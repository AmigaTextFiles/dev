@DATABASE "Bitmap"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Object: Bitmap"

@{b}@{u}OBJECT DOCUMENTATION@{uu}@{ub}
Name:      @{"BITMAP" LINK "Description"}
Date:      October 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 3@{uu}@{ub}
Added:   Bitmap->DrawPen()
         Bitmap->DrawUCPixel()
         Bitmap->DrawUCRPixel()
         Bitmap->PenUCPixel()
         Bitmap->ReadUCPixel()
         Bitmap->ReadUCRPixel()

@{b}@{u}CHANGES VERSION 2@{uu}@{ub}
Added:   Bitmap->Query()

Edited:  Bitmap->Planes
         Bitmap->AmtColours
         Bitmap->Palette
         Copy()

@{b}@{u}CHANGES VERSION 1@{uu}@{ub}
Added:   Bitmap->Copy()
         Bitmap->Flags
         Bitmap->Palette
         Bitmap->Restore
         CopyStructure()
         SaveToFile()
         More functions in support list.

Edited:  Bitmap->AmtColours
         Bitmap->LineMod
         Bitmap->Palette
         Bitmap->Parent
         Bitmap->PlaneMod
         Bitmap->Type
         Description information.

         A lot of the fields were missing the Type: definition in their
         headers, these have now been inserted.

@EndNode
---------------------------------------------------------------------------
@NODE "Description" "Object: Bitmap"

@{b}@{u}OBJECT@{uu}@{ub}
Name:    Bitmap
Version: 3
ID:      ID_BLITTER
Module:  @{"Blitter" LINK "GMSDev:AutoDocs/Blitter.guide/Functions"}
Include: @{"graphics/blitter.h" LINK "GMSDev:Includes/graphics/blitter.h/Main"}
Type:    Descriptor

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  Bitmap  provides  a  way  of  describing  an  area  of  memory that an
application  can  draw  to,  and/or  display  if  the data is held in video
memory.   Bitmaps  are most often used in the handling of Screens and Bobs,
and are required by most drawing functions such as DrawPixel().

Because Bitmaps are used by a large number of other objects, it's best that
you read as much of this document as possible.

@{b}@{u}ACTIONS@{uu}@{ub}
Actions supported by the Bitmap object are:

    @{"Clear()" LINK "GMSDev:AutoDocs/Kernel.guide/Clear()"}         - Clear a Bitmap's data area.
  * @{"Copy()" LINK "Bitmap_Copy()"}          - Make a copy of a Bitmap's image.
    @{"CopyStructure()" LINK "GMSDev:AutoDocs/Kernel.guide/CopyStructure()"} - Copy the field details of a Bitmap to another object.
    @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}          - Free a Bitmap object.
    @{"Get()" LINK "GMSDev:AutoDocs/Kernel.guide/Get()"}           - Get a new Bitmap object.
  * @{"Init()" LINK "Bitmap_Init()"}          - Initialise a Bitmap for use.
    @{"Query()" LINK "Bitmap_Query()"}         - Pre-initialises a Bitmap.
    @{"Read()" LINK "GMSDev:AutoDocs/Kernel.guide/Read()"}          - Read bytes from Bitmap->Data.
    @{"SaveToFile()" LINK "GMSDev:AutoDocs/Kernel.guide/SaveToFile()"}    - Save a Bitmap to a File.
    @{"Seek()" LINK "GMSDev:AutoDocs/Kernel.guide/Seek()"}          - Seek to a position in Bitmap->Data.
    @{"Write()" LINK "GMSDev:AutoDocs/Kernel.guide/Write()"}         - Write bytes to Bitmap->Data.

@{b}@{u}FUNCTIONS@{uu}@{ub}
Some of the functions supporting the Bitmap object are:

    @{"DrawPixel()"    LINK "GMSDev:AutoDocs/Blitter.guide/DrawPixel()"}
    @{"DrawRGBPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/DrawRGBPixel()"}
    @{"DrawUCPixel()"  LINK "GMSDev:AutoDocs/Blitter.guide/DrawUCPixel()"}
    @{"DrawLine()"     LINK "GMSDev:AutoDocs/Blitter.guide/DrawLine()"}
    @{"DrawRGBLine()"  LINK "GMSDev:AutoDocs/Blitter.guide/DrawRGBLine()"}
    @{"DrawUCLine()"   LINK "GMSDev:AutoDocs/Blitter.guide/DrawUCLine()"}
    @{"ReadPixel()"    LINK "GMSDev:AutoDocs/Blitter.guide/ReadPixel()"}
    @{"ReadRGBPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/ReadRGBPixel()"}

@{b}@{u}STRUCTURE@{uu}@{ub}
The Bitmap structure consists of the following fields:

    @{"AmtColours" LINK "BMP_AmtColours"} - Amount of colours available.
    @{"ByteWidth" LINK "BMP_ByteWidth"}  - Width in bytes.
    @{"Data" LINK "BMP_Data"}       - Pointer to Bitmap data area.
    @{"Flags" LINK "BMP_Flags"}      - Optional flags.
    @{"Height" LINK "BMP_Height"}     - Height in pixels.
    @{"LineMod" LINK "BMP_LineMod"}    - Line differential.
    @{"MemType" LINK "BMP_MemType"}    - Memory type to use in allocations.
    @{"Palette" LINK "BMP_Palette"}    - Palette of colours.
    @{"Parent" LINK "BMP_Parent"}     - Bitmap owner.
    @{"PlaneMod" LINK "BMP_PlaneMod"}   - Plane differential.
    @{"Planes" LINK "BMP_Planes"}     - Amount of bitplanes.
    @{"Restore" LINK "BMP_Restore"}    - Restore object for this Bitmap, if any.
    @{"Size" LINK "BMP_Size"}       - Total size of the Bitmap in bytes.
    @{"Type" LINK "BMP_Type"}       - Display type.
    @{"Width" LINK "BMP_Width"}      - Width in pixels.

    @{b}@{u}Internal Functions@{uu}@{ub}
    The following functions follow the same definitions as their
    counterparts in the blitter module, except you can call them directly
    (e.g. Bitmap->PenUCPixel(Bitmap,50,120)).  They provide an extremely
    fast way of drawing to a Bitmap, but be warned that only DrawPen()
    supports clipping.

    @{"DrawUCPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/DrawUCPixel()"}
    @{"DrawPen()" LINK "GMSDev:AutoDocs/Blitter.guide/DrawPen()"}
    @{"PenUCPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/PenPixel()"}
    @{"DrawUCRPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/DrawRGBPixel()"}
    @{"ReadUCPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/ReadPixel()"}
    @{"ReadUCRPixel()" LINK "GMSDev:AutoDocs/Blitter.guide/ReadRGBPixel()"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_AmtColours" "Bitmap: AmtColours"

@{b}@{u}FIELD@{uu}@{ub}
Name:        AmtColours
Type:        LONG
Inheritance: ScrType, Palette, Planes, User default.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies the total amount of colours available in the Bitmap.
If  you  set  this value to NULL then Init() will fill it in for you, via a
check to the Planes and Type fields.

Common values are:

  2, 4, 8, 16, 32, 64, 128, 256, 32767, 65535, 16777215

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_ByteWidth" "Bitmap: ByteWidth"

@{b}@{u}FIELD@{uu}@{ub}
Name:        ByteWidth
Type:        WORD
Inheritance: Width
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  ByteWidth  of  a Bitmap is calculated directly from the Bitmap's Width
and  Type settings.  Under no circumstances should you attempt to calculate
this value yourself, as it is heavily dependent on the Type.

Here are some of the calculations used to evaluate this field:

  Planar      = Width/8
  ILBM        = Width/8
  Chunky8     = Width
  Chunky16    = Width * 2
  True Colour = Width * 4

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Width" LINK "BMP_Width"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Data" "Bitmap: Data"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Data
Type:        APTR
Inheritance: Allocated on initialisation.
On Change:   Dynamic -- Parent objects do not accept changes though,
             and you cannot change this field if it was set by Init().
Status:      Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  points  directly  to  the  start  of  the  Bitmap's data area.
Allocating  your  own  Bitmap  memory  is  acceptable  if you use MEM_DATA,
MEM_VIDEO  or  MEM_BLIT  types.   However  it  is  often best for Init() to
allocate  the  correct  amount  of  memory for you by leaving this field as
NULL.

The amount of memory allocated is dependant on the Size field.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"MemType" LINK "BMP_MemType"}
       @{"Size"    LINK "BMP_Size"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Flags" "Bitmap: Flags"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Flags
Type:   LONG
Status: Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   field  contains  flags  that  affect  Bitmap  behaviour.   Currently
available flags are:

  @{u}BMF_BLANKPALETTE@{uu}
  Setting this flag causes the Bitmap to drive all Palette colours to black
  on initialisation.

  @{u}BMF_HAM@{uu}
  Sets  the Amiga only Hold And Modify mode.  The amount of colours you get
  is dependant on the amount of planes in the screen.  Works for PLANAR and
  ILBM Bitmaps only.

  @{u}BMF_EXTRAHB@{uu}
  A special Amiga mode allowing 64 colours on OCS, ECS and AGA chipsets.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Palette" LINK "BMP_Palette"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Height" "Bitmap: Height"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Height
Type:        WORD
Inheritance: Internal default.
Range:       1 - 32767
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  pixel  height  of  of  the Bitmap is specified here.  It has a minimum
value of 1 and a maximum value of 32,767.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Width" LINK BMP_Width}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_LineMod" "Bitmap: LineMod"

@{b}@{u}FIELD@{uu}@{ub}
Name:        LineMod
Type:        LONG
Inheritance: Calculated on Init().
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This field is a calculation of the distance between each line on the Bitmap
(the  line  differential).   For  PLANAR,  CHUNKY8, CHUNKY16 and TRUECOLOUR
types the value will match the ByteWidth field.  For ILBM the value will be
calculated from the formula:  ByteWidth * Planes.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"PlaneMod" LINK "BMP_PlaneMod"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_MemType" "Bitmap: MemType"

@{b}@{u}FIELD@{uu}@{ub}
Name:      MemType
Type:      LONG
Default:   MEM_DATA
On Change: Cannot change after initialisation.
Status:    Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field decides what type of memory will be allocated if Init() finds a
Data  pointer  of  NULL.   This  field  uses  the  standard memory flags of
MEM_DATA, MEM_VIDEO and MEM_BLIT.

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Palette" "Bitmap: Palette"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Palette
Type:        LONG *
Inheritance: Init()
On Change:   Dynamic
Status:      Read/Write

@{b}@{u}DESCRIPTION@{uu}@{ub}
A  palette  is an array of longwords that contain colour values in standard
RGB  format  ($AARRGGBB).   The  first  longword  must  have a header ID of
"PALETTE_ARRAY",  followed by the amount of values in the array.  Following
this  is the actual list itself - colour 0, then colour 1 and so on.  There
is no termination signal at the end of the list.

The following example is for a 32 colour palette:

  LONG Palette[] = {
    PALETTE_ARRAY,32,
    0x000000L,0x101010L,0x171717L,0x202020L,
    0x272727L,0x303030L,0x373737L,0x404040L,
    0x474747L,0x505050L,0x575757L,0x606060L,
    0x676767L,0x707070L,0x777777L,0x808080L,
    0x878787L,0x909090L,0x979797L,0xa0a0a0L,
    0xa7a7a7L,0xb0b0b0L,0xb7b7b7L,0xc0c0c0L,
    0xc7c7c7L,0xd0d0d0L,0xd7d7d7L,0xe0e0e0L,
    0xe0e0e0L,0xf0f0f0L,0xf7f7f7L,0xffffffL
  };

Palettes are created for all Bitmap types, including RGB based Bitmaps such
as  TRUECOLOUR.   This  is  because a number of drawing functions require a
palette  table  for  conversion  between  the  Bitmap  types.   By default,
TRUECOLOUR  and  CHUNKY16  Bitmaps will get a palette table of 256 colours,
which is set to the user selected colour values.

@{b}@{u}NOTE@{uu}@{ub}
Although the array is dynamic, parent objects such as the Screen need to be
notified if you want any altered colour values to be displayed.

The  alpha  channel ($AA) in the first byte is optional.  Remember that not
all  hardware  supports  the  alpha  channel,  and  in such cases it may be
ignored by the system.

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Parent" "Bitmap: Parent"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Parent
Type:        APTR
Inheritance: Init()
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This abstract field points to the parent of the Bitmap.  For example if the
Bitmap  is  owned by a Screen, then a pointer to that Screen will be placed
here.

Never attempt to set a parent by writing directly to this field.

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_PlaneMod" "Bitmap: PlaneMod"

@{b}@{u}FIELD@{uu}@{ub}
Name:        PlaneMod
Type:        LONG
Inheritance: Calculated on Init().
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies  the distance (in bytes) between each bitplane.  For
non-planar  types  such as CHUNKY8, CHUNKY16 and TRUECOLOUR this field will
actually  reflect  the  total size of the Bitmap.  The calculation used for
ILBM and PLANAR types is:

  ILBM   - ByteWidth
  PLANAR - ByteWidth * Height

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"LineMod" LINK "BMP_LineMod"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Planes" "Bitmap: Planes"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Planes (Depth, BitsPerPixel)
Type:        WORD
Inheritance: Internal default.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  specifies the amount of bitplanes (or bits per pixel depending
on  the  screen type) for the Bitmap.  The amount of colours you can use is
completely  dependent on this value.

For  ILBM or PLANAR Bitmaps you can calculate the amount of colours you get
with the formula 2^n, where n is the amount of planes.

For  chunky-based  bitmaps,  this  field  will be set to the total bits per
pixel  -  8,  15,  16,  24  or  32  depending  on the Type.  Note that if a
truecolour  Bitmap has a setting of 24, then the RGB colours are grouped in
sets of 3 bytes with no longword alignment.

@{b}@{u}SEE ALSO@{uu}@{ub}
Field: @{"Type" LINK "BMP_Type"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Restore" "Bitmap: Restore"

@{b}@{u}FIELD@{uu}@{ub}
Name:   Restore
Type:   struct Restore *
Status: Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  was  implemented so that it would be easy to reference Restore
objects  from  Bitmaps.   If  you  find  it  necessary to obtain a Bitmap's
Restore object, you can read its address from here.

@{b}@{u}SEE ALSO@{uu}@{ub}
Object: @{"Restore" LINK "GMSDev:AutoDocs/Objects/Restore.guide/Main"}

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Size" "Bitmap: Size"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Size
Type:        LONG
Inheritance: Width, Height, Depth
Status:      Read Only.

@{b}@{u}DESCRIPTION@{uu}@{ub}
You can read this field to find out how big the Bitmap is in bytes.

The calculation uses the formula:

     Size = Width * Height * Depth

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Type" "Bitmap: Type"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Type
Type:        WORD
Inheritance: User Default.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  field  defines  the  display  data type - either PLANAR, INTERLEAVED,
CHUNKY8,  CHUNKY16  or TRUECOLOUR.  Descriptions of these display types are
out  of  the scope of this document, so if you require detailed information
perhaps  you  should try the RKM's and other sources.  Note that for planar
bitmaps, the bitplanes are stored sequentially, one after the other.  There
is no scattering of planar bitplane memory.

If  you  set  this  field  to  NULL  then  Init() will initialise it to the
preferred  user  screen  type.  This is exceptionally useful, as some types
are faster than others for certain effects.  Remember that if you specify a
Type  that  is  unsupported  in  hardware, then it will have to be emulated
(slowing   things   down  considerably).   Type  independence  is  strongly
encouraged because of these reasons.

@{b}@{u}NOTE@{uu}@{ub}
The colour format for the CHUNKY16 mode is 5 red bits, 6 green bits, 5 blue
bits.   It is not too nice to deal with, but it gives you the full range of
65,535 colours.  Visually it looks like:

   %RRRR.RGGG.GGGB.BBBB

The  colour  fomat  for the TRUECOLOUR mode is 1 byte alpha channel, 1 byte
red,  1 byte green, 1 byte blue.  If the graphics chip does not support the
alpha channel, then it is simply ignored.  Visually this looks like:

   $AA.RR.GG.BB

@EndNode
---------------------------------------------------------------------------
@NODE "BMP_Width" "Bitmap: Width"

@{b}@{u}FIELD@{uu}@{ub}
Name:        Width
Type:        WORD
Inheritance: Internal default.
On Change:   Cannot change after initialisation.
Status:      Read/Init

@{b}@{u}DESCRIPTION@{uu}@{ub}
The  pixel  Width  of  the  Bitmap  is  specified  here.  The Width must be
divisible by 16, and cannot be any less than 16 pixels across.

@{b}@{u}SEE ALSO@{uu}@{ub}
Fields: @{"ByteWidth" LINK "BMP_ByteWidth"}
        @{"Height" LINK "BMP_Height"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Bitmap_Copy()" "Object: Bitmap"

@{b}@{u}ACTION@{uu}@{ub}
Name:   Copy(*Bitmap, *Object)
Object: Bitmap
Short:  Copies a Bitmap's image to another object.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will copy the image of a Bitmap (held in Bitmap->Data) to the
image of another object.

As  of  V1.1  this  action  also  features automatic clipping and remapping
features, depending on how the two Bitmaps relate to each other.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Copy()" LINK "GMSDev:AutoDocs/Kernel.guide/Copy()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Bitmap_Init()" "Object: Bitmap"

@{b}@{u}ACTION@{uu}@{ub}
Name:   APTR Init(*Bitmap, *Container)
Object: Bitmap
Short:  Initialises a Bitmap object.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action  will  initialise a Bitmap object so that it is ready for use.
If  the  Bitmap->Data  field has not been specified, a memory block will be
allocated  and  placed  in  this  field.   The  type of memory allocated is
dependent on the Bitmap->MemType field.  If you have not specified a memory
type,  you  will  get  a  default  of MEM_DATA.  For a video displayable or
drawable Bitmap use MEM_VIDEO, or if you want to draw from or to the Bitmap
then use MEM_BLIT.

For  this  function  to  work  properly you must have defined the Width and
Height fields of the Bitmap before initialisation.

@{b}@{u}SEE ALSO@{uu}@{ub}
Kernel: @{"Free()" LINK "GMSDev:AutoDocs/Kernel.guide/Free()"}
        @{"Init()" LINK "GMSDev:AutoDocs/Kernel.guide/Init()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Bitmap_Query()" "Object: Bitmap"

@{b}@{u}ACTION@{uu}@{ub}
Name:   LONG Query(*Bitmap)
Object: Bitmap
Short:  Queryialises a Bitmap object.

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  action will pre-initialise a Bitmap object so that all the fields are
filled  out.   It  performs exactly the same function as an Init(), but the
Bitmap->Data memory will not be allocated.

For  this  function  to  work  properly you must have defined the Width and
Height fields of the Bitmap before the Query().

@{b}@{u}SEE ALSO@{uu}@{ub}
Bitmap: @{"Init()" LINK "Bitmap_Init()"}

@EndNode
