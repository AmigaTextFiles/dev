@DATABASE "Default"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Objects Module"

@{b}@{u}MODULE DOCUMENTATION@{uu}@{ub}
Name:      @{"OBJECTS" LINK "Functions"}
Version:   1.0
Date:      March 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
Renamed: GetObject() to PullObject()
         GetObjectList() to PullObjectList()

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Renamed: ObjectBase to ObjectFile.

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "Object Functions"

 @{b}OBJECTS@{ub}
 @{"ObjectFile" LINK "GMSDev:AutoDocs/Objects/ObjectFile.guide/Description"}

 @{b}FUNCTIONS@{ub}
 @{"PullObject()"     LINK "PullObject()"}
 @{"PullObjectList()" LINK "PullObjectList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "PullObject()" "Objects: PullObject()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PullObject()
Short:    Finds an object by Name and returns it.
Synopsis: APTR PullObject(*ObjectFile [a0], BYTE *Name [a1]);

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  looks  for an object by Name, and then returns a pointer to
that  object's  address inside the ObjectFile.  This function does not make
copies  of  the  object,  so  any  changes  you  make will be affecting the
original   object   data.    This  should  be  fine  for  the  majority  of
circumstances.

If  the  object  is  a  code segment, you can execute it in assembler using
these instructions:

	CALL    PullObject
	tst.l   d0
	beq.s   .error
	move.l  d0,a0
	jsr     (a0)

NOTE:  If the code segment is in a different CPU instruction set, your call
will  be diverted to an emulator which will run the code safely.  (If there
is  no emulator available, PullObject() will fail safely so that the system
does not crash).

If  the object is an identifiable tag list (eg TAGS_BOB) then this function
will  preprocess  it  into its native structure.  Essentially, this is very
similar  to  calling the Get() function, with the fields already filled out
for you.  Tag based objects must be Free()'d later on.

@{b}@{u}INPUTS@{uu}@{ub}
ObjectFile
  Pointer to an initialised ObjectFile.

Name
  A  string  containing  the name of the object that you wish to find.  NB:
  The  "*" character is currently reserved, as wild-cards will be supported
  in future.

@{b}@{u}RESULT@{uu}@{ub}
Returns a pointer to the Object, or NULL if not found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Objects: @{"PullObjectList()" LINK "PullObjectList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "PullObjectList()" "Objects: PullObjectList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PullObjectList()
Short:    Get more than one object from an object file.
Synopsis: LONG PullObjectList(APTR ObjectFile [a0], APTR ObjectList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  acts the same way as PullObject() but will grab the objects
from  a  list  and  process  them one by one.  This is the fastest and most
convenient way to obtain a large set of objects.

Here is the ObjectList format:

	dc.l	OBJECTLIST,0
	dc.l	<Name>,<Object>	
	dc.l	...
	dc.l	LISTEND

<Name>  points  to  a character string correctly identifying an object, and
<Object> should be NULL as it will be initialised by this function.

@{b}@{u}INPUTS@{uu}@{ub}
ObjectFile
  An initialised ObjectFile

ObjectList
  A list of objects to initialise.

@{b}@{u}RESULT@{uu}@{ub}
Returns  ERR_OK if successful.  The ObjectList will be updated so that each
<Object> field points to the relevant object that was found.

@{b}@{u}SEE ALSO@{uu}@{ub}
Objects: @{"PullObject()" LINK "PullObject()"}

@EndNode
