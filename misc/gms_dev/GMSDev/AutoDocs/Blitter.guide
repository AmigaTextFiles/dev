@DATABASE "Blitter"
@AUTHOR   "Paul Manias"
@NODE     "Main" "Blitter Documentation"

@{b}@{u}MODULE DOCUMENTATION@{uu}@{ub}
Name:      @{"BLITTER" LINK "Functions"}
Version:   3.1
Number:    MOD_BLITTER
Date:      September 1998
Author:    Paul Manias
Copyright: DreamWorld Productions, 1996-1998.  All rights reserved.

@{b}@{u}CHANGES VERSION 3.1@{uu}@{ub}
Added:   DrawPen()
         SetPenShape()
         PenLinePxl()
         BlitArea()

Edited:  PenCircle()

@{b}@{u}CHANGES VERSION 3.0@{uu}@{ub}
Added:   PenCircle()
         PenEllipse()
         FlipHBitmap()
         FlipVBitmap()

Edited:  PenRect()

@{b}@{u}CHANGES VERSION 2.0@{uu}@{ub}
Added:   CopyLine()
         PenRect()
         PenLine()
         PenPixel()
         SetRGBPen()
         GetRGBPen()

Edited:  PenRect()

@{b}@{u}CHANGES VERSION 1.0@{uu}@{ub}
Added:   DrawRGBPixel()
         DrawRGBPixelList()
         DrawUCRGBPixel()
         DrawRGBLine()
         DrawUCRGBLine()
         ReadRGBPixel()

Edited:  DrawPixel()
         SetBobDimensions()
         SetBobFrames()
         ReadPixel()
         Introduction
         All *Line() functions support masks.

Removed: ClearBitmap()
         ClearBob()

@{b}@{u}CHANGES VERSION 0.9B@{uu}@{ub}
Removed: AllocBlitter()
         FreeBlitter()

Edited:  AllocBlitMem()
         FreeBlitMem()
         DrawBob()
         DrawBobList()
         DrawPixelList()
         CreateMasks()

@EndNode
---------------------------------------------------------------------------
@NODE "Functions" "Blitter Information"

 @{"INTRODUCTION" LINK "Introduction"}

 @{b}OBJECTS@{ub}
 @{"Bitmap"  LINK "GMSDev:AutoDocs/Objects/Bitmap.guide/Description"}
 @{"Bob" LINK "GMSDev:AutoDocs/Objects/Bob_MBob.guide/Description"}
 @{"MBob" LINK "GMSDev:AutoDocs/Objects/Bob_MBob.guide/Description"}
 @{"Restore" LINK "GMSDev:AutoDocs/Objects/Restore.guide/Description"}

 @{b}FUNCTIONS@{ub}
 @{"AllocBlitMem()" LINK "AllocBlitMem()"}
 @{"BlitArea()" LINK "BlitArea()"}
 @{"CopyBuffer()" LINK "CopyBuffer()"}
 @{"CreateMasks()" LINK "CreateMasks()"}
 @{"DrawBob()" LINK "DrawBob()"}
 @{"DrawBobList()" LINK "DrawBobList()"}
 @{"FlipHBitmap()" LINK "FlipHBitmap()"}
 @{"FlipVBitmap()" LINK "FlipVBitmap()"}
 @{"FreeBlitMem()" LINK "FreeBlitMem()"}
 @{"SetBobDimensions()" LINK "SetBobDimensions()"}
 @{"SetBobDrawMode()" LINK "SetBobDrawMode()"}
 @{"SetBobFrames()" LINK "SetBobFrames()"}

 @{b}@{u}Line Functions@{uu}@{ub}
 @{"CopyLine()" LINK "CopyLine()"}
 @{"DrawLine()" LINK "DrawLine()"}
 @{"DrawRGBLine()" LINK "DrawRGBLine()"}
 @{"DrawUCLine()" LINK "DrawUCLine()"}
 @{"DrawUCRGBLine()" LINK "DrawUCRGBLine()"}

 @{b}@{u}Pixel Functions@{uu}@{ub}
 @{"DrawPixel()" LINK "DrawPixel()"}
 @{"DrawPixelList()" LINK "DrawPixelList()"}
 @{"DrawRGBPixel()" LINK "DrawRGBPixel()"}
 @{"DrawRGBPixelList()" LINK "DrawRGBPixelList()"}
 @{"DrawUCPixel()" LINK "DrawUCPixel()"}
 @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}
 @{"DrawUCRGBPixel()" LINK "DrawUCRGBPixel()"}
 @{"ReadPixel()" LINK "ReadPixel()"}
 @{"ReadPixelList()" LINK "ReadPixelList()"}
 @{"ReadRGBPixel()" LINK "ReadRGBPixel()"}
 @{"ReadRGBPixelList()" LINK "ReadRGBPixelList()"}

 @{b}@{u}Pen based Functions@{uu}@{ub}
 @{"DrawPen()" LINK "DrawPen()"}
 @{"GetRGBPen()" LINK "GetRGBPen()"}
 @{"PenCircle()" LINK "PenCircle()"}
 @{"PenEllipse()" LINK "PenEllipse()"}
 @{"PenLine()" LINK "PenLine()"}
 @{"PenLinePxl()" LINK "PenLinePxl()"}
 @{"PenPixel()" LINK "PenPixel()"}
 @{"PenRect()" LINK "PenRect()"}
 @{"PenUCLine()" LINK "PenUCLine()"}
 @{"SetPenShape()" LINK "SetPenShape()"}
 @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "Introduction" "Blitter Module Overview"

@{b}
                         BLITTER SUPPORT OVERVIEW
@{ub}


The  blitter support is designed so that it can perform the task of drawing
images  to  screen as quickly and efficiently as possible.  The best way of
doing  this  is  to  provide you with a large amount of drawing options, so
that  you  can  specify  exactly  how  you  want an image to be drawn.  For
experienced  programmers this level of functionality is extremely useful in
providing  fast  and optimised drawing speeds.  If you're a beginner it may
take  some time before you learn what methods to use in each situation, but
with  a  little  practice you will know how to use the available options to
your  advantage.   Currently,  options  include blitting in lists, clipping
on/off,  restore and clear modes, masking on/off, mask generation, multiple
Bobs, setting clip areas, and others.

Many  parts of the blitter routines contain high-speed CPU assisted drawing
routines.   This works extremely well in mass drawing operations with about
20-30%  speed  up  on  my  '020  A1200+Fast  in  comparison to blitter-only
drawing.  On a '030 I would expect at least 40% faster operations, while on
'040  and  '060 we are probably looking at the CPU drawing 2 bobs while the
blitter draws 1.  I think Amiga owners with fast CPU's will appreciate this
feature,  while  '000  users  will not suffer because the blitter will take
most of the load for slow CPU's.

Enjoy  the  fast  drawing,  and if you have any good ideas for advancements
then send them all in.

@{b}@{u}NOTE@{uu}@{ub}
This document uses some terms that you need to know:

  @{b}@{u}RGB@{uu}@{ub}
  Stands for Red-Green-Blue, which are the three colours used to make up
  the 24-bit colour spectrum of 16 million colours.  An RGB value is a
  long-word that looks like this:

    $AA.RR.GG.BB

  AA is a byte for the alpha channel, this is a special byte that is
  supported by some graphics cards.  If the alpha byte is not supported in
  the hardware, this value has a default of 00.

  RR, GG, and BB are byte values for Red, Green and Blue respectively.

@EndNode
-----------------------------------------------------------------------------
@NODE "AllocBlitMem()" "Blitter: AllocBlitMem()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     AllocBlitMem()
Short:    Allocates a block of blitter memory.
Synopsis: APTR AllocBlitMem(LONG Size [d0], LONG Flags [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function allocates a block of memory suitable for the Blitter module.
On  current  Amiga's  it  will  only  grab  chip  mem,  but fast ram may be
supported in the future (for CPU blitting).

You can free the memory by calling FreeBlitMem() or FreeMemBlock().

@{b}@{u}NOTE@{uu}@{ub}
It  is possible to use video memory as blitter memory.  However the reverse
is  not  true,  because as mentioned above blitter memory can be in fast or
"program" ram, which is not good for video displays.

@{b}@{u}INPUTS@{uu}@{ub}
Size
  The Size of the memory to allocate.

Flags
  Special memory flags such as MEM_UNTRACKED.

@{b}@{u}RESULT@{uu}@{ub}
Returns a pointer to the allocated memory.  All blitter memory is formatted
with 0's when allocated.  If an error occurred, a NULL pointer is returned.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"FreeBlitMem()" LINK "FreeBlitMem()"}
Kernel:  @{"AllocMemBlock()" LINK "GMSDev:AutoDocs/Kernel.guide/AllocMemBlock()"}
         @{"FreeMemBlock()" LINK "GMSDev:AutoDocs/Kernel.guide/FreeMemBlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "BlitArea()" "Blitter: BlitArea()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     BlitArea() (V3.1)
Short:    Blits a rectangular area from one Bitmap to another.
Synopsis: void BlitArea(*SrcBitmap [a0], *DestBitmap [a1], WORD XStart [d0],
            WORD YStart [d1], WORD Width [d2], WORD Height [d3],
            WORD XDest [d4], WORD YDest [d5], WORD Remap [d6])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allows  you  blit  rectangular  blocks between Bitmaps.  It
performs  a straight copy only, but can perform remapping if the source and
destination are different.

@{b}@{u}INPUTS@{uu}@{ub}
SrcBitmap
  The Bitmap to copy the line from.

DestBitmap
  The destination Bitmap.  It is okay for the destination to be the same as
  the source (in fact the blit will go a lot faster this way).

XStart, YStart
  The (X,Y) position in the source Bitmap.

Width, Height
  The width and height of the area that you want to copy.

XDest, YDest
  The (X,Y) position in the destination Bitmap.

Remap
  Set to TRUE to enforce remapping, otherwise set to FALSE.  Note that in
  certain situations remapping will be forced anyway, e.g.  if the two
  bitmaps are not matching Types (TRUECOLOUR != CHUNKY8).

@EndNode
---------------------------------------------------------------------------
@NODE "ClearArea()" "Blitter: ClearArea()"

Not implemented yet.

@EndNode
---------------------------------------------------------------------------
@NODE "CopyLine()" "Blitter: CopyLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     CopyLine() (V2.0)
Short:    Copies a line from one Bitmap to another Bitmap.
Synopsis: void CopyLine(*SrcBitmap [a0], *DestBitmap [a1], WORD Srcy [d0],
            WORD Desty [d1], WORD AmtPixels [d2], WORD Remap [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  is  capable of copying single lines between Bitmaps even if
there  are  major differences between them, e.g.  ILBM -> TRUECOLOUR or 256
Colours -> 32 Colours.  If the Bitmaps are identical then a fast-copy will
be implemented over the slower conversion routines.

Remapping is also available, which you can recommend to this routine if you
know that the palettes are different.

@{b}@{u}INPUTS@{uu}@{ub}
SrcBitmap
  The Bitmap to copy the line from.

DestBitmap
  The destination Bitmap.  It is okay for the destination to be the same as
  the source (useful if you want to duplicate the same line a few times in
  a single Bitmap).

SrcY
  The line number to copy from the source.

DestY
  The destination line number.

AmtPixels
  The maximum amount of pixels that you want to be copied.  You cannot
  copy more pixels than what is available from the source (CopyLine() will
  automatically enforce this limitation).

Remap
  Set to either one of the following:

     0 = Do not remap.
     1 = Remap.

  Note that in certain situations remapping will be forced anyway, e.g.  if
  the two bitmaps are not matching Types (TRUECOLOUR != CHUNKY8).  If both
  of the Bitmaps are CHUNKY15 or better, remapping is not required and will
  therefore be ignored completely.

@EndNode
---------------------------------------------------------------------------
@NODE "CopyBuffer()" "Blitter: CopyBuffer()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     CopyBuffer()
Short:    Copy the contents from one screen buffer to another.
Synopsis: void CopyBuffer(*Screen [a0], WORD SrcBuffer [d0],
           WORD DestBuffer [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function copies the contents from one Screen buffer to another.  It is
intended for Screens that have been initialised with DBLBUFFER or TPLBUFFER
properties only (this function is useless for single buffered Screens).

Both  the  CPU  and  blitter  will  perform  the  copy action as quickly as
possible.

@{b}@{u}Example@{uu}@{ub}
This example would copy buffer #1 to buffer #2 of the Screen:

  CopyBuffer(Screen,BUFFER1,BUFFER2)

@{b}@{u}INPUTS@{uu}@{ub}
Screen
  Pointer to an initialised Screen structure.

SrcBuffer
  The buffer source ID, eg BUFFER1.

DestBuffer
  The buffer destination ID, eg BUFFER2.

@EndNode
-----------------------------------------------------------------------------
@NODE "CreateMasks()" "Blitter: CreateMasks()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     CreateMasks()
Short:    Creates or recreates all the masks for a Bob.
Synopsis: LONG CreateMasks(APTR Bob [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  creates  all  the  masks for a Bob or MBob.  If the Bob has
already been initialised, the old masks will be freed and a new set will be
created.

Masks  are  created by looking at the graphics data of the Bob in question.
Colour  0  is  always  considered  to  be  the  transparent  colour, so the
background pixels will always show through this colour.

If  you  set  the  FILLMASK  option  in  Bob->Attrib, masked pixels will be
created  where there are "holes" in the graphic.  For example if you draw a
character  with  black  eyes,  normally  you  would  end up seeing straight
through  them  and  into  the  background.  With FILLMASK the eyes would be
filled  in.   The filling routine is a simple linear filler only, so if you
want  to  generate  more complex masks it is best to draw the mask yourself
until a better algorithm is implemented.

@{b}@{u}INPUT@{uu}@{ub}
Bob
  Pointer to a Bob or MBob structure.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.  This call can fail for a number of reasons, but
more likely only if there is little memory left for mask allocation.

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawBob()" "Blitter: DrawBob()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawBob()
Short:    Draws a Blitter OBject directly to a bitmap.
Synopsis: void DrawBob(APTR Bob [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws a Bob or MBob to a Bitmap, according to the values in
the Bob/MBob structure.

The  methods used to draw the bob will remain unknown to you:  the blitter,
CPU,  or both devices may be used to get the image on screen.  Keep in mind
that  the  primary objective of this function is simply to get the image on
screen as quickly as possible with whatever means available.

@{b}@{u}FEATURES@{uu}@{ub}
The  blitter  functions have some special features that you should be aware
of,  if  you  are  interested  in  obtaining  maximum drawing speed.  Where
possible,  the  CPU will be used to draw when the blitter is not available.
It  will  also  assist  the  blitter  by drawing parts of the bob while the
blitter  draws  other  sections.   This parallel drawing gains considerable
speed-up for 68020 machines and upwards.

Blitting  images at alignments of 16 pixels will be sped up due to the fact
that no shifting is required.  If you keep this in mind you can use this to
your  advantage  in  certain  situations.   One  example  is  a  horizontal
shoot'em-up,  where  you could align the bullets of your ship to 16 pixels.
This  would  give  you  a  good  speed advantage when blitting many of such
objects.

More obvious features, such as blitting or clearing without masks will also
give a natural speed up.  You can often use the CLEAR mode if you know that
the  background  is  empty.   Use  MBob's whenever possible, and always use
Restore objects as a fast way to redraw or clear your backgrounds.

@{b}@{u}INPUT@{uu}@{ub}
Bob
  Pointer to an initialised Bob/MBob structure.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawBobList()" LINK "DrawBobList()"}
Kernel:  @{"Draw()" LINK "GMSDev:AutoDocs/Kernel.guide/Draw()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawBobList()" "Blitter: DrawBobList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawBobList()
Short:    Draws a list of Blitter OBjects onto a Bitmap.
Synopsis: void DrawBobList(APTR *BobList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  is  a  mass-drawing function that allows you to blit many Bobs from a
list onto their respective Bitmaps.  It handles all Bob structure types and
is the fastest way to process the drawing of many Bobs at any one time.

The  methods used to draw the bob will remain unknown to you:  the blitter,
CPU,  or both devices may be used to get the image on screen.  Keep in mind
that  the  primary objective of this function is simply to get the image on
screen as quickly as possible with whatever means available.

@{b}@{u}INPUTS@{uu}@{ub}
BobList
  Pointer to a LIST of Bob structures to draw.  Must be terminated by a
  LISTEND.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawBob()" LINK "DrawBob()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawLine()" "Blitter: DrawLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawLine()
Short:    Draws a line between two points on a Bitmap.
Synopsis: void DrawLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
            WORD XEnd [d3], WORD YEnd [d4], LONG Colour [d5],
            LONG Mask [d6])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Draws  a  line  between  (XStart,YStart)  and  (XEnd,YEnd).   This function
supports  clipping  for  lines that are outside of the Bitmap borders.  For
faster line drawing, use DrawUCLine() when you are 100% certain that a line
is within the Bitmap's borders.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap structure.

XStart,YStart
  The (X,Y) starting coordinates.

XEnd,YEnd
  The (X,Y) end coordinates.

Colour
  Line colour value.

Mask
  A 32 bit masking value.  Use 0xffffffff for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawUCLine()" LINK "DrawUCLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawPen()" "Blitter: DrawPen()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawPen() (V3.1)
Short:    Draws a pen to a Bitmap.
Synopsis: void DrawPen(*Bitmap [a0], WORD X [d1], WORD Y [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function draws a pen to coordinates (X,Y) on a Bitmap.  It is affected
by  functions  such  as  SetPenShape() and SetRGBPen() which manipulate the
size,  colour  and shape of a pen.  If your programming language is capable
of  doing  so,  consider  using  Bitmap->DrawPen() as it has a slight speed
advantage over this function.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

X, Y
  The (X,Y) coordinate for the pen.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"SetPenShape()" LINK "SetPenShape()"}
         @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawPixel()" "Blitter: DrawPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawPixel()
Short:    Draw a single pixel to a Bitmap.
Synopsis: void DrawPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2],
            LONG Value [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function draws a pixel to coordinates XCoord, YCoord on a Bitmap.  It
will  check the given coordinates to make sure that the pixel is inside the
Bitmap  area,  otherwise  it is not drawn.  If you do not require clipping,
use DrawUCPixel().

@{b}@{u}NOTES@{uu}@{ub}
Never  specify  a colour value that is beyond the amount of colours for the
Bitmap.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord, YCoord
  X and Y coordinate for the pixel.

Colour
  Colour number to use for the pixel.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixelList()" LINK "DrawPixelList()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}
         @{"PenPixel()" LINK "PenPixel()"}
@EndNode
---------------------------------------------------------------------------
@NODE "DrawPixelList()" "Blitter: DrawPixelList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawPixelList()
Short:    Draw a list of pixels to a Bitmap buffer.
Synopsis: void DrawPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws  an  entire  list  of pixels to a Bitmap, with border
clipping enabled.

This  is the second fastest way to draw many pixels without making multiple
library  calls.   For even faster drawing you may use DrawUCPixelList(), at
the risk of losing active clipping for the pixels.

The  Pixel  List  is  not  the standard "LIST" type.  Instead it looks like
this:

       dc.w  <AmtEntries>,<EntrySize>
       dc.l  <&Array>

Array: dc.w  <XCoord>,<YCoord>
       dc.l  <ColourNo>
       dc.w  ...
       dc.l  ...

Here is an example for blitting 3 pixels to a 4 colour Bitmap of dimensions
320x256.  Note the use of the PIXEL macro that helps to fit the three entry
fields on one line:

PixelList:
  dc.w   3,PXL_SIZEOF
  dc.l   .Values

.Values
  PIXEL  140,201,3
  PIXEL  036,165,1
  PIXEL  224,051,2

Here is the C version:

  struct PixelList PixelList = { /* Definition of pixel list header */
    3,
    sizeof(struct PixelEntry),
    Pixels
  };

  struct PixelEntry Pixels[3] = { /* The list of pixel values */
    140,201,3
    036,165,1
    224,051,2	  
  };

You  are also allowed to mutate each PixelEntry so that you can store extra
data  in  the  array.  For example, if you are writing a demo with flashing
lights/pixels,  then  it  would  be  most convenient if you could store the
on/off  state of each pixel in the same array.  To do this you will need to
increase the EntrySize field so that DrawPixelList() knows the true size of
each image entry.  Eg:

LightList:
        dc.w  3,PXL_SIZEOF+2
        dc.l  .Values

.Values PIXEL 140,201,3
        dc.w  0
        PIXEL 036,165,1
        dc.w  1
        PIXEL 224,051,2
        dc.w  0

You  can  also pull out the PixelEntry structure from the include files and
add extra fields to that if it is more convenient.

A  flag  exists for conveniently skipping pixel entries.  Specify SKIPPIXEL
in  the  X  coordinate  if you do not wish for a pixel to be drawn for that
entry.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

PixelList
  Points to a list of pixels, explained above.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawRGBLine()" "Blitter: DrawRGBLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawRGBLine()
Short:    Draws an RGB based line to a Bitmap.
Synopsis: void DrawRGBLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
            WORD XEnd [d3], WORD YEnd [d4], LONG RGB [d5], LONG Mask [d6])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will draw a line using a 24-bit RGB value as the colour.  A
conversion  process  will take place to find the best match to the provided
colour  (unless  you are in TRUECOLOUR mode).  Then the line itself will be
drawn.

This  function  supports  clipping for lines that are outside of the Bitmap
borders.   For  faster  line drawing, use DrawUCRGBLine() when you are 100%
certain that a line is within the Bitmap's borders.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart
  X starting coordinate.

YStart
  Y starting coordinate.

XEnd
  X end coordinate.

YEnd
  Y end coordinate.

RGB
  Line colour in RGB format.

Mask
  A 32 bit masking value.  Use 0xffffffff for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawLine()" LINK "DrawLine()"}
         @{"DrawUCRGBLine()" LINK "DrawUCRGBLine()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawRGBPixel()" "Blitter: DrawRGBPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawRGBPixel()
Short:    Draws an RGB based pixel to a Bitmap.
Synopsis: void DrawPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2],
            LONG RGB [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function draws a pixel to coordinates XCoord, YCoord on a Bitmap.  It
will  check the given coordinates to make sure that the pixel is inside the
Bitmap  area,  otherwise  it is not drawn.  If you do not require clipping,
use DrawUCRGBPixel().

Unlike  DrawPixel(),  this  function  requires  that  you specify the exact
Red-Green-Blue  settings  rather  than  a  palette  based value.  On a true
colour  Bitmap,  you  will  get the required result.  However palette based
Bitmap's, such as PLANAR and CHUNKY8 will automatically convert your colour
to the closest matching value in their palette table.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord
  X coordinate for pixel.

YCoord
  Y coordinate for pixel.

RGB
  Pixel colour in RGB format.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}
         @{"DrawUCRGBPixel()" LINK "DrawUCRGBPixel()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawRGBPixelList()" "Blitter: DrawRGBPixelList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawRGBPixelList()
Short:    Draw a list of pixels to a Bitmap buffer.
Synopsis: void DrawRGBPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws  an  entire  list  of pixels to a Bitmap, with border
clipping  enabled.   This  function  follows  the same functionality as the
original DrawPixelList(), but all the colours are specified in RGB format.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

PixelList
  Points to a list of pixels.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixelList()" LINK "DrawPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCLine()" "Blitter: DrawUCLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawUCLine()
Short:    Draws a line between two points on a Bitmap, without clipping
            checks.
Synopsis: void DrawUCLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
            WORD XEnd [d3], WORD YEnd [d4], LONG Colour [d5], LONG Mask [d6])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Draws  a  line  between (XStart,YStart) and (XEnd,YEnd).  The function does
not  perform  clipping  of  any sort, so it is imperative that you keep any
lines   that  you  draw  within  your  Bitmap  boundaries.   Otherwise  use
DrawLine().

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart,YStart
  The (X,Y) starting coordinate.

XEnd,YEnd
  The (X,Y) end coordinate.

Colour
  Line colour.

Mask
  A 32 bit masking value.  Use 0xffffffff for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawLine()" LINK "DrawLine()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCPixel()" "Blitter: DrawUCPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawUCPixel()
Short:    Draw a pixel to Bitmap without any clipping checks.
Synopsis: void DrawUCPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2],
            LONG Colour [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
Draws  a  pixel to coordinates (XCoord, YCoord) on a Bitmap.  This function
does  not  perform  clipping of any sort, and expects the coordinates to be
within the limits of the Bitmap.  If you require clipping, you will need to
use DrawPixel().

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord
  X coordinate for pixel.

YCoord
  Y coordinate for pixel.

Colour
  Colour number to use for the pixel.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}
         @{"DrawPixelList()" LINK "DrawPixelList()"}
         @{"DrawUCPixelList()" LINK "DrawUCPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "DrawUCPixelList()" "Blitter: DrawUCPixelList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawUCPixelList()
Short:    Draw an unclipped list of pixels to a Bitmap.
Synopsis: void DrawUCPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws  a  list  of unclipped pixels to a Bitmap.  This is a
special  function  that  is provided only for situations where you are 100%
certain that no pixels lie outside the Bitmap borders.  Because there is no
checking,  any  rogue  pixels  can  cause illegal memory over-writes, so be
careful!   The  advantage  of this function is that it is very fast at mass
pixel writes.

See @{"DrawPixelList()" LINK "DrawPixelList()"} for detailed information on how to form a PixelList.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

PixelList
  Points to a list of pixels, explained above.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}
Blitter: @{"DrawPixelList()" LINK "DrawPixelList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawUCRGBLine()" "Blitter: DrawUCRGBLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawUCRGBLine()
Short:    Draws an unclipped RGB based line to a Bitmap.
Synopsis: void DrawUCRGBLine(*Bitmap [a0], WORD XStart [d1], WORD YStart [d2],
            WORD XEnd [d3], WORD YEnd [d4], LONG RGB [d5], LONG Mask [d6])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will draw a line using a 24-bit RGB value as the colour.  A
conversion  process  will take place to find the best match to the provided
colour  (unless  you are in TRUECOLOUR mode).  Then the line itself will be
drawn.

The  function  does  not  perform clipping of any sort, so it is imperative
that  you  keep  any  lines  that  you  draw within your Bitmap boundaries.
Otherwise use DrawRGBLine().

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart,YStart
  The (X,Y) starting coordinate.

XEnd,YEnd
  The (X,Y) end coordinate.

RGB
  Line colour in RGB format.

Mask
  A 32 bit masking value.  Use 0xffffffff for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawRGBLine()" LINK "DrawRGBLine()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "DrawUCRGBPixel()" "Blitter: DrawUCRGBPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     DrawUCRGBPixel()
Short:    Draws an unclipped RGB based pixel to a Bitmap.
Synopsis: void DrawPixel(*Bitmap [a0], WORD X [d1], WORD Y [d2],
            LONG RGB [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws a pixel to coordinates X, Y on a Bitmap.  It does not
support pixel clipping.

This  function  requires that you specify the exact Red-Green-Blue settings
rather  than  a palette based value.  On a true colour Bitmap, you will get
the  required  result.   Palette based Bitmap's, such as PLANAR and CHUNKY8
will  automatically  convert  your  colour to the closest matching value in
their palette table.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

X, Y
  The (X,Y) coordinate for the pixel.

RGB
  Pixel colour in RGB format.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}
         @{"DrawRGBPixel()" LINK "DrawRGBPixel()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FlipHBitmap()" "Blitter: FlipHBitmap()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FlipHBitmap() (V3.0)
Short:    Flips a Bitmap around the horizontal axis.
Synopsis: void FlipHBitmap(*Bitmap [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function will flip an entire Bitmap around its horizontal axis.  This
may take some time, depending on the size of your Bitmap.

@{b}@{u}INPUT@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"FlipVBitmap()" LINK "FlipVBitmap()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FlipVBitmap()" "Blitter: FlipVBitmap()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FlipVBitmap() (V3.0)
Short:    Flips a Bitmap around the vertical axis.
Synopsis: void FlipVBitmap(*Bitmap [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  will  flip an entire Bitmap around its vertical axis.  This
may take some time, depending on the size of your Bitmap.

@{b}@{u}INPUT@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"FlipHBitmap()" LINK "FlipHBitmap()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "FreeBlitMem()" "Blitter: FreeBlitMem()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     FreeBlitMem()
Short:    Frees memory allocated by AllocBlitMem()
Synopsis: void FreeBlitMem(APTR MemBlock [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   function   frees   a   memory  block  that  has  been  allocated  by
AllocBlitMem().   If you pass this function a pointer to NULL then the call
will be ignored.

Any blitter memory that is allocated and not freed, will stay in the system
resource  list.   Such  bugs  will  cause the system to present you with an
error message when your program exits.

@{b}@{u}INPUT@{uu}@{ub}
MemBlock
  MemBlock allocated from AllocBlitMem().

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"AllocBlitMem()" LINK "AllocBlitMem()"}
Kernel:  @{"FreeMemBlock()" LINK "GMSDev:AutoDocs/Kernel.guide/FreeMemBlock()"}

@EndNode
---------------------------------------------------------------------------
@NODE "GetBmpType()" "Screens: GetBmpType()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "GetRGBPen()" "Blitter: GetRGBPen()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     GetRGBPen() (V2.0)
Short:    Gets the current pen setting from a Bitmap.
Synopsis: LONG GetRGBPen(*Bitmap [a0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  allows  you to find out the current pen colour of a Bitmap.
If  you  have  not  called SetRGBPen() on the Bitmap already, this function
will most probably return $000000 (black).

@{b}@{u}INPUT@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

@{b}@{u}RESULT@{uu}@{ub}
Returns the current pen colour in RGB format.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "GiveOSBlitter()" Blitter: GiveOSBlitter()"

Private.

@EndNode
---------------------------------------------------------------------------
@NODE "PenCircle()" "Blitter: PenCircle()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenCircle() (V3.0)
Short:    Draws a circle to a Bitmap.
Synopsis: void PenCircle(*Bitmap [a0], WORD X [d0], WORD Y [d1],
            WORD RadiusX [d2], WORD RadiusY [d3], WORD Fill [d4])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This function draws a circle around point (X,Y) with the given Radius.  You
can  choose  to  have  the  circle  filled, or just draw the outline of the
circle depending on your Fill setting (either TRUE or FALSE).

Note  that  when  drawing  unfilled circles, the DrawPen() function will be
used,  while  filled  circles  will  use  PenPixel().  This is an important
difference, as DrawPen() allows you draw circles of a thicker width through
the use of SetPenShape().

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

X, Y
  The (X,Y) coordinate that will be the center of the circle.

RadiusX, RadiusY
  The X and Y radius settings for the circle.

Fill
  Set to TRUE to fill the circle, otherwise FALSE.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"PenEllipse()" LINK "PenEllipse()"}
         @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenEllipse()" "Blitter: PenEllipse()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenEllipse() (V3.0)
Short:    Draws an ellipse to a Bitmap.
Synopsis: void PenEllipse(*Bitmap [a0], WORD X [d0], WORD Y [d1],
            WORD RadiusX [d2], WORD RadiusY, WORD Fill [d3])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws  an  ellipse around point (X,Y) with the given Radius
settings.   You  can  choose  to  have the ellipse filled, or just draw the
outline  of  the  ellipse  depending  on  your Fill setting (either TRUE or
FALSE).

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

X,Y
  The (X,Y) coordinate that will be the center of the ellipse.

RadiusX, RadiusY
  The radius settings of the ellipse.

Fill
  Set to TRUE to fill the ellipse, otherwise FALSE.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"PenCircle()" LINK "PenCircle()"}
         @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenLine()" "Blitter: PenLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenLine() (V2.0)
Short:    Draws a line across a Bitmap.
Synopsis: void PenLine(*Bitmap [a0], WORD XStart [d0], WORD YStart [d1],
            WORD XEnd [d2], WORD YEnd [d3], LONG Pattern [d4])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   function   draws   a  pen-based  line  between  (XStart,YStart)  and
(XEnd,YEnd).

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart,YStart
  The (X,Y) coordinate to start drawing the line from.

XEnd,YEnd
  The (X,Y) coordinate to end the line on.

Pattern
  A 32 bit masking value.  Use 0xffffffff (-1) for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"PenLinePxl()" LINK "PenLinePxl()"}
         @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenLinePxl()" "Blitter: PenLinePxl()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenLinePxl() (V3.1)
Short:    Draws a line across a Bitmap.
Synopsis: void PenLinePxl(*Bitmap [a0], WORD XStart [d0], WORD YStart [d1],
            WORD XEnd [d2], WORD YEnd [d3], LONG Pattern [d4])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This   function   draws   a  pen-based  line  between  (XStart,YStart)  and
(XEnd,YEnd).   It  will  use PenPixel() rather than DrawPen() to create the
line, so as to avoid shaped pens (which are a lot slower than pixels).

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart,YStart
  The (X,Y) coordinate to start drawing the line from.

XEnd,YEnd
  The (X,Y) coordinate to end the line on.

Pattern
  A 32 bit masking value.  Use 0xffffffff (-1) for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"PenLine()" LINK "PenLine()"}
         @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenUCLine()" "Blitter: PenUCLine()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenUCLine() (V2.0)
Short:    Draws a line across a Bitmap.
Synopsis: void PenUCLine(*Bitmap [a0], WORD XStart [d0], WORD YStart [d1],
            WORD XEnd [d2], WORD YEnd [d3], LONG Pattern [d4])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  draws  a  line  between  (XStart,YStart)  and  (XEnd,YEnd).
Clipping  is  not  active  for  this  function,  so  it  must be considered
dangerous - use it carefully.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XStart,YStart
  The (X,Y) coordinate to start drawing the line from.

XEnd,YEnd
  The (X,Y) coordinate to end the line on.

Pattern
  A 32 bit masking value.  Use 0xffffffff (-1) for an uninterrupted line.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenPixel()" "Blitter: PenPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenPixel() (V2.0)
Short:    Draws a single pixel to a Bitmap.
Synopsis: void PenPixel(*Bitmap [a0], WORD XCoord [d0], WORD YCoord [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function draws a pixel to coordinates XCoord, YCoord on a Bitmap.  It
will  check the given coordinates to make sure that the pixel is inside the
Bitmap area, otherwise it is not drawn.

Because  this  function uses pens, you will need to have called SetRGBPen()
before this function.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord
  X coordinate for pixel.

YCoord
  Y coordinate for pixel.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"DrawPixel()" LINK "DrawPixel()"}

@EndNode
---------------------------------------------------------------------------
@NODE "PenRect()" "Blitter: PenRect()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     PenRect() (V2.0)
Short:    Draws a single pixel to a Bitmap.
Synopsis: void PenRect(*Bitmap [a0], WORD X [d0], WORD Y [d2],
            WORD Width [d2], WORD Height [d3], WORD Fill [d4])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function will draw a rectangle to a Bitmap.  You can draw a rectangle
with  an area as big as you like, and there is a filling option available.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

X,Y
  The top left coordinate (X,Y) of the rectangle.

Width
  Width of the rectangle.

Height
  Height of the rectangle.

Fill
  Set to TRUE to fill the rectangle, otherwise use FALSE.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"SetRGBPen()" LINK "SetRGBPen()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ReadPixel()" "Blitter: ReadPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     ReadPixel()
Short:    Reads a pixel colour from position X/Y on a Bitmap.
Synopsis: LONG ReadPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  reads  a  pixel  from a Bitmap area and returns its closest
matching  colour  number in the Bitmap->Palette.  If you give this function
coordinates that lie outside of the Bitmap's area, it will return -1.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord
  The X coordinate to read the pixel from.

YCoord
  The Y coordinate to read the pixel from.

@{b}@{u}RESULT@{uu}@{ub}
The colour number or -1.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"ReadPixelList()" LINK "ReadPixelList()"}

@EndNode
---------------------------------------------------------------------------
@NODE "ReadPixelList()" "Blitter: ReadPixelList()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     ReadPixelList()
Short:    Reads a list of pixels from a Bitmap.
Synopsis: void ReadPixelList(*Bitmap [a0], *PixelList [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
You  can use this function for reading lots of pixel colours from a Bitmap.
All  you have to do is create a PixelList array and specify the coordinates
that you want to check.  You can leave the Colour field at NULL.

Then  call  ReadPixelList().   This function will take the given PixelList,
and  compare its coordinates to the Bitmap.  In doing so, it will write out
every  pixel  value that it finds, to the PixelList array.  Any coordinates
that  lie  outside  of the Bitmap's boundary will receive a colour value of
-1.

@{b}@{u}NOTE@{uu}@{ub}
This function has not been tested yet - maybe it works, maybe not!

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

PixelList
  Pointer to a pixel list array.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"ReadPixel()" LINK "ReadPixel()"}
         @{"ReadRGBPixelList()" LINK "ReadRGBPixelList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "ReadRGBPixel()" "Blitter: ReadRGBPixel()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     ReadRGBPixel()
Short:    Reads a pixel's RGB colour from position X/Y on a Bitmap.
Synopsis: LONG ReadRGBPixel(*Bitmap [a0], WORD XCoord [d1], WORD YCoord [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function  reads a pixel from a Bitmap area and returns its RGB colour
value.   If  you  give  this  function  coordinates that lie outside of the
Bitmap's area, it will return -1.

@{b}@{u}INPUTS@{uu}@{ub}
Bitmap
  Pointer to an initialised Bitmap.

XCoord
  The X coordinate to read the pixel from.

YCoord
  The Y coordinate to read the pixel from.

@{b}@{u}RESULT@{uu}@{ub}
The RGB colour value or -1.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"ReadPixelList()" LINK "ReadPixelList()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "ReadRGBPixelList()" "Blitter: ReadRGBPixelList()"

Not implemented yet.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobDimensions()" "Blitter: SetBobDimensions()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetBobDimensions()
Short:    Re-calculates the dimension fields for a Bob after one or more of
           them have changed.
Synopsis: void SetBobDimensions(*Bob [a1], WORD Width [d0], WORD Height [d1],
           WORD Depth [d2])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function will re-calculate the dimension fields for a Bob if you want
to  change  them.  By dimensions, this specifically means the Width, Height
and Depth (Planes) of the Bob.

@{b}@{u}NOTE@{uu}@{ub}
If  you are using generated masks and you change the size of your Bob, this
function  will  call CreateMasks() to cater for this change.  This may slow
the  function down slightly.  If the Bob is using the RESTORE mode then the
function  will  be  slowed  down  more  considerably  as all of the restore
buffers will need to be reallocated.

@{b}@{u}BUGS@{uu}@{ub}
Due  to  the complexity, the support for resizing Bobs with RESTORE mode is
not finished yet.

@{b}@{u}INPUT@{uu}@{ub}
Bob
  Pointer to the Bob to be updated.

Width
  The width of the Bob in pixels.  This argument follows the same rules as
  outlined in the Bob->Width field.  Use NULL if you do not want to alter
  the existing Width.

Height
  The height of the Bob in pixels.  Use NULL if you do not want to alter
  the existing Height.

Depth
  The depth of the Bob (valid values from 1 - 8).  This only applies to
  PLANAR Bob types.  Use NULL if you do not want to alter the existing
  Depth.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobDrawMode()" "Blitter: SetBobDrawMode()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetBobDrawMode()
Short:    Sets the drawing mode of a Bob.
Synopsis: LONG SetBobDrawMode(*Bob [a1], LONG Flags [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
If  you  want  to  change  the  drawing mode of a Bob that has already been
initialised, you will need to call this function.

@{b}@{u}BUGS@{uu}@{ub}
This  function  does  not  support  activation  of  the  RESTORE mode after
initialisation.

@{b}@{u}INPUT@{uu}@{ub}
Bob
  Pointer to the Bob that is to be updated.

Flags
  New settings for the Bob->Attrib field.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK if the new setting was successful.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetBobFrames()" "Blitter: SetBobFrames()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetBobFrames()
Short:    Recreates a Bob's direct lists after altering its frames.
Synopsis: LONG SetBobFrames(*Bob [a1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
If you make alterations to the GfxCoords or MaskCoords arrays for your Bob,
you  will need to call this function to have the graphics updated.  You may
also  need  to  call  CreateMasks() if the masks go out of whack due to the
changing of the coordinates.

@{b}@{u}NOTE@{uu}@{ub}
You  cannot  make  attempts to expand the amount of frames in your Bob with
this function.

@{b}@{u}INPUT@{uu}@{ub}
Bob
  Pointer to the Bob to be updated.

@{b}@{u}RESULT@{uu}@{ub}
Returns ERR_OK on success.

@EndNode
-----------------------------------------------------------------------------
@NODE "SetRGBPen()" "Blitter: SetRGBPen()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetRGBPen() (V2.0)
Short:    Sets a new pen colour for a Bitmap.
Synopsis: LONG SetRGBPen(*Bitmap [a0], LONG RGB [d0])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function will set the current pen colour for a Bitmap.  Once you have
called  this  function  you  can  then  use  pen  based  functions  such as
PenPixel(),  PenLine()  etc.   By  using  pens  you  can speed up graphical
operations that use the same colour.  For example, if you are going to draw
200  red  pixels,  it is much faster to call SetRGBPen() once and then call
PenPixel() 200 times, rather than 200 calls to DrawRGBPixel().  However, if
you were to draw 200 differently coloured pixels, DrawRGBPixel() would have
the advantage.

@{b}@{u}NOTE@{uu}@{ub}
When  using  shared  Bitmaps it is important that you have exclusive use of
any Bitmap object before using pen based functions.

@{b}@{u}INPUT@{uu}@{ub}
Bitmap
  The Bitmap to receive the new pen colour.

RGB
  The RGB pen setting.

@{b}@{u}RESULT@{uu}@{ub}
Returns the previous RGB pen setting.

@{b}@{u}SEE ALSO@{uu}@{ub}
Blitter: @{"GetRGBPen()" LINK "GetRGBPen()"}

@EndNode
-----------------------------------------------------------------------------
@NODE "SetPenShape()" "Blitter: SetPenShape()"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     SetPenShape() (V3.1)
Short:    Defines the shape of a Bitmap's pen.
Synopsis: void SetPenShape(*Bitmap [a0], WORD Shape [d0], WORD Radius [d1])

@{b}@{u}DESCRIPTION@{uu}@{ub}
This  function allows you to define the shape of a Bitmap's pen.  Currently
you  can  request circular, rectangular and pixel sized shapes.  The Radius
argument also allows you to specify how big the shape should be.

The   shape   of   the   pen  affects  DrawPen(),  PenLine(),  PenCircle(),
PenEllipse()   and   PenRect()   and   other   functions   which   use  the
Bitmap->DrawPen()  method.   Functions  that use Bitmap->PenPixel() are not
affected by the shape of a pen.

@{b}@{u}NOTE@{uu}@{ub}
When  using  shared  Bitmaps it is important that you have exclusive use of
any Bitmap object before using pen based functions.

@{b}@{u}INPUT@{uu}@{ub}
Bitmap
  The Bitmap to receive the new pen shape.

Shape
  Specifies the shape that you want for your pen.  Available shapes are
  PSP_CIRCLE, PSP_SQUARE and PSP_PIXEL.

Radius
  The radius of the pen, in pixels.

@EndNode
-----------------------------------------------------------------------------
@NODE "TakeOSBlitter()" "Blitter: TakeOSBlitter()"

Private.

@EndNode
-----------------------------------------------------------------------------
@NODE "()" "Blitter:"

@{b}@{u}FUNCTION@{uu}@{ub}
Name:     
Short:    
Synopsis:

@{b}@{u}DESCRIPTION@{uu}@{ub}

@{b}@{u}NOTE@{uu}@{ub}

@{b}@{u}INPUT@{uu}@{ub}

@{b}@{u}RESULT@{uu}@{ub}

@{b}@{u}SEE ALSO@{uu}@{ub}

@EndNode
