TABLE OF CONTENTS

freedb.library/ARexxHost
freedb.library/freedb.library
freedb.library/FreeDBAllocObjectA
freedb.library/FreeDBClearObject
freedb.library/FreeDBConfigChanged
freedb.library/FreeDBCreateAppA
freedb.library/FreeDBFreeConfig
freedb.library/FreeDBFreeMessage
freedb.library/FreeDBFreeObject
freedb.library/FreeDBGetDiscA
freedb.library/FreeDBGetLocalDiscA
freedb.library/FreeDBGetString
freedb.library/FreeDBHandleAbort
freedb.library/FreeDBHandleCheck
freedb.library/FreeDBHandleCommandA
freedb.library/FreeDBHandleCreateA
freedb.library/FreeDBHandleFree
freedb.library/FreeDBHandleSignal
freedb.library/FreeDBHandleWait
freedb.library/FreeDBMatchEnd
freedb.library/FreeDBMatchNext
freedb.library/FreeDBMatchStartA
freedb.library/FreeDBReadConfig
freedb.library/FreeDBReadTOCA
freedb.library/FreeDBSaveConfig
freedb.library/FreeDBSaveLocalDiscA
freedb.library/FreeDBSetDiscInfoA
freedb.library/FreeDBSetDiscInfoTrackA
freedb.library/freedb.library                        freedb.library/freedb.library

    FreeDB is a complete package to access freedb databases.
    See http://freedb.freedb.org for information about freedb.

    FreeDB includes:

    - freedb.library
      An AmigaDOS shared library

    - FreeDBXXX.mcc
      MUI custom classes from MUI programmers

    Note that freedb.library doesn't requires MUI. FreeDBXXX.mcc are
    built over freedb.library. If you like another GUI system you may
    use it.

    The porpoise of freedb.library is to retrieve CD-ROM discs
    information. FreeDB bases disc information upon the Table Of
    Contents (TOC) of a disc.

    The TOC contains 3 basic information:
    - The number of the tracks
    - The start second of each track
    - The total duration of the disc

    Based on these information there is calculated a so called
    DiscID. It is a ULONG represented as a 8 digit hex number.

    -----------------------------------
    A DiscID may represent many discs.
    -----------------------------------

    Another important concept is the category (categ) of a disc.
    It is a string representing the musical genre of the disc.

    ----------------------------------------------
    Discs in the same categ have different DiscID.
    ----------------------------------------------

    ------------------------------------------------------
    So a couple <categ,DiscID> may identify only one disc.
    ------------------------------------------------------

    Disc information are retrieved looking in a local cache. This is
    a drawer with sub drawers representing the categs. Any categ
    contains the local discs saved with their DiscID as name.

    To check if a disc is in the local cache, the DiscID of the disc
    is computed and then a file with that name is searched in any
    subdirectory (categ).

    At this point we may have 3 different results:

    - Found
      One and only one file named DiscID was found

    - MultiMathes
      More than one file named DiscID was found in different
      categs

    - NotFound
      No file found

    If "Found" we have reached our goal.

    If "MultiMatches" we have been informed by freedb.library about
    any categ where a file called DiscID was found. We have a set of
    couples <categ,DiscID> each representing a disc in our local cache.
    The user should be left to choose the right one, if any.

    If "NotFound" we have not that disc in our local cache: a freedb
    remote server must be queried.

    The server will give us the same result as above:
    - Found
    - MultiMathes
    - NotFound

    To handle all the above, 3 structures are needed:

    - TOC
      The Table Of Contents

    - DiscInfo
      Contains disc information

    - handle
      a transparent handler for remote connection
freedb.library/ARexxHost                             freedb.library/ARexxHost

   The ARexx host is described in the freedb_ARexx.guide .
freedb.library/FreeDBAllocObjectA                    freedb.library/FreeDBAllocObjectA

   NAME
    FreeDBAllocObjectA - allocates a FreeDB object

   SYNOPSIS
    ptr = FreeDBAllocObjectA(type,attrs);
    D0                       D0   A0

    APTR FREEDBAllocObject(ULONG,struct TagItem *);

    ptr = FreeDBAllocObject(type,tag1,...);
    D0                      D0   A0

    APTR FREEDBAllocObject(ULONG,Tag,...);

   FUNCTION
    This function actually allocates 2 structures: FREEDBS_TOC and
    FREEDBS_DiscInfo. Note that FREEDBS_TOC may be allocated by hands
    but FREEDBS_DiscInfo HAVE TO BE ALLOCATED with this function.

    type may be:

    - FREEDBV_Alloc_DiscInfo
      A FREEDBS_DiscInfo structure is returned.

    - FREEDBV_TOC
      A FREEDBS_TOC structure is returned.

    - FREEDBV_Alloc_DiscInfoTOC
      Both space for a FREEDBS_DiscInfo and FREEDBS_TOC is
      allocated. The pointer returned refers to FREEDBS_DiscInfo.
      To obtain the FREEDBS_TOC you have to use
      FREEDBM_GETTOCFROMDI() macro.

    The object allocated must be releases with FreeDBFreeObject().

    No attribute is actually defined, so let it NULL.

   INPUTS
    type  - which object to create
    attrs - a TagItem list

   RESULTS
    ptr - the object pointer or NULL


   SEE ALSO
    FreeDBFreeObject
    FreeDBClearObject
freedb.library/FreeDBClearObject                     freedb.library/FreeDBClearObject

   NAME
    FreeDBClearObject - clears a freedb.library object

   SYNOPSIS
    FreeDBClearObject(ptr);
                    A0

    FreeDBClearObject(APTR)

   FUNCTION
    Some freedb.library object must be cleared before reused.
    This applies especially to FREEDBS_DiscInfo which contains disc
    information allocated on the fly. Before reusing a
    FREEDBS_DiscInfo you must always clear it.

   INPUTS
    ptr - a freedb.library object

   RESULTS
    none

   SEE ALSO
    FreeDBAllocObjectA
    FreeDBFreeObject
freedb.library/FreeDBConfigChanged                   freedb.library/FreeDBConfigChanged

   NAME
    FreeDBConfigChanged - informs freedb.library about configuration
                          changes

   SYNOPSIS
    res = FreeDBConfigChanged();

    LONG FreeDBConfigChanged(void);

   FUNCTION
    freedb.library uses the environment file FreeDB/FreeDB as its
    configuration file.

    The file consists of lines in the form

    <OPTION> [args]

    Valid options are:

    - [USER/A]
      <name>

      Example: "alfie"

      The freedb protocol define a user name to be specified;
      freedb.library uses:
      1. The name specified in its configuration file
      2. The static string "ILoveNewYork"

    - [ROOTDIR/A]
      <path>

      The path to the freedb drawer. Default is "FreeDB:"

    - [PROXY/A,PROXYPORT/K/N,USEPROXY/S]
      <proxy> [proxyPort/N] [USEPROXY]

      Example: "www.proxy.org PROXYPORT 8080 USEPROXY"
               "www.proxy.org:8080"

      Specifies a proxy. Default for PROXYPORT is 8080.

    - [SITE/A/K,PORT/K/N,CGI/K,LAT/K,LONG/K,DESC/F]
      <site> [port/N] [cgi] [lat] [long] [desc/F]

      Example: "freedb.freedb.de"
               "freedb.freedb.de:80"

      Specifies a site entry.
      More than a SITE entry may be present.

      Default for PORT is 80.
      Default for CGI is /~cddb/cddb.cgi .
      Default for LAT (latitude) is "".
      Default for LONG (longitude) is "".
      Default for DESC is "".

    - [ACTIVESITE/A/K,PORT/K/N,CGI/K,LAT/K,LONG/K,DESC/F]
      <site> [port/N] [cgi] [lat] [long] [desc/F]

      As SITE but specifies the site to use. If no ACTIVE site is
      present, the only static site freedb.freedb.org:80 is used.

    - [EMAIL/A/K]
      <email>

      Your email in the format user@host . It must be supplied if
      you want submit discs to a freedb server.

    Anytime the configuration is changed, you have to inform
    freedb.library calling this function.

   INPUTS
    none

   RESULTS
    res - TRUE the new configuration was read. FALSE something wrong,
          still using old.

   SEE ALSO
    FreeDBFreeConfig
    FreeDBReadConfig
    FreeDBSaveConfig
freedb.library/FreeDBCreateAppA                      freedb.library/FreeDBCreateAppA

   NAME
    FreeDBCreateAppA - starts an istance of FreeDB

   SYNOPSIS
    proc = FreeDBCreateAppA(attrs);
    D0                     A0

    struct Process * FreeDBCreateAppA(struct TagItem *);

    proc = FreeDBCreateApp(Tag tag1,...);
    D0                     A0

    struct Process * FreeDBCreateApp(Tag,...);

   FUNCTION
    Starts an istance of FreeDB. This function is included in freedb.library since
    release 3 to make easier for application using the FreeDB package to search
    for disc information. My intent is:
    "Your application should just check for local information.
     If the disc is not found or there are multi matches, an istance of FreeDB
     should be run via this function, to make the user select the right entry
     or download disc information from a freedb server".

    attrs are:

    - FREEDBA_Device (STRPTR)
      The device to use e.g. "scsi.device"

    - FREEDBA_DeviceName (STRPTR)
      A mountend device name, e.g. "CD0"

    - FREEDBA_Unit (UWORD)
      Unit for FREEDB_Device

    - FREEDBA_Lun (UBYTE)
      Logical unit number

    - FREEDBA_Prg (STRPTR)
      The program that is using freedb.library

    - FREEDBA_Ver (STRPTR)
      The version of the program that is using freedb.library

    - FREEDBA_UseSpace (BOOL)
      Use the Space pic if any

    - FREEDBA_NoRequester (BOOL)
      Don't show requester when locking RootDir

    - FREEDBA_GetDisc (BOOL)
      Immediatly try to look up information

    - FREEDBA_Local (BOOL)
      If FREEDBA_GetDisc, do it just in the local caches

    - FREEDBA_Remote (BOOL)
      If FREEDBA_GetDisc, ignore the local cache

   INPUTS
    attrs - a TagItem list

   RESULTS
    proc - the struct Process pointer of the created istance of FreeDB,
           so NULL if the function failed

   SEE ALSO
freedb.library/FreeDBFreeConfig                      freedb.library/FreeDBFreeConfig

   NAME
    FreeDBFreeConfig - frees a freedb.library configuration

   SYNOPSIS
    FreeDBFreeConfig(conf);
                   A0

    FreeDBFreeConfig(struct FREEDBS_Config *);

   FUNCTION
    Frees a freedb.library configuration obtained via
    FreeDBReadConfig().

   INPUTS
    ptr - a freedb.library configuration

   RESULTS
    none

   SEE ALSO
    FreeDBConfigChanged
    FreeDBReadConfig
    FreeDBSaveConfig
freedb.library/FreeDBFreeMessage                     freedb.library/FreeDBFreeMessage

   NAME
    FreeDBFreeMessage - frees a hook message

   SYNOPSIS
    FreeDBFreeMessage(msg);
                    A0

    FreeDBFreeMessage(APTR);

   FUNCTION
    Frees a hook message. When you use the attributes
    FREEDBA_MultiHook FREEDBA_SitesHook FREEDBA_LsCatHook, your hook
    function will receive a hook message, the type of which depends on
    the context. When you are done with it, you have to use this
    function to free it. I am very paranoid with memory fragmentation
    and this function is the result of that.

   INPUTS
    msg - the message to free

   RESULTS
    none

   SEE ALSO
    none
freedb.library/FreeDBFreeObject                      freedb.library/FreeDBFreeObject

   NAME
    FreeDBFreeObject - Frees a freedb.library object

   SYNOPSIS
    FreeDBFreeObject(ptr);
                    A0

    FreeDBFreeObject(APTR)

   FUNCTION
    Frees a freedb.library object allocated via FREEDBAllocObject().

   INPUTS
    ptr - a freedb.library object

   RESULTS
    none

   SEE ALSO
    FreeDBAllocObjectA
    FreeDBClearObject

freedb.library/FreeDBGetDiscA                        freedb.library/FreeDBGetDiscA

   NAME
    FreeDBGetDiscA - looks up a disc

   SYNOPSIS
    res = FreeDBGetDiscA(attrs);
    D0                 A0

    LONG FreeDBGetDiscA(struct TagItem *);

    res = FreeDBGetDiscA(Tag1,...);
    D0                 A0

    LONG FreeDBGetDiscA(Tag,...);

   FUNCTION
    Looks up a disc, first searching in the local cache and then
    going online if no local entry is found.

    The attributes defined are the same of FreeDBGetLocalDisc() and
    FreeDBHandleCommand() plus:

    - FREEDBA_Handle (APTR)
      If no local entry is found, the function searches on the remote
      server. To do that it simply creates a handler via
      FreeDBHandleCreate(), starts the handle with

      FreeDBHandleCommand(handle,FREEDBV_Command_QueryRead,attrs)

      and returns FREEDBV_GetDisc_Remote.

      You may specify an already allocated handle with this tag.
      If it is supplied this is used.

    - FREEDBA_HandlePtr (APTR *)
      See FREEDBA_Handle. If FreeDB_Handle is not supplied a brand
      new handle is created and returned in this pointer.

    - FREEDBA_ErrorPtr (LONG *)
      The result from sub calls.

    - FREEDBA_Locale (BOOL)
      If supplied only local cache is searched.

    - FREEDBA_Remote (BOOL)
      If supplied local cache is not used.

   INPUTS
    attrs - a TagItem list

   RESULTS
    res - one of:

    - FREEDBV_GetDisc_LocalFound
      A disc was found in the local cache

    - FREEDBV_GetDisc_LocalMulti
      More that a matching entry was found in the local cache.
      Note that you may specify the tag FREEDBA_MultiHook to
      receive multi entries. The same hook will be used to
      receive remote multi entries. Note that a local multi
      match may be recognized via the code field of the
      FREEDBS_MultiMatch message which is set to 0.

    - FREEDBV_GetDisc_Remote
      No local entry found. Searching in the remote database.

    - FREEDBV_GetDisc_Error
      An error occurred. Find the reason in FREEDBA_Error if
      supplied.

   SEE ALSO
    FreeDBGetLocalDisc
    FreeDBHandleCreate
    FreeDBHandleCommand
freedb.library/FreeDBGetLocalDiscA                   freedb.library/FreeDBGetLocalDiscA

   NAME
    FreeDBGetLocalDiscA - searches for a disc in the local cache

   SYNOPSIS
    err = FreeDBGetLocalDiscA(attrs);
    D0                      A0

    ULONG FreeDBGetLocalDiscA(struct TagItem *)

    err = FreeDBGetLocalDisc(tag1,...);
    D0                     A0

    ULONG FreeDBGetLocalDisc(Tag,...)

   FUNCTION
    Searches for a disc in the local cache. A disc in the local cache
    may be looked up via:
        1. The couple <categ/DiscID>
        2. A DiscID

    The couple <categ/DiscID> may only refers an unique disc.
    A DiscID may refer to more than a disc.

    The categ of a disc may be supplied via:
    - FREEDBA_Categ
    - The field categ of the FREEDBS_DiscInfo defined
      in FREEDBA_DiscInfo

    The DiscID may be defined via:
    - FREEDBA_DiscID attribute
    - The discID field of the FREEDBS_TOC defined in
      FREEDBS_TOC attribute
    - The discID field of the FREEDBS_DiscInfo defined in
      FREEDBS_DiscInfo attribute

    The attributes defined are:

    - FREEDBA_Categ (STRPTR)
      May supply a categ here

    - FREEDBA_DiscID (LONG)
      May supply a DiscID here

    - FREEDBA_DiscInfo (FREEDBS_DiscInfo * )
      This has to be present because it is used to store the disc
      info. It must be a brand new or cleared one. Only the fields
      discID and categ may be used to pass the discID to search for.

    - FREEDBA_TOC (FREEDBS_TOC *)
      As in any freedb.library function, TOC rules over DiscInfo !

    - FREEDBA_MultiHook
      A struct Hook * that will be called for each entry found.
      The hook is called with:

          A0  struct Hook *
          A1  struct FREEDBS_MultiHookMessage *
          A2  NULL

      The FREEDBS_MultiHookMessage is filled as:
      - code
        0 for local multi matches

      - categ
        the categ of the disc

      - discID
        the discID note that this is always the samed
        discid your are searching for. Different disc
        id may be only supplied when remote searching
        as results of fuzzy matches.

      - discIDString
        facility

      - artist
        the artist that made this masterpiece

      - title
        the title of the disc

   - FREEDBA_NoRequester (BOOL)
     Don't show requester while locking the rootdir.

    The function may fail iff:

    - FREEDBV_Err_NoParms
      There were not supplied enough arguments to perform the
      operation: You must supply a FREEDBS_DiscInfo * in
      FREEDBA_DiscInfo and a valid DiscID via FREEDA_DiscID
      or in the discID field of the FREEDBS_TOC * as
      defined in FREEDBA_TOC or in the discID field of the
      FREEDBS_DiscInfo * as defined in FREEDBA_DiscInfo.

    - FREEDBV_Err_NoMem
      There is not enough memory available.

    - FREEDBV_Err_NoRootDir
      Rootdir can't be locked

    - FREEDBV_Err_NotFound
      No disc found

    - FREEDBV_Err_Multi
      Many discs found.

   INPUTS
    attrs - a TagItem list

    RESULTS
     res - 0 ok, >0 failure

   SEE ALSO
    none
freedb.library/FreeDBGetString                       freedb.library/FreeDBGetString

   NAME
    FreeDBGetString - gets a localized freedb.library string

   SYNOPSIS
    string = FreeDBGetString(id);
    d0                     d0

    STRPTR FreeDBGetString(LONG);

   FUNCTION
    Returns a localized freedb.library string.


   INPUTS
    id - the id of the string to get e.g. FREEDBV_Err_NoMem or
         FREEDBV_Handle_Status_Done

   RESULTS
    string - the localized string or NULL

   SEE ALSO
    none
freedb.library/FreeDBHandleAbort                     freedb.library/FreeDBHandleAbort

   NAME
    FreeDBHandleAbort - aborts an async handle operation

   SYNOPSIS
    FreeDBFreeDBHandleAbort(handle);
                        A0

    FreeDBHandleAbort(APTR);

   FUNCTION
    Aborts an async operation. It is safe to call this function
    on a handle that is not currently doing anything.

   INPUTS
    handle - the handle to abort

   RESULTS
    none

   SEE ALSO
    FreeDBHandleCheck
    FreeDBHandleCommandA
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleCheck                     freedb.library/FreeDBHandleCheck

   NAME
    FreeDBHandleCheck - checks for a handle completion

   SYNOPSIS
    res = FreeDBHandleCheck(handle);
    D0                    A0

    res = FreeDBHandleCheck(APTR);

   FUNCTION
    Checks if a handle completed its operation. It is safe to call
    this function on a handle that is not currently doing anything.

   INPUTS
    handle - the handle to abort

   RESULTS
    res - a boolean to indicate if the operation completed.

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCommandA
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleCommandA                  freedb.library/FreeDBHandleCommandA

   NAME
    FreeDBHandleCommandA - starts a handle operation

   SYNOPSIS
    res = FreeDBHandleCommandA(handle,command,attrs);
    D0                    A0

    LONG FreeDBHandleCommandA(APTR,ULONG,struct Tagitem *);

    res = FreeDBHandleCommand(handle,command,tag1,...);
    D0                      A0

    LONG FreeDBHandleCommandA(APTR,ULONG,Tag,...)

   FUNCTION
    After you created a handle with FreeDBHandleCreate(), you may ask
    the handle to perform an action via this function. An action is a
    command.

    The commands defined are:

    - FREEDBV_Command_QueryRead
      Query the site for the disc represented by FREEDBA_TOC.
      If one and only one entry is found, Read the site for the disc
      info and writes the result in FREEDBA_DiscInfo

      attrs are:

        - FREEDBA_DiscInfo (struct FREEDBS_DiscInfo *)
          Required

        - FREEDBA_TOC (struct FREEDBS_TOC *)
          Required

        - FREEDBA_StatusHook (struct Hook *)
          Called as:
              A0: struct Hook *hook
              A1: ULONG status,
              A1: APTR handle

        - FREEDBA_MultiHook
          Called as:
              A0: struct Hook *hook
              A1: struct FREEDBS_MultiHookMessage *msg
              A2: APTR handle

              msg is filled as
              - code:   210 or 211
              - categ:  the category
              - discID: the DiscID
              - artist: the artist
              - title:  the title
              - file:   NULL

    - FREEDBV_Command_Query
      attrs are:

       - FREEDBA_DiscInfo (struct FREEDBS_DiscInfo *)
         Required

       - FREEDBA_TOC (struct FREEDBS_TOC *)
         Required

       - FREEDBA_StatusHook (struct Hook *)

       - FREEDBA_MultiHook (struct Hook *)

    - FREEDBV_Command_Read
      attrs are:

       - FREEDBA_DiscInfo (struct FREEDBS_DiscInfo *)
         Required

       - FREEDBA_TOC (struct FREEDBS_TOC *)

       - FREEDBA_StatusHook

    - FREEDBV_Command_Sites
      attrs are:

       - FREEDBA_SitesHook
         Called as:
              A0: struct Hook *hook
              A1: struct FREEDBS_SiteHookMessage *msg
              A2: APTR handle

       - FREEDBA_StatusHook

    - FREEDBV_Command_LsCat
      attrs are:

       - FREEDBA_LsCatHook
         Called as:
              A0: struct Hook *hook
              A1: STRPTR
              A2: APTR handle

       - FREEDBA_StatusHook

    - FREEDBV_Command_Submit
      attrs are:

       - FREEDBA_TOC
         Required

       - FREEDBA_DiscInfo
         Required

       - FREEDBA_Email

       - FREEDBA_Prg
         The name of the prg that is submitting

       - FREEDBA_Ver
         The version of the prg that is submitting

       - FREEDBA_StatusHook

    General attrs are:

    - FREEDBA_Categ
      Use this instead of that one in DiscInfo

    - FREEDBA_DiscID
      Use this instead of that one in TOC

    - FREEDBA_Host
      Use this host (Default the configuration active one)

    - FREEDBA_HostPort
      Use this host port (Default the configuration active host one)

    - FREEDBA_CGI
      Use this CGI path (Default the configuration active host one)

    - FREEDBA_Proxy
      Use this proxy (Default the configuration one)

    - FREEDBA_ProxyPort
      Use this proxy port (Default the configuration proxy one)

    - FREEDBA_UseProxy
      Use the proxy (Default the configuration value)

    - FREEDBA_User
      Use this user (Default the configuration one)

    - FREEDBA_Email
      Use this email (Default the configuration one)

    - FREEDBA_Prg
      Use this prg (Default "freedb.library")

    - FREEDBA_Ver
      Use this ver (Default the current freedb.library version)

    The function may fail if:

        - FREEDBV_Err_NoMem
          There is not enough memory or a signal can't be allocated.

        - FREEDBV_Err_NoParms
          You missed something important.

        - FREEDBV_Err_ServerError
          Error returned from server

        - FREEDBV_Err_HTTPError
          Invalid HTTP answer

        ...

   INPUTS
    handle  - a handle
    command - the command to invoke on handle
    attrs   - a TagItem list

   RESULTS
    res - 0 ok, >0 failure

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCheck
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleCreateA                   freedb.library/FreeDBHandleCreateA

   NAME
    FreeDBFreeDBHandleCreateA - create a handle

   SYNOPSIS
    handle = FreeDBHandleCreateA(attrs);
    D0                         A0

    APTR FreeDBHandleCreateA(struct Tagitem *);

    handle = FreeDBHandleCreate(tag1 , ...);
    D0                        A0

    APTR FreeDBHandleCreate(Tag,...);

   FUNCTION
    When you want to communicate with a FreeDB servers, you have to
    call this function and create a handle. A handle is an opaque
    handler that represents a Process that will communicate with the
    FreeDB server. Normally, what you do is something like:

    if (handle = FreeDBHandleCreate(FREEDBA_Error,&err,TAG_DONE))
    {
        if (!(err = FreeDBHandleCommand(handle,FREEDBV_Command_QueryRead,
                                             FREEDBA_TOC,      toc,
                                             FREEDBA_DiscInfo,   di,
                                             FREEDBA_StatusHook, &statusHook,
                                             FREEDBA_MultiHook,  &multiHook,
                                             TAG_DONE)))
        {
            ULONG hsignal, signals;

            hsignal = FreeDBHandleSignal(handle);
            signals = hsignal|SIGBREAKF_CTRL_C;

            while (1)
            {
                ULONG recv;

                recv = Wait(signals);

                if (recv & SIGBREAKF_CTRL_C)
                {
                    FreeDBHandleAbort(handle);
                    break;
                }

                if ((recv & hsignal) && FreeDBHandleCheck(handle)) break;
            }

            err = FreeDBHandleResult(handle);
            FreeDBHandleFree(handle);
            ...
        }
        ...
    }
    ...

    Create the handle with FreeDBHandleCreate(), invoke a command on
    it with FreeDBHAndleCommand() and wait for events.

    No attributes is actually defined;

   INPUTS
    attrs - a TagItem list

   RESULTS
    res - a handle

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCheck
    FreeDBHandleCommandA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleFree                      freedb.library/FreeDBHandleFree

   NAME
    FreeDBHandleFree - frees a handle

   SYNOPSIS
    FreeDBHandleFree(handle);
                   A0

    FreeDBHandleFree(APTR);

   FUNCTION
    Frees a handle. It is safe to call this function
    on a handle that is busy.

   INPUTS
    handle - the handle to free

   RESULTS
    none

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCheck
    FreeDBHandleCommandA
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleSignal                    freedb.library/FreeDBHandleSignal

   NAME
    FreeDBHandleSignal - returns the exec.library signals of a handle

   SYNOPSIS
    sig = FreeDBHandleSignal(handle);
    D0                     A0

    LONG FreeDBHandleSignal(APTR);

   FUNCTION
    A handle uses a signal for notification of events. This function
    may be used to obtain this signal.

   INPUTS
    handle - the handle to obtain the signal of

   RESULTS
    sig - the signal of the handle

   EXAMPLE
    sig = FreeDBHandleSignal(handle)
    recv = Wait(sig|other_signals);

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCheck
    FreeDBHandleCommandA
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
    FreeDBHandleWait
freedb.library/FreeDBHandleWait                      freedb.library/FreeDBHandleWait

   NAME
    FreeDBHandleWait - waits for a handle event

   SYNOPSIS
    res = FreeDBHandleWait(handle);
    D0                   A0

    LONG FreeDBHandleWait(APTR);

   FUNCTION
    Waits for an event an a handle. If the handle has done its
    operation, or it is currently doing nothing, this function
    returns immediately, otherwise it waits for something to happen
    on the handle.

   INPUTS
    handle - the handle to wait for event on

   RESULTS
    res - the result of the handle async operation

   EXAMPLE
    sig = FreeDBHandleWait(handle)
    recv = Wait(sig|other_Waits);
    if (recv & sig)
    {
        res = FreeDBHandleWait(handle);
        ...
    }

   SEE ALSO
    FreeDBHandleAbort
    FreeDBHandleCheck
    FreeDBHandleCommandA
    FreeDBHandleCreateA
    FreeDBHandleFree
    FreeDBHandleSignal
freedb.library/FreeDBMatchEnd                        freedb.library/FreeDBMatchEnd

   NAME
    FreeDBMatchEnd - frees match resources

   SYNOPSIS
    FreeDBMatchEnd(match);
                   A0

    FreeDBMatchEnd(APTR);

   FUNCTION
    When you are done with the match returned by FreeDBMatchStartA(), you
    have to free the resources allocated via this function.

   INPUTS
    match - the result of FreeDBMatchStartA()

   RESULTS
    none

   SEE ALSO
    FreeDBMatchStartA
    FreeDBMatchNext
freedb.library/FreeDBMatchStartA                     freedb.library/FreeDBMatchStartA

   NAME
    FreeDBMatchStartA - creates a discs match

   SYNOPSIS
    match = FreeDBMatchStartA(attrs);
    D0                        A0

    APTR FreeDBMatchStartA(struct TagItem *);

    match = FreeDBMatchStart(tag1,...);
    D0                        A0

    APTR FreeDBMatchStartA(Tag);

   FUNCTION
    Start a disc match. Think about dos.library/MatchFirst()
    dos.library/MatchNext() dos.library/MatchEnd() functions.

    First of all, you create a match with:

    APTR match;

    match = FreeDBMatchStartA(attrs);

    The attributes defined are:

    - FREEDBA_ErrPtr (LONG *)
      If supplied, it will contains the reason for failure

    - FREEDBA_DiscInfo (FREEDBA_DiscInfo *)
      If supplied, this FREEDBS_DiscInfo is used.

    - FREEDBA_DiscID (STRPTR)
      An AmigaDOS pattern for DiscID.

    - FREEDBA_Categ (STRPTR)
      An AmigaDOS pattern for categs

    - FREEDBA_Title (STRPTR)
      An AmigaDOS pattern for title

    - FREEDBA_Artist (STRPTR)
      An AmigaDOS pattern for artist

    - FREEDBA_Titles (STRPTR)
      An AmigaDOS pattern for tracks title

    The patterns are used to filter the entries in the local cache.

    After that, you cycle with:

    struct FREEDBS_DiscInfo *mdi;

    while (mdi = FreeDBMatchNext(match))
    {
        /* mdi will contain disc information */
        ...
    }

    When you are done, you must free the allocated resources with

    FreeDBMatchEnd(match);

    The match pointer can't be reused.

   INPUTS
    attrs - a TagItem list

   RESULTS
    match - a pointer to use with FreeDBMatchNext(), NULL on failure.

   SEE ALSO
    FreeDBMatchNext
    FreeDBMatchEnd
freedb.library/FreeDBMatchNext                       freedb.library/FreeDBMatchNext

   NAME
    FreeDBMatchNext - finds next entry

   SYNOPSIS
    di = FreeDBMatchNext(match);
    D0                   A0

    struct FREEDBS_DiscInfo * FreeDBMatchNext(APTR);

   FUNCTION
    Finds next entry that matches the patterns set in FreeDBMatchStart().
    Returns NULL when there are no more entries.

   INPUTS
    match - the result of FreeDBMatchStartA()

   RESULTS
    di - a FREEDBS_DiscInfo representing the current entry or NULL
         if no more entries

   SEE ALSO
    FreeDBMatchStartA
    FreeDBMatchEnd
freedb.library/FreeDBReadConfig                      freedb.library/FreeDBReadConfig

   NAME
    FreeDBReadConfig - reads a freedb.library configuration file

   SYNOPSIS
    res = FreeDBReadConfig(config,name);
    D0                   A0   A1

    LONG FreeDBReadConfig(struct FREEDBS_Config,STRPTR name);

   FUNCTION
    Reads a freedb.library configuration file, setting
    config. Note that the memory allocated must be freed via
    FreeDBFreeConfig().

    name may be:

    - FREEDBV_ReadConfig_Environment
      ENV:FreeDB/FreeDB (and ENVARC:FreeDB/FreeDB) is read

    - FREEDBV_ReadConfig_Envarc
      ENVARC:FreeDB/FreeDB is read

   INPUTS
    config - a pointer to a FREEDBS_Config to fill
    name   - the name of the file to read

   RESULTS
    res - 0 ok, >0 error

   SEE ALSO
    FreeDBConfigChanged
    FreeDBFreeConfig
    FreeDBSaveConfig
freedb.library/FreeDBReadTOCA                        freedb.library/FreeDBReadTOCA

   NAME
    FreeDBReadTOC - reads a TOC from a disc

   SYNOPSIS
    res = FreeDBReadTOCA(attrs);
    D0                 A0

    LONG FreeDBReadTOCA(struct TagItem *);

    res = FreeDBReadTOC(Tag1,...);
    D0                 A0

    LONG FreeDBReadTOC(Tag,...);

   FUNCTION
    This function reads the TOC of a CD-ROM.

    attrs are:

    - FREEDBA_TOCPtr (FREEDBS_TOC **)
      if supplied a FREEDBS_TOC structure is created for you and
      returned here

    - FREEDBA_TOC (FREEDBS_TOC *)
      if supplied this is a pointer to an already existing
      FREEDBS_TOC structure which is filled

    - FREEDBA_Device (STRPTR)
      name of the CD-ROM device, e.g. "scsi.device"

    - FREEDBA_Unit (UWORD)
      the unit for FREEDBA_Device. Default 0

    - FREEDBA_DeviceName (STRPTR)
      the name of a mounted CD-ROM device, e.g. "CD0"

    - FREEDBA_Lun (UBYTE)
      logical unit for the CD-ROM. Default 0

    - FREEDBA_Pool (APTR)
      if supplied and a FREEDBS_TOC has to be allocated this is
      AllocPooled() there otherwise the FREEDBS_TOC is allocated
      via FREEDBAllocObject() and so must be released via
      FreeDBFreeObject()

    Note that:
    - one of FREEDBS_TOCPtr or FREEDBS_TOC must be supplied.
    - one of FREEDBA_Device or FREEDBA_DeviceName must be
      supplied.
    - Reading a TOC is a blocking operation. Because of that, a
      timer is created to stop the reading at 10 seconds.
    - requires an exec.signal to to be available
    - The TOC returned is a pure TOC not a "150 frames rounded one"

    The function may fails iff:

    - FREEDBV_Err_NoParms
      You missed some important parameters

    - FREEDBV_Err_NoMem
      Not enough mem

    - FREEDBV_Err_NoDevice
      The device can't be found

    - FREEDBV_Err_NoOpenDevice
      The device can't be opened

    - FREEDBV_Err_Aborted
      Timeout or ctrl-c

    - FREEDBV_Err_NoTOC
      The toc can't be read for some reason

    - FREEDBV_Err_NoMedium
      No disc inserted

    - FREEDBV_Err_NotCD
      The device seems to be not a CD-ROM device

    - FREEDBV_Err_BadTOC
      The device returned an invalid TOC

   INPUTS
    attrs - attributes list

   RESULTS
    res - 0 ok, >0 error

   SEE ALSO
    none
freedb.library/FreeDBSaveConfig                      freedb.library/FreeDBSaveConfig

   NAME
    FreeDBSaveConfig - Saves a freedb.library configuration

   SYNOPSIS
    res = FreeDBSaveConfig(config,name);
    D0                   A0     A1

    LONG FreeDBSaveConfig(struct FREEDBS_Config,STRPTR name);

   FUNCTION
    Saves a freedb.library configuration file.

    name may be also:

    - FREEDBV_SaveConfig_Envarc
      Save both in ENV:FreeDB/FreeDB and ENVARC:FreeDB/FreeDB

    - FREEDBV_SaveConfig_Env
      Saved in ENV:FreeDB/FreeDB

   INPUTS
    config - a pointer to a FREEDBS_Config to save
    name   - the name of the file to save

   RESULTS
    res - 0 ok, >0 error

   SEE ALSO
    FreeDBConfigChanged
    FreeDBReadConfig
    FreeDBSaveConfig
freedb.library/FreeDBSaveLocalDiscA                  freedb.library/FreeDBSaveLocalDiscA

   NAME
    FREEDBSaveLocalDisc - saves a disc to the local cache

   SYNOPSIS
    res = FreeDBSaveLocalDiscA(attrs);
    D0                 A0

    LONG FreeDBSaveLocalDiscA(struct TagItem *);

    res = FREEDBSaveLocalDisc(Tag1,...);
    D0                 A0

    LONG FREEDBSaveLocalDisc(Tag,...);

   FUNCTION
    This function saves a disc to the local cache.

    A disc is completely represented by the FREEDBS_DiscInfo
    supplied in FREEDBA_DiscInfo. But:

    - If you supply a categ in FREEDBA_Categ, that is used

    - If you supply a discID in FREEDBA_DiscID, that is used

    - If you supply a TOC in FREEDBA_TOC its discID is used.

    attrs are:

    - FREEDBA_DiscInfo (FREEDBS_DiscInfo *)
      The info of the disc, must be supplied and valid.

    - FREEDBA_TOC (FREEDBS_TOC *)
      The TOC of the disc. It is optional but should be supplied.
      As always it rules over FREEDB_DiscInfo !

    - FREEDBA_Categ (STRPTR)
      May supply a categ here.

    - FREEDBA_DiscID (ULONG)
      May supply a discID here.

    - FREEDBA_Prg (STRPTR)
      The name of the program that is saving the disc.

    - FREEDBA_Ver (STRPTR)
      The version of the program that is saving the disc.

    - FREEDBA_OverWrite (BOOL)
      Overwrite the file if it exists. Default FALSE.

    - FREEDBA_NoRequester (BOOL)
      Don't show requester when locking the RootDir

    - FREEDBA_OrigHeader (BOOL)
      Follow me: the FREEDBS_DiscInfo has a field called header.
      It is a STRPTR which contains the header of the disc info.
      This header is really important: it contains information
      used by a freedb server to handle discs.
      Anytime you ask freedb.library to save a file, a new header
      is created. If you set this attribute to TRUE the original
      header (if any) is used.

    The function may fails iff:

    - FREEDBV_Err_NoParms
      You missed some important parameters

    - FREEDBV_Err_NoMem
      Not enough mem

    - FREEDBV_Err_NoRootDir
      No root dir specified (in freedb.library configuration and
      FreeDB: is not mounted)

    - FREEDBV_Err_CantSave
      Can't save because of a DOS error

    - FREEDBV_Err_FileExists
      File exists

   INPUTS
    attrs - attributes list

   RESULTS
    res - 0 ok, >0 error

   SEE ALSO
    none
freedb.library/FreeDBSetDiscInfoA                    freedb.library/FreeDBSetDiscInfoA

   NAME
    FreeDBSetDiscInfoA - set attributes of a FREEDBS_DiscInfo

   SYNOPSIS
    res = FreeDBSetDiscInfoA(di,attrs);
    D0                       A0 A1

    ULONG FreeDBSetDiscInfoA(struct FREEDBS_DiscInfo *,struct TagItem *);

    res = FreeDBSetDiscInfo(di,tag1,...);
    D0                       A0 A1

    ULONG FreeDBSetDiscInfo(struct FREEDBS_DiscInfo *,Tag,...);

   FUNCTION
    This function may be used to modify in a complete transparent way
    the information contained in a DiscInfo.

    Note that the DiscInfo is not cleared by the function, except for
    FREEDBA_Tracks, which resets the DiscInfo to that number of tracks
    clearing it.

    attrs are:

    - FREEDBA_Tracks (ULONG)
      The number of the tracks

    - FREEDBA_DiscID (ULONG)

    - FREEDBA_Year (ULONG)

    - FREEDBA_Categ (STRPTR)

    - FREEDBA_Genre (STRPTR)

    - FREEDBA_Title (STRPTR)

    - FREEDBA_Artist (STRPTR)

    - FREEDBA_Extd (STRPTR)

    - FREEDBA_PlayOrder (STRPTR)

   INPUTS
    di    - a FREEDBS_DiscInfo structure pointer
    attrs - a TagItem list

   RESULTS
    res - the number of the attributes set


   SEE ALSO
    FreeDBSetDiscInfoTrackA
freedb.library/FreeDBSetDiscInfoTrackA               freedb.library/FreeDBSetDiscInfoTrackA

   NAME
    FreeDBSetDiscInfoTrackA - set attributes of a track in a FREEDBS_DiscInfo

   SYNOPSIS
    res = FreeDBSetDiscInfoTrackA(di,track,attrs);
    D0                            A0 D0    A1

    ULONG FreeDBSetDiscInfoTrackA(struct FREEDBS_DiscInfo *,ULONG,struct TagItem *);

    res = FreeDBSetDiscInfoTrack(di,track,tag1,...);
    D0                            A0 D0   A1

    ULONG FreeDBSetDiscInfoTrack(struct FREEDBS_DiscInfo *,ULONG,Tag,...);

   FUNCTION
    This function may be used to modify in a complete transparent way
    the information contained in a track of a DiscInfo.

    Note that the DiscInfo is not cleared by the function.

    attrs are:

    - FREEDBA_Title (STRPTR)

    - FREEDBA_Artist (STRPTR)

    - FREEDBA_Extd (STRPTR)

   INPUTS
    di    - a FREEDBS_DiscInfo structure pointer
    track - the track to modify
    attrs - a TagItem list

   RESULTS
    res - the number of the attributes set


   SEE ALSO
    FreeDBSetDiscInfoA
