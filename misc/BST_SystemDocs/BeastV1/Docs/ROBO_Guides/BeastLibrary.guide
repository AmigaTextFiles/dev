@database BeastLibrary.guide
@rem Source: BeastLibrary.s
@rem Generated with RoboDoc v3.0h (Apr 07 1996)
@rem RoboDoc is copyright 1994--1996 by Maverick Software Development
@node Main BeastLibrary.guide
@{jcenter}
@{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}

@{"BST_System/BeastLibrary                " Link "BeastLibrary"}
@{"BeastLibrary/BST_AddClass              " Link "BST_AddClass"}
@{"BeastLibrary/BST_ApplyTagChanges       " Link "BST_ApplyTagChanges"}
@{"BeastLibrary/BST_CloneTagItems         " Link "BST_CloneTagItems"}
@{"BeastLibrary/BST_FillAttrTagList       " Link "BST_FillAttrTagList"}
@{"BeastLibrary/BST_FindTagItem           " Link "BST_FindTagItem"}
@{"BeastLibrary/BST_FreeClass             " Link "BST_FreeClass"}
@{"BeastLibrary/BST_FreeTagItems          " Link "BST_FreeTagItems"}
@{"BeastLibrary/BST_MakeClass             " Link "BST_MakeClass"}
@{"BeastLibrary/BST_MakeSubClass          " Link "BST_MakeSubClass"}
@{"BeastLibrary/BST_NextTagItem           " Link "BST_NextTagItem"}
@{"BeastLibrary/BST_RemoveClass           " Link "BST_RemoveClass"}
@{"BeastLibrary/CLSS_AddMethod            " Link "CLSS_AddMethod"}
@{"BeastLibrary/CLSS_DisposeMethod        " Link "CLSS_DisposeMethod"}
@{"BeastLibrary/CLSS_FindMethod           " Link "CLSS_FindMethod"}
@{"BeastLibrary/OBJ_CreateConnection      " Link "OBJ_CreateConnection"}
@{"BeastLibrary/OBJ_DestroyObject         " Link "OBJ_DestroyObject"}
@{"BeastLibrary/OBJ_DisposeObject         " Link "OBJ_DisposeObject"}
@{"BeastLibrary/OBJ_DoMethod              " Link "OBJ_DoMethod"}
@{"BeastLibrary/OBJ_FromInput             " Link "OBJ_FromInput"}
@{"BeastLibrary/OBJ_MethodToChildren      " Link "OBJ_MethodToChildren"}
@{"BeastLibrary/OBJ_MethodToParent        " Link "OBJ_MethodToParent"}
@{"BeastLibrary/OBJ_NewObject             " Link "OBJ_NewObject"}
@{"BeastLibrary/OBJ_RemoveConnection      " Link "OBJ_RemoveConnection"}
@{"BeastLibrary/OBJ_ToOutput              " Link "OBJ_ToOutput"}
@{"BeastLibrary/mth_AllocMem_BeastLibrary " Link "mth_AllocMem_BeastLibrary"}
@{"BeastLibrary/mth_ForEach_BeastLibrary  " Link "mth_ForEach_BeastLibrary"}
@{"BeastLibrary/mth_FreeMem_BeastLibrary  " Link "mth_FreeMem_BeastLibrary"}
@{"BeastLibrary/mth_LockMem_BeastLibrary  " Link "mth_LockMem_BeastLibrary"}
@{"BeastLibrary/mth_UnlockMem_BeastLibrary" Link "mth_UnlockMem_BeastLibrary"}
@{jleft}
@endnode
@Node "BeastLibrary" "BST_System/BeastLibrary"
@{fg shine}BST_System/BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BeastLibrary@{ub} -- Library for BEAST. (V1 Bravo)

@{ub}
@{b}COPYRIGHT@{ub}
          Maverick Software Development


@{b}FUNCTION@{ub}
          The BEAST engine.

                The method names are defined as follows;
                mth_[method name]_[class name]

                The following tokens are used to explain the methods.

                af[..] = Attribute flags;
                        R    = Required, must be supplied.
                        P    = When not available, the method will try retrieve it from it's parents.
                        S(n) = This tag is used/filled in by a superclass (n) of this class.
                        E    = When supplied the object will act more efficient.
                        D(n) = Default value when it's not supplied and it cannot be retrieved
                               from something else.
                        A    = Always supplied by the method.
                        F    = This tag is filled in by the method.
                        I    = @{"BTF_Ignore" Link "TagLists.guide/BTF_Ignore"} flag is set when processed.
                        T(n) = Extra information about the typeof the tag.



@{b}AUTHOR@{ub}
@{i}          Jacco van Weert

@{ui}
@{b}CREATION DATE@{ub}
          23-Apr-95


@{b}MODIFICATION HISTORY@{ub}
          27-Mar-96:    First release, V1 Alpha.
          16-Apr-96:    @{"BST_FillAttrTagList" Link "BST_FillAttrTagList"}, V1 Bravo.
                        @{"OBM_ALLOCMEM" Link "Methods.guide/OBM_ALLOCMEM"}, @{"OBM_FREEMEM" Link "Methods.guide/OBM_FREEMEM"}, @{"OBM_LOCKMEM" Link "Methods.guide/OBM_LOCKMEM"}, @{"OBM_UNLOCKMEM" Link "Methods.guide/OBM_UNLOCKMEM"}
                        @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"} @{"Methods" Link "Methods.guide/Methods"} V1 Bravo.
                        Library version 2.


@{b}NOTES@{ub}


@endnode
@Node "BST_AddClass" "BeastLibrary/BST_AddClass"
@{fg shine}BeastLibrary/BST_AddClass@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_AddClass@{ub} -- Add a Beast class to the class list. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          AddClass( Class )
                    A0
          void @{b}BST_AddClass@{ub}( struct BST_Class * );


@{b}FUNCTION@{ub}
          Add the Beast class to the Beast system.


@{b}INPUTS@{ub}
          Class - Pointer to the class.


@{b}SEE ALSO@{ub}
          @{"BST_RemoveClass" Link "BST_RemoveClass"}, @{"BST_MakeClass" Link "BST_MakeClass"}


@endnode
@Node "BST_ApplyTagChanges" "BeastLibrary/BST_ApplyTagChanges"
@{fg shine}BeastLibrary/BST_ApplyTagChanges@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_ApplyTagChanges@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}BST_ApplyTagChanges@{ub}( list, changeList )
                               A0    A1


@{b}FUNCTION@{ub}
          <Same as in the utility.library>


@{b}NOTES@{ub}
          This routine is subject to change


@endnode
@Node "BST_CloneTagItems" "BeastLibrary/BST_CloneTagItems"
@{fg shine}BeastLibrary/BST_CloneTagItems@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_CloneTagItems@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          clone = @{b}BST_CloneTagItems@{ub}( original )
          D0                         A0


@{b}FUNCTION@{ub}
          <Same as in the utility.library>


@{b}NOTES@{ub}
          This routine is subject to change


@endnode
@Node "BST_FillAttrTagList" "BeastLibrary/BST_FillAttrTagList"
@{fg shine}BeastLibrary/BST_FillAttrTagList@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_FillAttrTagList@{ub} -- (V1 Bravo)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}BST_FillAttrTagList@{ub}( TagList, SupportedTags, Object, MethodFlags )
          D0                            A0       A1             A2,     D3


@{b}FUNCTION@{ub}
          This function can be used in assembler programs to process a TagList.
          The 'functions' are called with;
                D4 = Number of this filled item
                A0 = Pointer to { TAG, xxxx_data }
                A2 = Pointer to the object
                A3 = Pointer to the start of the TagList
                A5 = Pointer to the Instance


@{b}INPUTS@{ub}
          TagList        - Pointer to the to be processed TagList
          SupportedTags  - Pointer to a Table with all the supported tags
                           ends with TAG_DONE.

                           Example:
                                dc.l    @{"BTA_Size" Link "TagLists.guide/BTA_Size"},  addr_GetSize
                                dc.l    @{"BTA_Title" Link "TagLists.guide/BTA_Title"}, addr_GetTitle
                                dc.l    TAG_DONE
          Object         - Pointer to the object from which the instance is used.
          MethodFlags    - The MethodFlags, these are chanced when there is a
                           @{"BTA_NumberOf" Link "TagLists.guide/BTA_NumberOf"} tag, and it is neccesary.


@{b}RESULT@{ub}
          Result - New MethodFlags


@{b}SEE ALSO@{ub}


@endnode
@Node "BST_FindTagItem" "BeastLibrary/BST_FindTagItem"
@{fg shine}BeastLibrary/BST_FindTagItem@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_FindTagItem@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}BST_FindTagItem@{ub}( tagValue, tagList )
          D0,A0                     D0        A0
          struct TagItem *@{b}BST_FindTagItem@{ub}( ULONG, struct TagItem * );


@{b}FUNCTION@{ub}
          Same functionallity as the utility.library equivalent, added are
          special handling functions for the BEAST tags.


@endnode
@Node "BST_FreeClass" "BeastLibrary/BST_FreeClass"
@{fg shine}BeastLibrary/BST_FreeClass@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_FreeClass@{ub} -- Free a Beast class. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}BST_FreeClass@{ub}( Class )
                         A0
          void @{b}BST_FreeClass@{ub}( struct BST_Class );


@{b}FUNCTION@{ub}
          Free the Beast class from the memory. Also deallocate all class related
          stuff. Such as the methods lists.


@{b}INPUTS@{ub}
          Class - Pointer to the class.


@{b}NOTES@{ub}
          Before this routine @{"BST_RemoveClass" Link "BST_RemoveClass"} must be called.


@{b}BUGS@{ub}
@{fg shine}          No check if the Class is still in use.

@{fg text}
@{b}SEE ALSO@{ub}
          @{"BST_RemoveClass" Link "BST_RemoveClass"}, @{"BST_MakeClass" Link "BST_MakeClass"}


@endnode
@Node "BST_FreeTagItems" "BeastLibrary/BST_FreeTagItems"
@{fg shine}BeastLibrary/BST_FreeTagItems@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_FreeTagItems@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}BST_FreeTagItems@{ub}( taglist )
                            A0


@{b}FUNCTION@{ub}
          <Same as in the utility.library>


@{b}NOTES@{ub}
          This routine is subject to change


@endnode
@Node "BST_MakeClass" "BeastLibrary/BST_MakeClass"
@{fg shine}BeastLibrary/BST_MakeClass@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_MakeClass@{ub} -- Make a Beast class. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}BST_MakeClass@{ub}( ClassID, InstanceSize )
          D0                      A0       D0
          struct BST_Class *@{b}BST_MakeClass@{ub}( char *, ULONG );


@{b}FUNCTION@{ub}
          Defines a new public class, @{"BST_AddClass" Link "BST_AddClass"} must be called to add
          the class to the BEAST system.


@{b}INPUTS@{ub}
          ClassID      - Class ID, pointer to the public-name.
                         Please choose this name carefully, otherwise a
                         conflict may occur.
                         Beast classes always are starting with a 'B'.
                         BST_,  BVS_, BFS_, ..etc..

          InstanceSize - The Instance size in bytes.


@{b}RESULT@{ub}
          Result - The created class


@{b}SEE ALSO@{ub}
          @{"BST_FreeClass" Link "BST_FreeClass"}, @{"BST_AddClass" Link "BST_AddClass"}


@endnode
@Node "BST_MakeSubClass" "BeastLibrary/BST_MakeSubClass"
@{fg shine}BeastLibrary/BST_MakeSubClass@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_MakeSubClass@{ub} -- Make a Beast subclass. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}BST_MakeSubClass@{ub}( ClassID, InstanceSize, SuperClass )
          D0                         A0       D0            A1


@{b}FUNCTION@{ub}
          The same function as @{"BST_MakeClass" Link "BST_MakeClass"}, only now this class is a subclass
          of 'SuperClass'. This superclass _must_ be added to the system, because
          at least 1 object is created of this class.


@{b}INPUTS@{ub}
          ClassID      - Class ID, pointer to public-name.
          InstanceSize - The private class datasize in bytes.
          SuperClass   - The name of the SuperClass.


@{b}RESULT@{ub}
          Result - The created sub class


@{b}SEE ALSO@{ub}
          @{"BST_FreeClass" Link "BST_FreeClass"}, @{"BST_AddClass" Link "BST_AddClass"}, @{"BST_MakeClass" Link "BST_MakeClass"}


@endnode
@Node "BST_NextTagItem" "BeastLibrary/BST_NextTagItem"
@{fg shine}BeastLibrary/BST_NextTagItem@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_NextTagItem@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}BST_NextTagItem@{ub}( tagList )
          D0,A0                     A0
          struct TagItem *@{b}BST_NextTagItem@{ub}( struct TagItem * );


@{b}FUNCTION@{ub}
          Similar function as the one in the utility.library, only this
          takes care about some BEAST tags.


@{b}RESULT@{ub}
          Result - Pointer to the new position.
                   =NULL when end of TagList


@endnode
@Node "BST_RemoveClass" "BeastLibrary/BST_RemoveClass"
@{fg shine}BeastLibrary/BST_RemoveClass@{fg text}

@{b}NAME@{ub}
@{b}          @{b}BST_RemoveClass@{ub} -- Remove a Beast class from the class list. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}BST_RemoveClass@{ub}( Class )
                           A0
          void @{b}BST_RemoveClass@{ub}( struct BST_Class * );


@{b}FUNCTION@{ub}
          Unlink the Beast class from the list.


@{b}INPUTS@{ub}
          Class - Pointer to the class.


@{b}SEE ALSO@{ub}
          @{"BST_AddClass" Link "BST_AddClass"}, @{"BST_FreeClass" Link "BST_FreeClass"}


@endnode
@Node "CLSS_AddMethod" "BeastLibrary/CLSS_AddMethod"
@{fg shine}BeastLibrary/CLSS_AddMethod@{fg text}

@{b}NAME@{ub}
@{b}          @{b}CLSS_AddMethod@{ub} -- Add a Method to a class. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}CLSS_AddMethod@{ub}( Class, MethodStart, Method_ID )
          D0                       A0     A1           D0
          struct BST_Class @{b}CLSS_AddMethod@{ub}( struct BST_Class *, ULONG *, BST_Method );


@{b}FUNCTION@{ub}
          Add a method to a class, every method may have several method-routines.
          The Beast system has a large number of pre-defined method ID's.
          There are a number of free slots for local methods. Please consider
          very carefully when using local methods ID. Those are not supported
          among other classes. Also _NEVER_ use method delegation (@{"MTHF_DOPARENTS" Link "Methods.guide/MTHF_DOPARENTS"},
          @{"MTHF_DOCHILDREN" Link "Methods.guide/MTHF_DOCHILDREN"}..etc..) when using local methods. In the BEAST OO system
          objects are _never_ sure who parents or children are, even if you add them
          yourself.
          Free slots for local method ID's:
                @{"OBM_local0" Link "Methods.guide/OBM_local0"}      =       0x00000040 - 0x0000007F
                @{"OBM_local1" Link "Methods.guide/OBM_local1"}      =       0x00000100 - 0x000007FF
                @{"OBM_local2" Link "Methods.guide/OBM_local2"}      =       0x00004000 - 0x00004FFF
                OBM_local3      =       0x00100000 - 0x001FFFFF

          The method ID's with the lowest number have the highest priority. In
          V1 Alpha the priority is not yet implemented, but it will be in the future.


@{b}INPUTS@{ub}
          Class       - Pointer to the class.
          MethodStart - The start of the method routine.
          Method_ID   - The Method_ID number.


@{b}RESULT@{ub}
          Result - =NULL when Error.
                   <>NULL Class.


@{b}SEE ALSO@{ub}
          @{"CLSS_DisposeMethod" Link "CLSS_DisposeMethod"}


@endnode
@Node "CLSS_DisposeMethod" "BeastLibrary/CLSS_DisposeMethod"
@{fg shine}BeastLibrary/CLSS_DisposeMethod@{fg text}

@{b}NAME@{ub}
@{b}          @{b}CLSS_DisposeMethod@{ub} -- Dispose a Method from a class. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}CLSS_DisposeMethod@{ub}( Class, MethodStart, Method_ID )
                              A0     A1           D0
          void @{b}CLSS_DisposeMethod@{ub}( struct BST_Class *, ULONG *, BST_Method );


@{b}FUNCTION@{ub}
          Remove the method from the class.


@{b}INPUTS@{ub}
          Class       - Pointer to the class.
          MethodStart - Start of the method routine.
          Method_ID   - Method ID number


@{b}SEE ALSO@{ub}
          @{"CLSS_AddMethod" Link "CLSS_AddMethod"}


@endnode
@Node "CLSS_FindMethod" "BeastLibrary/CLSS_FindMethod"
@{fg shine}BeastLibrary/CLSS_FindMethod@{fg text}

@{b}NAME@{ub}
@{b}          @{b}CLSS_FindMethod@{ub} -- Find a Method in a class. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}CLSS_FindMethod@{ub}( Class, Method_ID )
          D0,A0                     A0     D0
          struct class_MethodList *@{b}CLSS_FindMethod@{ub}( struct BST_Class *, BST_Method );


@{b}FUNCTION@{ub}
          Search for a certain method ID.


@{b}INPUTS@{ub}
          Class     - Pointer to the class.
          Method_ID - Method ID number.


@{b}RESULT@{ub}
          Result - Pointer to found CLSS_MethodList or NULL when the method
                   is not found.


@endnode
@Node "OBJ_CreateConnection" "BeastLibrary/OBJ_CreateConnection"
@{fg shine}BeastLibrary/OBJ_CreateConnection@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_CreateConnection@{ub} -- Create a connection between two methods. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_CreateConnection@{ub}( FromObject, ToObject, FromMethod, ToMethod )
          D0                             A0          A1        D0          D1
          struct obj_OutputLink *@{b}OBJ_CreateConnection@{ub}( struct BST_Object *, struct BST_Object *, BST_Method, BST_Method );


@{b}FUNCTION@{ub}
          Create a connection between two objects. Every Method can be connected to any
          other method. Connections between objects running at the same task will be
          a direct connection. When connecting to object of different task the routine
          will insert an intermediair (not implemented in V1 Alpha). The same when connecting
          between two objects at two different computer systems.
          A connection can have multiple inputs and outputs. But a things must be take into
          consideration. When a 'FromMethod' is connected to several other methods the
          TagList (which is the data) is shared among the connected objects, which means
          that if the first object changes something in the TagList, the others will also
          see it.


@{b}INPUTS@{ub}
          FromObject - Pointer to the 'From' object.
          ToObject   - Pointer to the 'To' object
          FromMethod - The Method ID number of the FromObject.
          ToMethod   - The Method ID number of the ToObject.


@{b}RESULT@{ub}
          Result - 0 = An error has occured. Also when FromObject or ToObject
                       is zero. Otherwise, pointer to the obj_OutputLink.

          A double linked connection is created, an OIL_Connection
          and an OOL_Connection structure.


@{b}SEE ALSO@{ub}
          @{"OBJ_RemoveConnection" Link "OBJ_RemoveConnection"}


@endnode
@Node "OBJ_DestroyObject" "BeastLibrary/OBJ_DestroyObject"
@{fg shine}BeastLibrary/OBJ_DestroyObject@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_DestroyObject@{ub} -- Destroy an object. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}OBJ_DestroyObject@{ub}( Object, MethodFlags )
                             A0      D3
          struct BST_Object *@{b}OBJ_DestroyObject@{ub}( struct BST_Object *, BST_MethodFlags );


@{b}FUNCTION@{ub}
          This function combines a @{"OBM_DISPOSE" Link "Methods.guide/OBM_DISPOSE"} method with a @{"OBJ_DisposeObject" Link "OBJ_DisposeObject"}
          call.


@{b}INPUTS@{ub}
          Object      - Pointer to the object to be destroyed.
          MethodFlags - @{"MTHF_DOCHILDREN" Link "Methods.guide/MTHF_DOCHILDREN"} will be added by the function!!


@{b}SEE ALSO@{ub}
          @{"OBJ_DoMethod" Link "OBJ_DoMethod"}, @{"OBJ_DisposeObject" Link "OBJ_DisposeObject"}


@endnode
@Node "OBJ_DisposeObject" "BeastLibrary/OBJ_DisposeObject"
@{fg shine}BeastLibrary/OBJ_DisposeObject@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_DisposeObject@{ub} -- Dispose an object. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}OBJ_DisposeObject@{ub}( Object )
                             A0
          void @{b}OBJ_DisposeObject@{ub}( struct BST_Object * );


@{b}FUNCTION@{ub}
          Dispose this object AND all it's children.


@{b}INPUTS@{ub}
          Object - The object to be disposed. May be NULL.


@{b}RESULT@{ub}
          This object AND the children objects are disposed.


@{b}NOTES@{ub}
          This function will NOT perform an @{"OBM_DISPOSE" Link "Methods.guide/OBM_DISPOSE"} method.


@{b}SEE ALSO@{ub}
          @{"OBJ_NewObject" Link "OBJ_NewObject"}, @{"OBJ_DestroyObject" Link "OBJ_DestroyObject"}


@endnode
@Node "OBJ_DoMethod" "BeastLibrary/OBJ_DoMethod"
@{fg shine}BeastLibrary/OBJ_DoMethod@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_DoMethod@{ub} -- Perform a method on a object. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_DoMethod@{ub}( Object, Method_ID, TagList, MethodFlags )
                                 A0      D0         A1       D3
          BST_MethodFlags @{b}OBJ_DoMethod@{ub}( struct BST_Object *, BST_Method, struct TagItem *, BST_MethodFlags );


@{b}FUNCTION@{ub}
          Trigger a method on a certain object.


@{b}INPUTS@{ub}
          Object      - Pointer to the object (may NULL).
          Method_ID   - Method ID number.
          TagList     - Pointer to the TagList used by the Method routine.
          MethodFlags - Special method flags;
                                See the Beast:Docs/Beast_OO/Methods.doc


@{b}RESULT@{ub}
          Result = The new method flags

                        Method call with the following registers set;
                                D2 = Method_ID
                                D3 = MethodFlags
                                A2 = Object
                                A3 = TagList

          As a result the method must deliver the new MethodFlags in d0.
          Besides the discussed MethodFlags (INPUTS) there are some more;
                See the Beast:Docs/Beast_OO/Methods.doc


@{b}SEE ALSO@{ub}
          @{"OBJ_MethodToParent" Link "OBJ_MethodToParent"}, @{"OBJ_MethodToChildren" Link "OBJ_MethodToChildren"}


@endnode
@Node "OBJ_FromInput" "BeastLibrary/OBJ_FromInput"
@{fg shine}BeastLibrary/OBJ_FromInput@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_FromInput@{ub} -- Trigger methods connections to an input. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}OBJ_FromInput@{ub}( Object, InputMethod, MethodFlags, TagList )
                         A0,     D0           D3           A1
          BST_MethodFlags @{b}OBJ_FromInput@{ub}( struct BST_Object *, BST_Method, BST_MethodFlags, struct TagItem * );


@{b}FUNCTION@{ub}
          Request input from the method 'InputMethod', this will trigger ( if
          connected ) a method at the object connected to the 'InputMethod'.


@{b}INPUTS@{ub}
          Object       - Pointer to the object.
          InputMethod  - The input method number.
          MethodFlags  - The Method flags, see @{"OBJ_DoMethod" Link "OBJ_DoMethod"}.
          TagList      - The TagList put to the input/output-methods of the
                         connection.


@{b}SEE ALSO@{ub}
          @{"OBJ_ToOutput" Link "OBJ_ToOutput"}, @{"OBJ_CreateConnection" Link "OBJ_CreateConnection"}


@endnode
@Node "OBJ_MethodToChildren" "BeastLibrary/OBJ_MethodToChildren"
@{fg shine}BeastLibrary/OBJ_MethodToChildren@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_MethodToChildren@{ub} -- Delegate the method to the children. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_MethodToChildren@{ub}( Object, Method_ID, TagList, MethodFlags )
                                         A0      D0         A1       D3


@{b}FUNCTION@{ub}
          See DoMethod for full description. 
          This function pass the method to the children. This is used in a method
          definition when the @{"MTHF_PASSTOCHILD" Link "Methods.guide/MTHF_PASSTOCHILD"} flag is set.


@{b}INPUTS@{ub}
          Object      - Pointer to the object (may NULL).
          Method_ID   - Method ID number.
          TagList     - Pointer to the TagList used by the Method routine.
          MethodFlags - Special method flags;


@{b}RESULT@{ub}
          Result = The new method flags

          Method call with the following registers set;

                D2 = Method_ID
                D3 = MethodFlags
                A2 = Object
                A3 = TagList

          As a result the method must deliver the new MethodFlags in d0.


@{b}NOTES@{ub}


@{b}SEE ALSO@{ub}
          @{"OBJ_DoMethod" Link "OBJ_DoMethod"}


@endnode
@Node "OBJ_MethodToParent" "BeastLibrary/OBJ_MethodToParent"
@{fg shine}BeastLibrary/OBJ_MethodToParent@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_MethodToParent@{ub} -- Delegate the method to the parent. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_MethodToParent@{ub}( Object, Method_ID, TagList, MethodFlags )
                                       A0      D0         A1       D3
          BST_MethodFlags @{b}OBJ_MethodToParent@{ub}( struct BST_Object *, BST_Method, struct TagItem *, BST_MethodFlags );


@{b}FUNCTION@{ub}
          See DoMethod for full description. 
          This function pass the method to the parent. In this way the method won't
          be triggered at the caller object. Remember to set the @{"MTHF_DOPARENTS" Link "Methods.guide/MTHF_DOPARENTS"} flags
          the method should be delegated to other parents as well.


@{b}INPUTS@{ub}
          Object      - Pointer to the object (may NULL).
          Method_ID   - Method ID number.
          TagList     - Pointer to the TagList used by the Method routine.
          MethodFlags - Special method flags;


@{b}RESULT@{ub}
          Result = The new method flags

          Method call with the following registers set;

                D2 = Method_ID
                D3 = MethodFlags
                A2 = Object
                A3 = TagList

          As a result the method must deliver the new MethodFlags in d0.


@{b}SEE ALSO@{ub}
          @{"OBJ_DoMethod" Link "OBJ_DoMethod"}


@endnode
@Node "OBJ_NewObject" "BeastLibrary/OBJ_NewObject"
@{fg shine}BeastLibrary/OBJ_NewObject@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_NewObject@{ub} -- Create a new object. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_NewObject@{ub}( Class, Class_ID, Parent )
          D0                      A0     A1        D0
          struct BST_Object *@{b}OBJ_NewObject@{ub}( struct BST_Class *, char *, struct BST_Object * );


@{b}FUNCTION@{ub}
          Create a new object. The object is added 'under' the Parent. In version
          V1 Alpha multiple parents are not supported. If the Parent is null the
          object is added under the Beast root, or when the Beast FileSystem is
          available it's added under the UserClass.
          The object instance is allocated with MEMF_CLEAR, so the instance is cleared.


@{b}INPUTS@{ub}
          Class    - Pointer to an already known class (private class)
                     NULL if not used. (normally NULL).
          Class_ID - Pointer to the name of the public class.
          Parent   - Pointer to the parent object or NULL.


@{b}RESULT@{ub}
          Result - Pointer to created object. NULL if the object could
                   not be added.


@{b}SEE ALSO@{ub}
          @{"OBJ_DisposeObject" Link "OBJ_DisposeObject"}


@endnode
@Node "OBJ_RemoveConnection" "BeastLibrary/OBJ_RemoveConnection"
@{fg shine}BeastLibrary/OBJ_RemoveConnection@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_RemoveConnection@{ub} -- (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          @{b}OBJ_RemoveConnection@{ub}( OxL_Connection )
                                A1
          void @{b}OBJ_RemoveConnection@{ub}( struct obj_OutputLink * );


@{b}FUNCTION@{ub}
          Remove a created OIL_Connection or OOL_Connection.


@{b}INPUTS@{ub}
          OxL_Connection - Pointer to an OIL/OOL_Connection.


@{b}RESULT@{ub}
          The OIL_Connection and OOL_Connection structures are destroyed.


@{b}SEE ALSO@{ub}
          @{"OBJ_CreateConnection" Link "OBJ_CreateConnection"}


@endnode
@Node "OBJ_ToOutput" "BeastLibrary/OBJ_ToOutput"
@{fg shine}BeastLibrary/OBJ_ToOutput@{fg text}

@{b}NAME@{ub}
@{b}          @{b}OBJ_ToOutput@{ub} -- Trigger methods connections to an output. (V1 Alpha)

@{ub}
@{b}SYNOPSIS@{ub}
          Result = @{b}OBJ_ToOutput@{ub}( Object, TagList, OutputMethod, MethodFlags )
                                 A0      A1       D0            D3
          BST_MethodFlags @{b}OBJ_ToOutput@{ub}( struct BST_Object *, struct TagItem *, BST_Method, BST_MethodFlags );


@{b}FUNCTION@{ub}
          'Output' the TagList (A1) to the connected input, the used output
          is the OutputMethod (D0). The object is triggered which is connected
          to 'Object' at MethodID 'OutputMethod'.


@{b}INPUTS@{ub}
          Object       - Pointer to the object.
          TagList      - The TagList put to the input/output-method of the
                         connection.
          OutputMethod - The output method ID.
          MethodFlags  - The Method flags, see @{"OBJ_DoMethod" Link "OBJ_DoMethod"}.


@{b}RESULT@{ub}
          Result = The new methodflags.


@{b}SEE ALSO@{ub}
          @{"OBJ_FromInput" Link "OBJ_FromInput"}, @{"OBJ_CreateConnection" Link "OBJ_CreateConnection"}, @{"OBJ_DoMethod" Link "OBJ_DoMethod"}


@endnode
@Node "mth_AllocMem_BeastLibrary" "BeastLibrary/mth_AllocMem_BeastLibrary"
@{fg shine}BeastLibrary/mth_AllocMem_BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          mth_AllocMem - Allocate a memory block. (V1 Bravo)

@{ub}
@{b}FUNCTION@{ub}
          Use this function to allocate a memory block.


@{b}INPUTS@{ub}
          TagList -
                @{"BTA_MemSize" Link "TagLists.guide/BTA_MemSize"}     - af[D(0)]
                        The size of the to be allocated memory in bytes.

                @{"BTA_MemFlags" Link "TagLists.guide/BTA_MemFlags"}    - af[D(MEMF_PUBLIC)]
                        The memory flags of the memory.
                        The same as the one used by the exec.library AllocMem.
                        Extra flags;
                                MEMF_MOVEABLE_DISK
                                        The memory block may be swapped to
                                        slow memory (e.g. disk) when it's
                                        not locked.
                                MEMF_MOVEABLE_MEMORY
                                        The memory block may move around the
                                        systems memory when it's not locked.
                                MEMF_DISCARABLE
                                        The memory may be discard when it is
                                        not locked. So the whole memory will
                                        be released!.
                        These extra flags will be used by the BST_MemoryClass
                        and other memory handling classes.

                @{"BTA_MemHandle" Link "TagLists.guide/BTA_MemHandle"}   - af[RF]
                        On return this tag will hold the pointer to the
                        MemoryHandle. This is _not_ the pointer to the memory
                        block. One must @{"OBM_LOCKMEM" Link "Methods.guide/OBM_LOCKMEM"} the handle to obtain the
                        actual pointer to the memory block.


@{b}SEE ALSO@{ub}
          @{"mth_FreeMem_BeastLibrary" Link "mth_FreeMem_BeastLibrary"}


@endnode
@Node "mth_ForEach_BeastLibrary" "BeastLibrary/mth_ForEach_BeastLibrary"
@{fg shine}BeastLibrary/mth_ForEach_BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          mth_ForEach - (V1 Bravo)

@{ub}
@{b}FUNCTION@{ub}
          Trigger the '@{"BTA_Method" Link "TagLists.guide/BTA_Method"}' of '@{"BTA_MainObject" Link "TagLists.guide/BTA_MainObject"}' for each of the
          '@{"BTA_Object1" Link "TagLists.guide/BTA_Object1"}'s children objects. The supplied TagList is also
          send to the '@{"BTA_Method" Link "TagLists.guide/BTA_Method"}'. Every time 'BTA_Object2' is filled in
          with the current object. Only(!) the children of @{"BTA_Object1" Link "TagLists.guide/BTA_Object1"} are
          processed, not the childrens children.
          If the @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"} must work recursive throughout the whole
          children tree, the '@{"BTA_Method" Link "TagLists.guide/BTA_Method"}' must do an @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"} method again
          and must replace @{"BTA_Object1" Link "TagLists.guide/BTA_Object1"} with the value of BTA_Object2.
          The BST_SearchClass has an example how to do this.


@{b}INPUTS@{ub}
          TagList -
                @{"BTA_MainObject" Link "TagLists.guide/BTA_MainObject"}  - af[R]
                  Method '@{"BTA_Method" Link "TagLists.guide/BTA_Method"}' is this object is always triggered for
                  object. Mostly this is the object from which the @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"}
                  method is triggered.
                @{"BTA_Method" Link "TagLists.guide/BTA_Method"}      - af[R]
                  This method is triggered on '@{"BTA_MainObject" Link "TagLists.guide/BTA_MainObject"}'.
                @{"BTA_Object1" Link "TagLists.guide/BTA_Object1"}     - af[R]
                  The start point of the @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"} method. The children
                  objects of _this_ object are processed.
                BTA_Object2     - af[FR]
                  The tag is always filled with the current child object.
                  With this tag the called method can find out which object
                  the @{"OBM_FOREACH" Link "Methods.guide/OBM_FOREACH"} has processed.


@{b}SEE ALSO@{ub}
          mth_GetEach_BeastLibrary



@endnode
@Node "mth_FreeMem_BeastLibrary" "BeastLibrary/mth_FreeMem_BeastLibrary"
@{fg shine}BeastLibrary/mth_FreeMem_BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          mth_FreeMem - Free a memory block. (V1 Bravo)

@{ub}
@{b}FUNCTION@{ub}
          Use this function to free a memory block, allocate by the
          @{"OBM_ALLOCMEM" Link "Methods.guide/OBM_ALLOCMEM"} method.


@{b}INPUTS@{ub}
          TagList -
                @{"BTA_MemSize" Link "TagLists.guide/BTA_MemSize"}     - af[R]
                        The size of the memory in bytes.

                @{"BTA_MemHandle" Link "TagLists.guide/BTA_MemHandle"}   - af[R]
                        The memory handle


@{b}SEE ALSO@{ub}
          @{"mth_AllocMem_BeastLibrary" Link "mth_AllocMem_BeastLibrary"}, @{"mth_LockMem_BeastLibrary" Link "mth_LockMem_BeastLibrary"},
          @{"mth_UnlockMem_BeastLibrary" Link "mth_UnlockMem_BeastLibrary"}



@endnode
@Node "mth_LockMem_BeastLibrary" "BeastLibrary/mth_LockMem_BeastLibrary"
@{fg shine}BeastLibrary/mth_LockMem_BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          mth_LockMem - Lock a memory handle. (V1 Bravo)

@{ub}
@{b}FUNCTION@{ub}
          Use this method to obtain the pointer to the memory.


@{b}INPUTS@{ub}
          TagList -
                @{"BTA_MemHandle" Link "TagLists.guide/BTA_MemHandle"}   - af[R]
                        The MemoryHandle supplied by the @{"OBM_ALLOCMEM" Link "Methods.guide/OBM_ALLOCMEM"} method.
                @{"BTA_MemBlock" Link "TagLists.guide/BTA_MemBlock"}    - af[F]
                        When the method is finished this tag will hold the
                        pointer to the physical memory.


@{b}SEE ALSO@{ub}
          @{"mth_UnlockMem_BeastLibrary" Link "mth_UnlockMem_BeastLibrary"}, @{"mth_AllocMem_BeastLibrary" Link "mth_AllocMem_BeastLibrary"},
          @{"mth_FreeMem_BeastLibrary" Link "mth_FreeMem_BeastLibrary"}


@endnode
@Node "mth_UnlockMem_BeastLibrary" "BeastLibrary/mth_UnlockMem_BeastLibrary"
@{fg shine}BeastLibrary/mth_UnlockMem_BeastLibrary@{fg text}

@{b}NAME@{ub}
@{b}          mth_UnlockMem - Unlock a memory handle. (V1 Bravo)

@{ub}
@{b}FUNCTION@{ub}
          Use this method to 'given' back your memory. After this method has
          been called you MAY NOT use the memory. You must lock it first again.


@{b}INPUTS@{ub}
          TagList -
                @{"BTA_MemHandle" Link "TagLists.guide/BTA_MemHandle"}   - af[R]
                        The MemoryHandle supplied by the @{"OBM_ALLOCMEM" Link "Methods.guide/OBM_ALLOCMEM"} method.


@{b}SEE ALSO@{ub}
          @{"mth_LockMem_BeastLibrary" Link "mth_LockMem_BeastLibrary"}, @{"mth_AllocMem_BeastLibrary" Link "mth_AllocMem_BeastLibrary"},
          @{"mth_FreeMem_BeastLibrary" Link "mth_FreeMem_BeastLibrary"}


@endnode

