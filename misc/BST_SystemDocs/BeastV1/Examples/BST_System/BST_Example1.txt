
Example1.c
==========

This example program creates a simple class and creates an object
of it.

How it works
------------

Also see the ROBODocs (AutoDoc) for more information about the beast library
functions.

* my_class defines the pointer to the Beast Class (struct BST_Class) ,_NEVER_
use the BST_Class structure items directly, it _will_ change in the future.

* my_object defines the pointer to the Beast Object (struct BST_Object), also the
same story, never use the BST_Object items.

* The beast.library is opened, BeastBase now points to the opened beast.library.

* The BST_MakeClass function is use to define this small class.
  The first parameter is the public name of the class, which in our case is
  "my_firstclass". The second parameter is the size of our instance in bytes.
  A instance is defined by the struct my_class_instance, we want only two elements
  LONG X and LONG Y, so our instance size is 8 bytes.

* Now it's time add a method to our class. Look at the CLSS_AddMethod description
  for more information. For this example we choose a standard BEAST method ID,
  OBM_INIT. Our method routine is declared as my_init.
  To declare this routine the rfcall() macro is used (Beast.h).
  
* To add the class to the Beast system we use the BST_AddClass function. Now everybody
  can use this class. If you have the full BFS (BeastFileSystem) package you can
  assign a class to be used by only a certain group(s) of users.

* Finally we are ready to create an object from our class. OBJ_NewObject has three
  parameters, the first is always NULL, and mostly for internal use. The second
  is a pointer to the class name and the third one is very important, 'under' this
  object the new object is created. In this way a dynamic object tree is build.
  We set this parameter to NULL. This means that the object is created under the
  root of the Beast-object tree. If you have (again) the full BFS-package the object
  will be added under the BFS_UserClass of the logged in user.

* The OBJ_NewObject _only_ adds the Object. No initialization of the instance is done.
  But gladly our 'my_init' routine does the job. The first two parameters are 
  straightforward, the third is the most important, this is the TagList which is
  used by the method routine. In our example 'my_init' doesn't use any parameters
  of the TagList so we send an empty list (EmptyList). The fourth parameter are the
  MethodFlags, in our simple example they are 0. See the OBJ_DoMethod function for
  more information or the Docs/BST_System/Method.txt file.

* We now enter the 'my_init' routine. The first we do is to get the pointer to our
  instance (Macro_GetInstance). Now we can manipulate the instance elements.

* When we leave our method routine we _must_ return with the MethodFlags, because
  we aren't aware which flags are set. We _can_ however reset or set some flags.
  
* Right, this is enough let's dump this object. Very simple, we use the
  OBJ_DisposeObject function. This function simply removes the object.
  
* After this the class can be disposed, BST_RemoveClass and BST_FreeClass. The added
  method is also disposed by the BST_FreeClass. The methods can also be removed
  with the CLSS_DisposeMethod function. In this way the classes methods can be altered
  _run time_.

* The CloseLibrary ends our example program.


