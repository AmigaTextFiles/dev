
Example2.c
==========

This example program creates the following object network;


     OBM_INPUT  ,--------------, OBM_OUTPUT
  ,------------>| math_ax2_obj |------------,
  |		`--------------'    	    |
  |				    	    | OBM_INPUT
  |  OBM_INPUT  ,--------------, OBM_OUTPUT \	,-------------, OBM_OUTPUT
  |------------>| math_bx_obj  |--------------->| math_xy_obj |---,
  |		`--------------'	    /	`-------------'	  |
  |					    |			  |
  |  OBM_INPUT	,--------------, OBM_OUTPUT |			  |
  |------------>| math_c_obj   |------------'			  |
  |		`--------------'				  |
  |								  |
  `---------------------------------------------------------------'


This network calculates the formula Y = A*X^2 + B*X + C. The calculation
is done with long words, this could also be FFP (32-bits floats), but this
would require some casts which would make the example _more_ unreadable ;-)


How it works
------------

Let's start at the main() procedure.

* Four classes are defined;
	MATH_ax2Class = "A * X^2" part.
	MATH_bxClass  = "B * X" part.
	MATH_cClass   = "C" part.
	MATH_xyClass  = this class supplies the X value at the output, after
			this it gathers the Y values at the input at add's
			them.

* Every class get's four method's (OBM_INIT,OBM_INPUT,OBM_OUTPUT and OBM_SETATTR)
			
* New is the creation of the connections (OBJ_CreateConnection), with these
  connections you can actually build your own program. You can connect any
  method. So it is possible to connection the OBM_SETATTR method to the OBM_INIT
  method of another object. Only, data along the connection is send by the
  OBJ_ToOutput (or OBJ_FromInput) function. So the method must use this function
  to make the connection work.
  
* The preset values of the classes are set (OBM_SETATTR).

* The calculation is started by triggering the OBM_OUTPUT method from the
  math_xy_obj object.


The classes
-----------

MATH_ax2Class -

  mth_ax2_InputX - 
	The class more or less 'waits' until it recieves data at the
	OBM_INPUT method. Then it searches for the BTA_X tag. Please understand
	that the TagList recieved is _read only_ because there is a chance, and
	in this example it is the fact, that other object method will recieve this
	TagList also.
	The next thing to do is to construct a TagList with the result as BTA_Y
	tag. This TagList is send with the OBJ_ToOutput function, it is send
	to the object(s) connected to this object's OBM_OUTPUT method.

  mth_ax2_OutputX -
  	This method won't be called in this example at all!!!, the method
  	_would_ be called when an object connected to this object's OBM_OUTPUT
  	(math_xy_obj) would perform a OBJ_FromInput( .., OBM_INPUT,.. );
  	When this is done we must response with the result. But we do _not_
  	cache the A*X^2 result so we must ask for the X value. Thus a
  	OBJ_FromInput function again.
	This demonstrate the 'two-way' connectivity of the BEAST connections.
	In _normal_ case the forward connections (as used in this example)
	should be enough. The backward connections could be used when the data
	sizes are large.

  mth_ax2_SetAttr -
  	This is a largly overdone method function.... but it's an example, and
  	it shows how a 'normal' OBM_SETATTR should look like.
  	BTW: the OBM_GETATTR method should look very much the same, only that
  	the case statements are storing the result _into_ the TagList.
	See also Methods.doc.
	
MATH_bxClass -
MATH_cClass  -
	All the same principle.
	
MATH_xyClass -

  mth_xy_InputY -
  	Every time a object has calculate a result this method is called.
  	It just looks for the BTA_Y tag, and if found adds it to the Y
  	instance.

  mth_xy_OutputX -
  	When called it reset the Y instance back to zero. Then constructs
  	the TagList with the preset X value. The OBJ_ToOutput function 
  	start the whole process.


As you probably will notice is that all these methods have _a lot_ in
common. And the BEAST is a OO-system so this all could be solved with
Sub/Superclasses with the famous inheritance. Example3 shows this.


