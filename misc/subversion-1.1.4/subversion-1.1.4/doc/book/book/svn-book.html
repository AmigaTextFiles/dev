<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Version Control with Subversion</title><link rel="stylesheet" href="styles.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="svn"></a>Version Control with Subversion</h1></div><div><h2 class="subtitle"><p>For Subversion 1.1</p>
            <p>(book compiled from Revision 12923)</p>
  </h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Ben</span> <span class="surname">Collins-Sussman</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Brian W.</span> <span class="surname">Fitzpatrick</span></h3></div><div class="author"><h3 class="author"><span class="firstname">C. Michael</span> <span class="surname">Pilato</span></h3></div></div></div><div><p class="copyright">Copyright © 2002, 2003, 2004 Ben Collins-Sussman, Brian W. Fitzpatrick, C. Michael Pilato</p></div><div><div class="legalnotice"><p>This work is licensed under the Creative
        Commons Attribution License. To view a copy of this license,
        visit http://creativecommons.org/licenses/by/2.0/ or send a
        letter to Creative Commons, 559 Nathan Abbott Way, Stanford,
        California 94305, USA.</p></div></div><div><p class="pubdate">(TBA)</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="preface"><a href="#svn-foreword">Foreword</a></span></dt><dt><span class="preface"><a href="#svn-ch-0">Preface</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-0-sect-1">Audience</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-2">How to Read this Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-3">Conventions Used in This Book</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-0-sect-3.1">Typographic Conventions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-3.2">Icons</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-0-sect-4">Organization of This Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-5">This Book is Free</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-6">Acknowledgments</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-0-sect-6.1">From Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-6.2">From Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-6.3">From C. Michael Pilato</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-0-sect-7">New in Subversion 1.1</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-1">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-1-sect-1">What is Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-2">Subversion's History</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-3">Subversion's Features</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-4">Subversion's Architecture</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-5">Installing Subversion</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-6">Subversion's Components</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-7">A Quick Start</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-2">2. Basic Concepts</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-2-sect-1">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-2-sect-2">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-2.1">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.2">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.3">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-3">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-3.1">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.2">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.3">How Working Copies Track the Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.4">The Limitations of Mixed Revisions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-4">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-3">3. Guided Tour</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-3-sect-1">Help!</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-2">Import</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-3">Revisions: Numbers, Keywords, and Dates, Oh My!</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-3.1">Revision Numbers</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.2">Revision Keywords</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.3">Revision Dates</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-4">Initial Checkout</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-5">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-5.1">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.2">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.3">Examine Your Changes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.1">svn status</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.2">svn diff</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.3">svn revert</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-5.4">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.1">Merging Conflicts by Hand</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.2">Copying a File Onto Your Working File</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.3">Punting: Using svn revert</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-5.5">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-6">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-6.1">svn log</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.2">svn diff</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.1">Examining Local Changes</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.2">Comparing Working Copy to Repository</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.3">Comparing Repository to Repository</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-6.3">svn cat</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.4">svn list</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.5">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-7">Other Useful Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-7.1">svn cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-7.3">svn import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-8">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-4">4. Branching and Merging</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-4-sect-1">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-2">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-2.1">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.2">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.3">The Key Concepts Behind Branches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-3">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-3.1">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-3.2">Best Practices for Merging</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.1">Tracking Merges Manually</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.2">Previewing Merges</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.3">Merge Conflicts</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.4">Noticing or Ignoring Ancestry</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-4">Common Use-Cases</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-4.1">Merging a Whole Branch to Another</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.2">Undoing Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.3">Resurrecting Deleted Items</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.4">Common Branching Patterns</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-4-sect-4.4.1">Release Branches</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-4.4.2">Feature Branches</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-5">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-6">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-6.1">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-6.2">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-7">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-7.1">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-7.2">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-8">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-5">5. Repository Administration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-5-sect-1">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-1.1">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.2">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.3">Repository Data-Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-5-sect-1.3.1">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-1.3.2">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-2">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-2.1">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-2.2">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-3">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-3.1">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.1">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.2">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.3">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.4">svnshell.py</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.5">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-5-sect-3.2">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.3">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.4">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.5">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.6">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-6">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-6.1">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-6.2">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-7">Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-6">6. Server Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-6-sect-1">Overview</a></span></dt><dt><span class="sect1"><a href="#svn-ch-6-sect-2">Network Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-2.1">Requests and Responses</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.2">Client Credentials Caching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-3">svnserve, a custom server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-3.1">Invoking the Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-3.2">Built-in authentication and authorization</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-3.2.1">Create a 'users' file and realm</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-3.2.2">Set access controls</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-3.3">External path-based authorization</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-3.4">SSH authentication and authorization</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-4">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-4.1">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.2">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.3">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.3.1">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.3.2">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-4.4">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.4.1">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.4.2">Per-Directory Access Control</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-4.5">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.5.1">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.5.2">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-5">Supporting Multiple Repository Access Methods</a></span></dt></dl></dd><dt><span class="chapter"><a href="#svn-ch-7">7. Advanced Topics</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-7-sect-1">Runtime Configuration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-1.1">Configuration Area Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.2">Configuration and the Windows Registry</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-1.3">Configuration Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-7-sect-1.3.1">Servers</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-1.3.2">Config</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-2">Properties</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-2.1">Why Properties?</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.2">Manipulating Properties</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-2.3">Special Properties</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.1">svn:executable</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.2">svn:mime-type</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.3">svn:ignore</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.4">svn:keywords</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.5">svn:eol-style</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.6">svn:externals</a></span></dt><dt><span class="sect3"><a href="#svn-ch-7-sect-2.3.7">svn:special</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-7-sect-2.4">Automatic Property Setting</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-7-sect-3">Externals Definitions</a></span></dt><dt><span class="sect1"><a href="#svn-ch-7-sect-4">Vendor branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-7-sect-4.1">General Vendor Branch Management Procedure</a></span></dt><dt><span class="sect2"><a href="#svn-ch-7-sect-4.2">svn_load_dirs.pl</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn-ch-8">8. Developer Information</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-8-sect-1">Layered Library Design</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-1.1">Repository Layer</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-1.2">Repository Access Layer</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-8-sect-1.2.1">RA-DAV (Repository Access Using HTTP/DAV)</a></span></dt><dt><span class="sect3"><a href="#svn-ch-8-sect-1.2.2">RA-SVN (Custom Protocol Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn-ch-8-sect-1.2.3">RA-Local (Direct Repository Access)</a></span></dt><dt><span class="sect3"><a href="#svn-ch-8-sect-1.2.4">Your RA Library Here</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-8-sect-1.3">Client Layer</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-2">Using the APIs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-2.1">The Apache Portable Runtime Library</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-2.2">URL and Path Requirements</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-2.3">Using Languages Other than C and C++</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-3">Inside the Working Copy Administration Area</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-3.1">The Entries File</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-3.2">Pristine Copies and Property Files</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-8-sect-4">WebDAV</a></span></dt><dt><span class="sect1"><a href="#svn-ch-8-sect-5">Programming with Memory Pools</a></span></dt><dt><span class="sect1"><a href="#svn-ch-8-sect-6">Contributing to Subversion</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-8-sect-6.1">Join the Community</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-6.2">Get the Source Code</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-6.3">Become Familiar with Community Policies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-6.4">Make and Test Your Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-8-sect-6.5">Donate Your Changes</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#svn-ch-9">9. Subversion Complete Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ch-9-sect-1">The Subversion Command Line Client:
      svn</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-9-sect-1.1">svn Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-9-sect-1.2">svn Subcommands</a></span></dt><dd><dl><dt><a href="#svn-ch-9-sect-1.2-re-add">svn add</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-blame">svn blame</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-cat">svn cat</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-checkout">svn checkout</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-cleanup">svn cleanup</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-commit">svn commit</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-copy">svn copy</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-delete">svn delete</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-diff">svn diff</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-export">svn export</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-help">svn help</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-import">svn import</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-info">svn info</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-list">svn list</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-log">svn log</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-merge">svn merge</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-mkdir">svn mkdir</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-move">svn move</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-propdel">svn propdel</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-propedit">svn propedit</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-propget">svn propget</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-proplist">svn proplist</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-propset">svn propset</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-resolved">svn resolved</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-revert">svn revert</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-status">svn status</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-switch">svn switch</a></dt><dt><a href="#svn-ch-9-sect-1.2-re-update">svn update</a></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-9-sect-2">svnadmin</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-9-sect-2.1">svnadmin Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-9-sect-2.2">svnadmin Subcommands</a></span></dt><dd><dl><dt><a href="#svn-ch-9-sect-2.2-re-create">svnadmin create</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-deltify">svnadmin deltify</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-dump">svnadmin dump</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-help">svnadmin help</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-hotcopy">svnadmin hotcopy</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-list-dblogs">svnadmin list-dblogs</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-list-unused-dblogs">svnadmin list-unused-dblogs</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-load">svnadmin load</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-lstxns">svnadmin lstxns</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-recover">svnadmin recover</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-rmtxns">svnadmin rmtxns</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-setlog">svnadmin setlog</a></dt><dt><a href="#svn-ch-9-sect-2.2-re-verify">svnadmin verify</a></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-9-sect-3">svnlook</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-9-sect-3.1">svnlook Switches</a></span></dt><dt><span class="sect2"><a href="#svn-ch-9-sect-3.2">svnlook</a></span></dt><dd><dl><dt><a href="#svn-ch-9-sect-3.2-re-author">svnlook author</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-cat">svnlook cat</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-changed">svnlook changed</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-date">svnlook date</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-diff">svnlook diff</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-dirs-changed">svnlook dirs-changed</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-help">svnlook help</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-history">svnlook history</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-info">svnlook info</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-log">svnlook log</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-propget">svnlook propget</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-proplist">svnlook proplist</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-tree">svnlook tree</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-uuid">svnlook uuid</a></dt><dt><a href="#svn-ch-9-sect-3.2-re-youngest">svnlook youngest</a></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-9-sect-4">svnserve</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-9-sect-4.1">svnserve Switches</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-a">A. Subversion for CVS Users</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-a-sect-1">Revision Numbers Are Different Now</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-2">Directory Versions</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-3">More Disconnected Operations</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-4">Distinction Between Status and Update</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-5">Branches and Tags</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-6">Metadata Properties</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-7">Conflict Resolution</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-8">Binary Files and Translation</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-9">Versioned Modules</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-10">Authentication</a></span></dt><dt><span class="sect1"><a href="#svn-ap-a-sect-11">Converting a Repository from CVS to Subversion</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn-ap-b">B. Troubleshooting</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-b-sect-1">Common Problems</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-b-sect-1.2">Problems Using Subversion</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.1">Every time I try to access my repository, my Subversion
          client just hangs.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.2">Every time I try to run svn, it
          says my working copy is locked.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.3">I'm getting errors finding or opening a repository,
          but I know my repository URL is correct.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.4">How can I specify a Windows drive letter in a
          file:// URL?</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.5">I'm having trouble doing write operations to a
          Subversion repository over a network.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.6">Under Windows XP, the Subversion server sometimes
          seems to send out corrupted data.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.7">What is the best method of doing a network trace of
          the conversation between a Subversion client and
          Apache server?</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.8">I just built the distribution binary, and when I try to
          check out Subversion, I get an error about an Unrecognized
          URL scheme.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.9">Why does the svn revert command
          require an explicit target? Why is it not recursive by
          default? This behavior differs from almost all the other
          subcommands.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.10">When I start Apache, mod_dav_svn complains about a
          bad database version, that it found db-3.X,
          rather than db-4.X.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.11">I'm getting Function not implemented
          errors on RedHat 9, and nothing works. How do I fix
          this?</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.12">Why does log say (no author) for files
          committed or imported via Apache (ra_dav)?</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.13">I'm getting occasional Access Denied
          errors on Windows.  They seem to happen at random.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.14">On FreeBSD, certain operations (especially svnadmin
          create) sometimes hang.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.15">I can see my repository in a web browser, but
          svn checkout gives me an error about
          301 Moved Permanently.</a></span></dt><dt><span class="sect3"><a href="#svn-ap-b-sect-1.2.16">I'm trying to look at an old version of my file, but
          svn says something about path not
          found.</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-c">C. WebDAV and Autoversioning</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-c-sect-1">Basic WebDAV Concepts</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-c-sect-1.1">Just Plain WebDAV</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-1.2">DeltaV Extensions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ap-c-sect-2">Subversion and DeltaV</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-c-sect-2.1">Mapping Subversion to DeltaV</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-2.2">Autoversioning Support</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-2.3">The mod_dav_lock Alternative</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ap-c-sect-3">Autoversioning Interoperability</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ap-c-sect-3.1">Win32 WebFolders</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-3.2">Mac OS X</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-3.3">Unix: Nautilus 2</a></span></dt><dt><span class="sect2"><a href="#svn-ap-c-sect-3.4">Linux davfs2</a></span></dt></dl></dd></dl></dd><dt><span class="appendix"><a href="#svn-ap-d">D. Third Party Tools</a></span></dt><dd><dl><dt><span class="sect1"><a href="#svn-ap-d-sect-1">Clients and Plugins</a></span></dt><dt><span class="sect1"><a href="#svn-ap-d-sect-2">Language Bindings</a></span></dt><dt><span class="sect1"><a href="#svn-ap-d-sect-3">Repository Converters</a></span></dt><dt><span class="sect1"><a href="#svn-ap-d-sect-4">Higher Level Tools</a></span></dt><dt><span class="sect1"><a href="#svn-ap-d-sect-5">Repository Browsing Tools</a></span></dt></dl></dd><dt><span class="appendix"><a href="#svn-copyright">E. Copyright</a></span></dt></dl></div><div class="list-of-figures"><p><b>List of Figures</b></p><dl><dt>1.1. <a href="#svn-ch-1-dia-1">Subversion's Architecture</a></dt><dt>2.1. <a href="#svn-ch-2-dia-1">A typical client/server system</a></dt><dt>2.2. <a href="#svn-ch-2-dia-2">The problem to avoid</a></dt><dt>2.3. <a href="#svn-ch-2-dia-3">The lock-modify-unlock solution</a></dt><dt>2.4. <a href="#svn-ch-2-dia-4">The copy-modify-merge solution</a></dt><dt>2.5. <a href="#svn-ch-2-dia-5">The copy-modify-merge solution (continued)</a></dt><dt>2.6. <a href="#svn-ch-2-dia-6">The repository's filesystem</a></dt><dt>2.7. <a href="#svn-ch-2-dia-7">The repository</a></dt><dt>4.1. <a href="#svn-ch-4-dia-1">Branches of development</a></dt><dt>4.2. <a href="#svn-ch-4-dia-2">Starting repository layout</a></dt><dt>4.3. <a href="#svn-ch-4-dia-3">Repository with new copy</a></dt><dt>4.4. <a href="#svn-ch-4-dia-4">The branching of one file's history</a></dt><dt>8.1. <a href="#svn-ch-8-dia-1">Files and directories in two dimensions</a></dt><dt>8.2. <a href="#svn-ch-8-dia-2">Versioning time&#8212;the third dimension!</a></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>2.1. <a href="#svn-ch-2-table-1">Repository Access URLs</a></dt><dt>5.1. <a href="#svn-ch-5-table-1">Repository Data-Store Comparison</a></dt><dt>6.1. <a href="#svn-ch-6-table-1">Network Server Comparison</a></dt><dt>8.1. <a href="#svn-ch-8-table-1">A Brief Inventory of the Subversion Libraries</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>5.1. <a href="#svn-ch-8-sect-3.1.3-ex-1">Using svnshell to Navigate the Repository</a></dt><dt>5.2. <a href="#svn-ch-5-sect-3.2-ex-1">txn-info.sh (Reporting Outstanding Transactions)</a></dt><dt>6.1. <a href="#svn-ch-6-sect-4.4.2-ex-1">A sample configuration for anonymous access.</a></dt><dt>6.2. <a href="#svn-ch-6-sect-4.4.2-ex-2">A sample configuration for authenticated access.</a></dt><dt>6.3. <a href="#svn-ch-6-sect-4.4.2-ex-3">A sample configuration for mixed
            authenticated/anonymous access.</a></dt><dt>7.1. <a href="#svn-ch-7-sect-1.2-ex-1">Sample Registration Entries (.reg) File.</a></dt><dt>8.1. <a href="#svn-ch-8-sect-1.1-ex-1">Using the Repository Layer</a></dt><dt>8.2. <a href="#svn-ch-8-sect-2.3-ex-1">Using the Repository Layer with Python</a></dt><dt>8.3. <a href="#svn-ch-8-sect-2.3-ex-2">A Simple Script to Check Out a Working Copy.</a></dt><dt>8.4. <a href="#svn-ch-8-sect-3-ex-1">Contents of a Typical .svn/entries
          File</a></dt><dt>8.5. <a href="#svn-ch-8-sect-5-ex-1">Effective Pool Usage</a></dt></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-foreword"></a>Foreword</h2></div></div><div></div></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>A bad Frequently Asked Questions (FAQ) sheet is one that is
      composed not of the questions people actually asked, but of the
      questions the FAQ's author <span class="emphasis"><em>wished</em></span> people
      had asked.  Perhaps you've seen the type before:</p><div class="blockquote"><blockquote class="blockquote"><p>Q: How can I use Glorbosoft XYZ to maximize team
        productivity?</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>A: Many of our customers want to know how they can
        maximize productivity through our patented office groupware
        innovations.  The answer is simple: first, click on the
        &#8220;<span class="quote"><tt class="literal">File</tt></span>&#8221; menu, scroll down to
        &#8220;<span class="quote"><tt class="literal">Increase Productivity</tt></span>&#8221;,
        then&#8230;</p></blockquote></div><p>The problem with such FAQs is that they are not, in a
      literal sense, FAQs at all.  No one ever called the tech support
      line and asked, &#8220;<span class="quote">How can we maximize
      productivity?</span>&#8221;.  Rather, people asked highly specific
      questions, like, &#8220;<span class="quote">How can we change the calendaring system
      to send reminders two days in advance instead of one?</span>&#8221;
      and so on.  But it's a lot easier to make up imaginary
      Frequently Asked Questions than it is to discover the real ones.
      Compiling a true FAQ sheet requires a sustained, organized
      effort: over the lifetime of the software, incoming questions
      must be tracked, responses monitored, and all gathered into a
      coherent, searchable whole that reflects the collective
      experience of users in the wild.  It calls for the patient,
      observant attitude of a field naturalist.  No grand
      hypothesizing, no visionary pronouncements here&#8212;open eyes
      and accurate note-taking are what's needed most.</p><p>What I love about this book is that it grew out of just such
      a process, and shows it on every page.  It is the direct result
      of the authors' encounters with users.  It began with Ben
      Collins-Sussman's observation that people were asking the same
      basic questions over and over on the Subversion mailing lists:
      What are the standard workflows to use with Subversion?  Do
      branches and tags work the same way as in other version control
      systems?  How can I find out who made a particular change?</p><p>Frustrated at seeing the same questions day after day, Ben
      worked intensely over a month in the summer of 2002 to write
      <i class="citetitle">The Subversion Handbook</i>, a sixty page
      manual that covered all the basics of using Subversion.  The
      manual made no pretense of being complete, but it was
      distributed with Subversion and got users over that initial hump
      in the learning curve.  When O'Reilly and Associates decided to
      publish a full-length Subversion book, the path of least
      resistance was obvious: just expand the Subversion
      handbook.</p><p>The three co-authors of the new book were thus presented
      with an unusual opportunity.  Officially, their task was to
      write a book top-down, starting from a table of contents and an
      initial draft.  But they also had access to a steady
      stream&#8212;indeed, an uncontrollable geyser&#8212;of bottom-up
      source material.  Subversion was already in the hands of
      thousands of early adopters, and those users were giving tons of
      feedback, not only about Subversion, but about its existing
      documentation.</p><p>During the entire time they wrote this book, Ben, Mike, and
      Brian haunted the Subversion mailing lists and chat rooms
      incessantly, carefully noting the problems users were having in
      real-life situations.  Monitoring such feedback is part of their
      job descriptions at CollabNet anyway, and it gave them a huge
      advantage when they set out to document Subversion.  The book
      they produced is grounded firmly in the bedrock of experience,
      not in the shifting sands of wishful thinking; it combines the
      best aspects of user manual and FAQ sheet.  This duality might
      not be noticeable on a first reading.  Taken in order, front to
      back, the book is simply a straightforward description of a
      piece of software.  There's the overview, the obligatory guided
      tour, the chapter on administrative configuration, some advanced
      topics, and of course a command reference and troubleshooting
      guide.  Only when you come back to it later, seeking the
      solution to some specific problem, does its authenticity shine
      out: the telling details that can only result from encounters
      with the unexpected, the examples honed from genuine use cases,
      and most of all the sensitivity to the user's needs and the
      user's point of view.</p><p>Of course, no one can promise that this book will answer
      every question you have about Subversion.  Sometimes, the
      precision with which it anticipates your questions will seem
      eerily telepathic; yet occasionally, you will stumble into a
      hole in the community's knowledge, and come away empty-handed.
      When this happens, the best thing you can do is email
      <tt class="email">&lt;<a href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</tt> and present your
      problem.  The authors are still there, still watching, and they
      include not just the three listed on the cover, but many others
      who contributed corrections and original material.  From the
      community's point of view, solving your problem is merely a
      pleasant side effect of a much larger project&#8212;namely,
      slowly adjusting this book, and ultimately Subversion itself, to
      more closely match the way people actually use it.  They are
      eager to hear from you not merely because they can help you, but
      because you can help them.  With Subversion as with all active
      free software projects, <span class="emphasis"><em>you are not
      alone</em></span>.</p><p>Let this book be your first companion.</p><p>&#8212;
      <span class="author"><span class="firstname">Karl</span> <span class="surname">Fogel</span></span>, Chicago, 14 March, 2004</p></div></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-0"></a>Preface</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-0-sect-1">Audience</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-2">How to Read this Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-3">Conventions Used in This Book</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-0-sect-3.1">Typographic Conventions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-3.2">Icons</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-0-sect-4">Organization of This Book</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-5">This Book is Free</a></span></dt><dt><span class="sect1"><a href="#svn-ch-0-sect-6">Acknowledgments</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-0-sect-6.1">From Ben Collins-Sussman</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-6.2">From Brian W. Fitzpatrick</a></span></dt><dt><span class="sect2"><a href="#svn-ch-0-sect-6.3">From C. Michael Pilato</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-0-sect-7">New in Subversion 1.1</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><div class="blockquote"><blockquote class="blockquote"><p>&#8220;<span class="quote">If C gives you enough rope to hang yourself, think
        of Subversion as a sort of rope storage facility.</span>&#8221;
        &#8212;Brian W. Fitzpatrick</p></blockquote></div><p>In the world of open-source software, the Concurrent
      Versions System (CVS) has long been the tool of choice for
      version control.  And rightly so.  CVS itself is free software,
      and its non-restrictive <span class="foreignphrase"><i class="foreignphrase">modus
      operandi</i></span> and support for networked
      operation&#8212;which allow dozens of geographically dispersed
      programmers to share their work&#8212;fits the collaborative
      nature of the open-source world very well.  CVS and its
      semi-chaotic development model have become cornerstones of
      open-source culture.
    </p><p>But like many tools, CVS is starting to show its age.
      Subversion is a relatively new version control system designed
      to be the successor to CVS.  The designers set out to win the
      hearts of CVS users in two ways: by creating an open-source
      system with a design (and &#8220;<span class="quote">look and feel</span>&#8221;) similar
      to CVS, and by attempting to fix most of CVS's noticeable flaws.
      While the result isn't necessarily the next great evolution in
      version control design, Subversion <span class="emphasis"><em>is</em></span> very
      powerful, very usable, and very flexible.
    </p><p>This book is written to document the 1.1 series of the
      Subversion version control system.  We have made every attempt to be
      thorough in our coverage.  However, Subversion has a thriving
      and energetic development community, so there are already a
      number of features and improvements planned for future versions
      of Subversion that may change some of the commands and specific
      notes in this book.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-1"></a>Audience</h2></div></div><div></div></div><p>This book is written for computer-literate folk who want to
      use Subversion to manage their data.  While Subversion runs on a
      number of different operating systems, its primary user
      interface is command-line based.  It is that command-line tool
      (<span><b class="command">svn</b></span>) which is discussed and used in this
      book.  For consistency, the examples in this book assume the
      reader is using a Unix-like operating system, and is relatively
      comfortable with Unix and command-line interfaces.</p><p>That said, the <span><b class="command">svn</b></span> program also runs on
      non-Unix platforms like Microsoft Windows.  With a few minor
      exceptions, such as the use of backward slashes
      (<tt class="literal">\</tt>) instead of forward slashes
      (<tt class="literal">/</tt>) for path separators, the input to and
      output from this tool when run on Windows are identical to its
      Unix counterpart.  However, Windows users may find more success
      by running the examples inside the Cygwin Unix emulation
      environment.</p><p>Most readers are probably programmers or sysadmins who need
      to track changes to source code.  This is the most common use
      for Subversion, and therefore it is the scenario underlying all
      of the book's examples.  But Subversion can be used to manage
      changes to any sort of information: images, music, databases,
      documentation, and so on.  To Subversion, all data is just
      data.</p><p>While this book is written with the assumption that the
      reader has never used version control, we've also tried to make
      it easy for users of CVS to make a painless leap into
      Subversion.  Special sidebars may discuss CVS from time to time,
      and a special appendix summarizes most of the differences
      between CVS and Subversion.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-2"></a>How to Read this Book</h2></div></div><div></div></div><p>This book aims to be useful to people of widely different
      backgrounds&#8212;from people with no previous experience in
      version control to experienced sysadmins.  Depending on your own
      background, certain chapters may be more or less important to
      you.  The following can be considered a &#8220;<span class="quote">recommended
      reading list</span>&#8221; for various types of readers:</p><div class="variablelist"><dl><dt><span class="term">Experienced sysadmins</span></dt><dd><p>The assumption here is that you've probably used CVS
            before, and are dying to get a Subversion server up and
            running ASAP.  Chapters 5 and 6 will show you how to create
            your first repository and make it available over the
            network.  After that's done, chapter 3 and appendix A are
            the fastest routes to learning the Subversion client while
            drawing on your CVS experience.</p></dd><dt><span class="term">New users</span></dt><dd><p>Your administrator has probably set up Subversion
            already, and you need to learn how to use the client.  If
            you've never used a version control system (like CVS),
            then chapters 2 and 3 are a vital introduction.  If you're
            already an old hand at CVS, chapter 3 and appendix A are
            the best place to start.</p></dd><dt><span class="term">Advanced users</span></dt><dd><p>Whether you're a user or administrator, eventually
            your project will grow larger.  You're going to want to
            learn how to do more advanced things with Subversion, such
            as how to use branches and perform merges (chapter 4),
            how to use Subversion's property support, how to configure
            runtime options (chapter 7), and other things.  Chapters 4
            and 7 aren't vital at first, but be sure to read them once
            you're comfortable with the basics.</p></dd><dt><span class="term">Developers</span></dt><dd><p>Presumably, you're already familiar with Subversion,
            and now want to either extend it or build new software on
            top of its many APIs.  Chapter 8 is just for you.</p></dd></dl></div><p>The book ends with reference material&#8212;chapter 9 is a
      reference guide for all Subversion commands, and the appendices
      cover a number of useful topics.  These are the chapters you're
      mostly likely to come back to after you've finished the
      book.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-3"></a>Conventions Used in This Book</h2></div></div><div></div></div><p>This section covers the various conventions used in this
      book.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-0-sect-3.1"></a>Typographic Conventions</h3></div></div><div></div></div><div class="variablelist"><dl><dt><span class="term"><span><b class="command">Constant width</b></span></span></dt><dd><p>Used for commands, command output, and switches</p></dd><dt><span class="term"><i class="replaceable"><tt>Constant width italic</tt></i></span></dt><dd><p>Used for replaceable items in code and text</p></dd><dt><span class="term"><tt class="filename">Italic</tt></span></dt><dd><p>Used for file and directory names</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-0-sect-3.2"></a>Icons</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This icon designates a note relating to the surrounding
          text.</p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>This icon designates a helpful tip relating to the surrounding
          text.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>This icon designates a warning relating to the surrounding
          text.</p></div></div><p>Note that the source code examples are just
      that&#8212;examples. While they will compile with the proper
      compiler incantations, they are intended to illustrate the
      problem at hand, not necessarily serve as examples of good
      programming style.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-4"></a>Organization of This Book</h2></div></div><div></div></div><p>The chapters that follow and their contents are listed
      here:</p><div class="variablelist"><dl><dt><span class="term">Chapter 1, <span class="emphasis"><em>Introduction</em></span></span></dt><dd><p>Covers the history of Subversion as well as its
              features, architecture, components, and install
              methods.  Also includes a quick-start guide.</p></dd><dt><span class="term">Chapter 2, <span class="emphasis"><em>Basic Concepts</em></span></span></dt><dd><p>Explains the basics of version control and different
              versioning models, along with Subversion's repository,
              working copies, and revisions.</p></dd><dt><span class="term">Chapter 3, <span class="emphasis"><em>Guided Tour</em></span></span></dt><dd><p>Walks you through a day in the life of a Subversion
              user.  It demonstrates how to use Subversion to obtain,
              modify, and commit data.</p></dd><dt><span class="term">Chapter 4, <span class="emphasis"><em>Branching and Merging</em></span></span></dt><dd><p>Discusses branches, merges, and tagging, including
              best practices for branching and merging, common
              use-cases, how to undo changes, and how to easily swing
              from one branch to the next.</p></dd><dt><span class="term">Chapter 5, <span class="emphasis"><em>Repository
            Administration</em></span></span></dt><dd><p>Describes the basics of the Subversion repository,
              how to create, configure, and maintain a repository, and
              the tools you can use to do all of this.</p></dd><dt><span class="term">Chapter 6, <span class="emphasis"><em>Server Configuration</em></span></span></dt><dd><p>Explains how to configure your Subversion server and
              the three ways to access your repository:
              <tt class="literal">HTTP</tt>, the <tt class="literal">svn</tt>
              protocol, and local access.  It also covers the details
              of authentication, authorization and anonymous
              access.</p></dd><dt><span class="term">Chapter 7, <span class="emphasis"><em>Advanced Topics</em></span></span></dt><dd><p>Explores the Subversion client configuration files,
              file and directory properties, how to
              <tt class="literal">ignore</tt> files in your working copy,
              how to include external trees in your working copy, and
              lastly, how to handle vendor branches.</p></dd><dt><span class="term">Chapter 8, <span class="emphasis"><em>Developer Information</em></span></span></dt><dd><p>Describes the internals of Subversion, the
              Subversion filesystem, and the working copy
              administrative areas from a programmer's point of view.
              Demonstrates how to use the public APIs to write a
              program that uses Subversion, and most importantly, how
              to contribute to the development of Subversion.</p></dd><dt><span class="term">Chapter 9, <span class="emphasis"><em>Subversion Complete
            Reference</em></span></span></dt><dd><p>Explains in great detail every subcommand of
              <span><b class="command">svn</b></span>, <span><b class="command">svnadmin</b></span>, and
              <span><b class="command">svnlook</b></span> with plenty of examples for
              the whole family!</p></dd><dt><span class="term">Appendix A, <span class="emphasis"><em>Subversion for CVS
            Users</em></span></span></dt><dd><p>Covers the similarities and differences between
              Subversion and CVS, with numerous suggestions on how to
              break all the bad habits you picked up from years of
              using CVS.  Included are descriptions of Subversion
              revision numbers, versioned directories, offline
              operations, <span><b class="command">update</b></span>
              vs. <span><b class="command">status</b></span>, branches, tags, metadata,
              conflict resolution, and authentication.</p></dd><dt><span class="term">Appendix B, <span class="emphasis"><em>Troubleshooting</em></span></span></dt><dd><p>Addresses common problems and difficulties using and
              building Subversion.</p></dd><dt><span class="term">Appendix C, <span class="emphasis"><em>WebDAV and
            Autoversioning</em></span></span></dt><dd><p>Describes the details of WebDAV and DeltaV, and how
              you can configure your Subversion repository to be
              mounted read/write as a DAV share.</p></dd><dt><span class="term">Appendix D, <span class="emphasis"><em>Third Party Tools</em></span></span></dt><dd><p>Discusses tools that support or use Subversion,
              including alternative client programs, repository
              browser tools, and so on.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-5"></a>This Book is Free</h2></div></div><div></div></div><p>This book started out as bits of documentation written by
      Subversion project developers, which were then coalesced into a
      single work and rewritten.  As such, it has always been under a
      free license.  (See <a href="#svn-copyright" title="Appendix E. Copyright">Appendix E, <i>Copyright</i></a>.)  In fact,
      the book was written in the public eye, as a part of Subversion.
      This means two things:</p><div class="itemizedlist"><ul type="disc"><li><p>You will always find the latest version of this book in
          Subversion's own source tree.</p></li><li><p>You can distribute and make changes to this book however
          you wish&#8212;it's under a free license.  Of course,
          rather than distribute your own private version of this
          book, we'd much rather you send feedback and patches to the
          Subversion developer community.  See <a href="#svn-ch-8-sect-6" title="Contributing to Subversion">the section called &#8220;Contributing to Subversion&#8221;</a> to learn about joining this
          community.</p></li></ul></div><p>You can send publishing comments and questions to O'Reilly
      here: ###insert boilerplate.</p><p>A relatively recent online version of this book can be found
      at <tt class="systemitem">http://svnbook.red-bean.com</tt>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-6"></a>Acknowledgments</h2></div></div><div></div></div><p>This book would not be possible (nor very useful) if
      Subversion did not exist.  For that, the authors would like to
      thank Brian Behlendorf and CollabNet for the vision to fund such
      a risky and ambitious new Open Source project; Jim Blandy for
      the original Subversion name and design&#8212;we love you, Jim;
      Karl Fogel for being such a good friend and a great community
      leader, in that order.<sup>[<a name="id868920" href="#ftn.id868920">1</a>]</sup></p><p>Thanks to O'Reilly and our editors, Linda Mui and Tatiana
      Diaz for their patience and support.</p><p>Finally, we thank the countless people who contributed to
      this book with informal reviews, suggestions, and fixes: While
      this is undoubtedly not a complete list, this book would be
      incomplete and incorrect without the help of: Jani Averbach,
      Ryan Barrett, Francois Beausoleil, Jennifer Bevan, Matt Blais,
      Zack Brown, Martin Buchholz, Brane Cibej, John R. Daily, Peter
      Davis, Olivier Davy, Robert P. J. Day, Mo DeJong, Brian Denny,
      Joe Drew, Nick Duffek, Ben Elliston, Justin Erenkrantz, Shlomi
      Fish, Julian Foad, Chris Foote, Martin Furter, Dave Gilbert,
      Eric Gillespie, Matthew Gregan, Art Haas, Greg Hudson, Alexis
      Huxley, Jens B. Jorgensen, Tez Kamihira, David Kimdon, Mark
      Benedetto King, Andreas J. Koenig, Nuutti Kotivuori, Matt Kraai,
      Scott Lamb, Vincent Lefevre, Morten Ludvigsen, Paul Lussier,
      Bruce A. Mah, Philip Martin, Feliciano Matias, Patrick Mayweg,
      Gareth McCaughan, Jon Middleton, Tim Moloney, Mats Nilsson, Joe
      Orton, Amy Lyn Pilato, Kevin Pilch-Bisson, Dmitriy Popkov,
      Michael Price, Mark Proctor, Steffen Prohaska, Daniel Rall,
      Tobias Ringstrom, Garrett Rooney, Joel Rosdahl, Christian Sauer,
      Larry Shatzer, Russell Steicke, Sander Striker, Erik Sjoelund,
      Johan Sundstroem, John Szakmeister, Mason Thomas, Eric
      Wadsworth, Colin Watson, Alex Waugh, Chad Whitacre, Josef Wolf,
      Blair Zajac, and the entire Subversion community.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-0-sect-6.1"></a>From Ben Collins-Sussman</h3></div></div><div></div></div><p>Thanks to my wife Frances, who, for many months, got to
        hear, &#8220;<span class="quote">But honey, I'm still working on the book</span>&#8221;,
        rather than the usual, &#8220;<span class="quote">But honey, I'm still doing
        email.</span>&#8221;  I don't know where she gets all that patience!
        She's my perfect counterbalance.</p><p>Thanks to my extended family for their sincere
        encouragement, despite having no actual interest in the
        subject.  (You know, the ones who say, &#8220;<span class="quote">Ooh, you're
        writing a book?</span>&#8221;, and then when you tell them it's a
        computer book, sort of glaze over.)</p><p>Thanks to all my close friends, who make me a rich, rich man.
        Don't look at me that way&#8212;you know who you are.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-0-sect-6.2"></a>From Brian W. Fitzpatrick</h3></div></div><div></div></div><p>Huge thanks to my wife Marie for being incredibly
        understanding, supportive, and most of all, patient.  Thank
        you to my brother Eric who first introduced me to UNIX
        programming way back when. Thanks to my Mom and Grandmother
        for all their support, not to mention enduring a Christmas
        holiday where I came home and promptly buried my head in my
        laptop to work on the book.</p><p>To Mike and Ben: It was a pleasure working with you on the
        book.  Heck, it's a pleasure working with you at work!</p><p>To everyone in the Subversion community and the Apache
        Software Foundation, thanks for having me.  Not a day goes by
        where I don't learn something from at least one of you.
      </p><p>Lastly, thanks to my Grandfather who always told me that
        &#8220;<span class="quote">freedom equals responsibility.</span>&#8221; I couldn't agree
        more.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-0-sect-6.3"></a>From C. Michael Pilato</h3></div></div><div></div></div><p>Special thanks to my wife, Amy, for her love and patient
        support, for putting up with late nights, and for even
        reviewing entire sections of this book&#8212;you always go the
        extra mile, and do so with incredible grace.  Gavin, when
        you're old enough to read, I hope you're as proud of your
        Daddy as he is of you.  Mom and Dad (and the rest of the
        family), thanks for your constant support and enthusiasm.</p><p>Hats off to Shep Kendall, through whom the world of
        computers was first opened to me; Ben Collins-Sussman, my
        tour-guide through the open-source world; Karl Fogel&#8212;you
        <span class="emphasis"><em>are</em></span> my <tt class="filename">.emacs</tt>; Greg
        Stein, for oozing practical programming know-how; Brian
        Fitzpatrick&#8212;for sharing this writing experience with me.
        To the many folks from whom I am constantly picking up new
        knowledge&#8212;keep dropping it!</p><p>Finally, to the One who perfectly demonstrates creative
        excellence&#8212;thank you.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-0-sect-7"></a>New in Subversion 1.1</h2></div></div><div></div></div><p>This edition of the book has been updated to cover new
      features and behavioral changes in Subversion 1.1.  Here's a
      brief list of pointers to major 1.1 changes.</p><div class="variablelist"><dl><dt><span class="term">Non-database repositories</span></dt><dd><p>It's now possible to create repositories that don't
            use a BerkeleyDB database.  Instead, these new
            repositories store data in the ordinary filesystem using a
            custom file format.  These repositories aren't susceptible
            to &#8220;<span class="quote">wedging</span>&#8221;, but also aren't as well-tested
            as Berkeley DB repositories.  See <a href="#svn-ch-5-sect-1.3" title="Repository Data-Stores">the section called &#8220;Repository Data-Stores&#8221;</a>.</p></dd><dt><span class="term">Symbolic link versioning</span></dt><dd><p>Unix users can now create symbolic links and place
            them under version control with the <span><b class="command">svn
            add</b></span> command.  See <a href="#svn-ch-9-sect-1.2-re-add" title="svn add">svn add</a> and <a href="#svn-ch-7-sect-2.3.7" title="svn:special">the section called &#8220;svn:special&#8221;</a>.</p></dd><dt><span class="term">Client follows copies and renames</span></dt><dd><p>Branches (copies) of files and directories maintain
            historical connections to their source, but in Subversion
            1.0 only <span><b class="command">svn log</b></span> ever followed that
            copy/rename history, not other commands like <span><b class="command">svn
            diff</b></span>, <span><b class="command">svn merge</b></span>, <span><b class="command">svn
            list</b></span>, or <span><b class="command">svn cat</b></span>.  In
            Subversion 1.1, all client subcommands now transparently
            trace backwards through copies and renames when examining
            older versions of files and directories.</p></dd><dt><span class="term">Client auto-escaping of URIs and IRIs</span></dt><dd><p>In the 1.0 command-line client, users had to escape
            URLs manually.  The client only accepted &#8220;<span class="quote">legally
            correct</span>&#8221; URLs, such as
            <tt class="literal">http://host/path%20with%20space/project/espa%F1a</tt>.
            The 1.1 command-line client now knows how to do what
            web-browsers have been doing for long time: it
            auto-escapes characters like spaces and accented letters,
            as long as the user places the
            URL in quotes to protect characters from the shell:
            <tt class="literal">"http://host/path with
            space/project/españa"</tt></p></dd><dt><span class="term">Localized user messages</span></dt><dd><p>Subversion 1.1 is now using
            <tt class="literal">gettext()</tt> to display translated error,
            informational, and help messages to the user. There are
            currently translations for German, Spanish, Polish,
            Swedish, Traditional Chinese, Japanese, Brazilian
            Portuguese and Norwegian Bokmal.  To localize your
            Subversion client, just set your shell's LANG environment
            variable to a supported locale value (for example,
            <tt class="literal">de_DE</tt>).</p></dd><dt><span class="term">Shareable working copies</span></dt><dd><p>There have been historical problems with permissions
            when multiple users share a working copy, which are
            believed to be fixed now.</p></dd><dt><span class="term"><tt class="literal">store-passwords</tt> run-time variable</span></dt><dd><p>This is a new runtime variable which only disables
            password caching, so that server certificates can still be
            cached.  See <a href="#svn-ch-7-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>.</p></dd><dt><span class="term">Optimizations and bug fixes</span></dt><dd><p>The <span><b class="command">svn checkout</b></span>, <span><b class="command">svn
            update</b></span>, <span><b class="command">svn status</b></span>, and
            <span><b class="command">svn blame</b></span> commands are faster.  More
            than fifty small bugs have been fixed, all described in
            the Subversion project's CHANGES file (at <tt class="systemitem">http://svn.collab.net/repos/svn/trunk/CHANGES
            </tt>).</p></dd><dt><span class="term">New command switches</span></dt><dd><div class="itemizedlist"><ul type="disc"><li><p><span><b class="command">svn blame --verbose</b></span>: see
            <a href="#svn-ch-9-sect-1.2-re-blame" title="svn blame">svn blame</a>.
            </p></li><li><p><span><b class="command">svn export --native-eol EOL</b></span>: see
            <a href="#svn-ch-9-sect-1.2-re-export" title="svn export">svn export</a>.
            </p></li><li><p><span><b class="command">svn add --force</b></span>: see
            <a href="#svn-ch-9-sect-1.2-re-add" title="svn add">svn add</a>.
            </p></li><li><p><span><b class="command">svnadmin dump --deltas</b></span>: see
            <a href="#svn-ch-5-sect-3.5" title="Migrating a Repository">the section called &#8220;Migrating a Repository&#8221;</a>.
            </p></li><li><p><span><b class="command">svnadmin create --fs-type TYPE</b></span>: see
            <a href="#svn-ch-9-sect-2.2-re-create" title="svnadmin create">svnadmin create</a>.
            </p></li><li><p><span><b class="command">svnadmin recover --wait</b></span>: see
            <a href="#svn-ch-9-sect-2.2-re-recover" title="svnadmin recover">svnadmin recover</a>.
            </p></li><li><p><span><b class="command">svnserve --tunnel-user=NAME</b></span>: see
            <a href="#svn-ch-9-sect-4.1" title="svnserve Switches">the section called &#8220;svnserve Switches&#8221;</a>.
            </p></li></ul></div></dd></dl></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id868920" href="#id868920">1</a>] </sup>Oh, and thanks, Karl, for
      being too overworked to write this book yourself.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-1"></a>Chapter 1. Introduction</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-1-sect-1">What is Subversion?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-2">Subversion's History</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-3">Subversion's Features</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-4">Subversion's Architecture</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-5">Installing Subversion</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-6">Subversion's Components</a></span></dt><dt><span class="sect1"><a href="#svn-ch-1-sect-7">A Quick Start</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Version control is the art of managing changes to
      information.  It has long been a critical tool for programmers,
      who typically spend their time making small changes to software
      and then undoing those changes the next day.  But the usefulness
      of version control software extends far beyond the bounds of the
      software development world.  Anywhere you can find people using
      computers to manage information that changes often, there is
      room for version control.  And that's where Subversion comes
      into play.</p><p>This chapter contains a high-level introduction to
      Subversion&#8212;what it is; what it does; how to get it.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-1"></a>What is Subversion?</h2></div></div><div></div></div><p>Subversion is a free/open-source version control system.
      That is, Subversion manages files and directories over time.  A
      tree of files is placed into a central
      <i class="firstterm">repository</i>.  The repository is much like
      an ordinary file server, except that it remembers every change
      ever made to your files and directories.  This allows you to
      recover older versions of your data, or examine the history of
      how your data changed.  In this regard, many people think of a
      version control system as a sort of &#8220;<span class="quote">time
      machine</span>&#8221;.</p><p>Subversion can access its repository across networks, which
      allows it to be used by people on different computers.  At some
      level, the ability for various people to modify and manage the
      same set of data from their respective locations fosters
      collaboration.  Progress can occur more quickly without a single
      conduit through which all modifications must occur.  And because
      the work is versioned, you need not fear that quality is the
      trade-off for losing that conduit&#8212;if some incorrect change
      is made to the data, just undo that change.</p><p>Some version control systems are also software configuration
      management (SCM) systems.  These systems are specifically
      tailored to manage trees of source code, and have many features
      that are specific to software development&#8212;such as natively
      understanding programming languages, or supplying tools for
      building software.  Subversion, however, is not one of these
      systems.  It is a general system that can be used to manage
      <span class="emphasis"><em>any</em></span> collection of files.  For you, those
      files might be source code&#8212;for others, anything from
      grocery shopping lists to digital video mixdowns and
      beyond.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-2"></a>Subversion's History</h2></div></div><div></div></div><p>In early 2000, CollabNet, Inc. (<tt class="systemitem">http://www.collab.net</tt>) began seeking
      developers to write a replacement for CVS.  CollabNet offers a
      collaboration software suite called SourceCast, of which one
      component is version control.  Although SourceCast used CVS as
      its initial version control system, CVS's limitations were
      obvious from the beginning, and CollabNet knew it would
      eventually have to find something better.  Unfortunately, CVS
      had become the <span class="foreignphrase"><i class="foreignphrase">de facto</i></span> standard
      in the open source world largely because there
      <span class="emphasis"><em>wasn't</em></span> anything better, at least not under
      a free license.  So CollabNet determined to write a new version
      control system from scratch, retaining the basic ideas of CVS,
      but without the bugs and misfeatures.</p><p>In February 2000, they contacted Karl Fogel, the author of
      <i class="citetitle">Open Source Development with CVS</i>
      (Coriolis, 1999), and asked if he'd like to work on this new
      project.  Coincidentally, at the time Karl was already
      discussing a design for a new version control system with his
      friend Jim Blandy.  In 1995, the two had started Cyclic
      Software, a company providing CVS support contracts, and
      although they later sold the business, they still used CVS every
      day at their jobs.  Their frustration with CVS had led Jim to
      think carefully about better ways to manage versioned data, and
      he'd already come up with not only the name
      &#8220;<span class="quote">Subversion</span>&#8221;, but also with the basic design of the
      Subversion repository.  When CollabNet called, Karl immediately
      agreed to work on the project, and Jim got his employer, RedHat
      Software, to essentially donate him to the project for an
      indefinite period of time.  CollabNet hired Karl and Ben
      Collins-Sussman, and detailed design work began in May.  With
      the help of some well-placed prods from Brian Behlendorf and
      Jason Robbins of CollabNet, and Greg Stein (at the time an
      independent developer active in the WebDAV/DeltaV specification
      process), Subversion quickly attracted a community of active
      developers.  It turned out that many people had had the same
      frustrating experiences with CVS, and welcomed the chance to
      finally do something about it.</p><p>The original design team settled on some simple goals.  They
      didn't want to break new ground in version control methodology,
      they just wanted to fix CVS.  They decided that Subversion would
      match CVS's features, and preserve the same development model,
      but not duplicate CVS's most obvious flaws.  And although it did
      not need to be a drop-in replacement for CVS, it should be
      similar enough that any CVS user could make the switch with
      little effort.</p><p>After fourteen months of coding, Subversion became
      &#8220;<span class="quote">self-hosting</span>&#8221; on August 31, 2001.  That is,
      Subversion developers stopped using CVS to manage Subversion's
      own source code, and started using Subversion instead.</p><p>While CollabNet started the project, and still funds a large
      chunk of the work (it pays the salaries of a few full-time
      Subversion developers), Subversion is run like most open-source
      projects, governed by a loose, transparent set of rules that
      encourage meritocracy.  CollabNet's copyright license is fully
      compliant with the Debian Free Software Guidelines.  In other
      words, anyone is free to download, modify, and redistribute
      Subversion as he pleases; no permission from CollabNet or anyone
      else is required.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-3"></a>Subversion's Features</h2></div></div><div></div></div><p>When discussing the features that Subversion brings to the
      version control table, it is often helpful to speak of them in
      terms of how they improve upon CVS's design.  If you're not
      familiar with CVS, you may not understand all of these features.
      And if you're not familiar with version control at all, your
      eyes may glaze over unless you first read <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>, in which we provide a gentle introduction
      to version control in general.</p><p>Subversion provides:</p><div class="variablelist"><dl><dt><span class="term">Directory versioning</span></dt><dd><p>CVS only tracks the history of individual files, but
            Subversion implements a &#8220;<span class="quote">virtual</span>&#8221; versioned
            filesystem that tracks changes to whole directory trees
            over time.  Files <span class="emphasis"><em>and</em></span> directories are
            versioned.</p></dd><dt><span class="term">True version history</span></dt><dd><p>Since CVS is limited to file versioning, operations
            such as copies and renames&#8212;which might happen to
            files, but which are really changes to the contents of
            some containing directory&#8212;aren't supported in CVS.
            Additionally, in CVS you cannot replace a versioned file
            with some new thing of the same name without the new item
            inheriting the history of the old&#8212;perhaps completely
            unrelated&#8212;file.  With Subversion, you can add,
            delete, copy, and rename both files and directories.  And
            every newly added file begins with a fresh, clean
            history all its own.</p></dd><dt><span class="term">Atomic commits</span></dt><dd><p>A collection of modifications either goes into the
            repository completely, or not at all.  This allows
            developers to construct and commit changes as logical
            chunks, and prevents problems that can occur when only a
            portion of a set of changes is successfully sent to the
            repository.</p></dd><dt><span class="term">Versioned metadata</span></dt><dd><p>Each file and directory has a set of
            properties&#8212;keys and their values&#8212;associated
            with it.  You can create and store any arbitrary key/value
            pairs you wish.  Properties are versioned over time, just
            like file contents.</p></dd><dt><span class="term">Choice of network layers</span></dt><dd><p>Subversion has an abstracted notion of repository
            access, making it easy for people to implement new network
            mechanisms.  Subversion can plug into the Apache HTTP
            Server as an extension module.  This gives Subversion a
            big advantage in stability and interoperability, and
            instant access to existing features provided by that
            server&#8212;authentication, authorization, wire
            compression, and so on.  A more lightweight, standalone
            Subversion server process is also available.  This server
            speaks a custom protocol which can be easily tunneled over
            SSH.</p></dd><dt><span class="term">Consistent data handling</span></dt><dd><p>Subversion expresses file differences using a binary
            differencing algorithm, which works identically on both
            text (human-readable) and binary (human-unreadable) files.
            Both types of files are stored equally compressed in the
            repository, and differences are transmitted in both
            directions across the network.</p></dd><dt><span class="term">Efficient branching and tagging</span></dt><dd><p>The cost of branching and tagging need not be
            proportional to the project size.  Subversion creates
            branches and tags by simply copying the project, using a
            mechanism similar to a hard-link.  Thus these operations
            take only a very small, constant amount of time.
          </p></dd><dt><span class="term">Hackability</span></dt><dd><p>Subversion has no historical baggage; it is
            implemented as a collection of shared C libraries with
            well-defined APIs.  This makes Subversion extremely
            maintainable and usable by other applications and
            languages.</p></dd></dl></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-4"></a>Subversion's Architecture</h2></div></div><div></div></div><p><a href="#svn-ch-1-dia-1" title="Figure 1.1. Subversion's Architecture">Figure 1.1, &#8220;Subversion's Architecture&#8221;</a> illustrates what one might
      call a &#8220;<span class="quote">mile-high</span>&#8221; view of Subversion's
      design.</p><div class="figure"><a name="svn-ch-1-dia-1"></a><p class="title"><b>Figure 1.1. Subversion's Architecture</b></p><div><img src="images/ch01dia1.png" alt="Subversion's Architecture"></div></div><p>On one end is a Subversion repository that holds all of your
      versioned data.  On the other end is your Subversion client
      program, which manages local reflections of portions of that
      versioned data (called &#8220;<span class="quote">working copies</span>&#8221;).  Between
      these extremes are multiple routes through various Repository
      Access (RA) layers.  Some of these routes go across computer
      networks and through network servers which then access the
      repository.  Others bypass the network altogether and access the
      repository directly.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-5"></a>Installing Subversion</h2></div></div><div></div></div><p>Subversion is built on a portability layer called APR (the
      Apache Portable Runtime library).  This means Subversion should
      work on any operating system that the Apache httpd server runs
      on: Windows, Linux, all flavors of BSD, Mac OS X, Netware, and
      others.</p><p>The easiest way to get Subversion is to download a binary
      package built for your operating system.  Subversion's website
      (<tt class="systemitem">http://subversion.tigris.org</tt>) often has
      these packages available for download, posted by volunteers.
      The site usually contains graphical installer packages for users
      of Microsoft operating systems.  If you run a Unix-like
      operating system, you can use your system's native package
      distribution system (RPMs, DEBs, the ports tree, etc.) to get
      Subversion.</p><p>Alternately, you can build Subversion directly from source
      code.  From the Subversion website, download the latest
      source-code release.  After unpacking it, follow the
      instructions in the <tt class="filename">INSTALL</tt> file to build
      it.  Note that a released source package contains everything you
      need to build a command-line client capable of talking to a
      remote repository (in particular, the apr, apr-util, and neon
      libraries).  But optional portions of Subversion have many other
      dependencies, such as Berkeley DB and possibly Apache httpd.  If
      you want to do a complete build, make sure you have all of the
      packages documented in the <tt class="filename">INSTALL</tt> file.
      If you plan to work on Subversion itself, you can use your
      client program to grab the latest, bleeding-edge source code.
      This is documented in <a href="#svn-ch-8-sect-6.2" title="Get the Source Code">the section called &#8220;Get the Source Code&#8221;</a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-6"></a>Subversion's Components</h2></div></div><div></div></div><p>Subversion, once installed, has a number of different
      pieces.  The following is a quick overview of what you get.
      Don't be alarmed if the brief descriptions leave you scratching
      your head&#8212;there are <span class="emphasis"><em>plenty</em></span> more pages
      in this book devoted to alleviating that confusion.</p><div class="variablelist"><dl><dt><span class="term">svn</span></dt><dd><p>The command-line client program.</p></dd><dt><span class="term">svnversion</span></dt><dd><p>A program for reporting the state (in terms of
            revisions of the items present) of a working copy.</p></dd><dt><span class="term">svnlook</span></dt><dd><p>A tool for inspecting a Subversion repository.</p></dd><dt><span class="term">svnadmin</span></dt><dd><p>A tool for creating, tweaking or repairing a Subversion
            repository.</p></dd><dt><span class="term">svndumpfilter</span></dt><dd><p>A program for filtering Subversion repository dump
            streams.</p></dd><dt><span class="term">mod_dav_svn</span></dt><dd><p>A plug-in module for the Apache HTTP Server, used to
            make your repository available to others over a
            network.</p></dd><dt><span class="term">svnserve</span></dt><dd><p>A custom standalone server program, runnable as a
            daemon process or invokable by SSH; another way to make
            your repository available to others over a network.</p></dd></dl></div><p>Assuming you have Subversion installed correctly, you should
      be ready to start.  The next two chapters will walk you through
      the use of <span><b class="command">svn</b></span>, Subversion's command-line client 
      program.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-1-sect-7"></a>A Quick Start</h2></div></div><div></div></div><p>Some people have trouble absorbing a new technology by
      reading the sort of &#8220;<span class="quote">top down</span>&#8221; approach provided by this
      book.  This section is a very short introduction to Subversion, and is
      designed to give &#8220;<span class="quote">bottom up</span>&#8221; learners a fighting chance.
      If you're one of those folks who prefers to learn by
      experimentation, the following demonstration will get you up and
      running.  Along the way, we give links to the relevant chapters
      of this book.</p><p>If you're new to the entire concept of version control or to
      the &#8220;<span class="quote">copy-modify-merge</span>&#8221; model used by both CVS and
      Subversion, then you should read <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>
      before going any further.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The following example assumes that you have
        <span><b class="command">svn</b></span>, the Subversion command-line client,
        and <span><b class="command">svnadmin</b></span>, the administrative tool,
        ready to go.  It also assumes that your <span><b class="command">svn</b></span>
        client has been compiled against Berkeley DB.  To verify this,
        run <span><b class="command">svn --version</b></span> and make sure the
        <tt class="literal">ra_local</tt> module is available.  Without this
        module, the client cannot access <tt class="literal">file://</tt>
        URLs.</p></div><p>Subversion stores all versioned data in a central
      repository.  To begin, create a new repository:</p><pre class="screen">
$ svnadmin create /path/to/repos
$ ls /path/to/repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>This command creates a new directory
      <tt class="filename">/path/to/repos</tt> which contains a Subversion
      repository.  Make sure that this directory lives on a local
      disk, <span class="emphasis"><em>not</em></span> a network share.  This new
      directory mainly contains a collection of Berkeley DB database
      files.  You won't see your versioned files if you peek inside.
      For more information about repository creation and maintenance,
      see <a href="#svn-ch-5" title="Chapter 5. Repository Administration">Chapter 5, <i>Repository Administration</i></a>.</p><p>Next, create a tree of files and directories to import into
      the repository.  For reasons that will be clear later on (see
      <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>), your structure should contain three
      top-level directories named <tt class="filename">branches</tt>,
      <tt class="filename">tags</tt>, and
      <tt class="filename">trunk</tt>:</p><pre class="screen">
/tmp/project/branches/
/tmp/project/tags/
/tmp/project/trunk/
               foo.c
               bar.c
               Makefile
               &#8230;
</pre><p>Once you have a tree of data ready to go, import the data
      into the repository with the <span><b class="command">svn import</b></span>
      command (see <a href="#svn-ch-3-sect-7.3" title="svn import">the section called &#8220;svn import&#8221;</a>):</p><pre class="screen">
$ svn import /tmp/project file:///path/to/repos -m "initial import"
Adding         /tmp/project/branches
Adding         /tmp/project/tags
Adding         /tmp/project/trunk
Adding         /tmp/project/trunk/foo.c
Adding         /tmp/project/trunk/bar.c
Adding         /tmp/project/trunk/Makefile
&#8230;
Committed revision 1.
$ 
</pre><p>Now the repository contains this tree of data.  Note that
      the original <tt class="filename">/tmp/project</tt> directory is
      unchanged; Subversion is unaware of it.  (In fact, you can even
      delete that directory if you wish.)  In order to start
      manipulating repository data, you need to create a new
      &#8220;<span class="quote">working copy</span>&#8221; of the data, a sort of private
      workspace.  Ask Subversion to &#8220;<span class="quote">check out</span>&#8221; a working
      copy of the repository's <tt class="filename">trunk</tt>
      directory:</p><pre class="screen">
$ svn checkout file:///path/to/repos/trunk project
A  project/foo.c
A  project/bar.c
A  project/Makefile
&#8230;
Checked out revision 1.
</pre><p>Now you have a personal copy of part of the repository in a
      new directory named <tt class="filename">project</tt>.  You can edit
      the files in your working copy and then commit those changes
      back into the repository.</p><div class="itemizedlist"><ul type="disc"><li><p>Enter your working copy and edit a file's
          contents.</p></li><li><p>Run <span><b class="command">svn diff</b></span> to see unified diff
          output of your changes.</p></li><li><p>Run <span><b class="command">svn commit</b></span> to commit the new
          version of your file to the repository.</p></li><li><p>Run <span><b class="command">svn update</b></span> to bring your working
          copy &#8220;<span class="quote">up-to-date</span>&#8221; with the repository.</p></li></ul></div><p>For a full tour of all the things you can do with your
      working copy, read <a href="#svn-ch-3" title="Chapter 3. Guided Tour">Chapter 3, <i>Guided Tour</i></a>.</p><p>At this point, you have the option of making your repository
      available to others over a network.  See <a href="#svn-ch-6" title="Chapter 6. Server Configuration">Chapter 6, <i>Server Configuration</i></a> to learn about the different sorts of
      server processes available and how to configure them.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-2"></a>Chapter 2. Basic Concepts</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-2-sect-1">The Repository</a></span></dt><dt><span class="sect1"><a href="#svn-ch-2-sect-2">Versioning Models</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-2.1">The Problem of File-Sharing</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.2">The Lock-Modify-Unlock Solution</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-2.3">The Copy-Modify-Merge Solution</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-3">Subversion in Action</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-2-sect-3.1">Working Copies</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.2">Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.3">How Working Copies Track the Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-2-sect-3.4">The Limitations of Mixed Revisions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-2-sect-4">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>This chapter is a short, casual introduction to Subversion.
      If you're new to version control, this chapter is definitely for
      you.  We begin with a discussion of general version control
      concepts, work our way into the specific ideas behind
      Subversion, and show some simple examples of Subversion in
      use.</p><p>Even though the examples in this chapter show people sharing
      collections of program source code, keep in mind that Subversion
      can manage any sort of file collection&#8212;it's not limited to
      helping computer programmers.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-1"></a>The Repository</h2></div></div><div></div></div><p>Subversion is a centralized system for sharing information.
      At its core is a repository, which is a central store of data.
      The repository stores information in the form of a
      <i class="firstterm">filesystem tree</i>&#8212;a typical hierarchy
      of files and directories.  Any number of
      <i class="firstterm">clients</i> connect to the repository, and
      then read or write to these files.  By writing data, a client
      makes the information available to others; by reading data, the
      client receives information from others.  <a href="#svn-ch-2-dia-1" title="Figure 2.1. A typical client/server system">Figure 2.1, &#8220;A typical client/server system&#8221;</a> illustrates this.</p><div class="figure"><a name="svn-ch-2-dia-1"></a><p class="title"><b>Figure 2.1. A typical client/server system</b></p><div><img src="images/ch02dia1.png" alt="A typical client/server system"></div></div><p>So why is this interesting?  So far, this sounds like the
      definition of a typical file server.  And indeed, the repository
      <span class="emphasis"><em>is</em></span> a kind of file server, but it's not your
      usual breed.  What makes the Subversion repository special is
      that <span class="emphasis"><em>it remembers every change</em></span> ever written
      to it: every change to every file, and even changes to the
      directory tree itself, such as the addition, deletion, and
      rearrangement of files and directories.</p><p>When a client reads data from the repository, it normally
      sees only the latest version of the filesystem tree.  But the
      client also has the ability to view
      <span class="emphasis"><em>previous</em></span> states of the filesystem.  For
      example, a client can ask historical questions like, &#8220;<span class="quote">What
      did this directory contain last Wednesday?</span>&#8221; or &#8220;<span class="quote">Who
      was the last person to change this file, and what changes did
      they make?</span>&#8221; These are the sorts of questions that are at
      the heart of any <i class="firstterm">version control system</i>:
      systems that are designed to record and track changes to data
      over time.
    </p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-2"></a>Versioning Models</h2></div></div><div></div></div><p>The core mission of a version control system is to enable
      collaborative editing and sharing of data.  But different
      systems use different strategies to achieve this.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.1"></a>The Problem of File-Sharing</h3></div></div><div></div></div><p>All version control systems have to solve the same
        fundamental problem: how will the system allow users to share
        information, but prevent them from accidentally stepping on
        each other's feet?  It's all too easy for users to
        accidentally overwrite each other's changes in the
        repository.</p><p>Consider the scenario shown in <a href="#svn-ch-2-dia-2" title="Figure 2.2. The problem to avoid">Figure 2.2, &#8220;The problem to avoid&#8221;</a>.  Suppose we have two co-workers,
        Harry and Sally.  They each decide to edit the same repository
        file at the same time.  If Harry saves his changes to the
        repository first, then it's possible that (a few moments
        later) Sally could accidentally overwrite them with her own
        new version of the file.  While Harry's version of the file
        won't be lost forever (because the system remembers every
        change), any changes Harry made <span class="emphasis"><em>won't</em></span> be
        present in Sally's newer version of the file, because she
        never saw Harry's changes to begin with.  Harry's work is
        still effectively lost&#8212;or at least missing from the
        latest version of the file&#8212;and probably by accident.
        This is definitely a situation we want to avoid!</p><div class="figure"><a name="svn-ch-2-dia-2"></a><p class="title"><b>Figure 2.2. The problem to avoid</b></p><div><img src="images/ch02dia2.png" alt="The problem to avoid"></div></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.2"></a>The Lock-Modify-Unlock Solution</h3></div></div><div></div></div><p>Many version control systems use a
        <i class="firstterm">lock-modify-unlock</i> model to address
        this problem.  In such a system, the repository allows only
        one person to change a file at a time.  First Harry must
        &#8220;<span class="quote">lock</span>&#8221; the file before he can begin making
        changes to it.  Locking a file is a lot like borrowing a book
        from the library; if Harry has locked a file, then Sally
        cannot make any changes to it.  If she tries to lock the file,
        the repository will deny the request.  All she can do is read
        the file, and wait for Harry to finish his changes and release
        his lock.  After Harry unlocks the file, his turn is over, and
        now Sally can take her turn by locking and editing.  <a href="#svn-ch-2-dia-3" title="Figure 2.3. The lock-modify-unlock solution">Figure 2.3, &#8220;The lock-modify-unlock solution&#8221;</a> demonstrates this simple
        solution.</p><div class="figure"><a name="svn-ch-2-dia-3"></a><p class="title"><b>Figure 2.3. The lock-modify-unlock solution</b></p><div><img src="images/ch02dia3.png" alt="The lock-modify-unlock solution"></div></div><p>The problem with the lock-modify-unlock model is that it's
        a bit restrictive, and often becomes a roadblock for
        users:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Locking may cause administrative
            problems.</em></span>

            Sometimes Harry will lock a file and then forget about it.
            Meanwhile, because Sally is still waiting to edit the file,
            her hands are tied.  And then Harry goes on vacation.  Now
            Sally has to get an administrator to release Harry's lock.
            The situation ends up causing a lot of unnecessary delay
            and wasted time.</p></li><li><p><span class="emphasis"><em>Locking may cause unnecessary
            serialization.</em></span>

            What if Harry is editing the beginning of a text file,
            and Sally simply wants to edit the end of the same file?
            These changes don't overlap at all.  They could easily
            edit the file simultaneously, and no great harm would
            come, assuming the changes were properly merged together.
            There's no need for them to take turns in this
            situation.</p></li><li><p><span class="emphasis"><em>Locking may create a false sense of
            security.</em></span>

            Pretend that Harry locks and edits file A, while
            Sally simultaneously locks and edits file B.  But suppose
            that A and B depend on one another, and the changes made
            to each are semantically incompatible.  Suddenly A and B
            don't work together anymore. The locking system was
            powerless to prevent the problem&#8212;yet it somehow
            provided a false sense of security.  It's easy for Harry and
            Sally to imagine that by locking files, each is beginning a
            safe, insulated task, and thus not bother
            discussing their incompatible changes early
            on.</p></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-2.3"></a>The Copy-Modify-Merge Solution</h3></div></div><div></div></div><p>Subversion, CVS, and other version control systems use a
        <i class="firstterm">copy-modify-merge</i> model as an
        alternative to locking.  In this model, each user's client
        contacts the project repository and creates a personal
        <i class="firstterm">working copy</i>&#8212;a local reflection
        of the repository's files and directories.  Users then work in
        parallel, modifying their private copies.  Finally, the
        private copies are merged together into a new, final version.
        The version control system often assists with the merging, but
        ultimately a human being is responsible for making it happen
        correctly.</p><p>Here's an example.  Say that Harry and Sally each create
        working copies of the same project, copied from the
        repository.  They work concurrently, and make changes to the
        same file A within their copies.  Sally saves her changes to
        the repository first.  When Harry attempts to save his changes
        later, the repository informs him that his file A is
        <i class="firstterm">out-of-date</i>.  In other words, that file
        A in the repository has somehow changed since he last copied
        it.  So Harry asks his client to <i class="firstterm">merge</i>
        any new changes from the repository into his working copy of
        file A.  Chances are that Sally's changes don't overlap with
        his own; so once he has both sets of changes integrated, he
        saves his working copy back to the repository.  <a href="#svn-ch-2-dia-4" title="Figure 2.4. The copy-modify-merge solution">Figure 2.4, &#8220;The copy-modify-merge solution&#8221;</a> and <a href="#svn-ch-2-dia-5" title="Figure 2.5. The copy-modify-merge solution (continued)">Figure 2.5, &#8220;The copy-modify-merge solution (continued)&#8221;</a>
        show this process.</p><div class="figure"><a name="svn-ch-2-dia-4"></a><p class="title"><b>Figure 2.4. The copy-modify-merge solution</b></p><div><img src="images/ch02dia4.png" alt="The copy-modify-merge solution"></div></div><div class="figure"><a name="svn-ch-2-dia-5"></a><p class="title"><b>Figure 2.5. The copy-modify-merge solution (continued)</b></p><div><img src="images/ch02dia5.png" alt="The copy-modify-merge solution (continued)"></div></div><p>But what if Sally's changes <span class="emphasis"><em>do</em></span> overlap
        with Harry's changes?  What then?  This situation is called a
        <i class="firstterm">conflict</i>, and it's usually not much of
        a problem.  When Harry asks his client to merge the latest
        repository changes into his working copy, his copy of file A
        is somehow flagged as being in a state of conflict: he'll be
        able to see both sets of conflicting changes, and manually
        choose between them.  Note that software can't automatically
        resolve conflicts; only humans are capable of understanding
        and making the necessary intelligent choices.  Once Harry has
        manually resolved the overlapping changes&#8212;perhaps after
        a discussion with Sally&#8212;he can safely save the
        merged file back to the repository.</p><p>The copy-modify-merge model may sound a bit chaotic, but
        in practice, it runs extremely smoothly.  Users can work in
        parallel, never waiting for one another.  When they work on
        the same files, it turns out that most of their concurrent
        changes don't overlap at all; conflicts are infrequent.  And
        the amount of time it takes to resolve conflicts is far less
        than the time lost by a locking system.</p><p>In the end, it all comes down to one critical factor: user
        communication.  When users communicate poorly, both syntactic
        and semantic conflicts increase.  No system can force users to
        communicate perfectly, and no system can detect semantic
        conflicts.  So there's no point in being lulled into a false
        promise that a locking system will somehow prevent conflicts;
        in practice, locking seems to inhibit productivity more than
        anything else.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-3"></a>Subversion in Action</h2></div></div><div></div></div><p>It's time to move from the abstract to the concrete.  In
      this section, we'll show real examples of Subversion being
      used.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.1"></a>Working Copies</h3></div></div><div></div></div><p>You've already read about working copies; now we'll
        demonstrate how the Subversion client creates and uses
        them.</p><p>A Subversion working copy is an ordinary directory tree on
        your local system, containing a collection of files.  You can
        edit these files however you wish, and if they're source code
        files, you can compile your program from them in the usual
        way.  Your working copy is your own private work area:
        Subversion will never incorporate other people's changes, nor
        make your own changes available to others, until you
        explicitly tell it to do so.</p><p>After you've made some changes to the files in your
        working copy and verified that they work properly, Subversion
        provides you with commands to &#8220;<span class="quote">publish</span>&#8221; your
        changes to the other people working with you on your project
        (by writing to the repository).  If other people publish their
        own changes, Subversion provides you with commands to merge
        those changes into your working directory (by reading from the
        repository).</p><p>A working copy also contains some extra files, created and
        maintained by Subversion, to help it carry out these commands.
        In particular, each directory in your working copy contains a
        subdirectory named <tt class="filename">.svn</tt>, also known as
        the working copy <i class="firstterm">administrative
        directory</i>.  The files in each administrative
        directory help Subversion recognize which files contain
        unpublished changes, and which files are out-of-date with
        respect to others' work.</p><p>A typical Subversion repository often holds the files (or
        source code) for several projects; usually, each project is a
        subdirectory in the repository's filesystem tree.  In this
        arrangement, a user's working copy will usually correspond to
        a particular subtree of the repository.</p><p>For example, suppose you have a repository that contains
        two software projects, <tt class="literal">paint</tt> and
        <tt class="literal">calc</tt>.  Each project lives in its own
        top-level subdirectory, as shown in <a href="#svn-ch-2-dia-6" title="Figure 2.6. The repository's filesystem">Figure 2.6, &#8220;The repository's filesystem&#8221;</a>.</p><div class="figure"><a name="svn-ch-2-dia-6"></a><p class="title"><b>Figure 2.6. The repository's filesystem</b></p><div><img src="images/ch02dia6.png" alt="The repository's filesystem"></div></div><p>To get a working copy, you must <i class="firstterm">check
        out</i> some subtree of the repository.  (The term
        &#8220;<span class="quote">check out</span>&#8221; may sound like it has something to do
        with locking or reserving resources, but it doesn't; it simply
        creates a private copy of the project for you.) For example,
        if you check out <tt class="filename">/calc</tt>, you will get a
        working copy like this:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc
A  calc
A  calc/Makefile
A  calc/integer.c
A  calc/button.c

$ ls -A calc
Makefile  integer.c  button.c  .svn/
</pre><p>The list of letter A's indicates that Subversion is adding
        a number of items to your working copy.  You now have a
        personal copy of the repository's <tt class="filename">/calc</tt>
        directory, with one additional
        entry&#8212;<tt class="filename">.svn</tt>&#8212;which holds the
        extra information needed by Subversion, as mentioned
        earlier.</p><div class="sidebar"><a name="svn-ch-2-sidebar-1"></a><p class="title"><b>Repository URLs</b></p><p>Subversion repositories can be accessed through many
          different methods&#8212;on local disk, or through various
          network protocols.  A repository location, however, is
          always a URL.  Table 2-1 describes how different URL
          schemas map to the available access methods.</p><div class="table"><a name="svn-ch-2-table-1"></a><p class="title"><b>Table 2.1. Repository Access URLs</b></p><table summary="Repository Access URLs" border="1"><colgroup><col><col></colgroup><thead><tr><th>Schema</th><th>Access Method</th></tr></thead><tbody><tr><td><tt class="literal">file:///</tt></td><td>direct repository access (on local disk)</td></tr><tr><td><tt class="literal">http://</tt></td><td>access via WebDAV protocol to Subversion-aware
                  Apache server</td></tr><tr><td><tt class="literal">https://</tt></td><td>same as <tt class="literal">http://</tt>, but with
                  SSL encryption.</td></tr><tr><td><tt class="literal">svn://</tt></td><td>access via custom protocol to an
                  <tt class="literal">svnserve</tt> server</td></tr><tr><td><tt class="literal">svn+ssh://</tt></td><td>same as <tt class="literal">svn://</tt>, but through
                  an SSH tunnel.</td></tr></tbody></table></div><p>For the most part, Subversion's URLs use the standard
          syntax, allowing for server names and port numbers to be
          specified as part of the URL.  Remember that the
          <tt class="literal">file:</tt> access method is valid only for
          local repositories&#8212;in fact, in
          accordance with convention, the server name portion of the
          URL is required to be either absent or
          <tt class="literal">localhost</tt>:</p><pre class="screen">
$ svn checkout file:///path/to/repos
&#8230;
$ svn checkout file://localhost/path/to/repos
&#8230;
</pre><p>Also, users of the <tt class="literal">file:</tt> scheme on
          Windows platforms will need to use an unofficially
          &#8220;<span class="quote">standard</span>&#8221; syntax for accessing repositories
          that are on the same machine, but on a different drive than
          the client's current working drive.  Either of the two
          following URL path syntaxes will work where
          <tt class="literal">X</tt> is the drive on which the repository
          resides:</p><pre class="screen">
C:\&gt; svn checkout file:///X:/path/to/repos
&#8230;
C:\&gt; svn checkout "file:///X|/path/to/repos"
&#8230;
</pre><p>In the second syntax, you need to quote the URL so that
          the vertical bar character is not interpreted as a pipe.</p><p>Note that a URL uses ordinary slashes even though the native
          (non-URL) form of a path on Windows uses backslashes.</p></div><p>Suppose you make changes to <tt class="filename">button.c</tt>.
        Since the <tt class="filename">.svn</tt> directory remembers the
        file's modification date and original contents, Subversion can
        tell that you've changed the file.  However, Subversion does
        not make your changes public until you explicitly tell it to.
        The act of publishing your changes is more commonly known as
        <i class="firstterm">committing</i> (or <i class="firstterm">checking
        in</i>) changes to the repository.</p><p>To publish your changes to others, you can use
        Subversion's <span><b class="command">commit</b></span> command:</p><pre class="screen">
$ svn commit button.c
Sending        button.c
Transmitting file data .
Committed revision 57.
</pre><p>Now your changes to <tt class="filename">button.c</tt> have
        been committed to the repository; if another user checks out a
        working copy of <tt class="filename">/calc</tt>, they will see
        your changes in the latest version of the file.</p><p>Suppose you have a collaborator, Sally, who checked out a
        working copy of <tt class="filename">/calc</tt> at the same time
        you did.  When you commit your change to
        <tt class="filename">button.c</tt>, Sally's working copy is left
        unchanged; Subversion only modifies working copies at the
        user's request.</p><p>To bring her project up to date, Sally can ask
        Subversion to <i class="firstterm">update</i> her working copy,
        by using the Subversion <span><b class="command">update</b></span> command.
        This will incorporate your changes into her working copy, as
        well as any others that have been committed since she checked
        it out.</p><pre class="screen">
$ pwd
/home/sally/calc

$ ls -A 
.svn/ Makefile integer.c button.c

$ svn update
U button.c
</pre><p>The output from the <span><b class="command">svn update</b></span> command
        indicates that Subversion updated the contents of
        <tt class="filename">button.c</tt>.  Note that Sally didn't need to
        specify which files to update; Subversion uses the information
        in the <tt class="filename">.svn</tt> directory, and further
        information in the repository, to decide which files need to
        be brought up to date.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.2"></a>Revisions</h3></div></div><div></div></div><p>An <span><b class="command">svn commit</b></span> operation can publish
        changes to any number of files and directories as a single
        atomic transaction.  In your working copy, you can change
        files' contents, create, delete, rename and copy files and
        directories, and then commit the complete set of changes as a
        unit.</p><p>In the repository, each commit is treated as an atomic
        transaction: either all the commit's changes take place, or
        none of them take place.  Subversion tries to retain this
        atomicity in the face of program crashes, system crashes,
        network problems, and other users' actions.</p><p>Each time the repository accepts a commit, this creates a
        new state of the filesystem tree, called a
        <i class="firstterm">revision</i>.  Each revision is assigned a
        unique natural number, one greater than the number of the
        previous revision.  The initial revision of a freshly created
        repository is numbered zero, and consists of nothing but an
        empty root directory.</p><p><a href="#svn-ch-2-dia-7" title="Figure 2.7. The repository">Figure 2.7, &#8220;The repository&#8221;</a> illustrates a nice way to
        visualize the repository.  Imagine an array of revision
        numbers, starting at 0, stretching from left to right.  Each
        revision number has a filesystem tree hanging below it, and
        each tree is a &#8220;<span class="quote">snapshot</span>&#8221; of the way the
        repository looked after a commit.</p><div class="figure"><a name="svn-ch-2-dia-7"></a><p class="title"><b>Figure 2.7. The repository</b></p><div><img src="images/ch02dia7.png" alt="The repository"></div></div><div class="sidebar"><p class="title"><b>Global Revision Numbers</b></p><p>Unlike those of many other version control systems,
          Subversion's revision numbers apply to <span class="emphasis"><em>entire
          trees</em></span>, not individual files.  Each revision
          number selects an entire tree, a particular state of the
          repository after some committed change.  Another way to
          think about it is that revision N represents the state of
          the repository filesystem after the Nth commit.  When a
          Subversion user talks about &#8220;<span class="quote">revision 5 of
          <tt class="filename">foo.c</tt></span>&#8221;, they really mean
          &#8220;<span class="quote"><tt class="filename">foo.c</tt> as it appears in revision 5.</span>&#8221;
          Notice that in general, revisions N and M of a file do
          <span class="emphasis"><em>not</em></span> necessarily differ!  Because CVS
          uses per-file revisions numbers, CVS users might want to see
          <a href="#svn-ap-a" title="Appendix A. Subversion for CVS Users">Appendix A, <i>Subversion for CVS Users</i></a> for more details.</p></div><p>It's important to note that working copies do not always
        correspond to any single revision in the repository; they may
        contain files from several different revisions.  For example,
        suppose you check out a working copy from a repository whose
        most recent revision is 4:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:4
</pre><p>At the moment, this working directory corresponds exactly
        to revision 4 in the repository.  However, suppose you make a
        change to <tt class="filename">button.c</tt>, and commit that
        change.  Assuming no other commits have taken place, your
        commit will create revision 5 of the repository, and your
        working copy will now look like this:</p><pre class="screen">
calc/Makefile:4
     integer.c:4
     button.c:5
</pre><p>Suppose that, at this point, Sally commits a change to
        <tt class="filename">integer.c</tt>, creating revision 6.  If you
        use <span><b class="command">svn update</b></span> to bring your working copy
        up to date, then it will look like this:</p><pre class="screen">
calc/Makefile:6
     integer.c:6
     button.c:6
</pre><p>Sally's change to <tt class="filename">integer.c</tt> will
        appear in your working copy, and your change will still be
        present in <tt class="filename">button.c</tt>.  In this example,
        the text of <tt class="filename">Makefile</tt> is identical in
        revisions 4, 5, and 6, but Subversion will mark your working
        copy of <tt class="filename">Makefile</tt> with revision 6 to
        indicate that it is still current.  So, after you do a clean
        update at the top of your working copy, it will generally
        correspond to exactly one revision in the repository.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.3"></a>How Working Copies Track the Repository</h3></div></div><div></div></div><p>For each file in a working directory, Subversion records
        two essential pieces of information in the
        <tt class="filename">.svn/</tt> administrative area:</p><div class="itemizedlist"><ul type="disc"><li><p>what revision your working file is based on (this is
            called the file's <i class="firstterm">working
            revision</i>), and</p></li><li><p>a timestamp recording when the local copy was last
            updated by the repository.</p></li></ul></div><p>Given this information, by talking to the repository,
        Subversion can tell which of the following four states a
        working file is in:</p><div class="variablelist"><dl><dt><span class="term">Unchanged, and current</span></dt><dd><p>The file is unchanged in the working directory, and
              no changes to that file have been committed to the
              repository since its working revision.  An <span><b class="command">svn
              commit</b></span> of the file will do nothing, and an
              <span><b class="command">svn update</b></span> of the file will do
              nothing.</p></dd><dt><span class="term">Locally changed, and current</span></dt><dd><p>The file has been changed in the working directory,
              and no changes to that file have been committed to the
              repository since its base revision.  There are local
              changes that have not been committed to the repository,
              thus an <span><b class="command">svn commit</b></span> of the file will
              succeed in publishing your changes, and an <span><b class="command">svn
              update</b></span> of the file will do nothing.</p></dd><dt><span class="term">Unchanged, and out-of-date</span></dt><dd><p>The file has not been changed in the working
              directory, but it has been changed in the repository.
              The file should eventually be updated, to make it
              current with the public revision.  An <span><b class="command">svn
              commit</b></span> of the file will do nothing, and an
              <span><b class="command">svn update</b></span> of the file will fold the
              latest changes into your working copy.</p></dd><dt><span class="term">Locally changed, and out-of-date</span></dt><dd><p>The file has been changed both in the working
              directory, and in the repository.  An <span><b class="command">svn
              commit</b></span> of the file will fail with an
              &#8220;<span class="quote">out-of-date</span>&#8221; error.  The file should be
              updated first; an <span><b class="command">svn update</b></span> command
              will attempt to merge the public changes with the local
              changes.  If Subversion can't complete the merge in a
              plausible way automatically, it leaves it to the user to
              resolve the conflict.</p></dd></dl></div><p>This may sound like a lot to keep track of, but the
        <span><b class="command">svn status</b></span> command will show you the state
        of any item in your working copy.  For more information on
        that command, see <a href="#svn-ch-3-sect-5.3.1" title="svn status">the section called &#8220;svn status&#8221;</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-2-sect-3.4"></a>The Limitations of Mixed Revisions</h3></div></div><div></div></div><p>As a general principle, Subversion tries to be as flexible
        as possible.  One special kind of flexibility is the ability
        to have a working copy containing mixed revision
        numbers.</p><p>At first, it may not be entirely clear why this sort of
        flexibility is considered a feature, and not a liability.
        After completing a commit to the repository, the freshly
        committed files and directories are at a more recent working
        revision than the rest of the working copy.  It looks like a
        bit of a mess.  As demonstrated earlier, the working copy can
        always be brought to a single working revision by running
        <span><b class="command">svn update</b></span>.  Why would someone
        <span class="emphasis"><em>deliberately</em></span> want a mixture of working
        revisions?</p><p>Assuming your project is sufficiently complex, you'll
        discover that it's sometimes nice to forcibly
        &#8220;<span class="quote">backdate</span>&#8221; portions of your working copy to an
        earlier revision; you'll learn how to do that in Chapter 3.
        Perhaps you'd like to test an earlier version of a sub-module,
        contained in a subdirectory, or perhaps you'd like to examine
        a number of previous versions of a file in the context of the
        latest tree.</p><p>However you make use of mixed-revisions in your working
        copy, there are limitations to this flexibility.</p><p>First, you cannot commit the deletion of a file or
        directory which isn't fully up-to-date.  If a newer version of
        the item exists in the repository, your attempt to delete will
        be rejected, to prevent you from accidentally
        destroying changes you've not yet seen.</p><p>Second, you cannot commit a metadata change to a directory
        unless it's fully up-to-date.  You'll learn about attaching
        &#8220;<span class="quote">properties</span>&#8221; to items in Chapter 6.  A
        directory's working revision defines a specific set of entries
        and properties, and thus committing a property change to an
        out-of-date directory may destroy properties you've not yet
        seen.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-2-sect-4"></a>Summary</h2></div></div><div></div></div><p>We've covered a number of fundamental Subversion concepts in
      this chapter:</p><div class="itemizedlist"><ul type="disc"><li><p>We've introduced the notions of the central repository,
          the client working copy, and the array of repository
          revision trees.</p></li><li><p>We've seen some simple examples of how two collaborators
          can use Subversion to publish and receive changes from one
          another, using the &#8220;<span class="quote">copy-modify-merge</span>&#8221;
          model.</p></li><li><p>We've talked a bit about the way Subversion tracks and
          manages information in a working copy.</p></li></ul></div><p>At this point, you should have a good idea of how Subversion
      works in the most general sense.  Armed with this knowledge, you
      should now be ready to jump into the next chapter, which is a
      detailed tour of Subversion's commands and features.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-3"></a>Chapter 3. Guided Tour</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-3-sect-1">Help!</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-2">Import</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-3">Revisions: Numbers, Keywords, and Dates, Oh My!</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-3.1">Revision Numbers</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.2">Revision Keywords</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-3.3">Revision Dates</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-4">Initial Checkout</a></span></dt><dt><span class="sect1"><a href="#svn-ch-3-sect-5">Basic Work Cycle</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-5.1">Update Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.2">Make Changes to Your Working Copy</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-5.3">Examine Your Changes</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.1">svn status</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.2">svn diff</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.3.3">svn revert</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-5.4">Resolve Conflicts (Merging Others' Changes)</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.1">Merging Conflicts by Hand</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.2">Copying a File Onto Your Working File</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-5.4.3">Punting: Using svn revert</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-5.5">Commit Your Changes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-6">Examining History</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-6.1">svn log</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.2">svn diff</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.1">Examining Local Changes</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.2">Comparing Working Copy to Repository</a></span></dt><dt><span class="sect3"><a href="#svn-ch-3-sect-6.2.3">Comparing Repository to Repository</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-3-sect-6.3">svn cat</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.4">svn list</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-6.5">A Final Word on History</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-7">Other Useful Commands</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-3-sect-7.1">svn cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-3-sect-7.3">svn import</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-3-sect-8">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Now we will go into the details of using Subversion.  By the
      time you reach the end of this chapter, you will be able to
      perform almost all the tasks you need to use Subversion in a
      normal day's work.  You'll start with an initial checkout of
      your code, and walk through making changes and examining those
      changes. You'll also see how to bring changes made by others
      into your working copy, examine them, and work through any
      conflicts that might arise.</p><p>Note that this chapter is not meant to be an exhaustive list
      of all Subversion's commands&#8212;rather, it's a conversational
      introduction to the most common Subversion tasks you'll
      encounter.  This chapter assumes that you've read and understood
      <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a> and are familiar with the general
      model of Subversion.  For a complete reference of all commands,
      see <a href="#svn-ch-9" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-1"></a>Help!</h2></div></div><div></div></div><p>Before reading on, here is the most important command you'll
      ever need when using Subversion: <span><b class="command">svn help</b></span>.
      The Subversion command-line client is
      self-documenting&#8212;at any time, a quick <span><b class="command">svn help
      &lt;subcommand&gt;</b></span> will describe the syntax, switches,
      and behavior of the <span><b class="command">subcommand</b></span>.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-2"></a>Import</h2></div></div><div></div></div><p>You use <span><b class="command">svn import</b></span> to import a new
      project into a Subversion repository.  While this is most likely
      the very first thing you will do when you set up your Subversion
      server, it's not something that happens very often.  For a
      detailed description of import, see <a href="#svn-ch-3-sect-7.3" title="svn import">the section called &#8220;svn import&#8221;</a> later in this chapter.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-3"></a>Revisions: Numbers, Keywords, and Dates, Oh My!</h2></div></div><div></div></div><p>Before we go on, you should know a bit about how to identify
      a particular revision in your repository.  As you learned in
      <a href="#svn-ch-2-sect-3.2" title="Revisions">the section called &#8220;Revisions&#8221;</a>, a revision is a
      &#8220;<span class="quote">snapshot</span>&#8221; of the repository at a particular moment
      in time.  As you continue to commit and grow your repository,
      you need a mechanism for identifying these snapshots.</p><p>You specify these revisions by using the
      <tt class="option">--revision</tt> (<tt class="option">-r</tt>) switch plus
      the revision you want (<span><b class="command">svn --revision REV</b></span>) or
      you can specify a range by separating two revisions with a colon
      (<span><b class="command">svn --revision REV1:REV2</b></span>).  And Subversion
      lets you refer to these revisions by number, keyword, or
      date.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.1"></a>Revision Numbers</h3></div></div><div></div></div><p>When you create a new Subversion repository, it begins its
        life at revision zero and each successive commit increases the
        revision number by one.  After your commit completes, the
        Subversion client informs you of the new revision
        number:</p><pre class="screen">
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</pre><p>If at any point in the future you want to refer to that
        revision (we'll see how and why we might want to do that later
        in this chapter), you can refer to it as
        &#8220;<span class="quote">3</span>&#8221;.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.2"></a>Revision Keywords</h3></div></div><div></div></div><p>The Subversion client understands a number of
        <i class="firstterm">revision keywords</i>.  These keywords
        can be used instead of integer arguments to the
        <tt class="option">--revision</tt> switch, and are resolved into
        specific revision numbers by Subversion:</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Each directory in your working copy contains an
          administrative subdirectory called
          <tt class="filename">.svn</tt>.  For every file in a directory,
          Subversion keeps a copy of each file in the administrative
          area.  This copy is an unmodified (no keyword expansion, no
          end-of-line translation, no nothing) copy of the file as it
          existed in the last revision (called the &#8220;<span class="quote">BASE</span>&#8221;
          revision) that you updated it to in your working copy.  We
          refer to this file as the <i class="firstterm">pristine
          copy</i> or <i class="firstterm">text-base</i> version
          of your file, and it's always an exact byte-for-byte copy of
          the file as it exists in the repository.</p></div><div class="variablelist"><dl><dt><span class="term">HEAD</span></dt><dd><p>The latest revision in the repository.</p></dd><dt><span class="term">BASE</span></dt><dd><p>The &#8220;<span class="quote">pristine</span>&#8221; revision of an item in a
              working copy.</p></dd><dt><span class="term">COMMITTED</span></dt><dd><p>The last revision in which an item changed before (or
              at) <tt class="literal">BASE</tt>.</p></dd><dt><span class="term">PREV</span></dt><dd><p>The revision just <span class="emphasis"><em>before</em></span> the last
              revision in which an item changed.  (Technically,
              <tt class="literal">COMMITTED</tt> - 1.)</p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><tt class="literal">PREV</tt>, <tt class="literal">BASE</tt>, and
          <tt class="literal">COMMITTED</tt> can be used to refer to local
          paths, but not to URLs.</p></div><p>Here are some examples of revision keywords in action.
        Don't worry if the commands don't make sense yet; we'll be
        explaining these commands as we go through the chapter:</p><pre class="screen">
$ svn diff --revision PREV:COMMITTED foo.c
# shows the last change committed to foo.c

$ svn log --revision HEAD
# shows log message for the latest repository commit

$ svn diff --revision HEAD
# compares your working file (with local mods) to the latest version
# in the repository.

$ svn diff --revision BASE:HEAD foo.c
# compares your &#8220;<span class="quote">pristine</span>&#8221; foo.c (no local mods) with the 
# latest version in the repository

$ svn log --revision BASE:HEAD
# shows all commit logs since you last updated

$ svn update --revision PREV foo.c
# rewinds the last change on foo.c.
# (foo.c's working revision is decreased.)
</pre><p>These keywords allow you to perform many common (and
        helpful) operations without having to look up specific
        revision numbers or remember the exact revision of your
        working copy.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-3.3"></a>Revision Dates</h3></div></div><div></div></div><p>Anywhere that you specify a revision number or revision
        keyword, you can also specify a date
        inside curly braces &#8220;<span class="quote">{}</span>&#8221;.  You can even access
        a range of changes in the repository using both dates and
        revisions together!</p><p>Here are examples of the date formats that Subversion
        accepts.  Remember to use quotes around any date that contains
        spaces.</p><pre class="screen">
$ svn checkout --revision {2002-02-17}
$ svn checkout --revision {15:30}
$ svn checkout --revision {15:30:00.200000}
$ svn checkout --revision {"2002-02-17 15:30"}
$ svn checkout --revision {"2002-02-17 15:30 +0230"}
$ svn checkout --revision {2002-02-17T15:30}
$ svn checkout --revision {2002-02-17T15:30Z}
$ svn checkout --revision {2002-02-17T15:30-04:00}
$ svn checkout --revision {20020217T1530}
$ svn checkout --revision {20020217T1530Z}
$ svn checkout --revision {20020217T1530-0500}
&#8230;
</pre><p>When you specify a date as a revision, Subversion finds
        the most recent revision of the repository as of that
        date:</p><pre class="screen">
$ svn log --revision {2002-11-28}
------------------------------------------------------------------------
r12 | ira | 2002-11-27 12:31:51 -0600 (Wed, 27 Nov 2002) | 6 lines
&#8230;
</pre><div class="sidebar"><p class="title"><b>Is Subversion a Day Early?</b></p><p>If you specify a single date as a revision without
          specifying a time of day (for example
          <tt class="literal">2002-11-27</tt>), you may think that Subversion
          should give you the last revision that took place on the
          27th of November.  Instead, you'll get back a revision from
          the 26th, or even earlier.  Remember that Subversion will
          find the <span class="emphasis"><em>most recent revision of the
          repository</em></span> as of the date you give.  If you give
          a date without a timestamp, like
          <tt class="literal">2002-11-27</tt>, Subversion assumes a time of
          00:00:00, so looking for the most recent revision won't
          return anything on the day of the 27th.</p><p>If you want to include the 27th in your search, you can
          either specify the 27th with the time (<tt class="literal">{"2002-11-27
          23:59"}</tt>), or just specify the next day
          (<tt class="literal">{2002-11-28}</tt>).</p></div><p>You can also use a range of dates.  Subversion will find
        all revisions between both dates, inclusive:</p><pre class="screen">
$ svn log --revision {2002-11-20}:{2002-11-29}
&#8230;
</pre><p>As we pointed out, you can also mix dates and revisions:</p><pre class="screen">
$ svn log --revision {2002-11-20}:4040
</pre><p>Users should be aware of a subtlety that can become quite
        a stumbling-block when dealing with dates in Subversion.  Since
        the timestamp of a revision is stored as a property of the
        revision&#8212;an unversioned, modifiable
        property&#8212;revision timestamps can be changed to represent
        complete falsifications of true chronology, or even removed
        altogether.  This will wreak havoc on the internal
        date-to-revision conversion that Subversion performs.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-4"></a>Initial Checkout</h2></div></div><div></div></div><p>Most of the time, you will start using a Subversion
      repository by doing a <i class="firstterm">checkout</i> of your
      project.  Checking out a repository creates a copy of it on your
      local machine.  This copy contains the <tt class="literal">HEAD</tt>
      (latest revision) of the Subversion repository that you specify
      on the command line:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk
A  trunk/subversion.dsw
A  trunk/svn_check.dsp
A  trunk/COMMITTERS
A  trunk/configure.in
A  trunk/IDEAS
&#8230;
Checked out revision 2499.
</pre><div class="sidebar"><p class="title"><b>Repository Layout</b></p><p>If you're wondering what <tt class="literal">trunk</tt> is all
        about in the above URL, it's part of the way we recommend
        you lay out your Subversion repository which we'll talk a lot
        more about in <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>.</p></div><p>Although the above example checks out the trunk directory,
      you can just as easily check out any deep subdirectory of a
      repository by specifying the subdirectory in the checkout
      URL:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk/doc/book/tools
A  tools/readme-dblite.html
A  tools/fo-stylesheet.xsl
A  tools/svnbook.el
A  tools/dtd
A  tools/dtd/dblite.dtd
&#8230;
Checked out revision 2499.
</pre><p>Since Subversion uses a &#8220;<span class="quote">copy-modify-merge</span>&#8221;
      model instead of &#8220;<span class="quote">lock-modify-unlock</span>&#8221; (see <a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>), you're already able to start making
      changes to the files and directories in your working copy.  Your
      working copy is just like any other collection of files and
      directories on your system.  You can edit and change them, move
      them around, you can even delete the entire working copy and
      forget about it.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>While your working copy is &#8220;<span class="quote">just like any other
          collection of files and directories on your system</span>&#8221;,
          you need to let Subversion know if you're going to be
          rearranging anything inside of your working copy.  If you
          want to copy or move an item in a working copy, you should
          use <span><b class="command">svn copy</b></span> or <span><b class="command">svn
          move</b></span> instead of the copy and move commands
          provided by your operating system.  We'll talk more about
          them later in this chapter.</p></div><p>Unless you're ready to commit a new file or directory, or
      changes to existing ones, there's no need to further notify the
      Subversion server that you've done anything.</p><div class="sidebar"><p class="title"><b>What's with the <tt class="filename">.svn</tt> directory?</b></p><p>Every directory in a working copy contains an
        administrative area, a subdirectory named
        <tt class="filename">.svn</tt>.  Usually, directory listing
        commands won't show this subdirectory, but it is nevertheless
        an important directory.  Whatever you do, don't delete or
        change anything in the administrative area!  Subversion
        depends on it to manage your working copy.</p></div><p>While you can certainly check out a working copy with the
      URL of the repository as the only argument, you can also specify
      a directory after your repository URL.  This places your working
      copy in the new directory that you name.  For example:</p><pre class="screen">
$ svn checkout http://svn.collab.net/repos/svn/trunk subv
A  subv/subversion.dsw
A  subv/svn_check.dsp
A  subv/COMMITTERS
A  subv/configure.in
A  subv/IDEAS
&#8230;
Checked out revision 2499.
</pre><p>That will place your working copy in a directory named
      <tt class="literal">subv</tt> instead of a directory named
      <tt class="literal">trunk</tt> as we did previously.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-5"></a>Basic Work Cycle</h2></div></div><div></div></div><p>Subversion has numerous features, options, bells and whistles, but on
      a day-to-day basis, odds are that you will only use a few of them. In
      this section we'll run through the most common things that you might
      find yourself doing with Subversion in the course of a day's work.</p><p>The typical work cycle looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p>Update your working copy</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn update</b></span></p></li></ul></div></li><li><p>Make changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn add</b></span></p></li><li><p><span><b class="command">svn delete</b></span></p></li><li><p><span><b class="command">svn copy</b></span></p></li><li><p><span><b class="command">svn move</b></span></p></li></ul></div></li><li><p>Examine your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn status</b></span></p></li><li><p><span><b class="command">svn diff</b></span></p></li><li><p><span><b class="command">svn revert</b></span></p></li></ul></div></li><li><p>Merge others' changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn merge</b></span></p></li><li><p><span><b class="command">svn resolved</b></span></p></li></ul></div></li><li><p>Commit your changes</p><div class="itemizedlist"><ul type="circle"><li><p><span><b class="command">svn commit</b></span></p></li></ul></div></li></ul></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.1"></a>Update Your Working Copy</h3></div></div><div></div></div><p>When working on a project with a team, you'll want to
        update your working copy to receive any changes made since
        your last update by other developers on the project.  Use
        <span><b class="command">svn update</b></span> to bring your working copy into
        sync with the latest revision in the repository.</p><pre class="screen">
$ svn update
U  foo.c
U  bar.c
Updated to revision 2.
</pre><p>In this case, someone else checked in modifications to
        both <tt class="filename">foo.c</tt> and <tt class="filename">bar.c</tt>
        since the last time you updated, and Subversion has updated
        your working copy to include those changes.</p><p>Let's examine the output of <span><b class="command">svn update</b></span>
        a bit more.  When the server sends changes to your working
        copy, a letter code is displayed next to each item to let you
        know what actions Subversion performed to bring your working
        copy up-to-date:</p><div class="variablelist"><dl><dt><span class="term"><tt class="computeroutput">U      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> was
              <tt class="computeroutput">U</tt>pdated (received changes
              from the server).</p></dd><dt><span class="term"><tt class="computeroutput">A      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">A</tt>dded to your working
              copy.</p></dd><dt><span class="term"><tt class="computeroutput">D      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">D</tt>eleted from your working
              copy.</p></dd><dt><span class="term"><tt class="computeroutput">R      foo</tt></span></dt><dd><p>File or directory <tt class="filename">foo</tt> was
              <tt class="computeroutput">R</tt>eplaced in your working
              copy; that is, <tt class="filename">foo</tt> was deleted, and a
              new item with the same name was added.  While they may have
              the same name, the repository considers them to be distinct
              objects with distinct histories.</p></dd><dt><span class="term"><tt class="computeroutput">G      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> received new changes
              from the repository, but your local copy of the file had
              your modifications.  Either the changes did not intersect,
              or the changes were exactly the same as your local
              modifications, so Subversion has successfully
              mer<tt class="computeroutput">G</tt>ed the repository's
              changes into the file without a problem.</p></dd><dt><span class="term"><tt class="computeroutput">C      foo</tt></span></dt><dd><p>File <tt class="filename">foo</tt> received
              <tt class="computeroutput">C</tt>onflicting changes from
              the server.  The changes from the server directly overlap
              your own changes to the file.  No need to panic, though.
              This overlap needs to be resolved by a human (you); we
              discuss this situation later in this chapter.</p></dd></dl></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.2"></a>Make Changes to Your Working Copy</h3></div></div><div></div></div><p>Now you can get to work and make changes in your
        working copy. It's usually most convenient to decide on a
        particular change (or set of changes) to make, such as writing
        a new feature, fixing a bug, etc.  The Subversion commands
        that you will use here are <span><b class="command">svn add</b></span>,
        <span><b class="command">svn delete</b></span>, <span><b class="command">svn copy</b></span>,
        and <span><b class="command">svn move</b></span>.  However, if you are merely
        editing files that are already in Subversion, you may not need
        to use any of these commands until you commit.  Changes you can
        make to your working copy:</p><div class="variablelist"><dl><dt><span class="term">File changes</span></dt><dd><p>This is the simplest sort of change.  You don't need
              to tell Subversion that you intend to change a file;
              just make your changes.  Subversion will be able to
              automatically detect which files have been
              changed.</p></dd><dt><span class="term">Tree changes</span></dt><dd><p>You can ask Subversion to &#8220;<span class="quote">mark</span>&#8221; files
              and directories for scheduled removal, addition,
              copying, or moving.  While these changes may take place
              immediately in your working copy, no additions or
              removals will happen in the repository until you commit
              them.</p></dd></dl></div><p>To make file changes, use your text editor, word
        processor, graphics program, or whatever tool you would
        normally use.  Subversion handles binary files just as easily
        as it handles text files&#8212;and just as efficiently
        too.</p><p>Here is an overview of the four Subversion subcommands
        that you'll use most often to make tree changes (we'll cover
        <span><b class="command">svn import</b></span> and <span><b class="command">svn mkdir</b></span>
        later).</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">svn add foo</b></span></span></dt><dd><p>Schedule file, directory, or symbolic link
              <tt class="filename">foo</tt> to be added to the repository.
              When you next commit, <tt class="filename">foo</tt> will
              become a child of its parent directory.  Note that if
              <tt class="filename">foo</tt> is a directory, everything
              underneath <tt class="filename">foo</tt> will be scheduled
              for addition.  If you only want to add
              <tt class="filename">foo</tt> itself, pass the
              <tt class="option">--non-recursive</tt> (<tt class="option">-N</tt>)
              switch.</p></dd><dt><span class="term"><span><b class="command">svn delete foo</b></span></span></dt><dd><p>Schedule file, directory, or symbolic link
              <tt class="filename">foo</tt> to be deleted from the
              repository.  If <tt class="filename">foo</tt> is a file or
              link, it is immediately deleted from your working copy.
              If <tt class="filename">foo</tt> is a directory, it is not
              deleted, but Subversion schedules it for deletion.  When
              you commit your changes, <tt class="filename">foo</tt> will
              be removed from your working copy and the repository.
              <sup>[<a name="id895273" href="#ftn.id895273">2</a>]</sup></p></dd><dt><span class="term"><span><b class="command">svn copy foo bar</b></span></span></dt><dd><p>Create a new item <tt class="filename">bar</tt> as a
              duplicate of <tt class="filename">foo</tt>.
              <tt class="filename">bar</tt> is automatically scheduled for
              addition.  When <tt class="filename">bar</tt> is added to the
              repository on the next commit, its copy history is
              recorded (as having originally come from
              <tt class="filename">foo</tt>).  <span><b class="command">svn copy</b></span>
              does not create intermediate directories.</p></dd><dt><span class="term"><span><b class="command">svn move foo bar</b></span></span></dt><dd><p>This command is exactly the same as running
              <span><b class="command">svn copy foo bar; svn delete foo</b></span>.
              That is, <tt class="filename">bar</tt> is scheduled for
              addition as a copy of <tt class="filename">foo</tt>, and
              <tt class="filename">foo</tt> is scheduled for removal.
              <span><b class="command">svn move</b></span> does not create intermediate
              directories.</p></dd></dl></div><div class="sidebar"><p class="title"><b>Changing the Repository Without a Working Copy</b></p><p>Earlier in this chapter, we said that you have to commit
          any changes that you make in order for the repository to
          reflect these changes. That's not entirely true&#8212;there
          <span class="emphasis"><em>are</em></span> some use-cases that immediately
          commit tree changes to the repository.  This only happens
          when a subcommand is operating directly on a URL, rather
          than on a working-copy path. In particular, specific uses
          of <span><b class="command">svn mkdir</b></span>, <span><b class="command">svn
          copy</b></span>, <span><b class="command">svn move</b></span>, and
          <span><b class="command">svn delete</b></span> can work with URLs.</p><p>URL operations behave in this manner because commands
          that operate on a working copy can use the working copy as a
          sort of &#8220;<span class="quote">staging area</span>&#8221; to set up your changes
          before committing them to the repository.  Commands that
          operate on URLs don't have this luxury, so when you operate
          directly on a URL, any of the above actions represent an
          immediate commit.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.3"></a>Examine Your Changes</h3></div></div><div></div></div><p>Once you've finished making changes, you need to commit
        them to the repository, but before you do so, it's usually a
        good idea to take a look at exactly what you've changed.  By
        examining your changes before you commit, you can make a
        more accurate log message. You may also discover that
        you've inadvertently changed a file, and this gives you a
        chance to revert those changes before committing.
        Additionally, this is a good opportunity to review and
        scrutinize changes before publishing them.  You can see
        exactly what changes you've made by using <span><b class="command">svn
        status</b></span>, <span><b class="command">svn diff</b></span>, and
        <span><b class="command">svn revert</b></span>.  You will usually use the first
        two commands to find out what files have changed in your
        working copy, and then perhaps the third to revert some (or
        all) of those changes.</p><p>Subversion has been optimized to help you with this task,
        and is able to do many things without communicating with the
        repository.  In particular, your working copy contains a
        secret cached &#8220;<span class="quote">pristine</span>&#8221; copy of each version
        controlled file within the <tt class="filename">.svn</tt> area.
        Because of this, Subversion can quickly show you how your
        working files have changed, or even allow you to undo your
        changes without contacting the repository.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.3.1"></a><span><b class="command">svn status</b></span></h4></div></div><div></div></div><p>You'll probably use the <span><b class="command">svn status</b></span>
          command more than any other Subversion command.</p><div class="sidebar"><p class="title"><b>CVS Users: Hold That Update!</b></p><p>You're probably used to using <span><b class="command">cvs
            update</b></span> to see what changes you've made to your
            working copy.  <span><b class="command">svn status</b></span> will give you
            all the information you need regarding what has changed in
            your working copy&#8212;without accessing the repository
            or potentially incorporating new changes published by
            other users.</p><p>In Subversion, <span><b class="command">update</b></span> does just
            that&#8212;it updates your working copy with any changes
            committed to the repository since the last time you've
            updated your working copy.  You'll have to break the habit
            of using the <span><b class="command">update</b></span> command to see what
            local modifications you've made.</p></div><p>If you run <span><b class="command">svn status</b></span> at the top of
          your working copy with no arguments, it will detect all file
          and tree changes you've made.  Below are examples of
          the different status codes that <span><b class="command">svn
          status</b></span> can return.  (Note that the text following
          <tt class="literal">#</tt> is not
          actually printed by <span><b class="command">svn status</b></span>.)</p><pre class="screen">
  L    abc.c               # svn has a lock in its .svn directory for abc.c
M      bar.c               # the content in bar.c has local modifications
 M     baz.c               # baz.c has property but no content modifications
X      3rd_party           # this dir is part of an externals definition
?      foo.o               # svn doesn't manage foo.o
!      some_dir            # svn manages this, but it's either missing or incomplete
~      qux                 # versioned as file/dir/link, but type has changed
I      .screenrc           # svn doesn't manage this, and is configured to ignore it
A  +   moved_dir           # added with history of where it came from
M  +   moved_dir/README    # added with history and has local modifications
D      stuff/fish.c        # this file is scheduled for deletion
A      stuff/loot/bloo.h   # this file is scheduled for addition
C      stuff/loot/lump.c   # this file has conflicts from an update
    S  stuff/squawk        # this file or dir has been switched to a branch
</pre><p>In this output format <span><b class="command">svn status</b></span>
          prints five columns of characters, followed by several
          whitespace characters, followed by a file or directory name.
          The first column tells the status of a file or directory
          and/or its contents.  The codes printed here are:</p><div class="variablelist"><dl><dt><span class="term"><tt class="computeroutput">A      item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> has been scheduled for
                addition into the repository.</p></dd><dt><span class="term"><tt class="computeroutput">C     item</tt></span></dt><dd><p>The file <tt class="filename">item</tt> is in a state
                of conflict.  That is, changes received from the
                server during an update overlap with local changes
                that you have in your working copy.  You must resolve
                this conflict before committing your changes to the
                repository.</p></dd><dt><span class="term"><tt class="computeroutput">D      item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> has been scheduled for
                deletion from the repository.</p></dd><dt><span class="term"><tt class="computeroutput">M      item</tt></span></dt><dd><p>The contents of the file <tt class="filename">item</tt>
                have been modified.</p></dd><dt><span class="term"><tt class="computeroutput">X      item</tt></span></dt><dd><p>The directory <tt class="filename">item</tt> is
                unversioned, but is related to a Subversion externals
                definition.  To find out more about externals
                definitions, see <a href="#svn-ch-7-sect-3" title="Externals Definitions">the section called &#8220;Externals Definitions&#8221;</a>.</p></dd><dt><span class="term"><tt class="computeroutput">?      item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> is not under version
                control.  You can silence the question marks by either
                passing the <tt class="option">--quiet</tt>
                (<tt class="option">-q</tt>) switch to <span><b class="command">svn
                status</b></span>, or by setting the
                <tt class="literal">svn:ignore</tt> property on the parent
                directory.  For more information on ignored files, see
                <a href="#svn-ch-7-sect-2.3.3" title="svn:ignore">the section called &#8220;svn:ignore&#8221;</a>.</p></dd><dt><span class="term"><tt class="computeroutput">!      item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> is under version control but
                is missing or somehow incomplete.  The item can be
                missing if it's removed using a non-Subversion
                command.  In the case of a directory, it can be
                incomplete if you happened to interrupt a checkout or
                update.  A quick <span><b class="command">svn update</b></span> will
                refetch the file or directory from the repository, or
                <span><b class="command">svn revert file</b></span> will restore a
                missing file.</p></dd><dt><span class="term"><tt class="computeroutput">~     item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> is in the repository as one
                kind of object, but what's actually in your working
                copy is some other kind.  For example, Subversion
                might have a file in the repository, but you removed
                the file and created a directory in its place, without
                using the <span><b class="command">svn delete</b></span> or
                <span><b class="command">svn add</b></span> command.</p></dd><dt><span class="term"><tt class="computeroutput">I      item</tt></span></dt><dd><p>The file, directory, or symbolic link
                <tt class="filename">item</tt> is not under version control,
                and Subversion is configured to ignore it during
                <span><b class="command">svn add</b></span>, <span><b class="command">svn import</b></span>
                and <span><b class="command">svn status</b></span> operations.  For more
                information on ignored files, see <a href="#svn-ch-7-sect-2.3.3" title="svn:ignore">the section called &#8220;svn:ignore&#8221;</a>.  Note that this
                symbol only shows up if you pass the
                <tt class="option">--no-ignore</tt> option to <span><b class="command">svn
                status</b></span>&#8212;otherwise the file would be
                ignored and not listed at all!</p></dd></dl></div><p>The second column tells the status of a file or
          directory's properties (see <a href="#svn-ch-7-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a> for more information on
          properties).  If an <tt class="computeroutput">M</tt>
          appears in the second column, then the properties have been
          modified, otherwise a whitespace will be printed.</p><p>The third column will only show whitespace or an
          <tt class="computeroutput">L</tt> which means that
          Subversion has locked the item in
          the <tt class="filename">.svn</tt> working area.  You will see an
          <tt class="computeroutput">L</tt> if you run <span><b class="command">svn
          status</b></span> in a directory where an <span><b class="command">svn
          commit</b></span> is in progress&#8212;perhaps when you are
          editing the log message.  If Subversion is not running, then
          presumably Subversion was interrupted and the lock needs to
          be cleaned up by running <span><b class="command">svn cleanup</b></span>
          (more about that later in this chapter).</p><p>The fourth column will only show whitespace or a
          <tt class="computeroutput">+</tt> which means that the file
          or directory is scheduled to be added or modified with
          additional attached history.  This typically happens when you
          <span><b class="command">svn move</b></span> or <span><b class="command">svn copy</b></span> a file
          or directory.  If you see
          <tt class="computeroutput">A  +</tt>, this means
          the item is scheduled for addition-with-history.  It could be
          a file, or the root of a copied directory.
          <tt class="computeroutput">+</tt>
          means the item is part of a subtree scheduled for
          addition-with-history, i.e. some parent got copied, and it's
          just coming along for the ride.
          <tt class="computeroutput">M  +</tt> means the item
          is part of a subtree scheduled for addition-with-history,
          <span class="emphasis"><em>and</em></span> it has local modifications.  When you
          commit, first the parent will be added-with-history (copied),
          which means this file will automatically exist in the copy.
          Then the local modifications will be uploaded into the
          copy.</p><p>The fifth column will only show whitespace or an
          <tt class="computeroutput">S</tt>.  This signifies that the
          file or directory has been switched from the path of the
          rest of the working copy (using <span><b class="command">svn
          switch</b></span>) to a branch.</p><p>If you pass a specific path to <span><b class="command">svn
          status</b></span>, it gives you information about that item
          alone:</p><pre class="screen">
$ svn status stuff/fish.c
D      stuff/fish.c
</pre><p><span><b class="command">svn status</b></span> also has a
          <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) switch,
          which will show you the status of <span class="emphasis"><em>every</em></span>
          item in your working copy, even if it has not been
          changed:</p><pre class="screen">
$ svn status --verbose
M               44        23    sally     README
                44        30    sally     INSTALL
M               44        20    harry     bar.c
                44        18    ira       stuff
                44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
                44        21    sally     stuff/things
A                0         ?     ?        stuff/things/bloo.h
                44        36    harry     stuff/things/gloo.c
</pre><p>This is the &#8220;<span class="quote">long form</span>&#8221; output of
          <span><b class="command">svn status</b></span>.  The first column remains
          the same, but the second column shows the working-revision of
          the item.  The third and fourth columns show the revision in
          which the item last changed, and who changed it.</p><p>None of the above invocations to <span><b class="command">svn
          status</b></span> contact the repository, they work only
          locally by comparing the metadata in the
          <tt class="filename">.svn</tt> directory with the working copy.
          Finally, there is the <tt class="option">--show-updates</tt>
          (<tt class="option">-u</tt>) switch, which contacts the repository
          and adds information about things that are
          out-of-date:</p><pre class="screen">
$ svn status --show-updates --verbose
M      *        44        23    sally     README
M               44        20    harry     bar.c
       *        44        35    harry     stuff/trout.c
D               44        19    ira       stuff/fish.c
A                0         ?     ?        stuff/things/bloo.h
Status against revision:   46
</pre><p>Notice the two asterisks: if you were to run
          <span><b class="command">svn update</b></span> at this point, you would
          receive changes to <tt class="filename">README</tt>
          and <tt class="filename">trout.c</tt>.  This tells you some very
          useful information&#8212;you'll need to update and get the
          server changes on <tt class="filename">README</tt> before you
          commit, or the repository will reject your commit for being
          out-of-date.  (More on this subject later.)</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.3.2"></a><span><b class="command">svn diff</b></span></h4></div></div><div></div></div><p>Another way to examine your changes is with the
          <span><b class="command">svn diff</b></span> command.  You can find out
          <span class="emphasis"><em>exactly</em></span> how you've modified things by
          running <span><b class="command">svn diff</b></span> with no arguments, which
          prints out file changes in unified diff
          format:<sup>[<a name="id896311" href="#ftn.id896311">3</a>]</sup></p><pre class="screen">
$ svn diff
Index: bar.c
===================================================================
--- bar.c	(revision 3)
+++ bar.c	(working copy)
@@ -1,7 +1,12 @@
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;unistd.h&gt;
+
+#include &lt;stdio.h&gt;

 int main(void) {
-  printf("Sixty-four slices of American Cheese...\n");
+  printf("Sixty-five slices of American Cheese...\n");
 return 0;
 }

Index: README
===================================================================
--- README	(revision 3)
+++ README	(working copy)
@@ -193,3 +193,4 @@ 
+Note to self:  pick up laundry.

Index: stuff/fish.c
===================================================================
--- stuff/fish.c	(revision 1)
+++ stuff/fish.c	(working copy)
-Welcome to the file known as 'fish'.
-Information on fish will be here soon.

Index: stuff/things/bloo.h
===================================================================
--- stuff/things/bloo.h	(revision 8)
+++ stuff/things/bloo.h	(working copy)
+Here is a new file to describe
+things about bloo.
</pre><p>The <span><b class="command">svn diff</b></span> command produces this
          output by comparing your working files against the cached
          &#8220;<span class="quote">pristine</span>&#8221; copies within the
          <tt class="filename">.svn</tt> area.  Files scheduled for
          addition are displayed as all added-text, and files
          scheduled for deletion are displayed as all deleted
          text.</p><p>Output is displayed in <i class="firstterm">unified diff
          format</i>.  That is, removed lines are prefaced
          with a <tt class="literal">-</tt> and added lines are prefaced
          with a <tt class="literal">+</tt>.  <span><b class="command">svn diff</b></span>
          also prints filename and offset information useful to the
          <span><b class="command">patch</b></span> program, so you can generate
          &#8220;<span class="quote">patches</span>&#8221; by redirecting the diff output to a
          file:</p><pre class="screen">
$ svn diff &gt; patchfile
</pre><p>You could, for example, email the patch file to another
          developer for review or testing prior to commit.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.3.3"></a><span><b class="command">svn revert</b></span></h4></div></div><div></div></div><p>Now suppose you see the above diff output, and realize
          that your changes to <tt class="filename">README</tt> are a
          mistake; perhaps you accidentally typed that text into the
          wrong file in your editor.</p><p>This is a perfect opportunity to use <span><b class="command">svn
          revert</b></span>.</p><pre class="screen">
$ svn revert README
Reverted 'README'
</pre><p>Subversion reverts the file to its pre-modified state by
          overwriting it with the cached &#8220;<span class="quote">pristine</span>&#8221; copy
          from the <tt class="filename">.svn</tt> area.  But also note that
          <span><b class="command">svn revert</b></span> can undo
          <span class="emphasis"><em>any</em></span> scheduled operations&#8212;for
          example, you might decide that you don't want to add a new
          file after all:</p><pre class="screen">
$ svn status foo
?      foo

$ svn add foo
A         foo

$ svn revert foo
Reverted 'foo'

$ svn status foo
?      foo
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p><span><b class="command">svn revert</b></span>
            <i class="replaceable"><tt>ITEM</tt></i> has exactly the same
            effect as deleting <i class="replaceable"><tt>ITEM</tt></i> from
            your working copy and then running <span><b class="command">svn update -r
            BASE</b></span> <i class="replaceable"><tt>ITEM</tt></i>.  However,
            if you're reverting a file, <span><b class="command">svn revert</b></span>
            has one very noticeable difference&#8212;it doesn't have
            to communicate with the repository to restore your
            file.</p></div><p>Or perhaps you mistakenly removed a file from version
          control:</p><pre class="screen">
$ svn status README 
       README

$ svn delete README 
D         README

$ svn revert README
Reverted 'README'

$ svn status README
       README
</pre></div><div class="sidebar"><p class="title"><b>Look Ma! No Network!</b></p><p>All three of these commands (<span><b class="command">svn
          status</b></span>, <span><b class="command">svn diff</b></span>, and
          <span><b class="command">svn revert</b></span>) can be used without any
          network access.  This makes it easy to manage your
          changes-in-progress when you are somewhere without a network
          connection, such as traveling on an airplane, riding a
          commuter train or hacking on the beach.</p><p>Subversion does this by keeping private caches of
          pristine versions of each versioned file inside of the
          <tt class="filename">.svn</tt> administrative areas.  This allows
          Subversion to report&#8212;and revert&#8212;local
          modifications to those files <span class="emphasis"><em>without network
          access</em></span>.  This cache (called the
          &#8220;<span class="quote">text-base</span>&#8221;) also allows Subversion to send the
          user's local modifications during a commit to the server as
          a compressed <i class="firstterm">delta</i> (or
          &#8220;<span class="quote">difference</span>&#8221;) against the pristine version.
          Having this cache is a tremendous benefit&#8212;even if you
          have a fast net connection, it's much faster to send only a
          file's changes rather than the whole file to the server.  At
          first glance, this might not seem that important, but
          imagine the repercussions if you try to commit a one line
          change to a 400MB file and have to send the whole file to
          the server!</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.4"></a>Resolve Conflicts (Merging Others' Changes)</h3></div></div><div></div></div><p>We've already seen how <span><b class="command">svn status -u</b></span>
        can predict conflicts.  Suppose you run <span><b class="command">svn
        update</b></span> and some interesting things occur:</p><pre class="screen">
$ svn update
U  INSTALL
G  README
C  bar.c
Updated to revision 46.
</pre><p>The <tt class="computeroutput">U</tt> and
        <tt class="computeroutput">G</tt> codes are no cause for
        concern; those files cleanly absorbed changes from the
        repository.  The files marked with
        <tt class="computeroutput">U</tt> contained no local changes
        but were <tt class="computeroutput">U</tt>pdated with changes
        from the repository.  The <tt class="computeroutput">G</tt>
        stands for mer<tt class="computeroutput">G</tt>ed, which
        means that the file had local changes to begin with, but the
        changes coming from the repository didn't overlap with the local
        changes.</p><p>But the <tt class="computeroutput">C</tt> stands for
        conflict.  This means that the changes from the server overlapped
        with your own, and now you have to manually choose between
        them.</p><p>Whenever a conflict occurs, three things typically occur
        to assist you in noticing and resolving that conflict:</p><div class="itemizedlist"><ul type="disc"><li><p>Subversion prints a <tt class="computeroutput">C</tt>
            during the update, and remembers that the file is in a
            state of conflict.</p></li><li><p>If Subversion considers the file to be of a mergable
            type, it places <i class="firstterm">conflict
            markers</i>&#8212;special strings of text which
            delimit the &#8220;<span class="quote">sides</span>&#8221; of the
            conflict&#8212;into the file to visibly demonstrate the
            overlapping areas.  (Subversion uses the
            <tt class="literal">svn:mime-type</tt> property to decide if a
            file is capable of contextual, line-based merging.  See
            <a href="#svn-ch-7-sect-2.3.2" title="svn:mime-type">the section called &#8220;svn:mime-type&#8221;</a> to learn more.)</p></li><li><p>For every conflicted file, Subversion places up to
            three extra unversioned files in your working copy:</p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">filename.mine</tt></span></dt><dd><p>This is your file as it existed in your working
                  copy before you updated your working copy&#8212;that
                  is, without conflict markers.  This file has your
                  latest changes in it and nothing else.  (If
                  Subversion considers the file to be unmergeable,
                  then the <tt class="filename">.mine</tt> file isn't
                  created, since it would be identical to the working
                  file.)</p></dd><dt><span class="term"><tt class="filename">filename.rOLDREV</tt></span></dt><dd><p>This is the file that was the
                  <tt class="literal">BASE</tt> revision before you updated
                  your working copy.  That is, the file that you
                  checked out before you made your latest
                  edits.</p></dd><dt><span class="term"><tt class="filename">filename.rNEWREV</tt></span></dt><dd><p>This is the file that your Subversion client
                  just received from the server when you updated your
                  working copy.  This file corresponds to the
                  <tt class="literal">HEAD</tt> revision of the
                  repository.</p></dd></dl></div><p>Here <tt class="literal">OLDREV</tt> is the revision number
            of the file in your <tt class="filename">.svn</tt> directory
            and <tt class="literal">NEWREV</tt> is the revision number of
            the repository <tt class="literal">HEAD</tt>.</p></li></ul></div><p>For example, Sally makes changes to the file
        <tt class="filename">sandwich.txt</tt> in the repository.  Harry has
        just changed the file in his working copy and checked it in.
        Sally updates her working copy before checking in and she gets
        a conflict:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls -1
sandwich.txt
sandwich.txt.mine
sandwich.txt.r1
sandwich.txt.r2
</pre><p>At this point, Subversion will <span class="emphasis"><em>not</em></span>
        allow you to commit the file <tt class="filename">sandwich.txt</tt>
        until the three temporary files are removed.</p><pre class="screen">
$ svn commit --message "Add a few more things"
svn: Commit failed (details follow):
svn: Aborting commit: '/home/sally/svn-work/sandwich.txt' remains in conflict
</pre><p>If you get a conflict, you need to do one of three
        things:</p><div class="itemizedlist"><ul type="disc"><li><p>Merge the conflicted text &#8220;<span class="quote">by hand</span>&#8221; (by
              examining and editing the conflict markers within the
              file).</p></li><li><p>Copy one of the temporary files on top of your
              working file.</p></li><li><p>Run <span><b class="command">svn revert &lt;filename&gt;</b></span>
              to throw away all of your local changes.</p></li></ul></div><p>Once you've resolved the conflict, you need to let
        Subversion know by running <span><b class="command">svn resolved</b></span>.
        This removes the three temporary files and Subversion no
        longer considers the file to be in a state of
        conflict.<sup>[<a name="id896971" href="#ftn.id896971">4</a>]</sup></p><pre class="screen">
$ svn resolved sandwich.txt
Resolved conflicted state of 'sandwich.txt'
</pre><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.4.1"></a>Merging Conflicts by Hand</h4></div></div><div></div></div><p>Merging conflicts by hand can be quite intimidating the
          first time you attempt it, but with a little practice, it
          can become as easy as falling off a bike.</p><p>Here's an example.  Due to a miscommunication, you and
          Sally, your collaborator, both edit the file
          <tt class="filename">sandwich.txt</tt> at the same time.  Sally
          commits her changes, and when you go to update your working
          copy, you get a conflict and we're going to have to edit
          <tt class="filename">sandwich.txt</tt> to resolve the conflicts.
          First, let's take a look at the file:</p><pre class="screen">
$ cat sandwich.txt
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
Creole Mustard
Bottom piece of bread
</pre><p>The strings of less-than signs, equal signs, and
          greater-than signs are conflict markers, and are not part of
          the actual data in conflict.  You generally want to ensure
          that those are removed from the file before your next
          commit.  The text between the first two sets of markers is
          composed of the changes you made in the conflicting
          area:</p><pre class="screen">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; .mine
Salami
Mortadella
Prosciutto
=======
</pre><p>The text between the second and third sets of conflict
          markers is the text from Sally's commit:</p><pre class="screen">
=======
Sauerkraut
Grilled Chicken
&gt;&gt;&gt;&gt;&gt;&gt;&gt; .r2
</pre><p>Usually you won't want to just delete the conflict
          markers and Sally's changes&#8212;she's going to be awfully
          surprised when the sandwich arrives and it's not what she
          wanted.  So this is where you pick up the phone or walk
          across the office and explain to Sally that you can't get
          sauerkraut from an Italian deli.<sup>[<a name="id896780" href="#ftn.id896780">5</a>]</sup> Once you've agreed on the changes
          you will check in, edit your file and remove the conflict
          markers.</p><pre class="screen">
Top piece of bread
Mayonnaise
Lettuce
Tomato
Provolone
Salami
Mortadella
Prosciutto
Creole Mustard
Bottom piece of bread
</pre><p>Now run <span><b class="command">svn resolved</b></span>, and you're
          ready to commit your changes:</p><pre class="screen">
$ svn resolved sandwich.txt
$ svn commit -m "Go ahead and use my sandwich, discarding Sally's edits."
</pre><p>Remember, if you ever get confused while editing the
          conflicted file, you can always consult the three files that
          Subversion creates for you in your working
          copy&#8212;including your file as it was before you updated.
          You can even use a third-party interactive merging tool to
          examine those three files.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.4.2"></a>Copying a File Onto Your Working File</h4></div></div><div></div></div><p>If you get a conflict and decide that you want to throw
          out your changes, you can merely copy one of the temporary
          files created by Subversion over the file in your working
          copy:</p><pre class="screen">
$ svn update
C  sandwich.txt
Updated to revision 2.
$ ls sandwich.*
sandwich.txt  sandwich.txt.mine  sandwich.txt.r2  sandwich.txt.r1
$ cp sandwich.txt.r2 sandwich.txt
$ svn resolved sandwich.txt
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-5.4.3"></a>Punting: Using <span><b class="command">svn revert</b></span></h4></div></div><div></div></div><p>If you get a conflict, and upon examination decide that
          you want to throw out your changes and start your edits
          again, just revert your changes:</p><pre class="screen">
$ svn revert sandwich.txt
Reverted 'sandwich.txt'
$ ls sandwich.*
sandwich.txt
</pre><p>Note that when you revert a conflicted file, you don't
          have to run <span><b class="command">svn resolved</b></span>.</p></div><p>Now you're ready to check in your changes.  Note that
        <span><b class="command">svn resolved</b></span>, unlike most of the other
        commands we've dealt with in this chapter, requires an
        argument.  In any case, you want to be careful and only run
        <span><b class="command">svn resolved</b></span> when you're certain that you've
        fixed the conflict in your file&#8212;once the temporary files
        are removed, Subversion will let you commit the file even if
        it still contains conflict markers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-5.5"></a>Commit Your Changes</h3></div></div><div></div></div><p>Finally!  Your edits are finished, you've merged all
        changes from the server, and you're ready to commit your
        changes to the repository.</p><p>The <span><b class="command">svn commit</b></span> command sends all of
        your changes to the repository.  When you commit a change, you
        need to supply a <i class="firstterm">log message</i>,
        describing your change.  Your log message will be attached to
        the new revision you create.  If your log message is brief,
        you may wish to supply it on the command line using the
        <tt class="option">--message</tt> (or <tt class="option">-m</tt>)
        option:</p><pre class="screen">
$ svn commit --message "Corrected number of cheese slices."
Sending        sandwich.txt
Transmitting file data .
Committed revision 3.
</pre><p>However, if you've been composing your log message as you
        work, you may want to tell Subversion to get the message from
        a file by passing the filename with the
        <tt class="option">--file</tt> switch:</p><pre class="screen">
$ svn commit --file logmsg 
Sending        sandwich.txt
Transmitting file data .
Committed revision 4.
</pre><p>If you fail to specify either the
        <tt class="option">--message</tt> or <tt class="option">--file</tt> switch,
        then Subversion will automatically launch your favorite editor
        (see the <tt class="literal">editor-cmd</tt> section in
        <a href="#svn-ch-7-sect-1.3.2" title="Config">the section called &#8220;Config&#8221;</a>) for composing a log
        message.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>If you're in your editor writing a commit message and
          decide that you want to cancel your commit, you can just
          quit your editor without saving changes.  If you've already
          saved your commit message, simply delete the text and save
          again.</p><pre class="screen">
$ svn commit
Waiting for Emacs...Done

Log message unchanged or not specified
a)bort, c)ontinue, e)dit
a
$
</pre></div><p>The repository doesn't know or care if your changes make
        any sense as a whole; it only checks to make sure that nobody
        else has changed any of the same files that you did when you
        weren't looking.  If somebody <span class="emphasis"><em>has</em></span> done
        that, the entire commit will fail with a message informing you
        that one or more of your files is out-of-date:</p><pre class="screen">
$ svn commit --message "Add another rule"
Sending        rules.txt
svn: Commit failed (details follow):
svn: Out of date: 'rules.txt' in transaction 'g'
</pre><p>At this point, you need to run <span><b class="command">svn
        update</b></span>, deal with any merges or conflicts that
        result, and attempt your commit again.</p><p>That covers the basic work cycle for using Subversion.
        There are many other features in Subversion that you can use
        to manage your repository and working copy, but you can get by
        quite easily using only the commands that we've discussed so
        far in this chapter.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-6"></a>Examining History</h2></div></div><div></div></div><p>As we mentioned earlier, the repository is like a time
      machine.  It keeps a record of every change ever committed,
      and allows you to explore this history by examining previous
      versions of files and directories as well as the metadata that
      accompanies them.  With a single Subversion command, you can
      check out the repository (or restore an existing working copy)
      exactly as it was at any date or revision number in the past.
      However, sometimes you just want to <span class="emphasis"><em>peer
      into</em></span> the past instead of <span class="emphasis"><em>going
      into</em></span> the past.</p><p>There are several commands that can provide you with
      historical data from the repository:</p><div class="variablelist"><dl><dt><span class="term"><span><b class="command">svn log</b></span></span></dt><dd><p>Shows you broad information: log messages attached
              to revisions, and which paths changed in each
              revision.</p></dd><dt><span class="term"><span><b class="command">svn diff</b></span></span></dt><dd><p>Shows you the specific details of how a file changed
              over time.</p></dd><dt><span class="term"><span><b class="command">svn cat</b></span></span></dt><dd><p>This is used to retrieve any file as it existed in a
              particular revision number and display it on your
              screen.</p></dd><dt><span class="term"><span><b class="command">svn list</b></span></span></dt><dd><p>Displays the files in a directory for any given
              revision.</p></dd></dl></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-6.1"></a><span><b class="command">svn log</b></span></h3></div></div><div></div></div><p>To find information about the history of a file or
        directory, use the <span><b class="command">svn log</b></span>
        command. <span><b class="command">svn log</b></span> will provide you with a
        record of who made changes to a file or directory, at what
        revision it changed, the time and date of that revision, and,
        if it was provided, the log message that accompanied the
        commit.</p><pre class="screen">
$ svn log
------------------------------------------------------------------------
r3 | sally | Mon, 15 Jul 2002 18:03:46 -0500 | 1 line

Added include lines and corrected # of cheese slices.
------------------------------------------------------------------------
r2 | harry | Mon, 15 Jul 2002 17:47:57 -0500 | 1 line

Added main() methods.
------------------------------------------------------------------------
r1 | sally | Mon, 15 Jul 2002 17:40:08 -0500 | 1 line

Initial import
------------------------------------------------------------------------
</pre><p>Note that the log messages are printed in
        <span class="emphasis"><em>reverse chronological order</em></span> by default.
        If you wish to see a different range of revisions in a
        particular order, or just a single revision, pass the
        <tt class="option">--revision</tt> (<tt class="option">-r</tt>)
        switch:</p><pre class="screen">
$ svn log --revision 5:19    # shows logs 5 through 19 in chronological order

$ svn log -r 19:5            # shows logs 5 through 19 in reverse order

$ svn log -r 8               # shows log for revision 8
</pre><p>You can also examine the log history of a single file or
        directory.  For example:</p><pre class="screen">
$ svn log foo.c
&#8230;
$ svn log http://foo.com/svn/trunk/code/foo.c
&#8230;
</pre><p>These will display log messages <span class="emphasis"><em>only</em></span>
        for those revisions in which the working file (or URL)
        changed.</p><p>If you want even more information about a file or
        directory, <span><b class="command">svn log</b></span> also takes a
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) switch.
        Because Subversion allows you to move and copy files and
        directories, it is important to be able to track path changes
        in the filesystem, so in verbose mode, <span><b class="command">svn
        log</b></span> will include a list of changed paths in a
        revision in its output:</p><pre class="screen">
$ svn log -r 8 -v
------------------------------------------------------------------------
r8 | sally | 2002-07-14 08:15:29 -0500 | 1 line
Changed paths:
M /trunk/code/foo.c
M /trunk/code/bar.h
A /trunk/code/doc/README

Frozzled the sub-space winch.

------------------------------------------------------------------------
</pre><div class="sidebar"><p class="title"><b>Why Does <span><b class="command">svn log</b></span> Give Me an Empty
          Response?</b></p><p>After working with Subversion for a bit, most users will
          come across something like this:</p><pre class="screen">
$ svn log -r 2
------------------------------------------------------------------------
$
</pre><p>At first glance, this seems like an error.  But recall
          that while revisions are repository-wide, <span><b class="command">svn
          log</b></span> operates on a path in the repository.  If you
          supply no path, Subversion uses the current working
          directory as the default target.  As a result, if you're
          operating in a subdirectory of your working copy and attempt
          to see the log of a revision in which neither that directory
          nor any of its children was changed, Subversion will show you
          an empty log.  If you want to see what changed in that
          revision, try pointing <span><b class="command">svn log</b></span> directly at
          the top-most URL of your repository, as in <span><b class="command">svn log -r 2
          http://svn.collab.net/repos/svn</b></span>.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-6.2"></a>svn diff</h3></div></div><div></div></div><p>We've already seen <span><b class="command">svn diff</b></span>
        before&#8212;it displays file differences in unified diff
        format; it was used to show the local modifications made to
        our working copy before committing to the repository.</p><p>In fact, it turns out that there are
        <span class="emphasis"><em>three</em></span> distinct uses of <span><b class="command">svn
        diff</b></span>:</p><div class="itemizedlist"><ul type="disc"><li><p>Examine local changes</p></li><li><p>Compare your working copy to the repository</p></li><li><p>Compare repository to repository</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-6.2.1"></a>Examining Local Changes</h4></div></div><div></div></div><p>As we've seen, invoking <span><b class="command">svn diff</b></span> with
          no switches will compare your working files to the cached
          &#8220;<span class="quote">pristine</span>&#8221; copies in
          the <tt class="filename">.svn</tt> area:</p><pre class="screen">
$ svn diff
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-6.2.2"></a>Comparing Working Copy to Repository</h4></div></div><div></div></div><p>If a single <tt class="option">--revision</tt>
          (<tt class="option">-r</tt>) number is passed, then your
          working copy is compared to the specified revision in the
          repository.</p><pre class="screen">
$ svn diff --revision 3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 3)
+++ rules.txt	(working copy)
@@ -1,4 +1,5 @@
 Be kind to others
 Freedom = Responsibility
 Everything in moderation
-Chew with your mouth open
+Chew with your mouth closed
+Listen when others are speaking
$
</pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-3-sect-6.2.3"></a>Comparing Repository to Repository</h4></div></div><div></div></div><p>If two revision numbers, separated by a colon, are
          passed via <tt class="option">--revision</tt>
          (<tt class="option">-r</tt>), then the two revisions are directly
          compared.</p><pre class="screen">
$ svn diff --revision 2:3 rules.txt 
Index: rules.txt
===================================================================
--- rules.txt	(revision 2)
+++ rules.txt	(revision 3)
@@ -1,4 +1,4 @@
 Be kind to others
-Freedom = Chocolate Ice Cream
+Freedom = Responsibility
 Everything in moderation
 Chew with your mouth open
$
</pre><p>Not only can you use <span><b class="command">svn diff</b></span> to
          compare files in your working copy to the repository, but if
          you supply a URL argument, you can examine the differences
          between items in the repository without even having a
          working copy.  This is especially useful if you wish to
          inspect changes in a file when you don't have a working copy
          on your local machine:</p><pre class="screen">
$ svn diff --revision 4:5 http://svn.red-bean.com/repos/example/trunk/text/rules.txt
&#8230;
$
</pre></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-6.3"></a><span><b class="command">svn cat</b></span></h3></div></div><div></div></div><p>If you want to examine an earlier version of a file and
        not necessarily the differences between two files, you can use
        <span><b class="command">svn cat</b></span>:</p><pre class="screen">
$ svn cat --revision 2 rules.txt 
Be kind to others
Freedom = Chocolate Ice Cream
Everything in moderation
Chew with your mouth open
$
</pre><p>You can also redirect the output directly into a
        file:</p><pre class="screen">
$ svn cat --revision 2 rules.txt &gt; rules.txt.v2
$
</pre><p>You're probably wondering why we don't just use
        <span><b class="command">svn update --revision</b></span> to update the file to
        the older revision.  There are a few reasons why we might
        prefer to use <span><b class="command">svn cat</b></span>.</p><p>First, you may want to see the differences between two
        revisions of a file using an external diff program (perhaps a
        graphical one, or perhaps your file is in such a format that
        the output of unified diff is nonsensical).  In this case,
        you'll need to grab a copy of the old revision, redirect it to
        a file, and pass both that and the file in your working copy
        to your external diff program.</p><p>Sometimes it's easier to look at an older version of a
        file in its entirety as opposed to just the differences
        between it and another revision.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-6.4"></a><span><b class="command">svn list</b></span></h3></div></div><div></div></div><p>The <span><b class="command">svn list</b></span> command shows you what
        files are in a repository directory without actually
        downloading the files to your local machine:</p><pre class="screen">
$ svn list http://svn.collab.net/repos/svn
README
branches/
clients/
tags/
trunk/
</pre><p>If you want a more detailed listing, pass the
        <tt class="option">--verbose</tt> (<tt class="option">-v</tt>) flag to get
        output like this:</p><pre class="screen">
$ svn list --verbose http://svn.collab.net/repos/svn
   2755 harry          1331 Jul 28 02:07 README
   2773 sally               Jul 29 15:07 branches/
   2769 sally               Jul 29 12:07 clients/
   2698 harry               Jul 24 18:07 tags/
   2785 sally               Jul 29 19:07 trunk/
</pre><p>The columns tell you the revision at which the file or
        directory was last modified, the user who modified it, the size
        if it is a file, the date it was last modified, and the item's
        name.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-6.5"></a>A Final Word on History</h3></div></div><div></div></div><p>In addition to all of the above commands, you can use
        <span><b class="command">svn update</b></span> and <span><b class="command">svn
        checkout</b></span> with the <tt class="option">--revision</tt> switch
        to take an entire working copy &#8220;<span class="quote">back in time</span>&#8221;
        <sup>[<a name="id897970" href="#ftn.id897970">6</a>]</sup>:</p><pre class="screen">
$ svn checkout --revision 1729 # Checks out a new working copy at r1729
&#8230;
$ svn update --revision 1729 # Updates an existing working copy to r1729
&#8230;
</pre></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-7"></a>Other Useful Commands</h2></div></div><div></div></div><p>While not as frequently used as the commands previously
        discussed in this chapter, you will occasionally need these
        commands.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-7.1"></a><span><b class="command">svn cleanup</b></span></h3></div></div><div></div></div><p>When Subversion modifies your working copy (or any
        information within <tt class="filename">.svn</tt>), it tries to do
        so as safely as possible.  Before changing the working copy,
        Subversion writes its intentions to a log file. Next it executes
        the commands in the log file to apply the requested change.
        Finally, Subversion removes the log file. Architecturally, this
        is similar to a journaled filesystem.  If a Subversion operation is
        interrupted (if the process is killed, or if the machine
        crashes, for example), the log files remain on disk.  By
        re-executing the log files, Subversion can complete the
        previously started operation, and your working copy can get
        itself back into a consistent state.</p><p>And this is exactly what <span><b class="command">svn cleanup</b></span>
        does: it searches your working copy and runs any leftover
        logs, removing locks in the process.  If Subversion ever tells
        you that some part of your working copy is
        &#8220;<span class="quote">locked</span>&#8221;, then this is the command that you
        should run.  Also, <span><b class="command">svn status</b></span> will display
        an <tt class="literal">L</tt> next to locked items:</p><pre class="screen">
$ svn status
  L    somedir
M      somedir/foo.c 

$ svn cleanup
$ svn status
M      somedir/foo.c
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-3-sect-7.3"></a><span><b class="command">svn import</b></span></h3></div></div><div></div></div><p>The <span><b class="command">svn import</b></span> command is a quick way
        to copy an unversioned tree of files into a repository,
        creating intermediate directories as necessary.</p><pre class="screen">
$ svnadmin create /usr/local/svn/newrepos
$ svn import mytree file:///usr/local/svn/newrepos/some/project
Adding         mytree/foo.c
Adding         mytree/bar.c
Adding         mytree/subdir
Adding         mytree/subdir/quux.h

Committed revision 1.
</pre><p>The previous example copied the contents of directory
        <tt class="filename">mytree</tt> under the directory
        <tt class="filename">some/project</tt> in the repository:</p><pre class="screen">
$ svn list file:///usr/local/svn/newrepos/some/project
bar.c
foo.c
subdir/
</pre><p>Note that after the import is finished, the original tree
        is <span class="emphasis"><em>not</em></span> converted into a working copy.  To
        start working, you still need to <span><b class="command">svn
        checkout</b></span> a fresh working copy of the tree.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-3-sect-8"></a>Summary</h2></div></div><div></div></div><p>Now we've covered most of the Subversion client commands.
        Notable exceptions are those dealing with branching and
        merging (see <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>) and properties (see
        <a href="#svn-ch-7-sect-2" title="Properties">the section called &#8220;Properties&#8221;</a>). However, you may want to
        take a moment to skim through <a href="#svn-ch-9" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a> to
        get an idea of all the many different commands that Subversion
        has&#8212;and how you can use them to make your work
        easier.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id895273" href="#id895273">2</a>] </sup>Of course, nothing is ever totally
              deleted from the repository&#8212;just from the
              <tt class="literal">HEAD</tt> of the repository.  You can get
              back anything you delete by checking out (or updating
              your working copy) a revision earlier than the one in
              which you deleted it.</p></div><div class="footnote"><p><sup>[<a name="ftn.id896311" href="#id896311">3</a>] </sup>Subversion uses its internal diff
          engine, which produces unified diff format, by default.  If
          you want diff output in a different format, specify an
          external diff program using <tt class="option">--diff-cmd</tt> and
          pass any flags you'd like to it using the
          <tt class="option">--extensions</tt> switch.  For example, to see
          local differences in file <tt class="filename">foo.c</tt> in
          context output format while ignoring whitespace changes, you
          might run <span><b class="command">svn diff --diff-cmd /usr/bin/diff
          --extensions '-bc' foo.c</b></span>.</p></div><div class="footnote"><p><sup>[<a name="ftn.id896971" href="#id896971">4</a>] </sup>You can always remove the temporary
        files yourself, but would you really want to do that when
        Subversion can do it for you?  We didn't think so.</p></div><div class="footnote"><p><sup>[<a name="ftn.id896780" href="#id896780">5</a>] </sup>And if you
          ask them for it, they may very well ride you out of town on
          a rail.</p></div><div class="footnote"><p><sup>[<a name="ftn.id897970" href="#id897970">6</a>] </sup>See?  We told you that Subversion was a time
        machine.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-4"></a>Chapter 4. Branching and Merging</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-4-sect-1">What's a Branch?</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-2">Using Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-2.1">Creating a Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.2">Working with Your Branch</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-2.3">The Key Concepts Behind Branches</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-3">Copying Changes Between Branches</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-3.1">Copying Specific Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-3.2">Best Practices for Merging</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.1">Tracking Merges Manually</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.2">Previewing Merges</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.3">Merge Conflicts</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-3.2.4">Noticing or Ignoring Ancestry</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-4">Common Use-Cases</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-4.1">Merging a Whole Branch to Another</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.2">Undoing Changes</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.3">Resurrecting Deleted Items</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-4.4">Common Branching Patterns</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-4-sect-4.4.1">Release Branches</a></span></dt><dt><span class="sect3"><a href="#svn-ch-4-sect-4.4.2">Feature Branches</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-5">Switching a Working Copy</a></span></dt><dt><span class="sect1"><a href="#svn-ch-4-sect-6">Tags</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-6.1">Creating a Simple Tag</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-6.2">Creating a Complex Tag</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-7">Branch Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-4-sect-7.1">Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-4-sect-7.2">Data Lifetimes</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-4-sect-8">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</p><p>Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<a href="#svn-ch-2" title="Chapter 2. Basic Concepts">Chapter 2, <i>Basic Concepts</i></a>).</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-1"></a>What's a Branch?</h2></div></div><div></div></div><p>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      &#8220;<span class="quote">tweaked</span>&#8221; for them, since they do things slightly
      differently.</p><p>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</p><p>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</p><p>This is the basic concept of a
      <i class="firstterm">branch</i>&#8212;namely, a line of
      development that exists independently of another line, yet still
      shares a common history if you look far enough back in time.  A
      branch always begins life as a copy of something, and moves on
      from there, generating its own history (see <a href="#svn-ch-4-dia-1" title="Figure 4.1. Branches of development">Figure 4.1, &#8220;Branches of development&#8221;</a>).</p><div class="figure"><a name="svn-ch-4-dia-1"></a><p class="title"><b>Figure 4.1. Branches of development</b></p><div><img src="images/ch04dia1.png" alt="Branches of development"></div></div><p>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      &#8220;<span class="quote">mix and match</span>&#8221; different lines of development in
      your daily work.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-2"></a>Using Branches</h2></div></div><div></div></div><p>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a &#8220;<span class="quote">revision</span>&#8221;)
      in the repository.  If not, go back and read about revisions in
      <a href="#svn-ch-2-sect-3.2" title="Revisions">the section called &#8220;Revisions&#8221;</a>.</p><p>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <tt class="filename">paint</tt> and <tt class="filename">calc</tt>.
      Notice that in <a href="#svn-ch-4-dia-2" title="Figure 4.2. Starting repository layout">Figure 4.2, &#8220;Starting repository layout&#8221;</a>, however, each
      project directory now contains subdirectories named
      <tt class="filename">trunk</tt> and <tt class="filename">branches</tt>.
      The reason for this will soon become clear.</p><div class="figure"><a name="svn-ch-4-dia-2"></a><p class="title"><b>Figure 4.2. Starting repository layout</b></p><div><img src="images/ch04dia2.png" alt="Starting repository layout"></div></div><p>As before, assume that Sally and you both have working
      copies of the &#8220;<span class="quote">calc</span>&#8221; project.  Specifically, you
      each have a working copy of <tt class="filename">/calc/trunk</tt>.
      All the files for the project are in this subdirectory rather
      than in <tt class="filename">/calc</tt> itself, because your team has
      decided that <tt class="filename">/calc/trunk</tt> is where the
      &#8220;<span class="quote">main line</span>&#8221; of development is going to take
      place.</p><p>Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to write, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project (in
      <tt class="filename">/calc/trunk</tt>) is always usable.  If you
      start committing your changes bit-by-bit, you'll surely break
      things for Sally.</p><p>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <tt class="filename">/calc/trunk</tt> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  By that
      same token, it's difficult to share your changes-in-progress
      with anyone else.  A common software development &#8220;<span class="quote">best
      practice</span>&#8221; is to allow your peers to review your work as you
      go.  If nobody sees your intermediate commits, you lose
      potential feedback.  Finally, when you're finished with all your
      changes, you might find it very difficult to re-merge your final
      work with the rest of the company's main body of code.  Sally
      (or others) may have made many other changes in the repository
      that are difficult to incorporate into your working
      copy&#8212;especially if you run <span><b class="command">svn update</b></span>
      after weeks of isolation.</p><p>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.1"></a>Creating a Branch</h3></div></div><div></div></div><p>Creating a branch is very simple&#8212;you make a copy of
        the project in the repository using the <span><b class="command">svn
        copy</b></span> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <tt class="filename">/calc/trunk</tt> directory.  Where should the
        new copy live?  Wherever you wish&#8212;it's a matter of
        project policy.  Let's say that your team has a policy of
        creating branches in the <tt class="filename">/calc/branches</tt>
        area of the repository, and you want to name your branch
        <tt class="literal">my-calc-branch</tt>.  You'll want to create a
        new directory,
        <tt class="filename">/calc/branches/my-calc-branch</tt>, which
        begins its life as a copy of
        <tt class="filename">/calc/trunk</tt>.</p><p>There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the project's
        root directory, <tt class="filename">/calc</tt>:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc bigwc
A  bigwc/trunk/
A  bigwc/trunk/Makefile
A  bigwc/trunk/integer.c
A  bigwc/trunk/button.c
A  bigwc/branches/
Checked out revision 340.
</pre><p>Making a copy is now simply a matter of passing two
        working-copy paths to the <span><b class="command">svn copy</b></span>
        command:</p><pre class="screen">
$ cd bigwc
$ svn copy trunk branches/my-calc-branch
$ svn status
A  +   branches/my-calc-branch
</pre><p>In this case, the <span><b class="command">svn copy</b></span> command
        recursively copies the <tt class="filename">trunk</tt> working
        directory to a new working directory,
        <tt class="filename">branches/my-calc-branch</tt>.  As you can see
        from the <span><b class="command">svn status</b></span> command, the new
        directory is now scheduled for addition to the repository.
        But also notice the &#8220;<span class="quote">+</span>&#8221; sign next to the letter
        A.  This indicates that the scheduled addition is a
        <span class="emphasis"><em>copy</em></span> of something, not something new.
        When you commit your changes, Subversion will create
        <tt class="filename">/calc/branches/my-calc-branch</tt> in the
        repository by copying <tt class="filename">/calc/trunk</tt>, rather
        than resending all of the working copy data over the
        network:</p><pre class="screen">
$ svn commit -m "Creating a private branch of /calc/trunk."
Adding         branches/my-calc-branch
Committed revision 341.
</pre><p>And now the easier method of creating a branch, which we
        should have told you about in the first place: <span><b class="command">svn
        copy</b></span> is able to operate directly on two URLs.</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
      -m "Creating a private branch of /calc/trunk."

Committed revision 341.
</pre><p>There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <tt class="filename">/calc/trunk</tt>.  This is shown in <a href="#svn-ch-4-dia-3" title="Figure 4.3. Repository with new copy">Figure 4.3, &#8220;Repository with new copy&#8221;</a>.  Notice that the second method,
        however, performs an <span class="emphasis"><em>immediate</em></span> commit.
        <sup>[<a name="id903462" href="#ftn.id903462">7</a>]</sup>
        It's an easier procedure, because it doesn't require you to
        check out a large mirror of the repository.  In fact, this
        technique doesn't even require you to have a working copy at
        all.</p><div class="figure"><a name="svn-ch-4-dia-3"></a><p class="title"><b>Figure 4.3. Repository with new copy</b></p><div><img src="images/ch04dia3.png" alt="Repository with new copy"></div></div><div class="sidebar"><p class="title"><b>Cheap Copies</b></p><p>Subversion's repository has a special design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge&#8212;Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <span class="emphasis"><em>existing</em></span> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be
          &#8220;<span class="quote">lazy</span>&#8221;.  That is, if you commit a change to one
          file within the copied directory, then only that file
          changes&#8212;the rest of the files continue to exist as
          links to the original files in the original
          directory.</p><p>This is why you'll often hear Subversion users talk
          about &#8220;<span class="quote">cheap copies</span>&#8221;.  It doesn't matter how
          large the directory is&#8212;it takes a very tiny, constant
          amount of time to make a copy of it.  In fact, this feature
          is the basis of how commits work in Subversion: each
          revision is a &#8220;<span class="quote">cheap copy</span>&#8221; of the previous
          revision, with a few items lazily changed within.  (To read
          more about this, visit Subversion's website and read about
          the &#8220;<span class="quote">bubble up</span>&#8221; method in Subversion's design
          documents.)</p><p>Of course, these internal mechanics of copying and
          sharing data are hidden from the user, who simply sees
          copies of trees.  The main point here is that copies are
          cheap, both in time and space.  Make branches as often as
          you want.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.2"></a>Working with Your Branch</h3></div></div><div></div></div><p>Now that you've created a branch of the project, you can
        check out a new working copy to start using it:</p><pre class="screen">
$ svn checkout http://svn.example.com/repos/calc/branches/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</pre><p>There's nothing special about this working copy; it simply
        mirrors a different directory in the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <tt class="filename">/calc/trunk</tt>.  (Be sure to read <a href="#svn-ch-4-sect-5" title="Switching a Working Copy">the section called &#8220;Switching a Working Copy&#8221;</a> later in this chapter: the
        <span><b class="command">svn switch</b></span> command is an alternate way of
        creating a working copy of a branch.)</p><p>Let's pretend that a week goes by, and the following
        commits happen:</p><div class="itemizedlist"><ul type="disc"><li><p>
          You make a change to
          <tt class="filename">/calc/branches/my-calc-branch/button.c</tt>,
          which creates revision 342.</p></li><li><p>
          You make a change to
          <tt class="filename">/calc/branches/my-calc-branch/integer.c</tt>,
          which creates revision 343.</p></li><li><p>
          Sally makes a change to
          <tt class="filename">/calc/trunk/integer.c</tt>, which creates
          revision 344.</p></li></ul></div><p>There are now two independent lines of development, shown
        in <a href="#svn-ch-4-dia-4" title="Figure 4.4. The branching of one file's history">Figure 4.4, &#8220;The branching of one file's history&#8221;</a>, happening on
        <tt class="filename">integer.c</tt>.</p><div class="figure"><a name="svn-ch-4-dia-4"></a><p class="title"><b>Figure 4.4. The branching of one file's history</b></p><div><img src="images/ch04dia4.png" alt="The branching of one file's history"></div></div><p>Things get interesting when you look at the history of
        changes made to your copy of
        <tt class="filename">integer.c</tt>:</p><pre class="screen">
$ pwd
/home/user/my-calc-branch

$ svn log --verbose integer.c
------------------------------------------------------------------------
r343 | user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/branches/my-calc-branch/integer.c

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

Creating a private branch of /calc/trunk.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Notice that Subversion is tracing the history of your
        branch's <tt class="filename">integer.c</tt> all the way back
        through time, even traversing the point where it was copied.
        It shows the creation of the branch as an event in the
        history, because <tt class="filename">integer.c</tt> was implicitly
        copied when all of <tt class="filename">/calc/trunk/</tt> was
        copied.  Now look what happens when Sally runs the same
        command on her copy of the file:</p><pre class="screen">
$ pwd
/home/sally/calc

$ svn log --verbose integer.c
------------------------------------------------------------------------
r344 | sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
r303 | sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  changed a docstring.

------------------------------------------------------------------------
r98 | sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines
Changed paths:
   M /calc/trunk/integer.c

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</pre><p>Sally sees her own revision 344 change, but not the change
        you made in revision 343.  As far as Subversion is concerned,
        these two commits affected different files in different
        repository locations.  However, Subversion
        <span class="emphasis"><em>does</em></span> show that the two files share a
        common history.  Before the branch-copy was made in revision
        341, they used to be the same file.  That's why you and Sally
        both see the changes made in revisions 303 and 98.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-2.3"></a>The Key Concepts Behind Branches</h3></div></div><div></div></div><p>There are two important lessons that you should remember
        from this section.</p><div class="orderedlist"><ol type="1"><li><p>Unlike many other version control systems,
            Subversion's branches exist as <span class="emphasis"><em>normal filesystem
            directories</em></span> in the repository, not in an extra
            dimension.  These directories just happen to carry some
            extra historical information.</p></li><li><p>Subversion has no internal concept of a
            branch&#8212;only copies.  When you copy a directory, the
            resulting directory is only a &#8220;<span class="quote">branch</span>&#8221;
            because <span class="emphasis"><em>you</em></span> attach that meaning to
            it.  You may think of the directory differently, or treat
            it differently, but to Subversion it's just an ordinary
            directory that happens to have been created by
            copying.</p></li></ol></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-3"></a>Copying Changes Between Branches</h2></div></div><div></div></div><p>Now you and Sally are working on parallel branches of the
      project: you're working on a private branch, and Sally is
      working on the <i class="firstterm">trunk</i>, or main line of
      development.</p><p>For projects that have a large number of contributors, it's
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p><p>So, the good news is that you and Sally aren't interfering
      with each other.  The bad news is that it's very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the &#8220;<span class="quote">crawl in a hole</span>&#8221; strategy is
      that by the time you're finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</p><p>Instead, you and Sally might continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      &#8220;<span class="quote">copy</span>&#8221; changes between branches.  And when you're
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-3.1"></a>Copying Specific Changes</h3></div></div><div></div></div><p>In the previous section, we mentioned that both you and
        Sally made changes to <tt class="filename">integer.c</tt> on
        different branches.  If you look at Sally's log message for
        revision 344, you can see that she fixed some spelling errors.
        No doubt, your copy of the same file still has the same spelling
        errors.  It's likely that your future changes to this file will
        be affecting the same areas that have the spelling errors, so
        you're in for some potential conflicts when you merge your
        branch someday.  It's better, then, to receive Sally's change
        now, <span class="emphasis"><em>before</em></span> you start working too heavily
        in the same places.</p><p>It's time to use the <span><b class="command">svn merge</b></span> command.
        This command, it turns out, is a very close cousin to the
        <span><b class="command">svn diff</b></span> command (which you read about in
        Chapter 3).  Both commands are able to compare any two objects
        in the repository and describe the differences.  For example,
        you can ask <span><b class="command">svn diff</b></span> to show you the exact
        change made by Sally in revision 344:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info-&gt;operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info-&gt;operating_system, "Macintosh"); break;
     case 8:  sprintf(info-&gt;operating_system, "Z-System"); break;
-    case 9:  sprintf(info-&gt;operating_system, "CPM"); break;
+    case 9:  sprintf(info-&gt;operating_system, "CP/M"); break;
     case 10:  sprintf(info-&gt;operating_system, "TOPS-20"); break;
     case 11:  sprintf(info-&gt;operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info-&gt;operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info-&gt;extra_header = (unsigned char *) my_malloc(total);
     fread(info-&gt;extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info-&gt;data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info-&gt;data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</pre><p>The <span><b class="command">svn merge</b></span> command is almost exactly
        the same.  Instead of printing the differences to your
        terminal, however, it applies them directly to your working
        copy as <span class="emphasis"><em>local modifications</em></span>:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c
</pre><p>The output of <span><b class="command">svn merge</b></span> shows that your
        copy of <tt class="filename">integer.c</tt> was patched.  It now
        contains Sally's change&#8212;the change has been
        &#8220;<span class="quote">copied</span>&#8221; from the trunk to your working copy of
        your private branch, and now exists as a local modification.
        At this point, it's up to you to review the local modification
        and make sure it works correctly.</p><p>In another scenario, it's possible that things may not have
        gone so well, and that <tt class="filename">integer.c</tt> may have
        entered a conflicted state.  You might need to resolve the
        conflict using standard procedures (see Chapter 3), or if you
        decide that the merge was a bad idea altogether, simply give up
        and <span><b class="command">svn revert</b></span> the local change.</p><p>But assuming that you've reviewed the merged change, you can
        <span><b class="command">svn commit</b></span> the change as usual.  At that
        point, the change has been merged into your repository branch.
        In version control terminology, this act of copying changes
        between branches is commonly called
        <i class="firstterm">porting</i> changes.</p><p>When you commit the local modification, make sure your log
        message mentions that you're porting a specific change from
        one branch to another.  For example:</p><pre class="screen">
$ svn commit -m "integer.c: ported r344 (spelling fixes) from trunk."
Sending        integer.c
Transmitting file data .
Committed revision 360.
</pre><p>As you'll see in the next sections, this is a very
        important &#8220;<span class="quote">best practice</span>&#8221; to follow.</p><div class="sidebar"><p class="title"><b>Why Not Use Patches Instead?</b></p><p>A question may be on your mind, especially if you're a
          Unix user: why bother to use <span><b class="command">svn merge</b></span> at
          all?  Why not simply use the operating system's
          <span><b class="command">patch</b></span> command to accomplish the same job?
          For example:</p><pre class="screen">
$ svn diff -r 343:344 http://svn.example.com/repos/calc/trunk &gt; patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</pre><p>In this particular case, yes, there really is no
          difference.  But <span><b class="command">svn merge</b></span> has special
          abilities that surpass the <span><b class="command">patch</b></span> program.
          The file format used by <span><b class="command">patch</b></span> is quite
          limited; it's only able to tweak file contents.  There's no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  If Sally's change had, say, added a new
          directory, the output of <span><b class="command">svn diff</b></span>
          wouldn't have mentioned it at all.  <span><b class="command">svn
          diff</b></span> only outputs the limited patch-format, so
          there are some ideas it simply can't express.
          <sup>[<a name="id904118" href="#ftn.id904118">8</a>]</sup>
          The <span><b class="command">svn merge</b></span> command, however, can express
          tree-changes by directly applying them to your working
          copy.</p></div><p>A word of warning: while <span><b class="command">svn diff</b></span> and
        <span><b class="command">svn merge</b></span> are very similar in concept, they
        do have different syntax in many cases.  Be sure to read about
        them in Chapter 9 for details, or ask <span><b class="command">svn
        help</b></span>.  For example, <span><b class="command">svn merge</b></span>
        requires a working-copy path as a target, i.e. a place where
        it should apply the tree-changes.  If the target isn't
        specified, it assumes you are trying to perform one of the
        following common operations:</p><div class="orderedlist"><ol type="1"><li><p>You want to merge directory changes into your current
            working directory.</p></li><li><p>You want to merge the changes in a specific file into
            a file by the same name which exists in your current working 
            directory.</p></li></ol></div><p>If you are merging a directory and haven't specified a
        target path, <span><b class="command">svn merge</b></span> assumes the first case
        above and tries to apply the changes into your current
        directory.  If you are merging a file, and that file (or a file
        by the same name) exists in your current working directory,
        <span><b class="command">svn merge</b></span> assumes the second case and tries
        to apply the changes to a local file with the same name.</p><p>If you want changes applied somewhere else, you'll
        need to say so.  For example, if you're sitting in the parent
        directory of your working copy, you'll have to specify the
        target directory to receive the changes:</p><pre class="screen">
$ svn merge -r 343:344 http://svn.example.com/repos/calc/trunk my-calc-branch
U   my-calc-branch/integer.c
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-3.2"></a>Best Practices for Merging</h3></div></div><div></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-3.2.1"></a>Tracking Merges Manually</h4></div></div><div></div></div><p>Merging changes sounds simple enough, but in practice it
          can become a headache.  The problem is that if you
          repeatedly merge changes from one branch to another, you
          might accidentally merge the same change
          <span class="emphasis"><em>twice</em></span>.  When this happens, sometimes
          things will work fine.  When patching a file, Subversion
          typically notices if the file already has the change, and
          does nothing.  But if the already-existing change has been
          modified in any way, you'll get a conflict.</p><p>Ideally, your version control system should prevent the
          double-application of changes to a branch.  It should
          automatically remember which changes a branch has already
          received, and be able to list them for you.  It should use
          this information to help automate merges as much as
          possible.</p><p>Unfortunately, Subversion is not such a system.  Like
          CVS, Subversion does not yet record any information about
          merge operations.  When you commit local modifications, the
          repository has no idea whether those changes came from
          running <span><b class="command">svn merge</b></span>, or from just
          hand-editing the files.</p><p>What does this mean to you, the user?  It means that
          until the day Subversion grows this feature, you'll have to
          track merge information yourself.  The best place to do this
          is in the commit log-message.  As demonstrated in the
          earlier example, it's recommended that your log-message
          mention a specific revision number (or range of revisions)
          that are being merged into your branch.  Later on, you can
          run <span><b class="command">svn log</b></span> to review which changes your
          branch already contains.  This will allow you to carefully
          construct a subsequent <span><b class="command">svn merge</b></span> command
          that won't be redundant with previously ported
          changes.</p><p>In the next section, we'll show some examples of this
          technique in action.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-3.2.2"></a>Previewing Merges</h4></div></div><div></div></div><p>Because merging only results in local modifications,
          it's not usually a high-risk operation.  If you get the
          merge wrong the first time, simply <span><b class="command">svn
          revert</b></span> the changes and try again.</p><p>It's possible, however, that your working copy might
          already have local modifications.  The changes applied by a
          merge will be mixed with your pre-existing ones, and running
          <span><b class="command">svn revert</b></span> is no longer an option.  The
          two sets of changes may be impossible to separate.</p><p>In cases like this, people take comfort in being able to
          predict or examine merges before they happen.  One simple
          way to do that is to run <span><b class="command">svn diff</b></span> with
          the same arguments you plan to pass to <span><b class="command">svn
          merge</b></span>, as we already showed in our first example
          of merging.  Another method of previewing is to pass the
          <tt class="option">--dry-run</tt> option to the merge
          command:</p><pre class="screen">
$ svn merge --dry-run -r 343:344 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
#  nothing printed, working copy is still unchanged.
</pre><p>The <tt class="option">--dry-run</tt> option doesn't actually
          apply any local changes to the working copy.  It only shows
          status codes that <span class="emphasis"><em>would</em></span> be printed in a
          real merge.  It's useful for getting a &#8220;<span class="quote">high
          level</span>&#8221; preview of the potential merge, for those
          times when running <span><b class="command">svn diff</b></span> gives too
          much detail.</p></div><div class="sidebar"><p class="title"><b>Subversion and Changesets</b></p><p>Everyone seems to have a slightly different definition
          of &#8220;<span class="quote">changeset</span>&#8221;, or a least a different
          expectation of what it means for a version control system to
          have &#8220;<span class="quote">changeset features</span>&#8221;.  For our purpose,
          let's say that a changeset is just a collection of changes
          with a unique name.  The changes might include textual edits
          to file contents, modifications to tree structure, or tweaks
          to metadata.  In more common speak, a changeset is just a
          patch with a name you can refer to.</p><p>In Subversion, a global revision number N names a tree
          in the repository: it's the way the repository looked after
          the Nth commit.  It's also the name of an implicit
          changeset: if you compare tree N with tree N-1, you can
          derive the exact patch that was committed.  For this reason,
          it's easy to think of &#8220;<span class="quote">revision N</span>&#8221; as not just
          a tree, but a changeset as well.  If you use an issue
          tracker to manage bugs, you can use the revision numbers to
          refer to particular patches that fix bugs&#8212;for example,
          &#8220;<span class="quote">this issue was fixed by revision 9238.</span>&#8221;.
          Somebody can then run <span><b class="command">svn log -r9238</b></span> to
          read about the exact changeset which fixed the bug, and run
          <span><b class="command">svn diff -r9237:9238</b></span> to see the patch
          itself.  And Subversion's merge command also uses revision
          numbers.  You can merge specific changesets from one branch
          to another by naming them in the merge arguments:
          <span><b class="command">svn merge -r9237:9238</b></span> would merge
          changeset #9238 into your working copy.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-3.2.3"></a>Merge Conflicts</h4></div></div><div></div></div><p>Just like the <span><b class="command">svn update</b></span> command,
          <span><b class="command">svn merge</b></span> applies changes to your working
          copy.  And therefore it's also capable of creating
          conflicts.  The conflicts produced by <span><b class="command">svn
          merge</b></span>, however, are sometimes different, and this
          section explains those differences.</p><p>To begin with, assume that your working copy has no
          local edits.  When you <span><b class="command">svn update</b></span> to a
          particular revision, the changes sent by the server will
          always apply &#8220;<span class="quote">cleanly</span>&#8221; to your working copy.
          The server produces the delta by comparing two trees: a
          virtual snapshot of your working copy, and the revision tree
          you're interested in.  Because the left-hand side of the
          comparison is exactly equal to what you already have, the
          delta is guaranteed to correctly convert your working copy
          into the right-hand tree.</p><p>But <span><b class="command">svn merge</b></span> has no such guarantees
          and can be much more chaotic: the user can ask the server to
          compare <span class="emphasis"><em>any</em></span> two trees at all, even ones
          that are unrelated to the working copy!  This means there's
          large potential for human error.  Users will sometimes
          compare the wrong two trees, creating a delta that doesn't
          apply cleanly.  <span><b class="command">svn merge</b></span> will do its
          best to apply has much of the delta as possible, but some
          parts may be impossible.  Just like the Unix
          <span><b class="command">patch</b></span> command sometimes complains about
          &#8220;<span class="quote">failed hunks</span>&#8221;, <span><b class="command">svn merge</b></span>
          will complain about &#8220;<span class="quote">skipped targets</span>&#8221;:</p><pre class="screen">
$ svn merge -r 1288:1351 http://svn.example.com/repos/branch
U  foo.c
U  bar.c
Skipped missing target: 'baz.c'
U  glub.c
C  glorb.h

$
</pre><p>In the previous example it might be the case that
          <tt class="filename">baz.c</tt> exists in both snapshots of the
          branch being compared, and the resulting delta wants to
          change the file's contents, but the file doesn't exist in
          the working copy.  Whatever the case, the
          &#8220;<span class="quote">skipped</span>&#8221; message means that the user is most
          likely comparing the wrong two trees; they're the classic
          sign of driver error.  When this happens, it's easy to
          recursively revert all the changes created by the merge
          (<span><b class="command">svn revert --recursive</b></span>), delete any
          unversioned files or directories left behind after the
          revert, and re-run <span><b class="command">svn merge</b></span> with
          different arguments.</p><p>Also notice that the previous example shows a conflict
          happening on <tt class="filename">glorb.h</tt>.  We already
          stated that the working copy has no local edits: how can a
          conflict possibly happen?  Again, because the user can use
          <span><b class="command">svn merge</b></span> to define and apply any old
          delta to the working copy, that delta may contain textual
          changes that don't cleanly apply to a working file, even if
          the file has no local modifications.</p><p>Another small difference between <span><b class="command">svn
          update</b></span> and <span><b class="command">svn merge</b></span> are the
          names of the full-text files created when a conflict
          happens.  In <a href="#svn-ch-3-sect-5.4" title="Resolve Conflicts (Merging Others' Changes)">the section called &#8220;Resolve Conflicts (Merging Others' Changes)&#8221;</a>, we saw
          that an update produces files named
          <tt class="filename">filename.mine</tt>,
          <tt class="filename">filename.rOLDREV</tt>, and
          <tt class="filename">filename.rNEWREV</tt>.  When <span><b class="command">svn
          merge</b></span> produces a conflict, though, it creates
          three files named <tt class="filename">filename.working</tt>,
          <tt class="filename">filename.left</tt>, and
          <tt class="filename">filename.right</tt>.  In this case, the
          terms &#8220;<span class="quote">left</span>&#8221; and &#8220;<span class="quote">right</span>&#8221; are
          describing which side of the double-tree comparison the file
          came from.  In any case, these differing names will help you
          distinguish between conflicts that happened as a result of an
          update versus ones that happened as a result of a
          merge.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-3.2.4"></a>Noticing or Ignoring Ancestry</h4></div></div><div></div></div><p>When conversing with a Subversion developer, you might
          very likely hear reference to the term
          <i class="firstterm">ancestry</i>.  This word is used to
          describe the relationship between two objects in a
          repository: if they're related to each other, then one
          object is said to be an ancestor of the other.</p><p>For example, suppose you commit revision 100, which
          includes a change to a file <tt class="filename">foo.c</tt>.
          Then <tt class="filename">foo.c@99</tt> is an
          &#8220;<span class="quote">ancestor</span>&#8221; of <tt class="filename">foo.c@100</tt>.
          On the other hand, suppose you commit the deletion of
          <tt class="filename">foo.c</tt> in revision 101, and then add a
          new file by the same name in revision 102.  In this case,
          <tt class="filename">foo.c@99</tt> and
          <tt class="filename">foo.c@102</tt> may appear to be related
          (they have the same path), but in fact are completely
          different objects in the repository.  They share no history
          or &#8220;<span class="quote">ancestry</span>&#8221;.</p><p>The reason for bringing this up is to point out an
          important difference between <span><b class="command">svn diff</b></span> and
          <span><b class="command">svn merge</b></span>.  The former command ignores
          ancestry, while the latter command is quite sensitive to it.
          For example, if you asked <span><b class="command">svn diff</b></span> to
          compare revisions 99 and 102 of <tt class="filename">foo.c</tt>,
          you would see line-based diffs; the diff command is blindly
          comparing two paths.  But if you asked <span><b class="command">svn
          merge</b></span> to compare the same two objects, it would
          notice that they're unrelated and first attempt to delete
          the old file, then add the new file;  you would see a
          <tt class="literal">D  foo.c</tt> followed by a <tt class="literal">A
          foo.c</tt>.</p><p>Most merges involve comparing trees that are ancestrally
          related to one another, and therefore <span><b class="command">svn
          merge</b></span> defaults to this behavior.  Occasionally,
          however, you may want the merge command to compare two
          unrelated trees.  For example, you may have imported two
          source-code trees representing different vendor releases of
          a software project (see <a href="#svn-ch-7-sect-4" title="Vendor branches">the section called &#8220;Vendor branches&#8221;</a>).
          If you asked <span><b class="command">svn merge</b></span> to compare the two
          trees, you'd see the entire first tree being deleted,
          followed by an add of the entire second tree!</p><p>In these situations, you'll want <span><b class="command">svn
          merge</b></span> to do a path-based comparison only, ignoring
          any relations between files and directories.  Add the
          <tt class="option">--ignore-ancestry</tt> option to your merge
          command, and it will behave just like <span><b class="command">svn
          diff</b></span>.  (And conversely, the
          <tt class="option">--notice-ancestry</tt> option will cause
          <span><b class="command">svn diff</b></span> to behave like the merge
          command.)</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-4"></a>Common Use-Cases</h2></div></div><div></div></div><p>There are many different uses for branching and <span><b class="command">svn
      merge</b></span>, and this section describes the most common ones
      you're likely to run into.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-4.1"></a>Merging a Whole Branch to Another</h3></div></div><div></div></div><p>To complete our running example, we'll move forward in
        time.  Suppose several days have passed, and many changes have
        happened on both the trunk and your private branch.  Suppose
        that you've finished working on your private branch; the
        feature or bug fix is finally complete, and now you want to
        merge all of your branch changes back into the trunk for
        others to enjoy.</p><p>So how do we use <span><b class="command">svn merge</b></span> in this
        scenario?  Remember that this command compares two trees, and
        applies the differences to a working copy.  So to receive the
        changes, you need to have a working copy of the trunk.  We'll
        assume that either you still have your original one lying
        around (fully updated), or that you recently checked out a
        fresh working copy of <tt class="filename">/calc/trunk</tt>.</p><p>But which two trees should be compared?  At first glance,
        the answer may seem obvious: just compare the latest trunk
        tree with your latest branch tree.  But beware&#8212;this
        assumption is <span class="emphasis"><em>wrong</em></span>, and has burned many
        a new user!  Since <span><b class="command">svn merge</b></span> operates like
        <span><b class="command">svn diff</b></span>, comparing the latest trunk and 
        branch trees will <span class="emphasis"><em>not</em></span> merely describe
        the set of changes you made to your branch.  Such a comparison
        shows too many changes: it would not only show the addition of
        your branch changes, but also the <span class="emphasis"><em>removal</em></span>
        of trunk changes that never happened on your branch.</p><p>To express only the changes that happened on your branch,
        you need to compare the initial state of your branch to its
        final state.  Using <span><b class="command">svn log</b></span> on your branch,
        you can see that your branch was created in revision 341.  And
        the final state of your branch is simply a matter of using the
        <tt class="literal">HEAD</tt> revision.  That means you want to
        compare revisions 341 and <tt class="literal">HEAD</tt> of your
        branch directory, and apply those differences to a working
        copy of the trunk.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>A nice way of finding the revision in which a branch was
          created (the &#8220;<span class="quote">base</span>&#8221; of the branch) is to use the
          <tt class="option">--stop-on-copy</tt> option to <span><b class="command">svn
          log</b></span>.  The log subcommand will normally show every
          change ever made to the branch, including tracing back
          through the copy which created the branch.  So normally,
          you'll see history from the trunk as well.  The
          <tt class="option">--stop-on-copy</tt> will halt log output as soon
          as <span><b class="command">svn log</b></span> detects that its target was
          copied or renamed.</p><p>So in our continuing example,</p><pre class="screen">
$ svn log --verbose --stop-on-copy \
          http://svn.example.com/repos/calc/branches/my-calc-branch
&#8230;
------------------------------------------------------------------------
r341 | user | 2002-11-03 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines
Changed paths:
   A /calc/branches/my-calc-branch (from /calc/trunk:340)

$
</pre><p>As expected, the final revision printed by this command
          is the revision in which <tt class="filename">my-calc-branch</tt>
          was created by copying.</p></div><p>Here's the final merging procedure, then:</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 405.

$ svn merge -r 341:HEAD http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn status
M   integer.c
M   button.c
M   Makefile

# ...examine the diffs, compile, test, etc...

$ svn commit -m "Merged my-calc-branch changes r341:405 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 406.
</pre><p>Again, notice that the commit log message very
        specifically mentions the range of changes that was merged
        into the trunk.  Always remember to do this, because it's
        critical information you'll need later on.</p><p>For example, suppose you decide to keep working on your
        branch for another week, in order to complete an enhancement
        to your original feature or bug fix.  The repository's
        <tt class="literal">HEAD</tt> revision is now 480, and you're ready
        to do another merge from your private branch to the trunk.
        But as discussed in <a href="#svn-ch-4-sect-3.2" title="Best Practices for Merging">the section called &#8220;Best Practices for Merging&#8221;</a>, you
        don't want to merge the changes you've already merged before;
        you only want to merge everything &#8220;<span class="quote">new</span>&#8221; on your
        branch since the last time you merged.  The trick is to figure
        out what's new.</p><p>The first step is to run <span><b class="command">svn log</b></span> on the
        trunk, and look for a log message about the last time you
        merged from the branch:</p><pre class="screen">
$ cd calc/trunk
$ svn log
&#8230;
------------------------------------------------------------------------
r406 | user | 2004-02-08 11:17:26 -0600 (Sun, 08 Feb 2004) | 1 line

Merged my-calc-branch changes r341:405 into the trunk.
------------------------------------------------------------------------
&#8230;
</pre><p>Aha!  Since all branch-changes that happened between
        revisions 341 and 405 were previously merged to the trunk as
        revision 406, you now know that you want to merge only the
        branch changes after that&#8212;by comparing revisions 406 and
        <tt class="literal">HEAD</tt>.</p><pre class="screen">
$ cd calc/trunk
$ svn update
At revision 480.

# We notice that HEAD is currently 480, so we use it to do the merge:

$ svn merge -r 406:480 http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile

$ svn commit -m "Merged my-calc-branch changes r406:480 into the trunk."
Sending        integer.c
Sending        button.c
Sending        Makefile
Transmitting file data ...
Committed revision 481.
</pre><p>Now the trunk contains the complete second wave of changes
        made to the branch.  At this point, you can either delete your
        branch (we'll discuss this later on), or continue working on
        your branch and repeat this procedure for subsequent
        merges.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-4.2"></a>Undoing Changes</h3></div></div><div></div></div><p>Another common use for <span><b class="command">svn merge</b></span> is to
        roll back a change that has already been committed.  Suppose
        you're working away happily on a working copy of
        <tt class="filename">/calc/trunk</tt>, and you discover that the
        change made way back in revision 303, which changed
        <tt class="filename">integer.c</tt>, is completely wrong.  It never
        should have been committed.  You can use <span><b class="command">svn
        merge</b></span> to &#8220;<span class="quote">undo</span>&#8221; the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <span class="emphasis"><em>reverse</em></span> difference:</p><pre class="screen">
$ svn merge -r 303:302 http://svn.example.com/repos/calc/trunk
U  integer.c

$ svn status
M  integer.c

$ svn diff
&#8230;
# verify that the change is removed
&#8230;

$ svn commit -m "Undoing change committed in r303."
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre><p>One way to think about a repository revision is as a
        specific group of changes (some version control systems call
        these <i class="firstterm">changesets</i>).  By using the
        <tt class="option">-r</tt> switch, you can ask <span><b class="command">svn
        merge</b></span> to apply a changeset, or whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we're asking <span><b class="command">svn merge</b></span> to apply
        changeset #303 to our working copy
        <span class="emphasis"><em>backwards</em></span>.</p><p>Keep in mind that rolling back a change like this is just
        like any other <span><b class="command">svn merge</b></span> operation, so you
        should use <span><b class="command">svn status</b></span> and <span><b class="command">svn
        diff</b></span> to confirm that your work is in the state you
        want it to be in, and then use <span><b class="command">svn commit</b></span>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <tt class="literal">HEAD</tt> revision.</p><p>Again, you may be thinking: well, that really didn't undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <tt class="filename">calc</tt> project between revisions 303 and
        349, they'll still see the bad change, right?</p><p>Yes, that's true.  When we talk about
        &#8220;<span class="quote">removing</span>&#8221; a change, we're really talking about
        removing it from <tt class="literal">HEAD</tt>.  The original change
        still exists in the repository's history.  For most
        situations, this is good enough.  Most people are only
        interested in tracking the <tt class="literal">HEAD</tt> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn't so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees which build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.
        <sup>[<a name="id905394" href="#ftn.id905394">9</a>]</sup>
      </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-4.3"></a>Resurrecting Deleted Items</h3></div></div><div></div></div><p>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <tt class="literal">HEAD</tt>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, &#8220;<span class="quote">How
        do I get my old file or directory back?</span>&#8221;</p><p>The first step is to define exactly <span class="bold"><b>which</b></span> item you're trying to resurrect.
        Here's a useful metaphor: you can think of every object in the
        repository as existing in a sort of two-dimensional coordinate
        system.  The first coordinate is a particular revision tree,
        and the second coordinate is a path within that tree.  So
        every version of your file or directory can be defined by a
        specific coordinate pair.</p><p>Subversion has no <tt class="filename">Attic</tt> directory
        like CVS does,
        <sup>[<a name="id905466" href="#ftn.id905466">10</a>]</sup>
        so you need to use <span><b class="command">svn
        log</b></span> to discover the exact coordinate pair you wish
        to resurrect.  A good strategy is to run <span><b class="command">svn log
        --verbose</b></span> in a directory which used to contain your
        deleted item.  The <tt class="option">--verbose</tt> option shows a
        list of all changed items in each revision; all you need to do
        is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <span><b class="command">grep</b></span>, or
        perhaps via an incremental search in an editor).</p><pre class="screen">
$ cd parent-dir
$ svn log --verbose
&#8230;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c

Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&#8230;
</pre><p>In the example, we're assuming that you're looking for a
        deleted file <tt class="filename">real.c</tt>.  By looking through
        the logs of a parent directory, you've spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <tt class="filename">/calc/trunk/real.c</tt> from revision
        807.</p><p>That was the hard part&#8212;the research.  Now that you
        know what you want to restore, you have two different
        choices.</p><p>One option is to use <span><b class="command">svn merge</b></span> to apply
        revision 808 &#8220;<span class="quote">in reverse</span>&#8221;.  (We've already
        discussed how to undo changes, see <a href="#svn-ch-4-sect-4.2" title="Undoing Changes">the section called &#8220;Undoing Changes&#8221;</a>.)  This would have the effect of
        re-adding <tt class="filename">real.c</tt> as a local modification.
        The file would be scheduled for addition, and after a commit,
        the file would again exist in <tt class="literal">HEAD</tt>.</p><p>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <tt class="filename">real.c</tt> for addition, but
        the log message indicates that it would also undo certain
        changes to <tt class="filename">integer.c</tt>, which you don't
        want.  Certainly, you could reverse-merge revision 808 and
        then <span><b class="command">svn revert</b></span> the local modifications to
        <tt class="filename">integer.c</tt>, but this technique doesn't
        scale well.  What if there were 90 files changed in revision
        808?</p><p>A second, more targeted strategy is not to use
        <span><b class="command">svn merge</b></span> at all, but rather the
        <span><b class="command">svn copy</b></span> command.  Simply copy the exact
        revision and path &#8220;<span class="quote">coordinate pair</span>&#8221; from the
        repository to your working copy:</p><pre class="screen">
$ svn copy --revision 807 \
           http://svn.example.com/repos/calc/trunk/real.c ./real.c

$ svn status
A  +   real.c

$ svn commit -m "Resurrected real.c from revision 807, /calc/trunk/real.c."
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre><p>The plus sign in the status output indicates that the item
        isn't merely scheduled for addition, but scheduled for
        addition &#8220;<span class="quote">with history</span>&#8221;. Subversion remembers
        where it was copied from.  In the future, running <span><b class="command">svn
        log</b></span> on this file will traverse back through the
        file's resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <tt class="filename">real.c</tt> isn't really new; it's a direct
        descendant of the original, deleted file.</p><p>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-4.4"></a>Common Branching Patterns</h3></div></div><div></div></div><p>Version control is most often used for software
        development, so here's a quick peek at two of the most common
        branching/merging patterns used by teams of programmers.  If
        you're not using Subversion for software development, feel
        free to skip this section.  If you're a software developer
        using version control for the first time, pay close attention,
        as these patterns are often considered best practices by
        experienced folk.  These processes aren't specific to
        Subversion; they're applicable to any version control system.
        Still, it may help to see them described in Subversion
        terms.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-4.4.1"></a>Release Branches</h4></div></div><div></div></div><p>Most software has a typical lifecycle: code, test,
          release, repeat.  There are two problems with this process.
          First, developers need to keep writing new features while
          quality-assurance teams take time to test supposedly-stable
          versions of the software.  New work cannot halt while the
          software is tested.  Second, the team almost always needs to
          support older, released versions of software; if a bug is
          discovered in the latest code, it most likely exists in
          released versions as well, and customers will want to get
          that bugfix without having to wait for a major new
          release.</p><p>Here's where version control can help.  The typical
          procedure looks like this:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Developers commit all new work to the
                trunk.</em></span>

              Day-to-day changes are committed to
              <tt class="filename">/trunk</tt>: new features, bugfixes, and
              so on.</p></li><li><p><span class="emphasis"><em>The trunk is copied to a
                &#8220;<span class="quote">release</span>&#8221; branch.</em></span>

              When the team thinks the software is ready for release
              (say, a 1.0 release), then <tt class="filename">/trunk</tt>
              might be copied to
              <tt class="filename">/branches/1.0</tt>.</p></li><li><p><span class="emphasis"><em>Teams continue to work in parallel.</em></span>

              One team begins rigorous testing of the release branch,
              while another team continues new work (say, for version
              2.0) on <tt class="filename">/trunk</tt>.  If bugs are
              discovered in either location, fixes are ported back and
              forth as necessary.  At some point, however, even that
              process stops.  The branch is &#8220;<span class="quote">frozen</span>&#8221; for
              final testing right before a release.</p></li><li><p><span class="emphasis"><em>The branch is tagged and released.</em></span>

              When testing is complete,
              <tt class="filename">/branches/1.0</tt> is copied to
              <tt class="filename">/tags/1.0.0</tt> as a reference
              snapshot.  The tag is packaged and released to
              customers.</p></li><li><p><span class="emphasis"><em>The branch is maintained over time.</em></span>

              While work continues on <tt class="filename">/trunk</tt> for
              version 2.0, bugfixes continue to be ported from
              <tt class="filename">/trunk</tt> to
              <tt class="filename">/branches/1.0</tt>.  When enough
              bugfixes have accumulated, management may decide to do a
              1.0.1 release: <tt class="filename">/branches/1.0</tt> is
              copied to <tt class="filename">/tags/1.0.1</tt>, and the tag
              is packaged and released.</p></li></ul></div><p>This entire process repeats as the software matures:
          when the 2.0 work is complete, a new 2.0 release branch is
          created, tested, tagged, and eventually released.  After
          some years, the repository ends up with a number of release
          branches in &#8220;<span class="quote">maintenance</span>&#8221; mode , and a number
          of tags representing final shipped versions.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-4-sect-4.4.2"></a>Feature Branches</h4></div></div><div></div></div><p>A <i class="firstterm">feature branch</i> is the sort of
          branch that's been the dominant example in this chapter, the
          one you've been working on while Sally continues to work on
          <tt class="filename">/trunk</tt>.  It's a temporary branch
          created to work on a complex change without interfering with
          the stability of <tt class="filename">/trunk</tt>.  Unlike
          release branches (which may need to be supported forever),
          feature branches are born, used for a while, merged back to
          the trunk, then ultimately deleted.  They have a finite span
          of usefulness.</p><p>Again, project policies vary widely concerning exactly
          when it's appropriate to create a feature branch.  Some
          projects never use feature branches at all: commits to
          <tt class="filename">/trunk</tt> are a free-for-all.  The
          advantage to this system is that it's simple&#8212;nobody
          needs to learn about branching or merging.  The disadvantage
          is that the trunk code is often unstable or unusable.  Other
          projects use branches to an extreme: no change is
          <span class="emphasis"><em>ever</em></span> committed to the trunk directly.
          Even the most trivial changes are created on a short-lived
          branch, carefully reviewed and merged to the trunk.  Then
          the branch is deleted.  This system guarantees an
          exceptionally stable and usable trunk at all times, but at
          the cost of tremendous process overhead.</p><p>Most projects take a middle-of-the-road approach.  They
          commonly insist that <tt class="filename">/trunk</tt> compile and
          pass regression tests at all times.  A feature branch is
          only required when a change requires a large number of
          destabilizing commits.  A good rule of thumb is to ask this
          question: if the developer worked for days in isolation and
          then committed the large change all at once (so that
          <tt class="filename">/trunk</tt> were never destabilized), would
          it be too large a change to review?  If the answer to that
          question is &#8220;<span class="quote">yes</span>&#8221;, then the change should be
          developed on a feature branch.  As the developer commits
          incremental changes to the branch, they can be easily
          reviewed by peers.</p><p>Finally, there's the issue of how to best keep a feature
          branch in &#8220;<span class="quote">sync</span>&#8221; with the trunk as work
          progresses.  As we mentioned earlier, there's a great risk
          to working on a branch for weeks or months; trunk changes
          may continue to pour in, to the point where the two lines of
          development differ so greatly that it may become a nightmare
          trying to merge the branch back to the trunk.</p><p>This situation is best avoided by regularly merging
          trunk changes to the branch.  Make up a policy: once a week,
          merge the last week's worth of trunk changes to the branch.
          Take care when doing this; the merging needs to be
          hand-tracked to avoid the problem of repeated merges (as
          described in <a href="#svn-ch-4-sect-3.2.1" title="Tracking Merges Manually">the section called &#8220;Tracking Merges Manually&#8221;</a>).  You'll
          need to write careful log messages detailing exactly which
          revision ranges have been been merged already (as
          demonstrated in <a href="#svn-ch-4-sect-4.1" title="Merging a Whole Branch to Another">the section called &#8220;Merging a Whole Branch to Another&#8221;</a>.)  It
          may sound intimidating, but it's actually pretty easy to
          do.</p><p>At some point, you'll be ready to merge the
          &#8220;<span class="quote">synchronized</span>&#8221; feature branch back to the
          trunk.  To do this, begin by doing a final merge of the
          latest trunk changes to the branch.  When that's done, the
          latest versions of branch and trunk will be absolutely
          identical except for your branch changes.  So in this
          special case, you would merge by comparing the branch with
          the trunk:</p><pre class="screen">
$ cd trunk-working-copy

$ svn update
At revision 1910.

$ svn merge http://svn.example.com/repos/calc/trunk@1910 \
            http://svn.example.com/repos/calc/branches/mybranch@1910 \
U  real.c
U  integer.c
A  newdirectory
A  newdirectory/newfile
&#8230;
</pre><p>By comparing the <tt class="literal">HEAD</tt> revision of the
          trunk with the <tt class="literal">HEAD</tt> revision of the
          branch, you're defining a delta that describes only the
          changes you made to the branch; both lines of development
          already have all of the trunk changes.</p><p>Another way of thinking about this pattern is that your
          weekly sync of trunk to branch is analogous to running
          <span><b class="command">svn update</b></span> in a working copy, while the
          final merge step is analogous to running <span><b class="command">svn
          commit</b></span> from a working copy.  After all, what else
          <span class="emphasis"><em>is</em></span> a working copy but a very shallow
          private branch?  It's a branch that's only capable of
          storing one change at a time.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-5"></a>Switching a Working Copy</h2></div></div><div></div></div><p>The <span><b class="command">svn switch</b></span> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <tt class="filename">/calc/trunk</tt> to mirror the new branch
      location:</p><pre class="screen">
$ cd calc

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/trunk

$ svn switch http://svn.example.com/repos/calc/branches/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep URL
URL: http://svn.example.com/repos/calc/branches/my-calc-branch
</pre><p>After &#8220;<span class="quote">switching</span>&#8221; to the branch, your working
      copy is no different than what you would get from doing a fresh
      checkout of the directory.  And it's usually more efficient to
      use this command, because often branches only differ by a small
      degree.  The server sends only the minimal set of changes
      necessary to make your working copy reflect the branch
      directory.</p><p>The <span><b class="command">svn switch</b></span> command also takes a
      <tt class="option">--revision</tt> (<tt class="option">-r</tt>) option, so you
      need not always move your working copy to the &#8220;<span class="quote">tip</span>&#8221;
      of the branch.</p><p>Of course, most projects are more complicated than our
      <tt class="filename">calc</tt> example, containing multiple
      subdirectories.  Subversion users often follow a specific
      algorithm when using branches:</p><div class="orderedlist"><ol type="1"><li><p>Copy the project's entire &#8220;<span class="quote">trunk</span>&#8221; to a
            new branch directory.</p></li><li><p>Switch only <span class="emphasis"><em>part</em></span> of the trunk
            working copy to mirror the branch.</p></li></ol></div><p>In other words, if a user knows that the branch-work only
      needs to happen on a specific subdirectory, they use
      <span><b class="command">svn switch</b></span> to move only that subdirectory to
      the branch.  (Or sometimes users will switch just a single
      working file to the branch!)  That way, they can continue to
      receive normal &#8220;<span class="quote">trunk</span>&#8221; updates to most of their
      working copy, but the switched portions will remain immune
      (unless someone commits a change to their branch).  This feature
      adds a whole new dimension to the concept of a &#8220;<span class="quote">mixed
      working copy</span>&#8221;&#8212;not only can working copies contain a
      mixture of working revisions, but a mixture of repository
      locations as well.</p><p>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</p><p>Note that while it's okay for your working copy to reflect a
      mixture of repository locations, these locations must all be
      within the <span class="emphasis"><em>same</em></span> repository.  Subversion
      repositories aren't yet able to communicate with one another;
      that's a feature planned beyond Subversion
      1.0.<sup>[<a name="id906249" href="#ftn.id906249">11</a>]</sup></p><div class="sidebar"><p class="title"><b>Switches and Updates</b></p><p>Have you noticed that the output of <span><b class="command">svn
        switch</b></span> and <span><b class="command">svn update</b></span> look the
        same?  The switch command is actually a superset of the
        update command.</p><p>When you run <span><b class="command">svn update</b></span>, you're asking
        the repository to compare two trees.  The repository does so,
        and then sends a description of the differences back to the
        client. The only difference between <span><b class="command">svn
        switch</b></span> and <span><b class="command">svn update</b></span> is that the
        update command always compares two identical paths.</p><p>That is, if your working copy is a mirror of
        <tt class="filename">/calc/trunk</tt>, then <span><b class="command">svn
        update</b></span> will automatically compare your working copy
        of <tt class="filename">/calc/trunk</tt> to
        <tt class="filename">/calc/trunk</tt> in the
        <tt class="literal">HEAD</tt> revision.  If you're switching your
        working copy to a branch, then <span><b class="command">svn switch</b></span>
        will compare your working copy of
        <tt class="filename">/calc/trunk</tt> to some
        <span class="emphasis"><em>other</em></span> branch-directory in the
        <tt class="literal">HEAD</tt> revision.</p><p>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <span class="emphasis"><em>and</em></span> space.</p></div><p>Because <span><b class="command">svn switch</b></span> is essentially a
      variant of <span><b class="command">svn update</b></span>, it shares the same
      behaviors; any local modifications in your working copy are
      preserved when new data arrives from the repository.  This
      allows you to perform all sorts of clever tricks.</p><p>For example, suppose you have a working copy of
      <tt class="filename">/calc/trunk</tt> and make a number of changes to
      it.  Then you suddenly realize that you meant to make the
      changes to a branch instead.  No problem!  When you <span><b class="command">svn
      switch</b></span> your working copy to the branch, the local
      changes will remain.  You can then test and commit them to the
      branch.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-6"></a>Tags</h2></div></div><div></div></div><p>Another common version control concept is a
      <i class="firstterm">tag</i>.  A tag is just a
      &#8220;<span class="quote">snapshot</span>&#8221; of a project in time.  In Subversion,
      this idea already seems to be everywhere.  Each repository
      revision is exactly that&#8212;a snapshot of the filesystem
      after each commit.</p><p>However, people often want to give more human-friendly names
      to tags, like <tt class="literal">release-1.0</tt>.  And they want to
      make snapshots of smaller subdirectories of the filesystem.
      After all, it's not so easy to remember that release-1.0 of a
      piece of software is a particular subdirectory of revision
      4822.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-6.1"></a>Creating a Simple Tag</h3></div></div><div></div></div><p>Once again, <span><b class="command">svn copy</b></span> comes to the
        rescue.  If you want to create a snapshot of
        <tt class="filename">/calc/trunk</tt> exactly as it looks in the
        <tt class="literal">HEAD</tt> revision, then make a copy of it:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/tags/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</pre><p>This example assumes that a
        <tt class="filename">/calc/tags</tt> directory already exists.  (If it
        doesn't, see <a href="#svn-ch-9-sect-1.2-re-mkdir" title="svn mkdir">svn mkdir</a>).
        After the copy completes, the new
        <tt class="filename">release-1.0</tt> directory is forever a
        snapshot of how the project looked in the
        <tt class="literal">HEAD</tt> revision at the time you made the
        copy.  Of course you might want to be more precise about
        exactly which revision you copy, in case somebody else may
        have committed changes to the project when you weren't
        looking.  So if you know that revision 350 of
        <tt class="filename">/calc/trunk</tt> is exactly the snapshot you
        want, you can specify it by passing <tt class="option">-r 350</tt> to
        the <span><b class="command">svn copy</b></span> command.</p><p>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a &#8220;<span class="quote">tag</span>&#8221; is because
        <span class="emphasis"><em>humans</em></span> have decided to treat it that way:
        as long as nobody ever commits to the directory, it forever
        remains a snapshot.  If people start committing to it, it
        becomes a branch.</p><p>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is &#8220;<span class="quote">hands off</span>&#8221;: as a matter of project policy,
        decide where your tags will live, and make sure all users know
        how to treat the directories they copy in there.  (That is,
        make sure they know not to commit to them.)  The second
        approach is more paranoid: you can use one of the
        access-control scripts provided with Subversion to prevent
        anyone from doing anything but creating new copies in the
        tags-area (See <a href="#svn-ch-6" title="Chapter 6. Server Configuration">Chapter 6, <i>Server Configuration</i></a>.)  The paranoid
        approach, however, isn't usually necessary.  If a user
        accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-6.2"></a>Creating a Complex Tag</h3></div></div><div></div></div><p>Sometimes you may want your &#8220;<span class="quote">snapshot</span>&#8221; to be
        more complicated than a single directory at a single
        revision.</p><p>For example, pretend your project is much larger than our
        <tt class="filename">calc</tt> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bug fixes.
        You can accomplish this by selectively backdating files or
        directories to particular revisions (using <span><b class="command">svn update
        -r</b></span> liberally), or by switching files and directories
        to particular branches (making use of <span><b class="command">svn
        switch</b></span>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</p><p>Time to make a snapshot.  Copying one URL to another won't
        work here. In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, <span><b class="command">svn copy</b></span> actually has four
        different uses (which you can read about in Chapter 9),
        including the ability to copy a working-copy tree to the
        repository:</p><pre class="screen">
$ ls
my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/calc/tags/mytag

Committed revision 352.
</pre><p>Now there is a new directory in the repository,
        <tt class="filename">/calc/tags/mytag</tt>, which is an exact
        snapshot of your working copy&#8212;mixed revisions, URLs,
        and all.</p><p>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <span><b class="command">svn
        diff</b></span> and sending a patch file (which won't capture
        tree changes), you can instead use <span><b class="command">svn copy</b></span>
        to &#8220;<span class="quote">upload</span>&#8221; your working copy to a private area
        of the repository.  Your collaborator can then either checkout
        a verbatim copy of your working copy, or use <span><b class="command">svn
        merge</b></span> to receive your exact changes.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-7"></a>Branch Maintenance</h2></div></div><div></div></div><p>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <span class="emphasis"><em>too</em></span>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-7.1"></a>Repository Layout</h3></div></div><div></div></div><p>There are some standard, recommended ways to organize a
        repository.  Most people create a <tt class="filename">trunk</tt>
        directory to hold the &#8220;<span class="quote">main line</span>&#8221; of development,
        a <tt class="filename">branches</tt> directory to contain branch
        copies, and a <tt class="filename">tags</tt> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</p><pre class="screen">
/trunk
/branches
/tags
</pre><p>If a repository contains multiple projects, admins
        typically index their layout by project (see <a href="#svn-ch-5-sect-6.1" title="Choosing a Repository Layout">the section called &#8220;Choosing a Repository Layout&#8221;</a> to read more about
        &#8220;<span class="quote">project roots</span>&#8221;):</p><pre class="screen">
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</pre><p>Of course, you're free to ignore these common layouts.
        You can create any sort of variation, whatever works best for
        you or your team.  Remember that whatever you choose, it's not
        a permanent commitment.  You can reorganize your repository at
        any time.  Because branches and tags are ordinary directories,
        the <span><b class="command">svn move</b></span> command can move or rename
        them however you wish.  Switching from one layout to another
        is just a matter of issuing a series of server-side moves; if
        you don't like the way things are organized in the repository,
        just juggle the directories around.</p><p>Remember, though, that while moving directories may be
        easy to do, you need to be considerate of your users as well.
        Your juggling can be disorienting to users with existing
        working copies.  If a user has a working copy of a particular
        repository directory, your <span><b class="command">svn move</b></span>
        operation might remove the path from the latest revision.
        When the user next runs <span><b class="command">svn update</b></span>, they'll
        be told that their working copy represents a path that no
        longer exists, and the user will be forced to <span><b class="command">svn
        switch</b></span> to the new location.
        </p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-4-sect-7.2"></a>Data Lifetimes</h3></div></div><div></div></div><p>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <tt class="filename">calc</tt> project.  After merging all of your
        changes back into <tt class="filename">/calc/trunk</tt>, there's
        no need for your private branch directory to stick around
        anymore:</p><pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</pre><p>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the
        <tt class="literal">HEAD</tt> revision, no longer distracting
        anyone.  If you use <span><b class="command">svn checkout</b></span>,
        <span><b class="command">svn switch</b></span>, or <span><b class="command">svn list</b></span>
        to examine an earlier revision, you'll still be able to see
        your old branch.</p><p>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into <tt class="literal">HEAD</tt>, simply
        use <span><b class="command">svn copy -r</b></span> to copy it from the old
        revision:</p><pre class="screen">
$ svn copy -r 374 http://svn.example.com/repos/calc/branches/my-calc-branch \
                  http://svn.example.com/repos/calc/branches/my-calc-branch

Committed revision 376.
</pre><p>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two &#8220;<span class="quote">main</span>&#8221; branches running side-by-side for
        very long periods.  For example, suppose it's time to release
        a stable <tt class="filename">calc</tt> project to the public, and
        you know it's going to take a couple of months to shake bugs
        out of the software.  You don't want people to add new
        features to the project, but you don't want to tell all
        developers to stop programming either.  So instead, you create
        a &#8220;<span class="quote">stable</span>&#8221; branch of the software that won't
        change much:</p><pre class="screen">
$ svn copy http://svn.example.com/repos/calc/trunk \
         http://svn.example.com/repos/calc/branches/stable-1.0 \
         -m "Creating stable branch of calc project."

Committed revision 377.
</pre><p>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <tt class="filename">/calc/trunk</tt>, and you can declare a
        project policy that only bug fixes are to be committed to
        <tt class="filename">/calc/branches/stable-1.0</tt>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bug fixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time&#8212;that is, as long
        as you continue to support that release for customers.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-4-sect-8"></a>Summary</h2></div></div><div></div></div><p>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <span><b class="command">svn copy</b></span> command.  We've shown how
      to use <span><b class="command">svn merge</b></span> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <span><b class="command">svn switch</b></span> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</p><p>Remember the Subversion mantra: branches and tags are cheap.
      So use them liberally!</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id903462" href="#id903462">7</a>] </sup>Subversion does not support
            cross-repository copying.  When using URLs with <span><b class="command">svn
            copy</b></span> or <span><b class="command">svn move</b></span>, you can only
            copy items within the same repository.</p></div><div class="footnote"><p><sup>[<a name="ftn.id904118" href="#id904118">8</a>] </sup>In the future, the Subversion project plans to use
              (or invent) an expanded patch format that describes
              tree-changes.</p></div><div class="footnote"><p><sup>[<a name="ftn.id905394" href="#id905394">9</a>] </sup>The Subversion project has plans, however, to someday
            implement an <span><b class="command">svnadmin obliterate</b></span>
            command that would accomplish the task of permanently
            deleting information.  In the meantime, see <a href="#svn-ch-5-sect-3.1.3" title="svndumpfilter">the section called &#8220;svndumpfilter&#8221;</a> for a possible
            workaround.</p></div><div class="footnote"><p><sup>[<a name="ftn.id905466" href="#id905466">10</a>] </sup>Because CVS doesn't version trees, it creates an
            <tt class="filename">Attic</tt> area within each repository
            directory as a way of remembering deleted files.</p></div><div class="footnote"><p><sup>[<a name="ftn.id906249" href="#id906249">11</a>] </sup>You <span class="emphasis"><em>can</em></span>, however, use
      <span><b class="command">svn switch</b></span> with the
      <tt class="option">--relocate</tt> switch if the URL of your server
      changes and you don't want to abandon an existing working copy.
      See the <span><b class="command">svn switch</b></span> section in <a href="#svn-ch-9" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a> for more information and an example.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-5"></a>Chapter 5. Repository Administration</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-5-sect-1">Repository Basics</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-1.1">Understanding Transactions and Revisions</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.2">Unversioned Properties</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-1.3">Repository Data-Stores</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-5-sect-1.3.1">Berkeley DB</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-1.3.2">FSFS</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-2">Repository Creation and Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-2.1">Hook Scripts</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-2.2">Berkeley DB Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-3">Repository Maintenance</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-3.1">An Administrator's Toolkit</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.1">svnlook</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.2">svnadmin</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.3">svndumpfilter</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.4">svnshell.py</a></span></dt><dt><span class="sect3"><a href="#svn-ch-5-sect-3.1.5">Berkeley DB Utilities</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-5-sect-3.2">Repository Cleanup</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.3">Managing Disk Space</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.4">Repository Recovery</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.5">Migrating a Repository</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-3.6">Repository Backup</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-6">Adding Projects</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-5-sect-6.1">Choosing a Repository Layout</a></span></dt><dt><span class="sect2"><a href="#svn-ch-5-sect-6.2">Creating the Layout, and Importing Initial Data</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-5-sect-7">Summary</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  As such, it becomes
      an obvious candidate for all the love and attention an
      administrator can offer.  While the repository is generally a
      low-maintenance item, it is important to understand how to
      properly configure and care for it so that potential problems
      are avoided, and actual problems are safely resolved.</p><p>In this chapter, we'll discuss how to create and configure
      a Subversion repository.  We'll also talk about repository
      maintenance, including the use of the <span><b class="command">svnlook</b></span>
      and <span><b class="command">svnadmin</b></span> tools (which are provided with
      Subversion).  We'll address some common questions and mistakes,
      and give some suggestions on how to arrange the data in the
      repository.</p><p>If you plan to access a Subversion repository only in the
      role of a user whose data is under version control (that is, via
      a Subversion client), you can skip this chapter altogether.
      However, if you are, or wish to become, a Subversion repository
      administrator,
      <sup>[<a name="id929106" href="#ftn.id929106">12</a>]</sup>
      you should definitely pay attention to this chapter.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-1"></a>Repository Basics</h2></div></div><div></div></div><p>Before jumping into the broader topic of repository
      administration, let's further define what a repository is.  How
      does it look?  How does it feel?  Does it take its tea hot or
      iced, sweetened, and with lemon?  As an administrator, you'll be
      expected to understand the composition of a repository both from
      a logical perspective&#8212;dealing with how data is represented
      inside the repository&#8212;and from a physical nuts-and-bolts
      perspective&#8212;how a repository looks and acts with respect
      to non-Subversion tools.  The following section covers some of
      these basic concepts at a very high level.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-1.1"></a>Understanding Transactions and Revisions</h3></div></div><div></div></div><p>Conceptually speaking, a Subversion repository is a
        sequence of directory trees.  Each tree is a snapshot of how
        the files and directories versioned in your repository looked
        at some point in time.  These snapshots are created as a
        result of client operations, and are called revisions.</p><p>Every revision begins life as a transaction tree.  When
        doing a commit, a client builds a Subversion transaction that
        mirrors their local changes (plus any additional changes that
        might have been made to the repository since the beginning of
        the client's commit process), and then instructs the
        repository to store that tree as the next snapshot in the
        sequence.  If the commit succeeds, the transaction is
        effectively promoted into a new revision tree, and is assigned
        a new revision number.  If the commit fails for some reason,
        the transaction is destroyed and the client is informed of the
        failure.</p><p>Updates work in a similar way.  The client builds a
        temporary transaction tree that mirrors the state of the
        working copy.  The repository then compares that transaction
        tree with the revision tree at the requested revision (usually
        the most recent, or &#8220;<span class="quote">youngest</span>&#8221; tree), and sends
        back information that informs the client about what changes
        are needed to transform their working copy into a replica of
        that revision tree.  After the update completes, the temporary
        transaction is deleted.</p><p>The use of transaction trees is the only way to make
        permanent changes to a repository's versioned filesystem.
        However, it's important to understand that the lifetime of a
        transaction is completely flexible.  In the case of updates,
        transactions are temporary trees that are immediately
        destroyed.  In the case of commits, transactions are
        transformed into permanent revisions (or removed if the commit
        fails).  In the case of an error or bug, it's possible that a
        transaction can be accidentally left lying around in the
        repository (not really affecting anything, but still taking up
        space).</p><p>In theory, someday whole workflow applications might
        revolve around more fine-grained control of transaction
        lifetime.  It is feasible to imagine a system whereby each
        transaction slated to become a revision is left in stasis well
        after the client finishes describing its changes to
        repository.  This would enable each new commit to be reviewed
        by someone else, perhaps a manager or engineering QA team, who
        can choose to promote the transaction into a revision, or
        abort it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-1.2"></a>Unversioned Properties</h3></div></div><div></div></div><p>Transactions and revisions in the Subversion repository
        can have properties attached to them.  These properties are
        generic key-to-value mappings, and are generally used to store
        information about the tree to which they are attached.  The
        names and values of these properties are stored in the
        repository's filesystem, along with the rest of your tree
        data.</p><p>Revision and transaction properties are useful for
        associating information with a tree that is not strictly
        related to the files and directories in that tree&#8212;the
        kind of information that isn't managed by client working
        copies.  For example, when a new commit transaction is created
        in the repository, Subversion adds a property to that
        transaction named <tt class="literal">svn:date</tt>&#8212;a
        datestamp representing the time that the transaction was
        created.  By the time the commit process is finished, and the
        transaction is promoted to a permanent revision, the tree has
        also been given a property to store the username of the
        revision's author (<tt class="literal">svn:author</tt>) and a
        property to store the log message attached to that revision
        (<tt class="literal">svn:log</tt>).</p><p>Revision and transaction properties are
        <i class="firstterm">unversioned properties</i>&#8212;as they
        are modified, their previous values are permanently discarded.
        Also, while revision trees themselves are immutable, the
        properties attached to those trees are not.  You can add,
        remove, and modify revision properties at any time in the
        future.  If you commit a new revision and later realize that
        you had some misinformation or spelling error in your log
        message, you can simply replace the value of the
        <tt class="literal">svn:log</tt> property with a new, corrected log
        message.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-1.3"></a>Repository Data-Stores</h3></div></div><div></div></div><p>As of Subversion 1.1, there are two options for storing
        data in a Subversion repository.  One type of repository
        stores everything in a Berkeley DB database; the other kind
        stores data in ordinary flat files, using a custom
        format.  Because Subversion developers often refer to a
        repository as &#8220;<span class="quote">The [Versioned] Filesystem</span>&#8221;, they have
        adopted the habit of referring to the latter type of repository as
        <i class="firstterm">FSFS</i>: that is, it's a versioned
        filesystem implementation that uses the native OS filesystem
        to store data.</p><p>When a repository is created, an administrator must decide
        whether it will use Berkeley DB or FSFS.  There are advantages
        and disadvantages to each, which we'll describe in a bit.
        Neither back-end is more &#8220;<span class="quote">official</span>&#8221; than another,
        and programs which access the repository are insulated from
        this implementation detail.  Programs have no idea how a
        repository is storing data; they only see revision and
        transaction trees through the repository API.</p><p>Here is a table that gives a comparative overview of
        Berkeley DB and FSFS repositories.  The next sections go into
        detail.</p><div class="table"><a name="svn-ch-5-table-1"></a><p class="title"><b>Table 5.1. Repository Data-Store Comparison</b></p><table summary="Repository Data-Store Comparison" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>Berkeley DB</th><th>FSFS</th></tr></thead><tbody><tr><td>Sensitivity to interruptions</td><td>very;  crashes and permission problems can leave the
                database &#8220;<span class="quote">wedged</span>&#8221;, requiring journaled
                recovery procedures.</td><td>quite insensitive.</td></tr><tr><td>Usable from a read-only mount</td><td>no</td><td>yes</td></tr><tr><td>Platform-independent storage</td><td>no</td><td>yes</td></tr><tr><td>Usable over network filesystems</td><td>no</td><td>yes</td></tr><tr><td>Repository size</td><td>slightly larger</td><td>slightly smaller</td></tr><tr><td>Scalability: number of revision trees</td><td>database;  no problems</td><td>some older native filesystems don't scale well with
                thousands of entries in a single directory.</td></tr><tr><td>Scalability: directories with many files</td><td>slower</td><td>faster</td></tr><tr><td>Speed:  checking out latest code</td><td>faster</td><td>slower</td></tr><tr><td>Speed:  large commits</td><td>slower, but work is spread throughout commit</td><td>faster, but finalization delay may cause client
                timeouts</td></tr><tr><td>Group permissions handling</td><td>sensitive to user umask problems;  best if accessed
                by only one user.</td><td>works around umask problems</td></tr><tr><td>Code maturity</td><td>in use since 2001</td><td>in use since 2004</td></tr></tbody></table></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-1.3.1"></a>Berkeley DB</h4></div></div><div></div></div><p>When the initial design phase of Subversion was in
          progress, the developers decided to use Berkeley DB for a
          variety of reasons, including its open-source license,
          transaction support, reliability, performance, API
          simplicity, thread-safety, support for cursors, and so
          on.</p><p>Berkeley DB provides real transaction
          support&#8212;perhaps its most powerful feature.  Multiple
          processes accessing your Subversion repositories don't have
          to worry about accidentally clobbering each other's data.
          The isolation provided by the transaction system is such
          that for any given operation, the Subversion repository code
          sees a static view of the database&#8212;not a database that
          is constantly changing at the hand of some other
          process&#8212;and can make decisions based on that view.  If
          the decision made happens to conflict with what another
          process is doing, the entire operation is rolled back as if
          it never happened, and Subversion gracefully retries the
          operation against a new, updated (and yet still static) view
          of the database.</p><p>Another great feature of Berkeley DB is <i class="firstterm">hot
          backups</i>&#8212;the ability to backup the database
          environment without taking it &#8220;<span class="quote">offline</span>&#8221;.  We'll
          discuss how to backup your repository in <a href="#svn-ch-5-sect-3.6" title="Repository Backup">the section called &#8220;Repository Backup&#8221;</a>, but the benefits of being
          able to make fully functional copies of your repositories
          without any downtime should be obvious.</p><p>Berkeley DB is also a very reliable database system.
          Subversion uses Berkeley DB's logging facilities, which
          means that the database first writes to on-disk log files a
          description of any modifications it is about to make, and
          then makes the modification itself.  This is to ensure that
          if anything goes wrong, the database system can back up to
          a previous <i class="firstterm">checkpoint</i>&#8212;a
          location in the log files known not to be corrupt&#8212;and
          replay transactions until the data is restored to a usable
          state.  See <a href="#svn-ch-5-sect-3.3" title="Managing Disk Space">the section called &#8220;Managing Disk Space&#8221;</a> for more
          about Berkeley DB log files.</p><p>But every rose has its thorn, and so we must note some
          known limitations of Berkeley DB.  First, Berkeley DB
          environments are not portable.  You cannot simply copy a
          Subversion repository that was created on a Unix system onto
          a Windows system and expect it to work.  While much of the
          Berkeley DB database format is architecture independent,
          there are other aspects of the environment that are not.
          Secondly, Subversion uses Berkeley DB in a way that will not
          operate on Windows 95/98 systems&#8212;if you need to house
          a repository on a Windows machine, stick with Windows 2000
          or Windows XP.  Also, you should never keep a Berkeley DB
          repository on a network share.  While Berkeley DB promises
          to behave correctly on network shares that meet a particular
          set of specifications, almost no known shares actually meet
          all those specifications.</p><p>Finally, because Berkeley DB is a library linked
          directly into Subversion, it's more sensitive to
          interruptions than a typical relational database system.
          Most SQL systems, for example, have a dedicated server
          process that mediates all access to tables.  If a program
          accessing the database crashes for some reason, the database
          daemon notices the lost connection and clean up any mess
          left behind.  And because the database daemon is the only
          process accessing the tables, applications don't need to
          worry about permission conflicts.  These things are not the
          case with Berkeley DB, however.  Subversion (and programs
          using Subversion libraries) access the database tables
          directly, which means that a program crash can leave the
          database in a temporarily inconsistent, inaccessible state.
          When this happens, an administrator needs to ask Berkeley DB
          to restore to a checkpoint, which is a bit of an annoyance.
          Other things can cause a repository to &#8220;<span class="quote">wedge</span>&#8221;
          besides crashed processes, such as programs conflicting over
          ownership and permissions on the database files.  So while a
          BerkeleyDB repository is quite fast and scalable, it's best
          used by a single server process running as one
          user&#8212;such as Apache's <span><b class="command">httpd</b></span> or
          <span><b class="command">svnserve</b></span> (see <a href="#svn-ch-6" title="Chapter 6. Server Configuration">Chapter 6, <i>Server Configuration</i></a>)&#8212;rather than accessing it as
          many different users via <tt class="literal">file:///</tt> or
          <tt class="literal">svn+ssh://</tt> URLs.  If using a Berkeley DB
          repository directly as multiple users, be sure to read <a href="#svn-ch-6-sect-5" title="Supporting Multiple Repository Access Methods">the section called &#8220;Supporting Multiple Repository Access Methods&#8221;</a>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-1.3.2"></a>FSFS</h4></div></div><div></div></div><p>In mid-2004, a second type of repository storage system
          came into being: one which doesn't use a database at all.
          An FSFS repository stores a revision tree in a single file,
          and so all of a repository's revisions can be found in a
          single subdirectory full of numbered files.  Transactions
          are created in separate subdirectories.  When complete, a
          single transaction file is created and moved to the
          revisions directory, thus guaranteeing that commits are
          atomic.  And because a revision file is permanent and
          unchanging, the repository also can be backed up while
          &#8220;<span class="quote">hot</span>&#8221;, just like a Berkeley DB repository.</p><p>The revision-file format represents a revision's
          directory structure, file contents, and deltas against files
          in other revision trees.  Unlike a Berkeley DB database,
          this storage format is portable across different operating
          systems and isn't sensitive to CPU architecture.  Because
          there's no journaling or shared-memory files being used, the
          repository can be safely accessed over a network filesystem
          and examined in a read-only environment.  The lack of
          database overhead also means that the overall repository
          size is a bit smaller.</p><p>FSFS has different performance characteristics too.
          When committing a directory with a huge number of files, FSFS
          uses an O(N) algorithm to append entries, while Berkeley DB
          uses an O(N^2) algorithm to rewrite the whole directory.  On
          the other hand, FSFS writes the latest version of a file as
          a delta against an earlier version, which means that
          checking out the latest tree is a bit slower than fetching
          the fulltexts stored in a Berkeley DB HEAD revision.  FSFS
          also has a longer delay when finalizing a commit, which
          could in extreme cases cause clients to time-out when
          waiting for a response.</p><p>The most important distinction, however, is FSFS's
          inability to be &#8220;<span class="quote">wedged</span>&#8221; when something goes
          wrong.  If a process using a Berkeley DB database runs into
          a permissions problem or suddenly crashes, the database is
          left unusable until an administrator recovers it.  If the
          same scenarios happen to a process using an FSFS repository,
          the repository isn't affected at all.  At worst, some
          transaction data is left behind.</p><p>The only real argument against FSFS is its relative
          immaturity compared to Berkeley DB.  It hasn't been used or
          stress-tested nearly as much, and so a lot of these
          assertions about speed and scalability are just that:
          assertions, based on good guesses.  In theory, it promises a
          lower barrier to entry for new administrators and is less
          susceptible to problems.  In practice, only time will
          tell.</p></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-2"></a>Repository Creation and Configuration</h2></div></div><div></div></div><p>Creating a Subversion repository is an incredibly simple
      task.  The <span><b class="command">svnadmin</b></span> utility, provided with
      Subversion, has a subcommand for doing just that.  To create a
      new repository, just run:</p><pre class="screen">
$ svnadmin create /path/to/repos
</pre><p>This creates a new repository in the directory
      <tt class="filename">/path/to/repos</tt>.  This new repository begins
      life at revision 0, which is defined to consist of nothing but
      the top-level root (<tt class="filename">/</tt>) filesystem
      directory.  Initially, revision 0 also has a single revision
      property, <tt class="literal">svn:date</tt>, set to the time at which
      the repository was created.</p><p>In Subversion 1.1, a repository is created with a Berkeley
      DB back-end by default.  This behavior may change in future
      releases.  Regardless, the type can be explicitly chosen with
      the <tt class="option">--fs-type</tt> argument:</p><pre class="screen">
$ svnadmin create --fs-type fsfs /path/to/repos
$ svnadmin create --fs-type bdb /path/to/other/repos
</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Do not create a Berkeley DB repository on a network
        share&#8212;it <span class="emphasis"><em>cannot</em></span> exist on a remote
        filesystem such as NFS, AFS, or Windows SMB.  Berkeley DB
        requires that the underlying filesystem implement strict POSIX
        locking semantics, and more importantly, the ability to map
        files directly into process memory.  Almost no network
        filesystems provide these features.  If you attempt to use
        Berkeley DB on a network share, the results are
        unpredictable&#8212;you may see mysterious errors right away,
        or it may be months before you discover that your repository
        database is subtly corrupted.</p><p>If you need multiple computers to access the repository,
        you create an FSFS repository on the network share, not a
        Berkeley DB repository.  Or better yet, set up a real server
        process (such as Apache or <span><b class="command">svnserve</b></span>), store
        the repository on a local filesystem which the server can
        access, and make the repository available over a network.
        <a href="#svn-ch-6" title="Chapter 6. Server Configuration">Chapter 6, <i>Server Configuration</i></a> covers this process in
        detail.</p></div><p>You may have noticed that the path argument to
      <span><b class="command">svnadmin</b></span> was just a regular filesystem path
      and not a URL like the <span><b class="command">svn</b></span> client program
      uses when referring to repositories.  Both
      <span><b class="command">svnadmin</b></span> and <span><b class="command">svnlook</b></span> are
      considered server-side utilities&#8212;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even &#8220;<span class="quote">local</span>&#8221;
      <tt class="literal">file:</tt> ones) to these two programs.</p><p>So, after you've run the <span><b class="command">svnadmin create</b></span>
      command, you have a shiny new Subversion repository in its own
      directory.  Let's take a peek at what is actually created inside
      that subdirectory.</p><pre class="screen">
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README.txt
</pre><p>With the exception of the <tt class="filename">README.txt</tt> and
      <tt class="filename">format</tt> files,
      the repository directory is a collection of subdirectories.  As
      in other areas of the Subversion design, modularity is given
      high regard, and hierarchical organization is preferred to
      cluttered chaos.  Here is a brief description of all of
      the items you see in your new repository directory:</p><div class="variablelist"><dl><dt><span class="term">conf</span></dt><dd><p>A directory containing repository configuration files.</p></dd><dt><span class="term">dav</span></dt><dd><p>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</p></dd><dt><span class="term">db</span></dt><dd><p>Where all of your versioned data resides.  This
            directory is either a Berkeley DB environment (full of DB
            tables and other things), or is an FSFS environment
            containing revision files.</p></dd><dt><span class="term">format</span></dt><dd><p>A file whose contents are a single integer value that
            dictates the version number of the repository layout.</p></dd><dt><span class="term">hooks</span></dt><dd><p>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</p></dd><dt><span class="term">locks</span></dt><dd><p>A directory for Subversion's repository locking
            data, used for tracking accessors to the repository.</p></dd><dt><span class="term">README.txt</span></dt><dd><p>A file which merely informs its readers that they
            are looking at a Subversion repository.</p></dd></dl></div><p>In general, you shouldn't tamper with your repository
      &#8220;<span class="quote">by hand</span>&#8221;.  The <span><b class="command">svnadmin</b></span> tool
      should be sufficient for any changes necessary to your
      repository, or you can look to third-party tools (such as
      Berkeley DB's tool suite) for tweaking relevant subsections of
      the repository.  Some exceptions exist, though, and we'll cover
      those here.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-2.1"></a>Hook Scripts</h3></div></div><div></div></div><p>A <i class="firstterm">hook</i> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</p><p>The <tt class="filename">hooks</tt> subdirectory is, by
        default, filled with templates for various repository
        hooks.</p><pre class="screen">
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl
post-revprop-change.tmpl  start-commit.tmpl
pre-commit.tmpl           
</pre><p>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <tt class="filename">repos/hooks</tt> directory
        which can be executed as the name (like
        <span><b class="command">start-commit</b></span> or
        <span><b class="command">post-commit</b></span>) of the hook.</p><p>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&#8212;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <tt class="literal">.tmpl</tt> extension,
        customize the hook's contents, and ensure that the script is
        executable.  Windows, however, uses file extensions to
        determine whether or not a program is executable, so you would
        need to supply a program whose basename is the name of the
        hook, and whose extension is one of the special extensions
        recognized by Windows for executable programs, such as
        <tt class="filename">.exe</tt> or <tt class="filename">.com</tt> for
        programs, and <tt class="filename">.bat</tt> for batch
        files.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>For security reasons, the Subversion repository executes
        hook scripts with an empty environment&#8212;that is, no
        environment variables are set at all, not even
        <tt class="literal">$PATH</tt> or <tt class="literal">%PATH%</tt>.
        Because of this, a lot of administrators are baffled when
        their hook script runs fine by hand, but doesn't work when run
        by Subversion.  Be sure to explicitly set environment
        variables in your hook and/or use absolute paths to
        programs.</p></div><p>Currently there are five hooks implemented by the
        Subversion repository:</p><div class="variablelist"><dl><dt><span class="term"><tt class="filename">start-commit</tt></span></dt><dd><p>This is run before the commit transaction is even
              created.  It is typically used to decide if the user has
              commit privileges at all.  The repository passes two
              arguments to this program: the path to the repository,
              and username which is attempting the commit.  If the
              program returns a non-zero exit value, the commit is
              stopped before the transaction is even created.  If the
              hook program writes data to stderr, it will be
              marshalled back to the client.</p></dd><dt><span class="term"><tt class="filename">pre-commit</tt></span></dt><dd><p>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and the transaction is removed.  If the hook
              program writes data to stderr, it will be marshalled
              back to the client.</p><p>The Subversion distribution includes some access
              control scripts (located in the
              <tt class="filename">tools/hook-scripts</tt> directory of the
              Subversion source tree) that can be called from
              <span><b class="command">pre-commit</b></span> to implement fine-grained
              write-access control.  Another option is to use the
              <span><b class="command">mod_authz_svn</b></span> Apache httpd module,
              which provides both read and write access control on
              individual directories (see <a href="#svn-ch-6-sect-4.4.2" title="Per-Directory Access Control">the section called &#8220;Per-Directory Access Control&#8221;</a>).  In a future version
              of Subversion, we plan to implement access control lists
              (ACLs) directly in the filesystem.</p></dd><dt><span class="term"><tt class="filename">post-commit</tt></span></dt><dd><p>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a backup of the repository.  The repository passes two
              arguments to this program: the path to the repository,
              and the new revision number that was created.  The exit
              code of the program is ignored.</p><p>The Subversion distribution includes
              <span><b class="command">mailer.py</b></span> and
              <span><b class="command">commit-email.pl</b></span> scripts (located in
              the <tt class="filename">tools/hook-scripts/</tt> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</p><p>Another useful tool provided by Subversion is the
              <span><b class="command">hot-backup.py</b></span> script (located in the
              <tt class="filename">tools/backup/</tt> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database back-end), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</p></dd><dt><span class="term"><tt class="filename">pre-revprop-change</tt></span></dt><dd><p>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <tt class="literal">svn:log</tt> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <tt class="filename">post-revprop-change</tt>)
              so that repository administrators can keep records of
              changes to these items using some external means if
              they so desire.  As a precaution against losing
              unversioned property data, Subversion clients will not
              be allowed to remotely modify revision properties at all
              unless this hook is implemented for your repository.</p><p>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modified property exists, the
              authenticated username of the person making the change,
              and the name of the property itself.</p></dd><dt><span class="term"><tt class="filename">post-revprop-change</tt></span></dt><dd><p>As mentioned earlier, this hook is the counterpart
              of the <tt class="filename">pre-revprop-change</tt> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <tt class="filename">pre-revprop-change</tt> hook
              exists.  When both of these hooks are present, the
              <tt class="filename">post-revprop-change</tt> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and the name of
              the property itself.</p><p>The Subversion distribution includes a
              <span><b class="command">propchange-email.pl</b></span> script (located
              in the <tt class="filename">tools/hook-scripts/</tt>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</p></dd></dl></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Do not attempt to modify the transaction using hook
          scripts. A common example of this would be to automatically
          set properties such as <tt class="literal">svn:eol-style</tt> or
          <tt class="literal">svn:mime-type</tt> during the commit.  While
          this might seem like a good idea, it causes problems.  The
          main problem is that the client does not know about the
          change made by the hook script, and there is no way to
          inform the client that it is out-of-date.  This
          inconsistency can lead to surprising and unexpected
          behavior.</p><p>Instead of attempting to modify the transaction, it is
          much better to <span class="emphasis"><em>check</em></span> the transaction in
          the <tt class="filename">pre-commit</tt> hook and reject the
          commit if it does not meet the desired requirements.</p></div><p>Subversion will attempt to execute hooks as the same user
        who owns the process which is accessing the Subversion
        repository.  In most cases, the repository is being accessed
        via Apache HTTP server and mod_dav_svn, so this user is the
        same user that Apache runs as.  The hooks themselves will need
        to be configured with OS-level permissions that allow that
        user to execute them.  Also, this means that any file or
        programs (including the Subversion repository itself) accessed
        directly or indirectly by the hook will be accessed as the
        same user.  In other words, be alert to potential
        permission-related problems that could prevent the hook from
        performing the tasks you've written it to perform.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-2.2"></a>Berkeley DB Configuration</h3></div></div><div></div></div><p>A Berkeley DB environment is an encapsulation of one or
        more databases, log files, region files and configuration
        files.  The Berkeley DB environment has its own set of default
        configuration values for things like the number of locks
        allowed to be taken out at any given time, or the maximum size
        of the journaling log files, etc.  Subversion's filesystem
        code additionally chooses default values for some of the
        Berkeley DB configuration options.  However, sometimes your
        particular repository, with its unique collection of data and
        access patterns, might require a different set of
        configuration option values.</p><p>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so they have provided a mechanism for
        overriding at runtime many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence of
        a file named <tt class="filename">DB_CONFIG</tt> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley environment.</p><p>The Berkeley configuration file for your repository is
        located in the <tt class="filename">db</tt> environment directory,
        at <tt class="filename">repos/db/DB_CONFIG</tt>.  Subversion itself
        creates this file when it creates the rest of the repository.
        The file initially contains some default options, as well as
        pointers to the Berkeley DB online documentation so you can
        read about what those options do.  Of course, you are free to
        add any of the supported Berkeley DB options to your
        <tt class="filename">DB_CONFIG</tt> file.  Just be aware that while
        Subversion never attempts to read or interpret the contents of
        the file, and makes no use of the option settings in it,
        you'll want to avoid any configuration changes that may cause
        Berkeley DB to behave in a fashion that is unexpected by the
        rest of the Subversion code.  Also, changes made to
        <tt class="filename">DB_CONFIG</tt> won't take effect until you
        recover the database environment (using <span><b class="command">svnadmin
        recover</b></span>).</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-3"></a>Repository Maintenance</h2></div></div><div></div></div><p>Maintaining a Subversion repository can be a daunting task,
      mostly due to the complexities inherent in systems which have a
      database backend.  Doing the task well is all about knowing the
      tools&#8212;what they are, when to use them, and how to use
      them.  This section will introduce you to the repository
      administration tools provided by Subversion, and how to wield
      them to accomplish tasks such as repository migrations,
      upgrades, backups and cleanups.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.1"></a>An Administrator's Toolkit</h3></div></div><div></div></div><p>Subversion provides a handful of utilities useful for
        creating, inspecting, modifying and repairing your repository.
        Let's look more closely at each of those tools.  Afterward,
        we'll briefly examine some of the utilities included in the
        Berkeley DB distribution that provide functionality specific
        to your repository's database backend not otherwise provided
        by Subversion's own tools.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.1"></a>svnlook</h4></div></div><div></div></div><p><span><b class="command">svnlook</b></span> is a tool provided by
          Subversion for examining the various revisions and
          transactions in a repository.  No part of this program
          attempts to change the repository&#8212;it's a
          &#8220;<span class="quote">read-only</span>&#8221; tool.  <span><b class="command">svnlook</b></span>
          is typically used by the repository hooks for reporting the
          changes that are about to be committed (in the case of the
          <span><b class="command">pre-commit</b></span> hook) or that were just
          committed (in the case of the <span><b class="command">post-commit</b></span>
          hook) to the repository.  A repository administrator may use
          this tool for diagnostic purposes.</p><p><span><b class="command">svnlook</b></span> has a straightforward
          syntax:</p><pre class="screen">
$ svnlook help
general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]
Note: any subcommand which takes the '--revision' and '--transaction'
      options will, if invoked without one of those options, act on
      the repository's youngest revision.
Type "svnlook help &lt;subcommand&gt;" for help on a specific subcommand.
&#8230;
</pre><p>Nearly every one of <span><b class="command">svnlook</b></span>'s
          subcommands can operate on either a revision or a
          transaction tree, printing information about the tree
          itself, or how it differs from the previous revision of the
          repository.  You use the <tt class="option">--revision</tt> and
          <tt class="option">--transaction</tt> options to specify which
          revision or transaction, respectively, to examine.  Note
          that while revision numbers appear as natural numbers,
          transaction names are alphanumeric strings.  Keep in mind
          that the filesystem only allows browsing of uncommitted
          transactions (transactions that have not resulted in a new
          revision).  Most repositories will have no such
          transactions, because transactions are usually either
          committed (which disqualifies them from viewing) or aborted
          and removed.</p><p>In the absence of both the <tt class="option">--revision</tt>
          and <tt class="option">--transaction</tt> options,
          <span><b class="command">svnlook</b></span> will examine the youngest (or
          &#8220;<span class="quote">HEAD</span>&#8221;) revision in the repository.  So the
          following two commands do exactly the same thing when 19 is
          the youngest revision in the repository located at
          <tt class="filename">/path/to/repos</tt>:</p><pre class="screen">
$ svnlook info /path/to/repos
$ svnlook info /path/to/repos --revision 19
</pre><p>The only exception to these rules about subcommands is
          the <span><b class="command">svnlook youngest</b></span> subcommand, which
          takes no options, and simply prints out the
          <tt class="literal">HEAD</tt> revision number.</p><pre class="screen">
$ svnlook youngest /path/to/repos
19
</pre><p>Output from <span><b class="command">svnlook</b></span> is designed to be
          both human- and machine-parsable.  Take as an example the output
          of the <tt class="literal">info</tt> subcommand:</p><pre class="screen">
$ svnlook info /path/to/repos
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual
Greek tree.
</pre><p>The output of the <tt class="literal">info</tt> subcommand is
          defined as:</p><div class="orderedlist"><ol type="1"><li><p>The author, followed by a newline.</p></li><li><p>The date, followed by a newline.</p></li><li><p>The number of characters in the log message,
              followed by a newline.</p></li><li><p>The log message itself, followed by a newline.</p></li></ol></div><p>This output is human-readable, meaning items like the
          datestamp are displayed using a textual representation
          instead of something more obscure (such as the number of
          nanoseconds since the Tasty Freeze guy drove by).  But this
          output is also machine-parsable&#8212;because the log
          message can contain multiple lines and be unbounded in
          length, <span><b class="command">svnlook</b></span> provides the length of
          that message before the message itself.  This allows scripts
          and other wrappers around this command to make intelligent
          decisions about the log message, such as how much memory to
          allocate for the message, or at least how many bytes to skip
          in the event that this output is not the last bit of data in
          the stream.</p><p>Another common use of <span><b class="command">svnlook</b></span> is to
          actually view the contents of a revision or transaction
          tree.  The <span><b class="command">svnlook tree</b></span> command displays
          the directories and files in the requested tree.  If you
          supply the <tt class="option">--show-ids</tt> option, it will also
          show the filesystem node revision IDs for each of those
          paths (which is generally of more use to developers than to
          users).</p><pre class="screen">
$ svnlook tree /path/to/repos --show-ids
/ &lt;0.0.1&gt;
 A/ &lt;2.0.1&gt;
  B/ &lt;4.0.1&gt;
   lambda &lt;5.0.1&gt;
   E/ &lt;6.0.1&gt;
    alpha &lt;7.0.1&gt;
    beta &lt;8.0.1&gt;
   F/ &lt;9.0.1&gt;
  mu &lt;3.0.1&gt;
  C/ &lt;a.0.1&gt;
  D/ &lt;b.0.1&gt;
   gamma &lt;c.0.1&gt;
   G/ &lt;d.0.1&gt;
    pi &lt;e.0.1&gt;
    rho &lt;f.0.1&gt;
    tau &lt;g.0.1&gt;
   H/ &lt;h.0.1&gt;
    chi &lt;i.0.1&gt;
    omega &lt;k.0.1&gt;
    psi &lt;j.0.1&gt;
 iota &lt;1.0.1&gt;
</pre><p>Once you've seen the layout of directories and files in
          your tree, you can use commands like <span><b class="command">svnlook
          cat</b></span>, <span><b class="command">svnlook propget</b></span>, and
          <span><b class="command">svnlook proplist</b></span> to dig into the details
          of those files and directories.</p><p><span><b class="command">svnlook</b></span> can perform a variety of
          other queries, displaying subsets of bits of information
          we've mentioned previously, reporting which paths were
          modified in a given revision or transaction, showing textual
          and property differences made to files and directories, and
          so on.  The following is a brief description of the current
          list of subcommands accepted by <span><b class="command">svnlook</b></span>,
          and the output of those subcommands:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">author</tt></span></dt><dd><p>Print the tree's author.</p></dd><dt><span class="term"><tt class="literal">cat</tt></span></dt><dd><p>Print the contents of a file in the tree.</p></dd><dt><span class="term"><tt class="literal">changed</tt></span></dt><dd><p>List all files and directories that changed in the 
                tree.</p></dd><dt><span class="term"><tt class="literal">date</tt></span></dt><dd><p>Print the tree's datestamp.</p></dd><dt><span class="term"><tt class="literal">diff</tt></span></dt><dd><p>Print unified diffs of changed files.</p></dd><dt><span class="term"><tt class="literal">dirs-changed</tt></span></dt><dd><p>List the directories in the tree that were
                themselves changed, or whose file children were
                changed.</p></dd><dt><span class="term"><tt class="literal">history</tt></span></dt><dd><p>Display interesting points in the history of a
                versioned path (places where modifications or copies
                occurred).</p></dd><dt><span class="term"><tt class="literal">info</tt></span></dt><dd><p>Print the tree's author, datestamp, log message
                character count, and log message.</p></dd><dt><span class="term"><tt class="literal">log</tt></span></dt><dd><p>Print the tree's log message.</p></dd><dt><span class="term"><tt class="literal">propget</tt></span></dt><dd><p>Print the value of a property on a path in the
                tree.</p></dd><dt><span class="term"><tt class="literal">proplist</tt></span></dt><dd><p>Print the names and values of properties set on paths
                in the tree.</p></dd><dt><span class="term"><tt class="literal">tree</tt></span></dt><dd><p>Print the tree listing, optionally revealing the
                filesystem node revision IDs associated with each
                path.</p></dd><dt><span class="term"><tt class="literal">uuid</tt></span></dt><dd><p>Print the repository's UUID&#8212;
                <span class="emphasis"><em>U</em></span>niversal <span class="emphasis"><em>U</em></span>nique
                <span class="emphasis"><em>ID</em></span>entifier.</p></dd><dt><span class="term"><tt class="literal">youngest</tt></span></dt><dd><p>Print the youngest revision number.</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.2"></a>svnadmin</h4></div></div><div></div></div><p>The <span><b class="command">svnadmin</b></span> program is the
          repository administrator's best friend.  Besides providing
          the ability to create Subversion repositories, this program
          allows you to perform several maintenance operations on
          those repositories.  The syntax of
          <span><b class="command">svnadmin</b></span> is similar to that of
          <span><b class="command">svnlook</b></span>:</p><pre class="screen">
$ svnadmin help
general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS &amp; OPTIONS ...]
Type "svnadmin help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   create
   deltify
   dump
   help (?, h)
&#8230;
</pre><p>We've already mentioned <span><b class="command">svnadmin</b></span>'s
          <tt class="literal">create</tt> subcommand (see <a href="#svn-ch-5-sect-2" title="Repository Creation and Configuration">the section called &#8220;Repository Creation and Configuration&#8221;</a>).  Most of the others we will
          cover in more detail later in this chapter.  For now, let's
          just take a quick glance at what each of the available
          subcommands offers.</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">create</tt></span></dt><dd><p>Create a new Subversion repository.</p></dd><dt><span class="term"><tt class="literal">deltify</tt></span></dt><dd><p>Run over a specified revision range, performing
                predecessor deltification on the paths changed in
                those revisions.  If no revisions are specified, this
                command will simply deltify the
                <tt class="literal">HEAD</tt> revision.</p></dd><dt><span class="term"><tt class="literal">dump</tt></span></dt><dd><p>Dump the contents of the repository, bounded by a
                given set of revisions, using a portable dump format.</p></dd><dt><span class="term"><tt class="literal">hotcopy</tt></span></dt><dd><p>Make a hot copy of a repository.  You can run
                this command at any time and make a safe copy of the
                repository, regardless if other processes are using
                the repository.</p></dd><dt><span class="term"><tt class="literal">list-dblogs</tt></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with the
                repository.  This list includes all log
                files&#8212;those still in use by Subversion, as well
                as those no longer in use.</p></dd><dt><span class="term"><tt class="literal">list-unused-dblogs</tt></span></dt><dd><p>(Berkeley DB repositories only.)  List the paths
                of Berkeley DB log files associated with, but no
                longer used by, the repository.  You may safely remove
                these log files from the repository layout, possibly
                archiving them for use in the event that you ever need
                to perform a catastrophic recovery of the
                repository.</p></dd><dt><span class="term"><tt class="literal">load</tt></span></dt><dd><p>Load a set of revisions into a repository from a
                stream of data that uses the same portable dump format
                generated by the <tt class="literal">dump</tt> subcommand.</p></dd><dt><span class="term"><tt class="literal">lstxns</tt></span></dt><dd><p>List the names of uncommitted Subversion
                transactions that currently exist in the repository.</p></dd><dt><span class="term"><tt class="literal">recover</tt></span></dt><dd><p>Perform recovery steps on a repository that is in
                need of such, generally after a fatal error has
                occurred that prevented a process from cleanly
                shutting down its communication with the repository.</p></dd><dt><span class="term"><tt class="literal">rmtxns</tt></span></dt><dd><p>Cleanly remove Subversion transactions from the
                repository (conveniently fed by output from the
                <tt class="literal">lstxns</tt> subcommand).</p></dd><dt><span class="term"><tt class="literal">setlog</tt></span></dt><dd><p>Replace the current value of the
                <tt class="literal">svn:log</tt> (commit log message)
                property on a given revision in the repository with a
                new value.</p></dd><dt><span class="term"><tt class="literal">verify</tt></span></dt><dd><p>Verify the contents of the repository.  This includes,
                among other things, checksum comparisons of the
                versioned data stored in the repository.</p></dd></dl></div></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.3"></a>svndumpfilter</h4></div></div><div></div></div><p>Since Subversion stores everything in an opaque database
          system, attempting manual tweaks is unwise, if not quite
          difficult.  And once data has been stored in your
          repository, Subversion generally doesn't provide an
          easy way to remove that data.
          <sup>[<a name="id931548" href="#ftn.id931548">13</a>]</sup>
          But inevitably, there will be times when you would like to
          manipulate the history of your repository.  You might need
          to strip out all instances of a file that was accidentally
          added to the repository (and shouldn't be there for whatever
          reason).  Or, perhaps you have multiple projects sharing a
          single repository, and you decide to split them up into
          their own repositories.  To accomplish tasks like this,
          administrators need a more manageable and malleable
          representation of the data in their repositories&#8212;the
          Subversion repository dump format.</p><p>The Subversion repository dump format is a
          human-readable representation of the changes that you've
          made to your versioned data over time.  You use the
          <span><b class="command">svnadmin dump</b></span> command to generate the
          dump data, and <span><b class="command">svnadmin load</b></span> to populate
          a new repository with it (see <a href="#svn-ch-5-sect-3.5" title="Migrating a Repository">the section called &#8220;Migrating a Repository&#8221;</a>).  The great thing about the
          human-readability aspect of the dump format is that, if you
          aren't careless about it, you can manually inspect and
          modify it.  Of course, the downside is that if you have two
          years' worth of repository activity encapsulated in what is
          likely to be a very large dump file, it could take you a
          long, long time to manually inspect and modify it.</p><p>While it won't be the most commonly used tool at the
          administrator's disposal, <span><b class="command">svndumpfilter</b></span>
          provides a very particular brand of useful
          functionality&#8212;the ability to quickly and easily modify
          that dump data by acting as a path-based filter.  Simply
          give it either a list of paths you wish to keep, or a list
          of paths you wish to not keep, then pipe your repository
          dump data through this filter.  The result will be a
          modified stream of dump data that contains only the
          versioned paths you (explicitly or implicitly) requested.</p><p>The syntax of <span><b class="command">svndumpfilter</b></span> is as
          follows:</p><pre class="screen">
$ svndumpfilter help
general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]
Type "svndumpfilter help &lt;subcommand&gt;" for help on a specific subcommand.

Available subcommands:
   exclude
   include
   help (?, h)
</pre><p>There are only two interesting subcommands.  They allow
          you to make the choice between explicit or implicit
          inclusion of paths in the stream:</p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">exclude</tt></span></dt><dd><p>Filter out a set of paths from the dump data
                stream.</p></dd><dt><span class="term"><tt class="literal">include</tt></span></dt><dd><p>Allow only the requested set of paths to pass
                through the dump data stream.</p></dd></dl></div><p>Let's look a realistic example of how you might use this
          program.  We discuss elsewhere (see <a href="#svn-ch-5-sect-6.1" title="Choosing a Repository Layout">the section called &#8220;Choosing a Repository Layout&#8221;</a>) the process of deciding how to
          choose a layout for the data in your
          repositories&#8212;using one repository per project or
          combining them, arranging stuff within your repository, and
          so on.  But sometimes after new revisions start flying in,
          you rethink your layout and would like to make some changes.
          A common change is the decision to move multiple projects
          which are sharing a single repository into separate
          repositories for each project.</p><p>Our imaginary repository contains three projects:
          <tt class="literal">calc</tt>, <tt class="literal">calendar</tt>, and
          <tt class="literal">spreadsheet</tt>.  They have been living
          side-by-side in a layout like this:</p><pre class="screen">
/
   calc/
      trunk/
      branches/
      tags/
   calendar/
      trunk/
      branches/
      tags/
   spreadsheet/
      trunk/
      branches/
      tags/
</pre><p>To get these three projects into their own repositories,
          we first dump the whole repository:</p><pre class="screen">
$ svnadmin dump /path/to/repos &gt; repos-dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
* Dumped revision 3.
&#8230;
$
</pre><p>Next, run that dump file through the filter, each time
          including only one of our top-level directories, and
          resulting in three new dump files:</p><pre class="screen">
$ cat repos-dumpfile | svndumpfilter include calc &gt; calc-dumpfile
&#8230;
$ cat repos-dumpfile | svndumpfilter include calendar &gt; cal-dumpfile
&#8230;
$ cat repos-dumpfile | svndumpfilter include spreadsheet &gt; ss-dumpfile
&#8230;
$
</pre><p>At this point, you have to make a decision.  Each of
          your dump files will create a valid repository,
          but will preserve the paths exactly as they were in the
          original repository.  This means that even though you would
          have a repository solely for your <tt class="literal">calc</tt>
          project, that repository would still have a top-level
          directory named <tt class="filename">calc</tt>.  If you want
          your <tt class="filename">trunk</tt>, <tt class="filename">tags</tt>,
          and <tt class="filename">branches</tt> directories to live in the
          root of your repository, you might wish to edit your
          dump files, tweaking the <tt class="literal">Node-path</tt> and
          <tt class="literal">Copyfrom-path</tt> headers to no longer have
          that first <tt class="filename">calc/</tt> path component.  Also,
          you'll want to remove the section of dump data that creates
          the <tt class="filename">calc</tt> directory.  It will look
          something like:</p><pre class="screen">
Node-path: calc
Node-action: add
Node-kind: dir
Content-length: 0

</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If you do plan on manually editing the dump file to
            remove a top-level directory, make sure that your editor is
            not set to automatically convert end-lines to the native
            format (e.g. \r\n to \n) as the content will then not agree
            with the metadata and this will render the dump file
            useless.</p></div><p>All that remains now is to create your three new
          repositories, and load each dump file into the right
          repository:</p><pre class="screen">
$ svnadmin create calc; svnadmin load calc &lt; calc-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : button.c ... done.
&#8230;
$ svnadmin create calendar; svnadmin load calendar &lt; cal-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : cal.c ... done.
&#8230;
$ svnadmin create spreadsheet; svnadmin load spreadsheet &lt; ss-dumpfile
&lt;&lt;&lt; Started new transaction, based on original revision 1
     * adding path : Makefile ... done.
     * adding path : ss.c ... done.
&#8230;
$
</pre><p>Both of <span><b class="command">svndumpfilter</b></span>'s subcommands
          accept options for deciding how to deal with
          &#8220;<span class="quote">empty</span>&#8221; revisions.  If a given revision
          contained only changes to paths that were filtered out, that
          now-empty revision could be considered uninteresting or even
          unwanted.  So to give the user control over what to do with
          those revisions, <span><b class="command">svndumpfilter</b></span> provides
          the following command-line options:</p><div class="variablelist"><dl><dt><span class="term"><tt class="option">--drop-empty-revs</tt></span></dt><dd><p>Do not generate empty revisions at all&#8212;just
                omit them.</p></dd><dt><span class="term"><tt class="option">--renumber-revs</tt></span></dt><dd><p>If empty revisions are dropped (using the
                <tt class="option">--drop-empty-revs</tt> option), change the
                revision numbers of the remaining revisions so that
                there are no gaps in the numeric sequence.</p></dd><dt><span class="term"><tt class="option">--preserve-revprops</tt></span></dt><dd><p>If empty revisions are not dropped, preserve the
                revision properties (log message, author, date, custom
                properties, etc.) for those empty revisions.
                Otherwise, empty revisions will only contain the
                original datestamp, and a generated log message that
                indicates that this revision was emptied by
                <span><b class="command">svndumpfilter</b></span>.</p></dd></dl></div><p>While <span><b class="command">svndumpfilter</b></span> can be very
          useful, and a huge timesaver, there are unfortunately a
          couple of gotchas.  First, this utility is overly sensitive
          to path semantics.  Pay attention to whether paths in your
          dump file are specified with or without leading slashes.
          You'll want to look at the <tt class="literal">Node-path</tt> and
          <tt class="literal">Copyfrom-path</tt> headers.</p><pre class="screen">
&#8230;
Node-path: spreadsheet/Makefile
&#8230;
</pre><p>If the paths have leading slashes, you should
          include leading slashes in the paths you pass to
          <span><b class="command">svndumpfilter include</b></span> and
          <span><b class="command">svndumpfilter exclude</b></span> (and if they don't,
          you shouldn't).  Further, if your dump file has an inconsistent
          usage of leading slashes for some reason,
          <sup>[<a name="id931974" href="#ftn.id931974">14</a>]</sup>
          you should probably normalize those paths so they all
          have, or lack, leading slashes.</p><p>Also, copied paths can give you some trouble.
          Subversion supports copy operations in the repository, where
          a new path is created by copying some already existing path.
          It is possible that at some point in the lifetime of your
          repository, you might have copied a file or directory from
          some location that <span><b class="command">svndumpfilter</b></span> is
          excluding, to a location that it is including.  In order to
          make the dump data self-sufficient,
          <span><b class="command">svndumpfilter</b></span> needs to still show the
          addition of the new path&#8212;including the contents of any
          files created by the copy&#8212;and not represent that
          addition as a copy from a source that won't exist in your
          filtered dump data stream.  But because the Subversion
          repository dump format only shows what was changed in each
          revision, the contents of the copy source might not be
          readily available.  If you suspect that you have any copies
          of this sort in your repository, you might want to rethink
          your set of included/excluded paths.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.4"></a>svnshell.py</h4></div></div><div></div></div><p>The Subversion source tree also comes with a shell-like
          interface to the repository.  The
          <span><b class="command">svnshell.py</b></span> Python script (located in
          <tt class="filename">tools/examples/</tt> in the source tree)
          uses Subversion's language bindings (so you must have
          those properly compiled and installed in order for this
          script to work) to connect to the repository and filesystem
          libraries.</p><p>Once started, the program behaves similarly to a shell
          program, allowing you to browse the various directories in
          your repository.  Initially, you are
          &#8220;<span class="quote">positioned</span>&#8221; in the root directory of the
          <tt class="literal">HEAD</tt> revision of the repository, and
          presented with a command prompt.  You can use the
          <tt class="literal">help</tt> command at any time to display a
          list of available commands and what they do.</p><pre class="screen">
$ svnshell.py /path/to/repos
&lt;rev: 2 /&gt;$  help
Available commands:
  cat FILE     : dump the contents of FILE
  cd DIR       : change the current working directory to DIR
  exit         : exit the shell
  ls [PATH]    : list the contents of the current directory
  lstxns       : list the transactions available for browsing
  setrev REV   : set the current revision to browse
  settxn TXN   : set the current transaction to browse
  youngest     : list the youngest browsable revision number
&lt;rev: 2 /&gt;$
</pre><p>Navigating the directory structure of your repository is
          done in the same way you would navigate a regular Unix or
          Windows shell&#8212;using the <tt class="literal">cd</tt> command.
          At all times, the command prompt will show you what revision
          (prefixed by <tt class="literal">rev:</tt>) or transaction
          (prefixed by <tt class="literal">txn:</tt>) you are currently
          examining, and at what path location in that revision or
          transaction.  You can change your current revision or
          transaction with the <tt class="literal">setrev</tt> and
          <tt class="literal">settxn</tt> commands, respectively.  As in a
          Unix shell, you can use the <tt class="literal">ls</tt> command to
          display the contents of the current directory, and you can
          use the <tt class="literal">cat</tt> command to display the
          contents of a file.</p><div class="example"><a name="svn-ch-8-sect-3.1.3-ex-1"></a><p class="title"><b>Example 5.1. Using svnshell to Navigate the Repository</b></p><pre class="screen">
&lt;rev: 2 /&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     2.0.1&gt;          Nov 15 11:50 A/
     2    harry &lt;     1.0.2&gt;       56 Nov 19 08:19 iota
&lt;rev: 2 /&gt;$ cd A
&lt;rev: 2 /A&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     4.0.1&gt;          Nov 15 11:50 B/
     1    sally &lt;     a.0.1&gt;          Nov 15 11:50 C/
     1    sally &lt;     b.0.1&gt;          Nov 15 11:50 D/
     1    sally &lt;     3.0.1&gt;       23 Nov 15 11:50 mu
&lt;rev: 2 /A&gt;$ cd D/G 
&lt;rev: 2 /A/D/G&gt;$ ls
   REV   AUTHOR  NODE-REV-ID     SIZE         DATE NAME
----------------------------------------------------------------------------
     1    sally &lt;     e.0.1&gt;       23 Nov 15 11:50 pi
     1    sally &lt;     f.0.1&gt;       24 Nov 15 11:50 rho
     1    sally &lt;     g.0.1&gt;       24 Nov 15 11:50 tau
&lt;rev: 2 /A&gt;$ cd ../..
&lt;rev: 2 /&gt;$ cat iota
This is the file 'iota'.
Added this text in revision 2.

&lt;rev: 2 /&gt;$ setrev 1; cat iota
This is the file 'iota'.

&lt;rev: 1 /&gt;$ exit
$
</pre></div><p>As you can see in the previous example, multiple
          commands may be specified at a single command prompt,
          separated by a semicolon.  Also, the shell understands the
          notions of relative and absolute paths, and will properly
          handle the <tt class="literal">.</tt> and
          <tt class="literal">..</tt> special path components.</p><p>The <tt class="literal">youngest</tt> command displays the
          youngest revision.  This is useful for determining the range
          of valid revisions you can use as arguments to the
          <tt class="literal">setrev</tt> command&#8212;you are allowed to
          browse all the revisions (recalling that they are named with
          integers) between 0 and the youngest, inclusively.
          Determining the valid browsable transactions isn't quite as
          pretty.  Use the <span><b class="command">lstxns</b></span> command to list
          the transactions that you are able to browse.  The list of
          browsable transactions is the same list that
          <span><b class="command">svnadmin lstxns</b></span> returns, and the same
          list that is valid for use with <span><b class="command">svnlook</b></span>'s
          <tt class="option">--transaction</tt> option.</p><p>Once you've finished using the shell, you can exit
          cleanly by using the <span><b class="command">exit</b></span> command.
          Alternatively, you can supply an end-of-file
          character&#8212;Control-D (though some Win32 Python
          distributions use the Windows Control-Z convention
          instead).</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-5-sect-3.1.5"></a>Berkeley DB Utilities</h4></div></div><div></div></div><p>If you're using a Berkeley DB repository, then all of
          your versioned filesystem's structure and data live in a set
          of database tables within the <tt class="filename">db</tt>
          subdirectory of your repository.  This subdirectory is a
          regular Berkeley DB environment directory, and can therefore
          be used in conjunction with any of the Berkeley database
          tools (you can see the documentation for these tools at
          SleepyCat's website, <tt class="systemitem">http://www.sleepycat.com/</tt>).</p><p>For day-to-day Subversion use, these tools are
          unnecessary.  Most of the functionality typically needed for
          Subversion repositories has been duplicated in the
          <span><b class="command">svnadmin</b></span> tool.  For example,
          <span><b class="command">svnadmin list-unused-dblogs</b></span> and
          <span><b class="command">svnadmin list-dblogs</b></span> perform a
          subset of what is provided by the Berkeley
          <span><b class="command">db_archive</b></span> command, and <span><b class="command">svnadmin
          recover</b></span> reflects the common use-cases of the
          <span><b class="command">db_recover</b></span> utility.</p><p>There are still a few Berkeley DB utilities that you
          might find useful.  The <span><b class="command">db_dump</b></span> and
          <span><b class="command">db_load</b></span> programs write and read,
          respectively, a custom file format which describes the keys
          and values in a Berkeley DB database.  Since Berkeley
          databases are not portable across machine architectures,
          this format is a useful way to transfer those databases from
          machine to machine, irrespective of architecture or
          operating system.  Also, the <span><b class="command">db_stat</b></span>
          utility can provide useful information about the status of
          your Berkeley DB environment, including detailed statistics
          about the locking and storage subsystems.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.2"></a>Repository Cleanup</h3></div></div><div></div></div><p>Your Subversion repository will generally require very
        little attention once it is configured to your liking.
        However, there are times when some manual assistance from an
        administrator might be in order.  The
        <span><b class="command">svnadmin</b></span> utility provides some helpful
        functionality to assist you in performing such tasks as</p><div class="itemizedlist"><ul type="disc"><li><p>modifying commit log messages,</p></li><li><p>removing dead transactions,</p></li><li><p>recovering &#8220;<span class="quote">wedged</span>&#8221; repositories, and</p></li><li><p>migrating repository contents to a different
            repository.</p></li></ul></div><p>Perhaps the most commonly used of
        <span><b class="command">svnadmin</b></span>'s subcommands is
        <tt class="literal">setlog</tt>.  When a transaction is committed to
        the repository and promoted to a revision, the descriptive log
        message associated with that new revision (and provided by the
        user) is stored as an unversioned property attached to the
        revision itself.  In other words, the repository remembers
        only the latest value of the property, and discards previous
        ones.</p><p>Sometimes a user will have an error in her log message (a
        misspelling or some misinformation, perhaps).  If the
        repository is configured (using the
        <tt class="literal">pre-revprop-change</tt> and
        <tt class="literal">post-revprop-change</tt> hooks; see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>) to accept changes to this log
        message after the commit is finished, then the user can
        &#8220;<span class="quote">fix</span>&#8221; her log message remotely using the
        <span><b class="command">svn</b></span> program's <tt class="literal">propset</tt>
        command (see <a href="#svn-ch-9" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a>).  However, because of
        the potential to lose information forever, Subversion
        repositories are not, by default, configured to allow changes
        to unversioned properties&#8212;except by an administrator.</p><p>If a log message needs to be changed by an administrator,
        this can be done using <span><b class="command">svnadmin setlog</b></span>.
        This command changes the log message (the
        <tt class="literal">svn:log</tt> property) on a given revision of a
        repository, reading the new value from a provided file.</p><pre class="screen">
$ echo "Here is the new, correct log message" &gt; newlog.txt
$ svnadmin setlog myrepos newlog.txt -r 388
</pre><p>The <span><b class="command">svnadmin setlog</b></span> command alone is
        still bound by the same protections against modifying
        unversioned properties as a remote client is&#8212;the
        <tt class="literal">pre-</tt> and
        <tt class="literal">post-revprop-change</tt> hooks are still
        triggered, and therefore must be setup to accept changes of
        this nature.  But an administrator can get around these
        protections by passing the <tt class="option">--bypass-hooks</tt>
        option to the <span><b class="command">svnadmin setlog</b></span> command.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Remember, though, that by bypassing the hooks, you are
          likely avoiding such things as email notifications of
          property changes, backup systems which track unversioned
          property changes, and so on.  In other words, be very
          careful about what you are changing, and how you change
          it.</p></div><p>Another common use of <span><b class="command">svnadmin</b></span> is to
        query the repository for outstanding&#8212;possibly
        dead&#8212;Subversion transactions.  In the event that a commit
        should fail, the transaction is usually cleaned up.  That is,
        the transaction itself is removed from the repository, and any
        data associated with (and only with) that transaction is
        removed as well.  Occasionally, though, a failure occurs in
        such a way that the cleanup of the transaction never happens.
        This could happen for several reasons: perhaps the client
        operation was inelegantly terminated by the user, or a network
        failure might have occurred in the middle of an operation, etc.
        Regardless of the reason, these dead transactions serve only
        to clutter the repository and consume resources.</p><p>You can use <span><b class="command">svnadmin</b></span>'s
        <tt class="literal">lstxns</tt> command to list the names of the
        currently outstanding transactions.</p><pre class="screen">
$ svnadmin lstxns myrepos
19
3a1
a45
$
</pre><p>Each item in the resultant output can then be used with
        <span><b class="command">svnlook</b></span> (and its
        <tt class="option">--transaction</tt> option) to determine who
        created the transaction, when it was created, what types of
        changes were made in the transaction&#8212;in other words,
        whether or not the transaction is a safe candidate for
        removal!  If so, the transaction's name can be passed to
        <span><b class="command">svnadmin rmtxns</b></span>, which will perform the
        cleanup of the transaction.  In fact, the
        <tt class="literal">rmtxns</tt> subcommand can take its input
        directly from the output of <tt class="literal">lstxns</tt>!</p><pre class="screen">
$ svnadmin rmtxns myrepos `svnadmin lstxns myrepos`
$
</pre><p>If you use these two subcommands like this, you should
        consider making your repository temporarily inaccessible to
        clients.  That way, no one can begin a legitimate transaction
        before you start your cleanup.  The following is a little bit
        of shell-scripting that can quickly generate information about
        each outstanding transaction in your repository:</p><div class="example"><a name="svn-ch-5-sect-3.2-ex-1"></a><p class="title"><b>Example 5.2. txn-info.sh (Reporting Outstanding Transactions)</b></p><pre class="programlisting">
#!/bin/sh

### Generate informational output for all outstanding transactions in
### a Subversion repository.

SVNADMIN=/usr/local/bin/svnadmin
SVNLOOK=/usr/local/bin/svnlook

REPOS="${1}"
if [ "x$REPOS" = x ] ; then
  echo "usage: $0 REPOS_PATH"
  exit
fi

for TXN in `${SVNADMIN} lstxns ${REPOS}`; do 
  echo "---[ Transaction ${TXN} ]-------------------------------------------"
  ${SVNLOOK} info "${REPOS}" --transaction "${TXN}"
done
</pre></div><p>You can run the previous script using
        <span><b class="command">/path/to/txn-info.sh /path/to/repos</b></span>.  The
        output is basically a concatenation of several chunks of
        <span><b class="command">svnlook info</b></span> output (see <a href="#svn-ch-5-sect-3.1.1" title="svnlook">the section called &#8220;svnlook&#8221;</a>), and will look something
        like:</p><pre class="screen">
$ txn-info.sh myrepos
---[ Transaction 19 ]-------------------------------------------
sally
2001-09-04 11:57:19 -0500 (Tue, 04 Sep 2001)
0
---[ Transaction 3a1 ]-------------------------------------------
harry
2001-09-10 16:50:30 -0500 (Mon, 10 Sep 2001)
39
Trying to commit over a faulty network.
---[ Transaction a45 ]-------------------------------------------
sally
2001-09-12 11:09:28 -0500 (Wed, 12 Sep 2001)
0
$
</pre><p>Usually, if you see a dead transaction that has no log
        message attached to it, this is the result of a failed update
        (or update-like) operation.  These operations use Subversion
        transactions under the hood to mimic working copy state.
        Since they are never intended to be committed, Subversion
        doesn't require a log message for those transactions.
        Transactions that do have log messages attached are almost
        certainly failed commits of some sort.  Also, a transaction's
        datestamp can provide interesting information&#8212;for
        example, how likely is it that an operation begun nine months
        ago is still active?</p><p>In short, transaction cleanup decisions need not be made
        unwisely.  Various sources of information&#8212;including
        Apache's error and access logs, the logs of successful
        Subversion commits, and so on&#8212;can be employed in the
        decision-making process.  Finally, an administrator can often
        simply communicate with a seemingly dead transaction's owner
        (via email, for example) to verify that the transaction is, in
        fact, in a zombie state.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.3"></a>Managing Disk Space</h3></div></div><div></div></div><p>While the cost of storage has dropped incredibly in the
          past few years, disk usage is still a valid concern for
          administrators seeking to version large amounts of data.
          Every additional byte consumed by the live repository is a
          byte that needs to be backed up offsite, perhaps multiple
          times as part of rotating backup schedules.  If using a
          Berkeley DB repository, the primary storage mechanism is a
          complex database system, it is useful to know what pieces of
          data need to remain on the live site, which need to be
          backed up, and which can be safely removed.  This section is
          specific to Berkeley DB;  FSFS repositories have no extra
          data that be cleaned up or reclaimed.</p><p>Until recently, the largest offender of disk space usage
          with respect to Subversion repositories was the log files to
          which Berkeley DB performs its pre-writes before modifying
          the actual database files.  These files capture all the
          actions taken along the route of changing the database from
          one state to another&#8212;while the database files reflect
          at any given time some state, the log files contain all the
          many changes along the way between states.  As such, they
          can start to accumulate quite rapidly.</p><p>Fortunately, beginning with the 4.2 release of Berkeley
          DB, the database environment has the ability to remove its
          own unused log files without any external procedures.  Any
          repositories created using an <span><b class="command">svnadmin</b></span>
          which is compiled against Berkeley DB version 4.2 or greater
          will be configured for this automatic log file removal.  If
          you don't want this feature enabled, simply pass the
          <tt class="option">--bdb-log-keep</tt> option to the
          <span><b class="command">svnadmin create</b></span> command.  If you forget
          to do this, or change your mind at a later time, simple edit
          the <tt class="filename">DB_CONFIG</tt> file found in your
          repository's <tt class="filename">db</tt> directory, comment out
          the line which contains the <tt class="literal">set_flags
          DB_LOG_AUTOREMOVE</tt> directive, and then run
          <span><b class="command">svnadmin recover</b></span> on your repository to
          force the configuration changes to take effect.  See <a href="#svn-ch-5-sect-2.2" title="Berkeley DB Configuration">the section called &#8220;Berkeley DB Configuration&#8221;</a> for more information about
          database configuration.</p><p>Without some sort of automatic log file removal in
          place, log files will accumulate as you use your repository.
          This is actually somewhat of a feature of the database
          system&#8212;you should be able to recreate your entire
          database using nothing but the log files, so these files can
          be useful for catastrophic database recovery.  But
          typically, you'll want to archive the log files that are no
          longer in use by Berkeley DB, and then remove them from disk
          to conserve space.  Use the <span><b class="command">svnadmin
          list-unused-dblogs</b></span> command to list the unused
          log files:</p><pre class="screen">
$ svnadmin list-unused-dblogs /path/to/repos
/path/to/repos/log.0000000031
/path/to/repos/log.0000000032
/path/to/repos/log.0000000033

$ svnadmin list-unused-dblogs /path/to/repos | xargs rm
## disk space reclaimed!
</pre><p>To keep the size of the repository as small as possible,
          Subversion uses <i class="firstterm">deltification</i> (or,
          &#8220;<span class="quote">deltified storage</span>&#8221;) within the repository
          itself.  Deltification involves encoding the representation
          of a chunk of data as a collection of differences against
          some other chunk of data.  If the two pieces of data are
          very similar, this deltification results in storage savings
          for the deltified chunk&#8212;rather than taking up space
          equal to the size of the original data, it only takes up
          enough space to say, &#8220;<span class="quote">I look just like this other
          piece of data over here, except for the following couple of
          changes.</span>&#8221; Specifically, each time a new version of a
          file is committed to the repository, Subversion encodes the
          previous version (actually, several previous versions) as a
          delta against the new version.  The result is that most of
          the repository data that tends to be sizable&#8212;namely,
          the contents of versioned files&#8212;is stored at a much
          smaller size than the original &#8220;<span class="quote">fulltext</span>&#8221;
          representation of that data.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Because all of the Subversion repository data that is
            subject to deltification is stored in a single Berkeley DB
            database file, reducing the size of the stored values will
            not necessarily reduce the size of the database file
            itself.  Berkeley DB will, however, keep internal records
            of unused areas of the database file, and use those areas
            first before growing the size of the database file.  So
            while deltification doesn't produce immediate space
            savings, it can drastically slow future growth of the
            database.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.4"></a>Repository Recovery</h3></div></div><div></div></div><p>As mentioned in <a href="#svn-ch-5-sect-1.3.1" title="Berkeley DB">the section called &#8220;Berkeley DB&#8221;</a>, a
        Berkeley DB repository can sometimes be left in frozen state
        if not closed properly.  When this happens, an administrator
        needs to rewind the database back into a consistent
        state.</p><p>In order to protect the data in your repository, Berkeley
        DB uses a locking mechanism.  This mechanism ensures that
        portions of the database are not simultaneously modified by
        multiple database accessors, and that each process sees the
        data in the correct state when that data is being read from
        the database.  When a process needs to change something in the
        database, it first checks for the existence of a lock on the
        target data.  If the data is not locked, the process locks the
        data, makes the change it wants to make, and then unlocks the
        data.  Other processes are forced to wait until that lock is
        removed before they are permitted to continue accessing that
        section of the database.</p><p>In the course of using your Subversion repository, fatal
        errors (such as running out of disk space or available memory)
        or interruptions can prevent a process from having the chance to
        remove the locks it has placed in the database.  The result is
        that the back-end database system gets &#8220;<span class="quote">wedged</span>&#8221;.
        When this happens, any attempts to access the repository hang
        indefinitely (since each new accessor is waiting for a lock to
        go away&#8212;which isn't going to happen).</p><p>First, if this happens to your repository, don't panic.
        The Berkeley DB filesystem takes advantage of database
        transactions and checkpoints and pre-write journaling to
        ensure that only the most catastrophic of events
        <sup>[<a name="id932913" href="#ftn.id932913">15</a>]</sup>
        can permanently destroy a database environment.  A
        sufficiently paranoid repository administrator will be making
        off-site backups of the repository data in some fashion, but
        don't call your system administrator to restore a backup tape
        just yet.</p><p>Secondly, use the following recipe to attempt to
        &#8220;<span class="quote">unwedge</span>&#8221; your repository:</p><div class="orderedlist"><ol type="1"><li><p>Make sure that there are no processes accessing (or
            attempting to access) the repository.  For networked
            repositories, this means shutting down the Apache HTTP
            Server, too.</p></li><li><p>Become the user who owns and manages the repository.
            This is important, as recovering a repository while
            running as the wrong user can tweak the permissions of the
            repository's files in such a way that your repository will
            still be inaccessible even after it is 
            &#8220;<span class="quote">unwedged</span>&#8221;.</p></li><li><p>Run the command <span><b class="command">svnadmin recover
            /path/to/repos</b></span>.  You should see output like
            this:</p><pre class="screen">
Repository lock acquired.
Please wait; recovering the repository may take some time...

Recovery completed.
The latest repos revision is 19.
</pre><p>This command may take many minutes to complete.</p></li><li><p>Restart the Subversion server.</p></li></ol></div><p>This procedure fixes almost every case of repository
        lock-up.  Make sure that you run this command as the user that
        owns and manages the database, not just as
        <tt class="literal">root</tt>.  Part of the recovery process might
        involve recreating from scratch various database files (shared
        memory regions, for example).  Recovering as
        <tt class="literal">root</tt> will create those files such that they
        are owned by <tt class="literal">root</tt>, which means that even
        after you restore connectivity to your repository, regular
        users will be unable to access it.</p><p>If the previous procedure, for some reason, does not
        successfully unwedge your repository, you should do two
        things.  First, move your broken repository out of the way and
        restore your latest backup of it.  Then, send an email to the
        Subversion user list (at
        <tt class="email">&lt;<a href="mailto:users@subversion.tigris.org">users@subversion.tigris.org</a>&gt;</tt>) describing your
        problem in detail.  Data integrity is an extremely high
        priority to the Subversion developers.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.5"></a>Migrating a Repository</h3></div></div><div></div></div><p>A Subversion filesystem has its data spread throughout
        various database tables in a fashion generally understood by
        (and of interest to) only the Subversion developers
        themselves.  However, circumstances may arise that call for
        all, or some subset, of that data to be collected into a
        single, portable, flat file format.  Subversion provides such
        a mechanism, implemented in a pair of
        <span><b class="command">svnadmin</b></span> subcommands:
        <tt class="literal">dump</tt> and <tt class="literal">load</tt>.</p><p>The most common reason to dump and load a Subversion
        repository is due to changes in Subversion itself.  As
        Subversion matures, there are times when certain changes made
        to the back-end database schema cause Subversion to be
        incompatible with previous versions of the repository.  Other
        reasons for dumping and loading might be to migrate a Berkeley
        DB repository to a new OS or CPU architecture, or to switch
        between Berkeley DB and FSFS back-ends.  The recommended
        course of action is relatively simple:</p><div class="orderedlist"><ol type="1"><li><p>Using your <span class="emphasis"><em>current</em></span> version of
            <span><b class="command">svnadmin</b></span>, dump your repositories to
            dump files.</p></li><li><p>Upgrade to the new version of Subversion.</p></li><li><p>Move your old repositories out of the way, and create
            new empty ones in their place using your
            <span class="emphasis"><em>new</em></span> <span><b class="command">svnadmin</b></span>.</p></li><li><p>Again using your <span class="emphasis"><em>new</em></span>
            <span><b class="command">svnadmin</b></span>, load your dump files into
            their respective, just-created repositories.</p></li><li><p>Be sure to copy any customizations from your old
            repositories to the new ones, including
            <tt class="filename">DB_CONFIG</tt> files and hook scripts.
            You'll want to pay attention to the release notes for the
            new release of Subversion to see if any changes since your
            last upgrade affect those hooks or configuration
            options.</p></li><li><p>If the migration process made your repository
            accessible at a different URL (e.g. moved to a different
            computer, or is being accessed via a different schema),
            then you'll probably want to tell your users to run
            <span><b class="command">svn switch --relocate</b></span> on their existing
            working copies.  See <a href="#svn-ch-9-sect-1.2-re-switch" title="svn switch">svn switch</a>.</p></li></ol></div><p><span><b class="command">svnadmin dump</b></span> will output a range of
        repository revisions that are formatted using Subversion's
        custom filesystem dump format.  The dump format is printed to
        the standard output stream, while informative messages are
        printed to the standard error stream.  This allows you to
        redirect the output stream to a file while watching the status
        output in your terminal window.  For example:</p><pre class="screen">
$ svnlook youngest myrepos
26
$ svnadmin dump myrepos &gt; dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&#8230;
* Dumped revision 25.
* Dumped revision 26.
</pre><p>At the end of the process, you will have a single file
        (<tt class="filename">dumpfile</tt> in the previous example) that
        contains all the data stored in your repository in the
        requested range of revisions.  Note that <span><b class="command">svnadmin
        dump</b></span> is reading revision trees from the repository
        just like any other &#8220;<span class="quote">reader</span>&#8221; process would
        (<span><b class="command">svn checkout</b></span>, for example.)  So it's safe
        to run this command at any time.</p><p>The other subcommand in the pair, <span><b class="command">svnadmin
        load</b></span>, parses the standard input stream as a
        Subversion repository dump file, and effectively replays those
        dumped revisions into the target repository for that
        operation.  It also gives informative feedback, this time
        using the standard output stream:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
     &#8230;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;

&#8230;

&lt;&lt;&lt; Started new txn, based on original revision 25
     * editing path : A/D/gamma ... done.

------- Committed new rev 25 (loaded from original rev 25) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 26
     * adding path : A/Z/zeta ... done.
     * editing path : A/mu ... done.

------- Committed new rev 26 (loaded from original rev 26) &gt;&gt;&gt;

</pre><p>Note that because <span><b class="command">svnadmin</b></span> uses
        standard input and output streams for the repository dump and
        load process, people who are feeling especially saucy can try
        things like this (perhaps even using different versions of
        <span><b class="command">svnadmin</b></span> on each side of the pipe):</p><pre class="screen">
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</pre><p>By default, the dump file will be quite large&#8212;much
        larger than the repository itself.  That's because every
        version of every file is expressed as a full text in the
        dump file.  This is the fastest and simplest behavior, and nice
        if you're piping the dump data directly into some other
        process (such as a compression program, filtering program, or
        into a loading process).  But if you're creating a dump file for
        longer-term storage, you'll likely want to save disk space by
        using the <tt class="option">--deltas</tt> switch.  With this option,
        successive revisions of files will be output as compressed,
        binary differences&#8212;just as file revisions are stored in
        a repository.  This option is slower, but results in a
        dump file much closer in size to the original
        repository.</p><p>We mentioned previously that <span><b class="command">svnadmin
        dump</b></span> outputs a range of revisions.  Use the
        <tt class="option">--revision</tt> option to specify a single
        revision to dump, or a range of revisions.  If you omit this
        option, all the existing repository revisions will be
        dumped.</p><pre class="screen">
$ svnadmin dump myrepos --revision 23 &gt; rev-23.dumpfile
$ svnadmin dump myrepos --revision 100:200 &gt; revs-100-200.dumpfile
</pre><p>As Subversion dumps each new revision, it outputs only
        enough information to allow a future loader to re-create that
        revision based on the previous one.  In other words, for any
        given revision in the dump file, only the items that were
        changed in that revision will appear in the dump.  The only
        exception to this rule is the first revision that is dumped
        with the current <span><b class="command">svnadmin dump</b></span>
        command.</p><p>By default, Subversion will not express the first dumped
        revision as merely differences to be applied to the previous
        revision.  For one thing, there is no previous revision in the
        dump file!  And secondly, Subversion cannot know the state of
        the repository into which the dump data will be loaded (if it
        ever, in fact, occurs).  To ensure that the output of each
        execution of <span><b class="command">svnadmin dump</b></span> is
        self-sufficient, the first dumped revision is by default a
        full representation of every directory, file, and property in
        that revision of the repository.</p><p>However, you can change this default behavior.  If you add
        the <tt class="option">--incremental</tt> option when you dump your
        repository, <span><b class="command">svnadmin</b></span> will compare the first
        dumped revision against the previous revision in the
        repository, the same way it treats every other revision that
        gets dumped.  It will then output the first revision exactly
        as it does the rest of the revisions in the dump
        range&#8212;mentioning only the changes that occurred in that
        revision.  The benefit of this is that you can create several
        small dump files that can be loaded in succession, instead of
        one large one, like so:</p><pre class="screen">
$ svnadmin dump myrepos --revision 0:1000 &gt; dumpfile1
$ svnadmin dump myrepos --revision 1001:2000 --incremental &gt; dumpfile2
$ svnadmin dump myrepos --revision 2001:3000 --incremental &gt; dumpfile3
</pre><p>These dump files could be loaded into a new repository with
        the following command sequence:</p><pre class="screen">
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</pre><p>Another neat trick you can perform with this
        <tt class="option">--incremental</tt> option involves appending to an
        existing dump file a new range of dumped revisions.  For
        example, you might have a <tt class="literal">post-commit</tt> hook
        that simply appends the repository dump of the single revision
        that triggered the hook.  Or you might have a script that runs
        nightly to append dump file data for all the revisions that
        were added to the repository since the last time the script
        ran.  Used like this, <span><b class="command">svnadmin</b></span>'s
        <tt class="literal">dump</tt> and <tt class="literal">load</tt> commands
        can be a valuable means by which to backup changes to your
        repository over time in case of a system crash or some other
        catastrophic event.</p><p>The dump format can also be used to merge the contents of
        several different repositories into a single repository.  By
        using the <tt class="option">--parent-dir</tt> option of <span><b class="command">svnadmin
        load</b></span>, you can specify a new virtual root directory
        for the load process.  That means if you have dump files for
        three repositories, say <tt class="filename">calc-dumpfile</tt>,
        <tt class="filename">cal-dumpfile</tt>, and
        <tt class="filename">ss-dumpfile</tt>, you can first create a new
        repository to hold them all:</p><pre class="screen">
$ svnadmin create /path/to/projects
$
</pre><p>Then, make new directories in the repository which will
        encapsulate the contents of each of the three previous
        repositories:</p><pre class="screen">
$ svn mkdir -m "Initial project roots" \
      file:///path/to/projects/calc \
      file:///path/to/projects/calendar \
      file:///path/to/projects/spreadsheet
Committed revision 1.
$ 
</pre><p>Lastly, load the individual dump files into their
        respective locations in the new repository:</p><pre class="screen">
$ svnadmin load /path/to/projects --parent-dir calc &lt; calc-dumpfile
&#8230;
$ svnadmin load /path/to/projects --parent-dir calendar &lt; cal-dumpfile
&#8230;
$ svnadmin load /path/to/projects --parent-dir spreadsheet &lt; ss-dumpfile
&#8230;
$
</pre><p>We'll mention one final way to use the Subversion
        repository dump format&#8212;conversion from a different
        storage mechanism or version control system altogether.
        Because the dump file format is, for the most part,
        human-readable,
        <sup>[<a name="id933372" href="#ftn.id933372">16</a>]</sup>
        it should be relatively easy to describe generic sets of
        changes&#8212;each of which should be treated as a new
        revision&#8212;using this file format.  In fact, the
        <span><b class="command">cvs2svn.py</b></span> utility (see <a href="#svn-ap-a-sect-11" title="Converting a Repository from CVS to Subversion">the section called &#8220;Converting a Repository from CVS to Subversion&#8221;</a>) uses the dump format to represent the
        contents of a CVS repository so that those contents can be
        moved in a Subversion repository.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-3.6"></a>Repository Backup</h3></div></div><div></div></div><p>Despite numerous advances in technology since the birth of
        the modern computer, one thing unfortunately rings true with
        crystalline clarity&#8212;sometimes, things go very, very
        awry.  Power outages, network connectivity dropouts, corrupt
        RAM and crashed hard drives are but a taste of the evil that
        Fate is poised to unleash on even the most conscientious
        administrator.  And so we arrive at a very important
        topic&#8212;how to make backup copies of your repository
        data.</p><p>There are generally two types of backup methods available
        for Subversion repository administrators&#8212;incremental and
        full.  We discussed in an earlier section of this chapter how
        to use <span><b class="command">svnadmin dump --incremental</b></span> to
        perform an incremental backup (see <a href="#svn-ch-5-sect-3.5" title="Migrating a Repository">the section called &#8220;Migrating a Repository&#8221;</a>).  Essentially, the idea is to
        only backup at a given time the changes to the repository
        since the last time you made a backup.</p><p>A full backup of the repository is quite literally a
        duplication of the entire repository directory (which includes
        either Berkeley database or FSFS environment).  Now, unless
        you temporarily disable all other access to your repository,
        simply doing a recursive directory copy runs the risk of
        generating a faulty backup, since someone might be currently
        writing to the database.</p><p>In the case of Berkeley DB, Sleepycat documents describe a
        certain order in which database files can be copied that will
        guarantee a valid backup copy.  And a similar ordering exists
        for FSFS data.  Better still, you don't have to implement
        these algorithms yourself, because the Subversion development
        team has already done so.  The
        <span><b class="command">hot-backup.py</b></span> script is found in the
        <tt class="filename">tools/backup/</tt> directory of the Subversion
        source distribution.  Given a repository path and a backup
        location, <span><b class="command">hot-backup.py</b></span>&#8212;which is
        really just a more intelligent wrapper around the
        <span><b class="command">svnadmin hotcopy</b></span> command&#8212;will perform
        the necessary steps for backing up your live
        repository&#8212;without requiring that you bar public
        repository access at all&#8212;and then will clean out the
        dead Berkeley log files from your live repository.</p><p>Even if you also have an incremental backup, you might
        want to run this program on a regular basis.  For example, you
        might consider adding <span><b class="command">hot-backup.py</b></span> to a
        program scheduler (such as <span><b class="command">cron</b></span> on Unix
        systems).  Or, if you prefer fine-grained backup solutions,
        you could have your post-commit hook script call
        <span><b class="command">hot-backup.py</b></span> (see <a href="#svn-ch-5-sect-2.1" title="Hook Scripts">the section called &#8220;Hook Scripts&#8221;</a>), which will then cause a new
        backup of your repository to occur with every new revision
        created.  Simply add the following to the
        <tt class="filename">hooks/post-commit</tt> script in your live
        repository directory:</p><pre class="programlisting">
(cd /path/to/hook/scripts; ./hot-backup.py ${REPOS} /path/to/backups &amp;)
</pre><p>The resulting backup is a fully functional Subversion
        repository, able to be dropped in as a replacement for your
        live repository should something go horribly wrong.</p><p>There are benefits to both types of backup methods.  The
        easiest is by far the full backup, which will always result in
        a perfect working replica of your repository.  This again
        means that should something bad happen to your live
        repository, you can restore from the backup with a simple
        recursive directory copy.  Unfortunately, if you are
        maintaining multiple backups of your repository, these full
        copies will each eat up just as much disk space as your live
        repository.</p><p>Incremental backups using the repository dump format are
        excellent to have on hand if the database schema changes
        between successive versions of Subversion itself.  Since a
        complete repository dump and load are generally required to
        upgrade your repository to the new schema, it's very
        convenient to already have half of that process (the dump
        part) finished.  Unfortunately, the creation of&#8212;and
        restoration from&#8212;incremental backups takes longer, as
        each commit is effectively replayed into either the dump file
        or the repository.</p><p>In either backup scenario, repository administrators need
        to be aware of how modifications to unversioned revision
        properties affect their backups.  Since these changes do not
        themselves generate new revisions, they will not trigger
        post-commit hooks, and may not even trigger the
        pre-revprop-change and post-revprop-change hooks.
        <sup>[<a name="id933692" href="#ftn.id933692">17</a>]</sup>  
        And since you can change revision properties without respect
        to chronological order&#8212;you can change any revision's
        properties at any time&#8212;an incremental backup of the
        latest few revisions might not catch a property modification
        to a revision that was included as part of a previous 
        backup.</p><p>Generally speaking, only the truly paranoid would need to
        backup their entire repository, say, every time a commit
        occurred.  However, assuming that a given repository has some
        other redundancy mechanism in place with relatively fine
        granularity (like per-commit emails), a hot backup of the
        database might be something that a repository administrator
        would want to include as part of a system-wide nightly backup.
        For most repositories, archived commit emails alone provide
        sufficient redundancy as restoration sources, at least for the
        most recent few commits.  But it's your data&#8212;protect it
        as much as you'd like.</p><p>Often, the best approach to repository backups is a
        diversified one.  You can leverage combinations of full and
        incremental backups, plus archives of commit emails.  The
        Subversion developers, for example, back up the Subversion
        source code repository after every new revision is created,
        and keep an archive of all the commit and property change
        notification emails.  Your solution might be similar, but
        should be catered to your needs and that delicate balance of
        convenience with paranoia.  And while all of this might not
        save your hardware from the iron fist of Fate,
        <sup>[<a name="id933709" href="#ftn.id933709">18</a>]</sup>
        it should certainly help you recover from those trying 
        times.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-6"></a>Adding Projects</h2></div></div><div></div></div><p>Once your repository is created and configured, all that
      remains is to begin using it.  If you have a collection of
      existing data that is ready to be placed under version control,
      you will more than likely want to use the <span><b class="command">svn</b></span>
      client program's <tt class="literal">import</tt> subcommand to
      accomplish that.  Before doing this, though, you should
      carefully consider your long-term plans for the repository.  In
      this section, we will offer some advice on how to plan the
      layout of your repository, and how to get your data arranged in
      that layout.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-6.1"></a>Choosing a Repository Layout</h3></div></div><div></div></div><p>While Subversion allows you to move around versioned files
        and directories without any loss of information, doing so can
        still disrupt the workflow of those who access the repository
        often and come to expect things to be at certain locations.
        Try to peer into the future a bit; plan ahead before placing
        your data under version control.  By &#8220;<span class="quote">laying out</span>&#8221;
        the contents of your repositories in an effective manner the
        first time, you can prevent a load of future headaches.</p><p>There are a few things to consider when setting up
        Subversion repositories.  Let's assume that as repository
        administrator, you will be responsible for supporting the
        version control system for several projects.  The first
        decision is whether to use a single repository for multiple
        projects, or to give each project its own repository, or some
        compromise of these two.</p><p>There are benefits to using a single repository for
        multiple projects, most obviously the lack of duplicated
        maintenance.  A single repository means that there is one set
        of hook scripts, one thing to routinely backup, one thing to
        dump and load if Subversion releases an incompatible new
        version, and so on.  Also, you can move data between projects
        easily, and without losing any historical versioning
        information.</p><p>The downside of using a single repository is that
        different projects may have different commit mailing lists or
        different authentication and authorization requirements.
        Also, remember that Subversion uses repository-global revision
        numbers.  Some folks don't like the fact that even though no
        changes have been made to their project lately, the youngest
        revision number for the repository keeps climbing because
        other projects are actively adding new revisions.</p><p>A middle-ground approach can be taken, too.  For example,
        projects can be grouped by how well they relate to each other.
        You might have a few repositories with a handful of projects
        in each repository.  That way, projects that are likely to
        want to share data can do so easily, and as new revisions are
        added to the repository, at least the developers know that
        those new revisions are at least remotely related to everyone
        who uses that repository.</p><p>After deciding how to organize your projects with respect
        to repositories, you'll probably want to think about directory
        hierarchies in the repositories themselves.  Because
        Subversion uses regular directory copies for branching and
        tagging (see <a href="#svn-ch-4" title="Chapter 4. Branching and Merging">Chapter 4, <i>Branching and Merging</i></a>), the Subversion
        community recommends that you choose a repository location for
        each <i class="firstterm">project root</i>&#8212;the
        &#8220;<span class="quote">top-most</span>&#8221; directory which contains data related
        to that project&#8212;and then create three subdirectories
        beneath that root: <tt class="filename">trunk</tt>, meaning the
        directory under which the main project development occurs;
        <tt class="filename">branches</tt>, which is a directory in which
        to create various named branches of the main development line;
        <tt class="filename">tags</tt>, which is a directory of branches
        that are created, and perhaps destroyed, but never
        changed.</p><p>For example, your repository might look like:</p><pre class="screen">
/
   calc/
      trunk/
      tags/
      branches/
   calendar/
      trunk/
      tags/
      branches/
   spreadsheet/
      trunk/
      tags/
      branches/
   &#8230;
</pre><p>Note that it doesn't matter where in your repository each
        project root is.  If you have only one project per repository,
        the logical place to put each project root is at the root of
        that project's respective repository.  If you have multiple
        projects, you might want to arrange them in groups inside the
        repository, perhaps putting projects with similar goals or
        shared code in the same subdirectory, or maybe just grouping
        them alphabetically.  Such an arrangement might look
        like:</p><pre class="screen">
/
   utils/
      calc/
         trunk/
         tags/
         branches/
      calendar/
         trunk/
         tags/
         branches/
      &#8230;
   office/
      spreadsheet/
         trunk/
         tags/
         branches/
      &#8230;
</pre><p>Lay out your repository in whatever way you see fit.
        Subversion does not expect or enforce a layout schema&#8212;in
        its eyes, a directory is a directory is a directory.
        Ultimately, you should choose the repository arrangement that
        meets the needs of the people who work on the projects that
        live there.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-5-sect-6.2"></a>Creating the Layout, and Importing Initial Data</h3></div></div><div></div></div><p>After deciding how to arrange the projects in your
        repository, you'll probably want to actually populate the
        repository with that layout and with initial project data.
        There are a couple of ways to do this in Subversion.  You
        could use the <span><b class="command">svn mkdir</b></span> command (see <a href="#svn-ch-9" title="Chapter 9. Subversion Complete Reference">Chapter 9, <i>Subversion Complete Reference</i></a>) to create each directory in your
        skeletal repository layout, one-by-one.  A quicker way to
        accomplish the same task is to use the <span><b class="command">svn
        import</b></span> command (see <a href="#svn-ch-3-sect-7.3" title="svn import">the section called &#8220;svn import&#8221;</a>).  By first creating the layout
        in a temporary location on your drive, you can import the
        whole layout tree into the repository in a single
        commit:</p><pre class="screen">
$ mkdir tmpdir
$ cd tmpdir
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags
$ mkdir projectB
$ mkdir projectB/trunk
$ mkdir projectB/branches
$ mkdir projectB/tags
&#8230;
$ svn import . file:///path/to/repos --message 'Initial repository layout'
Adding         projectA
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Adding         projectB
Adding         projectB/trunk
Adding         projectB/branches
Adding         projectB/tags
&#8230;
Committed revision 1.
$ cd ..
$ rm -rf tmpdir
$
</pre><p>You can verify the results of the import by running the
        <span><b class="command">svn list</b></span> command:</p><pre class="screen">
$ svn list --verbose file:///path/to/repos
      1 harry               May 08 21:48 projectA/
      1 harry               May 08 21:48 projectB/
&#8230;
$
</pre><p>Once you have your skeletal layout in place, you can begin
        importing actual project data into your repository, if any
        such data exists yet.  Once again, there are several ways to
        do this.  You could use the <span><b class="command">svn import</b></span>
        command.  You could checkout a working copy from your new
        repository, move and arrange project data inside the working
        copy, and use the <span><b class="command">svn add</b></span> and <span><b class="command">svn
        commit</b></span> commands.  But once we start talking about
        such things, we're no longer discussing repository
        administration.  If you aren't already familiar with the
        <span><b class="command">svn</b></span> client program, see <a href="#svn-ch-3" title="Chapter 3. Guided Tour">Chapter 3, <i>Guided Tour</i></a>.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-5-sect-7"></a>Summary</h2></div></div><div></div></div><p>By now you should have a basic understanding of how to
      create, configure, and maintain Subversion repositories.  We've
      introduced you to the various tools that will assist you with
      this task.  Throughout the chapter, we've noted common
      administration pitfalls, and suggestions for avoiding
      them.</p><p>All that remains is for you to decide what exciting data to
      store in your repository, and finally, how to make it available
      over a network.  The next chapter is all about networking.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id929106" href="#id929106">12</a>] </sup>This may sound really prestigious and lofty, but we're
          just talking about anyone who is interested in that
          mysterious realm beyond the working copy where everyone's
          data hangs out.</p></div><div class="footnote"><p><sup>[<a name="ftn.id931548" href="#id931548">13</a>] </sup>That, by the way, is a <span class="emphasis"><em>feature</em></span>,
              not a bug.</p></div><div class="footnote"><p><sup>[<a name="ftn.id931974" href="#id931974">14</a>] </sup>While <span><b class="command">svnadmin dump</b></span> has a
              consistent leading slash policy&#8212;to not include
              them&#8212;other programs which generate dump data might
              not be so consistent.</p></div><div class="footnote"><p><sup>[<a name="ftn.id932913" href="#id932913">15</a>] </sup>E.g.: hard drive + huge electromagnet = disaster.</p></div><div class="footnote"><p><sup>[<a name="ftn.id933372" href="#id933372">16</a>] </sup>The Subversion repository dump format resembles
            an RFC-822 format, the same type of format used for most
            email.</p></div><div class="footnote"><p><sup>[<a name="ftn.id933692" href="#id933692">17</a>] </sup><span><b class="command">svnadmin setlog</b></span> can be called in a
            way that bypasses the hook interface altogether.</p></div><div class="footnote"><p><sup>[<a name="ftn.id933709" href="#id933709">18</a>] </sup>You know&#8212;the collective term for all of her
            &#8220;<span class="quote">fickle fingers</span>&#8221;.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="svn-ch-6"></a>Chapter 6. Server Configuration</h2></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#svn-ch-6-sect-1">Overview</a></span></dt><dt><span class="sect1"><a href="#svn-ch-6-sect-2">Network Model</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-2.1">Requests and Responses</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-2.2">Client Credentials Caching</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-3">svnserve, a custom server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-3.1">Invoking the Server</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-3.2">Built-in authentication and authorization</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-3.2.1">Create a 'users' file and realm</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-3.2.2">Set access controls</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-3.3">External path-based authorization</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-3.4">SSH authentication and authorization</a></span></dt></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-4">httpd, the Apache HTTP server</a></span></dt><dd><dl><dt><span class="sect2"><a href="#svn-ch-6-sect-4.1">Prerequisites</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.2">Basic Apache Configuration</a></span></dt><dt><span class="sect2"><a href="#svn-ch-6-sect-4.3">Authentication Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.3.1">Basic HTTP Authentication</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.3.2">SSL Certificate Management</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-4.4">Authorization Options</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.4.1">Blanket Access Control</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.4.2">Per-Directory Access Control</a></span></dt></dl></dd><dt><span class="sect2"><a href="#svn-ch-6-sect-4.5">Extra Goodies</a></span></dt><dd><dl><dt><span class="sect3"><a href="#svn-ch-6-sect-4.5.1">Repository Browsing</a></span></dt><dt><span class="sect3"><a href="#svn-ch-6-sect-4.5.2">Other Features</a></span></dt></dl></dd></dl></dd><dt><span class="sect1"><a href="#svn-ch-6-sect-5">Supporting Multiple Repository Access Methods</a></span></dt></dl></div><div class="simplesect" lang="en"><div class="titlepage"><div></div><div></div></div><p>A Subversion repository can be accessed simultaneously by
      clients running on the same machine on which the repository
      resides using the <tt class="literal">file:///</tt> method.  But the
      typical Subversion setup involves a single server machine being
      accessed from clients on computers all over the office&#8212;or,
      perhaps, all over the world.</p><p>This section describes how to get your Subversion repository
      exposed outside its host machine for use by remote clients.  We
      will cover Subversion's currently available server mechanisms,
      discussing the configuration and use of each.  After reading
      this section, you should be able to decide which networking
      setup is right for your needs, and understand how to enable such
      a setup on your host computer.</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-1"></a>Overview</h2></div></div><div></div></div><p>Subversion was designed with an abstract network layer.
      This means that a repository can be programmatically accessed by
      any sort of server process, and the client &#8220;<span class="quote">repository
      access</span>&#8221; API allows programmers to write plugins that
      speak relevant network protocols.  In theory, Subversion can use
      an infinite number of network implementations.  In practice,
      there are only two servers at the time of writing.</p><p>Apache is an extremely popular webserver; using the
      <span><b class="command">mod_dav_svn</b></span> module, Apache can access a
      repository and make it available to clients via the WebDAV/DeltaV
      protocol, which is an extension of HTTP.  In the other corner is
      <span><b class="command">svnserve</b></span>: a small, standalone server
      program that speaks a custom protocol with clients.  Table 6-1
      presents a comparison of the two servers.</p><p>Note that Subversion, as an open-source project, does not
      officially endorse any server as &#8220;<span class="quote">primary</span>&#8221; or
      &#8220;<span class="quote">official</span>&#8221;.  Neither network implementation is
      treated as a second-class citizen; each server has advantages
      and disadvantages.  In fact, it's possible for different servers
      to run in parallel, each accessing your repositories in its own
      way, and each without hindering the other (see <a href="#svn-ch-6-sect-5" title="Supporting Multiple Repository Access Methods">the section called &#8220;Supporting Multiple Repository Access Methods&#8221;</a>).  Here's a brief overview and
      comparison of the two available Subversion servers&#8212;as an
      administrator, it's up to you to choose whatever works best for
      you and your users.</p><div class="table"><a name="svn-ch-6-table-1"></a><p class="title"><b>Table 6.1. Network Server Comparison</b></p><table summary="Network Server Comparison" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Feature</th><th>Apache + mod_dav_svn</th><th>svnserve</th></tr></thead><tbody><tr><td>Authentication options</td><td>HTTP(S) basic auth, X.509 certificates, LDAP, NTLM, or
              any other mechanism available to Apache httpd</td><td>CRAM-MD5 or SSH</td></tr><tr><td>User account options</td><td>private 'users' file</td><td>private 'users' file, or existing system (SSH)
              accounts</td></tr><tr><td>Authorization options</td><td>blanket read/write access, or per-directory
              read/write control</td><td>blanket read/write access, or per-directory write
              (but not read) control using a pre-commit hook</td></tr><tr><td>Encryption</td><td>via optional SSL</td><td>via optional SSH tunnel</td></tr><tr><td>Interoperability</td><td>partially usable by other WebDAV clients</td><td>not interoperable</td></tr><tr><td>Web viewing</td><td>limited built-in support, or via 3rd-party tools
              such as ViewCVS</td><td>via 3rd-party tools such as ViewCVS</td></tr><tr><td>Speed</td><td>somewhat slower</td><td>somewhat faster</td></tr><tr><td>Initial setup</td><td>somewhat complex</td><td>fairly simple</td></tr></tbody></table></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-2"></a>Network Model</h2></div></div><div></div></div><p>This section is a general discussion of how a Subversion
      client and server interact with one another, regardless of the
      network implementation you're using.  After reading, you'll have
      a good understanding of how a server can behave and the
      different ways in which a client can be configured to
      respond.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-2.1"></a>Requests and Responses</h3></div></div><div></div></div><p>The Subversion client spends most of its time managing
        working copies.  When it needs information from a repository,
        however, it makes a network request, and the server responds
        with an appropriate answer.  The details of the network
        protocol are hidden from the user; the client attempts to
        access a URL, and depending on the URL schema, a particular
        protocol is used to contact the server (see <a href="#svn-ch-2-sidebar-1" title="Repository URLs">Repository URLs</a>).  Users can run <span><b class="command">svn
        --version</b></span> to see which URL schemas and protocols the
        client knows how to use.</p><p>When the server process receives a client request, it
        typically demands that the client identify itself.  It issues
        an authentication challenge to the client, and the client
        responds by providing <i class="firstterm">credentials</i> back
        to the server.  Once authentication is complete, the server
        responds with the original information the client asked for.
        Notice that this system is different from systems like CVS,
        where the client pre-emptively offers credentials (&#8220;<span class="quote">logs
        in</span>&#8221;) to the server before ever making a request.  In
        Subversion, the server &#8220;<span class="quote">pulls</span>&#8221; credentials by
        challenging the client at the appropriate moment, rather than
        the client &#8220;<span class="quote">pushing</span>&#8221; them.  This makes certain
        operations more elegant.  For example, if a server is
        configured to allow anyone in the world to read a repository,
        then the server will never issue an authentication challenge
        when a client attempts to <span><b class="command">svn
        checkout</b></span>.</p><p>If the client's network request writes new data to the
        repository (e.g. <span><b class="command">svn commit</b></span>), then a new
        revision tree is created.  If the client's request was
        authenticated, then the authenticated user's name is stored as
        the value of the <tt class="literal">svn:author</tt> property on the
        new revision (see <a href="#svn-ch-5-sect-1.2" title="Unversioned Properties">the section called &#8220;Unversioned Properties&#8221;</a>).  If
        the client was not authenticated (in other words, the server
        never issued an authentication challenge), then the revision's
        <tt class="literal">svn:author</tt> property is empty.
        <sup>[<a name="id939940" href="#ftn.id939940">19</a>]</sup></p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-2.2"></a>Client Credentials Caching</h3></div></div><div></div></div><p>Many servers are configured to require authentication on
        every request.  This can become a big annoyance to users, who
        are forced to type their passwords over and over again.</p><p>Happily, the Subversion client has a remedy for this: a
        built-in system for caching authentication credentials on
        disk.  By default, whenever the command-line client
        successfully authenticates itself to a server, it saves the
        credentials in the user's private runtime configuration
        area&#8212;in <tt class="filename">~/.subversion/auth/</tt> on
        Unix-like systems or
        <tt class="filename">%APPDATA%/Subversion/auth/</tt> on Windows.
        (The runtime area is covered in more detail in <a href="#svn-ch-7-sect-1" title="Runtime Configuration Area">the section called &#8220;Runtime Configuration Area&#8221;</a>.)  Successful credentials are
        cached on disk, keyed on a combination of hostname, port, and
        authentication realm.</p><p>When the client receives an authentication challenge, it
        first looks for the appropriate credentials in the disk cache;
        if not present, or if the cached credentials fail to
        authenticate, then the client simply prompts the user for the
        information.</p><p>The security-paranoid people may be thinking to
        themselves, &#8220;<span class="quote">Caching passwords on disk?  That's
        terrible!  You should never do that!</span>&#8221;  But please remain
        calm.  First, the <tt class="filename">auth/</tt> caching area is
        permission-protected so that only the user (owner) can read
        data from it, not the world at large.  If that's still not
        safe enough for you, you can disable credential caching.  To
        disable caching for a single command, pass the
        <tt class="option">--no-auth-cache</tt> option:</p><pre class="screen">
$ svn commit -F log_msg.txt --no-auth-cache
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
Password for 'joe':

Adding         newfile
Transmitting file data .
Committed revision 2324.

# password was not cached, so a second commit still prompts us

$ svn delete newfile
$ svn commit -F new_msg.txt
Authentication realm: &lt;svn://host.example.com:3690&gt; example realm
Username:  joe
[...]
</pre><p>Or, if you want to disable credential caching permanently,
        you can edit your runtime <tt class="filename">config</tt> file
        (located next to the <tt class="filename">auth/</tt> directory).
        Simply set <tt class="literal">store-auth-creds</tt> to
        <tt class="literal">no</tt>, and no credentials will be cached on
        disk, ever.</p><pre class="screen">
[auth]
store-auth-creds = no
</pre><p>Sometimes users will want to remove specific credentials
        from the disk cache.  To do this, you need to navigate into
        the <tt class="filename">auth/</tt> area and manually delete the
        appropriate cache file.  Credentials are cached in individual
        files;  if you look inside each file, you will see keys and
        values.  The <tt class="literal">svn:realmstring</tt> key describes
        the particular server realm that the file is associated
        with:</p><pre class="screen">
$ ls ~/.subversion/auth/svn.simple/
5671adf2865e267db74f09ba6f872c28        
3893ed123b39500bca8a0b382839198e
5c3c22968347b390f349ff340196ed39

$ cat ~/.subversion/auth/svn.simple/5671adf2865e267db74f09ba6f872c28

K 8
username
V 3
joe
K 8
password
V 4
blah
K 15
svn:realmstring
V 45
&lt;https://svn.domain.com:443&gt; Joe's repository
END
</pre><p>Once you have located the proper cache file, just delete
        it.</p><p>One last word about client authentication behavior: a bit
        of explanation about the <tt class="option">--username</tt> and
        <tt class="option">--password</tt> options is needed.  Many client
        subcommands accept these options; however it is important to
        understand using these options <span class="emphasis"><em>does not</em></span>
        automatically send credentials to the server.  As discussed
        earlier, the server &#8220;<span class="quote">pulls</span>&#8221; credentials from the
        client when it deems necessary; the client cannot
        &#8220;<span class="quote">push</span>&#8221; them at will.  If a username and/or
        password are passed as options, they will
        <span class="emphasis"><em>only</em></span> be presented to the server if the
        server requests them.

         <sup>[<a name="id940126" href="#ftn.id940126">20</a>]</sup>
        
        Typically, these options are used when:</p><div class="itemizedlist"><ul type="disc"><li><p>the user wants to authenticate as a different user
            than her system login name, or</p></li><li><p>a script wants to authenticate without using cached
            credentials.</p></li></ul></div><p>Here is a final summary that describes how a Subversion
        client behaves when it receives an authentication
        challenge:</p><div class="orderedlist"><ol type="1"><li><p>Check whether the user specified any credentials as
            command-line options, via <tt class="option">--username</tt>
            and/or <tt class="option">--password</tt>.  If not, or if these
            options fail to authenticate successfully, then</p></li><li><p>Look up the server's realm in the runtime
            <tt class="filename">auth/</tt> area, to see if the user already
            has the appropriate credentials cached.  If not, or if the
            cached credentials fail to authenticate, then</p></li><li><p>Resort to prompting the user.</p></li></ol></div><p>If the client successfully authenticates by any of the
        methods listed above, it will attempt to cache the credentials
        on disk (unless the user has disabled this behavior, as
        mentioned earlier.)</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-3"></a>svnserve, a custom server</h2></div></div><div></div></div><p>The <span><b class="command">svnserve</b></span> program is a lightweight
      server, capable of speaking to clients over TCP/IP using a
      custom, stateful protocol.  Clients contact an
      <span><b class="command">svnserve</b></span> server by using URLs that begin with
      the <tt class="literal">svn://</tt> or <tt class="literal">svn+ssh://</tt>
      schema.  This section will explain the different ways of running
      <span><b class="command">svnserve</b></span>, how clients authenticate themselves
      to the server, and how to configure appropriate access control
      to your repositories.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-3.1"></a>Invoking the Server</h3></div></div><div></div></div><p>There a few different ways to invoke the
        <span><b class="command">svnserve</b></span> program.  If invoked with no
        options, you'll see nothing but a help message.  However, if
        you're planning to have <span><b class="command">inetd</b></span> launch the
        process, then you can pass the <tt class="option">-i</tt>
        (<tt class="option">--inetd</tt>) option:</p><pre class="screen">
$ svnserve -i
( success ( 1 2 ( ANONYMOUS ) ( edit-pipeline ) ) )
</pre><p>When invoked with the <tt class="option">--inetd</tt> option,
        <span><b class="command">svnserve</b></span> attempts to speak with a
        Subversion client via <span class="emphasis"><em>stdin</em></span> and
        <span class="emphasis"><em>stdout</em></span> using a custom protocol.  This is
        the standard behavior for a program being run via
        <span><b class="command">inetd</b></span>.  The IANA has reserved port 3690
        for the Subversion protocol, so on a Unix-like system you can
        add lines to <tt class="filename">/etc/services</tt> like these (if
        they don't already exist):</p><pre class="screen">
svn           3690/tcp   # Subversion
svn           3690/udp   # Subversion
</pre><p>And if your system is using a classic Unix-like
        <span><b class="command">inetd</b></span> daemon, you can add this line to
        <tt class="filename">/etc/inetd.conf</tt>:</p><pre class="screen">
svn stream tcp nowait svnowner /usr/local/bin/svnserve svnserve -i
</pre><p>Make sure &#8220;<span class="quote">svnowner</span>&#8221; is a user which has
        appropriate permissions to access your repositories.  Now, when
        a client connection comes into your server on port 3690,
        <span><b class="command">inetd</b></span> will spawn an
        <span><b class="command">svnserve</b></span> process to service it.</p><p>On a Windows system, third-party tools exist to run
      <span><b class="command">svnserve</b></span> as a service.  Look on Subversion's
      website for a list of these tools.</p><p>A second option is to run <span><b class="command">svnserve</b></span> as a
        standalone &#8220;<span class="quote">daemon</span>&#8221; process.  Use the
        <tt class="option">-d</tt> option for this:</p><pre class="screen">
$ svnserve -d
$               # svnserve is now running, listening on port 3690
</pre><p>When running <span><b class="command">svnserve</b></span> in daemon mode,
        you can use the <tt class="option">--listen-port=</tt> and
        <tt class="option">--listen-host=</tt> options to customize the exact
        port and hostname to &#8220;<span class="quote">bind</span>&#8221; to.</p><p>There's still a third way to invoke
        <span><b class="command">svnserve</b></span>, and that's in &#8220;<span class="quote">tunnel
        mode</span>&#8221;, with the <tt class="option">-t</tt> option.  This mode
        assumes that a remote-service program such as
        <span><b class="command">RSH</b></span> or <span><b class="command">SSH</b></span> has
        successfully authenticated a user and is now invoking a
        private <span><b class="command">svnserve</b></span> process <span class="emphasis"><em>as that
        user</em></span>.  The <span><b class="command">svnserve</b></span> program
        behaves normally (communicating via <span class="emphasis"><em>stdin</em></span>
        and <span class="emphasis"><em>stdout</em></span>), and assumes that the traffic
        is being automatically redirected over some sort of tunnel
        back to the client.  When <span><b class="command">svnserve</b></span> is
        invoked by a tunnel agent like this, be sure that the
        authenticated user has full read and write access to the
        repository database files. (See <a href="#svn-ch-6-sidebar-1" title="Servers and Permissions:  A Word of Warning">Servers and Permissions:  A Word of Warning</a>.)  It's essentially the same as
        a local user accessing the repository via
        <tt class="literal">file:///</tt> URLs.</p><div class="sidebar"><a name="svn-ch-6-sidebar-1"></a><p class="title"><b>Servers and Permissions:  A Word of Warning</b></p><p>First, remember that a Subversion repository is a
          collection of BerkeleyDB database files; any process which
          accesses the repository directly needs to have proper read
          and write permissions on the entire repository.  If you're
          not careful, this can lead to a number of headaches.  Be
          sure to read <a href="#svn-ch-6-sect-5" title="Supporting Multiple Repository Access Methods">the section called &#8220;Supporting Multiple Repository Access Methods&#8221;</a>.</p><p>Secondly, when configuring <span><b class="command">svnserve</b></span>,
          Apache <span><b class="command">httpd</b></span>, or any other server
          process, keep in mind that you might not want to launch the
          server process as the user <tt class="literal">root</tt> (or as
          any other user with unlimited permissions).  Depending on
          the ownership and permissions of the repositories you're
          exporting, it's often prudent to use a
          different&#8212;perhaps custom&#8212;user.  For example,
          many administrators create a new user named
          <tt class="literal">svn</tt>, grant that user exclusive ownership
          and rights to the exported Subversion repositories, and only
          run their server processes as that user.</p></div><p>Once the <span><b class="command">svnserve</b></span> program is running,
        it makes every repository on your system available to the
        network.  A client needs to specify an
        <span class="emphasis"><em>absolute</em></span> path in the repository URL.  For
        example, if a repository is located at
        <tt class="filename">/usr/local/repositories/project1</tt>, then a
        client would reach it via <tt class="systemitem">svn://host.example.com/usr/local/repositories/project1
        </tt>.  To increase security, you can pass the
        <tt class="option">-r</tt> option to <span><b class="command">svnserve</b></span>,
        which restricts it to exporting only repositories below that
        path:</p><pre class="screen">
$ svnserve -d -r /usr/local/repositories
&#8230;
</pre><p>Using the <tt class="option">-r</tt> option effectively
        modifies the location that the program treats as the root of
        the remote filesystem space.  Clients then use URLs that
        have that path portion removed from them, leaving much
        shorter (and much less revealing) URLs:</p><pre class="screen">
$ svn checkout svn://host.example.com/project1
&#8230;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-3.2"></a>Built-in authentication and authorization</h3></div></div><div></div></div><p>When a client connects to an <span><b class="command">svnserve</b></span>
        process, the following things happen:</p><div class="itemizedlist"><ul type="disc"><li><p>The client selects a specific
        repository.</p></li><li><p>The server processes the repository's
        <tt class="filename">conf/svnserve.conf</tt> file, and begins to
        enforce any authentication and authorization policies defined
        therein.</p></li><li><p>Depending on the situation and authorization
        policies,</p><div class="itemizedlist"><ul type="circle"><li><p>the client may be allowed to make requests
              anonymously, without ever receiving an authentication
              challenge, OR</p></li><li><p>the client may be challenged for
              authentication at any time, OR</p></li><li><p>if operating in &#8220;<span class="quote">tunnel
              mode</span>&#8221;, the client will declare itself to be
              already externally authenticated.</p></li></ul></div></li></ul></div><p>At the time of writing, the server only knows how to send
        a CRAM-MD5 <sup>[<a name="id940753" href="#ftn.id940753">21</a>]</sup>
        authentication challenge.  In essence, the server sends a bit
        of data to the client.  The client uses the MD5 hash algorithm
        to create a fingerprint of the data and password combined,
        then sends the fingerprint as a response.  The server performs
        the same computation with the stored password to verify that
        the result is identical.  <span class="emphasis"><em>At no point does the
        actual password travel over the network.</em></span></p><p>It's also possible, of course, for the client to be
        externally authenticated via a tunnel agent, such as
        <span><b class="command">SSH</b></span>.  In that case, the server simply
        examines the user it's running as, and uses it as the
        authenticated username.</p><p>As you've already guessed, a repository's
        <tt class="filename">svnserve.conf</tt> file is the central
        mechanism for controlling authentication and authorization
        policies.  The file has the same format as other configuration
        files (see <a href="#svn-ch-7-sect-1" title="Runtime Configuration Area">the section called &#8220;Runtime Configuration Area&#8221;</a>): section names
        are marked by square brackets (<tt class="literal">[</tt> and
        <tt class="literal">]</tt>), comments begin with hashes
        (<tt class="literal">#</tt>), and each section contains
        specific variables that can be set (<tt class="literal">variable =
        value</tt>).  Let's walk through this file and learn how
        to use them.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-3.2.1"></a>Create a 'users' file and realm</h4></div></div><div></div></div><p>For now, the <tt class="literal">[general]</tt> section of the
          <tt class="filename">svnserve.conf</tt> has all the variables you
          need.  Begin by defining a file which contains usernames and
          passwords, and an authentication realm:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm
</pre><p>The <tt class="literal">realm</tt> is a name that you define.
          It tells clients which sort of &#8220;<span class="quote">authentication
          namespace</span>&#8221; they're connecting to; the Subversion
          client displays it in the authentication prompt, and uses it
          as a key (along with the server's hostname and port) for
          caching credentials on disk (see <a href="#svn-ch-6-sect-2.2" title="Client Credentials Caching">the section called &#8220;Client Credentials Caching&#8221;</a>.)  The
          <tt class="literal">password-db</tt> variable points to a separate
          file that contains a list of usernames and passwords, using
          the same familiar format.  For example:</p><pre class="screen">
[users]
harry = foopassword
sally = barpassword
</pre><p>The value of <tt class="literal">password-db</tt> can be an
          absolute or relative path to the users file.  For many
          admins, it's easy to keep the file right in the
          <tt class="filename">conf/</tt> area of the repository, alongside
          <tt class="filename">svnserve.conf</tt>.  On the other hand, it's
          possible you may want to have two or more repositories share
          the same users file; in that case, the file should probably
          live in a more public place.  The repositories sharing the
          users file should also be configured to have the same realm,
          since the list of users essentially defines an
          authentication realm.  Wherever the file lives, be sure to
          set the file's read and write permissions appropriately.  If
          you know which user(s) <span><b class="command">svnserve</b></span> will run
          as, restrict read access to the user file as necessary.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-3.2.2"></a>Set access controls</h4></div></div><div></div></div><p>There are two more variables to set in the
          <tt class="filename">svnserve.conf</tt> file: they determine what
          unauthenticated (anonymous) and authenticated users are
          allowed to do.  The variables <tt class="literal">anon-access</tt>
          and <tt class="literal">auth-access</tt> can be set to the values
          <tt class="literal">none</tt>, <tt class="literal">read</tt>, or
          <tt class="literal">write</tt>.  Setting the value to
          <tt class="literal">none</tt> restricts all access of any kind;
          <tt class="literal">read</tt> allows read-only access to the
          repository, and <tt class="literal">write</tt> allows complete
          read/write access to the repository.  For example:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm

# anonymous users can only read the repository
anon-access = read

# authenticated users can both read and write
auth-access = write
</pre><p>The example settings are, in fact, the default values of
          the variables, should you forget to define them.  If you
          want to be even more conservative, you can block anonymous
          access completely:</p><pre class="screen">
[general]
password-db = userfile
realm = example realm

# anonymous users aren't allowed
anon-access = none

# authenticated users can both read and write
auth-access = write
</pre><p>Notice that <span><b class="command">svnserve</b></span> only understands
          &#8220;<span class="quote">blanket</span>&#8221; access control.  A user either has
          universal read/write access, universal read access, or no
          access.  There is no detailed control over access to
          specific paths within the repository.  For many projects and
          sites, this level of access control is more than adequate.
          However, if you need per-directory access control, you'll
          need to use Apache instead of <span><b class="command">svnserve</b></span> as
          your server process.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-3.3"></a>External path-based authorization</h3></div></div><div></div></div><p>While <span><b class="command">svnserve</b></span> itself does not provide
        any means to control per-path authorization, a pre-commit hook
        can be used to enforce per-path write access control. The
        Subversion distribution comes with
        <span><b class="command">commit-access-control.pl</b></span> and the more
        sophisticated <span><b class="command">svnperms.py</b></span> scripts for use
        in pre-commit scripts.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-3.4"></a>SSH authentication and authorization</h3></div></div><div></div></div><p><span><b class="command">svnserve</b></span>'s built-in authentication can
        be very handy, because it avoids the need to create real
        system accounts.  On the other hand, some administrators
        already have well-established SSH authentication frameworks in
        place.  In these situations, all of the project's users
        already have system accounts and the ability to &#8220;<span class="quote">SSH
        into</span>&#8221; the server machine.</p><p>It's easy to use SSH in conjunction with
        <span><b class="command">svnserve</b></span>.  The client simply uses the
        <tt class="literal">svn+ssh://</tt> URL schema to connect:</p><pre class="screen">
$ whoami
harry

$ svn list svn+ssh://host.example.com/repos/project
harry@host.example.com's password:  *****

foo
bar
baz
&#8230;
</pre><p>What's happening here is that the Subversion client is
        invoking a local <span><b class="command">ssh</b></span> process, connecting to
        <tt class="literal">host.example.com</tt>, authenticating as the user
        <tt class="literal">harry</tt>, then spawning a private
        <span><b class="command">svnserve</b></span> process on the remote machine,
        running as the user <tt class="literal">harry</tt>.  The
        <span><b class="command">svnserve</b></span> command is being invoked in tunnel
        mode (<tt class="option">-t</tt>) and its network protocol is being
        &#8220;<span class="quote">tunneled</span>&#8221; over the encrypted connection by
        <span><b class="command">ssh</b></span>, the tunnel-agent.
        <span><b class="command">svnserve</b></span> is aware that it's running as the user
        <tt class="literal">harry</tt>, and if the client performs a commit,
        the authenticated username will be attributed as the author of
        the new revision.</p><p>When running over a tunnel, authorization is primarily
        controlled by operating system permissions to the repository's
        database files; it's very much the same as if Harry were
        accessing the repository directly via a
        <tt class="literal">file:///</tt> URL.  If multiple system users are
        going to be accessing the repository directly, you may want to
        place them into a common group, and you'll need to be careful
        about umasks.  (Be sure to read <a href="#svn-ch-6-sect-5" title="Supporting Multiple Repository Access Methods">the section called &#8220;Supporting Multiple Repository Access Methods&#8221;</a>.)  But even in the case of
        tunneling, the <tt class="filename">svnserve.conf</tt> file can
        still be used to block access, by simply setting
        <tt class="literal">auth-access = read</tt> or <tt class="literal">auth-access
        = none</tt>.</p><p>You'd think that the story of SSH tunneling would end
        here, but it doesn't.  Subversion allows you to create custom
        tunnel behaviors in your run-time <tt class="filename">config</tt>
        file (see <a href="#svn-ch-7-sect-1" title="Runtime Configuration Area">the section called &#8220;Runtime Configuration Area&#8221;</a>.)  For example,
        suppose you want to use RSH instead of SSH.  In the
        <tt class="literal">[tunnels]</tt> section of your
        <tt class="filename">config</tt> file, simply define it like
        this:</p><pre class="screen">
[tunnels]
rsh = rsh
</pre><p>And now, you can use this new tunnel definition by using a
        URL schema that matches the name of your new variable:
        <tt class="literal">svn+rsh://host/path</tt>.  When using the new
        URL schema, the Subversion client will actually be running the
        command <span><b class="command">rsh host svnserve -t</b></span> behind the
        scenes.  If you include a username in the URL (for example,
        <tt class="literal">svn+rsh://username@host/path</tt>) the client
        will also include that in its command (<span><b class="command">rsh
        username@host svnserve -t</b></span>.)  But you can define new
        tunneling schemes to be much more clever than that:</p><pre class="screen">
[tunnels]
joessh = $JOESSH /opt/alternate/ssh -p 29934
</pre><p>This example demonstrates a couple of things.  First, it
        shows how to make the Subversion client launch a very specific
        tunneling binary (the one located at
        <tt class="filename">/opt/alternate/ssh</tt>) with specific
        options.  In this case, accessing a
        <tt class="literal">svn+joessh://</tt> URL would invoke the
        particular SSH binary with <tt class="option">-p 29934</tt> as
        arguments&#8212;useful if you want the tunnel program to
        connect to a non-standard port.</p><p>Second, it shows how to define a custom environment
        variable that can override the name of the tunneling program.
        Setting the <tt class="literal">SVN_SSH</tt> environment variable is
        a convenient way to override the default SSH tunnel agent.
        But if you need to have several different overrides for
        different servers, each perhaps contacting a different port or
        passing a different set of options, you can use the mechanism
        demonstrated in this example.  Now if we were to set the
        <tt class="literal">JOESSH</tt> environment variable, its value
        would override the entire value of the tunnel
        variable&#8212;<span><b class="command">$JOESSH</b></span> would be executed
        instead of <span><b class="command">/opt/alternate/ssh -p 29934</b></span>.</p><p>A final note: when using <tt class="literal">svn+ssh://</tt>
        URLs to access a repository, remember that it's the
        <span><b class="command">ssh</b></span> program prompting you for
        authentication, and <span class="emphasis"><em>not</em></span> the
        <span><b class="command">svn</b></span> program.  That means there's no
        automatic password caching going on (see <a href="#svn-ch-6-sect-2.2" title="Client Credentials Caching">the section called &#8220;Client Credentials Caching&#8221;</a>).  If you want to prevent
        <span><b class="command">ssh</b></span> from repeatedly asking for your
        password, you'll need to use a separate memory-caching tool
        like <span><b class="command">ssh-agent</b></span> on a Unix-like system, or
        <span><b class="command">pageant</b></span> on Windows.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="svn-ch-6-sect-4"></a>httpd, the Apache HTTP server</h2></div></div><div></div></div><p>The Apache HTTP Server is a &#8220;<span class="quote">heavy duty</span>&#8221;
      network server that Subversion can leverage.  Via a custom
      module, <span><b class="command">httpd</b></span> makes Subversion repositories
      available to clients via the WebDAV/DeltaV protocol, which is an
      extension to HTTP 1.1 (see <tt class="systemitem">http://www.webdav.org/</tt> for more
      information.) This protocol takes the ubiquitous HTTP protocol
      that is the core of the World Wide Web, and adds
      writing&#8212;specifically, versioned
      writing&#8212;capabilities.  The result is a standardized,
      robust system that is conveniently packaged as part of the
      Apache 2.0 software, is supported by numerous operating systems
      and third-party products, and doesn't require network
      administrators to open up yet another custom port.
      <sup>[<a name="id941491" href="#ftn.id941491">22</a>]</sup>
      While an Apache-Subversion server has more features than
      <span><b class="command">svnserve</b></span>, it's also a bit more difficult
      to set up.  With flexibility often comes more complexity.</p><p>Much of the following discussion includes references to
      Apache configuration directives.  While some examples are given
      of the use of these directives, describing them in full is
      outside the scope of this chapter.  The Apache team maintains
      excellent documentation, publicly available on their website at
      <tt class="systemitem">http://httpd.apache.org</tt>.
      For example, a general reference for the configuration
      directives is located at <tt class="systemitem">
      http://httpd.apache.org/docs-2.0/mod/directives.html</tt>.</p><p>Also, as you make changes to your Apache setup, it is likely
      that somewhere along the way a mistake will be made.  If you are
      not already familiar with Apache's logging subsystem, you should
      become aware of it.  In your <tt class="filename">httpd.conf</tt>
      file are directives that specify the on-disk locations of the
      access and error logs generated by Apache (the
      <tt class="literal">CustomLog</tt> and <tt class="literal">ErrorLog</tt>
      directives, respectively).  Subversion's mod_dav_svn uses
      Apache's error logging interface as well.  You can always browse
      the contents of those files for information that might reveal
      the source of a problem that is not clearly noticeable
      otherwise.</p><div class="sidebar"><p class="title"><b>Why Apache 2?</b></p><p>If you're a system administrator, it's very likely that
        you're already running the Apache web server and have some
        prior experience with it.  At the time of writing, Apache 1.3
        is by far the most popular version of Apache.  The world has
        been somewhat slow to upgrade to the Apache 2.X series for
        various reasons: some people fear change, especially changing
        something as critical as a web server.  Other people depend on
        plug-in modules that only work against the Apache 1.3 API, and
        are waiting for a 2.X port.  Whatever the reason, many people
        begin to worry when they first discover that Subversion's
        Apache module is written specifically for the Apache 2 API.</p><p>The proper response to this problem is: don't worry about
        it.  It's easy to run Apache 1.3 and Apache 2 side-by-side;
        simply install them to separate places, and use Apache 2 as a
        dedicated Subversion server that runs on a port other than 80.
        Clients can access the repository by placing the port number
        into the URL:</p><pre class="screen">
$ svn checkout http://host.example.com:7382/repos/project
&#8230;
</pre></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.1"></a>Prerequisites</h3></div></div><div></div></div><p>To network your repository over HTTP, you basically need
        four components, available in two packages.  You'll need
        Apache <span><b class="command">httpd</b></span> 2.0, the
        <span><b class="command">mod_dav</b></span> DAV module that comes with it,
        Subversion, and the <span><b class="command">mod_dav_svn</b></span>
        filesystem provider module distributed with Subversion.
        Once you have all of those components, the process of
        networking your repository is as simple as:</p><div class="itemizedlist"><ul type="disc"><li><p>getting httpd 2.0 up and running with the mod_dav
            module,</p></li><li><p>installing the mod_dav_svn plugin to mod_dav, which
            uses Subversion's libraries to access the repository,
            and</p></li><li><p>configuring your <tt class="filename">httpd.conf</tt>
            file to export (or expose) the repository.</p></li></ul></div><p>You can accomplish the first two items either by
        compiling <span><b class="command">httpd</b></span> and Subversion from
        source code, or by installing pre-built binary packages of
        them on your system.  For the most up-to-date information on
        how to compile Subversion for use with the Apache HTTP Server,
        as well as how to compile and configure Apache itself for
        this purpose, see the <tt class="filename">INSTALL</tt> file in
        the top level of the Subversion source code tree.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.2"></a>Basic Apache Configuration</h3></div></div><div></div></div><p>Once you have all the necessary components installed on
        your system, all that remains is the configuration of Apache
        via its <tt class="filename">httpd.conf</tt> file.  Instruct Apache
        to load the mod_dav_svn module using the
        <tt class="literal">LoadModule</tt> directive.  This directive must
        precede any other Subversion-related configuration items.  If
        your Apache was installed using the default layout, your
        <span><b class="command">mod_dav_svn</b></span> module should have been
        installed in the <tt class="filename">modules</tt> subdirectory of
        the Apache install location (often
        <tt class="filename">/usr/local/apache2</tt>).  The
        <tt class="literal">LoadModule</tt> directive has a simple syntax,
        mapping a named module to the location of a shared library on
        disk:</p><pre class="screen">
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>Note that if <span><b class="command">mod_dav</b></span> was compiled as a
        shared object (instead of statically linked directly to the
        <span><b class="command">httpd</b></span> binary), you'll need a similar
        <tt class="literal">LoadModule</tt> statement for it, too.  Be sure
        that it comes before the <span><b class="command">mod_dav_svn</b></span> line:</p><pre class="screen">
LoadModule dav_module         modules/mod_dav.so
LoadModule dav_svn_module     modules/mod_dav_svn.so
</pre><p>At a later location in your configuration file, you now
        need to tell Apache where you keep your Subversion repository
        (or repositories).  The <tt class="literal">Location</tt> directive
        has an XML-like notation, starting with an opening tag, and
        ending with a closing tag, with various other configuration
        directives in the middle.  The purpose of the
        <tt class="literal">Location</tt> directive is to instruct Apache to
        do something special when handling requests that are directed
        at a given URL or one of its children.  In the case of
        Subversion, you want Apache to simply hand off support for
        URLs that point at versioned resources to the DAV layer.  You
        can instruct Apache to delegate the handling of all URLs whose
        path portions (the part of the URL that follows the server's
        name and the optional port number) begin with
        <tt class="filename">/repos/</tt> to a DAV provider whose
        repository is located at
        <tt class="filename">/absolute/path/to/repository</tt> using the
        following <tt class="filename">httpd.conf</tt> syntax:</p><pre class="screen">
&lt;Location /repos&gt;
  DAV svn
  SVNPath /absolute/path/to/repository
&lt;/Location&gt;
</pre><p>If you plan to support multiple Subversion repositories
        that will reside in the same parent directory on your local
        disk, you can use an alternative directive, the
        <tt class="literal">SVNParentPath</tt> directive, to indicate that
        common parent directory.  For example, if you know you will be
        creating multiple Subversion repositories in a directory
        <tt class="filename">/usr/local/svn</tt> that would be accessed via
        URLs like <tt class="systemitem">http://my.server.com/svn/repos1</tt>,
        <tt class="systemitem">http://my.server.com/svn/repos2</tt>, and
        so on, you could use the <tt class="filename">httpd.conf</tt>
        configuration syntax in the following example:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn

  # any "/svn/foo" URL will map to a repository /usr/local/svn/foo
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>Using the previous syntax, Apache will delegate the
        handling of all URLs whose path portions begin with
        <tt class="filename">/svn/</tt> to the Subversion DAV provider,
        which will then assume that any items in the directory
        specified by the <tt class="literal">SVNParentPath</tt> directive
        are actually Subversion repositories.  This is a particularly
        convenient syntax in that, unlike the use of the
        <tt class="literal">SVNPath</tt> directive, you don't have to
        restart Apache in order to create and network new
        repositories.</p><p>Be sure that when you define your new
        <tt class="literal">Location</tt>, it doesn't overlap with other
        exported Locations.  For example, if your main
        <tt class="literal">DocumentRoot</tt> is <tt class="filename">/www</tt>,
        do not export a Subversion repository in <tt class="literal">&lt;Location
        /www/repos&gt;</tt>.  If a request comes in for the URI
        <tt class="filename">/www/repos/foo.c</tt>, Apache won't know
        whether to look for a file <tt class="filename">repos/foo.c</tt> in
        the <tt class="literal">DocumentRoot</tt>, or whether to delegate
        <span><b class="command">mod_dav_svn</b></span> to return
        <tt class="filename">foo.c</tt> from the Subversion
        repository.</p><div class="sidebar"><p class="title"><b>Server Names and the COPY Request</b></p><p>Subversion makes use of the <tt class="literal">COPY</tt>
          request type to perform server-side copies of files and
          directories.  As part of the sanity checking done by the
          Apache modules, the source of the copy is expected to be
          located on the same machine as the destination of the copy.
          To satisfy this requirement, you might need to tell mod_dav
          the name you use as the hostname of your server.  Generally,
          you can use the <tt class="literal">ServerName</tt> directive in
          <tt class="filename">httpd.conf</tt> to accomplish this.</p><pre class="screen">
ServerName svn.example.com
</pre><p>If you are using Apache's virtual hosting support via
          the <tt class="literal">NameVirtualHost</tt> directive, you may
          need to use the <tt class="literal">ServerAlias</tt> directive to
          specify additional names that your server is known by.
          Again, refer to the Apache documentation for full
          details.</p></div><p>At this stage, you should strongly consider the question
        of permissions.  If you've been running Apache for some time
        now as your regular web server, you probably already have a
        collection of content&#8212;web pages, scripts and such.
        These items have already been configured with a set of
        permissions that allows them to work with Apache, or more
        appropriately, that allows Apache to work with those files.
        Apache, when used as a Subversion server, will also need the
        correct permissions to read and write to your Subversion
        repository.  (See <a href="#svn-ch-6-sidebar-1" title="Servers and Permissions:  A Word of Warning">Servers and Permissions:  A Word of Warning</a>.)</p><p>You will need to determine a permission system setup that
        satisfies Subversion's requirements without messing up any
        previously existing web page or script installations.  This
        might mean changing the permissions on your Subversion
        repository to match those in use by other things that Apache
        serves for you, or it could mean using the
        <tt class="literal">User</tt> and <tt class="literal">Group</tt>
        directives in <tt class="filename">httpd.conf</tt> to specify that
        Apache should run as the user and group that owns your
        Subversion repository.  There is no single correct way to set
        up your permissions, and each administrator will have
        different reasons for doing things a certain way.  Just be
        aware that permission-related problems are perhaps the most
        common oversight when configuring a Subversion repository for
        use with Apache.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.3"></a>Authentication Options</h3></div></div><div></div></div><p>At this point, if you configured
        <tt class="filename">httpd.conf</tt> to contain something like</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
&lt;/Location&gt;
</pre><p>...then your repository is &#8220;<span class="quote">anonymously</span>&#8221;
        accessible to the world.  Until you configure some
        authentication and authorization policies, the Subversion
        repositories you make available via the
        <tt class="literal">Location</tt> directive will be generally
        accessible to everyone.  In other words,</p><div class="itemizedlist"><ul type="disc"><li><p>anyone can use their Subversion client to checkout a
            working copy of a repository URL (or any of its
            subdirectories),</p></li><li><p>anyone can interactively browse the repository's
            latest revision simply by pointing their web browser to
            the repository URL, and</p></li><li><p>anyone can commit to the repository.</p></li></ul></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-4.3.1"></a>Basic HTTP Authentication</h4></div></div><div></div></div><p>The easiest way to authenticate a client is via the
          HTTP Basic authentication mechanism, which simply uses a
          username and password to verify that a user is who she says
          she is.  Apache provides an <span><b class="command">htpasswd</b></span>
          utility for managing the list of acceptable usernames and
          passwords, those to whom you wish to grant special access to
          your Subversion repository.  Let's grant commit access to
          Sally and Harry.  First, we need to add them to the password
          file.</p><pre class="screen">
$ ### First time: use -c to create the file
$ ### Use -m to use MD5 encryption of the password, which is more secure
$ htpasswd -cm /etc/svn-auth-file harry
New password: ***** 
Re-type new password: *****
Adding password for user harry
$ htpasswd /etc/svn-auth-file -m sally
New password: *******
Re-type new password: *******
Adding password for user sally
$
</pre><p>Next, you need to add some more
          <tt class="filename">httpd.conf</tt> directives inside your
          <tt class="literal">Location</tt> block to tell Apache what to do
          with your new password file.  The
          <tt class="literal">AuthType</tt> directive specifies the type of
          authentication system to use.  In this case, we want to
          specify the <tt class="literal">Basic</tt> authentication system.
          <tt class="literal">AuthName</tt> is an arbitrary name that you
          give for the authentication domain.  Most browsers will
          display this name in the pop-up dialog box when the browser
          is querying the user for his name and password.  Finally,
          use the <tt class="literal">AuthUserFile</tt> directive to specify
          the location of the password file you created using
          <span><b class="command">htpasswd</b></span>.</p><p>After adding these three directives, your
          <tt class="literal">&lt;Location&gt;</tt> block should look
          something like this:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
&lt;/Location&gt;
</pre><p>This <tt class="literal">&lt;Location&gt;</tt> block is not
          yet complete, and will not do anything useful.  It's merely
          telling Apache that whenever authorization is required,
          Apache should harvest a username and password from the
          Subversion client. What's missing here, however, are
          directives that tell Apache <span class="emphasis"><em>which</em></span> sorts
          of client requests require authorization.  Wherever
          authorization is required, Apache will demand
          authentication as well.  The simplest thing to do is protect
          all requests.  Adding <tt class="literal">Require valid-user</tt>
          tells Apache that all requests require an authenticated
          user:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /etc/svn-auth-file
  Require valid-user
&lt;/Location&gt;
</pre><p>Be sure to read the next section (<a href="#svn-ch-6-sect-4.4" title="Authorization Options">the section called &#8220;Authorization Options&#8221;</a>) for more detail on the
          <tt class="literal">Require</tt> directive and other ways to set
          authorization policies.</p><p>One word of warning: HTTP Basic Auth passwords pass in
          very nearly plain-text over the network, and thus are
          extremely insecure.  If you're worried about password
          snooping, it may be best to use some sort of SSL encryption,
          so that clients authenticate via <tt class="literal">https://</tt>
          instead of <tt class="literal">http://</tt>; at a bare minimum,
          you can configure Apache to use a self-signed server
          certificate.
          <sup>[<a name="id942349" href="#ftn.id942349">23</a>]</sup>
          Consult Apache's documentation (and OpenSSL documentation)
          about how to do that.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-4.3.2"></a>SSL Certificate Management</h4></div></div><div></div></div><p>Businesses that need to expose their repositories for access
          outside the company firewall should be conscious of the
          possibility that unauthorized parties could be
          &#8220;<span class="quote">sniffing</span>&#8221; their network traffic.  SSL makes
          that kind of unwanted attention less likely to result in
          sensitive data leaks.</p><p>If a Subversion client is compiled to use OpenSSL, then
          it gains the ability to speak to an Apache server via
          <tt class="literal">https://</tt> URLs.  The Neon library used by
          the Subversion client is not only able to verify server
          certificates, but can also supply client certificates when
          challenged.  When the client and server have exchanged SSL
          certificates and successfully authenticated one another, all
          further communication is encrypted via a session key.</p><p>It's beyond the scope of this book to describe how to
          generate client and server certificates, and how to
          configure Apache to use them.  Many other books, including
          Apache's own documentation, describe this task.  But what
          <span class="emphasis"><em>can</em></span> be covered here is how to manage
          server and client certificates from an ordinary Subversion
          client.</p><p>When speaking to Apache via <tt class="literal">https://</tt>,
          a Subversion client can receive two different types of
          information:</p><div class="itemizedlist"><ul type="disc"><li><p>a server certificate</p></li><li><p>a demand for a client certificate</p></li></ul></div><p>If the client receives a server certificate, it needs to
          verify that it trusts the certificate: is the server really
          who it claims to be?  The OpenSSL library does this by
          examining the signer of the server certificate, or
          <i class="firstterm">certifying authority</i> (CA).  If
          OpenSSL is unable to automatically trust the CA, or if some
          other problem occurs (such as an expired certificate or
          hostname mismatch), the Subversion command-line client will
          ask you whether you want to trust the server certificate
          anyway:</p><pre class="screen">
$ svn list https://host.example.com/repos/project

Error validating server certificate for 'https://host.example.com:443':
 - The certificate is not issued by a trusted authority. Use the
   fingerprint to validate the certificate manually!
Certificate information:
 - Hostname: host.example.com
 - Valid: from Jan 30 19:23:56 2004 GMT until Jan 30 19:23:56 2006 GMT
 - Issuer: CA, example.com, Sometown, California, US
 - Fingerprint: 7d:e1:a9:34:33:39:ba:6a:e9:a5:c4:22:98:7b:76:5c:92:a0:9c:7b

(R)eject, accept (t)emporarily or accept (p)ermanently?
</pre><p>This dialogue should look familiar; it's essentially the
          same question you've probably seen coming from your web
          browser (which is just another HTTP client like Subversion!).
          If you choose the (p)ermanent option, the server certificate
          will be cached in your private run-time
          <tt class="filename">auth/</tt> area in just the same way your
          username and password are cached (see <a href="#svn-ch-6-sect-2.2" title="Client Credentials Caching">the section called &#8220;Client Credentials Caching&#8221;</a>.)  If cached, Subversion will
          automatically remember to trust this certificate in future
          negotiations.</p><p>Your run-time <tt class="filename">servers</tt> file also gives
          you the ability to make your Subversion client automatically
          trust specific CAs, either globally or on a per-host basis.
          Simply set the <tt class="literal">ssl-authority-files</tt>
          variable to a semicolon-separated list of PEM-encoded CA
          certificates:</p><pre class="screen">
[global]
ssl-authority-files = /path/to/CAcert1.pem;/path/to/CAcert2.pem
</pre><p>Many OpenSSL installations also have a pre-defined set
          of &#8220;<span class="quote">default</span>&#8221; CAs that are nearly universally
          trusted.  To make the Subversion client automatically trust
          these standard authorities, set the
          <tt class="literal">ssl-trust-default-ca</tt> variable to
          <tt class="literal">true</tt>.</p><p>When talking to Apache, a Subversion client might also
          receive a challenge for a client certificate.  Apache is
          asking the client to identify itself: is the client really
          who it says it is?  If all goes correctly, the Subversion
          client sends back a private certificate signed by a CA that
          Apache trusts.  A client certificate is usually stored on
          disk in encrypted format, protected by a local password.
          When Subversion receives this challenge, it will ask you for
          both a path to the certificate and the password which
          protects it:</p><pre class="screen">
$ svn list https://host.example.com/repos/project

Authentication realm: https://host.example.com:443
Client certificate filename: /path/to/my/cert.p12
Passphrase for '/path/to/my/cert.p12':  ********
&#8230;
</pre><p>Notice that the client certificate is a
          &#8220;<span class="quote">p12</span>&#8221; file.  To use a client certificate with
          Subversion, it must be in PKCS#12 format, which is a
          portable standard.  Most web browsers are already able to
          import and export certificates in that format.   Another
          option is to use the OpenSSL command-line tools to convert
          existing certificates into PKCS#12.</p><p>Again, the runtime <tt class="filename">servers</tt> file
          allows you to automate this challenge on a per-host basis.
          Either or both pieces of information can be described in
          runtime variables:</p><pre class="screen">
[groups]
examplehost = host.example.com

[examplehost]
ssl-client-cert-file = /path/to/my/cert.p12
ssl-client-cert-password = somepassword
</pre><p>Once you've set the
          <tt class="literal">ssl-client-cert-file</tt> and
          <tt class="literal">ssl-client-cert-password</tt> variables, the
          Subversion client can automatically respond to a client
          certificate challenge without prompting you.
          <sup>[<a name="id942594" href="#ftn.id942594">24</a>]</sup>
        </p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="svn-ch-6-sect-4.4"></a>Authorization Options</h3></div></div><div></div></div><p>At this point, you've configured authentication, but not
        authorization.  Apache is able to challenge clients and
        confirm identities, but it has not been told how to allow or
        restrict access to the clients bearing those identities.  This
        section describes two strategies for controlling access to
        your repositories.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="svn-ch-6-sect-4.4.1"></a>Blanket Access Control</h4></div></div><div></div></div><p>The simplest form of access control is to authorize
          certain users for either read-only access to a repository,
          or read/write access to a repository.</p><p>You can restrict access on all repository operations by
          adding the <tt class="literal">Require valid-user</tt> directive
          to your <tt class="literal">&lt;Location&gt;</tt> block.  Using
          our previous example, this would mean that only clients that
          claimed to be either <tt class="literal">harry</tt> or
          <tt class="literal">sally</tt>, and provided the correct
          password for their respective username, would be allowed to
          do anything with the Subversion repository:</p><pre class="screen">
&lt;Location /svn&gt;
  DAV svn
  SVNParentPath /usr/local/svn

  # how to authenticate a user
  AuthType Basic
  AuthName "Subversion repository"
  AuthUserFile /path/to/users/file
  
  # only authenticated users may access the repository
  Require valid-user
&lt;/Location&gt;
</pre><p>Sometimes you don't need to run such a tight ship.  For
          example, Subversion's own source code repository at
          <tt class="systemitem">http://svn.collab.net/repos/svn</tt>
          allows anyone in the world to perform read-only repository
          tasks (like checking out working copies and browsing the
          repository wi