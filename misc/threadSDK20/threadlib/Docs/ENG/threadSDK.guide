@DATABASE threadSDK.guide
@$VER: threadSDK.guide 1.0 (08.03.99)
@AUTHOR Gabriele Budelacci





@NODE "Main" "Copyright"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   LEGAL
@{ub}
 @{u}thread.library is SHAREWARE.@{uu}
 If you develop shareware or commercial software that use thread.library, you
 must send me a registered and complete copy of that software. If you not are
 registered to thread.library, you MUST register.
 No registration needed for freeware or public domain software !!!

 Please support AMIGA software and SHAREWARE concept.........................
 ...........................please register ;)


                                @{"CONTINUE" LINK "MainIndex"}
                             @{"How to register" LINK "Registration"}

@ENDNODE

 To register thread.library, send 10 Euro ( or equivalent value ) to:

   Gabriele Budelacci
   via Repubblica 9
   47030 San Mauro Mare
     Forlì
                ITALY

  Please support AMIGA software and SHAREWARE concept........................
  ..........................please register ;)


                                @{"CONTINUE" LINK "MainIndex"}

@ENDNODE





@NODE "MainIndex" "thread.library SDK guide"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         Software Development Kit
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


  CHAPTER 1: @{fg shine}OVERVIEW@{fg text}
@{ub}
   @{"Introduction                   " LINK "Introduction"}
   @{"Requirements                   " LINK "Requirements"}
   @{"Installation                   " LINK "Installation"}
   @{"Distribution                   " LINK "Distribution"}
   @{"Registration                   " LINK "Registration"}
   @{"Copyright                      " LINK "Main"}
   @{"Disclaimer                     " LINK "Disclaimer"}
   @{"Author                         " LINK "Author"}
   @{"History                        " LINK "History"}
   @{"Future                         " LINK "Future"}
   @{"Bugs                           " LINK "Bugs"}

@{b}
  Chapter 2: @{fg shine}FUNCTIONS@{fg text}
@{ub}
   LIST OF FUNCTIONS ORDERED ALPHABETICALLY

    @{"thread.library/TLAllocMem()    " LINK "TLAllocMem"}
    @{"thread.library/TLCancel()      " LINK "TLCancel"}
    @{"thread.library/TLCreate()      " LINK "TLCreate"}
    @{"thread.library/TLDetach()      " LINK "TLDetach"}
    @{"thread.library/TLExit()        " LINK "TLExit"}
    @{"thread.library/TLFreeMem()     " LINK "TLFreeMem"}
    @{"thread.library/TLGetPrio()     " LINK "TLGetPrio"}
    @{"thread.library/TLJoin()        " LINK "TLJoin"}
    @{"thread.library/TLMutexDestroy()" LINK "TLMutexDelete"}
    @{"thread.library/TLMutexInit()   " LINK "TLMutexInit"}
    @{"thread.library/TLMutexLock()   " LINK "TLMutexLock"}
    @{"thread.library/TLMutexTryLock()" LINK "TLMutexTryLock"}
    @{"thread.library/TLMutexUnlock() " LINK "TLMutexUnlock"}
    @{"thread.library/TLSetCancel()   " LINK "TLSetCancel"}
    @{"thread.library/TLSetPrio()     " LINK "TLSetPrio"}

   LIST OF FUNCTIONS GROUPS

    @{"Thread managing functions      " LINK "ThreadMan"}
    @{"Mutex managing functions       " LINK "MutexMan"}
    @{"Scheduler managing functions   " LINK "SchedulerMan"}
    @{"Memory managing functions      " LINK "MemoryMan"}


@{b}
  Chapter 3: @{fg shine}CONSTANTS@{fg text}
@{ub}
   @{"thread.library/TL_AMIGAE       " LINK "TL_AMIGAE"}
   @{"thread.library/TL_FALSE        " LINK "TL_FALSE"}
   @{"thread.library/TL_reg          " LINK "TL_reg"}
   @{"thread.library/TL_TRUE         " LINK "TL_TRUE"}

@{b}
  Chapter 4: @{fg shine}PROGRAMMING@{fg text}
@{ub}
   @{"What is a 'thread'             " LINK "WhatIsAThread"}
   @{"Programming with thread.library" LINK "Programming"}


@{i}
                                           'give new life to your programs'
@{ui}

@ENDNODE





@NODE "Introduction" "Introduction"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   INTRODUCTION
@{ub}
 thread.library is a higly optimized shared library for Amiga systems.
 thread.library implement a large subset of DCE® Thread Package functions,
 available for UNIX® and WindowsNT® and other operating systems. This
 library can help you to translate applications from/to these OS.
 thread.library will implement also some utils functions.

 If you don't know anything about threads, please read the
 @{"What is a 'thread'" LINK "WhatIsAThread"} section.

 thread.library is totally AmigaOS-friendly.


@ENDNODE





@NODE "Requirements" "Requirements"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   REQUIREMENTS
@{ub}
 thread.library require AmigaOS v3.0 or above.
 Only compiled programs can use thread.library...NO INTERPRETED LANGUAGES !!!

 thread.library was successfully tested on:

   A1200 OS 3.0
   A1200 + 4Mb Fast RAM, OS 3.0
   A1200 + Blizzard1230 + 16 Mb Fast Ram, OS 3.0


@ENDNODE





@NODE "Installation" "Installation"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   INSTALLATION
@{ub}
 To install thread.library, simply copy the 'thread.library' file in your
 LIBS: directory.

 You can find the newest version of thread.library in

              Aminet:util/libs/threadlibxx.lha

 where xx is the number of version followed by the number of revision.


@ENDNODE





@NODE "Distribution" "Distribution"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   DISTRIBUTION
@{ub}
 This archive contain the following files:

   @{fg shine}@{b}threadlib@{ub}@{fg text}
    |
    +- @{b}README.TXT@{ub}                      the quick reference file
    |
    +- @{b}thread.library@{ub}                  the library
    |
    +- @{b}BugReport.txt@{ub}                   the bug report file
    |
    +- @{fg shine}@{b}Docs@{ub}@{fg text}
    |   |
    |   +- @{fg shine}@{b}ENG@{ub}@{fg text}
    |       |
    |       +- @{b}threadSDK.guide@{ub}         this file
    |
    +- @{fg shine}@{b}fd@{ub}@{fg text}
    |   |
    |   +- @{b}thread_lib.fd@{ub}               the interface definitions
    |
    +- @{fg shine}@{b}Asm@{ub}@{fg text}
    |   |
    |   +- @{fg shine}@{b}include@{ub}@{fg text}
    |       |
    |       +- @{b}thread.i@{ub}                assembly include file
    |       |
    |       +- @{b}thread_lib.i@{ub}            assembly include file
    |
    +- @{fg shine}@{b}E@{ub}@{fg text}
    |   |
    |   +- @{fg shine}@{b}Modules@{ub}@{fg text}
    |   |   |
    |   |   +- @{b}thread.m@{ub}                AmigaE module file
    |   |   |
    |   |   +- @{fg shine}@{b}libraries@{ub}@{fg text}
    |   |       |
    |   |       +- @{b}thread.m@{ub}            AmigaE module file
    |   |
    |   +- @{fg shine}@{b}ModulesSrc@{ub}@{fg text}
    |       |
    |       +- @{fg shine}@{b}libraries@{ub}@{fg text}
    |           |
    |           +- @{b}thread.e@{ub}            source of AmigaE module file
    |
    +- @{fg shine}@{b}C@{ub}@{fg text}
    |   |
    |   +- @{b}thread.h@{ub}                    C include file
    |   |
    |   +- @{b}thread_lib.h@{ub}                C pragmas definition file
    |   |
    |   +- @{b}thread.lib@{ub}                  .lib file
    |
    +- @{fg shine}@{b}examples@{ub}@{fg text}
        |
        +- @{b}Example1@{ub}                    1st example
        |
        +- @{b}Example1.c@{ub}                  source of Example1
        |
        +- @{b}Example2@{ub}                    2nd example
        |
        +- @{b}Example2.e@{ub}                  source of Example2



 This archive can be spreaded only with all files included. You may not spread
 only a subpart of this archive.


 The newest version of thread.library is available in

              Aminet:util/libs/threadlibxx.lha

 where xx is the number of version followed by the number of revision.


@ENDNODE





@NODE "Registration" "Registration"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   REGISTRATION
@{ub}
 To register thread.library, send 10 Euro ( or equivalent money ) to:

   Gabriele Budelacci
   via Repubblica 9
   47030 San Mauro Mare
     Forlì
                ITALY

  Please support AMIGA software and SHAREWARE concept........................
  ..........................please register ;)


@ENDNODE





@NODE "Disclaimer" "Disclaimer"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   DISCLAIMER
@{ub}
 The author cannot be held liable for the suitability or  accuracy  of this
 manual  nor  the  program(s) and can not accept any responsibility for
 damage directly  or indirectly caused by the use of this manual  and/or the
 programs.
 In other words: Anything you do is at your own risk.


@ENDNODE





@NODE "Author" "Author"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   THE AUTHOR
@{ub}
     Gabriele Budelacci
     via Repubblica 9
     47030 San Mauro Mare
     Forlì
                  ITALY


 e-mail:      g.bude@eudoramail.com

 IRC:         NickName "Bubu" or "Bubu7te"
              Channels #AMIGAITA, #AMIGA

 ICQ/UID#:    28748520


@ENDNODE





@NODE "History" "History"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   HISTORY
@{ub}
 - thread package v0.1 ( 07/01/1999 )
     first internal C-functions version

 - thread.library v1.0 ( 03/02/1999 )
     first internal library version

 - thread.library v2.0 ( 05/03/1999 )
     first shareware version
     ( this distribution )


@ENDNODE





@NODE "Future" "Future"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   FUTURE
@{ub}
 - Adding 'conditions variables'.

 Some ideas ???
 Feel free to contact @{"me" LINK "Author"} !!!


@ENDNODE





@NODE "Bugs" "Bugs"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   BUGS
@{ub}
 Where ?
 No bugs known currently... :)
 If you find a bug, please send a compiled 'BugReport.txt' file to @{"me" LINK "Author"}.


@ENDNODE





@NODE "TLAllocMem" "thread.library/TLAllocMem()"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLAllocMem   - allocate public memory
@{b}
   SYNOPSIS
@{ub}
      memptr = TLAllocMem( bytesize )
        D0                    D0

      APTR TLAllocMem( ULONG )
@{b}
   FUNCTION
@{ub}
      This function allocate a block of public memory.
@{b}
   INPUTS
@{ub}
      bytesize     - size of memory block in bytes.
@{b}
   RESULTS
@{ub}
      memptr       - pointer to memory block allocated or TL_NULL if a error
                     has occured. The block is cleared to 0.
@{b}
   NOTES
@{ub}
      DO NOT USE system functions for deallocate a block of memory allocated
      by TLAllocMem() thread.library's function. The system may crash.
      Memory blocks allocated by TLAllocMem() will be freeed when the
      thread.library is flushed.
@{b}
   SEE ALSO
@{ub}
      @{"TLFreeMem()" LINK "TLFreeMem"}


@ENDNODE





@NODE "TLCancel" "thread.library/TLCancel"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLCancel     - cancel a thread
@{b}
   SYNOPSIS
@{ub}
      success = TLCancel( threadptr )
        D0                   A0

      LONG TLCancel( APTR )
@{b}
   FUNCTION
@{ub}
      This function try to cancel a thread.
@{b}
   INPUTS
@{ub}
      threadptr    - pointer to a thread descriptor.
@{b}
   RESULTS
@{ub}
      success      - boolean result: TL_TRUE if the thread is canceled,
                     TL_FALSE if the thread is not canceled.
@{b}
   NOTES
@{ub}
      A thread can decide if another thread can cancel it.
@{b}
   SEE ALSO
@{ub}
      @{"TLCreate()   " LINK "TLCreate"}
      @{"TLSetCancel()" LINK "TLSetCancel"}


@ENDNODE





@NODE "TLCreate" "thread.library/TLCreate"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLCreate     - create a new thread
@{b}
   SYNOPSIS
@{ub}
      threadptr = TLCreate( codeptr, regmask )
         D0                   A0       D0

      APTR = TLCreate( APTR, ULONG )
@{b}
   FUNCTION
@{ub}
      This function create a new child-thread.
@{b}
   INPUTS
@{ub}
      codeptr      - pointer to the code of the new thread.
      regmask      - bitfield parameter that indicate which CPU registers
                     the parent-thread must copy to child-thread.
@{b}
   RESULTS
@{ub}
      threadptr    - pointer to a new thread descriptor.
@{b}
   NOTES
@{ub}
      The 'regmask' parameter is necessary for the child-thread global
      variables and depend to your compiler impostation.
      Eg: if your compiler identify the global variables indexed by an
          address CPU register (eg: a5), you must specify TL_A5 as
          regmask value. If your compiler use absolute values for
          global variables, then you can specify TL_NULL as regmask value.
      AmigaE programmers must specify TL_AMIGAE, because the AmigaE compiler
      use global variables indexed by the A4 CPU address register.
@{b}
   EXAMPLE
@{ub}
      C:
         mythread = TLCreate( functionptr, TL_A5 | TL_D2 );
      Amiga E:
         mythread := TlCreate( {function}, TL_AMIGAE );
@{b}
   SEE ALSO
@{ub}
      @{"TLCancel()" LINK "TLCancel"}
      @{"TLJoin()  " LINK "TLJoin"}
      @{"TL_AMIGAE " LINK "TL_AMIGAE"}
      @{"TL_reg    " LINK "TL_reg"}


@ENDNODE





@NODE "TLDetach" "thread.library/TLDetach"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLDetach     - detach a thread from parent
@{b}
   SYNOPSIS
@{ub}
      TLDetach( value )
                 D0

      VOID TLDetach( LONG )
@{b}
   FUNCTION
@{ub}
      This function detach a thread from its parent. The parent thread has so
      no more join points with the child thread.
@{b}
   INPUTS
@{ub}
      value        - result value sended to parent thread.
@{b}
   NOTES
@{ub}
      If the parent thread call TLJoin() after the TLDetach() of its child,
      then the parent thread can continue immediately.
@{b}
   SEE ALSO
@{ub}
      @{"TLExit()" LINK "TLExit"}
      @{"TLJoin()" LINK "TLJoin"}


@ENDNODE





@NODE "TLExit" "thread.library/TLExit"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLExit       - exit from a thread
@{b}
   SYNOPSIS
@{ub}
      TLExit( returnvalue )
                  D0

      VOID TLExit( LONG )
@{b}
   FUNCTION
@{ub}
      This function exit from a thread, returning a result value to the
      parent thread.
@{b}
   INPUTS
@{ub}
      returnvalue  - return value for the parent thread.
@{b}
   NOTES
@{ub}
      TLExit() must be the last statement of a thread. Statements after
      a TLExit() call are not executed.
      The parent thread can read the return value with a TLJoin() call.
      If the thread has previously called TLDetach(), then the return
      value of TLExit() is not sended.
@{b}
   SEE ALSO
@{ub}
      @{"TLCreate()" LINK "TLCreate"}
      @{"TLDetach()" LINK "TLDetach"}
      @{"TLJoin()  " LINK "TLJoin"}


@ENDNODE





@NODE "TLFreeMem" "thread.library/TLFreeMem"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLFreeMem    - deallocate memory
@{b}
   SYNOPSIS
@{ub}
      TLFreeMem( memoryptr )
                    A0

      VOID TLFreeMem( APTR )
@{b}
   FUNCTION
@{ub}
      This function will deallocate a memory block, previously allocaded by
      a TLAllocMem() call.
@{b}
   INPUTS
@{ub}
      memoryptr    - pointer to the memory block.
@{b}
   NOTES
@{ub}
      If you alloc memory by a TLAllocMem() call without a TLFreeMem() call,
      then the memory block allocated is freeed when thread.library is
      flushed from the memory.
      DO NOT USE TLFreeMem() to deallocate memory block previously allocated
      by system functions. The system may crash.
@{b}
   SEE ALSO
@{ub}
      @{"TLAllocMem()" LINK "TLAllocMem"}


@ENDNODE





@NODE "TLGetPrio" "thread.library/TLGetPrio"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLGetPrio    - get the current priority of the thread
@{b}
   SYNOPSIS
@{ub}
      prio = TLGetPrio( threadptr )
       D0                  A0

      LONG TLGetPrio( APTR )
@{b}
   FUNCTION
@{ub}
      This function get the current scheduling priority of a thread.
@{b}
   INPUTS
      threadptr    - pointer to a thread descriptor.
@{ub}
@{b}
   RESULTS
@{ub}
      prio         - priority of the thread ( from -128 to +127 ).
@{b}
   NOTES
@{ub}
      According to AmigaOS, the prio value is in range:

         -128 : lesser priority
         ...
         0    : normal priority
         ...
         +127 : higher priority
@{b}
   SEE ALSO
@{ub}
      @{"TLSetPrio()" LINK "TLSetPrio"}


@ENDNODE





@NODE "TLJoin" "thread.library/TLJoin"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLJoin       - join parent thread with a child thread
@{b}
   SYNOPSIS
@{ub}
      value = TLJoin( threadptr )
       D0                A0

      LONG TLJoin( APTR )
@{b}
   FUNCTION
@{ub}
      This function join the parent thread with a child thread. The
      execution of the caller thread will continue when a signal from
      the child thread will become.
@{b}
   INPUTS
@{ub}
      threadptr    - thread descriptor of the child thread.
@{b}
   RESULTS
@{ub}
      value        - value returned from child thread.
@{b}
   NOTES
@{ub}
      When a child thread call TLDetach() function, the parent thread can
      continue.
@{b}
   SEE ALSO
@{ub}
      @{"TLDetach()" LINK "TLDetach"}
      @{"TLExit()  " LINK "TLExit"}


@ENDNODE





@NODE "TLMutexDestroy" "thread.library/TLMutexDestroy"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLMutexDestroy - delete a mutex semaphore
@{b}
   SYNOPSIS
@{ub}
      TLMutexDestroy( mutex )
                      A0

      VOID TLMutexDestroy( APTR )
@{b}
   FUNCTION
@{ub}
      This function delete a mutual exclusion semaphore.
@{b}
   INPUTS
@{ub}
      mutex         - pointer to a previously defined mutex semaphore
@{b}
   SEE ALSO
@{ub}
      @{"TLMutexInit()" LINK "TLMutexInit"}


@ENDNODE





@NODE "TLMutexInit" "thread.library/TLMutexInit"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLMutexInit  - create and initialize a mutex semaphore
@{b}
   SYNOPSIS
@{ub}
      mutex = TLMutexInit()
       D0

      APTR TLMutexInit( VOID )
@{b}
   FUNCTION
@{ub}
      This function will create and initialize a mutual exclusion semaphore.
@{b}
   RESULTS
@{ub}
      mutex        - pointer to the mutual exclusion semaphore.
@{b}
   NOTES
@{ub}
      Thread that create a mutex, does not have the exclusive access to the
      mutex. For the mutex utilization, it may perform a TLMutexLock() call.
@{b}
   SEE ALSO
@{ub}
      @{"TLMutexDestroy()" LINK "TLMutexDestroy"}
      @{"TLMutexLock()   " LINK "TLMutexLock"}


@ENDNODE





@NODE "TLMutexLock" "thread.library/TLMutexLock"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLMutexLock  - lock a mutex semaphore
@{b}
   SYNOPSIS
@{ub}
      TLMutexLock( mutex )
                    A0

      VOID TLMutexLock( APTR )
@{b}
   FUNCTION
@{ub}
      This function suspend the caller thread until the mutual exclusion
      semaphore will be come free. After this, the caller is the owner of
      the mutex and can continue its execution.
@{b}
   INPUTS
@{ub}
      mutex        - pointer to a previously defined mutex semaphore.
@{b}
   NOTES
@{ub}
      Remember that a locked mutex must be unlocked, by a TLMutexUnlock()
      call. Else, the system may crash.
      TLMutexLock() function will suspend the caller every time that the
      mutex is not available. For test availability of a mutex, please call
      the TLMutexTryLock() function.
@{b}
   EXAMPLE
@{ub}
      ...
         /* suspend the caller if the mutex is already locked */
      TLMutexLock( mutex );
         /* the mutex is now locked by the caller */
      ...
         /* unlock the mutex */
      TLMutexUnlock( mutex );
      ...
@{b}
   SEE ALSO
@{ub}
      @{"TLMutexUnlock() " LINK "TLMutexUnlock"}
      @{"TLMutexTryLock()" LINK "TLMutexTryLock"}


@ENDNODE





@NODE "TLMutexTryLock" "thread.library/TLMutexTryLock"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLMutexTryLock - try to lock a mutex semaphore
@{b}
   SYNOPSIS
@{ub}
      success = TLMutexTryLock( mutex )
        D0                       A0

      LONG TLMutexTryLock( APTR )
@{b}
   FUNCTION
@{ub}
      This function try to lock a mutual exclusion semaphore.
@{b}
   INPUTS
@{ub}
      mutex          - pointer to a previously defined mutex semaphore.
@{b}
   RESULTS
@{ub}
      success        - boolean value that indicate the state of the mutex:
                        TL_TRUE  : mutex has been successfully locked by
                                   caller;
                        TL_FALSE : mutex is locked by another thread.
@{b}
   NOTES
@{ub}
      TLMutexTryLock() function perform an asynchronous lock. For synchronous
      locking, please use TLMutexLock() function.
@{b}
   EXAMPLE
@{ub}
      ...
      if ( TLMutexTryLock( mutex ) )
      {
            /* the mutex is locked */
         ...
         TLMutexUnlock( mutex );
      }
      else
      {
            /* the mutex can't be locked */
         ...
      }
      ...
@{b}
   SEE ALSO
@{ub}
      @{"TLMutexLock()  " LINK "TLMutexLock"}
      @{"TLMutexUnlock()" LINK "TLMutexUnlock"}


@ENDNODE





@NODE "TLMutexUnlock" "thread.library/TLMutexUnlock"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLMutexUnlock - unlock a mutex semaphore
@{b}
   SYNOPSIS
@{ub}
      TLMutexUnlock( mutex )
                      A0

      VOID TLMutexUnlock( APTR )
@{b}
   FUNCTION
@{ub}
      This function will unlock a previously locked mutex.
@{b}
   INPUTS
@{ub}
      mutex         - pointer to a previously defined mutex semaphore.
@{b}
   NOTES
@{ub}
      A thread must unlock all the mutex locked. Else, the system may crash.
@{b}
   SEE ALSO
@{ub}
      @{"TLMutexLock()   " LINK "TLMutexLock"}
      @{"TLMutexTryLock()" LINK "TLMutexTryLock"}


@ENDNODE





@NODE "TLSetCancel" "thread.library/TLSetCancel"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLSetCancel  - enable or disable ability of other threads to kill the
                     caller
@{b}
   SYNOPSIS
@{ub}
      TLSetCancel( cancen )
                     D0

      VOID TLSetCancel( LONG )
@{b}
   FUNCTION
@{ub}
      This function will enable or disable ability of other threads to cancel
      the caller.
@{b}
   INPUTS
@{ub}
      cancen       - boolean value that set the cancel status of the caller:
                      TL_TRUE  : other threads can cancel this thread;
                      TL_FALSE : other threads can't cancel this thread.
@{b}
   NOTES
@{ub}
      When a thread perform a TLSetCancel( TL_FALSE ) call, possible
      TLCancel() calls performed by another threads are ignored, not
      remembered.
@{b}
   EXAMPLE
@{ub}
      ...
      TLSetCancel( TL_FALSE );
         /* now the thread can't be killed by another thread */
      ...
      TLSetCancel( TL_TRUE );
         /* the thread is now 'Cancel Enabled' */
      ...
@{b}
   SEE ALSO
@{ub}
      @{"TLCancel()" LINK "TLCancel"}


@ENDNODE





@NODE "TLSetPrio" "thread.library/TLSetPrio"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TLSetPrio    - set the priority of a thread
@{b}
   SYNOPSIS
@{ub}
      TLSetPrio( prio )
                  D0

      VOID TLSetPrio( LONG )
@{b}
   FUNCTION
@{ub}
      This function will set the scheduler priority of the thread.
@{b}
   INPUTS
@{ub}
      prio         - priority of the thread ( from -128 to +127 )
@{b}
   NOTES
@{ub}
      According to AmigaOS, the prio value is in range:

         -128 : lesser priority
         ...
         0    : normal priority
         ...
         +127 : higher priority
@{b}
   SEE ALSO
@{ub}
      @{"TLGetPrio()" LINK "TLGetPrio"}


@ENDNODE





@NODE "ThreadMan" "Thread managing functions"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   THREAD MANAGING FUNCTIONS
@{ub}
 These functions performs a complete thread managing by the programmer:

 @{"TLCancel()   " LINK    "TLCancel"} Try to cancel a thread.
 @{"TLCreate()   " LINK    "TLCreate"} Create a new thread.
 @{"TLDetach()   " LINK    "TLDetach"} No wait for parent thread when caller exit.
 @{"TLExit()     " LINK      "TLExit"} Called by a thread when it is finishing.
 @{"TLJoin()     " LINK      "TLJoin"} Like the WAIT system call in UNIX.
 @{"TLSetCancel()" LINK "TLSetCancel"} Enable or disable ability of ther threads to kill this thread.


@ENDNODE





@NODE "MutexMan" "Mutex managing functions"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   MUTEX MANAGING FUNCTIONS
@{ub}
 A 'mutex' is a 'MUTual EXclusion' semaphore, used to protect a block of
 memory from simultaneously accesses.
 These functions performs a complete mutex managing by the programmer:

 @{"TLMutexDestroy()" LINK "TLMutexDestroy"}     Delete a mutex.
 @{"TLMutexInit()   " LINK    "TLMutexInit"}     Create a mutex.
 @{"TLMutexLock()   " LINK    "TLMutexLock"}     Try to lock a mutex, if it's already locked, block.
 @{"TLMutexTryLock()" LINK "TLMutexTryLock"}     Try to lock a mutex, fail if it's already locked.
 @{"TLMutexUnlock() " LINK  "TLMutexUnlock"}     Unlock a mutex.

@ENDNODE





@NODE "SchedulerMan" "Scheduler managing functions"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   SCHEDULER MANAGING FUNCTIONS
@{ub}
 These functions performs a complete scheduler managing of the various
 threads:

 @{"TLGetPrio()" LINK "TLGetPrio"}         Get the current scheduling priority.
 @{"TLSetPrio()" LINK "TLSetPrio"}         Set the scheduling priority.


@ENDNODE





@NODE "MemoryMan" "Memory managing functions"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   MEMORY MANAGING FUNCTIONS
@{ub}
 These functions performs a 'garbage collector' memory managing: possible
 memory blocks undeallocated by the programmer are freed when the
 thread.library is flushed from the memory.
 These functions are an extension to 'DCE® Thread Package'.

 @{"TLAllocMem()" LINK "TLAllocMem"}        Allocate a block of memory.
 @{"TLFreeMem()" LINK  "TLFreeMem"}         Free a previously block of memory.


@ENDNODE





@NODE "TL_AMIGAE" "thread.library/TL_AMIGAE"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TL_AMIGAE
@{b}
   DESCRIPTION
@{ub}
      This constant specify which CPU registers of the parent thread must be
      copied to child thread. TL_AMIGAE equals to TL_A4 value, because
      AmigaE compiler identifi global variables by an indexed value through
      the A4 CPU address register.
@{b}
   EXAMPLE
@{ub}
      mythread := TlCreate( {threadcode}, TL_AMIGAE )
@{b}
   SEE ALSO
@{ub}
      @{"TLCreate()" LINK "TLCreate"}
      @{"TL_reg    " LINK "TL_reg"}


@ENDNODE





@NODE "TL_FALSE" "thread.library/TL_FALSE"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TL_FALSE
@{b}
   DESCRIPTION
@{ub}
      This constant specify a boolean false value. If a function will return
      this value, then the function has failed the scope.
@{b}
   SEE ALSO
@{ub}
      @{"TL_TRUE" LINK "TL_TRUE"}


@ENDNODE





@NODE "TL_TRUE" "thread.library/TL_TRUE"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TL_TRUE
@{b}
   DESCRIPTION
@{ub}
      This constant specify a boolean true value. If a function will return
      this value, then the function has successfully terminated.
@{b}
   SEE ALSO
@{ub}
      @{"TL_FALSE" LINK "TL_FALSE"}


@ENDNODE





@NODE "TL_reg" "thread.library/TL_reg"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   NAME
@{ub}
      TL_reg
      ( TL_D2, TL_D3, TL_D4, TL_D5, TL_D6, TL_D7, TL_A2, TL_A3, TL_A4, TL_A5 )
@{b}
   DESCRIPTION
@{ub}
      This constants specify which CPU registers of the parent thread must be
      copied to child thread.
@{b}
   EXAMPLE
@{ub}
      mythread := TLCreate( threadfunction, TL_D6 | TL_A4 | TL_A5 )
@{b}
   SEE ALSO
@{ub}
      @{"TLCreate()" LINK "TLCreate"}
      @{"TL_AMIGAE " LINK "TL_AMIGAE"}


@ENDNODE





@NODE "WhatIsAThread" "What is a 'thread'"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   WHAT IS A THREAD
@{ub}
 The normal code execution of a program il linear, first an instruction is
 executed, then the successive instruction, and so on...
 A 'process' can be intended like a program in execution.
 In a linear execution, a process contain a single instruction control flow.

 A 'thread' is a sub-process included in a process. It allow asinchronous
 execution of instructions, internally of a single program.
 With threads, a process can contain multiple control flows.

 EXAMPLE

 Imagine that a program must open a source file and, for every array
 contained, it must first fetch the array, then operate above the array and
 finishing store the array in a destination file.

 A normal coding of this problem is:

   +----------------+
   | Open the files |
   +----------------+
           |
          ...
           |
   +---------------+         \
   | Read an array |         |
   +---------------+         |
           |                 |
  +------------------+       |  for every array present
  | Process an array |       |  in the input file
  +------------------+       |
           |                 |
  +------------------+       |
  | Write the result |       |
  +------------------+       /
           |
          ...
           |
  +-----------------+
  | Close the files |
  +-----------------+

 With threads, the control flow can be the follow:

                         +----------------+
                         | Open the files |
                         +----------------+
                                  |
           +----------------------+------------------------+
           |                      |                        |
   +---------------+              |                        |
   | Read an array |--|  +------------------+              |
   +---------------+  |--| Process an array |--|  +------------------+
           |             +------------------+  |--| Write the result |
   +---------------+              |               +------------------+
   | Read an array |--|  +------------------+              |
   +---------------+  |--| Process an array |--|  +------------------+
           |             +------------------+  |--| Write the result |
   +---------------+              |               +------------------+
   | Read an array |--|  +------------------+              |
   +---------------+  |--| Process an array |--|  +------------------+
           |             +------------------+  |--| Write the result |
   +---------------+              |               +------------------+
   | Read an array |--|  +------------------+              |
   +---------------+  |--| Process an array |--|  +------------------+
           |             +------------------+  |--| Write the result |
           |                      |               +------------------+
           |                      |                        |
           +----------------------+------------------------+
                                  |
                         +-----------------+
                         | Close the files |
                         +-----------------+

 and the coding is simply respect the first case.


 A thread have the complete global variables of the root process. To avoid
 contemporary accesses to the same group of global variables, a set of
 mutual exclusion (mutex) semaphore managing functions are provided.
@{b}
   SEE ALSO
@{ub}
 @{"Thread managing functions      " LINK "ThreadMan"}
 @{"Mutex managing functions       " LINK "MutexMan"}
 @{"Scheduler managing functions   " LINK "SchedulerMan"}


@ENDNODE





@NODE "Programming" "Programming"

@{b}
                         ------------------------ @{fg shine}
                            thread.library 2.0
                         ©1999 Gabriele Budelacci @{fg text}
                         ------------------------


   PROGRAMMING WITH THREAD.LIBRARY
@{ub}
 Programming with thread.library is very simple.
 The root process must open the library. Then, it can create every thread, or
 create a thread that create a sub-thread and so on. Only a parent thread
 can wait the end of a sub-thread (child thread) through a TLJoin() call.
 Else, a thread may wait forever (or the system may crash).
 To create mutual exclusion semaphores, generally a parent thread must invoke
 the TLMutexInit() function before a thread creation that use the semaphore.
 This is not a official directive, but a good rule.
 After the end of every child threads, the parent thread can delete the mutex
 by a TLMutexDestroy() call.
 Note that if a thread is killed by another thread, the resources allocated
 by the killed thread are not deallocated. A good rule to prevent this is to
 call the TLSetCancel() function to set the cancel status of a thread.
 Finishing, the root process can close thread.library. Please note that if
 exists threads when thread.library is closed, the system may crash. So, you
 must close all the threads opened by a process before closing
 thread.library.
 A last council. The memory allocated by thread.library's functions can be
 not deallocated by the process. Flushing the library from the memory (eg.
 typing 'avail flush' from a shell), all the allocated blocks are freeed. If
 more programs using thread.library are present in your system, a large
 amount of memory is unavailable for other tasks before the library is
 flushed. Please, flush all the memory allocated by a process, or the largest
 blocks.

@{b}
   IMPORTANT
@{ub}
 See the docs of your compiler for the method used by addressing global
 variables. The 'regmask' parameter of the TLCreate() function is vitally
 important. Else, the system may crash.


@ENDNODE

