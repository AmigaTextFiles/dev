<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="tg 0.11 [temgen]">
   <meta name="Author" content="Marek Letowski">    
   <meta name="Description" content="temgen - universal code generator - documentation">    
   <meta name="Keywords" content="temgen,template,code generation">    
   <title> temgen - user documentation </title>
</head>
<body text="#000000" bgcolor="#FFFFFF">
<small>
<a href="intro_pl.html"> Polish version </a> -
<a href="intro.html"> English version </a> -
<a href="temgen.html"> User manual </a> -
Download: <a href="http://download.berlios.de/temgen/tg-0.11.tgz"> tg-0.11.tgz </a>
</small>
<hr>
<h1> temgen - user documentation </h1>
<ul>
   <li> <a href="#section1"> 1. Introduction </a>
   <li> <a href="#section2"> 2. Temgen invocation </a>
   <li> <a href="#section3"> 3. Template language </a>
   <li> <a href="#section4"> 4. Examples </a>
   <li> <a href="#section5"> 5. Author, license </a>
</ul>
   <a name=section1>
   <h2> 1. Introduction </h2>
<b><samp>Temgen</samp></b> is an universal code generator, based on 
<a href=#lang>template language.</a>
Temgen templates are text files consisting of 
<a href=#ctl_lin>control lines</a> and 
<a href=#data_lin>data lines.</a>
<b><samp>Temgen</samp></b> rewrites data lines to output files
in order defined by control lines. 
<a href=#var>Variable</a> symbols are expanded before writing output,
and <a href=#_function>Function calls</a> are replaced
with the call result.
<p>
<b><samp>Temgen</samp></b> can be used for generating any text containing
repeatable patterns.
All generation logic is contained in templates, so
<b><samp>Temgen</samp></b> can be applied to generating texts in any languages,
such as C, Perl, HTML, or even natural languages.
<p>
Mechanism <a href=#_embed><b><samp>@embed</samp></b></a>  
and <a href=#_emit><b><samp>@emit</samp></b></a> allows
to create templates generating code in several files
in the same time.
   <a name=section2>
   <h2> 2. Temgen invocation </h2>
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Temgen invocation 
</th></tr>
<tr><td><pre>
    temgen [options] file ...    
</pre></tr></table><p>
Available options:
<ul>
<li> <b><samp>-d</samp></b> - run built in debugger
<li> <b><samp>-h</samp></b> - show help message
</ul>
  <a name='lang'>  
   <a name=section3>
   <h2> 3. Template language </h2>
<table> 
<tr><th> Basis </th><th> Commands </th><th> Built in functions </th></tr>
<tr><td valign="top">
<ul>
<li> <a href=#parsing>Generating text</a>
<li> <a href=#ctl_lin>Control lines</a>
<li> <a href=#data_lin>Data lines</a>
<li> <a href=#var>Data types and expressions</a>    
</ul>
</td>
<td valign="top">
<a name='commands'>
<ul>
<li> <a href=#_>@</a>
<li> <a href=#_break>@ break</a>     
<li> <a href=#_embed>@ embed</a> 
<li> <a href=#_emit>@ emit</a> 
<li> <a href=#_for>@ for</a>
<li> <a href=#_function>@ function</a>
<li> <a href=#_if>@ if</a>   
<li> <a href=#_local>@ local</a>
<li> <a href=#_output>@ output</a>
<li> <a href=#_pop>@ pop</a>    
<li> <a href=#_push>@ push</a>   
<li> <a href=#_return>@ return</a>
<li> <a href=#_switch>@ switch</a>
<li> <a href=#_use>@ use</a>
</ul>
</td>
<td valign="top">
<ul>
<li> <a href=#_printf>$printf()</a>
<li> <a href=#_size>$size()</a> 
<li> <a href=#_strlen>$strlen()</a>
<li> <a href=#_substr>$substr()</a>
<li> <a href=#_system>$system()</a>
<li> <a href=#_tplfile>$tplfile()</a> 
<li> <a href=#_tplline>$tplline()</a>
</ul>
</td>
</table>   
<p>
 <a name='parsing'>
  <p><b> Generating text </b><p>
Generating flow is following: 
Whole source files are parsed one after another and then interpreted
in the same order.
Each file is interpreted line by line, but the order can be modified
with the <a href=#ctl_lin>control lines.</a>    
Source file (template) consists of two kind of lines:
<a href=#ctl_lin>control lines</a> and <a href=#data_lin>data lines.</a>
 <a name='ctl_lin'> 
  <p><b>      Control lines  </b><p>
Each control line starts with <b><samp>@</samp></b> and command identifier.  
Command identifiers are enumerated in the table and described below.
The command purpose is changing control flow (ex.
        <a href=#_if><b><samp>@if</samp></b></a>,
        <a href=#_switch><b><samp>@switch</samp></b></a>), defining function ( 
        <a href=#_function><b><samp>@function</samp></b></a> ),
interpreting code fragments in order to initialize variables
( <a href=#_><b><samp>@</samp></b></a> ),
and setting output file and emit point (the point where output
text is to be placed (
        <a href=#_output><b><samp>@output</samp></b></a>, 
        <a href=#_embed><b><samp>@embed</samp></b></a>, 
        <a href=#_emit><b><samp>@emit</samp></b></a> ).
Control lines can be continued in next row. Continued line
should end with backslash and the next line has to start with <b><samp>@</samp></b>.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Control line continuation: 
</th></tr>
<tr><td><pre>
    @if ( $very_long_expression == \
    @     $another_very_long_expression )       
</pre></tr></table><p>
 <a name='data_lin'> 
  <p><b>      Data lines  </b><p>
Data lines contain text of the generated code. The text is expanded - 
encountered <a href=#var>expressions</a> are substituted with values.  
After expansion the text is inserted in embed point.
The embed point defaults to end of current output file,
but can be changed with the two commands:
<a href=#_emit><b><samp>@emit</samp></b></a> and <a href=#_embed><b><samp>@embed.</samp></b></a> 
The output file can be set by <a href=#_output><b><samp>@output</samp></b></a> command. 
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Data lines (template and output) 
</th></tr>
<tr><td><pre>
    @  $name = "Alaska"      
    $name is the best !    
</pre></td><td><pre>
    Alaska is the best !    
</pre></tr></table><p>
The strings can be escaped with backslash in order to prevent interpretation.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Escaping (template and output) 
</th></tr>
<tr><td><pre>
    @  $name = "Alaska"      
    (variable \$name)     
</pre></td><td><pre>
    (variable $name)      
</pre></tr></table><p>
 <a name='var'>       
  <p><b>      Data types and expressions </b><p>
There are three data types in the template language:
scalars, arrays and structures.  
Scalars can be strings or numbers, arrays are indexed with
integer numbers greater or equal 0.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Scalars, arrays and structures: 
</th></tr>
<tr><td><pre>
    @  $s = "BAR"
    @  $n = 2
    @  $tab[1] = "foo" 
    @  $tab[2] = "bar" 
    @  $str = [ name: "FOO", count: 4 ]
      $s   $tab[ 1 ]    $tab[ $n ]
      $str.name, $str.count
</pre></td><td><pre>
      BAR   foo    bar      
      FOO, 4             
</pre></tr></table><p>
Arrays and structures can be expanded dynamically. 
The iteration over all elements is supported:
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Arrays and structures - iterating 
</th></tr>
<tr><td><pre>
    @  $tab = ["a","b","c",1000]
    @  $str = [ name: "FOO", count: 4, val: 1.20 ]
    @for ($i=0; $i<$size($tab); $i++)
       item $i: $tab[ $i ]
    @endfor
    STRUCTURE:
    @for ($i in $str)
       $i: $str.$i 
    @endfor    
</pre></td><td><pre>
    item 0: a
    item 1: b
    item 2: c
    item 3: 1000
    STRUCTURE:
    name: FOO 
    count: 4 
    val: 1.200000 
</pre></tr></table><p>
Arrays and structures may be nested.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Nested data structures: 
</th></tr>
<tr><td><pre>
   @ $data = [ "scalar", [a:"Alaska", b:"Bar"], \     
   @           [1,2,3,4],                       \     
   @           10 ]
</pre></tr></table><p>
  <p><b> Expressions    </b><p>
Expressions can be used in control lines and in data lines.  
One can use <b>constant expressions</b> (numbers and strings),
<b>selectors</b> (giving an access to array or structure items),
<b>constructors</b> (creating arrays and structures),
<b>arithmetic</b> expressions and <b>function calls</b>.
Any expression can be enclosed in symbols <b><samp>$(  )</samp></b>;
sometimes (in data lines) it must be enclosed, because only tokens starting with
<b><samp>$</samp></b> are interpreted as expressions in <b>data lines</b>.
The addition operator ( <b><samp>+</samp></b> ) has additional meaning:
it is used as string concatenation operator.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Available operators (semantics as in C): 
</th></tr>
<tr><td><pre>
    -          ==        ++ (postfix and prefix)  
    +          !=        -- (postfix and prefix)   
    *           =        &&
    /           <        ||
    -=          >
    +=         <=
    *=         >=
    /=          !
</pre></tr></table><p>
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Expression examples: 
</th></tr>
<tr><td><pre>
    1    1.01   "foo"   'bar'    
    $x -= 10
    [ 1, 2, "FOO" ]
    [ name: "foo", val: 0 ]
    $fun( 10, $x )
    $var.x
    $var.$field
    $tab[ 10 ]
    $( 'Foo bar bazoola' )
</pre></td><td><pre>
    numbers and strings
    arithmetic expression 
    array constructor  
    structure constructor 
    function call    
    selector (field access)  
    selector (access by name)              
    selector (item access)         
    parenthesed expression
</pre></tr></table><p>
<a name='_fun_call'>
Each data line is expanded by substituting expression with calculated
values. For function calls, value is the string returned from function
with <a href=#_return><b><samp>@return</samp></b></a> command.
The data lines interpreted inside the function do not cause text emitting.
When the function is called from control line, the rule is reversed:
returned value is ignored and data lines from the function body are
expanded and emitted.
This sounds complicated, so you should read the example:
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Function call: 
</th></tr>
<tr><td><pre>
    @function fun()
        inline text
    @   return "RESULT TEXT"    
    @endfunction
    called from data line: $fun()  
    @ $fun()    
</pre></td><td><pre>
    called from data line: RESULT TEXT   
        inline text
</pre></tr></table><p>
  <p><b>    Control commands    </b><p>
 <a name='_'>
  <p><b>      @  </b><p>
The lines started with <b><samp>@</samp></b> after which there is an expression 
are interpreted by calculating the expression.
The evaluated value is then ignored - as in C, the side effects are
the goal of such expression-instruction.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Expression instructions 
</th></tr>
<tr><td><pre>
    @ $fun()    
    @ $x = 1
</pre></tr></table><p>
 <a name='_break'>
  <p><b>      @ break  </b><p>
<b><samp>@break</samp></b> command works as C language    <b><samp>break</samp></b> instruction.
It breaks <a href=#_for><b><samp>@for</samp></b></a> loop and
<a href=#_switch><b><samp>@switch</samp></b></a> instruction.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
@break command: 
</th></tr>
<tr><td><pre>
    @for ( $i=0; $i<10; $i++ )  
       iteration  $i
    @  break
    @endfor
      
    @switch ( 1 )
    @  case 1:
       branch 1
    @  break   
    @  case 2:
       branch 2
    @endswitch    
</pre></td><td><pre>
   iteration  0     
   branch 1
</pre></tr></table><p>
 <a name='_embed'>
  <p><b>      @ embed </b><br>
 <a name='_emit'> 
     <b>      @ emit </b><p>
The two commands <b><samp>@embed</samp></b> and <b><samp>@emit</samp></b> allow 
to change order of generated lines.   
<b><samp>@embed</samp></b> defines  point  in which the text will be emitted,
<b><samp>@emit</samp></b> redirects output stream to emit point declared
in other place.
This is important that emit point can be declared in different source file
before - or after - <b><samp>@emit</samp></b> command. It can emit text
to different output file.
The four commands: 
<a href=#_emit>@emit</a>,
<a href=#_embed>@embed</a>,
<a href=#_push>@push</a>,
<a href=#_pop>@pop</a>
are probably the most robust mechanism of <b><samp>Temgen</samp></b> .
<p>
<b><samp>@embed</samp></b> and <b><samp>@emit</samp></b> accept any expression as argument,
not only constant strings.
<p>
<b><samp>@embed 'Name'</samp></b> means:  emit here after finding <b><samp>@emit 'Name'</samp></b>. <br>
<b><samp>@emit 'Name'</samp></b> means: emit in point marked with <b><samp>@embed 'Name'</samp></b>. <br>
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Emit points: 
</th></tr>
<tr><td><pre>
    @embed "header"
    @embed "body"
    @embed "footer"   
    @emit  "body"
      BODY TEXT
    @emit  "footer"
      FOOTER TEXT
    @emit  "header"    
      HEADER TEXT
</pre></td><td><pre>
    HEADER TEXT   
    BODY TEXT
    FOOTER TEXT
</pre></tr></table><p>
 <a name='_for'>
  <p><b>      @ for </b><p>
The basic form of <b><samp>@for</samp></b> works similar as in C language.
The loop can be broken with the <a href=#_break><b><samp>@break</samp></b></a> command.
The second form is used for iterating over structure fields.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Loops: 
</th></tr>
<tr><td><pre>
    @for ( $i=0; $i<3; $i++ )
       item  $i
    @endfor

    @  $str = [ a: "FOO", b: "BAR" ]    
    @for ( $fld in $str )
       $fld: $str.$fld 
    @endfor    
</pre></td><td><pre>
       item  0     
       item  1
       item  2
       a: FOO 
       b: BAR 
</pre></tr></table><p>
 <a name='_function'>
  <p><b>      @ function  </b><p>
<b><samp>@function</samp></b> command starts function definition. 
Argument names are enumerated in function header.
<a href=#_return><b><samp>@return</samp></b></a> command is used to return
function result. As <a href=#_fun_call>explained before</a>,
function call effect depends on the function call place.
Functions can be called in any template file, before or after
function declaration.
The command 
<a href=#_local><b><samp>@local</samp></b></a> is used to declare local variables.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Function: 
</th></tr>
<tr><td><pre>
    @function factor( n )
    @  if ( $n == 1 )
    @     return 1
    @  else
    @     return $n * $factor( $n - 1 )   
    @  endif    
    @endfunction
   
    @for ( $i=1; $i<8; $i++ )
       $i ! = $factor($i)
    @endfor
</pre></td><td><pre>
     1 ! = 1
     2 ! = 2
     3 ! = 6
     4 ! = 24
     5 ! = 120
     6 ! = 720
     7 ! = 5040    
</pre></tr></table><p>
 <a name='_if'>
  <p><b>      @ if  </b><p>
The conditional command  <b><samp>@if</samp></b> is classic.
It is presented in many examples here.
 <a name='_local'>
  <p><b>      @ local  </b><p>
The <b><samp>@local</samp></b> command allows to declare local variable in function.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Local variable: 
</th></tr>
<tr><td><pre>
   @function abc(a,b)   
   @local c    
      $a $b $c
   @   $a='anew'
   @   $b='bnew'
   @   $c='cnew'
      $a $b $c
   @endfunction
   
   @ $a='a'
   @ $b='b'
   @ $c='c'

   $a $b $c
   @ $abc( $a, $b )
   $a $b $c
</pre></td><td><pre>
    a b c
        a b 
        anew bnew cnew   
    a b c
</pre></tr></table><p>
 <a name='_output'> 
  <p><b>      @ output </b><p>
Command <b><samp>@output</samp></b> interpretation causes switching output file
to file named in argument.
Together with the four command:
<a href=#_embed><b><samp>@embed</samp></b></a>,
<a href=#_emit><b><samp>@emit</samp></b></a>,
<a href=#_pop><b><samp>@pop</samp></b></a> and 
<a href=#_push><b><samp>@push</samp></b></a>
it constitutes command set used to control generation output.
Special file name  <b><samp>"stdout"</samp></b> is used to redirect
text to standard output of generator.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
Controlling output: 
</th></tr>
<tr><td><pre>
    @output "foo" 
      FOO
    @output "stdout"  
      STDOUT
</pre></tr></table><p>
 <a name='_pop'> 
  <p><b>      @ pop </b><br>
 <a name='_push'> 
     <b>      @ push </b><p>
<b><samp>@pop</samp></b> and <b><samp>push</samp></b> are used to save and restore
emit point. Emit point is set by commands
 <a href=#_output><b><samp>@output</samp></b></a> (file) and <a href=#_emit><b><samp>@emit</samp></b></a>
(line).  
<b><samp>@pop</samp></b> and <b><samp>@push</samp></b> are useful inside function body,
allowing to restore emit point to its state before function entry.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
@Push and @pop: 
</th></tr>
<tr><td><pre>
    @function decl( d )
    @  push
    @  output "example.h"
         $d
    @  pop
    @endfunction    
            
    @output "example.c"
        
    #include "example.h"
        
    @ $decl( "int i;" )
        
    int main()
    {
    @ $decl( "int result;" )   
          return result;    
    }
</pre></td><td><pre>
example.h:

   int i;
   int result;

example.c:

#include "example.h"   
int main()
{
      return result;    
}
</pre></tr></table><p>
 <a name='_return'>
  <p><b>      @ return </b><p>
The <b><samp>@return</samp></b> ends <a href=#_fun_call>function call</a>
and returns result.
 <a name='_switch'>
  <p><b>      @ switch </b><p>
The <b><samp>@switch</samp></b> command has syntax similar to <b><samp>switch</samp></b>
instruction in C language.    
The difference is in <b><samp>@case</samp></b> labels.   
One can use any expressions as <b><samp>@case</samp></b> labels, not
only constant literals, as in C.
The <a href=#_break>@break</a> is used analogous to language C.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
@switch command: 
</th></tr>
<tr><td><pre>
    @function string( len )
    @  if ( $len == 1 )
    @     return "z"
    @  else
    @     return "z" + $string( $len-1 )   
    @  endif 
    @endfunction    
      
    @switch "zz"
    @  case $string(1) :
          1
    @     break  
    @  case $string(2) :
          2
    @     break  
    @  case $string(3) :
          3
    @     break  
    @endswitch
</pre></td><td><pre>
     2      
</pre></tr></table><p>
<a name='_use'> 
  <p><b>      @ use </b><p>
The <b><samp>@use</samp></b> command (known from Perl) allows to
load template code from external file.
The file name must be given as constant string.
Loaded code is not interpreted, but the functions defined in the code
are available.
<b><samp>Temgen</samp></b> checks for redundant loading, skipping already loaded files.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
@use command: 
</th></tr>
<tr><td><pre>
   @use "foo.tg"    
   @  $foo()
</pre></td><td><pre>
   FOO     
</pre></tr></table><p>
 <a name='_printf'> 
  <p><b>      $printf() </b><p>
The <b><samp>$printf</samp></b> function is used to expression formatting.
It works similar to functions from <b><samp>printf (3)</samp></b> family.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$printf() 
</th></tr>
<tr><td><pre>
    $printf( "%-10s %d 0x%02X", "foo", 10, 10 ) 
</pre></td><td><pre>
 foo        10 0x0A  
</pre></tr></table><p>
 <a name='_size'>   
  <p><b>      $size()  </b><p>
The <b><samp>$size</samp></b> function returns size (number of fields)
of compound object.    
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$size() 
</th></tr>
<tr><td><pre>
    @ $x = 1
    @ $y = [ 1, 2, 3 ]
    @ $z = [ a:"foo", b:10 ]
    
    $size($x)  $size($y)  $size($z)  $size($undef)  
</pre></td><td><pre>
  0  3  2  0   
</pre></tr></table><p>
 <a name='_strlen'>
  <p><b>      $strlen() </b><p>
The <b><samp>$strlen</samp></b> function returns length of string.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$strlen() 
</th></tr>
<tr><td><pre>
    @ $x = 1
    @ $y = "Foo Bar"
   
    $strlen($x)  $strlen($y)  $strlen($undef)
</pre></td><td><pre>
    0  7  0   
</pre></tr></table><p>
 <a name='_substr'>
  <p><b>      $substr() </b><p>
The <b><samp>$substr</samp></b> function returns substring starting from
given point, having given length (or up to the end - if
only two arguments are used).        
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$substr() 
</th></tr>
<tr><td><pre>
    $substr( "ABCDEFGHIJK", 2, 5 )
    $substr( "ABCDEFGHIJK", 2 )
    $substr( "ABCDEFGHIJK", 2, 50 )
</pre></td><td><pre>
  CDEFG
  CDEFGHIJK   
  CDEFGHIJK
</pre></tr></table><p>
 <a name='_system'>
  <p><b>      $system() </b><p>
The <b><samp>$system</samp></b>  function executes system command,
reads the command output and returns its content.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$system() 
</th></tr>
<tr><td><pre>
    $system("ps")   
</pre></td><td><pre>
      PID TTY          TIME CMD
      348 pts/0    00:00:00 bash   
      713 pts/0    00:00:00 tg
      714 pts/0    00:00:00 ps
</pre></tr></table><p>
 <a name='_tplfile'>
  <p><b>      $tplfile() </b><br>
 <a name='_tplline'>
     <b>      $tplline() </b><p>
The two functions returns current file name and line number in template.
<p>
<table border=1 bgcolor="#ffe0c0" width="98%"><tr><th colspan=2 align='left'> 
$tplfile(), $tplline() 
</th></tr>
<tr><td><pre>
    \#line  $tplline()  \"$tplfile()\"     
</pre></td><td><pre>
#line  2  "sample.tg"      
</pre></tr></table><p>
   <a name=section4>
   <h2> 4. Examples </h2>
In the <b><samp>sample/</samp></b> directory there are some examples
of <b><samp>temgen</samp></b> templates.
<ol>
<li> <b><samp>sample/class/</samp></b> - using temgen to C++ code generating
<li> <b><samp>sample/docex/</samp></b> - examples from the documentation
<li> <b><samp>sample/getopt/</samp></b> - classic example - command line options
</ol>
   <a name=section5>
   <h2> 5. Author, license </h2>
Marek Letowski is the author
(mletowski@firma.interia.pl).
All comments and suggestions are appreciated.
The program is distributed with full source code,
on the terms of GNU General Public License.
<p>
<hr>
<small>
<a href="intro_pl.html"> Polish version </a> -
<a href="intro.html"> English version </a> -
<a href="temgen.html"> User manual </a> -
Download: <a href="http://download.berlios.de/temgen/tg-0.11.tgz"> tg-0.11.tgz </a>
</small>
</body></html>
