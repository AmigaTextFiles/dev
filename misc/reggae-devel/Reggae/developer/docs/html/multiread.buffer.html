<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML><HEAD>
<TITLE>multiread.buffer.html</TITLE>
<!-- Source: class.c -->
<!-- Generated with RoboDoc v3.1a (Jul  3 2005) -->
<!-- RoboDoc is copyright 1994-1997 by Maverick Software Development -->
</HEAD><BODY>
<H1 ALIGN="center">TABLE OF CONTENTS</H1>
<OL>
<LI><A HREF="#background">multiread.buffer/background</A>
<LI><A HREF="#MMM_Peek">multiread.buffer/MMM_Peek</A>
<LI><A HREF="#MMM_Restore">multiread.buffer/MMM_Restore</A>
<LI><A HREF="#MMM_Seek">multiread.buffer/MMM_Seek</A>
</OL>
<HR>

<H2><A NAME="background">multiread.buffer/background</A></H2>

<FONT SIZE="+1">DESCRIPTION</FONT>
<PRE>       The class makes it possible to read the same data from a stream
       multiple times (it is called peeking data). While this functionality
       is easy to achieve for backward seekable streams, for sequential
       access streams data buffering is required. The multiread.buffer
       performs all needed buffering. The three methods related to peeking
       feature are <A HREF="#MMM_Peek">MMM_Peek</A>, <A HREF="#MMM_Restore">MMM_Restore</A>, <A HREF="multimedia.class.html#MMM_Pull">MMM_Pull</A> and <A HREF="#MMM_Seek">MMM_Seek</A>. These
       methods interacts in the following way:
       1. The stream of data (output port) has associated two data
          pointers: read pointer and peek pointer. Both are set to 0 at
          object creation.
       2. Read pointer can never be greater than peek pointer.
       3. Advancing peek pointer copies data to the buffer, advancing read
          pointer throws read data out of the buffer.
       4. <A HREF="#MMM_Peek">MMM_Peek</A> advances peek pointer and does not touch read pointer.
       5. <A HREF="multimedia.class.html#MMM_Pull">MMM_Pull</A> advances read pointer and may advance peek pointer too,
          to fulfill rule 2. Some internal buffers may be discarded to
          fulfill rule 3.
       6. <A HREF="#MMM_Restore">MMM_Restore</A> moves peek pointer back to be equal to read pointer,
          but data buffers are not discarded, so following <A HREF="#MMM_Peek">MMM_Peek</A> or
          <A HREF="multimedia.class.html#MMM_Pull">MMM_Pull</A> will read buffered data again.
       7. <A HREF="#MMM_Seek">MMM_Seek</A> sets both read and peek pointer to the seek position. All
          buffered data are flushed.

</PRE><FONT SIZE="+1">NEW METHODS</FONT>
<PRE>       <A HREF="#MMM_Peek">MMM_Peek</A>(port, buffer, length)            (V50)
       <A HREF="#MMM_Restore">MMM_Restore</A>(port)                         (V50)
       <A HREF="#MMM_Seek">MMM_Seek</A>(port, type, position)            (V51)

</PRE>
<HR>

<H2><A NAME="MMM_Peek">multiread.buffer/MMM_Peek</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE>       <B>MMM_Peek</B> -- Reads a data block from a port and buffers it internally.
         (V50)

</PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       ULONG DoMethod(Object *obj, <B>MMM_Peek</B>, ULONG port, APTR buffer, ULONG
         length);

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       The method reads a block of data of given length from a port of
       specified object starting from current peek pointer position. Data
       may be read from output ports only. It works similarly to <A HREF="multimedia.class.html#MMM_Pull">MMM_Pull</A>
       except of data are also copied to an internal buffer. Peek pointer is
       advanced, read pointer is not moved.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       obj - object to perform method on.
       port - number of port to peek data from, must be 1 (output port).
       buffer - address of buffer for peeked data.
       length - number of bytes to peek.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       Number of bytes read from port. <A HREF="multimedia.class.html#MMA_ErrorCode">MMA_ErrorCode</A> contains secondary
       error information:
       - MMERR_WRONG_ARGUMENTS - buffer is NULL, or port is not 1.

</PRE>
<HR>

<H2><A NAME="MMM_Restore">multiread.buffer/MMM_Restore</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE>       <B>MMM_Restore</B> -- Moves stream peeking position back, without clearing
         data buffers. (V50)

</PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       void DoMethod(Object *obj, <B>MMM_Restore</B>);

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       Moves back stream peek pointer to stream read pointer position
       without discarding peek buffers. Following <A HREF="multimedia.class.html#MMM_Pull">MMM_Pull</A> or <A HREF="#MMM_Peek">MMM_Peek</A> will
       fetch data from buffers.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       obj - object to perform method on.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       None

</PRE><FONT SIZE="+1">SEE ALSO</FONT>
<PRE>       <A HREF="#MMM_Peek">MMM_Peek</A>

</PRE>
<HR>

<H2><A NAME="MMM_Seek">multiread.buffer/MMM_Seek</A></H2>

<FONT SIZE="+1">NAME</FONT>
<PRE>       <B>MMM_Seek</B> -- Moves stream pointer to a specified position.
         (V51)

</PRE><FONT SIZE="+1">SYNOPSIS</FONT>
<PRE>       ULONG DoMethod(Object *obj, <B>MMM_Seek</B>, ULONG port, ULONG type,
         UQUAD *position);

</PRE><FONT SIZE="+1">FUNCTION</FONT>
<PRE>       The method performs seek on the previous object in the pipeline first.
       If previous object seek is OK, all peek buffers are flushed, then both
       peek and read pointer are set to the new position. This way following
       peek or read operation will start at specified stream position. If the
       previous connected object refuses seek operation for any reason,
       buffers and pointers are not changed. Error code from the previous
        object is set for this object as well.

</PRE><FONT SIZE="+1">INPUTS</FONT>
<PRE>       obj - object to perform method on.
       port - number of port to seek, must be 1 (output port).
       type - seek type.
       position - a pointer to UQUAD variable containing new position.

</PRE><FONT SIZE="+1">RESULT</FONT>
<PRE>       Number of bytes read from port. <A HREF="multimedia.class.html#MMA_ErrorCode">MMA_ErrorCode</A> contains secondary
       error information:
       - MMERR_WRONG_ARGUMENTS - wrong port, unknown type.
       - MMERR_NOT_SEEKABLE - the previous object refused seeking, because
         it is not seekable.
       - MMERR_END_OF_DATA - the previous object refused seeking, because
         desired position is after stream end.
       - MMERR_NOT_IMPLEMENTED - the previous object do not understand
         specified seek type (for example MMM_SEEK_FRAMES on MMF_STREAM).

</PRE>
</BODY></HTML>
