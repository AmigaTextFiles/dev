TABLE OF CONTENTS
0001 multimedia.class/background
0002 multimedia.class/MediaAllocVec
0003 multimedia.class/MediaConnectTagList
0004 multimedia.class/MediaFindClassTagList
0005 multimedia.class/MediaFreeVec
0006 multimedia.class/MediaGetClassAttr
0007 multimedia.class/MediaLog
0008 multimedia.class/MediaNewObjectTagList
0009 multimedia.class/MMA_AutoDestruction
0010 multimedia.class/MMA_ErrorCode
0011 multimedia.class/MMA_ObjectName
0012 multimedia.class/MMA_Port_ConnNumber
0013 multimedia.class/MMA_Port_ConnObject
0014 multimedia.class/MMA_Port_Format
0015 multimedia.class/MMA_Port_FormatsTable
0016 multimedia.class/MMA_Port_Number
0017 multimedia.class/MMA_Port_Object
0018 multimedia.class/MMA_Port_Type
0019 multimedia.class/MMA_Ports
0020 multimedia.class/MMM_AddPort
0021 multimedia.class/MMM_ConnectPort
0022 multimedia.class/MMM_DisconnectPort
0023 multimedia.class/MMM_GetPort
0024 multimedia.class/MMM_GetPortFwd
0025 multimedia.class/MMM_IsMember
0026 multimedia.class/MMM_LockObject
0027 multimedia.class/MMM_Pull
0028 multimedia.class/MMM_Push
0029 multimedia.class/MMM_Seek
0030 multimedia.class/MMM_SetPort
0031 multimedia.class/MMM_SetPortFwd
0032 multimedia.class/MMM_Setup
0033 multimedia.class/MMM_UnlockObject
multimedia.class/background

DESCRIPTION
   This class is the main class of Reggae system and the one and only having
   two programmimg interfaces: library interface and BOOPSI interface.
   BOOPSI interface is used for operations on existing objects, while
   library one is used for object creation and for functionality not related
   to objects. Tasks performed by multimedia.class are:
   - error reporting.
   - managing object's ports.
   - connecting ports.
   - automatically building processing structures.
   - database of available classes.
   - stream format recognition.
   - passing methods along processing structures.
   Multimedia.class is a direct subclass of rootclass.


NEW ATTRIBUTES
   Attributes applicability:
     I - may be set at creation time.
     S - may be set on an existing object.
     G - may be get from an object.
     P - may be set for an object's port.
     Q - may be queried from an object's port.

   MMA_Port_Object        (V50) [....Q], Object*
   MMA_Port_Number        (V50) [....Q], ULONG
   MMA_Port_FormatsTable  (V50) [...PQ], ULONG*
   MMA_Port_Format        (V50) [...PQ], ULONG
   MMA_Port_ConnObject    (V50) [...PQ], Object*
   MMA_Port_ConnNumber    (V50) [...PQ], ULONG
   MMA_Port_Type          (V50) [...PQ], ULONG
   MMA_Ports              (V50) [..G..], ULONG
   MMA_ErrorCode          (V50) [ISG..], ULONG
   MMA_ObjectName         (V51) [ISG..], ULONG
   MMA_AutoDestruction    (V52) [I....], BOOL


NEW METHODS
   MMM_LockObject()                          (V50)
   MMM_UnlockObject()                        (V50)
   MMM_GetPort(port, attr, storage)          (V50)
   MMM_SetPort(port, attr, value)            (V50)
   MMM_GetPortFwd(port, attr, storage)       (V50)
   MMM_SetPortFwd(port, attr, value)         (V50)
   MMM_AddPort(number)                       (V50)
   MMM_Push(port, buffer, length)            (V50)
   MMM_Pull(port, buffer, length)            (V50)
   MMM_IsMember(parent)                      (V50)
   MMM_Seek(port, type, position)            (V51)
   MMM_Setup(port)                           (V51)
   MMM_DisconnectPort(port)                  (V52)
   MMM_ConnectPort(port, destobj, destport)  (V52)


HISTORY
 52.4  (23.02.2007)
 - Added MMM_DisconnectPort() and MMM_ConnectPort() methods, now all ports
  	are	connected and disconnected with	these methods. It allows objects to
  	track number of their connected ports.
 - Added MMA_AutoDestruction attribute and auto destruction mechanism for
  	automatic objects.
 - Added automatic insertion of audio common format converter object in
  	LibMediaConnect().
 - Ports are disconnected from previous objects before connection.

 52.3  (15.01.2007)
 - Added DisconnectPorts() function. It is now called from LibMediaConnect()
   if MMM_Setup on any of ports being connected fails.
 - Added handling of errors returned by MediaConnectTagList() in
  	CreateDecodingTree().

 52.2  (12.01.2007)
 - Added proper error reporting in CreateDecodingTree().

 52.1  (06.01.2007)
 - Added a new function to the API, it is MediaSetLogLevel(). This function
   is related to moving log messages filtering from logging application to
   the multimedia.class. It lowers logging overhead as log messages below
   filter level are rejected in MediaLog() function and not sent to
   MediaLogger at all. Log level is set to LOG_NONE by default. MediaLogger
   sets it to user desired level at start and sets it back to LOG_NONE at
   exit. Then if MediaLogger is not running, all messages are immediately
   rejected by MediaLog(), saving on message and message port creation,
   finding destination port etc. Note that the new function is not
   protected against more than one application calling it (it is global
   setting). As MediaLogger is a single-instance application, and there is
   no other one, it should not be a problem. Note that MediaLogger has been
   updated too, this version of multimedia.class will work with MediaLogger
   1.6 or newer.

 51.10 (31.10.2006)
 - Fixes in documentation and media log messages.

 51.8  (06.01.2006)
 - MediaConnect() fails now if any of MMM_Setup() calls on ports being
   connected fails.
 - Default object names for objects created in the decoding tree contain now
   the object's true class name instead of word "object" (more descriptive
   debug output).
 - MMA_ObjectName is settable now.
 - Default MMM_Setup() implemented for subclasses not needing setup.
 - MediaConnect() clears MMA_ErrorCode for both objects before connecting.

 51.7  (15.11.2005)
 - Fixed MMA_ErrorCode problem in MediaGetPort().
 - MediaGetPort() and MediaGetPortFwd() do not clear object error to 0.

 51.6  (12.06.2005)
 - Fixed bug in MediaAllocVec(), it simply didn't worked under MorphOS 1.4.
   Also on machines with no AltiVec available alignment requirements are
   lowered from 16 to 8 bytes.

 51.5  (04.05.2005)
 - Fixed bug in TagInArrayWild(), it caused only the first port format in a
   format list was recognized.

 51.4  (29.04.2005)
 - Fixed bug in MediaNewObjectTagList(), it always returned NULL, even if
   object creation was succesfull.
 - Fixed bug in MediaNewObjectTagList(), now forward is added for every
   decoder output.

 51.3  (21.04.2005)
 - Removed annoying debug message "Errors cleared for...".
 - All objects created by MediaNewObjectTagList() are now disposed if the
   function fails.
 - CreateDecodingTree() is now called on multiread.buffer object as it
   should, not on processblock object.
 - Multiread buffers are now correctly added to the processblock (and then
   correctly disposed with it).

 51.2  (20.04.2005)
 - Implemented MMA_ObjectName.
 - Added object name output to all debug messages.

 50.24 (07.03.2005)
 - Supports MMF_ANY_FORMAT in MediaConnectTagList() as a wildchar.

 50.23 (19.02.2005)
 - MMM_AddPort has protection against creating more than one port with the
   same number.
 - MMA_ErrorCode support in MediaNewObjectTagList().
 - MediaConnectTagList() has protection against connecting two ports of the
   same object.

 50.22 (18.12.2004)
 - New forwarding scheme according to the docs, MMM_GetPortFwd and
   MMM_SetPortFwd removed as not needed.
 - OM_DISPOSE: every port is disconnected before disposing (it means, its
   connected peer port gets MMA_ConnPort = MM_NO_PORT and MMA_ConnObject =
   NULL).

 50.21 (16.12.2004)
 - Implemented new methods: MMM_GetPortFwd, MMM_SetPortFwd, MMM_IsMember.

 50.20 (08.12.2004)
 - MediaConnect() modified: MMM_Setup method is called on both connected
   ports.

 50.19 (06.12.2004)
 - Fixed bug in MediaFindClass() when searching against MMA_DataFormat
   value.

 50.18 (28.11.2004)
 - Implemented MediaGetClassAttr().

 50.17 (27.11.2004)
 - Implemented MediaFindClass().

 50.16 (18.11.2004)
 - Recognize routines are now enqueued according to MMA_Priority tag from
 class data.

 50.15 (03.11.2004)
 - Implemented new class identification system.
 - match_datatype() is semaphore protected.

 50.14 (31.10.2004)
 - Media type filter (MMA_MediaType) working in MediaNewObject().

 50.13 (23.10.2004)
 - Processblock object is disposed and MediaNewObject() returns NULL, when
   the pipeline was not created fully (for example missing decoder).
 - Added missing error log messages.

 50.12 (01.09.2004)
 - Fixed bug in MediaConnect(), second port format was set for the first
   port if both ports had formats tables only.

 50.11 (25.08.2004)
 - MediaConnect() full implementation.
 - Implemented MMM_Pull for pulling from input port (useful for subclasses,
   they can pull from their inputs), it is passed to connected object.
 - Added missing MMA_Port_Type in MMM_GetPort.
 - Added missing MMA_Port_ConnObject and MMA_Port_ConnNumber in MMM_SetPort.

 50.10 (20.08.2004)
 - MMM_AddPort initializes connected port number to MM_NO_PORT (invalid
   number), so wrong port connection can be detected.
 - Added library interface function MediaConnect() - no-op for now, for
   testing only.

 50.9 (19.08.2004)
 - Fixed stupid bug in initialization of MediaPort list.
 - MMM_SetPort works with MMA_Port_Type, MMA_Port_Format,
   MMA_Port_FormatsTable.
 - MMM_GetPort fully implemented.

 50.8 (09.04.2004)
 - Demuxers scan routine uses query.library instead of proprietary code.

 50.7 (20.02.2004)
 - Added DTOA_LoadAdvance attribute. It returns current advance in reading
   source (compressed) stream. Useful when uncompressed data size is unknown
   (for example mp3.decoder returns 0 for SNDA_FrameCount, because if you
   want to know number of uncompressed frames, you have to scan the whole
   file). Note that it only works with source stream of known length
   (returning non-zero DTSA_CurrentSize). It may be less accurate than
   calculating advance on decompressed data, since compression ratio may be
   variable through the stream, also DTOA_LoadAdvance takes stream header
   into account. Attribute value is percents multiplied by 10 000, so
   1 000 000 means 100% of source stream has been read.
 - Fixed bug, OM_GET for all per class attributes (DTOA_ClassName,
   DTOA_ClassDesc, DTOA_MimeType, DTOA_DataFormat) was broken.

 50.6 (30.12.2003)
 - Added: Support for DTOA_ErrorCode in NewMediaObject() and OM_NEW.
 - Removed: Check for source stream in OM_NEW (it is subclass specific).

 50.5 (07.12.2003)
 - Added: DTOA_DataType, DTOA_ClassDesc, DTOA_ClassName, DTOA_MimeType are
   now gettable.

 50.4 (29.11.2003)
 - Change: debug output is now switched by makefile target 'debug'.

 50.3 (07.11.2003)
 - Fixes caused by stream API changes.

 50.2 (22.09.2003)
 - Added functionality in NewMediaObject(), the function can create object
   stream itself, if there is no DTOA_SourceStream tag, but
   DTOA_SrcStreamName and DTOA_SrcStreamType pair instead. The library keeps
   track of created streams and these are disposed at OM_DISPOSE of object
   returned by NewMediaObject().


multimedia.class/MediaAllocVec

NAME
   MediaAllocVec -- Allocates memory for media buffers. (V50)


SYNOPSIS
   APTR MediaAllocVec(ULONG size);


FUNCTION
   The function is used for allocating processing buffers for Reggae
   classes. It should be used in subclasses for all buffers containing
   stream data. It also should be used by applications for data to be fed
   into Reggae processing structure and for buffers to be filled with data
   by Reggae objects as well. Using this function instead of exec functions
   ensures data are properly aligned for AltiVec unit available in G4/G5
   processors. AltiVec alignment is enforced only on machines with AltiVec
   available (to lower memory consumption and usage on low-end 60x and G3
   systems). Memory allocations via MediaAllocMem() can be tracked for
   testing and debug purposes.


INPUTS
   size - size of memory buffer to be allocated. The function returns NULL
     if zero size is passed.


RESULT
   Pointer to allocated buffer, or NULL for failure.


NOTES
   Memory allocated with MediaAllocVec() must be freed with MediaFreeVec().


SEE ALSO
   MediaFreeVec().


multimedia.class/MediaConnectTagList

NAME
   MediaConnectTagList -- Connects two ports of MOS Media objects. (V50)


SYNOPSIS
   BOOL MediaConnectTagList(Object *obj1, ULONG port1, Object *obj2, ULONG
   port2, struct TagItem *taglist);

   BOOL MediaConnectTags(Object *obj1, ULONG port1, Object *obj2, ULONG
   port2, Tag tag1, ...);


FUNCTION
   Connects two ports of media objects. The function checks if given ports
   exist in objects, then checks for matching data formats. There are three
   possible data format conditions:
   1. Both ports have format set explicitly. If it is the same format ports
      are connected, the function fails otherwise. If one of ports has
      MMF_ANY_FORMAT, it's format is set to the other's port one before
      connecting. If both ports have MMF_ANY_FORMAT, they are connected as
      is.
   2. One port has format set explicitly, the second one has format table.
      If the first port's format is found in second port's format table,
      ports are connected, the function fails otherwise. Matched format is
      set for the second port. If the explicitly set format is
      MMF_ANY_FORMAT, it is set to the first format found in the second port
      format table (unless it is empty) before connecting. Note that future
      tags may modify this behaviour in a way that not neccesarily the first
      format from the table may be choosen.
   3. Both ports have format tables. The second format table is searched for
      every format in the first table in turn. The first match is set as
      format for both ports. If there is no match, function fails. This
      matching process can be modified by tags in taglist in the future (it
      means if there is more than one match not neccesarily the first one
      will be selected).
   After succesfull connection, MMM_Setup method is called on both connected
   ports. This method is not used by Reggae main classes, but may be used by
   subclasses to perform setup dependent on datastream avaliability or
   parameters (for example demuxers can read stream header in MMM_Setup,
   other classes may create internal buffers etc.).


INPUTS
   obj1 - the first object to be connected.
   port1 - the number of port in obj1 to be connected.
   obj2 - the second object to be connected.
   port2 - the number of port in obj2 to be connected.
   taglist - for future expansion, no tags defined in V50. NULL taglist is
     OK and is treated as an empty one.


RESULT
   TRUE if ports connected succesfully. FALSE may be returned because of
   following reasons:
   - one or both of objects are NULL.
   - one or both of ports are not found in objects.
   - application is trying to connect two ports of the same object.
   - port formats do not match (see case 1. above).
   - no matching format found in ports format table[s] (see cases 2. and 3.
     above).
   - application is trying to connect two inputs or two outputs, or any of
     ports has wrong (uninitialized?) type.
   - any of ports has set neither format nor format table (uninitialized?).


multimedia.class/MediaFindClassTagList

NAME
   MediaFindClassTagList -- Finds MOS Media classes of given properties.
   (V50)


SYNOPSIS
   STRPTR MediaFindClassTagList(APTR *ptr, struct TagItem *taglist);

   STRPTR MediaFindClassTags(APTR *ptr, Tag tag1, ...);


FUNCTION
   The function is used for finding Reggae classes of given properties in
   the database maintained by multimedia.class. Properties are specified in
   the passed taglist. On the first call the function returns the first
   class found matching passed properties. To find all matching classes, the
   function should be called in a loop until it returns NULL. The value
   returned is the name of class.


INPUTS
   ptr - pointer to APTR pointer used for saving current position in the
     database. Must be initialized to NULL before the first call.
   taglist - list of tags specifying properties of classes to be found.
     Following tags are recognized:
     - MMA_ClassType, one of MMCLASS_xxx defined in
       <classes/multimedia/multimedia.h>.
     - MMA_MediaType, one of three media types (audio, picture, video)
       defined in <classes/multimedia/multimedia.h> or any OR-ed combination
       of them.
     - MMA_DataFormat, the name of media format (like "Audio IFF"), strings
       are compared.


RESULT
   Pointer to read-only, zero-terminated class name string, or NULL if no
   class found.


EXAMPLE
   \* search for all sound demuxers *\

   APTR p = NULL;   \* must be initialized to NULL *\
   STRPTR classname;

   while (classname = MediaFindClassTags(&p,
     MMA_MediaType, MMT_SOUND,
     MMA_ClassType, MMCLASS_DEMUXER,
   TAG_END))
   {
     \* do something with class name *\
   }


multimedia.class/MediaFreeVec

NAME
   MediaFreeVec -- Frees media buffer memory. (V50)


SYNOPSIS
   void MediaFreeVec(APTR memory);


FUNCTION
   The function frees media buffer memory allocated with MediaAllocVec().
   The memory tracker can report errors like wrong size or address.


INPUTS
   memory - buffer to be freed. The function does nothing if NULL pointer is
   passed.


RESULT
   none


NOTES
   Only memory allocated with MediaAllocVec() can be freed with
   MediaFreeVec().


SEE ALSO
   MediaAllocVec().


multimedia.class/MediaGetClassAttr

NAME
   MediaGetClassAttr -- Gets an attibute of a MOS Media class. (V50)


SYNOPSIS
   MediaGetClassAttr(STRPTR classname, ULONG attr, ULONG *storage);


FUNCTION
   Gets an attribute of specified MOS Media class. If the class is found in
   the database and the attribute is found in this class attribute list, the
   attribute value is stored at given pointer.


INPUTS
   classname - the name of the class (zero-terminated string).
   attr - attribute to get. Following attributes are recognized:
     - MMA_ClassType,
     - MMA_MediaType,
     - MMA_SupportedFormats.
   storage - pointer to a variable where attribute value is to be stored.


RESULT
   TRUE if class and attribute found and value stored. FALSE otherwise.


EXAMPLE
   \* prints all supported data format identifiers for a class *\

   ULONG *formats;

   if (MediaGetClassAttr("foo.class", MMA_SupportedFormats, 
     (ULONG*)&formats))
   {
     ULONG *p = formats;

     while (*p) Printf("Format $%08lx.\n", *p++);
   }


multimedia.class/MediaLog

NAME
   MediaLog -- Sends a debug message to logging application. (V50)


SYNOPSIS
   void MediaLog(ULONG level, STRPTR classname, STRPTR functionname, STRPTR
   msg, ...);


FUNCTION
   Sends log packet to an application with open public port named
   "MediaLogger". Typically it is MediaLogger application included with the
   Reggae package, but third party loggers are possible. Logger catches all
   debug messages, filters them, can also write them to a disk file. The
   function is typically used in subclasses for debug output. Message sent
   to the logger is of type 'struct MediaError' and is defined in the
   include file <classes/multimedia/multimedia.h>.


INPUTS
   loglevel - importance of the log message, one of LOG_ERRORS, LOG_INFO
     or LOG_VERBOSE. Used to filter messages in a logger application.
   classname - name of a class, the message is sent from.
   functionname - name of a function, the message is sent from.
   msg - message text. Can contain printf()-style placeholders,
     NewRawDoFmt() will be called on it with the text, and following
     variable arguments as parameters.
   [following arguments] - variable number of arguments to be passed to
     NewRawDoFmt().


RESULT
   None.


NOTES
   There are two macros MLOG() and MLOGV() defined in
   <classes/multimedia/multimedia.h> include file, which automatically use
   CLASSNAME (should be defined by subclass implementor) and __FUNCTION__
   GCC automatic macro, to fill 'classname' and 'functionname'. MLOG()
   should be used when there are no parameters after 'msg' (no
   placeholders), MLOGV() for one or more parameters after 'msg'. MLOGV()
   can take QUAD and UQUAD arguments (use "%Ld", "%Lu" or "%Lx"
   placeholders). MLOG1(), MLOG2() and MLOGQ() macros are obsolete and must
   not be used.

   V52: Starting from this version, MediaLog() filters out messages, which
   importance level is lower than log level set by MediaSetLogLevel(). If 
   a message importance is lower than the level set, MediaLog() call
   returns immediately and does not try to sent the message to the public
   "MediaLogger" port.


EXAMPLE
   \* Assume we are in 'foo.class' code and CLASSNAME is defined as *\
   \* "foo.class".                                                  *\

   void AnyFunction(void)
   {
     UQUAD value = 6;
     LONG errcode = 2983;

     MediaLog(LOG_ERRORS, "foo.class", "AnyFunction", 
       "Kernel panic - too many bugs in PSU fan!");
     \* or the same with MLOG() macro *\
     MLOG(LOG_ERRORS, "Kernel panic - too many bugs in PSU fan!");

     MediaLog(LOG_ERRORS, "foo.class", "AnyFunction",
       "Unknown error %lu, 64-bit value is $%Lx.", errcode, value);
     \* or the same with MLOGV() macro *\
     MLOGV(LOG_ERRORS, "Unknown error %lu, 64-bit value is $%Lx.",
       errcode, value);
   }


SEE ALSO
   exec.library/NewRawDoFmt()


multimedia.class/MediaNewObjectTagList

NAME
   MediaNewObjectTagList -- Creates complete decoding structure. (V50)


SYNOPSIS
   Object *MediaNewObjectTagList(struct TagItem *taglist);

   Object *MediaNewObjectTags(Tag tag1, ...);


FUNCTION
   This high-level function is used to create processing structure for
   opening and decoding media stream of unknown format. It is very
   convenient function for application programmers, as it automates common
   task of recognizing and decoding any media stream. The first step is to
   obtain source data stream. The stream can be defined in three different
   ways:
   1. An application can pass an already created stream object with
      MMA_Stream tag. The application is responsible for disposing this
      stream when no longer used.
   2. Stream can be specified with MMA_StreamName and MMA_StreamType to be
      opened by MediaNewObject(). Stream will be automatically disposed,
      when media object is disposed.
   3. The same as above, but stream is specified by its handle 
      (MMA_StreamHandle) instead of name. May be convenient for some types
      of streams. Meaning of stream name and handle depends on stream type
      (see streams documentation).
   The second stage is format recognition. Multimedia.class registers all
   available demultiplexers at startup. Every demultiplexer has its own
   format recognition routine. These routines are all loaded to memory
   during multimedia.class startup (without loading entire class code). Then
   MediaNewObjectTagList() calls every recognition routine in turn on stream
   passed. Every routine returns probability of stream being formatted with
   the format recognized by it. In a typical situation all routines return
   probability of 0, except one with probability of 1. If the stream format
   hasn't well defined and formed header (MP3 stream for example), more than
   one routine can return non-zero probability. The most probable format is
   always taken. Application has some control of recognition process. It can
   limit demultiplexer matching only to specific kind of media: sound,
   picture, video or any combination of them. It can be done with
   MMA_MediaType tag. Some media formats are difficult to detect. Detection
   can take much time, or CPU power. To avoid slowdown when it can't be
   accepted, recognition has two operation modes: "light" and "heavy" one.
   In "light" mode recognition is always fast, but may be inaccurate.
   "Heavy" recognition routines may be slower, but are more precise.
   Recognition mode is selected with MMA_Recognition tag. To speed
   recognition up, file formats with well defined headers (like WAVE) are
   tested before formats harder to recognize (like MP3). It is done by
   prioritizing registered demultiplexers list. After the stream format is
   recognized, the function opens matched demultiplexer library and creates
   new demultiplexer object. This object is fed with source stream. Then
   demultiplexer output format is checked. Many demultiplexers have only one
   output format (for example AIFF has big-endian PCM), but some may have
   more than one output format (WAVE is a good example). That is why
   demultiplexer output format is determined on demultiplexer object, not
   class. Then the function scans demultiplexer outputs. If an output is of
   MMF_STREAM type, the function calls itself recursively on this output. If
   not, a proper decoder object is created and attached. All created objects
   are added to a processblock grouping them. Pointer to this processblock
   object is used as the return value of MediaNewObjectTagList() function.


INPUTS
   taglist - list of tags specifying data source and other parameters.
     Accepted tags:
     - MMA_ErrorCode (pointer to an ULONG variable).
     - MMA_StreamName (name of stream to be opened).
     - MMA_StreamHandle (handle of stream to be opened).
     - MMA_StreamType (type (class name) of stream to be opened).
     - MMA_Stream (already created stream object).
     - MMA_MediaType (type of media, MMT_VIDEO, MMT_SOUND, MMT_PICTURE, may
       be OR-ed togehter).


RESULT
   Created processblock or NULL on failure. Secondary error information is
   available via MMA_ErrorCode attribute. Possible failure reasons are:
   - MMERR_NO_STREAM (incomplete stream specification).
   - MMERR_NO_STREAM_CLASS (stream class specified with MMA_StreamType not
     found or can't be opened).
   - MMERR_OUT_OF_MEMORY (as name says...)
   - MMERR_NOT_RECOGNIZED (no demuxer recognized the stream).
   - MMERR_NO_DECODER (no decoder for demuxer output format).


multimedia.class/MMA_AutoDestruction

NAME
   MMA_AutoDestruction [I....], BOOL


FUNCTION
   This attribute causes Reggae to automatically dispose an object when all
   its ports get disconnected. It is used for objects created automatically
   by Reggae (for example common format converters). Usage of this attribute
   in applications is not recommended.


multimedia.class/MMA_ErrorCode

NAME
   MMA_ErrorCode [ISG..], ULONG / ULONG*


FUNCTION
   Error code of the latest operation performed on the object. Note that
   error does not accumulate, so every succesful operation clears it to
   zero. When passed to OM_NEW [I], tag value should be a pointer to ULONG
   variable where error code will be stored. The same for OM_GET [G]. For
   OM_SET [S], tag value should be just error code.


multimedia.class/MMA_ObjectName

NAME
   MMA_ObjectName [ISG..], STRPTR


FUNCTION
   Pointer to a meaningful name for an object. It is mainly useful for
   making MediaLogger output more readable, because if an object has a name,
   it will be used in logs. Local copy of passed string is created in
   OM_NEW, so the passed string need not to be static. Default value for the
   name is "classname $XXXXXXXX", where 'classname' is the name of class
   (the same as the name of class executable file) 'X'-es are replaced by
   object address as hexadecimal digit.


NOTES
   Subclasses implementors: names are not used automagically, you should get
   MMA_ObjectName value explicitly (for example using predefined OBJNAME()
   macro) and pass it to MediaLog(). Multimedia.class always uses names in
   logs.


SEE ALSO
   MediaLog()


multimedia.class/MMA_Port_ConnNumber

NAME
   MMA_Port_ConnNumber [...PQ], ULONG


FUNCTION
   Returns or specifies a number of port connected to the queried one.


NOTES
   Not for general use. Do not touch without a reason. Use
   MediaConnectTagList() for connecting ports togehter.


SEE ALSO
   MediaConnectTagList()


multimedia.class/MMA_Port_ConnObject

NAME
   MMA_Port_ConnObject [...PQ], Object*


FUNCTION
   Returns or specifies a pointer to object connected to queried port.


NOTES
   Not for general use. Do not touch without a reason. Use
   MediaConnectTagList() for connecting ports togehter.


SEE ALSO
   MediaConnectTagList()


multimedia.class/MMA_Port_Format

NAME
   MMA_Port_Format [...PQ], ULONG


FUNCTION
   Specifies or returns media format of stream going through the port. When
   set to a port [P], the specified format must be found in format table of
   the port. If it is not, format is not set.


NOTES
   For subclasses implementors only.


multimedia.class/MMA_Port_FormatsTable

NAME
   MMA_Port_FormatsTable [...PQ], ULONG*


FUNCTION
   Specifies or returns a pointer to a zero-terminated table of media
   formats to be accepted or produced by given port.


NOTES
   For subclasses implementors only.


multimedia.class/MMA_Port_Number

NAME
   MMA_Port_Number [....Q], ULONG


FUNCTION
   Own number of port. Multimedia.class returns just number of port the
   query is performed on.


NOTES
   Processblock.class overrides this attribute to perform port forwarding.


multimedia.class/MMA_Port_Object

NAME
   MMA_Port_Object [....Q], Object*


FUNCTION
   Pointer to object, where the port belongs. Multimedia.class returns just
   pointer of object the query is performed on.


NOTES
   Processblock.class overrides this attribute to perform port forwarding.


multimedia.class/MMA_Port_Type

NAME
   MMA_Port_Type [...PQ], ULONG


FUNCTION
   Returns or specifies type of queried port. It can be MDP_TYPE_INPUT or
   MDP_TYPE_OUTPUT. Any other value means the port is not initialized
   properly.


NOTES
   Not for general use. Do not touch without a reason. Use
   MediaConnectTagList() for connecting ports togehter.


SEE ALSO
   MediaConnectTagList()


multimedia.class/MMA_Ports

NAME
   MMA_Ports [..G..], ULONG


FUNCTION
   Returns the number of ports in an object.


multimedia.class/MMM_AddPort

NAME
   MMM_AddPort -- Adds a port to an object. (V50)


SYNOPSIS
   LONG DoMethod(Object *obj, MMM_AddPort, ULONG number);


FUNCTION
   Adds new port to an object. Port is uninitialized and needs type and
   format or format table to be set.


INPUTS
   obj - object a port will be added to
   number - number of port to be created


RESULT
   TRUE if port was created succesfully. FALSE otherwise. The method may
   fail for two reasons:
   1. Out of memory, MMA_ErrorCode is MMERR_OUT_OF_MEMORY.
   2. Port with specified number already exists, MMA_ErrorCode is
      MMERR_WRONG_ARGUMENTS.


multimedia.class/MMM_ConnectPort

NAME
   MMM_ConnectPort -- Connects a port. (V52)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_DisconnectPort, ULONG port, Object
  	*destobj, ULONG destport);


FUNCTION
   Sets mdp_Port and mdp_Object of a port to specified destination object
  	and port number. Note that destination port and object are not verified
  	for validity. The method resolves processblock forwards	automatically, so
  	always the true port is connected.


INPUTS
   port - number of port to connect.
   destobj - pointer to the destination object.
   destport - number of destination port.


RESULT
   None.


NOTES
   Used internally by multimedia.class. Applications must use
  	LibMediaConnectTagList() API call.


multimedia.class/MMM_DisconnectPort

NAME
   MMM_DisconnectPort -- Disconnects a port. (V52)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_DisconnectPort, ULONG port);


FUNCTION
   Sets mdp_Object of disconnected port to NULL, and mdp_Port to MM_NO_PORT.
   It also decreases object's connected ports counter. The method resolves
   processblock forwards automatically, so always the true port is
  	disconnected.


INPUTS
   port - number of port to disconnect.


RESULT
   None.


NOTES
   Used internally by multimedia.class. Disposing an object causes
   MMM_DisconnectPort() on ports of objects connected to the one being
  	disposed.


multimedia.class/MMM_GetPort

NAME
   MMM_GetPort -- Gets a value of a port dependent attribute. (V50)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_GetPort, ULONG port, ULONG attribute,
   ULONG *storage);


FUNCTION
   Gets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. Usually this method is implemented at subclass level.
   If it reaches multimedia.class level and queried attribute is not port
   attribute but data stream one, the method is called on all outputs if
   comes from an input and called on all inputs if comes from an output.
   This way a query can travel along the processing structure.


INPUTS
   obj - queried object,
   port - number of queried port,
   attribute - queried attribute,
   storage - pointer to a variable, where value will be stored.


RESULT
   TRUE if the attribute was recognized and value stored, FALSE otherwise.


NOTES
   Two useful macros: MediaGetPort() and MediaGetPort64() defined in
   <classes/multimedia/multimedia.h> return directly the 32-bit or 64-bit
   value. May be used if return value of MMM_GetPort is not needed.


EXAMPLE
   UQUAD val64;
   ULONG val32;

   DoMethod(obj, MMM_GetPort, port, MMA_Any32BitAttr, &val32);
   \* is equivalent to *\
   val32 = MediaGetPort(obj, port, MMA_Any32BitAttr);

   DoMethod(obj, MMM_GetPort, port, MMA_Any64BitAttr, (ULONG*)&val64);
   \* is equivalent to *\
   val64 = MediaGetPort64(obj, port, MMA_Any64BitAttr);


multimedia.class/MMM_GetPortFwd

NAME
   MMM_GetPortFwd -- Gets a value of a port dependent attribute from
   connected port. (V50)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_GetPortFwd, ULONG port, ULONG attribute,
   ULONG *storage);


FUNCTION
   Gets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. This method gets a port connected to the specified one,
   and then performs MMM_GetPort on this connected port. This is the only
   difference between MMM_GetPort and MMM_GetPortFwd. MMM_GetPortFwd is
   usually used inside the class, when an object needs to query an attribute
   from the previous, or the next object in a processing structure. Using
   MMM_GetPort in this case will cause forwarding in wrong direction (query
   on input will be forwarded to outputs, query on output will be forwarded
   to inputs). MMM_GetPortFwd will forward query on input to the previous
   object's output, and query on output to the next object's input as
   expected.


INPUTS
   obj - queried object,
   port - number of queried port,
   attribute - queried attribute,
   storage - pointer to a variable, where value will be stored.


RESULT
   TRUE if the attribute was recognized and value stored, FALSE otherwise.


NOTES
   Two useful macros: MediaGetPortFwd() and MediaGetPortFwd64() defined in
   <classes/multimedia/multimedia.h> return directly the 32-bit or 64-bit
   value. May be used if return value of MMM_GetPort is not needed.


EXAMPLE
   UQUAD val64;
   ULONG val32;

   DoMethod(obj, MMM_GetPort, port, MMA_Any32BitAttr, &val32);
   \* is equivalent to *\
   val32 = MediaGetPort(obj, port, MMA_Any32BitAttr);

   DoMethod(obj, MMM_GetPort, port, MMA_Any64BitAttr, (ULONG*)&val64);
   \* is equivalent to *\
   val64 = MediaGetPort64(obj, port, MMA_Any64BitAttr);


SEE ALSO
   MMM_GetPort


multimedia.class/MMM_IsMember

NAME
   MMM_IsMember -- Checks if an object is a member of another object. (V50)


SYNOPSIS
   BOOL DoMethod(Object *obj, MMM_IsMember, Object *parent);


FUNCTION
   Returns TRUE if an object is member of parent object. At multimedia.class
   level this function always returns TRUE, as every object is a member of
   itself. The method is overloaded by processblock.class.


INPUTS
   obj - object to be checked.
   parent - object expected to have 'obj' as member.


RESULT
   Always TRUE on multimedia.class level.


SEE ALSO
   processblock.class/MMM_IsMember


multimedia.class/MMM_LockObject

NAME
   MMM_LockObject -- Locks Reggae object for exclusive use. (V50)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_LockObject);


FUNCTION
   Locks Reggae object for exclusive use. It is done by obtaining object's
   own semaphore. Locks can be nested.


INPUTS
   None.


RESULT
   None.


NOTES
   Not needed in applications usually, as every method is protected with
   MMM_LockObject / MMM_UnlockObject pair. Subclasses implementors should
   always use it in all methods.


SEE ALSO
   MMM_UnlockObject


multimedia.class/MMM_Pull

NAME
   MMM_Pull -- Pulls a data block from a port. (V50)


SYNOPSIS
   LONG DoMethod(Object *obj, MMM_Pull, ULONG port, APTR buffer, ULONG
   length);


FUNCTION
   The method pulls a block of data of given length from a port of specified
   object. Data may be pulled from output ports only. Usually a pull from
   object's output causes object to generate following pull from the
   previous object. In typical conditions MMM_Pull call does not reach
   multimedia.class. The one exception is when an object calls MMM_Pull on
   its own input. If it is the case, the object should pass this call to the
   superclass. Then the call reaches multimedia.class. The multimedia.class
   MMM_Pull implementation determines output port connected to the passed
   input and calls MMM_Pull on this input. The final result is that subclass
   implementor may safely call MMM_Pull on own object inputs, if only
   subclass MMM_Pull is implemented in a way that MMM_Pull calls on inputs
   are passed to superclass, these calls will be automatically forwarded to
   connected objects.


INPUTS
   obj - object to perform method on.
   port - number of port to pull data from.
   buffer - address of buffer for pulled data.
   length - number of bytes to pull.


RESULT
   Number of bytes pulled from port. MMA_ErrorCode contains secondary error
   information.


multimedia.class/MMM_Push

NAME
   MMM_Push -- Pushes a data block to a port. (V50)


SYNOPSIS
   LONG DoMethod(Object *obj, MMM_Push, ULONG port, APTR buffer, ULONG
   length);


FUNCTION
   The method pushes given block of data into a port of specified object.
   Data may be pushed to input ports only. Usually a push to object's input
   causes object to generate following push to the next object. In typical
   conditions MMM_Push call does not reach multimedia.class. The one
   exception is when an object calls MMM_Push on its own output. If it is
   the case, the object should pass this call to the superclass. Then the
   call reaches multimedia.class. The multimedia.class implementation of
   MMM_Push determines input port connected to the passed output and calls
   MMM_Push on this input. The final result is that subclass implementor may
   safely call MMM_Push on own object outputs, if only subclass MMM_Push is
   implemented in a way that MMM_Push calls on outputs are passed to
   superclass, these calls will be automatically forwarded to connected
   objects.


INPUTS
   obj - object to perform method on.
   port - number of port, where data will be pushed.
   buffer - address of data buffer.
   length - length of data in bytes.


RESULT
   Number of data bytes accepted by object. MMA_ErrorCode contains secondary
   error information.


multimedia.class/MMM_Seek

NAME
   MMM_Seek -- Forwards seek method to the connected object. (V50)


SYNOPSIS
   LONG DoMethod(Object *obj, MMM_Seek, ULONG port, ULONG type, UQUAD
   *position);


FUNCTION
   Multimedia.class version of MMM_Seek is called by a subclass, when an
   object wants to perform seek on its own input. Applications may call this
   method on output ports, seeking on input is for subclasses only. Calling
   on input means seek event backpropagation to the data source, then all
   objects in the pipeline can adjust their buffers and pointers. This class
   implementation of MMM_Seek passes the method to a port connected to the
   specified one. If this fails, error code from the connected object is
   passed forward to the calling one.


INPUTS
   obj - object calling for seek backpropagation.
   port - input port to be used.
   type - seek type, neither interpreted nor checked here.
   position - a pointer to UQUAD variable containing the new position,
     neither interpreted, nor checked here.


RESULT
   Result of seek on the object connected to the port passed. MMA_ErrorCode
   is propagated forward in case of failure.


multimedia.class/MMM_SetPort

NAME
   MMM_SetPort -- Sets a value of a port dependent attribute. (V50)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_SetPort, ULONG port, ULONG attribute,
   ULONG value);


FUNCTION
   Sets the value of an attribute, which is port-dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. Usually this method is implemented at subclass level.
   If it reaches multimedia.class level and queried attribute is not port
   attribute but data stream one, the method is called on all outputs if
   comes from an input and called on all inputs if comes from an output.
   This way a request can travel along the processing structure.


INPUTS
   obj - object,
   port - number of port to set attribute on,
   attribute - attribute,
   value - value to set. 64-bit numbers and larger structures are passed
     via pointer.


RESULT
   TRUE if the attribute was recognized and value set, FALSE otherwise.


NOTES
   Two useful macros: MediaSetPort() and MediaSetPort64() defined in
   <classes/multimedia/multimedia.h> set directly the 32-bit or 64-bit
   value.


EXAMPLE
   UQUAD val64;
   ULONG val32;

   result = DoMethod(obj, MMM_SetPort, port, MMA_Any32BitAttr, val32);
   \* is equivalent to *\
   result = MediaSetPort(obj, port, MMA_Any32BitAttr, val32);

   result = DoMethod(obj, MMM_SetPort, port, MMA_Any64BitAttr,
     (ULONG*)&val64);
   \* is equivalent to *\
   result = MediaSetPort64(obj, port, MMA_Any64BitAttr, val64);


multimedia.class/MMM_SetPortFwd

NAME
   MMM_SetPortFwd -- Sets a value of a port dependent attribute to connected
   port. (V50)


SYNOPSIS
   LONG DoMethod(Object *obj, MMM_SetPortFwd, ULONG port, ULONG attribute,
   ULONG value);


FUNCTION
   Sets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. This method gets a port connected to the specified one,
   and then performs MMM_SetPort on this connected port. This is the only
   difference between MMM_SetPort and MMM_SetPortFwd. MMM_SetPortFwd is
   usually used inside the class, when an object needs to set an attribute
   of the previous, or the next object in a processing structure. Using
   MMM_SetPort in this case will cause forwarding in wrong direction
   (request on input will be forwarded to outputs, request on output will be
   forwarded to inputs). MMM_SetPortFwd will forward request on input to the
   previous object's output, and request on output to the next object's
   input as expected.


INPUTS
   obj - object,
   port - number of port to set attribute on,
   attribute - attribute,
   value - value to set. 64-bit numbers and larger structures are passed via
     pointer.


RESULT
   TRUE if the attribute was recognized and value set, FALSE otherwise.


NOTES
   Two useful macros: MediaSetPortFwd() and MediaSetPortFwd64() defined in
   <classes/multimedia/multimedia.h> set directly the 32-bit or 64-bit value.


EXAMPLE
   UQUAD val64;
   ULONG val32;

   result = DoMethod(obj, MMM_SetPortFwd, port, MMA_Any32BitAttr,
     val32);
   \* is equivalent to *\
   result = MediaSetPortFwd(obj, port, MMA_Any32BitAttr, val32);

   result = DoMethod(obj, MMM_SetPortFwd, port, MMA_Any64BitAttr,
     (ULONG*)&val64);
   \* is equivalent to *\
   result = MediaSetPortFwd64(obj, port, MMA_Any64BitAttr, val64);


SEE ALSO
   MMM_SetPort


multimedia.class/MMM_Setup

NAME
   MMM_Setup -- Prepares connected port for use. (V51)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_Setup, ULONG port);


FUNCTION
   This method is called on object's port just after it is connected to
   another one with MediaConnectTagList(). An object can do any preparations
   (calculations, buffer allocation etc.) depending on data stream
   parameters. Subclass should return TRUE if setup was succesfull
   (MediaConnectTagList() will fail, if setup on any of connected ports
   fails). If a subclass does not implement MMM_Setup at all (because it
   does not need it), multimedia.class just checks if the port exists in the
   object and returns TRUE in the case.


INPUTS
     obj - object, which port is to be set up.
     port - port number.


RESULT
   Booolean, this class always returns TRUE, if only the port is found in
   the object.


NOTES


SEE ALSO


multimedia.class/MMM_UnlockObject

NAME
   MMM_UnlockObject -- Unlocks previously locked object. (V50)


SYNOPSIS
   ULONG DoMethod(Object *obj, MMM_UnlockObject);


FUNCTION
   Unlocks object locked with MMM_LockObject. It is done by releasing
   object's own semaphore.


INPUTS
   None.


RESULT
   None.


NOTES
   Not needed in applications usually, as every method is protected with
   MMM_LockObject / MMM_UnlockObject pair. Subclasses implementors should
   always use it in all methods.


SEE ALSO
   MMM_LockObject


