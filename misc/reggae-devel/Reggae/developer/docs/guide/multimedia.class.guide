@database multimedia.class.guide
@rem Source: class.c
@rem Generated with RoboDoc v3.1a (Jul  3 2005)
@rem RoboDoc is copyright 1994-1997 by Maverick Software Development
@node Main multimedia.class.guide
@{jcenter}
@{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}

@{"multimedia.class/background           " Link "background"}
@{"multimedia.class/MediaAllocVec        " Link "MediaAllocVec"}
@{"multimedia.class/MediaConnectTagList  " Link "MediaConnectTagList"}
@{"multimedia.class/MediaFindClassTagList" Link "MediaFindClassTagList"}
@{"multimedia.class/MediaFreeVec         " Link "MediaFreeVec"}
@{"multimedia.class/MediaGetClassAttr    " Link "MediaGetClassAttr"}
@{"multimedia.class/MediaLog             " Link "MediaLog"}
@{"multimedia.class/MediaNewObjectTagList" Link "MediaNewObjectTagList"}
@{"multimedia.class/MMA_AutoDestruction  " Link "MMA_AutoDestruction"}
@{"multimedia.class/MMA_ErrorCode        " Link "MMA_ErrorCode"}
@{"multimedia.class/MMA_ObjectName       " Link "MMA_ObjectName"}
@{"multimedia.class/MMA_Port_ConnNumber  " Link "MMA_Port_ConnNumber"}
@{"multimedia.class/MMA_Port_ConnObject  " Link "MMA_Port_ConnObject"}
@{"multimedia.class/MMA_Port_Format      " Link "MMA_Port_Format"}
@{"multimedia.class/MMA_Port_FormatsTable" Link "MMA_Port_FormatsTable"}
@{"multimedia.class/MMA_Port_Number      " Link "MMA_Port_Number"}
@{"multimedia.class/MMA_Port_Object      " Link "MMA_Port_Object"}
@{"multimedia.class/MMA_Port_Type        " Link "MMA_Port_Type"}
@{"multimedia.class/MMA_Ports            " Link "MMA_Ports"}
@{"multimedia.class/MMM_AddPort          " Link "MMM_AddPort"}
@{"multimedia.class/MMM_ConnectPort      " Link "MMM_ConnectPort"}
@{"multimedia.class/MMM_DisconnectPort   " Link "MMM_DisconnectPort"}
@{"multimedia.class/MMM_GetPort          " Link "MMM_GetPort"}
@{"multimedia.class/MMM_GetPortFwd       " Link "MMM_GetPortFwd"}
@{"multimedia.class/MMM_IsMember         " Link "MMM_IsMember"}
@{"multimedia.class/MMM_LockObject       " Link "MMM_LockObject"}
@{"multimedia.class/MMM_Pull             " Link "MMM_Pull"}
@{"multimedia.class/MMM_Push             " Link "MMM_Push"}
@{"multimedia.class/MMM_Seek             " Link "MMM_Seek"}
@{"multimedia.class/MMM_SetPort          " Link "MMM_SetPort"}
@{"multimedia.class/MMM_SetPortFwd       " Link "MMM_SetPortFwd"}
@{"multimedia.class/MMM_Setup            " Link "MMM_Setup"}
@{"multimedia.class/MMM_UnlockObject     " Link "MMM_UnlockObject"}
@{jleft}
@endnode
@Node "background" "multimedia.class/background"
@{fg shine}multimedia.class/background@{fg text}

@{b}DESCRIPTION@{ub}
   This class is the main class of Reggae system and the one and only having
   two programmimg interfaces: library interface and BOOPSI interface.
   BOOPSI interface is used for operations on existing objects, while
   library one is used for object creation and for functionality not related
   to objects. Tasks performed by multimedia.class are:
   - error reporting.
   - managing object's ports.
   - connecting ports.
   - automatically building processing structures.
   - database of available classes.
   - stream format recognition.
   - passing methods along processing structures.
   Multimedia.class is a direct subclass of rootclass.


@{b}NEW ATTRIBUTES@{ub}
   Attributes applicability:
     I - may be set at creation time.
     S - may be set on an existing object.
     G - may be get from an object.
     P - may be set for an object's port.
     Q - may be queried from an object's port.

   @{"MMA_Port_Object" Link "MMA_Port_Object"}        (V50) [....Q], Object*
   @{"MMA_Port_Number" Link "MMA_Port_Number"}        (V50) [....Q], ULONG
   @{"MMA_Port_FormatsTable" Link "MMA_Port_FormatsTable"}  (V50) [...PQ], ULONG*
   @{"MMA_Port_Format" Link "MMA_Port_Format"}        (V50) [...PQ], ULONG
   @{"MMA_Port_ConnObject" Link "MMA_Port_ConnObject"}    (V50) [...PQ], Object*
   @{"MMA_Port_ConnNumber" Link "MMA_Port_ConnNumber"}    (V50) [...PQ], ULONG
   @{"MMA_Port_Type" Link "MMA_Port_Type"}          (V50) [...PQ], ULONG
   @{"MMA_Ports" Link "MMA_Ports"}              (V50) [..G..], ULONG
   @{"MMA_ErrorCode" Link "MMA_ErrorCode"}          (V50) [ISG..], ULONG
   @{"MMA_ObjectName" Link "MMA_ObjectName"}         (V51) [ISG..], ULONG
   @{"MMA_AutoDestruction" Link "MMA_AutoDestruction"}    (V52) [I....], BOOL


@{b}NEW METHODS@{ub}
   @{"MMM_LockObject" Link "MMM_LockObject"}()                          (V50)
   @{"MMM_UnlockObject" Link "MMM_UnlockObject"}()                        (V50)
   @{"MMM_GetPort" Link "MMM_GetPort"}(port, attr, storage)          (V50)
   @{"MMM_SetPort" Link "MMM_SetPort"}(port, attr, value)            (V50)
   @{"MMM_GetPortFwd" Link "MMM_GetPortFwd"}(port, attr, storage)       (V50)
   @{"MMM_SetPortFwd" Link "MMM_SetPortFwd"}(port, attr, value)         (V50)
   @{"MMM_AddPort" Link "MMM_AddPort"}(number)                       (V50)
   @{"MMM_Push" Link "MMM_Push"}(port, buffer, length)            (V50)
   @{"MMM_Pull" Link "MMM_Pull"}(port, buffer, length)            (V50)
   @{"MMM_IsMember" Link "MMM_IsMember"}(parent)                      (V50)
   @{"MMM_Seek" Link "MMM_Seek"}(port, type, position)            (V51)
   @{"MMM_Setup" Link "MMM_Setup"}(port)                           (V51)
   @{"MMM_DisconnectPort" Link "MMM_DisconnectPort"}(port)                  (V52)
   @{"MMM_ConnectPort" Link "MMM_ConnectPort"}(port, destobj, destport)  (V52)


@{b}HISTORY@{ub}
 52.4  (23.02.2007)
 - Added @{"MMM_DisconnectPort" Link "MMM_DisconnectPort"}() and @{"MMM_ConnectPort" Link "MMM_ConnectPort"}() methods, now all ports
        are     connected and disconnected with these methods. It allows objects to
        track number of their connected ports.
 - Added @{"MMA_AutoDestruction" Link "MMA_AutoDestruction"} attribute and auto destruction mechanism for
        automatic objects.
 - Added automatic insertion of audio common format converter object in
        LibMediaConnect().
 - Ports are disconnected from previous objects before connection.

 52.3  (15.01.2007)
 - Added DisconnectPorts() function. It is now called from LibMediaConnect()
   if @{"MMM_Setup" Link "MMM_Setup"} on any of ports being connected fails.
 - Added handling of errors returned by @{"MediaConnectTagList" Link "MediaConnectTagList"}() in
        CreateDecodingTree().

 52.2  (12.01.2007)
 - Added proper error reporting in CreateDecodingTree().

 52.1  (06.01.2007)
 - Added a new function to the API, it is MediaSetLogLevel(). This function
   is related to moving log messages filtering from logging application to
   the multimedia.class. It lowers logging overhead as log messages below
   filter level are rejected in @{"MediaLog" Link "MediaLog"}() function and not sent to
   MediaLogger at all. Log level is set to LOG_NONE by default. MediaLogger
   sets it to user desired level at start and sets it back to LOG_NONE at
   exit. Then if MediaLogger is not running, all messages are immediately
   rejected by @{"MediaLog" Link "MediaLog"}(), saving on message and message port creation,
   finding destination port etc. Note that the new function is not
   protected against more than one application calling it (it is global
   setting). As MediaLogger is a single-instance application, and there is
   no other one, it should not be a problem. Note that MediaLogger has been
   updated too, this version of multimedia.class will work with MediaLogger
   1.6 or newer.

 51.10 (31.10.2006)
 - Fixes in documentation and media log messages.

 51.8  (06.01.2006)
 - MediaConnect() fails now if any of @{"MMM_Setup" Link "MMM_Setup"}() calls on ports being
   connected fails.
 - Default object names for objects created in the decoding tree contain now
   the object's true class name instead of word "object" (more descriptive
   debug output).
 - @{"MMA_ObjectName" Link "MMA_ObjectName"} is settable now.
 - Default @{"MMM_Setup" Link "MMM_Setup"}() implemented for subclasses not needing setup.
 - MediaConnect() clears @{"MMA_ErrorCode" Link "MMA_ErrorCode"} for both objects before connecting.

 51.7  (15.11.2005)
 - Fixed @{"MMA_ErrorCode" Link "MMA_ErrorCode"} problem in MediaGetPort().
 - MediaGetPort() and MediaGetPortFwd() do not clear object error to 0.

 51.6  (12.06.2005)
 - Fixed bug in @{"MediaAllocVec" Link "MediaAllocVec"}(), it simply didn't worked under MorphOS 1.4.
   Also on machines with no AltiVec available alignment requirements are
   lowered from 16 to 8 bytes.

 51.5  (04.05.2005)
 - Fixed bug in TagInArrayWild(), it caused only the first port format in a
   format list was recognized.

 51.4  (29.04.2005)
 - Fixed bug in @{"MediaNewObjectTagList" Link "MediaNewObjectTagList"}(), it always returned NULL, even if
   object creation was succesfull.
 - Fixed bug in @{"MediaNewObjectTagList" Link "MediaNewObjectTagList"}(), now forward is added for every
   decoder output.

 51.3  (21.04.2005)
 - Removed annoying debug message "Errors cleared for...".
 - All objects created by @{"MediaNewObjectTagList" Link "MediaNewObjectTagList"}() are now disposed if the
   function fails.
 - CreateDecodingTree() is now called on multiread.buffer object as it
   should, not on processblock object.
 - Multiread buffers are now correctly added to the processblock (and then
   correctly disposed with it).

 51.2  (20.04.2005)
 - Implemented @{"MMA_ObjectName" Link "MMA_ObjectName"}.
 - Added object name output to all debug messages.

 50.24 (07.03.2005)
 - Supports MMF_ANY_FORMAT in @{"MediaConnectTagList" Link "MediaConnectTagList"}() as a wildchar.

 50.23 (19.02.2005)
 - @{"MMM_AddPort" Link "MMM_AddPort"} has protection against creating more than one port with the
   same number.
 - @{"MMA_ErrorCode" Link "MMA_ErrorCode"} support in @{"MediaNewObjectTagList" Link "MediaNewObjectTagList"}().
 - @{"MediaConnectTagList" Link "MediaConnectTagList"}() has protection against connecting two ports of the
   same object.

 50.22 (18.12.2004)
 - New forwarding scheme according to the docs, @{"MMM_GetPortFwd" Link "MMM_GetPortFwd"} and
   @{"MMM_SetPortFwd" Link "MMM_SetPortFwd"} removed as not needed.
 - OM_DISPOSE: every port is disconnected before disposing (it means, its
   connected peer port gets MMA_ConnPort = MM_NO_PORT and MMA_ConnObject =
   NULL).

 50.21 (16.12.2004)
 - Implemented new methods: @{"MMM_GetPortFwd" Link "MMM_GetPortFwd"}, @{"MMM_SetPortFwd" Link "MMM_SetPortFwd"}, @{"MMM_IsMember" Link "MMM_IsMember"}.

 50.20 (08.12.2004)
 - MediaConnect() modified: @{"MMM_Setup" Link "MMM_Setup"} method is called on both connected
   ports.

 50.19 (06.12.2004)
 - Fixed bug in MediaFindClass() when searching against MMA_DataFormat
   value.

 50.18 (28.11.2004)
 - Implemented @{"MediaGetClassAttr" Link "MediaGetClassAttr"}().

 50.17 (27.11.2004)
 - Implemented MediaFindClass().

 50.16 (18.11.2004)
 - Recognize routines are now enqueued according to MMA_Priority tag from
 class data.

 50.15 (03.11.2004)
 - Implemented new class identification system.
 - match_datatype() is semaphore protected.

 50.14 (31.10.2004)
 - Media type filter (MMA_MediaType) working in MediaNewObject().

 50.13 (23.10.2004)
 - Processblock object is disposed and MediaNewObject() returns NULL, when
   the pipeline was not created fully (for example missing decoder).
 - Added missing error log messages.

 50.12 (01.09.2004)
 - Fixed bug in MediaConnect(), second port format was set for the first
   port if both ports had formats tables only.

 50.11 (25.08.2004)
 - MediaConnect() full implementation.
 - Implemented @{"MMM_Pull" Link "MMM_Pull"} for pulling from input port (useful for subclasses,
   they can pull from their inputs), it is passed to connected object.
 - Added missing @{"MMA_Port_Type" Link "MMA_Port_Type"} in @{"MMM_GetPort" Link "MMM_GetPort"}.
 - Added missing @{"MMA_Port_ConnObject" Link "MMA_Port_ConnObject"} and @{"MMA_Port_ConnNumber" Link "MMA_Port_ConnNumber"} in @{"MMM_SetPort" Link "MMM_SetPort"}.

 50.10 (20.08.2004)
 - @{"MMM_AddPort" Link "MMM_AddPort"} initializes connected port number to MM_NO_PORT (invalid
   number), so wrong port connection can be detected.
 - Added library interface function MediaConnect() - no-op for now, for
   testing only.

 50.9 (19.08.2004)
 - Fixed stupid bug in initialization of MediaPort list.
 - @{"MMM_SetPort" Link "MMM_SetPort"} works with @{"MMA_Port_Type" Link "MMA_Port_Type"}, @{"MMA_Port_Format" Link "MMA_Port_Format"},
   @{"MMA_Port_FormatsTable" Link "MMA_Port_FormatsTable"}.
 - @{"MMM_GetPort" Link "MMM_GetPort"} fully implemented.

 50.8 (09.04.2004)
 - Demuxers scan routine uses query.library instead of proprietary code.

 50.7 (20.02.2004)
 - Added DTOA_LoadAdvance attribute. It returns current advance in reading
   source (compressed) stream. Useful when uncompressed data size is unknown
   (for example mp3.decoder returns 0 for SNDA_FrameCount, because if you
   want to know number of uncompressed frames, you have to scan the whole
   file). Note that it only works with source stream of known length
   (returning non-zero DTSA_CurrentSize). It may be less accurate than
   calculating advance on decompressed data, since compression ratio may be
   variable through the stream, also DTOA_LoadAdvance takes stream header
   into account. Attribute value is percents multiplied by 10 000, so
   1 000 000 means 100% of source stream has been read.
 - Fixed bug, OM_GET for all per class attributes (DTOA_ClassName,
   DTOA_ClassDesc, DTOA_MimeType, DTOA_DataFormat) was broken.

 50.6 (30.12.2003)
 - Added: Support for DTOA_ErrorCode in NewMediaObject() and OM_NEW.
 - Removed: Check for source stream in OM_NEW (it is subclass specific).

 50.5 (07.12.2003)
 - Added: DTOA_DataType, DTOA_ClassDesc, DTOA_ClassName, DTOA_MimeType are
   now gettable.

 50.4 (29.11.2003)
 - Change: debug output is now switched by makefile target 'debug'.

 50.3 (07.11.2003)
 - Fixes caused by stream API changes.

 50.2 (22.09.2003)
 - Added functionality in NewMediaObject(), the function can create object
   stream itself, if there is no DTOA_SourceStream tag, but
   DTOA_SrcStreamName and DTOA_SrcStreamType pair instead. The library keeps
   track of created streams and these are disposed at OM_DISPOSE of object
   returned by NewMediaObject().


@endnode
@Node "MediaAllocVec" "multimedia.class/MediaAllocVec"
@{fg shine}multimedia.class/MediaAllocVec@{fg text}

@{b}NAME@{ub}
   @{b}MediaAllocVec@{ub} -- Allocates memory for media buffers. (V50)


@{b}SYNOPSIS@{ub}
   APTR @{b}MediaAllocVec@{ub}(ULONG size);


@{b}FUNCTION@{ub}
   The function is used for allocating processing buffers for Reggae
   classes. It should be used in subclasses for all buffers containing
   stream data. It also should be used by applications for data to be fed
   into Reggae processing structure and for buffers to be filled with data
   by Reggae objects as well. Using this function instead of exec functions
   ensures data are properly aligned for AltiVec unit available in G4/G5
   processors. AltiVec alignment is enforced only on machines with AltiVec
   available (to lower memory consumption and usage on low-end 60x and G3
   systems). Memory allocations via MediaAllocMem() can be tracked for
   testing and debug purposes.


@{b}INPUTS@{ub}
   size - size of memory buffer to be allocated. The function returns NULL
     if zero size is passed.


@{b}RESULT@{ub}
   Pointer to allocated buffer, or NULL for failure.


@{b}NOTES@{ub}
   Memory allocated with @{b}MediaAllocVec@{ub}() must be freed with @{"MediaFreeVec" Link "MediaFreeVec"}().


@{b}SEE ALSO@{ub}
   @{"MediaFreeVec" Link "MediaFreeVec"}().


@endnode
@Node "MediaConnectTagList" "multimedia.class/MediaConnectTagList"
@{fg shine}multimedia.class/MediaConnectTagList@{fg text}

@{b}NAME@{ub}
   @{b}MediaConnectTagList@{ub} -- Connects two ports of MOS Media objects. (V50)


@{b}SYNOPSIS@{ub}
   BOOL @{b}MediaConnectTagList@{ub}(Object *obj1, ULONG port1, Object *obj2, ULONG
   port2, struct TagItem *taglist);

   BOOL MediaConnectTags(Object *obj1, ULONG port1, Object *obj2, ULONG
   port2, Tag tag1, ...);


@{b}FUNCTION@{ub}
   Connects two ports of media objects. The function checks if given ports
   exist in objects, then checks for matching data formats. There are three
   possible data format conditions:
   1. Both ports have format set explicitly. If it is the same format ports
      are connected, the function fails otherwise. If one of ports has
      MMF_ANY_FORMAT, it's format is set to the other's port one before
      connecting. If both ports have MMF_ANY_FORMAT, they are connected as
      is.
   2. One port has format set explicitly, the second one has format table.
      If the first port's format is found in second port's format table,
      ports are connected, the function fails otherwise. Matched format is
      set for the second port. If the explicitly set format is
      MMF_ANY_FORMAT, it is set to the first format found in the second port
      format table (unless it is empty) before connecting. Note that future
      tags may modify this behaviour in a way that not neccesarily the first
      format from the table may be choosen.
   3. Both ports have format tables. The second format table is searched for
      every format in the first table in turn. The first match is set as
      format for both ports. If there is no match, function fails. This
      matching process can be modified by tags in taglist in the future (it
      means if there is more than one match not neccesarily the first one
      will be selected).
   After succesfull connection, @{"MMM_Setup" Link "MMM_Setup"} method is called on both connected
   ports. This method is not used by Reggae main classes, but may be used by
   subclasses to perform setup dependent on datastream avaliability or
   parameters (for example demuxers can read stream header in @{"MMM_Setup" Link "MMM_Setup"},
   other classes may create internal buffers etc.).


@{b}INPUTS@{ub}
   obj1 - the first object to be connected.
   port1 - the number of port in obj1 to be connected.
   obj2 - the second object to be connected.
   port2 - the number of port in obj2 to be connected.
   taglist - for future expansion, no tags defined in V50. NULL taglist is
     OK and is treated as an empty one.


@{b}RESULT@{ub}
   TRUE if ports connected succesfully. FALSE may be returned because of
   following reasons:
   - one or both of objects are NULL.
   - one or both of ports are not found in objects.
   - application is trying to connect two ports of the same object.
   - port formats do not match (see case 1. above).
   - no matching format found in ports format table[s] (see cases 2. and 3.
     above).
   - application is trying to connect two inputs or two outputs, or any of
     ports has wrong (uninitialized?) type.
   - any of ports has set neither format nor format table (uninitialized?).


@endnode
@Node "MediaFindClassTagList" "multimedia.class/MediaFindClassTagList"
@{fg shine}multimedia.class/MediaFindClassTagList@{fg text}

@{b}NAME@{ub}
   @{b}MediaFindClassTagList@{ub} -- Finds MOS Media classes of given properties.
   (V50)


@{b}SYNOPSIS@{ub}
   STRPTR @{b}MediaFindClassTagList@{ub}(APTR *ptr, struct TagItem *taglist);

   STRPTR MediaFindClassTags(APTR *ptr, Tag tag1, ...);


@{b}FUNCTION@{ub}
   The function is used for finding Reggae classes of given properties in
   the database maintained by multimedia.class. Properties are specified in
   the passed taglist. On the first call the function returns the first
   class found matching passed properties. To find all matching classes, the
   function should be called in a loop until it returns NULL. The value
   returned is the name of class.


@{b}INPUTS@{ub}
   ptr - pointer to APTR pointer used for saving current position in the
     database. Must be initialized to NULL before the first call.
   taglist - list of tags specifying properties of classes to be found.
     Following tags are recognized:
     - MMA_ClassType, one of MMCLASS_xxx defined in
       <classes/multimedia/multimedia.h>.
     - MMA_MediaType, one of three media types (audio, picture, video)
       defined in <classes/multimedia/multimedia.h> or any OR-ed combination
       of them.
     - MMA_DataFormat, the name of media format (like "Audio IFF"), strings
       are compared.


@{b}RESULT@{ub}
   Pointer to read-only, zero-terminated class name string, or NULL if no
   class found.


@{b}EXAMPLE@{ub}
   \\* search for all sound demuxers *\\

   APTR p = NULL;   \\* must be initialized to NULL *\\
   STRPTR classname;

   while (classname = MediaFindClassTags(&p,
     MMA_MediaType, MMT_SOUND,
     MMA_ClassType, MMCLASS_DEMUXER,
   TAG_END))
   {
     \\* do something with class name *\\
   }


@endnode
@Node "MediaFreeVec" "multimedia.class/MediaFreeVec"
@{fg shine}multimedia.class/MediaFreeVec@{fg text}

@{b}NAME@{ub}
   @{b}MediaFreeVec@{ub} -- Frees media buffer memory. (V50)


@{b}SYNOPSIS@{ub}
   void @{b}MediaFreeVec@{ub}(APTR memory);


@{b}FUNCTION@{ub}
   The function frees media buffer memory allocated with @{"MediaAllocVec" Link "MediaAllocVec"}().
   The memory tracker can report errors like wrong size or address.


@{b}INPUTS@{ub}
   memory - buffer to be freed. The function does nothing if NULL pointer is
   passed.


@{b}RESULT@{ub}
   none


@{b}NOTES@{ub}
   Only memory allocated with @{"MediaAllocVec" Link "MediaAllocVec"}() can be freed with
   @{b}MediaFreeVec@{ub}().


@{b}SEE ALSO@{ub}
   @{"MediaAllocVec" Link "MediaAllocVec"}().


@endnode
@Node "MediaGetClassAttr" "multimedia.class/MediaGetClassAttr"
@{fg shine}multimedia.class/MediaGetClassAttr@{fg text}

@{b}NAME@{ub}
   @{b}MediaGetClassAttr@{ub} -- Gets an attibute of a MOS Media class. (V50)


@{b}SYNOPSIS@{ub}
   @{b}MediaGetClassAttr@{ub}(STRPTR classname, ULONG attr, ULONG *storage);


@{b}FUNCTION@{ub}
   Gets an attribute of specified MOS Media class. If the class is found in
   the database and the attribute is found in this class attribute list, the
   attribute value is stored at given pointer.


@{b}INPUTS@{ub}
   classname - the name of the class (zero-terminated string).
   attr - attribute to get. Following attributes are recognized:
     - MMA_ClassType,
     - MMA_MediaType,
     - MMA_SupportedFormats.
   storage - pointer to a variable where attribute value is to be stored.


@{b}RESULT@{ub}
   TRUE if class and attribute found and value stored. FALSE otherwise.


@{b}EXAMPLE@{ub}
   \\* prints all supported data format identifiers for a class *\\

   ULONG *formats;

   if (@{b}MediaGetClassAttr@{ub}("foo.class", MMA_SupportedFormats, 
     (ULONG*)&formats))
   {
     ULONG *p = formats;

     while (*p) Printf("Format $%08lx.\\n", *p++);
   }


@endnode
@Node "MediaLog" "multimedia.class/MediaLog"
@{fg shine}multimedia.class/MediaLog@{fg text}

@{b}NAME@{ub}
   @{b}MediaLog@{ub} -- Sends a debug message to logging application. (V50)


@{b}SYNOPSIS@{ub}
   void @{b}MediaLog@{ub}(ULONG level, STRPTR classname, STRPTR functionname, STRPTR
   msg, ...);


@{b}FUNCTION@{ub}
   Sends log packet to an application with open public port named
   "MediaLogger". Typically it is MediaLogger application included with the
   Reggae package, but third party loggers are possible. Logger catches all
   debug messages, filters them, can also write them to a disk file. The
   function is typically used in subclasses for debug output. Message sent
   to the logger is of type 'struct MediaError' and is defined in the
   include file <classes/multimedia/multimedia.h>.


@{b}INPUTS@{ub}
   loglevel - importance of the log message, one of LOG_ERRORS, LOG_INFO
     or LOG_VERBOSE. Used to filter messages in a logger application.
   classname - name of a class, the message is sent from.
   functionname - name of a function, the message is sent from.
   msg - message text. Can contain printf()-style placeholders,
     NewRawDoFmt() will be called on it with the text, and following
     variable arguments as parameters.
   [following arguments] - variable number of arguments to be passed to
     NewRawDoFmt().


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   There are two macros MLOG() and MLOGV() defined in
   <classes/multimedia/multimedia.h> include file, which automatically use
   CLASSNAME (should be defined by subclass implementor) and __FUNCTION__
   GCC automatic macro, to fill 'classname' and 'functionname'. MLOG()
   should be used when there are no parameters after 'msg' (no
   placeholders), MLOGV() for one or more parameters after 'msg'. MLOGV()
   can take QUAD and UQUAD arguments (use "%Ld", "%Lu" or "%Lx"
   placeholders). MLOG1(), MLOG2() and MLOGQ() macros are obsolete and must
   not be used.

   V52: Starting from this version, @{b}MediaLog@{ub}() filters out messages, which
   importance level is lower than log level set by MediaSetLogLevel(). If 
   a message importance is lower than the level set, @{b}MediaLog@{ub}() call
   returns immediately and does not try to sent the message to the public
   "MediaLogger" port.


@{b}EXAMPLE@{ub}
   \\* Assume we are in 'foo.class' code and CLASSNAME is defined as *\\
   \\* "foo.class".                                                  *\\

   void AnyFunction(void)
   {
     UQUAD value = 6;
     LONG errcode = 2983;

     @{b}MediaLog@{ub}(LOG_ERRORS, "foo.class", "AnyFunction", 
       "Kernel panic - too many bugs in PSU fan!");
     \\* or the same with MLOG() macro *\\
     MLOG(LOG_ERRORS, "Kernel panic - too many bugs in PSU fan!");

     @{b}MediaLog@{ub}(LOG_ERRORS, "foo.class", "AnyFunction",
       "Unknown error %lu, 64-bit value is $%Lx.", errcode, value);
     \\* or the same with MLOGV() macro *\\
     MLOGV(LOG_ERRORS, "Unknown error %lu, 64-bit value is $%Lx.",
       errcode, value);
   }


@{b}SEE ALSO@{ub}
   exec.library/NewRawDoFmt()


@endnode
@Node "MediaNewObjectTagList" "multimedia.class/MediaNewObjectTagList"
@{fg shine}multimedia.class/MediaNewObjectTagList@{fg text}

@{b}NAME@{ub}
   @{b}MediaNewObjectTagList@{ub} -- Creates complete decoding structure. (V50)


@{b}SYNOPSIS@{ub}
   Object *@{b}MediaNewObjectTagList@{ub}(struct TagItem *taglist);

   Object *MediaNewObjectTags(Tag tag1, ...);


@{b}FUNCTION@{ub}
   This high-level function is used to create processing structure for
   opening and decoding media stream of unknown format. It is very
   convenient function for application programmers, as it automates common
   task of recognizing and decoding any media stream. The first step is to
   obtain source data stream. The stream can be defined in three different
   ways:
   1. An application can pass an already created stream object with
      MMA_Stream tag. The application is responsible for disposing this
      stream when no longer used.
   2. Stream can be specified with MMA_StreamName and MMA_StreamType to be
      opened by MediaNewObject(). Stream will be automatically disposed,
      when media object is disposed.
   3. The same as above, but stream is specified by its handle 
      (MMA_StreamHandle) instead of name. May be convenient for some types
      of streams. Meaning of stream name and handle depends on stream type
      (see streams documentation).
   The second stage is format recognition. Multimedia.class registers all
   available demultiplexers at startup. Every demultiplexer has its own
   format recognition routine. These routines are all loaded to memory
   during multimedia.class startup (without loading entire class code). Then
   @{b}MediaNewObjectTagList@{ub}() calls every recognition routine in turn on stream
   passed. Every routine returns probability of stream being formatted with
   the format recognized by it. In a typical situation all routines return
   probability of 0, except one with probability of 1. If the stream format
   hasn't well defined and formed header (MP3 stream for example), more than
   one routine can return non-zero probability. The most probable format is
   always taken. Application has some control of recognition process. It can
   limit demultiplexer matching only to specific kind of media: sound,
   picture, video or any combination of them. It can be done with
   MMA_MediaType tag. Some media formats are difficult to detect. Detection
   can take much time, or CPU power. To avoid slowdown when it can't be
   accepted, recognition has two operation modes: "light" and "heavy" one.
   In "light" mode recognition is always fast, but may be inaccurate.
   "Heavy" recognition routines may be slower, but are more precise.
   Recognition mode is selected with MMA_Recognition tag. To speed
   recognition up, file formats with well defined headers (like WAVE) are
   tested before formats harder to recognize (like MP3). It is done by
   prioritizing registered demultiplexers list. After the stream format is
   recognized, the function opens matched demultiplexer library and creates
   new demultiplexer object. This object is fed with source stream. Then
   demultiplexer output format is checked. Many demultiplexers have only one
   output format (for example AIFF has big-endian PCM), but some may have
   more than one output format (WAVE is a good example). That is why
   demultiplexer output format is determined on demultiplexer object, not
   class. Then the function scans demultiplexer outputs. If an output is of
   MMF_STREAM type, the function calls itself recursively on this output. If
   not, a proper decoder object is created and attached. All created objects
   are added to a processblock grouping them. Pointer to this processblock
   object is used as the return value of @{b}MediaNewObjectTagList@{ub}() function.


@{b}INPUTS@{ub}
   taglist - list of tags specifying data source and other parameters.
     Accepted tags:
     - @{"MMA_ErrorCode" Link "MMA_ErrorCode"} (pointer to an ULONG variable).
     - MMA_StreamName (name of stream to be opened).
     - MMA_StreamHandle (handle of stream to be opened).
     - MMA_StreamType (type (class name) of stream to be opened).
     - MMA_Stream (already created stream object).
     - MMA_MediaType (type of media, MMT_VIDEO, MMT_SOUND, MMT_PICTURE, may
       be OR-ed togehter).


@{b}RESULT@{ub}
   Created processblock or NULL on failure. Secondary error information is
   available via @{"MMA_ErrorCode" Link "MMA_ErrorCode"} attribute. Possible failure reasons are:
   - MMERR_NO_STREAM (incomplete stream specification).
   - MMERR_NO_STREAM_CLASS (stream class specified with MMA_StreamType not
     found or can't be opened).
   - MMERR_OUT_OF_MEMORY (as name says...)
   - MMERR_NOT_RECOGNIZED (no demuxer recognized the stream).
   - MMERR_NO_DECODER (no decoder for demuxer output format).


@endnode
@Node "MMA_AutoDestruction" "multimedia.class/MMA_AutoDestruction"
@{fg shine}multimedia.class/MMA_AutoDestruction@{fg text}

@{b}NAME@{ub}
   @{b}MMA_AutoDestruction@{ub} [I....], BOOL


@{b}FUNCTION@{ub}
   This attribute causes Reggae to automatically dispose an object when all
   its ports get disconnected. It is used for objects created automatically
   by Reggae (for example common format converters). Usage of this attribute
   in applications is not recommended.


@endnode
@Node "MMA_ErrorCode" "multimedia.class/MMA_ErrorCode"
@{fg shine}multimedia.class/MMA_ErrorCode@{fg text}

@{b}NAME@{ub}
   @{b}MMA_ErrorCode@{ub} [ISG..], ULONG / ULONG*


@{b}FUNCTION@{ub}
   Error code of the latest operation performed on the object. Note that
   error does not accumulate, so every succesful operation clears it to
   zero. When passed to OM_NEW [I], tag value should be a pointer to ULONG
   variable where error code will be stored. The same for OM_GET [G]. For
   OM_SET [S], tag value should be just error code.


@endnode
@Node "MMA_ObjectName" "multimedia.class/MMA_ObjectName"
@{fg shine}multimedia.class/MMA_ObjectName@{fg text}

@{b}NAME@{ub}
   @{b}MMA_ObjectName@{ub} [ISG..], STRPTR


@{b}FUNCTION@{ub}
   Pointer to a meaningful name for an object. It is mainly useful for
   making MediaLogger output more readable, because if an object has a name,
   it will be used in logs. Local copy of passed string is created in
   OM_NEW, so the passed string need not to be static. Default value for the
   name is "classname $XXXXXXXX", where 'classname' is the name of class
   (the same as the name of class executable file) 'X'-es are replaced by
   object address as hexadecimal digit.


@{b}NOTES@{ub}
   Subclasses implementors: names are not used automagically, you should get
   @{b}MMA_ObjectName@{ub} value explicitly (for example using predefined OBJNAME()
   macro) and pass it to @{"MediaLog" Link "MediaLog"}(). Multimedia.class always uses names in
   logs.


@{b}SEE ALSO@{ub}
   @{"MediaLog" Link "MediaLog"}()


@endnode
@Node "MMA_Port_ConnNumber" "multimedia.class/MMA_Port_ConnNumber"
@{fg shine}multimedia.class/MMA_Port_ConnNumber@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_ConnNumber@{ub} [...PQ], ULONG


@{b}FUNCTION@{ub}
   Returns or specifies a number of port connected to the queried one.


@{b}NOTES@{ub}
   Not for general use. Do not touch without a reason. Use
   @{"MediaConnectTagList" Link "MediaConnectTagList"}() for connecting ports togehter.


@{b}SEE ALSO@{ub}
   @{"MediaConnectTagList" Link "MediaConnectTagList"}()


@endnode
@Node "MMA_Port_ConnObject" "multimedia.class/MMA_Port_ConnObject"
@{fg shine}multimedia.class/MMA_Port_ConnObject@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_ConnObject@{ub} [...PQ], Object*


@{b}FUNCTION@{ub}
   Returns or specifies a pointer to object connected to queried port.


@{b}NOTES@{ub}
   Not for general use. Do not touch without a reason. Use
   @{"MediaConnectTagList" Link "MediaConnectTagList"}() for connecting ports togehter.


@{b}SEE ALSO@{ub}
   @{"MediaConnectTagList" Link "MediaConnectTagList"}()


@endnode
@Node "MMA_Port_Format" "multimedia.class/MMA_Port_Format"
@{fg shine}multimedia.class/MMA_Port_Format@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_Format@{ub} [...PQ], ULONG


@{b}FUNCTION@{ub}
   Specifies or returns media format of stream going through the port. When
   set to a port [P], the specified format must be found in format table of
   the port. If it is not, format is not set.


@{b}NOTES@{ub}
   For subclasses implementors only.


@endnode
@Node "MMA_Port_FormatsTable" "multimedia.class/MMA_Port_FormatsTable"
@{fg shine}multimedia.class/MMA_Port_FormatsTable@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_FormatsTable@{ub} [...PQ], ULONG*


@{b}FUNCTION@{ub}
   Specifies or returns a pointer to a zero-terminated table of media
   formats to be accepted or produced by given port.


@{b}NOTES@{ub}
   For subclasses implementors only.


@endnode
@Node "MMA_Port_Number" "multimedia.class/MMA_Port_Number"
@{fg shine}multimedia.class/MMA_Port_Number@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_Number@{ub} [....Q], ULONG


@{b}FUNCTION@{ub}
   Own number of port. Multimedia.class returns just number of port the
   query is performed on.


@{b}NOTES@{ub}
   Processblock.class overrides this attribute to perform port forwarding.


@endnode
@Node "MMA_Port_Object" "multimedia.class/MMA_Port_Object"
@{fg shine}multimedia.class/MMA_Port_Object@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_Object@{ub} [....Q], Object*


@{b}FUNCTION@{ub}
   Pointer to object, where the port belongs. Multimedia.class returns just
   pointer of object the query is performed on.


@{b}NOTES@{ub}
   Processblock.class overrides this attribute to perform port forwarding.


@endnode
@Node "MMA_Port_Type" "multimedia.class/MMA_Port_Type"
@{fg shine}multimedia.class/MMA_Port_Type@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Port_Type@{ub} [...PQ], ULONG


@{b}FUNCTION@{ub}
   Returns or specifies type of queried port. It can be MDP_TYPE_INPUT or
   MDP_TYPE_OUTPUT. Any other value means the port is not initialized
   properly.


@{b}NOTES@{ub}
   Not for general use. Do not touch without a reason. Use
   @{"MediaConnectTagList" Link "MediaConnectTagList"}() for connecting ports togehter.


@{b}SEE ALSO@{ub}
   @{"MediaConnectTagList" Link "MediaConnectTagList"}()


@endnode
@Node "MMA_Ports" "multimedia.class/MMA_Ports"
@{fg shine}multimedia.class/MMA_Ports@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Ports@{ub} [..G..], ULONG


@{b}FUNCTION@{ub}
   Returns the number of ports in an object.


@endnode
@Node "MMM_AddPort" "multimedia.class/MMM_AddPort"
@{fg shine}multimedia.class/MMM_AddPort@{fg text}

@{b}NAME@{ub}
   @{b}MMM_AddPort@{ub} -- Adds a port to an object. (V50)


@{b}SYNOPSIS@{ub}
   LONG DoMethod(Object *obj, @{b}MMM_AddPort@{ub}, ULONG number);


@{b}FUNCTION@{ub}
   Adds new port to an object. Port is uninitialized and needs type and
   format or format table to be set.


@{b}INPUTS@{ub}
   obj - object a port will be added to
   number - number of port to be created


@{b}RESULT@{ub}
   TRUE if port was created succesfully. FALSE otherwise. The method may
   fail for two reasons:
   1. Out of memory, @{"MMA_ErrorCode" Link "MMA_ErrorCode"} is MMERR_OUT_OF_MEMORY.
   2. Port with specified number already exists, @{"MMA_ErrorCode" Link "MMA_ErrorCode"} is
      MMERR_WRONG_ARGUMENTS.


@endnode
@Node "MMM_ConnectPort" "multimedia.class/MMM_ConnectPort"
@{fg shine}multimedia.class/MMM_ConnectPort@{fg text}

@{b}NAME@{ub}
   @{b}MMM_ConnectPort@{ub} -- Connects a port. (V52)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{"MMM_DisconnectPort" Link "MMM_DisconnectPort"}, ULONG port, Object
        *destobj, ULONG destport);


@{b}FUNCTION@{ub}
   Sets mdp_Port and mdp_Object of a port to specified destination object
        and port number. Note that destination port and object are not verified
        for validity. The method resolves processblock forwards automatically, so
        always the true port is connected.


@{b}INPUTS@{ub}
   port - number of port to connect.
   destobj - pointer to the destination object.
   destport - number of destination port.


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   Used internally by multimedia.class. Applications must use
        LibMediaConnectTagList() API call.


@endnode
@Node "MMM_DisconnectPort" "multimedia.class/MMM_DisconnectPort"
@{fg shine}multimedia.class/MMM_DisconnectPort@{fg text}

@{b}NAME@{ub}
   @{b}MMM_DisconnectPort@{ub} -- Disconnects a port. (V52)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_DisconnectPort@{ub}, ULONG port);


@{b}FUNCTION@{ub}
   Sets mdp_Object of disconnected port to NULL, and mdp_Port to MM_NO_PORT.
   It also decreases object's connected ports counter. The method resolves
   processblock forwards automatically, so always the true port is
        disconnected.


@{b}INPUTS@{ub}
   port - number of port to disconnect.


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   Used internally by multimedia.class. Disposing an object causes
   @{b}MMM_DisconnectPort@{ub}() on ports of objects connected to the one being
        disposed.


@endnode
@Node "MMM_GetPort" "multimedia.class/MMM_GetPort"
@{fg shine}multimedia.class/MMM_GetPort@{fg text}

@{b}NAME@{ub}
   @{b}MMM_GetPort@{ub} -- Gets a value of a port dependent attribute. (V50)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_GetPort@{ub}, ULONG port, ULONG attribute,
   ULONG *storage);


@{b}FUNCTION@{ub}
   Gets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. Usually this method is implemented at subclass level.
   If it reaches multimedia.class level and queried attribute is not port
   attribute but data stream one, the method is called on all outputs if
   comes from an input and called on all inputs if comes from an output.
   This way a query can travel along the processing structure.


@{b}INPUTS@{ub}
   obj - queried object,
   port - number of queried port,
   attribute - queried attribute,
   storage - pointer to a variable, where value will be stored.


@{b}RESULT@{ub}
   TRUE if the attribute was recognized and value stored, FALSE otherwise.


@{b}NOTES@{ub}
   Two useful macros: MediaGetPort() and MediaGetPort64() defined in
   <classes/multimedia/multimedia.h> return directly the 32-bit or 64-bit
   value. May be used if return value of @{b}MMM_GetPort@{ub} is not needed.


@{b}EXAMPLE@{ub}
   UQUAD val64;
   ULONG val32;

   DoMethod(obj, @{b}MMM_GetPort@{ub}, port, MMA_Any32BitAttr, &val32);
   \\* is equivalent to *\\
   val32 = MediaGetPort(obj, port, MMA_Any32BitAttr);

   DoMethod(obj, @{b}MMM_GetPort@{ub}, port, MMA_Any64BitAttr, (ULONG*)&val64);
   \\* is equivalent to *\\
   val64 = MediaGetPort64(obj, port, MMA_Any64BitAttr);


@endnode
@Node "MMM_GetPortFwd" "multimedia.class/MMM_GetPortFwd"
@{fg shine}multimedia.class/MMM_GetPortFwd@{fg text}

@{b}NAME@{ub}
   @{b}MMM_GetPortFwd@{ub} -- Gets a value of a port dependent attribute from
   connected port. (V50)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_GetPortFwd@{ub}, ULONG port, ULONG attribute,
   ULONG *storage);


@{b}FUNCTION@{ub}
   Gets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. This method gets a port connected to the specified one,
   and then performs @{"MMM_GetPort" Link "MMM_GetPort"} on this connected port. This is the only
   difference between @{"MMM_GetPort" Link "MMM_GetPort"} and @{b}MMM_GetPortFwd@{ub}. @{b}MMM_GetPortFwd@{ub} is
   usually used inside the class, when an object needs to query an attribute
   from the previous, or the next object in a processing structure. Using
   @{"MMM_GetPort" Link "MMM_GetPort"} in this case will cause forwarding in wrong direction (query
   on input will be forwarded to outputs, query on output will be forwarded
   to inputs). @{b}MMM_GetPortFwd@{ub} will forward query on input to the previous
   object's output, and query on output to the next object's input as
   expected.


@{b}INPUTS@{ub}
   obj - queried object,
   port - number of queried port,
   attribute - queried attribute,
   storage - pointer to a variable, where value will be stored.


@{b}RESULT@{ub}
   TRUE if the attribute was recognized and value stored, FALSE otherwise.


@{b}NOTES@{ub}
   Two useful macros: MediaGetPortFwd() and MediaGetPortFwd64() defined in
   <classes/multimedia/multimedia.h> return directly the 32-bit or 64-bit
   value. May be used if return value of @{"MMM_GetPort" Link "MMM_GetPort"} is not needed.


@{b}EXAMPLE@{ub}
   UQUAD val64;
   ULONG val32;

   DoMethod(obj, @{"MMM_GetPort" Link "MMM_GetPort"}, port, MMA_Any32BitAttr, &val32);
   \\* is equivalent to *\\
   val32 = MediaGetPort(obj, port, MMA_Any32BitAttr);

   DoMethod(obj, @{"MMM_GetPort" Link "MMM_GetPort"}, port, MMA_Any64BitAttr, (ULONG*)&val64);
   \\* is equivalent to *\\
   val64 = MediaGetPort64(obj, port, MMA_Any64BitAttr);


@{b}SEE ALSO@{ub}
   @{"MMM_GetPort" Link "MMM_GetPort"}


@endnode
@Node "MMM_IsMember" "multimedia.class/MMM_IsMember"
@{fg shine}multimedia.class/MMM_IsMember@{fg text}

@{b}NAME@{ub}
   @{b}MMM_IsMember@{ub} -- Checks if an object is a member of another object. (V50)


@{b}SYNOPSIS@{ub}
   BOOL DoMethod(Object *obj, @{b}MMM_IsMember@{ub}, Object *parent);


@{b}FUNCTION@{ub}
   Returns TRUE if an object is member of parent object. At multimedia.class
   level this function always returns TRUE, as every object is a member of
   itself. The method is overloaded by processblock.class.


@{b}INPUTS@{ub}
   obj - object to be checked.
   parent - object expected to have 'obj' as member.


@{b}RESULT@{ub}
   Always TRUE on multimedia.class level.


@{b}SEE ALSO@{ub}
   processblock.class/@{b}MMM_IsMember@{ub}


@endnode
@Node "MMM_LockObject" "multimedia.class/MMM_LockObject"
@{fg shine}multimedia.class/MMM_LockObject@{fg text}

@{b}NAME@{ub}
   @{b}MMM_LockObject@{ub} -- Locks Reggae object for exclusive use. (V50)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_LockObject@{ub});


@{b}FUNCTION@{ub}
   Locks Reggae object for exclusive use. It is done by obtaining object's
   own semaphore. Locks can be nested.


@{b}INPUTS@{ub}
   None.


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   Not needed in applications usually, as every method is protected with
   @{b}MMM_LockObject@{ub} / @{"MMM_UnlockObject" Link "MMM_UnlockObject"} pair. Subclasses implementors should
   always use it in all methods.


@{b}SEE ALSO@{ub}
   @{"MMM_UnlockObject" Link "MMM_UnlockObject"}


@endnode
@Node "MMM_Pull" "multimedia.class/MMM_Pull"
@{fg shine}multimedia.class/MMM_Pull@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Pull@{ub} -- Pulls a data block from a port. (V50)


@{b}SYNOPSIS@{ub}
   LONG DoMethod(Object *obj, @{b}MMM_Pull@{ub}, ULONG port, APTR buffer, ULONG
   length);


@{b}FUNCTION@{ub}
   The method pulls a block of data of given length from a port of specified
   object. Data may be pulled from output ports only. Usually a pull from
   object's output causes object to generate following pull from the
   previous object. In typical conditions @{b}MMM_Pull@{ub} call does not reach
   multimedia.class. The one exception is when an object calls @{b}MMM_Pull@{ub} on
   its own input. If it is the case, the object should pass this call to the
   superclass. Then the call reaches multimedia.class. The multimedia.class
   @{b}MMM_Pull@{ub} implementation determines output port connected to the passed
   input and calls @{b}MMM_Pull@{ub} on this input. The final result is that subclass
   implementor may safely call @{b}MMM_Pull@{ub} on own object inputs, if only
   subclass @{b}MMM_Pull@{ub} is implemented in a way that @{b}MMM_Pull@{ub} calls on inputs
   are passed to superclass, these calls will be automatically forwarded to
   connected objects.


@{b}INPUTS@{ub}
   obj - object to perform method on.
   port - number of port to pull data from.
   buffer - address of buffer for pulled data.
   length - number of bytes to pull.


@{b}RESULT@{ub}
   Number of bytes pulled from port. @{"MMA_ErrorCode" Link "MMA_ErrorCode"} contains secondary error
   information.


@endnode
@Node "MMM_Push" "multimedia.class/MMM_Push"
@{fg shine}multimedia.class/MMM_Push@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Push@{ub} -- Pushes a data block to a port. (V50)


@{b}SYNOPSIS@{ub}
   LONG DoMethod(Object *obj, @{b}MMM_Push@{ub}, ULONG port, APTR buffer, ULONG
   length);


@{b}FUNCTION@{ub}
   The method pushes given block of data into a port of specified object.
   Data may be pushed to input ports only. Usually a push to object's input
   causes object to generate following push to the next object. In typical
   conditions @{b}MMM_Push@{ub} call does not reach multimedia.class. The one
   exception is when an object calls @{b}MMM_Push@{ub} on its own output. If it is
   the case, the object should pass this call to the superclass. Then the
   call reaches multimedia.class. The multimedia.class implementation of
   @{b}MMM_Push@{ub} determines input port connected to the passed output and calls
   @{b}MMM_Push@{ub} on this input. The final result is that subclass implementor may
   safely call @{b}MMM_Push@{ub} on own object outputs, if only subclass @{b}MMM_Push@{ub} is
   implemented in a way that @{b}MMM_Push@{ub} calls on outputs are passed to
   superclass, these calls will be automatically forwarded to connected
   objects.


@{b}INPUTS@{ub}
   obj - object to perform method on.
   port - number of port, where data will be pushed.
   buffer - address of data buffer.
   length - length of data in bytes.


@{b}RESULT@{ub}
   Number of data bytes accepted by object. @{"MMA_ErrorCode" Link "MMA_ErrorCode"} contains secondary
   error information.


@endnode
@Node "MMM_Seek" "multimedia.class/MMM_Seek"
@{fg shine}multimedia.class/MMM_Seek@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Seek@{ub} -- Forwards seek method to the connected object. (V50)


@{b}SYNOPSIS@{ub}
   LONG DoMethod(Object *obj, @{b}MMM_Seek@{ub}, ULONG port, ULONG type, UQUAD
   *position);


@{b}FUNCTION@{ub}
   Multimedia.class version of @{b}MMM_Seek@{ub} is called by a subclass, when an
   object wants to perform seek on its own input. Applications may call this
   method on output ports, seeking on input is for subclasses only. Calling
   on input means seek event backpropagation to the data source, then all
   objects in the pipeline can adjust their buffers and pointers. This class
   implementation of @{b}MMM_Seek@{ub} passes the method to a port connected to the
   specified one. If this fails, error code from the connected object is
   passed forward to the calling one.


@{b}INPUTS@{ub}
   obj - object calling for seek backpropagation.
   port - input port to be used.
   type - seek type, neither interpreted nor checked here.
   position - a pointer to UQUAD variable containing the new position,
     neither interpreted, nor checked here.


@{b}RESULT@{ub}
   Result of seek on the object connected to the port passed. @{"MMA_ErrorCode" Link "MMA_ErrorCode"}
   is propagated forward in case of failure.


@endnode
@Node "MMM_SetPort" "multimedia.class/MMM_SetPort"
@{fg shine}multimedia.class/MMM_SetPort@{fg text}

@{b}NAME@{ub}
   @{b}MMM_SetPort@{ub} -- Sets a value of a port dependent attribute. (V50)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_SetPort@{ub}, ULONG port, ULONG attribute,
   ULONG value);


@{b}FUNCTION@{ub}
   Sets the value of an attribute, which is port-dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. Usually this method is implemented at subclass level.
   If it reaches multimedia.class level and queried attribute is not port
   attribute but data stream one, the method is called on all outputs if
   comes from an input and called on all inputs if comes from an output.
   This way a request can travel along the processing structure.


@{b}INPUTS@{ub}
   obj - object,
   port - number of port to set attribute on,
   attribute - attribute,
   value - value to set. 64-bit numbers and larger structures are passed
     via pointer.


@{b}RESULT@{ub}
   TRUE if the attribute was recognized and value set, FALSE otherwise.


@{b}NOTES@{ub}
   Two useful macros: MediaSetPort() and MediaSetPort64() defined in
   <classes/multimedia/multimedia.h> set directly the 32-bit or 64-bit
   value.


@{b}EXAMPLE@{ub}
   UQUAD val64;
   ULONG val32;

   result = DoMethod(obj, @{b}MMM_SetPort@{ub}, port, MMA_Any32BitAttr, val32);
   \\* is equivalent to *\\
   result = MediaSetPort(obj, port, MMA_Any32BitAttr, val32);

   result = DoMethod(obj, @{b}MMM_SetPort@{ub}, port, MMA_Any64BitAttr,
     (ULONG*)&val64);
   \\* is equivalent to *\\
   result = MediaSetPort64(obj, port, MMA_Any64BitAttr, val64);


@endnode
@Node "MMM_SetPortFwd" "multimedia.class/MMM_SetPortFwd"
@{fg shine}multimedia.class/MMM_SetPortFwd@{fg text}

@{b}NAME@{ub}
   @{b}MMM_SetPortFwd@{ub} -- Sets a value of a port dependent attribute to connected
   port. (V50)


@{b}SYNOPSIS@{ub}
   LONG DoMethod(Object *obj, @{b}MMM_SetPortFwd@{ub}, ULONG port, ULONG attribute,
   ULONG value);


@{b}FUNCTION@{ub}
   Sets the value of an attribute, which is port dependent. It is typically
   an attribute of the port itself, or an attribute of the data stream going
   through the port. This method gets a port connected to the specified one,
   and then performs @{"MMM_SetPort" Link "MMM_SetPort"} on this connected port. This is the only
   difference between @{"MMM_SetPort" Link "MMM_SetPort"} and @{b}MMM_SetPortFwd@{ub}. @{b}MMM_SetPortFwd@{ub} is
   usually used inside the class, when an object needs to set an attribute
   of the previous, or the next object in a processing structure. Using
   @{"MMM_SetPort" Link "MMM_SetPort"} in this case will cause forwarding in wrong direction
   (request on input will be forwarded to outputs, request on output will be
   forwarded to inputs). @{b}MMM_SetPortFwd@{ub} will forward request on input to the
   previous object's output, and request on output to the next object's
   input as expected.


@{b}INPUTS@{ub}
   obj - object,
   port - number of port to set attribute on,
   attribute - attribute,
   value - value to set. 64-bit numbers and larger structures are passed via
     pointer.


@{b}RESULT@{ub}
   TRUE if the attribute was recognized and value set, FALSE otherwise.


@{b}NOTES@{ub}
   Two useful macros: MediaSetPortFwd() and MediaSetPortFwd64() defined in
   <classes/multimedia/multimedia.h> set directly the 32-bit or 64-bit value.


@{b}EXAMPLE@{ub}
   UQUAD val64;
   ULONG val32;

   result = DoMethod(obj, @{b}MMM_SetPortFwd@{ub}, port, MMA_Any32BitAttr,
     val32);
   \\* is equivalent to *\\
   result = MediaSetPortFwd(obj, port, MMA_Any32BitAttr, val32);

   result = DoMethod(obj, @{b}MMM_SetPortFwd@{ub}, port, MMA_Any64BitAttr,
     (ULONG*)&val64);
   \\* is equivalent to *\\
   result = MediaSetPortFwd64(obj, port, MMA_Any64BitAttr, val64);


@{b}SEE ALSO@{ub}
   @{"MMM_SetPort" Link "MMM_SetPort"}


@endnode
@Node "MMM_Setup" "multimedia.class/MMM_Setup"
@{fg shine}multimedia.class/MMM_Setup@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Setup@{ub} -- Prepares connected port for use. (V51)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_Setup@{ub}, ULONG port);


@{b}FUNCTION@{ub}
   This method is called on object's port just after it is connected to
   another one with @{"MediaConnectTagList" Link "MediaConnectTagList"}(). An object can do any preparations
   (calculations, buffer allocation etc.) depending on data stream
   parameters. Subclass should return TRUE if setup was succesfull
   (@{"MediaConnectTagList" Link "MediaConnectTagList"}() will fail, if setup on any of connected ports
   fails). If a subclass does not implement @{b}MMM_Setup@{ub} at all (because it
   does not need it), multimedia.class just checks if the port exists in the
   object and returns TRUE in the case.


@{b}INPUTS@{ub}
     obj - object, which port is to be set up.
     port - port number.


@{b}RESULT@{ub}
   Booolean, this class always returns TRUE, if only the port is found in
   the object.


@{b}NOTES@{ub}


@{b}SEE ALSO@{ub}


@endnode
@Node "MMM_UnlockObject" "multimedia.class/MMM_UnlockObject"
@{fg shine}multimedia.class/MMM_UnlockObject@{fg text}

@{b}NAME@{ub}
   @{b}MMM_UnlockObject@{ub} -- Unlocks previously locked object. (V50)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_UnlockObject@{ub});


@{b}FUNCTION@{ub}
   Unlocks object locked with @{"MMM_LockObject" Link "MMM_LockObject"}. It is done by releasing
   object's own semaphore.


@{b}INPUTS@{ub}
   None.


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   Not needed in applications usually, as every method is protected with
   @{"MMM_LockObject" Link "MMM_LockObject"} / @{b}MMM_UnlockObject@{ub} pair. Subclasses implementors should
   always use it in all methods.


@{b}SEE ALSO@{ub}
   @{"MMM_LockObject" Link "MMM_LockObject"}


@endnode

