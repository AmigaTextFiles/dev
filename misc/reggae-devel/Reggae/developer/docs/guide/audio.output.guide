@database audio.output.guide
@rem Source: class.c
@rem Generated with RoboDoc v3.1a (Jul  3 2005)
@rem RoboDoc is copyright 1994-1997 by Maverick Software Development
@node Main audio.output.guide
@{jcenter}
@{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}

@{"audio.output/background          " Link "background"}
@{"audio.output/MMA_Sound_AhiUnit   " Link "MMA_Sound_AhiUnit"}
@{"audio.output/MMA_Sound_Channels  " Link "MMA_Sound_Channels"}
@{"audio.output/MMA_Sound_SampleRate" Link "MMA_Sound_SampleRate"}
@{"audio.output/MMA_Sound_Volume    " Link "MMA_Sound_Volume"}
@{"audio.output/MMM_Play            " Link "MMM_Play"}
@{"audio.output/MMM_ReplyMsgAtEnd   " Link "MMM_ReplyMsgAtEnd"}
@{"audio.output/MMM_Seek            " Link "MMM_Seek"}
@{"audio.output/MMM_SignalAtEnd     " Link "MMM_SignalAtEnd"}
@{"audio.output/MMM_Stop            " Link "MMM_Stop"}
@{jleft}
@endnode
@Node "background" "audio.output/background"
@{fg shine}audio.output/background@{fg text}

@{b}CREATION DATE@{ub}
   $VER: audio.output 51.6 (11.2.2007)


@{b}DESCRIPTION@{ub}
   The class is a Reggae audio output using AHI hardware abstraction layer.
   The class uses high-level (device style) AHI interface, number of used
   unit may be set by application. The audio.output has one port (input)
   number 0. This port accepts MMFC_AUDIO_INT16 format. Currently only 1 or
   2 sound channels are supported. The audio.output class is a direct
   subclass of multimedia.class.


@{b}NEW ATTRIBUTES@{ub}
   Attributes applicability:
     I - may be set at creation time.
     S - may be set on an existing object.
     G - may be get from an object.
     P - may be set for an object's port.
     Q - may be queried from an object's port.

   @{"MMA_Sound_Channels" Link "MMA_Sound_Channels"}       (V50) [.SG.Q], ULONG
   @{"MMA_Sound_SampleRate" Link "MMA_Sound_SampleRate"}     (V50) [.SG.Q], ULONG
   @{"MMA_Sound_Volume" Link "MMA_Sound_Volume"}         (V50) [.SG.Q], ULONG
   @{"MMA_Sound_AhiUnit" Link "MMA_Sound_AhiUnit"}        (V51) [I.G.Q], ULONG
   MMA_StreamPosFrames      (V51) [..G.Q], UQUAD*
   MMA_StreamPosTime        (V51) [..G.Q], UQUAD*


@{b}NEW METHODS@{ub}
   @{"MMM_Play" Link "MMM_Play"}()                             (V50)
   @{"MMM_Stop" Link "MMM_Stop"}()                             (V50)
   @{"MMM_Seek" Link "MMM_Seek"}(port, type, position)         (V51)
   @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}(task, sigbit)          (V50)
   @{"MMM_ReplyMsgAtEnd" Link "MMM_ReplyMsgAtEnd"}(message)             (V51.6)


@{b}HISTORY@{ub}
   51.6  (11.02.2007)
   - Implemented @{"MMM_ReplyMsgAtEnd" Link "MMM_ReplyMsgAtEnd"}().

   51.5  (26.10.2006)
   - Stream end should rewind the stream, the same as @{"MMM_Stop" Link "MMM_Stop"} method
     does (of course non-seekable streams will ignore this). Fixed. Also
     stream rewinding behaviour is now documented explicitly.

   51.4  (11.07.2006)
   - Fixed debug, altered exit message for OM_NEW if no @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}
     specified.

   51.3  (15.05.2006)
   - Fixed a bug reported by Thomas Igracki. Symptoms: OM_NEW waits forever
     if some application opens AHI in exclusive mode.

   51.2  (03.05.2005)
   - Requires v51 multimedia.class.
   - Sound data buffers reworked (now use @{"MediaAllocVec" Link "multimedia.class.guide/MediaAllocVec"}()).
   - Implemented @{"MMM_Seek" Link "MMM_Seek"}, @{"MMM_Stop" Link "MMM_Stop"} tries to rewind stream.
   - Fixed lot of compiler warnings.

   51.1  (29.04.2005)
   - Well, v51 version, untested and probably buggy.

   50.14 (18.12.2004)
   - New, documented way of MMA_GetPort and MMA_SetPort forwarding.

   50.13 (16.12.2004)
   - Proper MMA_Get/SetPort forwarding.

   50.12 (22.11.2004)
   - Implemented MMA_TaskPriority (OM_NEW and OM_SET) with default value of
     2.

   50.11 (22.10.2004)
   - play buffer aligned to 16 bytes for AltiVec.

   50.10 (11.10.2004)
   - removed unused library bases in the class base.
   - added missing query support.
   - query tags are accessible via the class base.

   50.9 (05.09.2004)
   - changed according to new multimedia design.

   50.8 (16.03.2004)
   - fixed format autonegotiation with decoders.

   50.7 (09.03.2004)
   - SNDA_CurrentPos now counts also played frames of aborted (stopped)
     requests.

   50.6 (04.03.2004)
   - Bugfix: DTOM_SignalAtEnd did not work if playback limit set by
     SNDA_FrameCount was lower than 16384 frames (fit in single AHI
     request).

   50.5 (04.03.2004)
   - Added: object keeps track of number of played frames and can be
     queried about it with SNDA_CurrentPos.
   - Bugfix: DTOM_SignalAtEnd did not work if playback limit set by
     SNDA_FrameCount was multiple of 16384 frames. Fixes SoundTool problem
     with "PlayMarked" button not released after play.

   50.4 (03.01.2004)
   - Limiting frames with SNDA_FrameCount works.
   - Implemented fetching from stream object.

   50.3 (02.01.2004)
   - Implemented DTOM_SignalAtExit.

   50.2 (01.01.2004)
   - Basic functionality: Fetching from decoder object, DTOM_Play,
     DTOM_Stop.

   50.1 (29.12.2003)
   - Initial release.


@endnode
@Node "MMA_Sound_AhiUnit" "audio.output/MMA_Sound_AhiUnit"
@{fg shine}audio.output/MMA_Sound_AhiUnit@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Sound_AhiUnit@{ub} (V51) [I.G.Q], ULONG


@{b}FUNCTION@{ub}
   AHI unit to be used by the object for playing. Default value is unit 0,
   allowed range is from 0 to 3.


@{b}BUGS@{ub}
@{fg shine}   It is not implemented yet, and unit 0 is used always.

@{fg text}
@endnode
@Node "MMA_Sound_Channels" "audio.output/MMA_Sound_Channels"
@{fg shine}audio.output/MMA_Sound_Channels@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Sound_Channels@{ub} (V50) [.SG.Q], ULONG


@{b}FUNCTION@{ub}
   Specifies number of sound channels in the played stream. Application need
   not to specify it explicitly, as object queries it automatically from a
   previous one, when being connected. The default value of this attribute
   is one channel. It is overridden by querying the previous object (if it
   understands the attribute), then it can be overridden by an application.
   Current audio.output can handle one or two channels. Streams with more
   channels won't be played.
       

@{b}NOTES@{ub}
   Changing number of channels reported by the previous object makes no
   sense usually, as it produces strange effects.

   Changing @{b}MMA_Sound_Channels@{ub} takes effect on the next playback buffers
   swap if the object is playing. Depending on stream parameters it may take
   up to one second.


@endnode
@Node "MMA_Sound_SampleRate" "audio.output/MMA_Sound_SampleRate"
@{fg shine}audio.output/MMA_Sound_SampleRate@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Sound_SampleRate@{ub} (V50) [.SG.Q], ULONG


@{b}FUNCTION@{ub}
   Specifies playback sample rate in samples per second. Application need
   not to specify it explicitly as object queries it automatically from a
   previous one, when being connected. The default value of this attribute
   is 8000 samples per second. It is overridden by querying the previous
   object (if it understands the attribute), then it can be overridden by an
   application. Current audio.output support playback rates from 8000 to
   48000 samples per second.


@{b}NOTES@{ub}
   Changing @{b}MMA_Sound_SampleRate@{ub} takes effect on the next playback buffers
   swap if the object is playing. Depending on stream parameters it may take
   up to one second. AHI resampling algorithms are rather weak (poor
   antialiasing filters). For quality resampling or effects based on smooth
   samplerate change use resample.filter.


@endnode
@Node "MMA_Sound_Volume" "audio.output/MMA_Sound_Volume"
@{fg shine}audio.output/MMA_Sound_Volume@{fg text}

@{b}NAME@{ub}
   @{b}MMA_Sound_Volume@{ub} (V50) [.SG.Q], ULONG


@{b}FUNCTION@{ub}
   Specifies playback volume. The range is from 0 (silence) to 65536 (full
   volume), higher values are limited to the maximum. The default volume is
   65536 (max), then it may be overridden by the previous object when
   objects are connected (most of sound formats have no in-stream volume
   information, but if present, it will be used here). After that an
   application may set it.


@{b}NOTES@{ub}
   Changing @{b}MMA_Sound_Volume@{ub} takes effect on the next playback buffers swap
   if the object is playing. Depending on stream parameters it may take up
   to one second. For quality volume/fade/mix effects use gainmatrix.filter.


@endnode
@Node "MMM_Play" "audio.output/MMM_Play"
@{fg shine}audio.output/MMM_Play@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Play@{ub} (V50)


@{b}SYNOPSIS@{ub}
   success = DoMethod(obj, @{b}MMM_Play@{ub});


@{b}FUNCTION@{ub}
   The method instruct player process to start playback. It is asynchronous,
   so it returns to the caller immediately. Player process fills playback
   buffers with stream data, opens AHI unit and sends playback requests to
   it. Player process pulls data incrementally as sound is played. Playback
   is stopped automatically if data pull returns an error (MMERR_END_OF_DATA
   typically). It can be also stopped at any time with @{"MMM_Stop" Link "MMM_Stop"}. In any case
   signalling requests are executed (see @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}) and the stream is
   rewinded to the start (of course if the input stream is seekable).
   @{b}MMM_Play@{ub} issued while audio.output is still playing, is ignored.


@{b}INPUTS@{ub}
   None.


@{b}RESULT@{ub}
   TRUE if playback started, FALSE otherwise, check @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"} for
   additional information.


@{b}SEE ALSO@{ub}
   @{"MMM_Stop" Link "MMM_Stop"}, @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}, @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}


@endnode
@Node "MMM_ReplyMsgAtEnd" "audio.output/MMM_ReplyMsgAtEnd"
@{fg shine}audio.output/MMM_ReplyMsgAtEnd@{fg text}

@{b}NAME@{ub}
   @{b}MMM_ReplyMsgAtEnd@{ub} (V51.6)


@{b}SYNOPSIS@{ub}
   DoMethod(obj, @{b}MMM_ReplyMsgAtEnd@{ub}, struct Message *msg);


@{b}FUNCTION@{ub}
   Causes object to reply a message passed, at the end of playback. It may
   be triggered by either end of stream or @{"MMM_Stop" Link "MMM_Stop"} method. Unlike
   @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}, this notification is an one-time one, simply because a
   message can be replied only once. The message passed is sent to a player
   process using PutMsg() call. Then it is queued in a list. At stream end,
   or @{"MMM_Stop" Link "MMM_Stop"}, all messages in a list are ReplyMsg()-ed.


@{b}INPUTS@{ub}
   - msg, a message to be replied. It must be properly initialized system
     message, especially mn_ReplyPort musi be valid.


@{b}RESULT@{ub}
   None.


@{b}SEE ALSO@{ub}
   @{"MMM_Play" Link "MMM_Play"}, @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}


@endnode
@Node "MMM_Seek" "audio.output/MMM_Seek"
@{fg shine}audio.output/MMM_Seek@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Seek@{ub} (V51)


@{b}SYNOPSIS@{ub}
   success = DoMethod(obj, @{b}MMM_Seek@{ub}, ULONG port, ULONG type, UQUAD*
   position);


@{b}FUNCTION@{ub}
   Performs seek in the played audio stream. The method propagates itself to
   all the previous objects first. If the object is playing, new data are
   pulled to one of playback buffers, playback is stopped and restarted
   immediately with the new data. When time seek is requested, frame number
   is calculated based on current playback samplerate.


@{b}INPUTS@{ub}
   - obj, object to perform the method on.
   - port, number of port is always 0.
   - type, seek type (MMM_SEEK_FRAMES, MMM_SEEK_TIME).
   - position, new, absolute position in the stream. For frame seek it is in
     frames, for time seek in microseconds. It is 64-bit parameter passed by
     a pointer to the value.


@{b}RESULT@{ub}
   TRUE if success, FALSE otherwise. Check @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"} for detailed
   information.


@{b}NOTES@{ub}
   It is asynchronous call. Seeking stream is done in player process
   context, so even if seeking takes time (network streams), the method
   returns to the application immediately. Following @{b}MMM_Seek@{ub} calls will be
   blocking however until the first one is fulfilled.


@{b}SEE ALSO@{ub}
   @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}


@endnode
@Node "MMM_SignalAtEnd" "audio.output/MMM_SignalAtEnd"
@{fg shine}audio.output/MMM_SignalAtEnd@{fg text}

@{b}NAME@{ub}
   @{b}MMM_SignalAtEnd@{ub} (V50)


@{b}SYNOPSIS@{ub}
   DoMethod(obj, @{b}MMM_SignalAtEnd@{ub}, *struct Task task, ULONG sigbit);


@{b}FUNCTION@{ub}
   Causes object to signal specified task with specified signal at the end
   of playback. It may be triggered by either end of stream or @{"MMM_Stop" Link "MMM_Stop"}
   method. Multiple calls to this method will be added to a list, so
   multiple tasks may be signalled. A signalling request added with
   @{b}MMM_SignalAtEnd@{ub} stays valid until the object is disposed. It means every
   stopped playback will trigger signals. To remove a signalling request,
   call it again with the same task pointer and MMA_SignalAtEnd_Remove as
   sigbit.


@{b}INPUTS@{ub}
   - task, the task to be signalled,
   - sigbit, the signal number (not mask!) to be used, must be in (0, 31)
     range, or MMA_SignalAtEnd_Remove. Other values are ignored.


@{b}RESULT@{ub}
   None.


@{b}SEE ALSO@{ub}
   @{"MMM_Play" Link "MMM_Play"}, @{"MMM_ReplyMsgAtEnd" Link "MMM_ReplyMsgAtEnd"}


@endnode
@Node "MMM_Stop" "audio.output/MMM_Stop"
@{fg shine}audio.output/MMM_Stop@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Stop@{ub} (V50)


@{b}SYNOPSIS@{ub}
   DoMethod(obj, @{b}MMM_Stop@{ub});


@{b}FUNCTION@{ub}
   The method stops sound playback immediately, then performs all
   @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"} requests, closes AHI unit, flushes playback buffers and
   performs @{"MMM_Seek" Link "MMM_Seek"} on the stream to absolute 0 position. This command is
   asynchronous, stopping stream and seeking back to the beginning is done
   on the player process context.


@{b}INPUTS@{ub}
   None.


@{b}RESULT@{ub}
   None.


@{b}NOTES@{ub}
   If source is not seekable, seeking to 0 has no effect.


@{b}SEE ALSO@{ub}
   @{"MMM_Play" Link "MMM_Play"}, @{"MMM_SignalAtEnd" Link "MMM_SignalAtEnd"}


@endnode

