@database soundloop.filter.guide
@rem Source: class.c
@rem Generated with RoboDoc v3.1a (Jul  3 2005)
@rem RoboDoc is copyright 1994-1997 by Maverick Software Development
@node Main soundloop.filter.guide
@{jcenter}
@{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}

@{"soundloop.filter/background         " Link "background"}
@{"soundloop.filter/MMA_SoundLoop_Count" Link "MMA_SoundLoop_Count"}
@{"soundloop.filter/MMA_SoundLoop_End  " Link "MMA_SoundLoop_End"}
@{"soundloop.filter/MMA_SoundLoop_Start" Link "MMA_SoundLoop_Start"}
@{"soundloop.filter/MMA_StreamPosFrames" Link "MMA_StreamPosFrames"}
@{"soundloop.filter/MMM_Pull           " Link "MMM_Pull"}
@{"soundloop.filter/MMM_Seek           " Link "MMM_Seek"}
@{jleft}
@endnode
@Node "background" "soundloop.filter/background"
@{fg shine}soundloop.filter/background@{fg text}

@{b}DESCRIPTION@{ub}
   This sound filter purpose is creating loops in audio stream. Loop start
   and end point, nummber of repetitions, are configurable. A soundloop
   object will automatically buffer short loops, longer ones are done with
   stream seeking (seekable stream is needed for this). This class supports
   all three common sound formats:
   - MMFC_AUDIO_INT16,
   - MMFC_AUDIO_INT32,
   - MMFC_AUDIO_FLOAT32.
   Up to 256 channels (including) are supported. Note that it is guarranted,
        loops longer than 2^32 frames work properly.


@{b}NEW ATTRIBUTES@{ub}
   Attributes applicability:
     I - may be set at creation time.
     S - may be set on an existing object.
     G - may be get from an object.
     P - may be set for an object's port.
     Q - may be queried from an object's port.

   @{"MMA_SoundLoop_Start" Link "MMA_SoundLoop_Start"}      (V51) [ISGPQ], *UQUAD
   @{"MMA_SoundLoop_End" Link "MMA_SoundLoop_End"}        (V51) [ISGPQ], *UQUAD
   @{"MMA_SoundLoop_Count" Link "MMA_SoundLoop_Count"}      (V51) [ISGPQ],  ULONG
   @{"MMA_StreamPosFrames" Link "MMA_StreamPosFrames"}      (V51) [..G.Q], *UQUAD


@{b}NEW METHODS@{ub}
   @{"MMM_Pull" Link "MMM_Pull"}(port, buffer, length)  (V51)
   @{"MMM_Seek" Link "MMM_Seek"}(port, type, position)  (V51)


@endnode
@Node "MMA_SoundLoop_Count" "soundloop.filter/MMA_SoundLoop_Count"
@{fg shine}soundloop.filter/MMA_SoundLoop_Count@{fg text}

@{b}NAME@{ub}
   @{b}MMA_SoundLoop_Count@{ub} (V51) [ISGPQ], ULONG


@{b}FUNCTION@{ub}
   This attribute specified how many times a sound fragment between
        @{"MMA_SoundLoop_Start" Link "MMA_SoundLoop_Start"} and @{"MMA_SoundLoop_End" Link "MMA_SoundLoop_End"} should be repeated in the
   output stream. Note that passing 1 means no loop, as the fragment to be
   looped is played once. Passing 0 gives 2^32 loops, so it can be
   practically considered as infinite looping. When the attribute is get, it
   returns number of complete repetitions left to do at the time of query.
   Default value for this attribute is 1.


@endnode
@Node "MMA_SoundLoop_End" "soundloop.filter/MMA_SoundLoop_End"
@{fg shine}soundloop.filter/MMA_SoundLoop_End@{fg text}

@{b}NAME@{ub}
   @{b}MMA_SoundLoop_End@{ub} (V51) [ISGPQ], *UQUAD


@{b}FUNCTION@{ub}
   Loop end point in frames, counted from start of the input stream. This
   attribute is inclusive, it means if this attribute and
   @{"MMA_SoundLoop_Start" Link "MMA_SoundLoop_Start"} are set to be equal, one sample frame will be looped.
   Default value of this attribute is equal to MMA_Sound_FrameCount (number
   of frames in the sound). If MMA_Sound_FrameCount is 0 (which means
        unlimited or unknown length), @{b}MMA_SoundLoop_End@{ub} default value is set to
   $FFFFFFFFFFFFFFFF, so the loop will practically never turn back (which is
   intuitive, as one can't loop unlimited number of frames).


@{b}NOTES@{ub}
   As every 64-bit attribute, it is passed via pointer.


@endnode
@Node "MMA_SoundLoop_Start" "soundloop.filter/MMA_SoundLoop_Start"
@{fg shine}soundloop.filter/MMA_SoundLoop_Start@{fg text}

@{b}NAME@{ub}
   @{b}MMA_SoundLoop_Start@{ub} (V51) [ISGPQ], *UQUAD


@{b}FUNCTION@{ub}
   Loop start point in frames, counted from start of the input stream.
        Default value for this attribute is 0.


@{b}NOTES@{ub}
   As every 64-bit attribute, it is passed via pointer.


@endnode
@Node "MMA_StreamPosFrames" "soundloop.filter/MMA_StreamPosFrames"
@{fg shine}soundloop.filter/MMA_StreamPosFrames@{fg text}

@{b}NAME@{ub}
   MMA_Sound_StreamPosFrames (V51) [..G.Q], *UQUAD


@{b}FUNCTION@{ub}
   Returns number of sound frames pulled on the output so far.


@{b}NOTES@{ub}
   As every 64-bit attribute, it is passed via pointer.


@endnode
@Node "MMM_Pull" "soundloop.filter/MMM_Pull"
@{fg shine}soundloop.filter/MMM_Pull@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Pull@{ub} -- Writes looped audio stream to specified buffer. (V51)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{b}MMM_Pull@{ub}, ULONG port, APTR buffer, ULONG
   length);


@{b}FUNCTION@{ub}
   The method puts specified amount of data in the buffer. A loop specified
   with object's attributes is performed. Looping means repetition of block 
   of data. The block is specified with @{"MMA_SoundLoop_Start" Link "MMA_SoundLoop_Start"} and
   @{"MMA_SoundLoop_End" Link "MMA_SoundLoop_End"}, number of repetitions is set with @{"MMA_SoundLoop_Count" Link "MMA_SoundLoop_Count"}.
   Note that changing loop start, end and count changes while object is
   inside current loop may lead to strange effects.


@{b}INPUTS@{ub}
   obj - object to perform method on.
   port - number of port, data must be pulled from port 1 (output).
   buffer - destination buffer for data.
   length - amount of data to be pulled in *bytes*.


@{b}RESULT@{ub}
   Number of bytes pulled, secondary error information via @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}.


@{b}SEE ALSO@{ub}
   multimedia.class/@{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}


@endnode
@Node "MMM_Seek" "soundloop.filter/MMM_Seek"
@{fg shine}soundloop.filter/MMM_Seek@{fg text}

@{b}NAME@{ub}
   @{b}MMM_Seek@{ub} -- Moves stream pointer to a new position. (V51)


@{b}SYNOPSIS@{ub}
   ULONG DoMethod(Object *obj, @{"MMM_Pull" Link "MMM_Pull"}, ULONG port, ULONG type, UQUAD*
   position);


@{b}FUNCTION@{ub}
   As usual, this function moves reading position in the stream. This method
   can be succesful only if all previous objects connected in the pipeline
   support seeking. Note that seek position is for output (it means looped)
   stream, not input stream. If for example output stream is inside a third
   repetition of 100 frames loop which should be repeated 5 times, seeking
   either back or forward 100 frames, will not change the source stream
   position.


@{b}INPUTS@{ub}
   obj - object to perform method on.
   port - number of port, seek must be done on port 1 (output).
   buffer - type of seek, MMM_SEEK_TIME or MMM_SEEK_FRAMES.
   position - a pointer to an UQUAD variable holding the new position. It is
     in frames for frame seek and in microseconds for time seek.


@{b}RESULT@{ub}
   Number of bytes pulled, secondary error information via @{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}.
   Seek operation may fail if the connected stream is not seekable.


@{b}SEE ALSO@{ub}
   multimedia.class/@{"MMA_ErrorCode" Link "multimedia.class.guide/MMA_ErrorCode"}


@endnode

