      <html>  <head><title>
Istar Inference
      </title></head>   <body>

      <h1>
INFERENCE
      </h1><!-- -->

<a href="rfman.html#infce">Inference</a> is the central operation of Istar, 
and it is well to understand it soon after you have mastered the first 
steps of Istar.  Inference involves a number of attributes connected by the 
'inference' type of relatonship.  The whole inference KB consists of a 
number of stages in each of which one receives the links from the others; 
we will call the one the central attribute and the others its antecedents.
      <p>
For the central attribute you choose an <a href="#im">inference method</a> 
and for each of the 'inference' links to its antecedents you might choose a 
<a href="#uop">unary operator</a> and set a weighting.
      <p>
Page under construction.

      <h2><a name="meaningful">
Meaningful Inference Methods and Weightings
      </a></h2><!-- -->

      <h3><a name="">
Commonly Needed Types of Inference among Probabilistic Attributes
      </a></h3><!-- -->

In the ICT project we used a lot of probabilistic attributes, with many 
booleans that were considered probabilities with two values (0,1).  We 
found that our KB needed certain types of inference more commonly than 
others and moreover that selection of <a href="#im">inference method</a> 
was closely tied with selection of <a href="#uop">unary operators</a> on 
the relationships.  The set comprising inference method and the unary 
operators of all its antecedent links seemed to fall into several 
categories.  Other variations no doubt are possible, but the following 
seemed the most meaningful.  All involve a probabilistic consequent and 
usually probabilistic or boolean antecedents.  (When probabilistic 
antecedents are expected then booleans are accepted by Istar because it 
converts them automatically into two-value probabilities.  Also, Bayesian 
or proportion antecedents are taken to be probabilities.)

      <h4><a name="pick">
Simple Picking List
      </a></h4><!-- -->
      <ul>
  <li> Meaning:  The more the better
  <li> IM:  Count % A =, with first antecedent being a TRUE constant.
  <li> UOps:  Direct
  <li> Weights:  -  (You can achieve greater weightings on some antecedents 
by having two or more relationships to them.)
  <li> Antecedents:  Boolean.  The first ante must be a TRUE constant. 
Usually all the others are presented on a single form so that user can tick 
those that apply.
      </ul>

      <h4><a name="pick.some">
Picking List: Any M from N
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  The more the better, until we have enough.  Variant of 
Simple Picking List
  <li> IM:  Count % A =, with first antecedent being a TRUE constant.
  <li> UOps:  Direct
  <li> Weights:  -
  <li> Antecedents:  Boolean.  The first ante must be a TRUE constant.
  <li> Consequent:  Follow this by a limiter which defines 'enough'.  This 
can be either a consequent with inference method of "Whether A >" or a link 
whose unary operator is "Whether >".
      </ul>

      <h4><a name="b.b">
Belt and Braces
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  One or a few will do, but the more we have, the more 
certain we become.  Opposite effect of Paranoid.  Belt and Braces 
asymptotically approaches 1.
  <li> IM:  ProbOr
  <li> UOps:  ProbAnd
  <li> Weights:  Between 0..1, higher for more important antes (weight 
gives maximum contribution of the ante, when true)
  <li> Antecedents:  Probability or Boolean
      </ul>

      <h4><a name="weakest">
Weakest Link
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  Chain is only as strong as its weakest link.
  <li> IM:  Min
  <li> UOps:  ProbOr
  <li> Weights:  Between 0..1, lower for more important antes (weight gives 
lowest value the effect of ante can take the result down to)
  <li> Antecedents:  Probability or Boolean
      </ul>

      <h4><a name="paranoid">
Paranoid Weakest Link
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  If any one is missing then we are in trouble; and the more 
missing, the worse we get.  Opposite effect of Belt and Braces.
  <li> IM:  ProbAnd
  <li> UOps:  ProbOr
  <li> Weights:  Between 0..1, lower for more important antes (weight gives 
lowest value the effect of ante can take the result down to)
  <li> Antecedents:  Probability or Boolean
      </ul>

      <h4><a name="strongest">
Strongest Link
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  The strongest of the antecedents.  A bit like Belt and 
Braces but only the strongest antecedent makes a contribution and the 
others are effectively ignored.
  <li> IM:  Max
  <li> UOps:  ProbAnd
  <li> Weights:  Between 0..1, higher for more important antes (weight 
gives maximum contribution of the ante, when true)
  <li> Antecedents:  Probability or Boolean
      </ul>

      <h4><a name="synergy">
Synergistic
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  The whole is more than the sum of its parts.  In Belt and 
Braces the result is less than the sum of all its (weighted) antecedents, 
its graph being always below a 45 degree straight line.  With Synergistic 
the graph is above the straight line.  However, once it has reached 1 it 
stops there.  Although this seems as though it could be meaningful, we 
could not think of a real life example, so perhaps it is only meaningful in 
theory.
  <li> IM:  Complex in Istar.  I think you would probably have to do 
something like the following: convert all the antecedents to numbers in the 
range 0..100, multiply them together, limit them to 100, and convert back 
to probability.
  <li> UOps:  As needed.
  <li> Antecedents:  Probability or Boolean.
      </ul>

      <h4><a name="evidence">
Evidence
      </a></h4><!-- -->
      <ul>

  <li> Meaning:  Evidence for and against.
  <li> IM:  Bayesian
  <li> UOps:  Direct is taken to mean Bayesian Weighting automatically
  <li> Weights:  Bayesian Weights
  <li> Antecedents:  Bayesian, Probability or Boolean.
      </ul>

In the ICT knowledge base we found <a href="#paranoid">Paranoid</a> and <a 
href="#b.b">Belt and Braces</a> were the most often used.

<hr>

      <h2><a name="uop">
Unary Operators in Istar
      </a></h2><!-- -->

Page under construction.
      <p>

Unary operators are applied to <a href="rfman.html#infce">inference 
relationships</a> to modify the effect of the <a 
href="rfman.html#ante">antecedent</a> attribute before using it in the 
inference.  At present they only apply to inference relationships.
      <p>
Normally a relationship starts off with no unary operator, except as 
required by the <a href="rfman.html#im">inference method</a>.  For 
instance, the Bayesian inference method requires that its links hold 
bayesian weights, so in this case the indicated unary operator is 
overridden.
      <p>

      <h2><a name="uops">
List of Unary Operations
      </a></h2><!-- -->

The effect of most unary operators is given below, but there are two 
exceptions that override those.
      <p>
The highest priority is given to the CONTROL unary operator.  If one of 
these is found, and the antecedent is such that it can be converted into a 
truth value (i.e. of types Boolean, Probability, Proportion, Bayesian, 
Odds) then it might set the value of the consequent regardless of the other 
antecedents; see <a href="#control">below</a>.  If it is not one of these 
types then the CONTROL is ignored.
      <p>
The next highest priority is when the inference method of the consequent is 
Bayesian Accumulation of evidence.  Then the operation is different.  See 
<a href="#bayesian">below</a>.
      <p>
Otherwise, the operations are as follows:

      <h3><a name="direct">
Direct Unary Op: esUO_NONE
      </a></h3><!-- -->

No change (except when <a href="#bayesian">bayesian inference method</a>.
      <p>

      <h3><a name="negate">
Negate: esUO_NEG
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, OZMO, Float:  Takes negative of antecedent.
<li>Boolean:  Takes boolean opposite.
<li>Probability:  Takes probabilistic opposite (1 - p).
<li>Direction:  Changes direction by 180 degrees.
<li>Otherwise:  No change.
      </ul>


      <h3><a name="invert">
Invert: esUO_INVERT
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Odds, Ratio:  Exchanges numerator with denominator.
<li>Boolean:  Takes boolean opposite.
<li>Probability:  Takes probabilistic opposite (1 - p).
<li>Otherwise:  No change.
      </ul>

      <h3><a name="abs">
Absolute Value: esUO_ABS
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, OZMO, Float:  Takes absolute value of antecedent.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="scale">
Multiply (Scale) by Weight: esUO_SCALE
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, Float:  Multiplies value by weight.
<li>Otherwise:  No change.  But in future e.g. Ratio might be affected.
      </ul>

      <h3><a name="div">
Divide (Shrink) by Weight: esUO_DIV
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, Float:  Divides value by weight.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="add">
Add Weight: esUO_ADD
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, Float:  Adds numeric value of weight.
<li>Otherwise:  No change.  But in future e.g. Ratio might be affected.
      </ul>

      <h3><a name="subtract">
Subtract Weight: esUO_SUB
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer, Float:  Subtracts numeric value of weight.
<li>Otherwise:  No change.  But in future e.g. Ratio might be affected.
      </ul>

      <h3><a name="proband">
Take Proportion, Probabilistic And: esUO_PROPN, esUO_PROBAND
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Probability, Proportion, Bayesian:  Multiply the probability of the 
antecedent by the weight taken as a probability.
<li>Boolean:  Convert to Probability type and treat as above, giving the 
value 0 if False and giving the weight value (taken as a Probability) if 
True.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="probor">
Probabilistic Or: esUO_PROBOR
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Probability, Proportion, Bayesian:  Combine antecedent probability 
value with that of weight as a probabilistic OR (p + q - pq).
<li>Boolean:  Convert to Probability type and treat as above, giving the 
value Unity if True and giving the weight value (taken as a Probability) if 
False.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="mask">
Mask by Weight; Bitwise And: esUO_AND
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer only:  Bitwise AND with weight bits.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="union">
Union with Weight; Bitwise Or: esUO_OR
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer only:  Bitwise OR with weight bits.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="xor">
Bitwise Exclusive Or: esUO_XOR
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer only:  Bitwise XOR with weight bits.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="random">
Randomize: esUO_RANDOM
      </a></h3><!-- -->

Except when <a href="#bayesian">bayesian inference method</a>:
      <p>
      <ul>
<li>Integer:  Randomly give a value that is between the antecedent value 
and zero.
<li>Enumerated type, Ordinal:  If the antecedent has an Ordinal Limit (as 
most will, but a few from old KBs will not) then select a value from 1 to 
the limit at random.
<li>Otherwise:  No change.
      </ul>

      <h3><a name="control">
Control: esUO_CONTROL
      </a></h3><!-- -->

If the antecedent is of the appropriate type, one that can be converted to 
a truth value, then this unary operator takes precedence over all others. 
It is normally when one attribute is made irrelevant by another (such as 
"Are you ill?" would make "What illness do you have?" irrelevant if 
answered with 'No').  It acts to control whether the consequent is relevant 
or not, by taking the truth value of the antecedent and:
      <p>
      <ul>
<li>If True, then the consequent attribute is deemed relevant, and its 
inference proceeds as dictated by the inference method and the other 
antecedents.
<li>If False, then the consequent attribute is deemed irrelevant, and it is 
given an answered value found in the weight of this Control relationship.
      </ul>

      <h3><a name="bayesian">
When Inference Method is Bayesian Accumulation: esUO_WEIGHT, esUO_INVWEIGHT
      </a></h3><!-- -->

When the inference method is Bayesian Accumulation of Evidence, then 
special action is taken which overrides the above.  The unary operator on 
the relationship is replaced by one of these: INVWEIGHT being used if the 
unary operator is NEGATE or INVERT, and the WEIGHT being used otherwise. 
With these two unary operators:
      <p>
      <ul>
<li>If the antecedent is of type Bayesian, Probability, Boolean, then it is 
converted to Odds, using the weights found in the link, and the result is 
used as an Odds multiplier for the consequent.  If the unary operator is 
(ie. has become) INVWEIGHT, then the weights are reversed before being 
applied to generate the Odds.
      <p>
<li>If the antecedent is Odds, then it is used directly as an Odds 
multiplier for the consequent (and so INVWEIGHT and WEIGHT have the same 
effect).
      </ul>
      <p>



<hr>
      <h2><a name="im">
Inference Methods
      </a></h2><!-- -->

This is a reference guide to the types of inference methods available in 
the 'es' module of IRKit, as used in KBTools/Istar.  Each method is known 
by a short identifier of the for esIM_XXX where XXX is its name.  The 
prefix, esIM, means 'es' module Inference Method, and these names are those 
found in the program (e.g. in the es.h include file).

      <p>

      For each method we give the following information:

      <p>
      <ul>

<li>  esIM_XXX name
<li>  Its normal label in a list view gadget - what the knowledge engineer 
is likely to see.
<li>  What it does.
<li>  What types of antecedents is acts on or requires.
<li>  What types of consequents is requires.
<li>  Advanced use.
<li>  Any stopping rule that makes the result answered before all 
antecedents have been searched by backward chaining.

      </ul>

      <h3>
esIM_ADD, esIM_SUB
<!-- --><br>
"X = A + B, C, ...", "X = A - B, C, ..."


      </h3>


<strong>Action</strong>:
      With integers and floating point numbers these perform simple
addition and subtraction.  The first antecedent is taken (converted to 
integer or floating point as needed), and then all the others are added to 
or subtracted from it, accumulating a result as we take each antecedent. 
For simple use, ensure that all antecedents are integer or float.

      <p>
<strong>Antecedents</strong>:
      These act on numeric antecedents.

      <p>
<strong>Consequents</strong>:
      Integer, Float, Angle/Direction, Enum, Ordinal.  Others in future,
perhaps.

      <p>
<strong>Advanced use</strong>:
      When B (and C etc.) is a PROPORTION the inference is different: it
adds that proportion of what is already accumulated.  Thus (60 + 50%) gives 
90, not 110.  If C, D, etc. is a PROPORTION, it takes a proportion of what 
is already accumulated, not just of A.  Thus if A is 60, B is 50%, C is 20 
and D is 10% the result is:

      <ul>
<li>  take A to give 60
<li>  add B=50% of that to give 90
<li>  add C=20 to give 110
<li>  add D=10% of that to give 121.
      </ul>

At present, probabilities, Bayesians, odds and ratios act as proportions 
do.

      <h3>
esIM_MULT, esIM_DIV
<!-- --><br>
"X = A * B, C, ...", "X = A / B, C, ...)"


      </h3>

<strong>Action</strong>:
      A is taken and then multiplied or divided by the rest.

      <p>
<strong>Stopping</strong>:
      With multiplication, if an antecedent makes the result zero then no
further ones are taken.

      <p>
<strong>Antecedents</strong>:
      These act on numeric antecedents.

      <p>
<strong>Consequents</strong>:
      Integer, Float or Angle/Direction.

      <p>
<strong>Advanced use</strong>:
      The stopping rule can be used to control the order in which questions
are asked.


      <h3>
esIM_AND, esIM_OR
<!-- --><br>
"X = A & B & C & ...," "X = A | B | C | ..."


      </h3>

<strong>Action</strong>:
      The result is the normal boolean AND or OR of all the antecedents.

      <p>
<strong>Stopping</strong>:
      With AND, if any antecedent in order A, B, C ... is FALSE, no others
are taken.  With OR, if any is TRUE, no others are taken.

      <p>
<strong>Antecedents</strong>:
      These act on boolean antecedents.  Any other type is converted to
boolean if possible before being accumulated into the result.

      <p>
<strong>Consequents</strong>:
      Boolean.

      <p>
<strong>Advanced use</strong>:
      The stopping rule can be used to control the order in which questions
are asked.


      <h3>
esIM_NOT
<!-- --><br>
"X = !(A)"



      </h3>

<strong>Action</strong>:
      Gives the NOT of the antecedent.

      <p>
<strong>Antecedents</strong>:
      This acts on a single boolean antecedent, and ignores all others.

      <p>
<strong>Consequents</strong>:
      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_PROBAND, esIM_PROBOR, esIM_PROBNOT
<!-- --><br>
"p(X) = p(A) & p(B) &...", "p(X) = p(A) | p(B) |...", "p(X) = 1 - p(A)"

      </h3>

<strong>Action</strong>:
      They give, respectively, the probabilistic AND, OR and NOT.

      <p>
<strong>Antecedents</strong>:
      These act on probabilistic antecedents.  Proportions are treated as
probabilities.  Bayesians have their main part treated as a probability. 
Booleans are converted to probability.  Odds are converted to probability 
in the normal manner, viz. P = O / (1 + O).

      <p>
<strong>Consequents</strong>:
      <p>
<strong>Advanced use</strong>:

      <h3><a name="bayes">
Bayesian  esIM_BAYES
      </a></h3><!-- -->


<strong>Action</strong>:
      A very useful inference for decision support systems, this performs a
Bayesian accumulation of beliefs of evidence to come to a level of belief 
in a conclusion.

      That is, the consequent and antecedents are all levels of belief in
various propositions.  e.g. (Antecedent belief that) the bird has a red 
breast and (antecedent belief that) the bird is small might be evidence for 
(consequent belief that) the bird is a (British) robin, and (antecedent 
belief that) the bird has a thick bill would be evidence against.  (For 
'belief' you can also say 'probability'.)

      This form of inference is found in artificial intelligence.

      <p>
<strong>Stopping</strong>:
      Normally there is no stopping rule.  But you can define a Lower or
Upper Cut-Off to ignore any weak evidence once you are sufficiently 
confident in the present result.  Suppose you have six antecedents and a 
Lower Cut-Off of 10% on the consequent, and that three of the antecedents 
have been answered in such a way as to bring the belief in the consequent 
down to 5%.  Then if the other three (unanswered) antecedents have 
sufficiently weak evidence that however they are answered their combined 
effect will not bring the final result over 10%, then the consequent is 
considered answered.  So the three remaining antecedents are not searched 
during the backward chaining process.  Conversely for the Upper Cut-Off.

      <p>
<strong>Antecedents</strong>:
      This acts on Bayesian antecedents.  Probabilities, proportions and
booleans are converted to Bayesian whose a-priori is 0.5 (50%).

      <p>
<strong>Consequents</strong>:
      Bayesian.

      <p>
<strong>Advanced use</strong>:
      Using the Lower and Upper Cut-Offs you can make the knowledge base
appear more 'intelligent' and less pedantic.

      To understand Bayesian accumulation of evidence, read the following.

      The consequent belief is an accumulation of the antecedent beliefs,
for and against.  Each antecedent can have a different weight, so that 
having a red breast is of greater weight (more conclusive) as evidence for 
the bird being a robin than that the bird is small.  Evidence against (such 
as thick bill) is also indicated by the weights, and in this case the 
weight would be inverted.

      The weights are held as parameters of the relationship that joins the
antecedent to the consequent.  All antecedent relationships must have a UOp 
of either 'Normal' or 'Negate', and are expected to hold a Bayesian Weight, 
which is two odds multipliers - four small positive integers in all.  One 
pair should give a ratio >= 1 and the other pair should give a ratio <= 1. 
The distance these ratios are from 1 the 'stronger' the weight for this 
antecedent.

      If belief in the antecedent is total (e.g. 100%) then the full weight
found in the relationship is taken and accumulated into the consequent 
belief.  But if the belief is partial then only part of the weight is 
taken.  By "total" we mean either that the antecedent is definitely known 
to be true (100%) or definitely known to be false (0%).

      The consequent and each antecedent has an a-priori belief, which is
the belief which would be taken if there were no evidence.  (The a-priori 
is often found from the statistical probability of the proposition being 
true.)  The a-priori belief of the consequent is the starting point for 
accumulation.  e.g. The a-priori belief that the bird is a robin might be 
10%, and as evidence is accumulated for or against the belief varies from 
this level.  When the proposition is an antecedent of a Bayesian inference 
then the a-priori is also used to calculate partial weights.  If the belief 
is precisely that of the a-priori then the antecedent has zero weight, no 
effect.  As the belief moves away from the a-priori of the antecedent the 
amount of the weight taken increases until the whole is taken for a total 
belief.


      <h3>
esIM_EQ, esIM_NE
<!-- --><br>
"Whether A = all", "Whether A <> all"


      </h3>

<strong>Action</strong>:
      These can take most types of antecedent, and yields a boolean result.
All antecedents after the first, viz. B, C, D, ..., are converted to the 
type of the first before the comparison.

      The result is TRUE is A equals all the rest, is unequal to all the
rest, respectively.

      <p>
<strong>Stopping</strong>:
      Answered as soon as it is known the result is false, so no further
antecedents will be searched during backward chaining.

      <p>
<strong>Antecedents</strong>:
      A:  Any.
      Others:  Any convertible to type of A.

      <p>
<strong>Consequents</strong>:
      Boolean.

      <p>
<strong>Advanced use</strong>:
      Owing to the stopping rule, this can be used to control the order in
which questions are asked of the user.


      <h3>
esIM_GT, esIM_LT, esIM_GE, esIM_LE
<!-- --><br>
"Whether A > all", "Whether A < all", "Whether A >= all", "Whether A <= 
all"
      </h3>

<strong>Action</strong>:
      These all perform comparisons in a similar manner to the above.  The
difference is that the antecedents must by numeric or string.

      <p>
<strong>Antecedents</strong>:
      A: Any numeric or ordinal.
      Others:  Any convertible to type of A.

      <p>
<strong>Consequents</strong>:
      Boolean.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_PEQ, esIM_PGT, esIM_PLT, esIM_PNE, esIM_PGE, esIM_PLE
<!-- --><br>
"% A =", "% A >", "% A <", "% A <>", "% A >=", "% A <="



      </h3>

<strong>Action</strong>:
      These perform comparisons similar to the above, but they find the
proportion for which the comparison is true, rather than whether all are 
true.

      <p>
<strong>Antecedents</strong>:
      A: Any numeric or ordinal.
      Others:  Any convertible to type of A.

      <p>
<strong>Consequents</strong>:
      The result is a Proportion (or Probability or Bayesian).

      <p>
<strong>Advanced use</strong>:, esIM_CEQ, esIM_CGT, esIM_CLT, esIM_CNE, 
esIM_CGE, esIM_CLE
<!-- --><br>
"Count A =", "Count A >", "Count A <", "Count A <>", "Count A >=", "Count A 
<="


      </h3>

<strong>Action</strong>:
      These perform comparisons similar to the above, but count the number
for which the comparison is true.

      <p>
<strong>Antecedents</strong>:
      A: Any numeric or ordinal.
      Others:  Any convertible to type of A.

      <p>
<strong>Consequents</strong>:
      Integer.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_ISIN, esIM_CISIN, esIM_PISIN
<!-- --><br>
"A is found in all B, C, ...", "How many A is in", "% A is in"

      </h3>

<strong>Action</strong>:
      These look to see if A 'is in' all the other antecedents, and return
either a truth value, a number or a proportion (as in the comparisons 
above).

      By 'is in' we mean one of two things.  If all antecedents are
strings, then is looks to see if A is a substring of all other antecedents. 
If all antecedents are integers, it looks to see if A is a factor of all 
the others.

      <p>
<strong>Antecedents</strong>:
      A:  String or integer.
      Others:  Must be like A or convertible to A's type.

      <p>
<strong>Consequents</strong>:
      esIM_HAS:  Boolean.
      esIM_CHAS:  Integer.
      esIM_PHAS:  Proportion, Probability or Bayesian.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_HAS, esIM_CHAS, esIM_PHAS
<!-- --><br>
"A contains all B, C, ...", "How many are in A", "% in A"

      </h3>

<strong>Action</strong>:
      These operate inversely to the above.  They count or find the
proportion of antecedents after the first (A), that are 'in' A in the sense 
defined above.  That is, if strings, whether each is a substring of A, and 
if integers, if each is a factor of A.

      <p>
<strong>Antecedents</strong>:
      A:  String or integer.
      Others:  Must be like A or convertible to A's type.

      <p>
<strong>Consequents</strong>:
      esIM_HAS:  Boolean.
      esIM_CHAS:  Integer.
      esIM_PHAS:  Proportion, Probability or Bayesian.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_FIRSTKNOWN
<!-- --><br>
"First Known"



      </h3>

<strong>Action</strong>:
      This finds the first antecedent that has a known value.  It is useful
for instance in allowing the user to answer 'Unknown' and then inferring 
the value by other means.  It can take any type of antecedent that is 
convertible to the type of the consequent.

      <p>
<strong>Antecedents</strong>:
      Any that can be converted to type of consequent.

      <p>
<strong>Consequents</strong>:
      Any.

      <p>
<strong>Advanced use</strong>:
      With this you can provide sophisticated strategies of questioning the
user or otherwise finding out information.

      <h3>
esIM_CHOICE
<!-- --><br>
"Chooser"



      </h3>

<strong>Action</strong>:
      This acts like an array or small database.  It chooses one
antecedent.  If A is integer, it chooses the Ath among the rest.  That is, 
if A is 1 it chooses B, if 2, it chooses C, etc.  If 0, it returns Unknown. 
If A is boolean, it chooses B if A is false, and C if A is true.

      <p>
<strong>Antecedents</strong>:
      A:  Anything that can be converted to integer.
      Others:  Converted to type of consequent.

      <p>
<strong>Consequents</strong>:
      Any.

      <p>
<strong>Advanced use</strong>:
      Note that in backward chaining, it first gets A answered and once its
value is found will only backward chain up the appropriate chosen 
antecedent.  In this way you can cut out whole sections of questioning if 
you wish.


      <h3>
esIM_ALLANS
<!-- --><br>
"All Answered"



      </h3>

<strong>Action</strong>:
      This returns TRUE or FALSE, depending on whether all antecedents are
in an answered state.  They can be of any type.

      <p>
<strong>Antecedents</strong>:
      Any.

      <p>
<strong>Consequents</strong>:
      Boolean.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_COUNTANS
<!-- --><br>
"How many Answered"



      </h3>

<strong>Action</strong>:
      This counts the number of antecedents that are answered.  They can be
of any type.

      <p>
<strong>Antecedents</strong>:
      Any.

      <p>
<strong>Consequents</strong>:
      Integer.

      <p>
<strong>Advanced use</strong>:
Beware: The consequent is always known and answered.

      <h3>
esIM_COUNTKNOWN
<!-- --><br>
"How many Known"



      </h3>

<strong>Action</strong>:
      This counts the number of antecedents that have known values.  They
can be of any type.

      <p>
<strong>Antecedents</strong>:
      Any.

      <p>
<strong>Consequents</strong>:
      Integer.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_COUNT
<!-- --><br>
"No of Antes"



      </h3>

<strong>Action</strong>:
      This is simply a count of the antecedents.  Like a constant, but you
don't have to set it manually if you add another.

      <p>
<strong>Antecedents</strong>:
      Any.

      <p>
<strong>Consequents</strong>:
      Integer.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_IRAND
<!-- --><br>
"X = A + (Rand * (B - A))"



      </h3>

<strong>Action</strong>:
      This produces a random number.  At present, the antecedents are
irrelevant.  It uses the FastRand algorithm.

      <p>
<strong>Antecedents</strong>

      Any.

      <p>
<strong>Consequents</strong>:
      Integer.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_MAX, esIM_MIN
<!-- --><br>
"Max", "Min"


      </h3>

<strong>Action</strong>:
These act on numeric or string antecedents.  They find which one is maximum 
or minimum.

      <p>
<strong>Antecedents</strong>:
      Anything that can be converted to type of consequent.

      <p>
<strong>Consequents</strong>:
      Numeric or string.  The antecedents are converted to type of
consequent.

      <p>
<strong>Advanced use</strong>:
      These act on numeric or string antecedents.  They return the maximum
or minimum value.


      <h3>
esIM_WHICHMAX     , esIM_WHICHMIN
<!-- --><br>
"Which Max", "Which Min"


      </h3>

<strong>Action</strong>:
These act on numeric or string antecedents.  They find which one is maximum 
or minimum.

      <p>
<strong>Antecedents</strong>:
      Most numerics and string.

      <p>
<strong>Consequents</strong>:
      Integer, ENUM or ORDINAL (in which case the answer is 1 if A is
max/min, 2 if B, and so on).
      Or BLOCK, in which case the result is the DSAP of the antecedent
block.

      <p>
<strong>Advanced use</strong>:
      The use of BLOCK consequent is expected to become more versatile in
future, but at present you can find for instance the name of the block by 
conversion to string at the next stage.


      <h3>
esIM_AVG
<!-- --><br>
"Mean"



      </h3>

<strong>Action</strong>:
      This acts on certain numeric antecedents, and returns the mean
(average) of them.

      <p>
<strong>Antecedents</strong>:
      Numeric.

      <p>
<strong>Consequents</strong>:
      Numeric.

      <p>
<strong>Advanced use</strong>:

      <h3>
esIM_CONCAT
<!-- --><br>
"Concat"



      </h3>

<strong>Action</strong>:
This concatenates string antecedents.  e.g. "cat" and "dog" antecedents 
gives consequent "catdog" (note: no spaces; an option for spacing might be 
added in future).

In future CONCAT is likely to be used for any data that is essentially a 
linear sequence, such as sound samples, songs, animations, lists, arrays.

      <p>
<strong>Antecedents</strong>:
      If the antecedents are not string type then they are converted to
string if possible.

      <p>
<strong>Consequents</strong>:
      String.

      <p>
<strong>Advanced use</strong>:

      <p>

<hr>
Copyright (c) <a href="http://www.basden.u-net.com/andrew.html">Andrew 
Basden</a> 1997.  Last updated: 21 May 1999
</body></html>
