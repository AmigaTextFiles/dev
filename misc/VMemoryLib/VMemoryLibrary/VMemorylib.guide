@Database VMemoryLibrary
@Master Dokumentation
@Node Main Dokumentation
                         
	@{FG Highlight}
			********************************* 
			*                               @{FG text}*@{FG highlight} 
			*  Virtual-Memor@{FG text}y-Library V1.0  @{FG text}*@{fg highlight} 
			*                               @{FG text}*
			*********************************


		    (?) 1996 by A.C.M. the Assembler-Magician


	@{"Beschreibung der Library" link "Distribution"}
	@{"Installation der Library" link "Install"}
	@{"Offset's der Library" link "Offsets"}
	@{"Fehlermeldungen der Library" link "Errors"}
	@{"Die LibraryBase-Struktur" link "Libbase"}
	@{"Die Eintragsstruktur" link "Entries"}
	@{"Die Pagefiles" link "Pagefiles"}
	@{"Was ist virtueller Speicher" link "Virtuell Memory"}
	@{"Wozu ist sie gut ..." link "Other"}
	@{"Urheberrecht der Library" link "Copyright"}
	@{"Kontaktadresse des Autor's" link "Address"}
	@{"Bekannte ?? Fehler" link "KnownErrors"}
        @{"Unbekannte Fehler" link "UnknownErrors"}
	@{"Nur fuer Programmierer ..." link "Developers"}
	@{"Programme, welche die Library unterstuetzen:" link "Programms"}

@Endnode

@Node Distribution "Beschreibung der Library"

Die vmemory.library kann ueber jede Programmiersprache programmiert werden,
insofern Includes dafuer existieren.
Notfalls muss man sich selbst fuer seine eigene Programmiersprache Includes
erstellt werden.
In diesem Paket existieren Includes fuer Assembler (Maxon-Ass), C (Aztec) 
und Basic (FD).
Sie kann normal ueber OpenLibrary geoeffnet werden und gibt dabei, wie jede
andere Library auch, die Libbase im Register D0 zurueck.
Bei Nichterfolg des Oeffnens der Library wird eine 0 in D0 zurueckgegeben.
Beim ersten Aufruf der Library installiert sie sich reserviert sie sich
12000 Bytes fuer Speichereintraege und 500 Bytes fuer die Filenamen.
Dass heisst, 250 Bytes sind fuer den normalen Filenamen verfuegbar und 250
Bytes fuer einen Filenamen, in welchen @{"PageFiles" link "Pages"} umbenannt werden.

@{FG highlight}
Diese Library benoetigt keine MMU (wird auch nicht unterstuetzt) und sollte
auch noch unter einem 68000er mit Kickstart 1.2 funktionieren.
(Wurde aber noch nicht ausgetestet ...)
@{FG text}

@Endnode

@Node Install "Installation der Library"

Die Installation der Library ist denkbar einfach und bedarf dabei keinen
besonderen Vorkenntnissen ueber das Betriebssystem.
Die Library aus dem Libsverzeichnis ins eigene LIBS: kopieren.
Danach im Verzeichnis @{FG highlight}ENV:@{FG text} und in @{FG highlight}ENVARC:@{FG text} eine Datei mit dem Namen
@{FG Highlight}vmemlib.prefs@{FG text} anlegen.
Dabei geht man am besten so vor:

Man oeffne sich seinen Texteditor nach Wahl.

Gibt dort den kompletten Pfad ein, wo spaeter die @{"Pagefiles" link "Pagefiles"} gespeichert
werden sollen ein.
Z.B.: DH0:Pagefiles
Natuerlich muss dieser Pfad auch existent sein, ansonsten gibt es keinen
@{"Virtuellen Speicher" link "virtuell memory"}.

Speichert sich diese Texte unter den entsprechenden Namen und in den ent-
sprechenden Verzeichnissen ab.
Der Pfad @{FG Highlight}ENVARC:@{FG text} speichert die Datei permanent.
Der Pfad @{FG Highlight}ENV:@{FG text} speichert die Datei nur temporaer,
hat aber den Vorteil, dass die Library sofort genutzt werden kann.
Es ist natuerlich auch moeglich, in beiden Verzeichnissen zu schreiben.

Ist dies nun geschehen, steht der Benutzung vom @{"virtuellen Speichers" link "virtuell Memory"} nichts mehr im
Wege, es sei den, das benutzte Programm unterstuetzt diese Libary.

Aber nicht entaeuscht sein, wenn sich der Speicher jetzt nach dieser In-
stallation nicht sofort ins unendliche katapultiert, denn
diese Library macht @{FG highlight}keinen@{FG text} Systempatch der Offsets
der Exec-Library "_LVOAllocMem(),_LVOFreeMem()", sondern nutzt dabei
seine eigenen Belegungsroutinen.

Die Library wird auch nicht in dieser Hinsicht vom Betriebssystem unter-
stuetzt, dass vielleicht sogar dieselben Routinen auch auf diese Libary
zugreifen koennten.

Wie gesagt, es gibt noch sehr wenige Programme, welche diese Library unter-
stuetzen, deshalb ist sie auch @{"GIFTWARE" link "Copyrights"}.

Kleiner Tip am Rande: beim Pfad in der Datei vmemlib.prefs nicht unbedingt
                      'RAM:' angeben ... ;-)

@EndNode

@Node Offsets "Die Einspruenge der Library"

@{FG highlight}	Funktionsname                Offset (Dezimal)@{FG text}

	@{"_LVOAllocVMem       EQU         -30" link "AllocVMem"}
	@{"_LVOFreeVMem        EQU         -36" link "FreeVMem"} 
	@{"_LVOReadVMem        EQU         -42" link "ReadVMem"} 
	@{"_LVOWriteVMem       EQU         -48" link "WriteVMem"}
	@{"_LVORenamePage      EQU         -54" link "RenamePage"}
	@{"_LVOSwapVMem        EQU         -60" link "SwapVMem"}
	@{"_LVOAvailVMem       EQU         -66" link "AvailVMem"}
	@{"_LVOLBinHex         EQU         -72" link "LBinHex"}
	@{"_LVOReadPath        EQU         -78" link "ReadPath"}

@EndNode

@Node AllocVMem "Virtuellen Speicher anfordern"

@{B}Name@{UB}

	AllocVMem  - Belegt virtuellen Speicher

@{B}Synonyme@{UB}

	Pagenummer = AllocVMem( Adresse, Groesse);
	LONG                    APTR     LONG
           D0                    A0        D0

	Pagenummer = Indexnummer, nach welcher der Speicherblock wieder
	             gefunden werden kann. (Unbedingt merken)

	Adresse	   = Adresse oder APTR des Speicherblocks, welcher aus-
	             gelagert werden soll.

	Groesse    = Groesse in Bytes des Speicherblocks, welcher ausge-
	             lagert werden soll.
	
@{B}Funktion@{UB}

	Legt eine Auslagerungsdatei an, in welcher der angegebene Speicher-
	block geschrieben wird.

@{B}Parameterdaten@{UB}

	Adresse - Adresse eines Speicherblocks
	Groesse - Groesse des Speicherblocks

@{B}Ergebnisse@{UB}

	Pagenummer - ist die Kennung des Eintrages, unter welcher der 
	             Speicherblock abgelegt wurde. Unter dieser Nummer
                     kann dieser Speicherblock bearbeitet werden.
                     Dies ist eine sehr wichtige Nummer, wenn man den
	             ausgelagerten Speicherblock wieder einlesen will.
	             Diese Nummer kann aber auch einen Fehlercode ent-
	             halten, welcher aber immer kleiner als 0 ist.

@{B}Warnungen@{UB}

	Bei Speichermedien, wie zum Beispiel Diskette, welche sich jeder-
	zeit auswechseln lassen, kann es passieren, wenn eine Pagedatei
        auf einer anderen Diskette liegt, nicht mehr eingelesen werden kann
	oder aber auch eine falsche Datei eingelesen werden kann.
	Bei Nichteinlesen gibt die Library eine Fehlermeldung zurueck, beim
	Einlesen einer falschen Datei, weil sie vielleicht auf einer anderen
	Diskette liegt, ist die Library machtlos und erkennt dabei auch
	keinen Fehler.
	Der Speicherblock, welcher ausgelager wurde, bleibt bei dieser
        Funktion unveraendert im Speicher stehen, d. h., er wird @{FG highlight}nicht@{FG text}
	geloescht.

@{B}Siehe auch@{UB}

	@{"FreeVMem" link "FreeVMem"},@{"WriteVMem" link "WriteVMem"},@{"Fehlercodes" link "Errors"}.

@EndNode

@Node FreeVMem "Virtuellen Speicher freigeben"

@{B}Name@{UB}

	FreeVMem  - Gibt virtuellen Speicher wieder frei

@{B}Synonyme@{UB}

	Fehlercode = FreeVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Frei-
	             geben aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
@{B}Funktion@{UB}

	Loescht wieder eine Auslagerungsdatei und entfernt aus der den
	entsprechenden Eintrag mit der Nummer wieder aus der Eintrags-
	liste.


@{B}Parameterdaten@{UB}

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     @{"AllocVMem" link "AllocVMem"} zurueckgegeben wurde.

@{B}Ergebnisse@{UB}

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein @{"Fehler" link "Errors"} ist aufgetreten.

@{B}Warnungen@{UB}

	Diese Funktion liest den Speicher bei ihrem Aufruf @{FG highlight}nicht@{FG text} wieder
        in die Originaladresse ein.
	Jedoch ist diese Funktion nicht so empfindlich, wie die der fast
        identischen Funktion in der Execlibrary, und gibt bei einem nicht
        auffinden des Speichers lediglich einen Errorcode zurueck.

@{B}Siehe auch@{UB}

	@{"AllocVMem" link "AllocVMem"},@{"ReadVMem" link "ReadVMem"},@{"Fehlercodes" link "Errors"}.

@EndNode

@Node ReadVMem "Virtuellen Speicher einlesen"

@{B}Name@{UB}

	ReadVMem  - liest virtuellen Speicher wieder ein

@{B}Synonyme@{UB}

	Fehlercode = ReadVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Einlesen
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
@{B}Funktion@{UB}

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	liest den Speicherblock wieder so ein, wie er zuletzt ausgelagert
	oder geschrieben wurde.


@{B}Parameterdaten@{UB}

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     @{"AllocVMem" link "AllocVMem"} zurueckgegeben wurde.

@{B}Ergebnisse@{UB}

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein @{"Fehler" link "Errors"} ist aufgetreten.

@{B}Warnungen@{UB}

	Diese Funktion liest den Speicher bei ihrem Aufruf wieder an die
        Originaladresse, ab welcher ausgelagert wurde, ein.
	Bei einem Fehler, entsprechende Fehlernummer beachten.
	Es ist besonders sorgfaeltig dabei zu achten, dass bei dieser
	Funktion der Speicher veraendert wird !!
	Eventuell veraenderte Daten im Speicher gehen dabei mit Sicherheit 
	verloren.

@{B}Siehe auch@{UB}

	@{"WriteVMem" link "WriteVMem"},@{"SwapVMem" link "SwapVMem"},@{"Fehlercodes" link "Errors"}.

@EndNode

@Node WriteVMem "Virtuellen Speicher explizit auslagern"

@{B}Name@{UB}

	WriteVMem  - schreibt virtuellen Speicher explizit in die Datei

@{B}Synonyme@{UB}

	Fehlercode = WriteVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Schreiben
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
@{B}Funktion@{UB}

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	schreibt den Speicherblock so in die Datei, wie er vorliegt.


@{B}Parameterdaten@{UB}

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     @{"AllocVMem" link "AllocVMem"} zurueckgegeben wurde.

@{B}Ergebnisse@{UB}

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein @{"Fehler" link "Errors"} ist aufgetreten.

@{B}Warnungen@{UB}

	Diese Funktion schreibt den Speicher bei ihrem Aufruf so in die
        Datei ein, wie er vorliegt.
	Dass heisst, es werden dabei eventuell bereits ausgelagerte Daten
	ueberschrieben.
	Bei einem Fehler, entsprechende Fehlernummer beachten.
	Es ist besonders sorgfaeltig dabei zu achten, dass bei dieser
	Funktion der Speicher veraendert wird !!
	Eventuell veraenderte Daten in der Datei gehen dabei mit Sicherheit 
	verloren.

@{B}Siehe auch@{UB}

	@{"ReadVMem" link "ReadVMem"},@{"SwapVMem" link "SwapVMem"},@{"Fehlercodes" link "Errors"}.

@EndNode

@Node RenamePage "Umbenennen einer Indexnummer"

@{B}Name@{UB}

	RenamePage  - versucht einer Indexnummer einer anderen zuzuweisen

@{B}Synonyme@{UB}

	Fehlercode = RenamePage(OldPagenumber,NewPagenumber);
	LONG                    LONG          LONG
           D0                         D0          D1

	Fehlercode    = Fehlernummer, welche bei Problemen mit dem Umbenennen
	                aufgetreten sind.

	OldPagenumber = Indexnummer, nach welcher ein Speicherblock ausge-
	                lagert wurde.

	NewPagenumber = Neue Indexnummer, nach welcher ein Speicherblock nun
	                benannt werden soll.
	
@{B}Funktion@{UB}

	Versucht eine Indexnummer in eine andere umzubenennen, wobei (nur
	bei Erfolg) der alte Eintrag wieder freigeben wird und der Neue
	Eintrag belegt wird.


@{B}Parameterdaten@{UB}

	OldPagenumber - ist die Kennung des Speichers, unter welcher er ab-
	                gelegt wurde.
                        Dieser Wert ist identisch mit dem Wert, welcher von
                        @{"AllocVMem" link "AllocVMem"} zurueckgegeben wurde.

	NewPagenumber - ist ein neuer, eventuell freier Wert, welcher nun
	                dem Speicherblock zugewiesen werden soll.

@{B}Ergebnisse@{UB}

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein @{"Fehler" link "Errors"} ist aufgetreten.

@{B}Warnungen@{UB}

	Diese Funktion versucht die OldPagenumber auf die NewPagenumber zu
	transferieren und gibt danach wieder die OldPagenummer frei.
	Dabei wird aber auch das File auf dem Speichermedium umbenannt.

@{B}Siehe auch@{UB}

	@{"SwapVMem" link "SwapVMem"},@{"Fehlercodes" link "Errors"}.
@EndNode

@Node SwapVMem "Virtuellen Speicher austauschen"

@{B}Name@{UB}

	SwapVMem  - tauscht virtuellen Speicher mit normalem Speicher aus

@{B}Synonyme@{UB}

	Fehlercode = SwapVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Tauschen
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
@{B}Funktion@{UB}

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	tauscht den Speicherblock, mit den Daten aus der Datei.
	Das heisst, es erfolgt ein Platztausch, bei welchem @{FG highlight}keine@{FG text} Daten
	verloren gehen (sollten/duerfen/muessen).

@{B}Parameterdaten@{UB}

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     @{"AllocVMem" link "AllocVMem"} zurueckgegeben wurde.

@{B}Ergebnisse@{UB}

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein @{"Fehler" link "Errors"} ist aufgetreten.

@{B}Warnungen@{UB}

	Diese Funktion tauscht den Speicher mit den Daten aus der Datei
	ohne Datenverlust aus.
	Das heisst, was vorher auf dem Speichermedium stand ist danach im
	Speicher verfuegbar und was vorher im Speicher verfuegbar war, ist
	jetzt auf dem Speichermedium geschrieben worden.
	Dabei wird auch kein @{"Umbenennen" link "RenamePage"} vorgenommen.


@{B}Siehe auch@{UB}

	@{"ReadVMem" link "ReadVMem"},@{"WriteVMem" link "WriteVMem"},@{"RenamePage" link "RenamePage"},@{"Fehlercodes" link "Errors"}.
@EndNode

@Node AvailVMem "zeigt belegten virtuellen Speicher an"

@{B}Name@{UB}

	AvailVMem  - zeigt virtuellen @{FG highlight}belegten@{FG text} Speicher an

@{B}Synonyme@{UB}

	Nummer = AvailVMem();
	LONG
           D0                    

	Nummer = Zahl, wieviel virtueller Speicher bereits angelegt wurde.

	
@{B}Funktion@{UB}

	Sucht sich alle Eintraege heraus und prueft, ob sich dort ein
	gueltiger Wert befindet.

@{B}Parameterdaten@{UB}


@{B}Ergebnisse@{UB}

	Nummer - Groesse des belegten virtuellen Speichers, welcher be-
	         reits angelegt wurde.

@{B}Warnungen@{UB}

	Diese Funktion zeigt @{FG highlight}nur@{FG text} den wirklich belegten virtuellen Speicher 
	und nicht etwa andere Speicherbelegungen an.

@{B}Siehe auch@{UB}

	@{"AllocVMem" link "AllocVMem"},@{"FreeVMem" link "FreeVMem"}.
@EndNode

@Node LBinHex "rechnet binaere Zahl in HEX-ASCII um"

@{B}Name@{UB}

	LBinHex  - rechnet eine binaere Zahl in ASCII um.

@{B}Synonyme@{UB}

	LBinHex(Speicher, Zahl);
	        APTR      LONG
                 A0        D0                    

	Speicher = freier Speicherbereich, min. 8 Bytes, ab welchem die
                   umgerechnete Hex-Zahl als ASCII-String abgelegt wird.

	Zahl     = binaere Zahl, welche in einen HexString umgerechnet
                   werden soll.

	
@{B}Funktion@{UB}

	Diese Funktion berechnet aus einer binaeren Zahl das entsprechende
	Gegenstueck in ASCII.

@{B}Parameterdaten@{UB}

	Speicher = Adresse oder APTR auf einen freien Speicherbereich

	Zahl     = die binaere Zahl, welche umgerechnet werden soll.

@{B}Ergebnisse@{UB}

	Als Ergebnis steht nach Aufruf dieser Funktion die binaere Zahl
	als ASCII-HEX-String im angegebenen Speicher.

@{B}Warnungen@{UB}

	Diese Funktion ist (nur) in der Lage, Longwoerter umzurechnen,
	d. h., es sind 8 Hexstellen (Bytes) von noeten.
	Es wird dabei @{FG highlight}keine Nullunterdrueckung@{FG text} im String vorgenommen.
	Eventuell falsch angegebener Speicher wird dabei gnadenlos ueber-
	schrieben, was eventuell unerwuenschte und mehr oder weniger
	schoene Effekte zur Folge haben kann (Guru).

@{B}Siehe auch@{UB}

	@{"AvailVMem" link "AvailVMem"}.
@EndNode

@Node ReadPath "liest Pagepfad ein"

@{B}Name@{UB}

	ReadPath  - liest den Pagepfad ein.

@{B}Synonyme@{UB}

	ReadPath();                    

	
@{B}Funktion@{UB}

	Diese Funktion liest aus der Librarybase den Pagepfad ein,
	wo die entsprechenden Pagefiles zu finden sind.
	Inhalt ist identisch mit dem Inhalt aus ENV:vmemlib.prefs.

@{B}Parameterdaten@{UB}


@{B}Ergebnisse@{UB}

	Als Ergebnis laesst sich der Pagepfad ueber die Libbase mit dem
	Eintrag sb_PagePath(a6) als String auslesen.

@{B}Warnungen@{UB}


@{B}Siehe auch@{UB}

@EndNode

@Node Errors "Fehlercodes der Libary"

     @{B}Wert@{UB}        @{B}Kurzbeschreibung@{UB}

          0L          =        @{"Alles Ok" link "OK"}
	 -1L          =        @{"Tabelle voll" link "TableFull"}
         -2L          =        @{"Kein Prefsfile" link "NoPrefs"}
         -3L          =        @{"Kein Startspeicher" link "NoStartMem"}
         -4L          =        @{"Dateioeffnungsfehler" link "NoFileOpen"}
         -5L          =        @{"Fehler beim Schreiben" link "FailWrite"}
         -6L          =        @{"Keinen leeren Eintrag gefunden" link "NoEmptyEntry"}
         -7L          =        @{"Keinen Eintrag geleert" link "NoEntryFreed"}
         -8L          =        @{"Fehler beim Lesen" link "FailRead"}
         -9L          =        @{"Eintrag nicht gefunden" link "NoEntryFound"}
        -10L          =        @{"Eintrag bereits belegt" link "EntryOccupied"}

@EndNode

@Node Ok "Kein Fehler"

Alles Ok, eigentlich kein Fehler, kann aber ebenfalls zurueckgegeben werden.
Ausser bei @{"AllocVMem" link "AllocVMem"} ist es mit Sicherheit eine Pagenummer.

@EndNode

@Node TableFull "Eintragstabelle voll"

Dieser Fehler wird wahrscheinlich so gut wie nie auftreten, aber was weiss
man den schon ..
Soweit, sogut, sollte er aber dennoch auftreten, so bedeutet es nur, dass
momentan alle Eintraege belegt sind und derzeit keine Virtuelle Page an-
gelegt werden kann.

Um zu erklaeren, wie dieser Fehler auftreten kann, muss ich etwas weiter
ausholen:

Beim Anlegen einer Library im Speicher vom Betriebssystem, wird beim ersten
Mal immer besondere Vorbereitungen fuer die Libary vorgenommen, welche
bei einem zweiten Oeffnen nicht noetig sind.
So ist es auch bei dieser Library der Fall, dazu gehoert unter anderem,
dass sich die Library 12000 Bytes Speicher reserviert, worin die einzelnen
Eintraege geschrieben und verwaltet werden.
Diese Library ist in der Version 1.0 in der Lage davon exakt 1000 Pages
(Seiten) anzulegen und zu verwalten, kann aber dieser Speicher nicht
angelegt werden, so tritt dieser Fehler auf.
Naeheres dazu siehe auch @{"Eintraege" link "Entries"}.

@EndNode
 
@Node NoPrefs "Kein Preferencefile vorhanden"

Tritt dieser Fehler auf, so wurde die Library wahrscheinlich falsch oder
gar nicht vom @{FG highlight}User@{FG text} installiert.
Abhilfe schafft hierbei das Anlegen eines solchen Prefsfiles,
siehe dazu auch die @{"Installation der Library" link "Install"}.

@EndNode

@Node NoStartMem "Keinen Eintragsspeicher erhalten"

Hierbei ist schon beim ersten Einladen der Libary vom Betriebssystem etwas
schiefgegangen und bedeutet lediglich, dass kein Speicher fuer die Ver-
waltung der Eintraege erhalten wurde.

Siehe dazu auch @{"Eintraege" link "Entries"},@{"Eintragstabelle voll" link "TableFull"}.

@EndNode

@Node NoFileOpen "Fehler beim Oeffnen des Pagefiles"

Bei diesem Fehler gab es Probleme beim Oeffnen des Pagefiles, welche die
Daten enthaelt seitens der Dos.library.
Auftreten kann dieser Fehler, wenn das Pagefile von aussen (anderen Pro-
grammen) geloescht wurde, dass File gar nicht auf dem Datentraeger
existiert oder aber vielleicht sogar ein Schreib-LeseFehler in der Datei ...
Siehe dazu auch @{"Bekannte Fehler" link "KnownErrors"}

@EndNode

@Node FailWrite "Fehler beim Schreiben in Pagefile"

Hierbei konnte das Pagefile sehr wohl geoeffnet werden, es traten aber
Fehler beim Schreiben der Datei auf.
Es kann eventuell daran liegen, dass der Datentraeger bereits voll ist
oder die Datei beschaedigt ist.

@EndNode

@Node NoEmptyEntry "Keinen leerer Eintrag mehr vorhanden"

tritt auf, wenn zum Beispiel bei @{"SwapVMem" link "SwapVMem"} der Eintrag
sehr wohl existiert, aber kein Ausweicheintrag mehr zum Tauschen vor-
handen ist.
D. h., das Tauschen von Speicherbereichen geht wie folgt vor sich:

Es wird zuerst versucht einen neuen leeren Eintrag zu finden (FEHLER).

Danach wird erst der neue Speicherbereich ausgelagert und in Eintragstabelle
aufgenommen.

Dann liest die Library den alten Speicherbereich wieder ein.

Und wenn bis dahin alles glatt ging, wird der alte Speicherblock vom
Datentraeger geloescht und in der Eintragstabelle als frei gekennzeichnet.

Zu guter Letzt bekommt dann der neue Eintrag noch den Namen des alten, wie
auch die ausgelagerte Datei.

Siehe dazu auch @{"die Eintraege" link "Entries"} und @{"die Pagefiles" link "Pagefiles"}.

@EndNode

@Node NoEntryFreed "Keinen Eintrag leeren (freigeben) koennen"

Dieser Fehler tritt eigentlich nie auf.

Sollte es aber dennoch in zukuenftigen Versionen der Fall sein, so be-
deutet dies, dass es hier unmoeglich war, einen Eintrag wieder freizugeben.

@EndNode

@Node FailRead "Fehler beim Lesen des Pagefiles"

Dieser Fehlercode ist das aequivalente Gegenstueck zu @{"FailWrite" link "FailWrite"} und zeigt an,
dass beim Lesen eines Pagefiles Probleme auftraten.

Ursachen hierfuer koennen sein:

Das Pagefile ist beschaedigt oder es konnte schon nicht richtig geschrieben
werden ...

@EndNode

@Node NoEntryFound "Keinen solchen Eintrag gefunden"

Bedeutet, dass ein Eintrag mit der angegebenen Indexnummer nicht in der
Verwaltung der Eintraege existiert und daher auch nicht gefunden werden
konnte.

Ursachen dazu koennen sein, dass der Eintrag nie angelegt worden ist oder
er eventuell (irrtuemlich) von einem anderen Programm bereits freigegeben
worden ist.

Normalerweise sollte es nicht passieren, dass zum Beispiel von der Library
der gleiche Eintrag zweimal vergeben wird, aber was weiss der (Fehler)teufel
denn schon.

@EndNode

@Node EntryOccupied "Eintrag wurde bereits vergeben"

Hier wurde zum Beispiel versucht, einen Eintrag in einen Namen umzubenennen,
welcher bereits besetzt ist.
Im Klartext heisst dies, dass ein solches Pagefile bereits existiert und
daher nicht ueberschrieben werden kann oder darf.
Dieser Fehler tritt eigentlich nur bei den Routinen @{"RenamePage" link "RenamePage"} auf.
Diese Routine wird unter anderem auch von @{"SwapVMem" link "SwapVMem"} benutzt.

@EndNode

@Node Libbase "Die Librarybase-Struktur"

Die Librarybase-Struktur besteht derzeit aus 13 Eintraegen, welche ev.
mehr oder weniger interessante Informationen bietet.

@{B}Name@{UB}       @{B}Groesse@{UB}   @{B}Typ@{UB}        @{B}Inhalt@{UB}

sb_SysLib    1       APTR       Zeiger auf die Execbasestruktur
sb_DosLib    1       APTR       Zeiger auf die Dosbasestruktur
sb_TBase     1       APTR       Zeiger auf den Eintragsverwaltungsspeicher
sb_TCount    1       ULONG      aktuelle Anzahl angelegter Pages
sb_NEntry    1       APTR       Zeiger auf naechsten freien Eintrag
sb_NIndex    1       ULONG      Nummer des naechsten leeren Indexes
sb_OldIndex  1       ULONG      Nummer der letzten angelegten Page
sb_PagePath  1       APTR       Zeiger auf den vollen Pfadnamen + File
sb_RenPath   1       APTR       Zeiger auf den vollen RenamePfad + File
sb_Pagename  1       APTR       Zeiger auf den Namen des Prefs-Files
sb_SegList   1       ULONG      Nummer in der Segmentsliste*
sb_Flags     1       UBYTE      Flaggenbits fuer Besetztung v. Routinen
sb_pad       1       UBYTE      ???*


*
Zu diesen Routinen kann ich leider nur sehr wenig sagen, da sie unbedingt
notwendig sind und eigentlich nur zur Verwaltung der Library fuer die
Execlibrary benoetigt werden.
Veraendern dieser Werte bitte nur, wenn man weiss, was man tut.

In Wahrheit duerfen die anderen Eintraege ebenfalls nur gelesen werden, aber
nie beschrieben.
Sonst haette dies eventuell fatale Folgen fuer die Library und der Aus-
fuehrung der Routinen selbst.
Es kann dann unter Umstaenden sogar Datenverlust mit sich bringen und im
schlimmsten Fall sogar eine Zerstoerung des Speichermediums, aber nicht des
Geraetes, worin sich das Medium befand.
Bei meinen Testphasen wurde ich dadurch sogar schon mal von der Festplatte
mit einem Validierungsvorgang von 20 Minuten belohnt.

@EndNode

@Node Entries "Die Eintragsstruktur des Virtuellen Speichers"

Die Eintragsstruktur der Library, welche eingentlich das Kernstueck der
Verwaltung von virtuellen Speichers darstellt, ist in Wirklichkeit sehr
einfach bis ausreichend gehalten.

Ein socher Eintrag besteht nur aus 12 Bytes, welche in 3 Longwort unter-
teilt worden sind:

@{B}Name@{UB}   @{B}Bytes@{UB}   @{B}Typ@{UB}       @{B}Beschreibung@{UB}

INDEX     4    ULONG     Name der Page, wert welcher von AllocVMem zurueck
                         gegeben wird.

SIZE      4    ULONG     Groesse des Speicherblocks, welcher auf das
                         Speichermedium kopiert wurde.

ADRESS    4    APTR      Zeiger auf das erste Byte des Speicherbereichs,
                         welcher kopiert wurde.

Durch dieses Wissen laesst sich auch schnell erklaeren, warum die Library
eigentlich (nur) 1000 Pages verwalten kann.
Der Speicherbereich, welcher auch StartMemory genannt wird, siehe dazu auch
@{"Fehlercode" link "Errors"}, misst exakt 12000 Bytes.
Dass heisst 12000 Bytes / 12 Bytes = 1000 Eintraege.
Nachdem 1 Eintrag 12 Bytes misst und dies multipliziert mit 1000 = 12000
Bytes StartMemory.

Erkannt und gesucht werden diese Eintraege nur an ihrer Indexnummer, was
auch ein kleines, schnelles und relativ unkompliziertes Verwalten der
Pages ermoeglicht.
Dies ist auch der Grund, warum die Routinen @{"SwapVMem()" link "SwapVMem"}, @{"ReadVMem()" link "ReadVMem"},
@{"WriteVMem()" link "WriteVMem"} und @{"FreeVMem()" link "FreeVMem"} als Argument nur mehr noch die Pagenummer
zum Arbeiten benoetigen.

@EndNode

@Node Pagefiles "Beschreibung des ausgelagerten Speichers"

Die Pagefiles beinhalten ausser den Daten, welche der ausgelagerte Speicher
enthalten hat, nichts.
Die Groesse dieser Pagefiles hangen nur davon ab, welche Groesse bei der
Routine @{"AllocVMem()" link "AllocVMem"} angegeben wurde.
Weiteres ist, diese Pagefiles enthalten auch @{FG highlight}keine@{FG text} Angaben ueber den Index,
Adresse oder sonst irgendwelche Daten.
Der Speicher wird nur ueber die @{"Eintraege" link "Entries"} verwaltet, d. h., ist ein solcher
Eintrag einmal versehentlich geloescht worden, so ist auch das zugehoerige
Pagefile verloren und liegt sinnlos auf dem Speichermedium.
In meinen Testphasen ist es mir bis jetzt noch nie passiert, dass ein
solches Pagefile von der Library versehentlich geloescht wurde.
Mit Vorsicht zu geniesen ist es, wenn zum Beispiel Variablen in Hochsprachen
wie Basic oder dergleichen, welche ihre Variablen dynamisch verwalten,
auszulagern. Dabei kann es durchaus passieren, dass hier falscher Speicher
beim Einlesen ueberschrieben wird, was aber kein Bug der Library selbst ist.
Ziemlich ohne Bedenken kann man z. B. Graphicdaten oder Speicher, welcher
vorher vom Betriebssystem sicher als belegt deklariert wurde, auslagern.

@EndNode
 
@Node "Virtuell Memory" "Was ist virtueller Speicher ?"

Der Virtuelle Speicher ist der Schwachpunkt des Amiga-Betriebssystem, und
es ist sehr schade, dass er nicht unterstuetzt wird.
(Zumindest trifft dies bei Konfigurationen ohne MMU zu >:-( )

Virtueller Speicher ist ein Speicherbereich, welcher eigentlich fuer
den Computer nicht existent ist, aber dennoch mit Hilfsmitteln wie
einer MMU (Memory Managment Unit = Speicher Verwaltungs Einheit) zur
Verfuegung gestellt werden kann.
Dieser Speicherbereich wird nicht selten zum Beispiel auf einer Festplatte
in Form von Dateien geschrieben und bei bedarf, dass heisst, wenn er
angesprochen wird, wieder in einen zugaenglichen Speicherbereich geladen
und die Aufrufe von der MMU auf diesen neuen Speicherbereich umgelenkt.

Es funktioniert ueber die MMU auf diese Weise, dass hierbei Speicherbereich
angelegt wird, welcher ausserhalb des Adressbereichs des Prozessors liegt.
Nun hat der Prozessor die Eigenschaft, wenn der auf ein solches Befehlswort
trifft, er beim vorhandensein einer solchen MMU, dieses Befehlswort auch
diesem besonderen Baustein uebergibt.
Bei nichtexistieren einer solchen, wuerde sich der Amiga in so einem Fall
ins Nirvana verabschieden was eine Meditation zur Folge hat ...
 
Die VMemorylibrary benoetigt zur Arbeit @{FG highlight}keine@{FG text} solche MMU.
Dies ist auch der Grund, warum man bei der Programmierung der Library sehr
sorgfaeltig umgehen muss.

Diese Library kann natuerlich keine Aufrufe in illegalem Speicherbereich
abfangen und eventuell den Prozessor umlenken auf neuen Speicherbereich.
(Sollte es aber vielleicht doch einen Weg ohne MMU und nur mit dem reinen
Prozessor geben, so koenntet ihr mir doch eventuell schreiben ;-) )

Sehr wohl ist diese Library aber in der Lage, Speicher (kurzzeitig) auf
ein Speichermedium auszulagern, worauf dieser neu gewonnene Speicher
mehr oder weniger gefahrlos Veraendert werden darf.
Sollten die Veraenderungen wieder rueckgaengig gemacht werden, so holt
man sich einfach den Speicher wieder mittels @{"SwapVMem()" link "SwapVMem"} o. @{"ReadVMem()" link "ReadVMem"}.

Es waere damit zum Beispiel auch moeglich, sehr grosse Dateien, welch nicht
in einem Stueck in den Speicher passen wuerden, in kleinere Teile (Pages)
zerteilen und dennoch einlesen (z.b.: Adressdaten).

Oder ein anderes Anwendungsbeispiel waere zum Beispiel ein File-Zapper,
welcher mit dieser Library in der Lage ist, auch Dateien zu Zappen, welche
zum Beispiel 5 Megabyte gross sind, der vorhandene Speicher aber nur
2 Megabyte misst.

Ich bin mir dessen Sicher, dass es genug Programmierer geben wird, welche
auch die ausgefallensten Ideen dafuer aufbringen und umsetzen.

@EndNode

@Node Other "Wozu ist sie gut ..."

Eine berechtigte Frage, welche ich auch hier beantworten moechte.

Diese Library sollte erstens dazu dienen, um zu demonstrieren, dass es
auch moeglich ist 'vituellen Speicher' ohne MMU anzulegen und zu verwalten.

Zweitens sollte sie auch eine alternative fuer Programmierer darstellen,
um auch Systeme mit nicht so viel Speicher (100 MB Hauptspeicher ;-) ) zu
unterstuetzen.

Drittens sollte sie eine (Speicher)Luecke des Betriebssystems fuellen.

Viertens appeliert der Programmierer der Library an andere Programmierer
sie auch, wenn moeglich zu unterstuetzen.

Fuenftens hofft der Programmierer der Library auch auf andere Programmierer,
dass sie diese (besondere) Library unterstuetzen.

@EndNode

@Node Copyright "Urheberrecht der Library"

Diese Rechte gelten vorerst fuer die Version 1.0 der Library, Aenderungen
in spaeteren Versionen werden vorbehalten.

Das heisst vorerst:

Diese Library CATWARE und nicht PD !!!
Das heisst bei Gefallen und Nutzung der Library erwartet der Programmierer
eine kleine Anerkennung, frei nach dem Motto: Alles fuer die Katz'.
Schickt dem @{"Programmierer" link "Address"} irgendetwas an Zubehoer, was man als Katzenbe-
sitzer brauchen koennte.
Dies waeren zum Beispiel: Flohbaender, Katzenstreu, Amigas :-), Katzen-
spielzeug usw.
Bitte schickt es @{"mir" link "Address"} mit der Registrierungskarte, welche bitte ausgedruckt
werden muss.
Die Registrierung selbst, geschieht unter voelliger Diskretion und deren
Daten unterliegen natuerlich dem Datenschutz und ist bei Zusendung mit
dem Utensiel fuer die Katz' kostenlos.
Nehmt diesen Aufruf mit der CATWARE ohne weiteres Woertlich ...

Die Urheberrechte dieser Library liegen beim @{"Programmierer" link "Address"} des
Autors, dass heisst, die Library darf frei nach belieben genutzt werden.

Jedoch ist dabei etwas zu beachten:

Das Archiv darf nur vollstaendig und die Library darf nur unveraendert
weitergegeben werden.

Sie darf jederzeit von fremden Programmen aufgerufen und genutzt werden.

Ausnahmen bilden hierbei kommerzielle Produkte, welche bei einer Nutzung
mindestens die Kontaktaufnahme des @{"Autors" link "Address"} beduerfen.

Das Paket darf jederzeit in Diskettenmagazinen, PD-Serien, PD-CD's, 
Mailboxen usw. erscheinen.

Ausnahme bilden hierbei wieder kommerzielle Produkte, wo sich wieder bei
einer Beilage, vorher mindestens die Genehmigung des @{"Autor's" link "Address"} einzuholen
ist.

Es duerfen mit dieser Library keine Gewinne finanziellen Gewinne erzielt
werden, es darf bei Beilage dieser Library einzig und allein die Selbskosten,
was fuer Datentraeger und kopieren anfallen, erstattet werden.

Die Beschreibung der Library darf unter den Vorraussetzunge, dass sie
Sinngemaess und Unveraendert wiedergegeben wird, in ander Sprachen
uebersetzt und dem Paket beigefuegt werden.

Es duerfen auch andere lauffaehige Beispielprogramme, wenn sie frei
kopierbar sind, ebenfalls beigefuegt werden.
Dies sind die einzigen Aenderungen des Pakets, welche gestattet sind.

Fuer eventeulle Schaeden an Geraeten und Datentraegern uebernimmt der
Autor keinerlei Haftung oder Schadensersatzverpflichtungen.
Ebensowenig bei Datenverlusten oder dergleichen.

@EndNode

@Node Address "Adresse des Autors"

Fuer eventuelle Bugreporte, Verbesserungsvorschlaege oder aehnlich Harmlosen
kann der Autor dieser Libary unter dieser Adresse kontaktiert werden:

@{FG highlight}
		A.C.M. the Assembler-Magician
		Postfach 68
		A-9508  Villach
		AUSTRIA

Internet:	andreas.kobuaritsch@telecom.at
@{FG text}

Briefbomben, Drohbriefe oder sonstige Bosheiten werden vom Autor natuerlich
unfrei an den Absender zurueckgesandt ;-).

@EndNode

@Node KnownErrors "Bekannte Fehler der Library"

Niemand ist Perfekt und der Fehlerteufel schlaeft bekanntlich nicht:

Es kann zum Beispiel vorkommen, wenn die Routine @{"AllocVMem()" link "AllocVMem"} von mehreren
zu schnell hintereinander aufgerufen wird, das der Speicherbereich zwar
in der Eintragsverwaltung aufgenommen wurde, aber das File auf Diskette
nicht geschrieben worden ist.
(Passiert zum Beispiel, wenn man in einer Batchdatei 5 - 6 mal hintereinander
das gleiche Programm aufruft und dieses Programm sofort damit beginnt
sich virtuellen Speicher anzufordern ...)
Hierbei ist es bei mir schon vorgekommen, das von der Doslibrary einfach
'vergessen' wurde, ein solches File anzulegen.

@EndNode

@Node UnknownErrors "Unbekannte Fehler ??"

@{FG highlight}
keine, sonst wuerden sie ja auch nicht hier stehen :-)
@{FG text}

@EndNode

@Node Developers "Nur fuer Programmierer ..."

Diese Rubrik ist an all die jenigen gerichtet, welche sich ernsthaft damit
befassen, Programme zu schreiben, welche diese Library unterstuetzen wollen.

Zum ersten sei hier bitte angegeben, beim Aufruf der Library immer eine
Versionsnummer anzugeben, denn es folgen mit Sicherheit noch hoehere
Verionen dieser Library, um Inkompatibilitaetsprobleme von Haus aus aus
der Welt zu schaffen.

Die Librarybase bitte niemals direkt Beschreiben, dies wird alles von
der Library selbst erledigt.

Es wurde die Funktion @{"AvailVMem()" link "AvailVMem"} implementiert, welche nicht den freien
virtuellen Speicher anzeigt :-), sondern den bereits belegten.

Niemals ueber einen anderen Librarybasepointer Routinen aus der Library
anspringen.
Die Library erwartet die eigene Basisadresse immer im Register A6, da sie
selbst sehr viel in die Librarybase schreibt.

Bitte immer die @{"Errorcodes" link "Errors"} beachten.

Es ist damit theoretisch auch moeglich, sich sogar Programmcode auszulagern
und bei bedarf in wieder einzuholen.

Vorsicht bei Hochsprachen wie Basic, wenn man sich Speicher auslager will,
es koennte sein, dass sich wieder nach Aufruf von @{"ReadVMem()" link "ReadVMem"} das Speicher-
bild ploetzlich geaendert hat und es zu einem Guru kommt (dynamische 
Speicher-, oder Variablenverwaltung).

Es ist theoretisch sogar moeglich, sich seine eigenen ReadVMem()-Routinen
zu schreiben, welche unter umstaenden sogar schneller sind, Freigeben
solchen Speichers aber bitte immer ueber @{"FreeVMem()" link "FreeVMem"}.

Bei einer Freigabe von virtuellen Speicher wird nicht nur das File auf
dem Datentraeger geloescht und der Eintrag mit -1 als komplett geloescht
gekennzeichnet, es wird zusaetzlich auch der Pagecounter um 1 verringert.

Beim Anfordern von virtuellem Speicher wird als erstes geprueft, ob ueber-
haupt noch eine Page frei ist, danach wird aus der @{"Librarybase" link "Libbase"} der 
naechste freie Eintrag geholt. Der Speicher wird in der Eintragsliste mit
der Indexnummer versehen und es wird in der @{"Librarybase" link "Libbase"} und 'sb_OldIndex'
eingetragen. Danach wird der naechste freie Eintrag gesucht und in
sb_NIndex eingetragen wie die zugehoerige Adresse unter sb_NEntry.

Die Platznummer des Eintrages ist @{"FG highlight"}nicht@{"FG text"} gleich der
Indexnummer. Siehe dazu auch @{"SwapVMem()" link "SwapVMem"}.

Vielleicht findet oder hat jemand anders eine bessere Loesung bereit, um
Routinen vor vorlaeufigen Zugriff zu sperren und auf deren 'Freizeichen'
zu warten, dann bitte ich ihn, sie mir @{"mitzuteilen" link "Address"}.

Die Library selbst ist 100% in Assembler auf einem A1200 mit 2 Meg. Chip
4 Meg. Fastram, Blizzard 1220 Turbokarte, 68882 Coprozessor, 420 Meg.
Festplatte, zweiten Diskettenlaufwerk und einem CD-Laufwerk (Mitsumi)
geschrieben. Bei mir gab es bis jetzt keine besonderen Probleme ausser
die bereits @{"Beschriebenen" link "KnownError"}.

Diese Library sollte auch noch unter der Kickstart 1.2 funktionieren.

Vielleicht findet jemand einen kleinen Trick, wie man eventuell der
Doslibrary etwas auf die Spruenge helfen kann ...
Siehe dazu @{"Bekannte Fehler" link "KnownErrors"}.

@EndNode

@Node Programms "Programme, welche die Library unterstuetzen"

Bis jetzt noch sehr wenige (man siehe auch den Versionsstring ;-) ):

Aber dennoch hier eine kleine Liste:

@{B}Name@{UB}                                              @{B}Version@{UB}

BootMonitor                                       V 1.9
enthaltene Beispielprogramme                      V --
WinMemory                                         V 1.1

@EndNode
