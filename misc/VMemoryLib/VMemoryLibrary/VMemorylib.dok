                         
			********************************* 
			*                               *
			*  Virtual-Memory-Library V1.0  * 
			*                               *
			*********************************


		    (?) 1996 by A.C.M. the Assembler-Magician


	1. 	Beschreibung der Library
	2.	Installation der Library
	3.	Offset's der Library
	4.	Fehlermeldungen der Library
	5.	Die LibraryBase-Struktur
	6.	Die Eintragsstruktur
	7.	Die Pagefiles
	8.	Was ist virtueller Speicher
	9.	Wozu ist sie gut ...
	10.	Urheberrecht der Library
	11.	Kontaktadresse des Autor's
	12.	Bekannte ?? Fehler
        13.	Unbekannte Fehler
	14.	Nur fuer Programmierer ...
	15.	Programme, welche die Library unterstuetzen


1.	Beschreibung der Library

Die vmemory.library kann ueber jede Programmiersprache programmiert werden,
insofern Includes dafuer existieren.
Notfalls muss man sich selbst fuer seine eigene Programmiersprache Includes
erstellt werden.
In diesem Paket existieren Includes fuer Assembler (Maxon-Ass), C (Aztec) 
und Basic (FD).
Sie kann normal ueber OpenLibrary geoeffnet werden und gibt dabei, wie jede
andere Library auch, die Libbase im Register D0 zurueck.
Bei Nichterfolg des Oeffnens der Library wird eine 0 in D0 zurueckgegeben.
Beim ersten Aufruf der Library installiert sie sich, reserviert sich
12000 Bytes fuer Speichereintraege und 500 Bytes fuer die Filenamen.
Dass heisst, 250 Bytes sind fuer den normalen Filenamen verfuegbar und 250
Bytes fuer einen Filenamen, in welchen PageFiles umbenannt (rename) werden.

Diese Library benoetigt keine MMU (wird auch nicht unterstuetzt) und sollte
auch noch unter einem 68000er mit Kickstart 1.2 funktionieren.
(Wurde aber noch nicht ausgetestet ...)


2.	Installation der Library

Die Installation der Library ist denkbar einfach und bedarf dabei keinen
besonderen Vorkenntnissen ueber das Betriebssystem.
Die Library aus dem Libsverzeichnis ins eigene LIBS: kopieren.
Danach im Verzeichnis  ENV: und in ENVARC: eine Datei mit dem Namen 
vmemlib.prefs anlegen.

Dabei geht man am besten so vor:

Man oeffne sich seinen Texteditor nach Wahl.

Gibt dort den kompletten Pfad, wo spaeter die Pagefiles gespeichert
werden sollen, ein.
Z.B.: DH0:Pagefiles
Natuerlich muss dieser Pfad auch existent sein, ansonsten gibt es keinen
Virtuellen Speicher.

Speichert sich diese Texte unter den entsprechenden Namen und in den ent-
sprechenden Verzeichnissen ab.
Der Pfad  ENVARC:  speichert die Datei permanent.
Der Pfad  ENV:  speichert die Datei nur temporaer,
hat aber den Vorteil, dass die Library sofort genutzt werden kann.
Es ist natuerlich auch moeglich, in beiden Verzeichnissen zu schreiben.

Ist dies nun geschehen, steht der Benutzung vom virtuellen Speicher nichts 
mehr im Wege, es sei den, das benutzte Programm unterstuetzt diese Libary.

Aber nicht entaeuscht sein, wenn sich der Speicher jetzt nach dieser In-
stallation nicht sofort ins unendliche katapultiert, denn
diese Library macht  keinen  Systempatch der Offsets
der Exec-Library _LVOAllocMem(), _LVOFreeMem(), sondern nutzt dabei
seine eigenen Belegungsroutinen.

Die Library wird auch nicht in dieser Hinsicht vom Betriebssystem unter-
stuetzt, dass vielleicht sogar dieselben Routinen auch auf diese Libary
zugreifen koennten.

Wie gesagt, es gibt noch sehr wenige Programme, welche diese Library unter-
stuetzen, deshalb ist sie auch GIFTWARE.

Kleiner Tip am Rande: beim Pfad in der Datei vmemlib.prefs nicht unbedingt
                      'RAM:' angeben ... ;-)



3.	Die Einspruenge der Library

 	Funktionsname                	Offset (Dezimal) 

	_LVOAllocVMem       EQU         -30	
	_LVOFreeVMem        EQU         -36	 
	_LVOReadVMem        EQU         -42	 
	_LVOWriteVMem       EQU         -48
	_LVORenamePage      EQU         -54
	_LVOSwapVMem        EQU         -60
	_LVOAvailVMem       EQU         -66
	_LVOLBinHex         EQU         -72
	_LVOReadPath        EQU         -78



Virtuellen Speicher anfordern
-----------------------------

Name

	AllocVMem  - Belegt virtuellen Speicher

Synonyme

	Pagenummer = AllocVMem( Adresse, Groesse);
	LONG                    APTR     LONG
           D0                    A0        D0

	Pagenummer = Indexnummer, nach welcher der Speicherblock wieder
	             gefunden werden kann. (Unbedingt merken)

	Adresse	   = Adresse oder APTR des Speicherblocks, welcher aus-
	             gelagert werden soll.

	Groesse    = Groesse in Bytes des Speicherblocks, welcher ausge-
	             lagert werden soll.
	
Funktion

	Legt eine Auslagerungsdatei an, in welcher der angegebene Speicher-
	block geschrieben wird.

Parameterdaten

	Adresse - Adresse eines Speicherblocks
	Groesse - Groesse des Speicherblocks

Ergebnisse

	Pagenummer - ist die Kennung des Eintrages, unter welcher der 
	             Speicherblock abgelegt wurde. Unter dieser Nummer
                     kann dieser Speicherblock bearbeitet werden.
                     Dies ist eine sehr wichtige Nummer, wenn man den
	             ausgelagerten Speicherblock wieder einlesen will.
	             Diese Nummer kann aber auch einen Fehlercode ent-
	             halten, welcher aber immer kleiner als 0 ist.

Warnungen

	Bei Speichermedien, wie zum Beispiel Diskette, welche sich jeder-
	zeit auswechseln lassen, kann es passieren, wenn eine Pagedatei
        auf einer anderen Diskette liegt, nicht mehr eingelesen werden kann
	oder aber auch eine falsche Datei eingelesen werden kann.
	Bei Nichteinlesen gibt die Library eine Fehlermeldung zurueck, beim
	Einlesen einer falschen Datei, weil sie vielleicht auf einer anderen
	Diskette liegt, ist die Library machtlos und erkennt dabei auch
	keinen Fehler.
	Der Speicherblock, welcher ausgelager wurde, bleibt bei dieser
        Funktion unveraendert im Speicher stehen, d. h., er wird  nicht 
	geloescht.

Siehe auch

	FreeVMem, WriteVMem und Fehlercodes.



Virtuellen Speicher freigeben
-----------------------------

Name

	FreeVMem  - Gibt virtuellen Speicher wieder frei

Synonyme

	Fehlercode = FreeVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Frei-
	             geben aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
Funktion

	Loescht wieder eine Auslagerungsdatei und entfernt aus der den
	entsprechenden Eintrag mit der Nummer wieder aus der Eintrags-
	liste.


Parameterdaten

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     AllocVMemAllocVMem zurueckgegeben wurde.

Ergebnisse

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein FehlerErrors ist aufgetreten.

Warnungen

	Diese Funktion liest den Speicher bei ihrem Aufruf  nicht  wieder
        in die Originaladresse ein.
	Jedoch ist diese Funktion nicht so empfindlich, wie die der fast
        identischen Funktion in der Execlibrary, und gibt bei einem nicht
        auffinden des Speichers lediglich einen Errorcode zurueck.

Siehe auch

	AllocVMem, ReadVMem und Fehlercodes.



Virtuellen Speicher einlesen
----------------------------

Name

	ReadVMem  - liest virtuellen Speicher wieder ein

Synonyme

	Fehlercode = ReadVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Einlesen
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
Funktion

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	liest den Speicherblock wieder so ein, wie er zuletzt ausgelagert
	oder geschrieben wurde.


Parameterdaten

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     AllocVMemAllocVMem zurueckgegeben wurde.

Ergebnisse

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein FehlerErrors ist aufgetreten.

Warnungen

	Diese Funktion liest den Speicher bei ihrem Aufruf wieder an die
        Originaladresse, ab welcher ausgelagert wurde, ein.
	Bei einem Fehler, entsprechende Fehlernummer beachten.
	Es ist besonders sorgfaeltig dabei zu achten, dass bei dieser
	Funktion der Speicher veraendert wird !!
	Eventuell veraenderte Daten im Speicher gehen dabei mit Sicherheit 
	verloren.

Siehe auch

	WriteVMem, SwapVMem und Fehlercodes.



Virtuellen Speicher explizit auslagern
--------------------------------------

Name

	WriteVMem  - schreibt virtuellen Speicher explizit in die Datei

Synonyme

	Fehlercode = WriteVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Schreiben
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
Funktion

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	schreibt den Speicherblock so in die Datei, wie er vorliegt.


Parameterdaten

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     AllocVMemAllocVMem zurueckgegeben wurde.

Ergebnisse

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein FehlerErrors ist aufgetreten.

Warnungen

	Diese Funktion schreibt den Speicher bei ihrem Aufruf so in die
        Datei ein, wie er vorliegt.
	Dass heisst, es werden dabei eventuell bereits ausgelagerte Daten
	ueberschrieben.
	Bei einem Fehler, entsprechende Fehlernummer beachten.
	Es ist besonders sorgfaeltig dabei zu achten, dass bei dieser
	Funktion der Speicher veraendert wird !!
	Eventuell veraenderte Daten in der Datei gehen dabei mit Sicherheit 
	verloren.

Siehe auch

	ReadVMem, SwapVMem und FehlercodesErrors.



Umbenennen einer Indexnummer
----------------------------

Name

	RenamePage  - versucht einer Indexnummer einer anderen zuzuweisen

Synonyme

	Fehlercode = RenamePage(OldPagenumber,NewPagenumber);
	LONG                    LONG          LONG
           D0                         D0          D1

	Fehlercode    = Fehlernummer, welche bei Problemen mit dem Umbenennen
	                aufgetreten sind.

	OldPagenumber = Indexnummer, nach welcher ein Speicherblock ausge-
	                lagert wurde.

	NewPagenumber = Neue Indexnummer, nach welcher ein Speicherblock nun
	                benannt werden soll.
	
Funktion

	Versucht eine Indexnummer in eine andere umzubenennen, wobei (nur
	bei Erfolg) der alte Eintrag wieder freigeben wird und der Neue
	Eintrag belegt wird.


Parameterdaten

	OldPagenumber - ist die Kennung des Speichers, unter welcher er ab-
	                gelegt wurde.
                        Dieser Wert ist identisch mit dem Wert, welcher von
                        AllocVMemAllocVMem zurueckgegeben wurde.

	NewPagenumber - ist ein neuer, eventuell freier Wert, welcher nun
	                dem Speicherblock zugewiesen werden soll.

Ergebnisse

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein FehlerErrors ist aufgetreten.

Warnungen

	Diese Funktion versucht die OldPagenumber auf die NewPagenumber zu
	transferieren und gibt danach wieder die OldPagenummer frei.
	Dabei wird aber auch das File auf dem Speichermedium umbenannt.

Siehe auch

	SwapVMem und Fehlercodes.


Virtuellen Speicher austauschen
-------------------------------

Name

	SwapVMem  - tauscht virtuellen Speicher mit normalem Speicher aus

Synonyme

	Fehlercode = SwapVMem(Pagenummer);
	LONG                  LONG
           D0                     D0

	Fehlercode = Fehlernummer, welche bei Problemen mit dem Tauschen
	             aufgetreten sind.

	Pagenummer = Indexnummer, nach welcher der Speicherblock ausge-
	             lagert wurde.

	
Funktion

	Sucht sich in der Eintragsliste den entsprechenden Eintrag und
	tauscht den Speicherblock, mit den Daten aus der Datei.
	Das heisst, es erfolgt ein Platztausch, bei welchem  keine  Daten
	verloren gehen (sollten/duerfen/muessen).

Parameterdaten

	Pagenummer - ist die Kennung des Speichers, unter welcher er ab-
	             gelegt wurde.
                     Dieser Wert ist identisch mit dem Wert, welcher von
                     AllocVMemAllocVMem zurueckgegeben wurde.

Ergebnisse

	Fehlercode - ist die Fehlernummer, welche zurueckgegeben wird,
                     wenn Fehler aufgetreten sind.
		     =0  = alles ist glatt verlaufen.
	             >0  = ein FehlerErrors ist aufgetreten.

Warnungen

	Diese Funktion tauscht den Speicher mit den Daten aus der Datei
	ohne Datenverlust aus.
	Das heisst, was vorher auf dem Speichermedium stand ist danach im
	Speicher verfuegbar und was vorher im Speicher verfuegbar war, ist
	jetzt auf dem Speichermedium geschrieben worden.
	Dabei wird auch kein UmbenennenRenamePage vorgenommen.


Siehe auch

	ReadVMem, WriteVMem, RenamePage und Fehlercodes.


Auslesen von belegtem virtuellen Speicher
-----------------------------------------

Name

	AvailVMem  - zeigt virtuellen  belegten  Speicher an

Synonyme

	Nummer = AvailVMem();
	LONG
           D0                    

	Nummer = Zahl, wieviel virtueller Speicher bereits angelegt wurde.

	
Funktion

	Sucht sich alle Eintraege heraus und prueft, ob sich dort ein
	gueltiger Wert befindet.

Parameterdaten


Ergebnisse

	Nummer - Groesse des belegten virtuellen Speichers, welcher be-
	         reits angelegt wurde.

Warnungen

	Diese Funktion zeigt  nur  den wirklich belegten virtuellen Speicher 
	und nicht etwa andere Speicherbelegungen an.

Siehe auch

	AllocVMem und FreeVMem.


Umrechnen binaerer Zahlen in HEX-ASCII
--------------------------------------

Name

	LBinHex  - rechnet eine binaere Zahl in ASCII um.

Synonyme

	LBinHex(Speicher, Zahl);
	        APTR      LONG
                 A0        D0                    

	Speicher = freier Speicherbereich, min. 8 Bytes, ab welchem die
                   umgerechnete Hex-Zahl als ASCII-String abgelegt wird.

	Zahl     = binaere Zahl, welche in einen HexString umgerechnet
                   werden soll.

	
Funktion

	Diese Funktion berechnet aus einer binaeren Zahl das entsprechende
	Gegenstueck in ASCII.

Parameterdaten

	Speicher = Adresse oder APTR auf einen freien Speicherbereich

	Zahl     = die binaere Zahl, welche umgerechnet werden soll.

Ergebnisse

	Als Ergebnis steht nach Aufruf dieser Funktion die binaere Zahl
	als ASCII-HEX-String im angegebenen Speicher.

Warnungen

	Diese Funktion ist (nur) in der Lage, Longwoerter umzurechnen,
	d. h., es sind 8 Hexstellen (Bytes) von noeten.
	Es wird dabei  keine Nullunterdrueckung  im String vorgenommen.
	Eventuell falsch angegebener Speicher wird dabei gnadenlos ueber-
	schrieben, was eventuell unerwuenschte und mehr oder weniger
	schoene Effekte zur Folge haben kann (Guru).

Siehe auch

	AvailVMem.


Einlesen des Pagepfades
-----------------------

Name

	ReadPath  - liest den Pagepfad ein.

Synonyme

	ReadPath();                    

	
Funktion

	Diese Funktion liest aus der Librarybase den Pagepfad ein,
	wo die entsprechenden Pagefiles zu finden sind.
	Inhalt ist identisch mit dem Inhalt aus ENV:vmemlib.prefs.

Parameterdaten


Ergebnisse

	Als Ergebnis laesst sich der Pagepfad ueber die Libbase mit dem
	Eintrag sb_PagePath(a6) als String auslesen.

Warnungen


Siehe auch



4.	Fehlercodes der Libary


     	Wert        	       Kurzbeschreibung

    	  0L          =        Alles Ok
	 -1L          =        Tabelle voll
	 -2L          =        Kein Prefsfile
	 -3L          =        Kein Startspeicher
         -4L          =        Dateioeffnungsfehler
         -5L          =        Fehler beim Schreiben
         -6L          =        Keinen leeren Eintrag gefunden
         -7L          =        Keinen Eintrag geleert
         -8L          =        Fehler beim Lesen
         -9L          =        Eintrag nicht gefunden
        -10L          =        Eintrag bereits belegt



Kein Fehler (No Error)
----------------------

Alles Ok, eigentlich kein Fehler, kann aber ebenfalls zurueckgegeben werden.
Ausser bei AllocVMem ist es mit Sicherheit eine Pagenummer.



Eintragstabelle voll (TableFull)
--------------------------------

Dieser Fehler wird wahrscheinlich so gut wie nie auftreten, aber was weiss
man den schon ..
Soweit, sogut, sollte er aber dennoch auftreten, so bedeutet es nur, dass
momentan alle Eintraege belegt sind und derzeit keine Virtuelle Page an-
gelegt werden kann.

Um zu erklaeren, wie dieser Fehler auftreten kann, muss ich etwas weiter
ausholen:

Beim Anlegen einer Library im Speicher vom Betriebssystem, wird beim ersten
Mal immer besondere Vorbereitungen fuer die Libary vorgenommen, welche
bei einem zweiten Oeffnen nicht noetig sind.
So ist es auch bei dieser Library der Fall, dazu gehoert unter anderem,
dass sich die Library 12000 Bytes Speicher reserviert, worin die einzelnen
Eintraege geschrieben und verwaltet werden.
Diese Library ist in der Version 1.0 in der Lage davon exakt 1000 Pages
(Seiten) anzulegen und zu verwalten, kann aber dieser Speicher nicht
angelegt werden, so tritt dieser Fehler auf.
Naeheres dazu siehe auch Eintraege.


 
Kein Preferencefile vorhanden (NoPefs)
--------------------------------------

Tritt dieser Fehler auf, so wurde die Library wahrscheinlich falsch oder
gar nicht vom User installiert.
Abhilfe schafft hierbei das Anlegen eines solchen Prefsfiles,
siehe dazu auch die Installation der LibraryInstall.



Keinen Eintragsspeicher erhalten (NoStartMem)
---------------------------------------------

Hierbei ist schon beim ersten Einladen der Libary vom Betriebssystem etwas
schiefgegangen und bedeutet lediglich, dass kein Speicher fuer die Ver-
waltung der Eintraege erhalten wurde.

Siehe dazu auch Eintraege und Eintragstabelle voll.



Fehler beim Oeffnen des Pagefiles (NoFileOpen)
----------------------------------------------

Bei diesem Fehler gab es Probleme beim Oeffnen des Pagefiles, welche die
Daten enthaelt seitens der Dos.library.
Auftreten kann dieser Fehler, wenn das Pagefile von aussen (anderen Pro-
grammen) geloescht wurde, dass File gar nicht auf dem Datentraeger
existiert oder aber vielleicht sogar ein Schreib-LeseFehler in der Datei ...
Siehe dazu auch Bekannte Fehler.



Fehler beim Schreiben in Pagefile (FailWrite)
---------------------------------------------

Hierbei konnte das Pagefile sehr wohl geoeffnet werden, es traten aber
Fehler beim Schreiben der Datei auf.
Es kann eventuell daran liegen, dass der Datentraeger bereits voll ist
oder die Datei beschaedigt ist.



Keinen leerer Eintrag mehr vorhanden (NoEmptyEntry)
---------------------------------------------------

tritt auf, wenn zum Beispiel bei SwapVMem der Eintrag
sehr wohl existiert, aber kein Ausweicheintrag mehr zum Tauschen vor-
handen ist.
D. h., das Tauschen von Speicherbereichen geht wie folgt vor sich:

Es wird zuerst versucht einen neuen leeren Eintrag zu finden (FEHLER).

Danach wird erst der neue Speicherbereich ausgelagert und in Eintragstabelle
aufgenommen.

Dann liest die Library den alten Speicherbereich wieder ein.

Und wenn bis dahin alles glatt ging, wird der alte Speicherblock vom
Datentraeger geloescht und in der Eintragstabelle als frei gekennzeichnet.

Zu guter Letzt bekommt dann der neue Eintrag noch den Namen des alten, wie
auch die ausgelagerte Datei.

Siehe dazu auch die Eintraege und die Pagefiles.



Keinen Eintrag leeren (freigeben) koennen (NoEntryFreed)
--------------------------------------------------------

Dieser Fehler tritt eigentlich nie auf.

Sollte es aber dennoch in zukuenftigen Versionen der Fall sein, so be-
deutet dies, dass es hier unmoeglich war, einen Eintrag wieder freizugeben.



Fehler beim Lesen des Pagefiles (FailRead)
------------------------------------------

Dieser Fehlercode ist das aequivalente Gegenstueck zu FailWrite und zeigt an,
dass beim Lesen eines Pagefiles Probleme auftraten.

Ursachen hierfuer koennen sein:

Das Pagefile ist beschaedigt oder es konnte schon nicht richtig geschrieben
werden ...



Keinen (solchen) Eintrag gefunden (NoEntryFound)
----------------------------------------------

Bedeutet, dass ein Eintrag mit der angegebenen Indexnummer nicht in der
Verwaltung der Eintraege existiert und daher auch nicht gefunden werden
konnte.

Ursachen dazu koennen sein, dass der Eintrag nie angelegt worden ist oder
er eventuell (irrtuemlich) von einem anderen Programm bereits freigegeben
worden ist.

Normalerweise sollte es nicht passieren, dass zum Beispiel von der Library
der gleiche Eintrag zweimal vergeben wird, aber was weiss der (Fehler)Teufel
denn schon.



Eintrag wurde bereits vergeben (EntryOccupied)
----------------------------------------------

Hier wurde zum Beispiel versucht, einen Eintrag in einen Namen umzubenennen,
welcher bereits besetzt ist.
Im Klartext heisst dies, dass ein solches Pagefile bereits existiert und
daher nicht ueberschrieben werden kann oder darf.
Dieser Fehler tritt eigentlich nur bei den Routinen RenamePage auf.
Diese Routine wird unter anderem auch von SwapVMem benutzt.



5.	Die Librarybase-Struktur"

Die Librarybase-Struktur besteht derzeit aus 13 Eintraegen, welche ev.
mehr oder weniger interessante Informationen bietet.

Name       Groesse   Typ        Inhalt

sb_SysLib    1       APTR       Zeiger auf die Execbasestruktur
sb_DosLib    1       APTR       Zeiger auf die Dosbasestruktur
sb_TBase     1       APTR       Zeiger auf den Eintragsverwaltungsspeicher
sb_TCount    1       ULONG      aktuelle Anzahl angelegter Pages
sb_NEntry    1       APTR       Zeiger auf naechsten freien Eintrag
sb_NIndex    1       ULONG      Nummer des naechsten leeren Indexes
sb_OldIndex  1       ULONG      Nummer der letzten angelegten Page
sb_PagePath  1       APTR       Zeiger auf den vollen Pfadnamen + File
sb_RenPath   1       APTR       Zeiger auf den vollen RenamePfad + File
sb_Pagename  1       APTR       Zeiger auf den Namen des Prefs-Files
sb_SegList   1       ULONG      Nummer in der Segmentsliste*
sb_Flags     1       UBYTE      Flaggenbits fuer Besetztung v. Routinen
sb_pad       1       UBYTE      ???*


*
Zu diesen Routinen kann ich leider nur sehr wenig sagen, da sie unbedingt
notwendig sind und eigentlich nur zur Verwaltung der Library fuer die
Execlibrary benoetigt werden.
Veraendern dieser Werte bitte nur, wenn man weiss, was man tut.

In Wahrheit duerfen die anderen Eintraege ebenfalls nur gelesen werden, aber
nie beschrieben.
Sonst haette dies eventuell fatale Folgen fuer die Library und der Aus-
fuehrung der Routinen selbst.
Es kann dann unter Umstaenden sogar Datenverlust mit sich bringen und im
schlimmsten Fall sogar eine Zerstoerung des Speichermediums, aber nicht des
Geraetes, worin sich das Medium befand.
Bei meinen Testphasen wurde ich dadurch sogar schon mal von der Festplatte
mit einem Validierungsvorgang von 20 Minuten belohnt.



6.	Die Eintragsstruktur des Virtuellen Speichers

Die Eintragsstruktur der Library, welche eingentlich das Kernstueck der
Verwaltung von virtuellen Speichers darstellt, ist in Wirklichkeit sehr
einfach bis ausreichend gehalten.

Ein socher Eintrag besteht nur aus 12 Bytes, welche in 3 Longwort unter-
teilt worden sind:

Name   Bytes   Typ       Beschreibung

INDEX     4    ULONG     Name der Page, wert welcher von AllocVMem zurueck
                         gegeben wird.

SIZE      4    ULONG     Groesse des Speicherblocks, welcher auf das
                         Speichermedium kopiert wurde.

ADRESS    4    APTR      Zeiger auf das erste Byte des Speicherbereichs,
                         welcher kopiert wurde.

Durch dieses Wissen laesst sich auch schnell erklaeren, warum die Library
eigentlich (nur) 1000 Pages verwalten kann.
Der Speicherbereich, welcher auch StartMemory genannt wird, siehe dazu auch
FehlercodeErrors, misst exakt 12000 Bytes.
Dass heisst 12000 Bytes / 12 Bytes = 1000 Eintraege.
Nachdem 1 Eintrag 12 Bytes misst und dies multipliziert mit 1000 = 12000
Bytes StartMemory.

Erkannt und gesucht werden diese Eintraege nur an ihrer Indexnummer, was
auch ein kleines, schnelles und relativ unkompliziertes Verwalten der
Pages ermoeglicht.
Dies ist auch der Grund, warum die Routinen SwapVMem(), ReadVMem(), 
WriteVMem() und FreeVMem() als Argument nur mehr noch die Pagenummer
zum Arbeiten benoetigen.



7.	Beschreibung des ausgelagerten Speichers

Die Pagefiles beinhalten ausser den Daten, welche der ausgelagerte Speicher
enthalten hat, nichts.
Die Groesse dieser Pagefiles hangen nur davon ab, welche Groesse bei der
Routine AllocVMem() angegeben wurde.
Weiteres ist, diese Pagefiles enthalten auch  keine  Angaben ueber den Index,
Adresse oder sonst irgendwelche Daten.
Der Speicher wird nur ueber die EintraegeEntries verwaltet, d. h., ist ein solcher
Eintrag einmal versehentlich geloescht worden, so ist auch das zugehoerige
Pagefile verloren und liegt sinnlos auf dem Speichermedium.
In meinen Testphasen ist es mir bis jetzt noch nie passiert, dass ein
solches Pagefile von der Library versehentlich geloescht wurde.
Mit Vorsicht zu geniesen ist es, wenn zum Beispiel Variablen in Hochsprachen
wie Basic oder dergleichen, welche ihre Variablen dynamisch verwalten,
auszulagern. Dabei kann es durchaus passieren, dass hier falscher Speicher
beim Einlesen ueberschrieben wird, was aber kein Bug der Library selbst ist.
Ziemlich ohne Bedenken kann man z. B. Graphikdaten oder Speicher, welcher
vorher vom Betriebssystem sicher als belegt deklariert wurde, auslagern.


 
8.	Was ist virtueller Speicher ?

Der Virtuelle Speicher ist der Schwachpunkt des Amiga-Betriebssystem und
es ist sehr schade, dass er nicht unterstuetzt wird.
(Zumindest trifft dies bei Konfigurationen ohne MMU zu >:-( )

Virtueller Speicher ist ein Speicherbereich, welcher eigentlich fuer
den Computer nicht existent ist, aber dennoch mit Hilfsmitteln wie
einer MMU (Memory Managment Unit = Speicher Verwaltungs Einheit) zur
Verfuegung gestellt werden kann.
Dieser Speicherbereich wird nicht selten zum Beispiel auf einer Festplatte
in Form von Dateien geschrieben und bei bedarf, dass heisst, wenn er
angesprochen wird, wieder in einen zugaenglichen Speicherbereich geladen
und die Aufrufe von der MMU auf diesen neuen Speicherbereich umgelenkt.

Es funktioniert ueber die MMU auf diese Weise, dass hierbei Speicherbereich
angelegt wird, welcher ausserhalb des Adressbereichs des Prozessors liegt.
Nun hat der Prozessor die Eigenschaft, wenn der auf ein solches Befehlswort
trifft, er beim vorhandensein einer solchen MMU, dieses Befehlswort auch
diesem besonderen Baustein uebergibt.
Bei nichtexistieren einer solchen, wuerde sich der Amiga in so einem Fall
ins Nirvana verabschieden was eine Meditation zur Folge hat ...
 
Die VMemorylibrary benoetigt zur Arbeit  keine  solche MMU.
Dies ist auch der Grund, warum man bei der Programmierung der Library sehr
sorgfaeltig umgehen muss.

Diese Library kann natuerlich keine Aufrufe in illegalem Speicherbereich
abfangen und eventuell den Prozessor umlenken auf neuen Speicherbereich.
(Sollte es aber vielleicht doch einen Weg ohne MMU und nur mit dem reinen
Prozessor geben, so koenntet ihr mir doch eventuell schreiben ;-) )

Sehr wohl ist diese Library aber in der Lage, Speicher (kurzzeitig) auf
ein Speichermedium auszulagern, worauf dieser neu gewonnene Speicher
mehr oder weniger gefahrlos Veraendert werden darf.
Sollten die Veraenderungen wieder rueckgaengig gemacht werden, so holt
man sich einfach den Speicher wieder mittels SwapVMem() o. ReadVMem.

Es waere damit zum Beispiel auch moeglich, sehr grosse Dateien, welch nicht
in einem Stueck in den Speicher passen wuerden, in kleinere Teile (Pages)
zerteilen und dennoch einlesen (z.b.: Adressdaten).

Oder ein anderes Anwendungsbeispiel waere zum Beispiel ein File-Zapper,
welcher mit dieser Library in der Lage ist, auch Dateien zu Zappen, welche
zum Beispiel 5 Megabyte gross sind, der vorhandene Speicher aber nur
2 Megabyte misst.

Ich bin mir dessen Sicher, dass es genug Programmierer geben wird, welche
auch die ausgefallensten Ideen dafuer aufbringen und umsetzen.



9.	Wozu ist sie gut ...

Eine berechtigte Frage, welche ich auch hier beantworten moechte.

Diese Library sollte erstens dazu dienen, um zu demonstrieren, dass es
auch moeglich ist 'vituellen Speicher' ohne MMU anzulegen und zu verwalten.

Zweitens sollte sie auch eine alternative fuer Programmierer darstellen,
um auch Systeme mit nicht so viel Speicher (100 MB Hauptspeicher ;-) ) zu
unterstuetzen.

Drittens sollte sie eine (Speicher)Luecke des Betriebssystems fuellen.

Viertens appeliert der Programmierer der Library an andere Programmierer
sie auch, wenn moeglich zu unterstuetzen.

Fuenftens hofft der Programmierer der Library auch auf andere Programmierer,
dass sie diese (besondere) Library unterstuetzen.



10.	Urheberrecht der Library (Copyrights)

Diese Rechte gelten vorerst fuer die Version 1.0 der Library, Aenderungen
in spaeteren Versionen werden vorbehalten.

Das heisst vorerst:

Diese Library CATWARE und nicht PD !!!
Das heisst bei Gefallen und Nutzung der Library erwartet der Programmierer
eine kleine Anerkennung, frei nach dem Motto: Alles fuer die Katz'.
Schickt dem ProgrammiererAddress irgendetwas an Zubehoer, was man als 
Katzenbesitzer brauchen koennte.
Dies waeren zum Beispiel: Flohbaender, Katzenstreu, Amigas :-), Katzen-
spielzeug usw.
Bitte schickt es mir mit der Registrierungskarte, welche bitte ausgedruckt
werden muss.
Die Registrierung selbst, geschieht unter voelliger Diskretion und deren
Daten unterliegen natuerlich dem Datenschutz und ist bei Zusendung mit
dem Utensiel fuer die Katz' kostenlos.
Nehmt diesen Aufruf mit der CATWARE ohne weiteres Woertlich ...

Die Urheberrechte dieser Library liegen beim Programmierer, dass heisst, 
die Library darf frei nach belieben genutzt werden.

Jedoch ist dabei etwas zu beachten:

Das Archiv darf nur vollstaendig und die Library darf nur unveraendert
weitergegeben werden.

Sie darf jederzeit von fremden Programmen aufgerufen und genutzt werden.

Ausnahmen bilden hierbei kommerzielle Produkte, welche bei einer Nutzung
mindestens die Kontaktaufnahme des Autors beduerfen.

Das Paket darf jederzeit in Diskettenmagazinen, PD-Serien, PD-CD's, 
Mailboxen usw. erscheinen.

Ausnahme bilden hierbei wieder kommerzielle Produkte, wo sich wieder bei
einer Beilage, vorher mindestens die Genehmigung des Autor's einzuholen
ist.

Es duerfen mit dieser Library keine finanziellen Gewinne erzielt
werden, es darf bei Beilage dieser Library einzig und allein die Selbskosten,
was fuer Datentraeger und kopieren anfallen, erstattet werden.

Die Beschreibung der Library darf unter den Vorraussetzunge, dass sie
Sinngemaess und Unveraendert wiedergegeben wird, in anderen Sprachen
uebersetzt und dem Paket beigefuegt werden.

Es duerfen auch andere lauffaehige Beispielprogramme, wenn sie frei
kopierbar sind, ebenfalls beigefuegt werden.
Dies sind die einzigen Aenderungen des Pakets, welche gestattet sind.

Fuer eventeulle Schaeden an Geraeten und Datentraegern uebernimmt der
Autor keinerlei Haftung oder Schadensersatzverpflichtungen.
Ebensowenig bei Datenverlusten oder dergleichen.



11.	Adresse des Autors

Fuer eventuelle Bugreporte, Verbesserungsvorschlaege oder aehnlich Harmlosen
kann der Autor dieser Libary unter dieser Adresse kontaktiert werden:

 
		A.C.M. the Assembler-Magician
		Postfach 68
		A-9508  Villach
		AUSTRIA

Internet:	andreas.kobuaritsch@telecom.at 

Briefbomben, Drohbriefe oder sonstige Bosheiten werden vom Autor natuerlich
unfrei an den Absender zurueckgesandt ;-).



12.	Bekannte Fehler der Library

Niemand ist Perfekt und der Fehlerteufel schlaeft bekanntlich nicht:

Es kann zum Beispiel vorkommen, wenn die Routine AllocVMem()
zu schnell hintereinander aufgerufen wird, das der Speicherbereich zwar
in der Eintragsverwaltung aufgenommen wurde, aber das File auf Diskette
nicht geschrieben worden ist.
(Passiert zum Beispiel, wenn man in einer Batchdatei 5 - 6 mal hintereinander
das gleiche Programm aufruft und dieses Programm sofort damit beginnt
sich virtuellen Speicher anzufordern ...)
Hierbei ist es bei mir schon vorgekommen, das von der Doslibrary einfach
'vergessen' wurde, ein solches File anzulegen.



13.	Unbekannte Fehler ??

 
keine, sonst wuerden sie ja auch nicht hier stehen :-)
 



14.	Nur fuer Programmierer ...

Diese Rubrik ist an all die jenigen gerichtet, welche sich ernsthaft damit
befassen, Programme zu schreiben, welche diese Library unterstuetzen wollen.

Zum ersten sei hier bitte angegeben, beim Aufruf der Library immer eine
Versionsnummer anzugeben, denn es folgen mit Sicherheit noch hoehere
Verionen dieser Library, um Inkompatibilitaetsprobleme von Haus aus aus
der Welt zu schaffen.

Die Librarybase bitte niemals direkt Beschreiben, dies wird alles von
der Library selbst erledigt.

Es wurde die Funktion AvailVMem() implementiert, welche nicht den freien
virtuellen Speicher anzeigt :-), sondern den bereits belegten.

Niemals ueber einen anderen Librarybasepointer Routinen aus der Library
anspringen.
Die Library erwartet die eigene Basisadresse immer im Register A6, da sie
selbst sehr viel in die Librarybase schreibt.

Bitte immer die Errorcodes beachten.

Es ist damit theoretisch auch moeglich, sich sogar Programmcode auszulagern
und bei bedarf in wieder einzuholen.

Vorsicht bei Hochsprachen wie Basic, wenn man sich Speicher auslager will,
es koennte sein, dass sich wieder nach Aufruf von ReadVMem() das Speicher-
bild ploetzlich geaendert hat und es zu einem Guru kommt (dynamische 
Speicher-, oder Variablenverwaltung).

Es ist theoretisch sogar moeglich, sich seine eigenen ReadVMem()-Routinen
zu schreiben, welche unter umstaenden sogar schneller sind, Freigeben
solchen Speichers aber bitte immer ueber FreeVMem().

Bei einer Freigabe von virtuellen Speicher wird nicht nur das File auf
dem Datentraeger geloescht und der Eintrag mit -1 als komplett geloescht
gekennzeichnet, es wird zusaetzlich auch der Pagecounter um 1 verringert.

Beim Anfordern von virtuellem Speicher wird als erstes geprueft, ob ueber-
haupt noch eine Page frei ist, danach wird aus der Librarybase der 
naechste freie Eintrag geholt. Der Speicher wird in der Eintragsliste mit
der Indexnummer versehen und es wird in der Librarybase und 'sb_OldIndex'
eingetragen. Danach wird der naechste freie Eintrag gesucht und in
sb_NIndex eingetragen wie die zugehoerige Adresse unter sb_NEntry.

Die Platznummer des Eintrages ist nicht gleich der Indexnummer. 
Siehe dazu auch SwapVMem().

Vielleicht findet oder hat jemand anders eine bessere Loesung bereit, um
Routinen vor vorlaeufigen Zugriff zu sperren und auf deren 'Freizeichen'
zu warten, dann bitte ich ihn, sie mir mitzuteilen.

Die Library selbst ist 100% in Assembler auf einem A1200 mit 2 Meg. Chip
4 Meg. Fastram, Blizzard 1220 Turbokarte, 68882 Coprozessor, 420 Meg.
Festplatte, zweiten Diskettenlaufwerk und einem CD-Laufwerk (Mitsumi)
geschrieben. Bei mir gab es bis jetzt keine besonderen Probleme ausser
die bereits beschriebenen.

Diese Library sollte auch noch unter der Kickstart 1.2 funktionieren.

Vielleicht findet jemand einen kleinen Trick, wie man eventuell der
Doslibrary etwas auf die Spruenge helfen kann ...
Siehe dazu Bekannte Fehler.



15.	Programme, welche die Library unterstuetzen

Bis jetzt noch sehr wenige (man siehe auch den Versionsstring ;-) ):

Aber dennoch hier eine kleine Liste:

Name                                              Version

BootMonitor                                       V 1.9
enthaltene Beispielprogramme                      V --
WinMemory                                         V 1.1


