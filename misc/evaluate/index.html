<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="author" content="Stuart Caie">
<title>Kyzer -&gt; Coding -&gt; Evaluate</title>
</head>
<body bgcolor="#ffffff" text="#000000">

<h1>evaluate - evaluate algebraic strings</h1>

<ul>
<li><a href="evaluate.c">download <tt>evaluate.c</tt></a>
<li><a href="evaluate.h">download <tt>evaluate.h</tt></a>
<li><a href="eval.c">download <tt>eval.c</tt> example</a>
</ul>

<h2>Overview</h2>

<tt>evaluate.c</tt> is a piece of documented example code showing an
interesting and quick algorithim for evaluating algebraic strings, such as
<tt>"2 + 4"</tt> and <tt>"a=5; b=10; c=b-a; b*c"</tt>. It is released under
the GNU General Public License version 2 or later.

<h2>Purpose</h2>

Mainly so I can write a new <tt>calculus.library</tt> for the Amiga, but
to be honest, I'd like programmers who write evaluators to take a look at
it and maybe learn something. I've used many evaluators, and often there
are terrible mistakes. My pet peeves are:

<ul>
<li>Using a full regexp scanner and LALR parser!
<li>No operator precedence!
<li>Only evaluating with integer arithmetic.
<li>Having fixed number of variables or fixed variable name lengths.
<li>Having some arbitrary limit on the evaluation depth or number of tokens.
</ul>


<h2>Usage</h2>
Call this function: <tt>int evaluate(char *expr, struct val *result, struct vartable *vartable);</tt>

Its arguments are:
<ul>

<li><tt>expr</tt> is string representing an expression to evaluate, for
example <tt>"1+a"</tt> or <tt>"pi/2"</tt>.

<li><tt>result</tt> is a pointer to a structure that will contain the
result of the evaluation - it contains both real and integer values, and a
'type' flag to say which one contains the actual value. The structure must
exist in advance - for example, you could declare <tt>struct val
result;</tt> in the variables of your program then use <tt>&result</tt> as
the parameter.


<li><tt>vartable</tt> can be <tt>NULL</tt> - if so, <tt>evaluate</tt> uses
its own private variable table, but if not then this should be a pointer to
a variable table as created with <tt>create_vartable()</tt> and freed with
<tt>free_vartable()</tt>. The table itself can be edited with
<tt>get_var()</tt> and <tt>put_var()</tt>

<li>The value returned by <tt>evaluate</tt> is an error code of some sort,
or <tt>RESULT_OK</tt> to indicate that everything went well.

</ul>

<a href="workings.html"><h2>Read about how the code works!</h2></a>

To compile the example <tt>eval.c</tt>, try one of these:

<ul>
<li><tt>gcc -o eval eval.c evaluate.c -lm</tt>
<li><tt>cc -o eval eval.c evaluate.c -lm</tt>
<li><tt>vc -o eval eval.c evaluate.c -lmieee</tt>
<li><tt>vc -sc -cpu=68020 -fpu=68881 -o eval eval.c evaluate.c -lm881</tt>
</ul>


<h2>Expressions</h2>

In the demo program you can type in expressions and press return to have
them evaluated. The rules regarding expressions are as follows:

<br><br>

You can follow any expression with a semicolon and another expression. The
expression is a mixture of values, variables and operators, in infix
notation. You can use parentheses (round brackets) to force a particular
order. The operators are as follows:

<table cellpadding=8>
<tr><td align=center><tt>+</tt></td><td>addition</td><td align=center><tt>&lt;&lt;</tt></td><td>bitwise shift left</td></tr>
<tr><td align=center><tt>-</tt></td><td>subtraction (or negation)</td><td align=center><tt>&gt;&gt;</tt></td><td>bitwise shift right</td></tr>
<tr><td align=center><tt>*</tt></td><td>multiplication</td><td align=center><tt>&amp;&amp;</tt></td><td>logical and</td></tr>
<tr><td align=center><tt>/</tt></td><td>division</td><td align=center><tt>||</tt></td><td>logical or</td></tr>
<tr><td align=center><tt>**</tt></td><td>raise to the power</td><td align=center><tt>!</tt></td><td>logical not</td></tr>
<tr><td align=center><tt>%</tt></td><td>modulus</td><td align=center><tt>==</tt></td><td>equality test</td></tr>
<tr><td align=center><tt>=</tt></td><td>assignment</td><td align=center><tt>!=</tt></td><td>inequality test</td></tr>
<tr><td align=center><tt>&amp;</tt></td><td>bitwise AND</td><td align=center><tt>&lt;</tt></td><td>less than test</td></tr>
<tr><td align=center><tt>|</tt></td><td>bitwise OR</td><td align=center><tt>&gt;</tt></td><td> greater than test</td></tr>
<tr><td align=center><tt>~</tt></td><td>bitwise NOT</td><td align=center><tt>&lt;=</tt></td><td>less than or equal to test</td></tr>
<tr><td align=center><tt>^</tt></td><td>bitwise XOR</td><td align=center><tt>&gt;=</tt></td><td>greater than or equal to test</td></tr>
</table>

<br><br>

The precedence of the operators is as follows, from highest (most tightly
binding) to lowest:
<ul>
<li>implicit multiplication
<li><tt>!</tt>, <tt>~</tt>, unary <tt>-</tt>
<li><tt>**</tt>
<li><tt>*</tt>, <tt>/</tt>, <tt>%</tt>
<li><tt>+</tt>, <tt>-</tt>
<li><tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>
<li><tt>&lt;</tt>, <tt>&gt;</tt>, <tt>&lt;=</tt>, <tt>&gt;=</tt>
<li><tt>==</tt>, <tt>!=</tt>
<li><tt>&amp;</tt>, 
<li><tt>|</tt>, <tt>^</tt>
<li><tt>&amp;&amp;</tt>, <tt>||</tt>
<li><tt>=</tt>
<li>functions
</ul>

<br><br>

The available functions are <tt>acos</tt>, <tt>asin</tt>, <tt>atan</tt>,
<tt>cos</tt>, <tt>cosh</tt>, <tt>exp</tt>, <tt>ln</tt>, <tt>log</tt>,
<tt>sin</tt>, <tt>sinh</tt>, <tt>sqr</tt>, <tt>sqrt</tt>, <tt>tan</tt> and
<tt>tanh</tt>. All functions take one argument. You do not need to have
parentheses round the argument.

<br><br>

Any text other than function is considered to be a variable reference.
All variables have to be assigned before use (for example, <tt>"a=5;
b=a-3; a+b"</tt>), or set as operating system environment variables.

<br><br>

The behaviour of operators and functions, and the accuracy of results
is entirely down to the C compiler which compiles <tt>evaluate.c</tt>.

<hr><em>Kyzer/CSG</em>
</body>
</html>
