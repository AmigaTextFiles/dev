<html>
<head><title>OOP4A</title></head>
<Body bgcolor=#140040 text=white link=red vlink=blue>

<CENTER><img src=top.png border=0><BR>Object Oriented Programming for All</CENTER>
<P>
<CENTER>- Entwurfsmuster - Design Pattern -</CENTER>
<P>
<CENTER>Ein Wort vorweg: "Das ist ne sehr umfangreiche Geschichte, also füllt sich das nach und nach!"</CENTER>
<P>
Zunächst wäre da der Begriff des Designpattern, zu Deutsch: Entwurfsmuster. Ein Muster
ist nichts anderes als eine Lösungsstrategie für ein Problem. Verschiedene Leute haben 
Ihre Programmierprobleme mal näher betrachtet und analysiert, in welche typischen 
Probleme man sie einteilen könnte. Dabei ist eine relativ kleine Liste mit wiederkehrenden
Problemen zusammengekommen. Einige Probleme sind recht trivial zu lösen , andere 
erfordern viel mehr Aufwand. Zu diesen Problemen gibt es immer eine theoretische
Lösung und einen Ansatz mit dem man das Problem sauber lösen kann. 
<BR>
Zwei von den einfacheren Problemen sind "das Anmatchen von Schnittstellen" und "Resourcenverwaltung".
<P>
Ersteres Muster heißt "Wrapper" und ist jedem Programmierer bekannt, egal ob er/sie OO oder prozederal
programmieren. 
<P>
<HR>
<P> </P><BR>
<a name=wrapper><font size=+3><CENTER>Muster Wrapper</CENTER></font></A>
<P>
<CENTER><I>"Ein Wrapper ist eine Schnittstelle zwischen den Schnittstellen." (msc)</I></CENTER>
<P>
Nehmen wir ein typische Programmierproblem , ein altes Programm A wurde für ein neues
Betriebssystem compiliert/emuliert/portiert und möchte dort nun die Serielle Schnittstelle
verwenden. Auf dem alten Betriebssystem sah die Schnittstelle für das serial.device
noch so aus:
<P>
<PRE>
class serial

    public setSpeed(long baud)
    public sendBytes(long buffer,long length)
    public recvBytes(long buffer,long length)
</PRE>
 <P>
auf dem neuen System sieht die Schnittstelle nun so aus:
<P>
<PRE>
class serial

    public openSerialPort()
    public closeSerialPort(long port)
    public setSpeed(long baud)
    public setHandshake(long mode)
    public send(long port,long buffer,long length)
    public recv(long port,long buffer,long length)
</PRE>
 <P>
Ohne den Quellcode des alten Programmes zu ändern ist hier nicht mehr an eine
funktion zu denken. Aus irgendeinem Grund kann oder will man dieses Programm nicht
verändern. Also muß ein Wrapper her.<BR>
Das ist eine Klasse die die alte Schnittstelle zur Verfügung stellt und 
selbst die neue benutzt. Eine solche Wrapperklasse finden Sie in den com.amiga.system
Klassen. Für unser Problem könnte eine Klasse so aussehen.
<P>
<PRE>
class serialwrapper
{
    Object class serial serial
    long port 

    public Constructor()
    {
       port=serial.openPort()
    }

    public DeConstructor()
    {
       serial.closePort(port)
    } 
    
    public setSpeed(long baud) 
    {
       serial.setSpeed(Baud)
    }

    public sendBytes(long buffer,long length)
    {
       long res

       res=serial.send(long port,long buffer,long length)
       return res
    }

    public recvBytes(long buffer,long length)
    {
       long res

       res=serial.recv(long port,long buffer,long length)
       return res
    }
}
</PRE>
 <P>
Damit ist das Problem gelöst. Würde man das alte Programm ändern, wäre das natürlich
der bessere Weg.
<P>
<HR>
<P> </P><BR>
<a name=Singleton><font size=+3><CENTER>Muster Singleton</CENTER></FONT></A>
<P>
<CENTER><I>"Singelton: Eine Anzahl Instanzen, welche als eine Instanz funktioniert."</I></CENTER>
<P>
Im Abschnitt über <a href=oop4ac.html#sm>syncronisierte Methoden</A> haben wir das Singleton
kennen gelernt.<P>
<UL>
<LI> Was ist ein Singleton?
<LI> Wann setzt man es ein?<BR>
 und 
<LI> Wie programmiert man das eigentlich?
</UL>
<P>
Ein Singleton ist Konstrukt das es nur einmal in Speicher gibt. In der OOP
handelt es sich dabei um das Erzeugen des immer gleichen Objektes pro Instanz.
In Java wird dies durch einen statischen Konstruktor gelöst, in OOP4A ist dies
so nicht möglich und auch eigentlich nicht nötig.<BR>
Ein Beispiel wird dies verdeutlichen:
<P>
<PRE>
<font color=red>Class</font> Test 
{
    <font color=blue>static</font> <font color=red>long</font> counter

    <font color=blue>static</font> <font color=red>String</font> Name    "OOP4A"
    <font color=blue>static</font> <font color=red>String</font> Vorname "System"
    <font color=blue>static</font> <font color=red>String</font> Strasse "MC68040"
    <font color=blue>static</font> <font color=red>String</font> Ort     "Amiga"

    <font color=red>public</font> getName()
    {
      <font color=blue>return</font> Name
    }

    <font color=red>public</font> getVorname()
    {
      <font color=blue>return</font> Vorname
    }

    <font color=red>public</font> getCounter()
    {
      <font color=blue>return</font> counter
    }

    <font color=red>public</font> <font color=#FFA000>syncronized</font> setCounter(long value)
    {
      counter==value
    }
}
</PRE>
 <P>
Selbst wenn von dieser Klasse beliebig viele Objektinstanzen erzeugt werden,
geben alle Methoden die gleichen Variablen zurück. Wenn es sich bei diesen Variablen
nicht um Strings sondern um Informationen über z.b. eine Hardware handelt, so 
kann mit syncronisierten Zugriffsmethoden auf diese Informatinen zugegriffen werden.
Es kann auch sichergestellt werden, daß immer nur ein Task auf die Hardware zugreift.
Damit handelt es sich um ein Singelton, eine Anzahl Instanzen die als eine Instanz
funktioniert.
<P>


<P>
<CENTER><a href=oop4a.html>OOP4A</A></CENTER>
<P>


</BODY>
</HTML>
