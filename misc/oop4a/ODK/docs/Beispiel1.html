<html>
<head><title>OOP4A</title></head>
<Body bgcolor=#140040 text=white link=red vlink=blue>

<CENTER><img src=top.png border=0><BR>Object Oriented Programming for All</CENTER>
<P>
<CENTER>Beispiel einer Abstrakten Klasse</CENTER>
<P>
<LISTING>

abstract class Sort
{
    long Root DataPointer

    protected makeRoot()
    {
      root=makeEntry()
    }

    abstract public makeEntry()
    
    abstract public insertItem(value)
    
    abstract public deleteItem(value)
    
    abstract public getFirstItem()

    abstract public getNextItem()
    
    abstract public displayList()
    
}

Class VerketteListe extends Sort
{

    public makeEntry()
    {
       long mem
    
       mem=new("ListEntry",0)
     
       return mem  
    }

    public insertItem(long value)
    {
    
       Object Entry

       Entry=getLastItem(Root)
       
       Entry.AddEntry(value)
    }

    ...

}

Class BinärerBaum extends Sort
{

    public makeEntry()
    {
       long Entry
    
       Entry=new("BinTreeEntry",0)
     
       return Entry
    }

    public insertItem(long value)
    {
    
       Object Entry

       SortInTree(Root,Value)
       
    }

    ...
}

</LISTING>

Wie man jetzt gut sehen kann haben alle abgeleiteten Objecte dieselben Methoden und
MethodenArgumente, aber konkret andere Implementierungen. Zur Laufzeit eines
Programms kann man sich aussuchen welchen Sortieralgorithmus man benutzen will, ohne das 
beim Programmieren schon festzulegen. Der User könnte in einem Prefsfile angeben welche 
konkrete Sortiermethode er benutzen will. So können Implementierungen auch nachträglich 
verbessert werden ohne alles neu zukompilieren.


<CENTER><a href=oop4a.html>zurück zum Index</A>
</BODY>
</HTML>
