<html>
<head><title>OOP4A</title></head>
<Body bgcolor=#140040 text=white link=red vlink=blue>

<a name=start><CENTER><img src=top.png border=0><BR>Object Oriented Programming for All</CENTER></A><P>

Hi,<BR>
willkommen zu einem kleinen neuen Projekt von mir.
Objektorientierte Programmierung für alle. Das meint,
daß jede NICHT objektorientierte Programmiersprache, die fähig ist
Amiga Shared Libraries zu benutzen, zur Programmierung von Objekten benutzt werden kann.
<P>
Jeder Programmierer hat schon mal was von JAVA gehört und im gleichen Atemzug, 
daß es auf dem Amiga zwar funktioniert, aber leider so langsam ist, das es nicht
praktisch einsetzbar ist. Wer nun OO programmieren will, muß auf einen der diversen C++ 
Compiler umsteigen.
<P>
Da mir im großen und gesamten JAVA und OOP gefällt und ich dazu auch noch meine 
eigene Programmiersprache verwenden wollte, hab ich mir Gedanken gemacht , wie man OOP
auf dem Amiga resourcenschonend und zugleich <I>offen</I> für alle Programmiersprachen
gestalten kann.<BR>
Das Ergebnis sieht man hier:
<P>
<CENTER>
    <a href=../IPS/oop4a.lha.gz>Downloadpackage here</A>
    <P>
    <a href=oop4a.html#install>Installation hier lesen</A>
    <P>
    <a href=oop4a.html#Selbst>Eigene Sprache benutzen</A>
    <P>
    <a href=oop4a_e.html>Page translated by Babelfish :-)
       <img src="http://www.altavista.com/static/i/bf/bfish.gif" border=0>
    </A><BR>pls read the german text in paralell :-)))
    <P>
    <a href=oop4a.html#basics>Inhalt</A>
    <P>
    <a href=oop4a.html#abstract>Abstrakte Methoden und Klassen</A>
    <P>
    <a href=oop4a.html#basics>Basics über OOP4A</A>
    <P>
    <a href=oop4ab.html>BOOPSI und OOP4A<br><font size=1>lest es!</font></A>
    <P>
    <a href=oop4ac.html>Static Kontext - AutoStrings</A>
    <P>
    <a href=oop4ad.html>Typen und Überladung von Methoden</A>
    <P>
    <a href=oop4a.html#garbage>GarbageCollector</A>
    <P>
    <a href=oop4a.html#packages>Packages</A>
    <P>
</CENTER>
<P>
Die <a name=basics>"oop.library"</A> ist das Herz des gesamten Systems.
 Sie bietet 3 Funktionen an:<P>
<UL>
<LI>new<P>
<LI>del<P>
<LI>domethode<P>
</UL><P>

Mit new() werden neue Objekte erzeugt, mit del() werden
diese zerstört, und domethode() ruft Methoden dieser Objekte auf.
<P>
Objekte sind in Klassen definiert, diese finden sich in Klassenfiles
wieder , Endung "<B>.class</B>". Diese Klassenfiles werden mit 
einem Präprozessor übersetzt und dann kompiliert und assembliert.
Das Zielformat ist eine echte <I>Amiga Shared Library</I>.
<P>
Klassen werden nur einmal erzeugt und können beliebig oft instanziiert werden.<BR>
Eine Klasse definiert sich so:
<PRE>
<B>class</B> Klassenname 
 {

    <I>Variablen und Objekte</I>

    Methoden()
    {}

 }

</PRE>
Eine Klasse kann eine andere Klasse erweitern und dadurch die Methoden und
Variablen der Superklasse erben.
<P>
<PRE>
<B>class</B> b <font color=red>extends</font> a
{
    <B>...</B>
}
</PRE>
<P>
Klassenerweiterungen können sich beliebig oft Verschachteln,d.h. Klasse Z erweitert Y,
Y erweitert X, X erweitert W usw. usw.
<P>
Der Name der zu erweiterenden Klasse <I>kann</I> ein vollqualifizierter Name sein, oder
der Name der Klasse ohne <I>.class</I>. Ein Packagename kann auch benutzt werden.
<P>
Variablen sind durch den Compiler auf LONG und Zeiger auf LONG festgelegt. Als
Compiler wird PreAss verwendet. Als Assembler Asm-One. 
Der Präprozessor Preassxx kennt auch Objekte als Variablen. Dies ist wichtig 
damit Konstrukte der Form <B><I>X=objektname.methodenname(arg1,arg2...).methodeY()...</I></B>
möglich sind. Variablen können privat ( default ) oder public sein. Das macht
aber nur Sinn in den Objektvariablen, in den lokalen Variablen der Methoden
ist public zwar angebbar , aber nicht wirksam, da es sich um Stackvariablen handelt.
<P>
Methoden können vier definierte Zustände haben:<BR>
<OL><LI>private<BR><LI>protected<BR><LI>public<P><LI>abstract<BR></OL><P>
<B>Nur public-Methoden können von aussen angesprochen werden</B>. <a href=oop4a.html#abstract><I>Abstrakte Methoden</I></A> sind
Methoden ohne Methodenkörper, also Programmcode, und können so <U>nicht</U> kompiliert werden.

<P>
<PRE>

<B>class</B> Test
{
    <B>long</B> A B C

    <font color=blue>public</font> setA(long value)
     {
        a==value
     }

    <font color=blue>public</font> setB(long value)
     {
        B==value
     }

    <font color=blue>private</font> setC(long value)
     {
        C==value*-1
     }

    <font color=blue>public</font> calc()
     {
        <B>long</B> returnvalue

        returnvalue==A*B

        setC(returnvalue)

        <font color=red>return</font> returnvalue

     }
}

<font color=red><B>* Die hier verwendete Test.class ist im ODK nicht enthalten! *</B></font>

<HR>Ein Programm welches die Klasse benutzen will<HR>

Start:
    test=<font color=red>new</font>("test",0)
    domethode(test,"setA",>settag1:10)
    domethode(test,"setB",>settag2:20)
    ret=domethode(test,"calc",0)
    printf("10 * 20 = %ld\n",*ret)
    test=<font color=red>del</font>(test)
    {* return *}

</PRE>

Will eine Klasse ein Objekt einer anderen Klasse benutzen, 
muß es einfach ein Objekt dieser Klasse mit new() instanziieren:
<P>
<PRE>
<B>class</B> a 
{
    <B>long</B> testobject

    <font color=blue>public</font> methode()
    {
        testobject=<font color=red>new</font>("test",0)
        ...
        <font color=red>del</font>(testobject)
    }
}

</PRE>
Damit man nicht mehr auf normale Programme zurückgegriffen werden muß,
gibt es eine Methode <I>Main()</I> , welche als Programmstart angesehen werden kann.
Damit Klassen mit der Methode <I>Main()</I> auch benutzt werden können gibt es <B>OOPA</B>.
<I>OOPA</I> nimmt als Kommandozeilenargument den Namen der zu startenden Klasse und ggf. 
eine Argumentzeile an, die an die Methode <I>Main()</I> weitergreicht wird.
<P>
<PRE>
<B>class</B> a
{
    ...

    <font color=blue>public</font> Main()
    {
        Object testobject

        testobject=<font color=red>new</font>("test",0)
        
        Result=testobject.Test()
        if Result#0
         {
           printf("Result != null\n")
         }
        testobject=<font color=red>del</font>(testobject)
    }      
}

</PRE>

<font color=red>WARNUNG: Es gibt <B>keinen</B> <A name=garbage>GarbageCollector</A> der 
nach dem Zerstören eines Objektes alte Referenzen findet und freigibt.</font>
Das hat jedes Objekt selbst zu leisten. Es ist sicher ein Objekt mehrfach zu zerstören, wenn man
sich an die Regel <B>Object=del(Object)</B> hält. Einen kleinen GarbageCollector 
gibt es allerdings doch, flushlibs , liegt im Aminet bzw. ist im odk enthalten , und 
das ODK eigene flush können zusammen als Collector eingesetzt werden. Dabei werden
nicht mehr benötigte Objekt-Libraries aus dem Speicher entfernt. Dazu muß der OpenCounter
der Libraries Null anzeigen. Wenn man Klassen verändert, müssen sie neu kompiliert werden.
Dies ist normal, wenn man im OOP4A diese neue Version der Klasse auch wirklich benutzen will,
dann muß man die alte Klasse mit flushlibs aus dem Speicher entfernt haben, sonst wird
die passende Library nicht neu von der Festplatte gelesen und natürlich auch nicht
ausgeführt. Der AmigaOS Libraryloader, der zum Laden der Libraries zwangsweise eingesetzt
wird, ist leider nicht der Meinung, daß er mal nachsehen sollte, ob sich die Libs geändert
haben, wenn die Lib lange nicht benutzt wurde. Das ist auf die alten Amigas ohne Festplatte
ausgerichtet, um so Zeit zusparen. Erst eine Anforderung nach freiem RAM-Speicher für 
das System entfernt unbenutzte Libraries aus dem Speicher, z.b. `Avail flush` oder
`flushlibs`.
<P>
Um zubenutzende Objekte anzulegen bzw. zu zerstören gibt es einen <I>Konstruktur</I>
 und einen <I>Dekonstruktor</I>. Im Dekonstruktor kann auch die empfohlende "object=del(object)"
Klausel verzichtet werden, da es nach dem Beenden der Methode ja keiner mehr auf das
Objekt zugreifen kann.
<P>

<PRE>
<B>class</B> a 
{
    <B>long</B> testobject

    <font color=blue>public</font> methode()
    {
        testobject=<font color=red>new</font>("test.class",0)
        ...
        testobject=<font color=red>del</font>(testobject)
    }

    <font color=blue>public</font> DeConstructor()
    {
      <font color=red>del</font>(testobject)
    }

}

</PRE>
Im Konstruktor werden Routinen abgearbeitet die bei jedem Erstellen
eines Objektes dieser Klasse durchlaufen werden sollen. Dies passiert
exakt <B>einmal</B> im Leben eines Ojektes, es sei denn der Konstruktor
wird expliziert aufgerufen. Der Dekonstruktor wird auch nur <B>einmal</B>
aufgerufen, wenn das Objekt zerstört werden soll.
<P>
<Table border>
    <TR><TH>Funktion</TH><TH>Name</TH></TR>
    <TR><TD>Konstruktor</TD><TD>Constructor()</TD></TR>
    <TR><TD>DeKonstruktor</TD><TD>DeConstructor()</TD></TR>
</TABLE>
<P>
<A name=abstract>Abstrakte</A> Klassen sind Klassen die nicht instanziierbar sind, weil konkrete Methoden
fehlen. 

<PRE>

<font color=blue>abstract</font> <B>class</B> A
{
    <B>long</B> Zahl

    <font color=blue>abstract</font> <font color=blue>public</font> Methode1(long a,long b)
             
    <font color=blue>public</font> Methode2(long a,long b)
    {
        ... konkreter code ...
    }
}

</PRE>
Diese Klasse A kann nicht instanziiert werden, da für die Methode1() kein Sourcecode
vorliegt. Eine Klasse B muß nun diese Klasse erweitern und den nötigen Sourcecode
konkret implementieren:

<PRE>
<B>class</B> b <font color=red>extends</font> a
{
    <font color=blue>public</font> Methode1(long a,long b)
    {
      <B>long</B> returnvalue
    
      returnvalue==A+b

      <font color=red>return</font> returnvalue
    }
}

</PRE>
Dies geschieht, damit Objekte als ganzes austauschbar werden. Das <font color=green>
<a href=Beispiel1.html>Beispiel</A></font> wird dies verdeutlichen.
<PRE>
<B>class</B> a
{
    Object <B>class</B> String  Name
    Object <B>class</B> Integer Zahl

    Methode()
    {
    
      Name.Set("hallo")
    }
}

</PRE>
Daraus wird das folgende De/KonstruktorPaar zusammengebaut, selbst wenn <U>ein</U> 
De/Konstruktor vorgeben wird. <font color=red>Bitte beachten Sie das!</font>
<P>
<PRE>
 Constructor()
    {
      name=<font color=red>new</font>("String",0)
      Zahl=<font color=red>new</font>("Integer",0)
      if name&zahl=0
       {
         <font color=red>del</font>(name)
         <font color=red>del</font>(zahl)
         {* UnFramereturn -1*}
       }
    }

 DeConstructor()
    {
      <font color=red>del</font>(name)
      <font color=red>del</font>(zahl)
    }

</PRE>
<P>
<CENTER><img src=framework.png></CENTER>
Abb. zeigt einen kleinen Einblick in das Framework
</P>
<P>
<CENTER><img src=integertest.png></CENTER>
Abb. zeigt die Abh&auml;nigkeiten von Objekten und Klassen untereinander
</P>
<P>
<CENTER>
<HR>
    <a href=oop4a.html#start>Inhalt</A>
    <P>
    <a href=oop4a.html#abstract>Abstrakte Methoden und Klassen</A>
    <P>
    <a href=oop4a.html#basics>Basics über OOP4A</A>
    <P>
    <a href=oop4ab.html>BOOPSI und OOP4A<br><font size=1>lest es!</font></A>
    <P>
    <a href=oop4ac.html>Static Kontext - AutoStrings</A>
    <P>
    <a href=../IPS/oop4a.lha.gz>Downloadpackage here</A>
    <P>
    <a href=oop4a.html#install>Installation hier lesen</A>
    <P>
    <a href=oop4a.html#Selbst>Eigene Sprache benutzen</A>
    <P>

<HR>
</CENTER>
<P>
<a name=install>Installation:</A>
</P>
<P>
Saugt euch von der StartSeite die PREASS Archive und installiert dieses zuerst.
Dann entpackt das oop4a Archiv . Darin sind die nötigen LVO/FD/AUTODOCS für die 
oop.library und der Präprozessor für die ClassFiles enthalten, dazu eine auf das 
jeweilige ODK angepaßte Version von Preass. Einige Klassenfiles sind im 
Archiv dabei, diese sind aber ohne richtige Funktion, da es noch keinen 
DeveloperKit für PreassXX gibt. Wir sind da erst am Anfang! Wer Lust hat darf 
gerne eigene Packages schreiben und zu mir senden, die werden gern genommen.
<BR>
<a name=packages>Packages</A> bauen sich eigentlich wie bei JAVA auf. Das Ganze 
muß relativ zu Libs:classes geschrieben sein.Statt . kann auch / verwendet werden,
das kommt auf gleiche raus.
<P>
Wer keine eigene Domain im Netz besitzt, der baut das so auf:
<P>
<PRE>
TopLevelDomain des Landes in dem man wohnt ( z.b. de ) + Name des Authors + Projektname + ..

also z.b. de.Cyborg.Hamsterkäfig

</PRE>
Wo der Source liegt, ist eigentlich egal. Der Sourcetree soll die gleiche Struktur haben, 
wie der Baum in Libs:classes, sonst kommen wir da ins Caos! Die fertig assemblierten 
 Libraries kommen dann nach "Libs:Classes" , dazu muß "libs:classes" in den Libspfad eingebaut werden..
<P>
<hr>
<P>
<a name=selbst>Einen eigenen Präprozessor schreiben:</A>
<P>
<HR>
<P>
Wie war das jetzt mit der eigenen Sprache und OOP ? <BR>
Naja, eigentlich ist das jetzt ganz einfach. Dem ODK liegt ein Beispiel Präprozessor
für Preass dabei. Diesen muß man eigentlich nur an die verwendete Sprache anpassen.
Der Präprozessor arbeitet in zwei Schritten. Im 1. Schritt werden alle Zeilen des Klassenfiles
eingelesen und in Ihre Bestandteile zerlegt. Das wären z.b. Anweisungen wie CLASS , EXTENDS
Public , RETURN usw. Jede Zeile die nichts enthält , was der Präprozessor wissen muß , 
wird mit der entsprechenden MethodenID ( 0 = Klassencode ( z.Z. nicht unterstützt ) 
in der Line-Liste ( LineRoot)  gespeichert. Alle Objekte und Variablen werden ebenfalls 
in solchen verketten Listen gespeichert. Aus diesen Listen wird im 2. Schritt der 
Source für Preass gebaut. 
Kurz um, am Ende des Prozesses muß eine Struktur mit dem gleichen Verhalten wie aus dem Preass++
Präprozessor. Dies ist eine Librarystruktur und muß vom Compiler auch direkt in eine 
Library oder Assembercode übersetzt werden können. Wichtig dabei sind die Arrays für 
Funktionen und Strings, die für die OOP Lib gebraucht werden!
<P>
Ein <font color=red><B>wichtiger Hinweis</B></font>: alle Klassen die mit Preass++ geschrieben und übersetzt werden
sind <B>threadsafe</B>! Wenn das der von Ihnen geschriebene Präprozessor nicht sicherstellen
sollte, dann kann er <B>nicht eingesetzt</B> werden, da Thread-Sicherheit eine Grundvorraussetzung
 ist.
<P>
Das ist nicht zu verwechseln mit syncronisiertem Zugriff auf eine Methode!
<P>
Viel Spaß.
<P>
<CENTER><a href=oop4a_history.html>OOP4A History</A></CENTER>
<P>


</BODY>
</HTML>
