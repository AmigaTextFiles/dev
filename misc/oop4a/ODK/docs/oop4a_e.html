<html>
<head><title>OOP4A</title></head>
<Body bgcolor=#140040 text=white link=red vlink=blue>

<a name=start><CENTER><img src=top.png border=0><BR>Object Oriented Programming for All</CENTER></A><P>

Hi,<BR>
welcome to a small new project of mine: "Object Orientated Programming for All".
Every none oop language which offers support for Amiga Shared Libraries, is now able to use objects and can
be used to produce new classes.
<P>
Every programmer has surely heared about Java and that it will be very slow on an normal amiga.
If you wanne code oop you are forced to use one of the C++ compilers or one the eiffel
ports. What if you don`t need to because someone has build an open class system and a compiler
which offers nearly the same functionality as the JAVA language does ?
<P>
Well I did this and because I wanted to use my own compiler language as a basis , I 
coded a precompiler which does the whole oop releated things and a oop library
which does the runtime jobs. This system is <I>open</I> to every programming language which can 
make use of libraries. If you wanne use <B>your own</B> programming language, you will find a 
precompiler sourcecode which you can adapt , which is a very easy thing to do. 
<P>
The results for Preass can be found here:
<P>
<CENTER>
    <B>Some pages have not been translated yet, feel free to use Babelfish instead. Reading it, will be of much fun for all of us.</B>
    <P>
    <a href=../IPS/oop4a.lha.gz>Downloadpackage here</A>
    <P>
    <a href=oop4a_e.html#install>How to install</A>
    <P>
    <a href=oop4a_e.html#Selbst>use your own language</A>
    <P>
    <a href=oop4a_e.html#basics>start of this page</A>
    <P>
    <a href=oop4a_e.html#abstract>abstract methods and classes</A>
    <P>
    <a href=oop4a_e.html#basics>Basics about OOP4A</A>
    <P>
    <a href=oop4ab.html>BOOPSI and OOP4A<br><font size=1>read it!</font></A>
    <P>
    <a href=oop4ac.html>static context - autostrings</A>
    <P>
    <a href=oop4ad.html>typs and methodoverloading</A>
    <P>
    <a href=oop4a_e.html#garbage>garbagecollector</A>
    <P>
    <a href=oop4a_e.html#packages>packages</A>
    <P>
</CENTER>
<P>
Heart of the system is the <a name=basics>"oop.library"</A>, which offers 3 functions:
<P>
<UL>
<LI>new<P>
<LI>del<P>
<LI>domethode<P>
</UL>
<P>
new() generates new objects, del() destroys them and 
domethode() calls methods of the generated objects.
<P>
Objects are defined in Classes, which can be found in classfiles, postfix <B>.class</B>.
These classes will be precompiled with the precompiler preassxx , compiled with preass and 
assembled with ASM-One. If you wanne use another programming language then look <a href=oop4a_e.html#Selbst>here</A>.
The compiled files are real nativ <I>Amiga Shared Libraries</I>.
<P>
Classes will only be generated once. Any number of objects can created from these classes.
A class is definied as followed:
<PRE>
<B>class</B> classname 
 {

    <I>variables and objectes</I>

    methods()
    {}

 }

</PRE>
Eine Klasse kann eine andere Klasse erweitern und dadurch die Methoden und
Variablen der Superklasse erben.

A class can extend another class and inherits her methods and variables of 
the so called superclass.
<P>
<PRE>
<B>class</B> b <font color=red>extends</font> a
{
    <B>...</B>
}
</PRE>
<P>
Classextentions can be done until you hit the root of the object tree, this means 
class z can extend y, y can extend x, x can extend w etc. etc..
<P>
The name of the extended class <I>can be</I> a fully qualified name or the name without ".class".
A packagename (s.b.) can be used also.
<P>
Variables are preset from the compiler to long and pointer to long. Preass is used as Compiler, as
Assembler ASM-One is used. The praeprozessor Preassxx knows also objects as variables.
This is important for constructs like <B><I>X=objektname.methodenname(arg1,arg2...).methodeY()...</I></B>.
Variables can be private ( default state ) or public. This makes only sense for instance variables.
You can give this state to any variable used in the methodebody, but there it does not have ANY 
effect or sense because, these are stackvariables , which can not be accessed from outside.
BTW: You can`t access public instance variables too, this is more an indicator for 
other programmer that these Variables have get and set routines which have to be use instead.
This is a strong behaviour compared against other oop systems, i.e. JAVA  offers a way to access public variables.
If I would do the same, the data inside an object would no longer encapsulated.
<P>
Methods can have four different states:<BR>
<OL><LI>private<BR><LI>protected<BR><LI>public<P><LI>abstract<BR></OL><P>
<B>Only public-methods can be access from outside</B>. <a href=oop4a.html#abstract><I>Abstract methods</I></A> 
are methods without methodebodies, without sourcecode after the methodeheader, and <U>can not be</U> compiled!.
<P>
<PRE>

<B>class</B> Test
{
    <B>long</B> A B C

    <font color=blue>public</font> setA(long value)
     {
        a==value
     }

    <font color=blue>public</font> setB(long value)
     {
        B==value
     }

    <font color=blue>private</font> setC(long value)
     {
        C==value*-1
     }

    <font color=blue>public</font> calc()
     {
        <B>long</B> returnvalue

        returnvalue==A*B

        setC(returnvalue)

        <font color=red>return</font> returnvalue

     }
}

<font color=red><B>* Test.class is just an example! *</B></font>

<HR>A program which could use the above class<HR>

Start:
    test=<font color=red>new</font>("test",0)
    domethode(test,"setA",>settag1:10)
    domethode(test,"setB",>settag2:20)
    ret=domethode(test,"calc",0)
    printf("10 * 20 = %ld\n",*ret)
    test=<font color=red>del</font>(test)
    {* return *}

</PRE>
if a class wants to use another object it has to instanciate the object
with new():
<P>
<PRE>
<B>class</B> a 
{
    <B>long</B> testobject

    <font color=blue>public</font> methode()
    {
        testobject=<font color=red>new</font>("test",0)
        ...
        <font color=red>del</font>(testobject)
    }
}

</PRE>
Because we won`t make use of normal programs any more, there is a program called <B>oopa</B>
which can start classes by calling the <B>Main</B> methode of a class. If the class does 
not have a Main it won`t run this class. <B>oopa</B> parses the commandline arguments to Main.
<P>
<PRE>
<B>class</B> a
{
    ...

    <font color=blue>public</font> Main()
    {
        Object testobject

        testobject=<font color=red>new</font>("test",0)
        
        Result=testobject.Test()
        if Result#0
         {
           printf("Result != null\n")
         }
        testobject=<font color=red>del</font>(testobject)
    }      
}

</PRE>

<font color=red>WARNING: There is <B>no</B> <A name=garbage>GarbageCollector</A> which 
destroys unused objects.</font>
This has to be done by the owner of the object for each himself.It`s save to destroy an
objects more than once if you use this construct <B>Object=del(Object)</B>.
With it the reference to the object will be removed and every further call will be
alerted to the user by the oop.library.
<P>
If you wanne compile a new version of a class you have to remove the old library from the system.
The amigaoslibraryloader normally  does not check if a newer version of a library is available after 
loading one from disk. This spares some time if you have a floppy system, but makes
problems if develop with oop4a or other library building tools. For this case we have small
tool, which removes the unneeded libs from ram like a GarbageCollector should do.
It`s called "flushlibs" and together with the flush tool in okd:bin, you can remove 
old libs from ram in a given time intervall. Its more or less a small garbage collector
and maybe in the future the way to find unused objects. Maybe! You can find flushlibs at aminet or
in the odk.
<P>
For every object exists a Constructor and a Deconstructor paire. You don`t have to use the 
 "object=del(object)" rule in the deconstructor because there are no more calls in this object
:-) .
<P>

<PRE>
<B>class</B> a 
{
    <B>long</B> testobject

    <font color=blue>public</font> methode()
    {
        testobject=<font color=red>new</font>("test.class",0)
        ...
        testobject=<font color=red>del</font>(testobject)
    }

    <font color=blue>public</font> DeConstructor()
    {
      <font color=red>del</font>(testobject)
    }

}

</PRE>
Im Konstruktor werden Routinen abgearbeitet die bei jedem Erstellen
eines Objektes dieser Klasse durchlaufen werden sollen. Dies passiert
exakt <B>einmal</B> im Leben eines Ojektes, es sei denn der Konstruktor
wird expliziert aufgerufen. Der Dekonstruktor wird auch nur <B>einmal</B>
aufgerufen, wenn das Objekt zerstört werden soll.

At the Constructor you will place all routines which have to be called 
everytime an object is generated. This happens exactly one time in the life 
of an object. If you call the constructor a second time by hand it we be used a 
second time but that far beyond any coding style! The Deconstructor will be 
called only one time too! Don`t call it before you wanne destroy it, not even
if theres no Deconstructorbody! The precompiler adds a lot stuff the coder won`t
see! 

<P>
<Table border>
    <TR><TH>Function</TH><TH>Name</TH></TR>
    <TR><TD>Construktor</TD><TD>Constructor()</TD></TR>
    <TR><TD>Deconstruktor</TD><TD>DeConstructor()</TD></TR>
</TABLE>
<P>
<A name=abstract>Abstract</A> classes are classes which can not be instanciated, 
because concret methodebodies are missing! 
<PRE>

<font color=blue>abstract</font> <B>class</B> A
{
    <B>long</B> Zahl

    <font color=blue>abstract</font> <font color=blue>public</font> Methode1(long a,long b)
             
    <font color=blue>public</font> Methode2(long a,long b)
    {
        ... concrete code ...
    }
}

</PRE>
This classs A can not be instanciated, because Methode1() does not contain
a methodebody. A class B must extend this class and has to add the needed methodebody
or has to left the methode abstract to be extended by another class!

<PRE>
<B>class</B> b <font color=red>extends</font> a
{
    <font color=blue>public</font> Methode1(long a,long b)
    {
      <B>long</B> returnvalue
    
      returnvalue==a+b

      <font color=red>return</font> returnvalue
    }
}

</PRE>
This happens because objects can be exchanged if they offer the same interface.
An <font color=green> <a href=Beispiel1_e.html>example</A></font> will make it clear.

<PRE>
<B>class</B> a
{
    Object <B>class</B> String  Name
    Object <B>class</B> Integer Zahl

    Methode()
    {
    
      Name.Set("hallo")
    }
}

</PRE>
Daraus wird das folgende De/KonstruktorPaar zusammengebaut, selbst wenn <U>ein</U> 
De/Konstruktor vorgeben wird. <font color=red>Bitte beachten Sie das!</font>

This will produce the following constructor/deconstructor paire, even if <U>a</U>
de/constructor paire is given! <font color=red>Please take care of it!</font>

<P>
<PRE>
 Constructor()
    {
      name=<font color=red>new</font>("String",0)
      Zahl=<font color=red>new</font>("Integer",0)
      if name&zahl=0
       {
         <font color=red>del</font>(name)
         <font color=red>del</font>(zahl)
         {* UnFramereturn -1*}
       }
    }

 DeConstructor()
    {
      <font color=red>del</font>(name)
      <font color=red>del</font>(zahl)
    }

</PRE>
<P>
<CENTER><img src=framework.png></CENTER>
dia. shows a small part of the framework
</P>
<P>
<CENTER><img src=integertest.png></CENTER>
dia. shows the dependencies from objects and classes
</P>
<P>
<CENTER>
<HR>
    <a href=oop4a_e.html#start>Index</A>
    <P>
    <a href=oop4a_e.html#abstract>Abstract methods und classen</A>
    <P>
    <a href=oop4a_e.html#basics>Basics about OOP4A</A>
    <P>
    <a href=oop4ab.html>BOOPSI and OOP4A<br><font size=1>read it!</font></A>
    <P>
    <a href=oop4ac.html>static context - autostrings</A>
    <P>
    <a href=../IPS/oop4a.lha.gz>Download package here</A>
    <P>
    <a href=oop4a_e.html#install>How to install</A>
    <P>
    <a href=oop4a_e.html#Selbst>use your own language</A>
    <P>

<HR>
</CENTER>
<P>
<a name=install>Installation:</A>
</P>
<P>
Please download the PREASS package from the <a href=www.geocities.com/SiliconValley/Bridge/5737/Main>Preass Page</A>
or from the <a href=www.geocities.com/SiliconValley/Bridge/5737>Download Section</A> and install it first.
the actual preass version in odk:bin is the uptodate one!
After this depack the oop4a archive and copy the oop.library to "libs:". Please
make a tree copy of the source tree to libs:classes which contains only the directories!
Make an Assign odk: to the okd directory and add the okd:bin to your path i.e.
"assign c: odk:bin add" . That's it. You need asmone as "ass"  in c: . It could be
that you have to adjust the prefs of asmone at first use. A prefs file containing 
the working options is placed in odk:misc , copy it to env: and envarc: .
<BR>
<a name=packages>Packages</A> are build like in JAVA. The name must the relative to 
Libs:classes. You can use '/' instead of '.' it's equal, but '.' is more common.
<P>
If don't own an internet domain, pls build it like this example:
<P>
<PRE>
TopLevelDomain of your home country ( i.e. de ) + name of the author + projectname + ..

i.e. de.Cyborg.Hamsterkäfig

</PRE>
Place your sourcecode in odk:classes with your package structure as directory tree.
<P>
<hr>
<P>
<a name=selbst>Write your own preprozessor:</A>
<P>
<HR>
<P>
You will find a working preprocessor, or precompiler if want, in odk:source.
If you understand how it works you just need to change the output to the needed
syntax of your favorite compiler and thats it. Most library part is done 
in includefiles so it's easy to change the precompilerbackend. 
All lines of code inside a methodebody are untouched if they are have no keywords
inside and these keywords are only "return", "Object" , "long" and "new".
<P>
The precompiler works in two steps, first step is to sort all variables, methodes,, 
objects and other informations in chained lists. The second step produces the outputfile.
In step one some parts of step two are done for strings and analysing of constructs. 
<P>
At the end of the process must be the same library structure with the same behaviour as 
the original one. Important are the structures and arrays which are used by the oop.library 
to match the methodenames and argumenttypes.
<P>
An <font color=red><B>important information</B></font>: all classes which are compiled with PreassXX 
are <B>threadsafe</B>! if you compiler can off this behaviour you have a problem. 
<P>
Don`t mess this with syncronised methodes!
<P>
Have Fun!
<P>
<CENTER><a href=oop4a_history.html>OOP4A History</A></CENTER>
<P>


</BODY>
</HTML>
