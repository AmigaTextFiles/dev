<html>
<head><title>OOP4A</title></head>
<Body bgcolor=#140040 text=white link=red vlink=blue>

<CENTER><img src=top.png border=0><BR>Object Oriented Programming for All</CENTER>
<P>
<CENTER><H1>- Typen und Überladung von Methoden -</H1></CENTER>
<P>

Bis jetzt kennen Sie die compilerinternen Typen <B>long</B> und
<B>String</B>, wobei String nur eine Vereinfachung der Sprache
darstellt.<BR> 
Mit der Einführung von Typenprüfung beim Methodenaufruf ist der
Weg freigemacht für Methodenüberladung. Als gültige Typen gelten
alle einfachen Klassennamen also z.B. <font color=#D0D0D0>String</font>,<font color=#D0D0D0>zahl</font>,<font color=#D0D0D0>StringArray</font> usw.
Daraus ergibt sich zwar ein Problem der Eindeutigkeit , wenn in verschiedenen 
Packeten Klassen gleiche Namen haben, aber das liese sich nur mit Performanceeinbußen
vermeiden, in dem immer der Packetname statt des Klassennamens geprüft wird. 
Zudem würden zwei Amiga Libraries mit dem gleichen Namen auch nicht unterschieden werden,
daher ist von gleichen Klassennamen abzuraten, wenn sie nicht das gleiche Interface
erfüllen.
<P>
Ein Argumenttyp wird wie folgt angegeben.
<P>
<PRE>
class unbekannt
{
    public test(long A,StringArray B)
    {
        ...
    }
}
</PRE>
 <P>
Der Typ <B>long</B> ist dabei ein universal Typ, der alles annimmt was übergeben
wird. Will man die Klasse <B>Long</B> haben, so muß man auch <B>Long</B> angeben.
<B>Groß/KleinSchreibung ist dabei zu unterscheiden!</B>
<P>
<CENTER><H1>Was ist den nun Überladung?</H1></CENTER>
<P>
Als Überladung bezeichnet man die Eigenschaft einer Methode 
mehrere Implementierungen mit verschiedenen Argumentypen mitgeben zu können.
Konkret bedeutet das, daß es in einer Klasse mehrere Methoden gleichen Namens
geben kann. Die eigentlich auch gleiche Aufgaben versehen. Ein Beispiel macht 
dies deutlich:
<P>
<PRE>
class unbekannt
{
    public test(long A,StringArray B)
    {
        ...
    }
    public test(long A,String B)
    {
        ...
    }

}
</PRE>
 <P>
ruft nun eine Klasse die Methode <I>test</I> der unbekannten Klasse
auf, so kann Sie wahlweise einen String oder einen StringArray übergeben und erwarten
das beides mal das gleiche passiert.
<P>
<PRE>
class unbekannt
{
    long A

    public add(Integer B)
    {
        A=A+B.tolong()        // diese Syntax wird noch nicht vom Compiler unterstützt.
    }
    public add(Long B)
    {
        A=A+B.getLong(B)
    }
    public add(Word B)
    {
        A=A+B.tolong(B)
    }

}
</PRE>
 <P>
<CENTER><H1>Wozu kann man das jetzt benutzen????</H1></CENTER>
<P>
Naja, zunächst einmal lassen sich so Methoden zu Gruppen mit gleichen Aufgaben
zusammenstellen, so daß sich der Programmierer nur den Namen einer Methode
merken muß, um immer die richtige Funktion zubekommen. Ein gutes Beispiel ist hier 
die "print()" Methode. Damit man nicht für jedes Objekt eine eigene printXXXXX() Methode
hat, die man sich ja merken müßte, überläd man einfach die Methode mit einer
neuen Implementierung für einen neuen Typen und gut. So steht im Sourcecode später immer nur
"print()" statt "printLong()" "printStringArray()" usw.. . Beim Lesen kann man sich 
also daraufverlassen, wenn man weiß was eine Implementierung von print() macht, dann
machen alle anderen das auch. Natürlich nur , wenn der Programmierer der Überladenen
Methode das auch so sieht. Das kann letzden Endes kein Compiler der Welt sicherstellen.   
<P>
<H1><CENTER>Kann man eigentlich alles überladen?</CENTER></H1>
<P>
<UL>
<LI>Da auch Konstruktoren letztlich nur Methoden eines Objektes darstellen, können auch
diese Überladen werden. Damit können Objekte schon beim Erzeugen mit NEW() verschiedene
Argumente bekommen.
<LI><font color=orange>Das Überladen von Dekonstruktoren ist dagegen </font><font color=red>verboten!</font>
Ein überladener Dekonstruktor kann von DEL() nicht gefunden werden, da eine Übergabe von
Argumenten bei einem Dekonstruktor nicht vorgesehen ist und auch nicht sinnvoll ist!
Wenn vor einem Dekonstruieren besondere Maßnahmen gemacht werden müssen, die im 
normalen Dekonstruktor nichts zusuchen haben , oder nur bei bestimmten Objektkonstruktionen
durchgeführt werden sollen, dann ist eine eigene Methode dafür zuschreiben, die
vor DEL() aufgerufen wird oder der Dekonstruktor besser zu programmieren!
<P>
Ein eventuell später mal gebauter GarbageCollector hätte gar keine Chance ein Objekt korrekt zuzerstören,
wenn es mehrere Dekonstruktoren gäbe!.
<LI> Ein Überladen einer Methode X mit den gleichen Argumenttypen <B>und</B> Namen, führt zum
<B>Überschreiben</B> einer Methode. So lassen sich Methoden einer SuperKlasse in einer 
abgeleiteten Klasse überschreiben, <B>wenn</B> dies <B>nötig</B> ist. 
</UL>
<P>

<CENTER><a href=oop4a.html>Hauptseite</A></CENTER>
<P>


</BODY>
</HTML>
