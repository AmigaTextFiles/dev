; 5/2018 -=ONIX=-
; vasmm68k_mot -Fhunk -kick1hunks -quiet -o dosgv.o dosgv.s
; :ts=8

* Global vector offsets (function entries) launcher

	XREF	_DOSBase

	XDEF	_DosGV

; LONG DosGV( char*/LONG* stack_frame,	 Long word aligned!
;	      LONG gv_index,		 Global vector index, positive
;					 or negative
;	      ... )			 list of variable arguments
;
; va_args:
;	      LONG/APTR/BPTR/BSTR arg1,	 Whatsoever...
;	      LONG/APTR/BPTR/BSTR arg2,
;	      LONG/APTR/BPTR/BSTR arg3,
;	      LONG/APTR/BPTR/BSTR arg4,
_DosGV
	movem.l	D2-D7/A2-A6,-(sp)	; 11 * 4 + 4 = 48 (first arg at 48 sp)
; Only registers D6 and D7 are unused, A3 is used by glue code to remember
; return address, thus its content is destroyed upon entering the service code
; (A5). 

	movea.l	_DOSBase,A5
	movem.l	42(A5),A2/A5-A6		; dl_A2 = 42, dl_A5 = 46, dl_A6 = 50
; A2 - global vector (setup by DOS - DO NOT WRITE TO IT!!!)
; A5 - service code (glue code to invoke Tripos DOS function)
; A6 - cleanup code (glue code to return control from Tripos DOS function to
; callee)

	movea.l	48(sp),A1	; BCPL stack pointer
	movem.l	52(sp),D5	; GV index
	movem.l	56(sp),D1-D4	; arg1 to arg4, pendent arguments
;				  ignored by BCPL compiled functions/routines
	moveq	#12,D0
; D0 - offset BCPL stack frame (min 12 if stack frame points to very first
;				long word!)
; D1 to D4 - arguments to function
; D5 - Global Vector function index
; A1 - BCPL stack frame

; Just need to setup A0 and A4 and we're ready to launch a certain function
 
	suba.l	A0,A0		; Local to BCPL index register, must be
	;			  cleared before any function is called!!!
	asl.w	#2,D5		; BCPL function index as table (vector)
	;			  entry offset (positive or negative)
	movea.l	0(A2,D5.w),A4	; Plus address GV = function's code (code to
	;			  execute)
	jsr	(A5)		; Call service code which in turn executes
	;			  the desired BCPL compiled code (A4)
; Returns with result in D1
	move.l	D1,D0		; Return code to D0

	movem.l	(sp)+,D2-D7/A2-A6
	rts
