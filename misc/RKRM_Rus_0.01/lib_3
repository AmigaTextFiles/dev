@DATABASE Libraries Manual
@NODE MAIN "Amiga® RKM Библиотеки: 3 Intuition Экраны "
@INDEX Lib_Index/MAIN
@TOC Libraries_Manual/User
Экраны Intuition - простейший дисплей, который может сделать Intuition.
Экраны определяют фундаментальные характеристики дисплея, такие как
разрешение и палитра; они открывают среду для множества окон. Эта глава 
рассказывает о том, как использовать уже существующие экраны и, как 
создавать новые.

@{" Типы Экранов " link 3-1}
@{" Overscan и Display Clip " link 3-6}
@{" Структуры Экрана " link 3-2}
@{" Экраны Intuition и Графическая библиотека " link 3-7}
@{" Функции Обычных Экранов " link 3-3}
@{" Продвинутое Программирование Экранов " link 3-8}
@{" Функции Общих Экранов " link 3-4}
@{" Другие Функции " link 3-9}
@{" DrawInfo и 3D Вид " link 3-5}
@{" Справка по Функциям " link 3-10}

@ENDNODE

@NODE 3-1 "3 Intuition Экраны / Типы Экранов"
Экраны определяют разрешение, а также кол-во цветов на дисплее. Как только
экран открыт, его атрибуты не могут быть изменены, поэтому любая графическая
информация ограничена разрешением и глубиной экрана.

С помощью экранов Intuition, @{"дисплей" link Lib_27/27-1-2} может быть создан
в одном из режимов Amiga.  Простейшие параметры дисплея, такие как разрешение,
размеры, частота, поддержка genlock или перемещения экрана, и число цветов - 
всё это определяется режимом дисплея.  Существует четыре простейших режима,
подходящих для любой Amiga.  Они работают с обычными мониторами (частота 
строчной развёртки 15 kHz) и стaрыми @{"версиями" link Lib_1/1-1-4} ОС.


	    Table 3-1: Простейшие Режимы Дисплея Amiga


      Режимы         Максимальное Разрешение Кол-во 
      Дисплея     	 NTSC	    PAL      Цветов	HAM/EHB*
    -------------     ----------  -------    --------	-------
    @{"Lores" link Lib_27/27-1-4}	       320x200	  320x256   32 из 4096    Есть
    Lores-@{"Interlaced" link Lib_27/27-1-3}   320x400	  320x512   32 из 4096    Есть
    @{"Hires" link Lib_27/27-1-4}	       640x200	  640x256   16 из 4096    Нет
    Hires-Interlaced   640x400	  640x512   16 из 4096    нет


    * Режимы @{"HAM" link Lib_27/27-3-4} и @{"EHB" link Lib_27/27-3-3} позваляют 
      получить большее кол-во цветов (с некоторыми ограничениями). 


В ОС Версии 2 стали доступны множество других режимов (обычно требующих
@{"специального монитора" link Lib_27/27-2-9-1} или @{"ECS" link Lib_27/27-1-5}).  Все они
интегрированы в базу данных режимов дисплея в графической библиотеке. Чтобы
ознакомиться с полным списком, см. главу "@{"Графические Примитивы" link lib_27/27-1-4-1}".

@{" Множество Экранов " link 3-1-1}
@{" Общие и Обычные Экраны " link 3-1-2}
@{" Компоненты Экрана " link 3-1-3}

@ENDNODE

@NODE 3-1-1 "3 / Типы Экранов / Множество Экранов"
Все объекты Intuition (как окна и меню) наследуют характеристики дисплея
от экрана.  Эти объекты ограничены разрешением и глубиной, также как и экран,
на котором они действуют. Другие же, такие как палитра, перья и шрифты, также
наследуют их, но могут быть изменены.

На самом деле ограничений нетак много, потому что Amiga может содержать
несколько экранов в памяти одновременно.  Другими словами, каждое приложение
может использовать экран с @{"высоким разрешением" link 3-1 14}(16 цветов),
пока другое приложение пользуется экраном с @{"низким разрешением" link 3-1 14} (32 цвета)
в одно и тоже время.  Обычно экраны захватывают всю видимую область, поэтому
только один видем.  Но экраны могут быть сдвинуты вниз или вверх, или 
перетусованы пользователем (или программой) для @{"перемещения между экранами" link 3-1-3 10}.

@ENDNODE

@NODE 3-1-2 "3 / Типы Экранов / Общие и Обычные Экраны"
Для работы, приложение может выбрать уже открытый экран или создать свой 
собственный.  К примеру, нормальный процесс запуска Amiga открывает экран
Workbench (@{"Workbench" link Lib_14/MAIN} - стандартный GUI для Amiga).  Любое
приложение свободно использовать экран Workbench вместо открытия нового.
Экраны, которые могут быть разделены таким образом называются public-экранами
или общими.

@{"Общие экраны" link 3-4} - новая особенность ОС версии 2 (V36).  В старых @{"версиях" link Lib_1/1-1-4} ОС,
только экран Workbench мог быть разделяемым.  Теперь любой экран может быть
открыт как общий экран, таким образом, другие приложения могут использовать его.

Для того, чтобы использовать уже существующий общий экран, как экран Workbench,
требуется немного усилий от приложения и не требуется памяти.  Однако,
использование Workbench или другой общий экран означает потерю некоторой
гибкости; разрешение цвета и другие атрибуты уже установлены. Если приложение
не может функционировать с такими ограничениями, оно должно иметь свой собственный
обычный экран.

@{"Обычные экраны" link 3-3} позволяют полностью конролировать дисплей, так
приложение может получить точно то, что хочет.  Но такой экран использует память,
и должен быть использован, когда нет подходящих общих экранов.

Владелец обычного экрана может сохранять свой экран приватным, или позволить
другим приложениям разделять его, @{"регистрируя" link 3-4-3} экран у ОС,
как общий.  Поже см. раздел "@{"Функции Общих Экранов" link 3-4-2}".

@ENDNODE

@NODE 3-1-3 "3 / Типы Экранов / Компоненты Экрана"
Экраны имеют немного визуальных объектов, они просто держат область для
помещения других объектов, таких как окна и меню.  Экраны не имеют бордюра.
Только титульная полоса отмечает границы (вообще-то левый верхний край и
ширину экрана), она может быть спрятана, перекрыта графикой или окнами.

Также титульная полоса (title bar) служит @{"полосой меню (menu bar)" link Lib_6/6-1-2},
когда пользователь нажимает правую кнопку мышки.  Полоса меню разделяется 
между всеми приложениями, использующими данный экран.

Внутри титульной полосы есть @{"две кнопки" link Lib_5/5-1-1}: кнопка движения экрана и
кнопка расположения экрана по глубине.  Кнопка движения экрана позволяет
двигать экран вверх-вниз. Другая - помещать экран впереди или позади всех.

    @{" Figure 3-1: Экран Intuition (Workbench) " system "run >NIL: Cats_CD:Utilities/WDisplay Cats_CD:reference_library/lib_pics/3-1.pic"}

Экраны всегда прямоугольны, а области у краёв дисплея, которые находятся вне
экрана имеют цвет заднего плана.  Область над всеми видимыми экранами залита
цветом заднего плана самого верхнего из них.  Эти области, окружающие экран
(обычно не используюшиеся) известны как область overscan.  Система дисплея
Amiga позволяет использовать эту область для графики в определённых
обстоятельствах (см. раздел "@{"Overscan и Display Clip" link 3-6}" дальше
в этой главе).

@ENDNODE

@NODE 3-2 "3 Intuition Экраны / Структура Экрана"
Amiga использует @{"цветовые регистры" link Lib_27/27-1-6 103} и @{"битплан" link Lib_27/27-1-6 33}-организацию
данных дисплея.  Экраны нуждаются в таблице цветов и растре для каждого
битплана.  Эта память, где прорисовывается изображение и впоследствие
транслируется железом в настоящий видео дисплей. Вся эта информация содержется
в структуре графической библиотеки.

@{"ViewPort" link 3-7 4} - основная структура, используемая графической 
библиотекой для изображения экрана. Указатели на каждый битплан экрана
хранятся в структуре @{"BitMap" link 3-7 4}.  Таблица цветов - в структуре,
названной @{"ColorMap" link 3-7 4}.  А информация о режимах рисования и
шрифте - в структуре @{"RastPort" link 3-7 4}.

Структура @{"RastPort" link 3-7 4} - общего назначения, её графическая 
библиотека использует для операция рисования.  Множество функций рисования
Intuition, также берут адрес RastPort в качестве параметра. RastPort содержит
переменные для рисования также, как и указатель на @{"BitMap" link 3-7 4}, говорящий
куда выводить графику.  Смотрите раздел "@{"Графические Примитивы" link Lib_27/27-4-1}".

@{" Структура Экрана Intuition " link 3-2-1}
@{" Другие структуры Экрана " link 3-2-2}

@ENDNODE

@NODE 3-2-1 "3 / Структуры Экрана / Структура Экрана Intuition"
@{"Структуры" link 3-2 7}, упомянутые выше определены в файле <intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN 97}>.
Заметьте, что структура экрана (Screen) содержит примеры структур ViewPort,
RastPort и BitMap.


struct Screen
    {
    struct Screen *NextScreen;
    struct Window *FirstWindow;
    WORD LeftEdge, TopEdge, Width, Height;
    WORD MouseY, MouseX;
    UWORD Flags;
    UBYTE *Title, *DefaultTitle;
    BYTE BarHeight, BarVBorder, BarHBorder, MenuVBorder, MenuHBorder;
    BYTE WBorTop, WBorLeft, WBorRight, WBorBottom;
    struct TextAttr *Font;
    struct ViewPort ViewPort;
    struct RastPort RastPort;
    struct BitMap BitMap;
    struct Layer_Info LayerInfo;
    struct Gadget *FirstGadget;
    UBYTE DetailPen, BlockPen;
    UWORD SaveColor0;
    struct Layer *BarLayer;
    UBYTE *ExtData, *UserData;
    };


В общем, приложению не обязательно обращаться к полям этой структуры; для
манипулирования экраном оно использует функции Intuition. Также, приложения
не устанавливают экран сами; они используют вызов @{"OpenScreen()" link 3-3 6}.
Вот описание некоторых наиболее важных элементов структуры Screen.

LeftEdge, TopEdge
    Эти переменные задают позицию экрана относительно верхнего левого угла
    дисплея монитора (точно так, как в  @{"редакторе установок" link Lib_13/13-2-1 8}) @{"Overscan" link Lib_27/27-1-2-1}.
    Если указывают ниже или правее, они положительны.  Если экран сдвигается
    вверх или влево - отрицательны.  Величины задаются в пикселах. В ОС,
    предшествующей @{"V36" link Lib_1/1-1-4}, LeftEdge игнорируется, а 
    отрицательное значение TopEdge - неправильно.

    Позиция экрана может быть установленна, когда он открывается или позже,
    вызовом функции @{"MoveScreen()" link 3-9-2}. Запомните, что реальная
    позиция экрана на дисплее может неточно совпадать со значениями в полях
    LeftEdge и TopEdge.  Это может послужить причиной неправильного размещения
    окна в экране.  Эта проблема обусловленна тем, что железо ограничивает
    позицию экрана.  Например, экран @{"высокого разрешения" link 3-1 14} может
    быть позиционирован только координатами @{"низкого разрешения" link 3-1 14} одноко
    значения LeftEdge и TopEdge используют разрешение экрана.  Поэтому, когда
    экран показывается, его позиция округляется к позиции, возможной для монитора.

MouseX, MouseY
    Позиция мышки относительно верхнего левого угла экрана.

ViewPort, RastPort, BitMap, LayerInfo
    Действительные примеры @{"структур" link 3-2} графической библиотеки,
    связанных с экраном (не указатели, а структуры).  Для обычного тспользования
    @{"экранов" link 3-3}, эти структуры могут быть проигнорированы.

BarLayer
    Указатель на структуру @{"Layer" link Lib_30/30-1-1}, для @{"заголовка" link 3-1-3}.

WBorTop, WBorLeft, WBorRight, WBorBottom
    Границы окна, см. главу "@{"Intuition Окна" link Lib_4/4-2-6}".

Font
    Щрифт экрана по умолчанию, он может быть использован для рассчёта размеров
    @{"границ окна" link Lib_4/4-2-4 14}, открываемого на экране.

UserData
    Свободно для использования приложением.

Другие элементы структуры Screen обеспечивают информацию о слое загодовка
и атрибутах @{"меню" link Lib_6/6-2-9 5}, @{"окнах" link Lib_4/4-2-4}, открытых на экране.
Особо интересны величины, позволяющие определять размер окон. Эти величины
описаны в разделе "@{"Intuition Окна" link Lib_4/4-2-6}".

@ENDNODE

@NODE 3-2-2 "3 / Структуры Экрана / Другие Структуры"
В добавок к структуре Screen, Intuition использует несколько других, определённых
в файле <intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN}> и
<utility/@{"tagitems.h" link Includes/utility/tagitems.h/MAIN}>.  (См. Amiga ROM Kernel Reference Manual:
Includes and Autodocs.)


      Table 3-2: Структуры Данных, используемые в Экранах Intuition


  Имя Структуры   Описание			 Определно в файле #?.h
  --------------  -----------			 -----------------------
  @{"Screen" link 3-2-1}	  Основная структура,		<intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN 97}>
		  определяющая экран (см. выше)

  @{"DrawInfo" link 3-5}	  Содержит перо, шрифт		<intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN 60}>
		  и аспект для Intuition

  @{"TagItem" link lib_37/37-1-1}	  Параметр общего назначения	<utility/@{"tagitem.h" link Includes/utility/TagItem.h/MAIN 31}>
		  используемый для открытия
                  экранов в V36

  NewScreen	  Структура-параметр для	<intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN 309}>
		  создания экрана в V34

  ExtNewScreen	  Расшерение NewScreen   	<intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN 345}>
		  в V37 для обратной 
                  совместимости со старыми ОС


Как @{"упоминалось ранее" link 3-2}, для каждого экрана в памяти существует 
структура Screen (и соответствующая структура @{"ViewPort" link  3-7 4}).
В ОС Версии 2, всякий раз, когда открывается экран, Intuition создаёт 
вспомогательную структуру, названную DrawInfo.

Структура @{"DrawInfo" link 3-5} подобна @{"RastPort" link 3-7 4}. Но RastPort
используется для низко-уровневой графики, а DrawInfo для высоко-уровневой
графики Intuition. Также, DrawInfo содержит данные, нужные для обеспечения 
Нового Вида Intuition в ОС Версии 2.  (См. "@{"DrawInfo и 3D Вид" link 3-5}".)

Следущая новая особенность Версии 2 - @{"тэги" link Lib_37/37-1}. @{"Тэги" link Lib_37/37-1-1} - это
структура общего назначения, используемая для передачи аргументов для большого
числа функций ОС Версии 2.  Каждый тэг состоит из LONG ID (@{"ti_Tag" link Lib_37/37-1-1 9}) и LONG-
величины (@{"ti_Data" link Lib_37/37-1-1 9}).  С экранами, тэги используются
для описания атрибутов. Тэги заменяют структуру NewScreen.

Приложения могут использовать тэги вместо структуры @{"NewScreen" link Includes/intuition/screens.h/MAIN 309}, т.к.
тэги часто более удобны.  Ради совместимости, введена структура @{"ExtNewScreen" link Includes/intuition/screens.h/MAIN 345}.
ExtNewScreen объединяет метод NewScreen, используемый для старых ОС, и тэговый
метод ОС Версии 2.  @{"Примеры" link 3-3-1-1}, предложенные в следующем разделе, показывают,
как эти структуры могут быть использованы для открытия экрана.

@ENDNODE

@NODE 3-3 "3 Intuition Экраны / Функции Обычных Экранов"
Любому приложению нужен экран для работы.  Он может уже существовать,
@{"общий экран" link 3-4} или приложение создаст себе новый, обычный.
Для создания обычного экрана, вы должны вызвать OpenScreen() или один из
её вариантов.


		 Table 3-3: Функции Обычных Экранов
  ______________________________________________________________________
 |								       	|
 |     @{"OpenScreenTags()" link intuition/OpenScreenTags()}   Создаёт экран с помощью списка тэгов.		|
 |  @{"OpenScreenTagList()" link intuition/OpenScreenTagList()}  Использует оба метода				|
 |			 получения атрибутов.			       	|
 |								       	|
 |	   @{"OpenScreen()" link intuition/OpenScreen()}  Создаёт экран с помощью структуры		|
 |			 @{"ExtNewScreen" link 3-2-2 6}.  Используется для		|
 |			 совместимости с ОС 1.3 (V34) 		       	|
 |								       	|
 |	  @{"CloseScreen()" link 3-3-1-4}  Закрывает экран и освобождает память.     	|
 |______________________________________________________________________|


@{" Создание Обычного Экрана " link 3-3-1}
@{" Атрибуты Экрана " link 3-3-2}

@ENDNODE

@NODE 3-3-1 "3 / Функции Обычных Экранов / Создание Нового Обычного Экрана"
Есть три функции, которые вы можите использовать для создания и открытия 
@{"обычного экрана" link 3-3}: @{"OpenScreen()" link 3-3 6}, @{"OpenScreenTags()" link 3-3 6} или
@{"OpenScreenTagList()" link 3-3 6}.	До Версии 2 (V36), использовалась
OpenScreen().  Теперь она заменена OpenScreenTagList() и OpenScreenTags().

   struct Screen *OpenScreen( struct NewScreen *)
   struct Screen *OpenScreenTagList( struct NewScreen * , struct TagItem *)
   struct Screen *OpenScreenTags( struct NewScreen *, ULONG, ULONG, ... )

Старая @{"OpenScreen()" link 3-3 6} полагается на фиксированный размер
структуры (@{"NewScreen" link 3-2-2 6}), что не увеличивает возможность для расширения.
Новые функции базируются на тэгах, позволяют добавлять новые возможности без
модификации существующих структур и приложений. Раздел "@{"Атрибуты Экрана" link 3-3-2}"
(ниже) содержит полный список всех тэгов, доступных для установки экрана.
Для общего ознакомления с тэгами, смотрите главу "@{"Библиотека Utility" link Lib_37/37-1}".

@{" Пример Обычного Экрана " link 3-3-1-1}
@{" Создание Обычного Экрана, Работающего со Старыми ОС " link 3-3-1-2}
@{" Значения, возвращаемые OpenScreenTagList() " link 3-3-1-3}
@{" Закрытие Экрана " link 3-3-1-4}

@ENDNODE

@NODE 3-3-1-1 "3 / / Создание Нового Обычного Экрана / Пример Обычного Экрана"
Существует довольно много тэгов, связанных с экранами. Перед тем, как идти
дальше, будет полезно разобрать небольшой пример. Программа открывает новый,
@{"обычный экран" link 3-3}, используя @{"OpenScreenTags()" link 3-3 6}.
Пример использует всего два тэга (@{"SA_Depth" link 3-3-2 65} и @{"SA_Pens" link 3-3-2 82}), которые
обеспечивают минимум атрибутов для открытия экрана, использующего новый "@{"3D Вид" link 3-5}"
Intuition; и возможный в ОС Версии 2.

    @{" newlookscreen.c " link lib_examples/newlookscreen.c/MAIN}

Пример выше запускается только под ОС2 (V36) и более поздних версий ОС.
Для того, чтобы создать @{"обычный экран" link 3-3} на @{"обоих" link 3-3-1-2} версиях,
используйте оригинальную функцию @{"OpenScreen()" link 3-3 6}.

Структура @{"NewScreen" link 3-2-2 6}, используется с @{"OpenScreen()" link 3-3 6}, была расширина
тэгами в V36, для формирования @{"ExtNewScreen" link 3-2-2 6}.  Это сделано установкой
бита NS_EXTENDED в поле Type структуры NewScreen и добавлением указателя на
массив тэгов в конце структуры.  Бит NS_EXTENDED игнорируется на старых ОС,
таким образом тэги прозрачны для приложения и дополнительные возможности 
появляются, когда приложение запускается под ОС V36 и больше.
См. @{"OpenScreen()" link intuition/OpenScreen()} Autodocs и include-файл <intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN}>
для большей информации о флаге NS_EXTENDED и структуре ExtNewScreen.

@ENDNODE

@NODE 3-3-1-2 "3 / / / Создание Обычного Экрана, Работающего со Старыми ОС"
А вот пример, как использовать старую @{"OpenScreen()" link 3-3 6} со структурой
@{"ExtNewScreen" link 3-2-2 6}, для создания @{"обычного экрана" link 3-3} под любой версией
операционной системы.  Если версия V36 или выше, экрана будет 3D Вида.

    @{" screen34to37.c " link lib_examples/screen34to37.c/MAIN}

Как вы уже могли убедиться, существует много способов создания @{"обычных экранов" link 3-3}.
Дальнейшее описание "@{"OpenScreenTagList()" link 3-3 6}" в этом пособии
относится в равной степени и к @{"OpenScreenTags()" link 3-3 6}, и к @{"OpenScreen()" link 3-3 6}.

@ENDNODE

@NODE 3-3-1-3 "3 / / Создание Обычного Экрана / Значения, возвращаемые OpenScreenTagList()"
@{"OpenScreenTagList()" link 3-3 6} и её варианты возвращают указатель на структуру 
@{"Screen" link 3-2-2 6}, если созддание успешно и NULL если нет. В V36 эта функция
поддерживает коды ошибок. Он указывает на тип ошибки. Для получения такого кода,
вам необходимо использовать тэг @{"SA_ErrorCode" link 3-3-2 14}; код будет помещён
в ячейку, указываемую полем @{"TagItem.ti_Data" link Lib_37/37-1-1 9}. 
Вот все такие коды:

OSERR_NOMONITOR
    Монитор, нужный для получения запрошенного дисплея недоступен. Примером
    такой ошибки может стать попытка открытия экрана с режимом Productivity
    на системе без VGA или multisync монитора.

OSERR_NOCHIPS
    Для этого режима экрана нужен более новый чипсет.  Например, ECS Denise
    необходим для обеспечения @{"режимов productivity" link Lib_27/27-1-5-2}.

OSERR_NOMEM
    Не удаётся выделить память.

OSERR_NOCHIPMEM
    Нельзя выделить достаточно Chip памяти.

OSERR_PUBNOTUNIQUE
    Нельзя создать @{"общий экран" link 3-4-3}--такое имя уже есть. Система
    требует уникальных имён общих экранов.

OSERR_UNKNOWNMODE
    Не определён режим дисплея.	ОС не понимает значение в тэге @{"SA_DisplayID" link 3-3-2 74}.

@ENDNODE

@NODE 3-3-1-4 "3 / / Создание Нового Обычного Экрана / Закрытие Экрана"
Когда приложение закончило использовать экран, память, которую занимал экран,
надо вернуть системе, вызывая функцию @{"CloseScreen()" link intuition/CloseScreen()}.
Как правило, приложение должно закрывать талько те экраны, которые оно открыло.
Под V34 и ниже CloseScreen() не возвращает ничего.А под Версией 2 - булевскую
переменную (TRUE в случае успеха и FALSE в случае ошибки). CloseScreen()
может провалиться, если экран @{"общий" link 3-4} и другая задача ещё его
использует.

@ENDNODE

@NODE 3-3-2 "3 / Функции Обычных Экранов / Атрибуты Экрана"
В предъидущих разделах рассказавалось лишь только о простейших функциях и
типах экранов, о которых программисту необходимо знать.
Intuition содержит удивительное число дополнительных особенностей дисплея и
опций.  В этом разделе, а также в последующих, описаны атрибуты экрана и 
функции, контролирующие их.

Атрибуты экрана определяются с помощью тэгов, подробно описанных в главе
"@{"Библиотека Utility" link Lib_37/37-1-2}". В общем, тэги переопределяют
поля структуры NewScreen, если таковая имеется.

SA_ErrorCode
    Код ошибки.  Поле тэга Data - указатель на LONG, которое будет содержать
    код ошибки, если @{"OpenScreenTagList()" link 3-2-2 6} вернёт NULL. 
    Кода описаны выше.

SA_Left, SA_Top
    Начальная позиция экрана (левый и правый края).  Data - LONG (знаковое)
    Смещение относительно текстового overscan.

    Если SA_Left не указан и структура @{"NewScreen" link 3-2-2 6} не передана
    @{"OpenScreenTags/TagList()" link 3-3 6}, и не указан SA_Width или 
    указан, как STDSCREENWIDTH, тогда левый край экрана устанавливается по 
    умолчанию к левому краю дисплея. В других случаях, но когда точно указан
    SA_Width, левый край становится нулевым (левый край прямоугольника 
    тектового overscan).  Также и с верхним краем. До V36, левая позиция
    игнорировалась, а отрецательная верхняя была недопустима.

    Когда открывается полноразмерный экран, SA_Left должен быть минимальным
    по X значением в @{"Прямоугольнике" link Lib_29/29-3 49} дисплея, а
    SA_Top - минимальным по Y.  Это можно получить по умолчанию, как говорилось
    ранее или указать явно.  См. раздел "@{"Overscan и Display Clip" link 3-6}" и
    @{"OpenScreen()" link intuition/OpenScreen()} Autodoc.

    Если ваш экран больше дисплея, вы можете установить в SA_Left и SA_Top
    значения меньшие, чем MinX и MinY у дисплея. Пример этому @{"screen.c" link modules/screen.c/MAIN}
    в Приложение IFF Amiga ROM Kernel Reference
    Руководство: Devices.

SA_Width, SA_Height
    Размеры экрана. Data - LONG (беззнаковое).  Может быть больше или меньше,
    чем размеры дисплея. Использование STDSCREENWIDTH и STDSCREENHEIGHT 
    сделает размер экрана равным размеру дисплея.

    Для вычисления ширины @{"Прямоугольника" link Lib_29/29-3 49} дисплея,
    вычитайте MinX из MaxX+1. Соответственно с высотой.

SA_Depth
    Глубина битмэпа экрана.  Data - LONG (беззнаковое).  Глубина экрана
    определяет число цветов.  См. "@{"Графические Примитивы" link Lib_27/27-1-6 95}" для информации
    о ограничениях дисплея. Не ставте глубину больше, чем можно на данном 
    дисплее. Эта информация доступна приложению через базу данных на дисплеи
    графической библиотеки. По умолчанию глубина 1 битплан.

SA_DisplayID
    Режим дисплея экрана.  Data - LONG (беззнаковое).  Используя базу данных
    по дисплеям ОС 2, приложения могут открывать экрана в любом режиме, доступном
    системе пользователя, включая PAL и NTSC.  См. обсуждение базы данных по
    дисплеям в главе "@{"Графические Примитивы" link Lib_27/27-2-9-7}" и
    include-файле <graphics/@{"displayinfo.h" link Includes/graphics/displayinfo.h/MAIN}>.

SA_Pens
    Цвета пера на экране.  Data - указатель на массив WORD (беззнаковых),
    заканчивующийся ~0, так как в структуре @{"DrawInfo" link 3-2-2 6}.
    Указание этого тэга автоматически включает 3D Вид. См. "@{"DrawInfo и 3D Вид" link 3-5-1}".
    Пропуск сделает экран плоским, но использование цветов более удобно.

SA_DetailPen
    Цвет пера для деталий. Data - LONG (беззнаковое). Используется для
    рисование различных деталий заголовка экрана и меню.  Для более глубокого
    контроля используйте SA_Pens (V36).  Если SA_Pens не указан, экран не 
    получит новый 3D вид.

SA_BlockPen
    Цвет пера для блоков.  Data - LONG (беззнаковое).	Используется для
    заливки заголовка экрана и меню.  Для более глубокого контроля используйте
    SA_Pens (V36).  Если SA_Pens не указан, экран не получит новый 3D вид.


SA_Title                                                                  
    Заголовок экрана.  Data - указатель на строку.  Этот заголовок возникает,
    когда активное окно не имеет заголовка экрана или когда нет активных окон.

SA_Colors
    Определяет начальные цвета в палитре экрана.  Data - указатель на массив
    структур @{"ColorSpec" link Includes/intuition/intuition.h/MAIN 1241}, заканчивующийся
    ColorSpec с полем ColorIndex=-1. Цвета экрана могут изменяться после его
    открытия с помощью функции графической библиотеки  @{"SetRGB4()" link Lib_27/27-2-7-5} и @{"LoadRGB4()" link Lib_27/27-2-7-5}.
    Цвета в ColorSpec - младшие биты ( по 4 на каждую пушку).

SA_FullPalette
    Инициализирует полную таблицу цветов (32 цвета начиная с V36), а именно
    цвета 0-3, 17-19, и др. Data - булевская переменная. По умолчанию FALSE.

SA_Font
    Data - указатель на структуру @{"TextAttr" link Lib_29/29-2-1 21} (определённую в
    <graphics/@{"text.h" link Includes/graphics/text.h/MAIN 65}> ), которая
    определяет шрифт, его размер и стиль для использования на экране.
    Тоже, что и @{"NewScreen.Font" link 3-2-1 76}.

SA_SysFont
    Альтернатива SA_Font.  Выбирает один из установленных системных шрифтов.
    Data - LONG (беззнаковое), следующие заначения:

	0  Экран с фиксированным шрифтом. (по умолчанию).
	1  Экран с пропорциональным шрифтом.

    Экран Workbench открывается с {SA_SysFont , 1}.  Таблица 3-4 показывает,
    как выбрать шрифт во время @{"OpenScreen()" link 3-3 6}.


		Table 3-4: Выбор Шрифта для Intuition

       То, что в
       @{"OpenScreen()" link 3-3 6}	       Экранный шрифт	      Window.RPort шрифт
       -------------	       -----------	      -----------------
    A. @{"NewScreen" link 3-2-2 6}.Font=myfont  myfont		      myfont
    B. NewScreen.Font=NULL    GfxBase->DefaultFont    GfxBase->DefaultFont
    C. {SA_Font, myfont}      myfont		      myfont
    D. {SA_SysFont, 0}	      GfxBase->DefaultFont    GfxBase->DefaultFont
    E. {SA_SysFont, 1}	      Font.Prefs (Screen)     GfxBase->DefaultFont

       Замечание:
     * A и B есть и в V34 и в более ранних ОС.
     * C и D - тэги Версии 2 и эквивалентны A и B соответственно.
     * E - новая опция для V36.  Workbench использует эту опцию.
     * В качестве `myfont' может использоваться любой, даже пропорциональный
       шрифт, на всех версиях ОС.
     * GfxBase->DefaultFont всегда фиксированный.  (Это "System Default Text"
       в Установок Шрифтов)
     * Font Prefs Screen text ( "Screen Text" в Установок Шрифтов) может быть
       пропорциональным.


    Шрифт экрана легально нельзя сменить. Меню, окна, строки все они используют
    шрифт экрана. Шрифт, используемый в пунктах меню, может бфть переопределён
    в их структуре @{"IntuiText" link Lib_8/8-4-1}. После V36 шрифт строки,
    также можно переопрелить в структуре @{"StringExtend" link Lib_5/5-12-7}.
    Шрифт заголовка меню и окон переопределить нельзя.

    Шрифт @{"Window.RPort" link Lib_4/4-6 66} - начальный шрифт, который
    устанавливает Intuition в @{"RastPort" link Lib_4/4-2 8} ваших окнах.
    Он вполне легально изменяется @{"SetFont()" link Lib_29/29-2-1}. @{"IntuiText" link Lib_8/8-4-1} 
    прорисовывается в окно (или через @{"PrintIText()" link Lib_8/8-4-2}, или как кнопки @{"GadgetText" link Lib_5/5-9 111}) 
    по умолчанию шрифтом RastPort окна, но можно использовать @{"ITextFont" link Lib_8/8-4-1 59} для
    его переопределения.  Текст выводится функцией графической библиотеки
    @{"Text()" link Lib_29/29-2}, которая использует шрифт RastPort'а.

SA_Type
    Тоже, что и биты SCREENTYPE поля @{"NewScreen" link 3-2-2 6}.Type.
    Data - LONG (беззнаковое), может быть CUSTOMSCREEN или PUBLICSCREEN
    (WBENCHSCREEN - зарезервированно для ОС).  Смотрите тэги SA_BitMap,
    SA_Behind, SA_Quiet, SA_ShowTitle и SA_AutoScroll о других битах
    поля NewScreen.Type.

SA_BitMap
    Использовать заказной битмэп.  Data - указатель на структуру @{"BitMap" link 3-7 4}.
    Тэг эквивалентен @{"NewScreen" link 3-2-2 6}.CustomBitMap и флагу CUSTOMBITMAP
    в NewScreen.Type. Приложение должно открыть и закрыть такой битмэп само.

SA_Behind
    Открывать экран позади остальных.  Data - булевская переменная.  
    Тоже, что и флаг SCREENBEHIND в @{"NewScreen" link 3-2-2 6}.Type.

SA_Quiet
    Отключает вывод Intuition в экран.  Data - булевская переменная.
    Эквивалентно флагу SCREENQUIET в @{"NewScreen" link 3-2-2 6}.Type. Экран
    не будет иметь видимого заголовка или кнопок, но тоскать и сортировать
    можно. Для полного запрета вывода в экран, операции с меню нужно
    заблокировать, устанавливая для окон флаг WFLG_RMBTRAP.

SA_ShowTitle
    Распологать заголовок поверх всех задних окон. Data - булевская переменная.
    Тоже, что и флаг SHOWTITLE поля @{"NewScreen" link 3-2-2 6}.Type. Заголовок
    всегда виден позади всех обычных окон. Этот атрибут можно изменить с
    помощью функции @{"ShowTitle()" link 3-9-3 10}.

SA_AutoScroll
    Установка этого флага включает autoscroll, когда экран активен.
    (Пока, экран может быть активизирован только выбором на нём окна, приложением
    или пользователем). Data - булевская переменная.  Этот тэг - эквивалент
    флага AUTOSCROLL в @{"NewScreen" link 3-2-2 6}.Type.

    Autoscroll означает, что экран, больший, чем дисплей, будет автоматически
    прокручиваться, когда пользователь переместит мышку к краю экрана.
    Без этого тэга пользователь может перемещать экран с помощью drag bar или
    нажимая левую кнопку и левую кнопку Amiga, и передвигая мышку.

SA_PubName
    Появление этого тэга подразумевает, что экран будет @{"общим" link 3-4-3}.
    Data - указатель на строку.  Строка - имя общего экрана, которое используется
    другими приложениями для его нахождения. Этот тэг применияется до SA_PubSig
    и SA_PubTask.

SA_PubSig, SA_PubTask
    ID задачи (возвращённый @{"FindTask()" link Lib_21/21-8 5}) и сигнал для извещения
    приложения о закрытие последнего окна на @{"общем экране" link 3-4}.
    Data для SA_PubSig - LONG (беззнаковое). Data для SA_PubTask - указатель
    на структуру @{"Task" link Lib_21/21-1}. Эти тэги зависят от порядка
    появления в списке и должны указываться после SA_PubName.

SA_Overscan
    Устанавливает один из OSCAN_ спецификаторов для использования стандартных
    системных overscan дисплеев и размеров экрана.  Data - LONG (беззнаковое).
    Не используйте этот тэг вместе с SA_DClip.  SA_Overscan используется для
    получения стандартного размера overscan, тогда как SA_DClip - для
    произвольного размера. Если клип дисплея не определён, по умалчанию он
    @{"OSCAN_TEXT" link 3-6-1 12}.  
    См. раздел ниже о "@{"Overscan и Display Clip" link Lib_3/3-6-1}".

SA_DClip
    Спецификация клипа (clip) дисплея.	Data - указатель на структуру @{"Rectangle" link Lib_29/29-3 49},
    которая определяет этот регион.

@ENDNODE

@NODE 3-4 "3 Intuition Экраны / Функции Общих Экранов"
Общие экраны - новая особенность ОС Версии 2 (V36).  Общий экран позволяет
нескольким приложениям разделять его, сохраняя память. Если ваше приложение
открывает общий экран, тогда другие приложения могут открывать на нём свои
окна.  В старых версиях ОС, только экран Workbench мог быть раздделён между
программами, которые должны были жить в его рамках или использывать Chip память
для создания своих собственных экранов - @{"обычных" link 3-3}.

Теперь система позволяет вам открывать экран как общий, поэтому может быть
несколько таких экранов, не только Workbench.  Это позволяет пользователю
устанавливать различные рабочие среды для приложений (каждая с подходящим 
режимом дисплея ).

Workbench - особый случай общиего экрана, потому что он первоначальный общий
экран.	По умолчанию, если не указывается имя экрана, приложения получают
доступ именно к этому экрану. Обычно Workbench открывается системой во время
запуска.  Однако, помните, что основной общий экран (экран по умолчанию) может
быть изменён (это невсегда будет Workbench).

    Экраны для Новичка.
    -------------------
    Если вы не уверены, какой тип экрана использовать, тогда вам нужен
    общий экран по умолчанию.  Под ОС 2, вы можете открывать окна на таком
    экране без установки самого экрана.  См. главу "@{"Intuition Окна" link Lib_4/4-2-3}".

Вообще, гораздо удобнее использовать существующий общий экран, чем открывать
свой собственный.  Вот простейшие функции для работы с такими экранами.


		Table 3-5: Функции Общего Экрана
  ______________________________________________________________________
 |									|
 |	  @{"LockPubScreen()" link intuition/LockPubScreen()}  Найти Workbench или другой общий экран;	|
 |			   защитить от закрытия, пока окно открыто.	|
 |									|
 |	@{"UnlockPubScreen()" link intuition/UnlockPubScreen()}  Открыть замок, позволяющий		 	|
 |			   экрану закрыться.				|
 |									|
 |  @{"SetDefaultPubScreen()" link intuition/SetDefaultPubScreen()}  Установить общий экран по умолчанию.		|
 |									|
 |  @{"GetDefaultPubScreen()" link intuition/GetDefaultPubScreen()}  Копирует имя экрана в			|
 |			   буфер для использования его		 	|
 |			   (это имя не нужно обычным приложениям, 	|
 |			   вместо этого используйте LockPubScreen(NULL).|
 |									|
 |	@{"PubScreenStatus()" link intuition/PubScreenStatus()}  Изменяет статус экрана.			|
 |									|
 |    @{"SetPubScreenModes()" link intuition/SetPubScreenModes()}  Управляет глобальными режимами экрана. 	|
 |______________________________________________________________________|


Используя существующий общий экран, приложение больше не ответсвенно за установку 
его дисплея, тем не менее, оно теряет гибкость и контроль. Оно больше не изменяет
палитру или глубину и не может выводить прямо на экран без разрешения владельца
экрана. (Если эти ограничения слишком большие для приложения, оно может открыть
себе новый экран.)

@{" Доступ к Общему Экрану по Имени " link 3-4-1}
@{" Общий Экран по умолчанию и Workbench " link 3-4-2}
@{" Объявление Нового Обычного Экрана Общим " link 3-4-3}
@{" Поиск в Списке Общих Экранов " link 3-4-4}

@ENDNODE

@NODE 3-4-1 "3 / Функции Общих Экранов / Доступ к Общему Экрану по Имени"
Основные функции доступа к @{"общему экрану" link 3-4} - @{"LockPubScreen()" link 3-4 34} и
@{"UnlockPubScreen()" link 3-4 34}. Для использования этих функций вам нужно
знать имя общего экрана, к которому вы хотите получить доступ. Если вы его не
знаете или не уверены, вы можете запереть общий экран по умолчанию, используя
LockPubScreen(NULL).

    struct Screen *LockPubScreen( UBYTE * )
     VOID	 UnlockPubScreen( UBYTE * , struct Screen *)

Эти вызовы позволяют приложению определить наличие @{"общего экрана" link 3-4} и
гарантировать его существование, пока на нём открыто её окно. Также можно 
получить параметры экрана с помощью @{"GetScreenData()" link 3-9-3 20} ещё из V34
благодаря структуры @{"Screen" link 3-2-2 6}.

Всегда отпирайте @{"общий экран" link 3-4}, когда всё сделали. Помните, что
если на экране открыто окно, то ненужно его запирать.

Замки на экраны не должны удерживаться без причины.  

Есть простой пример, как найти @{"общий экран Workbench" link 3-4-2}, используя
@{"LockPubScreen()" link 3-4 34} и @{"UnlockPubScreen()" link 3-4 34}.

    @{" pubscreenbeep.c " link lib_examples/pubscreenbeep.c/MAIN}

@ENDNODE

@NODE 3-4-2 "3 / Функции Общих Экранов / Общий Экран по умолчанию и Workbench"
Как упоминалось ранее, Workbench - особый случай @{"общего экрана" link 3-4}, ведь
он первоначальный общий экран по умолчанию.  Есть ещё несколько причин его
особенности. Обычно, он - первое, что видит пользователь, потому что он начальный
интерфейс на всех компьютерах Amiga. Пока  Workbench единственный общий экран
для системный Настроек (Preferences) и экран, который Intuition может открыть
автоматически.

Из-за такого тесного взаимодействия с ОС, введены ещё несколько дополнительных функций
для манипуляции Workbench.  Одна из них контролирует и Workbench, и другие
@{"общие экраны" link 3-4} - @{"SetPubScreenModes()" link 3-4 34}.  Эта функция
конролирует глобальный режим общего экрана, SHANGHAI и POPPUBSCREEN.  Если бит
SHANGHAI установлен, старые приложения, которые ожидали Workbench, будут
использовать экран по умолчанию (которым может быть или нет Workbench). Бит
POPPUBSCREEN говорит будет ли общий экран возникать впереди, когда на нём
открывается окно.  Эти режимы описаны в главе "Intuition Окна" в разделе
"@{"Окна и Экраны" link Lib_4/4-2-3 48}".

Есть и другие функции для контроля экраном Workbench.


	   Table 3-6: Функции Общего Экрана Workbench
  ______________________________________________________________________
 |									|
 |    @{"WBenchToBack()" link intuition/WBenchToBack()}  Помещает Workbench позади всех остальных.		|
 |									|
 |   @{"WBenchToFront()" link intuition/WBenchToFront()}  Помещает Workbench впереди всех остальных экранов.|
 |									|
 |   @{"OpenWorkBench()" link intuition/OpenWorkBench()}  Отркывает экран Workbench.  Если экран уже открыт,|
 |		      вызов не имеет эффекта.  Этот вызов пробуждает	|
 |		      приложения, которые были активны до вызова	|
 |		      CloseWorkBench().					|
 |									|
 |  @{"CloseWorkBench()" link intuition/CloseWorkBench()}  Пытается освободить память, занятую Workbench.	|
 |		      Если удачно, эта функция закрывает экран и 	|
 |		      усыпляет приложения Workbench.			|
 |		      Вызов проваливается, если какое-то приложение	|
 |		      имеет открытое окно, или замок на Workbench.	|
 |______________________________________________________________________|


Программы, закрывшие Workbench, должны открыть его (OpenWorkBench()), как только
они закончат работу или позволят пользователю сделать это по его усмотрению
через меню или кнопку.

Если Workbench закрыт, то любое из перечисленных далее событий может открыть
его: вызов OpenWorkBench(); открытие окна на Workbench (включая @{"EasyRequests()" link Lib_7/7-4},
такой как запрос DOS "Insert Disk"); вызов @{"LockPubScreen" link 3-4 34}("Workbench");  
вызов LockPubScreen(NULL), когда Workbench - @{"общий экран" link 3-4} по умолчанию.

@ENDNODE

@NODE 3-4-3 "3 / Функции Общих Экранов / Объявление Нового Обычного Экрана Общим"
Приложение, которое открывает новый экран, может объявить его @{"общим" link 3-4}.
Если характеристики экрана не слишком экзотичны, вполне оправдано позволить
другим приложениям разделять его рабочее пространство. Это делает приложение
более мощьным и привлекательным, потому что оно позволяет пользователю 
добавлять программы и утилиты для настройки и интегрирования рабочей среды.

Для переделки вешего @{"обычного экрана" link 3-3} в @{"общий" link 3-4}, который
могут использовать другие программы, вам надо его назвать и зарегистрировать
у Intuition.  Экран должен быть объявлен, как общий в вызове @{"OpenScreenTagList()" link 3-3 6}
указанием строки в тэге @{"SA_PubName" link 3-3-2 234}. Когда экран открывается,
ID задачи приложения и сигнальный бит могут быть также зарегистрированы тэгами
@{"SA_PubTask и SA_PubSig" link 3-3-2 240}.  Если присутствуют данные тэги,
система сигнализирует вашу задачу о закрытие последнего окна.

Когда новый @{"общий экран" link 3-4} открыт, он не является приватным, потому
программе надо выполнять любые инициализирущие действия (например, открытие
фонового окна) до того, как экран будет объявлен общим.  Можно использовать
@{"PubScreenStatus()" link 3-4 34} для объявления экрана общим (или приватным).
Статус эркан не может быть изменён до того, как все окна и замки не быдут 
закрыты.  Как правило, экран не обязательно делать приватным перед тем, как
закрыть.

@{"CloseScreen()" link 3-3-1-4} вызвать не удасться, если @{"общий экран" link 3-4}
имеет окна или замки.	Если пользователь решит закрыть экран, но это нельзя
сделать, необхлдимо информировать его реквестором и предложить закрыть все окна.

@ENDNODE

@NODE 3-4-4 "3 / Функции Общих Экранов / Поиск Общего Экрана в Списке"
Существуют три подхода получения доступа к @{"общему экрану" link 3-4}.
Замкнуть общий экран @{"LockPubScreen" link 3-4 34}(NULL) или {@{"WA_PubScreenName" link Lib_4/4-7-2 129} , NULL}.

Еслм известно имя экрана, приложение может использовать @{"LockPubScreen()" link 3-4 34}
для получения замка на экран, как показано в @{"примере" link Lib_examples/pubscreenbeep.c/MAIN 28}
(или @{"OpenWindowTagList()" link Lib_4/4-2-1} с тэгом @{"WA_PubScreenName" link Lib_4/4-7-2 129},
как описано в главе "@{"Intuition Окна" link Lib_4/4-2-3 13}").  Невозможность
замыкания экрана или открытия окна показывает, что экран не существует.

Третий способ - поиск @{"общего экрана" link 3-4} в списке по каким-либо
требованиям.  Которые могут относиться к имени или атрибутам экрана. Вот 
функции для подобной работы.

		Table 3-7: Функции Списка Общих Экранов
  _____________________________________________________________________
 |								       |
 |    @{"LockPubScreenList()" link intuition/LockPubScreenList()}  Замыкает список экранов Intution, для того, |
 |			   чтобы можно было его скопировать.           |
 |								       |
 |  @{"UnlockPubScreenList()" link intuition/UnlockPubScreenList()}  Размыкает список.   		      	       |
 |								       |
 |	  @{"NextPubScreen()" link intuition/NextPubScreen()}  Ищет следующий экран.		       |
 |			   					       |
 |_____________________________________________________________________|


Основная функция обращения к списку @{"общих экранов" link 3-4} - это @{"LockPubScreenList()" link intuition/LockPubScreenList()}.
Эта функция, предназначенная для использования утилитой типа менеджера экранов,
закрывает список, позволяя копировать из него данные. Этот список хранится 
как Exec List, с записями @{"PubScreenNode" link Includes/intuition/screens.h/MAIN 381}.
О деталях смотрите <intuition/@{"screens" link Includes/intuition/screens.h/MAIN}>.

Не обращайтесь к списку, пока он заперт, лучше скопируйте, что нужно и снимите
замок.	Все данные необходимо скопировать, включая имя экрана, которое не 
является частью структуры записи в списке. Указатели структур списка не 
действительны после снятия замка на список. Как только замок снят, указатели
могут быть проверены на равенство другим экранам, но нельзя обращатся к
структурам, на которые они указывают. После размыкания списка с помощью
@{"UnlockPubScreenList()" link intuition/UnlockPubScreenList()},приложение может обращаться к данным структуры экрана,
замыкая теперь экран вызовом @{"LockPubScreen()" link 3-4 34} с именем экрана
в качестве параметра.

Приложению понадобятся только три поля структуры @{"PubScreenNode" link Includes/intuition/screens.h/MAIN 381}:
ln_Name, psn_Screen и psn_Flags. Имя  @{"общего экрана" link 3-4} содержится в
поле ln_Name. Доступ с другой информации экрана может быть после получения
замка на экран по имени. Указатель на структуру @{"Screen" link 3-2-2 6} содержится в
в psn_Screen и может использоваться только для проверки, никогда не обращайтесь
к структуре экрана через этот указатель. Наконец, флаги общего экрана находятся в
поле psn_Flags. Пока, определён только один PSNF_PRIVATE.  PSNF_PRIVATE показывает,
что экран сейчас необщий (приватный).

Помните, что вся информация в списке @{"обших экранов" link 3-4} непостоянна и
может изменяться в любое время. Единственный способ определить наличие или
режим экрана - замкнуть его напрямую @{"LockPubScreen()" link 3-4 34} или открыть
на нём окно. Для обновления копии списка, замкните его снова. Не забудте снять
потом замок.

Альтернативный способ обращения со списком @{"общих экранов" link 3-4} - @{"NextPubScreen()" link intuition/NextPubScreen()}.
Параметром этой функции является имя экрана, а возвращает она имя следующего
в списке экрана. Так можно собрать имена всех общих экранов в системе. Не
забывайте, что список подвержен неожиданным изменениям; задача, которая имеет
экран, может закрыть его после того, как вы получили его имя и до того, как
получили (точнее не получили) доступ к нему.

Всегда вызывайте @{"LockPubScreen()" link 3-4 34} для получения доступа к информации
после нахождения @{"общего экрана" link 3-4} в списке.

@ENDNODE

@NODE 3-5 "3 Intuition Экраны / DrawInfo и 3D Вид"
В Версии 2, всякий раз, когда создаётся новый экран, Intuition создаёт 
вспомогательную структуру, названную @{"DrawInfo" link Includes/intuition/screens/MAIN 60}. Эта струкрура
обеспечивает информацией, необходимую для Intuition в поддержке нового 3D вида,
а также специальной графической информацией для приложений. Эта информация
включает в себя такие пункты, как разрешение, шрифт, число цветов и перьев.

struct DrawInfo
{
    UWORD	dri_Version;	/* будет DRI_VERSION 		*/
    UWORD	dri_NumPens;	/* гарантировано >= numDrIPens	*/
    UWORD	*dri_Pens;	/* указатель на массив перьев	*/

    struct TextFont	*dri_Font;  /* шрифт экрана по умолчанию	*/
    UWORD	dri_Depth;	    /* (начальная) глубина битмэпа	*/

    struct {	/* из базы данных DisplayInfo - начальный режим дисплея	*/
	UWORD	X;
	UWORD	Y;
    }		dri_Resolution;

    ULONG	dri_Flags;		/* см. ниже			*/
    ULONG	dri_Reserved[7];	/* для будущего ;^)		*/
};


До того, как приложение будет использовать поля @{"DrawInfo" link Includes/intuition/screens.h/MAIN 60}, оно
должно проверить версию структуры для уверенности, что все поля в ней есть.
Если версия dri_Version больше или равна DRI_VERSION, структура может 
использоваться полностью и все поля в DrawInfo поддерживаются Intuition.

@{" Спецификация Пера (Pen) в DrawInfo " link 3-5-1}
@{" Спецификация Шрифта в DrawInfo " link 3-5-2}
@{" Клонирование Общего Экрана (Workbench) " link 3-5-3}

@ENDNODE

@NODE 3-5-1 "3 / DrawInfo и 3D Вид / Спецификация Пера в DrawInfo"
Спецификация пера в @{"DrawInfo.dri_Pens" link 3-5 8} позволяет приложению
использовать подходящие цвета для графических операций, таких как вывод 
текста, оттенение 3D объектов и закраска предметов, выделенных пользователем.

Intuition имеет два множества перьев, первое для multi-bitplane экранов и
другое для двухцветных экранов.  В добавок, есть специальный совместимый 
режим для экранов, которые не специфицируют @{"SA_Pens" link 3-3-2 82} тэг.

Новый 3D Вид
    Это полностью 3D вид, такой как Workbench в ОС Версии 2.
    Объекты рисуются так, что свет падает из верхнего левого угла экрана,
    придавая им трёхмерный вид.

Новый Монохромный Вид
    Невозможно сделать 3D вид на монохромном (двухцветном) экране.
    Intuition обеспечивает спецификацию пера для таких экранов с меньшей
    потерей информации.

Новый Совместимый Вид
    @{"Обычные экраны" link 3-3}, которые не использовали выставляли @{"SA_Pens" link 3-3-2 82},
    и очивидно имеют неопределённый набор перьев.  Они оперируют со специальным
    монохромным видом, который ипользует @{"DetailPen" link 3-3-2 91} и @{"BlockPen" link 3-3-2 99}.
    Это обеспечивает совместимость с V34 и более старыми @{"версиями" link Lib_1/1-1-4} ОС.

Удобно использовать спецификацию пера по умолчанию. Просто укажите пустой
список (на C это {~0}) и Intuition заполнит все значения стандартными,
подходящими к экрану. Такой способ продемонстрирован в первых двух примерах
(@{"newlookscreen.c" link Lib_examples/newlookscreen.c/MAIN 25} и @{"screen34to37.c" link Lib_examples/screen34to37.c/MAIN 23})
дальше в этой главе.

Но наверняка приложению потребуется свой набор перьев.  Такая спецификация
определяется, когда создаётся экран, используя тэг @{"SA_Pens" link 3-3-2 82} и
указатель на массив перьев.  Пока, Intuition использует девять. Программа
может установить все или только несколько перьев, а Intuition заполнит всё
остальное.  Intuition заполнит перья оставшиеся после спецификации программы;
нет возможности использования стандартных значений для "первых" перьев (они
в начале массива) без использования таких значений для остальных.

Использование спецификации пера уже существующего @{"общего экрана" link 3-4} немного
сложнее.  Во-первых, приложение должно получить указатель на структуру экрана
используя @{"LockPubScreen()" link 3-4 34}. Копию @{"DrawInfo" link 3-2-2 6} можно
получить с помощью @{"GetScreenDrawInfo()" link 3-5-3 16}.  Структура DrawInfo 
содержит копию спецификации пера, которую можно использовать в @{"OpenScreenTagList()" link 3-3 6}
с тэгом @{"SA_Pens" link 3-3-2 82}.  Массив перьев копируется в структуры нового
экрана (он не хранится как указатель), так что приложение может сразу же 
вызвать @{"FreeScreenDrawInfo()" link 3-10 21} и @{"UnlockPubScreen()" link 3-4 34} после открытия
нового экрана.

    @{" publicscreen.c " link lib_examples/publicscreen.c/MAIN}

Далее приводится список перьев, определённых в V36, которые обеспечивают 
3D вид. Для того, чтобы узнать значение определённого пера, используйте 
UWORD penvalue = myDrawInfo->dri_Pens[PENNAME], где myDrawInfo - указатель 
на структуру @{"DrawInfo" link 3-2-2 6}, а PENNAME взято из следующего списка.

DETAILPEN
    Совместимо с V34. Используется для вывода текста в заголовок экрана.

BLOCKPEN
    Совместимо с V34. Используется для заливки заголовка.

TEXTPEN
    Для обычного текста поверх BACKGROUNDPEN.

SHINEPEN
    Для освещённого угла 3D объектов.

SHADOWPEN
    Для затенённого угла 3D объектов.

FILLPEN
    Для закраски бордюра активного окна или кнопки.

FILLTEXTPEN
    Для вывода ткста поверх FILLPEN.

BACKGROUNDPEN
    Для заднего плана.  Пока должен быть 0.

HIGHLIGHTTEXTPEN
    Для "особого цвета" или подсветки текста на BACKGROUNDPEN.

@ENDNODE

@NODE 3-5-2 "3 / DrawInfo и 3D Вид / Спецификация Шрифта в DrawInfo"
Информация о шрифте для экрана приходит из нескольких источников.

@{"SA_Font" link 3-3-2 125}
    Приложение может указать шрифт для экрана используя тэг SA_Font со
    структурой @{"TextAttr" link Lib_29/29-2-1 21}.  В этом случае, шрифт
    будет использоваться экраном и будет по умолчанию для @{"RastPort" link Lib_4/4-2 8}
    любого окна на этом экране.

@{"SA_SysFont" link 3-3-2 130}, 0
    Если нужен фиксированный шрифт, определённый пользователем, его можно
    взять из @{"GfxBase->DefaultFont" link Includes/graphics/gfxbase.h/MAIN 24}.
    @{"RastPorts" link Lib_4/4-2 8} любого окна, также будет использовать 
    этот шрифт по умолчанию.

SA_SysFont, 1
    Экранный шрифт, установленный пользователем в Preferences - редакторе 
    шрифтов, может быть также пропорциональным. Для совместимости, если
    этот шрифт указан для экрана, @{"RastPort" link Lib_4/4-2 8} окон
    будет инициализирован @{"GfxBase->DefaultFont" link Includes/graphics/gfxbase.h/MAIN 24}
    (не пропорциональный шрифт).

Для доступа к шрифту экрана, приложение может справиться в @{"Screen.Font" link 3-2-1 76}
или @{"DrawInfo.dri_Font" link 3-5 8}.  Эти шрифты идентичны, структура @{"DrawInfo" link 3-2-2 6} 
просто обеспечивает альтернативный метод доступа к этой информации. Помните,
что Screen.Font это указатель на структуру @{"TextAttr" link Lib_29/29-2-1 21} также, как
и DrawInfo.dri_Font. Приложение может воспользоваться любым указателем.

Изменять шрифт экрана после открытия незаконно. Это означает, что шрифт,
указанный в структуре @{"Screen" link 3-2-2 6} и @{"DrawInfo" link 3-2-2 6} гарантировано
открыт пока открыт экран.

Меню, заголовки окно, пункты меню и содержание строк, всё это использует шрифт
экрана. Шрифт пунктов меню может быть переопределён в структуре этого пункта
с помощью @{"IntuiText" link Lib_8/8-4-1}.  В V36 и выше, шрифт использующийся
в строках может быть переопределён через структуру @{"StringExtend" link Lib_5/5-12-7}.
Шрифт для заголовков меню и окон не переопределяется.

Смотрите также описание тэгов @{"SA_Font" link 3-3-2 125} и @{"SA_SysFont" link 3-3-2 130}
в разделе "Атрибуты Экрана".

@ENDNODE

@NODE 3-5-3 "3 / DrawInfo и 3D Вид / Клонирование Общего Экрана (Workbench)"
Атрибуты предпочтения пользователя в основном отражены на экране Workbench 
или на рабочем @{"общем экране" link 3-4} (экран по умолчанию).  В некоторых
случаях может быть полезным создавать новый экран с такими же атрибутами.

В V34, информация о экране была доступна через @{"GetScreenData()" link 3-9-3 20}.
Из-за разширений V36 этот вызов больше не достаточен для описания дисплея.
Приложениям придётся использовать целый набор функций; определённых требуемой
информацией.

@{"LockPubScreen()" link 3-4 34} rвозвращает указатель на структуру Screen
определённого экрана. @{"GetScreenDrawInfo()" link 3-5-3 16} возвращает информацию
о графическом выводе, такую как массив перьев и шрифт.  @{"QueryOverscan()" link 3-6-1 76}
возвращает информацию об overscan данного режима дисплея
(см. раздел "@{"Overscan и Display Clip" link 3-6-1}").

Следующий пример показывает как использовать @{"GetScreenDrawInfo()" link intuition/GetScreenDrawInfo()} 
для проверки атрибутов экрана Workbench, таким образом можно создать экран
с такими же атрибутами.

    struct DrawInfo *GetScreenDrawInfo( struct Screen * )

Для клона экрана необходимы атрибуты: ширина, высота, глубина, перья и режим.
Перья и глубина экрана можно взять из структуры @{"DrawInfo" link 3-2-2 6}.
Ширину и высоту из структуры @{"Screen" link 3-2-2 6}. (Ширина и(или) высота
могут быть больше,чем площать overscan, если экран перемещаемый, и может быть
включено автоперемещение (autoscroll).)

Режим дисплея экрана можно узнать используя функцию графической библиотеки
@{"GetVPModeID()" link Lib_27/27-2-9-7 19}.	Она возвращает ID дисплея,
который можно использовать с тэгом @{"SA_DisplayID" link 3-3-2 74} в @{"OpenScreenTagList()" link 3-3 6}. 
Запомните, что ниже приведённый пример предполагает, что экран будет открыт
в соответствие с установками пользователя, в текстовомo overscan. Если 
необходима точная копия display clip существующего экрана, используйте
@{"VideoControl()" link Lib_27/27-2-9-4 15} для доступа к структуре @{"ViewPortExtra" link Includes/graphics/view.h/MAIN 78}.

Цвета можно скопировать, используя функции графической библиотеки @{"GetRGB4()" link Lib_27/27-2-7-5 41},
@{"SetRGB4()" link Lib_27/27-2-7-5}, @{"SetRGB4CM()" link Lib_27/27-2-7-5 41} и @{"LoadRGB4()" link Lib_27/27-2-7-5 41}.
Программа примера не копирует цвета.

Пример копирует шрифт экрана.  Разумной альтернативой может стать использование
установленного пользователем шрифта, который можно установить через тэг 
{"SA_SysFont" link 3-3-2 130}.

    @{" clonescreen.c " link lib_examples/clonescreen.c/MAIN}

@ENDNODE

@NODE 3-6 "3 Intuition Экраны / Overscan и Display Clip"
Экраны могут быть больше или меньше, чем определённый для них дисплей 
(прямоугольник overscan или display clip).  Когда экран меньше дисплея,
display clip действует как "контейнер" для экрана.  Экран можно перемещать
куда угодно внутри этого display clip.	Когда экран больше, display clip
действует как "окно" в экран. Экран можно перемещать, так что становяться
видимыми различные его части. Каждый размер экрана независим и может быть
больше, равный или меньше размера display clip.

Системя достаточно гибкая в определение размеров экрана.  Если приложение не 
зафиксировало эти размеры, можно получить возможность изменения пользователём
overscan или монитора (NTSC/PAL).

Используйте константы STDSCREENHEIGHT и STDSCREENWIDTH в тэгах @{"SA_Width" link 3-3-2 54}
и @{"SA_Height" link 3-3-2 54} для открытия экран с размерами равными display
clip.  Эти константы работают с любыми значениями существующих overscan,
устанавливаются в @{"SA_Overscan" link 3-3-2 247}, и с заказными overscan,
устанавливаются в тэге @{"SA_DClip" link 3-3-2 257}.

@{" Предопределённые Значения Overscan " link 3-6-1}

@ENDNODE

@NODE 3-6-1 "3 / Overscan и Display Clip / Предопределённые Значения Overscan"
Существует четыре размера overscan.  Приложения, использующие overscan, 
должны принимать предопределённые его виды. Избегайте иных значений, даже если
это неплохо смотрится на какой то системе. Однако, помните, что размер и
позиция таких экранов могут быть различными на каждой системе и зависят от
установок пользователя (Overscan Preferences).  Стандартные виды overscan,
также зависят от дисплея, так что они могут изменяться под различными 
режимами дисплея экрана. Overscan устанавливается @{"SA_Overscan" link 3-3-2 247} или
передаётся @{"QueryOverscan()" link intuition/QueryOverscan()} для нахождения
текущих установок overscan.

OSCAN_TEXT
    Эта область базируется на установках пользователя и показывает дисплей,
    полностью помещающийся в видимые границы монитора. Начало координат @{"вида" link 3-7 4} 
    устанавливается в левом верхнем углу. Эта позиция может изменяться 
    пользователем. Все координаты на экране вычисляются относительно этой 
    позиции.

OSCAN_STANDARD
    Границы области OSCAN_STANDARD также зависят от пользователя.
    OSCAN_STANDARD обеспечивает наименьший возможную область
    дисплея, которая покроет весь экран, оказавшегося без границ. Части
    дисплея могут быть невидимыми пользователю.

OSCAN_MAX
    Создаёт наибольшую область дисплея, полностью поддерживаемую Intuition и
    графической библиотекой.  Это самый большой размер для которого легальны
    все позиции. Части дисплея могут быть невидимы пользователю.

OSCAN_VIDEO
    Создаёт самый большой дисплей, ограничинный железом.  Это единственный
    легальный размер и позиция, которые возможно (но не обязательно) больше,
    чем при OSCAN_MAX.  Вы должны использовать определённые размер и позицию.
    OSCAN_VIDEO не поддерживает переменные левый и верхние края. Части дисплея
    могут быть невидимы пользователю.

Если нужна специальная область, её можно заказать, используя тэг @{"SA_DClip" link 3-3-2 257} 
и структуру @{"Rectangle" link Lib_29/29-3 49}.  Эта область должна помещаться
в OSCAN_MAX, включая смещение. Не разрешается определять область между 
OSCAN_MAX и OSCAN_VIDEO, а также больше OSCAN_VIDEO. Пример того, как открыть 
экран с overscan, смотрите @{"screen.c" link modules/screen.c/MAIN} в IFF
Приложение Amiga ROM Ядро ( Справочное Руководство: Устройства.)

Для определения настоящей области дисплея, используйте функцию графической 
библиотеки VideoControl(). Смотрите @{"Autodocs" link graphics/VideoControl()} и главу 
"@{"Графические Примитивы " link Lib_27/27-2-9-4 15}".  Структура @{"ViewPortExtra" link Includes/graphics/view.h/MAIN 78}
содержит информацию об области дисплея.

Если любое измерение экрана не равно соответствующему области дисплея, экран
можно прокрутить. Если эти измерения меньше данной области, он может быть
в ней перемещён.

AutoScroll можно включить установкой тэга @{"SA_AutoScroll" link 3-3-2 220}. Экран
можно скролировать, если он активен. Активация окна в экране делает активным
и его.

    О Стандартной Области Дисплея.
    -------------------------------
    Такая область используется, если приложение не определило @{"SA_Overscan" link 3-3-2 247}
    или @{"SA_DClip" link 3-3-2 257}.

Когда открывается окно на overscan экране, часто бывает полезно делать это
относительно видимой части экрана, чем относительно всего экрана. Для этого
используется функция @{"QueryOverscan()" link intuition/QueryOverscan()}, которая
находит регион overscan.

    LONG QueryOverscan(ULONG displayID,
		       struct Rectangle *rect, WORD overscanType )

Этот пример взят из главы "Intuition Окна" в разделе
"@{"Пример Полноэкранного Окна" link Lib_4/4-2-5-1}".
@{"complete example" link Lib_examples/visiblewindow.c/MAIN}.

/* Этим приёмом мы получаем регион overscan экрана.
**
** GetVPModeID() - вызов из графической библиотеки...
*/

screen_modeID = GetVPModeID(&(pub_screen->ViewPort))))
if (screen_modeID != INVALID_ID)
    {
    if ( QueryOverscan(screen_modeID, &rect, OSCAN_TEXT) )
	{
	/* если начало экрана вверху или слева от начала дисплея, тогда */
	/* сдвигаем окно вниз и вправо */
	left = max(0, -pub_screen->LeftEdge);
	top  = max(0, -pub_screen->TopEdge);

	/* получаем ширину и высоту из размера области дисплея */
	width  = rect.MaxX - rect.MinX + 1;
	height = rect.MaxY - rect.MinY + 1;

	/* выверяем высоту для экрана (только для видимой части) */
	if (pub_screen->TopEdge > 0)
	    height -= pub_screen->TopEdge;

	/* гарантируем, что окно помещается в экран */
	height = min(height, pub_screen->Height);
	width  = min(width,  pub_screen->Width);

	/* гарантируем, что окно имеет размер неменее минимального */
	width  = max(width,  MIN_WINDOW_WIDTH);
	height = max(height, MIN_WINDOW_HEIGHT);
	}
    }

@ENDNODE

@NODE 3-7 "3 Intuition Экраны / Экраны Intuition и Графическая Библиотека"
Как уже говорилось, экран Intuition связан с некоторыми основными структурами
графической библотеки.


	 Table 3-8: Графические Сткруктуры, использованные в Экранах


    Имя		    Описание	 		  Определена в Include-файле
    --------------  ----------- 		  -----------------------
    View	    Корневая структура графической   <graphics/@{"view.h" link Includes/graphics/view.h/MAIN 57}>
		    системы

    ViewPort	    Графическая структура,           <graphics/@{"view.h" link Includes/graphics/view.h/MAIN 40}>
		    соответствующая экрану

    BitMap	    Содержит размер и указатели на   <graphics/@{"gfx.h" link Includes/graphics/gfx.h/MAIN 47}>
		    битпланы экрана

    ColorMap	    Содержит размер и указатель на   <graphics/@{"view.h" link Includes/graphics/view.h/MAIN 113}>
		    палитру экрана

    @{"RastPort" link Lib_27/27-4-1}	    Содержит установки рисования,  <graphics/@{"rastport.h" link Includes/graphics/rastport.h/MAIN 55}>
                    пера и шрифта, а также адрес BitMap


Эти структуры объедины в структуру Intuition @{"Screen" link 3-2-2 6} (которая
потом также используется  в более высокоуровневых конструкциях Intuition, как
меню и окна).  Вот описание структур графической библиотеки , используемых
Intuition.

@{"View" link Includes/graphics/view.h/MAIN 57}
    Это структура полностью описывает дисплей, включая все видимые экраны.
    Система имеет только одну такую структуру. Адрес структуры можно взять
    из любого экрана, используя @{"ViewAddress()" link 3-10 52}.

@{"ViewPort" link Includes/graphics/view.h/MAIN 40}
    ViewPort - лежит в основе графических структур, соответствующих экрану.
    Каждый экран имеет ViewPort.  Для получения адреса ViewPort из структуры
    @{"Screen" link 3-2-2 6} используйте (&my_screen-> ViewPort).
    Из ViewPort приложение может получить указатели на все бипланы экрана и
    на его таблицу цветов.

@{"BitMap" link Includes/graphics/gfx.h/MAIN 47}
    BitMap содержит указатели на все битпланы ( до 8) и их размеры. Для 
    будущей совместимости, лучше используйте (my_screen->RastPort.BitMap), 
    чтобы получить адрес BitMap экрана, чем (&my_screen->BitMap).

    Поле BitMap.BytesPerRow определяет число байт, нужных для каждай строки
    растра. Она может быть больше, чем ширина экрана.

@{"ColorMap" link Includes/graphics/view.h/MAIN 113}
    Содержит указатель на таблицу цветов, массив длинных 32-битных слов 
    для цветовых регистров.  Используйте SetRGB4(), GetRGB4(), SetRGB4CM() и
    LoadRGB4() из графической библиотеки для получения доступа к этой таблице.
    Не читайте и не записывайте напрямую.

@{"RastPort" link 27-4-1}
    Контролирует вывод графики в любую область дисплея (не только экрана).
    Экраны имеют RastPort для прямого вывода графики. Приложение может найти
    эту структуру в (&my_screen->RastPort).  Но обычно такой подход не 
    пригоден, так как принято всё выводить в окно.

@{" Изменение Цветов Экрана " link 3-7-1}
@{" Прямой Доступ к Экрану " link 3-7-2}
@{" Функции Экранов, интегрирующие Intuition и Графическую Библиотеку " link 3-7-3}
@{" Ограничения Графической Подсистемы " link 3-7-4}

@ENDNODE

@NODE 3-7-1 "3 / Экраны Intuition и Графическая Библиотека / Изменение Цветов Экрана"
Спомощью тэга @{"SA_Colors" link 3-3-2 111} можно установить цвета экрана во время
его создания. Если необходимо изменить их после этого, нужно воспользоваться
функцией графической библиотеки LoadRGB4().  Для изменения одного цвета
используются SetRGB4() и SetRGB4CM().  Смотрите главу "@{"Graphics Primitives" link Lib_27/27-2-7-5}" 
для получения большей информации о них.

@ENDNODE

@NODE 3-7-2 "3 / Экраны Intuition и Графическая Библиотека / Прямой Доступ к Экрану"
Иногда приложению нужно напрямую обратиться к битмэпу экрана. Это может быть
полезно, если приложение использует оригинальные функции дисплея, но хочет
оставить функционирование Intuition. Например, приложение может использовать
графические примитивы для двойной буферизации и события от пользователя,
включая контроль Intuition над экраном, так что окна, кнопки и меню можно
использовать для обработки ввода. Если приложение комбинирует эти две 
технологии, оно должно позаботиться о устранение конфликта с выводом графики
Intuition. Пример того, как сделать это приведён в следующем разделе
"@{"Продвинутое Программирование Экранов" link 3-8-1}".

Приложение, открывшее @{"обычный экран" link 3-3}, может использовать его
память дисплея. Однако, эта память используется Intuition для окон и других
компонент дисплея высокого уровня. Обращение напрямую к экранной памяти,
непосредственно или через функции, использующие @{"RastPort" link 3-7 4} экрана,
не совместимо со многими конструкциями Intuition, такими как окна и меню.

Такая технология требует большого внимания и понимания Amiga. Если возможно,
приложению лучше избежать этого и использовать только стандартный дисплей
Intuition и обработку ввода.  Прямой доступ к битмэпу экрана не рекомендован.
Лучший способ обращения к дисплею экрана - через окна.  Окна обеспечивают
доступ к экрану через слои (layers), которые выполняют отсечение (clipping)
и арбитраж между разными областями графики.

Альтернативы записи напрямую в экран, такие как использование фоновых (backdrop)
окон, снижают число случаев, когда приложение вынуждено делать это. Функция
@{"ShowTitle()" link 3-9-3 10} позволяет заголовку экрана распологаться
впереди или позади фоновых окон. Следовательно фоновое окно может быть открыто
так, что используется вся видимая область монитора. Приложениям, использующим
@{"общие экраны" link 3-4}, не нужна такая свобода, такая как с @{"обычными" link 3-3}.

    Используйте Прямой Доступ Только к Своему Экрану
    ------------------------------------------------
    Приложение не должно красть битмэп экрана, который ей не принадлежит.
    Воровство битмэпа Workbench или любого другого @{"общего экрана" link 3-4}
    строжайше запрещено.  Доступ к основным графическим структурам экрана
    может быть только в @{"обычных экранах" link 3-3}, открытых приложением.

    Не Выполняйте Опирации со Слоями Напрямую.
    ------------------------------------------
    Тогда как @{"слои" link Lib_30/MAIN} не являются частью графической 
    библиотеки, стоит упомянут о них здесь. Определённые опирации со слоями
    не разрешены Intuition.  Вам нельзя, например, вызывать @{"SizeLayer()" link Lib_30/30-1-6 17}
    для окна (используйте @{"SizeWindow()" link Lib_4/4-8-3}). Для доступа к
    библиотеке слоёв (layers library), используйте окна Intuition!

@{"Обычный экран" link 3-3} может быть создан для модификации Copper листа экран.
Copper - синхронный сопроцессор, который управляет текущем дисплеем, напрямую
обращаясь к регистрам чипсета. Смотрите Amiga @{"Hardware" link Hard_2/MAIN} Reference Manual или
главы @{"графической" link Libraries_Manual/Graph} библиотеки.

@ENDNODE

@NODE 3-7-3 "3 / / Функции Экранов, интегрирующие Intuition и Графическую Библиотеку"
Эти функции, обычно используемые системой, объединяют высокоуровневые 
структуры Intuition с низкоуровневыми конструкциями, используемыми графической
библиотекой для создания дисплея.


    Table 3-9: Функции, Интегрирующие Intuition и Графическую библиотеку
  _______________________________________________________________________
 |									 |
 |	@{"MakeScreen()" link intuition/MakeScreen()}  Обнавить коппер лист одного экрана		 |
 |									 |
 |  @{"RethinkDisplay()" link intuition/RethinkDisplay()}  Объединить коппер листы всех экранов для @{"View" link 3-7 4}      |
 |									 |
 |   @{"RemakeDisplay()" link intuition/RemakeDisplay()}  Обнавить коппер листы всех экранов,потом объединить|
 |		      в View						 |
 |_______________________________________________________________________|


Программисты могут использовать эти функции для достижения специальных 
эффектов, как @{"двойная буферизация" link 3-8-1} или @{"двойное игровое поле" link 3-8-2}.
Пример смотрите в следующем разделе.

@{"MakeScreen()" link intuition/MakeScreen()} обнавляет, но не устанавливает Коппер лист экрана.  Эта
функция - Intuition эквивалент низкоуровневой @{"MakeVPort()" link Lib_27/27-2-7-6 9} из графической
библиотеки.  MakeScreen() выполняет вызов MakeVPort(). После MakeScreen()
вызывите RethinkDisplay() для того, чтобы новый Коппер лист был установлен.
MakeScreen() имеет один аргумент - указатель на структуру @{"Screen" link 3-2-2 6}, которая
содержит Коппер лист.

@{"RethinkDisplay()" link intuition/RethinkDisplay()} комбинирует коппер листы всех экранов в один.
Эта процедура выполняет глобальную реконструкцию дисплея, которая включает
в себя обработку нескольких внутренних состояний Intuition, пересмотр всех 
@{"ViewPort'ов" link 3-7 4} экранов и их отношений, и наконец, обновление
дисплея, соединие новых экранов в структуру @{"View" link 3-7 4}. @{"Экраны" link 3-3},
которые имеют свои собственные Коппер-инструкции, используют этот вызов для
инсталяции Коппер листа, предварительно обнавлённого с помощью MakeScreen().
RethinkDisplay() вызывает низкоуровневые @{"MrgCop()" link Lib_27/27-2-7-6 27} и
@{"LoadView()" link Lib_27/27-2-8}. Эта функция не имеет аргументов.

@{"RemakeDisplay()" link intuition/RemakeDisplay()} преобразует Intuition дисплей.
Это эквивалент вызова MakeScreen() для каждого экрана в системе и вызову 
RethinkDisplay(). Не имеет аргументов.

Обе RemakeDisplay() и RethinkDisplay() выполняются до нескольких милисекунд,
запирая все остальные задачи. Это может серьёзно понизить производительность 
системы, поэтому, если можно, используйте их реже.

@ENDNODE

@NODE 3-7-4 "3 / / Ограничения Графической Подсистемы"
Если все видимые экраны не имеют одинаковых физичеких параметров, может быть
невозможным показать их содержимое в надлежащем режиме.

Ограничения чипсета не допускают определённые типы дисплея.  Например,экраны
всегда используют полную ширину дисплея, не считаясь с шириной области overscan.
Это предупреждает изменения режима дисплея в строке развёртки. Другие режимы,
как VGA, требуют определённой версии чипсета и могут быть недоступны. Смотрите
главу "@{"Графические Примитивы" link Lib_27/27-2-1}" и Amiga @{"Hardware" link Hard_3/3-2-6} Reference
Manual.

@ENDNODE

@NODE 3-8 "3 Intuition Экраны / Продвинутое Программирование"
Этот раздел рассказывает: как сделать двойную буферизацию экранов Intuition,
как создать двойное игровое поле (dual-playfield) и т.д.

@{" Двойная Буферизация " link 3-8-1}  @{" Пример Двойного Игрового Поля " link 3-8-2}

@ENDNODE

@NODE 3-8-1 "3 / Продвинутое Программирование / Двойная Буферизация"
Двойная буферизация экрана Intuition включает обмен битмэпа экрана, потом
обновление коппер листа и его установка. Фокус в том, что после установки
битмэпа, дисплей не обнавляется до того, как не будет обновлён коппер лист.
Любой вывод до этого будет произведён в невидемый битмэп.

Первое. Установить битмэп.

    /* переключаем битмэп */
    screen->RastPort.BitMap	     = myBitMaps[toggleFrame];
    screen->ViewPort.RasInfo->BitMap = myBitMaps[toggleFrame];

Рисовать можно теперь на невидимом битмэпе @{"screen->RastPort" link 3-2-1}.

Коппер лист экрана обновляется @{"MakeScreen()" link 3-7-3 5}. Этот вызов
подкрепляет коппер лист, но не устанавливает в систему. @{"RethinkDisplay()" link 3-7-3 5} 
устанавливает новый коппер лист так, что появляются новые данные.

    /* обновляем дисплей  */
    MakeScreen(screen); /* Intuition обновляет коппер лист 	    */
    RethinkDisplay();	/* Совместимые с Intuition MrgCop и LoadView*/
			/*		 также WaitTOF().           */

Помните, что возможно пользователь ускорит обновление экрана, перемещая или
листая его. Это может привести к показу того, что ещё не надо.

Полный пример двойной буферизации.

    @{" doublebuffer.c " link lib_examples/doublebuffer.c/MAIN}

@ENDNODE

@NODE 3-8-2 "3 / Продвинутое Программирование / Пример Двойного Игрового Поля"
Этот пример показывает, как создавать дисплей с двойным полем.  Запомните, что
эта технология возможна только для тех режимов дисплея, которые её поддерживают.

Установка режима двойного игрового поля в @{"OpenScreen()" link 3-3 6} не лучший
способ.  Гораздо удобнее открыть стандартный экран. Потом создать второй
битмэп, его битпланы и структуру @{"RasInfo" link Lib_27/27-2-7-3} и установить
это всё в viewport экрана.  Обновить viewport для DUALPF и вызвать 
@{"MakeScreen()" link 3-7-3 5}, @{"RethinkDisplay()" link 3-7-3 5}.  Этот метод,
показанный в примере, сохраняет вывод Intuition (кнопки, меню, окна) в одном
игровом поле.

    @{" dualplayfield.c " link lib_examples/dualplayfield.c/MAIN}

@ENDNODE

@NODE 3-9 "3 Intuition Экраны / Другие Функции"
Есть функции Intuition, контролирующие расположение экрана, его перемещение,
заголовок и визуальный "error beep".

@{" Пролистование Экранов " link 3-9-1}
@{" Перемещение и Скроллинг Экрана " link 3-9-2}
@{" Другие Функции " link 3-9-3}

@ENDNODE

@NODE 3-9-1 "3 / Другие Функции / Расположение Экрана"
@{"ScreenToFront()" link intuition/ScreenToFront()} и @{"ScreenToBack()" link intuition/ScreenToBack()} перемещают экран на передний или задний план.
Если приложению понадобиться нарисовать что-то до того как экран окажется
видимым пользователю, экран можно открыть позади всех, а позже переместить 
его с помощью ScreenToFront().

    VOID ScreenToFront( struct Screen * )
    VOID ScreenToBack ( struct Screen * )

Такой контроль возможен через кнопку расположения экрана в полоске заголовка
или через горячую клавишу.  Клавиша N и Left-Amiga перемещают экран Workbench
вперёд.  M и Left-Amiga перемещает передний экран назад. Повторяя нажатие
Left-Amiga-M, можно просмотреть все экраны.

@ENDNODE

@NODE 3-9-2 "3 / Другие Функции / Перемещение и Скроллинг Экрана"
Функция @{"MoveScreen()" link intuition/MoveScreen()} перемещает экран по дисплею
по пикселям dx и dy.

    VOID MoveScreen( struct Screen *myscreen, WORD dx, WORD dy )

Вызов @{"MoveScreen()" link intuition/MoveScreen()} асинхронный; экран необязательно
переместится после выхода из функции.  Если вызов произошёл слишком быстро,
возможен непредсказуемый результат.  Есть хороший способ вызова этой функции
один раз для каждого события @{"IDCMP_INTUITICKS" link Lib_9/9-6-1-6 80}.

Перемещение экран также возможно через полоску заголовка и с помощью кнопок.
Left-Amiga и левая кнопка мышки, нажатая в любом месте, позволят вам перемещать
экран (даже если заголовок экран чем-либо закрыт).  Перемещение экрана вниз
делает видимыми задние экраны.  Экраны никогда не появляются слева или справа
друг от друга.

Вдобавок, слишком большие экраны могут смещаться с помощью новой возможности
ОС2 - автоскролл (autoscroll).  С ним экран автоматически скроллируется, как
только мышка достигает один из краёв дисплея. Автоскролл работает только на
активном экране.

Есть ещё один способ переместить экран - сдигать экран под меню. Когда экран
гораздо больше видимой области и скроллирован так, что меню оказалось вне
этой области. Для предотвращения этого, перед тем как нарисовать меню, экран
сдвигается. Экран как бы перещелкивается в нормальное положение, а когда 
меню выбрано, он сдвигается назад. Если при этом удерживается Left-Amiga
экран останится в нормальном положении. 

Редактор установок Intuition, IControl позволяет пользователю изменять число
свойств Intuition.  Некоторые из них включают способность отключить
menu snap, изменить спецификатор для перемещения экрана.

@ENDNODE

@NODE 3-9-3 "3 / Другие Функции / Другие Функции"
Существуют три функции DisplayBeep(), @{"ShowTitle()" link intuition/ShowTitle()} и
@{"GetScreenData()" link intuition/GetScreenData()}.  DisplayBeep() информирует пользователя
об ошибки вспыхиванием экрана.

    VOID DisplayBeep( struct Screen *myscreen )

Так как не все пользователи имеет спикер, DisplayBeep() используется для 
визуального оповещения. DisplayBeep() может работать с одним экраном или,
если myscreen=NULL со всеми.

@{"ShowTitle()" link intuition/ShowTitle()} определяет будет ли заголовок экрана
показан впереди или позади заднеплановых окон.

    VOID ShowTitle( struct Screen *myscreen, BOOL infront )

По умолчанию, заголовок экрана установлен видимым. Но можно установить этот 
флаг во время открытия экрана тэгом @{"SA_ShowTitle" link 3-3-2 211}.

В 1.3 (V34) и ранних версиях AmigaOS, приложения использовали функцию
@{"GetScreenData()" link intuition/GetScreenData()} для получения копии
структуры @{"Screen" link 3-2-2 6} экрана Workbench.

    success = BOOL GetScreenData( APTR buffer, UWORD bufsize,
				  UWORD type, struct Screen *scr)

В случае успеха, @{"GetScreenData()" link intuition/GetScreenData()} копирует структуру @{"Screen" link 3-2-2 6} в буфер.
Копию Workbench Screen можно получить, не зная её расположения, используя
GetScreenData(buf,sizeof(struct Screen), WBENCHSCREEN, NULL). Однако для
Версии 2 и выше эта функция может вернуть несколько неверную информацию
о экране Workbench.

Приложение, которое хочет получить информацию о Workbench, должно использовать
@{"GetScreenData()" link intuition/GetScreenData()} под 1.3 и @{"LockPubScreen()" link 3-4 34} под
Версию 2.

@ENDNODE

@NODE 3-10 "3 Intuition Экраны / Функции"
Далее следует краткое описание функций Intuition, относящихся к экранам.


	     Table 3-10: Фукции Intuition для Экранов
  ______________________________________________________________________
 |									|
 |	    Функция		      Описание				|
 |======================================================================|
 |    @{"OpenScreenTagList()" link intuition/OpenScreenTagList()}  Открывает экран.				|
 |	 @{"OpenScreenTags()" link intuition/OpenScreenTags()}  Альтернативный вызов для			|
 |			   OpenScreenTagList(). 			|
 |	     @{"OpenScreen()" link intuition/OpenScreen()}  	Открывает экран (до V36)		|
 |	    @{"CloseScreen()" link intuition/CloseScreen()}  Закрывает экран.				|
 |----------------------------------------------------------------------|
 |	     @{"MoveScreen()" link intuition/MoveScreen()}  Изменяет позицию экрана.			|
 |	   @{"ScreenToBack()" link intuition/ScreenToBack()}  Перемещает экран позади всех.		|
 |	  @{"ScreenToFront()" link intuition/ScreenToFront()}  Перемещает экран вперёд.			|
 |	      @{"ShowTitle()" link intuition/ShowTitle()}  Показывает экран впереди всех заднеплановых	|
 |			   окон.					|
 |----------------------------------------------------------------------|
 |    @{"GetScreenDrawInfo()" link intuition/GetScreenDrawInfo()}  Получает информацию DrawInfo. 		|
 |			   screen.					|
 |   @{"FreeScreenDrawInfo()" link intuition/FreeScreenDrawInfo()}  Освобождает DrawInfo.			|
 |----------------------------------------------------------------------|
 |	  @{"QueryOverscan()" link intuition/QueryOverscan()}  Находит информацию об overscan. 		|
 |----------------------------------------------------------------------|
 |	  @{"LockPubScreen()" link intuition/LockPubScreen()}  Запирает общий экран.			|
 |	@{"UnlockPubScreen()" link intuition/UnlockPubScreen()}  Освобождает замок на экран.			|
 |	  @{"NextPubScreen()" link intuition/NextPubScreen()}  Возвращает имя следующего в списке		|
 |			   общего экрана.				|
 |	@{"PubScreenStatus()" link intuition/PubScreenStatus()}  Делает общий экран приватнsм или 		|
 |			   наоборот.					|
 |----------------------------------------------------------------------|
 |    @{"LockPubScreenList()" link intuition/LockPubScreenList()}  Запирает список общих экранов.		|
 |  @{"UnlockPubScreenList()" link intuition/UnlockPubScreenList()}  Отпирает список общих экранов.		|
 |  @{"SetDefaultPubScreen()" link intuition/SetDefaultPubScreen()}  Устанавливает общий экран по умолчанию.	|
 |    @{"SetPubScreenModes()" link intuition/SetPubScreenModes()}  Устанавливает режим общего экрана.		|
 |  @{"GetDefaultPubScreen()" link intuition/GetDefaultPubScreen()}  Копирует имя общего экрана в буфер.		|
 |----------------------------------------------------------------------|
 |	  @{"OpenWorkBench()" link intuition/OpenWorkBench()}  Открывает Workbench.				|
 |	 @{"CloseWorkBench()" link intuition/CloseWorkBench()}  Закрывает Workbench.				|
 |	   @{"WBenchToBack()" link intuition/WBenchToBack()}  Перемещает экран позади всех.		|
 |	  @{"WBenchToFront()" link intuition/WBenchToFront()}  Перемещает экран вперёд.			|
 |	  @{"GetScreenData()" link intuition/GetScreenData()}  Получает информацию о экране. (до v36) 	|
 |----------------------------------------------------------------------|
 |	    @{"ViewAddress()" link intuition/ViewAddress()}  Возвращает адрес структуры View.		|
 |	@{"ViewPortAddress()" link intuition/ViewPortAddress()}  Используйте &screen->ViewPort.		|
 |----------------------------------------------------------------------|
 |	     @{"MakeScreen()" link intuition/MakeScreen()}  Низкоуровневое уgравление - пререстраевает 	|
 |			   Коппер лист.					|
 |	 @{"RethinkDisplay()" link intuition/RethinkDisplay()}  Низкоуровневое уgравление - соединяет	|
 |			   Коппер листы.	 			|
 |	  @{"RemakeDisplay()" link intuition/RemakeDisplay()}  MakeScreen() для всех экранов, потом		|
 |			   RethinkDisplay().				|
 |______________________________________________________________________|

@ENDNODE
