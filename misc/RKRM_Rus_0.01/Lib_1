@DATABASE Libraries Manual
@NODE MAIN "Amiga® RKM Библиотеки: 1 Введение в Систему Библиотек Amiga"
@INDEX Lib_Index/MAIN
@TOC Libraries_Manual/MAIN
Amiga, как другие компьютеры, содержит ПЗУ, полную функций,
делающих программирование машины проще.  Цель этого пособия - показать
вам, как их использовать.  Возможно лучший способ научиться программировать
на Amiga - исследывать примеры, и этот же метод используется в этом
пособии.  Прежде чем начать, было бы полезно выяснить некоторые основные
принцепы Amiga.  Этот раздел содержит некоторые основы, которые все
программисты (на Amiga) должны знать.

@{" Программирование в среде Amiga " link 1-1}
@{" О Примерах " link 1-2}
@{" Общие Правила Разработки ПО для Amiga " link 1-3}
@{" Совместимость с 1.3 " link 1-4}
@{" Приложения Commodore и Техническая Поддержка (CATS) " link 1-5}
@{" Сообщения об Ошибках " link 1-6}

@ENDNODE

@NODE 1-1 "1 Введение в Систему Библиотек / Программирование в среде Amiga"
Чтобы программировать в динамической среде Amiga, вам нужно уяснить следующие
детали дизайна Amiga:

  * @{" Многозадачность " link 1-1-1} (без защиты памяти)

  * Разделяемые @{" Библиотеки Функций " link 1-1-2}

  * @{" Динамическая архитектура памяти " link 1-1-3} (нет карты памяти)

  * @{" Версии ОС " link 1-1-4}

  * @{" Заказные чипы (The Custom Chips) " link 1-1-5} с DMA (два вида памяти)

@ENDNODE

@NODE 1-1-1 "1 / Программирование в среде Amiga / Многозадачность"
Ключевая особенность AmigaOS - это @{"многозадачность" link Lib_17/17-1}.
Многозадачность означает, что много программ или задач находятся в памяти в
одно время, разделяя системные ресурсы друг с другом.  Программы получают
время на исполнение и кажется, что несколько программ исполняются
одновременно.

@{"Многозадачность" link Lib_17/17-1} базируется на следующем: программа
большую часть своего времени ждёт чего-либо.  Программа ждёт событий, таких
как нажатие кнопки, движения мышкой или работы диска.  Пока программа ожидает,
процессор (CPU) бездельничает.  В период этого безделия CPU может быть
использован для исполнения другой программы, если бы был подходящий метод
быстрого переключения от одной программы к другой.  Это то, что делает
многозадачность.

@{" Что ОС для Вас делает " link 1-1-1-1}
@{" Что ОС для Вас не делает " link 1-1-1-2}

@ENDNODE

@NODE 1-1-1-1 "1 / / Многозадачность / Что ОС для Вас делает"
Amiga использует вытесняющую @{"многозадачность" link Lib_17/17-1}, означающую, что
ОС следит за всеми задачами в памяти и решает какой исполняться. 
  ОС проверяет сотни раз в секунду, какая задача будет исполняться или ждать.
Так как ОС управляет всей работой по переключению задач, многозадачность
прозрачна для приложений.  С точки зрения приложения кажется, что она управляет
всей машиной одна.

Также AmigaOS руководит разделением ресурсов между задачами.  Это важно,
потому как многочисленные задачи, исполняемые в @{"многозадачной" link Lib_17/17-1} среде Amiga,
должны быть предотвращены от столкновений друг с другом.  Представте, если
пять задач были допущены к использованию параллельного порта в одно время.
Результатом будет I/O хаос.  Для предупреждения этого, ОС предусматривает
арбитражный метод (обычно просто вызов функции) для каждого системного
ресурса.  Для примера вы должны вызвать функцию @{"AllocMem()" link Lib_20/20-1}, для
получения эксклюзивного доступа к блоку памяти.

@ENDNODE

@NODE 1-1-1-2 "1 / / Многозадачность / Что ОС для Вас не делает"
AmigaOS управляет всем хозяйством, необходимым для @{"многозадачности" link Lib_17/17-1},
но это не означает, что приложения не должны заботиться о многозадачности.
Текушее поколение систем Amiga не имеют hardware защиты памяти, следовательно
нечто не останавливает задачу, использующую память, каторую она не легально 
захватила.  Пастрадавшая задача может легко испортиться другими задачами
случайно перезаписавшими её код или данные. Amiga программисты должны уделять
дополнительное внимание работе с памятью; один неправильный указатель может
привести к @{"сбрасу" link Lib_D/D-1-5} (это предотвращают программы, такие как
MungWall и Enforcer).

Фактически программиты должны быть аккуратно со всеми ресурсами системы, не
только с памятью.  Все системные ресурсы от каналов звука до floppy диска -
разделяемые между задачами.  До того как  использовать ресурс, вы должны
спросить у системы доступ к нему.	Можите и не получить, если ресурс уже
используется другой задачей.

Как только вы получили контроль ресурса, ни одна другая задача не может
использовать его, поэтому отдайте его сразу после того как вы закончили.
Когда ваша программа вышла, вы должны отдать все что взяли будь то память,
доступ к файлу или I/O порт. Вы атветственны за это, система не сделает 
всё это автоматически.
  ______________________________________________________________________
 |                                                                      |
 |                                                                      |
 | Это Должен Знать Каждый Программист на Amiga                         |
 | ----------------------------------------                             |
 | Amiga - @{"многозадачный" link Lib_17/17-1} компьютер.					|
 | Не забывайте, что другие задачи исполняются в одно время вместе с    |
 | вашем приложением.  Всегда спрашивайте систему для предоставления    |
 | контроля за любым нужным вам ресурсом; некоторые другие задачи могут |
 | уже использовать его.  Отдайте назад его так скоро, как только можете|
 | - другая задача может ждать его.  Это применимо для всех действий    |
 | вашего приложения.                                                   |
 |______________________________________________________________________|

@ENDNODE

@NODE 1-1-2 "1 / Программирование в среде Amiga / Библиотеки Функций"
Большенство процедур, которые образуют AmigaOS, организованы в группы,
названными библиотеками.  Для вызова функции на Amiga вы должны сначала
открыть библиотеку, каторая содержит эту функцию.  Например, если вы хотите
вызвать функцию @{"Read()" link dos/Read()} для чтения данных с диска,
вы должны открыть библиотеку DOS.

Главная библиотека системы, названная @{"Exec" link 1-1-3-1}, всегда открыта.
Exec помнит о всех других библиотеках и заведует их открытием и закрытием.
Функция Exec - @{"OpenLibrary()" link exec/OpenLibrary()} используется для открытия всех
других библиотек.

Почти каждая программа, написанная вами на Amiga, будет вызывать функцию
@{"OpenLibrary()" link exec/OpenLibrary()}.  Применение:

    struct Library *LibBase;	  /* Global: объявление до main() */

    main()
    {
    LibBase = OpenLibrary("library.name",version);

    if(!LibBase) { /* Библиотека не открыта, значит выход */ }
    else	 { /* Библиотека открыта, значит используем её функции */ }
    }

LibBase
    Это указатель на структуру библиотеки, часто называемую основанием
    библиотеки. Этот указатель должен быть глобальным, так как система
    использует его для управления вызовом функций библиотеки.  Имя этого
    указателя устанавливается системой (вы не можете использовать любое
    имя) - смотрите ниже.

library.name
    Это терминальная строка (как в языке C), содержащая имя библиотеки,
    каторую вы собираетесь открыть.  Список имён библиотек для Amiga
	приводется ниже.

version
    Устанавливается, как самая ранняя приемлемая @{"версия библиотеки" link 1-1-4}.
    Величина 0 соответствует любой версии.  Величина 33 означает то, что вам
    нужна версия неменее 33, или более поздняя версия библиотеки.  Если
    версия библиотеки в системе старше, чем вы запросили, @{"OpenLibrary()" link exec/OpenLibrary()}
    провалиться (возвратит 0).

Следущая таблица содержит все библиотеки функций, которые сейчас являются 
частью системы Amiga.  Первая колонка содержит имя библиотеки, используемое
в @{"OpenLibrary()" link exec/OpenLibrary()}; вторая колонка содержит имя переменной,
которую вы будете использовать для хранения указателя на библиотеку; третья
колонка содержит старейшую @{"версию" link 1-1-4} библиотеки, которая ещё используется.


	 Table 1-1: Параметры, используемые в OpenLibrary()



     Имя библиотеки	       Имя указателя    Старейшая Версия
    (library.name)*		  (LibBase)	       (version)
    --------------	       -----------------    --------------
    @{"asl" link asl/MAIN}.library 	       AslBase			  36
    @{"commodities" link commodities/MAIN}.library        CxBase			  36
    @{"diskfont" link diskfont/MAIN}.library	       DiskfontBase		  33
    @{"dos" link dos/MAIN}.library 	       DOSBase			  33
    @{"exec" link exec/MAIN}.library	       SysBase			  33
    @{"expansion" link expansion/MAIN}.library	       ExpansionBase		  33
    @{"gadtools" link gadtools/MAIN}.library	       GadToolsBase		  36
    @{"graphics" link graphics/MAIN}.library	       GfxBase			  33
    @{"icon" link icon/MAIN}.library	       IconBase 		  33
    @{"iffparse" link iffparse/MAIN}.library	       IFFParseBase		  36
    @{"intuition" link intuition/MAIN}.library	       IntuitionBase		  33
    @{"keymap" link keymap/MAIN}.library	       KeymapBase		  33
    @{"layers" link layers/MAIN}.library	       LayersBase		  33
    @{"mathffp" link mathffp/MAIN}.library	       MathBase 		  33
    @{"mathtrans" link mathtrans/MAIN}.library	       MathTransBase		  33
    @{"mathieeedoubbas" link mathieeedoubbas/MAIN}.library    MathIeeeDoubBasBase	  33
    @{"mathieeedoubtrans" link mathieeedoubtrans/MAIN}.library  MathIeeeDoubTransBase	  33
    @{"mathieeesingbas" link mathieeesingbas/MAIN}.library    MathIeeeSingBasBase	  33
    @{"mathieeesingtrans" link mathieeesingtrans/MAIN}.library  MathIeeeSingTransBase	  33
    @{"rexxsyslib" link rexxsyslib/MAIN}.library	       RexxSysBase		  36
    @{"translator" link translator/MAIN}.library	       TranslatorBase		  33
    @{"utility" link utility/MAIN}.library	       UtilityBase		  36
    @{"wb" link wb/MAIN}.library			WorkbenchBase		   33


  * Могут быть и другие библиотеки, которые не поддерживаются Commodore, так
    как это особенность ОС - допускать такие библиотеки.


@{" Открытие Библиотеки на C " link 1-1-2-1}
@{" Открытие Библиотеки на Ассемблере " link 1-1-2-2}
@{" Другой Вид Библиотеки Функций " link 1-1-2-3}
@{" Библиотеки, Устройства (Devices) и Ресурсы " link 1-1-2-4}

@ENDNODE

@NODE 1-1-2-1 "1 / / Библиотеки Функций / Открытие Библиотеки на C"
Вызовите @{"OpenLibrary()" link 1-1-2} для открытия библиотеки функций. OpenLibrary()
вернёт адрес структуры библиотеки (база библиотеки), который вы должны присвоить
глобальной переменной, как показано @{"выше в таблице" link 1-1-2 49} (важен регистр букв).

Если библиотека не может быть открыта по некоторым причинам, @{"OpenLibrary()" link 1-1-2}
вернёт ноль.  Вот короткий пример, показывающий как это используется на C.

    @{" easy.c " link lib_examples/easy.c/MAIN}

@ENDNODE

@NODE 1-1-2-2 "1 / / Библиотеки Функций / Открытие Библиотеки на Ассемблере"
А вот тот же пример, написанный на ассемблере 680x0.  Принцепы одни и теже,
что и @{"на C" link 1-1-2-1}: вы должны всегда открывать библиотеку до того, как
испотльзывать любую из её функций.  Однако, на ассемблере базы библиотеки
трактуются немного иначе, чем на C.  На C, вы присваеваете базу библиотеки,
которую вы получили от @{"OpenLibrary()" link 1-1-2}, глобальной переменной и 
забываете об этом (система работает за вас).  На ассемблере, база библиотеки
должна быть всегда в @{"регистре" link Lib_26/26-2-3-1} A6 всякий раз, когда вызывается
любая из функций библиотеки.

Вы получаете базу для любой библиотеки, исключая @{"Exec" link 1-1-3-1}, вызывая
@{"OpenLibrary()" link 1-1-2}.	Для Exec вы можете получить базу из длинного слова в
памяти по адресу 4 ($0000 0004). Exec открывается автоматически системой во 
время бутирования, и её база сохраняется там.

    @{" easy.asm " link lib_examples/easy.asm/MAIN}

Функции принимают параметры в определённые @{"регистры" link Lib_26/26-2-3-1} 680x0 и всегда
возвращают результат в регистре данных D0.  Это позволяет программам и функциям,
написанным на ассемблере действовать быстро. Также это устраняет зависимоть
от границ стека, принятого в любом языке.

Функции библиотек Amiga используют @{"регистры" link Lib_26/26-2-3-1}: D0, D1, A0 и A1 для
рабочего пространства и регистр A6 для хранения базы библиотеки.
Не расчитывайте, что эти регистры не будут изменены после вызова функции.
все функции возвращают 32 битное длинное слово, если не оговорено иначе.

@ENDNODE

@NODE 1-1-2-3 "1 / / Библиотеки Функций / Другой Вид Библиотеки Функций"
Amiga имеет два вида библиотек: run-time библиотеки и link библиотеки.
Ранее обсуждались run-time библиотеки far. Run-time библиотеки составляют
большую часть AmigaOS и являются главной темой этого пособия.

Есть ещё идин тип библиотек, известный как линк библиотека (link library).
Хотя линк библиотека - это собрание функций такое как и run-time библиотека,
есть несколько важных отличий.

Run-time библиотека
    Или разделяемая билиотека (shared library) - группа функций управляемых 
    @{"Exec" link 1-1-3-1}, которая берет их из ПЗУ (ROM) или с диска ( в
    директории LIBS:).  Run-time библиотека должна быть открыта до использования
    (@{"см. выше" link 1-1-2}).  Функции в такой библиотеки доступны динамически
    во время работы и могут быть использованы многими программами в одно время,
    даже если в памяти только одна копия библиотеки.  Run-time библиотеки
    загружаются в память только по запросу программы и могут автоматически
    удаляться из памяти, когда больше не нужны.

Линк библиотека
    Это группа функций на диске, которая управляется компилятором во время
    линковки.   Линк библиотека не нуждается в открытие, в вместо этого вы 
    должны связать свой код с библиотекой во время компиляции.  Функции
    такой библиотеки фактически копируются в каждую программу.  Для примера
    функция @{"exit()" link dos/exit()}, используемая в @{"программах на C" link lib_examples/easy.c/MAIN}
    не является частью библиотек AmigaOS.  Она содержится в линк библиотеки,
    поддерживаемой @{"компилятором" link 1-2} (lc.lib для SAS/Lattice C или
    c.lib для Manx Aztec C).  Код, который исполняет функцию exit()
    копируется в каждую программу.

@ENDNODE

@NODE 1-1-2-4 "1 / / Библиотеки Функций / Библиотеки, Устройства (Devices) и Ресурсы"
Большенство функций AmigaOS организованы в группы разделяемых библиотек -
@{"run-time" link 1-1-2-3 9} библиотеки.  Amiga также имеет специализированные
функции, собранные в группы, названые устройствами (devices) и
ресурсами (resources), которые программисты используют для выполнения 
простейших операций ввода/вывода или доступа к железу.

Устроства и ресурсы подобны в смысле разделения @{"run-time" link 1-1-2-3}.
Они управляются @{"Exec" link 1-1-3-1} и должны быть открыты до использования.
Их функции отделены от программы и доступны динамически.  Несколько программ
могут иметь доступ к устройству или ресурсу, даже если в памяти есть только
одна копия устройства или ресурса (несколько ресурсов может использовать 
одна программа в одно время).

   ________________	 ________________
  |		   |	|		 |
  | AmigaDOS CLI   |	|   Workbench	 |
  | & utilities    |	| Icons/Drawers/ |
  |		   |	|   Utilities	 |
  |________________|	|________________|
	 |   |_________       |   |
	 |    _________|______|   |
	 |   |	    ___|____	  |
	 |   |	   /	    \	  |
	 |   |	  / Console  \	  |
	 |   |	 |  Device    |   |
	 |   |	  \	     /	  |
	 |   |	   \________/	  |
	 |   |	       |______	  |
   ______|___|_____	   ___|___|________
  |		   |	  |		   |
  |   AmigaDOS	   |	  |   Intuition    |
  |   Processes,   |	  | Windows,Menus  |
  |  File System   |	  | Gadgets,Events |
  |________________|	  |________________|
	 |		______|   |   |______
	 |	    ___|____	  |   _______|________
	 |	   /	    \	  |  |		      |
	 |	  /  Input   \	  |  |	  Layers      |
	 |	 |   Device   |   |  |	  Library     |
	 |	  \	     /	  |  |		      |
	 |	   \________/	  |  |________________|
	 |	       |	  |    ______|
	 |	       |     _____|___|______
	 |	       |    |		     |
	 |	       |    |	 Graphics    |
	 |	       |    |	Rendering    |
	 |	       |    |	Text, Gels   |
	 |	       |    |________________|
     ____|___	    ___|____	    |	      ________	     ________
    /	     \     /	    \	    |	     /	      \     /	     \
   /  SCSI &  \   / Keyboard \	    |	    /  Audio   \   /  Serial  \
  | Trackdisk  | | & Gameport |     |	   |   Device	| | & Parallel |
   \  Device  /   \  Devices /	    |	    \	       /   \  Devices /
    \________/	   \________/	    |	     \________/     \________/
	 |	       |	    |		  |		 |
   ______|_____________|____________|_____________|______________|______
  |									|
  |    Exec: Tasks, Messages, Interrupts, I/O, Libraries and Devices	|
  |_____________________________________________________________________|
	 |	       |	    |		  |	       |
   ______|_____________|____________|_____________|____________|________
  |		 |	      | 	    |		  |		|
  | Disk Control |  Keyboard  |  Graphics   |	 Audio	  |  I/O Ports	|
  |		 |  & Mouse   | 	    |		  |		|
  |______________|____________|_____________|_____________|_____________|


		Figure 1-1: Иерархия Системного Обеспечения Amiga


Устройства и ресурсы управляются @{"Exec" link 1-1-3-1}, как и библиотеки.
Более подробно о устройствах и ресурсах смотрите параграф @{"Exec Устройства I/O" link Lib_19/MAIN}
или Amiga ROM Kernel Reference Manual: @{"Устройства" link Devices_Manual/MAIN} для 
детального рассмотрения каждого устройства.
  ______________________________________________________________________
 |								       	|
 | Это должен знать каждый программист на Amiga			       	|
 | --------------------------------------------				|
 | Функции ОС Amiga доступны через разделяемые @{"run-time" link 1-1-2-3 9}			|
 | библиотеки.  Библиотеки должны быть открыты до использования.	|
 | Главная системная библиотека - @{"Exec" link 1-1-3-1} всегда открыта.			|
 | Её функция @{"OpenLibrary()" link 1-1-2} используется для открытия других библиотек.	|
 |______________________________________________________________________|

@ENDNODE

@NODE 1-1-3 "1 / Программирование в среде Amiga / Динамическая архитектура памяти"
В отличие от других ОС, AmigaOS использует обсолютные адреса памяти как можно
реже.  AmigaOS использыет технологию, позволяющую системным процедурам и данным
распологаться в памяти где угодно.

Amiga @{"run-time" link 1-1-2-3 9} библиотеки могут распологаться в любом месте в памяти,
так как всегда используются с помощью таблицы переходов (jump table).  Любая
библиотека, находящаяся в ПЗУ или загружанная с диска, должна быть связана c
структурой библиотеки (Library structure) и таблицей переходов в ОЗУ.


			  Нижняя память
			       /\
			       ||
		       ________||________
		      | 		 |
		      |  JMP Функция  N  |
		      | 	·	 |
		      | 	·	 |
		      |  JMP Функция  3  |
		      |  JMP Функция  2  |
		      |  JMP Функция  1  |
      Library Base____|__________________|
		      | 		 |
		      | Library Structure|
                      |     Структура    |
                      |    Библиотеки    |
		      |__________________|
		      | 		 |
		      |     Data Area	 |
                      |  Область данных  |
		      |__________________|
                               ||
			       ||
			       \/
			  Верхняя память


      Figure 1-2: Структура библиотеки и таблица переходов


Система знает, где начинается таблица переходов, потому что, когда библиотека 
открывается в первый раз, @{"Exec" link 1-1-3-1} создаёт структуру библиотеки
и запоминает её местоположение.	Порядок адресов в таблице переходов всегда
один и тот же, но функции могут распологаться где угодно в памяти. Следовательно
системные фукции настйледуются от версии к версии.  Получив доступ к таблице
переходов и подобрав соответствующее в ней смещение, можно найти любую функцию.

Не только функции могут быть перемещаемыми, но и системные структуры данных.
В @{"многозадачной" link 1-1-1} среде Amiga множество приложений действуют в одно время,
имея свой экран (screen), память, файлы, и даже подзадачи. Так как лубое количество
приложений может быть запущено или остановлено пользователем, системные структуры
должны быть установлены.  Они не могут распологаться в фиксированном месте,
так как сначала неизвестно ни их типа, ни количества.

Система устраняет эту проблуму, используя связанные списки данных о предметах:
библиотеках, задачах, экранах, файлах или памяти.  Связанный список - это цепочка
данных с элементамиб указывающими по порядку друг на друга.  Получая указатель
на первый элемент, можно найти ив списке любой.

@{" Exec: Администратор Системы " link 1-1-3-1}

@ENDNODE

@NODE 1-1-3-1 "1 / / Динамическая архитектура памяти / Exec: Администратор Системы"
Exec - сердце AmigaOS и заведует @{"многозадачностью" link 1-1-1}, предоставляя доступ к 
системным ресурсам (как память) и управляет системой библиотек.

Как @{"уже говорилось" link 1-1-2-2 8}, адрес 4 ($0000 0004), также известный как SysBase,
содержит @{"указатель" link Lib_26/26-2-3-1} на структуру @{"Exec" link Lib_18/MAIN}.
Это единственный абсолютный адрес в AmigaOS.  Программе необходимо только знать,
где найти библиотеку Exec, для манипулирования всеми другими системными
функциями.


			     $04 Sysbase
				  |
				  |
			     Exec Library
				  |
     _____________________________|_____________________________
    |	      | 	|	  |	    |	      | 	|
    |	      | 	|	  |	    |	      | 	|
БИБЛИОТЕКИ УСТРОЙСТВА ПАМЯТЬ   РЕСУРСЫ ПРЕРЫВАНИЯ   ПОРТЫ     ЗАДАЧИ
    |	      | 	|	  |	    |	      | 	|
   DOS	  Trackdisk   Блок 1	Potgo	  КОНЕЦ	    IDCMP	|
    |	      | 	|	  |		      | 	|
Graphics    Serial    Блок 2	Keymap		    IDCMP      / \
    |	      | 	|	  |		      |       /   \
Intuition  Parallel   КОНЕЦ	CIAA		  Workbench  /	   \
    |	      | 		  |		      |     /	 WAITING
Expansion  Printer		CIAB		    КОНЕЦ  /	    |
    |	      | 		  |			  /    File System
  Layers    Input		Disk			 /	    |
    |	      | 		  |		      READY    File System
 Mathffp   Keyboard		MISC			|	    |
    |	      | 		  |		      Shell    Input.device
   Icon    Gameport		КОНЕЦ			|	    |
    |	      | 				       RAM	  КОНЕЦ
 Diskfont   Timer					|
    |	      |                                    Приложение 1
  КОНЕЦ	    Audio                                       |
	      | 					|
	   Console				   Приложение 2
	      |                                         |
	    КОНЕЦ					|
			                              КОНЕЦ


	 Figure 1-3: Exec и организация AmigaOS


Эта диаграмма показывает, что все компоненты AmigaOS представляют дерево с 
корнем SysBase.  Каждый из них может в свою очередь иметь переменные и списки
данных.  В этом случае гибкость ОС повышается и модернизация может происходить
без потери @{"совместимости" link 1-4}.
  _______________________________________________________________________
 |									 |
 | Это должен знать каждый программист на Amiga				 |
 | --------------------------------------------				 |
 | Amiga имеет @{"динамическую память" link 1-1-3}.  Нет фиксированных адресов для	|
 | переменных и функций.  Не обращайтесь к функциям или системным	 |
 | структурам напрямую.  Вместо этого используйте косвенные методы       |
 | доступа, предоставляемые системой.				 	 |
 |_______________________________________________________________________|

@ENDNODE

@NODE 1-1-4 "1 / Программирование в среде Amiga / Версии ОС"
AmigaOS подвергалась нескольким важным переделкам приведённым в таблице.
Последняя версия - Release 2
(соответствует версии библиотек 36 и выше).


  Номер версии
  системы         Kickstart release
  --------------  -----------------
       0          Любая версия
       30	  Kickstart V1.0 (устарелая)
       31	  Kickstart V1.1 (только NTSC - устарелая)
       32	  Kickstart V1.1 (только PAL - устарелая)
       33	  Kickstart V1.2 (старейшая рабочая версия)
       34	  Kickstart V1.3 (добавлен autoboot)
       35	  Специальная версия Kickstart с поддержкой монитора A2024
       36	  Kickstart V2.0 (старая версия Release 2)
       37	  Kickstart V2.04 (текущая версия Release 2)


Все примеры в жтом пособии допускают использование Release 2.

Немало библиотек и функций, описанных в этом документе, доступны во всех версиях
AmigaOS.  Остальные полностью новые и не доступны без подходящей версии 
библиотеки.

Узнать какая функция новая в Release 2  можно в ROM Kernel
Reference Manual: @{"Includes and Autodocs" link 2.0Includes_Autodocs/Autodocs}.  Новые функции
отмечены (V36) или (V37) в строке NAME. Эти функции требуют использования
подходящей версии (36, 37 или выше) библиотеки.

@{"Грациозно Выйти" link Lib_27/27-2-8-2 14}, проинформировав, если требываемая версия библиотеки
не доступна.

@{" О Release 2 " link 1-1-4-1}

@ENDNODE

@NODE 1-1-4-1 "1 / / Версии ОС / О Release 2"
Release 2 впервые появилась на Amiga 3000.  Её начальная версия соответствовала
Kickstart V2.00, системной библиотеки версии V36.
Release 2 впоследствии была пересмотренна и её старая версия устарела.

Программы, написанные под Release 2, используют только следующие
версии (Kickstart V2.04 и выше), системные библиотеки версии V37 и выше.
Если ваша система использует ранюю версию Release 2, вам надо обновить её.

  _____________________________________________________________________
 |								       |
 | Это должен знать каждый программист на Amiga			       |
 | --------------------------------------------			       |
 | Некоторые библиотеки или функции не доступны в старых версиях ОС.   |
 | Будте уверены в минимальной версии, которую требует ваша программа. |
 |_____________________________________________________________________|

@ENDNODE

@NODE 1-1-5 "1 / Программирование в среде Amiga / Заказные чипы"
Наиболее важная часть железа Amiga- чипсет, который выполняет специальные задачи
независемо от процессора. Каждый из заказных чипов (названных Paula, Agnus,
и Denise) посвящены определённой работе:

Paula	(8364)		  Звук, диск, последовательный порт, прерывания
Agnus	(8361/8370/8372)  @{"Copper" link Lib_27/27-1-7} (видео сопроцессор), blitter, DMA
Denise	(8362)		  Цветовые регистры, цветовые ЦАП и спрайты

Чипсет может выполнять свою работу независимо от процессора, потому что он
имеет DMA или Прямой Доступ к Памяти.	DMA означает, что чипсет способен 
пользоваться некоторыми участками памяти без участия процессора. (На компьтерах
без DMA, процессор должен делать всю или почти всю работу по предоставлению
памяти для чипсета.)	Заказные чипы Amiga делают @{"многозадачность" link 1-1-1} особенно эффективной, 
потому что они делают многие вещи, как создание графики и звука независимо,
отдавая процессору больше времени для управления @{"переключением задач" link 1-1-1-1} и другой работы.

@{" Пересмотр Заказных Чипов " link 1-1-5-1}
@{" Два Вида Памяти " link 1-1-5-2}

@ENDNODE

@NODE 1-1-5-1 "1 / / Заказные Чипы / Пересмотр Заказных Чипов"
@{"Заказные чипы" link 1-1-5} с развитием Amiga были пересмотрены.  Последняя
версия чипсета извесна как Enhanced Chip Set, или @{"ECS" link Lib_27/27-1-5}.  Некоторые функции
AmigaOS, такие как высокое разрешение и @{"спец-режим genlock" link Lib_27/27-6}, требуют ECS.
В этом пособии функции, требующие ECS отмечены. Для более подробной информации
смотрите раздел по специальным функциям ECS - @{"Приложение C" link Hard_C/MAIN} из
Amiga Hardware Reference Manual.

@ENDNODE

@NODE 1-1-5-2 "1 / / Заказные Чипы / Два Вида Памяти"
Для повышения производительности Amiga, она имеет два BUSes (Binery Unit System) и
два вида памяти.  Chip память - память доступна как процессору, так @{"заказным чипам" link 1-1-5}.
Fast память - память доступна только процессору (и определённые карты расшиения)
Так как Chip память разделяемая, доступ процессора может быть затруднён, если
заказные чипы делают тяжёлую работу.  Доступ процессора к Fast памяти никогда
не замедляется соревнованием с заказными чипами.

Различия между Chip и Fast памятью очень важно для программиста, так как
любые манипуляции с данными напрямую заказными чипами, как видео данные,
аудио данные или спрайты должны быть в Chip памяти.
  _________________________________________________________________
 |								   |
 | Это должен знать каждый программист на Amiga			   |
 | --------------------------------------------			   |
 | Amiga имеет два вида памяти: Chip память и Fast память. 	   |
 | Используйте подходящий вид.					   |
 |_________________________________________________________________|

@ENDNODE

@NODE 1-2 "1 Введение в Систему Библиотек Amiga / О Примерах"
Большая часть примеров в этом пособии написаны на Cи (также есть немного 
примеров на Ассемблере 680x0).

Примеры на Cи были откомпилированы в пакете SAS C версии 5.10a. Опции
компилятора, использованные в каждом примере описаны в комментарие перед
программой.

В основном примеры совместимы с Manx Aztec C 68K версии 5.0d и другими 
компиляторами Cи, однако обычно необходимы некоторые изменения. Все примеры
на Си предполагают, что отключён автоматический признак Ctrl-C. Для SAS C
(и Lattice C версий 4.0 и веше) это делается так:


    /* Дабавим перед main() для перегрузки Ctrl-C, предусмотренной
     * в SAS (Lattice) C.  Событие Ctrl-C будет проигнорировано */

    int CXBRK ( void )	 { return(0); }
    int chkabort( void ) { return(0); }

Для Manx Aztec C, замените на:

    /* Это добавте повыше */
	    #include <functions.h>

    /* Это добавте до main() */
	    extern int Enable_Abort;   /* ссылка на abort */

    /* Это добавте после main(), как первую строку в программе */
	    Enable_Abort=0;	    /* выключает CTRL-C */


Другие изменения могут понадобиться в зависимости от примера и компилятора.
Большинство примеров на Си используют флаги опций компилятора SAS/C
(установите эквивалентные опции вашего компилятора):


-b1 = Small data модель.
-cf = Проверка прототипов функций.
  i = Игнорировать утверждения #include, которые уже встречались.
  s = Запоминать все буквенные строки, которые одинаковы в том же месте.
  t = Разрешить предупреждение о структурах, которые использованы до их определения.

 -v = Не включать проверку стека для каждой функции.
 -y = Загружать ругистр A4 адресом секции данных на входе функции.
      Флаги -v и -y в основном нужны для частей программ, которые
      вызываются системой напрямую, такие как: @{"серверы прерываний (interrupt servers)" link Lib_26/26-2-4},
      @{"подзадачи (subtasks)" link Lib_21/21-3 29}, @{"обработчики (handlers)" link Lib_26/26-2-3}
      и @{"callback hook" link Lib_37/37-2}.


Везде где не отмечено, примеры линкованы со стандартным SAS/C запускным кодом
c.o, SAS/C библотека lc.lib и библиотека Commodore amiga.lib.  Компилятор SAS/C
по умолчанию оперирует с 32-битными целыми.  Есди ваша среда разработки
использует 16-битовые целые, вы можете явно указывать определённые аргументы
как длинные (к примеру 1L << sigbit вместо 1 << sigbit).

Примеры на Ассемблере 680x0 ассемблированы на Innovatronics CAPE версии V2.x,
HiSoft Devpac версии V1.2 и Lake Forest Logic ADAPT версии 1.0. Никаких
изменений для перемещения кода между этими программи не потребуется.

@ENDNODE

@NODE 1-3 "1 Введение в Систему Библиотек Amiga / Общие Правила Разработки ПО для Amiga"
AmigaOS была описана в первых частях этой главы - @{"basic environment" link 1-1}.
Эта глава представляет особые правила, которым должны руководствоваться все 
программисты на Amiga.  Некоторые из них только для опытных программистов
или для тех, кто пишет на Ассемблере.

  * Следите за @{"потерей памяти" link Lib_D/D-1-26}.  Устраевайте ваш
    экран Workbench так, чтобы вы имели возможность запускать вашу программу
    без лишних открытий окон.  В Shell-окне наберите несколько раз Avail flush
    (см. об опции flush команды Avail версии @{"Release 2" link 1-1-4-1}).
    Запомните общий объём свободной памяти.  Запустите свою программу (не
    открывайте других окон) и выйдите из неё. В Shell наберите Avail flush.
    Сравните общей объём свободной памяти с прежним. Они должны быть одинаковыми.
    Любое раpkичие показывает, что ваше приложение не освобождает некоторое
    кол-во памяти или не закрывает библиотеку, драйвер (device) или шрифт (font).
    Запомните, что в Release 2, небольшая потеря памяти возможна только, если
    ваше прмложение использует первым аудио или устройство narrator (device).

  * @{"Отладте" link Lib_D/D-2} всю вашу программу и проверте все её функции.
    Новые отладчики, такие как Enforcer, MungWall, и Scratch помогут вам 
    найти неинициализированные указатели, попытки использовать освобожденную
    память и использование случайных регистров или условий (даже если
    ваша программа, кажется, работает правильно).

  * Всегда проверяйте, что вы получили ресурс о котором просили.  Это относится
    к памяти , окнам, экранам, хедлерам файлов, библиотекам, драйверам, портам,
    и т.д.  Где возможно получить ощибочный результат, сделайте исключение.
    Много плохо написанных программ кажутся надёжными, пока какая-то @{"ошибка" link Lib_D/D-1}
    (недостаток памяти или дисковые проблемы) заставит программу продолжать с
    неверным или нулевым указателем, или выйти на нетестированную часть кода.

  * Всегда убирайте за собой.  Это относится как к нормальному завершению
    программы, так и к @{"прерыванию программы" link Lib_21/21-3} из-за ошибосной
    ситуации. Всё, что было открыто, должно быть закрыто, всё что было выделено,
    должно быть освобождено. В общем правильно закрывать и освобождать в 
    порядке, обратным открытиям и выделениям.  Будте уверены в стартовом коде;
    некоторые вещи могут быть закрыты или освобождены за ваc автоматически,
    особенно при abort.  Если вы пишите на Си, убедитесь, что ваш код управляет
    @{"Ctrl-C" link 1-2 7} правильно.

  * Помните, что память периферийна и ПЗУ отличаются среди моделей и среди
    разных систем.  Не допускайте никаких предположений насчёт адресного
    пространства, хранения имён устройств или расположения структур в памяти.
    Никогда не вызывайте функции ПЗУ напрямую.  Остерегайтесь любого примера,
    который вызывает функции по адресам с $F0 0000 по $FF FFFF.  Это функции 
    ПЗУ и могут быть смещены в другой версии ОС.  Есть только один интерфейс
    к системному коду ПЗУ - через библиотеки, драйверы и ресурсы.

  * Не допускайте расположения баз библиотек или других структур в любом
    определённом месте в памяти.  Есть только один @{"обсолютный адрес" link 1-1-3-1 5} $00000004,
    который содержит указатель на базу библиотеки Exec. Не изменяйте и не
    полагайтесь на формат приватных системных структур. Это включает программирование
    @{"коппера" link Lib_27/27-1-7}, списков памяти и баз библиотек (library bases).

  * Никогда не предполагайте, что программы могут обращаться к железу напрямую.
    Всё жедезо контролируется ОС, которая отвечает за вмешательство от других
    программ.  Разделяемое железо требует от программ использования надлежащих
    протоколов.  Используйте определённый интерфейс; это лучший способ обеспечить
    совместимость вашего продукта с будущими моделями Amiga.

  * Никогда не трогайте разделяемые данные напрямую без соответствующего
    взаимного исключения - (@{"locking" link Lib_21/21-4-3}).  Помните, что
    другие задачи могут использовать эти же данные.

  * ОС не следит за размером @{"стека" link Lib_21/21-2-2 12} программ.	(Ваш
    компилятор может иметь @{"опцию" link 1-2 32}, чтобы делать это за вас.)
    Позаботьтесь о том, что ваша программа не переполняет стек и обеспечте
    дополнительный размер стека для возможности его использования в будущих
    версиях ОС.

  * Никогда не ип спользуйте циклы проверки сигналов.  Если ваша программа
    ждёт каких то внешних событий, как выбор меню или нажатия на клавишу,
    не топите @{"многозадачность" link 1-1-1}.  Вместо этого усыпите свою
    задачу вызовом функции @{"Wait()" link Lib_22/22-1-2} с сигнальными битами.
    Пример:

	signals = (ULONG)Wait(	(1<<windowPtr->UserPort->mp_SigBit) |
				    (1<<consoleMsgPortPtr->mp_SigBit)  );

    В примере мы переводим номер сигнального бита каждого из двух портов в
    маску, потом комбинируем их и передаём как аргумент функции Exec - @{"Wait()" link Lib_22/22-1-2}.
    Когда ваша задача проснётся, когда в порту появится сообщение (message).
    Убедитесь, что вы сделали @{"ReplyMsg()" link Lib_24/24-2-4} для всех
    сообщений.  Если вы не имеете сигнальных бит, используйте @{"Delay()" link dos/Delay()}
    или @{"WaitTOF()" link Lib_28/28-3-12-4} для обеспечения размерной задержки.

  * @{"Задачи (и процессы)" link Lib_17/17-1 51} исполняются в режиме
    пользователя (680x0 user mode).  @{"Supervisor режим" link Lib_21/21-7-1}
    зарезервирован для прерываний, traps, и диспечеризации задач.  
    Уделяйте особое внимание, если ваш код исполняется в режиме supervisor.
    Исключения в режиме supervisor смертельны.

  * Большенство системных функций требуют особой исполняющей среды. Все
    функции DOS и многие функции, вызывающие DOS (такие как открытие библиотек 
    с диска, шрифтов или устройств) могут быть выполнины только из @{"процесса" link Lib_17/17-1 51}.
    Просто задачи недостаточно. Большинство других функций ядра ОС могут
    испольняться из задачи. И только несколько из прерываний.

  * Никогла не @{"выключайте прерывания" link Lib_26/26-4} или многозадачность на
    длительные периоды.	Если вы используете @{"Forbid()" link Lib_21/21-4-1} или @{"Disable()" link Lib_21/21-4-2}, вы
    должны знать, что исполнение любой системной функции, которая содержит
    @{"Wait()" link Lib_24/24-2-2 31}, приведёт ко временному приостановлению
    состояния Forbid() или Disable(), и разрешит многозадачность и прерывания.
    Такие функции включают в себя почти все формы DOS и устройств I/O,
    включая общие функции stdio, как @{"printf()" link amiga_lib/printf()}.

  * Никогда не связывайте системные ресурсы, если это не необходимо. К примеру,
    если ваша программа не требует постояного использования принтера, открывайте
    устройство (драйвер), только когда нужно.  Это позволит другим задачам 
    использовать принтер.
    Вы должы обеспечить отклик по ошибки доступа к русурсу.

  * Все данные для @{"заказных чипов" link 1-1-5} должны располагаться в @{"Chip памяти" link 1-1-5-2}
    (включите  @{"MEMF_CHIP" link Lib_20/20-1-1 11}).  Такие как битпланы (bitplanes),
    звуковые сэмплы (sound samples), буфферы для trackdisk и изображения спрайтов,
    бобов (bobs), указателей (pointers), и кнопок (gadgets).  Функция @{"AllocMem()" link Lib_20/20-1}
    имеет флаг для спецификации типа памяти. Программа, которая ипсользует 
    неподходящий тип памяти может казаться работающей правильно, потому как
    многие Amiga имеют только Chip память.  (На всех моделях Amiga, первые
    512K памяти - Chip память.  В последующих моделях Chip память может 
    занимать первые два или один мегабайт).

    Тем не менее, @{"расширенная память" link 1-1-5-2} имеет тип @{"MEMF_FAST" link Lib_20/20-1-1 20},
    по умолчанию именно в ней выделяется память.  Следовательно программа
    может работать правильно на нерасширенной Amiga,  которая имеет только
    @{"Chip память" link 1-1-5-2}, тогда как расширенная  Amiga будет
    @{"сбрасыватьсяcrashing" link Lib_D/D-1-20}.  Разработчик с Chip памятью
    (только) может не заметить, что выбрал не тот тип.

    Большинство компиляторов имеют @{"опции" link 1-2 62} отмечать данные или
    объектные модули, так что они будут загружаться в @{"Chip RAM" link 1-1-5-2}.
    Если этот метод недоступен, используйте @{"AllocMem()" link Lib_20/20-1}
    для динамического выделения Chip памяти.

    Когда выделяете память, которая не должна быть @{"Chip памятью" link 1-1-5-2}, не ставте
    флаг @{"Fast memory" link 1-1-5-2}.  Вместо этого спрашивайте о типе памяти
    @{"MEMF_PUBLIC" link Lib_20/20-1-1 31} или 0L соответственно.  Если есть свободная
    Fast память, вы получите её.

  * Никогла не собственные циклы задержки!  Во @{"многозадачной" link 1-1-1} системе
    лучше это время потратить на исполнение других задач.
    Даже не смотря на такой отрецательный эффект, временные циклы неправильны
    и будут ждать разное время, в зависимости от модели Amiga.  Timer.device 
    обеспечивает точное время и используется в многозадачном режиме и работает
    одинакого на всех моделях Amiga.  Функция AmigaDOS @{"Delay()" link dos/Delay()}
    или графической библиотеки @{"WaitTOF()" link Lib_28/28-3-12-4} обеспечивает
    простейший интерфейс для больших задержек.	@{"Чипы ввода/вывода 8520" link hard_F/MAIN}
    содержат таймеры для разработчиков, которые обходят ОС (см. Amiga Hardware
    Reference Manua).

  * Всегда придерживайтесь правилам!

      · Все небайтовые поля должны быть выравнины по словам (word-aligned).
        Длинные слова (longwords) - соответственно (для производительности).

      · Все указатели должны быть 32-битными (не 24-битными).  Никогда не
        используйте старшие биты для данных.

      · Поля, не определённые содержать начальные значения, должны содержать
        нули. Это относится и к полям-указателям.

      · Все зарезервированные или не используемые поля должны быть
        проинициализированы 0 для будущей совместимости.

      · Данные, доступные для @{"заказных чипов" link 1-1-5}, общие данные
        (public data), например task control block, и структуры, которые 
        должны быть выравнины по длинным словам, размещаются на стеке.

      · Динамическое выделение структур с помощью @{"AllocMem()" link Lib_20/20-1}
        обеспечивает память нужного типа, выравниную по длинным словам
        с возможной инициализацией нулями.

@{" Для 68010/68020/68030/68040 Совместимости " link 1-3-1}
@{" Правила Программирования Железа " link 1-3-2}
@{" Дополнительные Правила Разработки для Ассемблера " link 1-3-3}

@ENDNODE

@NODE 1-3-1 "1 / Общие Правила Разработки / 68010/020/030/040 Совместимость"
Особое внимание должно быть уделено совместимости всех 680x0 процессоров:

  * Не используйте старшие 8 бит указателя для хранения информации.
    Процессоры 68020, 68030 и 68040 используют 32 битную адресацию.

  * Не используйте знаковые переменные или указатели для адресации.

  * Не используйте собственные циклы задержки, и не расчитывайте 
    на порядок в котором завершатся асинхронные задачи.

  * Стековый кадр, используемый для исключений различен для каждого
    процессора семейства 680x0.

  * Не используйте инструкцию MOVE SR,<dest> !	Эта команда 68000
    работает поразному на других процессорах.  Если вам нужно получить
    копию состояния процессора, пользуйтесь функцией Exec @{"GetCC()" link Lib_21/21-7-3}.

  * Не используйте команду CLR для регистров чипсета, которые имеют
    доступ только для записи.	68020 CLR делает только запись. 68000 CLR
    сначала читает, потом записывает. Используйте MOVE.x #0, <address>.

  * Само-модифицуруемый код очень нежелателен.  Все процессоры семейства 680x0
    имеют @{"кэш" link Lib_21/21-7-4}.  Это значит, что ЦП загружает команды
    наперёд.	Следовательно, если ваш код изменяет или расшифровывает себя,
    уже загруженные инструкции могут не соответствовать изменнёным. Более
    совершенные процессоры имеют больший объём кеша.  Если всёже такой код
    нужен, сброс кеша - самый безопасный способ.

  * 68020, 68030 и 68040 - все они имеют кеш команд.
    Этот кеш содержит недавно ипользованные команды, но не отмечает записи.
    После изменения или загрузки команд напрямую, кеш должен быть сброшен.
    Смотрите Autodoc по библиотеки Exec @{"CacheClearU()" link exec/CacheClearU()}.

@ENDNODE

@NODE 1-3-2 "1 / Общие Правила Разработки / Правила Программирования Железа"
Если вы нашли необходимым программировать напрямую железо, тогда ваша
обязанность писать код так, чтобы он работал правильно на разных моделях Amiga.
Будте уверены, что вы правильно запросили и используете какой-то из ресурсов
и будте особо осторожны в следующих областях:

  * Kickstart 2.0 использует чипы 8520 Complex Interface Adaptor (CIA)
    иначе, чем 1.3.  Для обеспечения совместимости, вы всегда должны запрашивать
    доступ к CIA, используя функции cia.resource: @{"AddICRVector()" link cia/AddICRVector()} и
    @{"RemICRVector()" link cia/RemICRVector()}.  Не делайте предположений
    о том, для чего ОС использует чипы CIA.  Если вы записываете напрямую
    в регистры CIA, не ждете, что от ОС обслуживания, например устройства
    trackdisk.device .  Если вы оставляете ОС, не читаете и не пишите 
    в Регистры Управления Прерываний CIA; используйте функции cia.resource @{"AbleICR()" link cia/AbleICR()} и
    @{"SetICR()" link cia/SetICR()}.  Даже если вы берёте всё управление 
    машиной на себя,не используйте начальные значения любого из регистров CIA
    или состояния лубого разрешённого прерывания.

  * Все регистры @{"заказных чипов" link 1-1-5} только для чтения (Read-only) или только для записи (Write-only).
    Не читайте Write-only-регистры и не записывайте в Read-only-регистры.

  * Никогда не запизывайте данные и не интерпретируйте данные из неиспользуемых
    бит или адресов в пространстве @{"чипсета" link 1-1-5}.  Для того, чтобы 
    быть программно совместимым с будущими версиями ОС, все неопределённые
    биты должны быть обнулёнными при записи, и должны быть маскированными при
    чтении до толкования их содержимого.

  * Никогда не пишите после адресного пространства @{"чипсета" link 1-1-5}.  Заказные чипы
    могут быть расширены или усеворшенствованы дополнительными регистрами,
    или могут использоваться ранее неиспользованные биты.

  * Никогда не читайте, не пишите и не используйте неопределённые адресные
    пространства или регистры.	Текущее и будущее использование подобных
    областей зарезервировано Commodore и подвергаются изменению.

  * Никогда не счетайте, что @{"регистры аппаратной части" link Hard_B/MAIN} будет инициализованы
    каким-то определённым значением.  Разные версии ОС устанавливать различные
    значения.  Свертесь с Amiga Hardware Reference Manual для гарантии того,
    что вы устанавливаете все регистры, которые воздействуют на вашу программу.

@ENDNODE

@NODE 1-3-3 "1 / Общие Правила / Дополнительные Правила Разработки для Ассемблера"
Если вы пишите на Ассемблере, есть несколько дополнительных правил:

  * Никогда не используйте команду TAS.  Системное DMA может конфликтовать 
    с неделимым циклом (read-modify-write) этой команды.

  * Системные функции должны вызываться с базой в @{"регистре" link Lib_26/26-2-3-1} A6.
    Даже если какая-то функция не требует этого регистра, вы должны обеспечить
    его для будущей совместимости.

  * Кроме этого, функции системы используют @{"регистры" link Lib_26/26-2-4-1} D0, D1, A0,
    и A1 как временные, и вы должны принимать во внимание, что  их прежние
    значения утерены после вызова функции. Функции, которые возвращают результат,
    хранят его в D0.

  * Никогда не полагайтесь на состояние процессора после вызова функции.
    Вы должны проверить возвращённое значение до того, как что-то делать.
    Обычно это реализуется с помощью команд TST или MOVE.

@ENDNODE

@NODE 1-4 "1 Введение в Систему Библиотек Amiga / Совместимость с 1.3"
Третье издание Amiga Technical Reference Series сфокусировано на @{"Второй" link 1-1-4-1} @{"версии" link 1-1-4}
AmigaOS (Kickstart V2.04, V37). Версия 2 была впервые использована на Amiga 3000,
а сейчас доступна как апгрейд для Amiga 500 и Amiga 2000. Версия 2 содержит
несколько новых библиотек и сотни новых функций, и особенностей в помощь
разработчикам приложений.

@{" Дезайн Решения " link 1-4-1}
@{" Совместимые Библиотеки " link 1-4-2}

@ENDNODE

@NODE 1-4-1 "1 / Совместимость с 1.3 / Дезайн Решения"
Последнии модели Amiga, включая все A3000, работают под @{"Версией 2" link 1-1-4-1}.
Но много более старых Amiga - всё ещё под 1.3.  В зависимости от вашего 
приложения и вашего рынка, вы можете посчетать необходимым использовать 
Версию 2, как минимальную платформу.  Это может быть разумным решением
для вертикальных рынков и профессиональных приложений.  Версия 2 также может
быть необходима для новых ревизий имеющихся программных продуктов. Если вы
приняли решение требывать Версию 2, значит вы свободны в использование преимуществ
всех новыз библиотек и особенностей, которые включены в неё.

В дальнейшем в этом пособие все особенности, функции и библиотеки, которые
были введены в @{"Версии 2" link 1-1-4-1}, будут обозначаться в описании 
как (V36) или (V37). Такие особенности недоступны  на Amiga, работающеми под
1.3 (V34) или @{"ранними версиями" link 1-1-4} ОС.  Безоговорочное использование
функций Версии 2 будет поводом для сбоя программы, когда она запускается на
машине с ОС 1.3.  Это очень важно, помнить об этом, когда вы пишите программу.

Разработчики развлекающих и полезных программ могут быть ещё не готовыми
писать приложения, которые требуют @{"Версию 2" link 1-1-4-1}, но даже они
могут повысить качество своих продуктов использую преимущества Версии 2, всё
ещё оставаясь совместимыми с 1.3.

Существует три простейших метода, позволяющих вам используя особенности Версии 2,
оставаться совместимым с 1.3 :

      * @{" Прозрачные Расширения Версии 2 " link 1-4-1-1}

      * @{" Условный Код " link 1-4-1-2}

      * @{"Совместимые Библиотеки" link 1-4-2}

@{" ASL Запросы " link 1-4-1-3}
@{" DOS System(), CreateNewProc(), и CON: Усовершенствования " link 1-4-1-4}
@{" База Данных: The Display DataBase " link 1-4-1-5}
@{" ARexx " link 1-4-1-6}

@ENDNODE

@NODE 1-4-1-1 "1 / / Дезайн Решения / Прозрачные Расширеня Версии 2"
Для обеспечения  совместимости с @{"Версией 2" link 1-1-4-1} и старой 1.3 @{"версией" link 1-1-4},
несколько знакомых структур ОС 1.3 были расширены для содержания необязательных
указателей на дополнительную информацию. Новые расширенные версии таких структур
в основном определены в тех же файлах, что и оригинальные.  Эти структуры
передаются тем же функциям ОС 1.3, что и нерасширенные (например: @{"OpenWindow()" link Lib_4/4-2-1},
@{"OpenScreen()" link Lib_3/3-3}, @{"AddGadget()" link intuition/AddGadget()}, @{"OpenDiskFont()" link Lib_29/29-2-1 5}).
Наличие дополнительной информации знаменуется новым флаговым битом.  (В  одном
случае  @{"PROPNEWLOOK" link Lib_5/5-11-1} - только один флаговый бит существенен.)
Эти расширения прозрачны для предыдущих версий ОС. Только Версия 2 распознает 
этот бит и отреагирует на дополнительную информацию.

Следующая таблица содержит флаги расширения для каждой структуры.

Оригинал  Расширение   Поле  	   Флаг		    Определён в
--------  ----------   ----------  --------	    -----------
NewScreen ExtNewScreen Type	   NS_EXTENDED	    <intuition/@{"screens.h" link Includes/intuition/screens.h/MAIN}>
NewWindow ExtNewWindow Flags	   WFLG_NW_EXTENDED <intuition/@{"intuition.h" link Includes/intuition/intuition.h/MAIN}>
Gadget	  Gadget       Flags	   GFLG_STRINGEXTEND<intuition/intuition.h>
PropInfo  PropInfo     Flags	   PROPNEWLOOK	    <intuition/intuition.h
TextAttr  TTextAttr    tta_Style   FSF_TAGGED	    <graphics/@{"text.h" link Includes/graphics/text.h/MAIN}>


С помощью этих структур приложение может запрашивать специальные функции
@{"Версии 2" link 1-1-4-1} совместимым с 1.3 способом.	Когда приложение
действует на машине под ОС Версии 2, активизируются дополнительные
возможности.

Расширения, доступные через эти структуры:


   Screen: Overscan, 3D Вид (SA_Pens), общие экраны (public screens),
           PAL/NTSC, новые режимы
   Window: Автоустановка размера, скрытые размеры (inner dimensions),
           меню помощи
   Gadget: Контроль за шрифтом, перья (pens) и редактирование строк
 PropInfo: 3D Вид пропорциональных gadgets
TTextAttr: Контроль за шириной шрифтов


Списки длинных слов, названных Тэгами (TagItem), используются для указания
дополнительной информации для многих таких структур.  Тэг-списки обеспечивают
открытый и совместимый сверху вниз мотод нарасщивания системных структур путём
хранения всех новых спецификаций в растяжимом массиве пар длинных слов.

Другое прозрачное расширение @{"Версии 2" link 1-1-4-1} - возможность библиотеки
diskfont.library @{"маштабировать" link Lib_29/29-1-1} битмэп и outline-шрифты
в произвольные размеры, и поддержка @{"маштабируемых outline-шрифтов" link Lib_29/29-1-1 8}.
Будте уверены, что эти новые маштабируемые шрифты разрешены вашему приложению,
сбросом флага @{"FPF_DESIGNED" link Lib_29/29-2-1 70} в @{"AvailFonts()" link Lib_29/29-6} или
@{"OpenDiskFont()" link Lib_29/29-2-1 5}.  Позвольте пользователю создавать
новые размеры шрифтов, обеспечивая выбор желаемого размера шрифта (ОС 1.3
возвращает ближащий размер, Версия 2 - запрошенный).

Смотрите @{"Intuition" link Libraries_Manual/User} и главу о библиотеки @{"graphics" link Libraries_Manual/Graph},
а также замечания в @{"include file" link contents/cats_cd@includes!utility}.
Смотрите главу о "@{"Библиотеке Utility" link lib_37/37-1}" для информации
о Тэгах и Тэговых списках.

@ENDNODE

@NODE 1-4-1-2 "1 / / Дезайн Решения / Условный Код"
Условный код представляет второй способ получения преимуществ @{"Версии 2" link 1-1-4-1}
в 1.3-совместимых приложениях.  Идея проста: добавить условия, базирующиеся
на версии библиотеки, для того чтобы пользоваться особенностями Версии 2, если
это возможно.  Есть много мощных и полезных функций Версии 2, которые стоит
определять через условный код.

Условный код всегда базируется на определённой версии доступной библиотеки.
Провал @{"OpenLibrary()" link 1-1-2 6}
(т.е. возврат значения NULL) означает, что библиотека запрошенной версии не 
доступна. Номер версии библиотеки, которая необходима может быть проверен
в LibBase->lib_Version.  Всегда проверяйте: версия больше или равна той, что
вам нужна.


    Пример условного кода:

    /* проверка присутствия новой библиотеки Версии 2 */
    if( AslBase = OpenLibrary("asl.library", 37L) )
	    { /* Готова к использованию библиотека ASL */ }
    else
	    { /* Нужно использовать другой метод */ }

    /* Проверка существования библиотеки с новыми возможностями Версии 2 */
    if(GfxBase->lib_Version >= 37) {/* значит возможны новые режимы genlock */}

@ENDNODE

@NODE 1-4-1-3 "1 / / Дезайн Решения / ASL Запросы"
@{"Библиотека ASL Версии 2" link Lib_16/16-1 4} обеспечивает стандартные файловые и шрифтовые
запросы. @{"Размещение" link Lib_16/16-2} и испольщывание ASL запросов может быть управляемо
написанием простой процедуры, если возможно.  Иначе используется fallback-код
или public domain запрос. Используя ASL запросы, вы можете обепечить знакомый
вашему пользователю интерфейс, извлекая всю пользу из ASL файлового реквестора,
и перестать поддерживать свой собственный код запросов.

@ENDNODE

@NODE 1-4-1-4 "1 / / Дезайн Решения / DOS System(), CreateNewProc(), и CON: Усовершенствования"
Если ваша программа использует AmigaDOS 1.3 @{"Execute()" link dos/Execute()} или @{"CreateProc()" link dos/CreateProc()},
тогда следует использовать условный код для использования их замен, когда
программа будет запущена под @{"Версией 2" link 1-1-4-1}. Функция @{"System()" link dos/SystemTagList() 10}
Версии 2 позволяет вам передавать командную строку AmigaDOS, как если бы она
была набрана в окне Shell.  System() может работать синхронно с возвращаемым
значением или асинхронно с автоматическим отчисткой и она также устанавливает
надлежащий среду ввода/вывода, когда получает DOS дискриптор файла для SYS_Input 
и NULL для SYS_Output.  В комбинации с улучшеным CON:, System() может обеспечить
подходящую среду выполнения на обоих Workbench или заказном экране. Функция
@{"CreateNewProc()" link dos/CreateNewProc()} предоставляет дополнительный
контроль и простату в создание процесса.

Теперь CON: поддерживает ввод и вывод в заказных экранах и окнах Intuition.
Новые опции хедлера консоли (CON:) @{"Версии 2" link 1-1-4-1} обеспечивает
возможность открывать CON: на любом общем экране Intuition или привязывать
CON: к уже существующему окну.  Дополнительные опции могут добовлять и
закрывать кнопки или создавать AUTO-консоль окно, которое откроется, если
доступно для чтения или записи. Дабавте условный код для использования
этих методов, когда программа быдет запущена под ОС Версии 2 или более 
поздней версией ОС.  Запомните, что дополнительная опция CON: может быть
удалена под 1.3 во время выполнения, установкой в строке CON: NULL после 
заголовка окна. Смотрите The AmigaDOS Manual by Bantam Books для дополнительной
информации о CON: и DOS особенностей ОС Версии 2.

@ENDNODE

@NODE 1-4-1-5 "1 / / Дезайн Решения / База Данных: The Display DataBase"
Графическая библиотека @{"Версии 2" link 1-1-4-1} и Enhanced Chip Set (@{"ECS" link 1-1-5-1})
предусматривают программируемые @{"экранные режимы" link Lib_27/27-1-5} и повышенные @{"genlock" link Lib_27/27-6} способности.
Пользователи Версии 2 и ECS могут желать использовать ваше приложение в одном
из новых экранных режимов. База Данных Display Database Версии 2 обеспечивает
информацией на все режимы, которые возможны на машине пользователя и мониторе.
В добавок, полезной информацией о способности и aspect ratio каждого режима
(DisplayInfo.Resolution.x и .y).  Новая функция {"ModeNotAvailable()" link Lib_27/27-2-9-9 5} позволяет
вам легче проверить возможен ли данный режим.

Структура @{"ExtNewScreen" link Lib_3/3-3-1-2} используется с функцией @{"OpenScreen()" link Lib_3/3-3}
Intuition, позволяя вам указывать новфе режимы с Тэгом @{"SA_DisplayID" link Lib_3/3-3-2 74} и
длинным словом ModeID.  Функция графической библиотеки Версии 2 @{"VideoControl()" link Lib_27/27-6-1}
предусматривает улучшенные возможности @{"genlock" link Lib_27/27-6} для @{"ECS" link 1-1-5-1} машин и
genlock'ом.  Небольшой условный код необходим для поддержки этих особенностей.
Смотрите главы о @{"графической библиотеке" link Libraries_Manual/Graph} и @{"Autodocs" link 2.0Includes_Autodocs/Autodocs}.

@ENDNODE

@NODE 1-4-1-6 "1 / / Дезайн Решения / ARexx"
Дабавте к вашей программе условный код ARexx-поддержки.  ARexx есть на всех
машинах с ОС @{"Версии 2" link 1-1-4-1} и на многие пользователи 1.3 покупают
ARexx отдельно. ARexx-поддержка дабавит ценности вашему продукту и позволит
пользователям и разработчикам вертикального рынка создавать свои и гибридные
приложения. Добавте возможность контроля вашим приложением извне через ARexx,
и изнутри через ARexx макроопределения.  Позвольте пользователю исполнять 
ARexx скрипты (scripts) для контроля других программ, включая возможность 
передачи информации из вашей программы другой.  Дополнительно смотрите Amiga
Programmer's Guide to ARexx, опубликованую (@{"CATS" link 1-5}). На счёт
заказа этой книги свяжитесь с местным представителем Commodore.

@ENDNODE

@NODE 1-4-2 "1 / Совместимость с 1.3 / Совместимые Библиотеки"
Совместимые библиотеки представляют третий метод использования ОС @{"Версии 2" link 1-1-4-1},
не теряя совместимости с ОС 1.3.  Некоторые библиотеки Версии 2 - 1.3-совместимые
и могут быть распространяться с вашем продуктом, если вы имеете Лицензию 1.3 Workbench
и право на распространение дополнительных библиотек.

@{" Библиотека IFFParse " link 1-4-2-1}
@{" Математические Библиотеки Одинарной Точности IEEE " link 1-4-2-2}
@{" Совместимые Библиотеки Третьих Компаний " link 1-4-2-3}

@ENDNODE

@NODE 1-4-2-1 "1 / / Совместимые Библиотеки / Библиотека IFFParse "
Новая библиотека @{"IFFParse" link Lib_33/MAIN} совместима с обоими версиями ОС:
@{"Версией 2" link 1-1-4-1} and the 1.3.  IFFParse - разделяемая библиотека,
которая обеспечивает низкоуровневый интерфейс для чтения, записи и разбора
IFF файлов.  Используйте библиотеку IFFParse и новые примеры, что значительно
уменьшет время разработки и отладки.  В добавок, IFFParse обеспечивает легкий
контроль за устройством clipboard.  Смотрите главу о Билиотеке @{"IFFParse" link lib_33/MAIN}
и @{"IFF Приложение" link dev_A/MAIN} Amiga ROM Kernel Reference Manual: Devices.

@ENDNODE

@NODE 1-4-2-2 "1 / / Совместимые Библиотеки / Математические Библиотеки Одинарной Точности IEEE"
Математические библиотеки @{"одинарной точности IEEE Версии 2" link Lib_35/35-7} также
совместимы с 1.3. Эти библиотеки содержат математические функции одинарной 
точности, которые используют математический сопроцессор, если возможно.

@ENDNODE

@NODE 1-4-2-3 "1 / / Совместимые Библиотеки / Совместимые Библиотеки Третьих Компаний"
Разработчики могут пожелать создавать интерфейс пользователя более простым
способом, используя библиотеки @{"GadTools Версии 2" link Lib_15/MAIN} и @{"ASL" link Lib_16/16-1}.
Эти новые библиотеки не совместимы с ОС 1.3, но существует несколько версий
третьих компаний, которые совместимы с 1.3. Вы можете использовать эту
возможность.

@ENDNODE

@NODE 1-5 "1 / Введение / Приложения Commodore и Техническая Поддержка (CATS) "
Commodore содержит группу технической поддержки, призванную помогать
разработчикам достигать их цели с Amiga. Сейчас программы технической
поддержки доступны для мелких независемых разработчиков и больших
корпораций.  Подписка на публикации технической поддержки Commodore,
Amiga Mail, доступны любому, кто интересуется последними новостями, программным
обеспечением Commodore и изменениями в железе, и советами для программистов.

Для заказа приложения поддержки разработчика или списка технической публикации
CATS, вышлете свой адрес конвертом 9" x 12" по адресу:


	CATS-Information
	1200 West Wilson Drive
	West Chester, PA  19380-4231

@ENDNODE

@NODE 1-6 "1 Введение в Систему Библиотек Amiga / Сообщения об Ошибках"
В сложных технических пособияз часто имеются ошибки. Если они найдутся,
они будут исправлены последующих выпусках.  Обновления будут распростронены
в Amiga Mail, издании технической поддержки Commodore.

Сообщения об ошибках могут быть пресланы Commodore по электронной почте или
просто по почте.  Представленные отчеты должны быть ясными, закончиными и
краткими.  Сообщения должны включать в себя телефонный номер и достаточно
информации для скорейшего устранения ошибки, выявленной вами (то есть,
пожалуйста описывайте ошибку и шаги, приводящие к ней).


	Amiga Software Engineering Group
	ATTN: BUG REPORTS
	Commodore Business Machines
	1200 Wilson Drive
	West Chester, PA  19380-4231
	USA


	BIX:	amiga.com/bug.reports(Commercial developers)
		amiga.cert/bug.reports(Certified developers)
		amiga.dev/bugs(Others)


	USENET: bugs@commodore.COM  or	uunet!cbmvax!bugs

        По вопросам перевода обращаться:
		Владимир Яворский <jvovka@belnet.ru>


@ENDNODE
