DEFINITION MODULE GadToolsBox {"gadtoolsbox.library", 39};

(*
 * -------------------------------------------------------------------------
 *
 *	:Program.	GadToolsBox.def
 *	:Contents.	Interface to GadToolsBox.library 39.3 by Jaan van den Baard
 *
 *	:Author.	Reiner B. Nix
 *	:Address.	Geranienhof 2, 50769 Köln Seeberg
 *	:Address.	rbnix@pool.informatik.rwth-aachen.de
 *	:Copyright.	free
 *	:Language.	Modula-2
 *	:Translator.	M2Amiga A-L V4.2d
 *	:History.	this interface descends from the original C-Interface  and 
 *	:History.	 the Oberon Interface by Kai Bolay
 *	:History.	GadToolsBox.def 1.0   ;M2Amiga 4.0d
 *	:History.	GadToolsBox.def 1.1   ;M2Amiga 4.2d
 *
 * -------------------------------------------------------------------------
 *)

FROM	SYSTEM		IMPORT	ADDRESS, BITSET, LONGSET, BYTE,
				CAST;
FROM	ExecD		IMPORT	Library,
				MsgPortPtr,
				LibraryPtr, DevicePtr;
FROM	GraphicsD	IMPORT	TextAttr,
				RastPortPtr, GfxBasePtr;
FROM	IntuitionD	IMPORT	IDCMPFlagSet, WindowFlagSet,
				IntuiText, ColorSpec,
				IntuiTextPtr, GadgetPtr, IClassPtr,
				IntuiMessagePtr, DrawInfoPtr,
				WindowPtr, RequesterPtr,
				IntuitionBasePtr;
FROM	DosD		IMPORT	DosLibraryPtr;
FROM	UtilityD	IMPORT	tagUser,
				Tag,
				TagItemPtr;
FROM	GadToolsD	IMPORT	NewMenu, NewGadget,
				NewGadgetPtr;
FROM	NoFrag		IMPORT	MemoryChainPtr;
IMPORT	R;


(* gadtoolsbox/forms.h *)
CONST	idGXMN		=CAST (LONGINT, "GXMN");	(* FORM identifiers		*)
	idGXTX		=CAST (LONGINT, "GXTX");
	idGXBX		=CAST (LONGINT, "GXBX");
	idGXGA		=CAST (LONGINT, "GXGA");
	idGXWD		=CAST (LONGINT, "GXWD");
	idGXUI		=CAST (LONGINT, "GXUI");

	idMEDA		=CAST (LONGINT, "MEDA");	(* chunk identifiers		*)
	idITXT		=CAST (LONGINT, "ITXT");
	idBBOX		=CAST (LONGINT, "BBOX");
	idGADA		=CAST (LONGINT, "GADA");
	idWDDA		=CAST (LONGINT, "WDDA");
	idGGUI		=CAST (LONGINT, "GGUI");

	idVERS		=CAST (LONGINT, "VERS");


TYPE	VersionPtr	=POINTER TO Version;		(* Version (ID_VERS) chunk...	*)

	Version		=RECORD	version		:CARDINAL;
				flags		:BITSET;
				reserved	:ARRAY [1..4] OF LONGCARD;
				END;


CONST	maxMenuTitle	=80;				(* NewMenu (ID_MEDA) chunk...	*)
	maxMenuLabel	=34;
	maxShortcut	=2;

	MenuVersion	=0;


TYPE	MenuDataPtr	=POINTER TO MenuData;

	MenuData	=RECORD	newMenu		:NewMenu;
				title		:ARRAY [0..maxMenuTitle-1] OF CHAR;
				label		:ARRAY [0..maxMenuLabel-1] OF CHAR;
				shortCut	:ARRAY [0..maxShortcut-1] OF CHAR;
				flags		:BITSET
				END;


CONST	maxTextLength	=80;				(* IntuiText (ID_ITXT) chunk...	*)
	ITextVersion	=0;


TYPE	ITextDataPtr	=POINTER TO ITextData;

	ITextData	=RECORD	iText		:IntuiText;
				text		:ARRAY [0..maxTextLength-1] OF CHAR
				END;


CONST	BBoxVersion	=0;				(* BevelBox (ID_BBOX) chunk...	*)


TYPE	BBoxFlags	=(recessed, dropBox,
			  bbf2, bbf3, bbf4, bbf5, bbf6, bbf7, bbf8,
			  bbf9, bbf10, bbf11, bbf12, bbf13, bbf14, bbf15);

	BBoxFlagSet	=SET OF BBoxFlags;


	BBoxDataPtr	=POINTER TO BBoxData;

	BBoxData	=RECORD	left,
				top		:INTEGER;
				width,
				height		:CARDINAL;
				flags		:BBoxFlagSet
				END;


CONST	maxGadgetText	=80;				(* NewGadget (ID_GADA) chunk...	*)
	maxGadgetLabel	=34;

	GadgetVersion	=0;


TYPE	GadgetFlags	=(gf0, gf1, gf2, gf3, gf4, IsLocked, NeedLock, gf7, gf8,
			  gf9, gf10, gf11, gf12, gf13, gf14, gf15,
			  gf16, gf17, gf18, gf19, gf20, gf21, gf22, gf23,
			  gf24, gf25, gf26, gf27, gf28, gf29, gf30, gf31);

	GadgetFlagSet	=SET OF GadgetFlags;


	GadgetDataPtr	=POINTER TO GadgetData;

	GadgetData	=RECORD	newGadget	:NewGadget;
				gadgetText	:ARRAY [0..maxGadgetText-1] OF CHAR;
				gadgetLabel	:ARRAY [0..maxGadgetLabel-1] OF CHAR;
				flags		:GadgetFlagSet;
				kind		:CARDINAL;
				numTags		:CARDINAL;
				reserved4	:ARRAY [1..4] OF LONGCARD;
				END;


CONST	maxWindowName	=34;				(* Window (ID_WDDA) chunk...	*)
	maxWindowTitle	=80;
	maxWdScreenTitle=80;

	WindowVersion	=0;


TYPE	WindowTagFlags	=(InnerWidth, InnerHeight, Zoom, MouseQueue, RptQueue,
			  AutoAdjust, DefaultZoom, FallBack,
			  wtf8, wtf9, wtf10, wtf11, wtf12, wtf13, wtf14, wtf15,
			  wtf16, wtf17, wtf18, wtf19, wtf20, wtf21, wtf22, wtf23,
			  wtf24, wtf25, wtf26, wtf27, wtf28, wtf29, wtf30, wtf31);

	WindowTagFlagSet=SET OF WindowTagFlags;


	WindowDataPtr	=POINTER TO WindowData;

	WindowData	=RECORD	name		:ARRAY [0..maxWindowName-1] OF CHAR;
				title		:ARRAY [0..maxWindowTitle-1] OF CHAR;
				screenTitle	:ARRAY [0..maxWdScreenTitle-1] OF CHAR;
				numTags		:CARDINAL;
				idCountFrom	:CARDINAL;
				idcmpFlags	:IDCMPFlagSet;
				windowFlags	:WindowFlagSet;
				tagFlags	:WindowTagFlagSet;
				innerWidth,
				innerHeight	:CARDINAL;
				showTitle	:BOOLEAN;
				mouseQueue,
				rptQueue	:CARDINAL;
				flags		:BITSET;
				leftBorder,
				topBorder	:CARDINAL;
				reserved	:ARRAY [1..10] OF BYTE
				END;


CONST	maxScreenTitle	=80;				(* GUI (ID_GGUI) chunk...	*)
	maxFontName	=128;
	maxColorSpec	=33;
	maxDriPens	=10;
	maxMoreDriPens	=10;

	GuiVersion	=0;


TYPE	GuiFlags	=(AutoScroll, Workbench, Public, Custom,
			  guif4, guif5, guif6, guif7, guif8,
			  guif9, guif10, guif11, guif12, guif13, guif14, guif15,
			  guif16, guif17, guif18, guif19, guif20, guif21, guif22, guif23,
			  guif24, guif25, guif26, guif27, guif28, guif29, guif30, guif31);

	GuiFlagSet	=SET OF GuiFlags;


	GuiDataPtr	=POINTER TO GuiData;

	GuiData		=RECORD	flags0		:GuiFlagSet;
				screenTitle	:ARRAY [0..maxScreenTitle-1] OF CHAR;
				left,
				top,
				width,
				height		:CARDINAL;
				depth		:CARDINAL;
				displayID	:LONGSET;
				overscan	:CARDINAL;
				driPens		:ARRAY [0..maxDriPens-1] OF CARDINAL;
				colors		:ARRAY [0..maxColorSpec-1] OF ColorSpec;
				fontName	:ARRAY [0..maxFontName-1] OF CHAR;
				font		:TextAttr;
				moreDriPens	:ARRAY [0..maxMoreDriPens-1] OF CARDINAL;
				reserved	:ARRAY [1..5] OF LONGCARD;

				flags1		:LONGSET;	(* private fields 	*)
				stdScreenWidth,
				stdScreenHeight	:CARDINAL;
				activeKind	:CARDINAL;
				lastProject	:CARDINAL;
				gridX,
				gridY		:CARDINAL;
				offX,
				offY		:CARDINAL;
				reserved1	:ARRAY [1..7] OF CARDINAL
				END;


(* gadtoolsbox/prefs.h *)
CONST	GTBConfigSave	="ENVARC:GadToolsBox/GadToolsBox.prefs";
	GTBConfigUse	="ENV:GadToolsBox/GadToolsBox.prefs";

	GTBConfigVersion=0;
	maxUserName	=64;
	maxIconPath	=128;

	idGTCO		=CAST (LONGINT, "GTCO");


TYPE	GTConfigFlags	=(Coordinates, WriteIcon, GZZAdjust, Crunch, CloseWBench,
			  Password, Overwrite, ASLFReq, FontAdapt, UsePubScreen,
			  gtcf10, gtcf11, gtcf12, gtcf13, gtcf14, gtcf15,
			  gtcf16, gtcf17, gtcf18, gtcf19, gtcf20, gtcf21, gtcf22, gtcf23,
			  gtcf24, gtcf25, gtcf26, gtcf27, gtcf28, gtcf29, gtcf30, gtcf31);

	GTConfigFlagSet	=SET OF GTConfigFlags;


	GadToolsConfigPtr=POINTER TO GadToolsConfig;

	GadToolsConfig	=RECORD	configFlags0	:GTConfigFlagSet;
				configFlags1	:LONGSET;
				crunchBuffer	:CARDINAL;
				crunchType	:CARDINAL;
				userName	:ARRAY [0..maxUserName-1] OF CHAR;
				iconPath	:ARRAY [0..maxIconPath-1] OF CHAR;
				reserved	:ARRAY [1..4] OF LONGCARD
				END;


(* GadToolsBox library generation prefs file format 			*)
(* NOTE: This is not yet supported by GadToolsBox and the library! 	*)

CONST	GTBLibGenSave	="ENVARC:GadToolsBox/LibGen.prefs";
	GTBLinGenUse	="ENV:GadToolsBox/LibGen.prefs";

	GTBLibGenVersion=0;
	maxLibName	=32;
	maxBaseName	=32;

	idLIBG		=CAST (LONGINT, "LIBG");


TYPE	LibraryGenFlags	=(Generate, Module, FailReq, DiskLib, Internal,
			  lgf5, lgf6, lgf7,
			  lgf8, lgf9, lgf10, lgf11, lgf12, lgf13, lgf14, lgf15);

	LibraryGenFlagSet=SET OF LibraryGenFlags;


	LibraryGenPtr	=POINTER TO LibraryGen;

	LibraryGen	=RECORD	libraryName	:ARRAY [0..maxLibName] OF CHAR;
				libraryBase	:ARRAY [0..maxBaseName] OF CHAR;
				flags		:LibraryGenFlagSet;
				minVersion	:INTEGER;
				reserved	:ARRAY [1..4] OF LONGCARD
				END;


CONST	GTBGenSaveC	="ENVARC:GadToolsBox/GenC.prefs";
	GTBGenUseC	="ENV:GadToolsBox/GenC.prefs";

	GTBGenCVersion	=0;

	idGENC		=CAST (LONGINT, "GENC");


TYPE	GenCFlags	=(gcStatic, gcGenOpenFont, gcSysFont, gcPragmas,
			  gcAtztec, gcGenHandler, gcTemplates, gcf7,
			  gcf8, gcf9, gcf10, gcf11, gcf12, gcf13, gcf14, gcf15,
			  gcf16, gcf17, gcf18, gcf19, gcf20, gcf21, gcf22, gcf23,
			  gcf24, gcf25, gcf26, gcf27, gcf28, gcf29, gcf30, gcf31);

	GenCFlagSet	=SET OF GenCFlags;


	GenCPtr		=POINTER TO GenC;

	GenC		=RECORD	gtConfig	:GadToolsConfig;
				genCFlags0	:GenCFlagSet;
				getCFlags1	:LONGSET;
				reserved	:ARRAY [1..4] OF LONGCARD
				END;


CONST	GTBGenAsmSave	="ENVARC:GadToolsBox/GenAsm.prefs";
	GTBGenAsmUse	="ENV:GadToolsBox/GenAsm.prefs";

	GTBGenAsmVersion=0;

	idGENA		=CAST (LONGINT, "GENA");


TYPE	GenAsmFlags	=(gaStatic, gaRaw, gaGenOpenFont, gaSysFont,
			  gaAmigaLib, gaf5, gaf6, gaf7,
			  gaf8, gaf9, gaf10, gaf11, gaf12, gaf13, gaf14,
			  gaf15, gaf16, gaf17, gaf18, gaf19, gaf20, gaf21, gaf22, gaf23,
			  gaf24, gaf25, gaf26, gaf27, gaf28, gaf29, gaf30, gaf31);

	GenAsmFlagSet	=SET OF GenAsmFlags;


	GenAsmPtr	=POINTER TO GenAsm;

	GenAsm		=RECORD	gtConfig	:GadToolsConfig;
				genAsmFlags0	:GenAsmFlags;
				genAsmFlags1	:LONGSET;
				reserved	:ARRAY [1..4] OF LONGCARD
				END;



(* gadtoolsbox/gui.h *)
TYPE	ExtNewGadgetPtr	=POINTER TO ExtNewGadget;
	ExtGadgetListPtr=POINTER TO ExtGadgetList;

	ExtGadgetList	=RECORD	head,
				tailPred,
				tail		:ExtNewGadgetPtr
				END;

	ExtNewGadget	=RECORD	succ,
				prev		:ExtNewGadgetPtr;
				tags		:TagItemPtr;
				reserved0	:ARRAY [1..4] OF BYTE;
				newGadget	:NewGadget;
				gadgetLabel	:ARRAY [0..maxGadgetLabel-1] OF CHAR;
				gadgetText	:ARRAY [0..maxGadgetText-1] OF CHAR;
				flags		:GadgetFlagSet;
				kind		:CARDINAL;
				reserved1	:ARRAY [1..4] OF LONGCARD
				END;


TYPE	ExtNewMenuPtr	=POINTER TO ExtNewMenu;
	ExtMenuListPtr	=POINTER TO ExtMenuList;

	ExtMenuList	=RECORD	head,
				tailPred,
				tail		:ExtNewMenuPtr
				END;

	ExtNewMenu	=RECORD	succ,
				prev		:ExtNewMenuPtr;
				reserved0	:ARRAY [1..6] OF BYTE;
				newMenu		:NewMenu;
				menuTitle	:ARRAY [0..maxMenuTitle-1] OF CHAR;
				menuLabel	:ARRAY [0..maxMenuLabel-1] OF CHAR;
				reserved1	:ARRAY [1..4] OF BYTE;
				items		:ExtMenuListPtr;
				reserved2	:ARRAY [1..2] OF BYTE;
				commKey		:ARRAY [0..maxShortcut-1] OF CHAR;
				reserved3	:ARRAY [1..2] OF BYTE
				END;


TYPE	BevelBoxPtr	=POINTER TO BevelBox;
	BevelListPtr	=POINTER TO BevelList;

	BevelList	=RECORD	head,
				tailPred,
				tail		:BevelBoxPtr
				END;

	BevelBox	=RECORD	succ,
				prev		:BevelBoxPtr;
				reserved0	:ARRAY [1..4] OF BYTE;
				left,
				top		:CARDINAL;
				width,
				height		:INTEGER;
				reserved1	:ARRAY [1..32] OF BYTE;
				flags		:BBoxFlagSet
				END;


TYPE	ProjectWindowPtr=POINTER TO ProjectWindow;
	WindowListPtr	=POINTER TO WindowList;

	WindowList	=RECORD	head,
				tailPred,
				tail		:ProjectWindowPtr
				END;

	ProjectWindow	=RECORD	succ,
				prev		:ProjectWindowPtr;
				reserved0	:ARRAY[1..6] OF BYTE;
				name		:ARRAY [0..maxWindowName-1] OF CHAR;
				countIDFrom	:CARDINAL;
				tags		:TagItemPtr;
				leftBorder,
				topBorder	:CARDINAL;
				windowTitle	:ARRAY [0..maxWindowTitle-1] OF CHAR;
				screenTitle	:ARRAY [0..maxWdScreenTitle-1] OF CHAR;
				reserved2	:ARRAY [1..192] OF BYTE;
				idcmpFlags	:IDCMPFlagSet;
				windowFlags	:WindowFlagSet;
				windowText	:IntuiTextPtr;
				gadgets		:ExtGadgetList;
				menus		:ExtMenuList;
				boxes		:BevelList;
				tagFlags	:WindowTagFlagSet;
				innerWidth,
				innerHeight	:INTEGER;
				showTitle	:BOOLEAN;
				reserved3	:ARRAY [1..6] OF BYTE;
				mouseQueue,
				rptQueue	:CARDINAL;
				flags		:BITSET
				END;


CONST	rgTagBase	=tagUser + 512;

TYPE	rgTags		=(rgGUI := rgTagBase + 1,	(* GuiDataPtr				*)
			  rgConfig,			(* GadToolsConfigPtr			*)
			  rgCConfig,
			  rgAsmConfig,
			  rgLibGen,			(* not supported yet.			*)
			  rgWindowList,			(* WindowListPtr			*)
			  rgValid,			(* vlfFlagSetPtr  *** POINTER ***	*)
			  rgPasswordEntry);		(* see Powerpacker-Library!!!		*)


	vlfFlags	=(vlfGUI, vlfConfig, vlfCConfig, vlfAsmConfig,
			  vlfLibGen, vlfWindowList);

	vlfFlagSet	=SET OF vlfFlags;


	gtbErrors	=(gtbErrorNone,
			  gtbErrorNoMem, gtbErrorOpen, gtbErrorRead,
			  gtbErrorWrite, gtbErrorParse, gtbErrorPacker,
			  gtbErrorPPLib, gtbErrorNotGuiFile);

(* gadtoolsbox/hotkey *)
TYPE	HotKeyHandle	=ADDRESS;

	RepeatFlags	=(srbMX, srbCycle, srbSlider, srbScroller,
			  srbListView, srbPalette);

	RepeatFlagSet	=SET OF RepeatFlags;


CONST	hkhTagBase	=tagUser + 256;

TYPE	hkhTags		=(hkhKeyMap := hkhTagBase + 1,	(* KeyMapPtr to use. Create & Set.	*)
			  hkhUseNewButton,		(* BOOLEAN if replace. Create only.	*)
			  hkhUseNewText,		(* BOOLEAN if replace. Create only.	*)
			  hkhSetRepeat);		(* RepeatFlagSet. Create & Set.		*)



(* gadtoolsbox/textclass.h *)
CONST	txTagBase	=tagUser + 1;

TYPE	txTags		=(txTextAttr := txTagBase + 1,
			  txStyle,
			  txForceTextPen,
			  txUnderscore,
			  txFlags,
			  txText,
			  txNoBox);


TYPE	StrPtr		=POINTER TO ARRAY [0..255] OF CHAR;



(* gadtoolsbox/gtxbase.h *)
TYPE	GTXBasePtr	=POINTER TO GTXBase;

	GTXBase		=RECORD	library		:Library;
				dosBase		:DosLibraryPtr;
				intuitionBase	:IntuitionBasePtr;
				gfxBase		:GfxBasePtr;
				gadToolsBase	:LibraryPtr;
				utilityBase	:LibraryPtr;
				iffParseBase	:LibraryPtr;
				consoleDevice	:DevicePtr;
				noFragBase	:LibraryPtr;
				ppBase		:LibraryPtr;	(* check if it is valid!	*)
				END;


VAR	gtxVersion	:INTEGER;
	gtxBase		:GTXBasePtr;


PROCEDURE TagInArray		(    tag {R.D0}		:Tag;
				     tagList {R.A0}	:TagItemPtr) :BOOLEAN;		CODE -30;

PROCEDURE SetTagData		(    tag {R.D0}		:Tag;
				     data {R.D1}	:LONGINT;
				     tagList {R.A0}	:TagItemPtr) :BOOLEAN;		CODE -36;


PROCEDURE GetNode		(    list {R.A0}	:ADDRESS;
				     nodeNumber {R.D0}	:LONGCARD) :ADDRESS;		CODE -42;

PROCEDURE GetNodeNumbers	(    list {R.A0}	:ADDRESS;
				     node {R.A1}	:ADDRESS) :LONGINT;		CODE -48;

PROCEDURE CountNodes		(    list {R.A0}	:ADDRESS) :LONGCARD;		CODE -54;

PROCEDURE MoveNodes		(    list {R.A0}	:ADDRESS;
				     node {R.A1}	:ADDRESS;
				     distance {R.D0}	:INTEGER) :BOOLEAN;		CODE -60;

PROCEDURE IFFErrToStr		(    error {R.D0}	:LONGINT;
				     skipEOF {R.D1}	:BOOLEAN) :StrPtr;		CODE -66;


PROCEDURE GetHandleA		(    tagList {R.A0}	:TagItemPtr) :HotKeyHandle;	CODE -72;

PROCEDURE FreeHandle		(    handle {R.A0}	:HotKeyHandle);			CODE -78;


PROCEDURE RefreshWindow		(    handle {R.A0}	:HotKeyHandle;
				     window {R.A1}	:WindowPtr;
				     requester {R.A2}	:RequesterPtr);			CODE -84;


PROCEDURE CreateGadgetA		(    handle {R.A0}	:HotKeyHandle;
				     kind {R.D0}	:CARDINAL;
				     pred {R.A1}	:GadgetPtr;
				     newGadget {R.A2}	:NewGadgetPtr;
				     tagList {R.A3}	:TagItemPtr) :GadgetPtr;	CODE -90;


PROCEDURE RawToVanilla		(    handle {R.A0}	:HotKeyHandle;
				     code {R.D0},
				     qualifier {R.D1}	:CARDINAL) :CHAR;		CODE -96;


PROCEDURE GetIMsg		(    handle {R.A0}	:HotKeyHandle;
				     port {R.A1}	:MsgPortPtr) :IntuiMessagePtr;	CODE -102;

PROCEDURE ReplyIMsg		(    handle {R.A0}	:HotKeyHandle;
				     message {R.A1}	:IntuiMessagePtr);		CODE -108;


PROCEDURE SetGadgetAttrsA	(    handle {R.A0}	:HotKeyHandle;
				     gadget {R.A1}	:GadgetPtr;
				     tagList {R.A2}	:TagItemPtr);			CODE -114;

PROCEDURE DetachLabels		(    handle {R.A0}	:HotKeyHandle;
				     gadget {R.A1}	:GadgetPtr);			CODE -120;

PROCEDURE DrawBox		(    rport {R.A0}	:RastPortPtr;
				     left {R.D0},
				     top {R.D1},
				     width {R.D2},
				     height {R.D3}	:LONGCARD;
				     dri {R.A2}		:DrawInfoPtr;
				     state {R.D4}	:LONGCARD);			CODE -126;


PROCEDURE InitTextClass		() :IClassPtr;						CODE -132;

PROCEDURE InitGetFileClass	() :IClassPtr;						CODE -138;


PROCEDURE SetHandleAttrsA	(    handle {R.A0}	:HotKeyHandle;
				     tagList {R.A1}	:TagItemPtr);			CODE -144;


PROCEDURE BeginRefresh		(    handle {R.A0}	:HotKeyHandle);			CODE -150;

PROCEDURE EndRefresh		(    handle {R.A0}	:HotKeyHandle;
				     all {R.D0}		:BOOLEAN);			CODE -156;


PROCEDURE FreeWindows		(    chain {R.A0}	:MemoryChainPtr;
				     windows {R.A1}	:WindowListPtr);		CODE -228;


PROCEDURE LoadGuiA		(    chain {R.A0}	:MemoryChainPtr;
				     name {R.A1}	:ADDRESS;
				     tagList {R.A2}	:TagItemPtr) :gtbErrors;	CODE -234;


END GadToolsBox.
