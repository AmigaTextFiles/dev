DEFINITION MODULE ReqD;
(*$ Implementation:=FALSE *)

IMPORT E: ExecD,
       I: IntuitionD,
       G: GraphicsD,
       D: DosD,
       S: SYSTEM,
       RE: RexxD,
       R;

CONST reqName       = "req.library";
      reqMinVersion = 2;

      numpairs      = 9; (* ARRAY[0..numpairs] OF... anstatt ARRAY numpairs OF...
                            in Oberon *)


TYPE GadgetBlockPtr = POINTER TO GadgetBlock;

     GadgetBlock = RECORD
                      gadget: I.Gadget;
                      border: I.Border;
                      pairs : ARRAY [0..numpairs] OF INTEGER;
                      text  : I.IntuiText;
                   END;

TYPE StringBlockPtr = POINTER TO StringBlock;

     StringBlock = RECORD
                      gadget: I.Gadget;
                      info  : I.StringInfo;
                      border: I.Border;
                      pairs : ARRAY [0..numpairs] OF INTEGER;
                   END;

TYPE PropBlockPtr  = POINTER TO PropBlock;

     PropBlock  = RECORD
                     gadget: I.Gadget;
                     info  : I.PropInfo;
                     image : I.Image;
                  END;

TYPE ScrollBlockPtr  = POINTER TO ScrollBlock;

     ScrollBlock  = RECORD
                       arrowUpLt: I.Gadget;
                       imageUpLt: I.Image;
                       arrowDnRt: I.Gadget;
                       imageDnRt: I.Image;
                       prop     : I.PropInfo;
                    END;

TYPE TwoImageGadgetPtr  = POINTER TO TwoImageGadget;

     TwoImageGadget  = RECORD
                          gadget: I.Gadget;
                          image1: I.Image;
                          image2: I.Image;
                       END;

CONST VERTSLIDER   = 16;  (* Default: Horizontal Slider*)
      HORIZSLIDER  = 0;

(*This structure is used with the TextRequester function.*)

TYPE TRStructurePtr  = POINTER TO TRStructure;

     TRStructure  = RECORD
                       text         : S.ADDRESS;   (* This is the message text, including printf() style formatting if desired.*)
                       controls     : S.ADDRESS;   (* This is the address of the parameter list, if printf() style formatting is used. *)
                       window       : I.WindowPtr; (* This is an optional (zero if not used) pointer to a window on the screen you*)
                                  (* would like the requester to show up on.*)
                       middleText   : S.ADDRESS;   (* If non-zero, this is the text for the gadget in the lower middle (returns 2).*)
                       positiveText : S.ADDRESS;   (* If non-zero, this is the text for the gadget in the lower left hand corner (returns 1).*)
                       negativeText : S.ADDRESS;   (* If non-zero, this is the text for the gadget in the lower right (returns 0).*)
                       title        : S.ADDRESS;   (* This is the title for the window.*)
                       keyMask      : S.BITSET;    (* This is the qualifier mask for the keyboard shortcuts.*)
                                  (* Use -1 to allow any qualifiers (or none).*)
                                  (* Zero means that no keyboard shortcuts are allowed.*)
                       textcolor    : INTEGER;     (* Color of the text.  Uses color 1 if no color specified.*)
                       detailcolor  : INTEGER;     (* Detail and block color, as in a NewWindow structure.  If*)
                       blockcolor   : INTEGER;     (* both are left zero, block pen will be set to 1.*)
                       versionnumber: INTEGER;     (* Make SURE this is set to reqversion.*)
                       timeout      : CARDINAL;    (* the timeout value in seconds *)
                       abortMask    : S.LONGSET;   (* If the requester gets a Signal() with this bit, it will abort *)
                       rfu1         : INTEGER;     (* Make SURE you leave these two zeroed also.*)
                    END;

(*NOTE:
    The  control  values  mentioned above are used if you choose to insert
printf  style directives in your strings and should contain the address of
a list of control parameters, usually on the stack.
   *)

(*         Remember,   if  you  don't  want  to  go  through  the  hassle  of
   initializing a ExtendedColorRequester structure, you can always just call
   ColorRequester  (as opposed to ExtendedColorRequester).  ColorRequester
   just  takes  a  single  parameter, in D0, the color that should start out
   being highlit.  It returns a single value, the color that was selected at
   the end. *)

(*         This structure is for use with the ExtendedColorRequester (_not_, *)
(* the ColorRequester) function.*)

TYPE ExtendedColorRequesterPtr  = POINTER TO ExtendedColorRequester;

     ExtendedColorRequester  = RECORD
                                  defcolor: LONGINT;     (*The color that is initially highlit.   *)
                                  window  : I.WindowPtr; (*The window the 'requester' opens up in.*)
                                  rfu1    : LONGINT;     (*Who knows what these will be used for, *)
                                  rfu2    : LONGINT;     (*but I'm sure we'll think of something. *)
                                  rfu3    : LONGINT;     (*Until then, just keep these zeroed.    *)
                                  rfu4    : LONGINT;     (*Okay?*)
                                  rfu5    : LONGINT;
                               END;

(*         This structure is for use with the GetLong function.*)

CONST glnodefault  = 0;(*Set this bit in the flags if you don't want a default*)
                        (*value to show up in the get long string gadget.  For*)
                        (*some things this is much better than having a zero  *)
                        (*show up.*)

TYPE GetLongStructPtr  = POINTER TO GetLongStruct;

     GetLongStruct  = RECORD
                         titlebar     : S.ADDRESS;
                         defaultval   : LONGINT;
                         minlimit     : LONGINT;
                         maxlimit     : LONGINT;
                         result       : LONGINT;
                         window       : I.WindowPtr;
                         versionnumber: INTEGER; (* Make SURE this is set to reqversion.*)
                         flags        : S.LONGSET; (* Some, uh flags.  See above for bit definitions.*)
                         rfu2         : LONGINT;
                      END;

TYPE GetStringStructPtr  = POINTER TO GetStringStruct;

     GetStringStruct  = RECORD
                           titlebar     : S.ADDRESS;
                           stringbuffer : S.ADDRESS;
                           window       : I.WindowPtr;
                           stringsize   : INTEGER; (*how many characters in the buffer*)
                           visiblesize  : INTEGER; (*how many characters show on screen*)
                           versionnumber: INTEGER; (* make SURE this is reqversion *)
                           flags        : S.LONGSET;
                           rfu1         : LONGINT;
                           rfu2         : LONGINT;
                           rfu3         : LONGINT;
                        END;

CONST dsize       = 130;
      fchars      =  30;
      wildlength  =  30;

TYPE DirString       = ARRAY[0..dsize] OF CHAR;
     DirStringPtr    = POINTER TO DirString;
     FileString      = ARRAY[0..fchars] OF CHAR;
     FileStringPtr   = POINTER TO FileString;
     PathString      = ARRAY[0..dsize+fchars+1] OF CHAR;
     PathStringPtr   = POINTER TO PathString;
     ShowHideString  = ARRAY[0..wildlength + 2] OF CHAR;
(*
   These  are  the  bit  numbers  of various bits that you can set in the
Flags  field of the file requester structure.  The actual values that come
out of these bit numbers are defined in the set of includes below with the
same  names  but  with  an  M  (for  mask) ending instead of a B (for bit)
ending.
  *)

TYPE UmmFlags = (showinfo,extselect,caching,getfonts,
                  infogadget,hidewilds,absolutexy,cachepurge,
                  nohalfcache,nosort,nodrag,saving,
                  loading,dironly,umm14,umm15,
                  umm16,umm17,umm18,umm19,
                  umm20,umm21,umm22,umm23,
                  umm24,umm25,umm26,umm27,
                  umm28,umm29,umm30,umm31);
      UmmFlagSet = SET OF UmmFlags;

(* CONST
     showinfo    = 0;  (*Set this in Flags if you want .info files to show.  They default to hidden.*)
     extselect   = 1;  (*Set this in Flags if you want extended select.  Default is not.*)
     caching     = 2;  (*Set this in Flags if you want directory caching.  Default is not.*)
     getfonts    = 3;  (*Set this in Flags if you want a font requester rather than a file requester.*)
     infogadget  = 4;  (*Set this in Flags if you want a hide-info files gadget.*)
     hidewilds   = 5;  (*Set this in Flags if you DON'T want 'show' and 'hide' string gadgets.*)
     absolutexy  = 6;  (*Use absolute x,y positions rather than centering on mouse.*)
     cachepurge  = 7;  (*Purge the cache whenever the directory date stamp changes if this is set.*)
     nohalfcache = 8;  (*Don't cache a directory unless it is completely read in when this is set.*)
     nosort      = 9;  (*Set this in Flags if you DON'T want sorted directories.*)
     nodrag      = 10; (*Set this in Flags if you DON'T want a drag bar and depth gadgets.*)
     saving      = 11; (*Set this bit if you are selecting a file to save to.*)
     loading     = 12; (*Set this bit if you are selecting a file(s) to load from.*)
                        (*These two bits (save and load) aren't currently used for*)
                        (*anything, but they may be in the future, so you should*)
                        (*remember to set them.  Also, these bits make it easier if*)
                        (*somebody wants to customize the file requester for their*)
                        (*machine.  They can make it behave differently for loading*)
                        (*vs saving.*)
     dironly     = 13; (*Allow the user to select a directory, rather than a file.*)

*)

TYPE ESStructurePtr   = POINTER TO ESStructure;

     ESStructure  = RECORD
                       nextFile       : ESStructurePtr;
                       nameLength     : INTEGER; (*Length of the filename field, not including the terminating zero.*)
                       pad            : INTEGER;
                       node           : S.ADDRESS;     (*For internal use only.*)
                       thefilename    : ARRAY[0..255] OF CHAR; (*This is (was) a variable size field.*)
                    END;


TYPE ReqFileRequesterPtr   = POINTER TO ReqFileRequester;

     ReqFileRequester  = RECORD
                            versionNumber      : INTEGER;  (*Make SURE this is set to reqversion.*)
                            title              : S.ADDRESS;  (*Hailing text*)
                            dir                : DirStringPtr;  (*Directory array (DSIZE+1)*)
                            file               : FileStringPtr; (*Filename array (FCHARS+1)*)
                            pathName           : PathStringPtr; (*Complete path name array (DSIZE+FCHARS+2)*)
                            window             : I.WindowPtr;   (*Window requesting or NULL*)

                            maxExtendedSelect  : CARDINAL;  (*Zero implies a maximum of 65535, as long as FRQEXTSELECT is set.*)
                            numlines           : CARDINAL;  (*Number of lines in file window.*)
                            numcolumns         : CARDINAL;  (*Number of columns in file window.*)
                            devcolumns         : CARDINAL;
                            flags              : UmmFlagSet; (*Various - umm - flags.  See above for more info.*)
                            dirnamescolor      : CARDINAL;  (*These five colors will all default*)
                            filenamescolor     : CARDINAL;  (*to color one if you don't specify*)
                            devicenamescolor   : CARDINAL;  (*a color (ie; if you specify color zero).*)
                            fontnamescolor     : CARDINAL;  (*If you want color zero to be used, specify*)
                            fontsizescolor     : CARDINAL;  (*color 32, or some other too large number*)
                                                 (*which mods down to zero.*)
                            detailcolor        : CARDINAL;  (*If both of these colors are specified as*)
                            blockcolor         : CARDINAL;  (*zero then the block pen will be set to one.*)

                            gadgettextcolor    : CARDINAL;   (*The color for the text of the five boolean gadgets.  Defaults to 1.*)
                            textmessagecolor   : CARDINAL;   (*The color for the message at the screen top.  Defaults to 1.*)
                            stringnamecolor    : CARDINAL;   (*The color for the words Drawer, File, Hide and Show.  Defaults to 3.*)
                            stringgadgetcolor  : CARDINAL;   (*The color for the borders of the string gadgets.  Defaults to 3.*)
                                       (*Unfortunately it is not possible to specify*)
                                       (*the color of the actual text in an Intuition*)
                                       (*string gadget.*)
                            boxbordercolor    : CARDINAL;   (*The color for the boxes around the file and directory areas.  Defaults to 3.*)
                            gadgetboxcolor    : CARDINAL;   (*The color for the boxes around the five boolean gadgets.  Defaults to 3.*)

                            stuff             : ARRAY[0..17] OF CARDINAL; (*This area, which is reserved for*)
                                                 (*future use, should all be zero.*)

                            dirDateStamp      : D.Date; (*A copy of the cached directories date stamp.*)
                                      (*There should never be any need to change this.*)

                            windowLeftEdge    : CARDINAL;  (*These two fields are only used when the*)
                            windowTopEdge     : CARDINAL;  (*FRQABSOLUTEXY flag is set.  They specify*)
                                      (*the location of the upper left hand*)
                                      (*corner of the window.*)

                            fontYSize         : CARDINAL;     (*These fields are used to return the selected*)
                            fontStyle         : CARDINAL;     (*font size and style, only applicable when the*)
                                      (*font bit is set.*)

   (*If you set the extended select bit and the user extended selects, the list of filenames will start from here.*)
                            extendedSelect    : ESStructurePtr;
                            hide              : ShowHideString; (*The wildcards text.*)
                            show              : ShowHideString; (*More wildcards text.*)
                            fileBufferPos     : INTEGER; (*Various fields taken from the various*)
                            fileDispPos       : INTEGER; (*string gadgets so that the cursor*)
                            dirBufferPos      : INTEGER; (*can be returned to the same position*)
                            dirDispPos        : INTEGER; (*on subsequent calls.*)
                            hideBufferPos     : INTEGER;
                            hideDispPos       : INTEGER;
                            showBufferPos     : INTEGER;
                            showDispPos       : INTEGER;

(*     The  following  fields are PRIVATE!  Don't go messing with them or
  wierd  things may/will happen.  If this isn't enough of a warning, go read
  the one in intuition.h, that should scare you off.  *)

                             memory           : S.ADDRESS;    (*Memory allocate for dir entries.   *)
                             memory2          : S.ADDRESS;    (*More memory, used for hidden files.*)
                             lock             : S.ADDRESS;
                             privateDirBuffer : ARRAY[0..dsize+1] OF CHAR; (*Used for keeping a record of which*)
                                             (*directory we have file names for.*)
                             fileInfoBlock    : D.FileInfoBlock;
                             numEntries       : INTEGER;
                             numHiddenEntries : INTEGER;
                             filestartnumber  : INTEGER;
                             devicestartnumber: INTEGER;
                          END;


(*       This is used with the RealTimeScroll function.*)

TYPE ReqScrollStructPtr  = POINTER TO ReqScrollStruct;

     ReqScrollStruct  = RECORD
                        topEntryNumber   : LONGCARD; (*This is the ordinal number of the first*)
                                 (*displayed entry.*)
                        numEntries       : LONGCARD; (*This is the total number of entries in*)
                                             (*the list.*)
                        lineSpacing      : CARDINAL; (*This is how many pixels high each entry is.*)
                        numLines         : LONGCARD; (*This is how many entries can be displayed simultaneously.*)
                        propGadget       : I.Gadget;(*This is a pointer to the prop gadget being monitored.*)

                        RedrawAll  : PROCEDURE(); (*This routine is used to redraw all of the*)
                              (*entries when the user moves far enough*)
                              (*that scrolling will take too long.*)

                        ReadMore   : PROCEDURE(); (*An optional routine that is called when*)
                              (*the scroll routine is waiting for movement.*)
                              (*This allows reading of new data while real*)
                              (*time scrolling.*)
                        ScrollAndDraw   : PROCEDURE((*{R.D0},{R.D1},{R.D2},{R.D3}*)); (*This routine is called when the data needs*)
                              (*to be scrolled and updated.  This routine is*)
                              (*passed four long parameters (on the stack and*)
                              (*in D0-D3) which are, respectively:*)
                              (*D0 - entry number of first line to be drawn.*)
                              (*D1 - pixel offset to draw first line at.*)
                              (*D2 - amount to scroll before doing any drawing.*)
                              (*D3 - number of lines of data to draw.*)
                        versionnumber  : INTEGER; (*Make SURE this is set to reqversion.*)
                        rfu1       : LONGINT;     (*Make SURE you leave these two zeroed also.*)
                        rfu2       : LONGINT;     (*Make SURE you leave these two zeroed also.*)
                     END;

TYPE ChipstuffPtr   = POINTER TO Chipstuff;

     Chipstuff  = RECORD
                     arrowUp      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     arrowDown    : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     arrowLeft    : ARRAY[0..8] OF INTEGER; (*16 pixels wide, 9 pixels high. *)
                     arrowRight   : ARRAY[0..8] OF INTEGER; (*16 pixels wide, 9 pixels high. *)
                     letterR      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     letterG      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     letterB      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     letterH      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     letterS      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                     letterV      : ARRAY[0..9] OF INTEGER; (*16 pixels wide, 10 pixels high.*)
                  END;

TYPE ReqLibPtr   = POINTER TO  ReqLib;

     ReqLib  = RECORD
                  rLib            : E.LibraryPtr;
                  sysLib          : E.ExecBasePtr;
                  dosLib          : D.DosLibraryPtr;
                  intuiLib        : I.IntuitionBasePtr;
                  gfxLib          : G.GfxBasePtr;
                  segList         : S.BPTR;
                  images          : ChipstuffPtr;
                  flags           : S.BITSET;
                  pad             : SHORTINT;
                  consoleDev      : S.ADDRESS;   (*Not really a char, but it should work*)
                  consoleHandle   : E.IOStdReqPtr;
                  rexxSysBase     : RE.RxsLibPtr;
               END;

END ReqD.
