@database Cyclone
@master Cyclone.guide
@$VER: V 0.94
@author "Marcel Timmermans"
@(c) "Marcel Timmermans"
@index Main

@node "Main" "Cyclone Modula-2 Compiler"

                        @{b}Cyclone Modula-2 Compiler@{ub}
                  @{b}A Modula-2 compiler for the Amiga
                        by @{i}Marcel Timmermans@{ub}@{ui}

                          @{"Introduction" link "Introduction" 0}
                          @{"System Requirements" link "SystemRequirements" 0}
                          @{"Installation" link "Installation" 0}
                          @{"Cyclone extensions to modula-2" link "ControlIndex" 0}

                          @{b}The programs@{ub}

                          @{"The Compiler (cmc)" link "CompilerIndex" 0}
                          @{"The Linker (cml)" link "LinkerDOC" 0}
                          @{"The Make program (cmm)" link "MakeDoc" 0}
                          @{"The Error lister (cmerr)" link "CmeDoc" 0}
                          @{"The Cache system (cmcache)" link "CmcacheDoc" 0}
                          @{"The Project program  (cmpm)" link "CmpCDoc" 0}
                          @{"The Library-linker ( CmLibLink)" link "CmLibLinker" 0}
                          @{"The FD-Convertor (FDTOM2" link "FdToM2" 0}


                          @{b}Misc@{ub}

                          @{"ToDo" link "todo.txt/main" 0}
                          @{"History" link "History.doc/main" 0}
                          @{"Reporting bugs" link "repbugs" 0}
                          @{"FAQ" link "FAQ" 0}
                          @{"CopyRight" link "copyright" 0}
                          @{"Disclaimer" link "Disclaimer" 0}
                          @{"Known Errors" link "KnownErrors" 0}
                          @{"Thanks" link "Thanks" 0}
                          @{"Author" link "AutherInfo" 0}
@endnode

@node "copyright" "CopyRight Information"

@{b} COPYRIGHTS@{ub}

 Cyclone Modula-2 Compiler, which includes the programs @{"Cmc" link "CompilerIndex" 0}, @{"Cml" link "LinkerDOC" 0}, @{"Cmm" link "MakeDoc" 0},
 @{"Cmerr" link "CmeDoc" 0}, @{"Cmpm" link "CmpCDoc" 0}, @{"CmCache" link "CmcacheDoc" 0}, @{"CmLibLink" link "CmLibLinker" 0} and @{"FdToM2" link "FdToM2" 0}, is Copyright (C) 1994-97 by
 @{"Marcel Timmermans" link "AutherInfo" 0}, All Rights Reserved.

 This program is @{bg highlight}GIFTWARE@{bg back} which means that if you like the program you
 should reward the author with gift that, you think, matches his efforts.

 This program may be freely distributed as long as all files are included
 in the distribution without any modifications.

 This program may *NOT* be uploaded on BBS's that claim copyrights on the
 uploaded material.

 Commercial distribution of Cyclone Modula-2 Compiler or it's relative
 files is *NOT* allowed without written permission from the @{"author" link "AutherInfo" 0}.
@endnode

@node "AutherInfo" "Information about the Author"
The author,

My home address is:

  Marcel Timmermans
  Aagje DekenStraat 22 (* shortly A.Dekenstr 22 *)
  6836 RM Arnhem
  Holland / Europe.

After 1 August 1997 my home address will be:

  Marcel Timmermans
  Wim Kanstraat 2
  6836 ME Arnhem
  Holland / Europe.

Or you can use my EMail addresses:

  Internet: mtimmerm@worldaccess.nl
            http://www.worldaccess.nl/~mtimmerm

@endnode

@node "Disclaimer" ""
 The @{"author" link "AutherInfo" 0} cannot be held liable for the suitability or accuracy of this
manual and/or the program(s) it describes. Any damage directly or indirectly
caused by the use or misuse of this manual and/or the program it describes
is the sole responsibility of the user her/him self.

Use of this software is forbidden in situations in which this non warranty
may be rendered inapplicable.
@endnode

@node "Introduction" ""
Thank you for your interest in Cyclone Modula-2 compiler.

Modula-2 is a higher programming language and developed by Prof Dr Niklaus
Wirth of ETH Zurich in Switzerland.  This modula-2 compiler is extended to
the requirements of the Amiga OS so that it is an ideal system to develop
small and large programs for the Amiga.  Cmc is a single pass object
oriented modula-2 compiler, which has a build in MC68000 assembler, that
directly generates MC68000 machine code.  The object files that the compiler
produces are in the standard AmigaDOS format.  The programs of Cyclone
Modula-2 Compiler, shortly described as Cyclone, are able to run under KS
1.2, 1.3, 2.x, 3.x and up.


@{b}Some highlights@{ub}

 - Quick
 - Exception handling (TRY EXCEPT/FINALLY END block)
 - Inline assembler
 - Object Ortiened things like inheritance, methods
 - Inlining possible
 - Easy handling of @{"threads" link "Threads.guide/main" 0}
 - Standard Amiga Object file format (blink compatible)
 - Optimized linking
 - Programs are resident and reentrant
 - Conditional compiling
 - Librarylinker
 - Cache system (to keep symbolfiles resident which improve the compilation speed)
 - easy use of tag arguments [...,...]
@endnode

@node "Installation" "Installation of Cyclone"
To make the installation as simple as possible, I wrote an installation
script for the AT Installer. Please run this and the Cyclone Modula-2
Compiler will be installed.
@endnode

@node "SystemRequirements" ""
Even though the Cyclone Modula-2 Compiler can be running from floppy drives
it is highly recommended to install the system to a harddisk. Further more
requires an Amiga personal computer with at least 1 MB of ram, depending of
the size of the module that is compiled. Cyclone is tested under KS 2.x and
KS 3.0 but it should be able to run under all Kickstart versions.

If there are problems under the different kickstarts, Please contact the
@{"Author" link "AutherInfo" 0}.
@endnode

@node "LinkerDOC" "The linker utility (cml)"
Cml is the Cyclone linker.  You will usually run cml from shell/cli or from
cmm, but cml can also be called from scripts within editors. Cml's expected
default extension is @{".obj" link "Files" 0}.

Cml requires at least a stack size of 20000 and can be kept resident to
speed up linking.

@{b}Linker output@{ub}

The linker scans the main @{"object file" link "Files" 0} and searches for modules which are
needed by the main module.  This is possible because in the object files the
procedures are written in the following format:
<modulefilename>.<procedurename>

The linker will only look into the paths that are written in the file
'am2:path' or in a local file called 'path'.

Example:

>cml sparks

cml sparks Cyclone Modula-2 Linker V1.05e Beta, 12.11.95, (c) Marcel
Timmermans.

 - sparks.obj
 - am2:modules/obj/ModulaLib.obj
 - am2:modules/obj/ExecL.obj
 - am2:modules/obj/GraphicsL.obj
 - am2:modules/obj/IntuitionL.obj
 - am2:modules/obj/Random.obj
 - am2:modules/obj/MathIEEESingBas.obj
 + sparks
 CODE:3188 DATA:0 VAR:132 PROGRAM: 3224 >

@{b}Linker Options@{ub}

There are a few commandline options which can be set.  This can be done with
+ (on) and - (off) in the commandline. The switches can appear in any
combination but they are case sensitive, which mean that -d is not the same
as -D!.

  Linker Argument options
  --------------------------

  Option   Default   Description
  ------   -------   --------------------------------------------------------
   d        Off (-)   Debug
   l        Off (-)   Linker library (+llibname)
@endnode

@node "MakeDoc" "The make program (cmm)"
Cmm is the make program of Cyclone.  You will usually run cmm from the
shell/cli or from a script in your editor.  Cmm's expected as a default
extension .mod.  So you don't have to type this in.

Because of the recursive procedures in the make program Cmm also needs 20000
bytes of stack size. The make program can be kept resident.

Set the stack by typing >stack 20000

Make cml resident by typing >resident cml

Example:

>Cmm sparks

Cyclone Modula-2 Make V1.00e, 04.03.95,(c) Marcel Timmermans.
 - sparks.mod
 - am2:modules/txt/Random.def
 - am2:modules/txt/Random.mod
 - am2:modules/txt/MathIEEESingBas.def
 - am2:modules/txt/IntuitionL.def
 - am2:modules/txt/Reg.def
 - am2:modules/txt/IntuitionD.def
 - am2:modules/txt/InputEvent.def
 - am2:modules/txt/UtilityD.def
 - am2:modules/txt/ExecD.def
 - am2:modules/txt/Timer.def
 - am2:modules/txt/GraphicsD.def
 - am2:modules/txt/Hardware.def
 - am2:modules/txt/GraphicsL.def
 - am2:modules/txt/ExecL.def
 + sparks.mtx Missing objectfile of sparks am2:cmc  sparks.mod  MC68000
Cyclone Modula-2 Compiler V0.45e, 05.03.95,(c) Marcel Timmermans.
 - sparks.mod
 - am2:modules/sym/ModulaLib.sym
 - am2:modules/sym/ExecL.sym
 - am2:modules/sym/GraphicsD.sym
 - am2:modules/sym/GraphicsL.sym
 - am2:modules/sym/IntuitionD.sym
 - am2:modules/sym/IntuitionL.sym
 - am2:modules/sym/Random.sym
 + sparks.obj

   Optimizing ...  54 Bytes optimized
   Symbol debug information available
   CODE: 1720 CONST: 0 BBS: 16

cml sparks Cyclone Modula-2 Linker V1.05e Beta, 12.11.95, (c) Marcel
Timmermans.

 - sparks.obj
 - am2:modules/obj/ModulaLib.obj
 - am2:modules/obj/ExecL.obj
 - am2:modules/obj/GraphicsL.obj
 - am2:modules/obj/IntuitionL.obj
 - am2:modules/obj/Random.obj
 - am2:modules/obj/MathIEEESingBas.obj
 + sparks
 CODE:3188 DATA:0 VAR:132 PROGRAM: 3224


Cmm will produce a dependency file called <filename>.mtx. With this file it
is not necessary to scan all depended files again. Beware! In some cases
this is not handy. f.e. If you not have imported all the modules yet. In
this case you can switch off use the dependency file with option '-d'. A
next attempt after deleting sparks.obj will be look like this:

Cyclone Modula-2 Make V1.00e, 04.03.95,(c) Marcel Timmermans.
 - sparks.mtx Missing objectfile of sparks am2:cmc  sparks.mod  MC68000
Cyclone Modula-2 Compiler V0.45e, 05.03.95,(c) Marcel Timmermans.
 - sparks.mod
 - am2:modules/sym/ModulaLib.sym
 - am2:modules/sym/ExecL.sym
 - am2:modules/sym/GraphicsD.sym
 - am2:modules/sym/GraphicsL.sym
 - am2:modules/sym/IntuitionD.sym
 - am2:modules/sym/IntuitionL.sym
 - am2:modules/sym/Random.sym
 + sparks.obj

   Optimizing ...  54 Bytes optimized
   Symbol debug information available
   CODE: 1720 CONST: 0 BBS: 16 cml sparks Cyclone Modula-2 Linker V1.05e
Beta, 12.11.95, (c) Marcel Timmermans.
 - sparks.obj
 - am2:modules/obj/ModulaLib.obj
 - am2:modules/obj/ExecL.obj
 - am2:modules/obj/GraphicsL.obj
 - am2:modules/obj/IntuitionL.obj
 - am2:modules/obj/Random.obj
 - am2:modules/obj/MathIEEESingBas.obj
 + sparks
 CODE:3188 DATA:0 VAR:132 PROGRAM: 3224


@{b}Cmm Options@{ub}

There are a few commandline options which can be set.  This can be done with
+ (on) and - (off) in the commandline. The switches can appear in any
combination but they are case sensitive, which mean that -v is not the same
as -V!.

  Cmm Argument options
  --------------------------

  Option   Default   Description
  ------   -------   ------------------------------------------------------
   x        On(+)    search externally. This means that make will search
                     in all paths that are present in the 'path' file.
   d        On(+)    use dependency file
   a        Off(-)   compile all founded modules.
   b        On(+)    start linker
   v        On(+)    verbose
   c        Off      After this you can put the compiler options.
                     f.e. Cmm +c[compiler options]
   l        Off      After this you can put the linker options
                     f.e. Cmm +l[linker options]


@{b}Possible problems@{ub}

- Make stopped, error ocurred?
  Possible when the linker or compiler cannot be executed

- Make did not make the correct dependency file with modules?
  Make sure that you clock is set right! And don't change it in
  the mean time.
  If you have no clock, make sure that you set your clock correct on boot
  time. Because Cmm looks at the time differences from the necessary files.

If your clock may be unstable, obtain the program DateInspector to correct
this.

Note also that having several copies of a module on your system may confuse
cmm.

@endnode

@node "CmeDoc" "The Error lister (cmerr)"
Cmerr is the error lister of Cyclone.  Usually you will run cmerr from the
shell/cli, but it can also be run from a script within an editor.  Cmerr's
expected as a default extension .mod.  If you need to list the error file of
a definition file you have to write the extension .def.


@{b}What does cmerr do?@{ub}

Cmerr lists error that are reported by the compiler. If the compiler finds
an error it will produce a .defE or a .modE file, depending on the compiled
sourcefile. This error file contains the error number and the position of
the error.


@{b}Error format@{ub}

Fileposition  -  4 bytes error number  -  2 bytes . . . <Endheader>   -
LONGINT(-1)


@{b}Commandline-option@{ub}

Cmerr has one commandline-option called 'n'. With this option you can ask an
error number for the error string.

Example:

>cmerr +n100

Cyclone Modula-2 Errorlister V1.00e, 22.03.95,(c) Marcel Timmermans.

operand type incompatible with +

>

@{b}How to use cmerr?@{ub}

Well, that is simple, just type cmerr <errorfile>[.def]

Example >cmerr errtest Cyclone Modula-2 Errorlister V1.00e, 22.03.95,(c)
Marcel Timmermans.
 - errtest.mod
 - errtest.modE -----
   6: j:=1;
      ^
      61: undefined identifier

>

The 6 marked the number of the line and 61 is the error code number. All the
errors are listed in normal ASCII text in the file am2:cmc_errors.txt!
@endnode

@node "CmcacheDoc" "The Cache system (cmcache)"
With Cmcache you can start the cachesystem and control it. After starting
Cmcache a semaphore will be started, this shall be kept active until you
remove the semaphore again with Cmcache.


@{b}What is this, exactly?@{ub}

Well, normally every @{"symbolfile" link "Files" 0} and @{"objectfile" link "Files" 0} that a module needs will be
loaded again from the disk. We can speed this up by keeping the symbolfile
and objectfile in memory. And when we need the objectfile we load it from
memory instead of the disk. This gives a much better performance.

At the moment only cmc makes use of this feature. When the compiler uses a
symbolfile this will be showed by a loading sign '=' instead of '-'.

Naturaly this will use memory. Therefor there is an option available to
specify how much memory Cmcache may use. Default for this is 300000 bytes.
At the moment Cmcache is not a smart cache system, which means that old
files that are not often used will be replaced by newer files if the cache
memory is full. Once a symbol is loaded, it can only removed by clearing the
cache!

@{u}Warning@{uu}:

When the compiler is making a new object or symbol file the old version of
this file will be, if available, removed from the cache.  The complete path
where the symbol or object file was loaded will be kept in memory. Still
files with the same name in different directories are treated the same. So a
file called dh1:work/files.sym and a file am2:modules/files.sym will be
removed from the cache system if the compiler generate a new symbol file:
files.sym.


@{b}How do you start Acmache?@{ub}

That's simple just type cmcache and enter and the cache system will be
installed.

Example

>cmcache

  Cyclone Modula Cache Utility V1.00e,
  04.03.95, (c) Marcel Timmermans.
  Installed CmCache!  >


@{b}What happens when I install it again?@{ub}

Example

>Cmcache
  Cyclone Modula Cache Utility V1.00e,
  04.03.95, (c) Marcel Timmermans.
  CmCache is already installed
  300000 bytes maximum memory
  0 bytes used memory  >


@{b}Cmcache options@{ub}

There are a few commandline options which can be used. Beware that the
options are handled different than the rest of the Cyclone programs!

  Cmcache Argument options
  --------------------------

  Option  Description
  ------  --------------------------------------------------------
   l      List the object/symbol files that are active
   f      Flush all files from the cache system
   q      Remove the cache system and flush everything
   u      Set the maximum memory usage from the cache system
          Example
           Cmcache u500000
           The cache system will now use a maximum of 500000 bytes memory.
@endnode

@node "CmpCDoc" "The project utility"
Cmpm is the Projectmaker of Cyclone.  Usually you will run Cmpm from the
shell/cli.

To keep a nice structure on your harddisk during development you can make a
project directory, f.e., 'compiler'. With Cmpm you can make the directory
compiler with the necessary directories inside.

Example

>cmpm compiler Cyclone Modula-2 Projectmaker, 1.00, 04.03.95, © Marcel
Timmermans
 + (compiler)
 + (compiler/bin)
 + (compiler/obj)
 + (compiler/sym)
 + (compiler/ref)
 + (compiler/txt)

Cmpm has know created the directory compiler with the following directories
in it:
 - bin
 - obj
 - sym
 - ref
 - txt

 In this way all the files created by compile or linker will go
 into the right directory.

 sym  <- keeps the symbol files (.sym)
 ref  <- Keeps the reference file for Source Level Debugger 
           (in development)
 txt  <- here you can make your source files ( .def | .mod )
 obj  <- keeps the object files (.obj)
 bin  <- the executable files end up here (no extension)



@{b}Cmpm Options@{ub}

There are a few commandline options which can be set.  This can be done with
+ (on) and - (off) in the commandline. The switches can appear in any
combination but they are @{u}not case sensitive@{uu}, which mean that -b is the same
as -B!.

  Cmpm Argument options
  --------------------------

  Option   Default  Description
  ------   ------- --------------------------------------------------------
   b        On (+)  Create a bin directory
   o        On (+)  Create a obj directory
   r        On (+)  Create a ref directory
   s        On (+)  Create a sym directory
   t        On (+)  Create a txt directory
   m        Off(+)  Move the files in the current directory to the
                    correct project directory.
@endnode

@node "Exception" "Exception Handling"
The exception handler has nothing to do with processor exceptions!

An exception handler is a piece of program code that will be invoked when
runtime errors occurs, f.e. memory that is not available. 

The block between TRY and EXCEPT is executed as normal, and if no exception
occurs, the block between EXCEPT and END is skipped. If an exception is
raised, either in the try part, or in any function that is called in this
block, an exception handler is invoked.

Raising an exception can be done by the procedure Raise which can be
imported from ModulaLib. As argument, Raise expects the exception error
code. This error code can be used to ask the cause of exception in the
exception handler. This error code is stored in the var ExceptNr which can
be imported from the ModulaLib.

f.e.

 MODULE Exception;

 FROM ModulaLib IMPORT ExceptNr,Raise; 
 FROM SYSTEM    IMPORT ADDRESS,ADR;
 FROM ExecL     IMPORT AllocMem; 
 FROM ExecD     IMPORT MemReqSet,MemReqs; 
 FROM InOut     IMPORT WriteString;

 CONST
  NOMEM=1;


 PROCEDURE TrySome; 
 VAR
  p:ADDRESS; 
 BEGIN
  TRY
   p:=AllocMem(100000,MemReqSet{public});
   IF p=NIL THEN Raise(NOMEM); END;
  EXCEPT 
   CASE ExceptNr DO
    | 1: WriteString('Sorry too little memory!\\n");
   ELSE
    Raise(ExceptNr);
   END;
  END 
 END TrySome;
 
 BEGIN
  TrySome; 
 CLOSE
 (* This is the default exception handler. You may not use (yet) a raise
  * here. This would create an endless loop!!
  *) 
 END Exception;

 But there is more you can do! When we change the EXCEPT statement to
 FINALLY than the block between FINALLY and END will always be executed!!

 The exception handler is stack based. This mean when you Raise an
 exception in an EXCEPT END block the previous exception handler will be
 called. If there isn't anymore the close statement will be called. This
 means if there is NO exception handler than Raise(x) has the same effect
 as Exit(0);
@endnode

@node "FAQ" "Cyclone's FAQ"
Cyclone FAQ

This FAQ-list (Frequently Asked Questions) was made after I got many similar
questions.


Q. Sometimes when I link I get an error message: Symbol [module].somenumber
   not found?!

A. This is mostly the problem that the modules are not compiled in the 
   properly order. Try to do a make!
   This may be due to a bad clock. If so, you need to get DateInspector.
   If this problem has got very bad, you may need to delete all the obj
   files, flush the cache and do a make (thus recompiling everything).

Q. Can I link Cyclone objectcode with other languages? 

A. Yes, You can! Cyclone use the standard Amiga object format! You 
   must only watch out that the calling convention of Cyclone if different
   than f.e. 'C'

Q. Can I link amiga.lib?

A. At the moment the linker doesn't support external objectfiles. This will
   soon be implemented.

Q. I wrote X in both C and Cyclone, and the Cyclone version is
   much more faster/slower.

A. It's not easy to compare both in a fair way. Often it may be the case
   that one of the two has more optimized routines for something (checking
   code, string handling etc). But I you want to use the maximum of speed
   you can use the build-in assembler of Cyclone!

Q. What's the problem with the error Key mismatch?!

A. With each compilation unit the compiler generates a so called module
   key. This key is unique and is needed to distinguish different compiled
   versions of the same module. This key is written on the symbol and
   object file. For an implementation module the key of the associated 
   definition module is adopted. The module keys of imported modules are
   also recorded on the generated symbol files and the object files. Any 
   mismatch of the module keys belonging to the same module will cause 
   an error message at compilation or linking time. At linking time you
   get something like cannot find symbol module.somenumber

   Be aware that you need to have a stable clock!!
@endnode

@node "CmLibLinker" "CmLibLinker"
@{b}CmLiblink (Cyclone's Library linker)

@{ub}With this program it is possible to create a resident library, such as the
libraries that are placed in libs:

When you want to create a library you must have some knowledge of how a
library works.  For more information about this subject you can look into
the RKM (libraries) manuals.

In the directory am2:liblinker/demolib is placed an example how to create a
library!


@{b}CmLiblink Options

@{ub}The following options can be used with CmLibLink:


  CmLibLink Argument options 
  --------------------------

  Option   Default   Description   
  ------   ------- --------------------------------------------------------
   d        Off(+)   Debugcode
   r        0        Revision 
   v        0        Version
   s        SIZEOF(Library) Librarysize
   l        none     a file where the exported procedures are mentioned


Format for procedurelist file (needed with option +l)

MODULENAME.PROCDURENAME


All exported procedures can be put into the list separately with a return.
Don't put any arguments in the procedure!!

f.e.

To export PROCEDURE Times(x,y:INTEGER) from module sample use:

sample.Times


Normaly a linker would include the ModulaLib.obj file. For the library there
is a special version of ModulaLib. This library is placed in the directory
am2:liblinker/modulalib/

When you make modifications to it, you need to recompile the file and put it
into am2:modules/obj/


This page is still under construction!! :-)
@endnode

@node "FdToM2" "FdToM2"
@{b}FDToM2@{ub}

This little utility allows you to convert standard FD files to Modula-2
definition/implementation files.


  FDToM2 Argument options 
  -----------------------

  Option   Default   Description   
  ------   ------- --------------------------------------------------------
   i        Off(-)   creating an implementation module
   m        0        minimal library version 
   t        fdname   the name to call the module
   l        none     the library name

f.e

 fdtom2 -i +lamigaguide.library +m40 +tAmigaguide amigaguide_lib.fd 

 This will create a definition file called:
  AmigaGuideL.def

When you create a definition file without an implementation file (-i), the
'L' will be put after the filename!
@endnode

@node "CompilerIndex" "The Compiler (cmc)"

    @{"Starting cmc" link "RunCmc" 0}

    @{"Commandline options" link "Commandlineopts" 0}

    @{"Basic types" link "BasicTypes" 0}

    @{"Keywords" link "Keywords" 0}

    @{"Internal procedures" link "InternalProcs" 0}

    @{"Cyclone extensions" link "ControlIndex" 0}

    @{"The inline assembler" link "Inlineasm" 0}

    @{"Start making a program" link "Startwriting" 0}

    @{"Importend to know" link "Importend" 0}

    @{"Module SYSTEM" link "SYSTEM" 0}
    @{"Module ModulaLib (The Runtime System)" link "ModulaLib" 0}
    @{"Module NoGuru" link "NoGuru" 0}
    @{"Module Break (Control-C)" link "Break" 0}

    @{"Compiler directives" link "Compilerdirec" 0}

    @{"Automatic optimizations" link "Automaticopts" 0}

    @{"Compiler limits" link "CompilerLimits" 0}
    @{"Compiletime errors" link "ErrorMessages" 0}
    @{"Runtime errors" link "Runtimeerrors" 0}
@endnode

@node "RunCmc" "Running cmc from the shell"
You will usually start cmc from the shell/cli, but you can also start it
from a scrip within some editors.  Cmc is reentrant.  You can keep it
resident by typing resident am2:cmc.

Format:   cmc [options] <source file>

Starting cmc with no argument will bring the compiler into the interactive
mode. In this mode you can give options or give a filename which need to be
compiled. A single '?' will display a short description. For a more detailed
description of all arguments, refer to @{"Commandline options" link "Commandlineopts" 0}.

When cmc is running, it can be stopped at any time by holding CTRL-C.
@endnode

@node "Commandlineopts" "Commandline options"
Command line options

Cmc has different options which can be set.  This can be done with + (on)
and -(off) in the command line.  There are also commands that can be set at
the source text, see the @{"compiler" link "Compilerdirec" 0} @{"directives" link "Compilerdirec" 0} for more information.  The
switches can appear in any combination but they are case sensitive, which
mean that -g is not the same as -G!.

  Compiler Argument options
  --------------------------

  Option   Default   Description
  ------   ------- --------------------------------------------------------
   g        On (+)   Optimizer.
   n        On (+)   Insert nil checking code.
   r        On (+)   Insert range checking code.
   o        On (+)   Insert Overflow checking code.
   s        On (+)   Insert stack checking code.
   f        On (+)   Insert return checking code.
   c        On (+)   Insert case checking code.
   d        On (+)   Insert symbol debug information
   v        On (+)   Verbose flag.
   l        On (+)   Clears local vars (EntryClear)
   k        On (+)   Stack scratch registers (D0,D1,A0,A1) on the stack
                     when calling a procedure 
   a        On (+)   Aligning of variables on longwords.
   t        On (+)   Strong TypeChecking
                     (When this is off you can easy mix integer and cardinal type)
   z        -        You can set here the variable for conditional
                     compiling. f.e. (+zEnglish)
   1        off      Code generation of 68010 processor
   2        off      Code generation of 68020 processor
   3        off      Code generation of 68030 processor
   4        off      Code generation of 68040 processor



For code generation of different processors you can only pick one of the
options. If you choose more than one than the latest option is active. You
can use cmc -2 or cmc +2. There is no difference between this.

Note that you should not use checking code within threads, libraries or
hooks.

@endnode

@node "BasicTypes" "Basic types"
 Data type representation

 CHAR           1 byte
 BOOLEAN        1 byte

 SHORTINT       1 byte
 SHORTCARD      1 byte

 INTEGER        2 bytes 2's complement
 CARDINAL       2 bytes
 LONGCARD       4 bytes
 LONGINT        4 bytes 2's complement

 REAL           4 bytes
 LONGREAL       8 bytes

 SHORTSET       1 byte  (0..7)
 BITSET         2 bytes (0..15)
 LONGSET        4 bytes (0..31)

 POINTERS       4 bytes
 PROCEDUREs     4 bytes

Remark: The type REAL make use of the mathieeesingbas.library and
mathieeesingtrans.library. Both of these libraries are only provided in
Workbench V2.0 or greater. If there is need to such libraries for versions
less than 2.0 of the workbench, I will think about it to write a library for
this. The type LONGREAL make use of the mathieeedoubbas.library and
mathieeedoubtrans.library. This libraries are provided from Workbench 1.2.
The type boolean is only 1 byte. This is not common in all languages. A
false value is zero. Everything else is true!!!
@endnode

@node "Keywords" "Keywords"
Default keywords

The following keywords are used by the compiler and may NOT use for
variables, types, procedures etc.

BY, DO, IF, IN, OF, OR, TO, AND, DIV, END, FOR, MOD, NOT, SET, VAR, CASE,
CODE, ELSE, EXIT, FROM, LOOP, THEN, TYPE, WITH, ARRAY, BEGIN, CONST, ELSIF,
UNTIL, WHILE, EXPORT, IMPORT, MODULE, @{"CLOSE" link "Closestatement" 0}, RECORD, REPEAT, RETURN,
FORWARD, BPOINTER, POINTER, PROCEDURE, QUALIFIED, DEFINITION, @{"INLINE" link "Inlining" 0}
IMPLEMENTATION, @{"COMPDATE, COMPTIME" link "DescKeywords" 0}, @{"CONSTRUCTOR, DESTRUCTOR, CLASS" link "OOProgramming" 0}, @{"TRY" link "Exception" 0},
@{"EXCEPT" link "Exception" 0}, @{"FINALLY" link "Exception" 0}, @{"IGNORE" link "DescKeywords" 25}

Note that as Cyclone is case sensitive, these keywords must be in capitals.
If you have a suitable editor (eg GoldED) you may wish to use AutoCase to
ensure you always get the case of keywords correct.  Keeping these keywords
capitalized makes your source code far more readable.

@endnode

@node "InternalProcs" "Internal procedures"
@{b}Internal compiler PROCEDURES@{ub}

 PROCEDURE ABS(x):LONGINT;
 PROCEDURE CAP(ch:CHAR):CHAR;
 PROCEDURE CHR(ch:CHAR):CHAR;
 PROCEDURE DEC(x:ScalarTyp{;d:ScalarTyp}):ScalarTyp;
 PROCEDURE EXCL(x:SetTyp;o:ElemSetTyp):SetTyp;
 PROCEDURE FLOAT(x:ScalarTyp):REAL;
 PROCEDURE HALT;
 PROCEDURE INC(x:ScalarTyp{;d:ScalarTyp}):ScalarTyp;
 PROCEDURE INCL(x:SetTyp;o:ElemSetTyp):SetTyp;
 PROCEDURE ODD(x:ScalarTyp):ScalarTyp;
 PROCEDURE HIGH(s:ARRAY OF CHAR):LONGINT;
 PROCEDURE MAX(x:ScalarTyp):LONGINT;
 PROCEDURE MIN(x:ScalarTyp):LONGINT;
 PROCEDURE ORD(x:ScalarTyp):LONGINT;
 PROCEDURE SIZE(x:AnyType):LONGINT;
 PROCEDURE TRUNC(r:RealTyp):LONGINT;
 PROCEDURE VAL(NewAnytyp,OldAnytyp):NewAnyTyp;
 PROCEDURE NEW(classtyp)
 PROCEDURE DISPOSE(classtyp)

 A part from the default Modula-2 procedures there are two more
 procedures NEW and DISPOSE. These procedures are needed for OO
 programming.



 NEW(classtyp)
 -------------

 When you have declared a new object you need to initialize the object and
 allocate memory for it.

 f.e. NEW(objectvar);

 Will allocate memory for the object and initialize the typedescriptor and
 will call the constructor if one present.

 Remark: The memory allocated for the object will be automatically be freed
 after leaving the program!!


 DEALLOCATE(classtyp)
 --------------------

 This procedure will deallocate the reserved memory for the object.
@endnode

@node "OOProgramming" "OO programming"
@{b}The Object Oriented future@{ub}

Cmc has a few extra syntaxes to make the language object oriented. The
object type class is a pointer to an object.

Like below we can define an object.

TYPE
 TList = CLASS(TObject)
           prev,next:TList;
           CONSTRUCTOR Init;
           PROCEDURE Add;
           DESTRUCTOR Done;
          END

CONSTRUCTOR TList.Init BEGIN (* Some code *) END TList.Init

PROCEDURE TList.Add BEGIN (* Some code *) END TList.Add

DESTRUCTOR TList.Done BEGIN (* Some code *) END TList.Done

VAR
 List:TList;

BEGIN
 NEW(List);
 List^.Add;
 WITH TList^  (*** NOT POSSIBLE, YET
  Add;
 END;          ***********************)
 DISPOSE(List); END x.

The constructor will be called when you initialize a new object with the
procedure "NEW" like above. After that you can call any procedure like
above. Closing (disposing) the object can be done with the procedure
"DISPOSE"

At the moment the OO part has no possibilities for datahiding and you cannot
make use from a with statement with a class.

Of course it is possible to use (virtual) methods, inheritance,
polymorphism.

For examples look at the various modules in the OOModules directory and at
the thread examples in the demo directory.
@endnode

@node "Runtimeerrors" "Runtime errors"
@{b}Runtime errors@{ub}

When the module @{"NoGuru" link "NoGuru" 0} is imported a trap handler is installed and catch the
runtime errors with a nice message.

The compiler generates in some situations special code for checking certain
thinks like NIL pointer errors, range checking etc.

When you don't imported the module NoGuru a runtime error will end up in a
Guru.

The following runtime system errors could occur:


 - Bus error (68000 Exception)
 - Address error (68000 Exception)
 - Illegal instruction (68000 Exception)
 - Zero divide (68000 Exception)
 - Rangecheck error (CHK) (68000 Exception)
 - Overflow error (TPAPV) (68000 Exception)
 - Privilege error (68000 Exception)
 - Trace (68000 Exception)
 - Line 1010 emulator (68000 Exception)
 - Line 1111 emulator (68000 Exception)
 - illegal CASE-index (Trap 0)
 - Pointer is NIL (Trap 1)
 - Overflow (Trap 2)
 - Stack Overflow! (Trap 3)
 - Return Failure! (Trap 4)
 - Range error! (Trap 5)

Note that NoGuru should not be used in libraries. Also be carefull when using 
Threads modules.

@endnode

@node "CompilerLimits" "Compiler limits"
@{b} Compiler Limits@{ub}

There are some limits in the compiler. A few because of the hardware and
some due to the compiler.
 - The total code of a module is limited until 32000 bytes (code+data+bbs).
 - The total string length is limited until 1000 bytes. With the
   concatenate method you are able to make a string with a total length
   of 32000 bytes.
   s='this is a test'+' with a concatenate string'
 - The modulename is limited until 30 chars.
 - The number of exit levels in a LOOP is 16.
 - The number of LOOP depth is 4
 - The number of WITH depth is 3
 - Maximum global modules is 64
 - Maximum of local variable size is 32KB
 - Maximum set size is 32 elements
 - Maximum case entries 127
 - Maximum methods in a object is 127

It is unlikely that any of these limits will affect you.  If they do then
you are probably writing poorly structured code.  

Note: The total code of a module is limited until 32000 bytes. This does not
mean that you cannot write application bigger than this limit. The linker
automaticly add ALV's (Auto Link Vectors).

@endnode

@node "ModulaLib" "The Runtime modula-2 Library (ModulaLib)"
 @{b}The Modula-2 Library (ModulaLib)@{ub}

This library contains the startup and closing code of the generated
executable.  Also the library provides runtime procedures, such as mulu,
muls, div etc, used by the compiler and support procedures for the compiler
and user.  The source code of ModulaLib.mod is also provided. Please be very
careful with change something is this module.  The compiler expect certain
things in the source.  So if you change anything in the source, without
knowing what you are really doing it is possible that the compiler is not
able to compile this module any more. 


 @{b}ModulaLib Vars@{ub}
 --------------

 @{i}wbStarted@{ui} is a boolean to check if the program is started from the
 workbench (true) or not (false).

 @{i}thisTask@{ui}  points to the main task of your program.

    Note that if you use several threads they may be on different tasks and
    you will need to get pointers to their tasks from execbase.
 
 @{i}kickVersion@{ui} has the value of the exec library version.

 @{i}returnVal@{ui} can be used to give a certain return value. Normaly you will do
 this with ModulaLib.Exit(returncode).


 @{i}dosCmdBuf@{ui} contains the arguments buffer (A0 after start).

 @{i}dosCmdLen@{ui} contains the lengths of the argument (D0 after start)

 @{i}wbenchMsg@{ui} contains the workbench startup message.

 @{i}ExceptNr@{ui} gives the last exceptionnumber that is raised with Raise(nr).

 @{i}ExceptStck, saveA7@{ui} and @{i}saveA5@{ui} are used for the exception handler. Don't
 change the values of these vars.


 @{b}ModulaLib Procedures@{ub}
 --------------------

(******* Private procedures; DO NOT USE *********)
 PROCEDURE easystartup;
 PROCEDURE StackChk(space{0}:LONGINT);
 PROCEDURE LoadA4;
 PROCEDURE Mulu32(x{0},y{1}:LONGINT):LONGINT;
 PROCEDURE Muls32(x{0},y{1}:LONGINT):LONGINT;
 PROCEDURE Divu32(x{0},y{1}:LONGINT):LONGINT;
 PROCEDURE Divs32(x{0},y{1}:LONGINT):LONGINT;
 PROCEDURE ModDiv(x{0},y{1}:LONGINT):LONGINT;
 PROCEDURE New(VAR adr:ADDRESS;size:LONGINT);
 PROCEDURE Dispose(VAR adr:ADDRESS);
 PROCEDURE SFix(x{0}:REAL):LONGINT;
 PROCEDURE StoredA4;

 The above mentioned procedures are private. You may never remove them from
 the definition file.


(* Runtime support procedures *)

 @{i}PROCEDURE Assert(cc: BOOLEAN; Msg:ADDRESS);@{ui}

 This procedure gives you the possibility to test an expression and
 depending on the state of that expression the program will be terminated
 or not with a requester.  After the requester popup the users has the
 possibility to continue the program or to terminate it.

 f.e. Assert(FALSE,ADR("some text")); Will terminate the program with
 the message 'some text'.

 @{i}PROCEDURE TerminateRequester(Msg:ADDRESS);@{ui}

 Popup a requester with some text and terminate the program.

 @{i}PROCEDURE Terminate;@{ui}

 Just terminate the program.

@{i} PROCEDURE TermOpenLib(Msg{9}:ADDRESS);@{ui}

 Popup a requester with a message 'Error opening library '+msg and
 terminate the program.

 @{i}PROCEDURE Exit(returnCode{0}:LONGINT);@{ui}

 Terminate the program with a returncode.

 @{i}PROCEDURE Halt;@{ui}

 This is the same as Assert(FALSE,ADR("HALT"));

 @{i}PROCEDURE Raise(i{0}:LONGINT);@{ui}

 This procedure is needed to Raise an exception.
@endnode

@node "NoGuru" "NoGuru"
 This module provides a RunTime traphandler. If you import this module, a
 RunTime Traphandler system will be installed. This has the advantage that
 if you get a trap error the traphandler catch the trap and handle this
 trap in a nice and clean way. This mean that you will get a requester with
 the error and after this the program will be cleanup nicely. Naturally it
 is also possible to write your own traphandler. The @{"ModulaLib" link "ModulaLib" 0} will always
 replace the by you installed traphandler by the default one at closing
 time.

 Be carefull with use NoGuru in a program that uses several threads!

@endnode

@node "ErrorMessages" "Errormessages"
Error| Description
-----+------------------------------------------------------------------
   1 | syntax error
   2 | colon expected
   3 | semi-colon expected
   4 | comma expected
   5 | missing right parenthesis
   6 | missing left parenthesis
   7 | missing right bracket
   8 | missing left bracket
   9 | missing right brace
  10 | missing left brace
  11 | equal sign expected
  12 | assignment expected
  13 | ellipsis expected
  14 | "*)" expected
  15 | TO expected
  16 | DO expected
  17 | UNTIL expected
  18 | THEN expected
  19 | OF expected
  20 | period expected
  21 | END expected
  22 | statement start with illegal symbol
  23 | BEGIN or END expected
  24 | statement part is not allowed in DEFINITION MODULE
  25 | -  
  26 | illegal use of code procedure
  27 | illegal use of forward procedure
  28 | identifiers in heading and end do not match
  29 | procedure call of a function
  30 | type conversion not possible
  31 | MODULE expected
  32 | IMPORT expected
  33 | number too large
  34 | factor starts with illegal symbol
  35 | unexpected end of file
  36 | file error
  37 | error opening object file
  38 | error opening symbol file
  39 | number not allowed
  40 | Invalid number
  41 | didn't found procedure in floating point library
  42 | only a constant expression is allowed
  43 | incompatible type of label or of subrange bound
  44 | illegal type of case expression
  45 | Lower bound greater than upper bound
  46 | duplicate case value
  47 | too many cases
  48 | illegal base type
  49 | invalid type name
  50 | maximum constants in enumeration type is 255
  51 | identifier, (, or [ expected
  52 | index type of array must be a enumeration or a range
  53 | maximum array size exceeded
  54 | unexpected symbols
  55 | illegal symbol
  56 | record type expected
  57 | expecting some parameters
  58 | more parameters than expected
  59 | object should be a module
  60 | identifier expected
  61 | undefined identifier
  62 | identifier already declared
  63 | illegal use of type
  64 | -
  65 | W or L as extension size expected
  66 | error operand format
  67 | size error
  68 | addressing mode not supported
  69 | mode error
  70 | expression error
  71 | record error
  72 | var error
  73 | label already exist
  74 | references already exist
  75 | branch out of range
  76 | undefined label
  77 | register overflow
  78 | S, B, W or L as extension size expected
  79 | unknown identifier
  80 | constant value expected
  81 | mode not supported
  82 | maximum address size exceeded
  83 | -
  84 | illegal index type
  85 | constant out of range
  86 | field name is not available in this record
  87 | variable is not a pointer
  88 | not possible to make type negative
  89 | AND, OR and NOT only possible with boolean type
  90 | set element out of range
  91 | basetype of set incompatible
  92 | type mismatch 
  93 | maximum of nested WITH exceeded
  94 | overflow failure
  95 | incompatible operand types
  96 | operand type incompatible with DIV
  97 | operand type incompatible with MOD
  98 | operand type incompatible with AND
  99 | operand type incompatible with OR
 100 | operand type incompatible with +
 101 | operand type incompatible with -
 102 | operand type incompatible with /
 103 | operand type incompatible with *
 104 | operand type incompatible with relation
 105 | illegal parameter type of standard procedure
 106 | register parameter expected (0-15)
 107 | type as parameter expected
 108 | exceeding size of this TAG variable
 109 | Assignment to a non variable
 110 | error procedure assignment
 111 | incompatible assignment
 112 | illegal assignment
 113 | boolean type of expression expected
 114 | invalid call, object is not procedure
 115 | parameter types not identical
 116 | illegal type of case expression
 117 | illegal type of control variable
 118 | identifier after FOR has an illegal type
 119 | incompatible operands
 120 | step in FOR statement cannot be zero
 121 | too many exit statements
 122 | exit not inside LOOP statement
 123 | more parameters in definition than in implementation.
 124 | mismatch between return types
 125 | function in definition and a procedure in implementation.
 126 | procedure in definition has parameters and in implementation not
 127 | error in export list
 128 | there are procedures without bodies
 129 | maximum length of modulename exceeded (30 chars)
 130 | division by zero
 131 | internal compiler error; unknown standard function
 132 | string is too long
 133 | illegal symbol format
 134 | symbol keys do not match
 135 | 32KB modulcode exceeded
 136 | maximum structures in symbol file exceeded
 137 | maximum size constant data exceeded
 138 | maximum global modules exceeded (64)
 139 | internal compiler error, registers not freed
 140 | expression not allowed or illegal
 141 | expression not addressable or loadable
 142 | fieldindex to big
 143 | expected dynamic array parameter
 144 | illegal range
 145 | longreal type expected
 146 | CAST can only make a type transfer with same sizes
 147 | Not allowed to pass a constant to a var parameter
 148 | illegal character
 149 | only by first element and only integer constant
 150 | register already used
 151 | LONGREALS have to be in D0..D6
 152 | negative bound not allowed
 153 | upper bound may not greater than 31
 154 | complex type not allowed in registers
 155 | function may not be an ARRAY or RECORD type
 156 | function size to big!
 157 | Opaque error
 158 | internal compiler error, D0 and/or D1 are in use
 159 | internal compiler error, this should never happen
 160 | Global register-vars not allowed
 161 | expected a simple type number
 162 | didn't found the procedure in ModulaLib
 163 | did not find the ModulaLib
 164 | Illegal character after "\\"
 165 | internal error
 166 | invalid option only +,- or =
 167 | this option is at this point not changeable
 168 | these options can only be set once
 169 | undefined option
 170 | real type expected
 171 | xref expected identifier
 172 | label or memmonic expected
 173 | use EVEN, odd address!
 174 | address register expected!
 175 | absolute expression expected
 176 | no operand allowed
 177 | expected one operand
 178 | expected two operands
 179 | size bigger as 8 Bit
 180 | size bigger as 16 bit
 181 | size bigger as 3 bit (1-8)
 182 | illegal trap vector (0-15)
 183 | data register expected (D0-D7)
 184 | var outside range 0..MAX(INTEGER)
 185 | mode must be d16(PC)
 186 | not possible to use register variable 
 187 | you may only use string constants
 188 | syntax failure module name
 189 | array to big
 190 | index from array to big
 191 | references on a unknown type
 192 | empty string is not allowed
 193 | string only with DC.B allowed
 194 | total local variable size to large, must be <32KB!
 195 | parameter out of range
 196 | expression too complex
 197 | source and destination size must be the same!
 198 | can only convert strings with size <= 4 bytes
 199 | size bigger as destination
 200 | CAST cannot transfer from or to longreal
 201 | type expected
 202 | You may only use code procedures in a definition file without an
       object file
 203 | You may not use vars in a definition file without an object file
 204 | relocation not supported
 205 | not a valid class
 206 | there are undefined methods
 207 | unknown method/var
 208 | cannot load 'Self' param
 209 | method matches not inherited method
       (PROCEDURE/CONSTRUCTOR/DESTRUCTOR)
 210 | illegal use of CONSTRUCTOR/DESTRUCTOR
 211 | CONSTRUCTOR/DESTRUCTOR may not have any parameters and/or function
 212 | size is not equal to four
 213 | Typedescriptor overflow
 214 | INLINE procedure in definition and not in implementation module
 215 | didn't found the procedure in AutoLib
 216 | didn't found the module AutoLib
 217 | option already defined
 218 | conditional compiling to deep nested
 219 | conditional option ENDIF expected
 220 | conditional ENDIF without IF
 221 | error opening inline reference file
 222 | function may not be used in a library!
 223 | incomplete exception handler
 224 | POINTER TO undefined identifier
 225 | to many elements
 226 | to little elements
 227 | illegal inline format
@endnode

@node "Automaticopts" "Automatic optimizations"
@{b}@{u}Automatic optimizations@{ub}@{uu}


@{b}Constant folding@{ub}

If the operands of an operator are constants, cmc evaluates the expression
at compile time.


@{b}Constant merging@{ub}

When you using the same string more than once there will be only one string
in the data segment.

f.e. You use the statement ADR("Ready") more than once there is only one
copy of the text in the segment.

@{b}Inlining@{ub}

When procedures are taged as INLINE the procedure is included into the code
instead of jumping to this code. This can improve the speed! However it also
increase the size of the executable. So the best procedures to tag to be
inlined are the small ones.


@{b}Peephole Optimizations@{ub}

It would be out of the scope of this doc to mention all the peephole
optimizations the compiler uses.


@{b}Other Optimizations@{ub}

There are some simple optimizations which the compiler will also do:

 - The compiler fixes long branches to short if possible
 - Remove unused nops!
 - Remove unused LINK A5,#0


@{b}Smart linking@{ub}

The linker of Cyclone (cml) automatically removes unused code when making
the executable. The removal of unused code take place on a per procedure
basis.
@endnode

@node "Compilerdirec" "Compiler directives"
 @{b}Compiler directives@{ub}


 A compiler directive is a comment with a special syntax. These directives
 must appear immediately at the beginning of a comment; A directive section
 starts with "(*$" and ends with "*)".  multiple directives
 may be entered in a single comment.  You may not use the @{"C++ comment
 style" link "C++Comment" 0} ( // ) for these compiler directives.  There
 are two types of directives:

 - Switch directives
 - Conditional directives

 Switch directives can be switch on or off with + or - or set back with =.
 Some of these options are stackable. These directives has always a higher
 priority than the options at the argument line. 


 Switch directives


  Option          Stack  Default     Description
  --------------- -----  -------     --------------------------------------

  StackChk         y      *          Insert stack checking code.
  NilChk           y      *          Insert nil checking code.
  RangeChk         y      *          Insert range checking code.
  OverflowChk      y      *          Insert Overflow checking code.
  CaseChk          y      *          Insert case checking code.
  ReturnChk        y      *          Insert return checking code.
  LoadA4           n      Off        Reload the A4 register with the global
                                     data pointer.
  SaveA4           n      Off        Save A4 on the stack
  EntryExitCode    n      On (+)     With this option you can switch off
                                     the compilers default generated entry
                                     or exit code of a procedure. Beware
                                     that you need to generate this by
                                     your self if you switch this off!
                                     (LINK, UNLINK, RTS etc)
  CopyDyn          n      On (+)     Normally the compiler copies a non var
                                     open array parameter to a part of the
                                     stack and use this in the procedure.
                                     So that if you change something on
                                     the array it won't change like a var
                                     parameter! This can be switch off if
                                     you don't change anything on the
                                     parameter which safes some code.
  CaseTab          y      Off(-)     With this option you can choose
                                     between a case table generation or
                                     a straight forward method in the
                                     object file. If you have a long
                                     case statement you can better choose
                                     CaseTab+ this reduces some code.
                                     In small case tables the straight
                                     forward method generates smaller code.
  Implementation   n      On (+)     You can only set this option in the
                                     top of a definition file. If this
                                     is off than the compiler do not
                                     expect a implementation module after
                                     importing this module.
                                     See module ASCII.def
  ReloadA4         n      Off        When on, it reloads the A4 globaldata
                                     pointer at the start of every
                                     procedure.
  LibCode          n      Off        Needs to be on when generating
                                     Library code.
  AutoLib          n      On (+)     When this option is on a definition
                                     module that must open an Library
                                     generates code to do this
                                     automatically. If the option is of the
                                     use must Open the library by it self
                                     an store baselibrary pointer in the
                                     var that is declared in the
                                     definition file.
  EntryClear       n      On (+)     When this option is on all local
                                     variables will be cleared.
  Align            n      On (+)     When this option is on all variables
                                     are longword aligned.
  SaveScratch      y      On (+)     When this option is on registers A0,A1,D0
                                     and D1 shall be saved on the stack when 
                                     calling a procedure. These registers will be
                                     saved when they are in use (f.e. for 
                                     Register parameters). If you are sure the
                                     registers are not trashed in the calling
                                     procedure you can switch this option off
                                     This saves a lot of code!
  ChipData         n      Off (-)    With this option you can put a data
                                     in a module in chipram.
  

  Here is an example how to set such a directive:

  (*$NilChk- RangeChk+ ReturnChk= *)



@{b}  Conditional directiv@{ub}es

  SET    identifier                  Setting a Identifier on true
  CLEAR  identifier                  Setting a Identifier on false
  NOT    identifier                  Inverse identifier
  IF     identifier                  \\
  ELSE                                > Keywords IF [NOT] ident [ELSE] END
  END                                /

  Here is an example:

  MODULE Directives;
  (*$ SET English *)

  IMPORT io:InOut;

  BEGIN
   (*$ IF English *)
      io.WriteString('English');
   (*$ ELSE *)
      io.WriteString('No English');
   (*$ END  *)
  END Directives.
@endnode

@node "Inlineasm" "The inline assembler"
@{b}The inline Assembler@{ub}

An 68000 inline assembler is provided.  Once ASSEMBLE is imported from
@{"SYSTEM" link "SYSTEM" 0}, you can enter inline assembler code by bracketing it with the
keywords ASSEMBLE and END. Assembler input is free form.  Comments are
entered as in regular Modula-2.  All modula-2 variables can generally be
accessed in assembler. It is not (yet) possible to use relocation.

Remember, this is a Modula-2 compiler, not an assembler! The inline
assembler capability is provided for use in small time critical or low level
routines only. 


Default Keywords


The following instructions are at the moment supported.

A0, A1, A2, A3, A4, A5, A6, A7, D0, D1, D2, D3, D4, D5, D6, D7, DC, MP, OR,
SB, SP, SR, PC, CCR, USP, EVEN, XREF, ABCD, ADD, ADDA, ADDI, ADDQ, ADDX,
AND, ANDI, ASL, ASR, BCC, BCHG, BCLR, BCS, BEQ, BGE, BGT, BHI, BLE, BLS,
BLT, BMI, BNE, BPL, BRA, BSET, BSR, BTST, BVC, BVS, CHK, CLR, CMP, CMPA,
CMPI, CMPM, DBCC, DBCS, DBEQ, DBF, DBGE, DBGT, DBHI, DBLE, DBLS, DBLT, DBMI,
DBNE, DBPL, DBRA, DBT, DBVC, DBVS, DIVSI, DIVS, DIVU, EOR, EORI, EXG, EXT,
JMP, JSR, LEA, LINK, LSL, LSR, MOVE, MOVEA, MOVEM, MOVEP, MOVEQ, MULS,
MULSI, MULU, NBCD, NEG, NEGX, NOP, NOT, OR, ORI, PEA, RESET, ROL, ROR, ROXL,
ROXR, RTE, RTR, RTS, SBCD, SCC, SCS, SEQ, SF, SGE, SGT, SHI, SLE, SLS, SLT,
SMI, SNE, SPL, ST, STOP, SUB, SUBA, SUBI, SUBQ, SUBX, SVC, SVS, SWAP, TAS,
TRAP, TRAPV, TST, UNLK


How can I use this assembler?


Well that is easy. First you import from the @{"SYSTEM" link "SYSTEM" 0} module the keyword
ASSEMBLE. After this you can use the assembler any ware you like.

Examples:

PROCEDURE StrLength(s:ARRAY OF CHAR):INTEGER; (*$ EntryExitCode- *)  (*
  Switch of the by the compiler generated entry and exit code
  I do it myself! *) BEGIN
 ASSEMBLE(
    MOVE.L  (A7)+,A0 (* return address *)
    MOVE.L  (A7)+,A1 (* s *)
    MOVE.L  (A7)+,D0 (* HIGH(s) *)
    MOVE.L  D0,D1
  l:
    TST.B   (A1)+
    DBEQ    D1,l
    SUB.W   D1,D0     (* len:=HIGH(s)-D1 *)
    JMP     (A0)
  END);   END StrLength;

PROCEDURE SetAVar; VAR i:INTEGER; BEGIN
 ASSEMBLE(
    MOVE.W #1,i(A5)
    (* the exit code is generated by
       the compiler (EntryExitCode is on !!!) *)
 END) END SetAVar;

As you can see the comments are not started with a semi-colon (;) but
started with (* and ended with *) as in Modula-2.
@endnode

@node "Inlining" "inlining"
@{b}Inlining@{ub}

Cyclone has the possibility to make inline code; When you tag a procedure as
inline the compiler generates code for the specified function at the point
the function is called, instead of a branch to the actual function. Using
this keyword can increase code size, but it can make your code run faster.
Using inlining can increase the compiling speed.

When you using inline functions in an implementation module you must tag any
exported inline functions as INLINE in the definition file as well as in the
implementation file.

f.e.

PROCEDURE Times(x{2},y{3}:LONGINT):LONGINT; INLINE;

This procedure will be inline if you make the following call

BEGIN
 i:=Times(3,4); END x.

It is wise to use inlining only by small procedures for maximum result of
speed.

For obvious reasons you cannot take the address of an inline function or
call it recursively.

@endnode

@node "Objectformat" "Object Format"
@{b}Object format@{ub}

Currently, the compiler generates code using the small model only. (large
model will be implemented as soon as possible) Each module has its own data
and code segments. The linker binds all the code and data segments together.
@endnode

@node "SYSTEM" "SYSTEM Module"
 The module SYSTEM includes the following definitions:

TYPES
 BYTE
 WORD
 ADDRESS
 SHORTSET
 BITSET
 LONGSET

 PROCEDURE ADR(VAR a:AnyTyp):ADDRESS;
 PROCEDURE ASSEMBLE({Assembler command(s)} END);
 PROCEDURE CAST(NewAnytyp,OldAnytyp):NewAnyTyp;
 PROCEDURE REG(rconst:[0..15]):LONGINT;
 PROCEDURE SETREG(rconst:[0..15],t:typesize4);
 PROCEDURE SHIFT(x:ScalarTyp,n:LONGINT):ScalarType;
 PROCEDURE TAG(VAR x:Anytyp; val {,val}:ADDRESS):ADDRESS;
 PROCEDURE TSIZE(t:Anytyp):LONGINT;
 PROCEDURE RAWDATA(const:word, {const});

ADR
 The 'ADR' function is used to find the runtime address of any variable or
 string constant. The result has a type ADDRESS. You can also use
 the symbol @ to get a runtime address.

ASSEMBLE
 Activates the @{"internal assembler" link "Inlineasm" 0}.

CAST
 With cast is it possible to change a type to a new type without any type
 conversion.  The only restriction is that the original type and the new
 type must have the same size.

REG
 Reg return the value which is kept into the register.
 0..7  -> D0..D7
 8..15 -> A0..A7

SETREG
 Puts the value (t) into the register rconst.
 0..7  -> D0..D7
 8..15 -> A0..A7

SHIFT
 This procedure shifts argument x argument n bits.  A positive value of n
 shifts to the left and a negative value performs a right shift.

TAG
 The first parameter of tag gives the memory that is needed for all the
 longwords that are followed in the next parameter(s).
 f.e.  VAR TagBuffer:ARRAY[0..10] OF LONGINT;
           TagAdr:ADDRESS;

 TagAdr:=TAG(TagBuffer,waTitle,ADR('TagDemo'),waWidth,500,waHight,200,tagEnd
));

 TagAdr Memory  0    ADR('TagDemo')
                4    500
                8    200
                12   tagEnd

 The TAG function is only implemented for compatibility with other
 compilers. Usually it is better to use the Cyclone "[ stuff ]" notation.

 For example

 DoMethod(myobj, [sometag, someval, anothertag, anotherval, tagEnd]);

 Click @{"here" link "Lists" 0} for more information.


TSIZE
 This is implemented for compatibility reasons. It is better to use SIZE.

RAWDATA
 With this procedure it is possible to put rawdata in the objectfile.
@endnode

@node "Startwriting" "Start making a program"
In this chapter we walk true al the steps to make a little program up to the
final executable.

1) Write with your favorite texteditor a Cyclone Module-2 program f.e.

   MODULE HelloWorld;

   FROM InOut IMPORT WriteString, WriteLn;

   BEGIN
    WriteString("Hello World!"); WriteLn;
   END HelloWorld.


   Save this program to a file ended with .mod f.e. Helloworld.mod!

2) To compile this program you can use cmm (the make program) or use cmc
   (the compiler and later on the linker). I will demonstrate both.

   First I will do it with the make program.

   shell> cmm helloworld
   Cyclone Modula-2 Make V1.06e Beta,
   29.06.96,(c) Marcel Timmermans.
   - helloworld.mod
   - am2:modules/txt/InOut.def
   - am2:modules/txt/InOut.mod
   - am2:modules/txt/Workbench.def
   - am2:modules/txt/GraphicsD.def
   - am2:modules/txt/Hardware.def
   - am2:modules/txt/ExecD.def
   - am2:modules/txt/UtilityD.def
   - am2:modules/txt/IntuitionD.def
   - am2:modules/txt/KeyMapD.def
   - am2:modules/txt/Timer.def
   - am2:modules/txt/InputEvent.def
   - am2:modules/txt/DosD.def
   - am2:modules/txt/Reg.def
   - am2:modules/txt/DosL.def
   - am2:modules/txt/ModulaLib.def
   - am2:modules/txt/ModulaLib.mod
   - am2:modules/txt/ExecL.def
   - am2:modules/txt/Ascii.def
   - am2:modules/txt/String.def
   - am2:modules/txt/String.mod
   - am2:modules/txt/Convert.def
   - am2:modules/txt/Convert.mod
   + helloworld.mtx

   cmc  helloworld.mod
   Cyclone Modula-2 Compiler V0.72e Beta,
   14.07.96,(c) Marcel Timmermans.
   - cmc.opt (+g-snrofcd)
   - helloworld.mod
   - am2:modules/sym/ModulaLib.sym
   - am2:modules/sym/InOut.sym
   + HelloWorld.obj
     Optimizing ...  18 Bytes optimized
     CODE: 48 CONST: 0 BBS: 4 DATA: 0

   cml  helloworld
   Cyclone Modula-2 Linker V1.09e Beta,
   20.06.96, (c) Marcel Timmermans.
   - helloworld.obj
   - am2:modules/obj/ModulaLib.obj
   - am2:modules/obj/ExecL.obj
   - am2:modules/obj/InOut.obj
   - am2:modules/obj/Convert.obj
   - am2:modules/obj/String.obj
   - am2:modules/obj/DosL.obj
   + helloworld
     CODE:1708 DATA:0 VAR:136 PROGRAM: 1744
     Purebit set. Program is reentrant.
   Shell>


   To start the program you can type helloworld in the shell:

   Shell>Helloworld
   Hello World!
   Shell>


   To make this program by your self with the compiler and linker do the
   following.

   Shell>cmc helloworld.mod
   Cyclone Modula-2 Compiler V0.72e Beta,
   14.07.96,(c) Marcel Timmermans.
   - cmc.opt (+g-snrofcd)
   - helloworld.mod
   - am2:modules/sym/ModulaLib.sym
   - am2:modules/sym/InOut.sym
   + HelloWorld.obj
     Optimizing ...  18 Bytes optimized
     CODE: 48 CONST: 0 BBS: 4 DATA: 0

   Shell>cml helloworld
   Cyclone Modula-2 Linker V1.09e Beta,
   20.06.96, (c) Marcel Timmermans.
   - helloworld.obj
   - am2:modules/obj/ModulaLib.obj
   - am2:modules/obj/ExecL.obj
   - am2:modules/obj/InOut.obj
   - am2:modules/obj/Convert.obj
   - am2:modules/obj/String.obj
   - am2:modules/obj/DosL.obj
   + helloworld
     CODE:1708 DATA:0 VAR:136 PROGRAM: 1744
     Purebit set. Program is reentrant.
   Shell>


   And again you can run the program as the same way as mentioned above.
   With complex programs it is easier to use the program cmm (make program)
   because this program compiler the modules in the correct order and than
   linked them. For simple programs it is quicker to use the compiler and
   linker separately.

   The output of the compiler, linker and make program is a little bit
   different than above. Normaly the modules will be scanned and displayed
   on one line instead on separate lines.
@endnode

@node "ControlIndex" "Control Issues"
 @{b}THIS PAGE IS UNDER CONSTRUCTION :)@{ub}

Here you find compiler specific information!


   @{"Registers" link "Registers" 0}           Handling of registers
   @{"Lists" link "Lists" 0}               Static lists [..,..]
   @{"Threads" link "Threads.guide/main" 0}             How to use threads
   @{"inlining" link "Inlining" 0}            How to use function inlining
   @{"OO programming" link "OOProgramming" 0}      OO Programming
   @{"Exception handling" link "Exception" 0}  How to use Exception handling
   @{"Addressable Const" link "AdrConst" 0}   How to make use of addressable constants
   @{"Escape characters" link "escapechars" 0}   Escaped characters in string and character constants
   @{"CLOSE" link "Closestatement" 0}               Close keyword
   @{"C++ Comment" link "C++Comment" 0}         C++ Comment (//)
@endnode

@node "Registers" "Registers"
 @{b}@{u}Registers@{ub}@{uu}

Registers that can be free used are D2..D7 and A0..A3. The registers
A4,A5,A6 and A7 are for special use!

Register A4

This register point to the small global variables. When this register is
changed a lot of operations are not possible any more!! The means that
whenever A4 is changed this register must be pushed on the stack (@{"SaveA4" link "Compilerdirec" 30})
and afterwards popped again. You can also make use of @{"LoadA4" link "Compilerdirec" 28} to reload the
register again.

So please be careful with this register. Change of this register will lead
into strange bugs!


Register A5

This is the LINK register and is the basis of the local variables and
parameters of procedures.  This register will always be loaded (if Compiler
option EntryExitCode is on) at the start of a local procedure. This mean
that when you use the assembler in a local procedure you must never change
this register!


Register A6

This register point to a library which is loaded when you make use of
library procedures/functions.


Register A7

This register will be used as the stackpointer.


Register variables

Register variables can be used in local procedures. This can be done with
the following syntax:

VAR r{3}:INTEGER;

This means that register D3 will be used whenever you will use variable
'r'.

Register Parameters

It is also possible to put parameters directly into a register. This future
was really designed for Library procedures but it is also useful in other
situations too.

Example.

 PROCEDURE Swap(x{0},y{1});

This means that the arguments x and y are passed by register D0 and D1. This
future is only possible with simple types! Structured types, like records
and open arrays, are not possible! You must pass pointer to them instead
@endnode

@node "Lists" "Lists"
@{b}@{u}Static lists ([..,..])@{ub}@{uu}

Lists are more like an constant array of long elements. Lists are written
using [ and ] to delimit comma separated elements. Example:

[1,2,3,@i,5]

is an expression that has a a return value an address to an already
initialized list.

@{b}Memorymap@{ub}

     Off
     ---

      0      1
      4      2
      8      3
      12     ADDRESS OF i
      16     5

Lists are most useful for writing taglists. See the 'Rom Kernal Reference
Manual' for more information about tags. With this 'function' you can easily
fill in taglist. It is also possible to nest list. Example:

[1,2,3,[10,11,12],ADR("test")]

@{b}Memorymap@{ub}

     Off
     ---

      0     1
      4     2
      8     3
      12    address of the list [10,11,12] 24
      16    address of the constanttext 'test'
      20    0
      24    10
      28    11
      32    12
@endnode

@node "AdrConst" "Addressable Constants"
@{b}Addressable constants@{ub}


You can easily use the ADR statement in a CONST definition block. f.e.

...

FROM SYSTEM IMPORT ADR,ADDRESS;

TYPE
 PenTyp   = ARRAY[0..3] OF INTEGER;
 LabelRec = RECORD
              adr:ADDRESS;
              pens:PenTyp;
              attr:ADDRESS;
            END;
 LabelTyp = ARRAY[0..2] OF LabelRec;


CONST

 Labels =LabelTyp{
            LabelRec{ADR("Display"),PenTyp{-1,..},NIL},
            LabelRec{ADR("Edit"),PenTyp{-1,..},NIL}
            LabelRec{ADR("File"),PenTyp{-1,..},NIL}};

...

In this way it is possible to make a relocatable datablock. At the moment
you can only uses text as argument from ADR!
@endnode

@node "DescKeywords" "Description of Keywords"
@{b}COMPDATE & COMPTIME@{ub}

If you uses the keyword COMPDATE the compiler will automatically fill in the
current date as a null terminated string in here. For the word COMPTIME the
current time will be filled in.

f.e.
  CONST
  CurrCompDateTxt = 'Current compilation date is : '+COMPDATE;
  CurrCompTimeTxt = 'Current compilation time is : '+COMPTIME;

If it is today 12 march 1994 and the time is 12:01:01

Than the constant string will be after compilation:

  CurrCompDateTxt = 'Current compilation date is : 12-03-1994';
  CurrCompTimeTxt = 'Current compilation time is : 12:01:01';

NOTE: This text is only visible in the object file. So the source file
      will be intact.




@{b}IGNORE@{ub}

With the keyword IGNORE you can ignore function results. f.e. if you have a
function LoadFile(name:ARRAY OF CHAR):BOOLEAN; and you don't want to test
the function result you can call the function as follow:

IGNORE LoadFile('myfile');

This would save some code instead of using IF LoadFile('myfile' THEN END; or
ok:=LoadFile('myfile');

Use IGNORE with care.  Never ignore error codes if an error could cause
problems later.  Only ignore things you really don't need.

@endnode

@node "Files" "Output files"
@{u}Objectfile (*.obj)@{uu}

An object file contains machine code, data and relocation information. This
objectfile is blink compatible.


@{u}Symbolfile (*.sym|*.ref)@{uu}

A symbol file contains information about the constants, types, variables and
procedures exported by a implementation module and is used by the compiler
if the module is imported by another module. The files ended with .ref are
needed for the Source Level Debugger which is still under development.
@endnode

@node "repbugs" "Reporting bugs"
@{b}Reporting bugs@{ub}

The programs of Cyclone have been programmed with great attention to
reliability. However, it is possible that it may contain bugs.

I you happen to find one, or you have any comments or suggestions for
improvements, write @{"me" link "AutherInfo" 0} an mail (English) that clearly describe the bug.

Please include an example of the program that demonstrates the bug. Also it
will be useful to describe the system that you using (KS, processor,
Memory).
@endnode

@node "escapechars" "Escape characters"
Using Escape Characters in string and char constants

There are, of course, lots of useful characters that can't easily be written
into a program source file.  Therefor Cyclone Modula-2 Compiler allows the
use of escaped characters in string and character constants. An escaped
character consists of a "\\" character followed by one or more characters.
The "\\" character indicates to the compiler that the following character(s)
has special meaning. The meanings are:

      \\o     : insert a nul, CHR(0)
      \\b     : insert a backspace, CHR(08H)
      \\e     : insert an escape, CHR(1BH)
      \\t     : insert a tab, CHR(09H)
      \\n     : insert a newline, CHR(0AH)
      \\f     : insert a form-feed, CHR(0CH)
      \\r     : insert a carriage return CHR(0DH)
      \\[     : insert CSI (Control Sequence Introducer), CHR(9BH)
      \\xnn   : insert the character with ASCII value nn hex.
      \\nnn   : insert the character with ASCII value nnn octal

every other character passes through unchanged, so the following definitions
also hold:

           \\\   Just a single backslash
           \\'   A single quote, even in a single-quote-delimited
                constant
           \\"   A double quote, even in a String constant


Examples:

 CONST
     EscText = "This is an\\n\\tescaped string constant\\n";
@endnode

@node "Break" "Module Break (Control-C)"
@{u}Module Break@{uu}

This module allows you to easily install a break handler with can react on
the dos signals Ctrl-C, Ctrl-D, Ctrl-E and Ctrl-F. When you import this
module you must call the procedure InstallExeption to install the
break-handler. With the procedure TestBreak() you can test on any of the
signals. After a signal is detected the program jumps to the close part of
the program and starts the closing phase. Default the module will always
react on the Ctrl-C signal. You can changes this by changing the SET
actualBreak.

With the procedure RemoveException you can remove the break handler. The
module Break do this always in the CLOSE part.

Note that this module cannot be used in multithreaded programs.

@endnode

@node "Importend" "Importend to know"


@{b}TRUE and FALSE@{ub}

The value for a TRUE  type = -1 (FFH) 1 byte The value for a FALSE type =  0
(0H)  1 byte

This is very importend in taglists! This is different than in the language
C. In C false is 0, while true is any other value, but mostly defined as
true=1.

I have created the constants LFALSE end LTRUE in the ExecD module. When you
use taglist it is wisely to use this constants.


@{b}Register A4@{ub}

This register points to the small global variables. When this register is
changed a lot of operations are not possible any more!! The means that
whenever A4 is changed this register must be pushed on the stack (@{"SaveA4" link "Compilerdirec" 30})
and afterwards popped again. You can also make use of @{"LoadA4" link "Compilerdirec" 28} to reload the
register again.

So please be careful with this register. Change of this register will lead
into strange bugs! (See also @{"Registers" link "Registers" 0})


@{b}"/" and DIV@{ub}

When you use the following expression : x:=x/y; and x and y are integer
types than the "/" is treaded the same as the operator DIV. You could also
write : x:=x DIV y; When you use floating type that you must use "/" to do a
division.
@endnode

@node "Closestatement" "CLOSE"
With using the keyword 'CLOSE' you are able to define a statement part that
will be called when the program ends, either naturally or due to an error.

Is this statement part you can put things that need to be done when a
program fails or closes.  f.e.  Free up global memory, freeing resources,
closing libraries etc.

When a program close all the CLOSE parts of the IMPORTED module will be
called in the correct way. A close part can be called more than once. So
when you use code in a close part you must be sure that the close code is
very safe by checking everything before deallocating it.
@endnode

@node "KnownErrors" "Known Errors"
@{b}CMM@{ub}

 - When a sourcefiles doesn't exist the make util do not try to recompile
   the module which imported the symbolfile of this missing sourcefile!!
@endnode

@node "C++Comment" "C++ Comment"
Besides the Modula-2 standard comment style (*.. *) you can also use C++
Comment style (//) in the Cyclone compiler.

f.e.

 MODULE Example;
 // This program is using the C++ Comment style

 // You need to put for every line a '//' to mark this line as comment
 // You may not set the options with C++ Comment style

 (*$ RangeChk- *) // ^^^^ Options

 BEGIN
 // Nothing to do
 END Example.
@endnode

@node "Thanks" "Thanks"
The following persons deserve special thanks from me as they made a
significant contribution to the development of Cyclone Modula-2 Compiler.
(no particular order)

 * Robert Ennals        - for a lot of testing, writing several modules 
                          (Threads,MemPool etc), checking the documentation
                          and a lot more
 * Stefan Tiemann       - for writing a lot of system modules, lot of testing
                          several test modules/programs and the translation of
                          this guide to German.
 * Wouter van Oortmersen- for his helpfull discussions
 * Soenke Tesch         - for all his testing and helpfull modules/programs
 * Stefan Schulz        - for making a codegeneration module for MuiBuilder
                          and a lot of testing
 * Stephan Splitthoff   - for a lot of testing
 * Herbert Klackl       - for a lot of testing
 * Dr. Maybe            - for very helpfull talk sessions
 * Ralph Babel          - for his GREAT book "The Amiga Guru book"
 * Commodore            - for making the wonderful machine!!! AMIGA FOREVER!

Other people who where essential to development of Cyclone:

 * Rhett R. Rodewald
 * Robert Barton
 * Tim Corringham
 * S Sinclair
 * Andrew P Scheller

and last but not least my girlfriend for the many evenings I left her
alone. Thanks Marie-An!

And all the people I forgot!!

@endnode

