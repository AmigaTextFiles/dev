@database HYPER:Modula-2/UtilityD
@node Main "HYPER:Modula-2/UtilityD"

Konstanten

   @{" tagDone " link Modul 28}                     @{" tagEnd " link Modul 29}                      @{" tagFilterAND " link Modul 36}
   @{" tagFilterNOT " link Modul 37}                @{" tagIgnore " link Modul 30}                   @{" tagMore " link Modul 31}
   @{" tagSkip " link Modul 32}                     @{" tagUser " link Modul 34}                     @{" utilityName " link Modul 11}


Typ-Deklarationen

   @{" ClockData " link Modul 39}                   @{" ClockDataPtr " link Modul 45}                @{" Hook " link Modul 51}
   @{" HookProc " link Modul 48}                    @{" HookPtr " link Modul 47}                     @{" Tag " link Modul 14}
   @{" TagItem " link Modul 16}                     @{" TagItemPtr " link Modul 22}                  @{" TagPtr " link Modul 21}


@endnode
@node Modul "HYPER:Modula-2/UtilityD.def.guide"
DEFINITION MODULE UtilityD; (*$Implementation:=FALSE*)
(* 26-Feb-1992/cn *)

FROM SYSTEM IMPORT ADDRESS;

FROM ExecD IMPORT
 @{" MinNode " link HYPER:Modula-2/ExecD.def.guide/Modul 26};

IMPORT
 R;

CONST
 utilityName="utility.library";

TYPE
 @{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}=LONGCARD;
 @{" TagItem " link HYPER:Modula-2/UtilityD.def.guide/Modul 16}=RECORD
  tag:@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14};
  data:LONGCARD;
 END;

 @{" TagPtr " link HYPER:Modula-2/UtilityD.def.guide/Modul 21}=POINTER TO @{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14};
 @{" TagItemPtr " link HYPER:Modula-2/UtilityD.def.guide/Modul 22}=POINTER TO @{" TagItem " link HYPER:Modula-2/UtilityD.def.guide/Modul 16};
(*
 Genaugenommen zeigen TagPtr und TagItemPtr meist auf eine Folge von
 Tag bzw. Tagitem.
*)

CONST
 tagDone=@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}(0); tagEnd=tagDone;
 tagIgnore=@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}(1);
 tagMore=@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}(2);
 tagSkip=@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}(3);

 tagUser=@{" Tag " link HYPER:Modula-2/UtilityD.def.guide/Modul 14}(80000000H);

 tagFilterAND=0;
 tagFilterNOT=1;

TYPE
 @{" ClockData " link HYPER:Modula-2/UtilityD.def.guide/Modul 39}=RECORD
  sec,min,hour:CARDINAL;
  mday,month,year:CARDINAL;
  wday:CARDINAL;
 END;
 @{" ClockDataPtr " link HYPER:Modula-2/UtilityD.def.guide/Modul 45}=POINTER TO @{" ClockData " link HYPER:Modula-2/UtilityD.def.guide/Modul 39};

 @{" HookPtr " link HYPER:Modula-2/UtilityD.def.guide/Modul 47}=POINTER TO @{" Hook " link HYPER:Modula-2/UtilityD.def.guide/Modul 51};
 @{" HookProc " link HYPER:Modula-2/UtilityD.def.guide/Modul 48}=PROCEDURE(HookPtr{R.A0},
                    (*object*)ADDRESS{R.A2},
                    (*message*)ADDRESS{R.A1}):ADDRESS;
 @{" Hook " link HYPER:Modula-2/UtilityD.def.guide/Modul 51}=RECORD
  node:@{" MinNode " link HYPER:Modula-2/ExecD.def.guide/Modul 26};
  entry:@{" HookProc " link HYPER:Modula-2/UtilityD.def.guide/Modul 48};
  subEntry:ADDRESS;
  data:ADDRESS;
 END;
(*
 "entry" ist die Prozedur die tatsächlich aufgerufen wird. Bei
 Hochsprachen, die keine Registervariabeln kennen, würde "entry" eine
 Assemblerprozedur enthalten, dass die Register auf den Stack lädt,
 und dann die in "subEntry" eingetragene Prozedur aufruft.

 Da M2Amiga eine Parameterübergabe in den Registern erlaubt, kann
 eine korrekt deklarierte Prozedur direkt in "entry" eingetragen
 werden.
*)

END UtilityD.noimp

@endnode
