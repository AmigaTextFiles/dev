


                   M2LMC - Modula2 Library-Modul-Converter


                                  © 1994

                             Carsten Ziegeler

                               Version 1.1


                             Was macht M2LMC ?
                             -----------------

M2LMC versucht grob gesagt, jedes normale Bibliothesmodul für den
M2Amiga in ein entsprechendes Modul für den LibraryLinker m2liblink
umzuwandeln.
Es entstand aus dem Problem, daß man beim Erstellen einer Bibliothek
eigentlich nicht so programmiert, daß diese ohne späteren Aufwand
auch eine Shared-Library abgeben kann. Will man nun aber gerade
dieses tun, so muß man alle Prozeduren mit Registerparametern ver-
sehen. Hat man dieses getan, so wird man meistens feststellen, daß
jetzt sich das Implementationsmodul nicht mehr übersetzen läßt, da
oft zuwenig Register frei sind. Und nun muß man seine gesamte Modul-
bibliothek umkonzipieren.
M2LMC nimmt einen diese Aufgaben ab ! D.h. Sie können Ihr Modul ganz
normal entwickeln, bearbeiten es mit M2LMC und schwupp, schon haben
Sie eine Shared-Library. (Zumindestens theoretisch !)


                             Copyright
                             ---------

Das gesamte M2LMC-Paket ist Freeware.

Lesen Sie M2LMC.doc für sämtliche Copyright-Hinweise und Benutzung-
möglichkeiten.
Es darf frei kopiert und weitergegeben werden, solange alle unter
Mindestumfang angegebenen Files unverändert enthalten sind.
An den dort angegebenen Files darf NICHTS verändert werden.
Es kann keine Garantie für das Programm gegeben werden. Der Autor
haftet nicht für eventuelle Schäden, die durch dieses Programm auftreten.
Jede kommerzielle Vermarktung und auch Nutzung ist verboten und bedarf
der Zustimmung des Autors.
Folgende Programme müssen enthalten sein:

M2LMC      Der Konverter
M2LMCUI    Eine graphische Oberfläche für M2LMC (OS 2.04 erforderlich)
M2LMC.dok  Diese Anleitung
M2LMC.doc  Englische Dokumentation


                               Installation
                               ------------

Kopieren Sie M2LMC (und auch M2LMCUI, wenn gewünscht) ins M2:-Ver-
zeichnis. Für M2LMCUI benötigen Sie mindestens OS2.04 !

M2LMC benutzt die Modula2-Linker-Library Versionen der newlists.library
und der guitools.library (V38.0) !


                            Aufruf von M2LMC
                            ----------------

M2LMC wird über das CLI gestartet und kennt folgende Parameter:

M2LMC [-rFILENAME] [-wFILENAME] [-vVERSION] [-vrREVISION] MODULENAME


 -vVersion   gibt die Versionsnummer Ihre Library an, also z.B.
             -v37 für eine Bibliothek unter OS2.0.
             Voreingestellt wird Ihre aktuelle Kickstartversion !
 -vrRevision die Revisionsnummer. Voreingestellt ist 1.

 MODULENAME  gibt das Modul an, das konvertiert werden soll. Geben Sie
             den Namen ohne Endung, aber mit Pfad an !
             Also z.B. M2LMC txt/NeueLibray
             M2LMC würde dann txt/NeueLibrary.def nach
             txt/NeueLibraryLib.def und txt/NeueLibrary.mod nach
             txt/NeueLibraryLib.mod konvertieren.

 -wFILENAME  Hier können Sie eine Zwischendatei angeben, in der M2LMC
 -rFILENAME  wichtige Werte über Ihre Prozeduren in der Library speichert.
             Diese Werte können Sie ändern und mit einem neuen Aufruf
             von M2LMC diesmal aber mit -rFILENAME wird Ihr Modul nicht
             neu analysiert, sondern es werden nur die Werte aus der
             Datei genommen. So können Sie in die Arbeit von M2LMC
             bzgl der Interfaceroutinen eingreifen. (Genau dieses tut
             auch M2LMCUI.)
             Genaueres über diese Zwischendatei erfahren Sie gleich...



                            Die Konvertierung
                            -----------------

Die Änderungen im Definitionsmodul:

M2LMC kopiert das Definitionsmodul und hängt an den Namen die Endung
"Lib" an. Zusätzlich werden noch folgende Zeilen hinzugefügt:
- CONST version = <VERSIONSNR>; (* Diese Nummer können Sie mit -v angeben*)
- TYPE <modulname>BasePtr = POINTER TO <modulname>;
       <modulname>Base = RECORD
         lib:Library;
         (* globale Variablen hierein *)
       END;
- CONST baseSize = SIZE(<modulname>Base);
- Die Definitionen für die Prozeduren LibOpen, LibClose, LibExpunge und
  LibExtFunc werden vor die anderen Prozedur-Definitionen geschrieben.

Des weiteren werden die Import-Listen so erweitert, daß dieses Modul ohne
weitere Änderungen übersetzt werden kann.
Nun werden alle Prozeduren mit Registerparametern versehen, dabei werden
alle Typen bis auf Zeiger in die Datenregister beginnend mit D0 und der
Rest in die Adressregister beginnend mit A0 gepackt.
Die Zuordnung der Parameter zu den Registern geschieht automatisch. Sie
läßt sich aber mit Hilfe der Zwischendatei manipulieren. (Mehr dazu gleich)


Die Änderungen im Implementationsmodul:

M2LMC kopiert das Implementationsmodul und hängt an den Namen die Endung
"Lib" an. Zusätzlich werden noch folgende Zeilen hinzugefügt:
- Sämtliche Kontrollen werden ausgeschaltet (z.B. (* NilChk:=FALSE *))
- Die Importlisten werden entsprechend erweitert
- CONST revision = <REVISIONSNR>; (* Angabe über -vr *)
- VAR myLib : <modulname>BasePtr;
- Es werden die Prozeduren LibOpen, LibClose, LibExpunge und LibExtFunc
  hinzugefügt.
- hinter dem BEGIN des Moduls wird noch folgende Zeile hinzugefügt:
  myLib := CAST(<modulname>BasePtr, dosCmdLen);
- Alle Prozeduren erhalten ein (*$ LoadA4:=TRUE *)
- Die Prozeduren werden mit Registerparametern versehen. Zusätzlich wird,
  um das Problem mit den zuwenigen Registern zu vermeiden, eine sog.
  Interfaceprozedur geschrieben. Die Eigentliche Prozedur bekommt an
  ihren Namen noch ein "E" gehängt und M2LMC generiert eine neue.
  Diese schiebt nun alle Register auf den Stack und ruft dann die alte
  Prozedur auf.
  Damit dieses aber reibungslos funktioniert, muß M2LMC wissen, welcher
  Datentyp wieviele Bytes belegt.
  M2LMC kennt folgende Datentypen, die automatisch in Datenregister ab-
  gelegt werden. In Klammern erfolgt die Größenangabe in Bytes:
  - SHORTINT (1)
  - INTEGER (2)
  - LONGINT (4)
  - SHORTCARD (1)
  - CARDINAL (2)
  - LONGCARD (4)
  - SHORTSET (1)
  - BITSET (2)
  - LONGSET (4)
  - FFP (4)
  - REAL (4)
  - CHAR (1)
  - BOOLEAN (1)
  Alle anderen Typen, die nicht auf <Set> enden, werden in Adressregister
  gelegt und bekommen die Größe von 4 Bytes. Typen, die auf <Set> enden,
  gelangen in Datenregister und es wird eine Größe von 4 Byte angenommen.


   Ändern der Prozedurdeklarationen mit Hilfe der Zwischendatei
   ------------------------------------------------------------

In der Zwischendatei wird nun für jede Prozedur festgehalten, welche
Parameter sie hat, in welche Register diese gelangen und welche Größe
die Typen haben. M2LMC erkennt sehr viele automatisch und ordnet ihnen
die richtige Größe zu, aber bei einigen kann es Probleme geben. (Z.B.
bei Sets, die nicht 4 Bytes belegen.)
Hier können Sie also andere Register angeben bzw die Längen korrigieren.
Des weiteren können Sie angeben, ob für die entsprechende Prozedur eine
Interfaceroutine geschrieben werden soll oder nicht. Diese wird nämlich
überflüssig, wenn kaum Parameter benutzt werden. Hier hilft oft probieren
weiter.
Wenn Sie OS2.0 haben, können Sie zum ändern der Zwischendatei besser
M2LMCUI benutzen. Für alle anderen nun aber der Aufbau der Zwischendatei:
Das Schlüsselwort ##PROC= kennzeichnet, daß eine neue Prozedurdefinition
anfängt. Dahinter steht der Name der Prozedur.
Nun folgen für jeden Parameter folgende  vier Zuweisungen:
VAR=     : enthält den Variablennamen
TYPE=    : enthält den Variablentyp
LENGTH=  : Länge des Types in Bytes
REG=     : Register
Nachdem alle Parameter so angegeben wurden, erfolgt noch die Zuweisung
INTERFACE=TRUE oder INTERFACE=FALSE. Sie gibt an, ob eine Interface-
routine erstellt werden soll oder nicht.


Was muß man noch selber machen ?
--------------------------------

Das einzige, was einem bleibt, ist darauf zu achten, daß man sein Modul
fehlerfrei entwickelt hat und daß es sich in eine Library umwandeln
lassen kann.
Man muß nur noch die globalen Variablen in die von M2LMC eingefügte
LibraryBase-Struktur eintragen und das Lib-Implementationsmodul dem-
entsprechend anpassen.


                          Benutzung von M2LMCUI
                          ---------------------

Der Aufbau der Zwischendatei ist sehr unübersichtlich, so daß eine
graphische Benutzeroberfläche dafür geschaffen wurde. Es benötigt
mindestens OS2.04 für die graphische Benutzeroberfläche.
Nach dem Starten geben Sie genau wie beim Aufruf von M2LMC im CLI,
die Parameter an, d.h. Modulnamen, Version, Revision und einen
Namen für die Zwischendatei. Im Gegensatz zu M2LMC MÜSSEN sie ALLE
Parameter angeben !
Mit einem Druck auf <Do It> wird M2:M2LMC aufgerufen und M2LMC erstellt
nun die Zwischendatei. Sollte die Zwischendatei schon
vorhanden gewesen sein, so wird NICHT M2LMC aufgerufen, sondern es
wird nur die alte Datei geladen !
M2LMCUI ließt also nun diese Datei und es wird ein neues Fenster mit
vielen Gadgets geöffnet. Oben sehen Sie den Prozedurnamen, Daneben
steht ein Checkbox-Gadget für die Interfaceroutine. Darunter stehen
die Parameter jeweils mit Länge und Registerangaben. Diese können Sie
je nach belieben ändern.
Mit dem "+" und "-" - Gadgets können Sie zwischen den Prozeduren um-
schalten.
Mit einem Druck auf OK wird die geänderte Zwischendatei geschrieben
und M2LMC neu aufgerufen und damit die Konversion gestartet.


                             Bekannte Probleme
                             -----------------

 1. Das Implementations-Modul MUß eine BEGIN-Anweisung enthalten. Sie
    brauch aber keine Befehle enthalten. Ist dies nicht der Fall so
    wirft M2LMC eine Fehlermeldung aus !
 2. Type-Definitionen, die eine PROCEDURE-Anweisung enthalten, müßen
    vorher in Kommentare umgewandelt werden, da der einfache Parser
    von M2LMC nur nach dem Schlüsselwort PROCEDURE sucht, und dann
    davon ausgeht, daß nun wirklich eine vorliegt. Handelt es sich
    aber um einen TYPE-Befehl, so interpretiert M2LMC diesen falsch
    und es entsteht der größte Blödsinn !
    Sie brauchen diese Befehle nicht in Kommentare umwandeln, wenn
    nach der PROCEDURE-Anweisung direkt eine Klammer-Auf folgt,
    also z.B. ...PROCEDURE(....
 3. Enthält eine Prozedur lokale Prozeduren, so muß die (*$ LoadA4:=TRUE *)
    Anweisung, die direkt hinter die PROCEDURE-Anweisung gesetzt wird
    und sich somit nur auf die erste lokale Prozedur beziehen würde,
    an die entsprechende Stelle von Hand umgesetzt werden.
    Dieses ist ein Problem des simpel gehaltenen Parsers.
 4. Aus demselben Grund müssen Typen im Implementations-Modul auf die
    selbe Art wie im Definitions-Modul importiert werden, d.h. folgendes
    ist nicht möglich :

    DEFINITION MODULE ....

    IMPORT I:IntuitionD;

      PROCEDURE OpenAWindow(wptr : I.WindowPtr);

     END ...

     IMPLEMENTATION MODULE ....

       FROM IntuitionD IMPORT WindowPtr;

       PROCEDURE OpenAWindow(wptr : WindowPtr);
     END ...

     Denn M2LMC macht dann im Implementations-Modul daraus einen Aufruf
     wie etwa:

       PROCEDURE OpenAWindow(wptr{R.A0} : I.WindowPtr);


Insgesamt gesehen glaube ich aber, daß man mit diesen Restriktionen leben
kann, denn M2LMC soll einen ja auch nur beim Erstellen der entsprechenden
Moduln unterstützen.



                           Mögliche Fehlerursachen
                           -----------------------

Was tun, wenn der Library-Linker munter eine Library erstellt hat, man
diese austestet und ..whoop... blink..blink..blink  - ein Absturz.

Bei meiner Arbeit mit M2LMC haben sich folgende zwei Fehlerursachen ergeben:

 1) Bei irgendeiner Prozedur, bei der ein Interface erstellt wird, ist
    die Länge einer Variablen falsch angegeben.
    Beheben: Mit Hilfe von M2LMCUI alle Aufrufe noch einmal systematisch
             durchgehen und überall die Längen und auch die Register
             überprüfen !
 2) Eine Prozedur enthält lokale Prozeduren, so daß wie oben berichtet,
    die (*$ LoadA4:=TRUE *)-Anweisung falsch positioniert ist.
    Beheben: Modul nach lokalen Prozeduren durchsuchen und ggf. die
             Option nach der letzten lokalen Prozedur stellen.

Wenn Ihr Modul vorher einwandfrei lief und Sie diese drei Fehlerquellen
ausgeschlossen haben, dürfte dem einwandfreien Funktionieren der
shared-library nichts mehr im Wege stehen....


                       Ein kurzes Beispiel
                       -------------------

Wenn Sie eine Bibliothek mit dem Namen test.def/test.mod haben, die die
folgende Prozedur enthält:

  PROCEDURE Wow(a, b : CARDINAL; c : LONGINT):BOOLEAN;

tut ein Aufruf von <M2LMC test> das folgende:

Im Definitionsmodul testlib.def:

  PROCEDURE Wow(a{R.D0}, b{R.D1} : CARDINAL; c{R.D2} : LONGINT):BOOLEAN;

Im Implementationsmodul testlib.mod

  PROCEDURE WowE(a, b : CARDINAL; c : LONGINT):BOOLEAN;
  (*$ LoadA4:=TRUE *)
  ....
  END WowE;

  PROCEDURE Wow(a{R.D0}, b{R.D1} : CARDINAL; c{R.D2} : LONGINT):BOOLEAN;
  (*$ EntryExitCode:=FALSE *)
  BEGIN
    ASSEMBLE(MOVE.W D0, -(A7)
             MOVE.W D1, -(A7)
             MOVE.L D2, -(A7)
             BSR    WowE(PC)
             RTS  END);
  END Wow;

Wenn Sie <M2LMC -wTEMP test> ausführen, sieht das File TEMP so aus:

##PROCEDURE=Wow
VAR=a
TYPE=CARDINAL
LENGTH=2
REG=D0
VAR=b
TYPE=CARDINAL
LENGTH=2
REG=D1
VAR=c
TYPE=LONGINT
LENGTH=4
REG=D2
INTERFACE=TRUE
##ENDOFFILE




Viel Spaß !

Mai-1994, Carsten Ziegeler
          Augustin-Wibbelt-Str.7
          33106 Paderborn

