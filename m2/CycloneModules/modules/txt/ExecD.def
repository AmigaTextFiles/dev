(*
**	Cyclone Modula-2 Interface module:
**	$VER: exec.h 39.0 (15.10.91)
**	Includes Release 40.15
**
**	Include all other Exec include files in a non-overlapping order.
**
**	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**      Interface module by Marcel Timmermans
**      (C) Copyright 1995-1996 Marcel Timmermans
**          All Rights Reserved
*)

DEFINITION MODULE ExecD;
(*$ Implementation- *)

FROM SYSTEM IMPORT BYTE, WORD, ADDRESS, BITSET, SHORTSET, LONGSET,CAST;

TYPE
  BPTR=BPOINTER TO LONGINT;
  IOFlagSet=SHORTSET;
  DevicePtr=POINTER TO Device;
  ExecBasePtr=POINTER TO ExecBase;
  InterruptPtr=POINTER TO Interrupt;
  IORequestPtr=POINTER TO IORequest;
  IOStdReqPtr=POINTER TO IOStdReq;
  LibraryPtr=POINTER TO Library;
  ListPtr=POINTER TO List;
  MemChunkPtr=POINTER TO MemChunk;
  MemHeaderPtr=POINTER TO MemHeader;
  MemListPtr=POINTER TO MemList;
  MessagePtr=POINTER TO Message;
  MinListPtr=POINTER TO MinList;
  MinNodePtr=POINTER TO MinNode;
  MsgPortPtr=POINTER TO MsgPort;
  NodePtr=POINTER TO Node;
  ResidentPtr=POINTER TO Resident;
  SemaphoreMessagePtr=POINTER TO SemaphoreMessage;
  SemaphorePtr=POINTER TO Semaphore;
  SignalSemaphorePtr=POINTER TO SignalSemaphore;
  TaskPtr=POINTER TO Task;
  UnitPtr=POINTER TO Unit;

CONST
 LTRUE=CAST(BOOLEAN,1);  (* Needed for Libraries *)
 LFALSE=CAST(BOOLEAN,0); (* Needed for Libraries *)
  

(*********************************************************************
*
*  Format of the alert error number:
*
*    +-+-------------+----------------+--------------------------------+
*    |D|  SubSysId   |	General Error |    SubSystem Specific Error    |
*    +-+-------------+----------------+--------------------------------+
*     1    7 bits	   8 bits		   16 bits
*
*		     D:  DeadEnd alert
*	      SubSysId:  indicates ROM subsystem number.
*	 General Error:  roughly indicates what the error was
*	Specific Error:  indicates more detail
**********************************************************************)

(*********************************************************************
*
*  General Alerts
*
*  For example: timer.device cannot open math.library would be 0x05038015
*
*	Alert(AN_TimerDev|AG_OpenLib|AO_MathLib);
*
*********************************************************************)

CONST

(**********************************************************************
*
*  Hardware/CPU specific alerts:  They may show without the 8 at the
*  front of the number.  These are CPU/68000 specific.	See 680x0
*  programmer's manuals for more details.
*
**********************************************************************)

  acpuBusErr    = 080000002H;	(* Hardware bus fault/access error *)
  acpuAddressErr= 080000003H;	(* Illegal address access (ie: odd) *)
  acpuInstErr   = 080000004H;	(* Illegal instruction *)
  acpuDivZero   = 080000005H;	(* Divide by zero *)
  acpuCHK       = 080000006H;	(* Check instruction error *)
  acpuTRAPV     = 080000007H;	(* TrapV instruction error *)
  acpuPrivErr   = 080000008H;	(* Privilege violation error *)
  acpuTrace     = 080000009H;	(* Trace error *)
  acpuLineA     = 08000000AH;	(* Line 1010 Emulator error *)
  acpuLineF     = 08000000BH;	(* Line 1111 Emulator error *)
  acpuFormat    = 08000000EH;	(* Stack frame format error *)
  acpuSpurious  = 080000018H;	(* Spurious interrupt error *)
  acpuAutoVec1  = 080000019H;	(* AutoVector Level 1 interrupt error *)
  acpuAutoVec2  = 08000001AH;	(* AutoVector Level 2 interrupt error *)
  acpuAutoVec3  = 08000001BH;	(* AutoVector Level 3 interrupt error *)
  acpuAutoVec4  = 08000001CH;	(* AutoVector Level 4 interrupt error *)
  acpuAutoVec5  = 08000001DH;	(* AutoVector Level 5 interrupt error *)
  acpuAutoVec6  = 08000001EH;	(* AutoVector Level 6 interrupt error *)
  acpuAutoVec7  = 08000001FH;	(* AutoVector Level 7 interrupt error *)

(*********************************************************************
*
*  General Alerts
*
*  For example: timer.device cannot open math.library would be 0x05038015
*
*	Alert(AN_TimerDev|AG_OpenLib|AO_MathLib);
*
*********************************************************************)



(*------ alert types *)
  deadEnd	= 080000000H;
  recovery	= 000000000H;

(*------ general purpose alert codes *)
  noMemory	= 000010000H;
  makeLib	= 000020000H;
  openLib	= 000030000H;
  openDev	= 000040000H;
  openRes	= 000050000H;
  iOError	= 000060000H;
  noSignal	= 000070000H;
  badParm	= 000080000H;
  closeLib	= 000090000H;	(* usually too many closes *)
  closeDev	= 0000A0000H;	(* or a mismatched close *)
  procCreate= 0000B0000H;	(* Process creation failed *)


(*------ alert objects: *)
  aoexecLib	= 000008001H;
  aographicsLib= 000008002H;
  aolayersLib	= 000008003H;
  aointuition	= 000008004H;
  aomathLib	= 000008005H;
  aodOSLib	= 000008007H;
  aorAMLib	= 000008008H;
  aoiconLib	= 000008009H;
  aoexpansionLib = 00000800AH;
  aodiskfontLib  = 00000800BH;
  aoutilityLib   = 00000800CH;

  aoaudioDev	  = 000008010H;
  aoconsoleDev  = 000008011H;
  aogamePortDev = 000008012H;
  aokeyboardDev = 000008013H;
  aotrackDiskDev= 000008014H;
  aotimerDev	  = 000008015H;

  aocIARsrc	= 000008020H;
  aodiskRsrc	= 000008021H;
  aomiscRsrc	= 000008022H;

  aobootStrap	= 000008030H;
  aoworkbench	= 000008031H;
  aodiskCopy	= 000008032H;
  aogadTools	= 000008033H;
  aounknown	= 000008035H;



(*********************************************************************
*
*   Specific Alerts:
*
*********************************************************************)

(*------ exec.library *)
  anexecLib	= 001000000H;
  anexcptVect	= 001000001H; (* 68000 exception vector checksum (obs.) *)
  anbaseChkSum= 001000002H; (* Execbase checksum (obs.) *)
  anlibChkSum	= 001000003H; (* Library checksum failure *)

  anmemCorrupt= 081000005H; (* Corrupt memory list detected in FreeMem *)
  anintrMem	= 081000006H; (* No memory for interrupt servers *)
  aninitAPtr	= 001000007H; (* InitStruct() of an APTR source (obs.) *)
  ansemCorrupt= 001000008H; (* A semaphore is in an illegal stateH;
				             at ReleaseSempahore() *)
  anfreeTwice	= 001000009H; (* Freeing memory already freed *)
  anbogusExcpt= 08100000AH; (* illegal 68k exception taken (obs.) *)
  anioUsedTwice=00100000BH; (* Attempt to reuse active IORequest *)
  anmemoryInsane=00100000CH; (* Sanity check on memory list failed
				                during AvailMem(MEMF_LARGEST) *)
  anioAfterClose= 00100000DH; (* IO attempted on closed IORequest *)
  anstackProbe  = 00100000EH; (* Stack appears to extend out of range *)
  anbadFreeAddr = 00100000FH; (* Memory header not located. [ Usually an
                                invalid address passed to FreeMem() ] *)
  anbadSemaphore= 001000010H; (* An attempt was made to use the old
                                message semaphores. *)

(*------ graphics.library *)
  angraphicsLib   = 002000000H;
  angfxNoMem      = 082010000H;	(* graphics out of memory *)
  angfxNoMemMspc  = 082010001H;	(* MonitorSpec alloc, no memory *)
  anlongFrame     = 082010006H;	(* long frame, no memory *)
  anshortFrame    = 082010007H;	(* short frame, no memory *)
  antextTmpRas    = 002010009H;	(* text, no memory for TmpRas *)
  anbltBitMap     = 08201000AH;	(* BltBitMap, no memory *)
  anregionMemory  = 08201000BH;	(* regions, memory not available *)
  anmakeVPort     = 082010030H;	(* MakeVPort, no memory *)
  angfxNewError   = 00200000CH;
  angfxFreeError  = 00200000DH;

  angfxNoLCM      = 082011234H;	(* emergency memory not available *)

  anobsoleteFont  = 002000401H;	(* unsupported font description used *)

(*------ layers.library *)
  anlayersLib     = 003000000H;
  anlayersNoMem   = 083010000H;	(* layers out of memory *)

(*------ intuition.library *)
  anintuition     = 004000000H;
  angadgetType    = 084000001H;	(* unknown gadget type *)
  anbadGadget     = 004000001H;	(* Recovery form of AN_GadgetType *)
  ancreatePort    = 084010002H;	(* create port, no memory *)
  anitemAlloc     = 004010003H;	(* item plane alloc, no memory *)
  ansubAlloc      = 004010004H;	(* sub alloc, no memory *)
  anplaneAlloc    = 084010005H;	(* plane alloc, no memory *)
  anitemBoxTop    = 084000006H;	(* item box top < RelZero *)
  anopenScreen    = 084010007H;	(* open screen, no memory *)
  anopenScrnRast  = 084010008H;	(* open screen, raster alloc, no memory *)
  ansysScrnType   = 084000009H;	(* open sys screen, unknown type *)
  anaddSWGadget   = 08401000AH;	(* add SW gadgets, no memory *)
  anopenWindow    = 08401000BH;	(* open window, no memory *)
  anbadState      = 08400000CH;	(* Bad State Return entering Intuition *)
  anbadMessage    = 08400000DH;	(* Bad Message received by IDCMP *)
  anweirdEcho     = 08400000EH;	(* Weird echo causing incomprehension *)
  annoConsole     = 08400000FH;	(* couldn't open the Console Device *)
  annoISem        = 004000010H;	(* Intuition skipped obtaining a sem *)
  anisemOrder     = 004000011H;  (* Intuition obtained a sem in bad order *)

(*------ math.library *)
  mathLib   = 005000000H;

(*------ dos.library *)
  andOSLib    = 007000000H;
  anstartMem  = 007010001H; (* no memory at startup *)
  anendTask   = 007000002H; (* EndTask didn't *)
  anqPktFail  = 007000003H; (* Qpkt failure *)
  anasyncPkt  = 007000004H; (* Unexpected packet received *)
  anfreeVec   = 007000005H; (* Freevec failed *)
  andiskBlkSeq= 007000006H; (* Disk block sequence error *)
  anbitMap    = 007000007H; (* Bitmap corrupt *)
  ankeyFree   = 007000008H; (* Key already free *)
  anbadChkSum = 007000009H; (* Invalid checksum *)
  andiskError = 00700000AH; (* Disk Error *)
  ankeyRange  = 00700000BH; (* Key out of range *)
  anbadOverlay= 00700000CH; (* Bad overlay *)
  anbadInitFunc= 00700000DH; (* Invalid init packet for cli/shell *)
  anfileReclosed= 00700000EH; (* A filehandle was closed more than once *)

(*------ ramlib.library *)
  anramLib    = 008000000H;
  anbadSegList= 008000001H;	(* no overlays in library seglists *)

(*------ icon.library *)
  aniconLib   = 009000000H;

(*------ expansion.library *)
  anexpansionLib = 00A000000H;
  anbadExpansionFree = 00A000001H; (* freeed free region *)

(*------ diskfont.library *)
  andiskfontLib = 00B000000H;

(*------ audio.device *)
  anaudioDev = 010000000H;

(*------ console.device *)
  anconsoleDev = 011000000H;
  annoWindow = 011000001H;	(* Console can't open initial window *)

(*------ gameport.device *)
  angamePortDev = 012000000H;

(*------ keyboard.device *)
  ankeyboardDev = 013000000H;

(*------ trackdisk.device *)
  antrackDiskDev  = 014000000H;
  antdCalibSeek   = 014000001H;	(* calibrate: seek error *)
  antdDelay       = 014000002H;	(* delay: error on timer wait *)

(*------ timer.device *)
  antimerDev      = 015000000H;
  antmBadReq      = 015000001H; (* bad request *)
  antmBadSupply   = 015000002H; (* power supply -- no 50/60Hz ticks *)

(*------ cia.resource *)
  anCIARsrc = 020000000H;

(*------ disk.resource *)
  andiskRsrc = 021000000H;
  andRHasDisk = 021000001H;	(* get unit: already has disk *)
  andRIntNoAct = 021000002H;	(* interrupt: no active unit *)

(*------ misc.resource *)
  anmiscRsrc = 022000000H;

(*------ bootstrap *)
  anbootStrap = 030000000H;
  anbootError = 030000001H;	(* boot code returned an error *)

(*------ Workbench *)
  anworkbench		     = 031000000H;
  annoFonts		     = 0B1000001H;
  anwbBadStartupMsg1	 = 031000001H;
  anwbBadStartupMsg2	 = 031000002H;
  anwbBadIOMsg		 = 031000003H;  (* Hacker code? *)

  anwbInitPotionAllocDrawer = 0B1010004H;
  anwbCreateWBMenusCreateMenus1 = 0B1010005H;
  anwbCreateWBMenusCreateMenus2 = 0B1010006H;
  anwbLayoutWBMenusLayoutMenus = 0B1010007H;
  anwbAddToolMenuItem	 = 0B1010008H;
  anwbReLayoutToolMenu = 0B1010009H;	 (* GadTools broke? *)
  anwbinitTimer		 = 0B101000AH;
  anwbInitLayerDemon	 = 0B101000BH;
  anwbinitWbGels		 = 0B101000CH;
  anwbInitScreenAndWindows1 = 0B101000DH;
  anwbInitScreenAndWindows2 = 0B101000EH;
  anwbInitScreenAndWindows3 = 0B101000FH;
  anwbMAlloc		 = 0B1010010H;

(*------ DiskCopy *)
  andiskCopy = 032000000H;

(*------ toolkit for Intuition *)
  angadTools = 033000000H;

(*------ System utility library *)
  anutilityLib = 034000000H;

(*------ For use by any application that needs it *)
  anunknown = 035000000H;

(*
 *  List Node Structure.  Each member in a list starts with a Node
 *)

TYPE
(*
** Note: Newly initialized IORequests, and software interrupt structures
** used with Cause(), should have type NT_UNKNOWN.  The OS will assign a type
** when they are first used.
*)
(*----- Node Types for LN_TYPE -----*)
 NodeType=(
  unknown,task,interrupt,device,msgPort,message,freeMsg,
  replyMsg,resource,library,memory,softInt,font,process,
  semaphore,signalSem,bootNode,kickMem,graphics,deathMessage
 );
CONST
 user=CAST(NodeType,SHORTCARD(254)); (* User node types work down from here *)
 extended=CAST(NodeType,SHORTCARD(255));

TYPE
 Node=RECORD
   succ:NodePtr;    (* Pointer to next (successor) *)
   pred:NodePtr;    (* Pointer to previous (predecessor) *)
   type:NodeType;
   pri:SHORTINT;    (* Priority, for sorting *)
   name:ADDRESS;    (* ID string, null terminated *)       
 END;
 MinNode=RECORD
   succ:MinNodePtr;
   pred:MinNodePtr;
 END;

(*
 *  Full featured list header.*
*)

 List=RECORD
   head:NodePtr;
   tail:NodePtr;
   tailPred:NodePtr;
   type:NodeType;
   pad:BYTE;
 END;

(*
 * Minimal List Header - no type checking
 *)
 MinList=RECORD
   head:MinNodePtr;
   tail:MinNodePtr;
   tailPred:MinNodePtr;
 END;

CONST
(*
 * Standard Device IO Errors (returned in io_Error)
 *)
  openFail=-1;  (* device/unit failed to open *)                
  aborted=-2;   (* request terminated early [after AbortIO()] *)
  noCmd=-3;     (* command not supported by device *)
  badLength=-4; (* not a valid length (usually IO_LENGTH) *)
  badAddress=-5;(* invalid address (misaligned or bad range) *)
  unitBusy=-6;  (* device opens ok, but requested unit is busy *)
  selfTest=-7;  (* hardware failed self-test *)                   

TYPE
  ResidentFlags=(
   coldstart,singleTask,afterDos,rf3,rf4,rf5,rf6,autoinit
  );
  ResidentFlagSet=SET OF ResidentFlags;
  Resident=RECORD
    matchWord:CARDINAL;         (* word to match on (ILLEGAL)	*)
    matchTag:ResidentPtr;       (* pointer to the above	*)
    endSkip:ADDRESS;            (* address to continue scan	*)
    flags:ResidentFlagSet;      (* various tag flags		*)
    version:SHORTCARD;          (* release version number	*)
    type:NodeType;              (* type of module (NT_XXXXXX)	*)
    pri:SHORTINT;               (* initialization priority *)
    name:ADDRESS;               (* pointer to node name	*)
    idString:ADDRESS;           (* pointer to identification string *)
    init:ADDRESS;               (* pointer to init code	*)             
  END;

CONST
  matchword=04AFCH;     (* The 68000 "ILLEGAL" instruction *)
  never=ResidentFlagSet{};


TYPE
  MemReqs=(public,chip,fast,mr3,mr4,mr5,mr6,mr7,
           local,       (* Memory that does not go away at RESET *)
           dma24Bit,    (* DMAable memory within 24 bits of address *)
           (*39*)kick,mr11,mr12,mr13,mr14,mr15,
           memClear,    (* AllocMem: NULL out area before return *)
           largest,     (* AvailMem: return the largest chunk size *)
           reverse,     (* AllocMem: allocate from the top down *)
           total,       (* AvailMem: return total size of memory *)
           mr20,mr21,mr22,mr23,mr24,mr25,mr26,mr27,mr28,mr29,mr30,
           (*39*)noExpunge);

  MemReqSet=SET OF MemReqs; (* MemReqSet{} = Any type of memory will do *)
  MemTypeSet=SET OF [public..mr15];

(****** MemChunk ****************************************************)

  MemChunk=RECORD
    next:MemChunkPtr; 	(* pointer to next chunk *)
    bytes:LONGCARD;     (* chunk byte size	*)       
  END;

(****** MemHeader ***************************************************)

  MemHeader=RECORD
    node:Node;
    attributes:MemTypeSet;      (* characteristics of this region *)
    first:MemChunkPtr;          (* first free region		*)
    lower:ADDRESS;              (* lower memory bound		*)
    upper:ADDRESS;              (* upper memory bound+1	*)
    free:LONGCARD;              (* total number of free bytes	*)       
  END;

(****** MemEntry ****************************************************)

  MemEntry=RECORD
    CASE :INTEGER OF
    | 1: reqs:MemReqSet     (* the AllocMem requirements *)
    | 2: addr:ADDRESS		(* the address of this memory region *)
    END;
    length:LONGCARD;		(* the length of this memory region *)       
  END;

(* Note: sizeof(struct MemList) includes the size of the first MemEntry! *)
  MemList=RECORD
    node:Node;
    numEntries:CARDINAL;
(* ml_ME: ARRAY[0..numEntries-1] OF MemEntry *)
  END;

(****** MemHandlerData **********************************************)
(* Note:  This structure is *READ ONLY* and only EXEC can create it!*)

  MemHandlerData=RECORD         
    requestSize:LONGCARD;       (* Requested allocation size *)
    requestFlags:MemReqSet;     (* Requested allocation flags *)
    flags:LONGSET;              (* Flags (see below) *)           
  END;

CONST
   recycle=0;   (* 0==First time, 1==recycle *) 

(****** Low Memory handler return values ***************************)

  memDidNothing=0;  (* Nothing we could do... *)
  memAllDone=-1;	(* We did all we could do *)
  memTryAgain=1;    (* We did some, try the allocation again *)



TYPE
(*----- Flag Bits ------------------------------------------*)

  TaskFlags=(
    procTime,tf1,tf2,eTask,stackChk,exception,switch,launch
  );
  TaskFlagSet=SET OF TaskFlags;

(*----- Task States ----------------------------------------*)
  TaskState=(nonvalid,added,run,ready,wait,except,removed);

(* Please use Exec functions to modify task structure fields, where available.
 *)
  Task=RECORD
    node:Node;
    flags:TaskFlagSet;
    state:TaskState;
    idNestCnt:SHORTINT;     (* intr disabled nesting*)
    tdNestCnt:SHORTINT;	    (* task disabled nesting*)
    sigAlloc:LONGSET;       (* sigs allocated *)
    sigWait:LONGSET;        (* sigs we are waiting for *)
    sigRecvd:LONGSET;       (* sigs we have received *)
    sigExcept:LONGSET;	    (* sigs we will take excepts for *)
    trapAlloc:BITSET;	    (* traps allocated *)
    trapAble:BITSET;        (* traps enabled *)
    exceptData:ADDRESS;	    (* points to except data *)
    exceptCode:PROC;	    (* points to except code *)
    trapData:ADDRESS;       (* points to trap data *)
    trapCode:PROC;          (* points to trap code *)
    spReg:ADDRESS;          (* stack pointer	    *)
    spLower:ADDRESS;        (* stack lower bound    *)
    spUpper:ADDRESS;        (* stack upper bound + 2*)
    switch:PROC;	        (* task losing CPU	  *)
    launch:PROC;	        (* task getting CPU  *)
    memEntry:List;  	    (* Allocated memory. Freed by RemTask() *)
    userData:ADDRESS;       (* For use by the task; no restrictions! *)    
  END;

  StackSwapStruct=RECORD
    lower:ADDRESS;          (* Lowest byte of stack *)              
    upper:ADDRESS;          (* Upper end of stack (size + Lowest) *)
    pointer:ADDRESS;        (* Stack pointer at switch point *)      
  END;

CONST
(*----- Predefined Signals -------------------------------------*)

  sigAbort  = 0;
  sigChild  = 1;
  sigBlit   = 4;
  sigSingle = 4;
  sigIntuition = 5;
  sigNet    = 7;
  sigDos    = 8;


TYPE
(* mp_Flags: Port arrival actions (PutMsg) *)
  MsgPortAction=(signal, softint, ignore);

 IntFlags=(
    tbeInt,dskblk,ifSoftint,ports,coper,vertb,blit,aud0i,
    aud1i,aud2i,aud3i,rbfInt,disksync,exter,inten,intSet
  );
  Interrupt=RECORD
    node:Node;
    data:ADDRESS;   (* server data segment  *)
    code:PROC;      (* server code entry    *)
  END;

(****** MsgPort *****************************************************)
  MsgPort=RECORD
    node:Node;
    CASE flags:MsgPortAction OF
    | signal:
      sigBit:SHORTCARD;         (* signal bit number	*)
      sigTask:TaskPtr;          (* object to be signalled *)
    | softint:
      pad0:BYTE;
      softInt:InterruptPtr;
    | ignore:
      pad1:BYTE;
      pad2:ADDRESS
    END;
    msgList:List;               (* message linked list	*)
  END;

  Message=RECORD
    node:Node;
    replyPort:MsgPortPtr; (* message reply port *)
    length:CARDINAL;      (* total message length, in bytes *)
				          (* (include the size of the Message *)
				          (* structure in the length) *)
  END;

  IntVector=RECORD  (* For EXEC use ONLY! *)
    data:ADDRESS;
    code:PROC;
    node:NodePtr;
  END;
  SoftIntList=RECORD  (* For EXEC use ONLY! *)
    list:List;
    pad:WORD;
  END;

CONST
(* this is a fake INT definition, used only for AddIntServer and the like *)
 nmi=15;

TYPE
(****** SignalSemaphore *********************************************)

  SemaphoreRequest=RECORD
    link:MinNode;
    waiter:TaskPtr;
  END;

(* Signal Semaphore data structure *)
  SignalSemaphore=RECORD
    link:Node;
    nestCount:INTEGER;
    waitQueue:MinList;
    multipleLink:SemaphoreRequest;
    owner:TaskPtr;
    queueCount:INTEGER;
  END;

(****** Semaphore procure message (for use in V39 Procure/Vacate ****)
  SemaphoreMessage=RECORD
    message:Message;
    semaphore:SignalSemaphorePtr;
  END;

CONST
  shared=1;
  exclusive=0;

(****** Semaphore (Old Procure/Vacate type, not reliable) ***********)
TYPE
  Semaphore=RECORD
    msgPort:MsgPort;
    bids:INTEGER;
  END;

(* Libraries *)
(*------ Special Constants ---------------------------------------*)

CONST
  vectSize=6;       (* Each library entry takes 6 bytes *)
  reserved=4;       (* Exec reserves the first 4 vectors *) 
  base=-vectSize;
  userDef=base-reserved*vectSize;
  nonStd=userDef;

(*------ Standard Functions --------------------------------------*)
  open=-6;
  close=-12;
  expunge=-18;
  extFunc=-24;

TYPE
 (* lib_Flags bit definitions (all others are system reserved) *)
  LibFlags=(summing,changed,sumUsed,delExp);
  LibFlagSet=SET OF LibFlags;

(*------ Library Base Structure ----------------------------------*)
(* Also used for Devices and some Resources *)

  Library=RECORD
    node:Node;
    flags:LibFlagSet;
    pad:BYTE;
    negSize:CARDINAL;   (* number of bytes before library *)
    posSize:CARDINAL;   (* number of bytes after library *)
    version:CARDINAL;   (* major *)
    revision:CARDINAL;  (* minor *)
    idString:ADDRESS;   (* ASCII identification *)
    sum:LONGCARD;       (* the checksum itself *)
    openCnt:CARDINAL;   (* number of current opens *)                
  END; (* Warning: size is not a longword multiple! *)

(****** Device ******************************************************)
TYPE
  Device=RECORD
    library:Library;
  END;

(****** Unit ********************************************************)
  UnitFlags=(active,inTask,uf2,uf3,uf4,uf5,uf6,uf7);
  UnitFlagSet=SET OF UnitFlags;

  Unit=RECORD
    msgPort:MsgPort; (* queue for unprocessed messages *)
                     (* instance of msgport is recommended *)
    flags:UnitFlagSet;
    pad:BYTE;
    openCnt:CARDINAL; (* number of active opens *)
  END;

(** IO ***)
  IORequest=RECORD
    message:Message;
    device:DevicePtr;
    unit:UnitPtr;
    command:CARDINAL;
    flags:SHORTSET;
    error:SHORTINT;
  END;
  IOStdReq=RECORD
    message:Message;
    device:DevicePtr;
    unit:UnitPtr;
    command:CARDINAL;
    flags:SHORTSET;
    error:SHORTINT;
    actual:LONGCARD;
    length:LONGINT;
    data:ADDRESS;
    offset:LONGCARD;
  END;

CONST
(* library vector offsets for device reserved vectors *)

  beginIO=-30;
  abortIO=-36;

(* io_Flags defined bits *)
  quick=SHORTSET{};

  invalid=0;
  reset=1;
  read=2;
  write=3;
  update=4;
  clear=5;
  stop=6;
  start=7;
  flush=8;

  nonstd=9;

(* Definition of the Exec library base structure (pointed to by location 4).
** Most fields are not to be viewed or modified by user programs.  Use
** extreme caution.
*)

TYPE
(****** Bit defines for AttnFlags ******************************)

  AttnFlags=(
    m68010,m68020,m68030,m68040,m68881,m68882,fpu40,
    m68060,reserved8,reserved9,af10,af11,af12,af13,af14,private
  );
  (*
   * The AFB_FPU40 bit is set when a working 68040 FPU
   * is in the system.  If this bit is set and both the
   * AFB_68881 and AFB_68882 bits are not set, then the 68040
   * math emulation code has not been loaded and only 68040
   * FPU instructions are available.  This bit is valid *ONLY*
   * if the AFB_68040 bit is set.
   *)
  AttnFlagSet=SET OF AttnFlags;

(****** Selected flag definitions for Cache manipulation calls **********)

  CacheFlags=(
    enableI,            (* Enable instruction cache *)
    freezeI,            (* Freeze instruction cache *)
    cf2,
    clearI,             (* Clear instruction cache  *)
    ibe,                (* Instruction burst enable *)
    cf5,cf6,cf7,
    enableD,            (* 68030 Enable data cache  *)
    freezeD,            (* 68030 Freeze data cache  *)
    cf10,
    clearD,             (* 68030 Clear data cache	 *)
    dbe,                (* 68030 Data burst enable *)
    writeAllocate,      (* 68030 Write-Allocate mode
					       (must always be set!)	 *)
    cf14,cf15,cf16,cf17,cf18,cf19,cf20,cf21,cf22,cf23,cf24,cf25,cf26,
    cf27,cf28,cf29,
    enableE,         (* Master enable for external caches *)
				     (* External caches should track the *)
				     (* state of the internal caches *)
				     (* such that they do not cache anything *)
				     (* that the internal cache turned off *)
				     (* for. *)
    copyBack         (* Master enable for copyback caches *)
  );
  CacheFlagSet=SET OF CacheFlags;


  ExecBase=RECORD
    libNode:Library;        (* Standard library node *)
    softVer:CARDINAL;       (* kickstart release number (obs.) *)
    lowMemChkSum:INTEGER;   (* checksum of 68000 trap vectors *)
    chkBase:LONGCARD;       (* system base pointer complement *)
    coldCapture:ADDRESS;    (* coldstart soft capture vector *)
    coolCapture:ADDRESS;    (* coolstart soft capture vector *)
    warmCapture:ADDRESS;    (* warmstart soft capture vector *)
    sysStkUpper:ADDRESS;    (* system stack base   (upper bound) *)
    sysStkLower:ADDRESS;    (* top of system stack (lower bound) *)
    maxLocMem:LONGCARD;     (* top of chip memory *)
    debugEntry:ADDRESS;     (* global debugger entry point *)
    debugData:ADDRESS;      (* global debugger data segment *)
    alertData:ADDRESS;      (* alert data segment *)
    maxExtMem:ADDRESS;      (* top of extended mem, or null if none *)
    chkSum:CARDINAL;        (* for all of the above (minus 2) *)
    intVects:ARRAY IntFlags OF IntVector;
    thisTask:TaskPtr;       (* pointer to current task (readable) *)
    idleCount:LONGCARD;     (* idle counter *)
    dispCount:LONGCARD;     (* dispatch counter *)
    quantum:CARDINAL;       (* time slice quantum *)
    elapsed:CARDINAL;       (* current quantum ticks *)
    sysFlags:CARDINAL;      (* misc internal system flags *)
    idNestCnt:SHORTINT;     (* interrupt disable nesting count *)
    tdNestCnt:SHORTINT;     (* task disable nesting count *)          
    attnFlags:AttnFlagSet;  (* special attention flags (readable) *)
    attnResched:CARDINAL;   (* rescheduling attention *)
    resModules:ADDRESS;     (* resident module array pointer *)
    taskTrapCode:PROC;
    taskExceptCode:PROC;
    taskExitCode:PROC;
    taskSigAlloc:LONGSET;
    taskTrapAlloc:BITSET;
    (* private *)
    memList:List;
    resourceList:List;
    deviceList:List;
    intrList:List;
    libList:List;
    portList:List;
    taskReady:List;
    taskWait:List;
    softInts:ARRAY [0..4] OF SoftIntList;
    lastAlert:ARRAY [0..3] OF LONGINT;

	(* these next two variables are provided to allow
	** system developers to have a rough idea of the
	** period of two externally controlled signals --
	** the time between vertical blank interrupts and the
	** external line rate (which is counted by CIA A's
	** "time of day" clock).  In general these values
	** will be 50 or 60, and may or may not track each
	** other.  These values replace the obsolete AFB_PAL
	** and AFB_50HZ flags.
	*)

    vBlankFrequency:SHORTCARD;   (* (readable) *)
    powerSupplyFrequency:SHORTCARD;  (* (readable) *)

    semaphoreList:List;

	(* these next two are to be able to kickstart into user ram.
	** KickMemPtr holds a singly linked list of MemLists which
	** will be removed from the memory list via AllocAbs.  If
	** all the AllocAbs's succeeded, then the KickTagPtr will
	** be added to the rom tag list.
	*)
    kickMemPtr:ADDRESS;     (* ptr to queue of mem lists *)
    kickTagPtr:ADDRESS;     (* ptr to rom tag queue *)
    kickCheckSum:LONGCARD;	(* checksum for mem and tags *)

(****** V36 Exec additions start here **************************************)

    pad0:CARDINAL;          (* Private internal use *)
    launchPoint:LONGCARD;   (* Private to Launch/Switch *)
    ramLibPrivate:ADDRESS;
	(* The next ULONG contains the system "E" clock frequency,
	** expressed in Hertz.	The E clock is used as a timebase for
	** the Amiga's 8520 I/O chips. (E is connected to "02").
	** Typical values are 715909 for NTSC, or 709379 for PAL.
	*)
    eClockFrequency:LONGCARD;       (* (readable) *)
    cacheControl:CacheFlagSet;      (* Private to CacheControl calls *)
    taskId:LONGCARD;                (* Next available task ID *)            

    puddleSize:LONGCARD;
    poolThreshold:LONGCARD;
    publicPool:MinList;
    mmuLock:ADDRESS;                (* private *)
    reserved:ARRAY[0..11] OF BYTE;

(****** V39 Exec additions start here **************************************)
	(* The following list and data element are used
	 * for V39 exec's low memory handler...
	 *)
    memHandlers:MinList;        (* The handler list *)
    memHandler:ADDRESS;         (* Private! handler pointer *)
  END;

CONST
    dmaContinue=1;  (* Continuation flag for CachePreDMA *)
    dmaNoModify=2;  (* Set if DMA does not update memory *)
    
VAR
  execBase[4]:ExecBasePtr;

END ExecD.
