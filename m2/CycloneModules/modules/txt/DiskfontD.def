
(*
**	Cyclone Modula-2 Interface module:
**	$VER: diskfont.h 38.0 (18.6.92)
**	Includes Release 40.15
**
**	diskfont library definitions
**
**	(C) Copyright 1990 Robert R. Burns
**	    All Rights Reserved
**	(C) Copyright 1985-1993 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**      Interface module by Marcel Timmermans
**      (C) Copyright 1995-1996 Marcel Timmermans
**          All Rights Reserved
*)

DEFINITION MODULE DiskfontD;

(*$ Implementation- *)


FROM SYSTEM IMPORT ADDRESS,SHORTSET;
IMPORT ExecD,GraphicsD;

CONST
  maxFontPath  = 256;    (* including null terminator *)
  diskfontName = "diskfont.library";

TYPE
  FontContents = RECORD
   fileName : ARRAY [0..maxFontPath-1] OF CHAR;
   ySize    : CARDINAL;
   style    : SHORTSET;
   flags    : SHORTSET;
  END;

  TFontContentsPtr = POINTER TO TFontContents;
  TFontContents = RECORD
    fileName : ARRAY[0..maxFontPath-2] OF CHAR;
    tagCount : CARDINAL;
    (*
     *  if tfc_TagCount is non-zero, tfc_FileName is overlayed with
     *  Text Tags starting at:  (struct TagItem * )
     *      &tfc_FileName[MAXFONTPATH-(tfc_TagCount*sizeof(struct TagItem))]
     *)
    ySize : CARDINAL;
    style : SHORTSET;
    flags : SHORTSET;
  END;

CONST
  fchId     = 00F00H;  (* FontContentsHeader, then FontContents *)
  tfchId    = 00F02H;  (* FontContentsHeader, then TFontContents *)
  ofchID    = 00F03H;  (* FontContentsHeader, then TFontContents,
                          * associated with outline font *)

TYPE
  FontContentsHeaderPtr =  POINTER TO FontContentsHeader;
  FontContentsHeader = RECORD
    fileID : CARDINAL;         (* FCH_ID *)
    numEntries : CARDINAL;     (* the number of FontContents elements *)
    (* struct FontContents fch_FC[], or struct TFontContents fch_TFC[]; *)
  END;

CONST

  dfhId       = 00F80H;
  maxFontName = 32;     (* font name including ".font\0" *)

TYPE
  DiskFontHeaderPtr =  POINTER TO DiskFontHeader;
  DiskFontHeader = RECORD 
    (* the following 8 bytes are not actually considered a part of the  *)
    (* DiskFontHeader, but immediately preceed it. The NextSegment is   *)
    (* supplied by the linker/loader, and the ReturnCode is the code    *)
    (* at the beginning of the font in case someone runs it...          *)
    (*   ULONG dfh_NextSegment;                 \* actually a BPTR      *)
    (*   ULONG dfh_ReturnCode;                  \* MOVEQ #0,D0 : RTS    *)
    (* here then is the official start of the DiskFontHeader...         *)
    df       : ExecD.Node;     (* node to link disk fonts *)
    fileID   : CARDINAL;       (* DFH_ID *)
    revision : CARDINAL;       (* the font revision *)
    segment  : ExecD.BPTR;     (* the segment address when loaded *)
    name     : ARRAY[0..maxFontName-1] OF CHAR; (* the font name (null terminated) *)
    tf       : GraphicsD.TextFont; (* loaded TextFont structure *)
  END;


  AvailFontTypes=(
   memory,disk,scaled,bitmap,af3,af4,af5,af6,af7,af8,
   af9,af10,af11,af12,af13,af14,af15,tagged);  (* return TAvailFont *)

  AvailFontSet=SET OF AvailFontTypes;

TYPE
  AvailFontPtr =  POINTER TO AvailFont;
  AvailFont = RECORD
    type : AvailFontSet;           (* MEMORY, DISK, or SCALED *)
    attr : GraphicsD.TextAttr;     (* text attributes for font *)
  END;

  TAvailFontPtr =  POINTER TO TAvailFont;
  TAvailFont = RECORD
    type : AvailFontSet;          (* MEMORY, DISK, or SCALED *)
    attr : GraphicsD.TTextAttr;   (* text attributes for font *)
  END;

  AvailFontsHeaderPtr =  POINTER TO AvailFontsHeader;
  AvailFontsHeader = RECORD
    numEntries : CARDINAL;      (* number of AvailFont elements *)
   (* struct AvailFonts afh_AF[], or struct TAvailFonts afh_TAF[]; *)
   (* af: ARRAY[0..numEntries-1] OF AvailFont or 
     taf: ARRAY[0..numEntries-1] OF TAvailFont *)
  END;

(* ---------------------------------------------------------------- *)

CONST
   tagUser=LONGCARD(080000000H);
(* Level 0 entries never appear in the .otag tag list, but appear in font
 * specifications *)
  level0 =      tagUser;
(* Level 1 entries are required to exist in the .otag tag list *)
  level1 =      tagUser + 1000H;
(* Level 2 entries are optional typeface metric tags *)
  level2 =      tagUser + 2000H;
(* Level 3 entries are required for some OT_Engines *)
  level3 =      tagUser + 3000H;
(* Indirect entries are at (tag address + data offset) *)
  indirect =    08000H;


(********************************************************************)
(* font specification and inquiry tags *)

(* !  tags flagged with an exclaimation mark are valid for
 *    specification.
 *  ? tags flagged with a question mark are valid for inquiry
 *
 * fixed binary numbers are encoded as 16 bits of integer and
 * 16 bits of fraction.  Negative values are indicated by twos
 * complement of all 32 bits.
 *)

(* !  OT_DeviceDPI specifies the target device dots per inch -- X DPI is
 *    in the high word, Y DPI in the low word. *)
  deviceDPI = level0 + 01H;     (* (== TA_DeviceDPI *)

(* !  OT_DotSize specifies the target device dot size as a percent of
 *    it's resolution-implied size -- X percent in high word, Y percent
 *    in low word. *)
  dotSize = level0 + 02H;

(* !  OT_PointHeight specifies the requested point height of a typeface,
 *    specifically, the height and nominal width of the em-square.
 *    The point referred to here is 1/72".  It is encoded as a fixed
 *    binary number. *)
  pointHeight = level0 + 08H;

(* !  OT_SetFactor specifies the requested set width of a typeface.
 *    It distorts the width of the em-square from that specified by
 *    OT_PointHeight.  To compensate for a device with different
 *    horizontal and vertical resolutions, OT_DeviceDPI should be used
 *    instead.  For a normal aspect ratio, set to 1.0 (encoded as
 *    0x00010000.  This is the default value. *)
  setFactor = level0 + 09H;

(* !  OT_Shear... specifies the Sine and Cosine of the vertical stroke
 *    angle, as two fixed point binary fractions.  Both must be specified:
 *    first the Sine and then the Cosine.  Setting the sine component
 *    changes the Shear to an undefined value, setting the cosine
 *    component completes the Shear change to the new composite value.
 *    For no shear, set to 0.0, 1.0 (encoded as 000000000, 0x00010000).
 *    This is the default value. *)
  shearSin = level0 + 0AH;
  shearCos = level0 + 0BH;

(* !  OT_Rotate... specifies the Sine and Cosine of the baselin rotation
 *    angle, as two fixed point binary fractions.  Both must be specified:
 *    first the Sine and then the Cosine.  Setting the sine component
 *    changes the Shear to an undefined value, setting the cosine
 *    component completes the Shear change to the new composite value.
 *    For no shear, set to 0.0, 1.0 (encoded as 0x00000000, 0x00010000).
 *    This is the default value. *)
  rotateSin = level0 + 0CH;
  rotateCos = level0 + 0DH;

(* !  OT_Embolden... specifies values to algorithimically embolden -- or,
 *    when negative, lighten -- the glyph.  It is encoded as a fixed point
 *    binary fraction of the em-square.  The X and Y components can be
 *    changed indendently.  For normal characters, set to 0.0, 0.0
 *    (encoded as 0x00000000, 0x00000000).  This is the default value. *)
  emboldenX = level0 + 0EH;
  emboldenY = level0 + 0FH;

(* !  OT_PointSize is an old method of specifying the point size,
 *    encoded as (points * 16). *)
  pointSize = level0 + 010H;

(* !  OT_GlyphCode specifies the glyph (character) code to use with
 *    subsequent operations.  For example, this is the code for an
 *    OT_Glyph inquiry *)
  glyphCode = level0 + 011H;

(* !  OT_GlyphCode2 specifies the second glyph code.  For example,
 *    this is the right glyph of the two glyphs of an OT_KernPair
 *    inquiry *)
  glyphCode2 = level0 + 012H;

(* !  OT_GlyphWidth specifies a specific width for a glyph.
 *    It sets a specific escapement (advance) width for subsequent
 *    glyphs.  It is encoded as a fixed binary fraction of the em-square.
 *    To revert to using the font-defined escapement for each glyph, set
 *    to 0.0 (encoded as 0x00000000).  This is the default value. *)
  glyphWidth = level0 + 013H;

(* !  OT_OTagPath and
 * !  OT_OTagList specify the selected typeface.  Both must be specified:
 *    first the Path and then the List.  Setting the path name changes
 *    changes the typeface to an undefined value, providing the List
 *    completes the typeface selection to the new typeface.  OTagPath
 *    is the null terminated full file path of the .otag file associated
 *    with the typeface.  OTagList is a memory copy of the processed
 *    contents of that .otag file (i.e. with indirections resolved).
 *    There are no default values for the typeface. *)
  oTagPath = level0 + indirect + 014H;
  oTagList = level0 + indirect + 015H;

(*  ? OT_GlyphMap supplies a read-only struct GlyphMap pointer that
 *    describes a bitmap for a glyph with the current attributes. *)
  glyphMap = level0 + indirect + 020H;

(*  ? OT_WidthList supplies a read-only struct MinList of struct
 *    GlyphWidthEntry nodes for glyphs that are defined from GlyphCode
 *    to GlyphCode2, inclusive.  The widths are represented as fixed
 *    binary fractions of the em-square, ignoring any effect of
 *    SetFactor or GlyphWidth.  A width would need to be converted to
 *    a distance along the baseline in device units by the
 *    application. *)
  widthList = level0 + indirect + 021H;

(*  ? OT_...KernPair supplies the kern adjustment to be added to the
 *    current position after placement of the GlyphCode glyph and
 *    before placement of the GlyphCode2 glyph.  Text kern pairs are
 *    for rendering body text.  Display kern pairs are generally
 *    tighter values for display (e.g. headline) purposes.  The
 *    adjustment is represented as a fixed binary fraction of the
 *    em-square, ignoring any effect of SetFactor.  This number would
 *    need to be converted to a distance along the baseline in device
 *    units by the application. *)
  textKernPair   = level0 + indirect + 022H;
  designKernPair = level0 + indirect + 023H;

(*  ? OT_Underlined is an unsigned word which is used to request
 *    algorithimic underlining for the engine when rendering the glyph.
 *    Bullet.library currently does not support this tag, though it
 *    may be used by other engines in the future.  The default for
 *    any engine which supports this tag must be OTUL_None.  Engines which
 *    do not support this tag should return an appropriate OTERR value.
 *
 *    As of V39, diskfont.library will request underlining if specified
 *    in the TextAttr, or TTextAttr passed to OpenDiskFont().  Diskfont
 *    will first request Broken underlining (like the Text() function
 *    does when SetSoftStyle() is used), and then Solid underlining if
 *    the engine returns an error.  If the engine returns an error for
 *    both, then diskfont.library attempts to find, or create the best
 *    non-underlined font that it can. *)
  underLined = level0 + 024H;

  otulNone           = 0;
  otulSolid          = 1;
  otulBroken         = 2;
  otulDoubleSolid    = 3;
  outlDoubleBroken = 4;

(*  ? OT_StrikeThrough is a boolean which is used to request
 *    algorithimic strike through when rendering the glyph.
 *    Bullet.library currently does not support this tag, though it
 *    may be used by other engines in the future.  The default for
 *    any engined which supports this tag must be FALSE.  Engines which
 *    do not support this tag should return an appropriate OTERR value. *)
  strikeThrough = level0 + 025H;


(********************************************************************)
(* .otag tags *)

(* suffix for files in FONTS: that contain these tags *)
  suffix = ".otag";

(* OT_FileIdent both identifies this file and verifies its size.
 * It is required to be the first tag in the file. *)
  fileIdent = level1 + 01H;

(* OT_Engine specifies the font engine this file is designed to use *)
  engine  = level1 + indirect + 02H;
  eBullet = "bullet";

(* OT_Family is the family name of this typeface *)
  family = level1 + indirect + 03H;

(* The name of this typeface is implicit in the name of the .otag file *)
(* OT_BName is used to find the bold variant of this typeface *)
  bName = level2 + indirect + 05H;
(* OT_IName is used to find the italic variant of this typeface *)
  iName = level2 + indirect + 06H;
(* OT_BIName is used to find the bold italic variant of this typeface *)
  biName = level2 + indirect + 07H;

(* OT_SymSet is used to select the symbol set that has the OT_YSizeFactor
 * described here.  Other symbol sets might have different extremes *)
  symbolSet = level1 + 010H;

(* OT_YSizeFactor is a ratio to assist in calculating the Point height
 * to BlackHeight relationship -- high word: Point height term, low
 * word: Black height term -- pointSize = ysize*<high>/<low> *)
  ySizeFactor = level1 + 011H;

(* OT_SpaceWidth specifies the width of the space character relative
 * to the character height *)
  spaceWidth = level2 + 012H;

(* OT_IsFixed is a boolean indicating that all the characters in the
 * typeface are intended to have the same character advance *)
  isFixed = level2 + 013H;

(* OT_SerifFlag is a boolean indicating if the character has serifs *)
  serifFlag = level1 + 014H;

(* OT_StemWeight is an unsigned byte indicating the weight of the character *)
  stemWeight =  level1 + 015H;

  sUltraThin  = 8;   (*   0- 15 *)
  sExtraThin  = 24;  (*  16- 31 *)
  sThin       = 40;  (*  32- 47 *)
  sExtraLight = 56;  (*  48- 63 *)
  sLight      = 72;  (*  64- 79 *)
  sDemiLight  = 88;  (*  80- 95 *)
  sSemiLight  = 104; (*  96-111 *)
  sBook       = 120; (* 112-127 *)
  sMedium     = 136; (* 128-143 *)
  sSemiBold   = 152; (* 144-159 *)
  sDemiBold   = 168; (* 160-175 *)
  sBold       = 184; (* 176-191 *)
  sExtraBold  = 200; (* 192-207 *)
  sBlack      = 216; (* 208-223 *)
  sExtraBlack = 232; (* 224-239 *)
  sUltraBlack = 248; (* 240-255 *)

(* OT_SlantStyle is an unsigned byte indicating the font posture *)
  slantStyle = level1 + 016H;
  sUpright    = 0;
  sItalic     = 1;       (* Oblique, Slanted, etc. *)
  sLeftItalic = 2;       (* Reverse Slant *)

(* OT_HorizStyle is an unsigned byte indicating the appearance width *)
  horizStyle       = level1 + 017H;
  hUltraCompressed = 16;     (*   0- 31 *)
  hExtraCompressed = 48;     (*  32- 63 *)
  hCompressed      = 80;     (*  64- 95 *)
  hCondensed       = 112;    (*  96-127 *)
  hNormal          = 144;    (* 128-159 *)
  hSemiExpanded    = 176;    (* 160-191 *)
  hExpanded        = 208;    (* 192-223 *)
  hExtraExpanded   = 240;    (* 224-255 *)

(* OT_SpaceFactor specifies the width of the space character relative
 * to the character height *)
  spaceFactor = level2 + 018H;

(* OT_InhibitAlgoStyle indicates which ta_Style bits, if any, should
 * be ignored even if the font does not already have that quality.
 * For example, if FSF_BOLD is set and the typeface is not bold but
 * the user specifies bold, the application or diskfont library is
 * not to use OT_Embolden to achieve a bold result. *)
  inhibitAlgoStyle = level2 + 019H;

(* OT_AvailSizes is an indirect pointer to sorted UWORDs, 0th is count *)
  availSizes    = level1 + indirect + 020H;
  maxAvailSizes = 20;      (* no more than 20 sizes allowed *)

(* OT_SpecCount is the count number of parameters specified here *)
  specCount = level1 + 0100H;

(* Specs can be created as appropriate for the engine by ORing in the
 * parameter number (1 is first, 2 is second, ... up to 15th) *)
  spec = level1 + 0100H;
(* OT_Spec1 is the (first) parameter to the font engine to select
 * this particular typeface *)
  spec1 = level1 + 0101H;


(* ---------------------------------------------------------------- *)
TYPE
(*
 *      glyph.h -- structures for glyph libraries
 *)

(* A GlyphEngine must be acquired via OpenEngine and is read-only *)
  GlyphEnginePtr =  POINTER TO GlyphEngine;
  GlyphEngine = RECORD
    library   : ExecD.LibraryPtr; (* engine library *)
    name      : ADDRESS;    (* library basename: e.g. "bullet" *)
    (* private library data follows... *)
  END;

  FIXED = LONGINT;          (* 32 bit signed w/ 16 bits of fraction *)

  GlyphMapPtr =  POINTER TO GlyphMap;
  GlyphMap  = RECORD
    bmModulo    : CARDINAL;  (* # of bytes in row: always multiple of 4 *)
    bmRows      : CARDINAL;  (* # of rows in bitmap *)
    blackLeft   : CARDINAL;  (* # of blank pixel columns at left *)
    blackTop    : CARDINAL;  (* # of blank rows at top *)
    blackWidth  : CARDINAL;  (* span of contiguous non-blank columns *)
    blackHeight : CARDINAL;  (* span of contiguous non-blank rows *)
    xOrigin     : FIXED;     (* distance from upper left corner of bitmap *)
    yOrigin     : FIXED;     (*   to initial CP, in fractional pixels *)
    x0          : CARDINAL;  (* approximation of XOrigin in whole pixels *)
    y0          : CARDINAL;  (* approximation of YOrigin in whole pixels *)
    x1          : CARDINAL;  (* approximation of XOrigin + Width *)
    y1          : CARDINAL;  (* approximation of YOrigin + Width *)
    width       : FIXED;     (* character advance, as fraction of em width *)
    bitMap      : ADDRESS;   (* actual glyph bitmap *)
  END;

  GlyphWidthEntryPtr =  POINTER TO GlyphWidthEntry;
  GlyphWidthEntry = RECORD 
    node   : ExecD.MinNode;  (* on list returned by OT_WidthList inquiry *)
    code   : CARDINAL;       (* entry's character code value *)
    width  : FIXED;          (* character advance, as fraction of em width *)
  END;

(* ---------------------------------------------------------------- *)
CONST
(*
 *      oterrors.h -- error results from outline libraries
 *)

(* PRELIMINARY *)
  errFailure          =-1;       (* catch-all for error *)
  errSuccess          = 0;       (* no error *)
  errBadTag           = 1;       (* inappropriate tag for function *)
  errUnknownTag       = 2;       (* unknown tag for function *)
  errBadData          = 3;       (* catch-all for bad tag data *)
  errNoMemory         = 4;       (* insufficient memory for operation *)
  errNoFace           = 5;       (* no typeface currently specified *)
  errBadFace          = 6;       (* typeface specification problem *)
  errNoGlyph          = 7;       (* no glyph specified *)
  errBadGlyph         = 8;       (* bad glyph code or glyph range *)
  errNoShear          = 9;       (* shear only partially specified *)
  errNoRotate         = 10;      (* rotate only partially specified *)
  errTooSmall         = 11;      (* typeface metrics yield tiny glyphs *)
  errUnknownGlyph     = 12;      (* glyph not known by engine *)


END DiskfontD.
