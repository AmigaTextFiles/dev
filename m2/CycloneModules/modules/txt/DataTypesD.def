(*$ Implementation-*)
DEFINITION MODULE DataTypesD;
(*   11.12.96. Stefan Tiemann for Cyclone, converted from
**	datatypes.h 39.6 (22.4.93)
**	Includes Release 40.15
**
*)

IMPORT DD:DosD;
IMPORT ED: ExecD;
IMPORT IFF:IFFParseD;
IMPORT ID:IntuitionD;
IMPORT GD:GraphicsD;
IMPORT PRT:Printer;
IMPORT UD:UtilityD;
FROM SYSTEM IMPORT ADDRESS,BITSET,CAST,LONGSET;

(*****************************************************************************)
CONST
 dataTypesName="datatypes.library";

(*****************************************************************************)
CONST
 idDTYP=CAST(LONGCARD,'DTYP');

(*****************************************************************************)
CONST
 idDTHD=CAST(LONGCARD,'DTHD');

TYPE
 StrPtr= ADDRESS;
 DataTypeHeader=RECORD
  name:StrPtr;				(* Descriptive name of the data type *)
  baseName:StrPtr;				(* Base name of the data type *)
  pattern:StrPtr;				(* Match pattern for file name. *)
  mask:ADDRESS;				(* Comparision mask *)
  groupID:LONGCARD;				(* Group that the DataType is in *)
  id:LONGCARD;				(* ID for DataType (same as IFF FORM type) *)
  maskLen:INTEGER;				(* Length of comparision mask *)
  pad:INTEGER;				(* Unused at present (must be 0) *)
  flags:CARDINAL;				(* Flags *)
  priority:CARDINAL;				(* Priority *)
 END;
 DataTypeHeaderPtr= POINTER TO DataTypeHeader;

CONST
 dthSize=SIZE(DataTypeHeader);

(*****************************************************************************)

(* Basic type *)
 dtfTypeMask=BITSET{0..3};
 dtfBinary=BITSET{};
 dtfASCII=BITSET{0};
 dtfIFF=BITSET{1};
 dtfMisc=BITSET{0,1};

(* Set if case is important *)
 dtfCase=BITSET{4};

(* Reserved for system use *)
 dtfSystem1=BITSET{12};

(*****************************************************************************
 *
 * GROUP ID and ID
 *
 * This is used for filtering out objects that you don't want.	For
 * example, you could make a filter for the ASL file requester so
 * that it only showed the files that were pictures, or even to
 * narrow it down to only show files that were ILBM pictures.
 *
 * Note that the Group ID's are in lower case, and always the first
 * four characters of the word.
 *
 * For ID's; If it is an IFF file, then the ID is the same as the
 * FORM type.  If it isn't an IFF file, then the ID would be the
 * first four characters of name for the file type.
 *
 *****************************************************************************)

(* System file, such as; directory, executable, library, device, font, etc. *)
 gIdSystem	=CAST(LONGCARD,'syst');

(* Formatted or unformatted text *)
 gIdText	=CAST(LONGCARD,'text');

(* Formatted text with graphics or other DataTypes *)
 gIdDocument	=CAST(LONGCARD,'docu');

(* Sound *)
 gIdSound	=CAST(LONGCARD,'soun');

(* Musical instruments used for musical scores *)
 gIdInstrument	=CAST(LONGCARD,'inst');

(* Musical score *)
 gIdMusic	=CAST(LONGCARD,'musi');

(* Still picture *)
 gIdPicture =CAST(LONGCARD,'pict');

(* Animated picture *)
 gIdAnimation =CAST(LONGCARD,'anim');

(* Animation with audio track *)
 gIdMovie	=CAST(LONGCARD,'movi');

(*****************************************************************************)

(* A code chunk contains an embedded executable that can be loaded
 * with InternalLoadSeg. *)
 idCODE =CAST(LONGCARD,'DTCD');

TYPE
(* DataTypes comparision hook context (Read-Only).  This is the
 * argument that is passed to a custom comparision routine. *)
 DTHookContext=RECORD
    (* Libraries that are already opened for your use *)
  sysBase:ED.LibraryPtr;
  dosBase:ED.LibraryPtr;
  iffParseBase:ED.LibraryPtr;
  utilityBase:ED.LibraryPtr;
    (* File context *)
  lock:DD.BPTR;			(* Lock on the file *)
  fib:DD.FileInfoBlockPtr;	(* Pointer to a FileInfoBlock *)
  fileHandle:DD.BPTR;		(* Pointer to the file handle (may be NULL) *)
  iff: IFF.IFFHandlePtr;		(* Pointer to an IFFHandle (may be NULL) *)
  buffer:StrPtr;			(* Buffer *)
  bufferLength:LONGCARD;		(* Length of the buffer *)
 END;
 DTHookContextPtr= POINTER TO DTHookContext;
(*****************************************************************************)
CONST
 idTOOL =CAST(LONGCARD,'DTTL');

TYPE
 Tool=RECORD
    which:CARDINAL;				(* Which tool is this *)
    flags:BITSET;				(* Flags *)
    program:StrPtr;				(* Application to use *)
 END;
 ToolPtr= POINTER TO Tool;

CONST
 tSize=SIZE(Tool);

(* defines for tn_Which *)
 twInfo= 1;
 twBrows=	2;
 twEdit= 3;
 twPrint=	4;
 twMail= 5;

(* defines for tn_Flags *)
 tfLaunchMask=BITSET{0..3};
 tfShell=BITSET{0};
 tfWorkbench=BITSET{1};
 tfRx=BITSET{0,1};


(*****************************************************************************)

 idTAGS=CAST(LONGCARD,'DTTG');

(*****************************************************************************)
TYPE
 DataType=RECORD
  node1:ED.Node;			(* Reserved for system use *)
  node2:ED.Node;			(* Reserved for system use *)
  header:DataTypeHeaderPtr;	(* Pointer to the DataTypeHeader *)
  toolList:ED.List;			(* List of tool nodes *)
  functionName:StrPtr;		(* Name of comparision routine *)
  attrList:UD.TagItemPtr;	(* Object creation tags *)
  length:LONGCARD;			(* Length of the memory block *)
 END;
 DataTypePtr= POINTER TO DataType;

CONST
 dtnSize=SIZE(DataType);

(*****************************************************************************)
TYPE
 ToolNode=RECORD
    node:ED.Node;			(* Embedded node *)
    tool:Tool;				(* Embedded tool *)
    length:LONGCARD;		(* Length of the memory block *)
 END;
 ToolNodePtr=POINTER TO ToolNode;

CONST
 tnSize=SIZE(ToolNode);

(*****************************************************************************)

 idNAME	=CAST(LONGCARD,'NAME');

(*****************************************************************************)

(* text ID's *)
 dtErrorUnknownDataType= 		2000;
 dtErrorCouldntSave=			2001;
 dtErrorCouldntOpen=			2002;
 dtErrorCouldntSendMessage=		2003;

(* new for V40 *)
 dtErrorCouldntOpenClipboard=		2004;
 dtErrorReserved=    			2005;
 dtErrorUnknownCompression=		2006;
 dtErrorNotEnoughData=			2007;
 dtErrorInvalidData=			2008;

(* Offset for types *)
 dtMsgTypeOffset=    			2100;

(*****************************************************************************)






(*
**  datatypesclass.h 39.8 (17.3.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType objects.
**
*)


(*****************************************************************************)
CONST
 dataTypesClass=	"datatypesclass";

(*****************************************************************************)

	dtaDummy		=(UD.tagUser+1000H);

(* Generic attributes *)
	dtaTextAttr		=(dtaDummy+10);
	(* (struct TextAttr * ) Pointer to the default TextAttr to use for
	 * the text within the object. *)

	dtaTopVert		=(dtaDummy+11);
	(* (LONG) Current top vertical unit *)

	dtaVisibleVert		=(dtaDummy+12);
	(* (LONG) Number of visible vertical units *)

	dtaTotalVert		=(dtaDummy+13);
	(* (LONG) Total number of vertical units *)

	dtaVertUnit		=(dtaDummy+14);
	(* (LONG) Number of pixels per vertical unit *)

	dtaTopHoriz		=(dtaDummy+15);
	(* (LONG) Current top horizontal unit *)

	dtaVisibleHoriz	=(dtaDummy+16);
	(* (LONG)  Number of visible horizontal units *)

	dtaTotalHoriz		=(dtaDummy+17);
	(* (LONG) Total number of horizontal units *)

	dtaHorizUnit		=(dtaDummy+18);
	(* (LONG) Number of pixels per horizontal unit *)

	dtaNodeName		=(dtaDummy+19);
	(* (UBYTE * ) Name of the current element within the object. *)

	dtaTitle		=(dtaDummy+20);
	(* (UBYTE * ) Title of the object. *)

	dtaTriggerMethods	=(dtaDummy+21);
	(* (struct DTMethod * ) Pointer to a NULL terminated array of
	 * supported trigger methods. *)

	dtaData		=(dtaDummy+22);
	(* (APTR) Object specific data. *)

	dtaTextFont		=(dtaDummy+23);
	(* (struct TextFont * ) Default font to use for text within the
	 * object. *)

	dtaMethods		=(dtaDummy+24);
	(* (ULONG * ) Pointer to a ~0 terminated array of supported
	 * methods. *)

	dtaPrinterStatus	=(dtaDummy+25);
	(* (LONG) Printer error message.  Error numbers are defined in
	 * <devices/printer.h> *)

	dtaPrinterProc		=(dtaDummy+26);
	(* PRIVATE (struct Process * ) Pointer to the print process. *)

	dtaLayoutProc		=(dtaDummy+27);
	(* PRIVATE (struct Process * ) Pointer to the layout process. *)

	dtaBusy		=(dtaDummy+28);
	(* Used to turn the applications' busy pointer off and on *)

	dtaSync		=(dtaDummy+29);
	(* Used to indicate that new information has been loaded into
	 * an object.  This is for models that cache the dtaTopVert-
	 * like tags *)

	dtaBaseName		=(dtaDummy+30);
	(* The base name of the class *)

	dtaGroupID		=(dtaDummy+31);
	(* Group that the object must belong in *)

	dtaErrorLevel		=(dtaDummy+32);
	(* Error level *)

	dtaErrorNumber		=(dtaDummy+33);
	(* datatypes.library error number *)

	dtaErrorString		=(dtaDummy+34);
	(* Argument for datatypes.library error *)

	dtaConductor		=(dtaDummy+35);
	(* New for V40. (UBYTE * ) specifies the name of the
	 * realtime.library conductor.	Defaults to "Main". *)

	dtaControlPanel	=(dtaDummy+36);
	(* New for V40. (BOOL) Indicate whether a control panel should be
	 * embedded within the object (in the animation datatype, for
	 * example).  Defaults to TRUE. *)

	dtaImmediate		=(dtaDummy+37);
	(* New for V40. (BOOL) Indicate whether the object should
	 * immediately begin playing.  Defaults to FALSE. *)

	dtaRepeat		=(dtaDummy+38);
	(* New for V40. (BOOL) Indicate that the object should repeat
	 * playing.  Defaults to FALSE. *)


(* DTObject attributes *)
	dtaName		=(dtaDummy+100);
	dtaSourceType	=(dtaDummy+101);
	dtaHandle		=(dtaDummy+102);
	dtaDataType	=(dtaDummy+103);
	dtaDomain		=(dtaDummy+104);

(* DON'T USE THE FOLLOWING FOUR TAGS.  USE THE CORRESPONDING TAGS IN
 * <intuition/gadgetclass.h> *)
	dtaLeft		=(dtaDummy+105);
	dtaTop		=(dtaDummy+106);
	dtaWidth		=(dtaDummy+107);
	dtaHeight		=(dtaDummy+108);

	dtaObjName		=(dtaDummy+109);
	dtaObjAuthor		=(dtaDummy+110);
	dtaObjAnnotation	=(dtaDummy+111);
	dtaObjCopyright	=(dtaDummy+112);
	dtaObjVersion		=(dtaDummy+113);
	dtaObjectID		=(dtaDummy+114);
	dtaUserData		=(dtaDummy+115);
	dtaFrameInfo		=(dtaDummy+116);

(* DON'T USE THE FOLLOWING FOUR TAGS.  USE THE CORRESPONDING TAGS IN
 * <intuition/gadgetclass.h> *)
	dtaRelRight		=(dtaDummy+117);
	dtaRelBottom		=(dtaDummy+118);
	dtaRelWidth		=(dtaDummy+119);
	dtaRelHeight		=(dtaDummy+120);

	dtaSelectDomain	=(dtaDummy+121);
	dtaTotalPVert		=(dtaDummy+122);
	dtaTotalPHoriz		=(dtaDummy+123);
	dtaNominalVert		=(dtaDummy+124);
	dtaNominalHoriz	=(dtaDummy+125);

(* Printing attributes *)
	dtaDestCols		=(dtaDummy+400);
	(* (LONG) Destination X width *)

	dtaDestRows		=(dtaDummy+401);
	(* (LONG) Destination Y height *)

	dtaSpecial		=(dtaDummy+402);
	(* (UWORD) Option flags *)

	dtaRastPort		=(dtaDummy+403);
	(* (struct RastPort * ) RastPort to use when printing. (V40) *)

	dtaARexxPortName	=(dtaDummy+404);
	(* (STRPTR) Pointer to base name for ARexx port (V40) *)


(*****************************************************************************)

	dtstRam=		1;
	dtstFile=		2;
	dtstClipboard=		3;
	dtstHotlink=		4;

(*****************************************************************************)
TYPE
(* Attached to the Gadget.SpecialInfo field of the gadget.  Don't access directly,
 * use the Get/Set calls instead.
 *)
 DTSpecialInfo=RECORD
    lock: ED.SignalSemaphore;	(* Locked while in DoAsyncLayout() *)
    flags:LONGSET;
    topVert:LONGINT;	(* Top row (in units) *)
    visVert:LONGINT;	(* Number of visible rows (in units) *)
    totVert:LONGINT;	(* Total number of rows (in units) *)
    oTopVert:LONGINT;	(* Previous top (in units) *)
    vertUnit:LONGINT;	(* Number of pixels in vertical unit *)

    topHoriz:LONGINT;	(* Top column (in units) *)
    visHoriz:LONGINT;	(* Number of visible columns (in units) *)
    totHoriz:LONGINT;	(* Total number of columns (in units) *)
    oTopHoriz:LONGINT;	(* Previous top (in units) *)
    horizUnit:LONGINT;	(* Number of pixels in horizontal unit *)
 END;
 DTSpecialInfoPtr=POINTER TO DTSpecialInfo;

CONST
// Bitnumbers for DTSpecialInfo.flags
(* Object is in layout processing *)
	dtsiLayout=0;

(* Object needs to be layed out *)
	dtsiNEWSIZE=1;

	dtsiDragging=2;
	dtsiDragSelect=3;

	dtsiHighlight=4;

(* Object is being printed *)
	dtsiPrinting=5;

(* Object is in layout process *)
	dtsiLayoutProc=6;

(*****************************************************************************)
TYPE
 DTMethod=RECORD
    label:StrPtr;
    command:StrPtr;
    method:LONGCARD;
 END;
 DTMethodPtr=POINTER TO DTMethod;

(*****************************************************************************)
CONST
	dtmDummy		=0600H;

(* Inquire what environment an object requires *)
	dtmFrameBox		=0601H;

(* Same as GM_LAYOUT except guaranteed to be on a process already *)
	dtmProcLayout		=0602H;

(* Layout that is occurring on a process *)
	dtmAsyncLayout		=0603H;

(* When a RemoveDTObject() is called *)
	dtmRemoveDTObject	=0604H;

	dtmSelect		=0605H;
	dtmClearSelected	=0606H;

	dtmCopy		=0607H;
	dtmPrint		=0608H;
	dtmAbortPrint		=0609H;

	dtmNewMember		=0610H;
	dtmDisposeMember	=0611H;

	dtmGoto		=0630H;
	dtmTrigger 	=0631H;

	dtmObtainDrawInfo	=0640H;
	dtmDraw		=0641H;
	dtmReleaseDrawInfo	=0642H;

	dtmWrite		=0650H;

TYPE
(* Used to ask the object about itself *)
 FrameInfo=RECORD
    propertyFlags:GD.PropertyFlagSet;		(* DisplayInfo (graphics/displayinfo.h) *)
    resolution:GD.Point;		(* DisplayInfo *)

    redBits:SHORTCARD;
    greenBits:SHORTCARD;
    blueBits:SHORTCARD;

    dimensions:RECORD
      width:LONGCARD;
	 height:LONGCARD;
	 depth:LONGCARD;
    END;

    screen:ID.ScreenPtr;
    colorMap:GD.ColorMapPtr;

    flags:LONGSET;
END;
FrameInfoPtr=POINTER TO FrameInfo;
CONST
// Bitnumbers for FrameInfo.flags;
	fiScalable= 0;
	fiScrollable=1;
	fiRemappable=2;

TYPE
(* DTM_REMOVEDTOBJECT, DTM_CLEARSELECTED, DTM_COPY, DTM_ABORTPRINT *)
 dtGeneral=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
 END;
 dtGeneralPtr= POINTER TO dtGeneral;

(* DTM_SELECT *)
 dtSelect=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    select:GD.Rectangle;
 END;
 dtSelectPtr= POINTER TO dtSelect;

(* DTM_FRAMEBOX *)
 dtFrameBox=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    contentsInfo:FrameInfoPtr;	(* Input *)
    frameInfo:FrameInfoPtr;		(* Output *)
    sizeFrameInfo:LONGCARD;
    frameFlags:LONGSET;
 END;
 dtFrameBoxPtr=POINTER TO dtFrameBox;
CONST
//Bitnumber for dtFrameBox.frameFlags
 frameSpecify=0;	(* Make do with the dimensions of FrameBox provided. *)

TYPE
(* DTM_GOTO *)
 dtGoto=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    nodeName:StrPtr;		(* Node to goto *)
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtGotoPtr= POINTER TO dtGoto;

(* DTM_TRIGGER *)
 dtTrigger=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    function:LONGCARD;
    data:ADDRESS;
 END;

CONST
	stmPause=	1;
	stmPlay=	2;
	stmContents=	3;
	stmIndex=		4;
	stmRetrace=	5;
	stmBrowsePrev=	6;
	stmBrowseNext=	7;

	stmNextField=	8;
	stmPrevField=  9;
	stmActivateField=	10;

	stmCommand=	11;

(* New for V40 *)
	stmRewind=	12;
	stmFastForward=13;
	stmStop=		14;
	stmResume=	15;
	stmLocate=		16;

TYPE
(* DTM_PRINT *)
 dtPrint=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;		(* Gadget information *)
    pio:PRT.PrinterIOPtr;		(* Printer IO request *)
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtPrintPtr=POINTER TO dtPrint;

(* DTM_DRAW *)
 dtDraw=RECORD
    methodID:LONGCARD;
    rPort:GD.RastPortPtr;
    left:LONGINT;
    top:LONGINT;
    width:LONGINT;
    height:LONGINT;
    topHoriz:LONGINT;
    topVert:LONGINT;
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtDrawPtr=POINTER TO dtDraw;

(* DTM_WRITE *)
 dtWrite=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;		(* Gadget information *)
    fileHandle:DD.BPTR;			(* File handle to write to *)
    mode:LONGCARD;
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;

CONST
(* Save data as IFF data *)
	dtwmIIFF=0;

(* Save data as local data format *)
	dtwmRaw=1;


(*
**   pictureclass.h 39.5 (28.4.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType picture objects.
*)

CONST
(*****************************************************************************)

 pictureDTClass=	"picture.datatype";

(*****************************************************************************)

(* Picture attributes *)
	pdtaModeID		=(dtaDummy + 200);
	(* Mode ID of the picture *)

	pdtaBitMapHeader	=(dtaDummy + 201);

	pdtaBitMap		=(dtaDummy + 202);
	(* Pointer to a class-allocated bitmap, that will end
	 * up being freed by picture.class when DisposeDTObject()
	 * is called *)

	pdtaColorRegisters	=(dtaDummy + 203);
	pdtaCRegs		=(dtaDummy + 204);
	pdtaGRegs		=(dtaDummy + 205);
	pdtaColorTable		=(dtaDummy + 206);
	pdtaColorTable2	=(dtaDummy + 207);
	pdtaAllocated		=(dtaDummy + 208);
	pdtaNumColors		=(dtaDummy + 209);
	pdtaNumAlloc		=(dtaDummy + 210);

	pdtaRemap		=(dtaDummy + 211);
	(* Boolean : Remap picture (defaults to TRUE) *)

	pdtaScreen		=(dtaDummy + 212);
	(* Screen to remap to *)

	pdtaFreeSourceBitMap	=(dtaDummy + 213);
	(* Boolean : Free the source bitmap after remapping *)

	pdtaGrab		=(dtaDummy + 214);
	(* Pointer to a Point structure *)

	pdtaDestBitMap		=(dtaDummy + 215);
	(* Pointer to the destination (remapped) bitmap *)

	pdtaClassBitMap	=(dtaDummy + 216);
	(* Pointer to class-allocated bitmap, that will end
	 * up being freed by the class after DisposeDTObject()
	 * is called *)

	pdtaNumSparse		=(dtaDummy + 217);
	(* (UWORD) Number of colors used for sparse remapping *)

	pdtaSparseTable	=(dtaDummy + 218);
	(* (UBYTE * ) Pointer to a table of pen numbers indicating
	 * which colors should be used when remapping the image.
	 * This array must contain as many entries as there
	 * are colors specified with pdtaNumSparse *)

(*****************************************************************************)

(*  Masking techniques	*)
	mskNone=			0;
	mskHasMask=		1;
	mskHasTransparentColor=	2;
	mskLasso=		3;
	mskHasAlpha=		4;

(*  Compression techniques  *)
	cmpNone=			0;
	cmpByteRun1=		1;
	cmpByteRun2=		2;


(*  Bitmap header (BMHD) structure  *)
TYPE
 BitMapHeader=RECORD
    width:CARDINAL;		(* Width in pixels *)
    height:CARDINAL;		(* Height in pixels *)
    left:INTEGER;		(* Left position *)
    top:INTEGER;		(* Top position *)
    depth:SHORTCARD;		(* Number of planes *)
    masking:SHORTCARD;		(* Masking type *)
    compression:SHORTCARD;	(* Compression type *)
    pad:SHORTCARD;
    transparent:CARDINAL;	(* Transparent color *)
    xAspect:SHORTCARD;
    yAspect:SHORTCARD;
    pageWidth:INTEGER;
    pageHeight:INTEGER;
 END;
 BitMapHeaderPtr=POINTER TO BitMapHeader;

(*****************************************************************************)

(*  Color register structure *)
 ColorRegister=RECORD
    red, green, blue:SHORTCARD;
 END;
 ColorRegisterPtr=POINTER TO ColorRegister;

(*****************************************************************************)
CONST
(* IFF types that may be in pictures *)
	ID_ILBM		=CAST(LONGCARD,'ILBM');
	ID_BMHD		=CAST(LONGCARD,'BMHD');
	ID_BODY		=CAST(LONGCARD,'BODY');
	ID_CMAP		=CAST(LONGCARD,'CMAP');
	ID_CRNG		=CAST(LONGCARD,'CRNG');
	ID_GRAB		=CAST(LONGCARD,'GRAB');
	ID_SPRT		=CAST(LONGCARD,'SPRT');
	ID_DEST		=CAST(LONGCARD,'DEST');
	ID_CAMG		=CAST(LONGCARD,'CAMG');





(*
**  soundclass.h 39.3 (26.4.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType sound objects.
*)


(*****************************************************************************)
CONST
	soundDTClass=	"sound.datatype";

(*****************************************************************************)

(* Sound attributes *)
	sdtaDummy		=(dtaDummy + 500);
	sdtaVoiceHeader	=(sdtaDummy + 1);
	sdtaSample		=(sdtaDummy + 2);
   (* (UBYTE * ) Sample data *)

	sdtaSampleLength	=(sdtaDummy + 3);
   (* (ULONG) Length of the sample data in UBYTEs *)

	sdtaPeriod		=(sdtaDummy + 4);
    (* (UWORD) Period *)

	sdtaVolume		=(sdtaDummy + 5);
    (* (UWORD) Volume.	Range from 0 to 64 *)

	sdtaCycles		=(sdtaDummy + 6);

(* The following tags are new for V40 *)
	sdtaSignalTask		=(sdtaDummy + 7);
    (* (struct Task * ) Task to signal when sound is complete or
	next buffer needed. *)

	sdtaSignalBit		=(sdtaDummy + 8);
    (* (BYTE) Signal bit to use on completion or -1 to disable *)

	sdtaContinuous		=(sdtaDummy + 9);
    (* (ULONG) Playing a continuous stream of data.  Defaults to
	FALSE. *)

(*****************************************************************************)

 //cmpNone=     0;  //already declared above
 cmpFibDelta= 1;

TYPE
 VoiceHeader=RECORD
    oneShotHiSamples:LONGCARD;
    repeatHiSamples:LONGCARD;
    samplesPerHiCycle:LONGCARD;
    samplesPerSec:CARDINAL;
    octaves:SHORTCARD;
    compression:SHORTCARD;
    volume:LONGCARD;
 END;
 VoiceHeaderPtr=POINTER TO VoiceHeader;

(*****************************************************************************)
CONST
(* IFF types *)
 id8SVX =CAST(LONGCARD,'8SVX');
 idVHDR =CAST(LONGCARD,'VHDR');
 idBODY =CAST(LONGCARD,'BODY');

(*****************************************************************************)



(*
**  textclass.h 39.3 (3.8.92)
**  Includes Release 40.15
**
*)

(*****************************************************************************)

	textDTClass=	"text.datatype";

(*****************************************************************************)

(* Text attributes *)
	tdtaBuffer		=(dtaDummy + 300);
	tdtaBufferLen		=(dtaDummy + 301);
	tdtaLineList		=(dtaDummy + 302);
	tdtaWordSelect		=(dtaDummy + 303);
	tdtaWordDelim		=(dtaDummy + 304);
	tdtaWordWrap		=(dtaDummy + 305);
     (* Boolean. Should the text be word wrapped.  Defaults to false. *)

(*****************************************************************************)
TYPE
(* There is one Line structure for every line of text in our document.	*)
  Line=RECORD
    link:ED.MinNode;		(* to link the lines together *)
    text:StrPtr;		(* pointer to the text for this	line *)
    textLen:LONGCARD;		(* the character length of the text for this line *)
    xOffset:CARDINAL;		(* where in the	line the text starts *)
    yOffset:CARDINAL;		(* line the text is on *)
    width:CARDINAL;		(* Width of line in pixels *)
    height:CARDINAL;		(* Height of line in pixels *)
    flags:BITSET;		(* info	on the line *)
    fgPen:SHORTINT;		(* foreground pen *)
    bgPen:SHORTINT;		(* background pen *)
    style:LONGSET;		(* Font style *)
    data:ADDRESS;		(* Link data... *)
 END;
 LinePtr=POINTER TO Line;

(*****************************************************************************)
CONST
//Bitnumvbres for Line.flags
(* Line.ln_Flags *)

(* Line Feed *)
	lnLf=0;

(* Segment is a link *)
	lnLink=1;

(* ln_Data is a pointer to an DataTypes object *)
	lnObject=2;

(* Object is selected *)
	lnSelected=3;

(*****************************************************************************)

(* IFF types that may be text *)
	idFTXT		=CAST(LONGCARD,'FTXT');
	idCHRS		=CAST(LONGCARD,'CHRS');

(*****************************************************************************)






(*
**  animationclass.h 40.1 (4.5.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType animation objects.
**
*)


(*****************************************************************************)

	animationDTClass=	"animation.datatype";

(*****************************************************************************)

(* Animation attributes *)
	adtaDummy		=(dtaDummy + 600);
	adtaModeID		=pdtaModeID;
	adtaKeyFrame		=pdtaBitMap;
	(* (struct BitMap * ) Key frame (first frame) bitmap *)

	adtaColorRegisters	=pdtaColorRegisters;
	adtaCRegs			=pdtaCRegs;
	adtaGRegs			=pdtaGRegs;
	adtaColorTable		=pdtaColorTable;
	adtaColorTable2	=pdtaColorTable2;
	adtaAllocated		=pdtaAllocated;
	adtaNumColors		=pdtaNumColors;
	adtaNumAlloc		=pdtaNumAlloc;

	adtaRemap		=pdtaRemap;
	(* (BOOL) : Remap animation (defaults to TRUE) *)

	adtaScreen		=pdtaScreen;
	(* (struct Screen * ) Screen to remap to *)

	adtaNumSparse		=pdtaNumSparse;
	(* (UWORD) Number of colors used for sparse remapping *)

	adtaSparseTable	=pdtaSparseTable;
	(* (UBYTE * ) Pointer to a table of pen numbers indicating
	 * which colors should be used when remapping the image.
	 * This array must contain as many entries as there
	 * are colors specified with adtaNumSparse *)

	adtaWidth			=(adtaDummy + 1);
	adtaHeight		=(adtaDummy + 2);
	adtaDepth			=(adtaDummy + 3);
	adtaFrames		=(adtaDummy + 4);
	(* (ULONG) Number of frames in the animation *)

	adtaFrame		=(adtaDummy + 5);
	(* (ULONG) Current frame *)

	adtaFramesPerSecond	=(adtaDummy + 6);
	(* (ULONG) Frames per second *)

	adtaFrameIncrement	=(adtaDummy + 7);
	(* (LONG) Amount to change frame by when fast forwarding or
	 * rewinding.  Defaults to 10. *)

(* Sound attributes *)
	adtaSample		=sdtaSample;
	adtaSampleLength	=sdtaSampleLength;
	adtaPeriod		=sdtaPeriod;
	adtaVolume		=sdtaVolume;
	adtaCycles		=sdtaCycles;

(*****************************************************************************)

 idANIM	=CAST(LONGCARD,'ANIM');
 idANHD	=CAST(LONGCARD,'ANHD');
 idDLTA	=CAST(LONGCARD,'DLTA');

(*****************************************************************************)
TYPE
(*  Required ANHD structure describes an ANIM frame *)
 AnimHeader=RECORD
    operation:SHORTCARD;	(*  The compression method:
				     0	set directly (normal ILBM BODY),
				     1	XOR ILBM mode,
				     2	Long Delta mode,
				     3	Short Delta mode,
				     4	Generalized short/long Delta mode,
				     5	Byte Vertical Delta mode
				     6	Stereo op 5 (third party)
				    74	(ascii 'J') reserved for Eric Graham's
					compression technique (details to be
					released later). *)

    mask:SHORTCARD;	(* (XOR mode only - plane mask where each
				   bit is set =1 if there is data and =0
				   if not.) *)

    width:CARDINAL;	(* (XOR mode only - width and height of the *)
    height:CARDINAL;	(* area represented by the BODY to eliminate *)
				(* unnecessary un-changed data) *)


    left:INTEGER;	(* (XOR mode only - position of rectangular *)
    top:INTEGER;	(* area representd by the BODY) *)


    absTime:LONGCARD;	(* Timing for a frame relative to the time
					   the first frame was displayed, in
					   jiffies (1/60 sec) *)

    relTime:LONGCARD;	(* Timing for frame relative to time
					   previous frame was displayed - in
					   jiffies (1/60 sec) *)

    interleave:SHORTCARD;	(* Indicates how may frames back this data is to
						   modify.  0 defaults to indicate two frames back
						   (for double buffering). n indicates n frames back.
						   The main intent here is to allow values
						   of 1 for special applications where
						   frame data would modify the immediately
						   previous frame. *)

    pad0:SHORTCARD;	(* Pad byte, not used at present. *)

    flags:LONGSET;	(* 32 option bits used by options=4 and 5.
				   At present only 6 are identified, but the
				   rest are set =0 so they can be used to
				   implement future ideas.  These are defined
				   for option 4 only at this point.  It is
				   recommended that all bits be set =0 for
				   option 5 and that any bit settings
				   used in the future (such as for XOR mode)
				   be compatible with the option 4
				   bit settings.   Player code should check
				   undefined bits in options 4 and 5 to assure
				   they are zero.

				   The six bits for current use are:

				    bit #	set =0			set =1
				    ===============================================
				    0		short data		long data
				    1		set			XOR
				    2		separate info		one info list
						for each plane		for all planes
				    3		not RLC			RLC (run length coded)
				    4		horizontal		vertical
				    5		short info offsets	long info offsets
				*)

    pad:ARRAY [0..15] OF SHORTCARD;	(* This is a pad for future use for future
								   compression modes. *)
 END;
 AnimHeaderPtr=POINTER TO AnimHeader;

(*****************************************************************************)

CONST
	adtmDummy		=(0700H);

	adtmLoadFrame		=(0701H);
    (* Used to load a frame of the animation *)

	adtmUnloadFrame	=(0702H);
    (* Used to unload a frame of the animation *)

	adtmStart		=(0703H);
    (* Used to start the animation *)

	adtmPause		=(0704H);
    (* Used to pause the animation (don't reset the timer) *)

	adtmStop			=(0705H);
    (* Used to stop the animation *)

	adtmLocate		=(0706H);
    (* Used to locate a frame in the animation (as set by a slider...) *)

(*****************************************************************************)
TYPE
(* adtmLOADFRAME, adtmUNLOADFRAME *)
 adtFrame=RECORD
    methodID:LONGCARD;
    timeStamp:LONGCARD;		(* Timestamp of frame to load *)

    (* The following fields are filled in by the adtmLOADFRAME method, *)
    (* and are read-only for any other methods. *)

    frame:LONGCARD;		(* Frame number *)
    duration:LONGCARD;		(* Duration of frame *)

    bitMap:GD.BitMapPtr;		(* Loaded BitMap *)
    cMap:GD.ColorMapPtr;		(* Colormap, if changed *)

    sample:ADDRESS;		(* Sound data *)
    sampleLength:LONGCARD;
    period:LONGCARD;

    userData:ADDRESS;		(* Used by load frame for extra data *)
 END;
 adtFramePtr= POINTER TO adtFrame;

(* adtmSTART, adtmPAUSE, adtmSTOP, adtmLOCATE *)
 adtStart=RECORD
    methodID:LONGCARD;
    frame:LONGCARD;		(* Frame # to start at *)
 END;
 adtStartPtr=POINTER TO adtStart;

(*****************************************************************************)




END DataTypesD.

