(*
**	Cyclone Modula-2 Interface module:
**	$VER: exec_protos.h 39.15 (1.10.93)
**	Includes Release 40.15
**
**	C prototypes. For use with 32 bit integers only.
**
**	(C) Copyright 1990-1993 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**      Interface module by Marcel Timmermans
**      (C) Copyright 1995-1996 Marcel Timmermans
**      All Rights Reserved
*)

DEFINITION MODULE ExecL {"exec.library",33};

FROM SYSTEM IMPORT ADDRESS, SHORTSET, BITSET, LONGSET, WORD;

IMPORT ExecD,Reg;

(* 
   Automatic variable must be declared when there is a library 
   open code
 *)

VAR 
  execBase : ExecD.ExecBasePtr; (* Automatic filled in when using module *)    

PROCEDURE Supervisor(userFunction{Reg.A5}:PROC); CODE -30;

PROCEDURE InitCode(startClass{Reg.D0}:ExecD.ResidentFlagSet;
                   version{Reg.D1}:LONGINT); CODE -72;

PROCEDURE InitStruct(initTable{Reg.A1}:ADDRESS;
                     memory{Reg.A2}:ADDRESS;
                     size{Reg.D0}:LONGCARD); CODE -78;

PROCEDURE MakeLibrary(vectors{Reg.A0}:ADDRESS;
                      structure{Reg.A1}:ADDRESS;
                      init{Reg.A2}:ADDRESS;
                      dataSize{Reg.D0}:LONGINT;
                      segList{Reg.D1}:ExecD.BPTR):ExecD.LibraryPtr; CODE -84;

PROCEDURE MakeFunctions(target{Reg.A0}:ADDRESS;
                        functArray{Reg.A1}:ADDRESS;
                        functDispBase{Reg.A2}:ADDRESS); CODE -90;

PROCEDURE FindResident(name{Reg.A1}:ADDRESS):ExecD.ResidentPtr; CODE -96;

(*------ diagnostics --------------------------------------------------*)
PROCEDURE Alert(alertNum{7}:LONGINT;parameters{13}:ADDRESS); CODE -108;
PROCEDURE Debug(flags{Reg.D0}:LONGSET); CODE -114;

(*------ interrupts ---------------------------------------------------*)

PROCEDURE Disable(); CODE -120;

PROCEDURE Enable(); CODE -126;

PROCEDURE Forbid(); CODE -132;

PROCEDURE Permit(); CODE -138;

PROCEDURE SetSR(newSR{Reg.D0}:BITSET;mask{Reg.D1}:BITSET):BITSET; CODE -144;

PROCEDURE SuperState():ADDRESS; CODE -150;

PROCEDURE UserState(sysStack{Reg.D0}:ADDRESS); CODE -156;

PROCEDURE AddIntServer(intNum{Reg.D0}: LONGINT;
                       interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -168;

PROCEDURE RemIntServer(intNum{Reg.D0}: LONGINT;
                       interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -174;

PROCEDURE Cause(interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -180;

(*------ memory allocation --------------------------------------------*)

PROCEDURE Allocate(freeList{Reg.A0}:ExecD.MemHeaderPtr;
                   byteSize{Reg.D0}:LONGINT):ADDRESS; CODE -186;

PROCEDURE Deallocate(freeList{Reg.A0}:ExecD.MemHeaderPtr;
                     memoryBlock{Reg.A1}:ADDRESS;
                     byteSize{Reg.D0}:LONGINT); CODE -192;

PROCEDURE AllocMem(byteSize{Reg.D0}:LONGINT;
                   requirements{Reg.D1}:ExecD.MemReqSet):ADDRESS; CODE -198;

PROCEDURE AllocAbs(byteSize{Reg.D0}:LONGINT;
                   location{Reg.A1}:ADDRESS):ADDRESS; CODE -204;

PROCEDURE FreeMem(memoryBlock{Reg.A1}:ADDRESS;
                  byteSize{Reg.D0}:LONGINT); CODE -210;

PROCEDURE AvailMem(requirements{Reg.D1}:ExecD.MemReqSet):LONGINT; CODE -216;

PROCEDURE AllocEntry(
              memList{Reg.A0}:ExecD.MemListPtr):ExecD.MemListPtr; CODE -222;

PROCEDURE FreeEntry(memList{Reg.A0}:ExecD.MemListPtr); CODE -228;

(*------ lists --------------------------------------------------------*)

PROCEDURE Insert(list{Reg.A0}:ExecD.ListPtr;
                 node{Reg.A1}:ADDRESS;
                 listNode{Reg.A2}:ADDRESS); CODE -234;

PROCEDURE AddHead(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -240;

PROCEDURE AddTail(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -246;

PROCEDURE Remove(node{Reg.A1}:ADDRESS); CODE -252;

PROCEDURE RemTail(list{Reg.A0}:ExecD.ListPtr):ADDRESS; CODE -264;

PROCEDURE RemHead(list{Reg.A0}:ExecD.ListPtr):ADDRESS; CODE -258;

PROCEDURE Enqueue(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -270;

PROCEDURE FindName(start{Reg.A0}:ADDRESS;
                   name{Reg.A1}:ADDRESS):ADDRESS; CODE -276;

(*------ tasks --------------------------------------------------------*)

PROCEDURE AddTask(task{Reg.A1}:ExecD.TaskPtr;
                  initialPC{Reg.A2}:ADDRESS;
                  finalPC{Reg.A3}:ADDRESS); CODE -282;

PROCEDURE RemTask(task{Reg.A1}:ExecD.TaskPtr); CODE -288;

PROCEDURE FindTask(name{Reg.A1}:ADDRESS):ExecD.TaskPtr; CODE -294;

PROCEDURE SetTaskPri(task{Reg.A1}:ExecD.TaskPtr;
                     priority{Reg.D0}:SHORTINT):SHORTINT; CODE -300;

PROCEDURE SetSignal(newSignals{Reg.D0}:LONGSET;
                    signalMask{Reg.D1}:LONGSET):LONGSET; CODE -306;

PROCEDURE SetExcept(newSignals{Reg.D0}:LONGSET;
                    signalMask{Reg.D1}:LONGSET):LONGSET; CODE -312;

PROCEDURE Wait(signalSet{Reg.D0}:LONGSET):LONGSET; CODE -318;

PROCEDURE Signal(task{Reg.A1}:ExecD.TaskPtr;
                 signals{Reg.D0}:LONGSET); CODE -324;

PROCEDURE AllocSignal(
           signalNum{Reg.D0}:LONGINT):LONGINT; CODE -330;

PROCEDURE FreeSignal(signalNum{Reg.D0}:LONGINT); CODE -336;

PROCEDURE AllocTrap(trapNum{Reg.D0}:LONGINT):LONGINT; CODE -342;

PROCEDURE FreeTrap(trapNum{Reg.D0}:LONGINT); CODE -348;

(*------ messages -----------------------------------------------------*)

PROCEDURE AddPort(port{Reg.A1}:ExecD.MsgPortPtr); CODE -354;

PROCEDURE RemPort(port{Reg.A1}:ExecD.MsgPortPtr); CODE -360;

PROCEDURE PutMsg(port{Reg.A0}:ExecD.MsgPortPtr;
                 message{Reg.A1}:ADDRESS); CODE -366;

PROCEDURE GetMsg(port{Reg.A0}:ExecD.MsgPortPtr):ADDRESS; CODE -372;

PROCEDURE ReplyMsg(message{Reg.A1}:ADDRESS); CODE -378;

PROCEDURE WaitPort(port{Reg.A0}:ExecD.MsgPortPtr); CODE -384;

PROCEDURE FindPort(name{Reg.A1}:ADDRESS):ExecD.MsgPortPtr; CODE -390;

(*------ libraries ----------------------------------------------------*)

PROCEDURE AddLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -396;

PROCEDURE RemLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -402;

PROCEDURE OldOpenLibrary(libName{Reg.A1}:ADDRESS):ExecD.LibraryPtr; CODE -408;

PROCEDURE CloseLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -414;

PROCEDURE SetFunction(library{Reg.A1}:ExecD.LibraryPtr;
                      funcOffset{Reg.A0}:INTEGER;
                      funcEntry{Reg.D0}:ADDRESS):ADDRESS; CODE -420;

PROCEDURE SumLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -426;

PROCEDURE AddDevice(device{Reg.A1}:ExecD.DevicePtr); CODE -432;

PROCEDURE RemDevice(device{Reg.A1}:ExecD.DevicePtr); CODE -438;

PROCEDURE OpenDevice(devName{Reg.A0}:ADDRESS;
                     unitNumber{Reg.D0}:LONGINT;
                     ioRequest{Reg.A1}:ADDRESS;
                     flags{Reg.D1}:LONGSET); CODE -444;

PROCEDURE CloseDevice(ioRequest{Reg.A1}:ADDRESS); CODE -450;

PROCEDURE DoIO(ioRequest{Reg.A1}:ADDRESS); CODE -456;

PROCEDURE SendIO(ioRequest{Reg.A1}:ADDRESS); CODE -462;

PROCEDURE CheckIO(ioRequest{Reg.A1}:ADDRESS):BOOLEAN; CODE -468;

PROCEDURE WaitIO(ioRequest{Reg.A1}:ADDRESS); CODE -474;

PROCEDURE AbortIO(ioRequest{Reg.A1}:ADDRESS); CODE -480;

(*------ resources ----------------------------------------------------*)

PROCEDURE AddResource(resource{Reg.A1}:ADDRESS); CODE -486;

PROCEDURE RemResource(resource{Reg.A1}:ADDRESS); CODE -492;

PROCEDURE OpenResource(resName{Reg.A1}:ADDRESS):ADDRESS; CODE -498;

(*------ private diagnostic support -----------------------------------*)
(*------ misc ---------------------------------------------------------*)
PROCEDURE RawDoFmt(formatString{Reg.A0}:ADDRESS;
                   dataStream{Reg.A1}:ADDRESS;
                   putChProc{Reg.A2}:ADDRESS;
                   putChData{Reg.A3}:ADDRESS); CODE -522;

PROCEDURE GetCC():BITSET; CODE -528;

PROCEDURE TypeOfMem(address{Reg.A1}:ADDRESS):ExecD.MemReqSet; CODE -534;

PROCEDURE Procure(
           semaphore{Reg.A0}:ExecD.SemaphorePtr;
           bidMessage{Reg.A1}:ExecD.MessagePtr):LONGINT; CODE -540;

PROCEDURE Vacate(semaphore{Reg.A0}:ExecD.SemaphorePtr); CODE -546;

PROCEDURE OpenLibrary(libName{Reg.A1}:ADDRESS;
                      version{Reg.D0}:LONGINT):ExecD.LibraryPtr; CODE -552;

(*--- functions in V33 or higher (distributed as Release 1.2) ---*)
(*------ signal semaphores (note funny registers)----------------------*)

PROCEDURE InitSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -558;

PROCEDURE ObtainSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -564;

PROCEDURE ReleaseSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -570;

PROCEDURE AttemptSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr
          ):BOOLEAN; CODE -576;

PROCEDURE ObtainSemaphoreList(list{Reg.A0}:ExecD.ListPtr); CODE -582;

PROCEDURE ReleaseSemaphoreList(list{Reg.A0}:ExecD.ListPtr); CODE -588;

PROCEDURE FindSemaphore(
            name{Reg.A1}:ADDRESS):ExecD.SignalSemaphorePtr; CODE -594;

PROCEDURE AddSemaphore(
            signalSemaphore{Reg.A1}:ExecD.SignalSemaphorePtr); CODE -600;

PROCEDURE RemSemaphore(
            signalSemaphore{Reg.A1}:ExecD.SignalSemaphorePtr); CODE -606;

(*------ kickmem support ----------------------------------------------*)

PROCEDURE SumKickData():LONGCARD; CODE -612;

PROCEDURE AddMemList(size{Reg.D0}:LONGINT;
                     attributes{Reg.D1}:ExecD.MemReqSet;
                     pri{Reg.D2}:LONGINT;
                     base{Reg.A0}:ADDRESS;
                     name{Reg.A1}:ADDRESS):LONGINT; CODE -618;

PROCEDURE CopyMem(source{Reg.A0}:ADDRESS;
                  dest{Reg.A1}:ADDRESS;
                  size{Reg.D0}:LONGINT); CODE -624;

PROCEDURE CopyMemQuick(source{Reg.A0}:ADDRESS;
                       dest{Reg.A1}:ADDRESS;
                       size{Reg.D0}:LONGINT); CODE -630;

(*------ cache --------------------------------------------------------*)
(*--- functions in V36 or higher (distributed as Release 2.0) ---*)

PROCEDURE CacheClearU; CODE -636;

PROCEDURE CacheClearE(address{Reg.A0}:ADDRESS;
                      length{Reg.D0}:LONGCARD;
                      caches{Reg.D1}:ExecD.CacheFlagSet); CODE -642;

PROCEDURE CacheControl(cacheBits{Reg.D0},
                       cacheMask{Reg.D1}:ExecD.CacheFlagSet
                       ):ExecD.CacheFlagSet; CODE -648;

(*------ misc ---------------------------------------------------------*)

PROCEDURE CreateIORequest(replyPort{Reg.A0}:ExecD.MsgPortPtr;
                          size{Reg.D0}:LONGINT):ADDRESS ; CODE -654;

PROCEDURE DeleteIORequest(iorequest{Reg.A0}:ADDRESS); CODE -660;

PROCEDURE CreateMsgPort():ExecD.MsgPortPtr; CODE -666;

PROCEDURE DeleteMsgPort(port{Reg.A0}:ExecD.MsgPortPtr); CODE -672;

PROCEDURE ObtainSemaphoreShared(
            sigSem{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -678;

(*------ even more memory support -------------------------------------*)

PROCEDURE AllocVec(byteSize{Reg.D0}:LONGINT;
                   requirements{Reg.D1}:ExecD.MemReqSet):ADDRESS; CODE -684;

PROCEDURE FreeVec(memoryBlock{Reg.A1}:ADDRESS); CODE -690;

PROCEDURE CreatePool(requirements{Reg.D0}: ExecD.MemReqSet;
             puddleSize{Reg.D1} : LONGINT;
             puddleThresh{Reg.D2}: LONGINT): ADDRESS; CODE -696;

PROCEDURE DeletePool(poolHeader{Reg.A0}: ADDRESS); CODE -702;

PROCEDURE AllocPooled(poolHeader{Reg.A0}:ADDRESS;
                      memSize{Reg.D0}:LONGINT):ADDRESS; CODE -708;

PROCEDURE FreePooled(poolHeader{Reg.A0}:ADDRESS;
                     memory{Reg.A1}:ADDRESS;
                     memSize{Reg.D0}:LONGINT); CODE -714;

(*------ misc ---------------------------------------------------------*)

PROCEDURE ColdReboot; CODE -726;

PROCEDURE StackSwap(VAR newStack{Reg.A0}:ExecD.StackSwapStruct); CODE -732;

(*------ task trees ---------------------------------------------------*)

PROCEDURE ChildFree(tid{0}:ADDRESS); CODE -738;
PROCEDURE ChildOrphan(tid{0}:ADDRESS); CODE-744;
PROCEDURE ChildStatus(tid{0}:ADDRESS); CODE -750;
PROCEDURE ChildWait(tid{0}:ADDRESS); CODE -756;

(* ------ future expansion ---------------------------------------------*)

PROCEDURE CachePreDMA(vaddress{Reg.A0}:ADDRESS;
                      VAR length{Reg.A1}:LONGINT;
                      flags{Reg.D1}:LONGCARD):ADDRESS; CODE -762;

PROCEDURE CachePostDMA(vaddress{Reg.A0}:ADDRESS;
                       VAR length{Reg.A1}:LONGINT;
                       flags{Reg.D1}:LONGCARD); CODE -768;

END ExecL.
