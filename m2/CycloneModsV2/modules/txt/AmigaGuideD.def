(* 
**  Cyclone Modula-2 Interface module:
**  $VER: AmigaGuide 40.15 
**
**      (C) Copyright 1991-1993 Commodore-Amiga, Inc.
**          All Rights Reserved
**
**      (C) Copyright Modula-2 Interface 1996 by Marcel Timmermans
**          All Rights Reserved
**
**
*)

DEFINITION MODULE AmigaGuideD;

(*$ Implementation- *)

FROM SYSTEM IMPORT ADDRESS,LONGSET;
IMPORT ExecD,DosD,ud:UtilityD;


TYPE
 AmigaGuideBasePtr = POINTER TO AmigaGuideBase;
 AmigaGuideBase = RECORD
                    lib:ExecD.Library;
                  END;

CONST
(* AmigaGuideMsg.type *)
  apshToolID=11000;
  startupMsgID		= apshToolID+1;  (* Startup message *)
  loginToolID		= apshToolID+2;  (* Login a tool SIPC port *)
  logoutToolID		= apshToolID+3;  (* Logout a tool SIPC port *)
  shutdownMsgID		= apshToolID+4;  (* Shutdown message *)
  activateToolID	= apshToolID+5;  (* Activate tool *)
  deactivateToolID	= apshToolID+6;  (* Deactivate tool *)
  activeToolID		= apshToolID+7;  (* Tool Active *)
  inactiveToolID	= apshToolID+8;  (* Tool Inactive *)
  toolStatusID		= apshToolID+9;  (* Status message *)
  toolCmdID		= apshToolID+10; (* Tool command message *)
  toolCmdReplyID	= apshToolID+11; (* Reply to tool command *)
  shutdownToolID	= apshToolID+12; (* Shutdown tool *)          

(* Attributes accepted by GetAmigaGuideAttr() *)
  agaDummy         = ud.tagUser;
  agaPath          = agaDummy+1;
  agaXRefList      = agaDummy+2;
  agaActivate      = agaDummy+3;
  agaContext       = agaDummy+4;
  agaHelpGroup     = agaDummy+5; (* (ULONG) Unique identifier *)

  agaReserved1     = agaDummy+6;
  agaReserved2     = agaDummy+7;
  agaReserved3     = agaDummy+8;

  agaARexxPort     = agaDummy+9;
    (* MsgPortPtr Pointer to the ARexx message port (V40) *)

  agaARexxPortName = agaDummy+10;
    (* (LSTRPTR) Used to specify the ARexx port name (V40) (not copied) *)


TYPE
  AGContext = ADDRESS;
  
  AmigaGuideMsgPtr=POINTER TO AmigaGuideMsg;
  AmigaGuideMsg=RECORD
    msg:ExecD.Message;
    type:LONGCARD;       (* Type of message *)
    data:ADDRESS;        (* Pointer to message data *)
    sSize:LONGCARD;      (* Size of message data *)
    dType:LONGCARD;      (* Type of message data *)
    priRet:LONGCARD;     (* Primary return value *)
    secRet:LONGCARD;     (* Secondary return value *) 
    system1:ADDRESS;
    system2:ADDRESS;
  END;

  NewAmigaGuidePtr=POINTER TO NewAmigaGuide;
  NewAmigaGuide=RECORD
    lock:DosD.FileLockPtr;     (* Lock on the document directory *)
    name:ADDRESS;              (* Name of document file *)
    screen:ADDRESS;            (* Screen to place windows within *)
    pubScreen:ADDRESS;         (* Public screen name to open on *)
    hostPort:ADDRESS;          (* Application's ARexx port name *)
    clientPort:ADDRESS;        (* Name to assign to the clients ARexx port *)
    baseName:ADDRESS;          (* Base name of the application *)
    flags:LONGSET;             (* Flags *)
    context:POINTER TO ADDRESS;(* NIL terminated context table *)
    node:ADDRESS;              (* Node to align on first (defaults to Main) *)
    line:LONGINT;              (* Line to align on *)
    extens:ud.TagItemPtr;      (* Tag array extension *)
    client:ADDRESS;            (* Private! MUST be NULL *)                    
  END;

CONST

(* public Client flags (NewAmigaGuide.flags) *)
  htLoadIndex  = 0;     (* Force load the index at init time *)
  htLoadAll    = 1;     (* Force load the entire database at init *)
  htCacheNode  = 2;     (* Cache each node as visited *)
  htCacheDB    = 3;     (* Keep the buffers around until expunge *)
  htUnique     = 15;    (* Unique ARexx port name *)
  htNoActivate = 16;    (* Don't activate window *)
  htSysGads    = 31;


(* Callback function ID's *)
  hthOpen  = 0;
  hthClose = 1;


(* Callback error codes *)
  hterrNotEnoughMemory  = 100;
  hterrCantOpenDataBase = 101;
  hterrCantFindNode     = 102;
  hterrCantOpenNode     = 103;
  hterrCantOpenWindow   = 104;
  hterrInvalidCommand   = 105;
  hterrCantComplete     = 106;
  hterrPortClosed       = 107;
  hterrCantCreatePort   = 108;
  hterrKeywordNotFound  = 113;

TYPE
(* Cross reference node *)
  XRefPtr=POINTER TO XRef;
  XRef=RECORD
    node:ExecD.Node;   (* Embedded node *)
    pad:CARDINAL;      (* Padding *)
    df:ADDRESS;        (* Document defined in ('DocFilePtr') *)
    file:ADDRESS;      (* Name of document file *)
    name:ADDRESS;      (* Name of item *)
    line:LONGINT;      (* Line defined at *)                   
  END;


CONST
  xrSize=SIZE(XRef);

(* Types of cross reference nodes *)
  xrGeneric	= 0;
  xrFunction	= 1;
  xrCommand	= 2;
  xrInclude	= 3;
  xrMacro	= 4;
  xrStruct	= 5;
  xrField	= 6;
  xrTypedef	= 7;
  xrDefine	= 8;

TYPE
(* Callback handle *)
  AmigaGuideHostPtr=POINTER TO AmigaGuideHost;
  AmigaGuideHost=RECORD
    dispatcher:ud.Hook; (* Dispatcher *)
    reserved:LONGCARD;  (* Must be 0 *)
    flags:LONGSET;
    useCnt:LONGCARD;    (* Number of open nodes *)
    systemData:ADDRESS; (* Reserved for system use *)
    userData:ADDRESS;   (* Anything you want... *)   
  END;

CONST
  hmFindNode=1;
  hmOpenNode=2;
  hmCloseNode=3;
  hmExpunge=10;         (* Expunge DataBase *)

TYPE
  (* hmFindNode *)
  opFindHostPtr=POINTER TO opFindHost;
  opFindHost=RECORD
    methodID:LONGCARD;
    attrs:ud.TagItemPtr; (*  R: Additional attributes *)
    name:ADDRESS;        (*  R: Name of node *)
    toc:ADDRESS;         (*  W: Table of Contents *)
    title:ADDRESS;       (*  W: Title to give to the node *)
    next:ADDRESS;        (*  W: Next node to browse to *)
    prev:ADDRESS;        (*  W: Previous node to browse to *)
  END;


  (* hmOpenNode, hmCloseNode *)
  opNodeIOPtr=POINTER TO opNodeIO;
  opNodeIO=RECORD
    methodID:LONGCARD;
    attrs:ud.TagItemPtr; (*  R: Additional attributes *)
    node:ADDRESS;        (*  R: Node name and arguments *)
    fileName:ADDRESS;    (*  W: File name buffer *)
    docBuffer:ADDRESS;   (*  W: Node buffer *)
    buffLen:LONGCARD;    (*  W: Size of buffer *)
    flags:LONGSET;       (* RW: Control flags *)           
  END;

CONST
(* onm_Flags *)

  htnKeep       = 0;    (* Don't flush this node until database is closed. *)
  htnReserved1  = 1;    (* Reserved for system use *)
  htnReserved2  = 2;    (* Reserved for system use *)
  htnAscii      = 3;    (* Node is straight ASCII *)
  htnReserved3  = 4;    (* Reserved for system use *)
  htnClean      = 5;    (* Remove the node from the database *)
  htnDone       = 6;    (* Done with node *)

(* onm_Attrs *)

  htnaScreen	= ud.tagUser+1; (* struct Screen *Screen that window resides in *)
  htnaPens	= ud.tagUser+2; (* Pen array (from DrawInfo) *)
  htnaRectangle	= ud.tagUser+3; (* Window box *)                                     
  htnaHelpGroup = ud.tagUser+5; (* (ULONG) unique identifier *)

TYPE
  (* hmExpunge *)
  opExpungeNodePtr=POINTER TO opExpungeNode;
  opExpungeNode=RECORD
    methodID:LONGCARD;
    attrs:ud.TagItemPtr;   (*  R: Additional attributes *)
  END;

END AmigaGuideD.
