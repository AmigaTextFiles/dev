(* ------------------------------------------------------------------------
  :Program.       ReqTools
  :Contents.      Interface to Nico François' reqtools.library
  :Author.        Kai Bolay [kai] (C-Version by Nico François)
  :Address.       Hoffmannstraße 168
  :Address.       D-7250 Leonberg 1 (Germany)
  :Address.       UUCP: ...!cbmvax!cbmehq!cbmger!depot1!amokle!kai
  :Address.       FIDO: 2:247/706.3
  :History.       v1.0 [kai] 22-Nov-91 (translated from C)
  :History.       v1.0m [Frank Lömker] 24-Feb-92 Umsetzung nach Modula
  :History.       v2.0m [Frank Lömker] 10-Aug-92 ReqTools V38
  :History.                                      ReqToolsBase korrigiert
  :Copyright.     Freeware
  :Language.      Modula-2
  :Translator.    M2Amiga V4.0d
  :Remark.        Thanks to Nico for his great library
  :Bugs.          ReqTools/Arq should support each other
  :Bugs.          Font-Hook: ta.name can contain odd pointer :-(

  :Remark         Adjusted to Cyclone compiler by M. Timmmermans

------------------------------------------------------------------------ *)

DEFINITION MODULE ReqTools;

FROM IntuitionD IMPORT IntuitionBasePtr,WindowPtr,ScreenPtr,NewWindow;
FROM GraphicsD IMPORT GfxBasePtr,TextFontPtr,TextAttr;
FROM DosD IMPORT DosLibraryPtr;
FROM ExecD IMPORT Library,LibraryPtr;
FROM SYSTEM IMPORT ADDRESS,SHORTSET,LONGSET;
FROM UtilityD IMPORT HookPtr,TagItem,TagItemPtr,Tag,tagUser;

(* Do not remove this option, this is a trick *)

(*$ 
   Align- 
 *)



TYPE STRPTR=ADDRESS;
CONST
  ReqToolsName = "reqtools.library";
  ReqToolsVersion = 38;

TYPE
  ReqToolsBasePtr = POINTER TO ReqToolsBase;

VAR reqToolsBase:ReqToolsBasePtr; (* Automatic filled in when using module *)

TYPE
  ReqToolsBase = RECORD
    libNode: Library;
    flags: SHORTSET;
    pad1,pad2,pad3:SHORTINT;
    segList: ADDRESS; (* BPTR *)
    (* The following library bases may be read and used by your program *)
    intuitionBase: IntuitionBasePtr;
    gfxBase: GfxBasePtr;
    dosBase: DosLibraryPtr;
    (* Next two library bases are only (and always) valid on Kickstart 2.0!
       (1.3 version of reqtools also initializes these when run on 2.0) *)
    gadToolsBase: LibraryPtr;
    utilityBase: LibraryPtr;
  END;

CONST
  (* types of requesters, for AllocRequestA() *)
  TypeFileReq       = 0;
  TypeReqInfo       = 1;
  TypeFontReq       = 2;
  TypeScreenModeReq = 3;

(***********************
*                      *
*    File requester    *
*                      *
***********************)

(* structure _MUST_ be allocated with AllocRequest() *)

TYPE
  FileRequesterPtr = POINTER TO FileRequester;
  FileRequester = RECORD
    reqPos: LONGINT;
    leftOffset: INTEGER;
    topOffset: INTEGER;
    flags: LONGSET;
    (* OBSOLETE IN V38! DON'T USE! *) hook: HookPtr;
    dir: STRPTR;                (* READ ONLY! Change with ChangeReqAttrA()! *)
    matchPat: STRPTR;           (* READ ONLY! Change with ChangeReqAttrA()! *)
    defaultFont: TextFontPtr;
    waitPointer: ADDRESS;
    (* V38 *)
    lockWindow: LONGINT;
    shareIDCMP: LONGINT;
    intuiMsgFunc: HookPtr;
    reserved1: INTEGER;
    reserved2: INTEGER;
    reserved3: INTEGER;
    reqHeight: INTEGER;         (* READ ONLY!  Use RTFI_Height tag! *)
    (* Private data follows! HANDS OFF :-) *)
  END;

(* returned by FileRequestA() if multiselect is enabled,
   free list with FreeFileList() *)

  FileListPtr = POINTER TO FileList;
  FileList = RECORD
    next: FileListPtr;
    strLen: LONGINT;  (* -1 for directories *)
    name: STRPTR;
  END;

(* structure passed to RTFI_FilterFunc callback hook by
   volume requester (see RTFI_VolumeRequest tag) *)

  VolumeEntryPtr = POINTER TO VolumeEntry;
  VolumeEntry = RECORD
    type: LONGINT;    (* DLT_DEVICE or DLT_DIRECTORY *)
    name: STRPTR;
  END;

(***********************
*                      *
*    Font requester    *
*                      *
***********************)

(* structure _MUST_ be allocated with AllocRequest() *)

  FontRequesterPtr = POINTER TO FontRequester;
  FontRequester = RECORD
    reqPos: LONGINT;
    leftOffset: INTEGER;
    topOffset: INTEGER;
    flags: LONGSET;
    (* OBSOLETE IN V38! DON'T USE! *) hook: HookPtr;
    attr: TextAttr;  (* READ ONLY! *)
    defaultFont: TextFontPtr;
    waitPointer: ADDRESS;
    (* V38 *)
    lockWindow: LONGINT;
    shareIDCMP: LONGINT;
    intuiMsgFunc: HookPtr;
    reserved1: INTEGER;
    reserved2: INTEGER;
    reserved3: INTEGER;
    reqHeight: INTEGER;         (* READ ONLY!  Use RTFI_Height tag! *)
    (* Private data follows! HANDS OFF :-) *)
  END;

(*************************
*                        *
*  ScreenMode requester  *
*                        *
*************************)

(* structure _MUST_ be allocated with rtAllocRequest() *)

  ScreenModeRequesterPtr = POINTER TO ScreenModeRequester;
  ScreenModeRequester = RECORD
    reqPos: LONGINT;
    leftOffset: INTEGER;
    topOffset: INTEGER;
    flags: LONGSET;
    private1: LONGINT;
    displayID: LONGINT;         (* READ ONLY! *)
    displayWidth: INTEGER;      (* READ ONLY! *)
    displayHeight: INTEGER;     (* READ ONLY! *)
    defaultFont: TextFontPtr;
    waitPointer: ADDRESS;
    lockWindow: LONGINT;
    shareIDCMP: LONGINT;
    intuiMsgFunc: HookPtr;
    reserved1: INTEGER;
    reserved2: INTEGER;
    reserved3: INTEGER;
    reqHeight: INTEGER;         (* READ ONLY!  Use RTFI_Height tag! *)
    displayDepth: INTEGER;
    overscanType: INTEGER;
    autoScroll: LONGINT;
    (* Private data follows! HANDS OFF :-) *)
  END;

(***********************
*                      *
*    Requester Info    *
*                      *
***********************)

  (* for EZRequestA(), GetLongA(), GetStringA() and PaletteRequestA(),
   _MUST_ be allocated with AllocRequest() *)

  ReqInfoPtr = POINTER TO ReqInfo;
  ReqInfo = RECORD
    reqPos: LONGINT;
    leftOffset: INTEGER;
    topOffset: INTEGER;
    width: LONGINT;              (* not for EZRequestA() *)
    reqTitle: STRPTR;            (* currently only for EZRequestA() *)
    flags: LONGSET;
    defaultFont: TextFontPtr;    (* currently only for PaletteRequestA() *)
    waitPointer: ADDRESS;
    (* V38 *)
    lockWindow: LONGINT;
    shareIDCMP: LONGINT;
    intuiMsgFunc: HookPtr;
    (* structure may be extended in future *)
  END;

(***********************
*                      *
*     Handler Info     *
*                      *
***********************)

(* for ReqHandlerA(), will be allocated for you when you use
   the ReqHandler tag, never try to allocate this yourself! *)

  HandlerInfoPtr = POINTER TO HandlerInfo;
  HandlerInfo = RECORD
    private1: LONGINT;
    waitMask: LONGSET;
    doNotWait: LONGINT (* LONGBOOL *); (* ? *)
    (* Private data follows, HANDS OFF :-) *)
  END;

(* possible return codes from ReqHandlerA() *)
CONST
  CallHandler = 080000000H;


(*************************************
*                                    *
*                TAGS                *
*                                    *
*************************************)

  TagBase = tagUser;

  (*** tags understood by most requester functions ***)
   (* optional pointer to window *)
  Window = TagBase+1;
   (* idcmp flags requester should abort on (useful for IDCMP_DISKINSERTED) *)
  IDCMPFlags = TagBase+2;
   (* position of requester window (see below) - default REQPOS_POINTER *)
  ReqPos = TagBase+3;
   (* signal mask to wait for abort signal *)
  LeftOffset = TagBase+4;
   (* topedge offset of requester relative to position specified by ReqPos *)
  TopOffset = TagBase+5;
   (* name of public screen to put requester on (Kickstart 2.0 only!) *)
  PubScrName = TagBase+6;
   (* address of screen to put requester on *)
  Screen = TagBase+7;
   (* tagdata must hold the address of (!) an APTR variable *)
  DoReqHandler = TagBase+8;
   (* font to use when screen font is rejected, _MUST_ be fixed-width font!
    (struct TextFont *, not struct TextAttr *!)
    - default GfxBase->DefaultFont *)
  DefaultFont = TagBase+9;
   (* boolean to set the standard wait pointer in window - default FALSE *)
  WaitPointer = TagBase+10;
  (* (V38) char preceding keyboard shortcut characters (will be underlined) *)
  Underscore = TagBase+11;
  (* (V38) share IDCMP port with window - default FALSE *)
  ShareIDCMP = TagBase+12;
  (* (V38) lock window and set standard wait pointer - default FALSE *)
  LockWindowTag = TagBase+13;
  (* (V38) boolean to make requester's screen pop to front - default TRUE *)
  ScreenToFront = TagBase+14;
  (* (V38) Requester should use this font - default: screen font *)
  Textattr = TagBase+15;
  (* (V38) call this hook for every IDCMP message not for requester *)
  IntuiMsgFunc = TagBase+16;
  (* (V38) Locale ReqTools should use for text *)
  Locale = TagBase+17;

  (*** tags specific to EZRequestA ***
  *)
   (* title of requester window - default "Request" or "Information" *)
  ezReqTitle = TagBase+20;
   (* TagBase+21 reserved *)
   (* various flags (see below) *)
  ezFlags = TagBase+22;
   (* default response (activated by pressing RETURN) - default TRUE *)
  ezDefaultResponse = TagBase+23;

(*** tags specific to GetLongA ***
*)
   (* minimum allowed value - default MININT *)
  glMin = TagBase+30;
   (* maximum allowed value - default MAXINT *)
  glMax = TagBase+31;
   (* suggested width of requester window (in pixels) *)
  glWidth = TagBase+32;
   (* boolean to show the default value - default TRUE *)
  glShowDefault = TagBase+33;
  (* (V38) string with possible responses - default " _Ok |_Cancel" *)
  glGadFmt = TagBase+34;
  (* (V38) optional arguments for RTGL_GadFmt *)
  glGadFmtArgs = TagBase+35;
  (* (V38) invisible typing - default FALSE *)
  glInvisible = TagBase+36;
  (* (V38) window backfill - default TRUE *)
  glBackfill = TagBase+37;
  (* (V38) optional text above gadget *)
  glTextFmt = TagBase+38;
  (* (V38) optional arguments for RTGS_TextFmt *)
  glTextFmtArgs = TagBase+39;
  (* (V38) various flags (see below) *)
  glFlags = ezFlags;

(*** tags specific to GetStringA ***
*)
   (* suggested width of requester window (in pixels) *)
  gsWidth = glWidth;
   (* allow empty string to be accepted - default FALSE *)
  gsAllowEmpty = TagBase+80;
  (* (V38) string with possible responses - default " _Ok |_Cancel" *)
  gsGadFmt  = glGadFmt;
  (* (V38) optional arguments for RTGS_GadFmt *)
  gsGadFmtArgs = glGadFmtArgs;
  (* (V38) invisible typing - default FALSE *)
  gsInvisible = glInvisible;
  (* (V38) window backfill - default TRUE *)
  gsBackfill = glBackfill;
  (* (V38) optional text above gadget *)
  gsTextFmt = glTextFmt;
  (* (V38) optional arguments for RTGS_TextFmt *)
  gsTextFmtArgs = glTextFmtArgs;
  (* (V38) various flags (see below) *)
  gsFlags = ezFlags;

(*** tags specific to FileRequestA ***
*)
   (* various flags (see below) *)
  fiFlags = TagBase+40;
   (* suggested height of file requester *)
  fiHeight = TagBase+41;
   (* replacement text for 'Ok' gadget (max 6 chars) *)
  fiOkText = TagBase+42;
  (* (V38) bring up volume requester, tag data holds flags (see below) *)
  fiVolumeRequest = TagBase+43;
  (* (V38) call this hook for every file in the directory *)
  fiFilterFunc = TagBase+44;
  (* (V38) allow empty file to be accepted - default FALSE *)
  fiAllowEmpty = TagBase+45;

(*** tags specific to FontRequestA ***
*)
   (* various flags (see below) *)
  foflags = fiFlags;
   (* suggested height of font requester *)
  foHeight = fiHeight;
   (* replacement text for 'Ok' gadget (max 6 chars) *)
  foOkText = fiOkText;
   (* suggested height of font sample display - default 24 *)
  foSampleHeight= TagBase+60;
   (* minimum height of font displayed *)
  foMinHeight = TagBase+61;
   (* maximum height of font displayed *)
  foMaxHeight = TagBase+62;
   (* [TagBase+63 to TagBase+66 used below] *)
  (* (V38) call this hook for every font *)
  foFilterFunc = fiFilterFunc;

  (*** (V38) tags for rtScreenModeRequestA ***
*)
  (* various flags (see below) *)
  scFlags = fiFlags;
  (* suggested height of screenmode requester *)
  scHeight = fiHeight;
  (* replacement text for 'Ok' gadget (max 6 chars) *)
  scOkText = fiOkText;
  (* property flags (see also RTSC_PropertyMask) *)
  scPropertyFlags = TagBase+90;
  (* property mask - default all bits in RTSC_PropertyFlags considered *)
  scPropertyMask = TagBase+91;
  (* minimum display width allowed *)
  scMinWidth = TagBase+92;
  (* maximum display width allowed *)
  scMaxWidth = TagBase+93;
  (* minimum display height allowed *)
  scMinHeight = TagBase+94;
  (* maximum display height allowed *)
  scMaxHeight = TagBase+95;
  (* minimum display depth allowed *)
  scMinDepth = TagBase+96;
  (* maximum display depth allowed *)
  scMaxDepth = TagBase+97;
  (* call this hook for every display mode id *)
  scFilterFunc = fiFilterFunc;

(*** tags for ChangeReqAttrA ***
*)
   (* file requester - set directory *)
  fiDir = TagBase+50;
   (* file requester - set wildcard pattern *)
  fiMatchPat = TagBase+51;
   (* file requester - add a file or directory to the buffer *)
  fiAddEntry = TagBase+52;
   (* file requester - remove a file or directory from the buffer *)
  fiRemoveEntry = TagBase+53;
   (* font requester - set font name of selected font *)
  foFontName = TagBase+63;
   (* font requester - set font size *)
  foFontHeight = TagBase+64;
   (* font requester - set font style *)
  foFontStyle = TagBase+65;
   (* font requester - set font flags *)
  foFontFlags = TagBase+66;
  (* (V38) screenmode requester - get display attributes from screen *)
  scModeFromScreen = TagBase+80;
  (* (V38) screenmode requester - set display mode id (32-bit extended) *)
  scDisplayID = TagBase+81;
  (* (V38) screenmode requester - set display width *)
  scDisplayWidth = TagBase+82;
  (* (V38) screenmode requester - set display height *)
  scDisplayHeight = TagBase+83;
  (* (V38) screenmode requester - set display depth *)
  scDisplayDepth = TagBase+84;
  (* (V38) screenmode requester - set overscan type, 0 for regular size *)
  scOverscanType = TagBase+85;
  (* (V38) screenmode requester - set autoscroll *)
  scAutoScroll = TagBase+86;

(*** tags for PaletteRequestA ***
*)
   (* initially selected color - default 1 *)
  paColor = TagBase+70;

(*** tags for ReqHandlerA ***
*)
   (* end requester by software control, set tagdata to REQ_CANCEL, REQ_OK or
    in case of EZRequest to the return value *)
  rhEndRequest = TagBase+60;

(*** tags for AllocRequestA ***)
  (* no tags defined yet *)


(************
* ReqPos *
************)
  ReqPosPointer = 0;
  ReqPosCenterWin = 1;
  ReqPosCenterScr = 2;
  ReqPosTopLeftWin = 3;
  ReqPosTopLeftScr = 4;

(******************
* RTRH_EndRequest *
******************)
  ReqCancel = 0;
  ReqOK = 1;

(***************************************
* flags for RTFI_Flags and RTFO_Flags  *
* or filereq->Flags and fontreq->Flags *
***************************************)
  fReqNoBuffer = 2;

(*****************************************
* flags for RTFI_Flags or filereq->Flags *
*****************************************)
  fReqMultiSelect = 0;
  fReqSave = 1;
  fReqNoFiles = 3;
  fReqPatGad = 4;
  fReqSelectDirs = 12;

(*****************************************
* flags for RTFO_Flags or fontreq->Flags *
*****************************************)
  fReqFixedWidth = 5;
  fReqColorFonts = 6;
  fReqChangePalette = 7;
  fReqLeavePalette = 8;
  fReqScale = 9;
  fReqStyle = 10;

(*****************************************************
* (V38) flags for RTSC_Flags or screenmodereq->Flags *
*****************************************************)
  scReqSizeGads = 13;
  scReqDepthGad = 14;
  scReqNonStdModes =15;
  scReqGuiModes = 16;
  scReqAutoscrollGad =18;
  scReqOverscanGad =19;

(*****************************************
* flags for RTEZ_Flags or reqinfo->Flags *
*****************************************)
  ezReqNoReturnKey = 0;
  ezReqLamigaQual = 1;
  ezReqCenterText = 2;

(***********************************************
* (V38) flags for RTGL_Flags or reqinfo->Flags *
***********************************************)
  glReqCenterText = ezReqCenterText;
  glReqHighlightText = 3;

(***********************************************
* (V38) flags for RTGS_Flags or reqinfo->Flags *
***********************************************)
  gsReqCenterText = ezReqCenterText;
  gsReqHighlightText = glReqHighlightText;

(*****************************************
* (V38) flags for RTFI_VolumeRequest tag *
*****************************************)
  vReqNoAssigns = 0;
  vReqNoDisks = 1;
  vReqAllDisks = 2;

(*
   Following things are obsolete in ReqTools V38.
   Don't use them in new code!
*)
  fReqDoWildFunc = 11;
  ReqHookWildFile = 0;
  ReqHookWildFont = 1;

PROCEDURE AllocRequestA (type{0}: LONGINT;
                         tagList{8}: TagItemPtr): ADDRESS;        CODE -30;
PROCEDURE AllocRequest (type{0}: LONGINT;
                        tag1{8}: TagItemPtr): ADDRESS;            CODE -30;
PROCEDURE FreeRequest (req{9}: ADDRESS);                          CODE -36;
PROCEDURE FreeReqBuffer (req{9}: ADDRESS);                        CODE -42;
PROCEDURE ChangeReqAttrA (req{9}: ADDRESS;
                          tagList{8}: TagItemPtr);                CODE -48;
PROCEDURE ChangeReqAttr (req{9}: ADDRESS;
                         tag1{8}: TagItemPtr);                    CODE -48;
PROCEDURE FileRequestA (fileReq{9}: FileRequesterPtr;
                (*VAR*) fileName{10}: ADDRESS (*ARRAY OF CHAR*);
                        title{11}: ADDRESS (*ARRAY OF CHAR*);
                        tagList{8}: TagItemPtr): BOOLEAN;         CODE -54;
PROCEDURE FileRequest (fileReq{9}: FileRequesterPtr;
               (*VAR*) fileName{10}: ADDRESS (*ARRAY OF CHAR*);
                       title{11}: ADDRESS (*ARRAY OF CHAR*);
                       tag1{8}: TagItemPtr): ADDRESS;             CODE -54;
PROCEDURE FreeFileList (fileList{8}: FileListPtr);                CODE -60;

(* The next 6 procedures are specialy adjusted for amc modula-2 use
   so that they direcly can be used from out this module.
   Amc use internaly A4 and this register is used by the procedures
   as an argument. So A4 has to be saved 
*)

PROCEDURE EZRequestA (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                      reqInfo{11}: ReqInfoPtr;
                      argarray{2}: ADDRESS;
                      tagList{8}: TagItemPtr): LONGINT;
PROCEDURE EZRequestTags (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                         reqInfo{11}: ReqInfoPtr;
                         argarray{2}: ADDRESS;
                         tag1{8}: TagItemPtr):LONGINT;
PROCEDURE EZRequest (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                     reqInfo{11}: ReqInfoPtr;
                     tagList{8}: TagItemPtr;
                     argarray{2}: ADDRESS (*LONGINT*)): LONGINT;
(* Without result.... *)
PROCEDURE vEZRequestA (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                       reqInfo{11}: ReqInfoPtr;
                       argarray{2}: ADDRESS;
                       tagList{8}: TagItemPtr); 
PROCEDURE vEZRequestTags (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                          reqInfo{11}: ReqInfoPtr;
                          argarray{2}: ADDRESS;
                          tag1{8}: TagItemPtr);
PROCEDURE vEZRequest (bodyfmt{9}, gadfmt{10}: ADDRESS (*ARRAY OF CHAR*);
                      reqInfo{11}: ReqInfoPtr;
                      tagList{8}: TagItemPtr;
                      argarray{2}: ADDRESS (*LONGINT*)); 


PROCEDURE GetStringA ((*VAR*) buffer{9}: ADDRESS (*ARRAY OF CHAR*);
                      maxchars{0}: LONGINT;
                      title{10}: ADDRESS (*ARRAY OF CHAR*);
                      reqInfo{11}: ReqInfoPtr;
                      tagList{8}: TagItemPtr): BOOLEAN;           CODE -72;
PROCEDURE GetString ((*VAR*) buffer{9}: ADDRESS (*ARRAY OF CHAR*);
                     maxchars{0}: LONGINT;
                     title{10}: ADDRESS (*ARRAY OF CHAR*);
                     reqInfo{11}: ReqInfoPtr;
                     tag1{8}: TagItemPtr): BOOLEAN;               CODE -72;
PROCEDURE GetLongA (VAR long{9}: LONGINT; title{10}: ADDRESS (*ARRAY OF CHAR*);
                    reqInfo{11}: ReqInfoPtr;
                    tagList{8}: TagItemPtr): BOOLEAN;             CODE -78;
PROCEDURE GetLong (VAR long{9}: LONGINT; title{10}: ADDRESS (*ARRAY OF CHAR*);
                   reqInfo{11}: ReqInfoPtr;
                   tag1{8}: TagItemPtr): BOOLEAN;                 CODE -78;
PROCEDURE FontRequestA (fontReq{9}: FontRequesterPtr;
                        title{11}: ADDRESS (*ARRAY OF CHAR*);
                        tagList{8}: TagItemPtr): BOOLEAN  ;       CODE -96;
PROCEDURE FontRequest (fontReq{9}: FontRequesterPtr;
                       title{11}: ADDRESS (*ARRAY OF CHAR*);
                       tag1{8}: TagItemPtr):BOOLEAN  ;            CODE -96;
PROCEDURE PaletteRequestA (title{10}: ADDRESS (*ARRAY OF CHAR*);
                           reqInfo{11}: ReqInfoPtr;
                           tagList{8}: TagItemPtr): LONGINT;      CODE -102;
PROCEDURE PaletteRequest (title{10}: ADDRESS (*ARRAY OF CHAR*);
                          reqInfo{11}: ReqInfoPtr;
                          tag1{8}: TagItemPtr): LONGINT;          CODE -102;
PROCEDURE ReqHandlerA (hinfo{9}: HandlerInfoPtr;
                       sigs{0}: LONGSET;
                       tagList{8}: TagItemPtr): LONGINT;          CODE -108;
PROCEDURE ReqHandler (hinfo{9}: HandlerInfoPtr;
                      sigs{0}: LONGSET;
                      tag1{8}: TagItemPtr): LONGINT;              CODE -108;
PROCEDURE SetWaitPointer (window{8}: WindowPtr);                  CODE -114;
PROCEDURE GetVScreenSize (screen{8}: ScreenPtr;
                          VAR width{9},height{10}: LONGINT);      CODE -120;
PROCEDURE SetReqPosition (reqpos{0}: LONGINT;
                          VAR nw{8}: NewWindow;
                          screen{9}: ScreenPtr;
                          window{10}: WindowPtr);                 CODE -126;
PROCEDURE Spread ((*VAR*) posarray{8}: ADDRESS (*ARRAY OF LONGINT*);
                  sizearray{9}: ADDRESS (*ARRAY OF LONGINT*);
                  totalsize{0}, min{1}, max{2}, num{3}: LONGINT); CODE -132;
PROCEDURE ScreenToFrontSafely (screen{8}: ScreenPtr);             CODE -138;

(*--- functions in V38 or higher (distributed as Release 2.0) ---*)
PROCEDURE ScreenModeRequestA (screenmodeReq{9}: ScreenModeRequesterPtr;
                              title{11}: ADDRESS (*ARRAY OF CHAR*);
                              tagList{8}: TagItemPtr): BOOLEAN;   CODE -144;
PROCEDURE ScreenModeRequest (screenmodeReq{9}: ScreenModeRequesterPtr;
                             title{11}: ADDRESS (*ARRAY OF CHAR*);
                             tag1{8}: TagItemPtr): BOOLEAN;       CODE -144;
PROCEDURE CloseWindowSafely (window{8}: WindowPtr);               CODE -150;
PROCEDURE LockWindow (window{8}: WindowPtr): LONGINT;             CODE -156;
PROCEDURE UnlockWindow (window{8}: WindowPtr;
                        winlock{9}: LONGINT);                     CODE -162;


PROCEDURE EasyFileReq(VAR fname:ARRAY OF CHAR; win:ADDRESS; title:ARRAY OF CHAR;
                       x,y:INTEGER; VAR pattern:ARRAY OF CHAR; save:BOOLEAN):BOOLEAN;

END ReqTools.
