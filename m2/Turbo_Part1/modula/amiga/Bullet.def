DEFINITION FOR LIBRARY MODULE Bullet ;

FROM SYSTEM	IMPORT STRING, ADDRESS ;
FROM Utility	IMPORT TAG_USER, TagItemPtr, Tag ;
FROM Exec	IMPORT MinNode, LibraryPtr ;

TYPE
  GlyphEnginePtr	= POINTER TO GlyphEngine ;
  GlyphMapPtr		= POINTER TO GlyphMap ;
  GlyphWidthEntryPtr	= POINTER TO GlyphWidthEntry ;

(* tag definitions for .otag files *)

CONST
(* Level 0 entries never appear in the .otag tag list, but appear in font *)
(* specifications							  *)

  OT_Level0		= TAG_USER ;

(* Level 1 entries are required to exist in the .otag tag list *)

  OT_Level1		= TAG_USER+01000H ;

(* Level 2 entries are optional typeface metric tags	*)

  OT_Level2		= TAG_USER+02000H ;

(* Level 3 entries are required for some OT_Engines	*)

  OT_Level3		= TAG_USER+03000H ;

(* Indirect entries are at (tag address+data offset)	*)

  OT_Indirect		= 08000H ;

(*=========================================================================*)
(* font specification and inquiry tags					   *)

(* !  tags flagged with an exclaimation mark are valid for		   *)
(*    specification.							   *)
(*  ? tags flagged with a question mark are valid for inquiry		   *)
(*									   *)
(* fixed binary numbers are encoded as 16 bits of integer and		   *)
(* 16 bits of fraction.  Negative values are indicated by twos		   *)
(* complement of all 32 bits.						   *)

(* !  OT_DeviceDPI specifies the target device dots per inch -- X DPI is   *)
(*    in the high word, Y DPI in the low word.				   *)

  OT_DeviceDPI		= OT_Level0+001H ;	(* == TA_DeviceDPI *)

(* !  OT_DotSize specifies the target device dot size as a percent of	   *)
(*    it's resolution-implied size -- X percent in high word, Y percent    *)
(*    in low word.							   *)

  OT_DotSize		= OT_Level0+002H ;

(* !  OT_PointHeight specifies the requested point height of a typeface,   *)
(*    specifically, the height and nominal width of the em-square.	   *)
(*    The point referred to here is 1/72".  It is encoded as a fixed	   *)
(*    binary number.							   *)

  OT_PointHeight	= OT_Level0+008H ;

(* !  OT_SetFactor specifies the requested set width of a typeface.	   *)
(*    It distorts the width of the em-square from that specified by	   *)
(*    OT_PointHeight.  To compensate for a device with different	   *)
(*    horizontal and vertical resolutions, OT_DeviceDPI should be used	   *)
(*    instead.	For a normal aspect ratio, set to 1.0 (encoded as	   *)
(*    000010000H).  This is the default value.				   *)

  OT_SetFactor		= OT_Level0+009H ;

(* !  OT_Shear... specifies the Sine and Cosine of the vertical stroke	   *)
(*    angle, as two fixed point binary fractions.  Both must be specified: *)
(*    first the Sine and then the Cosine.  Setting the sine component	   *)
(*    changes the Shear to an undefined value, setting the cosine	   *)
(*    component completes the Shear change to the new composite value.	   *)
(*    For no shear, set to 0.0, 1.0 (encoded as 000000000H, 000010000H).   *)
(*    This is the default value.					   *)

  OT_ShearSin		= OT_Level0+00AH ;
  OT_ShearCos		= OT_Level0+00BH ;

(* !  OT_Rotate... specifies the Sine and Cosine of the baselin rotation   *)
(*    angle, as two fixed point binary fractions.  Both must be specified: *)
(*    first the Sine and then the Cosine.  Setting the sine component	   *)
(*    changes the Shear to an undefined value, setting the cosine	   *)
(*    component completes the Shear change to the new composite value.	   *)
(*    For no shear, set to 0.0, 1.0 (encoded as 000000000H, 000010000H).   *)
(*    This is the default value.					   *)

  OT_RotateSin		= OT_Level0+00CH ;
  OT_RotateCos		= OT_Level0+00DH ;

(* !  OT_Embolden... specifies values to algorithimically embolden -- or,  *)
(*    when negative, lighten -- the glyph.  It is encoded as a fixed point *)
(*    binary fraction of the em-square.  The X and Y components can be	   *)
(*    changed indendently.  For normal characters, set to 0.0, 0.0	   *)
(*    (encoded as 000000000H, 000000000H).  This is the default value.	   *)

  OT_EmboldenX		= OT_Level0+00EH ;
  OT_EmboldenY		= OT_Level0+00FH ;

(* !  OT_PointSize is an old method of specifying the point size,	   *)
(*    encoded as (points * 16).						   *)

  OT_PointSize		= OT_Level0+010H ;

(* !  OT_GlyphCode specifies the glyph (character) code to use with	   *)
(*    subsequent operations.  For example, this is the code for an	   *)
(*    OT_Glyph inquiry							   *)

  OT_GlyphCode		= OT_Level0+011H ;

(* !  OT_GlyphCode2 specifies the second glyph code.  For example,	   *)
(*    this is the right glyph of the two glyphs of an OT_KernPair	   *)
(*    inquiry								   *)

  OT_GlyphCode2		= OT_Level0+012H ;

(* !  OT_GlyphWidth specifies a specific width for a glyph.		   *)
(*    It sets a specific escapement (advance) width for subsequent	   *)
(*    glyphs.  It is encoded as a fixed binary fraction of the em-square.  *)
(*    To revert to using the font-defined escapement for each glyph, set   *)
(*    to 0.0 (encoded as 000000000H).  This is the default value.	   *)

  OT_GlyphWidth		= OT_Level0+013H ;

(* !  OT_OTagPath and							   *)
(* !  OT_OTagList specify the selected typeface.  Both must be specified:  *)
(*    first the Path and then the List.  Setting the path name changes	   *)
(*    changes the typeface to an undefined value, providing the List	   *)
(*    completes the typeface selection to the new typeface.  OTagPath	   *)
(*    is the null terminated full file path of the .otag file associated   *)
(*    with the typeface.  OTagList is a memory copy of the processed	   *)
(*    contents of that .otag file (i.e. with indirections resolved).	   *)
(*    There are no default values for the typeface. 			   *)

  OT_OTagPath		= OT_Level0+OT_Indirect+014H ;
  OT_OTagList		= OT_Level0+OT_Indirect+015H ;

(*  ? OT_GlyphMap supplies a read-only struct GlyphMap pointer that	   *)
(*    describes a bitmap for a glyph with the current attributes.	   *)

  OT_GlyphMap		= OT_Level0+OT_Indirect+020H ;

(*  ? OT_WidthList supplies a read-only struct MinList of struct	   *)
(*    GlyphWidthEntry nodes for glyphs that are defined from GlyphCode	   *)
(*    to GlyphCode2, inclusive.  The widths are represented as fixed	   *)
(*    binary fractions of the em-square, ignoring any effect of		   *)
(*    SetFactor or GlyphWidth.	A width would need to be converted to	   *)
(*    a distance along the baseline in device units by the		   *)
(*    application.							   *)

  OT_WidthList		= OT_Level0+OT_Indirect+021H ;

(*  ? OT_...KernPair supplies the kern adjustment to be added to the	   *)
(*    current position after placement of the GlyphCode glyph and	   *)
(*    before placement of the GlyphCode2 glyph.  Text kern pairs are	   *)
(*    for rendering body text.	Display kern pairs are generally	   *)
(*    tighter values for display (e.g. headline) purposes.  The		   *)
(*    adjustment is represented as a fixed binary fraction of the	   *)
(*    em-square, ignoring any effect of SetFactor.  This number would	   *)
(*    need to be converted to a distance along the baseline in device      *)
(*    units by the application.						   *)

  OT_TextKernPair	= OT_Level0+OT_Indirect+022H ;
  OT_DesignKernPair	= OT_Level0+OT_Indirect+023H ;

(*  ? OT_Underlined is an unsigned word which is used to request	   *)
(*    algorithimic underlining for the engine when rendering the glyph.	   *)
(*    Bullet.library currently does not support this tag, though it	   *)
(*    may be used by other engines in the future.  The default for	   *)
(*    any engine which supports this tag must be OTUL_None.  Engines which *)
(*    do not support this tag should return an appropriate OTERR value.	   *)
(*									   *)
(*    As of V39, diskfont.library will request underlining if specified    *)
(*    in the TextAttr, or TTextAttr passed to OpenDiskFont().  Diskfont	   *)
(*    will first request Broken underlining (like the Text() function	   *)
(*    does when SetSoftStyle() is used), and then Solid underlining if	   *)
(*    the engine returns an error.  If the engine returns an error for	   *)
(*    both, then diskfont.library attempts to find, or create the best	   *)
(*    non-underlined font that it can. *)

  OT_UnderLined		= OT_Level0+024H ;

  OTUL_None		= 0 ;
  OTUL_Solid		= 1 ;
  OTUL_Broken		= 2 ;
  OTUL_DoubleSolid	= 3 ;
  OUTL_DoubleBroken	= 4 ;(* typo ??? *)
  OTUL_DoubleBroken	= 4 ;

(*  ? OT_StrikeThrough is a boolean which is used to request		   *)
(*    algorithimic strike through when rendering the glyph.		   *)
(*    Bullet.library currently does not support this tag, though it	   *)
(*    may be used by other engines in the future.  The default for	   *)
(*    any engined which supports this tag must be FALSE.  Engines which	   *)
(*    do not support this tag should return an appropriate OTERR value.	   *)

  OT_StrikeThrough	= OT_Level0+025H ;


(*=========================================================================*)
(* .otag tags								   *)

(* suffix for files in FONTS: that contain these tags *)

  OTSUFFIX		= ".otag" ;

(* OT_FileIdent both identifies this file and verifies its size.
 * It is required to be the first tag in the file. *)

  OT_FileIdent		= OT_Level1+001H ;

(* OT_Engine specifies the font engine this file is designed to use *)
  OT_Engine		= OT_Level1+OT_Indirect+002H ;

  OTE_Bullet		= "bullet" ;

(* OT_Family is the family name of this typeface *)

  OT_Family		= OT_Level1+OT_Indirect+003H ;

(* The name of this typeface is implicit in the name of the .otag file  *)
(* OT_BName is used to find the bold variant of this typeface		*)

  OT_BName		= OT_Level2+OT_Indirect+005H ;

(* OT_IName is used to find the italic variant of this typeface *)

  OT_IName		= OT_Level2+OT_Indirect+006H ;

(* OT_BIName is used to find the bold italic variant of this typeface *)

  OT_BIName		= OT_Level2+OT_Indirect+007H ;

(* OT_SymSet is used to select the symbol set that has the OT_YSizeFactor *)
(* described here.  Other symbol sets might have different extremes	  *)

  OT_SymbolSet		= OT_Level1+010H ;

(* OT_YSizeFactor is a ratio to assist in calculating the Point height	  *)
(* to BlackHeight relationship -- high word: Point height term, low	  *)
(* word: Black height term -- pointSize = ysize*<high>/<low>		  *)

  OT_YSizeFactor	= OT_Level1+011H ;

(* OT_SpaceWidth specifies the width of the space character relative	  *)
(* to the character height 						  *)

  OT_SpaceWidth		= OT_Level2+012H ;

(* OT_IsFixed is a boolean indicating that all the characters in the	  *)
(* typeface are intended to have the same character advance 		  *)

  OT_IsFixed		= OT_Level2+013H ;

(* OT_SerifFlag is a boolean indicating if the character has serifs	    *)

  OT_SerifFlag		= OT_Level1+014H ;

(* OT_StemWeight is an unsigned byte indicating the weight of the character *)

  OT_StemWeight	= OT_Level1+015H ;

  OTS_UltraThin		=   8 ;	(*   0- 15 *)
  OTS_ExtraThin		=  24 ;	(*  16- 31 *)
  OTS_Thin	 	=  40 ;	(*  32- 47 *)
  OTS_ExtraLight	=  56 ;	(*  48- 63 *)
  OTS_Light	 	=  72 ;	(*  64- 79 *)
  OTS_DemiLight		=  88 ;	(*  80- 95 *)
  OTS_SemiLight		= 104 ;	(*  96-111 *)
  OTS_Book		= 120 ;	(* 112-127 *)
  OTS_Medium		= 136 ;	(* 128-143 *)
  OTS_SemiBold		= 152 ;	(* 144-159 *)
  OTS_DemiBold		= 168 ;	(* 160-175 *)
  OTS_Bold		= 184 ;	(* 176-191 *)
  OTS_ExtraBold		= 200 ;	(* 192-207 *)
  OTS_Black		= 216 ;	(* 208-223 *)
  OTS_ExtraBlack	= 232 ;	(* 224-239 *)
  OTS_UltraBlack	= 248 ;	(* 240-255 *)

(* OT_SlantStyle is an unsigned byte indicating the font posture *)

  OT_SlantStyle	= OT_Level1+016H ;

  OTS_Upright		= 0 ;
  OTS_Italic		= 1 ;	(* Oblique, Slanted, etc. *)
  OTS_LeftItalic	= 2 ;	(* Reverse Slant	  *)

(* OT_HorizStyle is an unsigned byte indicating the appearance width *)

  OT_HorizStyle	= OT_Level1+017H ;

  OTH_UltraCompressed	=  16 ;	(*   0- 31 *)
  OTH_ExtraCompressed	=  48 ;	(*  32- 63 *)
  OTH_Compressed	=  80 ;	(*  64- 95 *)
  OTH_Condensed		= 112 ;	(*  96-127 *)
  OTH_Normal		= 144 ;	(* 128-159 *)
  OTH_SemiExpanded	= 176 ;	(* 160-191 *)
  OTH_Expanded		= 208 ;	(* 192-223 *)
  OTH_ExtraExpanded	= 240 ;	(* 224-255 *)

(* OT_SpaceFactor specifies the width of the space character relative	*)
(* to the character height						*)

  OT_SpaceFactor	= OT_Level2+018H ;

(* OT_InhibitAlgoStyle indicates which ta_Style bits, if any, should	*)
(* be ignored even if the font does not already have that quality.	*)
(* For example, if FSF_BOLD is set and the typeface is not bold but	*)
(* the user specifies bold, the application or diskfont library is	*)
(* not to use OT_Embolden to achieve a bold result.			*)

  OT_InhibitAlgoStyle	= OT_Level2+019H ;

(* OT_AvailSizes is an indirect pointer to sorted UWORDs, 0th is count *)

  OT_AvailSizes	= OT_Level1+OT_Indirect+020H ;

  OT_MAXAVAILSIZES	= 20 ;	(* no more than 20 sizes allowed *)

(* OT_SpecCount is the count number of parameters specified here *)

  OT_SpecCount		= OT_Level1+0100H ;

(* Specs can be created as appropriate for the engine by ORing in the	*)
(* parameter number (1 is first, 2 is second, ... up to 15th)		*)

  OT_Spec		= OT_Level1+0100H ;

(* OT_Spec1 is the (first) parameter to the font engine to select	*)
(* this particular typeface						*)

  OT_Spec1		= OT_Level1+0101H ;

(* structures for glyph libraries *)

(* A GlyphEngine must be acquired via OpenEngine and is read-only *)

TYPE
  GlyphEngine = RECORD
    gle_Library : LibraryPtr ; (* engine library			*)
    gle_Name	: STRING     ; (* library basename: e.g. "bullet"	*)
    (* private library data follows... *)
  END ;

  FIXED = LONGINT ;		(* 32 bit signed w/ 16 bits of fraction *)

TYPE
  GlyphMap = RECORD
    glm_BMModulo	: CARDINAL ; (* # of bytes in row: always multiple of4*)
    glm_BMRows		: CARDINAL ; (* # of rows in bitmap		      *)
    glm_BlackLeft	: CARDINAL ; (* # of blank pixel columns at left      *)
    glm_BlackTop	: CARDINAL ; (* # of blank rows at top		      *)
    glm_BlackWidth	: CARDINAL ; (* span of contiguous non-blank columns  *)
    glm_BlackHeight	: CARDINAL ; (* span of contiguous non-blank rows     *)
    glm_XOrigin		: FIXED    ; (* distance from upper left corner of bit*)
    glm_YOrigin		: FIXED    ; (* map to initial CP,in fractional pixels*)
    glm_X0		: INTEGER  ; (* approximatn of XOrigin in whole pixels*)
    glm_Y0		: INTEGER  ; (* approximatn of YOrigin in whole pixels*)
    glm_X1		: INTEGER  ; (* approximation of XOrigin+Width        *)
    glm_Y1		: INTEGER  ; (* approximation of YOrigin+Width        *)
    glm_Width		: FIXED    ; (* character advance , as fraction of em *)
    				     (*  width				      *)
    glm_BitMap		: ADDRESS  ; (* actual glyph bitmap		      *)
  END ;

TYPE
  GlyphWidthEntry = RECORD
    gwe_Node : MinNode  ;	(* on list returned by OT_WidthList inquiry   *)
    gwe_Code : CARDINAL ;	(* entry's character code value		      *)
    gwe_Width: FIXED ;		(* character advance, as fraction of em width *)
  END ;

(* error results from outline libraries *)

(* PRELIMINARY *)
CONST
  OTERR_Failure		= -1 ;	(* catch-all for error			*)
  OTERR_Success		=  0 ;	(* no error				*)
  OTERR_BadTag		=  1 ;	(* inappropriate tag for function	*)
  OTERR_UnknownTag	=  2 ;	(* unknown tag for function		*)
  OTERR_BadData		=  3 ;	(* catch-all for bad tag data		*)
  OTERR_NoMemory	=  4 ;	(* insufficient memory for operation	*)
  OTERR_NoFace		=  5 ;	(* no typeface currently specified	*)
  OTERR_BadFace		=  6 ;	(* typeface specification problem	*)
  OTERR_NoGlyph		=  7 ;	(* no glyph specified			*)
  OTERR_BadGlyph	=  8 ;	(* bad glyph code or glyph range	*)
  OTERR_NoShear		=  9 ;	(* shear only partially specified	*)
  OTERR_NoRotate	= 10 ;	(* rotate only partially specified	*)
  OTERR_TooSmall	= 11 ;	(* typeface metrics yield tiny glyphs	*)
  OTERR_UnknownGlyph	= 12 ;	(* glyph not known by engine		*)

VAR
  BulletBase : LibraryPtr ;

PROCEDURE OpenEngine( ) : GlyphEnginePtr ;
PROCEDURE CloseEngine( glyphEng : GlyphEnginePtr ) ;
PROCEDURE SetInfoA( glyphEng : GlyphEnginePtr ; tags : TagItemPtr ) : LONGINT ;
PROCEDURE SetInfo( glyphEng : GlyphEnginePtr ; tag1 : Tag ; .. ) : LONGINT ;
PROCEDURE ObtainInfoA( glyphEng: GlyphEnginePtr ; tags: TagItemPtr ) : LONGINT ;
PROCEDURE ObtainInfo( glyphEng : GlyphEnginePtr ; tag1 : Tag ; .. ) : LONGINT ;
PROCEDURE ReleaseInfoA( glyphEng: GlyphEnginePtr ; tags: TagItemPtr ): LONGINT ;
PROCEDURE ReleaseInfo( glyphEng : GlyphEnginePtr ; tag1 : Tag ; .. ) : LONGINT ;

END Bullet.
