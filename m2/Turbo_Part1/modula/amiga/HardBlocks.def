DEFINITION FOR C MODULE HardBlocks ;

FROM SYSTEM IMPORT LONGSET ;

TYPE
  RigidDiskBlockPtr	= POINTER TO RigidDiskBlock	;
  BadBlockEntryPtr	= POINTER TO BadBlockEntry	;
  BadBlockBlockPtr	= POINTER TO BadBlockBlock	;
  PartitionBlockPtr	= POINTER TO PartitionBlock	;
  FileSysHeaderBlockPtr = POINTER TO FileSysHeaderBlock ;
  LoadSegBlockPtr	= POINTER TO LoadSegBlock	;

(*--------------------------------------------------------------------
 *
 *	This file describes blocks of data that exist on a hard disk
 *	to describe that disk.  They are not generically accessable to
 *	the user as they do not appear on any DOS drive.  The blocks
 *	are tagged with a unique identifier, checksummed, and linked
 *	together.  The root of these blocks is the RigidDiskBlock.
 *
 *	The RigidDiskBlock must exist on the disk within the first
 *	RDB_LOCATION_LIMIT blocks.  This inhibits the use of the zero
 *	cylinder in an AmigaDOS partition: although it is strictly
 *	possible to store the RigidDiskBlock data in the reserved
 *	area of a partition, this practice is discouraged since the
 *	reserved blocks of a partition are overwritten by "Format",
 *	"Install", "DiskCopy", etc.  The recommended disk layout,
 *	then, is to use the first cylinder(s) to store all the drive
 *	data specified by these blocks: i.e. partition descriptions,
 *	file system load images, drive bad block maps, spare blocks,
 *	etc.
 *
 *	Though only 512 byte blocks are currently supported by the
 *	file system, this proposal tries to be forward-looking by
 *	making the block size explicit, and by using only the first
 *	256 bytes for all blocks but the LoadSeg data.
 *
 *------------------------------------------------------------------*)

(*  NOTE								*)
(*	optional block addresses below contain FFFFFFFFH to indicate	*)
(*	a NULL address, as zero is a valid address			*)

TYPE
  RigidDiskBlock = RECORD
    rdb_ID		   : LONGINT ; (* 4 character identifier	      *)
    rdb_SummedLongs	   : LONGINT ; (* size of this checksummed structure  *)
    rdb_ChkSum		   : LONGINT ; (* block checksum(longword sum to zero)*)
    rdb_HostID		   : LONGINT ; (* SCSI Target ID of host	      *)
    rdb_BlockBytes	   : LONGINT ; (* size of disk blocks		      *)
    rdb_Flags		   : LONGSET ; (* see below for defines		      *)

    (* block list heads *)

    rdb_BadBlockList	   : LONGINT ; (* optional bad block list	    *)
    rdb_PartitionList	   : LONGINT ; (* optional first partition block    *)
    rdb_FileSysHeaderList  : LONGINT ; (* optional file system header block *)
    rdb_DriveInit	   : LONGINT ; (* optional drive-specific init code *)
			      (* DriveInit(lun,rdb,ior): "C" stk & d0/a0/a1 *)

    rdb_Reserved1	   : ARRAY [0..5] OF LONGINT; (* set to FFFFFFFFH *)

    (* physical drive characteristics *)

    rdb_Cylinders	: LONGINT ; (* number of drive cylinders*)
    rdb_Sectors		: LONGINT ; (* sectors per track	*)
    rdb_Heads		: LONGINT ; (* number of drive heads	*)
    rdb_Interleave	: LONGINT ; (* interleave		*)
    rdb_Park		: LONGINT ; (* landing zone cylinder	*)
    rdb_Reserved2	: ARRAY [0..2] OF LONGINT ;
    rdb_WritePreComp	: LONGINT ;(* starting cylinder:write precompensation *)
    rdb_ReducedWrite	: LONGINT ;(* starting cylinder:reduced write current *)
    rdb_StepRate	: LONGINT ;(* drive step rate			      *)
    rdb_Reserved3	: ARRAY [0..4] OF LONGINT ;

    (* logical drive characteristics *)

    rdb_RDBBlocksLo     : LONGINT;(* low block of range reserved forhardblocks*)
    rdb_RDBBlocksHi     : LONGINT;(* high block of range for these hardblocks *)
    rdb_LoCylinder	: LONGINT;(* low cylinder of partitionable disk area  *)
    rdb_HiCylinder	: LONGINT;(* high cylinder of partitionable data area *)
    rdb_CylBlocks	: LONGINT;(* number of blocks available per cylinder  *)
    rdb_AutoParkSeconds : LONGINT;(* zero for no auto park		      *)
    rdb_Reserved4	: ARRAY [0..1] OF LONGINT;

    (* drive identification *)

    rdb_DiskVendor	   : ARRAY [0..07] OF CHAR ;
    rdb_DiskProduct	   : ARRAY [0..15] OF CHAR ;
    rdb_DiskRevision	   : ARRAY [0..03] OF CHAR ;
    rdb_ControllerVendor   : ARRAY [0..07] OF CHAR ;
    rdb_ControllerProduct  : ARRAY [0..15] OF CHAR ;
    rdb_ControllerRevision : ARRAY [0..03] OF CHAR ;
    rdb_Reserved5	   : ARRAY [0..09] OF LONGINT ;
  END;

CONST
  IDNAME_RIGIDDISK	= 5244534BH ;   (* RDSK *)

  RDB_LOCATION_LIMIT	= 16  ;

  RDBFB_LAST		=  0  ;	(* no disks exist to be configured after      *)
  RDBFF_LAST		= {0} ;	(* this one on this controller		      *)
  RDBFB_LASTLUN		=  1  ;	(* no LUNs exist to be configured greater     *)
  RDBFF_LASTLUN		= {1} ;	(* than this one at this SCSI Target ID       *)
  RDBFB_LASTTID		=  2  ;	(* no Target IDs exist to be configured       *)
  RDBFF_LASTTID		= {2} ;	(* greater than this one on this SCSI bus     *)
  RDBFB_NORESELECT	=  3  ;	(* don't bother trying to perform reselection *)
  RDBFF_NORESELECT	= {3} ;	(* when talking to this drive		      *)
  RDBFB_DISKID		=  4  ;	(* rdb_Disk... identification valid	      *)
  RDBFF_DISKID		= {4} ;
  RDBFB_CTRLRID		=  5  ;	(* rdb_Controller... identification valid     *)
  RDBFF_CTRLRID		= {5} ;
				(* added 7/20/89 by commodore:		      *)
  RDBFB_SYNCH		= 6   ;	(* drive supports scsi synchronous mode	      *)
  RDBFF_SYNCH		= {6} ; (* CAN BE DANGEROUS TO USE IF IT DOESN'T!     *)

(*------------------------------------------------------------------*)

TYPE
  BadBlockEntry = RECORD
    bbe_BadBlock  : LONGINT ; (* block number of bad block	   *)
    bbe_GoodBlock : LONGINT ; (* block number of replacement block *)
  END;

  BadBlockBlock = RECORD
    bbb_ID		: LONGINT ; (* 4 character identifier		      *)
    bbb_SummedLongs	: LONGINT ; (* size of this checksummed structure     *)
    bbb_ChkSum		: LONGINT ; (* block checksum (longword sum to zero)  *)
    bbb_HostID		: LONGINT ; (* SCSI Target ID of host		      *)
    bbb_Next		: LONGINT ; (* block number of the next BadBlockBlock *)
    bbb_Reserved	: LONGINT ;
    bbb_BlockPairs	: ARRAY [0..60] OF BadBlockEntry ;
    			(* bad block entry pairs		*)
			(* note [0..60] assumes 512 byte blocks *)
  END;

CONST
   IDNAME_BADBLOCK = 42414442H ;   (* BADB *)

(*------------------------------------------------------------------*)

TYPE
  PartitionBlock = RECORD
    pb_ID	   : LONGINT ;	(* 4 character identifier		   *)
    pb_SummedLongs : LONGINT ;	(* size of this checksummed structure      *)
    pb_ChkSum	   : LONGINT ;	(* block checksum (longword sum to zero)   *)
    pb_HostID	   : LONGINT ;	(* SCSI Target ID of host		   *)
    pb_Next	   : LONGINT ;	(* block number of the next PartitionBlock *)
    pb_Flags	   : LONGSET ;	(* see below for defines		   *)
    pb_Reserved1   : ARRAY [0..1] OF LONGINT ;
    pb_DevFlags	   : LONGSET ;	(* preferred flags for OpenDevice	   *)
    pb_DriveName   : ARRAY [0..31] OF CHAR ;
    				(* preferred DOS device name: BSTR form    *)
				(* (not used if this name is in use)	   *)
    pb_Reserved2   : ARRAY [0..14] OF LONGINT ;
    				(* filler to 32 longwords		   *)
    pb_Environment : ARRAY [0..16] OF LONGINT ;
    				(* environment vector for this partition   *)
    pb_EReserved   : ARRAY [0..14] OF LONGINT ;
    				(* reserved for future environment vector  *)
  END;

CONST
  IDNAME_PARTITION = 50415254H ;    (* PART *)

  PBFB_BOOTABLE	   =  0  ; (* this partition is intended to be bootable  *)
  PBFF_BOOTABLE	   = {0} ; (*  (expected directories and files exist)    *)

  PBFB_NOMOUNT	   =  1  ; (* do not mount this partition (e.g. manually *)
  PBFF_NOMOUNT	   = {1} ; (*  mounted, but space reserved here)	 *)

(*------------------------------------------------------------------*)

TYPE
  FileSysHeaderBlock = RECORD
    fhb_ID	    : LONGINT ;	(* 4 character identifier		     *)
    fhb_SummedLongs : LONGINT ;	(* size of this checksummed structure	     *)
    fhb_ChkSum	    : LONGINT ;	(* block checksum (longword sum to zero)     *)
    fhb_HostID	    : LONGINT ;	(* SCSI Target ID of host		     *)
    fhb_Next	    : LONGINT ;	(* block number of next FileSysHeaderBlock   *)
    fhb_Flags	    : LONGSET ;	(* see below for defines		     *)
    fhb_Reserved1   : ARRAY [0..1] OF LONGINT ;
    fhb_DosType	    : LONGINT ;	(* file system description: match this with  *)
				(* partition environment's DE_DOSTYPE entry  *)
    fhb_Version	    : LONGINT ;	(* release version of this code		     *)
    fhb_PatchFlags  : LONGSET ;	(* bits set for those of the following that  *)
				(*   need to be substituted into a standard  *)
				(*   device node for this file system: e.g.  *)
				(*   0x180 to substitute SegList & GlobalVec *)
    fhb_Type	    : LONGINT ;	(* device node TYPE: zero		     *)
    fhb_Task	    : LONGINT ;	(* standard dos "task" field: zero	     *)
    fhb_Lock	    : LONGINT ;	(* not used for devices: zero		     *)
    fhb_Handler	    : LONGINT ;	(* filename to loadseg: zero placeholder     *)
    fhb_StackSize   : LONGINT ;	(* stacksize to use when starting task	     *)
    fhb_Priority    : LONGINT ;	(* task priority when starting task	     *)
    fhb_Startup     : LONGINT ;	(* startup msg: zero placeholder	     *)
    fhb_SegListBlocks : LONGINT;(* first of linked list of LoadSegBlocks:    *)
				(*   note that this entry requires some      *)
				(*   processing before substitution	     *)
    fhb_GlobalVec : LONGINT ;   (* BCPL global vector when starting task     *)
    fhb_Reserved2 : ARRAY [0..22] OF LONGINT;(*(those reserved by PatchFlags)*)
    fhb_Reserved3 : ARRAY [0..20] OF LONGINT;
  END;

CONST
  IDNAME_FILESYSHEADER = 46534844H ; (* FSHD *)

(*------------------------------------------------------------------*)

TYPE
  LoadSegBlock = RECORD
    lsb_ID	    : LONGINT ;	(* 4 character identifier		 *)
    lsb_SummedLongs : LONGINT ;	(* size of this checksummed structure	 *)
    lsb_ChkSum	    : LONGINT ;	(* block checksum (longword sum to zero) *)
    lsb_HostID	    : LONGINT ;	(* SCSI Target ID of host		 *)
    lsb_Next	    : LONGINT ;	(* block number of the next LoadSegBlock *)
    lsb_LoadData    : ARRAY [0..122] OF LONGINT ;  (* data for "loadseg" *)
    (* note [123] assumes 512 byte blocks *)
  END;

CONST
  IDNAME_LOADSEG = 4C534547H ; (* LSEG *)

END HardBlocks.
