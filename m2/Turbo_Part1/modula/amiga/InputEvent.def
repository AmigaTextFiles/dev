DEFINITION FOR C MODULE InputEvent ;

FROM SYSTEM IMPORT SHORTSET , ADDRESS ;
IMPORT Timer , Utility ;

TYPE
  IEPointerPixelPtr	= POINTER TO IEPointerPixel  ;
  IEPointerTabletPtr	= POINTER TO IEPointerTablet ;
  IENewTabletPtr	= POINTER TO IENewTablet     ;
  InputEventPtr		= POINTER TO InputEvent	     ;

(*----- constants --------------------------------------------------*)

(*  --- InputEvent.ie_Class --- *)

CONST
  IECLASS_NULL		= 000H ; (* A NOP input event			      *)
  IECLASS_RAWKEY	= 001H ; (* A raw keycode from the keyboard device    *)

  IECLASS_RAWMOUSE	= 002H ; (* The raw mouse report from the game port   *)
  				 (* device				      *)

  IECLASS_EVENT		= 003H ; (* A private console event		      *)
  IECLASS_POINTERPOS	= 004H ; (* A Pointer Position report		      *)
  IECLASS_TIMER		= 006H ; (* A timer event			      *)

  IECLASS_GADGETDOWN	= 007H ; (* select button pressed down over a	      *)
  				 (* Gadget (address in ie_EventAddress)	      *)

  IECLASS_GADGETUP	= 008H ; (* select button released over the same      *)
  				 (* Gadget (address in ie_EventAddress)	      *)

  IECLASS_REQUESTER	= 009H ; (* some Requester activity has taken place.  *)
  				 (* See Codes REQCLEAR and REQSET	      *)

  IECLASS_MENULIST	= 00AH ; (* this is a Menu Number transmission        *)
  				 (* (Menu number is in ie_Code)		      *)
  IECLASS_CLOSEWINDOW	= 00BH ; (* User has selected the active Window's     *)
  				 (* Close Gadget			      *)

  IECLASS_SIZEWINDOW	= 00CH ; (* this Window has a new size		      *)
  IECLASS_REFRESHWINDOW	= 00DH ; (* the Window pointed to by ie_EventAddress  *)
  				 (* needs to be refreshed		      *)

  IECLASS_NEWPREFS	= 00EH ; (* new preferences are available	      *)
  IECLASS_DISKREMOVED	= 00FH ; (* the disk has been removed		      *)
  IECLASS_DISKINSERTED	= 010H ; (* the disk has been inserted		      *)
  IECLASS_ACTIVEWINDOW	= 011H ; (* the window is about to be been made active*)


  IECLASS_INACTIVEWINDOW = 012H ; (* the window is about to be made inactive  *)
  IECLASS_NEWPOINTERPOS	 = 013H ; (* extended-function pointer position report*)
  IECLASS_MENUHELP	 = 014H ; (* Help key report during Menu session (V36)*)

  IECLASS_CHANGEWINDOW	 = 015H ; (* the Window has been modified with move   *)
  				  (* size, zoom, or change (V36)	      *)

  IECLASS_MAX		 = 015H ; (* the last class			      *)


(*  --- InputEvent.ie_SubClass --- *)
(*  IECLASS_NEWPOINTERPOS *)

  IESUBCLASS_COMPATIBLE	 = 000H ; (* like IECLASS_POINTERPOS		      *)

  IESUBCLASS_PIXEL	 = 001H ; (* ie_EventAddress points to struct	      *)
  				  (* IEPointerPixel			      *)

  IESUBCLASS_TABLET	 = 002H ; (* ie_EventAddress points to struct	      *)
  				  (* IEPointerTablet			      *)

  IESUBCLASS_NEWTABLET   = 003H ; (* ie_EventAddress points to IENewTablet    *)

(* pointed to by ie_EventAddress for IECLASS_NEWPOINTERPOS,	*)
(* and IESUBCLASS_PIXEL.					*)
(*								*)
(* You specify a screen and pixel coordinates in that screen	*)
(* at which you'd like the mouse to be positioned.		*)
(* Intuition will try to oblige, but there will be restrictions	*)
(* to positioning the pointer over offscreen pixels.		*)
(*								*)
(* IEQUALIFIER_RELATIVEMOUSE is supported for IESUBCLASS_PIXEL.	*)

TYPE
  IEPointerPixel = RECORD
    iepp_Screen : ADDRESS ; (* pointer to an open screen	*)
    iepp_Position : RECORD X,Y : INTEGER END ;
    			    (* pixel coordinates in iepp_Screen *)
  END ;

(* pointed to by ie_EventAddress for IECLASS_NEWPOINTERPOS,		*)
(* and IESUBCLASS_TABLET.						*)
(*									*)
(* You specify a range of values and a value within the range		*)
(* independently for each of X and Y (the minimum value of		*)
(* the ranges is always normalized to 0).				*)
(*									*)
(* Intuition will position the mouse proportionally within its		*)
(* natural mouse position rectangle limits.				*)
(*									*)
(* IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_TABLET.	*)

TYPE
  IEPointerTablet = RECORD
    iept_Range	  : RECORD X,Y : CARDINAL END ; (* 0 is min, these are max  *)
    iept_Value	  : RECORD X,Y : CARDINAL END ; (* between 0 and iept_Range *)
    iept_Pressure : INTEGER ;	(* -128 to 127 (unused, set to 0)  *)
  END ;


(* The ie_EventAddress of an IECLASS_NEWPOINTERPOS event of subclass	*)
(* IESUBCLASS_NEWTABLET points at an IENewTablet structure.		*)
(*									*)
(* IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_NEWTABLET.	*)

TYPE
  IENewTablet = RECORD

    (* Pointer to a hook you wish to be called back through, in		*)
    (* order to handle scaling.  You will be provided with the		*)
    (* width and height you are expected to scale your tablet		*)
    (* to, perhaps based on some user preferences.			*)
    (* If NULL, the tablet's specified range will be mapped directly	*)
    (* to that width and height for you, and you will not be		*)
    (* called back.							*)

     ient_CallBack : Utility.HookPtr ;

    (* Post-scaling coordinates and fractional coordinates.		*)
    (* DO NOT FILL THESE IN AT THE TIME THE EVENT IS WRITTEN!		*)
    (* Your driver will be called back and provided information		*)
    (* about the width and height of the area to scale the		*)
    (* tablet into.  It should scale the tablet coordinates		*)
    (* (perhaps based on some preferences controlling aspect		*)
    (* ratio, etc.) and place the scaled result into these		*)
    (* fields.	The ient_ScaledX and ient_ScaledY fields are		*)
    (* in screen-pixel resolution, but the origin ( [0,0]-point )	*)
    (* is not defined.	The ient_ScaledXFraction and			*)
    (* ient_ScaledYFraction fields represent sub-pixel position		*)
    (* information, and should be scaled to fill a UWORD fraction.	*)

    ient_ScaledX, ient_ScaledY : CARDINAL ;
    ient_ScaledXFraction, ient_ScaledYFraction : CARDINAL ;

    (* Current tablet coordinates along each axis: *)
    ient_TabletX, ient_TabletY : LONGINT ;

    (* Tablet range along each axis.  For example, if ient_TabletX	*)
    (* can take values 0-999, ient_RangeX should be 1000.		*)

    ient_RangeX, ient_RangeY : LONGINT ;

    (* Pointer to tag-list of additional tablet attributes.	*)
    (* See <intuition/intuition.h> for the tag values.		*)

    ient_TagList : Utility.TagItemPtr ;
  END ;


(*  --- InputEvent.ie_Code --- *)
(*  IECLASS_RAWKEY *)
CONST
  IECODE_UP_PREFIX	  = 080H ;
  IECODE_KEY_CODE_FIRST	  = 000H ;
  IECODE_KEY_CODE_LAST	  = 077H ;
  IECODE_COMM_CODE_FIRST  = 078H ;
  IECODE_COMM_CODE_LAST	  = 07FH ;

(*  IECLASS_ANSI *)
  IECODE_C0_FIRST	= 000H ;
  IECODE_C0_LAST	= 01FH ;
  IECODE_ASCII_FIRST	= 020H ;
  IECODE_ASCII_LAST	= 07EH ;
  IECODE_ASCII_DEL	= 07FH ;
  IECODE_C1_FIRST	= 080H ;
  IECODE_C1_LAST	= 09FH ;
  IECODE_LATIN1_FIRST	= 0A0H ;
  IECODE_LATIN1_LAST	= 0FFH ;

(*  IECLASS_RAWMOUSE *)
  IECODE_LBUTTON	= 068H ; (* also uses IECODE_UP_PREFIX *)
  IECODE_RBUTTON	= 069H ;
  IECODE_MBUTTON	= 06AH ;
  IECODE_NOBUTTON	= 0FFH ;

(*  IECLASS_EVENT (V36) *)

  IECODE_NEWACTIVE = 001H ; (* new active input window  *)
  IECODE_NEWSIZE   = 002H ; (* resize of window		*)
  IECODE_REFRESH   = 003H ; (* refresh of window	*)

(*  IECLASS_REQUESTER *)
(*   broadcast when the first Requester (not subsequent ones) opens up in *)
(*   the Window								  *)
  IECODE_REQSET	  = 01H ;

(*	broadcast when the last Requester clears out of the Window *)
  IECODE_REQCLEAR = 000H ;

(*  --- InputEvent.ie_Qualifier --- *)

  IEQUALIFIERB_LSHIFT		=  0 ;
  IEQUALIFIERB_RSHIFT		=  1 ;
  IEQUALIFIERB_CAPSLOCK		=  2 ;
  IEQUALIFIERB_CONTROL		=  3 ;
  IEQUALIFIERB_LALT		=  4 ;
  IEQUALIFIERB_RALT		=  5 ;
  IEQUALIFIERB_LCOMMAND		=  6 ;
  IEQUALIFIERB_RCOMMAND		=  7 ;
  IEQUALIFIERB_NUMERICPAD	=  8 ;
  IEQUALIFIERB_REPEAT		=  9 ;
  IEQUALIFIERB_INTERRUPT	= 10 ;
  IEQUALIFIERB_MULTIBROADCAST	= 11 ;
  IEQUALIFIERB_MIDBUTTON	= 12 ;
  IEQUALIFIERB_RBUTTON		= 13 ;
  IEQUALIFIERB_LEFTBUTTON	= 14 ;
  IEQUALIFIERB_RELATIVEMOUSE	= 15 ;

  IEQUALIFIER_LSHIFT		=  {0} ;
  IEQUALIFIER_RSHIFT		=  {1} ;
  IEQUALIFIER_CAPSLOCK		=  {2} ;
  IEQUALIFIER_CONTROL		=  {3} ;
  IEQUALIFIER_LALT		=  {4} ;
  IEQUALIFIER_RALT		=  {5} ;
  IEQUALIFIER_LCOMMAND		=  {6} ;
  IEQUALIFIER_RCOMMAND		=  {7} ;
  IEQUALIFIER_NUMERICPAD	=  {8} ;
  IEQUALIFIER_REPEAT		=  {9} ;
  IEQUALIFIER_INTERRUPT		= {10} ;
  IEQUALIFIER_MULTIBROADCAST	= {11} ;
  IEQUALIFIER_MIDBUTTON		= {12} ;
  IEQUALIFIER_RBUTTON		= {13} ;
  IEQUALIFIER_LEFTBUTTON	= {14} ;
  IEQUALIFIER_RELATIVEMOUSE	= {15} ;

(*----- InputEvent -------------------------------------------------*)

TYPE
  InputEvent = RECORD
    ie_NextEvent : InputEventPtr; (* the chronologically next event	*)
    ie_Class	 : SHORTCARD	; (* the input event class		*)
    ie_SubClass	 : SHORTCARD	; (* optional subclass of the class	*)
    ie_Code	 : CARDINAL	; (* the input event code		*)
    ie_Qualifier : BITSET	; (* qualifiers in effect for the event	*)
    CASE :LONGINT OF
    |0:
    ie_Position  : RECORD
        CASE :LONGINT OF
        |0: ie_xy   : RECORD ie_x,ie_y : INTEGER END ;
        |1: ie_addr : ADDRESS ; (* the event address *)
        |2: ie_dead : RECORD
	    ie_prev1DownCode : SHORTCARD ; (* previous down keys for dead     *)
	    ie_prev1DownQual : SHORTSET  ; (*   key translation: the ie_Code  *)
	    ie_prev2DownCode : SHORTCARD ; (*   & low byte of ie_Qualifier for*)
	    ie_prev2DownQual : SHORTSET  ; (*   last & second last down keys  *)
          END ;
        END ;
      END ;
    |2:
      CASE :LONGINT OF
      |0: ie_X , ie_Y	   : INTEGER   ;
      |1: ie_EventAddress  : ADDRESS   ;
      |2: ie_Prev1DownCode : SHORTCARD ;
	  ie_Prev1DownQual : SHORTSET  ;
	  ie_Prev2DownCode : SHORTCARD ;
	  ie_Prev2DownQual : SHORTSET  ;
      END ;
    END ;
    ie_TimeStamp : Timer.TimeVal ;	(* the system tick at the event *)
  END ;

END InputEvent.
