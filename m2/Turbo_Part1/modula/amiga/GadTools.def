DEFINITION FOR LIBRARY MODULE GadTools ;

FROM SYSTEM	IMPORT ADDRESS, LONGSET, STRING ;
FROM Exec	IMPORT MsgPortPtr, LibraryPtr ;
FROM Intuition	IMPORT Gadget, GadgetPtr, MenuPtr, MenuItemPtr, RequesterPtr,
		       DrawInfoPtr, WindowPtr, ScreenPtr, IntuiMessagePtr ;

FROM Utility	IMPORT TAG_USER, Tag, TagItemPtr ;
FROM Graphics	IMPORT RastPortPtr, Rectangle, TextAttrPtr ;

FROM Intuition	IMPORT IDCMP_GADGETUP, IDCMP_GADGETDOWN, IDCMP_INTUITICKS,
		       IDCMP_MOUSEBUTTONS, IDCMP_MOUSEMOVE, MENUENABLED,
		       ITEMENABLED, COMMSEQ, ITEMTEXT, HIGHFLAGS ;

(* The kinds (almost classes) of gadgets that GadTools supports. *)
(* Use these identifiers when calling CreateGadgetA()		 *)

TYPE
  NewGadgetPtr	= POINTER TO NewGadget	  ;
  NewMenuPtr	= POINTER TO NewMenu	  ;
  LVDrawMsgPtr	= POINTER TO LVDrawMsgPtr ;
  VisualInfoPtr	= POINTER TO RECORD END ;

CONST
  GENERIC_KIND	= 0 ;
  BUTTON_KIND	= 1 ;
  CHECKBOX_KIND	= 2 ;
  INTEGER_KIND	= 3 ;
  LISTVIEW_KIND	= 4 ;
  MX_KIND	= 5 ;
  NUMBER_KIND	= 6 ;
  CYCLE_KIND	= 7 ;
  PALETTE_KIND	= 8 ;
  SCROLLER_KIND	= 9 ;

(* Kind number 10 is reserved *)

  SLIDER_KIND	= 11 ;
  STRING_KIND	= 12 ;
  TEXT_KIND	= 13 ;

  NUM_KINDS	= 14 ;

(*------------------------------------------------------------------------*)

(* 'Or' the appropriate set together for your Window IDCMPFlags: *)

  ARROWIDCMP	= IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_INTUITICKS+
  		  IDCMP_MOUSEBUTTONS ;

  BUTTONIDCMP	= IDCMP_GADGETUP ;
  CHECKBOXIDCMP	= IDCMP_GADGETUP ;
  INTEGERIDCMP	= IDCMP_GADGETUP ;
  LISTVIEWIDCMP	= IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_MOUSEMOVE+ARROWIDCMP;

  MXIDCMP	= IDCMP_GADGETDOWN ;
  NUMBERIDCMP	= 0 ;
  CYCLEIDCMP	= IDCMP_GADGETUP ;
  PALETTEIDCMP	= IDCMP_GADGETUP ;

(* Use ARROWIDCMP+SCROLLERIDCMP if your scrollers have arrows: *)
  SCROLLERIDCMP	= IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_MOUSEMOVE ;
  SLIDERIDCMP	= IDCMP_GADGETUP+IDCMP_GADGETDOWN+IDCMP_MOUSEMOVE ;
  STRINGIDCMP	= IDCMP_GADGETUP ;

  TEXTIDCMP	= 0 ;

(*------------------------------------------------------------------------*)

(* Generic NewGadget used by several of the gadget classes: *)

TYPE
  NewGadget = RECORD
    ng_LeftEdge   : INTEGER ;	(* gadget position 			*)
    ng_TopEdge	  : INTEGER ;	(* gadget position 			*)
    ng_Width	  : INTEGER ;	(* gadget size				*)
    ng_Height	  : INTEGER ;	(* gadget size				*)
    ng_GadgetText : STRING  ;	(* gadget label				*)
    ng_TextAttr   : TextAttrPtr;(* desired font for gadget label	*)
    ng_GadgetID   : CARDINAL ;	(* gadget ID				*)
    ng_Flags	  : LONGSET  ;	(* see below				*)
    ng_VisualInfo : ADDRESS  ;  (* Set to retval of GetVisualInfo()	*)
    ng_UserData   : ADDRESS  ;	(* gadget UserData			*)
  END ;

(* ng_Flags control certain aspects of the gadget.  The first five control    *)
(* the placement of the descriptive text.  Each gadget kind has its default,  *)
(* which is usually PLACETEXT_LEFT.  Consult the autodocs for details.	      *)

CONST
  PLACETEXT_LEFT  = {0} ; (* Right-align text on left side *)
  PLACETEXT_RIGHT = {1} ; (* Left-align text on right side *)
  PLACETEXT_ABOVE = {2} ; (* Center text above		   *)
  PLACETEXT_BELOW = {3} ; (* Center text below		   *)
  PLACETEXT_IN	  = {4} ; (* Center text on		   *)

  NG_HIGHLABEL	  = {5} ; (* Highlight the label	   *)

(*------------------------------------------------------------------------*)

(* Fill out an array of these and pass that to CreateMenus(): *)

TYPE
  NewMenu = RECORD
    nm_Type		: SHORTCARD ; (* See below			*)
    (* Compiler inserts a PAD byte here *)
    nm_Label		: STRING  ;
    nm_CommKey		: STRING  ; (* MenuItem Command Key Equiv	*)
    nm_Flags		: BITSET  ; (* Menu or MenuItem flags (see note)*)
    nm_MutualExclude	: LONGINT ; (* MenuItem MutualExclude word	*)
    nm_UserData		: ADDRESS ; (* For your own use, see note	*)
  END ;

(* Needed only by inside IM_ definitions below *)
CONST
  MENU_IMAGE = 128 ;

(* nm_Type determines what each NewMenu structure corresponds to.	 *)
(* for the NM_TITLE, NM_ITEM, and NM_SUB values, nm_Label should	 *)
(* be a text string to use for that menu title, item, or sub-item.	 *)
(* For IM_ITEM or IM_SUB, set nm_Label to point at the Image structure   *)
(* you wish to use for this item or sub-item.				 *)
(* NOTE: At present, you may only use conventional images.		 *)
(* Custom images created from Intuition image-classes do not work.	 *)

  NM_TITLE	= 1 ; (* Menu header		*)
  NM_ITEM	= 2 ; (* Textual menu item	*)
  NM_SUB	= 3 ; (* Textual menu sub-item	*)

  IM_ITEM	= NM_ITEM+MENU_IMAGE ; (* Graphical menu item	  *)
  IM_SUB	= NM_SUB+MENU_IMAGE ;  (* Graphical menu sub-item *)

(* The NewMenu array should be terminated with a NewMenu whose    *)
(* nm_Type equals NM_END.					  *)

  NM_END	= 0 ;	(* End of NewMenu array *)

(* Starting with V39, GadTools will skip any NewMenu entries whose*)
(* nm_Type field has the NM_IGNORE bit set.			  *)

  NM_IGNORE	= 64 ;

(* nm_Label should be a text string for textual items, a pointer  *)
(* to an Image structure for graphical menu items, or the special *)
(* constant NM_BARLABEL, to get a separator bar.		  *)

  NM_BARLABEL	= STRING(-1) ;

(* The nm_Flags field is used to fill out either the Menu->Flags or	*)
(* MenuItem->Flags field.  Note that the sense of the MENUENABLED or	*)
(* ITEMENABLED bit is inverted between this use and Intuition's use,	*)
(* in other words, NewMenus are enabled by default.  The following	*)
(* labels are provided to disable them:					*)

  NM_MENUDISABLED = MENUENABLED ;
  NM_ITEMDISABLED = ITEMENABLED ;

(* New for V39:  NM_COMMANDSTRING.  For a textual MenuItem or SubItem,	 *)
(* point nm_CommKey at an arbitrary string, and set the NM_COMMANDSTRING *)
(* flag.								 *)

  NM_COMMANDSTRING = COMMSEQ ;

(* The following are pre-cleared (COMMSEQ, ITEMTEXT, and HIGHxxx are set *)
(* later as appropriate):						 *)
(* Under V39, the COMMSEQ flag bit is not cleared, since it now has	 *)
(* meaning.								 *)

  NM_FLAGMASK	     = {0..7}-(COMMSEQ+ITEMTEXT+HIGHFLAGS) ;
  NM_FLAGMASK_V39    = {0..7}-(ITEMTEXT+HIGHFLAGS) ;

(* You may choose among CHECKIT, MENUTOGGLE, and CHECKED.		*)
(* Toggle-select menuitems are of type CHECKIT|MENUTOGGLE, along	*)
(* with CHECKED if currently selected.	Mutually exclusive ones		*)
(* are of type CHECKIT, and possibly CHECKED too.  The nm_MutualExclude	*)
(* is a bit-wise representation of the items excluded by this one,	*)
(* so in the simplest case (choose 1 among n), these flags would be	*)
(* ~1, ~2, ~4, ~8, ~16, etc.  See the Intuition Menus chapter.		*)

(* A UserData pointer can be associated with each Menu and MenuItem structure.*)
(* The CreateMenus() call allocates space for a UserData after each	      *)
(* Menu or MenuItem (header, item or sub-item).  You should use the	      *)
(* GTMENU_USERDATA() or GTMENUITEM_USERDATA() functions to extract it.	      *)

  PROCEDURE GTMENU_USERDATA( menu : MenuPtr ) : ADDRESS ;
  PROCEDURE GTMENUITEM_USERDATA( menuitem : MenuItemPtr ) : ADDRESS ;

(* Here is an old one for compatibility.  Do not use in new code! *)
(*  PROCEDURE MENU_USERDATA( ? ) : ADDRESS ;			  *)

CONST
  (* These return codes can be obtained through the GTMN_SecondaryError tag *)
  GTMENU_TRIMMED  = 000000001H ;  (* Too many menus, items, or subitems,    *)
				  (* menu has been trimmed down		    *)

  GTMENU_INVALID  = 000000002H ;  (* Invalid NewMenu array	*)
  GTMENU_NOMEM	  = 000000003H ;  (* Out of memory		*)

(*------------------------------------------------------------------------*)

(* Starting with V39, checkboxes and mx gadgets can be scaled to your	  *)
(* specified gadget width/height.  Use the new GTCB_Scaled or GTMX_Scaled *)
(* tags, respectively.	Under V37, and by default in V39, the imagery     *)
(* is of the following fixed size:					  *)

(* MX gadget default dimensions: *)
   MX_WIDTH	   = 17 ;
   MX_HEIGHT	   =  9 ;

(* Checkbox default dimensions: *)
   CHECKBOX_WIDTH  = 26 ;
   CHECKBOX_HEIGHT = 11 ;

(*------------------------------------------------------------------------*)

(* Tags for GadTools functions: *)

  GT_TagBase		= TAG_USER + 080000H ;

  GTVI_NewWindow	= GT_TagBase+1 ;  (* Unused			      *)
  GTVI_NWTags		= GT_TagBase+2 ;  (* Unused			      *)

  GT_Private0		= GT_TagBase+3 ;  (* (private)			      *)

  GTCB_Checked		= GT_TagBase+4 ;  (* State of checkbox		      *)

  GTLV_Top		= GT_TagBase+5 ;  (* Top visible one in listview      *)
  GTLV_Labels		= GT_TagBase+6 ;  (* List to display in listview      *)
  GTLV_ReadOnly		= GT_TagBase+7 ;  (* TRUE if listview is to be read-o *)
  GTLV_ScrollWidth	= GT_TagBase+8 ;  (* Width of scrollbar		      *)

  GTMX_Labels		= GT_TagBase+9 ;  (* NULL-terminated array of labels  *)
  GTMX_Active		= GT_TagBase+10 ; (* Active one in mx gadget	      *)

  GTTX_Text		= GT_TagBase+11 ; (* Text to display		      *)
  GTTX_CopyText		= GT_TagBase+12 ; (* Copy text label instead of	      *)
					  (* referencing it		      *)

  GTNM_Number		= GT_TagBase+13 ; (* Number to display		      *)

  GTCY_Labels		= GT_TagBase+14 ; (* NULL-terminated array of labels  *)
  GTCY_Active		= GT_TagBase+15 ; (* The active one in the cycle gad  *)

  GTPA_Depth		= GT_TagBase+16 ; (* Number of bitplanes in palette   *)
  GTPA_Color		= GT_TagBase+17 ; (* Palette color		      *)
  GTPA_ColorOffset	= GT_TagBase+18 ; (* First color to use in palette    *)
  GTPA_IndicatorWidth	= GT_TagBase+19 ; (* Width of current-color indicator *)
  GTPA_IndicatorHeight	= GT_TagBase+20 ; (* Height of current-color indicator*)

  GTSC_Top		= GT_TagBase+21 ; (* Top visible in scroller	      *)
  GTSC_Total		= GT_TagBase+22 ; (* Total in scroller area	      *)
  GTSC_Visible		= GT_TagBase+23 ; (* Number visible in scroller	      *)
  GTSC_Overlap		= GT_TagBase+24 ; (* Unused			      *)

(*  GT_TagBase+25 through GT_TagBase+37 are reserved *)

  GTSL_Min		= GT_TagBase+38 ; (* Slider min value		      *)
  GTSL_Max		= GT_TagBase+39 ; (* Slider max value		      *)
  GTSL_Level		= GT_TagBase+40 ; (* Slider level		      *)
  GTSL_MaxLevelLen	= GT_TagBase+41 ; (* Max length of printed level      *)
  GTSL_LevelFormat	= GT_TagBase+42 ; (* Format string for level	      *)
  GTSL_LevelPlace	= GT_TagBase+43 ; (* Where level should be placed     *)
  GTSL_DispFunc		= GT_TagBase+44 ; (* Callback for number calculation  *)
					  (* before display		      *)

  GTST_String		= GT_TagBase+45 ; (* String gadget's displayed string *)
  GTST_MaxChars		= GT_TagBase+46 ; (* Max length of string	      *)

  GTIN_Number		= GT_TagBase+47 ; (* Number in integer gadget	      *)
  GTIN_MaxChars		= GT_TagBase+48 ; (* Max number of digits	      *)

  GTMN_TextAttr		= GT_TagBase+49 ; (* MenuItem font TextAttr	      *)
  GTMN_FrontPen		= GT_TagBase+50 ; (* MenuItem text pen color	      *)

  GTBB_Recessed		= GT_TagBase+51 ; (* Make BevelBox recessed	      *)

  GT_VisualInfo		= GT_TagBase+52 ; (* result of VisualInfo call	      *)

  GTLV_ShowSelected	= GT_TagBase+53 ; (* show selected entry beneath      *)
					  (* listview, set tag data = NULL for*)
					  (* display-only, or pointer	      *)
					  (* to a string gadget you've created*)

  GTLV_Selected		= GT_TagBase+54 ; (* Set ordinal number of selected   *)
					  (* entry in the list		      *)

  GT_Reserved1		= GT_TagBase+56 ; (* Reserved for future use	      *)

  GTTX_Border		= GT_TagBase+57 ; (* Put a border around	      *)
					  (* Text-display gadgets	      *)

  GTNM_Border		= GT_TagBase+58 ; (* Put a border around	      *)
					  (* Number-display gadgets	      *)

  GTSC_Arrows		= GT_TagBase+59 ; (* Specify size of arrows for	      *)
  					  (* scroller			      *)

  GTMN_Menu		= GT_TagBase+60 ; (* Pointer to Menu for use by	      *)
					  (* LayoutMenuItems()		      *)

  GTMX_Spacing		= GT_TagBase+61 ; (* Added to font height to figure   *)
  					  (* spacing between mx choices.      *)
  					  (* Use this instead of	      *)
  					  (* LAYOUTA_SPACING for mx gadgets.  *)

(* New to V37 GadTools.  Ignored by GadTools V36 *)
  GTMN_FullMenu		= GT_TagBase+62 ; (* Asks CreateMenus to validate that*)
					  (* this is a complete menu structure*)

  GTMN_SecondaryError	= GT_TagBase+63 ; (* ti_Data is a pointer	      *)
					  (* to a ULONG to receive error      *)
					  (* reports from CreateMenus()	      *)

  GT_Underscore		= GT_TagBase+64 ; (* ti_Data points to the symbol     *)
					  (* that preceeds the character      *)
					  (* you'd like to underline in a     *)
					  (* gadget label		      *)


  GTST_EditHook		= GT_TagBase+55 ;  (* String EditHook *)

  GTIN_EditHook		= GTST_EditHook ;(* Same ; thing, different name,    *)
				         (* just to round out INTEGER_KIND   *)
				         (* gadgets			     *)

(* New to V39 GadTools.  Ignored by GadTools V36 and V37 *)
  GTMN_Checkmark	= GT_TagBase+65 ; (* ti_Data is checkmark img to use *)
  GTMN_AmigaKey		= GT_TagBase+66 ; (* ti_Data is Amiga-key img to use *)
  GTMN_NewLookMenus     = GT_TagBase+67 ; (* ti_Data is boolean		     *)

(* New to V39 GadTools.  Ignored by GadTools V36 and V37.	*)
(* Set to TRUE if you want the checkbox or mx image scaled to	*)
(* the gadget width/height you specify.  Defaults to FALSE,	*)
(* for compatibility.						*)

  GTCB_Scaled		= GT_TagBase+68 ; (* ti_Data is boolean		      *)
  GTMX_Scaled		= GT_TagBase+69 ; (* ti_Data is boolean		      *)

  GTPA_NumColors	= GT_TagBase+70 ; (* Number of colors in palette      *)

  GTMX_TitlePlace	= GT_TagBase+71 ; (* Where to put the title           *)

  GTTX_FrontPen		= GT_TagBase+72 ; (* Text color in TEXT_KIND gad      *)
  GTTX_BackPen		= GT_TagBase+73 ; (* Bgrnd color in TEXT_KIND gad     *)
  GTTX_Justification	= GT_TagBase+74 ; (* See GTJ_#? constants	      *)

  GTNM_FrontPen		= GT_TagBase+72 ; (* Text color in NUMBER_KIND gad    *)
  GTNM_BackPen		= GT_TagBase+73 ; (* Bgrnd color in NUMBER_KIND gad   *)
  GTNM_Justification	= GT_TagBase+74 ; (* See GTJ_#? constants	      *)
  GTNM_Format		= GT_TagBase+75 ; (* Formatting string for number     *)
  GTNM_MaxNumberLen	= GT_TagBase+76 ; (* Maximum length of number	      *)

  GTBB_FrameType	= GT_TagBase+77 ; (* defines what kind of boxes       *)
					  (* DrawBevelBox() renders. See      *)
					  (* the BBFT_#? constants for	      *)
					  (* possible values		      *)

  GTLV_MakeVisible	= GT_TagBase+78 ; (* Make this item visible	      *)
  GTLV_ItemHeight	= GT_TagBase+79 ; (* Height of an individual item     *)

  GTSL_MaxPixelLen	= GT_TagBase+80 ; (* Max pixel size of level display  *)
  GTSL_Justification	= GT_TagBase+81 ; (* how should the level be displayed*)

  GTPA_ColorTable	= GT_TagBase+82 ; (* colors to use in palette	      *)

  GTLV_CallBack		= GT_TagBase+83 ; (* general-purpose listview callback*)
  GTLV_MaxPen		= GT_TagBase+84 ; (* maximum pen number, callback use *)

  GTTX_Clipped		= GT_TagBase+85 ; (* make a TEXT_KIND clip text	      *)
  GTNM_Clipped		= GT_TagBase+85 ; (* make a NUMBER_KIND clip text     *)

(* Old definition, now obsolete: *)
  GT_Reserved0		= GTST_EditHook	;

(*------------------------------------------------------------------------*)

(* Justification types for GTTX_Justification and GTNM_Justification tags *)
  GTJ_LEFT   = 0 ;
  GTJ_RIGHT  = 1 ;
  GTJ_CENTER = 2 ;

(*------------------------------------------------------------------------*)

(* Bevel box frame types for GTBB_FrameType tag *)
  BBFT_BUTTON		= 1 ; (* Standard button gadget box *)
  BBFT_RIDGE		= 2 ; (* Standard string gadget box *)
  BBFT_ICONDROPBOX	= 3 ; (* Standard icon drop box	    *)

(*------------------------------------------------------------------------*)

(* Typical suggested spacing between "elements": *)
  INTERWIDTH	= 8 ;
  INTERHEIGHT	= 4 ;

(*------------------------------------------------------------------------*)

(* "NWay" is an old synonym for cycle gadgets *)
  NWAY_KIND	= CYCLE_KIND  ;
  NWAYIDCMP	= CYCLEIDCMP  ;
  GTNW_Labels	= GTCY_Labels ;
  GTNW_Active	= GTCY_Active ;

(*------------------------------------------------------------------------*)

(* These two definitions are obsolete, but are here for backwards	*)
(* compatibility.  You never need to worry about these:			*)

  GADTOOLBIT	= {15} ;

(* Use this mask to isolate the user part: *)
  GADTOOLMASK	= {0..14,16..31} ;

(*------------------------------------------------------------------------*)

(* These definitions are for the GTLV_CallBack tag *)

  (* The different types of messages that a listview callback hook can see *)
  LV_DRAW       = 0202H ; (* draw yourself, with state *)

(* Possible return values from a callback hook *)
  LVCB_OK       = 0 ; (* callback understands this message type    *)
  LVCB_UNKNOWN  = 1 ; (* callback does not understand this message *)

(* states for LVDrawMsg.lvdm_State *)
  LVR_NORMAL	        = 0 ; (* the usual		*)
  LVR_SELECTED	        = 1 ; (* for selected gadgets	*)
  LVR_NORMALDISABLED    = 2 ; (* for disabled gadgets	*)
  LVR_SELECTEDDISABLED  = 8 ; (* disabled and selected	*)

(* structure of LV_DRAW messages, object is a Exec.NodePtr *)
TYPE
  LVDrawMsg = RECORD
    lvdm_MethodID : LONGINT     ; (* LV_DRAW			*)
    lvdm_RastPort : RastPortPtr ; (* where to render to		*)
    lvdm_DrawInfo : DrawInfoPtr ; (* useful to have around	*)
    lvdm_Bounds   : Rectangle   ; (* limits of where to render	*)
    lvdm_State    : LONGINT     ; (* how to render		*)
  END ;

(*------------------------------------------------------------------------*)

VAR
  GadToolsBase : LibraryPtr ;

(*--- functions in V36 or higher (Release 2.0) ---*)

(* Gadget Functions *)

PROCEDURE CreateGadgetA(        kind : LONGINT ;
			         gad : GadgetPtr ;
			 VAR      ng : NewGadget ; (* in *)
			     taglist : TagItemPtr ) : GadgetPtr ;

PROCEDURE CreateGadget(    kind	: LONGINT ;
			    gad	: GadgetPtr ;
			VAR  ng	: NewGadget ; (* in *)
			    tag	: Tag ; .. ) : GadgetPtr ;

PROCEDURE FreeGadgets( gad : GadgetPtr ) ;

PROCEDURE GT_SetGadgetAttrsA( gad : GadgetPtr ;
			      win : WindowPtr ;
			      req : RequesterPtr ;
			      taglist : TagItemPtr ) ;

PROCEDURE GT_SetGadgetAttrs( gad : GadgetPtr ;
			     win : WindowPtr ;
			     req : RequesterPtr ;
			     tag : Tag ; .. ) ;

(* Menu functions *)

PROCEDURE CreateMenusA( newmenu : ARRAY OF NewMenu ;
                        taglist : TagItemPtr ) : MenuPtr;

PROCEDURE CreateMenus ( newmenu : ARRAY OF NewMenu ;
			tag : Tag ; .. ) : MenuPtr ;

PROCEDURE FreeMenus( menu : MenuPtr ) ;

PROCEDURE LayoutMenuItemsA( firstitem	: MenuItemPtr ;
			    vi		: VisualInfoPtr ;
			    taglist	: TagItemPtr ) : BOOLEAN ;

PROCEDURE LayoutMenuItems( firstitem : MenuItemPtr ;
			   vi	     : VisualInfoPtr ;
			   tag	     : Tag ; .. ) : BOOLEAN ;

PROCEDURE LayoutMenusA( firstmenu : MenuPtr ;
		        vi	  : VisualInfoPtr ;
		        taglist	  : TagItemPtr ) : BOOLEAN ;

PROCEDURE LayoutMenus( firstmenu : MenuPtr ;
		       vi	 : VisualInfoPtr ;
		       tag	 : Tag ; .. ) : BOOLEAN ;

(* Misc Event-Handling Functions *)

PROCEDURE GT_GetIMsg( iport : MsgPortPtr ) : IntuiMessagePtr ;
PROCEDURE GT_ReplyIMsg( imsg : IntuiMessagePtr ) ;
PROCEDURE GT_RefreshWindow( win : WindowPtr ; req : RequesterPtr ) ;
PROCEDURE GT_BeginRefresh( win : WindowPtr ) ;
PROCEDURE GT_EndRefresh( win : WindowPtr ; complete : BOOLEAN ) ;

PROCEDURE GT_FilterIMsg( imsg : IntuiMessagePtr ) : IntuiMessagePtr ;
PROCEDURE GT_PostFilterIMsg( imsg : IntuiMessagePtr ) : IntuiMessagePtr ;

PROCEDURE CreateContext( VAR glistptr : GadgetPtr ) : GadgetPtr ;

(* Rendering Functions *)

PROCEDURE DrawBevelBoxA( rport : RastPortPtr ;
			 left, top, width, height : LONGINT ;
			 tagList : TagItemPtr ) ;

PROCEDURE DrawBevelBox( rport : RastPortPtr ;
			left, top, width, height : LONGINT ;
			tag1 : Tag ; .. ) ;

(* Visuals Functions *)

PROCEDURE GetVisualInfoA( screen : ScreenPtr ;
			 taglist : TagItemPtr ) : ADDRESS ;

PROCEDURE GetVisualInfo( screen : ScreenPtr ;
			 tag1 : Tag ; .. ) : ADDRESS ;

PROCEDURE FreeVisualInfo( vi : VisualInfoPtr ) ;

(*--- functions in V39 or higher (Release 3) ---*)

PROCEDURE GT_GetGadgetAttrsA( gad     : GadgetPtr ;
			      win     : WindowPtr ;
			      req     : RequesterPtr ;
			      taglist : TagItemPtr ) : LONGINT ;

PROCEDURE GT_GetGadgetAttrs( gad : GadgetPtr ;
			     win : WindowPtr ;
			     req : RequesterPtr ;
			     tag : Tag ; .. ) : LONGINT ;

END GadTools.
