DEFINITION FOR C MODULE Hardware ;

FROM SYSTEM IMPORT ADDRESS, BITSET, SHORTSET ;

CONST
  HSIZEBITS = 6 ;
  VSIZEBITS = 16-HSIZEBITS ;
  HSIZEMASK = 03FH  ;	    (* 2^6 -- 1 *)
  VSIZEMASK = 03FFH ;       (* 2^10 - 1 *)

(* all agnii support horizontal blit of at least 1024 bits (128 bytes) wide *)
(* some agnii support horizontal blit of up to 32768 bits (4096 bytes) wide *)

(* definitions for blitter control register 0 *)

CONST
  ABC    = {7} ;
  ABNC   = {6} ;
  ANBC   = {5} ;
  ANBNC  = {4} ;
  NABC   = {3} ;
  NABNC  = {2} ;
  NANBC  = {1} ;
  NANBNC = {0} ;

(* some commonly used operations *)
  A_OR_B  = ABC+ANBC+NABC+ABNC+ANBNC+NABNC ;
  A_OR_C  = ABC+NABC+ABNC+ANBC+NANBC+ANBNC ;
  A_XOR_C = NABC+ABNC+NANBC+ANBNC ;
  A_TO_D  = ABC+ANBC+ABNC+ANBNC ;

  BC0B_DEST =  8 ;
  BC0B_SRCC =  9 ;
  BC0B_SRCB = 10 ;
  BC0B_SRCA = 11 ;

  BC0F_DEST =  {8} ;
  BC0F_SRCC =  {9} ;
  BC0F_SRCB = {10} ;
  BC0F_SRCA = {11} ;

  BC1F_DESC = {1} ;	      (* blitter descend direction *)

  DEST = {8}  ;
  SRCC = {9}  ;
  SRCB = {10} ;
  SRCA = {11} ;

  ASHIFTSHIFT = 12 ; (* bits to right align ashift value *)
  BSHIFTSHIFT = 12 ; (* bits to right align bshift value *)

(* definations for blitter control register 1 *)

  LINEMODE     = {0} ;
  FILL_OR      = {3} ;
  FILL_XOR     = {4} ;
  FILL_CARRYIN = {2} ;
  ONEDOT       = {1} ; (* one dot per horizontal line *)
  OVFLAG       = {5} ;
  SIGNFLAG     = {6} ;
  BLITREVERSE  = {1} ;

  SUD = {4} ;
  SUL = {3} ;
  AUL = {2} ;

  OCTANT8 = SUL+SUD ;
  OCTANT7 = AUL ;
  OCTANT6 = AUL+SUL ;
  OCTANT5 = AUL+SUL+SUD ;
  OCTANT4 = AUL+SUD ;
  OCTANT3 = SUL ;
  OCTANT2 = {} ;
  OCTANT1 = SUD;

(* stuff for blit qeuer *)

TYPE
  bltnodePtr = POINTER TO bltnode ;
  bltnode = RECORD
    n	     : bltnodePtr ;
    function : ADDRESS ;
    stat     : CHAR    ;
    blitsize : INTEGER ;
    beamsync : INTEGER ;
    cleanup  : ADDRESS ;
  END ;

(* defined bits for bltstat *)

CONST
  CLEANUP = 040H ;
  CLEANME = CLEANUP ;

TYPE
  PadArray = ARRAY [0..0FFH-1] OF SHORTSET ;

  CIA = RECORD
    ciapra	: SHORTSET  ;	pad0 : PadArray ;
    ciaprb	: SHORTSET  ;	pad1 : PadArray ;
    ciaddra	: SHORTSET  ;	pad2 : PadArray ;
    ciaddrb	: SHORTSET  ;	pad3 : PadArray ;
    ciatalo	: SHORTCARD ;	pad4 : PadArray ;
    ciatahi 	: SHORTCARD ;	pad5 : PadArray ;
    ciatblo	: SHORTCARD ;	pad6 : PadArray ;
    ciatbhi	: SHORTCARD ;	pad7 : PadArray ;
    ciatodlow	: SHORTCARD ;	pad8 : PadArray ;
    ciatodmid	: SHORTCARD ;	pad9 : PadArray ;
    ciatodhi	: SHORTCARD ;	padA : PadArray ;
    unusedreg	: SHORTSET  ;	padB : PadArray ;
    ciasdr	: SHORTSET  ;	padC : PadArray ;
    ciaicr	: SHORTSET  ;	padD : PadArray ;
    ciacra	: SHORTSET  ;	padE : PadArray ;
    ciacrb	: SHORTSET  ;
  END ;

VAR
  ciaa[0BFE001H] : CIA ;
  ciab[0BFD000H] : CIA ;

CONST
(* interrupt control register bit numbers *)
  CIAICRB_TA	 = 0 ;
  CIAICRB_TB	 = 1 ;
  CIAICRB_ALRM	 = 2 ;
  CIAICRB_SP	 = 3 ;
  CIAICRB_FLG	 = 4 ;
  CIAICRB_IR	 = 7 ;
  CIAICRB_SETCLR = 7 ;

(* control register A bit numbers *)
  CIACRAB_START	  = 0 ;
  CIACRAB_PBON	  = 1 ;
  CIACRAB_OUTMODE = 2 ;
  CIACRAB_RUNMODE = 3 ;
  CIACRAB_LOAD	  = 4 ;
  CIACRAB_INMODE  = 5 ;
  CIACRAB_SPMODE  = 6 ;
  CIACRAB_TODIN	  = 7 ;

(* control register B bit numbers *)
  CIACRBB_START	  = 0 ;
  CIACRBB_PBON	  = 1 ;
  CIACRBB_OUTMODE = 2 ;
  CIACRBB_RUNMODE = 3 ;
  CIACRBB_LOAD	  = 4 ;
  CIACRBB_INMODE0 = 5 ;
  CIACRBB_INMODE1 = 6 ;
  CIACRBB_ALARM	  = 7 ;

(* interrupt control register masks *)
  CIAICRF_TA	 = {CIAICRB_TA}	;
  CIAICRF_TB	 = {CIAICRB_TB} ;
  CIAICRF_ALRM	 = {CIAICRB_ALRM} ;
  CIAICRF_SP	 = {CIAICRB_SP}	;
  CIAICRF_FLG	 = {CIAICRB_FLG} ;
  CIAICRF_IR	 = {CIAICRB_IR}	;
  CIAICRF_SETCLR = {CIAICRB_SETCLR} ;

(* control register A register masks *)
  CIACRAF_START	  = {CIACRAB_START}	;
  CIACRAF_PBON	  = {CIACRAB_PBON}	;
  CIACRAF_OUTMODE = {CIACRAB_OUTMODE}	;
  CIACRAF_RUNMODE = {CIACRAB_RUNMODE}	;
  CIACRAF_LOAD	  = {CIACRAB_LOAD}	;
  CIACRAF_INMODE  = {CIACRAB_INMODE}	;
  CIACRAF_SPMODE  = {CIACRAB_SPMODE}	;
  CIACRAF_TODIN	  = {CIACRAB_TODIN}	;

(* control register B register masks *)
  CIACRBF_START	  = {CIACRBB_START}	;
  CIACRBF_PBON	  = {CIACRBB_PBON}	;
  CIACRBF_OUTMODE = {CIACRBB_OUTMODE}	;
  CIACRBF_RUNMODE = {CIACRBB_RUNMODE}	;
  CIACRBF_LOAD	  = {CIACRBB_LOAD}	;
  CIACRBF_INMODE0 = {CIACRBB_INMODE0}	;
  CIACRBF_INMODE1 = {CIACRBB_INMODE1}	;
  CIACRBF_ALARM	  = {CIACRBB_ALARM}	;

(* control register B INMODE masks *)
  CIACRBF_IN_PHI2    = {} ;
  CIACRBF_IN_CNT     = CIACRBF_INMODE0 ;
  CIACRBF_IN_TA	     = CIACRBF_INMODE1 ;
  CIACRBF_IN_CNT_TA  = CIACRBF_INMODE0+CIACRBF_INMODE1 ;

(* Port definitions -- what each bit in a cia peripheral register is tied to *)

(* ciaa port A (0xbfe001) *)
  CIAB_GAMEPORT1 = 7 ;   (* gameport 1, pin 6 (fire button)	*)
  CIAB_GAMEPORT0 = 6 ;   (* gameport 0, pin 6 (fire button)	*)
  CIAB_DSKRDY	 = 5 ;   (* disk ready 				*)
  CIAB_DSKTRACK0 = 4 ;   (* disk on track 00 			*)
  CIAB_DSKPROT	 = 3 ;   (* disk write protect 			*)
  CIAB_DSKCHANGE = 2 ;   (* disk change 			*)
  CIAB_LED	 = 1 ;   (* led light control (0==>bright) 	*)
  CIAB_OVERLAY	 = 0 ;   (* memory overlay bit 			*)

(* ciaa port B (0xbfe101) -- parallel port *)

(* ciab port A (0xbfd000) -- serial and printer control *)
  CIAB_COMDTR	= 7 ;   (* serial Data Terminal Ready 	*)
  CIAB_COMRTS	= 6 ;   (* serial Request to Send 	*)
  CIAB_COMCD	= 5 ;   (* serial Carrier Detect 	*)
  CIAB_COMCTS	= 4 ;   (* serial Clear to Send 	*)
  CIAB_COMDSR	= 3 ;   (* serial Data Set Ready	*)
  CIAB_PRTRSEL	= 2 ;   (* printer SELECT		*)
  CIAB_PRTRPOUT	= 1 ;   (* printer paper out		*)
  CIAB_PRTRBUSY	= 0 ;   (* printer busy			*)

(* ciab port B (0xbfd100) -- disk control *)
  CIAB_DSKMOTOR	= 7 ;   (* disk motorr			*)
  CIAB_DSKSEL3	= 6 ;   (* disk select unit 3		*)
  CIAB_DSKSEL2	= 5 ;   (* disk select unit 2		*)
  CIAB_DSKSEL1	= 4 ;   (* disk select unit 1		*)
  CIAB_DSKSEL0	= 3 ;   (* disk select unit 0		*)
  CIAB_DSKSIDE	= 2 ;   (* disk side select		*)
  CIAB_DSKDIREC	= 1 ;   (* disk direction of seek	*)
  CIAB_DSKSTEP	= 0 ;   (* disk step heads		*)

(* ciaa port A (0xbfe001) *)
  CIAF_GAMEPORT1 = {7} ;
  CIAF_GAMEPORT0 = {6} ;
  CIAF_DSKRDY	 = {5} ;
  CIAF_DSKTRACK0 = {4} ;
  CIAF_DSKPROT	 = {3} ;
  CIAF_DSKCHANGE = {2} ;
  CIAF_LED	 = {1} ;
  CIAF_OVERLAY	 = {0} ;

(* ciaa port B (0xbfe101) -- parallel port *)

(* ciab port A (0xbfd000) -- serial and printer control *)
  CIAF_COMDTR	= {7} ;
  CIAF_COMRTS	= {6} ;
  CIAF_COMCD	= {5} ;
  CIAF_COMCTS	= {4} ;
  CIAF_COMDSR	= {3} ;
  CIAF_PRTRSEL	= {2} ;
  CIAF_PRTRPOUT	= {1} ;
  CIAF_PRTRBUSY	= {0} ;

(* ciab port B (0xbfd100) -- disk control *)
  CIAF_DSKMOTOR	= {7} ;
  CIAF_DSKSEL3	= {6} ;
  CIAF_DSKSEL2	= {5} ;
  CIAF_DSKSEL1	= {4} ;
  CIAF_DSKSEL0	= {3} ;
  CIAF_DSKSIDE	= {2} ;
  CIAF_DSKDIREC	= {1} ;
  CIAF_DSKSTEP	= {0} ;

TYPE
  Custom=RECORD
    bltddat: CARDINAL ;
    dmaconr: BITSET ;
    vposr  : CARDINAL ;
    vhposr : CARDINAL ;
    dskdatr: BITSET ;
    joy0dat: RECORD v , h : SHORTINT END ;
    joy1dat: RECORD v , h : SHORTINT END ;
    clxdat : BITSET ;
    adkconr: BITSET ;
    pot0dat: RECORD v , h : SHORTINT END ;
    pot1dat: RECORD v , h : SHORTINT END ;
    potinp : BITSET ;
    serdatr: CARDINAL ;
    dskbytr: CARDINAL ;
    intenar: BITSET ;
    intreqr: BITSET ;
    dskpt  : ADDRESS ;
    dsklen : CARDINAL ;
    dskdat : CARDINAL ;
    refptr : CARDINAL ;
    vposw  : LONGCARD ;
    copcon : BITSET ;
    serdat : CARDINAL ;
    serper : BITSET ;
    potgo  : BITSET ;
    joytest: RECORD v , h : SHORTINT END ;
    strequ : CARDINAL ;
    strvbl : CARDINAL ;
    strhor : CARDINAL ;
    strlong: CARDINAL ;
    bltcon0: BITSET ;
    bltcon1: BITSET ;
    bltafwm: BITSET ;
    bltalwm: BITSET ;
    bltcpt : ADDRESS ;
    bltbpt : ADDRESS ;
    bltapt : ADDRESS ;
    bltdpt : ADDRESS ;
    bltsize: CARDINAL ;
    pad2d  : ARRAY [0..2] OF CARDINAL ;
    bltcmod: CARDINAL ;
    bltbmod: CARDINAL ;
    bltamod: CARDINAL ;
    bltdmod: CARDINAL ;
    pad34  : ARRAY [0..3] OF CARDINAL ;
    bltcdat: CARDINAL ;
    bltbdat: CARDINAL ;
    bltadat: CARDINAL ;
    pad3b  : ARRAY [0..3] OF CARDINAL ;
    dsksync: CARDINAL ;
    cop1lc : ADDRESS ;
    cop2lc : ADDRESS ;
    copjmp1: CARDINAL ;
    copjmp2: CARDINAL ;
    copins : CARDINAL ;
    diwstrt: RECORD v , h : SHORTINT END ;
    diwstop: RECORD v , h : SHORTINT END ;
    ddfstrt: RECORD v , h : SHORTINT END ;
    ddfstop: RECORD v , h : SHORTINT END ;
    dmacon : BITSET ;
    clxcon : BITSET ;
    intena : BITSET ;
    intreq : BITSET ;
    adkcon : BITSET ;
    aud    : ARRAY [0..3] OF RECORD
       ac_ptr  : ADDRESS  ; (* ptr to start of waveform data	*)
       ac_len  : CARDINAL ; (* length of waveform in words	*)
       ac_per  : CARDINAL ; (* sample period			*)
       ac_vol  : CARDINAL ; (* volume				*)
       ac_dat  : CARDINAL ; (* sample pair			*)
       ac_pad  : LONGINT  ; (* unused				*)
      END ;
    bplpt  : ARRAY [0..5] OF ADDRESS ;
    pad7c  : ARRAY [0..3] OF CARDINAL ;
    bplcon0: BITSET ;
    bplcon1: CARDINAL ;
    bplcon2: CARDINAL ;
    pad83  : CARDINAL ;
    bpl1mod: CARDINAL ;
    bpl2mod: CARDINAL ;
    pad86  : ARRAY [0..1] OF CARDINAL ;
    bpldat : ARRAY [0..5] OF CARDINAL ;
    pad8e  : ARRAY [0..1] OF CARDINAL ;
    sprpt  : ARRAY [0..7] OF ADDRESS ;
    spr    : ARRAY [0..7] OF RECORD
        pos   : CARDINAL ;
        ctl   : CARDINAL ;
        data  : CARDINAL ;
        datab : CARDINAL ;
      END ;
    color  : ARRAY [0..31] OF CARDINAL ;

    (* unknown field types ??? *)

    htotal    : CARDINAL ;
    hsstop    : CARDINAL ;
    hbstrt    : CARDINAL ;
    hbstop    : CARDINAL ;
    vtotal    : CARDINAL ;
    vsstop    : CARDINAL ;
    vbstrt    : CARDINAL ;
    vbstop    : CARDINAL ;
    sprhstrt  : CARDINAL ;
    sprhstop  : CARDINAL ;
    bplhstrt  : CARDINAL ;
    bplhstop  : CARDINAL ;
    hhposw    : CARDINAL ;
    hhposr    : CARDINAL ;
    beamcon0  : BITSET   ;
    hsstrt    : CARDINAL ;
    vsstrt    : CARDINAL ;
    hcenter   : CARDINAL ;
    diwhigh   : CARDINAL ; (* 1e4 *)
    padf3     : ARRAY [0..10] OF CARDINAL ;
    fmode     : CARDINAL ;
 END;

VAR
  custom[0DFF000H] : Custom ;

(* defines for beamcon register *)

CONST
  VARVBLANK	= {12} ; (* Variable vertical blank enable		*)
  LOLDIS	= {11} ; (* long line disable				*)
  CSCBLANKEN	= {10} ; (* redirect composite sync			*)
  VARVSYNC	=  {9} ; (* Variable vertical sync enable		*)
  VARHSYNC	=  {8} ; (* Variable horizontal sync enable		*)
  VARBEAM	=  {7} ; (* variable beam counter enable		*)
  DISPLAYDUAL	=  {6} ; (* use UHRES pointer and standard pointers	*)
  DISPLAYPAL	=  {5} ; (* set decodes to generate PAL display		*)
  VARCSYNC	=  {4} ; (* Variable composite sync enable		*)
  CSBLANK	=  {3} ; (* Composite blank out to CSY* pin		*)
  CSYNCTRUE	=  {2} ; (* composite sync true signal			*)
  VSYNCTRUE	=  {1} ; (* vertical sync true				*)
  HSYNCTRUE	=  {0} ; (* horizontal sync true			*)

(* new defines for bplcon0 *)
  USE_BPLCON3		= {0} ;

(* new defines for bplcon2 *)
  BPLCON2_ZDCTEN	= {10} ; (* colormapped genlock bit	  *)
  BPLCON2_ZDBPEN	= {11} ; (* use bitplane as genlock bits  *)
  BPLCON2_ZDBPSEL0	= {12} ; (* three bits to select one	  *)
  BPLCON2_ZDBPSEL1	= {13} ; (* of 8 bitplanes in		  *)
  BPLCON2_ZDBPSEL2	= {14} ; (* ZDBPEN genlock mode		  *)

(* defines for bplcon3 register *)
  BPLCON3_EXTBLNKEN	= {0} ; (* external blank enable		*)
  BPLCON3_EXTBLKZD	= {1} ; (* external blank ored into trnsprncy   *)
  BPLCON3_ZDCLKEN	= {2} ; (* zd pin outputs a 14mhz clock		*)
  BPLCON3_BRDNTRAN	= {4} ; (* border is opaque			*)
  BPLCON3_BRDNBLNK	= {5} ; (* border is opaque			*)

CONST
  ADKB_SETCLR	= 15 ; (* standard set/clear bit			*)
  ADKB_PRECOMP1	= 14 ; (* two bits of precompensation			*)
  ADKB_PRECOMP0	= 13 ;
  ADKB_MFMPREC	= 12 ; (* use mfm style precompensation			*)
  ADKB_UARTBRK	= 11 ; (* force uart output to zero			*)
  ADKB_WORDSYNC	= 10 ; (* enable DSKSYNC register matching		*)
  ADKB_MSBSYNC	= 9  ; (* (Apple GCR Only) sync on MSB for reading	*)
  ADKB_FAST	= 8  ; (* 1 -> 2 us/bit (mfm), 2 -> 4 us/bit (gcr)	*)
  ADKB_USE3PN	= 7  ; (* use aud chan 3 to modulate period of ??	*)
  ADKB_USE2P3	= 6  ; (* use aud chan 2 to modulate period of 3	*)
  ADKB_USE1P2	= 5  ; (* use aud chan 1 to modulate period of 2	*)
  ADKB_USE0P1	= 4  ; (* use aud chan 0 to modulate period of 1	*)
  ADKB_USE3VN	= 3  ; (* use aud chan 3 to modulate volume of ??	*)
  ADKB_USE2V3	= 2  ; (* use aud chan 2 to modulate volume of 3	*)
  ADKB_USE1V2	= 1  ; (* use aud chan 1 to modulate volume of 2	*)
  ADKB_USE0V1	= 0  ; (* use aud chan 0 to modulate volume of 1	*)

  ADKF_SETCLR	= {15} ;
  ADKF_PRECOMP1 = {14} ;
  ADKF_PRECOMP0	= {13} ;
  ADKF_MFMPREC	= {12} ;
  ADKF_UARTBRK	= {11} ;
  ADKF_WORDSYNC	= {10} ;
  ADKF_MSBSYNC	=  {9} ;
  ADKF_FAST	=  {8} ;
  ADKF_USE3PN	=  {7} ;
  ADKF_USE2P3	=  {6} ;
  ADKF_USE1P2	=  {5} ;
  ADKF_USE0P1	=  {4} ;
  ADKF_USE3VN	=  {3} ;
  ADKF_USE2V3	=  {2} ;
  ADKF_USE1V2	=  {1} ;
  ADKF_USE0V1	=  {0} ;

  ADKF_PRE000NS	= { } ;			(* 000 ns of precomp *)
  ADKF_PRE140NS	= ADKF_PRECOMP0 ;	(* 140 ns of precomp *)
  ADKF_PRE280NS	= ADKF_PRECOMP1 ;	(* 280 ns of precomp *)
  ADKF_PRE560NS	= ADKF_PRECOMP0+ADKF_PRECOMP1 ;
  					(* 560 ns of precomp *)


CONST
  INTB_SETCLR	= 15 ; (* Set/Clear control bit. Determines if bits *)
		       (* written with a 1 get set or cleared. Bits *)
		       (* written with a zero are allways unchanged *)
  INTB_INTEN	= 14 ; (* Master interrupt (enable only )	    *)
  INTB_EXTER	= 13 ; (* External interrupt			    *)
  INTB_DSKSYNC	= 12 ; (* Disk re-SYNChronized			    *)
  INTB_RBF	= 11 ; (* serial port Receive Buffer Full	    *)
  INTB_AUD3	= 10 ; (* Audio channel 3 block finished	    *)
  INTB_AUD2	=  9 ; (* Audio channel 2 block finished	    *)
  INTB_AUD1	=  8 ; (* Audio channel 1 block finished	    *)
  INTB_AUD0	=  7 ; (* Audio channel 0 block finished	    *)
  INTB_BLIT	=  6 ; (* Blitter finished			    *)
  INTB_VERTB	=  5 ; (* start of Vertical Blank		    *)
  INTB_COPER	=  4 ; (* Coprocessor				    *)
  INTB_PORTS	=  3 ; (* I/O Ports and timers			    *)
  INTB_SOFTINT	=  2 ; (* software interrupt request		    *)
  INTB_DSKBLK	=  1 ; (* Disk Block done			    *)
  INTB_TBE	=  0 ; (* serial port Transmit Buffer Empty	    *)

  INTF_SETCLR	= {15} ;
  INTF_INTEN	= {14} ;
  INTF_EXTER	= {13} ;
  INTF_DSKSYNC	= {12} ;
  INTF_RBF	= {11} ;
  INTF_AUD3	= {10} ;
  INTF_AUD2	=  {9} ;
  INTF_AUD1	=  {8} ;
  INTF_AUD0	=  {7} ;
  INTF_BLIT	=  {6} ;
  INTF_VERTB	=  {5} ;
  INTF_COPER	=  {4} ;
  INTF_PORTS	=  {3} ;
  INTF_SOFTINT	=  {2} ;
  INTF_DSKBLK	=  {1} ;
  INTF_TBE	=  {0} ;

(* write definitions for dmaconw *)
CONST
  DMAF_SETCLR  = {15} ;
  DMAF_AUD0    =  {0} ;
  DMAF_AUD1    =  {1} ;
  DMAF_AUD2    =  {2} ;
  DMAF_AUD3    =  {3} ;
  DMAF_DISK    =  {4} ;
  DMAF_SPRITE  =  {5} ;
  DMAF_BLITTER =  {6} ;
  DMAF_COPPER  =  {7} ;
  DMAF_RASTER  =  {8} ;
  DMAF_MASTER  =  {9} ;
  DMAF_BLITHOG = {10} ;

  DMAF_AUDIO   = {0..3} ; (* 4 bit mask *)
  DMAF_ALL     = {0..8} ; (* all dma channels *)

(* read definitions for dmaconr *)
(* bits 0-8 correspnd to dmaconw definitions *)
  DMAF_BLTDONE  = {14} ;
  DMAF_BLTNZERO	= {13} ;

CONST
  DMAB_AUD0	=  0 ;
  DMAB_AUD1	=  1 ;
  DMAB_AUD2	=  2 ;
  DMAB_AUD3	=  3 ;
  DMAB_DISK	=  4 ;
  DMAB_SPRITE	=  5 ;
  DMAB_BLITTER	=  6 ;
  DMAB_COPPER	=  7 ;
  DMAB_RASTER	=  8 ;
  DMAB_MASTER	=  9 ;
  DMAB_BLITHOG  = 10 ;
  DMAB_BLTDONE  = 14 ;
  DMAB_BLTNZERO	= 13 ;
  DMAB_SETCLR	= 15 ;

END Hardware.
