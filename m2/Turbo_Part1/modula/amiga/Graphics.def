DEFINITION FOR LIBRARY MODULE Graphics ;

FROM SYSTEM	IMPORT ADDRESS, STRING, SHORTSET, LONGSET ;

FROM Exec	IMPORT Node, Message, NodePtr, SignalSemaphore, MsgPortPtr,
		       List, Library, Interrupt, TaskPtr, MinList,
		       SignalSemaphorePtr ;

FROM Utility	IMPORT TagItem, TAG_USER, TagItemPtr, HookPtr ;

FROM Hardware	IMPORT bltnodePtr, DISPLAYPAL, VARVBLANK, LOLDIS, VARVSYNC,
		       VARHSYNC, VARBEAM, CSBLANK, VSYNCTRUE ;

TYPE
  CopInsPtr		 =  POINTER TO CopIns ;
  cprlistPtr		 =  POINTER TO cprlist ;
  CopListPtr		 =  POINTER TO CopList ;
  UCopListPtr		 =  POINTER TO UCopList ;
  copinitPtr		 =  POINTER TO copinit ;
  VSpritePtr		 =  POINTER TO VSprite ;
  BobPtr		 =  POINTER TO Bob ;
  AnimCompPtr		 =  POINTER TO AnimComp ;
  AnimObPtr		 =  POINTER TO AnimOb ;
  DBufPacketPtr		 =  POINTER TO DBufPacket ;
  collTablePtr		 =  POINTER TO collTable ;
  ExtendedNodePtr	 =  POINTER TO ExtendedNode ;
  IsrvstrPtr		 =  POINTER TO Isrvstr ;
  Layer_InfoPtr		 =  POINTER TO Layer_Info ;
  BitScaleArgsPtr	 =  POINTER TO BitScaleArgs ;
  SimpleSpritePtr	 =  POINTER TO SimpleSprite ;
  ExtSpritePtr		 =  POINTER TO ExtSprite ;
  TextAttrPtr		 =  POINTER TO TextAttr ;
  TTextAttrPtr		 =  POINTER TO TTextAttr ;
  TextFontPtr		 =  POINTER TO TextFont  ;
  TextFontExtensionPtr	 =  POINTER TO TextFontExtension ;
  ColorFontColorsPtr	 =  POINTER TO ColorFontColors ;
  ColorTextFontPtr	 =  POINTER TO ColorTextFont ;
  TextExtentPtr		 =  POINTER TO TextExtentRec ;
  MonitorSpecPtr	 =  POINTER TO MonitorSpec ;
  AnalogSignalIntervalPtr=  POINTER TO AnalogSignalInterval ;
  SpecialMonitorPtr	 =  POINTER TO SpecialMonitor ;
  RectanglePtr		 =  POINTER TO Rectangle ;
  Rect32Ptr		 =  POINTER TO Rect32 ;
  BitMapPtr		 =  POINTER TO BitMap ;
  AreaInfoPtr		 =  POINTER TO AreaInfo ;
  TmpRasPtr		 =  POINTER TO TmpRas ;
  GelsInfoPtr		 =  POINTER TO GelsInfo ;
  RastPortPtr		 =  POINTER TO RastPort ;
  RegionRectanglePtr	 =  POINTER TO RegionRectangle ;
  RegionPtr		 =  POINTER TO Region ;
  LayerPtr		 =  POINTER TO Layer ;
  ClipRectPtr		 =  POINTER TO ClipRect ;
  QueryHeaderPtr	 =  POINTER TO QueryHeader ;
  DisplayInfoPtr	 =  POINTER TO DisplayInfo ;
  DimensionInfoPtr	 =  POINTER TO DimensionInfo ;
  MonitorInfoPtr	 =  POINTER TO MonitorInfo ;
  NameInfoPtr		 =  POINTER TO NameInfo ;
  ViewPortPtr		 =  POINTER TO ViewPort ;
  ViewPtr		 =  POINTER TO View ;
  ViewExtraPtr		 =  POINTER TO ViewExtra ;
  ViewPortExtraPtr	 =  POINTER TO ViewPortExtra ;
  RasInfoPtr		 =  POINTER TO RasInfo ;
  ColorMapPtr		 =  POINTER TO ColorMap ;
  PaletteExtraPtr	 =  POINTER TO PaletteExtra ;
  DBufInfoPtr		 =  POINTER TO DBufInfo ;
  GfxBasePtr		 =  POINTER TO GfxBaseRec ;


TYPE
  Rectangle = RECORD
    MinX , MinY : INTEGER ;
    MaxX , MaxY : INTEGER ;
  END ;

  Rect32 = RECORD
    MinX , MinY : LONGINT ;
    MaxX , MaxY : LONGINT ;
  END ;

  tPoint = RECORD x , y : INTEGER END ;

  Point = tPoint ;

  PLANEPTR = ADDRESS ;

  BitMap = RECORD
    BytesPerRow : CARDINAL  ;
    Rows	: CARDINAL  ;
    Flags	: SHORTSET  ;
    Depth	: SHORTCARD ;
    pad		: CARDINAL  ;
    Planes	: ARRAY [0..7] OF PLANEPTR ;
  END ;

(* This macro is obsolete as of V39.AllocBitMap()should be used for allocating*)
(* bitmap data, since it knows about the machine's particular alignment	      *)
(* restrictions.							      *)

PROCEDURE RASSIZE( w , h : CARDINAL ) : CARDINAL ;

(* flags for AllocBitMap, etc. *)

CONST
  BMB_CLEAR	  = 0 ;
  BMB_DISPLAYABLE = 1 ;
  BMB_INTERLEAVED = 2 ;
  BMB_STANDARD	  = 3 ;
  BMB_MINPLANES   = 4 ;

  BMF_CLEAR	  = {BMB_CLEAR} ;
  BMF_DISPLAYABLE = {BMB_DISPLAYABLE} ;
  BMF_INTERLEAVED = {BMB_INTERLEAVED} ;
  BMF_STANDARD	  = {BMB_STANDARD} ;
  BMF_MINPLANES	  = {BMB_MINPLANES} ;

(* the following are for GetBitMapAttr() *)
  BMA_HEIGHT =  0 ;
  BMA_DEPTH  =  4 ;
  BMA_WIDTH  =  8 ;
  BMA_FLAGS  = 12 ;

TYPE
  AreaInfo = RECORD
    VctrTbl	: ADDRESS ;	(* ptr to start of vector table		      *)
    VctrPtr	: ADDRESS ;	(* ptr to current vertex		      *)
    FlagTbl	: ADDRESS ;	(* ptr to start of vector flag table	      *)
    FlagPtr	: ADDRESS ;	(* ptrs to areafill flags		      *)
    Count	: INTEGER ;	(* number of vertices in list		      *)
    MaxCount	: INTEGER ;	(* AreaMove/Draw will not allow Count>MaxCount*)
    FirstX 	: INTEGER ;
    FirstY	: INTEGER ;	(* first point for this polygon		      *)
  END ;

  TmpRas = RECORD
    RasPtr : ADDRESS ;
    Size   : LONGINT ;
  END ;

(* unoptimized for 32bit alignment of pointers *)

  GelsInfo = RECORD
    sprRsrvd	  : SHORTCARD  ; (* flag of which sprites to reserve from *)
    				 (* vsprite system			  *)
    Flags	  : SHORTSET   ; (* system use				  *)
    gelHead	  : VSpritePtr ;
    gelTail	  : VSpritePtr ; (* dummy vSprites for list management	  *)

    nextLine	  : ADDRESS ;    (* pointer to array of 8 WORDS for sprite*)
    				 (* available lines			  *)

    lastColor	  : ADDRESS ;    (* pointer to array of 8 pointers for	  *)
    				 (* color-last-assigned to vSprites	  *)
    collHandler	  : collTablePtr;(* addresses of collision routines	  *)
    leftmost	  : INTEGER ;
    rightmost	  : INTEGER ;
    topmost	  : INTEGER ;
    bottommost	  : INTEGER ;
    firstBlissObj : ADDRESS ;
    lastBlissObj  : ADDRESS ;    (* system use only			  *)
  END ;

  RastPort = RECORD
    Layer	: LayerPtr ;
    BitMap	: BitMapPtr ;
    AreaPtrn 	: ADDRESS ;	(* ptr to areafill pattern		  *)
    TmpRas	: TmpRasPtr ;
    AreaInfo 	: AreaInfoPtr ;
    GelsInfo 	: GelsInfoPtr ;
    Mask	: SHORTSET ;	(* write mask for this raster		  *)
    FgPen	: SHORTINT ;	(* foreground pen for this raster	  *)
    BgPen	: SHORTINT ;	(* background pen			  *)
    AOlPen	: SHORTINT ;	(* areafill outline pen			  *)
    DrawMode	: SHORTSET ;	(* drawing mode for fill, lines, and text *)
    AreaPtSz 	: SHORTINT ;	(* 2^n words for areafill pattern	  *)
    linpatcnt 	: SHORTINT ;	(* current line drawing pattern preshift  *)
    dummy	: SHORTINT ;
    Flags	: BITSET  ;	(* miscellaneous control bits		  *)
    LinePtrn 	: CARDINAL ;	(* 16 bits for textured lines		  *)
    cp_x	: INTEGER ;
    cp_y	: INTEGER ;	(* current pen position			  *)
    minterms	: ARRAY [0..7] OF SHORTINT ;
    PenWidth	: INTEGER ;
    PenHeight	: INTEGER ;
    Font	: TextFontPtr ;	(* current font address			  *)
    AlgoStyle	: SHORTSET ;	(* the algorithmically generated style	  *)
    TxFlags	: SHORTSET ;	(* text specific flags			  *)
    TxHeight	: CARDINAL ;	(* text height				  *)
    TxWidth	: CARDINAL ;	(* text nominal width			  *)
    TxBaseline	: CARDINAL ;	(* text baseline			  *)
    TxSpacing 	: INTEGER ;	(* text spacing (per character)		  *)
    RP_User	: ADDRESS ;
    longreserved: ARRAY [0..1] OF LONGINT  ;
    wordreserved: ARRAY [0..6] OF INTEGER  ; (* used to be a node	  *)
    reserved	: ARRAY [0..7] OF SHORTINT ; (* for future use		  *)
  END;

CONST
  (* drawing modes *)
  JAM1	     = {}  ;	(* jam 1 color into raster			*)
  JAM2	     = {0} ;	(* jam 2 colors into raster			*)
  COMPLEMENT = {1} ;	(* XOR bits into raster				*)
  INVERSVID  = {2} ;	(* inverse video for drawing modes		*)

  (* these are the flag bits for RastPort flags *)

  FRST_DOT = {0} ;	(* draw the first dot of this line ?		*)
  ONE_DOT  = {1} ;	(* use one dot mode for drawing lines		*)
  DBUFFER  = {2} ;	(* flag set when RastPorts are double-buffered	*)

(* only used for bobs *)

  AREAOUTLINE = {3} ;	(* used by areafiller		*)
  NOCROSSFILL = {5} ;	(* areafills have no crossovers *)

(* there is only one style of clipping: raster clipping			  *)
(* this preserves the continuity of jaggies regardless of clip window	  *)
(* When drawing into a RastPort, if the ptr to ClipRect is nil then there *)
(* is no clipping done, this is dangerous but useful for speed		  *)

TYPE
  RegionRectangle = RECORD
    Next , Prev : RegionRectanglePtr ;
    bounds : Rectangle ;
  END ;

  Region = RECORD
    bounds : Rectangle ;
    RegionRectangle : RegionRectanglePtr ;
  END ;

  Layer = RECORD
    front , back	: LayerPtr ;	(* ignored by roms		      *)
    ClipRect		: ClipRectPtr ;	(* read by roms to find first cliprect*)
    rp			: RastPortPtr ;
    bound		: Rectangle ;	(* ignored by roms		      *)
    reserved		: ARRAY [0..3] OF SHORTINT ;
    priority		: CARDINAL ;	(* system use only		      *)
    Flags		: BITSET  ;	(* obscured ?, Virtual BitMap?	      *)
    SuperBitMap		: BitMapPtr ;
    SuperClipRect	: ClipRectPtr;	(* super bitmap cliprects if	      *)
    					(* VBitMap != 0 else damage cliprect  *)
    					(* list for refresh		      *)

    Window		: ADDRESS ;	(* reserved for user interface use    *)
    Scroll_X, Scroll_Y	: INTEGER ;
    cr, cr2, crnew	: ClipRectPtr ;	(* used by dedice		      *)
    SuperSaveClipRects	: ClipRectPtr ; (* preallocated cr's		      *)
    _cliprects		: ClipRectPtr ;	(* system use during refresh	      *)
    LayerInfo		: Layer_InfoPtr;(* points to head of the list	      *)
    Lock		: SignalSemaphore ;
    reserved3		: ARRAY [0..7] OF SHORTINT ;
    ClipRegion		: RegionPtr ;
    saveClipRects	: RegionPtr ;	(* used to back out when in trouble   *)
    Width,Height	: INTEGER ;	(* system use			      *)
    reserved2		: ARRAY [0..17] OF SHORTCARD ;
    (* this must stay here *)
    DamageList		: RegionPtr ;	(* list of rectngls to refresh throug *)
  END ;

  ClipRect = RECORD
    Next	: ClipRectPtr ;	(* roms used to find next ClipRect	*)
    prev	: ClipRectPtr ; (* Temp use in layers (private)		*)
    lobs	: LayerPtr    ; (* Private use for layers		*)
    BitMap	: BitMapPtr   ; (* Bitmap for layers private use	*)
    bounds	: Rectangle   ; (* bounds of cliprect			*)
    _p1,_p2	: ADDRESS     ;	(* system reserved			*)
    reserved	: LONGINT     ;	(* system use				*)
  END ;

CONST

  (* internal cliprect flags *)

  CR_NEEDS_NO_CONCEALED_RASTERS  = 1 ;
  CR_NEEDS_NO_LAYERBLIT_DAMAGE   = 2 ;

  (* defines for code values for getcode *)

  ISLESSX = 1 ;
  ISLESSY = 2 ;
  ISGRTRX = 4 ;
  ISGRTRY = 8 ;


CONST  (* VSprite flags *)

  (* user-set VSprite flags: *)
  SUSERFLAGS  = {0..7} ; (* mask of all user-settable VSprite-flags *)

  VSPRITE     = {0} ; (* set if VSprite, clear if Bob			*)
  SAVEBACK    = {1} ; (* set if background is to be saved/restored	*)
  OVERLAY     = {2} ; (* set to mask image of Bob onto background	*)
  MUSTDRAW    = {3} ; (* set if VSprite absolutely must be drawn	*)

  (* system-set VSprite flags: *)

  BACKSAVED   = {8}  ; (* this Bob's background has been saved		*)
  BOBUPDATE   = {9}  ; (* temporary flag, useless to outside world	*)
  GELGONE     = {10} ; (* set if gel is completely clipped (offscreen)	*)
  VSOVERFLOW  = {11} ; (* VSprite overflow (if MUSTDRAW set we draw!)	*)

  (* Bob flags *)
  (* these are the user flag bits *)

  BUSERFLAGS 	= {0..7} ; (* mask of all user-settable Bob-flags	*)
  SAVEBOB	= {0} ;    (* set to not erase Bob			*)
  BOBISCOMP	= {1} ;    (* set to identify Bob as AnimComp		*)

  (* these are the system flag bits *)

  BWAITING	= {08} ; (* set while Bob is waiting on 'after'		*)
  BDRAWN	= {09} ; (* set when Bob is drawn this DrawG pass	*)
  BOBSAWAY   	= {10} ; (* set to initiate removal of Bob		*)
  BOBNIX	= {11} ; (* set when Bob is completely removed		*)
  SAVEPRESERVE	= {12} ; (* for back-restore during double-buffer	*)
  OUTSTEP	= {13} ; (* for double-clearing if double-buffer	*)

  (* defines for the animation procedures *)
  ANFRACSIZE  = 00006H ;
  ANIMHALF    = 00020H ;
  RINGTRIGGER = 00001H ;


(* UserStuff definitions						      *)
(*  Modula does not have an #include or an extensible datatype mechanism,     *)
(* if you need to add your own data ( and integer is inappropriate ) declare  *)
(* something like							      *)
(*									      *)
(*       TYPE								      *)
(*         BobExt = RECORD bob : Bob ; userStuff : <..> END ;		      *)
(*									      *)
(*  and access userStuff using casts.					      *)
(*									      *)
(* see the manual for a thorough definition of the UserStuff definitions      *)

TYPE
  VUserStuff = INTEGER ;  (* Sprite user stuff  *)
  BUserStuff = INTEGER ;  (* Bob user stuff	*)
  AUserStuff = INTEGER ;  (* AnimOb user stuff	*)


(*--------------------- GEL STRUCTURES -------------------------------------*)


TYPE
  VSprite = RECORD
    (* GEL linked list forward/backward pointers sorted by y,x value *)

    NextVSprite : VSpritePtr ;
    PrevVSprite : VSpritePtr ;

    (* GEL draw list constructed in the order the Bobs are actually drawn, *)
    (*  then list is copied to clear list				   *)
    (*  must be here in VSprite for system boundary detection		   *)

    DrawPath	: VSpritePtr ; (* pointer of overlay drawing   *)
    ClearPath	: VSpritePtr ; (* pointer for overlay clearing *)

    (* the VSprite positions are defined in (y,x) order to make sorting  *)
    (*  sorting easier, since (y,x) as a long integer			 *)

    OldY, OldX	: INTEGER ; (* previous position *)
    Flags	: BITSET  ; (* VSprite flags	 *)

    (* the VSprite positions are defined in (y,x) order to make sorting *)
    (* sorting easier, since (y,x) as a long integer			*)

    Y, X 	: INTEGER ; (* screen position				 *)
    Height	: INTEGER ;
    Width	: INTEGER ; (* number of words per row of image data	 *)
    Depth	: INTEGER ; (* number of planes of data			 *)
    MeMask	: BITSET  ; (* which types can collide with this VSprite *)
    HitMask	: BITSET  ; (* which types this VSprite can collide with *)
    ImageData	: ADDRESS ; (* pointer to VSprite image			 *)

    (* borderLine is the one-dimensional logical OR of all	   *)
    (* the VSprite bits, used for fast collision detection of edge *)

    BorderLine	: ADDRESS ; (* logical OR of all VSprite bits	        *)
    CollMask	: ADDRESS ; (* similar to above except this is a matrix *)

    (* pointer to this VSprite's color definitions (not used by Bobs)	*)

    SprColors	: ADDRESS ;
    VSBob	: BobPtr  ; (* points home if this VSprite is part of a Bob *)

(* planePick flag:  set bit selects a plane from image, clear bit selects     *)
(*  use of shadow mask for that plane					      *)
(* OnOff flag: if using shadow mask to fill plane, this bit (corresponding    *)
(*  to bit in planePick) describes whether to fill with 0's or 1's	      *)
(* There are two uses for these flags:					      *)
(*   - if this is the VSprite of a Bob, these flags describe how the Bob      *)
(*     is to be drawn into memory					      *)
(*   - if this is a simple VSprite and the user intends on setting the        *)
(*     MUSTDRAW flag of the VSprite, these flags must be set too to describe  *)
(*     which color registers the user wants for the image		      *)

    PlanePick  : SHORTINT ;
    PlaneOnOff : SHORTINT ;
    VUserExt   : VUserStuff ;
  END ;


  Bob = RECORD
    Flags	: BITSET  ; (* general purpose flags (see definitions below)  *)
    SaveBuffer	: ADDRESS ; (* pointer to the buffer for background save      *)
    ImageShadow : ADDRESS ; (* used by Bobs for "cookie-cutting"	      *)
    			    (* and multi-plane masking			      *)

    (* pointer to BOBs for sequenced drawing of Bobs		*)
    (* for correct overlaying of multiple component animations	*)

    Before	: BobPtr	; (* draw this Bob before Bob pointed to *)
    				  (* by before				 *)
    After 	: BobPtr	; (* draw this Bob after Bob pointed to  *)
    				  (* by after				 *)
    BobVSprite	: VSpritePtr	; (* this Bob's VSprite definition	 *)
    BobComp	: AnimCompPtr	; (* pointer to this Bob's AnimComp def  *)
    DBuffer	: DBufPacketPtr	; (* pointer to this Bob's dBuf packet	 *)
    BUserExt	: BUserStuff	; (* Bob user extension			 *)
  END ;


  AnimComp = RECORD
    Flags	: BITSET  ;	(* AnimComp flags for system & user	      *)
    Timer	: INTEGER ;	(* timer defines how long to keep this	      *)
				(* component active:			      *)
				(* if set non-zero, timer decrements to zero  *)
				(* then switches to nextSeq if set to zero,   *)
				(* AnimComp never switches		      *)

    TimeSet	: INTEGER ;	(* initial value for timer when the AnimComp  *)
    				(* is activated by the system		      *)
    NextComp	: AnimCompPtr ;	(* pointer to next and previous components of *)
    				(* animation object			      *)
    PrevComp	: AnimCompPtr ;
    NextSeq	: AnimCompPtr ;	(* pointer to component component definition  *)
    				(* of next image in sequence		      *)
    PrevSeq	: AnimCompPtr ;
    AnimCRoutine: PROCEDURE( ) : INTEGER ;
    				(* address of special animation procedure     *)
    YTrans	: INTEGER ;     (* init y translation (if this is a component)*)
    XTrans	: INTEGER ;     (* init x translation (if this is a component)*)
    HeadOb	: AnimObPtr ;
    AnimBob	: BobPtr ;
  END ;


 AnimOb = RECORD
    NextOb, PrevOb : AnimObPtr ;

(* number of calls to Animate this AnimOb has endured *)
    Clock		: LONGINT ;
    AnOldY, AnOldX	: INTEGER ; (* old y,x coordinates		*)
    AnY, AnX		: INTEGER ; (* y,x coordinates of the AnimOb	*)
    YVel, XVel		: INTEGER ; (* velocities of this object	*)
    YAccel, XAccel	: INTEGER ; (* accelerations of this object	*)
    RingYTrans,
    RingXTrans		: INTEGER ; (* ring translation values		*)
    AnimORoutine	: PROCEDURE(): INTEGER ;
    			  (* address of special animation procedure *)

    HeadComp		: AnimCompPtr ; (* pointer to first component	*)
    AUserExt		: AUserStuff  ;	(* AnimOb user extension	*)
  END ;

(* dBufPacket defines the values needed to be saved across buffer to buffer   *)
(*  when in double-buffer mode						      *)

  DBufPacket = RECORD
    BufY, BufX	: INTEGER    ; (* save the other buffers screen coordinates *)
    BufPath	: VSpritePtr ; (* carry the draw path over the gap	    *)

    (* these pointers must be filled in by the user *)
    (* pointer to other buffer's background save buffer *)

    BufBuffer	: ADDRESS ;
  END ;

(*-------------------------- Gels Macros ---------------------------------*)

PROCEDURE InitAnimate( animKey : ADDRESS ) ;
PROCEDURE RemBob( b : BobPtr ) ;

(*------------------------------------------------------------------------*)

CONST
  B2NORM   = 0 ;
  B2SWAP   = 1 ;
  B2BOBBER = 2 ;

(*------------------------------------------------------------------------*)

(* a structure to contain the 16 collision procedure addresses *)

TYPE
  LongProc = PROCEDURE( ) : LONGINT ;
  collTable = RECORD
    collPtrs : ARRAY [0..15] OF LongProc ;
  END ;

  ExtendedNode = RECORD
    xln_Succ	  : NodePtr ;
    xln_Pred	  : NodePtr ;
    xln_Type	  : SHORTCARD ;
    xln_Pri 	  : SHORTINT ;
    xln_Name	  : STRING ;
    xln_Subsystem : SHORTCARD ;
    xln_Subtype	  : SHORTCARD ;
    xln_Library	  : LONGINT ;
    xln_Init	  : LongProc ;
  END ;

CONST
  SS_GRAPHICS = 002H ;

  VIEW_EXTRA_TYPE	= 1 ;
  VIEWPORT_EXTRA_TYPE	= 2 ;
  SPECIAL_MONITOR_TYPE	= 3 ;
  MONITOR_SPEC_TYPE	= 4 ;

  (* structure used by AddTOFTask *)

TYPE
  Isrvstr = RECORD
    is_Node : Node ;
    Iptr    : IsrvstrPtr ;   (* passed to srvr by os *)
    code    : LongProc ;
    ccode   : LongProc ;
    Carg    : LONGINT  ;
  END ;

CONST
  LAYERSIMPLE		= {0} ;
  LAYERSMART		= {1} ;
  LAYERSUPER		= {2} ;
  LAYERUPDATING		= {4} ;
  LAYERBACKDROP		= {6} ;
  LAYERREFRESH		= {7} ;
  LAYERIREFRESH		= {9} ;
  LAYERIREFRESH2	= {10};
  LAYER_CLIPRECTS_LOST	= {8} ;	(* during BeginUpdate		 *)
				(* or during layerop		 *)
				(* this happens if out of memory *)

TYPE
  Layer_Info = RECORD
    top_layer		: LayerPtr ;
    check_lp		: LayerPtr ;		(* !! Private !! *)
    obs			: ClipRectPtr ;
    FreeClipRects	: ClipRectPtr ;		(* !! Private !! *)
    PrivateReserve1	: LONGINT ;		(* !! Private !! *)
    PrivateReserve2	: LONGINT ;		(* !! Private !! *)
    Lock		: SignalSemaphore ;	(* !! Private !! *)
    gs_Head		: MinList ;		(* !! Private !! *)
    PrivateReserve3	: INTEGER ;		(* !! Private !! *)
    PrivateReserve4	: ADDRESS ;		(* !! Private !! *)
    Flags		: BITSET   ;
    fatten_count	: SHORTINT ;		(* !! Private !! *)
    LockLayersCount	: SHORTINT ;		(* !! Private !! *)
    PrivateReserve5	: INTEGER  ;		(* !! Private !! *)
    BlankHook		: ADDRESS  ;		(* !! Private !! *)
    LayerInfo_extra	: ADDRESS  ;		(* !! Private !! *)
  END ;

CONST
  NEWLAYERINFO_CALLED = 1 ;

  (* LAYERS_NOBACKFILL is the value needed to get no backfill hook	  *)
  (* LAYERS_BACKFILL is the value needed to get the default backfill hook *)

  LAYERS_NOBACKFILL = HookPtr( 1 ) ;
  LAYERS_BACKFILL   = HookPtr( 0 ) ;


  RPTAG_Font		= 080000000H ;	(* get/set font			      *)
  RPTAG_APen		= 080000002H ;	(* get/set apen			      *)
  RPTAG_BPen		= 080000003H ;	(* get/set bpen			      *)
  RPTAG_DrMd		= 080000004H ;	(* get/set draw mode		      *)
  RPTAG_OutLinePen	= 080000005H ;	(* get/set outline pen		      *)
  RPTAG_OutlinePen	= 080000005H ;	(* get/set outline pen.corrected case *)
  RPTAG_WriteMask	= 080000006H ;	(* get/set WriteMask		      *)
  RPTAG_MaxPen		= 080000007H ;	(* get/set maxpen		      *)

  RPTAG_DrawBounds	= 080000008H ;	(* get only rastport draw bounds.     *)
  					(* pass & rect			      *)

TYPE
  BitScaleArgs = RECORD
    bsa_SrcX		: CARDINAL ;
    bsa_SrcY		: CARDINAL ;	(* source origin 		*)
    bsa_SrcWidth	: CARDINAL ;
    bsa_SrcHeight	: CARDINAL ;	(* source size 			*)
    bsa_XSrcFactor	: CARDINAL ;
    bsa_YSrcFactor	: CARDINAL ;	(* scale factor denominators 	*)
    bsa_DestX		: CARDINAL ;
    bsa_DestY		: CARDINAL ;	(* destination origin		*)
    bsa_DestWidth	: CARDINAL ;
    bsa_DestHeight	: CARDINAL ;	(* destination size result	*)
    bsa_XDestFactor	: CARDINAL ;
    bsa_YDestFactor	: CARDINAL ;	(* scale factor numerators	*)
    bsa_SrcBitMap 	: BitMapPtr;	(* source BitMap		*)
    bsa_DestBitMap	: BitMapPtr;	(* destination BitMap		*)
    bsa_Flags		: LONGSET  ;	(* reserved.  Must be zero!	*)
    bsa_XDDA, bsa_YDDA	: CARDINAL ;	(* reserved			*)
    bsa_Reserved1	: LONGINT  ;
    bsa_Reserved2	: LONGINT  ;
  END ;

CONST
  SPRITE_ATTACHED = 080H ;

TYPE
  SimpleSprite = RECORD
    posctldata	: ADDRESS  ;
    height	: CARDINAL ;
    x , y	: CARDINAL ; (* current position *)
    num		: CARDINAL ;
  END ;

  ExtSprite = RECORD
    es_SimpleSprite : SimpleSprite ; (* conventional simple sprite structure *)
    es_wordwidth    : CARDINAL ;     (* graphics use only, subject to change *)
    es_flags	    : BITSET  ;	     (* graphics use only, subject to change *)
  END ;

CONST
  (* tags for AllocSpriteData() *)

  SPRITEA_Width		= 081000000H ;
  SPRITEA_XReplication	= 081000002H ;
  SPRITEA_YReplication	= 081000004H ;
  SPRITEA_OutputHeight	= 081000006H ;
  SPRITEA_Attached	= 081000008H ;
  SPRITEA_OldDataFormat	= 08100000AH ;
  			  (* MUST pass in outputheight if using this tag *)

  (* tags for GetExtSprite() *)

  GSTAG_SPRITE_NUM = 082000020H ;
  GSTAG_ATTACHED   = 082000022H ;
  GSTAG_SOFTSPRITE = 082000024H ;

  (* tags valid for either GetExtSprite or ChangeExtSprite *)

  GSTAG_SCANDOUBLED = 083000000H ; (* request "NTSC-Like" height if possible *)

(*---------------------------------------------------------------------------*)

TYPE
  ViewPort = RECORD
    Next	: ViewPortPtr ;
    ColorMap	: ColorMapPtr ;	(* table of colors for this viewport *)
				(* if this is nil, MakeVPort assumes *)
				(* default values		     *)

    DspIns	: CopListPtr ;	(* user by MakeView()	*)
    SprIns	: CopListPtr ;	(* used by sprite stuff	*)
    ClrIns	: CopListPtr ;	(* used by sprite stuff	*)
    UCopIns	: UCopListPtr ;	(* User copper list	*)
    DWidth	: INTEGER ;
    DHeight	: INTEGER ;
    DxOffset	: INTEGER ;
    DyOffset	: INTEGER ;
    Modes	: BITSET  ;
    SpritePriorities : SHORTCARD ;
    ExtendedModes : SHORTSET ;
    RasInfo	: RasInfoPtr ;
  END ;

  View = RECORD
    ViewPort   : ViewPortPtr ;
    LOFCprList : cprlistPtr ; (* used for interlaced and noninterlaced     *)
    SHFCprList : cprlistPtr ; (* only used during interlace		   *)
    DyOffset   : INTEGER    ;
    DxOffset   : INTEGER    ; (* for complete View positioning		   *)
			      (* offsets are +- adjustments to standard #s *)
    Modes      : BITSET     ; (* such as INTERLACE, GENLOC		   *)
  END ;


  (* these structures are obtained via GfxNew *)
  (* and disposed by GfxFree		      *)

  ViewExtra = RECORD
    n	    : ExtendedNode   ;
    View    : ViewPtr	     ;	(* backwards link	  *)
    Monitor : MonitorSpecPtr ;	(* monitors for this view *)
    TopLine : CARDINAL	     ;
  END ;

  (* this structure is obtained via GfxNew *)
  (* and disposed by GfxFree		   *)

  ViewPortExtra = RECORD
    n 		: ExtendedNode ;
    ViewPort	: ViewPortPtr ;	(* backwards link			  *)
    DisplayClip : Rectangle ;	(* MakeVPort display clipping information *)

    (* These are added for V39 *)

    VecTable	: ADDRESS ; (* Private *)
    DriverData	: ARRAY [0..1] OF ADDRESS ;
    Flags	: BITSET  ;
    Origin	: ARRAY [0..1] OF Point;(* First visible point relative to  *)
    					(* the DClip.			    *)
					(* One for each possible playfield. *)

    cop1ptr	: ADDRESS ; (* private *)
    cop2ptr	: ADDRESS ; (* private *)
  END ;

CONST

  (* All these VPXF_flags are private *)

  VPXB_FREE_ME		= 0 ;
  VPXF_FREE_ME		= {VPXB_FREE_ME} ;
  VPXB_LAST		= 1 ;
  VPXF_LAST		= {VPXB_LAST} ;
  VPXB_STRADDLES_256	= 4 ;
  VPXF_STRADDLES_256	= {VPXB_STRADDLES_256} ;
  VPXB_STRADDLES_512	= 5 ;
  VPXF_STRADDLES_512	= {VPXB_STRADDLES_512} ;


  EXTEND_VSTRUCT	= {12}; (* unused bit in Modes field of View	*)

  VPF_A2024		= {6} ;	(* VP?_ fields internal only		*)
  (*  VPF_TENHZ		= {5} ; does not match VPB_TENHZ ??*)
  VPB_A2024		=  6  ;
  (*  VPB_TENHZ		=  4  ;*)

  (* defines used for Modes in IVPargs *)

  GENLOCK_VIDEO	  =  {1} ;
  LACE		  =  {2} ;
  DOUBLESCAN	  =  {3} ;
  SUPERHIRES	  =  {5} ;
  PFBA		  =  {6} ;
  EXTRA_HALFBRITE =  {7} ;
  GENLOCK_AUDIO	  =  {8} ;
  DUALPF	  = {10} ;
  HAM		  = {11} ;
  EXTENDED_MODE	  = {12} ;
  VP_HIDE	  = {13} ;
  SPRITES	  = {14} ;
  HIRES		  = {15} ;

TYPE
  RasInfo = RECORD (* used by callers to and InitDspC() *)
    Next	: RasInfoPtr ; (* used for dualpf		*)
    BitMap	: BitMapPtr  ;
    RxOffset	: INTEGER    ;
    RyOffset	: INTEGER    ; (* scroll offsets in this BitMap *)
  END ;

  ColorMap = RECORD
    Flags		: SHORTSET ;
    Type		: SHORTCARD ;
    Count		: CARDINAL ;
    ColorTable		: ADDRESS ;
    cm_vpe		: ViewPortExtraPtr ;
    LowColorBits	: ADDRESS ;
    TransparencyPlane	: SHORTCARD ;
    SpriteResolution	: SHORTCARD ;
    SpriteResDefault	: SHORTCARD ;(* what resolution you get when you have *)
    				     (* set SPRITERESN_DEFAULT		      *)
    AuxFlags		: SHORTSET ;
    cm_vp		: ViewPortPtr ;
    NormalDisplayInfo	: ADDRESS ;
    CoerceDisplayInfo	: ADDRESS ;
    cm_batch_items	: TagItemPtr ;
    VPModeID		: LONGINT ;
    PalExtra		: PaletteExtraPtr ;
    SpriteBase_Even	: CARDINAL ;
    SpriteBase_Odd	: CARDINAL ;
    Bp_0_base		: CARDINAL ;
    Bp_1_base		: CARDINAL ;
  END ;

(* if Type == 0 then ColorMap is V1.2/V1.3 compatible *)
(* if Type != 0 then ColorMap is V38	   compatible *)
(* the system will never create other than V39 type colormaps when running V39*)

CONST
  COLORMAP_TYPE_V1_2	= 000 ;
  COLORMAP_TYPE_V1_4	= 001 ;
  COLORMAP_TYPE_V36	= COLORMAP_TYPE_V1_4 ;	(* use this definition *)
  COLORMAP_TYPE_V39	= 002 ;

  (* Flags variable *)

  COLORMAP_TRANSPARENCY	  = {0} ;
  COLORPLANE_TRANSPARENCY = {1} ;
  BORDER_BLANKING	  = {2} ;
  BORDER_NOTRANSPARENCY	  = {3} ;
  VIDEOCONTROL_BATCH	  = {4} ;
  USER_COPPER_CLIP	  = {5} ;
  BORDERSPRITES		  = {6} ;

  CMF_CMTRANS	= 0 ;
  CMF_CPTRANS	= 1 ;
  CMF_BRDRBLNK	= 2 ;
  CMF_BRDNTRAN	= 3 ;
  CMF_BRDRSPRT	= 6 ;

  SPRITERESN_ECS= 0 ;

  (* ^140ns, except in 35ns viewport, where it is 70ns. *)

  SPRITERESN_140NS	= 1 ;
  SPRITERESN_70NS	= 2 ;
  SPRITERESN_35NS	= 3 ;
  SPRITERESN_DEFAULT	=-1 ;

  (* AuxFlags : *)

  CMAB_FULLPALETTE		= 0 ;
  CMAF_FULLPALETTE		= {CMAB_FULLPALETTE};
  CMAB_NO_INTERMED_UPDATE 	= 1 ;
  CMAF_NO_INTERMED_UPDATE 	= {CMAB_NO_INTERMED_UPDATE};
  CMAB_NO_COLOR_LOAD 		= 2 ;
  CMAF_NO_COLOR_LOAD		= {CMAB_NO_COLOR_LOAD} ;
  CMAB_DUALPF_DISABLE		= 3 ;
  CMAF_DUALPF_DISABLE		= {CMAB_DUALPF_DISABLE} ;


TYPE
  PaletteExtra = RECORD	(* structure may be extended so watch out! *)
    pe_Semaphore	: SignalSemaphore ;(* shared semaphore for arbitration*)
    pe_FirstFree	: CARDINAL ; (* private *)
    pe_NFree		: CARDINAL ; (* number of free colors *)
    pe_FirstShared	: CARDINAL ; (* private *)
    pe_NShared		: CARDINAL ; (* private *)
    pe_RefCnt		: ADDRESS  ; (* private *)
    pe_AllocList	: ADDRESS  ; (* private *)
    pe_ViewPort		: ViewPortPtr ;	(* back pointer to viewport*)
    pe_SharableColors	: CARDINAL ;	(* the number of sharable colors.*)
  END ;

(* flags values for ObtainPen *)
CONST
  PENB_EXCLUSIVE	= 0 ;
  PENB_NO_SETCOLOR	= 1 ;

  PENF_EXCLUSIVE	= {PENB_EXCLUSIVE} ;
  PENF_NO_SETCOLOR	= {PENB_NO_SETCOLOR} ;

  (* obsolete names for PENF_xxx flags: *)

  PEN_EXCLUSIVE		= PENF_EXCLUSIVE ;
  PEN_NO_SETCOLOR	= PENF_NO_SETCOLOR ;

  (* precision values for ObtainBestPen : *)

  PRECISION_EXACT	= -1 ;
  PRECISION_IMAGE	= 0  ;
  PRECISION_ICON	= 16 ;
  PRECISION_GUI		= 32 ;


  (* tags for ObtainBestPen: *)

  OBP_Precision = 084000000H ;
  OBP_FailIfBad = 084000001H ;

  (* From V39, MakeVPort() will return an error if there is not enough memory,*)
  (* or the requested mode cannot be opened with the requested depth with the *)
  (* given bitmap (for higher bandwidth alignments).			      *)

  MVP_OK	= 0 ;	(* you want to see this one			      *)
  MVP_NO_MEM	= 1 ;	(* insufficient memory for intermediate workspace     *)
  MVP_NO_VPE	= 2 ;	(* ViewPort does not have a ViewPortExtra, and	      *)
			(* insufficient memory to allocate a temporary one.   *)

  MVP_NO_DSPINS	= 3 ;	(* insufficient memory for intermidiate copper   *)
			(* instructions.				 *)

  MVP_NO_DISPLAY = 4 ;	(* BitMap data is misaligned for this viewport's *)
			(* mode and depth - see AllocBitMap().		 *)

  MVP_OFF_BOTTOM = 5 ;	(* PRIVATE - you will never see this. *)

  (* From V39, MrgCop() will return an error if there is not enough memory,
   * or for some reason MrgCop() did not need to make any copper lists.
   *)

  MCOP_OK	= 0 ;	(* you want to see this one			*)
  MCOP_NO_MEM	= 1 ;	(* insufficient memory to allocate the system	*)
			(* copper lists.				*)

  MCOP_NOP	= 2 ;	(* MrgCop() did not merge any copper lists	*)
			(* (eg, no ViewPorts in the list, or all marked *)
			(* as hidden).					*)


TYPE
  DBufInfo = RECORD
    dbi_Link1		: ADDRESS  ;
    dbi_Count1		: LONGINT  ;
    dbi_SafeMessage	: Message  ; (* replied to when safe to write to old *)
     				     (* bitmap				     *)
    dbi_UserData1	: ADDRESS  ; (* first user data			     *)

    dbi_Link2		: ADDRESS  ;
    dbi_Count2		: LONGINT  ;
    dbi_DispMessage	: Message  ; (* replied to when new bitmap has been *)
     				     (* displayed at least once		    *)
    dbi_UserData2	: ADDRESS  ; (* second user data		    *)
    dbi_MatchLong	: LONGINT  ;
    dbi_CopPtr1		: ADDRESS  ;
    dbi_CopPtr2		: ADDRESS  ;
    dbi_CopPtr3		: ADDRESS  ;
    dbi_BeamPos1	: CARDINAL ;
    dbi_BeamPos2	: CARDINAL ;
  END ;


(* These flags are passed (in combination) to CoerceMode() to determine the   *)
(* type of coercion required.						      *)

CONST
  PRESERVE_COLORS ={0}; (* Ensure that the mode coerced to can display just as*)
		        (* many colours as the ViewPort being coerced	      *)
  AVOID_FLICKER	  ={1}; (* Ensure that the mode coerced to is not interlaced  *)
  IGNORE_MCOMPAT  ={2}; (* Coercion should ignore monitor compatibility issues*)
  BIDTAG_COERCE	  ={0}; (* Private					      *)


(* These bit descriptors are used by the GEL collide routines.		*)
(*  These bits are set in the hitMask and meMask variables of		*)
(*  a GEL to describe whether or not these types of collisions		*)
(*  can affect the GEL.  BNDRY_HIT is described further below;		*)
(*  this bit is permanently assigned as the boundary-hit flag.		*)
(*  The other bit GEL_HIT is meant only as a default to cover		*)
(*  any GEL hitting any other; the user may redefine this bit.		*)

CONST
  BORDERHIT = 0 ;

(* These bit descriptors are used by the GEL boundry hit routines.	*)
(*  When the user's boundry-hit routine is called (via the argument	*)
(*  set by a call to SetCollision) the first argument passed to		*)
(*  the user's routine is the address of the GEL involved in the	*)
(*  boundry-hit, and the second argument has the appropriate bit(s)	*)
(*  set to describe which boundry was surpassed				*)

  TOPHIT    = 1 ;
  BOTTOMHIT = 2 ;
  LEFTHIT   = 4 ;
  RIGHTHIT  = 8 ;

  COPPER_MOVE = 0 ;	 (* pseude opcode for move #XXXX,dir		*)
  COPPER_WAIT = 1 ;	 (* pseudo opcode for wait y,x			*)
  CPRNXTBUF   = 2 ;	 (* continue processing with next buffer	*)
  CPR_NT_LOF  = 08000H ; (* copper instruction only for short frames	*)
  CPR_NT_SHT  = 04000H ; (* copper instruction only for long frames	*)
  CPR_NT_SYS  = 02000H ; (* copper user instruction only		*)

TYPE
  CopIns = RECORD
    OpCode : INTEGER ; (* 0 = move, 1 = wait *)
    CASE : LONGINT OF
    |0: u3 :
      RECORD
        CASE : LONGINT OF
        |0:nxtlist : CopListPtr ;
        |1:u4:
          RECORD
            CASE :LONGINT OF
            |0: u1 : RECORD
         	       VWaitPos: INTEGER;(* vertical beam wait		      *)
         	       DestAddr: INTEGER;(* destination address of copper move*)
		     END ;
	    |1: u2 : RECORD
	 	       HWaitPos: INTEGER;(* horizontal beam wait position     *)
		       DestData: INTEGER;(* destination immediate data to send*)
		     END ;
	    END ;
	  END ;
        END ;
      END ;
      (* shorthand for above *)
    |1: NXTLIST  : CopListPtr (* u3.nxtlist *)
    |2: VWAITPOS , DESTADDR : INTEGER (* u3.u4.u1.field *)
    |3: HWAITPOS , DESTDATA : INTEGER (* u3.u4.u2.field *)
    END ;
  END ;

  (* structure of cprlist that points to list that hardware actually executes *)

  cprlist = RECORD
    Next     : cprlistPtr ;
    start    : ADDRESS    ; (* start of copper list	   *)
    MaxCount : INTEGER    ; (* number of long instructions *)
  END ;

  CopList = RECORD
    Next	: CopListPtr	; (* next block for this copper list	    *)
    _CopList	: CopListPtr	; (* system use				    *)
    _ViewPort	: ViewPortPtr	; (* system use				    *)
    CopIns	: CopInsPtr	; (* start of this block		    *)
    CopPtr	: CopInsPtr	; (* intermediate ptr			    *)
    CopLStart 	: ADDRESS	; (* mrgcop fills this in for Long Frame    *)
    CopSStart	: ADDRESS	; (* mrgcop fills this in for Short Frame   *)
    Count	: INTEGER	; (* intermediate counter		    *)
    MaxCount	: INTEGER	; (* max # of copins for this block	    *)
    DyOffset	: INTEGER	; (* offset this copper list vertical waits *)
    SLRepeat	: CARDINAL	;
    Flags	: BITSET 	;
  END ;

CONST
  (* These CopList->Flags are private *)
  EXACT_LINE = {0} ;
  HALF_LINE  = {1} ;


TYPE
  UCopList = RECORD
    Next	 : UCopListPtr ;
    FirstCopList : CopListPtr  ; (* head node of this copper list *)
    CopList	 : CopListPtr  ; (* node in use			  *)
  END ;

(* Private graphics data structure. This structure has changed in the past,   *)
(* and will continue to change in the future. Do Not Touch!		      *)


TYPE
  copinit = RECORD
    vsync_hblank : ARRAY [0..1 ] OF CARDINAL ;
    diagstrt	 : ARRAY [0..11] OF CARDINAL ;(*copper list for first bitplane*)
    fm0		 : ARRAY [0..1 ] OF CARDINAL ;
    diwstart	 : ARRAY [0..9 ] OF CARDINAL ;
    bplcon2	 : ARRAY [0..1 ] OF CARDINAL ;
    sprfix	 : ARRAY [0..15] OF CARDINAL ;
    sprstrtup	 : ARRAY [0..31] OF CARDINAL ;
    wait14	 : ARRAY [0..1 ] OF CARDINAL ;
    norm_hblank	 : ARRAY [0..1 ] OF CARDINAL ;
    jump	 : ARRAY [0..1 ] OF CARDINAL ;
    wait_forever : ARRAY [0..5 ] OF CARDINAL ;
    sprstop	 : ARRAY [0..7 ] OF CARDINAL ;
  END ;

CONST

  (* bplcon0 defines *)

  MODE_640    = {15}	;
  PLNCNTMSK   = {0..2}	;    (* how many bit planes?			*)
			     (* 0 = none, 1->6 = 1->6, 7 = reserved	*)
  PLNCNTSHFT  = 12	;    (* bits to shift for bplcon0		*)
  PF2PRI      = {6}	;    (* bplcon2 bit				*)
  COLORON     = {9}	;    (* disable color burst			*)
  DBLPF	      = {10}	;
  HOLDNMODIFY = {11}	;
  INTERLACE   = {2}	;    (* interlace mode for 400			*)

  (* bplcon1 defines *)

  PFA_FINE_SCROLL       = {0..3} ;
  PFB_FINE_SCROLL_SHIFT = 0004H  ;
  PF_FINE_SCROLL_MASK   = {0..3} ;

  (* display window start and stop defines *)

  DIW_HORIZ_POS		= {0..6}	;  (* horizontal start/stop	*)
  DIW_VRTCL_POS		= {0..8}	;  (* vertical start/stop	*)
  DIW_VRTCL_POS_SHIFT	= 7 ;

  (* Data fetch start/stop horizontal position *)

  DFTCH_MASK = {0..7} ;

  (* vposr bits *)

  VPOSRLOF = {15} ;

(*------ Font Styles ------------------------------------------------*)

CONST
  FS_NORMAL	 = { }	;	(* normal text (no style bits set)	*)
  FSB_UNDERLINED =  0	;	(* underlined (under baseline)		*)
  FSF_UNDERLINED = {0}	;
  FSB_BOLD	 =  1	;	(* bold face text (ORed w/ shifted)	*)
  FSF_BOLD	 = {1}	;
  FSB_ITALIC	 =  2	; 	(* italic (slanted 1:2 right)		*)
  FSF_ITALIC	 = {2}	;
  FSB_EXTENDED	 =  3 	;	(* extended face (wider than normal)	*)
  FSF_EXTENDED	 = {3}	;

  FSB_COLORFONT	 =  6	;	(* this uses ColorTextFont structure	*)
  FSF_COLORFONT	 = {6}	;
  FSB_TAGGED	 =  7	;	(* the TextAttr is really an TTextAttr, *)
  FSF_TAGGED	 = {7}	;

(*------ Font Flags -------------------------------------------------*)

  FPB_ROMFONT	=  0	;	(* font is in rom			 *)
  FPF_ROMFONT	= {0}	;
  FPB_DISKFONT	=  1	;	(* font is from diskfont.library	 *)
  FPF_DISKFONT	= {1}	;
  FPB_REVPATH	=  2	;	(* designed path is reversed (e.g. left) *)
  FPF_REVPATH	= {2}	;
  FPB_TALLDOT	=  3	;	(* designed for hires non-interlaced	 *)
  FPF_TALLDOT	= {3}	;
  FPB_WIDEDOT	=  4	;	(* designed for lores interlaced	 *)
  FPF_WIDEDOT	= {4}	;
  FPB_PROPORTIONAL =  5 ;	(* character sizes can vary from nominal *)
  FPF_PROPORTIONAL = {5};
  FPB_DESIGNED	   =  6 ;	(* size explicitly designed, not constructed  *)
				(* note: if you do not set this bit in your   *)
			  	(* textattr, then a font may be constructed   *)
				(* for you by scaling an existing rom or disk *)
				(* font (under V36 and above).		      *)
  FPF_DESIGNED  = {6} ;
    (* bit 7 is always clear for fonts on the graphics font list *)
  FPB_REMOVED	=  7  ;		(* the font has been removed		      *)
  FPF_REMOVED	= {7} ;

(*------- TextAttr node, matches text attributes in RastPort ----------*)

TYPE
  TextAttr = RECORD
    ta_Name  : STRING   ; (* name of the font		*)
    ta_YSize : CARDINAL ; (* height of the font		*)
    ta_Style : SHORTSET ; (* intrinsic font style	*)
    ta_Flags : SHORTSET ; (* font preferences and flags	*)
  END ;

  TTextAttr = RECORD
    tta_Name  : STRING ;	(* name of the font		*)
    tta_YSize : CARDINAL ;	(* height of the font		*)
    tta_Style : SHORTSET ;	(* intrinsic font style		*)
    tta_Flags : SHORTSET ;	(* font preferences and flags	*)
    tta_Tags  : TagItemPtr ;	(* extended attributes		*)
  END ;


(*----- Text Tags --------------------------------------------------*)

CONST
  TA_DeviceDPI = 1+TAG_USER ;	(* Tag value is Point union:		*)
				(* Hi word XDPI, Lo word YDPI		*)
  MAXFONTMATCHWEIGHT = 32767 ;	(* perfect match from WeighTAMatch	*)


(*----- TextFonts node ---------------------------------------------*)

TYPE
  TextFont  = RECORD
    CASE :LONGINT OF
    |0: n : Node ;
    tf_Extension: MsgPortPtr ;
    |1:
    tf_Message	: Message ;	(* reply message for font removal	     *)
    END ;
				(* font name in LN	  \    used in this  *)
    tf_YSize	: CARDINAL ;	(* font height		  |    order to best *)
    tf_Style	: SHORTSET ;	(* font style		  |    match a font  *)
    tf_Flags	: SHORTSET ;	(* preferences and flags  /    request.	     *)
    tf_XSize	: CARDINAL ;	(* nominal font width			     *)
    tf_Baseline	: CARDINAL ;	(* distance from the top of char to baseline *)
    tf_BoldSmear: CARDINAL ;	(* smear to affect a bold enhancement	     *)

    tf_Accessors: CARDINAL ;	(* access count				     *)

    tf_LoChar	: SHORTCARD ;	(* the first character described here	     *)
    tf_HiChar	: SHORTCARD ;	(* the last character described here	     *)
    tf_CharData : ADDRESS ;	(* the bit character data		     *)

    tf_Modulo	: CARDINAL ;	(* the row modulo for the strike font data   *)
    tf_CharLoc	: ADDRESS  ;	(* ptr to location data for the strike font  *)
				(*   2 words: bit offset then size	     *)
    tf_CharSpace: ADDRESS ;	(* ptr to words of proportional spacing data *)
    tf_CharKern : ADDRESS ;	(* ptr to words of kerning data		     *)
  END ;


(*-----	tfe_Flags0 (partial definition) ----------------------------*)

CONST
  TE0B_NOREMFONT =  0  ; (* disallow RemFont for this font *)
  TE0F_NOREMFONT = {0} ;

TYPE
  TextFontExtension = RECORD		(* this structure is read-only	    *)
    tfe_MatchWord	: CARDINAL ;	(* a magic cookie for the extension *)
    tfe_Flags0		: SHORTSET ;	(* (system private flags)	    *)
    tfe_Flags1		: SHORTSET ;	(* (system private flags)	    *)
    tfe_BackPtr		: TextFontPtr ;	(* validation of compilation	    *)
    tfe_OrigReplyPort	: MsgPortPtr ;	(* original value in tf_Extension   *)
    tfe_Tags		: TagItemPtr ;	(* Text Tags for the font	    *)
    tfe_OFontPatchS	: ADDRESS ;	(* (system private use)		    *)
    tfe_OFontPatchK	: ADDRESS ;	(* (system private use)		    *)
    (* this space is reserved for future expansion *)
  END ;

(*-----	ColorTextFont node -----------------------------------------*)
(*-----	ctf_Flags --------------------------------------------------*)

CONST
  CT_COLORMASK = {0..3}	; (* mask to get to following color styles     *)
  CT_COLORFONT = {0}	; (* color map contains designer's colors      *)
  CT_GREYFONT  = {1}	; (* color map describes even-stepped	       *)
			  (* brightnesses from low to high	       *)
  CT_ANTIALIAS = {2}	; (* zero background thru fully saturated char *)

  CTB_MAPCOLOR =  0  ;	  (* map ctf_FgColor to the rp_FgPen if it's   *)
  CTF_MAPCOLOR = {0} ;	  (* is a valid color within ctf_Low..ctf_High *)

(*----- ColorFontColors --------------------------------------------*)

TYPE
  ColorFontColors = RECORD
    cfc_Reserved	: CARDINAL ; (* *must* be zero			      *)
    cfc_Count		: CARDINAL ; (* number of entries in cfc_ColorTable   *)
    cfc_ColorTable	: ADDRESS  ; (* 4 bit/component color map packed xRGB *)
  END ;

(*-----	ColorTextFont ----------------------------------------------*)

  ColorTextFont = RECORD
    ctf_TF		: TextFont  ;
    ctf_Flags		: BITSET    ; (* extended flags			 *)
    ctf_Depth		: SHORTCARD ; (* number of bit planes		 *)
    ctf_FgColor		: SHORTCARD ; (* color that is remapped to FgPen *)
    ctf_Low		: SHORTCARD ; (* lowest color represented here	 *)
    ctf_High		: SHORTCARD ; (* highest color represented here  *)
    ctf_PlanePick	: SHORTCARD ; (* PlanePick ala Images		 *)
    ctf_PlaneOnOff	: SHORTCARD ; (* PlaneOnOff ala Images		 *)
    ctf_ColorFontColors : ColorFontColorsPtr ; (* colors for font	 *)
    ctf_CharData	: ARRAY [0..7] OF ADDRESS ;
    				(*pointers to bit planes ala tf_CharData *)
  END ;

(*------- TextExtent node -------------------------------------------*)

  TextExtentRec = RECORD
    te_Width  : CARDINAL  ; (* same as TextLength *)
    te_Height : CARDINAL  ; (* same as tf_YSize	  *)
    te_Extent : Rectangle ; (* relative to CP	  *)
  END ;


  (* the "public" handle to a DisplayInfoRecord *)

TYPE
  DisplayInfoHandle = ADDRESS ;

  (* datachunk type identifiers *)

CONST
  DTAG_DISP = 080000000H ;
  DTAG_DIMS = 080001000H ;
  DTAG_MNTR = 080002000H ;
  DTAG_NAME = 080003000H ;
  DTAG_VEC  = 080004000H ; (* internal use only *)

TYPE
  QueryHeader = RECORD
    StructID  : LONGINT ; (* datachunk type identifier			*)
    DisplayID : LONGINT ; (* copy of display record key			*)
    SkipID    : LONGINT ; (* TAG_SKIP -- see tagitems.h			*)
    Length    : LONGINT ; (* length of local data in double-longwords	*)
  END ;

  DisplayInfo = RECORD
    Header		: QueryHeader ;
    NotAvailable	: CARDINAL ;	(* if NULL available, else see defines*)
    PropertyFlags	: LONGSET ;	(* Properties of this mode see defines*)
    Resolution		: Point ;	(* ticks-per-pixel X/Y		      *)
    PixelSpeed		: CARDINAL ;	(* aproximation in nanoseconds	      *)
    NumStdSprites	: CARDINAL ;	(* number of standard amiga sprites   *)
    PaletteRange	: CARDINAL ;	(* OBSOLETE - use Red/Green/Blue bits *)
    					(* instead 			      *)

    SpriteResolution	: Point ; (* std sprite ticks-per-pixel X/Y    *)
    pad			: ARRAY [0..3] OF SHORTCARD ;
    					(* used internally		      *)
    RedBits		: SHORTCARD ;	(* number of Red bits this display    *)
    					(* supports (V39)		      *)
    GreenBits		: SHORTCARD ;	(* number of Green bits this display  *)
    					(* supports (V39)		      *)
    BlueBits		: SHORTCARD ;	(* number of Blue bits this display   *)
    					(* supports (V39)		      *)
    pad2		: SHORTCARD ;
    pad3		: ARRAY [0..3] OF SHORTCARD ;
    					(* find some use for this. *)
    reserved		: ARRAY [0..1] OF LONGINT ; (* terminator *)
  END ;

CONST
(* availability *)

  DI_AVAIL_NOCHIPS		= 00001 ;
  DI_AVAIL_NOMONITOR		= 00002 ;
  DI_AVAIL_NOTWITHGENLOCK	= 00004 ;

(* mode properties *)

  DIPF_IS_LACE		= {0} ;
  DIPF_IS_DUALPF	= {1} ;
  DIPF_IS_PF2PRI	= {2} ;
  DIPF_IS_HAM		= {3} ;

  DIPF_IS_ECS		= {4} ;	(* note: ECS modes (SHIRES, VGA, and *)
				(* PRODUCTIVITY) do not support      *)
				(* attached sprites.		     *)

  DIPF_IS_AA		= {16} ;(* AA modes - may only be available  *)
				(* if machine has correct memory     *)
				(* type to support required	     *)
				(* bandwidth - check availability.   *)
				(* (V39)			     *)

  DIPF_IS_PAL		= {5} ;
  DIPF_IS_SPRITES	= {6} ;
  DIPF_IS_GENLOCK	= {7} ;

  DIPF_IS_WB		= {8} ;
  DIPF_IS_DRAGGABLE	= {9} ;
  DIPF_IS_PANELLED	= {10} ;
  DIPF_IS_BEAMSYNC	= {11} ;

  DIPF_IS_EXTRAHALFBRITE = {12} ;

(* The following DIPF_IS_... flags are new for V39 *)

  DIPF_IS_SPRITES_ATT		= {13} ; (* supports attached sprites	      *)
  DIPF_IS_SPRITES_CHNG_RES	= {14} ; (* supports variable sprite reslution*)
  DIPF_IS_SPRITES_BORDER	= {15} ; (* sprite can be displayed in the    *)
  					 (* border			      *)
  DIPF_IS_SCANDBL		= {17} ; (* scan doubled		      *)
  DIPF_IS_SPRITES_CHNG_BASE	= {18} ; (* can change the sprite base colour *)
  DIPF_IS_SPRITES_CHNG_PRI	= {19} ;
					(* can change the sprite priority     *)
					(* with respect to the playfield(s).  *)

  DIPF_IS_DBUFFER  = {20} ;	(* can support double buffering		*)
  DIPF_IS_PROGBEAM = {21} ;	(* is a programmed beam-sync mode	*)
  DIPF_IS_FOREIGN  = {31} ;	(* this mode is not native to the Amiga *)


TYPE
  DimensionInfo = RECORD
    Header		: QueryHeader ;
    MaxDepth		: CARDINAL  ; (* log2( max number of colors ) *)
    MinRasterWidth	: CARDINAL  ; (* minimum width in pixels      *)
    MinRasterHeight	: CARDINAL  ; (* minimum height in pixels     *)
    MaxRasterWidth	: CARDINAL  ; (* maximum width in pixels      *)
    MaxRasterHeight	: CARDINAL  ; (* maximum height in pixels     *)
    Nominal		: Rectangle ; (* "standard" dimensions	      *)
    MaxOScan		: Rectangle ; (* fixed, hardware dependent    *)
    VideoOScan		: Rectangle ; (* fixed, hardware dependent    *)
    TxtOScan		: Rectangle ; (* editable via preferences     *)
    StdOScan		: Rectangle ; (* editable via preferences     *)
    pad			: ARRAY [0..13] OF SHORTCARD ;
    reserved		: ARRAY [0..1] OF LONGINT ; (* terminator *)
  END ;

  MonitorInfo = RECORD
    Header		: QueryHeader ;
    Mspc		: MonitorSpecPtr ;(* pointer to monitor specification *)
    ViewPosition	: Point ;	  (* editable via preferences	      *)
    ViewResolution	: Point ;         (* standard monitor ticks-per-pixel *)
    ViewPositionRange	: Rectangle ;     (* fixed, hardware dependent	      *)
    TotalRows		: CARDINAL ;	  (* display height in scanlines      *)
    TotalColorClocks	: CARDINAL ;      (* scanline width in 280 ns units   *)
    MinRow		: CARDINAL ;	  (* absolute minimum active scanline *)
    Compatibility	: INTEGER ;	  (* how this coexists with others    *)
    pad			: ARRAY [0..31] OF SHORTCARD ;
    MouseTicks		: Point ;
    DefaultViewPosition	: Point ;   (* original, never changes  *)
    PreferredModeID	: LONGINT ; (* for Preferences		*)
    reserved		: ARRAY [0..1] OF LONGINT ;
    				    (* terminator		*)
  END ;

CONST
(* monitor compatibility *)

  MCOMPAT_MIXED	= 0 ;	(* can share display with other MCOMPAT_MIXED	*)
  MCOMPAT_SELF	= 1 ;	(* can share only within same monitor		*)
  MCOMPAT_NOBODY = -1 ;	(* only one viewport at a time			*)

  DISPLAYNAMELEN = 32 ;

TYPE
  NameInfo = RECORD
    Header   : QueryHeader ;
    Name     : ARRAY [0..DISPLAYNAMELEN-1] OF CHAR ;
    reserved : ARRAY [0..1] OF LONGINT ; (* terminator *)
  END ;

TYPE
  MonitorSpec = RECORD
    ms_Node			: ExtendedNode ;
    ms_Flags			: BITSET  ;
    ratioh 			: LONGINT ;
    ratiov 			: LONGINT ;
    total_rows 			: CARDINAL ;
    total_colorclocks 		: CARDINAL ;
    DeniseMaxDisplayColumn 	: CARDINAL ;
    BeamCon0 			: CARDINAL ;
    min_row 			: CARDINAL ;
    ms_Special 			: SpecialMonitorPtr ;
    ms_OpenCount 		: CARDINAL ;
    ms_transform 		: LongProc ;
    ms_translate 		: LongProc ;
    ms_scale   			: LongProc ;
    ms_xoffset 			: CARDINAL ;
    ms_yoffset 			: CARDINAL ;
    ms_LegalView 		: Rectangle ;
    ms_maxoscan 		: LongProc ;	(* maximum legal overscan *)
    ms_videoscan 		: LongProc ;	(* video display overscan *)
    DeniseMinDisplayColumn	: CARDINAL ;
    DisplayCompatible		: LONGINT ;
    DisplayInfoDataBase		: List ;
    DisplayInfoDataBaseSemaphore: SignalSemaphore ;
    ms_MrgCop			: LongProc ;
    ms_LoadView			: LongProc ;
    ms_KillView			: LongProc ;
  END ;

CONST
  TO_MONITOR		= 0 ;
  FROM_MONITOR		= 1 ;
  STANDARD_XOFFSET	= 9 ;
  STANDARD_YOFFSET	= 0 ;

  MSB_REQUEST_NTSC	= 0 ;
  MSB_REQUEST_PAL	= 1 ;
  MSB_REQUEST_SPECIAL	= 2 ;
  MSB_REQUEST_A2024	= 3 ;
  MSB_DOUBLE_SPRITES	= 4 ;

  MSF_REQUEST_NTSC	= {MSB_REQUEST_NTSC} ;
  MSF_REQUEST_PAL	= {MSB_REQUEST_PAL} ;
  MSF_REQUEST_SPECIAL	= {MSB_REQUEST_SPECIAL} ;
  MSF_REQUEST_A2024	= {MSB_REQUEST_A2024} ;
  MSF_DOUBLE_SPRITES	= {MSB_DOUBLE_SPRITES} ;


(* obsolete, v37 compatible definitions follow *)

  REQUEST_NTSC		= {MSB_REQUEST_NTSC} ;
  REQUEST_PAL		= {MSB_REQUEST_PAL} ;
  REQUEST_SPECIAL	= {MSB_REQUEST_SPECIAL} ;
  REQUEST_A2024		= {MSB_REQUEST_A2024} ;

  DEFAULT_MONITOR_NAME	= "default.monitor" ;
  NTSC_MONITOR_NAME	= "ntsc.monitor" ;
  PAL_MONITOR_NAME	= "pal.monitor" ;
  STANDARD_MONITOR_MASK	= ( REQUEST_NTSC + REQUEST_PAL ) ;

  STANDARD_NTSC_ROWS	= 262 ;
  STANDARD_PAL_ROWS	= 312 ;
  STANDARD_COLORCLOCKS	= 226 ;
  STANDARD_DENISE_MAX	= 455 ;
  STANDARD_DENISE_MIN	= 93 ;
  STANDARD_NTSC_BEAMCON	= 00000 ;
  STANDARD_PAL_BEAMCON	= DISPLAYPAL ;

  SPECIAL_BEAMCON=VARVBLANK+LOLDIS+VARVSYNC+VARHSYNC+VARBEAM+CSBLANK+VSYNCTRUE ;

  MIN_NTSC_ROW		= 21 ;
  MIN_PAL_ROW		= 29 ;
  STANDARD_VIEW_X	= 081H ;
  STANDARD_VIEW_Y	= 02CH ;
  STANDARD_HBSTRT	= 006H ;
  STANDARD_HSSTRT	= 00BH ;
  STANDARD_HSSTOP	= 01CH ;
  STANDARD_HBSTOP	= 02CH ;
  STANDARD_VBSTRT	= 00122H ;
  STANDARD_VSSTRT	= 002A6H ;
  STANDARD_VSSTOP	= 003AAH ;
  STANDARD_VBSTOP	= 01066H ;

  VGA_COLORCLOCKS	= (STANDARD_COLORCLOCKS/2) ;
  VGA_TOTAL_ROWS	= (STANDARD_NTSC_ROWS*2) ;
  VGA_DENISE_MIN	= 59 ;
  MIN_VGA_ROW		= 29 ;
  VGA_HBSTRT		= 008H ;
  VGA_HSSTRT		= 00EH ;
  VGA_HSSTOP		= 01CH ;
  VGA_HBSTOP		= 01EH ;
  VGA_VBSTRT		= 00000H ;
  VGA_VSSTRT		= 00153H ;
  VGA_VSSTOP		= 00235H ;
  VGA_VBSTOP		= 00CCDH ;

  VGA_MONITOR_NAME	= "vga.monitor" ;

  BROADCAST_HBSTRT	= 001H ;
  BROADCAST_HSSTRT	= 006H ;
  BROADCAST_HSSTOP	= 017H ;
  BROADCAST_HBSTOP	= 027H ;
  BROADCAST_VBSTRT	= 00000H ;
  BROADCAST_VSSTRT	= 002A6H ;
  BROADCAST_VSSTOP	= 0054CH ;
  BROADCAST_VBSTOP	= 01C40H ;
  BROADCAST_BEAMCON	= LOLDIS + CSBLANK ;
  RATIO_FIXEDPART	= 4 ;
  RATIO_UNITY		= INTEGER({RATIO_FIXEDPART}) ;

TYPE
  AnalogSignalInterval = RECORD
    asi_Start : CARDINAL ;
    asi_Stop  : CARDINAL ;
  END ;

  SpecialMonitor = RECORD
    spm_Node	: ExtendedNode ;
    spm_Flags 	: BITSET  ;
    do_monitor	: LongProc ;
    reserved1	: LongProc ;
    reserved2	: LongProc ;
    reserved3	: LongProc ;
    hblank	: AnalogSignalInterval ;
    vblank	: AnalogSignalInterval ;
    hsync	: AnalogSignalInterval ;
    vsync	: AnalogSignalInterval ;
  END ;

CONST
  VTAG_END_CM			= 000000000H ;
  VTAG_CHROMAKEY_CLR		= 080000000H ;
  VTAG_CHROMAKEY_SET		= 080000001H ;
  VTAG_BITPLANEKEY_CLR		= 080000002H ;
  VTAG_BITPLANEKEY_SET		= 080000003H ;
  VTAG_BORDERBLANK_CLR		= 080000004H ;
  VTAG_BORDERBLANK_SET		= 080000005H ;
  VTAG_BORDERNOTRANS_CLR	= 080000006H ;
  VTAG_BORDERNOTRANS_SET	= 080000007H ;
  VTAG_CHROMA_PEN_CLR		= 080000008H ;
  VTAG_CHROMA_PEN_SET		= 080000009H ;
  VTAG_CHROMA_PLANE_SET		= 08000000AH ;
  VTAG_ATTACH_CM_SET		= 08000000BH ;
  VTAG_NEXTBUF_CM		= 08000000CH ;
  VTAG_BATCH_CM_CLR		= 08000000DH ;
  VTAG_BATCH_CM_SET		= 08000000EH ;
  VTAG_NORMAL_DISP_GET		= 08000000FH ;
  VTAG_NORMAL_DISP_SET		= 080000010H ;
  VTAG_COERCE_DISP_GET		= 080000011H ;
  VTAG_COERCE_DISP_SET		= 080000012H ;
  VTAG_VIEWPORTEXTRA_GET	= 080000013H ;
  VTAG_VIEWPORTEXTRA_SET	= 080000014H ;
  VTAG_CHROMAKEY_GET		= 080000015H ;
  VTAG_BITPLANEKEY_GET		= 080000016H ;
  VTAG_BORDERBLANK_GET		= 080000017H ;
  VTAG_BORDERNOTRANS_GET	= 080000018H ;
  VTAG_CHROMA_PEN_GET		= 080000019H ;
  VTAG_CHROMA_PLANE_GET		= 08000001AH ;
  VTAG_ATTACH_CM_GET		= 08000001BH ;
  VTAG_BATCH_CM_GET		= 08000001CH ;
  VTAG_BATCH_ITEMS_GET		= 08000001DH ;
  VTAG_BATCH_ITEMS_SET		= 08000001EH ;
  VTAG_BATCH_ITEMS_ADD		= 08000001FH ;
  VTAG_VPMODEID_GET		= 080000020H ;
  VTAG_VPMODEID_SET		= 080000021H ;
  VTAG_VPMODEID_CLR		= 080000022H ;
  VTAG_USERCLIP_GET		= 080000023H ;
  VTAG_USERCLIP_SET		= 080000024H ;
  VTAG_USERCLIP_CLR		= 080000025H ;

(* The following tags are V39 specific. They will be ignored *)
(* (returing error -3) by earlier versions		     *)

  VTAG_PF1_BASE_GET		= 080000026H ;
  VTAG_PF2_BASE_GET		= 080000027H ;
  VTAG_SPEVEN_BASE_GET		= 080000028H ;
  VTAG_SPODD_BASE_GET		= 080000029H ;
  VTAG_PF1_BASE_SET		= 08000002AH ;
  VTAG_PF2_BASE_SET		= 08000002BH ;
  VTAG_SPEVEN_BASE_SET		= 08000002CH ;
  VTAG_SPODD_BASE_SET		= 08000002DH ;
  VTAG_BORDERSPRITE_GET		= 08000002EH ;
  VTAG_BORDERSPRITE_SET		= 08000002FH ;
  VTAG_BORDERSPRITE_CLR		= 080000030H ;
  VTAG_SPRITERESN_SET		= 080000031H ;
  VTAG_SPRITERESN_GET		= 080000032H ;
  VTAG_PF1_TO_SPRITEPRI_SET	= 080000033H ;
  VTAG_PF1_TO_SPRITEPRI_GET	= 080000034H ;
  VTAG_PF2_TO_SPRITEPRI_SET	= 080000035H ;
  VTAG_PF2_TO_SPRITEPRI_GET	= 080000036H ;
  VTAG_IMMEDIATE		= 080000037H ;
  VTAG_FULLPALETTE_SET		= 080000038H ;
  VTAG_FULLPALETTE_GET		= 080000039H ;
  VTAG_FULLPALETTE_CLR		= 08000003AH ;
  VTAG_DEFSPRITERESN_SET	= 08000003BH ;
  VTAG_DEFSPRITERESN_GET	= 08000003CH ;

  (* all the following tags follow the new, rational standard for videocontrol*)
  (* tags:								      *)
  (* VC_xxx,state	set the state of attribute 'xxx' to value 'state'     *)
  (* VC_xxx_QUERY,&var	get the state of attribute 'xxx' and store it into the*)
  (*			longword pointed to by &var.			      *)
  (*									      *)
  (* The following are new for V40:					      *)

  VC_IntermediateCLUpdate	= 080000080H ;
  (* default=true. When set graphics will update the intermediate copper   *)
  (* lists on color changes, etc. When false,it won't, and will be faster. *)

  VC_IntermediateCLUpdate_Query	= 080000081H ;

  VC_NoColorPaletteLoad		= 080000082H ;

  (* default = false. When set, graphics will only load color 0		*)
  (* for this ViewPort, and so the ViewPort's colors will come		*)
  (* from the previous ViewPort's.					*)
  (*									*)
  (* NB - Using this tag and VTAG_FULLPALETTE_SET together is undefined.*)

  VC_NoColorPaletteLoad_Query	= 080000083H ;

  VC_DUALPF_Disable		= 080000084H ;

  (* default = false. When this flag is set, the dual-pf bit		 *)
  (* in Dual-Playfield screens will be turned off. Even bitplanes	 *)
  (* will still come from the first BitMap and odd bitplanes		 *)
  (* from the second BitMap, and both R[xy]Offsets will be		 *)
  (* considered. This can be used (with appropriate palette		 *)
  (* selection) for cross-fades between differently scrolling		 *)
  (* images.								 *)
  (* When this flag is turned on, colors will be loaded for		 *)
  (* the viewport as if it were a single viewport of depth depth1+depth2 *)

  VC_DUALPF_Disable_Query	= 080000085H ;



TYPE
  GfxBaseRec = RECORD
    LibNode		: Library ;
    ActiView		: ViewPtr ;
    copinit		: copinitPtr ;	(* ptr to copper start up list	   *)
    cia			: ADDRESS ;	(* for 8520 resource use	   *)
    blitter		: ADDRESS ;	(* for future blitter resource use *)
    LOFlist		: ADDRESS ;
    SHFlist		: ADDRESS ;
    blthd		: bltnodePtr ;
    blttl 		: bltnodePtr ;
    bsblthd		: bltnodePtr ;
    bsblttl 		: bltnodePtr ;
    vbsrv,timsrv,bltsrv	: Interrupt ;
    TextFonts		: List ;
    DefaultFont 	: TextFontPtr ;
    Modes		: BITSET  ;	(* copy of current first bplcon0 *)
    VBlank		: SHORTINT ;
    Debug		: SHORTINT ;
    BeamSync		: INTEGER ;
    system_bplcon0	: BITSET  ;(* it is ored into each bplcon0 for display*)
    SpriteReserved	: SHORTCARD ;
    bytereserved	: SHORTCARD ;
    Flags		: BITSET  ;
    BlitLock		: INTEGER ;
    BlitNest		: INTEGER ;

    BlitWaitQ		: List ;
    BlitOwner		: TaskPtr ;
    TOF_WaitQ		: List ;
    DisplayFlags	: BITSET  ;	(* NTSC PAL GENLOC etc		 *)
					(* flags initialized at power on *)
    SimpleSprite	: POINTER TO ARRAY OF SimpleSpritePtr ;
    MaxDisplayRow	: CARDINAL ;	(* hardware stuff, do not use	 *)
    MaxDisplayColumn	: CARDINAL ;	(* hardware stuff, do not use	 *)
    NormalDisplayRows	: CARDINAL ;
    NormalDisplayColumns: CARDINAL ;

	(* the following are for standard non interlace, 1/2 wb width *)

    NormalDPMX		: CARDINAL ;	(* Dots per meter on display *)
    NormalDPMY		: CARDINAL ;	(* Dots per meter on display *)
    LastChanceMemory	: SignalSemaphorePtr ;
    LCMptr		: ADDRESS ;
    MicrosPerLine	: CARDINAL ;	(* 256 time usec/line *)
    MinDisplayColumn	: CARDINAL ;

    ChipRevBits0	: SHORTSET ;
    MemType		: SHORTSET ;
    crb_reserved	: ARRAY [0..3] OF SHORTCARD ;
    monitor_id		: CARDINAL ;
    hedley		: ARRAY [0..7] OF LONGINT ;
    hedley_sprites	: ARRAY [0..7] OF LONGINT ;
    				(* sprite ptrs for intuition mouse *)
    hedley_sprites1	: ARRAY [0..7] OF LONGINT ;
    				(* sprite ptrs for intuition mouse *)
    edley_count		: INTEGER ;
    hedley_flags	: BITSET  ;
    edley_tmp		: INTEGER ;
    hash_table		: ADDRESS ;
    current_tot_rows	: CARDINAL ;
    current_tot_cclks	: CARDINAL ;
    hedley_hint		: SHORTCARD ;
    hedley_hint2	: SHORTCARD ;
    nreserved		: ARRAY [0..3] OF LONGINT ;
    a2024_sync_raster	: ADDRESS ;
    control_delta_pal	: CARDINAL ;
    control_delta_ntsc	: CARDINAL ;
    current_monitor	: MonitorSpecPtr ;
    MonitorList		: List ;
    default_monitor	: MonitorSpecPtr ;
    MonitorListSemaphore: SignalSemaphorePtr ;
    DisplayInfoDataBase : ADDRESS ;
    TopLine		: CARDINAL ;
    ActiViewCprSemaphore: SignalSemaphorePtr ;
    UtilBase		: ADDRESS ; (* for hook and tag utilities. had to *)
    				    (* change because of name clash	  *)
    ExecBase		: ADDRESS ; (* to link with rom.lib		  *)

    bwshifts		: ADDRESS ;
    StrtFetchMasks	: ADDRESS ;
    StopFetchMasks	: ADDRESS ;
    Overrun		: ADDRESS ;
    ealStops		: ADDRESS ;
    SpriteWidth		: CARDINAL ;  (* current width (in words) of sprites  *)
    SpriteFMode		: BITSET   ;  (* current sprite fmode bits	      *)
    SoftSprites		: SHORTSET ;  (* bit mask of size change knowledgeable*)
    				      (* sprites			      *)
    arraywidth		: SHORTINT ;
    DefaultSpriteWidth	: CARDINAL ;  (* what width intuition wants *)
    SprMoveDisable	: SHORTSET ;
    WantChips		: SHORTSET ;
    BoardMemType	: SHORTSET ;
    Bugs		: SHORTSET ;
    gb_LayersBase	: ADDRESS ;
    ColorMask		: LONGSET ;
    IVector		: ADDRESS ;
    IData		: ADDRESS ;
    SpecialCounter	: LONGINT ;   (* special for double buffering *)
    DBList		: ADDRESS ;
    MonitorFlags	: BITSET  ;
    ScanDoubledSprites  : SHORTCARD ;
    BP3Bits		: SHORTSET ;
    MonitorVBlank	: AnalogSignalInterval ;
    natural_monitor	: MonitorSpecPtr ;

    ProgData		: ADDRESS ;
    ExtSprites		: SHORTCARD ;
    pad3		: SHORTCARD ;
    GfxFlags		: BITSET  ;
    VBCounter		: LONGINT ;
    HashTableSemaphore	: SignalSemaphorePtr ;
    CASE :LONGINT OF
    |0: ChunkyToPlanarPtr : LONGINT ;
    |1: HWEmul : ARRAY [0..8] OF LONGINT ;
    END ;
  END ;

VAR
  GfxBase : GfxBasePtr ;

CONST
  GRAPHICSNAME = "graphics.library" ;

  (* Values for GfxBase->DisplayFlags *)

  NTSC		= {0} ;
  GENLOC	= {1} ;
  PAL		= {2} ;
  TODA_SAFE	= {3} ;
  REALLY_PAL	= {4} ;	(* what is actual crystal frequency		      *)
			(*(as opposed to what bootmenu set the agnus to)?(V39)*)

  LPEN_SWAP_FRAMES = {5} ;

  (* LightPen software could set this bit if the		    *)
  (* "lpen-with-interlace" fix put in for V39			    *)
  (* does not work. This is true of a number of Agnus chips. (V40). *)

  BLITMSG_FAULT	= {2} ;

  (* bits defs for ChipRevBits *)

  GFXB_BIG_BLITS	= 0 ;
  GFXB_HR_AGNUS		= 0 ;

  GFXB_HR_DENISE	= 1 ;
  GFXB_AA_ALICE		= 2 ;
  GFXB_AA_LISA		= 3 ;
  GFXB_AA_MLISA		= 4 ;	(* internal use only. *)

  GFXF_BIG_BLITS	= {0} ;
  GFXF_HR_AGNUS		= {0} ;
  GFXF_HR_DENISE	= {1} ;
  GFXF_AA_ALICE		= {2} ;
  GFXF_AA_LISA		= {3} ;
  GFXF_AA_MLISA		= {4} ;	(* internal use only *)

  (* Pass ONE of these to SetChipRev() *)

  SETCHIPREV_A		= GFXF_HR_AGNUS ;
  SETCHIPREV_ECS	= GFXF_HR_AGNUS + GFXF_HR_DENISE ;
  SETCHIPREV_AA		= GFXF_AA_ALICE + GFXF_AA_LISA + SETCHIPREV_ECS ;
  SETCHIPREV_BEST	= {0..31} ;

  (* memory type *)

  BUS_16		= {} ;
  NML_CAS		= {} ;
  BUS_32		= {0} ;
  DBL_CAS		= {1} ;

  BANDWIDTH_1X		= BUS_16 + NML_CAS ;
  BANDWIDTH_2XNML	= BUS_32 ;
  BANDWIDTH_2XDBL	= DBL_CAS ;
  BANDWIDTH_4X		= BUS_32 + DBL_CAS ;

  (* GfxFlags (private) *)

  NEW_DATABASE		= {0} ;

CONST
  BITSET = BITSET(08000H) ;
  BITCLR = { } ;

(*------------------------- BitMap primitives --------------------------------*)

PROCEDURE BltBitMap( srcBitMap : BitMapPtr ;
		     xSrc      : LONGINT ;
		     ySrc      : LONGINT ;
		     destBitMap: BitMapPtr ;
		     xDest     : LONGINT ;
		     yDest     : LONGINT ;
		     xSize     : LONGINT ;
		     ySize     : LONGINT ;
		     minterm   : LONGINT ;
		     mask      : LONGINT ;
		     tempA     : PLANEPTR ) : LONGINT ;

PROCEDURE BltTemplate( source : PLANEPTR ;
		       xSrc   : LONGINT ;
		       srcMod : LONGINT ;
		       destRP : RastPortPtr ;
		       xDest  : LONGINT ;
		       yDest  : LONGINT ;
		       xSize  : LONGINT ;
		       ySize  : LONGINT ) ;

(*------------------------ Text routines -------------------------------------*)

PROCEDURE ClearEOL   ( rp : RastPortPtr ) ;
PROCEDURE ClearScreen( rp : RastPortPtr ) ;

PROCEDURE TextLength( rp     : RastPortPtr ;
		      string : STRING ;
		      count  : LONGINT ) : INTEGER ;

PROCEDURE Text( rp     : RastPortPtr ;
		string : STRING ;
		count  : LONGINT ) : LONGINT ;

PROCEDURE SetFont( rp : RastPortPtr ; textFont : TextFontPtr ) : LONGINT ;

PROCEDURE OpenFont( textAttr : TextAttrPtr ) : TextFontPtr ;

PROCEDURE CloseFont( textFont : TextFontPtr ) ;
PROCEDURE AskSoftStyle( rp : RastPortPtr ) : SHORTSET ;
PROCEDURE SetSoftStyle( rp     : RastPortPtr ;
		        style  : SHORTSET ;
		        enable : SHORTSET ) : SHORTSET ;

(*------------------------- Gels routines ------------------------------------*)

PROCEDURE AddBob( bob : BobPtr ; rp : RastPortPtr ) ;
PROCEDURE AddVSprite( vSprite : VSpritePtr ; rp : RastPortPtr ) ;
PROCEDURE DoCollision( rp : RastPortPtr ) ;
PROCEDURE DrawGList( rp : RastPortPtr ; vp : ViewPortPtr ) ;

PROCEDURE InitGels( head : VSpritePtr ;
		    tail : VSpritePtr ;
		    gelsInfo : GelsInfoPtr ) ;

PROCEDURE InitMasks( vSprite : VSpritePtr ) ;

PROCEDURE RemIBob( bob : BobPtr ;
		   rp  : RastPortPtr ;
		   vp  : ViewPortPtr ) ;

PROCEDURE RemVSprite( vSprite : VSpritePtr );

PROCEDURE SetCollision( num	 : LONGINT ;
			cp	 : PROC ; (* cast it *)
			gelsInfo : GelsInfoPtr ) ;

PROCEDURE SortGList( rp : RastPortPtr ) ;

PROCEDURE AddAnimOb( anOb  : AnimObPtr ;
		     anKey : ADDRESS ;
		     rp    : RastPortPtr ) ;

PROCEDURE Animate( VAR anKey : AnimOb ; rp : RastPortPtr ) ;

PROCEDURE GetGBuffers( anOb : AnimObPtr ;
		       rp   : RastPortPtr ;
		       flag : LONGINT ) : BOOLEAN ;

PROCEDURE InitGMasks( anOb : AnimObPtr ) ;

(*-------------------- General graphics routines -----------------------------*)

PROCEDURE DrawEllipse( rp      : RastPortPtr ;
		       xCenter : LONGINT ;
		       yCenter : LONGINT ;
		       a       : LONGINT ;
		       b       : LONGINT ) ;

PROCEDURE AreaEllipse( rp      : RastPortPtr  ;
		       xCenter : LONGINT ;
		       yCenter : LONGINT ;
		       a       : LONGINT ;
		       b       : LONGINT ) : LONGINT ;

PROCEDURE LoadRGB4( vp : ViewPortPtr ; colors : ADDRESS ; count : LONGINT ) ;
PROCEDURE InitRastPort( VAR rp : RastPort ) ;
PROCEDURE InitVPort( VAR vp : ViewPort ) ;
PROCEDURE MrgCop( view : ViewPtr ) : LONGINT ;
PROCEDURE MakeVPort( view : ViewPtr ; vp : ViewPortPtr ) : LONGINT ;
PROCEDURE LoadView( view : ViewPtr ) ;
PROCEDURE WaitBlit( ) ;
PROCEDURE SetRast( rp : RastPortPtr ; pen : LONGINT ) ;
PROCEDURE Move( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) ;
PROCEDURE Draw( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) ;
PROCEDURE AreaMove( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) : LONGINT ;
PROCEDURE AreaDraw( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) : LONGINT ;
PROCEDURE AreaEnd( rp : RastPortPtr ) : LONGINT ;
PROCEDURE WaitTOF( ) ;
PROCEDURE QBlit( blit : bltnodePtr ) ;

PROCEDURE InitArea( VAR areaInfo : AreaInfo ;
		    vectorBuffer : ADDRESS ;
		    maxVectors   : LONGINT ) ;

PROCEDURE SetRGB4( vp	 : ViewPortPtr ;
		   index : LONGINT ;
		   red   : LONGINT ;
		   green : LONGINT ;
		   blue  : LONGINT ) ;

PROCEDURE QBSBlit( blit : bltnodePtr ) ;

PROCEDURE BltClear( memBlock  : PLANEPTR ;
		    byteCount : LONGINT  ;
		    flags     : LONGSET ) ;

PROCEDURE RectFill( rp : RastPortPtr ; xMin, yMin, xMax, yMax : LONGINT ) ;

PROCEDURE BltPattern( rp   : RastPortPtr ;
		      mask : PLANEPTR ;
		      xMin : LONGINT ;
		      yMin : LONGINT ;
		      xMax : LONGINT ;
		      yMax : LONGINT ;
		      maskBPR : LONGINT ) ;

PROCEDURE ReadPixel ( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) : LONGINT ;
PROCEDURE WritePixel( rp : RastPortPtr ; x : LONGINT ; y : LONGINT ) : LONGINT ;

PROCEDURE Flood( rp : RastPortPtr ;
		 mode : LONGINT ;
		 x, y : LONGINT ) : BOOLEAN ;

PROCEDURE PolyDraw( rp : RastPortPtr; count : LONGINT ; polyTable : ADDRESS );
PROCEDURE SetAPen( rp : RastPortPtr; pen : LONGINT );
PROCEDURE SetBPen( rp : RastPortPtr; pen : LONGINT );
PROCEDURE SetDrMd( rp : RastPortPtr; drawMode : SHORTSET );
PROCEDURE InitView( view : View );
PROCEDURE CBump( copList : UCopListPtr ) ;
PROCEDURE CMove( copList : UCopListPtr ;
		 destination : ADDRESS ;
		 data : LONGINT ) ;
PROCEDURE CWait( copList : UCopListPtr; v : LONGINT; h : LONGINT );
PROCEDURE VBeamPos( ) : LONGINT ;

PROCEDURE InitBitMap( VAR bitMap : BitMap ; depth , width , height : LONGINT ) ;

PROCEDURE ScrollRaster( rp   : RastPortPtr ;
			dx   : LONGINT ;
			dy   : LONGINT ;
			xMin : LONGINT ;
			yMin : LONGINT ;
			xMax : LONGINT ;
			yMax : LONGINT ) ;

PROCEDURE WaitBOVP( vp : ViewPortPtr ) ;
PROCEDURE GetSprite( sprite : SimpleSpritePtr ; num : LONGINT ) : INTEGER ;
PROCEDURE FreeSprite( num : LONGINT ) ;

PROCEDURE ChangeSprite( vp	: ViewPortPtr ;
			sprite  : SimpleSpritePtr ;
			newData : PLANEPTR ) ;

PROCEDURE MoveSprite( vp     : ViewPortPtr ;
		      sprite : SimpleSpritePtr ;
		      x, y   : LONGINT ) ;

PROCEDURE LockLayerRom( layer : LayerPtr ) ;
PROCEDURE UnlockLayerRom( layer : LayerPtr ) ;
PROCEDURE SyncSBitMap( layer : LayerPtr ) ;
PROCEDURE CopySBitMap( layer : LayerPtr ) ;
PROCEDURE OwnBlitter( ) ;
PROCEDURE DisownBlitter( ) ;

PROCEDURE InitTmpRas( VAR tmpRas : TmpRas ;
		      buffer : PLANEPTR  ;
		      size   : LONGINT ) : TmpRasPtr ;

PROCEDURE AskFont( rp : RastPortPtr ; textAttr : TextAttrPtr ) ;
PROCEDURE AddFont( textFont : TextFontPtr ) ;
PROCEDURE RemFont( textFont : TextFontPtr ) ;
PROCEDURE AllocRaster( width : LONGINT ; height : LONGINT ) : PLANEPTR ;
PROCEDURE FreeRaster( p : PLANEPTR ; width : LONGINT ; height : LONGINT ) ;

PROCEDURE AndRectRegion( region : RegionPtr ; rectangle : RectanglePtr ) ;

PROCEDURE OrRectRegion( region : RegionPtr ;
			rectangle : RectanglePtr ) : BOOLEAN ;

PROCEDURE NewRegion( ) : RegionPtr ;

PROCEDURE ClearRectRegion( region    : RegionPtr ;
			   rectangle : RectanglePtr ) : BOOLEAN ;

PROCEDURE ClearRegion( region   : RegionPtr ) ;
PROCEDURE DisposeRegion( region : RegionPtr ) ;
PROCEDURE FreeVPortCopLists( vp : ViewPortPtr ) ;
PROCEDURE FreeCopList( copList  : CopListPtr ) ;

PROCEDURE ClipBlit( srcRP   : RastPortPtr ;
		    xSrc    : LONGINT ;
		    ySrc    : LONGINT ;
		    destRP  : RastPortPtr ;
		    xDest   : LONGINT ;
		    yDest   : LONGINT ;
		    xSize   : LONGINT ;
		    ySize   : LONGINT ;
		    minterm : LONGINT ) ;

PROCEDURE XorRectRegion( region : RegionPtr ; rect : RectanglePtr ) : BOOLEAN ;
PROCEDURE FreeCprList( cprList : cprlistPtr ) ;
PROCEDURE GetColorMap( entries : LONGINT ) : ColorMapPtr ;
PROCEDURE FreeColorMap( colorMap : ColorMapPtr ) ;
PROCEDURE GetRGB4( colorMap : ColorMapPtr ; entry : LONGINT ) : LONGINT ;
PROCEDURE ScrollVPort( vp : ViewPortPtr ) ;
PROCEDURE UCopperListInit( uCopList : UCopListPtr ; n : LONGINT ): UCopListPtr ;

PROCEDURE FreeGBuffers( anOb  : AnimObPtr ;
			rp    : RastPortPtr ;
			db    : BOOLEAN ) ;

PROCEDURE BltBitMapRastPort( srcBitMap	: BitMapPtr ;
			     xSrc	: LONGINT ;
			     ySrc	: LONGINT ;
			     destRP	: RastPortPtr ;
			     xDest	: LONGINT ;
			     yDest	: LONGINT ;
			     xSize	: LONGINT ;
			     ySize	: LONGINT ;
			     minterm	: LONGINT ) ;

PROCEDURE OrRegionRegion ( srcRegion, destRegion : RegionPtr ) : BOOLEAN ;
PROCEDURE XorRegionRegion( srcRegion, destRegion : RegionPtr ) : BOOLEAN ;
PROCEDURE AndRegionRegion( srcRegion, destRegion : RegionPtr ) : BOOLEAN ;

PROCEDURE SetRGB4CM( colorMap : ColorMapPtr ;
		     index, red, green, blue : LONGINT ) ;

PROCEDURE BltMaskBitMapRastPort( srcBitMap : BitMapPtr ;
				 xSrc	   : LONGINT ;
				 ySrc	   : LONGINT ;
				 destRP	   : RastPortPtr ;
				 xDest	   : LONGINT ;
				 yDest	   : LONGINT ;
				 xSize	   : LONGINT ;
				 ySize	   : LONGINT ;
				 minterm   : LONGINT ;
				 bltMask   : PLANEPTR ) ;

PROCEDURE AttemptLockLayerRom( layer : LayerPtr ) : BOOLEAN ;

(*--------------- functions in V36 or higher (Release 2.0) -------------------*)

PROCEDURE GfxNew( gfxNodeType : LONGINT ) : ADDRESS ;
PROCEDURE GfxFree( gfxNodePtr : ADDRESS ) ;
PROCEDURE GfxAssociate( associateNode : ADDRESS ; gfxNodePtr : ADDRESS ) ;
PROCEDURE BitMapScale( bitScaleArgs : BitScaleArgsPtr ) ;
PROCEDURE ScalerDiv( factor , numerator , denominator : LONGINT ) : CARDINAL ;

PROCEDURE TextExtent( rp	 : RastPortPtr ;
		      string	 : STRING ;
		      count	 : LONGINT ;
		      textExtent : TextExtentPtr ) : INTEGER ;

PROCEDURE TextFit( rp : RastPortPtr ;
		   string : STRING ;
		   strLen : LONGINT;
		   textExtent : TextExtentPtr ;
		   constrainingExtent : TextExtentPtr ;
		   strDirection : LONGINT ;
		   constrainingBitWidth  : LONGINT ;
		   constrainingBitHeight : LONGINT ) : LONGINT ;

PROCEDURE GfxLookUp( associateNode : ADDRESS ) : ADDRESS ;

PROCEDURE VideoControl( colorMap : ColorMapPtr ;
			tagarray : TagItemPtr ) : BOOLEAN ;

PROCEDURE VideoControlTags( colorMap : ColorMapPtr ;
			    tag1Type : LONGINT ; .. ) : BOOLEAN ;

PROCEDURE OpenMonitor( monitorName : STRING ;
		       displayID   : LONGINT ) : MonitorSpecPtr ;

PROCEDURE CloseMonitor( monitorSpec : MonitorSpecPtr ) : BOOLEAN ;
PROCEDURE FindDisplayInfo( displayID : LONGINT ) : DisplayInfoHandle ;
PROCEDURE NextDisplayInfo( displayID : LONGINT ) : LONGINT ;

PROCEDURE GetDisplayInfoData( handle	: DisplayInfoHandle ;
			      buf	: ADDRESS ;
			      size	: LONGINT ;
			      tagID	: LONGINT ;
			      displayID : LONGINT ) : LONGINT ;

PROCEDURE FontExtent( font : TextFontPtr ; fontExtent : TextExtentPtr ) ;

PROCEDURE ReadPixelLine8( rp	 : RastPortPtr ;
			  xstart : LONGINT ;
			  ystart : LONGINT ;
			  width  : LONGINT ;
			  array  : ADDRESS ;
			  tempRP : RastPortPtr ) : LONGINT ;

PROCEDURE WritePixelLine8( rp : RastPortPtr ;
			   xstart, ystart, width : LONGINT ;
			   array  : ADDRESS ;
			   tempRP : RastPortPtr ) : LONGINT ;

PROCEDURE ReadPixelArray8( rp : RastPortPtr ;
			   xstart, ystart, xstop, ystop : LONGINT;
			   array  : ADDRESS ;
			   temprp : RastPortPtr ) : LONGINT ;

PROCEDURE WritePixelArray8( rp	   : RastPortPtr ;
			    xstart, ystart, xstop, ystop  : LONGINT ;
			    array  : ADDRESS ;
			    temprp : RastPortPtr ) : LONGINT ;

PROCEDURE GetVPModeID( vp : ViewPortPtr ) : LONGINT ;
PROCEDURE ModeNotAvailable( modeID : LONGINT ) : LONGINT ;

PROCEDURE WeighTAMatch( reqTextAttr	: TextAttrPtr ;
			targetTextAttr	: TextAttrPtr ;
			targetTags	: TagItemPtr ) : INTEGER ;

PROCEDURE WeighTAMatchTags( reqTextAttr	   : TextAttrPtr ;
			    targetTextAttr : TextAttrPtr ;
			    tag1Type	   : LONGINT ; .. ) : INTEGER ;

PROCEDURE EraseRect( rp	: RastPortPtr ; xMin, yMin, xMax, yMax : LONGINT ) ;

PROCEDURE ExtendFont( font     : TextFontPtr ;
		      fontTags : TagItemPtr ) : LONGINT ;

PROCEDURE ExtendFontTags( font     : TextFontPtr ;
			  tag1Type : LONGINT ; .. ) : LONGINT ;

PROCEDURE StripFont( font : TextFontPtr ) ;

(*----------------- functions in V39 or higher (Release 3) -------------------*)

PROCEDURE CalcIVG( v : ViewPtr ; vp : ViewPortPtr ) : CARDINAL ;
PROCEDURE AttachPalExtra( cm : ColorMapPtr ; vp : ViewPortPtr ) : LONGINT ;

PROCEDURE ObtainBestPenA( cm	: ColorMapPtr ;
			  r,g,b : LONGINT ;
			  tags  : TagItemPtr ) : LONGINT ;

PROCEDURE ObtainBestPen( cm : ColorMapPtr ;
			 r,g,b,tag1Type : LONGINT ; .. ) : LONGINT ;

PROCEDURE SetRGB32( vp : ViewPortPtr ; n,r,g,b : LONGINT ) ;

PROCEDURE GetAPen( rp : RastPortPtr ) : LONGINT ;
PROCEDURE GetBPen( rp : RastPortPtr ) : LONGINT ;
PROCEDURE GetDrMd( rp : RastPortPtr ) : LONGINT ;
PROCEDURE GetOutlinePen( rp : RastPortPtr ) : LONGINT ;
PROCEDURE LoadRGB32( vp : ViewPortPtr ; table : ADDRESS ) ;
PROCEDURE SetChipRev( want : LONGSET ) : LONGSET ;

PROCEDURE SetABPenDrMd( rp : RastPortPtr ;
			apen : LONGINT ;
			bpen : LONGINT ;
			drawmode : SHORTSET ) ;

PROCEDURE GetRGB32( cm : ColorMapPtr ;
		    firstcolor : LONGINT ;
		    ncolors : LONGINT ;
		    table : ADDRESS ) ;

PROCEDURE AllocBitMap( sizex : LONGINT ;
		       sizey : LONGINT ;
		       depth : LONGINT ;
		       flags : SHORTSET ;
		       friend_bitmap : BitMapPtr ) : BitMapPtr ;

PROCEDURE FreeBitMap( bm : BitMapPtr ) ;
PROCEDURE GetExtSpriteA( ss : ExtSpritePtr ; tags : TagItemPtr ) : LONGINT ;
PROCEDURE GetExtSprite( ss : ExtSpritePtr ; tag1Type : LONGINT; .. ): LONGINT ;

PROCEDURE CoerceMode( vp	: ViewPortPtr;
		      monitorid : LONGINT;
		      flags	: LONGSET ) : LONGINT ;

PROCEDURE ChangeVPBitMap( vp : ViewPortPtr ;
			  bm : BitMapPtr ;
			  db : DBufInfoPtr ) ;

PROCEDURE ReleasePen( cm : ColorMapPtr ; n : LONGINT ) ;

PROCEDURE ObtainPen( cm : ColorMapPtr ;
		      n : LONGINT ;
		      r : LONGINT ;
		      g : LONGINT ;
		      b : LONGINT ;
		      f : LONGSET ) : LONGINT ;

PROCEDURE GetBitMapAttr( bm : BitMapPtr ; attrnum : LONGINT ) : LONGINT ;
PROCEDURE AllocDBufInfo( vp : ViewPortPtr ) : DBufInfoPtr ;
PROCEDURE FreeDBufInfo( dbi : DBufInfoPtr ) ;
PROCEDURE SetOutlinePen( rp : RastPortPtr ; pen : LONGINT ) : LONGINT ;
PROCEDURE SetWriteMask( rp : RastPortPtr ; msk : SHORTSET ) : LONGINT ;
PROCEDURE SetMaxPen( rp : RastPortPtr ; maxpen : LONGINT ) ;

PROCEDURE SetRGB32CM( cm : ColorMapPtr ;
		       n : LONGINT ;
		       r : LONGINT ;
		       g : LONGINT ;
		       b : LONGINT ) ;

PROCEDURE ScrollRasterBF( rp   : RastPortPtr ;
			  dx   : LONGINT ;
			  dy   : LONGINT ;
			  xMin : LONGINT ;
			  yMin : LONGINT ;
			  xMax : LONGINT ;
			  yMax : LONGINT ) ;

PROCEDURE FindColor(	cm : ColorMapPtr ;
			r  : LONGINT ;
			g  : LONGINT ;
			b  : LONGINT ;
			maxcolor : LONGINT ) : LONGINT ;

PROCEDURE AllocSpriteDataA( bm : BitMapPtr; tags : TagItemPtr ) : ExtSpritePtr ;
PROCEDURE AllocSpriteData( bm	    : BitMapPtr ;
			   tag1Type : LONGINT ; .. ) : ExtSpritePtr ;

PROCEDURE ChangeExtSpriteA( vp	      : ViewPortPtr  ;
			    oldsprite : ExtSpritePtr ;
			    newsprite : ExtSpritePtr ;
			    tags      : TagItemPtr ) : LONGINT ;

PROCEDURE ChangeExtSprite( vp	     : ViewPortPtr ;
			   oldsprite : ExtSpritePtr ;
			   newsprite : ExtSpritePtr ;
			   tag1Type  : LONGINT ; .. ) : LONGINT ;

PROCEDURE FreeSpriteData( sp : ExtSpritePtr ) ;
PROCEDURE SetRPAttrsA( rp : RastPortPtr ; tags : TagItemPtr ) ;
PROCEDURE SetRPAttrs( rp : RastPortPtr ; tag1Type : LONGINT; .. ) ;
PROCEDURE GetRPAttrsA( rp : RastPortPtr ; tags : TagItemPtr ) ;
PROCEDURE GetRPAttrs( rp : RastPortPtr ; tag1Type : LONGINT ; .. ) ;
PROCEDURE BestModeIDA( tags : TagItemPtr ) : LONGINT ;
PROCEDURE BestModeID ( tag1Type : LONGINT ; .. ) : LONGINT ;

(*---------------- functions in V40 or higher (Release 3.1) ------------------*)

PROCEDURE WriteChunkyPixels( rp	    : RastPortPtr ;
			     xstart : LONGINT ;
			     ystart : LONGINT ;
			     xstop  : LONGINT ;
			     ystop  : LONGINT ;
			     array  : ADDRESS ;
			     bytesperrow : LONGINT ) ;

END Graphics.
