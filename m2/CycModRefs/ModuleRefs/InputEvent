@database InputEvent
@node Main "InputEvent"

Constants

   @{" asciiDel " link Modul 167}                    @{" asciiFirst " link Modul 165}                  @{" asciiLast " link Modul 166}
   @{" c0First " link Modul 163}                     @{" c0Last " link Modul 164}                      @{" c1First " link Modul 168}
   @{" c1Last " link Modul 169}                      @{" classMax " link Modul 49}                    @{" commCodeFirst " link Modul 159}
   @{" commCodeLast " link Modul 160}                @{" compatible " link Modul 55}                  @{" keyCodeFirst " link Modul 157}
   @{" keyCodeLast " link Modul 158}                 @{" lButton " link Modul 174}                     @{" latin1First " link Modul 170}
   @{" latin1Last " link Modul 171}                  @{" mButton " link Modul 176}                     @{" newActive " link Modul 180}
   @{" newSize " link Modul 181}                     @{" newTablet " link Modul 58}                   @{" noButton " link Modul 177}
   @{" pixel " link Modul 56}                       @{" rButton " link Modul 175}                     @{" refresh " link Modul 182}
   @{" reqClear " link Modul 189}                    @{" reqSet " link Modul 187}                      @{" tablet " link Modul 57}
   @{" upPrefix " link Modul 153}                 

Type-Declarations

   @{" Class " link Modul 15}                       @{" InputEvent " link Modul 203}                  @{" InputEventPtr " link Modul 13}
   @{" NewTablet " link Modul 106}                   @{" NewTabletPtr " link Modul 12}                @{" PointerPixel " link Modul 76}
   @{" PointerPixelPtr " link Modul 9}             @{" PointerTablet " link Modul 93}               @{" PointerTabletPtr " link Modul 11}
   @{" QualifierSet " link Modul 199}                @{" Qualifiers " link Modul 192}                  @{" XYRec " link Modul 60}


@endnode
@node Modul "am2:ModuleRefs/InputEvent.def"
(*$ Implementation- *)
DEFINITION MODULE InputEvent;

(* (C) Copyright 1994 Marcel Timmermans. All rights reserved. *)

FROM SYSTEM IMPORT ADDRESS;
FROM Timer IMPORT TimeVal;
IMPORT UtilityD;

TYPE
  PointerPixelPtr   = POINTER TO PointerPixel;
  PointerTabletPtr  = POINTER TO PointerTablet;
  NewTabletPtr      = POINTER TO NewTablet;
  InputEventPtr     = POINTER TO InputEvent;

 Class=(
  null,             (* A NOP input event                              *)
  rawkey,           (* A raw keycode from the keyboard device         *)
  rawmouse,         (* The raw mouse report from the game port        *)
                    (* device                                         *)
  event,            (* A private console event                        *)
  class5,           (* dummy                                          *)
  pointerpos,       (* A Pointer Position report                      *)
  timer,            (* A timer event                                  *)
  gadgetdown,       (* select button pressed down over a Gadget       *)
                    (* (address in ie_EventAddress)                   *)
  gadgetup,         (* select button released over the same Gadget    *)
                    (* (address in ie_EventAddress)                   *)
  requester,        (* some Requester activity has taken place.  See  *)
                    (* Codes REQCLEAR and REQSET                      *)
  menulist,         (* this is a Menu Number transmission (Menu       *)
                    (* number is in ie_Code)                          *)
  closewindow,      (* User has selected the active Window's Close    *)
                    (* Gadget                                         *)
  sizewindow,       (* this Window has a new size                     *)
  refreshwindow,    (* the Window pointed to by ie_EventAddress needs *)
                    (* to be refreshed                                *)
  newprefs,         (* new preferences are available                  *)
  diskremoved,      (* the disk has been removed                      *)
  diskinserted,     (* the disk has been inserted                     *)
  activewindow,     (* the window is about to be been made active     *)
  inactivewindow,   (* the window is about to be made inactive        *)
  newpointerpos,    (* extended-function pointer position report      *)
                    (* (V36)                                          *)
  menuhelp,         (* Help key report during Menu session (V36)      *)
  changewindow      (* the Window has been modified with move, size,  *)
                    (* zoom, or change (V36)                          *)
  );

CONST
 classMax=ORD(MAX(Class)); (* the last class                          *) 


(*  --- InputEvent.subClass --- *)
(*  newpointerpos *)
  compatible = 00H;  (* like pointerpos *)
  pixel      = 01H;  (* InputEvent.eventAddress points to PointerPixel *)
  tablet     = 02H;  (* InputEvent.eventAddress points to PointerTablet *)
  newTablet  = 03H;  (* InputEvent.eventAddress points to NewTablet *)

TYPE
  XYRec=RECORD
    X:INTEGER;
    Y:INTEGER;
  END;

(* pointed to by InputEvent.eventAddress for newpointerposs,
 * and InputEvent.subClass=pixel.
 *
 * You specify a screen and pixel coordinates in that screen
 * at which you'd like the mouse to be positioned.
 * Intuition will try to oblige, but there will be restrictions
 * to positioning the pointer over offscreen pixels.
 *
 * IEQUALIFIER_RELATIVEMOUSE is supported for IESUBCLASS_PIXEL.
 *)
  PointerPixel=RECORD
    screen:ADDRESS;            (* pointer to an open screen *)
    position:XYRec;            (* pixel coordinates in iepp_Screen *)
  END;

(* pointed to by InputEvent.eventAddress for newpointerpos,
 * and InputEvent.subClass=tablet.
 *
 * You specify a range of values and a value within the range
 * independently for each of X and Y (the minimum value of
 * the ranges is always normalized to 0).
 *
 * Intuition will position the mouse proportionally within its
 * natural mouse position rectangle limits.
 *
 * IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_TABLET.
 *)
  PointerTablet=RECORD
    range:XYRec;      (* 0 is min, these are max         *)
    value:XYRec;      (* between 0 and range             *)
    pressure:INTEGER; (* -128 to 127 (unused, set to 0)  *)
  END;

(* The ie_EventAddress of an IECLASS_NEWPOINTERPOS event of subclass
 * IESUBCLASS_NEWTABLET points at an IENewTablet structure.
 *
 *
 * IEQUALIFIER_RELATIVEMOUSE is not supported for IESUBCLASS_NEWTABLET.
 *)

  NewTablet=RECORD

    (* Pointer to a hook you wish to be called back through, in
     * order to handle scaling.  You will be provided with the
     * width and height you are expected to scale your tablet
     * to, perhaps based on some user preferences.
     * If NULL, the tablet's specified range will be mapped directly
     * to that width and height for you, and you will not be
     * called back.
     *)
    callBack:UtilityD.HookPtr;

    (* Post-scaling coordinates and fractional coordinates.
     * DO NOT FILL THESE IN AT THE TIME THE EVENT IS WRITTEN!
     * Your driver will be called back and provided information
     * about the width and height of the area to scale the
     * tablet into.  It should scale the tablet coordinates
     * (perhaps based on some preferences controlling aspect
     * ratio, etc.) and place the scaled result into these
     * fields.        The ient_ScaledX and ient_ScaledY fields are
     * in screen-pixel resolution, but the origin ( [0,0]-point )
     * is not defined.        The ient_ScaledXFraction and
     * ient_ScaledYFraction fields represent sub-pixel position
     * information, and should be scaled to fill a UWORD fraction.
     *)
    scaledX         : CARDINAL;
    scaledY         : CARDINAL;
    scaledXFraction : CARDINAL;
    scaledYFraction : CARDINAL;

    (* Current tablet coordinates along each axis: *)
    tabletX         : LONGCARD;
    tabletY         : LONGCARD;

    (* Tablet range along each axis.  For example, if ient_TabletX
     * can take values 0-999, ient_RangeX should be 1000.
     *)
    rangeX          : LONGCARD;
    rangeY          : LONGCARD;

    (* Pointer to tag-list of additional tablet attributes.
     * See <intuition/intuition.h> for the tag values.
     *)
    tagList         : UtilityD.TagPtr;
  END;


CONST
(*  --- InputEvent.ie_Code --- *)
(*  IECLASS_RAWKEY *)
  upPrefix       = 080H;
  keyCodeFirst   = 000H;
  keyCodeLast    = 077H;
  commCodeFirst  = 078H;
  commCodeLast   = 07FH;

(*  IECLASS_ANSI *)
  c0First        = 000H;
  c0Last         = 01FH;
  asciiFirst     = 020H;
  asciiLast      = 07EH;
  asciiDel       = 07FH;
  c1First        = 080H;
  c1Last         = 09FH;
  latin1First    = 0A0H;
  latin1Last     = 0FFH;

(*  IECLASS_RAWMOUSE *)
  lButton        = 068H;  (* also uses IECODE_UP_PREFIX *)
  rButton        = 069H;
  mButton        = 06AH;
  noButton       = 0FFH;

(*  IECLASS_EVENT (V36) *)
  newActive      = 001H;  (* new active input window *)
  newSize        = 002H;  (* resize of window *)
  refresh        = 003H;  (* refresh of window *)

(*  IECLASS_REQUESTER *)
(*  broadcast when the first Requester (not subsequent ones) opens up in *)
(*  the Window *)
  reqSet         = 001H;
(*  broadcast when the last Requester clears out of the Window *)
  reqClear       = 000H;


TYPE
(*  --- InputEvent.ie_Qualifier --- *)
 Qualifiers=(
  lShift,rShift,capsLock,control,lAlt,rAlt,lCommand,rCommand,
  numericPad,repeat,interrupt,multiBroadcast,midButton,
  rightButton,leftButton,relativeMouse
 );
 QualifierSet=SET OF Qualifiers;

(*----- InputEvent -------------------------------------------------*)

 InputEvent=RECORD
  nextEvent:InputEventPtr;    (* the chronologically next event *)
  class:Class;                (* the input event class *)
  subClass:Class;             (* optional subclass of the class *)  
  code:CARDINAL;              (* the input event code *)  
  qualifier:QualifierSet;     (* qualifiers in effect for the event*)  
  CASE :INTEGER OF
  |0: x,y:INTEGER;            (* the pointer position for the event*)
  |1: eventAddress:ADDRESS    (* the event address *)
  |2: prev1DownCode:SHORTCARD;(* previous down keys for dead *)
      prev1DownQual:SHORTCARD;(* key translation: the ie_Code *)
      prev2DownCode:SHORTCARD;(* & low byte of ie_Qualifier for *)
      prev2DownQual:SHORTCARD;(* last & second last down keys *)   
  END;
  timeStamp:TimeVal
 END;

END InputEvent.

@endnode
