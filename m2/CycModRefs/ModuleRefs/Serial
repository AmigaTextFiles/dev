@database Serial
@node Main "Serial"

Constants

   @{" abort " link Modul 20}                       @{" active " link Modul 19}                      @{" break " link Modul 16}
   @{" bufrRead " link Modul 22}                    @{" defaultCtlChar " link Modul 33}              @{" query " link Modul 14}
   @{" queued " link Modul 21}                      @{" select " link Modul 90}                      @{" serialName " link Modul 11}
   @{" setParams " link Modul 17}                

Type-Declarations

   @{" Error " link Modul 125}                       @{" ExtSerFlagSet " link Modul 100}               @{" ExtSerFlags " link Modul 93}
   @{" IOExtSer " link Modul 108}                    @{" IOExtSerPtr " link Modul 122}                 @{" IOTArray " link Modul 24}
   @{" SerFlagSet " link Modul 52}                  @{" SerFlags " link Modul 41}                    @{" Status " link Modul 74}
   @{" StatusSet " link Modul 89}                

@endnode
@node Modul "am2:ModuleRefs/Serial.def"
(*$ Implementation- *)
DEFINITION MODULE Serial;
(* 2-July-96/Stefan Tiemann for Cyclone *)
(* Converted from C-include: serial.h 33.6 (6.11.90), Includes Release 40.15 *)

FROM SYSTEM IMPORT
 ADDRESS;

FROM ExecD IMPORT
 nonstd,IOFlagSet,IOStdReq;

CONST
 serialName="serial.device";

CONST
 query= nonstd;	         (* $09 *)
 break= nonstd+1;        (* $0A *)
 setParams= nonstd+2;    (* $0B *)

 active= IOFlagSet{4};   (* rqst-qued-or-current bit *)
 abort= IOFlagSet{5};    (* rqst-aborted bit *)
 queued= IOFlagSet{6};   (* rqst-queued bit *)
 bufrRead= IOFlagSet{7}; (* from read buffer bit *)

TYPE
		   (* array of termination char's *)
		   (* to use,see serial.doc setparams *)

 IOTArray= RECORD
  termArray0: LONGCARD;
  termArray1: LONGCARD;
 END;

CONST
 defaultCtlChar=11130000H;	(* default chars for xON,xOFF *)
(* You may change these via SETPARAMS.	At this time, parity is not
   calculated for xON/xOFF characters.	You must supply them with the
   desired parity. *)



TYPE
 SerFlags=(
  partyOn,  (* parity-enabled bit *)
  partyOdd, (* parity feature enabled bit *)
  sevenWire,(* RS232 7-wire protocol *)
  queuedBrk,(* queue this Break ioRqst *)
  radBoogie,(* high-speed mode active bit *)
  shared,   (* non-exclusive access bit *)
  eofMode,  (* EOF mode enabled bit *)
  xDisabled (* xOn-xOff feature disabled bit *)
 );
 SerFlagSet=SET OF SerFlags;

   (* status of serial port, as follows:
*		   BIT	ACTIVE	FUNCTION
*		    0	 ---	reserved
*		    1	 ---	reserved
*		    2	 high	Connected to parallel "select" on the A1000.
*				Connected to both the parallel "select" and
*				serial "ring indicator" pins on the A500
*				& A2000.  Take care when making cables.
*		    3	 low	Data Set Ready
*		    4	 low	Clear To Send
*		    5	 low	Carrier Detect
*		    6	 low	Ready To Send
*		    7	 low	Data Terminal Ready
*		    8	 high	read overrun
*		    9	 high	break sent
*		   10	 high	break received
*		   11	 high	transmit x-OFFed
*		   12	 high	receive x-OFFed
*		13-15		reserved
*)
 Status=(
  sta0,
  sta1,
  ringIndicator,  (* = select *)
  dataSetReady,
  clearToSend,
  carrierDetect,
  readyToSend,
  dataTerminalReady,
  overrun,        (* status word RBF overrun bit *)
  wroteBreak,     (* break was latest output bit *)
  readBreak,      (* break was latest input bit *)
  xOffWrite,      (* transmit currently xOFF'ed bit *)
  xOffRead        (* receive currently xOFF'ed bit *)
 );
 StatusSet= SET OF Status;
CONST
 select= ringIndicator;

TYPE
 ExtSerFlags=(
  mark,    (* if mark-space, use mark *)
  mSpOn,   (* Use mark-space parity, instead of odd-even. **)
  esf2,esf3,esf4,esf5,esf6,esf7,esf8,esf9,esf10,esf11,esf12,esf13,
  esf14,esf15,esf16
 );
 ExtSerFlagSet= SET OF ExtSerFlags;



(******************************************************************)
(* CAUTION !!  IF YOU ACCESS the serial.device, you MUST (!!!!) use an
   IOExtSer-sized structure or you may overlay innocent memory !! *)
(******************************************************************)
 IOExtSer= RECORD
  ioSer: IOStdReq;
  ctlChar: LONGCARD;       (* control char's (order = xON,xOFF,INQ,ACK) *)
  rBufLen: LONGCARD;       (* length in bytes of serial port's read buffer *)
  extFlags: ExtSerFlagSet; (* additional serial flags (see bitdefs below) *)
  baud: LONGCARD;          (* baud rate requested (true baud) *)
  brkTime: LONGCARD;       (* duration of break signal in MICROseconds *)
  termArray: IOTArray;     (* termination character array *)
  readLen: SHORTCARD;      (* bits per read character (# of bits) *)
  writeLen: SHORTCARD;     (* bits per write character (# of bits) *)
  stopBits: SHORTCARD;     (* stopbits for read (# of bits) *)
  serFlags: SerFlagSet;    (* see SerFlags bit definitions below  *)
  status: StatusSet;
 END;
 IOExtSerPtr= POINTER TO IOExtSer;


 Error=(
  e0,
  devBusy,
  baudMismatch,   (* baud rate not supported by hardware *)
  invBaud,        (* unused *)
  bufErr,         (* Failed to allocate new read buffer *)
  invParam,
  lineErr,
  notOpen,        (* unused *)
  portReset,      (* unused *)
  parityErr,
  initErr,        (* unused *)
  timerErr,       (*(See the serial/OpenDevice autodoc)*)
  bufOverflow,
  nodsr,
  nocts,          (* unused *)
  detectedBreak
 );

END Serial.





@endnode
