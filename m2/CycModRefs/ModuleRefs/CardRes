@database CardRes
@node Main "CardRes"

Procedures

   @{" BeginCardAccess " link Modul 154}             @{" CardAccessSpeed " link Modul 166}             @{" CardChangeCount " link Modul 187}
   @{" CardForceChange " link Modul 185}             @{" CardInterface " link Modul 189}               @{" CardMiscControl " link Modul 163}
   @{" CardProgramVoltage " link Modul 169}          @{" CardResetCard " link Modul 172}               @{" CardResetRemove " link Modul 160}
   @{" CopyTuple " link Modul 175}                   @{" DeviceTuple " link Modul 179}                 @{" EndCardAccess " link Modul 156}
   @{" GetCardMap " link Modul 152}                  @{" IfAmigaXIP " link Modul 182}                  @{" OwnCard " link Modul 147}
   @{" ReadCardStatus " link Modul 158}              @{" ReleaseCard " link Modul 149}              

Constants

   @{" autoRun " link Modul 131}                     @{" cardName " link Modul 18}                    @{" cisTplAmigaXIP " link Modul 119}
   @{" delayOwnerShip " link Modul 59}              @{" disablebWp " link Modul 86}                  @{" enablebDigaudio " link Modul 85}
   @{" ifAvailable " link Modul 58}                 @{" intbBSY " link Modul 104}                     @{" intbBVD1 " link Modul 100}
   @{" intbBVD2 " link Modul 102}                    @{" intbDA " link Modul 103}                      @{" intbIRQ " link Modul 105}
   @{" intbSC " link Modul 101}                      @{" intbSetClr " link Modul 99}                  @{" interfaceAmiga0 " link Modul 109}
   @{" postStatus " link Modul 60}                  @{" removeHandle " link Modul 64}                @{" resetRemove " link Modul 54}
   @{" statusbBSY " link Modul 74}                  @{" statusbBVD1 " link Modul 69}                 @{" statusbBVD2 " link Modul 71}
   @{" statusbCCDET " link Modul 68}                @{" statusbDA " link Modul 72}                   @{" statusbIRQ " link Modul 75}
   @{" statusbSC " link Modul 70}                   @{" statusbWR " link Modul 73}                   @{" voltage0v " link Modul 79}
   @{" voltage12v " link Modul 81}                  @{" voltage5v " link Modul 80}                

Type-Declarations

   @{" CardHandle " link Modul 25}                  @{" CardHandlePtr " link Modul 21}               @{" CardMemoryMap " link Modul 42}
   @{" CardMemoryMapPtr " link Modul 41}            @{" DeviceTData " link Modul 34}                 @{" DeviceTDataPtr " link Modul 33}
   @{" TPAmigaXIP " link Modul 123}                  @{" TPAmigaXIPPtr " link Modul 121}            

@endnode
@node Modul "am2:ModuleRefs/CardRes.def"
(*
**	Cyclone Modula-2 Interface module:
**      CardRes Includes Release 40.15
**
**      Interface module by Marcel Timmermans
**      (C) Copyright 1995-1996 Marcel Timmermans
**          All Rights Reserved
*)

(*$ Implementation- *)
DEFINITION MODULE CardRes;

FROM SYSTEM IMPORT ADDRESS,SHORTSET,LONGSET;

FROM ExecD IMPORT ResidentPtr,InterruptPtr,Node;

IMPORT Reg;

CONST
  cardName = "card.resource";

TYPE
(* Structures used by the card.resource                         *)

  CardHandlePtr = POINTER TO CardHandle;
  CardHandle = RECORD
    cardNode     : Node;
    cardRemoved  : InterruptPtr;
    cardInserted : InterruptPtr;
    cardStatus   : InterruptPtr;
    cardFlags    : SHORTSET;
  END;

  DeviceTDataPtr = POINTER TO DeviceTData;
  DeviceTData = RECORD
    dtSize   : LONGCARD;  (* Size in bytes        *)
    dtSpeed  : LONGCARD;  (* Speed in nanoseconds *)
    dtType   : SHORTCARD; (* Type of card         *)
    dtFlags  : SHORTSET;  (* Other flags          *)
  END;

  CardMemoryMapPtr = POINTER TO CardMemoryMap;
  CardMemoryMap = RECORD
    commonMemory     : ADDRESS;
    attributeMemeory : ADDRESS;
    ioMemory         : ADDRESS;

(* Extended for V39 - These are the size of the memory spaces above *)

    commonMemSize    : LONGCARD;
    attributeMemSize : LONGCARD;
    ioMemSize        : LONGCARD;
  END;

CONST
(* CardHandle.cah_CardFlags for OwnCard() function              *)

  resetRemove    = 0;
  ifAvailable    = 1;
  delayOwnerShip = 2;
  postStatus     = 3;

(* ReleaseCreditCard() function flags                           *)

  removeHandle   = 0;

(* ReadStatus() return flags                                    *)

  statusbCCDET   = 6;
  statusbBVD1    = 5;
  statusbSC      = 5;
  statusbBVD2    = 4;
  statusbDA      = 4;
  statusbWR      = 3;
  statusbBSY     = 2;
  statusbIRQ     = 2;

(* CardProgramVoltage() defines *)

  voltage0v      = 0;       (* Set to default; may be the same as 5V *)
  voltage5v      = 1;
  voltage12v     = 2;

(* CardMiscControl() defines *)

  enablebDigaudio = 1;
  disablebWp      = 3;

(*
 * New CardMiscControl() bits for V39 card.resource.  Use these bits to set,
 * or clear status change interrupts for BVD1/SC, BVD2/DA, and BSY/IRQ.
 * Write-enable/protect change interrupts are always enabled.  The defaults
 * are unchanged (BVD1/SC is enabled, BVD2/DA is disabled, and BSY/IRQ is enabled).
 *
 * IMPORTANT -- Only set these bits for V39 card.resource or greater (check
 * resource base VERSION)
 *
 *)

  intbSetClr = 7;
  intbBVD1   = 5;
  intbSC     = 5;
  intbBVD2   = 4;
  intbDA     = 4;
  intbBSY    = 2;
  intbIRQ    = 2;

(* CardInterface() defines *)

  interfaceAmiga0 = 0;

(*
 * Tuple for Amiga execute-in-place software (e.g., games, or other
 * such software which wants to use execute-in-place software stored
 * on a credit-card, such as a ROM card).
 *
 * See documentatin for IfAmigaXIP().
 *)

  cisTplAmigaXIP = 091H;

TYPE
  TPAmigaXIPPtr=POINTER TO TPAmigaXIP;
  TPAmigaXIP = RECORD
    code      : SHORTCARD;
    link      : SHORTCARD;
    xipLoc    : ARRAY [0..3] OF SHORTCARD;
    xipFlags  : SHORTSET;
    xipResrv  : SHORTCARD;
  END;

CONST
(*
 * The XIPFLAGB_AUTORUN bit means that you want the machine
 * to perform a reset if the execute-in-place card is inserted
 * after DOS has been started.  The machine will then reset,
 * and execute your execute-in-place code the next time around.
 *
 * NOTE -- this flag may be ignored on some machines, in which
 * case the user will have to manually reset the machine in the
 * usual way.
 *
 *)

  autoRun = 0;


PROCEDURE OwnCard(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr):LONGINT; CODE -6;

PROCEDURE ReleaseCard(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                      flags{Reg.D0}:LONGSET); CODE -12;

PROCEDURE GetCardMap(base{Reg.A6}:ADDRESS):CardMemoryMapPtr; CODE -18;

PROCEDURE BeginCardAccess(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr):BOOLEAN; CODE -24;

PROCEDURE EndCardAccess(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr):BOOLEAN; CODE -30;

PROCEDURE ReadCardStatus(base{Reg.A6}:ADDRESS):SHORTINT; CODE -36;

PROCEDURE CardResetRemove(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                          flag{Reg.D0}:LONGSET):BOOLEAN; CODE -42;

PROCEDURE CardMiscControl(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                          controlBits{Reg.D1}:SHORTSET):SHORTSET; CODE -48;

PROCEDURE CardAccessSpeed(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                           nanoSeconds{Reg.D0}:LONGCARD):LONGCARD; CODE -54;

PROCEDURE CardProgramVoltage(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                             voltage{Reg.D0}:LONGCARD):LONGINT; CODE -60;

PROCEDURE CardResetCard(base{Reg.A6}:ADDRESS;
                        handle{Reg.A1}:CardHandlePtr):BOOLEAN; CODE -66;

PROCEDURE CopyTuple(base{Reg.A6}:ADDRESS;handle{Reg.A1}:CardHandlePtr;
                    buffer{Reg.A0}:ADDRESS;tupleCode{Reg.D1}:LONGCARD;
                    size{Reg.D0}:LONGCARD):BOOLEAN; CODE -72;

PROCEDURE DeviceTuple(base{Reg.A6}:ADDRESS;tupleData{Reg.A0}:ADDRESS;
                      storage{Reg.A1}:DeviceTDataPtr):LONGCARD; CODE -78;

PROCEDURE IfAmigaXIP(base{Reg.A6}:ADDRESS;
                     handle{Reg.A2}:CardHandlePtr):ResidentPtr; CODE -84;

PROCEDURE CardForceChange(base{Reg.A6}:ADDRESS):BOOLEAN; CODE -90;

PROCEDURE CardChangeCount(base{Reg.A6}:ADDRESS):LONGCARD; CODE -96;

PROCEDURE CardInterface(base{Reg.A6}:ADDRESS):LONGCARD; CODE -102;



END CardRes.

@endnode
