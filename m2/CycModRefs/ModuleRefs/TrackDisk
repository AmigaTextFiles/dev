@database TrackDisk
@node Main "TrackDisk"

Constants

   @{" addChangeInt " link Modul 79}                @{" allowNon35 " link Modul 185}                  @{" badDriveType " link Modul 219}
   @{" badHdrSum " link Modul 210}                   @{" badSecHdr " link Modul 213}                   @{" badSecID " link Modul 209}
   @{" badSecPreamble " link Modul 208}              @{" badSecSum " link Modul 211}                   @{" badUnitNum " link Modul 218}
   @{" cdrom " link Modul 153}                       @{" changeNum " link Modul 72}                   @{" changeState " link Modul 73}
   @{" communication " link Modul 157}               @{" directAccess " link Modul 146}                @{" diskChanged " link Modul 215}
   @{" drive35 " link Modul 194}                     @{" drive35rpm150 " link Modul 196}               @{" drive525 " link Modul 195}
   @{" driveInUse " link Modul 220}                  @{" eject " link Modul 82}                       @{" extClear " link Modul 98}
   @{" extCom " link Modul 65}                      @{" extFormat " link Modul 96}                   @{" extMotor " link Modul 94}
   @{" extRawRead " link Modul 99}                  @{" extRawWrite " link Modul 100}                 @{" extRead " link Modul 93}
   @{" extSeek " link Modul 95}                     @{" extUpdate " link Modul 97}                   @{" extWrite " link Modul 92}
   @{" format " link Modul 70}                      @{" getDriveType " link Modul 77}                @{" getGeometry " link Modul 81}
   @{" getNumTracks " link Modul 78}                @{" index " link Modul 166}                       @{" indexSync " link Modul 165}
   @{" labelSize " link Modul 177}                   @{" lastComm " link Modul 83}                    @{" mediumChanger " link Modul 156}
   @{" motor " link Modul 68}                       @{" noMem " link Modul 217}                       @{" noSecHdr " link Modul 207}
   @{" notSpecified " link Modul 206}                @{" numSecs " link Modul 28}                     @{" numUnits " link Modul 31}
   @{" opticalDisk " link Modul 155}                 @{" postReset " link Modul 221}                   @{" printer " link Modul 150}
   @{" processor " link Modul 151}                   @{" protStatus " link Modul 74}                  @{" rawRead " link Modul 75}
   @{" rawWrite " link Modul 76}                    @{" remChangeInt " link Modul 80}                @{" remove " link Modul 71}
   @{" scanner " link Modul 154}                     @{" secShift " link Modul 43}                    @{" sector " link Modul 42}
   @{" seek " link Modul 69}                        @{" seekError " link Modul 216}                   @{" sequentialAccess " link Modul 149}
   @{" tooFewSecs " link Modul 212}                  @{" trackDiskName " link Modul 63}               @{" unknown " link Modul 158}
   @{" word " link Modul 172}                        @{" wordSync " link Modul 171}                    @{" worm " link Modul 152}
   @{" writeProt " link Modul 214}                

Type-Declarations

   @{" DgFlagSet " link Modul 129}                   @{" DgFlags " link Modul 128}                     @{" DriveGeometry " link Modul 131}
   @{" DriveGeometryPtr " link Modul 144}            @{" IOExtTD " link Modul 107}                     @{" IOExtTDPtr " link Modul 113}
   @{" IOTrackDisk " link Modul 252}                 @{" IOTrackDiskPtr " link Modul 253}              @{" PubFlagSet " link Modul 233}
   @{" PubFlags " link Modul 230}                    @{" TDUPublicUnit " link Modul 235}            

@endnode
@node Modul "am2:ModuleRefs/TrackDisk.def"
(*$Implementation-*)
DEFINITION MODULE TrackDisk;
(*
**   14-12-96/Stefan Tiemann for Cyclone, converted from:
**	trackdisk.h 33.13 (28.11.90)
**	Includes Release 40.15
**
**	trackdisk device structure and value definitions
**
*)

IMPORT ED:ExecD;
FROM SYSTEM IMPORT LONGSET;

(*
 *--------------------------------------------------------------------
 *
 * Physical drive constants
 *
 *--------------------------------------------------------------------
 *)

(* OBSOLETE -- use the TD_GETNUMTRACKS command! *)
(*#define	NUMCYLS	80*)		(*  normal # of cylinders *)
(*#define	MAXCYLS	(NUMCYLS+20)*)	(* max # cyls to look for during cal *)
(*#define	NUMHEADS 2*)
(*#define	NUMTRACKS (NUMCYLS*NUMHEADS)*)

CONST

 numSecs=	11;
 numUnits= 4;

(*
 *--------------------------------------------------------------------
 *
 * Useful constants
 *
 *--------------------------------------------------------------------
 *)

(*-- sizes before mfm encoding *)
	sector= 512;
	secShift= 9;		(* log TD_SECTOR *)

(*
 *--------------------------------------------------------------------
 *
 * Driver Specific Commands
 *
 *--------------------------------------------------------------------
 *)

(*
 *-- TD_NAME is a generic macro to get the name of the driver.	This
 *-- way if the name is ever changed you will pick up the change
 *-- automatically.
 *--
 *-- Normal usage would be:
 *--
 *-- char internalName[] = TD_NAME;
 *--
 *)
     trackDiskName="trackdisk.device";

	extCom= 08000H;		(* for internal use only! *)


	motor=		(ED.nonstd+0);	(* control the disk's motor *)
	seek=		(ED.nonstd+1);	(* explicit seek (for testing) *)
	format=		(ED.nonstd+2);	(* format disk *)
	remove=		(ED.nonstd+3);	(* notify when disk changes *)
	changeNum=	(ED.nonstd+4);	(* number of disk changes *)
	changeState=	(ED.nonstd+5);	(* is there a disk in the drive? *)
	protStatus=	(ED.nonstd+6);	(* is the disk write protected? *)
	rawRead=		(ED.nonstd+7);	(* read raw bits from the disk *)
	rawWrite=		(ED.nonstd+8);	(* write raw bits to the disk *)
	getDriveType=	(ED.nonstd+9);	(* get the type of the disk drive *)
	getNumTracks=	(ED.nonstd+10); (* # of tracks for this type drive *)
	addChangeInt=	(ED.nonstd+11); (* REMOVE done right *)
	remChangeInt=	(ED.nonstd+12); (* remove softint set by ADDCHANGEINT *)
 	getGeometry=	(ED.nonstd+13); (* gets the disk geometry table *)
 	eject=		(ED.nonstd+14); (* for those drives that support it *)
	lastComm=		(ED.nonstd+15);

(*
 *
 * The disk driver has an "extended command" facility.	These commands
 * take a superset of the normal IO Request block.
 *
 *)

	extWrite=	(ED.write+extCom);
	extRead=	(ED.read+extCom);
	extMotor=	(motor+extCom);
	extSeek=	(seek+extCom);
	extFormat=(format+extCom);
	extUpdate=(ED.update+extCom);
	extClear=	(ED.clear+extCom);
	extRawRead=(rawRead+extCom);
	extRawWrite=(rawWrite+extCom);

(*
 *
 * extended IO has a larger than normal io request block.
 *
 *)
TYPE
 IOExtTD=RECORD
	req:	ED.IOStdReq;;
	count:LONGCARD;
	secLabel:LONGCARD;
 END;
 IOExtTDPtr=POINTER TO IOExtTD;

(*
 *  This is the structure returned by TD_DRIVEGEOMETRY
 *  Note that the layout can be defined three ways:
 *
 *  1. TotalSectors
 *  2. Cylinders and CylSectors
 *  3. Cylinders, Heads, and TrackSectors.
 *
 *  #1 is most accurate, #2 is less so, and #3 is least accurate.  All
 *  are usable, though #2 and #3 may waste some portion of the available
 *  space on some drives.
 *)
(* flags *)
 DgFlags=(removable,dg1,dg2,dg3,dg4,dg5,dg6,dg7);
 DgFlagSet=SET OF DgFlags;

 DriveGeometry=RECORD
	sectorSize:LONGCARD;		(* in bytes *)
	totalSectors:LONGCARD;		(* total # of sectors on drive *)
	cylinders:LONGCARD;			(* number of cylinders *)
	cylSectors:LONGCARD;		(* number of sectors/cylinder *)
	heads:LONGCARD;			(* number of surfaces *)
	trackSectors:LONGCARD;		(* number of sectors/track *)
	bufMemType:ED.MemReqSet;		(* preferred buffer memory type *)
							(* (usually MEMF_PUBLIC) *)
	deviceType:SHORTCARD;		(* codes as defined in the SCSI-2 spec*)
	flags:DgFlagSet;		(* flags, including removable *)
	reserved:CARDINAL;
 END;
 DriveGeometryPtr=POINTER TO DriveGeometry;

CONST
(* device types *)
 directAccess=	0;
 sequentialAccess=	1;
 printer=			2;
 processor=		3;
 worm=			4;
 cdrom=			5;
 scanner=			6;
 opticalDisk=		7;
 mediumChanger=	8;
 communication=	9;
 unknown=			31;

(*
** raw read and write can be synced with the index pulse.  This flag
** in io request's IO_FLAGS field tells the driver that you want this.
*)

 indexSync=4;
 index=ED.IOFlagSet{indexSync};
(*
** raw read and write can be synced with a $4489 sync pattern.	This flag
** in io request's IO_FLAGS field tells the driver that you want this.
*)
 wordSync=5;
 word= ED.IOFlagSet{wordSync};


(* labels are TD_LABELSIZE bytes per sector *)

 labelSize= 16;

(*
** This is a bit in the FLAGS field of OpenDevice.  If it is set, then
** the driver will allow you to open all the disks that the trackdisk
** driver understands.	Otherwise only 3.5" disks will succeed.
*)

 allowNon35=LONGSET{0};

(*
**  If you set the TDB_ALLOW_NON_3_5 bit in OpenDevice, then you don't
**  know what type of disk you really got.  These defines are for the
**  TD_GETDRIVETYPE command.  In addition, you can find out how many
**  tracks are supported via the TD_GETNUMTRACKS command.
*)

	drive35=1;
	drive525=2;
	drive35rpm150=3;

(*
 *--------------------------------------------------------------------
 *
 * Driver error defines
 *
 *--------------------------------------------------------------------
 *)

	notSpecified=	20;	(* general catchall *)
	noSecHdr=		21;	(* couldn't even find a sector *)
	badSecPreamble=22;	(* sector looked wrong *)
	badSecID=		23;	(* ditto *)
	badHdrSum=	24;	(* header had incorrect checksum *)
	badSecSum=	25;	(* data had incorrect checksum *)
	tooFewSecs=	26;	(* couldn't find enough sectors *)
	badSecHdr=	27;	(* another "sector looked wrong" *)
	writeProt=	28;	(* can't write to a protected disk *)
	diskChanged=	29;	(* no disk in the drive *)
	seekError=	30;	(* couldn't find track 0 *)
	noMem=		31;	(* ran out of memory *)
	badUnitNum=	32;	(* asked for a unit > NUMUNITS *)
	badDriveType=	33;	(* not a drive that trackdisk groks *)
	driveInUse=	34;	(* someone else allocated the drive *)
	postReset=	35;	(* user hit reset; awaiting doom *)

(*
 *--------------------------------------------------------------------
 *
 * public portion of the unit structure
 *
 *--------------------------------------------------------------------
 *)
TYPE
 (* flags for tdu_PubFlags *)
 PubFlags=(noClick,pf1,pf2,pf3,pf4,pf5,pf6,pf7);
 PubFlagSet=SET OF PubFlags;

 TDUPublicUnit=RECORD
	unit:ED.Unit;			(* base message port *)
	comp01Track:CARDINAL;	(* track for first precomp *)
	comp10Track:CARDINAL;	(* track for second precomp *)
	comp11Track:CARDINAL;	(* track for third precomp *)
	stepDelay:LONGCARD;		(* time to wait after stepping *)
	settleDelay:LONGCARD;	(* time to wait after seeking *)
	retryCnt:SHORTCARD;		(* # of times to retry *)
	pubFlags:PubFlagSet;	(* public flags, see below *)
	currTrk:CARDINAL;		(* track the heads are over... *)
						(* ONLY ACCESS WHILE UNIT IS STOPPED! *)
	calibrateDelay:LONGCARD;	(* time to wait after stepping *)
						(* during a recalibrate *)
	counter:LONGCARD;		(* counter for disk changes... *)
						(* ONLY ACCESS WHILE UNIT IS STOPPED! *)
 END;

 IOTrackDisk=IOExtTD;
 IOTrackDiskPtr=IOExtTDPtr;

END TrackDisk.

@endnode
