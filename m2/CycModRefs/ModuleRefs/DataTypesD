@database DataTypesD
@node Main "DataTypesD"

Constants

   @{" Bitnumber " link Modul 539}                   @{" Bitnumbers " link Modul 422}                  @{" Bitnumbers " link Modul 507}
   @{" Bitnumvbres " link Modul 858}                 @{" ID_BMHD " link Modul 733}                     @{" ID_BODY " link Modul 734}
   @{" ID_CAMG " link Modul 740}                     @{" ID_CMAP " link Modul 735}                     @{" ID_CRNG " link Modul 736}
   @{" ID_DEST " link Modul 739}                     @{" ID_GRAB " link Modul 737}                     @{" ID_ILBM " link Modul 730}
   @{" ID_SPRT " link Modul 738}                     @{" adtaAllocated " link Modul 913}               @{" adtaCRegs " link Modul 909}
   @{" adtaColorRegisters " link Modul 908}          @{" adtaColorTable " link Modul 911}              @{" adtaColorTable2 " link Modul 912}
   @{" adtaCycles " link Modul 953}                  @{" adtaDepth " link Modul 934}                   @{" adtaDummy " link Modul 903}
   @{" adtaFrame " link Modul 938}                   @{" adtaFrameIncrement " link Modul 944}          @{" adtaFrames " link Modul 935}
   @{" adtaFramesPerSecond " link Modul 941}         @{" adtaGRegs " link Modul 910}                   @{" adtaHeight " link Modul 933}
   @{" adtaKeyFrame " link Modul 905}                @{" adtaModeID " link Modul 904}                  @{" adtaNumAlloc " link Modul 915}
   @{" adtaNumColors " link Modul 914}               @{" adtaNumSparse " link Modul 923}               @{" adtaPeriod " link Modul 951}
   @{" adtaRemap " link Modul 917}                   @{" adtaSample " link Modul 949}                  @{" adtaSampleLength " link Modul 950}
   @{" adtaScreen " link Modul 920}                  @{" adtaSparseTable " link Modul 926}             @{" adtaVolume " link Modul 952}
   @{" adtaWidth " link Modul 932}                   @{" adtmDummy " link Modul 1041}                   @{" adtmLoadFrame " link Modul 1044}
   @{" adtmLocate " link Modul 1059}                  @{" adtmPause " link Modul 1053}                   @{" adtmStart " link Modul 1050}
   @{" adtmStop " link Modul 1056}                    @{" adtmUnloadFrame " link Modul 1047}             @{" already " link Modul 791}
   @{" animationDTClass " link Modul 898}            @{" cmpByteRun1 " link Modul 698}                 @{" cmpByteRun2 " link Modul 699}
   @{" cmpNone " link Modul 697}                     @{" cmpNone " link Modul 791}                     @{" dataTypesClass " link Modul 232}
   @{" dataTypesName " link Modul 18}               @{" dtErrorCouldntOpen " link Modul 202}          @{" dtErrorCouldntOpenClipboard " link Modul 206}
   @{" dtErrorCouldntSave " link Modul 201}          @{" dtErrorCouldntSendMessage " link Modul 203}   @{" dtErrorInvalidData " link Modul 210}
   @{" dtErrorNotEnoughData " link Modul 209}        @{" dtErrorReserved " link Modul 207}             @{" dtErrorUnknownCompression " link Modul 208}
   @{" dtErrorUnknownDataType " link Modul 200}      @{" dtMsgTypeOffset " link Modul 213}             @{" dtaARexxPortName " link Modul 389}
   @{" dtaBaseName " link Modul 307}                 @{" dtaBusy " link Modul 299}                     @{" dtaConductor " link Modul 322}
   @{" dtaControlPanel " link Modul 326}             @{" dtaData " link Modul 278}                     @{" dtaDataType " link Modul 344}
   @{" dtaDestCols " link Modul 377}                 @{" dtaDestRows " link Modul 380}                 @{" dtaDomain " link Modul 345}
   @{" dtaDummy " link Modul 237}                    @{" dtaErrorLevel " link Modul 313}               @{" dtaErrorNumber " link Modul 316}
   @{" dtaErrorString " link Modul 319}              @{" dtaFrameInfo " link Modul 361}                @{" dtaGroupID " link Modul 310}
   @{" dtaHandle " link Modul 343}                   @{" dtaHeight " link Modul 352}                   @{" dtaHorizUnit " link Modul 265}
   @{" dtaImmediate " link Modul 331}                @{" dtaLayoutProc " link Modul 296}               @{" dtaLeft " link Modul 349}
   @{" dtaMethods " link Modul 285}                  @{" dtaName " link Modul 341}                     @{" dtaNodeName " link Modul 268}
   @{" dtaNominalHoriz " link Modul 374}             @{" dtaNominalVert " link Modul 373}              @{" dtaObjAnnotation " link Modul 356}
   @{" dtaObjAuthor " link Modul 355}                @{" dtaObjCopyright " link Modul 357}             @{" dtaObjName " link Modul 354}
   @{" dtaObjVersion " link Modul 358}               @{" dtaObjectID " link Modul 359}                 @{" dtaPrinterProc " link Modul 293}
   @{" dtaPrinterStatus " link Modul 289}            @{" dtaRastPort " link Modul 386}                 @{" dtaRelBottom " link Modul 366}
   @{" dtaRelHeight " link Modul 368}                @{" dtaRelRight " link Modul 365}                 @{" dtaRelWidth " link Modul 367}
   @{" dtaRepeat " link Modul 335}                   @{" dtaSelectDomain " link Modul 370}             @{" dtaSourceType " link Modul 342}
   @{" dtaSpecial " link Modul 383}                  @{" dtaSync " link Modul 302}                     @{" dtaTextAttr " link Modul 240}
   @{" dtaTextFont " link Modul 281}                 @{" dtaTitle " link Modul 271}                    @{" dtaTop " link Modul 350}
   @{" dtaTopHoriz " link Modul 256}                 @{" dtaTopVert " link Modul 244}                  @{" dtaTotalHoriz " link Modul 262}
   @{" dtaTotalPHoriz " link Modul 372}              @{" dtaTotalPVert " link Modul 371}               @{" dtaTotalVert " link Modul 250}
   @{" dtaTriggerMethods " link Modul 274}           @{" dtaUserData " link Modul 360}                 @{" dtaVertUnit " link Modul 253}
   @{" dtaVisibleHoriz " link Modul 259}             @{" dtaVisibleVert " link Modul 247}              @{" dtaWidth " link Modul 351}
   @{" dtfASCII " link Modul 53}                    @{" dtfBinary " link Modul 52}                   @{" dtfCase " link Modul 58}
   @{" dtfIFF " link Modul 54}                      @{" dtfMisc " link Modul 55}                     @{" dtfSystem1 " link Modul 61}
   @{" dtfTypeMask " link Modul 51}                 @{" dthSize " link Modul 45}                     @{" dtmAbortPrint " link Modul 471}
   @{" dtmAsyncLayout " link Modul 461}              @{" dtmClearSelected " link Modul 467}            @{" dtmCopy " link Modul 469}
   @{" dtmDisposeMember " link Modul 474}            @{" dtmDraw " link Modul 480}                     @{" dtmDummy " link Modul 451}
   @{" dtmFrameBox " link Modul 455}                 @{" dtmGoto " link Modul 476}                     @{" dtmNewMember " link Modul 473}
   @{" dtmObtainDrawInfo " link Modul 479}           @{" dtmPrint " link Modul 470}                    @{" dtmProcLayout " link Modul 458}
   @{" dtmReleaseDrawInfo " link Modul 481}          @{" dtmRemoveDTObject " link Modul 464}           @{" dtmSelect " link Modul 466}
   @{" dtmTrigger " link Modul 477}                  @{" dtmWrite " link Modul 483}                    @{" dtnSize " link Modul 178}
   @{" dtsiDragSelect " link Modul 431}              @{" dtsiDragging " link Modul 430}                @{" dtsiHighlight " link Modul 433}
   @{" dtsiLayoutProc " link Modul 439}              @{" dtsiNEWSIZE " link Modul 428}                 @{" dtsiPrinting " link Modul 436}
   @{" dtstClipboard " link Modul 397}               @{" dtstFile " link Modul 396}                    @{" dtstHotlink " link Modul 398}
   @{" dtstRam " link Modul 395}                     @{" dtwmIIFF " link Modul 616}                    @{" dtwmRaw " link Modul 621}
   @{" fiRemappable " link Modul 511}                @{" fiScalable " link Modul 509}                  @{" fiScrollable " link Modul 510}
   @{" gIdAnimation " link Modul 103}                @{" gIdDocument " link Modul 88}                 @{" gIdInstrument " link Modul 94}
   @{" gIdMovie " link Modul 106}                    @{" gIdMusic " link Modul 97}                    @{" gIdPicture " link Modul 100}
   @{" gIdSound " link Modul 91}                    @{" gIdSystem " link Modul 82}                   @{" gIdText " link Modul 85}
   @{" id8SVX " link Modul 807}                      @{" idANHD " link Modul 958}                      @{" idANIM " link Modul 957}
   @{" idBODY " link Modul 811}                      @{" idCHRS " link Modul 878}                      @{" idCODE " link Modul 112}
   @{" idDLTA " link Modul 959}                      @{" idDTHD " link Modul 26}                      @{" idDTYP " link Modul 22}
   @{" idFTXT " link Modul 877}                      @{" idNAME " link Modul 195}                      @{" idTAGS " link Modul 163}
   @{" idTOOL " link Modul 133}                      @{" idVHDR " link Modul 810}                      @{" lnLink " link Modul 866}
   @{" lnObject " link Modul 869}                    @{" lnSelected " link Modul 872}                  @{" mskHasAlpha " link Modul 694}
   @{" mskHasMask " link Modul 691}                  @{" mskHasTransparentColor " link Modul 692}      @{" mskLasso " link Modul 693}
   @{" mskNone " link Modul 690}                     @{" pdtaAllocated " link Modul 654}               @{" pdtaBitMap " link Modul 644}
   @{" pdtaBitMapHeader " link Modul 642}            @{" pdtaCRegs " link Modul 650}                   @{" pdtaClassBitMap " link Modul 673}
   @{" pdtaColorRegisters " link Modul 649}          @{" pdtaColorTable " link Modul 652}              @{" pdtaColorTable2 " link Modul 653}
   @{" pdtaDestBitMap " link Modul 670}              @{" pdtaFreeSourceBitMap " link Modul 664}        @{" pdtaGRegs " link Modul 651}
   @{" pdtaGrab " link Modul 667}                    @{" pdtaModeID " link Modul 639}                  @{" pdtaNumAlloc " link Modul 656}
   @{" pdtaNumColors " link Modul 655}               @{" pdtaNumSparse " link Modul 678}               @{" pdtaRemap " link Modul 658}
   @{" pdtaScreen " link Modul 661}                  @{" pdtaSparseTable " link Modul 681}             @{" pictureDTClass " link Modul 631}
   @{" sdtaContinuous " link Modul 785}              @{" sdtaCycles " link Modul 775}                  @{" sdtaDummy " link Modul 761}
   @{" sdtaPeriod " link Modul 769}                  @{" sdtaSample " link Modul 763}                  @{" sdtaSampleLength " link Modul 766}
   @{" sdtaSignalBit " link Modul 782}               @{" sdtaSignalTask " link Modul 778}              @{" sdtaVoiceHeader " link Modul 762}
   @{" sdtaVolume " link Modul 772}                  @{" soundDTClass " link Modul 755}                @{" stmActivateField " link Modul 572}
   @{" stmBrowseNext " link Modul 568}               @{" stmBrowsePrev " link Modul 567}               @{" stmCommand " link Modul 574}
   @{" stmContents " link Modul 564}                 @{" stmFastForward " link Modul 578}              @{" stmIndex " link Modul 565}
   @{" stmLocate " link Modul 581}                   @{" stmNextField " link Modul 570}                @{" stmPause " link Modul 561}
   @{" stmPlay " link Modul 563}                     @{" stmPrevField " link Modul 571}                @{" stmResume " link Modul 580}
   @{" stmRetrace " link Modul 566}                  @{" stmRewind " link Modul 577}                   @{" stmStop " link Modul 579}
   @{" tSize " link Modul 144}                       @{" tdtaBuffer " link Modul 830}                  @{" tdtaBufferLen " link Modul 831}
   @{" tdtaLineList " link Modul 832}                @{" tdtaWordDelim " link Modul 834}               @{" tdtaWordSelect " link Modul 833}
   @{" tdtaWordWrap " link Modul 835}                @{" textDTClass " link Modul 825}                 @{" tfLaunchMask " link Modul 155}
   @{" tfRx " link Modul 158}                        @{" tfShell " link Modul 156}                     @{" tfWorkbench " link Modul 157}
   @{" tnSize " link Modul 190}                      @{" twBrows " link Modul 149}                     @{" twEdit " link Modul 150}
   @{" twInfo " link Modul 148}                      @{" twMail " link Modul 152}                      @{" twPrint " link Modul 151}


Type-Declarations

   @{" AnimHeader " link Modul 962}                  @{" AnimHeaderPtr " link Modul 1037}               @{" BitMapHeader " link Modul 703}
   @{" BitMapHeaderPtr " link Modul 719}             @{" ColorRegister " link Modul 724}               @{" ColorRegisterPtr " link Modul 727}
   @{" DTHookContext " link Modul 114}               @{" DTHookContextPtr " link Modul 131}            @{" DTMethod " link Modul 442}
   @{" DTMethodPtr " link Modul 448}                 @{" DTSpecialInfo " link Modul 401}               @{" DTSpecialInfoPtr " link Modul 420}
   @{" DataType " link Modul 166}                    @{" DataTypeHeader " link Modul 31}              @{" DataTypeHeaderPtr " link Modul 43}
   @{" DataTypePtr " link Modul 176}                 @{" FrameInfo " link Modul 485}                   @{" FrameInfoPtr " link Modul 506}
   @{" Line " link Modul 839}                        @{" LinePtr " link Modul 855}                     @{" StrPtr " link Modul 29}
   @{" Tool " link Modul 136}                        @{" ToolNode " link Modul 182}                    @{" ToolNodePtr " link Modul 188}
   @{" ToolPtr " link Modul 142}                     @{" VoiceHeader " link Modul 794}                 @{" VoiceHeaderPtr " link Modul 804}
   @{" adtFrame " link Modul 1063}                    @{" adtFramePtr " link Modul 1084}                 @{" adtStart " link Modul 1087}
   @{" adtStartPtr " link Modul 1091}                 @{" dtDraw " link Modul 594}                      @{" dtDrawPtr " link Modul 605}
   @{" dtFrameBox " link Modul 530}                  @{" dtFrameBoxPtr " link Modul 538}               @{" dtGeneral " link Modul 513}
   @{" dtGeneralPtr " link Modul 519}                @{" dtGoto " link Modul 543}                      @{" dtGotoPtr " link Modul 551}
   @{" dtPrint " link Modul 583}                     @{" dtPrintPtr " link Modul 591}                  @{" dtSelect " link Modul 522}
   @{" dtSelectPtr " link Modul 527}                 @{" dtTrigger " link Modul 554}                   @{" dtWrite " link Modul 608}


@endnode
@node Modul "am2:ModuleRefs/DataTypesD.def"
(*$ Implementation-*)
DEFINITION MODULE DataTypesD;
(*   11.12.96. Stefan Tiemann for Cyclone, converted from
**	datatypes.h 39.6 (22.4.93)
**	Includes Release 40.15
**
*)

IMPORT DD:DosD;
IMPORT ED: ExecD;
IMPORT IFF:IFFParseD;
IMPORT ID:IntuitionD;
IMPORT GD:GraphicsD;
IMPORT PRT:Printer;
IMPORT UD:UtilityD;
FROM SYSTEM IMPORT ADDRESS,BITSET,CAST,LONGSET;

(*****************************************************************************)
CONST
 dataTypesName="datatypes.library";

(*****************************************************************************)
CONST
 idDTYP=CAST(LONGCARD,'DTYP');

(*****************************************************************************)
CONST
 idDTHD=CAST(LONGCARD,'DTHD');

TYPE
 StrPtr= ADDRESS;
 DataTypeHeader=RECORD
  name:StrPtr;				(* Descriptive name of the data type *)
  baseName:StrPtr;				(* Base name of the data type *)
  pattern:StrPtr;				(* Match pattern for file name. *)
  mask:ADDRESS;				(* Comparision mask *)
  groupID:LONGCARD;				(* Group that the DataType is in *)
  id:LONGCARD;				(* ID for DataType (same as IFF FORM type) *)
  maskLen:INTEGER;				(* Length of comparision mask *)
  pad:INTEGER;				(* Unused at present (must be 0) *)
  flags:CARDINAL;				(* Flags *)
  priority:CARDINAL;				(* Priority *)
 END;
 DataTypeHeaderPtr= POINTER TO DataTypeHeader;

CONST
 dthSize=SIZE(DataTypeHeader);

(*****************************************************************************)

(* Basic type *)
 dtfTypeMask=BITSET{0..3};
 dtfBinary=BITSET{};
 dtfASCII=BITSET{0};
 dtfIFF=BITSET{1};
 dtfMisc=BITSET{0,1};

(* Set if case is important *)
 dtfCase=BITSET{4};

(* Reserved for system use *)
 dtfSystem1=BITSET{12};

(*****************************************************************************
 *
 * GROUP ID and ID
 *
 * This is used for filtering out objects that you don't want.	For
 * example, you could make a filter for the ASL file requester so
 * that it only showed the files that were pictures, or even to
 * narrow it down to only show files that were ILBM pictures.
 *
 * Note that the Group ID's are in lower case, and always the first
 * four characters of the word.
 *
 * For ID's; If it is an IFF file, then the ID is the same as the
 * FORM type.  If it isn't an IFF file, then the ID would be the
 * first four characters of name for the file type.
 *
 *****************************************************************************)

(* System file, such as; directory, executable, library, device, font, etc. *)
 gIdSystem	=CAST(LONGCARD,'syst');

(* Formatted or unformatted text *)
 gIdText	=CAST(LONGCARD,'text');

(* Formatted text with graphics or other DataTypes *)
 gIdDocument	=CAST(LONGCARD,'docu');

(* Sound *)
 gIdSound	=CAST(LONGCARD,'soun');

(* Musical instruments used for musical scores *)
 gIdInstrument	=CAST(LONGCARD,'inst');

(* Musical score *)
 gIdMusic	=CAST(LONGCARD,'musi');

(* Still picture *)
 gIdPicture =CAST(LONGCARD,'pict');

(* Animated picture *)
 gIdAnimation =CAST(LONGCARD,'anim');

(* Animation with audio track *)
 gIdMovie	=CAST(LONGCARD,'movi');

(*****************************************************************************)

(* A code chunk contains an embedded executable that can be loaded
 * with InternalLoadSeg. *)
 idCODE =CAST(LONGCARD,'DTCD');

TYPE
(* DataTypes comparision hook context (Read-Only).  This is the
 * argument that is passed to a custom comparision routine. *)
 DTHookContext=RECORD
    (* Libraries that are already opened for your use *)
  sysBase:ED.LibraryPtr;
  dosBase:ED.LibraryPtr;
  iffParseBase:ED.LibraryPtr;
  utilityBase:ED.LibraryPtr;
    (* File context *)
  lock:DD.BPTR;			(* Lock on the file *)
  fib:DD.FileInfoBlockPtr;	(* Pointer to a FileInfoBlock *)
  fileHandle:DD.BPTR;		(* Pointer to the file handle (may be NULL) *)
  iff: IFF.IFFHandlePtr;		(* Pointer to an IFFHandle (may be NULL) *)
  buffer:StrPtr;			(* Buffer *)
  bufferLength:LONGCARD;		(* Length of the buffer *)
 END;
 DTHookContextPtr= POINTER TO DTHookContext;
(*****************************************************************************)
CONST
 idTOOL =CAST(LONGCARD,'DTTL');

TYPE
 Tool=RECORD
    which:CARDINAL;				(* Which tool is this *)
    flags:BITSET;				(* Flags *)
    program:StrPtr;				(* Application to use *)
 END;
 ToolPtr= POINTER TO Tool;

CONST
 tSize=SIZE(Tool);

(* defines for tn_Which *)
 twInfo= 1;
 twBrows=	2;
 twEdit= 3;
 twPrint=	4;
 twMail= 5;

(* defines for tn_Flags *)
 tfLaunchMask=BITSET{0..3};
 tfShell=BITSET{0};
 tfWorkbench=BITSET{1};
 tfRx=BITSET{0,1};


(*****************************************************************************)

 idTAGS=CAST(LONGCARD,'DTTG');

(*****************************************************************************)
TYPE
 DataType=RECORD
  node1:ED.Node;			(* Reserved for system use *)
  node2:ED.Node;			(* Reserved for system use *)
  header:DataTypeHeaderPtr;	(* Pointer to the DataTypeHeader *)
  toolList:ED.List;			(* List of tool nodes *)
  functionName:StrPtr;		(* Name of comparision routine *)
  attrList:UD.TagItemPtr;	(* Object creation tags *)
  length:LONGCARD;			(* Length of the memory block *)
 END;
 DataTypePtr= POINTER TO DataType;

CONST
 dtnSize=SIZE(DataType);

(*****************************************************************************)
TYPE
 ToolNode=RECORD
    node:ED.Node;			(* Embedded node *)
    tool:Tool;				(* Embedded tool *)
    length:LONGCARD;		(* Length of the memory block *)
 END;
 ToolNodePtr=POINTER TO ToolNode;

CONST
 tnSize=SIZE(ToolNode);

(*****************************************************************************)

 idNAME	=CAST(LONGCARD,'NAME');

(*****************************************************************************)

(* text ID's *)
 dtErrorUnknownDataType= 		2000;
 dtErrorCouldntSave=			2001;
 dtErrorCouldntOpen=			2002;
 dtErrorCouldntSendMessage=		2003;

(* new for V40 *)
 dtErrorCouldntOpenClipboard=		2004;
 dtErrorReserved=    			2005;
 dtErrorUnknownCompression=		2006;
 dtErrorNotEnoughData=			2007;
 dtErrorInvalidData=			2008;

(* Offset for types *)
 dtMsgTypeOffset=    			2100;

(*****************************************************************************)






(*
**  datatypesclass.h 39.8 (17.3.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType objects.
**
*)


(*****************************************************************************)
CONST
 dataTypesClass=	"datatypesclass";

(*****************************************************************************)

	dtaDummy		=(UD.tagUser+1000H);

(* Generic attributes *)
	dtaTextAttr		=(dtaDummy+10);
	(* (struct TextAttr * ) Pointer to the default TextAttr to use for
	 * the text within the object. *)

	dtaTopVert		=(dtaDummy+11);
	(* (LONG) Current top vertical unit *)

	dtaVisibleVert		=(dtaDummy+12);
	(* (LONG) Number of visible vertical units *)

	dtaTotalVert		=(dtaDummy+13);
	(* (LONG) Total number of vertical units *)

	dtaVertUnit		=(dtaDummy+14);
	(* (LONG) Number of pixels per vertical unit *)

	dtaTopHoriz		=(dtaDummy+15);
	(* (LONG) Current top horizontal unit *)

	dtaVisibleHoriz	=(dtaDummy+16);
	(* (LONG)  Number of visible horizontal units *)

	dtaTotalHoriz		=(dtaDummy+17);
	(* (LONG) Total number of horizontal units *)

	dtaHorizUnit		=(dtaDummy+18);
	(* (LONG) Number of pixels per horizontal unit *)

	dtaNodeName		=(dtaDummy+19);
	(* (UBYTE * ) Name of the current element within the object. *)

	dtaTitle		=(dtaDummy+20);
	(* (UBYTE * ) Title of the object. *)

	dtaTriggerMethods	=(dtaDummy+21);
	(* (struct DTMethod * ) Pointer to a NULL terminated array of
	 * supported trigger methods. *)

	dtaData		=(dtaDummy+22);
	(* (APTR) Object specific data. *)

	dtaTextFont		=(dtaDummy+23);
	(* (struct TextFont * ) Default font to use for text within the
	 * object. *)

	dtaMethods		=(dtaDummy+24);
	(* (ULONG * ) Pointer to a ~0 terminated array of supported
	 * methods. *)

	dtaPrinterStatus	=(dtaDummy+25);
	(* (LONG) Printer error message.  Error numbers are defined in
	 * <devices/printer.h> *)

	dtaPrinterProc		=(dtaDummy+26);
	(* PRIVATE (struct Process * ) Pointer to the print process. *)

	dtaLayoutProc		=(dtaDummy+27);
	(* PRIVATE (struct Process * ) Pointer to the layout process. *)

	dtaBusy		=(dtaDummy+28);
	(* Used to turn the applications' busy pointer off and on *)

	dtaSync		=(dtaDummy+29);
	(* Used to indicate that new information has been loaded into
	 * an object.  This is for models that cache the dtaTopVert-
	 * like tags *)

	dtaBaseName		=(dtaDummy+30);
	(* The base name of the class *)

	dtaGroupID		=(dtaDummy+31);
	(* Group that the object must belong in *)

	dtaErrorLevel		=(dtaDummy+32);
	(* Error level *)

	dtaErrorNumber		=(dtaDummy+33);
	(* datatypes.library error number *)

	dtaErrorString		=(dtaDummy+34);
	(* Argument for datatypes.library error *)

	dtaConductor		=(dtaDummy+35);
	(* New for V40. (UBYTE * ) specifies the name of the
	 * realtime.library conductor.	Defaults to "Main". *)

	dtaControlPanel	=(dtaDummy+36);
	(* New for V40. (BOOL) Indicate whether a control panel should be
	 * embedded within the object (in the animation datatype, for
	 * example).  Defaults to TRUE. *)

	dtaImmediate		=(dtaDummy+37);
	(* New for V40. (BOOL) Indicate whether the object should
	 * immediately begin playing.  Defaults to FALSE. *)

	dtaRepeat		=(dtaDummy+38);
	(* New for V40. (BOOL) Indicate that the object should repeat
	 * playing.  Defaults to FALSE. *)


(* DTObject attributes *)
	dtaName		=(dtaDummy+100);
	dtaSourceType	=(dtaDummy+101);
	dtaHandle		=(dtaDummy+102);
	dtaDataType	=(dtaDummy+103);
	dtaDomain		=(dtaDummy+104);

(* DON'T USE THE FOLLOWING FOUR TAGS.  USE THE CORRESPONDING TAGS IN
 * <intuition/gadgetclass.h> *)
	dtaLeft		=(dtaDummy+105);
	dtaTop		=(dtaDummy+106);
	dtaWidth		=(dtaDummy+107);
	dtaHeight		=(dtaDummy+108);

	dtaObjName		=(dtaDummy+109);
	dtaObjAuthor		=(dtaDummy+110);
	dtaObjAnnotation	=(dtaDummy+111);
	dtaObjCopyright	=(dtaDummy+112);
	dtaObjVersion		=(dtaDummy+113);
	dtaObjectID		=(dtaDummy+114);
	dtaUserData		=(dtaDummy+115);
	dtaFrameInfo		=(dtaDummy+116);

(* DON'T USE THE FOLLOWING FOUR TAGS.  USE THE CORRESPONDING TAGS IN
 * <intuition/gadgetclass.h> *)
	dtaRelRight		=(dtaDummy+117);
	dtaRelBottom		=(dtaDummy+118);
	dtaRelWidth		=(dtaDummy+119);
	dtaRelHeight		=(dtaDummy+120);

	dtaSelectDomain	=(dtaDummy+121);
	dtaTotalPVert		=(dtaDummy+122);
	dtaTotalPHoriz		=(dtaDummy+123);
	dtaNominalVert		=(dtaDummy+124);
	dtaNominalHoriz	=(dtaDummy+125);

(* Printing attributes *)
	dtaDestCols		=(dtaDummy+400);
	(* (LONG) Destination X width *)

	dtaDestRows		=(dtaDummy+401);
	(* (LONG) Destination Y height *)

	dtaSpecial		=(dtaDummy+402);
	(* (UWORD) Option flags *)

	dtaRastPort		=(dtaDummy+403);
	(* (struct RastPort * ) RastPort to use when printing. (V40) *)

	dtaARexxPortName	=(dtaDummy+404);
	(* (STRPTR) Pointer to base name for ARexx port (V40) *)


(*****************************************************************************)

	dtstRam=		1;
	dtstFile=		2;
	dtstClipboard=		3;
	dtstHotlink=		4;

(*****************************************************************************)
TYPE
(* Attached to the Gadget.SpecialInfo field of the gadget.  Don't access directly,
 * use the Get/Set calls instead.
 *)
 DTSpecialInfo=RECORD
    lock: ED.SignalSemaphore;	(* Locked while in DoAsyncLayout() *)
    flags:LONGSET;
    topVert:LONGINT;	(* Top row (in units) *)
    visVert:LONGINT;	(* Number of visible rows (in units) *)
    totVert:LONGINT;	(* Total number of rows (in units) *)
    oTopVert:LONGINT;	(* Previous top (in units) *)
    vertUnit:LONGINT;	(* Number of pixels in vertical unit *)

    topHoriz:LONGINT;	(* Top column (in units) *)
    visHoriz:LONGINT;	(* Number of visible columns (in units) *)
    totHoriz:LONGINT;	(* Total number of columns (in units) *)
    oTopHoriz:LONGINT;	(* Previous top (in units) *)
    horizUnit:LONGINT;	(* Number of pixels in horizontal unit *)
 END;
 DTSpecialInfoPtr=POINTER TO DTSpecialInfo;

CONST
// Bitnumbers for DTSpecialInfo.flags
(* Object is in layout processing *)
	dtsiLayout=0;

(* Object needs to be layed out *)
	dtsiNEWSIZE=1;

	dtsiDragging=2;
	dtsiDragSelect=3;

	dtsiHighlight=4;

(* Object is being printed *)
	dtsiPrinting=5;

(* Object is in layout process *)
	dtsiLayoutProc=6;

(*****************************************************************************)
TYPE
 DTMethod=RECORD
    label:StrPtr;
    command:StrPtr;
    method:LONGCARD;
 END;
 DTMethodPtr=POINTER TO DTMethod;

(*****************************************************************************)
CONST
	dtmDummy		=0600H;

(* Inquire what environment an object requires *)
	dtmFrameBox		=0601H;

(* Same as GM_LAYOUT except guaranteed to be on a process already *)
	dtmProcLayout		=0602H;

(* Layout that is occurring on a process *)
	dtmAsyncLayout		=0603H;

(* When a RemoveDTObject() is called *)
	dtmRemoveDTObject	=0604H;

	dtmSelect		=0605H;
	dtmClearSelected	=0606H;

	dtmCopy		=0607H;
	dtmPrint		=0608H;
	dtmAbortPrint		=0609H;

	dtmNewMember		=0610H;
	dtmDisposeMember	=0611H;

	dtmGoto		=0630H;
	dtmTrigger 	=0631H;

	dtmObtainDrawInfo	=0640H;
	dtmDraw		=0641H;
	dtmReleaseDrawInfo	=0642H;

	dtmWrite		=0650H;

TYPE
(* Used to ask the object about itself *)
 FrameInfo=RECORD
    propertyFlags:GD.PropertyFlagSet;		(* DisplayInfo (graphics/displayinfo.h) *)
    resolution:GD.Point;		(* DisplayInfo *)

    redBits:SHORTCARD;
    greenBits:SHORTCARD;
    blueBits:SHORTCARD;

    dimensions:RECORD
      width:LONGCARD;
	 height:LONGCARD;
	 depth:LONGCARD;
    END;

    screen:ID.ScreenPtr;
    colorMap:GD.ColorMapPtr;

    flags:LONGSET;
END;
FrameInfoPtr=POINTER TO FrameInfo;
CONST
// Bitnumbers for FrameInfo.flags;
	fiScalable= 0;
	fiScrollable=1;
	fiRemappable=2;

TYPE
(* DTM_REMOVEDTOBJECT, DTM_CLEARSELECTED, DTM_COPY, DTM_ABORTPRINT *)
 dtGeneral=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
 END;
 dtGeneralPtr= POINTER TO dtGeneral;

(* DTM_SELECT *)
 dtSelect=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    select:GD.Rectangle;
 END;
 dtSelectPtr= POINTER TO dtSelect;

(* DTM_FRAMEBOX *)
 dtFrameBox=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    contentsInfo:FrameInfoPtr;	(* Input *)
    frameInfo:FrameInfoPtr;		(* Output *)
    sizeFrameInfo:LONGCARD;
    frameFlags:LONGSET;
 END;
 dtFrameBoxPtr=POINTER TO dtFrameBox;
CONST
//Bitnumber for dtFrameBox.frameFlags
 frameSpecify=0;	(* Make do with the dimensions of FrameBox provided. *)

TYPE
(* DTM_GOTO *)
 dtGoto=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    nodeName:StrPtr;		(* Node to goto *)
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtGotoPtr= POINTER TO dtGoto;

(* DTM_TRIGGER *)
 dtTrigger=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;
    function:LONGCARD;
    data:ADDRESS;
 END;

CONST
	stmPause=	1;
	stmPlay=	2;
	stmContents=	3;
	stmIndex=		4;
	stmRetrace=	5;
	stmBrowsePrev=	6;
	stmBrowseNext=	7;

	stmNextField=	8;
	stmPrevField=  9;
	stmActivateField=	10;

	stmCommand=	11;

(* New for V40 *)
	stmRewind=	12;
	stmFastForward=13;
	stmStop=		14;
	stmResume=	15;
	stmLocate=		16;

TYPE
(* DTM_PRINT *)
 dtPrint=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;		(* Gadget information *)
    pio:PRT.PrinterIOPtr;		(* Printer IO request *)
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtPrintPtr=POINTER TO dtPrint;

(* DTM_DRAW *)
 dtDraw=RECORD
    methodID:LONGCARD;
    rPort:GD.RastPortPtr;
    left:LONGINT;
    top:LONGINT;
    width:LONGINT;
    height:LONGINT;
    topHoriz:LONGINT;
    topVert:LONGINT;
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;
 dtDrawPtr=POINTER TO dtDraw;

(* DTM_WRITE *)
 dtWrite=RECORD
    methodID:LONGCARD;
    gInfo:ID.GadgetInfoPtr;		(* Gadget information *)
    fileHandle:DD.BPTR;			(* File handle to write to *)
    mode:LONGCARD;
    attrList:UD.TagItemPtr;		(* Additional attributes *)
 END;

CONST
(* Save data as IFF data *)
	dtwmIIFF=0;

(* Save data as local data format *)
	dtwmRaw=1;


(*
**   pictureclass.h 39.5 (28.4.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType picture objects.
*)

CONST
(*****************************************************************************)

 pictureDTClass=	"picture.datatype";

(*****************************************************************************)

(* Picture attributes *)
	pdtaModeID		=(dtaDummy + 200);
	(* Mode ID of the picture *)

	pdtaBitMapHeader	=(dtaDummy + 201);

	pdtaBitMap		=(dtaDummy + 202);
	(* Pointer to a class-allocated bitmap, that will end
	 * up being freed by picture.class when DisposeDTObject()
	 * is called *)

	pdtaColorRegisters	=(dtaDummy + 203);
	pdtaCRegs		=(dtaDummy + 204);
	pdtaGRegs		=(dtaDummy + 205);
	pdtaColorTable		=(dtaDummy + 206);
	pdtaColorTable2	=(dtaDummy + 207);
	pdtaAllocated		=(dtaDummy + 208);
	pdtaNumColors		=(dtaDummy + 209);
	pdtaNumAlloc		=(dtaDummy + 210);

	pdtaRemap		=(dtaDummy + 211);
	(* Boolean : Remap picture (defaults to TRUE) *)

	pdtaScreen		=(dtaDummy + 212);
	(* Screen to remap to *)

	pdtaFreeSourceBitMap	=(dtaDummy + 213);
	(* Boolean : Free the source bitmap after remapping *)

	pdtaGrab		=(dtaDummy + 214);
	(* Pointer to a Point structure *)

	pdtaDestBitMap		=(dtaDummy + 215);
	(* Pointer to the destination (remapped) bitmap *)

	pdtaClassBitMap	=(dtaDummy + 216);
	(* Pointer to class-allocated bitmap, that will end
	 * up being freed by the class after DisposeDTObject()
	 * is called *)

	pdtaNumSparse		=(dtaDummy + 217);
	(* (UWORD) Number of colors used for sparse remapping *)

	pdtaSparseTable	=(dtaDummy + 218);
	(* (UBYTE * ) Pointer to a table of pen numbers indicating
	 * which colors should be used when remapping the image.
	 * This array must contain as many entries as there
	 * are colors specified with pdtaNumSparse *)

(*****************************************************************************)

(*  Masking techniques	*)
	mskNone=			0;
	mskHasMask=		1;
	mskHasTransparentColor=	2;
	mskLasso=		3;
	mskHasAlpha=		4;

(*  Compression techniques  *)
	cmpNone=			0;
	cmpByteRun1=		1;
	cmpByteRun2=		2;


(*  Bitmap header (BMHD) structure  *)
TYPE
 BitMapHeader=RECORD
    width:CARDINAL;		(* Width in pixels *)
    height:CARDINAL;		(* Height in pixels *)
    left:INTEGER;		(* Left position *)
    top:INTEGER;		(* Top position *)
    depth:SHORTCARD;		(* Number of planes *)
    masking:SHORTCARD;		(* Masking type *)
    compression:SHORTCARD;	(* Compression type *)
    pad:SHORTCARD;
    transparent:CARDINAL;	(* Transparent color *)
    xAspect:SHORTCARD;
    yAspect:SHORTCARD;
    pageWidth:INTEGER;
    pageHeight:INTEGER;
 END;
 BitMapHeaderPtr=POINTER TO BitMapHeader;

(*****************************************************************************)

(*  Color register structure *)
 ColorRegister=RECORD
    red, green, blue:SHORTCARD;
 END;
 ColorRegisterPtr=POINTER TO ColorRegister;

(*****************************************************************************)
CONST
(* IFF types that may be in pictures *)
	ID_ILBM		=CAST(LONGCARD,'ILBM');
	ID_BMHD		=CAST(LONGCARD,'BMHD');
	ID_BODY		=CAST(LONGCARD,'BODY');
	ID_CMAP		=CAST(LONGCARD,'CMAP');
	ID_CRNG		=CAST(LONGCARD,'CRNG');
	ID_GRAB		=CAST(LONGCARD,'GRAB');
	ID_SPRT		=CAST(LONGCARD,'SPRT');
	ID_DEST		=CAST(LONGCARD,'DEST');
	ID_CAMG		=CAST(LONGCARD,'CAMG');





(*
**  soundclass.h 39.3 (26.4.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType sound objects.
*)


(*****************************************************************************)
CONST
	soundDTClass=	"sound.datatype";

(*****************************************************************************)

(* Sound attributes *)
	sdtaDummy		=(dtaDummy + 500);
	sdtaVoiceHeader	=(sdtaDummy + 1);
	sdtaSample		=(sdtaDummy + 2);
   (* (UBYTE * ) Sample data *)

	sdtaSampleLength	=(sdtaDummy + 3);
   (* (ULONG) Length of the sample data in UBYTEs *)

	sdtaPeriod		=(sdtaDummy + 4);
    (* (UWORD) Period *)

	sdtaVolume		=(sdtaDummy + 5);
    (* (UWORD) Volume.	Range from 0 to 64 *)

	sdtaCycles		=(sdtaDummy + 6);

(* The following tags are new for V40 *)
	sdtaSignalTask		=(sdtaDummy + 7);
    (* (struct Task * ) Task to signal when sound is complete or
	next buffer needed. *)

	sdtaSignalBit		=(sdtaDummy + 8);
    (* (BYTE) Signal bit to use on completion or -1 to disable *)

	sdtaContinuous		=(sdtaDummy + 9);
    (* (ULONG) Playing a continuous stream of data.  Defaults to
	FALSE. *)

(*****************************************************************************)

 //cmpNone=     0;  //already declared above
 cmpFibDelta= 1;

TYPE
 VoiceHeader=RECORD
    oneShotHiSamples:LONGCARD;
    repeatHiSamples:LONGCARD;
    samplesPerHiCycle:LONGCARD;
    samplesPerSec:CARDINAL;
    octaves:SHORTCARD;
    compression:SHORTCARD;
    volume:LONGCARD;
 END;
 VoiceHeaderPtr=POINTER TO VoiceHeader;

(*****************************************************************************)
CONST
(* IFF types *)
 id8SVX =CAST(LONGCARD,'8SVX');
 idVHDR =CAST(LONGCARD,'VHDR');
 idBODY =CAST(LONGCARD,'BODY');

(*****************************************************************************)



(*
**  textclass.h 39.3 (3.8.92)
**  Includes Release 40.15
**
*)

(*****************************************************************************)

	textDTClass=	"text.datatype";

(*****************************************************************************)

(* Text attributes *)
	tdtaBuffer		=(dtaDummy + 300);
	tdtaBufferLen		=(dtaDummy + 301);
	tdtaLineList		=(dtaDummy + 302);
	tdtaWordSelect		=(dtaDummy + 303);
	tdtaWordDelim		=(dtaDummy + 304);
	tdtaWordWrap		=(dtaDummy + 305);
     (* Boolean. Should the text be word wrapped.  Defaults to false. *)

(*****************************************************************************)
TYPE
(* There is one Line structure for every line of text in our document.	*)
  Line=RECORD
    link:ED.MinNode;		(* to link the lines together *)
    text:StrPtr;		(* pointer to the text for this	line *)
    textLen:LONGCARD;		(* the character length of the text for this line *)
    xOffset:CARDINAL;		(* where in the	line the text starts *)
    yOffset:CARDINAL;		(* line the text is on *)
    width:CARDINAL;		(* Width of line in pixels *)
    height:CARDINAL;		(* Height of line in pixels *)
    flags:BITSET;		(* info	on the line *)
    fgPen:SHORTINT;		(* foreground pen *)
    bgPen:SHORTINT;		(* background pen *)
    style:LONGSET;		(* Font style *)
    data:ADDRESS;		(* Link data... *)
 END;
 LinePtr=POINTER TO Line;

(*****************************************************************************)
CONST
//Bitnumvbres for Line.flags
(* Line.ln_Flags *)

(* Line Feed *)
	lnLf=0;

(* Segment is a link *)
	lnLink=1;

(* ln_Data is a pointer to an DataTypes object *)
	lnObject=2;

(* Object is selected *)
	lnSelected=3;

(*****************************************************************************)

(* IFF types that may be text *)
	idFTXT		=CAST(LONGCARD,'FTXT');
	idCHRS		=CAST(LONGCARD,'CHRS');

(*****************************************************************************)






(*
**  animationclass.h 40.1 (4.5.93)
**  Includes Release 40.15
**
**  Interface definitions for DataType animation objects.
**
*)


(*****************************************************************************)

	animationDTClass=	"animation.datatype";

(*****************************************************************************)

(* Animation attributes *)
	adtaDummy		=(dtaDummy + 600);
	adtaModeID		=pdtaModeID;
	adtaKeyFrame		=pdtaBitMap;
	(* (struct BitMap * ) Key frame (first frame) bitmap *)

	adtaColorRegisters	=pdtaColorRegisters;
	adtaCRegs			=pdtaCRegs;
	adtaGRegs			=pdtaGRegs;
	adtaColorTable		=pdtaColorTable;
	adtaColorTable2	=pdtaColorTable2;
	adtaAllocated		=pdtaAllocated;
	adtaNumColors		=pdtaNumColors;
	adtaNumAlloc		=pdtaNumAlloc;

	adtaRemap		=pdtaRemap;
	(* (BOOL) : Remap animation (defaults to TRUE) *)

	adtaScreen		=pdtaScreen;
	(* (struct Screen * ) Screen to remap to *)

	adtaNumSparse		=pdtaNumSparse;
	(* (UWORD) Number of colors used for sparse remapping *)

	adtaSparseTable	=pdtaSparseTable;
	(* (UBYTE * ) Pointer to a table of pen numbers indicating
	 * which colors should be used when remapping the image.
	 * This array must contain as many entries as there
	 * are colors specified with adtaNumSparse *)

	adtaWidth			=(adtaDummy + 1);
	adtaHeight		=(adtaDummy + 2);
	adtaDepth			=(adtaDummy + 3);
	adtaFrames		=(adtaDummy + 4);
	(* (ULONG) Number of frames in the animation *)

	adtaFrame		=(adtaDummy + 5);
	(* (ULONG) Current frame *)

	adtaFramesPerSecond	=(adtaDummy + 6);
	(* (ULONG) Frames per second *)

	adtaFrameIncrement	=(adtaDummy + 7);
	(* (LONG) Amount to change frame by when fast forwarding or
	 * rewinding.  Defaults to 10. *)

(* Sound attributes *)
	adtaSample		=sdtaSample;
	adtaSampleLength	=sdtaSampleLength;
	adtaPeriod		=sdtaPeriod;
	adtaVolume		=sdtaVolume;
	adtaCycles		=sdtaCycles;

(*****************************************************************************)

 idANIM	=CAST(LONGCARD,'ANIM');
 idANHD	=CAST(LONGCARD,'ANHD');
 idDLTA	=CAST(LONGCARD,'DLTA');

(*****************************************************************************)
TYPE
(*  Required ANHD structure describes an ANIM frame *)
 AnimHeader=RECORD
    operation:SHORTCARD;	(*  The compression method:
				     0	set directly (normal ILBM BODY),
				     1	XOR ILBM mode,
				     2	Long Delta mode,
				     3	Short Delta mode,
				     4	Generalized short/long Delta mode,
				     5	Byte Vertical Delta mode
				     6	Stereo op 5 (third party)
				    74	(ascii 'J') reserved for Eric Graham's
					compression technique (details to be
					released later). *)

    mask:SHORTCARD;	(* (XOR mode only - plane mask where each
				   bit is set =1 if there is data and =0
				   if not.) *)

    width:CARDINAL;	(* (XOR mode only - width and height of the *)
    height:CARDINAL;	(* area represented by the BODY to eliminate *)
				(* unnecessary un-changed data) *)


    left:INTEGER;	(* (XOR mode only - position of rectangular *)
    top:INTEGER;	(* area representd by the BODY) *)


    absTime:LONGCARD;	(* Timing for a frame relative to the time
					   the first frame was displayed, in
					   jiffies (1/60 sec) *)

    relTime:LONGCARD;	(* Timing for frame relative to time
					   previous frame was displayed - in
					   jiffies (1/60 sec) *)

    interleave:SHORTCARD;	(* Indicates how may frames back this data is to
						   modify.  0 defaults to indicate two frames back
						   (for double buffering). n indicates n frames back.
						   The main intent here is to allow values
						   of 1 for special applications where
						   frame data would modify the immediately
						   previous frame. *)

    pad0:SHORTCARD;	(* Pad byte, not used at present. *)

    flags:LONGSET;	(* 32 option bits used by options=4 and 5.
				   At present only 6 are identified, but the
				   rest are set =0 so they can be used to
				   implement future ideas.  These are defined
				   for option 4 only at this point.  It is
				   recommended that all bits be set =0 for
				   option 5 and that any bit settings
				   used in the future (such as for XOR mode)
				   be compatible with the option 4
				   bit settings.   Player code should check
				   undefined bits in options 4 and 5 to assure
				   they are zero.

				   The six bits for current use are:

				    bit #	set =0			set =1
				    ===============================================
				    0		short data		long data
				    1		set			XOR
				    2		separate info		one info list
						for each plane		for all planes
				    3		not RLC			RLC (run length coded)
				    4		horizontal		vertical
				    5		short info offsets	long info offsets
				*)

    pad:ARRAY [0..15] OF SHORTCARD;	(* This is a pad for future use for future
								   compression modes. *)
 END;
 AnimHeaderPtr=POINTER TO AnimHeader;

(*****************************************************************************)

CONST
	adtmDummy		=(0700H);

	adtmLoadFrame		=(0701H);
    (* Used to load a frame of the animation *)

	adtmUnloadFrame	=(0702H);
    (* Used to unload a frame of the animation *)

	adtmStart		=(0703H);
    (* Used to start the animation *)

	adtmPause		=(0704H);
    (* Used to pause the animation (don't reset the timer) *)

	adtmStop			=(0705H);
    (* Used to stop the animation *)

	adtmLocate		=(0706H);
    (* Used to locate a frame in the animation (as set by a slider...) *)

(*****************************************************************************)
TYPE
(* adtmLOADFRAME, adtmUNLOADFRAME *)
 adtFrame=RECORD
    methodID:LONGCARD;
    timeStamp:LONGCARD;		(* Timestamp of frame to load *)

    (* The following fields are filled in by the adtmLOADFRAME method, *)
    (* and are read-only for any other methods. *)

    frame:LONGCARD;		(* Frame number *)
    duration:LONGCARD;		(* Duration of frame *)

    bitMap:GD.BitMapPtr;		(* Loaded BitMap *)
    cMap:GD.ColorMapPtr;		(* Colormap, if changed *)

    sample:ADDRESS;		(* Sound data *)
    sampleLength:LONGCARD;
    period:LONGCARD;

    userData:ADDRESS;		(* Used by load frame for extra data *)
 END;
 adtFramePtr= POINTER TO adtFrame;

(* adtmSTART, adtmPAUSE, adtmSTOP, adtmLOCATE *)
 adtStart=RECORD
    methodID:LONGCARD;
    frame:LONGCARD;		(* Frame # to start at *)
 END;
 adtStartPtr=POINTER TO adtStart;

(*****************************************************************************)




END DataTypesD.


@endnode
