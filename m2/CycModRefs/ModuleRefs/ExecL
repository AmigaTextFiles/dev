@database ExecL
@node Main "ExecL"

Procedures

   @{" AbortIO " link Modul 212}                     @{" AddDevice " link Modul 193}                   @{" AddHead " link Modul 109}
   @{" AddIntServer " link Modul 70}                @{" AddLibrary " link Modul 179}                  @{" AddMemList " link Modul 275}
   @{" AddPort " link Modul 162}                     @{" AddResource " link Modul 216}                 @{" AddSemaphore " link Modul 265}
   @{" AddTail " link Modul 112}                     @{" AddTask " link Modul 129}                     @{" Alert " link Modul 51}
   @{" AllocAbs " link Modul 90}                    @{" AllocEntry " link Modul 98}                  @{" AllocMem " link Modul 87}
   @{" AllocPooled " link Modul 329}                 @{" AllocSignal " link Modul 151}                 @{" AllocTrap " link Modul 156}
   @{" AllocVec " link Modul 318}                    @{" Allocate " link Modul 80}                    @{" AttemptSemaphore " link Modul 254}
   @{" AvailMem " link Modul 96}                    @{" CacheClearE " link Modul 294}                 @{" CacheClearU " link Modul 292}
   @{" CacheControl " link Modul 298}                @{" CachePostDMA " link Modul 355}                @{" CachePreDMA " link Modul 351}
   @{" Cause " link Modul 76}                       @{" CheckIO " link Modul 208}                     @{" ChildFree " link Modul 344}
   @{" ChildOrphan " link Modul 345}                 @{" ChildStatus " link Modul 346}                 @{" ChildWait " link Modul 347}
   @{" CloseDevice " link Modul 202}                 @{" CloseLibrary " link Modul 185}                @{" ColdReboot " link Modul 338}
   @{" CopyMem " link Modul 281}                     @{" CopyMemQuick " link Modul 285}                @{" CreateIORequest " link Modul 304}
   @{" CreateMsgPort " link Modul 309}               @{" CreatePool " link Modul 323}                  @{" Deallocate " link Modul 83}
   @{" Debug " link Modul 52}                       @{" DeleteIORequest " link Modul 307}             @{" DeleteMsgPort " link Modul 311}
   @{" DeletePool " link Modul 327}                  @{" Disable " link Modul 56}                     @{" DoIO " link Modul 204}
   @{" Enable " link Modul 58}                      @{" Enqueue " link Modul 121}                     @{" FindName " link Modul 124}
   @{" FindPort " link Modul 175}                    @{" FindResident " link Modul 48}                @{" FindSemaphore " link Modul 262}
   @{" FindTask " link Modul 135}                    @{" Forbid " link Modul 60}                      @{" FreeEntry " link Modul 101}
   @{" FreeMem " link Modul 93}                     @{" FreePooled " link Modul 332}                  @{" FreeSignal " link Modul 154}
   @{" FreeTrap " link Modul 158}                    @{" FreeVec " link Modul 321}                     @{" GetCC " link Modul 229}
   @{" GetMsg " link Modul 169}                      @{" InitCode " link Modul 31}                    @{" InitSemaphore " link Modul 245}
   @{" InitStruct " link Modul 34}                  @{" Insert " link Modul 105}                      @{" MakeFunctions " link Modul 44}
   @{" MakeLibrary " link Modul 38}                 @{" ObtainSemaphore " link Modul 248}             @{" ObtainSemaphoreList " link Modul 258}
   @{" ObtainSemaphoreShared " link Modul 313}       @{" OldOpenLibrary " link Modul 183}              @{" OpenDevice " link Modul 197}
   @{" OpenLibrary " link Modul 239}                 @{" OpenResource " link Modul 220}                @{" Permit " link Modul 62}
   @{" Procure " link Modul 233}                     @{" PutMsg " link Modul 166}                      @{" RawDoFmt " link Modul 224}
   @{" ReleaseSemaphore " link Modul 251}            @{" ReleaseSemaphoreList " link Modul 260}        @{" RemDevice " link Modul 195}
   @{" RemHead " link Modul 119}                     @{" RemIntServer " link Modul 73}                @{" RemLibrary " link Modul 181}
   @{" RemPort " link Modul 164}                     @{" RemResource " link Modul 218}                 @{" RemSemaphore " link Modul 268}
   @{" RemTail " link Modul 117}                     @{" RemTask " link Modul 133}                     @{" Remove " link Modul 115}
   @{" ReplyMsg " link Modul 171}                    @{" SendIO " link Modul 206}                      @{" SetExcept " link Modul 143}
   @{" SetFunction " link Modul 187}                 @{" SetSR " link Modul 64}                       @{" SetSignal " link Modul 140}
   @{" SetTaskPri " link Modul 137}                  @{" Signal " link Modul 148}                      @{" StackSwap " link Modul 340}
   @{" SumKickData " link Modul 273}                 @{" SumLibrary " link Modul 191}                  @{" SuperState " link Modul 66}
   @{" Supervisor " link Modul 29}                  @{" TypeOfMem " link Modul 231}                   @{" UserState " link Modul 68}
   @{" Vacate " link Modul 237}                      @{" Wait " link Modul 146}                        @{" WaitIO " link Modul 210}
   @{" WaitPort " link Modul 173}                 

Variables

   @{" execBase " link Modul 26}                 

@endnode
@node Modul "am2:ModuleRefs/ExecL.def"
(*
**	Cyclone Modula-2 Interface module:
**	$VER: exec_protos.h 39.15 (1.10.93)
**	Includes Release 40.15
**
**	C prototypes. For use with 32 bit integers only.
**
**	(C) Copyright 1990-1993 Commodore-Amiga, Inc.
**	    All Rights Reserved
**
**      Interface module by Marcel Timmermans
**      (C) Copyright 1995-1996 Marcel Timmermans
**      All Rights Reserved
*)

DEFINITION MODULE ExecL {"exec.library",33};

FROM SYSTEM IMPORT ADDRESS, SHORTSET, BITSET, LONGSET, WORD;

IMPORT ExecD,Reg;

(* 
   Automatic variable must be declared when there is a library 
   open code
 *)

VAR 
  execBase : ExecD.ExecBasePtr; (* Automatic filled in when using module *)    

PROCEDURE Supervisor(userFunction{Reg.A5}:PROC); CODE -30;

PROCEDURE InitCode(startClass{Reg.D0}:ExecD.ResidentFlagSet;
                   version{Reg.D1}:LONGINT); CODE -72;

PROCEDURE InitStruct(initTable{Reg.A1}:ADDRESS;
                     memory{Reg.A2}:ADDRESS;
                     size{Reg.D0}:LONGCARD); CODE -78;

PROCEDURE MakeLibrary(vectors{Reg.A0}:ADDRESS;
                      structure{Reg.A1}:ADDRESS;
                      init{Reg.A2}:ADDRESS;
                      dataSize{Reg.D0}:LONGINT;
                      segList{Reg.D1}:ExecD.BPTR):ExecD.LibraryPtr; CODE -84;

PROCEDURE MakeFunctions(target{Reg.A0}:ADDRESS;
                        functArray{Reg.A1}:ADDRESS;
                        functDispBase{Reg.A2}:ADDRESS); CODE -90;

PROCEDURE FindResident(name{Reg.A1}:ADDRESS):ExecD.ResidentPtr; CODE -96;

(*------ diagnostics --------------------------------------------------*)
PROCEDURE Alert(alertNum{7}:LONGINT;parameters{13}:ADDRESS); CODE -108;
PROCEDURE Debug(flags{Reg.D0}:LONGSET); CODE -114;

(*------ interrupts ---------------------------------------------------*)

PROCEDURE Disable(); CODE -120;

PROCEDURE Enable(); CODE -126;

PROCEDURE Forbid(); CODE -132;

PROCEDURE Permit(); CODE -138;

PROCEDURE SetSR(newSR{Reg.D0}:BITSET;mask{Reg.D1}:BITSET):BITSET; CODE -144;

PROCEDURE SuperState():ADDRESS; CODE -150;

PROCEDURE UserState(sysStack{Reg.D0}:ADDRESS); CODE -156;

PROCEDURE AddIntServer(intNum{Reg.D0}: LONGINT;
                       interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -168;

PROCEDURE RemIntServer(intNum{Reg.D0}: LONGINT;
                       interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -174;

PROCEDURE Cause(interrupt{Reg.A1}:ExecD.InterruptPtr); CODE -180;

(*------ memory allocation --------------------------------------------*)

PROCEDURE Allocate(freeList{Reg.A0}:ExecD.MemHeaderPtr;
                   byteSize{Reg.D0}:LONGINT):ADDRESS; CODE -186;

PROCEDURE Deallocate(freeList{Reg.A0}:ExecD.MemHeaderPtr;
                     memoryBlock{Reg.A1}:ADDRESS;
                     byteSize{Reg.D0}:LONGINT); CODE -192;

PROCEDURE AllocMem(byteSize{Reg.D0}:LONGINT;
                   requirements{Reg.D1}:ExecD.MemReqSet):ADDRESS; CODE -198;

PROCEDURE AllocAbs(byteSize{Reg.D0}:LONGINT;
                   location{Reg.A1}:ADDRESS):ADDRESS; CODE -204;

PROCEDURE FreeMem(memoryBlock{Reg.A1}:ADDRESS;
                  byteSize{Reg.D0}:LONGINT); CODE -210;

PROCEDURE AvailMem(requirements{Reg.D1}:ExecD.MemReqSet):LONGINT; CODE -216;

PROCEDURE AllocEntry(
              memList{Reg.A0}:ExecD.MemListPtr):ExecD.MemListPtr; CODE -222;

PROCEDURE FreeEntry(memList{Reg.A0}:ExecD.MemListPtr); CODE -228;

(*------ lists --------------------------------------------------------*)

PROCEDURE Insert(list{Reg.A0}:ExecD.ListPtr;
                 node{Reg.A1}:ADDRESS;
                 listNode{Reg.A2}:ADDRESS); CODE -234;

PROCEDURE AddHead(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -240;

PROCEDURE AddTail(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -246;

PROCEDURE Remove(node{Reg.A1}:ADDRESS); CODE -252;

PROCEDURE RemTail(list{Reg.A0}:ExecD.ListPtr):ADDRESS; CODE -264;

PROCEDURE RemHead(list{Reg.A0}:ExecD.ListPtr):ADDRESS; CODE -258;

PROCEDURE Enqueue(list{Reg.A0}:ExecD.ListPtr;
                  node{Reg.A1}:ADDRESS); CODE -270;

PROCEDURE FindName(start{Reg.A0}:ADDRESS;
                   name{Reg.A1}:ADDRESS):ADDRESS; CODE -276;

(*------ tasks --------------------------------------------------------*)

PROCEDURE AddTask(task{Reg.A1}:ExecD.TaskPtr;
                  initialPC{Reg.A2}:ADDRESS;
                  finalPC{Reg.A3}:ADDRESS); CODE -282;

PROCEDURE RemTask(task{Reg.A1}:ExecD.TaskPtr); CODE -288;

PROCEDURE FindTask(name{Reg.A1}:ADDRESS):ExecD.TaskPtr; CODE -294;

PROCEDURE SetTaskPri(task{Reg.A1}:ExecD.TaskPtr;
                     priority{Reg.D0}:SHORTINT):SHORTINT; CODE -300;

PROCEDURE SetSignal(newSignals{Reg.D0}:LONGSET;
                    signalMask{Reg.D1}:LONGSET):LONGSET; CODE -306;

PROCEDURE SetExcept(newSignals{Reg.D0}:LONGSET;
                    signalMask{Reg.D1}:LONGSET):LONGSET; CODE -312;

PROCEDURE Wait(signalSet{Reg.D0}:LONGSET):LONGSET; CODE -318;

PROCEDURE Signal(task{Reg.A1}:ExecD.TaskPtr;
                 signals{Reg.D0}:LONGSET); CODE -324;

PROCEDURE AllocSignal(
           signalNum{Reg.D0}:LONGINT):LONGINT; CODE -330;

PROCEDURE FreeSignal(signalNum{Reg.D0}:LONGINT); CODE -336;

PROCEDURE AllocTrap(trapNum{Reg.D0}:LONGINT):LONGINT; CODE -342;

PROCEDURE FreeTrap(trapNum{Reg.D0}:LONGINT); CODE -348;

(*------ messages -----------------------------------------------------*)

PROCEDURE AddPort(port{Reg.A1}:ExecD.MsgPortPtr); CODE -354;

PROCEDURE RemPort(port{Reg.A1}:ExecD.MsgPortPtr); CODE -360;

PROCEDURE PutMsg(port{Reg.A0}:ExecD.MsgPortPtr;
                 message{Reg.A1}:ADDRESS); CODE -366;

PROCEDURE GetMsg(port{Reg.A0}:ExecD.MsgPortPtr):ADDRESS; CODE -372;

PROCEDURE ReplyMsg(message{Reg.A1}:ADDRESS); CODE -378;

PROCEDURE WaitPort(port{Reg.A0}:ExecD.MsgPortPtr); CODE -384;

PROCEDURE FindPort(name{Reg.A1}:ADDRESS):ExecD.MsgPortPtr; CODE -390;

(*------ libraries ----------------------------------------------------*)

PROCEDURE AddLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -396;

PROCEDURE RemLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -402;

PROCEDURE OldOpenLibrary(libName{Reg.A1}:ADDRESS):ExecD.LibraryPtr; CODE -408;

PROCEDURE CloseLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -414;

PROCEDURE SetFunction(library{Reg.A1}:ExecD.LibraryPtr;
                      funcOffset{Reg.A0}:INTEGER;
                      funcEntry{Reg.D0}:ADDRESS):ADDRESS; CODE -420;

PROCEDURE SumLibrary(library{Reg.A1}:ExecD.LibraryPtr); CODE -426;

PROCEDURE AddDevice(device{Reg.A1}:ExecD.DevicePtr); CODE -432;

PROCEDURE RemDevice(device{Reg.A1}:ExecD.DevicePtr); CODE -438;

PROCEDURE OpenDevice(devName{Reg.A0}:ADDRESS;
                     unitNumber{Reg.D0}:LONGINT;
                     ioRequest{Reg.A1}:ADDRESS;
                     flags{Reg.D1}:LONGSET); CODE -444;

PROCEDURE CloseDevice(ioRequest{Reg.A1}:ADDRESS); CODE -450;

PROCEDURE DoIO(ioRequest{Reg.A1}:ADDRESS); CODE -456;

PROCEDURE SendIO(ioRequest{Reg.A1}:ADDRESS); CODE -462;

PROCEDURE CheckIO(ioRequest{Reg.A1}:ADDRESS):BOOLEAN; CODE -468;

PROCEDURE WaitIO(ioRequest{Reg.A1}:ADDRESS); CODE -474;

PROCEDURE AbortIO(ioRequest{Reg.A1}:ADDRESS); CODE -480;

(*------ resources ----------------------------------------------------*)

PROCEDURE AddResource(resource{Reg.A1}:ADDRESS); CODE -486;

PROCEDURE RemResource(resource{Reg.A1}:ADDRESS); CODE -492;

PROCEDURE OpenResource(resName{Reg.A1}:ADDRESS):ADDRESS; CODE -498;

(*------ private diagnostic support -----------------------------------*)
(*------ misc ---------------------------------------------------------*)
PROCEDURE RawDoFmt(formatString{Reg.A0}:ADDRESS;
                   dataStream{Reg.A1}:ADDRESS;
                   putChProc{Reg.A2}:ADDRESS;
                   putChData{Reg.A3}:ADDRESS); CODE -522;

PROCEDURE GetCC():BITSET; CODE -528;

PROCEDURE TypeOfMem(address{Reg.A1}:ADDRESS):ExecD.MemReqSet; CODE -534;

PROCEDURE Procure(
           semaphore{Reg.A0}:ExecD.SemaphorePtr;
           bidMessage{Reg.A1}:ExecD.MessagePtr):LONGINT; CODE -540;

PROCEDURE Vacate(semaphore{Reg.A0}:ExecD.SemaphorePtr); CODE -546;

PROCEDURE OpenLibrary(libName{Reg.A1}:ADDRESS;
                      version{Reg.D0}:LONGINT):ExecD.LibraryPtr; CODE -552;

(*--- functions in V33 or higher (distributed as Release 1.2) ---*)
(*------ signal semaphores (note funny registers)----------------------*)

PROCEDURE InitSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -558;

PROCEDURE ObtainSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -564;

PROCEDURE ReleaseSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -570;

PROCEDURE AttemptSemaphore(
           signalSemaphore{Reg.A0}:ExecD.SignalSemaphorePtr
          ):BOOLEAN; CODE -576;

PROCEDURE ObtainSemaphoreList(list{Reg.A0}:ExecD.ListPtr); CODE -582;

PROCEDURE ReleaseSemaphoreList(list{Reg.A0}:ExecD.ListPtr); CODE -588;

PROCEDURE FindSemaphore(
            name{Reg.A1}:ADDRESS):ExecD.SignalSemaphorePtr; CODE -594;

PROCEDURE AddSemaphore(
            signalSemaphore{Reg.A1}:ExecD.SignalSemaphorePtr); CODE -600;

PROCEDURE RemSemaphore(
            signalSemaphore{Reg.A1}:ExecD.SignalSemaphorePtr); CODE -606;

(*------ kickmem support ----------------------------------------------*)

PROCEDURE SumKickData():LONGCARD; CODE -612;

PROCEDURE AddMemList(size{Reg.D0}:LONGINT;
                     attributes{Reg.D1}:ExecD.MemReqSet;
                     pri{Reg.D2}:LONGINT;
                     base{Reg.A0}:ADDRESS;
                     name{Reg.A1}:ADDRESS):LONGINT; CODE -618;

PROCEDURE CopyMem(source{Reg.A0}:ADDRESS;
                  dest{Reg.A1}:ADDRESS;
                  size{Reg.D0}:LONGINT); CODE -624;

PROCEDURE CopyMemQuick(source{Reg.A0}:ADDRESS;
                       dest{Reg.A1}:ADDRESS;
                       size{Reg.D0}:LONGINT); CODE -630;

(*------ cache --------------------------------------------------------*)
(*--- functions in V36 or higher (distributed as Release 2.0) ---*)

PROCEDURE CacheClearU; CODE -636;

PROCEDURE CacheClearE(address{Reg.A0}:ADDRESS;
                      length{Reg.D0}:LONGCARD;
                      caches{Reg.D1}:ExecD.CacheFlagSet); CODE -642;

PROCEDURE CacheControl(cacheBits{Reg.D0},
                       cacheMask{Reg.D1}:ExecD.CacheFlagSet
                       ):ExecD.CacheFlagSet; CODE -648;

(*------ misc ---------------------------------------------------------*)

PROCEDURE CreateIORequest(replyPort{Reg.A0}:ExecD.MsgPortPtr;
                          size{Reg.D0}:LONGINT):ADDRESS ; CODE -654;

PROCEDURE DeleteIORequest(iorequest{Reg.A0}:ADDRESS); CODE -660;

PROCEDURE CreateMsgPort():ExecD.MsgPortPtr; CODE -666;

PROCEDURE DeleteMsgPort(port{Reg.A0}:ExecD.MsgPortPtr); CODE -672;

PROCEDURE ObtainSemaphoreShared(
            sigSem{Reg.A0}:ExecD.SignalSemaphorePtr); CODE -678;

(*------ even more memory support -------------------------------------*)

PROCEDURE AllocVec(byteSize{Reg.D0}:LONGINT;
                   requirements{Reg.D1}:ExecD.MemReqSet):ADDRESS; CODE -684;

PROCEDURE FreeVec(memoryBlock{Reg.A1}:ADDRESS); CODE -690;

PROCEDURE CreatePool(requirements{Reg.D0}: ExecD.MemReqSet;
             puddleSize{Reg.D1} : LONGINT;
             puddleThresh{Reg.D2}: LONGINT): ADDRESS; CODE -696;

PROCEDURE DeletePool(poolHeader{Reg.A0}: ADDRESS); CODE -702;

PROCEDURE AllocPooled(poolHeader{Reg.A0}:ADDRESS;
                      memSize{Reg.D0}:LONGINT):ADDRESS; CODE -708;

PROCEDURE FreePooled(poolHeader{Reg.A0}:ADDRESS;
                     memory{Reg.A1}:ADDRESS;
                     memSize{Reg.D0}:LONGINT); CODE -714;

(*------ misc ---------------------------------------------------------*)

PROCEDURE ColdReboot; CODE -726;

PROCEDURE StackSwap(VAR newStack{Reg.A0}:ExecD.StackSwapStruct); CODE -732;

(*------ task trees ---------------------------------------------------*)

PROCEDURE ChildFree(tid{0}:ADDRESS); CODE -738;
PROCEDURE ChildOrphan(tid{0}:ADDRESS); CODE-744;
PROCEDURE ChildStatus(tid{0}:ADDRESS); CODE -750;
PROCEDURE ChildWait(tid{0}:ADDRESS); CODE -756;

(* ------ future expansion ---------------------------------------------*)

PROCEDURE CachePreDMA(vaddress{Reg.A0}:ADDRESS;
                      VAR length{Reg.A1}:LONGINT;
                      flags{Reg.D1}:LONGCARD):ADDRESS; CODE -762;

PROCEDURE CachePostDMA(vaddress{Reg.A0}:ADDRESS;
                       VAR length{Reg.A1}:LONGINT;
                       flags{Reg.D1}:LONGCARD); CODE -768;

END ExecL.

@endnode
