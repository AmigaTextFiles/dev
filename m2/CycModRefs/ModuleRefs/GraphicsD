@database GraphicsD
@node Main "GraphicsD"

Constants

   @{" a2024MonitorID " link Modul 1051}              @{" a2024fifteenhertzKey " link Modul 1054}        @{" a2024tenhertzKey " link Modul 1053}
   @{" anfracsize " link Modul 468}                  @{" animhalf " link Modul 469}                    @{" avoidFlicker " link Modul 194}
   @{" b2Bobber " link Modul 604}                    @{" b2Norm " link Modul 601}                      @{" b2Swap " link Modul 603}
   @{" bandwidth1x " link Modul 806}                 @{" bandwidth2xdbl " link Modul 808}              @{" bandwidth2xnml " link Modul 807}
   @{" bandwidth4x " link Modul 809}                 @{" bidtagBlueBits " link Modul 1194}              @{" bidtagDIPFMustHave " link Modul 1172}
   @{" bidtagDIPFMustNotHave " link Modul 1174}       @{" bidtagDepth " link Modul 1187}                 @{" bidtagDesiredHeight " link Modul 1185}
   @{" bidtagDesiredWidth " link Modul 1184}          @{" bidtagGreenBits " link Modul 1195}             @{" bidtagMonitorID " link Modul 1189}
   @{" bidtagNominalHeight " link Modul 1179}         @{" bidtagNominalWidth " link Modul 1178}          @{" bidtagRedBits " link Modul 1193}
   @{" bidtagSourceID " link Modul 1191}              @{" bidtagViewPort " link Modul 1176}              @{" bigBlits " link Modul 790}
   @{" bitClr " link Modul 87}                      @{" bitSet " link Modul 85}                      @{" blitMsgFault " link Modul 793}
   @{" bmClear " link Modul 114}                     @{" bmDisplayable " link Modul 116}               @{" bmInterleaved " link Modul 117}
   @{" bmMinplanes " link Modul 119}                 @{" bmStandard " link Modul 118}                  @{" bmaDepth " link Modul 123}
   @{" bmaFlags " link Modul 125}                    @{" bmaHeight " link Modul 122}                   @{" bmaWidth " link Modul 124}
   @{" borderHit " link Modul 206}                   @{" bottomHit " link Modul 216}                   @{" broadcastBeamcon " link Modul 754}
   @{" broadcastHbstop " link Modul 749}             @{" broadcastHbstrt " link Modul 746}             @{" broadcastHsstop " link Modul 748}
   @{" broadcastHsstrt " link Modul 747}             @{" broadcastVbstop " link Modul 753}             @{" broadcastVbstrt " link Modul 750}
   @{" broadcastVsstop " link Modul 752}             @{" broadcastVsstrt " link Modul 751}             @{" bus16 " link Modul 802}
   @{" bus32 " link Modul 804}                       @{" buserFlags " link Modul 465}                  @{" colorMask " link Modul 1286}
   @{" colorOn " link Modul 299}                     @{" complement " link Modul 1394}                  @{" copperMove " link Modul 221}
   @{" copperWait " link Modul 223}                  @{" cprNtLof " link Modul 225}                    @{" cprNtSht " link Modul 226}
   @{" cprNtSys " link Modul 227}                    @{" cprNxtBuf " link Modul 224}                   @{" dblCas " link Modul 805}
   @{" dblntscMonitorID " link Modul 1111}            @{" dblntschiresKey " link Modul 1126}             @{" dblntschiresdpf2Key " link Modul 1137}
   @{" dblntschiresdpf2laceKey " link Modul 1138}     @{" dblntschiresdpfKey " link Modul 1135}          @{" dblntschiresdpflaceKey " link Modul 1136}
   @{" dblntschiresehbKey " link Modul 1132}          @{" dblntschiresehbffKey " link Modul 1133}        @{" dblntschiresehblaceKey " link Modul 1134}
   @{" dblntschiresffKey " link Modul 1127}           @{" dblntschireshamKey " link Modul 1128}          @{" dblntschireshamffKey " link Modul 1129}
   @{" dblntschireshamlaceKey " link Modul 1131}      @{" dblntschireslaceKey " link Modul 1130}         @{" dblntscloresKey " link Modul 1113}
   @{" dblntscloresdpf2Key " link Modul 1124}         @{" dblntscloresdpf2laceKey " link Modul 1125}     @{" dblntscloresdpfKey " link Modul 1122}
   @{" dblntscloresdpflaceKey " link Modul 1123}      @{" dblntscloresehbKey " link Modul 1117}          @{" dblntscloresehbffKey " link Modul 1118}
   @{" dblntscloresehblaceKey " link Modul 1121}      @{" dblntscloresffKey " link Modul 1114}           @{" dblntscloreshamKey " link Modul 1115}
   @{" dblntscloreshamffKey " link Modul 1116}        @{" dblntscloreshamlaceKey " link Modul 1120}      @{" dblntscloreslaceKey " link Modul 1119}
   @{" dblpalMonitorID " link Modul 1140}             @{" dblpalhiresKey " link Modul 1155}              @{" dblpalhiresdpf2Key " link Modul 1166}
   @{" dblpalhiresdpf2laceKey " link Modul 1167}      @{" dblpalhiresdpfKey " link Modul 1164}           @{" dblpalhiresdpflaceKey " link Modul 1165}
   @{" dblpalhiresehbKey " link Modul 1161}           @{" dblpalhiresehbffKey " link Modul 1162}         @{" dblpalhiresehblaceKey " link Modul 1163}
   @{" dblpalhiresffKey " link Modul 1156}            @{" dblpalhireshamKey " link Modul 1157}           @{" dblpalhireshamffKey " link Modul 1158}
   @{" dblpalhireshamlaceKey " link Modul 1160}       @{" dblpalhireslaceKey " link Modul 1159}          @{" dblpalloresKey " link Modul 1142}
   @{" dblpalloresdpf2Key " link Modul 1153}          @{" dblpalloresdpf2laceKey " link Modul 1154}      @{" dblpalloresdpfKey " link Modul 1151}
   @{" dblpalloresdpflaceKey " link Modul 1152}       @{" dblpalloresehbKey " link Modul 1146}           @{" dblpalloresehbffKey " link Modul 1147}
   @{" dblpalloresehblaceKey " link Modul 1150}       @{" dblpalloresffKey " link Modul 1143}            @{" dblpalloreshamKey " link Modul 1144}
   @{" dblpalloreshamffKey " link Modul 1145}         @{" dblpalloreshamlaceKey " link Modul 1149}       @{" dblpalloreslaceKey " link Modul 1148}
   @{" dblpf " link Modul 300}                       @{" defaultMonitorID " link Modul 964}            @{" defaultMonitorName " link Modul 678}
   @{" dftchMask " link Modul 315}                   @{" displayNameLen " link Modul 421}              @{" diwhorizPos " link Modul 310}
   @{" diwvrtclPos " link Modul 311}                 @{" diwvrtclPosShift " link Modul 312}            @{" dtagDims " link Modul 328}
   @{" dtagDisp " link Modul 325}                    @{" dtagMntr " link Modul 329}                    @{" dtagName " link Modul 330}
   @{" dtagVec " link Modul 331}                     @{" euro36MonitorID " link Modul 1100}             @{" euro72MonitorID " link Modul 1062}
   @{" euro72ehbKey " link Modul 1097}                @{" euro72ehblaceKey " link Modul 1098}            @{" euro72extrahalfbriteKey " link Modul 1084}
   @{" euro72extrahalfbritelaceKey " link Modul 1085}   @{" euro72extraloresKey " link Modul 1064}         @{" euro72extraloresdpf2Key " link Modul 1078}
   @{" euro72extraloresdpfKey " link Modul 1072}      @{" euro72extraloresehbKey " link Modul 1093}      @{" euro72extraloresehblaceKey " link Modul 1094}
   @{" euro72extraloreshamKey " link Modul 1091}      @{" euro72extraloreshamlaceKey " link Modul 1092}   @{" euro72extraloreslaceKey " link Modul 1068}
   @{" euro72extraloreslacedpf2Key " link Modul 1081}   @{" euro72extraloreslacedpfKey " link Modul 1075}   @{" euro72hamKey " link Modul 1067}
   @{" euro72hamlaceKey " link Modul 1071}            @{" euro72loresKey " link Modul 1065}              @{" euro72loresdpf2Key " link Modul 1079}
   @{" euro72loresdpfKey " link Modul 1073}           @{" euro72loresehbKey " link Modul 1095}           @{" euro72loresehblaceKey " link Modul 1096}
   @{" euro72loreshamKey " link Modul 1089}           @{" euro72loreshamlaceKey " link Modul 1090}       @{" euro72loreslaceKey " link Modul 1069}
   @{" euro72loreslacedpf2Key " link Modul 1082}      @{" euro72loreslacedpfKey " link Modul 1076}       @{" euro72productKey " link Modul 1066}
   @{" euro72productdpf2Key " link Modul 1080}        @{" euro72productdpfKey " link Modul 1074}         @{" euro72producthamKey " link Modul 1087}
   @{" euro72producthamlaceKey " link Modul 1088}     @{" euro72productlaceKey " link Modul 1070}        @{" euro72productlacedpf2Key " link Modul 1083}
   @{" euro72productlacedpfKey " link Modul 1077}     @{" extendVStruct " link Modul 1614}               @{" extrahalfbriteKey " link Modul 996}
   @{" extrahalfbritelaceKey " link Modul 997}       @{" fromMonitor " link Modul 667}                 @{" graphicsName " link Modul 811}
   @{" gstagAttached " link Modul 1473}               @{" gstagScanDoubled " link Modul 1477}            @{" gstagSoftSprite " link Modul 1474}
   @{" gstagSpriteNum " link Modul 1472}              @{" hamKey " link Modul 979}                      @{" hamlaceKey " link Modul 983}
   @{" hiresKey " link Modul 977}                    @{" hiresdpf2Key " link Modul 991}                @{" hiresdpfKey " link Modul 985}
   @{" hiresehbKey " link Modul 1002}                 @{" hiresehblaceKey " link Modul 1006}             @{" hireshamKey " link Modul 1000}
   @{" hireshamlaceKey " link Modul 1004}             @{" hireslaceKey " link Modul 981}                @{" hireslacedpf2Key " link Modul 994}
   @{" hireslacedpfKey " link Modul 988}             @{" holdnmodify " link Modul 301}                 @{" interlace " link Modul 302}
   @{" invalidID " link Modul 958}                   @{" inversvid " link Modul 1395}                   @{" isGrtrX " link Modul 179}
   @{" isGrtrY " link Modul 180}                     @{" isLessX " link Modul 177}                     @{" isLessY " link Modul 178}
   @{" jam1 " link Modul 1391}                        @{" jam2 " link Modul 1393}                        @{" layersBackFill " link Modul 955}
   @{" layersNoBackFill " link Modul 954}            @{" leftHit " link Modul 217}                     @{" loresKey " link Modul 976}
   @{" loresdpf2Key " link Modul 990}                @{" loresdpfKey " link Modul 984}                 @{" loreslaceKey " link Modul 980}
   @{" loreslacedpf2Key " link Modul 993}            @{" loreslacedpfKey " link Modul 987}             @{" m640 " link Modul 293}
   @{" mapColor " link Modul 1284}                    @{" maxFontMatchWeight " link Modul 1237}          @{" mcompatMixed " link Modul 415}
   @{" mcompatNobody " link Modul 419}               @{" mcompatSelf " link Modul 418}                 @{" mcopNoMem " link Modul 1711}
   @{" mcopNop " link Modul 1714}                     @{" mcopOk " link Modul 1710}                      @{" minNtscRow " link Modul 695}
   @{" minPalRow " link Modul 696}                   @{" minVga70Row " link Modul 732}                 @{" minVgaRow " link Modul 713}
   @{" monitorIDmask " link Modul 962}               @{" monitorSpecType " link Modul 632}             @{" msDoubleSprites " link Modul 676}
   @{" msRequestA2024 " link Modul 675}              @{" msRequestNtsc " link Modul 672}               @{" msRequestPal " link Modul 673}
   @{" msRequestSpecial " link Modul 674}            @{" mvpNoDisplay " link Modul 1703}                @{" mvpNoDspIns " link Modul 1700}
   @{" mvpNoMem " link Modul 1696}                    @{" mvpNoVpe " link Modul 1697}                    @{" mvpOk " link Modul 1695}
   @{" needsNoConcealedRasters " link Modul 171}     @{" needsNoLayerblitDamage " link Modul 174}      @{" newLayerInfoCalled " link Modul 948}
   @{" nmlCas " link Modul 803}                      @{" noRemFont " link Modul 1259}                   @{" normalFont " link Modul 1207}
   @{" ntscMonitorID " link Modul 965}               @{" ntscMonitorName " link Modul 679}             @{" opbFailIfBad " link Modul 1689}
   @{" opbPrecision " link Modul 1688}                @{" palMonitorID " link Modul 966}                @{" palMonitorName " link Modul 680}
   @{" penExclusive " link Modul 1676}                @{" penNoSetColor " link Modul 1679}               @{" pf2pri " link Modul 298}
   @{" pfafineScroll " link Modul 305}               @{" pfbfineScrollShift " link Modul 306}          @{" pffineScrollMask " link Modul 307}
   @{" plnCntMsk " link Modul 295}                   @{" plnCntShft " link Modul 297}                  @{" precisionExact " link Modul 1682}
   @{" precisionGui " link Modul 1685}                @{" precisionIcon " link Modul 1684}               @{" precisionImage " link Modul 1683}
   @{" preserveColors " link Modul 183}              @{" protoMonitorID " link Modul 1058}              @{" ratioFixedpart " link Modul 755}
   @{" rightHit " link Modul 218}                    @{" ringtrigger " link Modul 470}                 @{" rptagAPen " link Modul 1418}
   @{" rptagBPen " link Modul 1419}                   @{" rptagDrMd " link Modul 1420}                   @{" rptagDrawBounds " link Modul 1425}
   @{" rptagFont " link Modul 1415}                   @{" rptagMaxPen " link Modul 1423}                 @{" rptagOutLinePen " link Modul 1421}
   @{" rptagWriteMask " link Modul 1422}              @{" setchiprevA " link Modul 796}                 @{" setchiprevAA " link Modul 798}
   @{" setchiprevBest " link Modul 799}              @{" setchiprevECS " link Modul 797}               @{" specialBeamcon " link Modul 692}
   @{" specialFlags " link Modul 1170}                @{" specialMonitorType " link Modul 631}          @{" spriteAttached " link Modul 1445}
   @{" spriteaAttached " link Modul 1468}             @{" spriteaOldDataFormat " link Modul 1469}        @{" spriteaOutputHeight " link Modul 1467}
   @{" spriteaWidth " link Modul 1462}                @{" spriteaXReplication " link Modul 1465}         @{" spriteaYReplication " link Modul 1466}
   @{" ssGraphics " link Modul 626}                  @{" standardColorclocks " link Modul 686}         @{" standardDeniseMax " link Modul 687}
   @{" standardDeniseMin " link Modul 688}           @{" standardHbstop " link Modul 703}              @{" standardHbstrt " link Modul 700}
   @{" standardHsstop " link Modul 702}              @{" standardHsstrt " link Modul 701}              @{" standardMonitorMask " link Modul 682}
   @{" standardNtscBeamcon " link Modul 689}         @{" standardNtscRows " link Modul 684}            @{" standardPalBeamcon " link Modul 690}
   @{" standardPalRows " link Modul 685}             @{" standardVbstop " link Modul 707}              @{" standardVbstrt " link Modul 704}
   @{" standardViewX " link Modul 698}               @{" standardViewY " link Modul 699}               @{" standardVsstop " link Modul 706}
   @{" standardVsstrt " link Modul 705}              @{" standardXoffset " link Modul 669}             @{" standardYoffset " link Modul 670}
   @{" super72MonitorID " link Modul 1106}            @{" superKey " link Modul 978}                    @{" superdpf2Key " link Modul 992}
   @{" superdpfKey " link Modul 986}                 @{" superehbKey " link Modul 1003}                 @{" superehblaceKey " link Modul 1007}
   @{" superhamKey " link Modul 1001}                 @{" superhamlaceKey " link Modul 1005}             @{" superlaceKey " link Modul 982}
   @{" superlacedpf2Key " link Modul 995}            @{" superlacedpfKey " link Modul 989}             @{" suserFlags " link Modul 463}
   @{" taDeviceDPI " link Modul 1234}                 @{" toMonitor " link Modul 665}                   @{" topHit " link Modul 215}
   @{" vga70Beamcon " link Modul 742}                @{" vga70Colorclocks " link Modul 729}            @{" vga70DeniseMin " link Modul 731}
   @{" vga70Hbstop " link Modul 736}                 @{" vga70Hbstrt " link Modul 733}                 @{" vga70Hsstop " link Modul 735}
   @{" vga70Hsstrt " link Modul 734}                 @{" vga70MonitorName " link Modul 744}            @{" vga70TotalRows " link Modul 730}
   @{" vga70Vbstop " link Modul 740}                 @{" vga70Vbstrt " link Modul 737}                 @{" vga70Vsstop " link Modul 739}
   @{" vga70Vsstrt " link Modul 738}                 @{" vgaColorclocks " link Modul 709}              @{" vgaDeniseMin " link Modul 711}
   @{" vgaHbstop " link Modul 718}                   @{" vgaHbstrt " link Modul 715}                   @{" vgaHsstop " link Modul 717}
   @{" vgaHsstrt " link Modul 716}                   @{" vgaMonitorID " link Modul 1011}                @{" vgaMonitorName " link Modul 724}
   @{" vgaTotalRows " link Modul 710}                @{" vgaVbstop " link Modul 722}                   @{" vgaVbstrt " link Modul 719}
   @{" vgaVsstop " link Modul 721}                   @{" vgaVsstrt " link Modul 720}                   @{" vgaehbKey " link Modul 1046}
   @{" vgaehblaceKey " link Modul 1047}               @{" vgaextrahalfbriteKey " link Modul 1033}        @{" vgaextrahalfbritelaceKey " link Modul 1034}
   @{" vgaextraloresKey " link Modul 1013}            @{" vgaextraloresdpf2Key " link Modul 1027}        @{" vgaextraloresdpfKey " link Modul 1021}
   @{" vgaextraloresehbKey " link Modul 1042}         @{" vgaextraloresehblaceKey " link Modul 1043}     @{" vgaextraloreshamKey " link Modul 1037}
   @{" vgaextraloreshamlaceKey " link Modul 1040}     @{" vgaextraloreslaceKey " link Modul 1017}        @{" vgaextraloreslacedpf2Key " link Modul 1030}
   @{" vgaextraloreslacedpfKey " link Modul 1024}     @{" vgahamKey " link Modul 1016}                   @{" vgahamlaceKey " link Modul 1020}
   @{" vgaloresKey " link Modul 1014}                 @{" vgaloresdpf2Key " link Modul 1028}             @{" vgaloresdpfKey " link Modul 1022}
   @{" vgaloresehbKey " link Modul 1044}              @{" vgaloresehblaceKey " link Modul 1045}          @{" vgaloreshamKey " link Modul 1036}
   @{" vgaloreshamlaceKey " link Modul 1039}          @{" vgaloreslaceKey " link Modul 1018}             @{" vgaloreslacedpf2Key " link Modul 1031}
   @{" vgaloreslacedpfKey " link Modul 1025}          @{" vgaproductKey " link Modul 1015}               @{" vgaproductdpf2Key " link Modul 1029}
   @{" vgaproductdpfKey " link Modul 1023}            @{" vgaproducthamKey " link Modul 1035}            @{" vgaproducthamlaceKey " link Modul 1038}
   @{" vgaproductlaceKey " link Modul 1019}           @{" vgaproductlacedpf2Key " link Modul 1032}       @{" vgaproductlacedpfKey " link Modul 1026}
   @{" viewExtraType " link Modul 629}               @{" viewportExtraType " link Modul 630}           @{" vpbA2024 " link Modul 1618}
   @{" vpbTenhz " link Modul 1619}                    @{" vpfA2024 " link Modul 1616}                    @{" vpfTenhz " link Modul 1617}
   @{" vposrlof " link Modul 318}                    @{" vpxbFreeMe " link Modul 1608}                  @{" vpxbLast " link Modul 1610}
   @{" vpxbStraddles256 " link Modul 1611}            @{" vpxbStraddles512 " link Modul 1612}            @{" vtagEndCm " link Modul 1480}


Type-Declarations

   @{" AnalogSignalInterval " link Modul 758}        @{" AnalogSignalIntervalPtr " link Modul 29}     @{" AnimComp " link Modul 554}
   @{" AnimCompPtr " link Modul 31}                 @{" AnimOb " link Modul 579}                      @{" AnimObPtr " link Modul 32}
   @{" AreaInfo " link Modul 1318}                    @{" AreaInfoPtr " link Modul 33}                 @{" AvailabilityFlagSet " link Modul 347}
   @{" AvailabilityFlags " link Modul 343}           @{" BitMap " link Modul 104}                      @{" BitMapPtr " link Modul 34}
   @{" BitScaleArgs " link Modul 1428}                @{" BitScaleArgsPtr " link Modul 35}             @{" Bob " link Modul 537}
   @{" BobFlagSet " link Modul 461}                  @{" BobFlags " link Modul 457}                    @{" BobPtr " link Modul 36}
   @{" ChipRevSet " link Modul 788}                  @{" ChipRevs " link Modul 787}                    @{" ClipRect " link Modul 158}
   @{" ClipRectPtr " link Modul 37}                 @{" CollTable " link Modul 606}                   @{" CollTablePtr " link Modul 38}
   @{" ColorFontColors " link Modul 1289}             @{" ColorFontColorsPtr " link Modul 39}          @{" ColorMap " link Modul 1638}
   @{" ColorMapFlagSet " link Modul 1636}             @{" ColorMapFlags " link Modul 1632}               @{" ColorMapPtr " link Modul 40}
   @{" ColorMapType " link Modul 1630}                @{" ColorTextFont " link Modul 1297}               @{" ColorTextFontFlagSet " link Modul 1282}
   @{" ColorTextFontFlags " link Modul 1278}          @{" ColorTextFontPtr " link Modul 41}            @{" CopIns " link Modul 229}
   @{" CopInsPtr " link Modul 43}                   @{" CopList " link Modul 250}                     @{" CopListPtr " link Modul 44}
   @{" Copinit " link Modul 277}                     @{" CopinitPtr " link Modul 42}                  @{" Cprlist " link Modul 244}
   @{" CprlistPtr " link Modul 45}                  @{" DBufInfo " link Modul 1719}                    @{" DBufInfoPtr " link Modul 46}
   @{" DBufPacket " link Modul 592}                  @{" DBufPacketPtr " link Modul 47}               @{" DimensionInfo " link Modul 383}
   @{" DimensionInfoPtr " link Modul 48}            @{" DisplayFlagSet " link Modul 783}              @{" DisplayFlags " link Modul 778}
   @{" DisplayInfo " link Modul 366}                 @{" DisplayInfoHandle " link Modul 322}           @{" DisplayInfoPtr " link Modul 49}
   @{" DrawModeSet " link Modul 1349}                 @{" DrawModes " link Modul 1348}                   @{" ExtSprite " link Modul 1456}
   @{" ExtSpritePtr " link Modul 51}                @{" ExtendedNode " link Modul 613}                @{" ExtendedNodePtr " link Modul 50}
   @{" FontFlagSet " link Modul 1215}                 @{" FontFlags " link Modul 1210}                   @{" FontStyleSet " link Modul 1205}
   @{" FontStyles " link Modul 1199}                  @{" GelsInfo " link Modul 1335}                    @{" GelsInfoPtr " link Modul 52}
   @{" GfxBase " link Modul 813}                     @{" GfxBasePtr " link Modul 53}                  @{" Isrvstr " link Modul 910}
   @{" IsrvstrPtr " link Modul 54}                  @{" Layer " link Modul 128}                       @{" LayerFlagSet " link Modul 927}
   @{" LayerFlags " link Modul 920}                  @{" LayerInfo " link Modul 929}                   @{" LayerInfoPtr " link Modul 56}
   @{" LayerPtr " link Modul 55}                    @{" MonitorInfo " link Modul 399}                 @{" MonitorInfoPtr " link Modul 57}
   @{" MonitorSpec " link Modul 635}                 @{" MonitorSpecPtr " link Modul 58}              @{" NameInfo " link Modul 423}
   @{" NameInfoPtr " link Modul 59}                 @{" PaletteExtra " link Modul 1664}                @{" PaletteExtraPtr " link Modul 60}
   @{" Point " link Modul 100}                       @{" PointPtr " link Modul 61}                    @{" PropertyFlagSet " link Modul 364}
   @{" PropertyFlags " link Modul 350}               @{" QueryHeader " link Modul 334}                 @{" QueryHeaderPtr " link Modul 62}
   @{" RasInfo " link Modul 1623}                     @{" RasInfoPtr " link Modul 63}                  @{" RastPort " link Modul 1357}
   @{" RastPortFlagSet " link Modul 1355}             @{" RastPortFlags " link Modul 1352}               @{" RastPortPtr " link Modul 64}
   @{" Rect32 " link Modul 95}                      @{" Rect32Ptr " link Modul 65}                   @{" Rectangle " link Modul 89}
   @{" RectanglePtr " link Modul 66}                @{" Region " link Modul 1409}                      @{" RegionPtr " link Modul 67}
   @{" RegionRectangle " link Modul 1403}             @{" RegionRectanglePtr " link Modul 68}          @{" SimpleSprite " link Modul 1448}
   @{" SimpleSpritePtr " link Modul 69}             @{" SpecialMonitor " link Modul 764}              @{" SpecialMonitorPtr " link Modul 70}
   @{" TTextAttr " link Modul 1225}                   @{" TTextAttrPtr " link Modul 76}                @{" TextAttr " link Modul 1218}
   @{" TextAttrPtr " link Modul 71}                 @{" TextExtent " link Modul 1311}                  @{" TextExtentPtr " link Modul 72}
   @{" TextFont " link Modul 1240}                    @{" TextFontExtension " link Modul 1262}           @{" TextFontExtensionPtr " link Modul 73}
   @{" TextFontPtr " link Modul 74}                 @{" TmpRas " link Modul 1329}                      @{" TmpRasPtr " link Modul 75}
   @{" UCopList " link Modul 268}                    @{" UCopListPtr " link Modul 77}                 @{" VSprite " link Modul 474}
   @{" VSpriteFlagSet " link Modul 453}              @{" VSpriteFlags " link Modul 446}                @{" VSpritePtr " link Modul 82}
   @{" VTags " link Modul 1483}                       @{" VecInfo " link Modul 436}                     @{" View " link Modul 1576}
   @{" ViewExtra " link Modul 1586}                   @{" ViewExtraPtr " link Modul 78}                @{" ViewModeSet " link Modul 1559}
   @{" ViewModes " link Modul 1551}                   @{" ViewPort " link Modul 1561}                    @{" ViewPortExtra " link Modul 1595}
   @{" ViewPortExtraPtr " link Modul 80}            @{" ViewPortPtr " link Modul 81}                 @{" ViewPtr " link Modul 79}


@endnode
@node Modul "am2:ModuleRefs/GraphicsD.def"
(**************************************************************************)
(*                                                                        *)
(* Definition Module (C) Copyright 1994 Marcel Timmermans.                *)
(* Date     : 06 Feb 1994                                                 *)
(* Language : Modula-2                                                    *)
(*                                                                        *)
(**************************************************************************)

(*$ IMPLEMENTATION- *)
DEFINITION MODULE GraphicsD;

FROM SYSTEM IMPORT 
 ADDRESS, SHIFT, BYTE, WORD, SHORTSET, BITSET, LONGSET;

FROM ExecD IMPORT  
 Node,NodeType,NodePtr,TaskPtr,Interrupt,Message,List,MinList,Library,
 MsgPortPtr,SignalSemaphore,SignalSemaphorePtr;

FROM UtilityD IMPORT
 TagItemPtr,tagUser,HookPtr;

FROM Hardware IMPORT
 BeamConFlags,BeamConFlagSet,BltnodePtr;

(*
 * All pointers are listed here (sorted), because many records have 
 * references to all kind of pointers.
 *)

TYPE
 AnalogSignalIntervalPtr      = POINTER TO AnalogSignalInterval;
 AnimCompPtr                  = POINTER TO AnimComp;
 AnimObPtr                    = POINTER TO AnimOb;
 AreaInfoPtr                  = POINTER TO AreaInfo;
 BitMapPtr                    = POINTER TO BitMap;
 BitScaleArgsPtr              = POINTER TO BitScaleArgs;
 BobPtr                       = POINTER TO Bob;
 ClipRectPtr                  = POINTER TO ClipRect;
 CollTablePtr                 = POINTER TO CollTable;
 ColorFontColorsPtr           = POINTER TO ColorFontColors;
 ColorMapPtr                  = POINTER TO ColorMap;
 ColorTextFontPtr             = POINTER TO ColorTextFont;
 CopinitPtr                   = POINTER TO Copinit;
 CopInsPtr                    = POINTER TO CopIns;
 CopListPtr                   = POINTER TO CopList;
 CprlistPtr                   = POINTER TO Cprlist;
 DBufInfoPtr                  = POINTER TO DBufInfo;
 DBufPacketPtr                = POINTER TO DBufPacket;
 DimensionInfoPtr             = POINTER TO DimensionInfo;
 DisplayInfoPtr               = POINTER TO DisplayInfo;
 ExtendedNodePtr              = POINTER TO ExtendedNode;
 ExtSpritePtr                 = POINTER TO ExtSprite;
 GelsInfoPtr                  = POINTER TO GelsInfo;
 GfxBasePtr                   = POINTER TO GfxBase;
 IsrvstrPtr                   = POINTER TO Isrvstr;
 LayerPtr                     = POINTER TO Layer;
 LayerInfoPtr                 = POINTER TO LayerInfo;
 MonitorInfoPtr               = POINTER TO MonitorInfo;
 MonitorSpecPtr               = POINTER TO MonitorSpec;
 NameInfoPtr                  = POINTER TO NameInfo;
 PaletteExtraPtr              = POINTER TO PaletteExtra;
 PointPtr                     = POINTER TO Point;
 QueryHeaderPtr               = POINTER TO QueryHeader;
 RasInfoPtr                   = POINTER TO RasInfo;
 RastPortPtr                  = POINTER TO RastPort;
 Rect32Ptr                    = POINTER TO Rect32;
 RectanglePtr                 = POINTER TO Rectangle;
 RegionPtr                    = POINTER TO Region;
 RegionRectanglePtr           = POINTER TO RegionRectangle;
 SimpleSpritePtr              = POINTER TO SimpleSprite;
 SpecialMonitorPtr            = POINTER TO SpecialMonitor;
 TextAttrPtr                  = POINTER TO TextAttr;
 TextExtentPtr                = POINTER TO TextExtent;
 TextFontExtensionPtr         = POINTER TO TextFontExtension;
 TextFontPtr                  = POINTER TO TextFont;
 TmpRasPtr                    = POINTER TO TmpRas;
 TTextAttrPtr                 = POINTER TO TTextAttr;
 UCopListPtr                  = POINTER TO UCopList;
 ViewExtraPtr                 = POINTER TO ViewExtra;
 ViewPtr                      = POINTER TO View;
 ViewPortExtraPtr             = POINTER TO ViewPortExtra;
 ViewPortPtr                  = POINTER TO ViewPort;
 VSpritePtr                   = POINTER TO VSprite;

(*- gfx.h -*)
CONST
 bitSet=08000H;
 bitClr=0;
 
TYPE
 Rectangle=RECORD
  minX,minY:INTEGER;
  maxX,maxY:INTEGER;
 END;

 Rect32=RECORD
  minX,minY:LONGINT;
  maxX,maxY:LONGINT;
 END;

 Point=RECORD
  x,y:INTEGER;
 END;

 BitMap=RECORD
  bytesPerRow:CARDINAL;
  rows:CARDINAL;
  flags:SHORTCARD;
  depth:SHORTCARD;
  pad:CARDINAL;
  planes:ARRAY [0..7] OF ADDRESS;
 END;

(* flags for AllocBitMap, etc. *)
CONST
 bmClear=0H;
 bmDisplayable=1H;
 bmInterleaved=2H;
 bmStandard=3H;
 bmMinplanes=4H;

(* the following are for GetBitMapAttr() *)
 bmaHeight=0;
 bmaDepth=4;
 bmaWidth=8;
 bmaFlags=12;

(*- clip.h -*)
TYPE
 Layer=RECORD
  front:LayerPtr;
  back:LayerPtr;
  clipRect:ClipRectPtr;   (* read by roms to find first cliprect *)
  rp:RastPortPtr;
  bounds:Rectangle;
  reserved:ARRAY [0..3] OF BYTE;
  priority:CARDINAL;      (* system use only *)
  flags:CARDINAL;         (* obscured ?, Virtual BitMap? *)
  superBitMap:BitMapPtr;
  superClipRect:ClipRectPtr;  (* super bitmap cliprects if VBitMap != 0*)
				                      (* else damage cliprect list for refresh *)
  window:ADDRESS;             (* reserved for user interface use *)
  scrollX:INTEGER;
  scrollY:INTEGER;
  cr,cr2,crnew:ClipRectPtr;   (* used by dedice *)
  superSaveClipRects:ClipRectPtr; (* preallocated cr's *)
  cliprects:ClipRectPtr;      (* system use during refresh *)
  layerInfo:LayerInfoPtr;     (* points to head of the list *)
  lock:SignalSemaphore;
  backFill:HookPtr;
  reserved1:LONGCARD;
  clipRegion:RegionPtr;
  saveClipRects:RegionPtr;    (* used to back out when in trouble*)
  width,height:INTEGER;       (* system use *)
  reserved2:ARRAY [0..17] OF BYTE;
  damageList:RegionPtr;       (* list of rectangles to refresh through *)
 END;

 ClipRect=RECORD
  next:ClipRectPtr;   (* roms used to find next ClipRect *)
  prev:ClipRectPtr;   (* Temp use in layers (private) *)
  lobs:LayerPtr;      (* Private use for layers *)
  bitMap:BitMapPtr;   (* Bitmap for layers private use *)
  bounds:Rectangle;   (* bounds of cliprect *)            
  p1:ClipRectPtr;     (* Layers private use!!! *)
  p2:ClipRectPtr;     (* Layers private use!!! *)
  reserved:LONGINT;   (* system use (Layers private) *)
  flags:LONGINT;      (* Layers private field for cliprects *)
				              (* that layers allocates... *)
 END;                 (* MUST be multiple of 8 bytes to buffer *)

CONST
(* internal cliprect flags *)
 needsNoConcealedRasters=01H;
 needsNoLayerblitDamage=02H;

(* defines for code values for getcode *)
 isLessX=1;
 isLessY=2;
 isGrtrX=4;
 isGrtrY=8;

(*- coerce.h -*)
CONST
(* These flags are passed (in combination) to CoerceMode() to determine the
 * type of coercion required.
 *)

(* Ensure that the mode coerced to can display just as many colours as the
 * ViewPort being coerced.
 *)
  preserveColors=0;

(* Ensure that the mode coerced to is not interlaced. *)
  avoidFlicker=1;

(*- collide.h -*)
(* These bit descriptors are used by the GEL collide routines.
 *  These bits are set in the hitMask and meMask variables of
 *  a GEL to describe whether or not these types of collisions
 *  can affect the GEL.  BNDRY_HIT is described further below;
 *  this bit is permanently assigned as the boundary-hit flag.
 *  The other bit GEL_HIT is meant only as a default to cover
 *  any GEL hitting any other; the user may redefine this bit.
 *)

CONST
 borderHit=0;
(* These bit descriptors are used by the GEL boundry hit routines.
 *  When the user's boundry-hit routine is called (via the argument
 *  set by a call to SetCollision) the first argument passed to
 *  the user's routine is the address of the GEL involved in the
 *  boundry-hit, and the second argument has the appropriate bit(s)
 *  set to describe which boundry was surpassed
 *)
 topHit=1;
 bottomHit=2;
 leftHit=4;
 rightHit=8;

(*- copper.h -*)
CONST
 copperMove=0;  (* pseude opcode for move #XXXX,dir *)
 copperWait=1;  (* pseudo opcode for wait y,x *)
 cprNxtBuf=2;   (* continue processing with next buffer *)
 cprNtLof=15;   (* copper instruction only for short frames *)
 cprNtSht=14;   (* copper instruction only for long frames *)
 cprNtSys=13;   (* copper user instruction only *)              

TYPE
 CopIns=RECORD
  CASE opCode:CARDINAL OF (* 0 = move, 1 = wait *)
  | copperMove:
   destAddr:INTEGER; (* destination address of copper move *)
   destData:INTEGER; (* destination immediate data to send *)
  | copperWait:
   vWaitPos:INTEGER; (* vertical beam wait *)
   hWaitPos:INTEGER; (* horizontal beam wait position *)
  | cprNxtBuf:
   nxtlist:CopListPtr;
  END;
 END;

(* structure of cprlist that points to list that hardware actually executes *)
 Cprlist=RECORD
  next:CprlistPtr;
  start:ADDRESS;      (* start of copper list *)
  maxCount:INTEGER;   (* number of long instructions *)
 END;

 CopList=RECORD
  next:CopListPtr;      (* next block for this copper list *)
  copList:CopListPtr;   (* system use *)
  viewPort:ViewPortPtr; (* system use *)
  copIns:CopInsPtr;     (* start of this block *)
  copPtr:CopInsPtr;     (* intermediate ptr *)
  copLStart:ADDRESS;    (* mrgcop fills this in for Long Frame*)
  copSStart:ADDRESS;    (* mrgcop fills this in for Short Frame*)
  count:INTEGER;        (* intermediate counter *)
  maxCount:INTEGER;     (* max # of copins for this block *)
  dyOffset:INTEGER;     (* offset this copper list vertical waits *) 
(* V1.3 *)
  cop2Start:ADDRESS;
  cop3Start:ADDRESS;
  cop4Start:ADDRESS;
  cop5Start:ADDRESS;
 END;

 UCopList=RECORD
  next:UCopListPtr;
  firstCopList:CopListPtr;  (* head node of this copper list *)
  copList:CopListPtr;       (* node in use *)                   
 END;

(* Private graphics data structure. This structure has changed in the past,
 * and will continue to change in the future. Do Not Touch!
 *)
 Copinit=RECORD
  vsyncHBlank:ARRAY [0..1] OF CARDINAL;
  diagstrt:ARRAY [0..11] OF CARDINAL; (* copper list for first bitplane *)
  fm0:ARRAY[0..1] OF CARDINAL;
  diwstart:ARRAY[0..9] OF CARDINAL;
  bpIcon2:ARRAY[0..1] OF CARDINAL;
  sprfix:ARRAY[0..(2*8)-1] OF CARDINAL;
  sprstrtup:ARRAY [0..(2*8*2)-1] OF CARDINAL;
  wait14:ARRAY [0..1] OF CARDINAL;
  normHBlank:ARRAY [0..1] OF CARDINAL;
  jump:ARRAY [0..(2*2)-1] OF CARDINAL;
  waitForever:ARRAY [0..1] OF CARDINAL;
  sprstop:ARRAY [0..7] OF CARDINAL;
 END;

(*- display.h -*)
CONST
 m640=08000H;
 plnCntMsk=7H;  (* how many bit planes? *)
    				    (* 0 = none, 1->6 = 1->6, 7 = reserved *)
 plnCntShft=12; (* bits to shift for bplcon0 *)
 pf2pri=40H;    (* bplcon2 bit *)
 colorOn=200H;  (* disable color burst *)     
 dblpf=400H;
 holdnmodify=800H;
 interlace=4H;  (* interlace mode for 400 *)

(* bplcon1 defines *)
 pfafineScroll=0FH;
 pfbfineScrollShift=04H;
 pffineScrollMask=0FH;

(* display window start and stop defines *)
 diwhorizPos=07FH;      (* horizontal start/stop *)
 diwvrtclPos=01FFH;     (* vertical start/stop *)  
 diwvrtclPosShift=07H;
 
(* Data fetch start/stop horizontal position *)
 dftchMask=0FFH;

(* vposr bits *)
 vposrlof=08000H;


(*- displayinfo.h -*)
TYPE
 DisplayInfoHandle=ADDRESS;

CONST
(* datachunk type identifiers *)
 dtagDisp=080000000H;
 dtagDims=080001000H;
 dtagMntr=080002000H;
 dtagName=080003000H;
 dtagVec =080004000H; (* internal use only *)


TYPE
 QueryHeader=RECORD
  structID:LONGCARD;    (* datachunk type identifier *)
  displayID:LONGCARD;	  (* copy of display record key	*)
  skipID:LONGCARD;      (* TAG_SKIP -- see tagitems.h *)
  length:LONGCARD;      (* length of local data in double-longwords *)
 END;

(* availability *)
 AvailabilityFlags=(
  availNochips,availNomonitor,availNotwithgenlock,af3,
  af4,af5,af6,af7,af8
 );
 AvailabilityFlagSet=SET OF AvailabilityFlags;

(* mode properties *)
 PropertyFlags=(
  isLace,isDualpf,isPf2pri,isHam,
  isEcs, (* note: ECS modes (SHIRES, VGA, and **
					** PRODUCTIVITY) do not support     **
					** attached sprites.		            **
					*)
  isPal,isSprites,isGenlock,
  isWb,isDraggable,isPanelled,isBeamsync,
  isExtrahalfbrite,isSpritesAtt,isSpritesChngRes,isSpritesBorder,
  isAA,isScanDbl,isSpritesChngBase,isSpritesChngPri,
  isDBuffer,isProgBeam,pf22,pf23,
  pf24,pf25,pf26,pf27,
  pf28,pf29,pf30,isForeign
 );
 PropertyFlagSet=SET OF PropertyFlags;

 DisplayInfo=RECORD
  header:QueryHeader;
  notAvailable:AvailabilityFlagSet;(* if NULL available, else see above   *)
  propertyFlags:PropertyFlagSet;(* Properties of this mode see above   *)
  resolution:Point;           (* ticks-per-pixel X/Y		       *)
  pixelSpeed:CARDINAL;        (* aproximation in nanoseconds	       *)
  numStdSprites:CARDINAL;	    (* number of standard amiga sprites    *)
  paletteRange:CARDINAL;      (* OBSOLETE - use Red/Green/Blue bits instead *) 
  spriteResolution:Point;     (* std sprite ticks-per-pixel X/Y    *)
  pad:ARRAY [0..3] OF SHORTCARD;(* used internally *)
  redBits:SHORTCARD;	(* number of Red bits this display supports (V39) *)
  greenBits:SHORTCARD;(* number of Green bits this display supports (V39) *)
  blueBits:SHORTCARD; (* number of Blue bits this display supports  (V39) *)
  pad2:ARRAY[0..4] OF SHORTCARD; (* find some use for this. *)
  reserved2:ARRAY [0..1] OF LONGCARD; (* terminator *)
 END;

 DimensionInfo=RECORD
  header:QueryHeader;
  maxDepth:CARDINAL;        (* log2( max number of colors ) *)
  minRasterWidth:CARDINAL;  (* minimum width in pixels      *)
  minRasterHeight:CARDINAL; (* minimum height in pixels     *)
  maxRasterWidth:CARDINAL;  (* maximum width in pixels      *)
  maxRasterHeight:CARDINAL; (* maximum height in pixels     *)
  nominal:Rectangle;        (* "standard" dimensions	      *)
  maxOScan:Rectangle;       (* fixed, hardware dependant    *)
  videoOScan:Rectangle;     (* fixed, hardware dependant    *)
  txtOScan:Rectangle;       (* editable via preferences     *)
  stdOScan:Rectangle;       (* editable via preferences     *)
  pad:ARRAY [0..13] OF SHORTCARD;
  reserved:ARRAY [0..1] OF LONGCARD; (* terminator *)
 END;

 MonitorInfo=RECORD
  header:QueryHeader;
  mspc:MonitorSpecPtr;      (* pointer to monitor specification  *)
  viewPosition:Point;       (* editable via preferences	   *)
  viewResolution:Point;     (* standard monitor ticks-per-pixel  *)
  viewPositionRange:Rectangle; (* fixed, hardware dependant *)
  totalRows:CARDINAL;       (* display height in scanlines	   *)
  totalColorClocks:CARDINAL;(* scanline width in 280 ns units    *) 
  minRow:CARDINAL;          (* absolute minimum active scanline  *)
  compatibility:INTEGER;	  (* how this coexists with others	   *)
  pad:ARRAY [0..35] OF SHORTCARD;
  defaultViewPosition:Point;         (* original, never changes *)
  preferredModeID:LONGCARD;          (* for Preference  s *)
  reserved:ARRAY [0..1] OF LONGCARD; (* terminator *)                
 END;

CONST
(* monitor compatibility *)
 mcompatMixed=0;    (* can share display with other MCOMPAT_MIXED *)
 mcompatSelf=1;     (* can share only within same monitor *)
 mcompatNobody=-1;  (* only one viewport at a time *)                

 displayNameLen=32;

TYPE
 NameInfo=RECORD
  header:QueryHeader;
  name:ARRAY [0..displayNameLen-1] OF CHAR;
  reserved:ARRAY [0..1] OF LONGCARD; (* terminator *)
 END;

(******************************************************************************)

(* The following VecInfo structure is PRIVATE, for our use only
 * Touch these, and burn! (V39)
 *)

 VecInfo=RECORD
  header:QueryHeader;
  vec:ADDRESS;
  data:ADDRESS;
  type:CARDINAL;
  pad:ARRAY[0..2] OF CARDINAL;
  reserved:ARRAY[0..1] OF LONGCARD;
 END;

(*- gels.h -*)  
TYPE
(* VSprite flags *)
(* user-set VSprite flags: *)
 VSpriteFlags=(
  vsprite,saveBack,overlay,mustDraw,vf4,vf5,vf6,vf7,
  backSaved,bobUpdate,gelGone,vsOverflow,vf12,vf13,vf14,vf15
 );
 VSpriteFlagSet=SET OF VSpriteFlags;

(* Bob flags *)
(* these are the user flag bits *)
 BobFlags=(
  saveBob,bobIsComp,bf2,bf3,bf4,bf5,bf6,bf7,
  bWaiting,bDrawn,bobsAway,bobNix,savePreserve,outStep,bf14,bf15
 );
 BobFlagSet=SET OF BobFlags;

CONST
 suserFlags=VSpriteFlagSet{vsprite..vf7};(* mask of all user-settable VSprite-flags *)
 buserFlags=BobFlagSet{saveBob..bf7}; (* mask of all user-settable Bob-flags *)

(* defines for the animation procedures *)
 anfracsize=6H;
 animhalf=020H;
 ringtrigger=1H;

(*********************** GEL STRUCTURES ***********************************)

TYPE
VSprite=RECORD
(* --------------------- SYSTEM VARIABLES ------------------------------- *)
(* GEL linked list forward/backward pointers sorted by y,x value *)
  nextVSprite:VSpritePtr;
  prevVSprite:VSpritePtr;

(* GEL draw list constructed in the order the Bobs are actually drawn, then
 *  list is copied to clear list
 *  must be here in VSprite for system boundary detection
 *)
  drawPath:VSpritePtr;    (* pointer of overlay drawing *)
  clearPath:VSpritePtr;   (* pointer for overlay clearing *)

(* the VSprite positions are defined in (y,x) order to make sorting
 *  sorting easier, since (y,x) as a long integer
 *)
  oldY,oldX:INTEGER;    (* previous position *)
(* --------------------- COMMON VARIABLES --------------------------------- *)
  flags:VSpriteFlagSet; (* VSprite flags *)
(* --------------------- USER VARIABLES ----------------------------------- *)
(* the VSprite positions are defined in (y,x) order to make sorting
 *  sorting easier, since (y,x) as a long integer
 *)
  y,x:INTEGER;
  height:INTEGER;
  width:INTEGER;  (* number of words per row of image data *)
  depth:INTEGER;  (* number of planes of data *)             
  meMask:BITSET;  (* which types can collide with this VSprite*)
  hitMask:BITSET; (* which types this VSprite can collide with*)

  imageData:ADDRESS;  (* pointer to VSprite image *)

(* borderLine is the one-dimensional logical OR of all
 *  the VSprite bits, used for fast collision detection of edge
 *)

  borderLine:ADDRESS;   (* logical OR of all VSprite bits *)
  collMask:ADDRESS;     (* similar to above except this is a matrix *)

(* pointer to this VSprite's color definitions (not used by Bobs) *)

  sprColors:ADDRESS;
  vsBob:BobPtr; (* points home if this VSprite is part of a Bob *)

(* planePick flag:  set bit selects a plane from image, clear bit selects
 *  use of shadow mask for that plane
 * OnOff flag: if using shadow mask to fill plane, this bit (corresponding
 *  to bit in planePick) describes whether to fill with 0's or 1's
 * There are two uses for these flags:
 *	- if this is the VSprite of a Bob, these flags describe how the Bob
 *	  is to be drawn into memory
 *	- if this is a simple VSprite and the user intends on setting the
 *	  MUSTDRAW flag of the VSprite, these flags must be set too to describe
 *	  which color registers the user wants for the image
 *)
  planePick:SHORTCARD;
  planeOnOff:SHORTCARD;
 END;


(* blitter-objects *)

 Bob=RECORD
  flags:BobFlagSet;   (* general purpose flags (see definitions above) *)
  saveBuffer:ADDRESS; (* pointer to the buffer for background save *)

(* used by Bobs for "cookie-cutting" and multi-plane masking *)
  imageShadow:ADDRESS;

(* pointer to BOBs for sequenced drawing of Bobs
 *  for correct overlaying of multiple component animations
 *)
  before:BobPtr;  (* draw this Bob before Bob pointed to by before *)
  after:BobPtr;   (* draw this Bob after Bob pointed to by after *)  
  bobVSprite:VSpritePtr;  (* this Bob's VSprite definition *)
  bobComp:AnimCompPtr;    (* pointer to this Bob's AnimComp def *)
  dBuffer:DBufPacketPtr;  (* pointer to this Bob's dBuf packet *)
 END;

 AnimComp=RECORD
  flags:INTEGER;        (* AnimComp flags for system & user *)

(* timer defines how long to keep this component active:
 *  if set non-zero, timer decrements to zero then switches to nextSeq
 *  if set to zero, AnimComp never switches
 *)
  timer:INTEGER;

(* --------------------- USER VARIABLES ----------------------------------- *)
(* initial value for timer when the AnimComp is activated by the system *)
  timeSet:INTEGER;

(* pointer to next and previous components of animation object *)
  nextComp,prevComp:AnimCompPtr;

(* pointer to component component definition of next image in sequence *)
  nextSeq,prevSeq:AnimCompPtr;
  animCRoutine:ADDRESS;(* address of special animation procedure *)
  yTrans:INTEGER;      (* initial y translation (if this is a component) *)
  xTrans:INTEGER;      (* initial x translation (if this is a component) *)
  headOb:AnimObPtr;
  animBob:BobPtr;
 END;

 AnimOb=RECORD
  nextOb:AnimObPtr;
  prevOb:AnimObPtr;
  clock:LONGINT;    (* number of calls to Animate this AnimOb has endured *)
  anOldY,anOldX:INTEGER;  (* old y,x coordinates *)
  anY,anX:INTEGER;        (* y,x coordinates of the AnimOb *)
  yVel,xVel:INTEGER;      (* velocities of this object *)
  yAccel,xAccel:INTEGER;  (* accelerations of this object *)
  ringYTrans,ringXTrans:INTEGER;  (* ring translation values *)
  animORoutine:ADDRESS;   (* address of special animation procedure *)
  headComp:AnimCompPtr;   (* pointer to first component *)
 END;

 DBufPacket=RECORD
  bufY,bufX:INTEGER;  (* save the other buffers screen coordinates *)
  bufPath:VSpritePtr; (* carry the draw path over the gap *)

(* these pointers must be filled in by the user *)
(* pointer to other buffer's background save buffer *)
  bufBuffer:ADDRESS;
 END;

CONST
 b2Norm=0;
 b2Swap=1;
 b2Bobber=2;

TYPE
(* a structure to contain the 16 collision procedure addresses *)
 CollTable=RECORD
  collPtrs:ARRAY [0..15] OF ADDRESS
 END;

(*- gfxnodes.h -*)
TYPE
 ExtendedNode=RECORD
  succ:NodePtr;
  pred:NodePtr;
  type:NodeType;
  pri:SHORTINT;
  name:ADDRESS;
  subsystem:SHORTCARD;
  subtype:SHORTCARD;
  library:LONGINT;
  init:PROCEDURE():LONGINT;
 END;

CONST
 ssGraphics=2H;

 viewExtraType=1;
 viewportExtraType=2;
 specialMonitorType=3;
 monitorSpecType=4;

(*- monitor.h -*)
TYPE
 MonitorSpec=RECORD
  node:ExtendedNode;
  flags:BITSET;
  ratioh:LONGINT;
  ratiov:LONGINT;
  totalRows:CARDINAL;
  totalColorclocks:CARDINAL;
  deniseMaxDisplayColumn:CARDINAL;
  beamCon0:CARDINAL;
  minRow:CARDINAL;
  special:SpecialMonitorPtr;
  openCount:CARDINAL;
  transform:PROCEDURE():LONGINT;
  translate:PROCEDURE():LONGINT;
  scale: PROCEDURE():LONGINT;
  xoffset:CARDINAL;
  yoffset:CARDINAL;
  legalView:Rectangle;
  maxoscan:PROCEDURE():LONGINT;    (* maximum legal overscan *)
  videoscan:PROCEDURE():LONGINT;   (* video display overscan *)
  deniseMinDisplayColumn:CARDINAL;
  displayCompatible:LONGCARD;
  displayInfoDataBase:List;
  displayInfoDataBaseSemaphore:SignalSemaphore;
  mrgCop:PROCEDURE():LONGINT;
  loadView:PROCEDURE():LONGINT;
  killView:PROCEDURE():LONGINT;
 END;

CONST
 toMonitor=0;
 fromMonitor=1;

 standardXoffset=9;
 standardYoffset=0;

 msRequestNtsc=0;
 msRequestPal=1;
 msRequestSpecial=2;
 msRequestA2024=3;
 msDoubleSprites=4;

 defaultMonitorName="default.monitor";
 ntscMonitorName="ntsc.monitor";
 palMonitorName="pal.monitor";

 standardMonitorMask=BITSET{msRequestNtsc,msRequestPal};

 standardNtscRows=262;
 standardPalRows=312;
 standardColorclocks=226;
 standardDeniseMax=455;
 standardDeniseMin=93;
 standardNtscBeamcon=0000H;
 standardPalBeamcon=displayPal;

 specialBeamcon=BeamConFlagSet{varVBlank,lolDis,varVSync,
                               varBeam,cSBlank,vSyncTrue};

 minNtscRow=21;
 minPalRow=29;

 standardViewX=81H;
 standardViewY=2CH;
 standardHbstrt=6H;
 standardHsstrt=0BH;
 standardHsstop=1CH;
 standardHbstop=2CH;
 standardVbstrt=122H;
 standardVsstrt=2A6H;
 standardVsstop=3AAH;
 standardVbstop=1066H;

 vgaColorclocks=standardColorclocks DIV 2;
 vgaTotalRows=standardNtscRows*2;
 vgaDeniseMin=59;

 minVgaRow=29;

 vgaHbstrt=8H;
 vgaHsstrt=0EH;
 vgaHsstop=1CH;
 vgaHbstop=1EH;
 vgaVbstrt=0;
 vgaVsstrt=0153H;
 vgaVsstop=0235H;
 vgaVbstop=0CCDH;

 vgaMonitorName="vga.monitor";

(* NOTE: VGA70 definitions are obsolete - a VGA70 monitor has never been
 * implemented.
 *)
 vga70Colorclocks=standardColorclocks DIV 2;
 vga70TotalRows=449;
 vga70DeniseMin=59;
 minVga70Row=35;
 vga70Hbstrt=8H;
 vga70Hsstrt=0EH;
 vga70Hsstop=1CH;
 vga70Hbstop=1EH;
 vga70Vbstrt=0;
 vga70Vsstrt=02A6H;
 vga70Vsstop=0388H;
 vga70Vbstop=0F73H;

 vga70Beamcon=specialBeamcon/BeamConFlagSet{vSyncTrue};

 vga70MonitorName="vga70.monitor";

 broadcastHbstrt=1H;
 broadcastHsstrt=6H;
 broadcastHsstop=17H;
 broadcastHbstop=27H;
 broadcastVbstrt=0;
 broadcastVsstrt=02A6H;
 broadcastVsstop=054CH;
 broadcastVbstop=1C40H;
 broadcastBeamcon=BeamConFlagSet{lolDis,cSBlank};
 ratioFixedpart=4;
(* ratioUnity=SHIFT(LONGCARD(1),ratioFixedpart); !!!!!!!!!!!!!!!!!!!!*)

TYPE
 AnalogSignalInterval=RECORD
  strt:CARDINAL;
  stop:CARDINAL;
 END;

 SpecialMonitor=RECORD
  node:ExtendedNode;
  flags:BITSET;
  doMonitor:PROCEDURE():LONGINT;
  reserved1:PROCEDURE():LONGINT;
  reserved2:PROCEDURE():LONGINT;
  reserved3:PROCEDURE():LONGINT;
  hblank:AnalogSignalInterval;
  vblank:AnalogSignalInterval;
  hsync:AnalogSignalInterval;
  vsync:AnalogSignalInterval;
 END;

(*- gfxbase.h -*)
TYPE
 DisplayFlags=(
   ntsc,genloc,pal,todaSafe,reallyPal,df5,df6,df7,
   df8,df9,df10,df11,df12,df13,df14,df15
 );
 DisplayFlagSet=SET OF DisplayFlags;

(* bits defs for ChipRevBits *)

 ChipRevs=(hrAgnus,hrDenise,aaAlice,aaLisa,aaMLisa,cr5,cr6,cr7);
 ChipRevSet=SET OF ChipRevs;

CONST
 bigBlits=hrAgnus;

 blitMsgFault=4;

(* Pass ONE of these to SetChipRev() *)
 setchiprevA=LONGSET{ORD(hrAgnus)};
 setchiprevECS=LONGSET{ORD(hrAgnus),ORD(hrDenise)};
 setchiprevAA=LONGSET{ORD(aaAlice),ORD(aaLisa)}+setchiprevECS;
 setchiprevBest=LONGSET{0..31};

(* memory type *)
 bus16=0;
 nmlCas=0;
 bus32=1;
 dblCas=2;
 bandwidth1x=bus16+nmlCas;
 bandwidth2xnml=bus32;
 bandwidth2xdbl=dblCas;
 bandwidth4x=bus32+dblCas;

 graphicsName="graphics.library";

TYPE
 GfxBase=RECORD
  libNode:Library;
  actiView:ViewPtr;
  copinit:CopinitPtr; (* ptr to copper start up list *)
  cia:ADDRESS;        (* for 8520 resource use *)
  blitter:ADDRESS;    (* for future blitter resource use *)
  loFlist:ADDRESS;
  shFlist:ADDRESS;
  blthd,blttl:BltnodePtr;
  bsblthd,bsblttl:BltnodePtr;
  vbsrv,timsrv,bltsrv:Interrupt;
  textFonts:List;
  defaultFont:TextFontPtr;
  modes:BITSET;     (* copy of current first bplcon0 *)
  vBlank:SHORTCARD;
  debug:BYTE;
  beamSync:INTEGER;
  bplcon0:BITSET;   (* it is ored into each bplcon0 for display *)
  spriteReserved:SHORTCARD;
  bytereserved:SHORTCARD;
  flags:BITSET;
  blitLock:INTEGER;
  blitNest:INTEGER;
  blitWaitQ:List;
  blitOwner:TaskPtr;
  waitQ:List;
  displayFlags:DisplayFlagSet;  (* NTSC PAL GENLOC etc see above *)
  simpleSprites:ADDRESS;
  maxDisplayRow:CARDINAL;       (* hardware stuff, do not use *)
  maxDisplayColumn:CARDINAL;    (* hardware stuff, do not use *)
  normalDisplayRows:CARDINAL;
  normalDisplayColumns:CARDINAL;
  normalDPMX:CARDINAL;          (* Dots per meter on display *)
  normalDPMY:CARDINAL;          (* Dots per meter on display *)
  lastChanceMemory:SignalSemaphorePtr;
  lcMptr:ADDRESS;
  microsPerLine:CARDINAL;       (* 256 time usec/line *)
  minDisplayColumn:CARDINAL;
  chipRevBits0:ChipRevSet;
  memType:SHORTCARD;
  reserved:ARRAY [0..3] OF SHORTCARD;
  monitorId:CARDINAL;
  hedley:ARRAY [0..7] OF ADDRESS;
  hedleySprites:ARRAY[0..7]OF ADDRESS; (* sprite ptrs for intuition mouse *)
  hedleySprites1:ARRAY[0..7]OF ADDRESS;(* sprite ptrs for intuition mouse *)
  hedleyCount:INTEGER;
  hedleyFlags:BITSET;
  hedleyTmp:INTEGER;
  hashTable:ADDRESS;
  currentTotRows:CARDINAL;
  currentTotCclks:CARDINAL;
  hedleyHint:SHORTCARD;
  hedleyHint2:SHORTCARD;
  nreserved:ARRAY [0..3] OF LONGCARD;
  a2024SyncRaster:ADDRESS;
  controlDeltaPal:INTEGER;
  controlDeltaNtsc:INTEGER;
  currentMonitor:MonitorSpecPtr;
  monitorList:List;
  defaultMonitor:MonitorSpecPtr;
  monitorListSemaphore:SignalSemaphorePtr;
  displayInfoDataBase:ADDRESS;
  topLine:CARDINAL;
  actiViewCprSemaphore:SignalSemaphorePtr;
  utilityBase:ADDRESS;  (* for hook and tag utilities. had to change because of name clash	*)
  execBase:ADDRESS;     (* to link with rom.lib	*)                                             
  bwshifts:ADDRESS;
  strtFetchMasks:ADDRESS;
  stopFetchMasks:ADDRESS;
  overrun:ADDRESS;
  realStops:ADDRESS;
  spriteWidth:CARDINAL; (* current width (in words) of sprites *)
  spriteFMode:BITSET;   (* current sprite fmode bits	*)
  softSprites:SHORTINT; (* bit mask of size change knowledgeable sprites *)
  arraywidth:SHORTINT;
  defaultSpriteWidth:CARDINAL; (* what width intuition wants *)
  sprMoveDisable:SHORTINT;
  wantChips:SHORTCARD;
  boardMemType:SHORTCARD;
  bugs:SHORTCARD;
  layersBase:ADDRESS;
  colorMask:LONGCARD;
  iVector:ADDRESS;
  iData:ADDRESS;
  specialCounter:LONGCARD;  (* special for double buffering *)
  dBList:ADDRESS;
  monitorFlags:BITSET;
  scanDoubledSprites:SHORTCARD;
  bP3Bits:SHORTCARD;
  monitorVBlank:AnalogSignalInterval;
  naturalMonitor:MonitorSpecPtr;
  progData:ADDRESS;
  extSprites:SHORTCARD;
 END;

(*- graphint.h -*)
TYPE
 Isrvstr=RECORD
  node:Node;
  iptr:IsrvstrPtr;  (* passed to srvr by os *)
  code:ADDRESS;
  ccode:ADDRESS;
  carg:LONGINT;
 END;

(*- layers.h -*)
TYPE
 LayerFlags=(
  layerSimple,layerSmart,layerSuper,lf3,
  layerUpdating,lf5,layerBackdrop,layerRefresh,
  layerClipRectsLost,layerIRefresh,layerIRefresh2,lf11,
  lf12,lf13,lf14,lf15
 );
 LayerFlagSet=SET OF LayerFlags;

 LayerInfo=RECORD
  layer:LayerPtr;
  lp:LayerPtr;      (* !! Private !! *)
  obs:ClipRectPtr;
  freeClipRects:ClipRectPtr;  (* !! Private !! *)
  privateReserve1,            (* !! Private !! *)
  privateReserve2:LONGINT;    (* !! Private !! *)
  lock:SignalSemaphore;       (* !! Private !! *)
  head:MinList;               (* !! Private !! *)
  privateReserve3:INTEGER;    (* !! Private !! *)
  privateReserve4:ADDRESS;    (* !! Private !! *)
  flags:LayerFlagSet;
  fattenCount:SHORTINT;       (* !! Private !! *)
  lockLayersCount:SHORTINT;   (* !! Private !! *)
  privateReserve5:INTEGER;    (* !! Private !! *)
  blankHook:ADDRESS;          (* !! Private !! *)
  layerInfoExtra:ADDRESS;     (* !! Private !! *)
 END;

CONST
 newLayerInfoCalled=1;
(*
 * LAYERS_NOBACKFILL is the value needed to get no backfill hook
 * LAYERS_BACKFILL is the value needed to get the default backfill hook
 *)
 layersNoBackFill=VAL(HookPtr,LONGINT(1));
 layersBackFill=VAL(HookPtr,NIL);

(*- modeid.h -*)
CONST
 invalidID=0FFFFFFFFH; (* NOT 0 *)

(* normal identifiers *)
 monitorIDmask=0FFFF1000H;

 defaultMonitorID=00000000H;
 ntscMonitorID=00011000H;
 palMonitorID=00021000H;

(* the following 22 composite keys are for Modes on the default Monitor.
 * NTSC & PAL "flavors" of these particular keys may be made by or'ing
 * the NTSC or PAL MONITOR_ID with the desired MODE_KEY...
 *
 * For example, to specifically open a PAL HAM interlaced ViewPort
 * (or intuition screen), you would use the modeid of
 * (PAL_MONITOR_ID | HAMLACE_KEY)
 *)
 loresKey=00000000H;
 hiresKey=00008000H;
 superKey=00008020H;
 hamKey=00000800H;
 loreslaceKey=00000004H;
 hireslaceKey=00008004H;
 superlaceKey=00008024H;
 hamlaceKey=00000804H;
 loresdpfKey=00000400H;
 hiresdpfKey=00008400H;
 superdpfKey=00008420H;
 loreslacedpfKey=00000404H;
 hireslacedpfKey=00008404H;
 superlacedpfKey=00008424H;
 loresdpf2Key=00000440H;
 hiresdpf2Key=00008440H;
 superdpf2Key=00008460H;
 loreslacedpf2Key=00000444H;
 hireslacedpf2Key=00008444H;
 superlacedpf2Key=00008464H;
 extrahalfbriteKey=00000080H;
 extrahalfbritelaceKey=00000084H;

(* New for AA ChipSet (V39) *)
 hireshamKey=00008800H;
 superhamKey=00008820H;
 hiresehbKey=00008080H;
 superehbKey=000080A0H;
 hireshamlaceKey=00008804H;
 superhamlaceKey=00008824H;
 hiresehblaceKey=00008084H;
 superehblaceKey=000080A4H;

(* VGA identifiers *)

 vgaMonitorID=00031000H;

 vgaextraloresKey=00031004H;
 vgaloresKey=00039004H;
 vgaproductKey=00039024H;
 vgahamKey=00031804H;
 vgaextraloreslaceKey=00031005H;
 vgaloreslaceKey=00039005H;
 vgaproductlaceKey=00039025H;
 vgahamlaceKey=00031805H;
 vgaextraloresdpfKey=00031404H;
 vgaloresdpfKey=00039404H;
 vgaproductdpfKey=00039424H;
 vgaextraloreslacedpfKey=00031405H;
 vgaloreslacedpfKey=00039405H;
 vgaproductlacedpfKey=00039425H;
 vgaextraloresdpf2Key=00031444H;
 vgaloresdpf2Key=00039444H;
 vgaproductdpf2Key=00039464H;
 vgaextraloreslacedpf2Key=00031445H;
 vgaloreslacedpf2Key=00039445H;
 vgaproductlacedpf2Key=00039465H;
 vgaextrahalfbriteKey=00031084H;
 vgaextrahalfbritelaceKey=00031085H;
 vgaproducthamKey=39824H;
 vgaloreshamKey=39804H;
 vgaextraloreshamKey=vgahamKey;
 vgaproducthamlaceKey=39825H;
 vgaloreshamlaceKey=39805H;
 vgaextraloreshamlaceKey=vgahamlaceKey;
(* New for AA ChipSet (V39) *)
 vgaextraloresehbKey=vgaextrahalfbriteKey;
 vgaextraloresehblaceKey=vgaextrahalfbritelaceKey;
 vgaloresehbKey=39084H;
 vgaloresehblaceKey=39085H;
 vgaehbKey=390A4H;
 vgaehblaceKey=390A5H;

 (* a2024 identifiers *)

 a2024MonitorID=00041000H;

 a2024tenhertzKey=00041000H;
 a2024fifteenhertzKey=00049000H;

 (* prototype identifiers (private) *)

 protoMonitorID=00051000H;

(* These monitors and modes were added for the V38 release. *)
 
 euro72MonitorID=000061000H;

 euro72extraloresKey=00061004H;
 euro72loresKey=00069004H;
 euro72productKey=00069024H;
 euro72hamKey=00061804H;
 euro72extraloreslaceKey=00061005H;
 euro72loreslaceKey=00069005H;
 euro72productlaceKey=00069025H;
 euro72hamlaceKey=00061805H;
 euro72extraloresdpfKey=00061404H;
 euro72loresdpfKey=00069404H;
 euro72productdpfKey=00069424H;
 euro72extraloreslacedpfKey=00061405H;
 euro72loreslacedpfKey=00069405H;
 euro72productlacedpfKey=00069425H;
 euro72extraloresdpf2Key=00061444H;
 euro72loresdpf2Key=00069444H;
 euro72productdpf2Key=00069464H;
 euro72extraloreslacedpf2Key=00061445H;
 euro72loreslacedpf2Key=00069445H;
 euro72productlacedpf2Key=00069465H;
 euro72extrahalfbriteKey=00061084H;
 euro72extrahalfbritelaceKey=00061085H;
(* New AA modes (V39) *)
 euro72producthamKey=00069824H;
 euro72producthamlaceKey=00069825H;
 euro72loreshamKey=00069804H;
 euro72loreshamlaceKey=00069805H;
 euro72extraloreshamKey=euro72hamKey;
 euro72extraloreshamlaceKey=euro72hamlaceKey;
 euro72extraloresehbKey=euro72extrahalfbriteKey;
 euro72extraloresehblaceKey=euro72extrahalfbritelaceKey;
 euro72loresehbKey=00069084H;
 euro72loresehblaceKey=00069085H;
 euro72ehbKey=000690A4H;
 euro72ehblaceKey=000690A5H;

 euro36MonitorID=00071000H;

(* Euro36 modeids can be ORed with the default modeids a la NTSC and PAL.
 * For example, Euro36 SuperHires is
 * (EURO36_MONITOR_ID | SUPER_KEY)
 *)
 super72MonitorID=00081000H;

(* Similarly for Super72 modes. *)

(* These monitors and modes were added for the V39 release. *)
 dblntscMonitorID=00091000H;

 dblntscloresKey=00091000H;
 dblntscloresffKey=00091004H;
 dblntscloreshamKey=00091800H;
 dblntscloreshamffKey=00091804H;
 dblntscloresehbKey=00091080H;
 dblntscloresehbffKey=00091084H;
 dblntscloreslaceKey=00091005H;
 dblntscloreshamlaceKey=00091805H;
 dblntscloresehblaceKey=00091085H;
 dblntscloresdpfKey=00091400H;
 dblntscloresdpflaceKey=00091404H;
 dblntscloresdpf2Key=00091440H;
 dblntscloresdpf2laceKey=00091444H;
 dblntschiresKey=00099000H;
 dblntschiresffKey=00099004H;
 dblntschireshamKey=00099800H;
 dblntschireshamffKey=00099804H;
 dblntschireslaceKey=00099005H;
 dblntschireshamlaceKey=00099805H;
 dblntschiresehbKey=00099080H;
 dblntschiresehbffKey=00099084H;
 dblntschiresehblaceKey=00099085H;
 dblntschiresdpfKey=00099400H;
 dblntschiresdpflaceKey=00099404H;
 dblntschiresdpf2Key=00099440H;
 dblntschiresdpf2laceKey=00099444H;

 dblpalMonitorID=000A1000H;

 dblpalloresKey=000A1000H;
 dblpalloresffKey=000A1004H;
 dblpalloreshamKey=000A1800H;
 dblpalloreshamffKey=000A1804H;
 dblpalloresehbKey=000A1080H;
 dblpalloresehbffKey=000A1084H;
 dblpalloreslaceKey=000A1005H;
 dblpalloreshamlaceKey=000A1805H;
 dblpalloresehblaceKey=000A1085H;
 dblpalloresdpfKey=000A1400H;
 dblpalloresdpflaceKey=000A1404H;
 dblpalloresdpf2Key=000A1440H;
 dblpalloresdpf2laceKey=000A1444H;
 dblpalhiresKey=000A9000H;
 dblpalhiresffKey=000A9004H;
 dblpalhireshamKey=000A9800H;
 dblpalhireshamffKey=000A9804H;
 dblpalhireslaceKey=000A9005H;
 dblpalhireshamlaceKey=000A9805H;
 dblpalhiresehbKey=000A9080H;
 dblpalhiresehbffKey=000A9084H;
 dblpalhiresehblaceKey=000A9085H;
 dblpalhiresdpfKey=000A9400H;
 dblpalhiresdpflaceKey=000A9404H;
 dblpalhiresdpf2Key=000A9440H;
 dblpalhiresdpf2laceKey=000A9444H;

(* Use these tags for passing to BestModeID() (V39) *)
 specialFlags=PropertyFlagSet{isDualpf,isPf2pri,isHam,isExtrahalfbrite};
 
 bidtagDIPFMustHave=80000001H;    (* mask of the DIPF_ flags the ModeID must have *)
				(* Default - NULL *)
 bidtagDIPFMustNotHave=80000002H; (* mask of the DIPF_ flags the ModeID must not have *)
				(* Default - SPECIAL_FLAGS *)
 bidtagViewPort=80000003H;        (* ViewPort for which a ModeID is sought. *)
				(* Default - NULL *)
 bidtagNominalWidth=80000004H;    (* \ together make the aspect ratio and *)
 bidtagNominalHeight=80000005H;	  (* / override the vp->Width/Height. *)   
				(* Default - SourceID NominalDimensionInfo,
				 * or vp->DWidth/Height, or (640 * 200),
				 * in that preferred order.
				 *)
 bidtagDesiredWidth=80000006H;    (* \ Nominal Width and Height of the *)
 bidtagDesiredHeight=80000007H;   (* / returned ModeID. *)               
				(* Default - same as Nominal *)
 bidtagDepth=80000008H; (* ModeID must support this depth. *)
				(* Default - vp->RasInfo->BitMap->Depth or 1 *)
 bidtagMonitorID=80000009H;(* ModeID must use this monitor. *)
				(* Default - use best monitor available *)
 bidtagSourceID=8000000AH;(* instead of a ViewPort. *)
				(* Default - VPModeID(vp) or HIRES_KEY *)
 bidtagRedBits=8000000BH;   (* \ 				*)
 bidtagBlueBits=8000000CH;  (*  } Match up from the database *)
 bidtagGreenBits=8000000DH; (* /				*)                      
				(* Default - 4 *)

(*- text.h -*)
TYPE
(*------ Font Styles ------------------------------------------------*)
 FontStyles=(
  underlined,bold,italic,fsextended,fs4,fs5,colorFont,tagged
 );
 (*************** ZIET EXTENDED UIT EXECD *********************)
 FontStyleSet=SET OF FontStyles;

CONST
 normalFont=FontStyleSet{};

TYPE
(*------ Font Flags -------------------------------------------------*)
 FontFlags=(
  romFont,diskFont,revPath,tallDot,wideDot,proportional,designed,removed
 );
 FontFlagSet=SET OF FontFlags;

(****** TextAttr node, matches text attributes in RastPort **********)
 TextAttr=RECORD
  name:ADDRESS;       (* name of the font *)
  ySize:CARDINAL;     (* height of the font *)
  style:FontStyleSet; (* intrinsic font style *)
  flags:FontFlagSet;  (* font preferences and flags *)
 END;

 TTextAttr=RECORD
  name:ADDRESS;       (* name of the font *)
  ySize:CARDINAL;     (* height of the font *)
  style:FontStyleSet; (* intrinsic font style *)
  flags:FontFlagSet;  (* font preferences and flags *)
  tags:TagItemPtr;    (* extended attributes *)         
 END;

(****** Text Tags ***************************************************)
CONST
 taDeviceDPI=tagUser+1;(* Tag value is Point union: *)
					(* Hi word XDPI, Lo word YDPI *)
 maxFontMatchWeight=32767; (* perfect match from WeighTAMatch *)

(****** TextFonts node **********************************************)
TYPE
 TextFont=RECORD
  message:Message;      (* reply message for font removal *)
  ySize:CARDINAL;       (* font height		  |    order to best *)
  style:FontStyleSet;   (* font style		  |    match a font *)
  flags:FontFlagSet;    (* preferences and flags  /    request. *)
  xSize:CARDINAL;       (* nominal font width *)
  baseline:CARDINAL;    (* distance from the top of char to baseline *)
  boldSmear:CARDINAL;   (* smear to affect a bold enhancement *)
  accessors:CARDINAL;   (* access count *)
  loChar:CHAR;          (* the first character described here *)
  hiChar:CHAR;          (* the last character described here *)
  charData:ADDRESS;     (* the bit character data *)
  modulo:CARDINAL;      (* the row modulo for the strike font data *)
  charLoc:ADDRESS;      (* ptr to location data for the strike font *)
  charSpace:ADDRESS;    (* ptr to words of proportional spacing data *)
  charKern:ADDRESS;     (* ptr to words of kerning data *)              
 END;

CONST
 noRemFont=0;        (* disallow RemFont for this font *)

TYPE
 TextFontExtension=RECORD (* this structure is read-only *)
  matchWord:CARDINAL;     (* a magic cookie for the extension *)       
  flags0:SHORTSET;        (* (system private flags) *)         
  flags1:SHORTSET;        (* (system private flags) *)         
  backPtr:TextFontPtr;    (* validation of compilation *)
  origReplyPort:MsgPortPtr;(* original value in tf_Extension *)
  tags:TagItemPtr;        (* Text Tags for the font *)
  oFontPatchS:ADDRESS;    (* (system private use) *)
  oFontPatchK:ADDRESS;    (* (system private use) *)             
    (* this space is reserved for future expansion *)
 END;


(******	ColorTextFont node ******************************************)
(*-----	ctf_Flags --------------------------------------------------*)
 ColorTextFontFlags=(
  colorfont,greyfont,antialias,ctf3,ctf4,ctf5,ctf6,ctf7,
  ctf8,ctf9,ctf10,ctf11,ctf12,ctf13,ctf14,ctf15
 );
 ColorTextFontFlagSet=SET OF ColorTextFontFlags;

CONST
 mapColor=colorFont;
 colorMask=ColorTextFontFlagSet{colorfont..ctf3};

(*----- ColorFontColors --------------------------------------------*)
TYPE
 ColorFontColors=RECORD
  reserved:CARDINAL;  (* *must* be zero *)
  count:CARDINAL;     (* number of entries in cfc_ColorTable *)
  colorTable:ADDRESS; (* 4 bit per component color map packed xRGB *)
 END;

(*-----	ColorTextFont ----------------------------------------------*)
 ColorTextFont=RECORD
  tf:TextFont;
  flags:CARDINAL;       (* extended flags *)
  depth:SHORTCARD;      (* number of bit planes *)
  fgColor:SHORTCARD;    (* color that is remapped *)
  low:SHORTCARD;        (* lowest color represented *)
  high:SHORTCARD;       (* highest color represented *)
  planePick:SHORTCARD;  (* PlanePick ala Images *)
  planeOnOff:SHORTCARD; (* PlaneOnOff ala Images *)
  colorFontColors:ColorFontColorsPtr;(* colors for font *)
  charData:ARRAY[0..7] OF ADDRESS; (*pointers to bit planes ala tf_CharData *)
 END;

(****** TextExtent node *********************************************)
 TextExtent=RECORD
  width:CARDINAL;     (* same as TextLength *)
  height:CARDINAL;    (* same as tf_YSize *)
  extent:Rectangle;   (* relative to CP *)      
 END;

(*- rastport.h -*)
TYPE
 AreaInfo=RECORD
  vctrTbl:ADDRESS;      (* ptr to start of vector table *)
  vctrPtr:ADDRESS;      (* ptr to current vertex *)
  flagTbl:ADDRESS;      (* ptr to start of vector flag table *)
  flagPtr:ADDRESS;      (* ptrs to areafill flags *)
  count:INTEGER;        (* number of vertices in list *)
  maxCount:INTEGER;     (* AreaMove/Draw will not allow Count>MaxCount*)
  firstX,firstY:INTEGER;(* first point for this polygon *)                
 END;

 TmpRas=RECORD
  rasPtr:ADDRESS;
  size:LONGINT;
 END;

(* unoptimized for 32bit alignment of pointers *)
 GelsInfo=RECORD
  sprRsrvd:SHORTINT;(* flag of which sprites to reserve from vsprite system *)
  flags:SHORTCARD;  (* system use *)
  gelHead,gelTail:VSpritePtr; (* dummy vSprites for list management*)
  (* pointer to array of 8 WORDS for sprite available lines *)
  nextLine:ADDRESS;
  (* pointer to array of 8 pointers for color-last-assigned to vSprites *)
  lastColor:ADDRESS;
  collHandler:CollTablePtr;  (* addresses of collision routines *)
  leftmost,rightmost,topmost,bottommost:INTEGER;
  firstBlissObj,lastBlissObj:ADDRESS; (* system use only *)
 END;

 DrawModes=(dm0,dmComplement,dmInversvid);
 DrawModeSet=SET OF DrawModes;

(* these are the flag bits for RastPort flags *)
 RastPortFlags=(
  firstDot,oneDot,dBuffer,areaOutline,rpf4,noCrossFill,rpf6,rpf7,rpf8
 );
 RastPortFlagSet=SET OF RastPortFlags;

 RastPort=RECORD
  layer:LayerPtr;
  bitMap:BitMapPtr;
  areaPtrn:ADDRESS;   (* ptr to areafill pattern *)
  tmpRas:TmpRasPtr;
  areaInfo:AreaInfoPtr;
  gelsInfo:GelsInfoPtr;
  mask:SHORTCARD;         (* write mask for this raster *)
  fgPen:SHORTCARD;        (* foreground pen for this raster *)
  bgPen:SHORTCARD;        (* background pen  *)
  aOlPen:SHORTCARD;       (* areafill outline pen *)
  drawMode:DrawModeSet;   (* drawing mode for fill, lines, and text *)
  areaPtSz:SHORTCARD;     (* 2^n words for areafill pattern *)
  linPatCnt:SHORTCARD;    (* current line drawing pattern preshift *)
  dummy:BYTE;                                                          
  flags:RastPortFlagSet;  (* miscellaneous control bits *)
  linePtrn:CARDINAL;      (* 16 bits for textured lines *)
  x,y:INTEGER;              (* current pen position *)       
  minterms:ARRAY [0..7] OF SHORTCARD;
  penWidth:INTEGER;
  penHeight:INTEGER;
  font:TextFontPtr;         (* current font address *)
  algoStyle:FontStyleSet;   (* the algorithmically generated style *)
  txFlags:FontFlagSet;      (* text specific flags *)
  txHeight:CARDINAL;        (* text height *)
  txWidth:CARDINAL;         (* text nominal width *)
  txBaseline:CARDINAL;      (* text baseline *)
  txSpacing:INTEGER;        (* text spacing (per character) *)          
  user:ADDRESS;
  longreserved:ARRAY [0..1] OF LONGINT;
  wordreserved:ARRAY [0..6] OF WORD;  (* used to be a node *)
  reserved:ARRAY [0..7] OF BYTE;  (* for future use *)   
 END;

CONST
 jam1=DrawModeSet{};                   (* jam 1 color into raster *)
 jam2=DrawModeSet{dm0};                (* jam 2 colors into raster *)
 complement=DrawModeSet{dmComplement}; (* XOR bits into raster *)
 inversvid=DrawModeSet{dmInversvid};   (* inverse video for drawing modes *) 

(* there is only one style of clipping: raster clipping *)
(* this preserves the continuity of jaggies regardless of clip window *)
(* When drawing into a RastPort, if the ptr to ClipRect is nil then there *)
(* is no clipping done, this is dangerous but useful for speed *)

(*- regions.h -*)
TYPE
 RegionRectangle=RECORD
  next,prev:RegionRectanglePtr;
  bounds:Rectangle;
 END;

 Region=RECORD
  bounds:Rectangle;
  regionRectangle:RegionRectanglePtr;
 END;

(*- rpattr.h -*)
CONST
(**	tag definitions for GetRPAttr, SetRPAttr **)
 rptagFont	=80000000H;     (* get/set font *)
 rptagAPen	=80000002H;     (* get/set apen *)
 rptagBPen	=80000003H;     (* get/set bpen *)
 rptagDrMd	=80000004H;     (* get/set draw mode *)
 rptagOutLinePen=80000005H; (* get/set outline pen *)
 rptagWriteMask	=80000006H; (* get/set WriteMask *)
 rptagMaxPen    =80000007H; (* get/set maxpen *)      

 rptagDrawBounds=80000008H; (* get only rastport draw bounds. pass &rect *)

(*- scale.h -*)
TYPE
 BitScaleArgs=RECORD
  srcX,srcY:CARDINAL;                 (* source origin *)
  srcWidth,srcHeight:CARDINAL;        (* source size *)
  srcXFactor,srcYFactor:CARDINAL;     (* scale factor denominators *)
  destX,destY:CARDINAL;               (* destination origin *)
  destWidth,destHeight:CARDINAL;      (* destination size result *)
  xDestFactor,yDestFactor:CARDINAL;   (* scale factor numerators *)
  srcBitMap:BitMapPtr;                (* source BitMap *)
  destBitMap:BitMapPtr;               (* destination BitMap *)
  flags:LONGCARD;                     (* reserved.  Must be zero! *)
  xDDA,yDDA:CARDINAL;                 (* reserved *)
  reserved1:LONGINT;
  reserved2:LONGINT;
 END;

(*- sprite.h -*)
CONST
 spriteAttached=80H;

TYPE
 SimpleSprite=RECORD
  posctldata:ADDRESS;
  height:CARDINAL;
  x,y:CARDINAL;  (* current position *)
  num:INTEGER;
 END;

 ExtSprite=RECORD
  simpleSprite:SimpleSprite;	(* conventional simple sprite structure *)
  wordwidth:CARDINAL;         (* graphics use only, subject to change *)
  flags:BITSET;               (* graphics use only, subject to change *)
 END;

CONST
(* tags for AllocSpriteData() *)
 spriteaWidth        =81000000H;
 spriteaXReplication =81000002H;
 spriteaYReplication =81000004H;
 spriteaOutputHeight =81000006H;
 spriteaAttached     =81000008H;
 spriteaOldDataFormat=8100000AH;(* MUST pass in outputheight if using this tag *)

(* tags for GetExtSprite() *)
 gstagSpriteNum =82000020H;
 gstagAttached  =82000022H;
 gstagSoftSprite=82000024H;

(* tags valid for either GetExtSprite or ChangeExtSprite *)
 gstagScanDoubled=83000000H;(* request "NTSC-Like" height if possible. *)

(*- videocontrol.h -*)
CONST
 vtagEndCm=0;

TYPE
 VTags=(
  vtagChromakeyClr:=tagUser,
  vtagChromakeySet,
  vtagBitplanekeyClr,
  vtagBitplanekeySet,
  vtagBorderblankClr,
  vtagBorderblankSet,
  vtagBordernotransClr,
  vtagBordernotransSet,
  vtagChromaPenClr,
  vtagChromaPenSet,
  vtagChromaPlaneSet,
  vtagAttachCmSet,
  vtagNextbufCm,
  vtagBatchCmClr,
  vtagBatchCmSet,
  vtagNormalDispGet,
  vtagNormalDispSet,
  vtagCoerceDispGet,
  vtagCoerceDispSet,
  vtagViewportextraGet,
  vtagViewportextraSet,
  vtagChromakeyGet,
  vtagBitplanekeyGet,
  vtagBorderblankGet,
  vtagBordernotransGet,
  vtagChromaPenGet,
  vtagChromaPlaneGet,
  vtagAttachCmGet,
  vtagBatchCmGet,
  vtagBatchItemsGet,
  vtagBatchItemsSet,
  vtagBatchItemsAdd,
  vtagVpmodeidGet,
  vtagVpmodeidSet,
  vtagVpmodeidClr,
  vtagUserclipGet,
  vtagUserclipSet,
  vtagUserclipClr, 
(* The following tags are V39 specific. They will be ignored (returing error -3) by
	earlier versions *)
  vtagPf1BaseGet,
  vtagPf2BaseGet,
  vtagSpEvenBaseGet,
  vtagSpOddBaseGet,
  vtagPf1BaseSet,
  vtagPf2BaseSet,
  vtagSpEvenBaseSet,
  vtagSpOddBaseSet,
  vtagBorderSpriteGet,
  vtagBorderSpriteSet,
  vtagBorderSpriteClr,
  vtagSpriteResnSet,
  vtagSpriteResnGet,
  vtagPf1ToSpritePriSet,
  vtagPf1ToSpritePriGet,
  vtagPf2ToSpritePriSet,
  vtagPf2ToSpritePriGet,
  vtagImmediate,
  vtagFullPaletteSet,
  vtagFullPaletteGet,
  vtagFullPaletteClr,
  vtagDefSpriteResnSet,
  vtagDefSpriteResnGet 
 );

(*- view.h -*)
TYPE
(* defines used for Modes in IVPargs *)
 ViewModes=(
  vm0,genlocVideo,lace,doubleScan,
  vm4,superHires,pfba,extraHalfbrite,
  genlocAudio,vm9,dualpf,ham,
  extendedMode,vpHide,sprites,hires
 );
 ViewModeSet=SET OF ViewModes;

 ViewPort=RECORD
  next:ViewPortPtr;
  colorMap:ColorMapPtr; (* table of colors for this viewport *)
  dspIns:CopListPtr;    (* user by MakeView() *)
  sprIns:CopListPtr;    (* used by sprite stuff *)
  clrIns:CopListPtr;    (* used by sprite stuff *)
  uCopIns:UCopListPtr;	(* User copper list *)   
  dWidth,dHeight:INTEGER;
  dxOffset,dyOffset:INTEGER;
  modes:ViewModeSet;
  spritePriorities:SHORTCARD;	(* used by makevp *)
  extendedModes:SHORTSET;
  rasInfo:RasInfoPtr;
 END;

 View=RECORD
  viewPort:ViewPortPtr;
  lofCprList:CprlistPtr;    (* used for interlaced and noninterlaced *)
  shfCprList:CprlistPtr;    (* only used during interlace *)
  dyOffset,dxOffset:INTEGER;(* for complete View positioning *)         
  modes:ViewModeSet;        (* such as INTERLACE, GENLOC *)
 END;

(* these structures are obtained via GfxNew *)
(* and disposed by GfxFree *)
 ViewExtra=RECORD
  n:ExtendedNode;
  view:ViewPtr;             (* backwards link *)
  monitor:MonitorSpecPtr;   (* monitors for this view *)
  topLine:CARDINAL;
 END;

(* this structure is obtained via GfxNew *)
(* and disposed by GfxFree *)
 ViewPortExtra=RECORD
  n:ExtendedNode;
  viewPort:ViewPortPtr;   (* backwards link *)
  displayClip:Rectangle;;	(* makevp display clipping information *)
	(* These are added for V39 *)
  vecTable:ADDRESS; (* Private *)
  driverData:ARRAY [0..1] OF ADDRESS;
  flags:BITSET;
  origin:ARRAY [0..1] OF Point; (* First visible point relative to the DClip.
					 * One for each possible playfield.
					 *)
 END;

CONST
 vpxbFreeMe=0;    (* private *)
 vpxbLast=1;
 vpxbStraddles256=4;
 vpxbStraddles512=5;

 extendVStruct=extendedMode; (* unused bit in Modes field of View *)

 vpfA2024=040H;	(* VP?_ fields internal only *)
 vpfTenhz=020H;
 vpbA2024=6;
 vpbTenhz=4;

(* defines used for Modes in IVPargs *)

TYPE
 RasInfo=RECORD   (* used by callers to and InitDspC() *)
  next:RasInfoPtr;           (* used for dualpf *)
  bitMap:BitMapPtr;
  rxOffset,ryOffset:INTEGER; (* scroll offsets in this BitMap *)
 END;

 ColorMapType=(colorMapTypeV33,colorMapTypeV36,colorMapTypeV39);

 ColorMapFlags=(
  colormapTransparency,colorPlaneTransparency,borderBlanking,
  borderNoTransparency,videoControlBatch,userCopperClip,borderSprites,cm7
 );
 ColorMapFlagSet=SET OF ColorMapFlags;

 ColorMap=RECORD
  flags:ColorMapFlagSet;
  type:ColorMapType;
  count:CARDINAL;
  colorTable:ADDRESS;
  vpe:ViewPortExtraPtr;
  transparencyBits:ADDRESS;
  transparencyPlane:SHORTCARD;
  reserved1:SHORTCARD;
  reserved2:CARDINAL;
  vp:ViewPortPtr;
  normalDisplayInfo:ADDRESS;
  coerceDisplayInfo:ADDRESS;
  batchItems:TagItemPtr;
  vpModeID:LONGCARD;
  palExtra:PaletteExtraPtr;
  spriteBaseEven:CARDINAL;
  spriteBaseOdd:CARDINAL;
  bp0Base:CARDINAL;
  bp1Base:CARDINAL;
 END;

(* if Type == 0 then ColorMap is V1.2/V1.3 compatible *)
(* if Type != 0 then ColorMap is V38	   compatible *)
(* the system will never create other than V39 type colormaps when running V39 *)

 PaletteExtra=RECORD      (* structure may be extended so watch out! *)
        semaphore:SignalSemaphore;  (* shared semaphore for arbitration	*)
        firstFree:CARDINAL;         (* *private*				*)
        nFree:CARDINAL;             (* number of free colors		*)
        firstShared:CARDINAL;			  (* *private*				*)
        nShared:CARDINAL;	          (* *private*				*)
        refCnt:ADDRESS;	            (* *private*				*)
        allocList:ADDRESS;			    (* *private*				*)   
        viewPort:ViewPortPtr;       (* back pointer to viewport		*)
        sharableColors:CARDINAL;    (* the number of sharable colors.	*)
       END;

CONST
(* flags values for ObtainPen *)
 penExclusive=0;
 penNoSetColor=1;

(* precision values for ObtainBestPen : *)
 precisionExact=-1;
 precisionImage=0;
 precisionIcon=16;
 precisionGui=32;

(* tags for ObtainBestPen: *)
 opbPrecision=84000000H;
 opbFailIfBad=84000001H;

(* From V39, MakeVPort() will return an error if there is not enough memory,
 * or the requested mode cannot be opened with the requested depth with the
 * given bitmap (for higher bandwidth alignments).
 *)
 mvpOk=0;           (* you want to see this one *)
 mvpNoMem=1;        (* insufficient memory for intermediate workspace *)
 mvpNoVpe=2;        (* ViewPort does not have a ViewPortExtra, and
            				 * insufficient memory to allocate a temporary one.
                     *)
 mvpNoDspIns=3;     (* insufficient memory for intermidiate copper
            				 * instructions.
            				 *)
 mvpNoDisplay=4;    (* BitMap data is misaligned for this viewport's
            				 * mode and depth - see AllocBitMapData().
            				 *)

(* From V39, MrgCop() will return an error if there is not enough memory,
 * or for some reason MrgCop() did not need to make any copper lists.
 *)
 mcopOk=0;    (* you want to see this one *)
 mcopNoMem=1; (* insufficient memory to allocate the system
       				 * copper lists.
			      	 *)
 mcopNop=2;   (* MrgCop() did not merge any copper lists
      				 * (eg, no ViewPorts in the list, or all marked as
      				 * hidden).
      				 *)

TYPE
 DBufInfo=RECORD
  link1:ADDRESS;
  count1:LONGCARD;
  safeMessage:Message; (* replied to when safe to write to old bitmap *)
  userData1:ADDRESS;   (* first user data *)                            
  link2:ADDRESS;
  count2:LONGCARD;
  dispMessage:Message;(* replied to when new bitmap has been displayed at least once *)
  userData2:ADDRESS;  (* second user data *)
  matchLong:LONGCARD;
  copPtr1:ADDRESS;
  copPtr2:ADDRESS;
  copPtr3:ADDRESS;
  beamPos1:CARDINAL;
  beamPos2:CARDINAL;
 END;

END GraphicsD.

@endnode
