@database IntuitionD
@node Main "IntuitionD"

Constants

   @{" autoBackPen " link Modul 440}                 @{" autoDrawMode " link Modul 441}                @{" autoFrontPen " link Modul 438}
   @{" autoITextFont " link Modul 444}               @{" autoLeftEdge " link Modul 442}                @{" autoNextText " link Modul 445}
   @{" autoTopEdge " link Modul 443}                 @{" boolGadget " link Modul 223}                  @{" boolMask " link Modul 299}
   @{" close " link Modul 220}                       @{" customGadget " link Modul 227}                @{" gMoreBounds " link Modul 238}
   @{" gMoreGadgetHelp " link Modul 239}             @{" gMoreScrollRaster " link Modul 240}           @{" gadgHComp " link Modul 205}
   @{" gadgHNone " link Modul 204}                   @{" gadgHighbits " link Modul 202}                @{" gadget0002 " link Modul 224}
   @{" gadgetType " link Modul 207}                  @{" gzzGadget " link Modul 210}                   @{" highFlags " link Modul 120}
   @{" highImage " link Modul 119}                   @{" highNone " link Modul 121}                    @{" intuitionName " link Modul 33}
   @{" knobHmin " link Modul 340}                    @{" knobVmin " link Modul 338}                    @{" maxBody " link Modul 341}
   @{" maxPot " link Modul 342}                      @{" menuEnabled " link Modul 117}                 @{" propGadget " link Modul 225}
   @{" reqGadget " link Modul 211}                   @{" sDownBack " link Modul 219}                   @{" sDragging " link Modul 215}
   @{" sUpFront " link Modul 217}                    @{" scrGadget " link Modul 209}                   @{" sizing " link Modul 213}
   @{" strGadget " link Modul 226}                   @{" sysGadget " link Modul 208}                   @{" wDownBack " link Modul 218}
   @{" wDragging " link Modul 214}                   @{" wUpFront " link Modul 216}                 

Type-Declarations

   @{" ActivationFlagSet " link Modul 200}           @{" ActivationFlags " link Modul 193}             @{" BoolInfo " link Modul 306}
   @{" BoolInfoPtr " link Modul 41}                 @{" Border " link Modul 477}                      @{" BorderPtr " link Modul 43}
   @{" ColorSpecPtr " link Modul 44}                @{" DrawInfoPtr " link Modul 45}                 @{" EasyStructPtr " link Modul 46}
   @{" ExtGadget " link Modul 289}                   @{" ExtGadgetPtr " link Modul 48}                @{" ExtIntuiMessagePtr " link Modul 47}
   @{" ExtNewScreenPtr " link Modul 49}             @{" ExtNewWindowPtr " link Modul 50}             @{" Gadget " link Modul 242}
   @{" GadgetFlagSet " link Modul 191}               @{" GadgetFlags " link Modul 184}                 @{" GadgetInfoPtr " link Modul 51}
   @{" GadgetPtr " link Modul 52}                   @{" GpGoInactivePtr " link Modul 53}             @{" GpHitTestPtr " link Modul 54}
   @{" GpInputPtr " link Modul 55}                  @{" GpLayoutPtr " link Modul 56}                 @{" GpRenderPtr " link Modul 57}
   @{" IBoxPtr " link Modul 58}                     @{" IClassPtr " link Modul 59}                   @{" IDCMPFlags " link Modul 545}
   @{" Image " link Modul 492}                       @{" ImagePtr " link Modul 60}                    @{" ImpDrawPtr " link Modul 61}
   @{" ImpErasePtr " link Modul 62}                 @{" ImpFrameBoxPtr " link Modul 63}              @{" ImpHitTestPtr " link Modul 64}
   @{" IntuiMessagePtr " link Modul 65}             @{" IntuiText " link Modul 454}                   @{" IntuiTextPtr " link Modul 66}
   @{" IntuitionBasePtr " link Modul 67}            @{" Menu " link Modul 96}                        @{" MenuItem " link Modul 123}
   @{" MenuItemFlagSet " link Modul 114}             @{" MenuItemFlags " link Modul 109}               @{" MenuItemPtr " link Modul 68}
   @{" MenuPtr " link Modul 69}                     @{" NewScreenPtr " link Modul 70}                @{" NewWindowPtr " link Modul 71}
   @{" ObjectPtr " link Modul 73}                   @{" OpAddTailPtr " link Modul 74}                @{" OpGetPtr " link Modul 72}
   @{" OpMemberPtr " link Modul 76}                 @{" OpSetPtr " link Modul 75}                    @{" OpUpdatePtr " link Modul 77}
   @{" PGXPtr " link Modul 78}                      @{" PreferencesPtr " link Modul 79}              @{" PropInfo " link Modul 350}
   @{" PropInfoFlagSet " link Modul 336}             @{" PropInfoFlags " link Modul 331}               @{" PropInfoPtr " link Modul 80}
   @{" PubScreenNodePtr " link Modul 81}            @{" RememberPtr " link Modul 82}                 @{" Requester " link Modul 159}
   @{" RequesterFlagSet " link Modul 157}            @{" RequesterFlags " link Modul 150}              @{" RequesterPtr " link Modul 83}
   @{" ScreenBufferPtr " link Modul 84}             @{" ScreenPtr " link Modul 85}                   @{" StringExtendPtr " link Modul 86}
   @{" StringInfo " link Modul 400}                  @{" StringInfoPtr " link Modul 87}               @{" TabletDataPtr " link Modul 88}
   @{" TabletHookDataPtr " link Modul 89}           @{" WindowPtr " link Modul 90}                

@endnode
@node Modul "am2:ModuleRefs/IntuitionD.def"
(**************************************************************************)
(*                                                                        *)
(* Definition Module IntuitionD.Def Marcel Timmermans.                    *)
(* Date     : 19 Feb 1994                                                 *)
(* Language : Modula-2                                                    *)
(*                                                                        *)
(**************************************************************************)

(*$ Implementation- *)
DEFINITION MODULE IntuitionD;

FROM SYSTEM IMPORT ADDRESS,SHORTSET,BITSET,BYTE,LONGSET,CAST;

FROM ExecD IMPORT
 Interrupt,IOStdReq,Library,List,ListPtr,MemReqSet,Message,MinNode,
 MsgPortPtr,SignalSemaphore,Node,TaskPtr;

FROM GraphicsD IMPORT
 jam2,BitMap,BitMapPtr,ClipRect,DBufInfoPtr,DrawModeSet,GfxBasePtr,
 LayerInfo,LayerPtr,Point,RastPort,RastPortPtr,RegionPtr,
 SimpleSpritePtr,TextAttr,TextAttrPtr,TextFontPtr,TmpRas,View,
 ViewModeSet,ViewPort,ViewPortPtr,ViewPtr;

FROM UtilityD IMPORT
 TagItemPtr,tagUser,HookPtr,Hook;

FROM InputEvent IMPORT
 lButton,rButton,upPrefix,InputEvent,InputEventPtr,
 Qualifiers,QualifierSet,mButton;

FROM Timer IMPORT TimeVal;
FROM KeyMapD IMPORT KeyMapPtr;

CONST
 intuitionName="intuition.library";

(*
 * All pointers are listed here (sorted), because many records have 
 * references to all kind of pointers.
 *)

TYPE
 BoolInfoPtr=POINTER TO BoolInfo;
 BorderPtr=POINTER TO Border;
 ColorSpecPtr=POINTER TO ColorSpec;
 DrawInfoPtr=POINTER TO DrawInfo;
 EasyStructPtr=POINTER TO EasyStruct;
 ExtIntuiMessagePtr=POINTER TO ExtIntuiMessage;
 ExtGadgetPtr=POINTER TO ExtGadget;
 ExtNewScreenPtr=POINTER TO ExtNewScreen;
 ExtNewWindowPtr=POINTER TO ExtNewWindow;
 GadgetInfoPtr=POINTER TO GadgetInfo;
 GadgetPtr=POINTER TO Gadget;
 GpGoInactivePtr=POINTER TO GpGoInactive;
 GpHitTestPtr=POINTER TO GpHitTest;
 GpInputPtr=POINTER TO GpInput;
 GpLayoutPtr=POINTER TO GpLayout;
 GpRenderPtr=POINTER TO GpRender;
 IBoxPtr=POINTER TO IBox;
 IClassPtr=POINTER TO IClass;
 ImagePtr=POINTER TO Image;
 ImpDrawPtr=POINTER TO ImpDraw;
 ImpErasePtr=POINTER TO ImpErase;
 ImpFrameBoxPtr=POINTER TO ImpFrameBox;
 ImpHitTestPtr=POINTER TO ImpHitTest;
 IntuiMessagePtr=POINTER TO IntuiMessage;
 IntuiTextPtr=POINTER TO IntuiText;
 IntuitionBasePtr=POINTER TO IntuitionBase;
 MenuItemPtr=POINTER TO MenuItem;
 MenuPtr=POINTER TO Menu;
 NewScreenPtr=POINTER TO NewScreen;
 NewWindowPtr=POINTER TO NewWindow;
 OpGetPtr=POINTER TO OpGet;
 ObjectPtr=POINTER TO Object;
 OpAddTailPtr=POINTER TO OpAddTail;
 OpSetPtr=POINTER TO OpSet;
 OpMemberPtr=POINTER TO OpMember;
 OpUpdatePtr=POINTER TO OpUpdate;
 PGXPtr=POINTER TO PGX;
 PreferencesPtr=POINTER TO Preferences;
 PropInfoPtr=POINTER TO PropInfo;
 PubScreenNodePtr=POINTER TO PubScreenNode;
 RememberPtr=POINTER TO Remember;
 RequesterPtr=POINTER TO Requester;
 ScreenBufferPtr=POINTER TO ScreenBuffer;
 ScreenPtr=POINTER TO Screen;
 StringExtendPtr=POINTER TO StringExtend;
 StringInfoPtr=POINTER TO StringInfo;
 TabletDataPtr=POINTER TO TabletData;
 TabletHookDataPtr=POINTER TO TabletHookData;
 WindowPtr=POINTER TO Window;

(*- intuition.h -*)
(* ======================================================================== *)
(* === Menu =============================================================== *)
(* ======================================================================== *)
TYPE
 Menu=RECORD
  nextMenu:MenuPtr;         (* same level *)                  
  leftEdge,topEdge:INTEGER; (* position of the select box *)
  width,height:INTEGER;     (* dimensions of the select box *)      
  flags:BITSET;             (* see flag definitions below *) 
  menuName:ADDRESS;         (* text for this Menu Header *)   
  firstItem:MenuItemPtr;
  (* these mysteriously-named variables are for internal use only *)
  jazzX,jazzY,beatX,beatY:INTEGER;
 END;

(* FLAGS SET BY THE APPLIPROG *)
 MenuItemFlags=(
  checkIt,itemText,commSeq,menuToggle,itemEnabled,mif5,
  highComp,highBox,checked,mif9,mif10,mif11,isDrawn,
  highItem,menuToggled,mif15
 );
 MenuItemFlagSet=SET OF MenuItemFlags;


CONST
 menuEnabled=0;
 highImage=MenuItemFlagSet{};
 highFlags=MenuItemFlagSet{highBox,highComp};
 highNone=MenuItemFlagSet{highBox,highComp};

TYPE
(* ======================================================================== *)
(* === MenuItem =========================================================== *)
(* ======================================================================== *)
 MenuItem=RECORD
  nextItem:MenuItemPtr;     (* pointer to next in chained list *)
  leftEdge,topEdge:INTEGER; (* position of the select box *)
  width,height:INTEGER;     (* dimensions of the select box *)
  flags:MenuItemFlagSet;    (* see the defines above *)          

  mutualExclude:LONGSET;    (* set bits mean this item excludes that *)
  itemFill:ADDRESS;         (* points to Image, IntuiText, or NULL *)

  (* when this item is pointed to by the cursor and the items highlight
   * mode HIGHIMAGE is selected, this alternate image will be displayed
   *)
  selectFill:ADDRESS;       (* points to Image, IntuiText, or NULL *)
  command:CHAR;             (* only if appliprog sets the COMMSEQ flag *)
  subItem:MenuItemPtr;      (* if non-zero, points to MenuItem for submenu *)

  (* The NextSelect field represents the menu number of next selected
   *	item (when user has drag-selected several items)
   *)
  nextSelect:CARDINAL;  
 END;

(* FLAGS SET BY THE APPLIPROG *)
 RequesterFlags=(
  pointRel,preDrawn,noisyReq,rf3,simpleReq,
  (* New for V36		*)
  useReqImage,noReqBackFill,rf7,rf8,rf9,rf10,rf11,
  (* FLAGS SET BY INTUITION *)
  reqOffWindow,reqActive,sysRequest,deferRefresh
 );
 RequesterFlagSet=SET OF RequesterFlags;

 Requester=RECORD
  olderRequest:RequesterPtr;
  leftEdge,topEdge:INTEGER; (* dimensions of the entire box *)
  width,height:INTEGER;     (* dimensions of the entire box *)
  relLeft,relTop:INTEGER;   (* for Pointer relativity offsets *)
  reqGadget:GadgetPtr;      (* pointer to a list of Gadgets *)
  reqBorder:BorderPtr;      (* the box's border *)
  reqText:IntuiTextPtr;     (* the box's text *)
  flags:RequesterFlagSet;   (* see definitions above *)         
  backFill:SHORTCARD;       (* pen number for back-plane fill before draws *)
  reqLayer:LayerPtr;        (* Layer in place of clip rect	*)
  reqPad1:ARRAY [0..31] OF BYTE;

    (* If the BitMap plane pointers are non-zero, this tells the system
     * that the image comes pre-drawn (if the appliprog wants to define
     * its own box, in any shape or size it wants!);  this is OK by
     * Intuition as long as there's a good correspondence between
     * the image and the specified Gadgets
     *)
  imageBMap:BitMapPtr;  (* points to the BitMap of PREDRAWN imagery *)
  rWindow:WindowPtr;    (* added.  points back to Window *)            
  reqImage:ImagePtr;    (* new for V36: drawn if USEREQIMAGE set *)
  reqPad2:ARRAY [0..31] OF BYTE;
 END;

 GadgetFlags=(
  gadgHBox,gadgHImage,gadgImage,gRelBottom,gRelRight,
  gRelWidth,gRelHeight,selected,gadgDisabled,
  tabCycle,stringExtend,imageDisable,
  labelString,labelImage,
  relSpecial,gfExtended
 );
 GadgetFlagSet=SET OF GadgetFlags;

TYPE
 ActivationFlags=(
  relVerify,gadgImmediate,endGadget,followMouse,
  rightBorder,leftBorder,topBorder,bottomBorder,
  toggleSelect,stringCenter,stringRight,longint,
  altKeyMap,boolExtend,activeGadget,borderSniff
 );
 ActivationFlagSet=SET OF ActivationFlags;

CONST
 gadgHighbits=CAST(GadgetFlagSet,03H);
 gadgHNone=GadgetFlagSet{gadgHBox,gadgHImage};
 gadgHComp=GadgetFlagSet{};

 gadgetType=CAST(BITSET,0FC00H);  (* all Gadget Global Type flags (padded) *)
 sysGadget=8000H; (* 1 = Allocated by the system, 0 = by app. *)
 scrGadget=4000H; (* 1 = ScreenGadget, 0 = WindowGadget *)
 gzzGadget=2000H; (* 1 = for WFLG_GIMMEZEROZERO borders *)
 reqGadget=1000H; (* 1 = this is a Requester Gadget *)          

 sizing=0010H;
 wDragging=0020H;
 sDragging=0030H;
 wUpFront=0040H;
 sUpFront=0050H;
 wDownBack=0060H;
 sDownBack=0070H;
 close=0080H;

(* application gadgets *)
 boolGadget=0001H;
 gadget0002=0002H;
 propGadget=0003H;
 strGadget=0004H;
 customGadget=0005H;

(* This bit in GadgetType is reserved for undocumented internal use
 * by the Gadget Toolkit, and cannot be used nor relied on by
 * applications:	0x0100
 *)

(* New for V39.  Gadgets which have the GFLG_EXTENDED flag set are
 * actually ExtGadgets, which have more flags.	The GMORE_xxx
 * identifiers describe those flags:
 *)
 gMoreBounds=0;
 gMoreGadgetHelp=1;
 gMoreScrollRaster=2;

TYPE
(* ======================================================================== *)
(* === Gadget ============================================================= *)
(* ======================================================================== *)
 Gadget=RECORD
  nextGadget:GadgetPtr;     (* next gadget in the list *)
  leftEdge,topEdge:INTEGER; (* "hit box" of gadget *)
  width,height:INTEGER;     (* "hit box" of gadget *)    
  flags:GadgetFlagSet;      (* see above for list of defines *)
  activation:ActivationFlagSet; (* see above for list of defines *)
  gadgetType:CARDINAL;

  (* appliprog can specify that the Gadget be rendered as either as Border
   * or an Image.  This variable points to which (or equals NULL if there's
   * nothing to be rendered about this Gadget)
   *)
  gadgetRender:ADDRESS;

  (* appliprog can specify "highlighted" imagery rather than algorithmic
   * this can point to either Border or Image data
   *)
  selectRender:ADDRESS;
  gadgetText:IntuiTextPtr;  (* text for this gadget *)

    (* MutualExclude, never implemented, is now declared obsolete.
     * There are published examples of implementing a more general
     * and practical exclusion in your applications.
     *
     * Starting with V36, this field is used to point to a hook
     * for a custom gadget.
     *
     * Programs using this field for their own processing will
     * continue to work, as long as they don't try the
     * trick with custom gadgets.
     *)
  CASE :INTEGER OF
  |0: mutualExclude:LONGSET;
  |1: hp:HookPtr;
  END;
  (* pointer to a structure of special data required by Proportional,
   * String and Integer Gadgets
   *)
  specialInfo:ADDRESS;
  gadgetID:INTEGER; (* user-definable ID field *)
  userData:ADDRESS; (* ptr to general purpose User data (ignored by In) *)
 END;

 ExtGadget=RECORD
  g:Gadget; (* This fields match struct Gadget exactly *)
  (* These fields only exist under V39 and only if GFLG_EXTENDED is set *)
  moreFlags:LONGSET;        (* see GMORE_ flags above *)
  boundsLeftEdge:INTEGER;   (* Bounding extent for gadget, valid   *)
  boundsTopEdge:INTEGER;    (* only if GMORE_BOUNDS is set.  The   *)
  boundsWidth:INTEGER;      (* GFLG_RELxxx flags affect these      *)
  boundsHeight:INTEGER;     (* coordinates as well.	       *)        
 END;

CONST
(* set BoolInfo.Flags to this flag bit.
 * in the future, additional bits might mean more stuff hanging
 * off of BoolInfo.Reserved.
 *)
 boolMask=1H; (* extension is for masked gadget *)

TYPE
(* ======================================================================== *)
(* === BoolInfo======================================================= *)
(* ======================================================================== *)
(* This is the special data needed by an Extended Boolean Gadget
 * Typically this structure will be pointed to by the Gadget field SpecialInfo
 *)
 BoolInfo=RECORD
  flags:BITSET; (* defined above *)
  mask:ADDRESS;	(* bit mask for highlighting and selecting
            		 * mask must follow the same rules as an Image
                 * plane.  Its width and height are determined
            		 * by the width and height of the gadget's
            		 * select box. (i.e. Gadget.Width and .Height).
            		 *)

  reserved:LONGCARD; (* set to 0	*)
 END;

(* --- FLAG BITS ---------------------------------------------------------- *)
(* NOTE: if you do not use an AUTOKNOB for a proportional gadget,
 * you are currently limited to using a single Image of your own
 * design: Intuition won't handle a linked list of images as
 * a proportional gadget knob.
 *)
 PropInfoFlags=(
  autoKnob,freeHoriz,freeVert,propBorderless,
  propNewLook,pf5,pf6,pf7,
  knobHit,pf9,pf10,pf11,pf12,pf13,pf14,pf15
 );
 PropInfoFlagSet=SET OF PropInfoFlags;

CONST
 knobVmin=4;
 knobHmin=6;
 maxBody=0FFFFH;
 maxPot=0FFFFH;

(* ======================================================================== *)
(* === PropInfo =========================================================== *)
(* ======================================================================== *)
(* this is the special data required by the proportional Gadget
 * typically, this data will be pointed to by the Gadget variable SpecialInfo
 *)
TYPE
 PropInfo=RECORD
  flags:PropInfoFlagSet;(* general purpose flag bits (see defines above) *)

    (* You initialize the Pot variables before the Gadget is added to
     * the system.  Then you can look here for the current settings
     * any time, even while User is playing with this Gadget.  To
     * adjust these after the Gadget is added to the System, use
     * ModifyProp();  The Pots are the actual proportional settings,
     * where a value of zero means zero and a value of MAXPOT means
     * that the Gadget is set to its maximum setting.
     *)

  horizPot:CARDINAL; (* 16-bit FixedPoint horizontal quantity percentage *)
  vertPot:CARDINAL;  (* 16-bit FixedPoint vertical quantity percentage *)  

    (* the 16-bit FixedPoint Body variables describe what percentage of
     * the entire body of stuff referred to by this Gadget is actually
     * shown at one time.  This is used with the AUTOKNOB routines,
     * to adjust the size of the AUTOKNOB according to how much of
     * the data can be seen.  This is also used to decide how far
     * to advance the Pots when User hits the Container of the Gadget.
     * For instance, if you were controlling the display of a 5-line
     * Window of text with this Gadget, and there was a total of 15
     * lines that could be displayed, you would set the VertBody value to
     *	   (MAXBODY / (TotalLines / DisplayLines)) = MAXBODY / 3.
     * Therefore, the AUTOKNOB would fill 1/3 of the container, and
     * if User hits the Cotainer outside of the knob, the pot would
     * advance 1/3 (plus or minus) If there's no body to show, or
     * the total amount of displayable info is less than the display area,
     * set the Body variables to the MAX.  To adjust these after the
     * Gadget is added to the System, use ModifyProp();
     *)
  horizBody:CARDINAL; (* horizontal Body *)
  vertBody:CARDINAL;  (* vertical Body *)  

    (* these are the variables that Intuition sets and maintains *)
  cWidth:CARDINAL;  (* Container width (with any relativity absoluted) *)
  cHeight:CARDINAL; (* Container height (with any relativity absoluted) *)
  hPotRes,vPotRes:CARDINAL; (* pot increments *)
  leftBorder:CARDINAL;  (* Container borders *)
  topBorder:CARDINAL;   (* Container borders *)
 END;

(* ======================================================================== *)
(* === StringInfo ========================================================= *)
(* ======================================================================== *)
(* this is the special data required by the string Gadget
 * typically, this data will be pointed to by the Gadget variable SpecialInfo
 *)
TYPE
 StringInfo=RECORD
    (* you initialize these variables, and then Intuition maintains them *)
  buffer:ADDRESS;     (* the buffer containing the start and final string *)
  undoBuffer:ADDRESS; (* optional buffer for undoing current entry *)
  bufferPos:INTEGER;  (* character position in Buffer *)
  maxChars:INTEGER;   (* max number of chars in Buffer (including NULL) *)
  dispPos:INTEGER;    (* Buffer position of first displayed character *)    

    (* Intuition initializes and maintains these variables for you *)
  undoPos:INTEGER;    (* character position in the undo buffer *)
  numChars:INTEGER;   (* number of characters currently in Buffer *)
  dispCount:INTEGER;  (* number of whole characters visible in Container *)
  cLeft,cTop:INTEGER; (* topleft offset of the container *)                 

    (* This unused field is changed to allow extended specification
     * of string gadget parameters.  It is ignored unless the flag
     * GACT_STRINGEXTEND is set in the Gadget's Activation field
     * or the GFLG_STRINGEXTEND flag is set in the Gadget Flags field.
     * (See GFLG_STRINGEXTEND for an important note)
     *)
    (* struct Layer *LayerPtr;	--- obsolete --- *)
  extension:StringExtendPtr;

 (* you can initialize this variable before the gadget is submitted to
     * Intuition, and then examine it later to discover what integer
     * the user has entered (if the user never plays with the gadget,
     * the value will be unchanged from your initial setting)
     *)
     longInt:LONGINT;
    (* If you want this Gadget to use your own Console keymapping, you
     * set the GACT_ALTKEYMAP bit in the Activation flags of the Gadget,
     * and then set this variable to point to your keymap.  If you don't
     * set the GACT_ALTKEYMAP, you'll get the standard ASCII keymapping.
     *)
  altKeyMap:KeyMapPtr;
 END;

CONST
 autoFrontPen=0;
 autoBackPen=1;
 autoDrawMode=jam2;
 autoLeftEdge=6;
 autoTopEdge=3;
 autoITextFont=NIL;
 autoNextText=NIL;

(* ======================================================================== *)
(* === IntuiText ========================================================== *)
(* ======================================================================== *)
(* IntuiText is a series of strings that start with a location
 *  (always relative to the upper-left corner of something) and then the
 *  text of the string.  The text is null-terminated.
 *)
TYPE
 IntuiText=RECORD
  frontPen,backPen:SHORTCARD; (* the pen numbers for the rendering *)
  drawMode:DrawModeSet;       (* the mode for rendering the text *)
  leftEdge:INTEGER;           (* relative start location for the text *)
  topEdge:INTEGER;            (* relative start location for the text *)
  iTextFont:TextAttrPtr;      (* if NULL, you accept the default *)
  iText:ADDRESS;              (* pointer to null-terminated text *)
  nextText:IntuiTextPtr;      (* pointer to another IntuiText to render *)
 END;

(* ======================================================================== *)
(* === Border ============================================================= *)
(* ======================================================================== *)
(* Data type Border, used for drawing a series of lines which is intended for
 *  use as a border drawing, but which may, in fact, be used to render any
 *  arbitrary vector shape.
 *  The routine DrawBorder sets up the RastPort with the appropriate
 *  variables, then does a Move to the first coordinate, then does Draws
 *  to the subsequent coordinates.
 *  After all the Draws are done, if NextBorder is non-zero we call DrawBorder
 *  on NextBorder
 *)
 Border=RECORD
  leftEdge,topEdge:INTEGER;   (* initial offsets from the origin *)
  frontPen,backPen:SHORTCARD; (* pens numbers for rendering *)
  drawMode:DrawModeSet;       (* mode for rendering *)
  count:SHORTCARD;            (* number of XY pairs *)
  xy:ADDRESS;                 (* vector coordinate pairs rel to LeftTop *)
  nextBorder:BorderPtr;       (* pointer to any other Border too *)       
 END;

(* ======================================================================== *)
(* === Image ============================================================== *)
(* ======================================================================== *)
(* This is a brief image structure for very simple transfers of
 * image data to a RastPort
 *)
 Image=RECORD
  leftEdge:INTEGER; (* starting offset relative to some origin *)
  topEdge:INTEGER;  (* starting offsets relative to some origin *)
  width:INTEGER;    (* pixel size (though data is word-aligned) *)
  height:INTEGER;
  depth:INTEGER;
  imageData:ADDRESS;  (* >= 0, for images you create		*)

    (* the PlanePick and PlaneOnOff variables work much the same way as the
     * equivalent GELS Bob variables.  It's a space-saving
     * mechanism for image data.  Rather than defining the image data
     * for every plane of the RastPort, you need define data only
     * for the planes that are not entirely zero or one.  As you
     * define your Imagery, you will often find that most of the planes
     * ARE just as color selectors.  For instance, if you're designing
     * a two-color Gadget to use colors one and three, and the Gadget
     * will reside in a five-plane display, bit plane zero of your
     * imagery would be all ones, bit plane one would have data that
     * describes the imagery, and bit planes two through four would be
     * all zeroes.  Using these flags avoids wasting all
     * that memory in this way:  first, you specify which planes you
     * want your data to appear in using the PlanePick variable.  For
     * each bit set in the variable, the next "plane" of your image
     * data is blitted to the display.	For each bit clear in this
     * variable, the corresponding bit in PlaneOnOff is examined.
     * If that bit is clear, a "plane" of zeroes will be used.
     * If the bit is set, ones will go out instead.  So, for our example:
     *	 Gadget.PlanePick = 0x02;
     *	 Gadget.PlaneOnOff = 0x01;
     * Note that this also allows for generic Gadgets, like the
     * System Gadgets, which will work in any number of bit planes.
     * Note also that if you want an Image that is only a filled
     * rectangle, you can get this by setting PlanePick to zero
     * (pick no planes of data) and set PlaneOnOff to describe the pen
     * color of the rectangle.
     *
     * NOTE:  Intuition relies on PlanePick to know how many planes
     * of data are found in ImageData.	There should be no more
     * '1'-bits in PlanePick than there are planes in ImageData.
     *)
  planePick,planeOnOff:SHORTCARD;

    (* if the NextImage variable is not NULL, Intuition presumes that
     * it points to another Image structure with another Image to be
     * rendered
     *)
  nextImage:ImagePtr;
 END;

(* --- IDCMP Classes ------------------------------------------------------ *)
(* Please refer to the Autodoc for OpenWindow() and to the Rom Kernel
 * Manual for full details on the IDCMP classes.
 *)
 IDCMPFlags=(
  sizeVerify,newSize,refreshWindow,mouseButtons,
  mouseMove,gadgetDown,gadgetUp,reqSet,menuPick,closeWindow,
  rawKey,reqVerify,reqClear,menuVerify,newPrefs,diskInserted,
  diskRemoved,wbenchMessage,activeWindow,inactiveWindow,
  deltaMove,vanillaKey,intuiTicks,idcmpUpdate,
  menuHelp,changeWindow
@endnode
