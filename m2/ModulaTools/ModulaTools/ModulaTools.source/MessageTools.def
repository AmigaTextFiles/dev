(******************************************************************************)
(*                                                                            *)
(*    The global constants and variables defined in this module are optional: *)
(* if you don't want to access their features, you needn't import them into   *)
(* your program. The variables in the parameter lists of the procedures are   *)
(* the only variables you are required to supply.                             *)
(*    When describing the order in which certain routines are called, I have  *)
(* adopted the curly-bracket notation of EBNF: routines in curly brackets {}  *)
(* may be called an arbitrary number of times (0 to n). A, {B}, {C, {D}} thus *)
(* implies that A is called once, followed by an arbitrary number of calls to *)
(* to B, followed by an arbitrary number of calls to C. Each of the calls to  *)
(* C may be followed by an arbitrary number of calls to D. Likewise, {{C},{D}}*)
(* implies an arbitrary number of calls to C and D in any order.              *)
(*                                                                            *)
(******************************************************************************)
(*                                                                            *)
(*  Version 1.00a.002 (Beta) :   March 2, 1988                                *)
(*                                                                            *)
(*    These procedures were originally written under version 1.20 of the TDI  *)
(* Modula-2 compiler. I have rewritten this module to operate under the v2.00 *)
(* compiler. However, should you find any problem or inconsistency with the   *)
(* functionality of this code, please contact me at the following address:    *)
(*                                                                            *)
(*                               Jerry Mack                                   *)
(*                               23 Prospect Hill Ave.                        *)
(*                               Waltham, MA   02154                          *)
(*                                                                            *)
(*    Check the module MenuUtils for TDI's (considerably less powerful) ver-  *)
(* sions of my Menu and IntuitionText procedures. The modules GadgetUtils and *)
(* EasyGadgets should also be of great help.                                  *)
(*                                                                            *)
(******************************************************************************)
(*                                                                            *)
(*    The source code to MessageTools is in the public domain. You may do     *)
(* with it as you please.                                                     *)
(*                                                                            *)
(******************************************************************************)

DEFINITION MODULE MessageTools;

FROM Intuition       IMPORT WindowPtr, MenuPtr, MenuItemPtr, IntuiMessagePtr;

TYPE
   ChoiceType = RECORD
                   MenuChosen    : CARDINAL;
                   ItemChosen    : CARDINAL;
                   SubItemChosen : CARDINAL;
                   ChoicePointer : MenuItemPtr;
                END; (* ChoiceType *)


   PROCEDURE GotMessage     (VAR IMessage   : IntuiMessagePtr;
                             CurrentWindow  : WindowPtr)     : BOOLEAN;

   PROCEDURE GetMenuChoice  (MenuSelection  : CARDINAL;        (* Input  *)
                             FirstMenu      : MenuPtr;         (* Input  *)
                             VAR MenuChoice : ChoiceType);     (* Output *)

 (* GotMessage quickly copies any message from Intuition and returns the *)
 (* original to Intuition. This helps reduce the number of IntuiMessages *)
 (* Intuition allocates. Since Intuition doesn't deallocate them unless  *)
 (* it is reinitialized, this is definitely a desireable practice. Also, *)
 (* Imessage is DISPOSEd of if it is non-NULL upon entering GotMessage.  *)
 (* This means you don't have to worry about disposing of the copies of  *)
 (* the Intuition messages, either. If IMessage^.Class = MenuPick, then  *)
 (* you may obtain the (Sub)Item chosen by calling GetMenuChoice. If no  *)
 (* message was pending from Intuition, then GotMessage returns FALSE.   *)
 (* CurrentWindow is the only input, pointing to the Window in which you *)
 (* wish to determine whether an Intuition message is pending.           *)
 
 (* GetMenuChoice determines the FIRST (Sub)Item chosen, and returns a   *)
 (* a pointer to it. Be certain to check the NextSelect field of the cho-*)
 (* sen (Sub)Item, as it is possible to click-select or drag-select mul- *)
 (* tiple choices before releasing the right mousebutton. Thus, MenuSe-  *)
 (* lection will be either IMessage^.Code or ChoicePointer^.NextSelect.  *)


END MessageTools.
