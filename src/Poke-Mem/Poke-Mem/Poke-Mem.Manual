
         Poking Memory Loctaions Using Python Version 1.4x Minimum.
         ----------------------------------------------------------

  Minimum Requirements Are:-
  --------------------------

         Stock AMIGA A1200(HD), 68EC020 and upwards.

         A FULL, standard, OS3.0x+ installation.

         A FULL, Python Version 1.4x minimum installation, available on
         AMINET at:-

                 http://main.aminet.net/dev/lang/Python_14.lha

----------------------------------------------------------------------------

                            OPTIONAL COMPONENTS.
                            --------------------

         AF2005/WinUAE along with 'Python Version 2.0x'. :)

                 http://main.aminet.net/dev/lang/Python20.lha

         'Peek-Mem.lha' can be found at:-

                 http://main.aminet.net/dev/src/Peek-Mem.lha

         'ACE-Basic Compiler' is not required as the compiled executable(s)
         IS/ARE supplied. It can be found, IF required, on AMINET at:-

                 http://main.aminet.net/dev/basic/ace24dist.lha

============================================================================

  Preface:-
  ---------

  As an addendum to my 'Peek-Mem.lha' I decided to release this version of
  poking classic AMIGA memory locations using Python Version 1.4x minimum.

  I will NOT be releasing the ~ANSI C~ version of the source code BUT my
  ACE-Basic compiler version instead. SORRY... :(

  This makes the idea purely AMIGA specific so if you want to 'TRY' and
  port this idea to other platforms then you will HAVE write your own ~C~
  source and compile it to do this task, assuming that it will work!!!

  I HOLD NO RESPONSIBILITY FOR WHAT MIGHT HAPPEN!!!

  This is VERY, VERY dangerous computer wise so be VERY, VERY careful when
  using it.

  REMEMBER!!! Python IS NOT AWARE OF SUCH THINGS AS 'ENFORCER HITS' SO BE
  VERY AWARE YOURSELF BEFORE POKING RANDOM MEMORY LOCATIONS ON HIGH END
  AMIGAS; READ 'The Legal Stuff:-' BELOW...

  Now having said that I needed this for classic AMIGA hardware access using
  Python to try and integrate it with some of my simple projects for the
  classic AMIGA range of computers. These Python programs will be released
  in due course.

         THIS LUNATIC IDEA IS COPYRIGHT, (C)2007, B.Walker, G0LCU.

  Enjoy... :)

----------------------------------------------------------------------------

  The Archive:-
  -------------

  In the archive are three items from 'Peek-Mem.lha' along with the POKEB
  and POKEW requirements.

  The archive is as follows:-

  mempoke.py - 'pokemem.py' WITHOUT all of the comments.
  mempokeb.b - 'pokeb.b' WITHOUT all of the comments.
  peek - A compiled version of 'print-peek.c' from 'Peek-Mem.lha'.
  peekb - Exactly the same as 'peek'.
  peekmem.py - The DEFAULT Python code for memory peeking from the above.
  peekw - A compiled version of 'print-peekw.c' from 'Peek-Mem.lha'.
  poke - A universal method of poking byte OR word values.
  Poke-Mem.Manual - The main manual in standard ASCII text format.
  Poke-Mem.readme - The AMINET readme file.
  poke.b - The ACE Basic Compiler source written in 'baby BASIC'... :)
  pokeb - The executable code of 'pokeb.b' for byte values ONLY.
  pokeb.b - The ACE Basic Compiler source written in 'baby BASIC'... :)
  pokemem-word.py - Python code to poke word values to memory addresses.
  pokemem.py - The DEFAULT Python code to poke byte values to memory addresses.
  pokew - The executable code for word values only.
  pokeb.b - The ACE Basic Compiler source written in 'baby BASIC'... :)

  NOTE:- I have NOT included 'pokel' and 'pokel.b' the executable and
  ACE Basic source for longword values as a simple set of changes to the
  childishly simple 'pokew.b' and re-compiling is enough to get you there.

  Have fun and enjoy finding simple solutions to often difficult problems
  involving computers AND programming in Python... :)

----------------------------------------------------------------------------

  Setting Up For Usage:-
  ----------------------

  It is assumed that Python is installed AND 'PYTHON:' is the volume name
  where the Python executable resides. Copy 'pokemem.py' to the
  'PYTHON:Lib/' drawer, (and 'peekmem.py' also IF you haven't got it
  already). Copy 'pokeb' and 'pokew' to the 'PYTHON:' volume, (and 'peekb'
  and 'peekw' to the 'PYTHON:' volume also IF you haven't got them already).

  IF 'peekb' IS required then rename it to 'peek' and see the archive:-

                http://main.aminet.net/dev/src/Peek-Mem.lha

  for further instructons......

  (......OR similarly if WORD values are needed, rename 'peekw' to peek
  and away you go... :)

----------------------------------------------------------------------------

  The Python Code, ('pokemem.py'):-
  ---------------------------------

# CAUTION!!! ...YOU USE THIS SOFTWARE AT YOUR OWN RISK!!!...
# POKEB ONLY memory using an executable. This is VERY dangerous, so be
# VERY, VERY careful. The idea is to use an executable to write a byte
# value into a register or memory. WORD capability is added also and LONG
# WORD transfers also work so it would theoretically be possible to access
# say the AMIGA PCMCIA slot and write a 16 Bit value to it using PYTHON
# WITHOUT ANY special additions, JUST the basic interpreter and its
# standard 'libraries'.

# This LUNATIC idea belongs to copyright, (C)2007, B.Walker, G0LCU.

# A matching BASIC source is issued to make the whole AMIGA specific.
# You brain-bods out there COULD make it work on other platforms IF you so
# desired BUT I hold NO responsibility for ANY problems that may arise.
# I am NOT releasing the 'ANSI C' source for this controversial method of
# writing to memory you will have to write your own 'ANSI C' code.
# The ACE Basic code makes this purely classic AMIGA specific.
# $VER: pokemem.py_Version_0.10.00_(C)01-01-2007_B.Walker_G0LCU.

# VERY IMPORTANT!!! THIS DEMONSTRATION CODE DOES NOT TAKE INTO ACCOUNT
# ANY TYPO' ERRORS. IN THEORY, THE ACE BASIC COMPILED EXECUTABLE WILL
# FORCE SOME TYPO' ERRORS TO ADDRESS 0 AND BYTE VALUE OF 0. SO BE VERY
# AWARE OF THIS. NOTE, THIS _IS_ AN ENFORCER HIT SO TREAT IT AS SUCH!!!

# Do any imports IF required.
import os

# Have it as an 'executeble' rather than an 'import'.
def main():
	# Set up any 'strings' or 'variables'.
	pokeaddress = '0'
	pokebyte = '0'
	# Use 'print' as a simple newline only.
	print
	print 'Poking a single memory location only...'
	print
	# Input 'pokeaddress' as ASCII numerical characters.
	# Typo' errors are NOT catered for. BEWARE!!!.
	pokeaddress = raw_input('Input address in decimal:- ')
	print
	# Input 'pokebyte' as ASCII numerical characters.
	# Typo' errors are NOT catered for. BEWARE!!!.
	pokebyte = raw_input('Input byte value in decimal:- ')
	# Do NOT allow a NULL string OR a RETURN/NEWLINE character!.
	if pokeaddress == '': pokeaddress = '0'
	if pokeaddress == chr(13): pokeaddress = '0'
	if pokeaddress == chr(10): pokeaddress = '0'
	if pokeaddress == chr(10) + chr(13): pokeaddress = '0'
	if pokeaddress == chr(13) + chr(10): pokeaddress = '0'
	# Do NOT allow a NULL string OR a RETURN/NEWLINE character!.
	if pokebyte == '': pokebyte = '0'
	if pokebyte == chr(13): pokebyte = '0'
	if pokebyte == chr(10): pokebyte = '0'
	if pokebyte == chr(10) + chr(13): pokebyte = '0'
	if pokebyte == chr(13) + chr(10): pokebyte = '0'
	# Now poke a byte value into memory WITH EXTREME CARE!!!
	os.system('PYTHON:pokeb ' + pokeaddress + ' ' + pokebyte)
	print
	print 'Now peek the same memory location as a test...'
	# Call peekmem.py as a check to see if it has worked.
	execfile('PYTHON:Lib/peekmem.py')
main()
# End of simple PYTHON 'executable'.

This is the DEFAULT Python code for this demonstration. It is a manual
method of poking values into memory. It can be changed to automatically
write to a classic AMIGA register for direct HW access. This would eliminate
any potential typo' erros that could occur.

  The Workings Of This Code:-
  ---------------------------

                !!!BEWARE WHEN RUNNING THE EXAMPLE BELOW!!!
                -------------------------------------------

  Start up Python Version 1.4x minimum and from the Python command line
  type this:-


>>> execfile('PYTHON:Lib/pokemem.py')<RETURN/ENTER>

Poking a single memory location only...

Input address in decimal:- 2<RETURN/ENTER>

Input byte value in decimal:- 123<RETURN/ENTER>

Now peek the same memory location as a test...

Input address in decimal:- 2<RETURN/ENTER>

Memory address in decimal is 2 and decimal byte value is 123

>>> _


  IMPORTANT!!! Rerun the program again and enter 2 for the 'address' AND 0
  for the 'byte' values to reset this address back to the correct state!!!
  THIS _IS_ AN ENRORCER HIT SO TREAT IT AS SUCH!!!

  After 'import'(ing) 'os' two strings are set up, 'pokeaddress' and
  'pokebyte'. These are initialised to ASCII '0'; 'pokeaddress' is then
  INPUT(ted) to give an ASCII numerical value of 0 to 16777215 the standard
  AMIGA 16MB boundary. Then 'pokebyte' is INPUT(ted) to give an ASCII
  numerical value of 0 to 255. A small amount of error correction is
  applied and these ASCII values passed on to the poking executable 'pokeb'.
  A large amount of error correction is applied by this executable and
  upon exitting returns back to this Python code. The Python code
  'peekmem.py' is called and once again the same 'address' is INPUT(ted)
  as before, IF all is correct and a VALID address is accessed then the
  returned value should be the same as the poked value. The Python code
  is then quitted back to the Python command line.

  To poke WORD sized values to memory, the line inside this code......

	os.system('PYTHON:pokeb ' + pokeaddress + ' ' + pokebyte)

  ......must be changed to......

	os.system('PYTHON:pokew ' + pokeaddress + ' ' + pokebyte)

  ......and away you go... :)

  REMEMBER!!! In 'pokew' mode, 'pokebyte' is NOW a 16 bit number from
  0 to 65535 decimal!!!

  ALTERNATIVELY USE THE Python CODE 'pokemem-word.py' AS THIS IS ALREADY
  PREPARED FOR YOU. AGAIN USE EXTREME CAUTION WHEN USING THIS PROGRAM!!!
  
----------------------------------------------------------------------------

  The ACE Basic Code, ('pokeb.b'):-
  ---------------------------------

REM CAUTION!!! ...YOU USE THIS SOFTWARE AT YOUR OWN RISK!!!...
REM Poking AMIGA memory using an A1200(HD) and Python Version 1.4.
REM Compiled using ACE Basic Compiler, (C)David Benn.
REM Original copyright for the idea, (C)20007, B.Walker, G0LCU.
REM This is very controversial BUT it works!!! :)
REM Written in what I call 'baby BASIC' for youngsters to
REM understand and expand on. :)

REM Deliberately limited to the A1200(HD) 16MB boundary.
REM WARNING!!!, all errors are corrected and changed to VALID
REM addresses and byte values. Addresses 0 to 3 are ENFORCER hits
REM so treat them as such!!!. Addresses 16252928 to 16777215
REM inclusive is the 1/2MB ROM area so don't bother poking around
REM that area.
REM $VER: pokeb.b_Version_0.10.00_(C)01-01-2007_B.Walker_G0LCU.

REM Set up all variables required.
  LET pokeaddress$="(C)G0LCU."
  LET pokevalue$="B.Walker."
  LET pokeaddress&=0
  LET pokevalue&=0
  LET n=0

REM Now obtain the required arguments from the 'command' line.
  LET pokeaddress$=ARG$(1)
  LET pokevalue$=ARG$(2)
  LET n=ARGCOUNT

REM Don't allow incorrect number of arguments, MUST be 2 for
REM ACE Basic Compiler, don't confuse with the ~ANSI C~ equivalent.
  IF n<=1 THEN GOSUB noerror:
  IF n>=3 THEN GOSUB noerror:

REM Don't allow any errors for 'pokeaddress$'. Force address 0
REM in the event of an error!!!.
  IF pokeaddress$="" THEN GOSUB noerror:
  IF pokeaddress$=CHR$(13) THEN GOSUB noerror:
  IF pokeaddress$=CHR$(10) THEN GOSUB noerror:
  IF pokeaddress$=(CHR$(10)+CHR$(13)) THEN GOSUB noerror:
  IF pokeaddress$=(CHR$(13)+CHR$(10)) THEN GOSUB noerror:
  IF LEN(pokeaddress$)<=0 THEN GOSUB noerror:
  IF LEN(pokeaddress$)>=9 THEN GOSUB noerror:

REM Don't allow any errors for 'pokevalue$'. Force a byte value
REM of 0 in the event of an error!!!.
  IF pokevalue$="" THEN GOSUB noerror:
  IF pokevalue$=CHR$(13) THEN GOSUB noerror:
  IF pokevalue$=CHR$(10) THEN GOSUB noerror:
  IF pokevalue$=(CHR$(10)+CHR$(13)) THEN GOSUB noerror:
  IF pokevalue$=(CHR$(13)+CHR$(13)) THEN GOSUB noerror:
  IF LEN(pokevalue$)<=0 THEN GOSUB noerror:
  IF LEN(pokevalue$)>=4 THEN GOSUB noerror:

REM Convert ASCII string to decimal numbers.
  LET pokeaddress&=VAL(pokeaddress$)
  LET pokevalue&=VAL(pokevalue$)

REM Ensure 'pokeaddress&' is in between 0 and 16777215.
  IF pokeaddress&<=0 THEN LET pokeaddress&=0
  IF pokeaddress&>=16777215 THEN LET pokeaddress&=16777215

REM Ensure 'pokevalue&' is in between 0 and 255.
  IF pokevalue&<=0 THEN LET pokevalue&=0
  IF pokevalue&>=255 THEN LET pokevalue&=255

REM Now place 'pokevalue&' into the memory location 'pokeaddress&'
REM and exit the program without a return code.
  POKE pokeaddress&,pokevalue&
  END

REM Do not allow an error, set address to ROM area and value of 0.
noerror:
  LET pokeaddress$="16777214"
  LET pokevalue$="0"
  RETURN 

This is the DEFAULT AMIGA executable and is compiled using ACE Basic
Compiler, (C)David Benn. I use it a great deal in AMIGA software development
as it is quick and convenient AND any source code becomes MACHINE specific.
This should give YOU an idea for YOUR 'ANSI C' source to 'TRY' and make the
whole package 'platform independant' should YOU so desire.

I HOLD NO RESPONSIBILITY FOR WHAT MIGHT HAPPEN IN AN ATTEMPT TO WRITE TO
RANDOM MEMORY ADDRESSES ON OTHER PLATFORMS!!!

The executable 'pokeb' CAN be used from the command line and entered
like this:-

pokeb <ANY ADDRESS FROM 0 TO 16777215> <BYTE VALUE><RETURN/ENTER>

For example:-

AMIGA-Shell:> pokeb 1234567 97<RETURN/ENTER>
AMIGA-Shell:> _

Would poke a decimal value 97 into memory address 1234567...

----------------------------------------------------------------------------

  The Additional Python Code, ('peekmem.py'):-
  --------------------------------------------

# PEEKB ONLY memory using an executable. This is very dangerous, so be
# VERY, VERY careful. The idea is to use the RETURN CODE of an executable
# to obtain a BYTE value from a hardware port of some kind. WORD and LONG
# WORD transfers also work so it would theoretically be possible to access
# say the AMIGA PCMCIA slot and obtain a 16 Bit value from it using PYTHON
# WITHOUT ANY special additions, JUST the basic interpreter and its
# standard 'libraries'.

# It IS possible to POKE values directly into memory or hardware registers,
# BUT I have NOT included this as it would be possible to crash the machine
# if you don't know what you are doing. 

# This LUNATIC idea belongs to copyright, (C)2006, B.Walker, G0LCU.

# A matching C source is issued which NEEDS to be compiled for this to work.
# It was intended for Classic AMIGA usage and compiled under Dice-C AND VBCC.
# You brain-bods out there COULD make it work on other platforms IF you so
# desired BUT I hold NO responsibility for ANY problems that may arise.

# Do any imports IF required.
import os

# Have it as an 'executeble' rather than an 'import'.
def main():
	# Set up any 'strings' or 'variables'.
	myaddress = '0'
	mybyte = 0
	# Use 'print' as a simple newline only.
	print
	# Input 'myaddress' as ASCII numerical characters. it does NOT
	# matter what is typed as the matching executable, after compiling
	# the attached C source code, takes care of any typos'.
	myaddress = raw_input('Input address in decimal:- ')
	# Do NOT allow a NULL string OR a RETURN/NEWLINE character!.
	if myaddress == '': myaddress = '0'
	if myaddress == chr(13): myaddress = '0'
	if myaddress == chr(10): myaddress = '0'
	if myaddress == chr(10) + chr(13): myaddress = '0'
	if myaddress == chr(13) + chr(10): myaddress = '0'
	# 'mybyte' takes the RETURN CODE single byte returned from 'peek'
	# as being a READ memory location within the limits of the 'peek'
	# executable. ERRORS are taken care of inside 'peek' itself.
	mybyte = (os.system('PYTHON:peek ' + myaddress))
	# Display result(s) on a standard PYTHON command line interpreter.
	print
	# IMPORTANT!!!, 'myaddress' is a string, NOT a number!. So ANYTHING
	# YOU type in WILL be displayed in the 'print' statement below as
	# gibberish, IF gibberish is what YOU have typed in, BUT, the C
	# executable WILL LIMIT ANY ERRORS to the NUMBERS 0 and 16777215
	# depending upon the error. In theory ALL errors are automatically
	# corrected, SO BEWARE!.
	# SEE the C source for more details.
	print 'Memory address in decimal is',myaddress,'and decimal byte value is',mybyte
	print
main()
# End of simple PYTHON 'executable'.

This code is part of the archive:-

                http://main.aminet.net/dev/src/Peek-Mem.lha

Refer to the archive above as to how this works...

============================================================================

  General Assumptions:-
  ---------------------

  That You Should Have A Basic Knowledge Of:-
  -------------------------------------------

  1) How to set up the AMIGA.
  2) How to BOOT up the AMIGA into either a CLI, (Command Line Interface),
     or a WorkBench screen.
  3) How to use the Keyboard.
  4) How to use the Mouse.
  5) How to start programs from the CLI or WorkBench.
  6) The general operation of WorkBench, windows and requesters etc...
  7) How to format a floppy disk.
  8) How to create a BOOTABLE floppy disk.
  9) Safely connecting ANY external equipment to the AMIGA.

============================================================================

                                IMPORTANT:-
                                -----------


    The Legal Stuff:-
    -----------------

    These programs are Public Domain and no profit will be made from them,
    also all of the files must remain unaltered and intact including this
    one. The author is not responsible for any damage to, or loss of, or
    failure of equipment or data caused in any way by the use of these
    programs. There is NO warranty with the use of these software releases
    and YOU USE THEM AT YOUR OWN RISK.

----------------------------------------------------------------------------

    Testing Evaluation:-
    --------------------

    An A1200(HD) in 2MB, 6MB and 10MB modes using trapdoor memory AND/OR
    PCMCIA memory expansions and OS3.0x+.

    Also tested on a(n) HP Pavillion Notebook, model number dv2036ea,
    running AF2005/WinUAE AND Python Version 2.0x.

    All test conditions WERE/ARE using standard ~topaz 8~ fonts throughout.

    I have no idea what a strange configuration setup will create so refer
    to the ~The Legal Stuff~ above.

----------------------------------------------------------------------------

                                 WARNING.
                                 --------

  1) DISCONNECT any faulty equipment under test from the MAINS supply.
  2) If a DC supply is used do NOT reverse polarity the connections.
  3) Do NOT power up any electronic item until it is safe to do so.
  4) CHECK and RECHECK all of your construction and repair work thoroughly.
  5) Handle ALL tools used with care.
  6) Beware of ALL types of solvents, glues and etching fluids.
  7) NEVER leave a soldering iron switched on unattended.
  8) KEEP everything OUT of the reach of small children.
  9) Switch OFF the AMIGA before disconnecting or connecting any hardware.
 10) And finally read 1) to 9) again.

----------------------------------------------------------------------------

   Contact:-
   ---------

   Mr Barry Walker, G0LCU,
   70 King George Road,
   Loughborough,
   Leicestershire,
   LE11 2PA,
   England.

   Email:-     wisecracker@tesco.net
   URL:-       http://homepages.tesco.net/wisecracker/G0LCU.HTM

   Author of the ~TestGear?~ projects in the ~hard/hack~ drawer of AMINET.

----------------------------------------------------------------------------

   A very useful HardWare related site, (C) Anthony Hoffman, for
   modifications, schematics, repairs and the like is:-

                          http://amiga.serveftp.net/

============================================================================
