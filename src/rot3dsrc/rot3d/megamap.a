;/****************************************************************
;This code is copyright 1993. All Rights Reserved. Authors:-
;
;  Jason Freund and Gabe Dalbec.
;  Chris Hames
;
;****************************************************************/

;uses breshenhams alg to check every point on a line to see if it's
;higher (closer) than what was in map[i].height, before

;	INCLUDE "defines.i"
	WALLWIDTH: equ 256
	section	code

;void MegaMap(short Sx, short Delx, short x, short y);

	XDEF	_MegaMap
	XREF	_dely
	XREF	_s2
	XREF	_map
	XREF	_e
	XREF	_wallwidth
	XREF	_Sy
	XREF	_Dy
	XREF	_intowall
	XREF	_outofwall
	XREF	_bitmapno
	XREF	_changepalette
	XREF    _wallparts

_MegaMap:
	movem.l	d2-d7/a2-a6,-(sp)	;/* Push regs */
;	move.w	44+4(sp),d0		;/* d0 =Sx */
	move.w	46+4(sp),d1		;/* d1 =Delx */
	move.w	50+4(sp),d3		;/* d3 =y */


	tst.w	d1
	beq	end

	lea     _wallparts,a3
	move.w  _bitmapno,d4
	mulu.w  #256*2,d4         ; d4 = bitmapno * 288*2
	add.w   d4,a3			; a3 = wallparts[bitmapno]
	moveq.l	#0,d4			; d4 = loop counter == Dx-Sx

	lsl.w   #1,d1
	move.w  d1,a6
	lsr.w   #1,d1
	move.w  d1,a5			; save delx in a5
	add.w   _outofwall,d1   ; d1= delx + outofwall
	add.w	_intowall,d1	; d1= delx + intowall + outofwall
	move.w  #WALLWIDTH,d6			; d6= WALLWIDTH
	mulu.w  _intowall,d6	; d6= (WALLWIDTH)*(intowall-1)
	sub.l   #WALLWIDTH,d6
	move.w  _e,d2
	move.w  _dely,d0
	lsl.w   #1,d0

loop:
	cmp.w	a5,d4			;/* if d1<d4 -> end; i>delx end */
	bgt.s	end
	addq.w	#1,d4
	addi.l  #WALLWIDTH,d6	; d6= WALLWIDTH * intowall + WALLWIDTH * i
	move.w	48(sp),d5
	add.w	d4,d5			;/* d5 = i+Sx */
	lsl.w	#3,d5			;/* each entry in map is 8 bytes. */
	lea	    _map,a0
	add.w	d5,a0			;/* map[i+Sx].height */
	cmp.w	(a0),d3			;/* if (map[i+Sx].height<y) -> while*/
	bgt.s	while
	move.w	d3,(a0)+		;/* map[i+Sx].height = y; */

	move.l  d6,d7			; put WALLWIDTH * (intowall+i) in d7 for divide
	divu.w	d1,d7			; WALLWIDTH * (intowall+i) / (delx+intowall+outofwall)
	subq.w  #1,d7
	move.w	d7,2(a0)			; map[i+Sx].offset =  "    /            "
	lsl.w   #1,d7
	move.w	0(a3,d7.w),(a0) ; map[i+Sx].bitmap = wallparts[bitmap*288*2+i]

while:
	tst.w	d2				; 0>e -> endwhile
	ble.s	endwhile
	add.w	_s2,d3			;/* y+=s2 */
	sub.w	a6,d2			;/* e = e-2*delx */
	bra.s	while

endwhile:
	tst.w	_s2
	bge.s	l1
	sub.w	d0,d2			;/* d2 = e- 2*dely */
	bra	loop

l1:
	add.w	d0,d2			;/* d2 = e+ 2*dely */
	bra	loop

end:
	movem.l	(sp)+,d2-d7/a2-a6
	rts

