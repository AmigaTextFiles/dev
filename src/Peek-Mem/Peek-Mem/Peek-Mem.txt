
             Peeking Memory Using Python Version 1.4 Minimum.
             ------------------------------------------------

  Minimum Requirements Are:-
  --------------------------

         Stock AMIGA A1200(HD), 68EC020 and upwards.

         A FULL, standard, OS3.0x+ installation.

         A FULL, Python Version 1.4x minimum installation, available on
         AMINET.

         (VBCC or Dice-C for classic AMIGAs is optional, available on
         AMINET.)

         (AF2005, WinUAE is optional also.)

============================================================================

  Preface:-
  ---------

  I needed the ability to check a memory address whilst doing something with
  Python V1.4. As Python is 'platform independant' there was no way of doing
  this using the normal full Python installation, so I set about this 
  problem for myself.

  In the archive there are the sources and executables to do this facility.
  (I have kept the sources as simple as possible so that anyone of about 14
  years old upwards can hopefully understand what is going on.)

  I decided on an ABSOLUTELY CRAZY idea of using the RETURN CODE, (RC), of
  an executable to store a BYTE value of any random memory address of MY
  choice. This INCLUDED any memory addresses deemed sacred and protected
  by the ENFORCER society. As Python cannot do HW related things easily,
  indeed IF at all, then I had to take the back door and so 'I DID IT MY
  WAY'.

  I know this is a ZANY, LUDICROUS and CRAZY idea BUT if you have any
  comments good OR bad, then Email me at the email address at the bottom of
  this 'manual'; I will reply to them.......

----------------------------------------------------------------------------

  The Archive:-
  -------------

  In the archive are the Python and C sources, executables generated by
  VBCC and Dice-C of the C sources and this 'manual'. Some of the executables
  can be used as stand-alone programs from the CLI/Shell to read any memory
  address up to the 16MB boundary. This is what I have deliberately limited
  the source code up to but with modification it can be extended. It is also
  possible to get UNSIGNED WORD and SIGNED LONGWORD values as a(n) RC for
  Python but I only needed UNSIGNED BYTE values so I left it at that,
  (see the listing below).

  These are the sources and executables for reading single byte memory
  addresses, plus others, using Python V1.4 minimum. They are free for your
  use and you may modify them as you please:-

    mempeek.c - A version of 'peek.c' WITHOUT the comments.
    mempeek.py - A version of 'peekmem1.py' WITHOUT the comments.
    Peek-Mem.readme - This manual/readme file.
    Peek-Mem.txt - The main manual with the source code buried inside.
    peek.c - C source WITHOUT any printing of values to a Shell.
    peek.dcc - Dice-C compiled executable of 'peek.c'.
    peek.vbcc - VBCC compiled executable of 'peek.c'.
    peekmem.py - My default Python 'executable'.
    peekmem1.py - A slightly different version of 'peekmem.py'.
    print-peek.c - C source WITH printing of values to a Shell.
    print-peek.dcc - Dice-C compiled executable of 'print-peek.c'.
    print-peek.vbcc - VBCC compiled executable of 'print-peek.c'.
    print-peekl.c - C source for 'longword' values printed to a shell.
    print-peekl.dcc - Dice-C compiled executable of 'print-peekl.c'.
    print-peekl.vbcc - VBCC compiled executable of 'print-peekl.c'.
    Print-peekw.c - C source for 'word' values printed to a shell.
    print-peekw.dcc - Dice-C compiled executable of 'print-peekw.c'.
    print-peekw.vbcc - VBCC compiled executable of 'print-peekw.c'.



  To compile the C source(s) under VBCC for m68k machines from a Shell:-
  (Note! Ensure you have enough stack for this; at least 65536 bytes!!!)

AMIGA-Shell:> vc peek.c<RETURN>

  This will give the executable as 'a.out'!, just rename it at will.

AMIGA-Shell:> vc print-peek.c<RETURN>

  This will also give the executable as 'a.out'!.



  To compile the C source(s) under Dice-C for m68k machines from a Shell:-

AMIGA-Shell:> dcc -o peek peek.c<RETURN>

  This will give the executable as 'peek'!, just rename it at will.

AMIGA-Shell:> dcc -o print-peek print-peek.c<RETURN>

  This will give the executable as 'print-peek'!.

----------------------------------------------------------------------------

  Both compiled versions of 'peek.c' do apparantly NOTHING, whereas both
  versions of 'print-peek.c' can be run from the command line as:-

  'print-peek.dcc <any numerical value from 0 to 16777215><RETURN>'
  'print-peek.vbcc <any numerical value from 0 to 16777215><RETURN>'

  For example:-

AMIGA-Shell:> print-peek.dcc 16777215<RETURN>

  Will print a decimal value to the screen, possibly decimal value 31.

----------------------------------------------------------------------------

  Integrating With Python:-
  -------------------------

  A full installation of Python Version 1.4x MINIMUM IS required for this
  and it can be found on AMINET. The 'PYTHON:' volume must be assigned to
  the 'Drive:Drawer' where the Python executable can be found.

  Copy 'peekmem.py' into the 'PYTHON:Lib/' drawer.
  Also copy 'peek.dcc' OR 'peek.vbcc' to the 'PYTHON:' volume and rename
  the one you choose to 'peek'. You are now ready to roll... :)

  (Similarly, copy 'print-peekw.dcc' OR 'print-peekw.vbcc' to the 'PYTHON:'
  volume and rename the one you choose to 'peek'; also similarly, copy
  'print-peekl.dcc' OR 'print-peekl.vbcc' to the 'PYTHON:' volume and rename
  the one you choose to 'peek'. These will return UNSIGNED WORD or SIGNED
  LONGWORD values to Python. IMPORTANT NOTE, THESE ARE PURELY EXPERIMENTAL
  AND ARE INCLUDED FOR YOUR USAGE AND EXPERIMENTATION ALSO; READ 'The Legal
  Stuff:-' BELOW!!!.)

  From the 'PYTHON:' volume start up Python and when the Python prompt
  '>>>' appears type:-

>>> execfile('PYTHON:Lib/peekmem.py')<RETURN>

Input address in decimal:- 16777215<RETURN>

Memory address in decimal is 16777215 and decimal byte value is 31

>>> _

  Note! The byte value may be different in your case. You can prove this
  by checking with a 'monitor' program like 'DevPac's MonAm(2)' for
  example.

  There we have it, peeking of a memory address using a(n) RC of an
  executable file and depositing it into Python... :)

  Read the Python source(s) to see what is happening as most of the
  information is buried as comments inside the source code.

  Similarly the C source(s) have comments aiding to the clarity of what is
  going on too.

============================================================================

The 'Python' Source Code, 'peekmem.py':-
----------------------------------------

# PEEKB ONLY memory using an executable. This is very dangerous, so be
# VERY, VERY careful. The idea is to use the RETURN CODE of an executable
# to obtain a BYTE value from a hardware port of some kind. WORD and LONG
# WORD transfers also work so it would theoretically be possible to access
# say the AMIGA PCMCIA slot and obtain a 16 Bit value from it using PYTHON
# WITHOUT ANY special additions, JUST the basic interpreter and its
# standard 'libraries'.

# It IS possible to POKE values directly into memory or hardware registers,
# BUT I have NOT included this as it would be possible to crash the machine
# if you don't know what you are doing. 

# This LUNATIC idea belongs to copyright, (C)2006, B.Walker, G0LCU.

# A matching C source is issued which NEEDS to be compiled for this to work.
# It was intended for Classic AMIGA usage and compiled under Dice-C AND VBCC.
# You brain-bods out there COULD make it work on other platforms IF you so
# desired BUT I hold NO responsibility for ANY problems that may arise.

# Do any imports IF required.
import os

# Have it as an 'executeble' rather than an 'import'.
def main():
	# Set up any 'strings' or 'variables'.
	myaddress = '0'
	mybyte = 0
	# Use 'print' as a simple newline only.
	print
	# Input 'myaddress' as ASCII numerical characters. it does NOT
	# matter what is typed as the matching executable, after compiling
	# the attached C source code, takes care of any typos'.
	myaddress = raw_input('Input address in decimal:- ')
	# Do NOT allow a NULL string OR a RETURN/NEWLINE character!.
	if myaddress == '': myaddress = '0'
	if myaddress == chr(13): myaddress = '0'
	if myaddress == chr(10): myaddress = '0'
	if myaddress == chr(10) + chr(13): myaddress = '0'
	if myaddress == chr(13) + chr(10): myaddress = '0'
	# 'mybyte' takes the RETURN CODE single byte returned from 'peek'
	# as being a READ memory location within the limits of the 'peek'
	# executable. ERRORS are taken care of inside 'peek' itself.
	mybyte = (os.system('PYTHON:peek ' + myaddress))
	# Display result(s) on a standard PYTHON command line interpreter.
	print
	# IMPORTANT!!!, 'myaddress' is a string, NOT a number!. So ANYTHING
	# YOU type in WILL be displayed in the 'print' statement below as
	# gibberish, IF gibberish is what YOU have typed in, BUT, the C
	# executable WILL LIMIT ANY ERRORS to the NUMBERS 0 and 16777215
	# depending upon the error. In theory ALL errors are automatically
	# corrected, SO BEWARE!.
	# SEE the C source for more details.
	print 'Memory address in decimal is',myaddress,'and decimal byte value is',mybyte
	print
main()
# End of simple PYTHON 'executable'.

============================================================================

The 'ANSI C' Source Code, 'peek.c':-
------------------------------------

/* Peeking memory addresses one byte at a time. */
/* Limited to 16MB boundary ONLY, for idea testing. */
/* This is the standard A1200 version using Dice-C and VBCC compilers. */
/* (C)2006, B.Walker, G0LCU. To be used in conjunction with Python V1.4. */

/* This is written in childishly simple C coding so that it can be easily */
/* understood by anyone interested in programming in C. */
/* It is in theory ANSI C compliant... */

/* Standard include(s). */
#include "stdio.h"
#include "stdlib.h"
#include "string.h"

/* Get the ASCII address from Python VIA this 'argv[1]'. Whatever appears */
/* in 'argv[1]' does not matter as the code below will compensate for any */
/* typo' errors. */
int main(int argc, char *argv[])

{
	/* Set up types required. */
	long int peekaddress;
	unsigned char mybyte;

	/* Allocate definate values to the above. */
	peekaddress = 0;
	mybyte = 0;

	/* Ensure no typo' error can occur. */
	if (strlen(argv[1]) <= 0) (argv[1]) = "0";
	if (strlen(argv[1]) >= 9) (argv[1]) = "16777215";

	/* Get ASCII address from 'argv[1]'. */
	/* NOTE:- No need to allow for a NULL string length or odd */
	/* ASCII characters as 'atol()' takes care of it for me. :) */
	peekaddress = atol(argv[1]);

	/* Correct for number of arguments error, MUST be 2. */
	/* If not equal to 2 then set 'peekaddress' to ZERO. */
	if (argc <= 1) peekaddress = 0;
	if (argc >= 3) peekaddress = 0;

	/* Limit memory access to 16MB boundary for A1200 use!. */
	/* DO NOT allow negative numbers!. Address 0 is technically an */
	/* ENFORCER hit for high end AMIGAs so treat it as such. */
	if (peekaddress <= 0) peekaddress = 0;
	if (peekaddress >= 16777215) peekaddress = 16777215;

	/* Obtain a single BYTE character ONLY from the memory address. */
	mybyte = *(unsigned char *)peekaddress;

	/* Use the RETURN CODE for BYTE value access for Python. */
	/* This is VERY controversial BUT it WORKS... :) */
	return(mybyte);
}

----------------------------------------------------------------------------

  General Assumptions:-
  ---------------------

  That You Should Have A Basic Knowledge Of:-
  -------------------------------------------

  1) How to set up the AMIGA.
  2) How to BOOT up the AMIGA into either a CLI, (Command Line Interface),
     or a WorkBench screen.
  3) How to use the Keyboard.
  4) How to use the Mouse.
  5) How to start programs from the CLI or WorkBench.
  6) The general operation of WorkBench, windows and requesters etc...
  7) How to format a floppy disk.
  8) How to create a BOOTABLE floppy disk.
  9) Safely connecting ANY external equipment to the AMIGA.

============================================================================

                                IMPORTANT:-
                                -----------


    The Legal Stuff:-
    -----------------

    These programs are Public Domain and no profit will be made from them,
    also all of the files must remain unaltered and intact including this
    one. The author is not responsible for any damage to, or loss of, or
    failure of equipment or data caused in any way by the use of these
    programs. There is NO warranty with the use of these software releases
    and YOU USE THEM AT YOUR OWN RISK.

----------------------------------------------------------------------------

    Testing Evaluation:-
    --------------------

    An A1200(HD) in 2MB, 6MB and 10MB modes using trapdoor memory AND/OR
    PCMCIA memory expansions and OS3.0x+. Also tested on a(n) Hewlett
    Packard Pavillion Notebook, (model number dv2036ea), running AF2005,
    (WinUAE), and Python Version 2.0x.

    All test conditions WERE/ARE using standard ~topaz 8~ fonts throughout.

    I have no idea what a strange configuration setup will create so refer
    to the ~The Legal Stuff~ above.

----------------------------------------------------------------------------

                                 WARNING.
                                 --------

  1) DISCONNECT any faulty equipment under test from the MAINS supply.
  2) If a DC supply is used do NOT reverse polarity the connections.
  3) Do NOT power up any electronic item until it is safe to do so.
  4) CHECK and RECHECK all of your construction and repair work thoroughly.
  5) Handle ALL tools used with care.
  6) Beware of ALL types of solvents, glues and etching fluids.
  7) NEVER leave a soldering iron switched on unattended.
  8) KEEP everything OUT of the reach of small children.
  9) Switch OFF the AMIGA before disconnecting or connecting any hardware.
 10) And finally read 1) to 9) again.

----------------------------------------------------------------------------

   Contact:-
   ---------

   Mr Barry Walker, G0LCU,
   70 King George Road,
   Loughborough,
   Leicestershire,
   LE11 2PA,
   England.

   Email:-     wisecracker@tesco.net
   URL:-       http://homepages.tesco.net/wisecracker/G0LCU.HTM

   Author of the ~TestGear?~ projects in the ~hard/hack~ drawer of AMINET.

----------------------------------------------------------------------------

   A very useful HardWare related site, (C) Anthony Hoffman, for
   modifications, schematics, repairs and the like is:-

                          http://amiga.serveftp.net/

============================================================================
