<html>
<head>
 <title>Scroller_YUnlimited2</title>
</head>
<body bgcolor=#FFFFFF>

Für diesen Algorithmus gilt vieles, was bereits zum Scroller_YUnlimited gesagt
wurde. Sehen Sie sich deshalb unbedingt zuerst dessen <a href="yunlimited-de.html">
Dokumentation</a> an!<p>

Der große Unterschied besteht darin, daß die Bitmap nicht mehr doppelt hoch ist.
Die Bitmaphöhe beträgt 288 Pixel (256 + 32). Wir werden auch nicht mehr doppelt
blitten, und dadurch ist dieser Alogrithmus doppelt so schnell.
Die Tatsache, daß wir nicht mehr doppelt blitten, ist auch der einzige große
Unterschied zum Scroller_YUnlimited Algorithmus. Nehmen wir an, wir sind eine
halbe Bitmaphöhe runter gescrollt. Das sieht dann bei den beiden Algorithmen
etwa so aus:<p>

<center>
 <img src="images/yunlimited2_1.gif" width=458 height=325>
</center>

<p>

Wie man an diesem Bild sieht, geht beim Scroller_YUnlimited2 der aktuelle und
sichtbare Bereich über die Bitmapgrenzen hinaus. Das darf natürlich nicht sein,
weil sich dort nichts befindet oder besser gesagt nichts, was uns "gehört".
Wenn wir uns die vorigen zwei Bilder etwas genauer ansehen, fällt aber etwas auf:<p>

<center>
 <img src="images/yunlimited2_2.gif" width=458 height=326>
</center>

<p>

Beim Scroller_YUnlimited Algorithms gehören in unserem Beispiel sowohl Teile der
oberen als auch Teile der unteren Bitmaphälfte zum aktuellen/sichtbaren Bereich.
Wie es der Zufall (oder auch nicht) will, ist der Teil, der zur unteren Bitmaphälfte gehört
(blaues Rechteck) identisch mit dem gleich großen Bereich am Anfang der oberen
Bitmaphälfte (grünes Rechteck). Und diesen Bereich gibt es in identischer Ausführung
auch bei unserer einfach-hohen-Bitmap = beim Scroller_YUnlimited2 Algorithmus.<p>

Die Lösung wäre also, dem Videochip irgendwie zu sagen, daß er, wenn er am unteren Ende
unserer Bitmap angelangt ist, einfach an den Bitmapanfang hüpft und den Rest des
Screens ab da darstellt. Dank des Coppers ist das ganz einfach. Wir benutzen einfach
eine COPWAIT Instruktion in der Copperliste, um auf den Anfang <i>der</i> Rasterzeile zu
warten, die ohne unser Eingreifen Daten außerhalb unserer Bitmap darstellen würde, und setzen
dann die Planeadressen wieder an den Anfang der Bitmap. Die Zeile, auf die wir warten
müssen ändert sich beim Scrollen ständig, weil sich der aktuelle Bitmapbereich und somit
auch der Bereich in der Bitmap, den wir zu Anfang der Copperliste durch entsprechendes
Setzen der Planeadressen darstellen, ständig ändert. Sind z. B. die Planeadressen am
Anfang der Copperliste so gesetzt worden, daß sie die Bitmap ab Zeile 32 darstellen
(heißt: der aktuelle Bitmapbereich beginnt ab Zeile 16), dann wird der Videochip
das Ende unserer Bitmap in Rasterzeile 256 (32 + 256 = 288 = BITMAPHÖHE) erreicht
(und übersprungen) haben. Die Zeile, auf die wir warten müssen errechnet sich also
wie folgt:<p>

<blockquote>
 yoffset = Zeile, ab der wir die Bitmap am Anfang der Copperliste darstellen<p>
 zeile = DIWSTARTY + BITMAPHÖHE - yoffset
</blockquote>

<p>

DIWSTARTY muß deshalb dazugezählt werden, weil die erste sichtbare Rasterzeile
für den Videochip nicht 0 ist, sondern die Y Komponente des Display Window Start
Hardware Registers. Bei COPWAIT Instruktionen ist noch zu beachten, daß nur 8
Bit (Werte zwischen 0 und 255) für die Y-Koordinate zur Verfügung stehen. Will
man auf eine Zeile warten, die größer gleich 256 ist, dann muß man zuerst auf
das Ende der Zeile 255 warten und dann auf die Zeile (ZEILE - 256).<p>

Nach der COPWAIT Instruktion werden die Planeadressen alle an den Anfang der
Bitmap gesetzt. Das heißt immer auf den gleichen Wert, wir müssen sie also
nicht ständig anpassen. Es reicht aus, sie einmal beim Initialisieren der
Copperliste in dieselbe einzutragen.<p>

Der Copper benötigt 2 Instruktionen, um eine Planeadresse zu setzen - eine
für das HIWORD (obere 16 Bit) und eine für das LOWORD (untere 16 Bit). Bei
Verwendung von vielen Planes kann es sein, daß der Copper in der horizontalen
Austastlücke nicht genug Zeit hat, um alle Planeadressen rechtzeitig zu
setzen, also noch bevor die VideoDMA wieder beginnt, Daten aus dem CHIP RAM
zu lesen. Das dürfte spätestens bei 7 oder 8 Planes passieren. Glücklicherweise
gibt es einen Trick, mit dem wir nur die Hälfte an Copperinstruktionen benötigen:<p>

Der Trick funktioniert so: Wir warten auf die Rasterzeile, die sich vor der
errechneten Zeile befindet. In dieser Zeile ändern wir die Bitplane Modulo
Register, wobei wir das an jeder beliebigen (auch sichtbaren) horizontalen Stelle
der Rasterzeile machen können. Durch das ändern der Bitplane Moduli ändern
sich alle Planeadressen automatisch, sobald der VIDEO Chip in die nächste Zeile
springt. Den Wert, den wir in die Bitplane Modulo Register schreiben, wählen
wir so, daß sich für die nächste Zeile das richtige LOWORD für alle Planeadressen
ergibt. Die Berechnung ist relativ einfach:<p>

<blockquote>
 gewünschteadresse = Anfang Bitmap für Plane 0<p>
 alteadresse = Adresse, die der Plane-0-Pointer am Ende von ZEILE - 1 erreichen wird<p>
 modulowert = (gewünschteadresse - alteadresse) & 0xFFFF 
</blockquote>

<p>

Es ginge sogar noch einfacher, was dann aber nicht mehr so ganz einleuchtend aussieht.
Bei nur-vertikalem Scrolling ist <i>alteadresse</i> konstant und entspricht stets der
Plane0-Adresse der letzten Bitmapzeile + (BITMAPBREITE / 8). Das ist deshalb so,
weil in Rasterzeile ZEILE - 1 stets die unterste Zeile unserer Bitmap dargestellt
wird. Da sowohl <i>alteadresse</i> als auch <i>gewünschteadresse</i> konstant sind, muß
folgerichtig auch das Ergebnis (<i>modulowert</i>) konstant sein. Im Demo-Quelltext
befindet sich diese Berechnung deshalb in der InitCopperlist() Funktion.

Durch das ändern der Bitplane
Moduli haben wir erst die LOWORDs der Bitplane Pointer geändert (würde man eine nicht-interleavte
Bitmap mit max. Planegröße von 32 KByte oder eine entsprechend kleinere interleavte 
Bitmap mit max. Bitmapgröße von 32 KByte verwenden, die dazu noch richtig aligned ist,
dann ist es möglich, durch Bitplane Modulo Änderung automatisch auch die HIWORDs
richtig zu setzen). Um die HIWORDs zu setzen warten wir auf die nächste Zeile, d. h.
auf die Zeile die wir eigentlich errechnet hatten = den Anfang der Rasterzeile
ZEILE. 1 Copperinstruktion pro Plane reicht jetzt aus. Nach den Planes setzen wir
die Bitplane Modulo Register wieder auf den richtigen (alten) Wert. Wiederum ist es
hier egal, wenn sich der Videobeam bereits im sichtbaren Bereich befindet. Alle
diese Dinge, mit Ausnahme der COPWAIT Instruktionen, werden in der InitCopperlist()
Funktion gemacht, weil sich an den Werten während des Scrollens nichts ändert.<p>

Noch einige Bemerkungen zum Quelltext des Demoprogrammes. Wenn die Variable
mapposy, die die Levelposition Y in Pixeln enthält, auf 0 steht, dann sieht
der User den Levelbereich ab Position BLOCKHÖHE (16), weil die ersten
BLOCKHÖHE (16) Pixel stets verdeckt sind. Der User sieht also den Bereich:<p>

<blockquote>
 (0,mapposy + BLOCKHEIGHT) - (SCREENWIDTH - 1,mapposy + BLOCKHEIGHT + SCREENHEIGHT - 1)
</blockquote>

<p>

Das heißt, daß die erste Blockreihe der Leveldatei nie sichtbar ist.
Will man in die Bitmap etwas hineinblitten, z. B. Blitter Objekte (BOBs), dann
muß man das im aktuell sichtbaren Bitmapbereich machen. Dieser Bereich ist:<p>

<blockquote>
 <table border=0 cellpadding=0 cellspacing=0>
  <tr>
   <td nowrap>
    (0,(videoposy + BLOCKHEIGHT) % BITMAPHEIGHT) - (SCREENWIDTH - 1,(videoposy + BLOCKHEIGHT + SCREENHEIGHT - 1) % BITMAPHEIGHT)
   </td>
  </tr>
 </table>
</blockquote>

<br>
 
Man darf die Start-Y Koordinate ((videoposy + BLOCKHEIGHT) % BITMAPHEIGHT) und die
End-Y Koordinate ((videoposy + BLOCKHEIGHT + SCREENHEIGHT - 1) % BITMAPHEIGHT)
auf ein Vielfaches von BLOCKHEIGHT auf- bzw. abrunden, sodaß der Bereich, in den
geblittet werden darf insgesamt SCREENHEIGHT + BLOCKHEIGHT Pixel hoch ist:<p>

<blockquote>
 blitbereich_strty = ((videoposy + BLOCKHEIGHT) & ~(BLOCKHEIGHT - 1)) % BITMAPHEIGHT<p>
 blitbereich_endey = (blitbereich_strtx + SCREENHEIGHT + BLOCKHEIGHT - 1) % BITMAPHEIGHT
</blockquote>

<p>

Wie aus obigen Berechnungen zu erahnen, kann es vorkommen, daß die Ende-Y-Koordinate
über der Start-Y-Koordinate liegt, d. h. kleiner ist. Das liegt am Videosplitting und
bedeutet nichts anderes, als daß der Bereich von der Startkoordinate bis zum Ende
der Bitmap geht, dann an den Anfang der Bitmap "wrappt" und dort noch bis zur
Endkoordinate reicht. Für das Blitten in den Blitbereich folgt daraus, daß man sich
die Blithöhe und die errechnete Blit-Ziel-Y-Position (blitbereich_strty + ziely)
genau anschauen muß:<p>

<blockquote>
 <b>Wenn BLITZIELY + BLITHÖHE &lt;= BITMAPHÖHE dann:</b>
 <blockquote>
  Ganz normal an Y-Position BLITZIELY blitten
 </blockquote>
 <b>andernfalls, wenn BLITZIELY &gt;= BITMAPHÖHE dann:</b>
 <blockquote>
  Ganz normal an Y-Position (BLITZIELY - BITMAPHÖHE) blitten
 </blockquote>
 <b>andernfalls:</b>
 <blockquote>
  Die ersten (BITMAPHÖHE - BLITZIELY) Pixelzeilen an Y-Position BLITZIELY blitten<br>
  Die letzten BLITHÖHE - (BITMAPHÖHE - BLITZIELY) Pixelzeilen an Y-Positionen 0 blitten
 </blockquote> 
</blockquote>

<p>

Im schlimmsten Fall, d. h. wenn sich die Videosplit-Zeile innerhalb des Blit-Ziel-
Bereiches befindet, muß der Blit also in zwei Schritten gemacht werden. Das ist
nur lästig, aber nicht weiter schlimm oder extrem langsam, zumal die Wahrscheinlichkeit,
daß ein Objekt in zwei Schritten geblittet werden muß, in den meisten Fällen
ziemlich gering ist. 
</body>
</html>

