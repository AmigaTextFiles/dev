<html>
<head>
 <title>Scroller_XYUnlimited</title>
</head>
<body bgcolor=#FFFFFF>

This algorithm and the one of <a href="xylimited-uk.html">Scroller_XYLimited</a>
are very similiar. The most important difference is that the height of the bitmap
no longer depends on the width of the map. Anyway you should not consider this
algorithm to be the best choice, as it also has some disadvantages.<p>

In addition to the "normal" extraheight of 2 * BLOCKHEIGHT pixels only one more
pixel line is needed. So the overall height of the bitmap is going to be 289
(256 + 16 * 2 + 1). In Scroller_XYLimited there was an area at the lower border
of the bitmap which was "used" by horizontal scrolling. The wider the map the
bigger this area had to be. This area also exists in this algorithm, with the
difference that it is always just one line high.<p>

How can this work? Very simple. We restrict horizontal scrolling in the
bitmap (!), so that videoposx can only have values between 0 .. BITMAPWIDTH - 1.
When due to horizontal scrolling videoposx would need to get the value
BITMAPWIDTH then we set videoposx to 0 and to compensate increase videoposy
by one planeline (!). When due to horizontal scrolling videoposx would need
to get the value -1 then we set videoposx to BITMAPWIDTH - 1 and to compensate
decrease videoposy by one planeline(!).<p>

We must of course use planelines as unit for videoposy, now. And there are
more changes in the source code. When blitting blocks the blit sometimes must
be done in two steps because of videoposx affecting videoposy. In Scroller_XYLimited
blocks never needed to be blitted in two steps, this could only happen to BOBs.
We also must take care that block blit operations only happen in the normal bitmap
area, that is, not in the extraline. To do so we must check and eventually
adjust blit destination coordinates. So block blits only happen in the area
(0,0) - (BITMAPWIDTH - 1, BITMAPHEIGHT - 1). By the way, BITMAPHEIGHT in our
case is 288 and not 289.<p>

There are also some problems with the video splitting. As this cannot happen
in the visible area of a rasterline, the extraline must help us out. At the
end of all scroll routines we blit enough bytes from the top of the bitmap
into the extraline so that the bottommost displayed (!) line of the bitmap
completely stays one after the other in memory as well. The calculation
of the VIDEOSPLIT plane pointers is a little bit different, too, because
of videoposx ranging between 0 and BITMAPWIDTH - 1, that is within one
planeline only. Therefore videoposy must be considered in the calculation
as well, to make sure that the plane addresses are on the correct planeline.<p>

When blitting BOBs you must be careful to do this after the extraline
special-blit.<p>

You really should not use this algorithm! If you cannot live without it's
positive properties have a look at
<a href="xyunlimited2-uk.html">Scroller_XYUnlimited2</a>. Things are
done in a very similiar way, there, but with much less disadvantages.
</body>
</html>
