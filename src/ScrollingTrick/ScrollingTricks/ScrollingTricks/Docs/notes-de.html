<html>
<head>
 <title>Allgemeine Hinweise zu allen Scroll-Algorithmen</title>
</head>
<body bgcolor="#FFFFFF">

<ul>
 <li>
  Es werden immer ganze Blöcke geblittet, weil das viel schneller geht, als
  zum Beispiel die jeweils letzte Pixel-Zeile von 16 verschiedenen Blöcken,
  obwohl die Datenmenge gleich groß ist. Bei vertikalem Scrolling kann man
  das eventuell schon machen, aber zumindest für horizontales Scrolling
  verbietet das Planar-Format des Amiga die Pixel-Spalten-Nachfüll-Technik,
  wenn man auf hohe Geschwindigkeit Wert legt.<p>
 </li>

 <li>
  Es werden nie ganze Blockspalten (horizontales Scrolling) oder ganze Blockreihen
  (vertikales Scrolling) geblittet. Stattdessen verteilen wir die zu
  blittenden Blöcke in BLOCKBREITE bzw. BLOCKHÖHE Schritte. Bei 16 x 16
  Blöcken sind das sowohl für horizontales als auch für vertikales Scrolling
  jeweils 16 Schritte. 16 deshalb, weil spätestens nach 16 Pixeln Scrolling
  die ins "Bild kommende" Spalte/Reihe (die 16 Pixel breite/hoch ist) komplett
  geblittet sein muß.<p>
 </li>
 
 <li>
  Alle Algorithmen gehen davon aus, daß man an jeder beliebigen Level Position
  die Richtung ändern kann. Deshalb ist zum Beispiel der 8-Wege-Scroller relativ
  kompliziert. Würde man die Richtungsänderungen nur in BLOCKBREITE/BLOCKHÖHE
  Abständen zulassen, wäre alles viel einfacher.<p>
 </li>
 
 <li>
  Da die Demo-Programme nur Single-Buffering verwenden, kann man vor allem
  bei schnellem Scrolling sehen, wie die Programme am Rand Blöcke blitten.
  Bei Verwendung von Double-Buffering (was man bei einem Spiel sowieso so
  gut wie immer verwendet) passiert das nicht.<p>
 </li>
 
 <li>
  Die Demo Quelltexte sind bei weitem nicht optimiert!! So werden viele Blitter
  Register stets neu gesetzt, anstatt nur einmal vor den Scroll Routinen. Außerdem
  ist es in einigen Fällen sicher sinnvoll, anstelle des Blitters die CPU zu
  verwenden (vielleicht ein Block mit dem Blitter, der nächste mit der CPU, dann
  wieder mit dem Blitter usw.), oder dem Blitter DMA Priorität gegenüber der CPU zu
  geben (DMAF_BLITHOG in DMACON). Es werden keinerlei Tabellen verwendet, was vor
  allem für Multiplikationen sinnvoll ist. Die Quelltexte dienen einzig und allein
  dazu, die Techniken verständlich zu machen.<p>
 </li>

 <li>
  Will man die Demo Quelltexte auf andere Blockgrößen (z. B. 32 x 32) umschreiben,
  ist es nicht damit getan die #define's zu ändern. Es werden etliche Dinge
  anzupassen und umzuschreiben zu sein!<p>
 </li>
 
 <li>
  In dieser Dokumentation werden Koordinatenpaare oft so dargestellt:<p>
  
  <blockquote>
   (KoordinateX,KoordinateY)
  </blockquote>
  
  <p>
  
  Die verwendete Einheit hängt vom Zusammenhang ab. Besonders aufzupassen
  ist bei der KoordinateY, die nicht unbedingt die selbe Einheit hat wie
  die KoordinateX, z. B. Planelines statt Pixel. Bereiche werden so
  dargestellt:<p>
  
  <blockquote>
   (StartKoordinateX,StartKoordinateY) - (EndKoordinateX,EndKoordinateY)
  </blockquote>
  
  <p>

  Bezüglich der Einheiten gilt hier dasselbe.<p>

 </li>

 <li>
  Alle Quelltexte verwenden die gleichen #defines und Variablen. <a href="variables-de.html">Beschreibung</a>.
 </li>
</ul>

</body>
</html>
