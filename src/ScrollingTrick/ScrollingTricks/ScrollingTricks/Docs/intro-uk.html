<html>
<head>
 <title>Introduction</title>
</head>
<body bgcolor=#FFFFFF>

This doc describes the best scrolling algorithms for block-based (tile-based)
games. Many games use this technique. Some of the most known are Turrican,
Lionheart, Giana Sisters, Z-Out, Katakis, R-Type, Battle Squadron.<p>

The main reason why a level should not consist of one big image is that
this would require an enormous amount of memory. Therefore one could only
have very small levels. However, if you build up the level using blocks,
whose size is usually 16 x 16 or 32 x 32 pixels, then you need much less
memory. Why? Well, usually one only needs a fairly small number of
different blocks and the memory usage per block (that is, for an area
of BLOCKWIDTH x BLOCKHEIGHT pixels the player is seeing on the screen)
is only a few bytes (min. 1).<p>

The techniques I'm going to describe here are designed for the Amiga
Chipset (ECS/OCS/AGA). A very important role is played by the Copper,
which makes it possible to code every kind of scrolling one can imagine
(horizontal only, vertical only, 8 way scroller) in such a way that
you never actually need scrolling graphic data around in memory with
the CPU or the Blitter. No matter what you want to do, you just need
to blit blocks 'coming in'.<p>

As far as I know, VGA graphic chips, as also used by Amiga GFX cards,
have as standard built in all the functionality needed to use the same
or very similiar techniques for scrolling:

<ul>
 <li>Possibility to change the 'display start address'</li>
 <li>Possibility to change the scanline modulo, that is how many bytes the
     video chip skips at the end of one line to get to the next line</li>
 <li>If necessary, the possiblity to split the display, that is changing the
     'display start address' somewhere in the visible area again</li>
</ul>

Therefore it might well be, that most of the scrolling algorithms also
work in a very similiar way on GFX cards. Differences are possibly
necessary mainly due to the different graphic layout (chunky pixel instead
of planar). Another question is of course, whether or to what extent above
mentioned features are made availabe to the programmer through the RTG
software's API.

</body>
</html>
