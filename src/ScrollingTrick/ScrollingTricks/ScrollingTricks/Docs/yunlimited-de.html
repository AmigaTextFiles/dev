<html>
<head>
 <title>Scroller_YUnlimited</title>
</head>
<body bgcolor=#FFFFFF>

Dieser Algorithmus verwendet eine relativ große (hohe) Bitmap. Deshalb
ist er im allgemeinen nicht die erste Wahl. Im Normalfall sollte man
diese Technik nicht verwenden, weil sie nur halb so schnell wie die von
Scroller_YUnlimited2 ist.<p>

Warum muß die Bitmap eigentlich 576 Pixel hoch sein? Zuerst einmal muß
man sagen, daß die Bitmap generell höher sein muß als der sichtbare
Bereich, weil wir "neu hereinkommende" Levelbereiche blockweise blitten
und das in einem Bereich machen müssen, den man nicht sieht - sonst sieht
das für den User gar nicht schön oder professionell aus. Der sichtbare
Bereich beträgt 256 Pixel in der Höhe, d. h. 16 Blöcke (SICHTBARE
HÖHE : BLOCKHÖHE = 256 : 16 = 16). Es sind aber nicht immer nur 16
Blöcke vertikal sichtbar, meistens sind es 17, nämlich immer dann, wenn
die Levelposition (d. h. die vertikale Position des Levelausschnittes
in Pixel) nicht durch 16 (BLOCKHÖHE) teilbar ist.<p>

<center>
 <img src="images/visibleblocksy.gif" width=358 height=293><p>
</center>

Deshalb muß die Bitmap mindestens 18 Blöcke hoch sein, d. h. 2 Blöcke 
= 32 Pixel mehr als die sichtbare Höhe. Im Gegensatz zu den Algorithmen
für horizontales Scrolling ändert sich bei Verwendung verschiedener
FETCH Modi nichts - ausgenommen einige anders zu setzende Video Chip Register.
Eine Bitmapbreite von 320 Pixeln ist ein Vielfaches von 64/32 und somit
sowohl für den 2x als auch den 4x FETCH Modus geeignet. Die Bitmaphöhe
ist egal - FETCH Modi Alignment Beschränkungen gibt es nur bezüglich
der Bitmapbreite.<p>

256 + 32 ist
aber nur 288? War da nicht die Rede von 576 Pixeln? Nun, auf 576 Pixel kommen
wir, wenn wir 288 mit 2 multiplizieren. Der wesentliche Trick von diesem
Scroll-Algorithmus besteht nämlich darin, daß unsere Bitmap doppelt so hoch
ist, wie sie eigentlich sein müßte. Die untere Hälfte ist stets eine exakte
Kopie der oberen Hälfte. Deshalb wird beim Scrollen jeder zu blittende Block
einmal in der oberen und einmal in der unteren Hälfte geblittet. So ganz
richtig mit der exakten Kopie ist das aber nur solange keine BOBs geblittet
werden. Die müssen nämlich zum Glück nur einmal geblittet werden. Das aber
nur nebenbei gesagt. Zu Beginn füllen wir die beiden Bitmaphälften mit dem
anfangs sichtbaren Levelbereich:<p>

<center>
 <img src="images/yunlimited.gif" width=184 height=296>
</center>

<p>

Das rote Rechteck stellt den am Anfang aktuellen Bereich dar, der mit dem
Copper dargestellt wird, wobei die ersten und letzten 16 Pixel ausgeblendet
sind. Der User sieht also nur den vom gelben Rechteck eingegrenzten Bereich.
Wenn wir nach unten scrollen, dann verschiebt sich auch der aktuelle
Bereich nach unten. Wenn wir nach oben scrollen, dann verschiebt er sich
nach oben. Den sichtbaren Bereich zu verschieben reicht natürlich nicht aus.
Wir müssen auch die neu hereinkommenden Blöcke in die Bitmap blitten. Gehen
wir mal davon aus, daß wir nach unten wollen. Am Anfang befinden sich in den
beiden Bitmaphälften die Blockreihen 0 bis 17, also die ersten 18 Reihen
des Levels. Nach spätestens 16 Pixeln (= Höhe einer Reihe) Nach-Unten-Scrollen
müssen sich die Blockreihen 1 bis 18 in beiden Bitmaphälften befinden. Da
wir 16 Pixel lang Zeit dazu haben blitten wir die neue (18) Blockreihe nicht
auf einmal, sondern schrittweise. 16 Pixel Zeit heißt, daß wir sie in 16 Schritten
blitten. Eine Blockreihe besteht aus 20 (BITMAPBREITE : BLOCKBREITE = 320 : 16 = 20)
Blöcken. Das würde bedeuten, daß wir pro Schritt 1,25 (20 : 16 = 1,25) Blöcke blitten müßten.
Wir blitten aber nur ganze Blöcke, also lösen wir das so, daß wir mal einen,
mal zwei Blöcke blitten. Bei wievielen der 16 Schritte wir 2 Blöcke blitten
müssen, um beim letzten Schritt die Reihe (20 Blöcke) komplett zu haben,
berechnen wir so:<p>

<blockquote>
 2 * x + (ANZAHLSCHRITTE - x) * 1 = BLÖCKEPROREIHE<p>
 2x + (16 - x) * 1 = 20<p>
 2x + 16 - x = 20<p>
 x = 20 - 16<p>
 x = 4
</blockquote>

<p>

Das bedeutet also in unserm Fall, das wir bei 4 der insgesamt 16 Schritten zwei
Blöcke blitten und bei den restlichen 12 Schritten nur einen Block. In den
Demo Quelltexten zu diesem Algorithmus wird bei den <b>letzten</b> 4 Schritten doppelt
geblittet, man kann das aber natürlich auch bei den <b>ersten</b> 4 Schritten machen.<p>

Welchen Schritt = welchen Block bzw. welche 2 Blöcke wir in einer bestimmten
Situation (= LevelPosition) blitten müssen, berechnen wir, indem wir die
LevelPositionY durch 16 (BLOCKHÖHE) dividieren und uns den Rest anschauen.
Der nämlich bestimmt den Schritt. Den Rest berechnen wir in C entweder mit
dem Modulo Operator (%), oder, weil 16 eine 2er Potenz ist mit einem binären
UND:

<p>
<blockquote>
 1) LevelPositionY % BLOCKHÖHE<p>
 2) LevelPositionY & (BLOCKHÖHE -1)
</blockquote>
<p>

Dabei erhält man Werte zwischen 0 und BLOCKHÖHE - 1, in unserem Falle (d. h.
Blockhöhe 16 Pixel) also zwischen 0 und 15. Der sich in der Reihe ganz links
befindende Block ist Block 0, der ganz rechts Block 19. Wir gingen davon aus,
nach unten zu scrollen, wollen also von LevelPositionY 0 zu LevelPositionY 1.
Da der errechnete Schritt für Levelposition 1 gleich 1 ist, wir aber zuerst den
Block ganz links (= Block 0) blitten müssen bzw. wollen, erhöhen wir die Variable
für LevelPositionY (in den Quelltexten mapposy genannt) erst am Ende der ScrollRunter()
Funktion. So erhalten wir für das Scrolling von Levelposition 0 nach Levelposition
1 den Schrittwert 0, für das Scrolling von Levelposition 1 nach Levelposition 2
den Schrittwert 1 usw. Bei den Schritten 0 .. 11 blitten wir den Block SCHRITT der
"Nachfüllreihe". Bei den Schritten 12 .. 15 (die letzten 4) blitten wir den Block
12 + (SCHRITT - 12) * 2 und den Block 12 + (SCHRITT - 12) * 2 + 1. So wird die Reihe
nach und nach mit dem neuen Levelbereich gefüllt. <p>

Eine Frage ist natürlich noch offen. An welcher Y-Position befindet sich die
Nachfüllreihe in der Bitmap - wo müssen die neuen Blöcke geblittet werden?
Antwort: An der Stelle, wo sich die "hinauswandernde" Blockreihe befindet. Im
obigen Beispiel wäre das die Reihe 0. Da während des Scrollens jeder Block
zweimal geblittet wird, also einmal in der oberen und einmal in der unteren
der beiden Bitmaphälften wandert der aktuell sichtbare Bereich beim Nach-Unten-Scrollen
langsam in Richtung der Nachfüllreihe der unteren Bitmaphälfte. Sie wird
gerade rechtzeitig fertig gefüllt sein, also noch bevor der User sie zu Gesicht
bekommt. Denn sobald das geschieht ist die Nachfüllreihe bereits vertikal einen
Block weitergerückt. In den Quelltexten enthält die Variable videoposy die
Position des aktuellen Bitmapbereiches (rotes Rechteck). Daraus errechnen
wir die Position in der Bitmap, an der sich die Nachfüllreihe befindet, d. h.
wo wir die Blöcke blitten müssen. Dazu gibt es wieder eine langsame (1) und eine
schnelle (2) Methode, wobei letztere wieder nur dann funktioniert wenn BLOCKHÖHE
ein 2er Potenz ist:<p>

<p>
<blockquote>
1) y = videoposy - (videoposy % BLOCKHÖHE)<p>
2) y = videoposy & ~(BLOCKHÖHE - 1)
</blockquote>
</p>

Diese Formel errechnet die Position in der oberen Bitmaphälfte. Für den Blit
in die untere Bitmaphälfte addieren wir einfach HALBEBITMAPHÖHE, d. h. 288.
In den Demo Quelltexten wird dieser Wert noch mit ANZPLANES multipliziert,
weil die Blockblit-Routine die Y-Koordinate in Planelines (1 Pixelzeile
besteht aus ANZPLANES Planelines) erwartet.<p>

Das nach Oben-Scrollen geschieht analog, mit dem Unterschied, daß wir die
LevelPositionY nicht am Ende der Scroll-Funktion ändern, sondern am Anfang.
Wir verwenden sozusagen Pre-Dekrement im Gegensatz zum Post-Inkrement beim
Nach-Unten-Scrollen. Der Grund ist ganz einfach. Stellen wir uns vor, wir
sind von LevelPosition 0 nach LevelPosition 1, also 1 Pixel nach unten,
gescrollt. Das Ergebnis ist, daß Block 0 (ganz links) der Nachfüllspalte
einen unten hereinkommenden Block, genauer gesagt Block (0,18), d. h.
den 19. Block der Levelspalte ganz links, enthält - im folgenden
Bild als ein gelbes Rechteck mit roter Umrandung dargestellt:<p>

<center>
 <img src="images/yunlimited2.gif" width=168 height=296>
</center>

<p>
Wir befinden uns also an Levelposition 1 und wollen wieder zurück nach
Levelposition 0, d. h. der gelb-rote Block muß weg und mit Block (0,0)
ersetzt werden. Aus Levelposition 1 errechnet sich der Schritt 1, was
falsch ist, weil das bedeuten würde den Block (1,0) rechts neben dem gelb-roten
Block zu blitten. Wenn wir die Levelposition aber am Anfang der ScrollRauf()
Funktion ändern, dann errechnet sich der Schritt aus Levelposition 0 und
wir erhalten als Ergebnis 0 (0 % 16 = 0). Das heißt dann für die Scroll-Funktion
Block (0,0) über das gelb-rote Rechteck zu blitten - genau das was wir
wollen :-)<p>

Wie bereits gesagt, wird
der "aktuelle" und sichtbare Bitmapbereich (rotes Rechteck im vorvorletztem
Bild) beim Scrollen analog zur Scroll-Richtung verschoben. Was passiert
aber, wenn wir so weit nach unten gescrollt haben, daß der Bereich Gefahr
läuft über die Bitmapgrenzen hinauszulaufen? Das passiert ja schon nach
288 Pixeln. Ganz einfach. Wenn wir so weit nach unten gescrollt sind,
dann setzen wir den aktuellen und somit automatisch auch den sichtbaren
Bitmapbereich wieder an den Anfang der
Bitmap (Position 0). Das geht deshalb, weil die obere und untere Bitmaphälfte
ja genau gleich ausschauen. Und wenn der Bereich droht, oben über die
Bitmapgrenze hinauszuscrollen, dann setzen wir ihn einfach an das untere
Maximum (Position 287). Ganz konkret heißt das, daß sich die Position
des "aktuellen" Bitmapbereichs durch folgende Formel
errechnet:

<p>
<blockquote>
videoposy = LevelPositionY % HALBEBITMAPHÖHE, d. h.<br>
videoposy = LevelPositionY % 288
</blockquote>
<p>

Noch einige Bemerkungen zum Quelltext des Demoprogrammes. Wenn die Variable
mapposy, die die Levelposition Y in Pixeln enthält, auf 0 steht, dann sieht
der User den Levelbereich ab Position BLOCKHÖHE (16), weil die ersten
BLOCKHÖHE (16) Pixel stets verdeckt sind. Der User sieht also den Bereich:<p>

<blockquote>
 (0,mapposy + BLOCKHEIGHT) - (SCREENWIDTH - 1,mapposy + BLOCKHEIGHT + SCREENHEIGHT - 1)
</blockquote>

<p>

Das heißt, daß die erste Blockreihe der Leveldatei nie sichtbar ist.
Will man in die Bitmap etwas hineinblitten, z. B. Blitter Objekte (BOBs), dann
muß man das im aktuell sichtbaren Bitmapbereich machen. Dieser Bereich ist:<p>

<blockquote>
 (0,videoposy + BLOCKHEIGHT) - (SCREENWIDTH - 1,videoposy + BLOCKHEIGHT + SCREENHEIGHT - 1)
</blockquote>

<p>
 
Man darf die Start-Y Koordinate (videoposy + BLOCKHEIGHT) und die End-Y Koordinate (videoposy + BLOCKHEIGHT + SCREENHEIGHT - 1)
auf ein Vielfaches von BLOCKHEIGHT auf- bzw. abrunden, sodaß der Bereich, in den
geblittet werden darf insgesamt SCREENHEIGHT + BLOCKHEIGHT Pixel hoch ist:<p>

<blockquote>
 blitbereich_strty = (videoposy + BLOCKHEIGHT) & ~(BLOCKHEIGHT - 1)<p>
 blitbereich_endey = blitbereich_strtx + SCREENHEIGHT + BLOCKHEIGHT - 1
</blockquote>

</body>
</html>
