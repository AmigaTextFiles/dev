<html>
<head>
 <title>The source codes use this #defines, macros und variables</title>
</head>
<body bgcolor="#FFFFFF">

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">#defines</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>BLOCKWIDTH</td>
  <td>Width of one block in pixels.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKHEIGHT</td>
  <td>Height of one block in pixels.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKPLANELINES</td>
  <td>Height of one block in planelines. One pixelline consists of BLOCKSDEPTH
      planelines.</td>
 </tr>
 <tr>
  <td valign=top>SCREENWIDTH</td>
  <td>Width of visible screen area in pixels.</td>
 </tr>
 <tr>
  <td valign=top>SCREENHEIGHT</td>
  <td>Height of visible screen area in pixels.</td>
 </tr>
 <tr>
  <td valign=top>SCREENBYTESPERROW</td>
  <td>Width of visible screen area in bytes.</td>
 </tr>
 <tr>
  <td valign=top>EXTRAWIDTH</td>
  <td>Extrawidth of bitmap in pixels, to make sure that there is some invisible
      area we can blit to. Usually equals to BLOCKWIDTH * 2. Exceptions might be
      necessary for higher FETCH Modes to get the correct bitmap aligning.</td>
 </tr>
 <tr>
  <td valign=top>EXTRAHEIGHT</td>
  <td>Extraheight of bitmap in pixels, to make sure that there is some invisible
      area we can blit to. Usually equals to BLOCKHEIGHT * 2.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPWIDTH</td>
  <td>Overall width of bitmap in pixels.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPHEIGHT</td>
  <td>Overall height of bitmap in pixels. In some source codes/algorithms when
      allocating the bitmap the bitmap height that is requested might be
      greater than this, for several reasons!</td>
 </tr>
 <tr>
  <td valign=top>PLANEPIXELBITMAPWIDTH</td>
  <td>Overall width of bitmap in planepixels. 1 real pixel consists of
      BLOCKSDEPTH planepixels.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPPLANELINES</td>
  <td>Height of bitmap in planelines. 1 pixelline consists of BLOCKSDEPTH
      planelines.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBYTESPERROW</td>
  <td>Width of bitmap in bytes.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPWIDTH</td>
  <td>Equals half the BITMAPWIDTH. Is only used by Scroller_XUnlimited,
      whose algorithm is based on a double-width bitmap.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPHEIGHT</td>
  <td>Equals half the BITMAPHEIGHT. Is only used by Scroller_YUnlimited,
      whose algorithm is based on a double-height bitmap.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSWIDTH</td>
  <td>Width in pixels of the bitmap that contains the imagedata of the blocks.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSHEIGHT</td>
  <td>Height in pixels of the bitmap that contains the imagedata of the blocks.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSBYTESPERROW</td>
  <td>Width in bytes of the bitmap that contains the imagedata of the blocks.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSDEPTH</td>
  <td>The blocks' number of planes.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSCOLORS</td>
  <td>The blocks' number of colors. Equals 2 ^ BLOCKSDEPTH.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSPERROW</td>
  <td>Number of blocks per row in the blocks-bitmap.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBLOCKSPERROW</td>
  <td>Number of blocks per row in the main (scroll-)bitmap.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBLOCKSPERCOL</td>
  <td>Number of blocks per column in the main bitmap.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPBLOCKSPERROW</td>
  <td>Number of blocks per row in one bitmap half. Is only used by
      the Scroller_XUnlimited algorithm.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPBLOCKSPERCOL</td>
  <td>Number of blocks per column in one bitmap half. Is only used by
      the Scroller_YUnlimited algorithm.</td>
 </tr>
 <tr>
  <td valign=top>TWOBLOCKS</td>
  <td>For vertical scrolling: how many of the overall BLOCKHEIGHT steps
      need 2 blocks to be blitted, to have the vertical-fillup-row completely
      blittet at the last step.</td>
 </tr>
 <tr>
  <td valign=top>TWOBLOCKSTEP</td>
  <td>For vertical scrolling: At which step do we have to change from
      1 blockblit per step to 2 blockblits per step.</td>
 </tr>

</table>

<p>

<table border=0><tr><td height=20>&nbsp;</td></tr></table>

<!-- ===================================================================== -->

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">Macros</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>ROUND2BLOCKWIDTH(x)</td>
  <td>Rounds down x to a multiple of BLOCKWIDTH.</td>
 </tr>
 <tr>
  <td valign=top>ROUND2BLOCKHEIGHT(x)</td>
  <td>Rounds down x to a multiple of BLOCKHEIGHT.</td>
 </tr>
 <tr>
  <td valign=top>ADJUSTDESTCOORDS(x,y)</td>
  <td>Makes sure that x is lower than BITMAPWIDTH and that y is lower than
      BITMAPHEIGHT. Corrections of x affect y.</td> 
 </tr>

</table>

<p>

<table border=0><tr><td height=20>&nbsp;</td></tr></table>

<!-- ===================================================================== -->

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">Variables</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>BlocksBitmap</td>
  <td>Pointer to OS-Bitmap-Structure of the bitmap that contains the image data of the blocks.</td>
 </tr>
 <tr>
  <td valign=top>ScreenBitmap</td>
  <td>Pointer to OS-Bitmap-Structure of the main bitmap that is used for scrolling.</td>
 </tr>
 <tr>
  <td valign=top>frontbuffer</td>
  <td>Pointer to graphic data (1st plane) of the scrollbitmap.
      This address can be different from the real bitplane
      address by 2 or 6 bytes in 2x and 4x FETCH Mode.</td>
 </tr>
 <tr>
  <td valign=top>blocksbuffer</td>
  <td>Pointer to graphic data (1st plane) of the blocksbitmap.</td>
 </tr>
 <tr>
  <td valign=top>mapdata</td>
  <td>Pointer to the map's data array.</td>
 </tr>
 <tr>
  <td valign=top>mapwidth</td>
  <td>Width of the map in blocks.</td>
 </tr>
 <tr>
  <td valign=top>mapheight</td>
  <td>Height of the map in blocks.</td>
 </tr>
 <tr>
  <td valign=top>mapposx</td>
  <td>Actual map position X in pixels.</td>
 </tr>
 <tr>
  <td valign=top>mapposy</td>
  <td>Actual map position Y in pixels.</td>
 </tr>
 <tr>
  <td valign=top>videoposx</td>
  <td>X position of the actual bitmap area in pixels.</td>
 </tr>
 <tr>
  <td valign=top>videoposy</td>
  <td>Y position of the actual bitmap area either in pixels or in planelines
      depending on the algorithm.</td>
 </tr>
 <tr>
  <td valign=top>block_videoposy</td>
  <td>Y Position of the vertical-fillup-row either in pixels or in planelines
      depending on the algorithm.</td>
 </tr>
 <tr>
  <td valign=top>stepx</td>
  <td>Actual step for horizontal scrolling. Equals mapposx % BLOCKWIDTH.</td>
 </tr>
 <tr>
  <td valign=top>stepy</td>
  <td>Actual step for vertical scrolling. Equals mapposy % BLOCKHEIGHT.</td>
 </tr>
 <tr>
  <td valign=top>savewordpointer</td>
  <td>Address, from where a planeline backup was made, because of the two
      possible 'states' of the horizontal-fillup-column.</td>
 </tr>
 <tr>
  <td valign=top>saveword</td>
  <td>The planeline backup. Restoring (to change the 'state' of the
      horizontal-fillup-column) is done by copying it to savewordpointer.</td>
 </tr>
 <tr>
  <td valign=top>fetchinfo</td>
  <td>Structure array containing several information about the different FETCH
      Modes, for example what values to use for DDFSTART/DDFSTOP, etc.</td>
 </tr>

</table>

</body>
</html>
