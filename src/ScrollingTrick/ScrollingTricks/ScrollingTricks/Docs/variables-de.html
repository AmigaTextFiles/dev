<html>
<head>
 <title>Verwendete #defines, Makros und Variablen in den Quelltexten</title>
</head>
<body bgcolor="#FFFFFF">

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">#defines</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>BLOCKWIDTH</td>
  <td>Breite eines Blockes in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKHEIGHT</td>
  <td>Höhe eines Blockes in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKPLANELINES</td>
  <td>Höhe eines Blockes in Planelines. Eine Pixelzeile besteht aus BLOCKSDEPTH
      Planelines.</td>
 </tr>
 <tr>
  <td valign=top>SCREENWIDTH</td>
  <td>Breite des sichtbaren Bildschirmausschnittes in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>SCREENHEIGHT</td>
  <td>Höhe des sichtbaren Bildschirmausschnittes in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>SCREENBYTESPERROW</td>
  <td>Breite des sichtbaren Bildschirmausschnittes in Bytes.</td>
 </tr>
 <tr>
  <td valign=top>EXTRAWIDTH</td>
  <td>Zusatzbreite der Bitmap in Pixeln, damit in einem Bereich geblittet
      werden kann, der nicht sichtbar is. Entspricht normalerweise der BLOCKWIDTH
      * 2. Ausnahmen können notwendig sein, um für höhere FETCH Modi das korrekte
      Bitmap Aligning zu bekommen.</td>
 </tr>
 <tr>
  <td valign=top>EXTRAHEIGHT</td>
  <td>Zusatzhöhe der Bitmap in Pixeln, damit in einem Bereich geblittet
      werden kann, der nicht sichtbar is. Entspricht grundsätzlich der BLOCKHEIGHT
      * 2.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPWIDTH</td>
  <td>Gesamtbreite der Bitmap in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPHEIGHT</td>
  <td>Gesamthöhe der Bitmap in Pixeln. Bei einigen Quelltexten/Algorithmen wird
      zu diesem Wert beim Allozieren der Bitmap aus unterschiedlichen Gründen
      noch verschiedenes dazugezählt!</td>
 </tr>
 <tr>
  <td valign=top>PLANEPIXELBITMAPWIDTH</td>
  <td>Gesamtbreite der Bitmap in Planepixeln. 1 echtes Pixel besteht aus
      BLOCKSDEPTH Planepixeln.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPPLANELINES</td>
  <td>Höhe der Bitmap in Planelines. Eine Pixelzeile besteht aus BLOCKSDEPTH
      Planelines.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBYTESPERROW</td>
  <td>Gesamtbreite der Bitmap in Bytes.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPWIDTH</td>
  <td>Entspricht der halben BITMAPWIDTH. Wird nur vom Scroller_XUnlimited verwendet,
      weil dessen Algorithmus auf einer doppelt breiten Bitmap basiert.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPHEIGHT</td>
  <td>Entspricht der halben BITMAPHEIGHT. Wird nur vom Scroller_YUnlimited verwendet,
      weil dessen Algorithmus auf einer doppelt hohen Bitmap basiert.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSWIDTH</td>
  <td>Breite der Bitmap, die die Grafikdaten der Blöcke enthält in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSHEIGHT</td>
  <td>Höhe der Bitmap, die die Grafikdaten der Blöcke enthält in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSBYTESPERROW</td>
  <td>Breite der Bitmap, die die Grafikdaten der Blöcke enthält in Bytes.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSDEPTH</td>
  <td>Anzahl Bitplanes der Blöcke.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSCOLORS</td>
  <td>Anzahl Farben der Blöcke. Enspricht 2 ^ BLOCKSDEPTH.</td>
 </tr>
 <tr>
  <td valign=top>BLOCKSPERROW</td>
  <td>Anzahl Blöcke pro Reihe in der Blöckebitmap.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBLOCKSPERROW</td>
  <td>Anzahl Blöcke, die in der (Scroll)Bitmap in eine Reihe passen.</td>
 </tr>
 <tr>
  <td valign=top>BITMAPBLOCKSPERCOL</td>
  <td>Anzahl Blöcke, die in der Bitmap in eine Spalte passen.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPBLOCKSPERROW</td>
  <td>Anzahl Blöcke, die in einer Bitmaphälfte in eine Reihe passen.
      Wird nur vom Scroller_XUnlimited Algorithmus verwendet.</td>
 </tr>
 <tr>
  <td valign=top>HALFBITMAPBLOCKSPERCOL</td>
  <td>Anzahl Blöcke, die in einer Bitmaphälfte in eine Spalte passen.
      Wird nur vom Scroller_YUnlimited Algorithmus verwendet.</td>
 </tr>
 <tr>
  <td valign=top>TWOBLOCKS</td>
  <td>Für Vertikal-Scrolling: bei wievielen der insgesamt BLOCKHEIGHT
      Schritte 2 Blöcke geblittet werden müssen, um beim letzten Schritt
      die Vertikal-Nachfüllreihe komplett zu haben.</td>
 </tr>
 <tr>
  <td valign=top>TWOBLOCKSTEP</td>
  <td>Für Vertikal-Scrolling: Ab welchem Schritt der Wechsel von 1
      Blockblit pro Schritt auf 2 Blockblits pro Schritt gemacht werden muß.</td>
 </tr>

</table>

<p>

<table border=0><tr><td height=20>&nbsp;</td></tr></table>

<!-- ===================================================================== -->

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">Makros</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>ROUND2BLOCKWIDTH(x)</td>
  <td>Rundet x auf ein Vielfaches von BLOCKWIDTH ab.</td>
 </tr>
 <tr>
  <td valign=top>ROUND2BLOCKHEIGHT(x)</td>
  <td>Rundet x auf ein Vielfaches von BLOCKHEIGHT ab.</td>
 </tr>
 <tr>
  <td valign=top>ADJUSTDESTCOORDS(x,y)</td>
  <td>Sorgt dafür, daß x kleiner BITMAPWIDTH und y kleiner
      BITMAPHEIGHT ist. Falls x korrigiert werden muß, wirkt sich das auf y aus.</td>
 </tr>

</table>

<p>

<table border=0><tr><td height=20>&nbsp;</td></tr></table>

<!-- ===================================================================== -->

<table width="100%">
 <tr>
  <td align=center valign=middle bgcolor=#000000><font size=+2 color="#FFFFFF">Variablen</font></td>
 </tr>
</table>

<p>

<table border=2 width="100%">
 <tr>
  <td valign=top>BlocksBitmap</td>
  <td>Zeiger auf die OS-Bitmap-Struktur von der Bitmap, die die Grafikdaten der Blöcke enthält.</td>
 </tr>
 <tr>
  <td valign=top>ScreenBitmap</td>
  <td>Zeiger auf die OS-Bitmap-Struktur von der Bitmap, die zum Scrollen verwendet wird.</td>
 </tr>
 <tr>
  <td valign=top>frontbuffer</td>
  <td>Zeiger auf die Grafikdaten (1. Plane) der Scrollbitmap.
      Diese Adresse kann im 2x und 4x FETCH Modus von der
      echten Bitplane Adresse um 2 bzw. 6 Bytes abweichen.</td>
 </tr>
 <tr>
  <td valign=top>blocksbuffer</td>
  <td>Zeiger auf die Grafikdaten (1. Plane) der Blöckebitmap.</td>
 </tr>
 <tr>
  <td valign=top>mapdata</td>
  <td>Zeiger auf das Leveldaten-Array.</td>
 </tr>
 <tr>
  <td valign=top>mapwidth</td>
  <td>Breite des Levels in Blöcken.</td>
 </tr>
 <tr>
  <td valign=top>mapheight</td>
  <td>Höhe des Levels in Blöcken.</td>
 </tr>
 <tr>
  <td valign=top>mapposx</td>
  <td>Aktuelle Level Position X in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>mapposy</td>
  <td>Aktuelle Level Position Y in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>videoposx</td>
  <td>X-Position des aktuellen Bitmapbereiches in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>videoposy</td>
  <td>Y-Position des aktuellen Bitmapbereiches je nach Algorithmus in Planelines oder in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>block_videoposy</td>
  <td>Y-Position der Vertikal-Nachfüllreihe je nach Algorithmus in Planelines oder in Pixeln.</td>
 </tr>
 <tr>
  <td valign=top>stepx</td>
  <td>Aktueller Schritt für Horizontal-Scrolling. Entspricht mapposx % BLOCKWIDTH.</td>
 </tr>
 <tr>
  <td valign=top>stepy</td>
  <td>Aktueller Schritt für Vertikal-Scrolling. Entspricht mapposy % BLOCKHEIGHT.</td>
 </tr>
 <tr>
  <td valign=top>savewordpointer</td>
  <td>Adresse, von der ein Planeline Backup gemacht wird, wegen der zwei möglichen
      'Zustände' der Horizontal-Nachfüllspalte.</td>
 </tr>
 <tr>
  <td valign=top>saveword</td>
  <td>Das Planeline-Backup. Beim Restaurieren, zum Wechsel des 'Zustandes' der
      Horizontal-Nachfüllspalte, wird es nach savewordpointer kopiert.</td>
 </tr>
 <tr>
  <td valign=top>fetchinfo</td>
  <td>Struktur-Array, das für die verschiedenen FETCH Modi verschiedene Informationen
      enthält, z. B. Werte für DDFSTART/DDFSTOP, usw.</td>
 </tr>

</table>

</body>
</html>
