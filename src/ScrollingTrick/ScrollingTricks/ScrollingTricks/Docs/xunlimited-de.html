<html>
<head>
 <title>Scroller_XUnlimited</title>
</head>
<body bgcolor=#FFFFFF>

Dieser Algorithmus verwendet eine relativ große (breite) Bitmap. Deshalb
ist er im allgemeinen nicht die erste Wahl, hat aber den Vorteil, daß die
Bitmapgröße unabhängig von der Levelgröße ist. Im Normalfall sollte man
diese Technik nicht verwenden, weil sie nur halb so schnell wie die von
Scroller_XLimited bzw. Scroller_XLimited_64 ist. Eine Ausnahme kann man
machen, wenn die Levels wirklich riesig sind, und deshalb der Nachteil
der "Limited-Algorithmen", nämlich die Abhängigkeit der Bitmapgröße von
der Levelgröße, extrem ausschlaggebend ist.<p>

Warum muß die Bitmap eigentlich 704 Pixel breit sein? Zuerst einmal muß
man sagen, daß die Bitmap generell breiter sein muß als der sichtbare
Bereich, weil wir "neu hereinkommende" Levelbereiche blockweise blitten
und das in einem Bereich machen müssen, den man nicht sieht - sonst sieht
das für den User gar nicht schön oder professionell aus. Der sichtbare
Bereich beträgt 320 Pixel in der Breite, d. h. 20 Blöcke (SICHTBARE
BREITE : BLOCKBREITE = 320 : 16 = 20). Es sind aber nicht immer nur 20
Blöcke horizontal sichtbar, meistens sind es 21, nämlich immer dann, wenn
die Levelposition (d. h. die horizontale Position des Levelausschnittes
in Pixel) nicht durch 16 (BLOCKBREITE) teilbar ist.<p>

<center>
 <img src="images/visibleblocks.gif" width=365 height=145><p>
</center>

Deshalb muß die Bitmap mindestens 22 Blöcke breit sein, d. h. 2 Blöcke 
= 32 Pixel mehr als die sichtbare Breite. Je nach FETCH Modus müssen
wir außerdem noch beachten, daß die Breite der Bitmap richtig aligned
ist: im 1x FETCH Modus muß die Breite ein Vielfaches von 16, im 2x
FETCH Modus ein Vielfaches von 32 und im 4x FETCH Modus ein Vielfaches
von 64 sein. Es stimmt <b>nicht</b>, daß die Extrabreite der Bitmap mindestens
so groß sein muß, wie der Bereich, den wir links mit Hilfe einiger
Copper Display Register (DIWSTART, DIWSTOP, DDFSTART, DDFSTOP) verstecken
müssen, um einen unschönen "Schiebeeffekt" zu verhindern. So muß dieser
Bereich im 4x FETCH Modus zwar 64 Pixel breit sein (2x: 32 Pixel, 1x: 16 Pixel),
aber dennoch kommen wir z. B. bei einer sichtbaren Breite von 288
mit einer Extrabreite von 32 aus. 288 + 32 = 320. 320 ist ein Vielfaches von
64 und damit für den 4x FETCH Modus ok. Bei einer sichtbaren Breite von 320
Pixeln hingegen reicht eine Extrabreite von 32 für den 4x FETCH Modus nicht
aus, weil die daraus resultierende Bitmapbreite (352) nicht ein Vielfaches von
64 ist.<p>

320 + 32 ist
aber nur 352? War da nicht die Rede von 704 Pixeln? Nun, auf 704 Pixel kommen
wir, wenn wir 352 mit 2 multiplizieren. Der wesentliche Trick von diesem
Scroll-Algorithmus besteht nämlich darin, daß unsere Bitmap doppelt so breit
ist, wie sie eigentlich sein müßte. Die rechte Hälfte ist stets eine exakte
Kopie der linken Hälfte. Deshalb wird beim Scrollen jeder zu blittende Block
einmal in der linken und einmal in der rechten Hälfte geblittet. So ganz
richtig mit der exakten Kopie ist das aber nur solange keine BOBs geblittet
werden. Die müssen nämlich zum Glück nur einmal geblittet werden. Das aber
nur nebenbei gesagt. Zu Beginn füllen wir die beiden Bitmaphälften mit dem
anfangs sichtbaren Levelbereich:<p>

<center>
 <img src="images/xunlimited.gif" width=360 height=149>
</center>

<p>

Das rote Rechteck stellt den am Anfang aktuellen Bereich dar, der mit dem
Copper dargestellt wird, wobei die ersten und letzten 16 Pixel ausgeblendet
sind. Der User sieht also nur den vom gelben Rechteck eingegrenzten Bereich.
Wenn wir nach rechts scrollen, dann verschiebt sich auch der aktuelle
Bereich nach rechts. Wenn wir nach links scrollen, dann verschiebt er sich
nach links. Den sichtbaren Bereich zu verschieben reicht natürlich nicht aus.
Wir müssen auch die neu hereinkommenden Blöcke in die Bitmap blitten. Gehen
wir mal davon aus, daß wir nach rechts wollen. Am Anfang befinden sich in den
beiden Bitmaphälften die Blockspalten 0 bis 21, also die ersten 22 Spalten
des Levels. Nach spätestens 16 Pixeln (= Breite einer Spalte) Nach-Rechts-Scrollen
müssen sich die Blockspalten 1 bis 22 in beiden Bitmaphälften befinden. Da
wir 16 Pixel lang Zeit dazu haben blitten wir die neue (22) Blockspalte nicht
auf einmal, sondern schrittweise. 16 Pixel Zeit heißt, daß wir sie in 16 Schritten
blitten. Eine Blockspalte besteht aus 16 (BITMAPHÖHE : BLOCKHÖHE = 256 : 16 = 16)
Blöcken. Deshalb brauchen wir pro Schritt (= pro 1-Pixel-Scrolling) nur einen
Block zu blitten. Welchen Schritt = welchen Block wir in einer bestimmten
Situation (= LevelPosition) blitten müssen, berechnen wir, indem wir die
LevelPositionX durch 16 (BLOCKBREITE) dividieren und uns den Rest anschauen.
Der nämlich bestimmt den Schritt. Den Rest berechnen wir in C entweder mit
dem Modulo Operator (%), oder, weil 16 eine 2er Potenz ist mit einem binären
UND:

<p>
<blockquote>
 1) LevelPositionX % BLOCKBREITE<p>
 2) LevelPositionX & (BLOCKBREITE -1)
</blockquote>
<p>

Dabei erhält man Werte zwischen 0 und BLOCKBREITE - 1, in unserem Falle (d. h.
Blockbreite 16 Pixel) also zwischen 0 und 15. Der sich in der Spalte ganz oben
befindende Block ist Block 0, der ganz unten Block 15. Wir gingen davon aus,
nach rechts zu scrollen, wollen also von LevelPositionX 0 zu LevelPositionX 1.
Da der errechnete Schritt für Levelposition 1 gleich 1 ist, wir aber zuerst den
obersten Block (= Block 0) blitten müssen bzw. wollen, erhöhen wir die Variable
für LevelPositionX (in den Quelltexten mapposx genannt) erst am Ende der ScrollRechts()
Funktion. So erhalten wir für das Scrolling von Levelposition 0 nach Levelposition
1 den Schrittwert 0, für das Scrolling von Levelposition 1 nach Levelposition 2
den Schrittwert 1 usw. So wird die Spalte nach und nach mit dem neuen Levelbereich
gefüllt.<p>

Ein Stück weiter oben stand, daß die ersten und letzten 16 Pixel des aktuellen
Bitmapbereiches ausgeblendet sind, sodaß der User letzendlich den durch das
gelbe Rechteck dargestellten Bereich sieht. Beim 1x FETCH Modus müssen wir
sowieso die ersten 16 Pixel verdecken, um links den bereits erwähnten Schiebeeffekt
zu verhindern - das paßt genau. Beim 2x FETCH Modus müssen wir aber 32
und beim 4x FETCH Modus sogar 64 Pixel verdecken. Um das Problem zu lösen gibt
es einen ganz einfachen Trick. Er funktioniert so, daß wir beim Blitten in die
Bitmap einfach annehmen, diese befände sich 16 Pixel = 2 Bytes (beim 2x
FETCH Modus) bzw. 48 Pixel = 6 Bytes weiter hinten im Speicher. Deshalb wird
der in den Quelltexten zum Blitten benutzten Bitmap-Variable frontbuffer nicht
die richtige Adresse der Bitmap zugewiesen sondern die Addresse plus einem
Offset (0 Bytes für 1x FETCH Modus - 2 für 2x Modus - 6 für 4x Modus). Wir dürfen
dann nicht vergessen, beim Anlegen der Bitmap 1 Zeile (wenn
wenn wir die Bitmap mit AllocBitmap() erzeugen) bzw. 2 oder 6 Bytes (wenn wir
die Bitmap mit AllocMem() erzeugen) mehr anzufordern. Durch die Verwendung dieses
Offsets beim Zeichnen in die Bitmap sind keine weiteren Änderungen bei Benutzung
der 2x bzw. 4x FETCH Modi notwendig, weil wir uns sozusagen den Verdeckungsbereich
an die richtige Stelle schieben:<p>

<center>
 <img src="images/xunlimited3.gif" width=378 height=267>
</center>

<p>

Das blaue Rechteck in den obigen Bildern stellt die zweite Bitmaphälfte dar. Man
beachte den "Wraparound" über den rechten Rand und den daraus resultierenden
falbverfälschten Bereich auf der linken Seite. Diese Farbverfälschung - verursacht
durch "Plane-Verschiebung" - sieht man natürlich nur, wenn man die echte Bitmapaddresse
zur Anzeige verwendet und links nichts verdeckt.<p>

Eine Frage ist natürlich noch offen. An welcher X-Position befindet sich die
Nachfüllspalte in der Bitmap - wo müssen die neuen Blöcke geblittet werden?
Antwort: An der Stelle, wo sich die "hinauswandernde" Blockspalte befindet. Im
obigen Beispiel wäre das die Spalte 0. Da während des Scrollens jeder Block
zweimal geblittet wird, also einmal in der linken und einmal in der rechten
der beiden Bitmaphälften wandert der aktuell sichtbare Bereich beim Nach-Rechts-Scrollen
langsam in Richtung der Nachfüllspalte der rechten Bitmaphälfte. Sie wird
gerade rechtzeitig fertig gefüllt sein, also noch bevor der User sie zu Gesicht
bekommt. Denn sobald das geschieht ist die Nachfüllspalte bereits horizontal einen
Block weitergerückt. In den Quelltexten enthält die Variable videoposx die
Position des aktuellen Bitmapbereiches (rotes Rechteck). Daraus errechnen
wir die Position in der Bitmap, an der sich die Nachfüllspalte befindet, d. h.
wo wir die Blöcke blitten müssen. Dazu gibt es wieder eine langsame (1) und eine
schnelle (2) Methode, wobei letztere wieder nur dann funktioniert wenn BLOCKBREITE
ein 2er Potenz ist:<p>

<p>
<blockquote>
1) x = videoposx - (videoposx % BLOCKBREITE)<p>
2) x = videoposx & ~(BLOCKBREITE - 1)
</blockquote>
</p>

Diese Formel errechnet die Position in der linken Bitmaphälfte. Für den Blit
in die rechte Bitmaphälfte addieren wir einfach HALBEBITMAPBREITE, d. h. 352.<p>

Das nach Links-Scrollen geschieht analog, mit dem Unterschied, daß wir die
LevelPositionX nicht am Ende der Scroll-Funktion ändern, sondern am Anfang.
Wir verwenden sozusagen Pre-Dekrement im Gegensatz zum Post-Inkrement beim
Nach-Rechts-Scrollen. Der Grund ist ganz einfach. Stellen wir uns vor, wir
sind von LevelPosition 0 nach LevelPosition 1, also 1 Pixel nach rechts,
gescrollt. Das Ergebnis ist, daß Block 0 (ganz oben) der Nachfüllspalte
einen rechts hereinkommenden Block, genauer gesagt Block (22,0), d. h.
der 23. Block in der obersten Reihe des Levels, enthält - im folgenden
Bild als ein gelbes Rechteck mit roter Umrandung dargestellt:<p>

<center>
 <img src="images/xunlimited2.gif" width=352 height=128>
</center>

<p>
Wir befinden uns also an Levelposition 1 und wollen wieder zurück nach
Levelposition 0, d. h. der gelb-rote Block muß weg und mit Block (0,0)
ersetzt werden. Aus Levelposition 1 errechnet sich der Schritt 1, was
falsch ist, weil das bedeuten würde den Block (0,1) unter dem gelb-roten
Block zu blitten. Wenn wir die Levelposition aber am Anfang der ScrollLinks()
Funktion ändern, dann errechnet sich der Schritt aus Levelposition 0 und
wir erhalten als Ergebnis 0 (0 % 16 = 0). Das heißt dann für die Scroll-Funktion
Block (0,0) über das gelb-rote Rechteck zu blitten - genau das was wir
wollen :-)<p>

Etwas ganz wichtiges hätte ich fast vergessen. Wie bereits gesagt, wird
der "aktuelle" und sichtbare Bitmapbereich (rotes Rechteck im vorvorletztem
Bild) beim Scrollen analog zur Scroll-Richtung verschoben. Was passiert
aber, wenn wir so weit nach rechts gescrollt haben, daß der Bereich Gefahr
läuft über die Bitmapgrenzen hinauszulaufen? Das passiert ja schon nach
352 Pixeln. Ganz einfach. Wenn wir so weit nach rechts gescrollt sind,
dann setzen wir den aktuellen und damit automatisch auch den sichtbaren
Bitmapbereich wieder an den Anfang der
Bitmap (Position 0). Das geht deshalb, weil die linke und rechte Bitmaphälfte
ja genau gleich ausschauen. Und wenn der Bereich droht, links über die
Bitmapgrenze hinauszuscrollen, dann setzen wir ihn einfach an das rechte
Maximum (Position 351). Ganz konkret heißt das, daß sich die Position
des "aktuellen" Bitmapbereichs durch folgende Formel
errechnet:

<p>
<blockquote>
videoposx = LevelPositionX % HALBEBITMAPBREITE, d. h.<br>
videoposx = LevelPositionX % 352
</blockquote>
<p>

Noch einige Bemerkungen zum Quelltext des Demoprogrammes. Wenn die Variable
mapposx, die die Levelposition X in Pixeln enthält, auf 0 steht, dann sieht
der User den Levelbereich ab Position BLOCKBREITE (16), weil die ersten
BLOCKBREITE (16) Pixel stets verdeckt sind. Der User sieht also den Bereich:<p>

<blockquote>
 (mapposx + BLOCKWIDTH,0) - (mapposx + BLOCKWIDTH + SCREENWIDTH - 1,SCREENHEIGHT - 1)
</blockquote>

<p>

Das heißt, daß die erste Blockspalte der Leveldatei nie sichtbar ist.
Will man in die Bitmap etwas hineinblitten, z. B. Blitter Objekte (BOBs), dann
muß man das im aktuell sichtbaren Bitmapbereich machen. Dieser Bereich ist:<p>

<blockquote>
 (videoposx + BLOCKWIDTH,0) - (videoposx + BLOCKWIDTH + SCREENWIDTH - 1,SCREENHEIGHT - 1)
</blockquote>

<p>
 
Man darf die Start-X Koordinate (videoposx + BLOCKWIDTH) und die End-X Koordinate (videoposx + BLOCKWIDTH + SCREENWIDTH - 1)
auf ein Vielfaches von BLOCKWIDTH auf- bzw. abrunden, sodaß der Bereich, in den
geblittet werden darf insgesamt SCREENWIDTH + BLOCKWIDTH Pixel breit ist:<p>

<blockquote>
 blitbereich_strtx = (videoposx + BLOCKWIDTH) & ~(BLOCKWIDTH - 1)<p>
 blitbereich_endex = blitbereich_strtx + SCREENWIDTH + BLOCKWIDTH - 1
</blockquote>

<p>

Grundlage fürs Blitten muß immer die Variable frontbuffer sein, weil diese
in den 2x und 4x FETCH Modi nicht identisch mit der echten Bitmapadresse ist!
</body>
</html>
