
-----------------------
TD Render Lib V1.0 Beta 
-----------------------
    FreeWare Lib
-----------------------
 By Yves ROSSO - 1997
-----------------------

First, i'm not a great coder :(, i've understood the basis of asm 
and E programming but i've no more time to learn all about mem
pointers using in asm ... So, i went to aminet to up load this 
sources of code and base bin, to give it to amiga users who are
interested in continue development.

The library need more shape drawing routines, effects routines,
better stars drawing, a better filling routine (mine is a trick,
no bug but not clean), ect ... Resolution adaptative :) ...
and certainly angles/vectors calc errors ;).


Purpose :   Making a 3D realtime graphic library that's independant
--------    from the hardware. By buffering all 3D faces tracing in 
            a fastmem buffer transfered on a double-buffered screen.
            
Sources :   In E :
--------    -----
            For controlling the Asm Library.
            My E source isn't a lot documented, you will find
            an example of double-buffered screen use in cgfx
            mode.
            
            You can use any language you want i think, if it 
            can call asm routines from lib.

            In Asm :
            -------
            3D rendering part
            I think my asm source is enough documented to
            explain what's done in it.
            For instance the lib use a 32bit xRGB buffer for
            drawing ( 320x240x32 provided by the E prog or
            yours, RaceCar or Space Simulation :).
            
Lib Functions :
--------------

;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdClearFrmBuf(a0)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0  (*) 320x240 buffer 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

tdClearFrmBuf(bufferaddress)(a0)

 = Clear the 32bit buffer to 0
            



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdClearFrmBufCol(a0,d0)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0  (*) 320x240 buffer
;               Color in D0  xRGB 32bit color
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

tdClearFrmBufCol(bufferaddress,color)(a0,d0)

 = Clear the 32bit buffer to a specified 32bit color
 

 
 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; D0 = tdRgbToVal(d0,d1,d2)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;           Red Color in D0  
;         Green Color in D1
;          Blue Color in D2
;
; return xRGB32 Color in D0 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdRgbToVal(r,g,b)(d0/d1/d2)

 = Convert an R=8bit,G=8bit,B=8bit color to xRGB=32bit color




;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; D0,D1,D2 = tdPixelColRgb(a0,d0,d1)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;        x coordinate in D0
;        y coordinate in D1
;
; return    Red Color in D0  
;         Green Color in D1
;          Blue Color in D2
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdPixelColRgb(bufferaddress,x,y)(a0,d0/d1)

 = Get color of point in 32bit buffer in R,G,B format
 
 
 
 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; D0 = tdPixelColVal(a0,d0,d1)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;        x coordinate in D0
;        y coordinate in D1
;
; return xRGB32 Color in D0 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdPixelColVal(bufferaddress,x,y)(a0,d0/d1)

 = Get color of point in 32bit buffer in xRGB format
 
 
 

 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdPixel(a0,d0,d1,d2)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;        X Coordinate in d0
;        Y Coordinate in d1
;               Color in d2
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdPixel(bufferadress,x,y,color)(a0,d0/d1/d2)

 = Draw a pixel in the 32bit buffer with specified color
 



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdLine(a0,d0,d1,d2,d3,d4)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;       Xo Coordinate in d0
;       Yo Coordinate in d1
;       Xe Coordinate in d2
;       Ye Coordinate in d3
;               Color in d4
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdLine(bufferaddress,xo,yo,xe,ye,color)(a0,d0/d1/d2/d3/d4)

 = Draw a line in the 32bit buffer with specified color
 



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdBox(a0,d0,d1,d2,d3,d4)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;       Xo Coordinate in d0
;       Yo Coordinate in d1
;       Xe Coordinate in d2
;       Ye Coordinate in d3
;               Color in d4
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdBox(bufferaddress,xo,yo,xe,ye,color)(a0,d0/d1/d2/d3/d4)

 = Draw a box in the 32bit buffer with specified color
 



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdBoxFill(a0,d0,d1,d2,d3,d4)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       BufferAddress in A0 
;       Xo Coordinate in d0
;       Yo Coordinate in d1
;       Xe Coordinate in d2
;       Ye Coordinate in d3
;               Color in d4
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdBoxFill(bufferaddress,xo,yo,xe,ye,color)(a0,d0/d1/d2/d3/d4)

 = Draw a filled box in the 32bit buffer




;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdDrawStars(a0,a1,d0,d1)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;      Render Buffer Address in A0 
;       Stars Buffer Address in A1
;               Stars Number in D0
;                  Draw Mode in D1 ( 0 - normal
;                                  ( 1 - flashing not really working ;(
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdDrawStars(bufferaddress,starbufferaddress,nbstars,mode)(a0/a1,d0/d1)

 = Draw 2D stars in 32bit buffer, you must provide a stars table
   in your soft.
   



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdMovRotStars(a0,d0,d1,d2,d3,d4,d5)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;       Stars Buffer Address in A0 
;              X Translation in D0
;              Y Translation in D1
;          X Rotation Center in D2
;          Y Rotation Center in D3  
;          Angle Of Rotation in D4 (degree value)
;               Stars Number in D5
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdMovRotStars(bufferaddress,transx,transy,centx,centy,angle,nbstars)(a0,d0/d1/d2/d3/d4/d5)

 = This modify 2D stars coords in stars table.
 



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdSetLight(d0,d1,d2,d3,d4,d5)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;      Light Xo position in D0 (integer) \
;            Yo position in D1 (integer)  |
;            Zo position in D2 (integer) /
;            -----------------------------> 2 pts to define a vector
;            Xe position in D3 (integer) \
;            Ye position in D4 (integer)  |
;            Ze position in D5 (integer) /
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdSetLight(xpos,ypos,zpos,xpos,ypos,zpos)(d0/d1/d2/d3/d4/d5)

 = Set the light position and direction in 3D space.




;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdSetCamera(d0,d1,d2,d3,d4,d5)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;           Camera X position in D0 (integer)
;                  Y position in D1 (integer)
;                  Z position in D2 (integer)
;                    an Angle in D3 (degree value) 
;                    bn Angle in D4 (degree value)
;                    cn Angle in D5 (degree value) 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdSetCamera(xpos,ypos,zpos,anglea,angleb,anglec)(d0/d1/d2/d3/d4/d5)

 = Set camera position and direction in 3D 





;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdGetMatrix(d0,d1,d2)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;                    an Angle in D0 (degree value) 
;                    bn Angle in D1 (degree value)
;                    cn Angle in D2 (degree value) 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdGetMatrix(anglea,angleb,anglec)(d0/d1/d2)

 = Calc a matrix with value given and store it in internal
   lib table. ( internally used by lib, but can be used
   also by extern call ) Look at the ASM source.
   


;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdRotCoord(d0,d1,d2)
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;                  X position in D0 (integer)
;                  Y position in D1 (integer)
;                  Z position in D2 (integer)
;
; Return Xrot,Yrot,Zrot in D0,D1,D2
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdRotCoord(xpos,ypos,zpos)(d0/d1/d2)

 = Calculated new X,Y,Z point position from matrix calculated
   with < tdGetMatrix > , the function don't trash matrix table.
   



;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdDrwObFrmCam(a0,a1,d0,d1,d2,d3,d4,d5)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;        Frame Buffer Address in A0 
; Object Faces Buffer Address in A1 
;           Object X position in D0 (integer)
;                  Y position in D1 (integer)
;                  Z position in D2 (integer)
;                    an Angle in D3 (degree value) 
;                    bn Angle in D4 (degree value)
;                    cn Angle in D5 (degree value) 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdDrwObFrmCam(bufferaddress,objectbuffer,xpos,ypos,zpos,anglea,angleb,anglec)(a0,a1,d0/d1/d2/d3/d4/d5)

 = Draw specified 3D object at a specified position and direction
   in function of the position and direction of the camera.
   
   ( Not really tested with camera movements for instance
   the E source have a fixed position camera with rotations free )




;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
; tdDrawObject(a0,a1,d0,d1,d2,d3,d4,d5)       
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
;        Frame Buffer Address in A0 
; Object Faces Buffer Address in A1 
;           Object X position in D0 (integer)
;                  Y position in D1 (integer)
;                  Z position in D2 (integer)
;                    an Angle in D3 (degree value) 
;                    bn Angle in D4 (degree value)
;                    cn Angle in D5 (degree value) 
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
tdDrawObject(bufferaddress,objectbuffer,xpos,ypos,zpos,anglea,angleb,anglec)(a0,a1,d0/d1/d2/d3/d4/d5)
 
 = Draw specified 3D object at a specified position and direction,
   do not use camera settings, the camera is fixed to 0 pos and dir.
   ( For testing object )



============================================================
 _________
| _    _  |
|( )| (_) |
| (_|____ |
|  _|____ |
|   |     |
|  _____  |
|_________|

22/06/97,   Yves ROSSO
            rosso@avo.net
            http://www.accueil.com/rosso/