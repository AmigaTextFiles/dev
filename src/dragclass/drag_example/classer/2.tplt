////////////////////////////////////////////////////////////
//
// $VER: Class.C.tplt 1.10 (18-06-94) (c) by Bernd "0" Noll
//
//  A skeleton to build easy and fast prototypes of small
//  BOOPSI-Klassen for test purposes.
//
// History:
//  11.05.94 1.7
//  23.05.94 1.8  added OM_*MEMBER
//  29-05-94 1.9  OBJ_??IT <-> OM_NEW/DISPOSE
//  18-06-94 1.10 added TRACKING
//
// Anmerkung:
//  Die folgende Auflistung erhebt weder Anspruch auf Vollstaendigkeit
//  noch auf Richtigkeit! Die vordefinierten Bezeichner sind noch nicht
//  vollstaendig durchdacht, daher kann ich nur eine vorlaeufige Liste
//  angeben, die (leider) nicht mit jeder Aenderung des Templates
//  aktualisiert wurde ...
//
// es ist eine reihe von Begriffen vordefiniert:
//  SUPER   - gibt die aktuellen parameter an die Superclass weiter
//  inst    - ist ein Zeiger auf die aktuelle Instanzenstruktur
//  o	    - ist das aktuelle Objekt
//  cl	    - ist die Klasse
//  msg     - ist die aktuelle Nachricht
//  val     - bei ISUN ti_Data des aktuellen attrs; bei G destination
// beim testen:
//  my_win  - Window
//  $(CLASS)_class - Class
//  my_gad  - 1.Object
//  im	    - IntuiMessage
//  done    - !running
//
////////////////////////////////////////////////////////////
//
//  Use the following line to rearrange the "#line"
//  directives found in this file, if You made any
//  change (the commands are XDME-syntax; if You might
//  use another editor (...) these commands are likely
//  to not work with it, else just call "col 3 eval $restofline"):
//
// ping 1 first find (#line) unfail (100 (next down getlineno xx up wright while ca del writevar xx)) pong 1
//
////////////////////////////////////////////////////////////
#line 47 "Class.C.tplt"


// needed for testing ...
#include <stdlib.h>
#include <stdio.h>

/* STANDARD INCLUDES */
#include <exec/types.h>
#include <exec/ports.h>
#include <exec/libraries.h>
#include <exec/execbase.h>
#include <intuition/intuitionbase.h>
#include <intuition/cghooks.h>
#include <intuition/classusr.h>
#include <intuition/classes.h>
#include <intuition/intuitionbase.h>
//#include "classnames.h"

#if $(HAS_TRACKING)
#include <support/AUTO.h>
#define DisposeObject(o)  DoMethod(o, OM_DISPOSE);
#define RemoveObject(o)   DoMethod(o, OM_REMOVE);
#define AppendObject(o,l) DoMethod(o, OM_ADDTAIL, l);
#endif


/* INCLUDES */
$(INCLUDES)
#line 76 "Class.C.tplt"


/* LIBRARY PROTOS */
#ifndef   CLIB_EXEC_PROTOS_H
#include <clib/exec_protos.h>
#endif
#ifndef   CLIB_INTUITION_PROTOS_H
#include <clib/intuition_protos.h>
#endif
#ifndef   CLIB_UTILITY_PROTOS_H
#include <clib/utility_protos.h>
#endif
#ifndef   CLIB_ALIB_PROTOS_H
#include <clib/alib_protos.h>
#endif
$(LIB_PROTOS)
#line 93 "Class.C.tplt"


/* PRIVATE INCLUDES */
$(PRIVATE_INCLUDES)
#line 98 "Class.C.tplt"

#ifndef SIGBREAKF_CTRL_C
#define SIGBREAKF_CTRL_C   (1<<12)
#endif


/* LIBRARY BASE DECLARATIONS */
extern struct IntuitionBase *IntuitionBase;
extern struct SysBase	    *SysBase;
$(LIB_EXTERNS)
#line 109 "Class.C.tplt"

/* LIBRARY PRAGMAS */
#ifdef PRAGMAS
#include <pragmas/exec_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/alib_pragmas.h>
$(LIB_PRAGMAS)
#line 117 "Class.C.tplt"
#endif


#ifdef	_DCC
#define  PRE_A4 __geta4
#define POST_A4
#define __A0(x) __A0 x
#define __A1(x) __A1 x
#define __A2(x) __A2 x
#endif
#ifdef __SASC
#define  PRE_A4 __saveds __asm
#define POST_A4
#define __A0(x) register __a0 x
#define __A1(x) register __a1 x
#define __A2(x) register __a2 x
#endif
#ifdef __GNUC__
#error "Dieses Modul ist im Augenblick nicht mit GCC kompilierbar"
#define  PRE_A4
#define POST_A4
#define __A0 register x asm("a0")
#define __A1 register x asm("a1")
#define __A2 register x asm("a2")
#endif
#ifndef PRE_A4
#error "Unknown Compiler!"
#endif


#define SUPER  DoSuperMethodA(cl, o, (Msg)msg)
#define GADOB  ((struct Gadget *)o)
#define OB     o
#define INST   inst
#define _CLASS $(CLASS)

// Es waere wuenschenswert, diese Dummies
// veraendern zu koennen ... nur wie ????
#define DUMMY_A ($(FIRST_ATTR_NUM))
#define DUMMY_M ($(FIRST_METH_NUM))

////////////////////////////////////////////////////
//
//  Defines, Attributes, Methods and Messages;
//  these Information should be put into an extern
//  Heraderfile for bigger projects
//
////////////////////////////////////////////////////

/* DEFINES */
$(DEFINES)
#line 169 "Class.C.tplt"

/* ATTRIBUTES */
$(ATTRIBUTES)
#line 173 "Class.C.tplt"

/* METHODS */
$(METHODS)
#line 177 "Class.C.tplt"

/* MESSAGES */
$(MESSAGES)
#line 181 "Class.C.tplt"

/* STRUCTURES */
$(STRUCTURES)
#line 185 "Class.C.tplt"

////////////////////////////////////////////////////
//
//  Following Struct defines the internal Data
//  of each instance
//
//  Anm. these Information is normally privat and
//	 thus should not be put into a headerfile
//
////////////////////////////////////////////////////

/* PRIVATE DEFINES */
$(PRIVATE_DEFINES)
#line 199 "Class.C.tplt"

#ifdef MYDEBUG
#include <debug.h>
#else
#define DQ(x)
#define D(x)
#define DD(x)
#endif


/* CONTENTS */
struct $(CLASS) {
$(CONTENTS)
#line 213 "Class.C.tplt"
#if $(HAS_TRACKING)
    struct Object *__Self;
#endif
}; /* $(CLASS) */

/* SUPPORT */
$(SUPPORT)
#line 221 "Class.C.tplt"

////////////////////////////////////////////////////
//
//  Following is the Class-dispatcher
//  and its sub functions
//
////////////////////////////////////////////////////
//
//  RootClass-Support:
//
//  Es sind bereits Gerueste definiert fuer die
//  Methoden OM_DISPOSE, OM_NEW, OM_SET, OM_GET
//  OM_NOTIFY, OM_UPDATE, und OM_*MEBER die verwendet
//  werden, sobald ein Attribut mit dem Vermerk
//  I,S,G,N,U verwendet wird, oder den Schluesselworten
//  OM_NEW/OM_DISPOSE C-source folgt, oder das
//  Schluesselwort LIST auftaucht.
//
//  Anm.: Von der Verwendung der U/N-Attribute
//	  sollten abgesehen werden, es handelt sich
//	  zur Zeit bei ihren Implementationen um
//	  blosse Kopien der OM_SET-Implementation
//
//  Jede Methode kann jedoch redefiniert werden;
//  dabei ist dann aber zu beachten, dass die
//  Automatische Einfuegung von OM_NEW/EXIT
//  und ISGNU-Attributen verloren geht.
//  Um sicherzugehen, dass kein vordefiniertes
//  Geruest verwendet wird empfiehlt es sich
//  #define NO_PREDEFINED_OM_*
//  in die SUPPORT-sektion aufzunehmen.
//
////////////////////////////////////////////////////



#if ($(HAS_OM_DISPOSE) || $(HAS_TRACKING) || ($(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER))) && !defined(NO_PREDEFINED_OM_DISPOSE)
static ULONG method_OM_DISPOSE (Class *cl, Object *o, Msg *msg, struct $(CLASS) *inst) {

$(OM_DISPOSE)
#line 262 "Class.C.tplt"

#if $(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER)
    {
	Object *member;
	APTR	state;

	state = (struct MinList *)(&inst->$(LIST))->mlh_Head;
	while (NULL != (member = NextObject(&state))) {
	    DoMethod   (member, OM_REMOVE);
	    DoMethodA  (member, msg);
	} /* while */
    }
#endif

#if $(HAS_TRACKING)
	Remove (&INST->$(TRACKING));
#endif

    return (ULONG)SUPER;
} /* method_OM_DISPOSE */
#endif

#if ($(HAS_OM_NEW) || $(HAS_ATTRIBUTES_I) || $(HAS_TRACKING) || ($(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER))) && !defined(NO_PREDEFINED_OM_NEW)
#define BEGIN_ATTRIBUTE(id) case id: {
#define END_ATTRIBUTE	    } break;

static ULONG method_OM_NEW (Class *cl, Object *o, struct opSet *msg, struct $(CLASS) *inst) {
    // APTR trueclass = o;
    struct TagItem *tstate, *ti;

    if (o = (Object *)SUPER) {
	inst = INST_DATA(cl, o);
	// setmem (inst, sizeof (struct $(CLASS)), 0);

$(OM_NEW)
#line 298 "Class.C.tplt"

#if $(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER)
	NewList ((struct List *)inst->$(LIST));
#endif
#if $(HAS_TRACKING)
	AddHead (&__ObjectsList, &INST->$(TRACKING));
	INST->__Self = o;
#endif

#if $(HAS_ATTRIBUTES_I)
	ti     = msg->ops_AttrList;
	tstate = ti;
	while (ti = NextTagItem(&tstate)) {
	    ULONG tg  = ti->ti_Tag;
	    ULONG val = ti->ti_Data;
	    switch (tg) {
$(ATTRIBUTES_I)
#line 316 "Class.C.tplt"
	    } /* switch */
	} /* while */
#endif
    } /* if */
    return (ULONG)o;
} /* method_OM_NEW */

#undef	BEGIN_ATTRIBUTE
#undef	END_ATTRIBUTE
#endif

#if ($(HAS_OM_SET) || $(HAS_ATTRIBUTES_S)) && !defined(NO_PREDEFINED_OM_SET)
#define BEGIN_ATTRIBUTE(id) case id: {
#define END_ATTRIBUTE	    } break;

static ULONG method_OM_SET (Class *cl, Object *o, struct opSet *msg, struct $(CLASS) *inst) {
    struct TagItem *tstate, *ti;
    ULONG retval;

$(OM_SET)
#line 337 "Class.C.tplt"

    retval = SUPER;
#if $(HAS_ATTRIBUTES_S)
    ti	   = msg->ops_AttrList;
    tstate = ti;
    while (ti = NextTagItem(&tstate)) {
	ULONG tg  = ti->ti_Tag;
	ULONG val = ti->ti_Data;
	switch (tg) {
$(ATTRIBUTES_S)
#line 348 "Class.C.tplt"
	} /* switch */
    } /* while */
#endif
    return retval;
} /* method_OM_SET */

#undef	BEGIN_ATTRIBUTE
#undef	END_ATTRIBUTE
#endif

#if $(HAS_ATTRIBUTES_G) && !defined(NO_PREDEFINED_OM_GET)
#define BEGIN_ATTRIBUTE(id) case id: {
#define END_ATTRIBUTE	    } return TRUE;
#define val *(msg->opg_Storage)

static ULONG method_OM_GET (Class *cl, Object *o, struct opGet *msg, struct $(CLASS) *inst) {
    int tg;

$(OM_GET)
#line 368 "Class.C.tplt"

#if $(HAS_ATTRIBUTES_G)
    switch (tg = msg->opg_AttrID) {
$(ATTRIBUTES_G)
#line 373 "Class.C.tplt"
    default: return SUPER;
    } /* switch */
#endif
    return TRUE;
} /* method_OM_GET */

#undef	val
#undef	BEGIN_ATTRIBUTE
#undef	END_ATTRIBUTE
#endif

#if $(HAS_ATTRIBUTES_N) && !defined(NO_PREDEFINED_OM_NOTIFY)
#define BEGIN_ATTRIBUTE(id) case id: {
#define END_ATTRIBUTE	    } break;

static ULONG method_OM_NOTIFY (Class *cl, Object *o, struct opSet *msg, struct $(CLASS) *inst) {
    struct TagItem *tstate, *ti;

$(OM_NOTIFY)
#line 393 "Class.C.tplt"

    SUPER;

#if $(HAS_ATTRIBUTES_N)
    ti	   = msg->ops_AttrList;
    tstate = ti;
    while (ti = NextTagItem(&tstate)) {
	ULONG tg  = ti->ti_Tag;
	ULONG val = ti->ti_Data;
	switch (tg) {
$(ATTRIBUTES_N)
#line 405 "Class.C.tplt"
	} /* switch */
    } /* while */
#endif
    return TRUE;
} /* method_OM_NOTIFY */

#undef	BEGIN_ATTRIBUTE
#undef	END_ATTRIBUTE
#endif

#if $(HAS_ATTRIBUTES_U) && !defined(NO_PREDEFINED_OM_UPDATE)
#define BEGIN_ATTRIBUTE(id) case id: {
#define END_ATTRIBUTE	    } break;

static ULONG method_OM_UPDATE (Class *cl, Object *o, struct opSet *msg, struct $(CLASS) *inst) {
    struct TagItem *tstate, *ti;

$(OM_UPDATE)
#line 424 "Class.C.tplt"

    SUPER;
#if $(HAS_ATTRIBUTES_U)
    ti	   = msg->ops_AttrList;
    tstate = ti;
    while (ti = NextTagItem(&tstate)) {
	ULONG tg  = ti->ti_Tag;
	ULONG val = ti->ti_Data;
	switch (tg) {
$(ATTRIBUTES_U)
#line 435 "Class.C.tplt"
	} /* switch */
    } /* while */
#endif
    return TRUE;
} /* method_OM_UPDATE */

#undef	BEGIN_ATTRIBUTE
#undef	END_ATTRIBUTE
#endif


#if $(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER)
static ULONG method_OM_ADDMEMBER (Class *cl, Object *o, struct opMember *msg, struct $(CLASS) *inst) {

$(OM_ADDMEMBER)
#line 451 "Class.C.tplt"

    DoMethod (o, OM_ADDTAIL, &inst->$(LIST));
    // ---- Was but must not be:
    // AddTail ((struct List *)&inst->$(LIST), (struct Node *)(o-1));
    return TRUE;
} /* method_OM_ADDMEMBER */

static ULONG method_OM_REMMEMBER (Class *cl, Object *o, struct opMember *msg, struct $(CLASS) *inst) {

$(OM_REMMEMBER)
#line 462 "Class.C.tplt"

    DoMethod (o, OM_REMOVE);
    // ---- Was but must not be:
    // Remove ((struct Node *)(o-1));
    return TRUE;
} /* method_OM_REMMEMBER */
#endif



////////////////////////////////////////////////////
//
//  Following are newly defined Methods
//
////////////////////////////////////////////////////

/* METHOD IMPLEMENTATIONS */
$(IMP_METHODS)
#line 481 "Class.C.tplt"


////////////////////////////////////////////////////
//
//  the dispatcher itself ...
//  again we have RootClass-Support
//
////////////////////////////////////////////////////


PRE_A4 ULONG $(CLASS)_dispatch( __A0( Class *cl ), __A2( Object *o ), __A1( Msg msg )) {
    ULONG	   retval = 0;
    struct $(CLASS) *inst   = NULL;

    POST_A4

    if (msg->MethodID != OM_NEW)
	inst = INST_DATA(cl, o);


    switch (msg->MethodID) {
#if ($(HAS_OM_DISPOSE) || $(HAS_TRACKING) || ($(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER))) && !defined(NO_PREDEFINED_OM_DISPOSE)
    case OM_DISPOSE:
		    DQ(bug("$(CLASS):OM_DISPOSE\n"));
		    retval = method_OM_DISPOSE(cl, o, (Msg)msg, inst);
		    break;
#endif
#if ($(HAS_ATTRIBUTES_I) || $(HAS_OM_NEW) || $(HAS_TRACKING) || ($(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER))) && !defined(NO_PREDEFINED_OM_NEW)
    case OM_NEW:
		    DQ(bug("$(CLASS):OM_NEW\n"));
		    retval = method_OM_NEW    (cl, o, (struct opSet*)msg, inst);
		    break;
#endif
#if $(HAS_ATTRIBUTES_S) && !defined(NO_PREDEFINED_OM_SET)
    case OM_SET:
		    DQ(bug("$(CLASS):OM_SET\n"));
		    retval = method_OM_SET    (cl, o, (struct opSet*)msg, inst);
		    break;
#endif
#if $(HAS_ATTRIBUTES_G) && !defined(NO_PREDEFINED_OM_GET)
    case OM_GET:
		    DQ(bug("$(CLASS):OM_GET\n"));
		    retval = method_OM_GET    (cl, o, (struct opGet*)msg, inst);
		    break;
#endif
#if $(HAS_ATTRIBUTES_N) && !defined(NO_PREDEFINED_OM_NOTIFY)
    case OM_NOTIFY:
		    DQ(bug("$(CLASS):OM_NOTIFY\n"));
		    retval = method_OM_NOTIFY (cl, o, (struct opSet*)msg, inst);
		    break;
#endif
#if $(HAS_ATTRIBUTES_U) && !defined(NO_PREDEFINED_OM_UPDATE)
    case OM_UPDATE:
		    DQ(bug("$(CLASS):OM_UPDATE\n"));
		    retval = method_OM_UPDATE (cl, o, (struct opSet*)msg, inst);
		    break;
#endif
#if $(HAS_LIST) && !defined(NO_PREDEFINED_OM_MEMBER)
    case OM_ADDMEMBER:
		    DQ(bug("$(CLASS):OM_ADDMEMBER\n"));
		    retval = method_OM_ADDMEMBER (cl, o, (struct opMember*)msg, inst);
		    break;
    case OM_REMMEMBER:
		    DQ(bug("$(CLASS):OM_REMMEMBER\n"));
		    retval = method_OM_REMMEMBER (cl, o, (struct opMember*)msg, inst);
		    break;
#endif
//  case M_: return method_ (cl, o, ( ... )msg, inst);
/* METHOD CALLS */
$(CALL_METHODS)
#line 552 "Class.C.tplt"

    default:
DQ(bug("$(CLASS):SUPERMETHOD\n"));
	retval = DoSuperMethodA(cl, o, msg);
    } /* switch */
DQ(bug("-> $%08lx\n", retval));
    return retval;
} /* $(CLASS)_dispatch */




////////////////////////////////////////////////////
//
//  Following are functions for creation and
//  deletion of the class itself
//
////////////////////////////////////////////////////


#if $(HAS_TRACKING)
    static struct List __ObjectsList;
    static Class      *__Class = NULL;
#endif

BOOL $(CLASS)_exit(Class *cl) {
    APTR USERDATA;
    if (!cl)
	return FALSE;
    USERDATA = (APTR)cl->cl_UserData;
    if (FreeClass(cl)) {
$(CLASS_EXIT)
#line 585 "Class.C.tplt"
#if $(HAS_TRACKING)
    __Class = NULL;
    NewList(&__ObjectsList);
#endif
	return TRUE;
    } /* if */
    return FALSE;
} /* $(CLASS)_exit */


Class *$(CLASS)_init(void) {
    Class *cl	    = NULL;
    APTR   USERDATA = NULL;

    if (cl = MakeClass(NULL, $(SUPERCLASS), sizeof (struct $(CLASS)), 0)) {
	cl->cl_Dispatcher.h_Entry    = $(CLASS)_dispatch;
	cl->cl_Dispatcher.h_SubEntry = NULL;
$(CLASS_INIT)
#line 604 "Class.C.tplt"
	if (USERDATA) cl->cl_UserData = (ULONG)USERDATA;
    } /* if */
#if $(HAS_TRACKING)
    __Class = cl;
#endif
    return cl;
} /* $(CLASS)_init */



////////////////////////////////////////////////////
//
//  For developement purposes it might be necessary
//  to make sure all members of a class are really
//  freed
//
////////////////////////////////////////////////////

#if $(HAS_TRACKING)
MK_AUTOINIT(__$(CLASS)_Exit) {
    if (__Class) {
	long  counter = 0;
	ULONG offset  = offsetof(struct $(CLASS), __Self) - offsetof(struct $(CLASS), $(TRACKING));
	struct Node *ptr;
	while ((ptr = __ObjectsList.lh_Head) && (ptr->ln_Succ)) {
	    Object *o;
	    o = *(APTR*)((ULONG)ptr + offset);
	    DisposeObject(o);
	    ++ i;
	} /* while */
	DQ(bug("%ld Elements freed after end of Program!\n", counter));
    } /* if */
} /* __$(CLASS)_Exit */
#endif



////////////////////////////////////////////////////
//
//  The rest of the file contains functions for
//  testing the above defined BOOPSI class
//  the needed libraries (as long as they are noted
//  in the class file) are opened, the class is
//  initialized, and a Window is opened;
//  after thst we call a simple IDCMP-handler
//
////////////////////////////////////////////////////

#ifdef TEST


/* LIBRARY BASES */
// struct SysBase    *SysBase	    = NULL;
struct Library	     *UtilityBase   = NULL;
struct IntuitionBase *IntuitionBase = NULL;
$(LIB_BASES)
#line 661 "Class.C.tplt"

       BOOL	      done	    = FALSE;
struct IntuiMessage  *im	    = NULL;
       Class	     *$(CLASS)_class= NULL;
struct Window	     *my_win	    = NULL;
       Object	     *my_gad	    = NULL;

/* TEST OBJECTS */
$(TEST_OBJECTS)
#line 671 "Class.C.tplt"

/* TEST SUPPORT */
$(TEST_SUPPORT)
#line 675 "Class.C.tplt"

//******************************
//
//  Main-loop
//
//	simple IDCMP handler
//
//	shold be the last call
//	in main() since it can
//	left only w/ "exit"
//	(X11-like)
//
//*****************************/

void main_loop (void) {

    while (done == FALSE) {
	if (Wait((1 << my_win->UserPort->mp_SigBit) | SIGBREAKF_CTRL_C) & SIGBREAKF_CTRL_C)
	    exit(1);

	while (im = (struct IntuiMessage *)GetMsg((struct MsgPort *)my_win->UserPort)) {
	    switch (im->Class) {
	    case IDCMP_CLOSEWINDOW:
		done = TRUE;
		break;
$(TEST_HANDLER)
#line 702 "Class.C.tplt"
	    } /* switch */
	    ReplyMsg((struct Message *)im);
	} /* while */
    } /* while */

    exit (0);
} /* main_loop */


//******************************
//
//  GUI_init/exit
//
//	to be called at pgmstart
//	open window and create
//	instance
//
//*****************************/

void gui_exits (void) {
    struct Message *msg;

DQ(bug("$(CLASS):gui_exits\n"));
    while (msg = GetMsg(my_win->UserPort))
	ReplyMsg(msg);

    if (my_win)
	CloseWindow(my_win);
    my_win = NULL;

$(TEST_EXITS)
#line 734 "Class.C.tplt"

} /* gui_exits */

int gui_inits (void) {
    atexit (gui_exits);

DQ(bug("$(CLASS):gui_inits\n"));
    if (NULL == (my_win = OpenWindowTags( NULL, WA_CloseGadget, TRUE,
						WA_DragBar,	TRUE,
						WA_DepthGadget, TRUE,
						WA_Activate,	TRUE,
						WA_IDCMP,	IDCMP_CLOSEWINDOW,
//						WA_Top, 	100,
//						WA_Left,	100,
//						WA_Width,	400,
//						WA_Height,	200,
$(TEST_WINDOW)
#line 752 "Class.C.tplt"
    TAG_DONE))) {
	printf ("WINDOW_init failure\n");
	return 21;
    } /* if */

    if (NULL == (APTR)((
$(TEST_INITS)
#line 760 "Class.C.tplt"
	TAG_DONE))) {
	printf ("OBJECT_init failure\n");
	return 22;
    } /* if */

    AddGList (my_win, (struct Gadget *)my_gad, ~0, -1, NULL);
    RefreshGadgets((struct Gadget *)my_gad, my_win, NULL);
    return 0;
} /* gui_inits */


//******************************
//
//  CLASS_init/exit
//
//	to be called at pgmstart
//	initializes CLASS
//
//******************************

void class_exits (void) {
DQ(bug("$(CLASS):class_exits\n"));
    if ($(CLASS)_class)
	$(CLASS)_exit($(CLASS)_class);
	$(CLASS)_class = NULL;
} /* class_exits */

int class_inits (void) {
    atexit(class_exits);

DQ(bug("$(CLASS):class_init\n"));
    if (NULL == ($(CLASS)_class = $(CLASS)_init())) {
	printf ("CLASS_init failure\n");
	return 11;
    } /* if */

    return 0;
} /* class_inits */


//******************************
//
//  SYS_init/exit
//
//	init the needed
//	runtime libraries
//
//******************************

void sys_exits (void) {

DQ(bug("$(CLASS):sys_exits\n"));
    if (IntuitionBase) {
	CloseLibrary((struct Library *)IntuitionBase);
	IntuitionBase = NULL;
    } /* if */

    if (UtilityBase) {
	CloseLibrary(UtilityBase);
	UtilityBase = NULL;
    } /* if */

$(LIB_EXITS)
#line 824 "Class.C.tplt"

} /* sys_exits */

int sys_inits (void) {
    atexit(sys_exits);

DQ(bug("$(CLASS):sys_inits\n"));
    SysBase = *((struct SysBase **)4l);

    if (NULL == (IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library",37L))) {
	return 2;
    } /* if */

    if (NULL == (UtilityBase = OpenLibrary("utility.library",37L))) {
	return 1;
    } /* if */

$(LIB_INITS)
#line 843 "Class.C.tplt"

    return 0;
} /* sys_inits */


//******************************
//
//  MAIN
//	simple classtester
//
//******************************

int main (int ac, char ** av) {
    if (sys_inits() != 0) {
	return 20;
    } /* if */

    if (class_inits() != 0) {
	return 10;
    } /* if */

    if (gui_inits() != 0) {
	return 10;
    } /* if */
    main_loop();
    return 0;
} /* main */

#endif /* TEST */

////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////

