//////////////////////////////////////////////////
//
//  DEMO for the ClassParser
//
//  This is a modified copy of
//  RKMLibs/intuition/Boopsi/RKMButton.c
//  while that file was about 16k
//  this one is only about 9k and it still
//  has almost full functionality;
//
//  that way the programmer can give away
//  some automatics to the parser and
//  concentrate to the problem
//
//  I must admit that there are still
//  many problems...
//  the worst thing is, You must know
//  what is defined in Ya "class.tplt"
//
//////////////////////////////////////////////////


CLASS	    rkmbutton
SUPERCLASS  "gadgetclass",NULL
VERSION     TestBut 37.1
CLASS_INIT
CLASS_EXIT

INCLUDES
    <intuition/gadgetclass.h>
    <intuition/icclass.h>

LIBRARIES
    graphics

PRIVATE_INCLUDES
    <graphics/gfxmacros.h>


DEFINES
    RKMBUT_Pulse (TAG_USER + 1)
    ERASE_ONLY	 0x00000001	// Tells rendering routine to
				// only erase the gadget, not
				// rerender a new one.	This
				// lets the gadget erase it-
				// self before it rescales.

PRIVATE_DEFINES
    TEST 1

CONTENTS
    LONG midX, midY;		// Coordinates of middle of gadget

OBJ_INIT
    inst->midX	 = ((struct Gadget *)o)->LeftEdge + ( (((struct Gadget *)o)->Width)  / 2);
    inst->midY	 = ((struct Gadget *)o)->TopEdge  + ( (((struct Gadget *)o)->Height) / 2);



METHOD GM_HITTEST struct gpHitTest*
	   // Since this is a rectangular gadget this
	   // method always returns GMR_GADGETHIT.
    return GMR_GADGETHIT;


METHOD GM_GOACTIVE struct gpInput*
	       // Only become active if the GM_GOACTIVE
	       // was triggered by direct user input.
    if (msg->gpi_IEvent)
    {
	       // This gadget is now active, change
	       // visual state to selected and render.
	((struct Gadget *)o)->Flags |= GFLG_SELECTED;
			RenderRKMBut(cl, (struct Gadget *)o, (struct gpRender *)msg);
	return GMR_MEACTIVE;
    }
    else	    // The GM_GOACTIVE was not
		    // triggered by direct user input.
	return GMR_NOREUSE;

METHOD GM_RENDER struct gpRender*
    return RenderRKMBut(cl, (struct Gadget *)o, msg);


METHOD GM_HANDLEINPUT struct gpInput*
		   // While it is active, this gadget sends its superclass an
		   // OM_NOTIFY pulse for every IECLASS_TIMER event that goes by
		   // (about one every 10th of a second).  Any object that is
		   // connected to this gadget will get A LOT of OM_UPDATE messages.

    struct Gadget *g = (struct Gadget *)o;
    struct InputEvent *ie = msg->gpi_IEvent;

    if (ie->ie_Class == IECLASS_RAWMOUSE)
    {
	switch (ie->ie_Code)
	{
	    case SELECTUP: // The user let go of the gadget so return GMR_NOREUSE
			   // to deactivate and to tell Intuition not to reuse
			   // this Input Event as we have already processed it.
			   // If the user let go of the gadget while the mouse was
			   // over it, mask GMR_VERIFY into the return value so
			   // Intuition will send a Release Verify (GADGETUP).
			   // Since the gadget is going inactive, send a final
			   // notification to the ICA_TARGET.
		NotifyPulse(cl , o, 0L, inst->midX, msg);
		if ( (msg->gpi_Mouse.X < g->LeftEdge) ||
		     (msg->gpi_Mouse.X > g->LeftEdge + g->Width) ||
		     (msg->gpi_Mouse.Y < g->TopEdge) ||
		     (msg->gpi_Mouse.Y > g->TopEdge + g->Height) )
		    return GMR_NOREUSE | GMR_VERIFY;
		else
		    return GMR_NOREUSE;

	    case MENUDOWN: // The user hit the menu button. Go inactive and let
			   // Intuition reuse the menu button event so Intuition can
			   // pop up the menu bar.
			   // Since the gadget is going inactive, send a final
			   // notification to the ICA_TARGET.
		NotifyPulse(cl , o, 0L, inst->midX, msg);
		return GMR_REUSE;

	    default:
		return GMR_MEACTIVE;
	}

    }
    else if (ie->ie_Class == IECLASS_TIMER)
		// If the gadget gets a timer event, it sends an
		// interim OM_NOTIFY to its superclass.
	NotifyPulse(cl, o, OPUF_INTERIM, inst->midX, msg);

    return GMR_MEACTIVE;

METHOD GM_GOINACTIVE struct gpGoInactive*
			      // Intuition said to go inactive.  Clear the GFLG_SELECTED
			      // bit and render using unselected imagery.
    ((struct Gadget *)o)->Flags &= ~GFLG_SELECTED;
    RenderRKMBut(cl, (struct Gadget *)o, (struct gpRender *)msg);
    return FALSE;


METHOD OM_SET struct opSet*
	    // Although this class doesn't have settable attributes, this gadget class   */
	    // does have scaleable imagery, so it needs to find out when its size and/or */
	    // position has changed so it can erase itself, THEN scale, and rerender.	 */
    if ( FindTagItem(GA_Width,  msg->ops_AttrList) ||
	 FindTagItem(GA_Height, msg->ops_AttrList) ||
	 FindTagItem(GA_Top,    msg->ops_AttrList) ||
	 FindTagItem(GA_Left,   msg->ops_AttrList) )
    {
	struct RastPort *rp;
	struct Gadget *g = (struct Gadget *)o;
	ULONG retval;

	WORD x,y,w,h;

	x = g->LeftEdge;
	y = g->TopEdge;
	w = g->Width;
	h = g->Height;

	retval = SUPER;
						  // Get pointer to RastPort for gadget.
	if (rp = ObtainGIRPort( msg->ops_GInfo) )
	{
	    UWORD *pens = msg->ops_GInfo->gi_DrInfo->dri_Pens;

	    SetAPen(rp, pens[BACKGROUNDPEN]);
	    SetDrMd(rp, JAM1);                            // Erase the old gadget.
	    RectFill(rp, x, y, x+w, y+h);

	    inst->midX = g->LeftEdge + ( (g->Width) / 2); // Recalculate where the
	    inst->midY = g->TopEdge + ( (g->Height) / 2); // center of the gadget is.

							  // Rerender the gadget.
	    DoMethod(o, GM_RENDER, msg->ops_GInfo, rp, GREDRAW_REDRAW);
	    ReleaseGIRPort(rp);
	}
	return retval;
    }
    else
	return SUPER;


SUPPORT
//*************************************************************************************************
//************** Build an OM_NOTIFY message for RKMBUT_Pulse and send it to the superclass. *******
//*************************************************************************************************
void NotifyPulse(Class *cl, Object *o, ULONG flags, LONG mid, struct gpInput *gpi)
{
    struct TagItem tt[3];

    tt[0].ti_Tag = RKMBUT_Pulse;
    tt[0].ti_Data = mid - ((gpi->gpi_Mouse).X + ((struct Gadget *)o)->LeftEdge);

    tt[1].ti_Tag = GA_ID;
    tt[1].ti_Data = ((struct Gadget *)o)->GadgetID;

    tt[2].ti_Tag = TAG_DONE;

    DoSuperMethod(cl, o, OM_NOTIFY, tt, gpi->gpi_GInfo, flags);
}

//*************************************************************************************************
//*******************************   Erase and rerender the gadget.   ******************************
//*************************************************************************************************
 ULONG RenderRKMBut(Class *cl, struct Gadget *g, struct gpRender *msg)
{
    struct _CLASS *inst = INST_DATA(cl, (Object *)g);
    struct RastPort *rp;
    ULONG retval = TRUE;
    UWORD *pens = msg->gpr_GInfo->gi_DrInfo->dri_Pens;

    if (msg->MethodID == GM_RENDER)   // If msg is truly a GM_RENDER message (not a gpInput that
				      // looks like a gpRender), use the rastport within it...
	rp = msg->gpr_RPort;
    else			      // ...Otherwise, get a rastport using ObtainGIRPort().
	rp = ObtainGIRPort(msg->gpr_GInfo);

    if (rp)
    {
	UWORD back, shine, shadow, w, h, x, y;

	if (g->Flags & GFLG_SELECTED) // If the gadget is selected, reverse the meanings of the
	{			      // pens.
	    back   = pens[FILLPEN];
	    shine  = pens[SHADOWPEN];
	    shadow = pens[SHINEPEN];
	}
	else
	{
	    back   = pens[BACKGROUNDPEN];
	    shine  = pens[SHINEPEN];
	    shadow = pens[SHADOWPEN];
	}
	SetDrMd(rp, JAM1);

	SetAPen(rp, back);                      // Erase the old gadget.
	RectFill(rp, g->LeftEdge,
		     g->TopEdge,
		     g->LeftEdge + g->Width,
		     g->TopEdge + g->Height);

	SetAPen(rp, shadow);                    // Draw shadow edge.
	Move(rp, g->LeftEdge + 1, g->TopEdge + g->Height);
	Draw(rp, g->LeftEdge + g->Width, g->TopEdge + g->Height);
	Draw(rp, g->LeftEdge + g->Width, g->TopEdge + 1);

	w = g->Width / 4;			// Draw Arrows - Sorry, no frills imagery
	h = g->Height / 2;
	x = g->LeftEdge + (w/2);
	y = g->TopEdge + (h/2);

	Move(rp, x, inst->midY);
	Draw(rp, x + w, y);
	Draw(rp, x + w, y + (g->Height) - h);
	Draw(rp, x, inst->midY);

	x = g->LeftEdge + (w/2) + g->Width / 2;

	Move(rp, x + w, inst->midY);
	Draw(rp, x, y);
	Draw(rp, x, y  + (g->Height) - h);
	Draw(rp, x + w, inst->midY);

	SetAPen(rp, shine);                     // Draw shine edge.
	Move(rp, g->LeftEdge, g->TopEdge + g->Height - 1);
	Draw(rp, g->LeftEdge, g->TopEdge);
	Draw(rp, g->LeftEdge + g->Width - 1, g->TopEdge);

	if (msg->MethodID != GM_RENDER)         // If we allocated a rastport, give it back.
	    ReleaseGIRPort(rp);
    }
    else retval = FALSE;
    return(retval);
}



TEST_SUPPORT
struct TagItem pulse2int[] = {
    {RKMBUT_Pulse, STRINGA_LongVal},
    {TAG_END,}
};

#   define INTWIDTH  40
#   define INTHEIGHT 20

TEST_WINDOW
	WA_Flags,	WFLG_DEPTHGADGET | WFLG_DRAGBAR | WFLG_CLOSEGADGET | WFLG_SIZEGADGET,
	WA_IDCMP,	IDCMP_CLOSEWINDOW,
	WA_Width,	    640,
	WA_Height,	    200,


TEST_OBJECT integer NULL,"strgclass",
       GA_ID,		 1L,
       GA_Top,		 (my_win->BorderTop) + 5L,
       GA_Left, 	 (my_win->BorderLeft) + 5L,
       GA_Width,	 INTWIDTH,
       GA_Height,	 INTHEIGHT,
       STRINGA_LongVal,  0L,
       STRINGA_MaxChars, 5L,


TEST_OBJECT but // myclass,NULL,
       GA_ID,	    2L,
       GA_Top,	    (my_win->BorderTop) + 5L,
       GA_Left,     ((struct Gadget*)integer)->LeftEdge + ((struct Gadget*)integer)->Width + 5L,
       GA_Width,    40L,
       GA_Height,   INTHEIGHT,
       GA_Previous, integer,
       ICA_MAP,     pulse2int,
       ICA_TARGET,  integer,




