@DATABASE CommonFuncs.guide
@REM Source: CommonFuncs.c
@REM Generated with RoboDoc v3.0j (May 24 1999)
@REM RoboDoc is copyright 1994-1997 by Maverick Software Development

@INDEX "PgmIndex"

@NODE PgmIndex "CommonFuncs.o Table of Contents:"
@{jcenter}
@{fg highlight}@{b}TABLE OF CONTENTS@{ub}@{fg text}
@{JLEFT}

   @{"Byt2Str()           " LINK "Byt2Str()"}   @{"CFFindMenuPtr()     " LINK "CFFindMenuPtr()"}
   @{"CloseLibs()         " LINK "CloseLibs()"}   @{"CommonFuncs.c       " LINK "Main"}
   @{"ComputeFont()       " LINK "ComputeFont()"}   @{"ComputeX()          " LINK "ComputeX()"}
   @{"ComputeY()          " LINK "ComputeY()"}   @{"DisplayTitle()      " LINK "DisplayTitle()"}
   @{"FGetS()             " LINK "FGetS()"}   @{"FileExists()        " LINK "FileExists()"}
   @{"FileReq()           " LINK "FileReq()"}   @{"File_DirReq()       " LINK "File_DirReq()"}
   @{"FindChar()          " LINK "FindChar()"}   @{"FindIcon()          " LINK "FindIcon()"}
   @{"FindTools()         " LINK "FindTools()"}   @{"FontXDim()          " LINK "FontXDim()"}
   @{"GetActiveScreen()   " LINK "GetActiveScreen()"}   @{"GetActiveWindow()   " LINK "GetActiveWindow()"}
   @{"GetPathName()       " LINK "GetPathName()"}   @{"GetToolBoolean()    " LINK "GetToolBoolean()"}
   @{"GetToolInt()        " LINK "GetToolInt()"}   @{"GetToolStr()        " LINK "GetToolStr()"}
   @{"GetUserResponse()   " LINK "GetUserResponse()"}   @{"GetUserString()     " LINK "GetUserString()"}
   @{"Guarded_AllocLV()   " LINK "Guarded_AllocLV()"}   @{"Guarded_FreeLV()    " LINK "Guarded_FreeLV()"}
   @{"HSV2RGB()           " LINK "HSV2RGB()"}   @{"Handle_Problem()    " LINK "Handle_Problem()"}
   @{"HideListFromView()  " LINK "HideListFromView()"}   @{"IsGadgetSelected()  " LINK "IsGadgetSelected()"}
   @{"IsMenuChecked()     " LINK "IsMenuChecked()"}   @{"LowerCase()         " LINK "LowerCase()"}
   @{"MakeHexASCIIStr()   " LINK "MakeHexASCIIStr()"}   @{"ModifyListView()    " LINK "ModifyListView()"}
   @{"OpenFile()          " LINK "OpenFile()"}   @{"OpenLibs()          " LINK "OpenLibs()"}
   @{"RGB2HSV()           " LINK "RGB2HSV()"}   @{"RemoveSubString()   " LINK "RemoveSubString()"}
   @{"ReplaceChar()       " LINK "ReplaceChar()"}   @{"ReportAllocLVError()" LINK "ReportAllocLVError()"}
   @{"ReverseString()     " LINK "ReverseString()"}   @{"SanityCheck()       " LINK "SanityCheck()"}
   @{"SetNotifyWindow()   " LINK "SetNotifyWindow()"}   @{"SetReqButtons()     " LINK "SetReqButtons()"}
   @{"SetTagItem()        " LINK "SetTagItem()"}   @{"SetTagPair()        " LINK "SetTagPair()"}
   @{"SetupList()         " LINK "SetupList()"}   @{"StringCat()         " LINK "StringCat()"}
   @{"StringComp()        " LINK "StringComp()"}   @{"StringCopy()        " LINK "StringCopy()"}
   @{"StringIComp()       " LINK "StringIComp()"}   @{"StringIndex()       " LINK "StringIndex()"}
   @{"StringLength()      " LINK "StringLength()"}   @{"StringNCat()        " LINK "StringNCat()"}
   @{"StringNComp()       " LINK "StringNComp()"}   @{"StringNCopy()       " LINK "StringNCopy()"}
   @{"StringNIComp()      " LINK "StringNIComp()"}   @{"SubString()         " LINK "SubString()"}
   @{"TrimSpaces()        " LINK "TrimSpaces()"}   @{"UpperCase()         " LINK "UpperCase()"}
   @{"UserInfo()          " LINK "UserInfo()"}   @{"drawArc()           " LINK "drawArc()"}
   @{"getScreenModeID()   " LINK "getScreenModeID()"}   @{"getUserFont()       " LINK "getUserFont()"}
   @{"itoa()              " LINK "itoa()"}   @{"stoi()              " LINK "stoi()"}
   @{"strClear()          " LINK "strClear()"}

   New functions in V3.8+
	   
	@{"CMsg()           " LINK "CMsg()"}
	@{"pathIncluded()   " LINK "pathIncluded()"}
	@{"RunMyCommand()   " LINK "RunMyCommand()"}
	@{"ClearNodeStrs()  " LINK "ClearNodeStrs()"}
	@{"removeNewLine()  " LINK "removeNewLine()"}
	@{"countFileLines() " LINK "countFileLines()"}

@ENDNODE

@NODE "Main" "CommonFuncs.o function Documentation:"
@INDEX "PgmIndex"
@{fg shine}CommonFuncs.o Function Documentation@{fg text}

@{b}NAME@{ub}
@{fg shine}    @{b}CommonFuncs.c@{ub}

@{fg text}
@{b}DESCRIPTION@{ub}
    Functions that get used a lot for GUI programming, especially for
    GadToolsBox-generated GUIs.  This file is used to generate 
    CommonFuncs.o - a Link-able Object for the SAS-C (V6.58) compiler,
    or CommonFuncsPPC.o for the gcc compiler, PowerPC & AmigaOS4.

    This a link-able object because there are far too many shared 
    libraries for the Amiga OS as it is, I couldn't see cluttering 
    someone's hard drive with another one (especially my own!).

@{b}HISTORY@{ub}
	 25-Mar-2007 - Rewritten to use Locale'ized strings found in 
	               commonfuncs.catalog (if any).  This means that
						OpenLibs() & CloseLibs() are also taking care of
						LocaleBase as well.
						
    03-Nov-2005 - Added the FileExists() function.

    25-Oct-2005 - Added stringfunctions.c functions for SAS-C code.

    31-Jan-2005 - Added GetUserString() Requester code.

    24-Jan-2005 - Replaced all string.h functions with their
                  equivalent functions in libstringfuncs.a.

    21-Jan-2005 - Added OpenFile() & TrimSpaces() functions.
    14-Jan-2005 - Added IsGadgetSelected() & IsMenuChecked() functions.
    20-Oct-2004 - All functions are now independent of the User
                  opening & closing the correct libraries for AmigaOS4.0.
    17-Oct-2004 - Added AmigaOS4.0 conditional support (via gcc)
    01-Oct-2003 - Added void strClear( char * ) function.
    24-Sep-2003 - Added GetActiveWindow() calls to all the Requesters.
    09-Sep-2003 - Added the drawArc() function.
    09-Apr-2002 - Added the getUserFont() function.

@{b}AUTHOR@{ub}
@{b}    James T. Steichen
    2217 N. Tamarack Dr.
    Slayton, Mn. 56172-1155, USA
    jimbot\@frontiernet.net

@{ub}
@{b}NOTES@{ub}
@{fg shine}    $VER: @{b}CommonFuncs.c@{ub} 4.0 (25-Mar-2007) by J.T. Steichen

@{fg text}
@{b}COPYRIGHT@{ub}
    @{b}CommonFuncs.c@{ub} & CommonFuncs.h (c) 1999-2007 by J.T. Steichen,
    All Rights Reserved.

@ENDNODE

@NODE "CMsg()" "CMsg()"
@{fg shine}CMsg()@{FG TEXT}
@{b}NAME@{ub}
@{fg shine}     CMsg()

@{fg text}
@{b}SYNOPSIS@{ub}
    STRPTR rval = CMsg( int index, char *defaultStr );

@{b}DESCRIPTION@{ub}
    Obtain a string from the locale catalog file, failing that,
    return the default string.

@{b}WARNINGS@{ub}
    The function internally uses the name @{fg shine}catalog@{fg text} for the struct
    Catalog that it will use, so make sure that your code uses
    @{fg shine}catalog@{fg text} for the name of the Catalog struct!!

@ENDNODE

@NODE "pathIncluded()" "pathIncluded()"
@{fg shine}pathIncluded()@{fg text}
@{b}NAME@{ub}
@{fg shine}     pathIncluded()

@{fg text}
@{b}SYNOPSIS@{ub}
    BOOL hasPath = pathIncluded( STRPTR file_path );
	 
@{b}DESCRIPTION@{ub}
    Check the given fileName to see if it contains path information.

@ENDNODE

@NODE "RunMyCommand()" "RunMyCommand()"
@{fg shine}RunMyCommand()@{fg text}
@{b}NAME@{ub}
@{fg shine}     RunMyCommand()

@{fg text}
@{b}SYNOPSIS@{ub}
    int success = RunMyCommand( char *CommandString );

@{b}DESCRIPTION@{ub}
    Tell the operating system to execute the given command string as if it were
    being run from a shell/Cli.

@{b}RETURNS@{ub}
    RETURN_OK if the command was successful.

@ENDNODE

@NODE "ClearNodeStrs()" "ClearNodeStrs()"
@{fg shine}ClearNodeStrs()@{fg text}
@{b}NAME@{ub}
@{fg shine}    ClearNodeStrs()

@{fg text}
@{b}SYNOPSIS@{ub}
    void ClearNodeStrs( struct ListViewMem *lvm, int numItems, int itemSize );

@{b}DESCRIPTION@{ub}
    Set the internal buffer associated with a ListView Gadget to all nils.

@ENDNODE

@NODE "removeNewLine()" "removeNewLine()"
@{fg shine}removeNewLine()@{fg text}
@{b}NAME@{ub}
@{fg shine}    removeNewLine()

@{fg text}
@{b}SYNOPSIS@{ub}
    void removeNewLine( char *inputLine );

@{b}DESCRIPTION@{ub}
    If the supplied string has a newline at the end of it, replace it with a nil.

@ENDNODE

@NODE "countFileLines()" "countFileLines()"
@{fg shine}countFileLines()@{fg text}
@{b}NAME@{ub}
@{fg shine}    countFileLines()
	
@{fg text}
@{b}SYNOPSIS@{ub}
    int numNewLines = countFileLines( FILE *inputFile );

@{b}DESCRIPTION@{ub}
    count the number of newline characters in a file, then rewind() it.

@ENDNODE

@NODE "Byt2Str()" "Byt2Str()"
@{fg shine}Byt2Str()@{fg text}

@{b}NAME@{ub}
@{fg shine}    Byt2Str()

@{fg text}
@{b}SYNOPSIS@{ub}
    char *hexstr = Byt2Str( char *output, UBYTE input_byte );

@{b}DESCRIPTION@{ub}
    Take an input binary character & generate a displayable 
    two-character ASCII 
    string that displays the HexaDecimal value of each byte.

@{b}WARNINGS@{ub}
    The output buffer has to be TWO times as long as the input
    buffer (+ 1 for nil); in other words supply a buffer that's
    three characters long!

@ENDNODE

@NODE "CFFindMenuPtr()" "CFFindMenuPtr()"
@{fg shine}CFFindMenuPtr()@{fg text}

@{b}NAME@{ub}
@{fg shine}    CFFindMenuPtr()

@{fg text}
@{b}DESCRIPTION@{ub}
    Return a pointer to a menu item that has the given title.

@{b}HISTORY@{ub}
    24-Jan-2005 - Changed the calls to strcmp() to StringComp(), 
                  which is in libstringfuncs.a

@ENDNODE

@NODE "CloseLibs()" "CloseLibs()"
@{fg shine}CloseLibs()@{fg text}

@{b}NAME@{ub}
@{fg shine}    CloseLibs()

@{fg text}
@{b}SYNOPSIS@{ub}
    void CloseLibs( void );

@{b}DESCRIPTION@{ub}
    Close the three most-commonly used libraries - 

       intuition.library, graphics.library & gadtools.library.

@ENDNODE

@NODE "ComputeFont()" "ComputeFont()"
@{fg shine}ComputeFont()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ComputeFont()

@{fg text}
@{b}SYNOPSIS@{ub}
    void ComputeFont( struct Screen   *screen,
                      struct TextAttr *font,
                      struct CompFont *cfont,
                      UWORD            width,
                      UWORD            height
                    );

@{b}DESCRIPTION@{ub}
    Initialize the CompFont structure according to the supplied
    values in the font, width & height.  If the results won't fit
    the screen dimensions, use topaz (8) in the computations
    instead.


@{b}NOTES@{ub}
@{fg shine}    GfxBase has to be open BEFORE calling this function!
@{fg text}
@ENDNODE

@NODE "ComputeX()" "ComputeX()"
@{fg shine}ComputeX()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ComputeX()

@{fg text}
@{b}SYNOPSIS@{ub}
    UWORD size = ComputeX( UWORD fontxsize, UWORD value );

@{b}DESCRIPTION@{ub}
    This function returns 
         (fontxsize * value + (fontxsize / 2)) / fontxsize

@{b}NOTES@{ub}
@{fg shine}    This function will probably be changed to private later.
@{fg text}
@ENDNODE

@NODE "ComputeY()" "ComputeY()"
@{fg shine}ComputeY()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ComputeY()

@{fg text}
@{b}SYNOPSIS@{ub}
    UWORD size = ComputeY( UWORD fontysize, UWORD value );

@{b}DESCRIPTION@{ub}
    This function returns 
         (fontysize * value + (fontysize / 2)) / fontysize

@{b}NOTES@{ub}
@{fg shine}    This function will probably be changed to private later.
@{fg text}
@ENDNODE

@NODE "DisplayTitle()" "DisplayTitle()"
@{fg shine}DisplayTitle()@{fg text}

@{b}NAME@{ub}
@{fg shine}    DisplayTitle()

@{fg text}
@{b}SYNOPSIS@{ub}
    void DisplayTitle( struct Window *wptr, char *windowTitle );

@{b}DESCRIPTION@{ub}
    Display the given text as a title for the given Window.

@{b}NOTES@{ub}
@{fg shine}    The title is silently limited to 79 characters in length.
@{fg text}
@ENDNODE

@NODE "FGetS()" "FGetS()"
@{fg shine}FGetS()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FGetS()

@{fg text}
@{b}SYNOPSIS@{ub}
    char *str = FGetS( char *buffer, int readlength, FILE *fptr );

@{b}DESCRIPTION@{ub}
    This function is identical to the C library function fgets()
    except that it changes the \\n at the end of a line to a \\0.

@ENDNODE

@NODE "FileExists()" "FileExists()"
@{fg shine}FileExists() (new for V3.6)@{fg text}

@{b}NAME@{ub}
@{fg shine}    FileExists()

@{fg text}
@{b}SYNOPSIS@{ub}
    BOOL result = FileExists( UBYTE *fileName );

@{b}DESCRIPTION@{ub}
    Check a fileName to see if it exists as a file in your Amiga PC.

@{b}INPUTS@{ub}
    fileName - contains the file name of the file you wish to
               verify.

@{b}RETURN VALUE@{ub}
    TRUE if the fileName is present as a file or directory,
    FALSE otherwise.

@{b}COPYRIGHT@{ub}
    Copyright (C) 2005 by J.T. Steichen.  All rights reserved.
    This function may be copied for personal, non-profit use only.

@ENDNODE

@NODE "FileReq()" "FileReq()"
@{fg shine}FileReq()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FileReq()

@{fg text}
@{b}SYNOPSIS@{ub}
    int len = FileReq( char *filename, struct TagItem *taglist );

@{b}DESCRIPTION@{ub}
    Display the ASL file requester with the given taglist.

@{b}NOTES@{ub}
@{fg shine}    This function is identical to File_DirReq() except that we
    don't use the Directory parameter.

    The suggested taglist items should be:

    ASLFR_Window,          (ULONG) WindowPointer // definitely needed!

    ASLFR_TitleText,       (ULONG) "Example title..." 
    ASLFR_InitialHeight,   200,
    ASLFR_InitialWidth,    400,
    ASLFR_InitialTopEdge,  16,
    ASLFR_InitialLeftEdge, 50,
    ASLFR_PositiveText,    (ULONG) "OKAY!",
    ASLFR_NegativeText,    (ULONG) "CANCEL!",
    ASLFR_InitialPattern,  (ULONG) "#?",
    ASLFR_InitialFile,     (ULONG) "",
    ASLFR_InitialDrawer,   (ULONG) "RAM:",
    ASLFR_Flags1,          FRF_DOPATTERNS,
    ASLFR_Flags2,          FRF_REJECTICONS,
    ASLFR_SleepWindow,     1,
    ASLFR_PrivateIDCMP,    1,
    TAG_END
@{fg text}
@ENDNODE

@NODE "File_DirReq()" "File_DirReq()"
@{fg shine}File_DirReq()@{fg text}

@{b}NAME@{ub}
@{fg shine}    File_DirReq()

@{fg text}
@{b}SYNOPSIS@{ub}
    int len = File_DirReq( char           *filename, 
                           char           *dirname,
                           struct TagItem *taglist
                         );

@{b}DESCRIPTION@{ub}
    Display the ASL file requester with the given taglist.  Return
    the size of the file selected as well as the filename & Directory.

    The suggested taglist items should be:

    ASLFR_Window,          (ULONG) WindowPointer // definitely needed!

    ASLFR_TitleText,       (ULONG) "Example title..." 
    ASLFR_InitialHeight,   200,
    ASLFR_InitialWidth,    400,
    ASLFR_InitialTopEdge,  16,
    ASLFR_InitialLeftEdge, 50,
    ASLFR_PositiveText,    (ULONG) "OKAY!",
    ASLFR_NegativeText,    (ULONG) "CANCEL!",
    ASLFR_InitialPattern,  (ULONG) "#?",
    ASLFR_InitialFile,     (ULONG) "",
    ASLFR_InitialDrawer,   (ULONG) "RAM:",
    ASLFR_Flags1,          FRF_DOPATTERNS,
    ASLFR_Flags2,          FRF_REJECTICONS,
    ASLFR_SleepWindow,     1,
    ASLFR_PrivateIDCMP,    1,
    TAG_END

@ENDNODE

@NODE "FindChar()" "FindChar()"
@{fg shine}FindChar()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FindChar()

@{fg text}
@{b}DESCRIPTION@{ub}
    Returns the location of the 1st occurence of the character
    contained within the string, or -1 if the letter was
    not found.

@{b}SYNOPSIS@{ub}
    int location = FindChar( string, letter );

@{b}INPUTS@{ub}
    string - pointer to the string to be examined.
    letter - contains the character we are searching for.

 RETURNS
    integer, or -1 if not found.

@ENDNODE

@NODE "FindIcon()" "FindIcon()"
@{fg shine}FindIcon()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FindIcon()

@{fg text}
@{b}DESCRIPTION@{ub}
    Find the icon associated with pgmname (if any) & process the
    ToolTypes array in the icon with ToolProc().

@{b}SYNOPSIS@{ub}
    void *rval = FindIcon( void              *(ToolProc)(char **), 
                           struct DiskObject *dobj,
                           char              *pgmname
                         );

@{b}INPUTS@{ub}
    ToolProc() - a Pointer to a function that will perform an
                 operation on the ToolTypes array from the Icon
                 if the icon was found.

    dobj       - storage (for a later call to FreeDiskObject())

    pgmname    - The name of the icon to look for (without the
                 ".info" at the end of the string). 

@{b}NOTES@{ub}
@{fg shine}    If the user starts a program from the CLI, & the icon is in
    the same directory, we will get the ToolTypes from the icon
    instead of using the built-in defaults.
@{fg text}
@ENDNODE

@NODE "FindTools()" "FindTools()"
@{fg shine}FindTools()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FindTools()
 
@{fg text}
@{b}DESCRIPTION@{ub}
    Locate a tools array for a given name.

@{b}SYNOPSIS@{ub}
    STRPTR *toolarray = FindTools( struct DiskObject *diskobj,
                                   char              *filename,
                                   BPTR               directory_lock
                                 );

@{b}INPUTS@{ub}
    filename = null-terminated name of file to look for.
    lock     = directory to look for file in.
    diskobj  = storage (for a later call to FreeDiskObject()) 

@{b}WARNINGS@{ub}
    Be sure to call FreeDiskObject() later in your program.
    FindTools() doesn't do this because it doesn't know what 
    you're going to do with the ToolTypes. 

@ENDNODE

@NODE "FontXDim()" "FontXDim()"
@{fg shine}FontXDim()@{fg text}

@{b}NAME@{ub}
@{fg shine}    FontXDim()

@{fg text}
@{b}SYNOPSIS@{ub}
    int length = FontXDim( struct TextAttr *font );

@{b}DESCRIPTION@{ub}
    Determine the horizontal distance for one character in the given
    font.

@ENDNODE

@NODE "GetActiveScreen()" "GetActiveScreen()"
@{fg shine}GetActiveScreen()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetActiveScreen()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct Screen *active = GetActiveScreen( void );

@{b}DESCRIPTION@{ub}
    Return a pointer to the Active Screen.

@ENDNODE

@NODE "GetActiveWindow()" "GetActiveWindow()"
@{fg shine}GetActiveWindow()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetActiveWindow()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct Window *active = GetActiveWindow( void );

@{b}DESCRIPTION@{ub}
    Return a pointer to the Active Window.

@ENDNODE

@NODE "GetPathName()" "GetPathName()"
@{fg shine}GetPathName()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetPathName()
  
@{fg text}
@{b}SYNOPSIS@{ub}
    char *path = GetPathName( char *pathbuf, char *filename, int size );

@{b}DESCRIPTION@{ub}
    Return with the Path portion of a filename string.

@ENDNODE

@NODE "GetToolBoolean()" "GetToolBoolean()"
@{fg shine}GetToolBoolean()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetToolBoolean()

@{fg text}
@{b}DESCRIPTION@{ub}
    Find the tooltype boolean that matches the given name.

@{b}SYNOPSIS@{ub}
    boolean ans = GetToolBoolean( STRPTR *toolptr,
                                  char   *name,
                                  int     defaultBool
                                );

@{b}INPUTS@{ub}
    toolptr     = pointer from FindTools() call.
    name        = tool we're searching the icon for.
    defaultBool = default boolean to return if the tool isn't found.

@{b}NOTES@{ub}
@{fg shine}    The following strings will return a Boolean value of TRUE:
        
        "TRUE", "YES", "1", "OK" & "OKAY"

    any other value will return FALSE.
@{fg text}
@ENDNODE

@NODE "GetToolInt()" "GetToolInt()"
@{fg shine}GetToolInt()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetToolInt() 

@{fg text}
@{b}DESCRIPTION@{ub}
    Find the tooltype integer that matches the given name.

@{b}SYNOPSIS@{ub}
    tool_int = GetToolInt( STRPTR *toolarray,
                           char   *toolname,
                           int     default_val
                         );

@{b}INPUTS@{ub}
    toolarray   = pointer from FindTools() call.
    toolname    = tool we're searching the icon for.
    default_val = default integer to return if the tool isn't found.

@ENDNODE

@NODE "GetToolStr()" "GetToolStr()"
@{fg shine}GetToolStr()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetToolStr()

@{fg text}
@{b}DESCRIPTION@{ub}
    Find the tooltype string that matches the given name.

@{b}SYNOPSIS@{ub}
    toolstring = GetToolStr( STRPTR *toolarray,
                             char   *toolname,
                             char   *default_tool
                           );

@{b}INPUTS@{ub}
    toolarray    = pointer from FindTools() call.
    toolname     = tool we're searching the icon for.
    default_tool = default string to return if the tool isn't found.

@ENDNODE

@NODE "GetUserResponse()" "GetUserResponse()"
@{fg shine}GetUserResponse()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetUserResponse - Get a button response from the user.

@{fg text}
@{b}SYNOPSIS@{ub}
    int ans = GetUserResponse( char *info, char *title, int *errnum );

@{b}FUNCTION@{ub}
    Return -1 if there's no window, otherwise return the ordinal
    of the button the user pressed.  This means that there can be
    more than two choice buttons for the User to choose from.

@{b}INPUTS@{ub}
    info   - Information string for the user to act on.
    title  - Title of the Problem Requester.
    errnum - Optional error number.

@{b}NOTES@{ub}
@{fg shine}    GetUserResponse() will return 0 for the right-most button,
    instead of n, where n is the number of buttons.  This is the
    behavior of the EasyRequest() function (so don't blame me!).

    Call SetReqButtons() before using this function &
    be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}
@ENDNODE

@NODE "GetUserString()" "GetUserString()"
@{fg shine}GetUserString()@{fg text}

@{b}NAME@{ub}
@{fg shine}    GetUserString()

@{fg text}
@{b}DESCRIPTION@{ub}
    Ask the user to supply a string to the calling program, NULL if
    the User Cancels or enters a string with zero length.

@{b}SYNOPSIS@{ub}
    UBYTE *string = GetUserString( struct Window *parentW, UBYTE *msg, UBYTE *title );

@{b}INPUTS@{ub}
    parentW - Address of the parent window from the calling program.
    msg     - Inform the User what string to enter (Keep it short!).
    title   - Requester title string (Keep it short!).

@{b}RESULT@{ub}
    This function returns the string the User entered, NULL if there's
    an ERROR or if the User did NOT enter a string.

@{b}WARNINGS@{ub}
    This function uses functions located in link object -lstringfuncs
    for gcc.
    This function does NOT adjust the requester width if you enter 
    either a long msg or title & will clip them.

@{b}COPYRIGHT@{ub}
    GetUserString() Jan-31-2005(C) by J.T. Steichen

@{b}NOTES@{ub}
@{fg shine}    Program set up to compile with gcc & AmigaOS4 also.

    $VER: GetUserString() 3.4 (Jan-31-2005) by J.T. Steichen
@{fg text}
@ENDNODE

@NODE "Guarded_AllocLV()" "Guarded_AllocLV()"
@{fg shine}Guarded_AllocLV()@{fg text}

@{b}NAME@{ub}
@{fg shine}    Guarded_AllocLV()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct ListViewMem *lvm = Guarded_AllocLV( int numitems, 
                                               int itemsize
                                             );

@{b}DESCRIPTION@{ub}
    Allocate the memory associated with a ListView Gadget.

@ENDNODE

@NODE "Guarded_FreeLV()" "Guarded_FreeLV()"
@{fg shine}Guarded_FreeLV()@{fg text}

@{b}NAME@{ub}
@{fg shine}    Guarded_FreeLV()

@{fg text}
@{b}SYNOPSIS@{ub}
    void Guarded_FreeLV( struct ListViewMem *lvm );

@{b}DESCRIPTION@{ub}
    Free the memory associated with a ListView Gadget & reset 
    the Guard. 

@ENDNODE

@NODE "HSV2RGB()" "HSV2RGB()"
@{fg shine}HSV2RGB()@{fg text}

@{b}NAME@{ub}
@{fg shine}    HSV2RGB()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct ColorCoords *ans = HSV2RGB( struct ColorCoords *input );

@{b}DESCRIPTION@{ub}
    Convert an HSV (Hue, Saturation & Luminance) coordinate into
    RGB (red, green & blue).

@{b}NOTES@{ub}
@{fg shine}    red, green & blue are values from 0 to 255 (normally).

@{fg text}
@{b}WARNINGS@{ub}
    If you want the input structure for later, save it before
    passing it to this function, since it modifies it & returns it.

@ENDNODE

@NODE "Handle_Problem()" "Handle_Problem()"
@{fg shine}Handle_Problem()@{fg text}

@{b}NAME@{ub}
@{fg shine}    Handle_Problem()

@{fg text}
@{b}SYNOPSIS@{ub}
    int ans = Handle_Problem( char *info, char *title, int *errnum );

@{b}DESCRIPTION@{ub}
    Get a Yes/No Response from the user.

@{b}FUNCTION@{ub}
    Return -1 if the user selected the ABORT (far-right) button,
    else return the errnum value (normally 0).

@{b}INPUTS@{ub}
    info   - Information string for the user to act on.
    title  - Title of the Problem Requester.
    errnum - Optional error number (normally NULL).

@{b}NOTES@{ub}
@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}
@ENDNODE

@NODE "HideListFromView()" "HideListFromView()"
@{fg shine}HideListFromView()@{fg text}

@{b}NAME@{ub}
@{fg shine}    HideListFromView()

@{fg text}
@{b}SYNOPSIS@{ub}
    void HideListFromView( struct Gadget *listview_gadget,
                           struct Window *window_pointer
                         );

@{b}DESCRIPTION@{ub}
    Turn off the Given ListView Gadget for the window, so that it
    can be modified elsewhere.

@{b}SEE ALSO@{ub}
    ModifyListView()

@ENDNODE

@NODE "IsGadgetSelected()" "IsGadgetSelected()"
@{fg shine}IsGadgetSelected()@{fg text}

@{b}NAME@{ub}
@{fg shine}    IsGadgetSelected()

@{fg text}
@{b}SYNOPSIS@{ub}
    BOOL result = IsGadgetSelected( struct Gadget *g );

@{b}DESCRIPTION@{ub}
    Returns TRUE if g is selected/checked, FALSE otherwise.

@ENDNODE

@NODE "IsMenuChecked()" "IsMenuChecked()"
@{fg shine}IsMenuChecked()@{fg text}

@{b}NAME@{ub}
@{fg shine}    IsMenuChecked()

@{fg text}
@{b}SYNOPSIS@{ub}
    BOOL result = IsMenuChecked( struct MenuItem *m );

@{b}DESCRIPTION@{ub}
    Returns TRUE if m is Checked, FALSE otherwise.

@ENDNODE

@NODE "LowerCase()" "LowerCase()"
@{fg shine}LowerCase()@{fg text}

@{b}NAME@{ub}
@{fg shine}    LowerCase()

@{fg text}
@{b}DESCRIPTION@{ub}
    Convert the input string into all LowerCase Letters.

@{b}SYNOPSIS@{ub}
    UBYTE *result = LowerCase( UBYTE *inputString );

@{b}INPUTS@{ub}
    inputString - contains the characters to convert (if any).

@ENDNODE

@NODE "MakeHexASCIIStr()" "MakeHexASCIIStr()"
@{fg shine}MakeHexASCIIStr()@{fg text}

@{b}NAME@{ub}
@{fg shine}    MakeHexASCIIStr()

@{fg text}
@{b}SYNOPSIS@{ub}
    unsigned int length = MakeHexASCIIStr( char *output, 
                                           char *input,
                                           int   inputlength
                                         );

@{b}DESCRIPTION@{ub}
    Take an input binary string & generate a displayable ASCII 
    string that displays the HexaDecimal value of each byte as
    well as the ASCII representation (for characters >= 0x20 &
    <= 0x7E).

    Output will be as follows:

    /------------ Hex Bytes ----------\\ /--- ASCII ----\\ @{FG SHINE}

    22334455 22334455 A7223344 7F223344 "3DU"3DU."3D."3D @{FG TEXT}

@{b}WARNINGS@{ub}
    The output buffer has to be FOUR times as long as the input
    buffer!  The maximum value for inlen should be 20 bytes, with
    16 being the nominal value.

@ENDNODE

@NODE "ModifyListView()" "ModifyListView()"
@{fg shine}ModifyListView()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ModifyListView()

@{fg text}
@{b}SYNOPSIS@{ub}
    void ModifyLsitView( struct Gadget *listview_gadget,
                         struct Window *window_pointer,
                         struct List   *listview_contents,
                         struct Gadget *string_gadget
                       ); 

@{b}DESCRIPTION@{ub}
    Change the Given ListView Gadget for the window to the 
    new parameters, which will re-display it.

@{b}SEE ALSO@{ub}
    HideListFromView()

@ENDNODE

@NODE "OpenFile()" "OpenFile()"
@{fg shine}OpenFile()@{fg text}

@{b}NAME@{ub}
@{fg shine}    OpenFile()

@{fg text}
@{b}SYNOPSIS@{ub}
    FILE *fPtr = OpenFile( char *fileName, char *fileMode );

@{b}DESCRIPTION@{ub}
    Improvement to the fopen() function in that OpenFile() first
    checks that the arguments are valid, then calls fopen().

@{b}WARNINGS@{ub}
    For the Amiga file system, spaces in a fileName are significant &
    any leading or trailing spaces inadvertently contained in the 
    fileName could lead to a failure of the fopen() function.
    Since leading or trailing spaces are usually of no significance,
    they are first removed BEFORE calling fopen().  If you wish to
    open a file with leading or trailing spaces in the fileName,
    DO NOT use this function.

@ENDNODE

@NODE "OpenLibs()" "OpenLibs()"
@{fg shine}OpenLibs()@{fg text}

@{b}NAME@{ub}
@{fg shine}    OpenLibs()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = OpenLibs( void );

@{b}DESCRIPTION@{ub}
    Open the three most-commonly used libraries (V39+) - 

       intuition.library, graphics.library & gadtools.library.

@{b}RETURN VALUE@{ub}
    Negative integer if a library could NOT be opened, zero if
    all was successful.

@ENDNODE

@NODE "RGB2HSV()" "RGB2HSV()"
@{fg shine}RGB2HSV()@{fg text}

@{b}NAME@{ub}
@{fg shine}    RGB2HSV()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct ColorCoords *ans = RGB2HSV( struct ColorCoords *input );

@{b}DESCRIPTION@{ub}
    Convert an RGB color coordinate set into HSV (Hue,
    Saturation & Luminance).

@{b}NOTES@{ub}
@{fg shine}    red, green & blue are values from 0 to 255 (normally).

@{fg text}
@{b}WARNINGS@{ub}
    If you want the input structure for later, save it before
    passing it to this function, since it modifies it & returns it.

@ENDNODE

@NODE "RemoveSubString()" "RemoveSubString()"
@{fg shine}RemoveSubString()@{fg text}

@{b}NAME@{ub}
@{fg shine}    RemoveSubString()

@{fg text}
@{b}DESCRIPTION@{ub}
    Removes the number of characters specified starting at the 
    character location contained in first from the contents.

@{b}SYNOPSIS@{ub}
    int chk = RemoveSubString( UBYTE *string, int first, int num_char )

@{b}INPUTS@{ub}
    string   - contains the characters to delete.
    first    - location (indexed) of 1st character to delete.
    num_char - number of characters to delete.

 RETURNS
    integer RETURN_OK or (-1) if error.

@ENDNODE

@NODE "ReplaceChar()" "ReplaceChar()"
@{fg shine}ReplaceChar()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ReplaceChar()

@{fg text}
@{b}DESCRIPTION@{ub}
    Replaces each occurence of the character contained in old_char 
    with the character contained in new_char.

@{b}SYNOPSIS@{ub}
    UBYTE *result = ReplaceChar( UBYTE *string, UBYTE old_char, UBYTE new_char );

@{b}INPUTS@{ub}
    string   - contains the string to examine
    old_char - contains the character to replace.
    new_char - contains the character to replace old_char with.

@ENDNODE

@NODE "ReportAllocLVError()" "ReportAllocLVError()"
@{fg shine}ReportAllocLVError()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ReportAllocLVError()

@{fg text}
@{b}SYNOPSIS@{ub}
    void ReportAllocLVError( void );

@{b}DESCRIPTION@{ub}
    Display a requester informing the User the error that 
    Guarded_AllocLV() found.

@{b}SEE ALSO@{ub}
    Guarded_AllocLV(), Guarded_FreeLV()

@ENDNODE

@NODE "ReverseString()" "ReverseString()"
@{fg shine}ReverseString()@{fg text}

@{b}NAME@{ub}
@{fg shine}    ReverseString()

@{fg text}
@{b}DESCRIPTION@{ub}
    Reverses a string in place.

@{b}SYNOPSIS@{ub}
    UBYTE *result = ReverseString( string );

@{b}INPUTS@{ub}
    string - contains the string to reverse

@ENDNODE

@NODE "SanityCheck()" "SanityCheck()"
@{fg shine}SanityCheck()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SanityCheck - Get a Yes/No Response from the user.

@{fg text}
@{b}SYNOPSIS@{ub}
    Boolean answer = SanityCheck( char *question );

@{b}FUNCTION@{ub}
    Return TRUE if the User pressed the 'YES' button.
    Return FALSE if the User pressed the 'NO' button.
›
@{b}INPUTS@{ub}
    question - question the User has to respond to.

@{b}NOTES@{ub}
@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}
@ENDNODE

@NODE "SetNotifyWindow()" "SetNotifyWindow()"
@{fg shine}SetNotifyWindow()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SetNotifyWindow()

@{fg text}
@{b}SYNOPSIS@{ub}
    (void) SetNotifyWindow( struct Window *wptr );

@{b}DESCRIPTION@{ub}
    Set the window pointer that Handle_Problem() & other User-
    Requesters will use for the EasyRequest() call.

@ENDNODE

@NODE "SetReqButtons()" "SetReqButtons()"
@{fg shine}SetReqButtons()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SetReqButtons

@{fg text}
@{b}SYNOPSIS@{ub}
    (void) SetReqButtons( char *newbuttons );

@{b}DESCRIPTION@{ub}
    Set the buttons for the Information requester to the given 
    format string.

@{b}NOTES@{ub}
@{fg shine}    The user of this function should return the buttons to a
    known string after Handle_Problem() or the other User-
    requesters are called.
@{fg text}
@ENDNODE

@NODE "SetTagItem()" "SetTagItem()"
@{fg shine}SetTagItem()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SetTagItem()

@{fg text}
@{b}SYNOPSIS@{ub}
    void SetTagItem( struct TagItem *taglist, ULONG tag, ULONG value );

@{b}DESCRIPTION@{ub}
    This function searches the given taglist for the given tag.  If
    the tag is found, its value (ti_Data) is changed to the given
    value.  This function completes the functionality for using 
    TagLists.

@ENDNODE

@NODE "SetTagPair()" "SetTagPair()"
@{fg shine}SetTagPair()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SetTagPair()

@{fg text}
@{b}SYNOPSIS@{ub}
    void SetTagPair( struct TagItem *taglist, ULONG tag, ULONG value );

@{b}DESCRIPTION@{ub}
    Add a Tag & value to a TagItem list.  If taglist is NULL, 
    nothing is done by this function.
    This function completes the functionality for using TagLists.

@{b}NOTES@{ub}
@{fg shine}    taglist is really an array of ULONG values organized into pairs.

@{fg text}
@{b}WARNINGS@{ub}
    No check is done to see if there is space in the Tag list
    for the added pair (so why not reserve space by using: 
    {TAG_IGNORE, NULL} in the taglist you provide?).

@ENDNODE

@NODE "SetupList()" "SetupList()"
@{fg shine}SetupList()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SetupList()

@{fg text}
@{b}SYNOPSIS@{ub}
    void SetupList( struct List *lst, struct ListViewMem *lvm );

@{b}DESCRIPTION@{ub}
    Initialize a List structure for a ListView Gadget.

@ENDNODE

@NODE "StringCat()" "StringCat()"
@{fg shine}StringCat()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringCat()

@{fg text}
@{b}SYNOPSIS@{ub}
    UBYTE *result = StringCat( UBYTE *string1, UBYTE *string2 );

@{b}DESCRIPTION@{ub}
    Appends the contents of string2 to the contents of string1.

@{b}INPUTS@{ub}
    string1 - string being appended to.
    string2 - string to append.

@ENDNODE

@NODE "StringComp()" "StringComp()"
@{fg shine}StringComp()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringComp()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = StringComp( UBYTE *str1, UBYTE *str2 );

@ENDNODE

@NODE "StringCopy()" "StringCopy()"
@{fg shine}StringCopy()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringCopy()

@{fg text}
@{b}SYNOPSIS@{ub}
    int length = StringCopy( UBYTE *dest, UBYTE *src );

@ENDNODE

@NODE "StringIComp()" "StringIComp()"
@{fg shine}StringIComp()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringIComp()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = StringIComp( UBYTE *str1, UBYTE *str2 );

@{b}DESCRIPTION@{ub}
    Compare two strings without Case-sensitivity

@ENDNODE

@NODE "StringIndex()" "StringIndex()"
@{fg shine}StringIndex()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringIndex()

@{fg text}
@{b}DESCRIPTION@{ub}
    Returns the starting location of the substring in the string, 
    or -1 if not found.

@{b}SYNOPSIS@{ub}
    int location = StringIndex( UBYTE *string, UBYTE *subString );

@{b}INPUTS@{ub}
    string    - contains the string to search for subString.
    subString - string to look for. 

@ENDNODE

@NODE "StringLength()" "StringLength()"
@{fg shine}StringLength()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringLength()

@{fg text}
@{b}SYNOPSIS@{ub}
    int length = StringLength( UBYTE *str );

@{b}DESCRIPTION@{ub}
    The strlen() function does not handle a NULL parameter.
    This function corrects this deficiency.

@ENDNODE

@NODE "StringNCat()" "StringNCat()"
@{fg shine}StringNCat()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringNCat()

@{fg text}
@{b}SYNOPSIS@{ub}
    UBYTE *result = StringNCat( UBYTE *string1, UBYTE *string2, int maxSize )

@{b}DESCRIPTION@{ub}
    Appends the contents of string2 to the contents of string1.

@{b}INPUTS@{ub}
    string1 - string being appended to.
    string2 - string to append.
    maxSize - maximum length of string1.

@ENDNODE

@NODE "StringNComp()" "StringNComp()"
@{fg shine}StringNComp()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringNComp()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = StringNComp( UBYTE *str1, UBYTE *str2, int size );

@ENDNODE

@NODE "StringNCopy()" "StringNCopy()"
@{fg shine}StringNCopy()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringNCopy()

@{fg text}
@{b}SYNOPSIS@{ub}
    void StringNCopy( UBYTE *dest, UBYTE *src, int size );

@ENDNODE

@NODE "StringNIComp()" "StringNIComp()"
@{fg shine}StringNIComp()@{fg text}

@{b}NAME@{ub}
@{fg shine}    StringNIComp()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = StringNIComp( UBYTE *str1, UBYTE *str2, int length );

@{b}DESCRIPTION@{ub}
    Compare two strings without Case-sensitivity up to length chars

@ENDNODE

@NODE "SubString()" "SubString()"
@{fg shine}SubString()@{fg text}

@{b}NAME@{ub}
@{fg shine}    SubString()

@{fg text}
@{b}SYNOPSIS@{ub}
    UBYTE *sub = SubString( UBYTE *str, UBYTE *end );

@{b}DESCRIPTION@{ub}
    This function returns the partial string starting at *str &
    ending at *end.

@{B}WARNING@{UB}
    The buffer that this function uses is limited to BUFF_SIZE (512)
    in StringFunctions.h.  Anything larger will result in a 
    truncated answer.

@ENDNODE

@NODE "TrimSpaces()" "TrimSpaces()"
@{fg shine}TrimSpaces()@{fg text}

@{b}NAME@{ub}
@{fg shine}    TrimSpaces()

@{fg text}
@{b}SYNOPSIS@{ub}
    UBYTE *newString = TrimSpaces( UBYTE *oldString );

@{b}DESCRIPTION@{ub}
    Removes Trailing & Leading spaces from oldString & returns the
    result as newString.

@ENDNODE

@NODE "UpperCase()" "UpperCase()"
@{fg shine}UpperCase()@{fg text}

@{b}NAME@{ub}
@{fg shine}    UpperCase()

@{fg text}
@{b}DESCRIPTION@{ub}
    Convert the input string into all UpperCase Letters.

@{b}SYNOPSIS@{ub}
    UBYTE *result = UpperCase( UBYTE *inputString );

@{b}INPUTS@{ub}
    inputString - contains the characters to convert (if any).

@ENDNODE

@NODE "UserInfo()" "UserInfo()"
@{fg shine}UserInfo()@{fg text}

@{b}NAME@{ub}
@{fg shine}    UserInfo()

@{fg text}
@{b}SYNOPSIS@{ub}
    void UserInfo( char *message, char *windowtitle );

@{b}DESCRIPTION@{ub}
    Tell user some information.

@{b}NOTES@{ub}
@{fg shine}    Be sure to call SetNotifyWindow( wptr ) BEFORE using this 
    function for the first time!
@{fg text}
@ENDNODE

@NODE "drawArc()" "drawArc()"
@{fg shine}drawArc()@{fg text}

@{b}NAME@{ub}
@{fg shine}    drawArc()

@{fg text}
@{b}SYNOPSIS@{ub}
    void drawArc( struct Window *w, int xs, int ys, float angle, int xc, int yc ); 

@{b}DESCRIPTION@{ub}
    Draw an Arc into the given Window using graphics functions.

@{b}INPUTS@{ub}
    Xs    - starting Window Horizontal coordinate. 
    Ys    - starting Window Vertical   coordinate. 
    angle - the length of the arc in radians. 
    Xc    - the Horizontal coordinate of the arc pivot point.
    Yc    - the Vertical   coordinate of the arc pivot point.

@{b}WARNINGS@{ub}
    Set the drawing Pen(s), draw Mode & Line Pattern BEFORE using this.

@ENDNODE

@NODE "getScreenModeID()" "getScreenModeID()"
@{fg shine}getScreenModeID()@{fg text}

@{b}NAME@{ub}
@{fg shine}    getScreenModeID()

@{fg text}
@{b}SYNOPSIS@{ub}
    ULONG mode = getScreenModeID( struct TagItem *taglist, 
                                  struct Screen  *screen,
                                  char           *req_title
                                ); 

@{b}DESCRIPTION@{ub}
    Obtain a user-selected (via ASL) ScreenModeID value.  NULL will
    be returned if you supply a NULL value for the screen pointer,
    or if you press & release the Cancel Gadget on the Requester.

@ENDNODE

@NODE "getUserFont()" "getUserFont()"
@{fg shine}getUserFont()@{fg text}

@{b}NAME@{ub}
@{fg shine}    getUserFont()

@{fg text}
@{b}SYNOPSIS@{ub}
    struct TextAttr *font = getUserFont( struct TagItem *taglist, 
                                         struct Screen  *screen,
                                         char           *req_title
                                       ); 

@{b}DESCRIPTION@{ub}
    Obtain a user-selected (via ASL) Font.  A NULL value for the FONT
    is returned if you press & release the Cancel Gadget on the 
    Requester.

@{b}WARNINGS@{ub}
    Store the result BEFORE the next call to getUserFont()!!

@ENDNODE

@NODE "itoa()" "itoa()"
@{fg shine}itoa()@{fg text}

@{b}NAME@{ub}
@{fg shine}    itoa()

@{fg text}
@{b}SYNOPSIS@{ub}
    void itoa( int convertMe, char *stringbuffer );

@{b}DESCRIPTION@{ub}
    convert an decimal integer to a string.

@{b}WARNINGS@{ub}
    Make sure that stringbuffer is at least 20 characters long!

@ENDNODE

@NODE "stoi()" "stoi()"
@{fg shine}stoi()@{fg text}

@{b}NAME@{ub}
@{fg shine}    stoi()

@{fg text}
@{b}SYNOPSIS@{ub}
    int result = stoi( char **inputString );

@{b}DESCRIPTION@{ub}
    Convert a string to integer.  If the string starts with 0x, it
    is interpreted as a HexaDecimal number, else if it starts with
    a 0 it is octal, else it is decimal.  Conversion stops on 
    encountering the 1st character which is NOT a digit in the
    indicated radix.  *inputString is updated to point to the end
    of the numbers found.

@{b}INPUTS@{ub}
    inputString - contains the string to convert.

@{b}COPYRIGHT@{ub}
    Copyright (C) 1985 by Allen Holub.  All rights reserved.
    This program may be copied for personal, non-profit use only.


@{b}NOTES@{ub}
@{fg shine}    From "Dr. Dobb's ToolBook of C", 1986, ISBN: 0-89303-599-8,
    pgs 476-477.
@{fg text}
@ENDNODE

@NODE "strClear()" "strClear()"
@{fg shine}strClear()@{fg text}

@{b}NAME@{ub}
@{fg shine}    strClear()

@{fg text}
@{b}SYNOPSIS@{ub}
    void strClear( char *string );

@{b}DESCRIPTION@{ub}
    Reset a strings's contents to all nils.

@{b}INPUTS@{ub}
    string - The string to clear out.

@ENDNODE

