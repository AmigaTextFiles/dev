@database area.hyper
@node Main "Example program (Main node)"
   (Click here for short info about the @{" purpose " link purpose}).

@{" " link klafdef} #define MAX_COORD 40

  #include <intuition/intuition.h>
  #include <intuition/screens.h>
@{" " link gfxmacros} #include <graphics/gfxmacros.h>
  #include <clib/exec_protos.h>
  #include <clib/intuition_protos.h>
  #include <clib/graphics_protos.h>

  struct Library *IntuitionBase;
  struct GfxBase *GfxBase;
  struct NewScreen my_newscreen =
@{" " link nsc_reason} { 0, 0, 320, 200, 3, 0, 1, NULL, CUSTOMSCREEN, NULL,
    "A Screen for area-experiments.", NULL, NULL };

  void main( void )
  {
    struct Screen *my_scr;
  @{" " link why_rp} struct RastPort *my_rp;
  @{" " link whatisareainfo} struct AreaInfo my_AIstruct = { 0 };
  @{" " link whatistmpras} struct TmpRas my_tmpras;
  @{" " link whatplptr} PLANEPTR my_rastptr;
  @{" " link coord_buf} WORD coor_buf[ MAX_COORD*5 ];
    int i;

  @{" " link therightway} IntuitionBase =
      OpenLibrary( "intuition.library",0 );
    GfxBase = (struct GfxBase *)
      OpenLibrary( "graphics.library", 0 );

    my_scr=OpenScreen( &my_newscreen );
    my_rp=& my_scr->RastPort;

  @{" " link ofaras} my_rastptr = AllocRaster( my_scr->Width, my_scr->Height );

  @{" " link ofitr} InitTmpRas( &my_tmpras, my_rastptr,
           ((my_scr->Width+15)/16)*my_scr->Height );	
  @{" " link ofinitarea} InitArea( &my_AIstruct, coor_buf, MAX_COORD );

  @{" " link ofrptr} my_rp->TmpRas = &my_tmpras;
  @{" " link oflinking} my_rp->AreaInfo = &my_AIstruct;
    
  @{" " link ofsetapen} SetAPen( my_rp, 6);
    SetBPen( my_rp, 5); 
    SetOPen( my_rp, 4);
  @{" " link ofareamove} AreaMove( my_rp, 40, 50 );
    for(i=0; i<18; i++)
  @{" " link ofareadraw}   AreaDraw( my_rp, rand()%140+20, rand()%185+15 );
  @{" " link whyagain} AreaMove( my_rp, 210, 120 );
    for(i=0; i<18; i++)
      AreaDraw( my_rp, rand()%140+160, rand()%185+15 );

  @{" " link ofareaend} AreaEnd( my_rp );

  @{" " link ofdelay} Delay(500);

  @{" " link freeras} FreeRaster( my_rastptr, my_scr->Width, my_scr->Height );
    CloseScreen( my_scr );
    CloseLibrary( GfxBase );
    CloseLibrary( IntuitionBase );
  }
@endnode Main

@node purpose "The purpose of this .guide file and the files accompanying it."
   This document should teach, or at least give
information about, the basic workings of the Area
routines on the Amiga. It is built around a working
C program, listed in its entirity in the @{" Main node " link Main}.
Hopefully, it will be a nice reference the first few times
somebody tries to do draw filled polygons. I know
I would have appreciated something like this, before
I got ahold of the RKM-Libraries book (which cost @{"$$$..." link denmark})
myself.

   The C program is "as short as possible". In particular,
this implies that you should _not_ mimic the way the
libraries and the screen is opened. The incredibly
ugly thing is, that I do not check if the 'openings'
succeeded (with an if-sentence), but advance straight on,
assuming that the libraries/screen _did_ open. Also,
I do not check if the allocation of memory succeeded.
@{" (How it ought to be done) " link therightway}.

   Included with this file (area.guide) are two source
code files, shortarea.c and nicearea.c.
   The first one is excactly the same code as that
listed in the @{" Main node " link Main}. The second one also features
proper opening/allocation (No big deal, really. It's just
that, without this checking, the example is kept really
short and informative/readable).

   The executable (the file called area) is of course
nicearea.c compiled.


_________________________________________________

     ABOUT THIS ARCHIVE, DISTRIBUTION INFO.
_________________________________________________

The archive should contain the following
files:

area.guide  : this file.
area        : an executable - nicearea.c compiled.
shortarea.c : the example program.
nicearea.c  : like shortarea.c, but checks
              whether it succeeded in
              opening/allocating things.


You are encouraged to send enhancement
and bug/error suggestions concerning
this archive to me; if you can be mailed
from the Internet I will do what I can
to reply to you, to tell you what I did
with your suggestion.

My Internet email address, June 26 1993 is
pilgrim@daimi.aau.dk, and my own address

Jakob Gaardsted
Aldersrovej 11,5
8200 Aarhus N
Denmark.

This archive's contents are strictly public
domain and copyright me, implying I grant
people the right to get mad at you, if you
make a profit by supplying/distributing this
program (other than the obligatory decent
copying fee to cover cost of disk, you know
what I mean). Or rather, you do NOT have my
permission to make a profit on this archive
or its contents. Apart from this, you may copy
it to your heart's contents, give it to your
friends and your dog.

   I get sick when thinking about the prices
I've seen charged for solid PD. (e.g., 12$
per disk containing only things, you can
find on Fred Fish's disks. The mentioned
price includes disk, though. I am outraged.
Get out of my store).
              
@endnode purpose

@node denmark "What do you mean, expensive ?"
The books might be cheap in USA, but in Denmark, they are
a bit expensive. Although not more than books in general in
Denmark.
@endnode denmark

@node klafdef "What for?"
Well, it's just that, before you do any drawing of
polygons with the area routines, you need to decide
the maximum amount of defining points you
are going to use.
   Of course you can choose this amount on runtime
just as well, and change it and all that. But
you will have to go through the motions again,
reinitializing your AreaInfo structure and such.

Related: @{" Coordinate buffer " link coord_buf }.
@endnode klafdef

@node gfxmacros "Why include <graphics/gfxmacros.h> ?"
I want to include this, as SetOPen is not defined in the
same place as SetAPen and SetBPen (actually, at this
moment, and probably forever, it is a macro).
   Also, BNDRYOFF is defined here. To avoid you looking this
entire document through searching for further explanation
of BNDRYOFF, I'd better say here, that I've written
nothing else about it. It is used to switch off drawing
of borders around your area shapes, and some day I
might add some text describing it, but I haven't yet...
   For the time being, BNDRYOFF is also a macro. 
@endnode gfxmacros

@node nsc_reason "Why write the NewScreen struct in such an ugly manner?"
Because we are investigating the Area routines,
not dealing with how to go about opening screens...
This way, it takes up very little space.
   The reason I open a custom screen, instead of
just opening a window on the workbench screen, is
that I myself more often mess around on my own little
screen (with this kind of stuff), than on the wb. with
the A1200 and A4000 here, using the workbench screen
and a window might really be more appropriate, but nah...
@endnode nsc_reason

@node why_rp "Isn't my_rp redundant ?"
   Well, I am going to refer a lot to the rastport
I am operating on (in this case, the Screen's
Rastport). Referring is done via a pointer to
something, so being able to write my_rp is a lot nicer
than writing &my_scr->RastPort all the time.
@endnode why_rp

@node whatisareainfo "So, what is AreaInfo ?"
   It is a structure, your Amiga uses to keep
track of the list of points, you expect it to
draw a polygon between. You should initialize it
with InitArea().
   By the way, a part of this AreaInfo thing is some
memory supplied by you - a @{" Coordinate buffer " link coord_buf } 
@endnode whatisareainfo

@node whatistmpras "I see. Then what is a TmpRas, grandpa ?"
In effect, it is a workspace where the polygon is
first drawn (in simple "black and white", or if 
you will, 0 and 1...), before being rendered into
your display area. Part of this TmpRas thing is
a bitplane supplied by you...
   You should initialize the TmpRas with InitTmpRas().
@endnode whatistmpras

@node whatplptr "What is this special PLANEPTR type good for?"
This is just a kind of pointer used to point to plane-data.
You could have the opinion, that this is unnecessary, but
since bitplanes are special - they _must_ lie in CHIP-memory -
I think it is nice to use a special type of pointer, and
not just an ordinary memory pointer (which it also,
at the moment, happens to be). Mind you, whenever I
give 'arguments' like these, the thing I advocate is
usually something Commodore thinks is nice too...

@endnode whatplptr

@node coord_buf "What do you mean by 'coordinate buffer' ?"
When initializing the AreaInfo structure, you supply
a coordinate buffer. This is a WORD-aligned memory area,
that you must somehow manage to get ahold of. It will
be used to hold coordinates for the polygon-vertices,
and will use 5 bytes for each coordinate. With two
coordinates in a coordinate pair (x,y), you then
need 10 bytes for each vertex.
   To make such a buffer, you can declare an array 
of (NO_OF_VERTICES * 5) WORDs, which is excactly
what is done in this example program. You are on
your own, if you instead declare an array of
BYTEs or chars...
   Using AllocMem() will also work, as such acquired
memory is always LONGWORD aligned.
   malloc() should also work (by all means,
if it just calls AllocMem), but you are better off
without any advice from me on this one - I do not
know if you can just use malloc, or have to take
care of the case when the returned pointer is uneven.
@endnode coord_buf

@node therightway "You had better check all 'Open'ings and allocations."
Most programs using any of the Amigas features
need to open and/or allocate various things.
This example, for one, needs to open the Intuition
library, the Graphics library, and allocate some
raster memory. In shortarea.c, I do not check whether
any of these things succeed, but just carry on. If,
for example, you are low on memory (either deliberately
or accidently), shortarea.c can be guaranteed to crash
your amiga!
   nicearea.c is a bit longer than shortarea.c, but
should behave better. As you can see (I have put a 
cutout from nicearea.c below) I have a cleanup
function, Die_Gracefully(), that shuts down the things
that _did_ open/succeed, and then exits. 
   The other common way to handle these things is with
a nested if-structure. I myself prefer the former,
as the nesting can get 'heavy', when you open a lot
of things.
   if you have a cleanup function, you might want to
initialize all the pointers to NULL, or your check of
whether something is open might fail. Yes, I know most
C compilers initialize variables with zero, but I have
used compilers that do not. 


______________________________________________
void Die_Gracefully(char *reason)
{
  printf("%s\n", reason);

  if( my_rastptr )
    FreeRaster( my_rastptr, my_scr->Width, my_scr->Height );
  if( my_scr )
    CloseScreen( my_scr );
  if( GfxBase )
    CloseLibrary( GfxBase );
  if( IntuitionBase )
    CloseLibrary( IntuitionBase );

  exit(1);
}_____________________________________________


And an application of Die_Gracefully():
______________________________________________
IntuitionBase =
    OpenLibrary( "intuition.library",0 );
  if( !IntuitionBase )
    Die_Gracefully("Could not open Intuition Library.");
______________________________________________
@endnode therightway

@node ofinitarea "A call of InitArea()."
This is the second of three things you must
do, if you want to use the Area-routines.
When you do this, you are simply 
Initializing the AreaInfo structure...
@endnode ofinitarea

@node ofrptr "Linking the TmpRas to your rastport."
This is the last of three things you must
do, if you want to use the Area-routines.
You are connecting the freshly initialized
TmpRas structure to your rastport.
@endnode ofrpai

@node ofaras "This is the first thing."
Before you can start to draw, you must do
some initializing. It is reasonable to say,
this consists of doing three things. The
first is to get ahold of a raster, which
is needed for the TmpRas structure. As you
can see, this is done with AllocRaster().

   The second is to initialize a TmpRas and
an AreaInfo structure, and the third to link
these two structures to your rastport.
@endnode ofaras

@node ofitr "This is the second thing."
You are initializing the TmpRas structure,
thereby giving it the raster you got for
it.
@endnode ofitr

@node oflinking "The last touch."
And by doing this - linking the AreaInfo to
your rastport - you are through. Now you
can use the area-routines.

  To sum it up, you

 o  Allocated a Raster.
 
 o  Initialized an AreaInfo and a
    TmpRas structure.

 o  Linked them into your Rastport.

  Do realize, that the ordering,
the grouping, and the number of items
is arbitrarily chosen by me.

@endnode oflinking

@node ofareamove "Purpose of the AreaMove routine."
( I can also give you an @{" overview " link droview} of the
drawing process ).

AreaMove is one of three routines, you
use together to draw shapes. The other
two are AreaEnd and AreaDraw.
   Defining the shape is done by submitting
the corner points of your shape one by one.
There will be an edge between a point and the
one submitted before it, unless you have started
on a new shape. This is done with AreaMove.
The first vertex of every shape must be defined
with AreaMove. There will also be drawn an edge
between the first and last point of a shape;
"first" points are the ones submitted with
AreaMove. So you should/need not close a shape
with AreaMove (it wouldn't make sense).

@endnode ofareamove

@node ofareadraw "Purpose of the AreaDraw routine."
( I can also give you an @{" overview " link droview} of the
drawing process ).

AreaDraw is one of three routines used
together to draw shapes. There will be
an edge between the point you submit with
AreaDraw and the one submitted before it
(with AreaMove or AreaDraw).
@endnode ofareadraw

@node droview "How do we go about drawing things, then ?"

You use three functions:
 
  AreaMove, AreaDraw and AreaEnd.

You define what is to be drawn with AreaMove
and AreaDraw, and you then call AreaEnd to
submit it for drawing.
   AreaMove is used to start a new shape.
Think of it as lifting the pen from the 
paper and subsequently putting it down
somewhere else. In this way, you can define
several separate figures before drawing them.
However, your coordinate buffer must be large
enough to hold the definition of all the
figures in their entirity, so watch out.

@endnode droview

@node ofareaend "Purpose of the AreaEnd routine."
( I can also give you an @{" overview " link droview} of the
drawing process ).

In the list AreaMove, AreaDraw and AreaEnd,
I will here concern myself with the last
one mentioned.

AreaEnd is used to submit the defined shape(s)
for drawing. Notice, that calling AreaEnd
closes the shape you have defined - there
will be an edge from the last point you
submitted, to the first point in the
lastly defined shape (that is, the point
submitted with your last call to AreaMove).
@endnode ofareaend

@node whyagain "Why call AreaMove two times ?"
Just to demonstrate, that you can define
several shapes before submitting them for
drawing (with AreaEnd). As also mentioned
elsewhere, you start every new shape with
AreaMove.
@endnode whyagain

@node ofsetapen "Mama, I wish to learn the Secret of Set?Pen."
SetAPen controls the colour of the
interiour of the shape.

SetBPen has nothing to do with Area
drawing. This is why I set it. You
will still only see two colours, and
changing the 5 to something else changes
nothing at all.

SetOPen controls the shape's border
colour. this is not a function, it is
a macro defined in <graphics/gfxmacros.h>
Also, it controls whether there will
be any border at all. It takes effect
on a per point basis, so you can switch
borders on and off for different edges.
However, only the last set colour takes
effect.
  The morale you have to draw from this is,
that if you want a border around your shape,
you will have to SetOPen before you start
to add points. SetAPen is something else -
as long as you SetAPen before calling AreaEnd,
you are OK.

   You can use fill patterns to change the
appearance of the shape. I mention it
here, so I can tell you there is no other
information about how to do this in this
document.
@endnode ofsetapen

@node ofdelay "Really, why ?"
The only thing the program does is
open a screen, draw some figures,
then close the screen and exit.
Without the pause caused by Delay(),
it would go a bit fast (for me
personally, at least).

Delay(500) gives a pause of 500/50
seconds on PAL Amigas, and 500/60 on
NTSC Amigas.
@endnode ofdelay

@node freeras "Just what you would expect."
You return the raster memory, you
previously got ahold of with
AllocRaster(), to the system.
@endnode freeras

