OPT PREPROCESS,OSVERSION=39

MODULE 'icon', 'dos/dos', 'exec/memory', 'translator',
       'intuition/intuition', 'workbench/startup', 'workbench/workbench'

ENUM ERR_NONE, ERR_STG, ERR_CHDV

RAISE ERR_STG IF String()=0

DEF z, vle, ld=0:PTR TO CHAR, lft=0:PTR TO CHAR, ycr=1500:PTR TO INT,
    aslBuf[100]:STRING, trns=0:PTR TO CHAR

PROC main() HANDLE
DEF fma=0:PTR TO LONG
checkConfig()
IF ((lft>=0) AND (lft<8))
checkWordFile()
ELSEIF ((lft>7) AND (lft<10))
checkSpeechFile()
ELSE
checkTitles()
ENDIF
EXCEPT DO
IF translatorbase THEN CloseLibrary(translatorbase)
IF (fma:=AllocMem(8000000, 0))<>0 THEN FreeMem(fma, 8000000)
CleanUp()
ENDPROC

PROC checkConfig()
DEF olddir, ckstg, argv:PTR TO LONG, rdargs, wbstartup:PTR TO wbstartup,
    wbarg:PTR TO wbarg, ck=0:PTR TO CHAR, dobj:PTR TO diskobject, toolarray
argv:=[0, 0, 0, 0]
IF (iconbase:=OpenLibrary('icon.library', 37))<>0
IF wbmessage=0
IF rdargs:=ReadArgs('FILEDEVICE/K,LGUIFILETYPE/K,RANGE/K,TRANSLATE/K', argv, 0)
IF ck:=StrCmp(UpperStr(argv[0]), 'DH0:', ALL)
ld:=1
ELSEIF ck:=StrCmp(UpperStr(argv[0]), 'WORK:', ALL)
ld:=2
ELSEIF ck:=StrCmp(UpperStr(argv[0]), 'DF0:', ALL)
ld:=3
ELSEIF ck:=StrCmp(UpperStr(argv[0]), 'DF1:', ALL)
ld:=4
ELSEIF ck:=StrCmp(UpperStr(argv[0]), 'DF2:', ALL)
ld:=5
ELSEIF ck:=StrCmp(UpperStr(argv[0]), 'DF3:', ALL)
ld:=6
ENDIF
IF ck:=StrCmp(UpperStr(argv[1]), 'DS', ALL)
lft:=0
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FS', ALL)
lft:=1
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'DN', ALL)
lft:=2
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FN', ALL)
lft:=3
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'DA', ALL)
lft:=4
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FA', ALL)
lft:=5
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'DV', ALL)
lft:=6
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FV', ALL)
lft:=7
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FNS', ALL)
lft:=8
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'FSS', ALL)
lft:=9
ELSEIF ck:=StrCmp(UpperStr(argv[1]), 'TITLES', ALL)
lft:=10
ENDIF
IF argv[2]
ycr:=Val(argv[2])
IF ((ycr<1) OR (ycr>1500))
ycr:=1500
ENDIF
ENDIF
IF ck:=StrCmp(UpperStr(argv[3]), 'TRUE', ALL)
trns:=1
ENDIF
FreeArgs(rdargs)
ELSE
errreq(' Incorrect ARGS Supplied', 'Default ARGS Used')
ENDIF
ELSE
wbstartup:=wbmessage
wbarg:=wbstartup.arglist
FOR z:=0 TO wbstartup.numargs-1
olddir:=-1
IF wbarg.lock<>0 AND (wbarg.name[]<>0)
olddir:=CurrentDir(wbarg.lock)
ENDIF
IF (wbarg.name[]<>0) AND (dobj:=GetDiskObject(wbarg.name))
toolarray:=dobj.tooltypes
IF ckstg:=FindToolType(toolarray, 'FILEDEVICE')
IF MatchToolValue(ckstg, 'DH0:')
ld:=1
ELSEIF MatchToolValue(ckstg, 'WORK:')
ld:=2
ELSEIF MatchToolValue(ckstg, 'DF0:')
ld:=3
ELSEIF MatchToolValue(ckstg, 'DF1:')
ld:=4
ELSEIF MatchToolValue(ckstg, 'DF2:')
ld:=5
ELSEIF MatchToolValue(ckstg, 'DF3:')
ld:=6
ENDIF
ENDIF
IF ckstg:=FindToolType(toolarray, 'LGUIFILETYPE')
IF MatchToolValue(ckstg, 'DS')
lft:=0
ELSEIF MatchToolValue(ckstg, 'FS')
lft:=1
ELSEIF MatchToolValue(ckstg, 'DN')
lft:=2
ELSEIF MatchToolValue(ckstg, 'FN')
lft:=3
ELSEIF MatchToolValue(ckstg, 'DA')
lft:=4
ELSEIF MatchToolValue(ckstg, 'FA')
lft:=5
ELSEIF MatchToolValue(ckstg, 'DV')
lft:=6
ELSEIF MatchToolValue(ckstg, 'FV')
lft:=7
ELSEIF MatchToolValue(ckstg, 'FNS')
lft:=8
ELSEIF MatchToolValue(ckstg, 'FSS')
lft:=9
ELSEIF MatchToolValue(ckstg, 'TITLES')
lft:=10
ENDIF
ENDIF
IF ckstg:=FindToolType(toolarray, 'RANGE')
ycr:=Val(ckstg)
IF ((ycr<1) OR (ycr>1500))
ycr:=1500
ENDIF
ENDIF
IF ckstg:=FindToolType(toolarray, 'TRANSLATE')
IF MatchToolValue(ckstg, 'TRUE')
trns:=1
ENDIF
ENDIF
FreeDiskObject(dobj)
ELSEIF wbarg.name[]=0
errreq(' ICON Is The Wrong Type', 'Default ARGS Used')
ELSE
errreq(' Cannot Find DISKOBJECT', 'Default ARGS Used')
ENDIF
IF olddir<>-1
CurrentDir(olddir)
ENDIF
wbarg++
ENDFOR
ENDIF
IF iconbase<>0
CloseLibrary(iconbase)
ENDIF
ELSE
errreq(' Cannot Open Icon.Library', 'Default ARGS Used')
ENDIF
IF ld=0
StrCopy(aslBuf, 'RAM:')
ELSEIF ld=1
StrCopy(aslBuf, 'DH0:')
ELSEIF ld=2
StrCopy(aslBuf, 'WORK:')
ELSEIF ld=3
StrCopy(aslBuf, 'DF0:')
ELSEIF ld=4
StrCopy(aslBuf, 'DF1:')
ELSEIF ld=5
StrCopy(aslBuf, 'DF2:')
ELSEIF ld=6
StrCopy(aslBuf, 'DF3:')
ENDIF
StrAdd(aslBuf, 'LanguageGUI/', ALL)
ENDPROC

PROC errreq(title:PTR TO CHAR, text:PTR TO CHAR)
EasyRequestArgs(0, [SIZEOF easystruct, 0, title, text, 'O.K']:easystruct, 0, 0)
ENDPROC

PROC checkSpeechFile()
DEF fh, nl:PTR TO INT, fl, chr:PTR TO CHAR, tmp=0:PTR TO CHAR,
    pos=0:PTR TO CHAR, tstg:PTR TO CHAR, pstg:PTR TO CHAR, flname:PTR TO CHAR,
    cnt=0:PTR TO CHAR, pc=0:PTR TO CHAR, lc=0:PTR TO CHAR, ccn=0:PTR TO CHAR,
    frq=0:PTR TO CHAR, nsw:PTR TO CHAR, tlo=0:PTR TO CHAR
chr:=String(4)
StrCopy(chr, '    ', ALL)
nsw:=String(4)
StrCopy(nsw, '    ', ALL)
tstg:=String(25)
StrCopy(tstg, '                         ', ALL)
pstg:=String(50)
StrCopy(pstg, '                                                  ', ALL)
flname:=String(100)
StrCopy(flname, '                                                                                                    ', ALL)
StrCopy(flname, aslBuf, ALL)
IF lft=8
StrAdd(flname, 'FNSpeech.Lgui', ALL)
ELSEIF lft=9
StrAdd(flname, 'FSSpeech.Lgui', ALL)
ENDIF
IF trns=1
IF (translatorbase:=OpenLibrary('translator.library', 37))<>0
tlo:=1
ELSE
WriteF('\nERROR: Translator.Library, V37 or Higher, was Not Found.\n')
ENDIF
ENDIF
WriteF('\n*** SPEECH FILE - \s ***\n\n', flname)
fl:=FileLength(flname)
IF fl>21
tmp:=NewM(fl, MEMF_PUBLIC OR MEMF_CLEAR)
IF fh:=Open(flname, MODE_OLDFILE)
nl:=Read(fh, tmp, fl)
Close(fh)
IF nl=fl
IF Char(tmp)<>64
WriteF('\nThe @ Character Is Missing.\n')
Raise(ERR_CHDV)
ELSE
FOR z:=1 TO 4 DO chr[z]:=Char(tmp+z)
frq:=Val(chr)
IF ((frq<1) OR (frq>1500))
WriteF('\nThe NUMBER OF SYLLABLE LINES You Have Declared Is Not In The Correct\nRange Of 1-1500.\n\nYou Have Incorrectly Declared: \d\n', frq)
Raise(ERR_CHDV)
ELSE
pos:=6
ENDIF
ENDIF
WHILE cnt<frq
ccn:=0
StrCopy(tstg, '                         ', ALL)
StrCopy(pstg, '                                                  ', ALL)
WHILE (vle:=Char(tmp+pos))<>10
IF ccn>=25
WriteF('\nSYLLABLE LINE \d Is More Than 25 Characters Long.\n', cnt+1)
Raise(ERR_CHDV)
ELSE
IF vle>31
tstg[ccn]:=vle
INC pos
INC ccn
ELSE
WriteF('\nSYLLABLE LINE \d Has An Invalid Character Inside It - Chr$(\d).\n\nPosition = \d\n\nN.B: Characters Below Chr$(32) Are Not Allowed.\n', cnt+1, vle, ccn+1)
Raise(ERR_CHDV)
ENDIF
ENDIF
ENDWHILE
IF ((ccn=0) AND ((Char(tmp+pos))=10))
WriteF('\nSYLLABLE LINE \d Is Not Valid.\n\nN.B: Empty Syllable Lines Are Not Allowed.\n', cnt+1)
Raise(ERR_CHDV)
ENDIF
IF ((trns=1) AND (tlo=1))
Translate(tstg, 25, pstg, 50)
WriteF('\s\n', pstg)
ENDIF
INC cnt
INC pos
ENDWHILE
IF Char(tmp+pos)=42
pos:=pos+2
cnt:=0
ELSE
WriteF('\nThe * End Marker Is Missing.\n')
Raise(ERR_CHDV)
ENDIF
WriteF('\n\nChecking Syllable Assignments, etc....\n')
WHILE ((Char(tmp+pos)=35) OR (Char(tmp+pos)=37))
pc:=0
FOR z:=1 TO 4 DO chr[z]:=Char(tmp+pos+z)
vle:=Val(chr)
lc:=vle
IF ((lc>0) AND (lc<=Min(ycr, 1500)))
pos:=pos+6
ELSE
WriteF('\nThe SPEAKING SENTENCE TO BE ACTIVATED (Position/Line: \d), (Value:\s),\nIs Not In YOUR Range Of 1-\d\n', cnt+1, chr, ycr)
Raise(ERR_CHDV)
ENDIF
WHILE (Char(tmp+pos))<>42
IF pc>=25
WriteF('\nYou Have Declared More Than 25 SYLLABLE LINES TO USE.\n\nThe SPEAKING SENTENCE TO BE ACTIVATED Is:\s - Check Its SYLLABLE LINES.\n', chr)
Raise(ERR_CHDV)
ELSE
FOR z:=0 TO 3 DO nsw[z]:=Char(tmp+pos+z)
vle:=Val(nsw)
IF ((vle>0) AND (vle<=Min(frq, 1500)))
INC pc
pos:=pos+4
ELSE
WriteF('\nYou Have An Invalid Value For One Of Your SYLLABLE LINES TO USE.\n\nThe SPEAKING SENTENCE TO BE ACTIVATED Is:\s.\n\nYour Invalid SYLLABLE LINE TO USE Is: \s  (At Number/Line Position: \d)\n', chr, nsw, pc+1)
Raise(ERR_CHDV)
ENDIF
ENDIF
ENDWHILE
pos:=pos+2
INC cnt
ENDWHILE
WriteF('\n....Checking Finished.\n')
IF ((trns=1) AND (tlo=1))
WriteF('\nN.B: Make sure the Length of any Translated (Phonetic) text line is\n     no longer than 25 Characters.')
ENDIF
ELSE
WriteF('\nERROR: \s was only Partly Read.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSE
WriteF('\nERROR: \s was Not Opened.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSEIF ((fl>=0) AND (fl<22))
WriteF('\nERROR: \s was Too Small.\n', flname)
Raise(ERR_CHDV)
ELSE
WriteF('\nERROR: \s was Not Found.\n', flname)
Raise(ERR_CHDV)
ENDIF
IF tstg THEN DisposeLink(tstg)
IF pstg THEN DisposeLink(pstg)
IF chr THEN DisposeLink(chr)
IF nsw THEN DisposeLink(nsw)
IF flname THEN DisposeLink(flname)
IF translatorbase<>0 THEN CloseLibrary(translatorbase)
ENDPROC

PROC checkWordFile()
DEF pos=0:PTR TO CHAR, cnt=0:PTR TO CHAR, fh, nl:PTR TO INT, fl,
    chr:PTR TO CHAR, rnge=0:PTR TO INT, pcnt=0:PTR TO CHAR, tmp=0:PTR TO CHAR,
    flname:PTR TO CHAR, nsw:PTR TO CHAR, ccnt=1:PTR TO CHAR
chr:=String(4)
StrCopy(chr, '    ', ALL)
nsw:=String(4)
StrCopy(nsw, '    ', ALL)
flname:=String(100)
StrCopy(flname, '                                                                                                    ', ALL)
StrCopy(flname, aslBuf, ALL)
IF lft=0
StrAdd(flname, 'DSentences.Lgui', ALL)
ELSEIF lft=1
StrAdd(flname, 'FSentences.Lgui', ALL)
ELSEIF lft=2
StrAdd(flname, 'DNouns.Lgui', ALL)
ELSEIF lft=3
StrAdd(flname, 'FNouns.Lgui', ALL)
ELSEIF lft=4
StrAdd(flname, 'DAdjectives.Lgui', ALL)
ELSEIF lft=5
StrAdd(flname, 'FAdjectives.Lgui', ALL)
ELSEIF lft=6
StrAdd(flname, 'DVerbs.Lgui', ALL)
ELSEIF lft=7
StrAdd(flname, 'FVerbs.Lgui', ALL)
ENDIF
IF ((lft>=0) AND (lft<2))
WriteF('\n*** SENTENCE FILE - \s ***\n\n', flname)
ELSEIF ((lft>1) AND (lft<8))
WriteF('\n*** WORD FILE - \s ***\n\n', flname)
ENDIF
fl:=FileLength(flname)
IF fl>2067
tmp:=NewM(fl, MEMF_PUBLIC OR MEMF_CLEAR)
IF fh:=Open(flname, MODE_OLDFILE)
nl:=Read(fh, tmp, fl)
Close(fh)
IF nl=fl
REPEAT
WriteF('\nChecking Category: \d\n', ccnt)
IF Char(tmp+pos)<>64
WriteF('\nThe @ character is missing from Category: \d\n', ccnt)
Raise(ERR_CHDV)
ELSE
FOR z:=1 TO 4 DO chr[z]:=Char(tmp+pos+z)
vle:=Val(chr)
IF vle<=0
WriteF('\nThe NUMBER OF DECLARED SENTENCE LINES in Category: \d  is invalid.\n', ccnt)
Raise(ERR_CHDV)
ENDIF
IF ((lft>=0) AND (lft<2))
rnge:=vle*2
ELSE
rnge:=vle
ENDIF
ENDIF
pos:=pos+6
cnt:=0
WHILE cnt<rnge
pcnt:=0
WHILE (vle:=Char(tmp+pos+pcnt))<>10
IF pcnt>=42
WriteF('\nYou have too many characters in Sentence Line: \d / Category: \d\n', cnt+1, ccnt)
Raise(ERR_CHDV)
ENDIF
IF vle<32
WriteF('\nINVALID CHARACTER in Sentence Line: \d\n', cnt+1)
Raise(ERR_CHDV)
ENDIF
INC pcnt
ENDWHILE
IF pcnt=0
WriteF('\nSentence Line: \d / Category: \d is invalid.\n\nN.B: EMPTY Sentence Lines are not allowed - A Sentences Line must contain\n     exactly 42 characters.\n', cnt+1, ccnt)
Raise(ERR_CHDV)
ENDIF
pos:=pos+43
INC cnt
ENDWHILE
IF (vle:=Char(tmp+pos))=42
pos:=pos+2
INC ccnt
ELSE
WriteF('\nThe * END MARKER is missing from Category: \d\n\nIf your * END MARKER is present, Check that you have declared\nthe right number of Sentence Lines.', ccnt)
Raise(ERR_CHDV)
ENDIF
UNTIL pos>=fl
IF ccnt<>23
WriteF('\nYou have \d Categories - LGUI Text Files MUST have exactly\n22 Categories in them.\n', ccnt-1)
Raise(ERR_CHDV)
ENDIF
ELSE
WriteF('\nERROR: \s was only Partly Read.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSE
WriteF('\nERROR: \s was Not Opened.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSEIF ((fl>=0) AND (fl<2068))
WriteF('\nERROR: \s was Too Small.\n', flname)
Raise(ERR_CHDV)
ELSE
WriteF('\nERROR: \s was Not Found.\n', flname)
Raise(ERR_CHDV)
ENDIF
IF chr THEN DisposeLink(chr)
IF nsw THEN DisposeLink(nsw)
IF flname THEN DisposeLink(flname)
WriteF('\n....Checking Finished.\n')
ENDPROC

PROC checkTitles()
DEF pos=0:PTR TO CHAR, fh, nl:PTR TO INT, fl, tmp=0:PTR TO CHAR,
    flname:PTR TO CHAR, ccnt=1:PTR TO CHAR
flname:=String(100)
StrCopy(flname, '                                                                                                    ', ALL)
StrCopy(flname, aslBuf, ALL)
StrAdd(flname, 'Titles.Lgui', ALL)
WriteF('\n*** TITLES FILE - \s ***\n\n', flname)
fl:=FileLength(flname)
IF fl=1276
tmp:=NewM(fl, MEMF_PUBLIC OR MEMF_CLEAR)
IF fh:=Open(flname, MODE_OLDFILE)
nl:=Read(fh, tmp, fl)
Close(fh)
IF nl=fl
REPEAT
WriteF('\nChecking Title: \d\n', ccnt)
FOR z:=0 TO 27
IF Char(tmp+pos+z)<32
WriteF('\nTitle \d - Character \d is Invalid.\n', ccnt, z)
Raise(ERR_CHDV)
ENDIF
ENDFOR
pos:=pos+28
IF Char(tmp+pos)<>10
WriteF('\nTitle \d - The RETURN/ENTER Character is missing, from the end of the line.\n', ccnt)
Raise(ERR_CHDV)
ENDIF
INC ccnt
INC pos
UNTIL pos>=fl
IF ccnt<>45
WriteF('\nYou have \d Titles - The LGUI Titles File MUST have exactly\n44 Titles in it.\n', ccnt-1)
Raise(ERR_CHDV)
ENDIF
ELSE
WriteF('\nERROR: \s was only Partly Read.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSE
WriteF('\nERROR: \s was Not Opened.\n', flname)
Raise(ERR_CHDV)
ENDIF
ELSEIF ((fl>=0) AND (fl<1276))
WriteF('\nERROR: \s was Too Small.\n', flname)
Raise(ERR_CHDV)
ELSEIF fl>1276
WriteF('\nERROR: \s was Too Large.\n', flname)
Raise(ERR_CHDV)
ELSE
WriteF('\nERROR: \s was Not Found.\n', flname)
Raise(ERR_CHDV)
ENDIF
IF flname THEN DisposeLink(flname)
WriteF('\n....Checking Finished.\n')
ENDPROC
