/*
** This P96 sample program demonstrates the API to create
** and handle memory overlays on supported graphics cards,
** implemented by Thomas Richter, THOR Software, 
** September 2021.
**
** Currently, only the CVision3D and the PicassoIV support
** overlays.
**
** While this program does not seem to generate anything
** spectacular - namely just a circle in a window -
** note that this is not an ordinary rastport the program
** draws into, but an overlay. Note that the circle is
** rescaled, and this rescaling is not done by P96 nor
** this program, but by the hardware.
**
** Depending on the capabilities of your graphics board,
** the circle may flicker if the window is partially hidden.
** This is because the bandwidth to the graphics memory is
** limited, and may not be sufficient to deliver both the
** overlay and the background.
**
** In some modes, the circle may not appear at all. For
** example, the S3Virge in the CVision3D can only generate
** overlays if the "stream processor" is turned on, and this
** requires a non-scandoubled mode with a horizontal
** resolution of 1024 pixels or less. Higher clocked modes
** use the "double pumped" VGA pipeline and bypass the stream
** processor. The circle will also disappear on the CVision3D
** if screens are dragged. This is also because split-screens
** are generated by the VGA logic and not the stream processor.
**
** Thus, beware, overlays may not be as generic as you like them
** to be.
**
** Compile with SAS/C, and link without Startup Code.
*/
#include <intuition/screens.h>
#include <graphics/rastport.h>
#include <graphics/gfxmacros.h>
#include <dos/dos.h>
#include <dos/dosextens.h>
#include <libraries/Picasso96.h>
#include <intuition/screens.h>
#include <intuition/intuition.h>
#include <exec/execbase.h>
#include <utility/tagitem.h>

#include <pragmas/exec_sysbase_pragmas.h>
#include <pragmas/graphics_pragmas.h>
#include <pragmas/intuition_pragmas.h>
#include <pragmas/dos_pragmas.h>
#include <pragmas/Picasso96_pragmas.h>
#include <clib/exec_protos.h>
#include <clib/graphics_protos.h>
#include <clib/dos_protos.h>
#include <clib/intuition_protos.h>
#include <clib/Picasso96_protos.h>

#include <proto/Picasso96.h>

#include <string.h>

/*
** Some shell arguments.
*/
#define TEMPLATE "Pubscreen=PS/K"
#define OPT_PUBSCREEN 0
#define OPT_LEN 1

/*
** Library bases
*/
struct Library *P96Base;
struct DosLibrary *DOSBase;
struct IntuitionBase *IntuitionBase;
struct GfxBase *GfxBase;
struct ExecBase *SysBase;

/*
** Prototypes
*/
LONG DemoProgram(struct Message *msg);

LONG __asm __saveds main(void)
{
  struct Message *msg = NULL;
  struct Process *proc;
  LONG rc = 25;
  
  SysBase = *((struct ExecBase **)(4L));
  
  proc = (struct Process *)(SysBase->ThisTask);

  /*
  ** Swallow WB Startup message
  */
  if (proc->pr_CLI == 0) {
    WaitPort(&(proc->pr_MsgPort));
    msg = GetMsg(&(proc->pr_MsgPort));
  }

  /*
  ** Open all the libraries
  */
  if (DOSBase = (struct DosLibrary *)OpenLibrary("dos.library",40)) {
    if (GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",40)) {
      if (IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library",40)) {
	if (P96Base = OpenLibrary("Picasso96API.library",2)) {

	  rc = DemoProgram(msg);
	  
	  CloseLibrary(P96Base);
	} else if (msg == NULL) {
	  Printf("This program requires the picasso96api.library version 2 or better.\n");
	}
	CloseLibrary((struct Library *)IntuitionBase);
      }
      CloseLibrary((struct Library *)GfxBase);
    }
    CloseLibrary((struct Library *)DOSBase);
  }

  /*
  ** Shutdown
  */
  if (msg) {
    Forbid();
    ReplyMsg(msg);
  }

  return rc;
}

/*
** This opens a P96 PIP window. The overlayfmt is the RGB format of
** the overlaid rastport. Formats are defined in <libraries/picasso96.h>,
** in the RGBFTYPE enum.
**
** The graphics card imposes some restrictions of which formats are 
** available for the overlay, in general, a "big-endian" mode will
** require a "big endian" overlay, though the format does not need to be
** identical to the format of the underlying screen.
**
** In particular, overlays may offer *MORE* formats than the native
** screen.
** Typical additional formats(!) are YUV based, including 422 or 420
** sampled YUV formats. Such formats are very convenient to display
** natural video in them. The conversion from YUV to RGB is performed
** by the graphics hardware, thus overlays are very fast.
**
** For example, the S3Virge in the CVision3D supports the following
** overlay types (on *ANY* screen, provided bandwidth is available):
**
** RGBFB_R8G8B8   : 24bit RGB on little-endian screens
** RGBFB_R5G6B5PC : 16bit RGB on little-endian screens
** RGBFB_R5G6B5   : 16bit RGB on big-endian screens
** RGBFB_R5G5B5PC : 15bit RGB on little-endian screens
** RGBFB_R5G5B5   : 15bit RGB on big-endian screens
** RGBFB_A8R8G8B8 : 32bit RGB on big-endian screens
** RGBFB_B8G8R8A8 : 32bit RGB on little-endian screens
** RGBFB_YUV422   : 422 YUV Y1-U0-Y0-V0
** RGBFB_YUV422PC : 422 YUV V0-Y0-U0-Y1
** RGBFB_YUV422CGX: 422 YUV Y0-V0-Y1-U0
** RGBFB_YUV411   : 211 YUV
** RGBFB_YUV411PC : 211 YUV
**
** Planar and chunky indexed modes are *not* available on
** overlays.
**
*/

/*
** Open a PIP window in the given format
*/
struct Window *OpenMemoryWindow(struct Screen *sc,RGBFTYPE overlayfmt)
{
  return p96PIP_OpenTags(WA_PubScreen,sc,
			 P96PIP_Type          ,P96PIPT_MemoryWindow, /* A memory window */
			 P96PIP_SourceFormat  ,overlayfmt,           /* the overlay format */
			 P96PIP_SourceWidth   ,320, /* dimension of the overlay bitmap */
			 P96PIP_SourceHeight  ,200,
			 /* Intuition tags */
			 WA_Title, "Memory Window Test",
			 WA_Activate, TRUE,
			 /* WA_RMBTrap, TRUE, */
			 WA_Left, (sc->Width-320)/2,
			 WA_Top, (sc->Height-200)/2,
			 WA_InnerWidth, 320,
			 WA_InnerHeight, 200,
			 WA_DragBar, TRUE,
			 WA_NotifyDepth, TRUE,
			 WA_DepthGadget, TRUE,
			 WA_SimpleRefresh, TRUE,
			 WA_SizeGadget, TRUE,
			 WA_CloseGadget, TRUE,
			 WA_IDCMP, IDCMP_CLOSEWINDOW,
			 WA_PubScreen, sc, TAG_DONE);
  /*
  ** Additional tags in libraries/picasso96.h.
  ** P96PIP_SourceBitMap:  custom bitmap,  otherwise allocated
  ** P96PIP_SourceRPort:   custom rastport,otherwise allocated
  ** P96PIP_Type       :   some chips also offer video overlays, the source then comes from
  **                       a video input. The P-IV flickerfixer works like this.
  ** P96PIP_Brightness :   brightness control, not for the S3Virge
  ** P96PIP_Left       :   left edge of the overlay relative to the window (default: 0)
  ** P96PIP_Top        :   top edge of the overlay relative to the window  (default: 0)
  ** P96PIP_Width      :   width of the overlay, default is inner width of the window
  ** P96PIP_Height     :   height of the overlay, default of the inner height of the window
  ** P96PIP_Relativity :   how to scale the overlay relative to the window, default
  **                       PIPRel_Width|PIPRel_Height -> scale with width and height
  ** P96PIP_Colors
  ** P96PIP_Colors32   :   Default pens for the overlay for CLUT overlays (non-S3)
  ** P96PIP_ClipLeft	
  ** P96PIP_ClipWidth
  ** P96PIP_ClipHeight :   Inner clipping of overlay (non-S3)
  */
}
			  

/*
** The main program, creates an overlay, renders a
** graphic into it, and waits for the user to close it.
*/
LONG DemoProgram(struct Message *msg)
{
  struct Screen *sc;
  const char *pubname = "Workbench";
  struct Window *win = NULL;
  struct RDArgs	*rda = NULL;
  struct RastPort *rp = NULL;
  LONG abort = FALSE;
  LONG args[OPT_LEN];

  memset(args,0,sizeof(args));

  /*
  ** Get the name of the screen to put the window
  ** on. Default is the workbench.
  */
  if (msg == NULL) {
    rda = ReadArgs(TEMPLATE,args,NULL);
    if (rda == NULL) {
      PrintFault(IoErr(),NULL);
      return 20;
    }
    if (args[OPT_PUBSCREEN])
      pubname = ((const char **)args)[OPT_PUBSCREEN];
  }

  /*
  ** Create a 16-bit hi-color overlay. May be big or
  ** little-endian. Try both, depends on the screen
  ** we put them on which one works...
  */
  if ((sc = LockPubScreen((char *)pubname))) {
    win = OpenMemoryWindow(sc,RGBFB_R5G6B5PC); /* First attempt: little-endian mode */
    if (win == NULL) {
      win = OpenMemoryWindow(sc,RGBFB_R5G6B5); /* Second attempt: big endian */
    }
  }
  
  UnlockPubScreen((char *)pubname,sc);
  
  if (rda)
    FreeArgs(rda);

  if (win == NULL) {
    if (msg == NULL) {
      PrintFault(ERROR_OBJECT_WRONG_TYPE,"PIP cannot open a memory window, maybe the hardware does not support it");
    }
    return 10;
  }

  /*
  ** Now retrieve the rastport to draw into
  */
  {
    struct TagItem tags[2];

    tags[0].ti_Tag  = P96PIP_SourceRPort;
    tags[0].ti_Data = (ULONG)&rp;
    tags[1].ti_Tag  = TAG_DONE;

    p96PIP_GetTagList(win,tags);
    /*
    ** This call retrieves properties of the overlay. In particular:
    ** P96PIP_SourceBitMap:  ** to Bitmap of the overlay
    ** P96PIP_SourceRPort :  ** to RastPort of the overlay
    ** P96PIP_ClipLeft    :
    ** P96PIP_ClipTop     :
    ** P96PIP_ClipWidth   :
    ** P96PIP_ClipHeight  :  Clipping bounds of the overlay
    **
    ** The call returns the number of tags filled in.
    */
  }

  if (rp == NULL) {
    if (msg == NULL) {
      PrintFault(ERROR_OBJECT_NOT_FOUND,"PIP cannot obtain the rastport to render data into");
    }
    return 10;
  }

  /*
  ** Time to draw something...
  ** Ok, this should really be some fancy graphics. Note that
  ** the content is scaled to the dimension of the window - depending
  ** on P96PIP_Relativity.
  */
  DrawEllipse(rp, 160, 100, 60, 40);

  /*
  ** The main loop...
  ** There is really nothing to see here. P96 informs the
  ** chipset on window rescaling, and adapts the size of the
  ** overlay accordingly.
  */
  do {
    struct IntuiMessage *imsg;
    
    WaitPort(win->UserPort);

    while ((imsg = (struct IntuiMessage *)GetMsg(win->UserPort))) {
      switch(imsg->Class) {
	case IDCMP_CLOSEWINDOW:
	  abort = TRUE;
	  break;
      }
      ReplyMsg(imsg);
    }
  } while(!abort);

  /*
  ** Close the window
  */
  p96PIP_Close(win);

  return 0;
}

