@database "OMonE.guide"
@node "main"

			     OMON V2.8

		   (c) 1994-2011 by Jürgen Klawitter

			      FREEWARE

    @{" Purpose               " link "Purpose"}
    @{" Start                 " link "Start"}
    @{" Command survey        " link "Command survey"}
    @{" General               " link "General"}
    @{" Moving through memory " link "Moving through memory"}
    @{" Lists                 " link "Lists"}
    @{" Jumping to structures " link "Jumping to structures"}
    @{" Mixed                 " link "Mixed"}
    @{" Help                  " link "Help"}
    @{" Search                " link "Search"}
    @{" Loading a file        " link "Loading a program"}
    @{" Modifying memory      " link "Modifying memory"}
    @{" Conversion of numbers " link "Conversion of numbers"}
    @{" Disassembling         " link "Disassembling"}
    @{" Author                " link "Author"}

@endnode
@node "Purpose"

    PURPOSE
    =======

    OMON is a monitor, which displays memory and and system lists. Its
    main purpose is to easily find and display structures, but it also
    can be used to disassemble programs, modify memory or files.

    Some features:

    - Input of addresses in most cases not necessary, because structures
      and lists are found by their names or name abbreviations respectively.

    - Apart from common structures like tasks, windows, libraries etc.
      a couple of unusual structures can be accessed, e.g. Locale, Catalog,
      DataType, MonitorSpec, ConUnit, TDUPublicUnit.

    - Pointer (APTR, BPTR) within structures may be used to jump to the
      addresses they point to.

    - Information about the offsets of more than 35 structures is built in and
      can easily be accessed. That's why I named this piece of software OMon
      (=offset monitor).

    - External help files like includes, LVOs etc can additionally be loaded

    - Built in 'memcheck' function prevents access of illegal or dangerous
      memory areas. You may switch it off if needed.

    - Very fast search function (Boyre-Moore)

    - Needs OS 2+
      Can be made resident
      Has been coded in assembly. It's fast and small.

@endnode
@node "Start"

    START
    =====

    OMon can be started from Workbench or Shell. If started from Shell
    one of the commands listed below can be given as an argument. However
    not all commands will work because they depend on conditions which are
    not fulfilled at start, e.g. offsets.

    Without any argument OMon will present the TaskWait-List at start.
@endnode
@node "Command survey"

    COMMAND SURVEY
    ==============

    This survey will be displayed if you type '?'.

    MOVE			    HELP
    <address>, +/-<offset>, return  ?, h [<structure>]
    > <offset> , >> <offset>	    help <helpfile>
    <, -, ., g=goto <mark>	    FILE
    mark [0-9] [<note>] 	    load <file>, first, last
    SEARCH			    saveas <file>
    s[-] "<string>" | <hexvalue>    CONVERT
    ss <LVO>			    #<<, #>>, #"ascii"
    sh <string>, more		    #[b,w,l][-][_,%%][<value>]
    VARIOUS			    DISASSEMBLE
    *, !, cls, o <outfile>	    dis [<address>] | +<length>
    exe <cmd>, list [<file/dir>]    dis <address> <address>
    segm <proc>, cli [n]	    MEMORY
    cu [n], tdu [n]		    chunks, flush, savemem <file>
    locks, lock [<address>]	    MODIFY
    drive [<drive>]		    mod "<string>" | <hexvalue>
    locale, obtaindt <file>	    EXIT with q or x

    LISTS	    Usage: <list> [<name>] [n]	    cat=Catalogs
    dl=DeviceList   dt=DataTypes    fse=FilSysEntry in=InputHandler
    i=Interrupts    k=KeyMaps	    l=Libraries     m=Memory
    mon=Monitors    p=Ports	    r=Resources     rc=ResCmds
    re=Residents    sm=Semaphores   scm=ScrModes    t=Tasks/Processes
    tf=TextFonts    tr=TimeRequests v=De[v]ices     w=Windows/Screens

    This may look rather confusing. But be patient! You have to spend some
    time to detect all the possibilities OMon offers.
    The meaning of every command is explained below, but first ....
@endnode
@node "General"

    GENERAL
    =======

    OMon opens a CON-Window when started, so that the abilities of the
    console handler (command line editing, history function) can be used.

    By default 128 bytes of memory are displayed (8 lines, each with
    16 bytes). By typing '*' you can switch to 16 lines (256 bytes).
    Memory is displayed as follows:

		   Offset
	    Line   CURRENT
    BASE    Offset ADDRESS    Name of memory		    ASCII
      |        |     |		   |			      |
      V        V     V		   V			      V
    07E007EC	 +00000000 expansion memory
    07E007EC: 000 07E2F2B8 00000A6C 099C00F8 008F0400 .âò¸...l...ø....
    07E007FC: 010 032A0278 0027002F 00F8009C 409D0000 .*.x.'./.ø..@...
    07E0080C: 020 0001006A 0000F81F F8130000 00000000 ...j..ø.ø.......
    07E0081C: 030 00000000 000007E0 226807E0 0A680020 .......à"h.à.h.
    07E0082C: 040 000000F8 33CA0000 00000000 00000000 ...ø3Ê..........
    07E0083C: 050 00009DF1 00000000 00000000 00000000 ...ñ............
    07E0084C: 060 07E0344C 00F91D34 07E0349A 00000000 .à4L.ù.4.à4.....
    07E0085C: 070 00F81784 00000000 07E00020 00F81706 .ø.......à. .ø..
    ....

    The first line contains some status information. From left to right:

	- BASE	    Basic address to which offsets are added

	- Offset CURRENT ADDRESS
		    Shows the offset of the so called CURRENT ADDRESS
		    which is used by several commands of OMon.
		    The CURRENT ADDRESS is connected with the BASE by the
		    following simple equation:

		    BASE + Offset = CURRENT ADDRESS

		    The offset is stored internally as longword and can be
		    positive or negative. In contrast to the BASE, the
		    CURRENT ADDRESS is allways situated in the memory area
		    displayed.

	- Name of memory
		    This may be 'chip memory' or 'expansion memory' or
		    something like that. If the displayed memory area is not
		    in the lists maintained by Exec, e.g. ROM or private
		    memory areas of the system, you'll get the information
		    'ROM' or 'Not in MemList'.

    If the memory at CURRENT ADDRESS is not in use, the message @{fg back}@{bg text} free @{fg text}@{bg back}
    will appear behind the name. If the CURRENT ADDRESS happens to be at
    the beginning of a free memory block @{fg back}@{bg text} free @{fg text}@{bg back} is replaced by
    @{fg back}@{bg text} MemChunk @{fg text}@{bg back}. As you probably know a MemChunk is a structure of
    8 bytes length. The first longword points to the next MemChunk, the
    second contains the length of the free memory block.

    The display looks as follows:

    07E30678	 +00000000 expansion memory  @{fg back}@{bg text}MemChunk@{fg text}@{bg back}
    07E30678: 000 07E306C0 00000008 20202020 20202020 .ã.À....
    07E30688: 010 2D2D2D2D 2D2D2D2D 00000000 00000000 --------........
    07E30698: 020 00000000 00000000 00000014 00000003 ................
    ....

    In this case the next block of free memory starts at address $07E306C0
    and the Chunk is 8 bytes long.


    Beneath the status line at the left are the hexadecimal addresses of
    each line. To the right follow the offsets in relation to the BASE.
    They consist of the last 3 digits of the real offset. This is sufficient
    because no structure is longer.

    After input of an offset (will be explained below) it will be added to
    the BASE, and the memory area where it is situated will be displayed.
    The first 4 bytes beginning at the offset will be marked with another
    colour.


    EXAMPLE: -> +114


    @{fg fill}07E007EC@{fg text}      +00000114 expansion memory
    07E008EC: 100 00000000 00000000 07E00060 00F81706 .........à.`.ø..
    07E008FC: 110 00000000 @{bg shine}07E51178@{bg back} 0003594A 0000E077 ....@{bg shine}.å.x@{bg back}..YJ..àw
    07E0090C: 120 00040004 0000FF00 00070000 07E00410 ......ÿ......à..
    07E0091C: 130 00F83054 00F83054 00F825C0 0000FFFF .ø0T.ø0T.ø%À..ÿÿ
    ....

    In this case the BASE is outside the memory area displayed and therefore
    highlighted with color 3. The CURRENT ADDRESS is $07E00900.
@endnode
@node "Moving through memory"


    MOVING THROUGH MEMORY
    =====================

    <addr>

    After input of an address the memory area starting with this address
    will be shown. Additionally the address becomes the new BASE.
    Addresses must be given as hexadecimal values. Don't use a leading '$'.
    Illegal addresses that are those which are not in ROM or in Exec's
    memory lists will not be accepted if MemCheck (default) is on. You'll
    get the message @{fg fill} dangerous address@{fg text}. The MemCheck can be turned
    off with '!'. See below.

    +/-<offs>

    Offsets differ from addresses by the sign. They are interpreted as hexa-
    decimal values as long as you don't use the prefixes '_' for decimal
    and '%' for binary. For example an offset of 12 can be given as +c (hex),
    +_12 (dec) or +%1100 (bin).
    If you want to go back to the BASE, type + or +0.

    return, - return

    By pressing the Return-Key the next 256/128 bytes of memory will be shown,
    and OMon will go back 256/128 bytes if you enter '-' + Return. The BASE
    will not be changed but the offset and the CURRENT ADDRESS.

    ATTENTION:
    If you are in search mode or in disassamble mode the effect of pressing
    Return is to continue the respective operation. These modes are indi-
    cated by different prompts (dis-> and s->).

    .	<- This is a point

    The CURRENT ADDRESS becomes the new BASE. Memory will be displayed new
    starting at the new BASE.

    > [offs]

    If no offset has been entered ('>' only) the longword at CURRENT ADDRESS
    will be interpreted as pointer (APTR) and the OMon will jump to the
    address the pointer points at.
    If an offset has been entered additionally this will be added to the
    BASE and the longword at the calculated address will be interpreted as
    pointer. Example:

    You have jumped to a window structure and you like to see the rastport
    structure of this window. The pointer to the rastport is at offset +$32.
    Input: >32	or >+32 (decimal: >_50 or >+_50).

    Pointer are allways at even addresses. If you try to use a longword at
    odd address as pointer an error message will appear.

    >> [offs]

    Does nearly the same as the foregoing command but the longword at
    CURRENT ADDRESS will be interpreted as BPTR. That means it will be
    multiplicated by 4. BPTRs are common in DOS structures. In structures
    displayed by the help command, e.g. by 'h dos', BPTRs are marked by '²'.

    <

    Jumps to the previously used base address. OMon remembers the last
    10 BASEs by saving them in a buffer. By repeatedly pressing '<'
    they can be accessed one after the other.

    mark [0-9] [<note>]

    This command can be used to save the current position in memory and
    to jump back to this address later with 'goto n'. Optionally you can
    type a short note (up to 26 chars) behind the number which characterizes
    the marked area (e.g. mark 1 WBScreen). This note will be displayed when
    you jump to the mark again.
    'mark' without any argument shows a list of all marks currently set
    including their notes.

    goto <n>

    Goes to mark n (0-9) if mark n has been set before otherwise an error
    message will occur. 'goto' can be abbreviated by 'g'.
@endnode
@node "Lists"


    LISTS
    =====

    To display one of the system lists one of the folling abbreviations
    have to be typed:

	cat=Catalogs	dl=DeviceList	dt=DataTypes	fse=FilSysEntry
	in=InputHandler i=Interrupts	k=KeyMaps	l=Libraries
	m=Memory	mon=Monitors	p=Ports 	r=Resources
	rc=ResCmds	re=Residents	sm=Semaphores	scm=ScrModes
	t=Tasks/Procs	tf=TextFonts	tr=TimeRequests v=De[v]ices
	w=Windows/Screens

    Each list starts with a header containing the name of the list. The lists
    of libraries, devices, resources, tasks and textfonts show additionally
    the number of elements (nodes). If a list is longer than can be
    displayed in the window output will be stopped and you have to press
    return to continue output.

    ANNOTATIONS TO SOME LISTS

    Each entry starts with the address of the structure and its name.
    Some lists contain additional information which will be explained now:

    @{fg fill}Catalogs@{fg text} (cat)
    Shows a list of currently loaded catalogs maintained by locale.library.
    OS V38+ is needed to get this list. In order to access the list OMon
    calls OpenCatalogA (sys/c.catalog). This catalog should be installed
    in Locale:catalogs/<language>/.

    @{fg fill}DeviceList@{fg text} (dl)
    The entries are sorted in the order volumes, assigned directories and
    devices. Volumes and devices have additional information about their
    handlers, directories about their locks (APTR). If to an assigned
    dirctory, e.g. LIBS:, other directories have been added by 'assign add'
    this is marked by a corresponding number of +-signs behind the name.
    If you enter the name of the device node, e.g. 'dl libs', you will see
    which directories these are.

    @{fg fill}KeyMap@{fg text} (k)
    Shows KeyMapNodes which are attached to a KeyMap.

    @{fg fill}Libraries, Devices, Resources@{fg text} (l, v, r)
    Each entry contains the following information:
    Name, OpenCount, number of subroutines (LVOs), type (ROM or loaded from
    Disk) and version.revision.
    There are some resources which have no library structure and therefore
    no LVOs.

    @{fg fill}Memory@{fg text} (m)
    Apart from types of memory managed by the memory list the address room
    of ROM is shown. After that comes information (address, length in bytes)
    about the files which have been loaded into memory by 'help' or 'load'
    if there are any.

    @{fg fill}Monitors@{fg text} (mon)
    Displays the list of MonitorSpec structures from GfxBase.

    @{fg fill}Tasks@{fg text} (t)
    Shows all tasks and processes of the TaskWait list and ThisTask (allways
    OMon). For each task priority, stack size and stack used are given.
    For processes additionally the number of hunks is given. In case of
    CLI processes the name in the CLI structure is appended in [].

    @{fg fill}TextFonts@{fg text} (tf)
    Additionally X and Y sizes of characters, LoChar, HiChar, Style, Flags
    with font type (fixed or proportional) and OpenCount are shown.

    @{fg fill}Windows und Screens@{fg text} (w)
    Shows all screens and immediatly after each screen the windows which
    are on this screen. In () are the values for x- and y-Position, width
    and height. For screens additional information about depth and ModeID
    is given, for windows the number of system and user gadgets and the
    number of menus.
    Nameless windows are marked by the string '----' and by the name of the
    task in [] which opened the window.

    @{fg fill}Resident Commands@{fg text} (rc)
    If you enter 'rc' without a program name the list of resident programs
    with their "UserCount" is displayed. 'rc <name> shows the address of
    the Segment structure for that program. You can get the offsets of the
    Segment structure by entering 'h dos'.

    @{fg fill}TimeRequests@{fg text} (tr)
    Shows without argument the list of tasks which have opened the
    timer.device. All 5 Units of timer.device are shown but in most cases
    only Unit VBLANK in use. With argument (task name) the TimeRequest
    structure for that task is shown.

    @{fg fill}Datatypes@{fg text} (dt)
    Shows a list of datatype structures which is maintained by datatypes-
    .library internally. The datatype structure starts with two nodes
    (node1, node2) which belong to different lists. OMon uses the node2-
    list because only this list contains all datatypes.

    When calling 'dt' for the first time OMon has to find the beginning of
    the node2 list. Therefor the datatypes.library must be opened and a
    ObtainDataTypeA() is performed. This causes some disk activities.
    After that calls of 'dt' are silent and faster.
@endnode
@node "Jumping to structures"


    JUMPING TO STRUCTURES WITHIN A LIST
    ===================================

    <list> [<structname>] [n]

    In order to jump to a structure within a list you have to enter the
    abbreviation of the list (e.g. l for libraries) and append the first
    char(s) of the structure name (case sensitive).

    EXAMPLE:  If there are two libraries which start with the same char,
	      e.g. asl.library and arp.library, 'l a' will show the the
	      first library which begins with char 'a', 'l ar' will show
	      the arp.library structure and 'l as' will show asl.library.

    In those cases where two structures in a list have the same name or
    are without a name you have additionally to enter the position n within
    this list. Examples:
    'w "" 1' shows the first nameless window of the window list
    'w "" 2' shows the second nameless window of the window list
    'l a 2' shows the second library structure starting with 'a'

    If a wanted structure has been found OMon shows the full name of this
    structure and after that the memory area where the structure starts.

    The following structures have some peculiarities:

    @{fg fill}Windows@{fg text}
    IDCMP and WFLG flags including some flags set by Intuition are displayed
    behind the window name. The same is true for Screens.

    @{fg fill}Libraries, Devices, Resources@{fg text}
    The ID string is shown if present.

    @{fg fill}Memory@{fg text}
    By entering 'm rom' or 'm r' you can jump to ROM allthough it is not
    present in the memory lists.
@endnode
@node "Mixed"


    MIXED
    =====

    x,q

    OMon exits. The allocated memory is freed and the files which are still
    open (output file , help file) will be closed automatically.

    *

    Switches memory display from 8 lines (128 bytes) to 16 lines (256 bytes)
    and reverse.

    !

    Switches MemCheck on/off. The default is ON.
    OMon normally displays memory areas only which are registrated in the
    exec memory lists or in ROM. The legal memory areas are shown with 'm',
    e.g.

    MEMORY
    07000000 expansion memory	07000020-08000000 16383 K
    00001000 chip memory	00001020-00200000 2043 K
    -------- ROM (not in list)	00F80000-01000000  512 K

    To access other memory can be dangerous and cause a guru. You should
    know what you do after switching MemCheck off! You can look at address 0
    by the way without switching MemCheck off.

    cls

    Clears the diplay.

    exe(cute) <cmd>

    Executes a program. You may use 'exe' or 'execute'. Any output of the
    executed program which normally would go to the shell window is redirected
    to OMon's window.
    Programs are started "sychronously" . That means you cannot continue to
    work with OMon as long as the started command is still busy. If you
    want a command to be started asynchronously you have to use 'run'.

    Example: exe run >nil: c:next docs/dme.doc

    o<outfile>

    The output of OMon will be saved to a file, too. The name of the output
    file has to be entered behind the 'o'. After that the default promt
    changes to 'o->' which indicates that a file is open. To close it again
    simply type 'o'.

    list [<name>]

    Works like the list command though the output is simpler.

    segm <process>

    This command jumps to first segment of a process which must be in the
    task list. The first longword of a segment is a BPTR to the next
    segment or null if there is no next segment. You can jump to the next
    segment by entering '>>'.

    cu [n]

    Shows the list of ConUnits which are numbered. To get a special ConUnit
    the number of this unit has to be entered additionally.

    tdu [n]

    Shows the list TDUPublicUnits maintained by trackdisk.device.
    There are as many entries in the list as there are drives attached
    to your Amiga. When entering a number n (0-3) the unit of drive dfn:
    will be shown.

    i [<name>] [n]

    Shows the IntVect data structures of ExecBase like this:

    INTERRUPT Level Pri  Type	  H/S	   Name
    1000374A	1     0  DISKBLK  Handler  disk.resource
    1000350A	3   120  PORTS	  Server   ciaa.resource
    100003B0	3    20  PORTS	  Server   UAE filesystem
    10003D4E	5    10  VBLANK   Server   graphics.library
    10008638	5     0  VBLANK   Server   gameport.device
    1000877A	5     0  VBLANK   Server   timer.device
    10003D7A	6     0  BLITTER  Handler  graphics.library
    10003760   12     0  DISKSYN  Handler  disk.resource
    100035AA   13   120  EXTERN   Server   ciab.resource

    Following informations are given behind the interrupt address:
    interrupt level (0-13), priority, type, handler/server and
    nodename.
    In order to jump to a special interrupt structure you have to append
    the name of the structure wanted. If there are more than one entry
    with the same name you have to enter the position n after the name.
    Example: 'i gra 2' jumps to the second interrupt structure with name
    'graphics.library'.

    cli [n]

    Presents the currently running CLI processes and their numbers.
    After entering 'cli n' the CLI structure with number n will be shown.

    lock [address]

    This command checks whether there is a FileLock structure at the
    address given or at CURRENT ADDRESS if no address has been given.
    The output is lock type, file type (file/directory) and path.

    locks

    Shows the addresses (APTR) of all locks and their paths. The paths
    may be abbreviated due to lacking space. This will be indicated by
    a '*' behind the volume name. Locks of type ACCESS_WRITE are indicated
    by 'w', unknown locks by '?'. All others are of type ACCESS_READ.

    locale

    Shows the locale structure for the language defined in locale.prefs.
    OS V38+ is needed. You can get the most interesting offsets into this
    structure by entering 'hloc'.

    obtaindt <file>

    Shows the DataType structure for the file <file>. OS V3+ is needed.

    drive [<drive>]

    Without an argument a list of drives mounted is shown with various
    informations, e.g. date of creation and filesystem. The following
    filesystems are recognized:

    OFS     Old  FileSystem
    FFS     Fast FileSystem
    OFS_int OFS  international
    FFS_int FFS       "
    OFS_dc  OFS  directory cache
    FFS_dc  FFS       "

    If you enter the name of a drive additionally the corresponding
    DosEnvec structure is displayed. The offsets of this structure are
    displayed with 'he'.

    chunks

    Gives information about fragmentation of memory. For each type of
    memory (chip, expansion) the number of MemChunks arranged by size
    are presented in a table. Chunks larger than 256K are summarized under
    'other'. Example:

   0.5K  4K  32K 256K  other sum   largest   free    used
   --------------------------------------------------------
     98   5    2    0	 2   107   29399 K  30234 K  2534 K  expansion memory
      3   0    1    0	 1     5    1965 K   1975 K    69 K  chip memory

    The numbers beneath the sizes indicate how many chunks exist up to
    this size, e.g. there are 5 chunks with more than 0.5K and not more
    than 4K in expasion memory, 0 chunks of this size in chip memory.

    flush

    Works like "avail flush". All libraries, devices, fonts etc. which are
    not in use will be removed from memory. After that the gain of memory
    is displayed. Sometimes you have to repeat this command in order to
    flush memory completely.

    savemem <name>

    Saves the memory block between the first two marks to the file <name>.

@endnode
@node "Help"


    HELP
    ====

    h<struct>

    This command activates the online help of OMon. 'h' without argument
    gives a survey over the the structures for which online help is
    available.

HELP		Usage: h<struct>
cli=CLI 	dl=DeviceList	dt=DataType	dos=DosStructs	e=Envec
exe=ExecBase	gfx=GfxBase	i=Interrupt	int=IntBase	io=Request
k=KeyMap	l=Library	ln=List/Node	loc=Locale	m=Memory
mp=Message/Port rm=ResModules	rp=RastPort	sc=Screen	segm=Segment
sm=Semaphore	t=Task/Process	tf=TextFont	u=Unit		w=Window

    Appending the shortcut of a structure to 'h' gives information about
    the offsets (hex values) in this stucture. At offsets with index ² are
    BPTRs. The number in [] is the length of the structure (hex).

    EXAMPLE:

    -> hdos  (dos structures)

    @{fg fill}DOS [36]@{fg text}  RootN22 GlVec26 Err's36@{fg fill} DInfo[14]@{fg text}²DevInfo04
    @{fg fill}ROOT[20]@{fg text} ²TskAr00²ConSg04 Stamp08²ReSeg14²DInfo18²FHSeg1C
    @{fg fill}LOCK[14]@{fg text} ²Link.00 Key..04 Acces08 Task.0C²Volum10
    @{fg fill}RES [10]@{fg text} ²Next.00 UC...04²Seg..08 Name.0C

    -> hw    (window offsets)

    @{fg fill}WIND[84]@{fg text}  NxtWd00 LEdge04 Width08 MousY0C MinW.10 MaxW.14 Flags18
	      MenuS1C Title20 1stRq24 DMReq28 WScr.2E RPort32 BLeft36
	      BTop.37 1stGd3E IDCMP52 UPort56 WPort5A IMsg.5E IFont80

    After the name of the structure (colored) follows in [] its length (hex)
    and the offset names, often heavily abbreviated. Due to place restrictions
    only the most interesting offsets are shown.

    help <helpfile>

    Apart from online help which is build in a text file can be loaded
    which contains additional information, e.g. about LVOs, constants,
    stucture offsets etc.. You can search within this file with the command
    'sh' for the data you need.

    It is possible to load another help file, the previous one will then
    be removed from memory. Typing 'help' without filename removes the
    current help file.
@endnode
@node "Search"


    SEARCH
    ======

    s[-] "string"|<hexval>

    Search can be done forward with 's' and backward with 's-'. You can
    either search for a hex value or for a string (cs). A string must be
    enclosed in quotation marks or it must contain signs other than 0-9
    and a-f.

    Examples:
    s dead	    ;searches for hex value $dead
    s "dead"        ;searches for the string 'dead'
    s library	    ;searches for the string 'library'

    When search has been started by return OMon looks for the hex value/
    string in the next 128K of memory starting at CURRENT ADDRESS and
    display the memory area if succesful otherwise the address up to which
    search has gone. The prompt is changed to 's->' in search mode and
    search can be continued simply by pressing return. Search stops auto-
    matically if an illegal memory area is reached. Search mode can be
    finished by entering another command or by 's' without an argument.

    Search doesn't alter the BASE.

    sh <string> | more	(sh=search help)

    With this command you can serarch for ascii strings in a help file
    which must be loaded before (see help command). It is not necessary
    to put the string you look for in quotation marks.
    In case of succesful search the line that contains the string and
    the two following lines are displayed. If you want to see the following
    three lines type 'more'. Search is continued by return and finished
    by 'sh' or another command.

    ss <LVO>	      (ss=search for subroutine)

    This command is useful for finding calls to library subroutines in
    program code with the general format:

    jsr libraryvectoroffset(a6)

    After 'ss' you have to enter the library vector offset in hex. It's
    not nessecary to place a '-' before the LVO because they are always
    negative. If you only know the decimal LVO place a '_' in front of the
    LVO.

    EXAMPLE:

    The LVO of AllocMem() in exec.library is -198 (decimal). To look for
    calls to AllocMem you may enter

    ss _198 or ss-_198 or ss c6 or ss -c6

    If found you can disassemble the program code which results in

    jsr  -$C6(a6)

    Be aware that this must not be a call to AllocMem() because a6 may
    contain another library base than that of exec. You have to disassemble
    the preceeding code to be shure. If then appears a line like
    'move.l 4,a6' you can be shure that it is a call to AllocMem().
@endnode
@node "Loading a program"


    LOADING A FILE INTO MEMORY
    ==========================

    load <name>

    This command copies the file with name <name> into memory and then shows
    the beginning of this memory area. If the file is a program you can now
    search with 'ss' for calls to library subroutines, search for strings
    with 's' or disassemble the code. It's also possible to modify the code.

    As long as OMon displays a memory area that is occupied by the loaded
    file the status line shows the name of the file, the current offset
    (hex), file length and position in %.

    'load' without an argument unloads the file and frees memory occupied.
    If you forgot the name of the file you loaded type 'm'.

    first

    Jumps to the beginning of the loaded file.

    last

    Jumps to the last longword of the loaded file

    saveas <path>

    Saves the loaded file with the name and path given. This is useful
    after you have modified the file in memory and want to check the result.
@endnode
@node "Modifying memory"


    MODIFYING A MEMORY AREA
    =======================

    mod "string"|<hexval>

    The string or hex value is written into memory at CURRENT ADDRESS.
    After that the memory area at CURRENT ADDRESS is displayed again
    showing the modification highlighted. There will be as many bytes
    written to memory as the string or hex value you entered is long.
    Since overwriting memory can be dangerous you'll be asked before
    wether you really want to write at address $xxxxxxxx. Press return
    to do it.

    This command is useful i.e. to patch a program or other binary files
    after they have been loaded by the 'load' command.
    Examples:	mod 00 writes one byte with value $00 at CURRENT ADDRESS
		mod "hallo" write 5 bytes beginning at CURRENT ADDRESS

@endnode
@node "Conversion of numbers"


    CONVERSION OF NUMERICAL VALUES
    ==============================

    '#' introduces instructions for converting a BYTE, WORD or LONG
    to hexadecimal, binary, decimal and ascii values.

    #, #l

    Convertes 4 bytes (1 LONG) at CURRENT ADDRESS. Memory is NOT altered
    by this operation.

    #b, #w

    Same as above. '#b' converts only the first byte at CURRENT ADDRESS,
    '#w' converts two bytes.

    #<<

    Converts the LONG at CURRENT ADDRESS after multiplying it by 4.
    BPTRs can be converted to APTRs in this way. Memory is NOT altered.

    #>>

    Like above, but division by 4. APTRs are converted to BPTRs.

    #"ascii"

    Converts a string consisting of max. 4 chars.
    Example: -> #"DOS"
    Output: $00444F53  %00000000_01000100_01001111_01010011  4476755  ".DOS"

    #[b|w|l][+/-][_|%][<val>]

    Converts a numerical value <val>.
    b = byte w = word l = long word
    _ = decimal % = binary

    Examples:
    -> #b10	Output: $10  %00010000	16/16  "."
    -> #b_10	Output: $0A  %00001010	10/10  "."
    -> #b-_10	Output: $F6  %11110110	246/-10  "ö"
       #wde	Output: $00DE  %00000000_11011110  222/222  ".Þ"
       #ldead	Output:
       $0000DEAD  %00000000_00000000_11011110_10101101	57005  "..Þ­"
       #"dead"  Output:
       $64656164  %01100100_01100101_01100001_01100100	1684365668  "dead"
@endnode
@node "Disassembling"


    DISASSEMBLING
    =============

    dis [<addr>]

    Disassembles memory starting at CURRENT ADDRESS or at address <addr>.
    You are in disassemble mode now, indicated by the prompt.
    16 lines of assembly code are produced each time you press return.
    You can disassemble backwards by entering '-' + return. OMon then
    goes 32 bytes back before disassembling.
    Going back may produce one or two incorrect lines if disassembling starts
    within a processor instruction.
    You can leave the disassembly mode by entering 'dis' or another command.

    dis <addr> <addr>

    Disassembles from first address to second address. The first one should
    be lower than the second one, of course.
    Output goes into the OMon window or if an output file has been opened
    before with 'o <outfile>' to that file. Disassembling to a file is
    much faster. Disassembling can be stopped by CTRL-C.

    dis +<length>

    Disassembles of length <length> starting at CURRENT ADDRESS. <length>
    must be a hex value.
    Example: dis +1000	 ; disassembles $1000=4096 bytes of memory.

    This command can be used to disassemble a whole program:
    1. load <program>
    2. o ram:program.dis
    3. dis +<program length>
    4. o
@endnode
@node "Author"

					Jürgen Klawitter
					Südendstraße 28
					12169 Berlin
					klawitter.juergen@berlin.de
@endnode
