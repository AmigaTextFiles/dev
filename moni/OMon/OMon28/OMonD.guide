@database "OMonD.guide"
@node "main"


				    OMON V2.8

			(c) 1994-2011 by Jürgen Klawitter

				    FREEWARE

	@{" Zweck                 " link "Zweck"}
	@{" Aufruf                " link "Aufruf"}
	@{" Befehlsübersicht      " link "Befehlsübersicht"}
	@{" Grundsätzliches       " link "Grundsätzliches"}
	@{" Bewegen im Speicher   " link "Bewegen im Speicher"}
	@{" Listen                " link "Listen"}
	@{" Strukturen anspringen " link "Strukturen anspringen"}
	@{" Diverses              " link "Vermischtes"}
	@{" Hilfe                 " link "Hilfe"}
	@{" Suchfunktionen        " link "Suchfunktionen"}
	@{" Datei laden           " link "Datei laden"}
	@{" Speicher modifizieren " link "Speicher modifizieren"}
	@{" Zahlenwerte umrechnen " link "Zahlenwerte umrechnen"}
	@{" Disassemblieren       " link "Disassemblieren"}
	@{" Autor                 " link "Autor"}

@endnode
@node "Zweck"

    ZWECK
    =====

    OMon ist ein vielseitig verwendbarer Speicher- und Systemmonitor, der
    sich vor allem zum Auffinden und Untersuchen von Strukturen eignet.

    OMon kann auch disassemblieren, Speicherbereiche modifiziern und als
    Filemonitor eingesetzt werden.

    Einige Features:
	- Adresseingaben weitgehend überflüssig, da Strukturen und Listen
	  über ihre Namen bzw. deren Anfangsbuchstaben gefunden werden

	- Neben den üblichen Strukturen (Task, Library, Window...) sind
	  auch eine Reihe von ungewöhnlichen Strukturen zugänglich:
	  Locale, Catalog, Datatype, MonitorSpec, ConUnit, TDUPublicUnit

	- Pointer in Strukturen (APTR, BPTR) können genutzt werden, um
	  die Adressen anzuspringen, auf die sie zeigen

	- Offsets für über 35 gängige Strukturen, insgesamt 3.6 Kb, ins
	  Programm eingebaut und leicht abrufbar. Daher übrigens der Name:
	  OMon = OffsetMonitor

	- beliebige externe Hilfsdateien, z.B. LVO-Listen, includes etc.
	  können geladen und nach Begriffen oder Daten durchsucht werden

	- ziemlich absturzsicher, da das Auslesen gefährlicher Speicher-
	  bereiche, z.B. Adressen der Customchips, durch eine MemCheck-
	  Funktion verhindert wird (kann bei Bedarf abgeschaltet werden)

	- sehr schnelle Suchfunktion (Boyre-Moore)

	- läuft ab OS 2.0 (V36+)

	- ist pure, kann resident gemacht werden

	- in Assembler programmiert, dadurch flott und handlich
@endnode
@node "Aufruf"


    AUFRUF
    ======

    OMon kann von der Workbench oder der Shell gestartet werden. Beim Start
    von der Shell kann als Argument ein Befehl angegeben werden (siehe
    folgende Übersicht). Befehle, die Voraussetzungen benötigen, die erst
    nach Programmstart erfüllt sind  (z.B. Offseteingaben), sollten nicht
    angegeben werden. Es kommt dann eine Fehlermeldung.

    Ohne Argument wird nach Start die TaskWait-Liste angezeigt.
@endnode
@node "Befehlsübersicht"


    BEFEHLSÜBERSICHT
    ================

    OMon ist nicht gerade arm an Befehlen. Hier eine Übersicht, die auch
    bei Eingabe von '?' angezeigt wird:

    MOVE			    HELP
    <address>, +/-<offset>, return  ?, h [<structure>]
    > <offset> , >> <offset>	    help <helpfile>
    <, -, ., g=goto <mark>	    FILE
    mark [0-9] [<note>] 	    load <file>, first, last
    SEARCH			    saveas <file>
    s[-] "<string>" | <hexvalue>    CONVERT
    ss <LVO>			    #<<, #>>, #"ascii"
    sh <string>, more		    #[b,w,l][-][_,%%][<value>]
    VARIOUS			    DISASSEMBLE
    *, !, cls, o <outfile>	    dis [<address>] | +<length>
    exe <cmd>, list [<file/dir>]    dis <address> <address>
    segm <proc>, cli [n]	    MEMORY
    cu [n], tdu [n]		    chunks, flush, savemem <file>
    locks, lock [<address>]	    MODIFY
    drive [<drive>]		    mod "<string>" | <hexvalue>
    locale, obtaindt <file>	    EXIT with q or x

    LISTS	    Usage: <list> [<name>] [n]	    cat=Catalogs
    dl=DeviceList   dt=DataTypes    fse=FilSysEntry in=InputHandler
    i=Interrupts    k=KeyMaps	    l=Libraries     m=Memory
    mon=Monitors    p=Ports	    r=Resources     rc=ResCmds
    re=Residents    sm=Semaphores   scm=ScrModes    t=Tasks/Procs
    tf=TextFonts    tr=TimeRequests v=De[v]ices     w=Windows/Screens

    Das wirkt vermutlich ziemlich verwirrend. Aber nicht abschrecken
    lassen! Dann erschließen sich nach und nach die vielseitigen
    Möglichkeiten dieses Programms.
    Die Bedeutung der einzelnen Kommandos wird nachfolgend erläutert.
    Zunächst aber @{"Grundsätzliches" link "Grundsätzliches"}...
@endnode
@node "Grundsätzliches"


    GRUNDSÄTZLICHES
    ===============

    OMon öffnet beim Start ein CON-Window, sodass die Ediermöglichkeiten
    und die History-Funktion des jeweiligen Console-Handlers genutzt
    werden können.

    Voreinstellungsmäßig wird vom Speicher ein Ausschnitt von 128 Bytes
    (8 Zeilen zu je 16 Bytes) gezeigt. Durch Eingabe von '*' kann aber
    auf 16 Zeilen (256 Bytes) umgeschaltet werden. Die Darstellung des
    Speichers ist wie folgt:

		   Offset
	    Zeilen AKTUELLE
    BASIS   Offset ADRESSE    Speichername	      ASCII-Darstellung
      |        |     |		   |			      |
      v        v     v		   v			      v
    07E007EC	 +00000000 expansion memory
    07E007EC: 000 07E2F2B8 00000A6C 099C00F8 008F0400 .âò¸...l...ø....
    07E007FC: 010 032A0278 0027002F 00F8009C 409D0000 .*.x.'./.ø..@...
    07E0080C: 020 0001006A 0000F81F F8130000 00000000 ...j..ø.ø.......
    07E0081C: 030 00000000 000007E0 226807E0 0A680020 .......à"h.à.h.
    07E0082C: 040 000000F8 33CA0000 00000000 00000000 ...ø3Ê..........
    07E0083C: 050 00009DF1 00000000 00000000 00000000 ...ñ............
    07E0084C: 060 07E0344C 00F91D34 07E0349A 00000000 .à4L.ù.4.à4.....
    07E0085C: 070 00F81784 00000000 07E00020 00F81706 .ø.......à. .ø..
    ....

    Die oberste Zeile enthält einige Statusinformationen. Von links nach
    rechts:

	- BASIS     Adresse, auf die sich angezeigte bzw. eingegebene
		    Offsets beziehen

	- Offset AKTUELLE ADRESSE
		    Gibt den Offset der sog. AKTUELLEN ADRESSE an, auf die
		    sich verschiedene Befehle von OMon beziehen. Der
		    Zusammenhang ist: BASIS + Offset = AKTUELLE ADRESSE
		    Im Gegensatz zur BASIS befindet sich die AKTUELLE ADRESSE
		    immer im angezeigten Speicherbereich.
		    Der Offset ist ein vorzeichenbehaftetes Langwort.
		    Ist er 0, sind BASIS und AKTUELLE ADRESSE identisch.
		    Folgende Kommandos beziehen sich auf die AKTUELLE
		    ADRESSE:  #, >, >>, ., mod <"string">|<hexval> und dis.
		    Sie werden weiter unten noch ausführlich erläutert.

	- Speichername
		    Hier kann auch 'chip memory' oder 'fast memory' stehen.
		    Falls der angezeigte Speicherbereich nicht in den von
		    Exec verwalteten Listen auftaucht, steht hier 'ROM' oder
		    "not in memlist". Letzteres gilt z.B. für private Speicher-
		    bereiche des Systems.

    Wenn der Speicher an der AKTUELLEN ADRESSE nicht belegt ist, folgt nach
    dem Speichernamen die Meldung @{fg back}@{bg text}  free  @{fg text}@{bg back}, ansonsten ist er belegt.
    Ein Spezialfall liegt vor, wenn die AKTUELLE ADRESSE der Beginn eines
    freien Speicherblocks ist. Hier steht dann eine 8 Byte lange MemChunk-
    struktur, die sich aus einem Zeiger auf den nächsten freien Block und
    einer Längenangabe im zweiten Langwort zusammensetzt.
    Die Anzeige sieht dann etwa so aus:

    07E30678	 +00000000 expansion memory  @{fg back}@{bg text}MemChunk@{fg text}@{bg back}
    07E30678: 000 07E306C0 00000008 20202020 20202020 .ã.À....
    07E30688: 010 2D2D2D2D 2D2D2D2D 00000000 00000000 --------........
    07E30698: 020 00000000 00000000 00000014 00000003 ................
    ....
    Im Beispiel beginnt der nächste freie Speicherblock also ab Adresse
    $07E306C0, Der aktuelle Block ist 8 Bytes lang, umfasst also nur die
    MemChunk-Struktur selbst.


    Unter der Statuszeile folgen die hexadezimalen Adressen der einzelnen
    Zeilen. Rechts davon stehen die Zeilen-Offsets in Bezug zur BASIS, eben-
    falls hexadezimal. Da aus Platzgründen nur 3 Bytes für die Zeilenoffsets
    zur Verfügung stehen, sind hier nur Werte bis max. $FFF darstellbar.
    Danach geht's wieder bei $000 los.
    Nach Eingabe eines Offsets (wird gleich erklärt) wird dieser zur BASIS
    addiert und der Speicherbereich, in dem der Offset liegt, wird angezeigt.
    Die 4 Bytes ab Offset werden farbig hervorgehoben.

    BEISPIEL: Offset +114


    @{fg fill}07E007EC@{fg text}      +00000114 expansion memory
    07E008EC: 100 00000000 00000000 07E00060 00F81706 .........à.`.ø..
    07E008FC: 110 00000000 @{bg shine}07E51178@{bg back} 0003594A 0000E077 ....@{bg shine}.å.x@{bg back}..YJ..àw
    07E0090C: 120 00040004 0000FF00 00070000 07E00410 ......ÿ......à..
    07E0091C: 130 00F83054 00F83054 00F825C0 0000FFFF .ø0T.ø0T.ø%À..ÿÿ
    ....
    Die BASIS liegt nicht mehr im angezeigten Speicherbereich (deshalb farbig
    hervorgehoben), die AKTUELLE ADRESSE ist 07E00900.
@endnode
@node "Bewegen im Speicher"


    BEWEGEN IM SPEICHER
    ===================

    <address>

    Bei Eingabe einer Adresse wird zu der entsprechenden Stelle im Speicher
    gesprungen. Sie wird zugleich zur neuen BASIS. Adressen müssen immer
    als Hex-Werte (OHNE führendes '$') angegeben werden.
    Illegale Adressen, also solche, die nicht in den Speicherlisten vorkommen
    oder nicht im ROM liegen, werden bei eingeschaltetem MemCheck (default)
    mit der Meldung @{fg fill} dangerous address@{fg text} abgewiesen. Der MemCheck kann
    aber mit '!' abgeschaltet werden (s.u.).

    +/-<offset>

    Offsets unterscheiden sich von Adressen durch das Vorzeichen. Sie werden
    ebenfalls als Hex-Werte interpretiert. Durch Voranstellen der Präfixe '_'
    und '%' kann man aber auch Dezimal- bzw. Binärwerte eingeben.
    Ein Offset von +12 kann z.B. eingegeben werden als +c (hex), +_12 (dez)
    oder +%1100 (bin).
    Offsets verändern die BASIS nicht. Wie bereits oben erläutert, wird nach
    der Eingabe der entsprechende Speicherbereich angezeigt. Um zur BASIS
    zurückzugelangen, gibt man + oder +0 ein.

    return, - return

    Durch Drücken von Return (ohne Eingabe) bewegt man sich im Speicher
    um 128 Bytes/256 Bytes weiter, bei vorangestelltem '-' um diesen Betrag
    zurück. Die BASIS wird in beiden Fällen nicht verändert, wohl aber der
    Offset und damit auch die AKTUELLE ADRESSE.
    ACHTUNG: Befindet man sich in einem der Suchmodi oder im Disassemblier-
    modus, wird weitergesucht bzw. -disassembliert. Return bedeutet aber
    auch hier so viel wie "Weitermachen". Der jeweilige Modus ist am Aussehen
    des Prompts zu erkennen (z.B. dis-> im Disassembliermodus).

    .	<- Das soll ein Punkt sein

    Macht die AKTUELLE ADRESSE zur neuen BASIS. Der Speicher wird ab dieser
    Adresse neu angezeigt.

    > [offset]

    Wenn kein Offset angegeben wurde, wird das Langwort ab AKTUELLER ADRESSE
    als Pointer (APTR) interpretiert und zu der Adresse gesprungen, auf die
    der Pointer zeigt. Wurde ein Offset angegeben, wird dieser zur BASIS
    addiert und das Langwort an der so berechneten Adresse als Pointer inter-
    pretiert. Beispiel:

    Man hat mit 'w <name>' eine Windowstruktur angesprungen und will nun
    den RastPort sehen. Der Zeiger auf den RastPort befindet sich bei Offset
    +$32. Eingabe: >32 oder >+32  (dezimal >_50 bzw. >+_50)

    Pointer liegen immer an geraden Adressen. Sollte die AKTUELLE ADRESSE
    ungerade sein, wird eine entsprechende Fehlermeldung ausgegeben.

    >> [offset]

    Macht fast dasselbe wie der vorherige Befehl, nur wird das jeweilige
    Langwort als BPTR interpretiert, also mit 4 multipliziert. BPTR tauchen
    in diversen DOS-Strukturen auf. Sie sind in der Online-Hilfe für
    DOS-Strukturen als solche durch eine '²' gekennzeichnet.

    <

    Springt zu zuletzt benutzten Basisadresse zurück. OMon speichert die
    letzten 10 BASEN in einem Rundpuffer. Mit '<' können sie zyklisch an-
    gesprungen werden.

    mark [0-9] [<note>]

    Mit diesem Befehl kann man sich die aktuelle Position im Speicher merken
    und später mit 'goto n' dahin zurückspringen. Optional kann man eine bis
    zu 26 Zeichen lange Bemerkung (note) eingeben, die den gemerkten Speicher-
    bereich charakterisiert (Strukturbezeichnung o.ä.). Mit 'mark' alleine
    wird eine Liste der markierten Adressen mit ihren notes ausgegeben.

    goto <mark>

    Springt zur angegebenen Marke (Ziffern 0-9), falls bereits eine Marke ge-
    gesetzt wurde und gibt ggf. die Bemerkung (note) zu dieser Marke aus.
    Statt 'goto' kann auch 'g' eingegeben werden, z.B. 'g1'.
@endnode
@node "Listen"


    LISTEN AUSGEBEN
    ===============

    Um sich eine Liste ausgeben zu lassen, reicht es, eine der folgenden
    Listenabkürzungen einzugeben:

	cat=Catalogs	dl=DeviceList	dt=DataTypes	fse=FilSysEntry
	in=InputHandler i=Interrupts	k=KeyMaps	l=Libraries
	m=Memory	mon=Monitors	p=Ports 	r=Resources
	rc=ResCmds	re=Residents	sm=Semaphores	scm=ScrModes
	t=Tasks/Procs	tf=TextFonts	tr=TimeRequests v=De[v]ices
	w=Windows/Screens

    Jede Liste beginnt mit einer Kopfzeile mit Listenname etc. Bei den meisten
    Listen ist hinter dem Namen die Zahl der Listenelemente (Nodes) angegeben.
    Mitunter enthält eine Liste mehr Elemente als ins Fenster passen.
    Die Ausgabe wird dann angehalten und erscheint in der untersten Zeile die
    Meldung 'press return to continue'.

    ANMERKUNGEN ZU EINZELNEN LISTEN

    Jeder Eintrag beginnt mit Strukturadresse und Strukturnamen. Einige
    Listen enthalten zusätzliche Informationen, die nachfolgend kurz erklärt
    werden.

    @{fg fill}Catalogs@{fg text} (cat)
    Zeigt eine von der locale.library verwaltete Liste der momentan gespei-
    cherten Kataloge. OS V38+ ist erforderlich. Um auf diese Liste zugreifen
    zu können wird beim ersten Aufruf ein OpenCatalogA (sys/c.catalog) aus-
    geführt. Der angegebene Katalog muss sich in Locale:catalogs/<language>/
    befinden.

    @{fg fill}DeviceList@{fg text} (dl)
    Die Einträge sind in der Reihenfolge Volumes, "assignte" Directories und
    Devices sortiert. Für Volumes und Devices sind die Handler angegeben, bei
    den Directories die Adressen der Locks (APTR). Falls einem Directory,
    z.B. LIBS: mit 'assign add' weitere Verzeichnisse hinzugefügt wurden,
    ist dies durch eine entsprechende Zahl von +-Zeichen hinter dem Namen
    gekennzeichnet. Welche Verzeichnisse das sind, wird angezeigt, wenn man
    nach 'dl' zusätzlich den Namen des DeviceNodes eingibt, z.B. 'dl libs'.

    @{fg fill}KeyMap@{fg text} (k)
    Streng genommen werden nicht die KeyMaps sondern KeyMapNodes angezeigt.
    Diese bestehen aus einer Nodestruktur, an die eine KeyMap angehängt ist.

    @{fg fill}Libraries, Devices, Resources@{fg text} (l, v, r)
    Hinter den Namen stehen OpenCount, Zahl der Subroutinen (LVOs), Typ
    (ROM oder von Disk geladen) und Version + Revision.
    Bei Resources ohne Sprungadressen erfolgen keine Angaben, da sie auch
    keine Library-Struktur haben.

    @{fg fill}Memory@{fg text} (m)
    Neben den Speichertypen, die in Listen verwaltet werden, ist der ROM-
    Bereich angegeben. Darunter stehen ggf. die mit 'help' oder 'load'
    geladenen Dateien mit ihren Speicheradressen und ihrer Länge in Bytes.

    @{fg fill}Monitors@{fg text} (mon)
    Zeigt die Liste der MonitorSpec-Strukturen aus GfxBase.

    @{fg fill}Tasks@{fg text} (t)
    Die Liste enthält die Tasks und Prozesse der TaskWait-Liste und ThisTask
    (immer OMon). Für jeden Task sind Priorität, Stackgröße und -verbrauch
    angegeben. Bei Prozessen ist zusätzlich die Zahl der Hunks angegeben.
    Falls ein CLI-Prozess vorliegt, steht am Ende in [] der Name, mit dem
    er in die CLI-Struktur eingetragen ist.

    @{fg fill}TextFonts@{fg text} (tf)
    Es werden zusätzlich X- und Y-Größe der Zeichen, LoChar, HiChar, Style,
    Flags (dahinter fixed=feste Breite oder prop.=proportional) und OpenCount
    angegeben.

    @{fg fill}Windows und Screens@{fg text} (w)
    Zeigt alle geöffneten Screens und Windows. Nach jedem Screen werden die
    dazugehörigen Windows angezeigt. In Klammern stehen x- und y-Position
    sowie Breite und Höhe. Bei Screens sind außerdem Depth und ModeID, bei
    Windows die Zahl der System-+Programmgadgets und Zahl der Menüs angegeben.
    Namenlose Fenster sind durch '----' gekennzeichnet, dahinter steht in
    eckigen Klammern der Name des Tasks, der das Fenster geöffnet hat.

    @{fg fill}Resident Commands@{fg text} (rc)
    Ohne Angabe eines Programmnamens wird hiermit eine Liste der residenten
    Programme und der "UserCount" ausgegeben. Mit Namen wird die für das
    angegebene Programm angelegte Struktur (sie heißt 'Segment') gezeigt,
    falls vorhanden.
    Die Offsets der Segment-Struktur sind mit 'hdos' zu erreichen. Hier ist
    auch die Bedeutung der UserCount-Werte (UC) erklärt.

    @{fg fill}TimeRequests@{fg text} (tr)
    Zeigt ohne Option eine Liste der Tasks an, die das timer.device geöffnet
    haben. Es werden alle 5 Units des timer.device ausgegeben, meist ist aber
    nur die Unit VBLANK benutzt. Bei Angabe eines Tasknamens wird seine
    TimeRequest-Strukur angezeigt.

    @{fg fill}Datatypes@{fg text} (dt)
    Zeigt eine Liste von Datatypes-Strukturen, die von der datatypes.library
    intern verwaltet wird. Die Datatype-Struktur beginnt mit zwei Nodes
    (Node1, Node2), die zu verschiedenen Listen gehören. OMon benutzt die
    Node2-Liste, weil nur in ihr sämtliche DatyTypes verkettet sind. Angegeben
    werden aber die Node1-Adressen.

    Bei dem ersten Aufruf von 'dt' nach Programmstart, muss der Listenanfang
    erst gefunden werden. Dazu muss die datatypes.library geöffnet und ein
    ObtainDataTypeA() ausgeführt werden. Das dauert etwas und ruft einige
    Laufwerkaktivität hervor. Spätere Aufrufe sind schneller.
@endnode
@node "Strukturen anspringen"


    STRUKTUREN INNERHALB EINER LISTE ANSPRINGEN
    ===========================================

    <list> [<structname>] [n]

    Um eine Struktur innerhalb einer Liste zu erreichen, müssen nach dem
    Listenkürzel die Anfangsbuchstaben des Namens der gewünschten Struktur
    angehängt werden. Ein Leerzeichen zwischen Listenkürzel und Strukturname
    ist nicht erforderlich. Es reicht aus, soviele Buchstaben einzugeben, wie
    zur Unterscheidung von anderen Namen in derselben Liste nötig ist.

    BEISPIEL: Angenommen, in der library-Liste befänden sich 2 libraries,
	      die mit 'ex' beginnen, z.B exec.library und expansion.library.
	      Will man die Basis der expansion.library erreichen, reicht die
	      Eingabe 'lexp' oder 'l exp'.

    In den Fällen, wo eine Liste mehrere Einträge gleichen Namens bzw. mit
    gleichen Anfangsbuchstaben enthält, wird normalerweise nur der erste
    gefunden. Um auch den n-ten zu erreichen, muss als weiteres Argument die
    Position n angegeben werden, z.B. eine '2' für den zweiten Eintrag mit
    gleichen Anfangsbuchstaben. Im obigen Beispiel würde nach Eingabe von
    -> l ex 2  die zweite Library, deren Name mit 'ex' beginnt, gesucht werden.
    Hat eine Struktur keinen Namen, was vor allem bei Windows öfter vorkommt,
    muss nach dem Listenkürzel als Name "" eingegeben werden. Nach Eingabe
    -> w "" 3  würde z.B. das dritte namenlose Element in der Liste der
    Windows und Screens gesucht werden.
    Hat die Suche Erfolg gehabt, gibt OMon den Namen der gefundenen Struktur
    aus und darunter die dazugehörige Struktur im  Speicher.

    Bei folgenden Strukturen gibt es noch ein paar Besonderheiten:

    @{fg fill}Windows@{fg text}
    Angabe der IDCMP- und WFLG-Flags einschließlich einiger von Intuition
    gesetzter Flags unter dem Window-Namen. Analoges gilt für Screens.

    @{fg fill}Libraries, Devices, Resources@{fg text}
    Angabe des ID-Strings, soweit vorhanden.

    @{fg fill}Memory@{fg text}
    Durch Eingabe von 'm rom' oder 'm r' kann das ROM angesprungen werden,
    obwohl es nicht in den Speicherlisten vertreten ist.
@endnode
@node "Vermischtes"


    DIVERSES
    ========

    x,q

    OMon wird beendet. Dabei werden allozierte Speicherbereiche automatisch
    freigegeben und und eine eventuell geöffnete Output-Datei geschlossen.

    *

    Schaltet zwischen 8-Zeilenanzeige (128 Bytes) und 16-Zeilenanzeige
    (256 Bytes) um. Letztere reicht oft aus, wenn man sich kleinere Strukturen
    ansehen will. Vorher angezeigte Bereiche oder Online-Hilfen entschwinden
    dann nicht so schnell aus dem Blickfeld.

    !

    Schaltet den MemCheck ein/aus. Default ist EIN.
    Das Auslesen bestimmter Adressbereiche, z.B. der Customchips, kann
    zum Absturz führen. OMon erlaubt daher normalerweise nur das Auslesen
    von Speicherbereichen, die in den Exec-Listen vermerkt sind oder im
    ROM liegen. Welches die "legalen" Bereiche sind, kann man sich ansehen,
    indem man sich mit 'm' die Speicherlisten ausgeben lässt.
    ANMERKUNG: Die untere Adresse des jeweiligen Speicherbereichs wird
    abgerundet, indem das untere Word auf Null gesetzt wird. So kann man
    sich das ChipMem ab Adresse Null ansehen, ohne den MemCheck abschalten
    zu müssen. Beispiel:

		       Listenbereich	    zugänglich ab
    expansion memory   07E00020-08000000    07E00000
    chip memory        00000420-00200000    00000000


    cls

    Löscht das Display. Positiver Nebeneffekt: Ab OS3 werden Textausgabe und
    Scrollen schneller, solange nur die Farben 0 und 1 verwendet werden, z.B.
    bei Ausgabe der Listen. Bei Grafikkarten ist kein Unterschied spürbar.

    exe(cute) <program>

    Führt das angegebene Programm aus. Statt 'execute' kann die Kurzform
    'exe' verwendet werden. Nach 'exe' ist dasselbe einzugeben wie bei einer
    Shell. Falls der Programmpfad oder ein Argument Leerzeichen enthält, sind
    Pfad und Parameter in "" einzuschließen.
    Etwaige Ausgaben des aufgerufenen Programms, die normalerweise ins Shell-
    Fenster gehen würden, werden ins OMon-Fenster umgeleitet.

    Die Abarbeitung des aufgerufenen Programms erfolgt 'synchron', d.h.
    man kann mit OMon erst weiterarbeiten, wenn es beendet ist. Soll dies
    vermieden werden, ist ein 'run' voranzustellen.

    Beispiel: exe run c:multiview docs/dme.doc

    o<outfile>

    Die Ausgabe von OMon kann parallel in einer Datei gespeichert werden,
    deren Name hinter dem 'o' angegeben werden muss. Danach ändert sich der
    Prompt von '->' nach 'o->', damit man daran erinnert wird, dass noch
    eine Datei geöffnet ist. Durch Eingabe eines einfachen 'o' wird die
    Datei wieder geschlossen. Bei Programmende geschieht dies automatisch.

    list [<name>]

    Macht dasselbe wie der Shell-Befehl List. Die Ausgabe ist allerdings etwas
    schlichter.

    segm <process>

    Mit diesem Befehl wird zum ersten Segment der Segmentliste des Prozesses
    mit dem angegebenen Namen gesprungen.
    Segmente beginnen mit einem BPTR auf das nächste Segment (oder Null).
    Durch Eingabe von '>>' kann man zum jeweils nächsten Segment springen.

    cu [n]

    Gibt eine Liste der ConUnits aus, die durchnummeriert sind. Bei zusätz-
    licher Angabe der Nummer wird die jeweilige Unit angezeigt.

    tdu [n]

    Gibt eine Liste der vom trackdisk.device verwalteten TDUPublicUnits aus.
    Sie enthält soviel Einträge wie Laufwerke angeschlossen sind. Mit ein-
    gegebener Nummer n (0-3) wird die Unit des Laufwerks dfn: angezeigt.

    i [<name>][n]

    Gibt die in der ExecBase-Struktur eingetragenen IntVect-Datenstrukturen
    in folgender Form aus:

    INTERRUPT Level Pri  Type	  H/S	   Name
    1000374A	1     0  DISKBLK  Handler  disk.resource
    1000350A	3   120  PORTS	  Server   ciaa.resource
    100003B0	3    20  PORTS	  Server   UAE filesystem
    10003D4E	5    10  VBLANK   Server   graphics.library
    10008638	5     0  VBLANK   Server   gameport.device
    1000877A	5     0  VBLANK   Server   timer.device
    10003D7A	6     0  BLITTER  Handler  graphics.library
    10003760   12     0  DISKSYN  Handler  disk.resource
    100035AA   13   120  EXTERN   Server   ciab.resource

    Folgende Informationen werden nach der Strukturadresse gegeben:
    Interruptlevel (0-13), Priorität, Typ, Handler/Server und Nodename.
    Zum Anspringen einer Interruptstruktur gibt man deren Namen an. Falls
    mehrere Einträge mit demselben Namen existieren, muss zusätzlich die
    Position n eingegeben werden. Beispiel: i gra 2, springt zur zweiten
    Struktur mit dem Namen 'graphics.library'

    cli [n]

    Zählt die im TaskArray eingetragenen aktuellen CLI-Prozesse mit ihrer
    Nummer auf. Bei Eingabe der Nummer wird die jeweilige CLI-Struktur gezeigt.

    lock [address]

    lock prüft, ob an der AKTUELLER ADRESSE bzw. an der eingegebenen eine
    FileLock-Struktur vorliegt und gibt ggf. Locktyp, Filetyp (FILE/DIR) und
    Pfad aus.

    locks

    Zeigt die Adressen (APTR) aller Locks und die dazugehörigen Pfade.
    Diese können aus Platzgründen gekürzt sein, was an einem '*' hinter
    dem Volumenamen erkennbar ist. Locks vom Typ ACCESS_WRITE sind durch
    ein "w" vor dem Pfad gekennzeichnet, unbekannte mit "?", alle anderen
    sind vom Type ACCESS_READ.

    locale

    Zeigt die Locale-Struktur für die in locale.prefs definierte Sprache an.
    OS V38+ ist erforderlich. Die wichtigsten Offsets bekommt man mit 'hloc'.

    obtaindt <file>

    Zeigt die DataType-Struktur für die angegebene Datei an. OS3+ ist erfor-
    derlich.

    drive [<drive>]

    Ohne Option wird eine Liste der angeschlossenen Laufwerke mit verschiedenen
    Informationen ausgegeben, u.a. das Formatierungsdatum (created) und
    das vorliegende Filesystem. Folgende Filesysteme werden erkannt:

    OFS     Old  FileSystem
    FFS     Fast FileSystem
    OFS_int OFS  international
    FFS_int FFS       "
    OFS_dc  OFS  directory cache
    FFS_dc  FFS       "

    Bei Angabe eines Laufwerknamens wird die dazugehörige DosEnvec-Struktur
    angesprungen. Die Offsets dieser Struktur bekommt man mit 'he'.

    chunks

    Informiert über die Speicherfragmentierung. Angegeben werden für jeden
    Speichertyp (chip, expansion) Zahl (sum) der MemChunks bis zur
    angegebenen Größe und der größte MemChunk. Unter 'other' ist alles
    zusammengefasst, was größer als 256K ist. Beispiel:

   0.5K  4K  32K 256K  other sum   largest   free    used
   --------------------------------------------------------
     98   5    2    0	 2   107   29399 K  30234 K  2534 K  expansion memory
      3   0    1    0	 1     5    1965 K   1975 K    69 K  chip memory

    flush

    Entspricht dem CLI-Befehl "avail flush". Nicht mehr benutzte libraries,
    devices, fonts etc. werden aus dem Speicher entfernt. Der Gewinn an
    freiem Speicher wird anschließend ausgegeben. Mitunter muss man flush
    mehrmals aufrufen, um alles zu entfernen.

    savemem <name>

    Speichert den Speicherbereich zwischen den ersten beiden Marken in die
    Datei mit Namen <name>.
@endnode
@node "Hilfe"


    HILFE
    =====

    ?

    Gibt eine Übersicht über alle Befehle von OMon in einem eigenen Fenster.
    Sollte der Platz nicht reichen, erfolgt die Ausgabe ins OMon-Fenster

    h<struct>

    Mit diesem Befehl erreicht man die Online-Hilfe von OMon. Bei Eingabe
    eines einfachen 'h' werden die Kurzbezeichnungen der Strukturen, für
    die Online-Hilfe verfügbar ist ausgegeben:

HELP		Usage: h <struct>
cli=CLI 	dl=DeviceList	dt=DataType	dos=DosStructs	e=Envec
exe=ExecBase	gfx=GfxBase	i=Interrupt	int=IntBase	io=Request
k=KeyMap	l=Library	ln=List/Node	loc=Locale	m=Memory
mp=Message/Port rm=ResModules	rp=RastPort	sc=Screen	segm=Segment
sm=Semaphore	t=Task/Process	tf=TextFont	u=Unit		w=Window

    Wird nach dem h die Kurzbezeichnung angehängt, erscheint die Information
    zur jeweiligen Strukur. Kurze Strukturen sind z.T. unter einem Oberbegriff
    vereint. BEISPIELE:

    -> hdos  (Dos-Strukturen)

    @{fg fill}DOS [36]@{fg text}  RootN22 GlVec26 Err's36@{fg fill} DInfo[14]@{fg text}²DevInfo04
    @{fg fill}ROOT[20]@{fg text} ²TskAr00²ConSg04 Stamp08²ReSeg14²DInfo18²FHSeg1C
    @{fg fill}LOCK[14]@{fg text} ²Link.00 Key..04 Acces08 Task.0C²Volum10
    @{fg fill}RES [10]@{fg text} ²Next.00 UC...04²Seg..08 Name.0C
    (An allen Offsets mit '²' davor stehen BPTR)

    -> hw    (Window-Offsets)

    @{fg fill}WIND[84]@{fg text}  NxtWd00 LEdge04 Width08 MousY0C MinW.10 MaxW.14 Flags18
	      MenuS1C Title20 1stRq24 DMReq28 WScr.2E RPort32 BLeft36
	      BTop.37 1stGd3E IDCMP52 UPort56 WPort5A IMsg.5E IFont80

    Hinter der farbigen Bezeichnung der Struktur ist in [] deren Länge in
    Hex angegeben. Danach folgen die Bezeichnungen der Offsets (lt. Manual)
    und die Offsetwerte, ebenfalls in Hex.
    Um Platz zu sparen, sind die Bezeichnungen von Struktur und Offsets
    oft stark gekürzt. Bei langen Strukturen ist außerdem nur ein Teil der
    Offsets angegeben.


    help <helpfile>

    Neben den Online-Hilfstexten, die ins Programm eingebaut sind, kann
    OMon eine Textdatei, die weitere Informationen über Strukturen, LVOs,
    Konstanten, Strukturoffsets etc. enthält, laden. Mit einem speziellen
    Suchkommando (sh) kann die Hilfdatei dann nach gewünschten Begriffen
    durchsucht werden.

    Es ist jederzeit möglich, ein neues helpfile zuladen. Der für das alte
    verwendete Speicherbereich wird dann automatisch freigegeben.
    Mit 'help' allein (ohne Dateinamen) wird das aktuelle helpfile entladen,
    d.h. der belegte Speicher wird freigegeben. Dies geschieht automatisch
    auch bei Programmende.
@endnode
@node "Suchfunktionen"


    SUCH-FUNKTIONEN
    ===============

    s[-] "string" | <hexval>

    Es kann vorwärts und rückwärts gesucht werden. Bei Rückwärtssuche ist
    's-' zu verwenden. Strings werden daran erkannt, dass sie entweder in
    "" eingeschlossen sind oder andere Zeichen als 0-9 und a-f enthalten.

    Beispiele:
    s deadbeaf	    ;sucht nach Hexwert $deadbeaf
    s "deadbeaf"    ;sucht nach String "deadbeaf"
    s library	    ;sucht nach String "library"

    Nach Abschluss der Eingabe mit Return durchsucht OMon einen Bereich von
    128 K ab der aktuellen Position und zeigt bei Erfolg den Speicherbereich
    an, anderenfalls die Adresse, bis zu der erfolglos gesucht wurde.
    Der Prompt ist im Suchmodus verändert zu 's->'. Es genügt ein einfaches
    Return, um die Suche über die nächsten 128 K fortzusetzen.
    Der Suchmodus wird automatisch beendet, wenn ein illegaler Speicherbereich
    erreicht ist. Er kann ebenfalls beendet werden durch Eingabe eines anderen
    Befehls oder durch ein 's' (ohne Suchbegriff).

    Durch die Suche wird die BASIS nicht verändert. Man sollte daher ein'.'
    eingeben, wenn man an einer gefundenen Stelle weitermachen will.

    sh <string> | more	(sh steht für 'Suche Hilfe')

    Mit dieser Suchfunktion kann eine geladene Hilfsdatei nach ASCII-Strings
    durchsucht werden. Der String kann hier ohne Anführungszeichen eingegeben
    werden, weil diese Suchfunktion ohnehin nur Strings erwartet. Wird der
    String gefunden, wird die Zeile, in der er steht und die beiden darauf
    folgenden Zeilen ausgegeben. Die Stelle, an der sich der gesuchte Begriff
    befindet, ist farbig markiert. Will man sehen, welcher Text auf die 3
    Zeilen folgt, ist 'more' einzugeben. Es werden dann 3 weitere Zeilen aus-
    gegeben.
    Solange man sich im "Suche-Hilfe-Modus" befindet, ist der Prompt verändert
    zu 'sh->' Durch Drücken von Return wird die Suche desselben Strings fort-
    gesetzt und abgebrochen, wenn das Ende der Hilfsdatei erreicht ist.
    Abgebrochen werden kann auch durch Eingabe von 'sh' oder eines anderen
    Kommandos.


    ss <LVO>	      (ss steht für 'Suche Subroutine')

    Mit dieser Suchfunktion kann Programmcode im Speicher nach Stellen durch-
    sucht werden, an denen Library-Subroutinen aufgerufen werden.
    Für <LVO> ist der gewünschte Library-Vector-Offset in Hex einzugeben, wobei
    kein Minuszeichen vorangestellt werden muss. Dezimale LVO-Werte müssen
    durch ein vorangestellten Unterstrich (_) gekennzeichnet werden.

    BEISPIEL:

    Der LVO für die Exec-Funktion AllocMem() ist -198 (dezimal). Folgende
    Eingaben sind zur Suche von Aufrufen dieser Funktion möglich:

    ss _198  ss -_198  ss c6  ss -c6

    Eine gefundene Stelle kann disassembliert werden. Im vorliegenden Fall
    würde das ergeben:	  jsr  -$C6(a6)

    Ob an dieser Stelle tatsächlich AllocMem() aufgerufen wird, ist noch
    nicht sicher, da der LVO -198 auch in anderen libraries vorkommt.
    Man muss also durch Disassemblieren des vorangehenden Codes herausbekommen,
    welche Library-Basis Register a6 enthält. Steht dort z.B. move.l 4,a6
    ist es tatsächlich ein Aufruf von AllocMem().
@endnode
@node "Datei laden"


    PROGRAMM IN DEN SPEICHER LADEN
    ==============================

    load <name>

    Kopiert die Datei mit dem angegebenen Namen (es sollte sinnvollerweise
    ein Programm sein) in den Speicher und zeigt den Beginn dieses
    Speicherbereichs an. Man kann nun alle vorher besprochenen Operationen
    (Offseteingaben, Suchen etc.) anwenden, um eine gewünschte Stelle im
    Programm zu erreichen. Es kann dann modifiziert oder disassembliert werden.

    In der Statuszeile werden Programmname, aktuelle Position als Hex-Offset,
    Programmlänge (Hex) und Position in % angegeben, solange man sich "im
    Programm" aufhält. Ansonsten erscheint die Statuszeile in normaler Dar-
    stellung.
    Mit 'load' ohne Namensangabe wird der für das Programm allozierte Speicher
    wieder freigegeben, und man kann anschließend ein weiteres Programm laden.
    Welches Programm man geladen hat und wie lang es ist, erfährt man auch
    nach Eingabe von 'm'.

    first

    Springt zum Anfang des geladenen Programms.

    last

    Springt zum letzten Langwort des geladenen Programms.

    saveas <name>

    Speichert ein geladenes Programm unter dem angegebenen Namen ab.
    Sinnvoll ist das nur, wenn man es vorher im Speicher modifiziert hat.
@endnode
@node "Speicher modifizieren"


    MODIFIZIERN EINES SPEICHERBEREICHS
    ==================================

    mod "string"|<hexval>

    Der Speicher wird ab AKTUELLER ADRESSE mit angegebenen ASCII-String oder
    Hex-Wert nach einer Sicherheitsabfrage überschrieben. Der modifizierte
    Bereich wird anschließend farbig hervorgehoben. Die Funktion eignet
    sich u.a. dazu, ein mit 'load' in den Speicher geladenes Programm zu
    patchen.
    Beispiele:	mod 00 füllt das 1. Byte ab AKTUELLER ADRESSE mit $00
		mod "hallo" füllt 4 Bytes ab AKTUELLER ADRESSE dem string
		"hallo"
@endnode
@node "Zahlenwerte umrechnen"


    ZAHLENWERTE UMRECHNEN
    =====================

    Mit '#' werden Anweisungen zum Konvertieren eines BYTE, WORD oder LONG
    in die gängigen Zahlensysteme eingeleitet. Die Ausgabe erfolgt stets
    in der Reihenfolge:  $hex  %bin  dec  "ascii"

    #, #l

    Konvertiert 4 Bytes (1 Langwort) an der AKTUELLEN ADRESSE, die ungerade
    sein kann. Der Speicher wird durch die Konvertierung NICHT verändert.

    Durch wiederholten Aufruf dieser Funktion lässt sich leicht testen, ob
    und wie sich Datenbereiche eines Programms oder des Systems ändern.
    Beispiel: -> #
    Ausgabe: $02800100	%00000010_10000000_00000001_00000000  41943296	"...."

    #b, #w

    Wie oben. Mit '#b' wird jedoch nur das erste Byte konvertiert, mit '#w'
    die ersten 2 Bytes (word) ab AKTUELLER ADRESSE.
    Beispiel: -> #w (Speicherinhalt wie oben)
    Ausgabe: $0280  %00000010_10000000	640/640  ".."

    #<<

    Shiftet das longword ab AKTUELLER ADRESSE 2x nach links (Multiplikation
    mit 4) und zeigt das Ergebnis in einer Zeile an. BPTR können so in APTR
    umgerechnet werden.

    #>>

    Wie obige Operation, nur zweimaliges Shiften nach rechts (Division
    durch 4). APTR werden in BPTR umgerechnet.

    #"ascii"

    Wandelt einen aus max. 4 Zeichen bestehenden String, der in "" einge-
    schlossen sein muss, gemäß ASCII-Tabelle in Zahlenwerte um.
    Beispiel: -> #"DOS"
    Ausgabe: $00444F53	%00000000_01000100_01001111_01010011  4476755  ".DOS"

    #[b,w,l][-][_,%][<value>]

    Wandelt einen eingegebenen Wert (<val>) von Byte-, Word- oder Longword-
    länge in die gängigen Zahlensysteme um. Mit den Präfixen '_' und '%'
    kann festgelegt werden, ob der Wert als Dezimal- oder Binärzahl inter-
    pretiert werden soll. Ansonsten wird er als Hexadezimalwert interpretiert.
    Beispiele:
    -> #b10	Ausgabe: $10  %00010000  16/16	"."
    -> #b_10	Ausgabe: $0A  %00001010  10/10	"."
    -> #b-_10	Ausgabe: $F6  %11110110  246/-10  "ö"
@endnode
@node "Disassemblieren"


    DISASSEMBLIEREN
    ===============

    dis [<address>]

    Disassembliert den Speicher ab AKTUELLER ADRESSE oder, wenn eine Adresse
    angegeben wurde, von da ab. Es wird nur 68000-Code verstanden (anderer
    kommt auf dem Amiga ohnehin kaum vor). Es werden 16 Zeilen Assemblercode
    ausgegeben. Danach befindet man sich weiterhin im Disassembliermodus, was
    an einer Änderung des Prompts zu erkennen ist. Es genügt dann, die
    Return-Taste zu drücken, um weitere 16 Zeilen Code zu disassemblieren.

    Durch Eingabe von '-' und Return wird quasi rückwärt disassembliert,
    d.h. OMon zeigt den Code, der 32 Bytes vor dem zuletzt ausgegebenen steht.
    Die Stelle, wo der vorher stehende Code in bereits angzeigten übergeht,
    ist durch eine Marke (<) am Rand gekennzeichnet.
    Zu beachten ist, dass beim Rückwärtsgehen u.U. mitten in einer Prozessor-
    anweisung begonnen wird. Der disassemblierte Code ist dann entweder
    falsch oder unverständlich (dc.w Anweisung). In solchen Fällen kann auch
    die Marke fehlen.

    Aus dem Disassembliermodus kommt man durch Eingabe eines anderen Befehls
    oder durch Eingabe von 'dis' heraus.

    dis <address> <address>

    Disassembliert den durch die beiden Adressen begrenzten Speicherbereich.
    Die zuerst angegebene Adresse muss natürlich niedriger sein als die zweite.

    Die Ausgabe des Codes erfolgt im Fenster oder - wenn mit 'o <outfile>'
    eine Output-Datei geöffnet wurde - in die Datei. Letzteres geht wesentlich
    schneller. Mit Ctrl-C kann der Disassembliervorgang abgebrochen werden.

    dis +<length>

    Der zu disassemblierende Bereich kann auch durch eine Längenangabe (in Hex)
    definiert werden. Es wird dann ab AKTUELLER ADRESSE begonnen. Ansonsten
    gilt das vorher Gesagte. Mit dieser Funktion kann man leicht ein
    ganzes Programm disassemblieren. Man geht wie folgt vor:
    1. load <Programmpfad>
    2. o ram:Programm.dis
    3. dis +<Programmlänge>
    4. o
@endnode
@node "Autor"

					Jürgen Klawitter
					Marschnerstr. 22
					12203 Berlin
					klawitter.juergen@berlin.de
@endnode
