/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jim Steichen
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <clib/diskfont_protos.h>

#define GetString( g )      ((( struct StringInfo * )g->SpecialInfo )->Buffer  )

#define GD_LLV                                 0
#define GD_Update                              1
#define GD_Cancel                              2
#define GD_Unlock                              3

#define ATS_CNT 4

PRIVATE char ver[] = "$VER: SysLocks 1.0 (12/20/1999) by J.T. Steichen";

struct Screen *Scr = NULL;
UBYTE *PubScreenName = "Workbench";
APTR VisualInfo = NULL;
struct Window *ATSWnd = NULL;
struct Gadget *ATSGList = NULL;
struct IntuiMessage ATSMsg;
struct Gadget *ATSGadgets[4];
UWORD ATSLeft = 0;
UWORD ATSTop = 14;
UWORD ATSWidth = 632;
UWORD ATSHeight = 228;
UBYTE *ATSWdt = ( UBYTE * ) "AmigaTalk System Locks Info:";
struct TextAttr *Font, Attr;
UWORD FontX, FontY;
UWORD OffX, OffY;
struct TextFont *ATSFont = NULL;

extern struct MinList LLV0List;

struct Node LLV0Nodes[] = {
   ( struct Node * ) & LLV0List.mlh_Tail, ( struct Node * ) & LLV0List.mlh_Head, 0, 0, "Address  Access   Path"};

struct MinList LLV0List = {
   ( struct MinNode * ) & LLV0Nodes[0], ( struct MinNode * ) NULL, ( struct MinNode * ) & LLV0Nodes[0]};

UWORD ATSGTypes[] = {
   LISTVIEW_KIND,
   BUTTON_KIND,
   BUTTON_KIND,
   BUTTON_KIND
   };

PRIVATE int LLVClicked( void )
   {
   /* routine when gadget "" is clicked. */
   }

PRIVATE int UpdateClicked( void )
   {
   /* routine when gadget "_Update" is clicked. */
   }

PRIVATE int CancelClicked( void )
   {
   /* routine when gadget "_Cancel" is clicked. */
   }

PRIVATE int UnlockClicked( void )
   {
   /* routine when gadget "Unlock" is clicked. */
   }

struct NewGadget ATSNGad[] = {
   2, 3, 627, 200, NULL, NULL, GD_LLV, 0, NULL, ( APTR ) LLVClicked,
   4, 205, 71, 17, ( UBYTE * ) "_Update", NULL, GD_Update, PLACETEXT_IN, NULL, ( APTR ) UpdateClicked,
   554, 205, 72, 17, ( UBYTE * ) "_Cancel", NULL, GD_Cancel, PLACETEXT_IN, NULL, ( APTR ) CancelClicked,
   82, 205, 71, 17, ( UBYTE * ) "Unlock", NULL, GD_Unlock, PLACETEXT_IN, NULL, ( APTR ) UnlockClicked
   };

ULONG ATSGTags[] = {
   ( LAYOUTA_Spacing ), 2, ( TAG_DONE ),
   ( GT_Underscore ), '_', ( TAG_DONE ),
   ( GT_Underscore ), '_', ( TAG_DONE ),
   ( GA_Disabled ), TRUE, ( TAG_DONE )
   };

static UWORD ComputeX( UWORD value )
   {
   return ( ( UWORD ) ( ( ( FontX * value ) + 4 ) / 8 ) );
   }

static UWORD ComputeY( UWORD value )
   {
   return ( ( UWORD ) ( ( ( FontY * value ) + 4 ) / 8 ) );
   }

static void ComputeFont( UWORD width, UWORD height )
   {
   Forbid(  );
   Font = &Attr;
   Font->ta_Name = ( STRPTR ) GfxBase->DefaultFont->tf_Message.mn_Node.ln_Name;
   Font->ta_YSize = FontY = GfxBase->DefaultFont->tf_YSize;
   FontX = GfxBase->DefaultFont->tf_XSize;
   Permit(  );

   OffX = Scr->WBorLeft;
   OffY = Scr->RastPort.TxHeight + Scr->WBorTop + 1;

   if ( width && height )
      {
      if ( ( ComputeX( width ) + OffX + Scr->WBorRight ) > Scr->Width )
         goto UseTopaz;
      if ( ( ComputeY( height ) + OffY + Scr->WBorBottom ) > Scr->Height )
         goto UseTopaz;
      }
   return;

UseTopaz:
   Font->ta_Name = ( STRPTR ) "topaz.font";
   FontX = FontY = Font->ta_YSize = 8;
   }

PRIVATE int LLVClicked( void )
   {
   /* routine when gadget "" is clicked. */
   }

PRIVATE int UpdateClicked( void )
   {
   /* routine when gadget "_Update" is clicked. */
   }

PRIVATE int CancelClicked( void )
   {
   /* routine when gadget "_Cancel" is clicked. */
   }

PRIVATE int UnlockClicked( void )
   {
   /* routine when gadget "Unlock" is clicked. */
   }

PRIVATE int ATSCloseWindow( void )
   {
   /* routine for "IDCMP_CLOSEWINDOW". */
   }

int SetupScreen( void )
   {
   if ( !( Scr = LockPubScreen( PubScreenName ) ) )
      return ( 1L );

   ComputeFont( 0, 0 );

   if ( !( VisualInfo = GetVisualInfo( Scr, TAG_DONE ) ) )
      return ( 2L );

   return ( 0L );
   }

void CloseDownScreen( void )
   {
   if ( VisualInfo )
      {
      FreeVisualInfo( VisualInfo );
      VisualInfo = NULL;
      }

   if ( Scr )
      {
      UnlockPubScreen( NULL, Scr );
      Scr = NULL;
      }
   }

int HandleATSIDCMP( void )
   {
   struct IntuiMessage *m;
   int ( *func ) (  );
   BOOL running = TRUE;

   while ( running == TRUE )
      {
      if ( ( m = GT_GetIMsg( ? ? Wnd->UserPort ) ) == NULL )
         {
         ( void ) Wait( 1L << ? ? Wnd->UserPort->mp_SigBit );
         continue;
         }

      CopyMem( ( char * ) m, ( char * ) &ATSMsg, ( long ) sizeof( struct IntuiMessage ) );

      GT_ReplyIMsg( m );

      switch ( ATSMsg.Class )
         {

         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( ATSWnd );
            GT_EndRefresh( ATSWnd, TRUE );
            break;

         case IDCMP_CLOSEWINDOW:
            running = ATSCloseWindow(  );
            break;

         case IDCMP_GADGETUP:
         case IDCMP_GADGETDOWN:
            func = ( void * ) ( ( struct Gadget * ) ATSMsg.IAddress )->UserData;
            running = func(  );
            break;
            }
      }
   return ( running );
   }

int OpenATSWindow( void )
   {
   struct NewGadget ng;
   struct Gadget *g;
   UWORD lc, tc;
   UWORD wleft = ATSLeft, wtop = ATSTop, ww, wh;

   ComputeFont( ATSWidth, ATSHeight );

   ww = ComputeX( ATSWidth );
   wh = ComputeY( ATSHeight );

   if ( ( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width )
      wleft = Scr->Width - ww;
   if ( ( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height )
      wtop = Scr->Height - wh;

   if ( !( ATSFont = OpenDiskFont( Font ) ) )
      return ( 5L );

   if ( !( g = CreateContext( &ATSGList ) ) )
      return ( 1L );

   for ( lc = 0, tc = 0; lc < ATS_CNT; lc++ )
      {

      CopyMem( ( char * ) &ATSNGad[lc], ( char * ) &ng, ( long ) sizeof( struct NewGadget ) );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr = Font;
      ng.ng_LeftEdge = OffX + ComputeX( ng.ng_LeftEdge );
      ng.ng_TopEdge = OffY + ComputeY( ng.ng_TopEdge );
      ng.ng_Width = ComputeX( ng.ng_Width );
      ng.ng_Height = ComputeY( ng.ng_Height );

      ATSGadgets[lc] = g = CreateGadgetA( ( ULONG ) ATSGTypes[lc], g, &ng, ( struct TagItem * ) & ATSGTags[tc] );

      while ( ATSGTags[tc] )
         tc += 2;
      tc++;

      if ( NOT g )
         return ( 2L );
      }

   if ( !( ATSWnd = OpenWindowTags( NULL,
                                    WA_Left, wleft,
                                    WA_Top, wtop,
                                    WA_Width, ww + OffX + Scr->WBorRight,
                                    WA_Height, wh + OffY + Scr->WBorBottom,
                                    WA_IDCMP, LISTVIEWIDCMP | BUTTONIDCMP | IDCMP_CLOSEWINDOW | IDCMP_REFRESHWINDOW,
                                    WA_Flags, WFLG_DRAGBAR | WFLG_DEPTHGADGET | WFLG_CLOSEGADGET | WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_RMBTRAP,
                                    WA_Gadgets, ATSGList,
                                    WA_Title, ATSWdt,
                                    WA_ScreenTitle, "AmigaTalk System Info",
                                    TAG_DONE ) ) )
      return ( 4L );

   GT_RefreshWindow( ATSWnd, NULL );

   return ( 0L );
   }

void CloseATSWindow( void )
   {
   if ( ATSWnd )
      {
      CloseWindow( ATSWnd );
      ATSWnd = NULL;
      }

   if ( ATSGList )
      {
      FreeGadgets( ATSGList );
      ATSGList = NULL;
      }

   if ( ATSFont )
      {
      CloseFont( ATSFont );
      ATSFont = NULL;
      }
   }
