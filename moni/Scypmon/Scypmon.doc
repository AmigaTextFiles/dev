
		    Description for Scypmon V1.7
		    \==========================/

Release:
--------

(C) by Jörg Bublath 1989-1993

  Developing this program took me a long time, so I'd appreciate a little
financial support. Because I hate all those "crippled unregistered versions",
I won't do this myself to get my DM 5,- (or US $5) shareware fee (that
really isn't much, is it ?), but I appeal to all those users out there to be
honest ! I know it costs a big pile of money to pay or all those shareware-
programs that one has. So I would like to suggest a new shareware concept:
I call it "you share me - I share you", which means that all authors of
shareware-programs let me use their programs for free, and they mine, but all
those who don't write any useful programs can begin doing so - or pay!
Update-services, which would cost money of course, aren't included in
the "share each other" concept. All those guys who helped me with ideas,
test-reports and routines to make Scypmon better, don't have to pay
shareware either (but I don't mind when they do :-))
Of course all authors of good Non-Shareware Software are included in my offer,
too! Just send me notice and your program.

  I prohibit changes to the program (incl. source) and documentation.

  Registered Users will receive updates and sourcecodes if they send a disk
including return postage.

  Scypmon is free to be spread on public-domain and shareware disks
especially on Fred Fish's AmigaLibDisks, as long as they are sold for a
reasonable charge that is less than US $6 or DM 8.- .
For use in commercial products the permission of the author is required.
Scypmon may be copied and distributed via electronic networks such
as the Internet, also it may be moved on anonymous ftp-servers,
mail-boxes or BBS's.
The Copyright stays by the Author.
Scypmon is Shareware, that means you may keep Scypmon in archived form
without paying, but when you unpack it and use it, you have to pay the fee
mentioned above, or share your programs with me.

General Information:

  This monitor uses a full-screen-editor with or without automatic
insertion and an additional command-history of 1K. The cursor can be
moved using the cursor-keys or by positioning it with your mouse.
If you leave the screen up or down, the screen will be scrolled in the
opposite direction. If the status-line is inverted, then the monitor is
active. The headline also shows if you are in insert or overwrite mode.
When you use the scrolling and there is an output-line of the "m", "i"
or "d"-command on the screen the next logical line of this command will
appear instead of the empty line.

  Using the cursor-keys with shift will cause scrolling by one full screen.

Some other keys that are used in a special way:

  HELP (=CTRL-l)          : Clear Screen + Cursor Home
  Shift + HELP (CTRL-K)   : Clears the rest of the line starting at the
			    actual cursor-position.
  Shift + DEL		  : Inserts one blank
  On the numeric keypad:
  Shift + 7		  : Cursor home (upper left corner)
  Shift + 1		  : Cursor end (lower left corner)
  Shift + 0		  : Switch between insert and overwrite mode
  Shift + .		  : Del
  F1			  : Jsr-dissassemble in
  Shift + F1		  : Switch mode "m" and "d" in full-screen display
  F2			  : Jsr-dissassemble out (explained later)
  Alt + Cursor Up	  : Previous command-history entry
  Alt + Cursor Down	  : Following command-history entry

During screen-output:

  SPACE 		  : Stop screen-output, continue: SPACE again
  CTRL-C		  : Break screen-output
  Left mouse-button	  : Hold to stop screen-output

Exceptions:
-----------

  All exceptions except #08 (privelege violation) and the trap #0x - commands
will not cause a guru, but instead a monitor output stating "exception #xx at
xxxxxx" if the "-p"-option to patch the exceptions is activated. In addition
you will receive some detailed information about the task that crashed (see
"e"-command) and it should no longer be in the task-list. If you crash your
machine totaly there will be certainly only one help for you :
ctrl + amiga + amiga !

Calling the monitor from CLI:
-----------------------------

You can call the monitor by typing:

scypmon [-bdp] [-P <xpos> <ypos>] [-S <xsize> <ysize>]
	[-s <pubscreen>] [-f <fontname> <fontsize>] [batchfile]

"-b" will make the monitor start itself in background, which means that its
     window will not be activated at startup.

"-p" will patch the exception vectors to catch gurus. If this option is
     not used, Amiga-Dos will do what ever it likes with crashes.

"-d" Tries to use the dis.library to disassemble, which means that Scypmon
     will know 68030-commands. Assembling is still only possible for
     68000, and even this will sometimes cause trouble with the dis.library
     because of a slightly different syntax.

"-P" give new coordinates for the window to open.

"-S" give a new size for the window.

     CAUTION: If the window cannot open due to wrong coordinates, Scypmon
	      won't run. There will be no error-message!

"-s" Running 2.0+ you are able to have public-screen. This option makes it
     possible to open the scypmon on any public screen.

"-f" For use of other than the fonts (systemfont) defined with preferences.

  This batchfile may be any textfile eg. edited with "ed" that contains a
list of monitor commands. This option is very useful for absolute
programming, when you need to load graphic or sound data into memory.

eg.:
{
o 60000 7f000 00
l "graphic.data" 70000
l "sound.data" 60000
l "sinus-table" 7e000
x
}

This batchfile will clear the memory from 60000 to 7f000, load the three
programs absolutely into memory and leaves the monitor afterwards.

A clarification to the memory allocations:

  To prevent allocmem-chaos, the monitor organizes memory-allocations in
its own way. You have 8 segments (0-7) that can be used for allocations.
If you use one segment twice then the old memory allocated in this
segment will be freed. When you leave the Monitor all segments will be
given back to Amiga-Dos. This prevents a chaos like in c-mon when you
load several programs and don't know afterwards where and how much, so
you have to reset to have a clean memory again.

Menus
------

  The options "-p" and "-d" can also be changed while the monitor is
running by using the menus. You also can leave scypmon by menues or
call up a helpwindow.
The help-window is just a short overview over the command and no
replacement for the doc-file.

The commands (in alphabetical order):
--------------------------------------

All Values (in assemble/dissamble,too !) have to be entered hexadecimal (you
don't have to use $xxx - only xxx) !

[ ]    : Expressions in these brackets are optional
( )    : Expressions in round brackets have to be entered
start  : Is a hex-expression that indicates a start-adress
stop   : Is a hex-expression that indicates an end-adress
target : Is a hex-expression that indicates a target-adress
name   : Is an ASCII-string
segment: A memory segment between 0 and 7

When dealing with hex-adresses you can use the variables ^(a-z) in most
cases.
----------------------------------------------------------------------------
[?] (expression)                        : Calculate

  The expression will be calculated and printed out decimal, hexadecimal,
binary and as 4-char ASCII string. Inside the expression you have to use a
"$" to indicate a hex-number, a "#" or nothing to indicate a decimal number,
a "%" to indicate a binary-number and max. 4 ASCII chars "<str>" or '<str>'.
In addition, you can get the value of a hex-address with "&(hexaddress)",
use uservariables with "^(a-z)" and the following systemvariables:
^s    = Startadress of last load
^e    = Endadress of last load
^S0-7 = Startadress of segment 0-7
^L0-7 = Length of segment 0-7

  For calculation you may use "+", "-", "*" and "/". You can also use
brackets - The calculation will be done in mathematical order (first "*"
and "/" then "+" and "-")

eg.: ? $1000-(#100+%010)*2
----------------------------------------------------------------------------
^(a-z)=(expression)                     : set variable

  This sets one of the 26 user-variables to the given value (compare "?")
Caution: The variables ^s and ^e are used by the monitor to indicate
the last start- and end-address of absolute loading.


eg.: ^a=^a+$20-(1+4)*5
----------------------------------------------------------------------------
<b (blocknr) (start) [len] [!]          : Block Load
>b (blocknr) (start) [len]              : Block Save

  Loads/Saves (len) bytes from disk starting with block number (blocknr).
If you don't give a [len] , $200 bytes = 1 sector will be loaded/saved.
As device will be used the one fixed the with "V"-command.
Attention: You have to enter all values in hex !
The "!"-Option overrides the memory check, to overload memory already
allocated by DOS.

eg.: <b 1a2 70000
----------------------------------------------------------------------------
<o (offset) (start) [len] [!]           : Offset Load
>o (offset) (start) [len]               : Offset Save

  Loads/Saves (len) bytes from disk starting with offset (offset).
If you don't give a [len] , $200 bytes = 1 sector will be loaded/saved.
As device will be used the one fixed the with "V"-command.
Attention: You have to enter all values in hex !
The "!"-Option overrides the memory check, to overload memory already
allocated by DOS.

eg.: <o 30000 70000
----------------------------------------------------------------------------
<t (tr) (hd) (sc) (start) [len] [!]     :Track Load
>t (tr) (hd) (sc) (start) [len]         :Track Save

  Loads/Saves [len] bytes from disk starting at track, head, sector. If you
don't give a [len] the default of $1400 bytes = 1 side of a track will
be loaded/saved.
As device will be used the one fixed the with "V"-command.
Attention: You have to enter all values in hex !
The "!"-Option overrides the memory check, to overload memory already
allocated by DOS.


eg.: <t 0a 01 06 70000
----------------------------------------------------------------------------
a (start)                               : Assemble

  Will cause an output of a "," followed by the given adress and sets the
cursors to the right tab-position to assemble. Instead of using this
command you can simply dissassemble the adress and overwrite it.

eg.: a 70000
----------------------------------------------------------------------------
A (segment) (start) (len)               : Allocate Absolute

  Uses AllocAbs (-204) to allocate memory and remembers the memory in the
segment-list.

eg.: A 0 70000 1000
----------------------------------------------------------------------------
A (segment) (len)                       : Allocate Memory

  If you don't give a alloc-adress allocmem (-198) will be used and the
memory remembered in the segment-list.

eg.: A 0 1000
----------------------------------------------------------------------------
b (start)                               : Boot Checksumm

  Calculates the checksum of a bootblock ($0400 bytes !) and inserts it.

eg.: b 70000
----------------------------------------------------------------------------
B (stop)                                : Breakpoint

  A breakpoint will be set to the adress (stop), then the program will start
according to the entered PC at the "r"-command. After execution the
breakpoint will be cleared and the register will be given out.

eg.: B 70200
----------------------------------------------------------------------------
c (start) (stop) (target)               : Compare

T  he memory (start) to (stop) will be compared with the (target) and all
differing bytes will be reported.

eg.: c 70000 71000 72000
----------------------------------------------------------------------------
C (start)                               : Calc Block CheckSumm

  Calculates the checksum of a normal diskblock and inserts it.

eg.: C 70000
----------------------------------------------------------------------------
CD [name]				: Change Directory

  The actual Path will be set to [name].

eg.: CD df0:c
----------------------------------------------------------------------------
d (start) [stop]                        : Dissassemble

  The given memory will be disassembled. Before each output-line there will
be printed a "," as a marker for the scroll-function and for assembling (so
you can assemble when overwriting).

eg.: d 70000 70020
----------------------------------------------------------------------------
D [name]				: Directory

  If no name is given, the actual directory will be printed out, otherwise
the given path will be used.

eg.: D df0:c
----------------------------------------------------------------------------
e "(taskname)"                          : Examine Task
e (taskadress)

  The given task is searched and will be printed with name, adress, priority,
signals and stackusage (and CLI-command).

e.g.: e "Scypmon 1.4"
---------------------------------------------------------------------------
f (start) (stop) (v1) [v2...] [!]       : Find

  This command searches after a expression that can be defined as a mixture
out of hexnibbles, "*", or strings. When nibbles are replaced by the
joker "*" then the command will find any possible matches.  If the "!" is
added then it will be a not-find, that means if you search for "00 !" you
will find all places where no 00 exists.

eg.: f 70000 80000 01 "hello" 0* 4a3b "xx" 00
----------------------------------------------------------------------------
fd (start) (stop) (v1) [v2...] [!]      : Find and disassemble

  Like the normal find-command, but if something is found it will be dis-
assembled if it stands on an even adress - then the monitor waits for any
key. If you press 'ESC' you will exit find-mode, otherwise the search will
be continued and if found the next line will be disassembled. If you are
only interested in the arguments of a command, the necessary number of
jokers ('*') has to be put in front if you want a sensible output.

eg.: fd 70000 80000 **** 00dff180
----------------------------------------------------------------------------
fr (start) (stop) (target)              : Find Relative

  Searches for a word between (start) and (stop) that points relatively to
(target). This word can lie between (target)-$8000 to (target)+$8000.
Very useful to find branches and xxxx(pc)-adressmodes. Won't find
short-branches.

eg.: fr 70000 72000 71000
----------------------------------------------------------------------------
F (segment)                             : Free Memory

  The given segment will be freed by using freemem (-210) or UnLoadSeg.

eg.: F 0
----------------------------------------------------------------------------
g (ziel)                                : Goto

  The program will be started at the given address under use of the at "r"
defined stacks and registers and return after "rts" into the monitor.

eg.: g 70000
----------------------------------------------------------------------------
h					: Show history

  The command-history will be displayed on the screen.

e.g.: h
----------------------------------------------------------------------------
i (start) [stop]                        : ASCII Dump

  The given memory will be printed as ASCII-dump. As a marker for scrolling
a ";" is used.

eg.: i 70000 70020
----------------------------------------------------------------------------
l ["](name)["] (start) [!]              : Load absolute File

  The given file is loaded at the given adress. Using the "M"-command the
monitor looks up how many bytes of memory are free, and loads only that
many bytes. If you want to overload memory allocated by DOS you can
cancel this control with "!".
The start- and end-address will be saved into the variables ^s and ^e for
further use, especially in batchfiles.

eg.: l "program.obj" 70000
----------------------------------------------------------------------------
ld ["](name)["] (segment)               : Load Dos-File

  Load an Amiga-Dos file using the LoadSeg-Command, allocs the memory and
inserts it into the segment-list.

eg.: ld "dir" 0
----------------------------------------------------------------------------
m (start) [stop]                        : Memory Dump

  The given memory will be printed as a hex-dump. Each line will be marked
by a ":" for scrolling and overwriting.

eg.: m 70000 70020
----------------------------------------------------------------------------
M (start)                               : Show Free Memory

  Looks up how many bytes of free memory there are, starting at the given
address, and print the amount.

e.g.: M 30000
----------------------------------------------------------------------------
o (start) (stop) (v1) [v2...]           : Occupy

  The memory between (start) and (stop) will be filled with the given values.

eg.: o 70000 71000 01 23 45
----------------------------------------------------------------------------
O [name]				: Set Output Device

  Here you can enter the device/filename that is used with the "p"-command.
If you don't give a name you will see the actual device.
(Default: prt:)
The outputfile will be opened at the first use of the "p"-command and
closed when you leave the monitor or specify a new output-file.

e.g.: O df0:testfile
----------------------------------------------------------------------------
p (any command)                         : Print using Output Device

  You can add a "p" as prefix before every command to have an output on
screen and chosen output-device (eg.: printer).

eg.: pd 70000 70200
----------------------------------------------------------------------------
P (start)                               : Print Text

  Prints a text in memory on the screen. The text should be ended by a $00.
The output can be paused by space and stopped by CTRL.

eg.: P 70000
----------------------------------------------------------------------------
r					: Register

  Give you all processor-registers (used at "goto" or "trace"). You can
change them by overwriting.

eg.: r
----------------------------------------------------------------------------
s ["](name)["] (start) (stop)           : Save absolute File

  The given memory will be saved.

eg.: s "objectcode" 70000 72000
----------------------------------------------------------------------------
S [segment]				: Segment List

  Print the data of the given segment - if it is an Amiga-Dos File you will
get a list of all segments of this file.
If no segment is given, you will get a general list of all 8 segments.

eg.: S 0
----------------------------------------------------------------------------
t (start) (stop) (target)               : Tansfer

  The memory from (start) to (stop) will be transfered to (target).

eg.: t 70000 71000 71000
----------------------------------------------------------------------------
T [start]				: Trace

  Starting at [start] (or if not given at the defined PC) the monitor will
dissassemble one command. You can start tracing now, using the following
keys:
	return: execute this command and show next
	x:	leave the trace-mode
	r:	show registers
	n:	set a breakpoint on the next command and start program.
		useful to escape from "dbf"-loops.
	j:	the next command will be executed, then one longword will
		be taken from the stack and a breakpoint will be set to
		the adress that is defined by the longword.
		Effect: if the actual command is a jsr/bsr the whole
		subroutine will be executed before returning to trace-
		mode. Otherwise the program will come back to trace-
		mode at the next "rts". Be careful: if something is
		taken from the stack before "rts" you will have a
		nice crash !
	g:	will behave like goto (leave trace-mode)

eg.:	T 70000
----------------------------------------------------------------------------
V <devicename>				: Device

  Changes the device used with the track-commands (default: df0).

eg.: V df0
----------------------------------------------------------------------------
w (start) ["](name)["]                  : Write ASCII

  The given string will be written as ASCII-code into memory.

eg.: w 70000 "hello world"
----------------------------------------------------------------------------
x					: Exit

  Leaves Scpymon. Allocated Memory will be restored.

eg.: x
----------------------------------------------------------------------------

Jsr-Disassemble
----------------

  This option is useful to trace a program by brain. When the F1-Key is
pressed the assembly-expression in the actual cursor-line will be
calculated (source-part) and the actual dissassemble-adress will be
pushed on a roundstack for 16 values. Afterwards, if the actual
command was a jsr/jmp or branch-command, the memory at the calculated
adress will be disassembled, otherwise it will be printed using the
"m"-command. The jsr-disassembler knows the following expressions:
$xxxx,$xxxx(pc),$xx(ax),$xx(ax,dx),$xx(ax,ax). As registers the actual
defined one will be taken.
  If the actual cursorposition is on a "m"-line, the next 8 digits will
be taken as long adress and shown by "m"-command again.
If you are on any other line, the hexadress at cursorposition will be
scanned and shown by "m" (Attention: You can't use F2 to go back here!)
  If you have seen enough about your subroutine/data you can press f2 to get
back to your starting point.
  The data will be saved on a round-stack, which means that you can
press F1 as often as you want and don't have to worry about a stack overflow,
but you can only take the last 16 "f1"s back with f2.
If you are not happy about the mode the monitor chose while pressing
f1 ("m" or "d"), you can change this by pressing shift+F1.

News since V1.5:
----------------

  Window! Sizable! Fonts! Public-Screen! More compatible! Better
  Trackloading....

News since V1.6:
----------------

  Minor Bugfixes, Trackdisk now works REALLY on all devices, Enforcerhits
  removed, removed german docs.

Final Remarks
-------------

  The fact that I didn't recover bugs when testing, doesn't mean that there
are no bugs at all, so if you have new ideas or find bugs, feel free to send
your them to my address, including a disk and the return-postage for sending
you a new version.

Jörg Bublath
Holzheimerstr. 4, E07
W-8390 Passau
Germany

or reach me by email under:
bublath@forwiss.uni-passau.de

or find me on IRC on #amigager under the nickname 'Skull'



