/*
--[[--------------------------------------------------------------------------

    Author: Michael Roth <mroth@nessie.de>

    Copyright (c) 2004, 2005 Michael Roth <mroth@nessie.de>

    Permission is hereby granted, free of charge, to any person 
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without restriction,
    including without limitation the rights to use, copy, modify, merge,
    publish, distribute, sublicense, and/or sell copies of the Software,
    and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be 
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

--]]--------------------------------------------------------------------------
*/

@require "sqlite3"

function assert_function(f)
	if gettype(f) <> #function then debugprint("Assertion failed")
	return(f)
endfunction

function assert_nil(f)
	if gettype(f) <> #nil then debugprint("Assertion failed")
	return(f)
endfunction

function assert_table(f)
	if gettype(f) <> #table then debugprint("Assertion failed")
	return(f)
endfunction

function assert_number(f)
	if gettype(f) <> #number then debugprint("Assertion failed")
	return(f)
endfunction

function assert_equal(a, b, msg)
	if a <> b then debugprint("Assertion failed:", msg)
	return(a)
endfunction

function assert_userdata(f)
	if gettype(f) <> #userdata then debugprint("Assertion failed")
	return(f)
endfunction

function assert_pass(f)
	local succ = f()
	if succ = false then debugprint("Assertion failed")
endfunction

function assert_error(f)
 	local succ = f()
	if succ = true then DebugPrint("Assertion failed")
endfunction

function my_assert(e)
	if gettype(e) = #nil then debugprint("Assertion failed")
	return(e)
endfunction
	
;-------------------------------
;-- Basic open and close test --
;-------------------------------

/*
lunit.wrap("open_memory", function()
  local db = assert_userdata( sqlite3.open_memory() )
  assert( db:close() )
end)

lunit.wrap("open", function()
  local filename = "/tmp/__lua-sqlite3-20040906135849." .. os.time()
  local db = assert_userdata( sqlite3.open(filename) )
  assert( db:close() )
  os.remove(filename)
end)

*/

;-------------------------------------
;-- Presence of db member functions --
;-------------------------------------

local db_funcs = {}

function db_funcs:setup()
  self.db = my_assert( sqlite3.open_memory() )
endfunction

function db_funcs:teardown()
  my_assert(self.db:close())
endfunction

function db_funcs:test()
  local db = self.db
  assert_function( db.close )
  assert_function( db.exec )
;--e  assert_function( db.irows )
  assert_function( db.rows )
;--e  assert_function( db.cols )
;--e  assert_function( db.first_irow )
;--e  assert_function( db.first_row )
;--e  assert_function( db.first_cols )
  assert_function( db.prepare )
  assert_function( db.interrupt )
  assert_function( db.last_insert_rowid )
  assert_function( db.changes )
  assert_function( db.total_changes )
endfunction

debugprint("#### Running 'Database Member Functions' (1 Tests)...")
db_funcs:setup()
db_funcs:test()
db_funcs:teardown()

;---------------------------------------
;-- Presence of stmt member functions --
;---------------------------------------

local stmt_funcs = {}

function stmt_funcs:setup()
  self.db = my_assert( sqlite3.open_memory() )
  self.stmt = my_assert( self.db:prepare("CREATE TABLE test (id, content)") )
endfunction

function stmt_funcs:teardown()
;--e-  assert( self.stmt:close() )
  my_assert( self.stmt:finalize() ) 
  my_assert( self.db:close() )
endfunction

function stmt_funcs:test()
  local stmt = self.stmt
;--e  assert_function( stmt.close )
  assert_function( stmt.reset )
;--e  assert_function( stmt.exec )
  assert_function( stmt.bind )
;--e  assert_function( stmt.irows )
;--e  assert_function( stmt.rows )
;--e  assert_function( stmt.cols )
;--e  assert_function( stmt.first_irow )
;--e  assert_function( stmt.first_row )
;--e  assert_function( stmt.first_cols )
;--e  assert_function( stmt.column_names )
;--e  assert_function( stmt.column_decltypes )
;--e  assert_function( stmt.column_count )
;--e +
  assert_function( stmt.isopen )
  assert_function( stmt.dostep )
  assert_function( stmt.reset )
  assert_function( stmt.finalize )
  assert_function( stmt.columns )
  assert_function( stmt.bind )
  assert_function( stmt.bind_values )
  assert_function( stmt.bind_names )
  assert_function( stmt.bind_blob )
  assert_function( stmt.bind_parameter_count )
  assert_function( stmt.bind_parameter_name )
  assert_function( stmt.get_value )
  assert_function( stmt.get_values )
  assert_function( stmt.get_name )
  assert_function( stmt.get_names )
  assert_function( stmt.get_type )
  assert_function( stmt.get_types )
  assert_function( stmt.get_uvalues )
  assert_function( stmt.get_unames )
  assert_function( stmt.get_utypes )
  assert_function( stmt.get_named_values )
  assert_function( stmt.get_named_types )
  assert_function( stmt.idata )
  assert_function( stmt.inames )
  assert_function( stmt.itypes )
  assert_function( stmt.data )
  assert_function( stmt.type )
;--e +
endfunction

debugprint("#### Running 'Statement Member Functions' (1 Tests)...")
stmt_funcs:setup()
stmt_funcs:test()
stmt_funcs:teardown()

;------------------
;-- Tests basics --
;------------------

local basics = {}

function basics:setup()
  self.db = assert_userdata( sqlite3.open_memory() )
endfunction

function basics:teardown()
  assert_number( self.db:close() )
endfunction

function basics:create_table()
  assert_number( self.db:exec("CREATE TABLE test (id, name)") )
endfunction

function basics:drop_table()
  assert_number( self.db:exec("DROP TABLE test") )
endfunction

function basics:insert(id, name)
  assert_number( self.db:exec("INSERT INTO test VALUES ("..id..", '"..name.."')") )
endfunction

function basics:update(id, name)
  assert_number( self.db:exec("UPDATE test SET name = '"..name.."' WHERE id = "..id) )
endfunction

function basics:test_create_drop()
  self:create_table()
  self:drop_table()
endfunction

function basics:test_multi_create_drop()
  self:create_table()
  self:drop_table()
  self:create_table()
  self:drop_table()
endfunction

function basics:test_insert()
  self:create_table()
  self:insert(1, "Hello World")
  self:insert(2, "Hello Lua")
  self:insert(3, "Hello sqlite3")
endfunction

function basics:test_update()
  self:create_table()
  self:insert(1, "Hello Home")
  self:insert(2, "Hello Lua")
  self:update(1, "Hello World")
endfunction

debugprint("#### Running 'Basics' (4 Tests)...")
basics:setup()
basics:test_create_drop()
basics:test_multi_create_drop()
basics:test_insert()
basics:test_update()
basics:teardown()

;---------------------------------
;-- Statement Column Info Tests --
;---------------------------------

function column_info_test()
  local db = assert_userdata( sqlite3.open_memory() )
  assert_number( db:exec("CREATE TABLE test (id INTEGER, name TEXT)") )
  local stmt = assert_userdata( db:prepare("SELECT * FROM test") )
  
  assert_equal(2, stmt:columns(), "Wrong number of columns." )
  
  local names = assert_table( stmt:get_names() )
  assert_equal(2, listitems(names), "Wrong number of names.")
  assert_equal("id", names[0] )
  assert_equal("name", names[1] )
  
  local types = assert_table( stmt:get_types() )
  assert_equal(2, listitems(types), "Wrong number of declaration types.")
  assert_equal("INTEGER", types[0] )
  assert_equal("TEXT", types[1] )
  
  assert_equal( #SQLITE3_OK, stmt:finalize() )
  assert_equal( #SQLITE3_OK, db:close() )
endfunction

debugprint("#### Running 'Column Info Test' (1 Tests)...")
column_info_test()

;---------------------
;-- Statement Tests --
;---------------------

st = {}

function st:setup()
  self.db = my_assert( sqlite3.open_memory() )
  assert_equal( #SQLITE3_OK, self.db:exec("CREATE TABLE test (id, name)") )
  assert_equal( #SQLITE3_OK, self.db:exec("INSERT INTO test VALUES (1, 'Hello World')") )
  assert_equal( #SQLITE3_OK, self.db:exec("INSERT INTO test VALUES (2, 'Hello Lua')") )
  assert_equal( #SQLITE3_OK, self.db:exec("INSERT INTO test VALUES (3, 'Hello sqlite3')") )
endfunction

function st:teardown()
  assert_equal( #SQLITE3_OK, self.db:close() )
endfunction

function st:check_content(expected)
  
  local stmt = self.db:prepare("SELECT * FROM test ORDER BY id")
  local i = 0
  
  if gettype(stmt) = #nil then return(false)
  
  for row in stmt:rows()
    i = i + 1
    
    if i > listitems(expected) then return(false)  ; "Too many rows"
    if 2 <> listitems(row) then return(false)  ; "Two result column expected."
    if i <> row[0] then return(false)  ; "Wrong 'id'."
    if expected[i-1] <> row[1] then return(false) ; "Wrong 'name'."
  next
  
  if listitems(expected) <> i then return(false) ;"Too few rows."
  if gettype(stmt:finalize()) <> #number then return(false)  ;"number expected"
  
  return(true)
  	
endfunction

function st:test_setup()
  assert_pass(function() return(self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3" })) endfunction)
  assert_error(function() return(self:check_content({ "Hello World", "Hello Lua" })) endfunction)
  assert_error(function() return(self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "To much" })) endfunction)
  assert_error(function() return(self:check_content({ "Hello World", "Hello Lua", "Wrong" })) endfunction)
  assert_error(function() return(self:check_content({ "Hello World", "Wrong", "Hello sqlite3" })) endfunction)
  assert_error(function() return(self:check_content({ "Wrong", "Hello Lua", "Hello sqlite3" })) endfunction)
endfunction

function st:test_questionmark_args()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (?, ?)")  )
  assert_number( stmt:bind_values(0, "Test") )
; AIRSOFT: can't test these because ExitOnError() currently doesn't allow us to intercept argument errors!
;  assert_error(function() return(iif(stmt:bind_values("To few") = #SQLITE3_OK, true, false)) endfunction)
;  assert_error(function() return(iif(stmt:bind_values(0, "Test", "To many") = #SQLITE3_OK, true, false)) endfunction)
endfunction

function st:test_questionmark()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (?, ?)")  )
  assert_number( stmt:bind_values(4, "Good morning") )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning" })
  assert_number( stmt:bind_values(5, "Foo Bar") )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning", "Foo Bar" })
  assert_number( stmt:finalize() )
endfunction

function st:test_identifiers()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (:id, :name)")  )
  assert_number( stmt:bind_values(4, "Good morning") )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning" })
  assert_number( stmt:bind_values(5, "Foo Bar") )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning", "Foo Bar" })
  assert_number( stmt:finalize() )
endfunction

function st:test_identifiers_names()
  ;local stmt = assert_userdata( self.db:prepare({"name", "id"}, "INSERT INTO test VALUES (:id, $name)")  )
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (:id, $name)")  )
  assert_number( stmt:bind_names({name="Good morning", id=4}) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning" })
  assert_number( stmt:bind_names({name="Foo Bar", id=5}) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning", "Foo Bar" })
  assert_number( stmt:finalize() )
endfunction

function st:test_colon_identifiers_names()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (:id, :name)")  )
  assert_number( stmt:bind_names({name="Good morning", id=4}) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning" })
  assert_number( stmt:bind_names({name="Foo Bar", id=5}) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3", "Good morning", "Foo Bar" })
  assert_number( stmt:finalize() )
endfunction

function st:test_bind_by_names()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES (:id, :name)")  )
  local args = { }
  args.id = 5
  args.name = "Hello girls"
  my_assert( stmt:bind_names(args) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  args.id = 4
  args.name = "Hello boys"
  my_assert( stmt:bind_names(args) )
  assert_number( stmt:dostep() )
  assert_number( stmt:reset() )
  self:check_content({ "Hello World", "Hello Lua", "Hello sqlite3",  "Hello boys", "Hello girls" })
  assert_number( stmt:finalize() )
endfunction

debugprint("#### Running 'Statement Tests' (7 Tests)...")
st:setup()
st:test_setup()
st:test_questionmark_args()
st:test_questionmark()
st:test_identifiers()
st:test_identifiers_names()
st:test_colon_identifiers_names()
st:test_bind_by_names()
st:teardown()

;--------------------------------
;-- Tests binding of arguments --
;--------------------------------

b = {}

function b:setup()
  self.db = my_assert( sqlite3.open_memory() )
  assert_number( self.db:exec("CREATE TABLE test (id, name, u, v, w, x, y, z)") )
endfunction

function b:teardown()
  assert_number( self.db:close() )
endfunction

function b:test_auto_parameter_names()
  local stmt = assert_userdata( self.db:prepare("INSERT INTO test VALUES($a, $b, $a2, $b2, $a, $b, $a3, $b3)") )
  local parameters = assert_number( stmt:bind_parameter_count() )
  assert_equal( 6, parameters )
  assert_equal( "$a", stmt:bind_parameter_name(1) )
  assert_equal( "$b", stmt:bind_parameter_name(2) )
  assert_equal( "$a2", stmt:bind_parameter_name(3) )
  assert_equal( "$b2", stmt:bind_parameter_name(4) )
  assert_equal( "$a3", stmt:bind_parameter_name(5) )
  assert_equal( "$b3", stmt:bind_parameter_name(6) )
endfunction

function b:test_no_parameter_names_1()
  local stmt = assert_userdata( self.db:prepare([[ SELECT * FROM test ]]))
  local parameters = assert_number( stmt:bind_parameter_count() )
  assert_equal( 0, (parameters) )
endfunction

function b:test_no_parameter_names_2()
  local stmt = assert_userdata( self.db:prepare([[ INSERT INTO test VALUES(?, ?, ?, ?, ?, ?, ?, ?) ]]))
  local parameters = assert_number( stmt:bind_parameter_count() )
  assert_equal( 8, (parameters) )
  assert_nil( stmt:bind_parameter_name(1) )
endfunction

debugprint("#### Running 'Binding Tests' (3 Tests)...")

b:setup()
b:test_auto_parameter_names()
b:test_no_parameter_names_1()
b:test_no_parameter_names_2()
b:teardown()

;----------------------------
;-- Test for bugs reported --
;----------------------------

bug = {}

function bug:setup()
  self.db = my_assert( sqlite3.open_memory() )
endfunction

function bug:teardown()
  assert_number( self.db:close() )
endfunction

function bug:test_nils()   ;-- appeared in lua-5.1 (holes in arrays)
  local function check(arg1, arg2, arg3, arg4, arg5)
    assert_equal(1, arg1)
    assert_equal(2, arg2)
    assert_nil(arg3)
    assert_equal(4, arg4)
    assert_nil(arg5)
  endfunction
  
  self.db:create_function("test_nils", 5, function(arg1, arg2, arg3, arg4, arg5)
    check(arg1, arg2, arg3, arg4, arg5)
  endfunction, {})
  
  assert_number( self.db:exec([[ SELECT test_nils(1, 2, NULL, 4, NULL) ]]) )
  
  for arg1, arg2, arg3, arg4, arg5 in self.db:urows([[ SELECT 1, 2, NULL, 4, NULL ]])
  	check(arg1, arg2, arg3, arg4, arg5) 
  next
  
  for row in self.db:rows([[ SELECT 1, 2, NULL, 4, NULL ]])
     assert_table( row ) 
     check(row[0], row[1], nil, row[3], nil)
  next
endfunction

debugprint("#### Running 'Bug-Report Tests' (1 Tests)...")

bug:setup()
bug:test_nils()
bug:teardown()

;----------------------------
;-- Test for collation fun --
;----------------------------

colla = {}

function colla:setup()
    local function collate(s1,s2)
	; if p then print("collation callback: ",s1,s2) end
	s1=lowerstr(s1)
	s2=lowerstr(s2)
	if s1=s2
	  return(0)
	elseif s1<s2
	  return(-1)
	else
	  return(1)
	endif  
    endfunction
    self.db = my_assert( sqlite3.open_memory() )
    assert_nil(self.db:create_collation("CINSENS",collate))
    self.db:exec([[
      CREATE TABLE test(id INTEGER PRIMARY KEY,content COLLATE CINSENS);
      INSERT INTO test VALUES(NULL,'hello world');
      INSERT INTO test VALUES(NULL,'Buenos dias');
      INSERT INTO test VALUES(NULL,'HELLO WORLD');
      INSERT INTO test VALUES(NULL,'Guten Tag');
      INSERT INTO test VALUES(NULL,'HeLlO WoRlD');
      INSERT INTO test VALUES(NULL,'Bye for now');
    ]])
endfunction

function colla:teardown()
  assert_number( self.db:close() )
endfunction

function colla:test()
    ;--for row in db:nrows('SELECT * FROM test') do
    ;--  print(row.id,row.content)
    ;--end
    local n = 0
    for row in self.db:nrows("SELECT * FROM test WHERE content=\"hElLo wOrLd\"")
      ;-- print(row.id,row.content)
      assert_equal (lowerstr(row.content), "hello world")
      n = n + 1
    next
    assert_equal (n, 3)
endfunction

debugprint("#### Running 'Collation Tests' (1 Tests)...")
colla:setup()
colla:test()
colla:teardown()

end


