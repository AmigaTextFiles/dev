<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hw_GetARGBBrush</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hw_GetARGBBrush -- get raw brush pixels (V5.2)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
ULONG *rgb = hw_GetARGBBrush(lua_ID *id, struct hwTagList *tags);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function can be used to get a copy of the specified brush's pixels. In contrast
to <a href="hw_LockBrush.html">hw_LockBrush()</a> <code>hw_GetARGBBrush()</code> will convert the pixels
to the 32-bit ARGB format automatically and it will also mix any potential alpha
channel or monochrome transparency mask into the pixel map. All this is of course
overhead which makes <code>hw_GetARGBBrush()</code> slower than <a href="hw_LockBrush.html">hw_LockBrush()</a>.
You have to pass the object identifier of the brush whose pixels you want to obtain.
The object identifier must be passed as a <code>lua_ID</code>. See <a href="LuaID.html">Object identifiers</a> for details.

<p>
Additionally, you can specify a taglist in the second parameter. The following tags
are currently recognized:

<p>
<dl>
<dt class="codelist"><code>HWGAB_WIDTH:</code></dt>
<dd>
If you specify this tag, you must set its <code>pData</code> member to a pointer to
an <code>int</code>. <code>hw_GetARGBBrush()</code> will then write the brush's width in pixels to this <code>int</code>.

<p>
</dd>
<dt class="codelist"><code>HWGAB_HEIGHT:</code></dt>
<dd>
If you specify this tag, you must set its <code>pData</code> member to a pointer to
an <code>int</code>. <code>hw_GetARGBBrush()</code> will then write the brush's height in pixels to this <code>int</code>.

<p>
</dd>
<dt class="codelist"><code>HWGAB_OPAQUE:</code></dt>
<dd>
If you specify this tag, you must set its <code>pData</code> member to a pointer to
an <code>int</code>. <code>hw_GetARGBBrush()</code> will then write <code>True</code> to this <code>int</code> if the brush doesn't
have a mask or an alpha channel, or <code>False</code> otherwise.

<p>
</dd>
<dt class="codelist"><code>HWGAB_FLAGS:</code></dt>
<dd>
This tag allows you to specify some flags for <code>hw_GetARGBBrush()</code>. The <code>iData</code> member
of this tag must be set to a <code>ULONG</code> containing one or more of the following flags:

<p>
<dl>
<dt class="codelist"><code>HWGABFLAGS_SCALE:</code></dt>
<dd>
If this flag is set, the brush will automatically be scaled by the current monitor's
scaling coefficient. This can be useful for supporting high DPI systems.

<p>
</dd>
<dt class="codelist"><code>HWGABFLAGS_INTERPOLATE:</code></dt>
<dd>
If <code>hw_GetARGBBrush()</code> scales the brush pixels because <code>HWGABFLAGS_SCALE</code> is set, you can
activate bilinear interpolation by setting this flag.
</dd></dl>

<p>
(V8.0)
</dd></dl>

<p>
Note that currently you always have to pass a taglist to this function as it does
not check against <code>NULL</code>. So just pass an empty taglist if you don't need to use
any of the tags above.

<p>
Please note that alpha byte will always be set, even if the brush doesn't have
any transparency information. In that case the alpha byte for every pixel will be
set to 255, i.e. fully opaque.

<p>
The memory buffer that is returned by this function must be freed by using the
<a href="hw_FreeARGBBrush.html">hw_FreeARGBBrush()</a> function. See <a href="hw_FreeARGBBrush.html">hw_FreeARGBBrush</a> for details.

<p>
Note that <code>hw_GetARGBBrush()</code> can only be used with software brushes. It is not possible
to get the raw pixels of hardware brushes.

<p>
</dd>
<dt class="autodoc"><b>Designer compatibility</b></dt><dd>
Unsupported

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>id</i></dt>
<dd>object identifier of brush whose pixels you want to get</dd>
<dt><i>tags</i></dt>
<dd>pointer to a taglist specifying additional options (see above); this
must not be <code>NULL</code></dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>rgb</i></dt>
<dd>raw 32-bit ARGB pixel buffer or <code>NULL</code> on error</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="hw_GetARGBBrush_.html" target="_top">Show TOC</a></font>
</body>
</html>