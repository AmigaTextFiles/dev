<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>Differences between Hollywood and Lua</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<h2 class="heading">2.16 Differences between Hollywood and Lua</h2>

<p>
If you plan to write plugins that extend Hollywood's script language by installing
new commands and constants, you will have to deal with the Lua VM which is at the
heart of Hollywood. Hollywood uses Lua 5.0.2 as its virtual machine but with major
modifications. Here is a non-exhaustive list of the differences between Lua 5.0.2
and Hollywood:

<p>
<ol>
<li>At a first glance, Hollywood in contrast to Lua does not seem to distinguish between
lower and upper case characters for keywords, preprocessor commands, variable, function,
and constant names. You can mix upper and lower case characters any way you please.
Internally, however, Hollywood still does the distinction between upper and lower
case in true Lua fashion. The reason why you don't notice this, is because Hollywood's
parser converts everything to lower case when it parses your script so all the differences
are levelled at parsing time already and you don't have to care about upper and lower case
characters when writing your script. However, if you write a plugin and you push
elements into the stack or pop them from the stack, you need to be very careful that
you use lower case strings only when describing these elements. Otherwise the user won't
be able to access the elements that you have pushed or you won't be able to access the elements the user
has pushed because internally Hollywood still distinguishes between upper and lower
case characters. This must be kept in mind when writing plugins that push/pop stack
elements. Always use lower case characters for everything and your plugin will fit
in just fine.

<p>
</li><li>The handling of <code>Nil</code> is different between Hollywood and Lua. Comparing 0 against
<code>Nil</code> will be <code>True</code> in Hollywood, but <code>False</code> in Lua. This change has been made to allow
you to work with uninitialiazed variables. If you pass an uninitialized, i.e. a <code>Nil</code>
variable to a function or you use an uninitialized variable in an equation, Hollywood
will just treat this uninitialized variable as if its value was 0. Lua, on the other hand,
will fail if you try do arithmetics with <code>Nil</code> variables or pass a <code>Nil</code> variable to a
function which expects a numerical value. Hollywood will just assume a numerical value of
0 for all uninitialized variables. The only exception from this rule is with table
elements. Hollywood will fail if you try to index table elements that are <code>Nil</code>. It will
not automatically assume 0 for them. That is why you have to explicitly initialize all
table elements you want to use. Variables, on the other hand, don't have to be initialized
explicitly. You can just use them and if they are still <code>Nil</code>, Hollywood will assume they
are 0.

<p>
</li><li>Hollywood does not support the boolean object type. In Hollywood, the values
<code>True</code> and <code>False</code> are simply special constants that will be mapped to the numerical
values 1 and 0 respectively. There is no special object type for boolean values. This
means that comparing 0 against <code>False</code> will be <code>True</code> in Hollywood, whereas in Lua it
would be <code>False</code> because you would be comparing two different object types. Internally,
Lua's boolean API is still supported by the VM and your plugin could use the respective
functions from <a href="LuaBaseOverview.html">LuaBase</a> but this is not recommended since
Hollywood itself will never use Lua's boolean object type. It will always just use
numbers. Not to mention that it is impossible to pass a real Lua boolean value to
one of your plugin's functions because the parser will map all the <code>True</code> and <code>False</code>
keywords to plain numbers.

<p>
</li><li>The syntax is different. Whereas Lua uses the <code>end</code> keyword to close all kinds
of different scopes, Hollywood has scope-dependent closing keywords like <code>Wend</code>, <code>Next</code>,
<code>EndIf</code> and so on to make script files better readable.

<p>
</li><li>The operators are different. For example, Lua uses <code>~=</code> for the <code>not equal</code>
operator whereas Hollywood uses <code>&lt;&gt;</code>. Hollywood also supports much more operators
than Lua does. For example, Hollywood comes with a variety of bitwise operators that
Lua is missing entirely.

<p>
</li><li>Lua uses 1-based tables and arrays whereas in Hollywood they are 0-based as
in almost every other programming language. Though 1-based arrays might make more sense
from a strictly logical point of view, 0-based arrays are the de facto standard in
the programming world.

<p>
</li><li>Hollywood's preprocessor has support for preprocessor commands, e.g. <code>@BRUSH</code>
or <code>@INCLUDE</code>. Preprocessor commands are prefixed by the at character (@).

<p>
</li><li>Hollywood supports constants. Constants are always prefixed by the hash tag
(#).

<p>
</li><li>Hollywood supports additional program flow statements like <code>Repeat/Until</code> and
<code>Switch/EndSwitch</code>.

<p>
</li><li>Hollywood still supports labels and <code>Goto()</code> and <code>Gosub()</code>, although this is
considered obsolete and is only included for compatibility with Hollywood 1.x.

<p>
</li><li>Hollywood has a <code>continue</code> statement.

<p>
</li><li>Hollywood introduces a new data type named <code>lua_ID</code> and the functions <a href="luaL_checkid.html">luaL_checkid()</a>
and <a href="luaL_checknewid.html">luaL_checknewid()</a> to deal with its object identifiers.
See <a href="LuaID.html">Object identifiers</a> for details.

<p>
</li><li>There is a difference in the error handling when writing C functions that are
callable from Lua. If an error occurs in a C function with Lua 5.0.2, your C function
has to call the <code>luaL_error()</code> function which will directly jump to Lua's error handler.
In Hollywood, however, you have to return an error code from your C function to indicate
that an error has occurred. If that is not possible for some reason, you may also call
<a href="lua_throwerror.html">lua_throwerror()</a> to jump directly into Hollywood's error handler
but the recommended way is returning an error code. The reason for this design is that
working with error codes is preferable to doing a <code>longjmp()</code> because it gives your
code a chance to free resources before it error-exits. Note that Lua functions like
<code>luaL_checklstring()</code> and <code>luaL_checknumber()</code> will still jump into the error handler
directly, so be prepared to deal with this.
</li></ol>

<p>
See <a href="LibraryOverview.html">Library plugins</a> for details.

<p>
See <a href="LuaBaseOverview.html">LuaBase</a> for details.

<p>
<hr>
<font size=-2><a href="LuaVSHollywood_.html" target="_top">Show TOC</a></font>
</body>
</html>