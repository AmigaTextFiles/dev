<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>RenderText</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
RenderText -- draw text string (V10.0)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
int error = RenderText(APTR handle, STRPTR str, int count, int encoding,
                struct hwRenderTextCtrl *pt, struct hwMatrix2D *m, struct
                hwTextLayout *tl, struct hwTagList *tags);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function must draw the text passed in <code>str</code> using the font passed in <code>handle</code>.
Note that <code>str</code> is not null-terminated. Instead, the string's length in bytes is
passed in the <code>count</code> parameter. The <code>encoding</code> parameter specifies the character
encoding of the string. This will be either <code>HWOS_ENCODING_UTF8</code> or <code>HWOS_ENCODING_ISO8859_1</code>.

<p>
If the plugin hasn't set the <code>HWFONTFLAGS_LAYOUT</code> flag for the font in its <a href="LoadFont.html">LoadFont()</a>
implementation, the string passed in <code>str</code> will never contain any line breaks. Handling line
breaks is only necessary if your plugin has requested to do its own layouting by setting the
<code>HWFONTFLAGS_LAYOUT</code> flag in <a href="LoadFont.html">LoadFont()</a>.

<p>
The drawing target is passed to <code>RenderText()</code> in the <code>pt</code> parameter. This is a
pointer to a <code>struct hwRenderTextCtrl</code> describing a drawing target.
<code>struct hwRenderTextCtrl</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwRenderTextCtrl
{
    int X;             [in]
    int Y;             [in]
    int Width;         [in]
    int Height;        [in]
    APTR RGBData;      [in]
    int RGBModulo;     [in]
    UBYTE *AlphaData;  [in]
    int AlphaModulo;   [in]
    UBYTE *MaskData;   [in]
    int MaskModulo;    [in]
    UBYTE *CLUTData;   [in]
    int CLUTModulo;    [in]
    int PixelFormat;   [in]
    int BytesPerPixel; [in]
};
</pre></td></tr></table><p>

Here is a description of the individual structure members:

<p>
<dl>
<dt class="codelist"><code>X:</code></dt>
<dd>
This specifies the x-offset you should draw to in the target buffer. An offset of 0 means
the leftmost column.

<p>
</dd>
<dt class="codelist"><code>Y:</code></dt>
<dd>
This specifies the y-offset you should draw to in the target buffer. An offset of 0 means
the topmost row.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
This will be set to the target buffer's pixel width, without any row padding.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
This will be set to the target buffer's pixel height.

<p>
</dd>
<dt class="codelist"><code>RGBData:</code></dt>
<dd>
If the font's color depth has been set to more than 8 in <a href="LoadFont.html">LoadFont()</a>, this member
will be set to a pointer to the raw RGB pixel data to draw to. The actual format used
by the individual pixels is defined by the <code>PixelFormat</code> member. Please note that
even if <code>PixelFormat</code> specifies a 32-bit format with alpha channel, you must never draw
any alpha channel pixels to <code>RGBData</code> because Hollywood always stores the alpha channel
separately in order to be compatible with 15-bit and 16-bit screenmodes. See <a href="BitmapInfo.html">Bitmap information</a> for details.
You always need to draw the alpha channel pixels to the buffer passed in <code>AlphaData</code>
instead.

<p>
</dd>
<dt class="codelist"><code>RGBModulo:</code></dt>
<dd>
If <code>RGBData</code> is non-<code>NULL</code>, this will contain the number of pixels in a single row in
the <code>RGBData</code> buffer. This can be more than returned in <code>Width</code> because Hollywood might
choose to allocate some padding bytes for optimized blitting. Note that the value
returned in <code>RGBModulo</code> is specified in pixels, not in bytes.

<p>
</dd>
<dt class="codelist"><code>AlphaData:</code></dt>
<dd>
This member will be set in the following two cases:

<p>
<ol>
<li>The font is an RGB color font. In that case you have to draw the color channels
to the buffer passed in <code>RGBData</code> and the alpha channel pixels to the buffer passed in
<code>AlphaData</code>.
</li><li>The text should be drawn with anti-aliasing. In that case you only have to draw
to the buffer passed in <code>AlphaData</code>.
</li></ol>

<p>
In all other cases <code>AlphaData</code> will be <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>AlphaModulo:</code></dt>
<dd>
If <code>AlphaData</code> is non-<code>NULL</code>, this member will be set to the number of pixels stored in
one row of the <code>AlphaData</code> array. This can be more than what is returned in the <code>Width</code>
member because Hollywood might use padding bytes for optimized blitting.

<p>
</dd>
<dt class="codelist"><code>MaskData:</code></dt>
<dd>
You have to draw to this buffer in case the font's color depth has been set to 1 or
the font's color depth has been set to 8 and anti-aliasing is turned off. In both
cases, <code>MaskData</code> will be set to a buffer you need to draw to. Otherwise it is set to
<code>NULL</code>. The data you write to this buffer is interpreted as a monochrome bitmap where
set bits indicate visible pixels and cleared bits indicate invisible pixels. The bits
are stored from left to right in chunks of one byte, i.e. the most significant bit of
the first byte describes the state of the first pixel.

<p>
</dd>
<dt class="codelist"><code>MaskModulo:</code></dt>
<dd>
If <code>MaskData</code> is non-<code>NULL</code>, this member will be set to the number of bytes that is
used for one row of mask data. Note that this value is specified in bytes and often
contains some padding.

<p>
</dd>
<dt class="codelist"><code>CLUTData:</code></dt>
<dd>
You have to draw to this buffer in case the font uses a color palette. Otherwise
this member will be <code>NULL</code>. Note that pixels will always be stored as 8 bits per pixel,
even if the font palette's depth is less than 8.

<p>
</dd>
<dt class="codelist"><code>CLUTModulo:</code></dt>
<dd>
If <code>CLUTData</code> is non-<code>NULL</code>, this will be set to the number of pixels per row. This can
be more than what is returned in the <code>Width</code> member because Hollywood might use padding
bytes for optimized blitting.

<p>
</dd>
<dt class="codelist"><code>PixelFormat:</code></dt>
<dd>
This member is set to the pixel format used by the pixels written to the
<code>RGBData</code> member. See <a href="PixelFormats.html">Pixel format information</a> for details.

<p>
</dd>
<dt class="codelist"><code>BytesPerPixel:</code></dt>
<dd>
This will be set to the number of bytes that are needed to represent one pixel
in the <code>RGBData</code> array.
</dd></dl>

<p>
The <code>m</code> parameter may be set to a pointer to a 2D transformation matrix that should
be applied to the text before drawing. If can also be <code>NULL</code> which means the identity
matrix should be used. Note that <code>m</code> will only ever be set if the font is a vector
font and if the plugin has requested to do its own layouting by setting the
<code>HWFONTFLAGS_LAYOUT</code> flag in <a href="LoadFont.html">LoadFont()</a>.

<p>
The <code>tl</code> parameter contains a pointer to a <code>struct hwTextLayout</code>. This
structure contains detailed information about the text layout. Most of the
structure members are only initialized for fonts that have requested to do
their own layouting by setting the <code>HWFONTFLAGS_LAYOUT</code> flag in <a href="LoadFont.html">LoadFont()</a>.
The only structure members that are supported for fonts that haven't set
<code>HWFONTFLAGS_LAYOUT</code> are <code>CharSpacing</code> and <code>Style</code> but the only style flag that
can be set for fonts that haven't set <code>HWFONTFLAGS_LAYOUT</code> is <code>HWFONTSTYLE_ANTIALIAS</code>.

<p>
<code>struct hwTextLayout</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwTextLayout
{
    ULONG Color;     [in]
    ULONG Style;     [in]
    int Align;       [in]
    int WrapWidth;   [in]
    int LineSpacing; [in]
    int CharSpacing; [in]
    int Indent;      [in]
    int AdvanceX;    [out]
    int AdvanceY;    [out]
    int *Tabs;       [in]
    int TabCount;    [in]
};
</pre></td></tr></table><p>

Here is a description of the individual structure members:

<p>
<dl>
<dt class="codelist"><code>Color:</code></dt>
<dd>
The desired font color as an RGB value.

<p>
</dd>
<dt class="codelist"><code>Style:</code></dt>
<dd>
A bit combination of style flags. The following style flags are currently
defined:

<p>
<dl>
<dt class="codelist"><code>HWFONTSTYLE_ANTIALIAS:</code></dt>
<dd>
Use anti-aliasing.

<p>
</dd>
<dt class="codelist"><code>HWFONTSTYLE_BOLD:</code></dt>
<dd>
Bold text.

<p>
</dd>
<dt class="codelist"><code>HWFONTSTYLE_ITALIC:</code></dt>
<dd>
Italic text.

<p>
</dd>
<dt class="codelist"><code>HWFONTSTYLE_UNDERLINED:</code></dt>
<dd>
Underlined text.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>Align:</code></dt>
<dd>
The desired text alignment. This can be one of the following alignment
types:

<p>
<dl>
<dt class="codelist"><code>HWTEXTALIGN_LEFT:</code></dt>
<dd>
Left alignment.

<p>
</dd>
<dt class="codelist"><code>HWTEXTALIGN_RIGHT:</code></dt>
<dd>
Right alignment.

<p>
</dd>
<dt class="codelist"><code>HWTEXTALIGN_CENTER:</code></dt>
<dd>
Centered alignment.

<p>
</dd>
<dt class="codelist"><code>HWTEXTALIGN_JUSTIFIED:</code></dt>
<dd>
Justified alignment.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>WrapWidth:</code></dt>
<dd>
The maximum number of pixels per line. If a word exceeds this number of pixels,
it should be moved to the next line. If this is 0, then no wordwrapping should
take place.

<p>
</dd>
<dt class="codelist"><code>LineSpacing:</code></dt>
<dd>
Adjustment pixels between lines. This can be a positive or negative
value. A negative value moves lines closer together, whereas a positive value
increases the spacing between lines. A value of 0 means no custom line adjustment.

<p>
</dd>
<dt class="codelist"><code>CharSpacing:</code></dt>
<dd>
Adjustment pixels between characters. This can be a positive or negative
value. A negative value moves characters closer together, whereas a positive value
increases the spacing between characters. A value of 0 means no custom character
adjustment.

<p>
</dd>
<dt class="codelist"><code>Indent:</code></dt>
<dd>
The indentation in pixels for the very first line of text. If this is greater than 0,
text on the very first line should be indented by this number of pixels.

<p>
</dd>
<dt class="codelist"><code>AdvanceX:</code></dt>
<dd>
This must be set to the number of pixels the cursor should be advanced horizontally
after drawing the text.

<p>
</dd>
<dt class="codelist"><code>AdvanceY:</code></dt>
<dd>
This must be set to the number of pixels the cursor should be advanced vertically
after drawing the text.

<p>
</dd>
<dt class="codelist"><code>Tabs:</code></dt>
<dd>
An integer array containing a number of tab stops. Whenever a tab character is
encountered, your text layouter should advance to the next tab stop. The number of
tab stops in the <code>Tabs</code> array is indicated by the <code>TabCount</code> member (see below).
Note that this can also be <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>TabCount:</code></dt>
<dd>
Number of tab stops in the <code>Tab</code> member (see above).
</dd></dl>

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>handle</i></dt>
<dd>the font handle allocated by <a href="LoadFont.html">LoadFont()</a></dd>
<dt><i>str</i></dt>
<dd>text to draw (this is not null-terminated!)</dd>
<dt><i>count</i></dt>
<dd>length of the text to draw in bytes</dd>
<dt><i>encoding</i></dt>
<dd>character encoding of the text (see above)</dd>
<dt><i>pt</i></dt>
<dd>pointer to a <code>struct hwRenderTextCtrl</code> containing information about the drawing target</dd>
<dt><i>m</i></dt>
<dd>pointer to a 2D transformation matrix that should be applied before drawing or <code>NULL</code></dd>
<dt><i>tl</i></dt>
<dd>pointer to a <code>struct hwTextLayout</code> that contains layout information</dd>
<dt><i>tags</i></dt>
<dd>tag list containing further options or <code>NULL</code></dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>error</i></dt>
<dd>error code or 0 for success</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="RenderText_.html" target="_top">Show TOC</a></font>
</body>
</html>