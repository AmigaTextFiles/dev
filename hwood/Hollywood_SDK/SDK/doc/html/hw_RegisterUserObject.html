<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hw_RegisterUserObject</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hw_RegisterUserObject -- register a new object type (V5.3)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
int id = hw_RegisterUserObject(lua_State *L, STRPTR name,
                struct hwObjectList **list,
                int (*attrfunc)(lua_State *L, int attr, lua_ID *id));</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function allows you to register a new object type with Hollywood. The user
will then be able to use all of Hollywood's object functions with your new type.
For example, it is possible to associate custom data with Hollywood objects by
using the <code>SetObjectData()</code> function and it is possible to query object attributes
by calling the <code>GetAttribute()</code> Hollywood function. Additionally, all registered
object types will also appear in Hollywood's resource monitor.

<p>
<code>hw_RegisterUserObject()</code> will return an identifier for the new object type or 0
in case of an error.

<p>
The name you pass to <code>hw_RegisterUserObject()</code> may contain spaces and non-ASCII
characters as it is only used by Hollywood's resource monitor.

<p>
You have to pass a pointer to a pointer that marks the start of an object list
to this function. Each list node must start with a <code>struct hwObjectList</code>
item so that Hollywood can iterate the list and find objects in it on its own.
<code>struct hwObjectList</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwObjectListHeader
{
    int type;
    lua_ID id;
    APTR reserved;
};

struct hwObjectList
{
    struct hwObjectListHeader hdr;
    struct hwObjectList *succ;
    // ... your private data must follow here ...
};
</pre></td></tr></table><p>

Whenever you add a new Hollywood object, you need to initialize the following
members:

<p>
<dl>
<dt class="codelist"><code>type:</code></dt>
<dd>
This member must be set to the object's identifier returned by <code>hw_RegisterUserObject()</code>.

<p>
</dd>
<dt class="codelist"><code>id:</code></dt>
<dd>
This member must be set to the <code>lua_ID</code> of this object. Hollywood objects can use two
different kinds of identifiers: They can either use a numerical identifier or an
automatically chosen identifier that uses the <code>LUA_TLIGHTUSERDATA</code> object type. The user
can request an automatically chosen identifier by passing <code>Nil</code> as the desired identifier
when creating the object. In that case, the plugin should automatically choose an
identifier for the object and return it. This is usually done by using the raw memory
pointer to the newly allocated object as an identifier because this guarantees its
uniqueness. Internally, the two different kinds of identifiers are managed using the
<code>lua_ID</code> structure which looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>typedef struct _lua_ID
{
    int num;
    void *ptr;
} lua_ID;
</pre></td></tr></table><p>

When adding a new object, the two structure members must be initialized like this:

<p>
<dl>
<dt class="codelist"><code>num:</code></dt>
<dd>
If the object is to use a numerical identifier, you need to write this identifier
to <code>num</code> and set the <code>ptr</code> member to <code>NULL</code>. If the <code>ptr</code> member is not <code>NULL</code>, Hollywood
will ignore whatever is in <code>num</code> so don't forget to set <code>ptr</code> to <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>ptr:</code></dt>
<dd>
If the object has been created using automatic ID selection, you need to set this
member to the identifier that this object should use. This is typically set to the
raw memory pointer of the newly allocated object. If <code>ptr</code> is <code>NULL</code>, Hollywood will
automatically use the numerical identifier specified in <code>num</code>.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>reserved:</code></dt>
<dd>
Reserved for future use. Must be <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>succ:</code></dt>
<dd>
This must point to the next object in the list or it must be <code>NULL</code> in case the object
is the last one. Whenever you create a new object, make sure to chain it into the
list of objects that you passed to <code>hw_RegisterUserObject()</code>.
</dd></dl>

<p>
You also have to pass a pointer to a function that is called whenever the user calls
<code>GetAttribute()</code> on your object type. Hollywood will handle the <code>#ATTRCOUNT</code> attribute
automatically for your object type but for all other attributes, Hollywood will simply
run the callback you specified when registering the new object type. The callback then
has to push the return value(s) for this attribute on the stack and return the number of
values actually pushed or an error code, just like a standard Lua function would do. See
below for an example implementation.

<p>
Note that all of Hollywood's inbuilt objects use constant identifiers defined by inbuilt
object constants like <code>#BRUSH</code>, <code>#ANIM</code>, or <code>#VIDEO</code>. User objects, however, use dynamic object
identifiers that are determined at runtime by <code>hw_RegisterUserObject()</code>. They can be
different every time Hollywood is run. That is why you should never create constants
to refer to your user objects because constant values will be hard-coded in applets
when scripts are compiled so there can be conflicts if <code>hw_RegisterUserObject()</code> returns
an identifier that is different from the constant definition. The recommended way
of dealing with user object identifiers is to implement a function named <code>GetObjectType()</code>
which returns the dynamic object identifier to the script.

<p>
An example implementation could look like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct myobj
{
    struct hwObjectList list;

    // store your object data here
    ...
};

// the actual identifier will be determined at runtime by
// hw_RegisterUserObject()
static int MY_OBJECT_TYPE = 0;

// our list of objects
static struct myobj *firstobj = NULL;

// this function is called whenever the user calls GetAttribute()
// on our user object
static SAVEDS int attrfunc(lua_State *L, int attr, lua_ID *id)
{
    struct myobj *o;

    // first find the object in our list
    for(o = firstobj; o; o = o-&gt;list.succ) {
        if(id-&gt;num == o-&gt;list.hdr.id.num &amp;&amp;
           id-&gt;ptr == o-&gt;list.hdr.id.ptr) break;
    }

    // not found? --&gt; error out!
    if(!o) return ERR_FINDOBJECT;

    // check attribute that should be queried and push return values
    switch(attr) {
    case MYATTRONE:
        lua_pushnumber(L, ...);
        return 1;
    }

    // unknown attribute
    return ERR_UNKNOWNATTR;
}

HW_EXPORT int InitLibrary(lua_State *L)
{
    // register our new object type
    MY_OBJECT_TYPE = hw_RegisterUserObject(L, &quot;MyObject&quot;,
                        (struct hwObjectList **) &amp;firstobj, attrfunc);

    return 0;
}

HW_EXPORT void FreeLibrary(lua_State *L)
{
    struct myobj *o, *succ;

    // do not forget to see if there are any objects that
    // the user hasn't freed yet on exit --&gt; otherwise you
    // will leak memory

    for(o = firstobj; o; o = succ) {
        o = o-&gt;list.succ;
        freeobject(L, o);
        free(o);
    }
}

// this function is important because the actual object identifier
// can be different each time Hollywood is run
static SAVEDS int my_GetObjectType(lua_State *L)
{
    lua_pushnumber(L, MY_OBJECT_TYPE);
    return 1;
}

static SAVEDS int my_CreateObject(lua_State *L)
{
    struct myobj *o, *prev = NULL;
    lua_ID id;

    // this will check whether the user passed a number in
    // parameter 1 or nil if he passed nil, luaL_checknewid()
    // will set id.ptr to ((void *) 1)
    luaL_checknewid(L, 1, &amp;id);

    if(!id.ptr) {
        // must check if there already is an object with this
        // id and free it
        ...
    }

    for(o = firstobj; o; o = o-&gt;list.succ) prev = o;

    // allocate new object
    if(!(o = calloc(sizeof(struct myobj), 1))) return ERR_MEM;

    // additional initialization to be done here
    ...

    // make sure to chain our object into the list
    if(!prev) {
        firstobj = o;
    } else {
        prev-&gt;list.succ = o;
    }

    // if the user wants automatic id selection, we need to set id.ptr
    // to our object and push it as light user data on the stack
    if(id.ptr) {
        id.ptr = o;
        lua_pushlightuserdata(L, id.ptr);
    }

    // don't forget to initialize the hwObjectList header
    pdf-&gt;list.hdr.type = MY_OBJECT_TYPE;
    pdf-&gt;list.hdr.id = id;

    // returns 1 if the user wants automatic id selection because in
    // that case there will be one return value; otherwise there won't
    // be any return values
    return (id.ptr != NULL);
}

static SAVEDS int my_FreeObject(lua_State *L)
{
    struct myobj *o, *prev = NULL;
    lua_ID id;

    // check whether the user passed a number or a light userdata
    // parameter
    luaL_checkid(L, 1, &amp;id);

    // find the object in our list
    for(o = firstobj; o; o = o-&gt;list.succ) {
        if(id.num == o-&gt;list.hdr.id.num &amp;&amp;
           id.ptr == o-&gt;list.hdr.id.ptr) break;
        prev = o;
    }

    // not found? exit!
    if(!o) return ERR_FINDOBJECT;

    // do your clean up here
    ...

    // important! ask Hollywood to free all data associated with this
    // object!
    hw_FreeObjectData(L, (struct hwObjectList *) o);

    // unchain object from our list
    if(prev) {
        prev-&gt;list.succ = o-&gt;list.succ;
    } else {
        firstobj = o-&gt;list.succ;
    }

    // and free it
    free(o);

    return 0;
}

static const struct hwCmdStruct plug_commands[] = {
    {&quot;CreateObject&quot;, my_CreateObject},
    {&quot;FreeObject&quot;, my_FreeObject},
    {&quot;GetObjectType&quot;, my_GetObjectType},
    ...
    {NULL, NULL}
};

HW_EXPORT struct hwCmdStruct *GetCommands(void)
{
    return (struct hwCmdStruct *) plug_commands;
}
</pre></td></tr></table><p>

Note that you have to iterate through your object list in <a href="FreeLibrary.html">FreeLibrary()</a>
and free all objects that the user didn't free explicitly. Hollywood won't do this automatically.
If you do not iterate through your object list in <a href="FreeLibrary.html">FreeLibrary()</a>,
you will leak memory. It's also very important that you call <a href="hw_FreeObjectData.html">hw_FreeObjectData()</a>
on every object that you have allocated. See <a href="hw_FreeObjectData.html">hw_FreeObjectData</a> for details.

<p>
If your plugin implements support for additional object types like above, the user will
be able to do the following from the Hollywood script to work with these new object
types:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>MY_OBJECT_TYPE = myplug.GetObjectType()

obj1 = myplug.CreateObject(Nil, ...)

DebugPrint(GetAttribute(MY_OBJECT_TYPE, obj1, #ATTRYOURATTR))

SetObjectData(MY_OBJECT_TYPE, obj1, &quot;test&quot;, &quot;Hello&quot;)
DebugPrint(GetObjectData(MY_OBJECT_TYPE, obj1, &quot;test&quot;))

myplug.FreeObject(obj1)
</pre></td></tr></table><p>

</dd>
<dt class="autodoc"><b>Designer compatibility</b></dt><dd>
Supported since Designer 5.0

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>L</i></dt>
<dd>pointer to the <code>lua_State</code></dd>
<dt><i>name</i></dt>
<dd>user object name to be displayed in the resource monitor</dd>
<dt><i>list</i></dt>
<dd>pointer to a <code>struct hwObjectList</code> pointer (see above)</dd>
<dt><i>attrfunc</i></dt>
<dd>function to be called when the user queries attributes for this object</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>id</i></dt>
<dd>identifier of the new object or 0 on error</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="hw_RegisterUserObject_.html" target="_top">Show TOC</a></font>
</body>
</html>