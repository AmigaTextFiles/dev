<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hw_RawBltBitMap</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hw_RawBltBitMap -- blit source to destination pixel buffer (V6.0)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
void hw_RawBltBitMap(APTR src, APTR dst, struct hwRawBltBitMapCtrl *ctrl,
         ULONG flags, struct hwTagList *tags);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function can be used to blit data from a source to a destination raw pixel buffer.
Note that this function does not accept Hollywood bitmaps, but expects you to pass
raw pixel buffers only. This makes it possible to use <code>hw_RawBltBitMap()</code> in lots of
different contexts. If you want to use <code>hw_RawBltBitMap()</code> on Hollywood bitmaps, you need
to lock those bitmaps first using <a href="hw_LockBitMap.html">hw_LockBitMap()</a> and then
pass the raw pixel buffer pointer obtained by <a href="hw_LockBitMap.html">hw_LockBitMap()</a>
to <code>hw_RawBltBitMap()</code>.

<p>
Optionally, <code>hw_RawBltBitMap()</code> can take a mask or alpha channel pixel buffer into account.
In case an alpha channel pixel buffer is specified, <code>hw_RawBltBitMap()</code> will also do the
blending for you.

<p>
You have to pass source and destination pixel buffer pointers as well as a pointer
to a <code>struct hwRawBltBitMapCtrl</code> to this function. <code>struct hwRawBltBitMapCtrl</code>
looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwRawBltBitMapCtrl
{
    int SrcX;           // [in]
    int SrcY;           // [in]
    int DstX;           // [in]
    int DstY;           // [in]
    int Width;          // [in]
    int Height;         // [in]
    int PixFmt;         // [in]
    UBYTE *MaskData;    // [in]
    UBYTE *AlphaData;   // [in]
    int SrcModulo;      // [in]
    int DstModulo;      // [in]
    int MaskModulo;     // [in]
    int AlphaModulo;    // [in]
};
</pre></td></tr></table><p>

Here's an explanation of the individual structure members:

<p>
<dl>
<dt class="codelist"><code>SrcX:</code></dt>
<dd>
Contains the x position in the source buffer that marks the start offset
for the copy operation. This is relative to the upper-left corner of the source buffer.

<p>
</dd>
<dt class="codelist"><code>SrcY:</code></dt>
<dd>
Contains the y position in the source buffer that marks the start offset
for the copy operation. This is relative to the upper-left corner of the source buffer.

<p>
</dd>
<dt class="codelist"><code>DstX:</code></dt>
<dd>
Contains the destination x position relative to the upper-left corner.

<p>
</dd>
<dt class="codelist"><code>DstY:</code></dt>
<dd>
Contains the destination y position relative to the upper-left corner.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
Contains the number of columns to copy.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
Contains the number of rows to copy.

<p>
</dd>
<dt class="codelist"><code>PixFmt:</code></dt>
<dd>
Contains the pixel format used by the source and destination pixel buffers. Both
buffers must use the same pixel format. See <a href="PixelFormats.html">Pixel format information</a> for details.

<p>
</dd>
<dt class="codelist"><code>SrcModulo:</code></dt>
<dd>
This must be set to the number of pixels per row in the source buffer. This can be more
than the actual image width in case there are padding pixels.

<p>
</dd>
<dt class="codelist"><code>DstModulo:</code></dt>
<dd>
This must be set to the number of pixels per row in the destination buffer. This can be more
than the actual destination image width in case there are padding pixels.

<p>
</dd>
<dt class="codelist"><code>MaskData:</code></dt>
<dd>
This can be set to a pointer containing an array of raw mask bits. Hollywood masks only
know two different states: visible (1) and invisible (0) pixels. The bits are stored
from left to right in chunks of one byte, i.e. the most significant bit of the first byte
describes the transparency setting for the first pixel. The buffer provided here must
be exactly <code>MaskModulo</code> bytes wide and must match the source buffer's height. If you don't
want to use masked blitting, set this to <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>MaskModulo:</code></dt>
<dd>
If you specify a mask bitplane in <code>MaskData</code>, you need to set this member to the number
of bytes that is used for one row of mask data. Note that this value is specified in bytes
and often needs to use some padding. For example, if the source buffer is 123 pixels
wide, the <code>MaskModulo</code> value would usually be set to 16 because 15 bytes are not enough for
123 pixels.

<p>
</dd>
<dt class="codelist"><code>AlphaData:</code></dt>
<dd>
This member can be set to an array containing alpha channel values for every pixel.
This array must use one byte for every pixel and must match the source buffer's height.
The width of the alpha channel array can be specified by setting the <code>AlphaModulo</code>
member (see below). If this member is specified, <code>hw_RawBltBitMap()</code> will do blit the
source pixel buffer to the destination pixel buffer with alpha blending. If you don't
want to use alpha blending, set this to <code>NULL</code>.

<p>
</dd>
<dt class="codelist"><code>AlphaModulo:</code></dt>
<dd>
If <code>AlphaData</code> has been provided, this member must be set to the number of pixels stored
in one row of the <code>AlphaData</code> array. This can be more than the source buffer's width
in case you need padding.
</dd></dl>

<p>
The following tags are recognized by <code>hw_RawBltBitMap()</code>:

<p>
<dl>
<dt class="codelist"><code>HWRBBTAG_CLIPRECT:</code></dt>
<dd>
This tag can be used to make <code>hw_RawBltBitMap()</code> clip its output to the specified clipping
rectangle. If you pass this tag, you must set the <code>pData</code> member of the tag to a
<code>struct hwRect</code> containing the desired clipping rectangle. Note that by default
there is no clipping at all, so you must make sure that the destination raw pixel buffer
is large enough. (V8.0)
</dd></dl>

<p>
</dd>
<dt class="autodoc"><b>Designer compatibility</b></dt><dd>
Unsupported

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>src</i></dt>
<dd>pointer to source raw pixel buffer</dd>
<dt><i>dst</i></dt>
<dd>pointer to destination raw pixel buffer</dd>
<dt><i>ctrl</i></dt>
<dd>pointer to a <code>struct hwRawBltBitMapCtrl</code> containing the blit parameters</dd>
<dt><i>flags</i></dt>
<dd>reserved for future use; pass 0</dd>
<dt><i>tags</i></dt>
<dd>reserved for future use; pass <code>NULL</code></dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="hw_RawBltBitMap_.html" target="_top">Show TOC</a></font>
</body>
</html>