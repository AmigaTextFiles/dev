<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>BltBitMap</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
BltBitMap -- copy pixels from source bitmap to destination (V6.0)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
void BltBitMap(APTR bmap, APTR handle, struct hwBltBitMapCtrl *ctrl,
         ULONG flags, struct hwTagList *tags);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function must copy pixels from a source bitmap to a destination which can
be a display or another bitmap. The source bitmap can be a software bitmap allocated
by Hollywood or your plugin or it can be a custom video bitmap allocated by your
plugin's <a href="AllocVideoBitMap.html">AllocVideoBitMap()</a> function. <code>BltBitMap()</code>
can be used in many different contexts so you need to pay close attention to
implement it correctly. If you only need a barebones implementation that doesn't
support offscreen rendering and video bitmaps, the implementation is really
simple and straight-forward, though. See towards the end of the <code>BltBitMap()</code>
documentation for information on what the most basic implementation of <code>BltBitMap()</code>
has to look like.

<p>
In parameter 3, Hollywood will pass a <code>struct hwBltBitMapCtrl</code> which looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwBltBitMapCtrl
{
    int SrcX;                  // [in]
    int SrcY;                  // [in]
    int DstX;                  // [in]
    int DstY;                  // [in]
    int Width;                 // [in]
    int Height;                // [in]
    int ScaleWidth;            // [in]
    int ScaleHeight;           // [in]
    ULONG ScaleMode;           // [in]
    APTR Mask;                 // [in]
    APTR Alpha;                // [in]
    struct hwMatrix2D *Matrix; // [in, V8.0]
    double AnchorX;            // [in, V8.0]
    double AnchorY;            // [in, V8.0]
    int AlphaMod;              // [in, V8.0]
    ULONG *Palette;            // [in, V9.0]
    ULONG TransPen:            // [in, V9.0]
};
</pre></td></tr></table><p>

Here's a description of the individual structure members:

<p>
<dl>
<dt class="codelist"><code>SrcX:</code></dt>
<dd>
Contains the x position in the source bitmap that marks the start offset
for the copy operation. This is relative to the upper-left corner of the source bitmap.

<p>
</dd>
<dt class="codelist"><code>SrcY:</code></dt>
<dd>
Contains the y position in the source bitmap that marks the start offset
for the copy operation. This is relative to the upper-left corner of the source bitmap.

<p>
</dd>
<dt class="codelist"><code>DstX:</code></dt>
<dd>
Contains the destination x position relative to the upper-left corner.

<p>
</dd>
<dt class="codelist"><code>DstY:</code></dt>
<dd>
Contains the destination y position relative to the upper-left corner.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
Contains the number of columns to copy.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
Contains the number of rows to copy.

<p>
</dd>
<dt class="codelist"><code>ScaleWidth:</code></dt>
<dd>
If you've passed the <code>HWSDAFLAGS_CUSTOMSCALING</code> flag in your call to <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>
then this will contain the desired scale width when autoscaling mode is
active. If you haven't passed <code>HWSDAFLAGS_CUSTOMSCALING</code>, Hollywood will take
care of scaling automatically and this member will always be zero.

<p>
</dd>
<dt class="codelist"><code>ScaleHeight:</code></dt>
<dd>
If you've passed the <code>HWSDAFLAGS_CUSTOMSCALING</code> flag in your call to <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>
then this will contain the desired scale height when autoscaling mode is
active. If you haven't passed <code>HWSDAFLAGS_CUSTOMSCALING</code>, Hollywood will take
care of scaling automatically and this member will always be zero.

<p>
</dd>
<dt class="codelist"><code>ScaleMode:</code></dt>
<dd>
If you've passed the <code>HWSDAFLAGS_CUSTOMSCALING</code> flag in your call to <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>
then this will contain the desired scale mode when autoscaling mode is
active. This can be either 0 for brute force scaling or 1 for interpolated
scaling using pixel antialiasing.

<p>
</dd>
<dt class="codelist"><code>Mask:</code></dt>
<dd>
Contains a pointer to mask bitmap or <code>NULL</code> if there is no mask. This member is only
used when drawing software bitmaps to video bitmaps or hardware double buffers.

<p>
</dd>
<dt class="codelist"><code>Alpha:</code></dt>
<dd>
Contains a pointer to an alpha channel bitmap or <code>NULL</code> if there is no alpha channel.
This member is only used when drawing software bitmaps to video bitmaps or hardware double buffers.

<p>
</dd>
<dt class="codelist"><code>Matrix:</code></dt>
<dd>
If you've set the <code>HWVBMCAPS_BLITTRANSFORM</code> capability in <code>HWSDATAG_VIDEOBITMAPCAPS</code>,
this may be set to a <code>struct hwMatrix2D</code> which means that your implementation
has to apply the specified transformation matrix when blitting. Your transformed
blit operation also has to take the anchor points that are passed in <code>AnchorX</code> and
<code>AnchorY</code> into account (see below). Note that if <code>Matrix</code> is non-<code>NULL</code>, all coordinates
passed to your <code>BltBitMap()</code> implementation are non-clipped. They will be set to the
raw coordinates passed to Hollywood's <code>DisplayBrush()</code> function. This is different to
the case where <code>Matrix</code> is <code>NULL</code>. In that case, all coordinates are clipped to the current
display's boundaries. (V8.0)

<p>
</dd>
<dt class="codelist"><code>AnchorX:</code></dt>
<dd>
If the <code>Matrix</code> member is non-<code>NULL</code>, this will be set to the horizontal anchor point of
the transformation. This will always be between 0 and 1. See <code>Matrix</code> for details. You
only need to handle <code>AnchorX</code> if you have set the <code>HWVBMCAPS_BLITTRANSFORM</code> capability
bit. (V8.0)

<p>
</dd>
<dt class="codelist"><code>AnchorY:</code></dt>
<dd>
If the <code>Matrix</code> member is non-<code>NULL</code>, this will be set to the vertical anchor point of
the transformation. This will always be between 0 and 1. See <code>Matrix</code> for details. You
only need to handle <code>AnchorY</code> if you have set the <code>HWVBMCAPS_BLITTRANSFORM</code> capability
bit. (V8.0)

<p>
</dd>
<dt class="codelist"><code>AlphaMod:</code></dt>
<dd>
If you've set the <code>HWVBMCAPS_BLITALPHAMOD</code> capability in <code>HWSDATAG_VIDEOBITMAPCAPS</code>,
this may be set to an alpha value that should be multiplied into the blitting
operation. Your <code>BltBitMap()</code> implementation has to modulate all pixels by this
alpha value when blitting. If you haven't set <code>HWVBMCAPS_BLITALPHAMOD</code>, you can ignore
this structure member. (V8.0)

<p>
</dd>
<dt class="codelist"><code>Palette:</code></dt>
<dd>
If <code>HWBBFLAGS_SRCCLUTBITMAP</code> is set (see below), this field will contain the palette
for the CLUT bitmap passed to <code>BltBitMap()</code>. The palette pens will be stored as normal RGB
colors in <code>Palette</code>. Note that <code>HWBBFLAGS_SRCCLUTBITMAP</code> can only ever be set if you have
passed <code>HWSDAFLAGS_PALETTE</code> in your <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a> call. (V9.0)

<p>
</dd>
<dt class="codelist"><code>TransPen:</code></dt>
<dd>
If <code>HWBBFLAGS_SRCCLUTBITMAP</code> is set (see below), this field can be set to a pen that
shouldn't be drawn by your <code>BltBitMap()</code> implementation. Note that the <code>TransPen</code> field will
normally be <code>HWPEN_NONE</code>. It can only ever be set to a transparent pen in case your
plugin supports custom double buffers. Also, <code>HWBBFLAGS_SRCCLUTBITMAP</code> can only ever be set
if you have passed <code>HWSDAFLAGS_PALETTE</code> in your <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a> call. (V9.0)
</dd></dl>

<p>
The way <code>BltBitMap()</code> should operate is defined by the <code>flags</code> parameter. The following
flags are currently recognized:

<p>
<dl>
<dt class="codelist"><code>HWBBFLAGS_SRCVIDEOBITMAP:</code></dt>
<dd>
The source bitmap passed in parameter 1 is a video bitmap allocated by <a href="AllocVideoBitMap.html">AllocVideoBitMap()</a>.
If this flag isn't set, then the source bitmap will be a software bitmap that has either been allocated by
Hollywood or by your plugin (if you've set the <code>HWSDAFLAGS_BITMAPADAPTER</code> flag). Note that video bitmaps can only
be drawn to a hardware double buffer allocated by your plugin or to another offscreen video bitmap. Thus,
if <code>HWBBFLAGS_SRCVIDEOBITMAP</code> is set you can be certain that Hollywood is either currently in hardware double buffer
mode, i.e. it has previously called your plugin's <a href="BeginDoubleBuffer.html">BeginDoubleBuffer()</a> function, or
that the <code>HWBBFLAGS_DESTVIDEOBITMAP</code> flag is set.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_DESTVIDEOBITMAP:</code></dt>
<dd>
The destination handle passed in parameter 2 is a video bitmap allocated by <a href="AllocVideoBitMap.html">AllocVideoBitMap()</a>.
This can only happen if you've set the <code>HWVBMCAPS_OFFSCREENCOLOR</code> or <code>HWVBMCAPS_OFFSCREENALPHA</code> capabilities in
<code>HWSDATAG_VIDEOBITMAPCAPS</code> to enable offscreen rendering to video bitmaps. Otherwise, <code>HWBBFLAGS_DESTVIDEOBITMAP</code>
will never be set.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_DESTALPHAONLY:</code></dt>
<dd>
This is only set in connection with <code>HWBBFLAGS_DESTVIDEOBITMAP</code>. If Hollywood wants you to draw to the alpha channel
of your video bitmap allocated by <a href="AllocVideoBitMap.html">AllocVideoBitMap()</a>, it will indicate this by setting
<code>HWBBFLAGS_DESTALPHAONLY</code>. If <code>HWBBFLAGS_DESTVIDEOBITMAP</code> is set and <code>HWBBFLAGS_DESTALPHAONLY</code> isn't, you have to draw
to the color channels of the video bitmap instead. Note that <code>HWBBFLAGS_DESTALPHAONLY</code> will only ever be set if you've
set the <code>HWVBMCAPS_OFFSCREENALPHA</code> capability flag in <code>HWSDATAG_VIDEOBITMAPCAPS</code> to enable offscreen rendering to video
bitmap alphachannels.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_DESTBITMAP:</code></dt>
<dd>
The destination handle passed in parameter 2 is a software bitmap allocated by Hollywood or your plugin's
<a href="AllocBitMap.html">AllocBitMap()</a> function if you've set the <code>HWSDAFLAGS_BITMAPADAPTER</code> in your call to
<a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>. Note that <code>HWBBFLAGS_DESTBITMAP</code> will only ever be set
if you've passed either <code>HWBMAHOOK_BLTBITMAP</code>, <code>HWBMAHOOK_BLTMASKBITMAP</code>, <code>HWBMAHOOK_BLTALPHAHOOK</code> or <code>HWBMAHOOK_BLTCLUTHOOK</code>
in <code>HWSDAFLAGS_BITMAPHOOK</code>. Otherwise, Hollywood will do the rendering to the software bitmap on its own and
you don't have to care. <code>HWBBFLAGS_DESTBITMAP</code> will only ever be set if you've explicitly requested that you
want to do offscreen drawing to software bitmaps on your own by setting the appropriate bitmap hook flags.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_DONOTBLEND:</code></dt>
<dd>
This flag indicates that <code>BltBitMap()</code> should not do any alpha blending. Instead, it should just do a raw
copy of the color and alpha channel pixel data without any blending. This may only ever be set if the
source or destination bitmap is a video bitmap allocated by your plugin, i.e. <code>HWBBFLAGS_DONOTBLEND</code> may
only be set if <code>HWBBFLAGS_DESTVIDEOBITMAP</code> or <code>HWBBFLAGS_SRCVIDEOBITMAP</code> is defined, too. It will never be
set when dealing with software bitmaps.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_IGNOREBKBUFFER:</code></dt>
<dd>
If autoscaling is active and <code>HWSDAFLAGS_CUSTOMSCALING</code> hasn't been set in your call to <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>
this flag may be set to indicate that the source bitmap doesn't match the dimensions of your back buffer.
Thus, if this flag is set you must not draw into the back buffer first. Instead, you must draw directly
to your display. If <code>HWBBFLAGS_IGNOREBKBUFFER</code> is set, the destination handle will always be a display
handle allocated by <a href="OpenDisplay.html">OpenDisplay()</a>. Since <code>HWBBFLAGS_IGNOREBKBUFFER</code> is only used
when Hollywood is in autoscale mode, it will always refresh the whole display, i.e. <code>SrcX</code>, <code>SrcY</code>, <code>DstX</code>,
and <code>DstY</code> will all be 0 and <code>Width</code> and <code>Height</code> will correspond to the display's dimensions.

<p>
</dd>
<dt class="codelist"><code>HWBBFLAGS_SRCCLUTBITMAP:</code></dt>
<dd>
If you have set <code>HWSDAFLAGS_PALETTE</code> in your call to <a href="hw_SetDisplayAdapter.html">hw_SetDisplayAdapter()</a>,
Hollywood will set this flag whenever it has passed a CLUT bitmap to you. You then need to draw the CLUT
bitmap using the palette and transparent pen passed in the <code>Palette</code> and <code>TransPen</code> fields of <code>struct hwBltBitMapCtrl</code>
(see above). (V9.0)
</dd></dl>

<p>
This may all sound quite complicated but in fact, the complexity of the <code>BltBitMap()</code> function can be
greatly reduced if your plugin doesn't support offscreen drawing and video bitmaps. In that case,
all your <code>BltBitMap()</code> implementation has to do is to grab the pixels from the source bitmap and draw
them to the destination display. You won't have to support the <code>Mask</code> and <code>Alpha</code> members of the
<code>struct hwBltBitMapCtrl</code> in that case either, because they will only ever be set if <code>BltBitMap()</code>
is used to draw a software bitmap to a video bitmap or a hardware double buffer.

<p>
To get the raw pixels of Hollywood bitmaps, you can use the <a href="hw_LockBitMap.html">hw_LockBitMap()</a>
function. If you've installed your own bitmap and video bitmap adapters, you can also directly interpret
the handle pointers that are passed to this function because you've allocated them. It's not necessary
to use <a href="hw_LockBitMap.html">hw_LockBitMap()</a> on bitmaps that have been allocated by your
plugin.

<p>
A typical implementation of <code>BltBitMap()</code> should do the following whenever it has to draw directly to the
display: It should first draw the pixels into a back buffer (unless <code>HWBBFLAGS_IGNOREBKBUFFER</code> is set or a
hardware double buffer is used) and then it should draw the pixels from this back buffer to the display.

<p>
This function doesn't have to do any clipping. Hollywood will perform clipping itself before calling
<code>BltBitMap()</code>.

<p>
If your plugin supports hardware double buffering and Hollywood has put your display into
hardware double buffering mode by calling your plugin's <a href="BeginDoubleBuffer.html">BeginDoubleBuffer()</a>
function, this function must not draw anything to the display but only to the back buffer.
Hollywood will call your plugin's <a href="Flip.html">Flip()</a> function when it wants you to
draw the back buffer to the display.

<p>
You might want to use the <a href="hw_RawBltBitMap.html">hw_RawBltBitMap()</a> function in your
implementation to copy the pixels of bitmaps stored as raw pixel buffers. See <a href="hw_RawBltBitMap.html">hw_RawBltBitMap</a> for details.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>bmap</i></dt>
<dd>source bitmap</dd>
<dt><i>handle</i></dt>
<dd>destination display or bitmap (depends on the flags that are set, see above)</dd>
<dt><i>ctrl</i></dt>
<dd>pointer to a <code>struct hwBltBitMapCtrl</code> containing parameters for the blit</dd>
<dt><i>flags</i></dt>
<dd>flags specifying how to copy the pixels (see above)</dd>
<dt><i>tags</i></dt>
<dd>additional options (currently always <code>NULL</code>)</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="BltBitMap_.html" target="_top">Show TOC</a></font>
</body>
</html>