<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>DrawPath</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
DrawPath -- draw a vector path (V5.0)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
int ok = DrawPath(struct DrawPathCtrl *ctrl);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function has to draw a vector path to a bitmap. The path itself and all other parameters
that you need to know are passed in the <code>struct DrawPathCtrl</code> pointer that this function
receives. <code>struct DrawPathCtrl</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct DrawPathCtrl
{
    void *Path;                // [in]
    struct PathStyle *Style;   // [in]
    int Fill;                  // [in]
    int Thickness;             // [in]
    ULONG Color;               // [in]
    UBYTE *Buf;                // [in]
    int LineWidth;             // [in]
    int Width;                 // [in]
    int Height;                // [in]
    int Pad;                   // [unused]
    double TX;                 // [in]
    double TY;                 // [in]
    double MinX;               // [in]
    double MinY;               // [in]
    struct hwMatrix2D *Matrix; // [in]
};
</pre></td></tr></table><p>

Hollywood will pass the following data in this structure:

<p>
<dl>
<dt class="codelist"><code>Path:</code></dt>
<dd>
A buffer containing the actual path data. This buffer contains the individual commands
and their parameters in a number of disparate items. The command is stored in an <code>int</code>
and is always first. The number of parameters that follow the command <code>int</code> and their
sizes depend on the actual command that has been passed. The following commands are
currently recognized:

<p>
<dl>
<dt class="codelist"><code>CCMD_STACKTOP:</code></dt>
<dd>
This is the terminator command. This will always be at the end of the path buffer.
You must break out of your command loop when encountering <code>CCMD_STACKTOP</code>.

<p>
</dd>
<dt class="codelist"><code>CCMD_NEWSUBPATH:</code></dt>
<dd>
This has to start a new sub-path and set the current point to undefined.

<p>
</dd>
<dt class="codelist"><code>CCMD_CLOSEPATH:</code></dt>
<dd>
This has to close the current path by drawing a line from the current point to
the first point in the sub-path. After that the current point has to be set to
this start and end point of the sub-path.

<p>
</dd>
<dt class="codelist"><code>CCMD_MOVETO:</code></dt>
<dd>
This command has to begin a new sub-path. The sub-path's current point must be set
to the specified position. <code>CCMD_MOVETO</code> receives the following three arguments:

<p>
<dl>
<dt class="codelist"><code>rel (int)</code></dt>
<dd>
This is a boolean value that indicates whether the coordinates are relative or
absolute values. If this is <code>True</code>, the coordinates have to be interpreted as
relative to the current point.

<p>
</dd>
<dt class="codelist"><code>x (double)</code></dt>
<dd>
The x coordinate of the new position.

<p>
</dd>
<dt class="codelist"><code>y (double)</code></dt>
<dd>
The y coordinate of the new position.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>CCMD_LINETO:</code></dt>
<dd>
This command has to draw a line from the current point to the specified position.
Additionally, it must change the current point to the line's end point when it
is done. <code>CCMD_LINETO</code> receives the following three arguments:

<p>
<dl>
<dt class="codelist"><code>rel (int)</code></dt>
<dd>
This is a boolean value that indicates whether the coordinates are relative or
absolute values. If this is <code>True</code>, the coordinates have to be interpreted as
relative to the current point.

<p>
</dd>
<dt class="codelist"><code>x (double)</code></dt>
<dd>
The x coordinate of the new position.

<p>
</dd>
<dt class="codelist"><code>y (double)</code></dt>
<dd>
The y coordinate of the new position.
</dd></dl>

<p>
If there is no current point, <code>CCMD_LINETO</code> must behave as if it was <code>CCMD_MOVETO</code>,
i.e. it must simply set the current point to the specified vertex.

<p>
</dd>
<dt class="codelist"><code>CCMD_CURVETO:</code></dt>
<dd>
This command has to draw a B&eacute;zier curve that runs from the current point
to the position passed in the final two coordinates. The other four coordinates
are the control points for the curve. Additionally, it must change the current
point to the curve's end point when it is done. <code>CCMD_CURVETO</code> receives the following
seven arguments:

<p>
<dl>
<dt class="codelist"><code>rel (int)</code></dt>
<dd>
This is a boolean value that indicates whether the coordinates are relative or
absolute values. If this is <code>True</code>, the coordinates have to be interpreted as
relative to the current point.

<p>
</dd>
<dt class="codelist"><code>x1 (double)</code></dt>
<dd>
The x coordinate of the first control point.

<p>
</dd>
<dt class="codelist"><code>y1 (double)</code></dt>
<dd>
The y coordinate of the first control point.

<p>
</dd>
<dt class="codelist"><code>x2 (double)</code></dt>
<dd>
The x coordinate of the first control point.

<p>
</dd>
<dt class="codelist"><code>y2 (double)</code></dt>
<dd>
The y coordinate of the first control point.

<p>
</dd>
<dt class="codelist"><code>x3 (double)</code></dt>
<dd>
The x coordinate of the end point.

<p>
</dd>
<dt class="codelist"><code>y3 (double)</code></dt>
<dd>
The y coordinate of the end point.
</dd></dl>

<p>
If there is no current point, <code>CCMD_CURVETO</code> must use the point passed in (x1,y1) as
the current point.

<p>
</dd>
<dt class="codelist"><code>CCMD_ARC:</code></dt>
<dd>
This command has to draw an elliptical arc. <code>CCMD_ARC</code> must open a new subpath for
the new arc only in case there is no currently active subpath. If there is already
a subpath, <code>CCMD_ARC</code> must connect its starting vertex with the current vertex of
the subpath. <code>CCMD_ARC</code> also must not close the subpath when it has finished adding
its vertices. <code>CCMD_ARC</code> must not connect the start and end angles of the arc with
its center point automatically. The user has to explicitly request this by issuing
separate <code>CCMD_MOVETO</code> and <code>CCMD_LINETO</code> commands before and after <code>CCMD_ARC</code>. <code>CCMD_ARC</code>
receives the following arguments:

<p>
<dl>
<dt class="codelist"><code>xc (double)</code></dt>
<dd>
The x center point of the arc.
</dd>
<dt class="codelist"><code>yc (double)</code></dt>
<dd>
The y center point of the arc.
</dd>
<dt class="codelist"><code>ra (double)</code></dt>
<dd>
Arc's radius on the x axis.
</dd>
<dt class="codelist"><code>rb (double)</code></dt>
<dd>
Arc's radius on the y axis.
</dd>
<dt class="codelist"><code>start (double)</code></dt>
<dd>
Start angle in degrees.
</dd>
<dt class="codelist"><code>end (double)</code></dt>
<dd>
End angle in degrees.
</dd>
<dt class="codelist"><code>clockwise (int)</code></dt>
<dd>
Whether or not the angles should be connected in clockwise direction.
</dd></dl>

<p>
When <code>CCMD_ARC</code> is done, it needs to set the current point to the position of the
end angle.

<p>
</dd>
<dt class="codelist"><code>CCMD_BOX:</code></dt>
<dd>
This command has to draw a rectangle. <code>CCMD_BOX</code> must first open a new subpath,
then add the rectangle's vertices to it and close the subpath when it is finished.
Optionally, the rectangle can have rounded corners. <code>CCMD_BOX</code> receives the following arguments:

<p>
<dl>
<dt class="codelist"><code>x (double)</code></dt>
<dd>
X position of the rectangle.
</dd>
<dt class="codelist"><code>y (double)</code></dt>
<dd>
Y position of the rectangle.
</dd>
<dt class="codelist"><code>width (double)</code></dt>
<dd>
Rectangle width.
</dd>
<dt class="codelist"><code>height (double)</code></dt>
<dd>
Rectangle height.
</dd>
<dt class="codelist"><code>rnd1 (int)</code></dt>
<dd>
Integer value in the range of 0 to 100 specifying the degree of rounding
for the first corner of the rectangle. 0 for no rounding.
</dd>
<dt class="codelist"><code>rnd2 (int)</code></dt>
<dd>
Integer value in the range of 0 to 100 specifying the degree of rounding
for the second corner of the rectangle. 0 for no rounding.
</dd>
<dt class="codelist"><code>rnd3 (int)</code></dt>
<dd>
Integer value in the range of 0 to 100 specifying the degree of rounding
for the third corner of the rectangle. 0 for no rounding.
</dd>
<dt class="codelist"><code>rnd4 (int)</code></dt>
<dd>
Integer value in the range of 0 to 100 specifying the degree of rounding
for the fourth corner of the rectangle. 0 for no rounding.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>CCMD_TEXT:</code></dt>
<dd>
This command has to draw vector text relative to the current point. The individual
characters should be added as closed subpaths. <code>CCMD_TEXT</code> receives the following
arguments:

<p>
<dl>
<dt class="codelist"><code>ptr (APTR)</code></dt>
<dd>
This is set to a pointer to a vector font created by <a href="CreateVectorFont.html">CreateVectorFont()</a>.

<p>
</dd>
<dt class="codelist"><code>size (int)</code></dt>
<dd>
Desired font size.

<p>
</dd>
<dt class="codelist"><code>text (varies)</code></dt>
<dd>
The text to draw is passed directly after the integer specifying the font size.
It is a null-terminated string encoded in the UTF-8 format. To read the next command
following the string data, you need to pad the pointer address after the terminating <code>NULL</code>
to a multiple of 4, i.e. a long-aligned address. Commands are always long-aligned
so be sure to pad to a long-aligned address after the string end.
</dd></dl>

<p>
When <code>CCMD_TEXT</code> is done, it needs to set the current point to where the next
character would be displayed.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>Style:</code></dt>
<dd>
This will be set to a pointer to a <code>struct PathStyle</code> containing
information about the line style that shall be used when drawing this path.
<code>struct PathStyle</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct PathStyle
{
    int LineJoin;
    int LineCap;
    int FillRule;
    int AntiAlias;
    double DashOffset;
    double *Dashes;
    int NumDashes;
    double MiterLimit;   // V7.1
};
</pre></td></tr></table><p>

Here's an explanation of the individual member's function:

<p>
<dl>
<dt class="codelist"><code>LineJoin:</code></dt>
<dd>
Contains the desired line join style for the path. This can be one of the following
constants:

<p>
<dl>
<dt class="codelist"><code>HWLINEJOIN_MITER:</code></dt>
<dd>
Join lines using a sharp corner.
</dd>
<dt class="codelist"><code>HWLINEJOIN_ROUND:</code></dt>
<dd>
Join lines using round edges.
</dd>
<dt class="codelist"><code>HWLINEJOIN_BEVEL:</code></dt>
<dd>
Join lines using cut-off edges.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>LineCap:</code></dt>
<dd>
Determines how line endings should be drawn. This can be one of the following
constants:

<p>
<dl>
<dt class="codelist"><code>HWLINECAP_BUTT:</code></dt>
<dd>
Line should stop exactly at the end point without any further decoration.

<p>
</dd>
<dt class="codelist"><code>HWLINECAP_ROUND:</code></dt>
<dd>
Line ending should be round.

<p>
</dd>
<dt class="codelist"><code>HWLINECAP_SQUARE:</code></dt>
<dd>
Line ending should be squared.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>FillRule:</code></dt>
<dd>
Determines the fill rule for overlapping sections of the path. This can be one
of the following constants:

<p>
<dl>
<dt class="codelist"><code>HWFILLRULE_WINDING:</code></dt>
<dd>
Fill all overlapping paths only if they are not winding.

<p>
</dd>
<dt class="codelist"><code>HWFILLRULE_EVENODD:</code></dt>
<dd>
Fill overlapping paths if the total number of intersections is odd.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>AntiAlias:</code></dt>
<dd>
This indicates whether Hollywood wants you to draw anti-aliased shapes or
monochrome shapes. <code>True</code> means anti-aliasing should be used.

<p>
</dd>
<dt class="codelist"><code>DashOffset:</code></dt>
<dd>
If <code>NumDashes</code> is greater than zero, this specifies the offset at which dashing
should start.

<p>
</dd>
<dt class="codelist"><code>Dashes:</code></dt>
<dd>
If <code>NumDashes</code> is greater than zero, this is set to a <code>double</code> array which
contains <code>NumDashes</code> entries, specifying alternate on and off sections that
define the dash style.

<p>
</dd>
<dt class="codelist"><code>NumDashes:</code></dt>
<dd>
If this is greater than zero, Hollywood wants you to draw dashed lines. The
dashing pattern is specified in <code>DashOffset</code> and <code>Dashes</code> (see above).

<p>
</dd>
<dt class="codelist"><code>MiterLimit:</code></dt>
<dd>
This item is only present in Hollywood 7.1 and up. If you are targetting
earlier Hollywood versions, assume a miter limit of 10. The miter limit is used
when the join style is set to <code>HWLINEJOIN_MITER</code> to determine when to join lines
with a bevel and when to join them using a miter. When drawing line ends, the
length of the miter is divided by the line width and if the result of this division
is greater than the miter limit set using this function, lines are joined using
a bevel. (V7.1)
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>Fill:</code></dt>
<dd>
This member specifies whether Hollywood wants you to draw filled shapes or
just the stroke outlines. If this is <code>True</code>, you have to fill all shapes.

<p>
</dd>
<dt class="codelist"><code>Thickness:</code></dt>
<dd>
This member sets the line thickness.

<p>
</dd>
<dt class="codelist"><code>Color:</code></dt>
<dd>
This is currently unused since <code>DrawPath()</code> doesn't draw into color channels
at all. Ignore this.

<p>
</dd>
<dt class="codelist"><code>Buf:</code></dt>
<dd>
This contains a pointer to an 8-bit bitmap which you have to draw to. See
<code>LineWidth</code> to find out about the bitmap's alignment.

<p>
</dd>
<dt class="codelist"><code>LineWidth:</code></dt>
<dd>
This contains the bytes per row of the bitmap passed in <code>Buf</code>.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
Contains the width of the bitmap in pixels. This can be less than <code>LineWidth</code>.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
Contains the height of the bitmap in pixels.

<p>
</dd>
<dt class="codelist"><code>TX:</code></dt>
<dd>
If this does not equal 0, Hollywood wants you to translate every pixel that
you draw by this many pixels on the x-axis. Note that the translation must
be done after applying the transformation matrix passed in <code>Matrix</code>.

<p>
</dd>
<dt class="codelist"><code>TY:</code></dt>
<dd>
If this does not equal 0, Hollywood wants you to translate every pixel that
you draw by this many pixels on the y-axis. Note that the translation must
be done after applying the transformation matrix passed in <code>Matrix</code>.

<p>
</dd>
<dt class="codelist"><code>MinX:</code></dt>
<dd>
You have to translate the path by this many pixels on the x-axis before drawing it.
Note that this value is inverted. A positive value indicates translation
to the left whereas a negative value requires you to translate the shape to the
right.

<p>
</dd>
<dt class="codelist"><code>MinY:</code></dt>
<dd>
You have to translate the path by this many pixels on the y-axis before drawing it.
Note that this value is inverted. A positive value indicates upwards
translation whereas a negative value requires you to translate the shape in
downward direction.

<p>
</dd>
<dt class="codelist"><code>Matrix:</code></dt>
<dd>
Contains a 2D transformation matrix that should be applied to this path.
If there is no transformation, you'll get a pointer to an identity matrix
consisting of (1,0,0,1).
</dd></dl>

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>ctrl</i></dt>
<dd>pointer to a <code>struct DrawPathCtrl</code></dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>ok</i></dt>
<dd><code>True</code> for success, <code>False</code> otherwise</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="DrawPath_.html" target="_top">Show TOC</a></font>
</body>
</html>