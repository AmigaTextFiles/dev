<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hw_AddBrush</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hw_AddBrush -- create a new brush (V5.3)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
int error = hw_AddBrush(lua_State *L, lua_ID *id, int width, int height,
                struct hwAddBrush *ctrl);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function can be used to create a new brush and make it available to the
Hollywood script. You have to pass the desired object identifier for the brush
as a <code>lua_ID</code>. See <a href="LuaID.html">Object identifiers</a> for details. Additionally, you have to specify
the brush's width and height as well as a pointer to a <code>struct hwAddBrush</code>
which contains further information. <code>struct hwAddBrush</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwAddBrush
{
    ULONG *Data;
    int LineWidth;
    ULONG Transparency;
    ULONG Flags;
    APTR Image;
    ULONG *(*GetImage)(APTR handle, struct LoadImageCtrl *ctrl);
    void (*FreeImage)(APTR handle);
    int (*TransformImage)(APTR handle, struct hwMatrix2D *m,
                             int width, int height);
    int Depth;              // V9.0
    ULONG *Palette;         // V9.0
};
</pre></td></tr></table><p>

You need to provide the following information in this structure:

<p>
<dl>
<dt class="codelist"><code>Data:</code></dt>
<dd>
This is only used if you want to create a raster brush, i.e. the <code>HWABFLAGS_VECTORBRUSH</code>
flag is not set. The format of <code>Data</code> depends on whether you want <code>hw_AddBrush()</code> to create
a palette brush or an RGB brush. For RGB brushes, set this structure member to a pointer to an
array of 32-bit ARGB pixels that contain the image data for the new brush. <code>hw_AddBrush()</code>
will only take the alpha byte into account if the <code>HWABFLAGS_USEALPHA</code> flag has been set.
Otherwise the alpha byte is ignored. For palette brushes, you must provide an 8-bit array
of pixels. Note that 8-bit pixels must be used even if the palette depth is less than 8
bits. The pixel array specified here must contain exactly as many pixels per row as passed
in the <code>LineWidth</code> member. If you set <code>Data</code> to <code>NULL</code> and <code>HWABFLAGS_VECTORBRUSH</code> isn't set,
<code>hw_AddBrush()</code> will create an uninitialized raster brush for you, i.e. it will be filled with
random pixel data.

<p>
</dd>
<dt class="codelist"><code>LineWidth:</code></dt>
<dd>
This must only be set if you want to create a raster brush and <code>Data</code> is not <code>NULL</code>. In that
case, you have to set this structure member to the number of pixels per row in the <code>Data</code>
pixel array. This can be different from the value passed in the <code>width</code> parameter of
<code>hw_AddBrush()</code> in case the pixel array you specified in <code>Data</code> contains some padding bytes.
Please note that <code>LineWidth</code> must be specified in pixels, not in bytes.

<p>
</dd>
<dt class="codelist"><code>Transparency:</code></dt>
<dd>
If the <code>HWABFLAGS_USETRANSPARENCY</code> flag has been set, this member contains a 24-bit RGB
color that should be made transparent. Hollywood will scan through the pixel array
passed in <code>Data</code> and create a monochrome mask for the new brush in which all pixels which
match the RGB color specified here are transparent. This member is only supported for raster
brushes. Note that for palette brushes, i.e. if the <code>HWABFLAGS_USEPALETTE</code> flag is set,
<code>Transparency</code> needs to specify a pen that should be made transparent instead. For no
transparent pen, set this to <code>HWPEN_NONE</code>.

<p>
</dd>
<dt class="codelist"><code>Depth:</code></dt>
<dd>
If <code>HWABFLAGS_USEPALETTE</code> is set, this member must be set to the palette depth. This
must be between 1 and 8. When creating RGB brushes, this member needn't be set. (V9.0)

<p>
</dd>
<dt class="codelist"><code>Palette:</code></dt>
<dd>
If <code>HWABFLAGS_USEPALETTE</code> is set, this member must be set to a <code>ULONG</code> array containing
the palette colors, specified as raw RGB values. Note that the array you pass here must
contain 256 entries, even if the palette depth is less than 8. (V9.0)

<p>
</dd>
<dt class="codelist"><code>Flags:</code></dt>
<dd>
This member controls several attributes for the new brush. It can be set to a combination
of the following flags:

<p>
<dl>
<dt class="codelist"><code>HWABFLAGS_USEALPHA:</code></dt>
<dd>
The brush uses alpha channel transparency. If this flag is set, the pixel array specified
in <code>Data</code> has to contain transparency information in the alpha byte. If a vector brush
is created, your <code>GetImage()</code> implementation must return transparency information in the
alpha byte as well. If this flag is not set, <code>hw_AddBrush()</code> will ignore whatever is in
the alpha byte. This flag and <code>HWABFLAGS_USETRANSPARENCY</code> are mutually exclusive.

<p>
</dd>
<dt class="codelist"><code>HWABFLAGS_USETRANSPARENCY:</code></dt>
<dd>
This is only supported if you create a raster brush and a pixel array has been passed
in <code>Data</code>. In that case, setting this flag indicates that you want <code>hw_AddBrush()</code> to create
a mask in which all pixels that match the color specified in <code>Transparency</code> are made transparent.
That is why you also need to set the <code>Transparency</code> member if you set this flag. This flag
and <code>HWABFLAGS_USEALPHA</code> are mutually exclusive.

<p>
</dd>
<dt class="codelist"><code>HWABFLAGS_VECTORBRUSH:</code></dt>
<dd>
If this flag is set, <code>hw_AddBrush()</code> will create a vector brush for you. Vector brushes
can be transformed without any quality loss and whenever the script wants to have a vector
brush scaled, rotated, or transformed, Hollywood will call into your plugin to apply this
transformation to your vector brush. That is why you need to provide several callbacks
when creating a vector brush (see below).

<p>
</dd>
<dt class="codelist"><code>HWABFLAGS_USEPALETTE:</code></dt>
<dd>
Set this flag if you want to create a palette brush. In that case, you also have to
set the <code>Palette</code> and <code>Depth</code> members (see above). (V9.0)
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>Image:</code></dt>
<dd>
This must only be set if you want to create a vector brush. In that case, it must
be set to a handle that you want Hollywood to pass to your vector brush callbacks
whenever it needs something done.

<p>
</dd>
<dt class="codelist"><code>GetImage:</code></dt>
<dd>
This must only be set if you want to create a vector brush. In that case, it must
be set to a callback function that returns the raw pixel data of the vector brush.
The function that you specify here has to work exactly like the <a href="GetImage.html">GetImage()</a>
function of image plugins. See <a href="GetImage.html">GetImage</a> for details.

<p>
</dd>
<dt class="codelist"><code>FreeImage:</code></dt>
<dd>
This must only be set if you want to create a vector brush. In that case, it must
be set to a callback function that frees any data that your plugin has allocated for your
vector brush. The function that you specify here has to work exactly like the <a href="FreeImage.html">FreeImage()</a>
function of image plugins. See <a href="FreeImage.html">FreeImage</a> for details.

<p>
</dd>
<dt class="codelist"><code>TransformImage:</code></dt>
<dd>
This must only be set if you want to create a vector brush. In that case, it must
be set to a callback function that applies transformation to a vector brush.
The function that you specify here has to work exactly like the <a href="TransformImage.html">TransformImage()</a>
function of image plugins. See <a href="TransformImage.html">TransformImage</a> for details.
</dd></dl>

<p>
You can free brushes by calling the <a href="hw_FreeBrush.html">hw_FreeBrush()</a> function.

<p>
</dd>
<dt class="autodoc"><b>Designer compatibility</b></dt><dd>
Unsupported

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>L</i></dt>
<dd>pointer to the <code>lua_State</code></dd>
<dt><i>id</i></dt>
<dd>object identifier for the new brush</dd>
<dt><i>width</i></dt>
<dd>desired pixel width for the new brush</dd>
<dt><i>height</i></dt>
<dd>desired pixel height for the new brush</dd>
<dt><i>ctrl</i></dt>
<dd>pointer to a <code>struct hwAddBrush</code> containing additional information</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>error</i></dt>
<dd>error code or 0 on success</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="hw_AddBrush_.html" target="_top">Show TOC</a></font>
</body>
</html>