<html>
<!-- generated from hollywood_sdk.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hw_AttachDisplaySatellite</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hw_AttachDisplaySatellite -- create a new display satellite (V5.2)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
APTR handle = hw_AttachDisplaySatellite(lua_ID *id, int (*dispatcher)
                  (APTR handle, int op, APTR opdata, APTR userdata),
                  APTR userdata, struct hwTagList *tags);</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
This function can be used to attach a new satellite to the specified display. A display
satellite is an object which receives all the graphics output that is being done to
its root display so that the satellite always mirrors the graphics of its root display.
The satellite can then choose what to do with these graphics: It could save them to a file,
upload them to the internet or another application, display them using a custom device, etc.
There are many possible use cases for display satellites. A big advantage of display satellites
is that they also work while their root display is hidden. This makes it possible to create
some sort of light display adapter using satellites by hiding the display opened by
Hollywood and using a custom display managed by the satellite instead. In this case,
however, Hollywood will still run its inbuilt event processor so you cannot switch
to entirely different toolkits as you can do with a display adapter. See <a href="DisplayAdapterOverview.html">Display adapter plugins</a> for details.
Furthermore, the satellite can also post events to its root display. This is done by calling the
<a href="hw_PostSatelliteEvent.html">hw_PostSatelliteEvent()</a> function. See <a href="hw_PostSatelliteEvent.html">hw_PostSatelliteEvent</a> for details.

<p>
You have to pass the object identifier of the display the new satellite shall attach to.
The object identifier must be passed as a <code>lua_ID</code>. See <a href="LuaID.html">Object identifiers</a> for details.

<p>
You also have to pass a pointer to a dispatcher function which will be called whenever
Hollywood draws something to the satellite's root display. In that case, Hollywood will
first draw to the root display and then immediately call your satellite's dispatcher
so that it is informed about the draw operation. The prototype of this dispatcher
function looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>int dispatcher(APTR handle, int op, APTR opdata, APTR userdata);
</pre></td></tr></table><p>

Hollywood will pass a handle to the display satellite in the first parameter and it
will pass the user data that you specified in your call to <code>hw_AttachDisplaySatellite()</code>
in the fourth parameter. Parameters 2 and 3 contain the information about the operation
that Hollywood wants your satellite to execute. The data passed in <code>opdata</code> depends
on the actual operation passed in parameter 2. The following operations are currently
recognized:

<p>
<dl>
<dt class="codelist"><code>HWSATOP_BLTBITMAP:</code></dt>
<dd>
Hollywood wants your satellite to blit a bitmap to its graphics buffer. <code>opdata</code> will
get a pointer to a <code>struct hwSatelliteBltBitMap</code> which contains all information
you need to do the blit operation. <code>struct hwSatelliteBltBitMap</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteBltBitMap
{
    APTR BitMap;        // [in]
    int BitMapType;     // [in]
    int BitMapWidth;    // [in]
    int BitMapHeight;   // [in]
    int BitMapModulo;   // [in]
    int BitMapPixFmt;   // [in]
    UBYTE *Mask;        // [in]
    int MaskModulo;     // [in]
    int SrcX;           // [in]
    int SrcY;           // [in]
    int DstX;           // [in]
    int DstY;           // [in]
    int Width;          // [in]
    int Height;         // [in]
    ULONG *Palette;     // [in] -- V9.0
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>BitMap:</code></dt>
<dd>
This will be set to a pointer to the bitmap that shall be blitted. The actual
type of the bitmap specified here is specified in the <code>BitMapType</code> member (see below).

<p>
</dd>
<dt class="codelist"><code>BitMapType:</code></dt>
<dd>
This contains the type of the bitmap pointer passed in the <code>BitMap</code> member. The
following types are currently supported:

<p>
<dl>
<dt class="codelist"><code>HWSATBMTYPE_AMIGABITMAP:</code></dt>
<dd>
<code>HWSATBMTYPE_AMIGABITMAP</code> indicates that the bitmap is an AmigaOS bitmap, i.e.
a <code>struct BitMap</code> allocated by <code>graphics.library/AllocBitMap()</code>.
This can only happen on AmigaOS based systems.

<p>
</dd>
<dt class="codelist"><code>HWSATBMTYPE_PIXELBUFFER:</code></dt>
<dd>
The bitmap is a raw pixel buffer. The actual format of the raw pixels is specified
in the <code>BitMapPixFmt</code> structure member.

<p>
</dd>
<dt class="codelist"><code>HWSATBMTYPE_VIDEOBITMAP:</code></dt>
<dd>
The bitmap is a video bitmap allocated by your plugin's <a href="AllocVideoBitMap.html">AllocVideoBitMap()</a>
function. (V6.0)

<p>
</dd>
<dt class="codelist"><code>HWSATBMTYPE_BITMAP:</code></dt>
<dd>
The bitmap is a Hollywood bitmap. Use <a href="hw_LockBitMap.html">hw_LockBitMap()</a> to
access its pixels. (V6.0)

<p>
</dd>
<dt class="codelist"><code>HWSATBMTYPE_CLUTBITMAP:</code></dt>
<dd>
The bitmap is a CLUT bitmap. Use <a href="hw_LockBitMap.html">hw_LockBitMap()</a> to access its pixels.
Note that this can only ever happen if you have set <code>HWADS_PALETTE</code> to <code>True</code> when calling
<code>hw_AttachDisplaySatellite()</code>. Otherwise you will never
be passed CLUT bitmaps. The CLUT bitmap's palette will be stored in the palette structure
member (see below). (V9.0)
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>BitMapWidth:</code></dt>
<dd>
Contains the bitmap's width in pixels.

<p>
</dd>
<dt class="codelist"><code>BitMapHeight:</code></dt>
<dd>
Contains the bitmap's height in pixels.

<p>
</dd>
<dt class="codelist"><code>BitMapModulo:</code></dt>
<dd>
Contains the bitmap's modulo width in pixels, i.e. the pixel of one row of image data.
This is often more than what is passed in <code>BitMapWidth</code> because row padding is used.
<code>BitMapModulo</code> only contains a meaningful value if <code>BitMapType</code> has been set to <code>HWSATBMTYPE_PIXELBUFFER</code>.

<p>
</dd>
<dt class="codelist"><code>BitMapPixFmt:</code></dt>
<dd>
Contains the pixel format of the raw pixels passed in the <code>BitMap</code> structure member. This only
contains a meaningful value if <code>BitMapType</code> has been set to <code>HWSATBMTYPE_PIXELBUFFER</code>.
See <a href="PixelFormats.html">Pixel format information</a> for a list of pixel formats.

<p>
</dd>
<dt class="codelist"><code>MaskData:</code></dt>
<dd>
If this does not equal <code>NULL</code>, Hollywood wants you to take this mask into account when
blitting. <code>MaskData</code> points to an array of raw mask bits then (1 bit per pixel). This array
matches the size of the bitmap passed in the <code>BitMap</code> member. Hollywood masks only know two
different states: visible (1) and invisible (0) pixels. The bits are stored from left to
right in chunks of one byte, i.e. the most significant bit of the first byte describes the
transparency setting of the first pixel. The number of bytes per row is stored in the
<code>MaskModulo</code> member (see below).

<p>
</dd>
<dt class="codelist"><code>MaskModulo:</code></dt>
<dd>
If <code>MaskData</code> contains a mask pointer, this member will be set to the number of bytes that is
used for one row of mask data. Note that this value is specified in bytes and often
contains some padding.

<p>
</dd>
<dt class="codelist"><code>SrcX:</code></dt>
<dd>
Contains the source x-offset of the blit operation.

<p>
</dd>
<dt class="codelist"><code>SrcY:</code></dt>
<dd>
Contains the source y-offset of the blit operation.

<p>
</dd>
<dt class="codelist"><code>DstX:</code></dt>
<dd>
Contains the destination x-offset of the blit operation.

<p>
</dd>
<dt class="codelist"><code>DstY:</code></dt>
<dd>
Contains the destination y-offset of the blit operation.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
Contains the number of columns to blit.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
Contains the number of rows to blit.

<p>
</dd>
<dt class="codelist"><code>Palette:</code></dt>
<dd>
Contains the palette of the CLUT bitmap if <code>BitMapType</code> is <code>HWSATBMTYPE_CLUTBITMAP</code>.
The palette colors are stored as raw RGB values in the <code>ULONG</code> array. Note that <code>Palette</code>
can only ever be set if you have set <code>HWADS_PALETTE</code> to <code>True</code> when calling
<code>hw_AttachDisplaySatellite()</code>. Otherwise you will never
be passed CLUT bitmaps. (V9.0)
</dd></dl>

<p>
Please note that you do not have to do any clipping. Hollywood will clip all coordinates
against your satellite root display's boundaries before invoking your dispatcher.

<p>
</dd>
<dt class="codelist"><code>HWSATOP_RECTFILL:</code></dt>
<dd>
Hollywood wants your satellite to draw a rectangle to its graphics buffer. <code>opdata</code> will
get a pointer to a <code>struct hwSatelliteRectFill</code> which contains all information
you need to do this operation. <code>struct hwSatelliteRectFill</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteRectFill
{
    int X;
    int Y;
    int Width;
    int Height;
    ULONG Color;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>X:</code></dt>
<dd>
Start x-offset of the rectangle to fill.

<p>
</dd>
<dt class="codelist"><code>Y:</code></dt>
<dd>
Start y-offset of the rectangle to fill.

<p>
</dd>
<dt class="codelist"><code>Width:</code></dt>
<dd>
Width in pixels of the area to fill.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
Height in pixels of the area to fill.

<p>
</dd>
<dt class="codelist"><code>Color:</code></dt>
<dd>
Filling color specified as a 24-bit RGB value.
</dd></dl>

<p>
Please note that you do not have to do any clipping. Hollywood will clip all coordinates
against your satellite root display's boundaries before invoking your dispatcher.

<p>
</dd>
<dt class="codelist"><code>HWSATOP_LINE:</code></dt>
<dd>
Hollywood wants your satellite to draw a line to its graphics buffer. <code>opdata</code> will
get a pointer to a <code>struct hwSatelliteLine</code> which contains all information
you need to do this operation. <code>struct hwSatelliteLine</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteLine
{
    int X1;
    int Y1;
    int X2;
    int Y2;
    ULONG Color;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>X1:</code></dt>
<dd>
Start x-offset for the line.

<p>
</dd>
<dt class="codelist"><code>Y1:</code></dt>
<dd>
Start y-offset for the line.

<p>
</dd>
<dt class="codelist"><code>X2:</code></dt>
<dd>
End x-offset for the line.

<p>
</dd>
<dt class="codelist"><code>Y2:</code></dt>
<dd>
End y-offset for the line.

<p>
</dd>
<dt class="codelist"><code>Color:</code></dt>
<dd>
Desired line color specified as a 24-bit RGB value.
</dd></dl>

<p>
Please note that you do not have to do any clipping. Hollywood will clip all coordinates
against your satellite root display's boundaries before invoking your dispatcher.

<p>
</dd>
<dt class="codelist"><code>HWSATOP_WRITEPIXEL:</code></dt>
<dd>
Hollywood wants your satellite to draw a single pixel to its graphics buffer. <code>opdata</code> will
get a pointer to a <code>struct hwSatelliteWritePixel</code> which contains all information
you need to do this operation. <code>struct hwSatelliteWritePixel</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteWritePixel
{
    int X;
    int Y;
    ULONG Color;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>X:</code></dt>
<dd>
Pixel's x-offset.

<p>
</dd>
<dt class="codelist"><code>Y:</code></dt>
<dd>
Pixel's y-offset.

<p>
</dd>
<dt class="codelist"><code>Color:</code></dt>
<dd>
Pixel color specified as a 24-bit RGB value.
</dd></dl>

<p>
Please note that you do not have to do any clipping. Hollywood will clip all coordinates
against your satellite root display's boundaries before invoking your dispatcher.

<p>
</dd>
<dt class="codelist"><code>HWSATOP_RESIZE:</code></dt>
<dd>
Hollywood wants your display satellite to resize. <code>opdata</code> will get a pointer to a
<code>struct hwSatelliteResize</code> which contains all information you need to do
this operation. <code>struct hwSatelliteResize</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteResize
{
    int Width;
    int Height;
};
</pre></td></tr></table><p>

The structure members will be initialized like this:

<p>
<dl>
<dt class="codelist"><code>Width:</code></dt>
<dd>
This member contains the new display satellite width in pixels.

<p>
</dd>
<dt class="codelist"><code>Height:</code></dt>
<dd>
This member contains the new display satellite height in pixels.
</dd></dl>

<p>
</dd>
<dt class="codelist"><code>HWSATOP_VWAIT:</code></dt>
<dd>
This opcode is only sent if your display satellite has explicitly requested to
be notified whenever its root display is asked to wait for the vertical blank
interrupt by setting the <code>HWADS_DISPATCHVWAIT</code> tag to <code>True</code>. If that is the case,
you will receive this opcode whenever a vertical blank wait is executed on the
satellite's root display. This notification can come in handy in case the root
display is hidden and doesn't execute any vertical blank waits. You could then
do this job in your satellite dispatcher to prevent Hollywood from running too
fast. (V6.0)

<p>
</dd>
<dt class="codelist"><code>HWSATOP_SETPOINTER:</code></dt>
<dd>
Hollywood wants your satellite to change the mouse pointer. <code>opdata</code> will be
set to a pointer to a <code>struct hwSatelliteSetPointer</code> which contains all information
you need to change the pointer. <code>struct hwSatelliteSetPointer</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteSetPointer
{
    int Type;
    APTR Handle;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>Type:</code></dt>
<dd>
This member will be initialized to one of the following pointer types:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>HWPOINTER_SYSTEM
HWPOINTER_BUSY
HWPOINTER_CUSTOM
</pre></td></tr></table><p>

</dd>
<dt class="codelist"><code>Handle:</code></dt>
<dd>
If <code>Type</code> has been set to <code>HWPOINTER_CUSTOM</code>, <code>Handle</code> will be set to the pointer's
handle, as allocated by <a href="CreatePointer.html">CreatePointer()</a>.
</dd></dl>

<p>
Note that <code>HWSATOP_SETPOINTER</code> will only be dispatched if you have set the
<code>HWADS_MOUSEPOINTER</code> tag to <code>True</code> (see below). (V9.0)

<p>
</dd>
<dt class="codelist"><code>HWSATOP_SHOWHIDEPOINTER:</code></dt>
<dd>
Hollywood wants your satellite to show or hide the mouse pointer. <code>opdata</code> will
be set to a pointer to a <code>struct hwSatelliteShowHidePointer</code> which contains the
information whether to show or hide the pointer. <code>struct hwSatelliteShowHidePointer</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteShowHidePointer
{
    int Show;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>Show:</code></dt>
<dd>
This will be <code>True</code> if the pointer shouldn't be shown, <code>False</code> if it should be hidden.
</dd></dl>

<p>
Note that <code>HWSATOP_SHOWHIDEPOINTER</code> will only be dispatched if you have set the
<code>HWADS_MOUSEPOINTER</code> tag to <code>True</code> (see below). (V9.0)

<p>
</dd>
<dt class="codelist"><code>HWSATOP_MOVEPOINTER:</code></dt>
<dd>
Hollywood wants your satellite to move the mouse pointer. <code>opdata</code> will
be set to a pointer to a <code>struct hwSatelliteMovePointer</code> which contains the
information about the new pointer position. <code>struct hwSatelliteMovePointer</code> looks like this:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>struct hwSatelliteMovePointer
{
    int X;
    int Y;
};
</pre></td></tr></table><p>

The structure members will be initialized as follows:

<p>
<dl>
<dt class="codelist"><code>X:</code></dt>
<dd>
The new x position for the mouse pointer.

<p>
</dd>
<dt class="codelist"><code>Y:</code></dt>
<dd>
The new y position for the mouse pointer.
</dd></dl>

<p>
Note that <code>HWSATOP_MOVEPOINTER</code> will only be dispatched if you have set the
<code>HWADS_MOUSEPOINTER</code> tag to <code>True</code> (see below). (V9.0)

<p>
</dd></dl>

<p>
Finally, <code>hw_AttachDisplaySatellite()</code> also accepts a tag list which allows you
to configure some further options. The following tags are currently recognized:

<p>
<dl>
<dt class="codelist"><code>HWADS_WIDTH:</code></dt>
<dd>
If you specify this tag, you need to set its <code>pData</code> member to a pointer to an <code>int</code>.
<code>hw_AttachDisplaySatellite()</code> will then write the root display's pixel width to
this <code>int</code>.

<p>
</dd>
<dt class="codelist"><code>HWADS_HEIGHT:</code></dt>
<dd>
If you specify this tag, you need to set its <code>pData</code> member to a pointer to an <code>int</code>.
<code>hw_AttachDisplaySatellite()</code> will then write the root display's pixel height to
this <code>int</code>.

<p>
</dd>
<dt class="codelist"><code>HWADS_DISPATCHVWAIT:</code></dt>
<dd>
This tag allows you to control whether or not you want to be notified when
the root display waits for the vertical blank. By default, you won't be notified
about this event but if you set the <code>iData</code> member of this tag to <code>True</code>, Hollywood
will dispatch the <code>HWSATOP_VWAIT</code> operation to your satellite dispatcher whenever
its root display waits for the vertical blank interrupt (see above). (V6.0)

<p>
</dd>
<dt class="codelist"><code>HWADS_OPTIMIZEDREFRESH:</code></dt>
<dd>
Set this tag to <code>True</code> to force optimized refresh of this display satellite's
parent. See <a href="OpenDisplay.html">OpenDisplay</a> for more information on optimized refresh. (V6.1)

<p>
</dd>
<dt class="codelist"><code>HWADS_CUSTOMSCALING:</code></dt>
<dd>
Set this tag to <code>True</code> if your dispatcher will handle autoscaling for this satellite.
In this case, Hollywood won't do any autoscaling but will simply tell the
dispatcher to do so. Note that this tag only affects autoscaling, layer scaling
will always be done by Hollywood. If your dispatcher implements custom scaling,
the dimensions returned by <code>HWADS_WIDTH</code> and <code>HWADS_HEIGHT</code> reflect the destination
scaling size and the dimensions returned by <code>HWADS_BUFFERWIDTH</code> and <code>HWADS_BUFFERHEIGHT</code>
reflect the source size. (V8.0)

<p>
</dd>
<dt class="codelist"><code>HWADS_BUFFERWIDTH:</code></dt>
<dd>
This tag can be used to get the width of the display satellite's parent's back buffer.
This can be different from what is returned in <code>HWADS_WIDTH</code> in case autoscaling is active.
The return value will be written to the <code>pData</code> member of this tag. You must set <code>pData</code> to
an <code>int</code> pointer for this purpose. (V8.0)

<p>
</dd>
<dt class="codelist"><code>HWADS_BUFFERHEIGHT:</code></dt>
<dd>
This tag can be used to get the height of the display satellite's parent's back buffer.
This can be different from what is returned in <code>HWADS_HEIGHT</code> in case autoscaling is active.
The return value will be written to the <code>pData</code> member of this tag. You must set <code>pData</code> to
an <code>int</code> pointer for this purpose. (V8.0)

<p>
</dd>
<dt class="codelist"><code>HWADS_PALETTE:</code></dt>
<dd>
Set this tag to <code>True</code> to indicate that your dispatcher can handle CLUT bitmaps as well,
i.e. <code>HWSATOP_BLTBITMAP</code> is able to deal with CLUT bitmaps. (V9.0)

<p>
</dd>
<dt class="codelist"><code>HWADS_MOUSEPOINTER:</code></dt>
<dd>
Set this tag to <code>True</code> to indicate that your dispatcher wants to be notified about
mouse pointer operations as well. If <code>HWADS_MOUSEPOINTER</code> is <code>True</code>, your dispatcher needs
to handle the mouse pointer operations <code>HWSATOP_SETPOINTER</code>, <code>HWSATOP_SHOWHIDEPOINTER</code>,
and <code>HWSATOP_MOVEPOINTER</code> as well. (V9.0)
</dd></dl>

<p>
Note that Hollywood versions prior to 6.0 did not check the tag list pointer against
<code>NULL</code> so make sure to pass a tag list even if there are no tags in it.

<p>
To detach your satellite from its root display, call the <a href="hw_DetachDisplaySatellite.html">hw_DetachDisplaySatellite()</a>
function. See <a href="hw_DetachDisplaySatellite.html">hw_DetachDisplaySatellite</a> for details. The user won't
be able to free the root display until all satellites have been detached.

<p>
</dd>
<dt class="autodoc"><b>Designer compatibility</b></dt><dd>
Unsupported

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>id</i></dt>
<dd>object identifier of the display you want to attach to</dd>
<dt><i>dispatcher</i></dt>
<dd>function to handle satellite actions (see above)</dd>
<dt><i>userdata</i></dt>
<dd>userdata to be passed to the dispatcher function</dd>
<dt><i>tags</i></dt>
<dd>taglist containing additional arguments; should not be <code>NULL</code> (see above)</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>handle</i></dt>
<dd>handle to the display satellite or <code>NULL</code> on error</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="hw_AttachDisplaySatellite_.html" target="_top">Show TOC</a></font>
</body>
</html>