@DATABASE Hollywood_SDK.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from Hollywood_SDK.meta by MetaDoc 1.13 (c) by Airsoft Softwair"
@$VER: Hollywood_SDK.guide 10.0 (04.02.2023)
@INDEX SDKReference
@HELP SDKReference

@NODE Main "Hollywood SDK"

 @{b}============================================================================================================@{ub}
 @{b}                                            Hollywood SDK 10.0          @{ub}
 @{b}============================================================================================================@{ub}
                       (C) Copyright 2002-2023 by Andreas Falkenhahn. All rights reserved.

 1. General information
 @{" Introduction                          " LINK Introduction}    What is the Hollywood SDK?
 @{" Terms and conditions                  " LINK License}    Legal information and license
 @{" Requirements                          " LINK Requirements}    What you need to work with the SDK
 @{" Example plugins                       " LINK Examples}    Example plugins included in the SDK
 @{" History                               " LINK History}    Information on the evolution of this SDK
 @{" Contact                               " LINK Contact}    How to get in touch with the author

 2. Conceptual overview
 @{" Getting started                       " LINK GettingStarted}    On the road to your first Hollywood plugin
 @{" Plugin types and Hollywood APIs       " LINK DocStructure}    Notes on the structure of this manual
 @{" What is a Hollywood plugin?           " LINK WhatIsAPlugin}    Technical notes on the file format of a Hollywood plugin
 @{" Basic plugin design                   " LINK PluginDesign}    Description of a Hollywood plugin's layout
 @{" Auto and manual init plugins          " LINK AutoAndManualInit}    Difference between auto- and manually-initialized plugins
 @{" Compiling plugins                     " LINK Compiling}    How to compile Hollywood plugins
 @{" Error codes                           " LINK ErrorCodes}    Error codes used by Hollywood plugins
 @{" Data types                            " LINK DataTypes}    Data types used by the Hollywood SDK
 @{" Version compatibility                 " LINK SDKVersions}    How to make your plugin work with different Hollywood versions
 @{" Tag lists                             " LINK TagLists}    Explanation of the tag list data type
 @{" Unicode support                       " LINK UnicodeSupport}    Character encoding to use when working with strings
 @{" File IO information                   " LINK FileIO}    Important information for all plugins doing file IO
 @{" File attributes                       " LINK FileAttributes}    File attributes recognized by Hollywood
 @{" Bitmap information                    " LINK BitmapInfo}    Information on different bitmap types supported by Hollywood
 @{" Pixel formats                         " LINK PixelFormats}    Pixel formats supported by Hollywood
 @{" Differences between Hollywood and Lua " LINK LuaVSHollywood}    Major differences between Hollywood and Lua
 @{" Object identifiers                    " LINK LuaID}    Internal representation of Hollywood object identifiers
 @{" User tags                             " LINK UserTags}    Pass additional information to Hollywood plugins
 @{" Multithreading                        " LINK Multithreading}    Notes on the thread safety of various functions
 @{" Designer compatibility                " LINK DesignerCompatibility}    Make your plugin compatible with Hollywood Designer
 @{" Legacy plugins                        " LINK LegacyPlugins}    Information about the plugin format used before Hollywood 5

 3. AmigaOS peculiarities
 @{" Glue code                             " LINK AmigaOSGlueCode}    Every AmigaOS plugin requires this glue code
 @{" C runtime limitations                 " LINK AmigaOSCRT}    Pitfalls to avoid when calling C runtime functions from your plugin
 @{" clib2 versus newlib                   " LINK AmigaOSclib2}    Information about the AmigaOS 4 C runtime library
 @{" __saveds keyword                      " LINK AmigaOSSaveDS}    Architectures that require you to use the __saveds keyword
 @{" Building for 68881 and 68882          " LINK AmigaOSFPU}    Important information for FPU builds
 @{" Building for WarpOS                   " LINK AmigaOSWarpOS}    Overview of PPC native APIs and calls that need a context switch

 4. Plugin types
 @{" Base plugin functions                 " LINK BaseOverview}    Every plugin has two implement these two functions
 @{" Convert script plugins                " LINK ConvertScriptOverview}    Magically turn random file formats into Hollywood scripts
 @{" Library plugins                       " LINK LibraryOverview}    Extend Hollywood's function library with new commands and constants
 @{" Image plugins                         " LINK ImageOverview}    Provide a loader for a new image file format
 @{" Animation plugins                     " LINK AnimOverview}    Enable Hollywood to load a new animation file format
 @{" Sound plugins                         " LINK SoundOverview}    Add support for a new sound file format
 @{" Vectorgraphics plugins                " LINK VectorGfxOverview}    Add a new vectorgraphics drawing backend to Hollywood
 @{" Video plugins                         " LINK VideoOverview}    Provide a loader for additional video formats
 @{" Image saver plugins                   " LINK ImageSaverOverview}    Enable Hollywood to save images in new formats
 @{" Animation saver plugins               " LINK AnimSaverOverview}    Add a saver for a new animation file format
 @{" Sample saver plugins                  " LINK SampleSaverOverview}    Provide a saver for a new sound file format
 @{" Require hook plugins                  " LINK RequireHookOverview}    Intercept all \@REQUIRE calls to your plugin
 @{" Display adapter plugins               " LINK DisplayAdapterOverview}    Completely replace Hollywood's display driver with a custom one
 @{" Timer adapter plugins                 " LINK TimerAdapterOverview}    Replace Hollywood's timer handler with a custom one
 @{" Requester adapter plugins             " LINK RequesterAdapterOverview}    Use your own requesters instead of Hollywood's default ones
 @{" File adapter plugins                  " LINK FileAdapterOverview}    Hook into Hollywood's file handler and intercept certain files
 @{" Directory adapter plugins             " LINK DirAdapterOverview}    Hook into Hollywood's directory handler and intercept certain dirs
 @{" Audio adapter plugins                 " LINK AudioAdapterOverview}    Completely replace Hollywood's audio driver with a custom one
 @{" Extension plugins                     " LINK ExtensionOverview}    Define supported extensions for certain plugin types
 @{" Network adapter plugins               " LINK NetworkAdapterOverview}    Implement handlers for custom network protocols
 @{" Serializer plugins                    " LINK SerializeOverview}    Support more data serialization formats
 @{" Icon plugins                          " LINK IconOverview}    Provide a loader for a new icon file format
 @{" Icon saver plugins                    " LINK IconSaverOverview}    Enable Hollywood to save icons in new formats
 @{" IPC adapter plugins                   " LINK IPCAdapterOverview}    Add support for additional IPC protocols
 @{" Font plugins                          " LINK FontOverview}    Add support for additional font formats
 @{" Filesystem adapter plugins            " LINK FilesysAdapterOverview}    Replace Hollywood's filesystem handler with a custom one

 5. Hollywood APIs
 @{" CRTBase functions                     " LINK CRTBaseOverview}    Functions from the ANSI C runtime library and POSIX
 @{" SysBase functions                     " LINK SysBaseOverview}    Lowlevel functions that deal with Hollywood's core functionality
 @{" DOSBase functions                     " LINK DOSBaseOverview}    Set of functions for working with files and directories
 @{" GfxBase functions                     " LINK GfxBaseOverview}    Functions that deal with graphics and displays
 @{" AudioBase functions                   " LINK AudioBaseOverview}    Various audio-related functions
 @{" RequesterBase functions               " LINK RequesterBaseOverview}    Functions to open different kinds of requesters
 @{" FontBase functions                    " LINK FontBaseOverview}    Miscellaneous functions that deal with font-related functionality
 @{" FT2Base functions                     " LINK FT2BaseOverview}    Interface to the FreeType2 library
 @{" LuaBase functions                     " LINK LuaBaseOverview}    Interface to the Lua VM
 @{" MiscBase functions                    " LINK MiscBaseOverview}    Various functions and data buffers that fit nowhere else
 @{" ZBase functions                       " LINK ZBaseOverview}    Interface to the zlib library
 @{" JPEGBase functions                    " LINK JPEGBaseOverview}    Interface to the libjpeg library
 @{" PluginBase functions                  " LINK PluginBaseOverview}    Functions that deal with Hollywood plugins
 @{" UtilityBase functions                 " LINK UtilityBaseOverview}    Collection of often needed utility functions
 @{" UnicodeBase functions                 " LINK UnicodeBaseOverview}    Functions for working with Unicode text
 @{" LocaleBase functions                  " LINK LocaleBaseOverview}    Functions for dealing with the locale

 @{" Index                                 " LINK SDKReference}    Quickly find what you are looking for

@ENDNODE
@NODE Introduction "Hollywood SDK"
@{b}Introduction@{ub}

    Welcome to the Hollywood Software Development Kit (SDK). This package
    contains all the necessary information and files to write your own Hollywood
    plugins. Plugins can greatly enhance Hollywood's functionality. They can
    provide load and save support for additional video, audio, image, icon, and
    sample formats, they can extend the command set of the Hollywood language as
    well as enable Hollywood to use real vector graphics and it is even possible
    to write plugins which replace core parts of Hollywood like its inbuilt
    display and audio driver with custom implementations provided by plugins. It
    is also possible to write plugins which convert project files of other
    applications like Scala or PowerPoint into Hollywood scripts so that
    Hollywood can run these project files directly although they are not in the
    *.hws format.

    Hollywood plugins use the suffix *.hwp. On all systems except on AmigaOS and
    compatibles, plugins must be stored in a directory named "Plugins" that is
    in the same directory as the main Hollywood program. On AmigaOS and
    compatible systems, plugins must be installed to LIBS:Hollywood instead. On
    macOS, the "Plugins" directory must be inside the "Resources" directory of
    the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources. When distributing
    a compiled Hollywood program, plugins required by your program must simply
    be put into the same directory as your program. On AmigaOS and compatible
    systems, plugins in a compiled program's directory have a higher priority
    than those in LIBS:Hollywood. So if a plugin is present in both locations,
    Hollywood will load the one from the program's directory. When compiling
    application bundles for macOS, plugins need to be put in the "Resources"
    directory of the application bundle, i.e. in
    MyProject.app/Contents/Resources.

    Plugins will be loaded automatically by Hollywood on startup. If you do not
    want this, you can disable automatic loading by renaming the plugin: Plugins
    whose filename starts with an underscore character ('_') will not be loaded
    automatically by Hollywood on startup. As an alternative, you can also use
    the -skipplugins console argument to tell Hollywood to skip automatic
    loading of certain plugins. Plugins which have not been loaded at startup,
    can be loaded later by using the "\@REQUIRE" preprocessor command or the
    "LoadPlugin()" function.

    The Android version of Hollywood also supports Hollywood plugins. You have
    to copy them to the directory Hollywood/Plugins on your SD card. Hollywood
    will scan this location on every startup and load all plugins from there. If
    you want to compile your own plugins, make sure that you compile in thumb
    mode.

@ENDNODE

@NODE License "Hollywood SDK"
@{b}Terms and conditions@{ub}

    The Hollywood SDK is © Copyright 2002-2023 by Andreas Falkenhahn (in the
    following referred to as "the author"). All rights reserved.

    The software is provided "as-is" and the author can not be made responsible
    of any possible harm done by it. You are using this software absolutely at
    your own risk. No warranties are implied or given by the author.

    This software must not be distributed without the written permission of the
    author.

    It is generally not allowed to release any kind of wrapper programs that
    make Hollywood commands available to other programming languages or the
    end-user. It is also generally not allowed to release any sort of mediator
    programs that would enable the user to access Hollywood commands through a
    mediating software.

    No changes may be made to the SDK without the permission of the author.

    This software uses Lua by Roberto Ierusalimschy, Waldemar Celes and Luiz
    Henrique de Figueiredo. See @{"Lua license" LINK LicenseLua} for details.

    This software uses libjpeg by the Independent JPEG Group.

    This software uses libpng by the PNG Development Group and zlib by Jean-loup
    Gailly and Mark Adler.

    This software uses PTPlay © Copyright 2001, 2003, 2004 by Ronald Hof, Timm
    S. Mueller, Per Johansson.

    This software uses the OpenCV library by Intel Corporation. See @{"OpenCV" LINK LicenseOpenCV}
    @{"library license" LINK LicenseOpenCV} for details.

    This software uses ImageMagick by ImageMagick Studio LLC. See @{"ImageMagick" LINK LicenseImageMagick}
    @{"license" LINK LicenseImageMagick} for details.

    This software uses the GD Graphics Library by Thomas Boutell. See @{"GD" LINK LicenseGD}
    @{"Graphics Library license" LINK LicenseGD} for details.

    This software uses the pixman library. See @{"Pixman license" LINK LicensePixman} for details.

    Portions of this software are copyright © 2010 The FreeType Project
    (http://www.freetype.org) . All rights reserved.

    Hollywood uses the Bitstream Vera font family. See @{"Bitstream Vera fonts" LINK LicenseVera}
    @{"license" LINK LicenseVera} for details.

    The Linux version of Hollywood uses gtk, glibc, and the Advanced Linux Sound
    Architecture (ALSA) all of which are licensed under the LGPL license. See
    @{"LGPL license" LINK LicenseLGPLv3} for details.

    The Android version of Hollywood uses the Simple DirectMedia Layer (SDL) by
    Sam Lantinga. See @{"SDL license" LINK LicenseSDL} for details.

    This software uses codesets.library by Alfonso Ranieri and the
    codesets.library Open Source Team. See @{"LGPL license" LINK LicenseLGPLv3} for details.

    This software uses LuaSocket by Diego Nehab. See @{"LuaSocket license" LINK LicenseLuaSocket} for
    details.

    This software uses librs232 by Petr Stetiar. See @{"librs232 license" LINK LicenseLibRS232} for
    details.

    This software uses UsbSerial by Felipe Herranz. See @{"UsbSerial license" LINK LicenseUsbSerial} for
    details.

    All trademarks are the property of their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "Hollywood SDK"
@{b}Requirements@{ub}

    This SDK is targetted at C/C++ programmers only. Using C/C++ for writing
    Hollywood plugins is recommended because C/C++ compilers are available for a
    multitude of platforms and thus it is usually not too difficult to make your
    plugin available for more than one platform.

    You need a C/C++ compiler and some knowledge about how to write shared
    libraries in C/C++ and how to compile them using your C/C++ compiler.

    It's recommended to use the following compilers:

    Windows:  Microsoft Visual C

    Linux, Android, macOS, AmigaOS 4, AROS, MorphOS:
              gcc

    AmigaOS 3:
              vbcc

    WarpOS:   vbcc

@ENDNODE

@NODE Examples "Hollywood SDK"
@{b}Examples@{ub}

    The Hollywood SDK comes with several example plugins and makefiles for lots
    of different platforms. You can study the source code of these examples to
    learn more about the practical aspects of writing a Hollywood plugin. The
    following example plugins are currently included with the SDK:

    AIFF:     This is a plugin of type "HWPLUG_CAPS_SOUND" which adds a loader
              for the AIFF audio file format popular on the macOS platforms to
              Hollywood. The AIFF file format's layout is very easy to
              understand so this plugin is a good starting point for learners
              who want to write a sound plugin. See @{"Sound plugins" LINK SoundOverview} for details.

    DisplayAdapter:
              This is a plugin of type "HWPLUG_CAPS_DISPLAYADAPTER". It is just
              a very basic example that shows how to replace Hollywood's inbuilt
              display adapter with a minimal custom display adapter (here based
              on SDL). It is not optimized in any way and only the most basic
              functionality has been implemented. Its aim is to get you started
              with writing custom display adapters, that's why this plugin has
              deliberately been kept as simple as possible to make it easier to
              understand the code. Once you have understood this plugin, here
              are some ideas how you can optimize it:

              1. Add support for hardware double buffers
              2. Add support for video bitmaps that can be drawn to hardware
                 double buffers
              3. Add support for scaling and transforming video bitmaps using
                 the GPU
              4. Add support for offscreen drawing to video bitmaps
              5. Add audio support through SDL

              RebelSDL can do all that and in fact this plugin is nothing else
              than a cut-down version of RebelSDL so as a little exercise you
              can try to implement all RebelSDL features that have been cut from
              this plugin.

    Library:  This is a plugin of type "HWPLUG_CAPS_LIBRARY". It adds some
              primitive functions and constants to Hollywood and is a good
              starting point if you want to extend Hollywood's command set using
              your own functions. It can also be used to learn about the way the
              Lua VM works. See @{"Library plugins" LINK LibraryOverview} for details.

    PCX:      This is a plugin of type "HWPLUG_CAPS_IMAGE" which adds a loader
              for the PCX image file format to Hollywood. Have a look at this
              source code if you intend to write an image loader plugin for
              Hollywood. See @{"Image plugins" LINK ImageOverview} for details.

    As an exercise, you might want to use the AIFF or PCX plugin source codes as
    a starting point and extend them to include a saver for these formats as
    well. See @{"Image saver plugins" LINK ImageSaverOverview} for details. See @{"Sample saver plugins" LINK SampleSaverOverview} for
    details.

    More plugin source codes are available at the official Hollywood portal at
    http://www.hollywood-mal.com. You can find them in the download section next
    to the binary distributions of the plugins.

@ENDNODE

@NODE History "Hollywood SDK"
@{b}History@{ub}

    Please consult the Hollywood documentation for a detailed list of changes in
    the course of Hollywood's evolution.

@ENDNODE

@NODE Contact "Hollywood SDK"
@{b}Contact@{ub}

    If you need to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE GettingStarted "Hollywood SDK"
@{b}Getting started@{ub}

    The best way to learn to write Hollywood plugins is a learning-by-doing
    based approach. Just take a look at the source code of one of the example
    plugins that come with this SDK and use this documentation to try to
    understand what is going on there. After you have understood the structure
    and operation modes of some basic plugins, you can start to extend them by
    adding your own code, using this documentation as a reference manual.

    This SDK expects that you are familiar with the C language and know how to
    use a C compiler to create libraries. If you aren't an experienced Amiga
    programmer, it is advised that you start out on Windows or Linux first,
    because it's much easier to write Hollywood plugins on these systems than on
    AmigaOS-based systems. Once you have developed a stable plugin on Windows or
    Linux and you are confident with Hollywood's plugin API, you may tackle an
    AmigaOS build as well, although there are several pitfalls that you have to
    avoid. See @{"AmigaOS peculiarities" LINK AmigaOSGlueCode} for details.

    If you need help, don't hesitate to ask on the official Hollywood forums
    which are online at http://forums.hollywood-mal.com/ There you will find a
    friendly community from all around the world which can surely help you to
    solve your programming problems.

@ENDNODE

@NODE DocStructure "Hollywood SDK"
@{b}Plugin types and Hollywood APIs@{ub}

    This documentation can be divided into two major parts: The first part
    describes all the different plugin types supported by Hollywood and their
    interfaces. There is detailed information on all the functions you will have
    to implement for the individual plugin types as well as on the way Hollywood
    interacts with them. As of Hollywood 10.0, the following plugin types are
    supported:

    - Convert script plugins: These plugins automatically convert a custom file
      format into a Hollywood script. See @{"Convert script plugins" LINK ConvertScriptOverview} for details.

    - Library plugins: These plugins can add new commands and constants to
      Hollywood's script language. See @{"Library plugins" LINK LibraryOverview} for details.

    - Image plugins: These plugins can provide loaders for additional image
      formats. See @{"Image plugins" LINK ImageOverview} for details.

    - Animation plugins: These plugins can provide loaders for additional
      animation formats. See @{"Animation plugins" LINK AnimOverview} for details.

    - Sound plugins: These plugins can provide loaders for additional sound and
      music formats. See @{"Sound plugins" LINK SoundOverview} for details.

    - Vectorgraphics plugins: These plugins can provide code for drawing
      vector-based graphics. See @{"Vectorgraphics plugins" LINK VectorGfxOverview} for details.

    - Video plugins: These plugins can provide loaders for additional video
      formats. See @{"Video plugins" LINK VideoOverview} for details.

    - Image saver plugins: These plugins can provide savers for additional image
      formats. See @{"Image saver plugins" LINK ImageSaverOverview} for details.

    - Animation saver plugins: These plugins can provide savers for additional
      animation formats. See @{"Animation saver plugins" LINK AnimSaverOverview} for details.

    - Sample saver plugins: These plugins can provide savers for additional
      sample formats. See @{"Sample saver plugins" LINK SampleSaverOverview} for details.

    - Require hook plugins: These plugins can hook into Hollywood's "\@REQUIRE"
      preprocessor command to do their initialization only when explicitly asked
      to. See @{"Require hook plugins" LINK RequireHookOverview} for details.

    - Display adapter plugins: These plugins can completely replace Hollywood's
      internal display driver with a custom one. This is a very powerful plugin
      type and can be used to achieve quite astonishing things. See @{"Display" LINK DisplayAdapterOverview}
      @{"adapter plugins" LINK DisplayAdapterOverview} for details.

    - Timer adapter plugins: These plugins can completely replace Hollywood's
      internal timer handler with a custom one. See @{"Timer adapter plugins" LINK TimerAdapterOverview} for
      details.

    - Requester adapter plugins: These plugins can completely replace
      Hollywood's internal requester handler with a custom one. See @{"Requester" LINK RequesterAdapterOverview}
      @{"adapter plugins" LINK RequesterAdapterOverview} for details.

    - File adapter plugins: These plugins can hook into Hollywood's file handler
      and intercept any file they like. This can be used to make Hollywood
      magically able to handle compressed files or entirely new file formats.
      See @{"File adapter plugins" LINK FileAdapterOverview} for details.

    - Directory adapter plugins: These plugins can hook into Hollywood's
      directory handler and intercept access on any directory they like. This
      can be used to allow Hollywood to deal with custom directory types, e.g. a
      plugin that treats a ZIP file as a directory could be written using the
      directory adapter plugin interface. See @{"Directory adapter plugins" LINK DirAdapterOverview} for
      details.

    - Audio adapter plugins: These plugins can completely replace Hollywood's
      internal audio driver with a custom one. See @{"Audio adapter plugins" LINK AudioAdapterOverview} for
      details.

    - Extension plugins: This is a special plugin type that does not offer any
      functionality on its own. Its only purpose is to extend other plugin
      types. See @{"Extension plugins" LINK ExtensionOverview} for details.

    - Network adapter plugins: These plugins can hook into Hollywood's network
      handler and implement support for all kinds of custom protocols. This
      makes it possible to access servers not supported by Hollywood itself
      through Hollywood's standard network library. See @{"Network adapter plugins" LINK NetworkAdapterOverview}
      for details.

    The second major part of this manual is the documentation of the functions
    that are publically exposed by Hollywood to every plugin. When Hollywood
    calls the @{"InitPlugin()" LINK InitPlugin} function of a plugin, it passes a pointer to a
    hwPluginAPI data structure which contains pointers to all the API functions
    that Hollywood has made publically available. Currently, the hwPluginAPI
    structure looks like this:

        typedef struct _hwPluginAPI
        {
            int hwVersion;
            int hwRevision;
            hwCRTBase *CRTBase;
            hwSysBase *SysBase;
            hwDOSBase *DOSBase;
            hwGfxBase *GfxBase;
            hwAudioBase *AudioBase;
            hwRequesterBase *RequesterBase;
            hwFontBase *FontBase;
            hwFT2Base *FT2Base;
            hwLuaBase *LuaBase;
            hwMiscBase *MiscBase;

            /****** V5.3 vectors start here *****/
            hwZBase *ZBase;
            hwJPEGBase *JPEGBase;

            /****** V6.0 vectors start here *****/
            hwPluginLibBase *PluginBase;
            hwUtilityBase *UtilityBase;

            /****** V7.0 vectors start here *****/
            hwUnicodeBase *UnicodeBase;

            /****** V7.1 vectors start here *****/
            hwLocaleBase *LocaleBase;
        } hwPluginAPI;

    All the individual structure members point to libraries, i.e. collections of
    functions that your plugin can use to interact with Hollywood. The way you
    have to call these functions is described in the second major part of this
    documentation. See @{"GfxBase functions" LINK GfxBaseOverview} to find out about all functions
    supported by the GfxBase library, for example.

@ENDNODE

@NODE WhatIsAPlugin "Hollywood SDK"
@{b}What is a Hollywood plugin?@{ub}

    A Hollywood plugin is a shared library that is dynamically loaded by
    Hollywood at run time. Every Hollywood plugin has to export a number of
    function symbols that Hollywood can call when necessary. The actual file
    format of a plugin is platform-dependent. Here is an overview of the file
    formats used by Hollywood plugins on the individual platforms:

    Windows:  Hollywood plugins have to be compiled as standard Windows DLLs.
              Hollywood loads plugins using "LoadLibrary()".

    macOS:    Hollywood plugins have to be compiled as dynamic libraries
              (dylib). Hollywood loads plugins using "dlopen()".

    Linux and Android:
              Hollywood plugins have to be compiled as shared objects. Hollywood
              loads plugins using "dlopen()".

    AmigaOS and compatibles:
              Hollywood plugins have to be compiled as executables that can be
              loaded via "LoadSeg()". As AmigaOS doesn't supported named symbol
              export, some glue code is necessary to allow access to named
              symbols. See @{"AmigaOS glue code" LINK AmigaOSGlueCode} for details. Another speciality on
              AmigaOS is that you cannot use certain functions from the standard
              ANSI C runtime library. See @{"AmigaOS C runtime limitations" LINK AmigaOSCRT} for
              details.

    Please note that although Hollywood uses common file formats like DLLs on
    Windows, dylibs on macOS, and shared objects on Linux/Android, the file
    extension of a Hollywood plugin always has to be *.hwp. Otherwise Hollywood
    won't be able to detect plugins.

@ENDNODE

@NODE PluginDesign "Hollywood SDK"
@{b}Basic plugin design@{ub}

    Every Hollywood plugin needs to export the functions @{"InitPlugin()" LINK InitPlugin} and
    @{"ClosePlugin()" LINK ClosePlugin}. As their names imply, these two functions initialize and
    close a plugin. By calling @{"InitPlugin()" LINK InitPlugin} Hollywood asks your plugin to
    identify itself, i.e. it needs to report certain information back to
    Hollywood, e.g. its feature set, author, version, minimum required Hollywood
    version and so on. Depending on this information, Hollywood will then import
    other function pointers from the plugin, depending on the feature set the
    plugin has reported to Hollywood.

    To describe its feature set, the plugin sets the hwPluginBase.CapsMask field
    to a combination of capability bits taken from the "HWPLUG_CAPS_XXX"
    definitions in hollywood/plugin.h. Hollywood then knows what this plugin can
    do and will import the needed function pointers. For example, if
    hwPluginBase.CapsMask is set to HWPLUG_CAPS_SOUND|HWPLUG_CAPS_SAVESAMPLE,
    Hollywood will know that this plugin can load sound files and save sample
    files. Hollywood will therefore import the following additional function
    pointers from the plugin:

        OpenStream()
        CloseStream()
        SeekStream()
        StreamSamples()
        GetFormatName()
        RegisterSampleSaver()
        SaveSample()

    If one of the function pointers listed above cannot be resolved, Hollywood
    won't load this plugin.

    See @{"InitPlugin()" LINK InitPlugin} for details.

    See @{"ClosePlugin()" LINK ClosePlugin} for details.

    Note that starting with Hollywood 10.0, all functions exported by plugins
    should use the prefix "hwp_" to avoid name clashes with other APIs. Thus,
    for a plugin targetting Hollywood 10.0 or better, the plugin example from
    above should better export the following functions instead of the one listed
    above:

        hwp_OpenStream()
        hwp_CloseStream()
        hwp_SeekStream()
        hwp_StreamSamples()
        hwp_GetFormatName()
        hwp_RegisterSampleSaver()
        hwp_SaveSample()

    Using the "hwp_" prefix makes sure that there are no clashes with other
    (system) APIs. Keep in mind, though, that if you use the "hwp_" prefix in
    your function exports, your plugin won't run on any Hollywood version that
    is older than 10.0. That's why in this documentation the "hwp_" prefix won't
    be explicitly mentioned in the documentation of the individual plugin
    functions because many plugin authors might want to target older Hollywood
    versions as well. If your plugin needs Hollywood 10.0 or better, though, you
    should always use the "hwp_" prefix in your function exports and you should
    also define the "HW_USEPREFIX" macro so that the correct prototypes are used
    in hollywood/plugin.h.

@ENDNODE

@NODE AutoAndManualInit "Hollywood SDK"
@{b}Auto and manual init plugins@{ub}

    All available plugins will be loaded automatically by Hollywood upon
    startup. However, not all plugins will be initialized automatically. Some
    plugin types will only be initialized if the user explicitly calls
    "\@REQUIRE" on them. The reason for this is simple: Some plugin types can
    completely replace core components of Hollywood like the inbuilt display or
    audio driver. It would not make any sense to activate these plugins
    automatically upon startup because it could happen then that several plugins
    try to replace the same core component and it would also make it impossible
    to revert to Hollywood's inbuilt drivers. That's the reason why certain
    plugin types are only initialized if explicitly demanded by the user by
    calling "\@REQUIRE" on them. Other plugin types, however, like loaders and
    savers for additional file formats are normally initialized automatically so
    that they are immediately available to all Hollywood applications right
    after their installation. Starting with Hollywood 6.0 it is possible to
    prevent automatic initialization of image, animation, sound, and video
    loader plugins using extension flags.

    If you want to write a plugin that requires manual initialization, you need
    to set the "HWPLUG_CAPS_REQUIRE" capability flag in your @{"InitPlugin()" LINK InitPlugin}
    implementation. Hollywood will then call your plugin whenever the user runs
    the "\@REQUIRE" preprocessor command on your plugin. You will then be able
    to perform all necessary initialization in your implementation of the
    @{"RequirePlugin()" LINK RequirePlugin} call.

    Here's a brief overview which plugin types are automatically initialized and
    which plugin types have to be manually initialized from your @{"RequirePlugin()" LINK RequirePlugin}
    function:

    HWPLUG_CAPS_CONVERT
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_LIBRARY
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.1 automatic loading can be disabled by setting the
              "HWEXT_LIBRARY_NOAUTOINIT" extension bit.

    HWPLUG_CAPS_IMAGE
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.0 automatic loading can be disabled by setting the
              "HWEXT_IMAGE_NOAUTOINIT" extension bit.

    HWPLUG_CAPS_ANIM
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.0 automatic loading can be disabled by setting the
              "HWEXT_ANIM_NOAUTOINIT" extension bit.

    HWPLUG_CAPS_SOUND
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.0 automatic loading can be disabled by setting the
              "HWEXT_SOUND_NOAUTOINIT" extension bit.

    HWPLUG_CAPS_VECTOR
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.0, however, the user will have to call
              "SetVectorEngine()" manually to make Hollywood's vectorgraphics
              library use the plugin.

    HWPLUG_CAPS_VIDEO
              Initialized automatically when plugin is loaded. Starting with
              Hollywood 6.0 automatic loading can be disabled by setting the
              "HWEXT_VIDEO_NOAUTOINIT" extension bit.

    HWPLUG_CAPS_SAVEIMAGE
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_SAVEANIM
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_SAVESAMPLE
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_REQUIRE
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_DISPLAYADAPTER
              Use @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} to initialize this plugin type. See
              @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

    HWPLUG_CAPS_TIMERADAPTER
              Use @{"hw_SetTimerAdapter()" LINK hw_SetTimerAdapter} to initialize this plugin type. See
              @{"hw_SetTimerAdapter" LINK hw_SetTimerAdapter} for details.

    HWPLUG_CAPS_REQUESTERADAPTER
              Use @{"hw_SetRequesterAdapter()" LINK hw_SetRequesterAdapter} to initialize this plugin type. See
              @{"hw_SetRequesterAdapter" LINK hw_SetRequesterAdapter} for details.

    HWPLUG_CAPS_FILEADAPTER
              Use @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to initialize this plugin type. See
              @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for details.

    HWPLUG_CAPS_DIRADAPTER
              Use @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to initialize this plugin type. See
              @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for details.

    HWPLUG_CAPS_AUDIOADAPTER
              Use @{"hw_SetAudioAdapter()" LINK hw_SetAudioAdapter} to initialize this plugin type. See
              @{"hw_SetAudioAdapter" LINK hw_SetAudioAdapter} for details.

    HWPLUG_CAPS_EXTENSION
              This is a special plugin type that extends other plugin types. It
              does not offer any functionality on its own.

    HWPLUG_CAPS_NETWORKADAPTER
              Use @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to initialize this plugin type. See
              @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for details.

    HWPLUG_CAPS_SERIALIZE
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_ICON
              Initialized automatically when plugin is loaded. Automatic loading
              can be disabled by setting the "HWEXT_ICON_NOAUTOINIT" extension
              bit.

    HWPLUG_CAPS_SAVEICON
              Initialized automatically when plugin is loaded.

    HWPLUG_CAPS_IPCADAPTER
              Use @{"hw_SetIPCAdapter()" LINK hw_SetIPCAdapter} to initialize this plugin type. See
              @{"hw_SetIPCAdapter" LINK hw_SetIPCAdapter} for details.

    HWPLUG_CAPS_FONT
              Initialized automatically when plugin is loaded. Automatic loading
              can be disabled by setting the "HWEXT_FONT_NOAUTOINIT" extension
              bit.

    HWPLUG_CAPS_FILESYSADAPTER
              Use @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to initialize this plugin type. See
              @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for details.

    You will normally call the functions listed above in your @{"RequirePlugin()" LINK RequirePlugin}
    implementation. See @{"RequirePlugin" LINK RequirePlugin} for details.

    Some plugin types only support the initialization of a single plugin, e.g.
    it is not possible to have multiple display adapter plugins running. Only a
    single display adapter can be active at a time. Thus, only the first call to
    @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} will succeed. All other attempts to install another
    display adapter will fail once a plugin has installed a custom display
    adapter.

@ENDNODE

@NODE Compiling "Hollywood SDK"
@{b}Compiling plugins@{ub}

    All source files that include hollywood/plugin.h need to be compiled with
    certain preprocessor commands defined, depending on the platform. Here is a
    list of preprocessor commands that may need to be defined, depending on your
    platform:

    HW_AMIGAOS3
              Needs to be defined for AmigaOS 3 builds.

    HW_AMIGAOS4
              Needs to be defined for AmigaOS 4 builds.

    HW_ANDROID
              Needs to be defined for Android builds.

    HW_AROS   Needs to be defined for AROS builds.

    HW_LINUX  Needs to be defined for Linux builds.

    HW_LITTLE_ENDIAN
              Needs to be defined for little endian builds.

    HW_MACOS  Needs to be defined for macOS builds.

    HW_MORPHOS
              Needs to be defined for MorphOS builds.

    HW_WARPOS Needs to be defined for WarpOS builds.

    HW_WIN32  Needs to be defined for Windows builds.

    Also make sure to use the "HW_EXPORT" macro on all function declarations
    that you export as shared library functions to Hollywood, i.e.

        HW_EXPORT int InitPlugin(hwPluginBase *self, hwPluginAPI *cl, STRPTR p)
        {
            ...
        }

    Note that when targetting Hollywood 10.0 or better, your plugin function
    exports should always use the "hwp_" prefix. Thus, if you target Hollywood
    10.0 or better, you should export your @{"InitPlugin()" LINK InitPlugin} function like this
    instead:

        HW_EXPORT int hwp_InitPlugin(hwPluginBase *s, hwPluginAPI *c, STRPTR p)
        {
            ...
        }

    Using the "hwp_" prefix makes sure that there are no clashes with other
    (system) APIs. Keep in mind, though, that if you use the "hwp_" prefix in
    your function exports, your plugin won't run on any Hollywood version that
    is older than 10.0. That's why in this documentation the "hwp_" prefix won't
    be explicitly mentioned in the documentation of the individual plugin
    functions because many plugin authors might want to target older Hollywood
    versions as well. If your plugin needs Hollywood 10.0 or better, though, you
    should always use the "hwp_" prefix in your function exports and you should
    also define the "HW_USEPREFIX" macro so that the correct prototypes are used
    in hollywood/plugin.h.

    Finally, don't forget to target your plugin for the right architecture. The
    32-bit version of Hollywood can only load plugins compiled for a 32-bit
    architecture whereas the 64-bit version can only load plugins compiled for
    64-bit. Modern compilers often default to 64-bit binaries nowadays so keep
    in mind that these binaries can't be loaded by the 32-bit versions of
    Hollywood. To make it easier for you to distinguish between 32-bit and
    64-bit builds, the Hollywood SDK will automatically define the "HW_64BIT"
    preprocessor constant when it has detected that you are building for a
    64-bit target.

    On AmigaOS you also need to make sure that you do not link the compiler's
    startup code against the plugin as this can cause conflicts. You also must
    not use any library auto-open features provided by the compiler. You need to
    manually open all Amiga libraries that your plugin requires. See @{"AmigaOS C" LINK AmigaOSCRT}
    @{"runtime limitations" LINK AmigaOSCRT} for details.

@ENDNODE

@NODE ErrorCodes "Hollywood SDK"
@{b}Error codes@{ub}

    Many functions require you to return a Hollywood error code to indicate
    success or failure. All standard error codes are defined in
    hollywood/errors.h but you can also register custom error codes using To
    indicate success, you have to return 0 which is equivalent to the constant
    "ERR_NONE".

    A special error code is "ERR_USERABORT". If you return this error code,
    Hollywood will immediately shut down and quit without showing any error
    message.

@ENDNODE

@NODE DataTypes "Hollywood SDK"
@{b}Data types@{ub}

    The Hollywood SDK defines a few additional data types that are often used by
    its functions. They are all defined in <hollywood/types.h>. Here is a brief
    overview:

    APTR:     The arbitrary pointer. This is used to declare pointers to memory
              buffers that contain data of various sizes. The C equivalent to
              the "APTR" is the "void" pointer.

    STRPTR:   The string pointer. This data type is used to refer to
              null-terminated strings. See @{"Unicode support" LINK UnicodeSupport} for details.

    UBYTE:    This data type is used for an unsigned byte (8-bit).

    UWORD:    This data type is used for an unsigned word (16-bit).

    ULONG:    This data type is used for an unsigned long-word (32-bit).

    DOSINT64: This is a platform-dependent data type for IO functions that deal
              with 64-bit integers. On platforms that support 64-bit file IO,
              this is set to a signed 64-bit quantity whereas on platforms that
              do not support 64-bit file IO, e.g. AmigaOS 3.x, this is set to a
              signed 32-bit quantity, limiting large file support to 2
              gigabytes.

    IPTR:     An unsigned integer that is large enough to hold a pointer. This
              is 4 bytes on 32-bit systems and 8 bytes on 64-bit systems.

@ENDNODE

@NODE SDKVersions "Hollywood SDK"
@{b}Version compatibility@{ub}

    It is possible to write plugins which dynamically make use of features of
    newer Hollywood versions. However, you need to be very careful when trying
    to access structure members or functions that are not available in all
    Hollywood versions. For example, let's consider the struct LoadSoundCtrl
    structure which looks like this:

        struct LoadSoundCtrl
        {
            ULONG Samples;
            int Channels;
            int Bits;
            int Frequency;
            ULONG Flags;
            int SubSong;        // V5.3
            int NumSubSongs;    // V5.3
            STRPTR Adapter;     // V6.0
        };

    You can see that the "SubSong" and "NumSubSongs" members are not available
    in Hollywood versions before 5.3 and "Adapter" is not available before
    Hollywood 6.0. This means that if your plugin is targetted at Hollywood 5.0
    and up, you must only access these fields if you've verified that the user
    is running at least Hollywood 5.3 or 6.0 respectively. Otherwise you are
    going to access uninitialized memory which can easily lead to a crash.
    Hollywood will pass its version and revision numbers to your @{"InitPlugin()" LINK InitPlugin}
    function. It's recommended to store this information somewhere in your
    plugin so that your @{"OpenStream()" LINK OpenStream} function can verify that the user is
    running Hollywood 5.3 or 6.0 before accessing the new structure members.
    Such a check could look like this:

        ctrl->Frequency = 48000;
        ctrl->Channels = 2;
        ctrl->Bits = 16;
        ctrl->Samples = numsamples;
        ctrl->Flags = HWSNDFLAGS_SIGNEDINT;

        // only return NumSubSongs if Hollywood >= 5.3
        if(hwver > 5 || (hwver == 5 && hwrev >= 3)) {
            ctrl->NumSubSongs = numsubsongs;
        }

    Furthermore, be extra careful when using "memset()" to zero-out structure
    memory. For example, to zero-out struct LoadSoundCtrl you could do the
    following inside your @{"OpenStream()" LINK OpenStream} implementation:

        memset(ctrl, 0, sizeof(struct LoadSoundCtrl));

    This, however, will cause memory access faults when the plugin is loaded by
    Hollywood versions older than version 6.0 because in that case the structure
    pointer passed to your @{"OpenStream()" LINK OpenStream} function will point to a memory block
    that is smaller than the one used by Hollywood 6.0. If you just do a
    "memset()" without verifying version numbers first, you will write to
    unallocated memory which is likely to crash Hollywood. Thus, always make
    sure to check version numbers before reading from or writing to structure
    memory passed to your plugin by Hollywood.

    If this is too much hassle for you, you can also declare that your plugin
    requires at least Hollywood 6.0 in your @{"InitPlugin()" LINK InitPlugin} implementation. If you
    do that, then you won't have to do all these checks of course because all
    Hollywood versions earlier than 6.0 will simply refuse to load your plugin.

    You also have to be careful when calling Hollywood API functions from the
    different library bases. On its man page, every library base API function is
    followed by a version number in brackets which indicates the Hollywood
    version in which this API was first introduced. Before calling Hollywood API
    functions you must make sure that the user is running a Hollywood version
    that has this API using one of the methods described above.

@ENDNODE

@NODE TagLists "Hollywood SDK"
@{b}Tag lists@{ub}

    People familiar with AmigaOS programming will already know about the concept
    of tag lists which can be used to pass additional arguments to functions or
    receive additional return values. The Hollywood SDK makes extensive use of
    this concept so that the capabilities of the individual functions can be
    easily extended in the future simply by offering new tags.

    A tag list is an array of a number of struct hwTagList elements that is
    terminated by a last element that has its "Tag" member set to 0. Many
    Hollywood SDK API functions accept such a tag list as their last argument in
    order to be extensible. struct hwTagList looks like this:

        struct hwTagList
        {
            ULONG Tag;
            union {
                ULONG iData;
                void *pData;
            } Data;
        };

    As you can see, each tag item is accompanied by a data item that can either
    be an integer value or a pointer. Tag items can either be used to pass
    additional parameters to a function or they can also be used to receive
    additional return values from a function by setting the "pData" pointer to a
    variable that is to receive an additional return value. The data that needs
    to be passed in the "iData" or "pData" elements depends on the tag of
    course. This is all documented alongside the respective API functions.

    Here is an example of how a tag list is used with the @{"hw_SetAudioAdapter()" LINK hw_SetAudioAdapter}
    API:

        struct hwTagList[3];

        t[0].Tag = HWSAATAG_BUFFERSIZE;
        t[0].Data.iData = 2048;
        t[1].Tag = HWSAATAG_CHANNELS;
        t[1].Data.iData = 8;
        t[2].Tag = 0;

        error = hw_SetAudioAdapter(self, HWSAAFLAGS_PERMANENT, t);

    In this case, a tag list is used to pass some additional parameters to
    @{"hw_SetAudioAdapter()" LINK hw_SetAudioAdapter}.

@ENDNODE

@NODE UnicodeSupport "Hollywood SDK"
@{b}Unicode support@{ub}

    Starting with version 7.0, Unicode is now fully supported by Hollywood. By
    default, Hollywood always runs in Unicode mode now which means that all
    strings that your plugin gets from Hollywood or that your plugin passes to
    Hollywood must be in the UTF-8 encoding. This even applies to standard C
    functions in @{"CRTBase" LINK CRTBaseOverview} like "fopen()", "stat()", "rename()", "remove()", etc.
    Normally, those functions from the C runtime library aren't UTF-8 compatible
    on all systems (most notably they aren't UTF-8 compatible on Windows and
    AmigaOS), but when calling those standard C runtime functions through
    Hollywood's @{"CRTBase" LINK CRTBaseOverview} they will expect UTF-8 strings.

    Note that scripts may explicitly request running in compatibility mode which
    puts Hollywood back into ISO 8859-1 mode which was used before Hollywood
    7.0. In that case, all strings that your plugin gets from Hollywood or
    passes to Hollywood must be in ISO 8859-1 encoding. Supporting this
    compatibility mode can greatly increase the complexity of your plugin which
    is why you should think about whether your plugin really needs to support
    this mode or if you just make Hollywood running in Unicode mode a
    requirement for your plugin.

    If you do decide to support compatibility mode in your plugin, the
    recommended way to detect the compatibility mode is to install a callback
    for the "HWCB_ENCODINGCHANGE" type in your @{"InitPlugin()" LINK InitPlugin} implementation using
    @{"hw_RegisterCallback()" LINK hw_RegisterCallback}. This callback will then be called if a script
    explicitly requests running in compatibility mode.

    Note that if you want your plugin to be compatible with Hollywood versions
    older than 7.0, you have to support the ISO 8859-1 compatibility mode as
    well of course, because before Hollywood 7.0 all strings were in ISO 8859-1
    encoding anyway.

    Here's how you could deal with both cases in your @{"InitPlugin()" LINK InitPlugin}
    implementation. We first check the Hollywood version. If it is older than
    7.0, we run in the ISO 8859-1 encoding. If it is at least 7.0, we install an
    encoding change callback to find out whether Hollywood is running in
    compatibility mode or UTF-8 mode. Here is the code:

        // we store the encoding used by Hollywood here
        static int useencoding;

        // this callback will be run if the encoding changes; note that this
        // will never be called more than once; the encoding can only change
        // during Hollywood's program startup, not on the fly!
        static SAVEDS void encodingchange(int encoding, APTR userdata)
        {
            useencoding = encoding;
        }

        HW_EXPORT int InitPlugin(hwPluginBase *self, hwPluginAPI *cl, STRPTR
            path)
        {
            // on Hollywood 7 or better, UTF-8 is the default encoding whereas
            // older version use ISO 8859-1 instead
            if(self->hw_Version > 6) {
                useencoding = HWOS_ENCODING_UTF8;
            } else {
                useencoding = HWOS_ENCODING_ISO8859_1;
            }

            // do initialization here
            ....

            // if we are on Hollywood 7 or better, let us know if the script
            // requests compatibility mode
            if(hwcl->hwVersion > 6) {
                hwcl->SysBase->hw_RegisterCallback(HWCB_ENCODINGCHANGE, (APTR)
                    encodingchange, NULL);
            }

            return TRUE;
        }

    To convert between different encodings there is a convenience function named
    @{"hw_ConvertString()" LINK hw_ConvertString}. See @{"hw_ConvertString" LINK hw_ConvertString} for details.

@ENDNODE

@NODE FileIO "Hollywood SDK"
@{b}File IO information@{ub}

    As Hollywood can deal with virtual files as well as with files linked into
    other files like applets or executables there are some things to attend to
    when writing plugins that deal with files. If you want your plugin to
    support all these Hollywood-specific extensions you must make sure that you
    only use IO functions provided by Hollywood in the "DOSBase" pointer to deal
    with files. If you use functions like "fopen()" from the ANSI C library
    instead, your plugin will only work with normal files that are physically
    existent on a system drive.

    For example, when writing plugins that provide loaders for additional file
    formats like images, sounds, or videos it can often happen that the filename
    that is passed to your plugin is a specially formatted specification that
    Hollywood uses to load files that have been linked to applets or
    executables. If you do not use Hollywood's IO functions to open this file,
    your plugin won't be able to load files that have been linked to applets or
    executables. This can be quite annoying for the end-user because the ability
    to link data files into applets and executables is a key functionality of
    Hollywood and thus your plugin should strive to be compatible with it. If
    you use "fopen()" instead, it will just fail whenever your function is
    passed a specially formatted specification to open one of Hollywood's
    virtual files.

    If your plugin has to use IO functions from the C runtime for some
    particular reason and you are unable to use the functions from "DOSBase"
    instead, you can translate virtual file specifications into physical files
    using the @{"hw_TranslateFileName()" LINK hw_TranslateFileName} or @{"hw_TranslateFileNameExt()" LINK hw_TranslateFileNameExt} APIs. See
    @{"hw_TranslateFileName" LINK hw_TranslateFileName} for details.

@ENDNODE

@NODE FileAttributes "Hollywood SDK"
@{b}File attributes@{ub}

    The following attributes are supported by Hollywood for file system objects,
    i.e. files and directories:

    HWOS_FILEATTR_READ:
              Read access is granted (user scope). This is unsupported on Win32.

    HWOS_FILEATTR_WRITE:
              Write access is granted (user scope). This is unsupported on
              Win32.

    HWOS_FILEATTR_DELETE:
              Delete access is granted. This is only supported on AmigaOS and
              compatibles.

    HWOS_FILEATTR_EXECUTE:
              Execute access is granted (user scope). This is unsupported on
              Win32.

    HWOS_FILEATTR_PURE:
              File can be made resident. This is only supported on AmigaOS and
              compatibles.

    HWOS_FILEATTR_ARCHIVE:
              Archive bit. This is supported on AmigaOS and Win32.

    HWOS_FILEATTR_SCRIPT:
              File is an AmigaDOS script. This is only supported on AmigaOS and
              compatibles.

    HWOS_FILEATTR_HIDDEN:
              File is hidden. This is supported on AmigaOS and Win32.

    HWOS_FILEATTR_SYSTEM:
              User for system files on Win32.

    HWOS_FILEATTR_READG:
              Read access is granted (group scope). This is unsupported on Win32
              and AmigaOS.

    HWOS_FILEATTR_WRITEG:
              Write access is granted (group scope). This is unsupported on
              Win32 and AmigaOS.

    HWOS_FILEATTR_EXECUTEG:
              Execute access is granted (group scope). This is unsupported on
              Win32 and AmigaOS.

    HWOS_FILEATTR_READO:
              Read access is granted (others scope). This is unsupported on
              Win32 and AmigaOS.

    HWOS_FILEATTR_WRITEO:
              Write access is granted (others scope). This is unsupported on
              Win32 and AmigaOS.

    HWOS_FILEATTR_EXECUTEO:
              Execute access is granted (others scope). This is unsupported on
              Win32 and AmigaOS.

    HWOS_FILEATTR_READONLY:
              Only read-access is allowed for this file. Supported on Win32
              only.

    You'll have to deal with these attributes if you write a file or directory
    adapter.

    See @{"Stat" LINK Stat} for details.

    See @{"NextDirEntry" LINK NextDirEntry} for details.

@ENDNODE

@NODE BitmapInfo "Hollywood SDK"
@{b}Bitmap information@{ub}

    Hollywood supports two different kinds of bitmaps: Software bitmaps and
    hardware bitmaps. Software bitmaps, often also called device-independent
    bitmaps (DIBs), are bitmaps that are usually allocated in CPU memory.
    Hollywood will often need to read from and write to these bitmaps. That's
    why it's advised that they are stored in memory that the CPU can access
    efficiently. The downside of software bitmaps is that it is quite slow to
    draw them to the screen and that it's not possible to apply
    hardware-accelerated transformations like scaling, rotating, blending, etc.
    to them. This is only possible with hardware bitmaps.

    Hardware bitmaps, on the other hand, are usually stored in GPU memory. They
    are often also called video or device-dependent bitmaps (DDBs). Hardware
    bitmaps are optimized for efficient blitting to the display and for
    hardware-accelerated transformations. Hollywood will never modify the pixels
    of hardware bitmaps using the CPU because this would be too slow. Instead,
    hardware bitmaps are uploaded to GPU memory once and then only the GPU is
    used to access hardware bitmaps. Only the Amiga versions of Hollywood have
    inbuilt support for hardware bitmaps. On all other systems hardware bitmap
    support is not available in Hollywood but can be provided by third party
    plugins by installing a display adapter using @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} and
    setting the "HWSDAFLAGS_VIDEOBITMAPADAPTER" flag.

    Software bitmaps always store the color and transparency channels in
    separate bitmaps. This is because Hollywood is still compatible with 15-bit
    and 16-bit screen modes which do not have enough room for an 8-bit alpha
    channel that carries transparency information. Thus, software bitmaps, even
    if they use 32-bits per pixel, will never contain alpha channel information
    in their most significant bits. This is always stored in a separate bitmap.
    Plugins which want to override Hollywood's inbuilt software bitmap handler
    by setting the "HWSDAFLAGS_BITMAPADAPTER" flag need to adhere to this design
    as well and allocate color and transparency channels separately. See
    @{"AllocBitMap" LINK AllocBitMap} for details.

    Hardware bitmaps, on the other hand, can store color and transparency
    channels in any way they like because Hollywood will never access the pixels
    of hardware bitmaps directly. The way a plugin allocates hardware bitmaps is
    completely up to the plugin. A limitation of hardware bitmaps is that they
    can only be drawn when Hollywood is in hardware double-buffer mode. Thus, if
    you want to write a plugin which offers support for hardware bitmaps, you
    also have to set the "HWSDAFLAGS_DOUBLEBUFFERADAPTER" flag along with
    "HWSDAFLAGS_VIDEOBITMAPADAPTER" or your hardware bitmap support won't be of
    much use.

    If you want to replace Hollywood's inbuilt bitmap handler with your custom
    versions, you have to write a display adapter plugin. See @{"Display adapter" LINK DisplayAdapterOverview}
    @{"plugins" LINK DisplayAdapterOverview} for details.

@ENDNODE

@NODE PixelFormats "Hollywood SDK"
@{b}Pixel formats@{ub}

    Hollywood software bitmaps can currently use the following pixel formats:

    HWOS_PIXFMT_RGB15:
              Two bytes per pixel. Colors are stored as 0rrrrrgg gggbbbbb.

    HWOS_PIXFMT_BGR15:
              Two bytes per pixel. Colors are stored as 0bbbbbgg gggrrrrr.

    HWOS_PIXFMT_RGB15PC:
              Two bytes per pixel. Colors are stored as gggbbbbb 0rrrrrgg.

    HWOS_PIXFMT_BGR15PC:
              Two bytes per pixel. Colors are stored as gggrrrrr 0bbbbbgg.

    HWOS_PIXFMT_RGB16:
              Two bytes per pixel. Colors are stored as rrrrrggg gggbbbbb.

    HWOS_PIXFMT_BGR16:
              Two bytes per pixel. Colors are stored as bbbbbggg gggrrrrr.

    HWOS_PIXFMT_RGB16PC:
              Two bytes per pixel. Colors are stored as gggbbbbb rrrrrggg.

    HWOS_PIXFMT_BGR16PC:
              Two bytes per pixel. Colors are stored as gggrrrrr bbbbbggg.

    HWOS_PIXFMT_RGB24:
              Three bytes per pixel. Colors are stored as rrrrrrrr gggggggg
              bbbbbbbb.

    HWOS_PIXFMT_BGR24:
              Three bytes per pixel. Colors are stored as bbbbbbbb gggggggg
              rrrrrrrr.

    HWOS_PIXFMT_ARGB32:
              Four bytes per pixel. Colors are stored as aaaaaaaa rrrrrrrr
              gggggggg bbbbbbbb.

    HWOS_PIXFMT_BGRA32:
              Four bytes per pixel. Colors are stored as bbbbbbbb gggggggg
              rrrrrrrr aaaaaaaa.

    HWOS_PIXFMT_RGBA32:
              Four bytes per pixel. Colors are stored as rrrrrrrr gggggggg
              bbbbbbbb aaaaaaaa.

    HWOS_PIXFMT_ABGR32:
              Four bytes per pixel. Colors are stored as aaaaaaaa bbbbbbbb
              gggggggg rrrrrrrr.

    HWOS_PIXFMT_CLUT:
              One byte per pixel for all CLUT bit depths.

    HWOS_PIXFMT_ALPHA8:
              One byte per pixel. Stored as aaaaaaaa.

    HWOS_PIXFMT_MONO1:
              One bit per pixel (visible and invisible).

    Please note that although many pixel formats support the storage of alpha
    channel information next to the color channel information, Hollywood's
    software bitmaps always store alpha channel information in separate bitmaps
    for compatibility with 15-bit and 16-bit screen modes. See @{"Bitmap" LINK BitmapInfo}
    @{"information" LINK BitmapInfo} for details.

    Keep in mind that for 16-bit and 32-bit pixel formats the actual byte
    storage order is dependent on the endianness of the host system. The
    constants defined above always specify the byte order when reading words or
    longwords from memory. Thus, in case a little endian system is used, the
    actual byte order in memory will be inverted for all 16-bit and 32-bit pixel
    formats, i.e. if you access a bitmap that uses "HWOS_PIXFMT_ARGB32" as its
    pixel format on a little endian system, the bytes will actually be stored in
    BGRA order in memory so that you get an ARGB pixel whenever you read a
    longword from the pixel buffer. Conversely, bitmaps that use
    "HWOS_PIXFMT_BGRA32" will store bytes as ARGB on little endian systems so
    that you get BGRA pixels when reading a longword from the pixel buffer.

@ENDNODE

@NODE LuaVSHollywood "Hollywood SDK"
@{b}Differences between Hollywood and Lua@{ub}

    If you plan to write plugins that extend Hollywood's script language by
    installing new commands and constants, you will have to deal with the Lua VM
    which is at the heart of Hollywood. Hollywood uses Lua 5.0.2 as its virtual
    machine but with major modifications. Here is a non-exhaustive list of the
    differences between Lua 5.0.2 and Hollywood:

    1. At a first glance, Hollywood in contrast to Lua does not seem to
       distinguish between lower and upper case characters for keywords,
       preprocessor commands, variable, function, and constant names. You can
       mix upper and lower case characters any way you please. Internally,
       however, Hollywood still does the distinction between upper and lower
       case in true Lua fashion. The reason why you don't notice this, is
       because Hollywood's parser converts everything to lower case when it
       parses your script so all the differences are levelled at parsing time
       already and you don't have to care about upper and lower case characters
       when writing your script. However, if you write a plugin and you push
       elements into the stack or pop them from the stack, you need to be very
       careful that you use lower case strings only when describing these
       elements. Otherwise the user won't be able to access the elements that
       you have pushed or you won't be able to access the elements the user has
       pushed because internally Hollywood still distinguishes between upper and
       lower case characters. This must be kept in mind when writing plugins
       that push/pop stack elements. Always use lower case characters for
       everything and your plugin will fit in just fine.

    2. The handling of Nil is different between Hollywood and Lua. Comparing 0
       against Nil will be TRUE in Hollywood, but FALSE in Lua. This change has
       been made to allow you to work with uninitialiazed variables. If you pass
       an uninitialized, i.e. a Nil variable to a function or you use an
       uninitialized variable in an equation, Hollywood will just treat this
       uninitialized variable as if its value was 0. Lua, on the other hand,
       will fail if you try do arithmetics with Nil variables or pass a Nil
       variable to a function which expects a numerical value. Hollywood will
       just assume a numerical value of 0 for all uninitialized variables. The
       only exception from this rule is with table elements. Hollywood will fail
       if you try to index table elements that are Nil. It will not
       automatically assume 0 for them. That is why you have to explicitly
       initialize all table elements you want to use. Variables, on the other
       hand, don't have to be initialized explicitly. You can just use them and
       if they are still Nil, Hollywood will assume they are 0.

    3. Hollywood does not support the boolean object type. In Hollywood, the
       values TRUE and FALSE are simply special constants that will be mapped to
       the numerical values 1 and 0 respectively. There is no special object
       type for boolean values. This means that comparing 0 against FALSE will
       be TRUE in Hollywood, whereas in Lua it would be FALSE because you would
       be comparing two different object types. Internally, Lua's boolean API is
       still supported by the VM and your plugin could use the respective
       functions from @{"LuaBase" LINK LuaBaseOverview} but this is not recommended since Hollywood itself
       will never use Lua's boolean object type. It will always just use
       numbers. Not to mention that it is impossible to pass a real Lua boolean
       value to one of your plugin's functions because the parser will map all
       the TRUE and FALSE keywords to plain numbers.

    4. The syntax is different. Whereas Lua uses the "end" keyword to close all
       kinds of different scopes, Hollywood has scope-dependent closing keywords
       like "Wend", "Next", "EndIf" and so on to make script files better
       readable.

    5. The operators are different. For example, Lua uses ~= for the not equal
       operator whereas Hollywood uses <>. Hollywood also supports much more
       operators than Lua does. For example, Hollywood comes with a variety of
       bitwise operators that Lua is missing entirely.

    6. Lua uses 1-based tables and arrays whereas in Hollywood they are 0-based
       as in almost every other programming language. Though 1-based arrays
       might make more sense from a strictly logical point of view, 0-based
       arrays are the de facto standard in the programming world.

    7. Hollywood's preprocessor has support for preprocessor commands, e.g.
       "\@BRUSH" or "\@INCLUDE". Preprocessor commands are prefixed by the at
       character (\@).

    8. Hollywood supports constants. Constants are always prefixed by the hash
       tag (#).

    9. Hollywood supports additional program flow statements like Repeat/Until
       and Switch/EndSwitch.

    10. Hollywood still supports labels and "Goto()" and "Gosub()", although this
       is considered obsolete and is only included for compatibility with
       Hollywood 1.x.

    11. Hollywood has a "continue" statement.

    12. Hollywood introduces a new data type named "lua_ID" and the functions
       @{"luaL_checkid()" LINK luaL_checkid} and @{"luaL_checknewid()" LINK luaL_checknewid} to deal with its object identifiers.
       See @{"Object identifiers" LINK LuaID} for details.

    13. There is a difference in the error handling when writing C functions that
       are callable from Lua. If an error occurs in a C function with Lua 5.0.2,
       your C function has to call the "luaL_error()" function which will
       directly jump to Lua's error handler. In Hollywood, however, you have to
       return an error code from your C function to indicate that an error has
       occurred. If that is not possible for some reason, you may also call
       @{"lua_throwerror()" LINK lua_throwerror} to jump directly into Hollywood's error handler but the
       recommended way is returning an error code. The reason for this design is
       that working with error codes is preferable to doing a "longjmp()"
       because it gives your code a chance to free resources before it
       error-exits. Note that Lua functions like "luaL_checklstring()" and
       "luaL_checknumber()" will still jump into the error handler directly, so
       be prepared to deal with this.

    See @{"Library plugins" LINK LibraryOverview} for details.

    See @{"LuaBase" LINK LuaBaseOverview} for details.

@ENDNODE

@NODE LuaID "Hollywood SDK"
@{b}Object identifiers@{ub}

    All Hollywood objects like brushes, videos, samples, etc. have an object
    identifier that is used to refer to the object when calling a function that
    deals with this object type. Hollywood objects can use two different kinds
    of identifiers: They can either use a numerical identifier or an
    automatically chosen identifier that uses the "LUA_TLIGHTUSERDATA" object
    type internally. The user can request an automatically chosen identifier by
    passing "Nil" as the desired identifier when creating the object. In that
    case, Hollywood will automatically choose an identifier for the object and
    return it. This is usually done by using the raw memory pointer to the newly
    allocated object as an identifier because this guarantees its uniqueness.

    Internally, Hollywood object identifiers are managed using the "lua_ID"
    structure which looks like this:

        typedef struct _lua_ID
        {
            int num;
            void *ptr;
        } lua_ID;

    Every Hollywood object has such a "lua_ID" associated with it. The two
    structure members are initialized like this:

    num:      If the object uses a numerical identifier, this identifier is
              stored in "num" and the "ptr" member is set to NULL. If the "ptr"
              member is not NULL, Hollywood will ignore whatever is in "num" and
              the object will automatically use the value in "ptr" as its
              identifier.

    ptr:      If the object has been created using automatic ID selection, this
              member contains the object's unique identifier of type
              "LUA_TLIGHTUSERDATA". This is typically set to the raw memory
              pointer of the newly allocated object. If "ptr" is NULL, Hollywood
              will automatically use the numerical identifier specified in
              "num".

    Whenever you call an API function that expects an object identifier you need
    to pass a pointer to a "lua_ID" to it. For example, let's assume you want to
    use @{"hw_LockBrush()" LINK hw_LockBrush} to access the raw pixel data of brush 1. In that case,
    you'd have to call @{"hw_LockBrush()" LINK hw_LockBrush} like this:

        lua_ID id = {1, NULL};
        struct hwos_LockBrushStruct lb;
        APTR handle;

        handle = hw_LockBrush(&id, NULL, &lb);
        if(handle) hw_UnLockBrush(handle);

    If you are writing a plugin that has the "HWPLUG_CAPS_LIBRARY" capability
    flag set and you want to offer a function that accepts either a numerical or
    an automatically chosen object identifier, you can use the @{"luaL_checkid()" LINK luaL_checkid}
    function for that. @{"luaL_checkid()" LINK luaL_checkid} will check whether the value at the
    specified stack position is a number or a light userdata value and then it
    will initialize the "lua_ID" structure accordingly. The function from above
    would look like this then:

        static SAVEDS int plug_LockBrush(lua_State *L)
        {
            lua_ID id;
            struct hwos_LockBrushStruct lb;
            APTR handle;

            luaL_checkid(L, 1, &id);

            handle = hw_LockBrush(&id, NULL, &lb);
            if(handle) hw_UnLockBrush(handle);
        }

    By using @{"luaL_checkid()" LINK luaL_checkid} your function can be made to accept numerical as
    well as light user data identifiers without much hassle.

    You can also register your own Hollywood object types by calling the
    @{"hw_RegisterUserObject()" LINK hw_RegisterUserObject} function. See @{"hw_RegisterUserObject" LINK hw_RegisterUserObject} for details.

@ENDNODE

@NODE UserTags "Hollywood SDK"
@{b}User tags@{ub}

    User tags are a way of passing additional information from Hollywood scripts
    to plugins. They can be used to pass an unlimited amount of additional data
    to plugins directly from the Hollywood script. For example, let's suppose
    there's a plugin that can load PDF pages as images. Such a plugin would need
    two additional pieces of information to do its job, namely the page to load
    and optionally a password in case the PDF is password-protected. Both pieces
    of information could be passed to the plugin using user tags.

    From the Hollywood script's point of view, user tags are simply passed in an
    optional "UserTags" table accepted by many Hollywood functions, e.g.
    "LoadBrush()". To pass the optional page and password arguments to an image
    plugin, a Hollywood script could do the following:

        LoadBrush(1, "test.pdf", {UserTags = {Page = 5, Password = "secret"}})

    All tags that the script passes in the "UserTags" table that is accepted by
    all commands that support plugins are then forwarded to plugins in a struct
    hwUserTagList linked list. For image plugins, the pointer to the first
    struct hwUserTagList node is passed to your @{"LoadImage()" LINK LoadImage} implementation in
    the struct LoadImageCtrl argument. Your @{"LoadImage()" LINK LoadImage} implementation can then
    examine all user tags that are in the list by iterating through the
    individual list nodes. struct hwUserTagList looks like this:

        struct hwUserTagList
        {
            struct hwUserTagList *Succ;
            STRPTR Name;
            STRPTR Str;
            double Val;
            int Length;
        };

    Here is a description of the structure members:

    Succ:     Contains a pointer to the next node in the list or NULL for the
              tail node.

    Name:     Name of the user tag.

    Str:      If the user has set the tag to a string value, it is passed here.
              If this is NULL, then you have to examine the "Val" member below.

    Val:      If the user has set the tag to a numerical value, it is passed in
              this structure member.

    Length:   If the user has set the tag to a string value, this structure
              member contains the string length in bytes (not including the
              terminating 0). This structure member is useful when passing
              binary data through user tags. In that case there can be null
              characters in the string so the only way to find out the length of
              the data in "Str" is via this member.

    Note that even if your plugin doesn't support any user tags, you should
    still look for the user tag list and pass it on to functions like
    @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed to your plugin could also be
    intended for another plugin like the file adapter plugin that is used to
    handle the actual file I/O. That's why it is important that plugins always
    forward the user tags list to all functions that support user tags.

@ENDNODE

@NODE DesignerCompatibility "Hollywood SDK"
@{b}Designer compatibility@{ub}

    Hollywood Designer, the WYSIWYG editor for Hollywood scripts, also supports
    Hollywood plugins. However, it supports only a fraction of Hollywood's
    plugin API. Thus, you need to be very careful when calling plugin API
    functions because they might not be available when Hollywood Designer has
    opened your plugin.

    The first version of Hollywood Designer that supports Hollywood plugins is
    version 4.0. Hollywood Designer supports the following plugin types:

    HWPLUG_CAPS_IMAGE
              Plugin provides a loader for additional image formats. See @{"Image" LINK ImageOverview}
              @{"plugins" LINK ImageOverview} for details.

    HWPLUG_CAPS_ANIM
              Plugin provides a loader for additional animation formats. See
              @{"Animation plugins" LINK AnimOverview} for details.

    HWPLUG_CAPS_VIDEO
              Plugin provides a loader for additional video formats. See @{"Video" LINK VideoOverview}
              @{"plugins" LINK VideoOverview} for details.

    HWPLUG_CAPS_SAVEIMAGE
              Plugin provides a saver for additional image formats. See @{"Image" LINK ImageSaverOverview}
              @{"saver plugins" LINK ImageSaverOverview} for details.

    All the other plugin types are currently unsupported. Thus, you don't have
    to be careful about which plugin API functions you call if your plugin is of
    a type that Designer doesn't support anyway. Be careful about the
    @{"InitPlugin()" LINK InitPlugin} and @{"ClosePlugin()" LINK ClosePlugin} functions, though. These will be called for
    all plugins so you must be very careful about the plugin API functions you
    call from these functions.

    Let's suppose you are going to write a plugin that adds an image loader and
    a file adapter. In that case you would set hwPluginBase.CapsMask to
    HWPLUG_CAPS_IMAGE|HWPLUG_CAPS_FILEADAPTER. File adapters usually call
    @{"hw_ConfigureLoaderAdapter()" LINK hw_ConfigureLoaderAdapter} from their @{"InitPlugin()" LINK InitPlugin} implementation.
    @{"hw_ConfigureLoaderAdapter()" LINK hw_ConfigureLoaderAdapter}, however, is not supported by Designer because
    Designer doesn't support file adapters. That's why you have to check if
    Hollywood or Hollywood Designer has opened your plugin before you call
    @{"hw_ConfigureLoaderAdapter()" LINK hw_ConfigureLoaderAdapter}. You can check for Hollywood Designer by
    looking at the first function of "LuaBase" and see if it is NULL. If it is,
    you can be sure that you are being called by Hollywood Designer. Your
    implementation of @{"InitPlugin()" LINK InitPlugin} could then look like this:

        HW_EXPORT int InitPlugin(hwPluginBase *self, hwPluginAPI *cl, STRPTR p)
        {
            int isdesigner = (cl && cl->LuaBase->lua_gettop == NULL);

            self->CapsMask = HWPLUG_CAPS_IMAGE|HWPLUG_CAPS_FILEADAPTER;
            self->hwVersion = 1;
            self->hwRevision = 0;
            ...

            if(cl) {
                if(!isdesigner) cl->SysBase->hw_ConfigureLoaderAdapter(...);
            }

            return TRUE;
        }

    The code above will only call @{"hw_ConfigureLoaderAdapter()" LINK hw_ConfigureLoaderAdapter} if @{"InitPlugin()" LINK InitPlugin}
    has been called by Hollywood. If you don't do this check, Hollywood Designer
    will crash on every startup because your plugin tries to jump to a function
    that is NULL. So make sure your @{"InitPlugin()" LINK InitPlugin} implementation is compatible
    with Hollywood Designer.

    To find out which plugin APIs are supported by Hollywood Designer, look at
    the "Designer compatibility" section that is part of every function's
    documentation.

    To find out which version of Hollywood Designer is calling you, you must use
    the "HWMCP_GETDESIGNERVERSION" tag with the @{"hw_MasterControl()" LINK hw_MasterControl} function. It
    is not sufficient to look at the "hwVersion" and "hwRevision" members of the
    "hwPluginBase" that is passed to your @{"InitPlugin()" LINK InitPlugin} implementation because
    these just contain the version of the Hollywood plugin API provided by the
    Designer version that is calling your plugin. For example, Designer 4.0 will
    identify itself as Hollywood 5.0 whereas Designer 5.0 will identify itself
    as Hollywood 8.0. To get the real Designer version numbers, use
    "HWMCP_GETDESIGNERVERSION". See @{"hw_MasterControl" LINK hw_MasterControl} for details.

@ENDNODE

@NODE Multithreading "Hollywood SDK"
@{b}Multithreading@{ub}

    Generally, all of Hollywood's API functions are not thread-safe and the
    plugin functions need also not be thread-safe except where stated. There are
    a few thread-safe API calls and there are also a few plugin functions that
    must be thread-safe. In that case, this requirement is explicitly mentioned
    in this documentation. If nothing is mentioned in an API call's
    documentation, then the call is not thread-safe or need not be thread-safe
    in case it is a plugin function to be written by you.

@ENDNODE

@NODE LegacyPlugins "Hollywood SDK"
@{b}Legacy plugins@{ub}

    Plugin support was introduced with Hollywood 1.5. However, Hollywood's
    plugin interface was completely redesigned for Hollywood 5.0 and isn't
    compatible to previous versions any more. Thus, all the documentation
    provided here only applies to Hollywood 5.0 and up. If you need to target
    older Hollywood versions, too, please contact me for developer information
    for older Hollywood versions.

@ENDNODE

@NODE AmigaOSGlueCode "Hollywood SDK"
@{b}Glue code@{ub}

    As AmigaOS doesn't support the export of named symbols from library files,
    Hollywood plugins need to provide some glue code on AmigaOS and compatible
    systems so that Hollywood can locate symbols by name instead of by
    jumptable.

    After calling "LoadSeg()" on your plugin, Hollywood will look for two magic
    cookies that must be embedded in the "MagicCookie[]" array in the following
    structure:

        typedef struct _hwAmigaEntry
        {
            ULONG MagicCookie[2];
            int Platform;
            void *(*GetProcAddress)(STRPTR name);
        } hwAmigaEntry;

    Thus, your plugin needs to declare a global constant based on this structure
    so that Hollywood can identify the file as a Hollywood plugin. An example
    declaration could be like this:

        const hwAmigaEntry entry = {
            {HWPLUG_COOKIE1, HWPLUG_COOKIE2},
            HWARCH_OS3,
            GetProcAddress,
        };

    Make sure that the compiler doesn't optimize this declaration away just
    because it isn't referenced anywhere. Otherwise Hollywood won't be able to
    load your plugin. As you can see "MagicCookie[]" needs to be set to
    "HWPLUG_COOKIE1" and "HWPLUG_COOKIE2" which are both defined in
    hollywood/plugin.h. Note that different cookies are used on little endian
    systems so make sure to define the preprocessor constant "HW_LITTLE_ENDIAN"
    if you target little endian systems.

    It is very important to set hwAmigaEntry.Platform to the correct
    architecture constant. In the above example we set it to "HWARCH_OS3"
    indicating that this is a plugin for AmigaOS 3.

    You can also see that the declaration above references a function named
    "GetProcAddress()". You need to implement this function in your glue code as
    well. Hollywood calls this function whenever it needs to resolve a function
    pointer from a symbol name. Thus, your implementation of "GetProcAddress()"
    needs to look at the string argument it has received and then return the
    appropriate function pointer. This can be implemented using a lookup table
    like this:

        static const struct
        {
            STRPTR name;
            void *func;
        } funcs[] =
        {
            {"InitPlugin", (void *) InitPlugin},
            {"ClosePlugin", (void *) ClosePlugin},
            // ...more function pointers here, depending on plugin type
            {NULL, NULL}
        };

        HW_EXPORT void *GetProcAddress(STRPTR name)
        {
            int k;

            for(k = 0; funcs[k].name; k++) {
                if(!strcmp(name, funcs[k].name)) return funcs[k].func;
            }

            return NULL;
        }

    Another speciality on AmigaOS is that you cannot use certain functions from
    the standard ANSI C runtime library. See @{"AmigaOS C runtime limitations" LINK AmigaOSCRT} for
    details.

@ENDNODE

@NODE AmigaOSCRT "Hollywood SDK"
@{b}C runtime limitations@{ub}

    As Hollywood plugins on AmigaOS are loaded using "LoadSeg()" they do not
    contain the C compiler's runtime library startup code and there is no
    standardized way of executing the constructor and destructor functions of
    your C compiler's runtime library from a Hollywood plugin. This means that
    you won't be able to use any functions from the ANSI C runtime that require
    the compiler constructor or destructor code. Instead, you either have to
    call into AmigaOS API functions directly or you can use the C runtime
    functions that Hollywood makes available to your plugin in "CRTBase" that is
    passed to your @{"InitPlugin()" LINK InitPlugin} function.

    Here is a list of functions that typically require the constructor and
    destructor code of your C compiler and therefore cannot be used from
    Hollywood plugins. Depending on your compiler, there may be more functions
    which cannot be used:

    Memory allocation functions
              Functions like malloc(), calloc(), realloc(), free(), strdup()...

    File IO functions
              All functions that deal with file handles like fopen(), fclose(),
              fread(), fwrite(), fgetc()...

    Standard IO functions
              Functions like printf(), sprintf(), scanf(), sscanf()...

    Date and time functions
              Functions like time(), localtime(), mktime(), gettimeofday()...

    Locale dependent functions
              Functions like toupper(), tolower(), isgraph()...

    Please note that it is usually not possible to write Hollywood plugins in
    C++ on AmigaOS because C++ most of the time also needs custom compiler
    constructor and destructor code.

    You also must not use any library auto-open features provided by the
    compiler. You need to manually open and close all Amiga libraries that your
    plugins requires.

    Very experienced users might be able to work around all these limitations by
    finding a way to run the compiler's constructor and destructor code manually
    from the @{"InitPlugin()" LINK InitPlugin} and @{"ClosePlugin()" LINK ClosePlugin} functions but this requires quite
    some effort and is different from compiler to compiler.

@ENDNODE

@NODE AmigaOSclib2 "Hollywood SDK"
@{b}clib2 versus newlib@{ub}

    Developers targetting the AmigaOS 4 platform can choose between two
    different C runtime libraries: clib2 and newlib. clib2 is linked statically
    into the binary whereas newlib is available as a shared library. Since
    Hollywood uses clib2 it is recommended that you use clib2 for your plugins
    as well. This can be achieved by compiling your sources with the following
    compiler setting:

        gcc -mcrt=clib2 ...

    Please note that clib2 is not thread-safe by default. Thus, if you need a
    thread-safe C runtime you need to link against clib2-ts instead, i.e.

        gcc -mcrt=clib2-ts ...

    If you want to use newlib for your plugins, you need to be very careful not
    to mix clib2 and newlib structures and handles. For example, all handles
    (e.g. an stdio "FILE" handle) allocated by Hollywood will be clib2 handles
    since Hollywood uses clib2. Thus, you must not pass them to a newlib stdio
    function since the internal representation of these handles might differ.
    Also, you must be careful when using structures that are shared between the
    C runtime provided by Hollywood and your plugin. Hollywood's C runtime will
    use the structures as defined in the clib2 headers whereas your plugin will
    use the format defined the newlib headers.

    Finally, you also have to open newlib.library on your own if you want to use
    newlib in your plugin.

@ENDNODE

@NODE AmigaOSSaveDS "Hollywood SDK"
@{b}__saveds keyword@{ub}

    If you compile plugins for the Motorola 680x0 processors or for WarpOS you
    have to make sure that all your functions that will be called by Hollywood
    are declared using the "__saveds" keyword or your compiler's equivalent of
    this keyword (some compilers use a function called "geta4()" or a "__geta4"
    keyword instead). This is to make sure that the compiler generates code that
    loads the near data pointer in register "a4" on each function entry so that
    your function is able to access its data. If you don't use "__saveds" in
    your functions that can be called from Hollywood, then the index register
    will still point to to the data section within Hollywood and not within your
    plugin which will lead to all sorts of trouble.

    Note that you need not use "__saveds" for all your functions but only the
    ones that Hollywood will directly call into. This includes the functions
    your plugin exports, the Lua functions offered by your plugin as well as
    callback functions within your plugin whose pointers you pass to Hollywood
    functions.

    When declaring your plugin functions, the "HW_EXPORT" macro will
    automatically set "__saveds" for you, e.g.

        HW_EXPORT int InitPlugin(hwPluginBase *self, hwPluginAPI *cl, STRPTR p)
        {
            ...
        }

    However, you will also need to use "__saveds" when defining the Lua
    functions for your "HWPLUG_CAPS_LIBRARY" plugin, e.g.

        static SAVEDS int MyDiv(lua_State *L)
        {
            double a = luaL_checknumber(L, 1);
            double b = luaL_checknumber(L, 2);

            // catch division by zero CPU exception and handle
            // it cleanly
            if(b == 0) return ERR_ZERODIVISION;

            lua_pushnumber(L, a / b);

            // push 1 to indicate one return value
            return 1;
        }

        static const struct hwCmdStruct plug_commands[] = {
            {"MyDiv", MyDiv},
            ...
            {NULL, NULL}
        };

    Here we use the macro "SAVEDS" which will only insert the "__saveds" keyword
    when building for 680x0 or WarpOS-based systems.

    Finally, don't forget to set "__saveds" when writing callback functions that
    you pass to a Hollywood API call. These must also be declared with the
    "__saveds" keyword because, obviously, Hollywood calls into them, e.g.

        static SAVEDS int dispatcher(APTR h, int op, APTR data, APTR udata)
        {
            ...
        }

        handle = hw_AttachDisplaySatellite(&id, dispatcher, data, tags);

    Make sure that you don't forget the "__saveds" keyword for all these
    functions! Trying to debug a crash that is caused by a missing "__saveds"
    declaration can be a really frustrating experience because very strange
    things will start to happen if the data index register hasn't been set up
    correctly.

@ENDNODE

@NODE AmigaOSFPU "Hollywood SDK"
@{b}Building for 68881 and 68882@{ub}

    Some extra care needs to be taken when compiling plugins for the 68881 and
    68882 FPUs. Hollywood's plugin interface was designed to allow plugins
    compiled for 68881/2 to be used with the non-FPU version of Hollywood as
    well. This means that return values from plugins compiled for 68881/2 must
    never be stored in FPU registers like "fp0". Instead, return values must
    always be returned in CPU registers. If a 64-bit value is to be returned
    from a plugin that has been compiled for 68881/2, it must be returned in
    registers "d0" and "d1", not in "fp0". Even the FPU version of Hollywood
    will expect floating point return values in CPU registers. Hollywood will
    never look for them in FPU registers! This design makes it possible to use
    FPU-compiled plugins with the non-FPU version of Hollywood and also vice
    versa.

    Most compilers, however, will use FPU registers for floating point return
    values by default. If you're using vbcc, you can change this behaviour by
    compiling your source codes using the -no-fp-return command line argument.
    If this is specified, vbcc will always use CPU registers for return values.
    If you compile your sources with -no-fp-return enabled, however, you'll soon
    run into another problem, namely that all the ANSI C runtime library
    functions which return floating point values will return them in "fp0". This
    will cause conflicts because the compiler expects them in "d0" and "d1" now.
    To solve this problem, you will have to link your project against runtime
    libraries which also have been compiled using -no-fp-return. At the time of
    this writing, the standard vbcc distribution does not come with these
    special libraries, but they're available on request from Frank Wille, who is
    the maintainer of the Amiga vbcc distribution.

@ENDNODE

@NODE AmigaOSWarpOS "Hollywood SDK"
@{b}Building for WarpOS@{ub}

    If you build plugins for WarpOS, the "hwPluginAPI" pointer that is passed to
    your @{"InitPlugin()" LINK InitPlugin} will contain function pointers to PPC code. However, many
    of these function pointers will immediately do a context switch and run on
    the 68k context. You might already be aware of the fact that context
    switches are quite expensive so you should do your best to minimize the
    number of context switches your plugin has to perform. To achieve this, you
    need to know which of the functions in the "hwPluginAPI" base pointer run
    PPC-native and which of them need a context switch. So here's an overview on
    the functions that don't need a context switch. All other functions not
    listed here will immediately perform a context switch.

    CRTBase:  The following functions are available in PPC native versions:
              "malloc()", "calloc()", "realloc()", "free()", "strdup()",
              "qsort()", "stricmp()", "strnicmp()", "toupper()", "tolower()",
              "strtolower()", "strtoupper()", "gettimeofday()", "time()",
              "lrint()", "strtol()", "strtoul()", "strtod()", "vsscanf()",
              "vsnprintf()", "atol()", "dtostr()".

    SysBase:  The following functions are available in PPC native versions:
              "hw_GetSysTime()", "hw_SubTime()", "hw_AddTime()", "hw_CmpTime()",
              "hw_Delay()", "hw_MasterControl()" (but this function is only
              PPC-native when querying the "HWMCP_GETPOWERPCBASE" tag to make
              Hollywood return its "PowerPCBase" pointer to you),
              "hw_TrackedAlloc()", "hw_TrackedFree()", "hw_AllocSemaphore()",
              "hw_FreeSemaphore()", "hw_LockSemaphore()",
              "hw_UnLockSemaphore()".

    DOSBase:  All functions here are implemented in 68k code and will
              immediately do a context switch.

    GfxBase:  All functions here are implemented in 68k code and will
              immediately do a context switch.

    AudioBase:
              All functions here are implemented in 68k code and will
              immediately do a context switch.

    RequesterBase:
              All functions here are implemented in 68k code and will
              immediately do a context switch.

    FontBase: All functions here are implemented in 68k code and will
              immediately do a context switch.

    FT2Base:  All functions here are PPC-native and don't need a context switch.
              Note that the PPC-native "FT2Base" for WarpOS is not available
              before Hollywood 5.3. You need to make sure that your plugin was
              opened by Hollywood 5.3 at least before trying to make any calls
              in "FT2Base".

    LuaBase:  All functions here are implemented in 68k code and will
              immediately do a context switch.

    ZBase:    All functions here are PPC-native and don't need a context switch.

    JPEGBase: All functions here are PPC-native and don't need a context switch.

    PluginBase:
              All functions here are implemented in 68k code and will
              immediately do a context switch.

    UtilityBase:
              The following functions are available in PPC native versions:
              "hw_CRC32()", "hw_DecodeBase64()", "hw_EncodeBase64()", and
              "hw_MD5()". The other functions are implemented in 68k code and
              will do a context switch.

    UnicodeBase:
              All functions here are PPC-native and don't need a context switch.

    LocaleBase:
              All functions here are implemented in 68k code and will
              immediately do a context switch.

    Also, be careful about structure alignment when developing for WarpOS. The
    WarpOS version of Hollywood doesn't use the traditional Amiga structure
    alignment of 2 bytes but is optimized for performance. This means, for
    example, that 64-bit double values will always be aligned on an 8 byte
    boundary.

@ENDNODE

@NODE AnimOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_ANIM" set will be called
    whenever Hollywood has to load an animation. The plugin can check then
    whether the animation file is in a format that the plugin recognizes and if
    it is, it can open the animation and return the raw pixel data of the
    individual frames to Hollywood. This makes it possible to load custom
    animation formats with Hollywood.

    By default, anim plugins are automatically activated when Hollywood loads
    them. Starting with Hollywood 6.0 this behaviour can be changed by setting
    the "HWEXT_ANIM_NOAUTOINIT" extension bit. If this bit is set, Hollywood
    will not automatically activate your plugin at load time. Instead, you will
    have to manually call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to activate your plugin. For
    example, you could call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} from your @{"RequirePlugin()" LINK RequirePlugin}
    implementation. In that case, the anim plugin would only be activated if the
    user called "\@REQUIRE" on it. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on a
    plugin that has auto-initialization disabled, it will only be available if
    the user addresses it directly through the "Loader" tag. See @{"Extension" LINK ExtensionOverview}
    @{"plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    Note that anim plugins need not implement all functions offered by the anim
    plugin API. Some functions are optional and need only be implemented in
    specific cases. Here's a list of optional functions:

    GetFrame()
              Only used if you set the "HWEXT_ANIM_VECTOR" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    TransformFrame()
              Only used if you set the "HWEXT_ANIM_VECTOR" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    FreeVectorFrame()
              Only used if you set the "HWEXT_ANIM_VECTOR" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    GetAnimFormat()
              Only used if you set the "HWEXT_ANIM_FORMAT" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    @{"CloseAnim()                       " LINK CloseAnim} Close animation handle
    @{"FreeFrame()                       " LINK FreeFrame} Free frame pixel data
    @{"FreeVectorFrame()                 " LINK FreeVectorFrame} Free vector frame
    @{"GetAnimFormat()                   " LINK GetAnimFormat} Get anim format name
    @{"GetFrame()                        " LINK GetFrame} Get raw frame pixel data
    @{"GetFrameDelay()                   " LINK GetFrameDelay} Get frame presentation time stamp
    @{"LoadFrame()                       " LINK LoadFrame} Load raw pixel data of a single frame
    @{"OpenAnim()                        " LINK OpenAnim} Open an animation file
    @{"TransformFrame()                  " LINK TransformFrame} Transform vector frame
@ENDNODE

@NODE CloseAnim "Hollywood SDK"

   @{b}NAME@{ub}
        CloseAnim -- close animation handle (V5.0)

   @{b}SYNOPSIS@{ub}
        void CloseAnim(APTR handle);

   @{b}FUNCTION@{ub}
        This function must close the specified animation handle that has been
        allocated by your plugin's @{"OpenAnim()" LINK OpenAnim} function. Hollywood will call
        CloseAnim() when it is done with your animation.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"OpenAnim()" LINK OpenAnim}

@ENDNODE

@NODE FreeFrame "Hollywood SDK"

   @{b}NAME@{ub}
        FreeFrame -- free frame pixel data (V5.0)

   @{b}SYNOPSIS@{ub}
        void FreeFrame(ULONG *raw);

   @{b}FUNCTION@{ub}
        This function must free the raw pixel data returned by @{"LoadFrame()" LINK LoadFrame}.

        Note that FreeFrame() is only called for raster anims. For vector anims,
        Hollywood will call @{"FreeVectorFrame()" LINK FreeVectorFrame} to free a frame allocated by
        @{"LoadFrame()" LINK LoadFrame}.

   @{b}RESULTS@{ub}
        raw       frame buffer allocated by @{"LoadFrame()" LINK LoadFrame}

@ENDNODE

@NODE FreeVectorFrame "Hollywood SDK"

   @{b}NAME@{ub}
        FreeVectorFrame -- free vector frame (V9.0)

   @{b}SYNOPSIS@{ub}
        void FreeVectorFrame(APTR handle);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_ANIM_VECTOR" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, FreeVectorFrame() must free the frame
        handle allocated by @{"LoadFrame()" LINK LoadFrame}.

        Note that FreeVectorFrame() is only called for vector anims. For raster
        anims, Hollywood will call @{"FreeFrame()" LINK FreeFrame} to free a frame allocated by
        @{"LoadFrame()" LINK LoadFrame}.

   @{b}RESULTS@{ub}
        handle    frame handle as returned by @{"LoadFrame()" LINK LoadFrame}

@ENDNODE

@NODE GetAnimFormat "Hollywood SDK"

   @{b}NAME@{ub}
        GetAnimFormat -- get anim format name (V10.0)

   @{b}SYNOPSIS@{ub}
        STRPTR name = GetAnimFormat(APTR handle);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_ANIM_FORMAT" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, this function must return the format
        name of the anim file handle passed in "handle". The string returned by
        this function can be retrieved from Hollywood scripts by querying the
        #ATTRFORMAT attribute on #ANIM objects. The string you return must be
        valid until @{"CloseAnim()" LINK CloseAnim} is called on the anim handle passed to this
        function.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"OpenAnim()" LINK OpenAnim}

   @{b}RESULTS@{ub}
        name      anim format name

@ENDNODE

@NODE GetFrame "Hollywood SDK"

   @{b}NAME@{ub}
        GetFrame -- get raw pixel frame data (V9.0)

   @{b}SYNOPSIS@{ub}
        ULONG *raw = GetFrame(APTR handle, struct LoadAnimCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_ANIM_VECTOR" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, this function must return the frame's
        raw pixel data and some information about it. The pixel data needs to be
        returned as an array of 32-bit ARGB values. and GetFrame() also needs to
        take possible transformations that have been applied via
        @{"TransformFrame()" LINK TransformFrame} into account.

        Note that GetFrame() is only called for vector anims. For raster anims,
        Hollywood will obtain the pixel data from @{"LoadFrame()" LINK LoadFrame}.

        Furthermore, GetFrame() has to provide some additional information in
        the struct LoadAnimCtrl pointer that is passed as the second parameter.
        See @{"OpenAnim" LINK OpenAnim} for details on this structure. The following information
        has to be provided by GetFrame():

        Width:    Must be set to the frame width in pixels. If @{"TransformFrame()" LINK TransformFrame}
                  has been called prior to GetFrame(), this value must exactly
                  match the width that has been passed to the last call of
                  @{"TransformFrame()" LINK TransformFrame}.

        Height:   Must be set to the frame height in pixels. If @{"TransformFrame()" LINK TransformFrame}
                  has been called prior to GetFrame(), this value must exactly
                  match the height that has been passed to the last call of
                  @{"TransformFrame()" LINK TransformFrame}.

        LineWidth:
                  Must be set to the frame modulo width in pixels. This is often
                  the same as the frame width.

        AlphaChannel:
                  Must be set to TRUE or FALSE, depending on whether or not this
                  frame has an alpha channel.

        The pointer that is returned by GetFrame() must stay valid at least
        until the next call to GetFrame() or @{"FreeVectorFrame()" LINK FreeVectorFrame} on this handle.

   @{b}INPUTS@{ub}
        handle    frame handle as returned by @{"LoadFrame()" LINK LoadFrame}
        ctrl      pointer to a struct LoadAnimCtrl for storing information about
                  the frame

   @{b}RESULTS@{ub}
        raw       an array of raw pixel data

@ENDNODE

@NODE GetFrameDelay "Hollywood SDK"

   @{b}NAME@{ub}
        GetFrameDelay -- get frame presentation time stamp (V5.0)

   @{b}SYNOPSIS@{ub}
        int delay = GetFrameDelay(APTR handle, int frame);

   @{b}FUNCTION@{ub}
        This function must return the presentation time stamp of the specified
        frame. Frame indices are counted from 0 to number of frames minus 1.
        Presentation time stamp means the duration that this frame should be
        shown before skipping to the next frame. This value has to be specified
        in milliseconds. If the animation format doesn't support frame-based
        time stamps you can also return a global frame delay value here or even
        0. Returning 0 for every frame will display the animation as fast as
        possible.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"OpenAnim()" LINK OpenAnim}
        frame     index of frame to query (starts from 0)

   @{b}RESULTS@{ub}
        delay     delay in milliseconds for the specified frame

@ENDNODE

@NODE LoadFrame "Hollywood SDK"

   @{b}NAME@{ub}
        LoadFrame -- load animation frame (V5.0)

   @{b}SYNOPSIS@{ub}
        ULONG *raw = LoadFrame(APTR handle, int frame, struct LoadAnimCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function must load the specified frame and return it. Frame indices
        are counted from 0 to number of frames minus 1. Note that this function
        is expected to behave completely different for raster and vector anims.

        For raster anims, i.e. "HWANIMTYPE_RASTER", LoadFrame() must return the
        raw pixel data of the frame but note that the ULONG* return type is just
        for compatibility reasons. The actual format of the pixel data that
        LoadFrame() needs to return depends on whether the
        "HWANMFLAGS_LOADPALETTE" flag was set when @{"OpenAnim()" LINK OpenAnim} was called. If it
        was set, LoadFrame() needs to return 8-bit pen values (even if the bit
        depth of the image is less than 8-bit!). If "HWANMFLAGS_LOADPALETTE"
        wasn't set, LoadFrame() needs to return 32-bit ARGB values. The returned
        pixel array must use the exact dimensions returned by @{"OpenAnim()" LINK OpenAnim}, i.e.
        it must contain exactly width * height * bpp bytes. A line width
        different from the animation width is currently not supported.

        For vector anims, i.e. "HWANIMTYPE_VECTOR", LoadFrame() must return an
        opaque handle that only your plugin knows how to interpret. This handle
        will then be passed to @{"GetFrame()" LINK GetFrame} and @{"TransformFrame()" LINK TransformFrame} to get or
        transform the pixel data. Thus, for vector anims, LoadFrame() must never
        return any actual pixel data but just a handle that @{"GetFrame()" LINK GetFrame} and
        @{"TransformFrame()" LINK TransformFrame} can use later to get or transform the pixel data.
        Furthermore, you also don't have to write to any member of the struct
        LoadAnimCtrl passed in the "ctrl" parameter.

        Also note that for raster anims, Hollywood will call @{"FreeFrame()" LINK FreeFrame} to free
        the frame returned by LoadFrame() whereas for vector anims Hollywood
        will call @{"FreeVectorFrame()" LINK FreeVectorFrame} to free the frame returned by LoadFrame().

        In case the anim is a raster anim, this function also has to provide
        certain information about the frame it has just loaded. This information
        has to be written to the struct LoadAnimCtrl that is passed in the third
        parameter. This structure looks like this:

            struct LoadAnimCtrl
            {
                int Width;                      // [out]
                int Height;                     // [out]
                int LineWidth;                  // [out]
                int NumFrames;                  // [out]
                int AlphaChannel;               // [out]
                int ForceAlphaChannel;          // [out]
                STRPTR Adapter;                 // [in]     -- V6.0
                ULONG Flags;                    // [in]     -- V6.0
                ULONG *Palette;                 // [unused] -- V9.0
                ULONG TransPen;                 // [unused] -- V9.0
                int Depth;                      // [unused] -- V9.0
                int Type;                       // [out]    -- V9.0
                struct hwUserTagList *UserTags; // [unused] -- V10.0
            };

        In contrast to @{"OpenAnim()" LINK OpenAnim}, LoadFrame() only uses some members from the
        struct LoadAnimCtrl structure pointer. The following members are used by
        LoadFrame():

        AlphaChannel:
                  This will be set to TRUE whenever the "LoadAlpha" tag has been
                  set to TRUE.

        ForceAlphaChannel:
                  If you set this to TRUE, Hollywood will automatically create
                  an alpha channel for this frame. For example, if the user
                  calls "OpenAnim()" on your animation but does not set the
                  "LoadAlpha" tag to TRUE, the frame will still get an alpha
                  channel if you set "ForceAlphaChannel" to TRUE. Note that this
                  functionality was broken before Hollywood 6.0.

        Flags:    This member can be set to a combination of the following
                  flags:

                  HWANMFLAGS_TRANSPARENCY:
                            This flag will be set whenever the user sets the
                            "LoadTransparency" tag to TRUE. If
                            "HWANMFLAGS_LOADPALETTE" is set as well, you must
                            return the pen that is to be made transparent in the
                            "TransPen" structure member (see below). If
                            "HWANMFLAGS_LOADPALETTE" is not set, you have to
                            write the frame's transparency information to its
                            alpha channel and set the "ForceAlphaChannel" member
                            to TRUE. See above for more information. (V6.0)

                  HWANMFLAGS_LOADPALETTE:
                            This flag will be set whenever the user sets the
                            "LoadPalette" tag to TRUE. If this flag is set, your
                            implementation of LoadFrame() must return an array
                            of 8-bit pixel data and a palette in the "Palette"
                            structure member (see below). (V9.0)

                  Make sure to check for Hollywood 6.0 before trying to access
                  this member because it isn't there in previous versions.
                  (V6.0)

        Depth:    Must be set to the frame's bit depth. Set this only for raster
                  anims. (V9.0)

        Palette:  If "HWANMFLAGS_LOADPALETTE" is set in the "Flags" member and
                  the anim is a raster anim, you need to set this member to a
                  pointer to a palette, stored as a "ULONG" array of 256 RGB
                  colors. Note that the "ULONG" array must always have 256
                  entries, even if the bit depth is less than 8. Initialize
                  unused palette entries to 0. (V9.0)

        TransPen: If "HWANMFLAGS_LOADPALETTE" and "HWANMFLAGS_TRANSPARENCY" are
                  set and the frame has a transparent pen and the anim is a
                  raster anim, set "TransPen" to the index of that transparent
                  pen. Otherwise set this member to "HWPEN_NONE". (V9.0)

   @{b}INPUTS@{ub}
        handle    handle returned by @{"OpenAnim()" LINK OpenAnim}
        frame     index of frame to load (starts from 0)
        ctrl      pointer to a struct LoadAnimCtrl

   @{b}RESULTS@{ub}
        raw       an array of raw pixel data

@ENDNODE

@NODE OpenAnim "Hollywood SDK"

   @{b}NAME@{ub}
        OpenAnim -- open an animation file (V5.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = OpenAnim(STRPTR filename, struct LoadAnimCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function has to open the specified filename, check if it is in an
        animation format that the plugin wants to handle, and, if it is, return
        a handle to the animation back to Hollywood. Otherwise it has to return
        NULL. The handle returned by OpenAnim() is an opaque datatype that only
        your plugin knows about. Hollywood will simply pass this handle back to
        your @{"LoadFrame()" LINK LoadFrame} function when it wants to have the raw pixel data of a
        single frame.

        This function also has to provide certain information about the
        animation it has just loaded. This information has to be written to the
        struct LoadAnimCtrl that is passed in the second parameter. This
        structure looks like this:

            struct LoadAnimCtrl
            {
                int Width;                      // [out]
                int Height;                     // [out]
                int LineWidth;                  // [out]
                int NumFrames;                  // [out]
                int AlphaChannel;               // [out]
                int ForceAlphaChannel;          // [out]
                STRPTR Adapter;                 // [in]     -- V6.0
                ULONG Flags;                    // [in]     -- V6.0
                ULONG *Palette;                 // [unused] -- V9.0
                ULONG TransPen;                 // [unused] -- V9.0
                int Depth;                      // [unused] -- V9.0
                int Type;                       // [out]    -- V9.0
                struct hwUserTagList *UserTags; // [in]     -- V10.0
            };

        @{b}Be @{ub}@{b}careful @{ub}@{b}when @{ub}@{b}accessing @{ub}@{b}above @{ub}@{b}structure @{ub}@{b}members: @{ub}@{b}LoadAnimCtrl @{ub}@{b}has @{ub}@{b}seen@{ub}
        @{b}several @{ub}@{b}revisions @{ub}@{b}in @{ub}@{b}Hollywood's @{ub}@{b}history. @{ub}@{b}Before @{ub}@{b}accessing @{ub}@{b}members @{ub}@{b}that@{ub}
        @{b}haven't @{ub}@{b}been @{ub}@{b}there @{ub}@{b}in @{ub}@{b}all @{ub}@{b}Hollywood @{ub}@{b}versions @{ub}@{b}you @{ub}@{b}must @{ub}@{b}make @{ub}@{b}sure @{ub}@{b}that@{ub}
        @{b}your @{ub}@{b}plugin @{ub}@{b}has @{ub}@{b}been @{ub}@{b}opened @{ub}@{b}by @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}version @{ub}@{b}that @{ub}@{b}has @{ub}@{b}those@{ub}
        @{b}members @{ub}@{b}or @{ub}@{b}you @{ub}@{b}will @{ub}@{b}access @{ub}@{b}unallocated @{ub}@{b}memory!@{ub}

        The following information has to be written to the struct LoadAnimCtrl
        pointer by OpenAnim():

        NumFrames:
                  Must be set to the number of frames in this animation.

        Width:    Must be set to the animation width in pixels. Note that
                  Hollywood only supports animations which use the same width
                  for every frame.

        Height:   Must be set to the animation height in pixels. Note that
                  Hollywood only supports animations which use the same height
                  for every frame.

        AlphaChannel:
                  Must be set to TRUE or FALSE, depending on whether or not this
                  animation uses frames that have an alpha channel.

        ForceAlphaChannel:
                  If this is set to TRUE, Hollywood will automatically create an
                  alpha channel for all objects that load this animation. For
                  example, if the user calls "OpenAnim()" on your animation but
                  does not set the "LoadAlpha" tag to TRUE, the animation will
                  still get an alpha channel if you set "ForceAlphaChannel" to
                  TRUE. Note that this functionality was broken before Hollywood
                  6.0.

        Adapter:  Starting with Hollywood 6.0 users can specify the file adapter
                  that should be used to open certain files. If this member is
                  non-NULL, Hollywood wants your plugin to use the file adapter
                  specified in "Adapter" to open the animation. This means that
                  you have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of @{"hw_FOpen()" LINK hw_FOpen} to open
                  the animation. Make sure to check for Hollywood 6.0 before
                  trying to access this member because it isn't there in
                  previous versions. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details. (V6.0)

        Flags:    The following flags may be set by Hollywood:

                  HWANMFLAGS_TRANSPARENCY:
                            This flag will be set whenever the user sets the
                            "LoadTransparency" tag to TRUE. You may then choose
                            to write a frame's transparency information to its
                            alpha channel and set the "ForceAlphaChannel" member
                            to TRUE. See above for more information. (V6.0)

                  HWANMFLAGS_LOADPALETTE:
                            This flag will be set whenever the user sets the
                            "LoadPalette" tag to TRUE. If this flag is set, your
                            implementation of OpenAnim() should fail in case the
                            anim does not have a palette. If it has a palette,
                            you have to return that palette when Hollywood calls
                            your @{"LoadFrame()" LINK LoadFrame} implementation. Note that palette
                            anims must always use "HWANIMTYPE_RASTER". They may
                            not register as vector anims. (V9.0)

                  Make sure to check for Hollywood 6.0 before trying to access
                  this member because it isn't there in previous versions.
                  (V6.0)

        Type:     If the "HWEXT_ANIM_VECTOR" extension bit has been set, "Type"
                  must be set to the anim type. This may be either
                  "HWANIMTYPE_RASTER" or "HWANIMTYPE_VECTOR". If you set this to
                  "HWANIMTYPE_VECTOR", Hollywood will call your @{"TransformFrame()" LINK TransformFrame}
                  function whenever it needs to transform a frame. This allows
                  you to do lossless transformation of the vector frame. For
                  anim frames of type "HWANIMTYPE_RASTER", @{"TransformFrame()" LINK TransformFrame} will
                  never be called. Instead, Hollywood does all transformations
                  itself. (V9.0)

        UserTags: This member will be set to a list of user tags in case they
                  were specified in the Hollywood script. User tags are a way of
                  passing additional information from Hollywood scripts to
                  plugin functions. Note that even if your plugin doesn't
                  support any user tags, you should still look for this tag and
                  pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed
                  in "UserTags" could also be intended for another plugin,
                  namely the file adapter plugin passed in "Adapter". See @{"User" LINK UserTags}
                  @{"tags" LINK UserTags} for details. Make sure to check for Hollywood 10.0 before
                  trying to access this member because it isn't there in
                  previous versions. (V10.0)

        Please note that you should not use ANSI C functions like "fopen()" to
        open the file that is passed to this function because the filename that
        is passed to this function can also be a specially formatted filename
        specification that Hollywood uses to load files that have been linked to
        applets or executables. In order to be able to load these files
        correctly, you have to use special IO functions provided by Hollywood.
        See @{"File IO information" LINK FileIO} for details.

   @{b}INPUTS@{ub}
        filename  filename to open
        ctrl      pointer to a struct LoadAnimCtrl for storing information about
                  the animation

   @{b}RESULTS@{ub}
        handle    a handle that identifies this animation or NULL if plugin
                  doesn't want to handle this animation

@ENDNODE

@NODE TransformFrame "Hollywood SDK"

   @{b}NAME@{ub}
        TransformFrame -- transform a vector frame (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = TransformFrame(APTR handle, struct hwMatrix2D *m, int width,
                      int height);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_ANIM_VECTOR" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, this function must transform the
        specified vector frame according to the 2D transformation matrix passed
        in parameter 2. It must also clip the resulting frame to the specified
        width and height in pixels. After calling TransformFrame(), Hollywood
        will then call your plugin's @{"GetFrame()" LINK GetFrame} function again to obtain the raw
        pixel data of the newly transformed frame. It is very important that the
        dimensions and the pixel array returned by the next call to @{"GetFrame()" LINK GetFrame}
        match the dimensions passed to TransformFrame() in parameters 3 and 4
        exactly.

        TransformFrame() is only ever called for anims of type
        "HWANIMTYPE_VECTOR". If your @{"OpenAnim()" LINK OpenAnim} function sets the anim type to
        "HWANIMTYPE_RASTER", TransformFrame() won't be called at all and
        Hollywood will do all frame transformations on its own.

        If the transformation was successful, TransformFrame() must return TRUE.
        Otherwise it has to return FALSE.

   @{b}INPUTS@{ub}
        handle    frame handle as returned by @{"LoadFrame()" LINK LoadFrame}
        m         2D matrix describing the desired transformation
        width     clipping width for resulting frame
        height    clipping height for resulting frame

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE AnimSaverOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_SAVEANIM" set can
    register one or more additional output animation formats. The user will then
    be able to save animations in the output formats supported by the plugin.
    Plugins have to register new output animation formats by passing the name of
    a constant that should be used to access the new format. For example, a
    plugin might choose to register a new output animation format under the
    constant #ANMFMT_CUSTOMFORMAT. Whenever the user calls a command like
    "SaveAnim()" now and passes #ANMFMT_CUSTOMFORMAT as the animation format,
    Hollywood will ask the plugin to save the animation.

    Note that anim saver plugins need not implement all functions offered by the
    anim saver plugin API. Some functions are optional and need only be
    implemented in specific cases. Here's a list of optional functions:

    BeginAnimStreamExt()
              Only used if you set the "HWEXT_SAVEANIM_BEGINANIMSTREAM"
              extension flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
              extension bits.

    @{"BeginAnimStream()                 " LINK BeginAnimStream} Create a new animation stream
    @{"BeginAnimStreamExt()              " LINK BeginAnimStreamExt} Create a new animation stream with tags
    @{"FinishAnimStream()                " LINK FinishAnimStream} Finish animation stream
    @{"RegisterAnimSaver()               " LINK RegisterAnimSaver} Register a new animation saver
    @{"WriteAnimFrame()                  " LINK WriteAnimFrame} Write single animation frame to disk
@ENDNODE

@NODE BeginAnimStream "Hollywood SDK"

   @{b}NAME@{ub}
        BeginAnimStream -- create a new animation stream (V5.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = BeginAnimStream(STRPTR filename, int width, int height,
                          int format, int quality, int fps);

   @{b}FUNCTION@{ub}
        This function must create a new animation stream in the specified
        filename. After Hollywood has called this function, it will then call
        @{"WriteAnimFrame()" LINK WriteAnimFrame} to add a number of frames to your animation stream.
        Once all frames have been added, Hollywood will call @{"FinishAnimStream()" LINK FinishAnimStream}
        on the stream handle.

        The "format" parameter specifies the pixel format of the source frame
        data that will be passed by @{"WriteAnimFrame()" LINK WriteAnimFrame} later. This can be one of
        the following constants:

        HWSAVEANMFMT_ARGB:
                  Data is delivered as a 32-bit array consisting of ARGB pixels.

        HWSAVEANMFMT_CLUT:
                  Data is delivered as 8-bit indices into a color look-up table.

        You will only have to handle those formats that you have explicitly
        declared as supported when Hollywood called your @{"RegisterAnimSaver()" LINK RegisterAnimSaver}
        function.

        The "quality" parameter contains a value between 0 and 100 indicating
        the desired quality for the output file. Animation formats that use
        lossy compression can use this member to determine compression settings
        for the animation. Animation formats that don't use any compression or
        offer lossless compression can ignore this parameter.

        The "fps" parameter contains the desired playback rate for the animation
        in frames per second. This is not supported by all animation formats so
        you can ignore it if you want. Some animation formats also support a
        frame-based delay value that Hollywood will pass to you in its
        @{"WriteAnimFrame()" LINK WriteAnimFrame} calls.

        Please note that in case your plugin supports multiple output animation
        formats, you'll have to wait until the first call to @{"WriteAnimFrame()" LINK WriteAnimFrame} on
        that stream until you can tell which format the user has chosen for the
        stream. This inconvenience is due to a design flaw in Hollywood: Support
        for multiple output animation formats wasn't available before Hollywood
        5.3 but the API was designed for Hollywood 5.0. So there's just no room
        for another parameter in the BeginAnimStream() prototype declaration
        because it doesn't accept a tag list or any other parameter that could
        by dynamically extended as Hollywood functionality increases. Thus,
        you'll have to wait until @{"WriteAnimFrame()" LINK WriteAnimFrame} which gives you the
        information in the "FormatID" structure member.

        This function has to return a handle to the stream if the animation has
        been successfully created or NULL if there was an error.

        Note that since Hollywood 10.0 it's recommended to use
        @{"BeginAnimStreamExt()" LINK BeginAnimStreamExt} instead of this function because it also supports
        user tags and you don't have to wait until the first call to
        @{"WriteAnimFrame()" LINK WriteAnimFrame} to learn about the output format. BeginAnimStream() is
        broken by design because it can't be extended so if you target Hollywood
        10.0 or higher, you should use the more flexible @{"BeginAnimStreamExt()" LINK BeginAnimStreamExt}
        instead. See @{"BeginAnimStreamExt" LINK BeginAnimStreamExt} for details. Note if you use
        @{"BeginAnimStreamExt()" LINK BeginAnimStreamExt}, you also need to set the
        "HWEXT_SAVEANIM_BEGINANIMSTREAM" extension bit. See @{"Extension plugins" LINK ExtensionOverview} to
        learn how to use plugin extension bits.

   @{b}INPUTS@{ub}
        filename  desired location for the animation file on disk
        width     animation width in pixels
        height    animation height in pixels
        format    format for the animation (see above)
        quality   quality for the animation (see above)
        fps       frames per second for the animation

   @{b}RESULTS@{ub}
        handle    animation handle or NULL in case of an error

@ENDNODE

@NODE BeginAnimStreamExt "Hollywood SDK"

   @{b}NAME@{ub}
        BeginAnimStreamExt -- create a new animation stream (V10.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = BeginAnimStreamExt(STRPTR filename, int width, int height,
                        int format, int quality, int fps, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        When targetting Hollywood 10.0 or better, this function should be used
        instead of @{"BeginAnimStream()" LINK BeginAnimStream} because it offers more flexibility. To make
        Hollywood use this function instead of @{"BeginAnimStream()" LINK BeginAnimStream}, set the
        "HWEXT_SAVEANIM_BEGINANIMSTREAM" extension bit. See @{"Extension plugins" LINK ExtensionOverview} to
        learn how to use plugin extension bits.

        This function must create a new animation stream and save it as the
        specified file. After Hollywood has called this function, it will then
        call @{"WriteAnimFrame()" LINK WriteAnimFrame} to add a number of frames to your animation
        stream. Once all frames have been added, Hollywood will call
        @{"FinishAnimStream()" LINK FinishAnimStream} on the stream handle.

        The "format" parameter specifies the pixel format of the source frame
        data that will be passed by @{"WriteAnimFrame()" LINK WriteAnimFrame} later. This can be one of
        the following constants:

        HWSAVEANMFMT_ARGB:
                  Data is delivered as a 32-bit array consisting of ARGB pixels.

        HWSAVEANMFMT_CLUT:
                  Data is delivered as 8-bit indices into a color look-up table.

        You will only have to handle those formats that you have explicitly
        declared as supported when Hollywood called your @{"RegisterAnimSaver()" LINK RegisterAnimSaver}
        function.

        The "quality" parameter contains a value between 0 and 100 indicating
        the desired quality for the output file. Animation formats that use
        lossy compression can use this member to determine compression settings
        for the animation. Animation formats that don't use any compression or
        offer lossless compression can ignore this parameter.

        The "fps" parameter contains the desired playback rate for the animation
        in frames per second. This is not supported by all animation formats so
        you can ignore it if you want. Some animation formats also support a
        frame-based delay value that Hollywood will pass to you in its
        @{"WriteAnimFrame()" LINK WriteAnimFrame} calls.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWBASTAG_FORMAT:
                  The "iData" member of this tag contains the identifier of the
                  animation format that should be used. You only need to look at
                  this tag if your plugin supports more than one output format.
                  (V10.0)

        HWBASTAG_ADAPTER:
                  Starting with Hollywood 10.0, users can specify the file
                  adapter that should be used to save an anim. If this tag is
                  set, Hollywood wants your plugin to use the file adapter
                  specified in the "pData" member of the tag to save the anim.
                  This means that you have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of
                  @{"hw_FOpen()" LINK hw_FOpen} to save the anim. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details.
                  (V10.0)

        HWBASTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. Note that even if your
                  plugin doesn't support any user tags, you should still look
                  for this tag and pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the
                  user tags passed in "UserTags" could also be intended for
                  another plugin, namely the file adapter plugin passed in
                  "Adapter". See @{"User tags" LINK UserTags} for details. (V10.0)

        This function has to return a handle to the stream if the animation has
        been successfully created or NULL if there was an error.

   @{b}INPUTS@{ub}
        filename  desired location for the animation file on disk
        width     animation width in pixels
        height    animation height in pixels
        format    format for the animation (see above)
        quality   quality for the animation (see above)
        fps       frames per second for the animation
        tags      tag list containing further parameters

   @{b}RESULTS@{ub}
        handle    animation handle or NULL in case of an error

@ENDNODE

@NODE FinishAnimStream "Hollywood SDK"

   @{b}NAME@{ub}
        FinishAnimStream -- finish animation stream (V5.0)

   @{b}SYNOPSIS@{ub}
        int ok = FinishAnimStream(APTR stream);

   @{b}FUNCTION@{ub}
        This function must finish all writes to the specified animation stream
        and then close its file handle so that the file can be used.

        This function has to return TRUE if the stream has been successfully
        finished or FALSE in case of an error.

   @{b}INPUTS@{ub}
        stream    output anim stream handle created by @{"BeginAnimStream()" LINK BeginAnimStream}

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE RegisterAnimSaver "Hollywood SDK"

   @{b}NAME@{ub}
        RegisterAnimSaver -- register a new animation saver (V5.0)

   @{b}SYNOPSIS@{ub}
        void RegisterAnimSaver(struct SaveAnimReg *reg)

   @{b}FUNCTION@{ub}
        Hollywood will call this function to get information about the animation
        saver your plugin wants to register. In addition, RegisterAnimSaver()
        has to tell Hollywood whether it wants to register another animation
        saver. Hollywood will pass a pointer to a struct SaveAnimReg to this
        function. This structure looks like this:

            struct SaveFormatReg
            {
                ULONG CapsMask;     [out]
                ULONG FormatID;     [in/out]
                STRPTR FormatName;  [out]
            };

            struct SaveAnimReg
            {
                struct SaveFormatReg hdr;
            };

        Your implementation has to do the following with the individual
        structure members:

        CapsMask: This must be set to a combination of flags that tell Hollywood
                  about the capabilities of the animation saver that is to be
                  registered. The following flags are currently supported:

                  HWSAVEANMCAPS_ARGB:
                            Your animation saver supports source animation data
                            that is delivered as a 32-bit ARGB pixel array.

                  HWSAVEANMCAPS_CLUT:
                            Your animation saver supports source animation data
                            that is delivered as 8-bit CLUT pixels that are
                            index values for a palette look-up table.

                  HWSAVEANMCAPS_ALPHA:
                            Your animation saver supports alpha channel saving.
                            This is only supported if you also set
                            "HWSAVEANMCAPS_ARGB".

                  HWSAVEANMCAPS_MORE:
                            If you set this flag, Hollywood will call
                            RegisterAnimSaver() again so that you can register
                            another saver. If you don't want to register another
                            saver, don't set this flag. (V5.3)

                  Note that "HWSAVEANMCAPS_ARGB" and "HWSAVEANMCAPS_CLUT" are
                  not mutually exclusive. You can set them both if the target
                  animation format supports both true colour and palette-based
                  pixel data storage.

        FormatID: This member must be set to a unique 32-bit value that should
                  be assigned to the constant that is registered for accessing
                  this animation saver from Hollywood scripts. Values smaller
                  than 32768 are reserved for internal Hollywood use. You may
                  use values larger than 32768 for your saver but if you want to
                  publish your plugin, you need to contact Airsoft Softwair to
                  obtain a unique value that is still vacant. This won't cost
                  you anything; it's just needed to make sure that plugin
                  animation savers don't use conflicting identifiers. Also, once
                  you have published your animation saver plugin, the "FormatID"
                  you have specified must not be changed or you will break
                  compatibility with applets or executables that have been
                  compiled with previous versions. If you are registering more
                  than one animation saver using "HWSAVEANMCAPS_MORE", you can
                  look at the "FormatID" member to tell how many times Hollywood
                  has already called RegisterAnimSaver() because "FormatID" will
                  contain the identifier of the last animation saver you
                  registered. If "FormatID" is 0, then this is the first call to
                  RegisterAnimSaver(). Note that it is not recommended to keep
                  your own counter because Hollywood might call
                  RegisterAnimSaver() multiple times, i.e. it might first loop
                  over RegisterAnimSaver() to determine how many animation
                  savers there are in total and then it might loop over
                  RegisterAnimSaver() again to actually register their names.

        FormatName:
                  This must be set to a string that should form the second half
                  of the constant that Hollywood registers for your animation
                  saver. This string you specify here must follow the naming
                  restrictions for Hollywood constants, i.e. only alphabetical
                  characters, numbers and very few special characters like the
                  underscore character are allowed. The #ANMFMT_ prefix must not
                  be included in the string you pass. Hollywood will add this
                  automatically, i.e. if you pass the string "TESTFORMAT" here,
                  Hollywood will make your animation saver available under the
                  constant #ANMFMT_TESTFORMAT.

   @{b}INPUTS@{ub}
        reg       pointer to a struct SaveAnimReg to be filled out by your
                  implementation

@ENDNODE

@NODE WriteAnimFrame "Hollywood SDK"

   @{b}NAME@{ub}
        WriteAnimFrame -- write single animation frame to disk (V5.0)

   @{b}SYNOPSIS@{ub}
        int ok = WriteAnimFrame(APTR stream, struct SaveAnimCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function must save the frame described in the second parameter to
        the animation stream that is passed in the first parameter. This stream
        pointer is a handle that has been created by the @{"BeginAnimStream()" LINK BeginAnimStream}
        function. The second parameter is a pointer to a struct SaveAnimCtrl.
        This structure looks like this:

            struct SaveAnimCtrl
            {
                APTR Data;        // [in]
                ULONG *Palette;   // [in]
                int Modulo;       // [in]
                int Colors;       // [in]
                ULONG TransIndex; // [in]
                int Delay;        // [in]
                ULONG Flags;      // [in]
                ULONG FormatID;   // [in] -- V5.3
            };

        Hollywood passes the following information to your WriteAnimFrame()
        function:

        Data:     The pixel data to save to the frame. The actual format of this
                  data depends on the "Format" member.

        Modulo:   Number of bytes used by a single row of pixel data. This may
                  be more than needed to store for the width that has been
                  passed to @{"BeginAnimStream()" LINK BeginAnimStream} since there may be some padding.

        Colors:   This contains the number of colors in the color look-up table
                  passed in the "Palette" member. This member is only used if
                  "HWSAVEANMFMT_CLUT" has been passed to @{"BeginAnimStream()" LINK BeginAnimStream}.

        Palette:  Contains the look-up table that you need to convert the CLUT
                  pixel values to RGB color values. This table consists of as
                  many 32-bit ARGB values as has been set in the "Colors"
                  member. Note that "Palette" is only used if
                  "HWSAVEANMFMT_CLUT" has been passed to @{"BeginAnimStream()" LINK BeginAnimStream}.

        TransIndex:
                  If this animation stream has been created using
                  "HWSAVEANMFMT_CLUT" this member specifies the index of the
                  color that should appear transparent in the animation. The
                  value specified here is only valid if the
                  "HWSAVEANMFLAGS_TRANSINDEX" flag has been set (see below).

        Delay:    The delay for this frame in milliseconds or 0 if there should
                  be no delay. Not all animation formats support frame-based
                  delaying.

        Flags:    Contains a combination of flags specifying further options:

                  HWSAVEANMFLAGS_ALPHA:
                            Pixel data contains alpha channel transparency
                            values.

                  HWSAVEANMFLAGS_TRANSINDEX:
                            The "TransIndex" member contains the index of a
                            palette entry that should be made transparent in the
                            output animation.

        FormatID: This member contains the identifier of the animation format
                  the frame should be saved in. You only need to look at this
                  member if your plugin supports more than one output animation
                  format. But be careful, you are only allowed to look at this
                  member if the user is running at least Hollywood 5.3.
                  Otherwise, you must not access this member because older
                  versions of Hollywood don't support it. (V5.3)

        This function has to return TRUE if the frame has been successfully
        saved or FALSE in case of an error.

   @{b}INPUTS@{ub}
        stream    output anim stream handle created by @{"BeginAnimStream()" LINK BeginAnimStream}
        ctrl      pointer to a struct SaveAnimCtrl containing the frame to be
                  saved

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE AudioAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_AUDIOADAPTER" set can
    replace Hollywood's inbuilt audio driver with a customized version. This is
    a very powerful feature and allows you to reroute Hollywood's complete audio
    output through an entirely different backend, thus making it possible to
    adapt Hollywood to completely different audio environments.

    Please note that audio adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_SetAudioAdapter()" LINK hw_SetAudioAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the audio
    adapter. The audio adapter will then only be activated if the user calls
    "\@REQUIRE" on your plugin. Otherwise, Hollywood will use its default audio
    driver. See @{"Auto and manual plugin initialization" LINK AutoAndManualInit} for details.

    See @{"hw_SetAudioAdapter" LINK hw_SetAudioAdapter} for information on how to install your audio adapter.

    This plugin type is supported since Hollywood 6.0.

    @{"AllocAudioChannel()               " LINK AllocAudioChannel} Allocate new audio channel
    @{"CloseAudio()                      " LINK CloseAudio} Close audio device
    @{"FreeAudioChannel()                " LINK FreeAudioChannel} Free audio channel
    @{"OpenAudio()                       " LINK OpenAudio} Open audio device
    @{"SetChannelAttributes()            " LINK SetChannelAttributes} Change audio channel attributes
@ENDNODE

@NODE AllocAudioChannel "Hollywood SDK"

   @{b}NAME@{ub}
        AllocAudioChannel -- allocate new audio channel (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR chandle = AllocAudioChannel(APTR handle, int fmt, int freq, int vol,
                          int (*feedproc)(APTR handle, APTR chandle, APTR buf,
                          int count, APTR userdata), ULONG flags, APTR userdata,
                          struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must allocate a new audio channel on the audio device
        passed in the first parameter. Hollywood will inform you about the PCM
        sample format that should be played on this channel in parameters 2 to
        4. The "fmt" parameter can be one of the following formats:

        HWSMPFMT_U8M:
                  Unsigned 8-bit mono PCM data is fed to this channel.

        HWSMPFMT_U8S:
                  Unsigned 8-bit stereo PCM data is fed to this channel.

        HWSMPFMT_S8M:
                  Signed 8-bit mono PCM data is fed to this channel.

        HWSMPFMT_S8S:
                  Signed 8-bit stereo PCM data is fed to this channel.

        HWSMPFMT_S16M:
                  Signed 16-bit mono PCM data is fed to this channel.

        HWSMPFMT_S16S:
                  Signed 16-bit stereo PCM data is fed to this channel.

        Parameter 3 contains the number of PCM frames that will be played on
        this channel per second. Common values are 44100 or 48000 here.
        Parameter 4 contains the desired volume for this channel. This can range
        from 0 (mute) to 64 (full volume).

        Hollywood will also pass a pointer to an audio feed procedure to this
        function. Whenever you need more PCM data to play on this audio channel,
        call this feed procedure. The prototype of this procedure looks like
        this:

            int feedproc(APTR hdl, APTR ch, APTR buf, int count, APTR userdata);

        Here is how you have to call this feed procedure:

        hdl:      This parameter must be set to the handle of the audio device
                  opened via @{"OpenAudio()" LINK OpenAudio}.

        ch:       This parameter must be set to the handle of the audio channel
                  allocated via AllocAudioChannel().

        buf:      You have to pass a pointer to a memory buffer that should
                  receive the new PCM data here.

        count:    You have to pass the number of PCM frames you want to receive
                  here. Please note that this parameter must be specified in PCM
                  frames, not in bytes. So if you set this to 1024 and your PCM
                  samples are formatted as 16-bit wide stereo frames, the buffer
                  you pass would have to be at least 4096 bytes in size. You
                  should request PCM frames from Hollywood only in small
                  portions. For a playback rate of 44100 frames per second, a
                  request of 2048 PCM frames per "feedproc()" call is a
                  reasonable size.

        userdata: You always have to set this parameter to the user data pointer
                  that Hollywood has passed to your AllocAudioChannel() function
                  here.

        "feedproc()" returns the number of PCM frames successfully copied. Once
        again, be careful that this value is in PCM frames, not in bytes (see
        above). If this value is less than you requested, the channel has
        finished playing and Hollywood will soon call @{"FreeAudioChannel()" LINK FreeAudioChannel} on it.

        The feed procedure that Hollywood passes to you is thread-safe so you
        can call this from worker threads or audio interrupts as well.

   @{b}INPUTS@{ub}
        handle    audio device allocated by @{"OpenAudio()" LINK OpenAudio}
        fmt       format of PCM data passed to this channel (see above)
        freq      number of PCM frames per second to be played on this channel
        vol       initial channel volume (0 to 64)
        feedproc  pointer to a function that needs to be called to request more
                  PCM data from Hollywood
        flags     reserved for future use (currently 0)
        userdata  userdata that needs to be passed to "feedproc()"
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        chandle   handle to this audio channel or NULL on error

@ENDNODE

@NODE CloseAudio "Hollywood SDK"

   @{b}NAME@{ub}
        CloseAudio -- close audio device (V6.0)

   @{b}SYNOPSIS@{ub}
        void CloseAudio(APTR handle);

   @{b}FUNCTION@{ub}
        This function must close the specified audio device handle that has been
        opened by @{"OpenAudio()" LINK OpenAudio}.

   @{b}INPUTS@{ub}
        handle    audio device allocated by @{"OpenAudio()" LINK OpenAudio}

@ENDNODE

@NODE FreeAudioChannel "Hollywood SDK"

   @{b}NAME@{ub}
        FreeAudioChannel -- free audio channel (V6.0)

   @{b}SYNOPSIS@{ub}
        void FreeAudioChannel(APTR handle, APTR chandle);

   @{b}FUNCTION@{ub}
        This function must free the specified channel on the audio device.

   @{b}INPUTS@{ub}
        handle    audio device allocated by @{"OpenAudio()" LINK OpenAudio}
        chandle   audio channel allocated by @{"AllocAudioChannel()" LINK AllocAudioChannel}

@ENDNODE

@NODE OpenAudio "Hollywood SDK"

   @{b}NAME@{ub}
        OpenAudio -- open audio device (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = OpenAudio(ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must open your plugin's audio device and return a handle
        to it. The "flags" and "tags" parameters are currently unused and
        reserved for future use.

   @{b}INPUTS@{ub}
        flags     reserved for future use (currently 0)
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        handle    handle to audio device or NULL on error

@ENDNODE

@NODE SetChannelAttributes "Hollywood SDK"

   @{b}NAME@{ub}
        SetChannelAttributes -- change audio channel attributes (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = SetChannelAttributes(APTR handle, APTR chandle,
                        struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must change attributes of the specified audio channel.
        Attributes are passed as a taglist. The following attributes may
        currently be changed:

        HWSCATAG_VOLUME:
                  Change the channel's volume to the volume specified in the
                  "iData" member of this tag item. Volumes are specified in the
                  range of 0 (mute) to 64 (full volume).

        HWSCATAG_PANNING:
                  Change the channel's panning value to the value specified in
                  the "iData" member of this tag item. Panning values range from
                  0 (left speaker only) to 255 (right speaker only). The default
                  panning is 128 which means centered audio output.

        HWSCATAG_PITCH:
                  Change the channel's pitch to the value specified in the
                  "iData" member of this tag item. The pitch value specifies the
                  number of PCM frames that are to be played per second.

   @{b}INPUTS@{ub}
        handle    audio device allocated by @{"OpenAudio()" LINK OpenAudio}
        chandle   audio channel allocated by @{"AllocAudioChannel()" LINK AllocAudioChannel}
        tags      taglist containing attributes to modify (see above)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE BaseOverview "Hollywood SDK"
@{b}Overview@{ub}

    The functions @{"InitPlugin()" LINK InitPlugin} and @{"ClosePlugin()" LINK ClosePlugin} must be implemented by every
    plugin. Hollywood will load the plugin depending on the information returned
    to it by @{"InitPlugin()" LINK InitPlugin}.

    @{"ClosePlugin()                     " LINK ClosePlugin} Close plugin
    @{"InitPlugin()                      " LINK InitPlugin} Init plugin
@ENDNODE

@NODE ClosePlugin "Hollywood SDK"

   @{b}NAME@{ub}
        ClosePlugin -- close plugin (V5.0)

   @{b}SYNOPSIS@{ub}
        void ClosePlugin(void);

   @{b}FUNCTION@{ub}
        This function must free all resources allocated by the plugin.
        ClosePlugin() will be the final call Hollywood makes to your plugin.
        After that the plugin will be expunged from memory.

        @{b}Important: @{ub}@{b}Be @{ub}@{b}very @{ub}@{b}careful @{ub}@{b}about @{ub}@{b}the @{ub}@{b}plugin @{ub}@{b}API @{ub}@{b}functions @{ub}@{b}that @{ub}@{b}you @{ub}@{b}call@{ub}
        @{b}here @{ub}because ClosePlugin() can also be called by Hollywood versions that
        are older than the one you requested in your @{"InitPlugin()" LINK InitPlugin}
        implementation. See @{"InitPlugin" LINK InitPlugin} for a detailed description of this issue.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE InitPlugin "Hollywood SDK"

   @{b}NAME@{ub}
        InitPlugin -- init plugin (V5.0)

   @{b}SYNOPSIS@{ub}
        int success = InitPlugin(hwPluginBase *self, hwPluginAPI *cl, STRPTR path);

   @{b}FUNCTION@{ub}
        This function must initialize your plugin and report information about
        it back to Hollywood. Your InitPlugin() implementation must fill out all
        fields of the "hwPluginBase" structure that is passed to it:

            typedef struct _hwPluginBase
            {
                ULONG CapsMask;       // [out]
                int Version;          // [out]
                int Revision;         // [out]
                int hwVersion;        // [in/out]
                int hwRevision;       // [in/out]
                STRPTR Name;          // [out]
                STRPTR ModuleName;    // [out]
                STRPTR Author;        // [out]
                STRPTR Description;   // [out]
                STRPTR Copyright;     // [out]
                STRPTR URL;           // [out]
                STRPTR Date;          // [out]
                STRPTR Settings;      // [out]
                STRPTR HelpFile;      // [out]
            } hwPluginBase;

        Here is an explanation about the function of the different structure
        members:

        CapsMask: This is a bitmask describing the capabilities of your plugin,
                  i.e. which features your plugin provides. Hollywood uses this
                  bitmask to determine which function pointers it has to import
                  from your plugin. This member must be set to one or more of
                  the following capabilities:

                  HWPLUG_CAPS_CONVERT
                            Plugin can convert custom file types into Hollywood
                            scripts. See @{"Convert script plugins" LINK ConvertScriptOverview} for details.

                  HWPLUG_CAPS_LIBRARY
                            Plugin adds new commands and constants. See @{"Library" LINK LibraryOverview}
                            @{"plugins" LINK LibraryOverview} for details.

                  HWPLUG_CAPS_IMAGE
                            Plugin provides a loader for additional image
                            formats. See @{"Image plugins" LINK ImageOverview} for details.

                  HWPLUG_CAPS_ANIM
                            Plugin provides a loader for additional animation
                            formats. See @{"Animation plugins" LINK AnimOverview} for details.

                  HWPLUG_CAPS_SOUND
                            Plugin provides a loader for additional sound
                            formats. See @{"Sound plugins" LINK SoundOverview} for details.

                  HWPLUG_CAPS_VECTOR
                            Plugin provides an implementation to draw vector
                            graphics. See @{"Vectorgraphics plugins" LINK VectorGfxOverview} for details.

                  HWPLUG_CAPS_VIDEO
                            Plugin provides a loader for additional video
                            formats. See @{"Video plugins" LINK VideoOverview} for details.

                  HWPLUG_CAPS_SAVEIMAGE
                            Plugin provides a saver for additional image
                            formats. See @{"Image saver plugins" LINK ImageSaverOverview} for details.

                  HWPLUG_CAPS_SAVEANIM
                            Plugin provides a saver for additional animation
                            formats. See @{"Animation saver plugins" LINK AnimSaverOverview} for details.

                  HWPLUG_CAPS_SAVESAMPLE
                            Plugin provides a saver for additional sound
                            formats. See @{"Sample saver plugins" LINK SampleSaverOverview} for details.

                  HWPLUG_CAPS_REQUIRE
                            Plugin wants to be called when the user does a
                            "\@REQUIRE" on it. See @{"Require hook plugins" LINK RequireHookOverview} for
                            details. (V6.0)

                  HWPLUG_CAPS_DISPLAYADAPTER
                            Plugin replaces Hollywood's inbuilt display handler.
                            See @{"Display adapter plugins" LINK DisplayAdapterOverview} for details. (V6.0)

                  HWPLUG_CAPS_TIMERADAPTER
                            Plugin replaces Hollywood's inbuilt timer handler.
                            See @{"Timer adapter plugins" LINK TimerAdapterOverview} for details. (V6.0)

                  HWPLUG_CAPS_REQUESTERADAPTER
                            Plugin replaces Hollywood's inbuilt requester
                            handler. See @{"Requester adapter plugins" LINK RequesterAdapterOverview} for details.
                            (V6.0)

                  HWPLUG_CAPS_FILEADAPTER
                            Plugin provides a loader for additional file
                            formats. See @{"File adapter plugins" LINK FileAdapterOverview} for details.
                            (V6.0)

                  HWPLUG_CAPS_DIRADAPTER
                            Plugin provides a loader for additional directory
                            formats. See @{"Directory adapter plugins" LINK DirAdapterOverview} for details.
                            (V6.0)

                  HWPLUG_CAPS_AUDIOADAPTER
                            Plugin replaces Hollywood's inbuilt audio driver.
                            See @{"Audio adapter plugins" LINK AudioAdapterOverview} for details. (V6.0)

                  HWPLUG_CAPS_EXTENSION
                            This is a special plugin type that does not offer
                            any functionality on its own. Its only purpose is to
                            extend other plugin types. See @{"Extension plugins" LINK ExtensionOverview} for
                            details. (V6.0)

                  HWPLUG_CAPS_NETWORKADAPTER
                            Plugin provides a handler for custom network
                            protocols. See @{"Network adapter plugins" LINK NetworkAdapterOverview} for details.
                            (V8.0)

                  HWPLUG_CAPS_SERIALIZE
                            Plugin provides a new data serializer. See
                            @{"Serializer plugins" LINK SerializeOverview} for details. (V9.0)

                  HWPLUG_CAPS_ICON
                            Plugin provides a loader for additional icon
                            formats. See @{"Icon plugins" LINK IconOverview} for details. (V9.0)

                  HWPLUG_CAPS_SAVEICON
                            Plugin provides a saver for additional icon formats.
                            See @{"Icon saver plugins" LINK IconSaverOverview} for details. (V9.0)

                  HWPLUG_CAPS_IPCADAPTER
                            Plugin replaces Hollywood's inbuilt IPC handler. See
                            @{"IPC adapter plugins" LINK IPCAdapterOverview} for details. (V9.0)

                  HWPLUG_CAPS_FONT
                            Plugin provides a loader for additional font
                            formats. See @{"Font plugins" LINK FontOverview} for details. (V10.0)

                  HWPLUG_CAPS_FILESYSADAPTER
                            Plugin replaces Hollywood's inbuilt filesystem
                            handler. See @{"Filesystem adapter plugins" LINK FilesysAdapterOverview} for details.
                            (V10.0)

                  You have to implement all functions for every capability bit
                  you set in "CapsMask" otherwise Hollywood will fail to load
                  your plugin.

        Version:  Set this to the current version of your plugin.

        Revision: Set this to the current revision of your plugin.

        hwVersion:
                  This contains the Hollywood version that has just opened your
                  plugin. You should store this value somewhere because you
                  might need it later to check whether a certain feature is
                  available in this Hollywood version or not. After that, set
                  this member to the minimum Hollywood version required by your
                  plugin.

        hwRevision:
                  This contains the Hollywood revision that has just opened your
                  plugin. You should store this value somewhere because you
                  might need it later to check whether a certain feature is
                  available in this Hollywood revision or not. After that, set
                  this to the minimum Hollywood revision required by your
                  plugin.

        Name:     Set this to a string describing the name of your plugin. This
                  can contain spaces and need not be unique. Non-ASCII
                  characters must be encoded as UTF-8.

        ModuleName:
                  Set this to the module name of your plugin. The module name of
                  your plugin must be identical to its file name minus the *.hwp
                  extension. If file and module names do not match, Hollywood
                  will refuse to load your plugin. This may only contain ASCII
                  characters which are allowed in file names.

        Author:   Set this to the name(s) of the plugin author(s). Non-ASCII
                  characters must be encoded as UTF-8.

        Description:
                  Set this to a string describing the plugin's functionality.
                  Non-ASCII characters must be encoded as UTF-8.

        Copyright:
                  Set this to a string containing relevant copyright
                  information. Non-ASCII characters must be encoded as UTF-8.

        URL:      Set this to a string containing a link to the plugin's
                  website. This may be NULL.

        Date:     Set this to the build date of the plugin. This may be NULL. If
                  set, it should use the format "dd.mm.yy".

        Settings: This can be set to the full path of an external program that
                  can be used to configure settings for your plugin. It is
                  advised to store this program relative to your plugin's path.
                  You can find out the full path of your plugin by looking at
                  the third argument that is passed to InitPlugin(). This will
                  tell you where the user has installed your plugin. If you set
                  this member, the user will be able to launch the external
                  program from the Hollywood GUI. If your plugin doesn't feature
                  such a program, set this member to NULL.

        HelpFile: This can be set to the full path of a help file that acts as a
                  user manual for the plugin. It is advised to store this help
                  file relative to your plugin's path. You can find out the full
                  path of your plugin by looking at the third argument that is
                  passed to InitPlugin(). This will tell you where the user has
                  installed your plugin. If you set this member, the user will
                  be able to open this help file from the Hollywood GUI. If your
                  plugin doesn't come with a help file, set this member to NULL.

        Note that all string pointers you use to initialize the "hwPluginBase"
        structure must stay valid until @{"ClosePlugin()" LINK ClosePlugin} is called.

        The second parameter that is passed to InitPlugin() is a pointer to a
        "hwPluginAPI" vector which is the gateway to all plugin API functions
        provided by Hollywood. Plugin API functions are grouped into several
        different library bases like "GfxBase" and "SysBase". Please note that
        this parameter can be NULL. If this is the case, your plugin should not
        initialize itself but just fill out the "hwPluginBase" structure and
        return TRUE. If Hollywood passes NULL in "hwPluginAPI" it only wants to
        collect information about your plugin without actually loading it.

        @{b}Important: @{ub}@{b}You @{ub}@{b}have @{ub}@{b}to @{ub}@{b}be @{ub}@{b}very @{ub}@{b}careful @{ub}@{b}about @{ub}@{b}the @{ub}@{b}plugin @{ub}@{b}API @{ub}@{b}functions@{ub}
        @{b}you @{ub}@{b}call @{ub}@{b}from @{ub}@{b}your @{ub}@{b}InitPlugin() @{ub}@{b}implementation. @{ub}This is because an older
        Hollywood version might have called your InitPlugin() function and if
        you try to call newer plugin API functions that are unavailable in the
        Hollywood version that has just called InitPlugin(), your plugin will
        crash terribly. You always have to check the "hwVersion" and
        "hwRevision" members of the "hwPluginBase" structure that is passed to
        your InitPlugin() function before you call any of the plugin APIs. These
        checks only have to be done in InitPlugin() and @{"ClosePlugin()" LINK ClosePlugin} since they
        can be called by any Hollywood version. All the other functions of your
        plugin will only be called if the host Hollywood version matches the one
        you request in your InitPlugin() implementation using the "hwVersion"
        and "hwRevision" members. InitPlugin() and @{"ClosePlugin()" LINK ClosePlugin}, however, may
        be called by any arbitrary Hollywood version and the only assumption you
        can make is that it will be at least Hollywood 5.0 which is calling you
        because 5.0 is the version that introduced the new plugin system
        explained here. @{b}Please @{ub}@{b}take @{ub}@{b}this @{ub}@{b}advice @{ub}@{b}very @{ub}@{b}seriously @{ub}@{b}because @{ub}@{b}a @{ub}@{b}plugin@{ub}
        @{b}which @{ub}@{b}does @{ub}@{b}not @{ub}@{b}cleanly @{ub}@{b}work @{ub}@{b}with @{ub}@{b}older @{ub}@{b}Hollywood @{ub}@{b}versions @{ub}@{b}will @{ub}@{b}also@{ub}
        @{b}crash @{ub}@{b}all @{ub}@{b}executables @{ub}@{b}compiled @{ub}@{b}by @{ub}@{b}these @{ub}@{b}previous @{ub}@{b}Hollywood @{ub}@{b}versions@{ub}
        @{b}because @{ub}@{b}they @{ub}@{b}will @{ub}@{b}usually @{ub}@{b}also @{ub}@{b}scan @{ub}@{b}and @{ub}@{b}load @{ub}@{b}all @{ub}@{b}available @{ub}@{b}plugins @{ub}@{b}and@{ub}
        @{b}if @{ub}@{b}there @{ub}@{b}is @{ub}@{b}a @{ub}@{b}plugin @{ub}@{b}which @{ub}@{b}isn't @{ub}@{b}compatible @{ub}@{b}with @{ub}@{b}older @{ub}@{b}versions,@{ub}
        @{b}projects @{ub}@{b}compiled @{ub}@{b}with @{ub}@{b}older @{ub}@{b}Hollywood @{ub}@{b}versions @{ub}@{b}will @{ub}@{b}suddenly @{ub}@{b}crash@{ub}
        @{b}badly.@{ub}

        Additionally, InitPlugin() can also be called by Hollywood Designer. In
        that case you have to be careful as well, because Hollywood Designer
        supports only a subset of the official Hollywood plugin API so many
        function pointers inside "hwPluginBase" will be NULL and you cannot call
        them. That is why your InitPlugin() implementation also has to check
        whether it was called by Hollywood or by Hollywood Designer and act
        accordingly then. See @{"Designer compatibility" LINK DesignerCompatibility} for details.

        The third parameter contains the full path to the plugin's location on
        the user's hard drive. This may be useful information if you need to
        load files from the plugin's directory or store preferences files in the
        plugin's directory, etc.

        InitPlugin() has to return either TRUE or FALSE to signal success or
        failure. If it returns FALSE, @{"ClosePlugin()" LINK ClosePlugin} won't ever be called on this
        plugin.

   @{b}INPUTS@{ub}
        self      pointer to structure that your plugin has to fill out
        cl        pointer to Hollywood's plugin API functions or NULL (see
                  above)
        path      full path to the plugin's shared library file

   @{b}RESULTS@{ub}
        success   TRUE or FALSE indicating whether initialization was successful

@ENDNODE

@NODE ConvertScriptOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_CONVERT" set are called
    when Hollywood loads the file the user has passed to the program. The plugin
    can then examine the file and if it is in a format that the plugin
    recognizes, it can convert the file into a Hollywood script and return this
    script to Hollywood. Hollywood will then run the script it has received from
    the plugin instead of the file it was originally passed.

    This makes it possible to enable Hollywood to open custom file formats. The
    Malibu plugin, which makes Hollywood able to open Scala project files, uses
    "HWPLUG_CAPS_CONVERT" for this job for example.

    @{"FreeScript()                      " LINK FreeScript} Free converted script
    @{"GetScript()                       " LINK GetScript} Convert custom file to Hollywood script
@ENDNODE

@NODE FreeScript "Hollywood SDK"

   @{b}NAME@{ub}
        FreeScript -- free converted script (V5.0)

   @{b}SYNOPSIS@{ub}
        void FreeScript(STRPTR buf);

   @{b}FUNCTION@{ub}
        This function must free the script returned by @{"GetScript()" LINK GetScript}. Note that
        this is called before Hollywood actually runs your script so if your
        @{"GetScript()" LINK GetScript} implementation has created some temporary files that are
        required by the script, you must not free them in FreeScript() but in
        @{"ClosePlugin()" LINK ClosePlugin} which is called when Hollywood shuts down.

   @{b}INPUTS@{ub}
        buf       script buffer allocated by @{"GetScript()" LINK GetScript}

@ENDNODE

@NODE GetScript "Hollywood SDK"

   @{b}NAME@{ub}
        GetScript -- convert custom file to Hollywood script (V5.0)

   @{b}SYNOPSIS@{ub}
        STRPTR buf = GetScript(STRPTR file);

   @{b}FUNCTION@{ub}
        This function must examine the file that is passed to this function and
        if it is in a format that the plugin can handle, it must convert the
        file to a Hollywood script and return this script as a null-terminated
        string. Hollywood will then skip loading this file and it will run the
        script that it has received from GetScript() instead.

        If GetScript() does not want to handle the file it is passed, it must
        return NULL.

        For compatibility reasons, the returned script is expected to be in ISO
        8859-1 encoding. You can change this by including the magic phrase
        ::utf8 in the very first 5 bytes that your GetScript() implementation
        returns. In that case, Hollywood will assume UTF-8 encoding for your
        script.

   @{b}INPUTS@{ub}
        file      path to a file that the user wants Hollywood to run

   @{b}RESULTS@{ub}
        buf       null-terminated string containing a Hollywood script or NULL

@ENDNODE

@NODE DirAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_DIRADAPTER" set can hook
    into Hollywood's directory handler. Whenever Hollywood has to scan a
    directory, it will first ask all the plugins that have hooked themselves
    into Hollywood's directory handler if one of them wants to scan it instead.

    Please note that directory adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the
    directory adapter. The directory adapter will then only be activated if the
    user calls "\@REQUIRE" on your plugin. See @{"Auto and manual plugin" LINK AutoAndManualInit}
    @{"initialization" LINK AutoAndManualInit} for details. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on your
    directory adapter plugin, it will only be available if the user addresses it
    directly through the "Adapter" tag.

    See @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for information on how to add your directory
    adapter.

    This plugin type is supported since Hollywood 6.0.

    Starting with Hollywood 8.0 directory adapter plugins support the
    "HWEXT_DIRADAPTER_REWIND" extension. If this extension is set, a directory
    adapter declares itself capable of rewinding a directory handle. If you set
    the "HWEXT_DIRADAPTER_REWIND" extension bit, you need to implement the
    @{"RewindDir()" LINK RewindDir} function. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
    extension bits. Note that it is recommended for directory adapters to
    support the "HWEXT_DIRADAPTER_REWIND" extension because rewinding a
    directory is a core functionality which all directory adapters should
    support. Otherwise not all Hollywood functions will be available to the
    directory adapter.

    Starting with Hollywood 9.0 directory adapter plugins support the
    "HWEXT_DIRADAPTER_STAT" extension. If this extension is set, a directory
    adapter declares itself capable of obtaining additional information about
    open directories. If you set the "HWEXT_DIRADAPTER_STAT" extension bit, you
    need to implement the @{"StatDir()" LINK StatDir} function. See @{"Extension plugins" LINK ExtensionOverview} to learn how
    to use plugin extension bits. Note that it is recommended for directory
    adapters to support the "HWEXT_DIRADAPTER_STAT" extension because getting
    information like date, time, and DOS attributes is a core functionality
    which all directory adapters should support. Otherwise not all Hollywood
    functions will be available to the directory adapter.

    @{"CloseDir()                        " LINK CloseDir} Close a directory handle
    @{"NextDirEntry()                    " LINK NextDirEntry} Return next directory object
    @{"OpenDir()                         " LINK OpenDir} Open a directory
    @{"RewindDir()                       " LINK RewindDir} Rewind a directory
    @{"StatDir()                         " LINK StatDir} Obtain information about an open directory
@ENDNODE

@NODE CloseDir "Hollywood SDK"

   @{b}NAME@{ub}
        CloseDir -- close a directory handle (V6.0)

   @{b}SYNOPSIS@{ub}
        void CloseDir(APTR handle);

   @{b}FUNCTION@{ub}
        This function must close the specified directory handle allocated by
        @{"OpenDir()" LINK OpenDir}.

   @{b}INPUTS@{ub}
        handle    directory handle returned by @{"OpenDir()" LINK OpenDir}

@ENDNODE

@NODE NextDirEntry "Hollywood SDK"

   @{b}NAME@{ub}
        NextDirEntry -- return next directory object (V6.0)

   @{b}SYNOPSIS@{ub}
        int more = NextDirEntry(APTR handle, struct hwos_StatStruct *st,
                       struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to return the next file system object from the
        directory handle passed in parameter 1. File system objects can be
        returned in a random order. They do not need to be alphabetically
        sorted. NextDirEntry() needs to return TRUE if it has obtained a file
        system object from the directory or FALSE if all entries have been
        retrieved. If it returns TRUE, it has to write information about the
        file system object retrieved to the struct hwos_StatStruct pointer
        passed in parameter 2. struct hwos_StatStruct looks like this:

            struct hwos_StatStruct
            {
                int Type;                               // [out]
                DOSINT64 Size;                          // [out]
                ULONG Flags;                            // [out]
                struct hwos_DateStruct Time;            // [out]
                struct hwos_DateStruct LastAccessTime;  // [out]
                struct hwos_DateStruct CreationTime;    // [out]
                STRPTR FullPath;                        // [out]
                STRPTR Comment;                         // [out]
                int LinkMode;                           // [out]
                STRPTR Container;                       // [out]
            };

        Your NextDirEntry() implementation needs to write the following
        information to the individual structure members:

        Type:     This must be set to one of the following types:

                  HWSTATTYPE_FILE:
                            The file system object is a file.

                  HWSTATTYPE_DIRECTORY:
                            The file system object is a directory.

        Size:     Size of object in bytes if it is a file, 0 for directories.
                  Note that this can also be set to -1 in case the file size
                  isn't know, for example because the file is being streamed
                  from a network source.

        Flags:    Combination of flags describing the file system object
                  attributes. See @{"File attributes" LINK FileAttributes} for a list of supported
                  attributes.

        Time:     Time stamp indicating when this file system object was last
                  modified. This information is optional. Do not touch this
                  member if you don't have this time information.

        LastAccessTime:
                  Time stamp indicating when this file system object was last
                  accessed. This information is optional. Do not touch this
                  member if you don't have this time information.

        CreationTime:
                  Time stamp indicating when this file system object was
                  created. This information is optional. Do not touch this
                  member if you don't have this time information.

        FullPath: Name of the file system object. This must be provided. The
                  string pointer you use here must stay valid until the next
                  call to NextDirEntry(). Please note that in contrast to its
                  name, "FullPath" must not be set to a fully qualified path but
                  just to the name of the file system object without any path
                  components.

        Comment:  Comment stored for this object in the file system. Set this to
                  NULL if you do not have this information or the file system
                  doesn't support storage of comments. The string pointer you
                  pass here must stay valid until the next call to
                  NextDirEntry().

        LinkMode: Currently unused. Set to 0.

        Container:
                  Currently unused. Set to NULL.

   @{b}INPUTS@{ub}
        handle    directory handle returned by @{"OpenDir()" LINK OpenDir}
        st        pointer to a struct hwos_StatStruct for storing information
                  about the file system object
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        ok        TRUE if file system object has been retrieved, FALSE if there
                  are no more objects

@ENDNODE

@NODE OpenDir "Hollywood SDK"

   @{b}NAME@{ub}
        OpenDir -- open a directory (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = OpenDir(STRPTR name, int mode, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is called for every directory that Hollywood opens. Your
        OpenDir() implementation has to check whether your plugin wants to
        handle this directory or not. If your plugin wants to handle this
        directory, your OpenDir() implementation needs to open it and return a
        handle back to Hollywood. Otherwise OpenDir() must return NULL. The
        handle returned by this function is an opaque data type only your plugin
        knows about. Hollywood will pass this handle to you whenever it wants to
        get the next object from this directory.

        The "mode" argument is currently unused.

        The tag list that Hollywood may pass to OpenDir() can contain the
        following items:

        HWOPENDIRTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details. (V10.0)

        HWOPENDIRTAG_FORMAT:
                  This tag can be used to pass a directory format string back to
                  Hollywood. "pData" will point to a pointer to a string
                  pointer, i.e. STRPTR*. Your plugin can set "pData" to a
                  null-terminated string containing a format description of the
                  directory. Hollywood scripts will then be able to get this
                  format name by querying the #ATTRFORMAT attribute on
                  #DIRECTORY. Note that the string pointer you write to "pData"
                  must stay valid for as long as the directory is open. (V10.0)

   @{b}INPUTS@{ub}
        name      directory to open
        mode      reserved for future use (currently 0)
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        handle    handle to refer to this directory later or NULL if your plugin
                  doesn't want to handle this directory

@ENDNODE

@NODE RewindDir "Hollywood SDK"

   @{b}NAME@{ub}
        RewindDir -- rewind a directory handle (V8.0)

   @{b}SYNOPSIS@{ub}
        int ok = RewindDir(APTR handle);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DIRADAPTER_REWIND" extension bit has been set. See @{"Extension" LINK ExtensionOverview}
        @{"plugins" LINK ExtensionOverview} for details. In that case, Hollywood will call RewindDir() to
        rewind a directory scanning operation, i.e. after a call to RewindDir()
        the next call to @{"NextDirEntry()" LINK NextDirEntry} must return the first entry in the
        directory again because the directory has been rewound.

   @{b}INPUTS@{ub}
        handle    directory handle returned by @{"OpenDir()" LINK OpenDir}

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE StatDir "Hollywood SDK"

   @{b}NAME@{ub}
        StatDir -- obtain information about a directory (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = StatDir(APTR handle, ULONG flags, struct hwos_StatStruct *st,
                           struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DIRADAPTER_STAT" extension bit has been set. See @{"Extension" LINK ExtensionOverview}
        @{"plugins" LINK ExtensionOverview} for details. In that case, this function has to do the same as
        @{"Stat()" LINK Stat} but instead of a string describing a path to a file system object
        it has to be able to obtain information about a directory from its
        handle allocated by @{"OpenDir()" LINK OpenDir}. StatDir() needs to write the information
        about the directory to the structure pointer passed in parameter 3.
        struct hwos_StatStruct looks like this:

            struct hwos_StatStruct
            {
                int Type;                               // [out]
                DOSINT64 Size;                          // [out]
                ULONG Flags;                            // [out]
                struct hwos_DateStruct Time;            // [out]
                struct hwos_DateStruct LastAccessTime;  // [out]
                struct hwos_DateStruct CreationTime;    // [out]
                STRPTR FullPath;                        // [out]
                STRPTR Comment;                         // [out]
                int LinkMode;                           // [unused]
                STRPTR Container;                       // [unused]
            };

        Your StatDir() implementation needs to write the following information
        to the individual structure members:

        Type:     This must always be set to "HWSTATTYPE_DIRECTORY".

        Size:     This must be set to 0.

        Flags:    Combination of flags describing the file system object
                  attributes. See @{"File attributes" LINK FileAttributes} for a list of supported
                  attributes.

        Time:     Time stamp indicating when this file system object was last
                  modified. This information is optional. Do not touch this
                  member if you don't have this time information.

        LastAccessTime:
                  Time stamp indicating when this file system object was last
                  accessed. This information is optional. Do not touch this
                  member if you don't have this time information.

        CreationTime:
                  Time stamp indicating when this file system object was
                  created. This information is optional. Do not touch this
                  member if you don't have this time information.

        FullPath: Fully qualified path to the directory. This must be provided.
                  If the "HWSTATFLAGS_ALLOCSTRINGS" flag is not set, you can set
                  this to a static string buffer which must stay valid until the
                  next call to StatDir(). If "HWSTATFLAGS_ALLOCSTRINGS" has been
                  set, you need to allocate a string buffer using
                  @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        Comment:  Comment stored for this directory in the file system. Set this
                  to NULL if you do not have this information or the file system
                  doesn't support storage of comments. If the
                  "HWSTATFLAGS_ALLOCSTRINGS" flag is not set, you can set this
                  to a static string buffer which must stay valid until the next
                  call to StatDir(). If "HWSTATFLAGS_ALLOCSTRINGS" has been set,
                  you need to allocate a string buffer using @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        The following flags are supported by StatDir():

        HWSTATFLAGS_ALLOCSTRINGS:
                  If this flag is set, StatDir() must not use static string
                  buffers for the "FullPath" and "Comment" structure members but
                  allocate new private string buffers for them. Hollywood will
                  then call @{"hw_TrackedFree()" LINK hw_TrackedFree} on these buffers once it is done
                  with them. This flag is often set when StatDir() is used in a
                  multithreaded setup.

        StatDir() has to return TRUE on success or FALSE on failure.

        This function must be implemented in a thread-safe manner if the
        "HWSTATFLAGS_ALLOCSTRINGS" flag is set.

   @{b}INPUTS@{ub}
        handle    directory handle returned by @{"OpenDir()" LINK OpenDir}
        flags     additional flags (see above)
        st        pointer to a struct hwos_StatStruct for storing information
                  about the directory
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE DisplayAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_DISPLAYADAPTER" set can
    replace Hollywood's inbuilt display handler with a custom display handler.
    This is a very powerful feature and allows you to reroute Hollywood's
    complete graphics output and event handler through an entirely different
    toolkit or display driver, thus making it possible to use Hollywood scripts
    in completely new environments.

    Optionally, display adapters can also choose to override Hollywood's inbuilt
    bitmap handler with custom implementations and it is also possible to offer
    support for custom hardware bitmaps and double buffers from display
    adapters. This allows you to take full advantage of device dependent bitmaps
    for optimized drawing.

    If you're just starting out with display adapters, it is advised that you
    begin with a pretty basic display adapter first and then you may choose to
    add support for advanced features later. Functions like @{"BltBitMap()" LINK BltBitMap} can get
    quite complex if your display adapter supports all the advanced
    functionality that Hollywood makes available, so it might be a better idea
    to first implement a barebones display adapter that doesn't support video
    bitmaps or hardware double buffers but just reroutes all of Hollywood's
    graphics through a custom device. You can then use this implementation as a
    basis to add support for more advanced features.

    Also, be sure to benchmark raw performance of scripts with your display
    adapter and compare them to the performance of Hollywood's inbuilt display
    handler to see if your adapter needs optimizing. See @{"HandleEvents" LINK HandleEvents} for
    details.

    Please note that display adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the
    display adapter. The display adapter will then only be activated if the user
    calls "\@REQUIRE" on your plugin. Otherwise, Hollywood will use its default
    display handler. See @{"Auto and manual plugin initialization" LINK AutoAndManualInit} for details.

    You don't have to implement all functions offered by the display adapter
    API. Many functions are optional and only have to be implemented if you
    explicitly request their use in your call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
    However, it is mandatory that all functions defined by the display adapter
    API are declared so that Hollywood can import their symbols when it loads
    the plugin. Functions that are optional and that you don't enable via
    @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} can just be dummies then. Here is an overview of all
    display adapter APIs that are optional:

    Sleep()   Only used if activated by setting "HWSDAFLAGS_SLEEP".

    VWait()   Only used if activated by setting "HWSDAFLAGS_VWAIT".

    GetMonitorInfo()
              Only used if activated by setting "HWSDAFLAGS_MONITORINFO".

    FreeMonitorInfo()
              Only used if activated by setting "HWSDAFLAGS_MONITORINFO".

    GrabScreenPixels()
              Only used if activated by setting "HWSDAFLAGS_GRABSCREEN".

    FreeGrabScreenPixels()
              Only used if activated by setting "HWSDAFLAGS_GRABSCREEN".

    BeginDoubleBuffer()
              Only used if activated by setting "HWSDAFLAGS_DOUBLEBUFFER".

    EndDoubleBuffer()
              Only used if activated by setting "HWSDAFLAGS_DOUBLEBUFFER".

    Flip()    Only used if activated by setting "HWSDAFLAGS_DOUBLEBUFFER".

    Cls()     Only used if activated by setting "HWSDAFLAGS_DOUBLEBUFFER".

    AllocBitMap()
              Only used if activated by setting "HWSDAFLAGS_BITMAPADAPTER".

    FreeBitMap()
              Only used if activated by setting "HWSDAFLAGS_BITMAPADAPTER".

    LockBitMap()
              Only used if activated by setting "HWSDAFLAGS_BITMAPADAPTER".

    UnLockBitMap()
              Only used if activated by setting "HWSDAFLAGS_BITMAPADAPTER".

    GetBitMapAttr()
              Only used if activated by setting "HWSDAFLAGS_BITMAPADAPTER".

    AllocVideoBitMap()
              Only used if activated by setting "HWSDAFLAGS_VIDEOBITMAPADAPTER".

    FreeVideoBitMap()
              Only used if activated by setting "HWSDAFLAGS_VIDEOBITMAPADAPTER".

    ReadVideoPixels()
              Only used if activated by setting "HWSDAFLAGS_VIDEOBITMAPADAPTER".

    FreeVideoPixels()
              Only used if activated by setting "HWSDAFLAGS_VIDEOBITMAPADAPTER".

    DoVideoBitMapMethod()
              Only used if activated by setting "HWSDAFLAGS_VIDEOBITMAPADAPTER".

    AdapterMainLoop()
              Only used if you set the "HWEXT_DISPLAYADAPTER_MAINLOOP" extension
              flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension
              bits.

    SetPalette()
              Only used if you set the "HWEXT_DISPLAYADAPTER_PALETTE" extension
              flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension
              bits.

    SetMenuBar()
              Only used if you set the "HWEXT_DISPLAYADAPTER_MENUADAPTER"
              extension flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
              extension bits.

    SetMenuAttributes()
              Only used if you set the "HWEXT_DISPLAYADAPTER_MENUADAPTER"
              extension flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
              extension bits.

    GetMenuAttributes()
              Only used if you set the "HWEXT_DISPLAYADAPTER_MENUADAPTER"
              extension flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
              extension bits.

    SetTrayIcon()
              Only used if you set the "HWEXT_DISPLAYADAPTER_TRAYICON" extension
              flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension
              bits.

    OpenPopupMenu()
              Only used if you set the "HWEXT_DISPLAYADAPTER_POPUPMENU"
              extension flag. See @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin
              extension bits.

    See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for information on how to install your display
    adapter.

    This plugin type is supported since Hollywood 6.0.

    @{"ActivateDisplay()                 " LINK ActivateDisplay} Activate a display
    @{"AdapterMainLoop()                 " LINK AdapterMainLoop} Enter display adapter's main loop
    @{"AllocBitMap()                     " LINK AllocBitMap} Allocate a new software bitmap
    @{"AllocVideoBitMap()                " LINK AllocVideoBitMap} Allocate a video bitmap
    @{"BeginDoubleBuffer()               " LINK BeginDoubleBuffer} Start hardware double buffer mode for display
    @{"BltBitMap()                       " LINK BltBitMap} Copy pixels from source bitmap to destination
    @{"ChangeBufferSize()                " LINK ChangeBufferSize} Change size of back buffer
    @{"CloseDisplay()                    " LINK CloseDisplay} Close a display
    @{"Cls()                             " LINK Cls} Clear back buffer in hardware double buffer mode
    @{"CreatePointer()                   " LINK CreatePointer} Create a custom mouse pointer
    @{"DetermineBorderSizes()            " LINK DetermineBorderSizes} Obtain information about window border sizes
    @{"DoVideoBitMapMethod()             " LINK DoVideoBitMapMethod} Perform custom action on video bitmap
    @{"EndDoubleBuffer()                 " LINK EndDoubleBuffer} Stop hardware double buffer mode
    @{"Flip()                            " LINK Flip} Flip front and back buffers
    @{"ForceEventLoopIteration()         " LINK ForceEventLoopIteration} Wake up WaitEvents()
    @{"FreeBitMap()                      " LINK FreeBitMap} Free a software bitmap
    @{"FreeGrabScreenPixels()            " LINK FreeGrabScreenPixels} Free grabbed screen pixels
    @{"FreeMonitorInfo()                 " LINK FreeMonitorInfo} Free data allocated by GetMonitorInfo()
    @{"FreePointer()                     " LINK FreePointer} Free a custom mouse pointer
    @{"FreeVideoBitMap()                 " LINK FreeVideoBitMap} Free video bitmap
    @{"FreeVideoPixels()                 " LINK FreeVideoPixels} Free pixel array allocated by ReadVideoPixels()
    @{"GetBitMapAttr()                   " LINK GetBitMapAttr} Query software bitmap attribute
    @{"GetMenuAttributes()               " LINK GetMenuAttributes} Get menu item attributes
    @{"GetMonitorInfo()                  " LINK GetMonitorInfo} Get information about monitor hardware
    @{"GetMousePos()                     " LINK GetMousePos} Query mouse pointer position
    @{"GetQualifiers()                   " LINK GetQualifiers} Query current qualifier key state
    @{"GrabScreenPixels()                " LINK GrabScreenPixels} Grab pixels of display's host screen
    @{"HandleEvents()                    " LINK HandleEvents} Handle display events
    @{"Line()                            " LINK Line} Draw a line
    @{"LockBitMap()                      " LINK LockBitMap} Lock a software bitmap
    @{"MovePointer()                     " LINK MovePointer} Move the mouse pointer
    @{"OpenDisplay()                     " LINK OpenDisplay} Open a display
    @{"OpenPopupMenu()                   " LINK OpenPopupMenu} Open a popup menu
    @{"ReadVideoPixels()                 " LINK ReadVideoPixels} Get raw pixels from video bitmap
    @{"RectFill()                        " LINK RectFill} Fill rectangular pixel area with color
    @{"SetDisplayAttributes()            " LINK SetDisplayAttributes} Modify display attributes
    @{"SetDisplayTitle()                 " LINK SetDisplayTitle} Change display title
    @{"SetMenuAttributes()               " LINK SetMenuAttributes} Set menu item attributes
    @{"SetMenuBar()                      " LINK SetMenuBar} Set display's menu bar
    @{"SetPalette()                      " LINK SetPalette} Change display palette
    @{"SetPointer()                      " LINK SetPointer} Change mouse pointer
    @{"SetTrayIcon()                     " LINK SetTrayIcon} Change the tray icon
    @{"ShowHideDisplay()                 " LINK ShowHideDisplay} Show or hide the display
    @{"ShowHidePointer()                 " LINK ShowHidePointer} Show or hide the mouse pointer
    @{"SizeMoveDisplay()                 " LINK SizeMoveDisplay} Change display position and/or size
    @{"Sleep()                           " LINK Sleep} Sleep for a certain amount of time
    @{"UnLockBitMap()                    " LINK UnLockBitMap} Unlock a software bitmap
    @{"VWait()                           " LINK VWait} Wait for next vertical blank
    @{"WaitEvents()                      " LINK WaitEvents} Wait until events come in
    @{"WritePixel()                      " LINK WritePixel} Draw a single pixel
@ENDNODE

@NODE ActivateDisplay "Hollywood SDK"

   @{b}NAME@{ub}
        ActivateDisplay -- activate a display (V6.0)

   @{b}SYNOPSIS@{ub}
        void ActivateDisplay(APTR handle, ULONG flags);

   @{b}FUNCTION@{ub}
        This function must assign the focus to the specified display.
        Optionally, the following flags may be set:

        HWACTDISPFLAGS_TOFRONT:
                  If this flag is set, the display should also be brought to the
                  front.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        flags     additional options (see above)

@ENDNODE

@NODE AdapterMainLoop "Hollywood SDK"

   @{b}NAME@{ub}
        AdapterMainLoop -- enter display adapter's main loop (V6.1, optional)

   @{b}SYNOPSIS@{ub}
        int error = AdapterMainLoop(lua_State *L, int (*f)(APTR data), APTR data,
                          ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_MAINLOOP" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. In that case, it must start the display
        adapter's main loop and after that run the function that is passed in
        the second parameter forwarding the third parameter "data" to it.

        Normally, Hollywood doesn't explicitly ask display adapters to start
        their main loop since not all toolkits are main loop-based. Instead, by
        default, Hollywood repeatedly asks display adapters to wait for events
        by calling the @{"WaitEvents()" LINK WaitEvents} function and to handle events by calling the
        @{"HandleEvents()" LINK HandleEvents} function. Some toolkits, however, don't fit into this
        model very well because their API expects you to call a function which
        runs the main loop which in turn does all the event waiting and
        handling. If the toolkit your display adapter uses employs such a
        design, you can set the "HWEXT_DISPLAYADAPTER_MAINLOOP" extension bit to
        make Hollywood ask your plugin to start its main loop and call the
        function which hands back control to Hollywood after the main loop has
        been started.

        Note that even if "HWEXT_DISPLAYADAPTER_MAINLOOP" has been set,
        Hollywood will still call your display adapter's @{"WaitEvents()" LINK WaitEvents} and
        @{"HandleEvents()" LINK HandleEvents} functions but you don't have to do anything in
        @{"WaitEvents()" LINK WaitEvents} then. It can just be an empty function. However, in
        @{"HandleEvents()" LINK HandleEvents} you still have to call into the master server and run
        timer callbacks. See @{"HandleEvents" LINK HandleEvents} for details.

        Since this function starts the main loop of your display adapter, it is
        not expected to return until Hollywood should shut down, i.e. until the
        user has closed all displays managed by your display adapter.

   @{b}INPUTS@{ub}
        L         pointer to the "lua_State"
        f         function you have to call right after starting your main loop
        data      data you have to pass to the function passed in the second
                  parameter
        flags     reserved for future use (currently 0)
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE AllocBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        AllocBitMap -- allocate a new software bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        APTR handle = AllocBitMap(int type, int width, int height, ULONG flags,
                          struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to allocate a software bitmap of the specified type in
        the requested dimensions. The "type" parameter can be one of the
        following constants:

        HWBMTYPE_RGB:
                  Hollywood wants you to allocate a color bitmap.

        HWBMTYPE_ALPHA:
                  Hollywood wants you to allocate an 8-bit alpha channel bitmap.
                  Alpha channel bitmaps contain transparency information ranging
                  from 0 (pixel is transparent) to 255 (pixel is fully opaque)
                  for every pixel. Hollywood's software bitmaps always store
                  alpha channel information for color bitmaps in separate
                  bitmaps to be compatible with 15-bit and 16-bit screenmodes
                  which don't have enough room to store an 8-bit alpha channel
                  in a bitmap.

        HWBMTYPE_MASK:
                  Hollywood wants you to allocate a monochrome 1-bit mask
                  bitmap. Mask bitmaps are used to store information about pixel
                  transparency settings. In contrast to alpha channel bitmaps
                  only two different states are supported: Visible pixels (1) or
                  invisible pixels (0).

        HWBMTYPE_CLUT:
                  Hollywood wants you to allocate a CLUT bitmap. This can only
                  ever happen if you have set "HWSDAFLAGS_CLUTBITMAPADAPTER" in
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. In that case, you must allocate a
                  bitmap that can store 1 byte per pixel. Note that CLUT bitmaps
                  in Hollywood always use 1 byte per pixel, no matter if the bit
                  depth is 8 or less than that. (V9.0)

        The "flags" parameter can be a combination of the following flags:

        HWABMFLAGS_CLEAR:
                  If this flag is set, Hollywood wants you to clear the bitmap
                  after allocating. Clearing a bitmap means that all bits should
                  be set to 0.

        Hollywood also passes a taglist to this function. Your implementation
        has to handle the following tags:

        HWABMTAG_FRIENDBITMAP:
                  If "type" is "HWBMTYPE_MASK", the "pData" element of this tag
                  item can contain a pointer to a color bitmap that Hollywood
                  wants to use this mask for. The mask can then be allocated in
                  a way that allows efficient blitting.

        HWABMTAG_DATA:
                  If this tag is given, your AllocBitMap() implementation must
                  initialize the bitmap it has just allocated with the bits
                  provided in the "pData" member of this tag. If this tag is
                  set, Hollywood will also always pass the
                  "HWABMTAG_DATABYTESPERROW" to inform your implementation about
                  the byte length of a single row of the pixel array that has
                  been passed to this function in the "pData" member.
                  "HWABMTAG_DATA" is only used for types "HWBMTYPE_MASK" or
                  "HWBMTYPE_ALPHA".

        HWABMTAG_DATABYTESPERROW:
                  If "HWABMTAG_DATA" is set, this tag contains the byte width of
                  a single row in its "iData" member. To find out the total size
                  of the array passed to you in "HWABMTAG_DATA", multiply this
                  value with the height of the bitmap.

        See @{"Bitmap information" LINK BitmapInfo} for more information on Hollywood bitmaps.

        AllocBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_BITMAPADAPTER" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        type      desired bitmap type (see above)
        width     width of the bitmap in pixels
        height    height of the bitmap in pixels
        flags     allocation flags (see above)
        tags      taglist for additional options (see above)

   @{b}RESULTS@{ub}
        handle    handle to the bitmap or NULL in case of an error

@ENDNODE

@NODE AllocVideoBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        AllocVideoBitMap -- allocate a video bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        APTR handle = AllocVideoBitMap(int width, int height, ULONG flags,
                          struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must allocate a new video bitmap in the requested
        dimensions. Video bitmaps, also called hardware or device-dependent
        bitmaps (DDBs), are usually stored in GPU memory and can thus be drawn
        and transformed with hardware acceleration. Hollywood can only draw
        video bitmaps to the custom hardware double buffer implemented by your
        plugin. Thus, whenever you write a plugin that supports video bitmaps
        you will also have to implement a custom hardware double buffer and set
        the "HWSDAFLAGS_DOUBLEBUFFERADAPTER" flag accordingly. See @{"Bitmap" LINK BitmapInfo}
        @{"information" LINK BitmapInfo} for details.

        Hollywood will pass a taglist which contains further parameters for the
        operation to AllocVideoBitMap(). Your implementation must be able to
        deal with the following tags:

        HWAVBMTAG_DATA:
                  The "pData" member of this tag item will be set to an object
                  that should be used to initialize the video bitmap's pixels.
                  This tag will always be provided because there is no way to
                  set the video bitmap's pixel data at a later stage. That is
                  why the pixel data for the video bitmap is already provided by
                  Hollywood at allocation time. If the "HWAVBMFLAGS_BITMAPDATA"
                  flag is set, then "pData" will contain a handle to another
                  video bitmap. This means that the new video bitmap should copy
                  all pixels from this video bitmap handle. It is guaranteed
                  that the video bitmap handle provided here matches the size of
                  the new video bitmap that is to be allocated. If
                  "HWAVBMFLAGS_BITMAPDATA" is not set, then "pData" contains a
                  pointer to a 32-bit ARGB pixel array that contains the raw
                  pixels that should be used to initialize the new video bitmap.
                  This 32-bit ARGB array will always be of the size width *
                  height * 4. No row padding is applied to this buffer.

        HWAVBMTAG_SRCWIDTH:
                  If this tag is set and the "HWAVBMTAG_MATRIX2D" tag is not
                  passed, then the width value passed in parameter 1 is to be
                  interpreted as a scaled value while the width passed in this
                  tag's "iData" member contains the width of the source pixel
                  data that is passed in "HWAVBMTAG_DATA". This means that your
                  implementation has to scale the source pixel data provided in
                  "HWAVBMTAG_DATA" to the dimensions passed in parameters 1 and
                  2. It also has to take the scale mode into account that is
                  passed in "HWAVBMTAG_SCALEMODE". Hollywood uses this tag to
                  offer hardware-accelerated scaling of video bitmaps. Please
                  note that "HWAVBMTAG_SRCWIDTH" will only ever be passed to
                  AllocVideoBitMap() if your plugin has explicitly declared that
                  it supports video bitmap scaling by setting the
                  "HWVBMCAPS_SCALE" flag in "HWSDATAG_VIDEOBITMAPCAPS". If
                  "HWAVMTAG_SRCWIDTH" and "HWAVBMTAG_MATRIX2D" are both passed,
                  then you have to apply a transformation matrix to the source
                  pixel data. See the documentation of "HWAVBMTAG_MATRIX2D"
                  below for more information.

        HWAVBMTAG_SRCHEIGHT:
                  This is the height counterpart for "HWAVBMTAG_SRCWIDTH". See
                  above for a description on what this tag is used for.

        HWAVBMTAG_SCALEMODE:
                  If "HWAVBM_SRCWIDTH" and "HWAVBM_SRCHEIGHT" or
                  "HWAVBM_MATRIX2D" are set, this tag will also be provided to
                  tell you about the scale mode that Hollywood wants you to use.
                  Currently, only 0 and 1 are supported here. A value of 0 in
                  "iData" means that you should do hard scaling without any
                  interpolation whereas a value of 1 means that Hollywood wants
                  you to do use anti-alias interpolation. See above in the
                  description of "HWAVBM_SRCWIDTH" for more information.

        HWAVBMTAG_MATRIX2D:
                  If this tag is set, then Hollywood wants you to apply a
                  transformation to the source pixel data provided in
                  "HWAVBMTAG_DATA" and store the transformation's resulting
                  pixels in the new video bitmap that is to be allocated.
                  Hollywood has already calculated the dimensions for the new
                  video bitmap and passed them to this function in parameters 1
                  and 2. To get to know about the dimensions of the source pixel
                  data, you have to examine the tags "HWAVBMTAG_SRCWIDTH" and
                  "HWAVBM_SRCHEIGHT" which are always passed if
                  "HWAVBMTAG_MATRIX2D" is set. The "pData" member of this tag
                  item will be set to a pointer to a struct hwMatrix2D that
                  contains all parameters for the transformation. Note that your
                  implementation also has to take the scale mode that is passed
                  in "HWAVBMTAG_SCALEMODE" into account. Hollywood uses this tag
                  to offer hardware-accelerated transformation of video bitmaps.
                  Please note that "HWAVBMTAG_MATRIX2D" will only ever be passed
                  to AllocVideoBitMap() if your plugin has explicitly declared
                  that it supports video bitmap transformation by setting the
                  "HWVBMCAPS_TRANSFORM" flag in "HWSDATAG_VIDEOBITMAPCAPS".

        HWAVBMTAG_DISPLAY:
                  If you've set the "HWSDAFLAGS_TIEDVIDEOBITMAP" flag when
                  installing your display adapter using @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}
                  then this tag will always be provided and its "pData" member
                  will be set to a handle to the display that this video bitmap
                  should be allocated for. This will always be a handle returned
                  by your @{"OpenDisplay()" LINK OpenDisplay} implementation.

        In addition to the taglist items described above, Hollywood can also set
        the following flags and your plugin has to be prepared to handle them:

        HWAVBMFLAGS_BLEND:
                  If this flag is set, then the data provided in
                  "HWAVBMTAG_DATA" contains alpha channel transparency
                  information and your plugin is expected to do the alpha
                  blending with this data whenever it draws this bitmap. Note
                  that the alpha channel data is always non-premultiplied.

        HWAVBMFLAGS_BITMAPDATA:
                  If this flag is set, then the data provided in
                  "HWAVBMTAG_DATA" is a handle to another video bitmap which
                  Hollywood wants you to use as the pixel data source. If this
                  flag isn't set, then "HWAVBMTAG_DATA" contains a pointer to a
                  32-bit ARGB pixel array. See the documentation of
                  "HWAVBMTAG_DATA" above for more information.

        HWAVBMFLAGS_SMOOTH:
                  If the "SmoothScale" tag has been set to TRUE in Hollywood's
                  "\@BRUSH", "LoadBrush()", "CreateBrush()", or "CopyBrush()"
                  commands, this flag will be set. (V8.0)

        AllocVideoBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_VIDEOBITMAPADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        width     desired bitmap width in pixels
        height    desired bitmap height in pixels
        flags     allocation flags (see above)
        tags      taglist containing additional parameters (see above)

   @{b}RESULTS@{ub}
        handle    handle to the bitmap or NULL in case of an error

@ENDNODE

@NODE BeginDoubleBuffer "Hollywood SDK"

   @{b}NAME@{ub}
        BeginDoubleBuffer -- start hardware double buffer mode for display (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = BeginDoubleBuffer(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must put the specified display into hardware double
        buffering mode. If Hollywood is in hardware double buffering mode, all
        calls to functions that draw something to the display like @{"BltBitMap()" LINK BltBitMap}
        or @{"RectFill()" LINK RectFill} must draw to the back buffer instead. This back buffer
        must then be drawn to the display whenever Hollywood calls the @{"Flip()" LINK Flip}
        function of your plugin.

        Please note that this function will only be called if the Hollywood
        script explicitly requests a hardware double buffer, i.e. the user has
        to set the hardware parameter to TRUE when he calls Hollywood's
        BeginDoubleBuffer() function. If he doesn't do that, Hollywood will use
        its own software double buffering method and your plugin's
        BeginDoubleBuffer() function will never be called at all.

        BeginDoubleBuffer() is an optional API and must only be implemented if
        "HWSDAFLAGS_DOUBLEBUFFERADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE BltBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        BltBitMap -- copy pixels from source bitmap to destination (V6.0)

   @{b}SYNOPSIS@{ub}
        void BltBitMap(APTR bmap, APTR handle, struct hwBltBitMapCtrl *ctrl,
                 ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must copy pixels from a source bitmap to a destination
        which can be a display or another bitmap. The source bitmap can be a
        software bitmap allocated by Hollywood or your plugin or it can be a
        custom video bitmap allocated by your plugin's @{"AllocVideoBitMap()" LINK AllocVideoBitMap}
        function. BltBitMap() can be used in many different contexts so you need
        to pay close attention to implement it correctly. If you only need a
        barebones implementation that doesn't support offscreen rendering and
        video bitmaps, the implementation is really simple and straight-forward,
        though. See towards the end of the BltBitMap() documentation for
        information on what the most basic implementation of BltBitMap() has to
        look like.

        In parameter 3, Hollywood will pass a struct hwBltBitMapCtrl which looks
        like this:

            struct hwBltBitMapCtrl
            {
                int SrcX;                  // [in]
                int SrcY;                  // [in]
                int DstX;                  // [in]
                int DstY;                  // [in]
                int Width;                 // [in]
                int Height;                // [in]
                int ScaleWidth;            // [in]
                int ScaleHeight;           // [in]
                ULONG ScaleMode;           // [in]
                APTR Mask;                 // [in]
                APTR Alpha;                // [in]
                struct hwMatrix2D *Matrix; // [in, V8.0]
                double AnchorX;            // [in, V8.0]
                double AnchorY;            // [in, V8.0]
                int AlphaMod;              // [in, V8.0]
                ULONG *Palette;            // [in, V9.0]
                ULONG TransPen:            // [in, V9.0]
            };

        Here's a description of the individual structure members:

        SrcX:     Contains the x position in the source bitmap that marks the
                  start offset for the copy operation. This is relative to the
                  upper-left corner of the source bitmap.

        SrcY:     Contains the y position in the source bitmap that marks the
                  start offset for the copy operation. This is relative to the
                  upper-left corner of the source bitmap.

        DstX:     Contains the destination x position relative to the upper-left
                  corner.

        DstY:     Contains the destination y position relative to the upper-left
                  corner.

        Width:    Contains the number of columns to copy.

        Height:   Contains the number of rows to copy.

        ScaleWidth:
                  If you've passed the "HWSDAFLAGS_CUSTOMSCALING" flag in your
                  call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} then this will contain the
                  desired scale width when autoscaling mode is active. If you
                  haven't passed "HWSDAFLAGS_CUSTOMSCALING", Hollywood will take
                  care of scaling automatically and this member will always be
                  zero.

        ScaleHeight:
                  If you've passed the "HWSDAFLAGS_CUSTOMSCALING" flag in your
                  call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} then this will contain the
                  desired scale height when autoscaling mode is active. If you
                  haven't passed "HWSDAFLAGS_CUSTOMSCALING", Hollywood will take
                  care of scaling automatically and this member will always be
                  zero.

        ScaleMode:
                  If you've passed the "HWSDAFLAGS_CUSTOMSCALING" flag in your
                  call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} then this will contain the
                  desired scale mode when autoscaling mode is active. This can
                  be either 0 for brute force scaling or 1 for interpolated
                  scaling using pixel antialiasing.

        Mask:     Contains a pointer to mask bitmap or NULL if there is no mask.
                  This member is only used when drawing software bitmaps to
                  video bitmaps or hardware double buffers.

        Alpha:    Contains a pointer to an alpha channel bitmap or NULL if there
                  is no alpha channel. This member is only used when drawing
                  software bitmaps to video bitmaps or hardware double buffers.

        Matrix:   If you've set the "HWVBMCAPS_BLITTRANSFORM" capability in
                  "HWSDATAG_VIDEOBITMAPCAPS", this may be set to a struct
                  hwMatrix2D which means that your implementation has to apply
                  the specified transformation matrix when blitting. Your
                  transformed blit operation also has to take the anchor points
                  that are passed in "AnchorX" and "AnchorY" into account (see
                  below). Note that if "Matrix" is non-NULL, all coordinates
                  passed to your BltBitMap() implementation are non-clipped.
                  They will be set to the raw coordinates passed to Hollywood's
                  "DisplayBrush()" function. This is different to the case where
                  "Matrix" is NULL. In that case, all coordinates are clipped to
                  the current display's boundaries. (V8.0)

        AnchorX:  If the "Matrix" member is non-NULL, this will be set to the
                  horizontal anchor point of the transformation. This will
                  always be between 0 and 1. See "Matrix" for details. You only
                  need to handle "AnchorX" if you have set the
                  "HWVBMCAPS_BLITTRANSFORM" capability bit. (V8.0)

        AnchorY:  If the "Matrix" member is non-NULL, this will be set to the
                  vertical anchor point of the transformation. This will always
                  be between 0 and 1. See "Matrix" for details. You only need to
                  handle "AnchorY" if you have set the "HWVBMCAPS_BLITTRANSFORM"
                  capability bit. (V8.0)

        AlphaMod: If you've set the "HWVBMCAPS_BLITALPHAMOD" capability in
                  "HWSDATAG_VIDEOBITMAPCAPS", this may be set to an alpha value
                  that should be multiplied into the blitting operation. Your
                  BltBitMap() implementation has to modulate all pixels by this
                  alpha value when blitting. If you haven't set
                  "HWVBMCAPS_BLITALPHAMOD", you can ignore this structure
                  member. (V8.0)

        Palette:  If "HWBBFLAGS_SRCCLUTBITMAP" is set (see below), this field
                  will contain the palette for the CLUT bitmap passed to
                  BltBitMap(). The palette pens will be stored as normal RGB
                  colors in "Palette". Note that "HWBBFLAGS_SRCCLUTBITMAP" can
                  only ever be set if you have passed "HWSDAFLAGS_PALETTE" in
                  your @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} call. (V9.0)

        TransPen: If "HWBBFLAGS_SRCCLUTBITMAP" is set (see below), this field
                  can be set to a pen that shouldn't be drawn by your
                  BltBitMap() implementation. Note that the "TransPen" field
                  will normally be "HWPEN_NONE". It can only ever be set to a
                  transparent pen in case your plugin supports custom double
                  buffers. Also, "HWBBFLAGS_SRCCLUTBITMAP" can only ever be set
                  if you have passed "HWSDAFLAGS_PALETTE" in your
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} call. (V9.0)

        The way BltBitMap() should operate is defined by the "flags" parameter.
        The following flags are currently recognized:

        HWBBFLAGS_SRCVIDEOBITMAP:
                  The source bitmap passed in parameter 1 is a video bitmap
                  allocated by @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. If this flag isn't set, then
                  the source bitmap will be a software bitmap that has either
                  been allocated by Hollywood or by your plugin (if you've set
                  the "HWSDAFLAGS_BITMAPADAPTER" flag). Note that video bitmaps
                  can only be drawn to a hardware double buffer allocated by
                  your plugin or to another offscreen video bitmap. Thus, if
                  "HWBBFLAGS_SRCVIDEOBITMAP" is set you can be certain that
                  Hollywood is either currently in hardware double buffer mode,
                  i.e. it has previously called your plugin's
                  @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} function, or that the
                  "HWBBFLAGS_DESTVIDEOBITMAP" flag is set.

        HWBBFLAGS_DESTVIDEOBITMAP:
                  The destination handle passed in parameter 2 is a video bitmap
                  allocated by @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. This can only happen if
                  you've set the "HWVBMCAPS_OFFSCREENCOLOR" or
                  "HWVBMCAPS_OFFSCREENALPHA" capabilities in
                  "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen rendering to
                  video bitmaps. Otherwise, "HWBBFLAGS_DESTVIDEOBITMAP" will
                  never be set.

        HWBBFLAGS_DESTALPHAONLY:
                  This is only set in connection with
                  "HWBBFLAGS_DESTVIDEOBITMAP". If Hollywood wants you to draw to
                  the alpha channel of your video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}, it will indicate this by setting
                  "HWBBFLAGS_DESTALPHAONLY". If "HWBBFLAGS_DESTVIDEOBITMAP" is
                  set and "HWBBFLAGS_DESTALPHAONLY" isn't, you have to draw to
                  the color channels of the video bitmap instead. Note that
                  "HWBBFLAGS_DESTALPHAONLY" will only ever be set if you've set
                  the "HWVBMCAPS_OFFSCREENALPHA" capability flag in
                  "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen rendering to
                  video bitmap alphachannels.

        HWBBFLAGS_DESTBITMAP:
                  The destination handle passed in parameter 2 is a software
                  bitmap allocated by Hollywood or your plugin's @{"AllocBitMap()" LINK AllocBitMap}
                  function if you've set the "HWSDAFLAGS_BITMAPADAPTER" in your
                  call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. Note that
                  "HWBBFLAGS_DESTBITMAP" will only ever be set if you've passed
                  either "HWBMAHOOK_BLTBITMAP", "HWBMAHOOK_BLTMASKBITMAP",
                  "HWBMAHOOK_BLTALPHAHOOK" or "HWBMAHOOK_BLTCLUTHOOK" in
                  "HWSDAFLAGS_BITMAPHOOK". Otherwise, Hollywood will do the
                  rendering to the software bitmap on its own and you don't have
                  to care. "HWBBFLAGS_DESTBITMAP" will only ever be set if
                  you've explicitly requested that you want to do offscreen
                  drawing to software bitmaps on your own by setting the
                  appropriate bitmap hook flags.

        HWBBFLAGS_DONOTBLEND:
                  This flag indicates that BltBitMap() should not do any alpha
                  blending. Instead, it should just do a raw copy of the color
                  and alpha channel pixel data without any blending. This may
                  only ever be set if the source or destination bitmap is a
                  video bitmap allocated by your plugin, i.e.
                  "HWBBFLAGS_DONOTBLEND" may only be set if
                  "HWBBFLAGS_DESTVIDEOBITMAP" or "HWBBFLAGS_SRCVIDEOBITMAP" is
                  defined, too. It will never be set when dealing with software
                  bitmaps.

        HWBBFLAGS_IGNOREBKBUFFER:
                  If autoscaling is active and "HWSDAFLAGS_CUSTOMSCALING" hasn't
                  been set in your call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} this flag may
                  be set to indicate that the source bitmap doesn't match the
                  dimensions of your back buffer. Thus, if this flag is set you
                  must not draw into the back buffer first. Instead, you must
                  draw directly to your display. If "HWBBFLAGS_IGNOREBKBUFFER"
                  is set, the destination handle will always be a display handle
                  allocated by @{"OpenDisplay()" LINK OpenDisplay}. Since "HWBBFLAGS_IGNOREBKBUFFER"
                  is only used when Hollywood is in autoscale mode, it will
                  always refresh the whole display, i.e. "SrcX", "SrcY", "DstX",
                  and "DstY" will all be 0 and "Width" and "Height" will
                  correspond to the display's dimensions.

        HWBBFLAGS_SRCCLUTBITMAP:
                  If you have set "HWSDAFLAGS_PALETTE" in your call to
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}, Hollywood will set this flag whenever
                  it has passed a CLUT bitmap to you. You then need to draw the
                  CLUT bitmap using the palette and transparent pen passed in
                  the "Palette" and "TransPen" fields of struct hwBltBitMapCtrl
                  (see above). (V9.0)

        This may all sound quite complicated but in fact, the complexity of the
        BltBitMap() function can be greatly reduced if your plugin doesn't
        support offscreen drawing and video bitmaps. In that case, all your
        BltBitMap() implementation has to do is to grab the pixels from the
        source bitmap and draw them to the destination display. You won't have
        to support the "Mask" and "Alpha" members of the struct hwBltBitMapCtrl
        in that case either, because they will only ever be set if BltBitMap()
        is used to draw a software bitmap to a video bitmap or a hardware double
        buffer.

        To get the raw pixels of Hollywood bitmaps, you can use the
        @{"hw_LockBitMap()" LINK hw_LockBitMap} function. If you've installed your own bitmap and video
        bitmap adapters, you can also directly interpret the handle pointers
        that are passed to this function because you've allocated them. It's not
        necessary to use @{"hw_LockBitMap()" LINK hw_LockBitMap} on bitmaps that have been allocated by
        your plugin.

        A typical implementation of BltBitMap() should do the following whenever
        it has to draw directly to the display: It should first draw the pixels
        into a back buffer (unless "HWBBFLAGS_IGNOREBKBUFFER" is set or a
        hardware double buffer is used) and then it should draw the pixels from
        this back buffer to the display.

        This function doesn't have to do any clipping. Hollywood will perform
        clipping itself before calling BltBitMap().

        If your plugin supports hardware double buffering and Hollywood has put
        your display into hardware double buffering mode by calling your
        plugin's @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} function, this function must not draw
        anything to the display but only to the back buffer. Hollywood will call
        your plugin's @{"Flip()" LINK Flip} function when it wants you to draw the back buffer
        to the display.

        You might want to use the @{"hw_RawBltBitMap()" LINK hw_RawBltBitMap} function in your
        implementation to copy the pixels of bitmaps stored as raw pixel
        buffers. See @{"hw_RawBltBitMap" LINK hw_RawBltBitMap} for details.

   @{b}INPUTS@{ub}
        bmap      source bitmap
        handle    destination display or bitmap (depends on the flags that are
                  set, see above)
        ctrl      pointer to a struct hwBltBitMapCtrl containing parameters for
                  the blit
        flags     flags specifying how to copy the pixels (see above)
        tags      additional options (currently always NULL)

@ENDNODE

@NODE ChangeBufferSize "Hollywood SDK"

   @{b}NAME@{ub}
        ChangeBufferSize -- change size of back buffer (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = ChangeBufferSize(APTR handle, int width, int height,
                        ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function will usually be called by Hollywood when the display's
        size has changed. It tells you about the new size of Hollywood's
        internal back buffer and if your drawing mechanism is back buffer based
        as well, you need to adapt the size of your back buffer when Hollywood
        calls this function.

        Please note that the back buffer size is not necessarily the same as the
        window's physical dimensions. If autoscaling is active, back buffer size
        and the window's physical dimensions can be different.

        If you don't use a back buffer you won't have to do anything here. This
        is often the case for plugins which are designed to draw in hardware
        double buffer mode. In that case, an additional back buffer is not
        necessary and would only slow things down.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        width     new back buffer width
        height    new back buffer height
        flags     additional flags (currently 0)
        tags      taglist for additional options (currently always NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE CloseDisplay "Hollywood SDK"

   @{b}NAME@{ub}
        CloseDisplay -- close a display (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = CloseDisplay(APTR handle);

   @{b}FUNCTION@{ub}
        This function must close the specified display that has been opened by
        your plugin's @{"OpenDisplay()" LINK OpenDisplay} function. Hollywood will call CloseDisplay()
        when it is done with your display. After calling this function, there
        will be no more accesses to the display handle and you can safely free
        all resources associated with it.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE Cls "Hollywood SDK"

   @{b}NAME@{ub}
        Cls -- clear back buffer in hardware double buffer mode (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = Cls(APTR handle, ULONG color, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This must clear the back buffer of the hardware double buffer in the
        specified display with the color specified in the second parameter. The
        color is specified as a 24-bit RGB value.

        Cls() is an optional API and must only be implemented if
        "HWSDAFLAGS_DOUBLEBUFFERADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        color     color to use for clearing
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE CreatePointer "Hollywood SDK"

   @{b}NAME@{ub}
        CreatePointer -- create a custom mouse pointer (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = CreatePointer(ULONG *rgb, int hx, int hy, int *width,
                          int *height, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must create a mouse pointer that uses the custom imagery
        passed to this function. Hollywood passes the desired imagery for the
        custom mouse pointer as a 32-bit ARGB pixel array in the first
        parameter. Please note that transparency settings for the mouse pointer
        image are always provided as 8-bit alpha channel values in the 8 most
        significant bits. If your hardware doesn't support alpha channeled mouse
        pointers, you have to convert this information first.

        Additionally, Hollywood passes the desired hotspot for the mouse pointer
        to CreatePointer(). A mouse pointer's hotspot is a single pixel within
        the pointer imagery that is used to determine the mouse pointer's pixel
        position by the operating system. The hotspot is described as an offset
        in pixels that is relative to the upper-left corner of the mouse pointer
        image.

        The desired pixel dimensions for the new mouse pointer are passed as
        pointer values because your implementation of CreatePointer() is allowed
        to modify them in case there are some hardware restrictions for mouse
        pointer dimensions on your system. You have to return the actual pixel
        dimensions of the new mouse pointer in parameters 4 and 5.

        The last parameter is a pointer to a tag list. This is reserved for
        future use and is currently always NULL.

   @{b}INPUTS@{ub}
        rgb       pointer to a 32-bit ARGB pixel array containing the pointer
                  image
        hx        x offset of the pointer hotspot in pixels
        hy        y offset of the pointer hotspot in pixels
        width     pointer to an integer containing the pointer width in pixels;
                  you have to write the real pointer width in pixels to this
                  pointer on exit
        height    pointer to an integer containing the pointer height in pixels;
                  you have to write the real pointer height in pixels to this
                  pointer on exit
        tags      tag list containing additional parameters (see above)

   @{b}RESULTS@{ub}
        handle    handle to the custom pointer or NULL if CreatePointer() failed

@ENDNODE

@NODE DetermineBorderSizes "Hollywood SDK"

   @{b}NAME@{ub}
        DetermineBorderSizes -- obtain information about window border sizes (V6.0)

   @{b}SYNOPSIS@{ub}
        void DetermineBorderSizes(ULONG flags, int *left, int *right,
                 int *top, int *bottom);

   @{b}FUNCTION@{ub}
        Hollywood will call this function before @{"OpenDisplay()" LINK OpenDisplay} to determine the
        border sizes of the display your plugin is about to open. Hollywood
        needs this information prior to opening the display in order to align
        the display on its host screen or center it. You have to write the
        border size values in pixels to the integer pointers passed to this
        function.

        Additionally, Hollywood passes some flags to this function that tell you
        something about the display's style. "Flags" can be a combination of the
        following bits:

        HWDISPFLAGS_BORDERLESS:
                  Display should be opened without any border decoration.

        HWDISPFLAGS_SIZEABLE:
                  Display should be resizeable.

        HWDISPFLAGS_FIXED:
                  Display dragging should be disabled.

        HWDISPFLAGS_NOHIDE:
                  Display should not have a widget for minimizing.

        HWDISPFLAGS_NOCLOSE:
                  Display should not have a close widget.

   @{b}INPUTS@{ub}
        flags     flags describing the display facilities
        left      integer pointer to receive width of the left window border
        right     integer pointer to receive width of the right window border
        top       integer pointer to receive height of the top window border
        bottom    integer pointer to receive height of the bottom window border

@ENDNODE

@NODE DoVideoBitMapMethod "Hollywood SDK"

   @{b}NAME@{ub}
        DoVideoBitMapMethod -- perform custom action on video bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = DoVideoBitMapMethod(APTR handle, int method, APTR data);

   @{b}FUNCTION@{ub}
        This function is used to perform custom actions on a video bitmap. It
        accepts a "method" and a "data" parameter. The contents of the "data"
        parameter depend on the specified method.

        The following methods are currently recognized:

        HWVBMMTHD_SETBLEND:
                  Hollywood will call this method to toggle the blend flag of
                  the video bitmap. If the blend flag is set, this video bitmap
                  has to be drawn with alpha blending enabled. If the blend flag
                  isn't set, the video bitmap should be drawn without any alpha
                  blending. If "HWVBMMTHD_SETBLEND" is passed, the "data"
                  parameter will just be an "int" that is set to TRUE or FALSE
                  to enable or disable the blend flag.

        DoVideoBitMapMethod() is an optional API and must only be implemented if
        "HWSDAFLAGS_VIDEOBITMAPADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    handle to a bitmap allocated by @{"AllocVideoBitMap()" LINK AllocVideoBitMap}.
        method    method to execute (see above)
        data      method specific data

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE EndDoubleBuffer "Hollywood SDK"

   @{b}NAME@{ub}
        EndDoubleBuffer -- stop hardware double buffer mode (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = EndDoubleBuffer(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must stop hardware double buffer mode for the specified
        display.

        EndDoubleBuffer() is an optional API and must only be implemented if
        "HWSDAFLAGS_DOUBLEBUFFERADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE Flip "Hollywood SDK"

   @{b}NAME@{ub}
        Flip -- flip front and back buffers (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = Flip(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        When in hardware double buffer mode, this function must bring the
        display's back buffer into view and install the former front buffer as
        the new back buffer. See @{"BeginDoubleBuffer" LINK BeginDoubleBuffer} for details.

        The following tags may be passed in the second parameter:

        HWFLIPTAG_VSYNC:
                  If the "iData" element of this tag item is set to TRUE,
                  Hollywood wants you to synchronize buffer flips with the
                  vertical blank interrupt. If this is FALSE, Hollywood doesn't
                  want you to do any synchronization and your Flip()
                  implementation should exit immediately after flipping front
                  and back buffers.

        Flip() is an optional API and must only be implemented if
        "HWSDAFLAGS_DOUBLEBUFFERADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        tags      taglist for additional options (see above)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE ForceEventLoopIteration "Hollywood SDK"

   @{b}NAME@{ub}
        ForceEventLoopIteration -- wake up WaitEvents() (V6.0)

   @{b}SYNOPSIS@{ub}
        void ForceEventLoopIteration(struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must wake up your @{"WaitEvents()" LINK WaitEvents} implementation and make it
        return control to Hollywood. Hollywood will call
        ForceEventLoopIteration() from worker threads whenever it needs control
        back from your plugin.

        The tag list parameter is reserved for future use. It's currently always
        NULL.

        This function must be implemented in a thread-safe way.

   @{b}INPUTS@{ub}
        t         tag list containing additional parameters (currently always
                  NULL)

@ENDNODE

@NODE FreeBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        FreeBitMap -- free a software bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void FreeBitMap(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free bitmaps allocated by @{"AllocBitMap()" LINK AllocBitMap}.

        FreeBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_BITMAPADAPTER" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    bitmap handle returned by @{"AllocBitMap()" LINK AllocBitMap}

@ENDNODE

@NODE FreeGrabScreenPixels "Hollywood SDK"

   @{b}NAME@{ub}
        FreeGrabScreenPixels -- free grabbed screen pixels (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void FreeGrabScreenPixels(ULONG *pixels);

   @{b}FUNCTION@{ub}
        This function must free the pixel array allocated by @{"GrabScreenPixels()" LINK GrabScreenPixels}.

        FreeGrabScreenPixels() is an optional API and must only be implemented
        if "HWSDAFLAGS_GRABSCREEN" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        pixels    pixel array allocated by @{"GrabScreenPixels()" LINK GrabScreenPixels}

@ENDNODE

@NODE FreeMonitorInfo "Hollywood SDK"

   @{b}NAME@{ub}
        FreeMonitorInfo -- free data allocated by GetMonitorInfo() (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void FreeMonitorInfo(int what, APTR data);

   @{b}FUNCTION@{ub}
        This function must free the data allocated by @{"GetMonitorInfo()" LINK GetMonitorInfo}. You
        have to specify the type of the data in "what". See @{"GetMonitorInfo" LINK GetMonitorInfo} for a
        list of supported data types.

        FreeMonitorInfo() is an optional API and must only be implemented if
        "HWSDAFLAGS_MONITORINFO" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See
        @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        what      which data to free
        data      data allocated by @{"GetMonitorInfo()" LINK GetMonitorInfo}

@ENDNODE

@NODE FreePointer "Hollywood SDK"

   @{b}NAME@{ub}
        FreePointer -- free a custom mouse pointer (V6.0)

   @{b}SYNOPSIS@{ub}
        void FreePointer(APTR handle);

   @{b}FUNCTION@{ub}
        This function has to free a mouse pointer handle allocated by
        @{"CreatePointer()" LINK CreatePointer}. Hollywood will make sure that this function is only
        called if the custom mouse pointer is no longer attached to any display.

   @{b}INPUTS@{ub}
        handle    pointer handle returned by @{"CreatePointer()" LINK CreatePointer}

@ENDNODE

@NODE FreeVideoBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        FreeVideoBitMap -- free video bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void FreeVideoBitMap(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free the specified video bitmap that has been
        allocated using @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. See @{"AllocVideoBitMap" LINK AllocVideoBitMap} for details.

        FreeVideoBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_VIDEOBITMAPADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    handle to a bitmap allocated by @{"AllocVideoBitMap()" LINK AllocVideoBitMap}.

@ENDNODE

@NODE FreeVideoPixels "Hollywood SDK"

   @{b}NAME@{ub}
        FreeVideoPixels -- free pixel array allocated by ReadVideoPixels() (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void FreeVideoPixels(APTR pixels);

   @{b}FUNCTION@{ub}
        This function must free the pixel array allocated by @{"ReadVideoPixels()" LINK ReadVideoPixels}.
        See @{"ReadVideoPixels" LINK ReadVideoPixels} for details.

        FreeVideoPixels() is an optional API and must only be implemented if
        "HWSDAFLAGS_VIDEOBITMAPADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        pixels    pixel array allocated by @{"ReadVideoPixels()" LINK ReadVideoPixels}

@ENDNODE

@NODE GetBitMapAttr "Hollywood SDK"

   @{b}NAME@{ub}
        GetBitMapAttr -- query software bitmap attribute (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int val = GetBitMapAttr(APTR handle, int attr, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must return the requested information about the specified
        bitmap. The "attr" parameter will tell you which information you have to
        return. The following attributes are currently recognized:

        HWBMATTR_WIDTH:
                  Return the bitmap's width in pixels.

        HWBMATTR_HEIGHT:
                  Return the bitmap's height in pixels.

        HWBMATTR_BYTESPERROW:
                  Return the bitmap's bytes per row.

        GetBitMapAttr() is an optional API and must only be implemented if
        "HWSDAFLAGS_BITMAPADAPTER" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    bitmap handle allocated by @{"AllocBitMap()" LINK AllocBitMap}
        attr      which information should be queried
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        val       value of the requested attribute

@ENDNODE

@NODE GetMenuAttributes "Hollywood SDK"

   @{b}NAME@{ub}
        GetMenuAttributes -- get menu item attributes (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = GetMenuAttributes(APTR display, struct hwMenuTreeInfo *item,
                     ULONG *flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_MENUADAPTER" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, GetMenuAttributes()
        will be called by Hollywood to find out if the menu item specified by
        "item" is selected or disabled. You need to write the result to the
        "flags" pointer.

        The following menu item flags are recognized by GetMenuAttributes():

        HWMENUFLAGS_SELECTED:
                  Set this flag if the menu item is currently selected.

        HWMENUFLAGS_DISABLED:
                  Set this flag if the menu item is currently disabled.

        If the menu item is neither selected nor disabled, write 0 to "flags".

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        item      menu item to query
        flags     pointer that receives the return value
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        ok        return TRUE to indicate success, FALSE to indicate failure

@ENDNODE

@NODE GetMonitorInfo "Hollywood SDK"

   @{b}NAME@{ub}
        GetMonitorInfo -- get information about monitor hardware (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = GetMonitorInfo(int what, int monitor, APTR *data,
                        struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must query all available monitors and return information
        about their configuration and capabilities. Hollywood will use the
        "what" parameter to tell your implementation which information about the
        monitor hardware the program wants to have. "what" can be one of the
        following values:

        HWGMITYPE_MONITORS:
                  Hollywood wants to have information about all monitors
                  available to the system and their positions on the extended
                  desktop relative to the primary monitor. If "what" has been
                  set to "HWGMITYPE_MONITORS", your GetMonitorInfo()
                  implementation must allocate a list of all available monitors
                  as an array of struct hwMonitorInfo elements. The list must be
                  terminated by a last struct hwMonitorInfo element with all
                  structure members set to zero. Here is what struct
                  hwMonitorInfo looks like:

                      struct hwMonitorInfo
                      {
                          int X;        // [out]
                          int Y;        // [out]
                          int Width;    // [out]
                          int Height;   // [out]
                      };

                  Hollywood expects the following information in the individual
                  structure members:

                  X:        Must be set to the x position of this monitor on the
                            extended desktop.

                  Y:        Must be set to the y position of this monitor on the
                            extended desktop.

                  Width:    This monitor's width on the extended desktop.

                  Height:   This monitor's height on the extended desktop.

                  All values must be specified in pixels. The pointer to the
                  list of struct hwMonitorInfo elements must be written to the
                  "data" pointer that is passed to GetMonitorInfo() as parameter
                  3. Hollywood will call @{"FreeMonitorInfo()" LINK FreeMonitorInfo} to give you a chance
                  to free the list you've allocated.

                  The "monitor" parameter is ignored if "what" is
                  "HWGMITYPE_MONITORS".

        HWGMITYPE_VIDEOMODES:
                  Hollywood wants to know about all video modes that a specific
                  monitor supports. The number of the monitor to examine is
                  passed in the "monitor" parameter. Monitors are counted from 0
                  which describes the primary monitor. Your GetMonitorInfo()
                  implementation must allocate a list of all available video
                  modes for this monitor as an array of struct hwVideoModeInfo
                  elements. The list must be terminated by a last struct
                  hwVideoModeInfo element with all structure members set to
                  zero. Here is what struct hwVideoModeInfo looks like:

                      struct hwVideoModeInfo
                      {
                          int Width;    // [out]
                          int Height;   // [out]
                          int Depth;    // [out]
                      };

                  Hollywood expects the following information in the individual
                  structure members:

                  Width:    Width of video mode in pixels.

                  Height:   Height of video mode in pixels.

                  Depth:    Depth of video mode.

                  The pointer to the list of struct hwVideoModeInfo elements
                  must be written to the "data" pointer that is passed to
                  GetMonitorInfo() as parameter 3. Hollywood will call
                  @{"FreeMonitorInfo()" LINK FreeMonitorInfo} to give you a chance to free the list you've
                  allocated.

        GetMonitorInfo() is an optional API and must only be implemented if
        "HWSDAFLAGS_MONITORINFO" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See
        @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        what      which information to query (see above)
        monitor   monitor index to query
        data      pointer to store this function's return data
        tags      taglist containing additional parameters (currently always
                  NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE GetMousePos "Hollywood SDK"

   @{b}NAME@{ub}
        GetMousePos -- query mouse pointer position (V6.0)

   @{b}SYNOPSIS@{ub}
        void GetMousePos(APTR handle, int *mx, int *my);

   @{b}FUNCTION@{ub}
        This function must query the mouse pointer position for the specified
        window and write it to the pointers passed in parameters 2 and 3. The
        mouse position you return in this function must be relative to the
        upper-left corner of your display's client area.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        mx        pointer to write the mouse pointer's x position to
        my        pointer to write the mouse pointer's y position to

@ENDNODE

@NODE GetQualifiers "Hollywood SDK"

   @{b}NAME@{ub}
        GetQualifiers -- query current qualifier key state (V6.0)

   @{b}SYNOPSIS@{ub}
        ULONG state = GetQualifiers(APTR handle);

   @{b}FUNCTION@{ub}
        This function must query the state of all keyboard qualifiers for the
        specified display and return them to Hollywood. The following keyboard
        qualifiers are currently defined:

        HWKEY_QUAL_MASK:
                  This is an internal control bit and must always be set.

        HWKEY_QUAL_LSHIFT:
                  Left shift key is down.

        HWKEY_QUAL_RSHIFT:
                  Right shift key is down.

        HWKEY_QUAL_LALT:
                  Left alt key is down.

        HWKEY_QUAL_RALT:
                  Right alt key is down.

        HWKEY_QUAL_LCOMMAND:
                  Left command key is down.

        HWKEY_QUAL_RCOMMAND:
                  Right command key is down.

        HWKEY_QUAL_LCONTROL:
                  Left control key is down.

        HWKEY_QUAL_RCONTROL:
                  Right control key is down.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}

   @{b}RESULTS@{ub}
        state     bitmask containing all qualifier keys that are currently down;
                  do not forget to always set "HWKEY_QUAL_MASK"

@ENDNODE

@NODE GrabScreenPixels "Hollywood SDK"

   @{b}NAME@{ub}
        GrabScreenPixels -- grab pixels of display's host screen (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        ULONG *rgb = GrabScreenPixels(APTR handle, int x, int y, int width,
                         int height, ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must grab the pixels of the screen that is currently
        hosting the specified display and return them to Hollywood as a 32-bit
        RGB pixel array. The pixel array that is returned by this function must
        be exactly width * height * 4 bytes in size. No padding bytes are
        allowed.

        Hollywood will call your @{"FreeGrabScreenPixels()" LINK FreeGrabScreenPixels} function to free the
        pixel array allocated by this function.

        GrabScreenPixels() is an optional API and must only be implemented if
        "HWSDAFLAGS_GRABSCREEN" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See
        @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        x         x offset marking the start position of the grab operation
        y         y offset marking the start position of the grab operation
        width     grab width in pixels
        height    grab height in pixels
        flags     reserved for future use (currently 0)
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        rgb       32bit RGB array containing the grabbed pixels

@ENDNODE

@NODE HandleEvents "Hollywood SDK"

   @{b}NAME@{ub}
        HandleEvents -- handle display events (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = HandleEvents(lua_State *L, ULONG flags, struct hwTagList *t);

   @{b}FUNCTION@{ub}
        This function must handle all display events that have come in.
        Hollywood will call this function many times per second so that your
        application stays responsive. As this is called so very often, you may
        want to implement a throttle here so that you only poll for events 50
        times per second or so. Otherwise, HandleEvents() has the potential to
        slow down your script's execution significantly if polling for events is
        too expensive and you do not implement a throttle. Be sure to benchmark
        raw performance of scripts with your display adapter and compare them to
        the performance of Hollywood's inbuilt display handler to see if your
        adapter needs optimizing.

        The following flags may be passed in the second parameter:

        HWHEFLAGS_LINEHOOK:
                  This flag is set if HandleEvents() has been called from the
                  Lua line hook.

        HWHEFLAGS_MODAL:
                  If this flag is set, then HandleEvents() has been called from
                  a modal loop that Hollywood is currently running. A modal loop
                  is a temporary event loop set up by functions that block the
                  script execution until certain events happen, e.g.
                  "WaitLeftMouse()" or "InKeyStr()".

        HWHEFLAGS_CHECKEVENT:
                  This flag is set if HandleEvents() has been called as a result
                  of the script calling Hollywood's "CheckEvent()" command.

        HWHEFLAGS_WAITEVENT:
                  This flag is set if HandleEvents() has been called because
                  @{"WaitEvents()" LINK WaitEvents} has triggered.

        Your HandleEvents() function should always call @{"hw_MasterServer()" LINK hw_MasterServer} with
        the "HWMSFLAGS_DRAWVIDEOS" flag set so that Hollywood can update any
        videos that are currently playing. If you don't do that, video playback
        won't work correctly.

        The third parameter is a tag list which is currently always NULL. This
        might change in the future, though.

        HandleEvents() must return an error code or 0 for success. A special
        return value is "ERR_USERABORT". If your HandleEvents() returns
        "ERR_USERABORT", Hollywood will quit. Thus, it is suggested that you
        return "ERR_USERABORT" if the user has clicked your display's close
        widget, pressed the escape key, etc. Note that you should not return
        "ERR_USERABORT" in case the "HWDISPSATAG_USERCLOSE" attribute has been
        set to TRUE using @{"SetDisplayAttributes()" LINK SetDisplayAttributes}. See @{"SetDisplayAttributes" LINK SetDisplayAttributes} for
        details.

        Please note that this function must handle events on all displays that
        have currently been opened by @{"OpenDisplay()" LINK OpenDisplay}. Additionally, it could
        also happen that no display is open at all and your HandleEvents()
        function is called. Be prepared to deal with these cases.

        All standard window events like sizing a window, moving a window, key
        presses and mouse events, etc. should be forwarded to Hollywood using
        @{"hw_PostEventEx()" LINK hw_PostEventEx} so that Hollywood is able to notify any handlers that
        might listen to these events.

   @{b}INPUTS@{ub}
        L         pointer to the "lua_State"
        flags     combination of flags (see above)
        t         tag list containing additional parameters (see above)

   @{b}RESULTS@{ub}
        error     error code or 0 for success; returning "ERR_USERABORT" tells
                  Hollywood to quit

@ENDNODE

@NODE Line "Hollywood SDK"

   @{b}NAME@{ub}
        Line -- draw a line (V6.0)

   @{b}SYNOPSIS@{ub}
        void Line(APTR handle, int x1, int y1, int x2, int y2, ULONG color,
                 ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must draw a line between the two points passed to this
        function. The destination handle can be either a display or a bitmap.
        You have to look at "flags" parameter to find out how to interpret the
        handle that Hollywood has passed to your function. The following flags
        are currently recognized:

        HWLIFLAGS_DESTVIDEOBITMAP:
                  The handle passed is a video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. This can only happen if you've set the
                  "HWVBMCAPS_OFFSCREENCOLOR" or "HWVBMCAPS_OFFSCREENALPHA"
                  capabilities in "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen
                  rendering to video bitmaps. Otherwise,
                  "HWLIFLAGS_DESTVIDEOBITMAP" will never be set.

        HWLIFLAGS_DESTALPHAONLY:
                  This is only set in connection with
                  "HWLIFLAGS_DESTVIDEOBITMAP". If Hollywood wants you to draw to
                  the alpha channel of your video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}, it will indicate this by setting
                  "HWLIFLAGS_DESTALPHAONLY". If "HWLIFLAGS_DESTVIDEOBITMAP" is
                  set and "HWLIFLAGS_DESTALPHAONLY" isn't, you have to draw to
                  the color channels of the video bitmap instead. Note that
                  "HWLIFLAGS_DESTALPHAONLY" will only ever be set if you've set
                  the "HWVBMCAPS_OFFSCREENALPHA" capability flag in
                  "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen rendering to
                  video bitmap alphachannels. In that case, the "color"
                  parameter will contain just an 8-bit alpha transparency value
                  ranging from 0 to 255.

        HWLIFLAGS_DESTBITMAP:
                  The handle passed is a software bitmap allocated by Hollywood
                  or your plugin's @{"AllocBitMap()" LINK AllocBitMap} function if you've set the
                  "HWSDAFLAGS_BITMAPADAPTER" in your call to
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. Note that "HWLIFLAGS_DESTBITMAP" will
                  only ever be set if you've passed "HWBMAHOOK_WRITEPIXEL" in
                  "HWSDAFLAGS_BITMAPHOOK". Otherwise, Hollywood will do the
                  rendering to the software bitmap on its own and you don't have
                  to care. "HWLIFLAGS_DESTBITMAP" will only ever be set if
                  you've explicitly requested that you want to do offscreen
                  drawing to software bitmaps on your own by setting the
                  appropriate bitmap hook flags.

        If you've set the "HWSDAFLAGS_ALPHADRAW" flag when calling
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} to initialize your plugin, the color value passed
        in parameter 6 will contain an alpha value in its 8 most significant
        bits and your implementation is expected to draw to the destination with
        alpha blending enabled. If you haven't set "HWSDAFLAGS_ALPHADRAW", the
        color will be just a 24-bit RGB value. If the "HWLIFLAGS_DESTALPHAONLY"
        flag is set, the "color" parameter will contain just an 8-bit alpha
        transparency value ranging from 0 to 255.

        This function doesn't have to do any clipping. Hollywood will perform
        clipping itself before calling Line().

        If your display adapter doesn't support video bitmaps or hooks into
        Hollywood's bitmap handler, Line() only has to be able to draw to the
        display which should be quite simple and straight-forward to implement.

        If your plugin supports hardware double buffering and Hollywood has put
        your display into hardware double buffering mode by calling your
        plugin's @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} function, this function must not draw
        anything to the display but only to the back buffer. Hollywood will call
        your plugin's @{"Flip()" LINK Flip} function when it wants you to draw the back buffer
        to the display.

        You might want to use the @{"hw_RawLine()" LINK hw_RawLine} function in your implementation
        to draw lines to bitmaps stored as raw pixel buffers. See @{"hw_RawLine" LINK hw_RawLine} for
        details.

   @{b}INPUTS@{ub}
        handle    destination display or bitmap (depends on the flags that are
                  set, see above)
        x1        start x offset for the line
        y1        start y offset for the line
        x2        end x offset for the line
        y2        end y offset for the line
        color     desired line color
        flags     flags specifying further parameters
        tags      additional options (currently always NULL)

@ENDNODE

@NODE LockBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        LockBitMap -- lock a software bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        APTR lock = LockBitMap(APTR handle, ULONG flags, struct
                        hwos_LockBitMapStruct *bmlock, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must lock a bitmap to allow access to the bitmap's
        underlying pixel data. Hollywood will pass a pointer to a struct
        hwos_LockBitMapStruct to this function. Your implementation must then
        fill this structure with all necessary information. struct
        hwos_LockBitMapStruct looks like this:

            struct hwos_LockBitMapStruct
            {
                APTR Data;          // [out]
                int Modulo;         // [out]
                int PixelFormat;    // [out]
                int BytesPerPixel;  // [out]
                int Width;          // [out]
                int Height;         // [out]
            };

        Your LockBitMap() implementation has to write the following information
        to the individual structure members:

        Data:     Must be set to a pointer to the bitmap's actual pixel data.
                  The pointer must be valid until Hollywood calls @{"UnLockBitMap()" LINK UnLockBitMap}
                  on the handle that is returned by this function.

        Modulo:   Must be set to the bitmap's modulo width, i.e. the length of a
                  single row of pixels. For bitmaps of type "HWBMTYPE_RGB" this
                  value must be specified in pixels. For the other bitmap types,
                  this value must be specified in bytes.

        PixelFormat:
                  This must be set to the pixel format used by the raw pixel
                  array that you've set in "Data". See @{"Pixel format information" LINK PixelFormats}
                  for details.

        BytesPerPixel:
                  This must be set to how many bytes are needed for a single
                  pixel. Note that for CLUT bitmaps this must always be 1, even
                  if the actual bit depth is less than 8 bits.

        Width:    Must be set to the bitmap's width.

        Height:   Must be set to the bitmap's height.

        Hollywood will also pass a combination of flags to this function. The
        following flags are currently supported:

        HWLBMFLAGS_READONLY:
                  If this flag is set, Hollywood will only need read access to
                  the bitmap. It won't write to the pixel array you return in
                  the "Data" member of the struct hwos_LockBitMapStruct.

        LockBitMap() has to return a lock handle for this bitmap. This is an
        opaque datatype only known by your plugin. It's only used to unlock the
        bitmap again when Hollywood is finished with it. Hollywood will call
        @{"UnLockBitMap()" LINK UnLockBitMap} then, passing the handle which was returned by
        LockBitMap(). If this function fails to lock the bitmap, return NULL.

        This function will usually be called very often by Hollywood so your
        implementation should be efficient and should not have to copy the
        pixels to a new memory block first. Instead, it should be designed in a
        way that allows immediate access to the pixel data.

        LockBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_BITMAPADAPTER" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    bitmap handle allocated by @{"AllocBitMap()" LINK AllocBitMap}
        flags     flags for the lock operation (see above)
        bmlock    pointer to a struct hwos_LockBitMapStruct to be filled out by
                  this function
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        lock      bitmap lock or NULL in case there was an error

@ENDNODE

@NODE MovePointer "Hollywood SDK"

   @{b}NAME@{ub}
        MovePointer -- move the mouse pointer (V6.0)

   @{b}SYNOPSIS@{ub}
        void MovePointer(APTR handle, int x, int y);

   @{b}FUNCTION@{ub}
        This function must move the mouse pointer to the specified position. The
        position that is passed to this function is relative to the display's
        client area top-left corner.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        x         desired new x position for mouse pointer
        y         desired new y position for mouse pointer

@ENDNODE

@NODE OpenDisplay "Hollywood SDK"

   @{b}NAME@{ub}
        OpenDisplay -- open a display (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = OpenDisplay(STRPTR title, int x, int y, int width,
                          int height, ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to open a new display that is described by the
        parameters passed to this function. Hollywood will pass the position of
        the display on screen as well as its dimensions. All values are in
        pixels. Additionally, a flags bitfield and a tag list is passed to this
        function.

        Your implementation has to return a handle that is used to refer to this
        display later or NULL in case an error has occurred.

        The "flags" parameter can be a combination of the following individual
        flags:

        HWDISPFLAGS_BORDERLESS:
                  Window should be opened without any border decoration.

        HWDISPFLAGS_SIZEABLE:
                  Window should be resizeable. Note that this flag refers to
                  user resizability only. Even if this flag isn't set,
                  Hollywoood might still ask your window to resize by calling
                  the @{"SizeMoveDisplay()" LINK SizeMoveDisplay} function.

        HWDISPFLAGS_FIXED:
                  Window dragging should be disabled.

        HWDISPFLAGS_NOHIDE:
                  Window should not have a widget for minimizing.

        HWDISPFLAGS_NOCLOSE:
                  Window should not have a close widget.

        HWDISPFLAGS_AUTOSCALE:
                  This flag is set if the user has enabled auto scaling for this
                  window. If that is the case, the window's physical dimensions
                  won't necessarily match the dimensions of its back buffer.

        HWDISPFLAGS_LAYERSCALE:
                  This flag is set if the user has enabled layer scaling for
                  this window. Layer scaling uses a different technique than
                  auto scaling which means that the back buffer size will match
                  the window's physical size in case layer scaling is active.

        HWDISPFLAGS_LAYERS:
                  This flag is set if layers are enabled for this window.

        HWDISPFLAGS_DOUBLEBUFFER:
                  This flag is set if Hollywood will use double buffer drawing
                  for this window.

        HWDISPFLAGS_HARDWAREDB:
                  This flag is set if Hollywood is using a hardware double
                  buffer provided by the plugin for this window.

        HWDISPFLAGS_FULLSCREEN:
                  If this flag is set, the display should be opened in full
                  screen mode. You may choose to ignore the "x" and "y"
                  parameters in that case.

        HWDISPFLAGS_DISABLEBLANKER:
                  If this flag is set, the screen blanker should be disabled
                  while this display is opened.

        HWDISPFLAGS_ALWAYSONTOP:
                  If this flag is set, the display should always stay on top of
                  other windows. (V7.1)

        HWDISPFLAGS_SCALEFACTOR:
                  If this flag is set, the display has scale factor mode
                  enabled. You can get the scale factor by querying
                  "HWDISPATTR_SCALEFACTOR" using @{"hw_GetDisplayAttr()" LINK hw_GetDisplayAttr}. Note that
                  an enabled scale factor mode doesn't necessarily mean that the
                  scale factor is different from 1.0. Scale factor mode can be
                  enabled and the scale factor can still be 1.0 in which case
                  your display should behave as if no scale factor mode was
                  active. (V9.0)

        HWDISPFLAG_TRAPRMB:
                  If this flag is set, the user has set the "TrapRMB" option to
                  TRUE. (V9.0)

        HWDISPFLAG_KEEPPROPORTIONS:
                  If this flag is set, the user has set the "KeepProportions"
                  option to TRUE. (V9.0)

        Additionally, Hollywood will pass a tag list to OpenDisplay(). This tag
        list can contain the following tags:

        HWDISPTAG_BUFFERWIDTH:
                  This tag is always provided and contains the pixel width of
                  Hollywood's back buffer for this display. Please note that
                  this is not necessarily the same as the window's physical
                  dimensions. If autoscaling is active, back buffer size and the
                  window's physical dimensions can be different. It is suggested
                  that you allocate a pixel buffer of this size and first draw
                  everything into this back buffer. After that you refresh the
                  display using the graphics you have drawn into the back
                  buffer. For optimized drawing you should implement a custom
                  double buffer using "HWPLUG_CAPS_DOUBLEBUFFER". Custom double
                  buffers don't have to draw into the back buffer first because
                  double buffer frames are usually updated multiple times per
                  second so there's no need to cache an additional back buffer
                  for refreshing the window when parts of it have to be redrawn.

        HWDISPTAG_BUFFERHEIGHT:
                  This tag is always provided and contains the pixel height of
                  Hollywood's back buffer for this display. See above for
                  details.

        HWDISPTAG_OPTIMIZEDREFRESH:
                  This tag is always provided and it is set to a pointer to a
                  "ULONG". Your plugin can write TRUE to this pointer if it
                  wants Hollywood to enable optimized refresh for this display.
                  Optimized refresh should be enabled on systems where it's more
                  efficient to refresh the complete display instead of several
                  smaller parts. By default, Hollywood prefers to refresh just
                  the parts of the display that actually need refreshing. On
                  some backends, however, this is quite slow if several smaller
                  parts have to be updated. It is often faster to refresh the
                  complete display on these systems. This is especially true for
                  backends that are double buffer based because refreshing a
                  single tile on double buffer based backends means doing a
                  complete buffer flip which doesn't look so nice and is quite
                  slow. That's why it is wise to enable this option on some
                  systems. By default, optimized refresh is disabled.

        HWDISPTAG_SINGLEREFRESHFX:
                  This tag is always provided and it is set to a pointer to a
                  "ULONG". Your plugin can write TRUE to this pointer if it
                  wants Hollywood to enable single refresh transition effect
                  drawing for this display. This option is related to the
                  "HWDISPTAG_OPTIMIZEDREFRESH" tag (see above). If you set the
                  pointer that you are passed here to TRUE, Hollywood will draw
                  one transition effect frame in exactly one video frame. If it
                  is set to FALSE (which is also the default), Hollywood might
                  emit more than one video frame for a single transition effect
                  frame. This is especially so for transition effect frames that
                  consist of many small parts that need to be updated. If
                  "HWDISPTAG_SINGLEREFRESHFX" is not set to TRUE, Hollywood will
                  prefer to draw many small parts instead of the complete frame
                  all at once. On some systems, however, drawing many small bits
                  totally kills the performance. In that case you need to set
                  this tag to TRUE. See above in "HWDISPTAG_OPTIMIZEDREFRESH"
                  for additional information.

        HWDISPTAG_LUASTATE:
                  This tag is always provided and contains a pointer to the
                  "lua_State".

        HWDISPTAG_MONITOR:
                  This tag is always provided and specifies the monitor that
                  this display should be opened on. Monitors are counted from 0
                  which specifies the primary monitor.

        HWDISPTAG_SCREENWIDTH:
                  If "HWDISPFLAGS_FULLSCREEN" has been set, this tag contains
                  the desired pixel width for the full screen mode. This is not
                  necessarily the same as the display width since the user might
                  explicitly choose a full screen resolution that is larger than
                  the display, e.g. an 800x600 screen mode for a 640x480
                  display.

        HWDISPTAG_SCREENHEIGHT:
                  Contains the desired pixel screen height if
                  "HWDISPFLAGS_FULLSCREEN" has been set. See above for details.

        HWDISPTAG_SCREENDEPTH:
                  Contains the desired screen depth if "HWDISPFLAGS_FULLSCREEN"
                  has been set. On most systems you may choose to ignore this
                  since most modern systems all operate in 32-bit true colour
                  mode.

        HWDISPTAG_SCALEWIDTH:
                  If "HWDISPFLAGS_AUTOSCALE" or "HWDISPFLAGS_LAYERSCALE" is
                  active, this tag contains the current scale width.

        HWDISPTAG_SCALEHEIGHT:
                  If "HWDISPFLAGS_AUTOSCALE" or "HWDISPFLAGS_LAYERSCALE" is
                  active, this tag contains the current scale height.

        HWDISPTAG_SCALEMODE:
                  If "HWDISPFLAGS_AUTOSCALE" or "HWDISPFLAGS_LAYERSCALE" is
                  active, this tag contains the current scale mode. Currently,
                  only 0 and 1 are defined here. 0 means hard scaling with no
                  interpolation whereas 1 means anti-alias interpolated scaling.

        HWDISPTAG_DEPTH:
                  Contains the desired pixel depth for the display. This is
                  mostly interesting in palette modes. (V9.0)

        HWDISPTAG_PALETTE:
                  If the display is a palette mode display, the "pData" member
                  of this tag will be set to a "ULONG" array containing the
                  display's palette. The individual colors will be stored as RGB
                  values in the palette array. (V9.0)

        HWDISPTAG_PALETTEMODE:
                  If the display is a palette mode display, the "pData" member
                  of this tag will be set to a pointer to an "int". Your display
                  adapter can write the value TRUE to this "int" to signal that
                  it supports genuine palette mode. A genuine palette mode is a
                  screen mode which is palette-based so that changing a single
                  pen will automatically change all pixels that use that pen. A
                  genuine palette display allows Hollywood to use several
                  optimizations because screen pixels can be changed by just
                  changing color registers, i.e. without copying any actual
                  pixel data. If you enable genuine palette mode, you must also
                  set "HWSDAFLAGS_PALETTE" and one or both of
                  "HWSDAFLAGS_PENDRAW" and "HWSDAFLAGS_SETPALETTE" using
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.
                  (V9.0)

        HWDISPTAG_MENU:
                  If a menu bar should be attached to this display, Hollywood
                  will set the "pData" member of this tag to a struct
                  hwMenuTreeInfo pointer which contains all nodes and leaves of
                  the menu bar. See @{"SetMenuBar" LINK SetMenuBar} for a description of this
                  structure. Whenever the user selects a menu item, you need to
                  post an "HWEVT_MENUITEM" event to Hollywood's event queue. See
                  @{"hw_PostEvent" LINK hw_PostEvent} for details. Note that this tag will only ever be
                  set if your display adapter has signalled that it supports
                  menus by setting the "HWSDAFLAGS_MENUADAPTER" when calling
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.
                  (V9.0)

        HWDISPTAG_XPOSITION:
                  The "pData" member of this tag is set to a pointer to an "int"
                  that contains the display's x position. This is identical to
                  the x position passed to your OpenDisplay() implementation.
                  However, if your implementation decides to open the display at
                  a position different to the requested one, you should write
                  the actual x position of your display to the "int" pointer
                  passed in the "pData" member of the tag so that Hollywood can
                  get to know the display's real x position. (V9.1)

        HWDISPTAG_YPOSITION:
                  The "pData" member of this tag is set to a pointer to an "int"
                  that contains the display's y position. This is identical to
                  the y position passed to your OpenDisplay() implementation.
                  However, if your implementation decides to open the display at
                  a position different to the requested one, you should write
                  the actual y position of your display to the "int" pointer
                  passed in the "pData" member of the tag so that Hollywood can
                  get to know the display's real y position. (V9.1)

        HWDISPTAG_FLAGS:
                  The "pData" member of this tag is set to a pointer to a
                  "ULONG" that contains the display flags. This is identical to
                  the display flags passed to your OpenDisplay() implementation.
                  However, if your implementation decides to modify the
                  requested display flags in any way (e.g. adding or removing
                  flags), you should write the actual display flags to the
                  "ULONG" pointer passed in the "pData" member of the tag so
                  that Hollywood can get to know the display's real flags.
                  (V9.1)

        HWDISPTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details. (V10.0)

        Please note that Hollywood supports multiple displays so OpenDisplay()
        can be called several times. Hollywood also supports multiple full
        screen displays if they are to appear on different monitors. Be prepared
        to deal with these cases.

   @{b}INPUTS@{ub}
        title     caption string for the display's window border
        x         desired x position of this display in pixels
        y         desired y position of this display in pixels
        width     desired width for this display in pixels
        height    desired height for this display in pixels
        flags     flags describing additional options (see above)
        tags      tag list describing additional options (see above)

   @{b}RESULTS@{ub}
        handle    a handle to the newly allocated display or NULL in case of an
                  error

@ENDNODE

@NODE OpenPopupMenu "Hollywood SDK"

   @{b}NAME@{ub}
        OpenPopupMenu -- open popup menu (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = OpenPopupMenu(APTR display, struct hwMenuTreeInfo *menu, int x,
                     int y, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_POPUPMENU" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, OpenPopupMenu() will
        be called if Hollywood wants your display adapter to show a popup menu.
        Hollywood will pass a struct hwMenuTreeInfo pointer in "menu" which
        contains all nodes and leaves of the menu bar. See @{"SetMenuBar" LINK SetMenuBar} for a
        description of this structure. Whenever the user selects a menu item,
        you need to post an "HWEVT_MENUITEM" event to Hollywood's event queue.
        See @{"hw_PostEvent" LINK hw_PostEvent} for details.

        The "x" and "y" parameters will contain the desired position for the
        popup menu on the screen or "CO_UNSPECIFIED" if the popup menu should
        appear under the mouse pointer. Note that all coordinates are relative
        to the screen's origin, not the display's origin.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        menu      menu strip to show
        x         x position for the popup menu
        y         y position for the popup menu
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        ok        return TRUE to indicate success, FALSE to indicate failure

@ENDNODE

@NODE ReadVideoPixels "Hollywood SDK"

   @{b}NAME@{ub}
        ReadVideoPixels -- get raw pixels from video bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        APTR rgb = ReadVideoPixels(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must return the raw pixels of the specified video bitmap.
        This is often very slow because it has to read from GPU memory. That's
        why Hollywood calls this function only under very special circumstances.
        This function has to return a pixel buffer that is exactly of the size
        width * height * bytes_per_pixel. No line padding may be involved.

        Additionally, your implementation has to handle the following taglist:

        HWRVPTAG_BLEND:
                  The "pData" member of this tag item will be set to a pointer
                  to an "int". Your implementation has to set this pointer to
                  either TRUE or FALSE, depending on whether the returned video
                  pixels contain alpha channel transparency information or not.

        HWRVPTAG_PIXELFORMAT:
                  The "pData" member of this tag item will be set to a pointer
                  to an "int". Your implementation has to set this pointer to
                  the pixel format the returned data is in. See @{"Pixel formats" LINK PixelFormats}
                  for details.

        When Hollywood is done with the data returned by this function, it will
        call @{"FreeVideoPixels()" LINK FreeVideoPixels} on it.

        ReadVideoPixels() is an optional API and must only be implemented if
        "HWSDAFLAGS_VIDEOBITMAPADAPTER" has been passed to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    handle to a bitmap allocated by @{"AllocVideoBitMap()" LINK AllocVideoBitMap}.
        tags      taglist containing additional parameters (see above)

   @{b}RESULTS@{ub}
        rgb       array containing raw pixel data or NULL in case of an error

@ENDNODE

@NODE RectFill "Hollywood SDK"

   @{b}NAME@{ub}
        RectFill -- fill rectangular pixel area with color (V6.0)

   @{b}SYNOPSIS@{ub}
        void RectFill(APTR handle, int x, int y, int width, int height,
                 ULONG color, ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must fill the specified rectangular area with the color
        passed in parameter 6. The destination handle can be either a display or
        a bitmap. You have to look at "flags" parameter to find out how to
        interpret the handle that Hollywood has passed to your function. The
        following flags are currently recognized:

        HWRFFLAGS_DESTVIDEOBITMAP:
                  The handle passed is a video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. This can only happen if you've set the
                  "HWVBMCAPS_OFFSCREENCOLOR" or "HWVBMCAPS_OFFSCREENALPHA"
                  capabilities in "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen
                  rendering to video bitmaps. Otherwise,
                  "HWRFFLAGS_DESTVIDEOBITMAP" will never be set.

        HWRFFLAGS_DESTALPHAONLY:
                  This is only set in connection with
                  "HWRFFLAGS_DESTVIDEOBITMAP". If Hollywood wants you to draw to
                  the alpha channel of your video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}, it will indicate this by setting
                  "HWRFFLAGS_DESTALPHAONLY". If "HWRFFLAGS_DESTVIDEOBITMAP" is
                  set and "HWRFFLAGS_DESTALPHAONLY" isn't, you have to draw to
                  the color channels of the video bitmap instead. Note that
                  "HWRFFLAGS_DESTALPHAONLY" will only ever be set if you've set
                  the "HWVBMCAPS_OFFSCREENALPHA" capability flag in
                  "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen rendering to
                  video bitmap alphachannels. In that case, the "color"
                  parameter will contain just an 8-bit alpha transparency value
                  ranging from 0 to 255.

        HWRFFLAGS_DESTBITMAP:
                  The handle passed is a software bitmap allocated by Hollywood
                  or your plugin's @{"AllocBitMap()" LINK AllocBitMap} function if you've set the
                  "HWSDAFLAGS_BITMAPADAPTER" in your call to
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. Note that "HWRFFLAGS_DESTBITMAP" will
                  only ever be set if you've passed "HWBMAHOOK_RECTFILL" in
                  "HWSDAFLAGS_BITMAPHOOK". Otherwise, Hollywood will do the
                  rendering to the software bitmap on its own and you don't have
                  to care. "HWRFFLAGS_DESTBITMAP" will only ever be set if
                  you've explicitly requested that you want to do offscreen
                  drawing to software bitmaps on your own by setting the
                  appropriate bitmap hook flags.

        If you've set the "HWSDAFLAGS_ALPHADRAW" flag when calling
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} to initialize your plugin, the color value passed
        in parameter 6 will contain an alpha value in its 8 most significant
        bits and your implementation is expected to draw to the destination with
        alpha blending enabled. If you haven't set "HWSDAFLAGS_ALPHADRAW", the
        color will be just a 24-bit RGB value. If the "HWRFFLAGS_DESTALPHAONLY"
        flag is set, the "color" parameter will contain just an 8-bit alpha
        transparency value ranging from 0 to 255.

        This function doesn't have to do any clipping. Hollywood will perform
        clipping itself before calling RectFill().

        If your display adapter doesn't support video bitmaps or hooks into
        Hollywood's bitmap handler, RectFill() only has to be able to draw to
        the display which should be quite simple and straight-forward to
        implement.

        If your plugin supports hardware double buffering and Hollywood has put
        your display into hardware double buffering mode by calling your
        plugin's @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} function, this function must not draw
        anything to the display but only to the back buffer. Hollywood will call
        your plugin's @{"Flip()" LINK Flip} function when it wants you to draw the back buffer
        to the display.

        You might want to use the @{"hw_RawRectFill()" LINK hw_RawRectFill} function in your
        implementation to draw rectangles to bitmaps stored as raw pixel
        buffers. See @{"hw_RawRectFill" LINK hw_RawRectFill} for details.

   @{b}INPUTS@{ub}
        handle    destination display or bitmap (depends on the flags that are
                  set, see above)
        x         x offset of the rectangle to fill
        y         y offset of the rectangle to fill
        width     width in pixels of the area to fill
        height    height in pixels of the area to fill
        color     filling color
        flags     flags specifying further parameters
        tags      additional options (currently always NULL)

@ENDNODE

@NODE SetDisplayAttributes "Hollywood SDK"

   @{b}NAME@{ub}
        SetDisplayAttributes -- modify display attributes (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = SetDisplayAttributes(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is used by Hollywood to change certain attributes of your
        display. Hollywood will pass a tag list to this function. The following
        tags are currently defined:

        HWDISPSATAG_USERCLOSE:
                  If "iData" is set to TRUE here, then you must not shut down
                  Hollywood when the user clicks on your display's close widget,
                  i.e. your @{"HandleEvents()" LINK HandleEvents} implementation should not return
                  "ERR_USERABORT" in that case. Instead, you should just post an
                  "HWEVT_CLOSEDISPLAY" event and leave everything else to
                  Hollywood. This attribute is often set to TRUE in case the
                  user listens to "CloseWindow" events using
                  "InstallEventHandler()" to perform some custom action when the
                  window's close widget is pressed.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        t         tag list containing additional attributes (see above)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE SetDisplayTitle "Hollywood SDK"

   @{b}NAME@{ub}
        SetDisplayTitle -- change display title (V6.0)

   @{b}SYNOPSIS@{ub}
        void SetDisplayTitle(APTR handle, STRPTR title);

   @{b}FUNCTION@{ub}
        This function must change the display's window caption to the specified
        string.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        title     new caption for the display

@ENDNODE

@NODE SetMenuAttributes "Hollywood SDK"

   @{b}NAME@{ub}
        SetMenuAttributes -- change menu item attributes (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = SetMenuAttributes(APTR display, struct hwMenuTreeInfo *item,
                     ULONG setflags, ULONG clrflags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_MENUADAPTER" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, SetMenuAttributes()
        will be called by Hollywood to select or deselect a menu item or to
        enable or disable it. The menu item to be modified will be passed in the
        "item" parameter. The "setflags" parameter indicates which menu item
        flags should be set and the "clrflags" parameter indiciates which menu
        item flags should be cleared.

        The following menu item flags are recognized by SetMenuAttributes():

        HWMENUFLAGS_SELECTED:
                  Select or deselect menu item.

        HWMENUFLAGS_DISABLED:
                  Enable or disable menu item.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        item      menu item to modify
        setflags  flags that should be set (see above)
        clrflags  flags that should be cleared (see above)
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        ok        return TRUE to indicate success, FALSE to indicate failure

@ENDNODE

@NODE SetMenuBar "Hollywood SDK"

   @{b}NAME@{ub}
        SetMenuBar -- set display's menu bar (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = SetMenuBar(APTR display, struct hwMenuTreeInfo *menu,
                     struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_MENUADAPTER" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, SetMenuBar() must
        set the display's menu bar to the one specified in the "menu" parameter.
        The "menu" parameter will be either a pointer to a struct hwMenuTreeInfo
        describing the menu tree or NULL. If it is NULL, the menu bar must be
        removed from the display.

        struct hwMenuTreeInfo looks like this:

            struct hwMenuTreeInfo
            {
                struct hwMenuTreeInfo *Succ;
                STRPTR Name;
                STRPTR ID;
                STRPTR Hotkey;
                ULONG Flags;
                struct hwMenuTreeInfo *FirstChild;
                APTR UserData;
            };

        Here is a description of the individual structure members:

        Succ:     Will be set to a pointer to the next tree node or NULL if this
                  node is the last one.

        Name:     Null-terminated string containing the menu item's title. If
                  this is NULL, you must create a separator item.

        ID:       Null-terminated string containing the menu item's identifier
                  or NULL.

        Hotkey:   Null-terminated string containing the menu item's shortcut or
                  NULL.

        Flags:    A combination of the following flags:

                  HWMENUFLAGS_TOGGLE:
                            The menu item shall be a toggle menu.

                  HWMENUFLAGS_RADIO:
                            The menu item shall be part of a radio group.

                  HWMENUFLAGS_SELECTED:
                            The menu item shall be initially selected. This can
                            only be set if either "HWMENUFLAGS_TOGGLE" or
                            "HWMENUFLAGS_RADIO" is set.

                  HWMENUFLAGS_DISABLED:
                            The menu item shall be initially disabled.

        FirstChild:
                  Pointer to the menu tree of the subitem. If it is NULL, the
                  menu item doesn't have a subitem.

        UserData: You may store user data here. This can be useful to refer to
                  this item when Hollywood calls your @{"SetMenuAttributes()" LINK SetMenuAttributes} or
                  @{"GetMenuAttributes()" LINK GetMenuAttributes} functions.

        Whenever the user selects a menu item, you need to post an
        "HWEVT_MENUITEM" event to Hollywood's event queue. See @{"hw_PostEvent" LINK hw_PostEvent} for
        details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        menu      menu tree definition or NULL to remove menu
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        ok        return TRUE to indicate success, FALSE to indicate failure

@ENDNODE

@NODE SetPalette "Hollywood SDK"

   @{b}NAME@{ub}
        SetPalette -- change display palette (V9.0)

   @{b}SYNOPSIS@{ub}
        void SetPalette(APTR handle, ULONG *palette, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_MAINLOOP" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, it must change the
        palette of the display specified by "handle" to the palette that is
        passed in the "palette" argument. The colors in the "palette" array are
        passed as raw RGB values.

        Note that if you want Hollywood to call this function, you also must set
        "HWDISPTAG_PALETTEMODE" to TRUE in your @{"OpenDisplay()" LINK OpenDisplay} implementation and
        you must set the "HWSDAFLAGS_SETPALETTE" flag in your call to
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        palette   new palette for display
        tags      reserved for future use, currently NULL

@ENDNODE

@NODE SetPointer "Hollywood SDK"

   @{b}NAME@{ub}
        SetPointer -- change mouse pointer (V6.0)

   @{b}SYNOPSIS@{ub}
        void SetPointer(APTR handle, int type, APTR data);

   @{b}FUNCTION@{ub}
        This function must change the display's mouse pointer to the one that is
        requested by Hollywood. The second parameter describes the requested
        mouse pointer type. This can be one of the following types:

        HWPOINTER_SYSTEM:
                  Mouse pointer should be changed to the system's default mouse
                  pointer.

        HWPOINTER_BUSY:
                  Mouse pointer should be changed to a system mouse pointer that
                  indicates that the application is currently busy.

        HWPOINTER_CUSTOM:
                  Mouse pointer should be changed to a custom mouse pointer
                  allocated by @{"CreatePointer()" LINK CreatePointer}. If "type" is set to
                  "HWPOINTER_CUSTOM", a handle to the custom mouse pointer is
                  passed in the "data" parameter. Otherwise the "data" parameter
                  is NULL.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        type      desired mouse pointer type (see above for supported types)
        data      if type is "HWPOINTER_CUSTOM", this is set to a handle
                  returned by @{"CreatePointer()" LINK CreatePointer}, otherwise it is NULL

@ENDNODE

@NODE SetTrayIcon "Hollywood SDK"

   @{b}NAME@{ub}
        SetTrayIcon -- change the tray icon (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = SetTrayIcon(APTR display, ULONG *rgb, int width, int height,
                     struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_DISPLAYADAPTER_TRAYICON" extension bit has been set. See
        @{"Extension plugins" LINK ExtensionOverview} for details. If that is the case, it must set the tray
        icon to the image passed in the "rgb" parameter. "rgb" will be a pointer
        to a memory buffer of raw ARGB pixels in the size specified by "width"
        and "height". The alpha byte in that buffer will always be set. Note
        that "rgb" may also be NULL. In that case, the tray icon needs to be
        removed.

        Additionally, Hollywood may pass a tag list to SetTrayIcon() which can
        contain the following tags:

        HWSTITAG_TOOLTIP:
                  If this tag is in the list, the "pData" member of it will be
                  set to a string that should be installed as the tray icon's
                  tooltip.

        Note that if you want Hollywood to call this function, you also must set
        the "HWSDAFLAGS_SETTRAYICON" flag in your call to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

        When the user clicks on the tray icon, you should post a
        "HWEVT_TRAYICON" event to Hollywood's event queue. See @{"hw_PostEvent" LINK hw_PostEvent} for
        details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        rgb       ARGB image data of new tray icon or NULL to remove the tray
                  icon
        width     width of the ARGB pixel buffer
        height    height of the ARGB pixel buffer
        tags      tag list containing additional options (see above)

@ENDNODE

@NODE ShowHideDisplay "Hollywood SDK"

   @{b}NAME@{ub}
        ShowHideDisplay -- show or hide the display (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = ShowHideDisplay(APTR handle, int show, struct hwTagList *t);

   @{b}FUNCTION@{ub}
        This function must show or hide the display depending on the state
        passed as parameter 2.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        show      TRUE to show the display, FALSE to hide it
        t         taglist for additional options (currently always NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE ShowHidePointer "Hollywood SDK"

   @{b}NAME@{ub}
        ShowHidePointer -- show or hide the mouse pointer (V6.0)

   @{b}SYNOPSIS@{ub}
        void ShowHidePointer(APTR handle, int show);

   @{b}FUNCTION@{ub}
        This function must show or hide the mouse pointer for the specified
        display.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        show      TRUE to show the pointer, FALSE to hide it

@ENDNODE

@NODE SizeMoveDisplay "Hollywood SDK"

   @{b}NAME@{ub}
        SizeMoveDisplay -- change display position and/or size (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = SizeMoveDisplay(APTR handle, int x, int y, int width,
                        int height, ULONG flags, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must change the display position to the specified new
        position and the display size must be changed to the specified new
        dimensions. All values have to be passed in pixels.

        After a display size change Hollywood will usually also call
        @{"ChangeBufferSize()" LINK ChangeBufferSize} so that your plugin can adapt the size of its back
        buffer. The only time in which @{"ChangeBufferSize()" LINK ChangeBufferSize} is not called after
        SizeMoveDisplay() is with enabled autoscaling because in that case the
        size of the back buffer does not change with the output display's size.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        x         new x position for this display
        y         new y position for this display
        width     new width for this display
        height    new height for this display
        flags     additional flags (currently 0)
        t         taglist for additional options (currently always NULL)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE Sleep "Hollywood SDK"

   @{b}NAME@{ub}
        Sleep -- sleep for a certain amount of time (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        int error = Sleep(lua_State *L, int ms);

   @{b}FUNCTION@{ub}
        This function must put the application to sleep for the requested amount
        of milliseconds. It is important that this is done in a way that lets
        the application stay responsive, i.e. you must make sure that you keep
        handling window events and you also must call into @{"hw_MasterServer()" LINK hw_MasterServer}
        frequently to keep videos playing. If the user closes the display while
        sleeping, you should return "ERR_USERABORT" so that Hollywood can
        shutdown.

        Sleep() is an optional API and must only be implemented if
        "HWSDAFLAGS_SLEEP" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See
        @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

        Note that when compiling for 64-bit Windows, this function must be
        called "_Sleep" instead. Otherwise there will be clashes with the
        function of the same name from "kernel32". lib. On 32-bit Windows this
        isn't a problem because 32-bit Windows uses decorated function exports.
        Starting with Hollywood 10.0, it is recommended to use the "hwp_" prefix
        before all plugin function exports. If you do that, you can just export
        this function as "hwp_Sleep" without having to use a different export
        name for 32-bit and 64-bit builds but keep in mind that the "_hwp"
        prefix works only on Hollywood 10.0 or better.

   @{b}INPUTS@{ub}
        L         pointer to the "lua_State"
        ms        number of milliseconds to sleep

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE UnLockBitMap "Hollywood SDK"

   @{b}NAME@{ub}
        UnLockBitMap -- unlock a software bitmap (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void UnLockBitMap(APTR handle);

   @{b}FUNCTION@{ub}
        This must unlock the software bitmap specified by "handle". Note that
        the "handle" parameter is not a bitmap but the lock handle as returned
        by @{"LockBitMap()" LINK LockBitMap}.

        UnLockBitMap() is an optional API and must only be implemented if
        "HWSDAFLAGS_BITMAPADAPTER" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}.
        See @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    lock handle returned by @{"LockBitMap()" LINK LockBitMap}

@ENDNODE

@NODE VWait "Hollywood SDK"

   @{b}NAME@{ub}
        VWait -- wait for next vertical blank (V6.0, optional)

   @{b}SYNOPSIS@{ub}
        void VWait(APTR handle, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must wait for the next vertical blank on the specified
        display. The following tags can currently be passed in the tag list:

        HWVWAITTAG_DOUBLEBUFFER:
                  The "iData" value of this tag item is set to TRUE if Hollywood
                  is currently in double-buffer mode, otherwise it is set to
                  FALSE.

        VWait() is an optional API and must only be implemented if
        "HWSDAFLAGS_VWAIT" has been passed to @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. See
        @{"hw_SetDisplayAdapter" LINK hw_SetDisplayAdapter} for details.

   @{b}INPUTS@{ub}
        handle    display handle returned by @{"OpenDisplay()" LINK OpenDisplay}
        t         taglist for additional options (see above)

@ENDNODE

@NODE WaitEvents "Hollywood SDK"

   @{b}NAME@{ub}
        WaitEvents -- wait until events come in (V6.0)

   @{b}SYNOPSIS@{ub}
        int error = WaitEvents(lua_State *L, ULONG flags, struct hwTagList *t);

   @{b}FUNCTION@{ub}
        This function must halt the program's execution until an event comes in.
        The event must then be handled by your @{"HandleEvents()" LINK HandleEvents} implementation.
        WaitEvents() has to return an error code or 0 for success.

        The following flags may be passed in the second parameter:

        HWWEFLAGS_MODAL:
                  If this flag is set, then WaitEvents() has been called from a
                  modal loop that Hollywood is currently running. A modal loop
                  is a temporary event loop set up by functions that block the
                  script execution until certain events happen, e.g.
                  "WaitLeftMouse()" or "InKeyStr()". If "HWWEFLAGS_MODAL" is not
                  set, then you can be sure that Hollywood is currently running
                  the script's main loop. This means that your WaitEvents()
                  implementation has been called as a result of the script
                  calling Hollywood's "WaitEvent()" function.

        The third parameter is a tag list that can contain the following tags:

        HWWETAG_AMIGASIGNALS:
                  This tag is always passed on Amiga systems and your
                  WaitEvents() implementation must take it into account. The
                  "pData" item of this tag is set to a "ULONG" pointer that
                  contains a combination of signal bits that your WaitEvents()
                  implementation has to take into account. Thus, on Amiga
                  systems all WaitEvents() implementations must be based on
                  exec.library/Wait(). You may choose to wait on additional
                  signals but you also must take the signals that you get from
                  Hollywood into account. Furthermore, you must write the
                  signals that have broken your WaitEvents() implementation back
                  to the "ULONG" pointer before you return from this function.
                  This is because Hollywood needs to know which signals have
                  triggered so that it can take appropriate action.

        Please note that this function must wait for events on all displays that
        have currently been opened by @{"OpenDisplay()" LINK OpenDisplay}. Additionally, it could
        also happen that no display is open at all and your WaitEvents()
        function is called. Be prepared to deal with these cases.

        Also note that your WaitEvents() implementation must be capable of being
        woken up by @{"ForceEventLoopIteration()" LINK ForceEventLoopIteration} when this is called from worker
        threads. See @{"ForceEventLoopIteration" LINK ForceEventLoopIteration} for details.

   @{b}INPUTS@{ub}
        L         pointer to the "lua_State"
        flags     combination of flags (see above)
        t         tag list containing additional parameters (see above)

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE WritePixel "Hollywood SDK"

   @{b}NAME@{ub}
        WritePixel -- draw a single pixel (V6.0)

   @{b}SYNOPSIS@{ub}
        void WritePixel(APTR handle, int x, int y, ULONG color, ULONG flags,
                 struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must draw a single pixel with the color passed in
        parameter 4. The destination handle can be either a display or a bitmap.
        You have to look at "flags" parameter to find out how to interpret the
        handle that Hollywood has passed to your function. The following flags
        are currently recognized:

        HWWPFLAGS_DESTVIDEOBITMAP:
                  The handle passed is a video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}. This can only happen if you've set the
                  "HWVBMCAPS_OFFSCREENCOLOR" or "HWVBMCAPS_OFFSCREENALPHA"
                  capabilities in "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen
                  rendering to video bitmaps. Otherwise,
                  "HWWPFLAGS_DESTVIDEOBITMAP" will never be set.

        HWWPFLAGS_DESTALPHAONLY:
                  This is only set in connection with
                  "HWWPFLAGS_DESTVIDEOBITMAP". If Hollywood wants you to draw to
                  the alpha channel of your video bitmap allocated by
                  @{"AllocVideoBitMap()" LINK AllocVideoBitMap}, it will indicate this by setting
                  "HWWPFLAGS_DESTALPHAONLY". If "HWWPFLAGS_DESTVIDEOBITMAP" is
                  set and "HWWPFLAGS_DESTALPHAONLY" isn't, you have to draw to
                  the color channels of the video bitmap instead. Note that
                  "HWWPFLAGS_DESTALPHAONLY" will only ever be set if you've set
                  the "HWVBMCAPS_OFFSCREENALPHA" capability flag in
                  "HWSDATAG_VIDEOBITMAPCAPS" to enable offscreen rendering to
                  video bitmap alphachannels. In that case, the "color"
                  parameter will contain just an 8-bit alpha transparency value
                  ranging from 0 to 255.

        HWWPFLAGS_DESTBITMAP:
                  The handle passed is a software bitmap allocated by Hollywood
                  or your plugin's @{"AllocBitMap()" LINK AllocBitMap} function if you've set the
                  "HWSDAFLAGS_BITMAPADAPTER" in your call to
                  @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. Note that "HWWPFLAGS_DESTBITMAP" will
                  only ever be set if you've passed "HWBMAHOOK_WRITEPIXEL" in
                  "HWSDAFLAGS_BITMAPHOOK". Otherwise, Hollywood will do the
                  rendering to the software bitmap on its own and you don't have
                  to care. "HWWPFLAGS_DESTBITMAP" will only ever be set if
                  you've explicitly requested that you want to do offscreen
                  drawing to software bitmaps on your own by setting the
                  appropriate bitmap hook flags.

        If you've set the "HWSDAFLAGS_ALPHADRAW" flag when calling
        @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} to initialize your plugin, the color value passed
        in parameter 4 will contain an alpha value in its 8 most significant
        bits and your implementation is expected to draw to the destination with
        alpha blending enabled. If you haven't set "HWSDAFLAGS_ALPHADRAW", the
        color will be just a 24-bit RGB value. If the "HWWPFLAGS_DESTALPHAONLY"
        flag is set, the "color" parameter will contain just an 8-bit alpha
        transparency value ranging from 0 to 255.

        This function doesn't have to do any clipping. Hollywood will perform
        clipping itself before calling WritePixel().

        If your display adapter doesn't support video bitmaps or hooks into
        Hollywood's bitmap handler, WritePixel() only has to be able to draw to
        the display which should be quite simple and straight-forward to
        implement.

        If your plugin supports hardware double buffering and Hollywood has put
        your display into hardware double buffering mode by calling your
        plugin's @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} function, this function must not draw
        anything to the display but only to the back buffer. Hollywood will call
        your plugin's @{"Flip()" LINK Flip} function when it wants you to draw the back buffer
        to the display.

        You might want to use the @{"hw_RawWritePixel()" LINK hw_RawWritePixel} function in your
        implementation to plot pixels to bitmaps stored as raw pixel buffers.
        See @{"hw_RawWritePixel" LINK hw_RawWritePixel} for details.

   @{b}INPUTS@{ub}
        handle    destination display or bitmap (depends on the flags that are
                  set, see above)
        x         x offset for the pixel
        y         y offset for the pixel
        color     pixel color
        flags     flags specifying further parameters
        tags      additional options (currently always NULL)

@ENDNODE

@NODE ExtensionOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_EXTENSION" set are a
    special plugin type that doesn't offer any functionality on its own but just
    extends an existing plugin type. Certain plugin types support a number of
    extensions in newer Hollywood versions and the extension plugin type can be
    used to tell Hollywood which extensions your plugin actually supports. There
    is only one function, @{"GetExtensions()" LINK GetExtensions}, which Hollywood will call to get
    information about the extensions supported by your plugin.

    This plugin type is supported since Hollywood 6.0.

    @{"GetExtensions()                   " LINK GetExtensions} Query supported extensions for plugin type
@ENDNODE

@NODE GetExtensions "Hollywood SDK"

   @{b}NAME@{ub}
        GetExtensions -- query supported extensions for plugin type (V6.0)

   @{b}SYNOPSIS@{ub}
        ULONG exts = GetExtensions(ULONG capbit, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        Hollywood will call this function to see which extensions are supported
        by your plugin for a certain plugin type. Hollywood will pass the
        capability bit of the plugin type whose supported extensions it wants to
        know to GetExtensions(). Note that this is a not a combination of
        capability flags but only a single capability bit will ever be set in
        each call to GetExtensions() Hollywood makes, i.e. Hollywood will call
        GetExtensions() for each plugin type whose supported extensions it wants
        to get individually.

        The following plugin types currently support extensions:

        HWPLUG_CAPS_LIBRARY:
                  Library plugins currently support the following extensions:

                  HWEXT_LIBRARY_MULTIPLE:
                            If this extension bit is set, your library plugin
                            wants to install multiple libraries and has
                            implemented the @{"GetLibraryCount()" LINK GetLibraryCount} and
                            @{"SetCurrentLibrary()" LINK SetCurrentLibrary} functions to handle this. See
                            @{"Library plugins" LINK LibraryOverview} for details. (V6.0)

                  HWEXT_LIBRARY_NOAUTOINIT:
                            If this extension bit is set, the commands and
                            constants of your library won't be added
                            automatically to Hollywood's set of commands and
                            constants. Instead, they'll only be added when the
                            script performs a "\@REQUIRE" on your plugin. See
                            @{"Library plugins" LINK LibraryOverview} for details. (V6.1)

                  HWEXT_LIBRARY_HELPSTRINGS:
                            If this extension bit is set, your library plugin
                            wants to provide help strings and nodes for the
                            individual plugin commands and needs to implement
                            the @{"GetHelpStrings()" LINK GetHelpStrings} function to handle this. See
                            @{"Library plugins" LINK LibraryOverview} for details. (V7.0)

                  HWEXT_LIBRARY_UPVALUES:
                            If this extension bit is set, Hollywood can be made
                            to allocate upvalues for your plugin commands. For
                            this purpose it is necessary that you implement the
                            @{"PushUpvalues()" LINK PushUpvalues} function if this bit is set. See
                            @{"Library plugins" LINK LibraryOverview} for details. (V7.1)

        HWPLUG_CAPS_IMAGE:
                  Image plugins currently support the following extensions:

                  HWEXT_IMAGE_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Image" LINK ImageOverview}
                            @{"plugins" LINK ImageOverview} for details. (V6.0)

                  HWEXT_IMAGE_FORMATNAME:
                            If this extension bit is set, the plugin indicates
                            that it supports returning a string that describes
                            the image format of a file. If you set this
                            extension bit, your plugin needs to implement the
                            @{"GetImageFormat()" LINK GetImageFormat} function. See @{"GetImageFormat" LINK GetImageFormat} for
                            details. (V10.0)

        HWPLUG_CAPS_ANIM:
                  Anim plugins currently support the following extensions:

                  HWEXT_ANIM_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Anim plugins" LINK AnimOverview}
                            for details. (V6.0)

                  HWEXT_ANIM_VECTOR:
                            Set this extension bit to indicate that your anim
                            plugin supports vector anims. This means that your
                            plugin must implement additional functions like
                            @{"GetFrame()" LINK GetFrame} and set the type of the anim when
                            @{"OpenAnim()" LINK OpenAnim} is called. See @{"OpenAnim" LINK OpenAnim} for details.
                            (V9.0)

                  HWEXT_ANIM_FORMATNAME:
                            If this extension bit is set, the plugin indicates
                            that it supports returning a string that describes
                            the anim format of a file. If you set this extension
                            bit, your plugin needs to implement the
                            @{"GetAnimFormat()" LINK GetAnimFormat} function. See @{"GetAnimFormat" LINK GetAnimFormat} for
                            details. (V10.0)

        HWPLUG_CAPS_SOUND:
                  Sound plugins currently support the following extensions:

                  HWEXT_SOUND_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Sound" LINK SoundOverview}
                            @{"plugins" LINK SoundOverview} for details. (V6.0)

        HWPLUG_CAPS_VIDEO:
                  Video plugins currently support the following extensions:

                  HWEXT_VIDEO_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Video" LINK VideoOverview}
                            @{"plugins" LINK VideoOverview} for details. (V6.0)

        HWPLUG_CAPS_VECTOR:
                  Vectorgraphics plugins currently support the following
                  extensions:

                  HWEXT_VECTOR_EXACTFIT:
                            If this extension bit is set, @{"GetPathExtents()" LINK GetPathExtents} must
                            take the transformation matrix it is passed into
                            account when computing the path's extents. If
                            "HWEXT_VECTOR_EXACTFIT" is not set, Hollywood will
                            compute the extents of the transformed path but this
                            is not recommended since it is your plugin that
                            knows best about the real extents. See
                            @{"Vectorgraphics plugins" LINK VectorGfxOverview} for details. (V6.0)

                  HWEXT_VECTOR_CUSTOMFT2:
                            Vectorgraphics plugins can set this extension bit to
                            tell Hollywood that they're using a custom freetype2
                            implementation that is not compatible with the one
                            that is built into Hollywood. If this extension bit
                            is set, Hollywood will call your plugin whenever it
                            needs to turn a font into an "FT_Face".
                            Consequently, plugins which set
                            "HWEXT_VECTOR_CUSTOMFT2" must implement the
                            @{"OpenFont()" LINK OpenFont} and @{"CloseFont()" LINK CloseFont} vectors. Note that on
                            WarpOS Hollywood will activate
                            "HWEXT_VECTOR_CUSTOMFT2" automatically for WarpOS
                            plugins because those can only access a PPC build of
                            freetype2 whose "FT_Face" handles are not compatible
                            with the 68k ones expected by Hollywood. (V10.0)

        HWPLUG_CAPS_SAVEANIM:
                  Anim saver plugins currently support the following extensions:

                  HWEXT_SAVEANIM_BEGINANIMSTREAM:
                            If this extension tag is defined, Hollywood will
                            call the @{"BeginAnimStreamExt()" LINK BeginAnimStreamExt} function instead of
                            the @{"BeginAnimStream()" LINK BeginAnimStream} function to create a new anim.
                            This allows plugins to get information about the
                            desired file adapter, user tags and also the desired
                            output format. The original @{"BeginAnimStream()" LINK BeginAnimStream} is
                            broken by design because it accepts neither a tag
                            list nor a structure argument so it can't be
                            extended at all. See @{"BeginAnimStreamExt" LINK BeginAnimStreamExt} for details.
                            (V10.0)

        HWPLUG_CAPS_DISPLAYADAPTER:
                  Display adapter plugins currently support the following
                  extensions:

                  HWEXT_DISPLAYADAPTER_MAINLOOP:
                            If this extension bit is set, the display adapter is
                            marked as main loop-based which means that Hollywood
                            will explicitly ask the display adapter to run its
                            main loop instead of just calling the @{"HandleEvents()" LINK HandleEvents}
                            and @{"WaitEvents()" LINK WaitEvents} functions from time to time. See
                            @{"AdapterMainLoop" LINK AdapterMainLoop} for details. (V6.1)

                  HWEXT_DISPLAYADAPTER_PALETTE:
                            If this extension bit is set, the display adapter
                            signals that it has implemented the @{"SetPalette()" LINK SetPalette}
                            function for changing the palette of a genuine
                            palette mode display. You can activate genuine
                            palette mode by setting the "HWDISPTAG_PALETTEMODE"
                            tag to TRUE in @{"OpenDisplay()" LINK OpenDisplay} and setting the
                            "HWSDAFLAGS_SETPALETTE" flags with
                            @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter}. (V9.0)

                  HWEXT_DISPLAYADAPTER_MENUADAPTER:
                            If this extension bit is set, the display adapter
                            signals that it supports menus and you have to
                            implement all additional menu functions like
                            @{"SetMenuBar()" LINK SetMenuBar} and others. Furthermore, you have to
                            pass "HWSDAFLAGS_MENUADAPTER" to
                            @{"hw_SetDisplayAdapter()" LINK hw_SetDisplayAdapter} to activate menu support for
                            your display adapter. (V9.0)

        HWPLUG_CAPS_DIRADAPTER:
                  Directory adapter plugins currently support the following
                  extensions:

                  HWEXT_DIRADAPTER_REWIND:
                            If this extension bit is set, the directory adapter
                            declares itself capable of rewinding directories.
                            This means that the @{"RewindDir()" LINK RewindDir} function must be
                            implemented. See @{"RewindDir" LINK RewindDir} for details. (V8.0)

                  HWEXT_DIRADAPTER_STAT:
                            If this extension bit is set, the directory adapter
                            declares itself capable of getting additional
                            information like date, time, and DOS attributes
                            about directories. This means that the @{"StatDir()" LINK StatDir}
                            function must be implemented. See @{"StatDir" LINK StatDir} for
                            details. (V9.0)

        HWPLUG_CAPS_REQUIRE:
                  Require hook plugins currently support the following
                  extensions:

                  HWEXT_REQUIRE_LUALESS:
                            You can set this extension bit to signal that your
                            implementation of @{"RequirePlugin()" LINK RequirePlugin} doesn't need a
                            valid lua_State pointer. This is important for
                            compatibility with Hollywood Designer. Since
                            Designer doesn't contain a Lua virtual machine, it
                            won't be able to pass a lua_State pointer to
                            @{"RequirePlugin()" LINK RequirePlugin}. That is why Designer ignores
                            plugins which depend on @{"RequirePlugin()" LINK RequirePlugin} to be called
                            by default. However, if you set
                            "HWEXT_REQUIRE_LUALESS" and then make sure that your
                            @{"RequirePlugin()" LINK RequirePlugin} implementation can handle a NULL
                            pointer in the lua_State argument, your plugin will
                            be compatible with Designer as well. See
                            @{"RequirePlugin" LINK RequirePlugin} for details. (V9.0)

        HWPLUG_CAPS_ICON:
                  Icon plugins currently support the following extensions:

                  HWEXT_ICON_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Icon plugins" LINK IconOverview}
                            for details. (V9.0)

                  HWEXT_ICON_FORMATNAME:
                            If this extension bit is set, the plugin indicates
                            that it supports returning a string that describes
                            the icon format of a file. If you set this extension
                            bit, your plugin needs to implement the
                            @{"GetIconFormat()" LINK GetIconFormat} function. See @{"GetIconFormat" LINK GetIconFormat} for
                            details. (V10.0)

        HWPLUG_CAPS_FONT:
                  Font plugins currently support the following extensions:

                  HWEXT_FONT_NOAUTOINIT:
                            If this extension bit is set, Hollywood will not
                            automatically activate your plugin at load time.
                            Instead, you'll have to do this manually by calling
                            the @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} function. See @{"Font plugins" LINK FontOverview}
                            for details. (V10.0)

   @{b}INPUTS@{ub}
        capbit    single capability bit of the plugin type whose extensions
                  should be queried
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        exts      combination of extension bits for the specified plugin type
                  (see above)

@ENDNODE

@NODE FileAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_FILEADAPTER" set can hook
    into Hollywood's file handler. Whenever Hollywood has to open a file, it
    will first ask all the plugins that have hooked themselves into Hollywood's
    file handler if one of them wants to open it instead. If one of the plugins
    chooses to handle this file type, all file IO will be done through the file
    adapter functions implemented in the plugin. Otherwise, Hollywood will do
    all file IO through its default file handler.

    Please note that file adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the file
    adapter. The file adapter will then only be activated if the user calls
    "\@REQUIRE" on your plugin. See @{"Auto and manual plugin initialization" LINK AutoAndManualInit} for
    details. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on your file adapter
    plugin, it will only be available if the user addresses it directly through
    the "Adapter" tag.

    See @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for information on how to add your file adapter.

    All functions of this plugin type have to be implemented in a thread-safe
    manner.

    This plugin type is supported since Hollywood 6.0.

    @{"FClose()                          " LINK FClose} Close a file handle
    @{"FEof()                            " LINK FEof} Check if end-of-file marker has been reached
    @{"FFlush()                          " LINK FFlush} Flush all pending writes to file
    @{"FGetC()                           " LINK FGetC} Read a single character from a file
    @{"FOpen()                           " LINK FOpen} Open a file
    @{"FPutC()                           " LINK FPutC} Write single character to file
    @{"FRead()                           " LINK FRead} Read file data into memory buffer
    @{"FSeek()                           " LINK FSeek} Seek file to new position
    @{"FStat()                           " LINK FStat} Obtain information about an open file
    @{"FWrite()                          " LINK FWrite} Write data to file handle
    @{"Stat()                            " LINK Stat} Examine a file system object
@ENDNODE

@NODE FClose "Hollywood SDK"

   @{b}NAME@{ub}
        FClose -- close a file handle (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = FClose(APTR handle);

   @{b}FUNCTION@{ub}
        This function must close the specified file handle, finishing all
        pending writes. FClose() must return TRUE on success, FALSE otherwise.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FEof "Hollywood SDK"

   @{b}NAME@{ub}
        FEof -- check if end-of-file marker has been reached (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = FEof(APTR handle);

   @{b}FUNCTION@{ub}
        This function must return TRUE if the end-of-file marker has been
        reached for the specified file handle.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE

@ENDNODE

@NODE FFlush "Hollywood SDK"

   @{b}NAME@{ub}
        FFlush -- flush all pending writes to file (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = FFlush(APTR handle);

   @{b}FUNCTION@{ub}
        This function must flush any pending buffered write operations to the
        specified file handle and return TRUE on success, FALSE otherwise.

        If your file adapter doesn't support writing to files, this function can
        be a dummy stub.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FGetC "Hollywood SDK"

   @{b}NAME@{ub}
        FGetC -- read a single character from a file (V6.0)

   @{b}SYNOPSIS@{ub}
        int c = FGetC(APTR handle);

   @{b}FUNCTION@{ub}
        This function must read a single character from the specified file
        handle and return it. In case the end-of-file marker has been reached or
        an error has occurred, -1 must be returned.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}

   @{b}RESULTS@{ub}
        c         character read or -1 on error or EOF

@ENDNODE

@NODE FOpen "Hollywood SDK"

   @{b}NAME@{ub}
        FOpen -- open a file (V6.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = FOpen(STRPTR name, int mode, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is called for every file that Hollywood opens. Your
        FOpen() implementation has to check whether your plugin wants to handle
        this file or not. If your plugin wants to handle this file, your FOpen()
        implementation needs to open it and return a handle to Hollywood.
        Otherwise FOpen() must return NULL. The handle returned by this function
        is an opaque data type only your plugin knows about. Hollywood will pass
        this handle to you whenever it wants to do IO on this file.

        The second parameter specifies whether Hollywood wants to open this file
        for reading and/or writing. It can be one of the following values:

        HWFOPENMODE_READ_NEW:
                  File should be opened for reading. FOpen() must fail if file
                  doesn't exist.

        HWFOPENMODE_WRITE:
                  File should be opened for writing. If it doesn't exist,
                  FOpen() has to create it first.

        HWFOPENMODE_READWRITE:
                  File should be opened for reading and writing.

        Additionally, Hollywood will pass a tag list to your implementation in
        parameter 3. This tag list can contain the following items:

        HWFOPENTAG_FLAGS:
                  This tag is used to pass additional flags to your plugin and
                  it also allows you to report certain flags about the file back
                  to Hollywood. The "pData" member of this tag will be set to a
                  pointer to a "ULONG" which contains the flags Hollywood wants
                  to pass to your plugin. Your plugin may then also set one or
                  more of the following flags in this "ULONG" to inform
                  Hollywood about the properties of the file. Flags marked as
                  [in] may be set by Hollywood whereas flags marked as [out] can
                  be set by your plugin. The following flags are currently
                  defined:

                  HWFOPENFLAGS_STREAMING: [out]
                            Setting this flag tells Hollywood that the file is
                            being streamed from a network source. If this flag
                            is set, Hollywood will try to avoid operations that
                            are inefficient on streaming sources like excessive
                            seeking operations.

                  HWFOPENFLAGS_NOSEEK: [out]
                            Setting this flag tells Hollywood that the file
                            cannot be seeked. Note that if you set this flag,
                            you will still have to implement the @{"FSeek()" LINK FSeek}
                            function but it only needs to support rewinding
                            (i.e. reverting the read/write cursor to the
                            beginning of the file) and querying the current file
                            cursor position. Note that if you set
                            "HWFOPENFLAGS_NOSEEK" several file format handlers
                            which depend on the seek functionality might stop
                            working. Plugins may choose to work-around this
                            problem by setting the "HWFOPENMODE_EMULATESEEK"
                            flag when calling @{"hw_FOpen()" LINK hw_FOpen}. See @{"hw_FOpen" LINK hw_FOpen} for
                            details.

                  HWFOPENFLAGS_WONTSEEK: [in]
                            Hollywood will set this flag in case it doesn't need
                            to seek the file that should be opened. This allows
                            file adapters to use optimized I/O in case the file
                            will never be seeked. Note, however, that even if
                            "HWFOPENFLAGS_WONTSEEK" is set, Hollywood can still
                            call @{"FSeek()" LINK FSeek} to query the current cursor position,
                            to query the file size by seeking to position 0 with
                            mode set to "HWFSEEKMODE_END" or to rewind the file
                            back to 0 so your plugin must be able to handle
                            those situation. (V10.0)

        HWFOPENTAG_CHUNKFILE:
                  If you've set the "HWCLAFAFLAGS_CHUNKLOADER" flag to indicate
                  that your file adapter supports opening of virtual files that
                  do not exist physically but only as parts of other files, you
                  can use this tag to find out the path to the real file that
                  contains the virtual file. If Hollywood passes the
                  "HWFOPENTAG_CHUNKFILE" tag to your FOpen() implementation, the
                  "pData" member will be set to a string containing the path to
                  the real file Hollywood wants you to open, but keep in mind
                  that Hollywood wants you to look at a part of this file only.
                  This part is described by the "HWFOPENTAG_CHUNKOFFSET" and
                  "HWFOPENTAG_CHUNKLENGTH" tags which are always passed
                  alongside "HWFOPENTAG_CHUNKFILE". "HWFOPENTAG_CHUNKOFFSET"
                  specifies the offset where the virtual file inside the file
                  passed in "HWFOPENTAG_CHUNKFILE" starts and
                  "HWFOPENTAG_CHUNKLENGTH" specifies its length. Your file
                  adapter implementation must remap all accesses to the virtual
                  file to the physical file specified in "HWFOPENTAG_CHUNKFILE"
                  then, i.e. if the user calls @{"FSeek()" LINK FSeek} to seek to the beginning
                  of the file, your implementation of @{"FSeek()" LINK FSeek} must actually seek
                  to the position specified in "HWFOPENTAG_CHUNKOFFSET" and so
                  on. You only need to implement support for
                  "HWFOPENTAG_CHUNKFILE" if you set "LinkMode" to
                  "HWSTATLKMODE_CONTAINER" in @{"FStat()" LINK FStat}. Otherwise, it's not
                  necessary to implement "HWFOPENTAG_CHUNKFILE". See @{"FStat" LINK FStat} for
                  details.

        HWFOPENTAG_CHUNKMEMORY:
                  This is similar to "HWFOPENTAG_CHUNKFILE" except that the
                  "pData" member of this tag doesn't point to a string
                  containing a file path but to a memory block containing the
                  data of the virtual file. You can look at the
                  "HWFOPENTAG_CHUNKLENGTH" to find out the size of the memory
                  block. "HWFOPENTAG_CHUNKOFFSET" is not used for this tag. See
                  above for more information.

        HWFOPENTAG_CHUNKOFFSET:
                  If "HWFOPENTAG_CHUNKFILE" is set, the "iData" member of this
                  tag will be set to the starting offset of the virtual file
                  inside the physical file specified in "HWFOPENTAG_CHUNKFILE".

        HWFOPENTAG_CHUNKLENGTH:
                  If either "HWFOPENTAG_CHUNKFILE" or "HWFOPENTAG_CHUNKMEMORY"
                  is set, the "iData" member of this tag will be set to the
                  length of the virtual file in bytes.

        HWFOPENTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details. (V10.0)

        HWFOPENTAG_FORMAT:
                  This tag can be used to pass a file format string back to
                  Hollywood. "pData" will point to a pointer to a string
                  pointer, i.e. STRPTR*. Your plugin can set "pData" to a
                  null-terminated string containing a format description of the
                  file. Hollywood scripts will then be able to get this format
                  name by querying the #ATTRFORMAT attribute on #FILE. Note that
                  the string pointer you write to "pData" must stay valid for as
                  long as the file is open. (V10.0)

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        name      file to open
        mode      desired access mode (see above)
        tags      tag list with additional options (see above)

   @{b}RESULTS@{ub}
        handle    handle to refer to this file later or NULL if your plugin
                  doesn't want to handle this file

@ENDNODE

@NODE FPutC "Hollywood SDK"

   @{b}NAME@{ub}
        FPutC -- write single character to file (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = FPutC(APTR handle, int ch);

   @{b}FUNCTION@{ub}
        This function must write the specified character to the specified file
        handle. It must return TRUE on success or FALSE on failure.

        If your file adapter doesn't support writing to files, this function can
        be a dummy stub.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}
        ch        character to write to file (0-255)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FRead "Hollywood SDK"

   @{b}NAME@{ub}
        FRead -- read file data into memory buffer (V6.0)

   @{b}SYNOPSIS@{ub}
        int read = FRead(APTR handle, APTR buf, int size);

   @{b}FUNCTION@{ub}
        This function has to read the specified number of bytes into the memory
        buffer specified in parameter 2. It has to return the number of bytes
        actually read.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}
        buf       pointer to memory buffer to receive the data read
        size      number of bytes to read from file handle

   @{b}RESULTS@{ub}
        read      number of bytes actually read

@ENDNODE

@NODE FSeek "Hollywood SDK"

   @{b}NAME@{ub}
        FSeek -- seek file to new position (V6.0)

   @{b}SYNOPSIS@{ub}
        DOSINT64 oldpos = FSeek(APTR handle, DOSINT64 pos, int mode);

   @{b}FUNCTION@{ub}
        This function has to seek the file handle's read/write cursor to the
        specified position. Additionally, it has to return the position of the
        read/write cursor before the seek operation. The specified position is
        relative to the seek mode passed in parameter 3. This can be one of the
        following modes:

        HWFSEEKMODE_CURRENT:
                  New seek position is relative to the current position.

        HWFSEEKMODE_BEGINNING:
                  New seek position is relative to the beginning of the file.

        HWFSEEKMODE_END:
                  New seek position is relative to the end of the file.

        Note that FSeek() is often called with a 0 zero position and
        "HWFSEEKMODE_CURRENT" to query the position of the read/write cursor.

        If there was an error, FSeek() has to return -1.

        If you set the "HWFOPENFLAGS_NOSEEK" flag in your @{"FOpen()" LINK FOpen}
        implementation, your FSeek() implementation only has to support
        rewinding the file and querying the position of the cursor. In terms of
        code, this means that FSeek() only has to support the following two
        operations if "HWFOPENFLAGS_NOSEEK" is set:

            FSeek(fh, 0, HWFSEEKMODE_BEGINNING);     // rewind
            pos = FSeek(fh, 0, HFSEEKMODE_CURRENT);  // query cursor position

        For any other operation, it has to return -1, i.e. an error has
        occurred.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}
        pos       destination seek position
        mode      seek mode (see above)

   @{b}RESULTS@{ub}
        oldpos    previous position of file cursor or -1 on error

@ENDNODE

@NODE FStat "Hollywood SDK"

   @{b}NAME@{ub}
        FStat -- obtain information about open file (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = FStat(APTR handle, ULONG flags, struct hwos_StatStruct *st,
                           struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to do the same as @{"Stat()" LINK Stat} but instead of a string
        describing a path to a file system object it has to be able to obtain
        information about a file from its handle allocated by @{"FOpen()" LINK FOpen}. FStat()
        needs to write the information about the file to the structure pointer
        passed in parameter 3. struct hwos_StatStruct looks like this:

            struct hwos_StatStruct
            {
                int Type;                               // [out]
                DOSINT64 Size;                          // [out]
                ULONG Flags;                            // [out]
                struct hwos_DateStruct Time;            // [out]
                struct hwos_DateStruct LastAccessTime;  // [out]
                struct hwos_DateStruct CreationTime;    // [out]
                STRPTR FullPath;                        // [out]
                STRPTR Comment;                         // [out]
                int LinkMode;                           // [out]
                STRPTR Container;                       // [out]
            };

        Your FStat() implementation needs to write the following information to
        the individual structure members:

        Type:     This must always be set to "HWSTATTYPE_FILE".

        Size:     This must be set to the size of the file in bytes or -1 if the
                  size is not known, maybe because the file is being streamed
                  from a network source.

        Flags:    Combination of flags describing the file system object
                  attributes. See @{"File attributes" LINK FileAttributes} for a list of supported
                  attributes.

        Time:     Time stamp indicating when this file system object was last
                  modified. This information is optional. Do not touch this
                  member if you don't have this time information.

        LastAccessTime:
                  Time stamp indicating when this file system object was last
                  accessed. This information is optional. Do not touch this
                  member if you don't have this time information.

        CreationTime:
                  Time stamp indicating when this file system object was
                  created. This information is optional. Do not touch this
                  member if you don't have this time information.

        FullPath: Fully qualified path to the file. This must be provided. If
                  the "HWSTATFLAGS_ALLOCSTRINGS" flag is not set, you can set
                  this to a static string buffer which must stay valid until the
                  next call to FStat(). If "HWSTATFLAGS_ALLOCSTRINGS" has been
                  set, you need to allocate a string buffer using
                  @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        Comment:  Comment stored for this file in the file system. Set this to
                  NULL if you do not have this information or the file system
                  doesn't support storage of comments. If the
                  "HWSTATFLAGS_ALLOCSTRINGS" flag is not set, you can set this
                  to a static string buffer which must stay valid until the next
                  call to Stat(). If "HWSTATFLAGS_ALLOCSTRINGS" has been set,
                  you need to allocate a string buffer using @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        LinkMode: This member has to be set to the link mode to use when
                  Hollywood needs to link this file into an applet or
                  executable. This can be one of the following pre-defined link
                  modes:

                  HWSTATLKMODE_NORMAL:
                            Normal link mode. This means that all data is simply
                            read from the file and is written to the applet or
                            executable. Consequently, your file adapter is no
                            longer necessary when running the compiled applet or
                            executable since the data has already been converted
                            to its raw form. Thus, if you use
                            "HWSTATLKMODE_NORMAL", the compiled applet or
                            executable won't require your file adapter plugin
                            any more. Also, your file adapter won't be called at
                            all when the user runs the compiled applet or
                            executable because Hollywood has already obtained
                            the raw data from the file adapter during linking
                            stage.

                  HWSTATLKMODE_NONE:
                            This file should never be linked to applets or
                            executables. If you use this link mode, Hollywood
                            will not link the file and just keep the original
                            reference that was specified in the Hollywood
                            script, whatever it may be. This can be useful when
                            writing a file adapter that streams data from a
                            network source like an HTTP server. It wouldn't make
                            sense then for the Hollywood linker to always
                            download the whole file and link it to your applet
                            or executable. Instead, just the URL specification
                            should be linked so that the data is streamed from
                            this URL when the user runs the compiled applet or
                            executable. In that case "HWSTATLKMODE_NONE" is the
                            right choice since it skips linking for this file
                            altogether.

                  HWSTATLKMODE_CONTAINER:
                            This link mode allows you to specify a container
                            file that should be linked instead of the current
                            file. Imagine you are writing a file adapter that
                            can load a compressed file format like gzip. If you
                            used "HWSTATLKMODE_NORMAL" now, Hollywood would
                            always link the uncompressed data to the applet or
                            executable. However, you might want to make
                            Hollywood link the compressed data instead. This can
                            be achieved by setting the link mode to
                            "HWSTATLKMODE_CONTAINER" and then setting the
                            "Container" member of this structure to the file
                            that contains the compressed data. When setting
                            "LinkMode" to "HWSTATLKMODE_CONTAINER", Hollywood
                            will always link the file specified in "Container"
                            instead of the current file. Please note that if you
                            use "HWSTATLKMODE_CONTAINER", your implementation of
                            @{"FOpen()" LINK FOpen} has to support the "HWFOPENTAG_CHUNKXXX"
                            tags and you have to set the
                            "HWCLAFAFLAGS_CHUNKLOADER" flag using
                            @{"hw_ConfigureLoaderAdapter()" LINK hw_ConfigureLoaderAdapter}. See @{"FOpen" LINK FOpen} for details.

        Container:
                  If you set "LinkMode" to "HWSTATLKMODE_CONTAINER", you need to
                  set this member to a path to a file that should be linked
                  instead of the current file when Hollywood is in linking mode.
                  This can be used for fine-tuned control over Hollywood's
                  linker. See above for more information. The string buffer you
                  use to pass a container file to Hollywood must stay valid
                  until the next call to FStat(). Note that
                  "HWSTATFLAGS_ALLOCSTRINGS" (see below) doesn't affect
                  "Container". It must always use a static string buffer. If
                  link mode isn't set to "HWSTATLKMODE_CONTAINER", set this
                  member to NULL.

        The following flags are supported by FStat():

        HWSTATFLAGS_ALLOCSTRINGS:
                  If this flag is set, FStat() must not use static string
                  buffers for the "FullPath" and "Comment" structure members but
                  allocate new private string buffers for them. Hollywood will
                  then call @{"hw_TrackedFree()" LINK hw_TrackedFree} on these buffers once it is done
                  with them. This flag is often set when FStat() is used in a
                  multithreaded setup.

        FStat() has to return TRUE on success or FALSE on failure.

        This function must be implemented in a thread-safe manner if the
        "HWSTATFLAGS_ALLOCSTRINGS" flag is set.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}
        flags     additional flags (see above)
        st        pointer to a struct hwos_StatStruct for storing information
                  about the file
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FWrite "Hollywood SDK"

   @{b}NAME@{ub}
        FWrite -- write data to file handle (V6.0)

   @{b}SYNOPSIS@{ub}
        int written = FWrite(APTR handle, APTR buf, int size);

   @{b}FUNCTION@{ub}
        This function has to write the specified number of bytes from the memory
        buffer specified in parameter 2 to the file handle passed in parameter
        1. It has to return the number of bytes actually written.

        If your file adapter doesn't support writing to files, this function can
        be a dummy stub.

        This function must be implemented in a thread-safe manner.

   @{b}INPUTS@{ub}
        handle    file handle returned by @{"FOpen()" LINK FOpen}
        buf       source memory buffer
        size      number of bytes to write to file handle

   @{b}RESULTS@{ub}
        written   number of bytes actually written

@ENDNODE

@NODE Stat "Hollywood SDK"

   @{b}NAME@{ub}
        Stat -- examine a file system object (V6.0)

   @{b}SYNOPSIS@{ub}
        int ok = Stat(STRPTR name, ULONG flags, struct hwos_StatStruct *st,
                         struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to examine the file system object specified in
        parameter 1 and write information about it to the structure pointer
        passed in parameter 3. struct hwos_StatStruct looks like this:

            struct hwos_StatStruct
            {
                int Type;                               // [out]
                DOSINT64 Size;                          // [out]
                ULONG Flags;                            // [out]
                struct hwos_DateStruct Time;            // [out]
                struct hwos_DateStruct LastAccessTime;  // [out]
                struct hwos_DateStruct CreationTime;    // [out]
                STRPTR FullPath;                        // [out]
                STRPTR Comment;                         // [out]
                int LinkMode;                           // [out]
                STRPTR Container;                       // [out]
            };

        Your Stat() implementation needs to write the following information to
        the individual structure members:

        Type:     This must be set to one of the following types:

                  HWSTATTYPE_FILE:
                            The file system object examined is a file.

                  HWSTATTYPE_DIRECTORY:
                            The file system object examined is a directory.

        Size:     Size of object in bytes if it is a file, 0 for directories.
                  Note that this can also be set to -1 in case the file size
                  isn't know, for example because the file is being streamed
                  from a network source.

        Flags:    Combination of flags describing the file system object
                  attributes. See @{"File attributes" LINK FileAttributes} for a list of supported
                  attributes.

        Time:     Time stamp indicating when this file system object was last
                  modified. This information is optional. Do not touch this
                  member if you don't have this time information.

        LastAccessTime:
                  Time stamp indicating when this file system object was last
                  accessed. This information is optional. Do not touch this
                  member if you don't have this time information.

        CreationTime:
                  Time stamp indicating when this file system object was
                  created. This information is optional. Do not touch this
                  member if you don't have this time information.

        FullPath: Fully qualified path to the file system object. This must be
                  provided. If the "HWSTATFLAGS_ALLOCSTRINGS" flag is not set,
                  you can set this to a static string buffer which must stay
                  valid until the next call to Stat(). If
                  "HWSTATFLAGS_ALLOCSTRINGS" has been set, you need to allocate
                  a string buffer using @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        Comment:  Comment stored for this object in the file system. Set this to
                  NULL if you do not have this information or the file system
                  doesn't support storage of comments. If the
                  "HWSTATFLAGS_ALLOCSTRINGS" flag is not set, you can set this
                  to a static string buffer which must stay valid until the next
                  call to Stat(). If "HWSTATFLAGS_ALLOCSTRINGS" has been set,
                  you need to allocate a string buffer using @{"hw_TrackedAlloc()" LINK hw_TrackedAlloc}.

        LinkMode: Currently unused. Set to 0.

        Container:
                  Currently unused. Set to NULL.

        The following flags are supported by Stat():

        HWSTATFLAGS_ALLOCSTRINGS:
                  If this flag is set, Stat() must not use static string buffers
                  for the "FullPath" and "Comment" structure members but
                  allocate new private string buffers for them. Hollywood will
                  then call @{"hw_TrackedFree()" LINK hw_TrackedFree} on these buffers once it is done
                  with them. This flag is often set when Stat() is used in a
                  multithreaded setup.

        Stat() has to return TRUE on success or FALSE on failure.

        Stat() is often used by Hollywood to find out whether a certain file
        system object is a file or a directory. It is also used to resolve
        relative file name specifications into absolute, fully-qualified paths.
        So make sure your implementation provides this information in the
        "FullPath" structure member above.

        This function must be implemented in a thread-safe manner if the
        "HWSTATFLAGS_ALLOCSTRINGS" flag is set.

   @{b}INPUTS@{ub}
        name      name of file system object to examine
        flags     additional flags (see above)
        st        pointer to a struct hwos_StatStruct for storing information
                  about the file system object
        tags      reserved for future use (currently NULL)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FilesysAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_FILESYSADAPTER" set can
    hook into Hollywood's filesystem handler. By doing that, they can take over
    operations like making directories, deleting files or directories, and
    setting file or directory attributes, among others. This allows plugins to
    do quite some magic, e.g. they could allow scripts to copy files or whole
    directories directly into a zip file using Hollywood's "CopyFile()" function
    if the zip plugin implements Hollywood's filesystem adapter interface.
    Scripts could also delete files or whole directories from zip files using
    Hollywood's "DeleteFile()" function or even move files from one zip file to
    another using "MoveFile()" etc. Filesystem adapters offer quite a powerful
    interface.

    Note that filesystem adapters are usually combined with file and directory
    adapters because several features depend on each other. For example, the
    filesystem adapter API @{"SetFSObjAttributes()" LINK SetFSObjAttributes} is used to set file or directory
    attributes whereas the @{"Stat()" LINK Stat} function of the file adapter API is used to
    get file or directory attributes. That's why it makes sense for filesystem
    adapters to also implement file and directory adapter interfaces. See @{"File" LINK FileAdapterOverview}
    @{"adapter plugins" LINK FileAdapterOverview} for details. See @{"Directory adapter plugins" LINK DirAdapterOverview} for details.

    Please note that filesystem adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the
    filesystem adapter. The filesystem adapter will then only be activated if
    the user calls "\@REQUIRE" on your plugin. See @{"Auto and manual plugin" LINK AutoAndManualInit}
    @{"initialization" LINK AutoAndManualInit} for details. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on your
    filesystem adapter plugin, it will only be available if the user addresses
    it directly through the "Adapter" tag.

    See @{"hw_AddLoaderAdapter" LINK hw_AddLoaderAdapter} for information on how to add your filesystem
    adapter.

    This plugin type is supported since Hollywood 10.0.

    @{"ChangeDir()                       " LINK ChangeDir} Change current directory
    @{"DeleteFSObj()                     " LINK DeleteFSObj} Delete file or directory
    @{"GetCurDir()                       " LINK GetCurDir} Get current directory
    @{"MakeDir()                         " LINK MakeDir} Make directory
    @{"MoveFSObj()                       " LINK MoveFSObj} Move file or directory
    @{"RenameFSObj()                     " LINK RenameFSObj} Rename file or directory
    @{"SetFSObjAttributes()              " LINK SetFSObjAttributes} Set file or directory attributes
@ENDNODE

@NODE ChangeDir "Hollywood SDK"

   @{b}NAME@{ub}
        ChangeDir -- change current directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = ChangeDir(STRPTR dir, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to change the current directory to the one specified
        by "dir" and return TRUE for success, FALSE for failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWCHANGEDIRTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        dir       directory to make the current one
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE DeleteFSObj "Hollywood SDK"

   @{b}NAME@{ub}
        DeleteFSObj -- delete file or directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = DeleteFSObj(STRPTR obj, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must delete the file or directory specified by "obj" and
        return TRUE on success or FALSE on failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWDELETEFSOBJTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        obj       filesystem object to delete
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE GetCurDir "Hollywood SDK"

   @{b}NAME@{ub}
        GetCurDir -- get current directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = GetCurDir(STRPTR buf, int size, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to copy the fully qualified path of the current
        directory to the buffer passed in "buf". The buffer size is passed in
        the "size" argument. You must not copy more than "size" bytes to the
        buffer. This function must return TRUE on success and FALSE on failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWGETCURDIRTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        buf       buffer to receive the current directory
        size      size of the buffer in bytes
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE MakeDir "Hollywood SDK"

   @{b}NAME@{ub}
        MakeDir -- make a directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = MakeDir(STRPTR dir, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must create the directory specified by "dir" and return
        TRUE on success, FALSE on failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWMAKEDIRTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        dir       directory to create
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE MoveFSObj "Hollywood SDK"

   @{b}NAME@{ub}
        MoveFSObj -- move file or directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = MoveFSObj(STRPTR src, STRPTR dst, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must move the file or directory specified by "src" to the
        location specified "dst". Note that "dst" will always include the file
        or directory name, even if it is the same as the one passed in "src".
        Also note that "dst" can be a location on a different partition.
        MoveFSObj() must return TRUE on success or FALSE on failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWMOVEFSOBJTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        src       filesystem object to move
        dst       new location for the filesystem object
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE RenameFSObj "Hollywood SDK"

   @{b}NAME@{ub}
        RenameFSObj -- rename file or directory (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = RenameFSObj(STRPTR oldobj, STRPTR newobj, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must rename the file or directory specified by "oldobj" to
        the name specified by "newobj". Note that "newobj" will never contain
        any path specification but just the new name for the file or directory.
        RenameFSObj() must return TRUE on success or FALSE on failure.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWRENAMEFSOBJTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        oldobj    filesystem object to rename
        newobj    new name for the filesystem object
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE SetFSObjAttributes "Hollywood SDK"

   @{b}NAME@{ub}
        SetFSObjAttributes -- set file or directory attributes (V10.0)

   @{b}SYNOPSIS@{ub}
        int ok = SetFSObjAttributes(STRPTR obj, ULONG attr, struct hwos_StatStruct
                     *st, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must set the specified attributes in the file or directory
        specified by "obj". The "attr" parameter specifies which attributes to
        set. This can be a combination of the following flags:

        HWSETFSOATTR_FLAGS:
                  Set file or directory flags.

        HWSETFSOATTR_TIME:
                  Set file or directory datestamp.

        HWSETFSOATTR_COMMENT:
                  Set file or directory comment.

        The actual attribute values are passed in the "st" parameter which is a
        pointer to a struct hwos_StatStruct. struct hwos_StatStruct looks like
        this:

            struct hwos_StatStruct
            {
                int Type;                               // [ignored]
                DOSINT64 Size;                          // [ignored]
                ULONG Flags;                            // [in]
                struct hwos_DateStruct Time;            // [in]
                struct hwos_DateStruct LastAccessTime;  // [in]
                struct hwos_DateStruct CreationTime;    // [in]
                STRPTR FullPath;                        // [ignored]
                STRPTR Comment;                         // [in]
                int LinkMode;                           // [ignored]
                STRPTR Container;                       // [ignored]
            };

        Not all structure members are used by SetFSObjAttributes(). The ones
        that are marked [ignored] don't have any function in
        SetFSObjAttributes(). The others are only used if the respective
        attribute has been set in the "attr" bitmask (see above). Here is a
        description of those members:

        Flags:    This member contains a combination of flags describing the
                  file system object attributes. See @{"File attributes" LINK FileAttributes} for a list
                  of supported attributes. You must only handle this if the
                  "HWSETFSOATTR_FLAGS" attribute has been set (see above).

        Time:     This member contains a time stamp indicating when this file
                  system object was last modified. You must only handle this if
                  the "HWSETFSOATTR_TIME" attribute has been set (see above).

        LastAccessTime:
                  This member contains a time stamp indicating when this file
                  system object was last accessed. You must only handle this if
                  the "HWSETFSOATTR_TIME" attribute has been set (see above).

        CreationTime:
                  This member contains a time stamp indicating when this file
                  system object was created. You must only handle this if the
                  "HWSETFSOATTR_TIME" attribute has been set (see above).

        Comment:  This member contains the comment for this object in the file
                  system. You must only handle this if the
                  "HWSETFSOATTR_COMMENT" attribute has been set (see above).

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWSETFSOATAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. See @{"User tags" LINK UserTags} for
                  details.

   @{b}INPUTS@{ub}
        obj       filesystem object to use
        attr      combination of attributes to set
        st        pointer to a struct hwos_StatStruct containing the attribute
                  values
        tags      tag list containing further parameters (see above)

   @{b}RESULTS@{ub}
        ok        TRUE to indicate success, FALSE on failure

@ENDNODE

@NODE FontOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_FONT" set will be called
    whenever Hollywood opens a font. The plugin can check then whether the font
    is in a format that the plugin recognizes and if it is, it can open the font
    and take over the handling. This makes it possible to load custom font
    formats with Hollywood.

    Font plugins aren't limited to providing loaders for new font formats but
    they can also take over Hollywood's text engine completely by providing
    their own layout mechanism. This is done by setting the "HWFONTFLAGS_LAYOUT"
    flag in the plugin's @{"LoadFont()" LINK LoadFont} implementation. By default, Hollywood's font
    layouter is used also for fonts loaded by plugins which means that Hollywood
    will take care of handling word-wrapping, kerning, justification, alignment,
    text formatting codes and so on. This means that your plugin just needs to
    deliver the glyph extents and bitmaps and Hollywood will do the rest. If
    your plugin wants to do its own layouting, though, it can set the
    "HWFONTFLAGS_LAYOUT" flag. In that case, Hollywood's layouter won't be used
    at all and your plugin can process the text layout on its own.

    By default, font plugins are automatically activated when Hollywood loads
    them. This behaviour can be changed by setting the "HWEXT_FONT_NOAUTOINIT"
    extension bit. If this bit is set, Hollywood will not automatically activate
    your plugin at load time. Instead, you will have to manually call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to activate your plugin. For example, you could call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} from your @{"RequirePlugin()" LINK RequirePlugin} implementation. In that
    case, the font plugin would only be activated if the user called "\@REQUIRE"
    on it. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on a plugin that has
    auto-initialization disabled, it will only be available if the user
    addresses it directly through the "Loader" tag. See @{"Extension plugins" LINK ExtensionOverview} to
    learn how to use plugin extension bits.

    This plugin type is supported since Hollywood 10.0.

    @{"FreeFont()                        " LINK FreeFont} Free font handle
    @{"GetFontFormat()                   " LINK GetFontFormat} Get font format name
    @{"GetKerning()                      " LINK GetKerning} Get character kerning
    @{"LoadFont()                        " LINK LoadFont} Load font
    @{"MeasureText()                     " LINK MeasureText} Measure text string
    @{"RenderText()                      " LINK RenderText} Draw text string
    @{"SetFontScale()                    " LINK SetFontScale} Apply scaling factor to font
@ENDNODE

@NODE FreeFont "Hollywood SDK"

   @{b}NAME@{ub}
        FreeFont -- free font handle (V10.0)

   @{b}SYNOPSIS@{ub}
        void FreeFont(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free the specified font handle that has been
        allocated by your plugin's @{"LoadFont()" LINK LoadFont} function. Hollywood will call
        FreeFont() when it is done with your font.

   @{b}INPUTS@{ub}
        handle    font handle returned by @{"LoadFont()" LINK LoadFont}

@ENDNODE

@NODE GetFontFormat "Hollywood SDK"

   @{b}NAME@{ub}
        GetFontFormat -- get font format name (V10.0)

   @{b}SYNOPSIS@{ub}
        STRPTR name = GetFontFormat(APTR handle);

   @{b}FUNCTION@{ub}
        This function must return a null-terminated string containing the name
        of the format of the font passed in "handle". This string can be
        retrieved from Hollywood by querying the #ATTRFORMAT constant on #FONT
        objects. The string must remain valid until @{"FreeFont()" LINK FreeFont} is called on the
        font handle.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"LoadFont()" LINK LoadFont}

   @{b}RESULTS@{ub}
        name      font format name

@ENDNODE

@NODE GetKerning "Hollywood SDK"

   @{b}NAME@{ub}
        GetKerning -- get character kerning (V10.0)

   @{b}SYNOPSIS@{ub}
        int kern = GetKerning(APTR handle, STRPTR pair, int encoding, struct
                       hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is used to determine the kerning for the character pair
        passed in the "pair" string. The "pair" parameter will contain two
        characters and your implementation must return the desired kerning in
        pixels for those two characters. The "encoding" parameter specifies the
        character encoding of the string. This will be either
        "HWOS_ENCODING_UTF8" or "HWOS_ENCODING_ISO8859_1".

   @{b}INPUTS@{ub}
        handle    the font handle allocated by @{"LoadFont()" LINK LoadFont}
        pair      string containing two characters
        encoding  character encoding of the string (see above)
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        kern      character kerning in pixels

@ENDNODE

@NODE LoadFont "Hollywood SDK"

   @{b}NAME@{ub}
        LoadFont -- load font (V10.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = LoadFont(STRPTR name, int size, struct hwLoadFontCtrl *lf,
                          struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function is called whenever Hollywood loads a font. The name of the
        font is passed in "name" and the size in "size". Your plugin needs to
        check if the specified font is in a format that the plugin wants to
        handle, and, if it is, return a handle to the font back to Hollywood.
        Otherwise it has to return NULL. The handle returned by LoadFont() is an
        opaque datatype that only your plugin knows about. Hollywood will pass
        this handle to all your font plugin functions.

        LoadFont() is also passed a pointer to a struct hwLoadFontCtrl in the
        third parameter. This structure is used to pass some additional
        arguments to your plugin and your plugin can also pass some information
        back to Hollywood using this structure pointer. struct hwLoadFontCtrl
        looks like this:

            struct hwLoadFontCtrl
            {
                STRPTR Name;                    [out]
                STRPTR Adapter;                 [in]
                ULONG *Palette;                 [out]
                ULONG TransPen;                 [out]
                ULONG Flags;                    [in/out]
                int Depth;                      [out]
                int Height;                     [out]
                int Baseline;                   [out]
                struct hwUserTagList *UserTags; [in]
            };

        Here's an explanation of the individual structure members:

        Name:     This can be set to a string that contains the name of the
                  font. The string pointer must remain valid until @{"FreeFont()" LINK FreeFont} is
                  called.

        Adapter:  Users can specify the file adapter that should be used to open
                  certain files. If this member is non-NULL, Hollywood wants
                  your plugin to use the file adapter specified in "Adapter" to
                  open the file. This means that you have to use @{"hw_FOpenExt()" LINK hw_FOpenExt}
                  instead of @{"hw_FOpen()" LINK hw_FOpen} to open the file. See @{"hw_FOpenExt" LINK hw_FOpenExt} for
                  details.

        Palette:  If the font is a palette-based color font, you need to set
                  this member to a pointer to a palette, stored as a "ULONG"
                  array of 256 RGB colors. Note that the "ULONG" array must
                  always have 256 entries, even if the font's bit depth is less
                  than 8. Initialize unused palette entries to 0.

        TransPen: If the font is a palette-based color font and uses a
                  transparent pen, set this structure member to the index of the
                  pen that should appear transparent. Pen indices start from 0.
                  By default, pen 0 will appear transparent. If you want to have
                  no transparency, set this member to "HWPEN_NONE".

        Flags:    This field contains a combination of bit flags. Some can be
                  set by Hollywood before it calls LoadFont() and some flags can
                  be set by your plugin to pass information back to Hollywood.
                  The following flags are currently defined:

                  HWFONTFLAGS_VECTOR:
                            Set this flag if the font you have opened is a
                            vector font. This means that you must implement
                            @{"SetFontScale()" LINK SetFontScale} so that it applies a scaling factor
                            when Hollywood asks for it. If you also set
                            "HWFONTFLAGS_LAYOUT" (see below), you don't have to
                            implement @{"SetFontScale()" LINK SetFontScale} but in that case your
                            @{"RenderText()" LINK RenderText} implementation must be able to apply a
                            2D transformation matrix to the text before drawing.

                  HWFONTFLAGS_USEPOINTS:
                            Hollywood will set this flag if the size passed to
                            LoadFont() is in points instead of pixels. Your
                            implementation must look for this flag and act
                            accordingly.

                  HWFONTFLAGS_ANTIALIAS:
                            Set this flag if the font supports anti-aliasing.

                  HWFONTFLAGS_NOFILE:
                            Set this flag if the font passed to your LoadFont()
                            implementation in the "name" parameter isn't a file.
                            This is important to know for Hollywood's linker. If
                            "HWFONTFLAGS_NOFILE" isn't set, the linker will try
                            to link the font when compiling applets or
                            executables. This must be prevented for fonts that
                            do not directly exist as files. E.g. if your
                            LoadFont() function is passed "Arial" in "name" and
                            you don't set "HWFONTFLAGS_NOFILE", Hollywood's
                            linker will try to link a file named "Arial" which
                            will of course fail.

                  HWFONTFLAGS_LAYOUT:
                            Set this flag if your plugin wants to take over font
                            layouting completely. By default, Hollywood's font
                            layouter is used which means that Hollywood will
                            take care of handling word-wrapping, kerning,
                            justification, alignment, text formatting codes and
                            so on. This means that your plugin just needs to
                            deliver the glyph extents and bitmaps and Hollywood
                            will do the rest. If your plugin wants to its own
                            layouting, though, you can set the
                            "HWFONTFLAGS_LAYOUT" flag. In that case, Hollywood's
                            layouter won't be used at all for this font but your
                            plugin can do its own layouting.

        Depth:    This member must be set to the color depth of the font. Set
                  this to 1 for monochrome fonts, to 8 for fonts that support
                  anti-aliasing (i.e. 256 levels of gray) or to 32 for color
                  fonts with alpha transparency. If the "Palette" member is set
                  as well (see above), "Depth" must be a value between 1 and 8.
                  Note that if you set this to 8 with "Palette" set to NULL to
                  indicate that the font supports anti-aliasing your
                  @{"RenderText()" LINK RenderText} implementation must also be able to draw to a
                  1-bit monochrome target. In other words: Fonts that support
                  anti-aliasing must also support non-anti-aliased drawing.

        Height:   Set this to the font height in pixels.

        Baseline: Set this to the baseline of the font. Hollywood needs to know
                  the font's baseline to correctly position font styles like
                  underlining etc.

        UserTags: This member will be set to a list of user tags in case they
                  were specified in the Hollywood script. User tags are a way of
                  passing additional information from Hollywood scripts to
                  plugin functions. Note that even if your plugin doesn't
                  support any user tags, you should still look for this tag and
                  pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed
                  in "UserTags" could also be intended for another plugin,
                  namely the file adapter plugin passed in "Adapter". See @{"User" LINK UserTags}
                  @{"tags" LINK UserTags} for details.

        Please note that you should not use ANSI C functions like "fopen()" to
        open the file that is passed to this function because the filename that
        is passed to this function can also be a specially formatted filename
        specification that Hollywood uses to load files that have been linked to
        applets or executables. In order to be able to load these files
        correctly, you have to use special IO functions provided by Hollywood.
        See @{"File IO information" LINK FileIO} for details.

   @{b}INPUTS@{ub}
        name      name of the font to open; this isn't necessarily a file
        size      desired font size
        lf        pointer to a struct LoadFontCtrl that is used to exchange
                  further information
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        handle    a handle that identifies this font or NULL if the plugin
                  doesn't want to handle this font

@ENDNODE

@NODE MeasureText "Hollywood SDK"

   @{b}NAME@{ub}
        MeasureText -- measure text string (V10.0)

   @{b}SYNOPSIS@{ub}
        int error = MeasureText(APTR handle, STRPTR str, int count, int encoding,
                        struct hwTextExtent *te, struct hwTextLayout *tl, struct
                        hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must return the dimensions of the text passed in "str"
        when rendered with the font passed in "handle". Note that "str" is not
        null-terminated. Instead, the string's length in bytes is passed in the
        "count" parameter. The "encoding" parameter specifies the character
        encoding of the string. This will be either "HWOS_ENCODING_UTF8" or
        "HWOS_ENCODING_ISO8859_1".

        If the plugin hasn't set the "HWFONTFLAGS_LAYOUT" flag for the font in
        its @{"LoadFont()" LINK LoadFont} implementation, the string passed in "str" will never
        contain any line breaks. Handling line breaks is only necessary if your
        plugin has requested to do its own layouting by setting the
        "HWFONTFLAGS_LAYOUT" flag in @{"LoadFont()" LINK LoadFont}.

        Your MeasureText() implementation has to return the dimensions of the
        text in the "te" parameter that points to a struct hwTextExtent which
        looks like this:

            struct hwTextExtent
            {
                int MinX;    [out]
                int MinY;    [out]
                int MaxX;    [out]
                int MaxY;    [out]
                int Width;   [out]
                int Height;  [out]
            };

        Your implementation of MeasureText() must set all the structure members
        to the correct dimensions. Here is a description of the individual
        structure members:

        MinX:     Set this to the offset to the left side of the bounding box.
                  This can be negative when characters extend to the previous
                  character's area. This often happens with character such as
                  "j".

        MinY:     Set this to the offset from the baseline to the top of the
                  bounding box. This should always be negative.

        MaxX:     Set this to the offset to the right side of the bounding box.

        MaxY:     Set this to the offset from the baseline to the bottom of the
                  bounding box.

        Width:    Set this to the cursor advance that rendering the text will
                  cause.

        Height:   This should be set to the font height.

        All values are in struct hwTextExtent are in pixels.

        The "tl" parameter contains a pointer to a struct hwTextLayout. This
        structure contains detailed information about the text layout. Most of
        the structure members are only initialized for fonts that have requested
        to do their own layouting by setting the "HWFONTFLAGS_LAYOUT" flag in
        @{"LoadFont()" LINK LoadFont}. The only structure members that are supported for fonts
        that haven't set "HWFONTFLAGS_LAYOUT" are "CharSpacing" and "Style" but
        the only style flag that can be set for fonts that haven't set
        "HWFONTFLAGS_LAYOUT" is "HWFONTSTYLE_ANTIALIAS".

        struct hwTextLayout looks like this:

            struct hwTextLayout
            {
                ULONG Color;     [in]
                ULONG Style;     [in]
                int Align;       [in]
                int WrapWidth;   [in]
                int LineSpacing; [in]
                int CharSpacing; [in]
                int Indent;      [in]
                int AdvanceX;    [out]
                int AdvanceY;    [out]
                int *Tabs;       [in]
                int TabCount;    [in]
            };

        Here is a description of the individual structure members:

        Color:    The desired font color as an RGB value.

        Style:    A bit combination of style flags. The following style flags
                  are currently defined:

                  HWFONTSTYLE_ANTIALIAS:
                            Use anti-aliasing.

                  HWFONTSTYLE_BOLD:
                            Bold text.

                  HWFONTSTYLE_ITALIC:
                            Italic text.

                  HWFONTSTYLE_UNDERLINED:
                            Underlined text.

        Align:    The desired text alignment. This can be one of the following
                  alignment types:

                  HWTEXTALIGN_LEFT:
                            Left alignment.

                  HWTEXTALIGN_RIGHT:
                            Right alignment.

                  HWTEXTALIGN_CENTER:
                            Centered alignment.

                  HWTEXTALIGN_JUSTIFIED:
                            Justified alignment.

        WrapWidth:
                  The maximum number of pixels per line. If a word exceeds this
                  number of pixels, it should be moved to the next line. If this
                  is 0, then no wordwrapping should take place.

        LineSpacing:
                  Adjustment pixels between lines. This can be a positive or
                  negative value. A negative value moves lines closer together,
                  whereas a positive value increases the spacing between lines.
                  A value of 0 means no custom line adjustment.

        CharSpacing:
                  Adjustment pixels between characters. This can be a positive
                  or negative value. A negative value moves characters closer
                  together, whereas a positive value increases the spacing
                  between characters. A value of 0 means no custom character
                  adjustment.

        Indent:   The indentation in pixels for the very first line of text. If
                  this is greater than 0, text on the very first line should be
                  indented by this number of pixels.

        AdvanceX: This must be set to the number of pixels the cursor should be
                  advanced horizontally after drawing the text.

        AdvanceY: This must be set to the number of pixels the cursor should be
                  advanced vertically after drawing the text.

        Tabs:     An integer array containing a number of tab stops. Whenever a
                  tab character is encountered, your text layouter should
                  advance to the next tab stop. The number of tab stops in the
                  "Tabs" array is indicated by the "TabCount" member (see
                  below). Note that this can also be NULL.

        TabCount: Number of tab stops in the "Tab" member (see above).

   @{b}INPUTS@{ub}
        handle    the font handle allocated by @{"LoadFont()" LINK LoadFont}
        str       text to measure (this is not null-terminated!)
        count     length of the text to measure in bytes
        encoding  character encoding of the text (see above)
        te        pointer to a struct hwTextExtent that receives the text's
                  dimensions
        tl        pointer to a struct hwTextLayout that contains layout
                  information
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE RenderText "Hollywood SDK"

   @{b}NAME@{ub}
        RenderText -- draw text string (V10.0)

   @{b}SYNOPSIS@{ub}
        int error = RenderText(APTR handle, STRPTR str, int count, int encoding,
                        struct hwRenderTextCtrl *pt, struct hwMatrix2D *m, struct
                        hwTextLayout *tl, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must draw the text passed in "str" using the font passed
        in "handle". Note that "str" is not null-terminated. Instead, the
        string's length in bytes is passed in the "count" parameter. The
        "encoding" parameter specifies the character encoding of the string.
        This will be either "HWOS_ENCODING_UTF8" or "HWOS_ENCODING_ISO8859_1".

        If the plugin hasn't set the "HWFONTFLAGS_LAYOUT" flag for the font in
        its @{"LoadFont()" LINK LoadFont} implementation, the string passed in "str" will never
        contain any line breaks. Handling line breaks is only necessary if your
        plugin has requested to do its own layouting by setting the
        "HWFONTFLAGS_LAYOUT" flag in @{"LoadFont()" LINK LoadFont}.

        The drawing target is passed to RenderText() in the "pt" parameter. This
        is a pointer to a struct hwRenderTextCtrl describing a drawing target.
        struct hwRenderTextCtrl looks like this:

            struct hwRenderTextCtrl
            {
                int X;             [in]
                int Y;             [in]
                int Width;         [in]
                int Height;        [in]
                APTR RGBData;      [in]
                int RGBModulo;     [in]
                UBYTE *AlphaData;  [in]
                int AlphaModulo;   [in]
                UBYTE *MaskData;   [in]
                int MaskModulo;    [in]
                UBYTE *CLUTData;   [in]
                int CLUTModulo;    [in]
                int PixelFormat;   [in]
                int BytesPerPixel; [in]
            };

        Here is a description of the individual structure members:

        X:        This specifies the x-offset you should draw to in the target
                  buffer. An offset of 0 means the leftmost column.

        Y:        This specifies the y-offset you should draw to in the target
                  buffer. An offset of 0 means the topmost row.

        Width:    This will be set to the target buffer's pixel width, without
                  any row padding.

        Height:   This will be set to the target buffer's pixel height.

        RGBData:  If the font's color depth has been set to more than 8 in
                  @{"LoadFont()" LINK LoadFont}, this member will be set to a pointer to the raw
                  RGB pixel data to draw to. The actual format used by the
                  individual pixels is defined by the "PixelFormat" member.
                  Please note that even if "PixelFormat" specifies a 32-bit
                  format with alpha channel, you must never draw any alpha
                  channel pixels to "RGBData" because Hollywood always stores
                  the alpha channel separately in order to be compatible with
                  15-bit and 16-bit screenmodes. See @{"Bitmap information" LINK BitmapInfo} for
                  details. You always need to draw the alpha channel pixels to
                  the buffer passed in "AlphaData" instead.

        RGBModulo:
                  If "RGBData" is non-NULL, this will contain the number of
                  pixels in a single row in the "RGBData" buffer. This can be
                  more than returned in "Width" because Hollywood might choose
                  to allocate some padding bytes for optimized blitting. Note
                  that the value returned in "RGBModulo" is specified in pixels,
                  not in bytes.

        AlphaData:
                  This member will be set in the following two cases:

                  1. The font is an RGB color font. In that case you have to
                     draw the color channels to the buffer passed in "RGBData"
                     and the alpha channel pixels to the buffer passed in
                     "AlphaData".
                  2. The text should be drawn with anti-aliasing. In that case
                     you only have to draw to the buffer passed in "AlphaData".

                  In all other cases "AlphaData" will be NULL.

        AlphaModulo:
                  If "AlphaData" is non-NULL, this member will be set to the
                  number of pixels stored in one row of the "AlphaData" array.
                  This can be more than what is returned in the "Width" member
                  because Hollywood might use padding bytes for optimized
                  blitting.

        MaskData: You have to draw to this buffer in case the font's color depth
                  has been set to 1 or the font's color depth has been set to 8
                  and anti-aliasing is turned off. In both cases, "MaskData"
                  will be set to a buffer you need to draw to. Otherwise it is
                  set to NULL. The data you write to this buffer is interpreted
                  as a monochrome bitmap where set bits indicate visible pixels
                  and cleared bits indicate invisible pixels. The bits are
                  stored from left to right in chunks of one byte, i.e. the most
                  significant bit of the first byte describes the state of the
                  first pixel.

        MaskModulo:
                  If "MaskData" is non-NULL, this member will be set to the
                  number of bytes that is used for one row of mask data. Note
                  that this value is specified in bytes and often contains some
                  padding.

        CLUTData: You have to draw to this buffer in case the font uses a color
                  palette. Otherwise this member will be NULL. Note that pixels
                  will always be stored as 8 bits per pixel, even if the font
                  palette's depth is less than 8.

        CLUTModulo:
                  If "CLUTData" is non-NULL, this will be set to the number of
                  pixels per row. This can be more than what is returned in the
                  "Width" member because Hollywood might use padding bytes for
                  optimized blitting.

        PixelFormat:
                  This member is set to the pixel format used by the pixels
                  written to the "RGBData" member. See @{"Pixel format information" LINK PixelFormats}
                  for details.

        BytesPerPixel:
                  This will be set to the number of bytes that are needed to
                  represent one pixel in the "RGBData" array.

        The "m" parameter may be set to a pointer to a 2D transformation matrix
        that should be applied to the text before drawing. If can also be NULL
        which means the identity matrix should be used. Note that "m" will only
        ever be set if the font is a vector font and if the plugin has requested
        to do its own layouting by setting the "HWFONTFLAGS_LAYOUT" flag in
        @{"LoadFont()" LINK LoadFont}.

        The "tl" parameter contains a pointer to a struct hwTextLayout. This
        structure contains detailed information about the text layout. Most of
        the structure members are only initialized for fonts that have requested
        to do their own layouting by setting the "HWFONTFLAGS_LAYOUT" flag in
        @{"LoadFont()" LINK LoadFont}. The only structure members that are supported for fonts
        that haven't set "HWFONTFLAGS_LAYOUT" are "CharSpacing" and "Style" but
        the only style flag that can be set for fonts that haven't set
        "HWFONTFLAGS_LAYOUT" is "HWFONTSTYLE_ANTIALIAS".

        struct hwTextLayout looks like this:

            struct hwTextLayout
            {
                ULONG Color;     [in]
                ULONG Style;     [in]
                int Align;       [in]
                int WrapWidth;   [in]
                int LineSpacing; [in]
                int CharSpacing; [in]
                int Indent;      [in]
                int AdvanceX;    [out]
                int AdvanceY;    [out]
                int *Tabs;       [in]
                int TabCount;    [in]
            };

        Here is a description of the individual structure members:

        Color:    The desired font color as an RGB value.

        Style:    A bit combination of style flags. The following style flags
                  are currently defined:

                  HWFONTSTYLE_ANTIALIAS:
                            Use anti-aliasing.

                  HWFONTSTYLE_BOLD:
                            Bold text.

                  HWFONTSTYLE_ITALIC:
                            Italic text.

                  HWFONTSTYLE_UNDERLINED:
                            Underlined text.

        Align:    The desired text alignment. This can be one of the following
                  alignment types:

                  HWTEXTALIGN_LEFT:
                            Left alignment.

                  HWTEXTALIGN_RIGHT:
                            Right alignment.

                  HWTEXTALIGN_CENTER:
                            Centered alignment.

                  HWTEXTALIGN_JUSTIFIED:
                            Justified alignment.

        WrapWidth:
                  The maximum number of pixels per line. If a word exceeds this
                  number of pixels, it should be moved to the next line. If this
                  is 0, then no wordwrapping should take place.

        LineSpacing:
                  Adjustment pixels between lines. This can be a positive or
                  negative value. A negative value moves lines closer together,
                  whereas a positive value increases the spacing between lines.
                  A value of 0 means no custom line adjustment.

        CharSpacing:
                  Adjustment pixels between characters. This can be a positive
                  or negative value. A negative value moves characters closer
                  together, whereas a positive value increases the spacing
                  between characters. A value of 0 means no custom character
                  adjustment.

        Indent:   The indentation in pixels for the very first line of text. If
                  this is greater than 0, text on the very first line should be
                  indented by this number of pixels.

        AdvanceX: This must be set to the number of pixels the cursor should be
                  advanced horizontally after drawing the text.

        AdvanceY: This must be set to the number of pixels the cursor should be
                  advanced vertically after drawing the text.

        Tabs:     An integer array containing a number of tab stops. Whenever a
                  tab character is encountered, your text layouter should
                  advance to the next tab stop. The number of tab stops in the
                  "Tabs" array is indicated by the "TabCount" member (see
                  below). Note that this can also be NULL.

        TabCount: Number of tab stops in the "Tab" member (see above).

   @{b}INPUTS@{ub}
        handle    the font handle allocated by @{"LoadFont()" LINK LoadFont}
        str       text to draw (this is not null-terminated!)
        count     length of the text to draw in bytes
        encoding  character encoding of the text (see above)
        pt        pointer to a struct hwRenderTextCtrl containing information
                  about the drawing target
        m         pointer to a 2D transformation matrix that should be applied
                  before drawing or NULL
        tl        pointer to a struct hwTextLayout that contains layout
                  information
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE SetFontScale "Hollywood SDK"

   @{b}NAME@{ub}
        SetFontScale -- apply scaling factor to font (V10.0)

   @{b}SYNOPSIS@{ub}
        int error = SetFontScale(APTR handle, double *sx, double *sy, struct
                        hwTagList *tags);

   @{b}FUNCTION@{ub}
        If your @{"LoadFont()" LINK LoadFont} implementation has indicated that the font is a
        vector font by setting the "HWFONTFLAGS_VECTOR" flag, SetFontScale()
        needs to apply the scaling coefficients passed in "sx" and "sy" to the
        font. Note that these are passed as pointers to "double" solely for
        compatibility with WarpOS. You must not write anything to these
        pointers, they are just for reading.

        Note that if your @{"LoadFont()" LINK LoadFont} implementation has set the
        "HWFONTFLAGS_LAYOUT" flag, SetFontScale() will never be called. In that
        case, any scaling coefficients will be passed to your @{"RenderText()" LINK RenderText}
        implementation as a 2D transformation matrix.

        Since applying scaling coefficients can always lead to floating point
        inaccuracies, your implementation of SetFontScale() should always pass
        the scaled pixel height and baseline of the font back to Hollywood. This
        is done using the tag list passed to SetFontScale() in the "tags"
        parameter. The tag list can contain the following tags:

        HWFONTSCALETAG_HEIGHT:
                  The "pData" member of the tag contains a pointer to an "int"
                  that you should write the new font height in pixels to.

        HWFONTSCALETAG_BASELINE:
                  The "pData" member of the tag contains a pointer to an "int"
                  that you should write the new font baseline in pixels to.

   @{b}INPUTS@{ub}
        handle    the font handle allocated by @{"LoadFont()" LINK LoadFont}
        sx        x scaling coefficient passed as a pointer to a "double"
        sy        y scaling coefficient passed as a pointer to a "double"
        tags      tag list containing further options

   @{b}RESULTS@{ub}
        error     error code or 0 for success

@ENDNODE

@NODE IconOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_ICON" set will be called
    whenever Hollywood has to load an icon. The plugin can check then whether
    the icon is in a format that the plugin recognizes and if it is, it can open
    the icon and return the icon's images to Hollywood. This makes it possible
    to load custom icon formats with Hollywood.

    By default, icon plugins are automatically activated when Hollywood loads
    them. This behaviour can be changed by setting the "HWEXT_ICON_NOAUTOINIT"
    extension bit. If this bit is set, Hollywood will not automatically activate
    your plugin at load time. Instead, you will have to manually call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to activate your plugin. For example, you could call
    @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} from your @{"RequirePlugin()" LINK RequirePlugin} implementation. In that
    case, the icon plugin would only be activated if the user called "\@REQUIRE"
    on it. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} on a plugin that has
    auto-initialization disabled, it will only be available if the user
    addresses it directly through the "Loader" tag. See @{"Extension plugins" LINK ExtensionOverview} to
    learn how to use plugin extension bits.

    Note that icon plugins need not implement all functions offered by the icon
    plugin API. Some functions are optional and need only be implemented in
    specific cases. Here's a list of optional functions:

    GetIconFormat()
              Only used if you set the "HWEXT_ICON_FORMAT" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    This plugin type is supported since Hollywood 9.0.

    @{"FreeIcon()                        " LINK FreeIcon} Free icon handle
    @{"GetIconFormat()                   " LINK GetIconFormat} Get icon format name
    @{"GetIconImages()                   " LINK GetIconImages} Get all images inside icon
    @{"LoadIcon()                        " LINK LoadIcon} Load icon into memory
@ENDNODE

@NODE FreeIcon "Hollywood SDK"

   @{b}NAME@{ub}
        FreeIcon -- free icon handle (V9.0)

   @{b}SYNOPSIS@{ub}
        void FreeIcon(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free the specified icon handle that has been
        allocated by your plugin's @{"LoadIcon()" LINK LoadIcon} function. Hollywood will call
        FreeIcon() when it is done with your icon.

   @{b}INPUTS@{ub}
        handle    icon handle returned by @{"LoadIcon()" LINK LoadIcon}

@ENDNODE

@NODE GetIconFormat "Hollywood SDK"

   @{b}NAME@{ub}
        GetIconFormat -- get icon format name (V10.0)

   @{b}SYNOPSIS@{ub}
        STRPTR name = GetIconFormat(APTR handle);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_ICON_FORMAT" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, this function must return a
        null-terminated string containing name of the format of the icon file
        handle passed in "handle". The string returned by this function can be
        retrieved from Hollywood scripts by querying the #ATTRFORMAT attribute
        on the #ICON object type. The string you return must be valid until
        @{"FreeIcon()" LINK FreeIcon} is called on the image handle passed to this function.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"LoadIcon()" LINK LoadIcon}

   @{b}RESULTS@{ub}
        name      icon format name

@ENDNODE

@NODE GetIconImages "Hollywood SDK"

   @{b}NAME@{ub}
        GetIconImages -- get all images inside icon (V9.0)

   @{b}SYNOPSIS@{ub}
        struct hwIconList *list = GetIconImages(APTR handle, struct hwTagList
                                      *tags);

   @{b}FUNCTION@{ub}
        This function must return a list of all images stored inside an icon
        object. It is expected to return a pointer to the first node of a struct
        hwIconList list.

        Note that your plugin is responsible for freeing the list returned by
        this function. The list can't be freed by @{"hw_FreeIcons()" LINK hw_FreeIcons} because it has
        been allocated by your plugin. You may free a list returned by
        GetIconImages() as soon as Hollywood calls GetIconImages() again or when
        Hollywood calls your @{"ClosePlugin()" LINK ClosePlugin} function.

        The struct hwIconList that GetIconImages() needs to return looks like
        this:

            struct hwIconList
            {
                struct hwIconList *Succ;
                APTR Data;
                int Width;
                int Height;
                ULONG Flags;
                ULONG *Palette;
                ULONG TransPen;
                int Depth;
                APTR UserData;
            };

        For each node in the list, struct hw_IconList must be initialized as
        follows:

        Succ:     Must be set to a pointer to the next list node or NULL if this
                  node is the last one.

        Data:     Must be set to the image's pixel data. For RGB images, this
                  must be set to a 32-bit ARGB pixel buffer, for CLUT images to
                  an 8-bit pixel buffer. For 32-bit images the alpha byte must
                  always be set for every pixel. For CLUT images, you must also
                  set the "Palette" member (see below). The pixel buffer's size
                  must be exactly width * height * bpp. No row padding must be
                  used.

        Width:    Must be set to the image's width.

        Height:   Must be set to the image's height.

        Flags:    Must be set to a combination of flags for this image. The
                  following flags are currently supported:

                  HWICONFLAGS_DEFAULT:
                            This flag marks the default icon. Hollywood's icon
                            type allows scripts to designate an icon as the
                            default one. It's up to you how you interpret and
                            handle the default icon.

                  HWICONFLAGS_SELECTED:
                            If this flag is set, the image in this list node
                            describes a selected icon state. On AmigaOS and
                            compatibles, icon images usually have two states:
                            normal and selected. You can set this flag to mark
                            an image as selected.

                  HWICONFLAGS_OPAQUE:
                            This flag should be set if the image doesn't use any
                            transparency and all alpha bytes are set to 255
                            (i.e. visible).

        Palette:  If the image is a CLUT image, this must be set to a pointer to
                  an array of "ULONGs" which contains the palette colors for the
                  image. The palette colors are stored as raw RGB values. Note
                  that this must always be set to a buffer containing 256
                  "ULONG" entries. Even if you set "Depth" to something less
                  than 8, the palette you specify here must still contain 256
                  entries.

        TransPen: If the image is a CLUT image and has a transparent pen, set
                  this member to the pen that should be transparent. If there is
                  no transparent pen, set "TransPen" to "HWPEN_NONE".

        Depth:    Set this to the image's depth. This must be a bit depth either
                  between 1 and 8 for CLUT images or 32 for RGB images with
                  alpha channel. Do not set it to anything else.

   @{b}DESIGNER COMPATIBILITY@{ub}
        Unsupported

   @{b}INPUTS@{ub}
        handle    icon handle returned by @{"LoadIcon()" LINK LoadIcon}
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        list      a list containing all images in the icon object or NULL on
                  error

@ENDNODE

@NODE LoadIcon "Hollywood SDK"

   @{b}NAME@{ub}
        LoadIcon -- load icon into memory (V9.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = LoadIcon(STRPTR filename, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to open the specified filename, check if it is in a
        format that the plugin wants to handle, and, if it is, return a handle
        to the icon back to Hollywood. Otherwise it has to return NULL. The
        handle returned by LoadIcon() is an opaque datatype that only your
        plugin knows about. Hollywood will simply pass this handle back to your
        @{"GetIconImages()" LINK GetIconImages} function when it wants to get the individual images in
        your icon.

        Hollywood may also pass a tag list to your LoadIcon() implementation.
        This list may contain the following tags:

        HWLDICONTAG_ADAPTER:
                  If this tag is specified, Hollywood wants your plugin to use
                  the file adapter specified by the string stored in the "pData"
                  member to open the icon. This means that you have to use
                  @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of @{"hw_FOpen()" LINK hw_FOpen} to open the icon file
                  because the former doesn't support file adapters. See
                  @{"hw_FOpenExt" LINK hw_FOpenExt} for details.

        HWLDICONTAG_AMIGAEXT:
                  If this tag is set, "pData" points to a struct hwIconAmigaExt
                  that your plugin can initialize with metadata obtained from
                  the icon. This is for compatibility with Amiga icons which
                  contain metadata in addition to the image data. struct
                  hwIconAmigaExt looks like this:

                      struct hwIconAmigaExt
                      {
                          int Type;
                          int ViewMode;
                          int IconX;
                          int IconY;
                          int DrawerX;
                          int DrawerY;
                          int DrawerWidth;
                          int DrawerHeight;
                          int StackSize;
                          STRPTR DefaultTool;
                          STRPTR *ToolTypes;
                          ULONG Flags;
                      };

                  Here's an explanation of the individual structure members:

                  Type:     This must be set to the icon's type. This can be one
                            of the following predefined constants:

                                HWAMIGAICON_NONE
                                HWAMIGAICON_DISK
                                HWAMIGAICON_DRAWER
                                HWAMIGAICON_TOOL
                                HWAMIGAICON_PROJECT
                                HWAMIGAICON_GARBAGE
                                HWAMIGAICON_DEVICE
                                HWAMIGAICON_KICKSTART

                  ViewMode: This must be set to the icon's view mode. This can
                            be one of the following predefined constants:

                                HWAMIGAICONMODE_NONE
                                HWAMIGAICONMODE_ICONS
                                HWAMIGAICONMODE_NAME
                                HWAMIGAICONMODE_DATE
                                HWAMIGAICONMODE_SIZE
                                HWAMIGAICONMODE_TYPE

                  IconX:    The icon's x position on Workbench screen.

                  IconY:    The icon's y position on Workbench screen.

                  DrawerX:  In case "Type" is set to a container type like
                            "HWAMIGAICON_DRAWER", set this to the x position of
                            the new window that will be opened when
                            double-clicking the icon.

                  DrawerY:  In case "Type" is set to a container type like
                            "HWAMIGAICON_DRAWER", set this to the y position of
                            the new window that will be opened when
                            double-clicking the icon.

                  DrawerWidth:
                            In case "Type" is set to a container type like
                            "HWAMIGAICON_DRAWER", set this to the width of the
                            new window that will be opened when double-clicking
                            the icon.

                  DrawerHeight:
                            In case "Type" is set to a container type like
                            "HWAMIGAICON_DRAWER", set this to the height of the
                            new window that will be opened when double-clicking
                            the icon.

                  StackSize:
                            In case "Type" is set to "HWAMIGAICON_TOOL" or
                            "HWAMIGAICON_PROJECT", the desired stack size for
                            the program to be launched.

                  DefaultTool:
                            In case "Type" is set to "HWAMIGAICON_PROJECT", this
                            must be set to a null-terminated string containing
                            name (and optionally path) of the program to open
                            the file with.

                  ToolTypes:
                            If the icon has tooltypes, store them in this field.
                            If set, this must be an array of "STRPTR", each
                            array item containing a single tooltype stored as a
                            null-terminated string. The array you pass here must
                            be terminated by a NULL entry which must be the last
                            one.

                  Flags:    This structure member may be set to a combination of
                            the following flags:

                            HWAMIGAICONFLAGS_VIEWALL:
                                      If this is set and "Type" is a container
                                      type like "HWAMIGAICON_DRAWER", all files
                                      will be visible, not only those that have
                                      an icon.

        HWLDICONTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. Note that even if your
                  plugin doesn't support any user tags, you should still look
                  for this tag and pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the
                  user tags passed in "UserTags" could also be intended for
                  another plugin, namely the file adapter plugin passed in
                  "Adapter". See @{"User tags" LINK UserTags} for details. (V10.0)

        Please note that you should not use ANSI C functions like "fopen()" to
        open the file that is passed to this function because the filename that
        is passed to this function can also be a specially formatted filename
        specification that Hollywood uses to load files that have been linked to
        applets or executables. In order to be able to load these files
        correctly, you have to use special IO functions provided by Hollywood.
        See @{"File IO information" LINK FileIO} for details.

   @{b}INPUTS@{ub}
        filename  filename to open
        tags      tag list containing further options or NULL

   @{b}RESULTS@{ub}
        handle    a handle that identifies this icon or NULL if plugin doesn't
                  want to handle this icon

@ENDNODE

@NODE IconSaverOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_SAVEICON" set can
    register one or more additional output icon formats. The user will then be
    able to save icons in the output formats supported by the plugin. Plugins
    have to register new output icon formats by passing the name of a constant
    that should be used to access the new format. For example, a plugin might
    choose to register a new output icon format under the constant
    #ICNFMT_CUSTOMFORMAT. Whenever the user calls "SaveIcon()" now and passes
    #ICNFMT_CUSTOMFORMAT as the icon format, Hollywood will ask the plugin to
    save the icon.

    This plugin type is supported since Hollywood 9.0.

    @{"RegisterIconSaver()               " LINK RegisterIconSaver} Register a new icon saver
    @{"SaveIcon()                        " LINK SaveIcon} Save icon to disk
@ENDNODE

@NODE RegisterIconSaver "Hollywood SDK"

   @{b}NAME@{ub}
        RegisterIconSaver -- register a new icon saver (V9.0)

   @{b}SYNOPSIS@{ub}
        void RegisterIconSaver(struct SaveIconReg *reg)

   @{b}FUNCTION@{ub}
        Hollywood will call this function to get information about the icon
        saver your plugin wants to register. In addition, RegisterIconSaver()
        has to tell Hollywood whether it wants to register another icon saver.
        Hollywood will pass a pointer to a struct SaveIconReg to this function.
        This structure looks like this:

            struct SaveFormatReg
            {
                ULONG CapsMask;     [out]
                ULONG FormatID;     [in/out]
                STRPTR FormatName;  [out]
            };

            struct SaveIconReg
            {
                struct SaveFormatReg hdr;
            };

        Your implementation has to do the following with the individual
        structure members:

        CapsMask: This must be set to a combination of flags that tell Hollywood
                  about the capabilities of the icon saver that is to be
                  registered. The following flags are currently supported:

                  HWSAVEICNCAPS_MORE:
                            If you set this flag, Hollywood will call
                            RegisterIconSaver() again so that you can register
                            another saver. If you don't want to register another
                            saver, don't set this flag.

        FormatID: This member must be set to a unique 32-bit value that should
                  be assigned to the constant that is registered for accessing
                  this icon saver from Hollywood scripts. Values smaller than
                  32768 are reserved for internal Hollywood use. You may use
                  values larger than 32768 for your saver but if you want to
                  publish your plugin, you need to contact Airsoft Softwair to
                  obtain a unique value that is still vacant. This won't cost
                  you anything; it's just needed to make sure that plugin icon
                  savers don't use conflicting identifiers. Also, once you have
                  published your icon saver plugin, the "FormatID" you have
                  specified must not be changed or you will break compatibility
                  with applets or executables that have been compiled with
                  previous versions. If you are registering more than one icon
                  saver using "HWSAVEICNCAPS_MORE", you can look at the
                  "FormatID" member to tell how many times Hollywood has already
                  called RegisterIconSaver() because "FormatID" will contain the
                  identifier of the last icon saver you registered. If
                  "FormatID" is 0, then this is the first call to
                  RegisterIconSaver(). Note that it is not recommended to keep
                  your own counter because Hollywood might call
                  RegisterIconSaver() multiple times, i.e. it might first loop
                  over RegisterIconSaver() to determine how many icon savers
                  there are in total and then it might loop over
                  RegisterIconSaver() again to actually register their names.

        FormatName:
                  This must be set to a string that should form the second half
                  of the constant that Hollywood registers for your icon saver.
                  The string you specify here must follow the naming
                  restrictions for Hollywood constants, i.e. only alphabetical
                  characters, numbers and very few special characters like the
                  underscore character are allowed. The #ICNFMT_ prefix must not
                  be included in the string you pass. Hollywood will add this
                  automatically, i.e. if you pass the string "TESTFORMAT" here,
                  Hollywood will make your icon saver available under the
                  constant #ICNFMT_TESTFORMAT.

   @{b}INPUTS@{ub}
        reg       pointer to a struct SaveIconReg to be filled out by your
                  implementation

@ENDNODE

@NODE SaveIcon "Hollywood SDK"

   @{b}NAME@{ub}
        SaveIcon -- save icon to disk (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = SaveIcon(STRPTR filename, struct hwIconList *list, struct
                     hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function must save the icon to the specified filename. The icon's
        images are passed to SaveIcon() in the form of a struct hwIconList that
        contains one node per image.

        struct hwIconList looks like this:

            struct hwIconList
            {
                struct hwIconList *Succ;
                APTR Data;
                int Width;
                int Height;
                ULONG Flags;
                ULONG *Palette;
                ULONG TransPen;
                int Depth;
                APTR UserData;
            };

        For each node in the list, struct hw_IconList will be initialized as
        follows:

        Succ:     Will be set to a pointer to the next list node or NULL if this
                  node is the last one.

        Data:     Will be set to the image's pixel data. For RGB images, this
                  will be set to a 32-bit ARGB pixel buffer, for CLUT images to
                  an 8-bit pixel buffer. For 32-bit images the alpha byte will
                  always be set for every pixel. For CLUT images, the "Palette"
                  member (see below) will be set. The pixel buffer's size will
                  be exactly width * height * bpp. No row padding will be used.

        Width:    Contains the image's width in pixels.

        Height:   Contains the image's height in pixels.

        Flags:    May be set to a combination of flags for this image. The
                  following flags are currently supported:

                  HWICONFLAGS_DEFAULT:
                            This flag marks the default icon. Hollywood's icon
                            type allows scripts to designate an icon as the
                            default one. It's up to you how you interpret and
                            handle the default icon.

                  HWICONFLAGS_SELECTED:
                            If this flag is set, the image in this list node
                            describes a selected icon state. On AmigaOS and
                            compatibles, icon images usually have two states:
                            normal and selected. This flag will be used to mark
                            an image as the selected image.

                  HWICONFLAGS_OPAQUE:
                            This flag will be set if the image doesn't use any
                            transparency and all alpha bytes are set to 255
                            (i.e. visible).

        Palette:  If the image is a CLUT image, this will be set to a pointer to
                  an array of "ULONGs" which contains the palette colors for the
                  image. The palette colors are stored as raw RGB values.

        TransPen: If the image is a CLUT image and has a transparent pen, this
                  member will be set to the pen that should be transparent. If
                  there is no transparent pen, this will be set to "HWPEN_NONE".

        Depth:    This will be set to the image's depth. This will be a bit
                  depth either between 1 and 8 for CLUT images or 32 for RGB
                  images with alpha channel.

        The "tags" argument will be set to a tag list that can contain the
        following tags:

        HWSVICONTAG_FORMAT:
                  This tag contains the identifier of the icon format the file
                  should be saved in. You only need to handle this tag if your
                  plugin supports more than one output icon format.
                  Nevertheless, this tag will always be present.

        HWSVICONTAG_COMPRESSION:
                  Hollywood's "SaveIcon()" function allows scripts to specify a
                  compression level between 0 and 100 because some icon formats
                  might use lossy compression. "HWSVICONTAG_COMPRESSION" will
                  simply forward the specified compression level to your plugin.

        HWSVICONTAG_AMIGAEXT:
                  If this tag is present, the "pData" member of it will be set
                  to a struct hwIconAmigaExt pointer. This structure is used for
                  storing metadata that is present in every Amiga icon. See
                  @{"LoadIcon" LINK LoadIcon} for a detailed description of this structure.

        HWSVICONTAG_ADAPTER:
                  Starting with Hollywood 10.0, users can specify the file
                  adapter that should be used to save an icon. If this tag is
                  set, Hollywood wants your plugin to use the file adapter
                  specified in the "pData" member of the tag to save the icon.
                  This means that you have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of
                  @{"hw_FOpen()" LINK hw_FOpen} to save the icon. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details.
                  (V10.0)

        HWSVICONTAG_USERTAGS:
                  If this is set, "pData" will point to a struct hwUserTagList
                  containing a list of user tags passed by the Hollywood script.
                  User tags are a way of passing additional information from
                  Hollywood scripts to plugin functions. Note that even if your
                  plugin doesn't support any user tags, you should still look
                  for this tag and pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the
                  user tags passed in "UserTags" could also be intended for
                  another plugin, namely the file adapter plugin passed in
                  "Adapter". See @{"User tags" LINK UserTags} for details. (V10.0)

        This function has to return TRUE if the image has been successfully
        saved or FALSE in case of an error.

   @{b}INPUTS@{ub}
        filename  path to a destination file
        list      linked list of all images that should be saved to the icon
        tags      tag list containing further parameters

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE ImageOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_IMAGE" set will be called
    whenever Hollywood has to load an image. The plugin can check then whether
    the image is in a format that the plugin recognizes and if it is, it can
    open the image and return the raw pixel data to Hollywood. This makes it
    possible to load custom image formats with Hollywood.

    Image plugins can support two different image types: Raster and vector
    images. If your plugin supports vector images, Hollywood will always call
    your plugin whenever it needs to transform the image. Your plugin can then
    do the lossless vector image transformation on its own and return the new
    pixel data to Hollywood. For raster images, image transformation is always
    done by Hollywood and your plugin doesn't have to do anything.

    By default, image plugins are automatically activated when Hollywood loads
    them. Starting with Hollywood 6.0 this behaviour can be changed by setting
    the "HWEXT_IMAGE_NOAUTOINIT" extension bit. If this bit is set, Hollywood
    will not automatically activate your plugin at load time. Instead, you will
    have to manually call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} to activate your plugin. For
    example, you could call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter} from your @{"RequirePlugin()" LINK RequirePlugin}
    implementation. In that case, the image plugin would only be activated if
    the user called "\@REQUIRE" on it. If you do not call @{"hw_AddLoaderAdapter()" LINK hw_AddLoaderAdapter}
    on a plugin that has auto-initialization disabled, it will only be available
    if the user addresses it directly through the "Loader" tag. See @{"Extension" LINK ExtensionOverview}
    @{"plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    Note that image plugins need not implement all functions offered by the
    image plugin API. Some functions are optional and need only be implemented
    in specific cases. Here's a list of optional functions:

    GetImageFormat()
              Only used if you set the "HWEXT_IMAGE_FORMAT" extension flag. See
              @{"Extension plugins" LINK ExtensionOverview} to learn how to use plugin extension bits.

    The SDK distribution comes with an example image plugin which contains a
    loader for the PCX image format. Feel free to study this example code to
    learn how image plugins are written in practice.

    @{"FreeImage()                       " LINK FreeImage} Free image handle
    @{"GetImage()                        " LINK GetImage} Get raw pixel image data
    @{"GetImageFormat()                  " LINK GetImageFormat} Get image format name
    @{"IsImage()                         " LINK IsImage} Check if a file is in a supported image format
    @{"LoadImage()                       " LINK LoadImage} Load image into memory
    @{"TransformImage()                  " LINK TransformImage} Transform a vector image
@ENDNODE

@NODE FreeImage "Hollywood SDK"

   @{b}NAME@{ub}
        FreeImage -- free image handle (V5.0)

   @{b}SYNOPSIS@{ub}
        void FreeImage(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free the specified image handle that has been
        allocated by your plugin's @{"LoadImage()" LINK LoadImage} function. Hollywood will call
        FreeImage() when it is done with your image.

   @{b}INPUTS@{ub}
        handle    image handle returned by @{"LoadImage()" LINK LoadImage}

@ENDNODE

@NODE GetImage "Hollywood SDK"

   @{b}NAME@{ub}
        GetImage -- get raw pixel image data (V5.0)

   @{b}SYNOPSIS@{ub}
        ULONG *raw = GetImage(APTR handle, struct LoadImageCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function must return the image's raw pixel data and some
        information about it.

        Note that the ULONG* return type is just for compatibility reasons. The
        actual format of the pixel data that GetImage() needs to return depends
        on whether the "HWIMGFLAGS_LOADPALETTE" flag was set when @{"LoadImage()" LINK LoadImage}
        was called. If it was set, GetImage() needs to return 8-bit pen values
        (even if the bit depth of the image is less than 8-bit!). If
        "HWIMGFLAGS_LOADPALETTE" wasn't set, GetImage() needs to return 32-bit
        ARGB values.

        If the image type is "HWIMAGETYPE_VECTOR", GetImage() also needs to take
        possible transformations that have been applied via @{"TransformImage()" LINK TransformImage}
        into account.

        Furthermore, GetImage() has to provide some additional information in
        the struct LoadImageCtrl pointer that is passed as the second parameter.
        See @{"LoadImage" LINK LoadImage} for details on this structure. The following information
        has to be provided by GetImage():

        Width:    Must be set to the image width in pixels. If the image type is
                  "HWIMAGETYPE_VECTOR" and @{"TransformImage()" LINK TransformImage} has been called
                  prior to GetImage(), this value must exactly match the width
                  that has been passed to the last call of @{"TransformImage()" LINK TransformImage}.

        Height:   Must be set to the image height in pixels. If the image type
                  is "HWIMAGETYPE_VECTOR" and @{"TransformImage()" LINK TransformImage} has been called
                  prior to GetImage(), this value must exactly match the height
                  that has been passed to the last call of @{"TransformImage()" LINK TransformImage}.

        LineWidth:
                  Must be set to the image modulo width in pixels. This is often
                  the same as the image width.

        AlphaChannel:
                  Must be set to TRUE or FALSE, depending on whether or not this
                  image has an alpha channel.

        Depth:    Must be set to the image's bit depth. (V9.0)

        Palette:  If "HWIMGFLAGS_LOADPALETTE" was set when @{"LoadImage()" LINK LoadImage} was
                  called, you need to set this member to a pointer to a palette,
                  stored as a "ULONG" array of 256 RGB colors. Note that the
                  "ULONG" array must always have 256 entries, even if the bit
                  depth is less than 8. Initialize unused palette entries to 0.
                  (V9.0)

        The pointer that is returned by GetImage() must stay valid at least
        until the next call to GetImage() or @{"FreeImage()" LINK FreeImage} on this handle.

   @{b}INPUTS@{ub}
        handle    image handle as returned by @{"LoadImage()" LINK LoadImage}
        ctrl      pointer to a struct LoadImageCtrl for storing information
                  about the image

   @{b}RESULTS@{ub}
        raw       an array of raw pixel data

@ENDNODE

@NODE GetImageFormat "Hollywood SDK"

   @{b}NAME@{ub}
        GetImageFormat -- get image format name (V10.0)

   @{b}SYNOPSIS@{ub}
        STRPTR name = GetImageFormat(APTR handle);

   @{b}FUNCTION@{ub}
        This function is optional and must only be implemented if the
        "HWEXT_IMAGE_FORMAT" extension bit has been set. See @{"Extension plugins" LINK ExtensionOverview}
        for details. If that is the case, this function must return a
        null-terminated string containing the name of the format of the image
        file handle passed in "handle". The string returned by this function can
        be retrieved from Hollywood scripts by querying the #ATTRFORMAT
        attribute on image-based objects like #BRUSH or #BGPIC. The string you
        return must be valid until @{"FreeImage()" LINK FreeImage} is called on the image handle
        passed to this function.

   @{b}INPUTS@{ub}
        handle    handle returned by @{"LoadImage()" LINK LoadImage}

   @{b}RESULTS@{ub}
        name      image format name

@ENDNODE

@NODE IsImage "Hollywood SDK"

   @{b}NAME@{ub}
        IsImage -- check if a file is in a supported image format (V5.0)

   @{b}SYNOPSIS@{ub}
        int ok = IsImage(STRPTR filename, struct LoadImageCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function has to check whether the specified file is in an image
        format that the plugin wants to handle. If it is, the plugin has to
        return TRUE and provide information about the image's size and whether
        or not it has an alpha channel. This is done by setting the following
        members of the struct LoadImageCtrl pointer that is passed to IsImage()
        in the second argument:

        Width:    Must be set to the image width in pixels.

        Height:   Must be set to the image height in pixels.

        Depth:    Set this to the bit depth of the image. (V9.0)

        AlphaChannel:
                  Must be set to TRUE or FALSE, depending on whether or not this
                  image has an alpha channel.

        Flags:    Your implementation may set the following flags:

                  HWIMGFLAGS_TRANSPARENCY:
                            Set this flag to tell Hollywood that the image has a
                            monochrome transparency channel (e.g. a transparent
                            pen in a palette-based image). (V6.0)

        The following members of struct LoadImageCtrl are set by Hollywood
        before it calls your implementation of IsImage():

        Adapter:  Starting with Hollywood 6.0 users can specify the file adapter
                  that should be used to open certain files. If this member is
                  non-NULL, Hollywood wants your plugin to use the file adapter
                  specified in "Adapter" to open the file. This means that you
                  have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of @{"hw_FOpen()" LINK hw_FOpen} to open the
                  file. Make sure to check for Hollywood 6.0 before trying to
                  access this member because it isn't there in previous
                  versions. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details. (V6.0)

        UserTags: This member will be set to a list of user tags in case they
                  were specified in the Hollywood script. User tags are a way of
                  passing additional information from Hollywood scripts to
                  plugin functions. Note that even if your plugin doesn't
                  support any user tags, you should still look for this tag and
                  pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed
                  in "UserTags" could also be intended for another plugin,
                  namely the file adapter plugin passed in "Adapter". See @{"User" LINK UserTags}
                  @{"tags" LINK UserTags} for details. Make sure to check for Hollywood 10.0 before
                  trying to access this member because it isn't there in
                  previous versions. (V10.0)

        You must not touch any other members of the struct LoadImageCtrl pointer
        that is passed to this function. See @{"LoadImage" LINK LoadImage} for details on this
        structure.

   @{b}INPUTS@{ub}
        filename  filename to examine
        ctrl      pointer to a struct LoadImageCtrl for storing information
                  about the image

   @{b}RESULTS@{ub}
        ok        TRUE if the plugin wants to handle this file, FALSE otherwise

@ENDNODE

@NODE LoadImage "Hollywood SDK"

   @{b}NAME@{ub}
        LoadImage -- load image into memory (V5.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = LoadImage(STRPTR filename, struct LoadImageCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function has to open the specified filename, check if it is in a
        format that the plugin wants to handle, and, if it is, return a handle
        to the image back to Hollywood. Otherwise it has to return NULL. The
        handle returned by LoadImage() is an opaque datatype that only your
        plugin knows about. Hollywood will simply pass this handle back to your
        @{"GetImage()" LINK GetImage} function when it wants to have the raw pixel data.

        This function also has to provide certain information about the image it
        has just loaded. This information has to be written to the struct
        LoadImageCtrl that is passed in the second parameter. This structure
        looks like this:

            struct LoadImageCtrl
            {
                int Width;                      // [out]
                int Height;                     // [out]
                int LineWidth;                  // [out]
                int AlphaChannel;               // [out]
                int ForceAlphaChannel;          // [out]
                int Type;                       // [out]
                ULONG Flags;                    // [in/out] -- V5.3
                int ScaleWidth;                 // [in]     -- V5.3
                int ScaleHeight;                // [in]     -- V5.3
                int BaseWidth;                  // [out]    -- V5.3
                int BaseHeight;                 // [out]    -- V5.3
                ULONG ScaleMode;                // [in]     -- V5.3
                STRPTR Adapter;                 // [in]     -- V6.0
                ULONG *Palette;                 // [unused] -- V9.0
                ULONG TransPen;                 // [out]    -- V9.0
                int Depth;                      // [out]    -- V9.0
                struct hwUserTagList *UserTags; // [in]     -- V10.0
            };

        @{b}Be @{ub}@{b}careful @{ub}@{b}when @{ub}@{b}accessing @{ub}@{b}above @{ub}@{b}structure @{ub}@{b}members: @{ub}@{b}LoadImageCtrl @{ub}@{b}has@{ub}
        @{b}seen @{ub}@{b}several @{ub}@{b}revisions @{ub}@{b}in @{ub}@{b}Hollywood's @{ub}@{b}history. @{ub}@{b}Before @{ub}@{b}accessing @{ub}@{b}members@{ub}
        @{b}that @{ub}@{b}haven't @{ub}@{b}been @{ub}@{b}there @{ub}@{b}in @{ub}@{b}all @{ub}@{b}Hollywood @{ub}@{b}versions @{ub}@{b}you @{ub}@{b}must @{ub}@{b}make @{ub}@{b}sure@{ub}
        @{b}that @{ub}@{b}your @{ub}@{b}plugin @{ub}@{b}has @{ub}@{b}been @{ub}@{b}opened @{ub}@{b}by @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}version @{ub}@{b}that @{ub}@{b}has @{ub}@{b}those@{ub}
        @{b}members @{ub}@{b}or @{ub}@{b}you @{ub}@{b}will @{ub}@{b}access @{ub}@{b}unallocated @{ub}@{b}memory!@{ub}

        The following information has to be provided by LoadImage():

        Type:     This must be set to either "HWIMAGETYPE_RASTER" or
                  "HWIMAGETYPE_VECTOR". If you set this to "HWIMAGETYPE_VECTOR",
                  Hollywood will call your @{"TransformImage()" LINK TransformImage} function whenever it
                  needs to transform the image. This allows you to do lossless
                  transformation of the vector image. For images of type
                  "HWIMAGETYPE_RASTER", @{"TransformImage()" LINK TransformImage} is never called.
                  Instead, Hollywood does all transformations itself.

        Width:    Must be set to the image width in pixels.

        Height:   Must be set to the image height in pixels.

        Depth:    Must be set to the image's bit depth. (V9.0)

        LineWidth:
                  Must be set to the image modulo width in pixels. This is often
                  the same as the image width.

        AlphaChannel:
                  Must be set to TRUE or FALSE, depending on whether or not this
                  image has an alpha channel.

        ForceAlphaChannel:
                  If this is set to TRUE, Hollywood will automatically create an
                  alpha channel for all objects that load this image. For
                  example, if the user calls "LoadBrush()" on your image but
                  does not set the "LoadAlpha" tag to TRUE, the brush will still
                  get an alpha channel if you set "ForceAlphaChannel" to TRUE.

        Flags:    The following flags may be set by Hollywood:

                  HWIMGFLAGS_TRANSPARENCY:
                            This flag will be set whenever the user sets the
                            "LoadTransparency" tag to TRUE. If
                            "HWIMGFLAGS_LOADPALETTE" is set as well (see below),
                            you must return the pen that is transparent in the
                            "TransPen" member of struct LoadImageCtrl. If
                            "HWIMGFLAGS_LOADPALETTE" is not set, you have to
                            write the image's transparency information to its
                            alpha channel and set the "ForceAlphaChannel" member
                            to TRUE. See above for more information. (V6.0)

                  HWIMGFLAGS_LOADPALETTE:
                            This flag will be set whenever the user sets the
                            "LoadPalette" tag to TRUE. If this flag is set, your
                            implementation of LoadImage() should fail in case
                            the image does not have a palette. If it has a
                            palette, you have to return that palette when
                            Hollywood calls your @{"GetImage()" LINK GetImage} implementation. Note
                            that palette images must always use
                            "HWIMAGETYPE_RASTER". They may not register as
                            vector images. (V9.0)

                  The following flags may be set by your implementation:

                  HWIMGFLAGS_DIDSCALE:
                            If your plugin has scale-loaded this image, you have
                            to set the "HWIMGFLAGS_DIDSCALE" flag here so that
                            Hollywood knows that your plugin has loaded and
                            scaled the image. See below for more information on
                            scaled loading of images. (V5.3)

        Adapter:  Starting with Hollywood 6.0 users can specify the file adapter
                  that should be used to open certain files. If this member is
                  non-NULL, Hollywood wants your plugin to use the file adapter
                  specified in "Adapter" to open the image. This means that you
                  have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of @{"hw_FOpen()" LINK hw_FOpen} to open the
                  image. Make sure to check for Hollywood 6.0 before trying to
                  access this member because it isn't there in previous
                  versions. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details. (V6.0)

        TransPen: If "HWIMGFLAGS_LOADPALETTE" and "HWIMGFLAGS_TRANSPARENCY" are
                  set and the image has a transparent pen, set "TransPen" to the
                  index of that transparent pen. Otherwise set this member to
                  "HWPEN_NONE". (V9.0)

        Starting with Hollywood 5.3 LoadImage() also supports scaled loading of
        images. This is optional functionality and need not be supported by
        LoadImage(). If you want to support it, you have to look at the members
        "ScaleWidth" and "ScaleHeight" of the struct LoadImageCtrl pointer that
        is passed to LoadImage(). @{b}Warning! @{ub}@{b}Make @{ub}@{b}sure @{ub}@{b}that @{ub}@{b}you @{ub}@{b}access @{ub}@{b}these@{ub}
        @{b}members @{ub}@{b}only @{ub}@{b}if @{ub}@{b}you @{ub}@{b}have @{ub}@{b}checked @{ub}@{b}that @{ub}@{b}your @{ub}@{b}plugin @{ub}@{b}has @{ub}@{b}been @{ub}@{b}opened @{ub}@{b}by@{ub}
        @{b}version @{ub}@{b}5.3 @{ub}@{b}or @{ub}@{b}higher @{ub}@{b}of @{ub}@{b}Hollywood. @{ub}@{b}Otherwise, @{ub}@{b}these @{ub}@{b}members @{ub}@{b}won't @{ub}@{b}be@{ub}
        @{b}there @{ub}@{b}and @{ub}@{b}trying @{ub}@{b}to @{ub}@{b}access @{ub}@{b}them @{ub}@{b}will @{ub}@{b}read @{ub}@{b}from @{ub}@{b}bad @{ub}@{b}memory @{ub}@{b}locations @{ub}@{b}and@{ub}
        @{b}give @{ub}@{b}you @{ub}@{b}back @{ub}@{b}random @{ub}@{b}values. @{ub}So if you want to implement support for
        scaled loading of images, first check for Hollywood 5.3 and then take a
        look at the following members of the struct LoadImageCtrl:

        ScaleWidth:
                  If Hollywood wants your plugin to scale the image while
                  loading, this member will be set to either a positive or
                  negative integer. A positive integer value specifies the
                  desired width in pixels for this image while a negative
                  integer value is to be interpreted as a percentage value
                  specifying the desired scaling factor relative to the original
                  image width, i.e. "-75" means that the image should be scaled
                  to 75% of its original width. If "ScaleWidth" is 0, Hollywood
                  doesn't want to have any scaling. (V5.3)

        ScaleHeight:
                  This works in the same way as described above for "ScaleWidth"
                  except that it deals with the image height. (V5.3)

        ScaleMode:
                  Contains the ID of a scale mode. Currently, this can be either
                  0 for hard scaling or 1 for interpolated scaling using
                  anti-aliasing. (V5.3)

        BaseWidth:
                  If your plugin supports scaled loading, you need to set this
                  member to the original width of the image. This is important
                  because otherwise Hollywood won't know the original size of
                  the image as the "Width" member needs to be set to the scaled
                  width if you do scaling. (V5.3)

        BaseHeight:
                  Same as "BaseWidth" but for the image height. (V5.3)

        UserTags: This member will be set to a list of user tags in case they
                  were specified in the Hollywood script. User tags are a way of
                  passing additional information from Hollywood scripts to
                  plugin functions. Note that even if your plugin doesn't
                  support any user tags, you should still look for this tag and
                  pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed
                  in "UserTags" could also be intended for another plugin,
                  namely the file adapter plugin passed in "Adapter". See @{"User" LINK UserTags}
                  @{"tags" LINK UserTags} for details. Make sure to check for Hollywood 10.0 before
                  trying to access this member because it isn't there in
                  previous versions. (V10.0)

        Please note that you should not use ANSI C functions like "fopen()" to
        open the file that is passed to this function because the filename that
        is passed to this function can also be a specially formatted filename
        specification that Hollywood uses to load files that have been linked to
        applets or executables. In order to be able to load these files
        correctly, you have to use special IO functions provided by Hollywood.
        See @{"File IO information" LINK FileIO} for details.

   @{b}INPUTS@{ub}
        filename  filename to open
        ctrl      pointer to a struct LoadImageCtrl for storing information
                  about the image

   @{b}RESULTS@{ub}
        handle    a handle that identifies this image or NULL if plugin doesn't
                  want to handle this image

@ENDNODE

@NODE TransformImage "Hollywood SDK"

   @{b}NAME@{ub}
        TransformImage -- transform a vector image (V5.0)

   @{b}SYNOPSIS@{ub}
        int ok = TransformImage(APTR handle, struct hwMatrix2D *m, int width,
                      int height);

   @{b}FUNCTION@{ub}
        This function must transform the specified vector image according to the
        2D transformation matrix passed in parameter 2. It must also clip the
        resulting image to the specified width and height in pixels. After
        calling TransformImage(), Hollywood will then call your plugin's
        @{"GetImage()" LINK GetImage} function again to obtain the raw pixel data of the newly
        transformed image. It is very important that the dimensions and the
        pixel array returned by the next call to @{"GetImage()" LINK GetImage} match the dimensions
        passed to TransformImage() in parameters 3 and 4 exactly.

        TransformImage() is only ever called for images of type
        "HWIMAGETYPE_VECTOR". If your @{"LoadImage()" LINK LoadImage} function sets the image type
        to "HWIMAGETYPE_RASTER", TransformImage() won't be called at all and
        Hollywood will do all image transformations on its own.

        If the transformation was successful, TransformImage() must return TRUE.
        Otherwise it has to return FALSE.

   @{b}INPUTS@{ub}
        handle    image handle as returned by @{"LoadImage()" LINK LoadImage}
        m         2D matrix describing the desired transformation
        width     clipping width for resulting image
        height    clipping height for resulting image

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE ImageSaverOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_SAVEIMAGE" set can
    register one or more additional output image formats. The user will then be
    able to save images in the output formats supported by the plugin. Plugins
    have to register new output image formats by passing the name of a constant
    that should be used to access the new format. For example, a plugin might
    choose to register a new output image format under the constant
    #IMGFMT_CUSTOMFORMAT. Whenever the user calls "SaveBrush()" or
    "SaveSnapshot()" now and passes #IMGFMT_CUSTOMFORMAT as the image format,
    Hollywood will ask the plugin to save the image.

    @{"RegisterImageSaver()              " LINK RegisterImageSaver} Register a new image saver
    @{"SaveImage()                       " LINK SaveImage} Save image to disk
@ENDNODE

@NODE RegisterImageSaver "Hollywood SDK"

   @{b}NAME@{ub}
        RegisterImageSaver -- register a new image saver (V5.0)

   @{b}SYNOPSIS@{ub}
        void RegisterImageSaver(struct SaveImageReg *reg)

   @{b}FUNCTION@{ub}
        Hollywood will call this function to get information about the image
        saver your plugin wants to register. In addition, RegisterImageSaver()
        has to tell Hollywood whether it wants to register another image saver.
        Hollywood will pass a pointer to a struct SaveImageReg to this function.
        This structure looks like this:

            struct SaveFormatReg
            {
                ULONG CapsMask;     [out]
                ULONG FormatID;     [in/out]
                STRPTR FormatName;  [out]
            };

            struct SaveImageReg
            {
                struct SaveFormatReg hdr;
            };

        Your implementation has to do the following with the individual
        structure members:

        CapsMask: This must be set to a combination of flags that tell Hollywood
                  about the capabilities of the image saver that is to be
                  registered. The following flags are currently supported:

                  HWSAVEIMGCAPS_ARGB:
                            Your image saver supports source image data that is
                            delivered as a 32-bit ARGB pixel array.

                  HWSAVEIMGCAPS_CLUT:
                            Your image saver supports source image data that is
                            delivered as 8-bit CLUT pixels that are index values
                            for a palette look-up table.

                  HWSAVEIMGCAPS_ALPHA:
                            Your image saver supports alpha channel saving. This
                            is only supported if you also set
                            "HWSAVEIMGCAPS_ARGB".

                  HWSAVEIMGCAPS_MORE:
                            If you set this flag, Hollywood will call
                            RegisterImageSaver() again so that you can register
                            another saver. If you don't want to register another
                            saver, don't set this flag. (V5.3)

                  Note that "HWSAVEIMGCAPS_ARGB" and "HWSAVEIMGCAPS_CLUT" are
                  not mutually exclusive. You can set them both if the target
                  image format supports both true colour and palette-based pixel
                  data storage.

        FormatID: This member must be set to a unique 32-bit value that should
                  be assigned to the constant that is registered for accessing
                  this image saver from Hollywood scripts. Values smaller than
                  32768 are reserved for internal Hollywood use. You may use
                  values larger than 32768 for your saver but if you want to
                  publish your plugin, you need to contact Airsoft Softwair to
                  obtain a unique value that is still vacant. This won't cost
                  you anything; it's just needed to make sure that plugin image
                  savers don't use conflicting identifiers. Also, once you have
                  published your image saver plugin, the "FormatID" you have
                  specified must not be changed or you will break compatibility
                  with applets or executables that have been compiled with
                  previous versions. If you are registering more than one image
                  saver using "HWSAVEIMGCAPS_MORE", you can look at the
                  "FormatID" member to tell how many times Hollywood has already
                  called RegisterImageSaver() because "FormatID" will contain
                  the identifier of the last image saver you registered. If
                  "FormatID" is 0, then this is the first call to
                  RegisterImageSaver(). Note that it is not recommended to keep
                  your own counter because Hollywood might call
                  RegisterImageSaver() multiple times, i.e. it might first loop
                  over RegisterImageSaver() to determine how many image savers
                  there are in total and then it might loop over
                  RegisterImageSaver() again to actually register their names.

        FormatName:
                  This must be set to a string that should form the second half
                  of the constant that Hollywood registers for your image saver.
                  This string you specify here must follow the naming
                  restrictions for Hollywood constants, i.e. only alphabetical
                  characters, numbers and very few special characters like the
                  underscore character are allowed. The #IMGFMT_ prefix must not
                  be included in the string you pass. Hollywood will add this
                  automatically, i.e. if you pass the string "TESTFORMAT" here,
                  Hollywood will make your image saver available under the
                  constant #IMGFMT_TESTFORMAT.

   @{b}INPUTS@{ub}
        reg       pointer to a struct SaveImageReg to be filled out by your
                  implementation

@ENDNODE

@NODE SaveImage "Hollywood SDK"

   @{b}NAME@{ub}
        SaveImage -- save image to disk (V5.0)

   @{b}SYNOPSIS@{ub}
        int ok = SaveImage(STRPTR filename, struct SaveImageCtrl *ctrl);

   @{b}FUNCTION@{ub}
        This function must save the image provided by the pointer in the second
        parameter to the filename specified in the first parameter. Hollywood
        passes a pointer to a struct SaveImageCtrl to this function. This
        structure looks like this:

            struct SaveImageCtrl
            {
                APTR Data;                      // [in]
                ULONG *Palette;                 // [in]
                int Width;                      // [in]
                int Height;                     // [in]
                int Modulo;                     // [in]
                int Format;                     // [in]
                int Quality;                    // [in]
                int Colors;                     // [in]
                ULONG TransIndex;               // [in]
                ULONG Flags;                    // [in]
                ULONG FormatID;                 // [in] -- V5.3
                STRPTR Adapter;                 // [in] -- V10.0
                struct hwUserTagList *UserTags; // [in] -- V10.0
            };

        In this structure Hollywood passes the following information to your
        SaveImage() function:

        Data:     The pixel data to save to the file. The actual format of this
                  data depends on the "Format" member.

        Width:    Width of the image in pixels.

        Height:   Height of the image in pixels.

        Modulo:   Number of bytes used by a single row of pixel data. This may
                  be larger than the specified width because there may be some
                  padding involved.

        Format:   This specifies the pixel format of the source data passed in
                  "Data". May be one of the following constants:

                  HWSAVEIMGFMT_ARGB:
                            Data is a 32-bit array consisting of ARGB pixels.

                  HWSAVEIMGFMT_CLUT:
                            Data contains 8-bit indices into a color look-up
                            table. This color look-up table is passed in
                            "Palette" below.

                  You will only have to handle those formats here that you have
                  explicitly declared as supported when Hollywood called your
                  @{"RegisterImageSaver()" LINK RegisterImageSaver} function.

        Quality:  This contains a value between 0 and 100 indicating the desired
                  quality for the output file. Image formats that use lossy
                  compression can use this member to determine compression
                  settings for the image. Image formats that don't use any
                  compression or offer lossless compression can ignore this
                  member.

        Colors:   This contains the number of colors in the color look-up table
                  passed in the "Palette" member. This member is only used if
                  "Format" is "HWSAVEIMGFMT_CLUT".

        Palette:  Contains the look-up table that you need to convert the CLUT
                  pixel values to RGB color values. This table consists of as
                  many 32-bit ARGB values as has been set in the "Colors"
                  member. Note that "Palette" is only used if "Format" is
                  "HWSAVEIMGFMT_CLUT".

        TransIndex:
                  If "Format" is "HWSAVEIMGFMT_CLUT" this member specifies the
                  index of the color that should appear transparent in the
                  image. The value specified here is only valid if the
                  "HWSAVEIMGFLAGS_TRANSINDEX" flag has been set (see below).

        Flags:    Contains a combination of flags specifying further options:

                  HWSAVEIMGFLAGS_ALPHA:
                            Pixel data contains alpha channel transparency
                            values.

                  HWSAVEIMGFLAGS_TRANSINDEX:
                            The "TransIndex" member contains the index of a
                            palette entry that should be made transparent in the
                            output image.

        FormatID: This member contains the identifier of the image format the
                  file should be saved in. You only need to look at this member
                  if your plugin supports more than one output image format. But
                  be careful, you are only allowed to look at this member if the
                  user is running at least Hollywood 5.3. Otherwise, you must
                  not access this member because older versions of Hollywood
                  don't support it. (V5.3)

        Adapter:  Starting with Hollywood 10.0 users can specify the file
                  adapter that should be used to save an image file. If this
                  member is non-NULL, Hollywood wants your plugin to use the
                  file adapter specified in "Adapter" to save the image. This
                  means that you have to use @{"hw_FOpenExt()" LINK hw_FOpenExt} instead of @{"hw_FOpen()" LINK hw_FOpen}
                  to save the image. Make sure to check for Hollywood 10.0
                  before trying to access this member because it isn't there in
                  previous versions. See @{"hw_FOpenExt" LINK hw_FOpenExt} for details. (V10.0)

        UserTags: This member will be set to a list of user tags in case they
                  were specified in the Hollywood script. User tags are a way of
                  passing additional information from Hollywood scripts to
                  plugin functions. Note that even if your plugin doesn't
                  support any user tags, you should still look for this tag and
                  pass the user tags to @{"hw_FOpenExt" LINK hw_FOpenExt} because the user tags passed
                  in "UserTags" could also be intended for another plugin,
                  namely the file adapter plugin passed in "Adapter". See @{"User" LINK UserTags}
                  @{"tags" LINK UserTags} for details. Make sure to check for Hollywood 10.0 before
                  trying to access this member because it isn't there in
                  previous versions. (V10.0)

        This function has to return TRUE if the image has been successfully
        saved or FALSE in case of an error.

   @{b}INPUTS@{ub}
        filename  path to a destination file
        ctrl      pointer to a struct SaveImageCtrl containing the image to be
                  saved

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating success or failure

@ENDNODE

@NODE IPCAdapterOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_IPCADAPTER" set can
    replace Hollywood's inbuilt handler for inter-process communication (IPC).
    Since inter-process communication is often closely tied to display adapters,
    plugins that install their own display adapters might also want to provide a
    custom adapter for inter-process communication. This plugin type makes that
    possible.

    Hollywood will call your @{"CreateIPCPort()" LINK CreateIPCPort} function to create a port for
    inter-process communication. @{"SendIPCMessage()" LINK SendIPCMessage} will be called whenever
    Hollywood wants to send a message to an IPC port. When an IPC port receives
    a message, it must post it to Hollywood's event queue using the
    "HWEVT_USERMESSAGE" event type. See @{"hw_PostEvent" LINK hw_PostEvent} for details.

    Please note that IPC adapters are not automatically initialized when
    Hollywood loads the plugin. Instead, you have to manually call
    @{"hw_SetIPCAdapter()" LINK hw_SetIPCAdapter} in your @{"RequirePlugin()" LINK RequirePlugin} function to activate the IPC
    adapter. The IPC adapter will then only be activated if the user calls
    "\@REQUIRE" on your plugin. Otherwise, Hollywood will use its default IPC
    handler. See @{"Auto and manual plugin initialization" LINK AutoAndManualInit} for details.

    See @{"hw_SetIPCAdapter" LINK hw_SetIPCAdapter} for information on how to install your IPC adapter.

    This plugin type is supported since Hollywood 9.0.

    @{"CreateIPCPort()                   " LINK CreateIPCPort} Create a new IPC port
    @{"FreeIPCPort()                     " LINK FreeIPCPort} Free an IPC port
    @{"SendIPCMessage()                  " LINK SendIPCMessage} Send a message to an IPC port
@ENDNODE

@NODE CreateIPCPort "Hollywood SDK"

   @{b}NAME@{ub}
        CreateIPCPort -- create a new IPC port (V9.0)

   @{b}SYNOPSIS@{ub}
        APTR handle = CreateIPCPort(STRPTR name, struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to register a new IPC port that uses the name passed
        in the "name" parameter. IPC port names must be unique in the system, so
        this function must fail if there is already an IPC port with the
        specified name. Note that port names should always be case sensitive.

        Hollywood will call @{"FreeIPCPort()" LINK FreeIPCPort} to free an IPC port allocated by this
        function. See @{"FreeIPCPort" LINK FreeIPCPort} for details.

   @{b}INPUTS@{ub}
        name      desired port name; must be unique
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        handle    handle to the IPC port or NULL in case of an error

@ENDNODE

@NODE FreeIPCPort "Hollywood SDK"

   @{b}NAME@{ub}
        FreeIPCPort -- free an IPC port (V9.0)

   @{b}SYNOPSIS@{ub}
        void FreeIPCPort(APTR handle);

   @{b}FUNCTION@{ub}
        This function must free the specified IPC port that has been allocated
        by @{"CreateIPCPort()" LINK CreateIPCPort}. See @{"CreateIPCPort" LINK CreateIPCPort} for details.

   @{b}INPUTS@{ub}
        handle    port handle allocated by @{"CreateIPCPort()" LINK CreateIPCPort}

@ENDNODE

@NODE SendIPCMessage "Hollywood SDK"

   @{b}NAME@{ub}
        SendIPCMessage -- send a message to an IPC port (V9.0)

   @{b}SYNOPSIS@{ub}
        int ok = SendIPCMessage(STRPTR port, UBYTE *data, int len,
                     struct hwTagList *tags);

   @{b}FUNCTION@{ub}
        This function has to send the message specified by "data" to the IPC
        port specified by "port". The length of the message specified by "data"
        is specified in the "len" parameter (in bytes). Note that "data" could
        also contain binary data. If the port name specified in "port" doesn't
        exist or an error occurs, SendIPCMessage() must return FALSE.

        Note that since SendIPCMessage() may be used to send messages to
        different processes, the receiver's port must be specified as a string
        instead of a handle created by @{"CreateIPCPort()" LINK CreateIPCPort} because handles are of
        course private to the process that created them.

        When an IPC port receives a message, it should post it to Hollywood's
        event queue using the "HWEVT_USERMESSAGE" event type. See @{"hw_PostEvent" LINK hw_PostEvent}
        for details.

   @{b}INPUTS@{ub}
        port      receiver's port name
        data      raw data to send to port
        len       length of the data to send to port
        tags      reserved for future use, currently always NULL

   @{b}RESULTS@{ub}
        ok        return TRUE to indicate success, FALSE for error

@ENDNODE

@NODE LibraryOverview "Hollywood SDK"
@{b}Overview@{ub}

    Plugins that have the capability flag "HWPLUG_CAPS_LIBRARY" set can add new
    commands and constants to Hollywood's set of inbuilt commands and constants.
    If you want to write such a plugin, you need to familiarize yourself with
    the Lua which Hollywood uses as a VM. You can access Hollywood's Lua VM
    through the "LuaBase" pointer that is passed inside the "hwPluginAPI" table
    which your @{"InitPlugin()" LINK InitPlugin} function receives.

    Here is a brief explanation of how Lua calls C functions: Your function will
    receive just a single parameter - a pointer to the "lua_State". All
    parameters that the script passes to your function will be pushed into the
    stack. If you want to return values to Lua, you have to push them into the
    stack as well and return the number of values you pushed. Alternatively, you
    can also return an error code. Standard error codes are defined in
    hollywood/errors.h. You can also register custom error codes using
    @{"hw_RegisterError()" LINK hw_RegisterError}.

    Here is how a custom function that simply divides the first parameter by the
    second:

        static SAVEDS int MyDiv(lua_State *L)
        {
            double a = luaL_checknumber(L, 1);
            double b = luaL_checknumber(L, 2);

            // catch division by zero CPU exception and handle
            // it cleanly
            if(b == 0) return ERR_ZERODIVISION;

            lua_pushnumber(L, a / b);

            // push 1 to indicate one return value
            return 1;
        }

    This is just a primitive example. Check the Lua manual for more information
    on how to implement Lua functions in C. Please note that Hollywood uses Lua
    5.0.2 so make sure you consult the correct manual. See @{"LuaBase functions" LINK LuaBaseOverview} for
    details.

    The SDK distribution also comes with an example library plugin which adds
    several functions and constants to Hollywood. Feel free to study this
    example code to learn how library plugins are written in practice.

    Starting with Hollywood 6.0 library plugins support the
    "HWEXT_LIBRARY_MULTIPLE" extension. If this extension is set, a library can
    install multiple libraries instead of just a single one. If you set the
    "HWEXT_LIBRARY_MULTIPLE" extension bit, you need to implement the
    @{"GetLibraryCount()" LINK GetLibraryCount} and @{"SetCurrentLibrary()" LINK SetCurrentLibrary} functions. Hollywood will then
    call @{"GetLibraryCount()" LINK GetLibraryCount} to find out how many libraries your plugin wants to
    install. See @{"Extension plugins" LINK ExtensionOverview} to learn how to us