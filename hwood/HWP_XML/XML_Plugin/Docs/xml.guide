@DATABASE xml.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from xml.meta by MetaDoc 1.12 (c) by Airsoft Softwair"
@$VER: xml.guide 2.0 (25.11.2022)
@INDEX Reference
@HELP Reference

@NODE Main "XML Plugin Guide"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                                         -= @{B}@{FG highlight}X M L . H W P@{FG text}@{UB} =-

                                 Parse XML documents with Hollywood

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 I. General information
 @{" Introduction                    " LINK Introduction}     What is xml.hwp?
 @{" Terms and conditions            " LINK License}     License information
 @{" Requirements                    " LINK Requirements}     What you need to work with it
 @{" Installation                    " LINK Installation}     How to install xml.hwp

 II. About the XML plugin
 @{" Credits                         " LINK Credits}     Who was involved in this project?
 @{" F.A.Q.                          " LINK FAQ}     Frequently asked questions
 @{" Known issues                    " LINK KnownIssues}     List of things that can cause trouble
 @{" Future                          " LINK ToDo}     What is planned for the future?
 @{" History                         " LINK History}     What happened so far?

 III. Usage
 @{" Interfaces overview             " LINK Interfaces}     Overview on the plugin interfaces
 @{" Library interface               " LINK LibraryInterface}     The interface with the greatest flexibility
 @{" Serialization interface         " LINK SerializationInterface}     The interface that is most convenient
 @{" List serializer                 " LINK ListSerialization}     Serialize nodes as sequential list items
 @{" Named serializer                " LINK NamedSerialization}     Serialize nodes as named table items
 @{" Hollywood serializer            " LINK HollywoodSerialization}     Serialize arbitrary Hollywood tables

 IV. Reference
 @{" Function reference              " LINK XMLFunctions}     List of supported functions
 @{" Parser methods                  " LINK ParserMethods}     Methods supported by parser objects
 @{" Callback reference              " LINK CallbackFunctions}     Callbacks supported by parser objects

 @{" Index                           " LINK Reference}     Quickly find what you are looking for

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 xml.hwp is (C) Copyright © 2012-2022 Andreas Falkenhahn                      All rights reserved
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@ENDNODE
@NODE Introduction "XML Plugin Guide"
@{b}Introduction@{ub}

    The XML plugin allows Hollywood scripts to parse XML files easily and
    efficiently enabling you to make use of this extremely flexible universal
    markup language that can be used for so many different purposes. The plugin
    offers a powerful library interface that allows you to access all kinds of
    data in XML documents like nodes, attributes, namespaces, entities,
    attlists, CDATA and more.

    On top of that, the XML plugin also supports Hollywood's serialization
    interface which means that you can conveniently serialize Hollywood tables
    to XML documents by just a single call to Hollywood's "SerializeTable()"
    function. In the same manner you can also deserialize whole XML documents
    into Hollywood tables by a single call to Hollywood's "DeserializeTable()"
    function. It just doesn't get any easier!

@ENDNODE

@NODE License "XML Plugin Guide"
@{b}Terms and conditions@{ub}

    xml.hwp is © Copyright 2012-2022 by Andreas Falkenhahn (in the following
    referred to as "the author"). All rights reserved.

    The program is provided "as-is" and the author cannot be made responsible of
    any possible harm done by it. You are using this program absolutely at your
    own risk. No warranties are implied or given by the author.

    This plugin may be freely distributed as long as the following three
    conditions are met:

    1. No modifications must be made to the plugin.
    2. It is not allowed to sell this plugin.
    3. If you want to put this plugin on a coverdisc, you need to ask for
       permission first.

    This software uses Expat (C) Copyright 1998, 1999, 2000 Thai Open Source
    Software Center Ltd and Clark Cooper. (C) Copyright 2001, 2002, 2003, 2004,
    2005, 2006 Expat maintainers. See @{"Expat license" LINK LicenseExpat} for details.

    This software uses LuaExpat Copyright (C) 2003-2007 The Kepler Project. See
    @{"LuaExpat license" LINK LicenseLuaExpat} for details.

    All trademarks are the property of their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "XML Plugin Guide"
@{b}Requirements@{ub}

    - Hollywood 9.0 or better

@ENDNODE

@NODE Installation "XML Plugin Guide"
@{b}Installation@{ub}

    Installing xml.hwp is straightforward and simple: Just copy the file xml.hwp
    for the platform of your choice to Hollywood's plugins directory. On all
    systems except on AmigaOS and compatibles, plugins must be stored in a
    directory named Plugins that is in the same directory as the main Hollywood
    program. On AmigaOS and compatible systems, plugins must be installed to
    LIBS:Hollywood instead. On macOS, the Plugins directory must be inside the
    Resources directory of the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources.

    On Windows you should also copy the file xml.chm to the Docs directory of
    your Hollywood installation. Then you will be able to get online help by
    pressing F1 when the cursor is over a xml.hwp function in the Hollywood IDE.

    On Linux and macOS copy the xml directory that is inside the Docs directory
    of xml.hwp's distribution archive to the Docs directory of your Hollywood
    installation. Note that on macOS the Docs directory is within the
    Hollywood.app application bundle, i.e. in
    Hollywood.app/Contents/Resources/Docs.

@ENDNODE

@NODE Credits "XML Plugin Guide"
@{b}Credits@{ub}

    xml.hwp is one of the first Hollywood plugins and was written by Andreas
    Falkenhahn. It was originally written as a proof-of-concept for Hollywood
    5's new library plugin interface. Later it was expanded to support Hollywood
    9's new serialization interface to conveniently serialize XML documents to
    Hollywood tables and the other way round. Thanks have to go to Roberto
    Ierusalimschy, Andre Carregal and Tomas Guisasola for their LuaExpat plugin
    on which the library interface of xml.hwp is based.

    If you want to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE FAQ "XML Plugin Guide"
@{b}Frequently asked questions@{ub}

    This section covers some frequently asked questions. Please read them first
    before asking on the forum because your problem might have been covered
    here.

    @{b}Q: @{ub}@{b}Is @{ub}@{b}there @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}forum @{ub}@{b}where @{ub}@{b}I @{ub}@{b}can @{ub}@{b}get @{ub}@{b}in @{ub}@{b}touch @{ub}@{b}with @{ub}@{b}other @{ub}@{b}users?@{ub}

    A: Yes, please check out the "Community" section of the official Hollywood
    Portal online at http://www.hollywood-mal.com.


    @{b}Q: @{ub}@{b}Where @{ub}@{b}can @{ub}@{b}I @{ub}@{b}ask @{ub}@{b}for @{ub}@{b}help?@{ub}

    A: There's an active forum at http://forums.hollywood-mal.com. You're welcome
    to join it and ask your question there.


    @{b}Q: @{ub}@{b}I @{ub}@{b}have @{ub}@{b}found @{ub}@{b}a @{ub}@{b}bug.@{ub}

    A: Please post about it in the "Bugs" section of the forum.

@ENDNODE

@NODE KnownIssues "XML Plugin Guide"
@{b}Known issues@{ub}

    Here is a list of things that xml.hwp doesn't support yet or that may be
    confusing in some way:

    - tbd

@ENDNODE

@NODE ToDo "XML Plugin Guide"
@{b}Future@{ub}

    Here are some things that are on my to do list:

    - add more examples

    Don't hesitate to contact me if xml.hwp lacks a certain feature that is
    important for your project.

@ENDNODE

@NODE History "XML Plugin Guide"
@{b}History@{ub}

    Version 2.0:    (03-Dec-22)
    - Change: Amiga installer will now also copy the plugins for all platforms to Hollywood's
      linker plugins directory so that they can be easily linked to executables
    - New: Added help strings to the plugin; when using the Hollywood IDE you'll now get live
      help for all plugin functions and methods (requested by Michael Rupp)
    - New: Finally added fully-featured documentation that describes the plugin's functionality
      in great detail so it should hopefully be much easier to use now
    - Change [Linux/macOS]: xml.hwp is now dynamically linked against the system's libexpat
      which reduces the executable size by about 200kb
    - New: xml.CreateParser() accepts an optional additional argument now that allows you to
      specify whether the "CharacterData" callback should try to merge the data or not
    - Change: Renamed some methods: xmlparser.New() is now known as xml.CreateParser();
      parser:pos() has been renamed to parser:GetPosition() and parser:close() is now called
      parser:Free()
    - Change: On error, parser:Parse() doesn't return extended error information any more but
      just a boolean value; to get extended error information, call the new parser:GetError()
      method 
    - New: Added the following new callback functions: EntityDecl, AttlistDecl, ElementDecl,
      EndDoctypeDecl, SkippedEntity, XMLDecl; these allow you to parse almost all elements of
      XML documents now
    - New: Added xml.SetSerializeOptions() command; this command can be used to set several
      options to be used when serializing a Hollywood table or deserializing an XML document
    - New: Added xml.SetSerializeMode(); this can be used to set the desired (de)serialization
      mode; this can be #XML_SERIALIZEMODE_LIST (the default), #XML_SERIALIZEMODE_NAMED or
      #XML_SERIALIZEMODE_HOLLYWOOD; list serialization mode stores the tree nodes as sequential
      numeric table items whereas named serialization mode stores the tree nodes as named
      table items, which means that there mustn't be two table items of the same name at the
      same tree level; Hollywood serialization mode is a special mode designed to (de)serialize
      arbitrary Hollywood tables; it uses a special format to store additional information
      in the XML
    - Change: Changed plugin name from xmlparser.hwp to xml.hwp because it can't just parse
      but also write XML files now
    - New: Plugin supports Hollywood 9's new serialization capabilities now; this means that
      you can easily serialize a table to XML using Hollywood's WriteTable()/SerializeTable()/
      SavePrefs() functions and read it back into a table using ReadTable()/DeserializeTable()/
      LoadPrefs(); even the serialization of binary data and functions is fully supported  

    Version 1.1:    (02-Jul-15)
    - New [Linux]: Added build for Linux ARM
    - Fix [Linux/macOS]: Plugin is now compiled as position-independent code (PIC)

    Version 1.0:    (20-Mar-12)
    - First release
@ENDNODE

@NODE Interfaces "XML Plugin Guide"
@{b}Interfaces@{ub}

    There are two ways of using this plugin: Either through the library
    interface or through the serialization interface. Using the plugin through
    the serialization interface is easier and very convenient but it comes at
    the expense of flexibility. Using the plugin through the library interface
    is a bit more difficult but offers full flexibility. Please see the next two
    chapters for a brief overview of the two different interfaces.

@ENDNODE

@NODE LibraryInterface "XML Plugin Guide"
@{b}Library interface@{ub}

    Using the library interface of xml.hwp gives your script the most
    flexibility and allows you to access all features of XML documents. The
    library interface is based on the SAX parsing model which means that you
    specify a number of callbacks which the XML parser will call while it is
    parsing your document. One of those callbacks is the @{"StartElement()" LINK StartElement}
    callback. It will be called whenever the parser encounters a new XML tag in
    the document. As described in its manual page, @{"StartElement()" LINK StartElement} receives three
    arguments: The parser handle, the element name and a table containing the
    XML attributes specified in the tag. Thus, a @{"StartElement()" LINK StartElement} callback could
    look like this:

        Function p_StartElement(p, name$, attrs)
           DebugPrint("New tag found:", name$)
           For k,v In Pairs(attrs) Do DebugPrint(k .. "=" .. v)
        EndFunction

    The code above will print the name of the XML tag the parser has just
    handled as well as all the attributes specified in the XML tag declaration.
    After having defined the callback, we now have to create a XML parser. This
    is done using the @{"xml.CreateParser()" LINK xmlCreateParser} function. You have to pass all
    callbacks you want to use to it. For our little example, we only want to use
    the @{"StartElement()" LINK StartElement} callback so we create the parser like this:

        p = xml.CreateParser({StartElement = p_StartElement})

    As a next thing, we can feed XML data to the parser. This is done by calling
    the @{"parser:Parse()" LINK parserParse} method:

        p:Parse([[<plugin name="XML" author="A. Falkenhahn" version="1.0"/>]])

    Running this code will print the plugin's name as well as the attributes
    "name", "author" and "version". You can call @{"parser:Parse()" LINK parserParse} as often as you
    want. When you're finished, don't forget to call @{"parser:Free()" LINK parserFree} to free the
    parser handle. So here's the full example code of our minimal XML parser
    from above, ready to be copy and pasted into the Hollywood IDE:

        \@REQUIRE "xml"

        Function p_StartElement(p, name$, attrs)
           DebugPrint("New tag found:", name$)
           For k,v In Pairs(attrs) Do DebugPrint(k .. "=" .. v)
        EndFunction

        p = xml.CreateParser({StartElement = p_StartElement})
        p:Parse([[<plugin name="XML" author="A. Falkenhahn" version="1.0"/>]])
        p:Free()

    Of course, there are many other callback types besides @{"StartElement()" LINK StartElement}. See
    @{"xmlCreateParser" LINK xmlCreateParser} for details.

    Alternatively, you can also use the plugin's serialization interface. This
    is easier because it only requires a single function call to convert
    Hollywood tables to XML documents and vice versa but you won't have
    fine-tuned control over everything as you have when using the library
    interface.

    See the next chapter for more details on the plugin's serialization
    interface.

@ENDNODE

@NODE SerializationInterface "XML Plugin Guide"
@{b}Serialization interface@{ub}

    If you don't want to use xml.hwp's library interface (see above) for some
    reason, you can also use the plugin's serialization interface. This is
    easier to use because it only requires a single function call to convert
    Hollywood tables to XML documents and vice versa but you won't have
    fine-tuned control over everything as you have when using the library
    interface.

    Access to the xml.hwp's serialization interface is through Hollywood's
    "SerializeTable()" and "DeserializeTable()" functions, or, alternatively,
    through the "ReadTable()" and "WriteTable()" functions. By using the
    serialization interface, you can convert an XML document into a Hollywood
    table through just a single function call:

        t = DeserializeTable(FileToString("test.xml"), "xml")

    The code above will read all nodes and attributes from test.xml and store
    them in the Hollywood table "t".

    The way the XML data is stored inside the table depends on the serialization
    mode you have set using @{"xml.SetSerializeMode()" LINK xmlSetSerializeMode}. The XML plugin supports
    three different serialization modes:

    1. List mode: This will store all XML nodes as sequential list items inside
       the table. The first XML node will be at index 0, the second at index 1,
       and so on. This is the default mode. See @{"List serialization" LINK ListSerialization} for details.

    2. Named mode: This will store all XML nodes as named items inside the
       table. This means that you can conveniently access nodes by their name
       instead of having to use numeric indices. The disadvantage of this mode
       is that you can't have multiple nodes of the same name on the same level
       because the nodes are stored by name and each name is only available once
       per node level. Another disadvantage is that you don't have control over
       the order of the nodes when serializing them back to an XML document. See
       @{"Named serialization" LINK NamedSerialization} for details.

    3. Hollywood mode: This is a special mode that allows you to serialize
       arbitrary Hollywood tables. In contrast to the first two modes, Hollywood
       mode doesn't require the table to follow a certain layout. You can
       serialize any table in this mode, just as you can with Hollywood's
       "ReadTable()" and "WriteTable()" functions. The table can even contain
       binary data or code like Hollywood functions. See @{"Hollywood serialization" LINK HollywoodSerialization}
       for details.

    After you have converted an XML file to a Hollywood table, you could then
    make any modifications you like directly to the Hollywood table. When you're
    done with all modifications, you can simply convert your Hollywood table
    back into an XML document in just a single line like this:

        StringToFile(SerializeTable(t, "xml"), "test2.xml")

    The code above will convert the table "t" to an XML document using the
    xml.hwp plugin and save the XML document as test2.xml.

    As you can see, the serialization interface is very easy to use but doesn't
    offer as much flexibility as the library interface which gives you
    fine-tuned control over many XML documents features.

@ENDNODE

@NODE ListSerialization "XML Plugin Guide"
@{b}List serialization@{ub}

    The list (de)serialization mode, which is also the default mode, will store
    all XML nodes as sequential list items inside the table. The first XML node
    will be at index 0, the second at index 1, and so on. The table generated by
    the list deserializer will be a table of tables that contains the whole XML
    document. The following table fields will be initialized for each node:

    Name      Name of the XML node.

    Text      Character data of the XML node.

    Attrs     Set to a table of subtables containing all attributes as key and
              value pairs. Each subtable in the "Attrs" table will have the
              following fields initialized:

              Key       The attribute's name.

              Value     The attribute's value.

    Nodes     Set to a table containing the children of the node.

    To print all items of the table deserialized from an XML document using
    "DeserializeTable()" you could use the following recursive function:

        Function p_PrintNodes(t, indent)
            DebugPrint(RepeatStr(" ", indent) .. "+" .. t.name)
            For Local k = 0 To ListItems(t.attrs) - 1
               DebugPrint(RepeatStr(" ", indent + 1) ..
                  "attr: " .. t.attrs[k].key .. "=" .. t.attrs[k].value)
            Next
            If Not EmptyStr(t.text)
               DebugPrint(RepeatStr(" ", indent + 1) .. t.text)
            EndIf
            For Local k = 0 To ListItems(t.nodes) - 1
               p_PrintNodes(t.nodes[k], indent + 4)
            Next
        EndFunction

        t = DeserializeTable(FileToString("test.xml"), "xml")
        p_PrintNodes(t[0], 0)

    To modify a node, you can then simply change the desired value in the
    Hollywood table and then serialize it back to XML using Hollywood's
    "SerializeTable()" function. For example, let's suppose this is your XML
    file:

        <?xml version="1.0"?>
        <catalog>
           <book id="bk101">
              <author>Gambardella, Matthew</author>
              <title>XML Developer's Guide</title>
              <genre>Computer</genre>
              <price>44.95</price>
              <publish_date>2000-10-01</publish_date>
              <description>An in-depth look at creating applications
              with XML.</description>
           </book>
        </catalog>

    To change the price to 39.95 and save the updated XML to disk, you could do
    the following:

        t = DeserializeTable(FileToString("catalog.xml"), "xml")
        t[0].nodes[0].nodes[3].text = "39.95"
        StringToFile(SerializeTable(t, "xml"), "catalog_new.xml")

    Note that when using the list serializer, the table you pass to
    "SerializeTable()" must exactly follow the conventions described above, i.e.
    the table must contain a number of subtables stored at sequential numeric
    indices and the fields described above must be initialized for all nodes or
    there will be an error.

    For the example XML shown above, it might be more convenient to use the
    named serializer, though, because no node names are used twice. See @{"Named" LINK NamedSerialization}
    @{"serialization" LINK NamedSerialization} for details.

@ENDNODE

@NODE NamedSerialization "XML Plugin Guide"
@{b}Named serialization@{ub}

    The named (de)serialization mode will store all XML nodes as named items
    inside the table. This means that you can conveniently access nodes by their
    name instead of having to use numeric indices. The disadvantage of this mode
    is that you can't have multiple nodes of the same name on the same level
    because the nodes are stored by name and each name is only available once
    per node level. Another disadvantage is that you don't have control over the
    order of the nodes when serializing them back to an XML document.

    The following table fields will be initialized for each node when using the
    named serialization mode:

    Text      Character data of the XML node.

    Attrs     Set to a table of subtables containing all attributes as key and
              value pairs. Each subtable in the "Attrs" table will have the
              following fields initialized:

              Key       The attribute's name.

              Value     The attribute's value.

    Nodes     Set to a table containing the children of the node.

    For example, let's suppose this is your XML file:

        <?xml version="1.0"?>
        <catalog>
           <book id="bk101">
              <author>Gambardella, Matthew</author>
              <title>XML Developer's Guide</title>
              <genre>Computer</genre>
              <price>44.95</price>
              <publish_date>2000-10-01</publish_date>
              <description>An in-depth look at creating applications
              with XML.</description>
           </book>
        </catalog>

    To change the price to 39.95 and save the updated XML to disk, you could do
    the following:

        xml.SetSerializeMode(#XML_SERIALIZEMODE_NAMED)
        t = DeserializeTable(FileToString("catalog.xml"), "xml")
        t.catalog.nodes.book.nodes.price.text = "39.95"
        StringToFile(SerializeTable(t, "xml"), "catalog_new.xml")

    Note that when using the named serializer, the table you pass to
    "SerializeTable()" must exactly follow the conventions described above, i.e.
    the table must contain a number of subtables stored at named indices and the
    fields described above must be initialized for all nodes or there will be an
    error.

    Also note that since the named serializer stores XML nodes as named table
    fields, you can only use the same name once per tree level. Thus, you can't
    use the named serializer to deserialize XMLs that have multiple nodes of the
    same name, e.g. like this:

        <?xml version="1.0"?>
        <catalog>
           <item>First book</item>
           <item>Second book</item>
           <item>Third book</item>
        </catalog>

    In the XML shown above, there are three <item> tags on the same tree level.
    This can't be deserialized with the named serializer because in Hollywood
    tables each name can only be used once. To deserialize such tables you have
    to use the list serializer. See @{"List serialization" LINK ListSerialization} for details.

@ENDNODE

@NODE HollywoodSerialization "XML Plugin Guide"
@{b}Hollywood serialization@{ub}

    The Hollywood (de)serialization mode is a special mode that allows you to
    serialize arbitrary Hollywood tables. In contrast to the first two modes,
    Hollywood mode doesn't require the table to follow a certain layout. You can
    serialize any table to XML in this mode, just as you can with Hollywood's
    "ReadTable()" and "WriteTable()" functions. The table can even contain
    binary data or code like Hollywood functions.

    The disadvantage is that when deserializing XML data back to a Hollywood
    table in this mode, the XML must follow a certain convention because
    Hollywood needs to know the type of the data stored inside XML elements.
    Thus, even though it will probably work in most cases, it's not possible to
    generally deserialize any arbitrary XML data using the Hollywood serializer.
    You can only safely deserialize XMLs that have been serialized using the
    Hollywood serializer before. Here is an example, consider this Hollywood
    table:

        t = {1, 2, 3, 4, 5, test = "Hello", subtable = {x = 5, y = 6, z = "8"}}

    When serializing this table to XML using the Hollywood serializer, it will
    look like this:

        <?xml version="1.0" encoding="utf-8"?>
        <root>
           <item.0>1</item.0>
           <item.1>2</item.1>
           <item.2>3</item.2>
           <item.3>4</item.3>
           <item.4>5</item.4>
           <test>Hello</test>
           <subtable>
              <y>6</y>
              <x>5</x>
              <z type="string">8</z>
           </subtable>
        </root>

    You can see that sequential table indices are stored in the form of <item.n>
    and that the <z> tag has an additional "type" attribute that tells the
    deserializer that the value is to be stored as a string in the Hollywood
    table instead of a number. All these things are special conventions of the
    Hollywood serializer which is why it can't be used to deserialize arbitrary
    XML documents. The <root> tag that is at the top level can be changed to a
    different tag through the @{"xml.SetSerializeOptions()" LINK xmlSetSerializeOptions} function.

    Note that the Hollywood serializer mode also supports binary data. So in
    case the table contains Hollywood functions or strings that contain binary
    data, that data will be encoded as Base64 in the XML.

    To deserialize an arbitrary Hollywood table to an XML document and then
    serialize it back to a Hollywood table, you could do the following:

        xml.SetSerializeMode(#XML_SERIALIZEMODE_HOLLYWOOD)
        StringToFile(SerializeTable(t, "xml"), "test.xml")
        copy_of_t = DeserializeTable(FileToString("test.xml"), "xml")

@ENDNODE

@NODE xmlCreateParser "XML Plugin Guide"

   @{b}NAME@{ub}
        xml.CreateParser -- create new parser

   @{b}FORMERLY KNOWN AS@{ub}
        xmlparser.New (V1.x)

   @{b}SYNOPSIS@{ub}
        p = xml.CreateParser(t[, sep$, merge])

   @{b}FUNCTION@{ub}
        This function will create a new parser that can be used to iterate over
        XML documents. You have to pass a table that contains a selection of
        callback functions that should be called while the XML document is being
        parsed. The following callback functions can currently be passed in the
        table argument:

        AttlistDecl
                  The function you specify here will be called for attlist
                  declarations in the DTD. See @{"AttlistDecl" LINK AttlistDecl} for details. (V2.0)

        CharacterData
                  The function you specify here will be called for all data that
                  is not part of any XML entity. See @{"CharacterData" LINK CharacterData} for details.

        Comment   The function you specify here will be called when the parser
                  encounters a comment in the XML. See @{"Comment" LINK Comment} for details.

        DefaultExpand
                  This is the same as "DefaultHandler" except that the handler
                  doesn't inhibit the expansion of internal entity references.
                  See @{"DefaultExpand" LINK DefaultExpand} for details.

        DefaultHandler
                  The function you specify here will be called when the parser
                  encounters characters in the document which wouldn't otherwise
                  be handled. See @{"DefaultHandler" LINK DefaultHandler} for details.

        ElementDecl
                  The function you specify here will be called for element
                  declarations in a DTD. See @{"ElementDecl" LINK ElementDecl} for details. (V2.0)

        EndCDataSection
                  The function you specify here will be called when the parser
                  detects the end of an XML CDATA section. See @{"EndCDataSection" LINK EndCDataSection}
                  for details.

        EndDocTypeDecl
                  The function you specify here will be called when the parser
                  reaches the end of a DOCTYPE declaration. See @{"EndDocTypeDecl" LINK EndDocTypeDecl}
                  for details. (V2.0)

        EndElement
                  The function you specify here will be called when an XML node
                  is closed. See @{"EndElement" LINK EndElement} for details.

        EndNamespaceDecl
                  The function you specify here will be called when the parser
                  detects the end of an XML namespace declaration. Note that you
                  must specify the optional "sep$" parameter if you want the
                  parser to handle namespaces. See @{"EndNamespaceDecl" LINK EndNamespaceDecl} for details.

        EntityDecl
                  The function you specify here will be called when the parser
                  detects an entity declaration. See @{"EntityDecl" LINK EntityDecl} for details.
                  (V2.0)

        ExternalEntityRef
                  The function you specify here will be called when the parser
                  detects an external entity reference. See @{"ExternalEntityRef" LINK ExternalEntityRef}
                  for details.

        NotationDecl
                  The function you specify here will be called when the parser
                  encounters a notation declaration. See @{"NotationDecl" LINK NotationDecl} for
                  details.

        NotStandalone
                  The function you specify here will be called if the document
                  is not standalone without indicating so in the XML
                  declaration. See @{"NotStandalone" LINK NotStandalone} for details.

        ProcessingInstruction
                  The function you specify here will be called when the parser
                  detects XML processing instructions. See @{"ProcessingInstruction" LINK ProcessingInstruction}
                  for details.

        SkippedEntity
                  The function you specify here will be called when entities are
                  skipped. See @{"SkippedEntity" LINK SkippedEntity} for details. (V2.0)

        StartCDataSection
                  The function you specify here will be called when the parser
                  detects the beginning of an XML CDATA section. See
                  @{"StartCDataSection" LINK StartCDataSection} for details.

        StartDocTypeDecl
                  The function you specify here will be called when the parser
                  reaches the DOCTYPE declaration. See @{"StartDocTypeDecl" LINK StartDocTypeDecl} for
                  details.

        StartElement
                  The function you specify here will be called when the parser
                  encounters a new XML node. See @{"StartElement" LINK StartElement} for details.

        StartNamespaceDecl
                  The function you specify here will be called when the parser
                  detects an XML namespace declaration. Note that you must
                  specify the optional "sep$" parameter if you want the parser
                  to handle namespaces. See @{"StartNamespaceDecl" LINK StartNamespaceDecl} for details.

        UnparsedEntityDecl
                  The function you specify here will be called when the parser
                  detects declarations of unparsed entities. See
                  @{"UnparsedEntityDecl" LINK UnparsedEntityDecl} for details. Note that "UnparsedEntityDecl"
                  is obsolete and you should use "EntityDecl" instead (see
                  above).

        XMLDecl   The function you specify here will be called when the parser
                  detects XML declarations. See @{"XMLDecl" LINK XMLDecl} for details. (V2.0)

        The optional separator character "sep$" can be used to define the
        character used in the namespace expanded element names. If "sep$" isn't
        defined, the parser will not handle namespaces.

        The optional "merge" parameter can be used to configure whether or not
        the "CharacterData" callback should try to merge as much data as
        possible into a single string. This defaults to TRUE. If you set this to
        FALSE, your "CharacterData" callback could get called more often because
        the character data isn't merged into larger chunks.

        This function will return a parser object. You can call @{"parser:Parse()" LINK parserParse}
        to parse some XML using the parser object. Once you're done with
        parsing, call @{"parser:Free()" LINK parserFree} to free the parser object.

   @{b}INPUTS@{ub}
        t         table containing one or more callback functions (see above)
        sep$      optional: separator character
        merge     optional: whether or not the parser should try to merge
                  character data into bigger chunks of text (defaults to TRUE)
                  (V2.0)

   @{b}RESULTS@{ub}
        p         a parser object

   @{b}EXAMPLE@{ub}
        see @{"StartElement" LINK StartElement}

@ENDNODE

@NODE xmlSetSerializeMode "XML Plugin Guide"

   @{b}NAME@{ub}
        xml.SetSerializeMode -- set serialization mode (V2.0)

   @{b}SYNOPSIS@{ub}
        xml.SetSerializeMode(mode)

   @{b}FUNCTION@{ub}
        This can be used to set the desired serialization mode when using the
        plugin through its @{"serialization interface" LINK SerializationInterface}. You have to pass the
        desired serialization mode in the "mode" argument. The following
        serialization modes are currently supported:

        #XML_SERIALIZEMODE_LIST
                  This will store all XML nodes as sequential list items inside
                  the table. The first XML node will be at index 0, the second
                  at index 1, and so on. This is the default mode. See @{"List" LINK ListSerialization}
                  @{"serialization" LINK ListSerialization} for details.

        #XML_SERIALIZEMODE_NAMED
                  This will store all XML nodes as named items inside the table.
                  This means that you can conveniently access nodes by their
                  name instead of having to use numeric indices. The
                  disadvantage of this mode is that you can't have multiple
                  nodes of the same name on the same level because the nodes are
                  stored by name and each name is only available once per node
                  level. Another disadvantage is that you don't have control
                  over the order of the nodes when serializing them back to an
                  XML document. See @{"Named serialization" LINK NamedSerialization} for details.

        #XML_SERIALIZEMODE_HOLLYWOOD
                  This is a special mode that allows you to serialize arbitrary
                  Hollywood tables. In contrast to the first two modes,
                  Hollywood mode doesn't require the table to follow a certain
                  layout. You can serialize any table in this mode, just as you
                  can with Hollywood's "ReadTable()" and "WriteTable()"
                  functions. The table can even contain binary data or code like
                  Hollywood functions. See @{"Hollywood serialization" LINK HollywoodSerialization} for details.

        Further options can be configured using the @{"xml.SetSerializeOptions()" LINK xmlSetSerializeOptions}
        command. See @{"xml.SetSerializeOptions()" LINK xmlSetSerializeOptions} for details.

   @{b}INPUTS@{ub}
        mode      desired serialization mode (see above for possible values)

@ENDNODE

@NODE xmlSetSerializeOptions "XML Plugin Guide"

   @{b}NAME@{ub}
        xml.SetSerializeOptions -- set serialization options (V2.0)

   @{b}SYNOPSIS@{ub}
        xml.SetSerializeOptions(t)

   @{b}FUNCTION@{ub}
        This can be used to set certain options when using the plugin through
        its @{"serialization interface" LINK SerializationInterface}. The sole argument taken by this function
        is a table that can contain one or more of the following items:

        RootNode  This can be used to set the name of the XML's root node. This
                  is only used if the serialization mode is
                  #XML_SERIALIZEMODE_HOLLYWOOD. It defaults to "root".

        ForceLowerCase
                  When using the list or named serialization modes, the XML
                  plugin will always convert all node names to lower case. If
                  you don't want that, set this table item to FALSE. The default
                  value is TRUE. This tag is ignored for the Hollywood
                  serialization mode.

        IgnoreWhiteSpace
                  When using the list or named serialization modes, the XML
                  plugin will set the "Text" field of nodes that contain nothing
                  but whitespace characters (e.g. space, tab, line breaks...) to
                  an empty string. If you don't want that, set this item to
                  FALSE. The default value is TRUE. This tag is ignored for the
                  Hollywood serialization mode.

   @{b}INPUTS@{ub}
        t         table containing desired serialization options

@ENDNODE

@NODE parserFree "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:Free -- free parser

   @{b}FORMERLY KNOWN AS@{ub}
        parser:Close (V1.x)

   @{b}SYNOPSIS@{ub}
        parser:Free()

   @{b}FUNCTION@{ub}
        Closes the parser, freeing all memory used by it. A call to
        parser:Free() without a previous call to @{"parser:Parse()" LINK parserParse} could result in
        an error.

   @{b}INPUTS@{ub}
        none

   @{b}EXAMPLE@{ub}
        see @{"StartElement" LINK StartElement}

@ENDNODE

@NODE parserGetBase "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:GetBase -- get base for relative URIs

   @{b}SYNOPSIS@{ub}
        s$ = parser:GetBase()

   @{b}FUNCTION@{ub}
        Gets the base to be used for resolving relative URIs in system
        identifiers.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s$        base string

@ENDNODE

@NODE parserGetCallbacks "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:GetCallbacks -- get parser callbacks

   @{b}SYNOPSIS@{ub}
        cb = parser:GetCallbacks()

   @{b}FUNCTION@{ub}
        This simply returns a table containing all the callbacks that were
        specified when creating the parser using @{"xml.CreateParser()" LINK xmlCreateParser}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cb        table containing parser callbacks

@ENDNODE

@NODE parserGetError "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:GetError -- get extended error information (V2.0)

   @{b}SYNOPSIS@{ub}
        s$, line, col, pos = parser:GetError()

   @{b}FUNCTION@{ub}
        If @{"parser:Parse()" LINK parserParse} returns an error, you can use this method to get
        extended error information. The method returns a human-readable error
        message in "s$", the line and column index of the error in "line" and
        "col" and the byte index of the error in "pos".

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s$        error message
        line      line index (starting from 1)
        col       column index (starting from 1)
        pos       byte index of the error (starting from 1)

@ENDNODE

@NODE parserGetPosition "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:GetPosition -- get current parsing position

   @{b}FORMERLY KNOWN AS@{ub}
        parser:Pos (V1.x)

   @{b}SYNOPSIS@{ub}
        line, col, pos = parser:GetPosition()

   @{b}FUNCTION@{ub}
        This method returns the current parser position. The line and column
        indices are returned in "line" and "col" and the byte index is returned
        in "pos".

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        line      current line index (starting from 1)
        col       current column index (starting from 1)
        pos       current byte index (starting from 1)

@ENDNODE

@NODE parserParse "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:Parse -- parse XML code

   @{b}SYNOPSIS@{ub}
        ok = parser:Parse(s$)

   @{b}FUNCTION@{ub}
        This method parses XML code. The string "s$" contains part (or perhaps
        all) of the document to be parsed. The method returns a boolean value
        indicating success or failure. If parser:Parse() fails, you can use
        @{"parser:GetError()" LINK parserGetError} to get extended error information.

   @{b}INPUTS@{ub}
        s$        XML code to parse

   @{b}RESULTS@{ub}
        ok        boolean value indicating success or failure

   @{b}EXAMPLE@{ub}
        see @{"StartElement" LINK StartElement}

@ENDNODE

@NODE parserSetBase "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:SetBase -- set base for relative URIs

   @{b}SYNOPSIS@{ub}
        parser:SetBase(s$)

   @{b}FUNCTION@{ub}
        Sets the base to be used for resolving relative URIs in system
        identifiers to the string passed in "s$".

   @{b}INPUTS@{ub}
        s$        desired base

@ENDNODE

@NODE parserSetEncoding "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:SetEncoding -- set parser encoding

   @{b}SYNOPSIS@{ub}
        parser:SetEncoding(e$)

   @{b}FUNCTION@{ub}
        Set the encoding to be used by the parser. There are four built-in
        encodings, passed as strings: "US-ASCII", "UTF-8", "UTF-16", and
        "ISO-8859-1". parser:SetEncoding() must not be called after parsing has
        already been started with @{"parser:Parse()" LINK parserParse}.

   @{b}INPUTS@{ub}
        e$        encoding that should be used by the parser

@ENDNODE

@NODE parserStop "XML Plugin Guide"

   @{b}NAME@{ub}
        parser:Stop -- stop the parser

   @{b}SYNOPSIS@{ub}
        ok = parser:Stop()

   @{b}FUNCTION@{ub}
        Abort the parser and prevent it from parsing any further through the
        data it was last passed. Use this to halt parsing the document when an
        error is discovered inside a callback, for example. The parser object
        cannot accept more data after this call. The method returns a boolean
        value indicating success or failure.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        boolean value indicating success or failure

@ENDNODE

@NODE AttlistDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        AttlistDecl -- handler for attlist declarations in the DTD (V2.0)

   @{b}SYNOPSIS@{ub}
        AttlistDecl(p, elname$, attname$, atttype$, dflt$, isrequired)

   @{b}FUNCTION@{ub}
        This function is called for attlist declarations in the DTD. It is
        called for each attribute. So a single attlist declaration with multiple
        attributes declared will generate multiple calls to this handler. The
        "elname$" parameter returns the name of the element for which the
        attribute is being declared. The attribute name is in the "attname$"
        parameter. The attribute type is in the "atttype$" parameter. It is the
        string representing the type in the declaration with whitespace removed.

        The "dflt$" parameter holds the default value. It will be Nil in the
        case of #IMPLIED or #REQUIRED attributes. You can distinguish these two
        cases by checking the "isrequired" parameter, which will be TRUE in the
        case of #REQUIRED attributes. Attributes which are #FIXED will have also
        have a TRUE "isrequired", but they will have the non-Nil fixed value in
        the "dflt" parameter.

   @{b}PARAMETERS@{ub}
        p         parser handle
        elname$   name of the element for which the attribute is being declared
        attname$  attribute name
        attype$   attribute type
        dflt$     default value
        isrequired
                  TRUE or FALSE depending on whether the attribute is required

   @{b}EXAMPLE@{ub}
        Function p_AttlistDecl(p, elname$, attname$, atttype$, dflt$, isreq)
           DebugPrint(elname$, attname$, atttype$, dflt$, isreq)
        EndFunction
        
        p = xml.CreateParser({AttlistDecl = p_AttlistDecl})
        p:Parse([[
        <?xml version="1.0" standalone="yes"?>
        <!DOCTYPE lab_group [
           <!ELEMENT student_name (#PCDATA)>
           <!ATTLIST student_name student_no ID #REQUIRED>
           <!ATTLIST student_name tutor_1 IDREF #IMPLIED>
           <!ATTLIST student_name tutor_2 IDREF #IMPLIED>
        ]>
        <root/>
        ]])
        p:Free()

        The code above shows how to handle attlist declarations.

@ENDNODE

@NODE CharacterData "XML Plugin Guide"

   @{b}NAME@{ub}
        CharacterData -- parser has encountered character data

   @{b}SYNOPSIS@{ub}
        CharacterData(p, s$)

   @{b}FUNCTION@{ub}
        This function is called whenever the parser encounters data that is not
        part of any XML entity. The data is passed to your callback as a string
        in the "s$" parameter.

        Note that the character data for a single XML element might be passed to
        your callback in several separate chunks so make sure your code doesn't
        depend on getting all of the character data at once. By default, the XML
        plugin tries to merge character data into as few chunks of text as
        possible. You can turn off the merging functionality by passing FALSE in
        the optional third argument in your call to @{"xml.CreateParser()" LINK xmlCreateParser}. Note
        that even with the merge data option enabled (which is the default) it
        isn't guaranteed that all data will come in at once so be prepared to
        handle this correctly.

   @{b}PARAMETERS@{ub}
        p         parser handle
        s$        the character data

   @{b}EXAMPLE@{ub}
        Function p_CharacterData(p, s$)
           DebugPrint(s$)
        EndFunction
        
        p = xml.CreateParser({CharacterData = p_CharacterData})
        p:Parse([[<app>Hollywood</app>]])
        p:Free()

        The code above will print "Hollywood".

@ENDNODE

@NODE Comment "XML Plugin Guide"

   @{b}NAME@{ub}
        Comment -- parser has encountered a comment

   @{b}SYNOPSIS@{ub}
        Comment(p, s$)

   @{b}FUNCTION@{ub}
        This function is called whenever the parser encounters a comment in the
        XML. The comment data is passed to your callback as a string in the "s$"
        parameter.

   @{b}PARAMETERS@{ub}
        p         parser handle
        s$        the comment data

   @{b}EXAMPLE@{ub}
        Function p_Comment(p, s$)
           DebugPrint(s$)
        EndFunction
        
        p = xml.CreateParser({Comment = p_Comment})
        p:Parse([[
            <!--I'm a comment-->
            <app>Hollywood</app>
        ]])
        p:Free()

        The code above will print "I'm a comment".

@ENDNODE

@NODE DefaultExpand "XML Plugin Guide"

   @{b}NAME@{ub}
        DefaultExpand -- default handler with expansions

   @{b}SYNOPSIS@{ub}
        DefaultExpand(p, s$)

   @{b}FUNCTION@{ub}
        This does the same as @{"DefaultHandler()" LINK DefaultHandler} except that this handler doesn't
        inhibit the expansion of internal entity references. The entity
        reference will not be passed to the default handler.

   @{b}PARAMETERS@{ub}
        p         parser handle
        s$        the character data

@ENDNODE

@NODE DefaultHandler "XML Plugin Guide"

   @{b}NAME@{ub}
        DefaultHandler -- default handler for other characters

   @{b}SYNOPSIS@{ub}
        DefaultHandler(p, s$)

   @{b}FUNCTION@{ub}
        This function is called for any characters in the document which
        wouldn't otherwise be handled. This includes both data for which no
        handlers can be set (like some kinds of DTD declarations) and data which
        could be reported but which currently has no handler set. The characters
        are passed exactly as they were present in the XML document except that
        they will be encoded in UTF-8. Line boundaries are not normalized. Note
        that a byte order mark character is not passed to the default handler.
        There are no guarantees about how characters are divided between calls
        to the default handler: for example, a comment might be split between
        multiple calls. Setting the handler with this call has the side effect
        of turning off expansion of references to internally defined general
        entities. Instead these references are passed to the default handler.

   @{b}PARAMETERS@{ub}
        p         parser handle
        s$        the character data

@ENDNODE

@NODE ElementDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        ElementDecl -- handler for element declarations in the DTD (V2.0)

   @{b}SYNOPSIS@{ub}
        ElementDecl(p, name$, type, quantifier, children)

   @{b}FUNCTION@{ub}
        This function is called for element declarations in a DTD. The name of
        the element is passed in the "name$" parameter. If "type" equals
        #XML_CTYPE_EMPTY or #XML_CTYPE_ANY, then "quantifier" will be
        #XML_CQUANT_NONE, and the "children" table will be Nil.

        If "type" is #XML_CTYPE_MIXED, then "quantifier" will be
        #XML_CQUANT_NONE or #XML_CQUANT_REP and the "children" table will
        contain the elements that are allowed to be mixed in. All those children
        will have type #XML_CTYPE_NAME with no quantification then. Only the
        root node can be of type #XML_CTYPE_EMPTY, #XML_CTYPE_ANY, or
        #XML_CTYPE_MIXED.

        For type #XML_CTYPE_NAME, the "name$" parameter will contain the name
        and the "children" table will be Nil. The "quantifier" parameter will
        indicate any quantifiers placed on the name.

        Types #XML_CTYPE_CHOICE and #XML_CTYPE_SEQ indicate a choice or sequence
        respectively. The "children" table then contains the nodes in the choice
        or sequence.

        The children passed in the "children" table will have the fields "name",
        "type", "quantifier", and "children" set. They correspond to the
        parameters of the same name passed to ElementDecl().

        Possible values for the "type" parameter/field:

            #XML_CTYPE_EMPTY
            #XML_CTYPE_ANY
            #XML_CTYPE_MIXED
            #XML_CTYPE_NAME
            #XML_CTYPE_CHOICE
            #XML_CTYPE_SEQ

        Possible values for the "quantifier" parameter/field:

            #XML_CQUANT_NONE
            #XML_CQUANT_OPT
            #XML_CQUANT_REP
            #XML_CQUANT_PLUS

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     name of the element
        type      element type
        quantifier
                  element quantifier
        children  child nodes or Nil

   @{b}EXAMPLE@{ub}
        Function p_ElementDecl(p, elname$, type, quant, children)
           DebugPrint(elname$, type, quant, children)
        EndFunction
        
        p = xml.CreateParser({ElementDecl = p_ElementDecl})
        p:Parse([[
        <!DOCTYPE student [
           <!ELEMENT student (id|surname)>
           <!ELEMENT id (#PCDATA)>
        ]>
        <student>
           <id>9216735</id>
        </student>
        ]])
        p:Free()

        The code above shows how to handle attlist declarations.

@ENDNODE

@NODE EndCDataSection "XML Plugin Guide"

   @{b}NAME@{ub}
        EndCDataSection -- end of CDATA section has been reached

   @{b}SYNOPSIS@{ub}
        EndCDataSection(p)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects the end of an XML CDATA
        section. In the callback, you can use @{"parser:GetPosition()" LINK parserGetPosition} to get the
        current parser position.

   @{b}PARAMETERS@{ub}
        p         parser handle

@ENDNODE

@NODE EndDocTypeDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        EndDocTypeDecl -- parser has reached the end of a DOCTYPE declaration (V2.0)

   @{b}SYNOPSIS@{ub}
        EndDocTypeDecl(p)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects the end of the DOCTYPE
        declaration when the closing > is encountered, but after processing any
        external subset.

   @{b}PARAMETERS@{ub}
        p         parser handle

@ENDNODE

@NODE EndElement "XML Plugin Guide"

   @{b}NAME@{ub}
        EndElement -- XML element has been closed

   @{b}SYNOPSIS@{ub}
        EndElement(p, name$)

   @{b}FUNCTION@{ub}
        This function is called whenever an XML element is closed. The name of
        the XML element is passed in "name$".

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     name of the XML element

   @{b}EXAMPLE@{ub}
        see @{"StartElement" LINK StartElement}

@ENDNODE

@NODE EndNamespaceDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        EndNamespaceDecl -- parser has detected the end of a namespace declaration

   @{b}SYNOPSIS@{ub}
        EndNamespaceDecl(p, name$)

   @{b}FUNCTION@{ub}
        This function is called when leaving the scope of the namespace
        declaration specified by "name$". This handler will be called, for each
        namespace declaration, after the handler for the end tag of the element
        in which the namespace was declared.

        Note that you must specify the optional "sep$" parameter in your call to
        @{"xml.CreateParser()" LINK xmlCreateParser} if you want the parser to handle namespaces.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     namespace name

@ENDNODE

@NODE EntityDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        EntityDecl -- parser has detected an entity declaration

   @{b}SYNOPSIS@{ub}
        EntityDecl(p, name$, isparm, value$, base$, sysid$, pubid$, notation$)

   @{b}FUNCTION@{ub}
        This function is called for entity declarations. The "isparm" argument
        will be TRUE if the entity is a parameter entity, FALSE otherwise. For
        internal entities, e.g.

            (<!ENTITY foo "bar">)

        "value$" will be a string and "sysid$", "pubid$", and "notation$" will
        be Nil. The "value$" string can be Nil, as well as an empty string,
        which is a valid value. For external entities, "value$" will be Nil and
        "sysid$" will be a string. The "pubid$" argument will be Nil unless a
        public identifier was provided. The "notation$" argument will have a
        string value only for unparsed entity declarations.

        The "base$" parameter will be set to whatever has been set with
        @{"parser:SetBase()" LINK parserSetBase}. If not set, it will be Nil.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     entity name
        isparm    TRUE if the entity is a parameter entity
        base$     base to use for relative system identifiers
        sysid$    system ID
        pubid$    public ID
        notation$ notation name

@ENDNODE

@NODE ExternalEntityRef "XML Plugin Guide"

   @{b}NAME@{ub}
        ExternalEntityRef -- parser has detected an external entity reference

   @{b}SYNOPSIS@{ub}
        ExternalEntityRef(p, subparser, base$, sysid$, pubid$)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects an external entity
        reference. The "subparser" parameter contains a parser handle created
        with the same callbacks and context as the main parser and should be
        used to parse the external entity. The "base$" parameter is the base to
        use for relative system identifiers. It is set by @{"parser:SetBase()" LINK parserSetBase} and
        may be Nil. The "sysid$" parameter is the system identifier specified in
        the entity declaration and is never Nil. The "pubid$" parameter is the
        public ID given in the entity declaration and may be Nil.

   @{b}PARAMETERS@{ub}
        p         parser handle
        subparser subparser handle for parsing the external entity
        base$     base to use for relative system identifiers
        sysid$    system ID
        pubid$    public ID

@ENDNODE

@NODE NotationDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        NotationDecl -- parser has detected a notation declaration

   @{b}SYNOPSIS@{ub}
        NotationDecl(p, name$, base$, sysid$, pubid$)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects an XML notation
        declaration. The notation name is passed in the "name$" parameter. The
        "base$" parameter is the base to use for relative system identifiers. It
        is set by @{"parser:SetBase()" LINK parserSetBase} and may be Nil. The "sysid$" parameter is the
        system identifier specified in the entity declaration and is never Nil.
        The "pubid$" parameter is the public ID given in the entity declaration
        and may be Nil.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     notation name
        base$     base to use for relative system identifiers
        sysid$    system ID
        pubid$    public ID

@ENDNODE

@NODE NotStandalone "XML Plugin Guide"

   @{b}NAME@{ub}
        NotStandalone -- handle non-standalone documents

   @{b}SYNOPSIS@{ub}
        ok = NotStandalone(p)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects that the document is not
        "stand-alone". This happens when there is an external subset or a
        reference to a parameter entity, but the document does not have
        standalone set to "yes" in an XML declaration. This callback expects a
        return value, if the callback returns FALSE, parsing will be aborted.

   @{b}PARAMETERS@{ub}
        p         parser handle

   @{b}RESULTS@{ub}
        ok        return TRUE to continue parsing, FALSE to abort

@ENDNODE

@NODE ProcessingInstruction "XML Plugin Guide"

   @{b}NAME@{ub}
        ProcessingInstruction -- parser is processing instruction

   @{b}SYNOPSIS@{ub}
        ProcessingInstruction(p, target$, data$)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects XML processing
        instructions. The "target$" is the first word in the processing
        instruction. The "data$" is the rest of the characters in it after
        skipping all whitespace after the initial word.

   @{b}PARAMETERS@{ub}
        p         parser handle
        target$   first word in the processing instruction
        data$     rest of the characters after the initial word

   @{b}EXAMPLE@{ub}
        Function p_ProcessingInstruction(p, target$, data$)
           DebugPrint(target$, data$)
        EndFunction
        
        p = xml.CreateParser({ProcessingInstruction = p_ProcessingInstruction})
        p:Parse([[<foo><?Hollywood rocks?></foo>]])
        p:Free()

        The code above prints "Hollywood rocks".

@ENDNODE

@NODE SkippedEntity "XML Plugin Guide"

   @{b}NAME@{ub}
        SkippedEntity -- parser has skipped an entity (V2.0)

   @{b}SYNOPSIS@{ub}
        SkippedEntity(p, name$, isparm)

   @{b}FUNCTION@{ub}
        This function is called in two situations:

        1. An entity reference is encountered for which no declaration has been
           read and this is not an error.
        2. An internal entity reference is read, but not expanded, because
           @{"DefaultHandler()" LINK DefaultHandler} has been called.

        The "isparm" argument will be TRUE for a parameter entity and FALSE for
        a general entity.

        Note: Skipped parameter entities in declarations and skipped general
        entities in attribute values cannot be reported, because the event would
        be out of sync with the reporting of the declarations or attribute
        values.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     entity name
        isparm    TRUE for parameter entities, FALSE for general entities

@ENDNODE

@NODE StartCDataSection "XML Plugin Guide"

   @{b}NAME@{ub}
        StartCDataSection -- CDATA section is about to be parsed

   @{b}SYNOPSIS@{ub}
        StartCDataSection(p)

   @{b}FUNCTION@{ub}
        This function is called when the parser detects the beginning of an XML
        CDATA section. In the callback, you can use @{"parser:GetPosition()" LINK parserGetPosition} to get
        the current parser position.

   @{b}PARAMETERS@{ub}
        p         parser handle

@ENDNODE

@NODE StartDocTypeDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        StartDocTypeDecl -- parser has reached the DOCTYPE declaration

   @{b}SYNOPSIS@{ub}
        StartDocTypeDecl(p, name$, sysid$, pubid$, subset)

   @{b}FUNCTION@{ub}
        This function is called at the start of a DOCTYPE declaration, before
        any external or internal subset is parsed. The callback receives the
        DOCTYPE name in "name$", the system ID in "sysid$", the public ID in
        "pubid$". The "subset" parameter will be TRUE if the DOCTYPE declaration
        has an internal subset.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     DOCTYPE name
        sysid$    system ID
        pubid$    public ID
        subset    TRUE if DOCTYPE declaration has an internal subset

@ENDNODE

@NODE StartElement "XML Plugin Guide"

   @{b}NAME@{ub}
        StartElement -- an XML element has been found

   @{b}SYNOPSIS@{ub}
        StartElement(p, name$, attrs)

   @{b}FUNCTION@{ub}
        This function is called whenever a new XML element is opened. The name
        of the XML element is passed in "name$". The "attrs" parameter is a
        table with all the element attribute names and values. The table
        contains an entry for every attribute in the element start tag. The
        attribute's name is used as the table index.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     name of the XML element
        attrs     table containing all element attributes

   @{b}EXAMPLE@{ub}
        Function p_StartElement(p, name$, attrs)
           DebugPrint("Open:", name$, attrs.name, attrs.author)
        EndFunction
        Function p_EndElement(p, name$)
           DebugPrint("Close:", name$)
        EndFunction
        
        p = xml.CreateParser({StartElement = p_StartElement,
          EndElement = p_EndElement})
        p:Parse([[<plugin name="XML" author="Andreas Falkenhahn"/>]])
        p:Free()

        The code above will print "Open: plugin XML Andreas Falkenhahn" and then
        "Close: plugin".

@ENDNODE

@NODE StartNamespaceDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        StartNamespaceDecl -- parser has detected a namespace declaration

   @{b}SYNOPSIS@{ub}
        StartNamespaceDecl(p, name$, uri$)

   @{b}FUNCTION@{ub}
        This function is called when a namespace is declared. The callback will
        receive the name and URI of the namespace in the "name$" and "uri$"
        parameters. Note that even though namespace declarations occur inside
        start tags the namespace declaration start handler is called before the
        start tag handler for each namespace declared in that start tag.

        Note that you must specify the optional "sep$" parameter in your call to
        @{"xml.CreateParser()" LINK xmlCreateParser} if you want the parser to handle namespaces.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     namespace name
        uri$      namespace URI

   @{b}EXAMPLE@{ub}
        Function p_StartNamespaceDecl(p, name$, uri$)
           DebugPrint(name$, uri$)
        EndFunction
        
        p = xml.CreateParser({StartNamespaceDecl = p_StartNamespaceDecl}, "?")
        p:Parse([[<foo xmlns:space='a/namespace'/>]])
        p:Free()

        The code above will print "space a/namespace".

@ENDNODE

@NODE UnparsedEntityDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        UnparsedEntityDecl -- parser has detected an unparsed entity declaration

   @{b}SYNOPSIS@{ub}
        UnparsedEntityDecl(p, name$, base$, sysid$, pubid$, notation$)

   @{b}FUNCTION@{ub}
        This function is called when the parser receives declarations of
        unparsed entities. These are entity declarations that have a notation
        (NDATA) field. As an example, in the chunk

            <!ENTITY logo SYSTEM "images/logo.gif" NDATA gif>

        the "name$" parameter would be "logo", "sysid$" would be
        "images/logo.gif" and "notation$" would be "gif". For this example the
        "pubid$" parameter would be Nil. The "base$" parameter would be whatever
        has been set with @{"parser:SetBase()" LINK parserSetBase}. If not set, it would be Nil.

        Note that UnparsedEntityDecl() is obsolete and you should use
        @{"EntityDecl()" LINK EntityDecl} instead.

   @{b}PARAMETERS@{ub}
        p         parser handle
        name$     entity name
        base$     base to use for relative system identifiers
        sysid$    system ID
        pubid$    public ID
        notation$ notation name

@ENDNODE

@NODE XMLDecl "XML Plugin Guide"

   @{b}NAME@{ub}
        XMLDecl -- parser has reached an XML declaration (V2.0)

   @{b}SYNOPSIS@{ub}
        XMLDecl(p, version$, encoding$, standalone)

   @{b}FUNCTION@{ub}
        This function is called s called for XML declarations and also for text
        declarations discovered in external entities. The way to distinguish is
        that the "version$" parameter will be Nil for text declarations. The
        "encoding$" parameter may be Nil for an XML declaration. The
        "standalone" argument will contain -1, 0, or 1 indicating respectively
        that there was no standalone parameter in the declaration, that it was
        given as no, or that it was given as yes.

   @{b}PARAMETERS@{ub}
        p         parser handle
        version$  version in XML declaration
        encoding$ encoding in XML declaration
        standalone
                  stand-alone state of the declaration, can be 0, -1 or 1 (see
                  above)

   @{b}EXAMPLE@{ub}
        Function p_XMLDecl(p, version$, encoding$, standalone)
           DebugPrint(version$, encoding$, standalone)
        EndFunction
        
        p = xml.CreateParser({XMLDecl = p_XMLDecl})
        p:Parse([[<?xml version="1.0" encoding="ISO-8859-1"?><body/>]])
        p:Free()

        The code above will prints "1.0 ISO-8859-1 -1".

@ENDNODE

@NODE LicenseExpat "MUI Royale Guide"
@{b}Expat license@{ub}

    Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd and
    Clark Cooper

    Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006 Expat maintainers.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

@ENDNODE

@NODE LicenseLuaExpat "XML Plugin Guide"
@{b}LuaExpat license@{ub}

    LuaExpat is free software: it can be used for both academic and commercial
    purposes at absolutely no cost. There are no royalties or GNU-like
    "copyleft" restrictions. LuaExpat qualifies as Open Source software. Its
    licenses are compatible with GPL. LuaExpat is not in the public domain and
    the Kepler Project keep its copyright. The legal details are below.

    The spirit of the license is that you are free to use LuaExpat for any
    purpose at no cost without having to ask us. The only requirement is that if
    you do use LuaExpat, then you should give us credit by including the
    appropriate copyright notice somewhere in your product or its documentation.

    The LuaExpat library is designed and implemented by Roberto Ierusalimschy.
    The implementation is not derived from licensed software.

    Copyright (C) 2003-2007 The Kepler Project.

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.

@ENDNODE

@NODE XMLFunctions "XML Plugin Guide"
@{b}Function reference@{ub}

    @{"xml.CreateParser()                        " LINK xmlCreateParser} Create new parser
    @{"xml.SetSerializeMode()                    " LINK xmlSetSerializeMode} Set serialization mode
    @{"xml.SetSerializeOptions()                 " LINK xmlSetSerializeOptions} Set serialization options

@ENDNODE

@NODE ParserMethods "XML Plugin Guide"
@{b}Parser methods@{ub}

    @{"parser:Free()                             " LINK parserFree} Free parser
    @{"parser:GetBase()                          " LINK parserGetBase} Get base for relative URIs
    @{"parser:GetCallbacks()                     " LINK parserGetCallbacks} Get parser callbacks
    @{"parser:GetError()                         " LINK parserGetError} Get extended error information
    @{"parser:GetPosition()                      " LINK parserGetPosition} Get current parsing position
    @{"parser:Parse()                            " LINK parserParse} Parse XML code
    @{"parser:SetBase()                          " LINK parserSetBase} Set base for relative URIs
    @{"parser:SetEncoding()                      " LINK parserSetEncoding} Set parser encoding
    @{"parser:Stop()                             " LINK parserStop} Stop the parser

@ENDNODE

@NODE CallbackFunctions "XML Plugin Guide"
@{b}Callback reference@{ub}

    @{"AttlistDecl()                             " LINK AttlistDecl} Handler for attlist declarations in the DTD
    @{"CharacterData()                           " LINK CharacterData} Parser has encountered character data
    @{"Comment()                                 " LINK Comment} Parser has encountered a comment
    @{"DefaultExpand()                           " LINK DefaultExpand} Default handler with expansions
    @{"DefaultHandler()                          " LINK DefaultHandler} Default handler for other characters
    @{"ElementDecl()                             " LINK ElementDecl} Handler for element declarations in the DTD
    @{"EndCDataSection()                         " LINK EndCDataSection} End of CDATA section has been reached
    @{"EndDocTypeDecl()                          " LINK EndDocTypeDecl} Parser has reached the end of a DOCTYPE declaration
    @{"EndElement()                              " LINK EndElement} XML element has been closed
    @{"EndNamespaceDecl()                        " LINK EndNamespaceDecl} Parser has detected the end of a namespace declaration
    @{"EntityDecl()                              " LINK EntityDecl} Parser has detected an entity declaration
    @{"ExternalEntityRef()                       " LINK ExternalEntityRef} Parser has detected an external entity reference
    @{"NotationDecl()                            " LINK NotationDecl} Parser has detected a notation declaration
    @{"NotStandalone()                           " LINK NotStandalone} Handle non-standalone documents
    @{"ProcessingInstruction()                   " LINK ProcessingInstruction} Parser is processing instruction
    @{"SkippedEntity()                           " LINK SkippedEntity} Parser has skipped an entity
    @{"StartCDataSection()                       " LINK StartCDataSection} CDATA section is about to be parsed
    @{"StartDocTypeDecl()                        " LINK StartDocTypeDecl} Parser has reached the DOCTYPE declaration
    @{"StartElement()                            " LINK StartElement} An XML element has been found
    @{"StartNamespaceDecl()                      " LINK StartNamespaceDecl} Parser has detected a namespace declaration
    @{"UnparsedEntityDecl()                      " LINK UnparsedEntityDecl} Parser has detected an unparsed entity declaration
    @{"XMLDecl()                                 " LINK XMLDecl} Parser has reached an XML declaration

@ENDNODE

@NODE Reference "XML Plugin Guide"
@{b}Reference@{ub}

    @{"AttlistDecl()                             " LINK AttlistDecl} Handler for attlist declarations in the DTD
    @{"CharacterData()                           " LINK CharacterData} Parser has encountered character data
    @{"Comment()                                 " LINK Comment} Parser has encountered a comment
    @{"Credits                                   " LINK Credits} Who was involved in this project?
    @{"DefaultExpand()                           " LINK DefaultExpand} Default handler with expansions
    @{"DefaultHandler()                          " LINK DefaultHandler} Default handler for other characters
    @{"ElementDecl()                             " LINK ElementDecl} Handler for element declarations in the DTD
    @{"EndCDataSection()                         " LINK EndCDataSection} End of CDATA section has been reached
    @{"EndDocTypeDecl()                          " LINK EndDocTypeDecl} Parser has reached the end of a DOCTYPE declaration
    @{"EndElement()                              " LINK EndElement} XML element has been closed
    @{"EndNamespaceDecl()                        " LINK EndNamespaceDecl} Parser has detected the end of a namespace declaration
    @{"EntityDecl()                              " LINK EntityDecl} Parser has detected an entity declaration
    @{"ExternalEntityRef()                       " LINK ExternalEntityRef} Parser has detected an external entity reference
    @{"F.A.Q.                                    " LINK FAQ} Frequently asked questions
    @{"Future                                    " LINK ToDo} What is planned for the future?
    @{"History                                   " LINK History} What happened so far?
    @{"Hollywood serializer                      " LINK HollywoodSerialization} Serialize arbitrary Hollywood tables
    @{"Installation                              " LINK Installation} How to install xml.hwp
    @{"Interfaces overview                       " LINK Interfaces} Overview on the plugin interfaces
    @{"Introduction                              " LINK Introduction} What is xml.hwp?
    @{"Known issues                              " LINK KnownIssues} List of things that can cause trouble
    @{"Library interface                         " LINK LibraryInterface} The interface with the greatest flexibility
    @{"List serializer                           " LINK ListSerialization} Serialize nodes as sequential list items
    @{"Named serializer                          " LINK NamedSerialization} Serialize nodes as named table items
    @{"NotationDecl()                            " LINK NotationDecl} Parser has detected a notation declaration
    @{"NotStandalone()                           " LINK NotStandalone} Handle non-standalone documents
    @{"parser:Free()                             " LINK parserFree} Free parser
    @{"parser:GetBase()                          " LINK parserGetBase} Get base for relative URIs
    @{"parser:GetCallbacks()                     " LINK parserGetCallbacks} Get parser callbacks
    @{"parser:GetError()                         " LINK parserGetError} Get extended error information
    @{"parser:GetPosition()                      " LINK parserGetPosition} Get current parsing position
    @{"parser:Parse()                            " LINK parserParse} Parse XML code
    @{"parser:SetBase()                          " LINK parserSetBase} Set base for relative URIs
    @{"parser:SetEncoding()                      " LINK parserSetEncoding} Set parser encoding
    @{"parser:Stop()                             " LINK parserStop} Stop the parser
    @{"ProcessingInstruction()                   " LINK ProcessingInstruction} Parser is processing instruction
    @{"Requirements                              " LINK Requirements} What you need to work with it
    @{"Serialization interface                   " LINK SerializationInterface} The interface that is most convenient
    @{"SkippedEntity()                           " LINK SkippedEntity} Parser has skipped an entity
    @{"StartCDataSection()                       " LINK StartCDataSection} CDATA section is about to be parsed
    @{"StartDocTypeDecl()                        " LINK StartDocTypeDecl} Parser has reached the DOCTYPE declaration
    @{"StartElement()                            " LINK StartElement} An XML element has been found
    @{"StartNamespaceDecl()                      " LINK StartNamespaceDecl} Parser has detected a namespace declaration
    @{"Terms and conditions                      " LINK License} License information
    @{"UnparsedEntityDecl()                      " LINK UnparsedEntityDecl} Parser has detected an unparsed entity declaration
    @{"xml.CreateParser()                        " LINK xmlCreateParser} Create new parser
    @{"xml.SetSerializeMode()                    " LINK xmlSetSerializeMode} Set serialization mode
    @{"xml.SetSerializeOptions()                 " LINK xmlSetSerializeOptions} Set serialization options
    @{"XMLDecl()                                 " LINK XMLDecl} Parser has reached an XML declaration

@ENDNODE
