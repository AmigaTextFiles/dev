/*
 * 3-D gear wheels.  This program is in the public domain.
 *
 * Command line options:
 *    -info      print GL implementation information
 *    -exit      automatically exit after 30 seconds
 *
 *
 * Written by Brian Paul
 * Ported to Hollywood by Andreas Falkenhahn
 *
 *
 * Marcus Geelnard:
 *   - Conversion to GLFW
 *   - Time based rendering (frame rate independent)
 *   - Slightly modified camera that should work better for stereo viewing
 *
 *
 * Camilla Berglund:
 *   - Removed FPS counter (this is not a benchmark)
 *   - Added a few comments
 *   - Enabled vsync
 */

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Width = 300, Height = 300, Title = "Gears - use cursor keys to rotate", Sizeable = True}

/**

  Draw a gear wheel.  You'll probably want to call this function when
  building a display list since we do a lot of trig here.

  Input:  inner_radius - radius of hole at center
	  outer_radius - radius at center of teeth
	  width - width of gear teeth - number of teeth
	  tooth_depth - depth of tooth

 **/
Function p_Gear(inner_radius, outer_radius, width, teeth, tooth_depth)

  	Local angle
  	Local u, v, len
  	Local r0 = inner_radius
  	Local r1 = outer_radius - tooth_depth / 2
  	Local r2 = outer_radius + tooth_depth / 2
  	Local da = 2 * #PI / teeth / 4

  	gl.ShadeModel(#GL_FLAT)

  	gl.Normal(0, 0, 1)

  	; draw front face
  	gl.Begin(#GL_QUAD_STRIP)
  
  	For Local i = 0 To teeth
    		
    		angle = i * 2 * #PI / teeth
    		gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), width * 0.5)
    		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), width * 0.5)
    		
    		If i < teeth
      			gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), width * 0.5)
      			gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), width * 0.5)
      		EndIf
      	Next

	gl.End()

  	; draw front sides of teeth
  	gl.Begin(#GL_QUADS)
  
  	da = 2 * #PI / teeth / 4
  
  	For Local i = 0 To teeth - 1  		
    		angle = i * 2 * #PI / teeth
		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), width * 0.5)
    		gl.Vertex(r2 * Cos(angle + da), r2 * Sin(angle + da), width * 0.5)
    		gl.Vertex(r2 * Cos(angle + 2 * da), r2 * Sin(angle + 2 * da), width * 0.5)
    		gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), width * 0.5)
  	Next
  	
	gl.End()

	gl.Normal(0.0, 0.0, -1.0)

	; draw back face 
  	gl.Begin(#GL_QUAD_STRIP)
  	For Local i = 0 To teeth
  		
    		angle = i * 2 * #PI / teeth
    		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), -width * 0.5)
    		gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), -width * 0.5)
    		
		If i < teeth
      			gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), -width * 0.5)
      			gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), -width * 0.5)
      		EndIf
      	Next
      	
	gl.End()

	; draw back sides of teeth
  	gl.Begin(#GL_QUADS)
  	da = 2 * #PI / teeth / 4
  	For Local i = 0 To teeth - 1
		angle = i * 2 * #PI / teeth
		gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), -width * 0.5)
		gl.Vertex(r2 * Cos(angle + 2 * da), r2 * Sin(angle + 2 * da), -width * 0.5)
    		gl.Vertex(r2 * Cos(angle + da), r2 * Sin(angle + da), -width * 0.5)
    		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), -width * 0.5)
  	Next
  	
	gl.End()

	; draw outward faces of teeth
  	gl.Begin(#GL_QUAD_STRIP)
  	For Local i = 0  To teeth - 1
  		angle = i * 2 * #PI / teeth
		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), width * 0.5)
    		gl.Vertex(r1 * Cos(angle), r1 * Sin(angle), -width * 0.5)
    		u = r2 * Cos(angle + da) - r1 * Cos(angle)
    		v = r2 * Sin(angle + da) - r1 * Sin(angle)
    		len = Sqrt(u * u + v * v)
    		u = u / len
    		v = v / len
    		gl.Normal(v, -u, 0.0)
    		gl.Vertex(r2 * Cos(angle + da), r2 * Sin(angle + da), width * 0.5)
    		gl.Vertex(r2 * Cos(angle + da), r2 * Sin(angle + da), -width * 0.5)
    		gl.Normal(Cos(angle), Sin(angle), 0)
    		gl.Vertex(r2 * Cos(angle + 2 * da), r2 * Sin(angle + 2 * da), width * 0.5)
    		gl.Vertex(r2 * Cos(angle + 2 * da), r2 * Sin(angle + 2 * da), -width * 0.5)
    		u = r1 * Cos(angle + 3 * da) - r2 * Cos(angle + 2 * da)
    		v = r1 * Sin(angle + 3 * da) - r2 * Sin(angle + 2 * da)
    		gl.Normal(v, -u, 0)
    		gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), width * 0.5)
    		gl.Vertex(r1 * Cos(angle + 3 * da), r1 * Sin(angle + 3 * da), -width * 0.5)
    		gl.Normal(Cos(angle), Sin(angle), 0)
  	Next
  
	gl.Vertex(r1 * Cos(0), r1 * Sin(0), width * 0.5)
  	gl.Vertex(r1 * Cos(0), r1 * Sin(0), -width * 0.5)

	gl.End()

  	gl.ShadeModel(#GL_SMOOTH)

	; draw inside radius cylinder
  	gl.Begin(#GL_QUAD_STRIP)
  	
  	For Local i = 0 To teeth
		angle = i * 2 * #PI / teeth
    		gl.Normal(-Cos(angle), -Sin(angle), 0)
    		gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), -width * 0.5)
    		gl.Vertex(r0 * Cos(angle), r0 * Sin(angle), width * 0.5)
  	Next
  	
	gl.End()

EndFunction

/* OpenGL draw function & timing */
Function p_Draw()

	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)

  	gl.PushMatrix()
    	gl.Rotate(view_rotx, 1.0, 0.0, 0.0)
    	gl.Rotate(view_roty, 0.0, 1.0, 0.0)
    	gl.Rotate(view_rotz, 0.0, 0.0, 1.0)

    	gl.PushMatrix()
      	gl.Translate(-3.0, -2.0, 0.0)
      	gl.Rotate(angle, 0.0, 0.0, 1.0)
      	gl.CallList(gear1)
    	gl.PopMatrix()

    	gl.PushMatrix()
      	gl.Translate(3.1, -2, 0)
      	gl.Rotate(-2 * angle - 9, 0, 0, 1)
      	gl.CallList(gear2)
    	gl.PopMatrix()

    	gl.PushMatrix()
      	gl.Translate(-3.1, 4.2, 0)
      	gl.Rotate(-2 * angle - 25, 0, 0, 1)
      	gl.CallList(gear3)
    	gl.PopMatrix()

	gl.PopMatrix()

EndFunction


/* update animation parameters */
Function p_Animate()

	angle = 100 * (GetTimer(1) / 1000)

EndFunction

/* change view angle, exit upon ESC */
Function p_OnKey(msg)

	Switch msg.key
	Case "Z"
		If IsKeyDown("LSHIFT") Or IsKeyDown("RSHIFT")
			view_rotz = view_rotz - 5.0
    		Else
			view_rotz = view_rotz + 5.0
		EndIf			
	Case "UP":
    		view_rotx = view_rotx + 5.0
    	Case "DOWN":
    		view_rotx = view_rotx - 5.0
   	Case "LEFT":
    		view_roty = view_roty + 5.0
    	Case "RIGHT":
    		view_roty = view_roty - 5.0
	EndSwitch

EndFunction

/* program & OpenGL initialization */
Function p_Init()

	Local pos = {5, 5, 10, 0}
  	Local redc = {0.8, 0.1, 0, 1}
  	Local greenc = {0, 0.8, 0.2, 1}
  	Local bluec = {0.2, 0.2, 1, 1}

	view_rotx = 20
	view_roty = 30
	view_rotz = 0

  	gl.Light(#GL_LIGHT0, #GL_POSITION, pos)
  	gl.Enable(#GL_CULL_FACE)
  	gl.Enable(#GL_LIGHTING)
  	gl.Enable(#GL_LIGHT0)
  	gl.Enable(#GL_DEPTH_TEST)

  	; make the gears
  	gear1 = gl.GenLists(1)
  	gl.NewList(gear1, #GL_COMPILE)
  	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, redc)
  	p_Gear(1, 4, 1, 20, 0.7)
  	gl.EndList()

  	gear2 = gl.GenLists(1)
  	gl.NewList(gear2, #GL_COMPILE)
  	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, greenc)
	p_Gear(0.5, 2, 2, 10, 0.7)
	gl.EndList()

  	gear3 = gl.GenLists(1)
  	gl.NewList(gear3, #GL_COMPILE)
  	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, bluec)
  	p_Gear(1.3, 2, 0.5, 10, 0.7)
	gl.EndList()

  	gl.Enable(#GL_NORMALIZE)

EndFunction

/* new window size */
Function p_Reshape(msg)

	Local h = msg.height / msg.width
  	Local znear = 5.0
  	Local zfar  = 30.0
  	Local xmax  = znear * 0.5

	gl.Viewport(0, 0, msg.width, msg.height)
  	gl.MatrixMode(#GL_PROJECTION)
  	gl.LoadIdentity()
  	gl.Frustum(-xmax, xmax, -xmax*h, xmax*h, znear, zfar)
  	gl.MatrixMode(#GL_MODELVIEW)
  	gl.LoadIdentity()
  	gl.Translate(0.0, 0.0, -20.0)

	If msg.action = "ModeSwitch" Then p_Init()
		
EndFunction

p_Reshape({Width = 300, Height = 300, Action = "ModeSwitch"})

InstallEventHandler({
	SizeWindow = Function(msg) p_Reshape(msg) EndFunction,
	ModeSwitch = Function(msg) p_Reshape(msg) EndFunction,
	OnKeyDown = Function(msg) p_OnKey(msg) EndFunction
	})

; Setup a hardware doublebuffer managed by GL Galore	
BeginDoubleBuffer(True)

StartTimer(1)

EscapeQuit(True)

Repeat
	DisableLineHook()

	; Draw gears
	p_Draw()
	
	; Update animation
	p_Animate()
	
	EnableLineHook()

	; Swap buffers
	Flip
	CheckEvent
Forever
