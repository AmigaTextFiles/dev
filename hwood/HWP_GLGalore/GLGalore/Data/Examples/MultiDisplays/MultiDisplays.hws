/****************************************************************
**                                                             **
** Name:        MultiDisplays                                  **
** Author:      Andreas Falkenhahn                             **
** Version:     1.0                                            **
** Date:        26.05.15                                       **
** Interpreter: Hollywood 6.0                                  **
** Licence:     Sample program                                 **
** Function:    Demonstrates how to use multiple displays with **
**              GL Galore                                      **
**                                                             **
** History:                                                    **
**                                                             **
** 1.0: (26.05.15)                                             **
**                                                             **
** - initial release                                           **
**                                                             **
****************************************************************/

/*
** Make sure we have at least Hollywood 6.0!
*/
@VERSION 6,0


/*
** This script requires the GL Galore plugin
*/
@REQUIRE "glgalore"


/*
** Define four displays
*/
@DISPLAY 1, {Width = 320, Height = 240, Hidden = True, Title = "Cube 1"}
@DISPLAY 2, {Width = 320, Height = 240, Hidden = True, HideFromTaskBar = True, Title = "Cube 2"}
@DISPLAY 3, {Width = 320, Height = 240, Hidden = True, HideFromTaskBar = True, Title = "Cube 3"}
@DISPLAY 4, {Width = 320, Height = 240, Hidden = True, HideFromTaskBar = True, Title = "Cube 4"}


/*
** Draw a GL cube
*/ 
Function p_DrawCube(d)
	
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)
  	gl.LoadIdentity()

	gl.Translate(0, 0, -10)
  	gl.Rotate(r[d], 0, 1, 0)
  	gl.Rotate(r[d], 1, 1, 1)
  
  	gl.Begin(#GL_QUADS)

	; top face
    	gl.Color(1, 0, 0)       
    	gl.Vertex( 1, 1, -1)
    	gl.Vertex(-1, 1, -1)
    	gl.Vertex(-1, 1,  1)
    	gl.Vertex( 1, 1,  1)
    
    	; bottom face
    	gl.Color(1, 1, 0)    
    	gl.Vertex( 1, -1,  1)
    	gl.Vertex(-1, -1,  1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex( 1, -1, -1)

	; front face
    	gl.Color(1, 0, 1)    
    	gl.Vertex( 1,  1, 1)
    	gl.Vertex(-1,  1, 1)
    	gl.Vertex(-1, -1, 1)
    	gl.Vertex( 1, -1, 1)
    
    	; back face
    	gl.Color(1, 0.5, 0)    
    	gl.Vertex( 1, -1, -1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex(-1,  1, -1)
    	gl.Vertex( 1,  1, -1)
    	
    	; left face
    	gl.Color(0, 0, 1)
    	gl.Vertex(-1,  1,  1)
    	gl.Vertex(-1,  1, -1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex(-1, -1,  1)
    
    	; right face
    	gl.Color(0, 1, 0)    
    	gl.Vertex(1,  1, -1)
    	gl.Vertex(1,  1,  1)
    	gl.Vertex(1, -1,  1)
    	gl.Vertex(1, -1, -1)
  	gl.End()

	r[d] = r[d] + 2

EndFunction
 
; the following code splits the current screen into four parts and
; centers each of our displays in one of the four parts
dw = GetAttribute(#DISPLAY, 0, #ATTRHOSTWIDTH)
dh = GetAttribute(#DISPLAY, 0, #ATTRHOSTHEIGHT)

SelectDisplay(1, True)
SetDisplayAttributes({X = ((dw \ 2) - 360) \ 2, Y = ((dh \ 2) - 256) \ 2})

SelectDisplay(2, True)
SetDisplayAttributes({X = dw \ 2 + ((dw \ 2) - 360) \ 2, Y = ((dh \ 2) - 256) \ 2})

SelectDisplay(3, True)
SetDisplayAttributes({X = ((dw \ 2) - 360) \ 2, Y = dh \ 2 + ((dh \ 2) - 256) \ 2})

SelectDisplay(4, True)
SetDisplayAttributes({X = dw \ 2 + ((dw \ 2) - 360) \ 2, Y = dh \ 2 + ((dh \ 2) - 256) \ 2})

r = {0, 0, 0, 0}

; now that we have positioned our displays, we can open them!
For Local k = 4 To 1 Step -1
	
	; open display
	OpenDisplay(k)
	
	; make display's GL context the active one
	gl.SetCurrentContext(k)
	 
	; initialize GL context	for each window
	gl.ClearColor(0, 0, 0, 0)
	gl.Enable(#GL_DEPTH_TEST)

	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	glu.Perspective(20, 320 / 240, 5, 15)	
	gl.Viewport(0, 0, 320, 240)

	gl.MatrixMode(#GL_MODELVIEW)
   	
   	; start hardware double-buffering for window
	BeginDoubleBuffer(True)
Next

EscapeQuit(True)

; main loop
Repeat
	
	; update cube on all 4 displays
	For Local k = 1 To 4
		
		; change GL context
		gl.SetCurrentContext(k)	
		SelectDisplay(k, True)
		
		; draw next cube frame
		p_DrawCube(k - 1)	
		
		; flip buffer into view -- note that we only wait for the vertical refresh once
		; (when swapping buffers on the last display!)	
		Flip(IIf(k = 4, True, False))
	Next	
	
	CheckEvent
Forever	
