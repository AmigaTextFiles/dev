/*****************************************************************************
 * Wave Simulation in OpenGL
 * (C) 2002 Jakob Thomsen
 * http://home.in.tum.de/~thomsen
 * Modified for GLFW by Sylvain Hellegouarch - sh@programmationworld.com
 * Modified for variable frame rate by Marcus Geelnard
 * 2003-Jan-31: Minor cleanups and speedups / MG
 * 2010-10-24: Formatting and cleanup - Camilla Berglund
 * Ported to Hollywood by Andreas Falkenhahn
 *****************************************************************************/

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Sizeable = True, Title = "Wave simulation"}

; Maximum delta T to allow for differential calculations
Const #MAX_DELTA_T = 0.01

; Animation speed (10.0 looks good)
Const #ANIMATION_SPEED = 10.0

Const #GRIDW = 50
Const #GRIDH = 50
Const #VERTEXNUM = (#GRIDW*#GRIDH)

Const #QUADW = (#GRIDW - 1)
Const #QUADH = (#GRIDH - 1)
Const #QUADNUM = (#QUADW*#QUADH)

/* The grid will look like this:
 *
 *      3   4   5
 *      *---*---*
 *      |   |   |
 *      | 0 | 1 |
 *      |   |   |
 *      *---*---*
 *      0   1   2
 */

/*========================================================================
** Initialize grid geometry
**======================================================================*/

Function p_InitVertices()

	vertex = {}

	; Place the vertices in a grid
	For Local y = 0 To #GRIDH - 1

		For Local x = 0 To #GRIDW - 1

			Local p = y * #GRIDW + x

			vertex[p] = {}
			vertex[p].x = (x - #GRIDW / 2) / (#GRIDW / 2)
			vertex[p].y = (y - #GRIDH / 2) / (#GRIDH / 2)
			vertex[p].z = 0

			If ((x % 4 < 2) ~ (y % 4 < 2))
				vertex[p].r = 0.0
			Else
				vertex[p].r = 1.0
			EndIf

			vertex[p].g = y / #GRIDH
			vertex[p].b = 1.0 - (x / #GRIDW + y / #GRIDH) / 2.0
		Next
	Next

	For Local y = 0 To #QUADH - 1
    
		For Local x = 0 To #QUADW - 1

			Local p = 4 * (y * #QUADW + x)

			quad[p + 0] = y       * #GRIDW + x      ; Some point
			quad[p + 1] = y       * #GRIDW + x + 1  ; Neighbor at the right side
			quad[p + 2] = (y + 1) * #GRIDW + x + 1  ; Upper right neighbor
			quad[p + 3] = (y + 1) * #GRIDW + x      ; Upper neighbor
		Next
	Next

EndFunction

;========================================================================
; Initialize grid
;========================================================================

Function p_InitGrid()

	For Local y = 0 To #GRIDH - 1

		p[y] = {}
		vx[y] = {}
		vy[y] = {}

		For Local x = 0 To #GRIDW - 1

			Local dx = (x - #GRIDW / 2)
			Local dy = (y - #GRIDH / 2)
			Local d = Sqrt(dx * dx + dy * dy)
	    
			If d < 0.1 * (#GRIDW / 2)
				d = d * 10.0
				p[y][x] = -Cos(d * (#PI / (#GRIDW * 4))) * 100.0
			Else
				p[y][x] = 0.0
			EndIf

			vx[y][x] = 0.0
			vy[y][x] = 0.0
		Next
	Next

EndFunction

;========================================================================
; Draw scene
;========================================================================

Function p_DrawScene()

	; Clear the color and depth buffers
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)

	; We don't want to modify the projection matrix
	gl.MatrixMode(#GL_MODELVIEW)
	gl.LoadIdentity()

	; Move back
	gl.Translate(0.0, 0.0, -zoom)
    
	; Rotate the view
	gl.Rotate(beta, 1.0, 0.0, 0.0)
	gl.Rotate(alpha, 0.0, 0.0, 1.0)

	gl.DrawElements(#GL_QUADS, quad)

EndFunction

Function p_UpdateVertexPointer()

	Local tmp = {}
	Local i = 0

	For Local k = 0 To #VERTEXNUM - 1
		tmp[i] = vertex[k].x
		tmp[i+1] = vertex[k].y
		tmp[i+2] = vertex[k].z
		i = i + 3
	Next

	gl.VertexPointer(tmp, 3)

	Local tmp = {}
	Local i = 0

	For Local k = 0 To #VERTEXNUM - 1
		tmp[i] = vertex[k].r
		tmp[i+1] = vertex[k].g
		tmp[i+2] = vertex[k].b
		i = i + 3
	Next

	gl.ColorPointer(tmp, 3) ; Pointer to the first color

EndFunction

;========================================================================
; Initialize Miscellaneous OpenGL state
;========================================================================

Function p_InitOpenGL()

	; Use Gouraud (smooth) shading
	gl.ShadeModel(#GL_SMOOTH)

	; Switch on the z-buffer
	gl.Enable(#GL_DEPTH_TEST)

	gl.EnableClientState(#GL_VERTEX_ARRAY)
	gl.EnableClientState(#GL_COLOR_ARRAY)
	
	p_UpdateVertexPointer()

	gl.PointSize(2.0)

	; Background color is black
	gl.ClearColor(0, 0, 0, 0)

EndFunction


;========================================================================
; Modify the height of each vertex according to the pressure
;========================================================================

Function p_AdjustGrid()

	For Local y = 0 To #GRIDH - 1

		For Local x = 0 To #GRIDW - 1
			Local pos = y * #GRIDW + x
			vertex[pos].z = (p[y][x] * (1.0 / 50.0))
		Next
	Next

EndFunction


;========================================================================
; Calculate wave propagation
;========================================================================

Function p_CalcGrid()

	Local time_step = dt * #ANIMATION_SPEED

	; Compute accelerations
	For Local x = 0 To #GRIDW - 1
		Local x2 = (x + 1) % #GRIDW
		For Local y = 0 To #GRIDH - 1 Do ax[y][x] = p[y][x] - p[y][x2]
	Next

	For Local y = 0 To #GRIDH - 1
		Local y2 = (y + 1) % #GRIDH
		For Local x = 0 To #GRIDW - 1 Do ay[y][x] = p[y][x] - p[y2][x]
	Next

	; Compute speeds
	For Local x = 0 To #GRIDW - 1
		For Local y = 0 To #GRIDH - 1
			vx[y][x] = vx[y][x] + ax[y][x] * time_step
			vy[y][x] = vy[y][x] + ay[y][x] * time_step
		Next
	Next

	; Compute pressure
	For Local x = 1 To #GRIDW - 1
		Local x2 = x - 1
		For Local y = 1 To #GRIDH - 1
			y2 = y - 1
			p[y][x] = p[y][x] + (vx[y][x2] - vx[y][x] + vy[y2][x] - vy[y][x]) * time_step
		Next
	Next

EndFunction

;========================================================================
; Handle key strokes
;========================================================================

Function p_KeyCallback(msg)

	Switch msg.key
	Case " ":
		p_InitGrid()
	Case "LEFT":
		alpha = alpha + 5
	Case "RIGHT":
		alpha = alpha - 5
	Case "UP":
		beta = beta - 5
	Case "DOWN":
		beta = beta + 5
	Case "PAGEUP":	
		zoom = zoom - 0.25
		If zoom < 0 Then zoom = 0
	Case "PAGEDOWN":
		zoom = zoom + 0.25
	EndSwitch

EndFunction

;========================================================================
; Callback function for cursor motion events
;========================================================================

Function p_CursorPositionCallback(msg)

	If IsLeftMouse()
    		alpha = alpha + (msg.x - cursorX) / 10
		beta = beta + (msg.y - cursorY) / 10
	EndIf

    	cursorX = msg.x
    	cursorY = msg.y

EndFunction

;========================================================================
; Callback function for framebuffer resize events
;========================================================================

Function p_Reshape(width, height)

	Local ratio = 1.0

	If height > 0 Then ratio = width / height

	; Setup viewport
	gl.Viewport(0, 0, width, height)

	; Change to the projection matrix and set our viewing volume
	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	glu.Perspective(60.0, ratio, 1.0, 1024.0)

EndFunction

EscapeQuit(True)

alpha = 210
beta = -70
zoom = 2.0

p = {}
vx = {}
vy = {}
ax = {}
ay = {}
quad = {}

For Local y = 0 To #GRIDH - 1
	ax[y] = {}
	ay[y] = {}
	For Local x = 0 To #GRIDW - 1
		ax[y][x] = 0
		ay[y][x] = 0
	Next
Next

; Initialize simulation
p_InitVertices()
p_InitGrid()
p_AdjustGrid()

; Initialize OpenGL
p_InitOpenGL()
p_Reshape(640, 480)

InstallEventHandler({OnKeyDown = p_KeyCallback,
	OnMouseMove = p_CursorPositionCallback,
	SizeWindow = Function(msg) p_Reshape(msg.width, msg.height) EndFunction,
	ModeSwitch = Function(msg) p_InitOpenGL() p_Reshape(msg.width, msg.height) EndFunction
	})

; Setup a hardware doublebuffer managed by GL Galore	
BeginDoubleBuffer(True)

StartTimer(1)

; Initialize timer
t_old = GetTimer(1) / 1000

Wait(10)

Repeat

	DisableLineHook()

	Local t = GetTimer(1) / 1000
	Local dt_total = t - t_old
	t_old = t

	; Select iteration time step
	dt = IIf(dt_total > #MAX_DELTA_T, #MAX_DELTA_T, dt_total)
	dt_total = dt_total - dt

	; Calculate wave propagation
	p_CalcGrid()

	; Compute height of each vertex
	p_AdjustGrid()
	p_UpdateVertexPointer()

	; Draw wave grid to OpenGL display
	p_DrawScene()

	EnableLineHook()

	; Swap buffers
	Flip

	CheckEvent

Forever

