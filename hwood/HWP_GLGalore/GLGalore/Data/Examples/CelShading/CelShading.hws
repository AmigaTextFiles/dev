/*
** The Cel-Shading code from NeHe's lesson 37: http://nehe.gamedev.net/data/lessons/lesson.asp?lesson=37
**
** This code was created by Jeff Molofee '99 (ported to Linux/GLUT by Kah-Wah Tang 2002 with help from the lesson 1 basecode for Linux by Richard Campbell)
** Finally, it was ported to Amiga OS (and converted from C++ to C) by Hans de Ruiter
** Ported to Hollywood by Andreas Falkenhahn
** 
** If you've found this code useful, please let me know.
**
** Visit me at www.xs4all.nl/~chtang
** (email Kah-Wah Tang at tombraider28@hotmail.com)
*/

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Sizeable = True, Title = "Cel shading"}

Function p_ReadMesh()

	OpenFile(1, "Model.txt")

	polyData = {}
	polyNum = ReadInt(1, True)

	For Local k = 0 To polyNum - 1

		polyData[k] = {Verts = {}}

		For Local i = 0 To 2

			polyData[k].Verts[i] = {}

			Local x = ReadFloat(1, 4, True)
			Local y = ReadFloat(1, 4, True)
			Local z = ReadFloat(1, 4, True)

			polyData[k].Verts[i].Nor = {x = x, y = y, z = z}

			Local x = ReadFloat(1, 4, True)
			Local y = ReadFloat(1, 4, True)
			Local z = ReadFloat(1, 4, True)

			polyData[k].Verts[i].Pos = {x = x, y = y, z = z}
		Next
	Next

	CloseFile(1)

EndFunction

Function p_DotProduct(V1, V2)				                                 ; Calculate The Angle Between The 2 Vectors ( NEW )

	Return(V1.X * V2.X + V1.Y * V2.Y + V1.Z * V2.Z)				         ; Return The Angle ( NEW )

EndFunction

Function p_Magnitude(V)								         ; Calculate The Length Of The Vector ( NEW )

	Return(Sqrt(V.X * V.X + V.Y * V.Y + V.Z * V.Z))                                  ; Return The Length Of The Vector ( NEW )

EndFunction

Function p_Normalize(V)									 ; Creates A Vector With A Unit Length Of 1 ( NEW )

	Local M = p_Magnitude(V)							 ; Calculate The Length Of The Vector  ( NEW )

	If M <> 0.0									 ; Make Sure We Don't Divide By 0  ( NEW )
		V.X = V.X / M								 ; Normalize The 3 Components  ( NEW )
		V.Y = V.Y / M
		V.Z = V.Z / M
	EndIf

EndFunction

Function p_RotateVector(M, V, D)			                                 ; Rotate A Vector Using The Supplied Matrix ( NEW )

	D.X = (M[0] * V.X) + (M[4] * V.Y) + (M[8]  * V.Z)	                         ; Rotate Around The X Axis ( NEW )
	D.Y = (M[1] * V.X) + (M[5] * V.Y) + (M[9]  * V.Z)	                         ; Rotate Around The Y Axis ( NEW )
	D.Z = (M[2] * V.X) + (M[6] * V.Y) + (M[10] * V.Z)	                         ; Rotate Around The Z Axis ( NEW )

EndFunction

/* A general OpenGL initialization function.  Sets all of the initial parameters. */
Function p_InitGL(width, height)                                                         ; We call this right after our OpenGL window is created.

	; Start Of User Initialization
	gl.Hint(#GL_PERSPECTIVE_CORRECTION_HINT, #GL_NICEST)		                 ; Really Nice perspective calculations

	gl.ClearColor(0.7, 0.7, 0.7, 0.0)						 ; Light Grey Background
	gl.ClearDepth(1.0)								 ; Depth Buffer Setup

	gl.Enable(#GL_DEPTH_TEST)							 ; Enable Depth Testing
	gl.DepthFunc(#GL_LESS)								 ; The Type Of Depth Test To Do

	gl.ShadeModel(#GL_SMOOTH)							 ; Enables Smooth Color Shading( NEW )
	gl.Disable(#GL_LINE_SMOOTH)							 ; Initially Disable Line Smoothing( NEW )

	gl.Enable(#GL_CULL_FACE)							 ; Enable OpenGL Face Culling( NEW )

	gl.Disable(#GL_LIGHTING)							 ; Disable OpenGL Lighting( NEW )

	OpenFile(1, "Shader.txt")

	Local shaderData = {}
	Local j = 0

	For Local i = 0 To 31
		Local v = Val(ReadLine(1))
		shaderData[j] = v
		shaderData[j+1] = v
		shaderData[j+2] = v
		j = j + 3
	Next

	CloseFile(1)

	shaderTexture = gl.GenTextures(1)					         ; Get A Free Texture ID( NEW )

	gl.BindTexture(#GL_TEXTURE_1D, shaderTexture[0])		                 ; Bind This Texture. From Now On It Will Be 1D( NEW )

	; For Crying Out Loud Don't Let OpenGL Use Bi/Trilinear Filtering!( NEW )
	gl.TexParameter(#GL_TEXTURE_1D, #GL_TEXTURE_MAG_FILTER, #GL_NEAREST)
	gl.TexParameter(#GL_TEXTURE_1D, #GL_TEXTURE_MIN_FILTER, #GL_NEAREST)

	gl.TexImage(0, #GL_RGB, #GL_RGB, #GL_FLOAT, shaderData)                          ; Upload

	lightAngle = {X = 0, Y = 0, Z = 1}

	p_Normalize(lightAngle)                                                          ; Normalize The Light Direction( NEW )
	p_ReadMesh()

	p_Reshape(width, height)
										
EndFunction

/* The function called when our window is resized (which shouldn't happen, because we're fullscreen) */
Function p_Reshape(width, height)

	gl.Viewport(0, 0, width, height)	                                         ; Reset The Current Viewport And Perspective Transformation

	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()

	glu.Perspective(45.0, width / height, 0.1, 100.0)
	gl.MatrixMode(#GL_MODELVIEW)

EndFunction

/* The main drawing function. */
Function p_DrawGLScene()

	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)	                         ; Clear The Buffers
	gl.LoadIdentity()								 ; Reset The Matrix

	If outlineSmooth								 ; Check To See If We Want Anti-Aliased Lines( NEW )
		gl.Hint(#GL_LINE_SMOOTH_HINT, #GL_NICEST)				 ; Use The Good Calculations( NEW )
		gl.Enable(#GL_LINE_SMOOTH)						 ; Enable Anti-Aliasing( NEW )
	Else										 ; We Don't Want Smooth Lines( NEW )
		gl.Disable(#GL_LINE_SMOOTH)						 ; Disable Anti-Aliasing( NEW )
	EndIf

	gl.Translate(0.0, 0.0, -2.0)							 ; Move 2 Units Away From The Screen( NEW )
	gl.Rotate(modelAngle, 0.0, 1.0, 0.0)					         ; Rotate The Model On It's Y-Axis( NEW )

	Local TmpMatrix = gl.GetArray(#GL_MODELVIEW_MATRIX)			         ; Get The Generated Matrix( NEW )

	; Cel-Shading Code ;
	gl.Enable(#GL_TEXTURE_1D)							 ; Enable 1D Texturing( NEW )
	gl.BindTexture(#GL_TEXTURE_1D, shaderTexture[0])			         ; Bind Our Texture( NEW )

	gl.Color(1.0, 1.0, 1.0)								 ; Set The Color Of The Model( NEW )

	gl.Begin(#GL_TRIANGLES)								 ; Tell OpenGL That We're Drawing Triangles

	Local TmpNormal = {}
	Local TmpVector = {}

	For Local i = 0 To polyNum - 1							 ; Loop Through Each Polygon( NEW )
		
		For Local j = 0 To 2							 ; Loop Through Each Vertex( NEW )

			Local tmp = polyData[i].Verts[j]

			TmpNormal.X = tmp.Nor.X		                                 ; Fill Up The TmpNormal Structure With
			TmpNormal.Y = tmp.Nor.Y		                                 ; The Current Vertices' Normal Values( NEW )
			TmpNormal.Z = tmp.Nor.Z

			p_RotateVector(TmpMatrix, TmpNormal, TmpVector)	                 ; Rotate This By The Matrix( NEW )

			p_Normalize(TmpVector)						 ; Normalize The New Normal( NEW )

			Local TmpShade = p_DotProduct(TmpVector, lightAngle)	         ; Calculate The Shade Value( NEW )
			If TmpShade < 0.0 Then TmpShade = 0.0				 ; Clamp The Value to 0 If Negative( NEW )

			gl.TexCoord(TmpShade)						 ; Set The Texture Co-ordinate As The Shade Value( NEW )
			gl.Vertex(tmp.Pos.X, tmp.Pos.Y, tmp.Pos.Z)	                 ; Send The Vertex Position( NEW )
		Next
	Next

	gl.End()									 ; Tell OpenGL To Finish Drawing

	gl.Disable(#GL_TEXTURE_1D)							 ; Disable 1D Textures( NEW )

	; Outline Code ;
	If outlineDraw									 ; Check To See If We Want To Draw The Outline( NEW )

		gl.Enable(#GL_BLEND)							 ; Enable Blending( NEW )
		gl.BlendFunc(#GL_SRC_ALPHA, #GL_ONE_MINUS_SRC_ALPHA)		         ; Set The Blend Mode( NEW )

		gl.PolygonMode(#GL_BACK, #GL_LINE)					 ; Draw Backfacing Polygons As Wireframes( NEW )
		gl.LineWidth(outlineWidth)						 ; Set The Line Width( NEW )

		gl.CullFace(#GL_FRONT)							 ; Don't Draw Any Front-Facing Polygons( NEW )
		gl.DepthFunc(#GL_LEQUAL)						 ; Change The Depth Mode( NEW )

		gl.Color(outlineColor)							 ; Set The Outline Color( NEW )

		gl.Begin(#GL_TRIANGLES)							 ; Tell OpenGL What We Want To Draw

		For Local i = 0 To polyNum - 1						 ; Loop Through Each Polygon( NEW )
			For Local j = 0 To 2						 ; Loop Through Each Vertex( NEW )
				Local tmp = polyData[i].Verts[j].Pos
				gl.Vertex(tmp.X, tmp.Y, tmp.Z)	                         ; Send The Vertex Position( NEW )
			Next
		Next

		gl.End()								 ; Tell OpenGL We've Finished

		gl.DepthFunc(#GL_LESS)							 ; Reset The Depth-Testing Mode( NEW )

		gl.CullFace(#GL_BACK)							 ; Reset The Face To Be Culled( NEW )

		gl.PolygonMode(#GL_BACK, #GL_FILL)					 ; Reset Back-Facing Polygon Drawing Mode( NEW )

		gl.Disable(#GL_BLEND)							 ; Disable Blending( NEW )
	EndIf

	If modelRotate = True Then modelAngle = modelAngle + 2				 ; Check To See If Rotation Is Enabled( NEW )

EndFunction

; User Defined Variables
outlineDraw	= True							                 ; Flag To Draw The Outline ( NEW )
outlineSmooth	= False							                 ; Flag To Anti-Alias The Lines ( NEW )
outlineColor   	= {0.0, 0.0, 0.0}                     			                 ; Color Of The Lines ( NEW )
outlineWidth	= 3.0			 				                 ; Width Of The Lines ( NEW )
lightRotate	= False							                 ; Flag To See If We Rotate The Light ( NEW )

modelAngle	= 0.0 							                 ; Y-Axis Angle Of The Model ( NEW )
modelRotate	= True        						                 ; Flag To Rotate The Model ( NEW )

InstallEventHandler({
	SizeWindow = Function(msg) p_Reshape(msg.width, msg.height) EndFunction,
	ModeSwitch = Function(msg) p_InitGL(msg.width, msg.height) EndFunction})

p_InitGL(640, 480)

; Setup a hardware doublebuffer managed by GL Galore	
BeginDoubleBuffer(True)

EscapeQuit(True)

Repeat
	DisableLineHook()

	p_DrawGLScene()

	EnableLineHook()

	; Swap buffers
	Flip
	CheckEvent
Forever

