/*-
 *  sproingies.c - Copyright 1996 by Ed Mackey, freely distributable.
 *
 * Ported to Hollywood by Andreas Falkenhahn
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * This file is provided AS IS with no warranties of any kind.  The author
 * shall have no liability with respect to the infringement of copyrights,
 * trade secrets or any patents by this file or any part thereof.  In no
 * event will the author be liable for any lost revenue or profits or
 * other special, indirect and consequential damages.
 *
 * Revision History:
 * See sproingiewrap.c
 */

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Title = "Sproingies", Sizeable = True}

Const #NUM_SPROINGIES = 8

Const #MAXSPROING = 100
Const #TARGET_COUNT = 40
Const #BOOM_FRAME = 50
Const #NO_FRAME = -10
Const #JUMP_LEFT = 0
Const #JUMP_RIGHT = 1

Const #FIRST_FRAME = 0
Const #LAST_FRAME = 5 

smart_sproingies = False

Function p_NewSproingielife()
	Return(40 + Rnd(200))
EndFunction
		
Function p_ResetSproingielife()	
	Return(-30 + Rnd(28))
EndFunction
	
Function p_BuildTopsSides()

	Local mat_color = {0.392157, 0.784314, 0.941176, 1.0}
	Local dl_num = gl.GenLists(2)

	; Surface: Tops
	gl.NewList(dl_num, #GL_COMPILE)
	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, mat_color)
	gl.EndList()

	; Surface: Sides
	gl.NewList(dl_num + 1, #GL_COMPILE)
	mat_color[0] = 0.156863
	mat_color[1] = 0.156863
	mat_color[2] = 0.392157
	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, mat_color)
	gl.EndList()

	Return(dl_num)

EndFunction

Function p_LayGround(sx, sy, sz, width, height, si)

	Local x, y, z
	
	gl.CallList(si.TopsSides)	; Render the tops
	gl.Normal(0.0, 1.0, 0.0)

	For Local h = 0 To height - 1
		x = sx + h
		y = sy - (h * 2)
		z = sz + h
		For Local w = 0 To width - 1
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x, y, z)
			gl.Vertex(x, y, z - 1)
			gl.Vertex(x + 1, y, z - 1)
			gl.Vertex(x + 1, y, z)
			gl.End()
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x + 1, y - 1, z)
			gl.Vertex(x + 1, y - 1, z - 1)
			gl.Vertex(x + 2, y - 1, z - 1)
			gl.Vertex(x + 2, y - 1, z)
			gl.End()
			x = x + 1
			z = z - 1
		Next
	Next
	
	gl.CallList(si.TopsSides + 1)	; Render the sides
	gl.Normal(0.0, 0.0, 1.0)

	For Local h = 0 To height - 1
		x = sx + h
		y = sy - (h * 2)
		z = sz + h
		For Local w = 0 To width - 1
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x, y, z)
			gl.Vertex(x + 1, y, z)
			gl.Vertex(x + 1, y - 1, z)
			gl.Vertex(x, y - 1, z)
			gl.End()
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x + 1, y - 1, z)
			gl.Vertex(x + 2, y - 1, z)
			gl.Vertex(x + 2, y - 2, z)
			gl.Vertex(x + 1, y - 2, z)
			gl.End()
			x = x + 1
			z = z - 1
		Next
	Next

	; Render the other sides
	gl.Normal(1.0, 0.0, 0.0)

	For Local h = 0 To height - 1
		x = sx + h
		y = sy - (h * 2)
		z = sz + h
		For Local w = 0 To width - 1
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x + 1, y, z)
			gl.Vertex(x + 1, y, z - 1)
			gl.Vertex(x + 1, y - 1, z - 1)
			gl.Vertex(x + 1, y - 1, z)
			gl.End()
			gl.Begin(#GL_POLYGON)
			gl.Vertex(x + 2, y - 1, z)
			gl.Vertex(x + 2, y - 1, z - 1)
			gl.Vertex(x + 2, y - 2, z - 1)
			gl.Vertex(x + 2, y - 2, z)
			gl.End()
			x = x + 1
			z = z - 1
		Next
	Next

EndFunction

Function p_AdvanceSproingie(t, si)

	Local g_higher, g_back
	Local thisSproingie = si.positions[t]

	If thisSproingie.life > 0

		thisSproingie.frame = thisSproingie.frame + 1
		
		If thisSproingie.frame > #LAST_FRAME
			
			If thisSproingie.frame >= #BOOM_FRAME
				
				thisSproingie.r = thisSproingie.r - 0.08
				thisSproingie.g = thisSproingie.g - 0.08
				thisSproingie.b = thisSproingie.b - 0.08
				thisSproingie.life = thisSproingie.life - 1
											
				If thisSproingie.r < 0.0 Then thisSproingie.r = 0.0
				If thisSproingie.g < 0.0 Then thisSproingie.g = 0.0
				If thisSproingie.b < 0.0 Then thisSproingie.b = 0.0
				If thisSproingie.life < 1 Then thisSproingie.life = p_ResetSproingielife()
				Return
			EndIf
			
			thisSproingie.frame = #FIRST_FRAME

			Local S2 = si.positions

			; Check for collisions
			For Local t2 = 0 To si.maxsproingies - 1
				
				If (t2 <> t) And (thisSproingie.x = S2[t2].x) And (thisSproingie.y = S2[t2].y) And (thisSproingie.z = S2[t2].z) And (S2[t2].life > 10) And (S2[t2].frame < #LAST_FRAME + 1)
					
					If thisSproingie.life > 10
						thisSproingie.life = 10
						thisSproingie.frame = #BOOM_FRAME
						thisSproingie.r = thisSproingie.r + 0.5
						thisSproingie.g = thisSproingie.g + 0.5
						thisSproingie.b = thisSproingie.b + 0.5						
						
						If thisSproingie.r > 1.0 Then thisSproingie.r = 1.0
						If thisSproingie.g > 1.0 Then thisSproingie.g = 1.0
						If thisSproingie.b > 1.0 Then thisSproingie.b = 1.0
					EndIf
				EndIf	
			Next
		EndIf
		
		; Time to disappear... 
		If Not ((thisSproingie.life = 10) And (thisSproingie.frame > #FIRST_FRAME) And (thisSproingie.frame < #BOOM_FRAME))
			thisSproingie.life = thisSproingie.life - 1
			If thisSproingie.life < 1
				thisSproingie.life = p_ResetSproingielife()
			ElseIf thisSproingie.life < 9
				thisSproingie.frame = thisSproingie.frame - 2
			EndIf
		EndIf ; ... Else wait here for frame FIRST_FRAME to come about. 
		
	Else
		
		thisSproingie.life = thisSproingie.life + 1
		
		If thisSproingie.life >= 0

			If 1 Or t > 1
				g_higher = -3 + Rnd(5)
				g_back = -2 + Rnd(5)
			ElseIf t = 1
				g_higher = -2 + Rnd(3)
				g_back = -1 + Rnd(3)
			Else 
				g_higher = -1
				g_back = 0
			EndIf

			thisSproingie.x     = (-g_higher - g_back)
			thisSproingie.y     = g_higher * 2
			thisSproingie.z     = (g_back - g_higher)
			thisSproingie.life  = p_NewSproingielife()
			thisSproingie.frame = #NO_FRAME
			thisSproingie.r     = (40 + Rnd(200)) / 255.0
			thisSproingie.g     = (40 + Rnd(200)) / 255.0
			thisSproingie.b     = (40 + Rnd(200)) / 255.0

			Local S2 = si.positions

			For Local t2 = 0 To si.maxsproingies - 1
			
				If (t2 <> t) And (thisSproingie.x = S2[t2].x) And (thisSproingie.y = S2[t2].y) And (thisSproingie.z = S2[t2].z) And (S2[t2].life > 10) And (S2[t2].frame < #FIRST_FRAME)
					; If another is already on this place, wait.
					thisSproingie.life = -1
				EndIf
			Next	
		EndIf
	EndIf

EndFunction

Function p_NextSproingie()

	Local si = si_list[0]
	Local ddx

	; Although the sproingies cycle has six frames, the blocks cycle  
	; has twelve. After a full cycle (12 frames), re-center positions 
	; of sproingies

	si.sframe = si.sframe + 1
	If si.sframe > 11
		
		Local thisSproingie = si.positions
			
		si.sframe = #FIRST_FRAME
		
		For Local t = 0 To si.maxsproingies - 1
			thisSproingie[t].x = thisSproingie[t].x - 1
			thisSproingie[t].y = thisSproingie[t].y + 2
			thisSproingie[t].z = thisSproingie[t].z - 1
		Next
	EndIf

	For Local t = 0 To si.maxsproingies - 1 Do p_AdvanceSproingie(t, si)
	
	If si.target_count < 0			; track to current target 

		If si.target_rx < si.rotx
			si.rotx = si.rotx - 1
		ElseIf si.target_rx > si.rotx
			si.rotx = si.rotx + 1
		EndIf	

		If si.target_ry < si.roty
			si.roty = si.roty - 1
		ElseIf si.target_ry > si.roty
			si.roty = si.roty + 1
		EndIf	

		ddx = (si.target_dist - si.dist) \ 8
		If ddx
			si.dist = si.dist + ddx
		ElseIf si.target_dist < si.dist
			si.dist = si.dist - 1
		ElseIf si.target_dist > si.dist
			si.dist = si.dist + 1
		EndIf
		
		If (si.target_rx = si.rotx) And (si.target_ry = si.roty) And (si.target_dist = si.dist)
			si.target_count = #TARGET_COUNT
			If si.target_dist <= 32 Then si.target_count = si.target_count \ 4
		EndIf
		
	Else
		
		si.target_count = si.target_count - 1
		
		If si.target_count < 0			; make up new target 
			si.target_rx = Rnd(100) - 35
			si.target_ry = -Rnd(90)
			si.target_dist = 32 << Rnd(2)	; could be 32, 64, or 128, (previously or 256) 

			If si.target_dist >= si.dist Then si.target_dist = si.target_dist * 2	; no duplicate distances
		EndIf
	EndIf
	
	; Otherwise just hang loose for a while here

EndFunction

Function p_RenderList(list)
	
	gl.InterleavedArrays(list.format, 0, list.obj)
	gl.DrawArrays(list.primitive, 0, list.points)
	
EndFunction

Function p_RenderSproingie(t, si)

	Local scale, pointsize
	Local mat_color = {0.0, 0.0, 0.0, 1.0}
	Local clipplane = {0.0, 1.0, 0.0, 0.0}
	Local thisSproingie = si.positions[t]

	If thisSproingie.life < 1 Then Return

	gl.PushMatrix()

	mat_color[0] = thisSproingie.r
	mat_color[1] = thisSproingie.g
	mat_color[2] = thisSproingie.b
	gl.Material(#GL_FRONT, #GL_AMBIENT_AND_DIFFUSE, mat_color)

	If thisSproingie.frame < #FIRST_FRAME
		
		gl.Enable(#GL_CLIP_PLANE0)
		gl.Translate(thisSproingie.x, thisSproingie.y + (thisSproingie.frame / 9.0), thisSproingie.z)
		clipplane[3] = (thisSproingie.frame / 9.0) + 0.1
		gl.ClipPlane(#GL_CLIP_PLANE0, clipplane)

		p_RenderList(si.sproingies[0])
		gl.Disable(#GL_CLIP_PLANE0)
		
	ElseIf thisSproingie.frame >= #BOOM_FRAME
		
		gl.Translate(thisSproingie.x + 0.5, thisSproingie.y + 0.5, thisSproingie.z - 0.5)
		scale = 1 << (thisSproingie.frame - #BOOM_FRAME)
		gl.Scale(scale, scale, scale)
		gl.Color(mat_color)
		gl.Disable(#GL_LIGHTING)

		pointsize = ((#BOOM_FRAME + 8) - thisSproingie.frame) - (si.dist / 64.0)
		gl.PointSize(IIf(pointsize < 1.0, 1.0, pointsize))
		p_RenderList(si.SproingieBoom)
		gl.PointSize(1.0)
		gl.Enable(#GL_LIGHTING)
		
	Else
		If thisSproingie.direction = #JUMP_LEFT
			
			; When the sproingie jumps to the left, the frames must be
			; rotated and translated
			gl.Translate(thisSproingie.x, thisSproingie.y, thisSproingie.z - 1)
			gl.Rotate(-90.0, 0.0, 1.0, 0.0)
			If thisSproingie.frame = #LAST_FRAME
				thisSproingie.x = thisSproingie.x - 0
				thisSproingie.y = thisSproingie.y - 1
				thisSproingie.z = thisSproingie.z + 1
			EndIf
		Else			
			gl.Translate(thisSproingie.x, thisSproingie.y, thisSproingie.z)
			gl.Rotate(-0.0, 0.0, 1.0, 0.0)
			If thisSproingie.frame = #LAST_FRAME
				thisSproingie.x = thisSproingie.x + 1
				thisSproingie.y = thisSproingie.y - 1
				thisSproingie.z = thisSproingie.z - 0
			EndIf
		EndIf

		p_RenderList(si.sproingies[thisSproingie.frame])

		; Every 6 frame cycle...
		If thisSproingie.frame = #LAST_FRAME
			
			; ...check if the sproingies have gone out of the bricks
			If ((thisSproingie.x - thisSproingie.z = 6) And (2*thisSproingie.x + thisSproingie.y = 6)) Or ((thisSproingie.z - thisSproingie.x = 5) And (2*thisSproingie.x + thisSproingie.y = -5))

				; If they have, then they die
				If (thisSproingie.life > 0) And (thisSproingie.frame < #BOOM_FRAME) And (thisSproingie.frame > #FIRST_FRAME) Then thisSproingie.frame = #BOOM_FRAME
				
			Else
				; If not, they choose a direction for the next hop
				If smart_sproingies
					
					If (thisSproingie.x - thisSproingie.z = 5) And (2*thisSproingie.x + thisSproingie.y = 5)
						thisSproingie.direction = #JUMP_LEFT
					ElseIf (thisSproingie.z - thisSproingie.x = 4) And (2*thisSproingie.x + thisSproingie.y = -4)
						thisSproingie.direction = #JUMP_RIGHT
					Else
						thisSproingie.direction = Rnd(2)
					EndIf
				Else
					thisSproingie.direction = Rnd(2)
				EndIf
			EndIf			
		EndIf
	EndIf

	gl.PopMatrix()

EndFunction

Function p_ComputeGround(si)

	Local g_higher, g_back, g_width, g_height

	; higher: x-1, y+2, z-1
	; back: x-1, y, z+1
	g_back = 2
	g_width = 5

	g_higher = si.dist \ 8
	
	If g_higher < 4 Then g_higher = 4
	If g_higher > 16 Then g_higher = 16
	g_height = g_higher * 2

	If si.rotx < -10
		g_higher = g_higher + (g_higher \ 4)
	ElseIf si.rotx > 10
		g_higher = g_higher - (g_higher \ 4)
	EndIf

	; startx, starty, startz, width, height
	p_LayGround(-g_higher - g_back, g_higher * 2, g_back - g_higher, g_width, g_height, si)

EndFunction

Function p_DisplaySproingies()

	Local si = si_list[0]
	Local position = {8.0, 5.0, -2.0, 0.1}

	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)
	
	gl.PushMatrix()
	gl.Translate(0.0, 0.0, -si.dist / 16.0)	; viewing transform 
	gl.Rotate(si.rotx, 1.0, 0.0, 0.0)
	gl.Rotate(si.roty, 0.0, 1.0, 0.0)
	gl.Light(#GL_LIGHT0, #GL_POSITION, position)
	gl.Translate(si.sframe * (-1.0 / 12.0) - 0.75, si.sframe * (2.0 / 12.0) - 0.5, si.sframe * (-1.0 / 12.0) + 0.75)

	For Local t = 0 To si.maxsproingies - 1 Do p_RenderSproingie(t, si)

	p_ComputeGround(si)

	gl.PopMatrix()
	gl.Flush()

EndFunction

Function p_NextSproingieDisplay()

	p_NextSproingie()
	p_DisplaySproingies()

EndFunction

Function p_PrepareStateMachine(w, h, full)

	If full = True
		
		Local si = si_list[0]
			
		si.TopsSides = p_BuildTopsSides()
		
		Local ambient = {0.2, 0.2, 0.2, 1.0}
		Local position = {10.0, 1.0, 1.0, 10.0}
		Local mat_diffuse = {0.6, 0.6, 0.6, 1.0}
		Local mat_specular = {0.8, 0.8, 0.8, 1.0}
		Local mat_shininess = {50.0}
					
		gl.Enable(#GL_LIGHTING)
		gl.Enable(#GL_LIGHT0)
		gl.DepthFunc(#GL_LEQUAL)
		gl.Enable(#GL_DEPTH_TEST)

		gl.Light(#GL_LIGHT0, #GL_AMBIENT, ambient)
		gl.Light(#GL_LIGHT0, #GL_POSITION, position)

		gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mat_diffuse)
		gl.Material(#GL_FRONT_AND_BACK, #GL_SPECULAR, mat_specular)
		gl.Material(#GL_FRONT_AND_BACK, #GL_SHININESS, mat_shininess)
	
		gl.CullFace(#GL_BACK)
		gl.Enable(#GL_CULL_FACE)

		gl.FrontFace(#GL_CW)		
	EndIf		
		
	gl.Viewport(0, 0, w, h)
	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	glu.Perspective(65.0, w / h, 0.1, 2000.0)	; was 200000.0
	gl.MatrixMode(#GL_MODELVIEW)
	gl.LoadIdentity()

EndFunction
		
Function p_ReshapeSproingies(msg)

	p_PrepareStateMachine(msg.width, msg.height, (msg.action = "ModeSwitch"))

EndFunction

Function p_ReadSproingie(id)
	
	Local n = ReadInt(id)
	Local buf = AllocMem(Nil, n * 4)
	
	For Local k = 0 To n - 1 Do Poke(buf, k * 4, ReadFloat(id, 4), #FLOAT, True)

	Return(GetMemPointer(buf))

EndFunction		
	
Function p_InitSproingies(mspr, smrtspr)

	Local s1_1 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_2 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_3 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_4 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_5 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_6 = {format = #GL_N3F_V3F, primitive = #GL_TRIANGLES, points = 1728}
	Local s1_b = {format = #GL_V3F, primitive = #GL_POINTS, points = 500}

	If mspr < 0 Then mspr = 0
	If mspr >= #MAXSPROING Then mspr = #MAXSPROING - 1

	smart_sproingies = smrtspr 

	Local si = {rotx = 0, roty = -45, dist = (16 * 4), sframe = 0, target_count = 0, target_rx = 0, target_ry = 0, target_dist = 0}
	
	si.maxsproingies = mspr
	si.positions = {}
	
	For Local t = 0 To si.maxsproingies - 1
		si.positions[t] = {}
		si.positions[t].x = 0
		si.positions[t].y = 0
		si.positions[t].z = 0
		si.positions[t].life = (-t * IIf(si.maxsproingies > 19, 1, 4)) - 2
		si.positions[t].frame = #FIRST_FRAME
		si.positions[t].direction = Rnd(2)
	Next

	OpenFile(1, "sproingies.dat")
	s1_1.obj = p_ReadSproingie(1)
	s1_2.obj = p_ReadSproingie(1)
	s1_3.obj = p_ReadSproingie(1)
	s1_4.obj = p_ReadSproingie(1)
	s1_5.obj = p_ReadSproingie(1)
	s1_6.obj = p_ReadSproingie(1)
	s1_b.obj = p_ReadSproingie(1)				
	CloseFile(1)
						
	si.sproingies = {}
	si.sproingies[0] = s1_1
	si.sproingies[1] = s1_2
	si.sproingies[2] = s1_3
	si.sproingies[3] = s1_4
	si.sproingies[4] = s1_5
	si.sproingies[5] = s1_6
	si.SproingieBoom = s1_b

	si_list = {si}

EndFunction

Function p_DrawSproingies()
	
	DisableLineHook()

	gl.PushMatrix()
    	gl.Rotate(0, 0, 0, 1)
	p_NextSproingieDisplay()   ; It will swap.
    	gl.PopMatrix()
	gl.Finish()

	EnableLineHook()

EndFunction

p_InitSproingies(#NUM_SPROINGIES, True)
p_ReshapeSproingies({Action = "ModeSwitch", Width = GetAttribute(#DISPLAY, 0, #ATTRWIDTH), Height = GetAttribute(#DISPLAY, 0, #ATTRHEIGHT)})
p_DisplaySproingies(0, 0)

; Setup a hardware doublebuffer managed by GL Galore	
BeginDoubleBuffer(True)

EscapeQuit(True)

InstallEventHandler({SizeWindow = p_ReshapeSproingies, ModeSwitch = p_ReshapeSproingies})

SetInterval(1, Function() p_DrawSproingies Flip EndFunction, 1000\25)

Repeat
	WaitEvent
Forever

