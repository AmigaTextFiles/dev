/****************************************************************
**                                                             **
** Name:        MultiDisplays                                  **
** Author:      Andreas Falkenhahn                             **
** Version:     1.0                                            **
** Date:        26.05.15                                       **
** Interpreter: Hollywood 6.0                                  **
** Licence:     Sample program                                 **
** Function:    Demonstrates how to use multiple displays with **
**              GL Galore                                      **
**                                                             **
** History:                                                    **
**                                                             **
** 1.0: (26.05.15)                                             **
**                                                             **
** - initial release                                           **
**                                                             **
****************************************************************/

/*
** Make sure we have at least Hollywood 6.0!
*/
@VERSION 6,0


/*
** This script requires the GL Galore plugin
*/
@REQUIRE "glgalore"


/*
** Define four displays
*/
@DISPLAY {Sizeable = True, Title = "Cube"}


/*
** Draw a GL cube
*/ 
Function p_DrawCube()
	
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)
  	gl.LoadIdentity()

	gl.Translate(0, 0, -10)
  	gl.Rotate(r, 0, 1, 0)
  	gl.Rotate(r, 1, 1, 1)
  
  	gl.Begin(#GL_QUADS)

	; top face
    	gl.Color(1, 0, 0)       
    	gl.Vertex( 1, 1, -1)
    	gl.Vertex(-1, 1, -1)
    	gl.Vertex(-1, 1,  1)
    	gl.Vertex( 1, 1,  1)
    
    	; bottom face
    	gl.Color(1, 1, 0)    
    	gl.Vertex( 1, -1,  1)
    	gl.Vertex(-1, -1,  1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex( 1, -1, -1)

	; front face
    	gl.Color(1, 0, 1)    
    	gl.Vertex( 1,  1, 1)
    	gl.Vertex(-1,  1, 1)
    	gl.Vertex(-1, -1, 1)
    	gl.Vertex( 1, -1, 1)
    
    	; back face
    	gl.Color(1, 0.5, 0)    
    	gl.Vertex( 1, -1, -1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex(-1,  1, -1)
    	gl.Vertex( 1,  1, -1)
    	
    	; left face
    	gl.Color(0, 0, 1)
    	gl.Vertex(-1,  1,  1)
    	gl.Vertex(-1,  1, -1)
    	gl.Vertex(-1, -1, -1)
    	gl.Vertex(-1, -1,  1)
    
    	; right face
    	gl.Color(0, 1, 0)    
    	gl.Vertex(1,  1, -1)
    	gl.Vertex(1,  1,  1)
    	gl.Vertex(1, -1,  1)
    	gl.Vertex(1, -1, -1)
  	gl.End()

	r = r + 2

EndFunction

/* new window size */ 
Function p_Reshape(msg)

	; initialize GL context	
	gl.ClearColor(0, 0, 0, 0)
	gl.Enable(#GL_DEPTH_TEST)

	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	glu.Perspective(20, msg.width / msg.height, 5, 15)	
	gl.Viewport(0, 0, msg.width, msg.height)

	gl.MatrixMode(#GL_MODELVIEW)
   		
EndFunction
	 
p_Reshape({Width = 640, Height = 480})

InstallEventHandler({
	SizeWindow = Function(msg) p_Reshape(msg) EndFunction,
	ModeSwitch = Function(msg) p_Reshape(msg) EndFunction})
	 
; start hardware double-buffering for window
BeginDoubleBuffer(True)

EscapeQuit(True)

; main loop
Repeat
	
	; draw next cube frame
	p_DrawCube()	
		
	; flip buffer into view
	Flip

	CheckEvent
Forever	
