/* glmatrix, Copyright (c) 2003, 2004 Jamie Zawinski <jwz@jwz.org>
 *
 * Ported to Hollywood by Andreas Falkenhahn 
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation.  No representations are made about the suitability of this
 * software for any purpose.  It is provided "as is" without express or 
 * implied warranty.
 *
 * GLMatrix -- simulate the text scrolls from the movie "The Matrix".
 *
 * This program does a 3D rendering of the dropping characters that
 * appeared in the title sequences of the movies.  See also `xmatrix'
 * for a simulation of what the computer monitors actually *in* the
 * movie did.
 */

@VERSION 6,0

@REQUIRE "glgalore"

@BRUSH 1, "matrix.png"

@DISPLAY {Width = 640, Height = 480, Sizeable = True, Title = "GLMatrix"}

Const #MODE_MATRIX = 0
Const #MODE_DECIMAL = 1
Const #MODE_HEX = 2
Const #MODE_BINARY = 3
Const #MODE_DNA = 4

Const #DEF_SPEED = 1.0
Const #DEF_DENSITY = 20
Const #DEF_FOG = True
Const #DEF_WAVES = True
Const #DEF_ROTATE = True
Const #DEF_TEXTURE = True
Const #DEF_MODE = #MODE_MATRIX

Const #CHAR_COLS = 16
Const #CHAR_ROWS = 13

Const #GRID_SIZE = 70      /* width and height of the arena */
Const #GRID_DEPTH = 35     /* depth of the arena */
Const #WAVE_SIZE = 22      /* periodicity of color (brightness) waves */
Const #SPLASH_RATIO = 0.7  /* ratio of #GRID_DEPTH where chars hit the screen */

Function p_FRnd(m)
	Return(RndF() * m)
EndFunction	

Function p_BellRand(n)
	Return((p_FRnd(n) + p_FRnd(n) + p_FRnd(n)) / 3)
EndFunction

Function p_Random()
	Return(RndF() * 65536)
EndFunction
	
/*
** Re-randomize the state of one strip.
*/
Function p_ResetStrip(mp, s)

	Local time_displayed_p = False  /* never display time twice in one strip */

	s.x = p_FRnd(#GRID_SIZE) - #GRID_SIZE/2
	s.y = #GRID_SIZE/2 + p_BellRand(0.5)
	s.z = #GRID_DEPTH * 0.2 - p_FRnd(#GRID_DEPTH * 0.7)
  	
	s.dx = 0
  	s.dy = 0
  	s.dz = (p_BellRand(0.02) * speed)

	s.spinner_speed = p_BellRand(0.3) * speed
  	s.spin_speed = Int(p_BellRand(2.0 / speed) + 1)
 	s.spin_tick  = 0
  	s.spinner_y = 0
	s.spinner_glyph = 0
	
  	s.wave_position = 0
  	s.wave_speed = Int(p_BellRand(3.0 / speed) + 1)
  	s.wave_tick  = 0

	s.erasing_p = False
	s.glyphs = {}
	s.highlight = {}
	
	For Local i = 0 To #GRID_SIZE - 1
		s.glyphs[i] = 0
		s.highlight[i] = 0
	Next
		
  	For Local i = 0 To #GRID_SIZE - 1
  		
		Local draw_p = p_Random() % 7
		Local spin_p = (draw_p And (Not (p_Random() % 20)))
		Local g = 0
		
		If draw_p Then g = mp.glyph_map[(p_Random() % mp.nglyphs)] + 1
		If spin_p Then g = -g
	
		s.glyphs[i] = g
		s.highlight[i] = False
      	Next

	s.spinner_glyph = -(mp.glyph_map[(p_Random() % mp.nglyphs)] + 1)

EndFunction


/*
** Animate the strip one step.  Reset if it has reached the bottom.
*/
Function p_TickStrip(mp, s)
	
	s.x = s.x + s.dx
  	s.y = s.y + s.dy
  	s.z = s.z + s.dz

  	If s.z > #GRID_DEPTH * #SPLASH_RATIO  ; splashed into screen
		p_ResetStrip(mp, s)
		Return
    	EndIf

	s.spinner_y = s.spinner_y + s.spinner_speed
  	If s.spinner_y >= #GRID_SIZE

      		If s.erasing_p
          		p_ResetStrip(mp, s)
			Return
        	EndIf

		s.erasing_p = True
       		s.spinner_y = 0
       		s.spinner_speed = s.spinner_speed / 2  ; erase it slower than we drew it 
        EndIf

	; Spin the spinners.
  	s.spin_tick = s.spin_tick + 1
  	If s.spin_tick > s.spin_speed
      		s.spin_tick = 0
      		s.spinner_glyph = -(mp.glyph_map[(p_Random() % mp.nglyphs)] + 1)
      
      		For Local i = 0 To #GRID_SIZE - 1
        		If s.glyphs[i] < 0
          			s.glyphs[i] = -(mp.glyph_map[(p_Random() % mp.nglyphs)] + 1)
            			
				; sometimes they stop spinning             			
            			If Not (p_Random() % 800) Then s.glyphs[i] = -s.glyphs[i]
          		EndIf
          	Next
	EndIf

	; Move the color (brightness) wave.
 	s.wave_tick = s.wave_tick + 1
  	If s.wave_tick > s.wave_speed
		s.wave_tick = 0
      		s.wave_position = s.wave_position + 1
		If s.wave_position >= #WAVE_SIZE Then s.wave_position = 0
    	EndIf
   
EndFunction 


/*
** Draw a single character at the given position and brightness.
*/
Function p_DrawGlyph(mp, glyph, highlight, x, y, z, brightness)

	Local w = mp.tex_char_width
	Local h = mp.tex_char_height
	Local cx, cy = 0, 0
	Local S = 1
 	Local spinner_p = (glyph < 0)
	Local r, g, b, a
	
	If glyph = 0 Then End
	if glyph < 0 Then glyph = -glyph

	If spinner_p Then brightness = brightness * 1.5

	If Not do_texture
		S = 0.8
      		x = x + 0.1
      		y = y + 0.1
    	Else

      		Local ccx = ((glyph - 1) % #CHAR_COLS)
      		Local ccy = ((glyph - 1) \ #CHAR_COLS)

      		cx = ccx * w
      		cy = (mp.real_char_rows - ccy - 1) * h

      		If do_fog
          		Local depth = (z / #GRID_DEPTH) + 0.5  ; z ratio from back/front  
          		depth = 0.2 + (depth * 0.8)            ; scale to range [0.2 - 1.0]  
          		brightness = brightness * depth        ; so no row goes all black. 
        	EndIf
    	EndIf

	If highlight Then brightness = brightness * 2

    	If (Not do_texture) And (Not spinner_p)
    		g = 1
    	Else
    		r = 1
    		g = 1
    		b = 1
    	EndIf

	a = brightness

    	; If the glyph is very close to the screen (meaning it is very large,
        ; and is about to splash into the screen and vanish) then start fading
        ; it out, proportional to how close to the glass it is.
	If z > #GRID_DEPTH / 2
        
        	Local ratio = ((z - #GRID_DEPTH/2) / ((#GRID_DEPTH * #SPLASH_RATIO) - #GRID_DEPTH/2))
        	Local i = Int(ratio * #WAVE_SIZE)

        	If i < 0 Then i = 0 ElseIf i >= #WAVE_SIZE i = #WAVE_SIZE-1 

        	a = a * mp.brightness_ramp[i]
      	EndIf

    	gl.Color(r, g, b, a)

  	gl.Begin(#GL_QUADS)
  	gl.Normal(0, 0, 1)
  	gl.TexCoord(cx, cy)
  	gl.Vertex(x, y, z)
  	gl.TexCoord(cx+w, cy)
  	gl.Vertex(x+S, y, z)
  	gl.TexCoord(cx+w, cy+h)
  	gl.Vertex(x+S, y+S, z)
  	gl.TexCoord(cx, cy+h)
  	gl.Vertex(x, y+S, z)
  	gl.End()

EndFunction


/*
** Draw all the visible glyphs in the strip.
*/
Function p_DrawStrip(mp, s)

	For Local i = 0 To #GRID_SIZE - 1

		Local g = s.glyphs[i]
      		Local below_p = (s.spinner_y >= i)

      		If s.erasing_p Then below_p = Not below_p

      		If g And below_p       ; don't draw cells below the spinner 

			Local brightness
			
          		If Not do_waves
 		        	brightness = 1.0
          		Else
				Local j = #WAVE_SIZE - ((i + (#GRID_SIZE - s.wave_position)) % #WAVE_SIZE)
				If j = #WAVE_SIZE Then j = #WAVE_SIZE - 1
				brightness = mp.brightness_ramp[j]
            		EndIf

			p_DrawGlyph(mp, g, s.highlight[i], s.x, s.y - i, s.z, brightness)
        	EndIf
      	Next

	If Not s.erasing_p Then p_DrawGlyph(mp, s.spinner_glyph, False, s.x, s.y - s.spinner_y, s.z, 1.0)

EndFunction


/*
** Auto-tracking
*/
Function p_AutoTrackInit(mp)

	mp.last_view = 0
  	mp.target_view = 0
  	mp.view_x = nice_views[mp.last_view].x
  	mp.view_y = nice_views[mp.last_view].y
  	mp.view_steps = 100
  	mp.view_tick = 0
  	mp.auto_tracking_p = False

EndFunction

Function p_AutoTrack(mp)
	
	If Not do_rotate Then Return

	; if we're not moving, maybe start moving.  Otherwise, do nothing.
  	If Not mp.auto_tracking_p
    
    		mp.track_tick = mp.track_tick + 1
   		If mp.track_tick < 20 \ speed Then Return
      		mp.track_tick = 0
      
      		If p_Random() % 20 Then Return
      			
       		mp.auto_tracking_p = True
    	EndIf

	Local ox = nice_views[mp.last_view].x
	Local oy = nice_views[mp.last_view].y
	Local tx = nice_views[mp.target_view].x
	Local ty = nice_views[mp.target_view].y

    	; move from A to B with sinusoidal deltas, so that it doesn't jerk
       	; to a stop.
    	Local th = Sin((#PI / 2) * mp.view_tick / mp.view_steps)

    	mp.view_x = (ox + ((tx - ox) * th))
    	mp.view_y = (oy + ((ty - oy) * th))
    	mp.view_tick = mp.view_tick + 1

  	If mp.view_tick >= mp.view_steps
		mp.view_tick = 0
     		mp.view_steps = (350.0 / speed)
      		mp.last_view = mp.target_view
      		mp.target_view = (p_Random() % (ListItems(nice_views) - 1)) + 1
      		mp.auto_tracking_p = False
    	EndIf

EndFunction

/*
** Window management, etc
*/
Function p_Reshape(msg)

	Local h = msg.height / msg.width

	gl.Viewport(0, 0, msg.width, msg.height)

	gl.MatrixMode(#GL_PROJECTION)
  	gl.LoadIdentity()
  	glu.Perspective (80.0, 1/h, 1.0, 100)

	gl.MatrixMode(#GL_MODELVIEW)
  	gl.LoadIdentity()
  	glu.LookAt( 0.0, 0.0, 25.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0)

	gl.Clear(#GL_COLOR_BUFFER_BIT)

EndFunction

Function p_LoadTextures(mp, flip_p)
	
  	Local orig_w = GetAttribute(#BRUSH, 1, #ATTRWIDTH)
	Local orig_h = GetAttribute(#BRUSH, 1, #ATTRHEIGHT)
	mp.real_char_rows = #CHAR_ROWS - 2
 	
 	; OpenGL textures must be power-of-two
	CreateBrush(2, 512, 512, 0, {AlphaChannel = True, Clear = True})
	SelectBrush(2, #SELMODE_COMBO)
	DisplayBrush(1, 0, 6)
	DisplayBrushPart(1, 0, 46 * 12, 0, 6 + 46 * 10, 512, 46)
	EndSelect	
 	
	; char size in pixels
  	Local cw = orig_w / #CHAR_COLS
  	Local ch = orig_h / #CHAR_ROWS

	; char size in ratio of final (padded) texture size
  	mp.tex_char_width  = cw / 512
  	mp.tex_char_height = ch / 512

  	; Flip each character's bits horizontally -- we could also just do this
	; by reversing the texture coordinates on the quads, but on some systems
     	; that slows things down a lot.
     	If flip_p Then FlipBrush(2, True)

	; The pixmap is a color image with no transparency.  Set the texture's
     	; alpha to be the green channel, and set the green channel to be 100%.
	For Local y = 0 To 511
		For Local x = 0 To 511
			Local p = ReadBrushPixel(2, x, y)
			WriteBrushPixel(2, x, y, RGB(Red(p), 255, Blue(p)), Green(p))
		Next
	Next		
			
	; Now load the texture into GL.
	Local t = gl.GenTextures(1)
	mp.texture = t[0]
	
	gl.BindTexture(#GL_TEXTURE_2D, mp.texture)
	gl.TexImageFromBrush(0, 2)
	
	gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_MAG_FILTER, #GL_LINEAR)
  	gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_MIN_FILTER, #GL_LINEAR)

  	; I'd expect CLAMP to be the thing to do here, but oddly, we get a
	; faint solid green border around the texture if it is *not* REPEAT!
  	gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_WRAP_S, #GL_REPEAT)
  	gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_WRAP_T, #GL_REPEAT)

	gl.TexEnv(#GL_TEXTURE_ENV, #GL_TEXTURE_ENV_MODE, #GL_MODULATE)
	gl.PixelStore(#GL_UNPACK_ALIGNMENT, 1)

EndFunction

Function p_InitMatrix(msg)
	
	Local flip_p = False
	
	speed = #DEF_SPEED
	density = #DEF_DENSITY
	do_fog = #DEF_FOG
	do_waves = #DEF_WAVES
	do_rotate = #DEF_ROTATE
	do_texture = #DEF_TEXTURE

	Local mp = {track_tick = 0}
	
	Switch #DEF_MODE
	Case #MODE_MATRIX:
		flip_p = True
      		mp.glyph_map = matrix_encoding
	Case #MODE_DNA:
		mp.glyph_map = dna_encoding
	Case #MODE_BINARY:
		mp.glyph_map = binary_encoding
	Case #MODE_HEX:
		mp.glyph_map = hex_encoding
	Case #MODE_DECIMAL:
		mp.glyph_map = decimal_encoding
	EndSwitch
	
      	mp.nglyphs = ListItems(mp.glyph_map)
      	
	p_Reshape(msg)

	gl.ShadeModel(#GL_SMOOTH)

  	gl.Disable(#GL_DEPTH_TEST)
  	gl.Disable(#GL_CULL_FACE)
  	gl.Enable(#GL_NORMALIZE)

  	If do_texture Then p_LoadTextures(mp, flip_p)

	; to scale coverage-percent to strips, this number looks about right... 
  	mp.nstrips = Int(density * 2.2)
  	If mp.nstrips < 1 Then mp.nstrips = 1 ElseIf mp.nstrips > 2000 mp.nstrips = 2000

	mp.strips = {}
	For Local i = 0 To mp.nstrips - 1
		
		mp.strips[i] = {}
		Local s = mp.strips[i]
		
		p_ResetStrip(mp, s)
		
		; If we start all strips from zero at once, then the first few seconds
         	; of the animation are much denser than normal.  So instead, set all
         	; the initial strips to erase-mode with random starting positions.
         	; As these die off at random speeds and are re-created, we'll get a
         	; more consistent density.
      		s.erasing_p = True
      		s.spinner_y = p_FRnd(#GRID_SIZE)
      		
      		For Local k = 0 To #GRID_SIZE - 1 Do s.glyphs[k] = 0
      	Next
      			
	; Compute the brightness ramp.
	mp.brightness_ramp = {}
	For Local i = 0 To #WAVE_SIZE - 1

		Local j = (#WAVE_SIZE - i) / (#WAVE_SIZE - 1)
      		j = j * (#PI / 2)       ; j ranges from 0.0 - #PI/2  
      		j = Sin(j)		; j ranges from 0.0 - 1.0
      		j = 0.2 + (j * 0.8)     ; j ranges from 0.2 - 1.0  
      		mp.brightness_ramp[i] = j
      	Next
      		
  	p_AutoTrackInit(mp)

	mps = mp
	
EndFunction

Function p_DrawFrame(mp)
	
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)

  	gl.PushMatrix()
	gl.Rotate(0, 0, 0, 1)

	If do_texture
		gl.Enable(#GL_TEXTURE_2D)
      		gl.Enable(#GL_BLEND)

      		; Jeff Epler points out:
         	; By using #GL_ONE instead of #GL_SRC_ONE_MINUS_ALPHA, glyphs are
        	; added to each other, so that a bright glyph with a darker one
         	; in front is a little brighter than the bright glyph alone.
		gl.BlendFunc(#GL_SRC_ALPHA, #GL_ONE)
    	EndIf

	If do_rotate
		gl.Rotate(mp.view_x, 1, 0, 0)
		gl.Rotate(mp.view_y, 0, 1, 0)
    	EndIf

	; Render (and tick) each strip, starting at the back
     	; draw the ones farthest from the camera first, to make
     	; the alpha transparency work out right.)
     	Local sorted = {}
     	For Local i = 0 To mp.nstrips - 1 Do sorted[i] = mp.strips[i]
     	Sort(sorted, Function(a, b) Return(a.z < b.z) EndFunction)
     	
     	For Local i = 0 To mp.nstrips - 1
     		p_TickStrip(mp, sorted[i])
     		p_DrawStrip(mp, sorted[i])
     	Next
     			
  	p_AutoTrack(mp)

  	gl.PopMatrix()
	gl.Finish()

EndFunction

matrix_encoding = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175}
decimal_encoding  = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25}
hex_encoding = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 33, 34, 35, 36, 37, 38}
binary_encoding = {16, 17}
dna_encoding = {33, 35, 39, 52}

char_map = {
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /*   0 */
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /*  16 */
    0,  1,  2, 96,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,  /*  32 */
   16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,  /*  48 */
   32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,  /*  64 */
   48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,  /*  80 */
   64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,  /*  96 */
   80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,  /* 112 */
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /* 128 */
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /* 144 */
   96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,  /* 160 */
  112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,  /* 176 */
  128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  /* 192 */
  144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  /* 208 */
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /* 224 */
   96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,  /* 240 */
}

nice_views = {
  {x = 0,   y = 0},
  {x = 0,   y = -20},     /* this is a list of viewer rotations that look nice. */
  {x = 0,   y = 20},      /* every now and then we switch to a new one.         */
  {x = 25,  y = 0},       /* (but we only use the first one at start-up.)       */
  {x = -25, y = 0},
  {x = 25,  y = 20},
  {x = -25, y = 20},
  {x = 25,  y = -20},
  {x = -25, y = -20},

  {x = 10,  y = 0},
  {x = -10, y = 0},
  {x = 0,   y = 0},  /* prefer these */
  {x = 0,   y = 0},
  {x = 0,   y = 0},
  {x = 0,   y = 0},
  {x = 0,   y = 0},
}

p_InitMatrix({width = 640, height = 480})

InstallEventHandler({SizeWindow = Function(msg) p_Reshape(msg) EndFunction,
	ModeSwitch = Function(msg) p_InitMatrix(msg) EndFunction})
	
; Setup a hardware doublebuffer managed by GL Galore		
BeginDoubleBuffer(True)

EscapeQuit(True)

Repeat
	DisableLineHook()
	p_DrawFrame(mps)
	EnableLineHook()
	
	; Swap buffers
	Flip

	CheckEvent
Forever

