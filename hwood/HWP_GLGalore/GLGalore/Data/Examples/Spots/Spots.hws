
/* Copyright (c) Mark J. Kilgard, 1994. 
 *
 * Ported to Hollywood by Andreas Falkenhahn
 *
 * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Sizeable = True, Title = "Spots"}

Const #TWO_PI = 2 * #PI
Const #NUM_LIGHTS = 3
Const #useSAME_AMB_SPEC = 1

Local modelAmb = {0.2, 0.2, 0.2, 1.0}
Local matAmb = {0.2, 0.2, 0.2, 1.0}
Local matDiff = {0.8, 0.8, 0.8, 1.0}
Local matSpec = {0.4, 0.4, 0.4, 1.0}
Local matEmission = {0.0, 0.0, 0.0, 1.0}

spots = {
	{
	amb = {0.2, 0.0, 0.0, 1.0},   /* ambient */
	diff = {0.8, 0.0, 0.0, 1.0},  /* diffuse */
	spec = {0.4, 0.0, 0.0, 1.0},  /* specular */
	pos = {0.0, 0.0, 0.0, 1.0},   /* position */
	spotDir = {0.0, -1.0, 0.0},   /* direction */
	spotExp = 20.0,
	spotCutoff = 60.0,            /* exponent, cutoff */
	atten = {1.0, 0.0, 0.0},      /* attenuation */
	trans = {0.0, 1.25, 0.0},     /* translation */
	rot = {0.0, 0.0, 0.0},        /* rotation */
	swing = {20.0, 0.0, 40.0},    /* swing */
	Arc = {0.0, 0.0, 0.0},        /* arc */
	arcIncr = {#TWO_PI / 70.0, 0.0, #TWO_PI / 140.0}  /* arc increment */
	},
	
	{
	amb = {0.0, 0.2, 0.0, 1.0},   /* ambient */
	diff = {0.0, 0.8, 0.0, 1.0},  /* diffuse */
	spec = {0.0, 0.4, 0.0, 1.0},  /* specular */
	pos = {0.0, 0.0, 0.0, 1.0},   /* position */
	spotDir = {0.0, -1.0, 0.0},   /* direction */
	spotExp = 20.0,
	spotCutoff = 60.0,            /* exponent, cutoff */
	atten = {1.0, 0.0, 0.0},      /* attenuation */
	trans = {0.0, 1.25, 0.0},     /* translation */
	rot = {0.0, 0.0, 0.0},        /* rotation */
	swing = {20.0, 0.0, 40.0},    /* swing */
	Arc = {0.0, 0.0, 0.0},        /* arc */
	arcIncr = {#TWO_PI / 120.0, 0.0, #TWO_PI / 60.0}  /* arc increment */
	},

	{
	amb = {0.0, 0.0, 0.2, 1.0},   /* ambient */
	diff = {0.0, 0.0, 0.8, 1.0},  /* diffuse */
	spec = {0.0, 0.0, 0.4, 1.0},  /* specular */
	pos = {0.0, 0.0, 0.0, 1.0},   /* position */
	spotDir = {0.0, -1.0, 0.0},   /* direction */
	spotExp = 20.0,
	spotCutoff = 60.0,            /* exponent, cutoff */
	atten = {1.0, 0.0, 0.0},      /* attenuation */
	trans = {0.0, 1.25, 0.0},     /* translation */
	rot = {0.0, 0.0, 0.0},        /* rotation */
	swing = {20.0, 0.0, 40.0},    /* swing */
	Arc = {0.0, 0.0, 0.0},        /* arc */
	arcIncr = {#TWO_PI / 50.0, 0.0, #TWO_PI / 100.0}  /* arc increment */
	}
}

Function p_InitLights()

	For Local k = 0 To #NUM_LIGHTS - 1
    
		Local lt = #GL_LIGHT0 + k

		gl.Enable(lt)
		gl.Light(lt, #GL_AMBIENT, spots[k].amb)
		gl.Light(lt, #GL_DIFFUSE, spots[k].diff)

		If #useSAME_AMB_SPEC
			gl.Light(lt, #GL_SPECULAR, spots[k].amb)
		Else
			gl.Light(lt, #GL_SPECULAR, spots[k].spec)
		EndIf

		gl.Light(lt, #GL_SPOT_EXPONENT, spots[k].spotExp)
		gl.Light(lt, #GL_SPOT_CUTOFF, spots[k].spotCutoff)
		gl.Light(lt, #GL_CONSTANT_ATTENUATION, spots[k].atten[0])
		gl.Light(lt, #GL_LINEAR_ATTENUATION, spots[k].atten[1])
		gl.Light(lt, #GL_QUADRATIC_ATTENUATION, spots[k].atten[2])
	Next

EndFunction

Function p_AimLights()

	For Local k = 0 To #NUM_LIGHTS - 1

		spots[k].rot[0] = spots[k].swing[0] * Sin(spots[k].Arc[0])
		spots[k].Arc[0] = spots[k].Arc[0] + spots[k].arcIncr[0]
		If spots[k].Arc[0] > #TWO_PI Then spots[k].Arc[0] = spots[k].Arc[0] - #TWO_PI

		spots[k].rot[1] = spots[k].swing[1] * Sin(spots[k].Arc[1])
		spots[k].Arc[1] = spots[k].Arc[1] + spots[k].arcIncr[1]
		If spots[k].Arc[1] > #TWO_PI Then spots[k].Arc[1] = spots[k].Arc[1] - #TWO_PI

		spots[k].rot[2] = spots[k].swing[2] * Sin(spots[k].Arc[2])
		spots[k].Arc[2] = spots[k].Arc[2] + spots[k].arcIncr[2]
		If spots[k].Arc[2] > #TWO_PI Then spots[k].Arc[2] = spots[k].Arc[2] - #TWO_PI

	Next

EndFunction

Function p_SetLights()

	For Local k = 0 To #NUM_LIGHTS - 1

		Local lt = #GL_LIGHT0 + k

		gl.PushMatrix()
		gl.Translate(spots[k].trans[0], spots[k].trans[1], spots[k].trans[2])
		gl.Rotate(spots[k].rot[0], 1, 0, 0)
		gl.Rotate(spots[k].rot[1], 0, 1, 0)
		gl.Rotate(spots[k].rot[2], 0, 0, 1)
		gl.Light(lt, #GL_POSITION, spots[k].pos)
		gl.Light(lt, #GL_SPOT_DIRECTION, spots[k].spotDir)
		gl.PopMatrix()
	Next

EndFunction

Function p_DrawLights()

	gl.Disable(#GL_LIGHTING)

	For Local k = 0 To #NUM_LIGHTS - 1

		gl.Color(spots[k].diff)

		gl.PushMatrix()
		gl.Translate(spots[k].trans[0], spots[k].trans[1], spots[k].trans[2])
		gl.Rotate(spots[k].rot[0], 1, 0, 0)
		gl.Rotate(spots[k].rot[1], 0, 1, 0)
		gl.Rotate(spots[k].rot[2], 0, 0, 1)
		gl.Begin(#GL_LINES)
		gl.Vertex(spots[k].pos[0], spots[k].pos[1], spots[k].pos[2])
		gl.Vertex(spots[k].spotDir[0], spots[k].spotDir[1], spots[k].spotDir[2])
		gl.End()
		gl.PopMatrix()
	Next

	gl.Enable(#GL_LIGHTING)

EndFunction

Function p_DrawPlane(w, h)

	Local dw = 1.0 / w
	Local dh = 1.0 / h

	gl.Normal(0.0, 0.0, 1.0)
  
	For Local j = 0 To h - 1
		gl.Begin(#GL_TRIANGLE_STRIP)
		For Local i = 0 To w
			gl.Vertex(dw * i, dh * (j + 1))
			gl.Vertex(dw * i, dh * j)
		Next
		gl.End()
	Next

EndFunction

Function p_Display()

	gl.Clear(#GL_COLOR_BUFFER_BIT)

	gl.PushMatrix()
	gl.Rotate(spin, 0, 1, 0)

	p_AimLights()
	p_SetLights()

	gl.PushMatrix()
	gl.Rotate(-90.0, 1, 0, 0)
	gl.Scale(1.9, 1.9, 1.0)
	gl.Translate(-0.5, -0.5, 0.0)
	p_DrawPlane(16, 16)
	gl.PopMatrix()

	p_DrawLights()
	gl.PopMatrix()

	spin = spin + 0.5
	If spin > 360.0 Then spin = spin - 360.0

EndFunction

Function p_Reshape(msg)

	gl.Viewport(0, 0, msg.width, msg.height)
	gl.MatrixMode(#GL_PROJECTION)
  	gl.LoadIdentity()
	gl.Frustum(-1, 1, -1, 1, 2, 6)

	gl.MatrixMode(#GL_MODELVIEW)
	gl.LoadIdentity()
	gl.Translate(0.0, 0.0, -3.0)
	gl.Rotate(45.0, 1, 0, 0)

EndFunction

Function p_Init(w, h)

	p_Reshape({width = w, height = h})

	gl.Enable(#GL_LIGHTING)
	gl.Enable(#GL_NORMALIZE)

	gl.LightModel(#GL_LIGHT_MODEL_AMBIENT, modelAmb)
	gl.LightModel(#GL_LIGHT_MODEL_LOCAL_VIEWER, #GL_TRUE)
	gl.LightModel(#GL_LIGHT_MODEL_TWO_SIDE, #GL_FALSE)

	gl.Material(#GL_FRONT, #GL_AMBIENT, matAmb)
	gl.Material(#GL_FRONT, #GL_DIFFUSE, matDiff)
	gl.Material(#GL_FRONT, #GL_SPECULAR, matSpec)
	gl.Material(#GL_FRONT, #GL_EMISSION, matEmission)
	gl.Material(#GL_FRONT, #GL_SHININESS, 10.0)

	p_InitLights()

EndFunction

InstallEventHandler({
	SizeWindow = Function(msg) p_Init(msg.width, msg.height) EndFunction,
	ModeSwitch = Function(msg) p_Init(msg.width, msg.height) EndFunction,
 	})

p_Init(640, 480)

; Setup a hardware doublebuffer managed by GL Galore	
BeginDoubleBuffer(True)

EscapeQuit(True)

Repeat
	DisableLineHook()

	p_Display()

	EnableLineHook()

	; Swap buffers
	Flip

	CheckEvent
Forever

