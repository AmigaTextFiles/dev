/*-
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice appear in all copies and that
 * both that copyright notice and this permission notice appear in
 * supporting documentation.
 *
 * This file is provided AS IS with no warranties of any kind.  The author
 * shall have no liability with respect to the infringement of copyrights,
 * trade secrets or any patents by this file or any part thereof.  In no
 * event will the author be liable for any lost revenue or profits or
 * other special, indirect and consequential damages.
 *
 * The original code for this mode was written by Marcelo Fernandes Vianna
 * (me...) and was inspired on a WindowsNT(R)'s screen saver (Flower Box).
 * It was written from scratch and it was not based on any other source code.
 *
 * Porting it to xlock (the final objective of this code since the moment I
 * decided to create it) was possible by comparing the original Mesa's gear
 * demo with it's ported version to xlock, so thanks for Danny Sung (look at
 * gear.c) for his indirect help.
 *
 * Thanks goes also to Brian Paul for making it possible and inexpensive
 * to use OpenGL at home.
 *
 * If you are interested in the original version of this program (not a xlock
 * mode, please refer to the Mesa package (ftp iris.ssec.wisc.edu on /pub/Mesa)
 *
 * Since I'm not a native Engl.ish speaker, my apologies for any grammatical
 * mistakes.
 *
 * My e-mail address is
 * mfvianna@centroin.com.br
 *
 * Marcelo F. Vianna (Feb-13-1997)
 *
 * Revision History:
 * 05-Apr-2002: Removed all gl.list uses (fix some bug with nvidia driver)
 * 01-Mar-2001: Added FPS stuff E.Lassauge <lassauge@mail.dotcom.fr>
 * 27-Jul-1997: Speed ups by Marcelo F. Vianna.
 * 08-May-1997: Speed ups by Marcelo F. Vianna.
 *
 * Ported to Hollywood by Andreas Falkenhahn 
 *
 */

@VERSION 6,0

@REQUIRE "glgalore"

@DISPLAY {Sizeable = True, Title = "Morph3D"}

Const #SCALE4WINDOW = 0.3

; Increasing these values produces better image quality, the price is speed. 
Const #TETRADIVISIONS             = 23
Const #CUBEDIVISIONS              = 20
Const #OCTADIVISIONS              = 21
Const #DODECADIVISIONS            = 10
Const #ICODIVISIONS               = 15

Const #TETRAANGLE                 = 109.47122063449069174
Const #CUBEANGLE                  = 90.000000000000000000
Const #OCTAANGLE                  = 109.47122063449069174
Const #DODECAANGLE                = 63.434948822922009981
Const #ICOANGLE                   = 41.810314895778596167

Const #SQRT2                      = 1.4142135623730951455
Const #SQRT3                      = 1.7320508075688771932
Const #SQRT5                      = 2.2360679774997898051
Const #SQRT6                      = 2.4494897427831778813
Const #SQRT15                     = 3.8729833462074170214
Const #COSSEC36_2                 = 0.8506508083520399322
Const #COS72                      = 0.3090169943749474241
Const #SIN72                      = 0.9510565162951535721
Const #COS36                      = 0.8090169943749474241
Const #SIN36                      = 0.5877852522924731292

Const #TAU                        = (#SQRT5+1)/2

front_shininess = {60.0}
front_specular  = {0.7, 0.7, 0.7, 1.0}
ambient         = {0.0, 0.0, 0.0, 1.0}
diffuse         = {1.0, 1.0, 1.0, 1.0}
position0       = {1.0, 1.0, 1.0, 0.0}
position1       = {-1.0, -1.0, 1.0, 0.0}
lmodel_ambient  = {0.5, 0.5, 0.5, 1.0}
lmodel_twoside  = {#GL_TRUE}

MaterialRed     = {0.7, 0.0, 0.0, 1.0}
MaterialGreen   = {0.1, 0.5, 0.2, 1.0}
MaterialBlue    = {0.0, 0.0, 0.7, 1.0}
MaterialCyan    = {0.2, 0.5, 0.7, 1.0}
MaterialYellow  = {0.7, 0.7, 0.0, 1.0}
MaterialMagenta = {0.6, 0.2, 0.5, 1.0}
MaterialWhite   = {0.7, 0.7, 0.7, 1.0}
MaterialGray    = {0.5, 0.5, 0.5, 1.0}

Function VectMul(X1,Y1,Z1,X2,Y2,Z2)
	Return(Y1*Z2-Z1*Y2, Z1*X2-X1*Z2, X1*Y2-Y1*X2)
EndFunction
	
Function sqr(A)
	Return(A*A)
EndFunction

Function p_Triangle(Edge, Amp, Divisions, Z)                                                                    
                                                                                                               
	Local   Xf,Yf,Xa,Yb,Xf2,Yf2,Yf_2,Yb2,Yb_2                                                   
  	Local   Factor,Factor1,Factor2                                                                          
  	Local   VertX,VertY,VertZ,NeiAX,NeiAY,NeiAZ,NeiBX,NeiBY,NeiBZ                                               
  	Local   Ax,Ay                                                                                                                                                                                           
  	Local   Vr=Edge*#SQRT3/3                                                                                   
  	Local   AmpVr2=Amp/sqr(Vr)                                                                                
  	Local   Zf=Edge*Z                                                                                       
                                                                                                                 
  	Ax=Edge*(0.5/Divisions)
  	Ay=Edge*(-#SQRT3/(2*Divisions))                                                
                                                                                                                 
 	Yf=Vr+Ay Yb=Yf+0.001                                                                                         
  
  	For Local Ri=1 To Divisions   
  		                                                                         
    		gl.Begin(#GL_TRIANGLE_STRIP)                                                                                  
    		Xf=Ri*Ax Xa=Xf+0.001                                                                                
    		Yf2=sqr(Yf) Yf_2=sqr(Yf-Ay)                                                                                
    		Yb2=sqr(Yb) Yb_2=sqr(Yb-Ay)                                                                                
    
    		For Local Ti=0 To Ri - 1   
    			Xf2=sqr(Xf)                                                                                 
      			Factor=1-((Xf2+Yf2)*AmpVr2)                                                                     
      			Factor1=1-((sqr(Xa)+Yf2)*AmpVr2)                                                                          
      			Factor2=1-((Xf2+Yb2)*AmpVr2)                                                                              
      			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                           
      			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                    
      			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                    
      			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                             
      			gl.Vertex(VertX, VertY, VertZ)                                                                           
                                                                                                          
      			Xf=Xf-Ax Yf=Yf-Ay Xa=Xa-Ax Yb=Yb-Ay                                                                            
                       
                       	Xf2=sqr(Xf)
                       	                                                                                          
      			Factor=1-((Xf2+Yf_2)*AmpVr2)                                                                    
      			Factor1=1-((sqr(Xa)+Yf_2)*AmpVr2)                                                                         
      			Factor2=1-((Xf2+Yb_2)*AmpVr2)                                                                             
      			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                           
      			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                    
      			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                    
      			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                             
      			gl.Vertex(VertX, VertY, VertZ)                                                                           
                                                                                                                                                                                                 
      			Xf=Xf-Ax Yf=Yf+Ay Xa=Xa-Ax Yb=Yb+Ay                                                                            
    		Next
    		
    		Xf2=sqr(Xf)
    		Yf2=sqr(Yf)
    		                                                                                                            
    		Factor=1-((Xf2+Yf2)*AmpVr2)                                                             
    		Factor1=1-((sqr(Xa)+Yf2)*AmpVr2)                                                                            
    		Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                            
    		VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                             
    		NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                      
    		NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                      
    		gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                               
    		gl.Vertex(VertX, VertY, VertZ)                                                                             
    		Yf=Yf+Ay Yb=Yb+Ay                                                                                              
    		gl.End()                                                                                                     
	Next
	                                                                                                              
  	Return(Factor<0)                                                                                                 

EndFunction

Function p_Square(Edge, Amp, Divisions, Z)                                                                      
                                                                                                                                                                                                  
	Local   Xf,Yf,Y,Xf2,Yf2,Y2,Xa,Xa2,Yb                                                                        
  	Local   Factor,Factor1,Factor2                                                                          
  	Local   VertX,VertY,VertZ,NeiAX,NeiAY,NeiAZ,NeiBX,NeiBY,NeiBZ                                               
  	Local   Zf=Edge*Z                                                                                       
  	Local   AmpVr2=Amp/sqr(Edge*#SQRT2/2)                                                                    
                                                                                                                 
  	For Local Yi=0 To Divisions - 1
  		                                                                             
    		Yf=-(Edge/2.0) + (Yi)/Divisions*Edge                                                           
    		Yf2=sqr(Yf)                                                                                                 
    		Y=Yf+1.0/Divisions*Edge                                                                                 
    		Y2=sqr(Y)                                                                                                   
    		gl.Begin(#GL_QUAD_STRIP)                                                                                      
    	
    		For Local Xi=0 To Divisions                                                                          
      			Xf=-(Edge/2.0) + (Xi)/Divisions*Edge                                                         
      			Xf2=sqr(Xf)                                                                                               
                                                                                                                 
      			Xa=Xf+0.001 Yb=Y+0.001                                                                                   
      			Factor=1-((Xf2+Y2)*AmpVr2)                                                                                
      			Xa2=sqr(Xa)
      			Factor1=1-((Xa2+Y2)*AmpVr2)                                                                     
      			Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                          
      			VertX=Factor*Xf        VertY=Factor*Y         VertZ=Factor*Zf                                           
      			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Y-VertY  NeiAZ=Factor1*Zf-VertZ                                    
      			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                    
      			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                             
      			gl.Vertex(VertX, VertY, VertZ)                                                                           
                                                                                                                 
      			Yb=Yf+0.001                                                                                               
      			Factor=1-((Xf2+Yf2)*AmpVr2)                                                                               
      			Factor1=1-((Xa2+Yf2)*AmpVr2)                                                                              
      			Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                          
      			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                           
      			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                    
      			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                    
      			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                             
      			gl.Vertex(VertX, VertY, VertZ)                                                                                                                                                                
    		Next                                                                                                            
   
   		gl.End()                                                                                                     
  	Next
  	                                                                                                              
  	Return(Factor<0)                                                                                                 

EndFunction

Function p_Pentagon(Edge, Amp, Divisions, Z)                                                                    
                                                                                                                                                                                                
	Local   Xf,Yf,Xa,Yb,Xf2,Yf2                                                                                 
  	Local   Factor,Factor1,Factor2                                                                          
  	Local   VertX,VertY,VertZ,NeiAX,NeiAY,NeiAZ,NeiBX,NeiBY,NeiBZ                                               
  	Local   Zf=Edge*Z                                                                                       
  	Local   AmpVr2=Amp/sqr(Edge*#COSSEC36_2)                                                                 
                                                                                                                 
  	Local x = {}
  	Local y = {}                                                                                             
                                                                                                                 
  	For Local Fi=0 To 5                                                                                          
    		x[Fi]=-cos( Fi*2*#PI/5 + #PI/10 )/Divisions*#COSSEC36_2*Edge                                               
    		y[Fi]=sin( Fi*2*#PI/5 + #PI/10 )/Divisions*#COSSEC36_2*Edge                                                
  	Next                                                                                                              
                                                                                                                 
  	For Local Ri=1 To Divisions                                                                            
    		For Local Fi=0 To 4                                                                                     
      			gl.Begin(#GL_TRIANGLE_STRIP)                                                                                
      			For Local Ti=0 To Ri - 1                                                                                  
        			Xf=(Ri-Ti)*x[Fi] + Ti*x[Fi+1]                                                             
        			Yf=(Ri-Ti)*y[Fi] + Ti*y[Fi+1]                                                             
        			Xa=Xf+0.001 Yb=Yf+0.001
        			Xf2=sqr(Xf) 
        			Yf2=sqr(Yf)                                                                               
				Factor=1-((Xf2+Yf2)*AmpVr2)                                                             
				Factor1=1-((sqr(Xa)+Yf2)*AmpVr2)                                                                            
				Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                            
        			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                         
        			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                  
        			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                  
        			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                           
				gl.Vertex(VertX, VertY, VertZ)                                                                         
                                                                                                    
				Xf=Xf-x[Fi] Yf=Yf-y[Fi] Xa=Xa-x[Fi] Yb=Yb-y[Fi]                                                              
                
                		Xf2=sqr(Xf)
                		Yf2=sqr(Yf)                                                                                                 
				Factor=1-((Xf2+Yf2)*AmpVr2)                                                         
				Factor1=1-((sqr(Xa)+Yf2)*AmpVr2)                                                                        
				Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                        
        			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                         
        			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                  
        			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                  
        			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                           
				gl.Vertex(VertX, VertY, VertZ)                                                                                                                                                            
                  	Next
                  	                                                                                                          
      			Xf=Ri*x[Fi+1]                                                                                      
      			Yf=Ri*y[Fi+1]                                                                                      
      			Xa=Xf+0.001 Yb=Yf+0.001                                                                                  
      
      			Xf2=sqr(Xf)
      			Yf2=sqr(Yf)
      			Factor=1-((Xf2+Yf2)*AmpVr2)                                                           
      			Factor1=1-((sqr(Xa)+Yf2)*AmpVr2)                                                                          
      			Factor2=1-((Xf2+sqr(Yb))*AmpVr2)                                                                          
      			VertX=Factor*Xf        VertY=Factor*Yf        VertZ=Factor*Zf                                           
      			NeiAX=Factor1*Xa-VertX NeiAY=Factor1*Yf-VertY NeiAZ=Factor1*Zf-VertZ                                    
      			NeiBX=Factor2*Xf-VertX NeiBY=Factor2*Yb-VertY NeiBZ=Factor2*Zf-VertZ                                    
      			gl.Normal(VectMul(NeiAX, NeiAY, NeiAZ, NeiBX, NeiBY, NeiBZ))                                             
      			gl.Vertex(VertX, VertY, VertZ)                                                                           
      			gl.End()                                                                                                   
		Next
	Next
			      			                                                                                           
	Return(Factor<0)	                                                                                             

EndFunction

Function p_DrawTetra(mp)
	
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[0])

	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 0.5 / #SQRT6)

	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#TETRAANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[1])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 0.5 / #SQRT6)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #TETRAANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[2])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 0.5 / #SQRT6)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #TETRAANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[3])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 0.5 / #SQRT6)

EndFunction

Function p_DrawCube(mp)
	
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[0])

	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)

	gl.Rotate(#CUBEANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[1])
	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)
	gl.Rotate(#CUBEANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[2])
	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)
	gl.Rotate(#CUBEANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[3])
	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)
	gl.Rotate(#CUBEANGLE, 0, 1, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[4])
	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)
	gl.Rotate(2 * #CUBEANGLE, 0, 1, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[5])
	mp.VisibleSpikes = p_Square(2, mp.seno, mp.edgedivisions, 0.5)

EndFunction

Function p_DrawOcta(mp)
	
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[0])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)

	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-180 + #OCTAANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[1])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-#OCTAANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[2])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-#OCTAANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[3])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PopMatrix()
	gl.Rotate(180, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[4])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-180 + #OCTAANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[5])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-#OCTAANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[6])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-#OCTAANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[7])
	mp.VisibleSpikes = p_Triangle(2, mp.seno, mp.edgedivisions, 1 / #SQRT6)

EndFunction

Function p_DrawDodeca(mp)
	
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[0])

	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)

	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[1])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, #COS72, #SIN72, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[2])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, #COS72, -#SIN72, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[3])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(#DODECAANGLE, #COS36, -#SIN36, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[4])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.Rotate(#DODECAANGLE, #COS36, #SIN36, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[5])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.Rotate(180, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[6])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.Rotate(180, 0, 0, 1)
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[7])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, #COS72, #SIN72, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[8])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(-#DODECAANGLE, #COS72, -#SIN72, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[9])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(#DODECAANGLE, #COS36, -#SIN36, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[10])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)
	gl.PopMatrix()
	gl.Rotate(#DODECAANGLE, #COS36, #SIN36, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[11])
	mp.VisibleSpikes = p_Pentagon(1, mp.seno, mp.edgedivisions, sqr(#TAU) * sqrt((#TAU + 2) / 5) / 2)

EndFunction

Function p_DrawIcosa(mp)
	
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[0])

	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)

	gl.PushMatrix()

	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[1])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[2])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[3])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[4])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[5])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[6])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[7])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[8])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[9])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[10])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[11])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[12])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[13])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[14])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, #SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[15])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[16])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[17])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PushMatrix()
	gl.Rotate(180, 0, 1, 0)
	gl.Rotate(-180 + #ICOANGLE, 0.5, -#SQRT3 / 2, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[18])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)
	gl.PopMatrix()
	gl.Rotate(180, 0, 0, 1)
	gl.Rotate(-#ICOANGLE, 1, 0, 0)
	gl.Material(#GL_FRONT_AND_BACK, #GL_DIFFUSE, mp.MaterialColor[19])
	mp.VisibleSpikes = p_Triangle(1.5, mp.seno, mp.edgedivisions, (3 * #SQRT3 + #SQRT15) / 12)

EndFunction

Function p_Reshape(msg)

	gl.Viewport(0, 0, msg.width, msg.height)
	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	gl.Frustum(-1.0, 1.0, -1.0, 1.0, 5.0, 15.0)
	gl.MatrixMode(#GL_MODELVIEW)
	
	mps.windW = msg.width
	mps.windH = msg.height
	
EndFunction	

Function p_Init(mp)
	
	gl.ClearDepth(1.0)
	gl.Color(1.0, 1.0, 1.0)

	gl.Light(#GL_LIGHT0, #GL_AMBIENT, ambient)
	gl.Light(#GL_LIGHT0, #GL_DIFFUSE, diffuse)
	gl.Light(#GL_LIGHT0, #GL_POSITION, position0)
	gl.Light(#GL_LIGHT1, #GL_AMBIENT, ambient)
	gl.Light(#GL_LIGHT1, #GL_DIFFUSE, diffuse)
	gl.Light(#GL_LIGHT1, #GL_POSITION, position1)
	gl.LightModel(#GL_LIGHT_MODEL_AMBIENT, lmodel_ambient)
	gl.LightModel(#GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside)
	gl.Enable(#GL_LIGHTING)
	gl.Enable(#GL_LIGHT0)
	gl.Enable(#GL_LIGHT1)
	gl.Enable(#GL_DEPTH_TEST)
	gl.Enable(#GL_NORMALIZE)

	gl.ShadeModel(#GL_SMOOTH)
	gl.Material(#GL_FRONT_AND_BACK, #GL_SHININESS, front_shininess)
	gl.Material(#GL_FRONT_AND_BACK, #GL_SPECULAR, front_specular)

	mp.MaterialColor = {}
	
	Switch mp.object
	Case 2:
		mp.draw_object = p_DrawCube
		mp.MaterialColor[0] = MaterialRed
		mp.MaterialColor[1] = MaterialGreen
		mp.MaterialColor[2] = MaterialCyan
		mp.MaterialColor[3] = MaterialMagenta
		mp.MaterialColor[4] = MaterialYellow
		mp.MaterialColor[5] = MaterialBlue
		mp.edgedivisions = #CUBEDIVISIONS
		mp.Magnitude = 2.0
	Case 3:
		mp.draw_object = p_DrawOcta
		mp.MaterialColor[0] = MaterialRed
		mp.MaterialColor[1] = MaterialGreen
		mp.MaterialColor[2] = MaterialBlue
		mp.MaterialColor[3] = MaterialWhite
		mp.MaterialColor[4] = MaterialCyan
		mp.MaterialColor[5] = MaterialMagenta
		mp.MaterialColor[6] = MaterialGray
		mp.MaterialColor[7] = MaterialYellow
		mp.edgedivisions = #OCTADIVISIONS
		mp.Magnitude = 2.5
	Case 4:
		mp.draw_object = p_DrawDodeca
		mp.MaterialColor[0] = MaterialRed
		mp.MaterialColor[1] = MaterialGreen
		mp.MaterialColor[2] = MaterialCyan
		mp.MaterialColor[3] = MaterialBlue
		mp.MaterialColor[4] = MaterialMagenta
		mp.MaterialColor[5] = MaterialYellow
		mp.MaterialColor[6] = MaterialGreen
		mp.MaterialColor[7] = MaterialCyan
		mp.MaterialColor[8] = MaterialRed
		mp.MaterialColor[9] = MaterialMagenta
		mp.MaterialColor[10] = MaterialBlue
		mp.MaterialColor[11] = MaterialYellow
		mp.edgedivisions = #DODECADIVISIONS
		mp.Magnitude = 2.0
	Case 5:
		mp.draw_object = p_DrawIcosa
		mp.MaterialColor[0] = MaterialRed
		mp.MaterialColor[1] = MaterialGreen
		mp.MaterialColor[2] = MaterialBlue
		mp.MaterialColor[3] = MaterialCyan
		mp.MaterialColor[4] = MaterialYellow
		mp.MaterialColor[5] = MaterialMagenta
		mp.MaterialColor[6] = MaterialRed
		mp.MaterialColor[7] = MaterialGreen
		mp.MaterialColor[8] = MaterialBlue
		mp.MaterialColor[9] = MaterialWhite
		mp.MaterialColor[10] = MaterialCyan
		mp.MaterialColor[11] = MaterialYellow
		mp.MaterialColor[12] = MaterialMagenta
		mp.MaterialColor[13] = MaterialRed
		mp.MaterialColor[14] = MaterialGreen
		mp.MaterialColor[15] = MaterialBlue
		mp.MaterialColor[16] = MaterialCyan
		mp.MaterialColor[17] = MaterialYellow
		mp.MaterialColor[18] = MaterialMagenta
		mp.MaterialColor[19] = MaterialGray
		mp.edgedivisions = #ICODIVISIONS
		mp.Magnitude = 2.5
	Default:
		mp.draw_object = p_DrawTetra
		mp.MaterialColor[0] = MaterialRed
		mp.MaterialColor[1] = MaterialGreen
		mp.MaterialColor[2] = MaterialBlue
		mp.MaterialColor[3] = MaterialWhite
		mp.edgedivisions = #TETRADIVISIONS
		mp.Magnitude = 2.5
	EndSwitch

EndFunction

Function p_InitMorph3D(msg)
	
	Local mp = {}

	mps = mp
		
	mp.stepx = RndF() * 90
	mp.VisibleSpikes = 1

	p_Reshape(msg)
	gl.DrawBuffer(#GL_BACK)

	mp.object = 1
	p_Init(mp)

EndFunction
	
Function p_DrawMorph3D(mp)
	
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)

	gl.PushMatrix()

	gl.Translate(0.0, 0.0, -10.0)

	gl.Scale(#SCALE4WINDOW * mp.WindH / mp.WindW, #SCALE4WINDOW, #SCALE4WINDOW)
	gl.Translate(2.5 * mp.WindW / mp.WindH * Sin(mp.stepx * 1.11), 2.5 * cos(mp.stepx * 1.25 * 1.11), 0)

	gl.Rotate(mp.stepx * 100, 1, 0, 0)
	gl.Rotate(mp.stepx * 95, 0, 1, 0)
	gl.Rotate(mp.stepx * 90, 0, 0, 1)

	mp.seno = (Sin(mp.stepx) + 1.0 / 3.0) * (4.0 / 5.0) * mp.Magnitude

	If mp.VisibleSpikes
		gl.Disable(#GL_CULL_FACE)
	Else
		gl.Enable(#GL_CULL_FACE)
	EndIf

	mp.draw_object(mp)

	gl.PopMatrix()

	mp.stepx = mp.stepx + 0.05

EndFunction

Function p_ChangeMorph3D(msg)

	Local mp = msg.userdata
	Local t = GetVersion()
	
	; workaround for a bug in the Windows versions of Hollywood (fixed in 6.1)
	If (t.Platform = "Win32") And (Val(t.Version) <= 6) And (mp.first = True)
		mp.first = False
	Else
		mp.object = (mp.object) % 5 + 1
		p_Init(mp)
	EndIf

EndFunction
			
p_InitMorph3D({width = 640, height = 480})

InstallEventHandler({SizeWindow = Function(msg) p_Reshape(msg) EndFunction,
	ModeSwitch = Function(msg) p_InitMorph3D(msg) EndFunction})

mps.first = True
SetInterval(1, p_ChangeMorph3D, 10000, mps)

StartTimer(1)
	
; Setup a hardware doublebuffer managed by GL Galore		
BeginDoubleBuffer(True)

EscapeQuit(True)

Repeat
	DisableLineHook()
	p_DrawMorph3D(mps)
	EnableLineHook()
	
	; Swap buffers
	Flip

	CheckEvent
	WaitTimer(1, 30)
Forever
