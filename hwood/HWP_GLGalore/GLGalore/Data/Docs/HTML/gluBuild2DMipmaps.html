<html>
<!-- generated from GLGalore.meta by MetaDoc 1.7 (c) by Andreas Falkenhahn -->
<head>
<title>glu.Build2DMipmaps</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.7">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
glu.Build2DMipmaps -- create 2D mipmaps</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
error = glu.Build2DMipmaps(iformat, width, height, format, type, pixels)</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
<code>glu.Build2DMipmaps()</code> builds a series of prefiltered 2D texture maps of decreasing resolution. Mipmaps can be used so
that textures don't appear aliased.

<p>
A return value of 0 indicates success. Otherwise a GLU error code is returned (See <a href="gluErrorString.html">glu.ErrorString</a> for details.).

<p>
<code>glu.Build2DMipmaps()</code> first check whether <code>width</code> and <code>height</code> of <code>pixels</code> are both powers of 2. If not, <code>glu.Build2DMipmaps()</code> scales a
copy of <code>pixels</code> up or down to the nearest power of 2. This copy is then used as the base for subsequent mipmapping operations. For
example, if <code>width</code> is 57 and <code>height</code> is 23, then a copy of <code>pixels</code> scales up to 64 and down to 16, respectively, before mipmapping
takes place. (If <code>width</code> or <code>height</code> is exactly between powers of 2, the copy of data is scaled upward.)

<p>
If the GL version is 1.1 or greater, <code>glu.Build2DMipmaps()</code> then uses proxy textures (See <a href="glTexImage2D.html">gl.TexImage2D</a> for details.) to determine
whether there's enough room for the requested texture in the implementation. If not, <code>width</code> is halved (and halved again) until it fits.

<p>
<code>glu.Build2DMipmaps()</code> then uses proxy textures (See <a href="glTexImage2D.html">gl.TexImage2D</a> for details.) to determine if the implementation can store the
requested texture in texture memory. If not, both dimensions are continually halved until it fits.

<p>
Next, <code>glu.Build2DMipmaps()</code> builds a series of images; it halves a copy of <code>type</code> (or a scaled version of <code>type</code>, if necessary) along
both dimensions until size 1x1 is reached. At each level, each texel in the halved mipmap is an average of the corresponding four
texels in the larger mipmap. (In the case of rectangular images, halving the images repeatedly eventually results in an n*1 or 1*n
configuration. Here, two texels are averaged instead.)

<p>
<a href="glTexImage2D.html">gl.TexImage2D()</a> is called to load each of these images by level. If <code>width</code> and <code>height</code> are both powers of 2
which fit in the implementation, level 0 is a copy of <code>pixels</code>, and the highest level is log2(max(width, height)). For example, if
<code>width</code> is 64 and <code>height</code> is 16, the following mipmaps are built: 64x16, 32x8, 16x4, 8x2, 4x1, 2x1 and 1x1. These correspond to levels
0 through 6, respectively.

<p>
<code>iformat</code> specifies the internal format of the texture image. See <a href="InternalPixelFormats.html">Internal pixel formats</a> for details.
This can also be one of the special values 1, 2, 3, or 4.

<p>
<code>format</code> must be one of <code>#GL_COLOR_INDEX</code>, <code>#GL_RED</code>, <code>#GL_GREEN</code>, <code>#GL_BLUE</code>, <code>#GL_ALPHA</code>, <code>#GL_RGB</code>, <code>#GL_RGBA</code>, <code>#GL_LUMINANCE</code>, or <code>#GL_LUMINANCE_ALPHA</code>

<p>
<code>type</code> must be one of <code>#GL_UNSIGNED_BYTE</code>, <code>#GL_BYTE</code>, <code>#GL_BITMAP</code>, <code>#GL_UNSIGNED_SHORT</code>, <code>#GL_SHORT</code>, <code>#GL_UNSIGNED_INT</code>, <code>#GL_INT</code>, or <code>#GL_FLOAT</code>.

<p>
Please note that this command operates directly with memory pointers. There is also a version which works
with tables instead of memory pointers, but this is slower of course. See <a href="gluBuildMipmaps.html">glu.BuildMipmaps</a> for details.
See <a href="UsingPointers.html">Working with pointers</a> for details on how to use memory pointers with Hollywood.

<p>
Please consult an OpenGL reference manual for more information.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>iformat</i></dt>
<dd>specifies the internal format of the texture; must be one of the pixel format constants (see above)</dd>
<dt><i>width</i></dt>
<dd>specifies the width of the texture image</dd>
<dt><i>height</i></dt>
<dd>specifies the height of the texture image</dd>
<dt><i>format</i></dt>
<dd>specifies the format of the pixel data (see above)</dd>
<dt><i>type</i></dt>
<dd>specifies the data type for <code>pixels</code> (see above)</dd>
<dt><i>pixels</i></dt>
<dd>specifies a pointer to the image data in memory</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>error</i></dt>
<dd>error code or 0 for success</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="gluBuild2DMipmaps_.html" target="_top">Show TOC</a></font>
</body>
</html>