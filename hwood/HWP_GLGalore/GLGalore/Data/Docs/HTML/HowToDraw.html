<html>
<!-- generated from GLGalore.meta by MetaDoc 1.7 (c) by Andreas Falkenhahn -->
<head>
<title>Drawing graphics</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.7">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<h2 class="heading">3.4 Drawing graphics</h2>

<p>
For an optimal performance you need to be very careful concerning the way you draw your
graphics. Most of Hollywood's drawing commands are implemented in software only, i.e. they
draw using the CPU instead of the GPU. This can become quite a bottleneck especially on
slower CPUs. Thus, you should draw directly using the OpenGL commands offered by GL Galore
whenever and whereever possible.

<p>
Nevertheless, there are a few Hollywood commands which are redirected to use OpenGL directly
when GL Galore has been activated. These are the following:

<p>
<table cellpadding="0" cellspacing="0"><tr><td>&nbsp;</td><td><pre>Box()
Cls()
Line()
Plot()
DisplayBrush()
</pre></td></tr></table><p>

You can use these commands with OpenGL without any performance penalty. However, there are
some restrictions: <code>Box()</code>, <code>Line()</code>, and <code>WritePixel()</code> will only be redirected to OpenGL
in case the fill style is either <code>#FILLNONE</code> or <code>#FILLCOLOR</code> and no other form styles like <code>#EDGE</code> or
<code>#SHADOW</code> are active. As soon as you want to draw with other fill or form styles, these
commands will fall back to their software counterparts and thus will be very slow.

<p>
<code>DisplayBrush()</code> will only use OpenGL directly when called with a hardware brush.
See <a href="HardwareBrushes.html">Using hardware brushes</a> for details. When used with a software brush, i.e. a brush
that doesn't reside in video memory, <code>DisplayBrush()</code> will draw the brush using the CPU
which is much slower.

<p>
When mixing Hollywood and OpenGL drawing commands, however, there is another potential
problem that you have to be aware of: Since OpenGL is a state machine, changes to the
GL state made by one of Hollywood's drawing commands can affect subsequent calls to
OpenGL commands. Thus, you might need to restore certain states after calling a
Hollywood command which is redirected to OpenGL, e.g. the current color, transformation
matrix, matrix mode, enable texturing, blending or depth test again, etc. This can get
quite tedious so it is often easier to use only OpenGL commands in order to avoid having
to restore states after calling Hollywood commands.

<p>
Finally, don't forget that you should do all your drawing inside a hardware double buffer
loop. See <a href="HardwareDB.html">Using a hardware double buffer</a> for details.

<p>
<hr>
<font size=-2><a href="HowToDraw_.html" target="_top">Show TOC</a></font>
</body>
</html>