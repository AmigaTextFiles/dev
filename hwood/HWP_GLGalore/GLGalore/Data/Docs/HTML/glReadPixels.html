<html>
<!-- generated from GLGalore.meta by MetaDoc 1.7 (c) by Andreas Falkenhahn -->
<head>
<title>gl.ReadPixels</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.7">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
gl.ReadPixels -- read a block of pixels from the frame buffer</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
pixelsArray = gl.ReadPixels(x, y, width, height, format)</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
<code>gl.ReadPixels()</code> returns pixel data from the frame buffer, starting with the pixel whose lower left corner is at location (x, y),
in a table. Several parameters control the processing of the pixel data before it is placed into the table. These parameters are
set with three commands: <a href="glPixelStore.html">gl.PixelStore()</a>, <a href="glPixelTransfer.html">gl.PixelTransfer()</a>, and <a href="glPixelMap.html">gl.PixelMap()</a>.
This reference page describes the effects on <code>gl.ReadPixels()</code> of most, but not all of the parameters specified by these three commands.

<p>
<code>gl.ReadPixels()</code> returns values from each pixel with lower left corner at (x + i, y + j) for 0 &lt;= i &lt; width and 0 &lt;= j &lt; height. This
pixel is said to be the ith pixel in the jth row. Pixels are returned in row order from the lowest to the highest row, left to right in
each row.

<p>
<code>gl.ReadPixels()</code> always uses type <code>#GL_FLOAT</code> to read the pixels from the frame buffer. For fine-tuned control over the data type
of the pixel data, you can use <a href="glReadPixelsRaw.html">gl.ReadPixelsRaw()</a> instead. See <a href="glReadPixelsRaw.html">gl.ReadPixelsRaw</a> for details.

<p>
<code>format</code> specifies the format for the returned pixel values; accepted values are:

<p>
<dl>
<dt class="codelist"><code>#GL_COLOR_INDEX</code></dt>
<dd>
Color indices are read from the color buffer selected by gl.ReadBuffer(). Each index is converted to fixed point, shifted left
or right depending on the value and sign of <code>#GL_INDEX_SHIFT</code>, and added to <code>#GL_INDEX_OFFSET</code>. If <code>#GL_MAP_COLOR</code> is <code>#GL_TRUE</code>, indices
are replaced by their mappings in the table <code>#GL_PIXEL_MAP_I_TO_I</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_STENCIL_INDEX</code></dt>
<dd>
Stencil values are read from the stencil buffer. Each index is converted to fixed point, shifted left or right depending on the
value and sign of <code>#GL_INDEX_SHIFT</code>, and added to <code>#GL_INDEX_OFFSET</code>. If <code>#GL_MAP_STENCIL</code> is <code>#GL_TRUE</code>, indices are replaced by their
mappings in the table <code>#GL_PIXEL_MAP_S_TO_S</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_DEPTH_COMPONENT</code></dt>
<dd>
Depth values are read from the depth buffer. Each component is converted to floating point such that the minimum depth value maps
to 0 and the maximum value maps to 1. Each component is then multiplied by <code>#GL_DEPTH_SCALE</code>, added to <code>#GL_DEPTH_BIAS</code>, and finally
clamped to the range (0,1).

<p>
</dd>
<dt class="codelist"><code>#GL_RED</code></dt>
<dd>
Processing differs depending on whether color buffers store color indices or RGBA color components. If color indices are stored,
they are read from the color buffer selected by gl.ReadBuffer(). Each index is converted to fixed point, shifted left or right
depending on the value and sign of <code>#GL_INDEX_SHIFT</code>, and added to <code>#GL_INDEX_OFFSET</code>. Indices are then replaced by the red, green,
blue, and alpha values obtained by indexing the tables <code>#GL_PIXEL_MAP_I_TO_R</code>, <code>#GL_PIXEL_MAP_I_TO_G</code>, <code>#GL_PIXEL_MAP_I_TO_B</code>, and
<code>#GL_PIXEL_MAP_I_TO_A</code>. Each table must be of size 2^n , but n may be different for different tables. Before an index is used to
look up a value in a table of size 2^n , it must be masked against 2^n - 1.

<p>
If RGBA color components are stored in the color buffers, they are read from the color buffer selected by gl.ReadBuffer(). Each color
component is converted to floating point such that zero intensity maps to 0.0 and full intensity maps to 1.0. Each component is then
multiplied by <code>#GL_c_SCALE</code> and added to <code>#GL_c_BIAS</code>, where c is RED, GREEN, BLUE, or ALPHA. Finally, if <code>#GL_MAP_COLOR</code> is <code>#GL_TRUE</code>, each
component is clamped to the range (0,1), scaled to the size of its corresponding table, and is then replaced by its mapping in the
table <code>#GL_PIXEL_MAP_c_TO_c</code>, where c is R, G, B, or A.

<p>
Unneeded data is then discarded. For example, <code>#GL_RED</code> discards the green, blue, and alpha components, while <code>#GL_RGB</code> discards only
the alpha component. <code>#GL_LUMINANCE</code> computes a single-component value as the sum of the red, green, and blue components, and <code>#GL_LUMINANCE_ALPHA</code>
does the same, while keeping alpha as a second value. The final values are clamped to the range (0,1).

<p>
</dd>
<dt class="codelist"><code>#GL_GREEN</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_BLUE</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_ALPHA</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_RGB</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_RGBA</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_LUMINANCE</code></dt>
<dd>
See above in <code>#GL_RED</code>.

<p>
</dd>
<dt class="codelist"><code>#GL_LUMINANCE_ALPHA</code></dt>
<dd>
See above in <code>#GL_RED</code>.
</dd></dl>

<p>
The shift, scale, bias, and lookup factors just described are all specified by <a href="glPixelTransfer.html">gl.PixelTransfer()</a>. The lookup table
contents themselves are specified by <a href="glPixelMap.html">gl.PixelMap()</a>.

<p>
Return values are placed in the table as follows. If <code>format</code> is <code>#GL_COLOR_INDEX</code>, <code>#GL_STENCIL_INDEX</code>, <code>#GL_DEPTH_COMPONENT</code>, <code>#GL_RED</code>, <code>#GL_GREEN</code>, <code>#GL_BLUE</code>, <code>#GL_ALPHA</code>,
or <code>#GL_LUMINANCE</code>, a single floating-point value is returned. <code>#GL_RGB</code> returns three values, <code>#GL_RGBA</code> returns four values, and <code>#GL_LUMINANCE_ALPHA</code> returns two values
for each pixel, with all values corresponding to a single pixel occupying contiguous space in data. Storage parameters set by <a href="glPixelStore.html">gl.PixelStore()</a>,
such as <code>#GL_PACK_LSB_FIRST</code> and <code>#GL_PACK_SWAP_BYTES</code>, affect the way that data is written into memory. See <a href="glPixelStore.html">gl.PixelStore</a> for details.

<p>
Values for pixels that lie outside the window connected to the current GL context are undefined.

<p>
Please consult an OpenGL reference manual for more information.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>x</i></dt>
<dd>specify the left coordinate of a rectangular block of pixels</dd>
<dt><i>y</i></dt>
<dd>specify the lower coordinate of a rectangular block of pixels</dd>
<dt><i>width</i></dt>
<dd>width of the pixel rectangle</dd>
<dt><i>height</i></dt>
<dd>height of the pixel rectangle</dd>
<dt><i>format</i></dt>
<dd>format of the pixel data (see above)</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>pixelsArray</i></dt>
<dd>a table containing the pixel data</dl>
</dd>
<dt class="autodoc"><b>Errors</b></dt><dd>
<code>#GL_INVALID_ENUM</code> is generated if <code>format</code> is not an accepted value.

<p>
<code>#GL_INVALID_VALUE</code> is generated if either <code>width</code> or <code>height</code> is negative.

<p>
<code>#GL_INVALID_OPERATION</code> is generated if <code>format</code> is <code>#GL_COLOR_INDEX</code> and the color buffers store RGBA color components.

<p>
<code>#GL_INVALID_OPERATION</code> is generated if <code>format</code> is <code>#GL_STENCIL_INDEX</code> and there is no stencil buffer.

<p>
<code>#GL_INVALID_OPERATION</code> is generated if <code>format</code> is <code>#GL_DEPTH_COMPONENT</code> and there is no depth buffer.

<p>
<code>#GL_INVALID_OPERATION</code> is generated if <code>gl.ReadPixels()</code> is executed between the execution of <a href="glBegin.html">gl.Begin()</a> and the corresponding execution of <a href="glEnd.html">gl.End()</a>.

<p>
</dd>
<dt class="autodoc"><b>Associated gets</b></dt><dd>
<a href="glGet.html">gl.Get()</a> with argument <code>#GL_INDEX_MODE</code>

<p>
</dd></dl>
<hr>
<font size=-2><a href="glReadPixels_.html" target="_top">Show TOC</a></font>
</body>
</html>