@DATABASE GLGalore.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from GLGalore.meta by MetaDoc 1.7 (c) by Airsoft Softwair"
@$VER: GLGalore.guide 1.1 (16.05.2017)
@INDEX Reference
@HELP Reference

@NODE Main "GL Galore Guide"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                                       -= @{B}@{FG highlight}G L  G A L O R E@{FG text}@{UB} =-

                            Super smooth OpenGL® scripting with Hollywood

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 I. General information
 @{" Introduction                    " LINK Introduction}     What is GL Galore?
 @{" Terms and conditions            " LINK License}     License information
 @{" Requirements                    " LINK Requirements}     What you need to work with it
 @{" Installation                    " LINK Installation}     How to install GL Galore

 II. About GL Galore
 @{" Credits                         " LINK Credits}     Who was involved in this project?
 @{" F.A.Q.                          " LINK FAQ}     Frequently asked questions
 @{" Known issues                    " LINK KnownIssues}     List of things that can cause trouble
 @{" Future                          " LINK ToDo}     What is planned for the future?
 @{" History                         " LINK History}     What happened so far?

 III. Usage
 @{" Activating GL Galore            " LINK ActivatePlugin}     How to use GL Galore from your script
 @{" Accessing OpenGL from Hollywood " LINK AccessingOpenGL}     Calling into OpenGL with GL Galore
 @{" Using a hardware doublebuffer   " LINK HardwareDB}     All scripts need to be double-buffered
 @{" Drawing graphics                " LINK HowToDraw}     The basics on OpenGL drawing
 @{" Using hardware brushes          " LINK HardwareBrushes}     Benefit from hardware-accelerated blitting
 @{" Multiple displays               " LINK MultipleDisplays}     Managing multiple displays with GL Galore
 @{" Working with pointers           " LINK UsingPointers}     How to deal with raw data in memory blocks
 @{" Hollywood bridge                " LINK HollywoodBridge}     Convenience functions for bridging Hollywood and OpenGL
 @{" Increasing execution speed      " LINK MoreSpeed}     Ideas for making your script faster
 @{" Handling mode switches          " LINK ModeSwitch}     Information on how to handle mode switches
 @{" GL Galore as a helper plugin    " LINK OpenGLGlue}     Using GL Galore as a patch for Hollywood deficits
 @{" Internal pixel formats          " LINK InternalPixelFormats}     List of internal pixel formats

 IV. Tutorial
 @{" OpenGL tutorial                 " LINK Tutorial}     A tutorial for people starting out with GL Galore

 V. Examples
 @{" GL Galore examples              " LINK Examples}     Description of included examples

 VI. GL reference
 @{" GL function list                " LINK GLFunctions}     List of supported OpenGL calls

 VII. GLU reference
 @{" GLU function list               " LINK GLUFunctions}     List of supported GLU calls

 VIII. GLFW reference
 @{" GLFW function list              " LINK GLFWFunctions}     List of supported GLFW calls

 IX. Hollywood bridge
 @{" Hollywood bridging functions    " LINK BridgeFunctions}     List of calls bridging Hollywood and the GL

 @{" Index                           " LINK Reference}    Quickly find what you are looking for

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 GL Galore is (C) Copyright © 2014-2017 Andreas Falkenhahn                    All rights reserved
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@ENDNODE
@NODE Introduction "GL Galore Guide"
@{b}Introduction@{ub}

    GL Galore is a plugin for Hollywood that allows you to access the OpenGL®
    1.1 command set directly from Hollywood. This makes it possible to write
    scripts that utilize the host system's 3D hardware to create
    high-performance, butter-smooth 2D and 3D animation that is calculated
    completely in hardware by the GPU of your graphics board. This leads to a
    huge performance boost over the classic Hollywood graphics API which is
    mostly implemented in software. Especially systems with slower CPUs will
    benefit greatly from hardware-accelerated drawing offered by OpenGL.

    OpenGL is a portable software interface to graphics hardware. It is
    available for almost every platform in a variety of flavours. On AmigaOS and
    compatibles, OpenGL is available as MiniGL on AmigaOS 4, TinyGL on MorphOS,
    StormMesa on AmigaOS 3, and Mesa 3D on AROS. Windows, Mac OS X, and Linux
    systems are usually shipped with an OpenGL driver already installed. More
    information about OpenGL can be obtained from http://www.opengl.org. You can
    find good tutorials about learning OpenGL all over the web.

    There are two ways of using GL Galore: You can either access the OpenGL 1.1
    API directly or you can use Hollywood's hardware brush functions without
    making any direct calls to the OpenGL API. Whenever GL Galore is activated,
    Hollywood hardware brushes are mapped directly to OpenGL textures so they
    can be drawn and transformed in an extremely fast way on all supported
    systems. This is especially useful on Windows, Mac OS X, and Linux because
    Hollywood doesn't support hardware double buffers and brushes on these
    platforms by default. With GL Galore, however, hardware double buffers and
    brushes can be used on these platforms now too. So GL Galore can also act as
    a helper plugin here which adds this functionality to Hollywood without
    having you write a single line of OpenGL code to utilize it!

    On top of that, GL Galore offers wrapper functions for most commands of the
    OpenGL 1.1 API. These commands are wrapped directly with little to no
    changes to their original syntax. The only exception concerns OpenGL
    commands that expect a pointer: In this case, GL Galore usually offers a
    variant of the command so that it works with Hollywood tables. However, the
    original pointer variant is also available in GL Galore and can be used for
    time-critical scripts. Additionally, GL Galore also offers some bridging
    functions that allow you to convert Hollywood brushes into OpenGL textures
    and vice versa.

    GL Galore can also be useful for rapidly prototyping software written in
    OpenGL. People who used to program OpenGL using C will greatly appreciate
    Hollywood's convenient multimedia API which offers functions for almost all
    common tasks. For example, by using GL Galore to write OpenGL programs you
    can avoid all the hassle of managing a GL window using one of the many
    different toolkits out there. Also, jobs like image loading, sound or video
    playback, font handling and image manipulation become ridiculously easy now
    thanks to Hollywood's powerful command set which covers almost 700
    functions.

    GL Galore utilizes the new display adapter plugin interface introduced with
    Hollywood 6.0. Thus, the plugin will not work with any older versions of
    Hollywood. It requires at least Hollywood 6.0. Whenever GL Galore is
    activated, all graphics output will automatically be routed through OpenGL.
    To benefit from hardware acceleration, however, Hollywood scripts have to
    follow some rules as described in this manual.

    GL Galore comes with extensive documentation in various formats like PDF,
    HTML, AmigaGuide, and CHM that contains a full OpenGL reference and
    information about special functions in GL Galore. On top of that, many
    example scripts are included in the distribution archive to get you started
    really quickly.

    All of this makes GL Galore the ultimate OpenGL scripting experience
    combining the best of both worlds into one powerful plugin: Hollywood's
    extensive and convenient multimedia function set and OpenGL's raw graphics
    power!

@ENDNODE

@NODE License "GL Galore Guide"
@{b}Terms and conditions@{ub}

    GL Galore is © Copyright 2014-2017 by Andreas Falkenhahn (in the following
    referred to as "the author"). All rights reserved.

    The program is provided "as-is" and the author cannot be made responsible of
    any possible harm done by it. You are using this program absolutely at your
    own risk. No warranties are implied or given by the author.

    This plugin may be freely distributed as long as the following three
    conditions are met:

    1. No modifications must be made to the plugin.
    2. It is not allowed to sell this plugin.
    3. If you want to put this plugin on a coverdisc, you need to ask for
       permission first.

    This software uses LuaGL by Fabio Guerra, Cleyde Marlyse, and Antonio Scuri.
    See @{"LuaGL license" LINK LicenseLuaGL} for details.

    This software uses GLFW by Marcus Geelnard and Camilla Berglund. See @{"GLFW" LINK LicenseGLFW}
    @{"license" LINK LicenseGLFW} for details.

    This software uses StormMesa by Sam Jordan and Brian Paul. See @{"LGPL license" LINK LicenseLGPLv2}
    for details.

    This documentation is based on the OpenGL® 2.1 reference manual (C)
    1991-2006 Silicon Graphics, Inc. See @{"SGI Free Software B license" LINK LicenseFreeB} for
    details.

    OpenGL® and the oval logo are trademarks or registered trademarks of Silicon
    Graphics, Inc. in the United States and/or other countries worldwide.

    Amiga is a registered trademark of Amiga, Inc.

    All other trademarks belong to their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "GL Galore Guide"
@{b}Requirements@{ub}

    - Hollywood 6.0 or better
    - Windows: requires at least Windows 2000
    - Mac OS X: requires at least 10.5 on PowerPC or 10.6 on Intel Macs
    - MorphOS: requires TinyGL with MorphOS 3.8 or better
    - AmigaOS 3: requires StormMesa, 68040 or 68060, and an FPU
    - AmigaOS 4: requires MiniGL
    - AROS: requires Mesa 3D

@ENDNODE

@NODE Installation "GL Galore Guide"
@{b}Installation@{ub}

    Installing GL Galore is straightforward and simple: Just copy the file
    glgalore.hwp for the platform to Hollywood's plugins directory. On all
    systems except on AmigaOS and compatibles, plugins must be stored in a
    directory named Plugins that is in the same directory as the main Hollywood
    program. On AmigaOS and compatible systems, plugins must be installed to
    LIBS:Hollywood instead. On Mac OS X, the Plugins directory must be inside
    the Resources directory of the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources.

    Afterwards merge the contents of the Examples folder with the Examples
    folder that is part of your Hollywood installation. All GL Galore examples
    will then appear in Hollywood's GUI and you can launch and view them
    conveniently from the Hollywood GUI or IDE.

    On Windows you should also copy the file GLGalore.chm to the Docs directory
    of your Hollywood installation. Then you will be able to get online help by
    pressing F1 when the cursor is over a GL Galore function in the Hollywood
    IDE.

    On Linux and Mac OS copy the GLGalore directory that is inside the Docs
    directory of the GL Galore distribution archive to the Docs directory of
    your Hollywood installation. Note that on Mac OS the Docs directory is
    within the Hollywood.app application bundle, i.e. in
    Hollywood.app/Contents/Resources/Docs.

@ENDNODE

@NODE Credits "GL Galore Guide"
@{b}Credits@{ub}

    GL Galore was written by Andreas Falkenhahn. Additional coding by Fabio
    Guerra, Cleyde Marlyse, and Antonio Scuri. Work on this project was started
    in January 2014 as a proof-of-concept demonstration of Hollywood 6.0's
    powerful new display adapter API which allows plugins to take over
    Hollywood's entire display handler and replace it with a custom driver. It
    was then successively expanded into a full wrapper for the OpenGL 1.1 API
    including some bridging functions between Hollywood and OpenGL as well as a
    hardware brush and double-buffer driver for all the platforms that are not
    supported by Hollywood's inbuilt hardware brush and double-buffer driver.

    Thanks go to Frank Mariak, Mark Olsen, Hans de Ruiter, Frank Wille,
    Krzysztof Smiechowicz, and Sam Jordan.

    If you need to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE FAQ "GL Galore Guide"
@{b}Frequently asked questions@{ub}

    This section covers some frequently asked questions. Please read them first
    before asking on the mailing list or forum because your problem might have
    been covered here.

    @{b}Q: @{ub}@{b}Why @{ub}@{b}does @{ub}@{b}GL @{ub}@{b}Galore @{ub}@{b}report @{ub}@{b}all @{ub}@{b}keyboard @{ub}@{b}events @{ub}@{b}in @{ub}@{b}upper @{ub}@{b}case @{ub}@{b}notation?@{ub}

    A: That's a limitation of GLFW which is used by GL Galore. It currently
    doesn't allow listeners to distinguish between upper and lower case key
    presses when using raw keyboard listeners. See @{"Known issues" LINK KnownIssues} for details. If
    you have Hollywood 7.0 or better, you can just listen to the "VanillaKey"
    event handler to get the real keyboard events with full Unicode support.


    @{b}Q: @{ub}@{b}Why @{ub}@{b}are @{ub}@{b}the @{ub}@{b}Y @{ub}@{b}and @{ub}@{b}Z @{ub}@{b}keys @{ub}@{b}swapped @{ub}@{b}on @{ub}@{b}German @{ub}@{b}keyboards?@{ub}

    A: That's because GLFW's raw key listener is based on the US keyboard
    layout. See @{"Known issues" LINK KnownIssues} for details. If you are on Hollywood 7.0 or better,
    you can just listen to the "VanillaKey" event handler instead. This will
    give you the real keyboard events with full Unicode support.


    @{b}Q: @{ub}@{b}Is @{ub}@{b}there @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}forum @{ub}@{b}where @{ub}@{b}I @{ub}@{b}can @{ub}@{b}get @{ub}@{b}in @{ub}@{b}touch @{ub}@{b}with @{ub}@{b}other @{ub}@{b}users?@{ub}

    A: Yes, please check out the "Community" section of the official Hollywood
    Portal online at http://www.hollywood-mal.com.


    @{b}Q: @{ub}@{b}How @{ub}@{b}do @{ub}@{b}I @{ub}@{b}quit @{ub}@{b}scripts @{ub}@{b}that @{ub}@{b}run @{ub}@{b}in @{ub}@{b}fullscreen @{ub}@{b}mode?@{ub}

    A: Just press CTRL+C. This will always work except when CTRL+C has been
    explicitly disabled using Hollywood's "CtrlCQuit()" function.


    @{b}Q: @{ub}@{b}Where @{ub}@{b}can @{ub}@{b}I @{ub}@{b}ask @{ub}@{b}for @{ub}@{b}help?@{ub}

    A: There's a lively forum at http://forums.hollywood-mal.com and we also
    have a mailing list which you can access at
    airsoft_hollywood\@yahoogroups.com. Visit http://www.hollywood-mal.com for
    information on how to join the mailing list.


    @{b}Q: @{ub}@{b}I @{ub}@{b}have @{ub}@{b}found @{ub}@{b}a @{ub}@{b}bug.@{ub}

    A: Please post about it in the dedicated sections of the forum or the
    mailing list.

@ENDNODE

@NODE KnownIssues "GL Galore Guide"
@{b}Known issues@{ub}

    Here is a list of things that GL Galore doesn't support yet or that may be
    confusing in some way:

    - menus are unsupported
    - the mouse wheel is unsupported
    - the keyboard listener that is mapped to Hollywood's "OnKeyDown" and
      "OnKeyUp" event handlers currently only supports raw key codes based on
      the US keyboard layout; this means that all character keys will be
      returned as upper-case and on German keyboards the position of the Y and Z
      keys will be swapped. This is because of a limitation in GLFW which
      doesn't support fine-tuned listening (i.e. key down, key repeat, key up)
      using international keyboards; people who are on Hollywood 7.0 or better
      can just use the "VanillaKey" event handler instead; this event handler
      will deliver real keyboard events including full Unicode support
    - not all display styles are supported

@ENDNODE

@NODE ToDo "GL Galore Guide"
@{b}Future@{ub}

    Here are some things that are on my to do list:

    - add support for tesselation
    - improve support for OpenGL 1.2
    - integrate with FTGL for 3D text effects
    - add some more convenience functions that make it easier to use OpenGL
    - add support for embedding OpenGL displays in MUI GUIs via MUI Royale

    Don't hesitate to contact me if GL Galore lacks a certain feature that is
    important for your project.

@ENDNODE

@NODE History "GL Galore Guide"
@{b}History@{ub}

    Please read the history bottom-up. Note that the history might list some
    features that were implemented in beta versions and removed later but are
    still mentioned here. This history is a log of the programmer so that he
    can look up what has been done/tried/modified. Things that were implemented
    and removed later are marked with [VOID].

    Version 1.1   (19-May-17)

    - Change: Updated documentation
    - New: Added \@2x graphics for high resolutions systems on Windows and Mac OS 
    - New: Added 64-bit builds for Windows, Linux, and Mac OS
    - New: Added Linux ARM build; note that the Raspberry Pi currently only comes with an experimental
      OpenGL driver which is disabled by default; to enable it, you need to open raspi-config, go
      to "Advanced Options", enable it and reboot
    - New: Added the following functions for polling joystick input through GLFW: glfw.JoystickPresent(),
      glfw.GetJoystickButtons(), glfw.GetJoystickAxes(), and glfw.GetJoystickName(); these can be
      useful because there are much more flexible than Hollywood's inbuilt joystick library which is
      very Amiga-centric and was mainly designed for 1980s-style joysticks
    - Fix: Cube.hws and MultiDisplays.hws didn't call CheckEvent()
    - New: Added support for Hollywood 7's new FULLSCREENSCALE mode
    - New: Added help strings for GL Galore's commands; if you have Hollywood 7, you will now get
      function help with Hollywood's IDE for Windows and you can also press F1 to open the GL Galore
      reference; note that you need to copy GLGalore.chm to the "Docs" directory of your Hollywood
      installation directory for this to work
    - Fix: glu.Build3DMipmaps(), glu.UnProject(), and gl.GetCurrentContext() were not documented
    - New: Added Unicode support if Hollywood 7 is available; you can use the new "VanillaKey" event
      handler to listen to Unicode keys
    - Fix [Amiga]: GL Galore no longer crashes when started in full screen mode and the GL context
      couldn't be initialized, e.g. because of missing drivers (reported by Redlion)
    - Change [Win32]: Flip() uses a different vertical synchronization mechanism now that prevents
      tearing on some systems
    - Fix: Plugin initialization code didn't balance the stack after it was done

    Version 1.0   (03-Jun-15)
    - First Release
@ENDNODE

@NODE ActivatePlugin "GL Galore Guide"
@{b}Activating GL Galore@{ub}

    All you have to do to make your script use OpenGL instead of Hollywood's
    inbuilt graphics driver is adding the following line to the top of your
    script:

        \@REQUIRE "glgalore"

    Alternatively, if you are using Hollywood from a console, you can also start
    your script like this:

        Hollywood test.hws -requireplugins glgalore

    Once the GL Galore plugin has been activated for your script, it will
    reroute all of Hollywood's graphics output through OpenGL. Note that this
    will usually be slower than Hollywood's inbuilt graphics driver for scripts
    that aren't optimized for OpenGL. To get an optimal performance with OpenGL,
    your script needs to use a hardware-accelerated double buffer. See @{"Using a" LINK HardwareDB}
    @{"hardware double buffer" LINK HardwareDB} for details.

    GL Galore accepts the following arguments in its "\@REQUIRE" call:

    ForceFullRefresh:
              If this tag is set to FALSE, GL Galore will only refresh the parts
              of the display that have actually changed. This is quicker but it
              doesn't work correctly with older OpenGL implementations
              (especially on Amiga) because they often do not offer pixel
              perfect positioning of graphics. That is why this tag defaults to
              TRUE, which means that GL Galore will always refresh the full
              display whenever something is drawn. Note that this tag is only
              used when GL Galore is running without a hardware double buffer.
              In hardware double-buffered mode, front and back buffers cause a
              full refresh anyway.

    Here is an example of how to pass arguments to the "\@REQUIRE" preprocessor
    command:

        \@REQUIRE "glgalore", {ForceFullRefresh = False}

    Alternatively, you can also use the -requiretags console argument to pass
    these arguments. See the Hollywood manual for more information.

@ENDNODE

@NODE AccessingOpenGL "GL Galore Guide"
@{b}Accessing OpenGL from Hollywood@{ub}

    GL Galore directly wraps all OpenGL commands to Hollywood with little to no
    changes to their original syntax. After calling "\@REQUIRE" on GL Galore,
    all GL functions will be made available inside a "gl" table and the GLU
    functions will be made available inside a "glu" table.

    Calling OpenGL functions from Hollywood is much simpler than using OpenGL
    directly because the argument specification (e.g., '2d', '3f', '4sv') at the
    end of most OpenGL functions names has been removed. For example, GL
    Galore's @{"gl.Light()" LINK glLight} function binds the OpenGL functions: "glLightf",
    "glLightfv", "glLighti", "glLightiv". The number of parameters passed to
    @{"gl.Light()" LINK glLight} defines the correct function to use.

    GL Galore usually uses the floating point versions of all the OpenGL
    functions with the highest possible precision. Some functions that have a
    type parameter simply use the most precise possible (usually #GL_DOUBLE or
    #GL_FLOAT) and the format parameter is not used. When "stride" is not used,
    then it is assumed to be 0.

    The color and the vector data can be passed as a Hollywood table or as
    multiple parameters. A vector can have 2, 3 or 4 values (x, y, z, w), and
    colors can have 3 or 4 values (red, green, blue, alpha).

    For example:

        v1 = {0, 0}
        v2 = {1, 1}
        yellow = {1, 1, 0}
        gl.Color(yellow)
        gl.Vertex(v1)
        gl.Vertex(v2)

    Or you can also do:

        gl.Color(1, 1, 0)
        gl.Vertex(0, 0)
        gl.Vertex(1, 1)

    There are some OpenGL commands that expect a pointer. In this case, GL
    Galore usually offers a variant of the command so that it works with
    Hollywood tables. However, the original pointer variant is also available in
    GL Galore and can be used for time-critical scripts. For example,
    @{"gl.ReadPixels()" LINK glReadPixels} reads pixel data from the frame buffer into a Hollywood
    table whereas @{"gl.ReadPixelsRaw()" LINK glReadPixelsRaw} reads pixel data into a memory buffer
    directly which is much faster of course, but requires you to work with
    pointers. See @{"Working with pointers" LINK UsingPointers} for details.

@ENDNODE

@NODE HardwareDB "GL Galore Guide"
@{b}Using a hardware double buffer@{ub}

    If you want your script to benefit from OpenGL's hardware-accelerated
    drawing functions, you need to use a hardware double buffer and do all your
    drawing within that double buffer. Using a hardware double buffer will also
    ensure that graphics output is synchronized with your monitor's refresh rate
    to prevent any flickering. To get an optimal performance with OpenGL, your
    main loop should always look like this:

        \@REQUIRE "glgalore"

        BeginDoubleBuffer(True)  ; set up a hardware double buffer

        Repeat
            ....          ; draw the next frame here
            Flip()        ; wait for vertical refresh, then flip buffers
            CheckEvent()  ; run event callbacks
        Forever

    The call to "CheckEvent()" is only necessary if your script needs to listen
    to event handlers that have been installed using "InstallEventHandler()".
    Note that you should not draw the next frame in an interval callback that
    runs at a constant frame rate (say 50fps) because such a setup won't
    guarantee that drawing is synchronized with the vertical refresh as
    different monitors use different refresh rates so you might get flickery
    graphics. If you do your drawing like above, you can be sure that front and
    back buffers will be flipped in perfect synchronization with the monitor's
    vertical refresh.

    Additionally, you need to take care of how you actually draw your graphics
    because most of Hollywood's drawing commands operate entirely in software
    mode and thus do not benefit from hardware acceleration. See @{"Drawing" LINK HowToDraw}
    @{"graphics" LINK HowToDraw} for details.

    @{b}Important: @{ub}OpenGL is designed to be used with double buffers. Thus, all
    OpenGL drawing commands must be called within a double buffer. Drawing
    outside a double buffer with OpenGL is unsupported.

@ENDNODE

@NODE HowToDraw "GL Galore Guide"
@{b}Drawing graphics@{ub}

    For an optimal performance you need to be very careful concerning the way
    you draw your graphics. Most of Hollywood's drawing commands are implemented
    in software only, i.e. they draw using the CPU instead of the GPU. This can
    become quite a bottleneck especially on slower CPUs. Thus, you should draw
    directly using the OpenGL commands offered by GL Galore whenever and
    whereever possible.

    Nevertheless, there are a few Hollywood commands which are redirected to use
    OpenGL directly when GL Galore has been activated. These are the following:

        Box()
        Cls()
        Line()
        Plot()
        DisplayBrush()

    You can use these commands with OpenGL without any performance penalty.
    However, there are some restrictions: "Box()", "Line()", and "WritePixel()"
    will only be redirected to OpenGL in case the fill style is either #FILLNONE
    or #FILLCOLOR and no other form styles like #EDGE or #SHADOW are active. As
    soon as you want to draw with other fill or form styles, these commands will
    fall back to their software counterparts and thus will be very slow.

    "DisplayBrush()" will only use OpenGL directly when called with a hardware
    brush. See @{"Using hardware brushes" LINK HardwareBrushes} for details. When used with a software
    brush, i.e. a brush that doesn't reside in video memory, "DisplayBrush()"
    will draw the brush using the CPU which is much slower.

    When mixing Hollywood and OpenGL drawing commands, however, there is another
    potential problem that you have to be aware of: Since OpenGL is a state
    machine, changes to the GL state made by one of Hollywood's drawing commands
    can affect subsequent calls to OpenGL commands. Thus, you might need to
    restore certain states after calling a Hollywood command which is redirected
    to OpenGL, e.g. the current color, transformation matrix, matrix mode,
    enable texturing, blending or depth test again, etc. This can get quite
    tedious so it is often easier to use only OpenGL commands in order to avoid
    having to restore states after calling Hollywood commands.

    Finally, don't forget that you should do all your drawing inside a hardware
    double buffer loop. See @{"Using a hardware double buffer" LINK HardwareDB} for details.

@ENDNODE

@NODE HardwareBrushes "GL Galore Guide"
@{b}Using hardware brushes@{ub}

    GL Galore supports the creation of hardware brushes. Hardware brushes reside
    in GPU memory and thus can be drawn in no time. On most graphics boards,
    they can also be scaled and transformed by the GPU in an extremely efficient
    way. To make Hollywood create a hardware brush, all you have to do is set
    the optional "Hardware" tag to TRUE. This tag is supported by most of the
    Hollywood commands which create brushes.

    Here is an example:

        \@REQUIRE "glgalore"  ; make sure this line is first
        \@BRUSH 1, "sprites.png", {Hardware = True}

    In the code above, GL Galore will create brush 1 in video memory. It can
    then be drawn using the GPU at almost no cost. Keep in mind, though, that
    hardware brushes can only be drawn to hardware double buffers. See @{"Using a" LINK HardwareDB}
    @{"hardware double buffer" LINK HardwareDB} for details.

    To transform a hardware brush, you can use the "ScaleBrush()",
    "RotateBrush()", and "TransformBrush()" commands. Transformations of
    hardware brushes are usually also GPU-accelerated and thus many times faster
    than transformations done by the CPU.

    Note that hardware brushes can only be drawn to the display that was
    specified when allocating them. Thus, if your script uses multiple displays,
    you need to tell Hollywood the identifier of the display you want to use
    this hardware brush with. This can be done by specifying the "Display" tag
    along the "Hardware" tag. Here is an example:

        \@REQUIRE "glgalore"  ; make sure this line is first
        \@DISPLAY 1, {Title = "First display"}
        \@DISPLAY 2, {Title = "Second display"}
        \@BRUSH 1, "sprites.png", {Hardware = True, Display = 1}
        \@BRUSH 2, "sprites.png", {Hardware = True, Display = 2}

    The code above will allocate brush 1 in a way that it can be drawn to
    display 1 and it will allocate brush 2 in a way that it can be drawn to
    display 2. It won't be possible, however, to draw brush 2 to display 1 or
    brush 1 to display 2! OpenGL hardware brushes are always display-dependent
    and can only be drawn to the display they were allocated for.

    Please see the Hollywood manual for more information on hardware brushes and
    hardware double buffers.

    You can also use GL Galore as a helper plugin to add hardware brush support
    to Hollywood on Windows, Mac OS X, and Linux. By default, Hollywood doesn't
    support hardware brushes on these systems but GL Galore can add this feature
    to Hollywood. See @{"GL Galore as a helper plugin" LINK OpenGLGlue} for details.

    The SmoothScroll.hws example script that comes with GL Galore demonstrates
    how to use hardware brushes and a hardware double buffer without any calls
    to OpenGL.

@ENDNODE

@NODE MultipleDisplays "GL Galore Guide"
@{b}Multiple displays@{ub}

    When using multiple displays, GL Galore maintains a separate OpenGL context
    for each display. Thus, you need to tell OpenGL which context all calls to
    the GL should operate on. This is done by calling the @{"gl.SetCurrentContext()" LINK glSetCurrentContext}
    function which makes the GL context of the specified Hollywood display the
    current context. See @{"gl.SetCurrentContext" LINK glSetCurrentContext} for details.

    When dealing with hardware brushes, you also need to be careful when using
    multiple displays because hardware brushes in OpenGL are display-dependent.
    They can only be drawn to the display that was used to allocate them. See
    @{"Using hardware brushes" LINK HardwareBrushes} for details.

@ENDNODE

@NODE UsingPointers "GL Galore Guide"
@{b}Working with pointers@{ub}

    Several OpenGL functions expect you to pass a pointer to a raw memory buffer
    to them. Working with pointers directly is the most efficient way to
    interact with OpenGL since it avoids any overhead created by having to read
    the contents of Hollywood tables into memory buffers first.

    You can use the functions of Hollywood's memory block library to allocate
    memory buffers, read or write to them, and obtain a pointer to their raw
    memory buffer. To allocate a memory buffer, you use the "AllocMem()"
    function, to read from a memory buffer you use "Peek()" while "Poke()" can
    be used to write to a memory buffer. Finally, "GetMemPointer()" returns the
    pointer of a memory block object. You can pass the return value of
    "GetMemPointer()" to all OpenGL functions which expect a pointer argument.

    Here is an example:

        AllocMem(1, 640*480*4)
        Local ptr = GetMemPointer(1)
        gl.ReadPixelsRaw(0, 0, 640, 480, #GL_BGRA, #GL_UNSIGNED_BYTE, ptr)
        ... ; do something with the data
        FreeMem(1)

    The code above reads 480 rows of 640 pixels into memory block object 1. You
    could then write the data to a file using "WriteMem()", you could convert it
    to a table using "MemToTable()" or read individual values from it using
    "Peek()". See the documentation of Hollywood's memory block library for more
    information.

@ENDNODE

@NODE HollywoodBridge "GL Galore Guide"
@{b}Hollywood bridge@{ub}

    GL Galore offers some additional functions that are not part of the official
    OpenGL API. These functions allow you to conveniently use Hollywood objects
    like brushes with OpenGL. For example, the @{"gl.TexImageFromBrush()" LINK glTexImageFromBrush} function
    allows you to upload a Hollywood brush as an OpenGL texture and the
    @{"gl.GetTexImageToBrush()" LINK glGetTexImageToBrush} functions allows you to convert an OpenGL texture
    back into a Hollywood brush.

    See the chapter "Hollywood bridge" for all available functions.

@ENDNODE

@NODE MoreSpeed "GL Galore Guide"
@{b}Increasing execution speed@{ub}

    To increase the raw execution speed of your script, you can disable
    Hollywood's line hook using the "DisableLineHook()" and "EnableLineHook()"
    commands. This will improve your script's execution speed significantly in
    case lots of Hollywood code needs to be run to draw the next frame. Keep in
    mind, though, that you have to enable the line hook for every frame you draw
    or your window will become unresponsive. Here's what a speed-optimized
    implemention of the main loop could look like:

        \@REQUIRE "glgalore"

        BeginDoubleBuffer(True)  ; set up a hardware double buffer

        Repeat
            DisableLineHook() ; disable line hook while drawing the next frame
            p_DrawFrame()     ; draw the next frame here
            EnableLineHook()  ; enable line hook again
            Flip()            ; wait for vertical refresh, then flip buffers
            CheckEvent()      ; run event callbacks
        Forever

    Note that you'll only notice a speed difference here if "p_DrawFrame()"
    executes many lines of Hollywood code. If "p_DrawFrame()" only consists of
    20 lines of code, you won't notice any difference. It's only noticeable with
    hundreds of code lines or long loops.

    See the documentation of "DisableLineHook()" and "EnableLineHook()" in the
    Hollywood manual for more information.

@ENDNODE

@NODE ModeSwitch "GL Galore Guide"
@{b}Handling mode switches@{ub}

    As you might know, Hollywood offers a hotkey to switch between windowed and
    fullscreen mode. Whenever the user presses ALT+RETURN or COMMAND+RETURN
    Hollywood will automatically switch modes between windowed and fullscreen.
    This behaviour is enabled by default. It can be disabled by setting the
    "ModeTag" to FALSE in the "\@DISPLAY" preprocessor command.

    When using Hollywood's inbuilt display driver, mode switches are handled
    automatically by Hollywood and there is nothing your script needs to do.
    This is different with GL Galore. With GL Galore you will have to
    reinitialize your GL context after a mode switch. This is necessary because
    the old GL context will be destroyed when Hollywood switches modes. Thus,
    all current GL states will be lost in a mode switch. This also includes
    textures and display lists that your script has allocated. After a mode
    switch your script's GL context will be replaced by a vanilla GL context
    that is identical to the one your script is started with.

    In order to support mode switches with GL Galore, you have to install a
    listener on the "ModeSwitch" tag using "InstallEventHandler()". Whenever
    this event handler triggers, you will have to reinitialize your GL context
    and set all states to the desired values. Normally, you just have to run
    your initialization code, that sets up your GL context at the beginning of
    the script, again whenever the "ModeSwitch" event triggers. If this is too
    much hassle for you, you can also just disable automatic mode switching.

    Please note that it's not necessary to handle mode switches manually in case
    you're not using the OpenGL API directly. Hardware brushes allocated by GL
    Galore will be automatically transferred to the new GL context by GL Galore
    so you don't have to do anything about them. It is only necessary when
    programming OpenGL directly.

@ENDNODE

@NODE OpenGLGlue "GL Galore Guide"
@{b}GL Galore as a helper plugin@{ub}

    GL Galore can also be used as a helper plugin to work around the problem
    that Hollywood only supports hardware-accelerated double buffers and brushes
    on AmigaOS and compatibles. They aren't supported on Windows, Mac OS X, or
    Linux. If you install and "\@REQUIRE" GL Galore, however, hardware double
    buffer and hardware brush support will also be available on Windows, Mac OS
    X, and Linux because GL Galore supports this.

    Thus, you can also use GL Galore as a helper plugin just to get
    hardware-accelerated double buffer support on Windows, Mac OS X, and Linux.
    You don't even have to use any of the OpenGL commands directly. You can just
    "\@REQUIRE" GL Galore, set up a hardware double buffer and then draw to it
    using hardware brushes. This allows you to utilize hardware acceleration
    without having to write a single line of OpenGL code!

    On AmigaOS and compatibles this isn't necessary since Hollywood already
    supports hardware accelerated double buffers and brushes by default. Still,
    using GL Galore on AmigaOS as a hardware double buffer driver can be of
    benefit in full screen mode because GL Galore uses drawing which is
    perfectly synchronized with the monitor's vertical refresh so it usually
    looks better than double buffers managed by Hollywood directly.

    See @{"Using a hardware double buffer" LINK HardwareDB} for details.

    See @{"Using hardware brushes" LINK HardwareBrushes} for details.

    The SmoothScroll.hws example script that comes with GL Galore demonstrates
    how to use hardware brushes and a hardware double buffer without any calls
    to OpenGL.

@ENDNODE

@NODE InternalPixelFormats "GL Galore Guide"
@{b}Internal pixel formats@{ub}

    OpenGL commands which create textures, e.g. @{"gl.TexImage2D()" LINK glTexImage2D} or
    @{"gl.CopyTexImage()" LINK glCopyTexImage} accept an "internalFormat" parameter which allows you to
    specify the internal format of the texture. The following format constants
    are currently supported by GL Galore:

        #GL_ALPHA
        #GL_ALPHA4
        #GL_ALPHA8
        #GL_ALPHA12
        #GL_ALPHA16
        #GL_LUMINANCE
        #GL_LUMINANCE4
        #GL_LUMINANCE8
        #GL_LUMINANCE12
        #GL_LUMINANCE16
        #GL_LUMINANCE_ALPHA
        #GL_LUMINANCE4_ALPHA4
        #GL_LUMINANCE6_ALPHA2
        #GL_LUMINANCE8_ALPHA8
        #GL_LUMINANCE12_ALPHA4
        #GL_LUMINANCE12_ALPHA12
        #GL_LUMINANCE16_ALPHA16
        #GL_INTENSITY
        #GL_INTENSITY4
        #GL_INTENSITY8
        #GL_INTENSITY12
        #GL_INTENSITY16
        #GL_RGB
        #GL_R3_G3_B2
        #GL_RGB4
        #GL_RGB5
        #GL_RGB8
        #GL_RGB10
        #GL_RGB12
        #GL_RGB16
        #GL_RGBA
        #GL_RGBA2
        #GL_RGBA4
        #GL_RGB5_A1
        #GL_RGBA8
        #GL_RGB10_A2
        #GL_RGBA12
        #GL_RGBA16
        #GL_DEPTH_COMPONENT

    Note that @{"gl.TexImage1D()" LINK glTexImage1D} and @{"gl.TexImage2D()" LINK glTexImage2D} also accept the special values
    1, 2, 3, and 4 as valid internal pixel formats but @{"gl.CopyTexImage()" LINK glCopyTexImage} doesn't
    support this.

@ENDNODE

@NODE Tutorial "GL Galore Guide"
@{b}OpenGL tutorial@{ub}

    Unfortunately, there is currently no tutorial to get you started with GL
    Galore. The internet, however, is full of beginner's tutorials for OpenGL
    which you can use to get into the engine. Since GL Galore just wraps the
    OpenGL API, it is mostly simple and straightforward to port code written for
    other programming languages to GL Galore. The examples that are shipped with
    GL Galore can also help you to get started with GL Galore.

    Finally, the Hollywood forums are always a good place to ask your question
    if you're stuck programming with GL Galore. Just visit
    http://forums.hollywood-mal.com and ask.

@ENDNODE

@NODE Examples "GL Galore Guide"
@{b}Examples@{ub}

    GL Galore comes with a number of examples that demonstrate certain features
    and should allow you to get started really quickly. Here's a list of
    examples that are distributed with GL Galore:

    BlockTube A swirling, falling tunnel of reflective slabs which fade from hue
              to hue. Original code by Lars Damerow
    Boing     A clone of the first graphics demo for the Amiga 1000, which was
              written by Dale Luck and RJ Mical during a break at the 1984 CES.
              Original code by Jim Brooks
    Cel shading
              Demonstrates cel shading. Original code by Jeff Molofee
    Cityflow  Waves move across a sea of boxes. The city swells. The walls are
              closing in. Original code by Jamie Zawinski
    Cube      The OpenGL equivalent of "Hello World"
    Gears     The classic OpenGL gears demo. Original code by Brian Paul
    Gears 2   A variant of the OpenGL gears demo based on code found in the
              MiniGL SDK
    Gears 3   The OpenGL gears demo, this time with a texture
    GLMatrix  The 3D digital rain effect, as seen in the title sequence of a
              popular movie. Based on code by Jamie Zawinski
    Morph3D   Platonic solids that turn inside out and get spikey. Based on code
              by Marcelo F. Vianna
    MultiDisplays
              Demonstrates how to use multiple displays with GL Galore
    Simple    Simple rotating GL triangle. Based on code by Camilla Berglund
    SmoothScroll
              Uses OpenGL for hardware-accelerated 2D drawing of Hollywood
              brushes
    SplitView Renders four views of the same scene in one window. Based on code
              by Camilla Berglund
    Spots     Demonstrates GL lights. Based on code by Mark J. Kilgard
    Sproingies
              Slinky-like creatures walk down an infinite staircase and
              occasionally explode! Based on code by Ed Mackey
    Warp      Example of what an extreme field of view can do
    Wave      Wave simulation in OpenGL. Based on code by Jakob Thomsen

@ENDNODE

@NODE glAccum "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Accum -- operate on the accumulation buffer

   @{b}SYNOPSIS@{ub}
        gl.Accum(op, value)

   @{b}FUNCTION@{ub}
        The accumulation buffer is an extended-range color buffer. Images are
        not rendered into it. Rather, images rendered into one of the color
        buffers are added to the contents of the accumulation buffer after
        rendering. Effects such as antialiasing (of points, lines, and
        polygons), motion blur, and depth of field can be created by
        accumulating images generated with different transformation matrices.

        Each pixel in the accumulation buffer consists of red, green, blue, and
        alpha values. The number of bits per component in the accumulation
        buffer depends on the implementation. You can examine this number by
        calling @{"gl.Get()" LINK glGet} four times, with arguments #GL_ACCUM_RED_BITS,
        #GL_ACCUM_GREEN_BITS, #GL_ACCUM_BLUE_BITS, and #GL_ACCUM_ALPHA_BITS.
        Regardless of the number of bits per component, the range of values
        stored by each component is -1 through 1. The accumulation buffer
        pixels are mapped one-to-one with frame buffer pixels.

        gl.Accum() operates on the accumulation buffer. The first argument,
        "op", is a symbolic constant that selects an accumulation buffer
        operation. The second argument, "value", is a floating-point value to be
        used in that operation. Five operations are specified: #GL_ACCUM,
        #GL_LOAD, #GL_ADD, #GL_MULT, and #GL_RETURN.

        All accumulation buffer operations are limited to the area of the
        current scissor box and applied identically to the red, green, blue, and
        alpha components of each pixel. If a gl.Accum() operation results in a
        value outside the range -1 through 1, the contents of an accumulation
        buffer pixel component are undefined.

        The operations are as follows:

        #GL_ACCUM Obtains R, G, B, and A values from the buffer currently
                  selected for reading See @{"gl.ReadBuffer" LINK glReadBuffer} for details. (). Each
                  component value is divided by 2^n - 1, where n is the number
                  of bits allocated to each color component in the currently
                  selected buffer. The result is a floating-point value in the
                  range 0 through 1, which is multiplied by value and added to
                  the corresponding pixel component in the accumulation buffer,
                  thereby updating the accumulation buffer.

        #GL_LOAD  Similar to #GL_ACCUM, except that the current value in the
                  accumulation buffer is not used in the calculation of the new
                  value. That is, the R, G, B, and A values from the currently
                  selected buffer are divided by 2^n - 1, multiplied by value,
                  and then stored in the corresponding accumulation buffer cell,
                  overwriting the current value.

        #GL_ADD   Adds value to each R, G, B, and A in the accumulation buffer.

        #GL_MULT  Multiplies each R, G, B, and A in the accumulation buffer by
                  value and returns the scaled component to its corresponding
                  accumulation buffer location.

        #GL_RETURN
                  Transfers accumulation buffer values to the color buffer or
                  buffers currently selected for writing. Each R, G, B, and A
                  component is multiplied by value, then multiplied by 2^n - 1,
                  clamped to the range 0 2 n - 1, and stored in the
                  corresponding display buffer cell. The only fragment
                  operations that are applied to this transfer are pixel
                  ownership, scissor, dithering, and color writemasks.

        To clear the accumulation buffer, call @{"gl.ClearAccum()" LINK glClearAccum} with R, G, B, and
        A values to set it to, then call @{"gl.Clear()" LINK glClear} with the accumulation buffer
        enabled.

        Only pixels within the current scissor box are updated by a gl.Accum()
        operation.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        op        specifies the accumulation buffer operation. Symbolic
                  constants #GL_ACCUM, #GL_LOAD, #GL_ADD, #GL_MULT, and
                  #GL_RETURN are accepted
        value     specifies a floating-point value used in the accumulation
                  buffer operation. "op" determines how "value" is used

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if op is not an accepted value.

        #GL_INVALID_OPERATION is generated if there is no accumulation buffer.

        #GL_INVALID_OPERATION is generated if gl.Accum() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_RED_BITS

        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_GREEN_BITS

        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_BLUE_BITS

        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_ALPHA_BITS

@ENDNODE

@NODE glAlphaFunc "GL Galore Guide"

   @{b}NAME@{ub}
        gl.AlphaFunc -- specify the alpha test function

   @{b}SYNOPSIS@{ub}
        gl.AlphaFunc(func, ref)

   @{b}FUNCTION@{ub}
        The alpha test discards fragments depending on the outcome of a
        comparison between an incoming fragment's alpha value and a constant
        reference value. gl.AlphaFunc() specifies the reference value and the
        comparison function. The comparison is performed only if alpha testing
        is enabled. By default, it is not enabled. (See @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} of #GL_ALPHA_TEST.)

        "func" and "ref" specify the conditions under which the pixel is drawn.
        The incoming alpha value is compared to "ref" using the function
        specified by "func". If the value passes the comparison, the incoming
        fragment is drawn if it also passes subsequent stencil and depth buffer
        tests. If the value fails the comparison, no change is made to the frame
        buffer at that pixel location. The comparison functions are as follows:

        #GL_NEVER Never passes.

        #GL_LESS  Passes if the incoming alpha value is less than the reference
                  value.

        #GL_EQUAL Passes if the incoming alpha value is equal to the reference
                  value.

        #GL_LEQUAL
                  Passes if the incoming alpha value is less than or equal to
                  the reference value.

        #GL_GREATER
                  Passes if the incoming alpha value is greater than the
                  reference value.

        #GL_NOTEQUAL
                  Passes if the incoming alpha value is not equal to the
                  reference value.

        #GL_GEQUAL
                  Passes if the incoming alpha value is greater than or equal to
                  the reference value.

        #GL_ALWAYS
                  Always passes (initial value).

        gl.AlphaFunc() operates on all pixel write operations, including those
        resulting from the scan conversion of points, lines, polygons, and
        bitmaps, and from pixel draw and copy operations. gl.AlphaFunc() does
        not affect screen clear operations.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        func      specifies the alpha comparison function (see above)
        ref       specifies the reference value that incoming alpha values are
                  compared to. This value is clamped to the range 0 through 1,
                  where 0 represents the lowest possible alpha value and 1 the
                  highest possible value (the initial reference value is 0)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "func" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.AlphaFunc() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ALPHA_TEST_FUNC

        @{"gl.Get()" LINK glGet} with argument #GL_ALPHA_TEST_REF

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_ALPHA_TEST

@ENDNODE

@NODE glAreTexturesResident "GL Galore Guide"

   @{b}NAME@{ub}
        gl.AreTexturesResident -- determine if textures are loaded in texture memory

   @{b}SYNOPSIS@{ub}
        residencesArray = gl.AreTexturesResident(texturesArray)

   @{b}FUNCTION@{ub}
        GL establishes a working set of textures that are resident in texture
        memory. These textures can be bound to a texture target much more
        efficiently than textures that are not resident.

        gl.AreTexturesResident() queries the texture residence status of the n
        textures named by the elements of "texturesArray" and returns their
        status in the table "residencesArray".

        The residence status of a single bound texture may also be queried by
        calling @{"gl.GetTexParameter()" LINK glGetTexParameter} with the target argument set to the target
        to which the texture is bound, and the "pname" argument set to
        #GL_TEXTURE_RESIDENT. This is the only way that the residence status of
        a default texture can be queried.

        gl.AreTexturesResident() returns the residency status of the textures at
        the time of invocation. It does not guarantee that the textures will
        remain resident at any other time.

        If textures reside in virtual memory (there is no texture memory), they
        are considered always resident.

        Some implementations may not load a texture until the first use of that
        texture.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        texturesArray
                  specifies an array containing the names of the textures to be
                  queried

   @{b}RESULTS@{ub}
        residencesArray
                  an array in which the texture residence status is returned

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if any element in "texturesArray" is 0 or
        does not name a texture. In that case, the function returns Nil.

        #GL_INVALID_OPERATION is generated if gl.AreTexturesResident() is
        executed between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding
        execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexParameter()" LINK glGetTexParameter} with parameter name #GL_TEXTURE_RESIDENT retrieves
        the residence status of a currently bound texture.

@ENDNODE

@NODE glArrayElement "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ArrayElement -- render a vertex using the specified vertex array element

   @{b}SYNOPSIS@{ub}
        gl.ArrayElement(i)

   @{b}FUNCTION@{ub}
        gl.ArrayElement() commands are used within @{"gl.Begin()" LINK glBegin} / @{"gl.End()" LINK glEnd} pairs
        to specify vertex and attribute data for point, line, and polygon
        primitives. If #GL_VERTEX_ARRAY is enabled when gl.ArrayElement() is
        called, a single vertex is drawn, using vertex and attribute data taken
        from location "i" of the enabled arrays. If #GL_VERTEX_ARRAY is not
        enabled, no drawing occurs but the attributes corresponding to the
        enabled arrays are modified.

        Use gl.ArrayElement() to construct primitives by indexing vertex data,
        rather than by streaming through arrays of data in first-to-last order.
        Because each call specifies only a single vertex, it is possible to
        explicitly specify per-primitive attributes such as a single normal for
        each triangle.

        Changes made to array data between the execution of @{"gl.Begin()" LINK glBegin} and the
        corresponding execution of @{"gl.End()" LINK glEnd} may affect calls to
        gl.ArrayElement() that are made within the same @{"gl.Begin()" LINK glBegin} / @{"gl.End()" LINK glEnd}
        period in nonsequential ways. That is, a call to gl.ArrayElement() that
        precedes a change to array data may access the changed data, and a call
        that follows a change to array data may access original data.

        gl.ArrayElement() is included in display lists. If gl.ArrayElement() is
        entered into a display list, the necessary array data (determined by the
        array pointers and enables) is also entered into the display list.
        Because the array pointers and enables are client-side state, their
        values affect display lists when the lists are created, not when the
        lists are executed.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        i         specifies an index into the enabled vertex data arrays

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE may be generated if "i" is negative.

        #GL_INVALID_OPERATION is generated if a non-zero buffer object name is
        bound to an enabled array and the buffer object's data store is
        currently mapped.

@ENDNODE

@NODE glBegin "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Begin -- delimit the vertices of a primitive or a group of like primitives

   @{b}SYNOPSIS@{ub}
        gl.Begin(mode)

   @{b}FUNCTION@{ub}
        gl.Begin() and @{"gl.End()" LINK glEnd} delimit the vertices that define a primitive or
        a group of like primitives. gl.Begin() accepts a single argument that
        specifies in which of ten ways the vertices are interpreted. Taking n as
        an integer count starting at one, and N as the total number of vertices
        specified, the interpretations are as follows:

        #GL_POINTS
                  Treats each vertex as a single point. Vertex n defines point
                  n. N points are drawn.

        #GL_LINES Treats each pair of vertices as an independent line segment.
                  Vertices 2^n - 1 and 2^n define line n. N/2 lines are drawn.

        #GL_LINE_STRIP
                  Draws a connected group of line segments from the first vertex
                  to the last. Vertices n and n + 1 define line n. N - 1 lines
                  are drawn.

        #GL_LINE_LOOP
                  Draws a connected group of line segments from the first vertex
                  to the last, then back to the first. Vertices n and n + 1
                  define line n. The last line, however, is defined by vertices
                  N and 1. N lines are drawn.

        #GL_TRIANGLES
                  Treats each triplet of vertices as an independent triangle.
                  Vertices 3^n - 2, 3^n - 1, and 3^n define triangle n. N/3
                  triangles are drawn.

        #GL_TRIANGLE_STRIP
                  Draws a connected group of triangles. One triangle is defined
                  for each vertex presented after the first two vertices. For
                  odd n, vertices n, n + 1, and n + 2 define triangle n. For
                  even n, vertices n + 1, n, and n + 2 define triangle n. N - 2
                  triangles are drawn.

        #GL_TRIANGLE_FAN
                  Draws a connected group of triangles. One triangle is defined
                  for each vertex presented after the first two vertices.
                  Vertices 1, n + 1, and n + 2 define triangle n. N - 2
                  triangles are drawn.

        #GL_QUADS Treats each group of four vertices as an independent
                  quadrilateral. Vertices 4^n - 3, 4^n - 2, 4^n - 1, and 4^n
                  define quadrilateral n. N/4 quadrilaterals are drawn.

        #GL_QUAD_STRIP
                  Draws a connected group of quadrilaterals. One quadrilateral
                  is defined for each pair of vertices presented after the first
                  pair. Vertices 2^n - 1, 2^n, 2^n + 2, and 2^n + 1 define
                  quadrilateral n. N/2 - 1 quadrilaterals are drawn. Note that
                  the order in which vertices are used to construct a
                  quadrilateral from strip data is different from that used with
                  independent data.

        #GL_POLYGON
                  Draws a single, convex polygon. Vertices 1 through N define
                  this polygon.

        Only a subset of GL commands can be used between gl.Begin() and @{"gl.End()" LINK glEnd}.
        The commands are @{"gl.Vertex()" LINK glVertex}, @{"gl.Color()" LINK glColor}, @{"gl.Index()" LINK glIndex}, @{"gl.Normal()" LINK glNormal},
        @{"gl.TexCoord()" LINK glTexCoord}, and @{"gl.Material()" LINK glMaterial}, @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalPoint()" LINK glEvalPoint},
        @{"gl.EdgeFlag()" LINK glEdgeFlag}, and @{"gl.ArrayElement()" LINK glArrayElement}. Also, it is acceptable to use
        @{"gl.CallList()" LINK glCallList} or @{"gl.CallLists()" LINK glCallLists} to execute display lists that include
        only the preceding commands. If any other GL command is executed between
        gl.Begin() and @{"gl.End()" LINK glEnd}, the error flag is set and the command is
        ignored.

        Regardless of the value chosen for mode, there is no limit to the number
        of vertices that can be defined between gl.Begin() and @{"gl.End()" LINK glEnd}. Lines,
        triangles, quadrilaterals, and polygons that are incompletely specified
        are not drawn. Incomplete specification results when either too few
        vertices are provided to specify even a single primitive or when an
        incorrect multiple of vertices is specified. The incomplete primitive is
        ignored; the rest are drawn.

        The minimum specification of vertices for each primitive is as follows:
        1 for a point, 2 for a line, 3 for a triangle, 4 for a quadrilateral,
        and 3 for a polygon. Modes that require a certain multiple of vertices
        are #GL_LINES (2), #GL_TRIANGLES (3), #GL_QUADS (4), and #GL_QUAD_STRIP
        (2).

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies the primitive or primitives that will be created
                  from vertices presented between gl.Begin() and the subsequent
                  gl.End() (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is set to an unaccepted value.

        #GL_INVALID_OPERATION is generated if gl.Begin() is executed between a
        gl.Begin() and the corresponding execution of @{"gl.End()" LINK glEnd}.

        #GL_INVALID_OPERATION is generated if @{"gl.End()" LINK glEnd} is executed without being
        preceded by a glBegin.

        #GL_INVALID_OPERATION is generated if an unsupported command is executed
        between the execution of gl.Begin() and the corresponding execution
        @{"gl.End()" LINK glEnd}. See your OpenGL reference manual for commands that can be
        executed between gl.Begin() and @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glBindTexture "GL Galore Guide"

   @{b}NAME@{ub}
        gl.BindTexture -- bind a named texture to a texturing target

   @{b}SYNOPSIS@{ub}
        gl.BindTexture(target, texture)

   @{b}FUNCTION@{ub}
        gl.BindTexture() lets you create or use a named texture. Calling
        gl.BindTexture() with target set to #GL_TEXTURE_1D or #GL_TEXTURE_2D and
        texture set to the name of the new texture binds the texture name to the
        target. When a texture is bound to a target, the previous binding for
        that target is automatically broken.

        Texture names are unsigned integers. The value zero is reserved to
        represent the default texture for each texture target. Texture names and
        the corresponding texture contents are local to the shared display-list
        space of the current GL rendering context; two rendering contexts share
        texture names only if they also share display lists.

        You may use @{"gl.GenTextures()" LINK glGenTextures} to generate a set of new texture names.

        When a texture is first bound, it assumes the specified target: A
        texture first bound to #GL_TEXTURE_1D becomes one-dimensional texture, a
        texture first bound to #GL_TEXTURE_2D becomes two-dimensional texture.
        The state of a one-dimensional texture immediately after it is first
        bound is equivalent to the state of the default #GL_TEXTURE_1D at GL
        initialization, and similarly for two-dimensional textures.

        While a texture is bound, GL operations on the target to which it is
        bound affect the bound texture, and queries of the target to which it is
        bound return state from the bound texture. If texture mapping is active
        on the target to which a texture is bound, the bound texture is used. In
        effect, the texture targets become aliases for the textures currently
        bound to them, and the texture name zero refers to the default textures
        that were bound to them at initialization.

        A texture binding created with gl.BindTexture() remains active until a
        different texture is bound to the same target, or until the bound
        texture is deleted with @{"gl.DeleteTextures()" LINK glDeleteTextures}.

        Once created, a named texture may be re-bound to its same original
        target as often as needed. It is usually much faster to use
        gl.BindTexture() to bind an existing named texture to one of the texture
        targets than it is to reload the texture image using @{"gl.TexImage1D()" LINK glTexImage1D} or
        @{"gl.TexImage2D()" LINK glTexImage2D}. For additional control over performance, use
        @{"gl.PrioritizeTextures()" LINK glPrioritizeTextures}.

        gl.BindTexture() is included in display lists.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies the target to which the texture is bound. Must be
                  either #GL_TEXTURE_1D or #GL_TEXTURE_2D
        texture   specifies the name of a texture

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target" is not one of the allowable
        values.

        #GL_INVALID_OPERATION is generated if texture was previously created
        with a target that doesn't match that of "target".

        #GL_INVALID_OPERATION is generated if gl.BindTexture() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_BINDING_1D

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_BINDING_2D

@ENDNODE

@NODE glBitmap "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Bitmap -- draw a bitmap

   @{b}SYNOPSIS@{ub}
        gl.Bitmap(xorig, yorig, xmove, ymove[, bitmapArray])

   @{b}FUNCTION@{ub}
        A bitmap is a binary image. When drawn, the bitmap is positioned
        relative to the current raster position, and frame buffer pixels
        corresponding to 1's in the bitmap are written using the current raster
        color or index. Frame buffer pixels corresponding to 0's in the bitmap
        are not modified.

        gl.Bitmap() takes up to five arguments. The first pair specifies the
        location of the bitmap origin relative to the lower left corner of the
        bitmap image. The second pair of arguments specifies x and y offsets to
        be added to the current raster position after the bitmap has been drawn.
        The final argument is a table containing pixel data of the bitmap image
        itself.

        The bitmap image is interpreted like image data for the @{"gl.DrawPixels()" LINK glDrawPixels}
        command, with the bitmap's width and height corresponding to the width
        and height arguments of that command, and with type set to "GL_BITMAP"
        and format set to "GL_COLOR_INDEX". Modes specified using
        @{"gl.PixelStore()" LINK glPixelStore} affect the interpretation of bitmap image data; modes
        specified using @{"gl.PixelTransfer()" LINK glPixelTransfer} do not.

        If the current raster position is invalid, gl.Bitmap() is ignored.
        Otherwise, the lower left corner of the bitmap image is positioned at
        the window coordinates xw = xr - xo and yw = yr - yo where (xr,yr) is
        the raster position and (xo,yo) is the bitmap origin. Fragments are then
        generated for each pixel corresponding to a 1 (one) in the bitmap image.
        These fragments are generated using the current raster z coordinate,
        color or color index, and current raster texture coordinates. They are
        then treated just as if they had been generated by a point, line, or
        polygon, including texture mapping, fogging, and all per-fragment
        operations such as alpha and depth testing.

        After the bitmap has been drawn, the x and y coordinates of the current
        raster position are offset by "xmove" and "ymove". No change is made to
        the z coordinate of the current raster position, or to the current
        raster color, texture coordinates, or index.

        To set a valid raster position outside the viewport, first set a valid
        raster position inside the viewport, then call gl.Bitmap() without the
        bitmap parameter and with "xmove" and "ymove" set to the offsets of the
        new raster position. This technique is useful when panning an image
        around the viewport.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        xorig     specify the location of the x origin in the bitmap image. The
                  origin is measured from the lower left corner of the bitmap,
                  with right and up being the positive axes.
        yorig     specify the location of the y origin in the bitmap image. The
                  origin is measured from the lower left corner of the bitmap,
                  with right and up being the positive axes.
        xmove     specify the x offset to be added to the current raster
                  position after the bitmap is drawn
        ymove     specify the y offset to be added to the current raster
                  position after the bitmap is drawn
        bitmapArray
                  optional: table containing bitmap data

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if glBitmap is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_SECONDARY_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_DISTANCE

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_INDEX

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_TEXTURE_COORDS

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION_VALID

@ENDNODE

@NODE glBlendFunc "GL Galore Guide"

   @{b}NAME@{ub}
        gl.BlendFunc -- specify pixel arithmetic

   @{b}SYNOPSIS@{ub}
        gl.BlendFunc(sfactor, dfactor)

   @{b}FUNCTION@{ub}
        In RGBA mode, pixels can be drawn using a function that blends the
        incoming (source) RGBA values with the RGBA values that are already in
        the frame buffer (the destination values). Blending is initially
        disabled. Use @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with argument #GL_BLEND to
        enable and disable blending.

        gl.BlendFunc() defines the operation of blending when it is enabled.
        "sfactor" specifies which of nine methods is used to scale the source
        color components. "dfactor" specifies which of eight methods is used to
        scale the destination color components. The eleven possible methods are
        described in the following table. Each method defines four scale
        factors, one each for red, green, blue, and alpha.

        In the table and in subsequent equations, source and destination color
        components are referred to as (Rs, Gs, Bs, As) and (Rd, Gd, Bd, Ad).
        They are understood to have integer values between 0 and (kR, kG, kB,
        kA), where

            kc = 2^mc - 1

        and (mR, mG, mB, mA) is the number of red, green, blue, and alpha
        bitplanes.

        Source and destination scale factors are referred to as (sR, sG, sB, sA)
        and (dR, dG, dB, dA). The scale factors described in the table, denoted
        (fR, fG, fB, fA), represent either source or destination factors. All
        scale factors have range [0,1].

            Parameter               |                (fR, fG, fB, fA)
            ---------------------------------------------------------------------
            #GL_ZERO                |                 (0, 0, 0, 0)
            #GL_ONE                 |                 (1, 1, 1, 1)
            #GL_SRC_COLOR           |          (Rs/kR, Gs/kG, Bs/kB, As/kA)
            #GL_ONE_MINUS_SRC_COLOR | (1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)
            #GL_DST_COLOR           |         (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
            #GL_ONE_MINUS_DST_COLOR | (1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
            #GL_SRC_ALPHA           |         (As/kA, As/kA, As/kA, As/kA)
            #GL_ONE_MINUS_SRC_ALPHA | (1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)
            #GL_DST_ALPHA           |         (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
            #GL_ONE_MINUS_DST_ALPHA | (1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
            #GL_SRC_ALPHA_SATURATE  |                 (i, i, i, 1)

        In the table,

            i = min(As, kA  - Ad) / kA

        To determine the blended RGBA values of a pixel when drawing in RGBA
        mode, the system uses the following equations:

            Rd = min(kR, Rs sR + Rd dR)
            Gd = min(kG, Gs sG + Gd dG)
            Bd = min(kB, Bs sB + Bd dB)
            Ad = min(kA, As sA + Ad dA)

        Despite the apparent precision of the above equations, blending
        arithmetic is not exactly specified, because blending operates with
        imprecise integer color values. However, a blend factor that should be
        equal to 1 is guaranteed not to modify its multiplicand, and a blend
        factor equal to 0 reduces its multiplicand to 0. For example, when
        "sfactor" is #GL_SRC_ALPHA, "dfactor" is #GL_ONE_MINUS_SRC_ALPHA, and As
        is equal to kA, the equations reduce to simple replacement:

            Rd = Rs
            Gd = Gs
            Bd = Bs
            Ad = As

        Transparency is best implemented using blend function (#GL_SRC_ALPHA,
        #GL_ONE_MINUS_SRC_ALPHA) with primitives sorted from farthest to
        nearest. Note that this transparency calculation does not require the
        presence of alpha bitplanes in the frame buffer. Blend function
        (#GL_SRC_ALPHA, #GL_ONE_MINUS_SRC_ALPHA) is also useful for rendering
        antialiased points and lines in arbitrary order.

        Polygon antialiasing is optimized using blend function
        (#GL_SRC_ALPHA_SATURATE, #GL_ONE) with polygons sorted from nearest to
        farthest. See @{"gl.Enable" LINK glEnable} for information on polygon antialiasing. ( Look
        for #GL_POLYGON_SMOOTH) Destination alpha bitplanes, which must be
        present for this blend function to operate correctly, store the
        accumulated coverage.

        Incoming (source) alpha is correctly thought of as a material opacity,
        ranging from 1.0 (KA), representing complete opacity, to 0.0 (0),
        representing complete transparency.

        When more than one color buffer is enabled for drawing, the GL performs
        blending separately for each enabled buffer, using the contents of that
        buffer for destination color. See @{"gl.DrawBuffer" LINK glDrawBuffer} for details. ()

        Blending affects only RGBA rendering. It is ignored by color index
        renderers.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        sfactor   specifies how the red, green, blue, and alpha source blending
                  factors are computed (see above)
        dfactor   specifies how the red, green, blue, and alpha destination
                  blending factors are computed (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if either "sfactor" or "dfactor" is not an
        accepted value.

        #GL_INVALID_OPERATION is generated if gl.BlendFunc() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_BLEND_SRC

        @{"gl.Get()" LINK glGet} with argument #GL_BLEND_DST

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_BLEND

@ENDNODE

@NODE glCallList "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CallList -- execute a display list

   @{b}SYNOPSIS@{ub}
        gl.CallList(list)

   @{b}FUNCTION@{ub}
        gl.CallList() causes the named display list to be executed. The commands
        saved in the display list are executed in order, just as if they were
        called without using a display list. If list has not been defined as a
        display list, gl.CallList() is ignored.

        gl.CallList() can appear inside a display list. To avoid the possibility
        of infinite recursion resulting from display lists calling one another,
        a limit is placed on the nesting level of display lists during
        display-list execution. This limit is at least 64, and it depends on the
        implementation.

        GL state is not saved and restored across a call to gl.CallList(). Thus,
        changes made to GL state during the execution of a display list remain
        after execution of the display list is completed. Use @{"gl.PushAttrib()" LINK glPushAttrib},
        @{"gl.PopAttrib()" LINK glPopAttrib}, @{"gl.PushMatrix()" LINK glPushMatrix}, and @{"gl.PopMatrix()" LINK glPopMatrix} to preserve GL
        state across gl.CallList() calls.

        Display lists can be executed between a call to glBegin and the
        corresponding call to glEnd, as long as the display list includes only
        commands that are allowed in this interval.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        list      specifies the integer name of the display list to be executed

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MAX_LIST_NESTING

@ENDNODE

@NODE glCallLists "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CallLists -- execute a list of display lists

   @{b}SYNOPSIS@{ub}
        gl.CallLists(listArray)

   @{b}FUNCTION@{ub}
        gl.CallLists() causes each display list in the list of names passed as
        lists to be executed. As a result, the commands saved in each display
        list are executed in order, just as if they were called without using a
        display list. Names of display lists that have not been defined are
        ignored.

        gl.CallLists() provides an efficient means for executing more than one
        display list.

        An additional level of indirection is made available with the
        @{"gl.ListBase()" LINK glListBase} command, which specifies an unsigned offset that is added
        to each display-list name specified in lists before that display list is
        executed.

        gl.CallLists() can appear inside a display list. To avoid the
        possibility of infinite recursion resulting from display lists calling
        one another, a limit is placed on the nesting level of display lists
        during display-list execution. This limit is at least 64, and it depends
        on the implementation.

        GL state is not saved and restored across a call to gl.CallLists().
        Thus, changes made to GL state during the execution of a display list
        remain after execution of the display list is completed. Use
        @{"gl.PushAttrib()" LINK glPushAttrib}, @{"gl.PopAttrib()" LINK glPopAttrib}, @{"gl.PushMatrix()" LINK glPushMatrix}, and @{"gl.PopMatrix()" LINK glPopMatrix}
        to preserve GL state across gl.CallLists() calls.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        listArray specifies an array of name offsets in the display list

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LIST_BASE

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_LIST_NESTING

@ENDNODE

@NODE glClear "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Clear -- clear buffers to preset values

   @{b}SYNOPSIS@{ub}
        gl.Clear(mask)

   @{b}FUNCTION@{ub}
        gl.Clear() sets the bitplane area of the window to values previously
        selected by @{"gl.ClearColor()" LINK glClearColor}, @{"gl.ClearIndex()" LINK glClearIndex}, @{"gl.ClearDepth()" LINK glClearDepth},
        @{"gl.ClearStencil()" LINK glClearStencil}, and @{"gl.ClearAccum()" LINK glClearAccum}. Multiple color buffers can be
        cleared simultaneously by selecting more than one buffer at a time using
        @{"gl.DrawBuffer()" LINK glDrawBuffer}.

        The pixel ownership test, the scissor test, dithering, and the buffer
        writemasks affect the operation of gl.Clear(). The scissor box bounds
        the cleared region. Alpha function, blend function, logical operation,
        stenciling, texture mapping, and depth-buffering are ignored by
        gl.Clear().

        gl.Clear() takes a single argument that is the bitwise OR of several
        values indicating which buffer is to be cleared.

        The values are as follows:

        #GL_COLOR_BUFFER_BIT
                  Indicates the buffers currently enabled for color writing.

        #GL_DEPTH_BUFFER_BIT
                  Indicates the depth buffer.

        #GL_ACCUM_BUFFER_BIT
                  Indicates the accumulation buffer.

        #GL_STENCIL_BUFFER_BIT
                  Indicates the stencil buffer.

        The value to which each buffer is cleared depends on the setting of the
        clear value for that buffer.

        If a buffer is not present, then a gl.Clear() directed at that buffer
        has no effect.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mask      bitwise OR of masks that indicate the buffers to be cleared.
                  The four masks are #GL_COLOR_BUFFER_BIT, #GL_DEPTH_BUFFER_BIT,
                  #GL_ACCUM_BUFFER_BIT, and #GL_STENCIL_BUFFER_BIT

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if any bit other than the four defined
        bits is set in mask.

        #GL_INVALID_OPERATION is generated if gl.Clear() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_STENCIL_CLEAR_VALUE

@ENDNODE

@NODE glClearAccum "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClearAccum -- specify clear values for the accumulation buffer

   @{b}SYNOPSIS@{ub}
        gl.ClearAccum(red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        gl.ClearAccum() specifies the red, green, blue, and alpha values used by
        @{"gl.Clear()" LINK glClear} to clear the accumulation buffer.

        Values specified by gl.ClearAccum() are clamped to the range -1 through
        1.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        red       specify the red value used when the accumulation buffer is
                  cleared; the initial value is 0
        green     specify the green value used when the accumulation buffer is
                  cleared; the initial value is 0
        blue      specify the blue value used when the accumulation buffer is
                  cleared; the initial value is 0
        alpha     specify the alpha value used when the accumulation buffer is
                  cleared; the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ClearAccum() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ACCUM_CLEAR_VALUE

@ENDNODE

@NODE glClearColor "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClearColor -- specify clear values for the color buffers

   @{b}SYNOPSIS@{ub}
        gl.ClearColor(red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        gl.ClearColor() specifies the red, green, blue, and alpha values used by
        @{"gl.Clear()" LINK glClear} to clear the color buffers. Values specified by
        gl.ClearColor() are clamped to the range 0 through 1.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        red       specify the red value used when the color buffers are cleared;
                  the initial value is 0
        green     specify the green value used when the color buffers are
                  cleared; the initial value is 0
        blue      specify the blue value used when the color buffers are
                  cleared; the initial value is 0
        alpha     specify the alpha value used when the color buffers are
                  cleared; the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ClearColor() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_CLEAR_VALUE

@ENDNODE

@NODE glClearDepth "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClearDepth -- specify the clear value for the depth buffer

   @{b}SYNOPSIS@{ub}
        gl.ClearDepth(depth)

   @{b}FUNCTION@{ub}
        gl.ClearDepth() specifies the depth value used by @{"gl.Clear()" LINK glClear} to clear
        the depth buffer. Values specified by gl.ClearDepth() are clamped to the
        range 0 through 1.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        depth     specifies the depth value used when the depth buffer is
                  cleared; the initial value is 1

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ClearDepth() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_CLEAR_VALUE

@ENDNODE

@NODE glClearIndex "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClearIndex -- specify the clear value for the color index buffers

   @{b}SYNOPSIS@{ub}
        gl.ClearIndex(c)

   @{b}FUNCTION@{ub}
        gl.ClearIndex() specifies the index used by @{"gl.Clear()" LINK glClear} to clear the
        color index buffers. "c" is not clamped. Rather, "c" is converted to a
        fixed-point value with unspecified precision to the right of the binary
        point. The integer part of this value is then masked with 2^m-1, where
        m is the number of bits in a color index stored in the frame buffer.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        c         specifies the index used when the color index buffers are
                  cleared; the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ClearIndex() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_BITS

@ENDNODE

@NODE glClearStencil "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClearStencil -- specify the clear value for the stencil buffer

   @{b}SYNOPSIS@{ub}
        gl.ClearStencil(s)

   @{b}FUNCTION@{ub}
        gl.ClearStencil() specifies the index used by @{"gl.Clear()" LINK glClear} to clear the
        stencil buffer. "s" is masked with 2^m-1, where m is the number of bits
        in the stencil buffer.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        s         specifies the index used when the stencil buffer is cleared;
                  the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ClearStencil() is executed
        between the execution of glBegin and the corresponding execution of
        glEnd

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_STENCIL_CLEAR_VALUE

        @{"gl.Get()" LINK glGet} with argument #GL_STENCIL_BITS

@ENDNODE

@NODE glClipPlane "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ClipPlane -- specify a plane against which all geometry is clipped

   @{b}SYNOPSIS@{ub}
        gl.ClipPlane(plane, equationArray)

   @{b}FUNCTION@{ub}
        Geometry is always clipped against the boundaries of a six-plane frustum
        in x, y, and z. gl.ClipPlane() allows the specification of additional
        planes, not necessarily perpendicular to the x, y, or z axis, against
        which all geometry is clipped. To determine the maximum number of
        additional clipping planes, call @{"gl.Get()" LINK glGet} with argument
        #GL_MAX_CLIP_PLANES. All implementations support at least six such
        clipping planes. Because the resulting clipping region is the
        intersection of the defined half-spaces, it is always convex.

        gl.ClipPlane() specifies a half-space using a four-component plane
        equation. When gl.ClipPlane() is called, equation is transformed by the
        inverse of the modelview matrix and stored in the resulting eye
        coordinates. Subsequent changes to the modelview matrix have no effect
        on the stored plane-equation components. If the dot product of the eye
        coordinates of a vertex with the stored plane equation components is
        positive or zero, the vertex is in with respect to that clipping plane.
        Otherwise, it is out.

        To enable and disable clipping planes, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable}
        with the argument #GL_CLIP_PLANEi, where i is the plane number.

        All clipping planes are initially defined as (0, 0, 0, 0) in eye
        coordinates and are disabled.

        It is always the case that #GL_CLIP_PLANEi = #GL_CLIP_PLANE0 + i.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        plane     specifies which clipping plane is being positioned; symbolic
                  names of the form #GL_CLIP_PLANEi, where i is an integer
                  between 0 and #GL_MAX_CLIP_PLANES -1, are accepted
        equationArray
                  specifies an array of four double-precision floating-point
                  values; these values are interpreted as a plane equation

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if plane is not an accepted value

        #GL_INVALID_OPERATION is generated if gl.ClipPlane() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetClipPlane()" LINK glGetClipPlane}

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_CLIP_PLANEi

@ENDNODE

@NODE glColor "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Color -- set the current color

   @{b}SYNOPSIS@{ub}
        gl.Color(red, green, blue[, alpha])

   @{b}FUNCTION@{ub}
        The GL stores both a current single-valued color index and a current
        four-valued RGBA color. gl.Color() sets a new four-valued RGBA color. If
        the optional alpha argument is omitted, it will be set to 1.0.

        Current color values are stored in floating-point format such that the
        largest representable value maps to 1.0 (full intensity), and 0 maps to
        0.0 (zero intensity).

        Alternatively, you can also pass a table containing three or four
        floating-point values specifying the red, green, blue, and alpha values
        for the color.

        The initial value for the current color is (1, 1, 1, 1).

        The current color can be updated at any time. In particular, gl.Color()
        can be called between a call to @{"gl.Begin()" LINK glBegin} and the corresponding call to
        @{"gl.End()" LINK glEnd}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        red       specify new red value for the current color
        green     specify new green value for the current color
        blue      specify new blue value for the current color
        alpha     optional: specify new alpha value for the current color
                  (defaults to 1.0)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_RGBA_MODE

@ENDNODE

@NODE glColorMask "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ColorMask -- enable and disable writing of frame buffer color components

   @{b}SYNOPSIS@{ub}
        gl.ColorMask(red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        gl.ColorMask() specifies whether the individual color components in the
        frame buffer can or cannot be written. If red is #GL_FALSE, for example,
        no change is made to the red component of any pixel in any of the color
        buffers, regardless of the drawing operation attempted. The initial
        values are all #GL_TRUE, indicating that the color components can be
        written.

        Changes to individual bits of components cannot be controlled. Rather,
        changes are either enabled or disabled for entire color components.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        red       specify whether red can or cannot be written into the frame
                  buffer
        green     specify whether green can or cannot be written into the frame
                  buffer
        blue      specify whether blue can or cannot be written into the frame
                  buffer
        alpha     specify whether alpha can or cannot be written into the frame
                  buffer

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ColorMask() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_WRITEMASK

        @{"gl.Get()" LINK glGet} with argument #GL_RGBA_MODE

@ENDNODE

@NODE glColorMaterial "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ColorMaterial -- cause a material color to track the current color

   @{b}SYNOPSIS@{ub}
        gl.ColorMaterial(face, mode)

   @{b}FUNCTION@{ub}
        gl.ColorMaterial() specifies which material parameters track the current
        color. When #GL_COLOR_MATERIAL is enabled, the material parameter or
        parameters specified by "mode", of the material or materials specified
        by "face", track the current color at all times. "face" can be set to
        #GL_FRONT, #GL_BACK, or #GL_FRONT_AND_BACK. The initial value is
        #GL_FRONT_AND_BACK.

        The following values can be passed in the "mode" parameter:
        #GL_EMISSION, #GL_AMBIENT, #GL_DIFFUSE, #GL_SPECULAR, and
        #GL_AMBIENT_AND_DIFFUSE. The initial value is #GL_AMBIENT_AND_DIFFUSE.

        To enable and disable #GL_COLOR_MATERIAL, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_COLOR_MATERIAL. #GL_COLOR_MATERIAL is
        initially disabled.

        gl.ColorMaterial() makes it possible to change a subset of material
        parameters for each vertex using only the @{"gl.Color()" LINK glColor} command, without
        calling @{"gl.Material()" LINK glMaterial}. If only such a subset of parameters is to be
        specified for each vertex, calling gl.ColorMaterial() is preferable to
        calling @{"gl.Material()" LINK glMaterial}.

        Call gl.ColorMaterial() before enabling #GL_COLOR_MATERIAL.

        Calling @{"gl.DrawElements()" LINK glDrawElements} or @{"gl.DrawArrays()" LINK glDrawArrays} may leave the current color
        indeterminate, if the color array is enabled. If gl.ColorMaterial() is
        enabled while the current color is indeterminate, the lighting material
        state specified by face and mode is also indeterminate.

        If the GL version is 1.1 or greater, and #GL_COLOR_MATERIAL is enabled,
        evaluated color values affect the results of the lighting equation as if
        the current color were being modified, but no change is made to the
        tracking lighting parameter of the current color.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        face      specifies whether front, back, or both front and back material
                  parameters should track the current color
        mode      specifies which of several material parameters track the
                  current color (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if face or mode is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.ColorMaterial() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_COLOR_MATERIAL

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_MATERIAL_PARAMETER

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_MATERIAL_FACE

@ENDNODE

@NODE glColorPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ColorPointer -- define an array of colors

   @{b}SYNOPSIS@{ub}
        gl.ColorPointer(colorArray[, size])

   @{b}FUNCTION@{ub}
        gl.ColorPointer() specifies an array of color components to use when
        rendering. "colorArray" can be either a one-dimensional table consisting
        of an arbitrary number of consecutive color values or a two-dimensional
        table consisting of an arbitrary number of subtables which contain 3 or
        4 color values each. If "colorArray" is a one-dimensional table, you
        need to pass the optional "size" argument as well to define the size of
        each color component in "colorArray". "size" must be either 3 or 4. If
        "colorArray" is a two-dimensional table, "size" is automatically
        determined by the number of items in the first subtable, which must be
        either three or four as well.

        When using a two-dimensional table, please keep in mind that the number
        of color values in each subtable must be constant. It is not allowed to
        use differing numbers of color values in the individual subtables. The
        number of color values is defined by the number of elements in the first
        subtable and all following subtables must use the very same number of
        color values.

        If you pass Nil in "colorArray", the color array buffer will be freed
        but it won't be removed from OpenGL. You need to do this manually, e.g.
        by disabling the color array or defining a new one.

        To enable and disable the color array, call @{"gl.EnableClientState()" LINK glEnableClientState} and
        @{"gl.DisableClientState()" LINK glDisableClientState} with the argument #GL_COLOR_ARRAY. If enabled,
        the color array is used when @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or
        @{"gl.ArrayElement()" LINK glArrayElement} is called.

        The color array is initially disabled and isn't accessed when
        @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Execution of gl.ColorPointer() is not allowed between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.ColorPointer() is typically implemented on the client side.

        Color array parameters are client-side state and are therefore not saved
        or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}. Use
        @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        colorArray
                  one- or two-dimensional table containing color values or Nil
                  (see above)
        size      optional: size of each color component; must be either 3 or 4
                  and is only used with
        one       dimensional tables (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if size is not 3 or 4.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_COLOR_ARRAY

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_ARRAY_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_ARRAY_TYPE

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_ARRAY_STRIDE

        @{"gl.Get()" LINK glGet} with argument #GL_COLOR_ARRAY_POINTER

@ENDNODE

@NODE glCopyPixels "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CopyPixels -- copy pixels in the frame buffer

   @{b}SYNOPSIS@{ub}
        gl.CopyPixels(x, y, width, height, type)

   @{b}FUNCTION@{ub}
        gl.CopyPixels() copies a screen-aligned rectangle of pixels from the
        specified frame buffer location to a region relative to the current
        raster position. Its operation is well defined only if the entire pixel
        source region is within the exposed portion of the window. Results of
        copies from outside the window, or from regions of the window that are
        not exposed, are hardware dependent and undefined.

        "x" and "y" specify the window coordinates of the lower left corner of
        the rectangular region to be copied. "width" and "height" specify the
        dimensions of the rectangular region to be copied. Both "width" and
        "height" must not be negative.

        Several parameters control the processing of the pixel data while it is
        being copied. These parameters are set with three commands:
        @{"gl.PixelTransfer()" LINK glPixelTransfer}, @{"gl.PixelMap()" LINK glPixelMap}, and @{"gl.PixelZoom()" LINK glPixelZoom}. This reference
        page describes the effects on gl.CopyPixels() of most, but not all, of
        the parameters specified by these three commands.

        gl.CopyPixels() copies values from each pixel with the lower left-hand
        corner at (x+i,y+j) for 0 <= i < width and 0 <= j < height. This pixel
        is said to be the ith pixel in the jth row. Pixels are copied in row
        order from the lowest to the highest row, left to right in each row.

        "type" specifies whether color, depth, or stencil data is to be copied.
        The details of the transfer for each data type are as follows:

        #GL_COLOR Indices or RGBA colors are read from the buffer currently
                  specified as the read source buffer See @{"gl.ReadBuffer" LINK glReadBuffer} for
                  details. (). If the GL is in color index mode, each index that
                  is read from this buffer is converted to a fixed-point format
                  with an unspecified number of bits to the right of the binary
                  point. Each index is then shifted left by #GL_INDEX_SHIFT
                  bits, and added to #GL_INDEX_OFFSET. If #GL_INDEX_SHIFT is
                  negative, the shift is to the right. In either case, zero bits
                  fill otherwise unspecified bit locations in the result. If
                  #GL_MAP_COLOR is true, the index is replaced with the value
                  that it references in lookup table #GL_PIXEL_MAP_I_TO_I.
                  Whether the lookup replacement of the index is done or not,
                  the integer part of the index is then ANDed with 2^b-1, where
                  b is the number of bits in a color index buffer.

                  If the GL is in RGBA mode, the red, green, blue, and alpha
                  components of each pixel that is read are converted to an
                  internal floating-point format with unspecified precision. The
                  conversion maps the largest representable component value to
                  1.0, and component value 0 to 0.0. The resulting
                  floating-point color values are then multiplied by #GL_c_SCALE
                  and added to #GL_c_BIAS, where c is RED, GREEN, BLUE, and
                  ALPHA for the respective color components. The results are
                  clamped to the range [0,1]. If #GL_MAP_COLOR is true, each
                  color component is scaled by the size of lookup table
                  #GL_PIXEL_MAP_c_TO_c, then replaced by the value that it
                  references in that table. c is R, G, B, or A.

                  If the ARB_imaging extension is supported, the color values
                  may be additionally processed by color-table lookups,
                  color-matrix transformations, and convolution filters.

                  The GL then converts the resulting indices or RGBA colors to
                  fragments by attaching the current raster position z
                  coordinate and texture coordinates to each pixel, then
                  assigning window coordinates (xr+i,yr+j), where (xr,yr) is
                  the current raster position, and the pixel was the ith pixel
                  in the jth row. These pixel fragments are then treated just
                  like the fragments generated by rasterizing points, lines, or
                  polygons. Texture mapping, fog, and all the fragment
                  operations are applied before the fragments are written to the
                  frame buffer.

        #GL_DEPTH Depth values are read from the depth buffer and converted
                  directly to an internal floating-point format with unspecified
                  precision. The resulting floating-point depth value is then
                  multiplied by #GL_DEPTH_SCALE and added to #GL_DEPTH_BIAS. The
                  result is clamped to the range [0,1].

                  The GL then converts the resulting depth components to
                  fragments by attaching the current raster position color or
                  color index and texture coordinates to each pixel, then
                  assigning window coordinates (xr+i,yr+j), where (xr,yr) is the
                  current raster position, and the pixel was the ith pixel in
                  the jth row. These pixel fragments are then treated just like
                  the fragments generated by rasterizing points, lines, or
                  polygons. Texture mapping, fog, and all the fragment
                  operations are applied before the fragments are written to the
                  frame buffer.

        #GL_STENCIL
                  Stencil indices are read from the stencil buffer and converted
                  to an internal fixed-point format with an unspecified number
                  of bits to the right of the binary point. Each fixed-point
                  index is then shifted left by #GL_INDEX_SHIFT bits, and added
                  to #GL_INDEX_OFFSET. If #GL_INDEX_SHIFT is negative, the shift
                  is to the right. In either case, zero bits fill otherwise
                  unspecified bit locations in the result. If #GL_MAP_STENCIL is
                  true, the index is replaced with the value that it references
                  in lookup table #GL_PIXEL_MAP_S_TO_S. Whether the lookup
                  replacement of the index is done or not, the integer part of
                  the index is then ANDed with 2^b-1, where b is the number of
                  bits in the stencil buffer. The resulting stencil indices are
                  then written to the stencil buffer such that the index read
                  from the ith location of the jth row is written to location
                  (xr+i,yr+j), where (xr,yr) is the current raster position.
                  Only the pixel ownership test, the scissor test, and the
                  stencil writemask affect these write operations.

        The rasterization described thus far assumes pixel zoom factors of 1.0.
        If @{"gl.PixelZoom()" LINK glPixelZoom} is used to change the x and y pixel zoom factors,
        pixels are converted to fragments as follows. If (xr,yr) is the current
        raster position, and a given pixel is in the ith location in the jth row
        of the source pixel rectangle, then fragments are generated for pixels
        whose centers are in the rectangle with corners at

            (xr + zoomx_i, yr + zoomy_j)

        and

            (xr + zoomx_(i + 1), yr + zoomy_(j + 1))

        where "zoomx" is the value of #GL_ZOOM_X and "zoomy" is the value of
        #GL_ZOOM_Y.

        Modes specified by @{"gl.PixelStore()" LINK glPixelStore} have no effect on the operation of
        the command gl.CopyPixels().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify the x coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        y         specify the y coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        width     specify the dimensions of the rectangular region of pixels to
                  be copied; both must be nonnegative
        height    specify the dimensions of the rectangular region of pixels to
                  be copied; both must be nonnegative
        type      specifies whether color values, depth values, or stencil
                  values are to be copied; symbolic constants #GL_COLOR,
                  #GL_DEPTH, and #GL_STENCIL are accepted

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if type is not an accepted value.

        #GL_INVALID_VALUE is generated if either width or height is negative.

        #GL_INVALID_OPERATION is generated if type is #GL_DEPTH and there is no
        depth buffer.

        #GL_INVALID_OPERATION is generated if type is #GL_STENCIL and there is
        no stencil buffer.

        #GL_INVALID_OPERATION is generated if gl.CopyPixels() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION_VALID

@ENDNODE

@NODE glCopyTexImage "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CopyTexImage -- copy pixels into a texture image

   @{b}SYNOPSIS@{ub}
        gl.CopyTexImage(level, internalFormat, border, x, y, width[, height])

   @{b}FUNCTION@{ub}
        gl.CopyTexImage() defines a one- or two-dimensional texture image with
        pixels from the current #GL_READ_BUFFER. If the optional "height"
        argument is omitted, a one-dimensional texture will be defined,
        otherwise a two-dimensional texture will be defined.

        The screen-aligned pixel rectangle with lower left corner at (x, y) and
        with a width of width+2*border and a height of height+2*border defines
        the texture array at the mipmap level specified by "level".

        "internalformat" specifies the internal format of the texture array. See
        @{"Internal pixel formats" LINK InternalPixelFormats} for details. Note that in contrast to
        @{"gl.TexImage1D()" LINK glTexImage1D} and @{"gl.TexImage2D()" LINK glTexImage2D} the values 1, 2, 3, and 4 are not
        supported by the "internalFormat" parameter with gl.CopyTexImage().

        The pixels in the rectangle are processed exactly as if @{"gl.CopyPixels()" LINK glCopyPixels}
        had been called, but the process stops just before final conversion. At
        this point all pixel component values are clamped to the range [0,1] and
        then converted to the texture's internal format for storage in the texel
        array.

        Pixel ordering is such that lower x and y screen coordinates correspond
        to lower s and t texture coordinates.

        If any of the pixels within the specified rectangle of the current
        #GL_READ_BUFFER are outside the window associated with the current
        rendering context, then the values obtained for those pixels are
        undefined.

        Texturing has no effect in color index mode.

        An image with height or width of 0 indicates a "NULL" texture.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        level     specifies the level-of-detail number. Level 0 is the base
                  image level. Level n is the nth mipmap reduction image
        internalFormat
                  specifies the internal format of the texture; must be one of
                  the pixel format constants (see above)
        border    specifies the width of the border; must be either 0 or 1
        x         specify the x coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        y         specify the y coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        width     specifies the width of the texture image. Must be 0 or
                  2^n+2*border for some integer n
        height    optional: specifies the height of the texture image. Must be 0
                  or 2^n+2*border for some integer n (defaults to 1)

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "level" is less than 0.

        #GL_INVALID_VALUE may be generated if "level" is greater than log2(max),
        where "max" is the returned value of #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_VALUE is generated if "internalformat" is not an allowable
        value.

        #GL_INVALID_VALUE is generated if "width" is less than 0 or greater than
        2 + #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_VALUE is generated if non-power-of-two textures are not
        supported and the width cannot be represented as 2^n+2*border for some
        integer value of "n".

        #GL_INVALID_VALUE is generated if border is not 0 or 1.

        #GL_INVALID_OPERATION is generated if gl.CopyTexImage() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexImage()" LINK glGetTexImage}

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_TEXTURE_2D or #GL_TEXTURE_1D

@ENDNODE

@NODE glCopyTexSubImage "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CopyTexSubImage -- copy a two-dimensional texture subimage

   @{b}SYNOPSIS@{ub}
        gl.CopyTexSubImage(level, x, y, xoffset, width[, yoffset, height])

   @{b}FUNCTION@{ub}
        gl.CopyTexSubImage() replaces a rectangular portion of a one- or
        two-dimensional texture image with pixels from the current
        #GL_READ_BUFFER (rather than from main memory, as is the case for
        @{"gl.TexSubImage2D()" LINK glTexSubImage2D}). If the last two arguments are omitted, a
        rectangular portion of a one-dimension texture image is replaced,
        otherwise a two-dimensional texture image is the target.

        The screen-aligned pixel rectangle with lower left corner at (x,y) and
        with width "width" and height "height" replaces the portion of the
        texture array with "x" indices "xoffset" through "xoffset" + "width" -
        1, inclusive, and "y" indices "yoffset" through "yoffset" + "height" -
        1, inclusive, at the mipmap level specified by "level".

        The pixels in the rectangle are processed exactly as if @{"gl.CopyPixels()" LINK glCopyPixels}
        had been called, but the process stops just before final conversion. At
        this point, all pixel component values are clamped to the range [0,1]
        and then converted to the texture's internal format for storage in the
        texel array.

        The destination rectangle in the texture array may not include any
        texels outside the texture array as it was originally specified. It is
        not an error to specify a subtexture with zero width or height, but such
        a specification has no effect.

        If any of the pixels within the specified rectangle of the current
        #GL_READ_BUFFER are outside the read window associated with the current
        rendering context, then the values obtained for those pixels are
        undefined.

        No change is made to the "internalformat", "width", "height", or
        "border" parameters of the specified texture array or to texel values
        outside the specified subregion.

        Texturing has no effect in color index mode.

        @{"gl.PixelStore()" LINK glPixelStore} and @{"gl.PixelTransfer()" LINK glPixelTransfer} modes affect texture images in
        exactly the way they affect @{"gl.DrawPixels()" LINK glDrawPixels}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        level     specifies the level-of-detail number; level 0 is the base
                  image level; level n is the nth mipmap reduction image
        x         specify the x coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        y         specify the y coordinate of the lower left corner of the
                  rectangular region of pixels to be copied
        xoffset   specifies a texel offset in the x direction within the texture
                  array
        width     specifies the width of the texture subimage
        yoffset   optional: specifies a texel offset in the y direction within
                  the texture array
        height    optional: specifies the height of the texture subimage

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if the texture array has not been
        defined by a previous @{"gl.TexImage2D()" LINK glTexImage2D} or @{"gl.CopyTexImage()" LINK glCopyTexImage} operation.

        #GL_INVALID_VALUE is generated if "level" is less than 0.

        #GL_INVALID_VALUE may be generated if level > log2(max), where "max" is
        the returned value of #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_VALUE is generated if xoffset < -b, xoffset + width > w - b,
        yoffset < -b, or yoffset + height > h -b, where "w" is the
        #GL_TEXTURE_WIDTH, "h" is the #GL_TEXTURE_HEIGHT, and "b" is the
        #GL_TEXTURE_BORDER of the texture image being modified. Note that "w"
        and "h" include twice the border width.

        #GL_INVALID_OPERATION is generated if gl.CopyTexSubImage() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexImage()" LINK glGetTexImage}

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_TEXTURE_2D or #GL_TEXTURE_1D

@ENDNODE

@NODE glCullFace "GL Galore Guide"

   @{b}NAME@{ub}
        gl.CullFace -- specify whether front- or back-facing facets can be culled

   @{b}SYNOPSIS@{ub}
        gl.CullFace(mode)

   @{b}FUNCTION@{ub}
        gl.CullFace() specifies whether front- or back-facing facets are culled
        (as specified by "mode") when facet culling is enabled. Facet culling is
        initially disabled. To enable and disable facet culling, call the
        @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} commands with the argument #GL_CULL_FACE.
        Facets include triangles, quadrilaterals, polygons, and rectangles.

        @{"gl.FrontFace()" LINK glFrontFace} specifies which of the clockwise and counterclockwise
        facets are front-facing and back-facing. See @{"gl.FrontFace" LINK glFrontFace} for details.

        If mode is #GL_FRONT_AND_BACK, no facets are drawn, but other primitives
        such as points and lines are drawn.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies whether front- or back-facing facets are candidates
                  for culling; symbolic constants #GL_FRONT, #GL_BACK, and
                  #GL_FRONT_AND_BACK are accepted; the initial value is #GL_BACK

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.CullFace() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_CULL_FACE

        @{"gl.Get()" LINK glGet} with argument #GL_CULL_FACE_MODE

@ENDNODE

@NODE glDeleteLists "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DeleteLists -- delete a contiguous group of display lists

   @{b}SYNOPSIS@{ub}
        gl.DeleteLists(list, range)

   @{b}FUNCTION@{ub}
        gl.DeleteLists() causes a contiguous group of display lists to be
        deleted. list is the name of the first display list to be deleted, and
        range is the number of display lists to delete. All display lists d with
        list <= d <= list + range - 1 are deleted.

        All storage locations allocated to the specified display lists are
        freed, and the names are available for reuse at a later time. Names
        within the range that do not have an associated display list are
        ignored. If range is 0, nothing happens.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        list      specifies the integer name of the first display list to delete
        range     specifies the number of display lists to delete

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if range is negative.

        #GL_INVALID_OPERATION is generated if gl.DeleteLists() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

@ENDNODE

@NODE glDeleteTextures "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DeleteTextures -- delete named textures

   @{b}SYNOPSIS@{ub}
        gl.DeleteTextures(texturesArray)

   @{b}FUNCTION@{ub}
        gl.DeleteTextures() deletes all textures passed in the table
        "texturesArray". After a texture is deleted, it has no contents or
        dimensionality, and its name is free for reuse (for example by
        @{"gl.GenTextures()" LINK glGenTextures}). If a texture that is currently bound is deleted, the
        binding reverts to 0 (the default texture).

        gl.DeleteTextures() silently ignores 0's and names that do not
        correspond to existing textures.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        texturesArray
                  specifies an array of textures to be deleted

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if glDeleteTextures is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsTexture()" LINK glIsTexture}

@ENDNODE

@NODE glDepthFunc "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DepthFunc -- specify the value used for depth buffer comparisons

   @{b}SYNOPSIS@{ub}
        gl.DepthFunc(func)

   @{b}FUNCTION@{ub}
        gl.DepthFunc() specifies the function used to compare each incoming
        pixel depth value with the depth value present in the depth buffer. The
        comparison is performed only if depth testing is enabled. (See
        @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} of #GL_DEPTH_TEST)

        "func" specifies the conditions under which the pixel will be drawn. The
        comparison functions are as follows:

        #GL_NEVER Never passes.

        #GL_LESS  Passes if the incoming depth value is less than the stored
                  depth value.

        #GL_EQUAL Passes if the incoming depth value is equal to the stored
                  depth value.

        #GL_LEQUAL
                  Passes if the incoming depth value is less than or equal to
                  the stored depth value.

        #GL_GREATER
                  Passes if the incoming depth value is greater than the stored
                  depth value.

        #GL_NOTEQUAL
                  Passes if the incoming depth value is not equal to the stored
                  depth value.

        #GL_GEQUAL
                  Passes if the incoming depth value is greater than or equal to
                  the stored depth value.

        #GL_ALWAYS
                  Always passes.

        The initial value of func is #GL_LESS. Initially, depth testing is
        disabled. If depth testing is disabled or if no depth buffer exists, it
        is as if the depth test always passes.

        Even if the depth buffer exists and the depth mask is non-zero, the
        depth buffer is not updated if the depth test is disabled.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        func      specifies the depth comparison function (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "func" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.DepthFunc() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_FUNC

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_DEPTH_TEST

@ENDNODE

@NODE glDepthMask "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DepthMask -- enable or disable writing into the depth buffer

   @{b}SYNOPSIS@{ub}
        gl.DepthMask(flag)

   @{b}FUNCTION@{ub}
        gl.DepthMask() specifies whether the depth buffer is enabled for
        writing. If flag is #GL_FALSE, depth buffer writing is disabled.
        Otherwise, it is enabled. Initially, depth buffer writing is enabled.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        flag      specifies whether the depth buffer is enabled for writing; if
                  flag is #GL_FALSE, depth buffer writing is disabled,
                  otherwise, it is enabled; initially, depth buffer writing is
                  enabled

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.DepthMask() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_WRITEMASK

@ENDNODE

@NODE glDepthRange "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DepthRange -- specify mapping of depth values from normalized device coordinates to window coordinates

   @{b}SYNOPSIS@{ub}
        gl.DepthRange(zNear, zFar)

   @{b}FUNCTION@{ub}
        After clipping and division by w, depth coordinates range from -1 to 1,
        corresponding to the near and far clipping planes. gl.DepthRange()
        specifies a linear mapping of the normalized depth coordinates in this
        range to window depth coordinates. Regardless of the actual depth buffer
        implementation, window coordinate depth values are treated as though
        they range from 0 through 1 (like color components). Thus, the values
        accepted by gl.DepthRange() are both clamped to this range before they
        are accepted.

        The setting of (0,1) maps the near plane to 0 and the far plane to 1.
        With this mapping, the depth buffer range is fully utilized.

        It is not necessary that "nearVal" be less than "farVal". Reverse
        mappings such as nearVal = 1, and farVal = 0 are acceptable.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        zNear     specifies the mapping of the near clipping plane to window
                  coordinates; the initial value is 0
        zFar      specifies the mapping of the far clipping plane to window
                  coordinates; the initial value is 1

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.DepthRange() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_RANGE

@ENDNODE

@NODE glDisable "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Disable -- disable server-side GL capabilities

   @{b}SYNOPSIS@{ub}
        gl.Disable(cap)

   @{b}FUNCTION@{ub}
        gl.Disable() disables various capabilities. Use @{"gl.IsEnabled()" LINK glIsEnabled} or
        @{"gl.Get()" LINK glGet} to determine the current setting of any capability. The initial
        value for each capability with the exception of #GL_DITHER is #GL_FALSE.
        The initial value for #GL_DITHER is #GL_TRUE.

        gl.Disable() takes a single argument, "cap", which can assume one of the
        following values:

        #GL_ALPHA_TEST
                  If enabled, do alpha testing. See @{"gl.AlphaFunc" LINK glAlphaFunc} for details..

        #GL_AUTO_NORMAL
                  If enabled, generate normal vectors when either
                  #GL_MAP2_VERTEX_3 or #GL_MAP2_VERTEX_4 is used to generate
                  vertices. See @{"gl.Map" LINK glMap} for details.

        #GL_BLEND If enabled, blend the computed fragment color values with the
                  values in the color buffers. See See @{"gl.BlendFunc" LINK glBlendFunc} for details.

        #GL_CLIP_PLANEi
                  If enabled, clip geometry against user-defined clipping plane
                  i. See See @{"gl.ClipPlane" LINK glClipPlane} for details.

        #GL_COLOR_LOGIC_OP
                  If enabled, apply the currently selected logical operation to
                  the computed fragment color and color buffer values. See See
                  @{"gl.LogicOp" LINK glLogicOp} for details.

        #GL_COLOR_MATERIAL
                  If enabled, have one or more material parameters track the
                  current color. See See @{"gl.ColorMaterial" LINK glColorMaterial} for details.

        #GL_CULL_FACE
                  If enabled, cull polygons based on their winding in window
                  coordinates. See See @{"gl.CullFace" LINK glCullFace} for details.

        #GL_DEPTH_TEST
                  If enabled, do depth comparisons and update the depth buffer.
                  Note that even if the depth buffer exists and the depth mask
                  is non-zero, the depth buffer is not updated if the depth test
                  is disabled. See See @{"gl.DepthFunc" LINK glDepthFunc} for details. and See
                  @{"gl.DepthRange" LINK glDepthRange} for details.

        #GL_DITHER
                  If enabled, dither color components or indices before they are
                  written to the color buffer.

        #GL_FOG   If enabled and no fragment shader is active, blend a fog color
                  into the post-texturing color. See See @{"gl.Fog" LINK glFog} for details.

        #GL_INDEX_LOGIC_OP
                  If enabled, apply the currently selected logical operation to
                  the incoming index and color buffer indices. See See
                  @{"gl.LogicOp" LINK glLogicOp} for details.

        #GL_LIGHTi
                  If enabled, include light i in the evaluation of the lighting
                  equation. See See @{"gl.LightModel" LINK glLightModel} for details. and See @{"gl.Light" LINK glLight}
                  for details.

        #GL_LIGHTING
                  If enabled and no vertex shader is active, use the current
                  lighting parameters to compute the vertex color or index.
                  Otherwise, simply associate the current color or index with
                  each vertex. See @{"gl.Material" LINK glMaterial} for details. See @{"gl.LightModel" LINK glLightModel}
                  for details. See @{"gl.Light" LINK glLight} for details.

        #GL_LINE_SMOOTH
                  If enabled, draw lines with correct filtering. Otherwise, draw
                  aliased lines. See @{"gl.LineWidth" LINK glLineWidth} for details.

        #GL_LINE_STIPPLE
                  If enabled, use the current line stipple pattern when drawing
                  lines. See @{"gl.LineStipple" LINK glLineStipple} for details.

        #GL_MAP1_COLOR_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate RGBA values. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_INDEX
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate color indices. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_NORMAL
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate normals. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_TEXTURE_COORD_1
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.

        #GL_MAP1_TEXTURE_COORD_2
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s and t texture coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_TEXTURE_COORD_3
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s, t, and r texture coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_TEXTURE_COORD_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s, t, r, and q texture coordinates.
                  See @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_VERTEX_3
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate x, y, and z vertex coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP1_VERTEX_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate homogeneous x, y, z, and w vertex
                  coordinates. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_COLOR_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate RGBA values. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_INDEX
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate color indices. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_NORMAL
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate normals. See @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_TEXTURE_COORD_1
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.

        #GL_MAP2_TEXTURE_COORD_2
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s and t texture coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_TEXTURE_COORD_3
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s, t, and r texture coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_TEXTURE_COORD_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate s, t, r, and q texture coordinates.
                  See @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_VERTEX_3
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate x, y, and z vertex coordinates. See
                  @{"gl.Map" LINK glMap} for details.

        #GL_MAP2_VERTEX_4
                  If enabled, calls to @{"gl.EvalCoord()" LINK glEvalCoord}, @{"gl.EvalMesh()" LINK glEvalMesh}, and
                  @{"gl.EvalPoint()" LINK glEvalPoint} generate homogeneous x, y, z, and w vertex
                  coordinates. See @{"gl.Map" LINK glMap} for details.

        #GL_NORMALIZE
                  If enabled and no vertex shader is active, normal vectors are
                  normalized to unit length after transformation and before
                  lighting. See @{"gl.Normal" LINK glNormal} for details. See @{"gl.NormalPointer" LINK glNormalPointer} for
                  details.

        #GL_POINT_SMOOTH
                  If enabled, draw points with proper filtering. Otherwise, draw
                  aliased points. See @{"gl.PointSize" LINK glPointSize} for details.

        #GL_POLYGON_OFFSET_FILL
                  If enabled, and if the polygon is rendered in #GL_FILL mode,
                  an offset is added to depth values of a polygon's fragments
                  before the depth comparison is performed. See @{"gl.PolygonOffset" LINK glPolygonOffset}
                  for details.

        #GL_POLYGON_OFFSET_LINE
                  If enabled, and if the polygon is rendered in #GL_LINE mode,
                  an offset is added to depth values of a polygon's fragments
                  before the depth comparison is performed. See @{"gl.PolygonOffset" LINK glPolygonOffset}
                  for details.

        #GL_POLYGON_OFFSET_POINT
                  If enabled, an offset is added to depth values of a polygon's
                  fragments before the depth comparison is performed, if the
                  polygon is rendered in GL_POINT mode. See glPolygonOffset.

        #GL_POLYGON_SMOOTH
                  If enabled, draw polygons with proper filtering. Otherwise,
                  draw aliased polygons. For correct antialiased polygons, an
                  alpha buffer is needed and the polygons must be sorted front
                  to back.

        #GL_POLYGON_STIPPLE
                  If enabled, use the current polygon stipple pattern when
                  rendering polygons. See @{"gl.PolygonStipple" LINK glPolygonStipple} for details.

        #GL_SCISSOR_TEST
                  If enabled, discard fragments that are outside the scissor
                  rectangle. See @{"gl.Scissor" LINK glScissor} for details.

        #GL_STENCIL_TEST
                  If enabled, do stencil testing and update the stencil buffer.
                  See @{"gl.StencilFunc" LINK glStencilFunc} for details. See @{"gl.StencilOp" LINK glStencilOp} for details.

        #GL_TEXTURE_1D
                  If enabled and no fragment shader is active, one-dimensional
                  texturing is performed (unless two- or three-dimensional or
                  cube-mapped texturing is also enabled). See @{"gl.TexImage1D" LINK glTexImage1D} for
                  details.

        #GL_TEXTURE_2D
                  If enabled and no fragment shader is active, two-dimensional
                  texturing is performed (unless three-dimensional or
                  cube-mapped texturing is also enabled). See @{"gl.TexImage2D" LINK glTexImage2D} for
                  details.

        #GL_TEXTURE_GEN_Q
                  If enabled and no vertex shader is active, the q texture
                  coordinate is computed using the texture generation function
                  defined with @{"gl.TexGen()" LINK glTexGen}. Otherwise, the current q texture
                  coordinate is used. See @{"gl.TexGen" LINK glTexGen} for details.

        #GL_TEXTURE_GEN_R
                  If enabled and no vertex shader is active, the r texture
                  coordinate is computed using the texture generation function
                  defined with @{"gl.TexGen()" LINK glTexGen}. Otherwise, the current r texture
                  coordinate is used. See @{"gl.TexGen" LINK glTexGen} for details.

        #GL_TEXTURE_GEN_S
                  If enabled and no vertex shader is active, the s texture
                  coordinate is computed using the texture generation function
                  defined with @{"gl.TexGen()" LINK glTexGen}. Otherwise, the current s texture
                  coordinate is used. See @{"gl.TexGen" LINK glTexGen} for details.

        #GL_TEXTURE_GEN_T
                  If enabled and no vertex shader is active, the t texture
                  coordinate is computed using the texture generation function
                  defined with @{"gl.TexGen()" LINK glTexGen}. Otherwise, the current t texture
                  coordinate is used. See @{"gl.TexGen" LINK glTexGen} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        cap       specifies a symbolic constant indicating a GL capability

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "cap" is not one of the values listed
        previously.

        #GL_INVALID_OPERATION is generated if @{"gl.Enable()" LINK glEnable} or gl.Disable() is
        executed between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding
        execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled}

        @{"gl.Get()" LINK glGet}

@ENDNODE

@NODE glDisableClientState "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DisableClientState -- disable client-side capability

   @{b}SYNOPSIS@{ub}
        gl.DisableClientState(cap)

   @{b}FUNCTION@{ub}
        gl.DisableClientState() disables individual client-side capabilities. By
        default, all client-side capabilities are disabled.
        gl.DisableClientState() takes a single argument, "cap", which can assume
        one of the following values:

        #GL_COLOR_ARRAY
                  If enabled, the color array is enabled for writing and used
                  during rendering when @{"gl.ArrayElement()" LINK glArrayElement}, @{"gl.DrawArrays()" LINK glDrawArrays}, or
                  @{"gl.DrawElements()" LINK glDrawElements} is called. See @{"gl.ColorPointer" LINK glColorPointer} for details.

        #GL_EDGE_FLAG_ARRAY
                  If enabled, the edge flag array is enabled for writing and
                  used during rendering when @{"gl.ArrayElement()" LINK glArrayElement}, @{"gl.DrawArrays()" LINK glDrawArrays},
                  or @{"gl.DrawElements()" LINK glDrawElements} is called. See @{"gl.EdgeFlagPointer" LINK glEdgeFlagPointer} for
                  details.

        #GL_INDEX_ARRAY
                  If enabled, the index array is enabled for writing and used
                  during rendering when @{"gl.ArrayElement()" LINK glArrayElement}, @{"gl.DrawArrays()" LINK glDrawArrays}, or
                  @{"gl.DrawElements()" LINK glDrawElements} is called. See @{"gl.IndexPointer" LINK glIndexPointer} for details.

        #GL_NORMAL_ARRAY
                  If enabled, the normal array is enabled for writing and used
                  during rendering when @{"gl.ArrayElement()" LINK glArrayElement}, @{"gl.DrawArrays()" LINK glDrawArrays}, or
                  @{"gl.DrawElements()" LINK glDrawElements} is called. See @{"gl.NormalPointer" LINK glNormalPointer} for details.

        #GL_TEXTURE_COORD_ARRAY
                  If enabled, the texture coordinate array is enabled for
                  writing and used during rendering when @{"gl.ArrayElement()" LINK glArrayElement},
                  @{"gl.DrawArrays()" LINK glDrawArrays}, or @{"gl.DrawElements()" LINK glDrawElements} is called. See
                  @{"gl.TexCoordPointer" LINK glTexCoordPointer} for details.

        #GL_VERTEX_ARRAY
                  If enabled, the vertex array is enabled for writing and used
                  during rendering when @{"gl.ArrayElement()" LINK glArrayElement}, @{"gl.DrawArrays()" LINK glDrawArrays}, or
                  @{"gl.DrawElements()" LINK glDrawElements} is called. See @{"gl.VertexPointer" LINK glVertexPointer} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        array     specifies the capability to disable (see above for supported
                  constants)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "cap" is not an accepted value.

        gl.DisableClientState() is not allowed between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding @{"gl.End()" LINK glEnd}, but an error may or may not
        be generated. If no error is generated, the behavior is undefined.

@ENDNODE

@NODE glDrawArrays "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DrawArrays -- render primitives from array data

   @{b}SYNOPSIS@{ub}
        gl.DrawArrays(mode, first, count)

   @{b}FUNCTION@{ub}
        gl.DrawArrays() specifies multiple geometric primitives with very few
        subroutine calls. Instead of calling a GL procedure to pass each
        individual vertex, normal, texture coordinate, edge flag, or color, you
        can prespecify separate arrays of vertices, normals, and colors and use
        them to construct a sequence of primitives with a single call to
        gl.DrawArrays().

        When gl.DrawArrays() is called, it uses "count" sequential elements from
        each enabled array to construct a sequence of geometric primitives,
        beginning with element first. "mode" specifies what kind of primitives
        are constructed and how the array elements construct those primitives.
        If #GL_VERTEX_ARRAY is not enabled, no geometric primitives are
        generated. "mode" can be set to the symbolic constants #GL_POINTS,
        #GL_LINE_STRIP, #GL_LINE_LOOP, #GL_LINES, #GL_TRIANGLE_STRIP,
        #GL_TRIANGLE_FAN, #GL_TRIANGLES, #GL_QUAD_STRIP, #GL_QUADS, or
        #GL_POLYGON.

        Vertex attributes that are modified by gl.DrawArrays() have an
        unspecified value after gl.DrawArrays() returns. For example, if
        #GL_COLOR_ARRAY is enabled, the value of the current color is undefined
        after gl.DrawArrays() executes. Attributes that aren't modified remain
        well defined.

        gl.DrawArrays() is included in display lists. If gl.DrawArrays() is
        entered into a display list, the necessary array data (determined by the
        array pointers and enables) is also entered into the display list.
        Because the array pointers and enables are client-side state, their
        values affect display lists when the lists are created, not when the
        lists are executed.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies what kind of primitives to render (see above)
        first     specifies the starting index in the enabled arrays
        count     specifies the number of indices to be rendered

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if mode is not an accepted value.

        #GL_INVALID_VALUE is generated if count is negative.

        #GL_INVALID_OPERATION is generated if a non-zero buffer object name is
        bound to an enabled array and the buffer object's data store is
        currently mapped.

        #GL_INVALID_OPERATION is generated if glDrawArrays is executed between
        the execution of glBegin and the corresponding glEnd.

@ENDNODE

@NODE glDrawBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DrawBuffer -- specify which color buffers are to be drawn into

   @{b}SYNOPSIS@{ub}
        gl.DrawBuffer(mode)

   @{b}FUNCTION@{ub}
        When colors are written to the frame buffer, they are written into the
        color buffers specified by gl.DrawBuffer(). The following constants can
        be passed in "mode":

        #GL_NONE  No color buffers are written.

        #GL_FRONT_LEFT
                  Only the front left color buffer is written.

        #GL_FRONT_RIGHT
                  Only the front right color buffer is written.

        #GL_BACK_LEFT
                  Only the back left color buffer is written.

        #GL_BACK_RIGHT
                  Only the back right color buffer is written.

        #GL_FRONT Only the front left and front right color buffers are written.
                  If there is no front right color buffer, only the front left
                  color buffer is written.

        #GL_BACK  Only the back left and back right color buffers are written.
                  If there is no back right color buffer, only the back left
                  color buffer is written.

        #GL_LEFT  Only the front left and back left color buffers are written.
                  If there is no back left color buffer, only the front left
                  color buffer is written.

        #GL_RIGHT Only the front right and back right color buffers are written.
                  If there is no back right color buffer, only the front right
                  color buffer is written.

        #GL_FRONT_AND_BACK
                  All the front and back color buffers (front left, front right,
                  back left, back right) are written. If there are no back color
                  buffers, only the front left and front right color buffers are
                  written. If there are no right color buffers, only the front
                  left and back left color buffers are written. If there are no
                  right or back color buffers, only the front left color buffer
                  is written.

        #GL_AUXi  Only auxiliary color buffer "i" is written where "i" is
                  between 0 and the value of #GL_AUX_BUFFERS minus 1. Note that
                  #GL_AUX_BUFFERS is not the upper limit; use @{"gl.Get()" LINK glGet} to query
                  the number of available aux buffers. It is always the case
                  that #GL_AUXi = #GL_AUX0 + "i".

        If more than one color buffer is selected for drawing, then blending or
        logical operations are computed and applied independently for each color
        buffer and can produce different results in each buffer.

        Monoscopic contexts include only left buffers, and stereoscopic contexts
        include both left and right buffers. Likewise, single-buffered contexts
        include only front buffers, and double-buffered contexts include both
        front and back buffers. The context is selected at GL initialization.

        The initial value is #GL_FRONT for single-buffered contexts, and
        #GL_BACK for double-buffered contexts.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies up to four color buffers to be drawn into (see
                  above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if mode is not an accepted value.

        #GL_INVALID_OPERATION is generated if none of the buffers indicated by
        mode exists.

        #GL_INVALID_OPERATION is generated if gl.DrawBuffer() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_DRAW_BUFFER

        @{"gl.Get()" LINK glGet} with argument #GL_AUX_BUFFERS

@ENDNODE

@NODE glDrawElements "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DrawElements -- render primitives from array data

   @{b}SYNOPSIS@{ub}
        gl.DrawElements(mode, indicesArray)

   @{b}FUNCTION@{ub}
        gl.DrawElements() specifies multiple geometric primitives with very few
        subroutine calls. Instead of calling a GL function to pass each
        individual vertex, normal, texture coordinate, edge flag, or color, you
        can prespecify separate arrays of vertices, normals, and so on, and use
        them to construct a sequence of primitives with a single call to
        gl.DrawElements().

        When gl.DrawElements() is called, it reads sequential elements from an
        enabled array and constructs a sequence of geometric primitives. "mode"
        specifies what kind of primitives are constructed and how the array
        elements construct these primitives. "mode" can be set to the symbolic
        constants #GL_POINTS, #GL_LINE_STRIP, #GL_LINE_LOOP, #GL_LINES,
        #GL_TRIANGLE_STRIP, #GL_TRIANGLE_FAN, #GL_TRIANGLES, #GL_QUAD_STRIP,
        #GL_QUADS, and #GL_POLYGON. If more than one array is enabled, each is
        used. If #GL_VERTEX_ARRAY is not enabled, no geometric primitives are
        constructed.

        Vertex attributes that are modified by gl.DrawElements() have an
        unspecified value after gl.DrawElements() returns. For example, if
        #GL_COLOR_ARRAY is enabled, the value of the current color is undefined
        after gl.DrawElements() executes. Attributes that aren't modified
        maintain their previous values.

        gl.DrawElements() is included in display lists. If gl.DrawElements() is
        entered into a display list, the necessary array data (determined by the
        array pointers and enables) is also entered into the display list.
        Because the array pointers and enables are client-side state, their
        values affect display lists when the lists are created, not when the
        lists are executed.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies what kind of primitives to render (see above)
        indicesArray
                  specifies an array where the indices are stored; the indices
                  in this array are treated as values of type #GL_UNSIGNED_INT

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if mode is not an accepted value.

        #GL_INVALID_OPERATION is generated if a non-zero buffer object name is
        bound to an enabled array or the element array and the buffer object's
        data store is currently mapped.

        #GL_INVALID_OPERATION is generated if gl.DrawElements() is executed
        between the execution of glBegin and the corresponding glEnd.

@ENDNODE

@NODE glDrawPixels "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DrawPixels -- write a block of pixels to the frame buffer

   @{b}SYNOPSIS@{ub}
        gl.DrawPixels(width, height, format, pixelsArray)

   @{b}FUNCTION@{ub}
        This function does the same as @{"gl.DrawPixelsRaw()" LINK glDrawPixelsRaw} except that the pixel
        data is not passed as a raw memory buffer but as a table containing
        width*height number of elements describing a pixel each. This is of
        course not as efficient as using raw memory buffers because the table's
        pixel data has to be copied to a raw memory buffer first.

        Note that gl.DrawPixels() expects data of type #GL_FLOAT inside the
        "pixelsArray" table.

        See @{"gl.DrawPixelsRaw" LINK glDrawPixelsRaw} for more details on the parameters accepted by this
        function.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        width     specify the width of the pixel rectangle to be written into
                  the frame buffer
        height    specify the height of the pixel rectangle to be written into
                  the frame buffer
        format    specifies the format of the pixel data (see above for
                  supported formats)
        pixelsArray
                  specifies an array containing the pixel data; data in this
                  array is treated as #GL_FLOAT

@ENDNODE

@NODE glDrawPixelsRaw "GL Galore Guide"

   @{b}NAME@{ub}
        gl.DrawPixelsRaw -- write a block of pixels to the frame buffer

   @{b}SYNOPSIS@{ub}
        gl.DrawPixelsRaw(width, height, format, type, pixels)

   @{b}FUNCTION@{ub}
        gl.DrawPixelsRaw() reads pixel data from memory and writes it into the
        frame buffer relative to the current raster position, provided that the
        raster position is valid. Use @{"gl.RasterPos()" LINK glRasterPos} to set the current raster
        position; use @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION_VALID
        to determine if the specified raster position is valid, and @{"gl.Get()" LINK glGet}
        with argument #GL_CURRENT_RASTER_POSITION to query the raster position.

        Several parameters define the encoding of pixel data in memory and
        control the processing of the pixel data before it is placed in the
        frame buffer. These parameters are set with four commands:
        @{"gl.PixelStore()" LINK glPixelStore}, @{"gl.PixelTransfer()" LINK glPixelTransfer}, @{"gl.PixelMap()" LINK glPixelMap}, and
        @{"gl.PixelZoom()" LINK glPixelZoom}. This reference page describes the effects on
        gl.DrawPixelsRaw() of many, but not all, of the parameters specified by
        these four commands.

        Data is read from "pixels" as a sequence of signed or unsigned bytes,
        signed or unsigned shorts, signed or unsigned integers, or
        single-precision floating-point values, depending on "type" which can be
        #GL_UNSIGNED_BYTE, #GL_BYTE, #GL_BITMAP, #GL_UNSIGNED_SHORT, #GL_SHORT,
        #GL_UNSIGNED_INT, #GL_INT, or #GL_FLOAT. Each of these bytes, shorts,
        integers, or floating-point values is interpreted as one color or depth
        component, or one index, depending on format. Indices are always treated
        individually. Color components are treated as groups of one, two, three,
        or four values, again based on "format". Both individual indices and
        groups of components are referred to as pixels. If type is #GL_BITMAP,
        the data must be unsigned bytes, and format must be either
        #GL_COLOR_INDEX or #GL_STENCIL_INDEX. Each unsigned byte is treated as
        eight 1-bit pixels, with bit ordering determined by #GL_UNPACK_LSB_FIRST
        See @{"gl.PixelStore" LINK glPixelStore} for details. ().

        "width" * "height" pixels are read from memory, starting at location
        "pixels". By default, these pixels are taken from adjacent memory
        locations, except that after all width pixels are read, the read pointer
        is advanced to the next four-byte boundary. The four-byte row alignment
        is specified by @{"gl.PixelStore()" LINK glPixelStore} with argument #GL_UNPACK_ALIGNMENT, and
        it can be set to one, two, four, or eight bytes. Other pixel store
        parameters specify different read pointer advancements, both before the
        first pixel is read and after all width pixels are read. See
        @{"gl.PixelStore" LINK glPixelStore} for details.

        The "width" * "height" pixels that are read from memory are each
        operated on in the same way, based on the values of several parameters
        specified by @{"gl.PixelTransfer()" LINK glPixelTransfer} and @{"gl.PixelMap()" LINK glPixelMap}. The details of these
        operations, as well as the target buffer into which the pixels are
        drawn, are specific to the format of the pixels, as specified by
        "format". "format" can assume one of 13 symbolic values:

        #GL_COLOR_INDEX
                  Each pixel is a single value, a color index. It is converted
                  to fixed-point format, with an unspecified number of bits to
                  the right of the binary point, regardless of the memory data
                  type. Floating-point values convert to true fixed-point
                  values.

                  Each fixed-point index is then shifted left by #GL_INDEX_SHIFT
                  bits and added to #GL_INDEX_OFFSET. If #GL_INDEX_SHIFT is
                  negative, the shift is to the right. In either case, zero bits
                  fill otherwise unspecified bit locations in the result.

                  If the GL is in RGBA mode, the resulting index is converted to
                  an RGBA pixel with the help of the #GL_PIXEL_MAP_I_TO_R,
                  #GL_PIXEL_MAP_I_TO_G, #GL_PIXEL_MAP_I_TO_B, and
                  #GL_PIXEL_MAP_I_TO_A tables. If the GL is in color index mode,
                  and if #GL_MAP_COLOR is true, the index is replaced with the
                  value that it references in lookup table #GL_PIXEL_MAP_I_TO_I.
                  Whether the lookup replacement of the index is done or not,
                  the integer part of the index is then ANDed with 2^b-1, where
                  "b" is the number of bits in a color index buffer.

                  The GL then converts the resulting indices or RGBA colors to
                  fragments by attaching the current raster position z
                  coordinate and texture coordinates to each pixel, then
                  assigning x and y window coordinates to the nth fragment such
                  that

                      xn = xr + n % width
                      yn = yr + n / width

                  where (xr,yr) is the current raster position. These pixel
                  fragments are then treated just like the fragments generated
                  by rasterizing points, lines, or polygons. Texture mapping,
                  fog, and all the fragment operations are applied before the
                  fragments are written to the frame buffer.

        #GL_STENCIL_INDEX
                  Each pixel is a single value, a stencil index. It is converted
                  to fixed-point format, with an unspecified number of bits to
                  the right of the binary point, regardless of the memory data
                  type. Floating-point values convert to true fixed-point
                  values.

                  Each fixed-point index is then shifted left by #GL_INDEX_SHIFT
                  bits, and added to #GL_INDEX_OFFSET. If #GL_INDEX_SHIFT is
                  negative, the shift is to the right. In either case, zero bits
                  fill otherwise unspecified bit locations in the result. If
                  #GL_MAP_STENCIL is true, the index is replaced with the value
                  that it references in lookup table #GL_PIXEL_MAP_S_TO_S.
                  Whether the lookup replacement of the index is done or not,
                  the integer part of the index is then ANDed with 2^b-1, where
                  "b" is the number of bits in the stencil buffer. The resulting
                  stencil indices are then written to the stencil buffer such
                  that the nth index is written to location

                      xn = xr + n % width
                      yn = yr + n / width

                  where (xr,yr) is the current raster position. Only the pixel
                  ownership test, the scissor test, and the stencil writemask
                  affect these write operations.

        #GL_DEPTH_COMPONENT
                  Each pixel is a single-depth component. Floating-point data is
                  converted directly to an internal floating-point format with
                  unspecified precision. The resulting floating-point depth
                  value is then multiplied by #GL_DEPTH_SCALE and added to
                  #GL_DEPTH_BIAS. The result is clamped to the range [0,1].

                  The GL then converts the resulting depth components to
                  fragments by attaching the current raster position color or
                  color index and texture coordinates to each pixel, then
                  assigning x and y window coordinates to the nth fragment such
                  that

                      xn = xr + n % width
                      yn = yr + n / width

                  where (xr,yr) is the current raster position. These pixel
                  fragments are then treated just like the fragments generated
                  by rasterizing points, lines, or polygons. Texture mapping,
                  fog, and all the fragment operations are applied before the
                  fragments are written to the frame buffer.

        #GL_RGBA  Each pixel is a four-component group: For #GL_RGBA, the red
                  component is first, followed by green, followed by blue,
                  followed by alpha. Floating-point values are converted
                  directly to an internal floating-point format with unspecified
                  precision. The resulting floating-point color values are then
                  multiplied by #GL_c_SCALE and added to #GL_c_BIAS, where c is
                  RED, GREEN, BLUE, and ALPHA for the respective color
                  components. The results are clamped to the range [0,1].

                  If #GL_MAP_COLOR is true, each color component is scaled by
                  the size of lookup table #GL_PIXEL_MAP_c_TO_c, then replaced
                  by the value that it references in that table. c is R, G, B,
                  or A respectively.

                  The GL then converts the resulting RGBA colors to fragments by
                  attaching the current raster position z coordinate and texture
                  coordinates to each pixel, then assigning x and y window
                  coordinates to the nth fragment such that

                      xn = xr + n % width
                      yn = yr + n / width

                  where (xr,yr) is the current raster position. These pixel
                  fragments are then treated just like the fragments generated
                  by rasterizing points, lines, or polygons. Texture mapping,
                  fog, and all the fragment operations are applied before the
                  fragments are written to the frame buffer.

        #GL_RED   Each pixel is a single red component. This component is
                  converted to the internal floating-point format in the same
                  way the red component of an RGBA pixel is. It is then
                  converted to an RGBA pixel with green and blue set to 0, and
                  alpha set to 1. After this conversion, the pixel is treated as
                  if it had been read as an RGBA pixel.

        #GL_GREEN Each pixel is a single green component. This component is
                  converted to the internal floating-point format in the same
                  way the green component of an RGBA pixel is. It is then
                  converted to an RGBA pixel with red and blue set to 0, and
                  alpha set to 1. After this conversion, the pixel is treated as
                  if it had been read as an RGBA pixel.

        #GL_BLUE  Each pixel is a single blue component. This component is
                  converted to the internal floating-point format in the same
                  way the blue component of an RGBA pixel is. It is then
                  converted to an RGBA pixel with red and green set to 0, and
                  alpha set to 1. After this conversion, the pixel is treated as
                  if it had been read as an RGBA pixel.

        #GL_ALPHA Each pixel is a single alpha component. This component is
                  converted to the internal floating-point format in the same
                  way the alpha component of an RGBA pixel is. It is then
                  converted to an RGBA pixel with red, green, and blue set to 0.
                  After this conversion, the pixel is treated as if it had been
                  read as an RGBA pixel.

        #GL_RGB   Each pixel is a three-component group: red first, followed by
                  green, followed by blue. Each component is converted to the
                  internal floating-point format in the same way the red, green,
                  and blue components of an RGBA pixel are. The color triple is
                  converted to an RGBA pixel with alpha set to 1. After this
                  conversion, the pixel is treated as if it had been read as an
                  RGBA pixel.

        #GL_LUMINANCE
                  Each pixel is a single luminance component. This component is
                  converted to the internal floating-point format in the same
                  way the red component of an RGBA pixel is. It is then
                  converted to an RGBA pixel with red, green, and blue set to
                  the converted luminance value, and alpha set to 1. After this
                  conversion, the pixel is treated as if it had been read as an
                  RGBA pixel.

        #GL_LUMINANCE_ALPHA
                  Each pixel is a two-component group: luminance first, followed
                  by alpha. The two components are converted to the internal
                  floating-point format in the same way the red component of an
                  RGBA pixel is. They are then converted to an RGBA pixel with
                  red, green, and blue set to the converted luminance value, and
                  alpha set to the converted alpha value. After this conversion,
                  the pixel is treated as if it had been read as an RGBA pixel.

        The rasterization described so far assumes pixel zoom factors of 1. If
        @{"gl.PixelZoom()" LINK glPixelZoom} is used to change the x and y pixel zoom factors, pixels
        are converted to fragments as follows. If (xr,yr) is the current raster
        position, and a given pixel is in the nth column and mth row of the
        pixel rectangle, then fragments are generated for pixels whose centers
        are in the rectangle with corners at

            (xr + zoomx_n, yr + zoomy_m)

        and

            (xr + zoomx_(n + 1), yr + zoomy_(m + 1))

        where "zoomx" is the value of #GL_ZOOM_X and "zoomy" is the value of
        #GL_ZOOM_Y.

        Please note that this command operates directly with memory pointers.
        There is also a version which works with tables instead of memory
        pointers, but this is slower of course. See @{"gl.DrawPixels" LINK glDrawPixels} for details.
        See @{"Working with pointers" LINK UsingPointers} for details on how to use memory pointers with
        Hollywood.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        width     specifies the width of the pixel rectangle to be written into
                  the frame buffer
        height    specifies the height of the pixel rectangle to be written into
                  the frame buffer
        format    specifies the format of the pixel data (see above for
                  supported formats)
        type      specifies the data type of the pixel data (see above)
        pixels    specifies a pointer to the pixel data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "format" or "type" is not one of the
        accepted values.

        #GL_INVALID_ENUM is generated if "type" is #GL_BITMAP and "format" is
        not either #GL_COLOR_INDEX or #GL_STENCIL_INDEX.

        #GL_INVALID_VALUE is generated if either "width" or "height" is
        negative.

        #GL_INVALID_OPERATION is generated if "format" is #GL_STENCIL_INDEX and
        there is no stencil buffer.

        #GL_INVALID_OPERATION is generated if "format" is #GL_RED, #GL_GREEN,
        #GL_BLUE, #GL_ALPHA, #GL_RGB, #GL_RGBA, #GL_LUMINANCE, or
        #GL_LUMINANCE_ALPHA, and the GL is in color index mode.

        #GL_INVALID_OPERATION is generated if gl.DrawPixelsRaw() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION_VALID

@ENDNODE

@NODE glEdgeFlag "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EdgeFlag -- flag edges as either boundary or nonboundary

   @{b}SYNOPSIS@{ub}
        gl.EdgeFlag(flag)

   @{b}FUNCTION@{ub}
        Each vertex of a polygon, separate triangle, or separate quadrilateral
        specified between a @{"gl.Begin()" LINK glBegin} / @{"gl.End()" LINK glEnd} pair is marked as the start of
        either a boundary or nonboundary edge. If the current edge flag is true
        when the vertex is specified, the vertex is marked as the start of a
        boundary edge. Otherwise, the vertex is marked as the start of a
        nonboundary edge. gl.EdgeFlag() sets the edge flag bit to #GL_TRUE if
        flag is #GL_TRUE and to #GL_FALSE otherwise. The initial value is
        #GL_TRUE.

        The vertices of connected triangles and connected quadrilaterals are
        always marked as boundary, regardless of the value of the edge flag.

        Boundary and nonboundary edge flags on vertices are significant only if
        #GL_POLYGON_MODE is set to #GL_POINT or #GL_LINE. See @{"gl.PolygonMode" LINK glPolygonMode} for
        details.

        The current edge flag can be updated at any time. In particular,
        gl.EdgeFlag() can be called between a call to @{"gl.Begin()" LINK glBegin} and the
        corresponding call to @{"gl.End()" LINK glEnd}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        flag      specifies the current edge flag value (either #GL_TRUE or
                  #GL_FALSE)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_EDGE_FLAG

@ENDNODE

@NODE glEdgeFlagPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EdgeFlagPointer -- define an array of edge flags

   @{b}SYNOPSIS@{ub}
        gl.EdgeFlagPointer(flagsArray)

   @{b}FUNCTION@{ub}
        gl.EdgeFlagPointer() specifies an array of boolean edge flags to use
        when rendering. If you pass Nil in "flagsArray", the edge flag array
        buffer will be freed but it won't be removed from OpenGL. You need to do
        this manually, e.g. by disabling the edge flag array or defining a new
        one.

        When an edge flag array is specified, it is saved as client-side state,
        in addition to the current vertex array buffer object binding.

        To enable and disable the edge flag array, call @{"gl.EnableClientState()" LINK glEnableClientState}
        and @{"gl.DisableClientState()" LINK glDisableClientState} with the argument #GL_EDGE_FLAG_ARRAY. If
        enabled, the edge flag array is used when @{"gl.DrawArrays()" LINK glDrawArrays},
        @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Edge flags are not supported for interleaved vertex array formats. See
        @{"gl.InterleavedArrays" LINK glInterleavedArrays} for details.

        The edge flag array is initially disabled and isn't accessed when
        @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Execution of gl.EdgeFlagPointer() is not allowed between the execution
        of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.EdgeFlagPointer() is typically implemented on the client side.

        Edge flag array parameters are client-side state and are therefore not
        saved or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}. Use
        @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        flagsArray
                  specifies a table containing an array of edge flags or Nil

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_EDGE_FLAG_ARRAY

        @{"gl.Get()" LINK glGet} with argument #GL_EDGE_FLAG_ARRAY_POINTER

@ENDNODE

@NODE glEnable "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Enable -- enable server-side GL capabilities

   @{b}SYNOPSIS@{ub}
        gl.Enable(cap)

   @{b}FUNCTION@{ub}
        gl.Enable() enables various capabilities. Use @{"gl.IsEnabled()" LINK glIsEnabled} or @{"gl.Get()" LINK glGet}
        to determine the current setting of any capability. The initial value
        for each capability with the exception of #GL_DITHER is #GL_FALSE. The
        initial value for #GL_DITHER is #GL_TRUE.

        See @{"gl.Disable" LINK glDisable} for a list of supported capabilities.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        cap       specifies a symbolic constant indicating a GL capability

@ENDNODE

@NODE glEnableClientState "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EnableClientState -- enable client-side capability

   @{b}SYNOPSIS@{ub}
        gl.EnableClientState(cap)

   @{b}FUNCTION@{ub}
        gl.EnableClientState() enables individual client-side capabilities. By
        default, all client-side capabilities are disabled.
        gl.EnableClientState() takes a single argument, "cap". See
        @{"gl.DisableClientState" LINK glDisableClientState} for a list of supported capabilities.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        cap       specifies the capability to enable

@ENDNODE

@NODE glEnd "GL Galore Guide"

   @{b}NAME@{ub}
        gl.End -- delimit the vertices of a primitive or a group of like primitives

   @{b}SYNOPSIS@{ub}
        gl.End()

   @{b}FUNCTION@{ub}
        See @{"gl.Begin" LINK glBegin} for details.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
   @{b}ASSOCIATED GETS@{ub}
@ENDNODE

@NODE glEndList "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EndList -- replace a display list

   @{b}SYNOPSIS@{ub}
        gl.EndList()

   @{b}FUNCTION@{ub}
        See @{"gl.NewList" LINK glNewList} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.EndList() is called without a
        preceding @{"gl.NewList()" LINK glNewList}

@ENDNODE

@NODE glEvalCoord "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EvalCoord -- evaluate enabled one- and two-dimensional maps

   @{b}SYNOPSIS@{ub}
        gl.EvalCoord(u[, v])

   @{b}FUNCTION@{ub}
        gl.EvalCoord() evaluates enabled one- or two-dimensional maps at
        argument "u" or "u" and "v". To define a map, call @{"gl.Map()" LINK glMap}; to enable
        and disable it, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable}.

        When the gl.EvalCoord() command is issued, all currently enabled maps of
        the indicated dimension are evaluated. Then, for each enabled map, it is
        as if the corresponding GL command had been issued with the computed
        value. That is, if #GL_MAP1_INDEX or #GL_MAP2_INDEX is enabled, a
        @{"gl.Index()" LINK glIndex} command is simulated. If #GL_MAP1_COLOR_4 or #GL_MAP2_COLOR_4
        is enabled, a @{"gl.Color()" LINK glColor} command is simulated. If #GL_MAP1_NORMAL or
        #GL_MAP2_NORMAL is enabled, a normal vector is produced, and if any of
        the constants #GL_MAP1_TEXTURE_COORD_1, #GL_MAP1_TEXTURE_COORD_2,
        #GL_MAP1_TEXTURE_COORD_3, #GL_MAP1_TEXTURE_COORD_4, or also the
        constants #GL_MAP2_TEXTURE_COORD_1, #GL_MAP2_TEXTURE_COORD_2,
        #GL_MAP2_TEXTURE_COORD_3, or #GL_MAP2_TEXTURE_COORD_4 is enabled, then
        the GL will simulate an appropriate @{"gl.TexCoord()" LINK glTexCoord} command.

        For color, color index, normal, and texture coordinates the GL uses
        evaluated values instead of current values for those evaluations that
        are enabled, and current values otherwise, However, the evaluated values
        do not update the current values. Thus, if @{"gl.Vertex()" LINK glVertex} commands are
        interspersed with gl.EvalCoord() commands, the color, normal, and
        texture coordinates associated with the @{"gl.Vertex()" LINK glVertex} commands are not
        affected by the values generated by the gl.EvalCoord() commands, but
        only by the most recent @{"gl.Color()" LINK glColor}, @{"gl.Index()" LINK glIndex}, @{"gl.Normal()" LINK glNormal}, and
        @{"gl.TexCoord()" LINK glTexCoord} commands.

        No commands are issued for maps that are not enabled. If more than one
        texture evaluation is enabled for a particular dimension (for example,
        #GL_MAP2_TEXTURE_COORD_1 and #GL_MAP2_TEXTURE_COORD_2), then only the
        evaluation of the map that produces the larger number of coordinates (in
        this case, #GL_MAP2_TEXTURE_COORD_2) is carried out. #GL_MAP1_VERTEX_4
        overrides #GL_MAP1_VERTEX_3, and #GL_MAP2_VERTEX_4 overrides
        #GL_MAP2_VERTEX_3, in the same manner. If neither a three- nor a
        four-component vertex map is enabled for the specified dimension, the
        gl.EvalCoord() command is ignored.

        If you have enabled automatic normal generation, by calling @{"gl.Enable()" LINK glEnable}
        with argument #GL_AUTO_NORMAL, gl.EvalCoord() generates surface normals
        analytically, regardless of the contents or enabling of the
        #GL_MAP2_NORMAL map. If automatic normal generation is disabled, the
        corresponding normal map #GL_MAP2_NORMAL, if enabled, is used to produce
        a normal. If neither automatic normal generation nor a normal map is
        enabled, no normal is generated for gl.EvalCoord() commands.

        Alternatively, you can also pass a table containing one or two domain
        coordinates to gl.EvalCoord().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        u         specifies a value that is the domain coordinate u to the basis
                  function defined in a previous @{"gl.Map()" LINK glMap} command
        v         optional: specifies a value that is the domain coordinate v to
                  the basis function defined in a previous @{"gl.Map()" LINK glMap} command

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_VERTEX_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_VERTEX_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_INDEX

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_COLOR_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_NORMAL

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_1

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_2

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_VERTEX_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_VERTEX_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_INDEX

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_COLOR_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_NORMAL

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_1

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_2

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_AUTO_NORMAL

        @{"gl.GetMap()" LINK glGetMap}

@ENDNODE

@NODE glEvalMesh "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EvalMesh -- compute a one- or two-dimensional grid of points or lines

   @{b}SYNOPSIS@{ub}
        gl.EvalMesh(mode, i1, i2[, j1, j2])

   @{b}FUNCTION@{ub}
        This function can be used to compute a one- or two-dimensional grid of
        points or lines. If you omit the last two parameters, a one-dimensional
        mesh is computed, otherwise a two-dimensional will be computed.

        @{"gl.MapGrid()" LINK glMapGrid} and gl.EvalMesh() are used in tandem to efficiently
        generate and evaluate a series of evenly spaced map domain values.
        gl.EvalMesh() steps through the integer domain of a one- or
        two-dimensional grid, whose range is the domain of the evaluation maps
        specified by @{"gl.Map()" LINK glMap}. "mode" determines whether the resulting vertices
        are connected as points, lines, or filled polygons (the latter is only
        supported for two-dimensional grids). In the one-dimensional case,
        gl.EvalMesh(), the mesh is generated as if the following code fragment
        were executed:

            gl.Begin(type)
            For Local i = i1 To i2 Do gl.EvalCoord(i*du+u1)
            gl.End()

        where du = (u2-u1)/n and n, u1, and u2 are the arguments to the most
        recent @{"gl.MapGrid()" LINK glMapGrid} command. "type" is #GL_POINTS if mode is #GL_POINT,
        or #GL_LINES if mode is #GL_LINE. The one absolute numeric requirement
        is that if i = n, then the value computed from i*du+u1 is exactly u2.

        In the two-dimensional case, gl.EvalMesh(), let

            du = (u2-u1)/n
            dv = (v2-v1)/m,

        where n, u1, u2, m, v1, and v2 are the arguments to the most recent
        @{"gl.MapGrid()" LINK glMapGrid} command. Then, if mode is #GL_FILL, the gl.EvalMesh()
        command is equivalent to:

            For Local j = j1 To j2 - 1
               gl.Begin(#GL_QUAD_STRIP)
               For Local i = i1 To i2
                  gl.EvalCoord(i*du+u1, j*dv+v1)
                  gl.EvalCoord(i*du+u1, (j+1)*dv+v1)
               Next
               gl.End()
            Next

        If mode is #GL_LINE, then a call to gl.EvalMesh() is equivalent to:

            For Local j = j1 To j2
               gl.Begin(#GL_LINE_STRIP)
               For Local i = i1 To i2
                  gl.EvalCoord(i*du+u1, j*dv+v1)
               Next
               gl.End()
            Next

            For Local i = i1 To i2
               gl.Begin(#GL_LINE_STRIP)
               For Local j = j1 To j2
                  gl.EvalCoord(i*du+u1, j*dv+v1)
               Next
               gl.End()
            Next

        And finally, if mode is #GL_POINT, then a call to gl.EvalMesh() is
        equivalent to:

            gl.Begin(#GL_POINTS)
            For Local j = j1 To j2
               For Local i = i1 To i2
                  gl.EvalCoord(i*du+u1, j*dv+v1)
               Next
            Next
            gl.End()

        In all three cases, the only absolute.numeric requirements are that if i
        = n, then the value computed from i*du+u1 is exactly u2, and if j = m,
        then the value computed from j*dv+v1 is exactly v2.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies whether to compute a mesh of points, lines or
                  polygons; symbolic constants #GL_POINT, #GL_LINE, and in case
                  of a
        two       dimensional mesh, #GL_FILL are accepted
        i1        specify the first integer value for grid domain variable i
        i2        specify the last integer value for grid domain variable i
        j1        optional: specify the first integer value for grid domain
                  variable j
        j2        optional: specify the last integer value for grid domain
                  variable j

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.EvalMesh() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_SEGMENTS

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_SEGMENTS

@ENDNODE

@NODE glEvalPoint "GL Galore Guide"

   @{b}NAME@{ub}
        gl.EvalPoint -- generate and evaluate a single point in a mesh

   @{b}SYNOPSIS@{ub}
        gl.EvalPoint(i[, j])

   @{b}FUNCTION@{ub}
        @{"gl.MapGrid()" LINK glMapGrid} and @{"gl.EvalMesh()" LINK glEvalMesh} are used in tandem to efficiently
        generate and evaluate a series of evenly spaced map domain values.
        gl.EvalPoint() can be used to evaluate a single grid point in the same
        gridspace that is traversed by @{"gl.EvalMesh()" LINK glEvalMesh}. Calling gl.EvalPoint()
        with a single argument is equivalent to calling

            gl.EvalCoord(i*du+u1)

        where

            du = (u2-u1)/n

        and n, u1, and u2 are the arguments to the most recent @{"gl.MapGrid()" LINK glMapGrid}
        command. The one absolute numeric requirement is that if i = n, then the
        value computed from i*du+u1 is exactly u2.

        In the two-dimensional case, gl.EvalPoint(), let

            du = (u2-u1)/n
            dv = (v2-v1)/m

        where n, u1, u2, m, v1, and v2 are the arguments to the most recent
        @{"gl.MapGrid()" LINK glMapGrid} command. Then the gl.EvalPoint() command is equivalent to
        calling

            gl.EvalCoord(i*du+u1, j*dv+v1)

        The only absolute numeric requirements are that if i = n, then the value
        computed from i*du+u1 is exactly u2, and if j = m, then the value
        computed from j*dv+v1 is exactly v2.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        i         specifies the integer value for grid domain variable i
        j         optional: specifies the integer value for grid domain variable
                  j

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_SEGMENTS

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_SEGMENTS

@ENDNODE

@NODE glFeedbackBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.FeedbackBuffer -- controls feedback mode

   @{b}SYNOPSIS@{ub}
        buffer = gl.FeedbackBuffer(size, type)

   @{b}FUNCTION@{ub}
        The gl.FeedbackBuffer() function controls feedback. Feedback, like
        selection, is a GL mode. The mode is selected by calling @{"gl.RenderMode()" LINK glRenderMode}
        with #GL_FEEDBACK. When the GL is in feedback mode, no pixels are
        produced by rasterization. Instead, information about primitives that
        would have been rasterized is fed back to the application using the GL.

        gl.FeedbackBuffer() has two arguments: "size" indicates the size of the
        array that is to be returned, in items of #GL_FLOAT. "type" is a
        symbolic constant describing the information that is fed back for each
        vertex. gl.FeedbackBuffer() must be issued before feedback mode is
        enabled (by calling @{"gl.RenderMode()" LINK glRenderMode} with argument #GL_FEEDBACK). Setting
        #GL_FEEDBACK without establishing the feedback buffer, or calling
        gl.FeedbackBuffer() while the GL is in feedback mode, is an error.

        When @{"gl.RenderMode()" LINK glRenderMode} is called while in feedback mode, it returns the
        number of entries placed in the feedback array and resets the feedback
        array pointer to the base of the feedback buffer. The returned value
        never exceeds size. If the feedback data required more room than was
        available in buffer, @{"gl.RenderMode()" LINK glRenderMode} returns a negative value. To take
        the GL out of feedback mode, call @{"gl.RenderMode()" LINK glRenderMode} with a parameter value
        other than #GL_FEEDBACK.

        While in feedback mode, each primitive, bitmap, or pixel rectangle that
        would be rasterized generates a block of values that are copied into the
        feedback array. If doing so would cause the number of entries to exceed
        the maximum, the block is partially written so as to fill the array (if
        there is any room left at all), and an overflow flag is set. Each block
        begins with a code indicating the primitive type, followed by values
        that describe the primitive's vertices and associated data. Entries are
        also written for bitmaps and pixel rectangles. Feedback occurs after
        polygon culling and @{"gl.PolygonMode()" LINK glPolygonMode} interpretation of polygons has
        taken place, so polygons that are culled are not returned in the
        feedback buffer. It can also occur after polygons with more than three
        edges are broken up into triangles, if the GL implementation renders
        polygons by performing this decomposition.

        The @{"gl.PassThrough()" LINK glPassThrough} command can be used to insert a marker into the
        feedback buffer. See @{"gl.PassThrough" LINK glPassThrough} for details.

        Following is the grammar for the blocks of values written into the
        feedback buffer. Each primitive is indicated with a unique identifying
        value followed by some number of vertices. Polygon entries include an
        integer value indicating how many vertices follow. A vertex is fed back
        as some number of floating-point values, as determined by type. Colors
        are fed back as four values in RGBA mode and one value in color index
        mode.

        Feedback vertex coordinates are in window coordinates, except w, which
        is in clip coordinates. Feedback colors are lighted, if lighting is
        enabled. Feedback texture coordinates are generated, if texture
        coordinate generation is enabled. They are always transformed by the
        texture matrix

        gl.FeedbackBuffer(), when used in a display list, is not compiled into
        the display list but is executed immediately.

        Please note that gl.FeedbackBuffer() returns only the texture coordinate
        of texture unit #GL_TEXTURE0.

        To free a buffer allocated by this function, call
        @{"gl.FreeFeedbackBuffer()" LINK glFreeFeedbackBuffer}. See @{"gl.FreeFeedbackBuffer" LINK glFreeFeedbackBuffer} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        size      specifies the maximum number of values that will be returned
        type      specifies a symbolic constant that describes the information
                  that will be returned for each vertex; #GL_2D, #GL_3D,
                  #GL_3D_COLOR, #GL_3D_COLOR_TEXTURE, and #GL_4D_COLOR_TEXTURE
                  are accepted

   @{b}RESULTS@{ub}
        buffer    pointer to feedback buffer

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "type" is not an accepted value.

        #GL_INVALID_VALUE is generated if "size" is negative.

        #GL_INVALID_OPERATION is generated if gl.FeedbackBuffer() is called
        while the render mode is #GL_FEEDBACK, or if @{"gl.RenderMode()" LINK glRenderMode} is called
        with argument #GL_FEEDBACK before gl.FeedbackBuffer() is called at least
        once.

        #GL_INVALID_OPERATION is generated if gl.FeedbackBuffer() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_RENDER_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_FEEDBACK_BUFFER_POINTER

        @{"gl.Get()" LINK glGet} with argument #GL_FEEDBACK_BUFFER_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_FEEDBACK_BUFFER_TYPE

@ENDNODE

@NODE glFinish "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Finish -- block until all GL execution is complete

   @{b}SYNOPSIS@{ub}
        gl.Finish()

   @{b}FUNCTION@{ub}
        gl.Finish() does not return until the effects of all previously called
        GL commands are complete. Such effects include all changes to GL state,
        all changes to connection state, and all changes to the frame buffer
        contents.

        gl.Finish() requires a round trip to the server.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.Finish() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glFlush "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Flush -- force execution of GL commands in finite time

   @{b}SYNOPSIS@{ub}
        gl.Flush()

   @{b}FUNCTION@{ub}
        Different GL implementations buffer commands in several different
        locations, including network buffers and the graphics accelerator
        itself. glFlush empties all of these buffers, causing all issued
        commands to be executed as quickly as they are accepted by the actual
        rendering engine. Though this execution may not be completed in any
        particular time period, it does complete in finite time.

        Because any GL program might be executed over a network, or on an
        accelerator that buffers commands, all programs should call gl.Flush()
        whenever they count on having all of their previously issued commands
        completed. For example, call gl.Flush() before waiting for user input
        that depends on the generated image.

        gl.Flush() can return at any time. It does not wait until the execution
        of all previously issued GL commands is complete.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.Flush() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glFog "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Fog -- specify fog parameters

   @{b}SYNOPSIS@{ub}
        gl.Fog(pname, param)

   @{b}FUNCTION@{ub}
        Fog is initially disabled. While enabled, fog affects rasterized
        geometry, bitmaps, and pixel blocks, but not buffer clear operations. To
        enable and disable fog, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with argument
        #GL_FOG.

        gl.Fog() assigns the value or values in params to the fog parameter
        specified by "pname". The following values are accepted for pname:

        #GL_FOG_MODE
                  "param" is a single floating-point value that specifies the
                  equation to be used to compute the fog blend factor, f. Three
                  symbolic constants are accepted: #GL_LINEAR, #GL_EXP, and
                  #GL_EXP2. The equations corresponding to these symbolic
                  constants are defined below. The initial fog mode is #GL_EXP.

        #GL_FOG_DENSITY
                  "param" is a single floating-point value that specifies
                  density, the fog density used in both exponential fog
                  equations. Only nonnegative densities are accepted. The
                  initial fog density is 1.

        #GL_FOG_START
                  "param" is a single floating-point value that specifies start,
                  the near distance used in the linear fog equation. The initial
                  near distance is 0.

        #GL_FOG_END
                  "param" is a single floating-point value that specifies end,
                  the far distance used in the linear fog equation. The initial
                  far distance is 1.

        #GL_FOG_INDEX
                  "param" is a single floating-point value that specifies i f,
                  the fog color index. The initial fog index is 0.

        #GL_FOG_COLOR
                  "param" must be a table containing four floating-point values
                  that specify Cf, the fog color. All color components are
                  clamped to the range [0,1]. The initial fog color is (0, 0, 0,
                  0).

        Fog blends a fog color with each rasterized pixel fragment's
        post-texturing color using a blending factor f. Factor f is computed in
        one of three ways, depending on the fog mode. Let c be the distance in
        eye coordinates from the origin to the fragment being fogged. The
        equation for #GL_LINEAR fog is

            f = (end - c) / (end - start)

        The equation for #GL_EXP fog is

            f = e^(-density*c)

        The equation for #GL_EXP2 fog is

            f = e^(-density*c)^2

        Regardless of the fog mode, f is clamped to the range [0,1] after it is
        computed. Then, if the GL is in RGBA color mode, the fragment's red,
        green, and blue colors, represented by Cr, are replaced by

            Cr' = f*Cr+(1-f)*Cf

        Fog does not affect a fragment's alpha component.

        In color index mode, the fragment's color index ir is replaced by

            ir' = f*ir+(1-f)*if

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies a single-valued fog parameter; #GL_FOG_MODE,
                  #GL_FOG_DENSITY, #GL_FOG_START, #GL_FOG_END, #GL_FOG_INDEX,
                  and #GL_FOG_COLOR are accepted
        param     specifies the value that "pname" will be set to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value, or if
        "pname" is #GL_FOG_MODE and "param" is not an accepted value.

        #GL_INVALID_VALUE is generated if "pname" is #GL_FOG_DENSITY and "param"
        is negative.

        #GL_INVALID_OPERATION is generated if gl.Fog() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_FOG

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_INDEX

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_DENSITY

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_START

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_END

        @{"gl.Get()" LINK glGet} with argument #GL_FOG_MODE

@ENDNODE

@NODE glFreeFeedbackBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.FreeFeedbackBuffer -- free feedback mode buffer

   @{b}SYNOPSIS@{ub}
        gl.FreeFeedbackBuffer(buffer)

   @{b}FUNCTION@{ub}
        This function frees a buffer allocated by @{"gl.FeedbackBuffer()" LINK glFeedbackBuffer}. See
        @{"gl.FeedbackBuffer" LINK glFeedbackBuffer} for details.

        Note that this function doesn't detach the buffer from the GL. You need
        to do this manually, e.g. by changing the render mode using
        @{"gl.RenderMode()" LINK glRenderMode}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        buffer    a buffer allocated by @{"gl.FeedbackBuffer()" LINK glFeedbackBuffer}

@ENDNODE

@NODE glFreeSelectBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.FreeSelectBuffer -- free selection mode buffer

   @{b}SYNOPSIS@{ub}
        gl.FreeSelectBuffer(buffer)

   @{b}FUNCTION@{ub}
        This function frees a buffer allocated by @{"gl.SelectBuffer()" LINK glSelectBuffer}. See
        @{"gl.SelectBuffer" LINK glSelectBuffer} for details.

        Note that this function doesn't detach the buffer from the GL. You need
        to do this manually, e.g. by changing the render mode using
        @{"gl.RenderMode()" LINK glRenderMode}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        buffer    a buffer allocated by @{"gl.SelectBuffer()" LINK glSelectBuffer}

@ENDNODE

@NODE glFrontFace "GL Galore Guide"

   @{b}NAME@{ub}
        gl.FrontFace -- define front- and back-facing polygons

   @{b}SYNOPSIS@{ub}
        gl.FrontFace(mode)

   @{b}FUNCTION@{ub}
        In a scene composed entirely of opaque closed surfaces, back-facing
        polygons are never visible. Eliminating these invisible polygons has the
        obvious benefit of speeding up the rendering of the image. To enable and
        disable elimination of back-facing polygons, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_CULL_FACE.

        The projection of a polygon to window coordinates is said to have
        clockwise winding if an imaginary object following the path from its
        first vertex, its second vertex, and so on, to its last vertex, and
        finally back to its first vertex, moves in a clockwise direction about
        the interior of the polygon. The polygon's winding is said to be
        counterclockwise if the imaginary object following the same path moves
        in a counterclockwise direction about the interior of the polygon.
        gl.FrontFace() specifies whether polygons with clockwise winding in
        window coordinates, or counterclockwise winding in window coordinates,
        are taken to be front-facing. Passing #GL_CCW to mode selects
        counterclockwise polygons as front-facing; #GL_CW selects clockwise
        polygons as front-facing. By default, counterclockwise polygons are
        taken to be front-facing.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies the orientation of front-facing polygons; #GL_CW and
                  #GL_CCW are accepted; the initial value is #GL_CCW

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.FrontFace() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_FRONT_FACE

@ENDNODE

@NODE glFrustum "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Frustum -- multiply the current matrix by a perspective matrix

   @{b}SYNOPSIS@{ub}
        gl.Frustum(left, right, bottom, top, zNear, zFar)

   @{b}FUNCTION@{ub}
        gl.Frustum() describes a perspective matrix that produces a perspective
        projection. (left,bottom,-zNear) and (right,top,-zNear) specify the
        points on the near clipping plane that are mapped to the lower left and
        upper right corners of the window, respectively, assuming that the eye
        is located at (0, 0, 0). -zFar specifies the location of the far
        clipping plane. Both "zNear" and "zFar" must be positive. Consult an
        OpenGL reference for the corresponding matrix.

        The current matrix is multiplied by this matrix with the result
        replacing the current matrix. That is, if M is the current matrix and F
        is the frustum perspective matrix, then M is replaced with M*F.

        Use @{"gl.PushMatrix()" LINK glPushMatrix} and @{"gl.PopMatrix()" LINK glPopMatrix} to save and restore the current
        matrix stack.

        Depth buffer precision is affected by the values specified for zNear and
        zFar. The greater the ratio of far to near is, the less effective the
        depth buffer will be at distinguishing between surfaces that are near
        each other. If

            r = zFar / zNear

        roughly ld(r) bits of depth buffer precision are lost. Because r
        approaches infinity as zNear approaches zero, zNear must never be set to
        zero.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        left      specify the coordinate for the left vertical clipping plane
        right     specify the coordinate for the right vertical clipping plane
        bottom    specify the coordinate for the bottom horizontal clipping
                  plane
        top       specify the coordinate for the top horizontal clipping plane
        zNear     specify the distance to the near depth clipping plane; must be
                  positive
        zFar      specify the distance to the far depth clipping plane; must be
                  positive

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "zNear" or "zFar" is not positive, or
        if left = right, or bottom = top, or zNear = zFar.

        #GL_INVALID_OPERATION is generated if gl.Frustum() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glGenLists "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GenLists -- generate a contiguous set of empty display lists

   @{b}SYNOPSIS@{ub}
        num = gl.GenLists(range)

   @{b}FUNCTION@{ub}
        gl.GenLists() has one argument, "range". It returns an integer n such
        that "range" contiguous empty display lists, named n, n + 1,..., n +
        range - 1, are created. If "range" is 0, if there is no group of range
        contiguous names available, or if any error is generated, no display
        lists are generated, and 0 is returned.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        range     specifies the number of contiguous empty display lists to be
                  generated

   @{b}RESULTS@{ub}
        num       name of first empty display list

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "range" is negative.

        #GL_INVALID_OPERATION is generated if gl.GenLists() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsList()" LINK glIsList}

@ENDNODE

@NODE glGenTextures "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GenTextures -- generate texture names

   @{b}SYNOPSIS@{ub}
        texturesArray = gl.GenTextures(n)

   @{b}FUNCTION@{ub}
        gl.GenTextures() generates "n" texture names and returns them in the
        table "texturesArray". There is no guarantee that the names form a
        contiguous set of integers; however, it is guaranteed that none of the
        returned names was in use immediately before the call to
        gl.GenTextures().

        The generated textures have no dimensionality; they assume the
        dimensionality of the texture target to which they are first bound See
        @{"gl.BindTexture" LINK glBindTexture} for details. ().

        Texture names returned by a call to gl.GenTextures() are not returned by
        subsequent calls, unless they are first deleted with @{"gl.DeleteTextures()" LINK glDeleteTextures}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        n         specifies the number of texture names to be generated

   @{b}RESULTS@{ub}
        texturesArray
                  table containing "n" number of texture names

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "n" is negative.

        #GL_INVALID_OPERATION is generated if gl.GenTextures() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsTexture()" LINK glIsTexture}

@ENDNODE

@NODE glGet "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Get --  return the value or values of a selected parameter

   @{b}SYNOPSIS@{ub}
        param, ... = gl.Get(pname)

   @{b}FUNCTION@{ub}
        This command return values for simple state variables in GL. "pname" is
        a symbolic constant indicating the state variable to be returned. The
        following symbolic constants are accepted by "pname":

        #GL_ACCUM_ALPHA_BITS
                  "param" returns one value, the number of alpha bitplanes in
                  the accumulation buffer.
        #GL_ACCUM_BLUE_BIT
                  "param" returns one value, the number of blue bitplanes in the
                  accumulation buffer.
        #GL_ACCUM_CLEAR_VALUE
                  "param" returns four values: the red, greeen, blue, and alpha
                  values used to clear the accumulation buffer. See
                  @{"gl.ClearAccum" LINK glClearAccum} for details.
        #GL_ACCUM_GREEN_BITS
                  "param" returns one value, the number of green bitplanes in
                  the accumulation buffer.
        #GL_ACCUM_RED_BITS
                  "param" returns one value, the number of red bitplanes in the
                  accumulation buffer.
        #GL_ALPHA_BIAS
                  "param" returns one value, the alpha bias factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_ALPHA_BITS
                  "param" returns one value, the number of alpha bitplanes in
                  each color buffer.
        #GL_ALPHA_SCALE
                  "param" returns one value, the alpha scale factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_ALPHA_TEST
                  "param" returns a single Boolean value indicating whether
                  alpha testing of fragments is enabled. See @{"gl.AlphaFunc" LINK glAlphaFunc} for
                  details.
        #GL_ALPHA_TEST_FUNC
                  "param" returns one value, the symbolic name of the alpha test
                  function. See @{"gl.AlphaFunc" LINK glAlphaFunc} for details.
        #GL_ALPHA_TEST_REF
                  "param" returns one value, the reference value for the alpha
                  test. See @{"gl.AlphaFunc" LINK glAlphaFunc} for details.
        #GL_ATTRIB_STACK_DEPTH
                  "param" returns one value, the depth of the attribute stack.
                  If the stack is empty, zero is returned. See @{"gl.PushAttrib" LINK glPushAttrib} for
                  details.
        #GL_AUTO_NORMAL
                  "param" returns a single Boolean value indicating whether 2-D
                  map evaluation automatically generates surface normals. See
                  @{"gl.Map" LINK glMap} for details.
        #GL_AUX_BUFFERS
                  "param" returns one value, the number of auxiliary color
                  buffers.
        #GL_BLEND "param" returns a single Boolean value indicating whether
                  blending is enabled. See @{"gl.BlendFunc" LINK glBlendFunc} for details.
        #GL_BLEND_DST
                  "param" returns one value, the symbolic constant identifying
                  the destination blend function. See @{"gl.BlendFunc" LINK glBlendFunc} for details.
        #GL_BLEND_SRC
                  "param" returns one value, the symbolic constant identifying
                  the source blend function. See @{"gl.BlendFunc" LINK glBlendFunc} for details.
        #GL_BLUE_BIAS
                  "param" returns one value, the blue bias factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_BLUE_BITS
                  "param" returns one value, the number of blue bitplanes in
                  each color buffer.
        #GL_BLUE_SCALE
                  "param" returns one value, the blue scale factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_CLIP_PLANEi
                  "param" returns a single Boolean value indicating whether the
                  specified clipping plane is enabled. See @{"gl.ClipPlane" LINK glClipPlane} for
                  details..
        #GL_COLOR_CLEAR_VALUE
                  "param" returns four values: the red, green, blue, and alpha
                  values used to clear the color buffers. See @{"gl.ClearColor" LINK glClearColor} for
                  details..
        #GL_COLOR_MATERIAL
                  "param" returns a single Boolean value indicating whether one
                  or more material parameters are tracking the current color.
                  See @{"gl.ColorMaterial" LINK glColorMaterial} for details.
        #GL_COLOR_MATERIAL_FACE
                  "param" returns one value, a symbolic constant indicating
                  which materials have a parameter that is tracking the current
                  color. See @{"gl.ColorMaterial" LINK glColorMaterial} for details.
        #GL_COLOR_MATERIAL_PARAMETER
                  "param" returns one value, a symbolic constant indicating
                  which material parameters are tracking the current color. See
                  @{"gl.ColorMaterial" LINK glColorMaterial} for details.
        #GL_COLOR_WRITEMASK
                  "param" returns four Boolean values: the red, green, blue, and
                  alpha write enables for the color buffers. See @{"gl.ColorMask" LINK glColorMask}
                  for details.
        #GL_CULL_FACE
                  "param" returns a single Boolean value indicating whether
                  polygon culling is enabled. See @{"gl.CullFace" LINK glCullFace} for details.
        #GL_CULL_FACE_MODE
                  "param" returns one value, a symbolic constant indicating
                  which polygon faces are to be culled. See @{"gl.CullFace" LINK glCullFace} for
                  details.
        #GL_CURRENT_COLOR
                  "param" returns four values: the red, green, blue, and alpha
                  values of the current color. See @{"gl.Color" LINK glColor} for details.
        #GL_CURRENT_INDEX
                  "param" returns one value, the current color index. See
                  @{"gl.Index" LINK glIndex} for details.
        #GL_CURRENT_NORMAL
                  "param" returns three values: the x, y, and z values of the
                  current normal. See @{"gl.Normal" LINK glNormal} for details.
        #GL_CURRENT_RASTER_COLOR
                  "param" returns four values: the red, green, blue, and alpha
                  values of the current raster position. See @{"gl.RasterPos" LINK glRasterPos} for
                  details.
        #GL_CURRENT_RASTER_INDEX
                  "param" returns one value, the color index of the current
                  raster position. See @{"gl.RasterPos" LINK glRasterPos} for details.
        #GL_CURRENT_RASTER_POSITION
                  "param" returns four values: the x, y, z, and w components of
                  the current raster position. x, y, and z are in window
                  coordinates, and w is in clip coordinates. See @{"gl.RasterPos" LINK glRasterPos}
                  for details.
        #GL_CURRENT_RASTER_TEXTURE_COORDS
                  "param" returns four values: the s, t, r, and q current raster
                  texture coordinates. See @{"gl.RasterPos" LINK glRasterPos} for details. See
                  @{"gl.TexCoord" LINK glTexCoord} for details.
        #GL_CURRENT_RASTER_POSITION_VALID
                  "param" returns a single Boolean value indicating whether the
                  current raster position is valid. See @{"gl.RasterPos" LINK glRasterPos} for
                  details.
        #GL_CURRENT_TEXTURE_COORDS
                  "param" returns four values: the s, t, r, and q current
                  texture coordinates. See @{"gl.TexCoord" LINK glTexCoord} for details.
        #GL_DEPTH_BITS
                  "param" returns one value, the number of bitplanes in the
                  depth buffer.
        #GL_DEPTH_CLEAR_VALUE
                  "param" returns one value, the value that is used to clear the
                  depth buffer. See @{"gl.ClearDepth" LINK glClearDepth} for details.
        #GL_DEPTH_FUNC
                  "param" returns one value, the symbolic constant that
                  indicates the depth comparison function. See @{"gl.DepthFunc" LINK glDepthFunc} for
                  details.
        #GL_DEPTH_RANGE
                  "param" returns two values: the near and far mapping limits
                  for the depth buffer. See @{"gl.DepthRange" LINK glDepthRange} for details.
        #GL_DEPTH_WRITEMASK
                  "param" returns a single Boolean value indicating if the depth
                  buffer is enabled for writing. See @{"gl.DepthMask" LINK glDepthMask} for details.
        #GL_DOUBLEBUFFER
                  "param" returns a single Boolean value indicating whether
                  double buffering is supported.
        #GL_DRAW_BUFFER
                  "param" returns one value, a symbolic constant indicating
                  which buffers are being drawn to. See @{"gl.DrawBuffer" LINK glDrawBuffer} for
                  details.
        #GL_EDGE_FLAG
                  "param" returns a single Boolean value indication whether the
                  current edge flag is true or false. See @{"gl.EdgeFlag" LINK glEdgeFlag} for
                  details.
        #GL_FOG   "param" returns a single Boolean value indicating whether
                  fogging is enabled. See @{"gl.Fog" LINK glFog} for details.
        #GL_FOG_COLOR
                  "param" returns four values: the red, green, blue, and alpha
                  components of the fog color. See @{"gl.Fog" LINK glFog} for details.
        #GL_FOG_DENSITY
                  "param" returns one value, the fog density parameter. See
                  @{"gl.Fog" LINK glFog} for details.
        #GL_FOG_END
                  "param" returns one value, the end factor for the linear fog
                  equation. See @{"gl.Fog" LINK glFog} for details.
        #GL_FOG_HINT
                  "param" returns one value, a symbolic constant indicating the
                  mode of the fog hint. See See @{"gl.Hint" LINK glHint} for details.
        #GL_FOG_INDEX
                  "param" returns one value, the fog color index. See @{"gl.Fog" LINK glFog} for
                  details.
        #GL_FOG_MODE
                  "param" returns one value, a symbolic constant indicating
                  which fog equation is selected. See @{"gl.Fog" LINK glFog} for details.
        #GL_FOG_START
                  "param" returns one value, the start factor for the linear fog
                  equation. See @{"gl.Fog" LINK glFog} for details.
        #GL_FRONT_FACE
                  "param" returns one value, a symbolic constant indicating
                  whether clockwise or counterclockwise polygon winding is
                  treated as front-facing. See @{"gl.FrontFace" LINK glFrontFace} for details.
        #GL_GREEN_BIAS
                  "param" returns one value, the green bias factor used during
                  pixel transfers.
        #GL_GREEN_BITS
                  "param" returns one value, the number of green bitplanes in
                  each color buffer.
        #GL_GREEN_SCALE
                  "param" returns one value, the green scale factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_INDEX_BITS
                  "param" returns one value, the number of bitplanes in each
                  color index buffer.
        #GL_INDEX_CLEAR_VALUE
                  "param" returns one value, the color index used to clear the
                  color index buffers. See @{"gl.ClearIndex" LINK glClearIndex} for details.
        #GL_INDEX_MODE
                  "param" returns a single Boolean value indicating whether the
                  GL is in color index mode (true) or RGBA mode (false).
        #GL_INDEX_OFFSET
                  "param" returns one value, the offset added to color and
                  stencil indices during pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer}
                  for details.
        #GL_INDEX_SHIFT
                  "param" returns one value, the amount that color and stencil
                  indices are shifted during pixel transfers. See
                  @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_INDEX_WRITEMASK
                  "param" returns one value, a mask indicating which bitplanes
                  of each color index buffer can be written. See @{"gl.IndexMask" LINK glIndexMask}
                  for details.
        #GL_LIGHTi
                  "param" returns a single Boolean value indicating whether the
                  specified light is enabled. See @{"gl.Light" LINK glLight} for details. See
                  @{"gl.LightModel" LINK glLightModel} for details.
        #GL_LIGHTING
                  "param" returns a single Boolean value indicating whether
                  lighting is enabled. See @{"gl.LightModel" LINK glLightModel} for details.
        #GL_LIGHT_MODEL_AMBIENT
                  "param" returns four values: the red, green, blue, and alpha
                  components of the ambient intensity of the entire scene. See
                  @{"gl.LightModel" LINK glLightModel} for details.
        #GL_LIGHT_MODEL_LOCAL_VIEWER
                  "param" returns a single Boolean value indicating whether
                  specular reflection calculations treat the viewer as being
                  local to the scene. See @{"gl.LightModel" LINK glLightModel} for details.
        #GL_LIGHT_MODEL_TWO_SIDE
                  "param" returns a single Boolean value indicating whether
                  separate materials are used to compute lighting for front- and
                  back-facing polygons. See @{"gl.LightModel" LINK glLightModel} for details.
        #GL_LINE_SMOOTH
                  "param" returns a single Boolean value indicating whether
                  antialiasing of lines is enabled. See @{"gl.LineWidth" LINK glLineWidth} for
                  details.
        #GL_LINE_STIPPLE
                  "param" returns a single Boolean value indicating whether
                  stippling of lines is enabled. See @{"gl.LineStipple" LINK glLineStipple} for details.
        #GL_LINE_STIPPLE_PATTERN
                  "param" returns one value, the 16-bit line stipple pattern.
                  See @{"gl.LineStipple" LINK glLineStipple} for details.
        #GL_LINE_STIPPLE_REPEAT
                  "param" returns one value, the line stipple repeat factor. See
                  @{"gl.LineStipple" LINK glLineStipple} for details.
        #GL_LINE_WIDTH
                  "param" returns one value, the line width as specified with
                  @{"gl.LineWidth()" LINK glLineWidth}.
        #GL_LINE_WIDTH_GRANULARITY
                  "param" returns one value, the width difference between
                  adjacent supported widths for antialiased lines. See
                  @{"gl.LineWidth" LINK glLineWidth} for details.
        #GL_LINE_WIDTH_RANGE
                  "param" returns two values: the smallest and largest supported
                  widths for antialiased lines. See @{"gl.LineWidth" LINK glLineWidth} for details.
        #GL_LIST_BASE
                  "param" returns one value, the base offset added to all names
                  in arrays presented to @{"gl.CallLists()" LINK glCallLists}. See @{"gl.ListBase" LINK glListBase} for
                  details.
        #GL_LIST_INDEX
                  "param" returns one value, the name of the display list
                  currently under construction. Zero is returned if no display
                  list is currently under construction. See @{"gl.NewList" LINK glNewList} for
                  details.
        #GL_LIST_MODE
                  "param" returns one value, a symbolic constant indicating the
                  construction mode of the display list currently being
                  constructed. See @{"gl.NewList" LINK glNewList} for details.
        #GL_LOGIC_OP
                  "param" returns a single Boolean value indicating whether
                  fragment indexes are merged into the framebuffer using a
                  logical operation. See @{"gl.LogicOp" LINK glLogicOp} for details.
        #GL_LOGIC_OP_MODE
                  "param" returns one value, a symbolic constant indicating the
                  selected logic operational mode. See @{"gl.LogicOp" LINK glLogicOp} for details.
        #GL_MAP1_COLOR_4
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates colors. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_GRID_DOMAIN
                  "param" returns two values: the endpoints of the 1-D map's
                  grid domain. See @{"gl.MapGrid" LINK glMapGrid} for details.
        #GL_MAP1_GRID_SEGMENTS
                  "param" returns one value, the number of partitions in the 1-D
                  map's grid domain. See @{"gl.MapGrid" LINK glMapGrid} for details.
        #GL_MAP1_INDEX
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates color indices. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_NORMAL
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates normals. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_TEXTURE_COORD_1
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 1D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP1_TEXTURE_COORD_2
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 2D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP1_TEXTURE_COORD_3
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 3D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP1_TEXTURE_COORD_4
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 4D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP1_VERTEX_3
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 3D vertex coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP1_VERTEX_4
                  "param" returns a single Boolean value indicating whether 1D
                  evaluation generates 4D vertex coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_COLOR_4
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates colors. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_GRID_DOMAIN
                  "param" returns four values: the endpoints of the 2-D map's i
                  and j grid domains. See @{"gl.MapGrid" LINK glMapGrid} for details.
        #GL_MAP2_GRID_SEGMENTS
                  "param" returns two values: the number of partitions in the
                  2-D map's i and j grid domains. See @{"gl.MapGrid" LINK glMapGrid} for details.
        #GL_MAP2_INDEX
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates color indices. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_NORMAL
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates normals. See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_TEXTURE_COORD_1
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 1D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_TEXTURE_COORD_2
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 2D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_TEXTURE_COORD_3
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 3D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_TEXTURE_COORD_4
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 4D texture coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_VERTEX_3
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 3D vertex coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP2_VERTEX_4
                  "param" returns a single Boolean value indicating whether 2D
                  evaluation generates 4D vertex coordinates. See @{"gl.Map" LINK glMap} for
                  details.
        #GL_MAP_COLOR
                  "param" returns a single Boolean value indicating if colors
                  and color indices are to be replaced by table lookup during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_MAP_STENCIL
                  "param" returns a single Boolean value indicating if stencil
                  indices are to be replaced by table lookup during pixel
                  transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_MATRIX_MODE
                  "param" returns one value, a symbolic constant indicating
                  which matrix stack is currently the target of all matrix
                  operations. See glMatrixMode.
        #GL_MAX_ATTRIB_STACK_DEPTH
                  "param" returns one value, the maximum supported depth of the
                  attribute stack. See @{"gl.PushAttrib" LINK glPushAttrib} for details.
        #GL_MAX_CLIP_PLANES
                  "param" returns one value, the maximum number of
                  application-defined clipping planes. See @{"gl.ClipPlane" LINK glClipPlane} for
                  details.
        #GL_MAX_EVAL_ORDER
                  "param" returns one value, the maximum equation order
                  supported by 1-D and 2-D evaluators. See @{"gl.Map" LINK glMap} for details.
        #GL_MAX_LIGHTS
                  "param" returns one value, the maximum number of lights. See
                  @{"gl.Light" LINK glLight} for details.
        #GL_MAX_LIST_NESTING
                  "param" returns one value, the maximum recursion depth allowed
                  during display-list traversal. See @{"gl.CallList" LINK glCallList} for details.
        #GL_MAX_MODELVIEW_STACK_DEPTH
                  "param" returns one value, the maximum supported depth of the
                  modelview matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_MAX_NAME_STACK_DEPTH
                  "param" returns one value, the maximum supported depth of the
                  selection name stack. See @{"gl.PushName" LINK glPushName} for details.
        #GL_MAX_PIXEL_MAP_TABLE
                  "param" returns one value, the maximum supported size of a
                  glPixelMap lookup table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_MAX_PROJECTION_STACK_DEPTH
                  "param" returns one value, the maximum supported depth of the
                  projection matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_MAX_TEXTURE_SIZE
                  "param" returns one value, the maximum width or height of any
                  texture image (without borders). See @{"gl.TexImage1D" LINK glTexImage1D} for
                  details. See @{"gl.TexImage2D" LINK glTexImage2D} for details.
        #GL_MAX_TEXTURE_STACK_DEPTH
                  "param" returns one value, the maximum supported depth of the
                  texture matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_MAX_VIEWPORT_DIMS
                  "param" returns two values: the maximum supported width and
                  height of the viewport. See @{"gl.Viewport" LINK glViewport} for details.
        #GL_MODELVIEW_MATRIX
                  "param" returns sixteen values: the modelview matrix on the
                  top of the modelview matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for
                  details.
        #GL_MODELVIEW_STACK_DEPTH
                  "param" returns one value, the number of matrices on the
                  modelview matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_NAME_STACK_DEPTH
                  "param" returns one value, the number of names on the
                  selection name stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_NORMALIZE
                  "param" returns a single Boolean value indicating whether
                  normals are automatically scaled to unit length after they
                  have been transformed to eye coordinates. See @{"gl.Normal" LINK glNormal} for
                  details.
        #GL_PACK_ALIGNMENT
                  "param" returns one value, the byte alignment used for writing
                  pixel data to memory. See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_PACK_LSB_FIRST
                  "param" returns a single Boolean value indicating whether
                  single-bit pixels being written to memory are written first to
                  the least significant bit of each unsigned byte. See
                  @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_PACK_ROW_LENGTH
                  "param" returns one value, the row length used for writing
                  pixel data to memory. See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_PACK_SKIP_PIXELS
                  "param" returns one value, the number of pixel locations
                  skipped before the first pixel is written into memory. See
                  @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_PACK_SKIP_ROWS
                  "param" returns one value, the number of rows of pixel
                  locations skipped before the first pixel is written into
                  memory. See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_PACK_SWAP_BYTES
                  "param" returns a single Boolean value indicating whether the
                  bytes of two-byte and four-byte pixel indices and components
                  are swapped before being written to memory. See @{"gl.PixelStore" LINK glPixelStore}
                  for details.
        #GL_PIXEL_MAP_A_TO_A_SIZE
                  "param" returns one value the size of the alpha-to-alpha pixel
                  translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_B_TO_B_SIZE
                  "param" returns one value, the size of the blue-to-blue pixel
                  translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_G_TO_G_SIZE
                  "param" returns one value, the size of the green-to-green
                  pixel translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_I_TO_A_SIZE
                  "param" returns one value, the size of the index-to-alpha
                  pixel translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_I_TO_B_SIZE
                  "param" returns one value, the size of the index-to-blue pixel
                  translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_I_TO_G_SIZE
                  "param" returns one value, the size of the index-to-green
                  pixel translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_I_TO_I_SIZE
                  "param" returns one value, the size of the index-to-index
                  pixel translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_I_TO_R_SIZE
                  "param" returns one value, the size of the index-to-red pixel
                  translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_R_TO_R_SIZE
                  "param" returns one value, the size of the red-to-red pixel
                  translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_PIXEL_MAP_S_TO_S_SIZE
                  "param" returns one value, the size of the stencil-to-stencil
                  pixel translation table. See @{"gl.PixelMap" LINK glPixelMap} for details.
        #GL_POINT_SIZE
                  "param" returns one value, the point size as specified by
                  @{"gl.PointSize()" LINK glPointSize}.
        #GL_POINT_SIZE_GRANULARITY
                  "param" returns one value, the size difference between
                  adjacent supported sizes for antialiased points. See
                  @{"gl.PointSize" LINK glPointSize} for details.
        #GL_POINT_SIZE_RANGE
                  "param" returns two values: the smallest and largest supported
                  sizes for antialiased points. See @{"gl.PointSize" LINK glPointSize} for details.
        #GL_POINT_SMOOTH
                  "param" returns a single Boolean value indicating whether
                  antialiasing of points is enabled. See @{"gl.PointSize" LINK glPointSize} for
                  details.
        #GL_POLYGON_MODE
                  "param" returns two values: symbolic constants indicating
                  whether front-facing and back-facing polygons are rasterized
                  as points, lines, or filled polygons. See @{"gl.PolygonMode" LINK glPolygonMode} for
                  details.
        #GL_POLYGON_SMOOTH
                  "param" returns a single Boolean value indicating whether
                  antialiasing of polygons is enabled. See @{"gl.PolygonMode" LINK glPolygonMode} for
                  details.
        #GL_POLYGON_STIPPLE
                  "param" returns a single Boolean value indicating whether
                  stippling of polygons is enabled. See @{"gl.PolygonStipple" LINK glPolygonStipple} for
                  details.
        #GL_PROJECTION_MATRIX
                  "param" returns sixteen values: the projection matrix on the
                  top of the projection matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for
                  details.
        #GL_PROJECTION_STACK_DEPTH
                  "param" returns one value, the number of matrices on the
                  projection matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_READ_BUFFER
                  "param" returns one value, a symbolic constant indicating
                  which color buffer is selected for reading. See @{"gl.ReadPixels" LINK glReadPixels}
                  for details. See @{"gl.Accum" LINK glAccum} for details.
        #GL_RED_BIAS
                  "param" returns one value, the red bias factor used during
                  pixel transfers.
        #GL_RED_BITS
                  "param" returns one value, the number of red bitplanes in each
                  color buffer.
        #GL_RED_SCALE
                  "param" returns one value, the red scale factor used during
                  pixel transfers. See @{"gl.PixelTransfer" LINK glPixelTransfer} for details.
        #GL_RENDER_MODE
                  "param" returns one value, a symbolic constant indicating
                  whether the GL is in render, select, or feedback mode. See
                  @{"gl.RenderMode" LINK glRenderMode} for details.
        #GL_RGBA_MODE
                  "param" returns a single Boolean value indicating whether the
                  GL is in RGBA mode (true) or color index mode (false). See
                  @{"gl.Color" LINK glColor} for details.
        #GL_SCISSOR_BOX
                  "param" returns four values: the x and y window coordinates of
                  the scissor box, follow by its width and height. See
                  @{"gl.Scissor" LINK glScissor} for details.
        #GL_SCISSOR_TEST
                  "param" returns a single Boolean value indicating whether
                  scissoring is enabled. See @{"glScisscor" LINK glScissor} for details.
        #GL_SHADE_MODEL
                  "param" returns one value, a symbolic constant indicating
                  whether the shading mode is flat or smooth. See @{"gl.ShadeModel" LINK glShadeModel}
                  for details.
        #GL_STENCIL_BITS
                  "param" returns one value, the number of bitplanes in the
                  stencil buffer.
        #GL_STENCIL_CLEAR_VALUE
                  "param" returns one value, the index to which the stencil
                  bitplanes are cleared. See @{"gl.ClearStencil" LINK glClearStencil} for details.
        #GL_STENCIL_FAIL
                  "param" returns one value, a symbolic constant indicating what
                  action is taken when the stencil test fails. See @{"gl.StencilOp" LINK glStencilOp}
                  for details.
        #GL_STENCIL_FUNC
                  "param" returns one value, a symbolic constant indicating what
                  function is used to compare the stencil reference value with
                  the stencil buffer value. See @{"gl.StencilFunc" LINK glStencilFunc} for details.
        #GL_STENCIL_PASS_DEPTH_FAIL
                  "param" returns one value, a symbolic constant indicating what
                  action is taken when the stencil test passes, but the depth
                  test fails. See @{"gl.StencilOp" LINK glStencilOp} for details.
        #GL_STENCIL_PASS_DEPTH_PASS
                  "param" returns one value, a symbolic constant indicating what
                  action is taken when the stencil test passes and the depth
                  test passes. See @{"gl.StencilOp" LINK glStencilOp} for details.
        #GL_STENCIL_REF
                  "param" returns one value, the reference value that is
                  compared with the contents of the stencil buffer. See
                  @{"gl.StencilFunc" LINK glStencilFunc} for details.
        #GL_STENCIL_TEST
                  "param" returns a single Boolean value indicating whether
                  stencil testing of fragments is enabled. See glStencilFunc and
                  glStencilOp.
        #GL_STENCIL_VALUE_MASK
                  "param" returns one value, the mask that is used to mask both
                  the stencil reference value and the stencil buffer value
                  before they are compared. See @{"gl.StencilFunc" LINK glStencilFunc} for details.
        #GL_STENCIL_WRITEMASK
                  "param" returns one value, the mask that controls writing of
                  the stencil bitplanes. See @{"gl.StencilMask" LINK glStencilMask} for details.
        #GL_STEREO
                  "param" returns a single Boolean value indicating whether
                  stereo buffers (left and right) are supported.
        #GL_SUBPIXEL_BITS
                  "param" returns one value, an estimate of the number of bits
                  of subpixel resolution that are used to position rasterized
                  geometry in window coordinates.
        #GL_TEXTURE_1D
                  "param" returns a single Boolean value indicating whether 1D
                  texture mapping is enabled. See @{"gl.TexImage1D" LINK glTexImage1D} for details.
        #GL_TEXTURE_2D
                  "param" returns a single Boolean value indicating whether 2D
                  texture mapping is enabled. See @{"gl.TexImage2D" LINK glTexImage2D} for details.
        #GL_TEXTURE_GEN_S
                  "param" returns a single Boolean value indicating whether
                  automatic generation of the S texture coordinate is enabled.
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_T
                  "param" returns a single Boolean value indicating whether
                  automatic generation of the T texture coordinate is enabled.
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_R
                  "param" returns a single Boolean value indicating whether
                  automatic generation of the R texture coordinate is enabled.
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_Q
                  "param" returns a single Boolean value indicating whether
                  automatic generation of the Q texture coordinate is enabled.
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_MATRIX
                  "param" returns sixteen values: the texture matrix on the top
                  of the texture matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_TEXTURE_STACK_DEPTH
                  "param" returns one value, the number of matrices on the
                  texture matrix stack. See @{"gl.PushMatrix" LINK glPushMatrix} for details.
        #GL_UNPACK_ALIGNMENT
                  "param" returns one value, the byte alignment used for reading
                  pixel data from memory. See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_UNPACK_LSB_FIRST
                  "param" returns a single Boolean value indicating whether
                  single-bit pixels being read from memory are read first from
                  the least significant bit of each unsigned byte. See
                  @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_UNPACK_ROW_LENGTH
                  "param" returns one value, the row length used for reading
                  pixel data from memory. See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_UNPACK_SKIP_IMAGES
                  "param" returns one value, the number of images skipped before
                  the first (3D) pixel is read from memory. See @{"gl.PixelStore" LINK glPixelStore}
                  for details.
        #GL_UNPACK_SKIP_PIXELS
                  "param" returns one value, the number of pixel locations
                  skipped before the first pixel is read from memory. See
                  @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_UNPACK_SKIP_ROWS
                  "param" returns one value, the number of rows of pixel
                  locations skipped before the first pixel is read from memory.
                  See @{"gl.PixelStore" LINK glPixelStore} for details.
        #GL_UNPACK_SWAP_BYTES
                  "param" returns a single Boolean value indicating whether the
                  bytes of two-byte and four-byte pixel indices and components
                  are swapped after being read from memory. See @{"gl.PixelStore" LINK glPixelStore}
                  for details.
        #GL_VIEWPORT
                  "param" returns four values: the x and y window coordinates of
                  the viewport, follow by its width and height. See @{"gl.Viewport" LINK glViewport}
                  for details..
        #GL_ZOOM_X
                  "param" returns one value, the x pixel zoom factor. See
                  @{"gl.PixelZoom" LINK glPixelZoom} for details.
        #GL_ZOOM_Y
                  "param" returns one value, the y pixel zoom factor. See
                  @{"gl.PixelZoom" LINK glPixelZoom} for details.

        Many of the boolean parameters can also be queried more easily using
        @{"gl.IsEnabled()" LINK glIsEnabled}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the parameter value to be returned (see above for
                  supported constants)

   @{b}RESULTS@{ub}
        param     value of the specified parameter
        ...       additional return values depending on "pname"

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.Get() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetArray "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetArray -- return the value or values of a selected parameter as an array

   @{b}SYNOPSIS@{ub}
        paramsArray = gl.GetArray(pname)

   @{b}FUNCTION@{ub}
        This function does the same as @{"gl.Get()" LINK glGet} except that the values are
        returned as an array. See @{"gl.Get" LINK glGet} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the parameter value to be returned

   @{b}RESULTS@{ub}
        paramsArray
                  parameter values in an array

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.Get() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetClipPlane "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetClipPlane -- return the coefficients of the specified clipping plane

   @{b}SYNOPSIS@{ub}
        equationArray = gl.GetClipPlane(plane)

   @{b}FUNCTION@{ub}
        gl.GetClipPlane() returns in equation the four coefficients of the plane
        equation for plane.

        It is always the case that #GL_CLIP_PLANEi = #GL_CLIP_PLANE0 + i.

        If an error is generated, no change is made to the contents of equation.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        plane     specifies a clipping plane; the number of clipping planes
                  depends on the implementation, but at least six clipping
                  planes are supported; they are identified by symbolic names of
                  the form #GL_CLIP_PLANEi where "i" ranges from 0 to the value
                  of
        #GL_MAX_CLIP_PLANES
                  1

   @{b}RESULTS@{ub}
        equationArray
                  table with four double-precision values that are the
                  coefficients of the plane equation of plane in eye
                  coordinates; the initial value is (0, 0, 0, 0)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if plane is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.GetClipPlane() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetError "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetError -- return error information

   @{b}SYNOPSIS@{ub}
        error = gl.GetError()

   @{b}FUNCTION@{ub}
        gl.GetError() returns the value of the error flag. Each detectable error
        is assigned a numeric code and symbolic name. When an error occurs, the
        error flag is set to the appropriate error code value. No other errors
        are recorded until gl.GetError() is called, the error code is returned,
        and the flag is reset to #GL_NO_ERROR. If a call to gl.GetError()
        returns #GL_NO_ERROR, there has been no detectable error since the last
        call to gl.GetError(), or since the GL was initialized.

        To allow for distributed implementations, there may be several error
        flags. If any single error flag has recorded an error, the value of that
        flag is returned and that flag is reset to #GL_NO_ERROR when
        gl.GetError() is called. If more than one flag has recorded an error,
        gl.GetError() returns and clears an arbitrary error flag value. Thus,
        gl.GetError() should always be called in a loop, until it returns
        #GL_NO_ERROR, if all error flags are to be reset.

        Initially, all error flags are set to #GL_NO_ERROR.

        The following errors are currently defined:

        #GL_NO_ERROR
                  No error has been recorded. The value of this symbolic
                  constant is guaranteed to be 0.

        #GL_INVALID_ENUM
                  An unacceptable value is specified for an enumerated argument.
                  The offending command is ignored and has no other side effect
                  than to set the error flag.

        #GL_INVALID_VALUE
                  A numeric argument is out of range. The offending command is
                  ignored and has no other side effect than to set the error
                  flag.

        #GL_INVALID_OPERATION
                  The specified operation is not allowed in the current state.
                  The offending command is ignored and has no other side effect
                  than to set the error flag.

        #GL_STACK_OVERFLOW
                  This command would cause a stack overflow. The offending
                  command is ignored and has no other side effect than to set
                  the error flag.

        #GL_STACK_UNDERFLOW
                  This command would cause a stack underflow. The offending
                  command is ignored and has no other side effect than to set
                  the error flag.

        #GL_OUT_OF_MEMORY
                  There is not enough memory left to execute the command. The
                  state of the GL is undefined, except for the state of the
                  error flags, after this error is recorded.

        When an error flag is set, results of a GL operation are undefined only
        if #GL_OUT_OF_MEMORY has occurred. In all other cases, the command
        generating the error is ignored and has no effect on the GL state or
        frame buffer contents. If the generating command returns a value, it
        returns 0. If gl.GetError() itself generates an error, it returns 0.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        error     value of GL's error flag

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.GetError() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.
        In this case, gl.GetError() returns 0.

@ENDNODE

@NODE glGetLight "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetLight -- return light source parameter values

   @{b}SYNOPSIS@{ub}
        paramsArray = gl.GetLight(light, pname)

   @{b}FUNCTION@{ub}
        gl.GetLight() returns in "paramsArray" the value or values of a light
        source parameter. "light" names the light and is a symbolic name of the
        form #GL_LIGHTi where "i" ranges from 0 to the value of #GL_MAX_LIGHTS -
        1. #GL_MAX_LIGHTS is an implementation dependent constant that is
        greater than or equal to eight. "pname" specifies one of ten light
        source parameters, again by symbolic name.

        The following parameters are defined:

        #GL_AMBIENT
                  Returns four floating-point values representing the ambient
                  intensity of the light source. The initial value is (0, 0, 0,
                  1).

        #GL_DIFFUSE
                  Returns four floating-point values representing the diffuse
                  intensity of the light source. The initial value for
                  #GL_LIGHT0 is (1, 1, 1, 1); for other lights, the initial
                  value is (0, 0, 0, 0).

        #GL_SPECULAR
                  Returns four floating-point values representing the specular
                  intensity of the light source. The initial value for
                  #GL_LIGHT0 is (1, 1, 1, 1); for other lights, the initial
                  value is (0, 0, 0, 0).

        #GL_POSITION
                  Returns four floating-point values representing the position
                  of the light source. The returned values are those maintained
                  in eye coordinates. They will not be equal to the values
                  specified using @{"gl.Light()" LINK glLight}, unless the modelview matrix was
                  identity at the time @{"gl.Light()" LINK glLight} was called. The initial value
                  is (0, 0, 1, 0).

        #GL_SPOT_DIRECTION
                  Returns three floating-point values representing the direction
                  of the light source. The returned values are those maintained
                  in eye coordinates. They will not be equal to the values
                  specified using @{"gl.Light()" LINK glLight}, unless the modelview matrix was
                  identity at the time @{"gl.Light()" LINK glLight} was called. Although spot
                  direction is normalized before being used in the lighting
                  equation, the returned values are the transformed versions of
                  the specified values prior to normalization. The initial value
                  is (0,0,-1).

        #GL_SPOT_EXPONENT
                  Returns a single floating-point value representing the spot
                  exponent of the light. The initial value is 0.

        #GL_SPOT_CUTOFF
                  Returns a single floating-point value representing the spot
                  cutoff angle of the light. The initial value is 180.

        #GL_CONSTANT_ATTENUATION
                  Returns a single floating-point value representing the
                  constant (not distance-related) attenuation of the light. The
                  initial value is 1.

        #GL_LINEAR_ATTENUATION
                  Returns a single floating-point value representing the linear
                  attenuation of the light. The initial value is 0.

        #GL_QUADRATIC_ATTENUATION
                  Returns a single floating-point value representing the
                  quadratic attenuation of the light. The initial value is 0.

        It is always the case that #GL_LIGHT i = #GL_LIGHT0 + i.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        light     specifies a light source; the number of possible lights
                  depends on the implementation, but at least eight lights are
                  supported; they are identified by symbolic names of the form
                  #GL_LIGHTi where "i" ranges from 0 to the value of
        #GL_MAX_LIGHTS
                  1
        pname     specifies a light source parameter for "light" (see above for
                  possible parameters)

   @{b}RESULTS@{ub}
        paramsArray
                  table containing requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "light" or "pname" is not an accepted
        value.

        #GL_INVALID_OPERATION is generated if gl.GetLight() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetMap "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetMap -- return evaluator parameters

   @{b}SYNOPSIS@{ub}
        vArray = gl.GetMap(target, query)

   @{b}FUNCTION@{ub}
        @{"gl.Map()" LINK glMap} defines an evaluator. gl.GetMap() returns evaluator parameters.
        "target" chooses a map, and "query" selects a specific parameter. The
        following values are currently supported for "target":

            #GL_MAP1_COLOR_4
            #GL_MAP1_INDEX
            #GL_MAP1_NORMAL
            #GL_MAP1_TEXTURE_COORD_1
            #GL_MAP1_TEXTURE_COORD_2
            #GL_MAP1_TEXTURE_COORD_3,
            #GL_MAP1_TEXTURE_COORD_4
            #GL_MAP1_VERTEX_3
            #GL_MAP1_VERTEX_4
            #GL_MAP2_COLOR_4
            #GL_MAP2_INDEX
            #GL_MAP2_NORMAL
            #GL_MAP2_TEXTURE_COORD_1
            #GL_MAP2_TEXTURE_COORD_2
            #GL_MAP2_TEXTURE_COORD_3
            #GL_MAP2_TEXTURE_COORD_4
            #GL_MAP2_VERTEX_3
            #GL_MAP2_VERTEX_4

        See @{"gl.Map" LINK glMap} for details.

        "query" can assume the following values:

        #GL_COEFF v returns the control points for the evaluator function.
                  One-dimensional evaluators return order control points, and
                  two-dimensional evaluators return uorder*vorder control
                  points. Each control point consists of one, two, three, or
                  four double-precision floating-point values. The GL returns
                  two-dimensional control points in row-major order,
                  incrementing the uorder index quickly and the vorder index
                  after each row.

        #GL_ORDER v returns the order of the evaluator function. One-dimensional
                  evaluators return a single value, order. The initial value is
                  1. Two-dimensional evaluators return two values, uorder and
                  vorder. The initial value is (1,1).

        #GL_DOMAIN
                  v returns the linear u and v mapping parameters.
                  One-dimensional evaluators return two values, u1 and u2, as
                  specified by @{"gl.Map()" LINK glMap}. Two-dimensional evaluators return four
                  values (u1, u2, v1, and v2) as specified by @{"gl.Map()" LINK glMap}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies the symbolic name of a map (see above for possible
                  values)
        query     specifies which parameter to return (see above for possible
                  values)

   @{b}RESULTS@{ub}
        vArray    table containing the requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "either" target or "query" is not an
        accepted value.

        #GL_INVALID_OPERATION is generated if gl.GetMap() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetMaterial "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetMaterial -- return material parameters

   @{b}SYNOPSIS@{ub}
        paramsArray = gl.GetMaterial(face, pname)

   @{b}FUNCTION@{ub}
        gl.GetMaterial() returns a table containing the value or values of
        parameter "pname" of material "face". The following six parameters can
        be passed in "pname":

        #GL_AMBIENT
                  Returns four floating-point values representing the ambient
                  reflectance of the material. The initial value is (0.2, 0.2,
                  0.2, 1.0)

        #GL_DIFFUSE
                  Returns four floating-point values representing the diffuse
                  reflectance of the material. The initial value is (0.8, 0.8,
                  0.8, 1.0).

        #GL_SPECULAR
                  Returns four floating-point values representing the specular
                  reflectance of the material. The initial value is (0, 0, 0,
                  1).

        #GL_EMISSION
                  Returns four floating-point values representing the emitted
                  light intensity of the material. The initial value is (0, 0,
                  0, 1).

        #GL_SHININESS
                  Returns one floating-point value representing the specular
                  exponent of the material. The initial value is 0.

        #GL_COLOR_INDEXES
                  Returns three floating-point values representing the ambient,
                  diffuse, and specular indices of the material. These indices
                  are used only for color index lighting. (All the other
                  parameters are used only for RGBA lighting.)

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        face      specifies which of the two materials is being queried;
                  #GL_FRONT or #GL_BACK are accepted, representing the front and
                  back materials, respectively
        pname     specifies the material parameter to return (see above for
                  possible values)

   @{b}RESULTS@{ub}
        paramsArray
                  table containing the requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "face" or "pname" is not an accepted
        value.

        #GL_INVALID_OPERATION is generated if gl.GetMaterial() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetPixelMap "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetPixelMap -- return the specified pixel map

   @{b}SYNOPSIS@{ub}
        valuesArray = gl.GetPixelMap(map)

   @{b}FUNCTION@{ub}
        gl.GetPixelMap() returns the contents of the pixel map specified in
        "map". This can be one of the following constants:

            #GL_PIXEL_MAP_I_TO_I
            #GL_PIXEL_MAP_S_TO_S
            #GL_PIXEL_MAP_I_TO_R
            #GL_PIXEL_MAP_I_TO_G
            #GL_PIXEL_MAP_I_TO_B
            #GL_PIXEL_MAP_I_TO_A
            #GL_PIXEL_MAP_R_TO_R
            #GL_PIXEL_MAP_G_TO_G
            #GL_PIXEL_MAP_B_TO_B
            #GL_PIXEL_MAP_A_TO_A

        See @{"gl.PixelMap" LINK glPixelMap} for details.

        Pixel maps are used during the execution of @{"gl.ReadPixels()" LINK glReadPixels},
        @{"gl.DrawPixels()" LINK glDrawPixels}, @{"gl.CopyPixels()" LINK glCopyPixels}, and @{"gl.TexImage1D()" LINK glTexImage1D},
        @{"gl.TexImage2D()" LINK glTexImage2D}, @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, @{"gl.TexSubImage2D()" LINK glTexSubImage2D},
        @{"gl.CopyTexImage()" LINK glCopyTexImage} and @{"gl.CopyTexSubImage()" LINK glCopyTexSubImage}, to map color indices,
        stencil indices, color components, and depth components to other values.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        map       specifies the name of the pixel map to return (see above for
                  possible values)

   @{b}RESULTS@{ub}
        valuesArray
                  table containing the pixel map contents

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "map" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.GetPixelMap() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_I_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_S_TO_S_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_R_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_G_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_B_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_A_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_R_TO_R_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_G_TO_G_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_B_TO_B_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_A_TO_A_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_PIXEL_MAP_TABLE

@ENDNODE

@NODE glGetPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetPointer -- return values of the specified pointer

   @{b}SYNOPSIS@{ub}
        valuesArray = gl.GetPointer(pname, n)

   @{b}FUNCTION@{ub}
        gl.GetPointer() returns elements read from a GL pointer. "pname" is a
        symbolic constant indicating the pointer to be used and "n" specifies
        how many elements should be read and returned. "pname" can be set to the
        following values:

            #GL_COLOR_ARRAY_POINTER
            #GL_EDGE_FLAG_ARRAY_POINTER
            #GL_FEEDBACK_BUFFER_POINTER
            #GL_INDEX_ARRAY_POINTER
            #GL_NORMAL_ARRAY_POINTER
            #GL_SELECTION_BUFFER_POINTER
            #GL_TEXTURE_COORD_ARRAY_POINTER
            #GL_VERTEX_ARRAY_POINTER

        The pointers are all client-side state.

        The initial value for each pointer is NULL.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the array or buffer pointer to be queried (see above
                  for possible values)
        n         number of items to read from pointer

   @{b}RESULTS@{ub}
        valuesArray
                  table containing "n" items read from the respective pointer

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

@ENDNODE

@NODE glGetPolygonStipple "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetPolygonStipple -- return the polygon stipple pattern

   @{b}SYNOPSIS@{ub}
        maskArray = gl.GetPolygonStipple()

   @{b}FUNCTION@{ub}
        gl.GetPolygonStipple() returns to pattern a 32*32 polygon stipple
        pattern. The pattern is packed into memory as if @{"gl.ReadPixels()" LINK glReadPixels} with
        both height and width of 32, type of #GL_BITMAP, and format of
        #GL_COLOR_INDEX were called, and the stipple pattern were stored in an
        internal 32*32 color index buffer. Unlike @{"gl.ReadPixels()" LINK glReadPixels}, however,
        pixel transfer operations (shift, offset, pixel map) are not applied to
        the returned stipple image. Since #GL_BITMAP uses only 1-bit per pixel,
        the table returned by this function will always have exactly 128
        elements containing 8 pixels per table element.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        maskArray table containing the stipple pattern; the initial value is all
                  1's

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.GetPolygonStipple() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetSelectBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetSelectBuffer -- read value from the selection buffer

   @{b}SYNOPSIS@{ub}
        value = gl.GetSelectBuffer(buffer, index)

   @{b}FUNCTION@{ub}
        This function can be used to read the value at index "index" in the
        selection buffer passed in "buffer". This buffer must have been
        allocated by @{"gl.SelectBuffer()" LINK glSelectBuffer}. Values are read as unsigned four byte
        integers starting at index 0.

        See @{"gl.SelectBuffer" LINK glSelectBuffer} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        buffer    memory buffer allocated by @{"gl.SelectBuffer()" LINK glSelectBuffer}
        index     index of the value to read (starting at index 0)

   @{b}RESULTS@{ub}
        value     value at the specified index

@ENDNODE

@NODE glGetString "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetString -- return a string describing the current GL connection

   @{b}SYNOPSIS@{ub}
        string = gl.GetString(name)

   @{b}FUNCTION@{ub}
        gl.GetString() returns a pointer to a static string describing some
        aspect of the current GL connection. name can be one of the following:

        #GL_VENDOR
                  Returns the company responsible for this GL implementation.
                  This name does not change from release to release.

        #GL_RENDERER
                  Returns the name of the renderer. This name is typically
                  specific to a particular configuration of a hardware platform.
                  It does not change from release to release.

        #GL_VERSION
                  Returns a version or release number.

        #GL_EXTENSIONS
                  Returns a space-separated list of supported extensions to GL.

        Because the GL does not include queries for the performance
        characteristics of an implementation, some applications are written to
        recognize known platforms and modify their GL usage based on known
        performance characteristics of these platforms. Strings #GL_VENDOR and
        #GL_RENDERER together uniquely specify a platform. They do not change
        from release to release and should be used by platform-recognition
        algorithms.

        Some applications want to make use of features that are not part of the
        standard GL. These features may be implemented as extensions to the
        standard GL. The #GL_EXTENSIONS string is a space-separated list of
        supported GL extensions. (Extension names never contain a space
        character.)

        The #GL_VERSION string begins with a version number. The version number
        uses one of these forms:

            <major_number>.<minor_number>
            <major_number>.<minor_number>.<release_number>

        Vendor-specific information may follow the version number. Its format
        depends on the implementation, but a space always separates the version
        number and the vendor-specific information.

        The client and server may support different versions or extensions.
        gl.GetString() always returns a compatible version number or list of
        extensions. The release number always describes the server.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        name      specifies a symbolic constant (see above for possible values)

   @{b}RESULTS@{ub}
        string    string describing the current GL connection

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "name" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.GetString() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetTexEnv "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexEnv -- return texture environment parameters

   @{b}SYNOPSIS@{ub}
        paramsArray = gl.GetTexEnv(pname)

   @{b}FUNCTION@{ub}
        gl.GetTexEnv() returns a table containing selected values of a texture
        environment that was specified with @{"gl.TexEnv()" LINK glTexEnv}. "pname" names a
        specific texture environment parameter. The two parameters are as
        follows:

        #GL_TEXTURE_ENV_MODE
                  Returns the single-valued texture environment mode, a symbolic
                  constant.

        #GL_TEXTURE_ENV_COLOR
                  Returns four floating-point values that are the texture
                  environment color.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the symbolic name of a texture environment parameter
                  (see above for possible values)

   @{b}RESULTS@{ub}
        paramsArray
                  table containing the requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.GetTexEnv() is called between a
        call to glBegin and the corresponding execution to glEnd.

@ENDNODE

@NODE glGetTexGen "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexGen -- return texture coordinate generation parameters

   @{b}SYNOPSIS@{ub}
        paramsArray = gl.GetTexGen(coord, pname)

   @{b}FUNCTION@{ub}
        gl.GetTexGen() returns a table containing selected parameters of a
        texture coordinate generation function that was specified using
        @{"gl.TexGen()" LINK glTexGen}. "coord" names one of the (s, t, r, q) texture coordinates,
        using the symbolic constants #GL_S, #GL_T, #GL_R, or #GL_Q.

        "pname" specifies one of three symbolic names:

        #GL_TEXTURE_GEN_MODE
                  Returns the single-valued texture generation function, a
                  symbolic constant. The initial value is #GL_EYE_LINEAR.

        #GL_OBJECT_PLANE
                  This will return the four plane equation coefficients that
                  specify object linear-coordinate generation.

        #GL_EYE_PLANE
                  Returns the four plane equation coefficients that specify eye
                  linear-coordinate generation. The returned values are those
                  maintained in eye coordinates. They are not equal to the
                  values specified using @{"gl.TexGen()" LINK glTexGen}, unless the modelview
                  matrix was identity when @{"gl.TexGen()" LINK glTexGen} was called.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        coord     specifies a texture coordinate
        pname     specifies the symbolic name of the value(s) to be returned

   @{b}RESULTS@{ub}
        paramsArray
                  table containing the requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "coord" or "pname" is not an accepted
        value.

        #GL_INVALID_OPERATION is generated if gl.GetTexGen() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetTexImage "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexImage -- return a texture image

   @{b}SYNOPSIS@{ub}
        pixelsArray = gl.GetTexImage(target, level, format)

   @{b}FUNCTION@{ub}
        gl.GetTexImage() returns the pixels of a texture image. One-dimensional
        textures are returned in a one-dimensional table whereas two-dimensional
        textures are returned in a table that contains subtables for all rows in
        the texture. The pixels are returned as values of type #GL_FLOAT
        "target" specifies whether the desired texture image is one specified by
        @{"gl.TexImage1D()" LINK glTexImage1D} (#GL_TEXTURE_1D) or @{"gl.TexImage2D()" LINK glTexImage2D} (#GL_TEXTURE_2D).
        "level" specifies the level-of-detail number of the desired image.
        "format" specifies the format of the desired image array. See
        @{"gl.TexImage2D" LINK glTexImage2D} for a description of the acceptable values for the format
        parameter.

        To understand the operation of gl.GetTexImage(), consider the selected
        internal four-component texture image to be an RGBA color buffer the
        size of the image. The semantics of gl.GetTexImage() are then identical
        to those of @{"gl.ReadPixels()" LINK glReadPixels}, with the exception that no pixel transfer
        operations are performed, when called with the same format and type,
        with x and y set to 0, width set to the width of the texture image
        (including border if one was specified), and height set to 1 for 1D
        images, or to the height of the texture image (including border if one
        was specified) for 2D images. Because the internal texture image is an
        RGBA image, pixel formats #GL_COLOR_INDEX, #GL_STENCIL_INDEX, and
        #GL_DEPTH_COMPONENT are not accepted, and pixel type #GL_BITMAP is not
        accepted.

        If the selected texture image does not contain four components, the
        following mappings are applied. Single-component textures are treated as
        RGBA buffers with red set to the single-component value, green set to 0,
        blue set to 0, and alpha set to 1. Two-component textures are treated as
        RGBA buffers with red set to the value of component zero, alpha set to
        the value of component one, and green and blue set to 0. Finally,
        three-component textures are treated as RGBA buffers with red set to
        component zero, green set to component one, blue set to component two,
        and alpha set to 1.

        If you want to have fine-tuned control over the pixel type or if you
        want the pixels to be written into a memory buffer instead of a table,
        you can use the @{"gl.GetTexImageRaw()" LINK glGetTexImageRaw} function instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies which texture is to be obtained (must be
                  #GL_TEXTURE_1D or #GL_TEXTURE_2D)
        level     specifies the level-of-detail number of the desired image;
                  level 0 is the base image level; level n is the nth mipmap
                  reduction image
        format    specifies a pixel format for the returned data; the supported
                  formats are #GL_RED, #GL_GREEN, #GL_BLUE, #GL_ALPHA, #GL_RGB,
                  #GL_RGBA, #GL_LUMINANCE, and #GL_LUMINANCE_ALPHA

   @{b}RESULTS@{ub}
        pixelsArray
                  table containing the raw pixels

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target" or "format" is not an accepted
        value.

        #GL_INVALID_VALUE is generated if "level" is less than zero or greater
        than ld(max), where "max" is the returned value of #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_OPERATION is generated if gl.GetTexImage() is called between
        a call to glBegin and the corresponding call to glEnd.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_WIDTH

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_HEIGHT

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_BORDER

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_COMPONENTS

        @{"gl.Get()" LINK glGet} with arguments #GL_PACK_ALIGNMENT and others

@ENDNODE

@NODE glGetTexImageRaw "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexImageRaw -- return a texture image

   @{b}SYNOPSIS@{ub}
        gl.GetTexImageRaw(target, level, format, type, pixels)

   @{b}FUNCTION@{ub}
        gl.GetTexImageRaw() writes the pixels of a texture image to "pixels".
        This must be a memory buffer allocated by Hollywood's "AllocMem()"
        function and returned by "GetMemPointer()". To determine the required
        size of "pixels", use @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} to determine the
        dimensions of the internal texture image, then scale the required number
        of pixels by the storage required for each pixel, based on "format" and
        "type". Be sure to take the pixel storage parameters into account,
        especially #GL_PACK_ALIGNMENT.

        The supported values for "format" are #GL_RED, #GL_GREEN, #GL_BLUE,
        #GL_ALPHA, #GL_RGB, #GL_RGBA, #GL_LUMINANCE, and #GL_LUMINANCE_ALPHA.

        Supported data types for "type" are #GL_UNSIGNED_BYTE, #GL_BYTE,
        #GL_UNSIGNED_SHORT, #GL_SHORT, #GL_UNSIGNED_INT, #GL_INT, and #GL_FLOAT.

        The pixels are written to the memory buffer as values of type "type".
        "target" specifies whether the desired texture image is one specified by
        @{"gl.TexImage1D()" LINK glTexImage1D} (#GL_TEXTURE_1D) or @{"gl.TexImage2D()" LINK glTexImage2D} (#GL_TEXTURE_2D).
        "level" specifies the level-of-detail number of the desired image.
        "format" specifies the format of the desired image array. See
        @{"gl.TexImage2D" LINK glTexImage2D} for a description of the acceptable values for the format
        parameter.

        To understand the operation of gl.GetTexImageRaw(), consider the
        selected internal four-component texture image to be an RGBA color
        buffer the size of the image. The semantics of gl.GetTexImageRaw() are
        then identical to those of @{"gl.ReadPixels()" LINK glReadPixels}, with the exception that no
        pixel transfer operations are performed, when called with the same
        format and type, with x and y set to 0, width set to the width of the
        texture image (including border if one was specified), and height set to
        1 for 1D images, or to the height of the texture image (including border
        if one was specified) for 2D images. Because the internal texture image
        is an RGBA image, pixel formats #GL_COLOR_INDEX, #GL_STENCIL_INDEX, and
        #GL_DEPTH_COMPONENT are not accepted, and pixel type #GL_BITMAP is not
        accepted.

        If the selected texture image does not contain four components, the
        following mappings are applied. Single-component textures are treated as
        RGBA buffers with red set to the single-component value, green set to 0,
        blue set to 0, and alpha set to 1. Two-component textures are treated as
        RGBA buffers with red set to the value of component zero, alpha set to
        the value of component one, and green and blue set to 0. Finally,
        three-component textures are treated as RGBA buffers with red set to
        component zero, green set to component one, blue set to component two,
        and alpha set to 1.

        If you want to have the pixels returned in a table instead of a memory
        buffer, you can use the @{"gl.GetTexImage()" LINK glGetTexImage} function instead. See @{"Working" LINK UsingPointers}
        @{"with pointers" LINK UsingPointers} for details on how to use memory pointers with Hollywood.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies which texture is to be obtained (must be
                  #GL_TEXTURE_1D or #GL_TEXTURE_2D)
        level     specifies the level-of-detail number of the desired image;
                  level 0 is the base image level; level n is the nth mipmap
                  reduction image
        format    specifies a pixel format for the returned data (see above)
        type      specifies a pixel type for the returned data (see above)
        pixels    pointer to a memory buffer to write the pixels to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target", "type" or "format" is not an
        accepted value.

        #GL_INVALID_VALUE is generated if "level" is less than zero or greater
        than ld(max), where "max" is the returned value of #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_OPERATION is generated if gl.GetTexImageRaw() is called
        between a call to glBegin and the corresponding call to glEnd.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_WIDTH

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_HEIGHT

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_BORDER

        @{"gl.GetTexLevelParameter()" LINK glGetTexLevelParameter} with argument #GL_TEXTURE_COMPONENTS

        @{"gl.Get()" LINK glGet} with arguments #GL_PACK_ALIGNMENT and others

@ENDNODE

@NODE glGetTexLevelParameter "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexLevelParameter -- return texture parameter values for a specific level of detail

   @{b}SYNOPSIS@{ub}
        param = gl.GetTexLevelParameter(target, level, pname)

   @{b}FUNCTION@{ub}
        gl.GetTexLevelParameter() returns texture parameter values for a
        specific level-of-detail value, specified as "level". "target" defines
        the target texture, either #GL_TEXTURE_1D, #GL_TEXTURE_2D,
        #GL_PROXY_TEXTURE_1D, or #GL_PROXY_TEXTURE_2D.

        #GL_MAX_TEXTURE_SIZE is not really descriptive enough. It has to report
        the largest square texture image that can be accommodated with mipmaps
        and borders, but a long skinny texture, or a texture without mipmaps and
        borders, may easily fit in texture memory. The proxy targets allow the
        user to more accurately query whether the GL can accommodate a texture
        of a given configuration. If the texture cannot be accommodated, the
        texture state variables, which may be queried with
        gl.GetTexLevelParameter(), are set to 0. If the texture can be
        accommodated, the texture state values will be set as they would be set
        for a non-proxy target.

        "pname" specifies the texture parameter whose value or values will be
        returned. The accepted parameter names are as follows:

        #GL_TEXTURE_WIDTH
                  params returns a single value, the width of the texture image.
                  This value includes the border of the texture image. The
                  initial value is 0.

        #GL_TEXTURE_HEIGHT
                  params returns a single value, the height of the texture
                  image. This value includes the border of the texture image.
                  The initial value is 0.

        #GL_TEXTURE_DEPTH
                  params returns a single value, the depth of the texture image.
                  This value includes the border of the texture image. The
                  initial value is 0.

        #GL_TEXTURE_INTERNAL_FORMAT
                  params returns a single value, the internal format of the
                  texture image.

        #GL_TEXTURE_BORDER
                  params returns a single value, the width in pixels of the
                  border of the texture image. The initial value is 0.

        #GL_TEXTURE_XXX_SIZE
                  The internal storage resolution of an individual component
                  (XXX can be RED, GREEN, BLUE, ALPHA, LUMINANCE, INTENSITY,
                  DEPTH). The resolution chosen by the GL will be a close match
                  for the resolution requested by the user with the component
                  argument of @{"gl.TexImage1D()" LINK glTexImage1D}, @{"gl.TexImage2D()" LINK glTexImage2D}, and
                  @{"gl.CopyTexImage()" LINK glCopyTexImage}. The initial value is 0.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies the symbolic name of the target texture, either
                  #GL_TEXTURE_1D, #GL_TEXTURE_2D, #GL_PROXY_TEXTURE_1D, or
                  #GL_PROXY_TEXTURE_2D
        level     specifies the level-of-detail number of the desired image.
                  Level 0 is the base image level. Level n is the nth mipmap
                  reduction image
        pname     specifies the symbolic name of a texture parameter (see above
                  for possible values)

   @{b}RESULTS@{ub}
        param     requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target" or "pname" is not an accepted
        value.

        #GL_INVALID_VALUE is generated if "level" is less than 0.

        #GL_INVALID_VALUE may be generated if "level" is greater than ld(max),
        where max is the returned value of #GL_MAX_TEXTURE_SIZE.

        #GL_INVALID_OPERATION is generated if gl.GetTexLevelParameter() is
        executed between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding
        execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glGetTexParameter "GL Galore Guide"

   @{b}NAME@{ub}
        gl.GetTexParameter -- return texture parameter values

   @{b}SYNOPSIS@{ub}
        param = gl.GetTexParameter(target, pname)

   @{b}FUNCTION@{ub}
        gl.GetTexParameter() returns the value or values of the texture
        parameter specified as "pname". "target" defines the target texture,
        either #GL_TEXTURE_1D or #GL_TEXTURE_2D, to specify one- or
        two-dimensional texturing. "pname" accepts the same symbols as
        @{"gl.TexParameter()" LINK glTexParameter} with the same interpretations:

        #GL_TEXTURE_MAG_FILTER
                  Returns the single-valued texture magnification filter, a
                  symbolic constant. The initial value is #GL_LINEAR.

        #GL_TEXTURE_MIN_FILTER
                  Returns the single-valued texture minification filter, a
                  symbolic constant. The initial value is
                  #GL_NEAREST_MIPMAP_LINEAR.

        #GL_TEXTURE_WRAP_S
                  Returns the single-valued wrapping function for texture
                  coordinate s, a symbolic constant. The initial value is
                  #GL_REPEAT.

        #GL_TEXTURE_WRAP_T
                  Returns the single-valued wrapping function for texture
                  coordinate t, a symbolic constant. The initial value is
                  #GL_REPEAT.

        #GL_TEXTURE_BORDER_COLOR
                  Returns four floating-point numbers that comprise the RGBA
                  color of the texture border. The initial value is (0, 0, 0,
                  0).

        #GL_TEXTURE_PRIORITY
                  Returns the residence priority of the target texture (or the
                  named texture bound to it). The initial value is 1. See
                  @{"gl.PrioritizeTextures" LINK glPrioritizeTextures} for details.

        #GL_TEXTURE_RESIDENT
                  Returns the residence status of the target texture. If the
                  value returned in params is #GL_TRUE, the texture is resident
                  in texture memory. See @{"gl.AreTexturesResident" LINK glAreTexturesResident} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies the symbolic name of the target texture;
                  #GL_TEXTURE_1D and #GL_TEXTURE_2D are accepted
        pname     specifies the symbolic name of a texture parameter (see above
                  for supported values)

   @{b}RESULTS@{ub}
        param     requested data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target" or "pname" is not an accepted
        value.

        #GL_INVALID_OPERATION is generated if gl.GetTexParameter() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glHint "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Hint -- specify implementation-specific hints

   @{b}SYNOPSIS@{ub}
        gl.Hint(target, mode)

   @{b}FUNCTION@{ub}
        Certain aspects of GL behavior, when there is room for interpretation,
        can be controlled with hints. A hint is specified with two arguments.
        "target" is a symbolic constant indicating the behavior to be
        controlled, and "mode" is another symbolic constant indicating the
        desired behavior. The initial value for each target is #GL_DONT_CARE.
        "mode" can be one of the following:

        #GL_FASTEST
                  The most efficient option should be chosen.

        #GL_NICEST
                  The most correct, or highest quality, option should be chosen.

        #GL_DONT_CARE
                  No preference.

        Though the implementation aspects that can be hinted are well defined,
        the interpretation of the hints depends on the implementation. The hint
        aspects that can be specified with "target", along with suggested
        semantics, are as follows:

        #GL_FOG_HINT
                  Indicates the accuracy of fog calculation. If per-pixel fog
                  calculation is not efficiently supported by the GL
                  implementation, hinting #GL_DONT_CARE or #GL_FASTEST can
                  result in per-vertex calculation of fog effects.

        #GL_LINE_SMOOTH_HINT
                  Indicates the sampling quality of antialiased lines. If a
                  larger filter function is applied, hinting #GL_NICEST can
                  result in more pixel fragments being generated during
                  rasterization.

        #GL_PERSPECTIVE_CORRECTION_HINT
                  Indicates the quality of color, texture coordinate, and fog
                  coordinate interpolation. If perspective-corrected parameter
                  interpolation is not efficiently supported by the GL
                  implementation, hinting #GL_DONT_CARE or #GL_FASTEST can
                  result in simple linear interpolation of colors and/or texture
                  coordinates.

        #GL_POINT_SMOOTH_HINT
                  Indicates the sampling quality of antialiased points. If a
                  larger filter function is applied, hinting #GL_NICEST can
                  result in more pixel fragments being generated during
                  rasterization.

        #GL_POLYGON_SMOOTH_HINT
                  Indicates the sampling quality of antialiased polygons.
                  Hinting #GL_NICEST can result in more pixel fragments being
                  generated during rasterization, if a larger filter function is
                  applied.

        The interpretation of hints depends on the implementation. Some
        implementations ignore gl.Hint() settings.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies a symbolic constant indicating the behavior to be
                  controlled (see above for possible values)
        mode      specifies a symbolic constant indicating the desired behavior;
                  #GL_FASTEST, #GL_NICEST, and #GL_DONT_CARE are accepted

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if either target or mode is not an
        accepted value.

        #GL_INVALID_OPERATION is generated if gl.Hint() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glIndex "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Index -- set the current color index

   @{b}SYNOPSIS@{ub}
        gl.Index(c)

   @{b}FUNCTION@{ub}
        gl.Index() updates the current (single-valued) color index. It takes one
        argument, the new value for the current color index.

        The current index is stored as a floating-point value. The initial value
        is 1.

        Index values outside the representable range of the color index buffer
        are not clamped. However, before an index is dithered (if enabled) and
        written to the frame buffer, it is converted to fixed-point format. Any
        bits in the integer portion of the resulting fixed-point value that do
        not correspond to bits in the frame buffer are masked out.

        The current index can be updated at any time. In particular, gl.Index()
        can be called between a call to @{"gl.Begin()" LINK glBegin} and the corresponding call to
        @{"gl.End()" LINK glEnd}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        c         specifies the new value for the current color index

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_INDEX

@ENDNODE

@NODE glIndexMask "GL Galore Guide"

   @{b}NAME@{ub}
        gl.IndexMask -- control the writing of individual bits in the color index buffers

   @{b}SYNOPSIS@{ub}
        gl.IndexMask(mask)

   @{b}FUNCTION@{ub}
        gl.IndexMask() controls the writing of individual bits in the color
        index buffers. The least significant n bits of mask, where n is the
        number of bits in a color index buffer, specify a mask. Where a 1 (one)
        appears in the mask, it's possible to write to the corresponding bit in
        the color index buffer (or buffers). Where a 0 (zero) appears, the
        corresponding bit is write-protected.

        This mask is used only in color index mode, and it affects only the
        buffers currently selected for writing See @{"gl.DrawBuffer" LINK glDrawBuffer} for details.
        (). Initially, all bits are enabled for writing.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mask      specifies a bit mask to enable and disable the writing of
                  individual bits in the color index buffers; initially, the
                  mask is all 1's.

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.IndexMask() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_WRITEMASK

@ENDNODE

@NODE glIndexPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.IndexPointer -- define an array of color indexes

   @{b}SYNOPSIS@{ub}
        gl.IndexPointer(indexArray)

   @{b}FUNCTION@{ub}
        gl.IndexPointer() specifies an array of color indexes to use when
        rendering. "indexArray" must be an array containing a number of
        floating-point values describing color indexes.

        If you pass Nil in "indexArray", the color index array buffer will be
        freed but it won't be removed from OpenGL. You need to do this manually,
        e.g. by disabling the color index array or defining a new one.

        When a color index array is specified, it is saved as client-side state,
        in addition to the current vertex array buffer object binding.

        To enable and disable the color index array, call @{"gl.EnableClientState()" LINK glEnableClientState}
        and @{"gl.DisableClientState()" LINK glDisableClientState} with the argument #GL_INDEX_ARRAY. If
        enabled, the color index array is used when @{"gl.DrawArrays()" LINK glDrawArrays},
        @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Color indexes are not supported for interleaved vertex array formats See
        @{"gl.InterleavedArrays" LINK glInterleavedArrays} for details. ().

        The color index array is initially disabled and isn't accessed when
        @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Execution of gl.IndexPointer() is not allowed between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.IndexPointer() is typically implemented on the client side.

        Color index array parameters are client-side state and are therefore not
        saved or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}. Use
        @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        indexArray
                  array of color indexes or Nil (see above)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_INDEX_ARRAY

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_ARRAY_TYPE

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_ARRAY_STRIDE

        @{"gl.GetPointer()" LINK glGetPointer} with argument #GL_INDEX_ARRAY_POINTER

@ENDNODE

@NODE glInitNames "GL Galore Guide"

   @{b}NAME@{ub}
        gl.InitNames -- initialize the name stack

   @{b}SYNOPSIS@{ub}
        gl.InitNames()

   @{b}FUNCTION@{ub}
        The name stack is used during selection mode to allow sets of rendering
        commands to be uniquely identified. It consists of an ordered set of
        unsigned integers. gl.InitNames() causes the name stack to be
        initialized to its default empty state.

        The name stack is always empty while the render mode is not #GL_SELECT.
        Calls to gl.InitNames() while the render mode is not #GL_SELECT are
        ignored.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.InitNames() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_NAME_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_NAME_STACK_DEPTH

@ENDNODE

@NODE glInterleavedArrays "GL Galore Guide"

   @{b}NAME@{ub}
        gl.InterleavedArrays -- simultaneously specify and enable several interleaved arrays

   @{b}SYNOPSIS@{ub}
        gl.InterleavedArrays(format, stride, data)

   @{b}FUNCTION@{ub}
        gl.InterleavedArrays() lets you specify and enable individual color,
        normal, texture and vertex arrays whose elements are part of a larger
        aggregate array element. For some implementations, this is more
        efficient than specifying the arrays separately.

        "data" must be a pointer to a raw memory buffer allocated by Hollywood's
        "AllocMem()" function, containing the relevant array data. Use
        Hollywood's "GetMemPointer()" function to get the raw pointer address of
        memory blocks allocated by "AllocMem()". See @{"Working with pointers" LINK UsingPointers} for
        details on how to use memory pointers with Hollywood.

        If "stride" is 0, the aggregate elements are stored consecutively.
        Otherwise, "stride" bytes occur between the beginning of one aggregate
        array element and the beginning of the next aggregate array element.

        "format" serves as a key describing the extraction of individual arrays
        from the aggregate array. If "format" contains a T, then texture
        coordinates are extracted from the interleaved array. If C is present,
        color values are extracted. If N is present, normal coordinates are
        extracted. Vertex coordinates are always extracted. The digits 2, 3, and
        4 denote how many values are extracted. F indicates that values are
        extracted as floating-point values. Colors may also be extracted as 4
        unsigned bytes if 4UB follows the C. If a color is extracted as 4
        unsigned bytes, the vertex array element which follows is located at the
        first possible floating-point aligned address. The following symbolic
        constants are recognized for "format":

            #GL_V2F
            #GL_V3F
            #GL_C4UB_V2F
            #GL_C4UB_V3F
            #GL_C3F_V3F
            #GL_N3F_V3F
            #GL_C4F_N3F_V3F
            #GL_T2F_V3F
            #GL_T4F_V4F
            #GL_T2F_C4UB_V3F
            #GL_T2F_C3F_V3F
            #GL_T2F_N3F_V3F
            #GL_T2F_C4F_N3F_V3F
            #GL_T4F_C4F_N3F_V4F

        If gl.InterleavedArrays() is called while compiling a display list, it
        is not compiled into the list, and it is executed immediately.

        Execution of gl.InterleavedArrays() is not allowed between the execution
        of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.InterleavedArrays() is typically implemented on the client side.

        Vertex array parameters are client-side state and are therefore not
        saved or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}. Use
        @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        format    specifies the type of array to enable (see above for supported
                  formats)
        stride    specifies the offset in bytes between each aggregate array
                  element
        data      raw memory pointer containing data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "format" is not an accepted value.

@ENDNODE

@NODE glIsEnabled "GL Galore Guide"

   @{b}NAME@{ub}
        gl.IsEnabled -- test whether a capability is enabled

   @{b}SYNOPSIS@{ub}
        bool = gl.IsEnabled(cap)

   @{b}FUNCTION@{ub}
        gl.IsEnabled() returns #GL_TRUE if "cap" is an enabled capability and
        returns #GL_FALSE otherwise. Initially all capabilities except
        #GL_DITHER are disabled; #GL_DITHER is initially enabled.

        The following capabilities are accepted for "cap":

        #GL_ALPHA_TEST
                  See @{"gl.AlphaFunc" LINK glAlphaFunc} for details.
        #GL_AUTO_NORMAL
                  See @{"gl.EvalCoord" LINK glEvalCoord} for details.
        #GL_BLEND See @{"gl.BlendFunc" LINK glBlendFunc} for details. See @{"gl.LogicOp" LINK glLogicOp} for details.
        #GL_CLIP_PLANEi
                  See @{"gl.ClipPlane" LINK glClipPlane} for details.
        #GL_COLOR_ARRAY
                  See @{"gl.ColorPointer" LINK glColorPointer} for details.
        #GL_COLOR_LOGIC_OP
                  See @{"gl.LogicOp" LINK glLogicOp} for details.
        #GL_COLOR_MATERIAL
                  See @{"gl.ColorMaterial" LINK glColorMaterial} for details.
        #GL_CULL_FACE
                  See @{"gl.CullFace" LINK glCullFace} for details.
        #GL_DEPTH_TEST
                  See @{"gl.DepthFunc" LINK glDepthFunc} for details. See @{"gl.DepthRange" LINK glDepthRange} for details.
        #GL_DITHER
                  See @{"gl.Enable" LINK glEnable} for details.
        #GL_EDGE_FLAG_ARRAY
                  See @{"gl.EdgeFlagPointer" LINK glEdgeFlagPointer} for details.
        #GL_FOG   See @{"gl.Fog" LINK glFog} for details.
        #GL_INDEX_ARRAY
                  See @{"gl.IndexPointer" LINK glIndexPointer} for details.
        #GL_INDEX_LOGIC_OP
                  See @{"gl.LogicOp" LINK glLogicOp} for details.
        #GL_LIGHTi
                  See @{"gl.LightModel" LINK glLightModel} for details. See @{"gl.Light" LINK glLight} for details.
        #GL_LIGHTING
                  See @{"gl.Material" LINK glMaterial} for details. See @{"gl.LightModel" LINK glLightModel} for details.
                  See @{"gl.Light" LINK glLight} for details.
        #GL_LINE_SMOOTH
                  See @{"gl.LineWidth" LINK glLineWidth} for details.
        #GL_LINE_STIPPLE
                  See @{"gl.LineStipple" LINK glLineStipple} for details.
        #GL_MAP1_COLOR_4
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_INDEX
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_NORMAL
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_TEXTURE_COORD_1
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_TEXTURE_COORD_2
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_TEXTURE_COORD_3
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP1_TEXTURE_COORD_4
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_COLOR_4
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_INDEX
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_NORMAL
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_TEXTURE_COORD_1
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_TEXTURE_COORD_2
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_TEXTURE_COORD_3
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_TEXTURE_COORD_4
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_VERTEX_3
                  See @{"gl.Map" LINK glMap} for details.
        #GL_MAP2_VERTEX_4
                  See @{"gl.Map" LINK glMap} for details.
        #GL_NORMAL_ARRAY
                  See @{"gl.NormalPointer" LINK glNormalPointer} for details.
        #GL_NORMALIZE
                  See @{"gl.Normal" LINK glNormal} for details.
        #GL_POINT_SMOOTH
                  See @{"gl.PointSize" LINK glPointSize} for details.
        #GL_POLYGON_SMOOTH
                  See @{"gl.PolygonMode" LINK glPolygonMode} for details.
        #GL_POLYGON_OFFSET_FILL
                  See @{"gl.PolygonOffset" LINK glPolygonOffset} for details.
        #GL_POLYGON_OFFSET_LINE
                  See @{"gl.PolygonOffset" LINK glPolygonOffset} for details.
        #GL_POLYGON_OFFSET_POINT
                  See @{"gl.PolygonOffset" LINK glPolygonOffset} for details.
        #GL_POLYGON_STIPPLE
                  See @{"gl.PolygonStipple" LINK glPolygonStipple} for details.
        #GL_RESCALE_NORMAL
                  See @{"gl.Normal" LINK glNormal} for details.
        #GL_SCISSOR_TEST
                  See @{"gl.Scissor" LINK glScissor} for details.
        #GL_STENCIL_TEST
                  See @{"gl.StencilFunc" LINK glStencilFunc} for details. See @{"gl.StencilOp" LINK glStencilOp} for details.
        #GL_TEXTURE_1D
                  See @{"gl.TexImage1D" LINK glTexImage1D} for details.
        #GL_TEXTURE_2D
                  See @{"gl.TexImage2D" LINK glTexImage2D} for details.
        #GL_TEXTURE_COORD_ARRAY
                  See @{"gl.TexCoordPointer" LINK glTexCoordPointer} for details.
        #GL_TEXTURE_GEN_Q
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_R
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_S
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_TEXTURE_GEN_T
                  See @{"gl.TexGen" LINK glTexGen} for details.
        #GL_VERTEX_ARRAY
                  See @{"gl.VertexPointer" LINK glVertexPointer} for details.

        If an error is generated, gl.IsEnabled() returns 0.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        cap       specifies a symbolic constant indicating a GL capability

   @{b}RESULTS@{ub}
        bool      #GL_TRUE or #GL_FALSE

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "cap" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.IsEnabled() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glIsList "GL Galore Guide"

   @{b}NAME@{ub}
        gl.IsList -- determine if a name corresponds to a display list

   @{b}SYNOPSIS@{ub}
        bool = gl.IsList(list)

   @{b}FUNCTION@{ub}
        gl.IsList() returns #GL_TRUE if list is the name of a display list and
        returns #GL_FALSE if it is not, or if an error occurs.

        A name returned by @{"gl.GenLists()" LINK glGenLists}, but not yet associated with a display
        list by calling @{"gl.NewList()" LINK glNewList}, is not the name of a display list.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        list      specifies a potential display list name

   @{b}RESULTS@{ub}
        bool      #GL_TRUE or #GL_FALSE

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.IsList() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glIsTexture "GL Galore Guide"

   @{b}NAME@{ub}
        gl.IsTexture -- determine if a name corresponds to a texture

   @{b}SYNOPSIS@{ub}
        bool = gl.IsTexture(texture)

   @{b}FUNCTION@{ub}
        gl.IsTexture() returns #GL_TRUE if "texture" is currently the name of a
        texture. If "texture" is zero, or is a non-zero value that is not
        currently the name of a texture, or if an error occurs, gl.IsTexture()
        returns #GL_FALSE.

        A name returned by @{"gl.GenTextures()" LINK glGenTextures}, but not yet associated with a
        texture by calling @{"gl.BindTexture()" LINK glBindTexture}, is not the name of a texture.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        texture   specifies a value that may be the name of a texture

   @{b}RESULTS@{ub}
        bool      #GL_TRUE or #GL_FALSE

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.IsTexture() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glLight "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Light -- set light source parameters

   @{b}SYNOPSIS@{ub}
        gl.Light(light, pname, param)

   @{b}FUNCTION@{ub}
        gl.Light() sets the values of individual light source parameters.
        "light" names the light and is a symbolic name of the form #GL_LIGHTi,
        where "i" ranges from 0 to the value of #GL_MAX_LIGHTS - 1. "pname"
        specifies one of ten light source parameters, again by symbolic name.
        "param" is either a single floating-point value or a table that contains
        several floating-point values. This depends on the "pname" parameter.

        To enable and disable lighting calculation, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_LIGHTING. Lighting is initially disabled.
        When it is enabled, light sources that are enabled contribute to the
        lighting calculation. Light source i is enabled and disabled using
        @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with argument #GL_LIGHTi.

        The ten light parameters are as follows:

        #GL_AMBIENT
                  "param" must contain four floating-point values that specify
                  the ambient RGBA intensity of the light. The initial ambient
                  light intensity is (0, 0, 0, 1).

        #GL_DIFFUSE
                  "param" must contain four floating-point values that specify
                  the diffuse RGBA intensity of the light. The initial value for
                  #GL_LIGHT0 is (1, 1, 1, 1); for other lights, the initial
                  value is (0, 0, 0, 1).

        #GL_SPECULAR
                  "param" must contain four floating-point values that specify
                  the specular RGBA intensity of the light. The initial value
                  for #GL_LIGHT0 is (1, 1, 1, 1); for other lights, the initial
                  value is (0, 0, 0, 1).

        #GL_POSITION
                  "param" must contain four floating-point values that specify
                  the position of the light in homogeneous object coordinates.
                  The position is transformed by the modelview matrix when
                  gl.Light() is called (just as if it were a point), and it is
                  stored in eye coordinates. If the w component of the position
                  is 0, the light is treated as a directional source. Diffuse
                  and specular lighting calculations take the light's direction,
                  but not its actual position, into account, and attenuation is
                  disabled. Otherwise, diffuse and specular lighting
                  calculations are based on the actual location of the light in
                  eye coordinates, and attenuation is enabled. The initial
                  position is (0, 0, 1, 0); thus, the initial light source is
                  directional, parallel to, and in the direction of the -z axis.

        #GL_SPOT_DIRECTION
                  "param" must contain three floating-point values that specify
                  the direction of the light in homogeneous object coordinates.
                  The spot direction is transformed by the upper 3x3 of the
                  modelview matrix when gl.Light() is called, and it is stored
                  in eye coordinates. It is significant only when
                  #GL_SPOT_CUTOFF is not 180, which it is initially. The initial
                  direction is (0, 0, -1).

        #GL_SPOT_EXPONENT
                  "param" must be a single floating-point value that specifies
                  the intensity distribution of the light. Only values in the
                  range (0, 128) are accepted. Effective light intensity is
                  attenuated by the cosine of the angle between the direction of
                  the light and the direction from the light to the vertex being
                  lighted, raised to the power of the spot exponent. Thus,
                  higher spot exponents result in a more focused light source,
                  regardless of the spot cutoff angle (see #GL_SPOT_CUTOFF, next
                  paragraph). The initial spot exponent is 0, resulting in
                  uniform light distribution.

        #GL_SPOT_CUTOFF
                  "param" must be a single floating-point value that specifies
                  the maximum spread angle of a light source. Only values in the
                  range (0, 90) and the special value 180 are accepted. If the
                  angle between the direction of the light and the direction
                  from the light to the vertex being lighted is greater than the
                  spot cutoff angle, the light is completely masked. Otherwise,
                  its intensity is controlled by the spot exponent and the
                  attenuation factors. The initial spot cutoff is 180, resulting
                  in uniform light distribution.

        #GL_CONSTANT_ATTENUATION
                  "param" must be a single floating-point value that specifies
                  one of the three light attenuation factors. Only non-negative
                  values are accepted. If the light is positional, rather than
                  directional, its intensity is attenuated by the reciprocal of
                  the sum of the constant factor, the linear factor times the
                  distance between the light and the vertex being lighted, and
                  the quadratic factor times the square of the same distance.
                  The initial attenuation factors are (1, 0, 0), resulting in no
                  attenuation.

        #GL_LINEAR_ATTENUATION
                  See the documentation of #GL_CONSTANT_ATTENUATION above.

        #GL_QUADRATIC_ATTENUATION
                  See the documentation of #GL_CONSTANT_ATTENUATION above.

        It is always the case that #GL_LIGHTi = #GL_LIGHT0 + i.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        light     specifies a light (see above)
        pname     specifies a single-valued light source parameter for light
                  (see above)
        param     a single floating-point value or a table containing multiple
                  floating-point values (depends on the "pname" parameter, see
                  above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if either "light" or "pname" is not an
        accepted value.

        #GL_INVALID_VALUE is generated if a spot exponent value is specified
        outside the range (0, 128), or if spot cutoff is specified outside the
        range (0, 90) (except for the special value 180), or if a negative
        attenuation factor is specified.

        #GL_INVALID_OPERATION is generated if gl.Light() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetLight()" LINK glGetLight}

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_LIGHTING

@ENDNODE

@NODE glLightModel "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LightModel -- set the lighting model parameters

   @{b}SYNOPSIS@{ub}
        gl.LightModel(pname, param)

   @{b}FUNCTION@{ub}
        gl.LightModel() sets the lighting model parameter. "pname" names a
        parameter and params gives the new value. There are three lighting model
        parameters:

        #GL_LIGHT_MODEL_AMBIENT
                  "param" must contain four floating-point values that specify
                  the ambient RGBA intensity of the entire scene. The initial
                  ambient scene intensity is (0.2, 0.2, 0.2, 1.0).

        #GL_LIGHT_MODEL_LOCAL_VIEWER
                  "param" must be a single floating-point value that specifies
                  how specular reflection angles are computed. If "param" is 0,
                  specular reflection angles take the view direction to be
                  parallel to and in the direction of the -z axis, regardless of
                  the location of the vertex in eye coordinates. Otherwise,
                  specular reflections are computed from the origin of the eye
                  coordinate system. The initial value is 0.

        #GL_LIGHT_MODEL_TWO_SIDE
                  "param" must be a single floating-point value that specifies
                  whether one- or two-sided lighting calculations are done for
                  polygons. It has no effect on the lighting calculations for
                  points, lines, or bitmaps. If "param" is 0, one-sided lighting
                  is specified, and only the front material parameters are used
                  in the lighting equation. Otherwise, two-sided lighting is
                  specified. In this case, vertices of back-facing polygons are
                  lighted using the back material parameters and have their
                  normals reversed before the lighting equation is evaluated.
                  Vertices of front-facing polygons are always lighted using the
                  front material parameters, with no change to their normals.
                  The initial value is 0.

        In RGBA mode, the lighted color of a vertex is the sum of the material
        emission intensity, the product of the material ambient reflectance and
        the lighting model full-scene ambient intensity, and the contribution of
        each enabled light source. Each light source contributes the sum of
        three terms: ambient, diffuse, and specular. The ambient light source
        contribution is the product of the material ambient reflectance and the
        light's ambient intensity. The diffuse light source contribution is the
        product of the material diffuse reflectance, the light's diffuse
        intensity, and the dot product of the vertex's normal with the
        normalized vector from the vertex to the light source. The specular
        light source contribution is the product of the material specular
        reflectance, the light's specular intensity, and the dot product of the
        normalized vertex-to-eye and vertex-to-light vectors, raised to the
        power of the shininess of the material. All three light source
        contributions are attenuated equally based on the distance from the
        vertex to the light source and on light source direction, spread
        exponent, and spread cutoff angle. All dot products are replaced with 0
        if they evaluate to a negative value.

        The alpha component of the resulting lighted color is set to the alpha
        value of the material diffuse reflectance.

        In color index mode, the value of the lighted index of a vertex ranges
        from the ambient to the specular values passed to @{"gl.Material()" LINK glMaterial} using
        #GL_COLOR_INDEXES. Diffuse and specular coefficients, computed with a
        (.30,.59,.11) weighting of the lights' colors, the shininess of the
        material, and the same reflection and attenuation equations as in the
        RGBA case, determine how much above ambient the resulting index is.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies a single-valued lighting model parameter (see above)
        param     a single floating-point value or a table containing multiple
                  floating-point values (depends on the "pname" parameter, see
                  above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.LightModel() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LIGHT_MODEL_AMBIENT

        @{"gl.Get()" LINK glGet} with argument #GL_LIGHT_MODEL_LOCAL_VIEWER

        @{"gl.Get()" LINK glGet} with argument #GL_LIGHT_MODEL_TWO_SIDE

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_LIGHTING

@ENDNODE

@NODE glLineStipple "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LineStipple -- specify the line stipple pattern

   @{b}SYNOPSIS@{ub}
        gl.LineStipple(factor, pattern)

   @{b}FUNCTION@{ub}
        Line stippling masks out certain fragments produced by rasterization;
        those fragments will not be drawn. The masking is achieved by using
        three parameters: the 16-bit line stipple pattern "pattern", the repeat
        count "factor", and an integer stipple counter s.

        Counter s is reset to 0 whenever @{"gl.Begin()" LINK glBegin} is called and before each
        line segment of a

            gl.Begin(#GL_LINES)
            gl.End()

        sequence is generated. It is incremented after each fragment of a unit
        width aliased line segment is generated or after each i fragments of an
        i width line segment are generated. The i fragments associated with
        count s are masked out if

            pattern bit s factor % 16

        is 0, otherwise these fragments are sent to the frame buffer. Bit zero
        of pattern is the least significant bit.

        Antialiased lines are treated as a sequence of 1*width rectangles for
        purposes of stippling. Whether rectangle s is rasterized or not depends
        on the fragment rule described for aliased lines, counting rectangles
        rather than groups of fragments.

        To enable and disable line stippling, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable}
        with argument #GL_LINE_STIPPLE. When enabled, the line stipple pattern
        is applied as described above. When disabled, it is as if the pattern
        were all 1's. Initially, line stippling is disabled.

        Alternatively, you can also pass a string consisting of 16 characters
        that are either 0 or 1 in "pattern", e.g. "1111000011110000".

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        factor    specifies a multiplier for each bit in the line stipple
                  pattern; if factor is 3, for example, each bit in the pattern
                  is used three times before the next bit in the pattern is
                  used; factor is clamped to the range [1, 256] and defaults to
                  1.
        pattern   specifies a 16-bit integer whose bit pattern determines which
                  fragments of a line will be drawn when the line is rasterized;
                  bit zero is used first; the default pattern is all 1's.

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.LineStipple() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LINE_STIPPLE_PATTERN

        @{"gl.Get()" LINK glGet} with argument #GL_LINE_STIPPLE_REPEAT

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_LINE_STIPPLE

@ENDNODE

@NODE glLineWidth "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LineWidth -- specify the width of rasterized lines

   @{b}SYNOPSIS@{ub}
        gl.LineWidth(width)

   @{b}FUNCTION@{ub}
        gl.LineWidth() specifies the rasterized width of both aliased and
        antialiased lines. Using a line width other than 1 has different
        effects, depending on whether line antialiasing is enabled. To enable
        and disable line antialiasing, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with
        argument #GL_LINE_SMOOTH. Line antialiasing is initially disabled.

        If line antialiasing is disabled, the actual width is determined by
        rounding the supplied width to the nearest integer. (If the rounding
        results in the value 0, it is as if the line width were 1.) If delta x
        >= delta y, i pixels are filled in each column that is rasterized,
        where i is the rounded value of width. Otherwise, i pixels are filled in
        each row that is rasterized.

        If antialiasing is enabled, line rasterization produces a fragment for
        each pixel square that intersects the region lying within the rectangle
        having width equal to the current line width, length equal to the actual
        length of the line, and centered on the mathematical line segment. The
        coverage value for each fragment is the window coordinate area of the
        intersection of the rectangular region with the corresponding pixel
        square. This value is saved and used in the final rasterization step.

        Not all widths can be supported when line antialiasing is enabled. If an
        unsupported width is requested, the nearest supported width is used.
        Only width 1 is guaranteed to be supported; others depend on the
        implementation. Likewise, there is a range for aliased line widths as
        well. To query the range of supported widths and the size difference
        between supported widths within the range, call @{"gl.Get()" LINK glGet} with arguments
        #GL_LINE_WIDTH_RANGE and #GL_LINE_WIDTH_GRANULARITY.

        The line width specified by gl.LineWidth() is always returned when
        #GL_LINE_WIDTH is queried. Clamping and rounding for aliased and
        antialiased lines have no effect on the specified value.

        Nonantialiased line width may be clamped to an implementation-dependent
        maximum. Although this maximum cannot be queried, it must be no less
        than the maximum value for antialiased lines, rounded to the nearest
        integer value.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        width     specifies the width of rasterized lines; the initial value is
                  1

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "width" is less than or equal to 0.

        #GL_INVALID_OPERATION is generated if gl.LineWidth() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LINE_WIDTH

        @{"gl.Get()" LINK glGet} with argument #GL_LINE_WIDTH_RANGE

        @{"gl.Get()" LINK glGet} with argument #GL_LINE_WIDTH_GRANULARITY

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_LINE_SMOOTH

@ENDNODE

@NODE glListBase "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ListBase -- set the display-list base for gl.CallLists()

   @{b}SYNOPSIS@{ub}
        gl.ListBase(base)

   @{b}FUNCTION@{ub}
        @{"gl.CallLists()" LINK glCallLists} specifies an array of offsets. Display-list names are
        generated by adding base to each offset. Names that reference valid
        display lists are executed; the others are ignored.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        base      specifies an integer offset that will be added to
                  @{"gl.CallLists()" LINK glCallLists} offsets to generate
        display   list names; the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.ListBase() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LIST_BASE

@ENDNODE

@NODE glLoadIdentity "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LoadIdentity -- replace the current matrix with the identity matrix

   @{b}SYNOPSIS@{ub}
        gl.LoadIdentity()

   @{b}FUNCTION@{ub}
        gl.LoadIdentity() replaces the current matrix with the identity matrix.
        It is semantically equivalent to calling @{"gl.LoadMatrix()" LINK glLoadMatrix} with the
        identity matrix but in some cases it is more efficient.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.LoadIdentity() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glLoadMatrix "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LoadMatrix -- replace the current matrix with the specified matrix

   @{b}SYNOPSIS@{ub}
        gl.LoadMatrix(mArray)

   @{b}FUNCTION@{ub}
        gl.LoadMatrix() replaces the current matrix with the one whose elements
        are specified in "mArray". The current matrix is the projection matrix,
        modelview matrix, or texture matrix, depending on the current matrix
        mode See @{"gl.MatrixMode" LINK glMatrixMode} for details. (). "mArray" must store its values
        in column-major order.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mArray    specifies an array containing 16 consecutive values, which are
                  used as the elements of a 4*4 column-major matrix

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.LoadMatrix() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glLoadName "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LoadName -- load a name onto the name stack

   @{b}SYNOPSIS@{ub}
        gl.LoadName(name)

   @{b}FUNCTION@{ub}
        The name stack is used during selection mode to allow sets of rendering
        commands to be uniquely identified. It consists of an ordered set of
        unsigned integers and is initially empty.

        gl.LoadName() causes name to replace the value on the top of the name
        stack.

        The name stack is always empty while the render mode is not #GL_SELECT.
        Calls to gl.LoadName() while the render mode is not #GL_SELECT are
        ignored.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        name      specifies a name that will replace the top value on the name
                  stack

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.LoadName() is called while the
        name stack is empty.

        #GL_INVALID_OPERATION is generated if gl.LoadName() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_NAME_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_NAME_STACK_DEPTH

@ENDNODE

@NODE glLogicOp "GL Galore Guide"

   @{b}NAME@{ub}
        gl.LogicOp -- specify a logical pixel operation for color index rendering

   @{b}SYNOPSIS@{ub}
        gl.LogicOp(opcode)

   @{b}FUNCTION@{ub}
        gl.LogicOp() specifies a logical operation that, when enabled, is
        applied between the incoming color index or RGBA color and the color
        index or RGBA color at the corresponding location in the frame buffer.
        To enable or disable the logical operation, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} using the symbolic constant #GL_COLOR_LOGIC_OP for RGBA
        mode or #GL_INDEX_LOGIC_OP for color index mode. The initial value is
        disabled for both operations.

        #GL_CLEAR 0
        #GL_SET   1
        #GL_COPY  s
        #GL_COPY_INVERTED
                  ~s
        #GL_NOOP  d
        #GL_INVERT
                  ~d
        #GL_AND   s & d
        #GL_NAND  ~(s & d)
        #GL_OR    s | d
        #GL_NOR   ~(s | d)
        #GL_XOR   s ^ d
        #GL_EQUIV ~(s ^ d)
        #GL_AND_REVERSE
                  s & ~d
        #GL_AND_INVERTED
                  ~s & d
        #GL_OR_REVERSE
                  s | ~d
        #GL_OR_INVERTED
                  ~s | d

        "opcode" is a symbolic constant chosen from the list above. In the
        explanation of the logical operations, "s" represents the incoming color
        index and "d" represents the index in the frame buffer. Standard
        C-language operators are used. As these bitwise operators suggest, the
        logical operation is applied independently to each bit pair of the
        source and destination indices or colors.

        Color index logical operations are always supported. RGBA logical
        operations are supported only if the GL version is 1.1 or greater.

        When more than one RGBA color or index buffer is enabled for drawing,
        logical operations are performed separately for each enabled buffer,
        using for the destination value the contents of that buffer See
        @{"gl.DrawBuffer" LINK glDrawBuffer} for details. ().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        opcode    specifies a symbolic constant that selects a logical operation
                  (see above for supported constants)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "opcode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.LogicOp() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_LOGIC_OP_MODE.

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_COLOR_LOGIC_OP or #GL_INDEX_LOGIC_OP.

@ENDNODE

@NODE glMap "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Map -- define a one- or two-dimensional evaluator

   @{b}SYNOPSIS@{ub}
        gl.Map(target, u1, u2, pointsArray)
        gl.Map(target, u1, u2, v1, v2, pointsArray)

   @{b}FUNCTION@{ub}
        Evaluators provide a way to use polynomial or rational polynomial
        mapping to produce vertices, normals, texture coordinates, and colors.
        The values produced by an evaluator are sent to further stages of GL
        processing just as if they had been presented using @{"gl.Vertex()" LINK glVertex},
        @{"gl.Normal()" LINK glNormal}, @{"gl.TexCoord()" LINK glTexCoord}, and @{"gl.Color()" LINK glColor} commands, except that the
        generated values do not update the current normal, texture coordinates,
        or color.

        All polynomial or rational polynomial splines of any degree (up to the
        maximum degree supported by the GL implementation) can be described
        using evaluators. These include almost all splines used in computer
        graphics: B-splines, Bezier curves, Hermite splines, and so on.

        gl.Map() is used to define the basis and to specify what kind of values
        are produced. Once defined, a map can be enabled and disabled by calling
        @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with the map name, one of the nine
        predefined values for target described below. @{"gl.EvalCoord()" LINK glEvalCoord} evaluates
        the one-dimensional maps that are enabled. When @{"gl.EvalCoord()" LINK glEvalCoord} presents
        a value u or values u and v, the Bernstein functions are evaluated using
        u^ and v^, where

            u^ = (u - u1) / (u2 - u1)
            v^ = (v - v1) / (v2 - v1)

        "target" is a symbolic constant that indicates what kind of control
        points are provided in "pointsArray", and what output is generated when
        the map is evaluated. In one-dimensional mode it can assume one of the
        following nine predefined values:

        #GL_MAP1_VERTEX_3
                  Each control point is three floating-point values representing
                  x, y, and z. Internal @{"gl.Vertex()" LINK glVertex} commands are generated when
                  the map is evaluated.

        #GL_MAP1_VERTEX_4
                  Each control point is four floating-point values representing
                  x, y, z, and w. Internal @{"gl.Vertex()" LINK glVertex} commands are generated
                  when the map is evaluated.

        #GL_MAP1_INDEX
                  Each control point is a single floating-point value
                  representing a color index. Internal @{"gl.Index()" LINK glIndex} commands are
                  generated when the map is evaluated but the current index is
                  not updated with the value of these @{"gl.Index()" LINK glIndex} commands.

        #GL_MAP1_COLOR_4
                  Each control point is four floating-point values representing
                  red, green, blue, and alpha. Internal @{"gl.Color()" LINK glColor} commands are
                  generated when the map is evaluated but the current color is
                  not updated with the value of these @{"gl.Color()" LINK glColor} commands.

        #GL_MAP1_NORMAL
                  Each control point is three floating-point values representing
                  the x, y, and z components of a normal vector. Internal
                  @{"gl.Normal()" LINK glNormal} commands are generated when the map is evaluated
                  but the current normal is not updated with the value of these
                  @{"gl.Normal()" LINK glNormal} commands.

        #GL_MAP1_TEXTURE_COORD_1
                  Each control point is a single floating-point value
                  representing the s texture coordinate. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP1_TEXTURE_COORD_2
                  Each control point is two floating-point values representing
                  the s and t texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP1_TEXTURE_COORD_3
                  Each control point is three floating-point values representing
                  the s, t, and r texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP1_TEXTURE_COORD_4
                  Each control point is four floating-point values representing
                  the s, t, r, and q texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        In two-dimensional mode the following predefined constants are
        supported:

        #GL_MAP2_VERTEX_3
                  Each control point is three floating-point values representing
                  x, y, and z. Internal @{"gl.Vertex()" LINK glVertex} commands are generated when
                  the map is evaluated.

        #GL_MAP2_VERTEX_4
                  Each control point is four floating-point values representing
                  x, y, z, and w. Internal @{"gl.Vertex()" LINK glVertex} commands are generated
                  when the map is evaluated.

        #GL_MAP2_INDEX
                  Each control point is a single floating-point value
                  representing a color index. Internal @{"gl.Index()" LINK glIndex} commands are
                  generated when the map is evaluated but the current index is
                  not updated with the value of these @{"gl.Index()" LINK glIndex} commands.

        #GL_MAP2_COLOR_4
                  Each control point is four floating-point values representing
                  red, green, blue, and alpha. Internal @{"gl.Color()" LINK glColor} commands are
                  generated when the map is evaluated but the current color is
                  not updated with the value of these @{"gl.Color()" LINK glColor} commands.

        #GL_MAP2_NORMAL
                  Each control point is three floating-point values representing
                  the x, y, and z components of a normal vector. Internal
                  @{"gl.Normal()" LINK glNormal} commands are generated when the map is evaluated
                  but the current normal is not updated with the value of these
                  @{"gl.Normal()" LINK glNormal} commands.

        #GL_MAP2_TEXTURE_COORD_1
                  Each control point is a single floating-point value
                  representing the s texture coordinate. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP2_TEXTURE_COORD_2
                  Each control point is two floating-point values representing
                  the s and t texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP2_TEXTURE_COORD_3
                  Each control point is three floating-point values representing
                  the s, t, and r texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        #GL_MAP2_TEXTURE_COORD_4
                  Each control point is four floating-point values representing
                  the s, t, r, and q texture coordinates. Internal @{"gl.TexCoord()" LINK glTexCoord}
                  commands are generated when the map is evaluated but the
                  current texture coordinates are not updated with the value of
                  these @{"gl.TexCoord()" LINK glTexCoord} commands.

        Initially, #GL_AUTO_NORMAL is enabled. If #GL_AUTO_NORMAL is enabled,
        normal vectors are generated when either #GL_MAP2_VERTEX_3 or
        #GL_MAP2_VERTEX_4 is used to generate vertices.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        target    specifies the kind of values that are generated by the
                  evaluator (see above)
        u1        specify a linear mapping of u, as presented to @{"gl.EvalCoord()" LINK glEvalCoord},
                  to u^, the variable that is evaluated by the equations
                  specified by this command
        u2        specify a linear mapping of u, as presented to @{"gl.EvalCoord()" LINK glEvalCoord},
                  to u^, the variable that is evaluated by the equations
                  specified by this command
        v1        specify a linear mapping of v, as presented to @{"gl.EvalCoord()" LINK glEvalCoord},
                  to v^, one of the two variables that are evaluated by the
                  equations specified by this command
        v2        specify a linear mapping of v, as presented to @{"gl.EvalCoord()" LINK glEvalCoord},
                  to v^, one of the two variables that are evaluated by the
                  equations specified by this command
        pointsArray
                  specifies a table containing a number of control points (see
                  above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "target" is not an accepted value.

        #GL_INVALID_VALUE is generated if "u1" is equal to "u2", or if "v1" is
        equal to "v2".

        #GL_INVALID_OPERATION is generated if gl.Map() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetMap()" LINK glGetMap}

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_EVAL_ORDER

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_VERTEX_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_VERTEX_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_INDEX

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_COLOR_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_NORMAL

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_1

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_2

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP1_TEXTURE_COORD_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_VERTEX_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_VERTEX_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_INDEX

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_COLOR_4

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_NORMAL

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_1

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_2

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_3

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_MAP2_TEXTURE_COORD_4

@ENDNODE

@NODE glMapGrid "GL Galore Guide"

   @{b}NAME@{ub}
        gl.MapGrid -- define a one- or two-dimensional mesh

   @{b}SYNOPSIS@{ub}
        gl.MapGrid(un, u1, u2[, vn, v1, v2])

   @{b}FUNCTION@{ub}
        gl.MapGrid() and @{"gl.EvalMesh()" LINK glEvalMesh} are used together to efficiently generate
        and evaluate a series of evenly-spaced map domain values. @{"gl.EvalMesh()" LINK glEvalMesh}
        steps through the integer domain of a one- or two-dimensional grid,
        whose range is the domain of the evaluation maps specified by @{"gl.Map()" LINK glMap}.

        gl.MapGrid() specifies the linear grid mappings between the i (or i and
        j) integer grid coordinates, to the u (or u and v) floating-point
        evaluation map coordinates. See @{"gl.Map" LINK glMap} for details of how u and v
        coordinates are evaluated.

        In one-dimensional mode, gl.MapGrid() specifies a single linear mapping
        such that integer grid coordinate 0 maps exactly to u1, and integer grid
        coordinate un maps exactly to u2. All other integer grid coordinates i
        are mapped so that

            u = i(u2 - u1) / un + u1

        In two-dimensional mode gl.MapGrid() specifies two such linear mappings.
        One maps integer grid coordinate i = 0 exactly to u1, and integer grid
        coordinate i = un exactly to u2. The other maps integer grid coordinate
        j = 0 exactly to v1, and integer grid coordinate j = vn exactly to v2.
        Other integer grid coordinates i and j are mapped such that

            u = i(u2 - u1) / un + u1
            v = j(v2 - v1) / vn + v1

        The mappings specified by gl.MapGrid() are used identically by
        @{"gl.EvalMesh()" LINK glEvalMesh} and @{"gl.EvalPoint()" LINK glEvalPoint}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        un        specifies the number of partitions in the grid range interval
                  [u1, u2]; must be positive
        u1        specify the mappings for integer grid domain values i = 0 and
                  i = un
        u2        specify the mappings for integer grid domain values i = 0 and
                  i = un
        vn        optional: specifies the number of partitions in the grid range
                  interval [v1, v2]
        v1        optional: specify the mappings for integer grid domain values
                  j = 0 and j = vn
        v2        optional: specify the mappings for integer grid domain values
                  j = 0 and j = vn

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if either "un" or "vn" is not positive.

        #GL_INVALID_OPERATION is generated if gl.MapGrid() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_DOMAIN

        @{"gl.Get()" LINK glGet} with argument #GL_MAP1_GRID_SEGMENTS

        @{"gl.Get()" LINK glGet} with argument #GL_MAP2_GRID_SEGMENTS

@ENDNODE

@NODE glMaterial "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Material -- specify material parameters for the lighting model

   @{b}SYNOPSIS@{ub}
        gl.Material(face, pname, param)

   @{b}FUNCTION@{ub}
        gl.Material() assigns values to material parameters. There are two
        matched sets of material parameters. One, the front-facing set, is used
        to shade points, lines, bitmaps, and all polygons (when two-sided
        lighting is disabled), or just front-facing polygons (when two-sided
        lighting is enabled). The other set, back-facing, is used to shade
        back-facing polygons only when two-sided lighting is enabled. See
        @{"gl.LightModel" LINK glLightModel} for details concerning one- and two-sided lighting
        calculations.

        gl.Material() takes three arguments. The first, "face", specifies
        whether the #GL_FRONT materials, the #GL_BACK materials, or both
        #GL_FRONT_AND_BACK materials will be modified. The second, "pname",
        specifies which of several parameters in one or both sets will be
        modified. The third, "param", specifies what value or values will be
        assigned to the specified parameter. It can be single floating-point
        value or a table containing multiple floating-point values.

        Material parameters are used in the lighting equation that is optionally
        applied to each vertex. The equation is discussed in the @{"gl.LightModel()" LINK glLightModel}
        reference page. The parameters that can be specified using
        gl.Material(), and their interpretations by the lighting equation, are
        as follows:

        #GL_AMBIENT
                  "param" must be a table containing four floating-point values
                  that specify the ambient RGBA reflectance of the material. The
                  initial ambient reflectance for both front- and back-facing
                  materials is (0.2, 0.2, 0.2, 1.0).

        #GL_DIFFUSE
                  "param" must be a table containing four floating-point values
                  that specify the diffuse RGBA reflectance of the material. The
                  initial diffuse reflectance for both front- and back-facing
                  materials is (0.8, 0.8, 0.8, 1.0).

        #GL_SPECULAR
                  "param" must be a table containing four floating-point values
                  that specify the specular RGBA reflectance of the material.
                  The initial specular reflectance for both front- and
                  back-facing materials is (0, 0, 0, 1).

        #GL_EMISSION
                  "param" must be a table containing four floating-point values
                  that specify the RGBA emitted light intensity of the material.
                  The initial emission intensity for both front- and back-facing
                  materials is (0, 0, 0, 1).

        #GL_SHININESS
                  "param" must be a single floating-point value that specifies
                  the RGBA specular exponent of the material. Only values in the
                  range (0,128) are accepted. The initial specular exponent for
                  both front- and back-facing materials is 0.

        #GL_AMBIENT_AND_DIFFUSE
                  Equivalent to calling gl.Material() twice with the same
                  parameter values, once with #GL_AMBIENT and once with
                  #GL_DIFFUSE.

        #GL_COLOR_INDEXES
                  "param" must be a table containing three floating-point values
                  specifying the color indices for ambient, diffuse, and
                  specular lighting. These three values, and #GL_SHININESS, are
                  the only material values used by the color index mode lighting
                  equation. See @{"gl.LightModel" LINK glLightModel} for a discussion of color index
                  lighting.

        The material parameters can be updated at any time. In particular,
        gl.Material() can be called between a call to @{"gl.Begin()" LINK glBegin} and the
        corresponding call to @{"gl.End()" LINK glEnd}. If only a single material parameter is
        to be changed per vertex, however, @{"gl.ColorMaterial()" LINK glColorMaterial} is preferred over
        gl.Material() See @{"gl.ColorMaterial" LINK glColorMaterial} for details. ().

        While the ambient, diffuse, specular and emission material parameters
        all have alpha components, only the diffuse alpha component is used in
        the lighting computation.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        face      specifies which face or faces are being updated; must be one
                  of #GL_FRONT, #GL_BACK, or #GL_FRONT_AND_BACK
        pname     specifies the material parameter of the face or faces that is
                  being updated (see above)
        param     a floating-point value (or a table containing multiple
                  floating-point values) that "pname" will be set to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if either "face" or "pname" is not an
        accepted value.

        #GL_INVALID_VALUE is generated if a specular exponent outside the range
        (0,128) is specified.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetMaterial()" LINK glGetMaterial}

@ENDNODE

@NODE glMatrixMode "GL Galore Guide"

   @{b}NAME@{ub}
        gl.MatrixMode -- specify which matrix is the current matrix

   @{b}SYNOPSIS@{ub}
        gl.MatrixMode(mode)

   @{b}FUNCTION@{ub}
        gl.MatrixMode() sets the current matrix mode. "mode" can assume one of
        three values:

        #GL_MODELVIEW
                  Applies subsequent matrix operations to the modelview matrix
                  stack.

        #GL_PROJECTION
                  Applies subsequent matrix operations to the projection matrix
                  stack.

        #GL_TEXTURE
                  Applies subsequent matrix operations to the texture matrix
                  stack.

        To find out which matrix stack is currently the target of all matrix
        operations, call @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE. The initial
        value is #GL_MODELVIEW.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies which matrix stack is the target for subsequent
                  matrix operations (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.MatrixMode() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

@ENDNODE

@NODE glMultMatrix "GL Galore Guide"

   @{b}NAME@{ub}
        gl.MultMatrix -- multiply the current matrix with the specified matrix

   @{b}SYNOPSIS@{ub}
        gl.MultMatrix(mArray)

   @{b}FUNCTION@{ub}
        gl.MultMatrix() multiplies the current matrix with the one specified
        using mArray, and replaces the current matrix with the product.

        The current matrix is determined by the current matrix mode See
        @{"gl.MatrixMode" LINK glMatrixMode} for details. (). It is either the projection matrix,
        modelview matrix, or the texture matrix.

        While the elements of the matrix are specified with double precision,
        the GL may store or operate on these values in less-than-single
        precision.

        In many computer languages, 4x4 arrays are represented in row-major
        order. The transformations just described represent these matrices in
        column-major order. The order of the multiplication is important. For
        example, if the current transformation is a rotation, and
        gl.MultMatrix() is called with a translation matrix, the translation is
        done directly on the coordinates to be transformed, while the rotation
        is done on the results of that translation.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mArray    table containing 16 consecutive values that are used as the
                  elements of a 4x4 column-major matrix

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if glMultMatrix is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glNewList "GL Galore Guide"

   @{b}NAME@{ub}
        gl.NewList -- create or replace a display list

   @{b}SYNOPSIS@{ub}
        gl.NewList(list, mode)

   @{b}FUNCTION@{ub}
        Display lists are groups of GL commands that have been stored for
        subsequent execution. Display lists are created with gl.NewList(). All
        subsequent commands are placed in the display list, in the order issued,
        until @{"gl.EndList()" LINK glEndList} is called.

        gl.NewList() has two arguments. The first argument, "list", is a
        positive integer that becomes the unique name for the display list.
        Names can be created and reserved with @{"gl.GenLists()" LINK glGenLists} and tested for
        uniqueness with @{"gl.IsList()" LINK glIsList}. The second argument, "mode", is a symbolic
        constant that can assume one of two values:

        #GL_COMPILE
                  Commands are merely compiled.

        #GL_COMPILE_AND_EXECUTE
                  Commands are executed as they are compiled into the display
                  list.

        Certain commands are not compiled into the display list but are executed
        immediately, regardless of the display list mode that is currently
        active. These commands are @{"gl.AreTexturesResident()" LINK glAreTexturesResident}, @{"gl.ColorPointer()" LINK glColorPointer},
        @{"gl.DeleteLists()" LINK glDeleteLists}, @{"gl.DeleteTextures()" LINK glDeleteTextures}, and @{"gl.DisableClientState()" LINK glDisableClientState},
        @{"gl.EdgeFlagPointer()" LINK glEdgeFlagPointer}, @{"gl.EnableClientState()" LINK glEnableClientState}, and @{"gl.FeedbackBuffer()" LINK glFeedbackBuffer},
        @{"gl.Finish()" LINK glFinish}, @{"gl.Flush()" LINK glFlush}, @{"gl.GenLists()" LINK glGenLists}, @{"gl.GenTextures()" LINK glGenTextures},
        @{"gl.IndexPointer()" LINK glIndexPointer}, @{"gl.InterleavedArrays()" LINK glInterleavedArrays}, @{"gl.IsEnabled()" LINK glIsEnabled}, and also
        @{"gl.IsList()" LINK glIsList}, @{"gl.IsTexture()" LINK glIsTexture}, @{"gl.NormalPointer()" LINK glNormalPointer}, @{"gl.PopClientAttrib()" LINK glPopClientAttrib},
        and finally also @{"gl.PixelStore()" LINK glPixelStore}, @{"gl.PushClientAttrib()" LINK glPushClientAttrib},
        @{"gl.ReadPixels()" LINK glReadPixels}, @{"gl.RenderMode()" LINK glRenderMode}, @{"gl.SelectBuffer()" LINK glSelectBuffer},
        @{"gl.TexCoordPointer()" LINK glTexCoordPointer}, @{"gl.VertexPointer()" LINK glVertexPointer}, and all of the @{"gl.Get()" LINK glGet}
        commands.

        When @{"gl.EndList()" LINK glEndList} is encountered, the display-list definition is
        completed by associating the list with the unique name list (specified
        in the gl.NewList() command). If a display list with name list already
        exists, it is replaced only when @{"gl.EndList()" LINK glEndList} is called.

        @{"gl.CallList()" LINK glCallList} and @{"gl.CallLists()" LINK glCallLists} can be entered into display lists.
        Commands in the display list or lists executed by @{"gl.CallList()" LINK glCallList} or
        @{"gl.CallLists()" LINK glCallLists} are not included in the display list being created, even
        if the list creation mode is #GL_COMPILE_AND_EXECUTE.

        A display list is just a group of commands and arguments, so errors
        generated by commands in a display list must be generated when the list
        is executed. If the list is created in #GL_COMPILE mode, errors are not
        generated until the list is executed.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        list      specifies the display-list name as an integer
        mode      specifies the compilation mode, which can be #GL_COMPILE or
                  #GL_COMPILE_AND_EXECUTE

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "list" is 0.

        #GL_INVALID_ENUM is generated if "mode" is not an accepted value.

        #GL_INVALID_OPERATION is generated if @{"gl.EndList()" LINK glEndList} is called without a
        preceding gl.NewList(), or if gl.NewList() is called while a display
        list is being defined.

        #GL_INVALID_OPERATION is generated if gl.NewList() or @{"gl.EndList()" LINK glEndList} is
        executed between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding
        execution of @{"gl.End()" LINK glEnd}.

        #GL_OUT_OF_MEMORY is generated if there is insufficient memory to
        compile the display list. If the GL version is 1.1 or greater, no change
        is made to the previous contents of the display list, if any, and no
        other change is made to the GL state. (It is as if no attempt had been
        made to create the new display list.)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsList()" LINK glIsList}

        @{"gl.Get()" LINK glGet} with argument #GL_LIST_INDEX

        @{"gl.Get()" LINK glGet} with argument #GL_LIST_MODE

@ENDNODE

@NODE glNormal "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Normal -- set the current normal vector

   @{b}SYNOPSIS@{ub}
        gl.Normal(nx, ny, nz)

   @{b}FUNCTION@{ub}
        The current normal is set to the given floating-point coordinates
        whenever gl.Normal() is issued. The initial value of the current normal
        is the unit vector, (0, 0, 1). Alternatively, gl.Normal() can also be
        called with a single table element containing the x, y, z normal
        coordinates.

        Normals specified with gl.Normal() need not have unit length. If
        #GL_NORMALIZE is enabled, then normals of any length specified with
        gl.Normal() are normalized after transformation. If #GL_RESCALE_NORMAL
        is enabled, normals are scaled by a scaling factor derived from the
        modelview matrix. #GL_RESCALE_NORMAL requires that the originally
        specified normals were of unit length, and that the modelview matrix
        contain only uniform scales for proper results. To enable and disable
        normalization, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with either
        #GL_NORMALIZE or #GL_RESCALE_NORMAL. Normalization is initially
        disabled.

        The current normal can be updated at any time. In particular,
        gl.Normal() can be called between a call to @{"gl.Begin()" LINK glBegin} and the
        corresponding call to @{"gl.End()" LINK glEnd}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        nx        specify the x coordinate of the new current normal
        ny        specify the y coordinate of the new current normal
        nz        specify the z coordinate of the new current normal

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_NORMAL

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_NORMALIZE

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_RESCALE_NORMAL

@ENDNODE

@NODE glNormalPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.NormalPointer -- define an array of normals

   @{b}SYNOPSIS@{ub}
        gl.NormalPointer(normalArray[, type])

   @{b}FUNCTION@{ub}
        gl.NormalPointer() specifies an array of normals to use when rendering.
        "normalArray" can be either a one-dimensional table consisting of an
        arbitrary number of consecutive normals or a two-dimensional table
        consisting of an arbitrary number of subtables which contain a normal
        each. Every normal must contain x, y, and z coordinates specified as
        floating-point values. If "normalArray" is a one-dimensional table, you
        need to set the optional "type" argument to #GL_TRUE. If "normalArray"
        is a two-dimensional table, you can leave out the optional "type"
        argument or set it to #GL_FALSE.

        If you pass Nil in "normalArray", the normal array buffer will be freed
        but it won't be removed from OpenGL. You need to do this manually, e.g.
        by disabling the normal array or defining a new one.

        To enable and disable the normal array, call @{"gl.EnableClientState()" LINK glEnableClientState} and
        @{"gl.DisableClientState()" LINK glDisableClientState} with the argument #GL_NORMAL_ARRAY. If enabled,
        the normal array is used when @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or
        @{"gl.ArrayElement()" LINK glArrayElement} is called.

        The normal array is initially disabled and isn't accessed when
        @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is called.

        Execution of gl.NormalPointer() is not allowed between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.NormalPointer() is typically implemented on the client side.

        Normal array parameters are client-side state and are therefore not
        saved or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}. Use
        @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        normalArray
                  one- or two-dimensional table containing normal values or Nil
                  (see above)
        type      optional: #GL_TRUE if the table in argument 1 is a
                  one-dimensional table, else #GL_FALSE (defaults to #GL_FALSE)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_NORMAL_ARRAY

        @{"gl.Get()" LINK glGet} with argument #GL_NORMAL_ARRAY_TYPE

        @{"gl.Get()" LINK glGet} with argument #GL_NORMAL_ARRAY_STRIDE

        @{"gl.GetPointer()" LINK glGetPointer} with argument #GL_NORMAL_ARRAY_POINTER

@ENDNODE

@NODE glOrtho "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Ortho -- multiply the current matrix with an orthographic matrix

   @{b}SYNOPSIS@{ub}
        gl.Ortho(left, right, bottom, top, zNear, zFar)

   @{b}FUNCTION@{ub}
        gl.Ortho() describes a transformation that produces a parallel
        projection. The current matrix See @{"gl.MatrixMode" LINK glMatrixMode} for details. () is
        multiplied by this matrix and the result replaces the current matrix, as
        if @{"gl.MultMatrix()" LINK glMultMatrix} were called with the following matrix as its
        argument:

            A 0 0 tx
            0 B 0 ty
            0 0 C tz
            0 0 0 1

        where

            A = 2 / (right - left)
            B = 2 / (top - bottom)
            C = -2 / (far  - near)
            tx = -(right + left) / (right  - left)
            ty = -(top + bottom) / (top  - bottom)
            tz = -(zFar + zNear) / (zFar  - zNear)

        Typically, the matrix mode is #GL_PROJECTION, and (left, bottom, -zNear)
        and (right, top, -zNear) specify the points on the near clipping plane
        that are mapped to the lower left and upper right corners of the window,
        respectively, assuming that the eye is located at (0, 0, 0). -zFar
        specifies the location of the far clipping plane. Both zNear and zFar
        can be either positive or negative.

        Use @{"gl.PushMatrix()" LINK glPushMatrix} and @{"gl.PopMatrix()" LINK glPopMatrix} to save and restore the current
        matrix stack.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        left      specify the coordinate for the left vertical clipping plane
        right     specify the coordinate for the right vertical clipping plane
        bottom    specify the coordinate for the bottom horizontal clipping
                  plane
        top       specify the coordinate for the top horizontal clipping plane
        zNear     specify the distance to the nearer depth clipping plane; this
                  value is negative if the plane is to be behind the viewer
        zFar      specify the distance to the farther depth clipping plane; this
                  value is negative if the plane is to be behind the viewer

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if left = right, or bottom = top, or
        zNear = zFar.

        #GL_INVALID_OPERATION is generated if gl.Ortho() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glPassThrough "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PassThrough -- place a marker in the feedback buffer

   @{b}SYNOPSIS@{ub}
        gl.PassThrough(token)

   @{b}FUNCTION@{ub}
        Feedback is a GL render mode. The mode is selected by calling
        @{"gl.RenderMode()" LINK glRenderMode} with #GL_FEEDBACK. When the GL is in feedback mode, no
        pixels are produced by rasterization. Instead, information about
        primitives that would have been rasterized is fed back to the
        application using the GL. See @{"gl.FeedbackBuffer" LINK glFeedbackBuffer} for a description of the
        feedback buffer and the values in it.

        gl.PassThrough() inserts a user-defined marker in the feedback buffer
        when it is executed in feedback mode. "token" is returned as if it were
        a primitive; it is indicated with its own unique identifying value:
        #GL_PASS_THROUGH_TOKEN. The order of gl.PassThrough() commands with
        respect to the specification of graphics primitives is maintained.

        gl.PassThrough() is ignored if the GL is not in feedback mode.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        token     specifies a marker value to be placed in the feedback buffer
                  following a #GL_PASS_THROUGH_TOKEN

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.PassThrough() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_RENDER_MODE

@ENDNODE

@NODE glPixelMap "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PixelMap -- set up pixel transfer maps

   @{b}SYNOPSIS@{ub}
        gl.PixelMap(map, valuesArray)

   @{b}FUNCTION@{ub}
        gl.PixelMap() sets up translation tables, or maps, used by
        @{"gl.CopyPixels()" LINK glCopyPixels}, @{"gl.CopyTexImage()" LINK glCopyTexImage}, @{"gl.CopyTexSubImage()" LINK glCopyTexSubImage},
        @{"gl.DrawPixels()" LINK glDrawPixels}, @{"gl.ReadPixels()" LINK glReadPixels}, @{"gl.TexImage()" LINK glTexImage}, and also
        @{"gl.TexImage1D()" LINK glTexImage1D}, @{"gl.TexImage2D()" LINK glTexImage2D}, @{"gl.TexSubImage()" LINK glTexSubImage},
        @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, and @{"gl.TexSubImage2D()" LINK glTexSubImage2D}. Use of these maps is
        described completely in the @{"gl.PixelTransfer()" LINK glPixelTransfer} reference page, and
        partly in the reference pages for the pixel and texture image commands.
        Only the specification of the maps is described in this reference page.

        "map" is a symbolic map name, indicating one of ten maps to set.
        "values" is a table that contains an array of values for the specified
        map name. The ten maps are as follows:

        #GL_PIXEL_MAP_I_TO_I
                  Maps color indices to color indices.

        #GL_PIXEL_MAP_S_TO_S
                  Maps stencil indices to stencil indices.

        #GL_PIXEL_MAP_I_TO_R
                  Maps color indices to red components.

        #GL_PIXEL_MAP_I_TO_G
                  Maps color indices to green components.

        #GL_PIXEL_MAP_I_TO_B
                  Maps color indices to blue components.

        #GL_PIXEL_MAP_I_TO_A
                  Maps color indices to alpha components.

        #GL_PIXEL_MAP_R_TO_R
                  Maps red components to red components.

        #GL_PIXEL_MAP_G_TO_G
                  Maps green components to green components.

        #GL_PIXEL_MAP_B_TO_B
                  Maps blue components to blue components.

        #GL_PIXEL_MAP_A_TO_A
                  Maps alpha components to alpha components.

        The entries in a map are specified as floating-point numbers. Maps that
        store color component values (all but #GL_PIXEL_MAP_I_TO_I and
        #GL_PIXEL_MAP_S_TO_S) retain their values in floating-point format, with
        unspecified mantissa and exponent sizes. Floating-point values specified
        by gl.PixelMap() are converted directly to the internal floating-point
        format of these maps, then clamped to the range [0,1].

        Maps that store indices, #GL_PIXEL_MAP_I_TO_I and #GL_PIXEL_MAP_S_TO_S,
        retain their values in fixed-point format, with an unspecified number of
        bits to the right of the binary point. Floating-point values specified
        by gl.PixelMap() are converted directly to the internal fixed-point
        format of these maps.

        The following table shows the initial sizes and values for each of the
        maps. Maps that are indexed by either color or stencil indices must have
        mapsize = 2n for some n or the results are undefined. The maximum
        allowable size for each map depends on the implementation and can be
        determined by calling glGet with argument #GL_MAX_PIXEL_MAP_TABLE. The
        single maximum applies to all maps; it is at least 32.

                    Map          Lookup Index   Lookup Value  Def Size Def Value
            --------------------------------------------------------------------
            #GL_PIXEL_MAP_I_TO_I color index     color index      1       0
            #GL_PIXEL_MAP_S_TO_S stencil index  stencil index     1       0
            #GL_PIXEL_MAP_I_TO_R color index         R            1       0
            #GL_PIXEL_MAP_I_TO_G color index         G            1       0
            #GL_PIXEL_MAP_I_TO_B color index         B            1       0
            #GL_PIXEL_MAP_I_TO_A color index         A            1       0
            #GL_PIXEL_MAP_R_TO_R      R              R            1       0
            #GL_PIXEL_MAP_G_TO_G      G              G            1       0
            #GL_PIXEL_MAP_B_TO_B      B              B            1       0
            #GL_PIXEL_MAP_A_TO_A      A              A            1       0

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        map       specifies a symbolic map name (see above for supported names)
        valuesArray
                  specifies a table containing an array of values

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if map is not an accepted value.

        #GL_INVALID_VALUE is generated if mapsize is less than one or larger
        than #GL_MAX_PIXEL_MAP_TABLE.

        #GL_INVALID_VALUE is generated if map is #GL_PIXEL_MAP_I_TO_I,
        #GL_PIXEL_MAP_S_TO_S, #GL_PIXEL_MAP_I_TO_R, #GL_PIXEL_MAP_I_TO_G,
        #GL_PIXEL_MAP_I_TO_B, or #GL_PIXEL_MAP_I_TO_A, and mapsize is not a
        power of two.

        #GL_INVALID_OPERATION is generated if gl.PixelMap() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetPixelMap()" LINK glGetPixelMap}

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_I_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_S_TO_S_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_R_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_G_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_B_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_I_TO_A_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_R_TO_R_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_G_TO_G_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_B_TO_B_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_PIXEL_MAP_A_TO_A_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_PIXEL_MAP_TABLE

@ENDNODE

@NODE glPixelStore "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PixelStore -- set pixel storage modes

   @{b}SYNOPSIS@{ub}
        gl.PixelStore(pname, param)

   @{b}FUNCTION@{ub}
        gl.PixelStore() sets pixel storage modes that affect the operation of
        subsequent @{"gl.DrawPixels()" LINK glDrawPixels} and @{"gl.ReadPixels()" LINK glReadPixels} as well as the unpacking
        of polygon stipple patterns See @{"gl.PolygonStipple" LINK glPolygonStipple} for details. (),
        bitmaps See @{"gl.Bitmap" LINK glBitmap} for details. (), texture patterns See @{"gl.TexImage" LINK glTexImage}
        for details. ().

        "pname" is a symbolic constant indicating the parameter to be set, and
        "param" is the new value. Six of the twelve storage parameters affect
        how pixel data is returned to client memory. They are as follows:

        #GL_PACK_SWAP_BYTES
                  If true, byte ordering for multibyte color components, depth
                  components, color indices, or stencil indices is reversed.
                  That is, if a four-byte component consists of bytes b0, b1,
                  b2, b3, it is stored in memory as b3, b2, b1, b0 if
                  #GL_PACK_SWAP_BYTES is true. #GL_PACK_SWAP_BYTES has no effect
                  on the memory order of components within a pixel, only on the
                  order of bytes within components or indices. For example, the
                  three components of a #GL_RGB format pixel are always stored
                  with red first, green second, and blue third, regardless of
                  the value of #GL_PACK_SWAP_BYTES.

        #GL_PACK_LSB_FIRST
                  If true, bits are ordered within a byte from least significant
                  to most significant; otherwise, the first bit in each byte is
                  the most significant one. This parameter is significant for
                  bitmap data only.

        #GL_PACK_ROW_LENGTH
                  If greater than 0, #GL_PACK_ROW_LENGTH defines the number of
                  pixels in a row. If the first pixel of a row is placed at
                  location p in memory, then the location of the first pixel of
                  the next row is obtained by skipping a certain number of
                  components or indices. See an OpenGL reference manual for
                  details.

        #GL_PACK_SKIP_PIXELS
                  This value is provided as a convenience to the programmer; it
                  provides no functionality that cannot be duplicated simply by
                  incrementing the pointer passed to @{"gl.ReadPixels()" LINK glReadPixels}. Setting
                  #GL_PACK_SKIP_PIXELS to i is equivalent to incrementing the
                  pointer by "in" components or indices, where n is the number
                  of components or indices in each pixel.

        #GL_PACK_SKIP_ROWS
                  This value is provided as a convenience to the programmer; it
                  provides no functionality that cannot be duplicated simply by
                  incrementing the pointer passed to @{"gl.ReadPixels()" LINK glReadPixels}. Setting
                  #GL_PACK_SKIP_ROWS to j is equivalent to incrementing the
                  pointer by "jm" components or indices, where m is the number
                  of components or indices per row, as just computed in the
                  #GL_PACK_ROW_LENGTH section.

        #GL_PACK_ALIGNMENT
                  Specifies the alignment requirements for the start of each
                  pixel row in memory. The allowable values are 1
                  (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
                  (word-alignment), and 8 (rows start on double-word
                  boundaries).

        The other six of the twelve storage parameters affect how pixel data is
        read from client memory. These values are then significant for
        @{"gl.DrawPixels()" LINK glDrawPixels}, @{"gl.TexImage()" LINK glTexImage}, and furthermore also for
        @{"gl.TexImage1D()" LINK glTexImage1D}, @{"gl.TexImage2D()" LINK glTexImage2D}, @{"gl.TexSubImage()" LINK glTexSubImage},
        @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, @{"gl.TexSubImage2D()" LINK glTexSubImage2D}, @{"gl.Bitmap()" LINK glBitmap}, and
        @{"gl.PolygonStipple()" LINK glPolygonStipple}. They are as follows:

        #GL_UNPACK_SWAP_BYTES
                  If true, byte ordering for multibyte color components, depth
                  components, color indices, or stencil indices is reversed.
                  That is, if a four-byte component consists of bytes b0, b1,
                  b2, b3, it is taken from memory as b3, b2, b1, b0 if
                  #GL_UNPACK_SWAP_BYTES is true. #GL_UNPACK_SWAP_BYTES has no
                  effect on the memory order of components within a pixel, only
                  on the order of bytes within components or indices. For
                  example, the three components of a #GL_RGB format pixel are
                  always stored with red first, green second, and blue third,
                  regardless of the value of #GL_UNPACK_SWAP_BYTES.

        #GL_UNPACK_LSB_FIRST
                  If true, bits are ordered within a byte from least significant
                  to most significant; otherwise, the first bit in each byte is
                  the most significant one. This is relevant only for bitmap
                  data.

        #GL_UNPACK_ROW_LENGTH
                  If greater than 0, #GL_UNPACK_ROW_LENGTH defines the number of
                  pixels in a row. If the first pixel of a row is placed at
                  location p in memory, then the location of the first pixel of
                  the next row is obtained by skipping a certain number of
                  components or indices. See an OpenGL reference manual for
                  details.

        #GL_UNPACK_SKIP_PIXELS
                  This value is provided as a convenience to the programmer; it
                  provides no functionality that cannot be duplicated by
                  incrementing the pointer passed to @{"gl.DrawPixels()" LINK glDrawPixels}, or to
                  @{"gl.TexImage()" LINK glTexImage}, or also to @{"gl.TexImage1D()" LINK glTexImage1D} and @{"gl.TexImage2D()" LINK glTexImage2D},
                  additionally also to @{"gl.TexSubImage()" LINK glTexSubImage}, or to
                  @{"gl.TexSubImage1D()" LINK glTexSubImage1D} and @{"gl.TexSubImage2D()" LINK glTexSubImage2D}, @{"gl.Bitmap()" LINK glBitmap}, or
                  to @{"gl.PolygonStipple()" LINK glPolygonStipple} Setting #GL_UNPACK_SKIP_PIXELS to i is
                  equivalent to incrementing the pointer by "in" components or
                  indices, where n is the number of components or indices in
                  each pixel.

        #GL_UNPACK_SKIP_ROWS
                  This value is provided as a convenience to the programmer; it
                  provides no functionality that cannot be duplicated by
                  incrementing the pointer passed to @{"gl.DrawPixels()" LINK glDrawPixels}, or to
                  @{"gl.TexImage()" LINK glTexImage}, or also to @{"gl.TexImage1D()" LINK glTexImage1D} and @{"gl.TexImage2D()" LINK glTexImage2D},
                  additionally also to @{"gl.TexSubImage()" LINK glTexSubImage}, or to
                  @{"gl.TexSubImage1D()" LINK glTexSubImage1D} and @{"gl.TexSubImage2D()" LINK glTexSubImage2D}, @{"gl.Bitmap()" LINK glBitmap}, or
                  to @{"gl.PolygonStipple()" LINK glPolygonStipple} Setting #GL_UNPACK_SKIP_ROWS to j is
                  equivalent to incrementing the pointer by "jk" components or
                  indices, where k is the number of components or indices per
                  row, as just computed in the #GL_UNPACK_ROW_LENGTH section.

        #GL_UNPACK_ALIGNMENT
                  Specifies the alignment requirements for the start of each
                  pixel row in memory. The allowable values are 1
                  (byte-alignment), 2 (rows aligned to even-numbered bytes), 4
                  (word-alignment), and 8 (rows start on double-word
                  boundaries).

        The following table gives the type, initial value, and range of valid
        values for each storage parameter that can be set with gl.PixelStore().

            pname                 |  Type   | Default | Valid Range
            -------------------------------------------------------
            #GL_PACK_SWAP_BYTES   | boolean | false   | true or false
            #GL_PACK_LSB_FIRST    | boolean | false   | true or false
            #GL_PACK_ROW_LENGTH   | integer | 0       | [0,oo)
            #GL_PACK_SKIP_ROWS    | integer | 0       | [0,oo)
            #GL_PACK_SKIP_PIXELS  | integer | 0       | [0,oo)
            #GL_PACK_ALIGNMENT    | integer | 4       | 1, 2, 4, or 8
            #GL_UNPACK_SWAP_BYTES | boolean | false   | true or false
            #GL_UNPACK_LSB_FIRST  | boolean | false   | true or false
            #GL_UNPACK_ROW_LENGTH | integer | 0       | [0,oo)
            #GL_UNPACK_SKIP_ROWS  | integer | 0       | [0,oo)
            #GL_UNPACK_SKIP_PIXELS| integer | 0       | [0,oo)
            #GL_UNPACK_ALIGNMENT  | integer | 4       | 1, 2, 4, or 8

        The pixel storage modes in effect when @{"gl.DrawPixels()" LINK glDrawPixels}, @{"gl.ReadPixels()" LINK glReadPixels},
        or @{"gl.TexImage()" LINK glTexImage}, @{"gl.TexImage1D()" LINK glTexImage1D}, or @{"gl.TexImage2D()" LINK glTexImage2D}, or
        @{"gl.TexSubImage()" LINK glTexSubImage}, @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, or also GL's @{"gl.TexSubImage2D()" LINK glTexSubImage2D},
        or @{"gl.Bitmap()" LINK glBitmap}, or @{"gl.PolygonStipple()" LINK glPolygonStipple} is placed in a display list
        control the interpretation of memory data. The pixel storage modes in
        effect when a display list is executed are not significant.

        Pixel storage modes are client state and must be pushed and restored
        using @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the symbolic name of the parameter to be set (see
                  above for possible modes)
        param     specifies the value that "pname" is set to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_VALUE is generated if a negative row length, pixel skip, or
        row skip value is specified, or if alignment is specified as other than
        1, 2, 4, or 8.

        #GL_INVALID_OPERATION is generated if gl.PixelStore() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_PACK_SWAP_BYTES

        @{"gl.Get()" LINK glGet} with argument #GL_PACK_LSB_FIRST

        @{"gl.Get()" LINK glGet} with argument #GL_PACK_ROW_LENGTH

        @{"gl.Get()" LINK glGet} with argument #GL_PACK_SKIP_ROWS

        @{"gl.Get()" LINK glGet} with argument #GL_PACK_SKIP_PIXELS

        @{"gl.Get()" LINK glGet} with argument #GL_PACK_ALIGNMENT

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_SWAP_BYTES

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_LSB_FIRST

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_ROW_LENGTH

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_SKIP_ROWS

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_SKIP_PIXELS

        @{"gl.Get()" LINK glGet} with argument #GL_UNPACK_ALIGNMENT

@ENDNODE

@NODE glPixelTransfer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PixelTransfer -- set pixel transfer modes

   @{b}SYNOPSIS@{ub}
        gl.PixelTransfer(pname, param)

   @{b}FUNCTION@{ub}
        gl.PixelTransfer() sets pixel transfer modes that affect the operation
        of subsequent @{"gl.CopyPixels()" LINK glCopyPixels}, @{"gl.CopyTexImage()" LINK glCopyTexImage}, @{"gl.CopyTexSubImage()" LINK glCopyTexSubImage},
        @{"gl.DrawPixels()" LINK glDrawPixels}, @{"gl.ReadPixels()" LINK glReadPixels}, or also GL's @{"gl.TexImage()" LINK glTexImage},
        @{"gl.TexImage1D()" LINK glTexImage1D}, @{"gl.TexImage2D()" LINK glTexImage2D}, @{"gl.TexSubImage()" LINK glTexSubImage},
        @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, and @{"gl.TexSubImage2D()" LINK glTexSubImage2D} commands. The algorithms
        that are specified by pixel transfer modes operate on pixels after they
        are read from the frame buffer @{"gl.CopyPixels()" LINK glCopyPixels} (, @{"gl.CopyTexImage()" LINK glCopyTexImage},
        @{"gl.CopyTexSubImage()" LINK glCopyTexSubImage}, @{"gl.ReadPixels()" LINK glReadPixels}) or in case they are unpacked
        from client memory @{"gl.DrawPixels()" LINK glDrawPixels} (, @{"gl.TexImage()" LINK glTexImage}, @{"gl.TexImage1D()" LINK glTexImage1D},
        @{"gl.TexImage2D()" LINK glTexImage2D}, @{"gl.TexSubImage()" LINK glTexSubImage}, @{"gl.TexSubImage1D()" LINK glTexSubImage1D}, and
        @{"gl.TexSubImage2D()" LINK glTexSubImage2D}). Pixel transfer operations happen in the same
        order, and in the same manner, regardless of the command that resulted
        in the pixel operation. Pixel storage modes See @{"gl.PixelStore" LINK glPixelStore} for
        details. () control the unpacking of pixels being read from client
        memory, and the packing of pixels being written back into client memory.

        Pixel transfer operations handle four fundamental pixel types: color,
        color index, depth, and stencil. Color pixels consist of four
        floating-point values with unspecified mantissa and exponent sizes,
        scaled such that 0 represents zero intensity and 1 represents full
        intensity. Color indices comprise a single fixed-point value, with
        unspecified precision to the right of the binary point. Depth pixels
        comprise a single floating-point value, with unspecified mantissa and
        exponent sizes, scaled such that 0.0 represents the minimum depth buffer
        value, and 1.0 represents the maximum depth buffer value. Finally,
        stencil pixels comprise a single fixed-point value, with unspecified
        precision to the right of the binary point.

        The pixel transfer operations performed on the four basic pixel types
        are as follows:

        Color     Each of the four color components is multiplied by a scale
                  factor, then added to a bias factor. That is, the red
                  component is multiplied by #GL_RED_SCALE, then added to
                  #GL_RED_BIAS; the green component is multiplied by
                  #GL_GREEN_SCALE, then added to #GL_GREEN_BIAS; the blue
                  component is multiplied by #GL_BLUE_SCALE, then added to
                  #GL_BLUE_BIAS; and the alpha component is multiplied by
                  #GL_ALPHA_SCALE, then added to #GL_ALPHA_BIAS. After all four
                  color components are scaled and biased, each is clamped to the
                  range [0, 1]. All color, scale, and bias values are specified
                  with gl.PixelTransfer(). If #GL_MAP_COLOR is true, each color
                  component is scaled by the size of the corresponding
                  color-to-color map, then replaced by the contents of that map
                  indexed by the scaled component. That is, the red component is
                  scaled by #GL_PIXEL_MAP_R_TO_R_SIZE, then replaced by the
                  contents of #GL_PIXEL_MAP_R_TO_R indexed by itself. The green
                  component is scaled by #GL_PIXEL_MAP_G_TO_G_SIZE, then
                  replaced by the contents of #GL_PIXEL_MAP_G_TO_G indexed by
                  itself. The blue component is scaled by
                  #GL_PIXEL_MAP_B_TO_B_SIZE, then replaced by the contents of
                  #GL_PIXEL_MAP_B_TO_B indexed by itself. And the alpha
                  component is scaled by #GL_PIXEL_MAP_A_TO_A_SIZE, then
                  replaced by the contents of #GL_PIXEL_MAP_A_TO_A indexed by
                  itself. All components taken from the maps are then clamped to
                  the range [0, 1]. #GL_MAP_COLOR is specified with
                  gl.PixelTransfer(). The contents of the various maps are
                  specified with @{"gl.PixelMap()" LINK glPixelMap}.

        Color index
                  Each color index is shifted left by #GL_INDEX_SHIFT bits; any
                  bits beyond the number of fraction bits carried by the
                  fixed-point index are filled with zeros. If #GL_INDEX_SHIFT is
                  negative, the shift is to the right, again zero filled. Then
                  #GL_INDEX_OFFSET is added to the index. #GL_INDEX_SHIFT and
                  #GL_INDEX_OFFSET are specified with gl.PixelTransfer().

                  From this point, operation diverges depending on the required
                  format of the resulting pixels. If the resulting pixels are to
                  be written to a color index buffer, or if they are being read
                  back to client memory in #GL_COLOR_INDEX format, the pixels
                  continue to be treated as indices. If #GL_MAP_COLOR is true,
                  each index is masked by 2^n - 1, where n is
                  #GL_PIXEL_MAP_I_TO_I_SIZE, then replaced by the contents of
                  #GL_PIXEL_MAP_I_TO_I indexed by the masked value.
                  #GL_MAP_COLOR is specified with gl.PixelTransfer(). The
                  contents of the index map is specified with glPixelMap.

                  If the resulting pixels are to be written to an RGBA color
                  buffer, or if they are read back to client memory in a format
                  other than #GL_COLOR_INDEX, the pixels are converted from
                  indices to colors by referencing the four maps
                  #GL_PIXEL_MAP_I_TO_R, #GL_PIXEL_MAP_I_TO_G,
                  #GL_PIXEL_MAP_I_TO_B, and #GL_PIXEL_MAP_I_TO_A. Before being
                  dereferenced, the index is masked by 2^n - 1, where n is
                  #GL_PIXEL_MAP_I_TO_R_SIZE for the red map,
                  #GL_PIXEL_MAP_I_TO_G_SIZE for the green map,
                  #GL_PIXEL_MAP_I_TO_B_SIZE for the blue map, and
                  #GL_PIXEL_MAP_I_TO_A_SIZE for the alpha map. All components
                  taken from the maps are then clamped to the range [0, 1]. The
                  contents of the four maps is specified with @{"gl.PixelMap()" LINK glPixelMap}.

        Depth     Each depth value is multiplied by #GL_DEPTH_SCALE, added to
                  #GL_DEPTH_BIAS, then clamped to the range [0, 1].

        Stencil   Each index is shifted #GL_INDEX_SHIFT bits just as a color
                  index is, then added to #GL_INDEX_OFFSET. If #GL_MAP_STENCIL
                  is true, each index is masked by 2^n - 1, where n is
                  #GL_PIXEL_MAP_S_TO_S_SIZE, then replaced by the contents of
                  #GL_PIXEL_MAP_S_TO_S indexed by the masked value.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the symbolic name of the pixel transfer parameter to
                  be set (see above)
        param     specifies the value that "pname" is set to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "pname" is not an accepted value.

        #GL_INVALID_OPERATION is generated if gl.PixelTransfer() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MAP_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_MAP_STENCIL

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_SHIFT

        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_OFFSET

        @{"gl.Get()" LINK glGet} with argument #GL_RED_SCALE

        @{"gl.Get()" LINK glGet} with argument #GL_RED_BIAS

        @{"gl.Get()" LINK glGet} with argument #GL_GREEN_SCALE

        @{"gl.Get()" LINK glGet} with argument #GL_GREEN_BIAS

        @{"gl.Get()" LINK glGet} with argument #GL_BLUE_SCALE

        @{"gl.Get()" LINK glGet} with argument #GL_BLUE_BIAS

        @{"gl.Get()" LINK glGet} with argument #GL_ALPHA_SCALE

        @{"gl.Get()" LINK glGet} with argument #GL_ALPHA_BIAS

        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_SCALE

        @{"gl.Get()" LINK glGet} with argument #GL_DEPTH_BIAS

@ENDNODE

@NODE glPixelZoom "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PixelZoom -- specify the pixel zoom factors

   @{b}SYNOPSIS@{ub}
        gl.PixelZoom(xfactor, yfactor)

   @{b}FUNCTION@{ub}
        gl.PixelZoom() specifies values for the x and y zoom factors. During the
        execution of @{"gl.DrawPixels()" LINK glDrawPixels} or @{"gl.CopyPixels()" LINK glCopyPixels}, if (xr,yr) is the
        current raster position, and a given element is in the mth row and nth
        column of the pixel rectangle, then pixels whose centers are in the
        rectangle with corners at

            (xr+n*xfactor, yr+m*yfactor)
            (xr+(n+1)*xfactor,yr+(m+1)*yfactor)

        are candidates for replacement. Any pixel whose center lies on the
        bottom or left edge of this rectangular region is also modified.

        Pixel zoom factors are not limited to positive values. Negative zoom
        factors reflect the resulting image about the current raster position.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        xfactor   specify the x zoom factor for pixel write operations
        yfactor   specify the y zoom factor for pixel write operations

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if glPixelZoom is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ZOOM_X

        @{"gl.Get()" LINK glGet} with argument #GL_ZOOM_Y

@ENDNODE

@NODE glPointSize "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PointSize -- specify the diameter of rasterized points

   @{b}SYNOPSIS@{ub}
        gl.PointSize(size)

   @{b}FUNCTION@{ub}
        gl.PointSize() specifies the rasterized diameter of both aliased and
        antialiased points. Using a point size other than 1 has different
        effects, depending on whether point antialiasing is enabled. To enable
        and disable point antialiasing, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable} with
        argument #GL_POINT_SMOOTH. Point antialiasing is initially disabled.

        If point antialiasing is disabled, the actual size is determined by
        rounding the supplied size to the nearest integer. (If the rounding
        results in the value 0, it is as if the point size were 1.) If the
        rounded size is odd, then the center point (x,y) of the pixel fragment
        that represents the point is computed as

            (xw + 0.5, yw + 0.5)

        where w subscripts indicate window coordinates. All pixels that lie
        within the square grid of the rounded size centered at (x,y) make up the
        fragment. If the size is even, the center point is

            (xw + 0.5, yw + 0.5)

        and the rasterized fragment's centers are the half-integer window
        coordinates within the square of the rounded size centered at (x,y). All
        pixel fragments produced in rasterizing a non-antialiased point are
        assigned the same associated data, that of the vertex corresponding to
        the point.

        If antialiasing is enabled, then point rasterization produces a fragment
        for each pixel square that intersects the region lying within the circle
        having diameter equal to the current point size and centered at the
        point's (xw,yw). The coverage value for each fragment is the window
        coordinate area of the intersection of the circular region with the
        corresponding pixel square. This value is saved and used in the final
        rasterization step. The data associated with each fragment is the data
        associated with the point being rasterized.

        Not all sizes are supported when point antialiasing is enabled. If an
        unsupported size is requested, the nearest supported size is used. Only
        size 1 is guaranteed to be supported; others depend on the
        implementation. To query the range of supported sizes and the size
        difference between supported sizes within the range, call @{"gl.Get()" LINK glGet} with
        arguments #GL_POINT_SIZE_RANGE and #GL_POINT_SIZE_GRANULARITY.

        The point size specified by gl.PointSize() is always returned when
        #GL_POINT_SIZE is queried. Clamping and rounding for aliased and
        antialiased points have no effect on the specified value.

        A non-antialiased point size may be clamped to an
        implementation-dependent maximum. Although this maximum cannot be
        queried, it must be no less than the maximum value for antialiased
        points, rounded to the nearest integer value.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        size      specifies the diameter of rasterized points; the initial value
                  is 1

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if size is less than or equal to 0.

        #GL_INVALID_OPERATION is generated if gl.PointSize() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_POINT_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_POINT_SIZE_RANGE

        @{"gl.Get()" LINK glGet} with argument #GL_POINT_SIZE_GRANULARITY

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_POINT_SMOOTH

@ENDNODE

@NODE glPolygonMode "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PolygonMode -- select a polygon rasterization mode

   @{b}SYNOPSIS@{ub}
        gl.PolygonMode(face, mode)

   @{b}FUNCTION@{ub}
        gl.PolygonMode() controls the interpretation of polygons for
        rasterization. "face" describes which polygons mode applies to:
        front-facing polygons (#GL_FRONT), back-facing polygons (#GL_BACK), or
        both (#GL_FRONT_AND_BACK). The polygon mode affects only the final
        rasterization of polygons. In particular, a polygon's vertices are lit
        and the polygon is clipped and possibly culled before these modes are
        applied.

        Three modes are defined and can be specified in "mode":

        #GL_POINT Polygon vertices that are marked as the start of a boundary
                  edge are drawn as points. Point attributes such as
                  #GL_POINT_SIZE and #GL_POINT_SMOOTH control the rasterization
                  of the points. Polygon rasterization attributes other than
                  #GL_POLYGON_MODE have no effect.

        #GL_LINE  Boundary edges of the polygon are drawn as line segments. They
                  are treated as connected line segments for line stippling; the
                  line stipple counter and pattern are not reset between
                  segments (see glLineStipple). Line attributes such as
                  #GL_LINE_WIDTH and #GL_LINE_SMOOTH control the rasterization
                  of the lines. Polygon rasterization attributes other than
                  #GL_POLYGON_MODE have no effect.

        #GL_FILL  The interior of the polygon is filled. Polygon attributes such
                  as #GL_POLYGON_STIPPLE and #GL_POLYGON_SMOOTH control the
                  rasterization of the polygon.

        The initial value is #GL_FILL for both front- and back-facing polygons.

        Vertices are marked as boundary or nonboundary with an edge flag. Edge
        flags are generated internally by the GL when it decomposes polygons;
        they can be set explicitly using @{"gl.EdgeFlag()" LINK glEdgeFlag}.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        face      specifies the polygons that mode applies to (see above)
        mode      specifies how polygons will be rasterized (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if either "face" or "mode" is not an
        accepted value.

        #GL_INVALID_OPERATION is generated if gl.PolygonMode() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_POLYGON_MODE

@ENDNODE

@NODE glPolygonOffset "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PolygonOffset -- set the scale and units used to calculate depth values

   @{b}SYNOPSIS@{ub}
        gl.PolygonOffset(factor, units)

   @{b}FUNCTION@{ub}
        When #GL_POLYGON_OFFSET_FILL, #GL_POLYGON_OFFSET_LINE, or
        #GL_POLYGON_OFFSET_POINT is enabled, each fragment's depth value will be
        offset after it is interpolated from the depth values of the appropriate
        vertices. The value of the offset is factor * delta(Z) + r * units,
        where delta(Z) is a measurement of the change in depth relative to the
        screen area of the polygon, and r is the smallest value that is
        guaranteed to produce a resolvable offset for a given implementation.
        The offset is added before the depth test is performed and before the
        value is written into the depth buffer.

        gl.PolygonOffset() is useful for rendering hidden-line images, for
        applying decals to surfaces, and for rendering solids with highlighted
        edges.

        gl.PolygonOffset() has no effect on depth coordinates placed in the
        feedback buffer.

        gl.PolygonOffset() has no effect on selection.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        factor    specifies a scale factor that is used to create a variable
                  depth offset for each polygon; the initial value is 0
        units     is multiplied by an implementation-specific value to create a
                  constant depth offset; the initial value is 0

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.PolygonOffset() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_POLYGON_OFFSET_FILL,
        #GL_POLYGON_OFFSET_LINE, or #GL_POLYGON_OFFSET_POINT.

        @{"gl.Get()" LINK glGet} with argument #GL_POLYGON_OFFSET_FACTOR or
        #GL_POLYGON_OFFSET_UNITS.

@ENDNODE

@NODE glPolygonStipple "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PolygonStipple -- set the polygon stippling pattern

   @{b}SYNOPSIS@{ub}
        gl.PolygonStipple(maskArray)

   @{b}FUNCTION@{ub}
        Polygon stippling, like line stippling See @{"gl.LineStipple" LINK glLineStipple} for details.
        (), masks out certain fragments produced by rasterization, creating a
        pattern. Stippling is independent of polygon antialiasing.

        "maskArray" is a table containing a 32*32 stipple pattern stored as a
        monochrome bitmap that uses only 1 bit per pixel. The bitmap is passed
        in a table that consists of chunks of 8 pixels packed into one byte.
        Thus, for a 32*32 stipple pattern you'll have to pass a table that
        contains 128 byte elements containing 8 pixels each. This can be either
        a one-dimensional table containing 128 byte entries or a two-dimensional
        table containing 32 subtables of 4 byte entries each (those 4 byte
        entries describe a row of 32 pixels each.) The data is passed to the GL
        in a contiguous memory block without any padding or special alignments
        so make sure that no exotic settings with @{"gl.PixelStore()" LINK glPixelStore} are active
        because gl.PolygonStipple() expects the pattern data to be stored in
        memory just like the pixel data supplied to a @{"gl.DrawPixels()" LINK glDrawPixels} call with
        height and width both equal to 32, a pixel format of #GL_COLOR_INDEX,
        and data type of #GL_BITMAP. That is, the stipple pattern is represented
        as a 32x32 array of 1-bit color indices packed in unsigned bytes.
        @{"gl.PixelStore()" LINK glPixelStore} parameters like #GL_UNPACK_SWAP_BYTES and
        #GL_UNPACK_LSB_FIRST affect the assembling of the bits into a stipple
        pattern. Pixel transfer operations (shift, offset, pixel map) are not
        applied to the stipple image, however.

        To enable and disable polygon stippling, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_POLYGON_STIPPLE. Polygon stippling is
        initially disabled. If it's enabled, a rasterized polygon fragment with
        window coordinates xw and yw is sent to the next stage of the GL if and
        only if the (xw%32)th bit in the (yw%32)th row of the stipple pattern is
        1 (one). When polygon stippling is disabled, it is as if the stipple
        pattern consists of all 1's.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        maskArray specifies a table that contains a 32x32 stipple pattern

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.PolygonStipple() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetPolygonStipple()" LINK glGetPolygonStipple}

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_POLYGON_STIPPLE

@ENDNODE

@NODE glPopAttrib "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PopAttrib -- pop the server attribute stack

   @{b}SYNOPSIS@{ub}
        gl.PopAttrib()

   @{b}FUNCTION@{ub}
        gl.PopAttrib() restores the values of the state variables saved with the
        last @{"gl.PushAttrib()" LINK glPushAttrib} command. Those not saved are left unchanged.

        See @{"gl.PushAttrib" LINK glPushAttrib} for a list of supported state variables.

        It is an error to pop attributes off an empty stack. In that case, the
        error flag is set and no other change is made to GL state.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_STACK_UNDERFLOW is generated if gl.PopAttrib() is called while the
        attribute stack is empty.

        #GL_INVALID_OPERATION is generated if gl.PopAttrib() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ATTRIB_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_ATTRIB_STACK_DEPTH

@ENDNODE

@NODE glPopClientAttrib "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PopClientAttrib -- pop the client attribute stack

   @{b}SYNOPSIS@{ub}
        gl.PopClientAttrib()

   @{b}FUNCTION@{ub}
        gl.PopClientAttrib() restores the values of the client-state variables
        saved with the last @{"gl.PushClientAttrib()" LINK glPushClientAttrib}. Those not saved are left
        unchanged.

        See @{"gl.PushClientAttrib" LINK glPushClientAttrib} for a list of supported client state variables.

        It is an error to pop attributes off an empty stack. In that case, the
        error flag is set, and no other change is made to GL state.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_STACK_UNDERFLOW is generated if gl.PopClientAttrib() is called while
        the attribute stack is empty.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ATTRIB_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_CLIENT_ATTRIB_STACK_DEPTH

@ENDNODE

@NODE glPopMatrix "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PopMatrix -- pop the current matrix stack

   @{b}SYNOPSIS@{ub}
        gl.PopMatrix()

   @{b}FUNCTION@{ub}
        gl.PopMatrix() pops the current matrix stack, replacing the current
        matrix with the one below it on the stack.

        Initially, each of the stacks contains one matrix, an identity matrix.

        It is an error to pop a matrix stack that contains only a single matrix.
        In that case, the error flag is set and no other change is made to GL
        state.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_STACK_UNDERFLOW is generated if gl.PopMatrix() is called while the
        current matrix stack contains only a single matrix.

        #GL_INVALID_OPERATION is generated if gl.PopMatrix() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_MODELVIEW_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_PROJECTION_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_TEXTURE_STACK_DEPTH

@ENDNODE

@NODE glPopName "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PopName -- pop the name stack

   @{b}SYNOPSIS@{ub}
        gl.PopName()

   @{b}FUNCTION@{ub}
        The name stack is used during selection mode to allow sets of rendering
        commands to be uniquely identified. It consists of an ordered set of
        unsigned integers and is initially empty.

        gl.PopName() pops one name off the top of the stack.

        The maximum name stack depth is implementation-dependent; call
        #GL_MAX_NAME_STACK_DEPTH to find out the value for a particular
        implementation. It is an error to pop a name off an empty stack. It is
        also an error to manipulate the name stack between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}. In any of these
        cases, the error flag is set and no other change is made to GL state.

        The name stack is always empty while the render mode is not #GL_SELECT.
        Calls to gl.PopName() while the render mode is not #GL_SELECT are
        ignored.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_STACK_UNDERFLOW is generated if gl.PopName() is called while the
        name stack is empty.

        #GL_INVALID_OPERATION is generated if gl.PopName() is executed between a
        call to glBegin and the corresponding call to glEnd.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_NAME_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_NAME_STACK_DEPTH

@ENDNODE

@NODE glPrioritizeTextures "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PrioritizeTextures -- set texture residence priority

   @{b}SYNOPSIS@{ub}
        gl.PrioritizeTextures(texturesArray, prioritiesArray)

   @{b}FUNCTION@{ub}
        gl.PrioritizeTextures() assigns the texture priorities given in
        "prioritiesArray" to the textures named in "texturesArray".

        The GL establishes a "working set" of textures that are resident in
        texture memory. These textures may be bound to a texture target much
        more efficiently than textures that are not resident. By specifying a
        priority for each texture, gl.PrioritizeTextures() allows applications
        to guide the GL implementation in determining which textures should be
        resident.

        The priorities given in "prioritiesArray" are clamped to the range (0,1)
        before they are assigned. 0 indicates the lowest priority; textures with
        priority 0 are least likely to be resident. 1 indicates the highest
        priority; textures with priority 1 are most likely to be resident.
        However, textures are not guaranteed to be resident until they are used.

        gl.PrioritizeTextures() silently ignores attempts to prioritize texture
        0 or any texture name that does not correspond to an existing texture.

        gl.PrioritizeTextures() does not require that any of the textures named
        by textures be bound to a texture target. @{"gl.TexParameter()" LINK glTexParameter} may also be
        used to set a texture's priority, but only if the texture is currently
        bound. This is the only way to set the priority of a default texture.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        texturesArray
                  specifies an array containing the names of the textures to be
                  prioritized
        prioritiesArray
                  specifies an array containing the texture priorities; a
                  priority given in an element of priorities applies to the
                  texture named by the corresponding element of textures

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.PrioritizeTextures() is
        executed between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding
        execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.GetTexParameter()" LINK glGetTexParameter} with parameter name #GL_TEXTURE_PRIORITY retrieves
        the priority of a currently bound texture

@ENDNODE

@NODE glPushAttrib "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PushAttrib -- push the server attribute stack

   @{b}SYNOPSIS@{ub}
        gl.PushAttrib(mask)

   @{b}FUNCTION@{ub}
        gl.PushAttrib() takes one argument, a mask that indicates which groups
        of state variables to save on the attribute stack. Symbolic constants
        are used to set bits in the mask. mask is typically constructed by ORing
        several of these constants together. The special mask
        #GL_ALL_ATTRIB_BITS can be used to save all stackable states.

        The symbolic mask constants and their associated GL state are as
        follows:

        #GL_ACCUM_BUFFER_BIT
                  Accumulation buffer clear value

        #GL_COLOR_BUFFER_BIT
                  #GL_ALPHA_TEST enable bit

                  Alpha test function and reference value

                  #GL_BLEND enable bit

                  Blending source and destination functions

                  Constant blend color

                  Blending equation

                  #GL_DITHER enable bit

                  #GL_DRAW_BUFFER setting

                  #GL_COLOR_LOGIC_OP enable bit

                  #GL_INDEX_LOGIC_OP enable bit

                  Logic op function

                  Color mode and index mode clear values

                  Color mode and index mode writemasks

        #GL_CURRENT_BIT
                  Current RGBA color

                  Current color index

                  Current normal vector

                  Current texture coordinates

                  Current raster position

                  #GL_CURRENT_RASTER_POSITION_VALID flag

                  RGBA color associated with current raster position

                  Color index associated with current raster position

                  Texture coordinates associated with current raster position

                  #GL_EDGE_FLAG flag

        #GL_DEPTH_BUFFER_BIT
                  #GL_DEPTH_TEST enable bit

                  Depth buffer test function

                  Depth buffer clear value

                  #GL_DEPTH_WRITEMASK enable bit

        #GL_ENABLE_BIT
                  #GL_ALPHA_TEST flag

                  #GL_AUTO_NORMAL flag

                  #GL_BLEND flag

                  Enable bits for the user-definable clipping planes

                  #GL_COLOR_MATERIAL

                  #GL_CULL_FACE flag

                  #GL_DEPTH_TEST flag

                  #GL_DITHER flag

                  #GL_FOG flag

                  #GL_LIGHTi where 0.le. i < #GL_MAX_LIGHTS

                  #GL_LIGHTING flag

                  #GL_LINE_SMOOTH flag

                  #GL_LINE_STIPPLE flag

                  #GL_COLOR_LOGIC_OP flag

                  #GL_INDEX_LOGIC_OP flag

                  #GL_MAP1_x where x is a map type

                  #GL_MAP2_x where x is a map type

                  #GL_NORMALIZE flag

                  #GL_POINT_SMOOTH flag

                  #GL_POLYGON_OFFSET_LINE flag

                  #GL_POLYGON_OFFSET_FILL flag

                  #GL_POLYGON_OFFSET_POINT flag

                  #GL_POLYGON_SMOOTH flag

                  #GL_POLYGON_STIPPLE flag

                  #GL_SCISSOR_TEST flag

                  #GL_STENCIL_TEST flag

                  #GL_TEXTURE_1D flag

                  #GL_TEXTURE_2D flag

                  Flags #GL_TEXTURE_GEN_x where x is S, T, R, or Q

        #GL_EVAL_BIT
                  #GL_MAP1_x enable bits, where x is a map type

                  #GL_MAP2_x enable bits, where x is a map type

                  1D grid endpoints and divisions

                  2D grid endpoints and divisions

                  #GL_AUTO_NORMAL enable bit

        #GL_FOG_BIT
                  #GL_FOG enable bit

                  Fog color

                  Fog density

                  Linear fog start

                  Linear fog end

                  Fog index

                  #GL_FOG_MODE value

        #GL_HINT_BIT
                  #GL_PERSPECTIVE_CORRECTION_HINT setting

                  #GL_POINT_SMOOTH_HINT setting

                  #GL_LINE_SMOOTH_HINT setting

                  #GL_POLYGON_SMOOTH_HINT setting

                  #GL_FOG_HINT setting

        #GL_LIGHTING_BIT
                  #GL_COLOR_MATERIAL enable bit

                  #GL_COLOR_MATERIAL_FACE value

                  Color material parameters that are tracking the current color

                  Ambient scene color

                  #GL_LIGHT_MODEL_LOCAL_VIEWER value

                  #GL_LIGHT_MODEL_TWO_SIDE setting

                  #GL_LIGHTING enable bit

                  Enable bit for each light

                  Ambient, diffuse, and specular intensity for each light

                  Direction, position, exponent, and cutoff angle for each light

                  Constant, linear, and quadratic attenuation factors for each
                  light

                  Ambient, diffuse, specular, and emissive color for each
                  material

                  Ambient, diffuse, and specular color indices for each material

                  Specular exponent for each material

                  #GL_SHADE_MODEL setting

        #GL_LINE_BIT
                  #GL_LINE_SMOOTH flag

                  #GL_LINE_STIPPLE enable bit

                  Line stipple pattern and repeat counter

                  Line width

        #GL_LIST_BIT
                  #GL_LIST_BASE setting
        #GL_PIXEL_MODE_BIT
                  #GL_RED_BIAS and #GL_RED_SCALE settings

                  #GL_GREEN_BIAS and #GL_GREEN_SCALE values

                  #GL_BLUE_BIAS and #GL_BLUE_SCALE

                  #GL_ALPHA_BIAS and #GL_ALPHA_SCALE

                  #GL_DEPTH_BIAS and #GL_DEPTH_SCALE

                  #GL_INDEX_OFFSET and #GL_INDEX_SHIFT values

                  #GL_MAP_COLOR and #GL_MAP_STENCIL flags

                  #GL_ZOOM_X and #GL_ZOOM_Y factors

#GL_READ_BUFFER setting
        #GL_POINT_BIT
                  #GL_POINT_SMOOTH flag Point size
        #GL_POLYGON_BIT
                  #GL_CULL_FACE enable bit

                  #GL_CULL_FACE_MODE value

                  #GL_FRONT_FACE indicator

                  #GL_POLYGON_MODE setting

                  #GL_POLYGON_SMOOTH flag

                  #GL_POLYGON_STIPPLE enable bit

                  #GL_POLYGON_OFFSET_FILL flag

                  #GL_POLYGON_OFFSET_LINE flag

                  #GL_POLYGON_OFFSET_POINT flag

                  #GL_POLYGON_OFFSET_FACTOR

                  #GL_POLYGON_OFFSET_UNITS

        #GL_POLYGON_STIPPLE_BIT
                  Polygon stipple image
        #GL_SCISSOR_BIT
                  #GL_SCISSOR_TEST flag

                  Scissor box

        #GL_STENCIL_BUFFER_BIT
                  #GL_STENCIL_TEST enable bit

                  Stencil function and reference value

                  Stencil value mask

                  Stencil fail, pass, and depth buffer pass actions

                  Stencil buffer clear value

                  Stencil buffer writemask

        #GL_TEXTURE_BIT
                  Enable bits for the four texture coordinates

                  Border color for each texture image

                  Minification function for each texture image

                  Magnification function for each texture image

                  Texture coordinates and wrap mode for each texture image

                  Color and mode for each texture environment

                  Enable bits #GL_TEXTURE_GEN_x, x is S, T, R, and Q

                  #GL_TEXTURE_GEN_MODE setting for S, T, R, and Q

                  @{"gl.TexGen()" LINK glTexGen} plane equations for S, T, R, and Q

Current texture bindings (for example, #GL_TEXTURE_2D_BINDING)
        #GL_TRANSFORM_BIT
                  Coefficients of the six clipping planes

                  Enable bits for the user-definable clipping planes

                  #GL_MATRIX_MODE value

#GL_NORMALIZE flag
        #GL_VIEWPORT_BIT
                  Depth range (near and far)

                  Viewport origin and extent

        It is an error to push attributes onto a full stack. In that case, the
        error flag is set and no other change is made to GL state.

        Initially, the attribute stack is empty.

        Not all values for GL state can be saved on the attribute stack. For
        example, render mode state, and select and feedback state cannot be
        saved. Client state must be saved with @{"gl.PushClientAttrib()" LINK glPushClientAttrib}.

        The depth of the attribute stack depends on the implementation, but it
        must be at least 16.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mask      specifies a mask that indicates which attributes to save (see
                  above)

   @{b}ERRORS@{ub}
        #GL_STACK_OVERFLOW is generated if gl.PushAttrib() is called while the
        attribute stack is full.

        #GL_INVALID_OPERATION is generated if gl.PushAttrib() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ATTRIB_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_ATTRIB_STACK_DEPTH

@ENDNODE

@NODE glPushClientAttrib "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PushClientAttrib -- push the client attribute stack

   @{b}SYNOPSIS@{ub}
        gl.PushClientAttrib(mask)

   @{b}FUNCTION@{ub}
        gl.PushClientAttrib() takes one argument, a mask that indicates which
        groups of client-state variables to save on the client attribute stack.
        Symbolic constants are used to set bits in the mask. "mask" is typically
        constructed by specifying the bitwise-or of several of these constants
        together. The special mask #GL_CLIENT_ALL_ATTRIB_BITS can be used to
        save all stackable client state.

        The symbolic mask constants and their associated GL client state are as
        follows:

        #GL_CLIENT_PIXEL_STORE_BIT
                  Pixel storage modes
        #GL_CLIENT_VERTEX_ARRAY_BIT
                  Vertex arrays (and enables)

        It is an error to push attributes onto a full client attribute stack. In
        that case, the error flag is set, and no other change is made to GL
        state.

        Initially, the client attribute stack is empty.

        Not all values for GL client state can be saved on the attribute stack.
        For example, select and feedback state cannot be saved.

        The depth of the attribute stack depends on the implementation, but it
        must be at least 16.

        Use gl.PushAttrib() to push state that is kept on the server. Only pixel
        storage modes and vertex array state may be pushed with
        gl.PushClientAttrib().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mask      specifies a mask that indicates which attributes to save (see
                  above)

   @{b}ERRORS@{ub}
        #GL_STACK_OVERFLOW is generated if gl.PushClientAttrib() is called while
        the attribute stack is full.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_ATTRIB_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_CLIENT_ATTRIB_STACK_DEPTH

@ENDNODE

@NODE glPushMatrix "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PushMatrix -- push the current matrix stack

   @{b}SYNOPSIS@{ub}
        gl.PushMatrix()

   @{b}FUNCTION@{ub}
        There is a stack of matrices for each of the matrix modes. In
        #GL_MODELVIEW mode, the stack depth is at least 32. In the other modes,
        #GL_COLOR, #GL_PROJECTION, and #GL_TEXTURE, the depth is at least 2. The
        current matrix in any mode is the matrix on the top of the stack for
        that mode.

        gl.PushMatrix() pushes the current matrix stack down by one, duplicating
        the current matrix. That is, after a gl.PushMatrix() call, the matrix on
        top of the stack is identical to the one below it.

        Initially, each of the stacks contains one matrix, an identity matrix.

        It is an error to push a full matrix stack. In that case, the error flag
        is set and no other change is made to GL state.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        none

   @{b}ERRORS@{ub}
        #GL_STACK_OVERFLOW is generated if gl.PushMatrix() is called while the
        current matrix stack is full.

        #GL_INVALID_OPERATION is generated if gl.PushMatrix() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_MODELVIEW_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_PROJECTION_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_TEXTURE_STACK_DEPTH

@ENDNODE

@NODE glPushName "GL Galore Guide"

   @{b}NAME@{ub}
        gl.PushName -- push the name stack

   @{b}SYNOPSIS@{ub}
        gl.PushName(name)

   @{b}FUNCTION@{ub}
        The name stack is used during selection mode to allow sets of rendering
        commands to be uniquely identified. It consists of an ordered set of
        unsigned integers and is initially empty.

        gl.PushName() causes name to be pushed onto the name stack.

        The maximum name stack depth is implementation-dependent; call
        #GL_MAX_NAME_STACK_DEPTH to find out the value for a particular
        implementation. It is an error to push a name onto a full stack. It is
        also an error to manipulate the name stack between the execution of
        @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}. In any of these
        cases, the error flag is set and no other change is made to GL state.

        The name stack is always empty while the render mode is not #GL_SELECT.
        Calls to gl.PushName() while the render mode is not #GL_SELECT are
        ignored.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        name      specifies a name that will be pushed onto the name stack

   @{b}ERRORS@{ub}
        #GL_STACK_OVERFLOW is generated if gl.PushName() is called while the
        name stack is full.

        #GL_INVALID_OPERATION is generated if gl.PushName() is executed between
        a call to glBegin and the corresponding call to glEnd.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_NAME_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_MAX_NAME_STACK_DEPTH

@ENDNODE

@NODE glRasterPos "GL Galore Guide"

   @{b}NAME@{ub}
        gl.RasterPos -- specify the raster position for pixel operations

   @{b}SYNOPSIS@{ub}
        gl.RasterPos(x, y[, z, w])

   @{b}FUNCTION@{ub}
        The GL maintains a 3D position in window coordinates. This position,
        called the raster position, is used to position pixel and bitmap write
        operations. It is maintained with subpixel accuracy. See @{"gl.Bitmap" LINK glBitmap} for
        details. See @{"gl.DrawPixels" LINK glDrawPixels} for details. See @{"gl.CopyPixels" LINK glCopyPixels} for details.

        The current raster position consists of three window coordinates (x, y,
        z), a clip coordinate value (w), an eye coordinate distance, a valid
        bit, and associated color data and texture coordinates. The w coordinate
        is a clip coordinate, because w is not projected to window coordinates.

        The object coordinates presented by gl.RasterPos() are treated just like
        those of a @{"gl.Vertex()" LINK glVertex} command: They are transformed by the current
        modelview and projection matrices and passed to the clipping stage. If
        the vertex is not culled, then it is projected and scaled to window
        coordinates, which become the new current raster position, and the
        #GL_CURRENT_RASTER_POSITION_VALID flag is set. If the vertex is culled,
        then the valid bit is cleared and the current raster position and
        associated color and texture coordinates are undefined.

        The current raster position also includes some associated color data and
        texture coordinates. If lighting is enabled, then
        #GL_CURRENT_RASTER_COLOR (in RGBA mode) or #GL_CURRENT_RASTER_INDEX (in
        color index mode) is set to the color produced by the lighting
        calculation (see @{"gl.Light()" LINK glLight}, @{"gl.LightModel()" LINK glLightModel}, and @{"gl.ShadeModel()" LINK glShadeModel}).
        If lighting is disabled, current color (in RGBA mode, state variable
        #GL_CURRENT_COLOR) or color index (in color index mode, state variable
        #GL_CURRENT_INDEX) is used to update the current raster color.

        Likewise, #GL_CURRENT_RASTER_TEXTURE_COORDS is updated as a function of
        #GL_CURRENT_TEXTURE_COORDS, based on the texture matrix and the texture
        generation functions See @{"gl.TexGen" LINK glTexGen} for details. (). Finally, the
        distance from the origin of the eye coordinate system to the vertex as
        transformed by only the modelview matrix replaces
        #GL_CURRENT_RASTER_DISTANCE.

        Initially, the current raster position is (0, 0, 0, 1), the current
        raster distance is 0, the valid bit is set, the associated RGBA color is
        (1, 1, 1, 1), the associated color index is 1, and the associated
        texture coordinates are (0, 0, 0, 1). In RGBA mode,
        #GL_CURRENT_RASTER_INDEX is always 1; in color index mode, the current
        raster RGBA color always maintains its initial value.

        The raster position is modified by gl.RasterPos() and @{"gl.Bitmap()" LINK glBitmap}.

        When the raster position coordinates are invalid, drawing commands that
        are based on the raster position are ignored (that is, they do not
        result in changes to GL state).

        Calling @{"gl.DrawElements()" LINK glDrawElements} may leave the current color or index
        indeterminate. If gl.RasterPos() is executed while the current color or
        index is indeterminate, the current raster color or current raster index
        remains indeterminate.

        Alternatively, gl.RasterPos() can also be called with a single table
        argument containing two to four coordinates to set as the new raster
        position.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify the x object coordinates for the raster position
        y         specify the y object coordinates for the raster position
        z         optional: specify the z object coordinates for the raster
                  position (defaults to 0)
        w         optional: specify the w object coordinates for the raster
                  position (defaults to 1)

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.RasterPos() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_POSITION_VALID

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_DISTANCE

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_COLOR

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_INDEX

        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_RASTER_TEXTURE_COORDS

@ENDNODE

@NODE glReadBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ReadBuffer -- select a color buffer source for pixels

   @{b}SYNOPSIS@{ub}
        gl.ReadBuffer(mode)

   @{b}FUNCTION@{ub}
        gl.ReadBuffer() specifies a color buffer as the source for subsequent
        @{"gl.ReadPixels()" LINK glReadPixels}, @{"gl.CopyTexImage()" LINK glCopyTexImage}, @{"gl.CopyTexSubImage()" LINK glCopyTexSubImage}, and
        @{"gl.CopyPixels()" LINK glCopyPixels} commands. "mode" accepts one of twelve or more
        predefined values. #GL_AUX0 through #GL_AUX3 are always defined. In a
        fully configured system, #GL_FRONT, #GL_LEFT, and #GL_FRONT_LEFT all
        name the front left buffer, #GL_FRONT_RIGHT and #GL_RIGHT name the front
        right buffer, and #GL_BACK_LEFT and #GL_BACK name the back left buffer.

        Non-stereo double-buffered configurations have only a front left and a
        back left buffer. Single-buffered configurations have a front left and a
        front right buffer if stereo, and only a front left buffer if nonstereo.
        It is an error to specify a non-existent buffer to gl.ReadBuffer().

        "mode" is initially #GL_FRONT in single-buffered configurations and
        #GL_BACK in double-buffered configurations.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies a color buffer (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not one of the twelve (or
        more) accepted values.

        #GL_INVALID_OPERATION is generated if "mode" specifies a buffer that
        does not exist.

        #GL_INVALID_OPERATION is generated if gl.ReadBuffer() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_READ_BUFFER

@ENDNODE

@NODE glReadPixels "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ReadPixels -- read a block of pixels from the frame buffer

   @{b}SYNOPSIS@{ub}
        pixelsArray = gl.ReadPixels(x, y, width, height, format)

   @{b}FUNCTION@{ub}
        gl.ReadPixels() returns pixel data from the frame buffer, starting with
        the pixel whose lower left corner is at location (x, y), in a table.
        Several parameters control the processing of the pixel data before it is
        placed into the table. These parameters are set with three commands:
        @{"gl.PixelStore()" LINK glPixelStore}, @{"gl.PixelTransfer()" LINK glPixelTransfer}, and @{"gl.PixelMap()" LINK glPixelMap}. This
        reference page describes the effects on gl.ReadPixels() of most, but not
        all of the parameters specified by these three commands.

        gl.ReadPixels() returns values from each pixel with lower left corner at
        (x + i, y + j) for 0 <= i < width and 0 <= j < height. This pixel is
        said to be the ith pixel in the jth row. Pixels are returned in row
        order from the lowest to the highest row, left to right in each row.

        gl.ReadPixels() always uses type #GL_FLOAT to read the pixels from the
        frame buffer. For fine-tuned control over the data type of the pixel
        data, you can use @{"gl.ReadPixelsRaw()" LINK glReadPixelsRaw} instead. See @{"gl.ReadPixelsRaw" LINK glReadPixelsRaw} for
        details.

        "format" specifies the format for the returned pixel values; accepted
        values are:

        #GL_COLOR_INDEX
                  Color indices are read from the color buffer selected by
                  gl.ReadBuffer(). Each index is converted to fixed point,
                  shifted left or right depending on the value and sign of
                  #GL_INDEX_SHIFT, and added to #GL_INDEX_OFFSET. If
                  #GL_MAP_COLOR is #GL_TRUE, indices are replaced by their
                  mappings in the table #GL_PIXEL_MAP_I_TO_I.

        #GL_STENCIL_INDEX
                  Stencil values are read from the stencil buffer. Each index is
                  converted to fixed point, shifted left or right depending on
                  the value and sign of #GL_INDEX_SHIFT, and added to
                  #GL_INDEX_OFFSET. If #GL_MAP_STENCIL is #GL_TRUE, indices are
                  replaced by their mappings in the table #GL_PIXEL_MAP_S_TO_S.

        #GL_DEPTH_COMPONENT
                  Depth values are read from the depth buffer. Each component is
                  converted to floating point such that the minimum depth value
                  maps to 0 and the maximum value maps to 1. Each component is
                  then multiplied by #GL_DEPTH_SCALE, added to #GL_DEPTH_BIAS,
                  and finally clamped to the range (0,1).

        #GL_RED   Processing differs depending on whether color buffers store
                  color indices or RGBA color components. If color indices are
                  stored, they are read from the color buffer selected by
                  gl.ReadBuffer(). Each index is converted to fixed point,
                  shifted left or right depending on the value and sign of
                  #GL_INDEX_SHIFT, and added to #GL_INDEX_OFFSET. Indices are
                  then replaced by the red, green, blue, and alpha values
                  obtained by indexing the tables #GL_PIXEL_MAP_I_TO_R,
                  #GL_PIXEL_MAP_I_TO_G, #GL_PIXEL_MAP_I_TO_B, and
                  #GL_PIXEL_MAP_I_TO_A. Each table must be of size 2^n, but n
                  may be different for different tables. Before an index is used
                  to look up a value in a table of size 2^n, it must be masked
                  against 2^n - 1.

                  If RGBA color components are stored in the color buffers, they
                  are read from the color buffer selected by gl.ReadBuffer().
                  Each color component is converted to floating point such that
                  zero intensity maps to 0.0 and full intensity maps to 1.0.
                  Each component is then multiplied by #GL_c_SCALE and added to
                  #GL_c_BIAS, where c is RED, GREEN, BLUE, or ALPHA. Finally, if
                  #GL_MAP_COLOR is #GL_TRUE, each component is clamped to the
                  range (0,1), scaled to the size of its corresponding table,
                  and is then replaced by its mapping in the table
                  #GL_PIXEL_MAP_c_TO_c, where c is R, G, B, or A.

                  Unneeded data is then discarded. For example, #GL_RED discards
                  the green, blue, and alpha components, while #GL_RGB discards
                  only the alpha component. #GL_LUMINANCE computes a
                  single-component value as the sum of the red, green, and blue
                  components, and #GL_LUMINANCE_ALPHA does the same, while
                  keeping alpha as a second value. The final values are clamped
                  to the range (0,1).

        #GL_GREEN See above in #GL_RED.

        #GL_BLUE  See above in #GL_RED.

        #GL_ALPHA See above in #GL_RED.

        #GL_RGB   See above in #GL_RED.

        #GL_RGBA  See above in #GL_RED.

        #GL_LUMINANCE
                  See above in #GL_RED.

        #GL_LUMINANCE_ALPHA
                  See above in #GL_RED.

        The shift, scale, bias, and lookup factors just described are all
        specified by @{"gl.PixelTransfer()" LINK glPixelTransfer}. The lookup table contents themselves
        are specified by @{"gl.PixelMap()" LINK glPixelMap}.

        Return values are placed in the table as follows. If "format" is
        #GL_COLOR_INDEX, #GL_STENCIL_INDEX, #GL_DEPTH_COMPONENT, #GL_RED,
        #GL_GREEN, #GL_BLUE, #GL_ALPHA, or #GL_LUMINANCE, a single
        floating-point value is returned. #GL_RGB returns three values, #GL_RGBA
        returns four values, and #GL_LUMINANCE_ALPHA returns two values for each
        pixel, with all values corresponding to a single pixel occupying
        contiguous space in data. Storage parameters set by @{"gl.PixelStore()" LINK glPixelStore},
        such as #GL_PACK_LSB_FIRST and #GL_PACK_SWAP_BYTES, affect the way that
        data is written into memory. See @{"gl.PixelStore" LINK glPixelStore} for details.

        Values for pixels that lie outside the window connected to the current
        GL context are undefined.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify the left coordinate of a rectangular block of pixels
        y         specify the lower coordinate of a rectangular block of pixels
        width     width of the pixel rectangle
        height    height of the pixel rectangle
        format    format of the pixel data (see above)

   @{b}RESULTS@{ub}
        pixelsArray
                  a table containing the pixel data

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "format" is not an accepted value.

        #GL_INVALID_VALUE is generated if either "width" or "height" is
        negative.

        #GL_INVALID_OPERATION is generated if "format" is #GL_COLOR_INDEX and
        the color buffers store RGBA color components.

        #GL_INVALID_OPERATION is generated if "format" is #GL_STENCIL_INDEX and
        there is no stencil buffer.

        #GL_INVALID_OPERATION is generated if "format" is #GL_DEPTH_COMPONENT
        and there is no depth buffer.

        #GL_INVALID_OPERATION is generated if gl.ReadPixels() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_MODE

@ENDNODE

@NODE glReadPixelsRaw "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ReadPixelsRaw -- read a block of pixels from the frame buffer

   @{b}SYNOPSIS@{ub}
        gl.ReadPixelsRaw(x, y, width, height, format, type, pixels)

   @{b}FUNCTION@{ub}
        This does the same as @{"gl.ReadPixels()" LINK glReadPixels} but doesn't return the pixels in a
        table. Instead, the pixels are written directly to a memory block that
        has to be passed in "pixels". This must be a memory buffer allocated by
        Hollywood's "AllocMem()" function and returned by "GetMemPointer()". See
        @{"Working with pointers" LINK UsingPointers} for details on how to use memory pointers with
        Hollywood.

        See @{"gl.ReadPixels" LINK glReadPixels} for a list of supported types for the format
        parameter.

        Additionally, gl.ReadPixelsRaw() also allows you to define the data type
        that should be used when reading pixels from the frame buffer. "type"
        can assume the following values: #GL_UNSIGNED_BYTE, #GL_BYTE,
        #GL_BITMAP, #GL_UNSIGNED_SHORT, #GL_SHORT, #GL_UNSIGNED_INT, #GL_INT, or
        #GL_FLOAT. @{"gl.ReadPixels()" LINK glReadPixels} always uses #GL_FLOAT. With
        gl.ReadPixelsRaw() you can adjust this parameter to your specific needs.

        See @{"gl.ReadPixels" LINK glReadPixels} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify the left coordinate of a rectangular block of pixels
        y         specify the lower coordinate of a rectangular block of pixels
        width     width of the pixel rectangle
        height    height of the pixel rectangle
        format    format of the pixel data (see above)
        type      specifies the data type of the pixel data (see above)
        pixels    pointer to a memory buffer to write the pixels to

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "format" or "type" is not an accepted
        value.

        #GL_INVALID_VALUE is generated if either "width" or "height" is
        negative.

        #GL_INVALID_OPERATION is generated if "format" is #GL_COLOR_INDEX and
        the color buffers store RGBA color components.

        #GL_INVALID_OPERATION is generated if "format" is #GL_STENCIL_INDEX and
        there is no stencil buffer.

        #GL_INVALID_OPERATION is generated if "format" is #GL_DEPTH_COMPONENT
        and there is no depth buffer.

        #GL_INVALID_OPERATION is generated if gl.ReadPixels() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_INDEX_MODE

@ENDNODE

@NODE glRect "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Rect -- draw a rectangle

   @{b}SYNOPSIS@{ub}
        gl.Rect(x1, y1, x2, y2)

   @{b}FUNCTION@{ub}
        gl.Rect() supports efficient specification of rectangles as two corner
        points. Each rectangle command takes four arguments, organized as two
        consecutive pairs of (x,y) coordinates. Alternatively, you can also pass
        two tables containing (x,y) coordinates each to gl.Rect(). The resulting
        rectangle is defined in the z = 0 plane.

        gl.Rect(x1, y1, x2, y2) is exactly equivalent to the following sequence:

            gl.Begin(#GL_POLYGON)
            gl.Vertex(x1, y1)
            gl.Vertex(x2, y1)
            gl.Vertex(x2, y2)
            gl.Vertex(x1, y2)
            gl.End()

        Note that if the second vertex is above and to the right of the first
        vertex, the rectangle is constructed with a counter-clockwise winding.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x1        specifies one vertex of the rectangle
        y1        specifies one vertex of the rectangle
        x2        specifies the opposite vertex of the rectangle
        y2        specifies the opposite vertex of the rectangle

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.Rect() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

@ENDNODE

@NODE glRenderMode "GL Galore Guide"

   @{b}NAME@{ub}
        gl.RenderMode -- set rasterization mode

   @{b}SYNOPSIS@{ub}
        r = gl.RenderMode(mode)

   @{b}FUNCTION@{ub}
        gl.RenderMode() sets the rasterization mode. It takes one argument,
        "mode", which can assume one of three predefined values:

        #GL_RENDER
                  Render mode. Primitives are rasterized, producing pixel
                  fragments, which are written into the frame buffer. This is
                  the normal mode and also the default mode.

        #GL_SELECT
                  Selection mode. No pixel fragments are produced, and no change
                  to the frame buffer contents is made. Instead, a record of the
                  names of primitives that would have been drawn if the render
                  mode had been #GL_RENDER is returned in a select buffer, which
                  must be created See @{"gl.SelectBuffer" LINK glSelectBuffer} for details. () before
                  selection mode is entered.

        #GL_FEEDBACK
                  Feedback mode. No pixel fragments are produced, and no change
                  to the frame buffer contents is made. Instead, the coordinates
                  and attributes of vertices that would have been drawn if the
                  render mode had been #GL_RENDER is returned in a feedback
                  buffer, which must be created See @{"gl.FeedbackBuffer" LINK glFeedbackBuffer} for
                  details. () before feedback mode is entered.

        The return value of gl.RenderMode() is determined by the render mode at
        the time gl.RenderMode() is called, rather than by "mode". The values
        returned for the three render modes are as follows:

        #GL_RENDER
                  0.

        #GL_SELECT
                  The number of hit records transferred to the select buffer.

        #GL_FEEDBACK
                  The number of values (not vertices) transferred to the
                  feedback buffer.

        See @{"gl.SelectBuffer" LINK glSelectBuffer} for more details concerning selection operation.

        See @{"gl.FeedbackBuffer" LINK glFeedbackBuffer} for more details concerning feedback operation.

        If an error is generated, gl.RenderMode() returns 0 regardless of the
        current render mode.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies the rasterization mode; the initial value is
                  #GL_RENDER (see above)

   @{b}RESULTS@{ub}
        r         return code (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is not one of the three accepted
        values.

        #GL_INVALID_OPERATION is generated if @{"gl.SelectBuffer()" LINK glSelectBuffer} is called while
        the render mode is #GL_SELECT, or if gl.RenderMode() is called with
        argument #GL_SELECT before @{"gl.SelectBuffer()" LINK glSelectBuffer} is called at least once.

        #GL_INVALID_OPERATION is generated if @{"gl.FeedbackBuffer()" LINK glFeedbackBuffer} is called
        while the render mode is #GL_FEEDBACK, or if gl.RenderMode() is called
        with argument #GL_FEEDBACK before @{"gl.FeedbackBuffer()" LINK glFeedbackBuffer} is called at least
        once.

        #GL_INVALID_OPERATION is generated if gl.RenderMode() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_RENDER_MODE

@ENDNODE

@NODE glRotate "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Rotate -- multiply the current matrix by a rotation matrix

   @{b}SYNOPSIS@{ub}
        gl.Rotate(angle, x, y, z)

   @{b}FUNCTION@{ub}
        gl.Rotate() produces a rotation of angle degrees around the vector
        (x,y,z). The current matrix See @{"gl.MatrixMode" LINK glMatrixMode} for details. () is
        multiplied by a rotation matrix with the product replacing the current
        matrix.

        If the matrix mode is either #GL_MODELVIEW or #GL_PROJECTION, all
        objects drawn after gl.Rotate() is called are rotated.

        Use @{"gl.PushMatrix()" LINK glPushMatrix} and @{"gl.PopMatrix()" LINK glPopMatrix} to save and restore the unscaled
        coordinate system.

        This rotation follows the right-hand rule, so if the vector (x,y,z)
        points toward the user, the rotation will be counterclockwise.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        angle     specifies the angle of rotation, in degrees
        x         specify the x coordinate of a vector
        y         specify the y coordinate of a vector
        z         specify the z coordinate of a vector

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.Rotate() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glScale "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Scale -- multiply the current matrix by a general scaling matrix

   @{b}SYNOPSIS@{ub}
        gl.Scale(x, y, z)

   @{b}FUNCTION@{ub}
        gl.Scale() produces a nonuniform scaling along the x, y, and z axes. The
        three parameters indicate the desired scale factor along each of the
        three axes.

        The current matrix See @{"gl.MatrixMode" LINK glMatrixMode} for details. () is multiplied by
        this scale matrix, and the product replaces the current matrix as if
        @{"gl.MultMatrix()" LINK glMultMatrix} were called with the following matrix as its argument:

            x 0 0 0
            0 y 0 0
            0 0 z 0
            0 0 0 1

        If the matrix mode is either #GL_MODELVIEW or #GL_PROJECTION, all
        objects drawn after gl.Scale() is called are scaled.

        Use @{"gl.PushMatrix()" LINK glPushMatrix} and @{"gl.PopMatrix()" LINK glPopMatrix} to save and restore the unscaled
        coordinate system.

        If scale factors other than 1 are applied to the modelview matrix and
        lighting is enabled, lighting often appears wrong. In that case, enable
        automatic normalization of normals by calling @{"gl.Enable()" LINK glEnable} with the
        argument #GL_NORMALIZE.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify scale factor along the x axis
        y         specify scale factor along the y axis
        z         specify scale factor along the z axis

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.Scale() is executed between the
        execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_MATRIX_MODE

        @{"gl.Get()" LINK glGet} with argument #GL_MODELVIEW_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_PROJECTION_MATRIX

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_MATRIX

@ENDNODE

@NODE glScissor "GL Galore Guide"

   @{b}NAME@{ub}
        gl.Scissor -- define the scissor box

   @{b}SYNOPSIS@{ub}
        gl.Scissor(x, y, width, height)

   @{b}FUNCTION@{ub}
        gl.Scissor() defines a rectangle, called the scissor box, in window
        coordinates. The first two arguments, "x" and "y", specify the lower
        left corner of the box. "width" and "height" specify the width and
        height of the box.

        To enable and disable the scissor test, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_SCISSOR_TEST. The test is initially
        disabled. While the test is enabled, only pixels that lie within the
        scissor box can be modified by drawing commands. Window coordinates have
        integer values at the shared corners of frame buffer pixels.
        gl.Scissor(0,0,1,1) allows modification of only the lower left pixel in
        the window, and gl.Scissor(0,0,0,0) doesn't allow modification of any
        pixels in the window.

        When the scissor test is disabled, it is as though the scissor box
        includes the entire window.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        x         specify the left corner of the scissor box; initally 0
        y         specify the lower corner of the scissor box; initially 0
        width     specify the width of the scissor box
        height    specify the height of the scissor box

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if either "width" or "height" is
        negative.

        #GL_INVALID_OPERATION is generated if gl.Scissor() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_SCISSOR_BOX

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_SCISSOR_TEST

@ENDNODE

@NODE glSelectBuffer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.SelectBuffer -- establish a buffer for selection mode values

   @{b}SYNOPSIS@{ub}
        buffer = gl.SelectBuffer(size)

   @{b}FUNCTION@{ub}
        gl.SelectBuffer() allocates a memory buffer of the size specified in the
        "size" argument and returns a pointer to this buffer. Values from the
        name stack will be written to this buffer (see @{"gl.InitNames()" LINK glInitNames},
        @{"gl.LoadName()" LINK glLoadName}, @{"gl.PushName()" LINK glPushName}) when the rendering mode is #GL_SELECT
        See @{"gl.RenderMode" LINK glRenderMode} for details. (). gl.SelectBuffer() must be issued
        before selection mode is enabled, and it must not be issued while the
        rendering mode is #GL_SELECT.

        You can read values from the memory buffer returned by gl.SelectBuffer()
        by calling @{"gl.GetSelectBuffer()" LINK glGetSelectBuffer} or accessing the buffer directly using
        Hollywood's "GetMemPointer()" and "Peek()" functions. When accessing the
        buffer directly, please note that the first four bytes in the buffer
        contain the size of the selection buffer in bytes.

        A programmer can use selection to determine which primitives are drawn
        into some region of a window. The region is defined by the current
        modelview and perspective matrices.

        In selection mode, no pixel fragments are produced from rasterization.
        Instead, if a primitive or a raster position intersects the clipping
        volume defined by the viewing frustum and the user-defined clipping
        planes, this primitive causes a selection hit. (With polygons, no hit
        occurs if the polygon is culled.) When a change is made to the name
        stack, or when @{"gl.RenderMode()" LINK glRenderMode} is called, a hit record is copied to
        buffer if any hits have occurred since the last such event (name stack
        change or @{"gl.RenderMode()" LINK glRenderMode} call). The hit record consists of the number
        of names in the name stack at the time of the event, followed by the
        minimum and maximum depth values of all vertices that hit since the
        previous event, followed by the name stack contents, bottom name first.

        Depth values (which are in the range [0,1]) are multiplied by 2^32 - 1,
        before being placed in the hit record.

        An internal index into buffer is reset to 0 whenever selection mode is
        entered. Each time a hit record is copied into buffer, the index is
        incremented to point to the cell just past the end of the block of
        names, that is, to the next available cell if the hit record is larger
        than the number of remaining locations in buffer, as much data as can
        fit is copied, and the overflow flag is set. If the name stack is empty
        when a hit record is copied, that record consists of 0 followed by the
        minimum and maximum depth values.

        To exit selection mode, call @{"gl.RenderMode()" LINK glRenderMode} with an argument other than
        #GL_SELECT. Whenever @{"gl.RenderMode()" LINK glRenderMode} is called while the render mode is
        #GL_SELECT, it returns the number of hit records copied to buffer,
        resets the overflow flag and the selection buffer pointer, and
        initializes the name stack to be empty. If the overflow bit was set when
        @{"gl.RenderMode()" LINK glRenderMode} was called, a negative hit record count is returned.

        The contents of buffer is undefined until @{"gl.RenderMode()" LINK glRenderMode} is called with
        an argument other than #GL_SELECT.

        @{"gl.Begin()" LINK glBegin} / @{"gl.End()" LINK glEnd} primitives and calls to @{"gl.RasterPos()" LINK glRasterPos} can result
        in hits.

        To free a buffer allocated by this function, call @{"gl.FreeSelectBuffer()" LINK glFreeSelectBuffer}.
        See @{"gl.FreeSelectBuffer" LINK glFreeSelectBuffer} for details.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        size      specifies the size of the buffer in bytes

   @{b}RESULTS@{ub}
        buffer    memory buffer to use in selection mode

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "size" is negative.

        #GL_INVALID_OPERATION is generated if gl.SelectBuffer() is called while
        the render mode is #GL_SELECT, or if @{"gl.RenderMode()" LINK glRenderMode} is called with
        argument #GL_SELECT before gl.SelectBuffer() is called at least once.

        #GL_INVALID_OPERATION is generated if gl.SelectBuffer() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_NAME_STACK_DEPTH

        @{"gl.Get()" LINK glGet} with argument #GL_SELECTION_BUFFER_SIZE

        @{"gl.GetPointer()" LINK glGetPointer} with argument #GL_SELECTION_BUFFER_POINTER

@ENDNODE

@NODE glShadeModel "GL Galore Guide"

   @{b}NAME@{ub}
        gl.ShadeModel -- select flat or smooth shading

   @{b}SYNOPSIS@{ub}
        gl.ShadeModel(mode)

   @{b}FUNCTION@{ub}
        GL primitives can have either flat or smooth shading. Smooth shading,
        the default, causes the computed colors of vertices to be interpolated
        as the primitive is rasterized, typically assigning different colors to
        each resulting pixel fragment. Flat shading selects the computed color
        of just one vertex and assigns it to all the pixel fragments generated
        by rasterizing a single primitive. In either case, the computed color of
        a vertex is the result of lighting if lighting is enabled, or it is the
        current color at the time the vertex was specified if lighting is
        disabled.

        Flat and smooth shading are indistinguishable for points. Starting when
        @{"gl.Begin()" LINK glBegin} is issued and counting vertices and primitives from 1, the GL
        gives each flat-shaded line segment i the computed color of vertex i +
        1, its second vertex. Counting similarly from 1, the GL gives each
        flat-shaded polygon the computed color of the vertex listed in the
        following table. This is the last vertex to specify the polygon in all
        cases except single polygons, where the first vertex specifies the
        flat-shaded color.

            Primitive Type of Polygon i  |  Vertex
            ---------------------------------------
            Single polygon (i == 1)      |     1
            Triangle strip               |   i + 2
            Triangle fan                 |   i + 2
            Independent triangle         |    3i
            Quad strip                   |  2i + 2
            Independent quad             |    4i

        Flat and smooth shading are specified by gl.ShadeModel() with mode set
        to #GL_FLAT and #GL_SMOOTH, respectively.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mode      specifies a symbolic value representing a shading technique;
                  accepted values are #GL_FLAT and #GL_SMOOTH; the initial value
                  is #GL_SMOOTH

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "mode" is any value other than #GL_FLAT
        or #GL_SMOOTH.

        #GL_INVALID_OPERATION is generated if gl.ShadeModel() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_SHADE_MODEL

@ENDNODE

@NODE glStencilFunc "GL Galore Guide"

   @{b}NAME@{ub}
        gl.StencilFunc -- set function and reference value for stencil testing

   @{b}SYNOPSIS@{ub}
        gl.StencilFunc(func, ref, mask)

   @{b}FUNCTION@{ub}
        Stenciling, like depth-buffering, enables and disables drawing on a
        per-pixel basis. Stencil planes are first drawn into using GL drawing
        primitives, then geometry and images are rendered using the stencil
        planes to mask out portions of the screen. Stenciling is typically used
        in multipass rendering algorithms to achieve special effects, such as
        decals, outlining, and constructive solid geometry rendering.

        The stencil test conditionally eliminates a pixel based on the outcome
        of a comparison between the reference value and the value in the stencil
        buffer. To enable and disable the test, call @{"gl.Enable()" LINK glEnable} and
        @{"gl.Disable()" LINK glDisable} with argument #GL_STENCIL_TEST. To specify actions based on
        the outcome of the stencil test, call @{"gl.StencilOp()" LINK glStencilOp}.

        "func" is a symbolic constant that determines the stencil comparison
        function. It accepts one of eight values, shown in the following list.
        "ref" is an integer reference value that is used in the stencil
        comparison. It is clamped to the range (0,2^n-1), where n is the number
        of bitplanes in the stencil buffer. "mask" is bitwise ANDed with both
        the reference value and the stored stencil value, with the ANDed values
        participating in the comparison.

        If "stencil" represents the value stored in the corresponding stencil
        buffer location, the following list shows the effect of each comparison
        function that can be specified by func. Only if the comparison succeeds
        is the pixel passed through to the next stage in the rasterization
        process See @{"gl.StencilOp" LINK glStencilOp} for details. (). All tests treat stencil values
        as unsigned integers in the range (0,2^n-1), where n is the number of
        bitplanes in the stencil buffer.

        The following values are accepted by "func":

        #GL_NEVER Always fails.

        #GL_LESS  Passes if (ref & mask) < (stencil & mask).

        #GL_LEQUAL
                  Passes if (ref & mask) <= (stencil & mask).

        #GL_GREATER
                  Passes if (ref & mask) > (stencil & mask).

        #GL_GEQUAL
                  Passes if (ref & mask) >= (stencil & mask).

        GL_EQUAL  Passes if (ref & mask) = (stencil & mask).

        GL_NOTEQUAL
                  Passes if (ref & mask)!= (stencil & mask).

        #GL_ALWAYS
                  Always passes.

        Initially, the stencil test is disabled. If there is no stencil buffer,
        no stencil modification can occur and it is as if the stencil test
        always passes.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        func      specifies the test function; the initial value is #GL_ALWAYS
                  (see above)
        ref       specifies the reference value for the stencil test; the
                  initial value is 0
        mask      specifies a mask that is ANDed with both the reference value
                  and the stored stencil value when the test is done; the
                  initial value is all 1's

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "func" is not one of the eight accepted
        values.

        #GL_INVALID_OPERATION is generated if gl.StencilFunc() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_STENCIL_FUNC, #GL_STENCIL_VALUE_MASK,
        #GL_STENCIL_REF, or #GL_STENCIL_BITS

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_STENCIL_TEST

@ENDNODE

@NODE glStencilMask "GL Galore Guide"

   @{b}NAME@{ub}
        gl.StencilMask -- control the writing of individual bits in the stencil planes

   @{b}SYNOPSIS@{ub}
        gl.StencilMask(mask)

   @{b}FUNCTION@{ub}
        gl.StencilMask() controls the writing of individual bits in the stencil
        planes. The least significant n bits of mask, where n is the number of
        bits in the stencil buffer, specify a mask. Where a 1 appears in the
        mask, it's possible to write to the corresponding bit in the stencil
        buffer. Where a 0 appears, the corresponding bit is write-protected.
        Initially, all bits are enabled for writing.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        mask      specifies a bit mask to enable and disable writing of
                  individual bits in the stencil planes; initially, the mask is
                  all 1's

   @{b}ERRORS@{ub}
        #GL_INVALID_OPERATION is generated if gl.StencilMask() is executed
        between the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of
        @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_STENCIL_WRITEMASK,
        #GL_STENCIL_BACK_WRITEMASK, or #GL_STENCIL_BITS

@ENDNODE

@NODE glStencilOp "GL Galore Guide"

   @{b}NAME@{ub}
        gl.StencilOp -- set stencil test actions

   @{b}SYNOPSIS@{ub}
        gl.StencilOp(fail, zfail, zpass)

   @{b}FUNCTION@{ub}
        Stenciling, like depth-buffering, enables and disables drawing on a
        per-pixel basis. You draw into the stencil planes using GL drawing
        primitives, then render geometry and images, using the stencil planes to
        mask out portions of the screen. Stenciling is typically used in
        multipass rendering algorithms to achieve special effects, such as
        decals, outlining, and constructive solid geometry rendering.

        The stencil test conditionally eliminates a pixel based on the outcome
        of a comparison between the value in the stencil buffer and a reference
        value. To enable and disable the test, call @{"gl.Enable()" LINK glEnable} and @{"gl.Disable()" LINK glDisable}
        with argument #GL_STENCIL_TEST; to control it, call @{"gl.StencilFunc()" LINK glStencilFunc}.

        gl.StencilOp() takes three arguments that indicate what happens to the
        stored stencil value while stenciling is enabled. If the stencil test
        fails, no change is made to the pixel's color or depth buffers, and
        "fail" specifies what happens to the stencil buffer contents. The
        following eight actions are possible.

        #GL_KEEP  Keeps the current value.

        #GL_ZERO  Sets the stencil buffer value to 0.

        #GL_REPLACE
                  Sets the stencil buffer value to ref, as specified by
                  @{"gl.StencilFunc()" LINK glStencilFunc}.

        #GL_INCR  Increments the current stencil buffer value. Clamps to the
                  maximum representable unsigned value.

        #GL_DECR  Decrements the current stencil buffer value. Clamps to 0.

        #GL_INVERT
                  Bitwise inverts the current stencil buffer value.

        Stencil buffer values are treated as unsigned integers. When incremented
        and decremented, values are clamped to 0 and 2^n - 1, where n is the
        value returned by querying #GL_STENCIL_BITS.

        The other two arguments to gl.StencilOp() specify stencil buffer actions
        that depend on whether subsequent depth buffer tests succeed ("zpass")
        or fail ("zfail") See @{"gl.DepthFunc" LINK glDepthFunc} for details. (). The actions are
        specified using the same eight symbolic constants as "fail". Note that
        "zfail" is ignored when there is no depth buffer, or when the depth
        buffer is not enabled. In these cases, "fail" and "zpass" specify
        stencil action when the stencil test fails and passes, respectively.

        Initially the stencil test is disabled. If there is no stencil buffer,
        no stencil modification can occur and it is as if the stencil tests
        always pass, regardless of any call to gl.StencilOp().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        fail      specifies the action to take when the stencil test fails; the
                  initial value is #GL_KEEP (see above)
        zfail     specifies the stencil action when the stencil test passes, but
                  the depth test fails; "zfail" accepts the same symbolic
                  constants as "fail"; the initial value is #GL_KEEP
        zpass     specifies the stencil action when both the stencil test and
                  the depth test pass, or when the stencil test passes and
                  either there is no depth buffer or depth testing is not
                  enabled; "zpass" accepts the same symbolic constants as "fail";
                  the initial value is #GL_KEEP

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated if "fail", "zfail", or "zpass" is any
        value other than the eight defined constant values.

        #GL_INVALID_OPERATION is generated if gl.StencilOp() is executed between
        the execution of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with one of the following arguments: #GL_STENCIL_FAIL,
        #GL_STENCIL_PASS_DEPTH_PASS, #GL_STENCIL_PASS_DEPTH_FAIL,
        #GL_STENCIL_BACK_FAIL, or #GL_STENCIL_BITS

        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_STENCIL_TEST

@ENDNODE

@NODE glTexCoord "GL Galore Guide"

   @{b}NAME@{ub}
        gl.TexCoord -- set the current texture coordinates

   @{b}SYNOPSIS@{ub}
        gl.TexCoord(s[, t, r, q])

   @{b}FUNCTION@{ub}
        gl.TexCoord() specifies texture coordinates in one, two, three, or four
        dimensions.

        The current texture coordinates are part of the data that is associated
        with each vertex and with the current raster position. Initially, the
        values for s, t, r, and q are (0, 0, 0, 1).

        The current texture coordinates can be updated at any time. In
        particular, gl.TexCoord() can be called between a call to @{"gl.Begin()" LINK glBegin} and
        the corresponding call to @{"gl.End()" LINK glEnd}.

        Alternatively, you can also pass a table that contains one to four
        coordinates to gl.TexCoord().

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        s         specify the s texture coordinate
        t         optional: specify the t texture coordinate (defaults to 0)
        r         optional: specify the r texture coordinate (defaults to 0)
        q         optional: specify the q texture coordinate (defaults to 1)

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.Get()" LINK glGet} with argument #GL_CURRENT_TEXTURE_COORDS

@ENDNODE

@NODE glTexCoordPointer "GL Galore Guide"

   @{b}NAME@{ub}
        gl.TexCoordPointer -- define an array of texture coordinates

   @{b}SYNOPSIS@{ub}
        gl.TexCoordPointer(vArray[, size])

   @{b}FUNCTION@{ub}
        gl.TexCoordPointer() specifies an array of texture coordinates to use
        when rendering. "vArray" can be either a one-dimensional table
        consisting of an arbitrary number of consecutive texture coordinates or
        a two-dimensional table consisting of an arbitrary number of subtables
        which contain 1 to 4 texture coordinates each. If "vArray" is a
        one-dimensional table, you need to pass the optional "size" argument as
        well to define the number of texture coordinates per array element.
        "size" must be a value in the range of 1 to 4. If "vArray" is a
        two-dimensional table, "size" is automatically determined by the number
        of items in the first subtable, which must be in the range of 1 to 4 as
        well.

        When using a two-dimensional table, please keep in mind that the number
        of texture coordinates in each subtable must be constant. It is not
        allowed to use differing numbers of texture coordinates in the
        individual subtables. The number of texture coordinates is defined by
        the number of elements in the first subtable and all following subtables
        must use the very same number of coordinates.

        If you pass Nil in "vArray", the texture coordinates array buffer will
        be freed but it won't be removed from OpenGL. You need to do this
        manually, e.g. by disabling the texture coordinates array or defining a
        new one.

        To enable and disable a texture coordinate array, call
        @{"gl.EnableClientState()" LINK glEnableClientState} and @{"gl.DisableClientState()" LINK glDisableClientState} with the argument
        #GL_TEXTURE_COORD_ARRAY. If enabled, the texture coordinate array is
        used when @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is
        called.

        Each texture coordinate array is initially disabled and isn't accessed
        when @{"gl.DrawArrays()" LINK glDrawArrays}, @{"gl.DrawElements()" LINK glDrawElements}, or @{"gl.ArrayElement()" LINK glArrayElement} is
        called.

        Execution of gl.TexCoordPointer() is not allowed between the execution
        of @{"gl.Begin()" LINK glBegin} and the corresponding execution of @{"gl.End()" LINK glEnd}, but an error
        may or may not be generated. If no error is generated, the operation is
        undefined.

        gl.TexCoordPointer() is typically implemented on the client side.

        Texture coordinate array parameters are client-side state and are
        therefore not saved or restored by @{"gl.PushAttrib()" LINK glPushAttrib} and @{"gl.PopAttrib()" LINK glPopAttrib}.
        Use @{"gl.PushClientAttrib()" LINK glPushClientAttrib} and @{"gl.PopClientAttrib()" LINK glPopClientAttrib} instead.

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        vArray    one- or two-dimensional table containing texture coordinates
                  or Nil (see above)
        size      optional: texture coordinates per array element; must be
                  between 1 to 4 and is only used with one-dimensional tables
                  (see above)

   @{b}ERRORS@{ub}
        #GL_INVALID_VALUE is generated if "size" is not 1, 2, 3, or 4.

   @{b}ASSOCIATED GETS@{ub}
        @{"gl.IsEnabled()" LINK glIsEnabled} with argument #GL_TEXTURE_COORD_ARRAY

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_COORD_ARRAY_SIZE

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_COORD_ARRAY_TYPE

        @{"gl.Get()" LINK glGet} with argument #GL_TEXTURE_COORD_ARRAY_STRIDE

        @{"gl.GetPointer()" LINK glGetPointer} with argument #GL_TEXTURE_COORD_ARRAY_POINTER

@ENDNODE

@NODE glTexEnv "GL Galore Guide"

   @{b}NAME@{ub}
        gl.TexEnv -- set texture environment parameters

   @{b}SYNOPSIS@{ub}
        gl.TexEnv(pname, param)

   @{b}FUNCTION@{ub}
        A texture environment specifies how texture values are interpreted when
        a fragment is textured. "pname" can be either #GL_TEXTURE_ENV_MODE or
        #GL_TEXTURE_ENV_COLOR. If "pname" is #GL_TEXTURE_ENV_MODE, then "param"
        must be the symbolic name of a texture function. Four texture functions
        may be specified: #GL_MODULATE, #GL_DECAL, #GL_BLEND, and #GL_REPLACE.

        A texture function acts on the fragment to be textured using the texture
        image value that applies to the fragment See @{"gl.TexParameter" LINK glTexParameter} for
        details. () and produces an RGBA color for that fragment. See an OpenGL
        reference manual for information on how the RGBA color is produced for
        each of the three texture functions that can be chosen.

        If "pname" is #GL_TEXTURE_ENV_COLOR, "param" must be a table containing
        an array that holds an RGBA color consisting of four floating-point
        values.

        #GL_TEXTURE_ENV_MODE defaults to #GL_MODULATE and #GL_TEXTURE_ENV_COLOR
        defaults to (0, 0, 0, 0)

        Please consult an OpenGL reference manual for more information.

   @{b}INPUTS@{ub}
        pname     specifies the symbolic name of a texture environment parameter
                  (see above)
        param     table or single value specifying the parameter

   @{b}ERRORS@{ub}
        #GL_INVALID_ENUM is generated when "pname" is not one of the accepted
        defined values, or when "param" should have a defined constant value
        (based on the value of "pname") and does not.

        #GL_INVALID_OPERATION is generated if gl.TexEnv() is executed between
        the execu