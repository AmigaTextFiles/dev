@DATABASE Pangomonium.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from Pangomonium.meta by MetaDoc 1.16 (c) by Airsoft Softwair"
@$VER: Pangomonium.guide 2.1 (27.09.2024)
@INDEX Reference
@HELP Reference

@NODE Main "Pangomonium Guide"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                                     -= @{B}@{FG highlight}P A N G O M O N I U M@{FG text}@{UB} =-

                          The Ultimate Text & Graphics Engine for Hollywood

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 I. General information
 @{" Introduction                       " LINK Introduction}     What is Pangomonium?
 @{" Terms and conditions               " LINK License}     License information
 @{" Requirements                       " LINK Requirements}     What you need to work with it
 @{" Installation                       " LINK Installation}     How to install Pangomonium

 II. About Pangomonium
 @{" Credits                            " LINK Credits}     Who was involved in this project?
 @{" F.A.Q.                             " LINK FAQ}     Frequently asked questions
 @{" Future                             " LINK ToDo}     What is planned for the future?
 @{" History                            " LINK History}     What has happened so far?

 III. Usage
 @{" Overview                           " LINK UsageOverview}     Outline of the two different operation modes
 @{" Using the high-level interface     " LINK HighLevelInterface}     The easiest way to use Pangomonium
 @{" Using the vectorgraphics interface " LINK VectorGfxInterface}     Replaces Hollywood's vectorgraphics library
 @{" Loading SVG images                 " LINK SVGInterface}     How to load SVG images with Pangomonium
 @{" Using the low-level interface      " LINK LowLevelInterface}     This gives fine-tuned control over everything

 IV. Cairo APIs
 @{" General functions                  " LINK CFunctions}     Object constructors and general functions
 @{" Cairo context                      " LINK CContext}     The Cairo drawing context
 @{" Cairo font face                    " LINK CFontFace}     Base class for font faces
 @{" Cairo font options                 " LINK CFontOptions}     How a font should be rendered
 @{" Cairo glyphs                       " LINK CGlyphs}     Represents a single character
 @{" Cairo matrix                       " LINK CMatrix}     Manages transformations in the path
 @{" Cairo path                         " LINK CPath}     Creating paths and manipulating their data
 @{" Cairo pattern                      " LINK CPattern}     Sources for drawing
 @{" Cairo region                       " LINK CRegion}     Representing a pixel-aligned area
 @{" Cairo scaled font                  " LINK CScaledFont}     Font face at a particular size and options
 @{" Cairo surface                      " LINK CSurface}     Base class for surfaces

 V. Pango APIs
 @{" General functions                  " LINK PFunctions}     Object constructors and general functions
 @{" Pango analysis                     " LINK PAnalysis}     Information about the properties of a segment of text
 @{" Pango attribute                    " LINK PAttribute}     Apply format styles to segments of text
 @{" Pango attribute list               " LINK PAttributeList}     Combine several attributes in a list
 @{" Pango context                      " LINK PContext}     Global control over the itemization process
 @{" Pango coverage                     " LINK PCoverage}     Map Unicode characters to Pango levels
 @{" Pango font                         " LINK PFont}     Font representation in a rendering-system-independent manner
 @{" Pango font description             " LINK PFontDescription}     Describes a font in an implementation-independent manner
 @{" Pango font face                    " LINK PFontFace}     Group of fonts with the same family
 @{" Pango font family                  " LINK PFontFamily}     Family of related font faces
 @{" Pango font map                     " LINK PFontMap}     Set of fonts available for a particular rendering system
 @{" Pango font metrics                 " LINK PFontMetrics}     Overall metric information for a font
 @{" Pango font set                     " LINK PFontSet}     Set of individual Pango fonts
 @{" Pango glyph item                   " LINK PGlyphItem}     Glyph resulting from shaping the text
 @{" Pango glyph string                 " LINK PGlyphString}     String of glyphs with geometry and visual attribute information
 @{" Pango item                         " LINK PItem}     Information about a segment of text
 @{" Pango language                     " LINK PLanguage}     Language-specific information
 @{" Pango layout                       " LINK PLayout}     An entire paragraph of text
 @{" Pango layout iterator              " LINK PLayoutIterator}     Iterate over the visual extents of a layout
 @{" Pango layout line                  " LINK PLayoutLine}     A single line from a laid out paragraph
 @{" Pango matrix                       " LINK PMatrix}     Transformation between user-space and device coordinates
 @{" Pango tab array                    " LINK PTabArray}     A set of tab stops

 @{" Index                              " LINK Reference}     Quickly find what you are looking for

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 Pangomonium is (C) Copyright © 2022-2024 Andreas Falkenhahn                    All rights reserved
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@ENDNODE
@NODE Introduction "Pangomonium Guide"
@{b}Introduction@{ub}

    Pangomonium is a plugin for Hollywood that features advanced rendering
    engines both for text and graphics. Pangomonium's text rendering engine
    features state-of-the-art layouting and makes it possible to draw text in
    almost every language of the world. It supports complex layouts like the
    right-to-left or bidirectional ones found in the Arabic and Hebrew languages
    or vertical layouts in columns like in Japanese. Pangomonium can also handle
    complex-text languages like Hindi and fonts that contain colored glyphs
    (emojis) are supported as well. By giving you full access to the Pango API
    the plugin also enables you to customize all stages of the text rendering
    process.

    Furthermore, Pangomonium also comes with a loader for the popular SVG vector
    image format. As soon as Pangomonium is installed, Hollywood will
    "automagically" be able to load and draw SVG images. SVG images will be
    loaded as true vector images by Pangomonium which means that you can scale
    and transform them as you wish without any losses in quality. They will be
    perfectly crisp in any resolution.

    On top of that, Pangomonium also provides Hollywood wrappers for almost all
    functions of the popular Cairo graphics engine, allowing you to access
    advanced vector graphics drawing features directly from Hollywood scripts.
    Using the Cairo API via Pangomonium has the advantage that you have
    fine-tuned control over everything when drawing vector graphics.

    There are two ways of using Pangomonium: There is a high-level interface
    that can directly hook itself into Hollywood's text and vector graphics
    library, enhancing it with features provided by Pangomonium, e.g. drawing
    colored emojis or text with complex layouts such as Arabic or Japanese. This
    is the most convenient way of using Pangomonium because you don't have to
    use the Pango and Cairo functions directly here but you can just use
    established Hollywood functions.

    Another way of using Pangomonium is the low-level interface: This interface
    allows you to access the Pango and Cairo APIs directly from Hollywood
    scripts. This is extremely powerful because it allows you to access hundreds
    of different text and graphics rendering features, making it possible to
    fine-tune Pangomonium to your specific needs. Pangomonium contains over 500
    commands to make all your text and vector graphics rendering dreams come
    true!

    Finally, Pangomonium comes with extensive documentation in various formats
    like PDF, HTML, AmigaGuide, and CHM that contains detailed descriptions of
    all functions and methods offered by the plugin.

    All of this makes Pangomonium the ultimate text and graphics rendering
    engine for Hollywood that contains everything you need to draw text in any
    language spoken on the planet.

@ENDNODE

@NODE License "Pangomonium Guide"
@{b}Terms and conditions@{ub}

    Pangomonium is © Copyright 2022-2024 by Andreas Falkenhahn (in the following
    referred to as "the author"). All rights reserved.

    The program is provided "as-is" and the author cannot be made responsible of
    any possible harm done by it. You are using this program absolutely at your
    own risk. No warranties are implied or given by the author.

    This plugin may be freely distributed as long as the following three
    conditions are met:

    1. No modifications must be made to the plugin.
    2. It is not allowed to sell this plugin.
    3. If you want to put this plugin on a coverdisc, you need to ask for
       permission first.

    This software uses Pango which is released under the terms of the GNU Lesser
    General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses GNU FriBidi which is released under the terms of the GNU
    Lesser General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses Cairo which is released under the terms of the GNU Lesser
    General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses GLib which is released under the terms of the GNU Lesser
    General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses Librsvg which is released under the terms of the GNU
    Lesser General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses the Croco library which is released under the terms of
    the GNU Lesser General Public License. See @{"LGPL license" LINK LicenseLGPL} for details.

    This software uses HarfBuzz. See @{"HarfBuzz license" LINK LicenseHarfBuzz} for details.

    This software uses Expat which is Copyright (c) 1998-2000 Thai Open Source
    Software Center Ltd and Clark Cooper and Copyright (c) 2001-2022 Expat
    maintainers. See @{"Expat license" LINK LicenseExpat} for details.

    This software uses libxml2 which is Copyright (C) 1998-2012 Daniel Veillard.
    See @{"Libxml2 license" LINK LicenseLibxml2} for details.

    This software uses Fontconfig. See @{"Fontconfig license" LINK LicenseFontconfig} for details.

    This software uses the pixman library. See @{"Pixman license" LINK LicensePixman} for details.

    This software uses libpng by the PNG Development Group and zlib by Jean-loup
    Gailly and Mark Adler.

    Portions of this software are copyright (C) 2023 The FreeType Project
    (www.freetype.org). All rights reserved.

    All trademarks are the property of their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "Pangomonium Guide"
@{b}Requirements@{ub}

    - Hollywood 10.0 or better
    - Windows: requires Windows Vista or better
    - macOS: requires at least 10.5 (Leopard) for PowerPC, 10.9 (Mavericks) for
      x64 and 11.0 (Big Sur) for arm64
    - AmigaOS 3: your filesystem must be able to handle filenames longer than
      the usual 31 characters which are the limit on classic FFS; so you mustn't
      use classic FFS with Pangomonium; also, when using fonts that contain
      emojis or CJK characters you'll also need lots of memory because those
      fonts are often than 10 to 20 megabytes (or even more) in size and
      Pangomonium loads each font you use into a contiguous memory block so
      you'll need lots of memory and it mustn't be fragmented so that large
      blocks can still be allocated

@ENDNODE

@NODE Installation "Pangomonium Guide"
@{b}Installation@{ub}

    Installing Pangomonium is straightforward and simple: Just copy the file
    pangomonium.hwp for the platform of your choice to Hollywood's plugins
    directory. On all systems except on AmigaOS and compatibles, plugins must be
    stored in a directory named Plugins that is in the same directory as the
    main Hollywood program. On AmigaOS and compatible systems, plugins must be
    installed to LIBS:Hollywood instead. On macOS, the Plugins directory must be
    inside the Resources directory of the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources.

    Afterwards merge the contents of the Examples folder with the Examples
    folder that is part of your Hollywood installation. All Pangomonium examples
    will then appear in Hollywood's GUI and you can launch and view them
    conveniently from the Hollywood GUI or IDE.

    On Windows you should also copy the file Pangomonium.chm to the Docs
    directory of your Hollywood installation. Then you will be able to get
    online help by pressing F1 when the cursor is over a Pangomonium function in
    the Hollywood IDE.

    On Linux and macOS copy the Pangomonium directory that is inside the Docs
    directory of the Pangomonium distribution archive to the Docs directory of
    your Hollywood installation. Note that on macOS the Docs directory is within
    the Hollywood.app application bundle, i.e. in
    Hollywood.app/Contents/Resources/Docs.

@ENDNODE

@NODE Credits "Pangomonium Guide"
@{b}Credits@{ub}

    Pangomonium was written by Andreas Falkenhahn, based on the Pango text
    engine and other components. See @{"Pangomonium license" LINK License} for details.

    If you need to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE FAQ "Pangomonium Guide"
@{b}Frequently asked questions@{ub}

    This section covers some frequently asked questions. Please read them first
    before asking on the forum because your problem might have been covered
    here.

    @{b}Q: @{ub}@{b}Is @{ub}@{b}there @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}forum @{ub}@{b}where @{ub}@{b}I @{ub}@{b}can @{ub}@{b}get @{ub}@{b}in @{ub}@{b}touch @{ub}@{b}with @{ub}@{b}other @{ub}@{b}users?@{ub}

    A: Yes, please check out the "Community" section of the official Hollywood
    Portal online at http://www.hollywood-mal.com.


    @{b}Q: @{ub}@{b}Where @{ub}@{b}can @{ub}@{b}I @{ub}@{b}ask @{ub}@{b}for @{ub}@{b}help?@{ub}

    A: There's an active forum at http://forums.hollywood-mal.com. You're welcome
    to join it and ask your question there.


    @{b}Q: @{ub}@{b}I @{ub}@{b}have @{ub}@{b}found @{ub}@{b}a @{ub}@{b}bug.@{ub}

    A: Please post about it in the "Bugs" section of the forum.

@ENDNODE

@NODE ToDo "Pangomonium Guide"
@{b}Future@{ub}

    Here are some things that are on my to do list:

    - add more examples

    Don't hesitate to contact me if Pangomonium lacks a certain feature that is
    important for your project.

@ENDNODE

@NODE History "Pangomonium Guide"
@{b}History@{ub}

    Please read the history bottom-up. Note that the history might list some
    features that were implemented in beta versions and removed later but are
    still mentioned here. This history is a log of the programmer so that he
    can look up what has been done/tried/modified. Things that were implemented
    and removed later are marked with [VOID].

    Version 2.1   (27-Sep-24)
    - Fix: SVG images can now also be loaded without \@REQUIREing the plugin first (reported by Ralf
      Gruner)

    Version 2.0   (17-Jul-24)
    - Change: Updated documentation
    - New: Added new example that demonstrates SVG image loading
    - New: Added support for the SVG image format; Pangomonium can now also act as a loader for the
      SVG image format; the functionality is exactly the same as with the separate SVG plugin that
      has been available for Hollywood for over a decade now; the difference is that Pangomonium's
      SVG loader is more compatible and also has full support for Unicode text inside SVG images
    - Change [Windows]: Reduced minimum required Windows version from Windows 7 to Windows Vista
    - Change [Windows]: Reduced binary size by several megabyte because we link against hand-tailored
      versions of the dependency libraries now instead of the ones from the official distributions
    - Fix [OS3]: Memory access fault when using pcontext:SetLanguage()
    - Fix [Amiga]: Memory access fault when using Cairo's PDF surface
    - Fix [OS4]: Rendering text with Cairo to PDF surfaces didn't always work

    Version 1.0a  (06-Jul-24)
    - Note: This release only contains updated builds for macOS; the builds for all the other
      platforms are identical with the v1.0 release
    - Change [macOS/x64+arm64]: MacPorts is no longer required by Pangomonium; the plugin is
      completely stand-alone now
    - Fix [macOS/PPC]: The plugin didn't work correctly on PowerPC macOS (reported by Ruben Hart)

    Version 1.0   (17-Mar-24)
    - First Release
@ENDNODE

@NODE UsageOverview "Pangomonium Guide"
@{b}Overview@{ub}

    There are two different ways of using Pangomonium: You can either access the
    Pango and Cairo APIs directly through a low-level interface or you can use
    Pangomonium's high-level interface which maps some of Pangomonium's features
    to standard Hollywood functions.

    Using the high-level interface is really easy and extends Hollywood
    functions like "SetFont()" and "TextOut()" to operate through Pangomonium,
    enabling them to support advanced text layouts like right-to-left or colored
    glyphs (emojis). If you just want to draw some text and you don't need any
    fine-tuned control over the text rendering process, the high-level interface
    is the way to go for you.

    Besides the high-level interface that extends Hollywood's text library,
    Pangomonium also has a second high-level interface. In contrast to the first
    one, the second high-level interface replaces Hollywood's vector graphics
    library and can be activated by calling Hollywood's "SetVectorEngine()"
    function and passing "pangomonium" as the argument.

    The low-level interface, i.e. accessing Pango and Cairo's API directly, is
    useful if you need more fine-tuned control over the text rendering. The
    low-level interface allows you to configure all kinds of options in
    Pangomonium and makes it possible to access all of Pango and Cairo's
    advanced features, allowing you to meticulously take control over
    everything.

@ENDNODE

@NODE HighLevelInterface "Pangomonium Guide"
@{b}Using the high-level interface@{ub}

    Using Pangomonium's high-level interface is really easy. It extends standard
    Hollywood text commands like "SetFont()" and "TextOut()" to support advanced
    text rendering features like complex layouts and colored glyphs like emojis.
    To draw text using Pangomonium through normal Hollywood commands, just make
    sure you open the font using Pangomonium by passing the "Loader" tag to
    "SetFont()". Once you have opened a font through Pangomonium, all Hollywood
    commands that draw text will automatically do so through Pangomonium as
    well, e.g.:

        \@REQUIRE "pangomonium"

        SetFont("Noto Sans CJK HK Regular", 72, {Loader = "pangomonium"})
        SetFontStyle(#ANTIALIAS)

        ; "What is your name?" in Japanese
        Local t = {21517, 21069, 12399, 12394, 12435, 12391, 12377, 12363}
        For Local k = 0 To ListItems(t) - 1 Do text$ = text$ .. Chr(t[k])

        TextOut(#CENTER, #CENTER, text$)

    The code above will set the font to Noto Sans CJK HK Regular size 72 and
    draw some Japanese text. By passing "pangomonium" to the "Loader" tag you
    tell "SetFont()" to open the font through Pangomonium instead of through
    Hollywood's inbuilt font engine or through a font engine provided by the
    host operating system.

    Another advantage of using the high-level interface is the fact that
    Pangomonium supports true vector-based text transformation without any
    quality loss. Hollywood's inbuilt font engines only support lossless scaling
    of vector text. As soon as text is rotated, a lossy algorithm is used so
    drawing rotated text using Pangomonium will give you a better quality.

    Furthermore, Pangomonium allows you to use Pango's markup language which can
    do some advanced text formatting that Hollywood's inbuilt text engine can't
    do. For example, Pango's markup language allows you to use different font
    sizes in a single text object. So if you need more powerful formatting
    capabilities than supported by Hollywood's inbuilt text renderer, you might
    also want to use Pangomonium instead. See @{"playout:SetMarkup()" LINK playoutSetMarkup} for more
    information on Pango's markup language. Also note that Pango's markup
    language isn't enabled by default in Pangomonium for compatibility reasons.
    If you want to use it, you need enable it explicitly by setting the "Markup"
    tag to TRUE (see below).

    Note that in the code above we explicitly tell "SetFont()" to use
    Pangomonium to open the font by passing "pangomonium" in the "Loader" tag.
    Alternatively, you can also globally enable Pangomonium for all Hollywood
    commands dealing with fonts by simply installing Pangomonium's font adapter.
    This can be done by setting the "InstallAdapter" tag to TRUE when
    "\@REQUIREing" Pangomonium, e.g. like this:

        \@REQUIRE "pangomonium", {InstallAdapter = True}

    If you globally enable Pangomonium, you don't have to use the "Loader" tag
    with "SetFont()" or other Hollywood commands that deal with fonts any longer
    because if Pangomonium is globally enabled, commands like "SetFont()" will
    automatically ask Pangomonium for every font that is to be opened whether or
    not the plugin would like to handle this font. Keep in mind, though, that by
    default Pangomonium will never fail on font opening so if you globally
    activate it like above, it will take over the handling of each and every
    font you open, which might not be what you want. You can modify this
    behaviour by setting the "NoFail" user tag to FALSE, in which case
    Pangomonium will fail if a font is not available. If you want Pangomonium to
    handle all fonts in your script, however, globally enabling it using
    "InstallAdapter" as shown above can be a good idea.

    When using Pangomonium you can also pass some additional arguments to
    "SetFont()", "OpenFont()" or the "\@FONT" preprocessor by using Hollywood's
    user tags. The following additional arguments are recognized by Pangomonium:

    NoFail    By default, Pangomonium will never fail to open a font. If the
              requested font does not exist, an appropriate substitute is used.
              By default, Pangomonium will always open a font no matter what
              name you pass to it. If you don't want that, set this tag to
              FALSE. Defaults to TRUE.

    Markup    If you set this to TRUE, Pangomonium will allow you to use the
              Pango markup language in the text you pass to Hollywood calls like
              "TextOut()". By default, Pangomonium only supports Hollywood's
              text formatting codes. If you want it to use Pango's markup
              language instead of Hollywood's text formatting codes, set this
              tag to TRUE. See @{"playout:SetMarkup()" LINK playoutSetMarkup} for information on Pango's
              markup language. Defaults to FALSE.

    Monochrome
              Set this tag to TRUE if you want Pangomonium to operate in
              monochrome mode. This will reduce memory consumption by 75%
              because Pangomonium only needs to allocate one pixel channel
              instead of four but you will only be able to use single-colored
              text in monochrome mode so things like color emojis won't be drawn
              correctly. Defaults to FALSE.

    NoFT2     By default, Pangomonium uses Pango's FreeType2-based text renderer
              on all platforms. If you don't want that, set this tag to TRUE. In
              that case, Pangomonium will use the host operating system's
              default text renderer instead (e.g. DirectWrite on Windows, Core
              Text on macOS etc.) Note that on AmigaOS and compatibles the only
              available renderer is FreeType2 so you mustn't set this tag to
              TRUE on AmigaOS. Defaults to FALSE.

    Here's how you can pass user tags to Pangomonium:

        \@REQUIRE "pangomonium"
        SetFont("Arial", 72, {Loader = "pangomonium", UserTags = {Markup = True}})
        SetFontStyle(#ANTIALIAS)
        TextOut(#CENTER, #CENTER, "<span bgcolor=\\"red\\">Hello</span>")

    The code above demonstrates how to enable Pango's markup language in
    Pangomonium's high-level interface.

@ENDNODE

@NODE VectorGfxInterface "Pangomonium Guide"
@{b}Using the vectorgraphics interface@{ub}

    Besides the high-level interface that extends Hollywood's text functions,
    Pangomonium also has a second high-level interface that can be used to
    replace Hollywood's vector graphics library. You can use Hollywood's
    "SetVectorEngine()" function to make Pangomonium the default renderer for
    vector graphics. This means that all vector graphics will be drawn by
    Pangomonium instead of Hollywood, so Hollywood functions like "DrawPath()"
    and all other functions from the vector graphics library will be handled by
    Pangomonium.

    To make Pangomonium the default renderer for vector graphics, just do the
    following:

        SetVectorEngine("pangomonium")

@ENDNODE

@NODE SVGInterface "Pangomonium Guide"
@{b}Loading SVG images@{ub}

    Pangomonium can also load and draw SVG images. As soon as the plugin is
    installed, Hollywood will 'automagically' be able to open SVG images. So
    when you use "LoadBrush()", for example, on an SVG image, Pangomonium will
    automatically load it. Note that since there is another Hollywood plugin
    that can load SVG images, it is recommended that you use the "Loader" tag to
    specify which plugin should be used to load the SVG image, e.g.

        ; this code will make Pangomonium load the image
        LoadBrush(1, "test.svg", {Loader = "pangomonium"})

        ; this code will make the svgimage.hwp plugin load the image
        LoadBrush(1, "test.svg", {Loader = "svgimage"})

    If you don't specify the "Loader" tag and you have two plugins that can load
    SVG images installed, the plugin that Hollywood has loaded first will be the
    one that will load your SVG image. But since the order Hollywood plugins are
    loaded is dependent on the file system you can't really rely on anything so
    it's better to explicitly use the "Loader" tag to tell Hollywood which
    plugin to use to load the SVG image. To see which plugin loaded your SVG
    image, you can use the #ATTRLOADER attribute like this:

        DebugPrint(GetAttribute(#BRUSH, 1, #ATTRLOADER))

    When it loads an SVG image, Pangomonium will always create a vector brush
    for you. This means that you can transform it using commands like
    "ScaleBrush()", "RotateBrush()", and "TransformBrush()" without any losses
    in quality. In case layers are enabled and you display a vector brush using
    "DisplayBrush()", the layer graphics can also be transformed without any
    quality loss. The same is true for BGPics using vector graphics.

    Please note that Pangomonium will also always create images with alpha
    channel by default. If you don't want that, you have to manually delete the
    alpha channel using "DeleteAlphaChannel()" after loading the image. In case
    you want to use an SVG image as a BGPic, you can also work around this
    problem by defining a background for this BGPic, e.g. like this:

        \@BGPIC 1, "test.svg", {FillStyle = #FILLCOLOR, FillColor = #WHITE,
                                Loader = "pangomonium"}

@ENDNODE

@NODE LowLevelInterface "Pangomonium Guide"
@{b}Using the low-level interface@{ub}

    Using Pangomonium's low-level interface is more difficult than using the
    high-level interface because it allows you to access Pango and Cairo APIs
    directly. This means that you should first make yourself familiar with those
    APIs so that you know how they are designed and how they can serve your
    purposes.

    On top of the core Pango and Cairo APIs, Pangomonium also offers some
    special functions that can be used to bridge Pango/Cairo calls and Hollywood
    functions. One of the key functions that serves as such a bridge is
    @{"csurface:ToBrush()" LINK csurfaceToBrush} which allows you to convert a Cairo surface to a
    Hollywood brush. Conversely, it is also possible to create Cairo surfaces
    from Hollywood brushes by using the @{"cairo.ImageSurfaceFromBrush()" LINK cairoImageSurfaceFromBrush} function.

    By using these bridging functions, you can use Pango/Cairo APIs directly and
    then convert the result to a Hollywood brush. For example, drawing text
    using Pango typically involves the following steps:

    1. Create a Pango fontmap
    2. Create a Pango context from the fontmap
    3. Create a Pango layout from the context
    4. Create a Pango font description and assign it to the layout
    5. Load a font into the fontmap
    6. Set text that is to be rendered
    7. Create a Cairo surface
    8. Create a Cairo context from the surface
    9. Show the Pango layout on the Cairo context
    10. Convert the Cairo surface to a Hollywood brush

    As you can see, it's quite some work to draw text with Pangomonium when
    using the Pango/Cairo APIs directly. It's much easier to do it with the
    @{"high-level interface" LINK HighLevelInterface} but only the low-level interface allows you to access
    all of Pango's and Cairo's features.

    Here is what the steps described above look like in actual code:

        \@REQUIRE "pangomonium"
        \@DISPLAY {Color = #WHITE}

        fontmap = pango.FontMap(#CAIRO_FONT_TYPE_FT)
        context = fontmap:CreateContext()
        layout = pango.Layout(context)
        fontdesc = pango.FontDescription("DejaVu Sans 72")
        layout:SetFontDescription(fontdesc)
        fontmap:LoadFont(context, fontdesc)
        layout:SetText("Hello World")
        img = cairo.ImageSurface(#CAIRO_FORMAT_ARGB32, 640, 480)
        cr = cairo.Context(img)
        cr:ShowLayout(layout)
        img:ToBrush(1)
        DisplayBrush(1, 0, 0)

    When using the low-level interface you also need to think about freeing
    objects when they are no longer in use. This can be done by calling the
    "Free()" methods of the individual objects, e.g. @{"pcontext:Free()" LINK pcontextFree} to free a
    Pango context. Alternatively, you can also set the object to Nil. This
    signals Hollywood's garbage collector that the object is no longer in use
    and can be freed. However, keep in mind that garbage collection will only
    occur if there are really no more references to the object anywhere. Thus,
    it might be safer to explicitly call the "Free()" methods instead of setting
    objects to Nil.

    If you put the code from the example above in a function and use local
    variables only, however, you can get away without explicitly calling
    "Free()" on all objects because local variables will automatically be
    garbage-collected once they go out of scope. Consider the following code,
    which is the same as above with the only difference that the code is now
    wrapped inside a function:

        Function p_DrawText(t$, brush)
           Local fontmap = pango.FontMap()
           Local context = fontmap:CreateContext()
           Local layout = pango.Layout(context)
           Local fontdesc = pango.FontDescription("DejaVu Sans 72")
           layout:SetFontDescription(fontdesc)
           fontmap:LoadFont(context, fontdesc)
           layout:SetText(t$)
           Local img = cairo.ImageSurface(#CAIRO_FORMAT_ARGB32, 640, 480)
           Local cr = cairo.Context(img)
           cr:ShowLayout(layout)
           img:ToBrush(brush)
        EndFunction

    Since all Pango and Cairo objects are stored inside local variables,
    everything will be marked for garbage collection as soon as the function
    returns. Thus, in this case it isn't necessary to explicitly free objects by
    calling "Free()", even though it might be considered good practice to do so
    nevertheless.

    For more information on the Pango and Cairo APIs, please refer to the
    following chapters.

@ENDNODE

@NODE cairoContext "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Context -- create Cairo context

   @{b}SYNOPSIS@{ub}
        handle = cairo.Context(target)

   @{b}FUNCTION@{ub}
        Creates a new Cairo context with all graphics state parameters set to
        default values and with "target" as a target surface. The target surface
        should be constructed with a backend-specific function such as
        @{"cairo.ImageSurface()" LINK cairoImageSurface} (or any other Cairo surface backend constructor).

        This function references "target", so you can immediately call
        @{"csurface:Free()" LINK csurfaceFree} on it if you don't need to maintain a separate reference
        to it.

        This function returns a newly allocated Cairo context with a reference
        count of 1. The initial reference count should be released with
        @{"ccontext:Free()" LINK ccontextFree} when you are done using the Cairo context. This function
        never returns Nil. If memory cannot be allocated, a special Cairo
        context object will be returned on which @{"ccontext:Status()" LINK ccontextStatus} returns
        #CAIRO_STATUS_NO_MEMORY. If you attempt to target a surface which does
        not support writing (such as a Cairo MIME surface) then a
        #CAIRO_STATUS_WRITE_ERROR will be raised. You can use this object
        normally, but no drawing will be done.

   @{b}INPUTS@{ub}
        target    target surface for the context

   @{b}RESULTS@{ub}
        handle    a newly allocated Cairo context

@ENDNODE

@NODE cairoFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.FontFace -- create font face

   @{b}SYNOPSIS@{ub}
        font = cairo.FontFace(pattern)

   @{b}FUNCTION@{ub}
        Creates a new font face for the FreeType font backend based on a
        Fontconfig pattern. This font can then be used with
        @{"ccontext:SetFontFace()" LINK ccontextSetFontFace} or @{"cairo.ScaledFont()" LINK cairoScaledFont}.

        The "pattern" argument can be either a string in the format used by
        Fontconfig, e.g. "Ubuntu:style=italic:weight=200" or it can be a table
        that can contain the following tags, each describing a single element of
        a Fontconfig pattern:

        Family    The font family name.

        Style     Font style (passed as a string). Overrides weight and slant.

        Slant     Font slant. This can be one of the following constants:

                      #FC_SLANT_ROMAN
                      #FC_SLANT_ITALIC
                      #FC_SLANT_OBLIQUE

        Weight    Font weight. This can be one of the following constants:

                      #FC_WEIGHT_THIN
                      #FC_WEIGHT_EXTRALIGHT
                      #FC_WEIGHT_ULTRALIGHT
                      #FC_WEIGHT_LIGHT
                      #FC_WEIGHT_DEMILIGHT
                      #FC_WEIGHT_SEMILIGHT
                      #FC_WEIGHT_BOOK
                      #FC_WEIGHT_REGULAR
                      #FC_WEIGHT_NORMAL
                      #FC_WEIGHT_MEDIUM
                      #FC_WEIGHT_DEMIBOLD
                      #FC_WEIGHT_SEMIBOLD
                      #FC_WEIGHT_BOLD
                      #FC_WEIGHT_EXTRABOLD
                      #FC_WEIGHT_ULTRABOLD
                      #FC_WEIGHT_BLACK
                      #FC_WEIGHT_HEAVY
                      #FC_WEIGHT_EXTRABLACK
                      #FC_WEIGHT_ULTRABLACK

        Size      Font size in points.

        Aspect    Stretches glyphs horizontally before hinting.

        PixelSize Font size in pixels.

        Spacing   Font spacing. This can be one of the following constants:

                      #FC_PROPORTIONAL
                      #FC_DUAL
                      #FC_MONO
                      #FC_CHARCELL

        Width     Font width. This can be one of the following constants:

                      #FC_WIDTH_ULTRACONDENSED
                      #FC_WIDTH_EXTRACONDENSED
                      #FC_WIDTH_CONDENSED
                      #FC_WIDTH_SEMICONDENSED
                      #FC_WIDTH_NORMAL
                      #FC_WIDTH_SEMIEXPANDED
                      #FC_WIDTH_EXPANDED
                      #FC_WIDTH_EXTRAEXPANDED
                      #FC_WIDTH_ULTRAEXPANDED

        File      The filename holding the font.

        Index     The index of the font within the file.

        This function returns a newly created Cairo font face. Free with
        @{"cfontface:Free()" LINK cfontfaceFree} when you are done using it.

   @{b}INPUTS@{ub}
        pattern   a Fontconfig pattern, passed either as a string or table

   @{b}RESULTS@{ub}
        font      a newly created Cairo font face

@ENDNODE

@NODE cairoFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.FontOptions -- create new font options object

   @{b}SYNOPSIS@{ub}
        handle = cairo.FontOptions()

   @{b}FUNCTION@{ub}
        Allocates a new font options object with all options initialized to
        default values.

        This function returns a newly allocated Cairo font options object. Free
        with @{"cfontoptions:Free()" LINK cfontoptionsFree}. This function always returns a valid handle;
        if memory cannot be allocated, then a special error object is returned
        where all operations on the object do nothing. You can check for this
        with @{"cfontoptions:Status()" LINK cfontoptionsStatus}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a newly allocated Cairo font options object

@ENDNODE

@NODE cairoGlyphs "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Glyphs -- create new glyphs array

   @{b}SYNOPSIS@{ub}
        handle = cairo.Glyphs(n)

   @{b}FUNCTION@{ub}
        Allocates a new glyphs array that has enough room for storing "n"
        glyphs. You can then set and get the individual glyph at a specific
        index by using the @{"cglyphs:Get()" LINK cglyphsGet} and @{"cglyphs:Set()" LINK cglyphsSet} functions. By
        default, all glyph IDs and offsets in the object will be set to 0.

        A font is (in simple terms) a collection of shapes used to draw text. A
        glyph is one of these shapes. There can be multiple glyphs for a single
        character (alternates to be used in different contexts, for example), or
        a glyph can be a ligature of multiple characters. Cairo doesn't expose
        any way of converting input text into glyphs, so in order to use the
        Cairo interfaces that take arrays of glyphs, you must directly access
        the appropriate underlying font system.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a newly allocated Cairo glyphs array

@ENDNODE

@NODE cairoImageSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.ImageSurface -- create image surface

   @{b}SYNOPSIS@{ub}
        handle = cairo.ImageSurface(format, width, height)

   @{b}FUNCTION@{ub}
        Creates an image surface of the specified format and dimensions.
        Initially the surface contents are set to 0. (Specifically, within each
        pixel, each color or alpha channel belonging to format will be 0. The
        contents of bits within a pixel, but not belonging to the given format
        are undefined).

        The "format" argument can be one of the following pixel formats:

        #CAIRO_FORMAT_ARGB32
                  Each pixel is a 32-bit quantity, with alpha in the upper 8
                  bits, then red, then green, then blue. The 32-bit quantities
                  are stored native-endian. Pre-multiplied alpha is used. (That
                  is, 50% transparent red is $80800000, not $80ff0000.)

        #CAIRO_FORMAT_RGB24
                  Each pixel is a 32-bit quantity, with the upper 8 bits unused.
                  Red, green, and blue are stored in the remaining 24 bits in
                  that order.

        #CAIRO_FORMAT_A8
                  Each pixel is a 8-bit quantity holding an alpha value.

        #CAIRO_FORMAT_A1
                  Each pixel is a 1-bit quantity holding an alpha value. Pixels
                  are packed together into 32-bit quantities. The ordering of
                  the bits matches the endianness of the platform. On a
                  big-endian machine, the first pixel is in the uppermost bit,
                  on a little-endian machine the first pixel is in the
                  least-significant bit.

        #CAIRO_FORMAT_RGB16_565
                  Each pixel is a 16-bit quantity with red in the upper 5 bits,
                  then green in the middle 6 bits, and blue in the lower 5 bits.

        #CAIRO_FORMAT_RGB30
                  Like RGB24 but with 10bpc.

        This function returns a handle to the newly created surface. The caller
        owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if an error such as out of memory occurs. You can use
        @{"csurface:Status()" LINK csurfaceStatus} to check for this.

   @{b}INPUTS@{ub}
        format    format of pixels in the surface to create (see above)
        width     width of the surface, in pixels
        height    height of the surface, in pixels

   @{b}RESULTS@{ub}
        handle    image surface

@ENDNODE

@NODE cairoPath "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Path -- construct new path

   @{b}SYNOPSIS@{ub}
        p = cairo.Path(table)

   @{b}FUNCTION@{ub}
        Constructs a new Cairo path from a table source. The table can contain a
        number of subtables describing a path item each. Each subtable inside
        "table" must contain a "Type" field that specifies the path item type of
        the subtable. Additional subtable items that must be initialized depend
        on the item type set in the "Type" field.

        The following items are recognized for each subtable within "table":

        Type      Describes the type of path item. This can be one of the
                  following types:

                  #CAIRO_PATH_MOVE_TO
                            A move-to operation. You must set the fields "x1"
                            and "y1" as well.

                  #CAIRO_PATH_LINE_TO
                            A line-to operation. You must set the fields "x1"
                            and "y1" as well.

                  #CAIRO_PATH_CURVE_TO
                            A curve-to operation. You must set the fields "x1",
                            "y1", "x2", "y2", "x3" and "y3" as well.

                  #CAIRO_PATH_CLOSE_PATH
                            A close-path operation. No additional fields need to
                            be set.

        x1, y1    Control points needed by #CAIRO_PATH_MOVE_TO,
                  #CAIRO_PATH_LINE_TO, and #CAIRO_PATH_CURVE_TO.

        x2, y2, x3, y3
                  Additional control points, only needed by
                  #CAIRO_PATH_CURVE_TO.

   @{b}INPUTS@{ub}
        table     table describing the path

   @{b}RESULTS@{ub}
        p         a newly allocated Cairo path

@ENDNODE

@NODE cairoScaledFont "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.ScaledFont -- create scaled font

   @{b}SYNOPSIS@{ub}
        font = cairo.ScaledFont(font_face, font_matrix, ctm, options)

   @{b}FUNCTION@{ub}
        Creates a Cairo scaled font object from a font face and matrices that
        describe the size of the font and the environment in which it will be
        used. The "options" argument must be a Cairo font options handle created
        with @{"cairo.FontOptions()" LINK cairoFontOptions} or @{"cfontoptions:Copy()" LINK cfontoptionsCopy} The "font_matrix" and
        "ctm" arguments must be Cairo matrices.

        In the simplest case of a "N" point font, "font_matrix" is just a scale
        by "N", but it can also be used to shear the font or stretch it
        unequally along the two axes.

        This function returns a newly created Cairo scaled font. Destroy with
        @{"cscaledfont:Free()" LINK cscaledfontFree}

   @{b}INPUTS@{ub}
        font_face a Cairo font face
        font_matrix
                  font space to user space transformation matrix for the font
        ctm       user to device transformation matrix with which the font will
                  be used
        options   options to use when getting metrics for the font and rendering
                  with it

   @{b}RESULTS@{ub}
        font      a newly created Cairo scaled font

@ENDNODE

@NODE cairoImageSurfaceFromBrush "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.ImageSurfaceFromBrush -- create image surface from Hollywood brush

   @{b}SYNOPSIS@{ub}
        handle = cairo.ImageSurfaceFromBrush(id)

   @{b}FUNCTION@{ub}
        Creates an image surface from the Hollywood brush specified by "id". If
        the brush has transparent areas, the image surface will use
        #CAIRO_FORMAT_ARGB32, otherwise it will use the #CAIRO_FORMAT_RGB24
        pixel format.

        This function returns a handle to the newly created surface. The caller
        owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with it.

   @{b}INPUTS@{ub}
        id        Hollywood brush to convert to an image surface

   @{b}RESULTS@{ub}
        handle    image surface

@ENDNODE

@NODE cairoMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Matrix -- create matrix

   @{b}SYNOPSIS@{ub}
        m = cairo.Matrix([xx, yx, xy, yy, x0, y0])

   @{b}FUNCTION@{ub}
        Creates a matrix and optionally initializes its affine transformation to
        the coefficients specified by "xx", "yx", "xy", "yy", "x0", "y0".
        Omitted coefficients will be set to 0.

   @{b}INPUTS@{ub}
        xx        optional: xx component of the affine transformation (defaults
                  to 0)
        yx        optional: yx component of the affine transformation (defaults
                  to 0)
        xy        optional: xy component of the affine transformation (defaults
                  to 0)
        yy        optional: yy component of the affine transformation (defaults
                  to 0)
        x0        optional: X translation component of the affine transformation
                  (defaults to 0)
        y0        optional: Y translation component of the affine transformation
                  (defaults to 0)

   @{b}RESULTS@{ub}
        m         matrix object

@ENDNODE

@NODE cairoMatrixIdentity "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.MatrixIdentity -- create identity matrix

   @{b}SYNOPSIS@{ub}
        m = cairo.MatrixIdentity()

   @{b}FUNCTION@{ub}
        Creates a matrix and initializes its affine transformation to an
        identity transformation.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         identity matrix object

@ENDNODE

@NODE cairoPatternForSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternForSurface -- create pattern for surface

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternForSurface(surface)

   @{b}FUNCTION@{ub}
        Create a new Cairo pattern for the given surface.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        surface   the surface

   @{b}RESULTS@{ub}
        pat       the newly created Cairo pattern

@ENDNODE

@NODE cairoPatternLinear "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternLinear -- create linear pattern

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternLinear(x0, y0, x1, y1)

   @{b}FUNCTION@{ub}
        Create a new linear gradient Cairo pattern along the line defined by
        (x0, y0) and (x1, y1). Before using the gradient pattern, a number of
        color stops should be defined using @{"cpattern:AddColorStopRGB()" LINK cpatternAddColorStopRGB} or
        @{"cpattern:AddColorStopRGBA()" LINK cpatternAddColorStopRGBA}.

        Note: The coordinates here are in pattern space. For a new pattern,
        pattern space is identical to user space, but the relationship between
        the spaces can be changed with @{"cpattern:SetMatrix()" LINK cpatternSetMatrix}.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        x0        x coordinate of the start point
        y0        y coordinate of the start point
        x1        x coordinate of the end point
        y1        y coordinate of the end point

   @{b}RESULTS@{ub}
        pat       the newly created Cairo pattern

@ENDNODE

@NODE cairoPatternMesh "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternMesh -- create mesh pattern

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternMesh()

   @{b}FUNCTION@{ub}
        Create a new mesh pattern.

        Mesh patterns are tensor-product patch meshes (type 7 shadings in PDF).
        Mesh patterns may also be used to create other types of shadings that
        are special cases of tensor-product patch meshes such as Coons patch
        meshes (type 6 shading in PDF) and Gouraud-shaded triangle meshes (type
        4 and 5 shadings in PDF).

        Mesh patterns consist of one or more tensor-product patches, which
        should be defined before using the mesh pattern. Using a mesh pattern
        with a partially defined patch as source or mask will put the context in
        an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

        A tensor-product patch is defined by 4 Bezier curves (side 0, 1, 2, 3)
        and by 4 additional control points (P0, P1, P2, P3) that provide further
        control over the patch and complete the definition of the tensor-product
        patch. The corner C0 is the first point of the patch.

        Degenerate sides are permitted so straight lines may be used. A zero
        length line on one side may be used to create 3 sided patches.

                  C1     Side 1       C2
                   +---------------+
                   |               |
                   |  P1       P2  |
                   |               |
            Side 0 |               | Side 2
                   |               |
                   |               |
                   |  P0       P3  |
                   |               |
                   +---------------+
                 C0     Side 3        C3

        Each patch is constructed by first calling @{"cpattern:BeginPatch()" LINK cpatternBeginPatch}, then
        @{"cpattern:MoveTo()" LINK cpatternMoveTo} to specify the first point in the patch (C0). Then the
        sides are specified with calls to @{"cpattern:CurveTo()" LINK cpatternCurveTo} and
        @{"cpattern:LineTo()" LINK cpatternLineTo}.

        The four additional control points (P0, P1, P2, P3) in a patch can be
        specified with @{"cpattern:SetControlPoint()" LINK cpatternSetControlPoint}.

        At each corner of the patch (C0, C1, C2, C3) a color may be specified
        with @{"cpattern:SetCornerColorRGB()" LINK cpatternSetCornerColorRGB} or @{"cpattern:SetCornerColorRGBA()" LINK cpatternSetCornerColorRGBA}. Any
        corner whose color is not explicitly specified defaults to transparent
        black.

        A Coons patch is a special case of the tensor-product patch where the
        control points are implicitly defined by the sides of the patch. The
        default value for any control point not specified is the implicit value
        for a Coons patch, i.e. if no control points are specified the patch is
        a Coons patch.

        A triangle is a special case of the tensor-product patch where the
        control points are implicitly defined by the sides of the patch, all the
        sides are lines and one of them has length 0, i.e. if the patch is
        specified using just 3 lines, it is a triangle. If the corners connected
        by the 0-length side have the same color, the patch is a Gouraud-shaded
        triangle.

        Patches may be oriented differently to the above diagram. For example
        the first point could be at the top left. The diagram only shows the
        relationship between the sides, corners and control points. Regardless
        of where the first point is located, when specifying colors, corner 0
        will always be the first point, corner 1 the point between side 0 and
        side 1 etc.

        Calling @{"cpattern:EndPatch()" LINK cpatternEndPatch} completes the current patch. If less than 4
        sides have been defined, the first missing side is defined as a line
        from the current point to the first point of the patch (C0) and the
        other sides are degenerate lines from C0 to C0. The corners between the
        added sides will all be coincident with C0 of the patch and their color
        will be set to be the same as the color of C0.

        Additional patches may be added with additional calls to
        @{"cpattern:BeginPatch()" LINK cpatternBeginPatch} / @{"cpattern:EndPatch()" LINK cpatternEndPatch}.

            pat = cairo.PatternMesh()

            ; Add a Coons patch
            pat:BeginPatch()
            pat:MoveTo(0, 0)
            pat:CurveTo(30, -30, 60, 30, 100, 0)
            pat:CurveTo(60, 30, 130, 60, 100, 100)
            pat:CurveTo(60, 70, 30, 130,  0, 100)
            pat:CurveTo(30, 70, -30, 30,  0, 0)
            pat:SetCornerColorRGB(0, 1, 0, 0)
            pat:SetCornerColorRGB(1, 0, 1, 0)
            pat:SetCornerColorRGB(2, 0, 0, 1)
            pat:SetCornerColorRGB(3, 1, 1, 0)
            pat:EndPatch()

             Add a Gouraud-shaded triangle
            pat:BeginPatch()
            pat:MoveTo(100, 100)
            pat:LineTo(130, 130)
            pat:LineTo(130, 70)
            pat:SetCornerColorRGB(0, 1, 0, 0)
            pat:SetCornerColorRGB(1, 0, 1, 0)
            pat:SetCornerColorRGB(2, 0, 0, 1)
            pat:EndPatch()

        When two patches overlap, the last one that has been added is drawn over
        the first one.

        When a patch folds over itself, points are sorted depending on their
        parameter coordinates inside the patch. The v coordinate ranges from 0
        to 1 when moving from side 3 to side 1; the u coordinate ranges from 0
        to 1 when going from side 0 to side 2. Points with higher v coordinate
        hide points with lower v coordinate. When two points have the same v
        coordinate, the one with higher u coordinate is above. This means that
        points nearer to side 1 are above points nearer to side 3; when this is
        not sufficient to decide which point is above (for example when both
        points belong to side 1 or side 3) points nearer to side 2 are above
        points nearer to side 0.

        For a complete definition of tensor-product patches, see the PDF
        specification (ISO32000), which describes the parametrization in detail.

        Note: The coordinates are always in pattern space. For a new pattern,
        pattern space is identical to user space, but the relationship between
        the spaces can be changed with @{"cpattern:SetMatrix()" LINK cpatternSetMatrix}.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        pat       the newly created Cairo pattern

@ENDNODE

@NODE cairoPatternRadial "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternRadial -- create radial pattern

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternRadial(cx0, cy0, radius0, cx1, cy1, radius1)

   @{b}FUNCTION@{ub}
        Creates a new radial gradient Cairo pattern between the two circles
        defined by (cx0, cy0, radius0) and (cx1, cy1, radius1). Before using the
        gradient pattern, a number of color stops should be defined using
        @{"cpattern:AddColorStopRGB()" LINK cpatternAddColorStopRGB} or @{"cpattern:AddColorStopRGBA()" LINK cpatternAddColorStopRGBA}.

        Note: The coordinates here are in pattern space. For a new pattern,
        pattern space is identical to user space, but the relationship between
        the spaces can be changed with @{"cpattern:SetMatrix()" LINK cpatternSetMatrix}.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        cx0       x coordinate for the center of the start circle
        cy0       y coordinate for the center of the start circle
        radius0   radius of the start circle
        cx1       x coordinate for the center of the end circle
        cy1       y coordinate for the center of the end circle
        radius1   radius of the end circle

   @{b}RESULTS@{ub}
        x         the newly created Cairo pattern

@ENDNODE

@NODE cairoPatternRGB "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternRGB -- create RGB pattern

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternRGB(red, green, blue)

   @{b}FUNCTION@{ub}
        Creates a new Cairo pattern corresponding to an opaque color. The color
        components are floating point numbers in the range 0 to 1. If the values
        passed in are outside that range, they will be clamped.

        The color is specified in the same way as in @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB}.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        red       red component of the color
        green     green component of the color
        blue      blue component of the color

   @{b}RESULTS@{ub}
        pat       the newly created Cairo pattern

@ENDNODE

@NODE cairoPatternRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PatternRGBA -- create RGBA pattern

   @{b}SYNOPSIS@{ub}
        pat = cairo.PatternRGBA(red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        Creates a new Cairo pattern corresponding to a translucent color. The
        color components are floating point numbers in the range 0 to 1. If the
        values passed in are outside that range, they will be clamped.

        The color is specified in the same way as in @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB}.

        This function returns the newly created Cairo pattern if successful, or
        an error pattern in case of no memory. The caller owns the returned
        object and should call @{"cpattern:Free()" LINK cpatternFree} when finished with it.

        This function will always return a valid handle, but if an error
        occurred the pattern status will be set to an error. To inspect the
        status of a pattern use @{"cpattern:Status()" LINK cpatternStatus}.

   @{b}INPUTS@{ub}
        red       red component of the color
        green     green component of the color
        blue      blue component of the color
        alpha     alpha component of the color

   @{b}RESULTS@{ub}
        pat       the newly created Cairo pattern

@ENDNODE

@NODE cairoPDFSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PDFSurface -- create PDF surface

   @{b}SYNOPSIS@{ub}
        handle = cairo.PDFSurface(filename$, width_in_points, height_in_points)

   @{b}FUNCTION@{ub}
        Creates a PDF surface of the specified size in points to be written to
        "filename$".

        This function returns a handle to the newly created surface. The caller
        owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if an error such as out of memory occurs. You can use
        @{"csurface:Status()" LINK csurfaceStatus} to check for this.

   @{b}INPUTS@{ub}
        filename$ a filename for the PDF output (must be writable)
        width_in_points
                  width of the surface, in points (1 point == 1/72.0 inch)
        height_in_points
                  height of the surface, in points (1 point == 1/72.0 inch)

   @{b}RESULTS@{ub}
        handle    PDF surface

@ENDNODE

@NODE cairoPDFVersionToString "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.PDFVersionToString -- get string from PDF version

   @{b}SYNOPSIS@{ub}
        s$ = cairo.PDFVersionToString(version)

   @{b}FUNCTION@{ub}
        Get the string representation of the given "version" id. This function
        will return Nil if "version" isn't valid. "version" can be one of the
        following constants:

            #CAIRO_PDF_VERSION_1_4
            #CAIRO_PDF_VERSION_1_5

        This function returns the string associated to the given version.

   @{b}INPUTS@{ub}
        version   a version id

   @{b}RESULTS@{ub}
        s$        string representation of given version

@ENDNODE

@NODE cairoRegion "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Region -- create region

   @{b}SYNOPSIS@{ub}
        reg = cairo.Region([rects])

   @{b}FUNCTION@{ub}
        Allocates a new region object and optionally initializes it to the union
        of all given "rects". If specified, the "rects" parameter must be a
        table containing an arbitrary number of subtables describing a rectangle
        each. The subtables need to have the fields "x", "y", "width", "height"
        initialized. If the "rects" parameter is omitted, an empty region will
        be created.

        This function returns a newly allocated Cairo region. Free with
        @{"cregion:Free()" LINK cregionFree}. This function always returns a valid handle; if memory
        cannot be allocated, then a special error object is returned where all
        operations on the object do nothing. You can check for this with
        @{"cregion:Status()" LINK cregionStatus}.

   @{b}INPUTS@{ub}
        rects     optional: table of rectangles to initialize the region with

   @{b}RESULTS@{ub}
        reg       a newly allocated Cairo region

@ENDNODE

@NODE cairoStatusToString "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.StatusToString -- get string from status code

   @{b}SYNOPSIS@{ub}
        s$ = cairo.StatusToString(status)

   @{b}FUNCTION@{ub}
        Provides a human-readable description of the status code specified by
        "status". See @{"ccontext:Status()" LINK ccontextStatus} for a list of status codes.

   @{b}INPUTS@{ub}
        status    a Cairo status code

   @{b}RESULTS@{ub}
        s$        string representation of status code

@ENDNODE

@NODE cairoSVGSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.SVGSurface -- create SVG surface

   @{b}SYNOPSIS@{ub}
        handle = cairo.SVGSurface(filename$, width_in_points, height_in_points)

   @{b}FUNCTION@{ub}
        Creates a SVG surface of the specified size in points to be written to
        "filename$".

        The SVG surface backend recognizes the following MIME types for the data
        attached to a surface (see @{"csurface:SetMimeData()" LINK csurfaceSetMimeData}) when it is used as a
        source pattern for drawing on this surface: #CAIRO_MIME_TYPE_JPEG,
        #CAIRO_MIME_TYPE_PNG, #CAIRO_MIME_TYPE_URI. If any of them is specified,
        the SVG backend emits a href with the content of MIME data instead of a
        surface snapshot (PNG, Base64-encoded) in the corresponding image tag.

        The unofficial MIME type #CAIRO_MIME_TYPE_URI is examined first. If
        present, the URI is emitted as is: assuring the correctness of URI is
        left to the client code.

        If #CAIRO_MIME_TYPE_URI is not present, but #CAIRO_MIME_TYPE_JPEG or
        #CAIRO_MIME_TYPE_PNG is specified, the corresponding data is
        Base64-encoded and emitted.

        If #CAIRO_MIME_TYPE_UNIQUE_ID is present, all surfaces with the same
        unique identifier will only be embedded once.

        This function returns a handle to the newly created surface. The caller
        owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if an error such as out of memory occurs. You can use
        @{"csurface:Status()" LINK csurfaceStatus} to check for this.

   @{b}INPUTS@{ub}
        filename$ a filename for the SVG output (must be writable)
        width_in_points
                  width of the surface, in points (1 point == 1/72.0 inch)
        height_in_points
                  height of the surface, in points (1 point == 1/72.0 inch)

   @{b}RESULTS@{ub}
        handle    SVG surface

@ENDNODE

@NODE cairoSVGVersionToString "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.SVGVersionToString -- get string from SVG version

   @{b}SYNOPSIS@{ub}
        s$ = cairo.SVGVersionToString(version)

   @{b}FUNCTION@{ub}
        Get the string representation of the given "version" id. This function
        will return Nil if "version" isn't valid. "version" can be one of the
        following constants:

            #CAIRO_SVG_VERSION_1_1
            #CAIRO_SVG_VERSION_1_2

        This function returns the string associated to given version.

   @{b}INPUTS@{ub}
        version   a version id

   @{b}RESULTS@{ub}
        s$        string representation of given version

@ENDNODE

@NODE cairoToyFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.ToyFontFace -- create toy font face

   @{b}SYNOPSIS@{ub}
        font = cairo.ToyFontFace(family$, slant, weight)

   @{b}FUNCTION@{ub}
        Creates a font face from a triplet of "family$", "slant", and "weight".
        These font faces are used in implementation of the Cairo context "toy"
        font API.

        The "slant" parameter can be one of the following constants:

            #CAIRO_FONT_SLANT_NORMAL
            #CAIRO_FONT_SLANT_ITALIC
            #CAIRO_FONT_SLANT_OBLIQUE

        The "weight" parameter can be one of the following constants:

            #CAIRO_FONT_WEIGHT_NORMAL
            #CAIRO_FONT_WEIGHT_BOLD

        If "family$" is the zero-length string "", the platform-specific default
        family is assumed. The default family then can be queried using
        @{"cfontface:GetFamily()" LINK cfontfaceGetFamily}.

        The @{"ccontext:SelectFontFace()" LINK ccontextSelectFontFace} function uses this to create font faces.
        See that function for limitations and other details of toy font faces.

        This function returns a newly created Cairo font face. Free with
        @{"cfontface:Free()" LINK cfontfaceFree} when you are done using it.

   @{b}INPUTS@{ub}
        family$   a font family name
        slant     the slant for the font (see above)
        weight    the weight for the font (see above)

   @{b}RESULTS@{ub}
        font      a newly created Cairo font face

@ENDNODE

@NODE cairoVersion "Pangomonium Guide"

   @{b}NAME@{ub}
        cairo.Version -- get Cairo version

   @{b}SYNOPSIS@{ub}
        ver$ = cairo.MatrixIdentity()

   @{b}FUNCTION@{ub}
        Returns the version of the cairo library as a human-readable string of
        the form "X.Y.Z".

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ver$      Cairo version used by Pangomonium

@ENDNODE

@NODE ccontextAppendPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:AppendPath -- append path

   @{b}SYNOPSIS@{ub}
        ccontext:AppendPath(path)

   @{b}FUNCTION@{ub}
        Append the "path" onto the current path. The "path" may be either the
        return value from one of @{"ccontext:CopyPath()" LINK ccontextCopyPath} or @{"ccontext:CopyPathFlat()" LINK ccontextCopyPathFlat}
        or it may be constructed using @{"cairo.Path()" LINK cairoPath}.

   @{b}INPUTS@{ub}
        path      path to be appended

@ENDNODE

@NODE ccontextArc "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Arc -- add arc to current path

   @{b}SYNOPSIS@{ub}
        ccontext:Arc(xc, yc, radius, angle1, angle2)

   @{b}FUNCTION@{ub}
        Adds a circular arc of the given "radius" to the current path. The arc
        is centered at ("xc", "yc"), begins at "angle1" and proceeds in the
        direction of increasing angles to end at "angle2". If "angle2" is less
        than "angle1" it will be progressively increased by 2*#PI until it is
        greater than "angle1".

        If there is a current point, an initial line segment will be added to
        the path to connect the current point to the beginning of the arc. If
        this initial line is undesired, it can be avoided by calling
        @{"ccontext:NewSubPath()" LINK ccontextNewSubPath} before calling ccontext:Arc().

        Angles are measured in radians. An angle of 0.0 is in the direction of
        the positive X axis (in user space). An angle of #PI/2.0 radians (90
        degrees) is in the direction of the positive Y axis (in user space).
        Angles increase in the direction from the positive X axis toward the
        positive Y axis. So with the default transformation matrix, angles
        increase in a clockwise direction.

        To convert from degrees to radians, use degrees * #PI / 180.

        This function gives the arc in the direction of increasing angles; see
        @{"ccontext:ArcNegative()" LINK ccontextArcNegative} to get the arc in the direction of decreasing
        angles.

        The arc is circular in user space. To achieve an elliptical arc, you can
        scale the current transformation matrix by different amounts in the X
        and Y directions. For example, to draw an ellipse in the box given by
        "x", "y", "width", "height":

            ctx:Save()
            ctx:Translate(x + width / 2, y + height / 2)
            ctx:Scale(width / 2, height / 2)
            ctx:Arc(0, 0, 1, 0, 2 * #PI)
            ctx:Restore()

   @{b}INPUTS@{ub}
        xc        X position of the center of the arc
        yc        Y position of the center of the arc
        radius    the radius of the arc
        angle1    the start angle, in radians
        angle2    the end angle, in radians

@ENDNODE

@NODE ccontextArcNegative "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ArcNegative -- add arc to current path

   @{b}SYNOPSIS@{ub}
        ccontext:ArcNegative(xc, yc, radius, angle1, angle2)

   @{b}FUNCTION@{ub}
        Adds a circular arc of the given "radius" to the current path. The arc
        is centered at ("xc", "yc"), begins at "angle1" and proceeds in the
        direction of decreasing angles to end at "angle2". If "angle2" is
        greater than "angle1" it will be progressively decreased by 2*#PI until
        it is less than "angle1".

        See @{"ccontext:Arc()" LINK ccontextArc} for more details. This function differs only in the
        direction of the arc between the two angles.

   @{b}INPUTS@{ub}
        xc        X position of the center of the arc
        yc        Y position of the center of the arc
        radius    the radius of the arc
        angle1    the start angle, in radians
        angle2    the end angle, in radians

@ENDNODE

@NODE ccontextClip "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Clip -- set new clip region

   @{b}SYNOPSIS@{ub}
        ccontext:Clip()

   @{b}FUNCTION@{ub}
        Establishes a new clip region by intersecting the current clip region
        with the current path as it would be filled by @{"ccontext:Fill()" LINK ccontextFill} and
        according to the current fill rule (see @{"ccontext:SetFillRule()" LINK ccontextSetFillRule}).

        After ccontext:Clip(), the current path will be cleared from the Cairo
        context.

        The current clip region affects all drawing operations by effectively
        masking out any changes to the surface that are outside the current clip
        region.

        Calling ccontext:Clip() can only make the clip region smaller, never
        larger. But the current clip is part of the graphics state, so a
        temporary restriction of the clip region can be achieved by calling
        ccontext:Clip() within a @{"ccontext:Save()" LINK ccontextSave} / @{"ccontext:Restore()" LINK ccontextRestore} pair. The
        only other means of increasing the size of the clip region is
        @{"ccontext:ResetClip()" LINK ccontextResetClip}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextClipExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ClipExtents -- get clip extents

   @{b}SYNOPSIS@{ub}
        x1, y1, x2, y2 = ccontext:ClipExtents()

   @{b}FUNCTION@{ub}
        Computes a bounding box in user coordinates covering the area inside the
        current clip.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x1        left of the resulting extents
        y1        top of the resulting extents
        x2        right of the resulting extents
        y2        bottom of the resulting extents

@ENDNODE

@NODE ccontextClipPreserve "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ClipPreserve -- set new clip region and preserve path

   @{b}SYNOPSIS@{ub}
        ccontext:ClipPreserve()

   @{b}FUNCTION@{ub}
        Establishes a new clip region by intersecting the current clip region
        with the current path as it would be filled by @{"ccontext:Fill()" LINK ccontextFill} and
        according to the current fill rule (see @{"ccontext:SetFillRule()" LINK ccontextSetFillRule}).

        Unlike @{"ccontext:Clip()" LINK ccontextClip}, ccontext:ClipPreserve() preserves the path
        within the Cairo context.

        The current clip region affects all drawing operations by effectively
        masking out any changes to the surface that are outside the current clip
        region.

        Calling ccontext:ClipPreserve() can only make the clip region smaller,
        never larger. But the current clip is part of the graphics state, so a
        temporary restriction of the clip region can be achieved by calling
        ccontext:ClipPreserve() within a @{"ccontext:Save()" LINK ccontextSave} / @{"ccontext:Restore()" LINK ccontextRestore}
        pair. The only other means of increasing the size of the clip region is
        @{"ccontext:ResetClip()" LINK ccontextResetClip}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextClosePath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ClosePath -- close path

   @{b}SYNOPSIS@{ub}
        ccontext:ClosePath()

   @{b}FUNCTION@{ub}
        Adds a line segment to the path from the current point to the beginning
        of the current sub-path, (the most recent point passed to
        @{"ccontext:MoveTo()" LINK ccontextMoveTo}), and closes this sub-path. After this call the
        current point will be at the joined endpoint of the sub-path.

        The behavior of ccontext:ClosePath() is distinct from simply calling
        @{"ccontext:LineTo()" LINK ccontextLineTo} with the equivalent coordinate in the case of
        stroking. When a closed sub-path is stroked, there are no caps on the
        ends of the sub-path. Instead, there is a line join connecting the final
        and initial segments of the sub-path.

        If there is no current point before the call to ccontext:ClosePath(),
        this function will have no effect.

        Note: Any call to ccontext:ClosePath() will place an explicit "MOVE_TO"
        element into the path immediately after the "CLOSE_PATH" element, which
        can be seen in @{"ccontext:CopyPath()" LINK ccontextCopyPath} for example. This can simplify path
        processing in some cases as it may not be necessary to save the "last
        move_to point" during processing as the "MOVE_TO" immediately after the
        "CLOSE_PATH" will provide that point.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextCopyPage "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:CopyPage -- copy page

   @{b}SYNOPSIS@{ub}
        ccontext:CopyPage()

   @{b}FUNCTION@{ub}
        Emits the current page for backends that support multiple pages, but
        doesn't clear it, so, the contents of the current page will be retained
        for the next page too. Use @{"ccontext:ShowPage()" LINK ccontextShowPage} if you want to get an
        empty page after the emission.

        This is a convenience function that simply calls @{"csurface:CopyPage()" LINK csurfaceCopyPage} on
        the Cairo context's target.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextCopyPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:CopyPath -- copy path

   @{b}SYNOPSIS@{ub}
        handle = ccontext:CopyPath()

   @{b}FUNCTION@{ub}
        Creates a copy of the current path and returns it to the user as a Cairo
        path object. Use @{"cpath:Get()" LINK cpathGet} to get the individual path members.

        This function will always return a valid handle, but the result will
        have no data, if either of the following conditions hold:

        1. If there is insufficient memory to copy the path. In this case the
           path status will be set to #CAIRO_STATUS_NO_MEMORY.
        2. If the Cairo context is already in an error state. In this case the
           path status will contain the same status that would be returned by
           @{"ccontext:Status()" LINK ccontextStatus}.

        This function returns the copy of the current path. The caller owns the
        returned object and should call @{"cpath:Free()" LINK cpathFree} when finished with it.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the copy of the current path

@ENDNODE

@NODE ccontextCopyPathFlat "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:CopyPathFlat -- copy flattened version of path

   @{b}SYNOPSIS@{ub}
        handle = ccontext:CopyPathFlat()

   @{b}FUNCTION@{ub}
        Gets a flattened copy of the current path and returns it to the user as
        a Cairo path object. Use @{"cpath:Get()" LINK cpathGet} to get the individual path members.

        This function is like @{"ccontext:CopyPath()" LINK ccontextCopyPath} except that any curves in the
        path will be approximated with piecewise-linear approximations,
        (accurate to within the current tolerance value). That is, the result is
        guaranteed to not have any elements of type #CAIRO_PATH_CURVE_TO which
        will instead be replaced by a series of #CAIRO_PATH_LINE_TO elements.

        This function will always return a valid handle, but the result will
        have no data, if either of the following conditions hold:

        1. If there is insufficient memory to copy the path. In this case the
           path status will be set to #CAIRO_STATUS_NO_MEMORY.
        2. If the Cairo context is already in an error state. In this case the
           path status will contain the same status that would be returned by
           @{"ccontext:Status()" LINK ccontextStatus}.

        This function returns the copy of the current path. The caller owns the
        returned object and should call @{"cpath:Free()" LINK cpathFree} when finished with it.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the copy of the current path

@ENDNODE

@NODE ccontextCurveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:CurveTo -- add cubic Bezier spline to path

   @{b}SYNOPSIS@{ub}
        ccontext:CurveTo(x1, y1, x2, y2, x3, y3)

   @{b}FUNCTION@{ub}
        Adds a cubic Bezier spline to the path from the current point to
        position ("x3", "y3") in user-space coordinates, using ("x1", "y1") and
        ("x2", "y2") as the control points. After this call the current point
        will be ("x3", "y3").

        If there is no current point before the call to ccontext:CurveTo() this
        function will behave as if preceded by a call to @{"ccontext:MoveTo()" LINK ccontextMoveTo} with
        "x1" and "y1".

   @{b}INPUTS@{ub}
        x1        the X coordinate of the first control point
        y1        the Y coordinate of the first control point
        x2        the X coordinate of the second control point
        y2        the Y coordinate of the second control point
        x3        the X coordinate of the end of the curve
        y3        the Y coordinate of the end of the curve

@ENDNODE

@NODE ccontextDeviceToUser "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:DeviceToUser -- device to user

   @{b}SYNOPSIS@{ub}
        ux, uy = ccontext:DeviceToUser(dx, dy)

   @{b}FUNCTION@{ub}
        Transform a coordinate from device space to user space by multiplying
        the given point by the inverse of the current transformation matrix
        (CTM).

   @{b}INPUTS@{ub}
        dx        X value of coordinate (device space)
        dy        Y value of coordinate (device space)

   @{b}RESULTS@{ub}
        ux        X value of coordinate (user space)
        uy        Y value of coordinate (user space)

@ENDNODE

@NODE ccontextDeviceToUserDistance "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:DeviceToUserDistance -- device to user distance

   @{b}SYNOPSIS@{ub}
        ux, uy = ccontext:DeviceToUserDistance(dx, dy)

   @{b}FUNCTION@{ub}
        Transform a distance vector from device space to user space. This
        function is similar to @{"ccontext:DeviceToUser()" LINK ccontextDeviceToUser} except that the
        translation components of the inverse CTM will be ignored when
        transforming ("dx", "dy").

   @{b}INPUTS@{ub}
        dx        X component of a distance vector (device space)
        dy        Y component of a distance vector (device space)

   @{b}INPUTS@{ub}
        ux        X component of a distance vector (user space)
        uy        Y component of a distance vector (user space)

@ENDNODE

@NODE ccontextErrorUnderlinePath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ErrorUnderlinePath -- add squiggly line to path

   @{b}SYNOPSIS@{ub}
        ccontext:ErrorUnderlinePath(x, y, width, height)

   @{b}FUNCTION@{ub}
        Add a squiggly line to the current path in the specified Cairo context
        that approximately covers the given rectangle in the style of an
        underline used to indicate a spelling error.

        The width of the underline is rounded to an integer number of up/down
        segments and the resulting rectangle is centered in the original
        rectangle.

   @{b}INPUTS@{ub}
        x         the X coordinate of one corner of the rectangle
        y         the Y coordinate of one corner of the rectangle
        width     non-negative width of the rectangle
        height    non-negative height of the rectangle

@ENDNODE

@NODE ccontextFill "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Fill -- fill current path

   @{b}SYNOPSIS@{ub}
        ccontext:Fill()

   @{b}FUNCTION@{ub}
        A drawing operator that fills the current path according to the current
        fill rule. Each sub-path is implicitly closed before being filled. After
        ccontext:Fill(), the current path will be cleared from the Cairo
        context. See @{"ccontext:SetFillRule()" LINK ccontextSetFillRule} and @{"ccontext:FillPreserve()" LINK ccontextFillPreserve}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextFillExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:FillExtents -- get fill extents

   @{b}SYNOPSIS@{ub}
        x1, y1, x2, y2 = ccontext:FillExtents()

   @{b}FUNCTION@{ub}
        Computes a bounding box in user coordinates covering the area that would
        be affected (the "inked" area) by a @{"ccontext:Fill()" LINK ccontextFill} operation given the
        current path and fill parameters. If the current path is empty, returns
        an empty rectangle ((0,0), (0,0)). Surface dimensions and clipping are
        not taken into account.

        Contrast with @{"ccontext:PathExtents()" LINK ccontextPathExtents}, which is similar, but returns
        non-zero extents for some paths with no inked area, such as a simple
        line segment.

        Note that ccontext:FillExtents() must necessarily do more work to
        compute the precise inked areas in light of the fill rule, so
        @{"ccontext:PathExtents()" LINK ccontextPathExtents} may be more desirable for sake of performance if
        the non-inked path extents are desired.

        See @{"ccontext:Fill()" LINK ccontextFill}, @{"ccontext:SetFillRule()" LINK ccontextSetFillRule} and @{"ccontext:FillPreserve()" LINK ccontextFillPreserve}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x1        left of the resulting extents
        y1        top of the resulting extents
        x2        right of the resulting extents
        y2        bottom of the resulting extents

@ENDNODE

@NODE ccontextFillPreserve "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:FillPreserve -- fill and preserve path

   @{b}SYNOPSIS@{ub}
        ccontext:FillPreserve()

   @{b}FUNCTION@{ub}
        A drawing operator that fills the current path according to the current
        fill rule. Each sub-path is implicitly closed before being filled.
        Unlike @{"ccontext:Fill()" LINK ccontextFill}, ccontext:FillPreserve() preserves the path
        within the Cairo context.

        See @{"ccontext:SetFillRule()" LINK ccontextSetFillRule} and @{"ccontext:Fill()" LINK ccontextFill}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextFontExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:FontExtents -- font extents

   @{b}SYNOPSIS@{ub}
        t = ccontext:FontExtents()

   @{b}FUNCTION@{ub}
        Gets the font extents for the currently selected font. This will return
        a table that has the following elements initialized:

        Ascent    The distance that the font extends above the baseline. Note
                  that this is not always exactly equal to the maximum of the
                  extents of all the glyphs in the font, but rather is picked to
                  express the font designer's intent as to how the font should
                  align with elements above it.

        Descent   The distance that the font extends below the baseline. This
                  value is positive for typical fonts that include portions
                  below the baseline. Note that this is not always exactly equal
                  to the maximum of the extents of all the glyphs in the font,
                  but rather is picked to express the font designer's intent as
                  to how the font should align with elements below it.

        Height    The recommended vertical distance between baselines when
                  setting consecutive lines of text with the font. This is
                  greater than "Ascent" + "Descent" by a quantity known as the
                  line spacing or external leading. When space is at a premium,
                  most fonts can be set with only a distance of "Ascent" +
                  "Descent" between lines.

        MaxXAdvance
                  The maximum distance in the X direction that the origin is
                  advanced for any glyph in the font.

        MaxYAdvance
                  The maximum distance in the Y direction that the origin is
                  advanced for any glyph in the font. This will be zero for
                  normal fonts used for horizontal writing (The scripts of East
                  Asia are sometimes written vertically.)

        All values are given in the current user-space coordinate system.

        Because font metrics are in user-space coordinates, they are mostly, but
        not entirely, independent of the current transformation matrix. If you
        call @{"ccontext:Scale()" LINK ccontextScale} with coefficients of (2.0, 2.0), text will be
        drawn twice as big, but the reported text extents will not be doubled.
        They will change slightly due to hinting (so you can't assume that
        metrics are independent of the transformation matrix), but otherwise
        will remain unchanged.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing the font extents (see above)

@ENDNODE

@NODE ccontextFree "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Free -- destroy context

   @{b}SYNOPSIS@{ub}
        ccontext:Free()

   @{b}FUNCTION@{ub}
        Decreases the reference count on the Cairo context by one. If the result
        is zero, then the Cairo context and all associated resources are freed.
        See @{"ccontext:Reference()" LINK ccontextReference}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextGetAntialias "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetAntialias -- get current antialias mode

   @{b}SYNOPSIS@{ub}
        mode = ccontext:GetAntialias()

   @{b}FUNCTION@{ub}
        Gets the current shape antialiasing mode, as set by
        @{"ccontext:SetAntialias()" LINK ccontextSetAntialias}.

        See @{"ccontext:SetAntialias()" LINK ccontextSetAntialias} for a list of antialiasing modes.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mode      the current shape antialiasing mode

@ENDNODE

@NODE ccontextGetCurrentPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetCurrentPoint -- get current point

   @{b}SYNOPSIS@{ub}
        x, y = ccontext:GetCurrentPoint()

   @{b}FUNCTION@{ub}
        Gets the current point of the current path, which is conceptually the
        final point reached by the path so far.

        The current point is returned in the user-space coordinate system. If
        there is no defined current point or if the context is in an error
        status, "x" and "y" will both be set to 0.0. It is possible to check
        this in advance with @{"ccontext:HasCurrentPoint()" LINK ccontextHasCurrentPoint}.

        Most path construction functions alter the current point. See the
        following for details on how they affect the current point:
        @{"ccontext:NewPath()" LINK ccontextNewPath}, @{"ccontext:NewSubPath()" LINK ccontextNewSubPath}, @{"ccontext:AppendPath()" LINK ccontextAppendPath},
        @{"ccontext:ClosePath()" LINK ccontextClosePath}, @{"ccontext:MoveTo()" LINK ccontextMoveTo}, @{"ccontext:LineTo()" LINK ccontextLineTo},
        @{"ccontext:CurveTo()" LINK ccontextCurveTo}, @{"ccontext:RelMoveTo()" LINK ccontextRelMoveTo}, @{"ccontext:RelLineTo()" LINK ccontextRelLineTo},
        @{"ccontext:RelCurveTo()" LINK ccontextRelCurveTo}, @{"ccontext:Arc()" LINK ccontextArc}, @{"ccontext:ArcNegative()" LINK ccontextArcNegative},
        @{"ccontext:Rectangle()" LINK ccontextRectangle}, @{"ccontext:TextPath()" LINK ccontextTextPath}.

        Some functions use and alter the current point but do not otherwise
        change current path: @{"ccontext:ShowText()" LINK ccontextShowText}.

        Some functions unset the current path and as a result, current point:
        @{"ccontext:Fill()" LINK ccontextFill}, @{"ccontext:Stroke()" LINK ccontextStroke}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x         return value for X coordinate of the current point
        y         return value for Y coordinate of the current point

@ENDNODE

@NODE ccontextGetDash "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetDash -- get current dash array

   @{b}SYNOPSIS@{ub}
        dashes, offset = ccontext:GetDash()

   @{b}FUNCTION@{ub}
        Gets the current dash array.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        dashes    current dash array
        offset    current dash offset

@ENDNODE

@NODE ccontextGetDashCount "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetDashCount -- get current dash count

   @{b}SYNOPSIS@{ub}
        count = ccontext:GetDashCount()

   @{b}FUNCTION@{ub}
        This function returns the length of the dash array in the Cairo context
        or 0 if dashing is not currently in effect.

        See also @{"ccontext:SetDash()" LINK ccontextSetDash} and @{"ccontext:GetDash()" LINK ccontextGetDash}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the length of the dash array, or 0 if no dash array set

@ENDNODE

@NODE ccontextGetFillRule "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetFillRule -- get current fill rule

   @{b}SYNOPSIS@{ub}
        fillrule = ccontext:GetFillRule()

   @{b}FUNCTION@{ub}
        Gets the current fill rule, as set by @{"ccontext:SetFillRule()" LINK ccontextSetFillRule}. See
        @{"ccontext:SetFillRule()" LINK ccontextSetFillRule} for a list of fill rules.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        fillrule  the current fill rule

@ENDNODE

@NODE ccontextGetFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetFontFace -- get current font face

   @{b}SYNOPSIS@{ub}
        face = ccontext:GetFontFace()

   @{b}FUNCTION@{ub}
        Gets the current font face for a Cairo context.

        This function returns the current font face. This object is owned by
        Cairo. To keep a reference to it, you must call @{"cfontface:Reference()" LINK cfontfaceReference}.

        This function never returns Nil. If memory cannot be allocated, a
        special Nil font face object will be returned on which
        @{"cfontface:Status()" LINK cfontfaceStatus} returns #CAIRO_STATUS_NO_MEMORY. Using this Nil
        object will cause its error state to propagate to other objects it is
        passed to, for example, calling @{"ccontext:SetFontFace()" LINK ccontextSetFontFace} with a nil font
        will trigger an error that will shutdown the Cairo context object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        face      the current font face

@ENDNODE

@NODE ccontextGetFontMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetFontMatrix -- get current font matrix

   @{b}SYNOPSIS@{ub}
        m = ccontext:GetFontMatrix(matrix)

   @{b}FUNCTION@{ub}
        Returns the current font matrix as a Cairo matrix object. See
        @{"ccontext:SetFontMatrix()" LINK ccontextSetFontMatrix}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         matrix object

@ENDNODE

@NODE ccontextGetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetFontOptions -- get font options

   @{b}SYNOPSIS@{ub}
        ccontext:GetFontOptions(options)

   @{b}FUNCTION@{ub}
        Retrieves font rendering options set via @{"ccontext:SetFontOptions()" LINK ccontextSetFontOptions}.
        Note that the returned options do not include any options derived from
        the underlying surface; they are literally the options passed to
        @{"ccontext:SetFontOptions()" LINK ccontextSetFontOptions}.

   @{b}INPUTS@{ub}
        options   a Cairo font options object into which to store the retrieved
                  options; all existing values are overwritten

@ENDNODE

@NODE ccontextGetGroupTarget "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetGroupTarget -- get group target

   @{b}SYNOPSIS@{ub}
        handle = ccontext:GetGroupTarget()

   @{b}FUNCTION@{ub}
        Gets the current destination surface for the context. This is either the
        original target surface as passed to @{"cairo.Context()" LINK cairoContext} or the target
        surface for the current group as started by the most recent call to
        @{"ccontext:PushGroup()" LINK ccontextPushGroup} or @{"ccontext:PushGroupWithContent()" LINK ccontextPushGroupWithContent}.

        This function will always return a valid handle, but the result can be a
        "nil" surface if the Cairo context is already in an error state. A nil
        surface is indicated by @{"csurface:Status()" LINK csurfaceStatus} being different from
        #CAIRO_STATUS_SUCCESS.

        This function returns the target surface. This object is owned by Cairo.
        To keep a reference to it, you must call @{"csurface:Reference()" LINK csurfaceReference}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the target surface (owned by Cairo)

@ENDNODE

@NODE ccontextGetLineCap "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetLineCap -- get current line cap style

   @{b}SYNOPSIS@{ub}
        cap = ccontext:GetLineCap()

   @{b}FUNCTION@{ub}
        Gets the current line cap style, as set by @{"ccontext:SetLineCap()" LINK ccontextSetLineCap}. See
        @{"ccontext:SetLineCap()" LINK ccontextSetLineCap} for a list of line cap styles.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cap       the current line cap style

@ENDNODE

@NODE ccontextGetLineJoin "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetLineJoin -- get current line join style

   @{b}SYNOPSIS@{ub}
        join = ccontext:GetLineJoin()

   @{b}FUNCTION@{ub}
        Gets the current line join style, as set by @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin}. See
        @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin} for a list of line join styles.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        join      the current line join style

@ENDNODE

@NODE ccontextGetLineWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetLineWidth -- get current line width

   @{b}SYNOPSIS@{ub}
        width = ccontext:GetLineWidth()

   @{b}FUNCTION@{ub}
        This function returns the current line width value exactly as set by
        @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth}. Note that the value is unchanged even if the
        CTM has changed between the calls to @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth} and
        ccontext:GetLineWidth().

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the current line width

@ENDNODE

@NODE ccontextGetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetMatrix -- get current transformation matrix

   @{b}SYNOPSIS@{ub}
        m = ccontext:GetMatrix(matrix)

   @{b}FUNCTION@{ub}
        Returns the current transformation matrix (CTM) as a Cairo matrix
        object. Use @{"cmatrix:Get()" LINK cmatrixGet} to query the individual matrix coefficients.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         current transformation matrix

@ENDNODE

@NODE ccontextGetMiterLimit "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetMiterLimit -- get current miter limit

   @{b}SYNOPSIS@{ub}
        limit = ccontext:GetMiterLimit()

   @{b}FUNCTION@{ub}
        Gets the current miter limit, as set by @{"ccontext:SetMiterLimit()" LINK ccontextSetMiterLimit}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        limit     the current miter limit

@ENDNODE

@NODE ccontextGetOperator "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetOperator -- get current compositing operator

   @{b}SYNOPSIS@{ub}
        op = ccontext:GetOperator()

   @{b}FUNCTION@{ub}
        Gets the current compositing operator for a Cairo context. See
        @{"ccontext:SetOperator()" LINK ccontextSetOperator} for a list of compositing operators.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        op        the current compositing operator

@ENDNODE

@NODE ccontextGetReferenceCount "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetReferenceCount -- get reference count

   @{b}SYNOPSIS@{ub}
        count = ccontext:GetReferenceCount()

   @{b}FUNCTION@{ub}
        Returns the current reference count of the context.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the current reference count

@ENDNODE

@NODE ccontextGetScaledFont "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetScaledFont -- get current scaled font

   @{b}SYNOPSIS@{ub}
        font = ccontext:GetScaledFont()

   @{b}FUNCTION@{ub}
        Gets the current scaled font for a Cairo context.

        This function returns the current scaled font. This object is owned by
        Cairo. To keep a reference to it, you must call @{"cscaledfont:Reference()" LINK cscaledfontReference}.

        This function never returns Nil. If memory cannot be allocated, a
        special "nil" scaled font object will be returned on which
        @{"cscaledfont:Status()" LINK cscaledfontStatus} returns #CAIRO_STATUS_NO_MEMORY. Using this nil
        object will cause its error state to propagate to other objects it is
        passed to, for example, calling @{"ccontext:SetScaledFont()" LINK ccontextSetScaledFont} with a nil font
        will trigger an error that will shutdown the Cairo context object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        font      the current scaled font (owned by Cairo)

@ENDNODE

@NODE ccontextGetSource "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetSource -- get current source pattern

   @{b}SYNOPSIS@{ub}
        pat = ccontext:GetSource()

   @{b}FUNCTION@{ub}
        Gets the current source pattern for the Cairo context.

        This function returns the current source pattern. This object is owned
        by Cairo. To keep a reference to it, you must call @{"cpattern:Reference()" LINK cpatternReference}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        pat       the current source pattern (owned by Cairo)

@ENDNODE

@NODE ccontextGetTarget "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetTarget -- get target surface

   @{b}SYNOPSIS@{ub}
        surface = ccontext:GetTarget()

   @{b}FUNCTION@{ub}
        Gets the target surface for the Cairo context as passed to
        @{"cairo.Context()" LINK cairoContext}.

        This function will always return a valid handle, but the result can be a
        "nil" surface if the context is already in an error state. A nil surface
        is indicated by @{"csurface:Status()" LINK csurfaceStatus} being different to
        #CAIRO_STATUS_SUCCESS.

        This function returns the target surface. This object is owned by Cairo.
        To keep a reference to it, you must call @{"csurface:Reference()" LINK csurfaceReference}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        surface   the target surface (owned by Cairo)

@ENDNODE

@NODE ccontextGetTolerance "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GetTolerance -- get current tolerance value

   @{b}SYNOPSIS@{ub}
        t = ccontext:GetTolerance()

   @{b}FUNCTION@{ub}
        Gets the current tolerance value, as set by @{"ccontext:SetTolerance()" LINK ccontextSetTolerance}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         the current tolerance value

@ENDNODE

@NODE ccontextGlyphExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GlyphExtents -- get glyph extents

   @{b}SYNOPSIS@{ub}
        t = ccontext:GlyphExtents(glyphs[, offset, num_glyphs])

   @{b}FUNCTION@{ub}
        Gets the extents for a glyphs array. The extents describe a user-space
        rectangle that encloses the "inked" portion of the glyphs, as they would
        be drawn by @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs}. Additionally, the "XAdvance" and
        "YAdvance" values indicate the amount by which the current point would
        be advanced by @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs}.

        Note that whitespace glyphs do not contribute to the size of the
        rectangle ("Width" and "Height" fields).

        This function returns a table describing the glyph extents. See
        @{"ccontext:TextExtents()" LINK ccontextTextExtents} for a description of all table members.

   @{b}INPUTS@{ub}
        glyphs    a glyphs array
        offset    optional: offset into the array that specifies the starting
                  glyph (defaults to 0 which means first glyph)
        num_glyphs
                  optional: number of glyphs to show (defaults to -1 which means
                  all glyphs)

   @{b}RESULTS@{ub}
        t         table containing the glyphs extents

@ENDNODE

@NODE ccontextGlyphPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GlyphPath -- add glyphs to path

   @{b}SYNOPSIS@{ub}
        ccontext:GlyphPath(glyphs[, offset, num_glyphs])

   @{b}FUNCTION@{ub}
        Adds closed paths for the glyphs to the current path. The generated path
        if filled, achieves an effect similar to that of @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs}.

   @{b}INPUTS@{ub}
        glyphs    a glyphs array
        offset    optional: offset into the array that specifies the starting
                  glyph (defaults to 0 which means first glyph)
        num_glyphs
                  optional: number of glyphs to show (defaults to -1 which means
                  all glyphs)

@ENDNODE

@NODE ccontextGlyphStringPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:GlyphStringPath -- add glyphs to path

   @{b}SYNOPSIS@{ub}
        ccontext:GlyphStringPath(font, glyphs)

   @{b}FUNCTION@{ub}
        Adds the glyphs in "glyphs" to the current path in the specified Cairo
        context.

        The origin of the glyphs (the left edge of the baseline) will be at the
        current point of the Cairo context.

   @{b}INPUTS@{ub}
        font      a Pango font object
        glyphs    a Pango glyph string object

@ENDNODE

@NODE ccontextHasCurrentPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:HasCurrentPoint -- has current point

   @{b}SYNOPSIS@{ub}
        ok = ccontext:HasCurrentPoint()

   @{b}FUNCTION@{ub}
        Returns whether a current point is defined on the current path. See
        @{"ccontext:GetCurrentPoint()" LINK ccontextGetCurrentPoint} for details on the current point.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        whether a current point is defined

@ENDNODE

@NODE ccontextIdentityMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:IdentityMatrix -- reset current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:IdentityMatrix()

   @{b}FUNCTION@{ub}
        Resets the current transformation matrix (CTM) by setting it equal to
        the identity matrix. That is, the user-space and device-space axes will
        be aligned and one user-space unit will transform to one device-space
        unit.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextInClip "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:InClip -- check if point is inside clip area

   @{b}SYNOPSIS@{ub}
        ok = ccontext:InClip(x, y)

   @{b}FUNCTION@{ub}
        Tests whether the given point is inside the area that would be visible
        through the current clip, i.e. the area that would be filled by a
        @{"ccontext:Paint()" LINK ccontextPaint} operation.

        See @{"ccontext:Clip()" LINK ccontextClip} and @{"ccontext:ClipPreserve()" LINK ccontextClipPreserve}.

        This function returns a non-zero value if the point is inside, or zero
        if outside.

   @{b}INPUTS@{ub}
        x         X coordinate of the point to test
        y         Y coordinate of the point to test

   @{b}RESULTS@{ub}
        ok        a non-zero value if the point is inside, or zero if outside

@ENDNODE

@NODE ccontextInFill "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:InFill -- check if point is inside fill area

   @{b}SYNOPSIS@{ub}
        ok = ccontext:InFill(x, y)

   @{b}FUNCTION@{ub}
        Tests whether the given point is inside the area that would be affected
        by a @{"ccontext:Fill()" LINK ccontextFill} operation given the current path and filling
        parameters. Surface dimensions and clipping are not taken into account.

        See @{"ccontext:Fill()" LINK ccontextFill}, @{"ccontext:SetFillRule()" LINK ccontextSetFillRule} and @{"ccontext:FillPreserve()" LINK ccontextFillPreserve}.

        This function returns a non-zero value if the point is inside, or zero
        if outside.

   @{b}INPUTS@{ub}
        x         X coordinate of the point to test
        y         Y coordinate of the point to test

   @{b}RESULTS@{ub}
        ok        a non-zero value if the point is inside, or zero if outside

@ENDNODE

@NODE ccontextInStroke "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:InStroke -- check if point is inside stroke area

   @{b}SYNOPSIS@{ub}
        ok = ccontext:InStroke(x, y)

   @{b}FUNCTION@{ub}
        Tests whether the given point is inside the area that would be affected
        by a @{"ccontext:Stroke()" LINK ccontextStroke} operation given the current path and stroking
        parameters. Surface dimensions and clipping are not taken into account.

        See @{"ccontext:Stroke()" LINK ccontextStroke}, @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth}, @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin},
        @{"ccontext:SetLineCap()" LINK ccontextSetLineCap}, @{"ccontext:SetDash()" LINK ccontextSetDash}, and
        @{"ccontext:StrokePreserve()" LINK ccontextStrokePreserve}.

        This function returns a non-zero value if the point is inside, or zero
        if outside.

   @{b}INPUTS@{ub}
        x         X coordinate of the point to test
        y         Y coordinate of the point to test

   @{b}RESULTS@{ub}
        ok        a non-zero value if the point is inside, or zero if outside

@ENDNODE

@NODE ccontextIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:IsNull -- check if context is invalid

   @{b}SYNOPSIS@{ub}
        bool = ccontext:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the context is NULL, i.e. invalid. If functions that
        allocate contexts fail, they might not throw an error but simply set the
        context to NULL. You can use this function to check if context
        allocation has failed in which case the context will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the context is NULL, otherwise FALSE

@ENDNODE

@NODE ccontextLayoutLinePath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:LayoutLinePath -- add text from layout line

   @{b}SYNOPSIS@{ub}
        ccontext:LayoutLinePath(line)

   @{b}FUNCTION@{ub}
        Adds the text from the Pango layout line specified by "line" to the
        current path in the specified Cairo context.

        The origin of the glyphs (the left edge of the line) will be at the
        current point of the Cairo context.

   @{b}INPUTS@{ub}
        line      a Pango layout line object

@ENDNODE

@NODE ccontextLayoutPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:LayoutPath -- add text from layout

   @{b}SYNOPSIS@{ub}
        ccontext:LayoutPath(layout)

   @{b}FUNCTION@{ub}
        Adds the text from the Pango layout specified by "layout" to the current
        path in the specified Cairo context.

        The top-left corner of the Pango layout will be at the current point of
        the Cairo context.

   @{b}INPUTS@{ub}
        layout    a Pango layout object

@ENDNODE

@NODE ccontextLineTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:LineTo -- add line to path

   @{b}SYNOPSIS@{ub}
        ccontext:LineTo(x, y)

   @{b}FUNCTION@{ub}
        Adds a line to the path from the current point to position ("x", "y") in
        user-space coordinates. After this call the current point will be ("x",
        "y").

        If there is no current point before the call to ccontext:LineTo() this
        function will behave as @{"ccontext:MoveTo()" LINK ccontextMoveTo} with "x" and "y" as the
        parameters.

   @{b}INPUTS@{ub}
        x         the X coordinate of the end of the new line
        y         the Y coordinate of the end of the new line

@ENDNODE

@NODE ccontextMask "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Mask -- paint source with mask

   @{b}SYNOPSIS@{ub}
        ccontext:Mask(pattern)

   @{b}FUNCTION@{ub}
        A drawing operator that paints the current source using the alpha
        channel of "pattern" as a mask. Opaque areas of "pattern" are painted
        with the source, transparent areas are not painted.

   @{b}INPUTS@{ub}
        pattern   a Cairo pattern object

@ENDNODE

@NODE ccontextMaskSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:MaskSurface -- paint source with surface mask

   @{b}SYNOPSIS@{ub}
        ccontext:MaskSurface(surface, surface_x, surface_y)

   @{b}FUNCTION@{ub}
        A drawing operator that paints the current source using the alpha
        channel of "surface" as a mask. Opaque areas of "surface" are painted
        with the source, transparent areas are not painted.

   @{b}INPUTS@{ub}
        surface   a Cairo surface object
        surface_x X coordinate at which to place the origin of "surface"
        surface_y Y coordinate at which to place the origin of "surface"

@ENDNODE

@NODE ccontextMoveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:MoveTo -- begin new sub-path

   @{b}SYNOPSIS@{ub}
        ccontext:MoveTo(x, y)

   @{b}FUNCTION@{ub}
        Begin a new sub-path. After this call the current point will be ("x",
        "y").

   @{b}INPUTS@{ub}
        x         the X coordinate of the new position
        y         the Y coordinate of the new position

@ENDNODE

@NODE ccontextNewPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:NewPath -- clear current path

   @{b}SYNOPSIS@{ub}
        ccontext:NewPath()

   @{b}FUNCTION@{ub}
        Clears the current path. After this call there will be no path and no
        current point.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextNewSubPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:NewSubPath -- begin new sub-path

   @{b}SYNOPSIS@{ub}
        ccontext:NewSubPath()

   @{b}FUNCTION@{ub}
        Begin a new sub-path. Note that the existing path is not affected. After
        this call there will be no current point.

        In many cases, this call is not needed since new sub-paths are
        frequently started with @{"ccontext:MoveTo()" LINK ccontextMoveTo}.

        A call to ccontext:NewSubPath() is particularly useful when beginning a
        new sub-path with one of the @{"ccontext:Arc()" LINK ccontextArc} calls. This makes things
        easier as it is no longer necessary to manually compute the arc's
        initial coordinates for a call to @{"ccontext:MoveTo()" LINK ccontextMoveTo}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextPaint "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Paint -- paint current source

   @{b}SYNOPSIS@{ub}
        ccontext:Paint()

   @{b}FUNCTION@{ub}
        A drawing operator that paints the current source everywhere within the
        current clip region.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextPaintWithAlpha "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PaintWithAlpha -- paint current source with alpha

   @{b}SYNOPSIS@{ub}
        ccontext:PaintWithAlpha(alpha)

   @{b}FUNCTION@{ub}
        A drawing operator that paints the current source everywhere within the
        current clip region using a mask of constant alpha value "alpha". The
        effect is similar to @{"ccontext:Paint()" LINK ccontextPaint}, but the drawing is faded out
        using the alpha value.

   @{b}INPUTS@{ub}
        alpha     alpha value, between 0 (transparent) and 1 (opaque)

@ENDNODE

@NODE ccontextPangoContext "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PangoContext -- create Pango context

   @{b}SYNOPSIS@{ub}
        handle = ccontext:PangoContext()

   @{b}FUNCTION@{ub}
        Creates a Pango context set up to match the current transformation and
        target surface of the Cairo context.

        This context can then be used to create a layout using @{"pango.Layout()" LINK pangoLayout}.

        This function is a convenience function that creates a Pango context
        using the default font map, then updates it to the Cairo context. If you
        just need to create a layout for use with the Cairo context and do not
        need to access Pango context directly, you can use
        @{"ccontext:PangoLayout()" LINK ccontextPangoLayout} instead.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly created Pango context

@ENDNODE

@NODE ccontextPangoLayout "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PangoLayout -- create Pango layout

   @{b}SYNOPSIS@{ub}
        handle = ccontext:PangoLayout()

   @{b}FUNCTION@{ub}
        Creates a Pango layout set up to match the current transformation and
        target surface of the Cairo context.

        This layout can then be used for text measurement with functions like
        @{"playout:GetSize()" LINK playoutGetSize} or drawing with functions like @{"ccontext:ShowLayout()" LINK ccontextShowLayout}.
        If you change the transformation or target surface for the Cairo
        context, you need to call @{"ccontext:UpdateLayout()" LINK ccontextUpdateLayout}.

        This function is the most convenient way to use Cairo with Pango,
        however it is slightly inefficient since it creates a separate Pango
        context object for each layout. This might matter in an application that
        was laying out large amounts of text.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly created Pango layout

@ENDNODE

@NODE ccontextPathExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PathExtents -- get path extents

   @{b}SYNOPSIS@{ub}
        x1, y1, x2, y2 = ccontext:PathExtents()

   @{b}FUNCTION@{ub}
        Computes a bounding box in user-space coordinates covering the points on
        the current path. If the current path is empty, returns an empty
        rectangle ((0,0), (0,0)). Stroke parameters, fill rule, surface
        dimensions and clipping are not taken into account.

        Contrast with @{"ccontext:FillExtents()" LINK ccontextFillExtents} and @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents} which
        return the extents of only the area that would be "inked" by the
        corresponding drawing operations.

        The result of ccontext:PathExtents() is defined as equivalent to the
        limit of @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents} with #CAIRO_LINE_CAP_ROUND as the line
        width approaches 0.0 (but never reaching the empty-rectangle returned by
        @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents} for a line width of 0.0).

        Specifically, this means that zero-area sub-paths such as
        @{"ccontext:MoveTo()" LINK ccontextMoveTo} @{"ccontext:LineTo()" LINK ccontextLineTo}; segments, (even degenerate cases
        where the coordinates to both calls are identical), will be considered
        as contributing to the extents. However, a lone @{"ccontext:MoveTo()" LINK ccontextMoveTo} will
        not contribute to the results of ccontext:PathExtents().

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x1        left of the resulting extents
        y1        top of the resulting extents
        x2        right of the resulting extents
        y2        bottom of the resulting extents

@ENDNODE

@NODE ccontextPopGroup "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PopGroup -- pop group

   @{b}SYNOPSIS@{ub}
        pat = ccontext:PopGroup()

   @{b}FUNCTION@{ub}
        Terminates the redirection begun by a call to @{"ccontext:PushGroup()" LINK ccontextPushGroup} or
        @{"ccontext:PushGroupWithContent()" LINK ccontextPushGroupWithContent} and returns a new pattern containing the
        results of all drawing operations performed to the group.

        The ccontext:PopGroup() function calls @{"ccontext:Restore()" LINK ccontextRestore}, (balancing a
        call to @{"ccontext:Save()" LINK ccontextSave} by the push_group function), so that any changes
        to the graphics state will not be visible outside the group.

        This function returns a newly created (surface) pattern containing the
        results of all drawing operations performed to the group. The caller
        owns the returned object and should call @{"cpattern:Free()" LINK cpatternFree} when finished
        with it.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        pat       a newly created pattern

@ENDNODE

@NODE ccontextPopGroupToSource "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PopGroupToSource -- pop group to source

   @{b}SYNOPSIS@{ub}
        ccontext:PopGroupToSource()

   @{b}FUNCTION@{ub}
        Terminates the redirection begun by a call to @{"ccontext:PushGroup()" LINK ccontextPushGroup} or
        @{"ccontext:PushGroupWithContent()" LINK ccontextPushGroupWithContent} and installs the resulting pattern as
        the source pattern in the given Cairo context.

        The behavior of this function is equivalent to the sequence of
        operations:

            group = cr:PopGroup()
            cr:SetSource(group)
            group:Free()

        but is more convenient as their is no need for a variable to store the
        short-lived handle to the pattern.

        The @{"ccontext:PopGroup()" LINK ccontextPopGroup} function calls @{"ccontext:Restore()" LINK ccontextRestore}, (balancing a
        call to @{"ccontext:Save()" LINK ccontextSave} by the push group function), so that any changes
        to the graphics state will not be visible outside the group.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextPushGroup "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PushGroup -- push group

   @{b}SYNOPSIS@{ub}
        ccontext:PushGroup()

   @{b}FUNCTION@{ub}
        Temporarily redirects drawing to an intermediate surface known as a
        group. The redirection lasts until the group is completed by a call to
        @{"ccontext:PopGroup()" LINK ccontextPopGroup} or @{"ccontext:PopGroupToSource()" LINK ccontextPopGroupToSource}. These calls provide
        the result of any drawing to the group as a pattern, (either as an
        explicit object, or set as the source pattern).

        This group functionality can be convenient for performing intermediate
        compositing. One common use of a group is to render objects as opaque
        within the group, (so that they occlude each other), and then blend the
        result with translucence onto the destination.

        Groups can be nested arbitrarily deep by making balanced calls to
        ccontext:PushGroup() / @{"ccontext:PopGroup()" LINK ccontextPopGroup}. Each call pushes/pops the
        new target group onto/from a stack.

        The ccontext:PushGroup() function calls @{"ccontext:Save()" LINK ccontextSave} so that any
        changes to the graphics state will not be visible outside the group. The
        pop_group functions call @{"ccontext:Restore()" LINK ccontextRestore}.

        By default the intermediate group will have a content type of
        #CAIRO_CONTENT_COLOR_ALPHA. Other content types can be chosen for the
        group by using @{"ccontext:PushGroupWithContent()" LINK ccontextPushGroupWithContent} instead.

        As an example, here is how one might fill and stroke a path with
        translucence, but without any portion of the fill being visible under
        the stroke:

            cr:PushGroup()
            cr:SetSource(fill_pattern)
            cr:FillPreserve()
            cr:SetSource(stroke_pattern)
            cr:Stroke()
            cr:PopGroupToSource()
            cr:PaintWithAlpha(alpha)

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextPushGroupWithContent "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:PushGroupWithContent -- push group with content

   @{b}SYNOPSIS@{ub}
        ccontext:PushGroupWithContent(content)

   @{b}FUNCTION@{ub}
        Temporarily redirects drawing to an intermediate surface known as a
        group. The redirection lasts until the group is completed by a call to
        @{"ccontext:PopGroup()" LINK ccontextPopGroup} or @{"ccontext:PopGroupToSource()" LINK ccontextPopGroupToSource}. These calls provide
        the result of any drawing to the group as a pattern (either as an
        explicit object, or set as the source pattern).

        The group will have a content type of "content". The ability to control
        this content type is the only distinction between this function and
        @{"ccontext:PushGroup()" LINK ccontextPushGroup} which you should see for a more detailed
        description of group rendering.

        See @{"csurface:GetContent()" LINK csurfaceGetContent} for a list of supported content types.

   @{b}INPUTS@{ub}
        content   constant indicating the type of group that will be created
                  (see above)

@ENDNODE

@NODE ccontextRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Rectangle -- add rectangle to path

   @{b}SYNOPSIS@{ub}
        ccontext:Rectangle(x, y, width, height)

   @{b}FUNCTION@{ub}
        Adds a closed sub-path rectangle of the given size to the current path
        at position ("x", "y") in user-space coordinates.

        This function is logically equivalent to:

            cr:MoveTo(x, y)
            cr:RelLineTo(width)
            cr:RelLineTo(0, height)
            cr:RelLineTo(-width, 0)
            cr:ClosePath()

   @{b}INPUTS@{ub}
        x         the X coordinate of the top left corner of the rectangle
        y         the Y coordinate to the top left corner of the rectangle
        width     the width of the rectangle
        height    the height of the rectangle

@ENDNODE

@NODE ccontextReference "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        ccontext:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the context by one. This prevents the
        context from being destroyed until a matching call to @{"ccontext:Free()" LINK ccontextFree} is
        made.

        Use @{"ccontext:GetReferenceCount()" LINK ccontextGetReferenceCount} to get the number of references to a
        Cairo context.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextRelCurveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:RelCurveTo -- add relative cubic Bezier spline

   @{b}SYNOPSIS@{ub}
        ccontext:RelCurveTo(dx1, dy1, dx2, dy2, dx3, dy3)

   @{b}FUNCTION@{ub}
        Relative-coordinate version of @{"ccontext:CurveTo()" LINK ccontextCurveTo}. All offsets are
        relative to the current point. Adds a cubic Bezier spline to the path
        from the current point to a point offset from the current point by
        ("dx3", "dy3"), using points offset by ("dx1", "dy1") and ("dx2", "dy2")
        as the control points. After this call the current point will be offset
        by ("dx3", "dy3").

        Given a current point of (x, y), calling this function with "dx1",
        "dy1", "dx2", "dy2", "dx3", "dy3" is logically equivalent to calling
        @{"ccontext:CurveTo()" LINK ccontextCurveTo} with x+dx1, y+dy1, x+dx2, y+dy2, x+dx3, y+dy3.

        It is an error to call this function with no current point. Doing so
        will cause the context to shutdown with a status of
        #CAIRO_STATUS_NO_CURRENT_POINT.

   @{b}INPUTS@{ub}
        dx1       the X offset to the first control point
        dy1       the Y offset to the first control point
        dx2       the X offset to the second control point
        dy2       the Y offset to the second control point
        dx3       the X offset to the end of the curve
        dy3       the Y offset to the end of the curve

@ENDNODE

@NODE ccontextRelLineTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:RelLineTo -- add relative line

   @{b}SYNOPSIS@{ub}
        ccontext:RelLineTo(dx, dy)

   @{b}FUNCTION@{ub}
        Relative-coordinate version of @{"ccontext:LineTo()" LINK ccontextLineTo}. Adds a line to the
        path from the current point to a point that is offset from the current
        point by ("dx", "dy") in user space. After this call the current point
        will be offset by ("dx", "dy").

        Given a current point of (x, y), calling this function with "dx", "dy"
        is logically equivalent to calling @{"ccontext:LineTo()" LINK ccontextLineTo} with x+dx and y+dy.

        It is an error to call this function with no current point. Doing so
        will cause the context to shutdown with a status of
        #CAIRO_STATUS_NO_CURRENT_POINT.

   @{b}INPUTS@{ub}
        dx        the X offset to the end of the new line
        dy        the Y offset to the end of the new line

@ENDNODE

@NODE ccontextRelMoveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:RelMoveTo -- begin new sub-path with relative point

   @{b}SYNOPSIS@{ub}
        ccontext:RelMoveTo(dx, dy)

   @{b}FUNCTION@{ub}
        Begin a new sub-path. After this call the current point will offset by
        ("x", "y").

        Given a current point of (x, y), calling this function with "dx", "dy"
        is logically equivalent to calling @{"ccontext:MoveTo()" LINK ccontextMoveTo} with x+dx and y+dy.

        It is an error to call this function with no current point. Doing so
        will cause the context to shutdown with a status of
        #CAIRO_STATUS_NO_CURRENT_POINT.

   @{b}INPUTS@{ub}
        dx        the X offset
        dy        the Y offset

@ENDNODE

@NODE ccontextResetClip "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ResetClip -- reset current clip region

   @{b}SYNOPSIS@{ub}
        ccontext:ResetClip()

   @{b}FUNCTION@{ub}
        Reset the current clip region to its original, unrestricted state. That
        is, set the clip region to an infinitely large shape containing the
        target surface. Equivalently, if infinity is too hard to grasp, one can
        imagine the clip region being reset to the exact bounds of the target
        surface.

        Note that code meant to be reusable should not call ccontext:ResetClip()
        as it will cause results unexpected by higher-level code which calls
        @{"ccontext:Clip()" LINK ccontextClip}. Consider using @{"ccontext:Save()" LINK ccontextSave} and @{"ccontext:Restore()" LINK ccontextRestore}
        around @{"ccontext:Clip()" LINK ccontextClip} as a more robust means of temporarily restricting
        the clip region.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextRestore "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Restore -- restore saved state

   @{b}SYNOPSIS@{ub}
        ccontext:Restore()

   @{b}FUNCTION@{ub}
        Restores the context to the state saved by a preceding call to
        @{"ccontext:Save()" LINK ccontextSave} and removes that state from the stack of saved states.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextRotate "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Rotate -- rotate current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:Rotate(angle)

   @{b}FUNCTION@{ub}
        Modifies the current transformation matrix (CTM) by rotating the
        user-space axes by "angle" radians. The rotation of the axes takes
        places after any existing transformation of user space. The rotation
        direction for positive angles is from the positive X axis toward the
        positive Y axis.

   @{b}INPUTS@{ub}
        angle     angle (in radians) by which the user-space axes will be
                  rotated

@ENDNODE

@NODE ccontextSave "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Save -- save current state

   @{b}SYNOPSIS@{ub}
        ccontext:Save()

   @{b}FUNCTION@{ub}
        Makes a copy of the current state of the context and saves it on an
        internal stack of saved states for the context. When @{"ccontext:Restore()" LINK ccontextRestore}
        is called, the context will be restored to the saved state. Multiple
        calls to ccontext:Save() and @{"ccontext:Restore()" LINK ccontextRestore} can be nested; each call
        to @{"ccontext:Restore()" LINK ccontextRestore} restores the state from the matching paired
        ccontext:Save().

        It isn't necessary to clear all saved states before a Cairo context is
        freed. If the reference count of a Cairo context drops to zero in
        response to a call to @{"ccontext:Free()" LINK ccontextFree}, any saved states will be freed
        along with the Cairo context.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextScale "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Scale -- scale current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:Scale(sx, sy)

   @{b}FUNCTION@{ub}
        Modifies the current transformation matrix (CTM) by scaling the X and Y
        user-space axes by "sx" and "sy" respectively. The scaling of the axes
        takes place after any existing transformation of user space.

   @{b}INPUTS@{ub}
        sx        scale factor for the X dimension
        sy        scale factor for the Y dimension

@ENDNODE

@NODE ccontextSelectFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SelectFontFace -- select font face

   @{b}SYNOPSIS@{ub}
        ccontext:SelectFontFace(family$, slant, weight)

   @{b}FUNCTION@{ub}
        Note: The ccontext:SelectFontFace() function call is part of what the
        Cairo designers call the "toy" text API. It is convenient for short
        demos and simple programs, but it is not expected to be adequate for
        serious text-using applications.

        Selects a family and style of font from a simplified description as a
        family name, slant and weight. Cairo provides no operation to list
        available family names on the system (this is a "toy", remember), but
        the standard CSS2 generic family names, ("serif", "sans-serif",
        "cursive", "fantasy", "monospace"), are likely to work as expected.

        If "family$" starts with the string "cairo:", or if no native font
        backends are compiled in, Cairo will use an internal font family. The
        internal font family recognizes many modifiers in the "family$" string,
        most notably, it recognizes the string "monospace". That is, the family
        name "cairo:monospace" will use the monospace version of the internal
        font family.

        For "real" font selection, see the font-backend-specific font face
        creation functions for the font backend you are using, e.g.
        @{"cairo.FontFace()" LINK cairoFontFace}. The resulting font face could then be used with
        @{"cairo.ScaledFont()" LINK cairoScaledFont} and @{"ccontext:SetScaledFont()" LINK ccontextSetScaledFont}.

        Similarly, when using the "real" font support, you can call directly
        into the underlying font system, such as fontconfig or freetype, for
        operations such as listing available fonts, etc.

        It is expected that most applications will need to use a more
        comprehensive font handling and text layout library, for example,
        pango), in conjunction with Cairo.

        If text is drawn without a call to ccontext:SelectFontFace(), nor
        @{"ccontext:SetFontFace()" LINK ccontextSetFontFace} nor @{"ccontext:SetScaledFont()" LINK ccontextSetScaledFont}, the default family
        is platform-specific, but is essentially "sans-serif".

        The "slant" parameter can be one of the following constants:

            #CAIRO_FONT_SLANT_NORMAL
            #CAIRO_FONT_SLANT_ITALIC
            #CAIRO_FONT_SLANT_OBLIQUE

        The "weight" parameter can be one of the following constants:

            #CAIRO_FONT_WEIGHT_NORMAL
            #CAIRO_FONT_WEIGHT_BOLD

        Default slant is #CAIRO_FONT_SLANT_NORMAL, and default weight is
        #CAIRO_FONT_WEIGHT_NORMAL.

        This function is equivalent to a call to @{"cairo.ToyFontFace()" LINK cairoToyFontFace} followed by
        @{"ccontext:SetFontFace()" LINK ccontextSetFontFace}.

   @{b}INPUTS@{ub}
        family$   a font family name
        slant     the slant for the font (see above)
        weight    the weight for the font (see above)

@ENDNODE

@NODE ccontextSetAntialias "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetAntialias -- set antialias

   @{b}SYNOPSIS@{ub}
        ccontext:SetAntialias(antialias)

   @{b}FUNCTION@{ub}
        Set the antialiasing mode of the rasterizer used for drawing shapes. The
        "antialias" parameter can be one of the following constants:

        #CAIRO_ANTIALIAS_DEFAULT
                  Use the default antialiasing for the subsystem and target
                  device.
        #CAIRO_ANTIALIAS_NONE
                  Use a bilevel alpha mask.
        #CAIRO_ANTIALIAS_GRAY
                  Perform single-color antialiasing (using shades of gray for
                  black text on a white background, for example).
        #CAIRO_ANTIALIAS_SUBPIXEL
                  Perform antialiasing by taking advantage of the order of
                  subpixel elements on devices such as LCD panels.
        #CAIRO_ANTIALIAS_FAST
                  Hint that the backend should perform some antialiasing but
                  prefer speed over quality.
        #CAIRO_ANTIALIAS_GOOD
                  The backend should balance quality against performance.
        #CAIRO_ANTIALIAS_BEST
                  Hint that the backend should render at the highest quality,
                  sacrificing speed if necessary.

        Note that the "antialias" value is a hint, and a particular backend may
        or may not support a particular value. At the current time, no backend
        supports #CAIRO_ANTIALIAS_SUBPIXEL when drawing shapes.

        Note that this option does not affect text rendering, instead see
        @{"cfontoptions:SetAntialias()" LINK cfontoptionsSetAntialias}.

   @{b}INPUTS@{ub}
        antialias the new antialiasing mode (see above)

@ENDNODE

@NODE ccontextSetDash "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetDash -- set dash pattern

   @{b}SYNOPSIS@{ub}
        ccontext:SetDash(offset[, dash1, ...])

   @{b}FUNCTION@{ub}
        Sets the dash pattern to be used by @{"ccontext:Stroke()" LINK ccontextStroke}. A dash pattern
        is specified by a number of positive dash values starting with "dash1".
        Each value provides the length of alternate "on" and "off" portions of
        the stroke. The "offset" specifies an offset into the pattern at which
        the stroke begins.

        Each "on" segment will have caps applied as if the segment were a
        separate sub-path. In particular, it is valid to use an "on" length of
        0.0 with #CAIRO_LINE_CAP_ROUND or #CAIRO_LINE_CAP_SQUARE in order to
        distributed dots or squares along a path.

        Note: The length values are in user-space units as evaluated at the time
        of stroking. This is not necessarily the same as the user space at the
        time of ccontext:SetDash().

        If you omit the optional "dash1" etc. arguments dashing is disabled.

        If you pass just a single dash value, a symmetric pattern is assumed
        with alternating on and off portions of the size specified by the single
        value in "dash1".

        If any dash value is negative, or if all values are 0, then the Cairo
        context will be put into an error state with a status of
        #CAIRO_STATUS_INVALID_DASH.

   @{b}INPUTS@{ub}
        offset    an offset into the dash pattern at which the stroke should
                  start
        dash1     optional: value for first stroke portion (on section)
        ...       optional: more values specifying alternate lengths of on and
                  off stroke portions

@ENDNODE

@NODE ccontextSetFillRule "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetFillRule -- set current fill rule

   @{b}SYNOPSIS@{ub}
        ccontext:SetFillRule(fill_rule)

   @{b}FUNCTION@{ub}
        Set the current fill rule within the Cairo context. The fill rule is
        used to determine which regions are inside or outside a complex
        (potentially self-intersecting) path. The current fill rule affects both
        @{"ccontext:Fill()" LINK ccontextFill} and @{"ccontext:Clip()" LINK ccontextClip}. The following values can be passed
        for "fill_rule":

        #CAIRO_FILL_RULE_WINDING
                  If the path crosses the ray from left-to-right, counts +1. If
                  the path crosses the ray from right to left, counts -1. Left
                  and right are determined from the perspective of looking along
                  the ray from the starting point. If the total count is
                  non-zero, the point will be filled.

        #CAIRO_FILL_RULE_EVEN_ODD
                  Counts the total number of intersections, without regard to
                  the orientation of the contour. If the total number of
                  intersections is odd, the point will be filled.

        The default fill rule is #CAIRO_FILL_RULE_WINDING.

   @{b}INPUTS@{ub}
        fill_rule a fill rule (see above)

@ENDNODE

@NODE ccontextSetFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetFontFace -- set font face

   @{b}SYNOPSIS@{ub}
        ccontext:SetFontFace(font_face)

   @{b}FUNCTION@{ub}
        Replaces the current font face object in the Cairo context with
        "font_face". The replaced font face in the Cairo context will be
        destroyed if there are no other references to it.

   @{b}INPUTS@{ub}
        font_face a font face object or Nil to restore to the default font

@ENDNODE

@NODE ccontextSetFontMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetFontMatrix -- set font matrix

   @{b}SYNOPSIS@{ub}
        ccontext:SetFontMatrix(matrix)

   @{b}FUNCTION@{ub}
        Sets the current font matrix to "matrix". The font matrix gives a
        transformation from the design space of the font (in this space, the
        em-square is 1 unit by 1 unit) to user space. Normally, a simple scale
        is used (see @{"ccontext:SetFontSize()" LINK ccontextSetFontSize}), but a more complex font matrix
        can be used to shear the font or stretch it unequally along the two axes

   @{b}INPUTS@{ub}
        matrix    a matrix object describing a transform to be applied to the
                  current font

@ENDNODE

@NODE ccontextSetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetFontOptions -- set font options

   @{b}SYNOPSIS@{ub}
        ccontext:SetFontOptions(options)

   @{b}FUNCTION@{ub}
        Sets a set of custom font rendering options for the Cairo context.
        Rendering options are derived by merging these options with the options
        derived from underlying surface; if the value in "options" has a default
        value (like #CAIRO_ANTIALIAS_DEFAULT), then the value from the surface
        is used.

   @{b}INPUTS@{ub}
        options   font options object to use

@ENDNODE

@NODE ccontextSetFontSize "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetFontSize -- set font size

   @{b}SYNOPSIS@{ub}
        ccontext:SetFontSize(size)

   @{b}FUNCTION@{ub}
        Sets the current font matrix to a scale by a factor of "size", replacing
        any font matrix previously set with ccontext:SetFontSize() or
        @{"ccontext:SetFontMatrix()" LINK ccontextSetFontMatrix}. This results in a font size of "size" user
        space units. More precisely, this matrix will result in the font's
        em-square being a "size" by "size" square in user space.

        If text is drawn without a call to ccontext:SetFontSize(), nor
        @{"ccontext:SetFontMatrix()" LINK ccontextSetFontMatrix} nor @{"ccontext:SetScaledFont()" LINK ccontextSetScaledFont}, the default font
        size is 10.0.

   @{b}INPUTS@{ub}
        size      the new font size, in user space units

@ENDNODE

@NODE ccontextSetLineCap "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetLineCap -- set line cap style

   @{b}SYNOPSIS@{ub}
        ccontext:SetLineCap(line_cap)

   @{b}FUNCTION@{ub}
        Sets the current line cap style within the Cairo context. The "line_cap"
        parameter can be one of the following constants:

        #CAIRO_LINE_CAP_BUTT
                  Start(stop) the line exactly at the start(end) point.
        #CAIRO_LINE_CAP_ROUND
                  Use a round ending, the center of the circle is the end point.
        #CAIRO_LINE_CAP_SQUARE
                  Use squared ending, the center of the square is the end point.

        As with the other stroke parameters, the current line cap style is
        examined by @{"ccontext:Stroke()" LINK ccontextStroke} and @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents}, but does
        not have any effect during path construction.

        The default line cap style is #CAIRO_LINE_CAP_BUTT.

   @{b}INPUTS@{ub}
        line_cap  a line cap style (see above)

@ENDNODE

@NODE ccontextSetLineJoin "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetLineJoin -- set line join style

   @{b}SYNOPSIS@{ub}
        ccontext:SetLineJoin(line_join)

   @{b}FUNCTION@{ub}
        Sets the current line join style within the Cairo context. The
        "line_join" parameter can be one of the following constants:

        #CAIRO_LINE_JOIN_MITER
                  Use a sharp (angled) corner. See @{"ccontext:SetMiterLimit" LINK ccontextSetMiterLimit} for
                  details.
        #CAIRO_LINE_JOIN_ROUND
                  Use a rounded join, the center of the circle is the joint
                  point.
        #CAIRO_LINE_JOIN_BEVEL
                  Use a cut-off join, the join is cut off at half the line width
                  from the joint point.

        As with the other stroke parameters, the current line join style is
        examined by @{"ccontext:Stroke()" LINK ccontextStroke} and @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents}, but does
        not have any effect during path construction.

        The default line join style is #CAIRO_LINE_JOIN_MITER.

   @{b}INPUTS@{ub}
        line_join a line join style (see above)

@ENDNODE

@NODE ccontextSetLineWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetLineWidth -- set line width

   @{b}SYNOPSIS@{ub}
        ccontext:SetLineWidth(width)

   @{b}FUNCTION@{ub}
        Sets the current line width within the Cairo context. The line width
        value specifies the diameter of a pen that is circular in user space,
        (though device-space pen may be an ellipse in general due to
        scaling/shear/rotation of the CTM).

        Note: When the description above refers to user space and CTM it refers
        to the user space and CTM in effect at the time of the stroking
        operation, not the user space and CTM in effect at the time of the call
        to ccontext:SetLineWidth(). The simplest usage makes both of these
        spaces identical. That is, if there is no change to the CTM between a
        call to ccontext:SetLineWidth() and the stroking operation, then one can
        just pass user-space values to ccontext:SetLineWidth() and ignore this
        note.

        As with the other stroke parameters, the current line width is examined
        by @{"ccontext:Stroke()" LINK ccontextStroke} and @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents}, but does not have
        any effect during path construction.

        The default line width value is 2.0.

   @{b}INPUTS@{ub}
        width     a line width

@ENDNODE

@NODE ccontextSetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetMatrix -- set current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:SetMatrix(matrix)

   @{b}FUNCTION@{ub}
        Modifies the current transformation matrix (CTM) by setting it equal to
        "matrix".

   @{b}INPUTS@{ub}
        matrix    a transformation matrix from user space to device space

@ENDNODE

@NODE ccontextSetMiterLimit "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetMiterLimit -- set current miter limit

   @{b}SYNOPSIS@{ub}
        ccontext:SetMiterLimit(limit)

   @{b}FUNCTION@{ub}
        Sets the current miter limit within the Cairo context.

        If the current line join style is set to #CAIRO_LINE_JOIN_MITER (see
        @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin}), the miter limit is used to determine whether
        the lines should be joined with a bevel instead of a miter. Cairo
        divides the length of the miter by the line width. If the result is
        greater than the miter limit, the style is converted to a bevel.

        As with the other stroke parameters, the current line miter limit is
        examined by @{"ccontext:Stroke()" LINK ccontextStroke} and @{"ccontext:StrokeExtents()" LINK ccontextStrokeExtents} but does not
        have any effect during path construction.

        The default miter limit value is 10.0, which will convert joins with
        interior angles less than 11 degrees to bevels instead of miters. For
        reference, a miter limit of 2.0 makes the miter cutoff at 60 degrees,
        and a miter limit of 1.414 makes the cutoff at 90 degrees.

        A miter limit for a desired angle can be computed as:

            miterlimit = 1/sin(angle/2)

   @{b}INPUTS@{ub}
        limit     miter limit to set

@ENDNODE

@NODE ccontextSetOperator "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetOperator -- set current compositing operator

   @{b}SYNOPSIS@{ub}
        ccontext:SetOperator(op)

   @{b}FUNCTION@{ub}
        Sets the compositing operator to be used for all drawing operations. The
        "op" parameter can be one of the following constants:

        #CAIRO_OPERATOR_CLEAR
                  Clear destination layer (bounded)
        #CAIRO_OPERATOR_SOURCE
                  Replace destination layer (bounded).
        #CAIRO_OPERATOR_OVER
                  Draw source layer on top of destination layer (bounded).
        #CAIRO_OPERATOR_IN
                  Draw source where there was destination content (unbounded).
        #CAIRO_OPERATOR_OUT
                  Draw source where there was no destination content
                  (unbounded).
        #CAIRO_OPERATOR_ATOP
                  Draw source on top of destination content and only there.
        #CAIRO_OPERATOR_DEST
                  Ignore the source.
        #CAIRO_OPERATOR_DEST_OVER
                  Draw destination on top of source.
        #CAIRO_OPERATOR_DEST_IN
                  Leave destination only where there was source content
                  (unbounded).
        #CAIRO_OPERATOR_DEST_OUT
                  Leave destination only where there was no source content.
        #CAIRO_OPERATOR_DEST_ATOP
                  Leave destination on top of source content and only there
                  (unbounded).
        #CAIRO_OPERATOR_XOR
                  Source and destination are shown where there is only one of
                  them.
        #CAIRO_OPERATOR_ADD
                  Source and destination layers are accumulated.
        #CAIRO_OPERATOR_SATURATE
                  Like over, but assuming source and dest are disjoint
                  geometries.
        #CAIRO_OPERATOR_MULTIPLY
                  Source and destination layers are multiplied. This causes the
                  result to be at least as dark as the darker inputs.
        #CAIRO_OPERATOR_SCREEN
                  Source and destination are complemented and multiplied. This
                  causes the result to be at least as light as the lighter
                  inputs.
        #CAIRO_OPERATOR_OVERLAY
                  Multiplies or screens, depending on the lightness of the
                  destination color.
        #CAIRO_OPERATOR_DARKEN
                  Replaces the destination with the source if it is darker,
                  otherwise keeps the source.
        #CAIRO_OPERATOR_LIGHTEN
                  Replaces the destination with the source if it is lighter,
                  otherwise keeps the source.
        #CAIRO_OPERATOR_COLOR_DODGE
                  Brightens the destination color to reflect the source color.
        #CAIRO_OPERATOR_COLOR_BURN
                  Darkens the destination color to reflect the source color.
        #CAIRO_OPERATOR_HARD_LIGHT
                  Multiplies or screens, dependent on source color.
        #CAIRO_OPERATOR_SOFT_LIGHT
                  Darkens or lightens, dependent on source color.
        #CAIRO_OPERATOR_DIFFERENCE
                  Takes the difference of the source and destination color.
        #CAIRO_OPERATOR_EXCLUSION
                  Produces an effect similar to difference, but with lower
                  contrast.
        #CAIRO_OPERATOR_HSL_HUE
                  Creates a color with the hue of the source and the saturation
                  and luminosity of the target.
        #CAIRO_OPERATOR_HSL_SATURATION
                  Creates a color with the saturation of the source and the hue
                  and luminosity of the target. Painting with this mode onto a
                  gray area produces no change.
        #CAIRO_OPERATOR_HSL_COLOR
                  Creates a color with the hue and saturation of the source and
                  the luminosity of the target. This preserves the gray levels
                  of the target and is useful for coloring monochrome images or
                  tinting color images.
        #CAIRO_OPERATOR_HSL_LUMINOSITY
                  Creates a color with the luminosity of the source and the hue
                  and saturation of the target. This produces an inverse effect
                  to #CAIRO_OPERATOR_HSL_COLOR.

        The default operator is #CAIRO_OPERATOR_OVER.

   @{b}INPUTS@{ub}
        op        a compositing operator (see above)

@ENDNODE

@NODE ccontextSetScaledFont "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetScaledFont -- set scaled font

   @{b}SYNOPSIS@{ub}
        ccontext:SetScaledFont(scaled_font)

   @{b}FUNCTION@{ub}
        Replaces the current font face, font matrix, and font options in the
        Cairo context with those of the "scaled_font". Except for some
        translation, the current CTM of the Cairo context should be the same as
        that of the "scale_font", which can be accessed using
        @{"cscaledfont:GetCTM()" LINK cscaledfontGetCTM}.

   @{b}INPUTS@{ub}
        scaled_font
                  a scaled font object

@ENDNODE

@NODE ccontextSetSource "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetSource -- set source pattern

   @{b}SYNOPSIS@{ub}
        ccontext:SetSource(source)

   @{b}FUNCTION@{ub}
        Sets the source pattern within the context to "source". This pattern
        will then be used for any subsequent drawing operation until a new
        source pattern is set.

        Note: The pattern's transformation matrix will be locked to the user
        space in effect at the time of ccontext:SetSource(). This means that
        further modifications of the current transformation matrix will not
        affect the source pattern. See @{"cpattern:SetMatrix()" LINK cpatternSetMatrix}.

        The default source pattern is a solid pattern that is opaque black, that
        is, it is equivalent to @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB} with the arguments all
        set to 0.0.

   @{b}INPUTS@{ub}
        source    a Cairo pattern object to be used as the source for subsequent
                  drawing operations

@ENDNODE

@NODE ccontextSetSourceRGB "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetSourceRGB -- set source RGB

   @{b}SYNOPSIS@{ub}
        ccontext:SetSourceRGB(red, green, blue)

   @{b}FUNCTION@{ub}
        Sets the source pattern within the context to an opaque color. This
        opaque color will then be used for any subsequent drawing operation
        until a new source pattern is set.

        The color components are floating point numbers in the range 0 to 1. If
        the values passed in are outside that range, they will be clamped.

        The default source pattern is a solid pattern that is opaque black, that
        is, it is equivalent to ccontext:SetSourceRGB() with the arguments all
        set to 0.0.

   @{b}INPUTS@{ub}
        red       red component of color
        green     green component of color
        blue      blue component of color

@ENDNODE

@NODE ccontextSetSourceRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetSourceRGBA -- set source RGBA

   @{b}SYNOPSIS@{ub}
        ccontext:SetSourceRGBA(red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        Sets the source pattern within the context to a translucent color. This
        color will then be used for any subsequent drawing operation until a new
        source pattern is set.

        The color and alpha components are floating point numbers in the range 0
        to 1. If the values passed in are outside that range, they will be
        clamped.

        Note that the color and alpha values are not premultiplied.

        The default source pattern is a solid pattern that is opaque black, that
        is, it is equivalent to @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB} with the arguments all
        set to 0.0.

   @{b}INPUTS@{ub}
        red       red component of color
        green     green component of color
        blue      blue component of color
        alpha     alpha component of color

@ENDNODE

@NODE ccontextSetSourceSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetSourceSurface -- set source surface

   @{b}SYNOPSIS@{ub}
        ccontext:SetSourceSurface(surface, x, y)

   @{b}FUNCTION@{ub}
        This is a convenience function for creating a pattern from "surface" and
        setting it as the source in the context with @{"ccontext:SetSource()" LINK ccontextSetSource}.

        The "x" and "y" parameters give the user-space coordinate at which the
        surface origin should appear. The surface origin is its upper-left
        corner before any transformation has been applied. The "x" and "y"
        parameters are negated and then set as translation values in the pattern
        matrix.

        Other than the initial translation pattern matrix, as described above,
        all other pattern attributes, such as its extend mode, are set to the
        default values as in @{"cairo.PatternForSurface()" LINK cairoPatternForSurface}. The resulting pattern
        can be queried with @{"ccontext:GetSource()" LINK ccontextGetSource} so that these attributes can be
        modified if desired, (e.g. to create a repeating pattern with
        @{"cpattern:SetExtend()" LINK cpatternSetExtend}).

   @{b}INPUTS@{ub}
        surface   a surface to be used to set the source pattern
        x         User-space X coordinate for surface origin
        y         User-space Y coordinate for surface origin

@ENDNODE

@NODE ccontextSetTolerance "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:SetTolerance -- set tolerance

   @{b}SYNOPSIS@{ub}
        ccontext:SetTolerance(tolerance)

   @{b}FUNCTION@{ub}
        Sets the tolerance used when converting paths into trapezoids. Curved
        segments of the path will be subdivided until the maximum deviation
        between the original path and the polygonal approximation is less than
        "tolerance". The default value is 0.1. A larger value will give better
        performance, a smaller value, better appearance. Reducing the value from
        the default value of 0.1 is unlikely to improve appearance
        significantly. The accuracy of paths within Cairo is limited by the
        precision of its internal arithmetic, and the prescribed "tolerance" is
        restricted to the smallest representable internal value.

   @{b}INPUTS@{ub}
        tolerance the tolerance, in device units (typically pixels)

@ENDNODE

@NODE ccontextShowErrorUnderline "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowErrorUnderline -- draw error underline

   @{b}SYNOPSIS@{ub}
        ccontext:ShowErrorUnderline(x, y, width, height)

   @{b}FUNCTION@{ub}
        Draw a squiggly line in the specified Cairo context that approximately
        covers the given rectangle in the style of an underline used to indicate
        a spelling error.

        The width of the underline is rounded to an integer number of up/down
        segments and the resulting rectangle is centered in the original
        rectangle.

   @{b}INPUTS@{ub}
        x         the X coordinate of one corner of the rectangle
        y         the Y coordinate of one corner of the rectangle
        width     non-negative width of the rectangle
        height    non-negative height of the rectangle

@ENDNODE

@NODE ccontextShowGlyphItem "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowGlyphItem -- show glyph item

   @{b}SYNOPSIS@{ub}
        ccontext:ShowGlyphItem(text$, glyph_item)

   @{b}FUNCTION@{ub}
        Draws the glyphs in "glyph_item" in the specified Cairo context,
        embedding the text associated with the glyphs in the output if the
        output format supports it (PDF for example), otherwise it acts similar
        to @{"ccontext:ShowGlyphString()" LINK ccontextShowGlyphString}.

        The origin of the glyphs (the left edge of the baseline) will be drawn
        at the current point of the Cairo context.

        Note that "text" is the start of the text for layout, which is then
        indexed by the offset member of the glyph item.

   @{b}INPUTS@{ub}
        text$     the text that "glyph_item" refers to
        glyph_item
                  a Pango glyph item object

@ENDNODE

@NODE ccontextShowGlyphs "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowGlyphs -- show glyphs

   @{b}SYNOPSIS@{ub}
        ccontext:ShowGlyphs(glyphs[, offset, num_glyphs])

   @{b}FUNCTION@{ub}
        A drawing operator that generates the shape from a glyphs array,
        rendered according to the current font face, font size (font matrix),
        and font options.

   @{b}INPUTS@{ub}
        glyphs    glyphs array to show
        offset    optional: offset into the array that specifies the starting
                  glyph (defaults to 0 which means first glyph)
        num_glyphs
                  optional: number of glyphs to show (defaults to -1 which means
                  all glyphs)

@ENDNODE

@NODE ccontextShowGlyphString "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowGlyphString -- show glyph string

   @{b}SYNOPSIS@{ub}
        ccontext:ShowGlyphString(font, glyphs)

   @{b}FUNCTION@{ub}
        Draws the glyphs in "glyphs" in the specified Cairo context.

        The origin of the glyphs (the left edge of the baseline) will be drawn
        at the current point of the Cairo context.

   @{b}INPUTS@{ub}
        font      a Pango font object
        glyphs    a Pango glyph string object

@ENDNODE

@NODE ccontextShowLayout "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowLayout -- show layout

   @{b}SYNOPSIS@{ub}
        ccontext:ShowLayout(layout)

   @{b}FUNCTION@{ub}
        Draws a Pango layout in the specified Cairo context.

        The top-left corner of the Pango layout will be drawn at the current
        point of the Cairo context.

   @{b}INPUTS@{ub}
        layout    a Pango layout object

@ENDNODE

@NODE ccontextShowLayoutLine "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowLayoutLine -- show layout line

   @{b}SYNOPSIS@{ub}
        ccontext:ShowLayoutLine(line)

   @{b}FUNCTION@{ub}
        Draws a Pango layout line in the specified Cairo context.

        The origin of the glyphs (the left edge of the line) will be drawn at
        the current point of the Cairo context.

   @{b}INPUTS@{ub}
        line      a Pango layout line object

@ENDNODE

@NODE ccontextShowPage "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowPage -- show page

   @{b}SYNOPSIS@{ub}
        ccontext:ShowPage()

   @{b}FUNCTION@{ub}
        Emits and clears the current page for backends that support multiple
        pages. Use @{"ccontext:CopyPage()" LINK ccontextCopyPage} if you don't want to clear the page.

        This is a convenience function that simply calls @{"csurface:ShowPage()" LINK csurfaceShowPage} on
        "cr's" target.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextShowText "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:ShowText -- show text

   @{b}SYNOPSIS@{ub}
        ccontext:ShowText(s$)

   @{b}FUNCTION@{ub}
        A drawing operator that generates the shape from the string passed in
        "s$", rendered according to the current font face, font size (font
        matrix), and font options.

        This function first computes a set of glyphs for the string of text. The
        first glyph is placed so that its origin is at the current point. The
        origin of each subsequent glyph is offset from that of the previous
        glyph by the advance values of the previous glyph.

        After this call the current point is moved to the origin of where the
        next glyph would be placed in this same progression. That is, the
        current point will be at the origin of the final glyph offset by its
        advance values. This allows for easy display of a single logical string
        with multiple calls to ccontext:ShowText().

        Note: The ccontext:ShowText() function call is part of what the Cairo
        designers call the "toy" text API. It is convenient for short demos and
        simple programs, but it is not expected to be adequate for serious
        text-using applications. See @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs} for the "real" text
        display API in Cairo.

   @{b}INPUTS@{ub}
        s$        string of text to show

@ENDNODE

@NODE ccontextStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Status -- get context status

   @{b}SYNOPSIS@{ub}
        status = ccontext:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this context. The
        following status codes are currently defined:

        #CAIRO_STATUS_SUCCESS
                  No error has occurred.
        #CAIRO_STATUS_NO_MEMORY
                  Out of memory
        #CAIRO_STATUS_INVALID_RESTORE
                  @{"ccontext:Restore()" LINK ccontextRestore} called without matching @{"ccontext:Save()" LINK ccontextSave}
        #CAIRO_STATUS_INVALID_POP_GROUP
                  No saved group to pop, i.e. @{"ccontext:PopGroup()" LINK ccontextPopGroup} without
                  matching @{"ccontext:PushGroup()" LINK ccontextPushGroup}
        #CAIRO_STATUS_NO_CURRENT_POINT
                  No current point defined
        #CAIRO_STATUS_INVALID_MATRIX
                  Invalid matrix (not invertible)
        #CAIRO_STATUS_INVALID_STATUS
                  Invalid value for an input Cairo status
        #CAIRO_STATUS_NULL_POINTER
                  NULL pointer
        #CAIRO_STATUS_INVALID_STRING
                  Input string not valid UTF-8
        #CAIRO_STATUS_INVALID_PATH_DATA
                  Input path data not valid
        #CAIRO_STATUS_READ_ERROR
                  Error while reading from input stream
        #CAIRO_STATUS_WRITE_ERROR
                  Error while writing to output stream
        #CAIRO_STATUS_SURFACE_FINISHED
                  Target surface has been finished
        #CAIRO_STATUS_SURFACE_TYPE_MISMATCH
                  The surface type is not appropriate for the operation
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
                  The pattern type is not appropriate for the operation
        #CAIRO_STATUS_INVALID_CONTENT
                  Invalid value for an input Cairo content
        #CAIRO_STATUS_INVALID_FORMAT
                  Invalid value for an input Cairo format
        #CAIRO_STATUS_INVALID_VISUAL
                  Invalid value for an input visual
        #CAIRO_STATUS_FILE_NOT_FOUND
                  File not found
        #CAIRO_STATUS_INVALID_DASH
                  Invalid value for a dash setting
        #CAIRO_STATUS_INVALID_DSC_COMMENT
                  Invalid value for a DSC comment
        #CAIRO_STATUS_INVALID_INDEX
                  Invalid index passed to getter
        #CAIRO_STATUS_CLIP_NOT_REPRESENTABLE
                  Clip region not representable in desired format
        #CAIRO_STATUS_TEMP_FILE_ERROR
                  Error creating or writing to a temporary file
        #CAIRO_STATUS_INVALID_STRIDE
                  Invalid value for stride
        #CAIRO_STATUS_FONT_TYPE_MISMATCH
                  The font type is not appropriate for the operation
        #CAIRO_STATUS_USER_FONT_IMMUTABLE
                  The user-font is immutable
        #CAIRO_STATUS_USER_FONT_ERROR
                  Error occurred in a user-font callback function
        #CAIRO_STATUS_NEGATIVE_COUNT
                  Negative number used where it is not allowed
        #CAIRO_STATUS_INVALID_CLUSTERS
                  Input clusters do not represent the accompanying text and
                  glyph array
        #CAIRO_STATUS_INVALID_SLANT
                  Invalid value for an input Cairo font slant
        #CAIRO_STATUS_INVALID_WEIGHT
                  Invalid value for an input Cairo font weight
        #CAIRO_STATUS_INVALID_SIZE
                  Invalid value (typically too big) for the size of the input
                  (surface, pattern, etc.)
        #CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED
                  User-font method not implemented
        #CAIRO_STATUS_DEVICE_TYPE_MISMATCH
                  The device type is not appropriate for the operation
        #CAIRO_STATUS_DEVICE_ERROR
                  An operation to the device caused an unspecified error
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION
                  A mesh pattern construction operation was used outside begin
                  end patch pair
        #CAIRO_STATUS_DEVICE_FINISHED
                  Target device has been finished
        #CAIRO_STATUS_JBIG2_GLOBAL_MISSING
                  #CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID has been used on at least one
                  image but no image provided #CAIRO_MIME_TYPE_JBIG2_GLOBAL
        #CAIRO_STATUS_PNG_ERROR
                  Error occurred in libpng while reading from or writing to a
                  PNG file
        #CAIRO_STATUS_FREETYPE_ERROR
                  Error occurred in libfreetype
        #CAIRO_STATUS_WIN32_GDI_ERROR
                  Error occurred in the Windows Graphics Device Interface
        #CAIRO_STATUS_TAG_ERROR
                  Invalid tag name, attributes, or nesting
        #CAIRO_STATUS_DWRITE_ERROR
                  Error occurred in the Windows Direct Write API
        #CAIRO_STATUS_SVG_FONT_ERROR
                  Error occurred in OpenType-SVG font rendering

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    the current status of this context

@ENDNODE

@NODE ccontextStroke "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Stroke -- stroke current path

   @{b}SYNOPSIS@{ub}
        ccontext:Stroke()

   @{b}FUNCTION@{ub}
        A drawing operator that strokes the current path according to the
        current line width, line join, line cap, and dash settings. After
        ccontext:Stroke(), the current path will be cleared from the Cairo
        context. See @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth}, @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin},
        @{"ccontext:SetLineCap()" LINK ccontextSetLineCap}, @{"ccontext:SetDash()" LINK ccontextSetDash}, and
        @{"ccontext:StrokePreserve()" LINK ccontextStrokePreserve}.

        Note: Degenerate segments and sub-paths are treated specially and
        provide a useful result. These can result in two different situations:

        1. Zero-length "on" segments set in @{"ccontext:SetDash()" LINK ccontextSetDash}. If the cap
           style is #CAIRO_LINE_CAP_ROUND or #CAIRO_LINE_CAP_SQUARE then these
           segments will be drawn as circular dots or squares respectively. In
           the case of #CAIRO_LINE_CAP_SQUARE, the orientation of the squares is
           determined by the direction of the underlying path.

        2. A sub-path created by @{"ccontext:MoveTo()" LINK ccontextMoveTo} followed by either a
           @{"ccontext:ClosePath()" LINK ccontextClosePath} or one or more calls to @{"ccontext:LineTo()" LINK ccontextLineTo} to the
           same coordinate as the @{"ccontext:MoveTo()" LINK ccontextMoveTo}. If the cap style is
           #CAIRO_LINE_CAP_ROUND then these sub-paths will be drawn as circular
           dots. Note that in the case of #CAIRO_LINE_CAP_SQUARE a degenerate
           sub-path will not be drawn at all, (since the correct orientation is
           indeterminate).

        In no case will a cap style of #CAIRO_LINE_CAP_BUTT cause anything to be
        drawn in the case of either degenerate segments or sub-paths.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextStrokeExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:StrokeExtents -- get stroke extents

   @{b}SYNOPSIS@{ub}
        x1, y1, x2, y2 = ccontext:StrokeExtents()

   @{b}FUNCTION@{ub}
        Computes a bounding box in user coordinates covering the area that would
        be affected, the "inked" area, by a @{"ccontext:Stroke()" LINK ccontextStroke} operation given
        the current path and stroke parameters. If the current path is empty,
        returns an empty rectangle ((0,0), (0,0)). Surface dimensions and
        clipping are not taken into account.

        Note that if the line width is set to exactly zero, then
        ccontext:StrokeExtents() will return an empty rectangle. Contrast with
        @{"ccontext:PathExtents()" LINK ccontextPathExtents} which can be used to compute the non-empty bounds
        as the line width approaches zero.

        Note that ccontext:StrokeExtents() must necessarily do more work to
        compute the precise inked areas in light of the stroke parameters, so
        @{"ccontext:PathExtents()" LINK ccontextPathExtents} may be more desirable for sake of performance if
        non-inked path extents are desired.

        See @{"ccontext:Stroke()" LINK ccontextStroke}, @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth}, @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin},
        @{"ccontext:SetLineCap()" LINK ccontextSetLineCap}, @{"ccontext:SetDash()" LINK ccontextSetDash}, and
        @{"ccontext:StrokePreserve()" LINK ccontextStrokePreserve}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x1        left of the resulting extents
        y1        top of the resulting extents
        x2        right of the resulting extents
        y2        bottom of the resulting extents

@ENDNODE

@NODE ccontextStrokePreserve "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:StrokePreserve -- stroke path and preserve it

   @{b}SYNOPSIS@{ub}
        ccontext:StrokePreserve()

   @{b}FUNCTION@{ub}
        A drawing operator that strokes the current path according to the
        current line width, line join, line cap, and dash settings. Unlike
        @{"ccontext:Stroke()" LINK ccontextStroke}, ccontext:StrokePreserve() preserves the path within
        the Cairo context.

        See @{"ccontext:SetLineWidth()" LINK ccontextSetLineWidth}, @{"ccontext:SetLineJoin()" LINK ccontextSetLineJoin},
        @{"ccontext:SetLineCap()" LINK ccontextSetLineCap}, @{"ccontext:SetDash()" LINK ccontextSetDash}, and
        ccontext:StrokePreserve().

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE ccontextTagBegin "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:TagBegin -- mark beginning of a tag

   @{b}SYNOPSIS@{ub}
        ccontext:TagBegin(tag_name$, attributes$)

   @{b}FUNCTION@{ub}
        Marks the beginning of the "tag_name$" structure. Call @{"ccontext:TagEnd()" LINK ccontextTagEnd}
        with the same "tag_name$" to mark the end of the structure. The
        "tag_name$" parameter can be one of the following constants:

        #CAIRO_TAG_DEST
                  Create a destination for a hyperlink.
        #CAIRO_TAG_LINK
                  Create hyperlink.

        The "attributes$" string is of the form "key1=value2 key2=value2 ...".
        Values may be boolean (true/false or 1/0), integer, float, string, or an
        array.

        String values are enclosed in single quotes ('). Single quotes and
        backslashes inside the string should be escaped with a backslash.

        Boolean values may be set to true by only specifying the key. eg the
        attribute string "key" is the equivalent to "key=true".

        Arrays are enclosed in '[]'. eg "rect=[1.2 4.3 2.0 3.0]".

        If no attributes are required, "attributes" can be an empty string.

        See the tags and links description in the Cairo manual for the list of
        tags and attributes.

        Invalid nesting of tags or invalid attributes will cause the context to
        shutdown with a status of #CAIRO_STATUS_TAG_ERROR.

        See @{"ccontext:TagEnd()" LINK ccontextTagEnd}.

   @{b}INPUTS@{ub}
        tag_name$ tag name (see above)
        attributes$
                  tag attributes (see above)

   @{b}EXAMPLE@{ub}
        cr:TagBegin(#CAIRO_TAG_LINK, "dest='mydest' internal")
        cr:MoveTo(50, 50)
        cr:ShowText("This is a hyperlink.")
        cr:TagEnd(#CAIRO_TAG_LINK)

        The code above creates a hyperlink.

@ENDNODE

@NODE ccontextTagEnd "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:TagEnd -- mark end of a tag

   @{b}SYNOPSIS@{ub}
        ccontext:TagEnd(tag_name$)

   @{b}FUNCTION@{ub}
        Marks the end of the "tag_name$" structure. See @{"ccontext:TagBegin()" LINK ccontextTagBegin} for
        a list of tag names.

        Invalid nesting of tags will cause the context to shutdown with a status
        of #CAIRO_STATUS_TAG_ERROR.

   @{b}INPUTS@{ub}
        tag_name$ tag name

@ENDNODE

@NODE ccontextTextExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:TextExtents -- get text extents

   @{b}SYNOPSIS@{ub}
        t = ccontext:TextExtents(s$)

   @{b}FUNCTION@{ub}
        Gets the extents for a string of text. The extents describe a user-space
        rectangle that encloses the "inked" portion of the text, (as it would be
        drawn by @{"ccontext:ShowText()" LINK ccontextShowText}). Additionally, the "XAdvance" and
        "YAdvance" values indicate the amount by which the current point would
        be advanced by @{"ccontext:ShowText()" LINK ccontextShowText}.

        This function returns a table describing the text extents. The table
        contains the following fields:

        XBearing  The horizontal distance from the origin to the leftmost part
                  of the glyphs as drawn. Positive if the glyphs lie entirely to
                  the right of the origin.
        YBearing  The vertical distance from the origin to the topmost part of
                  the glyphs as drawn. Positive only if the glyphs lie
                  completely below the origin; will usually be negative.
        Width     Width of the glyphs as drawn.
        Height    Height of the glyphs as drawn.
        XAdvance  Distance to advance in the X direction after drawing these
                  glyphs.
        YAdvance  Distance to advance in the Y direction after drawing these
                  glyphs. Will typically be zero except for vertical text layout
                  as found in East-Asian languages.

        Note that whitespace characters do not directly contribute to the size
        of the rectangle ("Width" and "Height"). They do contribute indirectly
        by changing the position of non-whitespace characters. In particular,
        trailing whitespace characters are likely to not affect the size of the
        rectangle, though they will affect the "XAdvance" and "YAdvance" values.

        Also note that because text extents are in user-space coordinates, they
        are mostly, but not entirely, independent of the current transformation
        matrix. If you call @{"ccontext:Scale()" LINK ccontextScale} with scaling coefficients of 2.0 on
        each axis, the text will be drawn twice as big, but the reported text
        extents will not be doubled. They will change slightly due to hinting
        (so you can't assume that metrics are independent of the transformation
        matrix), but otherwise will remain unchanged.

   @{b}INPUTS@{ub}
        s$        string of text

   @{b}RESULTS@{ub}
        t         table containing the text extents (see above)

@ENDNODE

@NODE ccontextTextPath "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:TextPath -- add text to path

   @{b}SYNOPSIS@{ub}
        ccontext:TextPath(s$)

   @{b}FUNCTION@{ub}
        Adds closed paths for text to the current path. The generated path if
        filled, achieves an effect similar to that of @{"ccontext:ShowText()" LINK ccontextShowText}.

        Text conversion and positioning is done similar to @{"ccontext:ShowText()" LINK ccontextShowText}.

        Like @{"ccontext:ShowText()" LINK ccontextShowText}, after this call the current point is moved to
        the origin of where the next glyph would be placed in this same
        progression. That is, the current point will be at the origin of the
        final glyph offset by its advance values. This allows for chaining
        multiple calls to to ccontext:TextPath() without having to set current
        point in between.

        Note: The ccontext:TextPath() function call is part of what the Cairo
        designers call the "toy" text API. It is convenient for short demos and
        simple programs, but it is not expected to be adequate for serious
        text-using applications. See @{"ccontext:GlyphPath()" LINK ccontextGlyphPath} for the "real" text
        path API in Cairo.

   @{b}INPUTS@{ub}
        s$        string of text

@ENDNODE

@NODE ccontextTransform "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Transform -- modify current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:Transform(matrix)

   @{b}FUNCTION@{ub}
        Modifies the current transformation matrix (CTM) by applying "matrix" as
        an additional transformation. The new transformation of user space takes
        place after any existing transformation.

   @{b}INPUTS@{ub}
        matrix    a transformation matrix to be applied to the user-space axes

@ENDNODE

@NODE ccontextTranslate "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:Translate -- translate current transformation matrix

   @{b}SYNOPSIS@{ub}
        ccontext:Translate(tx, ty)

   @{b}FUNCTION@{ub}
        Modifies the current transformation matrix (CTM) by translating the
        user-space origin by ("tx", "ty"). This offset is interpreted as a
        user-space coordinate according to the CTM in place before the new call
        to ccontext:Translate(). In other words, the translation of the
        user-space origin takes place after any existing transformation.

   @{b}INPUTS@{ub}
        tx        amount to translate in the X direction
        ty        amount to translate in the Y direction

@ENDNODE

@NODE ccontextUpdateLayout "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:UpdateLayout -- update Pango layout

   @{b}SYNOPSIS@{ub}
        ccontext:UpdateLayout(layout)

   @{b}FUNCTION@{ub}
        Updates the private Pango context of a Pango layout created with
        @{"ccontext:PangoLayout()" LINK ccontextPangoLayout} to match the current transformation and target
        surface of a Cairo context.

   @{b}INPUTS@{ub}
        layout    a Pango layout from @{"ccontext:PangoLayout()" LINK ccontextPangoLayout}

@ENDNODE

@NODE ccontextUserToDevice "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:UserToDevice -- user to device

   @{b}SYNOPSIS@{ub}
        dx, dy = ccontext:UserToDevice(ux, uy)

   @{b}FUNCTION@{ub}
        Transform a coordinate from user space to device space by multiplying
        the given point by the current transformation matrix (CTM).

   @{b}INPUTS@{ub}
        ux        X value of coordinate (user space)
        uy        Y value of coordinate (user space)

   @{b}RESULTS@{ub}
        dx        X value of coordinate (device space)
        dy        Y value of coordinate (device space)

@ENDNODE

@NODE ccontextUserToDeviceDistance "Pangomonium Guide"

   @{b}NAME@{ub}
        ccontext:UserToDeviceDistance -- user to device distance

   @{b}SYNOPSIS@{ub}
        dx, dy = ccontext:UserToDeviceDistance(ux, uy)

   @{b}FUNCTION@{ub}
        Transform a distance vector from user space to device space. This
        function is similar to @{"ccontext:UserToDevice()" LINK ccontextUserToDevice} except that the
        translation components of the CTM will be ignored when transforming
        ("dx", "dy").

   @{b}INPUTS@{ub}
        ux        X component of a distance vector (user space)
        uy        Y component of a distance vector (user space)

   @{b}RESULTS@{ub}
        dx        X component of a distance vector (device space)
        dy        Y component of a distance vector (device space)

@ENDNODE

@NODE cfontfaceFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:Free -- free font face

   @{b}SYNOPSIS@{ub}
        cfontface:Free()

   @{b}FUNCTION@{ub}
        Decreases the reference count on the font face by one. If the result is
        zero, then the font face and all associated resources are freed. See
        @{"cfontface:Reference()" LINK cfontfaceReference}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cfontfaceGetFamily "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:GetFamily -- get family name

   @{b}SYNOPSIS@{ub}
        f$ = cfontface:GetFamily()

   @{b}FUNCTION@{ub}
        Gets the family name of a toy font.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        f$        the family name of the font

@ENDNODE

@NODE cfontfaceGetReferenceCount "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:GetReferenceCount -- get reference count

   @{b}SYNOPSIS@{ub}
        count = cfontface:GetReferenceCount()

   @{b}FUNCTION@{ub}
        Returns the current reference count of the font face.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the current reference count of the font face

@ENDNODE

@NODE cfontfaceGetSlant "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:GetSlant -- get font slant

   @{b}SYNOPSIS@{ub}
        slant = cfontface:GetSlant()

   @{b}FUNCTION@{ub}
        Gets the slant a toy font. This will be one of the following constants:

            #CAIRO_FONT_SLANT_NORMAL
            #CAIRO_FONT_SLANT_ITALIC
            #CAIRO_FONT_SLANT_OBLIQUE

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        slant     the slant value (see above)

@ENDNODE

@NODE cfontfaceGetType "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:GetType -- get font backend

   @{b}SYNOPSIS@{ub}
        type = cfontface:GetType()

   @{b}FUNCTION@{ub}
        This function returns the type of the backend used to create a font
        face. This will be one of the following constants:

        #CAIRO_FONT_TYPE_TOY
                  The font was created using cairo's toy font api.
        #CAIRO_FONT_TYPE_FT:
                  The font is of type FreeType.
        #CAIRO_FONT_TYPE_WIN32
                  The font is of type Win32.
        #CAIRO_FONT_TYPE_QUARTZ
                  The font is of type Quartz.
        #CAIRO_FONT_TYPE_USER
                  The font was create using cairo's user font api.
        #CAIRO_FONT_TYPE_DWRITE
                  The font is of type Win32 DWrite.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the font face type (see above)

@ENDNODE

@NODE cfontfaceGetWeight "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:GetWeight -- get font weight

   @{b}SYNOPSIS@{ub}
        weight = cfontface:GetWeight()

   @{b}FUNCTION@{ub}
        Gets the weight a toy font. This will be one of the following constants:

            #CAIRO_FONT_WEIGHT_NORMAL
            #CAIRO_FONT_WEIGHT_BOLD

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        weight    the weight value (see above)

@ENDNODE

@NODE cfontfaceIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:IsNull -- check if font face is invalid

   @{b}SYNOPSIS@{ub}
        bool = cfontface:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font face is NULL, i.e. invalid. If functions that
        allocate font faces fail, they might not throw an error but simply set
        the font face to NULL. You can use this function to check if font face
        allocation has failed in which case the font face will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the font face is NULL, otherwise FALSE

@ENDNODE

@NODE cfontfaceReference "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        cfontface:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the font face by one. This prevents the
        font face from being destroyed until a matching call to @{"cfontface:Free()" LINK cfontfaceFree}
        is made.

        Use @{"cfontface:GetReferenceCount()" LINK cfontfaceGetReferenceCount} to get the number of references to a
        Cairo font face.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cfontfaceStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontface:Status -- get font face status

   @{b}SYNOPSIS@{ub}
        status = cfontface:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this font face.

        This function returns #CAIRO_STATUS_SUCCESS or another error such as
        #CAIRO_STATUS_NO_MEMORY.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status code

@ENDNODE

@NODE cfontoptionsCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Copy -- copy font options object

   @{b}SYNOPSIS@{ub}
        handle = cfontoptions:Copy()

   @{b}FUNCTION@{ub}
        Allocates a new font options object copying the option values from the
        original.

        This function returns a newly allocated Cairo font options object. Free
        with @{"cfontoptions:Free()" LINK cfontoptionsFree}. This function always returns a valid handle;
        if memory cannot be allocated, then a special error object is returned
        where all operations on the object do nothing. You can check for this
        with @{"cfontoptions:Status()" LINK cfontoptionsStatus}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a newly allocated Cairo font options object

@ENDNODE

@NODE cfontoptionsEqual "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Equal -- check for equality

   @{b}SYNOPSIS@{ub}
        ok = cfontoptions:Equal(other)

   @{b}FUNCTION@{ub}
        Compares two font options objects for equality.

        This function returns TRUE if all fields of the two font options objects
        match. Note that this function will return FALSE if either object is in
        error.

   @{b}INPUTS@{ub}
        other     another Cairo font options object

   @{b}RESULTS@{ub}
        ok        TRUE if all fields of the two font options objects match

@ENDNODE

@NODE cfontoptionsFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Free -- free font options object

   @{b}SYNOPSIS@{ub}
        cfontoptions:Free()

   @{b}FUNCTION@{ub}
        Destroys a Cairo font options object object created with
        @{"cairo.FontOptions()" LINK cairoFontOptions} or @{"cfontoptions:Copy()" LINK cfontoptionsCopy}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cfontoptionsGetAntialias "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:GetAntialias -- get antialias mode

   @{b}SYNOPSIS@{ub}
        mode = cfontoptions:GetAntialias()

   @{b}FUNCTION@{ub}
        Gets the antialiasing mode for the font options object. See
        @{"ccontext:SetAntialias()" LINK ccontextSetAntialias} for a list of antialiasing modes.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mode      the antialiasing mode

@ENDNODE

@NODE cfontoptionsGetHintMetrics "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:GetHintMetrics -- get hint metrics

   @{b}SYNOPSIS@{ub}
        metrics = cfontoptions:GetHintMetrics()

   @{b}FUNCTION@{ub}
        Gets the metrics hinting mode for the font options object. See
        @{"cfontoptions:SetHintMetrics()" LINK cfontoptionsSetHintMetrics} for a list of hint metrics.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        metrics   the metrics hinting mode for the font options object

@ENDNODE

@NODE cfontoptionsGetHintStyle "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:GetHintStyle -- get hint style

   @{b}SYNOPSIS@{ub}
        style = cfontoptions:GetHintStyle()

   @{b}FUNCTION@{ub}
        Gets the hint style for font outlines for the font options object. See
        @{"cfontoptions:SetHintStyle()" LINK cfontoptionsSetHintStyle} for a list of hint styles.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        style     the hint style for the font options object

@ENDNODE

@NODE cfontoptionsGetSubpixelOrder "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:GetSubpixelOrder -- get subpixel order

   @{b}SYNOPSIS@{ub}
        order = cfontoptions:GetSubpixelOrder()

   @{b}FUNCTION@{ub}
        Gets the subpixel order for the font options object. See
        @{"cfontoptions:SetSubpixelOrder()" LINK cfontoptionsSetSubpixelOrder} for a list of subpixel orders.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        order     the subpixel order for the font options object

@ENDNODE

@NODE cfontoptionsGetVariations "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:GetVariations -- get font variations

   @{b}SYNOPSIS@{ub}
        v$ = cfontoptions:GetVariations()

   @{b}FUNCTION@{ub}
        Gets the OpenType font variations for the font options object. See
        @{"cfontoptions:SetVariations()" LINK cfontoptionsSetVariations} for details about the string format.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        v$        the font variations for the font options object

@ENDNODE

@NODE cfontoptionsHash "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Hash -- compute object hash

   @{b}SYNOPSIS@{ub}
        v = cfontoptions:Hash()

   @{b}FUNCTION@{ub}
        Compute a hash for the font options object; this value will be useful
        when storing an object containing a Cairo font options object in a hash
        table.

        This function returns the hash value for the font options object. The
        return value can be cast to a 32-bit type if a 32-bit hash value is
        needed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        v         the hash value for the font options object

@ENDNODE

@NODE cfontoptionsIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:IsNull -- check if font options object is invalid

   @{b}SYNOPSIS@{ub}
        bool = cfontoptions:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font options object is NULL, i.e. invalid. If
        functions that allocate objects fail, they might not throw an error but
        simply set the object to NULL. You can use this function to check if
        object allocation has failed in which case the object will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the object is NULL, otherwise FALSE

@ENDNODE

@NODE cfontoptionsMerge "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Merge -- merge font options

   @{b}SYNOPSIS@{ub}
        cfontoptions:Merge(other)

   @{b}FUNCTION@{ub}
        Merges non-default options from "other" into the font options object,
        replacing existing values. This operation can be thought of as somewhat
        similar to compositing "other" onto the font options object with the
        operation of #CAIRO_OPERATOR_OVER.

   @{b}INPUTS@{ub}
        other     another Cairo font options object

@ENDNODE

@NODE cfontoptionsSetAntialias "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:SetAntialias -- set antialias mode

   @{b}SYNOPSIS@{ub}
        cfontoptions:SetAntialias(antialias)

   @{b}FUNCTION@{ub}
        Sets the antialiasing mode for the font options object. This specifies
        the type of antialiasing to do when rendering text. See
        @{"ccontext:SetAntialias()" LINK ccontextSetAntialias} for a list of antialiasing modes.

   @{b}INPUTS@{ub}
        antialias the new antialiasing mode

@ENDNODE

@NODE cfontoptionsSetHintMetrics "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:SetHintMetrics -- set hint metrics

   @{b}SYNOPSIS@{ub}
        cfontoptions:SetHintMetrics(hint_metrics)

   @{b}FUNCTION@{ub}
        Sets the metrics hinting mode for the font options object. This controls
        whether metrics are quantized to integer values in device units.

        The following constants can be passed in the "hint_metrics" argument:

        #CAIRO_HINT_METRICS_DEFAULT
                  Hint metrics in the default manner for the font backend and
                  target device.
        #CAIRO_HINT_METRICS_OFF
                  Do not hint font metrics.
        #CAIRO_HINT_METRICS_ON
                  Hint font metrics.

   @{b}INPUTS@{ub}
        hint_metrics
                  the new metrics hinting mode

@ENDNODE

@NODE cfontoptionsSetHintStyle "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:SetHintStyle -- set hint style

   @{b}SYNOPSIS@{ub}
        cfontoptions:SetHintStyle(hint_style)

   @{b}FUNCTION@{ub}
        Sets the hint style for font outlines for the font options object. This
        controls whether to fit font outlines to the pixel grid, and if so,
        whether to optimize for fidelity or contrast.

        The following constants can be passed in the "hint_style" argument:

        #CAIRO_HINT_STYLE_DEFAULT
                  Use the default hint style for font backend and target device.
        #CAIRO_HINT_STYLE_NONE
                  Do not hint outlines.
        #CAIRO_HINT_STYLE_SLIGHT
                  Hint outlines slightly to improve contrast while retaining
                  good fidelity to the original shapes.
        #CAIRO_HINT_STYLE_MEDIUM
                  Hint outlines with medium strength giving a compromise between
                  fidelity to the original shapes and contrast.
        #CAIRO_HINT_STYLE_FULL
                  Hint outlines to maximize contrast.

   @{b}INPUTS@{ub}
        hint_style
                  the new hint style

@ENDNODE

@NODE cfontoptionsSetSubpixelOrder "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:SetSubpixelOrder -- set subpixel order

   @{b}SYNOPSIS@{ub}
        cfontoptions:SetSubpixelOrder(subpixel_order)

   @{b}FUNCTION@{ub}
        Sets the subpixel order for the font options object. The subpixel order
        specifies the order of color elements within each pixel on the display
        device when rendering with an antialiasing mode of
        #CAIRO_ANTIALIAS_SUBPIXEL.

        The following constants can be passed in the "subpixel_order" argument:

        #CAIRO_SUBPIXEL_ORDER_DEFAULT
                  Use the default subpixel order for for the target device.
        #CAIRO_SUBPIXEL_ORDER_RGB
                  Subpixel elements are arranged horizontally with red at the
                  left.
        #CAIRO_SUBPIXEL_ORDER_BGR
                  Subpixel elements are arranged horizontally with blue at the
                  left.
        #CAIRO_SUBPIXEL_ORDER_VRGB
                  Subpixel elements are arranged vertically with red at the top.
        #CAIRO_SUBPIXEL_ORDER_VBGR
                  Subpixel elements are arranged vertically with blue at the
                  top.

   @{b}INPUTS@{ub}
        subpixel_order
                  the new subpixel order

@ENDNODE

@NODE cfontoptionsSetVariations "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:SetVariations -- set variations

   @{b}SYNOPSIS@{ub}
        cfontoptions:SetVariations(variations$)

   @{b}FUNCTION@{ub}
        Sets the OpenType font variations for the font options object. Font
        variations are specified as a string with a format that is similar to
        the CSS font-variation-settings. The string contains a comma-separated
        list of axis assignments, which each assignment consists of a
        4-character axis name and a value, separated by whitespace and optional
        equals sign.

        Examples:

            wght=200,wdth=140.5
            wght 200 , wdth 140.5

   @{b}INPUTS@{ub}
        variations$
                  the new font variations

@ENDNODE

@NODE cfontoptionsStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        cfontoptions:Status -- get font options status

   @{b}SYNOPSIS@{ub}
        status = cfontoptions:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this font options
        object

        This function returns #CAIRO_STATUS_SUCCESS, #CAIRO_STATUS_NO_MEMORY, or
        #CAIRO_STATUS_NULL_POINTER.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status code (see above)

@ENDNODE

@NODE cglyphsFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cglyphs:Free -- free glyphs array

   @{b}SYNOPSIS@{ub}
        cglyphs:Free()

   @{b}FUNCTION@{ub}
        Frees a glyphs array allocated by @{"cairo.Glyphs()" LINK cairoGlyphs}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cglyphsGet "Pangomonium Guide"

   @{b}NAME@{ub}
        cglyphs:Get -- get glyph index and offset

   @{b}SYNOPSIS@{ub}
        index, x, y = cglyphs:Get(n)

   @{b}FUNCTION@{ub}
        Returns information about the glyph at index "n" in the glyphs array.
        The "index" return value specifies the glyph index in the font. The
        exact interpretation of the glyph index depends on the font technology
        being used. "x" and "y" specify the offset in the X and Y direction
        between the origin used for drawing or measuring the string and the
        origin of this glyph.

   @{b}INPUTS@{ub}
        n         which glyph to get

   @{b}RESULTS@{ub}
        index     glyph ID
        x         x offset of the glyph
        y         y offset of the glyph

@ENDNODE

@NODE cglyphsSet "Pangomonium Guide"

   @{b}NAME@{ub}
        cglyphs:Set -- set glyph index and offset

   @{b}SYNOPSIS@{ub}
        cglyphs:Set(n, index, x, y)

   @{b}FUNCTION@{ub}
        Set information about the glyph at index "n" in the glyphs array.
        "index" specifies the glyph index in the font. The exact interpretation
        of the glyph index depends on the font technology being used. "x" and
        "y" specify the offset in the X and Y direction between the origin used
        for drawing or measuring the string and the origin of this glyph.

   @{b}INPUTS@{ub}
        n         glyph to set
        index     glyph ID
        x         x offset of the glyph
        y         y offset of the glyph

@ENDNODE

@NODE cmatrixGet "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Get -- get matrix affine transformation

   @{b}SYNOPSIS@{ub}
        xx, yx, xy, yy, x0, y0 = cmatrix:Get()

   @{b}FUNCTION@{ub}
        Gets the affine transformation from the matrix and returns it.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        xx        xx component of the affine transformation
        yx        yx component of the affine transformation
        xy        xy component of the affine transformation
        yy        yy component of the affine transformation
        x0        X translation component of the affine transformation
        y0        Y translation component of the affine transformation

@ENDNODE

@NODE cmatrixInit "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Init -- init matrix

   @{b}SYNOPSIS@{ub}
        cmatrix:Init(xx, yx, xy, yy, x0, y0)

   @{b}FUNCTION@{ub}
        Sets "matrix" to be the affine transformation given by "xx", "yx", "xy",
        "yy", "x0", "y0". The transformation is given by:

            x_new = xx * x + xy * y + x0;
            y_new = yx * x + yy * y + y0;

   @{b}INPUTS@{ub}
        xx        xx component of the affine transformation
        yx        yx component of the affine transformation
        xy        xy component of the affine transformation
        yy        yy component of the affine transformation
        x0        X translation component of the affine transformation
        y0        Y translation component of the affine transformation

@ENDNODE

@NODE cmatrixInitIdentity "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:InitIdentity -- init identity

   @{b}SYNOPSIS@{ub}
        cmatrix:InitIdentity()

   @{b}FUNCTION@{ub}
        Modifies the matrix to be an identity transformation.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cmatrixInitRotate "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:InitRotate -- init rotate

   @{b}SYNOPSIS@{ub}
        cmatrix:InitRotate(radians)

   @{b}FUNCTION@{ub}
        Initializes the matrix to a transformation that rotates by "radians".
        The direction of rotation is defined such that positive angles rotate in
        the direction from the positive X axis toward the positive Y axis. With
        the default axis orientation of Cairo, positive angles rotate in a
        clockwise direction.

   @{b}INPUTS@{ub}
        radians   angle of rotation in radians

@ENDNODE

@NODE cmatrixInitScale "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:InitScale -- init scale

   @{b}SYNOPSIS@{ub}
        cmatrix:InitScale(sx, sy)

   @{b}FUNCTION@{ub}
        Initializes the matrix to a transformation that scales by "sx" and "sy"
        in the X and Y dimensions, respectively.

   @{b}INPUTS@{ub}
        sx        scale factor in the X direction
        sy        scale factor in the Y direction

@ENDNODE

@NODE cmatrixInitTranslate "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:InitTranslate -- init translate

   @{b}SYNOPSIS@{ub}
        cmatrix:InitTranslate(tx, ty)

   @{b}FUNCTION@{ub}
        Initializes matrix to a transformation that translates by "tx" and "ty"
        in the X and Y dimensions, respectively.

   @{b}INPUTS@{ub}
        tx        amount to translate in the X direction
        ty        amount to translate in the Y direction

@ENDNODE

@NODE cmatrixInvert "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Invert -- invert matrix

   @{b}SYNOPSIS@{ub}
        status = cmatrix:Invert()

   @{b}FUNCTION@{ub}
        Changes the matrix to be the inverse of its original value. Not all
        transformation matrices have inverses; if the matrix collapses points
        together (it is degenerate), then it has no inverse and this function
        will fail.

        If the matrix has an inverse, modifies the matrix to be the inverse
        matrix and returns #CAIRO_STATUS_SUCCESS. Otherwise, returns
        #CAIRO_STATUS_INVALID_MATRIX.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    status code indicating success or error (see above)

@ENDNODE

@NODE cmatrixMultiply "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Multiply -- multiply matrix

   @{b}SYNOPSIS@{ub}
        cmatrix:Multiply(a, b)

   @{b}FUNCTION@{ub}
        Multiplies the affine transformations in "a" and "b" together and stores
        the result in the target matrix. The effect of the resulting
        transformation is to first apply the transformation in "a" to the
        coordinates and then apply the transformation in "b" to the coordinates.

        It is allowable for the target matrix to be identical to either "a" or
        "b".

   @{b}INPUTS@{ub}
        a         a Cairo matrix
        b         a Cairo matrix

@ENDNODE

@NODE cmatrixRotate "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Rotate -- rotate matrix

   @{b}SYNOPSIS@{ub}
        cmatrix:Rotate(radians)

   @{b}FUNCTION@{ub}
        Applies rotation by "radians" to the transformation in the matrix. The
        effect of the new transformation is to first rotate the coordinates by
        "radians", then apply the original transformation to the coordinates.

        The direction of rotation is defined such that positive angles rotate in
        the direction from the positive X axis toward the positive Y axis. With
        the default axis orientation of cairo, positive angles rotate in a
        clockwise direction.

   @{b}INPUTS@{ub}
        radians   angle of rotation in radians

@ENDNODE

@NODE cmatrixScale "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Scale -- scale matrix

   @{b}SYNOPSIS@{ub}
        cmatrix:Scale(sx, sy)

   @{b}FUNCTION@{ub}
        Applies scaling by "sx", "sy" to the transformation in the matrix. The
        effect of the new transformation is to first scale the coordinates by
        "sx" and "sy", then apply the original transformation to the
        coordinates.

   @{b}INPUTS@{ub}
        sx        scale factor in the X direction
        sy        scale factor in the Y direction

@ENDNODE

@NODE cmatrixTransformDistance "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:TransformDistance -- transform distance vector

   @{b}SYNOPSIS@{ub}
        tx, ty = cmatrix:TransformDistance(dx, dy)

   @{b}FUNCTION@{ub}
        Transforms the distance vector ("dx", "dy") by the matrix. This is
        similar to @{"cmatrix:TransformPoint()" LINK cmatrixTransformPoint} except that the translation
        components of the transformation are ignored. The calculation of the
        returned vector is as follows:

            dx2 = dx1 * a + dy1 * c;
            dy2 = dx1 * b + dy1 * d;

        Affine transformations are position invariant, so the same vector always
        transforms to the same vector. If ("x1", "y1") transforms to ("x2",
        "y2") then ("x1+§dx1", "y1+§dy1") will transform to ("x1+§dx2",
        "y1+§dy2") for all values of "x1" and "x2".

   @{b}INPUTS@{ub}
        dx        X component of a distance vector
        dy        Y component of a distance vector

   @{b}RESULTS@{ub}
        tx        transformed X component of a distance vector
        ty        transformed Y component of a distance vector

@ENDNODE

@NODE cmatrixTransformPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:TransformPoint -- transform point

   @{b}SYNOPSIS@{ub}
        tx, ty = cmatrix:TransformPoint(x, y)

   @{b}FUNCTION@{ub}
        Transforms the point ("x", "y") by the matrix.

   @{b}INPUTS@{ub}
        x         X position
        y         Y position

   @{b}RESULTS@{ub}
        tx        transformed X position
        ty        transformed Y position

@ENDNODE

@NODE cmatrixTranslate "Pangomonium Guide"

   @{b}NAME@{ub}
        cmatrix:Translate -- translate matrix

   @{b}SYNOPSIS@{ub}
        cmatrix:Translate(tx, ty)

   @{b}FUNCTION@{ub}
        Applies a translation by "tx", "ty" to the transformation in the matrix.
        The effect of the new transformation is to first translate the
        coordinates by "tx" and "ty", then apply the original transformation to
        the coordinates.

   @{b}INPUTS@{ub}
        tx        amount to translate in the X direction
        ty        amount to translate in the Y direction

@ENDNODE

@NODE cpathFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cpath:Free -- free path

   @{b}SYNOPSIS@{ub}
        cpath:Free()

   @{b}FUNCTION@{ub}
        Frees a path allocated by @{"cairo.Path()" LINK cairoPath}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cpathGet "Pangomonium Guide"

   @{b}NAME@{ub}
        cpath:Get -- get path

   @{b}SYNOPSIS@{ub}
        t = cpath:Get()

   @{b}FUNCTION@{ub}
        Returns the individual items that make up the path. The individual path
        items are returned as a table containing a number of subtables each
        describing a single path item. See @{"cairo.Path()" LINK cairoPath} for a description of the
        valid fields in the subtables.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing all path items

@ENDNODE

@NODE cpatternAddColorStopRGB "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:AddColorStopRGB -- add RGB color stop

   @{b}SYNOPSIS@{ub}
        cpattern:AddColorStopRGB(offset, red, green, blue)

   @{b}FUNCTION@{ub}
        Adds an opaque color stop to a gradient pattern. The offset specifies
        the location along the gradient's control vector. For example, a linear
        gradient's control vector is from (x0,y0) to (x1,y1) while a radial
        gradient's control vector is from any point on the start circle to the
        corresponding point on the end circle.

        The color is specified in the same way as in @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB}.

        If two (or more) stops are specified with identical offset values, they
        will be sorted according to the order in which the stops are added
        (stops added earlier will compare less than stops added later). This can
        be useful for reliably making sharp color transitions instead of the
        typical blend.

        Note: If the pattern is not a gradient pattern, (e.g. a linear or radial
        pattern), then the pattern will be put into an error status with a
        status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH.

   @{b}INPUTS@{ub}
        offset    an offset in the range [0.0 .. 1.0]
        red       red component of color
        green     green component of color
        blue      blue component of color

@ENDNODE

@NODE cpatternAddColorStopRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:AddColorStopRGBA -- add RGBA color stop

   @{b}SYNOPSIS@{ub}
        cpattern:AddColorStopRGBA(offset, red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        Adds a translucent color stop to a gradient pattern. The offset
        specifies the location along the gradient's control vector. For example,
        a linear gradient's control vector is from (x0,y0) to (x1,y1) while a
        radial gradient's control vector is from any point on the start circle
        to the corresponding point on the end circle.

        The color is specified in the same way as in @{"ccontext:SetSourceRGBA()" LINK ccontextSetSourceRGBA}.

        If two (or more) stops are specified with identical offset values, they
        will be sorted according to the order in which the stops are added
        (stops added earlier will compare less than stops added later). This can
        be useful for reliably making sharp color transitions instead of the
        typical blend.

        Note: If the pattern is not a gradient pattern, (e.g. a linear or radial
        pattern), then the pattern will be put into an error status with a
        status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH.

   @{b}INPUTS@{ub}
        offset    an offset in the range [0.0 .. 1.0]
        red       red component of color
        green     green component of color
        blue      blue component of color
        alpha     alpha component of color

@ENDNODE

@NODE cpatternBeginPatch "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:BeginPatch -- begin patch

   @{b}SYNOPSIS@{ub}
        cpattern:BeginPatch()

   @{b}FUNCTION@{ub}
        Begin a patch in a mesh pattern.

        After calling this function, the patch shape should be defined with
        @{"cpattern:MoveTo()" LINK cpatternMoveTo}, @{"cpattern:LineTo()" LINK cpatternLineTo} and @{"cpattern:CurveTo()" LINK cpatternCurveTo}.

        After defining the patch, @{"cpattern:EndPatch()" LINK cpatternEndPatch} must be called before
        using the pattern as a source or mask.

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        the pattern already has a current patch, it will be put into an error
        status with a status of #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cpatternCurveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:CurveTo -- add cubic Bezier spline

   @{b}SYNOPSIS@{ub}
        cpattern:CurveTo(x1, y1, x2, y2, x3, y3)

   @{b}FUNCTION@{ub}
        Adds a cubic Bezier spline to the current patch from the current point
        to position ("x3", "y3") in pattern-space coordinates, using ("x1",
        "y1") and ("x2", "y2") as the control points.

        If the current patch has no current point before the call to
        cpattern:CurveTo(), this function will behave as if preceded by a call
        to @{"cpattern:MoveTo()" LINK cpatternMoveTo} with "x1" and "y1" as parameters.

        After this call the current point will be ("x3", "y3").

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        the pattern has no current patch or the current patch already has 4
        sides, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        x1        the X coordinate of the first control point
        y1        the Y coordinate of the first control point
        x2        the X coordinate of the second control point
        y2        the Y coordinate of the second control point
        x3        the X coordinate of the end of the curve
        y3        the Y coordinate of the end of the curve

@ENDNODE

@NODE cpatternEndPatch "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:EndPatch -- end patch

   @{b}SYNOPSIS@{ub}
        cpattern:EndPatch()

   @{b}FUNCTION@{ub}
        Indicates the end of the current patch in a mesh pattern.

        If the current patch has less than 4 sides, it is closed with a straight
        line from the current point to the first point of the patch as if
        @{"cpattern:LineTo()" LINK cpatternLineTo} was used.

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        the pattern has no current patch or the current patch already has 4
        sides, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cpatternFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:Free -- free pattern

   @{b}SYNOPSIS@{ub}
        cpattern:Free()

   @{b}FUNCTION@{ub}
        Decreases the reference count on the pattern by one. If the result is
        zero, then the pattern and all associated resources are freed. See
        @{"cpattern:Reference()" LINK cpatternReference}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cpatternGetColorStopCount "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetColorStopCount -- get color stop count

   @{b}SYNOPSIS@{ub}
        status, count = cpattern:GetColorStopCount()

   @{b}FUNCTION@{ub}
        Gets the number of color stops specified in the given gradient pattern.

        This function returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a gradient
        pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    status code (see above)
        count     number of color stops

@ENDNODE

@NODE cpatternGetColorStopRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetColorStopRGBA -- get color stop RGBA

   @{b}SYNOPSIS@{ub}
        status, offset, r, g, b, a = cpattern:GetColorStopRGBA(index)

   @{b}FUNCTION@{ub}
        Gets the color and offset information at the given "index" for a
        gradient pattern. Values of "index" range from 0 to n-1 where n is the
        number returned by @{"cpattern:GetColorStopCount()" LINK cpatternGetColorStopCount}.

        Note that the color and alpha values are not premultiplied.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_INVALID_INDEX if "index" is not valid for the given
        pattern. If the pattern is not a gradient pattern,
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH is returned.

   @{b}INPUTS@{ub}
        index     index of the stop to return data for

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_INVALID_INDEX
        offset    offset of the stop
        r         red component of color
        g         green component of color
        b         blue component of color
        a         alpha component of color

@ENDNODE

@NODE cpatternGetControlPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetControlPoint -- get control point

   @{b}SYNOPSIS@{ub}
        status, x, y = cpattern:GetControlPoint(patch_num, point_num)

   @{b}FUNCTION@{ub}
        Gets the control point "point_num" of patch "patch_num" for a mesh
        pattern.

        "patch_num" can range from 0 to n-1 where "n" is the number returned by
        @{"cpattern:GetPatchCount()" LINK cpatternGetPatchCount}.

        Valid values for "point_num" are from 0 to 3 and identify the control
        points as explained in @{"cairo.PatternMesh()" LINK cairoPatternMesh}.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_INVALID_INDEX if "patch_num" or "point_num" is not valid
        for the pattern. If the pattern is not a mesh pattern,
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH is returned.

   @{b}INPUTS@{ub}
        patch_num the patch number to return data for
        point_num the control point number to return data for

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_INVALID_INDEX
        x         x coordinate of the control point
        y         y coordinate of the control point

@ENDNODE

@NODE cpatternGetCornerColorRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetCornerColorRGBA -- get corner color RGBA

   @{b}SYNOPSIS@{ub}
        status, r, g, b, a = cpattern:GetCornerColorRGBA(patch_num, corner_num)

   @{b}FUNCTION@{ub}
        Gets the color information in corner "corner_num" of patch "patch_num"
        for a mesh pattern.

        "patch_num" can range from 0 to n-1 where "n" is the number returned by
        @{"cpattern:GetPatchCount()" LINK cpatternGetPatchCount}.

        Valid values for "corner_num" are from 0 to 3 and identify the corners
        as explained in @{"cairo.PatternMesh()" LINK cairoPatternMesh}.

        Note that the color and alpha values are not premultiplied.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_INVALID_INDEX if "patch_num" or "corner_num" is not valid
        for the pattern. If the pattern is not a mesh pattern,
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH is returned.

   @{b}INPUTS@{ub}
        patch_num the patch number to return data for
        corner_num
                  the corner number to return data for

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_INVALID_INDEX
        r         red component of color
        g         green component of color
        b         blue component of color
        a         alpha component of color

@ENDNODE

@NODE cpatternGetExtend "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetExtend -- get extend mode

   @{b}SYNOPSIS@{ub}
        mode = cpattern:GetExtend()

   @{b}FUNCTION@{ub}
        Gets the current extend mode for a pattern. See @{"cpattern:SetExtend()" LINK cpatternSetExtend} for
        details on the semantics of each extend strategy.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mode      the current extend strategy used for drawing the pattern

@ENDNODE

@NODE cpatternGetFilter "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetFilter -- get filter

   @{b}SYNOPSIS@{ub}
        filter = cpattern:GetFilter()

   @{b}FUNCTION@{ub}
        Gets the current filter for a pattern. See @{"cpattern:SetFilter()" LINK cpatternSetFilter} for
        details on each filter.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        filter    the current filter used for resizing the pattern

@ENDNODE

@NODE cpatternGetLinearPoints "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetLinearPoints -- get gradient endpoints

   @{b}SYNOPSIS@{ub}
        status, x0, y0, x1, y1 = cpattern:GetLinearPoints()

   @{b}FUNCTION@{ub}
        Gets the gradient endpoints for a linear gradient.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a linear
        gradient pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
        x0        x coordinate of the first point
        y0        y coordinate of the first point
        x1        x coordinate of the second point
        y1        y coordinate of the second point

@ENDNODE

@NODE cpatternGetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetMatrix -- get pattern's transformation matrix

   @{b}SYNOPSIS@{ub}
        m = cpattern:GetMatrix(matrix)

   @{b}FUNCTION@{ub}
        Returns the pattern's transformation matrix.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         current transformation matrix

@ENDNODE

@NODE cpatternGetPatchCount "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetPatchCount -- get patch count

   @{b}SYNOPSIS@{ub}
        status, count = cpattern:GetPatchCount()

   @{b}FUNCTION@{ub}
        Gets the number of patches specified in the given mesh pattern.

        The number only includes patches which have been finished by calling
        @{"cpattern:EndPatch()" LINK cpatternEndPatch}. For example it will be 0 during the definition of
        the first patch.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a mesh
        pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
        count     number of patches

@ENDNODE

@NODE cpatternGetRadialCircles "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetRadialCircles -- get radial circles

   @{b}SYNOPSIS@{ub}
        status, x0, y0, r0, x1, y1, r1 = cpattern:GetRadialCircles()

   @{b}FUNCTION@{ub}
        Gets the gradient endpoint circles for a radial gradient, each specified
        as a center coordinate and a radius.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a radial
        gradient pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x         #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
        x0        x coordinate of the center of the first circle
        y0        y coordinate of the center of the first circle
        r0        radius of the first circle
        x1        x coordinate of the center of the second circle
        y1        y coordinate of the center of the second circle
        r1        radius of the second circle

@ENDNODE

@NODE cpatternGetReferenceCount "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetReferenceCount -- get reference count

   @{b}SYNOPSIS@{ub}
        count = cpattern:GetReferenceCount()

   @{b}FUNCTION@{ub}
        Returns the current reference count of the pattern.

        This function returns the current reference count of the pattern. If the
        object is a nil object, 0 will be returned.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the current reference count of the pattern

@ENDNODE

@NODE cpatternGetRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetRGBA -- get RGBA

   @{b}SYNOPSIS@{ub}
        status, red, green, blue, alpha = cpattern:GetRGBA()

   @{b}FUNCTION@{ub}
        Gets the solid color for a solid color pattern.

        Note that the color and alpha values are not premultiplied.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a solid color
        pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
        red       red component of color
        green     green component of color
        blue      blue component of color
        alpha     alpha component of color

@ENDNODE

@NODE cpatternGetSurface "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetSurface -- get pattern surface

   @{b}SYNOPSIS@{ub}
        status, surface = cpattern:GetSurface()

   @{b}FUNCTION@{ub}
        Gets the surface of a surface pattern. The reference returned is owned
        by the pattern; the caller should call @{"csurface:Reference()" LINK csurfaceReference} if the
        surface is to be retained.

        This function also returns #CAIRO_STATUS_SUCCESS, or
        #CAIRO_STATUS_PATTERN_TYPE_MISMATCH if the pattern is not a surface
        pattern.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_PATTERN_TYPE_MISMATCH
        surface   surface of pattern

@ENDNODE

@NODE cpatternGetType "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:GetType -- get type

   @{b}SYNOPSIS@{ub}
        type = cpattern:GetType()

   @{b}FUNCTION@{ub}
        Get the pattern's type. This will be one of the following types:

        #CAIRO_PATTERN_TYPE_SOLID
                  The pattern is a solid (uniform) color. It may be opaque or
                  translucent.
        #CAIRO_PATTERN_TYPE_SURFACE
                  The pattern is a based on a surface (an image).
        #CAIRO_PATTERN_TYPE_LINEAR
                  The pattern is a linear gradient.
        #CAIRO_PATTERN_TYPE_RADIAL
                  The pattern is a radial gradient.
        #CAIRO_PATTERN_TYPE_MESH
                  The pattern is a mesh.
        #CAIRO_PATTERN_TYPE_RASTER_SOURCE
                  The pattern is a user pattern providing raster data.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the type of the pattern

@ENDNODE

@NODE cpatternIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:IsNull -- check if pattern is invalid

   @{b}SYNOPSIS@{ub}
        bool = cpattern:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the pattern is NULL, i.e. invalid. If functions that
        allocate patterns fail, they might not throw an error but simply set the
        pattern to NULL. You can use this function to check if pattern
        allocation has failed in which case the pattern will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the pattern is NULL, otherwise FALSE

@ENDNODE

@NODE cpatternLineTo "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:LineTo -- add line to patch

   @{b}SYNOPSIS@{ub}
        cpattern:LineTo(x, y)

   @{b}FUNCTION@{ub}
        Adds a line to the current patch from the current point to position
        ("x", "y") in pattern-space coordinates.

        If there is no current point before the call to cpattern:LineTo() this
        function will behave as @{"cpattern:MoveTo()" LINK cpatternMoveTo} with the arguments "x" and
        "y".

        After this call the current point will be ("x", "y").

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        the pattern has no current patch or the current patch already has 4
        sides, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        x         the X coordinate of the end of the new line
        y         the Y coordinate of the end of the new line

@ENDNODE

@NODE cpatternMoveTo "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:MoveTo -- move to point

   @{b}SYNOPSIS@{ub}
        cpattern:MoveTo(x, y)

   @{b}FUNCTION@{ub}
        Define the first point of the current patch in a mesh pattern.

        After this call the current point will be ("x", "y").

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        the pattern has no current patch or the current patch already has 4
        sides, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        x         the X coordinate of the new position
        y         the Y coordinate of the new position

@ENDNODE

@NODE cpatternReference "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        cpattern:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the pattern by one. This prevents the
        pattern from being destroyed until a matching call to @{"cpattern:Free()" LINK cpatternFree} is
        made.

        Use @{"cpattern:GetReferenceCount()" LINK cpatternGetReferenceCount} to get the number of references to a
        Cairo pattern.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cpatternSetControlPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetControlPoint -- set control point

   @{b}SYNOPSIS@{ub}
        cpattern:SetControlPoint(point_num, x, y)

   @{b}FUNCTION@{ub}
        Set an internal control point of the current patch.

        Valid values for "point_num" are from 0 to 3 and identify the control
        points as explained in @{"cairo.PatternMesh()" LINK cairoPatternMesh}.

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        "point_num" is not valid, the pattern will be put into an error status
        with a status of #CAIRO_STATUS_INVALID_INDEX. If the pattern has no
        current patch, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        point_num the control point to set the position for
        x         the X coordinate of the control point
        y         the Y coordinate of the control point

@ENDNODE

@NODE cpatternSetCornerColorRGB "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetCornerColorRGB -- set corner color RGB

   @{b}SYNOPSIS@{ub}
        cpattern:SetCornerColorRGB(corner_num, red, green, blue)

   @{b}FUNCTION@{ub}
        Sets the color of a corner of the current patch in a mesh pattern.

        The color is specified in the same way as in @{"ccontext:SetSourceRGB()" LINK ccontextSetSourceRGB}.

        Valid values for "corner_num" are from 0 to 3 and identify the corners
        as explained in @{"cairo.PatternMesh()" LINK cairoPatternMesh}.

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        "corner_num" is not valid, the pattern will be put into an error status
        with a status of #CAIRO_STATUS_INVALID_INDEX. If the pattern has no
        current patch, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        corner_num
                  the corner to set the color for
        red       red component of color
        green     green component of color
        blue      blue component of color

@ENDNODE

@NODE cpatternSetCornerColorRGBA "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetCornerColorRGBA -- set corner color RGBA

   @{b}SYNOPSIS@{ub}
        cpattern:SetCornerColorRGBA(corner_num, red, green, blue, alpha)

   @{b}FUNCTION@{ub}
        Sets the color of a corner of the current patch in a mesh pattern.

        The color is specified in the same way as in @{"ccontext:SetSourceRGBA()" LINK ccontextSetSourceRGBA}.

        Valid values for "corner_num" are from 0 to 3 and identify the corners
        as explained in @{"cairo.PatternMesh()" LINK cairoPatternMesh}.

        Note: If the pattern is not a mesh pattern then it will be put into an
        error status with a status of #CAIRO_STATUS_PATTERN_TYPE_MISMATCH. If
        "corner_num" is not valid, the pattern will be put into an error status
        with a status of #CAIRO_STATUS_INVALID_INDEX. If the pattern has no
        current patch, it will be put into an error status with a status of
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        corner_num
                  the corner to set the color for
        red       red component of color
        green     green component of color
        blue      blue component of color
        alpha     alpha component of color

@ENDNODE

@NODE cpatternSetExtend "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetExtend -- set extend mode

   @{b}SYNOPSIS@{ub}
        cpattern:SetExtend(extend)

   @{b}FUNCTION@{ub}
        Sets the mode to be used for drawing outside the area of a pattern. The
        "extend" parameter can be set to one of the following constants:

        #CAIRO_EXTEND_NONE
                  Pixels outside of the source pattern are fully transparent.
        #CAIRO_EXTEND_REPEAT
                  The pattern is tiled by repeating.
        #CAIRO_EXTEND_REFLECT
                  The pattern is tiled by reflecting at the edges.
        #CAIRO_EXTEND_PAD
                  Pixels outside of the pattern copy the closest pixel from the
                  source.

        The default extend mode is #CAIRO_EXTEND_NONE for surface patterns and
        #CAIRO_EXTEND_PAD for gradient patterns.

   @{b}INPUTS@{ub}
        extend    extend mode describing how the area outside of the pattern
                  will be drawn (see above)

@ENDNODE

@NODE cpatternSetFilter "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetFilter -- set filter

   @{b}SYNOPSIS@{ub}
        cpattern:SetFilter(filter)

   @{b}FUNCTION@{ub}
        Sets the filter to be used for resizing when using this pattern. The
        "filter" parameter can be set to one of the following constants:

        #CAIRO_FILTER_FAST
                  A high-performance filter, with quality similar to
                  #CAIRO_FILTER_NEAREST.
        #CAIRO_FILTER_GOOD
                  A reasonable-performance filter, with quality similar to
                  #CAIRO_FILTER_BILINEAR.
        #CAIRO_FILTER_BEST
                  The highest-quality available, performance may not be suitable
                  for interactive use.
        #CAIRO_FILTER_NEAREST
                  Nearest-neighbor filtering.
        #CAIRO_FILTER_BILINEAR
                  Linear interpolation in two dimensions.
        #CAIRO_FILTER_GAUSSIAN
                  This filter value is currently unimplemented, and should not
                  be used in current code.

        Note that you might want to control filtering even when you do not have
        an explicit Cairo pattern object, for example when using
        @{"ccontext:SetSourceSurface()" LINK ccontextSetSourceSurface}. In these cases, it is convenient to use
        @{"ccontext:GetSource()" LINK ccontextGetSource} to get access to the pattern that cairo creates
        implicitly. For example:

            ctx:SetSourceSurface(image, x, y)
            pat = ctx:GetSource()
            pat:SetFilter(#CAIRO_FILTER_NEAREST)

   @{b}INPUTS@{ub}
        filter    filter to use for resizing the pattern

@ENDNODE

@NODE cpatternSetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:SetMatrix -- set matrix

   @{b}SYNOPSIS@{ub}
        cpattern:SetMatrix(matrix)

   @{b}FUNCTION@{ub}
        Sets the pattern's transformation matrix to "matrix". This matrix is a
        transformation from user space to pattern space.

        When a pattern is first created it always has the identity matrix for
        its transformation matrix, which means that pattern space is initially
        identical to user space.

        Important: Please note that the direction of this transformation matrix
        is from user space to pattern space. This means that if you imagine the
        flow from a pattern to user space (and on to device space), then
        coordinates in that flow will be transformed by the inverse of the
        pattern matrix.

        For example, if you want to make a pattern appear twice as large as it
        does by default the correct code to use is:

            m = cairo.Matrix()
            m:InitScale(0.5, 0.5)
            pat:SetMatrix(m)

        Meanwhile, using values of 2.0 rather than 0.5 in the code above would
        cause the pattern to appear at half of its default size.

        Also, please note the discussion of the user-space locking semantics of
        @{"ccontext:SetSource()" LINK ccontextSetSource}.

   @{b}INPUTS@{ub}
        matrix    a Cairo matrix object

@ENDNODE

@NODE cpatternStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        cpattern:Status -- get pattern status

   @{b}SYNOPSIS@{ub}
        cpattern:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this pattern.

        This function returns #CAIRO_STATUS_SUCCESS, #CAIRO_STATUS_NO_MEMORY,
        #CAIRO_STATUS_INVALID_MATRIX, #CAIRO_STATUS_PATTERN_TYPE_MISMATCH, or
        #CAIRO_STATUS_INVALID_MESH_CONSTRUCTION.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status value (see above)

@ENDNODE

@NODE cregionContainsPoint "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:ContainsPoint -- check if point is in region

   @{b}SYNOPSIS@{ub}
        ok = cregion:ContainsPoint(x, y)

   @{b}FUNCTION@{ub}
        Checks whether ("x", "y") is contained in the region.

   @{b}INPUTS@{ub}
        x         the x coordinate of a point
        y         the y coordinate of a point

   @{b}RESULTS@{ub}
        ok        TRUE if ("x", "y") is contained in the region, FALSE if it is
                  not

@ENDNODE

@NODE cregionContainsRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:ContainsRectangle -- check if rectangle is in region

   @{b}SYNOPSIS@{ub}
        overlap = cregion:ContainsRectangle(rectangle)

   @{b}FUNCTION@{ub}
        Checks whether "rectangle" is inside, outside or partially contained in
        the region. The "rectangle" parameter must be a table that has the
        fields "x", "y", "width", and "height" initialized.

        This function returns #CAIRO_REGION_OVERLAP_IN if "rectangle" is
        entirely inside the region, #CAIRO_REGION_OVERLAP_OUT if "rectangle" is
        entirely outside the region, or #CAIRO_REGION_OVERLAP_PART if
        "rectangle" is partially inside and partially outside the region.

   @{b}INPUTS@{ub}
        rectangle a table describing a rectangle (see above)

   @{b}RESULTS@{ub}
        overlap   an overlap constant (see above)

@ENDNODE

@NODE cregionCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Copy -- copy region

   @{b}SYNOPSIS@{ub}
        reg = cregion:Copy()

   @{b}FUNCTION@{ub}
        Allocates a new region object copying the area from the original.

        This function returns a newly allocated Cairo region. Free with
        @{"cregion:Free()" LINK cregionFree}. This function always returns a valid handle; if memory
        cannot be allocated, then a special error object is returned where all
        operations on the object do nothing. You can check for this with
        @{"cregion:Status()" LINK cregionStatus}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        reg       a newly allocated Cairo region

@ENDNODE

@NODE cregionEqual "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Equal -- check region equality

   @{b}SYNOPSIS@{ub}
        ok = cregion:Equal(region_b)

   @{b}FUNCTION@{ub}
        Compares whether "region_b" is equivalent to the region.

        This function returns TRUE if both regions contained the same coverage,
        FALSE if it is not or any region is in an error status.

   @{b}INPUTS@{ub}
        region_b  a Cairo region

   @{b}RESULTS@{ub}
        ok        TRUE if both regions contained the same coverage, FALSE
                  otherwise

@ENDNODE

@NODE cregionFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Free -- free region

   @{b}SYNOPSIS@{ub}
        cregion:Free()

   @{b}FUNCTION@{ub}
        Destroys a Cairo region object created with @{"cairo.Region()" LINK cairoRegion} or
        @{"cregion:Copy()" LINK cregionCopy}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cregionGetExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:GetExtents -- get region extents

   @{b}SYNOPSIS@{ub}
        rc = cregion:GetExtents()

   @{b}FUNCTION@{ub}
        Gets the bounding rectangle of the region. This will return a table that
        has the "x", "y", "width", and "height" fields initialized.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        rc        bounding rectangle of the region

@ENDNODE

@NODE cregionGetRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:GetRectangle -- get rectangle from region

   @{b}SYNOPSIS@{ub}
        rc = cregion:GetRectangle(nth)

   @{b}FUNCTION@{ub}
        Returns the "nth" rectangle from the region. This will return a table
        that has the "x", "y", "width", and "height" fields initialized.

   @{b}INPUTS@{ub}
        nth       a number indicating which rectangle should be returned

   @{b}RESULTS@{ub}
        rc        rectangle at the specified index

@ENDNODE

@NODE cregionIntersect "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Intersect -- intersect regions

   @{b}SYNOPSIS@{ub}
        status = cregion:Intersect(other)

   @{b}FUNCTION@{ub}
        Computes the intersection of the region with "other".

   @{b}INPUTS@{ub}
        other     another Cairo region

   @{b}RESULTS@{ub}
        ok        #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionIntersectRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:IntersectRectangle -- intersect rectangle

   @{b}SYNOPSIS@{ub}
        status = cregion:IntersectRectangle(rectangle)

   @{b}FUNCTION@{ub}
        Computes the intersection of the region with "rectangle". The
        "rectangle" parameter must be a table that has the fields "x", "y",
        "width", and "height" initialized.

   @{b}INPUTS@{ub}
        rectangle a table containing a rectangle (see above)

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionIsEmpty "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:IsEmpty -- check if region is empty

   @{b}SYNOPSIS@{ub}
        ok = cregion:IsEmpty()

   @{b}FUNCTION@{ub}
        Checks whether the region is empty.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        TRUE if the region is empty, FALSE if it isn't

@ENDNODE

@NODE cregionIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:IsNull -- check if region is invalid

   @{b}SYNOPSIS@{ub}
        bool = cregion:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the region is NULL, i.e. invalid. If functions that
        allocate regions fail, they might not throw an error but simply set the
        region to NULL. You can use this function to check if region allocation
        has failed in which case the region will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the region is NULL, otherwise FALSE

@ENDNODE

@NODE cregionNumRectangles "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:NumRectangles -- num rectangles

   @{b}SYNOPSIS@{ub}
        count = cregion:NumRectangles()

   @{b}FUNCTION@{ub}
        Returns the number of rectangles contained in the region.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the number of rectangles contained in the region

@ENDNODE

@NODE cregionReference "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        cregion:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the region by one. This prevents the
        region from being destroyed until a matching call to @{"cregion:Free()" LINK cregionFree} is
        made.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cregionStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Status -- get region status

   @{b}SYNOPSIS@{ub}
        status = cregion:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previous occurred for this region object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status code

@ENDNODE

@NODE cregionSubtract "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Subtract -- subtract region

   @{b}SYNOPSIS@{ub}
        status = cregion:Subtract(other)

   @{b}FUNCTION@{ub}
        Subtracts the region specified by "other" from the region.

   @{b}INPUTS@{ub}
        other     another Cairo region

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionSubtractRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:SubtractRectangle -- subtract rectangle

   @{b}SYNOPSIS@{ub}
        status = cregion:SubtractRectangle(rectangle)

   @{b}FUNCTION@{ub}
        Subtracts "rectangle" from the region. The "rectangle" parameter must be
        a table that has the fields "x", "y", "width", and "height" initialized.

   @{b}INPUTS@{ub}
        rectangle a table containing a rectangle (see above)

   @{b}RESULTS@{ub}
        x         #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionTranslate "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Translate -- translate region

   @{b}SYNOPSIS@{ub}
        cregion:Translate(dx, dy)

   @{b}FUNCTION@{ub}
        Translates the region by ("dx", "dy").

   @{b}INPUTS@{ub}
        dx        Amount to translate in the x direction
        dy        Amount to translate in the y direction

@ENDNODE

@NODE cregionUnion "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Union -- compute region union

   @{b}SYNOPSIS@{ub}
        status = cregion:Union(other)

   @{b}FUNCTION@{ub}
        Computes the union of the current region and the region specified by
        "other".

   @{b}INPUTS@{ub}
        other     another Cairo region

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionUnionRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:UnionRectangle -- compute region union with rectangle

   @{b}SYNOPSIS@{ub}
        status = cregion:UnionRectangle(rectangle)

   @{b}FUNCTION@{ub}
        Computes the union of the current region and the rectangle specified by
        "rectangle". The "rectangle" parameter must be a table that has the
        fields "x", "y", "width", and "height" initialized.

   @{b}INPUTS@{ub}
        rectangle a table containing a rectangle (see above)

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionXor "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:Xor -- compute exclusive difference of region

   @{b}SYNOPSIS@{ub}
        status = cregion:Xor(other)

   @{b}FUNCTION@{ub}
        Computes the exclusive difference of the current region with the region
        specified by "other". That is, the current region will be set to contain
        all areas that are either in the current region or in "other", but not
        in both.

   @{b}INPUTS@{ub}
        other     another Cairo region

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cregionXorRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        cregion:XorRectangle -- compute exclusive difference of region with rectangle

   @{b}SYNOPSIS@{ub}
        status = cregion:XorRectangle(rectangle)

   @{b}FUNCTION@{ub}
        Computes the exclusive difference of the current region with
        "rectangle". That is, the current region will be set to contain all
        areas that are either in the current region or in "rectangle", but not
        in both. The "rectangle" parameter must be a table that has the fields
        "x", "y", "width", and "height" initialized.

   @{b}INPUTS@{ub}
        rectangle a table containing a rectangle (see above)

   @{b}RESULTS@{ub}
        status    #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY

@ENDNODE

@NODE cscaledfontExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:Extents -- get font extents

   @{b}SYNOPSIS@{ub}
        t = cscaledfont:Extents(extents)

   @{b}FUNCTION@{ub}
        Gets the metrics for a Cairo scaled font. This returns a table
        containing the font extents. See @{"ccontext:FontExtents()" LINK ccontextFontExtents} for an
        explanation of the individual table members.

   @{b}INPUTS@{ub}
        t         table containing the font extents (see above)

@ENDNODE

@NODE cscaledfontFree "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:Free -- free scaled font

   @{b}SYNOPSIS@{ub}
        cscaledfont:Free()

   @{b}FUNCTION@{ub}
        Decreases the reference count on the font by one. If the result is zero,
        then the font and all associated resources are freed. See
        @{"cscaledfont:Reference()" LINK cscaledfontReference}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cscaledfontGetCTM "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetCTM -- get current transformation matrix

   @{b}SYNOPSIS@{ub}
        m = cscaledfont:GetCTM()

   @{b}FUNCTION@{ub}
        Returns the CTM with which the scaled font was created. Note that the
        translation offsets (x0, y0) of the CTM are ignored by
        @{"cairo.ScaledFont()" LINK cairoScaledFont}. So, the matrix this function returns always has 0,0
        as x0,y0.

   @{b}INPUTS@{ub}
        m         current transformation matrix

@ENDNODE

@NODE cscaledfontGetFontFace "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetFontFace -- get font face

   @{b}SYNOPSIS@{ub}
        font = cscaledfont:GetFontFace()

   @{b}FUNCTION@{ub}
        Gets the font face that this scaled font uses. This might be the font
        face passed to @{"cairo.ScaledFont()" LINK cairoScaledFont}, but this does not hold true for all
        possible cases.

        This function returns the Cairo font face with which the scaled font was
        created. This object is owned by cairo. To keep a reference to it, you
        must call @{"cscaledfont:Reference()" LINK cscaledfontReference}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        font      the Cairo font face with which the scaled font was created

@ENDNODE

@NODE cscaledfontGetFontMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetFontMatrix -- get font matrix

   @{b}SYNOPSIS@{ub}
        m = cscaledfont:GetFontMatrix()

   @{b}FUNCTION@{ub}
        Returns the font matrix with which the scaled font was created.

   @{b}INPUTS@{ub}
        m         a Cairo matrix

@ENDNODE

@NODE cscaledfontGetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetFontOptions -- get font options

   @{b}SYNOPSIS@{ub}
        opt = cscaledfont:GetFontOptions(options)

   @{b}FUNCTION@{ub}
        Returns the font options with which the scaled font was created.

   @{b}INPUTS@{ub}
        opt       a Cairo font options object

@ENDNODE

@NODE cscaledfontGetReferenceCount "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetReferenceCount -- get reference count

   @{b}SYNOPSIS@{ub}
        count = cscaledfont:GetReferenceCount()

   @{b}FUNCTION@{ub}
        Returns the current reference count of the scaled font.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     the current reference count of the scaled font

@ENDNODE

@NODE cscaledfontGetScaleMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetScaleMatrix -- get scale matrix

   @{b}SYNOPSIS@{ub}
        m = cscaledfont:GetScaleMatrix()

   @{b}FUNCTION@{ub}
        Returns the scale matrix of the scaled font. The scale matrix is product
        of the font matrix and the ctm associated with the scaled font, and
        hence is the matrix mapping from font space to device space.

   @{b}INPUTS@{ub}
        m         scale matrix of the font

@ENDNODE

@NODE cscaledfontGetType "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GetType -- get font type

   @{b}SYNOPSIS@{ub}
        type = cscaledfont:GetType()

   @{b}FUNCTION@{ub}
        This function returns the type of the backend used to create a scaled
        font. See @{"cfontface:GetType()" LINK cfontfaceGetType} for a list of possible font types. Note
        that this function never returns #CAIRO_FONT_TYPE_TOY.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the type of the scaled font

@ENDNODE

@NODE cscaledfontGlyphExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:GlyphExtents -- get glyph extents

   @{b}SYNOPSIS@{ub}
        t = cscaledfont:GlyphExtents(glyphs[, offset, num_glyphs])

   @{b}FUNCTION@{ub}
        Gets the extents for a glyphs array. The extents describe a user-space
        rectangle that encloses the "inked" portion of the glyphs as they would
        be drawn by @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs} if the cairo graphics state were set
        to the same font face, font matrix, ctm, and font options as the scaled
        font. Additionally, the "XAdvance" and "YAdvance" values indicate the
        amount by which the current point would be advanced by
        @{"ccontext:ShowGlyphs()" LINK ccontextShowGlyphs}.

        Note that whitespace glyphs do not contribute to the size of the
        rectangle as returned in the "Width" and "Height" members of the
        extents.

        This function returns a table containing the glyph extents. See
        @{"ccontext:TextExtents()" LINK ccontextTextExtents} for a description of all table members.

   @{b}INPUTS@{ub}
        glyphs    a glyphs array containinig glyph IDs with X and Y offsets
        offset    optional: offset into the array that specifies the starting
                  glyph (defaults to 0 which means first glyph)
        num_glyphs
                  optional: number of glyphs to show (defaults to -1 which means
                  all glyphs)

   @{b}RESULTS@{ub}
        t         table containing the glyph extents (see above)

@ENDNODE

@NODE cscaledfontIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:IsNull -- check if scaled font is invalid

   @{b}SYNOPSIS@{ub}
        bool = cscaledfont:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the scaled font is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the object will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the object is NULL, otherwise FALSE

@ENDNODE

@NODE cscaledfontReference "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        cscaledfont:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the scaled font by one. This prevents
        the scaled font from being destroyed until a matching call to
        @{"cscaledfont:Free()" LINK cscaledfontFree} is made.

        Use @{"cscaledfont:GetReferenceCount()" LINK cscaledfontGetReferenceCount} to get the number of references to a
        Cairo scaled font.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE cscaledfontStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:Status -- get scaled font status

   @{b}SYNOPSIS@{ub}
        status = cscaledfont:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this scaled font.

        This function returns #CAIRO_STATUS_SUCCESS or another error such as
        #CAIRO_STATUS_NO_MEMORY.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status code (see above)

@ENDNODE

@NODE cscaledfontTextExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        cscaledfont:TextExtents -- get text extents

   @{b}SYNOPSIS@{ub}
        t = cscaledfont:TextExtents(s$)

   @{b}FUNCTION@{ub}
        Gets the extents for a string of text. The extents describe a user-space
        rectangle that encloses the "inked" portion of the text drawn at the
        origin (0,0) as it would be drawn by @{"ccontext:ShowText()" LINK ccontextShowText} if the
        Cairographics state were set to the same font face, font matrix, ctm,
        and font options as the scaled font. Additionally, the "XAdvance" and
        "YAdvance" values indicate the amount by which the current point would
        be advanced by @{"ccontext:ShowText()" LINK ccontextShowText}.

        Note that whitespace characters do not directly contribute to the size
        of the rectangle as contained in the "Width" and "Height" fields of the
        extents. They do contribute indirectly by changing the position of
        non-whitespace characters. In particular, trailing whitespace characters
        are likely to not affect the size of the rectangle, though they will
        affect the "XAdvance" and "YAdvance" values.

        This function returns a table containing the text extents. See
        @{"ccontext:TextExtents()" LINK ccontextTextExtents} for a description of all table members.

   @{b}INPUTS@{ub}
        s$        a string of text

   @{b}RESULTS@{ub}
        t         table containing the text extents (see above)

@ENDNODE

@NODE csurfaceAddOutline "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:AddOutline -- add outline

   @{b}SYNOPSIS@{ub}
        id = csurface:AddOutline(parent_id, name$, link$, flags)

   @{b}FUNCTION@{ub}
        For PDF surfaces, this adds an item to the document outline hierarchy
        with the name "name$" that links to the location specified by "link$".
        Link attributes have the same keys and values as the link tag, excluding
        the "rect" attribute. The item will be a child of the item with id
        "parent_id". Use #CAIRO_PDF_OUTLINE_ROOT as the parent id of top level
        items. The "flags" parameter can be set to a combination of the
        following flags:

        #CAIRO_PDF_OUTLINE_FLAG_OPEN
                  The outline item defaults to open in the PDF viewer.
        #CAIRO_PDF_OUTLINE_FLAG_BOLD
                  The outline item is displayed by the viewer in bold text.
        #CAIRO_PDF_OUTLINE_FLAG_ITALIC
                  The outline item is displayed by the viewer in italic text.

        This function returns the id for the added item.

   @{b}INPUTS@{ub}
        parent_id the id of the parent item or #CAIRO_PDF_OUTLINE_ROOT if this
                  is a top level item
        name$     the name of the outline
        link$     the link attributes specifying where this outline links to
        flags     outline item flags (see above)

   @{b}RESULTS@{ub}
        id        id for the added item

@ENDNODE

@NODE csurfaceCopyPage "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:CopyPage -- copy page

   @{b}SYNOPSIS@{ub}
        csurface:CopyPage()

   @{b}FUNCTION@{ub}
        Emits the current page for backends that support multiple pages, but
        doesn't clear it, so that the contents of the current page will be
        retained for the next page. Use @{"csurface:ShowPage()" LINK csurfaceShowPage} if you want to get
        an empty page after the emission.

        There is a convenience function for this that takes a Cairo context,
        namely @{"ccontext:CopyPage()" LINK ccontextCopyPage}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceCreateForRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:CreateForRectangle -- create surface from rectangle

   @{b}SYNOPSIS@{ub}
        handle = csurface:CreateForRectangle(x, y, width, height)

   @{b}FUNCTION@{ub}
        Create a new surface that is a rectangle within the target surface. All
        operations drawn to this surface are then clipped and translated onto
        the target surface. Nothing drawn via this sub-surface outside of its
        bounds is drawn onto the target surface, making this a useful method for
        passing constrained child surfaces to library routines that draw
        directly onto the parent surface, i.e. with no further backend
        allocations, double buffering or copies.

        The semantics of subsurfaces have not been finalized yet unless the
        rectangle is in full device units, is contained within the extents of
        the target surface, and the target or subsurface's device transforms are
        not changed.

        This function returns a handle to the newly allocated surface. The
        caller owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with
        it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if the source surface is already in an error state or
        any other error occurs.

   @{b}INPUTS@{ub}
        x         the x-origin of the sub-surface from the top-left of the
                  target surface (in device-space units)
        y         the y-origin of the sub-surface from the top-left of the
                  target surface (in device-space units)
        width     width of the sub-surface (in device-space units)
        height    height of the sub-surface (in device-space units)

   @{b}RESULTS@{ub}
        handle    handle to a new surface

@ENDNODE

@NODE csurfaceCreateSimilar "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:CreateSimilar -- create similar surface

   @{b}SYNOPSIS@{ub}
        handle = csurface:CreateSimilar(content, width, height)

   @{b}FUNCTION@{ub}
        Create a new surface that is as compatible as possible with an existing
        surface. For example the new surface will have the same device scale,
        fallback resolution and font options as the source surface. Generally,
        the new surface will also use the same backend as the source surface,
        unless that is not possible for some reason. The type of the returned
        surface may be examined with @{"csurface:GetType()" LINK csurfaceGetType}.

        The "content" parameter can be set to one of the following constants:

        #CAIRO_CONTENT_COLOR
                  The surface will hold color content only.
        #CAIRO_CONTENT_ALPHA
                  The surface will hold alpha content only.
        #CAIRO_CONTENT_COLOR_ALPHA
                  The surface will hold color and alpha content.

        Initially the surface contents are all 0 (transparent if contents have
        transparency, black otherwise.)

        Use @{"csurface:CreateSimilarImage()" LINK csurfaceCreateSimilarImage} if you need an image surface which can
        be painted quickly to the target surface.

        This function returns a handle to the newly allocated surface. The
        caller owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with
        it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if the source surface is already in an error state or
        any other error occurs.

   @{b}INPUTS@{ub}
        content   the content for the new surface (see above)
        width     width of the new surface, (in device-space units)
        height    height of the new surface (in device-space units)

   @{b}RESULTS@{ub}
        handle    handle to a new surface

@ENDNODE

@NODE csurfaceCreateSimilarImage "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:CreateSimilarImage -- create similar image surface

   @{b}SYNOPSIS@{ub}
        handle = csurface:CreateSimilarImage(format, width, height)

   @{b}FUNCTION@{ub}
        Create a new image surface that is as compatible as possible for
        uploading to and the use in conjunction with an existing surface.
        However, this surface can still be used like any normal image surface.
        Unlike @{"csurface:CreateSimilar()" LINK csurfaceCreateSimilar} the new image surface won't inherit the
        device scale from the source surface. The "format" parameter must be set
        to a pixel format constant. See @{"cairo.ImageSurface" LINK cairoImageSurface} for details.

        Initially the surface contents are all 0 (transparent if contents have
        transparency, black otherwise.)

        Use @{"csurface:CreateSimilar()" LINK csurfaceCreateSimilar} if you don't need an image surface.

        This function returns a handle to the newly allocated image surface. The
        caller owns the surface and should call @{"csurface:Free()" LINK csurfaceFree} when done with
        it.

        This function always returns a valid handle, but it will return a handle
        to a "nil" surface if "other" is already in an error state or any other
        error occurs.

   @{b}INPUTS@{ub}
        format    the format for the new surface
        width     width of the new surface, (in pixels)
        height    height of the new surface (in pixels)

   @{b}RESULTS@{ub}
        handle    handle to a new surface

@ENDNODE

@NODE csurfaceFinish "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:Finish -- finish surface

   @{b}SYNOPSIS@{ub}
        csurface:Finish()

   @{b}FUNCTION@{ub}
        This function finishes the surface and drops all references to external
        resources. For example, for the Xlib backend it means that Cairo will no
        longer access the drawable, which can be freed. After calling
        csurface:Finish() the only valid operations on a surface are checking
        status, getting and setting user, referencing and destroying, and
        flushing and finishing it. Further drawing to the surface will not
        affect the surface but will instead trigger a
        #CAIRO_STATUS_SURFACE_FINISHED error.

        When the last call to @{"csurface:Free()" LINK csurfaceFree} decreases the reference count to
        zero, Cairo will call csurface:Finish() if it hasn't been called
        already, before freeing the resources associated with the surface.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceFlush "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:Flush -- flush surface

   @{b}SYNOPSIS@{ub}
        csurface:Flush()

   @{b}FUNCTION@{ub}
        Do any pending drawing for the surface and also restore any temporary
        modifications Cairo has made to the surface's state. This function must
        be called before switching from drawing on the surface with Cairo to
        drawing on it directly with native APIs, or accessing its memory outside
        of Cairo. If the surface doesn't support direct access, then this
        function does nothing.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceFree "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:Free -- destroy surface

   @{b}SYNOPSIS@{ub}
        csurface:Free()

   @{b}FUNCTION@{ub}
        Decreases the reference count on the surface by one. If the result is
        zero, then the surface and all associated resources are freed. See
        @{"csurface:Reference()" LINK csurfaceReference}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceGetContent "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetContent -- get content type

   @{b}SYNOPSIS@{ub}
        content = csurface:GetContent()

   @{b}FUNCTION@{ub}
        This function returns the content type of the surface which indicates
        whether the surface contains color and/or alpha information. This can be
        one of the following constants:

        #CAIRO_CONTENT_COLOR
                  The surface holds color content only.
        #CAIRO_CONTENT_ALPHA
                  The surface holds alpha content only.
        #CAIRO_CONTENT_COLOR_ALPHA
                  The surface holds color and alpha content.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        content   the content type of the surface

@ENDNODE

@NODE csurfaceGetDeviceOffset "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetDeviceOffset -- get device offset

   @{b}SYNOPSIS@{ub}
        x_offset, y_offset = csurface:GetDeviceOffset()

   @{b}FUNCTION@{ub}
        This function returns the previous device offset set by
        @{"csurface:SetDeviceOffset()" LINK csurfaceSetDeviceOffset}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x_offset  the offset in the X direction, in device units
        y_offset  the offset in the Y direction, in device units

@ENDNODE

@NODE csurfaceGetDeviceScale "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetDeviceScale -- get device scale

   @{b}SYNOPSIS@{ub}
        x_scale, y_scale = csurface:GetDeviceScale()

   @{b}FUNCTION@{ub}
        This function returns the previous device scale set by
        @{"csurface:SetDeviceScale()" LINK csurfaceSetDeviceScale}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        x_scale   the scale in the X direction, in device units
        y_scale   the scale in the Y direction, in device units

@ENDNODE

@NODE csurfaceGetDocumentUnit "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetDocumentUnit -- get document unit

   @{b}SYNOPSIS@{ub}
        unit = csurface:GetDocumentUnit()

   @{b}FUNCTION@{ub}
        Get the unit of the SVG surface.

        If the surface passed as an argument is not an SVG surface, the function
        sets the error status to #CAIRO_STATUS_SURFACE_TYPE_MISMATCH and returns
        #CAIRO_SVG_UNIT_USER.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        unit      the SVG unit of the SVG surface

@ENDNODE

@NODE csurfaceGetFallbackResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetFallbackResolution -- get fallback resolution

   @{b}SYNOPSIS@{ub}
        xppi, yppi = csurface:GetFallbackResolution()

   @{b}FUNCTION@{ub}
        This function returns the previous fallback resolution set by
        @{"csurface:SetFallbackResolution()" LINK csurfaceSetFallbackResolution}, or default fallback resolution if
        never set.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        xppi      horizontal pixels per inch
        yppi      vertical pixels per inch

@ENDNODE

@NODE csurfaceGetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetFontOptions -- get font options

   @{b}SYNOPSIS@{ub}
        csurface:GetFontOptions(options)

   @{b}FUNCTION@{ub}
        Retrieves the default font rendering options for the surface. This
        allows display surfaces to report the correct subpixel order for
        rendering on them, print surfaces to disable hinting of metrics and so
        forth. The result can then be used with @{"cairo.ScaledFont()" LINK cairoScaledFont}.

   @{b}INPUTS@{ub}
        options   a Cairo font options object into which to store the retrieved
                  options; all existing values are overwritten

@ENDNODE

@NODE csurfaceGetFormat "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetFormat -- get pixel format of surface

   @{b}SYNOPSIS@{ub}
        format = csurface:GetFormat()

   @{b}FUNCTION@{ub}
        Get the pixel format of the surface. See @{"cairo.ImageSurface" LINK cairoImageSurface} for a list
        of pixel formats.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        format    pixel format of the surface

@ENDNODE

@NODE csurfaceGetHeight "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetHeight -- get surface height

   @{b}SYNOPSIS@{ub}
        height = csurface:GetHeight()

   @{b}FUNCTION@{ub}
        Get the height of the image surface in pixels.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        height    the height of the surface in pixels

@ENDNODE

@NODE csurfaceGetMimeData "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetMimeData -- get mime data

   @{b}SYNOPSIS@{ub}
        data$ = csurface:GetMimeData(mime_type$)

   @{b}FUNCTION@{ub}
        Return mime data previously attached to the surface using the specified
        mime type. If no data has been attached with the given mime type,
        "data$" is set to Nil.

   @{b}INPUTS@{ub}
        mime_type$
                  the mime type of the image data

   @{b}RESULTS@{ub}
        data$     the image data to attached to the surface

@ENDNODE

@NODE csurfaceGetReferenceCount "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetReferenceCount -- get reference count

   @{b}SYNOPSIS@{ub}
        count = csurface:GetReferenceCount()

   @{b}FUNCTION@{ub}
        Returns the current reference count of the surface.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        count     reference count of the surface

@ENDNODE

@NODE csurfaceGetType "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetType -- get surface type

   @{b}SYNOPSIS@{ub}
        type = csurface:GetType()

   @{b}FUNCTION@{ub}
        This function returns the type of the backend used to create a surface.
        This can be one of the following types:

        #CAIRO_SURFACE_TYPE_IMAGE
                  The surface is of type image.
        #CAIRO_SURFACE_TYPE_PDF
                  The surface is of type pdf.
        #CAIRO_SURFACE_TYPE_PS
                  The surface is of type ps.
        #CAIRO_SURFACE_TYPE_SVG
                  The surface is of type svg.
        #CAIRO_SURFACE_TYPE_QUARTZ
                  The surface is of type quartz.
        #CAIRO_SURFACE_TYPE_QUARTZ_IMAGE
                  The surface is of type quartz image.
        #CAIRO_SURFACE_TYPE_WIN32
                  The surface is of type win32.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the type of the surface (see above)

@ENDNODE

@NODE csurfaceGetWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:GetWidth -- get surface width

   @{b}SYNOPSIS@{ub}
        width = csurface:GetWidth()

   @{b}FUNCTION@{ub}
        Get the width of the image surface in pixels.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the width of the surface in pixels

@ENDNODE

@NODE csurfaceIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:IsNull -- check if surface is invalid

   @{b}SYNOPSIS@{ub}
        bool = csurface:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the surface is NULL, i.e. invalid. If functions that
        allocate surfaces fail, they might not throw an error but simply set the
        surface to NULL. You can use this function to check if surface
        allocation has failed in which case the surface will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the surface is NULL, otherwise FALSE

@ENDNODE

@NODE csurfaceMarkDirty "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:MarkDirty -- mark surface dirty

   @{b}SYNOPSIS@{ub}
        csurface:MarkDirty()

   @{b}FUNCTION@{ub}
        Tells Cairo that drawing has been done to surface using means other than
        Cairo, and that Cairo should reread any cached areas. Note that you must
        call @{"csurface:Flush()" LINK csurfaceFlush} before doing such drawing.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceMarkDirtyRectangle "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:MarkDirtyRectangle -- mark dirty rectangle

   @{b}SYNOPSIS@{ub}
        csurface:MarkDirtyRectangle(x, y, width, height)

   @{b}FUNCTION@{ub}
        Like @{"csurface:MarkDirty()" LINK csurfaceMarkDirty}, but drawing has been done only to the
        specified rectangle, so that Cairo can retain cached contents for other
        parts of the surface.

        Any cached clip set on the surface will be reset by this function, to
        make sure that future Cairo calls have the clip set that they expect.

   @{b}INPUTS@{ub}
        x         X coordinate of dirty rectangle
        y         Y coordinate of dirty rectangle
        width     width of dirty rectangle
        height    height of dirty rectangle

@ENDNODE

@NODE csurfaceReference "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        csurface:Reference()

   @{b}FUNCTION@{ub}
        Increases the reference count on the surface by one. This prevents the
        surface from being destroyed until a matching call to @{"csurface:Free()" LINK csurfaceFree} is
        made.

        Use @{"csurface:GetReferenceCount()" LINK csurfaceGetReferenceCount} to get the number of references to a
        surface.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceRestrictToVersion "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:RestrictToVersion -- restrict to version

   @{b}SYNOPSIS@{ub}
        csurface:RestrictToVersion(version)

   @{b}FUNCTION@{ub}
        Restricts the generated SVG or PDF file to "version". For PDF surfaces,
        you have to pass a PDF version constant here. See @{"cairo.PDFSurface()" LINK cairoPDFSurface} for
        a list of available PDF versions. For SVG surfaces, you have to pass an
        SVG version constant here. See @{"cairo.SVGSurface()" LINK cairoSVGSurface} for a list of
        available SVG versions.

        This function should only be called before any drawing operations have
        been performed on the given surface. The simplest way to do this is to
        call this function immediately after creating the surface.

   @{b}INPUTS@{ub}
        version   PDF or SVG version (see above)

@ENDNODE

@NODE csurfaceSetDeviceOffset "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetDeviceOffset -- set device offset

   @{b}SYNOPSIS@{ub}
        csurface:SetDeviceOffset(x_offset, y_offset)

   @{b}FUNCTION@{ub}
        Sets an offset that is added to the device coordinates determined by the
        CTM when drawing to the surface. One use case for this function is when
        we want to create a surface that redirects drawing for a portion of an
        onscreen surface to an offscreen surface in a way that is completely
        invisible to the user of the Cairo API. Setting a transformation via
        @{"ccontext:Translate()" LINK ccontextTranslate} isn't sufficient to do this, since functions like
        @{"ccontext:DeviceToUser()" LINK ccontextDeviceToUser} will expose the hidden offset.

        Note that the offset affects drawing to the surface as well as using the
        surface in a source pattern.

   @{b}INPUTS@{ub}
        x_offset  the offset in the X direction, in device units
        y_offset  the offset in the Y direction, in device units

@ENDNODE

@NODE csurfaceSetDeviceScale "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetDeviceScale -- set device scale

   @{b}SYNOPSIS@{ub}
        csurface:SetDeviceScale(x_scale, y_scale)

   @{b}FUNCTION@{ub}
        Sets a scale that is multiplied to the device coordinates determined by
        the CTM when drawing to the surface. One common use for this is to
        render to very high resolution display devices at a scale factor, so
        that code that assumes 1 pixel will be a certain size will still work.
        Setting a transformation via @{"ccontext:Scale()" LINK ccontextScale} isn't sufficient to do
        this, since functions like @{"ccontext:DeviceToUser()" LINK ccontextDeviceToUser} will expose the
        hidden scale.

        Note that the scale affects drawing to the surface as well as using the
        surface in a source pattern.

   @{b}INPUTS@{ub}
        x_scale   a scale factor in the X direction
        y_scale   a scale factor in the Y direction

@ENDNODE

@NODE csurfaceSetDocumentUnit "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetDocumentUnit -- set document unit

   @{b}SYNOPSIS@{ub}
        csurface:SetDocumentUnit(unit)

   @{b}FUNCTION@{ub}
        Use the specified unit for the width and height of the generated SVG
        file. See @{"csurface:GetDocumentUnit()" LINK csurfaceGetDocumentUnit} for a list of available unit values
        that can be used here.

        This function can be called at any time before generating the SVG file.

        However to minimize the risk of ambiguities it's recommended to call it
        before any drawing operations have been performed on the given surface,
        to make it clearer what the unit used in the drawing operations is.

        The simplest way to do this is to call this function immediately after
        creating the SVG surface.

        Note if this function is never called, the default unit for SVG
        documents generated by Cairo will be user unit.

   @{b}INPUTS@{ub}
        unit      SVG unit

@ENDNODE

@NODE csurfaceSetFallbackResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetFallbackResolution -- set fallback resolution

   @{b}SYNOPSIS@{ub}
        csurface:SetFallbackResolution(x_pixels_per_inch, y_pixels_per_inch)

   @{b}FUNCTION@{ub}
        Set the horizontal and vertical resolution for image fallbacks.

        When certain operations aren't supported natively by a backend, Cairo
        will fallback by rendering operations to an image and then overlaying
        that image onto the output. For backends that are natively
        vector-oriented, this function can be used to set the resolution used
        for these image fallbacks, (larger values will result in more detailed
        images, but also larger file sizes).

        Some examples of natively vector-oriented backends are the ps, pdf, and
        svg backends.

        For backends that are natively raster-oriented, image fallbacks are
        still possible, but they are always performed at the native device
        resolution. So this function has no effect on those backends.

        Note: The fallback resolution only takes effect at the time of
        completing a page (with @{"ccontext:ShowPage()" LINK ccontextShowPage} or @{"ccontext:CopyPage()" LINK ccontextCopyPage}) so
        there is currently no way to have more than one fallback resolution in
        effect on a single page.

        The default fallback resolution is 300 pixels per inch in both
        dimensions.

   @{b}INPUTS@{ub}
        x_pixels_per_inch
                  horizontal setting for pixels per inch
        y_pixels_per_inch
                  vertical setting for pixels per inch

@ENDNODE

@NODE csurfaceSetMetadata "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetMetadata -- set metadata for PDF surface

   @{b}SYNOPSIS@{ub}
        csurface:SetMetadata(metadata, s$)

   @{b}FUNCTION@{ub}
        Set document metadata for PDF surface. The
        #CAIRO_PDF_METADATA_CREATE_DATE and #CAIRO_PDF_METADATA_MOD_DATE values
        must be in ISO-8601 format: YYYY-MM-DDThh:mm:ss. An optional timezone of
        the form "[+/-]hh:mm" or "Z" for UTC time can be appended. All other
        metadata values can be any string.

        The "metadata" parameter can be one of the following constants:

        #CAIRO_PDF_METADATA_TITLE
                  The document title
        #CAIRO_PDF_METADATA_AUTHOR
                  The document author
        #CAIRO_PDF_METADATA_SUBJECT
                  The document subject
        #CAIRO_PDF_METADATA_KEYWORDS
                  The document keywords
        #CAIRO_PDF_METADATA_CREATOR
                  The document creator
        #CAIRO_PDF_METADATA_CREATE_DATE
                  The document creation date
        #CAIRO_PDF_METADATA_MOD_DATE
                  The document modification date

        For example:

            surface:SetMetadata(#CAIRO_PDF_METADATA_TITLE, "My Document")
            surface:SetMetadata(#CAIRO_PDF_METADATA_CREATE_DATE, "2015-12-31T23:59+02:00")

   @{b}INPUTS@{ub}
        metadata  the metadata item to set (see above)
        s$        metadata value

@ENDNODE

@NODE csurfaceSetMimeData "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetMimeData -- set mime data

   @{b}SYNOPSIS@{ub}
        status = csurface:SetMimeData(mime_type[, data$])

   @{b}FUNCTION@{ub}
        Attach an image in the format "mime_type" to the surface. To remove the
        data from a surface, call this function without specifying the "data$"
        argument.

        The attached image (or filename) data can later be used by backends
        which support it (currently: PDF, PS, SVG and Win32 Printing surfaces)
        to emit this data instead of making a snapshot of the the surface. This
        approach tends to be faster and requires less memory and disk space.

        The recognized MIME types are the following: #CAIRO_MIME_TYPE_JPEG,
        #CAIRO_MIME_TYPE_PNG, #CAIRO_MIME_TYPE_JP2, #CAIRO_MIME_TYPE_URI,
        #CAIRO_MIME_TYPE_UNIQUE_ID, #CAIRO_MIME_TYPE_JBIG2,
        #CAIRO_MIME_TYPE_JBIG2_GLOBAL, #CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID,
        #CAIRO_MIME_TYPE_CCITT_FAX, #CAIRO_MIME_TYPE_CCITT_FAX_PARAMS.

        See corresponding backend surface docs for details about which MIME
        types it can handle. Caution: the associated MIME data will be discarded
        if you draw on the surface afterwards. Use this function with care.

        Even if a backend supports a MIME type, that does not mean Cairo will
        always be able to use the attached MIME data. For example, if the
        backend does not natively support the compositing operation used to
        apply the MIME data to the backend. In that case, the MIME data will be
        ignored. Therefore, to apply an image in all cases, it is best to create
        an image surface which contains the decoded image data and then attach
        the MIME data to that. This ensures the image will always be used while
        still allowing the MIME data to be used whenever possible.

        This function returns #CAIRO_STATUS_SUCCESS or #CAIRO_STATUS_NO_MEMORY
        if a slot could not be allocated for the user data.

   @{b}INPUTS@{ub}
        mime_type the MIME type of the image data (see above)
        data$     optional: the image data to attach to the surface

   @{b}RESULTS@{ub}
        status    a Cairo status code

@ENDNODE

@NODE csurfaceSetPageLabel "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetPageLabel -- set page label

   @{b}SYNOPSIS@{ub}
        csurface:SetPageLabel(s$)

   @{b}FUNCTION@{ub}
        Set page label for the current page of a PDF surface.

   @{b}INPUTS@{ub}
        s$        the desired page label

@ENDNODE

@NODE csurfaceSetSize "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetSize -- set PDF surface size

   @{b}SYNOPSIS@{ub}
        csurface:SetSize(width_in_points, height_in_points)

   @{b}FUNCTION@{ub}
        Changes the size of a PDF surface for the current (and subsequent)
        pages.

        This function should only be called before any drawing operations have
        been performed on the current page. The simplest way to do this is to
        call this function immediately after creating the surface or immediately
        after completing a page with either @{"ccontext:ShowPage()" LINK ccontextShowPage} or
        @{"ccontext:CopyPage()" LINK ccontextCopyPage}.

   @{b}INPUTS@{ub}
        width_in_points
                  new surface width, in points (1 point == 1/72.0 inch)
        height_in_points
                  new surface height, in points (1 point == 1/72.0 inch)

@ENDNODE

@NODE csurfaceSetThumbnailSize "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SetThumbnailSize -- set thumbnail size

   @{b}SYNOPSIS@{ub}
        csurface:SetThumbnailSize(width, height)

   @{b}FUNCTION@{ub}
        Set the thumbnail image size for the current and all subsequent pages of
        a PDF surface. Setting a width or height of 0 disables thumbnails for
        the current and subsequent pages.

   @{b}INPUTS@{ub}
        width     thumbnail width
        height    thumbnail height

@ENDNODE

@NODE csurfaceShowPage "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:ShowPage -- show page

   @{b}SYNOPSIS@{ub}
        csurface:ShowPage()

   @{b}FUNCTION@{ub}
        Emits and clears the current page for backends that support multiple
        pages. Use @{"csurface:CopyPage()" LINK csurfaceCopyPage} if you don't want to clear the page.

        There is a convenience function for this that takes a Cairo context,
        namely @{"ccontext:ShowPage()" LINK ccontextShowPage}.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE csurfaceStatus "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:Status -- get surface status

   @{b}SYNOPSIS@{ub}
        status = csurface:Status()

   @{b}FUNCTION@{ub}
        Checks whether an error has previously occurred for this surface.

        This function returns #CAIRO_STATUS_SUCCESS, #CAIRO_STATUS_NULL_POINTER,
        #CAIRO_STATUS_NO_MEMORY, #CAIRO_STATUS_READ_ERROR,
        #CAIRO_STATUS_INVALID_CONTENT, #CAIRO_STATUS_INVALID_FORMAT, or
        #CAIRO_STATUS_INVALID_VISUAL.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        status    a Cairo status value (see above)

@ENDNODE

@NODE csurfaceSupportsMimeType "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:SupportsMimeType -- supports mime type

   @{b}SYNOPSIS@{ub}
        ok = csurface:SupportsMimeType(mime_type)

   @{b}FUNCTION@{ub}
        Return whether the surface supports "mime_type". See
        @{"csurface:SetMimeData()" LINK csurfaceSetMimeData} for a list of MIME types.

        This function returns TRUE if the surface supports "mime_type", FALSE
        otherwise.

   @{b}INPUTS@{ub}
        mime_type the mime type

   @{b}RESULTS@{ub}
        ok        boolean indicating whether the surface supports "mime_type"

@ENDNODE

@NODE csurfaceToBrush "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:ToBrush -- convert surface to Hollywood brush

   @{b}SYNOPSIS@{ub}
        [id] = csurface:ToBrush(brush[, color])

   @{b}FUNCTION@{ub}
        Converts the image surface to the Hollywood brush specified by "brush".
        If you pass Nil in "brush", automatic id selection will be used and this
        function will return the identifier of the brush. The optional argument
        "color" is only used in case the image surface doesn't have any color
        channels (e.g. if the pixel format is #CAIRO_FORMAT_A8). In that case,
        the color channels of the brush will be filled with the color specified
        in "color".

   @{b}INPUTS@{ub}
        brush     identifier of the brush to be created or Nil for auto id
                  selection
        color     optional: filling color to use if the surface doesn't have any
                  color channels

   @{b}RESULTS@{ub}
        id        optional: handle to the new brush; will only be returned if
                  you specified Nil in "brush"

@ENDNODE

@NODE csurfaceWriteToPNG "Pangomonium Guide"

   @{b}NAME@{ub}
        csurface:WriteToPNG -- write surface to PNG image

   @{b}SYNOPSIS@{ub}
        status = csurface:WriteToPNG(filename$)

   @{b}FUNCTION@{ub}
        Writes the contents of the surface to a new file specified by
        "filename$" as a PNG image

        This function returns #CAIRO_STATUS_SUCCESS if the PNG file was written
        successfully. Otherwise, #CAIRO_STATUS_NO_MEMORY if memory could not be
        allocated for the operation or #CAIRO_STATUS_SURFACE_TYPE_MISMATCH if
        the surface does not have pixel contents, or #CAIRO_STATUS_WRITE_ERROR
        if an I/O error occurs while attempting to write the file, or
        #CAIRO_STATUS_PNG_ERROR if libpng returned an error.

   @{b}INPUTS@{ub}
        filename$ filename of the PNG image

   @{b}RESULTS@{ub}
        status    a Cairo status value (see above)

@ENDNODE

@NODE pangoAttribute "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Attribute -- create Pango attribute

   @{b}SYNOPSIS@{ub}
        attr = pango.Attribute(type$[, ...])

   @{b}FUNCTION@{ub}
        Creates a new Pango attribute of the specified "type$". The other
        parameters that must be passed to this function depend on the specified
        type.

        The following types are currently supported:

        AllowBreaks
                  Create a new allow-breaks attribute. You must pass an
                  additional boolean argument specifying if breaks are allowed.
                  If breaks are disabled, the range will be kept in a single
                  run, as far as possible.

        Background
                  Create a new background color attribute. You must pass the
                  three additional arguments which specify the red, green, and
                  blue components of the background color and must be between 0
                  and 65535 each.

        BackgroundAlpha
                  Create a new background alpha attribute. You must pass the
                  additional argument "alpha" which specifies the background
                  alpha value and must be between 0 and 65535.

        Fallback  Create a new font fallback attribute. You must pass an
                  additional boolean argument that specifies whether fallback
                  should be enabled or disabled. If fallback is disabled,
                  characters will only be used from the closest matching font on
                  the system. No fallback will be done to other fonts on the
                  system that might contain the characters in the text.

        Family    Create a new font family attribute. You must pass a string
                  that contains the family name or a comma-separated list of
                  families.

        FontDesc  Create a new font description attribute. You must a Pango font
                  description object as an additional argument. This attribute
                  allows setting the attributes "Family", "Style", "Weight",
                  "Variant", "Stretch", and "Size" simultaneously.

        Foreground
                  Create a new foreground color attribute. You must pass the
                  three additional arguments which specify the red, green, and
                  blue components of the foreground color and must be between 0
                  and 65535 each.

        ForegroundAlpha
                  Create a new foreground alpha attribute. You must pass an
                  additional value which specifies the foreground alpha value
                  and must be between 0 and 65535.

        Gravity   Create a new gravity attribute. You must pass an additional
                  argument that specifies the gravity. See
                  @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants.

        GravityHint
                  Create a new gravity hint attribute. You must pass an
                  additional argument that specifies the gravity hint. See
                  @{"pcontext:SetGravityHint()" LINK pcontextSetGravityHint} for a list of gravity hints.

        InsertHyphens
                  Create a new insert-hyphens attribute. Pango will insert
                  hyphens when breaking lines in the middle of a word. Set this
                  attribute to FALSE to suppress the hyphen.

        Language  Create a new language tag attribute. You must pass an
                  additional argument containing a Pango language object.

        LetterSpacing
                  Create a new letter-spacing attribute. You must pass an
                  additional argument specifying the amount of extra space to
                  add between graphemes of the text (in Pango units).

        Rise      Create a new baseline displacement attribute. You must pass an
                  additional argument specifying the amount that the text should
                  be displaced vertically, in Pango units. Positive values
                  displace the text upwards.

        Scale     Create a new font size scale attribute. The base font for the
                  affected text will have its size multiplied by the scale
                  factor that is passed as an additional argument to this
                  attribute.

        Shape     Create a new shape attribute. A shape is used to impose a
                  particular ink and logical rectangle on the result of shaping
                  a particular glyph. This might be used, for instance, for
                  embedding a picture or a widget inside a Pango layout. You
                  have to pass two additional table arguments: The first is the
                  ink rectangle to assign to each character, the second is the
                  logical rectangle to assign to each character. Both arguments
                  must be tables with the fields "x", "y", "width", and "height"
                  initialized. Additionally, you can pass an optional third
                  argument which is considered user data and can be of any type.

        Show      Create a new attribute that influences how invisible
                  characters are rendered. You must pass an additional argument
                  that can be set to one of the following flags:

                  #PANGO_SHOW_NONE
                            No special treatment for invisible characters.
                  #PANGO_SHOW_SPACES
                            Render spaces, tabs and newlines visibly.
                  #PANGO_SHOW_LINE_BREAKS
                            Render line breaks visibly.
                  #PANGO_SHOW_IGNORABLES
                            Render default-ignorable Unicode characters visibly.

        Size      Create a new font-size attribute in fractional points. You
                  must pass an additional argument specifying the font size, in
                  #PANGO_SCALE-ths of a point.

        SizeAbsolute
                  Create a new font-size attribute in device points. You must
                  pass an additional argument specifying the font size, in
                  #PANGO_SCALE-ths of a device unit.

        Stretch   Create a new font stretch attribute. You must pass an
                  additional argument specifying the font stretch mode. See
                  @{"pfontdesc:SetStretch()" LINK pfontdescSetStretch} for a list of Pango stretch modes.

        Strikethrough
                  Create a new strike-through attribute. You must pass an
                  additional boolean argument specifying if the text should be
                  struck-through.

        StrikethroughColor
                  Create a new strikethrough color attribute. You must pass the
                  three additional arguments "red", "green", "blue" which
                  specify the strikethrough color and must be between 0 and
                  65535 for each value.

        Style     Create a new font slant style attribute. You must pass an
                  additional argument specifying the font slant style. See
                  @{"pfontdesc:SetStyle()" LINK pfontdescSetStyle} for a list of Pango styles.

        Underline Create a new underline-style attribute. You must pass an
                  additional argument specifying the underline style. The
                  following underline styles are currently supported:

                  #PANGO_UNDERLINE_NONE
                            No underline should be drawn.
                  #PANGO_UNDERLINE_SINGLE
                            A single underline should be drawn.
                  #PANGO_UNDERLINE_DOUBLE
                            A double underline should be drawn.
                  #PANGO_UNDERLINE_LOW
                            A single underline should be drawn at a position
                            beneath the ink extents of the text being
                            underlined. This should be used only for underlining
                            single characters, such as for keyboard
                            accelerators. #PANGO_UNDERLINE_SINGLE should be used
                            for extended portions of text.
                  #PANGO_UNDERLINE_ERROR
                            An underline indicating an error should be drawn
                            below. The exact style of rendering is up to the
                            PangoRenderer in use, but typical styles include
                            wavy or dotted lines. This underline is typically
                            used to indicate an error such as a possible
                            mispelling; in some cases a contrasting color may
                            automatically be used.
                  #PANGO_UNDERLINE_SINGLE_LINE
                            Like PANGO_UNDERLINE_SINGLE, but drawn continuously
                            across multiple runs.
                  #PANGO_UNDERLINE_DOUBLE_LINE
                            Like PANGO_UNDERLINE_DOUBLE, but drawn continuously
                            across multiple runs.
                  #PANGO_UNDERLINE_ERROR_LINE
                            Like PANGO_UNDERLINE_ERROR, but drawn continuously
                            across multiple runs.

        UnderlineColor
                  Create a new underline color attribute. You must pass the
                  three additional arguments "red", "green", "blue" which
                  specify the underline color and must be between 0 and 65535
                  for each value.

        Variant   Create a new font variant attribute. You must pass an
                  additional argument specifying the font variant style. See
                  @{"pfontdesc:SetVariant()" LINK pfontdescSetVariant} for a list of Pango variants.

        Weight    Create a new font weight attribute. You must pass an
                  additional argument specifying the font weight. This can be a
                  number or one of the predefined font weights. See
                  @{"pfontdesc:SetWeight()" LINK pfontdescSetWeight} for a list of Pango font weights.

        This function returns the newly allocated Pango attribute, which should
        be freed with @{"pattribute:Free()" LINK pattributeFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        attr      the newly allocated Pango attribute

@ENDNODE

@NODE pangoAttrList "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.AttrList -- create attribute list

   @{b}SYNOPSIS@{ub}
        handle = pango.AttrList()

   @{b}FUNCTION@{ub}
        Create a new empty attribute list with a reference count of one.

        This function returns the newly allocated Pango attribute list, which
        should be freed with @{"pattrlist:Free()" LINK pattrlistFree}

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated attribute list

@ENDNODE

@NODE pangoContext "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Context -- create Pango context

   @{b}SYNOPSIS@{ub}
        handle = pango.Context()

   @{b}FUNCTION@{ub}
        Creates a new Pango context initialized to default values.

        This function is not particularly useful as it should always be followed
        by a @{"pcontext:SetFontMap()" LINK pcontextSetFontMap} call, and the function
        @{"pfontmap:CreateContext()" LINK pfontmapCreateContext} does these two steps together and hence users
        are recommended to use that.

        This function returns the newly allocated Pango context, which should be
        freed with @{"pcontext:Free()" LINK pcontextFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango context

@ENDNODE

@NODE pangoCoverage "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Coverage -- create Pango coverage

   @{b}SYNOPSIS@{ub}
        handle = pango.Coverage()

   @{b}FUNCTION@{ub}
        Create a new Pango coverage.

        This function returns the newly allocated Pango coverage, initialized to
        #PANGO_COVERAGE_NONE with a reference count of one, which should be
        freed with @{"pcoverage:Free()" LINK pcoverageFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango coverage

@ENDNODE

@NODE pangoExtentsToPixels "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.ExtentsToPixels -- convert extents from Pango to device units

   @{b}SYNOPSIS@{ub}
        r1, r2 = pango.ExtentsToPixels(inclusive, nearest)

   @{b}FUNCTION@{ub}
        Converts extents from Pango units to device units. The conversion is
        done by dividing by the #PANGO_SCALE factor and performing rounding. The
        "inclusive" and "nearest" arguments must be tables that have the fields
        "x", "y", "width", and "height" initialized. If you don't need one of
        the rectangles, you can also set it to Nil.

        The "inclusive" rectangle is converted by flooring the x/y coordinates
        and extending width/height, such that the final rectangle completely
        includes the original rectangle.

        The "nearest" rectangle is converted by rounding the coordinates of the
        rectangle to the nearest device unit (pixel).

        The rule to which argument to use is: if you want the resulting
        device-space rectangle to completely contain the original rectangle,
        pass it in as "inclusive". If you want two touching-but-not-overlapping
        rectangles stay touching-but-not-overlapping after rounding to device
        units, pass them in as "nearest".

   @{b}INPUTS@{ub}
        inclusive rectangle to round to pixels inclusively or Nil
        nearest   rectangle to round to nearest pixels or Nil

   @{b}RESULTS@{ub}
        r1        rounded inclusive rectangle
        r2        rounded nearest rectangle

@ENDNODE

@NODE pangoFontDescription "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.FontDescription -- create font description

   @{b}SYNOPSIS@{ub}
        desc = pango.FontDescription([s$])

   @{b}FUNCTION@{ub}
        Creates a new font description. If the "s$" parameter is omitted, all
        fields will be initialized to default values. Otherwise, the font
        description is initialized according to the string specification. If
        specified, "s$" must have the form

            [FAMILY_LIST] [STYLE_OPTIONS] [SIZE] [VARIATIONS]

        where "FAMILY_LIST" is a comma-separated list of families optionally
        terminated by a comma, "STYLE_OPTIONS" is a whitespace-separated list of
        words where each word describes one of style, variant, weight, stretch,
        or gravity, and "SIZE" is a decimal number (size in points) or
        optionally followed by the unit modifier "px" for absolute size.
        "VARIATIONS" is a comma-separated list of font variation specifications
        of the form "axis=value" (the = sign is optional).

        The following words are understood as styles: "Normal", "Roman",
        "Oblique", "Italic".

        The following words are understood as variants: "Small-Caps",
        "All-Small-Caps", "Petite-Caps", "All-Petite-Caps", "Unicase",
        "Title-Caps".

        The following words are understood as weights: "Thin", "Ultra-Light",
        "Extra-Light", "Light", "Semi-Light", "Demi-Light", "Book", "Regular",
        "Medium", "Semi-Bold", "Demi-Bold", "Bold", "Ultra-Bold", "Extra-Bold",
        "Heavy", "Black", "Ultra-Black", "Extra-Black".

        The following words are understood as stretch values: "Ultra-Condensed",
        "Extra-Condensed", "Condensed", "Semi-Condensed", "Semi-Expanded",
        "Expanded", "Extra-Expanded", "Ultra-Expanded".

        The following words are understood as gravity values: "Not-Rotated",
        "South", "Upside-Down", "North", "Rotated-Left", "East",
        "Rotated-Right", "West".

        Any one of the options may be absent. If "FAMILY_LIST" is absent, then
        the "FamilyName" field of the resulting font description will be
        initialized to Nil. If "STYLE_OPTIONS" is missing, then all style
        options will be set to the default values. If "SIZE" is missing, the
        size in the resulting font description will be set to 0.

        A typical example:

            Cantarell Italic Light 15 wght=200

   @{b}INPUTS@{ub}
        s$        optional: a string describing the font to load

   @{b}RESULTS@{ub}
        desc      a new Pango font description

@ENDNODE

@NODE pangoFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.FontMap -- create font map

   @{b}SYNOPSIS@{ub}
        handle = pango.FontMap([fonttype])

   @{b}FUNCTION@{ub}
        Creates a new fontmap object.

        A fontmap is used to cache information about available fonts, and holds
        certain global parameters such as the resolution. In most cases, you can
        use @{"pango.GetDefaultFontMap()" LINK pangoGetDefaultFontMap} instead.

        Note that the type of the returned object will depend on the particular
        font backend Cairo was compiled to use; alternatively, you can also pass
        the optional "fonttype" argument to explicitly specify a backend to use.
        See @{"cfontface:GetType()" LINK cfontfaceGetType} for a list of font types.

        This function returns the newly allocated Pango font map, which should
        be freed with @{"pfontmap:Free()" LINK pfontmapFree}.

   @{b}INPUTS@{ub}
        fonttype  optional: the Cairo font type to use

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango font map

@ENDNODE

@NODE pangoGetDefaultFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GetDefaultFontMap -- get default font map

   @{b}SYNOPSIS@{ub}
        handle = pango.GetDefaultFontMap()

   @{b}FUNCTION@{ub}
        Gets a default font map to use with Cairo.

        Note that the type of the returned object will depend on the particular
        font backend Cairo was compiled to use.

        The default Cairo fontmap can be changed by using
        @{"pango.SetDefaultFontMap()" LINK pangoSetDefaultFontMap}. This can be used to change the Cairo font
        backend that the default fontmap uses for example.

        The object returned is owned by Pango and must not be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the default Pango fontmap

@ENDNODE

@NODE pangoGetDefaultLanguage "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GetDefaultLanguage -- get default language

   @{b}SYNOPSIS@{ub}
        lang = pango.GetDefaultLanguage()

   @{b}FUNCTION@{ub}
        Returns the Pango language for the current locale of the process. Note
        that the default language can change over the life of an application.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        lang      the default language as a Pango language

@ENDNODE

@NODE pangoGlyphString "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GlyphString -- create Pango glyph string

   @{b}SYNOPSIS@{ub}
        gstr = pango.GlyphString()

   @{b}FUNCTION@{ub}
        Create a new Pango glyph string.

        This function returns the newly allocated Pango glyph string, which
        should be freed with @{"pglyphstring:Free()" LINK pglyphstringFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        gstr      the newly allocated Pango glyph string

@ENDNODE

@NODE pangoGravityForMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GravityForMatrix -- find gravity for matrix

   @{b}SYNOPSIS@{ub}
        gravity = pango.GravityForMatrix(matrix)

   @{b}FUNCTION@{ub}
        Finds the gravity that best matches the rotation component in a Pango
        matrix.

        This function returns the gravity of "matrix", which will never be
        #PANGO_GRAVITY_AUTO.

        See @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants.

   @{b}INPUTS@{ub}
        matrix    Pango matrix

   @{b}RESULTS@{ub}
        gravity   the gravity of "matrix"

@ENDNODE

@NODE pangoGravityForScript "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GravityForScript -- get gravity for script

   @{b}SYNOPSIS@{ub}
        gravity = pango.GravityForScript(script, base_gravity, hint)

   @{b}FUNCTION@{ub}
        Returns the gravity to use in laying out a Pango item. The gravity is
        determined based on the script, base gravity, and hint.

        If "base_gravity" is #PANGO_GRAVITY_AUTO, it is first replaced with the
        preferred gravity of "script". To get the preferred gravity of a script,
        pass #PANGO_GRAVITY_AUTO and #PANGO_GRAVITY_HINT_STRONG in.

        This function returns resolved gravity suitable to use for a run of text
        with "script".

        See @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants. See
        @{"pcontext:SetGravityHint()" LINK pcontextSetGravityHint} for a list of gravity hints. See
        @{"planguage:GetScripts()" LINK planguageGetScripts} for a list of scripts.

   @{b}INPUTS@{ub}
        script    the Pango script to query
        base_gravity
                  base gravity of the paragraph
        hint      orientation hint

   @{b}RESULTS@{ub}
        gravity   resolved gravity suitable to use for a run of text

@ENDNODE

@NODE pangoGravityForScriptAndWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GravityForScriptAndWidth -- get gravity for script and width

   @{b}SYNOPSIS@{ub}
        g = pango.GravityForScriptAndWidth(script, wide, base_gravity, hint)

   @{b}FUNCTION@{ub}
        Returns the gravity to use in laying out a single character or Pango
        item.

        The gravity is determined based on the script, East Asian width, base
        gravity, and hint,

        This function is similar to @{"pango.GravityForScript()" LINK pangoGravityForScript} except that this
        function makes a distinction between narrow/half-width and
        wide/full-width characters also. Wide/full-width characters always stand
        *upright*, that is, they always take the base gravity, whereas
        narrow/full-width characters are always rotated in vertical context.

        If "base_gravity" is #PANGO_GRAVITY_AUTO, it is first replaced with the
        preferred gravity of "script".

        This function returns resolved gravity suitable to use for a run of text
        with "script" and "wide".

        See @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants. See
        @{"pcontext:SetGravityHint()" LINK pcontextSetGravityHint} for a list of gravity hints. See
        @{"planguage:GetScripts()" LINK planguageGetScripts} for a list of scripts.

   @{b}INPUTS@{ub}
        script    the Pango script to query
        wide      TRUE for wide characters
        base_gravity
                  base gravity of the paragraph
        hint      orientation hint

   @{b}RESULTS@{ub}
        g         resolved gravity suitable to use for a run of text

@ENDNODE

@NODE pangoGravityToRotation "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.GravityToRotation -- convert gravity to rotation

   @{b}SYNOPSIS@{ub}
        angle = pango.GravityToRotation(gravity)

   @{b}FUNCTION@{ub}
        Converts a Pango gravity value to its natural rotation in radians.

        Note that @{"pmatrix:Rotate()" LINK pmatrixRotate} takes angle in degrees, not radians. So, to
        call @{"pmatrix:Rotate()" LINK pmatrixRotate} with the output of this function you should
        multiply it by (180. / #PI).

        This function returns the rotation value corresponding to "gravity".

        See @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants.

   @{b}INPUTS@{ub}
        gravity   gravity to query, should not be #PANGO_GRAVITY_AUTO

   @{b}RESULTS@{ub}
        angle     the rotation value corresponding to "gravity"

@ENDNODE

@NODE pangoItem "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Item -- create Pango item

   @{b}SYNOPSIS@{ub}
        item = pango.Item()

   @{b}FUNCTION@{ub}
        Creates a new Pango item structure initialized to default values.

        This function returns the newly allocated Pango item, which should be
        freed with @{"pitem:Free()" LINK pitemFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        item      the newly allocated Pango item

@ENDNODE

@NODE pangoLanguage "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Language -- make language from string

   @{b}SYNOPSIS@{ub}
        lang = pango.Language(tag$)

   @{b}FUNCTION@{ub}
        Convert a language tag specified by "tag$" to a Pango language object.
        The language tag must be in a RFC-3066 format. Pango language handles
        can be efficiently copied (copy the handle) and compared with other
        language tags (compare the handle.)

        This function first canonicalizes the string by converting it to
        lowercase, mapping '_' to '-', and stripping all characters other than
        letters and '-'.

        Use @{"pango.GetDefaultLanguage()" LINK pangoGetDefaultLanguage} if you want to get the Pango language for
        the current locale of the process.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        lang      a Pango language object

@ENDNODE

@NODE pangoLayout "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Layout -- create Pango layout

   @{b}SYNOPSIS@{ub}
        handle = pango.Layout(context)

   @{b}FUNCTION@{ub}
        Create a new Pango layout object with attributes initialized to default
        values for a particular Pango context.

   @{b}INPUTS@{ub}
        context   a Pango context

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango layout

@ENDNODE

@NODE pangoMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Matrix -- create matrix

   @{b}SYNOPSIS@{ub}
        m = pango.Matrix([xx, xy, yx, yy, x0, y0])

   @{b}FUNCTION@{ub}
        Creates a matrix and optionally initializes its affine transformation to
        the coefficients specified by "xx", "xy", "yx", "yy", "x0", "y0".
        Omitted coefficients will be set to 0.

   @{b}INPUTS@{ub}
        xx        optional: xx component of the affine transformation (defaults
                  to 0)
        xy        optional: xy component of the affine transformation (defaults
                  to 0)
        yx        optional: yx component of the affine transformation (defaults
                  to 0)
        yy        optional: yy component of the affine transformation (defaults
                  to 0)
        x0        optional: X translation component of the affine transformation
                  (defaults to 0)
        y0        optional: Y translation component of the affine transformation
                  (defaults to 0)

   @{b}RESULTS@{ub}
        m         matrix object

@ENDNODE

@NODE pangoMatrixIdentity "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.MatrixIdentity -- create identity matrix

   @{b}SYNOPSIS@{ub}
        m = pango.MatrixIdentity()

   @{b}FUNCTION@{ub}
        Creates a matrix and initializes its affine transformation to an
        identity transformation.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         identity matrix object

@ENDNODE

@NODE pangoSetDefaultFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.SetDefaultFontMap -- set default fontmap

   @{b}SYNOPSIS@{ub}
        pango.SetDefaultFontMap([fontmap])

   @{b}FUNCTION@{ub}
        Sets a default fontmap to use with Cairo.

        This can be used to change the Cairo font backend that the default
        fontmap uses for example. The old default fontmap is unreffed and the
        new fontmap referenced.

        If you omit the "fontmap" parameter, the current default fontmap will be
        released and a new default fontmap will be created on demand, using
        @{"pango.FontMap()" LINK pangoFontMap}.

   @{b}INPUTS@{ub}
        fontmap   optional: Pango fontmap to set as default

@ENDNODE

@NODE pangoSetFontconfig "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.SetFontconfig -- set Fontconfig parameter

   @{b}SYNOPSIS@{ub}
        pango.SetFontconfig(parm$, val$[, ...])

   @{b}FUNCTION@{ub}
        This function can be used to configure individual Fontconfig settings.
        Fontconfig is used by Pango for font management. The following
        Fontconfig settings can currently be configured and passed as "parm$":

        FontDir   Adds the specified directory to the list of directories
                  scanned for fonts by Fontconfig. If you pass TRUE as a third
                  argument to this function, the existing list of font
                  directories will be cleared so that "val$" is the only
                  directory where Fontconfig will be looking for fonts. If you
                  omit the third argument or set it to FALSE, the specified
                  directory will be added on top of the existing font
                  directories.

        CacheDir  Sets the cache directory used by Fontconfig.

        ConfigDir Sets the directory in which Fontconfig looks for and stores
                  configuration files.

        ConfigFile
                  Sets the configuration file that Fontconfig should use.

   @{b}INPUTS@{ub}
        parm$     setting to modify (see above for valid types)
        val$      new value for the Fontconfig setting
        ...       optional: further parameters depending on the type passed in
                  "parm$"

@ENDNODE

@NODE pangoShape "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Shape -- convert text to glyphs

   @{b}SYNOPSIS@{ub}
        pango.Shape(text$, analysis, glyphs)

   @{b}FUNCTION@{ub}
        Convert the characters in "text$" into glyphs.

        Given a segment of text and the corresponding Pango analysis structure
        returned from @{"pcontext:Itemize()" LINK pcontextItemize}, convert the characters into glyphs.
        You may also pass in only a substring of the item from
        @{"pcontext:Itemize()" LINK pcontextItemize}.

        It is recommended that you use @{"pango.ShapeFull()" LINK pangoShapeFull} instead, since that API
        allows for shaping interaction happening across text item boundaries.

        Note that the extra attributes in the "analyis" that is returned from
        @{"pcontext:Itemize()" LINK pcontextItemize} have indices that are relative to the entire
        paragraph, so you need to subtract the item offset from their indices
        before calling this function.

   @{b}INPUTS@{ub}
        text$     the text to process
        analysis  Pango analysis object from @{"pcontext:Itemize()" LINK pcontextItemize}
        glyphs    Pango glyph string object in which to store results

@ENDNODE

@NODE pangoShapeFull "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.ShapeFull -- convert text to glyphs

   @{b}SYNOPSIS@{ub}
        pango.ShapeFull(item_text$, paragraph_text$, analysis, glyphs[, flags])

   @{b}FUNCTION@{ub}
        Convert the characters in "item_text$" into glyphs.

        Given a segment of text and the corresponding Pango analysis structure
        returned from @{"pcontext:Itemize()" LINK pcontextItemize}, convert the characters into glyphs.
        You may also pass in only a substring of the item from
        @{"pcontext:Itemize()" LINK pcontextItemize}.

        This is similar to @{"pango.Shape()" LINK pangoShape}, except it also can optionally take
        the full paragraph text as input, which will then be used to perform
        certain cross-item shaping interactions. If you have access to the
        broader text of which "item_text$" is part of, provide the broader text
        as "paragraph_text$". If "paragraph_text$" is Nil, item text is used
        instead.

        Note that the extra attributes in the "analyis" that is returned from
        @{"pcontext:Itemize()" LINK pcontextItemize} have indices that are relative to the entire
        paragraph, so you do not pass the full paragraph text as
        "paragraph_text$", you need to subtract the item offset from their
        indices before calling @{"pcontext:Itemize()" LINK pcontextItemize}.

        The optional argument "flags" can be used to influence the shaping
        process. The following flags are currently recognized:

        #PANGO_SHAPE_NONE
                  Default value.
        #PANGO_SHAPE_ROUND_POSITIONS
                  Round glyph positions and widths to whole device units. This
                  option should be set if the target renderer can't do subpixel
                  positioning of glyphs.

   @{b}INPUTS@{ub}
        item_text$
                  text to shape
        paragraph_text$
                  text of the paragraph or Nil (see details)
        analysis  Pango analysis object from @{"pcontext:Itemize()" LINK pcontextItemize}
        glyphs    glyph string in which to store results
        flags     optional: additional flags (see above)

@ENDNODE

@NODE pangoTabArray "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.TabArray -- create tab array

   @{b}SYNOPSIS@{ub}
        tabs = pango.TabArray(initial_size, positions_in_pixels)

   @{b}FUNCTION@{ub}
        Creates an array of "initial_size" tab stops. Tab stops are specified in
        pixel units if "positions_in_pixels" is TRUE, otherwise in Pango units.
        All stops are initially at position 0.

        This function returns the newly allocated Pango tab array, which should
        be freed with @{"ptabarray:Free()" LINK ptabarrayFree}.

   @{b}INPUTS@{ub}
        initial_size
                  initial number of tab stops to allocate, can be 0
        positions_in_pixels
                  whether positions are in pixel units

   @{b}RESULTS@{ub}
        tabs      the newly allocated Pango tab array

@ENDNODE

@NODE pangoTabArrayWithPositions "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.TabArrayWithPositions -- create tab array

   @{b}SYNOPSIS@{ub}
        tabs = pango.TabArrayWithPositions(positions_in_pixels[, align1, pos1, ...])

   @{b}FUNCTION@{ub}
        Creates a Pango tab array and allows you to specify the alignment and
        position of each tab stop. Tab stops are specified in pixel units if
        "positions_in_pixels" is TRUE, otherwise in Pango units.

        For each tab stop you must provide an alignment and a position. The
        "alignN" parameter can be one of the following constants:

        #PANGO_TAB_LEFT
                  The text appears to the right of the tab stop position.
        #PANGO_TAB_RIGHT
                  The text appears to the left of the tab stop position until
                  the available space is filled.
        #PANGO_TAB_CENTER
                  The text is centered at the tab stop position until the
                  available space is filled.
        #PANGO_TAB_DECIMAL
                  Text before the first occurrence of the decimal point
                  character appears to the left of the tab stop position (until
                  the available space is filled), the rest to the right.

        This function returns the newly allocated Pango tab array, which should
        be freed with @{"ptabarray:Free()" LINK ptabarrayFree}.

   @{b}INPUTS@{ub}
        positions_in_pixels
                  whether positions are in pixel units
        align1    alignment of first tab stop (see above)
        pos1      position of first tab stop
        ...       additional alignment/position pairs

   @{b}RESULTS@{ub}
        tabs      the newly allocated Pango tab array

@ENDNODE

@NODE pangoVersion "Pangomonium Guide"

   @{b}NAME@{ub}
        pango.Version -- return Pango version

   @{b}SYNOPSIS@{ub}
        ver$ = pango.Version()

   @{b}FUNCTION@{ub}
        Returns the version of Pango available at run-time.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ver$      Pango version

@ENDNODE

@NODE panalysisGet "Pangomonium Guide"

   @{b}NAME@{ub}
        panalysis:Get -- get analysis info

   @{b}SYNOPSIS@{ub}
        table = panalysis:Get()

   @{b}FUNCTION@{ub}
        Gets information about a Pango analysis object. The data will be
        returned as a table. The following fields will be initialized in the
        table:

        Font      The font for this segment. This is a Pango font handle. It is
                  owned by the Pango analysis object and mustn't be freed.
        Level     The bidirectional level for this segment.
        Gravity   The glyph orientation for this segment. See
                  @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of gravity constants.
        Flags     Boolean flags for this segment.
        Script    The detected script for this segment. See
                  @{"planguage:GetScripts()" LINK planguageGetScripts} for a list of supported scripts.
        Language  The detected language for this segment. This is a Pango
                  language handle. It is owned by the Pango analysis object and
                  mustn't be freed.
        ExtraAttrs
                  Extra attributes for this segment. This is a table of Pango
                  attributes. The Pango attribute objects are owned by the Pango
                  analysis object and mustn't be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        table     a table containing the analysis data

@ENDNODE

@NODE pattributeCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:Copy -- copy attribute

   @{b}SYNOPSIS@{ub}
        attr = pattribute:Copy()

   @{b}FUNCTION@{ub}
        Make a copy of an attribute.

        This function returns the newly allocated Pango attribute, which should
        be freed with @{"pattribute:Free()" LINK pattributeFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        attr      the newly allocated attribute copy

@ENDNODE

@NODE pattributeEqual "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:Equal -- compare for equality

   @{b}SYNOPSIS@{ub}
        ok = pattribute:Equal(attr2)

   @{b}FUNCTION@{ub}
        Compare the attribute with "attr2" for equality.

        This compares only the actual value of the two attributes and not the
        ranges that the attributes apply to.

        This function returns TRUE if the two attributes have the same value.

   @{b}INPUTS@{ub}
        attr2     another Pango attribute object

   @{b}RESULTS@{ub}
        ok        TRUE if the two attributes have the same value, FALSE
                  otherwise

@ENDNODE

@NODE pattributeFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:Free -- free attribute

   @{b}SYNOPSIS@{ub}
        pattribute:Free()

   @{b}FUNCTION@{ub}
        Destroy a Pango attribute and free all associated memory.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pattributeGetRange "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:GetRange -- get attribute range

   @{b}SYNOPSIS@{ub}
        start_index, end_index = pattribute:GetRange()

   @{b}FUNCTION@{ub}
        Gets the range to which the value in the type-specific part of the
        attribute applies.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        start_index
                  the start index of the range (in bytes)
        end_index end index of the range (in bytes); the character at this index
                  is not included in the range

@ENDNODE

@NODE pattributeGetType "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:GetType -- get attribute type

   @{b}SYNOPSIS@{ub}
        type = pattribute:GetType()

   @{b}FUNCTION@{ub}
        Gets the attribute type. This can be one of the following constants:

            #PANGO_ATTR_ABSOLUTE_SIZE
            #PANGO_ATTR_ALLOW_BREAKS
            #PANGO_ATTR_BACKGROUND
            #PANGO_ATTR_BACKGROUND_ALPHA
            #PANGO_ATTR_FALLBACK
            #PANGO_ATTR_FAMILY
            #PANGO_ATTR_FONT_DESC
            #PANGO_ATTR_FONT_FEATURES
            #PANGO_ATTR_FOREGROUND
            #PANGO_ATTR_FOREGROUND_ALPHA
            #PANGO_ATTR_GRAVITY
            #PANGO_ATTR_GRAVITY_HINT
            #PANGO_ATTR_INSERT_HYPHENS
            #PANGO_ATTR_INVALID
            #PANGO_ATTR_LANGUAGE
            #PANGO_ATTR_LETTER_SPACING
            #PANGO_ATTR_RISE
            #PANGO_ATTR_SCALE
            #PANGO_ATTR_SHAPE
            #PANGO_ATTR_SHOW
            #PANGO_ATTR_SIZE
            #PANGO_ATTR_STRETCH
            #PANGO_ATTR_STRIKETHROUGH
            #PANGO_ATTR_STRIKETHROUGH_COLOR
            #PANGO_ATTR_STYLE
            #PANGO_ATTR_UNDERLINE
            #PANGO_ATTR_UNDERLINE_COLOR
            #PANGO_ATTR_VARIANT
            #PANGO_ATTR_WEIGHT

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the attribute's type

@ENDNODE

@NODE pattributeGetValue "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:GetValue -- get attribute value

   @{b}SYNOPSIS@{ub}
        v = pattribute:GetValue()

   @{b}FUNCTION@{ub}
        Gets the attribute value. The attribute value is the value passed to the
        attribute when calling @{"pango.Attribute()" LINK pangoAttribute}. Depending on the attribute
        type, there can also be multiple values in the attribute.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        v         the attribute's value

@ENDNODE

@NODE pattributeIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:IsNull -- check if attribute is invalid

   @{b}SYNOPSIS@{ub}
        bool = pattribute:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the attribute is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the attribute will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the attribute is NULL, otherwise FALSE

@ENDNODE

@NODE pattributeSetRange "Pangomonium Guide"

   @{b}NAME@{ub}
        pattribute:SetRange -- set attribute range

   @{b}SYNOPSIS@{ub}
        pattribute:SetRange(start_index, end_index)

   @{b}FUNCTION@{ub}
        Sets the range to which the value in the type-specific part of the
        attribute applies.

   @{b}INPUTS@{ub}
        start_index
                  the start index of the range (in bytes)
        end_index end index of the range (in bytes); the character at this index
                  is not included in the range

@ENDNODE

@NODE pattrlistChange "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Change -- insert attribute

   @{b}SYNOPSIS@{ub}
        pattrlist:Change(attr)

   @{b}FUNCTION@{ub}
        Insert the given attribute into the Pango attribute list.

        It will replace any attributes of the same type on that segment and be
        merged with any adjoining attributes that are identical.

        This function is slower than @{"pattrlist:Insert()" LINK pattrlistInsert} for creating an
        attribute list in order (potentially much slower for large lists).
        However, @{"pattrlist:Insert()" LINK pattrlistInsert} is not suitable for continually changing a
        set of attributes since it never removes or combines existing
        attributes.

   @{b}INPUTS@{ub}
        attr      the attribute to insert

@ENDNODE

@NODE pattrlistCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Copy -- copy list

   @{b}SYNOPSIS@{ub}
        list = pattrlist:Copy()

   @{b}FUNCTION@{ub}
        Copy the attribute list and return an identical new list.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        list      the newly allocated attribute list

@ENDNODE

@NODE pattrlistFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Free -- free attribute list

   @{b}SYNOPSIS@{ub}
        pattrlist:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of the given attribute list by one.

        If the result is zero, free the attribute list and the attributes it
        contains.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pattrlistGetAttributes "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:GetAttributes -- get attributes

   @{b}SYNOPSIS@{ub}
        t = pattrlist:GetAttributes()

   @{b}FUNCTION@{ub}
        Gets a list of all attributes in the list. This function returns a table
        containing all attributes in the list. You must free the individual
        attributes using @{"pattribute:Free()" LINK pattributeFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing all attributes in the list

@ENDNODE

@NODE pattrlistInsert "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Insert -- insert attribute

   @{b}SYNOPSIS@{ub}
        pattrlist:Insert(attr)

   @{b}FUNCTION@{ub}
        Insert the given attribute into the Pango attribute list.

        It will be inserted after all other attributes with a matching start
        index. You can use @{"pattribute:SetRange()" LINK pattributeSetRange} to set the start index.

   @{b}INPUTS@{ub}
        attr      the attribute to insert

@ENDNODE

@NODE pattrlistInsertBefore "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:InsertBefore -- insert attribute in before mode

   @{b}SYNOPSIS@{ub}
        pattrlist:InsertBefore(attr)

   @{b}FUNCTION@{ub}
        Insert the given attribute into the Pango attribute list.

        It will be inserted before all other attributes with a matching start
        index. You can use @{"pattribute:SetRange()" LINK pattributeSetRange} to set the start index.

   @{b}INPUTS@{ub}
        attr      the attribute to insert

@ENDNODE

@NODE pattrlistIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:IsNull -- check if attribute list is invalid

   @{b}SYNOPSIS@{ub}
        bool = pattrlist:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the attribute list is NULL, i.e. invalid. If functions
        that allocate objects fail, they might not throw an error but simply set
        the object to NULL. You can use this function to check if object
        allocation has failed in which case the attribute list will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the attribute list is NULL, otherwise FALSE

@ENDNODE

@NODE pattrlistReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pattrlist:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count of the given attribute list by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pattrlistSplice "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Splice -- splice attribute list

   @{b}SYNOPSIS@{ub}
        pattrlist:Splice(other, pos, len)

   @{b}FUNCTION@{ub}
        This function opens up a hole in the list, fills it in with attributes
        from the left, and then merges the attribute list specified by "other"
        on top of the hole.

        This operation is equivalent to stretching every attribute that applies
        at position "pos" in the list by an amount "len", and then calling
        @{"pattrlist:Change()" LINK pattrlistChange} with a copy of each attribute in "other" in sequence
        (offset in position by "pos", and limited in length to "len").

        This operation proves useful for, for instance, inserting a pre-edit
        string in the middle of an edit buffer.

        For backwards compatibility, the function behaves differently when "len"
        is 0. In this case, the attributes from "other" are not limited to
        "len", and are just overlayed on top of the list.

        This mode is useful for merging two lists of attributes together.

   @{b}INPUTS@{ub}
        other     another Pango attribute list
        pos       the position in the list at which to insert "other"
        len       the length of the spliced segment; note that this must be
                  specified since the attributes in "other" may only be present
                  at some subsection of this range

@ENDNODE

@NODE pattrlistUpdate "Pangomonium Guide"

   @{b}NAME@{ub}
        pattrlist:Update -- update attribute indices

   @{b}SYNOPSIS@{ub}
        pattrlist:Update(pos, remove, add)

   @{b}FUNCTION@{ub}
        Update indices of attributes in the list for a change in the text they
        refer to.

        The change that this function applies is removing "remove" bytes at
        position "pos" and inserting "add" bytes instead.

        Attributes that fall entirely in the ("pos", "pos" + "remove") range are
        removed.

        Attributes that start or end inside the ("pos", "pos" + "remove") range
        are shortened to reflect the removal.

        Attributes start and end positions are updated if they are behind "pos"
        + "remove".

   @{b}INPUTS@{ub}
        pos       the position of the change
        remove    the number of removed bytes
        add       the number of added bytes

@ENDNODE

@NODE pcontextChanged "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:Changed -- force context change

   @{b}SYNOPSIS@{ub}
        pcontext:Changed()

   @{b}FUNCTION@{ub}
        Forces a change in the context, which will cause any Pango layout using
        this context to re-layout.

        This function is only useful when implementing a new backend for Pango,
        something applications won't do. Backends should call this function if
        they have attached extra data to the context and such data is changed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pcontextFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:Free -- free context

   @{b}SYNOPSIS@{ub}
        pcontext:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of a Pango context by one.

        If the result is zero, the context and all associated memory will be
        freed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pcontextGetBaseDir "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetBaseDir -- get base direction for context

   @{b}SYNOPSIS@{ub}
        dir = pcontext:GetBaseDir()

   @{b}FUNCTION@{ub}
        Retrieves the base direction for the context. See @{"pcontext:SetBaseDir()" LINK pcontextSetBaseDir}
        for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        dir       the base direction for the context

@ENDNODE

@NODE pcontextGetBaseGravity "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetBaseGravity -- get base gravity for context

   @{b}SYNOPSIS@{ub}
        gravity = pcontext:GetBaseGravity()

   @{b}FUNCTION@{ub}
        Retrieves the base gravity for the context. See
        @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        gravity   the base gravity for the context

@ENDNODE

@NODE pcontextGetFontDescription "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetFontDescription -- get font description

   @{b}SYNOPSIS@{ub}
        handle = pcontext:GetFontDescription()

   @{b}FUNCTION@{ub}
        Retrieve the default font description for the context.

        This function returns a handle to the context's default font
        description. This value must not be modified or freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a handle to the context's default font

@ENDNODE

@NODE pcontextGetFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetFontMap -- get font map

   @{b}SYNOPSIS@{ub}
        handle = pcontext:GetFontMap()

   @{b}FUNCTION@{ub}
        Gets the Pango font map used to look up fonts for this context.

        This function returns the font map for the Pango context. This value is
        owned by Pango and should not be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the font map for the Pango context

@ENDNODE

@NODE pcontextGetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetFontOptions -- get font options

   @{b}SYNOPSIS@{ub}
        handle = pcontext:GetFontOptions()

   @{b}FUNCTION@{ub}
        Retrieves any font rendering options previously set with
        @{"pcontext:SetFontOptions()" LINK pcontextSetFontOptions}.

        This function does not report options that are derived from the target
        surface by @{"pcontext:UpdateContext()" LINK pcontextUpdateContext}.

        This function returns the Cairo font options object previously set on
        the context, or NULL if no options have been set. The return object is
        owned by the context and must not be modified or freed. You can use
        @{"cfontoptions:IsNull()" LINK cfontoptionsIsNull} to check if the returned object is NULL.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a Cairo font options object

@ENDNODE

@NODE pcontextGetGravity "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetGravity -- get gravity

   @{b}SYNOPSIS@{ub}
        gravity = pcontext:GetGravity()

   @{b}FUNCTION@{ub}
        Retrieves the gravity for the context.

        This is similar to @{"pcontext:GetBaseGravity()" LINK pcontextGetBaseGravity}, except for when the base
        gravity is #PANGO_GRAVITY_AUTO for which @{"pango.GravityForMatrix()" LINK pangoGravityForMatrix} is
        used to return the gravity from the current context matrix.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        gravity   the resolved gravity for the context

@ENDNODE

@NODE pcontextGetGravityHint "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetGravityHint -- get gravity hint

   @{b}SYNOPSIS@{ub}
        hint = pcontext:GetGravityHint()

   @{b}FUNCTION@{ub}
        Retrieves the gravity hint for the context. See
        @{"pcontext:SetGravityHint()" LINK pcontextSetGravityHint} for details.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        hint      the gravity hint for the context

@ENDNODE

@NODE pcontextGetLanguage "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetLanguage -- get language

   @{b}SYNOPSIS@{ub}
        lang = pcontext:GetLanguage()

   @{b}FUNCTION@{ub}
        Retrieves the global language tag for the context. The return value will
        be a handle to a Pango language object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        lang      handle to the global language tag

@ENDNODE

@NODE pcontextGetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetMatrix -- get matrix

   @{b}SYNOPSIS@{ub}
        m = pcontext:GetMatrix()

   @{b}FUNCTION@{ub}
        Gets the transformation matrix that will be applied when rendering with
        this context. See @{"pcontext:SetMatrix()" LINK pcontextSetMatrix} for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        m         a Pango matrix object

@ENDNODE

@NODE pcontextGetMetrics "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetMetrics -- get metrics

   @{b}SYNOPSIS@{ub}
        metrics = pcontext:GetMetrics(desc, language)

   @{b}FUNCTION@{ub}
        Get overall metric information for a particular font description.

        Since the metrics may be substantially different for different scripts,
        a language tag can be provided to indicate that the metrics should be
        retrieved that correspond to the script(s) used by that language.

        The Pango font description is interpreted in the same way as by
        @{"pcontext:Itemize()" LINK pcontextItemize}, and the family name may be a comma separated list
        of names. If characters from multiple of these families would be used to
        render the string, then the returned fonts would be a composite of the
        metrics for the fonts loaded for the individual families.

        This function returns a Pango font metrics object. The caller must call
        @{"pfontmetrics:Free()" LINK pfontmetricsFree} when finished using the object.

   @{b}INPUTS@{ub}
        desc      a Pango font description structure; Nil means that the font
                  description from the context will be used
        language  language tag used to determine which script to get the metrics
                  for; Nil means that the language tag from the context will be
                  used; if no language tag is set on the context, metrics for
                  the default language (as determined by
                  @{"pango.GetDefaultLanguage()" LINK pangoGetDefaultLanguage} will be returned

   @{b}RESULTS@{ub}
        metrics   a Pango font metrics object

@ENDNODE

@NODE pcontextGetResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetResolution -- get context resolution

   @{b}SYNOPSIS@{ub}
        res = pcontext:GetResolution()

   @{b}FUNCTION@{ub}
        Gets the resolution for the context.

        This function returns the resolution in "dots per inch". A negative
        value will be returned if no resolution has previously been set.

        See @{"pcontext:SetResolution()" LINK pcontextSetResolution} for details.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        res       the context resolution in "dots per inch"

@ENDNODE

@NODE pcontextGetRoundGlyphPositions "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetRoundGlyphPositions -- get round glyph positions flag

   @{b}SYNOPSIS@{ub}
        ok = pcontext:GetRoundGlyphPositions()

   @{b}FUNCTION@{ub}
        Returns whether font rendering with this context should round glyph
        positions and widths.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        TRUE or FALSE indicating whether glyph positions and widths
                  should be rounded

@ENDNODE

@NODE pcontextGetSerial "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:GetSerial -- get serial of context

   @{b}SYNOPSIS@{ub}
        s = pcontext:GetSerial()

   @{b}FUNCTION@{ub}
        Returns the current serial number of the context.

        The serial number is initialized to an small number larger than zero
        when a new context is created and is increased whenever the context is
        changed using any of the setter functions, or the Pango font map it uses
        to find fonts has changed. The serial may wrap, but will never have the
        value 0. Since it can wrap, never compare it with "less than", always
        use "not equals".

        This can be used to automatically detect changes to a Pango context, and
        is only useful when implementing objects that need update when their
        Pango context changes, like Pango layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s         the current serial number of the context

@ENDNODE

@NODE pcontextIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:IsNull -- check if context is invalid

   @{b}SYNOPSIS@{ub}
        bool = pcontext:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the context is NULL, i.e. invalid. If functions that
        allocate contexts fail, they might not throw an error but simply set the
        context to NULL. You can use this function to check if context
        allocation has failed in which case the context will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the context is NULL, otherwise FALSE

@ENDNODE

@NODE pcontextItemize "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:Itemize -- check if context is invalid

   @{b}SYNOPSIS@{ub}
        list = pcontext:Itemize(text$, start_index, length, attrs[, base_dir])

   @{b}FUNCTION@{ub}
        Breaks a piece of text into segments with consistent directional level
        and font. Each byte of text will be contained in exactly one of the
        items in the returned list. The generated list of items will be in
        logical order (the start offsets of the items are ascending).

        Optionally, you can specify the base direction in the "base_dir"
        argument. The base direction is used when computing bidirectional
        levels. If "base_dir" is omitted, the base direction will be obtained
        from the context. See @{"pcontext:SetBaseDir()" LINK pcontextSetBaseDir} for a list of base
        directions.

        Note that you must free the individual Pango items in the list using
        @{"pitem:Free()" LINK pitemFree}.

   @{b}INPUTS@{ub}
        text$     the text to itemize
        start_index
                  first byte in text to process
        length    the number of bytes (not characters) to process after
                  "start_index". This must be >= 0
        attrs     a Pango attribute list containing the set of attributes that
                  apply to text
        base_dir  optional: base direction to use for bidirectional processing

   @{b}RESULTS@{ub}
        list      a table containing a list of Pango items; the caller is
                  responsible for freeing each item using @{"pitem:Free()" LINK pitemFree}

@ENDNODE

@NODE pcontextListFamilies "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:ListFamilies -- list families

   @{b}SYNOPSIS@{ub}
        t = pcontext:ListFamilies()

   @{b}FUNCTION@{ub}
        List all families for a context. The families are returned as a table
        containing a list of Pango font family handles. The font family handles
        are owned by the context and mustn't be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing all font families

@ENDNODE

@NODE pcontextLoadFont "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:LoadFont -- load font

   @{b}SYNOPSIS@{ub}
        font = pcontext:LoadFont(desc)

   @{b}FUNCTION@{ub}
        Loads the font in one of the fontmaps in the context that is the closest
        match for the Pango font description passed in "desc".

        This function returns the newly allocated Pango font that was loaded, or
        NULL if no font matched. You can use @{"pfont:IsNull()" LINK pfontIsNull} to check if the
        returned object contains a NULL font.

   @{b}INPUTS@{ub}
        desc      a Pango font description describing the font to load

   @{b}RESULTS@{ub}
        font      the newly allocated Pango font

@ENDNODE

@NODE pcontextLoadFontset "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:LoadFontset -- load fontset

   @{b}SYNOPSIS@{ub}
        fontset = pcontext:LoadFontset(desc, language)

   @{b}FUNCTION@{ub}
        Load a set of fonts in the context that can be used to render a font
        matching "desc".

        This function returns the newly allocated Pango font set that was
        loaded, or NULL if no font matched. You can use @{"pfontset:IsNull()" LINK pfontsetIsNull} to
        check if the returned object contains a NULL font set.

   @{b}INPUTS@{ub}
        desc      a Pango font description describing the fonts to load
        language  a Pango language the fonts will be used for

   @{b}RESULTS@{ub}
        fontset   the newly allocated font set

@ENDNODE

@NODE pcontextReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pcontext:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango context by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pcontextSetBaseDir "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetBaseDir -- set base direction for context

   @{b}SYNOPSIS@{ub}
        pcontext:SetBaseDir(direction)

   @{b}FUNCTION@{ub}
        Sets the base direction for the context. The "direction" parameter can
        be set to one of the following constants:

        #PANGO_DIRECTION_LTR
                  A strong left-to-right direction.
        #PANGO_DIRECTION_RTL
                  A strong right-to-left direction.
        #PANGO_DIRECTION_WEAK_LTR
                  A weak left-to-right direction.
        #PANGO_DIRECTION_WEAK_RTL
                  A weak right-to-left direction.
        #PANGO_DIRECTION_NEUTRAL
                  No direction specified.

        The base direction is used in applying the Unicode bidirectional
        algorithm; if the "direction" is #PANGO_DIRECTION_LTR or
        #PANGO_DIRECTION_RTL, then the value will be used as the paragraph
        direction in the Unicode bidirectional algorithm. A value of
        #PANGO_DIRECTION_WEAK_LTR or #PANGO_DIRECTION_WEAK_RTL is used only for
        paragraphs that do not contain any strong characters themselves.

   @{b}INPUTS@{ub}
        direction the new base direction

@ENDNODE

@NODE pcontextSetBaseGravity "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetBaseGravity -- set base gravity

   @{b}SYNOPSIS@{ub}
        pcontext:SetBaseGravity(gravity)

   @{b}FUNCTION@{ub}
        Sets the base gravity for the context. The "gravity" parameter can be
        set to one of the following constants:

        #PANGO_GRAVITY_SOUTH
                  Glyphs stand upright (default).
        #PANGO_GRAVITY_EAST
                  Glyphs are rotated 90 degrees counter-clockwise.
        #PANGO_GRAVITY_NORTH
                  Glyphs are upside-down.
        #PANGO_GRAVITY_WEST
                  Glyphs are rotated 90 degrees clockwise.
        #PANGO_GRAVITY_AUTO
                  The base gravity is used in laying vertical text out.

   @{b}INPUTS@{ub}
        gravity   the new base gravity (see above)

@ENDNODE

@NODE pcontextSetFontDescription "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetFontDescription -- set font description

   @{b}SYNOPSIS@{ub}
        pcontext:SetFontDescription(desc)

   @{b}FUNCTION@{ub}
        Set the default font description for the context. The "desc" parameter
        can also be Nil to reset the font description to a default value.

   @{b}INPUTS@{ub}
        desc      the new pango font description or Nil

@ENDNODE

@NODE pcontextSetFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetFontMap -- set font map

   @{b}SYNOPSIS@{ub}
        pcontext:SetFontMap(font_map)

   @{b}FUNCTION@{ub}
        Sets the font map to be searched when fonts are looked-up in this
        context. The "font_map" parameter can also be Nil to reset the font map
        to a default value.

        This is only for internal use by Pango backends, a Pango context
        obtained via one of the recommended methods should already have a
        suitable font map.

   @{b}INPUTS@{ub}
        font_map  the Pango font map to set or Nil

@ENDNODE

@NODE pcontextSetFontOptions "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetFontOptions -- set font options

   @{b}SYNOPSIS@{ub}
        pcontext:SetFontOptions(options)

   @{b}FUNCTION@{ub}
        Sets the font options used when rendering text with this context. These
        options override any options that @{"pcontext:UpdateContext()" LINK pcontextUpdateContext} derives from
        the target surface. This function will make a copy of the "options"
        object passed to it.

   @{b}INPUTS@{ub}
        options   a Cairo font obtions objects or Nil to unset any previously
                  set options

@ENDNODE

@NODE pcontextSetGravityHint "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetGravityHint -- set gravity hint

   @{b}SYNOPSIS@{ub}
        pcontext:SetGravityHint(hint)

   @{b}FUNCTION@{ub}
        Sets the gravity hint for the context. The "hint" parameter can be one
        of the following constants:

        #PANGO_GRAVITY_HINT_NATURAL
                  Scripts will take their natural gravity based on the base
                  gravity and the script. This is the default.
        #PANGO_GRAVITY_HINT_STRONG
                  Always use the base gravity set, regardless of the script.
        #PANGO_GRAVITY_HINT_LINE
                  For scripts not in their natural direction (e.g. Latin in East
                  gravity), choose per-script gravity such that every script
                  respects the line progression. This means, Latin and Arabic
                  will take opposite gravities and both flow top-to-bottom for
                  example.

        The gravity hint is used in laying vertical text out, and is only
        relevant if gravity of the context as returned by @{"pcontext:GetGravity()" LINK pcontextGetGravity}
        is set to #PANGO_GRAVITY_EAST or #PANGO_GRAVITY_WEST.

   @{b}INPUTS@{ub}
        hint      the new gravity hint (see above)

@ENDNODE

@NODE pcontextSetLanguage "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetLanguage -- set language

   @{b}SYNOPSIS@{ub}
        pcontext:SetLanguage(language)

   @{b}FUNCTION@{ub}
        Sets the global language tag for the context. The "language" parameter
        can also be Nil to reset the language to the default.

        The default language for the locale of the running process can be found
        using @{"pango.GetDefaultLanguage()" LINK pangoGetDefaultLanguage}.

   @{b}INPUTS@{ub}
        language  the new language tag or Nil

@ENDNODE

@NODE pcontextSetMatrix "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetMatrix -- set matrix

   @{b}SYNOPSIS@{ub}
        pcontext:SetMatrix(matrix)

   @{b}FUNCTION@{ub}
        Sets the transformation matrix that will be applied when rendering with
        this context.

        Note that reported metrics are in the user space coordinates before the
        application of the matrix, not device-space coordinates after the
        application of the matrix. So, they don't scale with the matrix, though
        they may change slightly for different matrices, depending on how the
        text is fit to the pixel grid.

   @{b}INPUTS@{ub}
        matrix    a Pango matrix

@ENDNODE

@NODE pcontextSetResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetResolution -- set context resolution

   @{b}SYNOPSIS@{ub}
        pcontext:SetResolution(dpi)

   @{b}FUNCTION@{ub}
        Sets the resolution for the context.

        This is a scale factor between points specified in a Pango font
        description and Cairo units. The default value is 96, meaning that a 10
        point font will be 13 units high. (10 * 96. / 72. = 13.3).

        Note that even though the resolution must be in "dots per inch",
        physical inches aren't actually involved. The terminology is
        conventional. A 0 or negative value means to use the resolution from the
        font map.

   @{b}INPUTS@{ub}
        dpi       the resolution in "dots per inch"

@ENDNODE

@NODE pcontextSetRoundGlyphPositions "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetRoundGlyphPositions -- set round glyph positions

   @{b}SYNOPSIS@{ub}
        pcontext:SetRoundGlyphPositions(round_positions)

   @{b}FUNCTION@{ub}
        Sets whether font rendering with this context should round glyph
        positions and widths to integral positions, in device units.

        This is useful when the renderer can't handle subpixel positioning of
        glyphs.

        The default value is to round glyph positions, to remain compatible with
        previous Pango behavior.

   @{b}INPUTS@{ub}
        round_positions
                  boolean specifying whether to round glyph positions

@ENDNODE

@NODE pcontextSetShapeRenderer "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:SetShapeRenderer -- set shape renderer

   @{b}SYNOPSIS@{ub}
        pcontext:SetShapeRenderer([func[, userdata]])

   @{b}FUNCTION@{ub}
        Sets callback function for context to use for rendering attributes of
        type #PANGO_ATTR_SHAPE.

        The callback function will receive three to four arguments: The first
        argument will be a handle to a Cairo context, the second argument will
        be a Pango attribute of type shape and the third argument will be a
        boolean that indicates whether only the shape path should be appended to
        current path of the Cairo context and no filling/stroking should be
        done. If you specify the "userdata" parameter, it will be forwarded to
        the callback function as the fourth parameter.

        To disable shape rendering, call this function without any arguments.

        Note that you must make sure that the object you call this function on
        stays valid for as long as you need the shape renderer so make sure that
        you don't set it to Nil and make sure that the object isn't
        garbage-collected in any way. See the ShapeText.hws example that comes
        with Pangomonium for an example on how to make sure that the object you
        call this function on doesn't get garbage collected.

   @{b}INPUTS@{ub}
        func      optional: callback function for rendering attributes of type
                  #PANGO_ATTR_SHAPE
        userdata  optional: user data that will be passed to "func"

@ENDNODE

@NODE pcontextUpdateContext "Pangomonium Guide"

   @{b}NAME@{ub}
        pcontext:UpdateContext -- update context

   @{b}SYNOPSIS@{ub}
        pcontext:UpdateContext(context)

   @{b}FUNCTION@{ub}
        Updates a Pango context previously created for use with Cairo to match
        the current transformation and target surface of the Cairo context
        passed in "context".

        If any layouts have been created for the context, it's necessary to call
        @{"playout:ContextChanged()" LINK playoutContextChanged} on those layouts.

   @{b}INPUTS@{ub}
        context   a Cairo context

@ENDNODE

@NODE pcoverageCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:Copy -- copy coverage

   @{b}SYNOPSIS@{ub}
        handle = pcoverage:Copy()

   @{b}FUNCTION@{ub}
        Copy an existing Pango coverage.

        This function returns the newly allocated Pango coverage, with a
        reference count of one, which should be freed with @{"pcoverage:Free()" LINK pcoverageFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango coverage,

@ENDNODE

@NODE pcoverageFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:Free -- free coverage

   @{b}SYNOPSIS@{ub}
        pcoverage:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count on the Pango coverage by one. If the result
        is zero, free the coverage and all associated memory.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pcoverageGet "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:Get -- get coverage level

   @{b}SYNOPSIS@{ub}
        level = pcoverage:Get(index)

   @{b}FUNCTION@{ub}
        Determine whether a particular index is covered by the coverage. This
        function returns the coverage level of the coverage for character
        "index".

   @{b}INPUTS@{ub}
        index     the index to check

   @{b}RESULTS@{ub}
        level     the coverage level for character "index"

@ENDNODE

@NODE pcoverageIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:IsNull -- check if coverage is invalid

   @{b}SYNOPSIS@{ub}
        bool = pcoverage:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the coverage is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the coverage will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the coverage is NULL, otherwise FALSE

@ENDNODE

@NODE pcoverageReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pcoverage:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango coverage by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pcoverageSet "Pangomonium Guide"

   @{b}NAME@{ub}
        pcoverage:Set -- set coverage level

   @{b}SYNOPSIS@{ub}
        pcoverage:Set(index, level)

   @{b}FUNCTION@{ub}
        Modify a particular index within the coverage.

   @{b}INPUTS@{ub}
        index     the index to modify
        level     the new level for "index"

@ENDNODE

@NODE pfontDescribe "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:Describe -- get font description

   @{b}SYNOPSIS@{ub}
        desc = pfont:Describe()

   @{b}FUNCTION@{ub}
        Returns a description of the font, with font size set in points.

        Use @{"pfont:DescribeWithAbsoluteSize()" LINK pfontDescribeWithAbsoluteSize} if you want the font size in device
        units.

        This function returns a newly-allocated Pango font description object.
        You are responsible for freeing this object using @{"pfontdesc:Free()" LINK pfontdescFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        desc      a newly-allocated Pango font description object

@ENDNODE

@NODE pfontDescribeWithAbsoluteSize "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:DescribeWithAbsoluteSize -- describe with absolute size

   @{b}SYNOPSIS@{ub}
        desc = pfont:DescribeWithAbsoluteSize()

   @{b}FUNCTION@{ub}
        Returns a description of the font, with absolute font size set in device
        units.

        Use @{"pfont:Describe()" LINK pfontDescribe} if you want the font size in points.

        This function returns a newly-allocated Pango font description object.
        You are responsible for freeing this object using @{"pfontdesc:Free()" LINK pfontdescFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        desc      a newly-allocated Pango font description object

@ENDNODE

@NODE pfontFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:Free -- free font

   @{b}SYNOPSIS@{ub}
        pfont:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of a Pango font by one.

        If the result is zero, the font and all associated memory will be freed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontGetCoverage "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:GetCoverage -- get coverage map

   @{b}SYNOPSIS@{ub}
        cov = pfont:GetCoverage(language)

   @{b}FUNCTION@{ub}
        Computes the coverage map for a given font and language tag. The
        "language" parameter must be set to a Pango language object.

        This function returns a newly-allocated Pango coverage object. You are
        responsible for freeing this object using @{"pcoverage:Free()" LINK pcoverageFree}.

   @{b}INPUTS@{ub}
        language  the language tag

   @{b}RESULTS@{ub}
        cov       a newly-allocated Pango coverage

@ENDNODE

@NODE pfontGetFontMap "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:GetFontMap -- get font map

   @{b}SYNOPSIS@{ub}
        fontmap = pfont:GetFontMap()

   @{b}FUNCTION@{ub}
        Gets the font map for which the font was created.

        Note that the font maintains a *weak* reference to the font map, so if
        all references to font map are dropped, the font map will be finalized
        even if there are fonts created with the font map that are still alive.
        In that case this function will return a NULL object.

        It is the responsibility of the user to ensure that the font map is kept
        alive. In most uses this is not an issue as a Pango context holds a
        reference to the font map.

        You mustn't free the returned font map.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        fontmap   the Pango font map

@ENDNODE

@NODE pfontGetGlyphExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:GetGlyphExtents -- get glyph extents

   @{b}SYNOPSIS@{ub}
        ink_rect, logical_rect = pfont:GetGlyphExtents(glyph)

   @{b}FUNCTION@{ub}
        Gets the logical and ink extents of a glyph within a font. This function
        returns two tables that have the fields the "x", "y", "width", and
        "height" initialized.

        The coordinate system for each rectangle has its origin at the base line
        and horizontal origin of the character with increasing coordinates
        extending to the right and down. The macros PANGO_ASCENT(),
        PANGO_DESCENT(), PANGO_LBEARING(), and PANGO_RBEARING() can be used to
        convert from the extents rectangle to more traditional font metrics. The
        units of the rectangles are in 1/#PANGO_SCALE of a device unit.

        If the font is a NULL object, this function gracefully sets some sane
        values in the output variables and returns.

   @{b}INPUTS@{ub}
        glyph     the glyph index

   @{b}RESULTS@{ub}
        ink_rect  table containing the extents of the glyph as drawn
        logical_rect
                  table containing the logical extents of the glyph

@ENDNODE

@NODE pfontGetMetrics "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:GetMetrics -- get font metrics

   @{b}SYNOPSIS@{ub}
        metrics = pfont:GetMetrics([language])

   @{b}FUNCTION@{ub}
        Gets overall metric information for a font.

        Since the metrics may be substantially different for different scripts,
        a language tag can be provided to indicate that the metrics should be
        retrieved that correspond to the script(s) used by that language. If it
        is specified, the "language" parameter must be a Pango language object.

        If the font is a NULL object, this function gracefully sets some sane
        values in the output variables and returns.

        This function returns a Pango font metrics object. The caller must call
        @{"pfontmetrics:Free()" LINK pfontmetricsFree} when finished using the object.

   @{b}INPUTS@{ub}
        language  optional: language tag used to determine which script to get
                  the metrics for; if this parameter is omitted metrics for the
                  entire font will be returned

   @{b}RESULTS@{ub}
        metrics   a Pango font metrics object

@ENDNODE

@NODE pfontGetScaledFont "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:GetScaledFont -- get scaled font

   @{b}SYNOPSIS@{ub}
        handle = pfont:GetScaledFont()

   @{b}FUNCTION@{ub}
        Gets the Cairo scaled font object used by the Pango font. The scaled
        font can be referenced and kept using @{"cscaledfont:Reference()" LINK cscaledfontReference}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a Cairo scaled font object

@ENDNODE

@NODE pfontHasChar "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:HasChar -- check if font has glyph

   @{b}SYNOPSIS@{ub}
        ok = pfont:HasChar(wc)

   @{b}FUNCTION@{ub}
        Returns whether the font provides a glyph for this character.

   @{b}INPUTS@{ub}
        wc        a Unicode character

   @{b}RESULTS@{ub}
        ok        TRUE if the font can render the glyph, FALSE otherwise

@ENDNODE

@NODE pfontIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:IsNull -- check if font is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfont:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font is NULL, i.e. invalid. If functions that
        allocate fonts fail, they might not throw an error but simply set the
        font to NULL. You can use this function to check if font allocation has
        failed in which case the font will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the font is NULL, otherwise FALSE

@ENDNODE

@NODE pfontReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pfont:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pfont:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango font by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontdescBetterMatch "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:BetterMatch -- match font descriptions

   @{b}SYNOPSIS@{ub}
        ok = pfontdesc:BetterMatch(old_match, new_match)

   @{b}FUNCTION@{ub}
        Determines if the style attributes of "new_match" are a closer match for
        the font description than those of "old_match" are, or if "old_match" is
        Nil, determines if "new_match" is a match at all.

        Approximate matching is done for weight and style; other style
        attributes must match exactly. Style attributes are all attributes other
        than family and size-related attributes. Approximate matching for style
        considers #PANGO_STYLE_OBLIQUE and #PANGO_STYLE_ITALIC as matches, but
        not as good a match as when the styles are equal.

        Note that "old_match" must match the font description.

   @{b}INPUTS@{ub}
        old_match a Pango font description object or Nil
        new_match a Pango font description object

   @{b}RESULTS@{ub}
        ok        TRUE if "new_match" is a better match

@ENDNODE

@NODE pfontdescCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:Copy -- copy font description

   @{b}SYNOPSIS@{ub}
        desc = pfontdesc:Copy()

   @{b}FUNCTION@{ub}
        Make a copy of a Pango font description.

        This function returns the newly allocated Pango font description, which
        should be freed with @{"pfontdesc:Free()" LINK pfontdescFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        desc      the newly allocated Pango font description

@ENDNODE

@NODE pfontdescEqual "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:Equal -- compare font descriptions for equality

   @{b}SYNOPSIS@{ub}
        ok = pfontdesc:Equal(desc2)

   @{b}FUNCTION@{ub}
        Compares two font descriptions for equality.

        Two font descriptions are considered equal if the fonts they describe
        are provably identical. This means that their masks do not have to
        match, as long as other fields are all the same. (Two font descriptions
        may result in identical fonts being loaded, but still compare FALSE.)

        This function returns TRUE if the two font descriptions are identical,
        FALSE otherwise.

   @{b}INPUTS@{ub}
        desc2     another Pango font description object

   @{b}RESULTS@{ub}
        ok        TRUE if the two font descriptions are identical, otherwise
                  FALSE

@ENDNODE

@NODE pfontdescFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:Free -- free font description

   @{b}SYNOPSIS@{ub}
        pfontdesc:Free()

   @{b}FUNCTION@{ub}
        Frees a font description.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontdescGetFamily "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetFamily -- get family name

   @{b}SYNOPSIS@{ub}
        family$ = pfontdesc:GetFamily()

   @{b}FUNCTION@{ub}
        Gets the family name field of a font description. See
        @{"pfontdesc:SetFamily()" LINK pfontdescSetFamily} for more information.

        This function returns the family name field for the font description, or
        Nil if not previously set.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        family$   the family name

@ENDNODE

@NODE pfontdescGetGravity "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetGravity -- get font gravity

   @{b}SYNOPSIS@{ub}
        gravity = pfontdesc:GetGravity()

   @{b}FUNCTION@{ub}
        Gets the gravity field of a font description. See @{"pfontdesc:SetGravity()" LINK pfontdescSetGravity}
        for more information.

        This function returns the gravity field for the font description. Use
        @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the field was explicitly set or
        not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        gravity   the gravity field for the font description

@ENDNODE

@NODE pfontdescGetSetFields "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetSetFields -- determine which fields have been set

   @{b}SYNOPSIS@{ub}
        mask = pfontdesc:GetSetFields()

   @{b}FUNCTION@{ub}
        Determines which fields in a font description have been set.

        This function returns a bitmask with bits set corresponding to the
        fields in the font description that have been set. The following bits
        can be set:

        #PANGO_FONT_MASK_FAMILY
                  The font family is specified.
        #PANGO_FONT_MASK_STYLE
                  The font style is specified.
        #PANGO_FONT_MASK_VARIANT
                  The font variant is specified.
        #PANGO_FONT_MASK_WEIGHT
                  The font weight is specified.
        #PANGO_FONT_MASK_STRETCH
                  The font stretch is specified.
        #PANGO_FONT_MASK_SIZE
                  The font size is specified.
        #PANGO_FONT_MASK_GRAVITY
                  The font gravity is specified.
        #PANGO_FONT_MASK_VARIATIONS
                  OpenType font variations are specified.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mask      a bitmask with bits set corresponding to the set fields (see
                  above)

@ENDNODE

@NODE pfontdescGetSize "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetSize -- get size

   @{b}SYNOPSIS@{ub}
        size = pfontdesc:GetSize()

   @{b}FUNCTION@{ub}
        Gets the size field of a font description. See @{"pfontdesc:SetSize()" LINK pfontdescSetSize} for
        more information.

        This function returns the size field for the font description in points
        or device units. You must call @{"pfontdesc:GetSizeIsAbsolute()" LINK pfontdescGetSizeIsAbsolute} to find out
        which is the case. Returns 0 if the size field has not previously been
        set or it has been set to 0 explicitly. Use @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to
        find out if the field was explicitly set or not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        size      the size field for the font description in points

@ENDNODE

@NODE pfontdescGetSizeIsAbsolute "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetSizeIsAbsolute -- determine whether the size is in device units

   @{b}SYNOPSIS@{ub}
        isabs = pfontdesc:GetSizeIsAbsolute()

   @{b}FUNCTION@{ub}
        Determines whether the size of the font is in points (not absolute) or
        device units (absolute).

        See @{"pfontdesc:SetSize()" LINK pfontdescSetSize} and @{"pfontdesc:SetAbsoluteSize()" LINK pfontdescSetAbsoluteSize} for more
        information.

        This function returns whether the size for the font description is in
        points or device units. Use @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the
        size field of the font description was explicitly set or not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        isabs     whether the size for the font description is in absolute units

@ENDNODE

@NODE pfontdescGetStretch "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetStretch -- get stretch field

   @{b}SYNOPSIS@{ub}
        stretch = pfontdesc:GetStretch()

   @{b}FUNCTION@{ub}
        Gets the stretch field of a font description. See @{"pfontdesc:SetStretch()" LINK pfontdescSetStretch}
        for more information.

        This function returns the stretch field for the font description. Use
        @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the field was explicitly set or
        not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        stretch   the stretch field for the font description

@ENDNODE

@NODE pfontdescGetStyle "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetStyle -- get style field

   @{b}SYNOPSIS@{ub}
        style = pfontdesc:GetStyle()

   @{b}FUNCTION@{ub}
        Gets the style field of a Pango font description. See
        @{"pfontdesc:SetStyle()" LINK pfontdescSetStyle} for more information.

        This function returns the style field for the font description. Use
        @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the field was explicitly set or
        not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        style     the style field for the font description

@ENDNODE

@NODE pfontdescGetVariant "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetVariant -- get variant field

   @{b}SYNOPSIS@{ub}
        var = pfontdesc:GetVariant()

   @{b}FUNCTION@{ub}
        Gets the variant field of a Pango font description. See
        @{"pfontdesc:SetVariant()" LINK pfontdescSetVariant} for more information.

        This function returns the variant field for the font description. Use
        @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the field was explicitly set or
        not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        var       the variant field for the font description

@ENDNODE

@NODE pfontdescGetVariations "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetVariations -- get variations field

   @{b}SYNOPSIS@{ub}
        var$ = pfontdesc:GetVariations()

   @{b}FUNCTION@{ub}
        Gets the variations field of a font description. See
        @{"pfontdesc:SetVariations()" LINK pfontdescSetVariations} for more information.

        This function returns the variations field for the font description, or
        Nil if not previously set.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        var$      the variations field for the font description

@ENDNODE

@NODE pfontdescGetWeight "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:GetWeight -- get weight field

   @{b}SYNOPSIS@{ub}
        weight = pfontdesc:GetWeight()

   @{b}FUNCTION@{ub}
        Gets the weight field of a font description. See @{"pfontdesc:SetWeight()" LINK pfontdescSetWeight}
        for more information.

        This function returns the weight field for the font description. Use
        @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} to find out if the field was explicitly set or
        not.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        weight    the weight field for the font description

@ENDNODE

@NODE pfontdescIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:IsNull -- check if font description is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontdesc:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font description is NULL, i.e. invalid. If functions
        that allocate objects fail, they might not throw an error but simply set
        the object to NULL. You can use this function to check if object
        allocation has failed in which case the font description will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the font description is NULL, otherwise FALSE

@ENDNODE

@NODE pfontdescMerge "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:Merge -- merge fields

   @{b}SYNOPSIS@{ub}
        pfontdesc:Merge(desc_to_merge, replace_existing)

   @{b}FUNCTION@{ub}
        Merges the fields that are set in "desc_to_merge" into the fields in the
        font description.

        If "replace_existing" is FALSE, only fields in the font description that
        are not already set are affected. If TRUE, then fields that are already
        set will be replaced as well.

   @{b}INPUTS@{ub}
        desc_to_merge
                  the Pango font description object to merge from
        replace_existing
                  if TRUE, replace fields in the font description with the
                  corresponding values from "desc_to_merge", even if they are
                  already exist.

@ENDNODE

@NODE pfontdescSetAbsoluteSize "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetAbsoluteSize -- set absolute size

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetAbsoluteSize(size)

   @{b}FUNCTION@{ub}
        Sets the size field of a font description, in device units.

        This is mutually exclusive with @{"pfontdesc:SetSize()" LINK pfontdescSetSize} which sets the font
        size in points.

   @{b}INPUTS@{ub}
        size      the new size, in Pango units; there are #PANGO_SCALE Pango
                  units in one device unit; for an output backend where a device
                  unit is a pixel, a size value of 10 * #PANGO_SCALE gives a 10
                  pixel font

@ENDNODE

@NODE pfontdescSetFamily "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetFamily -- set family

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetFamily(family$)

   @{b}FUNCTION@{ub}
        Sets the family name field of a font description.

        The family name represents a family of related font styles, and will
        resolve to a particular Pango font family. In some uses of Pango font
        description, it is also possible to use a comma separated list of family
        names for this field.

   @{b}INPUTS@{ub}
        family$   a string representing the family name

@ENDNODE

@NODE pfontdescSetGravity "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetGravity -- set gravity

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetGravity(gravity)

   @{b}FUNCTION@{ub}
        Sets the gravity field of a font description.

        The gravity field specifies how the glyphs should be rotated. If
        "gravity" is #PANGO_GRAVITY_AUTO, this actually unsets the gravity mask
        on the font description.

        This function is seldom useful to the user. Gravity should normally be
        set on a Pango context.

        See @{"pcontext:SetBaseGravity()" LINK pcontextSetBaseGravity} for a list of constants that can be passed
        in the "gravity" argument.

   @{b}INPUTS@{ub}
        gravity   the gravity for the font description

@ENDNODE

@NODE pfontdescSetSize "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetSize -- set size

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetSize(size)

   @{b}FUNCTION@{ub}
        Sets the size field of a font description in fractional points.

        This is mutually exclusive with @{"pfontdesc:SetAbsoluteSize()" LINK pfontdescSetAbsoluteSize}.

   @{b}INPUTS@{ub}
        size      the size of the font in points, scaled by #PANGO_SCALE (that
                  is, a size value of 10 * #PANGO_SCALE is a 10 point font; the
                  conversion factor between points and device units depends on
                  system configuration and the output device; for screen
                  display, a logical DPI of 96 is common, in which case a 10
                  point font corresponds to a 10 * (96 / 72) = 13.3 pixel font.
                  Use @{"pfontdesc:SetAbsoluteSize()" LINK pfontdescSetAbsoluteSize} if you need a particular size
                  in device units

@ENDNODE

@NODE pfontdescSetStretch "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetStretch -- set stretch field

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetStretch(stretch)

   @{b}FUNCTION@{ub}
        Sets the stretch field of a font description. The stretch field
        specifies how narrow or wide the font should be.

        The following constants can be passed in the "stretch" parameter:

        #PANGO_STRETCH_ULTRA_CONDENSED
                  Ultra condensed width.
        #PANGO_STRETCH_EXTRA_CONDENSED
                  Extra condensed width.
        #PANGO_STRETCH_CONDENSED
                  Condensed width.
        #PANGO_STRETCH_SEMI_CONDENSED
                  Semi condensed width.
        #PANGO_STRETCH_NORMAL
                  The normal width.
        #PANGO_STRETCH_SEMI_EXPANDED
                  Semi expanded width.
        #PANGO_STRETCH_EXPANDED
                  Expanded width.
        #PANGO_STRETCH_EXTRA_EXPANDED
                  Extra expanded width.
        #PANGO_STRETCH_ULTRA_EXPANDED
                  Ultra expanded width.

   @{b}INPUTS@{ub}
        stretch   the stretch for the font description (see above)

@ENDNODE

@NODE pfontdescSetStyle "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetStyle -- set style field

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetStyle(style)

   @{b}FUNCTION@{ub}
        Sets the style field of a Pango font description.

        The style field describes whether the font is slanted and the manner in
        which it is slanted; it can be either #PANGO_STYLE_NORMAL,
        #PANGO_STYLE_ITALIC, or #PANGO_STYLE_OBLIQUE.

        Most fonts will either have a italic style or an oblique style, but not
        both, and font matching in Pango will match italic specifications with
        oblique fonts and vice-versa if an exact match is not found.

   @{b}INPUTS@{ub}
        style     the style for the font description (see above)

@ENDNODE

@NODE pfontdescSetVariant "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetVariant -- set variant field

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetVariant(variant)

   @{b}FUNCTION@{ub}
        Sets the variant field of a font description.

        The variant field can either be #PANGO_VARIANT_NORMAL or
        #PANGO_VARIANT_SMALL_CAPS.

   @{b}INPUTS@{ub}
        variant   the variant type for the font description (see above)

@ENDNODE

@NODE pfontdescSetVariations "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetVariations -- set variations

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetVariations(variations$)

   @{b}FUNCTION@{ub}
        Sets the variations field of a font description.

        OpenType font variations allow to select a font instance by specifying
        values for a number of axes, such as width or weight.

        The format of the variations string is

            AXIS1=VALUE,AXIS2=VALUE...

        with each AXIS a 4 character tag that identifies a font axis, and each
        VALUE a floating point number. Unknown axes are ignored, and values are
        clamped to their allowed range.

        Pango does not currently have a way to find supported axes of a font.
        Both harfbuzz and freetype have API for this.

   @{b}INPUTS@{ub}
        variations$
                  a string representing the variations

@ENDNODE

@NODE pfontdescSetWeight "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:SetWeight -- set weight field

   @{b}SYNOPSIS@{ub}
        pfontdesc:SetWeight(weight)

   @{b}FUNCTION@{ub}
        Sets the weight field of a font description.

        The weight field specifies how bold or light the font should be. This
        can be a numeric value between 100 and 1000 or one of the following
        predefined weight constants:

        #PANGO_WEIGHT_THIN
                  The thin weight (= 100).
        #PANGO_WEIGHT_ULTRALIGHT
                  The ultralight weight (= 200).
        #PANGO_WEIGHT_LIGHT
                  The light weight (= 300).
        #PANGO_WEIGHT_SEMILIGHT
                  The semilight weight (= 350).
        #PANGO_WEIGHT_BOOK
                  The book weight (= 380).
        #PANGO_WEIGHT_NORMAL
                  The default weight (= 400).
        #PANGO_WEIGHT_MEDIUM
                  The medium weight (= 500).
        #PANGO_WEIGHT_SEMIBOLD
                  The semibold weight (= 600).
        #PANGO_WEIGHT_BOLD
                  The bold weight (= 700).
        #PANGO_WEIGHT_ULTRABOLD
                  The ultrabold weight (= 800).
        #PANGO_WEIGHT_HEAVY
                  The heavy weight (= 900).
        #PANGO_WEIGHT_ULTRAHEAVY
                  The ultraheavy weight (= 1000).

   @{b}INPUTS@{ub}
        weight    the weight for the font description (see above)

@ENDNODE

@NODE pfontdescToFilename "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:ToFilename -- create filename of font description

   @{b}SYNOPSIS@{ub}
        f$ = pfontdesc:ToFilename()

   @{b}FUNCTION@{ub}
        Creates a filename representation of a font description.

        The filename is identical to the result from calling
        @{"pfontdesc:ToString()" LINK pfontdescToString}, but with underscores instead of characters that
        are untypical in filenames, and in lower case only.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        f$        filename representation of font description

@ENDNODE

@NODE pfontdescToString "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:ToString -- create string of font description

   @{b}SYNOPSIS@{ub}
        s$ = pfontdesc:ToString()

   @{b}FUNCTION@{ub}
        Creates a string representation of a font description.

        See @{"pango.FontDescription()" LINK pangoFontDescription} for a description of the format of the
        string representation. The family list in the string description will
        only have a terminating comma if the last word of the list is a valid
        style option.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s$        string representation of font description

@ENDNODE

@NODE pfontdescUnsetFields "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontdesc:UnsetFields -- unset fields

   @{b}SYNOPSIS@{ub}
        pfontdesc:UnsetFields(to_unset)

   @{b}FUNCTION@{ub}
        Unsets some of the fields in a Pango font description. The unset fields
        will get back to their default values.

        See @{"pfontdesc:GetSetFields()" LINK pfontdescGetSetFields} for a list of supported fields.

   @{b}INPUTS@{ub}
        to_unset  bitmask of fields in the the font description to unset

@ENDNODE

@NODE pfontfaceDescribe "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontface:Describe -- return font description

   @{b}SYNOPSIS@{ub}
        desc = pfontface:Describe()

   @{b}FUNCTION@{ub}
        Returns a font description that matches the face.

        The resulting font description will have the family, style, variant,
        weight and stretch of the face, but its size field will be unset.

        This function returns a newly-created Pango font description structure
        holding the description of the face. Use @{"pfontdesc:Free()" LINK pfontdescFree} to free the
        result.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        desc      a newly-created Pango font description structure

@ENDNODE

@NODE pfontfaceGetFaceName "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontface:GetFaceName -- get face name

   @{b}SYNOPSIS@{ub}
        name$ = pfontface:GetFaceName()

   @{b}FUNCTION@{ub}
        Gets a name representing the style of this face.

        Note that a font family may contain multiple faces with the same name
        (e.g. a variable and a non-variable face for the same style).

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        name$     the face name for the face

@ENDNODE

@NODE pfontfaceIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontface:IsNull -- check if font face is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontface:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font face is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the font face will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the font face is NULL, otherwise FALSE

@ENDNODE

@NODE pfontfaceIsSynthesized "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontface:IsSynthesized -- check if font face is synthesized

   @{b}SYNOPSIS@{ub}
        ok = pfontface:IsSynthesized()

   @{b}FUNCTION@{ub}
        Returns whether a Pango font face is synthesized.

        This will be the case if the underlying font rendering engine creates
        this face from another face, by shearing, emboldening, lightening or
        modifying it in some other way.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        boolean indicating whether the font face is synthesized

@ENDNODE

@NODE pfontfaceListSizes "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontface:ListSizes -- list sizes

   @{b}SYNOPSIS@{ub}
        t = pfontface:ListSizes()

   @{b}FUNCTION@{ub}
        List the available sizes for a font. This returns a table containing a
        list of sizes for the font. The sizes returned are in Pango units and
        are sorted in ascending order.

        This is only applicable to bitmap fonts. For scalable fonts, an empty
        table is returned.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing a list of font sizes

@ENDNODE

@NODE pfontfamilyGetName "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontfamily:GetName -- get family name

   @{b}SYNOPSIS@{ub}
        name$ = pfontfamily:GetName()

   @{b}FUNCTION@{ub}
        Gets the name of the family.

        The name is unique among all fonts for the font backend and can be used
        in a Pango font description to specify that a face from this family is
        desired.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        name$     the name of the family

@ENDNODE

@NODE pfontfamilyIsMonospace "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontfamily:IsMonospace -- check if family is monospace

   @{b}SYNOPSIS@{ub}
        ok = pfontfamily:IsMonospace()

   @{b}FUNCTION@{ub}
        A monospace font is a font designed for text display where the the
        characters form a regular grid.

        For Western languages this would mean that the advance width of all
        characters are the same, but this categorization also includes Asian
        fonts which include double-width characters: characters that occupy two
        grid cells.

        The best way to find out the grid-cell size is to call
        @{"pfontmetrics:GetApproximateDigitWidth()" LINK pfontmetricsGetApproximateDigitWidth}, since the results of
        @{"pfontmetrics:GetApproximateCharWidth()" LINK pfontmetricsGetApproximateCharWidth} may be affected by double-width
        characters.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        TRUE if the family is monospace, FALSE otherwise

@ENDNODE

@NODE pfontfamilyIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontfamily:IsNull -- check if font family is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontfamily:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the font family is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the font family will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the font family is NULL, otherwise FALSE

@ENDNODE

@NODE pfontfamilyIsVariable "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontfamily:IsVariable -- check if family is variable

   @{b}SYNOPSIS@{ub}
        ok = pfontfamily:IsVariable()

   @{b}FUNCTION@{ub}
        A variable font is a font which has axes that can be modified to produce
        different faces.

        Such axes are also known as variations; see @{"pfontdesc:SetVariations()" LINK pfontdescSetVariations}
        for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ok        TRUE if the family is variable, FALSE otherwise

@ENDNODE

@NODE pfontfamilyListFaces "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontfamily:ListFaces -- list faces inside the family

   @{b}SYNOPSIS@{ub}
        t = pfontfamily:ListFaces()

   @{b}FUNCTION@{ub}
        Lists the different font faces that make up the font family. The faces
        in a family share a common design, but differ in slant, weight, width
        and other aspects.

        This function will return a table containing all family faces as Pango
        font face objects. You mustn't free the individual Pango font face
        objects because they are owned by the family. Note that the returned
        faces are not in any particular order, and multiple faces may have the
        same name or characteristics.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing a list of Pango font face objects

@ENDNODE

@NODE pfontmapChanged "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:Changed -- force context change

   @{b}SYNOPSIS@{ub}
        pfontmap:Changed()

   @{b}FUNCTION@{ub}
        Forces a change in the context, which will cause any Pango context using
        this fontmap to change.

        This function is only useful when implementing a new backend for Pango,
        something applications won't do. Backends should call this function if
        they have attached extra data to the context and such data is changed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontmapCreateContext "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:CreateContext -- create context

   @{b}SYNOPSIS@{ub}
        context = pfontmap:CreateContext()

   @{b}FUNCTION@{ub}
        Creates a Pango context connected to the fontmap.

        This is equivalent to @{"pango.Context()" LINK pangoContext} followed by @{"pcontext:SetFontMap()" LINK pcontextSetFontMap}.

        This function returns the newly allocated Pango context, which should be
        freed with @{"pcontext:Free()" LINK pcontextFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        context   the newly allocated Pango context

@ENDNODE

@NODE pfontmapFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:Free -- free fontmap

   @{b}SYNOPSIS@{ub}
        pfontmap:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of a Pango fontmap by one.

        If the result is zero, the fontmap and all associated memory will be
        freed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontmapGetFontType "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:GetFontType -- get font type

   @{b}SYNOPSIS@{ub}
        type = pfontmap:GetFontType()

   @{b}FUNCTION@{ub}
        Gets the type of Cairo font backend that the fontmap uses. See
        @{"cfontface:GetType()" LINK cfontfaceGetType} for a list of Cairo font types.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        type      the Cairo font backend type (see above)

@ENDNODE

@NODE pfontmapGetResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:GetResolution -- get resolution

   @{b}SYNOPSIS@{ub}
        dpi = pfontmap:GetResolution()

   @{b}FUNCTION@{ub}
        Gets the resolution for the fontmap.

        See @{"pfontmap:SetResolution()" LINK pfontmapSetResolution} for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        dpi       the resolution in "dots per inch"

@ENDNODE

@NODE pfontmapGetSerial "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:GetSerial -- get serial

   @{b}SYNOPSIS@{ub}
        s = pfontmap:GetSerial()

   @{b}FUNCTION@{ub}
        Returns the current serial number of the fontmap.

        The serial number is initialized to an small number larger than zero
        when a new fontmap is created and is increased whenever the fontmap is
        changed. It may wrap, but will never have the value 0. Since it can
        wrap, never compare it with "less than", always use "not equals".

        The fontmap can only be changed using backend-specific API, like
        changing fontmap resolution.

        This can be used to automatically detect changes to a Pango font map,
        like in Pango context.

        This function returns the current serial number of the fontmap.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s         the current serial number of the fontmap

@ENDNODE

@NODE pfontmapIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:IsNull -- check if fontmap is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontmap:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the fontmap is NULL, i.e. invalid. If functions that
        allocate fontmaps fail, they might not throw an error but simply set the
        fontmap to NULL. You can use this function to check if fontmap
        allocation has failed in which case the fontmap will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the fontmap is NULL, otherwise FALSE

@ENDNODE

@NODE pfontmapListFamilies "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:ListFamilies -- list families

   @{b}SYNOPSIS@{ub}
        t = pfontmap:ListFamilies()

   @{b}FUNCTION@{ub}
        List all families for a fontmap. The families are returned as a table
        containing a list of Pango font family handles in arbitrary order. The
        font family handles are owned by the fontmap and mustn't be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing all font families

@ENDNODE

@NODE pfontmapLoadFont "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:LoadFont -- load font

   @{b}SYNOPSIS@{ub}
        font = pfontmap:LoadFont(context, desc)

   @{b}FUNCTION@{ub}
        Load the font in the fontmap that is the closest match for "desc".

        This function returns the newly allocated Pango font loaded, or a NULL
        object if no font matched. You can use @{"pfont:IsNull()" LINK pfontIsNull} to check if a font
        is NULL.

   @{b}INPUTS@{ub}
        context   the Pango context the font will be used with
        desc      a Pango font description describing the font to load

   @{b}RESULTS@{ub}
        font      the newly allocated Pango font

@ENDNODE

@NODE pfontmapLoadFontset "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:LoadFontset -- load fontset

   @{b}SYNOPSIS@{ub}
        pfontmap:LoadFontset(context, desc, language)

   @{b}FUNCTION@{ub}
        Load a set of fonts in the fontmap that can be used to render a font
        matching "desc".

        This function returns the newly allocated `PangoFontset` loaded, or Nil
        if no font matched.

   @{b}INPUTS@{ub}
        context   the Pango context the font will be used with
        desc      a Pango font description describing the font to load
        language  a Pango language the fonts will be used for

   @{b}RESULTS@{ub}
        x         the newly allocated

@ENDNODE

@NODE pfontmapReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pfontmap:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango fontmap by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontmapSetResolution "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmap:SetResolution -- set resolution

   @{b}SYNOPSIS@{ub}
        pfontmap:SetResolution(dpi)

   @{b}FUNCTION@{ub}
        Sets the resolution for the fontmap.

        This is a scale factor between points specified in a Pango font
        description and Cairo units. The default value is 96, meaning that a 10
        point font will be 13 units high. (10 * 96. / 72. = 13.3).

   @{b}INPUTS@{ub}
        dpi       the resolution in "dots per inch"; physical inches aren't
                  actually involved; the terminology is conventional

@ENDNODE

@NODE pfontmetricsFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:Free -- free font metrics

   @{b}SYNOPSIS@{ub}
        pfontmetrics:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of a font metrics object by one.

        If the result is zero, frees the object and any associated memory.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontmetricsGetApproximateCharWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetApproximateCharWidth -- get approximate char width

   @{b}SYNOPSIS@{ub}
        width = pfontmetrics:GetApproximateCharWidth()

   @{b}FUNCTION@{ub}
        Gets the approximate character width for a font metrics structure.

        This is merely a representative value useful, for example, for
        determining the initial size for a window. Actual characters in text
        will be wider and narrower than this.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the character width, in Pango units

@ENDNODE

@NODE pfontmetricsGetApproximateDigitWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetApproximateDigitWidth -- get approximate digit width

   @{b}SYNOPSIS@{ub}
        width = pfontmetrics:GetApproximateDigitWidth()

   @{b}FUNCTION@{ub}
        Gets the approximate digit width for a font metrics structure.

        This is merely a representative value useful, for example, for
        determining the initial size for a window. Actual digits in text can be
        wider or narrower than this, though this value is generally somewhat
        more accurate than the result of @{"pfontmetrics:GetApproximateCharWidth()" LINK pfontmetricsGetApproximateCharWidth}
        for digits.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the digit width, in Pango units

@ENDNODE

@NODE pfontmetricsGetAscent "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetAscent -- get ascent

   @{b}SYNOPSIS@{ub}
        ascent = pfontmetrics:GetAscent()

   @{b}FUNCTION@{ub}
        Gets the ascent from a font metrics structure.

        The ascent is the distance from the baseline to the logical top of a
        line of text. The logical top may be above or below the top of the
        actual drawn ink. It is necessary to lay out the text to figure where
        the ink will be.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ascent    the ascent, in Pango units

@ENDNODE

@NODE pfontmetricsGetDescent "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetDescent -- get descent

   @{b}SYNOPSIS@{ub}
        descent = pfontmetrics:GetDescent()

   @{b}FUNCTION@{ub}
        Gets the descent from a font metrics structure.

        The descent is the distance from the baseline to the logical bottom of a
        line of text. The logical bottom may be above or below the bottom of the
        actual drawn ink. It is necessary to lay out the text to figure where
        the ink will be.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        descent   the descent, in Pango units

@ENDNODE

@NODE pfontmetricsGetHeight "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetHeight -- get height

   @{b}SYNOPSIS@{ub}
        height = pfontmetrics:GetHeight()

   @{b}FUNCTION@{ub}
        Gets the line height from a font metrics structure.

        The line height is the recommended distance between successive baselines
        in wrapped text using this font.

        If the line height is not available, 0 is returned.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        height    the height, in Pango units

@ENDNODE

@NODE pfontmetricsGetStrikethroughPosition "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetStrikethroughPosition -- get strikethrough position

   @{b}SYNOPSIS@{ub}
        pos = pfontmetrics:GetStrikethroughPosition()

   @{b}FUNCTION@{ub}
        Gets the suggested position to draw the strikethrough.

        The value returned is the distance *above* the baseline of the top of
        the strikethrough.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        pos       the suggested strikethrough position, in Pango units

@ENDNODE

@NODE pfontmetricsGetStrikethroughThickness "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetStrikethroughThickness -- get strikethrough thickness

   @{b}SYNOPSIS@{ub}
        thick = pfontmetrics:GetStrikethroughThickness()

   @{b}FUNCTION@{ub}
        Gets the suggested thickness to draw for the strikethrough.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        thick     the suggested strikethrough thickness, in Pango units

@ENDNODE

@NODE pfontmetricsGetUnderlinePosition "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetUnderlinePosition -- get underline position

   @{b}SYNOPSIS@{ub}
        pos = pfontmetrics:GetUnderlinePosition()

   @{b}FUNCTION@{ub}
        Gets the suggested position to draw the underline.

        The value returned is the distance *above* the baseline of the top of
        the underline. Since most fonts have underline positions beneath the
        baseline, this value is typically negative.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        pos       the suggested underline position, in Pango units

@ENDNODE

@NODE pfontmetricsGetUnderlineThickness "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:GetUnderlineThickness -- get underline thickness

   @{b}SYNOPSIS@{ub}
        thick = pfontmetrics:GetUnderlineThickness()

   @{b}FUNCTION@{ub}
        Gets the suggested thickness to draw for the underline.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        thick     the suggested underline thickness, in Pango units

@ENDNODE

@NODE pfontmetricsIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:IsNull -- check if font metrics object is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontmetrics:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the object is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the object will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the object is NULL, otherwise FALSE

@ENDNODE

@NODE pfontmetricsReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontmetrics:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pfontmetrics:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count of a font metrics structure by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontsetForEach "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:ForEach -- iterate through all fonts

   @{b}SYNOPSIS@{ub}
        pfontset:ForEach(func[, userdata])

   @{b}FUNCTION@{ub}
        Iterates through all the fonts in a fontset, calling "func" for each
        one. If "func" returns TRUE, that stops the iteration.

        The callback function will receive the fontset in the first parameter
        and the Pango font in the second parameter. If you specify the
        "userdata" parameter, it will be passed to the callback as the third
        parameter.

   @{b}INPUTS@{ub}
        func      a callback function
        data      additional data to pass to the callback function

@ENDNODE

@NODE pfontsetFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:Free -- free fontset

   @{b}SYNOPSIS@{ub}
        pfontset:Free()

   @{b}FUNCTION@{ub}
        Frees a fontset.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pfontsetGetFont "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:GetFont -- get font

   @{b}SYNOPSIS@{ub}
        font = pfontset:GetFont(wc)

   @{b}FUNCTION@{ub}
        Returns the font in the fontset that contains the best glyph for a
        Unicode character. You must free the font returned by this function
        using @{"pfont:Free()" LINK pfontFree}.

   @{b}INPUTS@{ub}
        wc        a Unicode character

   @{b}RESULTS@{ub}
        font      a Pango font object

@ENDNODE

@NODE pfontsetGetMetrics "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:GetMetrics -- get metrics for all fonts

   @{b}SYNOPSIS@{ub}
        metrics = pfontset:GetMetrics()

   @{b}FUNCTION@{ub}
        Get overall metric information for the fonts in the fontset. You must
        free the font metrics object returned by this function using
        @{"pfontmetrics:Free()" LINK pfontmetricsFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        metrics   a Pango font metrics object

@ENDNODE

@NODE pfontsetIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:IsNull -- check if font set is invalid

   @{b}SYNOPSIS@{ub}
        bool = pfontset:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the fontset is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the fontset will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the fontset is NULL, otherwise FALSE

@ENDNODE

@NODE pfontsetReference "Pangomonium Guide"

   @{b}NAME@{ub}
        pfontset:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        pfontset:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango fontset by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pglyphitemCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:Copy -- copy glyph item

   @{b}SYNOPSIS@{ub}
        handle = pglyphitem:Copy()

   @{b}FUNCTION@{ub}
        Make a deep copy of an existing Pango glyph item structure.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango glyph item

@ENDNODE

@NODE pglyphitemFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:Free -- free glyph item

   @{b}SYNOPSIS@{ub}
        pglyphitem:Free()

   @{b}FUNCTION@{ub}
        Frees a Pango glyph item and resources to which it points.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pglyphitemGet "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:Get -- get glyph item data

   @{b}SYNOPSIS@{ub}
        t = pglyphitem:Get()

   @{b}FUNCTION@{ub}
        Gets information about the glyph item. The data is returned as a table.
        See @{"pglyphitem:Set()" LINK pglyphitemSet} for a description of all the fields that will be
        set in the table.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing information about the glyph item (see above)

@ENDNODE

@NODE pglyphitemGetItem "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:GetItem -- get glyph item

   @{b}SYNOPSIS@{ub}
        item = pglyphitem:GetItem()

   @{b}FUNCTION@{ub}
        Gets the Pango item associated with the glyph item. You mustn't free
        this object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        item      a Pango item object

@ENDNODE

@NODE pglyphitemGetGlyphString "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:GetGlyphString -- get glyph string

   @{b}SYNOPSIS@{ub}
        glyph_string = pglyphitem:GetGlyphString()

   @{b}FUNCTION@{ub}
        Gets the glyph string associated with the glyph item. You mustn't free
        this object.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        glyph_string
                  a Pango glyph string object

@ENDNODE

@NODE pglyphitemGetLogicalWidths "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:GetLogicalWidths -- get logical widths

   @{b}SYNOPSIS@{ub}
        logical_widths = pglyphitem:GetLogicalWidths(text$)

   @{b}FUNCTION@{ub}
        Given a Pango glyph item and the corresponding text, determine the width
        corresponding to each character. The individual widths are returned in a
        table. When multiple characters compose a single cluster, the width of
        the entire cluster is divided equally among the characters.

        See also @{"pglyphstring:GetLogicalWidths()" LINK pglyphstringGetLogicalWidths}.

   @{b}INPUTS@{ub}
        text$     text that the glyph item corresponds to

   @{b}RESULTS@{ub}
        logical_widths
                  table containing the resulting character widths

@ENDNODE

@NODE pglyphitemIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:IsNull -- check if glyph item is invalid

   @{b}SYNOPSIS@{ub}
        bool = pglyphitem:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the glyph item is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the glyph item will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the glyph item is NULL, otherwise FALSE

@ENDNODE

@NODE pglyphitemSet "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:Set -- set glyph item data

   @{b}SYNOPSIS@{ub}
        pglyphitem:Set(table)

   @{b}FUNCTION@{ub}
        Sets data of one or more data fields inside the glyph item. You have to
        pass a table to this function that consists of one or more key-value
        pairs, each setting a single data member.

        The following keys are recognized in the "table" parameter:

        YOffset   Shift of the baseline, relative to the baseline of the
                  containing line. Positive values shift upwards.
        StartXOffset
                  Horizontal displacement to apply before the glyph item.
                  Positive values shift right.
        EndXOffset
                  Horizontal displacement to apply after th glyph item. Positive
                  values shift right.

   @{b}INPUTS@{ub}
        table     table containing key-value pairs with the data to set (see
                  above)

@ENDNODE

@NODE pglyphitemSetItem "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:SetItem -- set glyph item

   @{b}SYNOPSIS@{ub}
        pglyphitem:SetItem(item)

   @{b}FUNCTION@{ub}
        Sets the Pango item inside the glyph item to "item". Note that "item"
        won't be referenced by this function so you need to make sure it stays
        valid for the glyph item's lifecycle.

   @{b}INPUTS@{ub}
        item      a Pango item object

@ENDNODE

@NODE pglyphitemSetGlyphString "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:SetGlyphString -- set glyph string

   @{b}SYNOPSIS@{ub}
        pglyphitem:SetGlyphString(glyph_string)

   @{b}FUNCTION@{ub}
        Sets the glyph string inside the glyph item to "glyph_string". Note that
        "glyph_string" won't be referenced by this function so you need to make
        sure it stays valid for the glyph item's lifecycle.

   @{b}INPUTS@{ub}
        glyph_string
                  a Pango glyph string object

@ENDNODE

@NODE pglyphitemSplit "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphitem:Split -- split item

   @{b}SYNOPSIS@{ub}
        handle = pglyphitem:Split(text$, split_index)

   @{b}FUNCTION@{ub}
        Modifies the glyph item to cover only the text after "split_index", and
        returns a new item that covers the text before "split_index" that used
        to be in the glyph item.

        You can think of "split_index" as the length of the returned item.
        "split_index" may not be 0, and it may not be greater than or equal to
        the length of the source glyph item (that is, there must be at least one
        byte assigned to each item, you can't create a zero-length item).

        This function returns the newly allocated item representing text before
        "split_index", which should be freed with @{"pglyphitem:Free()" LINK pglyphitemFree}.

   @{b}INPUTS@{ub}
        text$     text to which positions in the glyph item apply
        split_index
                  byte index of position to split item, relative to the start of
                  the item

   @{b}RESULTS@{ub}
        handle    the newly allocated glyph item

@ENDNODE

@NODE pglyphstringCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:Copy -- copy glyph string

   @{b}SYNOPSIS@{ub}
        gstr = pglyphstring:Copy()

   @{b}FUNCTION@{ub}
        Copy a glyph string and associated storage.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        gstr      the newly allocated Pango glyph string

@ENDNODE

@NODE pglyphstringExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:Extents -- compute glyph string extents

   @{b}SYNOPSIS@{ub}
        ink_rect, logical_rect = pglyphstring:Extents(font)

   @{b}FUNCTION@{ub}
        Compute the logical and ink extents of a glyph string. This will return
        two tables that have the "x", "y", "width", and "height" fields
        initialized. See the documentation for @{"pfont:GetGlyphExtents()" LINK pfontGetGlyphExtents} for
        details about the interpretation of the rectangles.

        Examples of logical (red) and ink (green) rects:

        See image: @{"rects1.png" LINK "Guide/rects1.png/MAIN"} See image: @{"rects2.png" LINK "Guide/rects2.png/MAIN"}

   @{b}INPUTS@{ub}
        font      a Pango font

   @{b}RESULTS@{ub}
        ink_rect  table containing the extents of the glyph string as drawn
        logical_rect
                  table containing the logical extents of the glyph string

@ENDNODE

@NODE pglyphstringExtentsRange "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:ExtentsRange -- extents range

   @{b}SYNOPSIS@{ub}
        ink_rect, logical_rect = pglyphstring:ExtentsRange(start, end, font)

   @{b}FUNCTION@{ub}
        Computes the extents of a sub-portion of a glyph string. This will
        return two tables that have the "x", "y", "width", and "height" fields
        initialized.

        The extents are relative to the start of the glyph string range (the
        origin of their coordinate system is at the start of the range, not at
        the start of the entire glyph string).

   @{b}INPUTS@{ub}
        start     start index
        end       end index (the range is the set of bytes with indices such
                  that start <= index < end)
        font      a Pango font

   @{b}RESULTS@{ub}
        ink_rect  table containing the extents of the glyph string range as
                  drawn
        logical_rect
                  table containing the logical extents of the glyph string range

@ENDNODE

@NODE pglyphstringFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:Free -- free glyph string

   @{b}SYNOPSIS@{ub}
        pglyphstring:Free()

   @{b}FUNCTION@{ub}
        Free a glyph string and associated storage.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pglyphstringGet "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:Get -- get glyph info

   @{b}SYNOPSIS@{ub}
        table = pglyphstring:Get(index)

   @{b}FUNCTION@{ub}
        Gets positioning information and visual attributes for the glyph at
        "index". The information is returned as a table. See @{"pglyphstring:Set()" LINK pglyphstringSet}
        for a description of all the table fields that are set by this function.

   @{b}INPUTS@{ub}
        index     glyph to use

   @{b}RESULTS@{ub}
        table     a table containing glyph information

@ENDNODE

@NODE pglyphstringGetLogicalWidths "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:GetLogicalWidths -- get logical widths

   @{b}SYNOPSIS@{ub}
        t = pglyphstring:GetLogicalWidths(text$, embedding_level)

   @{b}FUNCTION@{ub}
        Given a Pango glyph string and corresponding text, determine the width
        corresponding to each character. When multiple characters compose a
        single cluster, the width of the entire cluster is divided equally among
        the characters. The individual widths are returned in a table.

        See also @{"pglyphitem:GetLogicalWidths()" LINK pglyphitemGetLogicalWidths}.

   @{b}INPUTS@{ub}
        text$     the text corresponding to the glyphs
        embedding_level
                  the embedding level of the string

   @{b}RESULTS@{ub}
        logical_widths
                  table containing the resulting character widths

@ENDNODE

@NODE pglyphstringGetWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:GetWidth -- get width

   @{b}SYNOPSIS@{ub}
        width = pglyphstring:GetWidth()

   @{b}FUNCTION@{ub}
        Computes the logical width of the glyph string.

        This can also be computed using @{"pglyphstring:Extents()" LINK pglyphstringExtents}. However, since
        this only computes the width, it's much faster. This is in fact only a
        convenience function that computes the sum of geometry.width for each
        glyph in the glyph string.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the logical width of the glyph string

@ENDNODE

@NODE pglyphstringIndexToX "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:IndexToX -- convert from character to x position

   @{b}SYNOPSIS@{ub}
        x_pos = pglyphstring:IndexToX(text$, analysis, index, trailing)

   @{b}FUNCTION@{ub}
        Converts from character position to x position.

        The X position is measured from the left edge of the run. Character
        positions are obtained using font metrics for ligatures where available,
        and computed by dividing up each cluster into equal portions, otherwise.

        See image: @{"glyphstring-positions-light.png" LINK "Guide/glyphstring-positions-light.png/MAIN"}

   @{b}INPUTS@{ub}
        text$     the text for the run
        analysis  the analysis information return from itemize; this must be a
                  Pango analysis object
        index     the byte index within "text$"
        trailing  whether we should compute the result for the beginning (FALSE)
                  or end (TRUE) of the character

   @{b}RESULTS@{ub}
        x_pos     location to store result

@ENDNODE

@NODE pglyphstringIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:IsNull -- check if glyph string is invalid

   @{b}SYNOPSIS@{ub}
        bool = pglyphstring:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the glyph string is NULL, i.e. invalid. If functions
        that allocate objects fail, they might not throw an error but simply set
        the object to NULL. You can use this function to check if object
        allocation has failed in which case the glyph string will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the glyph string is NULL, otherwise FALSE

@ENDNODE

@NODE pglyphstringSet "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:Set -- set glyph info

   @{b}SYNOPSIS@{ub}
        pglyphstring:Set(index, table)

   @{b}FUNCTION@{ub}
        Sets positioning information and visual attributes for the glyph at
        "index". The data to set must be passed as one or more key-value pairs
        in the "table" argument. The following keys are currently supported:

        Glyph     The glyph itself.
        Width     The logical width to use for the the character.
        XOffset   Horizontal offset from nominal character position.
        YOffset   Vertical offset from nominal character position.
        IsClusterStart
                  Set for the first logical glyph in each cluster.
        LogCluster
                  Logical cluster info, indexed by the byte index within the
                  text corresponding to the glyph string.

   @{b}INPUTS@{ub}
        index     glyph to use
        table     a table consisting of key-value pairs of the data to set

@ENDNODE

@NODE pglyphstringSetSize "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:SetSize -- resize glyph string

   @{b}SYNOPSIS@{ub}
        pglyphstring:SetSize(new_len)

   @{b}FUNCTION@{ub}
        Resize a glyph string to the given length.

   @{b}INPUTS@{ub}
        new_len   the new length of the string

@ENDNODE

@NODE pglyphstringXToIndex "Pangomonium Guide"

   @{b}NAME@{ub}
        pglyphstring:XToIndex -- convert from x offset to character position

   @{b}SYNOPSIS@{ub}
        index, trailing = pglyphstring:XToIndex(text$, analysis, x_pos)

   @{b}FUNCTION@{ub}
        Convert from x offset to character position.

        Character positions are computed by dividing up each cluster into equal
        portions. In scripts where positioning within a cluster is not allowed
        (such as Thai), the returned value may not be a valid cursor position;
        the caller must combine the result with the logical attributes for the
        text to compute the valid cursor position.

   @{b}INPUTS@{ub}
        text$     the text for the run
        analysis  the analysis information return from itemize; this must be a
                  Pango analysis object
        x_pos     the x offset (in Pango units)

   @{b}RESULTS@{ub}
        index     calculated byte index within "text$"
        trailing  boolean indicating whether the user clicked on the leading or
                  trailing edge of the character

@ENDNODE

@NODE pitemCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:Copy -- copy item

   @{b}SYNOPSIS@{ub}
        item = pitem:Copy()

   @{b}FUNCTION@{ub}
        Copy an existing Pango item structure.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        item      the newly allocated Pango item

@ENDNODE

@NODE pitemFree "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:Free -- free item

   @{b}SYNOPSIS@{ub}
        pitem:Free()

   @{b}FUNCTION@{ub}
        Free a Pango item and all associated memory.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE pitemGet "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:Get -- get item data

   @{b}SYNOPSIS@{ub}
        table = pitem:Get()

   @{b}FUNCTION@{ub}
        Gets data for the item. The data will be returned as a table. See
        @{"pitem:Set()" LINK pitemSet} for information on which table fields will be set.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        table     a table containing the item data

@ENDNODE

@NODE pitemIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:IsNull -- check if item is invalid

   @{b}SYNOPSIS@{ub}
        bool = pitem:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the item is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the item will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the item is NULL, otherwise FALSE

@ENDNODE

@NODE pitemSet "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:Set -- set item data

   @{b}SYNOPSIS@{ub}
        pitem:Set(table)

   @{b}FUNCTION@{ub}
        Sets data for the item. The data to set must be passed as one or more
        key-value pairs in the "table" argument. The following keys are
        currently supported:

        Offset    Byte offset of the start of this item in text.
        Length    Length of this item in bytes.
        NumChars  Number of Unicode characters in the item.
        Analysis  Analysis results for the item. This is a Pango analysis
                  object.

   @{b}INPUTS@{ub}
        table     a table consisting of key-value pairs of the data to set

@ENDNODE

@NODE pitemSplit "Pangomonium Guide"

   @{b}NAME@{ub}
        pitem:Split -- split item

   @{b}SYNOPSIS@{ub}
        item = pitem:Split(split_index, split_offset)

   @{b}FUNCTION@{ub}
        Modifies the item to cover only the text after "split_index", and
        returns a new item that covers the text before "split_index" that used
        to be in the original item.

        You can think of "split_index" as the length of the returned item.
        "split_index" may not be 0, and it may not be greater than or equal to
        the length of the item (that is, there must be at least one byte
        assigned to each item, you can't create a zero-length item).
        "split_offset" is the length of the first item in chars, and must be
        provided because the text used to generate the item isn't available, so
        this function can't count the char length of the split items itself.

        This function returns new item representing text before "split_index",
        which should be freed with @{"pitem:Free()" LINK pitemFree}.

   @{b}INPUTS@{ub}
        split_index
                  byte index of position to split item, relative to the start of
                  the item
        split_offset
                  number of chars between start of the item and "split_index"

   @{b}RESULTS@{ub}
        item      new item representing text before "split_index"

@ENDNODE

@NODE planguageGetSampleString "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:GetSampleString -- get sample string

   @{b}SYNOPSIS@{ub}
        s$ = planguage:GetSampleString()

   @{b}FUNCTION@{ub}
        Get a string that is representative of the characters needed to render a
        particular language.

        The sample text may be a pangram, but is not necessarily. It is chosen
        to be demonstrative of normal text in the language, as well as exposing
        font feature requirements unique to the language. It is suitable for use
        as sample text in a font selection dialog.

        If Pango does not have a sample string for the language, the classic
        "The quick brown fox..." is returned. This can be detected by comparing
        the returned handle value to that returned for (non-existent) language
        code "xx".

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s$        sample string for the language

@ENDNODE

@NODE planguageGetScripts "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:GetScripts -- get language scripts

   @{b}SYNOPSIS@{ub}
        t = planguage:GetScripts()

   @{b}FUNCTION@{ub}
        Determines the scripts used to write the language. The individual
        scripts are returned in a table. The list of scripts returned starts
        with the script that the language uses most and continues to the one it
        uses least.

        Most languages use only one script for writing, but there are some that
        use two (Latin and Cyrillic for example), and a few use three (Japanese
        for example).

        The following scripts are currently defined:

        #PANGO_SCRIPT_INVALID_CODE
                  Signals an invalid script.
        #PANGO_SCRIPT_COMMON
                  A character used by multiple different scripts.
        #PANGO_SCRIPT_INHERITED
                  A mark glyph that takes its script from the base glyph to
                  which it is attached.
        #PANGO_SCRIPT_ARABIC
                  Arabic.
        #PANGO_SCRIPT_ARMENIAN
                  Armenian.
        #PANGO_SCRIPT_BENGALI
                  Bengali.
        #PANGO_SCRIPT_BOPOMOFO
                  Bopomofo.
        #PANGO_SCRIPT_CHEROKEE
                  Cherokee.
        #PANGO_SCRIPT_COPTIC
                  Coptic.
        #PANGO_SCRIPT_CYRILLIC
                  Cyrillic.
        #PANGO_SCRIPT_DESERET
                  Deseret.
        #PANGO_SCRIPT_DEVANAGARI
                  Devanagari.
        #PANGO_SCRIPT_ETHIOPIC
                  Ethiopic.
        #PANGO_SCRIPT_GEORGIAN
                  Georgian.
        #PANGO_SCRIPT_GOTHIC
                  Gothic.
        #PANGO_SCRIPT_GREEK
                  Greek.
        #PANGO_SCRIPT_GUJARATI
                  Gujarati.
        #PANGO_SCRIPT_GURMUKHI
                  Gurmukhi.
        #PANGO_SCRIPT_HAN
                  Han.
        #PANGO_SCRIPT_HANGUL
                  Hangul.
        #PANGO_SCRIPT_HEBREW
                  Hebrew.
        #PANGO_SCRIPT_HIRAGANA
                  Hiragana.
        #PANGO_SCRIPT_KANNADA
                  Kannada.
        #PANGO_SCRIPT_KATAKANA
                  Katakana.
        #PANGO_SCRIPT_KHMER
                  Khmer.
        #PANGO_SCRIPT_LAO
                  Lao.
        #PANGO_SCRIPT_LATIN
                  Latin.
        #PANGO_SCRIPT_MALAYALAM
                  Malayalam.
        #PANGO_SCRIPT_MONGOLIAN
                  Mongolian.
        #PANGO_SCRIPT_MYANMAR
                  Myanmar.
        #PANGO_SCRIPT_OGHAM
                  Ogham.
        #PANGO_SCRIPT_OLD_ITALIC
                  Old Italic.
        #PANGO_SCRIPT_ORIYA
                  Oriya.
        #PANGO_SCRIPT_RUNIC
                  Runic.
        #PANGO_SCRIPT_SINHALA
                  Sinhala.
        #PANGO_SCRIPT_SYRIAC
                  Syriac.
        #PANGO_SCRIPT_TAMIL
                  Tamil.
        #PANGO_SCRIPT_TELUGU
                  Telugu.
        #PANGO_SCRIPT_THAANA
                  Thaana.
        #PANGO_SCRIPT_THAI
                  Thai.
        #PANGO_SCRIPT_TIBETAN
                  Tibetan.
        #PANGO_SCRIPT_CANADIAN_ABORIGINAL
                  Canadian Aboriginal.
        #PANGO_SCRIPT_YI
                  Yi.
        #PANGO_SCRIPT_TAGALOG
                  Tagalog.
        #PANGO_SCRIPT_HANUNOO
                  Hanunoo.
        #PANGO_SCRIPT_BUHID
                  Buhid.
        #PANGO_SCRIPT_TAGBANWA
                  Tagbanwa.
        #PANGO_SCRIPT_BRAILLE
                  Braille.
        #PANGO_SCRIPT_CYPRIOT
                  Cypriot.
        #PANGO_SCRIPT_LIMBU
                  Limbu.
        #PANGO_SCRIPT_OSMANYA
                  Osmanya.
        #PANGO_SCRIPT_SHAVIAN
                  Shavian.
        #PANGO_SCRIPT_LINEAR_B
                  Linear B.
        #PANGO_SCRIPT_TAI_LE
                  Tai Le.
        #PANGO_SCRIPT_UGARITIC
                  Ugaritic.
        #PANGO_SCRIPT_NEW_TAI_LUE
                  New Tai Lue.
        #PANGO_SCRIPT_BUGINESE
                  Buginese.
        #PANGO_SCRIPT_GLAGOLITIC
                  Glagolitic.
        #PANGO_SCRIPT_TIFINAGH
                  Tifinagh.
        #PANGO_SCRIPT_SYLOTI_NAGRI
                  Syloti Nagri.
        #PANGO_SCRIPT_OLD_PERSIAN
                  Old Persian.
        #PANGO_SCRIPT_KHAROSHTHI
                  Kharoshthi.
        #PANGO_SCRIPT_UNKNOWN
                  An unassigned code point.
        #PANGO_SCRIPT_BALINESE
                  Balinese.
        #PANGO_SCRIPT_CUNEIFORM
                  Cuneiform.
        #PANGO_SCRIPT_PHOENICIAN
                  Phoenician.
        #PANGO_SCRIPT_PHAGS_PA
                  Phags-pa.
        #PANGO_SCRIPT_NKO
                  NKo.
        #PANGO_SCRIPT_KAYAH_LI
                  Kayah Li.
        #PANGO_SCRIPT_LEPCHA
                  Lepcha.
        #PANGO_SCRIPT_REJANG
                  Rejang.
        #PANGO_SCRIPT_SUNDANESE
                  Sundanese.
        #PANGO_SCRIPT_SAURASHTRA
                  Saurashtra.
        #PANGO_SCRIPT_CHAM
                  Cham.
        #PANGO_SCRIPT_OL_CHIKI
                  Ol Chiki.
        #PANGO_SCRIPT_VAI
                  Vai.
        #PANGO_SCRIPT_CARIAN
                  Carian.
        #PANGO_SCRIPT_LYCIAN
                  Lycian.
        #PANGO_SCRIPT_LYDIAN
                  Lydian.
        #PANGO_SCRIPT_BATAK
                  Batak.
        #PANGO_SCRIPT_BRAHMI
                  Brahmi.
        #PANGO_SCRIPT_MANDAIC
                  Mandaic.
        #PANGO_SCRIPT_CHAKMA
                  Chakma.
        #PANGO_SCRIPT_MEROITIC_CURSIVE
                  Meroitic Cursive.
        #PANGO_SCRIPT_MEROITIC_HIEROGLYPHS
                  Meroitic Hieroglyphs.
        #PANGO_SCRIPT_MIAO
                  Miao.
        #PANGO_SCRIPT_SHARADA
                  Sharada.
        #PANGO_SCRIPT_SORA_SOMPENG
                  Sora Sompeng.
        #PANGO_SCRIPT_TAKRI
                  Takri.
        #PANGO_SCRIPT_BASSA_VAH
                  Bassa.
        #PANGO_SCRIPT_CAUCASIAN_ALBANIAN
                  Caucasian Albanian.
        #PANGO_SCRIPT_DUPLOYAN
                  Duployan.
        #PANGO_SCRIPT_ELBASAN
                  Elbasan.
        #PANGO_SCRIPT_GRANTHA
                  Grantha.
        #PANGO_SCRIPT_KHOJKI
                  Kjohki.
        #PANGO_SCRIPT_KHUDAWADI
                  Khudawadi, Sindhi.
        #PANGO_SCRIPT_LINEAR_A
                  Linear A.
        #PANGO_SCRIPT_MAHAJANI
                  Mahajani.
        #PANGO_SCRIPT_MANICHAEAN
                  Manichaean.
        #PANGO_SCRIPT_MENDE_KIKAKUI
                  Mende Kikakui.
        #PANGO_SCRIPT_MODI
                  Modi.
        #PANGO_SCRIPT_MRO
                  Mro.
        #PANGO_SCRIPT_NABATAEAN
                  Nabataean.
        #PANGO_SCRIPT_OLD_NORTH_ARABIAN
                  Old North Arabian.
        #PANGO_SCRIPT_OLD_PERMIC
                  Old Permic.
        #PANGO_SCRIPT_PAHAWH_HMONG
                  Pahawh Hmong.
        #PANGO_SCRIPT_PALMYRENE
                  Palmyrene.
        #PANGO_SCRIPT_PAU_CIN_HAU
                  Pau Cin Hau.
        #PANGO_SCRIPT_PSALTER_PAHLAVI
                  Psalter Pahlavi.
        #PANGO_SCRIPT_SIDDHAM
                  Siddham.
        #PANGO_SCRIPT_TIRHUTA
                  Tirhuta.
        #PANGO_SCRIPT_WARANG_CITI
                  Warang Citi.
        #PANGO_SCRIPT_AHOM
                  Ahom.
        #PANGO_SCRIPT_ANATOLIAN_HIEROGLYPHS
                  Anatolian Hieroglyphs.
        #PANGO_SCRIPT_HATRAN
                  Hatran.
        #PANGO_SCRIPT_MULTANI
                  Multani.
        #PANGO_SCRIPT_OLD_HUNGARIAN
                  Old Hungarian.
        PANGO_SCRIPT_SIGNWRITING
                  Signwriting.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing the individual scripts (see above)

@ENDNODE

@NODE planguageIncludesScript "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:IncludesScript -- check if language includes script

   @{b}SYNOPSIS@{ub}
        ok = planguage:IncludesScript(script)

   @{b}FUNCTION@{ub}
        Determines if "script" is one of the scripts used to write the language.

        The returned value is conservative; if nothing is known about the
        language tag the language, TRUE will be returned, since, as far as Pango
        knows, "script" might be used to write the language.

        This routine is used in Pango's itemization process when determining if
        a supplied language tag is relevant to a particular section of text. It
        probably is not useful for applications in most circumstances.

        See @{"planguage:GetScripts()" LINK planguageGetScripts} for a list of supported scripts.

   @{b}INPUTS@{ub}
        script    a script identifier

   @{b}RESULTS@{ub}
        ok        TRUE if "script" is one of the scripts used to write the
                  language, FALSE otherwise

@ENDNODE

@NODE planguageIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:IsNull -- check if language is invalid

   @{b}SYNOPSIS@{ub}
        bool = planguage:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the language is NULL, i.e. invalid. If functions that
        allocate objects fail, they might not throw an error but simply set the
        object to NULL. You can use this function to check if object allocation
        has failed in which case the language will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the language is NULL, otherwise FALSE

@ENDNODE

@NODE planguageMatches "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:Matches -- check if language tag matches language ranges

   @{b}SYNOPSIS@{ub}
        ok = planguage:Matches(range_list$)

   @{b}FUNCTION@{ub}
        Checks if a language tag matches one of the elements in a list of
        language ranges. The list of language ranges must be passed as a string,
        separated by ";", ":", ",", or space characters. Each element must
        either be "*", or a RFC 3066 language range canonicalized as by
        @{"pango.Language()" LINK pangoLanguage}.

        A language tag is considered to match a range in the list if the range
        is "*", the range is exactly the tag, or the range is a prefix of the
        tag, and the character after it in the tag is "-".

        This function returns TRUE if a match was found

   @{b}INPUTS@{ub}
        range_list$
                  a list of language ranges (see above for the format)

   @{b}RESULTS@{ub}
        ok        TRUE if a match was found, FALSE otherwise

@ENDNODE

@NODE planguageToString "Pangomonium Guide"

   @{b}NAME@{ub}
        planguage:ToString -- convert language tag to RFC-3066

   @{b}SYNOPSIS@{ub}
        f$ = planguage:ToString()

   @{b}FUNCTION@{ub}
        Gets the RFC-3066 format string representing the given language tag.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        f$        a string representing the language tag

@ENDNODE

@NODE playoutContextChanged "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:ContextChanged -- force recomputation of layout

   @{b}SYNOPSIS@{ub}
        playout:ContextChanged()

   @{b}FUNCTION@{ub}
        Forces recomputation of any state in the Pango layout that might depend
        on the layout's context.

        This function should be called if you make changes to the context
        subsequent to creating the layout.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE playoutCopy "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:Copy -- copy layout

   @{b}SYNOPSIS@{ub}
        handle = playout:Copy()

   @{b}FUNCTION@{ub}
        Creates a deep copy-by-value of the layout.

        The attribute list, tab array, and text from the original layout are all
        copied by value.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    the newly allocated Pango layout

@ENDNODE

@NODE playoutFree "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:Free -- free layout

   @{b}SYNOPSIS@{ub}
        playout:Free()

   @{b}FUNCTION@{ub}
        Decrease the reference count of a Pango layout by one.

        If the result is zero, the layout and all associated memory will be
        freed.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE playoutGetAlignment "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetAlignment -- get layout alignment

   @{b}SYNOPSIS@{ub}
        align = playout:GetAlignment()

   @{b}FUNCTION@{ub}
        Gets the alignment for the layout: how partial lines are positioned
        within the horizontal space available. See @{"playout:SetAlignment()" LINK playoutSetAlignment} for a
        list of alignments.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        align     the alignment

@ENDNODE

@NODE playoutGetAttributes "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetAttributes -- get attribute list

   @{b}SYNOPSIS@{ub}
        attrlist = playout:GetAttributes()

   @{b}FUNCTION@{ub}
        Gets the attribute list for the layout, if any. If there is no attribute
        list in the layout, a NULL object is returned. You can use
        @{"pattrlist:IsNull()" LINK pattrlistIsNull} to check if an attribute list is NULL.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        attrlist  a Pango attribute list

@ENDNODE

@NODE playoutGetAutoDir "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetAutoDir -- get layout's auto dir setting

   @{b}SYNOPSIS@{ub}
        autodir = playout:GetAutoDir()

   @{b}FUNCTION@{ub}
        Gets whether to calculate the base direction for the layout according to
        its contents.

        See @{"playout:SetAutoDir()" LINK playoutSetAutoDir} for more information.

        This function returns TRUE if the bidirectional base direction is
        computed from the layout's contents, FALSE otherwise.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        autodir   TRUE if auto dir is on, FALSE otherwise

@ENDNODE

@NODE playoutGetBaseline "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetBaseline -- get baseline

   @{b}SYNOPSIS@{ub}
        baseline = playout:GetBaseline()

   @{b}FUNCTION@{ub}
        Gets the Y position of baseline of the first line in the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        baseline  baseline of first line, from top of the layout

@ENDNODE

@NODE playoutGetCharacterCount "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetCharacterCount -- get character count

   @{b}SYNOPSIS@{ub}
        n = playout:GetCharacterCount()

   @{b}FUNCTION@{ub}
        Returns the number of Unicode characters in the the text of the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        n         the number of Unicode characters

@ENDNODE

@NODE playoutGetContext "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetContext -- get Pango context

   @{b}SYNOPSIS@{ub}
        ctx = playout:GetContext()

   @{b}FUNCTION@{ub}
        Retrieves the Pango context used for this layout. The context is owned
        by the layout and mustn't be freed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ctx       the Pango context for the layout

@ENDNODE

@NODE playoutGetCursorPos "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetCursorPos -- get cursor pos

   @{b}SYNOPSIS@{ub}
        strong_pos, weak_pos = playout:GetCursorPos(index)

   @{b}FUNCTION@{ub}
        Given an "index" within a layout, determines the positions that of the
        strong and weak cursors if the insertion point is at that index. Both
        "strongpos" and "weakpos" will be tables that have the fields "x", "y",
        "width", and "height" initialized. The position of each cursor is stored
        as a zero-width rectangle with the height of the run extents.

        See image: @{"cursor-positions-light.png" LINK "Guide/cursor-positions-light.png/MAIN"}

        The strong cursor location is the location where characters of the
        directionality equal to the base direction of the layout are inserted.
        The weak cursor location is the location where characters of the
        directionality opposite to the base direction of the layout are
        inserted.

        The following example shows text with both a strong and a weak cursor.

        See image: @{"split-cursor-light.png" LINK "Guide/split-cursor-light.png/MAIN"}

        The strong cursor has a little arrow pointing to the right, the weak
        cursor to the left. Typing a 'c' in this situation will insert the
        character after the 'b', and typing another Hebrew character, like '×',
        will insert it at the end.

   @{b}INPUTS@{ub}
        index     the byte index of the cursor

   @{b}RESULTS@{ub}
        strong_pos
                  strong cursor position
        weak_pos  weak cursor position

@ENDNODE

@NODE playoutGetEllipsize "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetEllipsize -- get ellipsization type

   @{b}SYNOPSIS@{ub}
        mode = playout:GetEllipsize()

   @{b}FUNCTION@{ub}
        Gets the type of ellipsization being performed for the layout. See
        @{"playout:SetEllipsize()" LINK playoutSetEllipsize} for more information.

        Use @{"playout:IsEllipsized()" LINK playoutIsEllipsized} to query whether any paragraphs were actually
        ellipsized.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mode      the current ellipsization mode for the layout

@ENDNODE

@NODE playoutGetExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetExtents -- get layout extents

   @{b}SYNOPSIS@{ub}
        ink_rect, logical_rect = playout:GetExtents()

   @{b}FUNCTION@{ub}
        Computes the logical and ink extents of the layout.

        Logical extents are usually what you want for positioning things. Note
        that both extents may have non-zero x and y. You may want to use those
        to offset where you render the layout. Not doing that is a very typical
        bug that shows up as right-to-left layouts not being correctly
        positioned in a layout with a set width.

        The extents are given in layout coordinates and in Pango units; layout
        coordinates begin at the top left corner of the layout.

        This function returns tables that have the fields "x", "y", "width", and
        "height" initialized.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ink_rect  extents of the layout as drawn
        logical_rect
                  logical extents of the layout

@ENDNODE

@NODE playoutGetFontDescription "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetFontDescription -- get font description

   @{b}SYNOPSIS@{ub}
        fontdesc = playout:GetFontDescription()

   @{b}FUNCTION@{ub}
        Gets the font description for the layout, if any. This function returns
        a handle to the layout's font description, or a NULL object if the font
        description from the layout's context is inherited. You can use
        @{"pfontdesc:IsNull()" LINK pfontdescIsNull} to check if an object is NULL.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        fontdesc  a handle to a font description

@ENDNODE

@NODE playoutGetHeight "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetHeight -- get layout height

   @{b}SYNOPSIS@{ub}
        height = playout:GetHeight()

   @{b}FUNCTION@{ub}
        Gets the height of layout used for ellipsization. See
        @{"playout:SetHeight()" LINK playoutSetHeight} for details.

        This function returns the height, in Pango units if positive, or number
        of lines if negative.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        height    layout height

@ENDNODE

@NODE playoutGetIndent "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetIndent -- get paragraph indent

   @{b}SYNOPSIS@{ub}
        indent = playout:GetIndent()

   @{b}FUNCTION@{ub}
        Gets the paragraph indent width in Pango units. A negative value
        indicates a hanging indentation.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        indent    the indent in Pango units

@ENDNODE

@NODE playoutGetIter "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetIter -- get layout iterator

   @{b}SYNOPSIS@{ub}
        it = playout:GetIter()

   @{b}FUNCTION@{ub}
        Returns an iterator to iterate over the visual extents of the layout.
        The caller is responsible for freeing the iterator using
        @{"playoutiter:Free()" LINK playoutiterFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        it        the new Pango layout iterator

@ENDNODE

@NODE playoutGetJustify "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetJustify -- get line justify

   @{b}SYNOPSIS@{ub}
        justify = playout:GetJustify()

   @{b}FUNCTION@{ub}
        Gets whether each complete line should be stretched to fill the entire
        width of the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        justify   a boolean value

@ENDNODE

@NODE playoutGetLine "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLine -- get line

   @{b}SYNOPSIS@{ub}
        handle = playout:GetLine(line)

   @{b}FUNCTION@{ub}
        Retrieves a particular line from a Pango layout.

        Use the faster @{"playout:GetLineReadonly()" LINK playoutGetLineReadonly} if you do not plan to modify
        the contents of the line (glyphs, glyph widths, etc.).

        This function returns the requested Pango layout line, or a NULL object
        if the index is out of range. The returned Pango layout line is owned by
        the layout and mustn't be freed. It can be ref'ed and retained, but will
        become invalid if changes are made to the Pango layout.

   @{b}INPUTS@{ub}
        line      the index of a line, which must be between 0 and the number of
                  lines in the layout minus one

   @{b}RESULTS@{ub}
        handle    a Pango layout line object

@ENDNODE

@NODE playoutGetLineCount "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLineCount -- get number of lines in layout

   @{b}SYNOPSIS@{ub}
        n = playout:GetLineCount()

   @{b}FUNCTION@{ub}
        Retrieves the count of lines for the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        n         the line count

@ENDNODE

@NODE playoutGetLineReadonly "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLineReadonly -- get layout line in read-only mode

   @{b}SYNOPSIS@{ub}
        handle = playout:GetLineReadonly(line)

   @{b}FUNCTION@{ub}
        Retrieves a particular line from a Pango layout.

        This is a faster alternative to @{"playout:GetLine()" LINK playoutGetLine}, but the user is not
        expected to modify the contents of the line (glyphs, glyph widths,
        etc.).

        This function returns the requested Pango layout line, or a NULL object
        if the index is out of range. The returned Pango layout line is owned by
        the layout and mustn't be freed. It can be ref'ed and retained, but will
        become invalid if changes are made to the Pango layout.

   @{b}INPUTS@{ub}
        line      the index of a line, which must be between 0 and the number of
                  lines in the layout minus one

   @{b}RESULTS@{ub}
        handle    a Pango layout line object

@ENDNODE

@NODE playoutGetLineSpacing "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLineSpacing -- get line spacing

   @{b}SYNOPSIS@{ub}
        spacing = playout:GetLineSpacing()

   @{b}FUNCTION@{ub}
        Gets the line spacing factor of the layout. See @{"playout:SetLineSpacing()" LINK playoutSetLineSpacing}
        for more information.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        spacing   line spacing factor

@ENDNODE

@NODE playoutGetLines "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLines -- get layout lines

   @{b}SYNOPSIS@{ub}
        list = playout:GetLines()

   @{b}FUNCTION@{ub}
        Returns the lines of the layout as a list.

        Use the faster @{"playout:GetLinesReadonly()" LINK playoutGetLinesReadonly} if you do not plan to modify
        the contents of the lines (glyphs, glyph widths, etc.).

        This function returns a list containing the lines in the layout. The
        Pango layout line objects in the list must be used with care. They will
        become invalid on any change to the layout's text or properties.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        list      table containing a list of Pango layout line objects

@ENDNODE

@NODE playoutGetLinesReadonly "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLinesReadonly -- get layout lines in read-only mode

   @{b}SYNOPSIS@{ub}
        list = playout:GetLinesReadonly()

   @{b}FUNCTION@{ub}
        Returns the lines of the layout as a list.

        This is a faster alternative to @{"playout:GetLines()" LINK playoutGetLines}, but the user is not
        expected to modify the contents of the lines (glyphs, glyph widths,
        etc.).

        This function returns a list containing the lines in the layout. The
        Pango layout line objects in the list must be used with care. They will
        become invalid on any change to the layout's text or properties.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        list      table containing a list of Pango layout line objects

@ENDNODE

@NODE playoutGetLogAttrs "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetLogAttrs -- get logical attributes for characters

   @{b}SYNOPSIS@{ub}
        t = playout:GetLogAttrs()

   @{b}FUNCTION@{ub}
        Retrieves an array of logical attributes for each character in the
        layout. This function will return a table that contains a subtable for
        each character in the layout. Each subtable will be have the following
        fields initialized:

        IsLineBreak
                  If set, can break line in front of character.
        IsMandatoryBreak
                  If set, must break line in front of character.
        IsCharBreak
                  If set, can break here when doing character wrapping.
        IsWhite   Is whitespace character.
        IsCursorPosition
                  If set, cursor can appear in front of character. i.e. this is
                  a grapheme boundary, or the first character in the text. This
                  flag implements Unicode's Grapheme Cluster Boundaries
                  semantics.
        IsWordStart
                  Is first character in a word.
        IsWordEnd Is first non-word char after a word. Note that in degenerate
                  cases, you could have both "IsWordStart" and "IsWordEnd" set
                  for some character.
        IsSentenceBoundary
                  Is a sentence boundary. There are two ways to divide
                  sentences. The first assigns all inter-sentence
                  whitespace/control/format chars to some sentence, so all chars
                  are in some sentence; "IsSentenceBoundary" denotes the
                  boundaries there. The second way doesn't assign
                  between-sentence spaces, etc. to any sentence, so
                  "IsSentenceStart" / "IsSentenceEnd" mark the boundaries of
                  those sentences.
        IsSentenceStart
                  Is first character in a sentence.
        IsSentenceEnd
                  Is first char after a sentence. Note that in degenerate cases,
                  you could have both "IsSentenceStart" and "IsSentenceEnd" set
                  for some character. (e.g. no space after a period, so the next
                  sentence starts right away).
        BackspaceDeletesCharacter
                  If set, backspace deletes one character rather than the entire
                  grapheme cluster. This field is only meaningful on grapheme
                  boundaries (where "IsCursorPosition" is set). In some
                  languages, the full grapheme (e.g. letter + diacritics) is
                  considered a unit, while in others, each decomposed character
                  in the grapheme is a unit. In the default implementation of
                  pango break, this bit is set on all grapheme boundaries except
                  those following Latin, Cyrillic or Greek base characters.
        IsExpandableSpace
                  Is a whitespace character that can possibly be expanded for
                  justification purposes.
        IsWordBoundary
                  Is a word boundary, as defined by UAX#29. More specifically,
                  means that this is not a position in the middle of a word. For
                  example, both sides of a punctuation mark are considered word
                  boundaries. This flag is particularly useful when selecting
                  text word-by-word. This flag implements Unicodes Word
                  Boundaries semantics.

        The number of attributes returned in the table will be one more than the
        total number of characters in the layout, since there need to be
        attributes corresponding to both the position before the first character
        and the position after the last character.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing an array of logical attributes

@ENDNODE

@NODE playoutGetPixelExtents "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetPixelExtents -- get pixel extents of layout

   @{b}SYNOPSIS@{ub}
        ink_rect, logical_rect = playout:GetPixelExtents()

   @{b}FUNCTION@{ub}
        Computes the logical and ink extents of the layout in device units. Both
        return values are tables that have the "x", "y", "width", and "height"
        fields initialized.

        This function just calls @{"playout:GetExtents()" LINK playoutGetExtents} followed by two
        @{"pango.ExtentsToPixels()" LINK pangoExtentsToPixels} calls, rounding "ink_rect" and "logical_rect"
        such that the rounded rectangles fully contain the unrounded one (that
        is, passes them as first argument to @{"pango.ExtentsToPixels()" LINK pangoExtentsToPixels}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ink_rect  extents of the layout as drawn
        logical_rect
                  logical extents of the layout

@ENDNODE

@NODE playoutGetPixelSize "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetPixelSize -- get layout dimensions

   @{b}SYNOPSIS@{ub}
        width, height = playout:GetPixelSize()

   @{b}FUNCTION@{ub}
        Determines the logical width and height of a Pango layout in device
        units.

        @{"playout:GetSize()" LINK playoutGetSize} returns the width and height scaled by #PANGO_SCALE.
        This is simply a convenience function around @{"playout:GetPixelExtents()" LINK playoutGetPixelExtents}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     logical width
        height    logical height

@ENDNODE

@NODE playoutGetSerial "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetSerial -- get serial

   @{b}SYNOPSIS@{ub}
        s = playout:GetSerial()

   @{b}FUNCTION@{ub}
        Returns the current serial number of the layout.

        The serial number is initialized to a small number larger than zero when
        a new layout is created and is increased whenever the layout is changed
        using any of the setter functions, or the Pango context it uses has
        changed. The serial may wrap, but will never have the value 0. Since it
        can wrap, never compare it with "less than", always use "not equals".

        This can be used to automatically detect changes to a Pango layout, and
        is useful for example to decide whether a layout needs redrawing. To
        force the serial to be increased, use @{"playout:ContextChanged()" LINK playoutContextChanged}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s         the current serial number of the layout

@ENDNODE

@NODE playoutGetSingleParagraphMode "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetSingleParagraphMode -- get single paragraph mode

   @{b}SYNOPSIS@{ub}
        bool = playout:GetSingleParagraphMode()

   @{b}FUNCTION@{ub}
        Obtains whether the layout is in single paragraph mode. See
        @{"playout:SetSingleParagraphMode()" LINK playoutSetSingleParagraphMode} for details.

        This function returns TRUE if the layout does not break paragraphs at
        paragraph separator characters, FALSE otherwise.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the layout does not break paragraphs, FALSE otherwise

@ENDNODE

@NODE playoutGetSize "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetSize -- get layout dimensions

   @{b}SYNOPSIS@{ub}
        width, height = playout:GetSize()

   @{b}FUNCTION@{ub}
        Determines the logical width and height of a Pango layout in Pango
        units.

        This is simply a convenience function around @{"playout:GetExtents()" LINK playoutGetExtents}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     logical width
        height    logical height

@ENDNODE

@NODE playoutGetSpacing "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetSpacing -- get line spacing

   @{b}SYNOPSIS@{ub}
        spacing = playout:GetSpacing()

   @{b}FUNCTION@{ub}
        Gets the amount of spacing between the lines of the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        spacing   the spacing in Pango units

@ENDNODE

@NODE playoutGetTabs "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetTabs -- get tab array

   @{b}SYNOPSIS@{ub}
        handle = playout:GetTabs()

   @{b}FUNCTION@{ub}
        Gets the current Pango tab array used by this layout.

        If no Pango tab array has been set, then the default tabs are in use and
        a NULL object is returned. You can use @{"ptabarray:IsNull()" LINK ptabarrayIsNull} to check if a
        tab array is NULL. Default tabs are every 8 spaces.

        The return value should be freed with @{"ptabarray:Free()" LINK ptabarrayFree}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    a Pango tab array

@ENDNODE

@NODE playoutGetText "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetText -- get text

   @{b}SYNOPSIS@{ub}
        s$ = playout:GetText()

   @{b}FUNCTION@{ub}
        Gets the text in the layout.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        s$        the text in the layout

@ENDNODE

@NODE playoutGetUnknownGlyphsCount "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetUnknownGlyphsCount -- get unknown glyphs count

   @{b}SYNOPSIS@{ub}
        n = playout:GetUnknownGlyphsCount()

   @{b}FUNCTION@{ub}
        Counts the number of unknown glyphs in the layout.

        This function can be used to determine if there are any fonts available
        to render all characters in a certain string, or when used in
        combination with #PANGO_ATTR_FALLBACK, to check if a certain font
        supports all the characters in the string.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        n         the number of unknown glyphs in the layout

@ENDNODE

@NODE playoutGetWidth "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetWidth -- get wrap width

   @{b}SYNOPSIS@{ub}
        width = playout:GetWidth()

   @{b}FUNCTION@{ub}
        Gets the width to which the lines of the Pango layout should wrap. This
        function returns the width in Pango units, or -1 if no width set.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        width     the width in Pango units, or -1 if no width set

@ENDNODE

@NODE playoutGetWrap "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:GetWrap -- get wrap mode

   @{b}SYNOPSIS@{ub}
        mode = playout:GetWrap()

   @{b}FUNCTION@{ub}
        Gets the wrap mode for the layout. See @{"playout:SetWrap()" LINK playoutSetWrap} for a list of
        supported wrap modes.

        Use @{"playout:IsWrapped()" LINK playoutIsWrapped} to query whether any paragraphs were actually
        wrapped.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        mode      active wrap mode

@ENDNODE

@NODE playoutIndexToLineX "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:IndexToLineX -- index to line x

   @{b}SYNOPSIS@{ub}
        line, x_pos = playout:IndexToLineX(index, trailing)

   @{b}FUNCTION@{ub}
        Converts from byte "index" within the layout to line and X position.

        The X position is measured from the left edge of the line.

   @{b}INPUTS@{ub}
        index     the byte index of a grapheme within the layout
        trailing  an integer indicating the edge of the grapheme to retrieve the
                  position of. If > 0, the trailing edge of the grapheme, if 0,
                  the leading of the grapheme

   @{b}RESULTS@{ub}
        line      line index (will be between 0 and the number of layout lines
                  minus 1)
        x_pos     position within line (#PANGO_SCALE units per device unit)

@ENDNODE

@NODE playoutIndexToPos "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:IndexToPos -- get onscreen position of grapheme

   @{b}SYNOPSIS@{ub}
        pos = playout:IndexToPos(index)

   @{b}FUNCTION@{ub}
        Converts from an index within a Pango layout to the onscreen position
        corresponding to the grapheme at that index.

        The return value is a table containing the fields "x", "y", "width", and
        "height" to describe a rectangle. Note that "x" is always the leading
        edge of the grapheme and x+width the trailing edge of the grapheme. If
        the directionality of the grapheme is right-to-left, then "width" will
        be negative.

   @{b}INPUTS@{ub}
        index     byte index within the layout

   @{b}RESULTS@{ub}
        pos       rectangle containing the position of the grapheme

@ENDNODE

@NODE playoutIsEllipsized "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:IsEllipsized -- check for ellipsized paragraphs

   @{b}SYNOPSIS@{ub}
        bool = playout:IsEllipsized()

   @{b}FUNCTION@{ub}
        Queries whether the layout had to ellipsize any paragraphs.

        This returns TRUE if the ellipsization mode for the layout is not
        #PANGO_ELLIPSIZE_NONE, a positive width is set on the layout, and there
        are paragraphs exceeding that width that have to be ellipsized.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if any paragraphs had to be ellipsized, FALSE otherwise

@ENDNODE

@NODE playoutIsNull "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:IsNull -- check if layout is invalid

   @{b}SYNOPSIS@{ub}
        bool = playout:IsNull()

   @{b}FUNCTION@{ub}
        Returns TRUE if the layout is NULL, i.e. invalid. If functions that
        allocate layouts fail, they might not throw an error but simply set the
        layout to NULL. You can use this function to check if layout allocation
        has failed in which case the layout will be NULL.

        Also, certain getter functions can return a NULL object in case the
        object doesn't exist. You can use this function to check if a getter
        function returned a NULL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if the layout is NULL, otherwise FALSE

@ENDNODE

@NODE playoutIsWrapped "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:IsWrapped -- check for wrapped paragraphs

   @{b}SYNOPSIS@{ub}
        bool = playout:IsWrapped()

   @{b}FUNCTION@{ub}
        Queries whether the layout had to wrap any paragraphs.

        This returns TRUE if a positive width is set on the layout,
        ellipsization mode of the layout is set to #PANGO_ELLIPSIZE_NONE, and
        there are paragraphs exceeding the layout width that have to be wrapped.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        bool      TRUE if any paragraphs had to be wrapped, FALSE otherwise

@ENDNODE

@NODE playoutMoveCursorVisually "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:MoveCursorVisually -- move cursor visually

   @{b}SYNOPSIS@{ub}
        nidx, ntrail = playout:MoveCursorVisually(strong, oidx, otrail, dir)

   @{b}FUNCTION@{ub}
        Computes a new cursor position from an old position and a direction.

        If "dir" is positive, then the new position will cause the strong or
        weak cursor to be displayed one position to right of where it was with
        the old cursor position. If "dir" is negative, it will be moved to the
        left.

        In the presence of bidirectional text, the correspondence between
        logical and visual order will depend on the direction of the current
        run, and there may be jumps when the cursor is moved off of the end of a
        run.

        Motion here is in cursor positions, not in characters, so a single call
        to this function may move the cursor over multiple characters when
        multiple characters combine to form a single grapheme.

   @{b}INPUTS@{ub}
        strong    whether the moving cursor is the strong cursor or the weak
                  cursor; the strong cursor is the cursor corresponding to text
                  insertion in the base direction for the layout
        oidx      the byte index of the current cursor position
        otrail    if 0, the cursor was at the leading edge of the grapheme
                  indicated by "oidx"; if > 0, the cursor was at the trailing
                  edge
        dir       direction to move cursor; a negative value indicates motion to
                  the left

   @{b}RESULTS@{ub}
        nidx      new cursor byte index; a value of -1 indicates that the cursor
                  has been moved off the beginning of the layout; a value of
                  #G_MAXINT indicates that the cursor has been moved off the end
                  of the layout
        ntrail    number of characters to move forward from the location
                  returned for "nidx" to get the position where the cursor
                  should be displayed; this allows distinguishing the position
                  at the beginning of one line from the position at the end of
                  the preceding line; "nind" is always on the line where the
                  cursor should be displayed

@ENDNODE

@NODE playoutReference "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:Reference -- increase reference count

   @{b}SYNOPSIS@{ub}
        playout:Reference()

   @{b}FUNCTION@{ub}
        Increase the reference count on the Pango layout by one.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE playoutSetAlignment "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetAlignment -- set alignment

   @{b}SYNOPSIS@{ub}
        playout:SetAlignment(alignment)

   @{b}FUNCTION@{ub}
        Sets the alignment for the layout: how partial lines are positioned
        within the horizontal space available. The "alignment" parameter can be
        one of the following constants:

        #PANGO_ALIGN_LEFT
                  Put all available space on the right.
        #PANGO_ALIGN_CENTER
                  Center the line within the available space.
        #PANGO_ALIGN_RIGHT
                  Put all available space on the left.

        The default alignment is #PANGO_ALIGN_LEFT.

   @{b}INPUTS@{ub}
        alignment desired alignment (see above)

@ENDNODE

@NODE playoutSetAttributes "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetAttributes -- set attributes

   @{b}SYNOPSIS@{ub}
        playout:SetAttributes(attrs)

   @{b}FUNCTION@{ub}
        Sets the text attributes for a layout object.

        This function references "attrs", so the caller can unref its reference.

   @{b}INPUTS@{ub}
        attrs     a Pango attribute list object

@ENDNODE

@NODE playoutSetAutoDir "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetAutoDir -- set auto dir

   @{b}SYNOPSIS@{ub}
        playout:SetAutoDir(auto_dir)

   @{b}FUNCTION@{ub}
        Sets whether to calculate the base direction for the layout according to
        its contents.

        When this flag is on (the default), then paragraphs in the layout that
        begin with strong right-to-left characters (Arabic and Hebrew
        principally), will have right-to-left layout, paragraphs with letters
        from other scripts will have left-to-right layout. Paragraphs with only
        neutral characters get their direction from the surrounding paragraphs.

        When FALSE, the choice between left-to-right and right-to-left layout is
        done according to the base direction of the layout's Pango context. See
        @{"pcontext:SetBaseDir()" LINK pcontextSetBaseDir} for details.

        When the auto-computed direction of a paragraph differs from the base
        direction of the context, the interpretation of #PANGO_ALIGN_LEFT and
        #PANGO_ALIGN_RIGHT are swapped.

   @{b}INPUTS@{ub}
        auto_dir  if TRUE, compute the bidirectional base direction from the
                  layout's contents

@ENDNODE

@NODE playoutSetEllipsize "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetEllipsize -- set ellipsize

   @{b}SYNOPSIS@{ub}
        playout:SetEllipsize(ellipsize)

   @{b}FUNCTION@{ub}
        Sets the type of ellipsization being performed for the layout.

        Depending on the ellipsization mode "ellipsize" text is removed from the
        start, middle, or end of text so they fit within the width and height of
        layout set with @{"playout:SetWidth()" LINK playoutSetWidth} and @{"playout:SetHeight()" LINK playoutSetHeight}.

        If the layout contains characters such as newlines that force it to be
        layed out in multiple paragraphs, then whether each paragraph is
        ellipsized separately or the entire layout is ellipsized as a whole
        depends on the set height of the layout.

        The following values are possible for "ellipsize":

        #PANGO_ELLIPSIZE_NONE
                  No ellipsization.
        #PANGO_ELLIPSIZE_START
                  Omit characters at the start of the text.
        #PANGO_ELLIPSIZE_MIDDLE
                  Omit characters in the middle of the text.
        #PANGO_ELLIPSIZE_END
                  Omit characters at the end of the text.

        The default value is #PANGO_ELLIPSIZE_NONE.

        See @{"playout:SetHeight()" LINK playoutSetHeight} for details.

   @{b}INPUTS@{ub}
        ellipsize the new ellipsization mode for the layout (see above)

@ENDNODE

@NODE playoutSetFontDescription "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetFontDescription -- set font description

   @{b}SYNOPSIS@{ub}
        playout:SetFontDescription(desc)

   @{b}FUNCTION@{ub}
        Sets the default font description for the layout.

        If no font description is set on the layout, the font description from
        the layout's context is used.

   @{b}INPUTS@{ub}
        desc      the new Pango font description to unset the current font
                  description

@ENDNODE

@NODE playoutSetHeight "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetHeight -- set height

   @{b}SYNOPSIS@{ub}
        playout:SetHeight(height)

   @{b}FUNCTION@{ub}
        Sets the height to which the Pango layout should be ellipsized at.

        There are two different behaviors, based on whether "height" is positive
        or negative.

        If "height" is positive, it will be the maximum height of the layout.
        Only lines would be shown that would fit, and if there is any text
        omitted, an ellipsis added. At least one line is included in each
        paragraph regardless of how small the height value is. A value of zero
        will render exactly one line for the entire layout.

        If "height" is negative, it will be the (negative of) maximum number of
        lines per paragraph. That is, the total number of lines shown may well
        be more than this value if the layout contains multiple paragraphs of
        text. The default value of -1 means that the first line of each
        paragraph is ellipsized. This behavior may be changed in the future to
        act per layout instead of per paragraph.

        Height setting only has effect if a positive width is set on the layout
        and ellipsization mode of the layout is not #PANGO_ELLIPSIZE_NONE. The
        behavior is undefined if a height other than -1 is set and ellipsization
        mode is set to #PANGO_ELLIPSIZE_NONE, and may change in the future.

   @{b}INPUTS@{ub}
        height    the desired height of the layout in Pango units if positive,
                  or desired number of lines if negative.

@ENDNODE

@NODE playoutSetIndent "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetIndent -- set indent

   @{b}SYNOPSIS@{ub}
        playout:SetIndent(indent)

   @{b}FUNCTION@{ub}
        Sets the width in Pango units to indent each paragraph.

        A negative value of "indent" will produce a hanging indentation. That
        is, the first line will have the full width, and subsequent lines will
        be indented by the absolute value of "indent".

        The indent setting is ignored if layout alignment is set to
        #PANGO_ALIGN_CENTER.

        The default value is 0.

   @{b}INPUTS@{ub}
        indent    the amount by which to indent

@ENDNODE

@NODE playoutSetJustify "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetJustify -- set justify mode

   @{b}SYNOPSIS@{ub}
        playout:SetJustify(justify)

   @{b}FUNCTION@{ub}
        Sets whether each complete line should be stretched to fill the entire
        width of the layout.

        Stretching is typically done by adding whitespace, but for some scripts
        (such as Arabic), the justification may be done in more complex ways,
        like extending the characters.

        Note that tabs and justification conflict with each other: Justification
        will move content away from its tab-aligned positions.

        The default value is FALSE.

   @{b}INPUTS@{ub}
        justify   whether the lines in the layout should be justified

@ENDNODE

@NODE playoutSetLineSpacing "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetLineSpacing -- set line spacing

   @{b}SYNOPSIS@{ub}
        playout:SetLineSpacing(factor)

   @{b}FUNCTION@{ub}
        Sets a factor for line spacing.

        Typical values are: 0, 1, 1.5, 2. The default values is 0.

        If "factor" is non-zero, lines are placed so that

            baseline2 = baseline1 + factor * height2

        where "height2" is the line height of the second line (as determined by
        the font(s)). In this case, the spacing set with @{"playout:SetSpacing()" LINK playoutSetSpacing} is
        ignored.

        If "factor" is zero (the default), spacing is applied as before.

        Note: for semantics that are closer to the CSS line-height property, use
        the line height attribute in a Pango attribute list.

   @{b}INPUTS@{ub}
        factor    the new line spacing factor

@ENDNODE

@NODE playoutSetMarkup "Pangomonium Guide"

   @{b}NAME@{ub}
        playout:SetMarkup -- set markup text

   @{b}SYNOPSIS@{ub}
        playout:SetMarkup(text$[, length])

   @{b}FUNCTION@{ub}
        Sets the layout text and attribute list from marked-up text. This will
        replace the current text and attribute list. It is the same as
        @{"playout:SetMarkupWithAccel()" LINK playoutSetMarkupWithAccel}, but the markup text isn't scanned for
        accelerators.

        The Pango markup language allows you to apply text formatting using XML
        tags. The most common tag in the Pango markup language is the <span>
        tag. It allows you to apply formatting to a range of characters. The
        <span> tag supports the following attributes:

        font
        font_desc A font description string, such as "Sans Italic 12". See
                  @{"pango.FontDescription()" LINK pangoFontDescription} for a description of the format of the
                  string representation. Note that any other span attributes
                  will override this description. So if you have "Sans Italic"
                  and also a style="normal" attribute, you will get Sans normal,
                  not italic.
        font_family
        face      A font family name.
        font_size
        size      Font size in 1024ths of a point, or in points (e.g. "12.5pt"),
                  or one of the absolute sizes "xx-small", "x-small", "small",
                  "medium", "large", "x-large", "xx-large", or a percentage
                  (e.g. "200%"), or one of the relative sizes "smaller" or
                  "larger". If you want to specify a absolute size, it"s usually
                  easier to take advantage of the ability to specify a partial
                  font description using "font"; you can use font="12.5" rather
                  than size="12800" or size="12.5pt".
        font_style
        style     One of "normal", "oblique", "italic".
        font_weight
        weight    One of "ultralight", "light", "normal", "bold", "ultrabold",
                  "heavy", or a numeric weight.
        font_variant
        variant   One of "normal", "small-caps", "all-small-caps",
                  "petite-caps", "all-petite-caps", "unicase", "title-caps".
        font_stretch
        stretch   One of "ultracondensed", "extracondensed", "condensed",
                  "semicondensed", "normal", "semiexpanded", "expanded",
                  "extraexpanded", "ultraexpanded".
        font_features
                  A comma-separated list of OpenType font feature settings, in
                  the same syntax as accepted by CSS. E.g:
                  font_features='dlig=1, -kern, afrc on'.
        foreground
        fgcolor
        color     An RGB color specification such as "#00FF00" or a color name
                  such as "red". An RGBA color specification such as "#00FF007F"
                  will be interpreted as sp