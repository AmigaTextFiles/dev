<html>
<!-- generated from RapaGUI.meta by MetaDoc 1.16 (c) by Andreas Falkenhahn -->
<head>
<title>Overview</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.16">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<h2 class="heading">43.1 Overview</h2>

<p>
Scrollcanvas class derives from <a href="Area.html">Area class</a> and creates a canvas with scrollbars attached. You can draw custom graphics to this canvas
via a paint callback that is automatically invoked whenever content needs to be drawn. You just
need to set up a notification on the <a href="ScrollcanvasPaint.html">Scrollcanvas.Paint</a> attribute and your event handler
will be called whenever content needs to be drawn. The same thing can be achieved by embedding a widget
derived from <a href="Hollywood.html">Hollywood class</a> inside a scrollgroup or connecting such a Hollywood
widget to scrollbars but Scrollcanvas class is preferable in some cases because it is optimized
especially for scrolled content, i.e. it tries to minimize painting by using OS widgets which are
specifically designed for displaying scrolled content. Thus, it is usually faster than the two solutions
outlined above.

<p>
You can set the canvas dimensions by using the <a href="ScrollcanvasVirtWidth.html">Scrollcanvas.VirtWidth</a> and <a href="ScrollcanvasVirtHeight.html">Scrollcanvas.VirtHeight</a>.
Since Scrollcanvas class uses scrollbars, the dimensions of the canvas can obviously be much
bigger than the physical dimensions of the scrollcanvas widget. As with all other classes,
you can set those physical dimensions using the generic <a href="AreaWidth.html">Area.Width</a> and <a href="AreaHeight.html">Area.Height</a> attributes.

<p>
To force a complete redraw of your widget, just run the <a href="AreaRedraw.html">Area.Redraw</a> method on your
object. Running <a href="AreaRedraw.html">Area.Redraw</a> on your object will result in your paint function being
called so that you can update the canvas accordingly.

<p>
With <code>Scrollcanvas class</code> the dimensions you specify in <a href="ScrollcanvasVirtWidth.html">Scrollcanvas.VirtWidth</a>
and <a href="ScrollcanvasVirtHeight.html">Scrollcanvas.VirtHeight</a> are in <a href="DIP.html">device-independent pixels</a> by default and
RapaGUI will automatically apply the system's scale factor to the contents drawn by the <a href="ScrollcanvasPaint.html">Scrollcanvas.Paint</a>
function. If you want to have fine-tuned control, you can set the <a href="ScrollcanvasAutoScale.html">Scrollcanvas.AutoScale</a>
attribute to <code>False</code>. In that case, <a href="ScrollcanvasVirtWidth.html">Scrollcanvas.VirtWidth</a> and <a href="ScrollcanvasVirtHeight.html">Scrollcanvas.VirtHeight</a>
are interpreted as physical pixels and no auto scaling will be done so that your paint function can
draw high resolutions graphics without any quality loss due to scaling. See <a href="HiDPI.html">High-DPI support</a> for details.

<p>

<p>
<hr>
<font size=-2><a href="Scrollcanvas_.html" target="_top">Show TOC</a></font>
</body>
</html>