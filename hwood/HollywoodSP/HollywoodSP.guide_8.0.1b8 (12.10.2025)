@DATABASE Hollywood.guide
@AUTHOR "Andreas Falkenhahn (ORIGINAL ENGLISH VERSION), Dámaso Domínguez (TRANSLATED SPANISH VERSION)"
@$VER: HollywoodSP.guide 8.0.1b8 (12.10.2025) by Dámaso 'AmiSpaTra' Domínguez
@INDEX Reference
@HELP Reference
@REMARK =======================================================================
@NODE Main "Guía de Hollywood: Contenidos *UPD10*"

-------------------------------------------------------------------------------

         @{fg highlight}## ## ###### ##    ##    ##  ## ##   ## ###### ###### #####@{fg text}
         @{fg highlight}## ## ##  ## ##    ##     ####  ## # ## ##  ## ##  ## ##  ##@{fg text}
         @{fg highlight}##### ##  ## ##    ##      ##   ## # ## ##  ## ##  ## ##  ##@{fg text}
         @{fg highlight}## ## ##  ## ##    ##      ##   ## # ## ##  ## ##  ## ##  ##@{fg text}
         @{fg highlight}## ## ###### ##### #####   ##   ####### ###### ###### #####@{fg text}

         La capa de aplicación multimedia  para múltiples plataformas


                     @{"IMPORTANTE... Sobre esta traducción " LINK AmiSpaTra}

-------------------------------------------------------------------------------

@{b}I. Introducción@{ub}

  @{" 01 Presentación                                                          " LINK Introduction}
     ¿Qué es Hollywood?

    @{" 01.01 Licencia                                                         " LINK License}
           Términos y condiciones.

    @{" 01.02 Filosofía                                                        " LINK Philosophy}
           La filosofía tras el programa.

    @{" 01.03 Requisitos                                                       " LINK Requirements}
           Lo que se necesita para que funcione.

    @{" 01.04 Créditos                                                         " LINK Credits}
           Quiénes han estado implicados en este proyecto.

    @{" 01.05 Foro                                                             " LINK Forum}
           Fuentes de consulta si necesita ayuda.

    @{" 01.06 Contacto                                                         " LINK Contact}
           Cómo contactar conmigo, el autor.

  @{" 02 El paquete Hollywood                                                  " LINK Package}
     Una visión general sobre su instalación.

    @{" 02.01 La interfaz gráfica del usuario                                  " LINK GUI}
           Información sobre su interfaz de usuario.

    @{" 02.02 Entorno de desarrollo integrado para Windows                     " LINK IDE}
           Manual de la interfaz integrada de desarrollo.

    @{" 02.03 Plataformas móviles                                              " LINK MobilePlatforms}
           Cómo utilizarlo bajo Android e iOS.

  @{" 03 Uso de la consola                                                     " LINK ConsoleUsageMenu}
     Su control preciso a través de la consola.

    @{" 03.01 Modo de consola                                                  " LINK ConsoleUsers}
           Su uso desde una consola.

    @{" 03.02 Argumentos de la consola                                         " LINK ManualUsage}
           Todos los argumentos que comprende.

    @{" 03.03 Emulación de la consola                                          " LINK ConsoleEmulation}
           Cómo utilizar los argumentos de la consola sin ella.

  @{" 04 Compilador y enlazador                                                " LINK CompilerMenu}
     Prepare sus guiones para la distribución.

    @{" 04.01 Compilación de ejecutables                                       " LINK Compiler}
           Compile ejecutables autónomos.

    @{" 04.02 Compilación de miniaplicaciones                                  " LINK Applets}
           Compile miniaplicaciones independientes de la plataforma.

    @{" 04.03 Incrustación de ficheros de datos                                " LINK LinkingData}
           Cómo incrustar los ficheros de datos en sus ejecutables.

    @{" 04.04 Incrustación de tipos de impresión                               " LINK LinkingFonts}
           Cómo incrustar los tipos de impresión en sus ejecutables.

    @{" 04.05 Incrustación de complementos                                     " LINK LinkingPlugins}
           Cómo incrustar complementos en sus ejecutables.

    @{" 04.06 Guardar guiones como ficheros de video                           " LINK VideoRecorder}
           Guarde sus guiones como ficheros en formato AVI.

  @{" 05 Complementos                                                          " LINK PluginsMenu}
     Hágalo aún más potente con los complementos.

    @{" 05.01 Complementos                                                     " LINK Plugins}
           Ampliación de las funcionalidades a través de los complementos.

    @{" 05.02 Instalación                                                      " LINK PluginsInstallation}
           Dónde instalarlos.

    @{" 05.03 Modo de empleo                                                   " LINK PluginsUsage}
           Cómo utilizarlos desde su guión.

    @{" 05.04 Obtención de complementos                                        " LINK PluginsObtaining}
           Dónde obtenerlos.

    @{" 05.05 Escribiendo sus propios complementos                             " LINK SDK}
           Información sobre el paquete para los desarrolladores.

  @{" 06 Historia y compatibilidad                                             " LINK HistoryMenu}
     Documentación de versiones previas y cambios.

    @{" 06.01 Historia                                                         " LINK History}
           ¿Qué ha pasado anteriormente?

    @{" 06.02 Notas de compatibilidad                                          " LINK APIChanges}
           Lista detallada de los cambios en la interfaz de programación.

    @{" 06.03 Futuro                                                           " LINK ToDo}
           ¿Qué puede deparar el futuro a Hollywood?

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

 @{b}II. El lenguaje@{ub}

  @{" 07 Comenzando                                                            " LINK PrgIntroduction}
     Su primer programa con Hollywood.

    @{" 07.01 Identificadores reservados                                       " LINK PrgIdentifiers}
           Identificadores reservados por el lenguaje.

    @{" 07.02 Comandos del preprocesador                                       " LINK PrgPreproc}
           Utilícelos para cargar previamente gráficos, sonidos y mucho más.

    @{" 07.03 Conversión numérica y de cadenas                                 " LINK PrgStrNumConv}
           Conversión automática de números y cadenas.

    @{" 07.04 Comentarios                                                      " LINK PrgComments}
           Los buenos programadores comentan su código.

    @{" 07.05 Inclusión de ficheros                                            " LINK PrgIncludes}
           Reparta su proyecto a través de múltiples ficheros.

    @{" 07.06 Manejo de los errores                                            " LINK PrgErrorHandling}
           Cómo se manejan los errores en Hollywood.

    @{" 07.07 Selección automática del id(entificador)                         " LINK AutoIDSelect}
           Cómo se utiliza.

    @{" 07.08 Cargadores y adaptadores                                         " LINK LoaderAdapterInfo}
           ¿Qué diferencias hay entre ambos?

    @{" 07.09 Etiquetas del usuario                                            " LINK UserTagsInfo}
           Suministrando datos adicionales a los complementos.

    @{" 07.10 Sugerencias de estilo                                            " LINK PrgStyleguideSuggestions}
           Mantenga su código legible.

  @{" 08 Tipos de datos                                                        " LINK PrgTypeIntro}
     Un breve vistazo a los diferentes tipos soportados.

    @{" 08.01 Números                                                          " LINK PrgTypeNumber}
           Valores enteros y de coma flotante.

    @{" 08.02 Cadenas                                                          " LINK PrgTypeString}
           Secuencias de caracteres.

    @{" 08.03 Tablas                                                           " LINK PrgTypeTable}
           Espacio de almacenamiento para múltiples ítems de datos.

    @{" 08.04 Funciones                                                        " LINK PrgTypeFunc}
           Subrutinas invocables por el usuario.

    @{" 08.05 NIL                                                              " LINK PrgTypeNil}
           Tipo especial para variables no inicializadas.

  @{" 09 Expresiones y operadores                                              " LINK PrgOpr}
     ¿Qué es una expresión? ¿Y un operador?

    @{" 09.01 Operadores aritméticos                                           " LINK PrgOprArith}
           Operaciones matemáticas básicas.

    @{" 09.02 Operadores relacionales                                          " LINK PrgOprRelat}
           Comprobación de relaciones entre dos operandos.

    @{" 09.03 Operadores lógicos                                               " LINK PrgOprLogic}
           Operadores "And" (Y), "Or" (O), "Not" (NO).

    @{" 09.04 Operadores a nivel de bit                                        " LINK PrgOprBitw}
           Desplazamientos y operaciones lógicas a nivel de bit.

    @{" 09.05 Concatenación de cadenas                                         " LINK PrgOprStrng}
           Concatenación de múltiples cadenas en una única.

    @{" 09.06 Prioridades de los operadores                                    " LINK PrgOprPri}
           Todos los operadores y la prioridad con que se evalúan.

    @{" 09.07 Metamétodos                                                      " LINK PrgOprMM}
           Empleo de tablas en expresiones.

  @{" 10 Variables y constantes                                                " LINK PrgVariables}
     Introducción a las variables y constantes.

    @{" 10.01 Variables globales                                               " LINK PrgGlobals}
           Variables que están disponibles globalmente.

    @{" 10.02 La declaración Global                                            " LINK PrgGlobal}
           Declaración de variables globales.

    @{" 10.03 Variables locales                                                " LINK PrgLocals}
           Variables que tienen una vida limitada.

    @{" 10.04 La declaración Local                                             " LINK PrgLocal}
           Declaración de variables locales.

    @{" 10.05 Recolector de basura                                             " LINK PrgGarbageCollector}
           Hollywood lo ejecuta periódicamente.

    @{" 10.06 Constantes                                                       " LINK PrgConstants}
           Cómo declarar sus propias constantes.

    @{" 10.07 La declaración Const                                             " LINK PrgConst}
           Definición de sus propias constantes

    @{" 10.08 Constantes internas                                              " LINK PrgInbuiltCst}
           Constantes especiales predefinidas.

    @{" 10.09 Constantes de carácter                                           " LINK PrgCharacterCst}
           Cómo usar las constantes de carácter.

  @{" 11 Control del flujo del programa                                        " LINK PrgFlow}
     Sentencias para controlar el flujo del programa.

    @{" 11.01 Estructura If-EndIf                                              " LINK PrgIf}
           Bloque condicional flexible.

    @{" 11.02 Estructura While-Wend                                            " LINK PrgWhile}
           Bucle a repetir mientras una condición se cumpla.

    @{" 11.03 Estructura For-Next                                              " LINK PrgFor}
           Bucle a repetir un número de veces.

    @{" 11.04 Estructura Repeat-Until/Forever                                  " LINK PrgRepeat}
           Bucle a repetir hasta que una condición se cumpla.

    @{" 11.05 Estructura Switch-Case                                           " LINK PrgSwitch}
           Bloque condicional simple.

    @{" 11.06 Sentencia Break                                                  " LINK PrgBreak}
           Interrupción del bucle/bloque condicional Switch más cercano.

    @{" 11.07 Sentencia Continue                                               " LINK PrgContinue}
           Continuación del bucle más cercano.

    @{" 11.08 Sentencia Return                                                 " LINK PrgReturn}
           Retorno de una función a dónde se invocó.

    @{" 11.09 Estructura Block-EndBlock                                        " LINK PrgBlock}
           Creación de un nuevo bloque.

    @{" 11.10 Las declaraciones de matrices Dim y DimStr                       " LINK PrgDim}
           Declaración de matrices de forma adecuada.

  @{" 12 Funciones                                                             " LINK PrgFunctions}
     Introducción a las funciones.

    @{" 12.01 Las funciones son variables                                      " LINK PrgFuncVar}
           Cada función es una variable normal.

    @{" 12.02 Funciones de retrollamada                                        " LINK PrgFuncCallback}
           Aprenda a trabajar con ellas.

    @{" 12.03 Valores devueltos                                                " LINK PrgFuncRetVals}
           Información avanzada sobre éstos.

    @{" 12.04 Funciones recursivas                                             " LINK PrgFuncRec}
           Soporte completo de la recursión.

    @{" 12.05 Número variable de argumentos                                    " LINK PrgFuncVarArgs}
           Cómo manejar un número variable de argumentos.

    @{" 12.06 Funciones como miembros de tablas                                " LINK PrgFuncTable}
           Las funciones también pueden ser almacenadas en tablas.

    @{" 12.07 Funciones locales                                                " LINK PrgFuncLoc}
           Las funciones también pueden ser locales.

    @{" 12.08 Métodos                                                          " LINK PrgFuncMethods}
           Programación orientada a objetos.

  @{" 13 Solución a problemas                                                  " LINk PrgTSIntro}
       Información sobre problemas comunes.

    @{" 13.01 Solución a problemas                                             " LINK PrgTSTroubleshooting}
           Los errores más comunes.

    @{" 13.02 Dudas frecuentes                                                 " LINK PrgTSFAQ}
           Respuestas a las preguntas habituales.

  @{" 14 Soporte de Unicode                                                    " LINK PrgUCIntro}
       Hollywood ofrece un soporte completo.

    @{" 14.01 Generalidades                                                    " LINK PrgUCOverview}
           Introducción a Unicode.

    @{" 14.02 Codificaciones de los caracteres                                 " LINK CharacterEncoding}
           Esquemas de codificación soportados.

  @{" 15 Tutoriales                                                            " LINK PrgTUIntro}
       Comience a programar.

    @{" 15.01 Tutorial                                                         " LINK PrgTUTutorial}
           Su primera presentación en diez fáciles pasos.

    @{" 15.02 Técnicas de animación                                            " LINK PrgTUAnimation}
           Encuentre la mejor técnica de animación para su proyecto.

    @{" 15.03 Temporización del guión                                          " LINK PrgTUTiming}
           ¡Un tema muy importante! ¡Léalo!

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

 @{b}III. Referencia de funciones@{ub}

  @{" 16 Biblioteca de eventos Event                                           " LINK LibEvent}
    Introducción a la biblioteca de eventos.

    @{" 16.01 Botones                                                          " LINK LibEventButton}
           Cree botones y maneje sus eventos.

    @{" 16.02 Manejo de eventos                                                " LINK LibEventHandler}
           Documentación de "WaitEvent()", ...

    @{" 16.03 Ratón y teclado                                                  " LINK LibEventInput}
           Consultando los estados del ratón y el teclado.

    @{" 16.04 Palanca de control                                               " LINK LibEventJoystick}
           Consultando el estado de la palanca de control.

    @{" 16.05 Intervalos                                                       " LINK LibEventInterval}
           Cómo instalar una función de intervalo.

    @{" 16.06 Tiempo de espera                                                 " LINK LibEventTimeout}
           Instalación de una función de tiempo de espera.

    @{" 16.07 IPC: Intercomunicación de procesos                               " LINK LibEventIPC}
           Funciones para comunicación entre procesos.

    @{" 16.08 Compatibilidad de las funciones                                  " LINK LibEventCompat}
           Compatibilidad con las funciones de Hollywood v1.x.

  @{" 17 Biblioteca matemática Math                                            " LINK LibMath}
     El gran laboratorio matemático.

  @{" 18 Biblioteca de cadenas  String                                         " LINK LibString}
     Funciones para manipular cadenas.

  @{" 19 Biblioteca de visualización Display                                   " LINK LibDisplay}
     Funciones para manejar las visualizaciones.

  @{" 20 Biblioteca de menús Menu                                              " LINK LibMenu}
     Funciones para añadir menús a las visualizaciones.

  @{" 21 Biblioteca gráfica Graphics                                           " LINK LibGfx}
     Introducción a la biblioteca gráfica.

    @{" 21.01 Primitivas gráficas                                              " LINK LibGfxDraw}
           Rectángulos, líneas, círculos, polígonos.

    @{" 21.02 Imágenes de fondo                                                " LINK LibGfxBGPic}
           Todo sobre las imágenes de fondo.

    @{" 21.03 Brochas                                                          " LINK LibGfxBrush}
           Dibujado y procesado de brochas.

    @{" 21.04 Animación                                                        " LINK LibGfxAnim}
           Funciones de reproducción de animaciones.

    @{" 21.05 Capas                                                            " LINK LibGfxLayer}
           Funciones para la gestión de capas.

    @{" 21.06 Duendecillos gráficos                                            " LINK LibGfxSprite}
           Todos sobre los duendecillos gráficos.

    @{" 21.07 Doble (memoria) tampón                                           " LINK LibGfxDoublebuffer}
            Visualización con doble tampón.

    @{" 21.08 Gráficos vectoriales                                             " LINK LibGfxVector}
           Funciones de dibujo basadas en vectores.

    @{" 21.09 Iconos                                                           " LINK LibGfxIcon}
           Cómo trabajar con iconos.

    @{" 21.10 Funciones de paleta                                              " LINK LibGfxPalette}
           Todo sobre las paletas en Hollywood

    @{" 21.11 Funciones variadas                                               " LINK LibGfxMisc}
           Detección de colisiones y otras funciones.

  @{" 22 Biblioteca de video Video                                             " LINK LibVideo}
     Funciones para la reproducción de video.

  @{" 23 Biblioteca de texto Text                                              " LINK LibText}
     Introducción a la biblioteca de texto.

    @{" 23.01 Tipos de impresión                                               " LINK LibText}
           Carga de tipos de impresión, aplicación de estilos.

    @{" 23.02 Generación de texto                                              " LINK LibTextRender}
           Funciones de salida de texto.

    @{" 23.03 Objetos de texto                                                 " LINK LibTextObject}
           Cómo crear objetos de texto.

  @{" 24 Biblioteca de sonido Sound                                            " LINK LibSound}
     Introducción a la biblioteca de sonido.

    @{" 24.01 Muestras                                                         " LINK LibSoundSample}
           Reproducción de muestras de sonido.

    @{" 24.02 Música                                                           " LINK LibSoundMusic}
           Reproducción de flujos de audio y módulos de Protracker.

    @{" 24.03 Canales                                                          " LINK LibSoundMisc}
           Gestión de los canales de sonido.

    @{" 24.04 Funciones variadas                                               " LINK LibSoundMisc}
           Otras funciones relacionadas con el sonido.

  @{" 25 Biblioteca de operaciones de ficheros DOS                             " LINK LibDOSFunctions}
     Funciones para E/S de fichero y mucho más.

  @{" 26 Biblioteca de red Network                                             " LINK LibNetwork}
     Funciones para el acceso a redes.

  @{" 27 Biblioteca del sistema System                                         " LINK LibSys}
     Introducción a la biblioteca del sistema.

    @{" 27.01 Fecha y hora                                                     " LINK LibSysDate}
           Consulta de la fecha del sistema, día de la semana, ...

    @{" 27.02 Medición del tiempo                                              " LINK LibSysTimer}
           Medición del tiempo transcurrido entre dos momentos determinados.

    @{" 27.03 Soporte local                                                    " LINK LibSysLocale}
           Soporte de idiomas diferentes.

    @{" 27.04 Peticiones                                                       " LINK LibSysReq}
           Apertura de los diferentes tipos de peticiones.

    @{" 27.05 Consola                                                          " LINK LibSysConsole}
           Funciones para entradas y salidas de la consola.

    @{" 27.06 Depuración                                                       " LINK LibSysDebug}
           Funciones de bajo nivel para la depuración.

    @{" 27.07 Tablas y listas                                                  " LINK LibSysList}
           Gestión de tablas y listas.

    @{" 27.08 Objetos                                                          " LINK LibSysObject}
           Funciones para trabajar con los objetos.

    @{" 27.09 Puntero del ratón                                                " LINK LibSysPointer}
           Instalación de un nuevo puntero.

    @{" 27.10 Portapapeles                                                     " LINK LibSysClipboard}
           Funciones para trabajar con el portapapeles.

    @{" 27.11 Bloques de memoria                                               " LINK LibSysMemory}
           Funciones de bajo nivel para el manejo de bloques de memoria.

    @{" 27.12 Aplicación                                                       " LINK LibSysApp}
           Funciones para gestionar su aplicación.

    @{" 27.13 Puerto serie                                                     " LINK LibSysSerial}
           Funciones para entradas/salidas por el puerto serie.

    @{" 27.13 Seriar                                                           " LINK LibSysSerializer}
           Seriado de datos desde/a ficheros.

    @{" 27.15 Complementos                                                     " LINK LibSysPlugin}
           Funciones para controlar los complementos.

    @{" 27.16 Miscelánea                                                       " LINK LibSysMisc}
           Otras funciones del sistema.

  @{" 28 Índice                                                                " LINK Reference}
     Encuentre rápidamente lo que busca.

-------------------------------------------------------------------------------
                           @{b}Hollywood es propiedad de
                 (C) Copyright © 2002-2023 Andreas Falkenhahn.
                        Todos los derechos reservados.

       Traducción libre y sin garantías al español v8.0.1b8 (12.10.2025)
     (actualización de la documentación de la v8.0 a v10.0... EN PROGRESO)
            Propiedad de: Copyright © Dámaso Domínguez (AmiSpaTra).
                         Todos los derechos reservados
                Dedicado a mi familia y todas mis musas ;D@{ub}
             ¡¡ Consulte siempre la versión original en inglés !!
-------------------------------------------------------------------------------


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Main"}

@ENDNODE
@REMARK =======================================================================
@NODE Introduction "Guía de Hollywood: Presentación *UPD10*"

@{b}Presentación@{ub}

Hollywood  es  un  lenguaje de programación orientado a la multimedia que puede
ser utilizado para crear aplicaciones gráficas y juegos de forma muy fácil.  Ha
sido  diseñado  teniendo  en  mente  que la creación de programas ha de ser tan
sencilla  como sea posible.  Por ello, Hollywood es adecuado tanto para novatos
como  para  usuarios  avanzados.   Hollywood  ofrece  una extensa biblioteca de
funciones  (que  abarca  casi 1.000 comandos diferentes) que simplifica en gran
medida  la  creación de juegos y aplicaciones.  Ha estado desarrollándose desde
2002 y hoy día es un paquete muy maduro y estable.

Uno  de  los  aspectos  a  resaltar  de  Hollywood es que incluye un compilador
cruzado  integrado  que  puede  ser  utilizado  para  compilar  ejecutables  en
diferentes  plataformas  sin tener que cambiar ni una sóla línea de código.  El
compilador  cruzado  puede  generar el código para todas las plataformas en las
que  Hollywood  se  ejecute.   Por  ejemplo, puede compilar una aplicación para
macOS  utilizando  la  versión  Windows  de Hollywood y viceversa.  Además, hay
extensiones   que   le   permite  compilar  sus  proyectos  de  Hollywood  como
aplicaciones nativas para iOS y Android.

Hollywood  es  ligero, pero aún así es un poderoso lenguaje de programación con
un núcleo de unos dos megaoctetos que no exige componentes externos.  Por ello,
es  ideal  para  crear  programas que se ejecutan correctamente sin instalación
previa.  De hecho, los programas de Hollywood se ejecutarán perfectamente desde
una  llave  o  memoria  USB  sin instalación previa de ningún tipo.  Además, la
funcionalidad  de partida de Hollywood puede mejorar en gran medida a través de
multitud  de  complementos  gratuitos que le permitirán acceder a OpenGLy SDL a
través de Hollywood, por ejemplo.

Actualmente se soportan las siguientes arquitecturas:

  - AmigaOS 3 (m68k)
  - AmigaOS 4 (ppc)
  - Android (arm)
  - AROS (x86)
  - iOS (arm)
  - Linux (x86)
  - Linux (x64)
  - Linux (ppc)
  - Linux (arm)
  - macOS (arm)
  - macOS (x86)
  - macOS (x64)
  - macOS (ppc)
  - MorphOS (ppc)
  - WarpOS (m68k/ppc)
  - Windows (x86)
  - Windows (x64)

@{b}Prestaciones y características de Hollywood@{ub}

Gráficos:

  * Motor gráfico muy flexible basado en capas
  * Soporte del canal alfa en los gráficos
  * Posibilidad de utilizar duendecillos gráficos de cualquier tamaño
  * Amplio soporte de texto que incluye aplicación
    de formato en tiempo real, partición de palabras y rotación
  * Generación de texto TrueType independiente de la plataforma
  * Soporte completo de la reproducción de video
  * Carga de imágenes vectoriales reales como el formato @{u}SVG@{uu}
  * Importación y exportación PDF.
  * Soporte de primitivas gráficas
    (elipses, arcos, líneas, rectángulos, polígonos,...)
  * Soporte para dibujo vectorial (esplines Bézier...)
  * Suavizado opcional para texto y primitivas gráficas
  * Sobre unas 150 transiciones para gráficos y texto
  * Toneladas de funciones para procesado de imágenes
  * Poderosas funciones de generación gráfica "fuera de pantalla"
    incluyendo la generación de máscaras y canales alfa
  * Soporte extensivo de zonas de recorte
    (recorte de regiones rectangulares y con formas definibles)
  * Soporte de visualizaciones con doble tampón
    gestionadas y aceleradas por la circuitería
  * Soporte de animación
  * Gráficos exportables como ficheros
    en formato PNG o incluso flujos de video AVI
  * Ventanas con posibilidad de utilizar un canal de transparencia alfa
  * Soporte de programación OpenGL 3D a través de complementos
  * Flujo de video soportado a través de un complemento dedicado

Sonido:

  * Interfaz de sonido multicanal
  * Soporte de muestras y flujos de sonido
  * Soporte de reprodución de módulos Protracker
  * El volumen y tono de las muestras
    puede ser alterado durante la reproducción
  * Mezclador multicanal para manipular las muestras
  * Posibilidad de enviar al dispositivo
    de sonido, sonido generado dinámicamente
  * Flujo de sonido soportado a través de un complemento dedicado

Interfaz gráfica del usuario:

  * Desarrollo de interfaces gráficas del usuario
    nativas soportadas a través del complemento RapaGUI
  * Creación de dichas interfaces nativas para
    Windows, Linux (GTK), macOS y AmigaOS (MUI)
  * Las interfaces gráficas son maquetadas
    convenientemente utilizando ficheros XML
  * Soporte para unos 40 artilugios de ventana diferentes
  * Flexibilidad total, ya que las visualizaciones
    de Hollywood pueden ser incrustadas en
    las interfaces gráficas del usuario nativas
  * Desarrollo de dichas interfaces gráficas de forma completamente
    independiente de la plataforma: ¡Uso del mismo código para todas!

Redes:

  * Soporte completo de redes e Internet
  * Creación de conexiones tipo servidor y tipo cliente
  * Transferencia de datos utilizando
    una amplia variedad de protocolos como HTTP, FTP y SCP
  * E/S serie a través de adaptadores RS/232 o USB
  * Soporte IPC para comunicarse con otros programas
  * Soporte de las interfaces IPv4 e IPv6
  * Soporte de SSL/TLS completo

Sistema:

  * Potente lenguaje de programación,
    pero aún así extremadamente fácil de usar
  * Compilador cruzado entre plataformas que soporta
    los ordenadores Amiga y compatibles, Windows, macOS y Linux
  * Soporte de Android e iOS a través del
    reproductor gratuito de Hollywood disponible
    Los paquetes APK pueden generarse a través del
    compilador APK para Hollywood disponible opcionalmente.
  * Los ejecutables compilados por Hollywood
    no exigen bibliotecas adicionales/DLL
    (¡pueden ser puestos en marcha desde una llave o memoria USB!)
  * Todos los ficheros de datos
    (incluyendo los tipos de impresión)
  * Soporto completo de Unicode
    puede ser incrustados en el ejecutable (un único fichero)
  * Soporte de los modos de pantalla completa y ventana
  * Soporte de múltiples monitores
  * "Cajón de arena": los programas nunca se bloquean
  * Se soporta la creación de menús del sistema operativo
  * Modelo de programación basado en eventos
    que garantiza un uso moderado del microprocesador
  * Baja latencia en las funciones de intervalo y temporización
  * Extensa biblioteca DOS para trabajar con el sistema de ficheros
  * Soporte de ZIP y otros archivadores.
  * Conveniente acceso al portapapeles
  * Acceso a peticiones, ventanas/cajas de diálogo del sistema
    (selector de ficheros, petición de cadenas, etcétera)
  * Soporte de la prestación "arrastrar y soltar"
  * Soporte de bases de datos vía SQL
  * Exhaustivas bibliotecas de cadenas y matemática
  * Fácil sustitución del cursor del ratón por uno definible
  * Seriación de datos de y para JSON y XML
  * Funciones de hora y fecha
  * Fácil internacionalización
    de los programas a través del sistema de catálogos
  * Soporte de palancas de control

Complementos:

  * Sistema de complementos entre plataformas extremadamente poderoso
  * Paquete para desarrolladores disponible públicamente
    con unas 500 páginas de documentación y código de ejemplo
  * El gestor de visualización por defecto es totalmente reorientable
    a través, enteramente, de diferentes subsistemas (como p. ej. OpenGL)
  * El gestor de sonido por defecto es totalmente reorientable
    a través, enteramente, de diferentes subsistemas
  * Los complementos pueden añadir cargadores y grabadores para formatos
    adicionales de imagen, animación, sonido, tipos de impresión y video
  * Todas las E/S a nivel de fichero pueden enrutarse
    a través de manejadores definibles a medida
  * El juego de comandos del lenguaje Hollywood
    puede ampliarse a través de los complementos


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Introduction"}

@ENDNODE
@REMARK =======================================================================
@NODE Philosophy "Guía de Hollywood: Filosofía *UPD10*"

@{b}Filosofía@{ub}

La  filosofía  tras Hollywood es ofrecer una poderosa plataforma, pero fácil de
utilizar  para escribir asombrosos programas en un espacio de tiempo muy corto.
El  lenguaje  utilizado  para  programa  con  Hollywood es muy sencillo para el
novato, pero con suficientes prestaciones para que el programador experimentado
lo  adore.   Puede  programar  Hollywood  en  un nivel muy simple al estilo del
BASIC,  pero  también  es  posible  sumergirse  en el mundo de la orientación a
objetos con él.   El amplio juego de comandos con unas 1.000 funciones internas
ofrece  al  programador  todas las herramientas necesarias para crear programas
asombrosos  con  Hollywood.   Casi  no  hay  nada que Hollywood no pueda hacer.
Además,   Hollywood  es  una  capa  de  aplicación  multimedia  para  múltiples
plataformas,  lo  que  significa  que puede ejecutar sus programas en múltiples
sistemas  diferentes  sin  cambiar  ni  una  sola línea de código, e incluso es
posible  compilar  de  forma  cruzada  ejecutables para estas plataformas.  Por
ejemplo, usted puede compilar aplicaciones macOS desde  su sistema AmigaOS 3.1.
Todos  esto  ¡convierte  a  Hollywood  en  la  herramienta  definitiva  para el
programador multimedia y una experiencia por derecho propio!


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Philosophy"}

@ENDNODE
@REMARK =======================================================================
@NODE License "Guía de Hollywood: Licencia *UPD10*"

@{b}Términos y condiciones@{ub}

Hollywood  (a  partir  de  aquí  refernciado  como  "el programa") es propiedad
© 2002-2023  Andreas Falkenhan (a partir de aquí referenciado como "el autor").
Todos los derechos están reservados.

El  programa  se suministra "tal cual" y el autor no puede ser responsabilizado
de  ningún daño producido por éste:  Usted utiliza este programa únicamente por
su cuenta y riesgo.  No hay garantías implícitadas ni el autor ofrece alguna.

No se permite realizar cambios en el programa si permiso del autor.

@{u}Versión de evaluación@{uu}

Se  permite  probar  la versión de evaluación de Hollywood durante treinta (30)
días.   Si  quiere  continuar utilizando Hollywood tras expirar este período de
prueba,  ha  de  adquirir  obligatoriamente  la  versión  completa,  sino ha de
desinstalar  Hollywood:   No  se  permite  continuar  utilizando Hollywood tras
expirar el período de prueba.

La  versión  de  evaluación de Hollywood se puede distribuir libremente siempre
que se respeten las siguientes condiciones:

  1. No se pueden realizar modificaciones en la versión de evaluación.
  2. No se permite vender la versión de evaluación.
  3. Distribuir  la  versión  de  evaluación  en  un  disco de portada
     exige un permiso por escrito del autor autorizándolo expresamente.

@{u}Versión completa@{uu}

La  versión  completa  de  Hollywood  puede instalarse en múltiples ordenadores
siempre  que sólo se utilice únicamente por la persona que ha adquirido y posee
la   licencia.    Todas   las   licencias   de  Hollywood  son  individuales  y
personalizadas,  de manera que no se permite compartir la licencia de Hollywood
con  otras  personas.  El nombre de quien ha adquirido la licencia, y que es el
único  autorizado para utilizar el programa, se muestra en el programa GUI y el
intérprete de Hollywood.

Esta  terminantemetne prohibido distribuir la versión completa de Hollywood sin
un permiso por esrito del autor.

@{u}Sus desarrollos con Hollywood@{uu}

No  hay  limitaciones  sobre  lo  que  pueda  crear  con  Hollywood,  salvo  la
prohibición   de  crear  programas  con  Hollywood  que  se  puedan  considerar
competencia  de  éste.   En  especial,  no se permite crear ningún programa que
permita  ejecutar  comandos, bibliotecas o complementos de Hollywood al usuario
final  o  desde  otros  lenguajes,  o  sea, que no se permite la publicación de
ningún  tipo de programa que actúe como intermediario para permitir el acceso a
los elementos de Hollywood ya citados.  Tampoco se permite crear un lenguaje de
programación  que  genere  código  a  partir de las bibliotecas, complementos o
comandos de Hollywood.

@{u}Exención de responsabilidades@{uu}

NO  EXISTE  GARANTÍA  PARA ESTE PROGRAMA EN LA MEDIDA QUE LO PERMITAN LAS LEYES
APLICABLES.   EXCEPTO CUANDO SE INDIQUE POR ESCRITO, EL TITULAR DE LOS DERECHOS
DE  AUTOR  U OTRAS PARTES OFRECEN EL PROGRAMA "TAL CUAL" SIN GARANTÍA DE NINGÚN
TIPO,  YA  SEA  EXPRESA  O  IMPLÍCITA,  INCLUYENDO,  PERO NO LIMITÁNDOSE A, LAS
GARANTÍAS  IMPLICÍTAS  DE  COMERCIALIZACIÓN  Y  ADECUACIÓN  PARA  UN  PROPÓSITO
PARTICULAR.  TODO EL RIESGO, EN CUANTO A CALIDAD Y RENDIMIENTO DEL PROGRAMA, ES
ASUMIDO  POR USTED.  EN EL CASO DE QUE SE PRUEBE QUE EL PROGRAMA ES DEFECTUOSO,
USTED ASUME TODO EL COSTE DEL SERVICIO, REPARACIÓN O CORRECCIÓN.

EN  NINGÚN CASO, A MENOS QUE LO EXIJA LA LEY APLICABLE O POR UN ACUERDO ESCRITO
DE  CUALQUIER TITULAR DE LOS DERECHOS DE AUTOR O CUALQUIER OTRA PARTE QUE PUEDA
DISTRIBUIR  EL  PROGRAMA  COMO SE PERMITE MÁS ATRÁS, SERÁ RESPONSABLE DE DAÑOS,
INCLUYENDO  CUALQUIER DAÑO GENERAL, ESPECIAL, INCIDENTAL O CONSECUENCIA DEL USO
O  INCAPACIDAD  DE  USO  DEL  PROGRAMA  (INCLUYENDO,  PERO NO LIMITÁNDOSE A LAS
PÉRDIDAS  DE DATOS O LA GENERACIÓN DE DATOS INCORRECTOS O PÉRDIDAS SUFRIDAS POR
USTED  O  TERCERAS  PARTES  O  UN  FALLO  DEL  PROGRAMA  PARA  OPERAR CON OTROS
PROGRAMAS),  INCLUSO  SI  EL  TITULAR  U OTRAS PARTES HAN SIDO ADVERTIDAS DE LA
POSIBILIDAD DE DICHOS DAÑOS.

@{u}Agradecimientos@{uu}

El  logicial  utiliza  Lua  de  Roberto  Ierusalimschy,  Waldemar  Celes y Luiz
Henrique  de  Figueiredo.   Consulte, para más detalles, @{"la licencia de Lua" LINK LicenseLua}.

El  logicial  utiliza libjpeg del Grupo independiente JPEG, libpng del Grupo de
desarrollo PNG y zlib de Jean-Loup Gailly y Mark Adler.

Este  logicial  utiliza PTPlay © Copyright 2001, 2003, 2004 de Ronald Hof, Timm
S. Mueller, Per Johansson.

Este  logicial utiliza la biblioteca OpenCV de la Corporación Intel.  Consulte,
para más detalles, @{"la licencia de la biblioteca OpenCV" LINK LicenseOpenCV}.

Este  logicial  utiliza  ImageMagick de ImageMagick Studio LLC.  Consulte, para
más detalles, @{"la licencia de ImageMagick" LINK LicenseImageMagick}.

Este  logicial  utiliza  la biblioteca gráfica GD de Thomas Boutell.  Consulte,
para más detalles, @{"la licencia de la biblioteca gráfica GD" LINK LicenseGD}.

Este  logicial  utiliza  la  biblioteca  Pixman.   Consulte, para más detalles,
@{"la licencia de Pixman" LINK LicensePixman}.

Porciones  de  este  logicial  son  propiedad del Proyecto de Tipo de Impresión
Libre/Gratuito  ©  2010  The FreeType Project (http://www.freetype.org).  Todos
los derechos reservados.

Hollywood  utiliza  la familia tipográfica  Bitstream Vera.  Consulte, para más
detalles, @{"la sección sobre los tipos de impresión Bitstream Vera" LINK LicenseVera}.

La versión de Linux de Hollywood utiliza gtk, glibc y la arquitectura de sonido
avanzada  ALSA para Linux, elementos todos ellos bajo licencia LGPL.  Consulte,
para más detalles, @{"la sección, en inglés, sobre la licencia LGPL" LINK "HollywoodEN.guide/LicenseLGPLv3"}.

La  versión  de  Android de Hollywood utiliza Simple DirectMedia Layer (SDL) de
Sam Lantinga.  Consulte  @{"la sección sobre la licencia SDL" LINK LicenseSDL} para los detalles.

Este logicial utiliza la biblioteca Codesets de Alfonso Ranieri y del Equipo de
código abierto codesets.library.   Para más detalles,  consulte @{"la sección, en" LINK LicenseLGPLv3}
@{"inglés, sobre la licencia LGPL" LINK "HollywoodEN.guide/LicenseLGPLv3"}.

Este logicial  utiliza  LuaSocket de  Diego Nehab.  Consulte  @{"la sección sobre" LINK LicenseLuaSocket}
@{"la licencia de LuaSocket" LINK LicenseLuaSocket} para los detalles.

Este logicial utiliza librs232  de  Petr Stetiar.   Consulte  @{"la sección sobre" LINK LicenseLibRS232}
@{"la licencia de librs232" LINK LicenseLibRS232} para los detalles.

Este logicial  utiliza UsbSerial  de Felipe Herranz. Consulte @{"la sección sobre" LINK LicenseUsbSerial}
@{"la licencia de UsbSerial" LINK LicenseUsbSerial} para los detalles.

Todas las marcas comerciales son propiedad de sus respectivos propietarios.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/License"}

@ENDNODE
@REMARK =======================================================================
@NODE Requirements "Guía de Hollywood: Requisitos *UPD10*"

@{b}Requisitos@{ub}

  @{b}Versión Windows@{ub}

  - Se exige al menos Windows 2000.

  @{b}Versión macOS@{ub}

  - ARM    : Se exige al menos macOS 11.0 (Big Sur).
  - Intel  : Se exige al menos macOS 10.6 (Snow Leopard).
  - PowerPC: Se exige al menos la versión macOS 10.4 (Tiger).

  @{b}Versión Linux@{ub}

  - Se exige un servidor X11 y glibc
  - Opcional: Biblioteca ALSA para la salida de sonido.
  - Opcional: GTK para el soporte de las cajas de diálogo.
  - Opcional: Biblioteca de extensión del modo de video XFree86,
              Xfixes, Xrender, Xcursor, Xrandr,
              Xss para algunas funcionalidades avanzadas.

  @{b}Versión para AmigaOS/MorphOS/AROS@{ub}

  - Kickstart 3.0 (versión 39).
  - Microprocesador 68020+ o PowerPC.
  - Sistema gráfico CyberGraphX o Picasso96.
  - Biblioteca Codesets bajo AmigaOS 3 y 4, WarpOS y AROS.
  - Biblioteca Charsets bajo MorphOS.
  - Opcional: AHI de Martin Blom para la salida de sonido.
  - Opcional: Biblioteca ReqTools para las funciones
    "StringRequest()", excepto bajo AmigaOS 4, y "ColorRequest()".
  - Opcional: Biblioteca PopUpMenu para
    la función @{"PopUpMenu" LINK PopUpMenu} (salvo bajo MorphOS).

  @{b}Versión iOS@{ub}

  - iOS 8 o superior.

  @{b}Versión Android@{ub}

  - Android v4.0 o superior.
  - Microprocesador ARM (32 o 64 bits).


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Requirements"}

@ENDNODE
@REMARK =======================================================================
@NODE Credits "Guía de Hollywood: Créditos *UPD10*"

@{b}Créditos@{ub}

Hollywood  ha  sido escrito por Andreas Falkenhahn.  Pero no habría llegado tan
lejos sin la ayuda de personas a las que quisiera dar las gracias aquí.

En  primer lugar,  mi  agradecimiento  en  especial  a  Timm S.  Müller por sus
esenciales consejos en las temprana fase de conceptulización de Hollywood.

En  segundo  lugar,  mi  agradecimiento  al equipo de Lua v5.0.2 por crear este
ligero  y  poderoso  lenguaje:   Roberto  Ierusalimschy,  Waldemar Celes y Luiz
Henrique de Figueiredo.

Gracias  a  Frank  Wille por la continua mejora del maravilloso compilador vbcc
que es necesario para la creación de las versiones 68K y WarpOS de Hollywood.

He  de dar las gracias especialmente a Dominic Widmer, Helmut Haake y Alexander
Pfau  por  traducir  la  gigantesca documentación al alemán.  Alexander Pfau ha
sido  el  primero  en  trabajar  en dicha traducción y la ha mantenido hasta la
versión  1.9.   Su  trabajo  ha  sido continuado gracias a un esfuerzo conjunto
suizo-alemán realizado por Dominic Widmer y Helmut Haake quienes mantienen esta
traducción hasta el día de hoy.

Mi agradecimiento además a Grzegorz Kraszewski, Martin Blom, Tomasz Wiszkowski,
Kimmo  Pekkola,  Olaf  Barthel,  Thomas  Richter,  Christoph Gutjahr, Jean-Yves
Auger,  Ralph  Schmidt,  Detlef Würkner, Stephan Rupprecht, Frank Mariak, Jacek
Piszczek,  Torgeir  Vee,  Christoph  Poelzl,  Fabio  Falcucci, Michael Jurisch,
Petteri  Valli  y  a todos los probadores beta y a aquellos que han estado ahí,
pero que he olvidado.

La  versión  de  Hollywood  para  Amiga  ha  sido  desarrollada bajo SAS/C 6.58
(versión 68K), VBCC (versión WarpOS), GCC v4.4.4 (versión MorphOS) y GCC v4.0.2
(versión  AmigaOS  4).   Además,  se  han  utilizado  los siguientes programas:
GoldED  Studio AIX, Directory Opus 4, PPaint 7, CyberGuard, CyberGraphX 4, MUI.
El  desarrollo principal se ha realizado en un Pegasos 2 con una unidad central
de  proceso  G4 a 1 GHz y MorphOS 1.4.5.  Además se ha desarrollado en un Amiga
1200  equipado  con  una  tarjeta  Blizzard  PPC  603e a 240 MHz de Phase5 y 82
megaoctetos de RAM.  Hollywood ha sido ampliamente probado bajo CyberGraphX 3 y
4, Picasso96, MorphOS, AmigaOS 4, AROS, DraCo, Amithlon y WinUAE.  Hollywood no
accede  en  forma alguna directamente a la circuitería, respeta las directrices
de  estilo  de  todos  los  sistemas y sólo utiliza funciones amigables con los
sistemas.

La versión macOS ha sido desarrollada en un Mac Mini a 1.5 GHz utilizando macOS
10.4  (Tiger) y en un Intel iMac a 2.4 GHz utilizando macOS 10.5 (Leopard).  El
código ha sido escrito utilizando el flexible editor de texto TextMate de Allan
Odgaard.   Hollywood  ha  sido  compilado  utilizando GCC que se incluye con el
paquete para desarrolladores macOS de Apple.

La  versión  Windows ha sido desarrollada en un Pentium IV a 2.6 GHz utilizando
Windows XP en su edición doméstica actualizado con los paquetes de servicio más
recientes.   El  código  ha  sido escrito utilizando el famoso UltraEdit de IDM
Comp.  Hollywood ha sido compilado utilizando Visual C de Microsoft.

La  versión  de Linux ha sido desarrollada utilizando openSUSE v11.2 en Pentium
IV a 2.6 GHz.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Credits"}

@ENDNODE
@REMARK =======================================================================
@NODE Forum "Guía de Hollywood: Foro *UPD10*"

@{b}Foro@{ub}

Los foros oficiales están en línea y disponibles en:

                         http://www.hollywood-mal.com/

Siéntase  libre para pasarse por allí y hablar con otros usuarios de Hollywood:
Es el lugar perfecto para pedir ayuda de otros usuarios.

Además  del  foro, también tenemos una lista de distribución para anuncios.  Si
quiere  ser  notificado  sobre  nuevos lanzamientos, complementos de Hollywood,
actualizaciones y todo lo relacionado con el ecosistema de Hollywood no dude en
suscribirse a través del portal oficial http://www.hollywood-mal.com/

Los usuarios de Alemania podrían querer echar una ojeada a la página "Hollywood
User  Page"  mantenida  por  Helmut  Haake.  Ofrece multitud de código fuente y
talleres,  así  como  un  foro en que el plantear sus preguntas.  Aquí tiene el
enlace:

            https://forum.amiga-resistance.info/viewforum.php?f=38


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Forum"}

@ENDNODE
@REMARK =======================================================================
@NODE Contact "Guía de Hollywood: Contacto *UPD10*"

@{b}Contacto@{ub}

Si necesita contactar conmigo, por favor, puede escribirsme por correo-e a:

  andreas\@airsoftsoftwair.de

O utilizar el formulario de contacto existente en:

  http://www.hollywood-mal.com/

                                                           @{">> Versión original" LINK "HollywoodEN.guide/Contact"}

@ENDNODE
@REMARK =======================================================================
@NODE Package "Guía de Hollywood: Generalidades *UPD10*"

@{b}Generalidades@{ub}

Aquí  tiene  un resumen de los componentes más importantes que ha de de conocer
cuando programe con Hollywood:

@{u}Intérprete@{uu}

El ejecutable principal de Hollywood es lo que llamamos "el intérprete":  Puede
leer  los  ficheros  de código fuente (los guiones) y traducirlos al formato de
código-octeto  propio  que utiliza Hollywood.  También puede compilar su código
fuente  en  ejecutables  autónomos  o  miniaplicaciones e incrustar ficheros de
datos  en  ellos.   Una  vez compilado su código fuente ya sea en ejecutalbes o
miniaplicaciones,  puede  distribuirlas:   Si  distribuye  sus  proyectos  como
miniaplicaciones,  sus  usuarios primero tendrán que instalar el reproductor de
Hollywood  disponible  gratuitamente  antes  de  poder  ejecutarlos.   Si elige
distribuir  sus  proyectos  como  ejecutables  autónomos, no se necesitarán más
componentes.   El  intérprete  es  un  programa  de consola y no tiene interfaz
gráfica  alguna.   Los  programas  GUI de Hollywood y la interfaz de desarrollo
integrada  para Windows simplemente ejecutarán el intérprete cuando usted elija
ejecutar un guión.

@{u}Reproductor@{uu}

El  reproductor  de  Hollywood  sólo  puede ejecutar miniaplicaciones (consulte
líneas  más  adelante):   No  puede  ejecutar código fuente.  El reproductor no
forma  parte  de  la  distribución comercial de Hollywood, pero está disponible
como  descarga  gratuita  en el portal oficial en http://www.hollywood-mal.com.
En    oposición   al   intérprete,   el   reproductor   se   puede   distribuir
libre/gratuitamente.   Si  elige distribuir sus proyectos como miniaplicaciones
de  Hollywood,  sus  usuarios  primero  tendrán  que  descargar  e  instalar el
reproductor  para  poder  ejecutarlos.   Si elige distribuir sus proyectos como
ejecutables  autónomos, el reproductor no será necesario ya que está incrustado
en su ejecutable.  Tenga en cuenta que el reproductor de Hollywood para Android
no está disponible en el portal de Hollywood, sino en la tienda Google Play:

  http://play.google.com/store/apps/details?id=com.airsoftsoftwair.hollywood

@{u}GUI@{uu}

Puesto que el intérprete de Hollywood es simplemente un programa de consola, se
acompaña   de  un  programa  separado  llamado  GUI  que  le  permite  utilizar
convenientemente  el  intérprete.   Bajo  Windows,  la  interfaz  gráfica es en
realidad  un  entorno  de  desarrollo integrado, mientras que en otros sistemas
(Amiga,  Linux,  macOS)  es únicamente una fachada para ejecutar y compilar los
guiones,  no  permitiendo  modificarlos,  por lo que en estas plataformas ha de
utilizar  su editor de textos favorito para este menester.  Sin embargo, puesto
que el intérprete es un programa de consola, es bastante fácil integrarlo en su
entorno de desarrollo integrado favorito.

@{u}Guiones@{uu}

El  código  fuente en el lenguaje Hollywood se llama guión (de Hollywood).  Los
guiones  son  simples  ficheros de texto con la extensión HWS, que contienen un
número  de  sentencias  que Hollywood puede entender y que se ajustan a ciertas
reglas  sintácticas  que  se  explican en esta documentación.  Se recomienda la
codificación UTF-8 para todos sus guiones.

@{u}Miniaplicaciones@{uu}

Las  miniaplicaciones de Hollywood son ficheros binarios con extensión HWA, que
contienen  el  código-octeto de un guión, así como datos adicionales que pueden
ser  imágenes,  sonidos,  tipos  de  impresión, etcétera.  Las miniaplicaciones
pueden  ejecutarse  tanto desde el reproductor de Hollywood como del intérprete
de  Hollywood.   La  elección de distribuir su proyecto como una miniaplicación
puede  ahorrar  gran  cantidad  de  espacio en disco duro, puesto que éstas son
normalmente  muy  pequeñas  al  no  incluir cada una de ellas el reproductor de
Hollywood incrustado.  Consulte la sección @{"Miniaplicaciones" LINK Applets} para los detalles.

@{u}Complementos@{uu}

En  todos  los  sistema  excepto  bajo  AmigaOS  y  sistemas  compatibles,  los
complementos  han  de  almacenarse  en  un directorio llamado "Plugins", que se
encuentra  en el mismo directorio que el programa principal de Hollywood.  Bajo
AmigaOS  y  sistemas compatibles,  sin  embargo, éstos  han de  instalarse,  en
"LIBS:Hollywood".  Bajo macOS, el directorio "Plugins" ha de encontrarse dentro
del  directorio  de  recursos  "Resources" del paquete de aplicación, es decir,
dentro  del directorio "HollywoodInterpreter.app/Contents/Resources".  Tenga en
cuenta  que  HollywoodInterpreter.app  está  almacenado  dentro  del paquete de
aplicación  Hollywood.app  mismo,  llamado  "Hollywood.app/Contents/Resources".
Cuando  se  distribuye  un  programa  compilado con Hollywood, los complementos
exigidos  por  su  programa simplemente han de colocarse en el mismo directorio
que  éste.   Cuando compile paquetes de aplicación para macOS, los complementos
han  de  colocarse  en  el  directorio  de  recursos "Resources" del paquete de
aplicación,  es decir, en "MiProyecto.app/Contents/Resources"; como alternativa
puede  incrustar  dichos  complementos en sus ejecutables.  Los complementos de
Hollywood,  como  ficheros,  utilizan  la  extensión  HWP.  Consulte la sección
@{"Complementos" LINK Plugins} para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Package"}

@ENDNODE
@REMARK =======================================================================
@NODE GUI "Guía de Hollywood: GUI *UPD10*"

@{b}GUI@{ub}

El propio Hollywood es un programa de consola, pero por razones de conveniencia
se  suministra  también  con una interfaz gráfica como fachada de dicha consola
que puede ser utilizada para controlarlo sin tener que recurrir a ésta.

Aquí tiene una instantánea de dicha interfaz en los sistemas Amiga:

  Imagen: @{"guiamiga.png" LINK "Guide/guiamiga.png/MAIN"}

El  programa  bajo  Linux  y macOS es completamente idéntico al de Amiga.  Como
puede ver está dividido en tres partes:  Un visualizador de listas que contiene
todos  los  proyectos  disponibles  en  Hollywood,  una esquina informativa que
muestra  información  sobre  el  proyecto de Hollywood actualmente seleccionado
junto a una instantánea gráfica de éste (si está disponible) y, por último, una
colección  de  botones  que  sirven  para  ejecutar  la mayoría de las acciones
estándares de Hollywood.

Aquí tiene una instantánea de dicho programa bajo Linux:

  Imagen: @{"guilinux.png" LINK "Guide/guilinux.png/MAIN"}

Una  vez  puesto  en  marcha,  Hollywood  explorará  automáticamente  el  cajón
de  ejemplos "Examples" ubicado dentro del directorio de instalación del propio
programa y añadirá todos los guiones que encuentre en las diferentes categorías
(puede  utilizar  el  artilugio de selección¹  para cambiar de una a otra).  La
última  categoría  siempre  será  la  llamada  "Mis  proyectos":   Los  guiones
mostrados en ésta no deberían almacenarse dentro del cajón "Examples", para que
no se pierdan cuando se actualice el programa a una versión más reciente.

Aquí tiene una instantánea de dicha interfaz bajo macOS:

  Imagen: @{"guimacos.png" LINK "Guide/guimacos.png/MAIN"}

Éstas son las funciones disponibles en la interfaz gráfica:

  @{b}[Código fuente]@{ub}

  Presione  este  botón  para  ver  el  código  fuente del proyecto actualmente
  seleccionado  de  Hollywood.  Puede configurar el visor a utilizar en el menú
  "Ajustes".

  @{b}[Olvidar]@{ub}

  Olvida   la   selección  actual  (o  sea,  el  proyecto  seleccionado  en  el
  visualizador  de  listas  "Maletín  de  ejemplos"  o  "Mis  ejemplos" deja de
  estarlo).   Esto  es necesario si quiere ejecutar un proyecto que no aparezca
  en una de los dos visualizadores de listas disponibles, porque en caso de que
  no  haya  proyecto  seleccionado al presionar el botón [Ejecutar] se mostrará
  una  petición  de  ficheros solicitándole un guión de Hollywood.  Así, que si
  desea que dicha petición aparezca, deberá utilizar este botón.

  @{b}[Añadir]@{ub}

  Este  botón  sólo  aparecerá  activo  si  la  categoría "Mis proyectos" es la
  elegida  con  el  artilugio de selección¹.  En este caso, puede utilizar este
  botón para añadir un nuevo proyecto al visualizador de listas de la categoría
  "Mis proyectos".

  @{b}[Borrar]@{ub}

  Este  botón  sólo  aparecerá  activo  si  la  categoría "Mis proyectos" es la
  elegida  en  el  artilugio  de selección¹.  En este caso, puede utilizar este
  botón para quitar un proyecto del visualizador de listas de la categoría "Mis
  proyectos".

  @{b}[Modificar]@{ub}

  Este  botón  sólo  aparecerá  activo  si  la  categoría "Mis proyectos" es la
  elegida  en  el  artilugio  de  selección.  En este caso, puede utilizar este
  botón  para  abrir abrir el proyecto actualmente seleccionado en su editor de
  texto  favorito.   Puede  configurar el editor de texto a utilizar en el menú
  "Ajustes"  del  programa.   Si  quiere modificar las propiedades del proyecto
  actualmente   seleccionado,   diríjase  a  la  opción  de  menú  "Proyecto  >
  Propiedades".

  @{b}[Ejecutar]@{ub}

  Presione  este  botón para ejecutar el proyecto actualmente seleccionado.  Si
  no hubiese ninguno, este botón abrirá una petición de ficheros para que elija
  un proyecto.

  @{b}[Compilar]@{ub}

  Puede  usar este botón para compilar un guión de Hollywood (o sea, generar un
  programa  ejecutable  o  una  miniaplicación de Hollywood).  Se le pedirá que
  elija  un  guión  de  Hollywood así como el fichero de salida y la plataforma
  destinataria.  Esta interfaz gráfica invocará al compilador de Hollywood para
  que  construya  su ejecutable o miniaplicación.  Consulte, para más detalles,
  la sección sobre @{"la compilación de ejecutables" LINK Compiler}.

  @{b}[Videograbadora]@{ub}

  Este  botón le permite generar un video a partir de un proyecto de Hollywood.
  Se le pedirá que elija un guión de Hollywood, así como un fichero de salida y
  un  formato  de  video.   Esta interfaz gráfica  invocará a la videograbadora
  para  crear  un  video  de su guión.  Consulte, para más detalles, la sección
  sobre @{"guardar guiones como ficheros de video" LINK VideoRecorder}.

  @{b}[Complementos]@{ub}

  Presione  este  botón  para  que  se  le  muestre  todos  los complementos de
  Hollywood  actualmente  disponibles  en su sistema y alguna información sobre
  ellos.

  @{b}[Ayuda]@{ub}

  Presione este botón para acceder a esta documentación que está leyendo.

  @{b}[Sobre]@{ub}

  Le  muestra  información  sobre los derechos de autor y licencia así como una
  visión general de todos los comandos disponibles en Hollywood.

  @{b}[Salir]@{ub}

  Cierra este programa GUI.

Hay además algunas opciones más en el lado derecho:

  @{b}Modo de visualización@{ub}

  Este  artilugio de selección¹ le permite elegir el modo de visualización para
  el  proyecto.   Puede elegir visualizarlo en una ventana, pantalla completa o
  pantalla completa (redimensionada).  Si elige la opción de pantalla completa,
  el  monitor  cambiará  su  resolución  física  por  la  resolución del guión,
  mientras  que  con  la  opción  de  pantalla  completa  (redimensionada),  se
  preservará  la  resolución física del monitor y simplemente se redimensionará
  el guión para que se ajuste a la resolución del monitor.

  @{b}Factor de la escala@{ub}

  Puede  utilizar  este  artilugio  de selección¹  para  activar  el  motor  de
  redimensionado automático de Hollywood.  Si elige un ajuste diferente al 100%
  para  su  guión, éste será redimensionado automáticamente al factor de escala
  seleccionado.  Consulte,  para más detalles, la sección sobre @{"los motores de" LINK AutoScalingInfo}
  @{"redimensionado" LINK AutoScalingInfo}.

  @{b}Tamaño ajustable@{ub}

  Hollywood  se  abrirá  en  modo  redimensionable si activa esta casilla:  Eso
  permitirá  al usuario poder cambiar el tamaño de (la caja de) la ventana para
  modificar las dimensiones de la visualización de su guión.  Deje esta casilla
  sin marcar si no desea que ocurra.

  @{b}Redimensionado con suavizado@{ub}

  Si  se  permite  el  redimensionado  de  la visualización puede utilizar esta
  casilla  para  definir  si  ha  de  aplicarse  suavizado  o  no  a  éste.  El
  redimensionado con suavizado tiene mejor aspecto, pero es más lento.

                                    --==--

              ¹ Nota del traductor: Debido a que con esta versión
              se ofrece el programa GUI en múltiples plataformas,
           algunos términos típicos de la plataforma Amiga han sido
            sustituidos por el autor por expresiones más genéricas.
                     En este caso concreto se ha pasado de
                  "botón cíclico" a "artilugio de selección".


                                                           @{">> Versión original" LINK "HollywoodEN.guide/GUI"}

@ENDNODE
@REMARK =======================================================================
@NODE IDE "Guía de Hollywood: Entorno de desarrollo integrado para Windows *UPD10*"

@{b}Entorno de desarrollo integrado para Windows@{ub}

En la plataforma Windows,  Hollywood ofrece  un entorno de desarrollo integrado
que  puede  utilizarse  para  crear proyectos de Hollywood muy fácilmente.  Las
prestaciones  de  este entorno son un editor de texto multipestaña con sintaxis
resaltada,  ayuda  en tiempo real mientras se teclea, un navegador de funciones
así  como una conveniente vista general de los datos externos referenciados por
los  comandos  del  preprocesador  utilizados  en  su  guión.   Aquí  tiene una
instantánea de dicho entorno de Hollywood para Windows:

  Imagen: @{"windowside.png" LINK "Guide/windowside.png/MAIN"}

Como puede ver el entorno dispone de seis partes diferentes:

  1. En  la  parte  superior izquierda del entorno integrado de desarrollo está
     la  vista  arborescente  del gestor  de  proyecto.  Está  dividido  en los
     árboles "@{b}Examples@{ub}", que es donde se muestran todos los ejemplos entregados
     con  Hollywood,  y  "@{b}My  projects@{ub}",  bajo  el  cual se mostrarán todos sus
     proyectos.   Para  añadir  ítems  al  árbol  "@{b}My  projects@{ub}", basta con que
     presione  el  botón  @{b}[Add]@{ub}  localizado  bajo  la vista arborescente.  Para
     eliminar un ítem de "@{b}My projects@{ub}", utilice el botón @{b}[Remove]@{ub}.

  2. En  el  lado  inferior izquierdo del entorno integrado de desarrollo puede
     encontrar  la esquina informativa  denominada "@{b}Info corner@{ub}".  Esta sección
     muestra  cierta  información  sobre  el  proyecto  actualmente  activo  de
     Hollywood.   Por  ahora, sólo está operativa para los proyectos de ejemplo
     que  vienen  incluidos  con  Hollywood.   Si selecciona uno de sus propios
     proyectos, esta área no mostrará nada.

  3. El editor constituye el corazón de la interfaz y está ubicado en el centro
     de ésta.  El editor mostrará automáticamente la ayuda en tiempo real en la
     barra  de estado si se detecta que está tecleando  un comando de Hollywood
     conocido. También se resaltarán todas las palabras claves y comentarios  y
     añadirán automáticamente  los  nombres  de  las  funciones al navegador de
     funciones  (más  información, más adelante).  Si presiona el botón derecho
     con  el  puntero  del  ratón  sobre  el  área de edición aparecerá un menú
     contextual  que  le  permitirá  saltar  a  la  definición  de  la  función
     actualmente  seleccionada  por  el  cursor  o  abrir  el  fichero que está
     actualmente  seleccionado  por el cursor.  También puede disponer de ayuda
     sensible al contexto con este método.

  4. En  el  lado  superior  derecho  del entorno integrado de desarrollo puede
     encontrar  el  navegador de funciones.  Esta lista contiene los nombres de
     todas  las  funciones  que  han sido declaradas en el proyecto actualmente
     activo.   Presione con el puntero del ratón doblemente y con rapidez sobre
     una  de  las  entradas  de  esta  lista  y  saltará  automáticamente  a la
     declaración de la función.

  5. En  el  lado  inferior derecho del entorno integrado de desarrollo está la
     herramienta  de  comandos  del preprocesador.  En la primera pestaña puede
     configurar múltiples atributos del comando del preprocesador @{"@DISPLAY" LINK atDISPLAY} que
     controla   la   apariencia  de  su  visualización.   Puede,  por  ejemplo,
     especificar  la  posición  inicial  de la visualización en la pantalla del
     escritorio,  si  debe  abrirse  o  no en modo de pantalla completa o si la
     visualización  ha  de  tener  un borde y un tirador de (cambio de) tamaño.
     También  puede  definir  el  título  de la visualización (por defecto será
     "Hollywood").   Naturalmente, también puede configurar todos los atributos
     directamente  en  el  editor  traspasándolos  directamente  al comando del
     preprocesador @{"@DISPLAY" LINK atDISPLAY}.   De hecho, cuando usted modifica estos atributos
     utilizando  esta  herramienta  de  comandos  del  preprocesador,  la línea
     correspondiente que contiene la especificación de @{"@DISPLAY" LINK atDISPLAY} en su guión se
     actualizará  inmediatamente.   Si no existiese, la herramienta de comandos
     del  preprocesador  la  añadiría  a  su guión.  Las demás pestañas en esta
     herramienta  contienen  listas  que  muestran  todos los ficheros externos
     referenciados por el guión actualmente activo.  Si presiona con el puntero
     sobre uno de estos ficheros, el entorno de desarrollo integrado saltará al
     lugar donde el fichero ha sido desclarado en su guión.  Si presiona con el
     puntero  doblemente  y  con  rapidez sobre uno de los ficheros, el entorno
     integrado de desarrollo abrirá Hollywood para mostrar el fichero.

  6. Al  pie  del entorno integrado de desarrollo puede encontrar la ventana de
     salida  de  Hollywood.   Cuando el entorno integrado de desarrollo pone en
     marcha  a  Hollywood,  la  salida  de éste será redirigida a esta ventana.
     También puede imprimir esta ventana desde su guión de Hollywood utilizando
     el  comando   @{"DebugPrint()" LINK DebugPrint}.   Puede  limpiar  esta  ventana  borrando  su
     contenido,  si  abre  el  menú contextual con el botón derecho del ratón y
     selecciona el ítem de menú "@{b}Clear@{ub}".

La  mayoría de los elementos constituyentes del entorno integrado de desarrollo
presentados  líneas  atrás  han  sido  implementados  como  dársenas¹,  un tipo
especial   de  ventana.   Esto  significa  que  puede  reajustarlos  según  sus
preferencias  personales:   Puede arrastrar estas ventanas a un lugar diferente
dentro  de  la  ventana  del  entorno  integrado  de desarrollo o incluso puede
moverlas  fuera  de ella.  En este caso, aparecerán como cajas de herramientas,
otro  tipo  especial  de  ventana.   Finalmente, puede también ocultarlas si no
necesita  su funcionalidad.  Para ocultar una de estas ventanas, puede utilizar
el  ítem de menú "View" o arrastrar las dársenas fuera de la ventana y entonces
cerrar las cajas de herramientas en las que se han convertido.

El  entorno  de desarrollo integrado puede ser controlado ya sea a través de la
barra  de  herramientas  que  aparece  en  la  parte  superior  de la ventana o
utilizando  el menú.  También existen atajos de teclado que puede utilizar.  La
ayuda  en  tiempo  real se mostrará en la barra de estado cuando el puntero del
ratón  se  encuentre sobre una barra de herramientas o un ítem del menú.  Puede
utilizar  la  barra de herramientas y el menú para ejecutar el proyecto actual,
compilarlo, grabarlo como un video o enviarlo a su impresora.  Además, multitud
de  funciones  estándares son accesibles a través de la barra de herramientas y
el menú como "@{b}Save@{ub}" (Guardar), "@{b}Save as@{ub}" (Guardar como), "@{b}Find@{ub}" (Buscar), "@{b}Find@{ub}
@{b}and  replace@{ub}"  (Buscar  y reemplazar), "@{b}Copy@{ub}" (Copiar), "@{b}Paste@{ub}" (Pegar), "@{b}Undo@{ub}"
(Deshacer), "@{b}Redo@{ub}" (Rehacer), etcétera.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

El  entorno  de  desarrollo  integrado también puede ser controlado a través de
atajos de teclado.  Aquí tiene los más comunes:

  * F1

    Abre  la ayuda sensible al contexto para la función/palabra clave en la que
    se encuentra el cursor actualmente.

  * F2

    Salta  a  la  declaración  de  la  función en la que se encuentra el cursor
    actualmente.

  * F4

    Abre el fichero en cuyo nombre se encuentra el cursor actualmente.

  * F5

    Ejecuta el proyecto actual a través de Hollywood.

  * Ctrl-F

    Abre  la  ventana de búsqueda para localizar una cadena dentro del proyecto
    actual.

  * Ctrl-G

    Salta a la línea especificada dentro del proyecto.

  * Ctrl-S

    Guarda el proyecto actual.


  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

Multitud  de  ajustes del entorno de desarrollo integrado son configurables por
el  usuario.  Elija el ítem "@{b}IDE settings...@{ub}" dentro del menú "@{b}File@{ub}" para abrir
la ventana que le permitirá configurar los ajustes según sus gustos personales.
La  ventana  de  ajustes  consiste  en  cuatro  páginas:   "@{b}General@{ub}", "@{b}Editor@{ub}",
"@{b}Hollywood@{ub}" y "@{b}Custom@{ub}".

Aquí tiene una instantánea de la primera pagina:

  Imagen:  @{"windowside_general.png" LINK "Guide/windowside_general.png/MAIN"}

y esta primera página puede configurar:

  * Syntax highlighting

    Active esta opción para que se destacar la sintaxis en el editor de guiones
    del entorno integrado de desarrollo.  Normalmente esta opción debería estar
    activada  porque hace que su código sea mucho más legible.  En sistemas muy
    lentos  o si trabaja con guiones extremadamente largos podría ser necesario
    desactivarla por cuestiones de rendimiento.

  * Enable function and preprocessor command scanner

    Si   activa  esta  opción,  el  entorno  integrado  de  desarrollo  añadirá
    automáticamente  todos  los  nombres  de  las  funciones  al  navegador  de
    funciones,  y  añadirá todos los ficheros referenciados a la herramienta de
    comandos del preprocesador.  Esto sólo es útil desactivarlo en sistemas muy
    lentos o con guiones muy grandes.

  * Enable display style configuration

    Si esta opción  está activada  será capaz de configurar  los parámetros del
    comando  del preprocesador  @{"@DISPLAY" LINK atDISPLAY}  utilizando  la  herramienta  de  los
    comandos del preprocesador situada en la parte inferior derecha del entorno
    integrado  de  desarrollo.   Si no quiere que esto sea así, deje la casilla
    sin marcar.

  * Auto spelling adaptation

    Esta opción le permite configurar cuando el entorno integrado de desarrollo
    ha  de  adaptar  automáticamente  cómo  se escriben los comandos y palabras
    clave  que  conoce.   Por  ejemplo, si teclea "waitleftmouse" y esta opción
    está activada, la forma en que se ha escrito será automáticamente corregida
    y sustituída por "WaitLeftMouse".

  * Auto indent

    Si  activa  esta  opción,  el  entorno  integrado  de  desarrollo  sangrará
    automáticamente  el  código  tras  sentencias que inicien un nuevo ámbito o
    nivel  en  el código (por ejemplo con "If", "While", "Function", etcétera).
    El  sangrado  se  realizará insertando caracteres de tabulación en la nueva
    línea.    Es  muy  útil  para  la  legibilidad  del  código  y  no  debería
    desactivarse.

  * Always save before Run

    Si  activa  esta  opción,  se  guardará  su proyecto actual automáticamente
    cuando  lo  ejecute.   Tenga  cuidado  con esta opción porque podría perder
    cambios importantes.

  * Always save before Compile

    Si  activa  esta  opción,  se  guardará  su proyecto actual automáticamente
    cuando lo compile generando un ejecutable.

  * Remember open files

    Si  activa  esta opción, el entorno integrado de desarrollo recordará todas
    las pestañas que estaban abiertas en la sesión previa a la actual.

  * Show toolbar

    Puede  utilizar  esta  opción  para hacer que la barra de herramientas esté
    visible o no.

  * Show info corner

    Puede  utilizar  esta  opción  para  hacer  que la esquina informativa esté
    visible o no.

  * Convert spaces to tabs during loading

    Esta  opción  le  permite  configurar  cuando  quiere que los espacios sean
    convertidos  o  no  en caracteres de tabulación antes de la carga:  Es útil
    porque  es  mucho más fácil estructurar su código utilizando tabuladores en
    lugar de espacios, pero tenga cuidado porque podría destruir la maquetación
    de  su  código si la equivalencia entre tabuladores y espacios es diferente
    entre  el entorno de desarrollo integrado y otros editores de texto.  Puede
    configurar este aspecto en la página "@{b}Editor@{ub}".

  * Keep help window on top

    Si  activa  esta opción, la ventana de ayuda de Hollywood aparecerá siempre
    sobre las demás ventanas que conforman el entorno de desarrollo integrado.

  * Language

    Esta  opción  le  permite  cambiar  el  idioma  utilizado por el entorno de
    desarrollo  integrado.   Tendrá que reiniciar el entorno para que el cambio
    se haga efectivo.

  * Save format

    Aquí  puede  definir  el  formato de salida de su guión.  Normalmente, éste
    debería  ser  UTF-8  con  o  sin BOM.  El formato ISO 8859-1 ya no debe ser
    utilizado puesto que puede aparejar problemas de compatibilidad en sistemas
    con un idioma (sistema local) diferente.

  * Restore defaults

    Utilice  este  botón  para reiniciar todos los ajustes de esta página a sus
    valores por defecto.

Aquí tiene una instantánea de la segunda página:

  Imagen: @{"windowside_editor.png" LINK "Guide/windowside_editor.png/MAIN"}

y en ella puede configurar la apariencia del editor:

  * Colors

    Puede  utilizar  estos  botones  para ajustar los colores utilizados por el
    editor, según sus propios gustos, para resaltar la sintaxis del código.

  * Font

    Aquí puede especificar el tipo de impresión utilizado por el editor:  Ha de
    utilizar  uno  monoespacionado  (anchura  fija),  o  en  caso  contrario la
    maquetación  será  un  desastre  al  no  poder alinearse verticalmente unos
    caracteres sobre otros.

  * Console font

    El tipo de impresión que aquí utilice se usará en la ventana de la consola:
    Puede utilizar tanto un tipo monoespecaciado como uno proporcional.

  * Tab size

    Aquí ha de especificar el ancho del carácter de tabulación utilizado por el
    editor  (en  otras  palabras,  un carácter de tabulación a cuantos espacios
    corresponde).  Puede elegir entre 2, 4, 6 y 8 espacios.

  * Restore defaults

    Utilice  este  botón  para reiniciar todos los ajustes de esta página a sus
    valores por defecto.

Aquí tiene una instantánea de la tercera página:

  Imagen: @{"windowside_hollywood.png" LINK "Guide/windowside_hollywood.png/MAIN"}

y en ella podrá configurar la interfaz de Hollywood:

  * Hollywood path

    En  este  campo  ha  de definirse la ruta de acceso a Hollywood:  Cuando el
    entorno  de  desarrollo invoque a Hollywood, buscará en la ruta señalada en
    este  campo.   Normalmente,  Hollywood reside en el mismo directorio que el
    ejecutable del entorno de desarrollo integrado..

  * Options for running scripts

    La  plantilla  especificada  en  este  campo es utilizada por el entorno de
    desarrollo  para  ejecutar  un  guión  de  Hollywood:  Normalmente, no debe
    cambiar  nada  en  dicho  campo.  Consulte el siguiente punto para saber el
    formato de dicha plantilla.

  * Options for compiling scripts

    La  plantilla  especificada  en  este  campo es utilizada por el entorno de
    desarrollo  para  compilar  los guiones de Hollywood.  Normalmente, no debe
    cambiar nada en dicho campo.

    Esta  plantilla,  así  como  la anterior para ejecutar guiones, admiten los
    siguientes distintivos que tienen un significado especial:

      %HWPATH

      Se reemplazará por la ruta de acceso al ejecutable de Hollywood.

      %SCRIPT

      Define el guión de Hollywood que ha de ser compilado.

      %IDEWINDOW

      Inserta el manejador de la ventana del entorno integrado de desarrollo.

      %OUTEXE

      Indica el fichero de destino que el compilador ha de crear.

      %EXEPLATFORM:

      Indica la(s) plataforma(s) de destino al compilador.

  * Use Hollywood for media display

    Active  esta opción si desea que el entorno de desarrollo utilice Hollywood
    para   mostrar  cualquier  fichero  de  medios  externos  como  imágenes  y
    animaciones.   Es  recomendable activarla porque Hollywood soporta formatos
    exóticos como el IFF ILBM y los módulos de Protracker que no son soportados
    por  los  visualizadores de medios estándares que trae el sistema operativo
    Windows.

  * Restore defaults

    Utilice  este  botón  para reiniciar todos los ajustes de esta página a sus
    valores por defecto.

Aquí tiene una instantánea de la cuarta página:

  Imagen: @{"windowside_custom.png" LINK "Guide/windowside_custom.png/MAIN"}

y en ella puede añadir palabras claves adicionales definidas por usted para que
sean  resaltadas  por  el  editor.  Por favor, tenga en cuenta que las palabras
clave  han  de comenzar siempre por un carácter alfabético o un guión bajo "_":
Pueden  contener  números,  pero NO como primer carácter; los únicos caracteres
especiales  permitidos  son  el  guión  bajo  ya  citado,  el símbolo del dólar
estadounidense "$" y el de cierre de exclamación "!".  Sólo puede definirse una
palabra clave por línea.

                                    --==--

      ¹ Nota del traductor: En algunos textos, podría encontrar traducido
                    el término inglés @{i}dock@{ui} como "botonera",
              un término que el DRAE actualmente no reconoce con
                 este significado, o banco/panel (de botones).


                                                           @{">> Versión original" LINK "HollywoodEN.guide/IDE"}

@ENDNODE
@REMARK =======================================================================
@NODE MobilePlatforms "Guía de Hollywood: Plataformas móviles *UPD10*"

@{b}Plataformas móviles@{ub}

Hollywood  también está disponible tan sólo como reproductor para Android e iOS
lo  que  le  permite  ejecutar  sus  miniaplicaciones de Hollywood en teléfonos
inteligentes y tabletas.  Este reproductor para Android exige la versión 4.0 de
dicho sistema y se ofrece gratuitamente en la tienda @{u}Google Play@{uu} en este URL:

  http://play.google.com/store/apps/details?id=com.airsoftsoftwair.hollywood

Desafortunadamente, el reproductor para iOS actuamente no está disponible en la
tienda  @{u}App Store@{uu}, debido a que sus capacidades parecen entrar en conflicto con
las normas que la rigen.

Aquí tiene imágenes del reproductor para Android (izquierda) e iOS (derecha):

  Imagen: @{"mobile.png" LINK "Guide/mobile.png/MAIN"}

Si  quiere ejecutar sus proyectos de Hollywood en su dispositivo móvil, primero
ha  de  compilarlos  como miniaplicaciones, copiarlos en su dispositivo y luego
ejecutarlos utilizando el reproductor citado para su plataforma móvil.

Otra  opción  alternativa,  es utilizar el compilador complementario "Hollywood
APK  Compiler"  (compilador  APK para Hollywood) que le permitirá convertir sus
proyectos  en paquetes APK autónomos para Android:  Por favor, visite el portal
de Hollywood para más información en la dirección http://www.hollywood-mal.com/

Si  quiere utilizar el reproductor gratuito de Hollywood, lea la siguiente guía
"paso a paso" para disponer de sus proyectos en su dispositivo móvil:

  1. Compile  su proyecto  de Hollywood  como una miniaplicación (*.hwa) con el
     programa  @{u}GUI@{uu}  de  Hollywood o con @{fg highlight}Hollywood Designer@{fg text}  o desde la línea de
     comandos.

  2. En  sistemas Android:  Copie el fichero *.hwa en el directorio "Hollywood"
     ubicado  en  la  tarjeta SD de su dispositivo Android.  Este directorio se
     crea automáticamente cuando pone en marcha por primera vez Hollywood en su
     dispositivo.   Si no existe, créelo por su cuenta en el directorio raíz de
     dicha tarjeta SD.

     En  sistemas  iOS:   Utilice  iTunes  para  copiar  el fichero *.hwa en el
     directorio de documentos de la aplicación (=el reproductor).

  3. Si  su miniaplicación no carga ningún fichero externo y todos los ficheros
     de datos necesarios están incrustados, salte hasta el sexto punto de estas
     instrucciones.

  4. Si  su miniaplicación  carga ficheros externos, cree un directorio para su
     miniaplicación  dentro  del directorio "Hollywood" (bajo Android) o dentro
     del  directorio  de documentos de la aplicación (bajo iOS) ya citado en el
     segundo punto.   El  nombre  del  directorio  ha  de ser idéntico al de su
     miniaplicación,  salvo  por  la  extensión  de  ésta.   Por ejemplo, si su
     miniaplicación   se  llama  "Mi alucinante juego.hwa",   deberá  crear  el
     directorio  "Mi alucinante juego"  dentro del directorio  de "Hollywood" o
     del directorio de documentos.

  5. Copie  todos  los  ficheros  de datos exigidos por su miniaplicación en el
     nuevo directorio que ha creado.

  6. Ejecute el reproductor en su dispositivo:  Mostrará una lista de todas las
     miniaplicaciones  que  ha  encontrado.  Elija su miniaplicación y toque el
     botón  de  ejecución/reproducción  en  la  barra  de  control  en la parte
     inferior de la pantalla.

  7. ¡Ahora su miniaplicación debería ponerse en marcha!

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨

Otra  opción  también  disponible  bajo  Android es copiar la miniaplicación de
Hollywood  en  una  ubicación  arbitraria  de su tarjeta SD y ponerla en marcha
ejecutando  simplemente  el  fichero  *.hwa  directamente  desde  su  gestor de
ficheros  favorito.  En este caso todos los ficheros externos referenciados por
la miniaplicación se cargarán desde la ubicación relativa a la carpeta donde se
encuentre  ubicado el fichero "*.hwa".  Hollywood no cambiará el directorio por
un  subdirectorio  como  por el otro método en el caso de que la miniaplicación
haya sido colocada fuera de la carpeta "/sdcard/Hollywood".

Puede  configurar algunas opciones pulsando el botón @{b}[Options]@{ub}.  La pantalla de
opciones tiene un aspecto como éste en Android (izquierda) e iOS (derecha):

  Imagen: @{"mobile2.png" LINK "Guide/mobile2.png/MAIN"}

Las siguientes opciones están disponibles actualmente:

  * Full screen (auto scale)

    Ejecuta  el  guión  en  el modo de pantalla completa utilizando el motor de
    redimensionado  automático.  Es la forma recomendada para asegurarse de que
    los  guiones  diseñados para resoluciones diferentes cubran la totalidad de
    la  pantalla  de  su  dispositivo  móvil.  Sin embargo, si su guión utiliza
    capas y gráficos vectoriales debería utilizar el motor de redimensionado de
    capa  en lugar de preferir obtener gráficos nítidos en cualquier resolución
    (consulte el siguiente apartado).

  * Full screen (layer scale)

    Ejecuta  el  guión  en  el modo de pantalla completa utilizando el motor de
    redimensionado  de  capa  y como es lógico, sólo se soporta con guiones que
    utilicen  capas.   Es  más lento que el motor de redimensionado automático,
    pero  puede llegar a generar gráficos nítidos en cualquier resolución si su
    guión  utiliza  únicamente  gráficos  vectoriales.   Para  guiones  que  no
    utilizan  las  capas,  ha de utilizar el motor de redimensionado automático
    (consulte líneas más atrás).  Tenga en cuenta que también puede utilizar el
    motor  de  redimensionado  automático  con guiones que utilicen capas, pero
    entonces  la  calidad no será tan buena como con el motor de redimensionado
    de capa si su guión utiliza gráficos vectoriales.  Éste es el motivo por el
    que  se  recomienda  utilizar  el  motor de redimensionado de capa sólo con
    guiones  que  usen capas y gráficos vectoriales.  Para guiones que utilicen
    capas   y   gráficos  de  mapa  de  bits,  debería  utilizar  el  motor  de
    redimensionado automático, ya que es más rápido.

  * Interpolate

    Utiliza   el  suavizado  por  interpolación  cuando  se  redimensionan  las
    imágenes.   Se  recomienda  para obtener unos gráficos más suaves con menos
    "artefactos" visuales debido al redimensionado.

  * Hide action bar

    Oculta  la  barra de acción de Android.  Se recomienda para los guiones que
    no  necesitan  ninguna  interacción  del  usuario  a través de las opciones
    disponibles en dicha barra de acción.

  * Hide status bar

    Oculta  la barra de estado bajo iOS, si hay una.  Activando esta opción, se
    obtendrá una visualización de pantalla completa.

  * Hide options menu

    Impide  los  cambios  en  la configuración de la visualización a través del
    menú  de opciones en la barra de acción.  Si activa esta opción, el menú de
    opciones  no será visible en la barra de acción.  Esto sólo se soporta bajo
    Android:   Bajo  iOS,  Hollywood no soporta la modificación de las opciones
    mientras se ejecuta un guión.

  * Keep screen on

    Fuerza al dispositivo móvil a mantener la pantalla encendida incluso cuando
    no  hay actividad del usuario.  Normalmente los dispositivos móviles entran
    en  el  modo  de  ahorro  energético  tras  transcurrir  cierto  tiempo  de
    inactividad.  Activando esta opción se desactiva este comportamiento.

  * No sound

    Active esta opción para poner en marcha Hollywood en modo silencioso.

Consulte @{"los argumentos de la consola" LINK ManualUsage} para información más detallada sobre las
opciones citadas líneas atrás.

Las  versiones móviles  de  Hollywood tienen ciertas prestaciones especiales en
comparación  con las versiones de sobremesa.  Aquí tiene una relación de dichas
prestaciones para Android e iOS:

  1. Bajo  Android  e iOS, Hollywood incluye soporte nativo de los formatos Ogg
     Vorbis  y  Ogg  Theora,  de manera que no necesita ningún complemento para
     acceder  a  estos  formatos  de fichero.  Se ejecutarán fuera de Hollywood
     bajo Android e iOS.

  2. Dispone  de  un teclado virtual utilizando las funciones @{"ShowKeyboard()" LINK ShowKeyboard} y
     @{"HideKeyboard()" LINK HideKeyboard}.    También   puede  atender   al   manejador  de  eventos
     "HideKeyboard"  para detectar cuando el usuario cierra el teclado virtual.
     Consulte @{"InstallEventHandler()" LINK InstallEventHandler} para más detalles.

  3. Puede  atender  al  manejador de eventos "OrientationChange" para detectar
     cuando  el usuario  rota  el dispositivo.  Consulte @{"InstallEventHandler()" LINK InstallEventHandler}
     para más detalles.

  4. También  puede programar una orientación forzada  para su guión utilizando
     la etiqueta  "Orientation" que es soportada por @{"@DISPLAY" LINK atDISPLAY}.  Eso conservará
     el  modo  de  orientación  que  especifique  en  dicha etiqueta.  Consulte
     @{"@DISPLAY" LINK atDISPLAY} para los detalles.

  5. Bajo  Android,  también puede cambiar entre la opción de pantalla completa
     o no, utilizando el menú de opciones en la barra de acción.

Naturalmente  hay  algunas  limitaciones en las versiones móviles de Hollywood.
La más destacable frente a las versiones de sobremesa, es que la versión de iOS
no  soporta  visualizaciones  múltiples, sólo se soporta únicamente una, ni las
visualizaciones  pueden  utilizar menús.  Tampoco es posible cambiar el puntero
del  ratón ya que bajo Android e iOS éste no suele existir.  Tampoco se soporta
el  uso  de  imágenes  de  fondo  transparentes  ni la etiqueta "Desktop" en el
comando del preprocesador @{"@DISPLAY" LINK atDISPLAY}.

Aquí  tiene  una  lista  de comandos que actualmente no están soportados en las
versiones móviles de Hollywood:

  - ActivateDisplay()            [sólo no se se soporta bajo iOS]
  - ChangeDisplayMode()          [sólo no se se soporta bajo iOS]
  - CloseDisplay()               [sólo no se se soporta bajo iOS]
  - CreatePointer()
  - CreatePort()
  - DebugPrompt()
  - FontRequest()
  - FreePointer()
  - GetEnv()
  - GetFileArgument()
  - GetRawArguments()
  - HideDisplay()                [sólo no se se soporta bajo iOS]
  - HidePointer()
  - MovePointer()
  - OpenDisplay()                [sólo no se se soporta bajo iOS]
  - SelectDisplay()              [sólo no se se soporta bajo iOS]
  - SendMessage()
  - SetPointer()
  - SetEnv()
  - ShowDisplay()                [sólo no se se soporta bajo iOS]
  - ShowPointer()
  - UnsetEnv()

Hay  también  algunas  funciones que son exclusivas de las versiones móviles de
Hollywood.  Aquí tiene una lista de dichas funciones:

  - CallJavaMethod()     [sólo Android]
  - GetAsset()           [sólo Android]
  - HideKeyboard()
  - ImageRequest()       [sólo Android]
  - PerformSelector()    [sólo iOS]
  - PermissionRequest()  [sólo Android]
  - ShowKeyboard()
  - ShowToast()
  - Vibrate()            [sólo Android]

La  versión Android de Hollywood también soporta los complementos de Hollywood.
Ha  de  copiarlos  en  el  directorio  "Hollywood/Plugins"  de  su tarjeta  SD:
Hollywood  explorará  dicha ubicación cada vez que se ponga en marcha y cargará
todos  los  complementos  allí  disponibles.   La versión de Hollywood para iOS
actuamente no soporta complementos.

Si su guión se ejecuta de forma extremadamente lenta bajo una plataforma móvil,
entonces  necesita  cambiar  la  técnica de generar los gráficos:  Refrescar la
pantalla  puede  ser  bastante  gravoso  en cuanto a recursos en un dispositivo
móvil  y  es  el motivo por el que debe intentar minimizar la frecuencia de los
refrescos  de la pantalla.  La mejor forma de hacerlo es utilizar la técnica de
doble tampón  cuando genere gráficos utilizando @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer} y @{"Flip()" LINK Flip}.
Lo  que  ralentiza  el  motor gráfico en los sistemas móviles son las múltiples
operaciones  de  dibujo  que  afectan sólo a pequeñas áreas.  Por ello, debería
intentar  combinar  todas las operaciones de generación de gráficos posibles en
un único paso.  Un doble tampón es la mejor solución para este problema:  Si no
puede  utilizarlo  por alguna razón (por ejemplo, porque utiliza duendecillos o
capas),  encapsule  todos los comandos de dibujo necesarios en un única sección
iniciada  por @{"BeginRefresh()" LINK BeginRefresh}  y  terminada  por @{"EndRefresh()" LINK EndRefresh}...  esto debería
mejorar   mucho   los   resultados   en  los  dispositivos  móviles.   Consulte
@{"BeginRefresh()" LINK BeginRefresh} para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/MobilePlatforms"}

@ENDNODE
@REMARK =======================================================================
@NODE ConsoleUsers "Guía de Hollywood: Modo de consola *UPD10*"

@{b}Modo de consola@{ub}

Actualmente,  las interfaces gráficas del usuario ofrecidas para Amiga, Linux y
macOS,  así  como la interfaz de desarrollo integrado ofrecida para Windows son
sólo  fachadas  para  interactuar  con  el  intérprete  de  Hollywood que es un
programa  de  consola,  así  que  también  puede  ser  utilizado  desde  ésta y
naturalmente  puede  desaarrollar  programas para ésta pues Hollywood tiene una
extensa  biblioteca  especializada.

Aquí  tiene  un  resumen  de  cómo  encontrar  el  intérprete de Hollywood para
ejecutarlo desde la consola...

 - AmigaOS y compatibles:

   El  intérprete Hollywood lo encontrará en el directorio "Hollywood:System/".
   Puesto que el guión instalador de Hollywood añade la ruta "Hollywood:System"
   a la ruta de búsqueda del sistema, puede poner en marcha el intérprete desde
   la consola tecleando únicamente "Hollywood".

 - Linux:

   Aquí el intérprete se llama simplemente "Interpreter" y puede encontrarse en
   el  directorio  raíz de su instalación de Hollywood.  Hay también un fichero
   llamado  "Hollywood" en ese directorio, pero sólo es la interfaz gráfica que
   actúa como fachada del intérprete.

 - macOS:

   Aquí  el intérprete se encuentra en el directorio "Contents/Resources" de la
   aplicación "Hollywood.app", almacenándose en su propio paquete de aplicación
   que  se  llama  "HollywodInterpreter.app".   Para ponerlo en marcha desde la
   consola ha de hacer algo como esto:

   cd Hollywood.app/Contents/Resources
   ./HollywoodInterpreter.app/Contents/MacOS/Hollywood prueba.hws

 - Windows:

   Aquí  las  cosas  son un poco más complicadas porque Windows distingue entre
   programas  los  programas  que  son  de  consola y los que no lo son, lo que
   implica  que  hay  dos  variantes  del  intérprete, una para consola llamada
   "Hollywood_Console.exe"   y   otra   para   la   interfaz   gráfica  llamada
   "Hollywood.exe".   Ambas  puede  encontrarlas  en  el  directorio  donde  ha
   instalado Hollywood, que habitualmente será "C:/Program Files/Hollywood".

   La  interfaz  de  desarrollo  integrado  de  Hollywood  siempre utilizará la
   versión  de  Hollywood  para la interfaz gráfica, es decir, "Hollywood.exe".
   Si  quisiera  disponer  de una salida de consola desde Hollywood, necesitará
   utilizar  la  versión  de  consola,  es  decir  "Hollywood_Interpreter.exe",
   pudiendo  ponerla  manualmente  en  marcha  desde  una  consola  de  Windows
   tecleando lo siguiente:

   cd "C:/Program Files/Hollywood"
   Hollywood_Console.exe prueba.hws

   Conocer  la diferencia entre ambas versiones es importante cuando distribuya
   su aplicación:  Puesto que Windows diferencia entre los programas que son de
   consola y los que no lo son, Hollywood también puede compilar ejecutables de
   los  dos  tipos.   Si  quiere  compilar un programa de consola para Windows,
   deberá suministrar el argumento @{"-consolemode" LINK ManualUsage} al compilador, ya sea desde la
   consola  o  añadiendo  manualmente  dicho  argumento  para  la  interfaz  de
   desarrollo  integrado  o la configuración GUI de Hollywood, puesto que estas
   dos últimas interfaces gráficas actualmente no lo soportan directamente.

   Tenga  en  cuenta  también  que  incluso los programas que no son de consola
   pueden abrir una consola bajo Windows, utilizando la función @{"OpenConsole()" LINK OpenConsole}.

Una  vez  que  sepa  cómo  poner  en marcha a Hollywood desde la consola, puede
solicitar  que  se  imprima  una  lista  de  todas  las  opciones  disoponibles
suministrándole el argumento -help. Bajo Windows vendría a ser algo como esto:

cd "C:/Program Files/Hollywood"
Hollywood_Console.exe -help

Bajo Linux sería algo así:

cd <directorio-de-instalación-de-Hollywood>
./Interpreter -help

Bajo macOS así:

cd /Applications/Hollywood.app/Contents/Resources
./HollywoodInterpreter.app/Contents/MacOS/Hollywood -help

Y bajo AmigaOS y compatibles algo así:

Hollywood -help

Con  este  argumento  se imprimirá una lista que comprenda todos los argumentos
disponibles  para la consola:  Consulte la sección de @{"argumentos de la consola" LINK ManualUsage}
para  los  detalles.   Si  omite  el  argumento  "-help",  Hollywood abrirá una
petición  de  ficheros  pidiéndole  que seleccione un guión o miniaplicación de
Hollywood a ejecutar.

Si  quiere  poner en marcha un guión de Hollywood desde la consola, tendría que
usar los siguientes comandos bajo Windows:

cd "C:/Program Files/Hollywood"
Hollywood_Console.exe miguion.hws

De forma similar se haría en las demás plataformas (vea líneas más atrás).

Es  importante  que  recuerde  que  TODAS  las  prestaciones de Hollywood están
disponibles  desde la consola, ya que las interfaces gráficas de Hollywood para
Windows,  Amiga,  Linux y macOS son meras interfaces que hacen uso del programa
principal  basado  en  la  consola.  Por ejemplo, aquí tiene un ejemplo de cómo
pedir  a  Hollywood  que  compile  el  programa "prueba.hws" para AmigaOS3 bajo
Linux:

cd <directorio-de-instalación-de-Hollywood>
./Interpreter prueba.hws -compile ~/MiPrueba_AmigaOS3 -exetype classic

Consulte  la  sección  de  @{"los argumentos  de  la consola" LINK ManualUsage} para una descripción
detallada de todos los parámetros de la línea de comandos.

Tenga  en  cuenta  que  bajo  AmigaOS  y  sistemas compatibles, la ubicación de
Hollywood  se  añadirá  automáticamente  a  la  ruta  del  sistema  durante  la
instalación,  gracias  a  lo  cual,  bastará  con  que teclee "Hollywood" en la
consola  y  éste se pondrá en marcha, sin importar dónde se encuentre instalado
el programa.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/ConsoleUsers"}

@ENDNODE
@REMARK *====================================================================*
@NODE ManualUsage "Guía de Hollywood: Argumentos de consola *UPD10*"

@{b}Argumentos de la consola@{ub}

Si  no  quiere utilizar el programa @{u}GUI@{uu} por alguna razón, puede poner en marcha
Hollywood  desde  la  consola.   Cuando  lo  haga desde ésta sin argumentos, se
abrirá   una  petición  de  ficheros  pidiéndole  que  elija  un  guión  o  una
miniaplicación  a  ejecutar.   Para  disponer  de  una  lista de los argumentos
soportados,  ejecute  Hollywood  utilizando  el argumento "-help".  La sintaxis
para el uso de Hollywood es la siguiente:

  Hollywood fichero.hws [-alldisplays] [-askdisplaymode]
                        [-audiodevice <nombre>] [-autofullscreen] [-autoscale]
                        [-backfill <tipo>] [-borderless] [-brush <id>]
                        [-brushfile <fichero>]
                        [-compile <fichero>] [-compress]
                        [-consolemode] [-cxkey <atajo>]
                        [-debugoutput] [-depth <profundidad>]
                        [-disableblanker] [-dpiaware]
                        [-encoding <codificación>]
                        [-endcolor <color>] [-exetype <tipo>]
                        [-exportcommands <fichero>]
                        [-exportconstants <fichero>] [-exporthelpstrings]
                        [-exportplugins <fichero>] [-exportpreprocs <fichero>]
                        [-fakefullscreen] [-fixed] [-fitscale] [-forceflush]
                        [-forcesound] [-formaterror]
                        [-fullscreen] [-fullscreenscale]
                        [-globalplugins]
                        [-help] [-hideoptionsmenu]
                        [-hidepointer] [-hidetitlebar]
                        [-icon16x16 <fichero>] [-icon24x24 <fichero>]
                        [-icon32x32 <fichero>] [-icon48x48 <fichero>]
                        [-icon64x64 <fichero>] [-icon96x96 <fichero>]
                        [-icon128x128 <fichero>] [-icon256x256 <fichero>]
                        [-icon512x512 <fichero>] [-icon1024x1024 <fichero>]
                        [-keepproportions] [-keepscreenon]
                        [-layerfullscreen] [-layerscale]
                        [-legacyaudio] [-linkfiles <fichero>]
                        [-linkfonts <fichero>] [-linkplugins <lista>]
                        [-locksettings]
                        [-mastervolume <volumen>] [-maximized]
                        [-moderequester] [-monitor <n>]
                        [-nativeunits] [-nobackfill] [-nochrdir]
                        [-nocommodity] [-nodebug] [-nodocky]
                        [-nohardwarescale] [-nokeepproportions]
                        [-nohide] [-nolegacyaudio] [-noliveresize]
                        [-nomodeswitch] [-nomousehook] [-noscaleengine]
                        [-noscaleswitch] [-nosmoothscale]
                        [-nosound] [-nostyleoverride] [-numchannels <canales>]
                        [-overrideplacement] [-overwrite]
                        [-pictrans <transparencia>] [-picxpos <x>]
                        [-picypos <y>] [-printerror]
                        [-pubscreen <nombre>]
                        [-quiet]
                        [-requireplugins <lista>] [-requiretags <etiquetas>]
                        [-resourcemonitor]
                        [-scalefactor <factor>]
                        [-scalepicture] [-scaleswitch]
                        [-scalewidth <anchura>] [-scaleheight <altura>]
                        [-scrwidth <anchura>] [-scrheight <altura>]
                        [-setconstants <lista>] [-sizeable]
                        [-skipplugins <máscara>] [-smoothscale] [-softtimer]
                        [-softwarerenderer]
                        [-startcolor <color>] [-stayactive] [-systemscale]
                        [-tempdirpath <ruta>]
                        [-usequartz] [-usewpa]
                        [-videofps <fps>] [-videoout <fichero>] [-videopointer]
                        [-videoquality <calidad>] [-videostrategy <estrategia>]
                        [-vsync]
                        [-window] [-winwidth <anchura>] [-winheight <altura>]
                        [-wpamode <modo>]
                        [-xserver <nombre>]

@{b}Información  importante:@{ub}  La mayoría de estos argumentos son soportados también
por cualquier programa compilado por Hollywood.  Si no quiere que sus programas
compilados soporten los argumentos de la consola, deberá compilarlos utilizando
el argumento "-locksettings" (consulte más adelante para una descripción).

@{b}Segunda  información importante@{ub}:  La mayoría de los argumentos mostrados líneas
atrás  también  pueden ser suministrados  a los programas creados con Hollywood
sin  utilizar la consola.  Puede encontrar una descripción de este mecanismo en
la sección sobre @{"los argumentos sin la consola" LINK ConsoleEmulation}.

Aquí tiene las descripciones detalladas para cada comando:

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -alldisplays

  Por  defecto,  los  argumentos  de  la línea de comandos como "-borderless" o
  "-sizeable"  sólo  afectarán  a  la  primera visualización de Hollywood.  Sin
  embargo,  si  añade  este  parámetro, todos estos argumentos que controlan el
  estilo de visualización se aplicarán a todas las visualizaciones.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -askdisplaymode

  Si  especifica  este  argumento, Hollywood abrirá una petición emergente para
  que  el usuario seleccione cuando el guión ha de mostrarse en modo de ventana
  o de pantalla completa.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -audiodevice <nombre>                                       [Sólo para Linux]

  Este  argumento  puede  usarse para especificar el dispositivo de sonido ALSA
  como  la salida de sonido.  Sólo necesita usar este argumento para definir un
  dispositivo de sonido diferente  al marcado  por defecto, así que normalmente
  no lo utilizará.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -autofullscreen

  Este  argumento hará que la visualización sea en el modo de pantalla completa
  utilizando  el  motor  de  redimensionado  automático  en lugar de cambiar la
  resolución del monitor, pero sólo cuando Hollywood se ejecute en sistemas que
  soporten  el  redimensionado  acelerado  por  la  GPU  (unidad  de  procesado
  gráfico).   En  todas  las demás plataformas se utilizará un modo de pantalla
  completa  normal, es decir, Hollywood cambiará la resolución del monitor para
  que  encaje  en  las dimensiones de la visualización actual.  Actualmente, el
  redimensionado  acelerado  por  GPU se soporta bajo Windows, macOS, Android e
  iOS  lo  que  significa  que  en  estas  plataformas  no  habrá cambios en la
  resolución  del  monitor,  sino  que Hollywood simplemente redimensionará los
  gráficos  para  que  encajen  en  las  dimensiones  del monitor actual.  Bajo
  AmigaOS  y compatibles, así como bajo Linux, sin embargo, aún sí se producirá
  el  cambio  de  la  resolución del monitor con este modo al no soportar estas
  plataformas el redimensionado acelerado por la GPU.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -autoscale

  Si  especifica  este argumento, el motor de redimensionado se activará.  Esto
  significa  que su guión puede visualizarse en cualquier resolución que defina
  de  forma  completamente  automática  (no  necesita  realizar  cambios  en su
  código).  Si el modo de redimensionado está activado, Hollywood intentará que
  su  guión  se  ejecute  en la resolución habitual, pero en realidad aumentará
  o reducirá la escala dependiendo de la resolución elegida.  Puede especificar
  la resolución inicial  utilizando  los argumentos "-scalewith" para anchura y
  "-scaleheight"  para  la  altura  o "-scalefactor" para el factor de escala o
  "-scalesystem"  para  usar  la escala del sistema anfitrión.  Esta resolución
  puede ser modificada por el usuario en cualquier momento, cambiando el tamaño
  de la ventana de Hollywood (no olvide permitir que se pueda cambiar el tamaño
  de  su ventana  utilizando  el  comando  del  preprocesador  @{"@DISPLAY" LINK atDISPLAY}  o  el
  argumento   "-sizeable").    Si   no   especifica   los   argumentos  citados
  "-scalewidth",  "-scaleheight", "-scalefactor" o "-scalesystem" al ponerlo en
  marcha, el guión arrancará sin el redimensionado automático, pero se activará
  tan  pronto  como  el  usuario  cambie el tamaño de la ventana.  Si lo quiere
  además  con  suavizado  (más  lento), especifique el argumento "-smothscale".
  Hollywood  soporta  otro  motor  de  redimensionado  automático que puede ser
  activado  especificando  el  argumento  "-layerscale",  del  que  tendrá  más
  información  líneas más adelante.  Consulte, para más información, la sección
  sobre @{"los motores de redimensionado" LINK AutoScalingInfo}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -backfill <tipo>

  Este  argumento  le  permite especificar  el tipo de fondo de relleno para la
  visualización   de   Hollywood.   Si  especifica  este  argumento,  Hollywood
  rellenará la pantalla completa. El parámetro <tipo> sólo puede ser una de las
  siguientes palabras clave:

    @{u}color@{uu}

    Rellena  el  fondo  con  el  color  especificado  a  través  del  argumento
    "-startcolor".

    @{u}picture@{uu}

    Muestra la brocha especificada a través del argumento "-brush"/"-brushfile"
    como   imagen  de fondo (centrada);  si  también  especifica  el  argumento
    "-startcolor",  el  fondo se limpiará con este color; si también especifica
    el argumento "-endcolor", el fondo se limpiará con un gradiente comprendido
    entre "-startcolor" y "-endcolor".

    @{u}gradient@{uu}

    Muestra  un gradiente como fondo (con un fundido o gradación desde el color
    especificado por el argumento "-startcolor" hasta el color especificado por
    el argumento "-endcolor").

    @{u}texture@{uu}

    Muestra la brocha especificada a través del argumento "-brush"/"-brushfile"
    como una textura.

  Como puede ver, todos los tipos de relleno exigen un argumento adicional como
  parámetro:    Ha   de  especificar  los  argumentos  "-brush",  "-brushfile",
  "-startcolor"  y  "-endcolor"  adicionalmente y  según los casos (tal como se
  indica líneas atrás).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -borderless

  Si  especifica  este  argumento, Hollywood abrirá una ventana sin bordes.  Es
  especialmente útil para ventanas transparentes.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -brush <id(entificador)>

  Sólo  se necesita cuando se utiliza el argumento "-backfill" con las palabras
  clave  "texture"  o  "picture".   Especifica  el identificador de la brocha a
  utilizar  en  el  modo  de fondo de relleno.  Puede usar también el argumento
  "-brushfile"  en lugar de éste  (si quiere usar  una brocha  para el fondo de
  relleno que no ha sido declarada dentro de su guión).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -brushfile <fichero>

  Sólo  se necesita cuando se utilice el argumento "-backfill" con las palabras
  clave  "texture" o "picture".  Especifique el nombre del fichero que contiene
  la  brocha a utilizar en el modo de relleno del fondo.  Puede usar también el
  argumento "-brush" en lugar de éste.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -compile <fichero>

  Si  especifica  este  argumento,  Hollywood  compilará  su guión generando un
  ejecutable  autónomo y guardándose con el nombre <fichero>  (su  guión  NO se
  ejecutará).  Debe usar esta opción si quiere  publicar  su guión.  Utilice el
  argumento "-exetype"  para especificar  la plataforma de destino  para la que
  quiere generar dicho ejecutable.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -compress

  Puede  utilizar  este interruptor para activar la compresión de los proyectos
  de  Hollywood.   Si  especifica  este  argumento,  Hollywood  comprimirá  las
  miniaplicaciones  y  los  ejecutables.  Este argumento sólo se puede utilizar
  junto al argumento "-compile".

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -consolemode                                              [Sólo para Windows]

  Si  especifica  este  argumento,  Hollywood  compilará  un  ejecutable que se
  ejecutará  únicamente  en  el  modo  de  consola bajo Windows, ya que en este
  sistema  operativo  hay  una  distinción entre los programas de consola y los
  programas  propiamente del entorno gráfico Windows.  Tenga en cuenta que este
  argumento sólo funciona cuando se especifica también el argumento -compile.

  Esta opción también está disponible como comando del preprocesador:  Consulte
  @{"@OPTIONS" LINK atOPTIONS} para los detalles.  Consulte también el capítulo
  sobre el @{"modo de consola" LINK ConsoleUsers} para más detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -cxkey <atajo>                                            [Sólo para AmigaOS]

  Este  argumento puede utilizarse para instalar un atajo de teclado específico
  del sistema para su aplicación.  Cuando el usuario presione dicha combinación
  de  teclas, su aplicación recibirá un evento "Hotkey" que puede ser detectado
  a través de la función @{"InstallEventHandler()" LINK InstallEventHandler}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -debugoutput

  Especificando  este argumento se activa la salida de la depuración  para este
  guión:  Este argumento  tiene el mismo efecto  que llamar a @{"DebugOutput()" LINK DebugOutput} al
  inicio de su guión.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -disableblanker

  Este  argumento  puede  utilizarse  para  desactivar el salvapantallas cuando
  Hollywood está ejecutándose.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -dpiaware                                                 [Sólo para Windows]

  Al  trabajar  con  monitores  de  una  gran  densidad de  puntos por pulgada,
  resoluciones  clásicas  como  640x480  píxeles  pueden quedar visualmente muy
  reducidas  si cada punto de la visualización coincide con el punto físico del
  monitor.  Por ello, sólo bajo Windows, se ofrece esta opción de manera que al
  utilizarla  no  se pedirá al sistema operativo redimensionar la visualización
  (lo  que  podría  generar  el problema citado de quedar una visualización muy
  reducida)...   de no usarla se redimensionaría, pero probablemente a costa de
  que  la imagen quede borrosa (el grado de emborronamiento dependerá de cuanta
  diferencia hay entre la resolución original de su guión y la resolución final
  a  la  que  ha  de redimensionarse...  a mayor diferencia, mayor borrosidad).
  Puede  activar esta opción desde su guión con la etiqueta "SystemScale" en el
  comando del preprocesador @{"@OPTIONS" LINK atDISPLAY}:  Consúltelo para más detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -encoding <codificación>

  Este  argumento  puede  utilizarse  para definir la codificación del juego de
  caracteres  del  guión.  El parámetro <codificación>  puede tener  uno de los
  siguientes valores:

    @{u}utf8@{uu}

    El esquema de codificación del juego de caracteres  del guión es UTF-8 (con
    o sin BOM¹).   Es también el valor por defecto y debería usarse siempre que
    sea posible.

    @{u}iso8859_1@{uu}

    El esquema de codificación del juego de caracteres del guión es ISO 8859-1.
    Tenga en cuenta que debido a razones  históricas,  Hollywood  no usará esta
    codificación   bajo   AmigaOS   y   sistemas  compatibles,  aunque  sea  la
    codificación  por defecto del sistema.  "iso8859_1" colocará a Hollywood en
    modo  clásico  y debería hacer que su guión fuese plenamente compatible con
    versiones anteriores a la 7.0 de Hollywood.  Sin embargo, debido a que este
    modo  de codificación tiene multitud de inconvenientes, no se recomienda el
    uso  del  modo  clásico de forma permanente:  En su lugar, debe adaptar los
    guiones para que funciones correctamente en modo Unicode.

  Tenga  en  cuenta que no se recomienda este modo "iso8859_1" ya que Hollywood
  sólo  se  ejecutará  correctamente  en  sistemas  locales compatibles con los
  lenguajes  europeos  occidentales.   Ha  de  utilizar  siempre "utf8", ya que
  coloca  a  Hollywood  en  modo  Unicode  y  se asegura de que Hollywood pueda
  manejar correctamente todos los sistemas locales.

  La   codificación   que  especifique  aquí  se  define  automáticamente  como
  codificación  por defecto  tanto  para la biblioteca de texto como para la de
  cadenas utilizando @{"SetDefaultEncoding()" LINK SetDefaultEncoding}.   Eso  significa  que  todas  estas
  funciones tendrán como predeterminada esta codificación.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -endcolor <color>

  Sólo se necesita  cuando  se utilice  el argumento "-backfill" con la palabra
  clave "gradient".  El parámetro  <color>  es un color @{"RVA" LINK RGBInfo},  como por ejemplo
  $FF0000 para el rojo. En el caso de utilizarlo con la palabra clave "picture"
  se creará un gradiente tras la imagen.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exetype <tipo>

  Sólo  se  necesita cuando se utilice el argumento "-compile".  Este argumento
  especifica  el formato de salida del ejecutable que Hollywood debe crear.  El
  parámetro <tipo> puede ser uno de los siguientes:

    @{u}amigaos4@{uu}      Ejecutable para AmigaOS 4 (PowerPC)
    @{u}android@{uu}       Miniaplicación de Hollywood que incluye
                  las constantes para Android específicas
                  para dicha plataforma (consulte más adelante)
    @{u}aros@{uu}          Ejecutable para AROS (x86)
    @{u}classic@{uu}       Ejecutable para AmigaOS 3.x (68020+)
    @{u}classic881@{uu}    Ejecutable para AmigaOS 3.x
                  que exige disponibilidad de unidad de coma flotante
                  (o sea, 68020+ y 68881/2, o, 68040/68060)
    @{u}ios@{uu}           Miniaplicación de Hollywood que incluye
                  las constante para iOS específicas
                  para dicha plataforma (consulte más adelante)
    @{u}linux@{uu}         Ejecutable para Linux (x86)
    @{u}linux64@{uu}       Ejecutable para Linux (x64)
    @{u}linuxarm@{uu}      Ejecutable para Linux (arm)
    @{u}linuxppc@{uu}      Ejecutable para Linux (PowerPC)
    @{u}macos@{uu}         Paquete de aplicación para macOS (PowerPC)
    @{u}macosarm64@{uu}    Paquete de aplicación para macOS (arm64)
    @{u}macos86@{uu}       Paquete de aplicación para macOS (x86)
    @{u}macos64@{uu}       Paquete de aplicación para macOS (x64)
    @{u}morphos@{uu}       Ejecutable para MorphOS
    @{u}warpos@{uu}        Ejecutable binario mixto para WarpOS (68040/PowerPC)
    @{u}win32@{uu}         Ejecutable para Windows (x86)
    @{U}win64@{UU}         Ejecutable para Windows (x64)
    @{u}applet@{uu}        Miniaplicación universal de Hollywood
                  que puede ser ejecutada en todos los sistemas
                  utilizando un reproductor de Hollywood.

  Por  defecto este argumento está definido como "classic" en la versión 68k de
  Hollywood, como "win32" en la versión de 32 bits de Windows, etcétera.

  Tenga  en  cuenta  que  las  opciones  "applet",  "android" e "ios" generarán
  exactamente  las  mismas miniaplicaciones independientes de la plataforma que
  podrá  ejecutar  en  *cualquier*  plataforma  utilizando  el  reproductor  de
  Hollywood:   La  diferencia  entre  las  tres  opciones citadas es que cuando
  compile  utilizando  las  opciones  "android"  o  "ios",  Hollywood  definirá
  adicionalmente  las constantes respectivas específicas de dichas plataformas,
  es  decir,  #HW_ANDROID  para  Android  y #HW_IOS para iOS, lo que únicamente
  sirve  para  permitir  a  los  guiones  saber para quién han sido compilados:
  Consulte @{"IF" LINK atIF} para los detalles.

  También  puede  compilar para múltiples plataformas de una sola vez.  En este
  caso, puede transferir  el nombre  de varias plataformas  separándolas con la
  barra  vertical "|".   Por  ejemplo,  para compilar "prueba.hws" sólo para el
  AmigaOS 4 y MorphOS, utilice la siguiente línea:

    1> Hollywood prueba.hws -compile prueba -exetype amigaos4|morphos

  Si   especifica   varias   plataformas  de  destino,  el  fichero  de  salida
  especificado  por  el  argumento "-compile"  se utilizará como plantilla y se
  añadirán  las  extensiones  específicas de la plataforma (para el anterior se
  generarían la serie de ejecutables llamados "prueba_OS4" y "prueba_MOS").

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exportcommands <fichero>

  Este  argumento  puede  ser utilizado para exportar una lista de los comandos
  disponibles  al  fichero  especificado.   La  lista  de  comandos disponibles
  aparecerá ordenada por bibliotecas.  Dentro de las secciones de la biblioteca
  las  listas  aparecerán sin ordenar.  Sólo se exportarán los comandos nativos
  de  Hollywood.   Los comandos instalados por los complementos no se mostrarán
  aquí, pero puede obtener éstos con el argumento "-exportplugins". Esta opción
  probablemente  no  sea  de mucho uso por parte de los usuarios normales, pero
  puede ser útil para autores de  entornos de desarrollo integrado  que quieran
  soportar Hollywood.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exportconstants <fichero>

  Este  argumento puede ser utilizado para exportar una lista de las constantes
  (sin  ordenar)  disponibles  al  fichero  especificado.   Sólo las constantes
  nativas de Hollywood serán exportadas.  Las constantes instaladas a través de
  complementos  no se mostrarán aquí, pero puede obtener éstas con el argumento
  "-exportplugins".  Esta opción probablemente no sea de mucho uso por parte de
  los  usuarios  normales,  pero  puede  ser  útil  para autores de entornos de
  desarrollo integrado que quieran soportar Hollywood.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exporthelpstrings

  Si  se  utiliza  este  argumento en conjución con "-exportplugins", Hollywood
  escribirá  tres líneas en lugar de una por cada comando del complemento en el
  fichero especificado en el argumento "-exportplugins".  La primera línea será
  el nombre del comando, la segunda será su texto de ayuda y la tercera será el
  nodo  de  ayuda  en  la documentación que acompaña a dicho complemento.  Esta
  información  es  útil  para los entornos de desarrollo integrado  que quieran
  ofrecer ayuda con los comandos del complemento.  Tenga en cuenta que tanto la
  segunda  como  la  tercera  línea  pueden  estar  vacías si el complemento no
  exporta la cadena o el nodo de ayuda para el comando.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exportplugins <fichero>

  Este   argumento   puede  ser  utilizado  para  exportar  una  lista  de  los
  complementos  disponibles al fichero especificado.  Si un complemento exporta
  comandos  o  constantes,  éstos  se añadirán al fichero de exportación.  Esta
  opción  probablemente no sea de mucho uso por parte de los usuarios normales,
  pero  puede  ser  útil para autores de  entornos de desarrollo integrado  que
  quieran   soportar   Hollywood.    Si   también   especifica   el   argumento
  "-exporthelpstrings" (consulte líneas más atrás), Hollywood exportará también
  los  textos de ayuda y nodos de todos los comandos del complemento.  Consulte
  líneas más atrás para los detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -exportpreprocs <fichero>

  Este  comando  puede  ser  utilizado  para  exportar  una  lista de todos los
  comandos  del preprocesador soportados por Hollywood al fichero especificado:
  La  lista no estará ordenada y los comandos individuales del preprocesador no
  contendrán  el prefijo arroba "@".  Esta opción probablemente no sea de mucho
  uso  por  parte de los usuarios normales, pero puede ser útil para autores de
  entornos de desarrollo integrado que quieran soportar Hollywood.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -fakefullscreen

  Este  argumento  permite  que  Hollywood  utilice  el  modo de falsa pantalla
  completa.  Esto significa que Hollywood se abrirá sobre el escritorio pero la
  ventana  con  fondo de relleno  se configurará  para proteger  el  escritorio
  completamente.   Por  ello el usuario tendrá la impresión de que Hollywood se
  está ejecutando en el modo de pantalla completa, aunque no sea así.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -fitscale

  Este  argumento  sólo se tiene en cuenta cuando están activos "-layerscale" o
  "-autoscale".  En estos casos, "-fitscale" ajustará la escala a la resolución
  de  la  pantalla  actual,  así  que  el  guión  siempre  llenará  la pantalla
  completamente.   Utilizar "-fitscale" es, básicamente, lo mismo que traspasar
  las  dimensiones  actuales  de  la  pantalla  a  través  de  "-scalewidth"  y
  "-scaleheight",  pero como no puede saber la resolución de la pantalla de los
  ordenadores  de  sus  usuarios,  he  aquí  el motivo de la existencia de este
  argumento  (que  justamente hace este trabajo).  Tenga en cuenta que utilizar
  el  argumento  "-fitscale"  podría  distorsionar  la  apariencia de la salida
  visual de su guión en caso de que la resolución de la pantalla actual utilice
  una  relación  de  aspecto (ratio X/Y) diferente a la planeada para su guión.
  Para  prevenir  la  distorsión,  puede  utilizar  junto  a este argumento, el
  argumento  "-keepproportions"  (consulte  más adelante, en esta misma sección
  para más detalles).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -fixed

  Si  especifica  este  argumento,  la  visualización de Hollywood quedará fija
  sobre  la  pantalla,  lo  que significa que no podrá moverla/desplazarla.  Es
  útil cuando Hollywood se abre en el modo de pantalla completa.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -forceflush

  Si especifica  este argumento  forzará el vaciado del tampón  tras cada línea
  que Hollywood escriba  en el dispositivo de depuración.  Sólo es útil  cuando
  dicho dispositivo de depuración  es un fichero o una canalización, ya que las
  consolas ya vacían por sí mismas los tampones tras cada línea.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -forcesound

  Normalmente, cuando un guión intenta reproducir un sonido y la circuitería de
  audio  no está disponible, Hollywood continuará ejecutando el guión, pero sin
  sonido.   Si no quiere que esto suceda así, es decir, si quiere que Hollywood
  fracase  (y  genere  un  error) si no se dispone de la circuitería de sonido,
  utilice este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -formaterror

  Este  argumento le indica a Hollywood que ha de dar formato a los mensajes de
  error  de  una forma determinada y así pueden ser fácilmente distinguibles de
  otras  salidas  de  la  consola.   Tenga en cuenta que este argumento sólo se
  tiene  en  cuenta  cuando la opción -printerror también está activa.  En este
  caso, los errores son mostrados en la consola así:

     \@_hwerror<línea>:<fichero>*<mensaje>

  Tenga  en  cuenta que el campo <fichero> puede estar encerrado entre comillas
  dobles  y  que  puede  estar vacío si el error no es referente al fichero del
  guión (en cuyo caso, <línea> será 0).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -fullscreen

  Este  argumento  ejecutará  Hollywood  en  modo  de  pantalla  completa.   Se
  explorarán  los  modos  de visualización del monitor para determinar la mejor
  resolución  para su guión y se cambiará al modo correspondiente ejecutando el
  guión.   Si  quiere ejecutar su guión en modo de pantalla completa sin que se
  realicen  cambios  en  la  resolución  del  monitor  utilice  en  su lugar el
  argumento "-fullscreenscale" (consulte líneas más adelante).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -fullscreenscale

  Se trata de un modo de pantalla completa especial en el que no se cambiará la
  resolución  de  su  monitor:   En  su  lugar,  la  visualización de Hollywood
  cambiará  de  tamaño  para  adaptarse/caber  en las dimensiones de su monitor
  activándose  el motor de redimensionado automático.  Este argumento utilizará
  dicho  motor  por  defecto:   Si  quiere utilizar el redimensionado por capa,
  tendrá  que  suministrar  simultáneamente  el  argumento  "-layerscale".   El
  argumento  "-fullscreenscale"  es  especialmente útil en dispositivos móviles
  cuya  circuitería  de  visualización  tiene  una resolución programada por la
  fuerza  y  no soporta los cambios de resolución como puede hacerlo un monitor
  externo  conectado  a  un  ordenador  de sobremesa.  El inconveniente de este
  argumento  es que es más lento, porque Hollywood es el encargado de modificar
  los  tamaños  en  todas las operaciones de generación de gráficos para que se
  ajusten a las dimensiones del monitor.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -globalplugins                                                 [Sólo AmigaOS]

  Bajo  AmigaOS  y  sistemas  compatibles,  los complementos también pueden ser
  instalados  globalmente  en "LIBS:Hollywood".  Los ejecutables compilados por
  Hollywood,  sin  embargo,  sólo  cargarán los complementos almacenados con el
  ejecutable  en  su  directorio.   Si  quiere que su ejecutable también cargue
  todos  los complementos de "LIBS:Hollyood", ha de especificar este argumento.
  Alternativamente,  también  puede  definir  "GlobalPlugins"  como  TRUE en el
  comando del preprocesador @{"@OPTIONS" LINK atOPTIONS}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -help

  Imprime una lista de los argumentos soportados por la consola.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -hideoptionsmenu                                               [Sólo Android]

  Cuando  el  usuario  abre  el  menú  de opciones en los dispositivos Android,
  Hollywood  le permitirá configurar múltiples parámetros de visualización como
  activar  o desactivar el motor de redimensionado automático o de capa.  Si no
  quiere ofrecer esa posibilidad al usuario, utilice este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -hidepointer

  Si  especifica  este  argumento,  el  puntero  del  ratón  automáticamente se
  ocultará  tan  pronto  como  Hollywood  entre  en el (falso) modo de pantalla
  completa.  Este argumento tiene la ventaja sobre el comando @{"HidePointer()" LINK HidePointer} en
  que  sólo oculta el puntero en el modo de pantalla completa.  Si Hollywood se
  abre  en  el modo de ventana, el puntero del ratón quedará visible, porque si
  se ocultase causaría habitualmente confusión al usuario.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -hidetitlebar                       [Sólo para AmigaOS, macOS, iOS y Android]

  Este  argumento  oculta  la  barra  de  título de la pantalla anfitriona.  En
  sistemas  de escritorio, este argumento sólo tiene efecto cuando Hollywood se
  abre  en  una  pantalla propia o cuando utilice el argumento "-backfill".  En
  dispositivos  móviles  esta  opción ocultará la barra de estado (iOS) o la de
  acción (Android).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -icon16x16 <fichero>
  -icon24x24 <fichero>
  -icon32x32 <fichero>
  -icon48x48 <fichero>
  -icon64x64 <fichero>
  -icon96x96 <fichero>
  -icon128x128 <fichero>
  -icon256x256 <fichero>
  -icon512x512 <fichero>
  -icon1024x1024 <fichero>

  Todos   estos   argumentos  de  consola  "-iconXXX"  pueden  utilizarse  para
  especificar  los  iconos  de  su  aplicación.   En los sistemas bajo Windows,
  macOS  y  Linux  estos  iconos aparecerán en el borde de la ventana y también
  serán  utilizados  por  ciertos elementos del sistema que maneja las ventanas
  como la barra de tareas de Windows.  Estos iconos se incrustarán en todos los
  ejecutables  o  miniaplicaciones  que  compile con Hollywood.  Por defecto, y
  ante  la  ausencia  de alguno de estos iconos, Hollywood siempre utilizará el
  icono  estándar de Hollywood:  La claqueta.  Si prefiere utilizar en su lugar
  su  propio  icono, puede hacerlo especificando uno o más de estos argumentos.
  Para  conseguir  los  mejores  resultados, debería ofrecer iconos artesanales
  para todos los tamaños.  Hollywood soporta actualmente los siguientes tamaños
  de  icono:   16x16,  24x24,  32x32,  48x48,  64x64, 96x96, 128x128, 256x256 y
  512x512  y  1024x1024.   Sin  embargo,  actualmente  no se soportan todos los
  tamaños  en  todas las plataformas...  a pesar de ello debería suministrarlos
  para  todos  los  tamaños disponibles, pues de no hacerlo y necesitarse dicho
  icono,  Hollywood echaría mano del icono por defecto (la susodicha claqueta).
  Así,  que  si  pretende  utilizar  sus  propios  iconos, asegúrese siempre de
  ofrecerlos  para  todos  los  tamaños.  El fichero con la imagen exigido como
  parámetro  por  estos  argumentos  debería ser una imagen PNG con canal alfa.
  Las  imágenes  sin  dicho  canal  también se soportan, pero no se recomiendan
  porque no se ven demasiado bien.  Alternativamente, también puede utilizar el
  comando del preprocesador @{"@APPICON" LINK atAPPICON} para especificar los iconos a medida para
  su proyecto.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -keepproportions

  Este  argumento  sólo  se  utiliza  cuando  están  activas  las  prestaciones
  puestas  en  marcha por los argumentos "-layerscale" o "-autoscale".  En este
  caso,  este  argumento  impedirá  distorsionar la resolución del guión actual
  cuando el usuario cambie el tamaño de la ventana.  En su lugar, se utilizarán
  bordes  o  franjas  negras  para  rellenar  las  regiones  de  la  ventana no
  proporcionales.   La  propia  visualización  conservará  siempre  el ratio de
  aspecto  (la relación entre la resolución del eje X y el eje Y).  Es muy útil
  para guiones cuya salida visual no debe ser distorsionada.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -keepscreenon                                       [Sólo para iOS y Android]

  Si  especifica este argumento, se desactivará el modo de ahorro de batería en
  los  dispositivos móviles.  Esto significa que la pantalla del dispositivo no
  se apagará nunca/oscurecerá para ahorrar energía. Es útil con  presentaciones
  que no exijan la interacción del usuario.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -layerfullscreen

  Este  argumento hará que la visualización sea de pantalla completa utilizando
  el  motor  de  redimensionado  de capas en lugar de cambiar la resolución del
  monitor,  pero  sólo  cuando  Hollywood se ejecute en sistemas que soporte el
  redimensionado  acelerado  por  GPU.   En  todas  las  demás  plataformas  se
  utilizará un modo de pantalla completa normal (s decir, Hollywood cambiará la
  resolución  del  monitor  para que las dimensiones de la visualización actual
  encajen).   Actualmente  el redimensionado acelerado por GPU es soportado por
  Windows,  macOS,  Android  e  iOS,  de  manera que en estas plataformas no se
  cambiará  la  resolución del monitor y se optará por el redimensionado.  Bajo
  AmigaOS  y  compatibles,  así como bajo Linux, sin embargo, sí se cambiará la
  resolución del monitor al no soportarse este tipo de redimensionado.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -layerscale

  Si especifica este argumento, el motor de redimensionado de capa se activará.
  Esto significa que su guión podrá ser visualizado en cualquier resolución que
  defina  y  funcionará  de  forma  totalmente  automática (no tendrá que hacer
  cambios  en su código).  Sin embargo, como su propio nombre implica, el motor
  de  redimensionado de capa sólo funcionará SI @{"las capas están activadas" LINK EnableLayers}.  En
  el  modo  de  redimensionado  de  la  capa,  todas  las  capas  se  adaptarán
  automáticamente  a la nueva resolución y Hollywood intentará hacer creer a su
  guión que se ejecuta en su resolución  original para  asegurarse  de  que  se
  ejecuta exactamente igual que si  no  estuviera  activado.   La  ventaja  del
  redimensionado  de  capa es que las capas vectoriales (por ejemplo primitivas
  gráficas,  texto  con  tipos  TrueType, brochas y animaciones vectoriales) se
  redimensionarán  en  el  modo vectorial así que no perderá calidad incluso si
  cambia  la  resolución de su guión de 320x240 a 1280x1024.  Puede especificar
  la resolución inicial  de la capa  utilizando  los argumentos "-scalewidth" y
  "-scaleheight"  o  "-scalefactor"  o "-scalesystem" (consulte más adelante en
  esta  sección).   La  resolución  de redimensionado puede ser cambiada por el
  usuario  en  cualquier momento cambiando el tamaño de la ventana de Hollywood
  (no olvide  permitir esto utilizando el comando del preprocesador @{"@DISPLAY" LINK atDISPLAY} o
  el  argumento  "-sizeable").  Si no especifica los argumentos "-scalewidth" y
  "-scaleheight"  o  "-scalefactor" o "-scalesystem" en la puesta en marcha, el
  guión  arrancará  sin  el redimensionado de capa, pero se activará tan pronto
  como   el  usuario  cambie  el  tamaño  de  la  ventana.   Si  desea  que  el
  redimensionado   de  capa  incluya  suavizado  (más  lento),  especifique  el
  argumento "-smoothscale".  Hollywood soporta otro motor de redimensionado que
  puede  ser  activado  especificando  el  argumento "-autoscale" (consulte más
  atrás en esta misma sección).  Encontrará más información sobre ambos motores
  en la sección sobre @{"los motores de redimensionado" LINK AutoScalingInfo}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -legacyaudio                                                   [Sólo AmigaOS]

  A  partir de la versión 6.0 de Hollywood, las versiones de este lenguaje para
  AmigaOS incluyen un nuevo gestor de sonido.  El viejo gestor aún se soporta y
  puede  ser activado especificando este argumento.  Por favor, tenga en cuenta
  que bajo Amiga OS 3.x el viejo gestor se activa por defecto por cuestiones de
  rendimiento,  así  que  si  desea  utilizar  el  nuevo bajo dicha versión del
  sistema operativo, tendrá que suministrar el argumento "-nolegacyaudio".

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -linkfiles <fichero>

  Este  argumento  sólo  es procesado cuando se especifica también el argumento
  "-compile".   Puede  utilizar  este  argumento  para incrustar ficheros en su
  miniaplicación  o  ejecutable,  como  alternativa  al uso de los comandos del
  preprocesador  equivalentes.   Alternativamente,  también  puede  utilizar el
  comando  del preprocesador  @{"@LINKER" LINK atLINKER} para especificar una lista de ficheros a
  incrustar   en   su   miniaplicación   e  ejecutable.   Consulte  la  sección
  @{"Incrustación de ficheros de datos" LINK LinkingData} para los detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -linkfonts <fichero>

  Este  argumento  sólo  es procesado cuando se especifica también el argumento
  "-compile".   Puede utilizar este argumento para incrustar tipos de impresión
  en su miniaplicación o ejecutable.  Su guión cargará entonces automáticamente
  estos  tipos  desde  su  miniaplicación  o  ejecutable  cuando  usted llame a
  @{"SetFont()" LINK SetFont}.  Utilizar el argumento "-linkfonts" es una alternativa a utilizar
  el  comando  del  preprocesador @{"@FONT" LINK atFONT} para incrustar tipos de impresión a su
  miniaplicación o ejecutable.  Normalmente, el uso de @{"@FONT" LINK atFONT} debería ser mucho
  más  sencillo  que  utilizar  el  argumento "-linkfonts", así que este último
  debería  utilizarlo sólo por buenas razones.  Alternativamente, también puede
  utilizar  el comando del preprocesador @{"@LINKER" LINK atLINKER} para especificar una lista de
  tipos de impresión a incrustar en su miniaplicación e ejecutable. Consulte la
  sección @{"Incrustación de tipos de impresión" LINK LinkingFonts} para los detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -linkplugins <lista>

  Este  argumento  sólo  es procesado cuando se especifica también el argumento
  "-compile".   Puede utilizar este argumento para incrustar complementos en su
  ejecutable:    Su   ejecutable   cargará   entonces   automáticamente   estos
  complementos durante su puesta en marcha, teniendo todo contenido en un único
  fichero,  no  siendo  ya  necesario  almacenar o instalar los complementos de
  forma externa  que pudiera necesitar.  Tenga en cuenta que estos complementos
  sólo  pueden ser incrustados en los ejecutables y NO en las miniaplicaciones,
  puesto   que  estas  últimas  son  independientes  de  la  plataforma  y  los
  complementos  no.  Ha de suministrar una lista de los complementos que tienen
  que  incrustarse en su ejecutable como argumento.  Si quiere incrustar más de
  un  complemento,  sepárelos  utilizando  la barra vertical "|".  Por ejemplo,
  para  incrustar  en su guión los complementos "cplmt1.hwp" y "cplmt2.hwp", ha
  de especificar como argumento "cplmt1|cplmt2".  Asegúrese de leer con cuidado
  las  licencias (documentos legales) de todos los complementos que incruste en
  su  ejecutable  porque  licencias  como  la LGPL le afectarán si los incrusta
  estáticamente.   Tenga  en  cuenta  que  antes  de  utilizar  este  argumento
  "-linkplugins",  primero  tendrá  que  definir  las  infraestructuras para la
  incrustación   de   complementos:    Consulte   la  sección @{"Incrustación  de" LINK LinkingPlugins}
  @{"complementos" LINK LinkingPlugins} para los detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -locksettings

  Este  argumento  sólo  es procesado cuando se especifica también el argumento
  "-compile".   Puede  utilizar  este argumento  para  corregir  los ajustes de
  visualización  de  su  guión.   Normalmente, cuando compila un ejecutable con
  Hollywood,  el  usuario  será  capaz  de  cambiar  su  apariencia a través de
  argumentos  añadidos  al  ejecutable  como "-borderless" o "-fullscreen".  El
  usuario  también  podría  cambiar  los  ajustes  del  relleno  del  fondo del
  ejecutable especificando "-backfill", etcétera.  Por defecto,  se ofrece toda
  la flexibilidad  posible al usuario  para ajustar  el programa  a sus deseos.
  Podría  también  activar  un  motor de redimensionado o hacer que su programa
  pueda  cambiar  de  tamaño  la  ventana.   Si  no quiere que el usuario pueda
  cambiar sus ajustes de visualización, entonces ha de compilar sus ejecutables
  utilizando  con  el argumento "-locksettings".  Si se utiliza este argumento,
  Hollywood  siempre  utilizará  los ajustes especificados en su guión a través
  del   comando   del  preprocesador @{"@DISPLAY" LINK atDISPLAY}.   Por  ejemplo,  si  especifica
  "Mode=FullScreen"  en el comando  @{"@DISPLAY" LINK atDISPLAY}  de su guión  y lo compila con el
  argumento  "-locksettings", entonces el usuario no podrá ejecutar el programa
  en  el modo de ventana:  Su programa siempre se abrirá en el modo de pantalla
  completa.   Piénselo dos  veces antes de utilizar este argumento porque resta
  flexibilidad a sus programas.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -mastervolume <volumen>                                        [Sólo AmigaOS]

  Este argumento  le  permite  especificar el volumen maestro, o principal, que
  Hollywood usará.  Utilícelo sólo si experimenta distorsiones cuando Hollywood
  reproduce   sonidos.   Normalmente,  no  tendrá  que  utilizarlo  (con  otros
  valores).  El volumen maestro oscila entre un rango de 0 a 64.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -maximized                                                     [Sólo Windows]

  Abre  la visualización en modo maximizado.  Esta visualización debe poder ser
  redimensionable para que este parámetro tenga efecto.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -moderequester

  Si especifica  este  argumento  junto  a  "-fullscreen", Hollywood abrirá una
  petición solicitando al usuario que seleccione la resolución del monitor para
  el modo de pantalla completa y procederá a utilizarla.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -monitor <n>

  Este   argumento   le   permite  especificar  el  monitor  sobre  el  que  la
  visualización  de  su guión ha de abrirse.  El valor del monitor <n> comienza
  con el valor uno que es el que corresponde al monitor primario.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nativeunits

  Si   este  argumento  se  especifica,  Hollywood  utilizará  las  coordenadas
  espaciales del sistema nativo en lugar de los píxeles.  Esto actualmente sólo
  tiene efecto bajo  macOS e iOS porque ambos sistemas operativos utilizan unas
  unidades  propias en lugar de los píxeles cuando se ejecuta en un dispositivo
  Retina.  Por defecto, Hollywood forzará el uso de píxeles en los dispositivos
  iOS  y Macs Retina para mantener la compatibilidad cruzada entre plataformas,
  pero usted podría querrar evitar este ajuste utilizando este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nobackfill                                                    [Sólo AmigaOS]

  Por  defecto,   Hollywood  siempre  utiliza  un  relleno  de  fondo  para  su
  visualización  si  ésta  se abre  en  el modo de pantalla completa:  Si no lo
  quiere,  utilice  esta opción  (en este caso, Hollywood al abrirse en modo de
  pantalla completa  no  protegerá las áreas que no son cubiertas por la propia
  visualización).   Es útil  en los sistemas Amiga si quiere que Hollywood abra
  una nueva ventana sin ocultar elementos visuales de la pantalla como la barra
  de título  de  ésta  o  la  decoración de fondo del usuario.  Si utiliza este
  argumento, puede que quiera utilizar también el argumento "-nostyleoverride".

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nochdir

  Por  defecto, Hollywood siempre convierte el directorio donde reside el guión
  o  miniaplicación que se está ejecutando actualmente en el directorio actual:
  Utilizar  este argumento, evita este comportamiento, o sea, que en este caso,
  Hollywood no cambiaría el directorio actual cuando se ejecute un guión.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nocommodity                                                   [Sólo AmigaOS]

   Bajo  AmigaOS  y sistemas compatibles, este argumento indica a Hollywood que
   no ha de introducirse a sí mismo en la lista del sistema de comodidades.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nodebug

  Si  especifica  este argumento,  los  comandos @{"DebugPrint()" LINK DebugPrint}, @{"DebugPrintNR()" LINK DebugPrintNR},
  @{"Assert()" LINK Assert}, @{"DebugOutput()" LINK DebugOutput} y @{"@WARNING" LINK atWARNING}  se saltarán  cuando se ejecute un guión
  o  miniaplicación.   Esto permite desactivar de forma global las funciones de
  depuración en un único paso.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nodocky                                                     [Sólo AmigaOS 4]

  Bajo  sistema  con  AmigaOS  4, si se especifica este argumento, Hollywood no
  mostrará  la  aplicación en AmiDock.  Esta etiqueta es útil si quisiera tener
  una aplicación invisible que utilice todas las funcionalidades del sistema de
  aplicaciones  como  el mecanismo de mensajes y Ringhio, pero sin que aparezca
  en  AmiDock.   Esta  etiqueta  sólo se reconocerá si "RegisterApplication" ha
  sido definida como TRUE en @{"@OPTIONS" LINK atOPTIONS}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nohardwarescale                                               [Sólo Android]

  Por cuestiones de rendimiento, Hollywood intentará utilizar el redimensionado
  acelerado a través de la circuitería cuando el redimensionado automático está
  activado  en los dispositivos Android por defecto.  Algunos dispositivos, sin
  embargo,  no implementan el redimensionado acelerado adecuadamente así que si
  observa  un  comportamiento  extraño  cuando  use  el  modo de redimensionado
  automático,  intente  desactivar  el  redimensionado acelerado a través de la
  circuitería  utilizando  este  argumento  y verifique si esto le ayuda.  @{u}Esta@{uu}
  @{u}opción  ha  quedado obsoleta con el lanzamiento de Hollywood 8.0 ya que ahora@{uu}
  @{u}siempre se utiliza el redimensionado acelerado a través de la circuitería.@{uu}

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nohide

  Si  especifica  este  argumento,  el  usuario  no  será  capaz  de ocultar la
  visualización  de  Hollywood,  y  así por ejemplo, la ventana de Hollywood no
  tendrá  un  botón para minimizarla.  Este argumento no tiene efecto sobre los
  comandos @{"ShowDisplay()" LINK ShowDisplay}  y @{"HideDisplay()" LINK HideDisplay},  de  manera  que aún podrá usarlos
  para ocultar y mostrar la visualización.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nokeepproportions

  Cuando  el  usuario cambia entre el modo de ventana y el de pantalla completa
  utilizando   la   combinación   de   teclas   CMD+RETORNO  (bajo  Windows  es
  ALTDCHA+RETORNO)   y  Hollyood  elige  redimensionar  la  visualización  para
  adaptarse  a la resolución actual del monitor, éste añadirá bordes de relleno
  si  es necesario para conservar el ratio X/Y (la relación entre ejes).  Si no
  desea esto, suministre este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nolegacyaudio                                                 [Sólo AmigaOS]

  A  partir de la versión 6.0 de Hollywood, las versiones de este lenguaje para
  AmigaOS incluyen un nuevo gestor de sonido, pero que bajo AmigaOS 3.x no está
  activo  por  defecto  debido  a cuestiones de rendimiento.  Si también quiere
  utilizar este nuevo gestor con el AmigaOS 3.x, utilice este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -noliveresize

  En   muchas  plataformas,  Hollywood  redimensionará,  en  tiempo  real,  una
  visualización (y sus contenidos) ante la acción del usuario.  Si no desea que
  esto suceda así, utilice este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nomodeswitch

  Si especifica este argumento no será posible cambiar entre el modo de ventana
  y  el  modo  de  pantalla  completa  presionando  la  combinación  de  teclas
  CMD+RETORNO  (bajo  Windows  sería  ALTDCHA+RETORNO).   Si se especifica este
  argumento,  Hollywood  permanecerá  siempre  en  este  modo  de visualización
  inicial  y  no  se producirá el cambio entre el modo de ventana y de pantalla
  completa.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nomousehook                                                     [Sólo Linux]

  Si   especifica  este  argumento,  Hollywood  no  instalará  un  resorte  que
  constantemente  averigüe  la  posición del ratón.  Sólo es útil en el caso de
  Linux  si  la  conexión  al servidor X es bastante lenta, porque en este caso
  utilizar  el  argumento podría suponer un mejora del rendimiento, aunque como
  contrapartida  ya  no recibirá notificaciones de los eventos "OnMouseMove" si
  se producen fuera de los límites de la ventana, porque esta notificación sólo
  funciona con un resorte.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -noscaleengine

  Este  argumento  ha de utilizarse en conjunción con "-fullscreenscale" y hace
  que  caso Hollywood no utilice ningún motor de redimensionado:  Se limitará a
  abrir  su  visualización  con  las mismas dimensiones que la resolución de su
  monitor.    Su   guión  necesitará,  entonces,  adaptarse  manualmente  a  la
  resolución  del  monitor.  Esto permite escribir guiones que puedan adaptarse
  dinámicamente  a  diferentes  resoluciones  sin simplemente redimensionar sus
  gráficos.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -noscaleswitch

  Cuando  el  usuario  cambia  del  modo  de  ventana  al  de pantalla completa
  utilizando   la   combinación   de   teclas   CMD+RETORNO  (bajo  Windows  es
  ALTDCHA+RETORNO), Hollywood podría elegir redimensionar la visualización a la
  resolución  actual  del  monitor en lugar de cambiar la resolución física del
  monitor.   Si  no  quiere  que  Hollywood simule el modo de pantalla completa
  redimensinando  la  visualización a la resolución actual del monitor, utilice
  este  argumento  de  consola.   En  este  caso, presionando la combinación de
  teclas de cambio siempre cambiará la resolución física del monitor.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nosmoothscale

  Cuando  el  usuario  cambia  entre  el  modo  de  ventana y pantalla completa
  utilizando   la   combinación   de   teclas   CMD+RETORNO  (bajo  Windows  es
  ALTDCHA+RETORNO)  y  Hollywood  elige  redimensionar  la  visualización  para
  ajustarla  a  la  resolución  actual del monitor, por defecto se utilizará un
  suavizado  por  interpolación para que los resultados se vean más suaves.  Si
  no quiere esto, utilice este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nosound

  Este  argumento  desactiva  todas  las  funciones  de  sonido  de  Hollywood:
  Hollywood se pondrá en marcha en modo silencioso.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -nostyleoverride                                               [Sólo AmigaOS]

  Si  Hollywood ejecuta su guión en el modo de pantalla completa, se modificará
  automáticamente  el  estilo de la decoración de la ventana de visualización y
  la  ventana  no  tendrá borde y su tamaño será fijo.  Si no desea esto, puede
  utilizar  este argumento para forzar a Hollywood a que respete los estilos de
  la  ventana no tocándolos.  Este argumento se utiliza habitualmente junto con
  "-nobackfill".

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -numchannels <canales>

  Por defecto, Hollywood reserva ocho canales de sonido para la reproducción de
  éste.   Eso  significa que Hollywood se quedará sin canales en el caso de que
  su  guión  intente  reproducir más de ocho fuentes de sonido diferentes, como
  muestras de sonido, flujos de video..., al mismo tiempo. Si su guión necesita
  más  canales  por  algún  motivo  particular,  puede  utilizar este argumento
  para que Hollywood los reserve.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -overrideplacement

  Si  se  especifica  este  argumento, Hollywood ignorará cualquier información
  guardada  de  la  posición o tamaño de las visualizaciones cuando la etiqueta
  "RememberPosition"   se   ha  definido   como  TRUE.   En  su  lugar,  estas
  visualizaciones  utilizarán siempre los valores por defecto establecidos para
  estos parámetros.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -overwrite

  El  comportamiento  por  defecto  de  Hollywood  es  pedirle  que confirme la
  sobreescritura  si  existen los ficheros al utilizar el argumento "-compile".
  Puede suprimir esta petición de confirmación especificando este argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -pictrans <transparencia>

  Sólo  se  utiliza  con  el  argumento "-backfill picture".  Este argumento le
  permite  asignar  un color transparente para su imagen.  Por defecto el valor
  es #NOTRANSPARENCY.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -picxpos <x>
  -picypos <y>

  Sólo  se  utiliza  con  el  argumento  "-backfill  picture".   Puede usar dos
  argumentos  para  especificar  la  posición en la que la imagen o relleno del
  fondo se visualizará.  Por defecto el valor es #CENTER.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -printerror:

  Si  se especifica este argumento, Hollywood no mostrará los errores del guión
  en  una caja de diálogo:  Simplemente los imprimirá en la consola.  Puede ser
  útil  cuando  integra  Hollywood  en  interfaces  de desarrollo.  Si necesita
  procesar los mensajes de error de Hollywood, debería también especificar este
  argumento  para  forzar  a  que éstos tengan un formato procesable, es decir,
  dividirlos  en  sus  constituyentes individuales como el nombre del guión, el
  número de línea, el mensaje de error.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -pubscreen <nombre>                                            [Sólo AmigaOS]

  Si  se especifica, Hollywood se abrirá sobre la pantalla pública especificada
  por su nombre y no sobre la pantalla del escritorio.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -quiet

  Si  especifica  este  argumento,  Hollywood  no  mostrará  información alguna
  durante su puesta en marcha.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -requireplugins <lista>

  Este   argumento   permite  especificar  de  forma  explícita  una  lista  de
  complementos  que su guión exige.  Si necesita especificar más de uno, separe
  los  complementos  utilizando  el  carácter barra vertical "|":  Por ejemplo,
  si  su  guión  exige  los  complementos  "cplmt1.hwp"  y  "cplmt2.hwp"  ha de
  especificarlos   como  "cplmt1|cplmt2"  con este  argumento.   Utilizar  este
  argumento  tiene  el  mismo  efecto que utilizar el comando del preprocesador
  @{"@REQUIRE" LINK atREQUIRE} (consúlte  éste  para  los  detalles).    Si  necesita  suministrar
  argumentos  adicionales  a  la  rutina de inicialización de los complementos,
  utilice el argumento "-requiretags".

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -requiretags <etiquetas>

  Este  argumento  le permite suministrar argumentos adicionales a la rutina de
  inicialización   de   los   complementos.    Estos   argumentos   adicionales
  normalmente se trasfieren  utilizando el comando del preprocesador @{"@REQUIRE" LINK atREQUIRE},
  pero  con  esta  opción también puede hacerlo desde la línea de comandos.  Es
  especialmente  útil  para pruebas porque así no tendrá que modificar su guión
  continuamente.   El  argumento sirve para más de un complemento, teniendo que
  adoptar la cadena el siguiente formato:

    nombre1[etiqueta1=valor1,...,etiquetaN=valorN]nombre2[...]...nombreN[...]

  Veámoslo con un ejemplo:

    -requiretags micmplt[Usuario=admin,Clave=secreto,Longitud=64]

  Este   ejemplo   exige   tres   etiquetas   adicionales  para  la  rutina  de
  inicialización  del complemento llamado "micmplt.hwp", denominadas "Usuario",
  "Clave"  y  "Longitud".   La  primera,  "Usuario" se ha definido con el valor
  "admin",  la  segunda con el valor "secreto" y la tercera con el valor entero
  "64".    Por   favor,   tenga   en   cuenta   que   ha  de  utilizar  también
  "-requireplugins"  si utiliza el argumento "-requiretags" o sino el código de
  inicialización de los complementos finalmente no se ejecutará.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -resourcemonitor

  Especificando  este  argumento se abrirá  a la derecha el monitor de recursos
  de  Hollywood  al  ponerse  en  marcha  su  guión.  Este monitor es útil para
  realizar  un  seguimiento  de los recursos mientras desarrolla su guión.  Por
  favor,  lea  la documentación de  @{"OpenResourceMonitor()" LINK OpenResourceMonitor} para más información
  sobre este tema.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scalefactor <factor>

  Este  argumento puede utilizarse en conexión con "-autoscale" o "-layerscale"
  para  aplicar  un  factor  global de escala o redimensionado a todo su guión.
  Este  factor  que  actúa  como coeficiente multiplicador, ha de especificarse
  como  un  número con parte fraccionaria:  Por ejemplo 0.5 reduciría todo a la
  mitad de su tamaño, mientras que 2.0 lo duplicaría todo.

  Tenga  en  cuenta  que  este argumento hará que el guión se comporte de forma
  ligeramente   diferente  que  al  utilizar  los  argumentos  "-scalewidht"  y
  "-scaleheight".    Estos   dos   últimos  argumentos  fuerzan  un  tamaño  de
  visualización  fijo  para  el guión que nunca cambiará a menos que el usuario
  utilice  el  ratón  para modificarlo, mientras que "-scalefactor" aplicará un
  factor a todas las nuevas imágenes de fondo y a los tamaños de visualización,
  de manera que estos últimos pueden cambiar si el tamaño de la imagen de fondo
  cambia  o  el propio guión cambia el tamaño de visualización.  Además, el uso
  de  "-scalefactor"  es  perfecto para el redimensionado de un guión cuando se
  utiliza  una visualización con un elevado número de puntos por pulgada porque
  asegura  que  el  guión  se  comportará igual, sólo que su visualización será
  mayor (¡o menor si lo desea!).

  También  puede  utilizar  el  argmento  "-systemscale"  para aplicar de forma
  automática  el  factor de escala o redimensionado del sistema anfitrión en su
  visualización  (consulte  líneas  más  adelante).   Por favor, lea también la
  documentación   de   los   argumentos   "-autoscale"/"-layerscale"  para  más
  información  sobre los motores de redimensionado (así como @{"la propia sección" LINK AutoScalingInfo}
  dedicado a ello para los detalles).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scalepicture

  Sólo se utiliza con el argumento "-backfill picture".  Este argumento informa
  a Hollywood que ha de redimensionar la imagen de fondo al tamaño actual de la
  ventana para que el relleno sea completo.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scaleswitch:

  Cuando  el  usuario  cambia  entre  los  modos de ventana y pantalla completa
  utilizando   la   combinación   de   teclas   CMD+RETORNO  (bajo  Windows  es
  ALTDCHA+RETORNO),  Hollywood  podría  no  cambiar  el  modo  de  pantalla del
  monitor,   sino   simplemente   simular   el   modo   de   pantalla  completa
  redimensionando  la  visualización  a la resolución actual del monitor.  Esto
  sólo  se  hace  si  el  sistema  donde  Hollywood se está ejecutando, soporta
  redimensionado  acelerado  a  través  de  la  circuitería.   En  sistemas más
  antiguos  o plataformas donde esta prestación no se soporta, Hollywood, en su
  lugar,  cambiará  la resolución del monitor.  Si quiere que Hollywood siempre
  simule el modo de pantalla completa a través del redimensionado, utilice este
  argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scalewidth <anchura>
  -scaleheight <altura>

  Estos dos argumentos pueden ser utilizados en conexión tanto con "-autoscale"
  como  "-layerscale"  para  especificar  las dimensiones iniciales al motor de
  redimensionado.   Puede especificarlos como el número de píxeles (por ejemplo
  "-scalewidth  1280  -scaleheight  1024")  o  como  un porcentaje (por ejemplo
  "-scalewidth 200% -scaleheight 200%").  Por favor, lea la documentación sobre
  "-autoscale"/"-layerscale"  para  más información en las secciones en las que
  se habla de @{"los motores de redimensionado" LINK AutoScalingInfo}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scrdepth <profundidad>

  Este argumento puede especificarse para definir la profundidad de la pantalla
  cuando  quiera  que  Hollywood se abra  en  modo de pantalla  completa.  Este
  argumento  le  dice  a  Hollywood  qué número de bits de profundidad de color
  quiere  para  dicha pantalla (las profundidades válidas son 15, 16, 24 y 32).
  Si no especifica el argumento, Hollywood utilizará la misma profundidad de la
  pantalla que la del escritorio.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -scrwidth <anchura>
  -scrheight <altura>

  Estos  dos  argumentos  pueden  ser utilizandos en conexión con "-fullscreen"
  para  especificar  las dimensiones de la pantalla que debe abrir Hollywood en
  el  modo  de pantalla completa.  Si no los especifica, se elegirá la pantalla
  que mejor se ajuste a su visualización.  Si especifica el valor nulo (0) como
  <anchura>  y  <altura>,  se  utilizará  las  dimensiones de la pantalla de su
  escritorio para el modo de pantalla completa.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -setconstants <lista>

  Puede   utilizar   este   argumento  para  declarar  una  o  más  constantes.
  Normalmente, las constantes  se declaran utilizando @{"la declaración Const" LINK PrgConst}.  A
  veces,  sin embargo, puede ser conveniente declararlas también desde la línea
  de comandos:  Es especialmente útil con el comando del preprocesador @{"@IF" LINK atIF}.

  Puede  suministrar  una  cadena que contenga una o más constantes a declarar,
  utilizando  la barra vertical "|" para separar las diferente declaraciones si
  son más de una y el signo igual "=" para asignar un valor a una constante (si
  no  inserta  el  signo  igual  para asignar un valor a una constante, ésta se
  inicializará con un valor de uno). Aquí tiene una cadena de ejemplo:

                       "MICONSTANTE1|MICONSTANTE2=1000"

  Si  suministra  esta  cadena  al  argumento "-setconstants", #MICONSTANTE1 se
  definirá  con  el  valor 1 y #MICONSTANTE2 se definirá con el valor 1000.  Si
  necesita definir una constante de cadena, tendrá que encerrar la cadena entre
  corchetes, como por ejemplo:

                        "MICONSTANTECADENA=[Prueba123]"

  Si  necesita almacenar los corchetes dentro de una constante de cadena, basta
  con  que  los  duplique  para  que  no se confundan con los delimitadores del
  contenido de la cadena.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -sizeable

  Si  especifica este argumento, Hollywood abrirá esta ventana con un artilugio
  de  tamaño  en  la parte inferior derecha de la ventana.  Este artilugio será
  invisible si su ventana no tiene bordes, pero estará disponible.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -skipplugins <máscara>

  Este  argumento  puede utilizarse para indicarle a Hollywood qué complementos
  no  han  de  cargarse  durante la puesta en marcha.  Puede especificar varios
  separándolos  con  una barra vertical "|".  Si quiere que Hollywood no cargue
  ningún  complemento,  utilice  un  asterisco "*".  Puede cargar más tarde los
  complementos   utilizando   el comando  del  preprocesador  @{"@REQUIRE" LINK atREQUIRE}  o  con
  @{"LoadPlugin()" LINK LoadPlugin}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -smoothscale

  Si  "-autoscale"  o  "-layerscale"  están  activas  y especifica el argumento
  "-smoothscale",  todas  las  operaciones de cambio de tamaño o redimensionado
  serán interpoladas utilizando un sistema de suavizado de la imagen a nivel de
  píxel.  El aspecto visual será mejor,  pero es más lento.   Por favor, lea la
  documentación  de  "-autoscale"/"-layerscale"  para más información sobre los
  motores de redimensionado de Hollywood.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -softtimer                                                     [Sólo Windows]

  Si  especifica  este argumento, Hollywood utilizará un temporizador, a través
  del  logicial,  de  baja resolución en lugar del temporizador, a través de la
  circuitería, de alta resolución.  Esto es necesario a veces porque con alguna
  circuitería  muy  antigua  bajo  Windows  XP,  el  temporizador podría saltar
  ocasionalmente  causando  un  comportamiento inesperado.  En las máquinas más
  modernas  tanto  a nivel de circuitería como de sistema operativo Windows, no
  debería utilizarlo nunca.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -softwarerenderer:                                             [Sólo Windows]

  Especifique  este  argumento  para desactivar la generación de imagen, en los
  sistemas  bajo  Windows,  utilizando  la  aceleración  a través de la tarjeta
  gráfica (Direct2D).  Usando este argumento, Hollywood realizará la generación
  de la imagen utilizando la CPU para una máxima compatibilidad.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -startcolor <color>

  Sólo  se  requiere  en  conexión  con  los  argumentos "-backfill gradient" o
  "-background  color".   <Color> es un color @{"RVA" LINK RGBInfo} (por ejemplo $00FF00 para el
  color  verde).  Puede especificarse también con "-backfill picture"; el color
  entonces llenará el fondo de la imagen.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -systemscale

  Si  define  este  argumento,  el  factor  de  escala  del sistema se aplicará
  automáticamente  a  su  visualización:   Esto  puede ser útil en sistemas con
  monitores  con  un  elevado número de puntos por pulgada.  Por ejemplo, si su
  visualización  se  abre  normalmente  en  640x480  píxeles y lo ejecuta en un
  monitor  que  tenga  el  doble  de  puntos  por  pulgada,  especificando este
  argumento  la  visualización  se  redimensionará  automáticamente  a 1280x960
  píxeles  de  manera  que no se verá tan pequeña.  Por defecto, este argumento
  activa  el  motor de redimensionado automático, así que si quiere utilizar en
  su lugar el redimensionado por capas utilice el argumento "-layerscale".

  Tenga  en  cuenta  que  el  argumento "-systemscale" utiliza el mismo modo de
  redimensionado  que  "-scalefactor"  internamente,  así  que  los  guiones se
  comportarán  igual.   Incluso  es posible combinar ambos argumentos de manera
  que  el  factor  suministrado  con  "-scalefactor"  se aplice sobre el factor
  establecido   por  "-systemfactor",  multiplicándose.   Por  favor,  consulte
  también  la documentación de los argumentos "-autoscale" y "-layerscale" para
  más  información  sobre los motores de redimensionado de Hollywood y consulte
  la sección @{"Motores de redimensionado" LINK AutoScalingInfo} para los detalles.  Tenga en cuenta que
  bajo Windows ha de definir la etiqueta "DPIAware" como TRUE con el comado del
  preprocesador @{"@OPTIONS" LINK atOPTIONS}  para poder usar este argumento:  Consúltelo para los
  detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -stayactive

  (Eliminado con la versión 2.0 de Hollywood)

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -tempdir <ruta>

  Este  argumento  puede  utilizarse para especificar la ruta de acceso a donde
  Hollywood  ha  de  almacenar  sus ficheros temporales.  Es especialmente útil
  bajo  AmigaOS  y  sistemas  compatibles  puesto  que Hollywood almacenará los
  ficheros  temporales por defecto en el disco de RAM en estos sistemas lo cual
  podría ocasionar problemas en equipos con poca memoria o cuando los proyectos
  son  muy  grandes.   Para especificar la ubicación del directorio actual como
  ubicación para los ficheros temporales utilice el carácter punto "." con este
  argumento.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -usequartz                                                       [Sólo macOS]

  Le indica  a Hollywood que ha de usar  @{u}Quartz 2D@{uu} para toda la salida gráfica.
  Por  defecto,  Hollywood  utiliza  el sistema  @{u}QuickDraw@{uu}  porque es mucho más
  rápido (a pesar de ser abandonado).  Si experimenta algún problema gráfico en
  macOS,  podría querer  probar  con este argumento.  Tenga en cuenta  que este
  argumento  sólo se soporta en la versión PowerPC de Hollywood:  Las versiones
  x86/x64 de Hollywood para macOS utilizarán siempre Quartz 2D.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -usewpa                                                        [Sólo AmigaOS]

  Le  indica  a  Hollywood que utilice el dispositivo independiente de mapas de
  bits  en  lugar  de los mapas de bits estándares del sistema operativo.  Esta
  opción  normalmente  es  más  lenta  que  los  mapas  de  bits del SO, con la
  excepción  de  @{u}WinUAE@{uu}  y  AROS (ambos pueden bloquear dichos mapas del bits a
  través  del SO sólo de manera bastante ineficiente).  Por ello, bajo @{u}WinUAE@{uu} y
  AROS,  la opción "-usewpa" se activa automáticamente para acelerar Hollywood.
  Si  desea desactivarlo, añada el argumento "-wpamode 0".  Por favor, tenga en
  cuenta  lo  siguiente:   "-usewpa"  es  un  argumento de bajo nivel que se ha
  incluido  aquí esencialmente para pruebas. Normalmente, no debería tratar con
  él directamente.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -videofps <fps>

  Sólo  se  utiliza  en conjunción con "-videout".  Si "-videoout" está activo,
  "-videofps"  puede utilizarse para indicarle a Hollywood a cuántos fotogramas
  por segundo (FPS) han de grabarse en video. Si no se especifica, se usará por
  defecto  el  valor  de  50  FPS.   Por  favor, para más detalles consulte la
  sección sobre @{"guardar guiones como ficheros de video" LINK VideoRecorder}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -videoout <fichero>

  Activa   la  prestación  interna  de  Hollywood  de  videograbación.   Si  se
  especifica, Hollywood  guardará la salida gráfica de su guión como un fichero
  de  video AVI, que podría grabar en formato @{u}DVD@{uu} por ejemplo.  Por favor, lea
  la sección sobre @{"guardar guiones como ficheros de video" LINK VideoRecorder} para más detalles.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -videopointer

  Sólo se utiliza en conjunción con "-videout".  Si especifica el argumento, el
  puntero  del ratón  siempre  será dibujado  dentro del flujo de video (o sea,
  aparecerá  en  éste).   Por  defecto, cuando se graba en video, el puntero no
  aparecerá.   Si  necesita  que  sí  aparezca  (por  ejemplo  para  mostrar la
  interación  del  usuario),  especifique  este argumento.  Por favor, para más
  detalles consulte la sección sobre @{"guardar guiones como ficheros de video" LINK VideoRecorder}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -videoquality <calidad>

  Sólo se utiliza  en  conjunción  con "-videout".  Si "-videoout" está activo,
  "-videoquality"  puede  utilizarse para especificar el nivel de compresión de
  los   fotogramas   del  video.   La  calidad  se  especifica  en  porcentaje,
  admitiéndose  como  rango de niveles de calidad válidos de 0 a 100.  El valor
  por  defecto es 90, lo que ofrece un fichero de video de una calidad bastante
  alta,  por  lo  que a su vez necesitará bastante espacio en disco.  Si quiere
  obtener  un  fichero  de  video más pequeño, puede probar a bajar el nivel de
  calidad.    Por   favor,   para   más  detalles  consulte  la  sección  sobre
  @{"guardar guiones como ficheros de video" LINK VideoRecorder}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -videostrategy <strategia>

  Sólo  se  utiliza  en  conjunción con "-videout".  Si "-videout" está activo,
  "-videostrategy" puede utilizarse para especificar la estrategia de Hollywood
  cuando  convierta  un  guión  a  un  fichero  de  video.   Actualmente, puede
  especificar las opciones "wait" y "raw".  Por defecto, Hollywood utilizará la
  estrategia  de  espera  "wait".   Por  favor,  para  más detalles consulte la
  sección sobre @{"guardar guiones como ficheros de video" LINK VideoRecorder}.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -vsync                                                         [Sólo Windows]

  Bajo  Windows,  este  argumento se puede utilizar para forzar al generador de
  gráficos  de  Hollywood  a  regular  el  refresco  de la tasa de refresco del
  monitor.   Eso significa  que  ya no tendrá que usar funciones como @{"VWait()" LINK VWait}.
  Sin  embargo,  tenga en cuenta que si lo define como TRUE ha de asegurarse de
  poder  dibujar  todo  en  el intervalo de generación del fotograma completo o
  sino el dibujado será extremadamente lento.  El dibujado a fotograma completo
  puede  alcanzarse,  por ejemplo, utilizando doble memoria tampón o utilizando
  @{"BeginRefresch()" LINK BeginRefresh}  y  @{"EndRefresh()" LINK EndRefresh}.    Tenga  en  cuenta  también  que  VSync
  actualmente sólo se soporta bajo Windows y sólo si Hollywood utiliza Direct2D
  (que sólo está disponible a partir de Windows Vista SP2).

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -window

  Si especifica este argumento, Hollywood abrirá su ventana en el escritorio en
  lugar  de  utilizar  el  modo  de  pantalla  completa.  Este es el ajuste por
  defecto.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -winwidth <anchura>
  -winheight <altura>

  Estos  argumentos  le  permiten  definir  la  anchura/altura  inicial  de  la
  visualización  sin activar los motores de redimensionado:  Tiene el mismo que
  efecto  que  si el usuario cambia manualmente el tamaño de su visualización a
  la  anchura/altura  especificada.   Éste  es  el  motivo  por el que su guión
  recibirá  también  el  evento "SizeWindow" tras poner en marcha Hollywood, si
  utiliza  este  argumento.   Tenga  en cuenta que como ya se ha dicho, esto no
  activa  ningún  motor  de redimensionado, así que el propio guión ha de estar
  preparado para las nuevas dimensiones.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -wpamode                                                       [Sólo AmigaOS]

  Si "-wpamode" está activo, este argumento puede ser utilizado para definir el
  modo  del  dispositivo  independiente  de  mapa  de  bits.  El valor cero (0)
  desactivará  el argumento "-usewpa", el valor uno (1) activará el modo DIB de
  32 bits  y  el valor dos (2) activará el modo DIB ajustado al Workbench.  Por
  defecto,   el   valor   utilizado es  "1" que  debería  ofrecer  los  mejores
  rendimientos.   Por  favor,  tenga  en cuenta lo siguiente:  "-wpamode" es un
  argumento  de  bajo nivel que se ha incluido aquí esencialmente para pruebas.
  Normalmente, no debería tratar con él directamente.

  ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  -xserver <nombre>                                                [Sólo Linux]

  Este  argumento  puede  utilizarse  para especificar el servidor X con el que
  Hollywood  ha  de  intentar  conectarse.  Por defecto, Hollywood utilizará el
  servidor  X  que  se especifica en la variable de entorno DISPLAY.  Si quiere
  que Hollywood se conecte con un servidor X diferente, utilice este argumento.

                                    --==--

                ¹ Nota del traductor: Acrónimo de la expresión
                       "Marca del orden de los octetos"
                 http://en.wikipedia.org/wiki/Byte_order_mark


                                                           @{">> Versión original" LINK "HollywoodEN.guide/ManualUsage"}

@ENDNODE
@REMARK =======================================================================
@NODE ConsoleEmulation "Guía de Hollywood: Emulación de la consola *UPD10*"

@{b}Emulación de la consola@{ub}

Hollywood  y  los programas compilados con éste reconocen argumentos de consola
que  controlan  varias  funciones  del  programa.   La  mayoría del tiempo, sin
embargo,  no pondrá poner en marcha Hollywood o los programas compilados con él
desde  la  consola,  así  que,  ¿cómo puede transferirse estos argumentos a los
programas creados con Hollywood cuando no existe dicha consola?  Difiere de una
plataforma  a  otra:   Más  adelante  se le ofrecerá una visión general de cómo
hacerlo.

Note  que  por  defecto, todos los programas compilados con Hollywood manejarán
los  argumentos  de  consola y los argumentos que se les transfieran utilizando
los mecanismos descritos más adelante.  Si quisiera evitar este comportamiento,
puede  compilar  sus programas  utilizando  el argumento @{"-locksettings" LINK ManualUsage}.  De no
hacerlo  así,  el  usuario  podrá cambiar el aspecto de su programa compilado a
través de los argumentos que utilice.

Aquí  tiene  como  especificar los argumentos de la consola a programas creados
con Hollywood sin utilizar la consola:

  1. @{u}AmigaOS@{uu}:

  Basta  con  que  cree  un icono para su programa y añada los argumentos de la
  consola  que  desee  utilizar  como tipos de herramienta de dicho icono.  Por
  ejemplo,   para   añadir   un  gradiente  de  negro  a  azul  a  su  programa
  "RAM:MiAlucinanteProg",  cree  un icono llamado "RAM:MiAlucinanteProg.info" y
  añada los siguientes tipos de herramienta al icono:

    BACKFILL=GRADIENT
    STARTCOLOR=$000000
    ENDCOLOR=$0000ff
    BORDERLESS
    FIXED
    (FULLSCREEN)

  Percátese  de  que los tipos de herramienta encerrados entre paréntesis serán
  ignorados,  lo  que  significa  que  para  el  ejemplo  anterior  el  tipo de
  herramienta FULLSCREEN no será tenido en cuenta.

  2. @{u}Windows@{uu}:

  Bajo  Windows, puede colocar los argumentos de consola que quiera utilizar en
  un  fichero INI que ha de acompañar a su programa.  Asumamos que ha compilado
  un  programa  llamado "MiAlucinanteProg.exe" con Hollywood y que ha instalado
  este programa en:

    C:/Program Files/MiAlucinanteProg/MiAlucinanteProg.exe

  Ahora  puede  crear  un  fichero  INI  que  contenga  las  opciones para este
  programa.   El  fichero  INI  ha de tener  el mismo nombre que su programa, o
  sino,  el  programa no será capaz de detectar su presencia.  Por lo tanto, ha
  de crear el fichero INI siguiente:

    C:/Program Files/MiAlucinanteProg/MiAlucinanteProg.ini

  Puede  usar  su editor de textos favorito para añadir opciones a este fichero
  INI.   Por  ejemplo,  para crear con su programa un gradiente de negro a azul
  para  rellenar  el fondo, puede añadir las siguientes etiquetas en el fichero
  "MiAlucinanteProg.ini":

    Backfill=Gradient
    StartColor=$000000
    EndColor=$0000ff
    Borderless=TRUE
    Fixed=TRUE

  Eche una ojeada  a la sección de @{"argumentos de la consola" LINK ManualUsage} para ver todos los
  argumentos que puede introducir en el fichero INI.

  3. @{u}macOS@{uu}:

  Bajo  macOS,  puede  elegir  entre  dos  formas  diferentes de transferir los
  argumentos de la consola sin utilizar la consola:

    1. Abra  el  fichero  "Info.plist"  dentro  del  paquete  de  su aplicación
       compilada  con Hollywood utilizando su editor de textos favorito.  Ahora
       busque  la  entrada  del  diccionario  llamada "CFBundleExecutableArgs".
       Aquí puede añadir ahora todos los argumentos de consola que quiera.  Por
       ejemplo:

         <key>CFBundleExecutableArgs</key>
         <string>
         -backfill gradient -startcolor $000000 -endcolor $0000ff
         -borderless -fixed
         </string>

       Con estos argumentos de consola especificados, su programa se abrirá con
       un gradiente de negro a azul.

    2. Alternativamente,  puede  crear  también  un  fichero  INI  igual que en
       Windows.   Consulte  más  arriba cómo hacerlo.  La única diferencia bajo
       macOS  es  que  ha  de  colocar  el  fichero  INI  dentro del directorio
       "Resources"  del  paquete  de su aplicación.  Por ejemplo, si su paquete
       está localizado en la siguiente ubicación:

         /Programs/MiAlucinanteProg.app

       Su fichero INI ha de estar entonces aquí:

         /Programs/MiAlucinanteProg.app/Contents/Resources/MiAlucinanteProg.ini

       El resto es exactamente igual que bajo Windows.

  4. @{u}Linux@{uu}:

  Bajo Linux también puede colocar todos los argumentos en un fichero INI.  Vea
  líneas más atrás para instrucciones más detalladas.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/ConsoleEmulation"}

@ENDNODE
@REMARK =======================================================================
@NODE Compiler "Guía de Hollywood: Compilador *UPD10*"

@{b}Compilación de ejecutables@{ub}

El compilador de Hollywood puede ser utilizado tanto a través del programa @{"GUI" LINK GUI}
como desde la consola utilizando @{"el argumento -compile" LINK ManualUsage}.

Una  vez  invocado,  el  compilador  leerá  el (fichero-)guión especificado, lo
compilará  y  lo  fusionará  con  el reproductor de Hollywood.  Todos los datos
externos  declarados  a través de @{"los comandos del preprocesador" LINK PrgPreproc} serán también
incrustados  en  el  ejecutable, a menos  que  explícitamente  se haya indicado
que  no  se  haga.   El formato del ejecutable de salida puede ser especificado
definiendo   @{"el argumento  -exetype" LINK ManualUsage}.    Este argumento  puede  definirse  para
generar los siguientes tipos de ejecutables:

    @{u}amigaos4@{uu}      Ejecutable para AmigaOS 4 (PowerPC)
    @{u}aros@{uu}          Ejecutable para AROS (x86)
    @{u}classic@{uu}       Ejecutable para AmigaOS 3.x (68020+)
    @{u}classic881@{uu}    Ejecutable para AmigaOS 3.x
                  que exige disponibilidad de unidad de coma flotante
                  (o sea, 68020+ y 68881/2, o, 68040/68060)
    @{u}linux@{uu}         Ejecutable para Linux (x86)
    @{u}linux64@{uu}       Ejecutable para Linux (x64)
    @{u}linuxarm@{uu}      Ejecutable para Linux (arm)
    @{u}linuxppc@{uu}      Ejecutable para Linux (PowerPC)
    @{u}macos@{uu}         Paquete de aplicación para macOS (PowerPC)
    @{u}macosarm64@{uu}    Paquete de aplicación para macOS (arm64)
    @{u}macos86@{uu}       Paquete de aplicación para macOS (x86)
    @{u}macos64@{uu}       Paquete de aplicación para macOS (x64)
    @{u}morphos@{uu}       Ejecutable para MorphOS
    @{u}warpos@{uu}        Ejecutable binario mixto para WarpOS (68040/PowerPC)
    @{u}win32@{uu}         Ejecutable para Windows (x86)
    @{U}win64@{UU}         Ejecutable para Windows (x64)
    @{u}applet@{uu}        Miniaplicación universal de Hollywood
                  que puede ser ejecutada en todos los sistemas
                  utilizando un reproductor de Hollywood.

En la versión 68K  de Hollywood @{"el argumento -exetype" LINK ManualUsage} es definido  por defecto
como "classic", en la versión AmigaOS 4 como "amigaos4" y así sucesivamente.

Si  su  guión utiliza gran cantidad de datos externos, su ejecutable podría ser
muy  grande,  puesto que Hollywood intentará incrustar en él todos los ficheros
declarados  con  los  comandos  del preprocesador.  Si no desea que eso ocurra,
puede  utilizar  el  argumento  "Link" que todos los comandos del preprocesador
soportan  para  indicarle  al  enlazador  que  no  quiere  que incruste ciertos
ficheros.   También,  podría  optar  por  cargar  los  ficheros  utilizando los
comandos normales de Hollywood en lugar de los comandos del preprocesador.

El  ejecutable  generado  aceptará  los mismos  @{"argumentos  de  consola" LINK ManualUsage} que el
programa  principal  de  Hollywood,  de manera, que por ejemplo podría poner en
marcha  su  aplicación con una ventana sin bordes invocándolo con @{"el argumento" LINK ManualUsage}
@{"-borderless" LINK ManualUsage}.

También  se puede  incrustar  complementos  en  sus  ejecutables utilizando @{"el" LINK ManualUsage}
@{"argumento -linkplugins" LINK ManualUsage},  pero  ha de tener cuidado con las licencias que rigen
éstos porque quizás no permitan en enlazado estático y además podrían afectar a
la licencia de su proyecto.  Consulte la sección @{"argumentos de la consola" LINK ManualUsage} para
los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Compiler"}

@ENDNODE
@REMARK =======================================================================
@NODE Applets "Guía de Hollywood: Miniaplicaciones *UPD10*"

@{b}Compilación de miniaplicaciones@{fg text}@{ub}

Además  de  poder  generar  ejecutables  autónomos,  también puede compilar sus
guiones  y  generar  miniaplicaciones,  que  son  mucho  más pequeñas porque no
contienen  el  reproductor  de  Hollywood.   Estas  miniaplicaciones pueden ser
puestas en marcha con el intérprete o con el reproductor gratuito de Hollywood.
La  ventaja  de las miniaplicaciones es que ahorran mucho espacio.  Imagine que
quiere  compilar  su  guión  para  todas  las plataformas que Hollywood soporta
(AmigaOS  3,  AmigaOS  4,  WarpOS,  MorphOS,  AROS,  Win32, macOS, Linux).  Los
reproductores para todas ellas consumen más de 25 megaoctetos, de manera que el
paquete  a distribuir sería bastante grande.  En este caso es mejor compilar el
guión  como  miniaplicación  y luego que el usuario simplemente se descargue el
reproductor para su plataforma de la página http://www.hollywood-mal.com/ y que
lo  utilice para ejecutar su miniaplicación.  Y así usted sólo ha de distribuir
la miniaplicación.

Para  compilar  miniaplicaciones  con  Hollywood,  basta  con  que  utilice  el
argumento applet con @{"el argumento -exetype" LINK ManualUsage}  o que utilice  la interfaz gráfica
GUI.  Las miniaplicaciones de Hollywood tienen como sufijo "hwa".


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Applets"}

@ENDNODE
@REMARK =======================================================================
@NODE LinkingData "Guía de Hollywood: Incrustación de ficheros de datos *UPD10*"

@{b}Incrustación de ficheros de datos@{ub}

Por  defecto,  el enlazador de Hollywood incrustará todos los ficheros de datos
externos   declarados  a  través  de  los  comandos  del  preprocesador  en  el
ejecutable/miniaplicación generada.  Si su guión tuviese un aspecto como el que
sigue, el fichero "prueba.jpg" se incrustaría en su ejecutable/miniaplicación:

  \@BGPIC 1, "prueba.jpg"
  WaitLeftMouse
  End

Si  no  desea  que  esto  ocurra, puede definir la etiqueta "Link" con el valor
FALSE  y  el  fichero  referenciado  por  el comando del preprocesador no sería
incrustado:  Esta etiqueta es aceptada por todos los comandos del preprocesador
que  tratan  con ficheros.  El código de nuestro ejemplo anterior ahora tendría
el siguiente aspecto:

  \@BGPIC 1, "prueba.jpg", {Link = FALSE}
  WaitLeftMouse
  End

A veces, puede que desee enlazar ficheros que su guión cargue durante el tiempo
de ejecución desde su ejecutable/miniaplicación.  Considere el siguiente código
por ejemplo:

  LoadBGPic(1, "prueba.jpg")
  LoadBrush(1, "titulo.png")
  DisplayBGPic(1)
  DisplayBrush(1, #CENTER, #CENTER)
  WaitLeftMouse
  End

Por  defecto,  los ficheros "prueba.jpg" y "titulo.png" no se incrustarán en su
ejecutable/miniaplicación  ya  que  no  han  sido declarados con un comando del
preprocesador, sino que se cargan durante el tiempo de ejecución utilizando en
su lugar  @{"LoadBGPic()" LINK LoadBGPic} y @{"LoadBrush()" LINK LoadBrush} respectivamente.  A pesar de ello, aún es
posible incrustar dichos ficheros en su ejecutable/miniaplicación utilizando el
argumento "-linkfiles" o el comando del preprocesador @{"@LINKER" LINK atLINKER}.

Cuando  se utiliza el argumento de la consola "-linkfiles", ha de suministrarse
un  fichero  de base de datos.  Dicho fichero es un simple fichero de texto con
codificación UTF-8 que contiene una lista de ficheros a incrustar por Hollywood
en  el ejecutable/miniaplicación durante el proceso de compilación.  Sólo ha de
especificar  un  fichero  por  línea  en  este fichero de base de datos y ha de
especificarlo  de forma idéntica a la que utilice en su guión, es decir, si por
ejemplo  hay  un  comando  LoadBrush(1,  "datos/menu.png")  en  su guión, en su
fichero  de  base  de  datos  ha  de  insertarse como "datos/menu.png" (sin las
comillas  dobles  que  únicamente  se  han  añadido en este caso por motivos de
claridad),  ¡no como "menu.png" ni "MisGuiones/JuegoGuay/datos/menu.png" ya que
no  funcionará!   Recuerde, que tanto en su guión como en el fichero de base de
datos  ha  de  especificarse de forma exactamente igual o Hollywood no sabrá de
qué fichero le habla.

Así  que  para  incrustar  el  fichero  "prueba.jpg"  y "titulo.png" en nuestro
ejecutable/miniaplicación,  el fichero de base de datos que pasaremos a nuestro
argumento "-linkfiles" tendrá estas líneas:

  prueba.jpg
  titulo.png

¡Y eso es todo!  El enlazador de Hollywood incrustará los ficheros "prueba.jpg"
y  "titulo.png" en el ejecutable/miniapliación a generar y la citada invocación
a  @{"LoadBGPic()" LINK LoadBGPic} y @{"LoadBrush()" LINK LoadBrush}  en  el guión citado como ejemplo cargará dichos
ficheros  directamente  desde el ejecutable/miniaplicación en lugar de utilizar
una fuente externa.

Lo mismo  puede  conseguirse  utilizando el comando del preprocesador @{"@LINKER" LINK atLINKER},
aplicándose las mismas reglas que para el argumento "-linkfiles", SALVO que los
ficheros  a incrustar no pueden suministrarse a través de un fichero externo de
base  de  datos, sino que han de declararse directamente en su guión como parte
del propio comando del preprocesador @{"@LINKER" LINK atLINKER}, como en este ejemplo:

  \@LINKER {Files = {"prueba.jpg", "titulo.png"}}

Puede  añadir tantos ficheros como quiera para incrustar utilizando la etiqueta
"Files"  citada en el ejemplo.  Asegúrese de que la especificación suministrada
de  la  ruta de acceso a los ficheros es idéntica a la utilizada después dentro
del  código  para  que  Hollywood  pueda  asociar  correctamente los ficheros a
incrustar con los ficheros individuales utilizados en el guión.

Si  necesita  incrustar  multitud  de ficheros en su miniaplicación/ejecutable,
puede  colocarlos  todos  en un directorio e indicarle a Hollywood que incruste
todo  lo  que  hay  dentro  de este.  Esto se realiza utilizando el comando del
preprocesador @{"@DIRECTORY" LINK atDIRECTORY} como se puede ver en el siguiente ejemplo:

  \@DIRECTORY 1, "datos"

Una  vez hecho esto, puede acceder a los ficheros individuales en el directorio
"datos" utilizando la función @{"GetDirectoryEntry()" LINK GetDirectoryEntry}.  Para nuestro ejemplo sería
así:

  LoadBGPic(1, GetDirectoryEntry(1, "datos/prueba.jpg"))
  LoadBrush(1, GetDirectoryEntry(1, "datos/titulo.png"))

El comando  del  preprocesador @{"@DIRECTORY" LINK atDIRECTORY} es muy flexible puesto que permitirá
archivar  el  árbol del directorio completo dentro de un guión/miniejecutable y
así  moverse  a  través  del  directorio (¡y todos los subdirectorios!) como si
fuera uno real.  Consulte @{"@DIRECTORY" LINK atDIRECTORY} para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/LinkingData"}

@ENDNODE
@REMARK =======================================================================
@NODE LinkingFonts "Guía de Hollywood: Incrustación de tipos de impresión *UPD10*"

@{b}Incrustación de tipos de impresión@{ub}

Por  defecto, el enlazador de Hollywood incrustará todos los tipos de impresión
declarados    utilizando   el   comando   del  preprocesador   @{"@FONT" LINK atFONT}   en   el
ejecutable/miniaplicación  a  generar.  Si su guión tiene el siguiente aspecto,
por  ejemplo,  el tipo de impresión "Arial" se incrustará automáticamente en el
ejecutable/miniaplicación:

  \@FONT 1, "Arial", 36
  WaitLeftMouse
  End

Si  no  desea  que  esto  ocurra, puede definir la etiqueta "Link" con el valor
FALSE  y  el  fichero  referenciado  por  el comando del preprocesador no sería
incrustado:   En  este  caso, el tipo de impresión no se incrustará.  El código
ahora tendría el siguiente aspecto:

  \@FONT 1, "Arial", 36, {Link = FALSE}
  WaitLeftMouse
  End

A veces, puede que desee enlazar ficheros que su guión cargue durante el tiempo
de ejecución desde su ejecutable/miniaplicación.  Considere el siguiente código
por ejemplo:

  SetFont("Arial", 36)
  WaitLeftMouse
  End

Por   defecto,   el   tipo   de  impresión  "Arial"  no  se  incrustará  en  su
ejecutable/miniaplicación  ya  que  no  ha  sido  declarado  con un comando del
preprocesador,  sino  que se carga durante el tiempo de ejecución utilizando en
su lugar @{"SetFont()" LINK SetFont}. A pesar de ello, aún es posible incrustar dicho fichero en
su  ejecutable/miniaplicación utilizando el argumento "-linkfonts" o el comando
del preprocesador @{"@LINKER" LINK atLINKER}.

Si  elige utilizar el argumento "-linkfonts", ha de suministrarle un fichero de
base  de  datos.   Dicho fichero es un simple fichero de texto con codificación
UTF-8  que  contiene  una  lista  con  los  tipos de impresión, a incrustar por
Hollywood  en  el  ejecutable/miniaplicación durante el proceso de compilación.
Sólo ha de especificar un tipo de impresión por línea en este fichero.  El tipo
de  impresión  puede ser el nombre de éste o una ruta al fichero *.ttf o *.otf.
Tenga  en  cuenta  que  suministrando  rutas de acceso a estos últimos tipos de
fichero  directamente, ha de utilizar el motor tipográfico interno por que sólo
éste  es capaz de cargar tipos de impresión desde ficheros.  Un ejemplo de base
de datos de tipos de impresión podría tener un aspecto como el siguiente:

  Arial
  "Times New Roman"
  FuturaL
  helvetica
  data/arial.ttf

¡No  olvide utilizar comillas dobles cuando el nombre de los tipos de impresión
incluyan espacios en blanco!

Lo mismo  puede  conseguirse  utilizando el comando del preprocesador @{"@LINKER" LINK atLINKER},
aplicándose las mismas reglas que para el argumento "-linkfonts", SALVO que los
tipos  de  impresión a incrustar no pueden suministrarse a través de un fichero
externo  de  base de datos, sino que han de declararse directamente en su guión
como parte del propio comando del preprocesador @{"@LINKER" LINK atLINKER}, como en este ejemplo:

  \@LINKER {Fonts = {"Arial", "Times New Roman", "FuturaL", "helvetica"}}

Puede añadir tantos tipos de impresión para incrustar como quiera utilizando la
etiqueta "Fonts" citada en la línea de ejemplo.

@{b}Nota  importante@{ub}:   Por  favor,  tenga en cuenta que la mayoría de los tipos de
impresión  están  protegidos  por la legislación (propiedad, derechos de autor,
patentes, marcas, etcétera) y que no se permitir  incrustarlos en sus programas
sin  la  adquisión de una licencia, ¡así que asegúrese de que la licencia de su
tipo de impresión  le permite hacerlo!  Si  no quiere pagar  por  las licencias
de  los tipos de impresión, se aconseja que use  tipos gratuitos  como @{u}DejaVu@{uu} o
@{u}Bitstream  Vera@{uu}  o  que  utilice  los  tipos TrueType  integrados  en Hollywood
(#SANS, #SERIF, #MONOSPACE, véase @{"@SetFont()" LINK SetFont}).


                                                           @{">> Versión original" LINK "HollywoodEN.guide/LinkingFonts"}

@ENDNODE
@REMARK =======================================================================
@NODE LinkingPlugins "Guía de Hollywood: Incrustación de complementos *UPD10*"

@{b}Incrustación de complementos@{ub}

Frente  a  los  ficheros de datos y tipos de impresión, los complementos no son
incrustados de forma automática en su ejecutable cuando éstos son invocados por
los  comandos del preprocesador.  El siguiente ejemplo de código, no forzará al
enlazador a incrustar el complemento "jpeg2000" en su ejecutable:

  \@REQUIRE "jpeg2000"

Si desea que el fichero "jpeg2000.hwp" se incruste en su ejecutable, tendrá que
definir  la  etiqueta  "Link"  como  TRUE.   El código  tendría que tener este
aspecto:

  \@REQUIRE "jpeg2000", {Link = TRUE}

En  este  caso,  el  fichero "jpeg2000.hwp" se incrustará en su ejecutable y el
usuario  no  necesitará  disponer  de una copia de dicho fichero porque ya está
disponible DENTRO de su ejecutable.

Por otro lado, también puede utilizar el argumento de la consola -"linkplugins"
para  incrustar  complementos en su ejecutable: Consulte la sección @{"Argumentos" LINK ManualUsage}
@{"de la consola" LINK ManualUsage} para los detalles.

Tenga  en  cuenta  que  los  complementos  sólo  pueden  ser incrustados en los
ejecutables,   no  en  las  miniaplicaciones,  puesto  que  estas  últimas  son
independientes de la plataforma y los complementos no.

Antes  de  que  pueda utilizar el enlazador de complementos, primero tendrá que
tener  una  copia  de  los  complementos  a  incrustar en un directorio llamado
"LinkerPlugins".   Bajo AmigaOS y sistemas compatibles este directorio se ha de
crear  en  el directorio de la instalación de Hollywood, o sea que su ubicación
será  "Hollywood:LinkerPlugins".  En todos los demás sistemas se ha de crear en
el  directorio  donde  Hollywood ha sido instalado, es decir, en el mismo donde
reside  el  ejecutable  Hollywood.   No  olvide  que  bajo  macOS éste se ha de
encontrar dentro del paquete de aplicación, es decir:

  HollywoodInterpreter.app/Contents/Resources/LinkerPlugins

Además,  tendrá  que  crear la siguiente estructura de subdirectorios dentro de
dicho directorio "LinkerPlugins":

  arm-android-v7a
  arm64-android-v8a
  arm-ios
  arm-linux
  m68k-amigaos
  m881-amigaos
  ppc-amigaos
  ppc-linux
  ppc-macos
  ppc-morphos
  ppc-warpup
  x86-aros
  x86-macos
  x86-linux
  x86-windows
  x86-windows-console
  x64-linux
  x64-macos
  x64-windows
  x64-windows-console

Tras  esto,  tendrá  que  copiar todos los complementos que quiera incrustar en
estos  subdirectorios:   Ha  de  copiar  todos  los  complementos  de todas las
arquitecturas  para  las que quiera generar los ejecutables.  Si no lo hace, el
enlazador  no  será  capaz de encontrar los complementos a incrustar.  Tenga en
cuenta  que  el  enlazador  buscará los complementos sólo dentro del directorio
"LinkerPlugins",  nada  más,  y  más  concretamente, no buscará en la ubicación
estándar de los complementos.

Tenga  en  cuenta  que  cuando  se  generen  ejecutables  para  la arquitectura
"m881-amigaos",  el  enlazador  también buscará en el directorio "m68k-amigaos"
porque  esta  segunda arquitectura es plenamente compatible con la primera.  Lo
mismo  ocurrirá para la arquitectura "ppc-warpup", en la que también se tendrán
en cuenta los directorios "m68k-amigaos" y "m881-amigaos".  Lo mismo sucede con
el  caso  de  los  directorios  "x86-windows-console" y "x86-windows" y con los
directorios "x64-windows-console" y "x64-windows".

@{u}Nota  importante@{uu}:   Asegúrese  de  tener  cuidado  al  leer la licencia de cada
complemento que incruste en su ejecutable porque hay licencias muy restrictivas
con  una  incrustación estática.  Por ejemplo, si enlaza un complemento con una
licencia  LGPL, su proyecto completo se convertirá automáticamente en LGPL, así
que tendrá que suministrar todas las fuentes y ficheros de datos.  Asegúrese de
estudiar las licencias del complemento antes de incrustarlo en sus ejecutables:
¡¡Yo ya le he advertido!!


                                                           @{">> Versión original" LINK "HollywoodEN.guide/LinkingPlugins"}

@ENDNODE
@REMARK =======================================================================
@NODE VideoRecorder "Guía de Hollywood: Grabación de video *UPD10*"

@{b}Guardando guiones como videos@{ub}

Desde  la  versión 4.0 de Hollywood es posible guardar los (resultados visuales
de los) guiones de Hollywood como ficheros de video AVI.  Es útil, por ejemplo,
si  desea  crear  un  DVD  de  sus  guiones  o  simplemente  ejecutarlos en una
plataforma actualmente no soportada por Hollywood.  Guardándolos de esta manera
le  permitirá  también  tratarlos  desde  programas de edición de video para un
posterior procesado o conversión de formato.

La  videograbadora  de  Hollywood  ha  sido  diseñada  con  la idea en mente de
reproducir  exactamente  el  comportamiento (visual) del guión en un fichero de
video.   Así  que  no  apreciará  habitualmente diferencias entre la versión en
formato  de  video  y  el  guión  de Hollywood.  La videograbadora de Hollywood
intenta  reproducir  fielmente  tal  como  se  vería en tiempo real un guión de
Hollywood.   Por  lo  tanto,  no  es problema para la videograbadora lidiar con
guiones   que   requieran   una  temporización  exacta,  por  ejemplo  para  la
sincronización con música.  La videograbadora presta especial atención a ello e
intenta ajustar siempre los tiempos correctamente.

Para  activar  el modo  de  videograbación  simplemente  ha  de especificar @{"el" LINK ManualUsage}
@{"argumento -videoout" LINK ManualUsage}  junto al nombre  de  un fichero para  el video  a crear.
Hollywood  comenzará  el  modo  de  grabación  y  los  gráficos y sonidos serán
redireccionados  como  un  flujo  de  video  (de  ahí  que  en  este modo no se
reproduzca/oiga  ningún  sonido  porque en cuanto es generado es introducido en
dicho  flujo  de  video).   Además,  tenga en cuenta que ciertas opciones serán
ignoradas  cuando  Hollywood  está  en  el  modo  de  videograbación y así, por
ejemplo,  en  este  modo siempre se abrirá en modo de ventana (nunca en modo de
pantalla  completa  incluso  aunque lo especifique), la ventana no permitirá su
cambio de tamaño, etcétera.

El  fichero  de  video generado por la videograbadora será un flujo de datos en
formato AVI 2.0 ajustado al estándar @{u}OpenDML@{uu},  de manera  que flujos mayores de
2 gigaoctetos son posibles.  Hollywood actualmente utiliza el códec Motion JPEG
para comprimir los fotogramas de video.  Los datos de sonido son escritos junto
al  fichero  de  video sin compresión.  Puede controlar la calidad del códec de
video utilizando @{"el argumento -videoquality" LINK ManualUsage}.

Para   conseguir   los  mejores  resultados  puede  necesitar  ajustar  algunos
parámetros en la videograbadora de los que nos ocuparemos ahora:

  1. Primero, se aconseja que le indique a la videograbadora cuántos fotogramas
     por   segundo  han  de  grabarse.   Puede  hacer  esto  con  @{"el argumento" LINK ManualUsage}
     @{"-videofps" LINK ManualUsage}. El valor  que  especifique  aquí  ha  de  ser  idéntico  a  la
     frecuencia  del  bucle  principal  de su guión.  Si, por ejemplo, su bucle
     principal, que llamaremos "p_BuclePrincipal", se ejecuta 25 fotogramas por
     segundo utilizando el siguiente código:

       @{"SetInterval(1, p_BuclePrincipal, 1000\\25)" LINK SetInterval}

     Entonces  su fichero de video debería generarse/visualizarse a 25 FPS, así
     que ha de añadir el siguiente argumento:

       -videofps 25

     en  la línea de comandos para indicarle a la videograbadora que quiere una
     salida de video de una velocidad de 25 fotogramas por segundo.

  2. Puede  querer  especificar  una  resolución  diferente  para el fichero de
     video.   Recuerde  que  la  resolución de video no puede cambiarse:  Ha de
     permanecer invariable durante la generación completa del video.  Hollywood
     puede cambiar la resolución de su visualización en cualquier momento, pero
     no  es  posible para la generación de los ficheros de video, así que si el
     tamaño  de  la visualización de Hollywood cambia mientras el programa está
     en  el  modo  de  videograbación,  los gráficos serán redimensionados para
     mantener  la  resolución correcta de video.  Por defecto, la resolución de
     video  se  definirá como la resolución de la primera imagen de fondo.  Sin
     embargo,  si quiere  una resolución diferente puede especificarla con @{"los" LINK ManualUsage}
     @{"argumentos -scalewidth y -scaleheight" LINK ManualUsage}.

  3. Su   guión   de  Hollywood  ha  de  seguir  ciertas  reglas  para  que  la
     videograbadora   pueda   guardar  éste  como  un  fichero  de  video.   En
     particular, la videograbadora necesita saber si la memoria tampón para los
     fotogramas ha de ser vaciada en el fichero de video.  Normalmente, esto se
     realiza al encontrar un comando de espera, como por ejemplo:

       @{"VWait()" LINK VWait}
       @{"Wait()" LINK Wait}
       @{"WaitEvent()" LINK WaitEvent}
       @{"WaitTimer()" LINK WaitTimer}
       etcétera

     Así,  ¡que  es  necesario  que  utilice  uno de los comandos citados en su
     guión! Su guión necesita utilizar un mecanismo de temporización, o sino no
     podrá  ser  convertido adecuadamente a un fichero de video.  Dentro de los
     mecanismos  sugeridos está la invocación un número de veces por segundo de
     funciones de intervalo  o  el uso de  @{"WaitTimer()" LINK WaitTimer}  y @{"VWait()" LINK VWait}.  Por favor,
     consulte   el  capítulo  sobre  @{"la  temporización  de  guiones" LINK PrgTUTiming}  para  más
     información  sobre  la  importancia  del  uso  correcto  de  un sistema de
     temporización.

     El  vaciado  de  la memoria tampón de los fotogramas, cuando se ejecuta un
     comando  de espera, se llama la estrategia "de espera" (opción "wait") que
     es  la  estrategia  de  video por defecto y la más adecuada para cualquier
     propósito.  Con guiones correctamente temporizados, esta estrategia ofrece
     los  mejores  resultados.   En  algunos  casos muy raros, o para tareas de
     depuración,  podría  querer  utilizar  en  su  lugar la estrategia "bruta"
     (opción "raw"):  En este caso la videograbadora generará cada fotograma en
     el flujo de video sin importar si se utilizan comandos de espera o no, por
     lo  que en la mayoría de los casos, se generarán, naturalmente, videos con
     una  temporización  incorrecta,  lo  que  probablemente conlleve que nunca
     quiera usarla.

  4. Finalmente,  ha  de  decidir  si  el  puntero  del ratón debe ser generado
     gráficamente  o no  en  el flujo de video.  Por defecto,  está desactivado
     porque  la  generación de la imagen del puntero del ratón en el video sólo
     tiene  sentido en situaciones especiales, como por ejemplo si está creando
     un  video  de demostración en el que se muestra la interacción del usuario
     con  la  interfaz.   Para  activar  su  grabación,  utilice  @{"el argumento" LINK ManualUsage}
     @{"-videopointer" LINK ManualUsage}  y  así todos los movimientos  del puntero  del ratón serán
     guardados en el fichero del video.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/VideoRecorder"}

@ENDNODE
@REMARK =======================================================================
@NODE Plugins "Guía de Hollywood: Complementos *UPD10*"

@{b}Complementos@{ub}

La  funcionalidad  de  Hollywood puede ser fuertemente ampliada a través de los
complementos:   Éstos  pueden ofrecer soporte para la lectura/carga y grabación
de  formatos  de  video, audio, imagen y sonido (muestras), ampliar el juego de
comandos  del  lenguaje  Hollywood así como activar/permitir el uso de gráficos
vectoriales  reales  e  incluso es posible escribir complementos que reemplacen
partes  del  núcleo de Hollywood, como la visualización y la gestión del sonido
integradas,  por implementaciones hechas a medida.  También es posible escribir
complementos  que  conviertan  ficheros  de proyecto de otras aplicaciones como
@{u}Scala@{uu}  o  @{u}PowerPoint@{uu}  en guiones de Hollywood, de manera que estos proyectos se
puedan ejecutar directamente a pesar de no ser ficheros en formato HWS.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/Plugins"}

@ENDNODE
@REMARK =======================================================================
@NODE PluginsInstallation "Guía de Hollywood: Instalación de complementos *UPD10*"

@{b}Instalación@{ub}

Los complementos de Hollywood utilizan el sufijo "hwp".  En todos los sistemas,
salvo el AmigaOS y sistemas compatibles, los complementos han de almacenarse en
el  directorio  de  complementos "Plugins" que se encuentra ubicado en el mismo
directorio donde se encuentra el programa principal de Hollywood.  Bajo AmigaOS
y  sistemas  compatibles, los complementos han de instalarse, por contra, en la
ubicación "LIBS:Hollywood".  Bajo macOS, el directorio "Plugins" ha de ubicarse
dentro  del  directorio de recursos "Resources" en el paquete de aplicación, es
decir, en:

  HollywoodInterpreter.app/Contents/Resources

Tenga  en  cuenta  que la aplicación "HollywoodInterpreter.app" está almacenada
dentro del propio paquete de aplicación de "Hollywood.app", denominado:

  Hollywood.app/Contents/Resources

Cuando  distribuya  un  programa  compilado  con  Hollywood,  los  complementos
exigidos  por  su  programa simplemente han de colocarse en el mismo directorio
que  dicho  programa.   Cuando  comple paquetes de aplicaciones para macOS, los
complementos  han  de  colocarse  el  el directorio de recursos "Resources" del
paquete  de  aplicación,  es decir, en MiProyecto.app/Contents/Resources.  Otra
opción es elegir incrustar los complementos en su ejecutable.

La  versión  Android  de  Hollywood  también  soporta  los complementos:  Ha de
copiarlos  en  el  directorio  "Hollywood/Plugins" en su tarjeta SD.  Hollywood
explorará  esta  ubicación  con  cada  puesta  en  marcha  y  cargará todos los
complementos  que allí encuentre.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PluginsInstallation"}

@ENDNODE
@REMARK =======================================================================
@NODE PluginsUsage "Guía de Hollywood: Uso de complementos *UPD10*"

@{b}Uso@{ub}

Hollywood cargará automáticamente los complementos durante su puesta en marcha.
Si no quiere que esto ocurra, puede desactivar la carga automática cambiando el
nombre al complemento: Los complementos cuyo nombre comiencen por un guión bajo
"_"  no  se  cargarán automáticamente durante la puesta en marcha de Hollywood.
Como  alternativa  también puede utilizar @{"el argumento de consola -skipplugins" LINK ManualUsage}
para  que  Hollywood se salte automáticamente la carga de ciertos complementos.
Los  complementos  que  no  se carguen  durante  el arranque,  pueden  cargarse
posterioremente  utilizando  el comando del preprocesador @{"@REQUIRE" LINK atREQUIRE} (consúltelo
para más detalles) o con @{"LoadPlugin()" LINK LoadPlugin}.

Por  favor,  tenga  que  en  cuenta  que  a pesar que Hollywood carga todos los
complementos automáticamente durante su arranque, muchos necesitan ser llamados
con  @{"@REQUIRE" LINK atREQUIRE}  antes  de poder  usarse.   El  motivo  es  debido  a  que estos
complementos necesitan un código de inicialización a medida que sólo se ejecuta
de  forma  explícita  con el comando del preprocesador citado, como por ejemplo
los  complementos que instalan un adaptador de visualización.  Los complementos
que sólo añaden un cargador o grabador adicional a los formatos de fichero, sin
embargo, se activarán automáticamente.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PluginsUsage"}

@ENDNODE
@REMARK =======================================================================
@NODE PluginsObtaining "Guía de Hollywood: Obtención de complementos *UPD10*"

@{b}Obtención de complementos@{ub}

Muchos  complementos  están  disponibles  en  línea,  en  el  portal oficial de
Hollywood en la dirección http://www.hollywood-mal.com/.  Aquí tiene un resumen
de los complementos actualmente disponibles allí:

  @{u}AHX@{uu}

  Permite  cargar  y  reproducir,  con  Hollywood,  módulos  en  formato  AHX e
  HivelyTracker.

  @{u}AIFF@{uu}

  Permite cargar y reproducir, con Hollywood, muestras en formato AIFF.

  @{u}APNG Anim@{uu}

  Permite  cargar  y  guardar,  con Hollywood, animaciones en formato APNG:  Es
  útil, porque el formato APNG soporta animaciones con canal alfa.

  @{u}AVCodec@{uu}

  Añade cargadores de muchos formatos de video y audio ofrecidos por el paquete
  FFMPEG:  Es muy útil para reproducir formatos de video y audio modernos, pero
  tenga  cuidado  ya  que  muchos  están  patentados  y exigen pagar regalías o
  licencias si los usa en sus productos.

  @{u}DigiBooster@{uu}

  Carga y reproduce, con Hollywood, módulos en formato DigiBooster.

  @{u}FLIC Anim@{uu}

  Carga, con Hollywood, animaciones en formato FLI y FLC.

  @{u}GL Galore@{uu}

  Envoltorio  OpenGL® para Hollywood.  Este complemento le permite programar en
  OpenGL  utilizando Hollywood y soporta la generación acelerada de gráficos 2D
  a  través  de  la  circuitería,  lo  que significa soportar el doble tampón a
  través de la circuitería  y  las brochas electrónicas.  Por ello, es muy útil
  al  generar  gráficos  bajo  Windows,  macOS  y  Linux,  ya  que por defecto,
  Hollywood   sólo   soporta  la  generación  de  gráficos  acelerados  por  la
  circuitería bajo AmigaOS y sistemas compatibles.

  @{u}HTTP Streamer@{uu}

  Este  complemento  le  permite cargar datos desde fuentes HTTP como si fuesen
  ficheros   normales:    Eso  significa  que  una  vez  tenga  instalado  este
  complemento,  podrá suministrar  una  URL a funciones como @{"LoadBrush()" LINK LoadBrush} y los
  ficheros  se  cargarán desde ésta.  Este complemento también puede utilizarse
  para flujos de video y audio desde fuentes HTTP.

  @{u}Iconic@{uu}

  Este  complemento es el definitivo en cuanto a cargar y guardar de iconos, ya
  que  soporta  una  gran  variedad  de formatos:  AmigaOS1.x, AmigaOS 2.x/3.x,
  AmigaOS  3.5  (también conocidos como GlowIcons), AmigaOS 4.0, macOS (formato
  *.icns),  MagicWB,  MorphOS/PowerIcons  (PNG),  NewIcons  e iconos de Windows
  (formato *.ico).

  @{u}hURL@{uu}

  Este  complemento,  basado  en  curl,  le permite transferir datos utilizando
  multitud  de  protocolos  diferentes:   DICT,  FILE, FTP, FTPS, Gopher, HTTP,
  HTTPS,  IMAP,  IMAPS,  LDAP,  LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB,
  SMBS,  SMTP,  SMTPS,  Telnet  y  TFTP.  Además soporta certificados SSL, HTTP
  POST,  HTTP  PUT,  envíos  FTP,  formulario HTTP basado en envíos, servidores
  apoderados,    HTTP/2,    galletas    de    configuración,    autentificación
  usuario+contraseña   (Basic   -básica-,  Plain  -simple-,  Digest  -resumen-,
  CRAM-MD5,   NTLM,   Negotiate   -negociado-   y   Kerberos),  reanudación  de
  transferencia  de  ficheros, tunelización de apoderado y más.  Es el motor de
  transferencia de datos definitivo de Hollywood al que no le falta nada.

  @{u}JPEG2000@{uu}

  Carga y guarda imágenes en formato JPEG2000.

  @{u}Malibu@{uu}

  Este  complemento  le  permite  ejecutar  los  guiones de Scala en Hollywood.
  Malibu soporta todas las versiones de Scala para Amiga incluyendo Scala MM400
  y Scala InfoChannel 500.

  @{u}Movie Setter@{uu}

  Abre y reproduce animaciones en el formato MovieSetter de Gold Disk.

  @{u}MUI Royale@{uu}

  Es  un  potente  complemento  que  permite acceder a casi toda la interfaz de
  desarrolladores de la "Magic User Interface" o MUI, creada por Stefan Stuntz,
  desde Hollywood, pudiendo crear interfaces vía XML.

  @{u}Ogg Theora@{uu}

  Carga y reproduce, con Hollywood, flujos de video en formato Ogg Theora.

  @{u}Ogg Vorbis@{uu}

  Carga y reproduce, con Hollywood, flujos de sonido en formato Ogg Vorbis.

  @{u}PCX@{uu}

  Carga, con Hollywood, imágenes en formato PCX.

  @{u}Plananarama@{uu}

  Utilice  Hollywood  en  sistemas  Amiga SIN una tarjeta gráfica.  Si necesita
  ejecutar  Hollywood  sobre pantallas basadas en una paleta, podrá hacerlo con
  este complemento.

  @{u}Polybios@{uu}

  Es  un  complemento  que le permite crear fácilmente documentos PDF desde sus
  guiones  de  Hollywood.   Destaca  su  capacidad  de  abrir documentos PDF ya
  existentes  y convertir sus páginas en brochas vectoriales de Hollywood (para
  que puedan redimensionarse, rotarse y transformarse sin pérdida de calidad, a
  menos  claro,  que  incluya  gráficos  de mapa de bits incrustadod dentro del
  documento PDF).

  @{u}RapaGUI@{uu}

  Paquete   de  herramientas  multiplataforma  para  desarrollo  de  interfaces
  gráficas  de usuario bajo Hollywood (realizando su maquetación a través de un
  fichero   XML).    Además,   las  visualizaciones  de  Hollywood  pueden  ser
  incrustadas  en  su  interfaz  como  si  fuesen  artilugios  de  la  ventana,
  permitiendo  utilizar  todas las poderosas prestaciones gráficas de Hollywood
  en su interfaz gráfica.

  @{u}RebelSDL@{uu}

  Envoltorio para Hollywood de la popular biblioteca SDL.  El gran beneficio es
  que  soporta  generación acelerada de gráficos 2D a través de la circuitería,
  lo  que  significa  soportar el doble tampón a través de la circuitería y las
  brochas  electrónicas.   Por  ello,  es  muy  útil  al  generar gráficos bajo
  Windows,  macOS  y  Linux,  ya  que  por  defecto,  Hollywood sólo soporta la
  generación  de gráficos acelerados por la circuitería bajo AmigaOS y sistemas
  compatibles.

  @{u}SID@{uu}

  Le permite cargar y reproducir ficheros SID.

  @{u}SQLite3@{uu}

  Crea y modifica, con Hollywood, bases de datos SQL.

  @{u}SVG@{uu}

  Carga, con Hollywood, imágenes vectoriales en formato SVG.

  @{u}TIFF@{uu}

  Carga y guarda, con Hollywood, imágenes en formato TIFF.

  @{u}Vectorgraphics@{uu}

  Genere gráficos vectoriales reales con Hollywood.

  @{u}XAD@{uu}

  Este  complemento  le  permite desempaquetar multitud de formatos de paquetes
  diferentes como LhA, LZX, RAR, ZIP, TAR, etcétera.  Un complemento muy útil.

  @{u}XLSX@{uu}

  Le  permite  leer  y escribir documentos XLSX desde los guiones de Hollywood.
  Ofrece   una   amplia   variedad   de   funciones   para  definir  y  obtener
  valores/fórmulas  de las celdas, sus tipos, propiedades del documento o de la
  hoja  y  multitud  de  otros atributos.  También ofrece una función iteradora
  para  obtener  una  gran  rendimiento cuando se trabaja con un gran número de
  celdas.

  @{u}XML@{uu}

  Complemento para procesar adecuadamente documentos XML.

  @{u}XMP@{uu}

  Este  complemten  puede  reproducir gran numero de formatos de música creados
  con programas de composición musical por pistas.

  @{u}YAFA@{uu}

  Carga  y  reproduce,  con  Hollywood, animaciones en formato YAFA, creado por
  Wildfire.

  @{u}ZIP@{uu}

  Este complemento le permite leer y escribir paquetes en formato ZIP.


                                    --==--

              ¹ Nota del traductor: Literalmente "GL a tutiplén".


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PluginsObtaining"}

@ENDNODE
@REMARK =======================================================================
@NODE SDK "Guía de Hollywood: Paquete de desarrolladores para Hollywood *UPD10*"

@{b}Escribiendo sus propios complementos@{ub}

En  caso  de  que eche de menos alguna prestación o funcionalidad en Hollywood,
puede  escribir  un  complemento que la añada al lenguaje.  También puede serle
útil  hacerlo  en  el  caso de que su guión necesite realizar realizar cálculos
intensivos  en el microprocesador, ya que que pueden ser mejor implementados en
código nativo para un rendimiento óptimo.

Escribirlos  es  realmente fácil:  La interfaz de los complementos de Hollywood
es  pública,  está totalmente documentada y todos los ficheros necesarios están
disponibles  como  descarga libre y gratuita en el portal oficial del lenguaje.
Este  paquete  para  desarrolladores,  también  conocido técnicamente como SDK,
incluye  unas 300 páginas de documentación detallada y multitud de ejemplos que
le ayudarán a iniciar el desarrollo de su complemento.

Por  favor,  para  ello  visite  el portal oficial de Hollywood en la dirección
http://www.hollywood-mal.com/.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/SDK"}

@ENDNODE
@REMARK =======================================================================
@NODE History "Guía de Hollywood: Historia *UPD10*"

@{b}Historia@{ub}

Por  favor,  lea  la  sección  histórica hacia atrás comenzando desde el final.
Tenga  en  cuenta  que  esta  sección podrá hacer referencia a prestaciones que
fueron  implementadas  en  versiones  beta  y luego eliminadas, pero que aún se
siguen  mencionando  aquí.   Esta  historia es un registro del programador, así
éste  puede  buscar lo que ha hecho, probado o modificado.  Aquello que ha sido
implementado y luego eliminado/anulado ha sido etiquetado como @{i}[VOID]@{ui}.

            Nota del traductor: En la revisión histórica en inglés,
          @{i}fix@{ui} significa que es una corrección de un error o problema,
                 @{i}change@{ui} significa la realización de un cambio,
            @{i}new@{ui} significa la incorporación de una nueva prestación.

-------------------------------------------------------------------------------

                       @{"Historia de Hollywood (en inglés)" LINK "HollywoodEN.guide/History"}

-------------------------------------------------------------------------------

[...]

Versión 1.0   (04-Nov-2002)

- Primera versión


                                                           @{">> Versión original" LINK "HollywoodEN.guide/History"}

@ENDNODE
@REMARK =======================================================================
@NODE APIChanges "Guía de Hollywood: Cambios en la interfaz para programadores *UPD10*"

@{b}Notas de compatibilidad@{ub}


@{u}@{i}Cambios en la interfaz para programadores de Hollywood 9.0@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  9.0.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  esta  versión.   Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación:

- Bajo  AmigaOS  y  compatibles, los ejecutables compilados por Hollywood ya no
  cargarán  automáticamente  los  complementos  instalados en "LIBS:Hollywood":
  Sólo cargarán los almacenados en el directorio del ejecutable.  Si quiere que
  vuelvan  a  comportarse  como antes ha de definir la etiqueta "GlobalPlugins"
  como  TRUE  en  el comando  del  preprocesador  @{"@OPTIONS" LINK atOPTIONS}  o  suministrar  el
  argumento  de consola (o tipo de herramienta) @{"-globalplugins" LINK ManualUsage}.

- Bajo  Windows, el motor de gráficos de Hollywood ha sido reescrito totalmente
  y  ahora  utiliza  Direct2D.   Esto  tiene  múltiples ventajas y también hace
  posible  utilizar  el  procesador  de  la  tarjeta gráfica cuando el motor de
  redimensionado  automático está activo.  En algunos raros casos, sin embargo,
  su  guión  podría  ser más lento que antes, dependiendo de cómo se realice la
  generación  de gráficos.  Si su guión se ejecuta más lentamente con Hollywood
  9.0,  puede forzar a Hollywood a que utilice el sistema antiguo de generación
  de gráficos que aún se soporta por cuestiones de compatibilidad con versiones
  de  Windows que no soportan Direct2D (es decir todas las versiones anteriores
  a  Vista  SP2)  o adaptar la forma en que su guión dibuja sus gráficos.  Para
  activar  el  viejo motor, basta con que defina la etiqueta "SoftwareRenderer"
  como  TRUE  en  @{"@DISPLAY" LINK atDISPLAY}.  Si  opta  por  adaptar la forma en que dibuja sus
  gráficos,  tenga  en  cuenta  que  bajo  Direct2D, cada operación de dibujado
  siempre  provocará  un  refresco completo de la visualización, incluso aunque
  sólo  tenga que dibujar ¡un simple píxel!...  por ello, su guión debe generar
  sus  gráficos  de  forma  que minimice los refrescos y esto puede conseguirse
  utilizando   una   doble   memoria   tampón  o  utilizando  @{"BeginRefresh()" LINK BeginRefresh} y
  @{"EndRefresh" LINK EndRefresh}: Consúltelos para más detalles.

- Bajo Windows, Hollywood ahora redimensionará automáticamente sus guiones para
  que su visualización encaje en la resolución del monitor en monitores con una
  gran   densidad  de  puntos  por  pulgada,  garantizándose  que  sus  guiones
  aparecerán  con  el tamaño correcto.  Si no quiere que esto ocurra, defina la
  nueva etiqueta "DPIAware" como TRUE en el comando del preprocesador @{"@OPTIONS" LINK atOPTIONS}
  (esto  es  especialmente  recomendado  en  aplicaciones  que  sean interfaces
  gráficas del ususario pues suelen verse mejor)

- Los  cargadores y adaptadores ahora son manejados en el orden que aparecen en
  la  cadena  que  se  suministra  a  través de la tabla de argumentos opcional
  "Loader" o "Adapter".  Por ejemplo, si suministra la cadena "digibooster|xmp"
  a   @{"OpenMusic()" LINK OpenMusic},   primero   se  intentará   abrir   la   música  utilizando
  digibooster.hwp  y  sólo  si  éste  falla  se utilizará xmp.hwp para abrir el
  fichero.   Esto  también  le permite dar prioridad a los cargadores genericos
  como  "Native"  (nativo),  "Inbuilt"  (interno)  y "Plugin" (complemento), es
  decir,  que si quiere que los cargadores nativos o internos se usen antes que
  los  de los complementos, ha de suministrar la cadena "native|inbuilt|plugin"
  para  conseguirlo.  Tenga en cuenta que, sin embargo, esto es un cambio en la
  interfaz de programadores y que probablemente no haya guiones que dependan de
  cómo  se  comportaba antes Hollywood (que era esencialmente un funcionamiento
  aleatorio habitualmente).

- Cuando una ruta no existente se suministraba a @{"ChangeDirectory()" LINK ChangeDirectory}, la función
  fallaba  de forma silenciosa y no mostraba error alguno.  Este comportamiento
  ahora ha cambiado, de manera que ahora sí genera un error.

- Cuando @{"CopyFile()" LINK CopyFile} no podía copiar un fichero porque éste ya existía y estaba
  protegido contra escritura o borrado, simplemente se saltaba dicho fichero de
  forma  silenciosa.  Ahora, ya no se hace, de manera que se genera un error si
  el  fichero  no puede ser sobreescrito.  Si necesita volver al comportamiento
  anterior,  utilice una función de retrollamada y devuelva FALSE cuando quiera
  obtener un mensaje #COPYFILE_UNPROTECT.

- El argumento  opcional  "transcolor" en @{"SaveBrush()" LINK SaveBrush} ahora tiene el valor por
  defecto  #NOCOLOR, en lugar de #BLACK, ya que el antiguo valor por defecto no
  tenía mucho sentido.

- @{"SaveAnim()" LINK SaveAnim},  @{"BeginAnimStream()" LINK BeginAnimStream}   y  @{"WriteAnimFrame()" LINK WriteAnimFrame}  ya  no  soportan  las
  etiquetas "Transparency" y "UseAlpha" porque no tiene sentido.  Estos ajustes
  ahora son determinados únicamente por el formato de la fuente de datos que se
  suministre a estas funciones.

- Cuando "KeepProportions" está activo para una visualización y @{"DisplayBGPic()" LINK DisplayBGPic}
  o @{"ChangeDisplaySize()" LINK ChangeDisplaySize}  son  invocados,  el tamaño de redimensionado ahora es
  recalculado  para  encajar  en  el relación de aspecto de  la nueva imagen de
  fondo  o  en  el  tamaño  de  la visualización.  Este cambio también afecta a
  @{"SetDisplayAttributes()" LINK SetDisplayAttributes}  cuando  es llamado  con  los  parámetros  "Width"  y
  "Height".

- Si la etiqueta "Monitor" no está definida en la tabla de argumentos opcional,
  @{"ChangeDisplayMode()" LINK ChangeDisplayMode} ahora  detectará  siempre  sobre qué monitor se ejecuta.
  Así   que   si   esto   ocurre   en   un   monitor   secundario   y  llama  a
  ChangeDisplayMode(#DISPMODE_FULLSCREEN),  ese  monitor  se  pondrá en modo de
  pantalla  completa.  Anteriormente, siempre era el primer monitor el afectado
  (salvo si se había definido la etiqueta "Monitor" para la visualización).

- Los videos manejados por el sistema de generación de video nativo del sistema
  operativo (es decir, DirectShow y Media Foundation bajo Windows, AVFoundation
  y  QuickTime  bajo  macOS),  ahora  son redimensionados de forma automática y
  reposicionados  cuando  una  visualización  es redimensionada por el usuario,
  incluso si no hay un motor de redimensionado activo...  y sólo éstos (los que
  usan  el  sistema  integrado  de Hollywood, no).  Esto se hace por cuestiones
  puramente  estéticas,  porque  de otra forma tendrían un aspecto feos.  Puede
  prohibir   este  comportamiento  definiendo  la  etiqueta  "NoLiveResize"  en
  @{"@DISPLAY" LINK atDISPLAY}.


@{u}@{i}Cambios en la interfaz para programadores de Hollywood 8.0@{ui}@{uu}

No hay cambios.


@{u}@{i}Cambios en la interfaz para programadores de Hollywood 7.1@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  7.1.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  esta  versión.   Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación:

- Se  han  realizado  algunos  pequeños  cambios el formato independiente de la
  plataforma  de  los  catálogos:

  * Las líneas que empiezan por un punto y coma ahora se consideran comentarios
    y son ignoradas (si necesita definir una cadena de catálogo que empiece por
    un punto y como, preceda éste con una barra invertida).

  * Las líneas en blanco ahora se ignorarán.

  * Las  cadenas  que  terminen en una barra invertida se consideran cadenas de
    múltiples líneas.

  Debido a esto podría ser necesario que corrigiese sus catálogos para hacerlos
  compatibles  con  el  nuevo formato. Consulte la sección sobre @{"el formato de" LINK CatalogFormatNote}
  @{"los catálogos" LINK CatalogFormatNote} para los detalles.


@{u}@{i}Cambios de ubicación en la versión 7.0 de Hollywood@{ui}@{uu}

Lo  primero de todo, es que los usuarios de Windows, macOS y Linux han de tener
en  cuenta  que  los  complementos  de  Hollywood  han  de  almacenarse  en  el
subdirectorio  de  complementos  "Plugins"  y  que éste ha de estar en el mismo
directorio  donde se encuentra el ejecutable de Hollywood tanto en Windows como
en  Linux.  Bajo macOS, este directorio ha de encontrarse dentro del paquete de
aplicación, es decir dentro del directorio:

  HollywoodInterpreter.app/Contents/Resources/Plugins

Tenga  en  cuenta  que la aplicación "HollywoodInterpreter.app" está almacenada
dentro del paquete de aplicación de "Hollywood.app", o sea, en:

  Hollywood.app/Contents/Resources

Bajo  Android,  los  complementos  han  de  almacenarse  dentro  del directorio
"Hollywood/Plugins"  en su tarjeta SD (en lugar de "Hollywood/_Plugins" como en
versiones  anteriores).   Bajo AmigaOS y sistemas compatibles, los complementos
han de copiarse en "LIBS:Hollywood" como siempre.

Sin  embargo, tenga en cuenta que para los ejecutables compilados con Hollywood
se  seguirán  cargando  los complementos del mismo directorio que el ejecutable
(excepto  bajo  macOS en donde lo harán desde dentro del directorio "Resources"
del paquete de aplicación).

Los   usuarios   de  macOS  han  de  tener  en  cuenta  que  el  fichero  llave
"Hollywood.key" ha de ser copiado también en:

  HollywoodInterpreter.app/Contents/Resources

y no en

  HollywoodInterpreter.app/Contents/MacOS

como antes.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 7.0@{ui}@{uu}

Desde  esta  versión  Hollywood  soporta  la codificación Unicode lo que podría
provocar  algunos  problemas  de  compatibilidad con sus viejos guiones.  Si no
quisiera  adaptarlos,  bastaría con que los ejecutase activando el modo clásico
que desactiva el soporte Unicode mencionado, añadiendo como la primera línea de
su guión la siguiente:

  \@OPTIONS {Encoding = #ENCODING_ISO8859_1}

Su  guión  se  ejecutaría  en el modo ISO 8899-1 lo que significa que podría no
funcionar correctamente en sistemas que no sean de Europa Occidental.  Por ello
se   recomienda  no  utilizar  esta  triquiñuela,  sino  que  adapte  su  guión
introduciendo el soporte de Unicode de forma permanente.

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  7.0.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 7.0.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación:

- En  primer  lugar,  guarde  todos sus guiones con codificación UTF-8.  Cuando
  ejecute  viejos  guiones  con  Hollywood  7.0,  éste  comprobará  primero  si
  contiene  caracteres  con codificación UTF-8:   Si  no es así, asumirá que la
  codificación  es  la ISO 8859-1 (o el sistema de codificación por defecto del
  Amiga)  y  lo convertirá a la codificación UTF-8 automáticamente.  Puesto que
  esta  conversión  automática  podría  provocar  problemas con los guiones que
  utilicen  una  codificación diferente a la ISO 8859-1 es muy recomendable que
  los guarde todos con la codificación UTF-8.

- Desde  esta versión, Hollywood se ejecuta por defecto en el modo Unicode y la
  codificación  de  las cadenas por defecto se define como #ENCODING_UTF8.  Eso
  significa que surgirán problemas si su guión intenta utilizar funciones de la
  biblioteca  de  cadenas para acceder a  datos binarios sin procesar dentro de
  las cadenas.  Cuando  la codificación está definida como  #ENCODING_UTF8, las
  funciones  de  la  biblioteca  de  cadenas sólo podrán lidiar con cadenas que
  tengan  texto UTF-8  válido.   En  Hollywood, sin embargo, las cadenas pueden
  contener datos binarios, como por ejemplo para descargar un fichero y guardar
  su contenido  en una cadena utilizando @{"DownloadFile()" LINK DownloadFile} y calcular su longitud
  con @{"StrLen()" LINK StrLen}:   Eso  no  funcionará cuando Hollywood se encuentre en el modo
  Unicode  (es  decir,  cuando  la codificación por defecto de las cadenas esté
  definida  como  #ENCODING_UTF8),  ya  que  StrLen() esperará una secuencia de
  datos  UTF-8  válida  algo  que  no  se  cumple con los datos binarios.  Para
  esquivar  este  problema,  puede  suministrar  la  constante  #ENCODING_RAW a
  @{"StrLen()" LINK StrLen}  para informarle que la cadena a evaluar contiene datos binarios en
  bruto en lugar de una texto UTF-8 válido.  Así mismo, ahora la mayoría de las
  otras  funciones  de  la  biblioteca  de cadenas también aceptan el parámetro
  adicional  de  codificación  que  puede utilizar para aclara qué codificación
  utiliza la cadena que suministre.  Si su guión no utiliza las funciones de la
  biblioteca  de  cadenas  para operar con datos binarios sin procesar, no debe
  preocuparse  por  nada  y  su  guión  debería funcionar sin fallos en el modo
  Unicode.

- La  codificación  por  defecto  del texto ahora está definida automáticamente
  como #ENCODING_UTF-8  con  Hollywood.   Esto  significa  que  funciones  como
  @{"TextOut()" LINK TextOut} y @{"Print()" LINK Print}  esperarán  texto  con dicha  codificación.   No  es un
  problema  convertir  su  guión  a  UTF-8, pero podrían surgir problemas si el
  texto  a  imprimir  se  lee  de un fichero o fuente externa que no utilice la
  codificación UTF-8.

- @{"ReadChr()" LINK ReadChr} y @{"WriteChr()" LINK WriteChr} ahora pueden leer y escribir hasta cuatro octetos en
  lugar de un único octeto si Hollywood está en el modo Unicode: Esto es debido
  a  que  ahora  estas funciones pueden lidiar realmente con caracteres como su
  nombre  indica  y  al estar  codificados en formato UTF-8 puede ser necesario
  utilizar  hasta  cuatro octetos para almacenarlos.  Si quiere leer y escribir
  octetos   individuales,  ahora utilice  las  nuevas funciones @{"ReadByte()" LINK ReadByte}  y
  @{"WriteByte()" LINK WriteByte}.

- @{"ReadString()" LINK ReadString} y @{"WriteString()" LINK WriteString}  ya  no pueden usarse para E/S binarias, porque
  leen y escriben cadenas, es decir, una secuencia de caracteres, ¡no octetos!,
  tal  como indica  el  propio  nombre  de  las  funciones.  Si necesita leer y
  escribir datos  binarios  sin  procesar,  ahora  utilice las nuevas funciones
  @{"ReadBytes()" LINK ReadBytes} y @{"WriteBytes()" LINK WriteBytes}.

- @{"ReadChr()" LINK ReadChr}, @{"WriteChr()" LINK WriteChr}, @{"ReadString()" LINK ReadString} y @{"WriteString()" LINK WriteString}  ahora leen y escriben
  caracteres UTF-8  por defecto.  Si los utiliza para leer datos de ficheros de
  texto  sin codificación  UTF-8,  puede  haber problemas con los caracteres no
  ASCII.  En este caso, ha de indicar a estas funciones que lean caracteres con
  codificación  ISO  8859-1 suministrándole la constante #ENCODING_ISO8859_1 en
  el argumento opcional de codificación.

- No se recomienda el uso de los manejadores de eventos "OnKeyDown" y "OnKeyUp"
  para  caracteres  no ingleses.  Los caracteres no ingleses han de gestionarse
  con  el nuevo  manejador de eventos "VanillaKey" que incluye  soporte Unicode
  completo.   "OnKeyDown"  y "OnKeyUp" continuarán funcionando como antes, pero
  el uso de caracteres no ingleses no es, en general, seguro:  Podría funcionar
  en  su  sistema  pero no en otros con un sistema local diferente.  Por favor,
  utilice sólo "VanillaKey" para manejar los caracteres no ingleses.

- Las funciones @{"IsKeyDown()" LINK IsKeyDown} y @{"WaitKeyDown()" LINK WaitKeyDown} ya no soportan teclas no inglesas.
  Si  necesita  obtener el estado de una tecla no inglesa, utilice el manejador
  de eventos "VanillaKey" en su lugar.

- El formato neutro en cuanto a plataforma, soportado por @{"OpenCatalog()" LINK OpenCatalog}, ahora
  ha de utilizar la codificación de carácter UTF-8 con o sin BOM.  Los ficheros
  ISO 8859-1 ya no se soportan.

- Las constantes de carácter multiocteto como 'ABCD' ya no se soportan debido a
  que entran en conflicto con las constantes de carácter UTF-8 soportadas ahora
  por Hollywood.  Si su guión las utiliza, ha de reescribirse para usar en
  su lugar el valor numérico directo de la constante de carácter.

- Se  introduce la sentencia  @{"FallThrough" LINK PrgSwitch}  que  permite  al código saltar a la
  siguiente sentencia @{"Case" LINK PrgSwitch} en un bloque condicional @{"Switch-Case" LINK PrgSwitch}. Esta adición
  significa  que ya no se permite el uso de variables o funciones con el nombre
  "FallThrough",  generándose  en este caso un error si existen, al convertirse
  en un identificador reservado.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 6.0@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  6.0.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 6.0.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- A  partir  de  Hollywood  6.0  se  incluye  soporte  integrado para el dibujo
  vectorial de manera que la biblioteca correspondiente ya no utiliza el primer
  complemento  de  gráficos vectoriales que pueda encontrar.  En su lugar ahora
  se  utilizará  por  defecto  el  sistema  generador  de  gráficos vectoriales
  integrado de Hollywood: Invoque a @{"SetVectorEngine()" LINK SetVectorEngine} si no desea que esto sea
  así señalándole qué motor de gráficos vectoriales quiere utilizar.

- El comando @{"ChangeDisplayMode()" LINK ChangeDisplayMode} ya no coloca todas las visualizaciones en una
  única  pantalla  completa,  sólo  lo hace con la activa.  Este cambio ha sido
  necesario  ya que esta versión de Hollywood introduce el soporte de múltiples
  monitores  lo  que  hace  posible disponer de múltiples visualizaciones en el
  modo de pantalla completa en monitores separados.

- El  manejador  de  la  visualización  de  Hollywood ha sido reescrito y ya no
  soporta el modo de visualización "OwnScreen".  Este modo era un modo especial
  que  podía  utilizarse  bajo  AmigaOS  y  sistemas compatibles para hacer que
  Hollywood  se  abriese  en  el modo de pantalla completa, pero conservando el
  aspecto  de  pantalla  clásico  del  Amiga,  es decir, Hollywood no abría una
  ventana  protegida  que cubría los elementos "decorativos" de la pantalla del
  Amiga.   Si  quiere  disponer  de  un  aspecto similar al de la visualización
  "OwnScreen" bajo Hollywood 6.0,  tendrá que usar los argumentos de la consola
  @{"-nobackfill" LINK ManualUsage} y @{"-nostyleoverride" LINK ManualUsage} conjuntamente junto a -fullscreen.

- En versiones anteriores los atributos de visualización especificados a través
  del comando  del  preprocesador  @{"@DISPLAY" LINK atDISPLAY} tenían preferencia automáticamente
  sobre los especificados a través de la línea de comandos, es decir, que si el
  atributo  "Borderless"  que  elimina  el  borde de la ventana se definía como
  FALSE a través  de  @{"@DISPLAY" LINK atDISPLAY}  y se utilizaba  el argumento -borderless,  el
  guión  mostraría  una  ventana  con  borde  porque  las  especificaciones  de
  @{"@DISPLAY" LINK atDISPLAY}  tenían  preferencia  sobre los argumentos de la línea de comandos:
  Esto  ya  no es así.  Si no desea este nuevo comportamiento, compile su guión
  utilizando  @{"el  modo -locksettings" LINK ManualUsage}  y  así  los  argumentos  de la línea  de
  comandos  no interferirán con los ajustes de la visualización hechos a través
  del comando del preprocesador.

- En  versiones anteriores los argumentos de la línea de comandos que afectaban
  al  estilo  de  la  visualización  se  aplicaban  a todas las visualizaciones
  definidas  en  los  comandos  del preprocesador de su guión.  Por ejemplo, si
  comenzaba  un  guión  que  definía  cuatro  visualizaciones  a  través de los
  comandos  del  preprocesador  con  @{"el argumento -borderless" LINK ManualUsage},  las cuatro  se
  abrían  en  dicho  modo.   Bajo  Hollywood  6.0 los argumentos de la línea de
  comandos  que  modifican  el  estilo  de  visualización  sólo se aplican a la
  visualización  nº 1  por  defecto.    Si  desea   que  afecten  a  todas  las
  visualizaciones, ha de utilizar @{"el nuevo argumento -alldisplays" LINK ManualUsage}.

- Algunos  argumentos  de la línea de comandos han sido renombrados por razones
  puramente  cosméticas:   -audiodev ahora se llama -audiodevice y -depth ahora
  se llama -scrdepth.  Su funcionalidad no ha cambiado.

- Se  ha  abandonado  el soporte de la biblioteca MPEGA bajo AmigaOS y sistemas
  compatibles:   Esta  biblioteca  causaba  bastante  problemas  debido  a  que
  habitualmente  reconocía  cualquier fichero  como un flujo MPEG  generando un
  buen montón de efectos  indeseados.  Si  desea reproducir  MP3 basta  con que
  utilice el complemento "avcodec.hwp" en su lugar.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 5.0@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  5.0    En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 5.0   Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- La  interfaz  para  complementos  ha  sido completamente reescrita y ya no es
  compatible  con  las  versiones antiguas de éstos.  En los ordenadores Amiga,
  los  complementos  ahora han de estar siempre instalados en "LIBS:Hollywood".
  La  vieja  ubicación  de los complementos "Hollywood:Plugins" ya no es válida
  con  la  versión 5.0 de Hollywood.  Alternativamente, los complementos pueden
  ser instalados en el directorio del programa (especialmente útil cuando ha de
  distribuir complementos con ejecutables compilados por Hollywood).

- Los  efectos  de  borde  y  sombra  en las capas tendrán un aspecto diferente
  (¡mejor!)  en  comparación  con  versiones previas porque ahora Hollywood usa
  para  ello  la  composición  del  canal alfa real.  Lo malo es que los nuevos
  efectos de borde y sombra son más lentos que en versiones anteriores.

- La  sombra  y  borde  ahora  tiene  ajustes  globales  para  cada capa.  Esto
  significa  que  ya  no  puede  tener capas con múltiples sombras o estilos de
  borde  (por  ejemplo  una  capa de texto donde sólo parte del texto tiene una
  sombra  o  borde).  Ya no se soporta:  Ahora la capa tiene una sombra/borde o
  no  la tiene, de manera que ya no es posible tener una sombra/borde para sólo
  una parte de una capa.

- Ahora  las capas con un borde se visualizarán de forma diferente cuando estén
  visibles u ocultas con una transición.  Debido a que el borde ya no es parte
  de  la  capa  principal  de  Hollywood 5.0, la transición para el borde ya no
  puede  ser  combinado  con  el  de  la  capa principal.  Así, ahora Hollywood
  simplemente  realizará  un  fundido entrante o saliente del borde mientras el
  efecto  de  la  capa  principal  se  esté  visualizando.  Si no le gusta este
  comportamiento, puede utilizar la nueva etiqueta "NoBorderFade".

- Por razones de consistencia, Hollywood  ya no soporta capas gruesas cuando el
  estilo de relleno se define como #FILLNONE, porque el propio concepto de capa
  gruesa colisiona con el nuevo concepto de capa de borde.  Así, en lugar de un
  ajuste  de grosor, las capas ahora tendrán un borde del "grosor" especificado
  para  hacerlo  más grueso.  La capa principal, sin embargo, siempre tendrá un
  grosor  de  1.  Si quiere incrementar su grosos, basta con que active la capa
  de borde y defina el grosor deseado en la etiqueta "BorderSize".

- Puesto  que  Hollywood  5.0  introduce  el soporte para imágenes vectoriales,
  @{"CreateGradientBGPic()" LINK CreateGradientBGPic}  y  @{"CreateTexturedBGPic()" LINK CreateTexturedBGPic}  ahora  creará  una  imagen
  vectorial de fondo  para usted.  Esto significa que ya no puede modificar los
  gráficos  de  estas imágenes  de fondo utilizando  la función @{"SelectBGPic()" LINK SelectBGPic}.
  Otra  diferencia  es  que  cuando  una  imagen de fondo con textura cambia de
  tamaño  (por  ejemplo cuando redimensiona una ventana), Hollywood no ajustará
  la  escala  de  dicha  imagen  de  fondo,  sino  que  la recreará en la nueva
  resolución.   Antes de la versión 5.0, las imágenes de fondo con textura eran
  redimensionadas:   Desde  la  versión  5.0,  la  imagen de fondo será rehecha
  completamente.

- Antes  de la versión 5.0, las funciones @{"CopyFile()" LINK CopyFile} y @{"DeleteFile()" LINK DeleteFile} aceptaban
  símbolos  comodín  como  argumento  del  nombre  del  fichero:  esto ya no es
  posible.   Si  desea  copiar/borrar  ficheros de forma selectiva, ahora ha de
  utilizar  un  argumento  opcional.   Consulte  la  documentación de estas dos
  funciones para más información.

- Antes  de  la  versión  5.0, Hollywood utilizaba funciones de coincidencia de
  patrones   al   estilo   del   AmigaOS   en  @{"MatchPattern()" LINK matchPattern},  @{"CopyFile()" LINK CopyFile}  y
  @{"DeleteFile()" LINK DeleteFile}.    Desde  la  versión  5.0,  Hollywood  utiliza  funciones  de
  coincidencia de patrones independientes de la plataforma, que difieren de las
  de   Amiga   en   ciertos  casos.   Consulte  la  sección  sobre  la  función
  @{"MatchPattern()" LINK MatchPattern} para más detalles.

- Las  cadenas  largas  [[...]]  ahora con Hollywood 5.0 se comportan de manera
  diferente  si  su  guión  ha  sido  guardado utilizando la codificación de un
  retorno  de carro más un salto de línea (la codificación CR+LF es la definida
  por  defecto  en  los editores de texto de Windows; Amiga y los sistemas Unix
  sólo  usan  el  carácter  LF  para  terminar  las  líneas).  Previamente, los
  caracteres  de  retorno  de  carro ("\\r")  siempre se incluían en las cadenas
  largas:   esto  ya  no  es  así.   Todos  las  marcas  de  final  de línea se
  convertirán  en simples  saltos de línea ("\\n").  Si un retorno de carro está
  presente, se ignorará.  Este cambio se ha hecho para prevenir que los guiones
  se  comporten  de  manera  diferente  cuando  se  guarden  en  Windows  y  en
  @{u}AmigaOS/Unix/Mac@{uu}.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 4.5@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  4.5.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 4.5.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- @{"RotateLayer()" LINK RotateLayer}  actuará  de  manera diferente en esta versión  con respecto a
  cómo  lo  hacía  en  la  versión  4.0 .  Este cambio ha sido necesario porque
  Hollywood  4.5  presenta puntos de anclaje para las capas.  En Hollywood 4.0,
  @{"RotateLayer()" LINK RotateLayer},  giraba  la capa en torno a su centro,  asumiendo un punto de
  anclaje  0.5/0.5.   En la versión 4.5, sin embargo, todas las capas tienen un
  punto   de   anclaje   0.0/0.0.   Por  lo  tanto,  si  quisiera  replicar  el
  comportamiento  de la versión 4.0, necesita cambiar el punto de anclaje de la
  capa  a  los valores 0.5/0.5 invocando  la función @{"SetAnchorPoint()" LINK SetlayerAnchor}, definir
  punto de anclaje.

-  Los ejecutables compilados para macOS ahora buscarán en el cajón de recursos
  "Resources"  del  paquete  que  integra  la  aplicación SÓLO para ficheros de
  datos.   Este  cambio  se ha realizado para ajustarse a las directrices de la
  interfaz  del usuario del macOS.  Todos los ficheros de datos que acompañan a
  la aplicación HAN DE SER colocados dentro del paquete de la aplicación.

- Cuando  utilice  @{"CreateSprite()" LINK CreateSprite}  para crear enlaces  a duendecillos gráficos
  (por  ejemplo con un tipo de fuente #SPRITE), previamente podía crear también
  enlaces  desde  enlaces (de duendecillos):  esto ya no es posible.  Cuando se
  crea un enlace a un duendecillo, siempre ha de especificar un duendecillo que
  no esté enlazado como el duendecillo fuente o de origen.

- Cuando  se  utiliza  #VANILLACOPY  con  @{"SetAlphaIntensity()" LINK SetAlphaIntensity},  Hollywood  con
  anterioridad a veces no dibujaba nada, p.ej.  si intentaba dibujar una brocha
  con máscara en un canal alfa utilizando @{"SetAlphaIntensity()" LINK SetAlphaIntensity} con el parámetro
  #VANILLACOPY  definido.   Este  comportamiento  ahora ha cambiado:  Hollywood
  dibujará  los  puntos visibles de la máscara con una intensidad alfa de 255 y
  los invisibles con una intensidad de 0.

- @{"SelectBGPic()" LINK SelectBGPic},  tenía una prestación secreta  que nunca se ha documentado en
  ningún  sitio  (y que no es oficial):  si utilizaba  @{"SelectBGPic()" LINK SelectBGPic} con capas
  activadas  en  la imagen de fondo actual, todas las capas insertadas antes de
  @{"EndSelect()" LINK EndSelect}, se insertaban como capas ocultas.  Este comportamiento  ha sido
  desterrado.   @{"SelectBGPic()" LINK SelectBGPic}  ahora  insertará capas normales  y las dibujará
  cuando @{"EndSelect()" LINK EndSelect} sea invocado.  Si desea el comportamiento anterior,  cree
  sus capas con el atributo de ocultación "Hidden" definido con el valor TRUE,
  o sea, activado.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 4.0@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  4.0.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 4.0.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- La  sintaxis  de @{"SetPointer()" LINK SetPointer}  ha  cambiado  completamente.  Ya no acepta un
  nombre de fichero y requiere que invoque previamente a @{"CreatePointer()" LINK CreatePointer}.

- Todas   las  funciones  de  la  biblioteca  de  transiciones,  al  igual  que
  @{"PlayAnim()" LINK PlayAnim}, las funciones "MoveXXX()"  y  @{"DisplayBGPicPart()" LINK DisplayBGPicPart}  usan una nueva
  sintaxis.   Sin  embargo, la antigua sintaxis es aún soportada por cuestiones
  de compatibilidad.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 3.1@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  3.1.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 3.1.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- El  carácter  dos  puntos ":" ya no se utiliza como un separador de comandos.
  En Hollywood 1.x, dicho carácter se utilizaba para separar en una misma línea
  varios comandos como por ejemplo:

  ; Código para Hollywood 1.x code - YA NO SE PUEDE UTILIZAR
  x=100:y=200:ancho=50:alto=50:Box(x, y, ancho, alto, #RED)

  El  emulador  interno  1.x  de  Hollywood  emulaba  este comportamiento hasta
  Hollywood  3.0.   Con  la versión 3.1 ya no se soporta porque este símbolo se
  necesita  para  la  programación  orientada  a  objetos.   Así  que  necesita
  actualizar  sus  guiones  si  aún utiliza este símbolo para separar múltiples
  comandos  en  una  única  línea.   Desde  Hollywood 2.0, puede colocar tantos
  comandos en una misma línea como desee, así que el código de ejemplo anterior
  se escribiría así:

    x=100 y=200 ancho=50 alto=50 Box(x, y, ancho, alto, #RED)

  Quizás  estéticamente  no  sea  muy bonito, así que quizás debería reescribir
  esas  líneas  para que cada comando ocupe sólo una.  Naturalmente la elección
  es  suya,  pero  recuerde que Hollywood ya no emula el comportamiento del
  carácter dos puntos de la versión 1.x.

- La  transición  #TYPEWRITER  ya  no  existe.  Era un efecto especial que sólo
  podía  utilizar  con  objetos  de  texto y que complicaba innecesariamente la
  interfaz  de  tipos  de  impresión,  de  ahí su eliminación.  Puede emular su
  comportamiento invocando @{"Print()" LINK Print} en serie.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 3.0@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  3.0.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 3.0.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- Si  Hollywood  3  es  puesto  en  marcha sin argumentos, se abrirá en modo de
  ventana.   Todas  las  versiones previas abrían se abrían en modo de pantalla
  completa,  pero creo que es más sabio que se haga de este otro modo porque el
  modo de pantalla completa podría no funcionar en todos los sistemas.

- Los  argumentos  de  la  línea  de  comandos  ahora  son  manejados  de forma
  diferente.   Ha  de  precedelos  con un guión, o sea, con el símbolo "-".  En
  versiones anteriores podía hacerlo así:

    Hollywood ejemplo.hws WINDOW BORDERLESS

  ¡Esto  ya  no  funciona!  Ahora ha de usar los guiones.  La forma correcta de
  invocar a Hollywood ahora es:

    Hollywood ejemplo.hws -window -borderless

  Este  cambio  era necesario  debido  a la nueva función @{"GetCommandLine()" LINK GetCommandLine} que
  ahora le permite trabajar con sus propios argumentos.

- El  segundo argumento  de @{"FileRequest()" LINk FileRequest} ha cambiado.  Anteriormente,  era un
  patrón  con  el  formato  del  AmigaDOS.   Ahora  es simplemente un filtro de
  cadenas  que  especifica  qué ficheros han de mostrarse en la petición.  Este
  cambio  era  necesario  debido  a  la  nueva  naturaleza  multiplataforma  de
  Hollywood.   Los  sistemas  operativos  como  Win32  y macOS no dispone de un
  gestor de filtros con patrones como ofrece el AmigaOS.

- En la versión anterior el tercer argumento opcional de la función @{"OpenFile()" LINK OpenFile}
  utilizaba  por  defecto de no indicarse el atributo #MODE_READWRITE.  Esto ha
  cambiado.   Ahora  el  modo  por  defecto es #MODE_READ.  Es un ruptura de la
  interfaz  de  programadores  por  orgullo.   Creo que tiene más sentido abrir
  ficheros en modo sólo lectura por defecto.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 2.5@{ui}@{uu}

Se  han producido algunos pequeños cambios en la interfaz para programadores de
Hollywood  2.5.   En  la  mayoría  de los casos seguramente no se requerirá que
adapte  sus  guiones  para  que  funcionen  con  la versión 3.0.  Compruebe los
siguientes puntos para comprobar si su guión exige alguna adaptación.

- El   soporte   de   la   biblioteca  "ttengine.library"  ha  sido  eliminado.
  Naturalmente Hollywood aún soporta los tipos de impresión TrueType.  La única
  limitación  es  que ya  no  puede  utilizar  @{"SetFont()" LINK SetFont}  directamente con los
  ficheros *.ttf directamente, por ejemplo:

    SetFont("dh1:arial.ttf")  ; ¡Código de Hollywood 2.0!

  Esto ya no funciona.  En Hollywood 2.5 sólo puede utilizar tipos TrueType que
  haya  instalado  en  su  sistema  utilizando  "FTManager"  o  una herramienta
  similar.   Estos  tipos  se  abren  como los tipos de impresión normales, por
  ejemplo:

    SetFont("Arial Narrow.font")  ; ¡Es correcto con Hollywood 2.5!

  Ha  de  hacerlo  así, porque Hollywood 2.5 carga todos los tipos de impresión
  TrueType  a  través  de las interfaces de la biblioteca Bullet compatible FT2
  (AmigaOS 4) o FreeType2 (MorphOS, AROS, AmigaOS 3) respectivamente.

- El comando  @{"CheckEvent()" LINK CheckEvent}  ha  sido suprimido, puesto que no se ajustaba a la
  filosofía de Hollywood.  Por favor, utilice siempre @{"WaitEvent()" LINK WaitEvent} en su lugar.

- El  comando  @{"Plot()" LINK Plot}  ahora sólo funciona  con capas desactivadas.  Las capas
  del  tipo #PLOT ya no son posibles.  No tiene mucho sentido tener capas de un
  tamaño  de 1x1.  Si realmente las necesita,  puede utilizar el comando @{"Box()" LINK Box}
  para dibujar un píxel.

- Debido  al  nuevo motor de generación de texto, ahora es obligatorio utilizar
  corchetes   en   las  cadenas   que   le   pase   a  @{"Print()" LINK Print},  @{"TextOut()" LINK TextOut}  y
  @{"CreateTextObject()" LINK CreateTextObject}  cuando quiera  imprimir  un  corchete.   Por ejemplo, el
  siguiente código:

    Print("[Amigables saludos]")    ; ¡Código para Hollywood 2.0!

  generaría  un  error  de sintaxis bajo Hollywood 2.5 porque el nuevo motor de
  texto  espera  un  comando  de  formato  tras los corchetes.  Así que debería
  escribirlo como sigue:

    Print("[[Amigables saludos]]")  ; ¡Es correcto bajo Hollywood 2.5!

  Y así funcionará como espera.

- Si  el  estilo  de  relleno  es  definido como #FILLTEXTURE o #FILLGRADIENT y
  dibuja utilizando  un valor @{"ARVA" LINK ARGBInfo} (canal alfa, rojo, verde y amarillo), estos
  estilos  de  relleno  respetarán  ahora  el  valor  alfa.  No ocurría así con
  Hollywood 2.0.

- Si @{"las capas están activadas" LINK EnableLayers} e invoca un comando de la biblioteca de dibujo,
  como  por ejemplo @{"Ellipse()" LINK Ellipse}, y especifica  un color @{"ARVA" LINK ARGBInfo} (como cuando desea
  dibujar  con transparencia), Hollywood 2.0 crearía una capa transparente para
  usted  como  si hubiese  invocado  la  función @{"SetLayerTransparency()" LINK SetLayerTransparency} con el
  octeto alfa del valor @{"ARVA" LINK ARGBInfo} como el valor de la transparencia.  Esto ya no es
  así.   Si dibuja con un color @{"ARVA" LINK ARGBInfo}, Hollywood 2.5 no le ofrecerá la capa con
  un  ajuste de la transparencia, aunque ahora la tenga, sino que en la versión
  2.5  la transparencia ya está dibujada con los datos gráficos (por ejemplo el
  canal  alfa)  y  no  se  conserva  de  forma  dinámica  con  en  el  caso  de
  @{"SetLayerTransparency()" LINK SetLayerTransparency}.

- Hasta la versión 2.0 de Hollywood, @{"RotateBrush()" LINK RotateBrush} siempre devolvía una brocha
  con  el  máximo tamaño que una rotación con la brocha fuente podría ocupar, o
  sea,  maxs  = sqrt(anchura*anchura+altura*altura).  La nueva brocha reservada
  por  Hollywood sería entonces de un ancho y una altura "maxs".  Esto ya no es
  así.   La  brocha  es  exactamente  tan grande como se necesite para contener
  todos los gráficos.

- En  Hollywood  2.0,  @{"WriteMem()" LINK WriteMem} y @{"ReadMem()" LINK ReadMem}  siempre  utilizaban entradas y
  salidas  sin  memoria  tampón  cuando  todas  las  demás  funciones DOS sí la
  utilizaban.   Ahora se han unificado todas las funciones y todas utilizan E/S
  con tampón por defecto.  Además, en Hollywood 2.0 @{"WriteMem()" LINK WriteMem} siempre purgaba
  los  tampones  automáticamente  amtes  de comenzar la operación de escritura.
  Esto  ya no es así  con  la versión 2.5.  Así que  si utiliza  en sus guiones
  @{"WriteMem()" LINK WriteMem} / @{"ReadMem()" LINK ReadMem}  y  necesita entradas / salidas  sin  tamponar  como
  en  la versión 2.0,  primero  tendrá  que llamar a @{"SetIOMode()" LINK SetIOMode}  para cambiar
  el  modo...  pero recuerde que no se vaciarán los tampones como con Hollywood
  2.0.   ¡Y recuerde que una vez llame a @{"SetIOMode()" LINK SetIOMode} todas las demás funciones
  DOS  también  utilizarán  el  modo  elegido  por  dicha  función!   Si  desea
  únicamente que @{"WriteMem()" LINK WriteMem} o @{"ReadMem()" LINK ReadMem}  no utilicen tampones, deberán volver
  a llamar  a  @{"SetIOMode()" LINK SetIOMode}  tras  utilizarlas  para  volver a cambiar el modo.
  También  puede llamar  de  forma  manual @{"FlushFile()" LINK FlushFile} si quiere cambiar EN EL
  MISMO FICHERO del modo tamponado al modo sin tamponar.  Todo esto puede sonar
  algo  complicado, pero en realidad es muy simple.  De hecho, le da un control
  total sobre las funciones de disco lo que puede ser muy útil en general.  Por
  favor, consulte la documentación sobre @{"SetIOMode()" LINK SetIOMode} para más información.

- Hasta  Hollywood  2.0, @{"TextOut()" LINK TextOut}  alinearía  automáticamente el texto si una
  constante  especial  de  coordenadas como #CENTER o #RIGHT se especifica como
  "x".   Esto ya no es posible.  Hay un nuevo argumento que puede utilizar para
  especificar la alineación deseada.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 2.0@{ui}@{uu}

A  pesar  de  que Hollywood 2.0 ha supuesto una actualización titánica, sólo se
han  producido  pequeños  cambios en la interfaz de programadores donde ha sido
necesario.   Aquí  tiene  una  lista  de  las  cosas  que  ha de cambiar en sus
guiones:

- Si  invoca funciones que no aceptan argumentos, pero devuelven un valor ha de
  usar  los  paréntesis.   Por  ejemplo,  el siguiente código funcionaba con la
  versión 1.9, pero ya no lo hace con la 2.0:

    ; ¡ Mal !
    x = MouseX
    y = MouseY

  Ha de escribirlo así:

    ; ¡ Correcto !
    x = MouseX()
    y = MouseY()

  A propósito, la versión incorrecta no generará un error del compilador puesto
  que el código es correcto, pero hace algo completamente diferente:  asigna la
  función @{"MouseX()" LINK MouseX} a la variable "x" que no es lo que se desea.

- Ahora  @{"GetTimer()" LINK GetTimer} siempre  devuelve el valor en milisegundos.  La unidad por
  defecto  en  Hollywood  1.x  era  el  segundo,  lo que suponía una infracción
  vanidosa  de  la  interfaz  para  programadores.   Naturalmente, podría haber
  conservado  la  vieja  implementación,  pero  honestamente,  no hay nadie que
  quiera  un valor devuelto en segundos puesto que es demasiado impreciso.  Por
  lo  tanto,  he  decidido  hacer  un favor a los programadores y utilizar como
  unidad  por  defecto  los  milisegundos, así que ya no tendrán que teclear la
  larga  expresión  "GetTimer(1,  #MILLISECONDS)" cada vez, bastándoles teclear
  GeTimer(1).

- Las funciones @{"MoveBrush()" LINK MoveBrush},  @{"MoveTextObject()" LINK MoveTextObject},  @{"MoveAnim()" LINK MoveAnim}...   ya no pueden
  manejar  los  viejos  objetos.   Por ejemplo, el siguiente código no funciona
  correctamente bajo 2.0:

    MoveBrush(1, #LEFTOUT, #CENTER, #CENTER, #CENTER)
    Wait(100)
    MoveBrush(1, #CENTER, #CENTER, #RIGHTOUT, #CENTER)

  En  Hollywood  1.x,  este código movía la brocha nº 1 desde la parte exterior
  izquierda  al  centro,  aguardando  100  cincuentavos  de segundo, y movía la
  brocha hacia la parte exterior derecha.  En Hollywood 2.0 hará lo mismo, pero
  una  copia de la brocha quedará en el centro del área de visualización.  Esto
  es  debido  a los grandes cambios introducidos en el sistema de refresco.  Si
  quiere  imitar  el comportamiento de la versión 1.x, utilice @{"MoveSprite()" LINK MoveSprite} en
  lugar de @{"MoveBrush()" LINK MoveBrush}.

- @{"DisplayTransitionFX()" LINK DisplayTransitionFX} ya puede  ser  utilizada para visualizar imágenes con
  fondo  transparente;  el  cambio a imágenes con fondo transparente sólo puede
  realizarse  ahora  sin un efecto.  Ello es debido a que Hollywood 2.0 utiliza
  ventanas de transparencia real en  MorphOS, AmigaOS 4 y AROS y estas ventanas
  tienen una capa donde los gráficos no pueden dibujarse.

- En  Hollywood  1.x,  @{"MixBrush()" LINK MixBrush}  cambiaba  el tamaño de dos brochas para que
  coincidiesen  sus dimensiones  si no era así.  Ya no lo hace:  @{"MixBrush()" LINK MixBrush} se
  limita a mezclar las partes coincidentes y desecha el resto.

- @{"RotateBrush()" LINK RotateBrush}  ahora creará  una máscara para la brocha si no tiene una.  Ya
  no tendrá que realizar usted esta tarea.

- Si @{"las capas están activadas" LINK EnableLayers} y utiliza @{"InKeyStr()" LINK InKeyStr}, sólo instalará una capa
  del  tipo  #PRINT.  En Hollywood 1.x, @{"InKeyStr()" LINK InKeyStr} dejaba una capa #PRINT por
  cada carácter.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 1.9@{ui}@{uu}

Existen  algunos cambios menores en la interfaz para programadores de Hollywood
1.9, que se citan a continuación:

- Los  comandos   @{"EnableEventHandler()" LINK EnableEventHandler}   y  @{"DisableEventHandler()" LINK DisableEventHandler}   han  sido
  eliminados.  Podían causar muchos problemas porque si se utilizaban, usted no
  sabía cuando sus procedimientos de eventos eran invocados.  Por favor, ¡ahora
  utilice la nueva función @{"CheckEvent()" LINK CheckEvent}!

- @{"EnablePrecalculation()" LINK EnablePrecalculation} y @{"DisablePrecalculation()" LINK DisablePrecalculation} han sido eliminados porque
  Hollywood  ya  no  soporta  el  precálculo.   Por  ello, el argumento/tipo de
  herramienta PRECALCULATION también ha desaparecido.

- @{"WhileMouseOn()" LINK WhileMouseOn}  tenía algunos cambios de los que probablemente de los que no
  se  dará  cuenta habitualmente, pero bajo ciertas circunstancias ahora podría
  tener  problemas  con  ellos:   En  versiones  antiguas, Hollywood retornaría
  inmediatamente   a   su  bucle   @{"WaitEvent()" LINK WaitEvent}   tras   producirse  un  evento
  @{"ONBUTTONCLICK" LINK ONBUTTONCLICK}.  ¡Esto es un comportamiento incorrecto!  Ahora retornará a su
  comando  @{"WhileMouseOn()" LINK WhileMouseOn}  porque  el ratón  aún  está  sobre  su  botón  tras
  producirse  el evento @{"ONBUTTONCLICK" LINK ONBUTTONCLICK}.  Si quiere que Hollywood 1.9 actúe como
  con  Hollywood  1.0  y  1.5  lo  hacían, necesitará utilizar el nuevo comando
  @{"BreakWhileMouseOn()" LINK BreakWhileMouseOn}.


@{i}@{u}Cambios en la interfaz para programadores de Hollywood 1.5@{ui}@{uu}

Desgraciadamente,   he   realizado   algunos   cambios   en  la  interfaz  para
programadores  del  lenguaje Hollywood con esta actualización 1.5.  Si su guión
no  funciona  correctamente bajo Hollywood 1.5, pero sí lo hace bajo la versión
1.0, por favor, lea la siguiente información y adapte su guión:

- La  sintaxis  de las constantes ha cambiado .  En Hollywood 1.0 basta con que
  especifique  las  constantes por su nombre, pero a partir de ahora tendrá que
  añadirles   el  prefijo  almohadilla  "#".   Así  que  deberá,  por  ejemplo,
  especificar  #CENTER en lugar de CENTER y #BOLD en lugar de BOLD.  Lo siento,
  pero este cambio era absolutamente necesario.

- @{"Undo()" LINK Undo}  ya no funcionará  hasta  que haya llamado a @{"EnableLayers()" LINK EnableLayers}.  Si está
  utilizando  @{"Undo()" LINK Undo}  en  su guión,  asegúrese  de  invocar  @{"EnableLayers()" LINK EnableLayers} al
  inicio.

- La  sintaxis de @{"PlaySample()" LINK PlaySample}  ha cambiado.  Ya no puede especificar un canal
  para   la  reproducción.   Hollywood  lo  hará  por  usted.   Basta  con  que
  especifique  el  número  de  la  muestra de sonido y si es la reproducción es
  cíclica o no.

- La sintaxis de @{"PlayAnim()" LINK PlayAnim} ha cambiado.  Ahora se ejecuta  de forma síncrona.
  Este  cambio  era necesario porque la vieja implementación  de @{"PlayAnim()" LINK PlayAnim} ya
  no  tenía  cabida  en  el  concepto  de  Hollywood.   Si  necesita reproducir
  animaciones  de  forma  asíncrona,  utilice enlaces a brochas de fotogramas y
  visualícelos con @{"DisplayBrush()" LINK DisplayBrush}.  Debido a que la función ahora es síncrona,
  los  comandos @{"IsAnimPlaying()" LINK IsAnimPlaying} y @{"WaitAnimEnd()" LINK WaitAnimEnd} ya no se necesitan y han sido
  suprimidos.

- @{"ClearScreen()" LINK ClearScreen}  ha  sido  suprimido  puesto  que  ya  no  tiene cabida  en el
  concepto de Hollywood.

- @{"LoadModule()" LINK LoadModule}  ya no carga módulos  en formato @{u}THX@{uu}, @{u}P61@{uu} o @{u}MED@{uu}.  El soporte de
  módulos  ahora  se  concentra  en  el  formato Protracker.  Otros formatos de
  módulos no pueden ser reproducidos limpiamente a través del sistema @{u}AHI@{uu}.

- @{"Print()" LINK Print} ya no soporta el suavizado con los tipos de impresión TrueType. Este
  cambio  ha sido necesario para conservar la compatibilidad con las capas.  El
  suavizado se volverá a ofrecer para todos los objetos con Hollywood 2.0.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/APIChanges"}

@ENDNODE
@REMARK =======================================================================
@NODE ToDo "Guía de Hollywood: El futuro *UPD10*"

@{b}El futuro@{ub}

Aquí están algunas ideas que tengo en mi lista de asuntos pendientes:

- aceleración  de  todas las funciones de transición que deberían producirse en
  milisegundos  en lugar de utilizando un tipo definible; ayudaría a temporizar
  los guiones correctamente.

- transiciones para texto.

- interfaz para programadores que permita crear flujos de video con Hollywood.

- dibujado más rápido utilizando recorte de zona poligonal cuando sea posible.

- más prestaciones.

Por  favor,  envíeme  @{"un mensaje  por correo electrónico" LINK Contact} si tiene buenas ideas
sobre qué prestaciones deberían implementarse en Hollywood.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/ToDo"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgIntroduction "Guía de Hollywood: Su primer programa *UPD10*"

@{b}Su primer programa con Hollywood@{ub}

El  lenguaje  de guiones de Hollywood es fácil de usar, ¡pero muy poderoso!  La
sintaxis  está  basada  esencialmente en la del @{u}BASIC@{uu}, ¡pero Hollywood es mucho
más poderoso porque es un lenguaje de tipificación dinámica!  Veremos más tarde
qué  significa  esto  para  el  programador.   Hollywood  incorpora los mejores
elementos del @{u}(Blitz-)BASIC@{uu}, @{u}C@{uu}, @{u}Amiga E@{uu}, @{u}Pascal@{uu} y @{u}Lua@{uu} en un poderoso y flexible
lenguaje que le permite hacer casi todo con un pequeño esfuerzo.

Los  guiones de Hollywood son simples textos (con codificación) UTF-8.  Así que
"déle caña" a su editor de textos favorito ¡y empiece a crear su primer guión!

Así sería el "famoso" programa "¡Hola amigos!" en Hollywood:

  Print("¡Hola amigos!")
  WaitLeftMouse()
  End()

El pequeño programa anterior abrirá una visualización de 640x480 píxeles (es el
tamaño  por  defecto  que  Hollywood utiliza cuando no se especifica nada).  Si
quiere  que  Hollywood  abra una visualización de otras dimensiones, necesitará
utilizar  los  comandos  del preprocesador  @{"@DISPLAY" LINK atDISPLAY}  o  @{"@BGPIC" LINK atBGPIC}.  El tamaño de
visualización  no  es  el mismo que el de pantalla:  ¡Se trata del tamaño de su
área  de  trabajo!   El  tamaño  de  pantalla  puede  ser cualquiera que sea lo
suficientemente grande para contener la visualización.  Su visualización estará
centrada  en la pantalla (puede utilizar el comando del preprocesador @{"@DISPLAY" LINK atDISPLAY}
si  quiere una posición inicial de la visualización diferente).  La ventana que
es  abierta  y  retiene  la  visualización,  será más larga que el tamaño de la
visualización  si  tiene  bordes.   Si  especifica  @el  argumento  de  consola
@{"-borderless" LINK ManualUsage},   el tamaño  de  la  ventana  coincidirá  con  el  tamaño  de  su
visualización.

Si  desea  disponer  de  una bonita imagen de fondo en lugar de un simple fondo
negro,  coloque  el comando  del preprocesador @{"@BGPIC" LINK atBGPIC} al principio de su guión
así:

  \@BGPIC 1, "UnBonitoFondo.jpg"
  Print("¡Hola amigos!")
  WaitLeftMouse()
  End()

También  puede colocar múltiples comandos en una línea, de manera que el código
anterior podría también escribirse así:

  Print("¡Hola mundo!") WaitLeftMouse() End()

Sin  embargo,  se  aconseja utilizar saltos de línea para que su código sea más
legible. Para conseguir esto, también puede utilizar @{"comentarios" LINK PrgComments} iniciados por
la  secuencia  de caracteres "/*" (NdT:  Sin las comillas dobles, que se añaden
para  delimitar  claramente la secuencia) y terminándolos con la secuencia "*/"
(NdT:   Nuevamente  sin  las  comillas  dobles)  o  si  es sencillo (una línea)
simplemente precediéndolo con el símbolo punto y coma ";", como por ejemplo:

  /* Esto es un comentario */
  Print("¡Hola amigos!")   ; Aquí tiene otro comentario
  WaitLeftMouse()   ; Se espera hasta presionar el botón izquierdo del ratón
  End()   ; Salir

Si  una  función/comando  de  Hollywood no acepta ni devuelve argumentos, puede
suprimir  los  paréntesis  cuando  la  llame.   Sin  embargo,  si le suministra
argumentos o si quiere almacenar el valor devuelto por ésta, ha de utilizarlos.
En   nuestro  ejemplo,  podríamos  suprimir  los  paréntesis  de  los  comandos
@{"WaitLeftMouse()" LINK WaitLeftMouse} y @{"End()" LINK End} por que no aceptan ningún argumento:

  Print("¡Hola amigos!")
  WaitLeftMouse
  End

Naturalmente,  también  es  posible utilizar variables en lugar de directamente
números  o  cadenas.  No necesita declarar las variables:  Se inicializarán con
el  valor  cero  o  una cadena vacía respectivamente cuando las use por primera
vez.  El nombre de las variables ha de comenzar con una letra desde la A/a a la
Z/z  (NdT:   Limítese  al alfabeto anglosajón) o con un guión bajo.  Tras ésta,
puede  contener  también  dígitos  del  cero  al  nueve,  el  símbolo del dólar
estadounidense "$" y el de cierre de exclamación "!".  Como cuestión de estilo,
pues  hace  el código más legible, las variables que contengan cadenas deberían
deberían tener su nombre finalizado con el signo del dólar estadounidense y las
que  contengan valores de coma flotante deberían tener su nombre finalizado con
el símbolo de cierre de exclamación.  La longitud del nombre de una variable no
puede exceder de los 64 caracteres.

  micadena$ = "¡Hola amigos!"
  Print(micadena$)
  WaitLeftMouse
  End

Además  de los comandos normales, existen en Hollywood también los comandos del
preprocesador.   Estos comando son procesados antes de iniciar la ejecución del
guión  y  el  nombre  del comando siempre comienza  por el carácter arroba "\@".
Uno  de  estos comandos  es @{"@VERSION" LINK atVERSION}, que permite definir la versión mínima de
Hollywood  que  el guión exige para funcionar.  Por ejemplo, el siguiente guión
sólo funcionará con la versión 2.0 o superior de Hollywood:

  \@VERSION 2,0
  Print("¡Hola amigos!")
  WaitLeftMouse
  End

Debería   utilizar   siempre   este  comando  del  preprocesador  como  primera
instrucción de su guión para asegurarse de que la versión se comprueba antes de
hacer nada.

Si teclea el código indicado líneas atrás en su editor de texto y lo guarda con
el nombre "MiPrograma.hws", puede ponerlo en marcha desde la consola tecleando:

    1> Hollywood MiPrograma.hws [ARGUMENTOS]

donde "[ARGUMENTOS]" puede(n) ser  cualquiera de @{"los argumentos" LINK ManualUsage} soportados por
Hollywood.   Si  desea  poner  en marcha  su  guión a través  del programa GUI,
ejecútelo, presione el botón  @{"Ejecutar" LINK GUI} sin tener seleccionada entrada alguna y
elija su guión.

¡Felicidades, ha creado su primer guión para Hollywood!


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgIntroduction"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgIdentifiers "Guía de Hollywood: Identificadores *UPD10*"

@{b}Identificadores reservados@{ub}

Los  siguientes  identificadores están reservados por Hollywood y no pueden ser
utilizados como nombres de variables o funciones:

  @{"And" LINK PrgOprLogic}
  @{"Block" LINK PrgBlock}
  @{"Break" LINK PrgBreak}
  @{"Case" LINK PrgSwitch}
  @{"Const" LINK PrgConst}
  @{"Continue" LINK PrgContinue}
  @{"Default" LINK PrgSwitch}
  @{"Dim" LINK PrgDim}
  @{"DimStr" LINK PrgDim}
  @{"Do" LINK PrgDo}
  @{"Else" LINK PrgFlow}
  @{"ElseIf" LINK PrgFlow}
  @{"EndBlock" LINK PrgBlock}
  @{"EndFunction" LINK PrgFunctions}
  @{"EndIf" LINK PrgFlow}
  @{"EndSwitch" LINK PrgSwitch}
  @{"FallThrough" LINK PrgSwitch}
  @{"FALSE" LINK PrgTrueFalse}
  @{"For" LINK PrgFor}
  @{"Forever" LINK PrgRepeat}
  @{"Function" LINK PrgFunctions}
  @{"Global" LINK PrgGlobal}
  @{"Gosub" LINK Gosub}
  @{"Goto" LINK Goto}
  @{"If" LINK PrgFlow}
  @{"In" LINK PrgFor}
  @{"Label" LINK Label}
  @{"Local" LINK PrgLocal}
  @{"Next" LINK PrgFor}
  @{"NIL" LINK PrgTypeNil}
  @{"Not" LINK PrgOprLogic}
  @{"Or" LINK PrgOprLogic}
  @{"Repeat" LINK PrgRepeat}
  @{"Return" LINK PrgReturn}
  @{"Step" LINK PrgFor}
  @{"Switch" LINK PrgSwitch}
  @{"Then" LINK PrgIf}
  @{"To" LINK PrgFor}
  @{"TRUE" LINK PrgTrueFalse}
  @{"Until" LINK PrgRepeat}
  @{"Wend" LINK PrgWhile}
  @{"While" LINK PrgWhile}
  @{"Xor" link PrgReserved}

Si  intenta  utilizar  uno  como  un  nombre  de  función o variable, Hollywood
generará un error.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgIdentifiers"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgPreproc "Guía de Hollywood: Comandos del preprocesador *UPD10*"

@{b}Comandos del preprocesador@{ub}

Un  comando  del  preprocesador es un comando que Hollywood procesa actualmente
ANTES  de  ejecutar su guión.  En Hollywood, se utilizan principalmente para la
carga  de  datos  antes de que su guión se ponga en marcha.  Por ejemplo, si su
guión  exige  los ficheros "menuprinc.png", "pantallajuego.png" y "musica.mod",
bastaría con cargarlos previamente utilizando el siguiente código:

  \@BGPIC 1, "menuprinc.png"
  \@BGPIC 2, "pantallajuego.png"
  \@MUSIC 1, "musica.mod"

Hollywood  procedería a cargar todos estos ficheros antes de ejecutar su guión.
Todos  los  ficheros cargados por este sistema están listos inmediatamente para
su  uso  cuando  su  guión  se  pone  en  marcha.   La  mayoría de los comandos
"LoadXXX()"  tienen su comando del preprocesador equivalente en Hollywood.  Así
por ejemplo,  el equivalente  de  @{"LoadBrush()" LINK LoadBrush}  es  @{"@BRUSH" LINK atBRUSH},  el equivalente de
@{"LoadBGPic()" LINK LoadBGPic}  es @{"@BGPIC" LINK atBGPIC} y así sucesivamente.

Los  comandos  del preprocesador tienen siempre como prefijo el carácter arroba
"\@".  También debería escribirlos en mayúsculas para poder diferenciarlos mejor
de  los  comandos  normales.  Los comandos del preprocesador puede colocarse en
cualquier  punto  del  guión, pero por motivos de legibilidad se sugiere que se
haga al inicio de su guión.

Un  comando  básico del preprocesador es @{"@VERSION" LINK atVERSION}.  ¡Debería ser el primero en
usar  en  todos sus guiones!  Este comando comprueba si la versión de Hollywood
utilizada es suficiente para ejecutar el guión:  Si no es así, Hollywood aborta
la ejecución.

La  mayoría  de  los comandos del preprocesador necesitan múltiples argumentos,
que  son  separados  entre  sí  por  comas  como el resto de comandos normales.
También  puede  utilizar  expresiones en ellos, y así por ejemplo, la siguiente
declaración aunque no es común, es perfectamente válida:

  \@BRUSH 5+5, "MiBrocha.png"

Esta  línea  de  código  debería cargar la brocha "MiBrocha.png" como la brocha
nº 10.   Lo  que  no  puede  hacer,  sin  embargo, es utilizar variables en sus
expresiones.   Cuando Hollywood procesa los comandos del preprocesador, no sabe
nada  del estado de las variables puesto que aún no se ha iniciado la ejecución
del guión.  Por ello, todas las expresiones que utilice han de ser constantes.

Otra  ventaja  de  los  comandos  del  preprocesador  es que todos los ficheros
especificados   aquí   se   enlazarán   automáticamente   con   el  ejecutable,
incrustándose  en  él,  cuando   compile  su guión.   Este comportamiento puede
alterarse  utilizando la etiqueta "Link" que es aceptada por todos los comandos
del  preprocesador  que  funcionan  con  ficheros.   Esta etiqueta le indica al
enlazador de Hollywood si el fichero ha de ser incrustado o no en el ejecutable
o  miniaplicación cuando compile un guión.  El valor por defecto de la etiqueta
"Link"  es siempre TRUE lo que significa que por defecto los ficheros cargados
a  través  de  los comandos del preprocesador se incrustarán en su ejecutable o
miniaplicación.   Si  desea que eso no ocurra con ciertos ficheros, por ejemplo
por que son muy grandes, puede especificarlo de forma explícita en los comandos
del preprocesador correspondientes.

Están disponibles los siguientes comandos del preprocesador:

  @{"@ANIM           " LINK atANIM}    Carga una animación para un uso posterior
  @{"@APPAUTHOR      " LINK atAPPAUTHOR}    Declara el autor de la aplicación
  @{"@APPCOPYRIGHT   " LINK atAPPCOPYRIGHT}    Declara los derechos de autoría de la aplicación
  @{"@APPDESCRIPTION " LINK atAPPDESCRIPTION}    Declara la descripción de la aplicación
  @{"@APPENTRY       " LINK atAPPENTRY}    Declara un guión de partida para la aplicación
  @{"@APPICON        " LINK atAPPICON}    Declara el icono de la aplicación
  @{"@APPIDENTIFIER  " LINK atAPPIDENTIFIER}    Declara el identificador de la aplicación
  @{"@APPTITLE       " LINK atAPPTITLE}    Declara el título de la aplicación
  @{"@APPVERSION     " LINK atAPPVERSION}    Declara la versión de la aplicación
  @{"@BACKFILL       " LINK atBACKFILL}    Define un fondo de relleno para su guión
  @{"@BGPIC          " LINK atBGPIC}    Carga una imagen de fondo para un uso posterior
  @{"@BRUSH          " LINK atBRUSH}    Carga una brocha para un uso posterior
  @{"@CATALOG        " LINK atCATALOG}    Carga un catálogo para un uso posterior
  @{"@DIRECTORY      " LINK atDIRECTORY}    Incrusta un directorio completo
  @{"@DISPLAY        " LINK atDISPLAY}    Define los atributos de visualización
  @{"@ELSE           " LINK atELSE}    Bloque a ejecutar si fallan todas las condiciones
  @{"@ELSEIF         " LINK atELSEIF}    Comprueba otra condición
  @{"@ENDIF          " LINK atENDIF}    Declara el final de un bloque condicional
  @{"@ERROR          " LINK atERROR}    Aborta la compilación con un mensaje de error
  @{"@FILE           " LINK atFILE}    Abre un fichero para un uso posterior
  @{"@FONT           " LINK atFONT}    Carga un tipo de impresión para un uso posterior
  @{"@ICON           " LINK atICON}    Carga un icono para un uso posterior
  @{"@IF             " LINK atIF}    Comprueba una condición
  @{"@INCLUDE        " LINK atINCLUDE}    Importa código de guiones o miniaplicaciones
  @{"@LINKER         " LINK atLINKER}    Suministra opciones al enlazador
  @{"@MENU           " LINK atMENU}    Crea una tira de menú
  @{"@MUSIC          " LINK atMUSIC}    Carga música para un uso posterior
  @{"@OPTIONS        " LINK atOPTIONS}    Configura opciones variadas
  @{"@PALETTE        " LINK atPALETTE}    Carga una paleta para un uso posterior
  @{"@REQUIRE        " LINK atREQUIRE}    Declara la dependencia de un complemento
  @{"@SAMPLE         " LINK atSAMPLE}    Carga una muestra de sonido para un uso posterior
  @{"@SCREEN         " LINK atSCREEN}    Configura el modo de pantalla de su guión
  @{"@SPRITE         " LINK atSPRITE}    Carga un duendecillo gráfico para un uso posterior
  @{"@VERSION        " LINK atVERSION}    Define la versión mínima de Hollywood exigida
  @{"@VIDEO          " LINK atVIDEO}    Carga un video para un uso posterior
  @{"@WARNING        " LINK atWARNING}    Envía una advertencia al dispositivo de depuración


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgPreproc"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgStrNumConv "Guía de Hollywood: Conversión entre cadenas y números *UPD10*"

@{b}Conversión entre cadenas y números@{ub}

Hollywood soporta la conversión automática de las cadenas a valores numéricos y
viceversa.  Esto significa que si una función aguarda una cadena como argumento
y  usted  le  suministra  un  valor numérico, Hollywood realizará la conversión
automáticamente y le transferirá a la función una cadena.

Por  ejemplo:  @{"StrLen()" LINK StrLen} devuelve la longitud de la cadena especificada.  Si la
invocamos así:

  a = StrLen(256)

Hollywood  convertirá  automáticamente el valor numérico 25 a la cadena "256" y
así  la  variable  "a"  contendrá el valor 3, debido a que la cadena "256" está
compuesta de tres caracteres.

Esto  funciona  de  igual forma al revés.  Si usted suministra una cadena a una
función  que  aguarda  un  número,  Hollywood  intentará convertirla a un valor
numérico.   La  diferencia de esta conversión con respecto a la anterior es que
ahora  podría  fallar.  Por ejemplo:  Hollywood no puede convertir cadenas como
"Hola"  a  un  número.   La  cadena  ha  de  contener  sólo dígitos decimales o
hexadecimales.   La  mezcla  de  cadenas  alfabéticas  y numéricas no puede ser
convertida,  incluso aunque los dígitos aparezcan antes de los caracteres.  Los
números  hexadecimales han de llevar como prefijo el símbolo del dólar "$" o la
secuencia "0x".  Un ejemplo:

  LoadBrush("1", "Brocha.iff")

@{"LoadBrush()" LINK LoadBrush} aguarda un número como identificador.  Por lo tanto, la cadena "1"
será  convertida automáticamente a un número por Hollywood.  Esto contrasta con
lo siguiente que no funcionará:

  LoadBrush("Prueba", "Brocha.iff")
  LoadBrush("1Prueba", "Brocha.iff")

Las cadenas "Prueba" o "1Prueba" no pueden ser convertidas a un número.

También  puede  usar  todos  los  operadores  con números y cadenas excepto los
operadores   relacionales.    Éstos   sólo  pueden  comparar  dos  valores  que
correspondan  al  mismo  tipo  de  datos.   Por  ejemplo,  el  siguiente código
funcionará correctamente:

  a = "5" * 10 + 100 / "10" + ("100" - 60)       ; "a" es 100

Pero  este  código generará un error porque utiliza operadores relacionales con
valores de diferentes tipos:

  If "10" < 20          ---> ¡Error!

Si  desea  hacer algo  como esto tendrá  que utilizar  @{"Val()" LINK Val}  o @{"StrStr()" LINK StrStr} para
convertir manualmente el número a una cadena o viceversa.  Por ejemplo:

  If Val("10") < 20     ---> ¡Funciona!


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgStrNumConv"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgComments "Guía de Hollywood: Comentarios *UPD10*"

@{b}Comentarios@{ub}

Hollywood soporta dos tipos de comentarios:  El terminado con un salto de línea
y  el  terminado  por  el  usuario.   El  primer tipo de comentario comienza si
Hollywood  encuentra un punto y coma ";" en su código:  Hollywood ignorará todo
lo  que  le siga y saltará a la siguiente línea de código para continuar con su
procesado.  Por ejemplo:

  DebugPrint("¡Hola!")   ; ¡Soy un comentario finalizado por un salto de línea!

El  segundo  tipo  de  comentario  necesita  que  el  usuario  marque su final.
Comienza  con la secuencia de caracteres "/*" y finaliza con la secuencia "*/".
Puesto  que  es  el  usuario  quien lo termina, puede abarcar múltiples líneas.
Pero  también puede empezar en cualquier sitio, ya sea al inicio de una línea o
en mitad de ella.  Ejemplos:


  /*
  ¡Todo lo que hay aquí será ignorado por Hollywood!
  */

  DebugPrint("¡Hola") /* Soy un comentario */ DebugPrint("amigo!")

¡Por  favor, comente su código!  No tiene porqué comentar cada pequeña variable
local,  pero  dar una breve descripción a las funciones no hace daño y facilita
que otra gente entienda el programa.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgComments"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgIncludes "Guía de Hollywood: Ficheros de inclusión *UPD10*"

@{b}Ficheros de inclusión@{ub}

Los  ficheros  de  inclusión  pueden  ser utilizados para importar código de un
fichero separado en el guión actual de Hollywood.  Puede importar código fuente
de Hollywood  (ficheros *.hws) así como @{"miniaplicaciones de Hollywood" LINK Applets} (fichero
*.hwa).   El código que importe de los ficheros HWS/HWA se enlazará a su actual
proyecto incrustándose cuando genere los ejecutables, así que estos ficheros no
son necesarios posteriormente con los proyectos de Hollywood ya compilados.  La
importación  de  código  es  especialmente  útil  para grandes proyectos porque
fácilmente  se  complica  el echarle una ojeada cuando sólo se tiene un único y
largo  fichero  fuente.   La  idea  de  los ficheros de inclusión es dividir el
código  en partes lógicas o cómodas.  Por ejemplo, para un juego de plataformas
se  podría  dividir en la introducción, la gestión del menú, el motor de mapas,
los  niveles  y  el  propio  juego, pudiendo crear ahora los ficheros de código
fuente para cada parte, que en nuestro ejemplo, serían "Intro.hws", "Menu.hws",
"MotorMapas.hws",  "Niveles.hws"  y "Juego.hws".  Uno de los ficheros de código
fuente  ha  de  ser  el  código  principal, que será el que ponga en marcha con
Hollywood.

Otro  uso  podría  ser  la  creación  de bibliotecas para Hollywood en forma de
miniaplicaciones.  Podría publicarlas, de manera que otros programadores puedan
beneficiarse  de  ellas, importando la miniaplicación en sus propios proyectos.
La ventaja de publicar su biblioteca como miniaplicación de Hollywood es que no
expondrá  su  código fuente.  Las miniaplicaciones sólo contienen código-octeto
precompilado  y no es legible por el ser humano.  Así que si quiere proteger su
código,  pero  aún  así  desea  compartirlo  con  otros  usuarios, basta que lo
publique como una miniaplicación de Hollywood.

Volvamos  al  ejemplo del juego de plataformas que nos ha permitido repartir el
código en múltiples ficheros.  Asumamos que el fichero "Intro.hws" es el código
fuente  principal,  porque  la introducción o presentación es lo primero que el
usuario  final ve.  La cabecera de nuestro fichero "Intro.hws" tendría entonces
un aspecto como el siguiente:

  \@INCLUDE "Menu.hws"
  \@INCLUDE "MotorMapas.hws"
  \@INCLUDE "Niveles.hws"
  \@INCLUDE "Juego.hws"

  MostrarIntro()
  MostrarMenu()          ; Función "MostrarMenu()" declarada en "Menu.hws"
  EjecutarJuego()        ; "EjecutarJuego()" declarada en "Juego.hws"
  DibujarMapa()          ; "DibujarMapa()" declarada en "MotorMapas.hws"
  SiguienteNivel()       ; "SiguienteNivel()" declarada en "Niveles.hws"

Como ve,  usamos el comando del preprocesador @{"@INCLUDE" LINK atINCLUDE} para incluir los cuatro
ficheros  fuente  en  nuestro  fichero  "Intro.hws".  Esto nos permite llamar a
todas  las  funciones declaradas en estos cuatro ficheros desde nuestro fichero
fuente principal, o sea, en nuestro ejemplo, desde "Intro.hws".

Los  ficheros  de inclusión contienen sólo funciones, variables o declaraciones
de  constantes  en  la  mayoría  de los casos.  Si hay sentencias inmediatas en
ellos,  como  por  ejemplo  "DebugPrint("Hola")",  serán  ejecutadas  antes  de
cualquier  otro código del código fuente principal porque todos los ficheros de
inclusión  son  insertados  en  el  orden en que son declarados.  En el ejemplo
indicado  líneas  atrás, Hollywood abriría primero "Menu.hws" e insertaría este
código,   luego   "MotorMapas.hws",   seguido  de  "Niveles.hws"  y  finalmente
"Juego.hws".  Así que Hollywood compilaría algo como esto:

  \@INCLUDE "Menu.hws"
  \@INCLUDE "MotorMapas.hws"
  \@INCLUDE "Niveles.hws"
  \@INCLUDE "Juego.hws"

  <...contenidos del fichero "Menu.hws"...>
  <...contenidos del fichero "MotorMapas.hws"...>
  <...contenidos del fichero "Niveles.hws"...>
  <...contenidos del fichero "Juego.hws"...>
  MostrarIntro()
  MostrarMenu()
  ...

Como  ve  todos  los  ficheros  de inclusión se insertan ANTES de la sección de
código  de  su  código  fuente  principal.   Por  lo  tanto,  también todas las
sentencias inmediatas serán ejecutadas antes del código fuente principal.

Si  desea  incluir  miniaplicaciones,  simplemente  utilice  como argumento del
comando del preprocesador \@INCLUDE el fichero de una miniaplicación.

  \@INCLUDE "Prueba.hwa"            ; Importa funciones de "Prueba.hwa"

  FuncBiblio()   ;     Llama a "FuncBiblio()" definida en "Prueba.hwa"


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgIncludes"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgErrorHandling "Guía de Hollywood *UPD10*"

@{b}Manejo de errores@{ub}

Hay  múltiples  formas de lidiar con los errores en Hollywood.  Lo más sencillo
es  dejar  a  Hollywood que se encargue de todo.  Éste es el comportamiento por
defecto y Hollywood siempre terminará su guión cuando se genere un error dentro
de una función de Hollywood.  Considere el siguiente código:

  LoadBrush(1, "xyz")

Si  el  fichero  "xyz"  no  existe, Hollywood finalizará su guión y mostrará un
error que dirá "¡Imposible leer el fichero xyz!".

Si  no  le  gusta  este comportamiento, también puede indicarle a Hollywood que
llame  a  una función suministrada por usted cuando un error se produzca.  Esto
es posible llamando a la función @{"RaiseOnError()" LINK RaiseOnError} y suministrando una función de
retrollamada.   Aquí  tiene  cómo  puede reemplazar el manejador de errores por
defecto de Hollywood por un manejador a medida:

  Function p_ManejoErrores(codigo, msj$, cmd$, linea)
     DebugPrint(codigo, msj$, cmd$, linea)
  EndFunction
  RaiseOnError(p_ManejoErrores)
  LoadBrush(1, "xyz")

Si utiliza  estas líneas de código, al llamar a @{"LoadBrush()" LINK LoadBrush} con una brocha que
no  existe,  no  se  invocará al manejador de errores por defecto de Hollywood,
sino  que  se   invocará   a   la   función   del  usuario  "p_ManejoErrores()"
suministrándosele  información sobre el error que se ha producido.  Consulte la
función @{"RaiseOnError()" LINK RaiseOnError} para los detalles.

A  veces,  sin embargo, puede ser útil saber si una única llamada tiene éxito o
no.   Esto puede conseguirse desactivando temporalmente el manejador de errores
de Hollywood y obteniendo el código de error a partir de la última llamada a la
función, por ejemplo, como en este caso:

  ExitOnError(FALSE)       ; desactiva el manejador de errores por defecto
  LoadBrush(1, "xyz")
  error = GetLastError()
  ExitOnError(TRUE)        ; reactiva el manejador de errores por defecto

Estas  líneas  de  código  desactivan temporalmente el manejador de errores por
defecto  de Hollywood durante la llamada a @{"LoadBrush()" LINK LoadBrush}.  Tras ésta, se utiliza
@{"GetLastError()" LINK GetLastError} para  averiguar  si la llamada a @{"LoadBrush()" LINK LoadBrush} ha tenido éxito o
ha  fracasado.   Es  importante llamar a @{"GetLastError()" LINK GetLastError} inmediatamente tras la
función  a  comprobar  porque  la  bandera  interna  de error se reiniciará con
cualquier otro comando de Hollywood que se ejecute para reflejar con cada nuevo
comando si éste ha tenido éxito o no.

Ya  que  este  código  exige  multitud  de pulsaciones de teclado para algo tan
simple,  hay  también  un  pequeño caramelo sintáctico que hace lo mismo que el
código  anterior  reduciendo dramáticamente la cantidad de teclas a pulsar.  En
lugar de llamar  a  @{"ExitOnError()" LINK ExitOnError}  y  @{"GetLastError()" LINK GetLastError}  manualmente  como hemos
visto,  basta  con  que  añada  como prefijo a las llamadas de las funciones el
símbolo de apertura de interrogación.  El código quedaría así:

  error = ?LoadBrush(1, "xyz")

En  caso  de  que  una  función  devuelva otros valores y utilice el símbolo de
apertura  de  interrogación  para obtener un código de error al llamarla, todos
los demás valores, serán desplazados hacia abajo (NdT:  el que era primer valor
será el segundo, el segundo será el tercero y así sucesivamente).  El código de
error  siempre  será el primer valor devuelto.  Por ejemplo, si quiere utilizar
@{"la selección automática de ID(entificador)" LINK AutoIDSelect} con @{"LoadBrush()" LINK LoadBrush} y combina esto con
el símbolo de apertura de interrogación, tendremos que escribirlo así:

  error, id = ?LoadBrush(NIL, "xyz")

Normalmente  "id"  sería  el  primer  valor  devuelto,  pero  puesto  que hemos
utilizado  la sintaxis que incluye el símbolo de apertura de interrogación para
obtener  un  código  de error  de  @{"LoadBrush()" LINK LoadBrush},  el  primer  valor devuelto es
desplazado  convirtiéndose  ahora en el segundo valor devuelto ya que el código
de error será siempre el primer valor devuelto.

Finalmente,  para  verificar  si  un  error  se  ha  producido o no, sólo ha de
comparar  el  código  de error "error" con la constante #ERR_NONE, que tiene un
valor nulo por conveniencia, es decir, que si "error" no es cero sabrá que algo
ha  fallado.   En  este caso  podría utilizar @{"GetErrorName()" LINK GetErrorName} para convertir el
código  de  error  en  una cadena legible por el ser humano o implementar algún
sistema de gestión de errores a medida dependiendo del código de error que sea.
Consulte la sección sobre @{"los códigos de error" LINK ErrorCodes} para una lista de todos ellos.

Por  favor,  tenga  en  cuenta que algunos errores no pueden ser interceptados.
Por  ejemplo,  si suministra un número de argumentos erróneo a una función o si
suministra  variables  de  un  tipo incorrecto a una función, Hollywood siempre
saldrá  de  forma inmediata con un error fatal y su guión no tendrá oportunidad
de  procesarlos.   Incluso cuando se producen en tiempo de ejecución, Hollywood
los  considerará errores de sintaxis y terminará inmediatamente.  Aquí tiene un
ejemplo donde suministramos una cadena como primer argumento de @{"LoadBrush()" LINK LoadBrush} lo
cual está prohibido, pues se aguarda un número:

  ExitOnError(FALSE)
  LoadBrush("Hola", "xyz")
  ExitOnError(TRUE)

A  pesar  de  que  hemos  desactivado  el  manejador  de  errores  de Hollywood
suministrando   el  valor  FALSE   a  @{"ExitOnError()" LINK ExitOnError},  Hollywood  aún  detendrá
inmediatamente   la   ejecución  del  guión,  porque  el  argumento  "Hola"  de
@{"LoadBrush()" LINK LoadBrush}  es simplemente  incorrecto  y  Hollywood  lo considerará un error
grave, no permitiendo a su guión interceptar este error en forma alguna.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgErrorHandling"}

@ENDNODE
@REMARK =======================================================================
@NODE AutoIDSelect "Guía de Hollywood: Autoselección del identificador *UPD10*"

@{b}Autoselección del ID(entificador)@{ub}

Puede suministrar  el  valor @{"NIL" LINK PrgTypeNil}  como identificador  a todas las funciones en
las  que  quiera  solicitar un identificador para un nuevo objeto de Hollywood.
En  este  caso,  Hollywood  elegirá  automáticamente  un  identificador y se lo
devolverá.   Esto es especialmente útil para grandes proyectos.  Si su proyecto
es pequeño es mejor que haga usted la selección, como por ejemplo:

  LoadBrush(1, "brocha1.iff")
  LoadBrush(2, "brocha2.iff")
  LoadSample(1, "muestra.wav")
  OpenFile(1, "fichero.txt")

Sin  embargo,  cuando sus proyectos crezcan mucho  la gestión del identificador
puede  ser  bastante  liosa  y  nadie  quiere  enredarse  con  una  miríada  de
identificadores diferentes. Por ello, basta con que suministre el valor @{"NIL" LINK PrgTypeNil} en
lugar  del  identificador y Hollywood devolverá uno para el nuevo objeto con la
garantía  de  que  será  único,  puesto que se usa la variable de tipo especial
#LIGHTUSERDATA.

De  esta  forma, se asegura de que no surjan conflictos al suministrar el valor
@{"NIL" LINK PrgTypeNil},  pues Hollywood no elegirá el identificador entre los números enteros (es
decir,  del 1 al "n"), sino que creará identificadores únicos, lo que permitirá
que  todos  los identificadores normales se encuentren disponibles para el uso.
Por ejemplo:

  brocha1 = LoadBrush(NIL, "brocha1.iff")
  brocha2 = LoadBrush(NIL, "brocha2.iff")
  muestra1 = LoadSample(NIL, "muestra.wav")
  fichero1 = OpenFile(NIL, "fichero.txt")

Las  variables  "brocha1",  "brocha2",  "muestra1"  y  "fichero1"  no recibirán
identificadores  legibles  por  el usuario, sino identificadores especiales del
tipo  #LIGHTUSERDATA,  por  ello  todos los legibles por el usuario,  del  1 al
"n",  estarán  disponibles.   Por lo tanto, no tiene que preocuparse por ningún
conflicto  entre identificadores  cuando  use el valor @{"NIL" LINK PrgTypeNil} con una función que
cree  un  objeto, porque no puede producirse al utilizar Hollywood dos sistemas
separados de identificadores:  uno legible por el ser humano que sólo puede ser
utilizado  cuando usted transfiere un identificador a las funciones de creación
de  objetos  y  otro  mecanismo  opaco de identificadores que se utiliza cuando
usted suministra el valor @{"NIL" LINK PrgTypeNil} a las funciones de creación de objetos.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/AutoIDSelect"}

@ENDNODE
@REMARK =======================================================================
@NODE LoaderAdapterInfo "Guía de Hollywood: Cargadores y adaptadores *UPD10*"

@{b}Cargadores y adaptadores@{ub}

Muchas funciones de Hollywood soportan cargadores y adaptadores.  La diferencia
entre  unos y otros es la siguiente:  Un cargador añade un soporte adicional de
formatos  de  imagen,  sonido, video, iconos, tipos de impresión o animaciones,
mientras  que  un adaptador sustituye ciertas partes de Hollywood con su propia
implementación.

Por  ejemplo,  hay  adaptadores  de  visualización  que  pueden utilizarse para
sustituir  el manejador de visualización integrado de Hollywood por uno hecho a
medida  como  es  el  caso  de visualizaciones gestionadas por el sistema SDL u
OpenGL,  hay  adaptadores  de  red  que  permite  complementos  para ignorar la
implementación  de  redes  de  Hollywood  y...  naturalmente hay adaptadores de
fichero.

Estos  últimos, los adaptadores de fichero, pueden, por ejemplo, ser utilizados
para añadir soporte a nuevos contenedores de formato.  Así, pueden vincularse a
los  cargadores,  de manera que el adaptador suministra los datos en bruto para
que  luego  sean  interpretados por  el  cargador (por ejemplo una colección de
imágenes BMP empaquetadas en un ficher gzip, podrían ser desempaquetadas por su
adaptador para luego suministrar las imágenes BMP al cargador correspondiente).
Un  adaptador  de fichero también podría implementar el tratamiento de flujo de
datos de una fuente cualquiera, por ejemplo un servidor HTTP u otras fuentes.

A  partir  de  la versión 6.0 de Hollywood, casi todas las funciones que lidian
con  ficheros  le  permiten  especificar un cargador o un adaptador en su tabla
opcional de argumentos.  La idea tras este diseño es acelerar la carga de datos
externos.  Si no especifica un cargador o adaptador, Hollywood consultará todos
los  cargadores y adaptadores actualmente instalados para saber si pueden abrir
el  fichero.  Dependiendo del número de complementos que tenga instalados, esto
puede  ralentizar  las  cosas  de  forma  considerable  cuando  necesite cargar
múltiples  ficheros.   Si sabe qué cargador permite cargar sus datos externos o
el  adaptador  que puede manejarlos puede suministrar su nombre a la función de
carga para acelerar dicho proceso.

La  cadena que suministre a las etiquetas "Loader" o "Adapter" aceptadas por el
argumento   opcional  de  la  tabla  que  soportan  casi  todas  las  funciones
relacionadas  con  ficheros  ha  de estar compuesta de al menos un nombre de un
cargador   o  un  adaptador,  o  de  una  palabra  reservada  que  describa  un
cargador/adaptador  especial.   Se  soporta el uso de varios nombres y palabras
clave  siempre que se separen entre sí por el carácter barra vertical "|".  Las
palabras clave reservadas actualmente reconocidas son:

  * @{u}Default@{uu}

    Es  el modo de operación por defecto.  No puede combinarse con ninguna otra
    palabra  clave  ni  con ningún nombre de cargador/adaptador:  Siempre ha de
    utilizarse  independiente  de  los  demás.  En este modo, Hollywood primero
    consultará  todos  los cargadores/adaptadores disponibles como complementos
    para  ver  si  puedan  manejar o no el fichero y si no existe uno capaz, se
    consultarán  los  manejadores internos.  Si no hay manejadores internos que
    reconozcan  el  fichero,  se  pedirá  a  los cargadores nativos del sistema
    operativo anfitrión que carguen el fichero.

  * @{u}Inbuilt@{uu}

    Si  se  especifica esta palabra clave, los cargadores internos de Hollywood
    se consultarán, puedan o no manejar el fichero.  Los cargadores internos de
    Hollywood soportan los siguientes formatos de fichero:

      - Imagen:
        IFF ILBM, JPEG, PNG, GIF y BMP.

      - Animación:
        IFF ANIM, GIF ANIM y AVI MJPEG.

      - Sonido:
        IFF 8SVX, IFF 16SV, RIFF WAVE y Protracker.

      - Video:
        IFF CDXL.

  * @{u}Native@{uu}

    Si  se  especifica  esta palabra clave, Hollywood consultará con el sistema
    operativo  anfitrión  para intentar cargar el fichero.  Esta opción sólo se
    soporta con ciertos sistemas operativos que procedemos a resumir:

      - AmigaOS:

        En  este  caso  se  utilizarán los tipos de datos para cargar imágenes,
        animaciones y sonidos.  No hay un cargador nativo para video.

      - Windows:

        Hay  cargadores  de  sonido  y  video  nativos  basados en  el  sistema
        DirectShow  y  Media  Foundation  y  cargadores de imagen y animaciones
        basados en Windows Imaging Component.

      - macOS:

        Hay  cargadores nativos para imagen, video y sonido.  No hay cargadores
        nativos para animaciones.

      - Linux:

        No hay ningún cargador nativo.

      - iOS:

        Hay  cargadores  nativos  para  sonido,  video  e imagen basados en las
        tecnologías iOS.  No hay cargador nativo para animación.

      - Android:

        No hay ningún cargador nativo.

  * @{u}Plugin@{uu}

    Si  se  especifica  esta  palabra  clave,  Hollywood  comprobará  todos los
    complementos para averiguar si pueden manejar el fichero.  Los complementos
    se  llamarán en el orden en que han sido cargados por Hollywood, lo cual es
    bastante  aleatorio,  porque  depende  del  orden  en  el que el sistema de
    ficheros  se  los  devuelva  a  Hollywood.  Si quiere asegurarse que cierto
    complemento  es  llamado  para  manejar  un  fichero  antes que otro, ha de
    especificar  el  nombre  de  dicho  complemento  en  la  cadena en lugar de
    utilizar la palabra clave genérica "Plugin".

Si  utiliza  una  palabra  clave como "Plugin" y necesita buscar qué cargador o
adaptador  ha sido utilizado para cargar un fichero, puede realizar la consulta
con los atributos #ATTRLOADER o #ATTRADAPTER utilizando @{"GetAttribute()" LINK GetAttribute}.

Los  cargadores  y  adaptadores también pueden suministrar un nombre de formato
para  el  fichero  que pueden gestionar.  Puede obtener esta información con el
atributo #ATTRFORMAT.

Aquí tiene algunos ejemplos:

  LoadBrush(1, "prueba.png", {Loader = "inbuilt"})

Esta  línea  de  código  cargará el fichero especificado utilizando el cargador
integrado  para  imágenes  PNG.  No se consultará si se puede manejar la imagen
con algún complemento o cargador de imágenes del sistema operativo anfitrión.

  LoadBrush(1, "prueba.png", {Loader = "micmplt"})

Esta  línea  de  código  le  pedirá  al complemento "micmplt.hwp" que cargue el
fichero "prueba.png". Si el complemento falla en la carga, @{"LoadBrush()" LINK LoadBrush} también
fallará.   No se echará mano del cargador integrado de imágenes:  Si quiere que
sí  se haga, tendrá que añadir la cadena "inbuilt" en la etiqueta "Loader" como
en este caso:

  LoadBrush(1, "prueba.png", {Loader = "micmplt|inbuilt"})

En  este caso, se utilizará el cargador integrado de imágenes en caso de que el
cargador  suministrado  "micmplt.hwp"  fracase.  El siguiente código funcionará
bajo  AmigaOS,  Windows y macOS, pero fracasará en las demás plataformas puesto
que  no  tienen  un  cargador de imágenes nativo, tal como se indicó líneas más
atrás:

  LoadBrush(1, "prueba.png", {Loader = "native"})

Bajo  AmigaOS,  "prueba.png"  se  cargará  a  través del subsistema de tipos de
datos,  bajo Windows utilizando Windows Imaging Component y bajo macOS e iOS se
cargará  a  través de CoreGraphics.  Bajo Linux y Android, sin embargo, fallará
porque  Hollywood  no  dispone  de  un  cargador  nativo  de imágenes en dichas
plataformas.

También  puede  utilizar  las etiquetas "Adapter" y "Loader" conjuntamente, por
ejemplo:

  LoadBrush(1, "prueba.bmp.gz", {Adapter = "gzip", Loader = "inbuilt"})

Esta línea de código primero suministra el fichero "test.png.gz" al complemento
"gzip.hwp"   para   que   lo  desempaquete  y  el  resultado,  un  fichero  BMP
descomprimido,  se transfiere al cargador integrado de imágenes.  Naturalmente,
también  podría  haber  escrito  dicha  línea  de manera más simple funcionando
igualmente:

  LoadBrush(1, "prueba.bmp.gz")

Sin  embargo,  esta  opción  generaría  algo de sobrecarga en el sistema porque
Hollywood  primero  tendría  que  preguntar  a todos los adaptadores de fichero
cuáles pueden manejar el fichero comprimido "prueba.bmp.gz" y luego tendría que
preguntar a todos los complementos para carga de ficheros cuáles pueden manejar
el  formato  BMP.   Dependiendo  de cuantos complementos tenga instalados, esta
consulta  puede  llevar  cierto  tiempo, así que si sabe qué adaptador/cargador
quiere utilizar, se mejorará la carga si los indica de forma específica.

Tenga  en  cuenta  que  si  suministra múltiples cargadores o adaptadores a una
función  de  Hollywood  y los separa utilizando la barra vertical "|", el orden
será  el  indicado.   Por  ejemplo,  el  siguiente  código  primero  pedirá  al
complemento digibooster.hwp que abra el fichero y luego a xmp.hwp:

  OpenMusic(1, "sombras.dbm", {Loader = "digibooster|xmp"})

Esto también permite dar prioridad a ciertos cargadores genéricos como "Native"
(nativo),  "Inbuilt"  (integrado)  y  "Plugin"  (complemento).   Como se indicó
líneas  atrás,  Hollywood, por defecto, primero consultará los complementos que
sean  cargadores,  luego  a  los  internos  y luego a los nativos para abrir un
fichero.   Si  quiere  alterar  el  orden  para  un caso concreto, por ejemplo,
consultando primero los nativos, luego los internos y por últimos los ofrecidos
por  los  complementos, debe suministrar la cadena "native|inbuilt|plugin" para
conseguirlo.    Podría   también  cambiar  el  orden  por  defecto  globalmente
utilizando    @{"SetDefaultLoader()" LINK SetDefaultLoader}   y  @{"SetDefaultAdapter()" LINK SetDefaultAdapter},   respectivamente:
Consúltelas para los detalles.

Otra  ventaja  de  especificar  directamente  un cargador o un adaptador es que
permite  acceder a aquellos que están ocultos para un uso general.  Los autores
de los complementos pueden decidir escribir un cargador o adaptador que no esté
disponible  automáticamente  una  vez que Hollywood cargue el complemento, sino
cuando  éste  se utilice de forma explícita llamándolo a través del comando del
preprocesador @{"@REQUIRE" LINK atREQUIRE}  o suministrando directamente el nombre del complemento
a  las  etiquetas  "Loader"  /  "Adapter"  (dichas  etiquetas  permiten acceder
directamente a complementos ocultos).

A partir de la versión 8.0 de Hollywood también se soportan adaptadores de red.
Estos  adaptadores  siguen  el mismo principio que los adaptadores de fichero y
directorio,  es  decir,  pueden  utilizarse  para redirigir las funciones de la
biblioteca   de  red  "Network"  a  manejadores  a  medida  implementados  como
complementos de Hollywood.  Los adaptadores de red, por ejemplo, pueden mejorar
la  funcionalidad  de @{"DownloadFile()" LINK DownloadFile}  y @{"UploadFile()" LINK UploadFile}  para  soportar  también
conexiones  TLS/SSL.  También podrían utilizarse para implementar el soporte de
diferentes  redes  y  protocolos puesto que la interfaz del adaptador de red de
Hollywood  está  totalmente  desligada  de  cualquier  interfaz específica para
desarrollo  de  red,  lo  que  la  hace  muy  flexible  para adaptarla a nuevos
entornos.

A  partir  de  la  versión 10.0 de Hollywood también se soportan adaptadores de
sistemas  de  ficheros,  pudiendo utilizarse éstos para reemplazar prestaciones
del  sistema  de ficheros interno como el renombrado de ficheros y directorios,
creación  de  subdirectorios,  movimiento de ficheros y directorios,  etcétera,
por  otros  hechos a medida.  Multitud de funciones de Hollywood soportan estos
adaptadores como @{"CopyFile()" LINK CopyFile}, @{"MakeDirectory()" LINK MakeDirectory} o @{"DeleteFile()" LINK DeleteFile}.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/LoaderAdapterInfo"}

@ENDNODE
@REMARK =======================================================================
@NODE UserTagsInfo "Guía de Hollywood: Etiquetas del usuario *UPD10*"

@{b}Etiquetas del usuario@{ub}

Las  etiquetas del usuario son una forma de suministrar información adicional e
ilimitada  de  forma directa desde los guiones de Hollywood a los complementos.
La  mayoría  de los comandos de Hollywood que soportan complementos también
permiten   suministrarles   etiquetas   del  usuario  que  se  reenvían  a  los
complementos.   Naturalmente,  esto sólo tiene sentido si los datos del usuario
son reconocidos por el respectivo complemento.

Por  ejemplo,  supongamos  que  hay un complemento que puede cargar páginas PDF
como imágenes.   Esto  posibilita utilizar el comando @{"LoadBrush()" LINK LoadBrush} de Hollywood
para  crear una brocha a partir de una página PDF.  Sin embargo, funciones como
ésta  no soportan especificar un número de página o una contraseña (NdT:  si el
PDF  estuviera  protegido)  porque  no  están  iseñados  para cargar páginas de
documentos  PDF.   El  complemento  podría lidiar con esta limitación, bastando
definir  dos  simple  nuevas  etiquetas  de  usuario,  como  por ejemplo "Page"
(página)  y  "Password" (contraseña) y entonces los guiones podrían utilizarlas
para suministrarle esa información al complemento.

Desde  el  punto  de  vista  del  guión de Hollywood, las etiquetas del usuario
simplemente  se suministran en una tabla opcional "UserTags" que suelen admitir
la gran mayoría de funciones de Hollywood, por ejemplo, la propia "LoadBrush()"
ya  mencionada.  Esta tabla "UserTags" puede contener una cantidad ilimitada de
parejas  de  palabras  clave  y  valores  para definir las etiquetas de usuario
individualmente.   Tenga  en  cuenta  que la palabra clave siempre ha de ser un
índice  de  tabla  con nombre (cadena) como "Page" o "Password":  No es posible
utilizar  índices  numéricos como etiquetas de usuario.  El valor, sin embargo,
puede  ser una cadena (en cuyo caso, podría contener datos binarios) o un valor
numérico.

Volviendo  a nuestra ejemplo de líneas atrás, para suministrar una página y una
contraseña  ese  complemnto  de imagen a través de las etiquetas de usuario, un
guión de Hollywood podría simplemente hacer lo siguiente:

  ; carga la página nº 5 del fichero prueba.pdf como brocha
  ; suministrado la cadena "mics" como la contraseña
   LoadBrush(1, "prueba.pdf", {UserTags = {Page = 5, Password = "mics"}})

El  complemento podría consultar las etiquetas "Page" y "Password" para obtener
el  número  de  página  a  cargar  y  la  contraseña  de  acceso al fichero PDF
(suponiendo  que  estuviese protegido de tal manera).  Resumiendo, que por este
sistema  puede  suministrar  toda  la información adicional que necesiten a los
complementos de Hollywood, como ya hemos dicho.

Además, las etiquetas de usuario también son soportadas por muchos comandos del
preprocesador, así que podría hacer lo mismo que el ejemplo anterior así:

  ; carga la página nº 5 del fichero prueba.pdf como brocha
  ; suministrado la cadena "mics" como la contraseña
  \@BRUSH 1, "prueba.pdf", {UserTags = {Page = 5, Password = "mics"}}

Tenga  en  cuenta que las etiquetas del usuario son soportados por todo tipo de
complementos:   Los cargadores de imagen, de animación, de sonido, de video, de
iconos,  de  tipos  de impresión, los adaptadores de fichero, de directorio, de
visualización,   de   red  y  los  seriadores.   Los  cargadores  habitualmente
reenviarán estas etiquetas a los adaptadores (por ejemplo, a los de fichero).


                                                           @{">> Versión original" LINK "HollywoodEN.guide/UserTagsInfo"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgStyleguideSuggestions "Guía de Hollywood: Sugerencias de estilo *UPD10*"

@{b}Sugerencias de estilo@{ub}

Aquí  tiene  algunas  sugerencias  para  preservar la legibilidad de su código.
Como ha podido leer con anterioridad, Hollywood no distingue entre mayúsculas y
minúsculas,  pero  para que su código siga siendo legible le sugerimos que siga
estas normas de estilo:

  - Escriba  siempre  los  comandos/funciones  internas  como  aparecen  en  la
    documentación o al menos escriba su primera letra en mayúscula.

  - Escriba  las  constantes totalmente en mayúsculas para distingurilas de los
    nombres de las variables.

  - Escriba  todos  los  comandos  del  preprocesador  en  mayúsculas  para que
    destaquen.

  - ¡Un único comando/función por línea es suficiente!

  - Utilice el símbolo del dolar estadounidense "$" sólo en variables de cadena
    para evitar confusiones.

  - Utilice  el  símbolo  de  cierre  de  exclamación "!" sólo en variables que
    contengan valores de coma flotante para evitar confusiones.

  - Añadir algunos comentarios no hará daño a nadie.

  - Cuando  utilice los bloques "If" y los bucles, debería utilizar tabuladores
    para estructurar visualmente a través del sangrado los diferente niveles.

  - Debería  añadir  a sus propias funciones el prefijo "p_" para distinguirlas
    de las  funciones  de Hollywood (en futuras versiones de Hollywood, podrían
    introducirse  funciones  con  el  mismo  nombre  que las suyas obteniéndose
    resultados inesperados).


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgStyleguideSuggestions"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeIntro "Guía de Hollywood: Tipos de datos *UPD10*"

@{b}Generalidades@{ub}

Este  capítulo  cubre  todos  los tipos de datos disponibles en Hollywood.  Los
siguiente cinco tipos de datos son los que se ofrecen:

  @{"Número   " LINK PrgTypeNumber} Valores numéricos como 1, 2, $FF, 3.5, 1.7e8, TRUE, FALSE, 'a'
  @{"Cadena   " LINK PrgTypeString} Secuencias de caracteres, habitualmente en textos como "Hola"
  @{"Tabla    " LINK PrgTypeTable} Colecciones de ítems de datos de igual o diferentes tipos
  @{"Función  " LINK PrgTypeFunc} Rutinas invocables por el usuario
  @{"NIL      " LINK PrgTypeNil} Significa que una variable no tiene ningún valor

Puede  averiguar  el  tipo  de  dato  de  una  variable  utilizando  la función
@{"GetType()" LINK GetType}.  Por ejemplo:

  GetType(1)                 -> devuelve #NUMBER
  GetType(2.5)               -> devuelve #NUMBER
  GetType(TRUE)              -> devuelve #NUMBER
  GetType('x')               -> devuelve #NUMBER
  GetType(#STRING)           -> devuelve #NUMBER
  GetType("¿Quién soy?")     -> devuelve #STRING
  GetType({1, 2, 3})         -> devuelve #TABLE
  GetType(DebugPrint)        -> devuelve #FUNCTION
  GetType(NIL)               -> devuelve #NIL


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeIntro"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeNumber "Guía de Hollywood: Números *UPD10*"

@{b}Números@{ub}

El  tipo  de dato "número" puede ser utilizado para almacenar números enteros y
números  reales.   Internamente, todos los números son almacenados como valores
de  coma  flotante  de 64 bits, lo que significa que puede utilizar enteros muy
largos  y  números  reales  muy  precisos.  El tipo numérico puede teóricamente
almacenar números comprendidos entre 1.7*10^-308 y 1.7*10^308.  El ranto de los
enteroe está comprendido entre desde -9007199254740992 a 9007199254740992.

También  puede  especificar  números  en  formato  hexadecimal  utilizando  los
prefijos "$" o "0x" como por ejemplo:

  a = $FF     ; a = 255

Los  números  de  coma  flotante  también  pueden  especificarse  utilizando la
notación exponencial, como por ejemplo:

  a = 2.5e5   ; a = 2.5 * 10^5  => a = 250000

El  cero  es opcional para valores de coma flotante entre -1 y 1, de manera que
el siguiente código debería funcionar también:

  a = .25 * 2 ; a = 0.5

Aunque  Hollywood  no tiene tipos de datos separados para los números enteros y
los de coma flotante, existe la sugerencia estilística de añadir como sufijo el
símbolo  de  cierre  de exclamación "!" para los valores de coma flotante, como
por ejemplo:

  a! = 3.14159265

Esto  mejora  la  legibilidad  de  su  código,  porque  se sabe exactamente qué
variables  contendrán  sólo  valores enteros y cuáles valores de coma flotante.
Naturalmente,  puede utilizar valores en coma flotante sin utilizar ese sufijo,
pero se recomienda su uso.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeNumber"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeString "Guía de Hollywood: Cadenas *UPD10*"

@{b}Cadenas@{ub}

El  tipo  de  dato "cadena" puede ser utilizado para almacenar una secuencia de
caracteres  o  de datos binarios.  Por defecto, el texto se almacena utilizando
la  codificación  UTF-8  lo  que  significa  que  pueden  ser  necesarios hasta
4 octetos para almacenar un único carácter Unicode.  Las cadenas se especifican
encerrándolas  entre  comillas  dobles.  Por cuestión de estilo, debería añadir
siempre  a sus variables el sufijo el símbolo del dólar estadounidense "$" para
que  aquel  que  consulte  el  código  fuente  pueda identificar fácilmente qué
variables almacenan cadenas y cuáles almacenan números.  Por ejemplo:

  a$ = "¡Hola amigos!"

Esto podría escribirse también así:

  a = "¡Hola amigos!"

Pero  con  el  símbolo  del dólar al final, el código es más legible ya que nos
informa que "a" es una cadena.

Puede  concatenar  cadenas  utilizando  el  operador  "..".  El código anterior
podría escribirse también así:

  a$ = "¡Hola" .. " " .. "amigos!"

Esto concatenará las tres cadenas en una única y la guardará en "a$".  Consulte
la sección sobre @{"Concatenación de cadenas" LINK PrgOprStrng} para los detalles.

Si  su cadena  necesita  contener comillas dobles,  puede utilizar el código de
escape  \\"  (barra  inclinada  invertida, seguida de las comillas dobles) para
ello.  Por ejemplo:

  DebugPrint("¡Hola, \\"Sr. Juan Nadie\\"!")  ; Imprime ¡Hola, "Sr. Juan Nadie"!

Los códigos de escape siempre se especifican tras una barra inclinada invertida
"\\".  Si necesita que una cadena contenga dicha barra inclinada invertida como
carácter,  utilice  la  propia  barra como código de escape, o sea, escriba dos
barras  invertidas  seguidas así "\\\\".  Se soportan las siguientes secuencias
de escape:

    \\a    Genera el sonido del sistema
    \\b    Retroceso
    \\f    Salto de página
    \\n    Nueva línea
    \\r    Retorno de carro
    \\t    Tabulador horizontal
    \\v    Tabulador vertical
    \\\\    Barra (inclinada) invertida
    \\"    Comillas (dobles)
    \\'    Comilla simple
    \\?    (Cierre de) interrogación
    \\[    Corchete de apertura
    \\]    Corchete de cierre
    \\xxx  Posición del código

La  última  secuencia  de  escape  de  la relación anterior le permite insertar
caracteres  directamente,  bastando con especificar el valor de la posición del
código  tras  la  barra inclinada invertida.  Este valor ha de especificarse en
notación  decimal  y  puede  ocupar  hasta  tres dígitos.  Sólo se permiten los
caracteres  del juego LATIN 1 que tienen posiciones comprendidas entre 0 y 255:
Cualquier  valor mayor de 255 será rechazado.  Utilizando secuencias de escape,
podría  insertar  el  carácter  nulo NUL (el valor de su posición del código es
cero) en una cadena:

  a$ = "¡Hola\\0amigos!"

En  múltiples  lenguajes  de  programación  este  cáracter nulo se utiliza como
finalizador de la cadena.  No ocurre así en Hollywood, pues éste permite el uso
de  tantos  caracteres nulos como desee en sus cadenas.  Todas las funciones de
la  biblioteca  de  cadenas "String" son seguras en cuanto al uso de caracteres
nulos.  Por ejemplo, este código devolvería el valor 11:

  DebugPrint(StrLen("¡Hola\\0amigos!"))

Sin embargo, esto no se aplica a funciones que generan una salida de texto.  El
siguiente  ejemplo  imprimirá  únicamente  "Hola",  debido al caracter nulo que
incluye la cadena:

  DebugPrint("Hola\\0amigos")      /* Imprime "Hola" por culpa del caracter nulo
                                      que actúa como terminador de la cadena */

Si  tras  la barra inclinada invertida hay un salto de línea, Hollywood también
insertará  dicho  salto de línea en la cadena y continuará procesando la cadena
en  la línea siguiente.  Por ejemplo, las dos instrucciones siguientes crean la
misma cadena:

  a$ = "¡Hola\\namigos!"

  a$ = "¡Hola\\
  amigos!"

Si utiliza esta prestación, asegúrese de que el carácter de salto de línea está
inmediatamente  a continuación de la barra invertida.  ¡No puede haber espacios
o símbolos de tabulación entre la barra invertida y el salto de línea!

Otra  forma  de  especificar cadenas es utilizar los dobles corchetes.  Es útil
especialmente  si  tiene múltiples líneas de texto que tengan que ser colocadas
dentro de la cadena.  Un ejemplo:

  a$ = [[
  <HTML>
  <HEAD>
  <TITLE>Mi página HTML</TITLE>
  </HEAD>
  <BODY>
  <A HREF="http://www.airsoftsoftwair.de/" TARGET="_NEW">
  http://www.airsoftsoftwair.de/</A>
  </BODY>
  </HTML>
  ]]

La cadena de inicialización anterior es idéntica a este código:

  a$ = "<HTML>\\n<HEAD>\\n<TITLE>Mi página HTML</TITLE>\\n</HEAD>\\n" ..
       "<BODY>\\n" ..
       "<A HREF=\\"http://www.airsoftsoftwair.de/\\" TARGET=\\"_NEW\\">" ..
       "http://www.airsoftsoftwair.de/</A>\\n</BODY>\\n</HTML>\\n"

Como  ve,  la  primera versión es mucho más legible.  Así que si desea utilizar
cadenas  de  múltiples  líneas,  es  aconsejable utilizar la versión con dobles
corchetes.   Si  un  carácter  de nueva línea "\\n" sigue a los dobles corchetes
iniciales,  entonces  este  carácter  se  ignorará.  Los retornos de carro "\\r"
nunca  se  incluyen  dentro  de  la larga cadena.  Cada finalización o salto de
línea  dentro  de  la  larga cadena se convertirá en un carácter de nueva línea
"\\n".   También  puede  utilizar  libremente  comillas  dobles  en  una  cadena
delimitada con los dobles corchetes, lo cual es otra ventaja.

También  puede  almacenar  datos  binarios  sin  formato  en  las cadenas:  Por
ejemplo,  la función @{"DownloadFile()" LINK DownloadFile} puede utilizarse para descargar un fichero
directamente  en una cadena. Cuando se almacenan datos binarios en las cadenas,
debe  de  tener  cuidado al llamar a las funciones de la biblioteca de cadenas,
puesto que éstas esperan datos con codificación UTF-8 válida en dichas cadenas.
Obviamente esto no se cumplirá cuando las cadenas se utilicen como contenedores
de  datos  binarios  sin  formato,  así  que  para  que dichas funciones operen
correctamente, tendrá que suministrarles la constante especial #ENCODING_RAW en
el  parámetro opcional que aceptan la mayoría de las funciones de la biblioteca
de  cadenas.  Consulte  la sección  @{"Codificaciones de los caracteres" LINK CharacterEncoding}  para los
detalles.

Para  terminar,  señalar  que  no  hay  límite  en  cuanto a la longitud de las
cadenas, pudiendo ser tan largas como lo permita la memoria.  Pero en casos que
almacene  grandes  cantidades  de  datos  en éstas debe tener cuidado y definir
dichas  cadenas  con  el pseudovalor @{"NIL" LINK PrgTypeNil} cuando ya no necesite esos datos para
que  @{"el recolector de basura" LINK PrgGarbageCollector} sepa  que puede liberar la memoria reservada  por
dichas cadenas.  Considere el siguiente ejemplo:

  dat$ = DownloadFile("http://www.airsoftsoftwair.de/images/" ..
                             "products/hollywood/47_shot1.jpg")
        ...más código que hace algo con el contenido de "dat$"...
  dat$ = NIL

Estas líneas de código descargarán el fichero del URL especificado y almacenará
los  datos  binarios  en  la  variable  "dat$".  Una vez que los datos han sido
procesados,  la variable  "dat$" se define como @{"NIL" LINK PrgTypeNil} para indicarle a Hollywood
que  puede  liberarse la memoria ocupada por dicha variable.  Es muy importante
porque de otra forma su guión podría consumir constantemente más memoria.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeString"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeTable "Guía de Hollywood: Tablas *UPD10*"

@{b}Tablas@{ub}

Una  tabla  es  una  colección  de  diferentes ítems de datos que pueden ser de
cualquier  tipo.  Se trata una estructura de datos universal en Hollywood y así
puede  ser  utilizada  de  diferentes  formas,  como una matriz, una lista o un
registro,   por   ejemplo.    Las   tablas   se  crean  utilizando  el  llamado
"constructor":  {...}.  Por ejemplo, el siguiente código crea una tabla vacía:

  a = {}

Una  tabla  vacía  no  incluye  datos  en  ella  y  es  una tabla aún sin usar.
Hollywood,  sin embargo, exige que todos los campos de una tabla se inicialicen
antes  de  utilizarse  y  por  ello,  si accedió a un campo de esta tabla vacía
ahora, por ejemplo así:

  b = a[0]

habrá obtenido un mensaje de error puesto que el primer elemento no ha sido aún
inicializado.    Sólo   puede   acceder  a  campos  de  la  tabla,  previamente
inicializados.  La versión correcta para su uso sería así:

  a[0] = 5     ; se asigna 5 al primer elemento de la tabla "a"
  b = a[0]     ; se asigna 5 a la variable "b"

O podría utilizar el propio constructor para inicializar la tabla:

  a = {5}      ; crea una tabla "a" con el valor 5 como primer elemento
  b = a[0]     ; asigna "5" a la variable "b"

También  puede  utilizar  el constructor para inicializar múltiples ítems de la
tabla.   La asignación a través del constructor se inicia a partir del elemento
con número de índice cero.  Por ejemplo:

  a = {1, 2, 4, 8, 16, 32, 64, 128, 256} ; crea una tabla con 9 elementos
  b = a[7]     ; asigna 128 a "b" (128 ocupa la 7ª posición en "a")

Adicionalmente,  puede utilizar @{"las declaraciones Dim  y  DimStr" LINK PrgDim}  para crear e
inicializar una tabla de un tamaño especificado.

Algo  que  es importante saber cuando trate con las tablas es que cuando asigna
una  tabla a una nueva variable, esta nueva variable sólo recibe una referencia
a  la tabla, no una copia independiente de dicha tabla.  Considere el siguiente
código:

  a = {1, 2, 3, 4, 5}       ; crea una tabla de cinco (5) elementos
  b = a                     ; crea una REFERENCIA de "a" en "b"
  b[0] = 2                  ; cambia el primer elemento por el valor 2
  DebugPrint(a[0], b[0])    ; imprimirá "2 2"

Si  quiere  crear  una  copia  indenpendiente  de  una tabla, puede utilizar la
función @{"CopyTable()" LINK CopyTable} para ello.

En  Hollywood,  los  índices  no  tienen porqué ser sólo enteros positivos:  Se
permiten  enteros  negativos,  valores de coma flotante e incluso cadenas.  Por
ejemplo, también puede inicializar elementos negativos en una tabla:

  a       = {}  ; crea una tabla vacía
  a[-5]   = 3   ; asigna 3 al número de índice -5
  a[1.5]  = 2   ; asigna 2 al número de índice 1.5

Si  quiere  realizar  una inicialización a medida en el constructor, tendrá que
utilizar corchetes.  Las tres líneas anteriores se escribirían así:

  a = {[-5] = 3, [1.5] = 2}   ; inicializa una nueva tabla

Si  quiere  utilizar  cadenas  como  índices,  puede hacerlo con las siguientes
declaraciones:

  a           = {}           ; crea una tabla vacía
  a["nombre"] = "Juan Nadie" ; asigna "Juan Nadie" al índice "nombre"
  a["edad"]   = 20           ; asigna 2 al índice "edad"
  a["sexo"]   = "masculino"  ; asigna "masculino" al índice "sexo"

Una forma sencilla de utilizar las cadenas como índices es utilizar expresiones
que  incluyen como símbolo el punto ".".  El siguiente código hace lo mismo que
el anterior:

  a          = {}            ; crea una tabla vacía
  a.nombre   = "Juan Nadie"  ; asigna "Juan Nadie" al índice "nombre"
  a.edad     = 20            ; asigna 20 al índice "edad"
  a.sexo     = "masculino"   ; asigna "masculino" al índice "sexo"

Por  último,  pero  no menos importante, también puede usar el constructor para
inicializar  una  tabla  con  índices  con nombre.  El siguiente código hace lo
mismo que los dos fragmentos inmediatamente anteriores de código:

  a = {["nombre"] = "Juan Nadie", ["edad"] = 20, ["sexo"] = "masculino"}

O de una forma más sencilla:

  a = {nombre = "Juan Nadie", edad = 20, sexo = "masculino"}

Además puede acceder a elementos con nombre (de una tabla) de dos maneras:

  b = a["nombre"]
  b = a.nombre

Ambas  líneas  asignarán el mismo valor a "b".  La forma más común de acceder e
inicializar elementos con nombre de una tabla es usar el método del punto.  Por
favor, tenga en cuenta que Hollywood no distingue entre nombres en mayúsculas y
minúsculas,  de  manera  que  puede  acceder  a  los  elementos  antes  citados
utilizando "a.NOMBRE" o incluso "a.nOmBrE".

Hay,  sin embargo, una excepción: Cuando se utilizan corchetes para inicializar
o  acceder  a  campos  de  una  tabla,   Hollywood distingue entre mayúsculas y
minúsculas con los índices que son cadenas.  Encontrará más detalles sobre este
tópico en la documentación del comando @{"RawGet()" LINK RawGet}: Consúltela para los detalles.

Puede  añadir  elementos  a  una  tabla  simplemente asignándoles un valor.  Si
quiere  borrar elementos,  ha de definir sus valores usando @{"NIL" LINK PrgTypeNil}.  Esta es otra
gran ventaja, la tipificación dinámica, del lenguaje de programación Hollywood.
Las  tablas  (matrices,  listas)  no  están  limitadas a un tamaño específicos:
pueden crecer o decrecer según desee.

También  puede  usar tablas  que combinen elementos con nombre y numerados, por
ejemplo:

  a = {x = 1, y = 2, 10, 11, 12, 13, z = 3, [6] = 16, 14, 15, obj="Cubo"}

Esto  crea  una  nueva  tabla  e inicializa los elementos del nº 0 al 6 con los
números  del  10  al 16.  Adicionalmente, se crean cuatro elementos denominados
"x", "y", "z" y "obj" que son inicializados con los valores 1, 2, 3 y "Cubo".

Ahora  echemos una ojeada a algunas construcciones más complejas de tablas, así
que si es un novato en Hollywood podría querer saltar la siguiente sección.

Es posible usar tablas dentro de tablas.  Eche una ojeada al siguiente ejemplo:

  bt = { {x1 = 0, y1 = 0, x2 = 100, y2 = 50},
         {x1 = 100, y1 = 0, x2 = 80, y2 = 50},
         {x1 = 180, y1 = 0, x2 = 100, y2 = 50} }

Este  código  crea  una nueva tabla llamada "bt" e inicializa los tres primeros
elementos  con  tablas que contienen la posición inicial y final de cada botón.
Podríamos usar el siguiente código para crear estos tres botones:

  For k = 0 To 2
    CreateButton(k + 1, bt[k].x1, bt[k].y1, bt[k].x2, bt[k].y2)
  Next

Las  tablas  multidimensionales  no son problema.  El siguiente código crea una
matriz de 50x100 y la inicializa con ceros:

  N = 50
  M = 100
  mtx = {}                    ; crea una tabla vacía
  For i = 0 To N - 1
    mtx[i] = {}               ; crea una nueva fila
    For j = 0 To M - 1
      mtx[i][j] = 0           ; inicializa un elemento
    Next
  Next

También  puede  utilizar  @{"las declaraciones Dim  y  DimStr" LINK PrgDim}  para crear  tablas
multidimensionales.

No  puede  utilizar  constantes  cuando  inicialice  una  tabla  a  través  del
constructor.  Sin embargo, puede usar variables cuando quiera.  Por ejemplo:

  s$ = "prueba"
  i = 5
  a = {[s$] = "Un elemento", [i * 5 + 1] = "Otro elemento"}

Este  código  creará un elemento "a.prueba" (que es lo mismo que a["prueba"]) y
asignará  la  cadena  "Un  elemento"  a él.  Además, creará el elemento a[26] y
asignará a éste la cadena "Otro elemento".

No se sienta confuso cuando vea algo así:

  x = 5
  y = 4
  a = {x = x, y = y}     ; asigna 5 a "x" y 4 a "y"

La declaración de la tabla anterior no es algo sin sentido:  Crea una tabla con
dos  elementos  denominados  "x" e "y".  El elemento "x" obtiene el valor de la
variable  "x"  que  a  su  vez  contiene  el valor numérico 5 y el elemento "y"
obtiene  el  valor  de  la variable "y" que contiene el valor numérico 4.  Otra
forma de escribir el código anterior es por ejemplo:

  x = 5
  y = 4
  a = {}        ; tabla vacía
  a.x = x       ; asigna 5 a "a.x"
  a.y = y       ; asigna 4 a "a.y"

Ambos fragmentos hacen exactamente lo mismo.

Finalmente, puede colocar funciones en sus tablas.  Aquí tiene un ejemplo:

  a = {Sumar = Function(v1, v2) Return(v1 + v2) EndFunction,
      MostrarBrocha = DisplayBrush}
  a.MostrarBrocha(1, #CENTER, #CENTER)  ; llama a "DisplayBrush()"
  b = a.Sumar(15, 16)                   ; devuelve 31 asignándolo a "b"

El  código  anterior creará una tabla con dos funciones.  La primera función es
una función a medida que suma dos valores y la segunda función simplemente hace
referencia  a la  función @{"DisplayBrush()" LINK DisplayBrush}.  Podría también escribir este código
de la siguiente forma:

  a = {["Sumar"] = Function(v1, v2) Return(v1 + v2) EndFunction,
       ["MostrarBrocha"] = DisplayBrush}
  a["MostrarBrocha"](1, #CENTER, #CENTER)  ; llama a "DisplayBrush()"
  b = a["Sumar"](15, 16)                   ; devuelve 31 asignándolo a "b"


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeTable"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeFunc "Guía de Hollywood: Funciones *UPD10*"

@{b}Funciones@{ub}

Sí, es cierto:  Las funciones también son parte de nuestro capítulo sobre tipos
de  datos,  puesto  que  en Hollywood cada función es simplemente una variable.
Eso  significa  que  puede inicializarlas como éstas, puede traspasar funciones
como  parámetros  a  otras  funciones  y  las  funciones también pueden ser los
valores devueltos por otras funciones.  Por ejemplo, el siguiente código:

  p_Imprimir = Function(s) DebugPrint(s) EndFunction

es otra forma de escribir:

  Function p_Imprimir(s)
      DebugPrint(s)
  EndFunction

Debido a que las funciones son variables, usted puede también asignarles nuevos
valores, como por ejemplo:

  DebugPrint = Print

Ahora  cuando  invoque a @{"DebugPrint()" LINK DebugPrint} en realidad estará invocando en su lugar
al comando @{"Print()" LINK Print}.

Hay  mucho  más  que  saber  sobre  este  tipo de dato, pero ya tiene su propio
capítulo en este manual: Consulte la sección de @{"funciones" LINK PrgFunctions} para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeFunc"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTypeNil "Guía de Hollywood: NIL *UPD10*"

@{b}NIL@{ub}

Si  utiliza  una variable sin asignarle un valor, la variable tendrá el tipo de
dato (o pseudovalor) NIL que prácticamente significa que la variable no existe.
Hollywood  sólo  gestiona las variables que tienen un valor:  Si suministra una
variable  no inicializada a una función o la utiliza con un operador, ésta será
inicializada  automáticamente  a  cero o, si la función espera una cadena, como
una cadena vacía "".

Si no necesita  ya una variable,  puede definirla como NIL y será borrada en el
próximo  ciclo  del @{"recolector de basura" LINK PrgGarbageCollector}.  También puede borrar un elemento de
una tabla definiendo éste como NIL.

Tenga cuidado cuando compruebe si las variables tienen un valor NIL, puesto que
la  igualdad  "0  =  NIL"  actualmente es verdadera en Hollywood y devolverá un
valor TRUE,  de  manera  que  esta  simple  comprobación  NO sirve:  @{"IsNil()" LINK IsNil} y
@{"GetType()" LINK GetType}  son las únicas formas fiables de averiguar si una variable será del
tipo NIL.

                                    --==--

       NOTA IMPORTANTE:  En la traducción en español de la documentación
              TRUE, FALSE y NIL se han escrito en mayúsculas como
             las constantes precedidas con el símbolo almohadilla
       sólo por cuestión de mejorar la legibilidad del documento, o sea,
   que es válido y equivalente escribir NIL, nil, Nil, nIl, ... por ejemplo.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTypeNil"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOpr "Guía de Hollywood: Expresiones *UPD10*"

@{b}Generalidades@{ub}

Una expresión es una combinación de operandos y operadores.  Si existe al menos
un  operando  y  un  operador,  hablamos  de una expresión.  Hollywood necesita
evaluar  las  expresiones  antes  de  que  pueda  transferir su resultado a una
función.   Una  expresión  puede  ser  constante  o variable, dependiendo de si
contiene  variables  o no.  Por ejemplo, 5 + 3 es una expresión.  Los operandos
son 5 y 3 y el operador es "+".  -1 también es una expresión porque tiene tanto
un operador como un operando.  Habitualmente los operadores son binarios lo que
significa  que  necesitan dos operandos, pero hay excepciones:  Por ejemplo, el
operador negación "-" es unario y sólo requiere un operando.

Puede  utilizar  paréntesis en expresiones para indicarle a Hollywood qué es lo
que deberá evaluar primero.  En la siguiente línea:

  a = (3 + 4) * 5

Hollywood primero sumará tres y cuatro y luego multiplicará dicho resultado por
cinco.   Si  no incluyese los paréntesis en el código citado, Hollywood primero
evaluaría  el  producto  de  cuatro por cinco y luego sumaría a dicho resultado
tres,  puesto  que  el  operador  producto "*" tiene una mayor prioridad que el
operador  adición  "+".   Consulte  la  sección  sobre  @{"las prioridades de los" LINK PrgOprPri}
@{"operadores" LINK PrgOprPri} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOpr"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprArith "Guía de Hollywood: Operadores aritméticos *UPD10*"

@{b}Operadores aritméticos@{ub}

Hollywood soporta los siguientes operadores aritméticos:

    +---------------------------------------------------------------------+
    +                              @{b}BINARIO@{ub}                                +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +            +                  Adición                  a + b        +
    +            -                Sustracción                a - b        +
    +            *                  Producto                 a * b        +
    +            /               División real               a / b        +
    +            \\             División entera               a \\ b        +
    +            %           Resto de la división            a % b        +
    +            ^               Potenciación                a ^ b        +
    +---------------------------------------------------------------------+

    +---------------------------------------------------------------------+
    +                              @{b}UNARIO@{ub}                                 +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +             -                Negación                   -a          +
    +---------------------------------------------------------------------+

Debería ser bastante autoexplicativo cómo se utilizan estos operadores, así que
aquí tiene sólo una breve descripción de cada operador:

  Adición: a + b
  - Suma "a" y "b", por ejemplo 5 + 3 = 8

  Sustracción: a - b
  - Resta "b" de "a", por ejemplo 10 - 5 = 5

  Producto: a * b
  - Multiplica "a" por "b", por ejemplo 10 * 8 = 80

  División real: a / b
  - Realiza  una división exacta, no pudiendo ser "b" nulo (o sea, no puede ser
    igual  a  cero).   El  valor  resultante  por  lo  tanto podría ser de coma
    flotante, por ejemplo 5 / 2 = 2.5,

  División entera: a \\ b
  - Divide "a" entre "b", no pudiendo ser "b" nulo (o sea, no puede ser igual a
    cero).  Las posiciones decimales serán eliminadas, por ejemplo 5 \\ 2 = 2

  Resto de la división: a % b
  - Devuelve  el resto entero de la división "a" \\ "b", por ejemplo 5 % 2 = 1,
    pero NO pudiendo ser "b" nulo (o sea, no puede ser igual a cero).

  Potenciación: a ^ b
  - Calcula la potencia "b" de "a" ("a" elevado a "b"), por ejemplo 2 ^ 8 = 256

  Negación: -a
  - Niega "a", por ejemplo --5 = 5


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprArith"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprRelat "Guía de Hollywood: Operadores relacionales *UPD10*"

@{b}Operadores relacionales@{ub}

Hollywood soporta los siguientes operadores relacionales:

    +---------------------------------------------------------------------+
    +                              @{b}BINARIO@{ub}                                +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +            =                   Igual                   a = b        +
    +            <>                 Distinto                 a <> b       +
    +            <                 Menor que                 a < b        +
    +            >                 Mayor que                 a > b        +
    +            <=             Menor o igual que            a <= b       +
    +            >=             Mayor o igual que            a >= b       +
    +---------------------------------------------------------------------+

Cada  uno de los operadores compara los operandos "a" y "b" y devuelve TRUE si
la  condición  se cumple y FALSE en otro caso.  Por favor, tenga en cuenta que
sólo  puede  comparar  valores  del  mismo  tipo.  ¡La conversión automática de
número a cadena NO se aplica a esta situación!

Los  operadores  de  igualdad pueden utilizarse con todos los tipos, y así, por
ejemplo también puede comparar funciones y tablas con ellos.  Los operadores de
orden  ("<", ">", "<=", ">=") sólo funcionan con números y cadenas.  Si compara
cadenas  con  ellos,  Hollywood  realizará una comparación alfabética, como por
ejemplo:

  r = ("Hola" < "Manuel")     -> El resultado es TRUE porque la 'H'
                                 está antes que la 'M' alfabéticamente.
  r = ("Commodore" < "Amiga") -> El resultado es FALSE porque la 'C'
                                 está después que la "a" alfabéticamente.

Tenga en cuenta que por razones de compatibilidad, en la comparación de cadenas
con  los  operadores  relacionales sólo se soportan los caracteres ASCII.  Para
comparar  cadenas  con  codificación  Unicode  completa, utilice en su lugar la
función @{"CompareStr()" LINK CompareStr}:  Consúltela para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprRelat"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprLogic "Guía de Hollywood: Operadores lógicos *UPD10*"

@{b}Operadores lógicos@{ub}

Hollywood soporta los siguientes operadores lógicos:

    +---------------------------------------------------------------------+
    +                              @{b}BINARIO@{ub}                                +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +            And                Y lógico                a And b       +
    +            Or           O lógico (inclusivo)          a Or b        +
    +---------------------------------------------------------------------+

    +---------------------------------------------------------------------+
    +                              @{b}UNARIO@{ub}                                 +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +            Not               NO lógico                 Not a        +
    +---------------------------------------------------------------------+

Los  operadores lógicos binarios permiten tomar decisiones basadas en múltiples
condiciones,  necesitando  dos  operandos  que  se  utilizan  para  evaluar  el
resultado de la condición lógica. Todos los valores que no son cero, @{"NIL" LINK PrgTypeNil} o una
cadena vacía "" se asimilan al valor TRUE.

Los  operadores  "And"  (Y)  y  "Or" (O inclusivo) utilizan atajos a la hora de
evaluar  expresiones:   Eso  significa  que  si el primer operando ya define el
resultado,  el segundo no se evalúa.  Por ejemplo, si el primer operando de una
expresión "And"  es @{"falso (cero)" LINK PrgTrueFalse}, entonces el segundo ya no necesita evaluarse
porque  ya no podrá ser verdadera en forma alguna (no cero). Lo mismo se aplica
a una expresión "Or" y así si el primer operando  es @{"verdadero (no cero)" LINK PrgTrueFalse}, pues
la expresión será automáticamente verdadera independiente del valor del segundo
operando.

Por  favor,  tenga en cuenta que "And" y "Or" no devuelven la constante TRUE si
son  verdaderas.   "And"  devuelve el segundo operador si éste es cierto y "Or"
devuelve el primero si éste es cierto.  Por ejemplo:

  a = 5 And 4     ; a = 4
  a = 5 And 0     ; a = 0
  a = 0 And 4     ; a = 0
  b = 5 Or 4      ; b = 5
  b = 5 Or 0      ; b = 5
  b = 0 Or 4      ; b = 4

El  operador  unario  "Not" (NO) negará su operando.  El resultado siempre será
TRUE  (1  => verdadero) o FALSE (0 => falso).  Si se ha utilizado en una cadena
el resultado será TRUE si es una cadena vacía "".  Por ejemplo:

  a = Not TRUE     ; a = 0 (falso)
  a = Not FALSE    ; a = 1 (verdadero)
  a = Not 5        ; a = 0 (verdadero)
  a = Not Not TRUE ; a = 1 (verdadero)
  a = Not "Hola"   ; a = 0 (falso)
  a = Not ""       ; a = 1 (verdadero)

Por  favor,  tenga  en  cuenta  que el operador "Not" tiene una alta prioridad.
Necesitará  utilizar  paréntesis  en  la mayoría de los casos.  Por ejemplo, si
pretende  negar  el resultado de una comparación como la del siguiente ejemplo,
tal como está escrito no funcionará:

  If Not a = -1        ; ¡mal!

Hollywood lo traducirá como:

  If (Not a) = -1

porque  el  operador  "Not",  ¡tiene  una  mayor  prioridad  que el operador de
igualdad  "="!   Pero  obviamente  esta  traducción  no tiene sentido porque el
resultado  de  la expresión en paréntesis siempre será 0 o 1, nunca -1.  Por lo
tanto,  si  usted  quisiera  comprobar  que  "a" no es -1 , deberá utilizar los
paréntesis con la expresión de menor prioridad:

  If Not (a = -1)      ; ¡correcto!

Consulte la sección sobre las @{"prioridades de los operadores" LINK PrgOprPri} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprLogic"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprBitw "Guía de Hollywood: Operadores a nivel de bit *UPD10*"

@{b}Operadores a nivel de bit@{ub}

Hollywood soporta los siguientes operadores a nivel de bit:

    +---------------------------------------------------------------------+
    +                              @{b}BINARIO@{ub}                                +
    +---------------------------------------------------------------------+
    +       @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +          <<       Desplazamiento a la izquierda       a << b        +
    +          >>        Desplazamiento a la derecha        a >> b        +
    +          &           "And" (Y) a nivel de bit         a & b         +
    +          ~      "Xor" (O exclusivo) a nivel de bit    a ~ b         +
    +          |           "Or" (O) a nivel de bit          a | b         +
    +---------------------------------------------------------------------+

    +---------------------------------------------------------------------+
    +                              @{b}UNARIO@{ub}                                 +
    +---------------------------------------------------------------------+
    +         @{b}Operador@{ub}            @{b}Descripción@{ub}               @{b}EJEMPLO@{ub}       +
    +---------------------------------------------------------------------+
    +             ~         Negación a nivel de bit           ~a          +
    +---------------------------------------------------------------------+

Los  operadores  a  nivel  de bit le permiten trabajar con expresiones, como su
propio  nombre  indica,  a  nivel de bit.  Estas operaciones  están limitadas a
valores de 32 bits.  Aquí tiene una descripción de estos operadores:

El  operador  de desplazamiento a la izquierda "<<" desplaza todos los bits del
operando  a la izquierda "b" veces.  Los agujeros a nivel de bit que se generan
en el lado derecho del número creado con esta operación se rellenarán con ceros
(desplazamiento  lógico).   "b"  no  puede  ser negativo.  El desplazamiento un
número  "a"  de "b" veces a la izquierda es igual a multiplicar este número por
"2^b",  pero  naturalmente  el  desplazamiento  en  sí  es  más  rápido  que la
multiplicación.  Ejemplos:

  7 << 1 = %111 << 1 = %1110 = 14 (7 * 2^1 = 14)
  256 << 4 = %100000000 << 4 = %1000000000000 = 4096 (256 * 2^4 = 4096)

El  operador  de  desplazamiento  a la derecha ">>" desplaza todos los bits del
operando a la derecha "b" veces.  Los agujeros a nivel de bit que se generan en
el  lado izquierdo del número creado con esta operación se rellenarán con ceros
(desplazamiento  lógico).   Si  necesita  un desplazamiento aritmético (que los
agujeros  a  nivel  de bit se rellenen con el bit más significativo), por favor
utilice  en  su lugar  la  función  @{"Sar()" LINK Sar}.   "b"  no  puede  ser negativo.  El
desplazamiento  un  número "a" de "b" veces a la izquierda es igual que dividir
este  número por "2^b", pero naturalmente el desplazamiento en sí es más rápido
que  la  división  si  un  resultado entero es suficientemente preciso para sus
propósitos.  Aquí tiene algunos ejemplos:

  65 >> 1 = %1000001 >> 1 = %100000 = 32 (65 \\ 2^1 = 32)
  256 >> 4 = %100000000 >> 4 = %10000 = 16 (256 \\ 2^4= 16)

Los  operadores  a  nivel  de  bit "And", "Xor" y "Or" (Y, O exclusivo y O) son
básicamente  los  mismos  que los operadores lógicos "And", "Xor" y "Or" con la
diferencia  de  que  "&",  "~"  y  "|" tienen como ámbito de trabajo el bit, es
decir, comparan los 32 bits de los operandos "a" y "b" y definen los bits en el
resultado  según esta comparación.  El operador "And" (Y) activará el bit en el
valor  retornado  si  ambos  bits  en los operandos "a" y "b" en dicha posición
están  activados.   El operador "Xor" (O exclusivo) activará el bit en el valor
retornado si uno de los dos está activado, pero NO ambos.  El operador "Or" (O)
activará  el bit en el valor retornado si uno de los dos está activado o ambos.
Aquí tiene un resumen en forma de tabla de la verdad:

          +-------+-------+-------------+-------------+-------------+
          + Bit 1 + Bit 2 + bit1 & bit2 + bit1 ~ bit2 + bit1 | bit2 +
          +-------+-------+-------------+-------------+-------------+
          +   1   +   1   +      1      +      0      +      1      +
          +   1   +   0   +      0      +      1      +      1      +
          +   0   +   1   +      0      +      1      +      1      +
          +   0   +   0   +      0      +      0      +      0      +
          +---------------+-------------+-------------+-------------+

Ejemplos:

  %10011001 & %11101000 = %10001000   ; "And" a nivel de bit
  %10011001 ~ %11101000 = %01110001   ; "Xor" a nivel de bit
  %10011001 | %11101000 = %11111001   ; "Or" a nivel de bit

El  operador  unario de negación "~" realizará una inversión a nivel de bit del
número  sobre el que opere:  Todos sus bits serán invertidos.  Por favor, tenga
en  cuenta  que el valor siempre será convertido a un entero de 32 bits tras la
inversión.   Por ello, podría obtener un buen número de "unos" de relleno.  Por
ejemplo:

  ~%00000000 = %11111111111111111111111111111111
  ~%10111001 = %11111111111111111111111101000110

Para  deshacerse de esos "unos" indeseados, basta con que utilice el operador a
nivel  de  bit  "And" sobre el resultado.  Por ejemplo, si quiere invertir sólo
9 bits  como el ejemplo siguiente, utilice el operador a nivel de bit "And" con
el valor 255:

  ~%00000000 & %11111111 = %11111111
  ~%10111001 & %11111111 = %01000110


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprBitw"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprStrng "Guía de Hollywood: Operadores de cadenas *UPD10*"

@{b}Concatenación de cadenas@{ub}

  +-------------------------------------------------------------------------+
  +                                @{b}BINARIO@{ub}                                  +
  +-------------------------------------------------------------------------+
  +          @{b}Operador@{ub}             @{b}Descripción@{ub}               @{b}Ejemplo@{ub}         +
  +-------------------------------------------------------------------------+
  +             ..               Concatenación               a .. b         +
  +-------------------------------------------------------------------------+

El  operador de concatenación de cadenas puede utilizarse para unir dos cadenas
en una nueva.  Puesto que Hollywood ofrece @{"la conversión automática de números" LINK PrgStrNumConv}
@{"a cadenas" LINK PrgStrNumConv} puede concatenar incluso dos números.  El resultado será siempre una
cadena.  Ejemplos:

  DebugPrint("¡Saludos," .. " amigos!")    ; imprime "¡Saludos, amigos!"
  DebugPrint(5 .. " + " .. 5 .. " = " .. 10)   ; imprime "5 + 5 = 10"

Este  operador  también es útil si quiere repartir una cadena en varias líneas.
Por ejemplo:

  DebugPrint("Mi Programa v1.0\\n" ..
             "(c) por mí 2005\\n" ..
             "¡Presione la tecla INTRO para empezar!")


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprStrng"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprPri "Guía de Hollywood: Prioridades de los operadores *UPD10*"

@{b}Prioridades de los operadores@{ub}

Aquí  tiene  una  lista  completa  de  todos  los  operadores disponibles y sus
prioridades.   No ha de sabérselos de memoria:  cuando tenga dudas, utilice los
paréntesis,  pues  no  causan  problemas aunque sean redundantes, y sin embargo
hacen más legible su programa, puesto que no todo el mundo sabe que el operador
de  desplazamiento a la izquierda tiene más prioridad que el operador O a nivel
de bit.

    +---------------------------------------------------------------------+
    +          Prioridad          Operador          Descripción           +
    +---------------------------------------------------------------------+
    +             12                 ^                Potencia            +
    +             11                 -                Negación            +
    +             11                 ~              Negación (bit)        +
    +             11                 Not              NO lógico           +
    +             10                 *              Multiplicación        +
    +             10                 /              División real         +
    +             10                 \\           División entera          +
    +             10                 %          Resto de la división      +
    +              9                 +                Adición             +
    +              9                 -              Sustracción           +
    +              8                 <<    Desplazamiento a la izquierda  +
    +              8                 >>     Desplazamiento a la derecha   +
    +              7                 &                Y (bit)             +
    +              6                 ~           O exclusivo (bit)        +
    +              5                 |                O (bit)             +
    +              4                 ..            Concatenación          +
    +              3                 =               Igualdad             +
    +              3                 <>             Desigualdad           +
    +              3                 <               Menor que            +
    +              3                 >               Mayor que            +
    +              3                 <=          Menor o igual que        +
    +              3                 >=          Mayor o igual que        +
    +              2                 And             Y lógico             +
    +              1                 Or              O lógico             +
    +---------------------------------------------------------------------+


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprPri"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgOprMM "Guía de Hollywood: Metamétodos *UPD10*"

@{b}Metamétodos@{ub}

Los  metamétodos  permiten  definir  cómo  los  operadores  de Hollywood han de
comportarse  cuando  trabajan  con  tablas,  puesto  que  normalmente no pueden
utilizarse como operandos y así, por ejemplo, esto no es posible:

  tabla_A = {1, 2, 3, 4, 5}
  tabla_B = {5, 4, 3, 2, 1}
  r = tabla_A + tabla_B   ; ¡se genera un error en el compilador!

El  código  del ejemplo intenta sumar la "tabla_A" a la "tabla_B", pero esto no
es  posible  porque  las  tablas  pueden  tener cualquier número de elementos o
incluso  cualquier  tipo de dato (funciones, subtablas, cadenas, etcétera), así
que  no  hay una forma genérica de decirle al operador adición cómo debe lidiar
con  una  tabla...   y aquí es dónde los metamétodos vienen en nuestro auxilio.
Los  metamétodos  permiten  definir  cómo  un operador ha de comportarse cuando
recibe una tabla como operando.  En otras palabras, los metamétodos le permiten
definir  una  función  que  se  ejecutará cuando un operador se utilice con una
tabla como operando, calculando el resultado y a esto lo llamamos metamétodo.

Los metamátodos no tienen ajustes globales:  son privados/específicos para cada
tabla.   Cuando  usted  crea una tabla, ésta no tiene metamétodos asociados, de
manera  que  si  intenta  utilizar  un operador con ella, éste fracasará.  Para
asignar metamétodos a una tabla ha de utilizar el comando @{"SetMetaTable()" LINK SetMetaTable}.  Una
metatabla   es   una   tabla   que   contiene  una  colección  de  metamétodos.
@{"SetMetaTable()" LINK SetMetaTable}  acepta dos tablas como argumento:  El primero es la tabla para
la  que  quiere  establecer  los  metamétodos,  y  el  segundo  argumento es la
metatabla  actual,  es  decir,  la  tabla  que  contiene los metamétodos que le
gustaría definir.

Ahora  echemos  una  ojeada a un ejemplo.  Reescribiremos el código del ejemplo
anterior utilizando metamétodos, de manera que podamos sumar las dos tablas.

  mt = {}  ; crea nuestra metatabla

  Function mt.__add(a, b)
    Local tamA = ListItems(a)   ; nº de elementos en la tabla A
    Local tamB = ListItems(b)   ; nº de elementos en la tabla B
    Local r = {}        ; crea la tabla resultante

    For Local k = 0 To Min(tamA, tamB) - 1
      resultado[k] = a[k] + b[k]             ; suma elementos
    Next

    Return(resultado)   ; devuelve la tabla resultante
  EndFunction

  tabla_A = {1, 2, 3, 4, 5}
  tabla_B = {5, 4, 3, 2, 1}

  SetMetaTable(tabla_A, mt)   ; define "mt" como la metatabla de "tabla_A"
  r = tabla_A + tabla_B

La tabla resultante tendrá cinco elementos que se ajustan a seis.  ¿Pero qué ha
hecho  el código anterior?  Primero hemos creado una tabla vacía que sirve como
nuestra  metatabla.   A  continuación hemos añadido una función llamada "__add"
(con  dos  guiones bajos) a esa tabla:  Esta función será el metamétodo para el
operador adición.  Tenga en cuenta de que hemos que usar el nombre "__add" para
esta función porque Hollywood lo utiliza para detectar el operador afectado por
el  metamétodo;  utilizando "__add" como nombre se define un metamétodo para el
operador  adición  "+".  El código de nuestro metamétodo simplemente calcula la
longitud  de dos tablas, suma los elementos de la tabla y almacena sus sumas en
una  nueva  tabla  que  es  el  resultado  que  devuelve.   Percátese de que la
implementación   de   nuestro  metamétodo  "__add"  anterior  exige  que  ambos
argumentos sean tablas y que las tablas sólo han de contener números (o cadenas
que puedan ser convertidas a números).  Por ejemplo, las siguientes expresiones
no funcionarían utilizando la implementación del metamétodo anterior:

  r = tabla_A + 10      ; --> error porque 10 no es una tabla
  r = tabla_A + "Hola"  ; --> mismo error que el anterior

Naturalmente,   es  posible  escribir  metamétodos  que  puedan  manejar  estas
situaciones.    Basta  con  que  compruebe  los  tipos  de  parámetros  que  se
transfieren a su metamétodo y que proceda a ejecutar las acciones definidas por
usted dependiendo de los tipos de variables especificados.

Por  ahora  sólo  hemos  cubierto  el  metamétodo  del  operador  adición  "+".
Naturalmente,  también  puede  definir  un  metamétodo  para  cada  operador de
Hollywood.   Así  mismo  puede  crear  metamétodos  para  todos  los operadores
relacionales  ("="  "<>"  "<"  ">" "<=" ">="), de manera que puede comparar las
tablas  directamente.  Todo lo que necesita saber es el nombre correcto para el
metamétodo  del  operador  para poder instalarlo.  Aquí tiene la lista de todos
los disponibles y sus correspondientes operadores:

    +---------------------------------------------------------------------+
    +         Metamétodo          Operador          Descripción           +
    +---------------------------------------------------------------------+
    +          __pow                 ^                Potencia            +
    +          __unm                 -                Negación            +
    +          __not                 ~             Negación (bit)         +
    +          __mul                 *             Multiplicación         +
    +          __div                 /              División real         +
    +          __divint              \\             División entera        +
    +          __mod                 %           Resto de la división     +
    +          __add                 +                 Adición            +
    +          __sub                 -               Sustracción          +
    +          __lsh                 <<     Desplazamiento a la izquierda +
    +          __rsh                 >>      Desplazamiento a la derecha  +
    +          __and                 &                 Y (bit)            +
    +          __xor                 ~            O exclusivo (bit)       +
    +          __or                  |                 O (bit)            +
    +          __concat              ..             Concatenación         +
    +          __eq                  =                Igualdad            +
    +          __lt                  <                Menor que           +
    +          __le                  <=           Menor o igual que       +
    +          __index               []       Leer un valor de la tabla   +
    +          __newindex            []=    Escribir un valor en la tabla +
    +          __call                ()          Llamada a una tabla      +
    +---------------------------------------------------------------------+

Como  puede  ver, no hay metamétodos para los operadores ">", ">=" ni "<>".  Es
debido  a  que Hollywood los maneja simplemente reformulando la condición de la
siguiente manera:

                 a <> b       es lo mismo que     Not (a = b)
                 a > b        es lo mismo que     b < a
                 a >= b       es lo mismo que     b <= a

Si quisiera comparar dos tablas, ambas asociadas a metatablas, pero sin invocar
el metamétodo  "__eq" tendrá que utilizar la función @{"RawEqual()" LINK RawEqual}.  Esta función
comparará ambas tablas únicamente por referencia sin invocar ningún metamétodo.

Como  puede  ver  más  atrás  cada  tabla tiene sus propios ajustes privados de
metatabla.  Cuando se utilicen operadores binarios, sin embargo, podría suceder
que  los  dos  operandos  no  utilicen la misma metatabla.  Así que ¿cómo elije
Hollywood la metatabla para el operador?  Esto depende de varias condiciones:

  a) Si  el  operador  es  uno  relacional  ("="  "<>"  "<"  "<=" ">" ">="), el
     metamétodo   únicamente  será  invocado  si  las  dos  tablas  pueden  ser
     comparadas   utilizando   la   misma   metatabla.   Si  tienen  metatablas
     diferentes, la comparación fallará.

  b) Si el operador es uno aritmético, un operador a nivel de bit o el operador
     de  concatenación de cadenas "..", Hollywood estudiará primero el operando
     A.   Si  el  operando A tiene una metatabla, entonces será la que utilice.
     Si  el  operando A no tiene una metatabla, Hollywood estudiará el operando
     B.   Si  éste  tiene  una  metatabla, entonces será la que se utilice.  Si
     ningún operando tiene una metatabla, se generará un mensaje de error.

Ya ha leído más atrás que los metamétodos relacionales sólo se invocarán si los
dos operandos utilizan las mismas metatablas.  Sin embargo, hay otra limitación
cuando  se  utilizan  estos metamétodos relacionales:  sólo se pueden llamar si
los  dos  operandos son tablas.  No es posible comparar una tabla y un número o
comparar  una  cadena con una tabla, etcétera.  Los metamétodos aritméticos y a
nivel  de  bit  pueden  funcionar  con  cualquier tipo de variable, pero los ya
mentados relacionales están limitados a comparar tablas.

Hasta  ahora  sólo  hemos  cubierto los metamátodos relacionales, aritméticos a
nivel  de  bit y de concatenación.  Hay sin embargo, unos cuantos más que puede
utilizar  denominados  "__index",  "__newindex", "__call" y "__tostring".  Aquí
tiene una descripción detallada de estos metamétodos:

  @{b}__index:@{ub}

  Este  metamátodo  es  invocado cuando intente leer un índice que no existe de
  una tabla.  Este metamétodo podría utilizarse para crear un valor por defecto
  para  todos los campos no inicializados de una tabla.  Normalmente, Hollywood
  fracasará  cuando  quiera  leer campos no inicializados.  Este comportamiento
  puede  cambiarse  utilizando  este  metamétodo.   Aquí  tiene un fragmento de
  código que define como valor por defecto el cero:

    mt = {}
    Function mt.__index(t, idx)
      Return(0)
    EndFunction

    t = {x = 10, y = 20}
    SetMetaTable(t, mt)
    NPrint(t.x, t.y, t.z)  ; --> imprime los valores 10 20 0

  Sin nuestra metatabla, la llamada a la función @{"NPrint()" LINK NPrint} fracasará porque "z"
  no  ha  sido  inicializada.  Utilizando la metatabla, sin embargo, "z" valdrá
  automáticamente cero porque ésta aún no existe.

  A  veces  podría ser necesario leer una tabla sin invocar ningún metamétodo y
  puede  hacerlo utilizando  la función @{"RawGet()" LINK RawGet}.  Esta función nunca invocará
  ningún metamétodo, de manera que si un índice no existe le devolverá el valor
  @{"NIL" LINK PrgTypeNil}.

                                      ---

  @{b}__newindex:@{ub}

  Este  metamétodo se invoca cuando intenta escribirse un valor en un índice de
  una  tabla que aún no existe en dicha tabla.  Podría utilizar este metamétodo
  por ejemplo para crear tablas no modificables ("sólo lectura").  El siguiente
  código manejará un error cuando intente escribir en una tabla protegida:

    mt = {}
    Function mt.__newindex(t, idx, val)
      NPrint("Escritura bloqueada", val, "en el índice", idx)
    EndFunction

    t = {x = 10, y = 20}
    SetMetaTable(t, mt)
    t.z = 45    ; --> "Escritura bloqueda del valor 45 en el índice "z""

  Este  código  define  la tabla "t" como protegida contra escritura, de manera
  que no podrá realizar modificaciones en ella.

  A  veces  podría  ser  necesario  escribir  en  una  tabla sin invocar ningún
  metamétodo  y  puede  hacerlo utilizando  la función @{"RawSet()" LINK RawGet}.  Esta función
  nunca  invocará  ningún  metamétodo, de manera que podría incluso escribir en
  tablas protegidas contra escritura con dicha función.

                                      ---

  @{b}__call:@{ub}

  Este metamétodo se invoca cuando se intenta llamar a una tabla.  Normalmente,
  el  intentar llamar a una tabla fracasará porque las tablas son sólo tipos de
  datos  y  no funciones.  Sin embargo, hay casos donde puede ser más manejable
  si  pudiese  referirse  una  tabla  como  si  de  una función se tratase.  El
  siguiente  ejemplo  muestra  un metamétodo que calculará el promedio de todos
  valores de una tabla:

    mt = {}
    Function mt.__call(t)
      Local c = ListItems(t)
      Local sum = 0

      For Local k = 0 To c - 1 Do sum = sum + t[k]

      Return(sum / c)
    EndFunction

    t = {10, 23, 45, 5, 107, 45, 18, 46}
    SetMetaTable(t, mt)
    NPrint(t())   ; --> 37.375

  Este  código devolverá el valor 37.375 que es el promedio de los ocho valores
  almacenados en la tabla "t".

                                      ---

  @{b}__tostring:@{ub}

  Este  metamétodo  se  utiliza  con  comandos  como  @{"Print()" LINK Print} o @{"DebugPrint()" LINK DebugPrint}.
  Normalmente,  cuando  usted traspase  una tabla a @{"Print()" LINK Print} obtendrá  algo así
  como  "Table: 1acd432f"  como  resultado:   Se trata del gestor que Hollywood
  utiliza  internamente  para  referirse  a la tabla y obviamente no le será de
  mucha  utilidad.   Sin  embargo, utilizando el metamétodo "__tostring", puede
  cambiar  este  comportamiento.   Aquí tiene un metamétodo que crea una cadena
  como representación de una tabla:

    mt = {}
    Function mt.__tostring(t)
       Local r$
       For Local k=0 To ListItems(t)-1 Do r$=r$..t[k].." "
       Return(r$)
    EndFunction

    t = {"Juan", "José", "Miguel", "David"}
    SetMetaTable(t, mt)
    NPrint(t)   ; --> Juan José Miguel David

  Este  código  imprimirá  "Juan José Miguel David" porque  nuestro  metamétodo
  "__tostring" simplemente ha concatenado todos los elementos de la tabla.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgOprMM"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgVariables "Guía de Hollywood: Variables y constantes *UPD10*"

@{b}Variables y constantes@{ub}

Una  variable  puede utilizarse para almacenar información bajo un nombre dado.
En Hollywood, las variables no tienen porqué ser declaradas:  Eso significa que
basta  con que asigne un valor a una variable sin tener que definir previamente
su  tipo:   Hollywood  lo  hará  por  usted  automáticamente.   El nombre de la
variable  ha  de  comenzar obligatoriamente por un carácter del alfabeto inglés
(a-z)  o  el  símbolo  guión bajo "_".  Tras el primer carácter, puede utilizar
también  números,  el  símbolo  de  cierre  de  exclamación  "!"  o  del  dólar
estadounidense  "$".   Se  sugiere  que  utilice  únicamente  el símbolo "$" en
variables de tipo cadena.  Puesto que Hollywood es un lenguaje indiferente a la
altura  de  la  caja  del  texto  (o  sea,  no  diferencia  entre  mayúsculas y
minúsculas),  no  hay  diferencias  entre  nombres  de variables como "MIVAR" y
"mivar"  (ambas  aluden  a  la  misma  variable).   Hollywood es un lenguaje de
tipificación   dinámica,  lo  que  significa  que  las  variables  también  son
dinámicas.  Por ejemplo, las siguientes líneas funcionarán sin problemas:

  mivar = 1.5
  mivar = "Hola"
  mivar = {1, 2, 3}
  mivar = Function(s) DebugPrint(s) EndFunction

Resumiendo,  puede cambiar el tipo de una variable sobre la marcha, ¡pero no es
un buen estilo de programación!

Las constantes son valores fijos que están disponibles globalmente para todo el
código  de  su guión.  Llevan como prefijo el símbolo de la almohadilla "#" así
puede distinguirlas de variables y funciones.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgVariables"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgGlobals "Guía de Hollywood: Variables globales *UPD10*"

@{b}Variables globales@{ub}

Si asigna un valor a una variable por primera vez, ésta se convertirá en global
salvo que explícitamente  le diga a Hollywood que ha de ser local utilizando la
declaración @{"Local" link PrgLocal}.  Se puede acceder  a las variables globales desde cualquier
parte  de  su  guión.   Están disponibles globalmente para todas las funciones.
Sin  embargo,  si  hay  una  variable local con el mismo nombre que una global,
Hollywood siempre utilizará primero la local.

Las  variables  globales  son  más  lentas  que  las  locales  y  no pueden ser
procesadas fácilmente  por  @{"el recolector de basura" LINK PrgGarbageCollector} a menos que explícitamente
las defina como @{"NIL" LINK PrgTypeNil} cuando ya no las necesite.  Por ello, debería utilizar las
variables  globales  sólo cuando sea realmente necesario.  En funciones debería
intentar trabajar sólo con variables locales.

Aquí tiene un ejemplo:

  ; ¡código incorrecto!
  Function p_Sumar(a, b)
    temporal = a + b
    Return(temporal)
  EndFunction

La variable "temporal" se creará como una variable global, y eso no tiene mucho
sentido  puesto  que  sólo  se necesita para esta función.  Así que sería mejor
hacerla local para esta función, como por ejemplo:

    ; ¡código correcto!
   Function p_Sumar(a, b)
     Local temporal = a + b
     Return(temporal)
   EndFunction

Para  mejorar  la  legibilidad  de  su  programa, puede utilizar la declaración
@{"Global" LINK PrgGlobal} para marcar  claramente aquellas variables  que  sean globales. Es algo
opcional   naturalmente,   porque  todas  las  variables  que  no  se  declaren
explícitamente como locales, son automáticamente globales.  Pero la utilización
de la declaración @{"Global" LINK PrgGlobal} hace su programa más fácil de leer.

Consulte la sección sobre las @{"variables locales" LINK PrgLocals} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgGlobals"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgGlobal "Guía de Hollywood: Global *UPD10*"

@{b}Declaración @{u}Global@{uu}@{ub}

  Global <var1> [, <var2>, ...] [= <expr1> [, <expr2>, ...]]

Esta  declaración  se  utiliza  para  indicarle  a  Hollywood  que  la variable
especificada  ha  de  ser  global.   Esto, además inicializa su variable.  Esta
declaración sólo se incluye para mejorar la legibilidad de su programa:  Podría
no  utilizarla  y  el  código  funcionaría exactamente igual.  Esta declaración
funciona como la declaración @{"Local" LINK PrgLocal}.

Si  utiliza  la  declaración  "Global",  se  aconseja  que  coloque todas estas
declaraciones  al  inicio  de  su  programa,  de  manera  que cualquiera que lo
consulte verá claramente qué variables globales hay disponibles:  Utilizarla en
otra parte de su código haría su lectura bastante confusa.

Consulte la sección sobre @{"variables globales" LINK PrgGlobals} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgGlobal"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgLocals "Guía de Hollywood: Variables locales *UPD10*"

@{b}Variables locales@{ub}

Debería  utilizar  variables locales siempre que le sea posible.  Su uso mejora
la  gestión  de  la memoria de su programa porque @{"el recolector de basura" LINK PrgGarbageCollector} sabe
automáticamente  cuando  debe  borrarlas.   Además,  el  acceso a las variables
locales  es  mucho  más  rápido  que  a  las globales porque Hollywood no ha de
recorrer  todo  el  entorno global y eso incrementa además la legibilidad de su
programa.

Las variables locales tienen una vida limitada.  Sólo estarán disponibles en el
bloque  en que se han declarado.  Un bloque será habitualmente el cuerpo de una
función,  pero  también  puede  ser  el  cuerpo  de  una estructura de control.
Incluso puede declarar bloques utilizando las sentencias @{"Block" LINK PrgBlock} y @{"EndBlock" LINK PrgBlock}.

Importante  -  Las  variables  locales  han  de desclararse de forma explícita,
porque  si  no  lo  hace así, la variable será global de forma automática.  Por
ejemplo, si escribe:

  Function p_Sumar(a, b)
    temporal = a + b
    Return(temporal)
  EndFunction

La  variable  "temporal"  se  creará  automáticamente como una variable global.
Pero  esto  es  un  desperdicio  de  recursos  porque  sólo se necesita para el
interior de dicha función, así que sería mejor escribir:

  Function p_Sumar(a, b)
    Local temporal = a + b
    Return(temporal)
  EndFunction

Ahora  la  variable  "temporal"  se  declara  explícitamente  como local y será
borrada en cuanto se salga de la función "p_Sumar()".

Como   ya  ha  visto,  las  variables  locales  son  declaradas  utilizando  la
declaración @{"Local" LINK PrgLocal}.   Para declarar una variable local basta con que coloque el
identificador @{"Local" LINK PrgLocal} antes de la variable:

  a = 10        ; variable global
  Local b = 10  ; variable local variable

Si quiere inicializar múltiples variables con una declaración @{"Local" LINK PrgLocal}, basta con
que use comas como haría en una asignación normal:

  /* ¡Variables globales! "a" tiene el valor de 10, "b" el valor de 5 */
  a, b = 10, 5
  /* ¡Variables locales! "x" tiene el valor de 10, "y" el valor de 5 */
  Local x, y = 10, 5

Una vez que haya declarado una variable local, ya no necesitará utilizar más la
declaración @{"Local" LINK PrgLocal} para dicha variable:

  ; si "x > 10", multiplícalo por 2, sino divídelo por 2

  If x > 10
    Local temporal = x       ; declara local la variable "temporal"
    temporal = temporal * 2  ; multiplica la variable local "temporal" por 2

    /* asigna el valor de la variable local "temporal" a "x" */
    x = temporal

  Else

    Local temporal = x       ; declara local la variable "temporal"
    temporal = temporal / 2  ; divide la variable local "temporal" por 2

    /* asigna el valor de la variable local "temporal" a "x" */
    x = temporal

  EndIf

  Print(temporal)            ; imprimirá el valor 0 porque...
                             ; "temporal" se ha destruído (local)

El  código  anterior  crea la variable local "temporal" para las dos partes del
bloque  @{"If-Else-Endif" LINK PrgIf}.    Tras   eso,  se  multiplica  o  divide  por  2.   El
identificador @{"Local" LINK PrgLocal}  ya no se exige dentro de dicho bloque porque Hollywood ya
sabe  en  este  punto  que  "temporal" es una variable local.  Esta variable se
borrará  al final  del  bloque  así  que ya no estará disponible  para la línea
"Print(temporal)" y su valor al llegar a ésta será @{"NIL" LINK PrgTypeNil}.

Si no asigna un valor a la variable, ésta tendrá el valor @{"NIL" LINK PrgTypeNil}, aunque ésta sea
local por definirla como tal, por ejemplo:

  If TRUE       ; inicio del bloque
    Local x     ; se declara local la variable "x"
    Print(x)    ; se imprime 0 porque "x" es NIL
    x = 5       ; se asigna 5 a la variable local "x"
    Print(x)    ; ahora se imprime el valor 5
  EndIf         ; aquí termina el ámbito de "x"

  Print(x)      ; se imprime 0 porque "x" vuelve a ser NIL (y global)

También  puede  utilizar el nombre de una variable global (o una variable local
de un bloque superior) para una variable local.  O sea,

  a = 50
  Block           ; inicio de un nuevo bloque
    Local a = 40  ; crea la variable local "a" y le asigna 40
    NPrint(a)     ; imprime 40
  EndBlock        ; aquí termina el ámbito de "a" (la variable local)

  NPrint(a)       ; imprime el valor 50 (de la variable global)

Aquí  tiene  un  ejemplo  más  complejo  que  usa varias variables con el mismo
nombre:

  x = 10                  ; variable global "x" (x1 = 10)
  Block                   ; se abre (=inicia) un nuevo bloque
    Local x = x + 1       ; se asigna 11 a la variable local "x" (x2=x1+1)
    Block                 ; se abre un nuevo bloque
      Local x = x + 1     ; se asigna 12 a la variable local "x" (x3=x2+1)
      Block               ; se abre un nuevo bloque
        Local x = x + 1   ; se asigna 13 a la variable local "x" (x4=x3+1)
        NPrint(x)         ; imprime 13 (= x4)
      EndBlock            ; el ámbito de x4 finaliza aquí
      NPrint(x)           ; imprime 12 (= x3)
    EndBlock              ; el ámbito de x3 finaliza aquí
    NPrint(x)             ; imprime 11 (= x2)
  EndBlock                ; el ámbito de x2 finaliza aquí
  NPrint(x)               ; imprime 10 (= x1)

Este  código  podría  parece algo confuso pero tiene todo el sentido del mundo.
En  cada  nuevo  bloque  Hollywood  buscará la variable "x" comenzando desde el
ámbito actual y atravesando todos los bloques superiores.

Debería darse  cuenta  que  no  puede  utilizar variables locales con @{"Gosub()" LINK Gosub},
porque  Hollywood  saltará  fuera del bloque actual cuando encuentre @{"Gosub()" LINK Gosub} y
volverá  más  tarde  con  datos  totalmente diferentes en la pila.  Por ello el
siguiente código no funcionará:

  ; código inválido
  Block

    Local a = 50      ; crea la variable local "a"
    Gosub(SUBRUTINA)  ; salta fuera del bloque actual; "a" se descartará
    Print(a)          ; la variable local "a" ahora...
                      ; ...tiene algún valor aleatorio de la pila
  EndBlock

Esto  no debería  ser  un  problema  porque @{"Gosub()" LINK Gosub} se considera obsoleta y no
debería utilizarla en su código.

También  puede  utilizar funciones locales.  Funcionan casi de la misma forma y
son  preferibles  a las funciones globales aunque lo más probable es que no las
utilice tanto como las variables locales.  Aún así, pueden ser útiles de vez en
cuando.  Consulte la sección sobre @{"las funciones locales" LINK PrgFuncLoc} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgLocals"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgLocal "Guía de Hollywood: Local *UPD10*"

@{b}Declaración @{u}Local@{uu}@{ub}

  Local <var1> [, <var2>, ...] [= <expr1> [, <expr2>, ...]]

Esta  declaración  se  utiliza  para  indicarle  a  Hollywood  que  la variable
especificada  ha  de  ser  local.   Además,  sirve  también para inicializar su
variable, si lo desea.

  Local mivar           ; informa a Hollywood que "mivar" será local
  r = GetType(mivar)    ; devuelve #NIL
  DebugPrint(mivar)     ; imprime cero
  <otro código>
  mivar = 5             ; ¡ahora "mivar" se crea como una variable local!

Este  código anterior simplemente informa a Hollywood que "mivar" será local en
cuanto  se le asigne  un valor.  La declaración "Local mivar"  no  inicializará
la  variable,  de manera  que  será  del  tipo @{"NIL" LINK PrgTypeNil}, o sea,  que aún no existe.
"mivar"  se  creará  cuando  le asigne un valor específico.  Normalmente, si el
valor  inicial  es  diferente  de cero, usted realizará la inicialización en la
propia declaración local, como por ejemplo:

  Local mivar = 5       ; crea una variable local

Puede  crear  e  inicializar  tantas  variables como quiera.  Basta con que las
separe con comas a cada lado del igual, como por ejemplo:

  Local mivar, mivar2, mivar3 = 5, 4, 3

Este código crea nuevas variables locales y asigna el valor de 5 a "mivar", 4 a
"mivar2" y 3 a "mivar3".

Por  favor, percátese que la declaración no tiene porqué colocarse al inicio de
una  función/bloque  como  en el caso de la declaraciones de variables de otros
lenguajes  de  programación.   Puede  colocarlas  dónde  quiera  y  no  es  una
infracción  del estilo de programación utilizarla en medio de una función.  Por
ejemplo, este código es correcto:

  Block
    DebugPrint("Llamando a FuncPrueba()")
    Local r = FuncPrueba()
    DebugPrint("Llamando a FuncPrueba2()")
    Local r2 = FuncPrueba2()
    DebugPrint("Resultados:", r, r2)
  EndBlock

Como puede ver se utiliza la declaración en medio de un nuevo bloque, lo que no
es un problema con Hollywood.

Consulte la sección sobre las @{"variables locales" LINK PrgLocals} para más detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgLocal"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgGarbageCollector "Guía de Hollywood: Recolector de basura *UPD10*"

@{b}Recolector de basura@{ub}

Hollywood  invocará  a  su  recolector  de  basura de vez en cuando mientras se
ejecuta  su  guión.   El  recolector  de  basura  gestiona  todos  los recursos
reservados  por  su guión y libera toda la memoria que ya no es necesaria.  Por
ejemplo:

   Print("¡Hola amigos!")

Tras invocar Hollywood  al comando @{"Print()" LINK Print}, la memoria reservada por la cadena
"¡Hola amigos!" puede liberarse puesto que ya no es necesaria.  Puede ayudar al
recolector de basura  definiendo variables  con el valor @{"NIL" LINK PrgTypeNil}  cuando ya no las
necesite.   Es  especialmente  útil  para largas cadenas o tablas extensas, por
ejemplo,

  a = {}
  For k = 1 To 1000
      a[k] = {e1 = x, e2 = y}
      x = x + 5
      y = y + 5
  Next

Este fragmento de código crea una bonita y amplia tabla que ocupa memoria de su
sistema.   Si ya no necesita la tabla, simplemente basta con que la defina como
@{"NIL" LINK PrgTypeNil}, por ejemplo,

  a = NIL

El recolector de basura liberará toda la memoria ocupada por esta tabla.

Se  sugiere  encarecidamente  que  utilice variables locales siempre que pueda,
porque  así  el recolector de basura podrá liberarlas automáticamente cuando se
abandone  su  ámbito  de uso (por ejemplo al finalizar la función).  Por favor,
lea el capítulo sobre @{"las variables locales" LINK PrgLocals} para más información.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgGarbageCollector"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgConstants "Guía de Hollywood: Constantes *UPD10*"

@{b}Constantes@{ub}

Las  constantes,  como  su  nombre  implica, son valores a los que se aludirá a
través  de un nombre especificado por el usuario, que no pueden ser modificados
tras  ser  inicializados  por  primera  vez.   Los valores que guardan se fijan
durante  la  ejecución  del  guión.   Como  todos  los  elementos del lenguaje,
Hollywood  no  distingue  entre constantes que utilicen caracteres de caja alta
(mayúsculas)  o  baja  (minúsculas), pero debería escribirlos en mayúsculas por
cuestiones  de  estilo.   Las  constantes  también necesitan llevar el carácter
almohadilla  "#"  como  prefijo  para  ser  distinguidas de las variables.  Las
constantes  @{"TRUE" LINK PrgTrueFalse} y @{"FALSE" LINK PrgTrueFalse}  son las únicas excepciones, o sea, que no necesitan
llevar  el prefijo citado porque son parte elemental del lenguaje de guiones de
Hollywood.   Todas las demás constantes son simplemente elementos añadidos para
los comandos y han de llevar el prefijo citado.

Las  constantes  han  de  ser  números  o  cadenas.  También puede declarar sus
propias constantes utilizando la declaración @{"Const" LINK PrgConst}, como por ejemplo:

  Const #MYCONSTANT = 5 * 5

Si  utiliza  esta  declaración,  siempre debería hacerlo al inicio de su guión,
puesto  que  se  trata  de  una  declaración global que no puede ser modificada
durante la ejecución de su guión.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgConstants"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgConst "Guía de Hollywood: Const *UPD10*"

@{b}Declaración @{u}Const@{uu}@{ub}

  Const #<nmb> = <expr>

Esta   declaración   le  permite  declarar  una  nueva  constante.   El  nombre
especificado en "nmb" ha de estar precedido por el símbolo almohadilla "#".  La
expresión  especificada  en  "expr"  ha de ser una expresión constante (¡!), en
otras palabras, aquí NO puede utilizar ninguna variable.  Por ejemplo:

  Const #MYCONSTANT  = (5 * 10) / 2      ; #MYCONSTANT  = 25
  Const #MYCONSTANT2 = #MYCONSTANT * 10  ; #MYCONSTANT2 = 250
  Const #MYCONSTANT3 = b * 5             ; ¡esto no funciona!

El  último ejemplo no funcionará porque se utiliza una variable en la expresión
y  como ya se ha indicado ha de ser una constante.  Por otro lado, la expresión
especificada  en  "expr"  también  puede  ser  una constante de cadena como por
ejemplo:

  Const #PRGVERSTRING = "$VER: MiPrograma 1.0 (13.04.2005)"

Las constantes también pueden declararse utilizando @{"el argumento de la consola" LINK ManualUsage}
@{"-setconstants" LINK ManualUsage}.   Es  especialmente  útil  en  conjunción  con  el comando  del
preprocesador @{"@IF" LINK atIF}.   Consulte  la sección  @{"Argumentos  de la consola" LINK ManualUsage} para los
detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgConst"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgInbuiltCst "Guía de Hollywood: Constantes internas *UPD10*"

@{b}Constantes internas@{ub}

Las  constantes  internas son utilizadas por muchas funciones como descriptores
de una acción especial, sin embargo, su función es diferente de una constante a
otra.   Si una función exige una constante especial como argumento (por ejemplo
@{"SetFontStyle()" LINK SetFontStyle}  acepta  las constantes #BOLD, #ITALIC, #NORMAL y #UNDERLINED),
entonces estas constantes son descritas en la documentación para dicho comando.

Además,  hay  algunas  constantes que pueden ser especificadas cada vez que una
función  de  Hollywood  le pide una coordenada "x" o "y".  Estas constantes son
las  llamadas  constantes  de  posición  y  permiten especificar de forma fácil
algunas posiciones utilizadas de forma frecuente.  Las siguientes constantes de
posición son internas:

  Las siguientes constantes pueden ser utilizadas como coordenada "x":

  #CENTER:

  Especifica el centro de la visualización
  (= (anchura de visualización - anchura del objeto) / 2)

  #LEFT:

  Especifica el borde izquierdo de la visualización
  (= 0)

  #LEFTOUT:

  Especifica el borde izquierdo más externo de la visualización
  (= - anchura del objeto)

  #RIGHT:

  Especifica el borde derecho de la pantalla
  (= anchura de visualización - anchura del objeto)

  #RIGHTOUT:

  Especifica el borde derecho más externo de la visualización
  (= anchura de visualización + anchura del objeto)

  #USELAYERPOSITION:

  Especifica la posición "x" actual de la capa.

  Las siguientes constantes pueden ser utilizadas como coordenada "y":

  #CENTER:

  Especifica el centro de la visualización
  (= (altura de visualización - altura del objeto)/2)

  #TOP:

  Especifica el borde superior de la visualización
  (= 0)

  #TOPOUT:

  Especifica el borde superior más externo de la visualización
  (= - altura del objeto)

  #BOTTOM:

  Especifica el borde inferior de la visualización
  (= altura de visualización - altura del objeto)

  #BOTTOMOUT:

  Especifica el borde inferior más externo de la visualización
  (= altura de visualización + altura del objeto)

  #USELAYERPOSITION:

  Especifica la posición "y" actual de la capa.

Estas  constantes  facilitan  de  forma  apreciable  el  posicionamiento de sus
objetos.   Por  ejemplo,  si desea visualizar la brocha nº 1 en el centro de la
pantalla,  basta  con ejecute  @{"DisplayBrush()" LINK DisplayBrush} con los argumentos  1,  #CENTER,
#CENTER y @{i}voilà!@{ui}

¡Puede  incluso  realizar  un  ajuste fino de las posiciones restando y sumando
valores  de  estas  constantes!  P. ej.  DisplayBrush(1, #CENTER, #CENTER + 25)
visualiza la brocha desplazada 25 píxeles desde el centro de la pantalla.

También  hay  algunas  constantes  que  le  permiten  un fácil acceso a algunos
colores  básicos.   Las  constantes  de  color  siguientes están declaradas por
defecto:   #BLACK  (negro),  #MAROON  (marrón),  #GREEN  (verde), #OLIVE (verde
oliva),  #NAVY  (azul  marino), #PURPLE (púrpura), #TEAL (verde azulado), #GRAY
(gris),   #SILVER   (plateado),   #RED  (rojo),  #LIME  (verde  lima),  #YELLOW
(amarillo), #BLUE (azul), #FUCHSIA (fucsia), #AQUA (agua), #WHITE (blanco).

  Imagen: @{"colors.png" LINK "Guide/colors.iff/MAIN"}.

Finalmente,  Hollywood define algunas constantes específicas de cada plataforma
dependiendo,  según  en la plataforma que se ejecute y según para la plataforma
que se compile. Puede utilizar el comando del preprocesador @{"@IF" LINK atIF} para verificar
estas  constantes  y  elegir  cómo  actuar.   Puede  encontrar estas constantes
específicas en esta documentación, en la sección en la que se habla del comando
del preprocesador @{"@IF" LINK atIF}:  Consúltela para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgInbuiltCst"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgCharacterCst "Guía de Hollywood: Constantes de carácter *UPD10*"

@{b}Constantes de carácter@{ub}

Las constantes de tipo carácter habitualmente se utilizan para obtener el valor
de la posición del código de un carácter de una forma sencilla.  Si encierra un
carácter  entre  comillas  simples  '', Hollywood lo reemplazará junto a dichas
comillas por el valor de la posición de dicho código.  Por ello, las constantes
de carácter son siempre de tipo @{"número" LINK PrgTypeNumber}.

Por ejemplo:

  DebugPrint('A')    ; imprime el valor 65

También puede utilizarlas para almacenar secuencias de escape. Por ejemplo:

  DebugPrint('\\n')  ; imprime el valor 10

Para  más información sobre la forma en que Hollywood soporta las secuencias de
escape, por favor, eche una ojeada a la documentación del tipo @{"cadena" LINK PrgTypeString}.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgCharacterCst"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFlow "Guía de Hollywood: Flujo del programa *UPD10*"

@{b}Sentencias de control del flujo del programa@{ub}

Este  capítulo  describe  todas  las  sentencias ofrecidas por Hollywood que se
utilizan para controlar el flujo del programa.  Es muy importante conocer estas
estructuras  de  control  porque  pueden  hacer  mucho más legible su programa.
Podemos clasificarlas en dos grupos:

1. @{u}Bloques   condicionales@{uu}:   Se  utilizan  para  comprobar  si  una  expresión
   específica es @{"verdadera (no cero)" LINK PrgTrueFalse} o @{"falsa (cero)" LINK PrgTrueFalse}. Es muy importante porque
   su  programa necesita tomar decisiones todo el tiempo.  Los siguientes tipos
   de bloques condicionales están disponibles:

     @{"If-Else-ElseIf-EndIf            " LINK PrgIf}
     @{"Switch-Case-Default-EndSwitch   " LINK PrgSwitch}

2. @{u}Bucles@{uu}:   Se utilizan para repetir ciertas partes de su código.  Imagine que
   quiere  imprimir  los  números  del 1 al 100.  Podría teclear un centenar de
   veces  el comando @{"Print()" LINK Print}, pero también podría utilizar un simple bucle For
   que  llame  a este comando un centenar de veces.  Las siguientes estructuras
   de bucles están disponibles:

     @{"While-Wend                      " LINK PrgWhile}
     @{"For-Next                        " LINK PrgFor}
     @{"Repeat-Until                    " LINK PrgRepeat}


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFlow"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgIf "Guía de Hollywood: If-EndIf *UPD10*"

@{b}Estructura @{u}If-EndIf@{uu}@{ub}

Hay dos versiones de esta estructura: Una larga y otra abreviada.

1) @{b}Versión larga:@{ub}:

  If <exp> <bloque> [ElseIf <exp> <bloque> ...] [Else <bloque>] EndIf

La sentencia "If" comprueba si la expresión dada es @{"verdadera (no cero)" LINK PrgTrueFalse}. Si es
el caso,  los  comandos  siguientes  son ejecutados.  Si es @{"falsa (cero)" LINK PrgTrueFalse}, "If"
salta a la siguiente sentencia "ElseIf" (si lo hay) y comprueba si la expresión
dada  es  cierta.  Esto se repite hasta que se alcanza la sentencia "Else".  Si
ninguna  de las expresiones anteriores ha sido verdadera, el código que sigue a
"Else" se ejecutará.

Las  sentencias  "If"  y  "EndIf"  son  obligatorias,  "ElseIf"  y  "Else"  son
opcionales.   Puede utilizar tantos "ElseIf" como quiera, pero sólo ha de haber
un  único  "Else" dentro de cada comparación "If".  Además, la sentencia "Else"
ha de ser la última condición antes de "EndIf".  Aquí tiene un ejemplo:

  If a > 5                       ; comprueba si "a" es mayor que 5
    DebugPrint("a > 5")
  ElseIf a < 5                   ; comprueba si "a" es menor que 5
    DebugPrint("a < 5")
  Else                           ; sino ha de ser 5
    DebugPrint("a = 5")
  EndIf

También puede utilizar expresiones más complejas como la condición:

  If pais$ = "USA" And edad < 21
    DebugPrint("¡Prohibida la venta de alcohol a menores de 21 en los EEUU!")
  EndIf

2) @{b}Versión abreviada@{ub}:

  If <exp> Then <sentencia> [ElseIf <exp> <sentencia> ...] [Else <sentencia>]

La versión breve de la estructura "If" funciona de la misma forma que la larga,
pero  con la ventaja de que no necesita incluir un "EndIf".  Esta versión tiene
una  restricción:  todas sus partes han de estar expresadas en una única línea.
Otra  restricción  es que sólo una sentencia puede seguir a los identificadores
"Then",  "ElseIf"  y  "Else",  de  manera  que  si  quiere  ejecutar  múltiples
sentencias ha de utilizar la versión larga.

Utilizando  la  versión  abreviada  de la sentencia "If", podríamos escribir el
ejemplo anterior de la forma siguiente:

  If a>5 Then Print("a>5") ElseIf a<5 Print("a<5") Else Print("a=5")

Puede  observar  que  el  resultado  no  es muy legible, así que en el caso del
ejemplo   anterior,  no  se  recomienda  utilizar  la  versión  abreviada.   La
estructura abreviada de "If" encaja mejor cuando sólo tiene una condición, como
por ejemplo

  If a = TRUE Then b = 5

que resulta ser más legible que

  If a = TRUE
     b = 5
  EndIf

Otra  versión  de  la  estructura  "If" es la sentencia llamada "If"-inmediato:
@{"IIf()" LINK IIf}.   Esta versión  se ha implementado como un comando en Hollywood y forma
parte  de la biblioteca del sistema.  Consulte la sección sobre @{"IIf()" LINK IIf} para los
detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgIf"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgWhile "Guía de Hollywood: While-Wend *UPD10*"

@{b}Estructura @{u}While@{uu}-@{u}Wend@{uu}@{ub}

Hay dos versiones: una larga y otra abreviada.

1) @{b}Versión larga@{ub}:

  While <exp> <bloque-a-repetir> Wend

La sentencia "While"  inicia el bucle si es  @{"verdadera (no cero)" LINK PrgTrueFalse}  la expresión
<exp> y se repetirá mientras siga siéndolo.  Si la expresión es  @{"falsa (cero)" LINK PrgTrueFalse},
el  segmento  <bloque-a-repetir>  se  salta  (NO  se  entra  en  el bucle) y la
ejecución continúa a partir de la sentencia "Wend".

  i = 0
  While i < 100
    i = i + 1
  Wend
  DebugPrint(i)   ; imprime 100

El bucle señalado en el ejemplo se repetirá hasta que la expresión "i < 100" se
vuelva  falsa y éste será el caso cuando "i" sea igual o mayor que 100.  Debido
a  que  empezamos con el valor 0 y se añade una unidad a "i" con cada iteración
del bucle, "i" tendrá el valor de 100 cuando se salga del bucle.

Puede echar una ojeada en la documentación a las sentencias @{"Break" LINK PrgBreak} y @{"Continue" LINK PrgContinue}:
Se utilizan para salir del bucle o saltar a su final.

2) @{b}Versión abreviada@{ub}:

  While <exp> Do <sentencia>

La  versión  breve se comporta de forma exactamente igual que la versión larga,
pero  no  ha de añadirse la sentencia "Wend" como finalizador de la estructura.
La  versión abreviada tiene como restricción que el bloque del bucle sólo puede
consistir  en  UNA  sentencia.  Si necesita ejecutar varias en el bucle, tendrá
que  utilizar la versión larga.  El identificador @{"Do" LINK PrgDo} le indica a Hollywood que
quiere utilizar la versión abreviada.

El  ejemplo  anterior  podría  escribirse  de  la siguiente forma utilizando la
versión abreviada:

  While i < 100 Do i = i + 1


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgWhile"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFor "Guía de Hollywood: For-Next *UPD10*"

@{b}Estructura @{u}For@{uu}-@{u}Next@{uu}@{ub}

Hay  tres  versiones  de  la  estructura "For":  una larga, una abreviada y una
genérica.  La versión genérica está también disponible en versiones abreviada y
larga,  así  que actualmente hay cuatro versiones diferentes.  Sin embargo, por
razones  de  claridad  nos ceñiremos en esta documentación a las tres versiones
diferentes.

1) @{b}Versión larga@{ub}:

  For [Local] <v> = <exp1> To <exp2> [Step <exp3>] <bloque-a-repetir> Next

Lo  primero es definir la variable especificada en "v" con la expresión "exp1".
Luego  el  valor  a  incrementar (la variable) a través de la palabra reservada
"Step"  con  el  valor  "exp3":  Este valor es opcional, de manera que si no lo
define el valor por defecto de "exp3" es 1.

Si "exp3" es positivo, la sentencia "For" comprobará si el valor de la variable
"v"  es  menor o igual a "exp2".  Si fuese el caso, se entrará en el bucle y se
repetirá  hasta  que  el  valor  de "v" sea mayor que "exp2".  Al final de cada
ciclo del bucle, "exp3" se sumará al valor de la variable "v".

Si "exp3" es negativo, la sentencia "For" comprobará si el valor de la variable
"v"  es  mayor o igual a "exp2".  Si fuese el caso, se entrará en el bucle y se
repetirá  hasta  que  el  valor  de "v" sea menor que "exp2".  Al final de cada
ciclo del bucle, "exp3" se sumará al valor de la variable "v".

Si  "exp3"  fuese  cero,  el bucle se repetirá de forma indefinida.  Por favor,
tenga  también  en  cuenta que las expresiones especificadas en "exp2" y "exp3"
sólo  se  evalúan  una  vez,  justamente  al principio del bucle.  Así pues, el
límite del bucle y el valor a incrementar son constantes mientras el bucle está
activo y no pueden ser modificados.

Un ejemplo:

  For i = 1 To 100
    DebugPrint(i)
  Next

Este código  imprime los  números  del  1 al 100.  @{"DebugPrint()" LINK DebugPrint}  se ejecuta un
centenar  de  veces.  Cuando se sale del bucle, la variable "i" tendrá el valor
10.   Como  puede observar, no se ha especificado  la palabra reservada "Step",
lo  que  significa  que  se  añadirá  una unidad con cada ciclo o iteración del
bucle.   Si  quisiéramos que el incremento fuese de dos unidades, utilizaríamos
el siguiente código:

  For i = 1 To 100 Step 2
    DebugPrint(i)
  Next

Estas  líneas  de  código imprimirán "1 3 5 7 9...  95 97 99".  La variable "i"
tendrá un valor de 101 cuando se salga del bucle.

Si  quisiéramos  una  cuenta  atrás  desde  100  a 0, utilizaríamos un valor de
incremento negativo como en el siguiente ejemplo:

  For i = 100 To 0 Step -1
    DebugPrint(i)
  Next

Este fragmento  de  código invoca a @{"DebugPrint()" LINK DebugPrint} ciento una veces.  Tras salir
del bucle, la variable "i" tendrá un valor de -1.

Si antecede la variable con la declaración @{"Local" LINK PrgLocal}, se creará una variable local
para  el  bucle.   Esto significa que no podrá accederse a dicha variable desde
fuera del bloque de dicho bucle.  Veamos un ejemplo:

  For Local i = 1 To 50
    DebugPrint(i)     ; imprime 1, 2, 3... 49, 50
  Next
  DebugPrint(i)       ; imprime 0 ("i" sólo está disponible DENTRO del bucle)

La ventaja de los bucles "For" que utilizan una variable local como contador es
que  se  ejecutan más rápidamente que aquellos que utilizan un variable global.
Si  no necesita acceder a la variable utilizada como contador en el bucle fuera
de éste,  debería utilizar siempre el identificador @{"Local" LINK PrgLocal}.  Una ventaja de los
bucles "For" que usan una variable local como contador es que siempren utilizan
el  identificador.   Una  limitación  de  estos  bucles  con  el  identificador
@{"Local" LINK PrgLocal}  es  no se  debe asignar un nuevo valor al valor del contador local.  Si
necesita  salir del  bucle, utilice @{"Break" LINK PrgBreak}:  La modificación de la variable que
actúa  como  contador en el bucle durante la ejecución de éste sólo funciona si
no se ha utilizado  el identificador @{"Local" LINK PrgLocal}.  Puede que quiera echar una ojeada
a la documentación de las sentencias @{"Break" LINK PrgBreak} y @{"Continue" LINK PrgContinue}: Pueden utilizarse para
salir del bucle o saltar al final de éste.

2) @{b}Versión abreviada@{ub}:

  For [Local] <v> = <exp1> To <exp2> [Step <exp3>] Do <sentencia>

La versión  abreviada  se  comporta exactamente como la larga, pero no necesita
utilizar  la  sentencia  "Next".   Esta  versión tiene la restricción de que el
bloque  del  bucle sólo puede tener una sentencia.  Si necesita ejecutar varias
sentencias  dentro  del bloque del bucle, tendrá que utilizar la versión larga.
El  identificador  @{"Do" LINK PrgDo} informa  a  Hollywood  que  quiere  utilizar  la versión
abreviada.

El  primer  ejemplo  señalado líneas atrás, podría reescribirse de la siguiente
forma utilizando la versión abreviada:

  For i = 1 To 100 Do DebugPrint(i)

3) @{b}Versión genérica@{ub}:

  For <v1> [, <v2>, ...] In <exp> [Do <sentencia>] o [<bloque-a-repetir> Next]

La  versión genérica de esta estructura es diferente de las otras dos versiones
puesto  que de hecho llama a una función definida por el usuario para recuperar
los  valores  en cada iteración.  Este hecho convierte esta versión en adecuada
para un amplia variedad de propósitos.  Puede escribir sus propias funciones de
iteración,  pero  en  la  mayoría  de los casos seguramente querrá utilizar las
funciones  de  iteración  integradas  que  son  smunistradas por funciones como
@{"Pairs()" LINK Pairs}, @{"IPairs()" LINK IPairs} o @{"PatternFindStr()" LINK PatternFindStr}.

La expresión especificada "exp" sólo se evalúa una vez y devuelve tres valores:
Una función de iteración, un valor del estado y un valor inicial para "v1".  La
función  de  iteración  y  el  valor  del estado  son valores privados y no son
visibles/accesibles  como  variables  durante el tiempo de ejecución del bucle.
Una  vez  que el bucle en su versión genérica ha recuperado estos tres valores,
comenzará invocando la función de iteracción con el valor del estado y el valor
actual  de "v1" como los dos argumentos.  El bucle se terminará tan pronto como
<v1> tenga el valor @{"NIL" LINK PrgTypeNil}.

La  mayoría de las funciones de iteracción devuelven múltiples valores con cada
iteración.   Este  es  el  porqué puede especificar múltiples variables para la
versión genérica de la estructura "For".  La capacidad de disponer de múltiples
variables  inicializadas  para  los diferentes estados de la iteración hace muy
flexible esta estructura.

Veamos ahora un ejemplo.  Considere la siguiente tabla:

  meses = {"Enero, "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio",
           "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"}

Ahora  somos capaces  de encontrar  el (nº del) índice  de un mes, del 1 al 12,
utilizando  su  nombre  como  una referencia.  Naturalmente, podría explorar la
tabla,  comparar  el nombre del mes con el que buscamos y encontrar el (nº del)
índice  apropiado.   Pero  cuando  lidiamos  con  una gran cantidad de datos, a
menudo  es  más  rápido  crear  una tabla inversa para encontrar la información
deseada.   En  nuestro  caso,  queremos  una tabla que utilice el nombre de los
meses  como  índices,  de  manera  que  'tabla["Enero"]'  devuelva  el valor 1,
'tabla["Febrero"]'  devuelva  el  valor 2 y  así  sucesivamente.  Podemos crear
fácilmente  esta  tabla  inversa  utilizando  un  bucle  "For" que utilice como
función de iteración @{"IPairs()" LINK IPairs}. Esta función devolverá una función de iteración
que  devuelve  dos  valores:   El valor del índice así como el valor clave para
cada  elemento  de  la  tabla  que  se le traspasa.  Podemos usar la función de
iteración para invertir la tabla muy fácilmente:

   invmeses = {}
   For i,v In IPairs(meses)
     invmeses[v] = i + 1
   Next

Alternativamente,  podríamos  usar  también la versión abreviada de la genérica
para  este código, porque sólo hay una sentencia en el bucle.  Si lo hiciéramos
tendría un aspecto como éste:

   invmeses = {}
   For i,v In IPairs(meses) Do invmeses[v] = i + 1

La función  @{"IPairs()" LINK IPairs} sólo se repetirá a través de todos los índices enteros en
una tabla.  Si quiere recorrer todos los campos de una tabla, puede utilizar en
su lugar la función @{"Pairs()" LINK Pairs}.

Otro  comando  que se utiliza a menudo en conjunción con la versión genérica de
"For"  es la función @{"PatternFindStr()" LINK PatternFindStr}.  Devolverá una función de iteración que
puede ser utilizada para procesar una cadena.  Por ejemplo, el siguiente código
se repetirá recorriendo todas las palabras de una cadena:

  s$ = "¡Hola amigos! Esto es una prueba"
  For w$ In PatternFindStr(s, "%a+") Do Print(w$)

Naturalmente,  también  es posible escribir sus propias funciones de iteración.
Esto, sin embargo, puede ser bastante complicado.  Este es el motivo por el que
no  se  explica  aquí.   Por  favor  consulte  la  segunda  edición  del  libro
"Programando  en @{u}Lua@{uu}"¹ de Roberto Ierusalimschy para más información sobre cómo
escribir sus propia funciones de iteración.

                                    --==--

                   ¹ Nota del traductor: El título original
                    es @{i}Programming in @{u}Lua@{uu} (second edition)@{ui}.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFor"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgRepeat "Guía de Hollywood: Repeat-Until y Repeat-Forever *UPD10*"

@{b}Estructuras @{u}Repeat@{uu}-@{u}Until@{uu} y @{u}Repeat@{uu}-@{u}Forever@{uu}@{ub}

Hay dos versiones de la estructura:  una versión condicional y otra sin fin.

1) @{b}Versión condicional@{ub}:

  Repeat <bloque-a-repetir> Until <exp>

La  estructura  condicional "Repeat" repetirá el bloque del bucle hasta que una
determinada  "exp"  se  vuelva  @{"verdadera (no  cero)" LINK PrgTrueFalse}:   En  otras palabras, se
repetirá  mientras  sea  @{"falsa (cero)" LINK PrgTrueFalse}.   Su  funcionamiento  es  justamente el
complementario  al  de  la estructura  @{"While" LINK PrgWhile},  que  repite el bloque del bucle
MIENTRAS la expresión es verdadera.

Aquí tiene un ejemplo:

  i = 1
  Repeat
    i = i + 1
  Until i = 100

Este  fragmento  de código cuenta del 1 al 100.  Cuando se termina el bucle, la
variable "i" tendrá un valor de 100.

También  puede  querer  echar  una  ojeada a la documentación de las sentencias
@{"Break"  LINK  PrgBreak} y @{"Continue" LINK PrgContinue}:   Éstas puede utilizarse para salir de un bucle o saltar al
final de éste.

2) @{b}Versión sin fin@{ub}:

  Repeat <bloque-a-repetir> Forever

La  versión  sin  fin  puede utilizarse para repetir una porción específica del
código  para  siempre;  aún  así,  puede  saltar  fuera del bucle utilizando la
sentencia @{"Break" LINK PrgBreak}.  Esta versión se utiliza mayoritariamente para crear el bucle
principal de un guión que llame a la función @{"WaitEvent()" LINK WaitEvent}, como por ejemplo:

  Repeat
    WaitEvent
  Forever


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgRepeat"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgSwitch "Guía de Hollywood: Switch-Case *UPD10*"

@{b}Estructura @{u}Switch@{uu}-@{u}Case@{uu}@{ub}

  Switch <ex1> Case <ex2>[:] <bloque> [...] [Default[:] <bloque>] EndSwitch

La estructura puede utilizarse para comparar la expresión especificada en "ex1"
con  todas  las  demás  expresiones  especificadas  tras las sentencias "Case".
Puede  utilizar  tantas  sentencias  "Case"  como quiera, pero ha de existir al
menos  una.   Si  la expresión tras un "Case" coincide con "ex1", se ejecuta el
código  que sigue a dicho "Case".  Tras la ejecución, Hollywood continúa con su
programa  tras  la sentencia "EndSwitch".  Si ninguna de las expresiones "Case"
satisface  la  coincidencia  con  "ex1",  el  código que sigue al identificador
"Default" es el que se ejecutará.  Tenga en cuenta que el uso de esta sentencia
"Default"  es  opcional,  de  manera  que  si  no  la  necesita no tiene porqué
utilizarla,  pero  si  la  usa,  siempre  ha  de  ser la última sentencia de su
estructura  "Switch"  (*NO* se permiten sentencias "Case" tras el identificador
"Default").  El símbolo de los dos puntos ":" tras los identificadores "Case" o
"Default" también es opcional.

Por  favor,  tenga en cuenta que la expresión que sigue al identificador "Case"
ha  de  ser  siempre una constante:  Aquí NO puede utilizar variables o valores
devueltos  por  funciones.  Tampoco puede mezclar tipos de variables:  Si "ex1"
es  una  cadena,  todas las demás expresiones han de ser cadenas; así mismo, si
"ex1" es un número, todas las demás expresiones también han de ser números.

Veamos un ejemplo:

  Switch x
  Case 1:
    DebugPrint("x = 1")
  Case 2:
    DebugPrint("x = 2")
  Default:
    DebugPrint("x <> 1 And x <> 2")
  EndSwitch

Estas  líneas  de código comprueban la variable "x" y si su valor es la unidad,
se  ejecuta  el código del primer "Case".  El código del segundo "Case" sólo se
ejecuta  si el valor de "x" fuese 2.  Si no tuviese ninguno de estos valores se
ejecutaría el código de la sección "Default".

Cada  estructura  "Switch"-"Case"  también puede escribirse como una estructura
@{"If" LINK PrgIf} normal.  El ejemplo indicado a continuación muestra cómo se vería el código
anterior:

  If x = 1
    DebugPrint("x = 1")
  ElseIf x = 2
    DebugPrint("x = 2")
  Else
    DebugPrint("x <> 1 And x <> 2")
  EndIf

Los  programadores  que  usan C y Java han de tener en cuenta que la estructura
"Switch" en Hollywood NO soporta una "ejecución en cascada" a partir del bloque
"Case"  que  cumple  la  condición,  o  sea,  que  no  se atravesará  el bloque
saltando/entrando  en el siguiente, sino que ejecutará automáticamente un salto
al  final de la estructura tras ejecutar el código del bloque "Case" que cumple
la condición  (y de ahí que no necesite utilizar @{"Break" LINK PrgBreak} al final de cada bloque
"Case",  pero  sí  puede  utilizarlo  para  salir  de forma anticipada de dicha
estructura).

A  pesar  de ello, es posible forzar manualmente este comportamiento utilizando
la sentencia "FallThrough":  Cuando Hollywood se la encuentre, sí atravesará el
bloque  saltando/entrando  en  el  siguiente  a  éste,  siempre  que  el bloque
siguiente  esté  encabezado  por  una  sentencia  "Case"  o "Default" (sino, se
generará  un  error).   El  bloque  "Default" siempre ha de ser el último de la
estructura  "Switch"  y  no  se  permite utilizar la sentencia "FallThrough" en
dicho bloque, ya que después de él no hay ninguno más.

Aquí tiene un ejemplo:

  Switch msg.action
  Case "OnKeyDown":
      FallThrough
  Case "OnKeyUp":
      DebugPrint("Evento de teclado:", msg.key)
  Default:
      DebugPrint("Otro evento")
  EndSwitch

Estas  líneas de código imprimirán la tecla que se ha presionado en caso de los
mensajes  en  "msg.action"  sean  "OnKeyDown"  o "OnKeyUp":  Si "msg.action" es
"OnKeyDown",  la  sentencia  "FallThrough"  se utiliza para atravesar el bloque
actual, entrando en el bloque siguiente "OnKeyUp".

Otra  opción  es  colocar  la  sentencia  "FallThrough"  directamente  tras  la
expresión  que  está  tras  la  sentencia  "Switch":  En este caso, cada bloque
"Case"  se  atravesará automáticamente para entrar en el siguiente, a menos que
se encuentre una sentencia "Break" prohibiendo este comportamiento.

Aquí tiene un ejemplo:

  Switch msg.action FallThrough
  Case "OnKeyDown":
  Case "OnKeyUp":
      DebugPrint("Evento de teclado:", msg.key)
      Break
  Case "OnMouseDown":
  Case "OnMouseUp":
      DebugPrint("Evento: Botón izquierdo del ratón")
      Break
  Case "OnRightMouseDown":
  Case "OnRightMouseUp":
      DebugPrint("Evento: Botón derecho del ratón")
      Break
  Default:
      DebugPrint("Otro evento")
  EndSwitch

Estas  líneas  de  código  utilizan  "FallThrough" globalmente para utilizar el
mismo  código  para "OnKeyDown" y "OnKeyUp" y para "OnMouseDown" y "OnMouseUp".
Las  sentencias  "Break"  del  ejemplo son necesarias, puesto que de otra forma
Hollywood  recorrería  todo el código (todos los bloques) hasta la última línea
en el bloque "Default"... y no es lo que deseamos.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgSwitch"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgBreak "Guía de Hollywood: Break *UPD10*"

@{b}Sentencia @{u}Break@{uu}@{ub}

  Break [(<nivel>)]

La  sentencia  "Break"  se  utiliza  para salir de un bucle o de una estructura
@{"Switch" LINK PrgSwitch}.  Un ejemplo:

  For k = 1 To 100
    DebugPrint(k)
    If IsKeyDown("ESC") = TRUE Then Break
  Next

El  bucle anterior cuenta de 1 a 100, pero puede abortarse en cualquier momento
presionando  la  tecla  ESC.  Utilizando el argumento opcional <nivel>, también
puede  provocar  la terminación de los bucles más internos/de más nivel.  Si no
especifica  dicho  argumento,  Hollywood asumirá el valor  1  para éste, lo que
significa  que  el  bucle  más  inmediato  será el que se finalice.  Si utiliza
valores  más  altos  para  dicho argumento, Hollywood atravesará los diferentes
niveles de bucles hacia el más externo/de menos nivel.  Un ejemplo:

  For x = 1 To 100
    For y = 1 To 100
      DebugPrint(x, y)
      If IsKeyDown("ESC") Then Break(2)
    Next
  Next

Este  código  utiliza  dos bucles  @{"For" LINK Prgfor} anidados y comprueba en el interior del
segundo  bucle  si se ha presionado la tecla ESC.  Para finalizar AMBOS bucles,
hemos utilizado la sentencia "Break(2)", ya que la sentencia "Break" sólo daría
por  finalizado  el  bucle más interno, para volver a a iniciarse puesto que el
externo aún no habría terminado.

Por  favor,  tenga en cuenta que si especifica el argumento opcional <nivel> es
obligatorio encerrarlo entre paréntesis.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgBreak"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgContinue "Guía de Hollywood: Continue *UPD10*"

@{b}Sentencia @{u}Continue@{uu}@{ub}

  Continue [(<nivel>)]

Esta  sentencia puede utilizarse para saltar al final de una estructura cíclica
o bucle.  Un ejemplo:

  While i < 100
    i = i + 1
    If i > 50 Then Continue
    j = j + 1
  Wend

Estas  líneas  de  código  cuentan, utilizando la variable "i", de 0 a 100.  La
variable  "j"  también es incrementada en cada ciclo, pero sólo mientras "i" es
inferior  o  igual a 50.  Al final del bucle "i" tiene el valor de 100 y "j" el
valor de 50.

Utilizando  el  argumento  opcional  "nivel", también puede saltar al final del
bucle más externo.  Si no especifica este argumento, Hollywood asumirá el valor
de  1, lo que significa que saltará al final del bucle más cercano.  Si utiliza
valores  superiores  para  este  argumento, Hollywood atravesará los diferentes
bucles anidados hacia el más externo.

Por  favor,  tenga en cuenta que si especifica el argumento opcional "nivel" es
obligatorio utilizar paréntesis para encerrar el argumento.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgContinue"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgReturn "Guía de Hollywood: Return *UPD10*"

@{b}Sentencia @{u}Return@{uu}@{ub}

  Return [(<1er valor devuelto>, <2º valor devuelto>, ...)]

Esta  sentencia  se  utiliza para salir de una función definida por el usuario.
El control del programa volverá a la posición del guión desde donde fue llamada
la función.

Opcionalmente, esta sentencia puede devolver tantos valores como quiera a quien
invocó  la  función.   Si  devuelve  valores  desde una función, es obligatorio
colocar esos valores entre paréntesis.  Por ejemplo:

  ; ¡incorrecto!
  Function p_Min(a, b)
    If a < b Then Return a
    Return b
  EndFunction

  ; ¡correcto!
  Function p_Min(a, b)
    If a < b Then Return(a)
    Return(b)
  EndFunction

Consulte la sección sobre @{"funciones" LINK PrgFunctions} para los detalles.

Nota  sobre  compatibilidad:   Esta sentencia también puede utilizarse tras una
etiqueta identificada como tal con la instrucción @{"Label" LINK Label} (el código comprendido
entre la etiqueta y Return puede ejecutarse con @{"Gosub" LINK Gosub}).  Esta prestación  sólo
se  incluye  para ofrecer compatibilidad con los guiones de Hollywood 1.x.  Por
favor, no utilice más esta prestación.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgReturn"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgBlock "Guía de Hollywood: Block-EndBlock *UPD10*"

@{b}Estructura @{u}Block@{uu}-@{u}EndBlock@{uu}@{ub}

  Block <código del bloque> EndBlock

Esta  estructura  simplemente  ejecuta  el  código  que  le  sigue en un ámbito
separado.   Esta  función es de raro uso, así que normalmente no la necesitará.
Aquí tiene un ejemplo:

  For k = 1 To 100
    Block
      Local k
      For k = 1 To 2
        DebugPrint(k)
      Next
    EndBlock   ; la variable local "k" ahora se borrará
  Next

Las  líneas  de  código anterior utilizan dos variables diferentes con el mismo
nombre  "k"  en  dos  bucles anidados.  Esto es únicamente posible porque hemos
puesto  el  bucle  más  interno  en  su  propio bloque y hemos creado una nueva
variable  local "k" en ese bloque.  Esta variable local es sólo accesible desde
DENTRO  de  dicho  bloque.  Tras la sentencia EndBlock la variable local "k" se
borrará y la variable global "k" se volverá a utilizar de nuevo.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgBlock"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgDim "Guía de Hollywood: Dim y DimStr *UPD10*"

@{b}Declaraciones @{u}Dim@{uu} y @{u}DimStr@{uu}@{ub}

  Dim <nombrevar>[<dim1-tamaño>] ([<dim2-tamaño>], ...), ...
  DimStr <nombrevar>[<dim1-tamaño>] ([<dim2-tamaño>], ...), ...

Las  declaraciones  "Dim" y "DimStr" pueden ser utilizadas para crear una tabla
n-dimensional  con el tamaño especificado e inicializar todos sus elementos con
el valor cero 0 (Dim) o cadena vacía "" (DimStr).

Como  ya sabe  por la documentación del tipo de dato @{"tabla" LINK PrgTypeTable}, los campos de ésta
necesitan  ser  inicializados  antes  de  que puedan utilizarse.  Incluso si un
campo  sólo  ha  de  contener  el  valor  nulo  (cero  o  cadena  vacía), ha de
inicializar  dicho  campo con este valor antes de acceder a él.  La declaración
"Dim"  puede  ayudarle  en  esta  tarea:   Creará  la  tabla  especificada  por
"nombrevar" con el tamaño especificado en "dimx-tamaño".  Este último parámetro
ha  de ser un valor constante, NO una variable.  Por favor, tenga en cuenta que
el  "dimx-tamaño"  especifica el tamaño de la tabla y no el último elemento que
ha  de  ser  inicializado.   Así,  si  utiliza 50 como "dimx-tamaño", Hollywood
inicializará  los  campos  de  la  tabla del 0 al 49...  el campo nº 50 no será
inicializado.

Aquí tiene un ejemplo:

  Dim mitabla[100]

Esta declaración se traduce a esta secuencia de código de Hollywood:

  Local mitabla = {}
  For k = 0 To 99 Do mitabla[k] = 0

La   declaración  "Dim"  se  vuelve  realmente  útil  si  quiere  crear  tablas
multidimensionales.   Puede utilizar tantos pares de corchetes como quiera tras
especificar  "nombrevar":  Cada nuevo par de corchetes crea una nueva dimensión
con el tamaño especificado en la tabla.  Por ejemplo:

  Dim vector[10][10][10]

Esta  declaración  crea  una  tabla  vectorial de tres dimensiones e inicializa
todos  los  campos  con  ceros.  La declaración se traduce como sigue, de forma
algo más compleja, a código de Hollywood:

  Local vector = {}
  For i = 0 To 9
    vector[i] = {}
    For j = 0 To 9
      vector[i][j] = {}
      For k = 0 To 9
        vector[i][j][k] = 0
      Next
    Next
  Next

También puede crear e inicializar más de una tabla con esta declaración.  Basta
con  que  añada  una  coma  tras  especificar la última dimensión de la tabla y
repita  el  procedimiento  completo  anterior  tantas  veces  como  desee.  Por
ejemplo:

  Dim tabla1[50], tabla2[50], tabla3[50]

La  declaración  "DimStr"  funciona de manera similar que "Dim" pero inicializa
todos  los  campos  con  la  cadena  vacía  "".  Por favor, tenga en cuenta que
"Dim"/"DimStr"  siempre  crearán  tablas  locales si dichas declaraciones no se
encuentran en el bloque principal de su guión.  Así, que si desea que una tabla
sea global, asegúrese de que dichas sentencias están en dicho bloque.

No  olvide  tampoco  que  "Dim"/"DimStr"  no  limitan  la  tabla  a  un  tamaño
específico:  La tabla puede aún crecer, ¡puesto que Hollywood es un lenguaje de
tipificación  dinámica!   Para  aumentar  el tamaño de una tabla, basta con que
inicialice los campos que necesite y Hollywood la aumentará.  Por ejemplo:

  Dim tabla[50]
  ...
  For k = 50 To 59 Do tabla[k] = 0   ; incrementa la tabla (diez campos más)

Este  fragmento  de  código  crea  una  tabla  con  espacio para 50 campos y la
incrementa  hasta  los  60.   Si  quiere  reducir  una tabla, defina los campos
correspondientes con el valor @{"NIL" LINK PrgTypeNil}.  Por ejemplo:

  Dim tabla[50]
  ...
  For k = 40 To 49 Do tabla[k] = NIL ; reduce la tabla (diez campos menos)

Este  fragmento  de  código  reduce  la  tabla  de  los 50 campos inicializados
originalmente  a  40.   Hollywood es un lenguaje de tipificación dinámica en el
que  las tablas no tienen un tamaño fijo:  Su tamaño puede aumentar o reducirse
según sus necesidades.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgDim"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFunctions "Guía de Hollywood: Generalidades sobre las funciones *UPD10*"

@{b}Generalidades@{ub}

Las  funciones  puede utilizarse para romper su programa en secciones de código
más pequeñas, aumentando la legibilidad y estructura de su código.  Una función
puede  considerarse como un pequeño programa.  Puede utilizar variables locales
a  la  función,  lo  que  significa  que sólo están disponibles dentro de dicha
función   y  por  lo  tanto  no  puede  ser  accedidas  desde  fuera  de  ella.
Naturalmente,  también  puede  acceder  a variables globales desde una función.
Sinónimos del término "función" son "procedimiento", "subrutina" o "sentencia".
Las funciones pueden no devolver nada o un número de valores de cualquier tipo.

Puede declarar  sus propias funciones utilizando los identificadores "Function"
y "EndFunction":

  Function p_Sumar(a, b)
    Return(a + b)
  EndFunction
  c = p_Sumar(5, 2)        ; "c" recibe el valor 7

Debe utilizar siempre  el prefijo "p_" en los nombres de sus propias funciones.
Esto ayuda a distinguirlas de las funciones internas de Hollywood y, permitirá,
en  futuras  versiones  de  Hollywood, evitar hipotéticos conflictos con nuevas
funciones  internas  que  su  puedan incorporar y que pudiesen coincidir con el
mismo  nombre  que  las suyas (conflictos con resultados inesperados).  Así que
debe  utilizar  siempre  este prefijo "p_" en los nombres de sus funciones para
evitar confusiones (el prefijo "p_" alude a "función privada").

Las funciones han de ser declaradas antes de ser llamadas, así que el siguiente
código generará un error:

  c = p_Sumar(5, 2)
  Function p_Sumar(a, b)
    Return(a + b)
  EndFunction

Hollywood  intentará  llamar  a  la  función "p_Sumar()", pero no la encontrará
porque  aún no ha sido declarada.  Las dos variables "a" y "b" serán locales al
ámbito de la función, lo que significa que sólo podrá acceder a ellas dentro de
la función  "p_Sumar()".  Si transfiere  más argumentos  de los esperados, como
por ejemplo,

  c = p_Sumar(5, 2, 4)     ; 'c' recibe el valor '7'

todos  los  argumentos  superfluos  serán descartados.  En este caso, el tercer
argumento  se ignorará.  Si transfiere menos argumentos a la función de los que
espera, como por ejemplo:

  c = p_Sumar(5)           ; 'c' recibe el valor '5', porque '5 + NIL = 5'

entonces Hollywood  transferirá  el valor especial @{"NIL" LINK PrgTypeNil}  a todos los argumentos
faltantes.

Las  funciones  pueden devolver  valores utilizando la sentencia @{"Return()" LINK PrgReturn}.  Es
obligatorio  que  los  valores devueltos estén encerrados entre paréntesis.  Si
necesita  devolver  múltiples valores, basta con que los separe por comas.  Por
ejemplo:

  Function p_AlgunosVal()
    Return(5, 6, 7, 8, 9, 10)
  EndFunction

Cuando  llame  a  funciones que devuelvan múltiples argumentos y no especifique
suficientes  variables para albergar todos los valores devueltos, aquellos para
los que no se hayan especificados variables serán descartados, por ejemplo:

  a, b, c = p_AlgunosVal()

La  línea  anterior  asigna  el  valor 5 a "a", 6 a "b" y 7 a "c".  Los valores
devueltos  8,  9  y  10 serán descartados.  Si especifica más variables que los
valores devueltos, las variables supérfluas obtendrán como valor @{"NIL" LINK PrgTypeNil}:

  a, b, c, d, e, f, g, h = p_AlgunosVal()  ; 'g' y 'h' tienen el valor 'NIL'

La  línea inmediatamente anterior tiene dos variables innecesarias:  "g" y "h".
A  éstas  se les asigna  el valor  @{"NIL" LINK PrgTypeNil}, puesto que la función "p_AlgunosVal()"
devuelve sólo seis valores.

Naturalmente,  también puede definir funciones que no devuelvan valores.  Estas
funciones también se denominan sentencias.  Por ejemplo:

  Function p_EsperarSegs(s)
    Wait(s, #SECONDS)
  EndFunction

Si intenta obtener un valor de retorno de las sentencia, obtendrá el valor @{"NIL" LINK PrgTypeNil}
como se muestra en la siguiente línea:

  a = p_EsperarSegs(5)

La  variable "a" tendrá el valor @{"NIL" LINK PrgTypeNil}, puesto que la función 'p_EsperarSegs' no
devuelve valor alguno.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFunctions"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncVar "Guía de Hollywood: Funciones como variables *UPD10*"

@{b}Las funciones son variables@{ub}

En  Hollywood,  las funciones son simplemente otras variables del tipo función.
Por lo tanto, puede fácilmente asignarlas a otras variables, como por ejemplo:

  mifunc = DisplayBrush         ; Asigna DisplayBrush a "mifunc"
  mifunc(1, #CENTER, #CENTER)   ; Invoca a DisplayBrush(1, #CENTER, #CENTER)

Puede incluso escribir la definición de una función como una asignación:

  p_Sumar = Function(a, b) Return(a + b) EndFunction
  c = p_Sumar(5, 2)   ; La variable "c" recibe el valor 7

La definición de "p_Sumar()" en la primera línea es lo mismo que escribir:

  Function p_Sumar(a, b)
    Return(a + b)
  EndFunction

También  podría  reemplazar  funciones  de Hollywood por  su propio código, por
ejemplo,  si quiere  que  todas las llamadas de @{"Print()" LINK Print} invoquen en realidad a
@{"DebugPrint()" LINK DebugPrint}, el siguiente código realizaría esta tarea:

  Function p_Print(...)
    /* Redirige los argumentos a DebugPrint() */
     DebugPrint(Unpack(arg))
  EndFunction
  Print = p_Print   ; Las llamadas a Print() llamarán ahora a "p_Print()"
  /* Print() es ahora una referencia a "p_Print()" */
  Print("¡Hola amigos!")

O incluso dispone de una solución más simple:

  /* Redirige todas las llamadas de Print() a DebugPrint() */
  Print = DebugPrint
  /* Ahora se llama a DebugPrint() directamente */
  Print("¡Hola amigos!")


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncVar"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncCallback "Guía de Hollywood: Funciones de retrollamada *UPD10*"

@{b}Funciones de retrollamada@{ub}

Multitud  de  comandos  de  Hollywood  le  permiten  especificar  funciones  de
retrollamada.   Éstas son funciones normales de Hollywood, con la diferencia de
que  no  son invocadas por el guión, sino por comandos de Hollywood.  Son parte
integral  de  Hollywood  y  hacen  que  su programa sea mucho más flexible.  El
sistema completo de botones y manejador de eventos de Hollywood depende en gran
medida  de  dichas  funciones  de  retrollamada.   Por  ejemplo,  si el usuario
presiona  su botón, Hollywood ejecutará la función de retrollamada suministrada
para este evento específico.  Las funciones de retrollamada reciben simplemente
como argumentos normales los comandos correspondientes de Hollywood.

Un ejemplo  de un comando de Hollywood que usa estas funciones es @{"MakeButton()" LINK MakeButton}
Este  comando espera un tabla, como séptimo parámetro, que define las funciones
de retrollamada para los diferentes eventos que se puedan producir, que para el
caso  de  un botón son "OnMouseOver", "OnMouseOut", "OnMouseDown", "OnMouseUp",
"OnRightMouseDown" y "OnRightMouseUp".  Si simplemente quiere una reacción a la
pulsación de un botón, utilice el evento "OnMouseUp".  Este evento se producirá
cuando  el usuario libere el botón izquierdo del ratón, mientras el puntero del
ratón se encuentre sobre un botón.  Aquí tiene un ejemplo:

  MakeButton(1, #SIMPLEBUTTON, 0, 0, 100, 100, {OnMouseUp = p_MiFnc})

Este  comando  crea un nuevo botón con el identificador nº 1 y define que ha de
invocarse  a  la función "p_MiFnc()" cuando el usuario presione este botón.  En
este  caso,  "p_MiFnc()"  es una función de retrollamada.  No será invocada por
usted,  sino  por  Hollywood  cuando el usuario presione el botón.  Funciona de
forma  automática.  Más exactamente, las funciones de retrollamada son llamadas
actualmente  por el comando de Hollywood  @{"WaitEvent()" LINK WaitEvent}, que debería utilizar en
todos  los guiones.  La función de retrollamada en sí misma podría ser algo así
como:

  Function p_MiFnc()
    DebugPrint("¡Presionado el botón nº 1!")
  EndFunction

También podría incrustar esta función directamente en la lista de argumentos de
@{"MakeButton()" LINK MakeButton}.  Tendría un aspecto como éste:

  MakeButton(1, #SIMPLEBUTTON, 0, 0, 100, 100, {OnMouseUp =
      Function() DebugPrint("¡Presionado el botón nº 1!") EndFunction})

Como ve,  Hollywood es muy flexible.  Recuerde que  si declara funciones dentro
de  la  lista  de argumentos de una llamada, no ha de suministrar ningún nombre
para  dicha  función porque son funciones anónimas.  Por ello este fragmento de
código no sería válido:

  ; ¡código no válido!
  MakeButton(1, #SIMPLEBUTTON, 0, 0, 100, 100, {OnMouseUp =
      Function p_MiFnc() DebugPrint("¡Presionado el botón nº 1!") EndFunction})

Las  funciones de retrollamada habitualmente recibe una tabla de mensajes en el
primer  parámetro.   En el ejemplo indicado líneas atrás, no hemos buscado este
mensaje  porque hemos declarado la función sin argumentos.  Para dicho ejemplo,
está bien, pero imagine el siguiente ejemplo:

  MakeButton(1, #SIMPLEBUTTON, 0, 0, 100, 100, {OnMouseUp = p_MiFnc})
  MakeButton(2, #SIMPLEBUTTON, 200, 0, 100, 100, {OnMouseUp = p_MiFnc})

Ahora  hemos declarado dos botones, pero ambos llaman a la misma función cuando
el usuario los presiona.  La función "p_MiFnc()" ahora necesita saber qué botón
es  el  presionado  cuando  es  invocada.   "p_MiFnc()"  puede  averiguar  esta
información echando una ojeada al mensaje que recibe como primer argumento:

  Function p_MiFnc(msj)
    If msj.id = 1
       DebugPrint("¡Presionado el botón nº 1!")
     ElseIf msj.id = 2
       DebugPrint("¡Presionado el botón nº 2!")
     EndIf
  EndFunction

Como  ve, "p_MiFnc()" comprueba el campo del identificador del mensaje recibido
como  primer,  y  en este caso único, argumento y así puede distinguir entre el
botón nº 1 y el nº 2.  Naturalmente, podría extenderlo para cualquier número de
botones.  Pero hay más.  Considere la siguiente situación:

  tablaevt = {OnMouseUp = p_MiFnc, OnRightMouseUp = p_MiFnc}
  MakeButton(1, #SIMPLEBUTTON, 0, 0, 100, 100, tablaevt)
  MakeButton(2, #SIMPLEBUTTON, 200, 0, 100, 100, tablaevt)
  MakeButton(3, #SIMPLEBUTTON, 400, 0, 100, 100, tablaevt)

Ahora  hemos  declarado  tres  botones y todos ellos utilizan la misma tabla de
eventos.   Por ello,  Hollywood  invocará a la misma función  para todos ellos.
Además,  estos  botones  reaccionan a otro evento, denominado "OnRightMouseUp".
Ahora,  "p_MiFnc()"  necesita  ser capaz de distinguir, no sólo entre múltiples
botones,  sino  que  además  entre  eventos  diferentes.  Pero no existe ningún
problema  después  de  todo,  porque el mensaje transferido a "p_MiFnc()" tiene
otro  campo  que puede leer el usuario y que incluye el evento que ha provocado
la  llamada a la función.  Nuestra función "p_MiFnc()" ahora tendría un aspecto
como éste:

  Function p_MiFnc(msj)
    Switch msj.action
    Case "OnMouseUp":
      DebugPrint("Presionado el botón izquierdo: ", msj.id)
    Case "OnRightMouseUp":
      DebugPrint("Presionado el botón derecho: ", msj.id)
    EndSwitch
  EndFunction

O sea, que como ve no hay problema para manejar múltiples botones o eventos con
la  misma función de retrollamada.  ¡Esto aumenta sobremanera la legibilidad de
su programa!  Hay mucho más que descubrir, así que asegúrese también de leer la
documentación sobre @{"MakeButton()" LINK MakeButton}.

Si  desea  ser  notificado  cuando  el usuario cierra o mueve la ventana, puede
instalar  una función  de retrollamada  utilizando  @{"InstallEventHandler()" LINK InstallEventHandler}.  La
función  que  transfiere  al comando de Hollywood será invocada cada vez que el
usuario   presione   el   botón   de   cierre   o   mueva   la  ventana.   Pero
@{"InstallEventHandler()" LINK InstallEventHandler} soporta más tipos de eventos: También puede instalar una
función  de retrollamada que se invoque si el usuario pulsa o libera una tecla,
etcétera.

El comando  de  Hollywood  @{"SetInterval()" LINK SetInterval}  también  utiliza  las  funciones  de
retrollamada.   La función  tranferida a  @{"SetInterval()" LINK SetInterval} se invocará una y otra
vez  transcurrido  el  intervalo especificado.  Es útil si quiere asegurarse de
que  su  guión  se  ejecuta  a  la misma velocidad en todos los sistemas.  Para
conseguir esto, basta con que use @{"SetInterval()" LINK SetInterval} para indicarle a Hollywood que
debe  ejecutar su función de retrollamada  25 veces por segundo.  De esta forma
se  asegura  de que no se ejecute más rápido en máquinas potentes.  Consulte la
documentación de  @{"SetInterval()" LINK SetInterval}  para  tener  una  buena  visión del uso de la
técnica del intervalo.

@{"SetTimeout()" LINK SetTimeout} es otro ejemplo similar: También se transfiere una función además
de  un  valor  de  tiempo  de espera.  Su función de retrollamada será invocada
exactamente  tras  haber transcurrido el tiempo especificado.  Es muy útil para
corregir   la   temporización   de  su  guión,  por  ejemplo,  cuando  pretende
sincronizarlo con música.

Por último,  pero  no  menos  importante,  el comando de Hollywood  @{"CopyFile()" LINK CopyFile}
acepta una  función  como cuarto parámetro.  Esta función se invocará de vez en
cuando  mientras  la  función  copie  ficheros.   Hay  una  diferencia  con las
funciones   de retrollamada  de  @{"MakeButton()" LINK MakeButton},  @{"SetInterval()" LINK SetInterval},  @{"SetTimeout()" LINK SetTimeout},
etcétera:   Éstas  son siempre  llamadas  por  @{"WaitEvent()" LINK WaitEvent}  y no por el propio
comando de Hollywood. @{"CopyFile()" LINK CopyFile}, sin embargo, llamará la función especificada
mientras  se  ejecute.   Así  que  podría  borrar  dicha  función tras terminar
@{"CopyFile()" LINK CopyFile}  de hacer  su trabajo (puede borrar la función definiendo ésta como
@{"NIL" LINK PrgTypeNil}).  No es posible hacer esto con @{"MakeButton()" LINK MakeButton} o @{"SetInterval()" LINK SetInterval} porque estas
funciones instalan las retrollamadas, pero no las invocan por sí mismas, puesto
que esta tarea se deja a @{"WaitEvent()" LINK WaitEvent}. La función de retrollamada de @{"CopyFile()" LINK CopyFile}
es  habitualmente  utilizada para actualizar la barra de evolución o abortar la
operación  de copiado  en  cualquier  momento.   Consulte  @{"CopyFile()" LINK CopyFile} para más
detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncCallback"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncRetVals "Guía de Hollywood: Valores devueltos por las funciones *UPD10*"

@{b}Valores devueltos@{ub}

Si  su  función  devuelve uno o más valores, se exige especificar estos valores
entre paréntesis.  La exigencia es debido a que de otra forma el procesador del
lenguaje podría tratarlos como instrucciones separadas.  Considere el siguiente
código:

  ; ¡código erróneo!
  Function p_Max(a, b)
    If a > b Then Return a
    Return b
  EndFunction

El  procesador  de  Hollywood  podría  interpretar  este código de la siguiente
forma:

  Function p_Max(a, b)
    If a > b Then Return   ; ¡¡ si 'a > b', no se devuelve valor !!
    a                      ; ¡¡ ejecutar la función "a()" !!
    Return                 ; ¡¡ no se devuelve valor !!
    b                      ; ¡¡ ejecutar la función "b()" !!
  EndFunction

Como  puede  ver  esto no tiene mucho sentido.  Los paréntesis son obligatorios
porque  esto  permite  a Hollywood teclear cuantos comandos quiera en una única
línea  sin  utilizar  ningún  delimitador.   Y  Hollywood  le  permite llamar a
funciones  que no acepten argumentos sin especificar los paréntesis, por lo que
una  sentencia  como  "Return  a"  es  convertida a dos sentencias, denominadas
@{"Return" LINK Return}  y  "a()".   Si  quiere devolver  la  variable  "a" ha de reescribir la
sentencia  anterior  como  "Return(a)".  La versión correcta de nuestra función
"p_Max()" tiene este aspecto:

  Function p_Max(a, b)
    If a > b Then Return(a)
    Return(b)
  EndFunction

Utilizando  los  paréntesis  le  indica a Hollywood que las variables "a" y "b"
pertenecen a la llamada a @{"Return()" LINK Return} y no son funciones separadas.

Si  una función devuelve más de un valor, pero quiere disponer sólo del primero
devuelto,  ha  de colocar  un par de paréntesis en torno a la función invocada.
Esto  obligará  a  que  el  resultado  de  la  función sea un único valor.  Por
ejemplo, la siguiente función devuelve tres valores:

  Function p_TresVals()
    Return(1, 2, 3)
  EndFunction

Si  transfiere  el resultado de esta función ahora a otra función que acepte un
número  múltiple de argumentos como por ejemplo @{"DebugPrint()" LINK DebugPrint}, los tres valores
serán transferidos a @{"DebugPrint()" LINK DebugPrint}:

  DebugPrint(p_TresVals()) ; imprime 1 2 3

Si  desea  que @{"DebugPrint()" LINK DebugPrint} reciba sólo el primer valor devuelto de la función
"p_TresVals()" tendrá que encerrar la función entre paréntesis de esta forma:

  DebugPrint((p_TresVals()))  ; imprime 1

Las  funciones  no  sólo pueden devolver números...  también devuelven cadenas,
tablas  e  incluso  otras  funciones.   Por  ejemplo,  el  código  siguiente es
completamente legal:

  Function p_Devuelve_una_tabla()
    Return({1, 2, 3, 4, 5})
  EndFunction
  a = p_Devuelve_una_tabla()
  DebugPrint(a[3])         ; imprime '4'

En  la  práctica,  probablemente  no utilizará  esta prestación demasiado, pero
debería  saber  al  menos que es posible tener funciones que devuelven tablas u
otras funciones.  Otro ejemplo:

  Function p_Devuelve_Func()
    Return(Function(s) DebugPrint(s) EndFunction)
  EndFunction
  mifunc = p_Devuelve_Func()
  mifunc("¡Hola amigos!")   ; invoca 'DebugPrint("¡Hola amigos!")'


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncRetVals"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncRec "Guía de Hollywood: Funciones recursivas *UPD10*"

@{b}Funciones recursivas@{ub}

Hollywood  soporta funciones recursivas, es decir, puede escribir funciones que
se  llamen  a  sí  mismas.   Por ejemplo, aquí tiene una función que calcula el
factorial de "n":

  Function p_Fac(n)
    If n = 0 Then Return(1)   ; 0! = 1
    Return(n * p_Fac(n - 1))  ; multiplica "n" por "n - 1" hasta que "n = 0"
  EndFunction

Como  puede  ver,  la función definida se llama a sí misma una y otra vez hasta
que el contador de "n" es cero:  Eso es una función recursiva.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncRec"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncVarArgs "Guía de Hollywood: Número variable de argumentos *UPD10*"

@{b}Número variable de argumentos@{ub}

También  puede  escribir funciones que acepten un número indeterminado a priori
de  argumentos.   Para ello ha de hacer uso del identificador "..." como último
parámetro.  Su función dispondrá de una tabla local llamada "argc" que contiene
todos   los  parámetros  transferidos  a  su  función  incluyendo  un  elemento
denominado  "n" que contiene el número de parámetros transferidos a la función.
Por  favor, tenga en cuenta que los argumentos se almacenarán en la tabla "arg"
comenzado  por el número de índice 0.  Aquí tiene, por ejemplo, una función que
calcula el promedio (=media aritmética) de todos los parámetros traspasados:

 Function p_Promedio(...)

    Local pars = arg.n              ; cantidad de parámetros traspasados
    Local avg, k                    ; variables temporales

    For k = 1 To pars
      avg = avg + arg[k-1]          ; suma todos los parámetros
    Next

    Return(avg / pars)              ; y divide la suma por su cantidad

  EndFunction

  a = p_Promedio(10, 20, 30, 40, 50) ; (10 + 20 + 30 + 40 + 50) / 5 = 30
  b = p_Promedio(34, 16, 27, 39)     ; (34 + 16 + 27 + 39) / 4 = 29
  c = p_Promedio(10, 10)             ; (10 + 10) / 2 = 10
  Print(a, b, c)                     ; imprime '30 29 10'

Es  importante  hacer  notar  que el identificador "..." ha de ser especificado
como  la  última entrada de su lista de parámetros.  En otras palabras no puede
escribir cosas como:

  ; código inválido
  Function p_Prueba(a, b, ..., c)
    ...
  EndFunction

Esto  obviamente  no  funcionará  porque  Hollywood  no  podría saber nunca qué
parámetro pertenece a "c".  Utilizando parámetros antes del identificador "..."
sin embargo, funciona bien aunque:

  Function p_MinMax(ismin, ...)

    Local pars = arg.n      ; número de parámetros transferidos
    Local k

    If ismin = TRUE         ; ¿buscar el elemento más pequeño?
      Local min = arg[0]    ; aquí se almacena el elemento más pequeño
      For k = 2 To pars     ; bucle que recorre todos los elementos
         If arg[k-1] < min Then min = arg[k-1] ; ¿el más pequeño?
      Next
      Return(min)           ; y devuelve el más pequeño
    Else
      Local max = arg[0]    ; aquí se almacena el elemento más grande
      For k = 2 To pars     ; bucle que recorre todos los elementos
        If arg[k-1] > max Then max = arg[k-1]  ; ¿el más grande?
      Next
      Return(max)           ; y devuelve el elemento más grande
    EndIf

  EndFunction

  a = p_MinMax(TRUE, 4, 8, 2, 3, 10, 1, 7, 9, 5, 6)   ; devuelve '1'
  b = p_MinMax(FALSE, 4, 8, 2, 3, 10, 1, 7, 9, 5, 6)  ; devuelve '10'

Esta  función devolverá el valor más bajo de los parámetros especificados si el
primer  argumento  es  TRUE,  o  el  valor mayor  si  el  primer  argumento es
FALSE.

Si necesita traspasar todos los argumentos a otra función, la función @{"Unpack()" LINK Unpack}
le será útil, pues le devolverá todos los elementos de una tabla.  Por ejemplo,
si quiere escribir su propia función @{"Print()" LINK Print}:

  Function p_Print(...)
    Print(Unpack(arg))
  EndFunction

Todos  los argumentos  traspasados  a  "p_Print()"  se  traspasarán  a @{"Print()" LINK Print}
utilizando la función @{"Unpack()" LINK Unpack}.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncVarArgs"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncTable "Guía de Hollywood: Funciones como miembros de tablas *UPD10*"

@{b}Funciones como miembros de tablas@{ub}

Como  ya  hemos  aprendido  antes,  las  funciones de Hollywood son simplemente
variables  con el tipo "función".  Por lo tanto, puede utilizarlas en cualquier
sitio  que  pueda  utilizar  variables...   y  eso  incluye  las tablas.  Puede
almacenar  funciones  como  cadenas  normales  o  valores dentro de una tabla y
llamarlas desde allí.  Veamos un ejemplo:

  matelib = {}  ; crea una tabla vacía

  Function matelib.add(a, b)
    Return(a + b)
  EndFunction

  Function matelib.sub(a, b)
     Return(a - b)
  EndFunction

  Function matelib.mul(a, b)
     Return(a * b)
  EndFunction

  Function matelib.div(a, b)
     Return(a / b)
  EndFunction

  a = matelib.mul(5, 10)  ; "a" recibe el valor '50'

La  tabla  "matelib"  ahora  contiene  cuatro funciones que pueden ser llamadas
desde  ésta.   Naturalmente,  podríamos  declarar  también funciones durante la
inicialización de la tabla.  Esto sería algo así:

   matelib = {add = Function(a, b) Return(a + b) EndFunction,
              sub = Function(a, b) Return(a - b) EndFunction,
              mul = Function(a, b) Return(a * b) EndFunction,
              div = Function(a, b) Return(a / b) EndFunction}
   a = matelib.mul(5, 10)  ; "a" recibe el valor '50'

Este código hace lo mismo que el código previo, pero de forma más compacta. Las
funciones  dentro de una tabla son a menudo referenciadas como "métodos".  Este
término procede del mundo de la programación orientada a objetos.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncTable"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncLoc "Guía de Hollywood: Funciones locales *UPD10*"

@{b}Funciones locales@{ub}

Debido  a  que  las  funciones  en  Hollywood  son  simples  variables del tipo
"función",  usted  puede  usar  funciones  locales que tienen una vida temporal
limitada.   Funciones  de  manera muy similar a las variables locales y también
tienen las mismas ventajas.  Aquí tiene un ejemplo de una función local:

  Block
    Local p_Sumar = Function(a, b) Return(a + b) EndFunction
    Print(p_Sumar(5, 6))    ; imprime 11
  EndBlock

En  este  código, la función "p_Sumar()" será local dentro del bloque en que ha
sido  declarada.   Así  que  cualquier  intento de llamar a "p_Sumar()" tras la
sentencia @{"EndBlock" LINK PrgBlock} generará un error.

También  podría  utilizar la forma más habitual de definir funciones para crear
funciones  locales.   Este código que sigue a continuación hace lo mismo que el
anterior pero utiliza la forma más común de declarar funciones:

  Block
    Local Function p_Sumar(a, b) Return(a + b) EndFunction
    Print(p_Sumar(5, 6))     ; imprime 11
  EndBlock

El   uso  de  funciones  locales  puede  ser  muy  útil  si  quiere  reemplazar
temporalmente  una  función  de  Hollywood.   Por  ejemplo, el siguiente código
reemplaza  temporalmente  la  función @{"DebugPrint()" LINK DebugPrint}  con  la  función  @{"Print()" LINK Print},
temporalidad  limitada  por  el  bloque  donde  ha sido definida (y los bloques
subordinados):

  If error = TRUE
    Local Function DebugPrint(...) Print(Unpack(arg)) EndFunction
    DebugPrint("¡Se ha producido un error!")    ; redirigida a "Print()"
  EndIf
  DebugPrint("¡Hola!")    ; apunta a "DebugPrint()" otra vez

La cadena "¡Se ha producido un error!" será generada en su visualización con el
código anterior  porque  hemos definido una función local llamada @{"DebugPrint()" LINK DebugPrint}
que  llama a la función @{"Print()" LINK Print} de Hollywood.  Esta función @{"DebugPrint()" LINK DebugPrint} local
será  destruida  en  cuanto  se  abandone  el  bloque.   La siguiente llamada a
@{"DebugPrint()" LINK DebugPrint} invocará a la función @{"DebugPrint()" LINK DebugPrint} real de Hollywood.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncLoc"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgFuncMethods "Guía de Hollywood: Métodos *UPD10*"

@{b}Métodos@{ub}

También es posible utilizar Hollywood para la programación orientada a objetos:
Hollywood  no  dispone  del  concepto  de  clase,  pero  el  comportamiento  es
fácilmente emulable utilizando tablas y metatablas.

Algo  que  es  importante  para  la  programación  orientada  a  objetos es que
habitualmente  las  funciones  del  objeto  reciben  un gestor de sí mismo como
primer  argumento.   Este  argumento  es habitualmente denominado "self" (yo) o
"this"  (esto).   Naturalmente  puede  emular  este  comportamiento  declarando
simplemente  un parámetro "self" o "this" en su función y traspasando a éste el
objeto  cuando  llama  a  la  función, pero también puede utilizar una sintaxis
especial  para  la  programación  orientada a objetos que Hollywood ofrece:  Si
declara  sus  funciones  utilizando  el  operador  ":",  Hollywood inicializará
automáticamente  un  argumento  oculto  "self"  para  usted  y  no  tendrá  que
declararlo  explícitamente.   Si utiliza la sintaxis de los dos puntos, siempre
estará  ahí.   Las  funciones  que  son  declaradas utilizando esta sintaxis se
llaman métodos porque son dependientes de un objeto raíz.

Aquí tiene un ejemplo simple de métodos en Hollywood:

  cont = {items = {}, numitems = 0}

  Function cont:AddItem(n$, p)
    self.items[self.numitems] = {nombre = n$, precio = p}
    self.numitems = self.numitems + 1
  EndFunction

  Function cont:RemoveItem(n$)
    For Local k = 0 To self.numitems - 1
      If self.items[k].nombre = n$
        RemoveItem(self.items, k)
        self.numitems = self.numitems - 1
        Return
      EndIf
    Next
  EndFunction

  Function cont:CheckOut()
    Local total = 0

    For Local k = 0 To self.numitems - 1
      NPrint(self.items[k].nombre, self.items[k].precio)
      total = total + self.items[k].precio
    Next

    NPrint("Su total es", total)
  EndFunction

  cont:AddItem("DVD", 10)
  cont:AddItem("Blizzard PPC", 1000)
  cont:AddItem("Integrados AAA", 100000)
  cont:AddItem("68070", 500)
  cont:CheckOut()
  cont:RemoveItem("Blizzard PPC")
  cont:CheckOut()

Este  ejemplo  crea  una  clase  simple que representa un contenedor.  La clase
tiene   tres   métodos:   Añadir  un  ítem,  borrar  un  ítem  y  realizar  una
verificación.  Además, tiene dos propiedades:  Una tabla que contiene una lista
de  todos  los elementos en el contenedor, y un contador numérico que guarda el
número  de  elementos  disponibles actualmente en el contenedor.  Puede ver que
cada  uno  de  los tres métodos funciona con una variable "self" que no ha sido
declarada.   Esto  es  debido  a  que  todos  los  métodos  han sido declarados
utilizando  el  operador  ":"  y  por lo tanto, Hollywood siempre traspasará un
parámetro  "self" de forma automática.  Naturalmente, hay mucho más, mucho más,
sobre  la  programación  orientada  a  objetos  que  lo  cubierto en esta breve
exposición.   Profundizar  en  la  programación  orientada a objetos (herencia,
herencia  múltiple,  privacidad,  etcétera) sería excesivo para esta guía, pero
todo  ello  es  posible  con  las  tablas  y  metatablas de Hollywood.  Si está
interesado en aprender más sobre este tema, debería consultar un libro sobre la
programación  con  el  lenguaje  @{u}Lua@{uu}, puesto que Hollywood utiliza el núcleo de
dicho  lenguaje.   Por  ejemplo,  la  segunda edición del libro "Programando en
@{u}Lua@{uu}"¹ de Roberto Ierusalimschy incluye un amplio capítulo sobre el tema en Lua,
que generalmente puede adaptar directamente al código de Hollywood.

                                    --==--

                   ¹ Nota del traductor: El título original
                   es @{i}Programming in @{u}Lua@{uu} (second edition)@{ui}.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgFuncMethods"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgUCOverview "Guía de Hollywood: Generalidades sobre la codificación de caracteres *UPD10*"

@{b}Generalidades@{ub}

Hollywood  7.0  finalmente  presenta  el  soporte  completo  de la codificación
Unicode,   implementada   utilizando   la  codificación  UTF-8.   En  versiones
anteriores,  el  programa  estaba limitado al juego de caracteres ISO 8859-1 en
Windows, Linux y macOS, así como al juego de caracteres por defecto del sistema
del  AmigaOS  y sistemas compatibles.  Por ello, desde la versión 7.0 todos los
guiones deben guardarse utilizando la codificación UTF-8 con o sin la marca del
orden de los octetos (también conocida abreviadamente como BOM).

Todos  los  textos  almacenados  en  cadenas  ahora  han  de almacenarse con la
codificación  UTF-8 y todas las funciones de las bibliotecas de texto y cadenas
ahora  esperarán  este  tipo  de  cadenas  por  defecto.   Es posible hacer que
Hollywood funcione como lo hacía clásicamente, es decir forzar a que utilice la
codificación ISO 8859-1  o  el juego de caracteres  por  defecto  del  AmigaOS,
utilizando el argumento de consola  @{"-encoding" LINK ManualUsage}  o su contrapartida como comando
del preprocesador  @{"@OPTIONS" LINK atOPTIONS},  pero no se recomienda, porque no hay garantía de
que su guión no falle con sistemas locales diferentes.

Todas  las  funciones  de  las  bibliotecas de texto y de cadenas que necesitan
operar con caracteres en cadenas aceptan un parámetro de codificación opcional,
lo   que   permite  definir  qué  codificación  específica  utiliza  la  cadena
suministrada.    No   es  necesario  utilizarlo  normalmente,  ya  que  es  muy
recomendable utilizar siempre la codificación UTF-8, pero en ciertos casos, sin
embargo,  podría  ser necesario utilizar otras codificaciones como puede ser al
operar  con  datos  binarios  sin procesar dentro de una cadena.  En este caso,
basta  con  que  suministre  la  constante  #ENCODING_RAW  a la correspondiente
función  para indicarle que desea operar con datos binarios sin procesar dentro
de la cadena, en lugar de utilizar la codificación UTF-8, y que por lo tanto no
desea  que  dicha  función  realice  comprobaciones  de integridad de la cadena
suministrada.

Para  cambiar la codificación de caracteres por defecto para las bibliotecas de
texto y de cadenas, puede utilizar la función @{"SetDefaultEncoding()" LINK SetDefaultEncoding}: Consúltela
para  los  detalles.   Sin embargo, normalmente no debe ser necesaria y debería
utilizar la codificación por defecto #ENCODING_UTF8.

Si  necesita  prestar  atención  a  teclas no inglesas, ha de utilizar el nuevo
manejador  de eventos  "VanillaKey" con @{"InstallEventHandler()" LINK InstallEventHandler}:  Consulte dicha
función   para  los  detalles.   "VanillaKey"  soporta  el  juego  completo  de
caracteres  Unicode,  mientras  que  "OnKeyDown"  y "OnKeyUp" sólo soportan las
teclas de control y las teclas estándares inglesas.

Debido  a  la transición a Unicode, Hollywood 7.0 podría generar algún problema
de  compatibilidad  con guiones antiguos.  Todos estos problemas potenciales se
tratan en la sección @{"Notas de compatibilidad" LINK APIChanges}:  Consúltela para los detalles.

Para  terminar,  tenga  en  cuenta  de  que la generación de texto de Hollywood
actualmente  sólo  soporta  texto  tradicional,  es  decir,  que el texto va de
izquierda  a  derecha  en  líneas  horizontales,  no  soportándose el que va de
derecha a izquierda ni el vertical.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgUCOverview"}

@ENDNODE
@REMARK =======================================================================
@NODE CharacterEncoding "Guía de Hollywood: Codificación del carácter *UPD10*"

@{b}Codificaciones del carácter@{ub}

La mayoría de las funciones de texto y de cadenas aceptan un parámetro opcional
que  especifica  el  esquema de la codificación de los caracteres a utilizar en
las  cadenas.  Este parámetro le indica a la función qué formato interno tienen
las cadenas suministradas.

Normalmente,  no debería utilizar este parámetro ya que desde la versión 7.0 de
Hollywood, todo el texto debe almacenarse con formato UTF-8.  Sin embargo, bajo
ciertas  circunstancias,  podría  ser  necesario  utilizar  este argumento para
modificar  la codificación, como por ejemplo, en aquellas cadenas que contienen
datos  binarios  sin procesar.  Estos datos, naturalmente, no tienen un formato
UTF-8  válido  y por ello serán rechazadas por las funciones de cadena, así que
la  única  manera  de  operar con ellos, es indicarle a dichas funciones que no
tienen  la  codificación  UTF-8,  sino  que  son  una secuencia sin procesar de
octetos.   Esto  se  consigue  suministrando  la  constante  #ENCODING_RAW como
parámetro de codificación.

Aquí  tiene  la relación de los diferentes esquemas de codificación disponibles
en Hollywood:

  #ENCODING_UTF8

  Es  la codificación por defecto desde la versión 7.0 de Hollywood y es la que
  debe utilizar siempre que trabaje con texto.

  #ENCODING_ISO8859_1

  Es  la  codificación  por defecto ANTERIOR a la versión 7.0 de Hollywood.  Se
  sigue  soportando  por cuestiones de compatibilidad, pero no se recomienda su
  uso.

  #ENCODING_RAW

  Es  un  sinónimo  de  la  codificación  #ENCODING_ISO8859_1.  Se utiliza para
  indicar  a  las funciones de la biblioteca de cadenas que han de tratar a las
  cadenas como datos binarios sin procesar en lugar de cómo texto.

  #ENCODING_AMIGA

  Esta constante especifica el juego de caracteres por defecto del sistema bajo
  AmigaOS y sistemas compatibles.  Esta constante sólo se soporta en la función
  @{"ConvertStr()" LINK ConvertStr}  y sólo  bajo  sistemas  AmigaOS y compatibles, obviamente.  Le
  permite  realizar  conversiones  entre el juego de caracteres por defecto del
  AmigaOS y la codificación UTF-8 (en ambos sentidos).

Puede utilizar la función @{"SetDefaultEncoding()" LINK SetDefaultEncoding} para cambiar la codificación de
caracteres  por defecto para las bibliotecas de texto y de cadenas:  Consúltela
para los detalles.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/CharacterEncoding"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTSTroubleshooting "Guía de Hollywood: Solución a problemas *UPD10*"

@{b}Solución a problemas@{ub}

Esta  sección  cubre  algunos  de  los  problemas  más  comunes  ofreciendo sus
soluciones:

1. @{b}Inicialización de tablas@{ub}

   Tenga  cuidado  cuando  intente  crear  un  campo de una tabla asignando una
   variable que no ha sido utilizada antes, puesto que su "valor" será @{"NIL" LINK PrgTypeNil}. Si
   hace esto el campo no se creará.  Por ejemplo, lo siguiente no funcionará:

     t = {}           ; Crea una tabla
     t.x = y          ; Asigna "y" al campo "x" (¡¡ "y" es 'NIL' !!)
     DebugPrint(t.x)  ; ---> ¡Error! ¡El campo "x" no está inicializado!

   La solución es inicializar "y" primero, por ejemplo:

     t = {}           ; Crea una tabla
     y = 0            ; Define "y" a 0
     t.x = y          ; Asigna "y" al campo "x"
     DebugPrint(t.x)  ; ¡Funciona! Imprime 0

2. @{b}Comparación de una variable con el valor @{"NIL" LINK PrgTypeNil}@{ub}

   ¡Tenga cuidado cuando compare una variable con @{"NIL" LINK PrgTypeNil}!  @{"GetType()" LINK GetType} es la única
   forma fiable  de  comprobar  si  una  variable  tiene  el  "valor"  @{"NIL" LINK PrgTypeNil} (no
   inicializada)  o no.   Comprobando  si la variable es igual a @{"NIL" LINK PrgTypeNil} no es una
   buena idea, porque podría dar un resultado verdadero si la variable tiene un
   valor nulo en lugar de @{"no estar inicializada" LINK PrgTypeNil}.  Ejemplo:

     a = 0
     b = NIL

     DebugPrint(GetType(a) = #NIL, a = NIL)  ; Imprime "0 1"
     DebugPrint(GetType(b) = #NIL, b = NIL)  ; Imprime "1 1"

   Puede ver que "a  =  NIL"  devuelve  el resultado TRUE a pesar de que "a" es
   nulo.   Esto  es debido  a  que  @{"NIL" LINK PrgTypeNil} siempre es tratado como cero cuando se
   utiliza  en expresiones.  Por lo tanto, si quiere saber si una variable está
   definida como @{"NIL" LINK PrgTypeNil}, utilice @{"GetType()" LINK GetType} y compare el resultado con #NIL.

   Desde la versión 6.0 de Hollywood también puede utilizar la función dedicada
   @{"IsNil()" LINK IsNil}  para comprobar  si  una  variable  es  NIL:   Consúltela  para los
   detalles.

3. @{b}Inicialización errónea de variables@{ub}

   En  Hollywood,  la inicialización de múltiples variables difiere un poco con
   respecto a la mayoría del resto de lenguajes porque Hollywood espera sólo un
   signo igual.  Por ejemplo, esto podría parecer correcto, pero no lo es:

     ; ¡Código erróneo!
     Local a = 5, b = 6, c = 7

   Desgraciadamente,  este código erróneo no generaría un error, sino que sería
   interpretado  pero  de  forma  incorrecta:   Haría que Hollywood asignase el
   valor  5 a la variable "a"  y  simplemente ignoraría el resto de la línea al
   haberse  encontrado una variable al lado izquierdo del signo igual.  Así que
   tenga  cuidado  con la inicialización de múltiples variables.  Siguiendo con
   el ejemplo, la versión correcta se escribiría así:

     ; ¡Código correcto!
     Local a, b, c = 5, 6, 7

   Este código asignará el valor 5 a la variable "a", 6 a "b" y 7 a "c".

4. @{b}Devolviendo valores@{ub}

   Tenga  cuidado  con  funciones que devuelven algo.  El valor retornado ha de
   estar  encerrado  entre  paréntesis.  El código como el siguiente ejemplo es
   erróneo, pero no generará un error:

     Function p_Sumar(a, b)
       Local r = a + b
       Return r   ; ¡¡¡AY!!!
     EndFunction

   Este  código  podría ser interpretado como "Retornar, y entonces llamar a la
   función  r()".  Naturalmente, la llamada a "r()" nunca llegará a realizarse,
   pero la función escrita más arriba devolverá @{"NIL" LINK PrgTypeNil}, o sea, nada, en todos los
   casos.  La versión correcta es ésta:

     Function p_Sumar(a, b)
       Local r = a + b
       Return(r)
     EndFunction


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTSTroubleshooting"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTSFAQ "Guía de Hollywood: Respuestas a preguntas habituales *UPD10*"

@{b}Respuestas a preguntas habituales sobre Hollywood@{ub}

Esta  sección,  como  bien  indica  su  título,  responde  a  algunas preguntas
planteadas  con cierta frecuencia.  Por favor léalas antes de plantearlas en el
foro porque su problema podría estar ya tratado por esta sección.

@{b}P: ¿Es posible  generar  directamente  con Hollywood  los paquetes "*.apk" para
   Android y así poder publicarlos a @{u}Google Play@{uu}?@{ub}

R: Sí,  es  posible  con  el  compilador  APK para Hollywood disponible como un
   complemento:   Por  favor,  visite  el  portal  oficial  de  Hollywood en la
   dirección  http://www.hollywood-mal.com  para  más  información.   Como otra
   alternativa,  puede  utilizar  el  reproductor  gratuito  de  Hollywood para
   Android  si quiere ejecutar  sus proyectos en dicha plataforma:  Consulte la
   sección sobre @{"Plataformas móviles" LINK MobilePlatforms} para los detalles.

                                   ---==---

@{b}P: ¿Es  posible  crear  una  interfaz  de  usuario  desde Hollywood que utilice
   artilugios nativos del sistema operativo?@{ub}

R: Sí,  ahora  es  posible  con  el  complemento  RapaGUI.  Este complemento le
   permite  crear  interfaces  nativas  para  AmigaOS  y  sistemas compatibles,
   Windows,  macOS  y  Linux.   La  maquetación  de  dichas  interfaces  pueden
   definirse  convenientemente en XML.  RapaGUI está disponible gratuitamente y
   puede  descargarse  desde  http://www.hollywood-mal.com.   Si su objetivo es
   únicamente  los  sistemas  AmigaOS  y compatibles, también puede utilizar el
   complemento  MUI  Royale, que le permite utilizar casi complementamente bajo
   Hollywood la interfaz para desarrolladores de MUI, maquetando dicha interfaz
   también en XML.

                                   ---==---

@{b}P: He compilado mi proyecto para macOS, pero macOS se niega a ejecutarlo.  ¿Qué
   tengo que hacer para conseguirlo?@{ub}

R: macOS  es  muy  estricto  a la hora de ejecutar aplicaciones que no han sido
   firmadas  por  un  desarrollador  registrado  de  Apple.  Típicamente, estas
   aplicaciones no firmadas quedan en cuarentena lo que significa que no pueden
   abrirse.   Puede,  sin  embargo,  desactivar  la bandera de cuarentena de la
   aplicación ejecutando la siguiente línea desde la terminal...

   xattr -dr com.apple.quarantine /path/to/your/App.app

   Con esto será capaz de abrir (=ejecutar) su aplicación sin problemas.

                                   ---==---

@{b}P: La generación de imágenes 2D es demasiado lenta. ¿Cómo puedo acelerarla?@{ub}

R: En   algunas  plataformas,  Hollywood  realiza  las  operaciones  de  dibujo
   utilizando el microprocesador, garantizando la máxima compatibilidad en todo
   tipo  de  plataformas.   El uso de la aceleración a través de la circuitería
   incrementa el riesgo de fallos con controladores gráficos defectuosos en los
   sistemas   operativos   anfitriones.   Sin  embargo,  Hollywood  soporta  la
   aceleración  a través de la circuitería, para lo cual usted ha de configurar
   un  sistema  de  doble tampón a través de la circuitería y crear sus brochas
   como  brochas  electrónicas.   Bajo  Windows,  macOS  y  Linux no se incluye
   soporte  interno  de  estas  prestaciones  de  momento,  por lo que necesita
   utilizar un complemento como "GL Galore" o "RebelSDL" para poder disponer de
   estas  prestaciones  en   dichos  sistemas.     Consulte  la  sección  sobre
   las @{"brochas electrónicas" LINK HardwareBrushNote} para los detalles.

                                   ---==---

@{b}P: Estoy  utilizando  el  motor  de  redimensionado  automático  (o  el modo de
   visualización  "pantalla  completa  (redimensionada)") para redimensionar mi
   guión  a  una resolución más alta.  El rendimiento es muy pobre.  ¿Hollywood
   no  puede  utilizar el coprocesador especializado de la tarjeta gráfica para
   las tareas de redimensionado?@{ub}

R: Hollywood  no soporta el redimensionado acelerado a través de la circuitería
   en  todas  las  plataformas  por  defecto.   Así,  bajo  Windows,  sólo está
   disponible  a partir de la versión 7 y versiones superiores, mientras que en
   macOS sólo está disponible a partir de la versión 10.10 y superiores.

   Si  ejecuta  Hollywod  en  un  sistema  donde  el  motor  de  redimensionado
   automático muestra un rendimiento pobre, podría ser capaz de obtener grandes
   mejoras de velocidad utilizando un complemento que soporte el redimensionado
   acelerado  a  través  de  la  circuitería  como  "GL  Galore"  o "RebelSDL".
   Consulte la sección @{"Obtención de complementos" LINK PluginsObtaining} para los detalles.

                                   ---==---

@{b}P: La   versión   de  Windows  de  Hollywood  ofrece  un  bonito  entorno  para
   desarrolladores.  ¿Porqué no se ofrece éste en la plataforma Amiga?@{ub}

R: Crear  dicho  entorno requeriría demasiado trabajo.  Existen otros programas
   que  puede  utilizar  en  Amiga para crear guiones para Hollywood.  Eche una
   ojeada  a  @{u}Cubic IDE@{uu} de Dietmar Eilert o a @{u}Codebench@{uu} de Simon Archer:  Ambos
   programas soportan Hollywood a través de complementos.

                      http://www.softwareandcircuits.com/
                            http://codebench.co.uk

                                   ---==---

@{b}P: ¿Cómo  puedo incrustar imágenes, sonidos, tipos de impresión, etcétera en mi
   ejecutable compilado?@{ub}

R: Si utiliza comandos del preprocesador como @{"@BRUSH" LINK atBRUSH}, @{"@BGPIC" LINK atBGPIC}, @{"@MUSIC" LINK atMUSIC}, @{"@FONT" LINK atFONT},
   etcétera, entonces Hollywood incrustará  todos los datos externos declarados
   con  estos  comandos en su ejecutable automáticamente.  Si está cargando sus
   datos manualmente utilizando  @{"LoadBrush()" LINK Loadbrush},  @{"OpenMusic()" LINK OpenMusic},  @{"SetFont()" LINK SetFont}, etc.,
   entonces  tendrá  que utilizar  el  argumento  de consola  @{"-linkfiles" LINK ManualUsage}  para
   especificar que los ficheros han de incrustarse en su ejecutable.

                                   ---==---

@{b}P: ¿Cómo puedo cambiar entre el modo de ventana y pantalla completa?@{ub}

R: Existe  una  combinación de teclas que permite realizar dicho cambio durante
   la  ejecución  de  sus  guiones:  simplemente pulse la tecla COMANDO+RETORNO
   bajo  AmigaOS  y  macOS,  o,  ALT DERECHA+RETORNO bajo Windows.  Si necesita
   cambiar de  modo   desde   el  código  de  su  guión,   utilice  el  comando
   @{"ChangeDisplayMode()" LINK ChangeDisplayMode}.

                                   ---==---

@{b}P: ¿Cómo  puedo  cambiar  el  icono  de  los  ejecutables compilados utilizando
   Hollywood?@{ub}

R: Utilice el comando del preprocesador @{"@APPICON" LINK atAPPICON} para ello.

                                   ---==---

@{b}P: Cuando  utilizo  tipos  TrueType, he notado que el texto se muestra de forma
   ligeramente  diferente entre AmigaOS y Windows, o Windows y macOS, o AmigaOS
   y macOS.  ¿Cómo puedo corregirlo?@{ub}

R: Si  quiere  que  el  texto  TrueType  se  vea exactamente igual en cualquier
   plataforma, ha de utilizar el motor tipográfico interno de Hollywood.  Puede
   activarlo  utilizando  la  constante  interna  #FONTENGINE_INBUILT  con  los
   comandos @{"SetFont()" LINK SetFont},  @{"OpenFont()" LINK Openfont} o @{"@FONT" LINK atFONT}.  Por defecto, Hollywood utilizará
   el motor  tipográfico  nativo  del  sistema  operativo  anfitrión (constante
   interna  #FONTENGINE_NATIVE)  y eso implica un aspecto ligeramente diferente
   de una plataforma a otra. Utilice #FONTENGINE_INBUILT, si no quiere eso.

                                   ---==---

@{b}P: ¿Cómo puedo incrementar el rendimiento bruto de mi guión?@{ub}

R: Podría  querer  desactivar  el  resorte  de  la línea por breves períodos de
   tiempo  para  incrementar  el  rendimiento  bruto  de  la máquina virtual de
   Hollywood.  Consulte @{"DisableLineHook()" LINK DisableLineHook} para los detalles.

                                   ---==---

@{b}P: He  compilado mi guión para macOS pero cuando lo pongo en marcha bajo macOS,
   ¡obtengo  un  error indicando que no encuentra los ficheros de datos para mi
   programa!@{ub}

R: Asegúrese  de  que  ha  colocado todos los ficheros de datos exigidos por su
   programa  dentro  del  cajón  de  recursos  "Resources"  en el paquete de su
   aplicación  compilada por Hollywood.  Por ejemplo, si Hollywood ha compilado
   un  paquete  llamado  "MiAlucinantePrograma.app", entonces ha de colocar los
   ficheros   de   datos   requeridos  por  dicho  programa  dentro  del  cajón
   "MiAlucinantePrograma.app/Contents/Resources".  Así funcionará.

                                   ---==---

@{b}P: He  compilado mi guión para macOS/Linux, pero no quiere ejecutarse.  ¿Qué es
   lo que falla?@{ub}

R: Asegúrese  de  que  el  programa  principal dentro del paquete de aplicación
   tiene  la  bandera de ejecución activada.  Cuando se realiza una compilación
   cruzada  de  programas  de macOS/Linux en Windows o AmigaOS, dicha bandera o
   atributo  a  menudo no se define correctamente porque macOS y Linux utilizan
   sistemas de ficheros diferentes.  Por ello, a veces tendrá que definir dicha
   bandera manualmente.

                                   ---==---

@{b}P: ¿Hay  un  programa  que  sirva  como  diseñador  visual  para los guiones de
   Hollywood  o  tengo  que  crear/modificar cada guión utilizando un editor de
   texto?@{ub}

R: Sí,  hay un programa denominado  @{fg highlight}Hollywood Designer@{fg text}  que ofrece una poderosa
   interfaz  gráfica  del tipo  "lo que se ve es lo que se obtiene"  para crear
   sus  propios  proyectos  con  Hollywood.   Eche  una  ojeada  en  la  página
   http://www.hollywood-mal.com/ para más información sobre este gran programa.
   Por  favor,  tenga  en  cuenta  que  este  programa  en  concreto  sólo está
   disponible actualmente para la plataforma Amiga y equipos compatibles.

                                   ---==---

@{b}P: ¿Hay  algún  foro  dedicado  a  Hollywood donde entrar en contacto con otros
   usuarios?@{ub}

R: Sí.   Por favor, eche una ojeada a la sección de la comunidad "Community" en
   el portal oficial en línea en http://www.hollywood-mal.com/.

                                   ---==---

@{b}P: Cuando  compilo  mi guión para Windows/macOS,  ¡obtengo  un mensaje de error
   del  tipo  indicando que Hollywood no puede abrir los tipos de impresión que
   utilizo!  ¿Qué estoy haciendo mal?@{ub}

R: Por  favor,  lea la sección sobre @{"trabajar con los tipos de impresión" LINK PrgG2KFonts} en el
   fichero  guía para una explicación detallada de cómo lidiar con los tipos de
   impresión en guiones multiplataforma.

                                   ---==---

@{b}P: Veo  que  programas  compilados con Hollywood soportan diferentes argumentos
   desde  la  consola.   ¡Pero  yo nunca pongo en marcha los programas desde la
   consola!  ¿Puedo aún así traspasarle los argumentos de alguna otra forma?@{ub}

R: Sí, es posible.  Lea la sección dedicada a @{"los argumentos sin la consola" LINK ConsoleEmulation} en
   este fichero guía para más información.

                                   ---==---

@{b}P: Cuando  intento  cargar una animación, siempre obtengo un mensaje quejándose
   de   que   la   memoria   libre  es  insuficiente,  a  pesar  de  que  tengo
   512 megaoctetos de RAM.@{ub}

R: Asegúrese  de  que ha activado la reproducción tamponada desde disco.  Puede
   hacerlo  utilizando  la etiqueta "FromDisk" con @{"LoadAnim()" LINK LoadAnim} o @{"@ANIM" LINK atANIM}.  Si no
   la especifica, Hollywood cargará  en memoria  toda la animación y puesto que
   Hollywood utiliza gráficos de 32 bits siempre, los 512 megaoctetos enseguida
   se llenarán.

                                   ---==---

@{b}P: Cuando  intento  acceder  a  un  campo que no existe en mi tabla, ¡Hollywood
   termina  inmediatamente  con  un  mensaje  de  error!   ¿Hay alguna forma de
   comprobar si existe un campo en una tabla antes de intentar acceder a él?@{ub}

R: Es posible  utilizando  la función @{"HaveItem()" LINK HaveItem}.  Devolverá el valor FALSE si
   el campo especificado de la tabla no existe.

                                   ---==---

@{b}P: La  salida  de  sonido  de Hollywood suena distorsionada bajo AmigaOS.  ¿Qué
   sucede?@{ub}

R: Compruebe  las preferencias del sistema de sonido AHI.  Tendrá que elegir la
   opción  "con  recorte"  para  el  volumen  maestro o principal en la sección
   avanzada  de  dichas  preferencias.   Si  esto  no ayuda, intente reducir el
   volumen   principal  o  maestro  especificando  el  argumento  de  Hollywood
   @{"-mastervolume" LINK ManualUsage}.   También debería  desactivar  los  modos  de  eco  y sonido
   envolvente  si  tiene  problemas  de  sonido.   Asegúrese  también de que ha
   definido  la  frecuencia de su gestor de sonido correctamente:  Ha de ser al
   menos de 22.050 Hz.

                                   ---==---

@{b}P: Me  gustaría  añadir  mis  propios  comandos  a  Hollywood  a  través  de un
   complemento.  ¿Existe un paquete para desarrolladores?@{ub}

R: Sí, está disponible para su descarga en el portal oficial de Hollywood en la
   dirección  http://www.hollywood-mal.com.   Incluye  ejemplos  y  una  amplia
   documentación que debería utilizar para comenzar.

                                   ---==---

@{b}P: ¿Cómo  puedo  interrumpir  las guiones que se ejecutan en una ventana que no
   tiene el botón de cierre?@{ub}

R: Basta  con  que  presione la combinación de teclas Ctrl-C.  Esta combinación
   funciona siempre salvo que sea desactivada utilizando @{"CtrlCQuit()" LINK CtrlCQuit}.

                                  ---==---

@{b}P: ¿Dónde puedo pedir ayuda?@{ub}

R: El  mejor  lugar  para ello es el foro oficial de Holllywood en la dirección
   http://forums.hollywood-mal.com.   Hay  además  una lista de distribución de
   noticias  que se usa para anuncios, así que si quiere estar al día sobre los
   últimos  lanzamientos, nuevos complementos, actualizaciones y cualquier otra
   cosa más relacionada con Hollywood, suscríbase a ésta visitando la página

                         http://www.hollywood-mal.com

                                  ---==---

@{b}P: He encontrado un fallo.@{ub}

R:  Por favor, publíquelo en la sección de errores "Bugs" del foro.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTSFAQ"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTUTutorial "Guía de Hollywood: Tutorial *UPD10*"

@{b}Tutorial@{ub}

Este  pequeño  tutorial  le  muestra  cómo crear su propia presentación en diez
fáciles  pasos.  Intente comprender cada paso dado y muy pronto podrá crear sus
propios guiones.

Para este tutorial se necesita lo siguiente:

01. Una  imagen  de fondo  llamada "BG.png" con dos flechas.  El rectángulo que
    abarca  la flecha  nº  1  tiene  los  valores  X: 4,  Y: 350,  ANCHURA: 35,
    ALTURA: 19.   El rectángulo  que abarca la flecha nº 2 tiene los valores X:
    591,  Y:430,  ANCHURA:  35,  ALTURA:   19.  El área donde estas imágenes se
    visualizan tiene como coordenadas X: 29, Y: 41.

02. Once imágenes denominadas "0.jpg", "1.jpg", "2.jpg"...  "10.jpg" de 571x377
    píxeles de tamaño.

03. Un módulo en formato Protracker llamado "MyMusic.mod".

Naturalmente, ya he preparado yo todo esto para este tutorial:  Los ficheros se
encuentran en el directorio "Help/Tutorial" dentro del directorio de Hollywood.
Por  favor,  copie  todos  estos  ficheros al directorio donde creará su guión.
Hecho esto, siga los siguientes pasos:

01. Ponga en marcha su editor de textos favoritos.

02. El fondo de su presentación será una imagen que haya creado con su programa
    de dibujo favorito.  En nuestro ejemplo, ya he preparado un fondo.

03. Ahora,  necesitamos indicarle  a  Hollywood  que  utilizaremos  el  fichero
    "BG.png"  como nuestra primera imagen de fondo.  Esto se hace especificando
    el comando  del preprocesador  @{"@BGPIC" LINK atBGPIC} junto  el nombre del fichero citado.
    Así que ha de escribir lo siguiente en el fichero que será su guión:

      \@BGPIC 1, "BG.png"

    Este comando  le  dice  a  Hollywood  que utilice  el fichero "BG.png" como
    imagen  de fondo inicial.  Esta imagen de fondo inicial siempre ha de tener
    el   identificador  nº  1,  pues  si  no  hay  imagen  de  fondo  con  este
    identificador, Hollywood creará una visualización en blanco.

04. Nuestra presentación también tendrá algo de música de fondo. Esta música es
    un módulo  en  formato  Protracker  con  el  nombre "MyMusic.mod".  Así que
    añadamos la siguiente línea a nuestro guión:

      \@MUSIC 1, "MyMusic.mod"

05. Ahora  hemos de definir las áreas en nuestra imagen de fondo que han de ser
    accesibles como  botones.   Como puede ver, hay dos flechas en la imagen de
    fondo.    Como  todos  los  botones  han  de  definirse  como  rectángulos,
    necesitamos  averiguar las coordenadas así como la altura y anchura de cada
    flecha: Puede utilizar un programa de dibujo como "PPaint" para esta tarea.
    Para  nuestra imagen de fondo, la flecha orientada hacia la izquierda es un
    rectángulo  con  las coordenadas  4:430  (esquina  superior izquierda) y la
    anchura/altura  es  de 35/19.   Así  que  podemos  añadir  ahora  la flecha
    orientada hacia la izquierda como el botón nº 1 a nuestro guión escribiendo
    el siguiente código en el fichero de lo que será nuestro guión:

      MakeButton(1, #SIMPLEBUTTON, 4, 430, 35, 19,
        {OnMouseUp = p_Retroceder})

    Ahora  podemos  hacer lo mismo con la flecha orientada hacia la derecha que
    es  un rectángulo que comienza en 591:430 con las mismas dimensiones que la
    primera flecha.  Así que podemos escribir lo siguiente en nuestro guión:

      MakeButton(2, #SIMPLEBUTTON, 591, 430, 35, 19,
        {OnMouseUp = p_Avanzar})

    Con esto  hemos  definido  dos  botones que reaccionarán al ratón cuando se
    presione el puntero sobre ellos.  Si el botón nº 1 es presionado, Hollywood
    llamará  a la función  "p_Retroceder()"  y  si el botón nº 2 es presionado,
    Hollywood llamará a la función "p_Avanzar()".

06. Ahora  podemos  empezar  a añadir  un  montón  de  comandos  que le digan a
    Hollywood  qué hacer.   En  primer  lugar,  queremos que la música de fondo
    empiece a sonar.  Como hemos declarado "MyMusic.mod" como el objeto musical
    con  el identificador  nº 1, ahora podemos llamar a @{"PlayMusic()" LINK PlayMusic} utilizando
    dicho identificador como argumento.  Añada  la siguiente línea a su guión y
    Hollywood reproducirá el módulo de Protracker:

      PlayMusic(1)

    También  necesitamos definir qué imagen será la última.  En nuestro ejemplo
    tenemos  once  imágenes que van desde la "0.jpg" hasta la "10.jpg", así que
    la  última  será  la número 10.  Por eso, añadimos las siguiente línea a su
    guión:

      ultimaimg = 10

    También  añadimos la siguiente línea porque nuestra primera imagen va a ser
    "0.jpg":

      img = 0

07. El siguiente comando cargará la imagen siguiente y la visualizará.  Como no
    hay  comando  que  haga todo esto, necesitamos escribir una pequeña función
    que  llamaremos  "p_SigImagen()".   En el décimo punto verá cómo se escribe
    esta  rutina,  así que por ahora supondremos que ya existe y simplemente le
    diremos a Hollywood que la invoque:

      p_SigImagen()

08. Ahora  añadiremos  el bucle  principal  de  nuestro  guión.  El formato más
    popular de este bucle es el que sigue:

      Repeat
        WaitEvent
      Forever

    Este comando @{"WaitEvent()" LINK WaitEvent}  detiene  la  ejecución  del  guión  hasta que se
    produzca un evento, por ejemplo hasta que se pulse un botón.  Si se produce
    un evento, @{"WaitEvent()" LINK WaitEvent}  saltará a la función que maneja este evento, y así
    por ejemplo,  si  el botón nº 1  fuese el pulsado, @{"WaitEvent()" LINK WaitEvent} saltaría en
    nuestro  ejemplo  a  la función  "p_Retroceder()".   Cuando  se  termine de
    ejecutar  esta  acción,  se  retornará  al  bucle  principal y se volverá a
    invocar a  @{"WaitEvent()" LINK WaitEvent},  repitiéndose  esto  una  y  otra vez hasta que el
    usuario cierra la ventana.

09. Con esto la estructura de nuestro guión está completa.  Lo que necesitamos
    hacer ahora  es añadir  las funciones "p_Retroceder()" que es invocada por
    @{"WaitEvent" LINK WaitEvent}  cuando se presiona  el  botón  nº  1  (botón  de  retroceso)  y
    "p_Avanzar()"  que  es invocada también por @{"WaitEvent()" LINK WaitEvent} cuando se presiona
    el botón nº 2 (botón de avance). Es importante definir las funciones ANTES
    de referenciarlas,  por lo que ha de añadir  el siguiente código  antes de
    llamarlas con @{"MakeButton()" LINK MakeButton}, líneas que ya escribimos en el paso nº 5.  Así
    que añada estas funciones ahora:

      Function p_Retroceder()
        If img = 0
          img = ultimaimagen
        Else
          img = img - 1
        EndIf
        p_SigImagen()
      EndFunction

      Function p_Avanzar()
        If img = ultimaimg
          img = 0
        Else
          img = img + 1
        EndIf
        p_SigImagen()
      EndFunction

    Como puede apreciar en las líneas anteriores, la variable "img" contiene el
    número  de la imagen actual.  Si el usuario presiona en el botón de avance,
    el valor  de la variable aumenta en una unidad, mientras que si presiona en
    el  de retroceso se reduce en una unidad.  Además la variable es "vigilada"
    para que no adquiera valores ilegales fuera del rango permitido.

10. Ahora  lo único que nos falta es escribir nuestra función "p_SigImagen" que
    se  encargará  de cargar y visualizar la imagen con el número almacenado en
    la  variable  "img".   Aquí  tiene  el  código,  pero  recuerde  que  ha de
    insertarlo antes de llamar a @{"MakeButton" LINK MakeButton}:

      Function p_SigImagen()
        LoadBrush(1, img .. ".jpg")
        DisplayBrush(1, 29, 41)
      EndFunction

    ¿Pero  qué  hace la rutina "p_SigImagen()"?  Simplemente añade la extensión
    al  valor  de  la  variable  "img"  para crear el nombre del fichero con la
    imagen  correspondiente  y a continuación lo carga y visualiza la brocha en
    las  coordenadas  29:41.   Por  eso  las  imágenes  han sido nombradas como
    "0.jpg" (primera imagen), "1.jpg" (segunda imagen) y así sucesivamente.

    Finalmente nuestro guión debería quedar así:

      \@BGPIC 1, "BG.png"
      \@MUSIC 1, "MyMusic.mod"

      Function p_SigImagen()
        LoadBrush(1, img .. ".jpg")
        DisplayBrush(1, 29, 41)
      EndFunction

      Function p_Retroceder()
        If img = 0
          img = ultimaimg
        Else
          img = img - 1
        EndIf

        p_SigImagen()
      EndFunction

      Function p_Avanzar()
         If img = ultimaimg
           img = 0
         Else
           img = img + 1
         EndIf

         p_SigImagen()
      EndFunction

      MakeButton(1, #SIMPLEBUTTON, 4, 430, 35, 19,
       {OnMouseUp = p_Retroceder})
      MakeButton(2, #SIMPLEBUTTON, 591, 430, 35, 19,
       {OnMouseUp = p_Avanzar})
      PlayMusic(1)

      ultimaimg = 10
      img = 0

      p_SigImagen()

      Repeat
        WaitEvent
      Forever

Ahora  ya  puede  guardar  su guión y ponerlo en marcha a través de la interfaz
@{"GUI" LINK GUI} de Hollywood  o desde la consola.  ¡Felicidades, ha creado su primer guión
de Hollywood!  ¿No ha sido fácil?  ¡Sólo 35 líneas de código!

Ahora  puede  mejorarlo/ampliarlo  si  lo desea.  Por ejemplo, si quiere que la
imagen se visualice con una transición basta con que reemplace la línea:

  DisplayBrush(1, 29, 41)

por la línea

  DisplayBrushFX(1, 29, 41, #RANDOMEFFECT)

y  su  imagen  aparecerá con una bonita transición elegida al azar de la amplia
variedad que ofrece Hollywood.


                                                           @{">> Versión original" LINK "HollywoodEN.guide/PrgTUTutorial"}

@ENDNODE
@REMARK =======================================================================
@NODE PrgTUAnimation "Guía de Hollywood: Técnicas de animación *UPD10*"

@{b}Técnicas de animación@{ub}

Cuando  se  necesita  una  animación,  tiene  que  elegir  entre tres técnicas:
duendecillos  gráficos,  doble  (memoria)  tampón  y capas.  Esta sección se ha
diseñado  para darle una visión general de las tres técnicas y así facilitar la
elección de la más fácil para usted.

  1. Duendecillos:

     Son  especialmente  útiles cuando no hay muchos gráficos que dibujar.  Por
     ejemplo,  si sólo necesitar algunos bloques o al personaje del jugador y a
     los  objetos  enemigos  de  alrededor.   En  este  caso, es mejor utilizar
     duendecillos porque Hollywood puede refrescar la visualización lo bastante
     rápido porque no se producen muchos cambios.  Consulte la sección sobre la
     @{"presentación de los duendecillos gráficos" LINK SpritesIntroduction} para los detalles.

  2. Doble (memoria) tampón:

     La utilización de esta técnica en Hollywood siempre es necesaria cuando se
     quiere refrescar toda la visualización.  Aunque en este caso se utiliza la
     aceleración  a  través de la circuitería cuando es posible, puede resultar
     bastante  costoso  con  una  área  de visualización de 640x480 píxeles que
     necesita  un  refresco de 25 veces por segundo.  Así, un doble tampón sólo
     se  recomienda  cuando  gran  cantidad  de  gráficos  a  medida  deben  de
     dibujarse.   Por  ejemplo,  los  ejemplos  de  Hollywood  que  dibujan  un
     desplazamiento  senoidal  real  utilizan  esta  técnica  porque  necesitan
     dibujar  un  montón  de  elementos diferentes.  Esto no es posible con los
     duendecillos  porque  las operaciones de dibujo son altamente definibles y
     cambian  con  cada  fotograma.   Consulte  la sección @{"BeginDoubleBuffer()" LINK BeginDoubleBuffer}
     para los detalles.

  3. @{"Capas" LINK LayersIntroduction}:

     Hollywood  incluye  un  poderoso sistema de capas que le permite acceder a
     cada  ítem  gráfico  de  la visualización como si tuviese su propia capa y
     modificar  su  posición,  tamaño y aspecto sobre la marcha.  El sistema de
     capas  es  extremadamente  flexible y poderoso a costa de la velocidad así
     que  si  necesita dibujar un buen número de gráficos podría ser más rápido
     utilizar en su lugar el sistema de doble (memoria) tampón.

Aquí  tiene  una  recomendación de las técnicas de animación adecuadas para los
tipos más comunes de aplicaciones:

  * Juegos de cartas/tablero

    Duendecillos o capas porque no se exigen gráficos rápidos.

  * Tetris

    Duendecillos o capas porque no hay mucha acción y las actualizaciones de la
    pantalla no han de ser muy rápidas.

  * Comecocos

    Duendecillos  o  capas, puesto que lo único que se mueve son los enemigos y
    el jugador.

  * Matamarcianos 2D

    Doble  tampón porque el fondo se desplaza.  Además, la pantalla completa se
    actualiza con cada fotograma.

  * Juego de plataformas

    Doble   tampón  porque  el  fondo  se  desplaza.   Si  el  juego  no  tiene
    desplazamiento, entonces duendecillos o capas.

  * Producción de la escena, como una demostración

    Doble (memoria) tampón siempre:  Es un caso clásico de su uso, pues se hace
    uso de una gran cantidad de gráficos a medida.

Si  utiliza  duendecillos o capas debería también encapsular todos los comandos
necesarios  para  dibujo  en  un  única  bloque  de  su proyecto delimitado por
@{"BeginRefresh()" LINK BeginRefresh} y @{"EndRefresh()" LINK EndRefresh}. Esto permitirá a Hollywood optimizar el dibujo
en  sistemas  que  no  soportan  refresco  parcial  de la pantalla como los que
ejecutan   Android.    Como   un  efecto  colaterial  bienvenido,  al  utilizar
@{"BeginRefresh()" LINK BeginRefresh} y @{"End