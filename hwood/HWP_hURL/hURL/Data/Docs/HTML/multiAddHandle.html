<html>
<!-- generated from hurl.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>multi:AddHandle</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
multi:AddHandle -- add an easy handle to a multi session</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
multi:AddHandle(handle)</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
Adds a standard easy handle to the multi stack. This function call will make this multi
handle control the specified easy handle.

<p>
While an easy handle is added to a multi stack, you cannot and you must not use <a href="easyPerform.html">easy:Perform()</a>
on that handle. After having removed the easy handle from the multi stack again, it is perfectly fine
to use it with the easy interface again.

<p>
If the easy handle is not get to use a shared (<code>#CURLOPT_SHARE</code>) or global DNS cache (<code>#CURLOPT_DNS_USE_GLOBAL_CACHE</code>),
it will be made to use the DNS cache that is shared between all easy handles within the multi handle when
<code>multi:AddHandle()</code> is called.

<p>
When an easy interface is added to a multi handle, it will use a shared connection cache owned by the multi handle.
Removing and adding new easy handles will not affect the pool of connections or the ability to do connection re-use.

<p>
If you have <code>#CURLMOPT_TIMERFUNCTION</code> get in the multi handle (and you really should if you're working event-based with
<a href="multiSocketAction.html">multi:SocketAction()</a> and friends), that callback will be called from within this function to ask for an updated
timer so that your main event loop will get the activity on this handle to get started.

<p>
The easy handle will remain added to the multi handle until you remove it again with <a href="multiRemoveHandle.html">multi:RemoveHandle()</a> -
even when a transfer with that specific easy handle is completed.

<p>
You should remove the easy handle from the multi stack before you terminate first the easy handle and then the multi handle:

<p>
<ol>
<li><a href="multiRemoveHandle.html">multi:RemoveHandle()</a>
</li><li><a href="easyClose.html">easy:Close()</a>
</li><li><a href="multiClose.html">multi:Close()</a>
</li></ol>

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>handle</i></dt>
<dd>easy handle to add to multi handle</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="multiAddHandle_.html" target="_top">Show TOC</a></font>
</body>
</html>