<html>
<!-- generated from hurl.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>easy:SetOpt_WriteFunction</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
easy:SetOpt_WriteFunction -- get callback for writing received data</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
easy:SetOpt_WriteFunction(write_callback[, userdata])</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
Pass a callback function. This callback function gets called by libcurl as soon as there is data
received that needs to be saved. For most transfers, this callback gets called
many times and each invoke delivers another chunk of data.

<p>
The first parameter that is passed to your callback function is a string that
contains the raw binary data just received. If you pass the optional <code>userdata</code>
argument, the value you pass in <code>userdata</code> will be passed to your callback function as
a second parameter. The <code>userdata</code> parameter can be of any type.

<p>
The callback function will be passed as much data as possible in all invokes,
but you must not make any assumptions. It may be one byte, it may be
thousands. The maximum amount of body data that will be passed to the write
callback is defined as follows: <code>#CURL_MAX_WRITE_SIZE</code> (the
usual default is 16K). If <code>#CURLOPT_HEADER</code> is enabled, which makes
header data get passed to the write callback, you can get up to
<code>#CURL_MAX_HTTP_HEADER</code> bytes of header data passed into it. This usually
means 100K.

<p>
This function may be called with zero bytes data if the transferred file is
empty.

<p>
Your callback should return the number of bytes actually taken care of. If
that amount differs from the amount passed to your callback function, it'll
signal an error condition to the library. This will cause the transfer to get
aborted and the libcurl function used will return <code>#CURLE_WRITE_ERROR</code>.

<p>
If your write function returns nothing, this will signal success and the transfer
will be continued.

<p>
If your callback function returns <code>#CURL_WRITEFUNC_PAUSE</code> it will cause this
transfer to become paused.  See <a href="easyPause.html">easy:Pause()</a> for further details.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>write_callback</i></dt>
<dd>input value</dd>
<dt><i>userdata</i></dt>
<dd>optional: user data to pass to callback function</dl>
</dd>
<dt class="autodoc"><b>Example</b></dt><dd>
<pre>
Function p_WriteData(data$)
   WriteBytes(1, data$)
EndFunction
e:SetOpt_WriteFunction(p_WriteData)
</pre>
The code above will install a write function that will write all data
it receives to the file using the identifier 1.

</dd></dl>
<hr>
<font size=-2><a href="easySetOpt_WriteFunction_.html" target="_top">Show TOC</a></font>
</body>
</html>