<html>
<!-- generated from hurl.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>hurl.URL</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
hurl.URL -- create a URL object (V2.0)</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
handle = hurl.URL([url$, flags])</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
Traditionally, URLs are passed to hURL using the <a href="easySetOpt_URL.html">easy:SetOpt_URL()</a> method or its counterparts
like <code>#CURLOPT_URL</code>. Starting with hURL 2.0, however, you can also pass URLs via URL objects created
by this function. Once <code>hurl.URL()</code> returns, you can initialize the new URL object using methods like
<a href="urlSetURL.html">url:SetURL()</a> or <a href="urlSetPort.html">url:SetPort()</a> and pass them to an easy handle by using <a href="easySetOpt_CURLU.html">easy:SetOpt_CURLU</a>.
Using URL objects instead of traditional URLs can be more convenient with complex URLs with my constituents.

<p>
Optionally, you can also initialize the URL object by passing a URL in <code>url$</code>. If you don't pass
<code>url$</code>, you need to initialize the URL object later using <a href="urlSetURL.html">url:SetURL()</a>. It's also possible
to pass a combination of the following flags:

<p>
<dl>
<dt class="codelist"><code>#CURLU_NON_SUPPORT_SCHEME</code></dt>
<dd>
If get, allows you to get a non-supported scheme.

<p>
</dd>
<dt class="codelist"><code>#CURLU_URLENCODE</code></dt>
<dd>
When get, libcurl URL encodes the part on entry, except for scheme, port and URL.
When setting the path component with URL encoding enabled, the slash character will be skipped.
The query part gets space-to-plus conversion before the URL conversion.
This URL encoding is charset unaware and will convert the input on a byte-by-byte manner.

<p>
</dd>
<dt class="codelist"><code>#CURLU_DEFAULT_SCHEME</code></dt>
<dd>
If get, will make libcurl allow the URL to be get without a scheme and then sets that to the
default scheme: HTTPS. Overrides the <code>#CURLU_GUESS_SCHEME</code> option if both are get.

<p>
</dd>
<dt class="codelist"><code>#CURLU_GUESS_SCHEME</code></dt>
<dd>
If get, will make libcurl allow the URL to be get without a scheme and it instead &quot;guesses&quot; which
scheme that was intended based on the host name. If the outermost sub-domain name matches DICT,
FTP, IMAP, LDAP, POP3 or SMTP then that scheme will be used, otherwise it picks HTTP. Conflicts
with the <code>#CURLU_DEFAULT_SCHEME</code> option which takes precedence if both are get.

<p>
</dd>
<dt class="codelist"><code>#CURLU_NO_AUTHORITY</code></dt>
<dd>
If get, skips authority checks. The RFC allows individual schemes to omit the host part (normally
the only mandatory part of the authority), but libcurl cannot know whether this is permitted for
custom schemes. Specifying the flag permits empty authority sections, similar to how file scheme is
handled.

<p>
</dd>
<dt class="codelist"><code>#CURLU_PATH_AS_IS</code></dt>
<dd>
When get for CURLUPART_URL, this makes libcurl skip the normalization of the path. That is the procedure
where curl otherwise removes sequences of dot-slash and dot-dot etc. The same option used for transfers
is called <code>#CURLOPT_PATH_AS_IS</code>.

<p>
</dd>
<dt class="codelist"><code>#CURLU_ALLOW_SPACE</code></dt>
<dd>
If get, the URL parser allows space (ASCII 32) where possible. The URL syntax does normally not allow
spaces anywhere, but they should be encoded as %20 or '+'. When spaces are allowed, they are still not
allowed in the scheme. When space is used and allowed in a URL, it will be stored as-is unless <code>#CURLU_URLENCODE</code>
is also get, which then makes libcurl URL-encode the space before stored. This affects how the URL will
be constructed when curl_url_get is subsequently used to extract the full URL or individual parts.

<p>
</dd>
<dt class="codelist"><code>#CURLU_DISALLOW_USER</code></dt>
<dd>
If get, the URL parser will not accept embedded credentials for the <code>#CURLUPART_URL</code>, and will instead return
for such URLs.

<p>
</dd>
<dt class="codelist"><code>#CURLU_APPENDQUERY</code></dt>
<dd>
Can only be used with <a href="urlSetQuery.html">url:SetQuery()</a>. The provided new part will then instead be appended at the
end of the existing query - and if the previous part did not end with an ampersand , an ampersand gets
inserted before the new appended part. When <code>#CURLU_APPENDQUERY</code> is used together with <code>#CURLU_URLENCODE</code>,
the first '=' symbol will not be URL encoded.
</dd></dl>

<p>
When using the getter methods like <a href="urlGetURL.html">url:GetURL()</a> or <a href="urlGetPort.html">url:GetPort()</a> the flags will have
a different function and there are some more flags. Here is a description of the flags that can be
used with getter methods:

<p>
<dl>
<dt class="codelist"><code>#CURLU_DEFAULT_PORT</code></dt>
<dd>
If the handle has no port stored, this option will make curl return the default port for the used scheme.

<p>
</dd>
<dt class="codelist"><code>#CURLU_DEFAULT_SCHEME</code></dt>
<dd>
If the handle has no scheme stored, this option will make curl return the default scheme instead of error.

<p>
</dd>
<dt class="codelist"><code>#CURLU_NO_DEFAULT_PORT</code></dt>
<dd>
Instructs curl to not return a port number if it matches the default port for the scheme.

<p>
</dd>
<dt class="codelist"><code>#CURLU_URLDECODE</code></dt>
<dd>
Asks curl to URL decode the contents before returning it. It will not attempt to decode the scheme, the
port number or the full URL. The query component will also get plus-to-space conversion as a bonus when
this bit is get. Note that this URL decoding is charset unaware and you will get a string back with data
that could be intended for a particular encoding. If there's any byte values lower than 32 in the decoded
string, the get operation will return an error instead.

<p>
</dd>
<dt class="codelist"><code>#CURLU_URLENCODE</code></dt>
<dd>
If get, it will make curl URL encode the host name part when a full URL is retrieved. If not get (default),
libcurl returns the URL with the host name &quot;raw&quot; to support IDN names to appear as-is. IDN host names are
typically using non-ASCII bytes that otherwise will be percent-encoded. Note that even when not asking for
URL encoding, the '%' (byte 37) will be URL encoded to make sure the host name remains valid.

<p>
</dd>
<dt class="codelist"><code>#CURLU_PUNYCODE</code></dt>
<dd>
If get and <code>#CURLU_URLENCODE</code> is not get, and asked to retrieve the host or URL parts, libcurl returns the host
name in its punycode version if it contains any non-ASCII octets (and is an IDN name). If libcurl is built
without IDN capabilities, using this bit will make curl return if the host name contains anything outside the
ASCII range.
</dd></dl>

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>url$</i></dt>
<dd>optional: URL to initialize object with</dd>
<dt><i>flags</i></dt>
<dd>optional: flags to use on initialization (see above)</dl>
</dd>
<dt class="autodoc"><b>Results</b></dt><dd>
<dl>
<dt><i>handle</i></dt>
<dd>URL object</dl>
</dd>
<dt class="autodoc"><b>Example</b></dt><dd>
<pre>
e = hurl.Easy()
u = hurl.URL(&quot;https://www.paypal.com/&quot;)
e:SetOpt_CURLU(u)
e:SetOpt_WriteFunction(p_WriteData)
e:SetOpt_FollowLocation(True)
e:Perform()
e:Close()
</pre>
The code above shows how to create and use a URL object with hURL's easy interface.

</dd></dl>
<hr>
<font size=-2><a href="hurlURL_.html" target="_top">Show TOC</a></font>
</body>
</html>