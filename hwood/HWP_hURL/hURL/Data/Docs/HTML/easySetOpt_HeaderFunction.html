<html>
<!-- generated from hurl.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>easy:SetOpt_HeaderFunction</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
easy:SetOpt_HeaderFunction -- callback that receives header data</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
easy:SetOpt_HeaderFunction(header_callback[, userdata])</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
Pass a callback function. This function gets called by libcurl as soon as it
has received header data. The header callback will be called once for each header and only
complete header lines are passed on to the callback. Parsing headers is very
easy using this.

<p>
The first parameter that is passed to your callback function is a string that
contains the header data just received. If you pass the optional <code>userdata</code>
argument, the value you pass in <code>userdata</code> will be passed to your callback function as
a second parameter. The <code>userdata</code> parameter can be of any type.

<p>
This callback function must return the number of bytes actually taken care of.
If that amount differs from the amount passed in to your function, it'll signal
an error to the library. This will cause the transfer to get aborted and the
libcurl function in progress will return <code>#CURLE_WRITE_ERROR</code>.

<p>
If your header function returns nothing, this will signal success and the transfer
will be continued.

<p>
A complete HTTP header that is passed to this function can be up to
<code>#CURL_MAX_HTTP_HEADER</code> (100K) bytes.

<p>
It's important to note that the callback will be invoked for the headers of
all responses received after initiating a request and not just the final
response. This includes all responses which occur during authentication
negotiation. If you need to operate on only the headers from the final
response, you will need to collect headers in the callback yourself and use
HTTP status lines, for example, to delimit response boundaries.

<p>
When a server sends a chunked encoded transfer, it may contain a trailer. That
trailer is identical to an HTTP header and if such a trailer is received it is
passed to the application using this callback as well. There are several ways
to detect it being a trailer and not an ordinary header: 1) it comes after the
response-body. 2) it comes after the final header line (CR LF) 3) a Trailer:
header among the regular response-headers mention what header(s) to expect in
the trailer.

<p>
For non-HTTP protocols like FTP, POP3, IMAP and SMTP this function will get
called with the server responses to the commands that libcurl sends.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>header_callback</i></dt>
<dd>input value</dd>
<dt><i>userdata</i></dt>
<dd>optional: user data to pass to callback function</dd></dl>
</dd></dl>
<hr>
<font size=-2><a href="easySetOpt_HeaderFunction_.html" target="_top">Show TOC</a></font>
</body>
</html>