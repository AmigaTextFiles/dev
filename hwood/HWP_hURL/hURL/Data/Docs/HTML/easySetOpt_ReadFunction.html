<html>
<!-- generated from hurl.meta by MetaDoc 1.13 (c) by Andreas Falkenhahn -->
<head>
<title>easy:SetOpt_ReadFunction</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.13">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<dl>
<dt class="autodoc"><b>Name</b></dt><dd>
easy:SetOpt_ReadFunction -- read callback for data uploads</dd>
<dt class="autodoc"><b>Synopsis</b></dt><dd>
<pre>
easy:SetOpt_ReadFunction(read_callback[, userdata])</pre>
</dd>
<dt class="autodoc"><b>Function</b></dt><dd>
Pass a callback function. This callback function gets called by libcurl as soon as it needs to read data
in order to send it to the peer - like if you ask it to upload or post data to
the server.

<p>
The first parameter that is passed to your callback function is an integer that
contains the number of bytes that should be read. If you pass the optional <code>userdata</code>
argument, the value you pass in <code>userdata</code> will be passed to your callback function as
a second parameter. The <code>userdata</code> parameter can be of any type.

<p>
Your function must return a string containing the data that has been read.
This may contain less bytes than requested but there must be at least one
byte in the return string or the transfer will be aborted.

<p>
If you stop the current transfer by returning an empty string (i.e before the
server expected it, like when you've said you will upload N bytes and you
upload less than N bytes), you may experience that the server &quot;hangs&quot; waiting
for the rest of the data that won't come.

<p>
The read callback may return <code>#CURL_READFUNC_ABORT</code> to stop the current
operation immediately, resulting in a <code>#CURLE_ABORTED_BY_CALLBACK</code> error
code from the transfer.

<p>
The callback can return <code>#CURL_READFUNC_PAUSE</code> to cause reading from this
connection to pause. See <a href="easyPause.html">easy:Pause()</a> for further details.

<p>
Bugs: when doing TFTP uploads, you must return the exact amount of data
that the callback wants, or it will be considered the final packet by the
server end and the transfer will end there.

<p>
</dd>
<dt class="autodoc"><b>Inputs</b></dt><dd>
<dl>
<dt><i>read_callback</i></dt>
<dd>input value</dd>
<dt><i>userdata</i></dt>
<dd>optional: user data to pass to callback function</dl>
</dd>
<dt class="autodoc"><b>Example</b></dt><dd>
<pre>
Function p_ReadData(len)
   If readlen + len &gt; totallen Then len = totallen - readlen
   If len &gt; 0
      readlen = readlen + len
      Return(ReadBytes(1, len))
   Else
      Return(&quot;&quot;)
   EndIf
EndFunction
readlen = 0
totallen = FileLength(1)
e:SetOpt_ReadFunction(p_ReadData)
</pre>
The code above installs a read function that will read all data from
the file using the identifier 1.

</dd></dl>
<hr>
<font size=-2><a href="easySetOpt_ReadFunction_.html" target="_top">Show TOC</a></font>
</body>
</html>