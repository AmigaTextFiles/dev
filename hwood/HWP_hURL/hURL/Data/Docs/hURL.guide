@DATABASE hURL.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from hurl.meta by MetaDoc 1.13 (c) by Airsoft Softwair"
@$VER: hURL.guide 2.0 (21.04.2023)
@INDEX Reference
@HELP Reference

@NODE Main "hURL Guide"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                                          -= @{B}@{FG highlight}h U R L@{FG text}@{UB} =-

                       The Multi-Protocol Data Transfer Plugin for Hollywood

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 I. General information
 @{" Introduction                    " LINK Introduction}     What is hURL?
 @{" Terms and conditions            " LINK License}     License information
 @{" Requirements                    " LINK Requirements}     What you need to work with it
 @{" Installation                    " LINK Installation}     How to install hURL

 II. About hURL
 @{" Credits                         " LINK Credits}     Who was involved in this project?
 @{" F.A.Q.                          " LINK FAQ}     Frequently asked questions
 @{" Future                          " LINK ToDo}     What is planned for the future?
 @{" History                         " LINK History}     What happened so far?

 III. Usage
 @{" Overview                        " LINK UsageOverview}     Outline of the two different operation modes
 @{" Using the high-level interface  " LINK HighLevelInterface}     The easiest way to use hURL
 @{" Using the low-level interface   " LINK LowLevelInterface}     This gives fine-tuned control over everything

 IV. hURL APIs
 @{" General functions               " LINK HUGeneral}     Base functions offered by hURL
 @{" Easy methods                    " LINK HUEasy}     Methods supported by easy objects
 @{" Form methods                    " LINK HUForm}     Methods supported by form objects
 @{" Mime methods                    " LINK HUMime}     Methods supported by mime objects
 @{" Mime part methods               " LINK HUMimePart}     Methods supported by mime part objects
 @{" Multi methods                   " LINK HUMulti}     Methods supported by multi objects
 @{" Share methods                   " LINK HUShare}     Methods supported by share objects
 @{" URL methods                     " LINK HUURL}     Methods supported by URL objects

 @{" Index                           " LINK Reference}     Quickly find what you are looking for

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 hURL is (C) Copyright © 2018-2023 Andreas Falkenhahn                           All rights reserved
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@ENDNODE
@NODE Introduction "hURL Guide"
@{b}Introduction@{ub}

    hURL is a plugin for Hollywood that allows you to transfer data using many
    different protocols. Based on curl, hURL supports an incredibly wide range
    of transfer protocols, e.g. DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS,
    IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS,
    SMTP, SMTPS, Telnet and TFTP. Furthermore, hURL supports SSL certificates,
    HTTP POST, HTTP PUT, FTP uploading, HTTP form based upload, proxies, HTTP/2,
    cookies, user+password authentication (Basic, Plain, Digest, CRAM-MD5, NTLM,
    Negotiate and Kerberos), file transfer resume, proxy tunneling and more. It
    really is the ultimate data transfer engine for Hollywood, leaving nothing
    to be desired.

    There are two ways of using hURL: There is a high-level interface that can
    directly hook itself into Hollywood's network library, enhancing it with
    hURL functionality like SSL/TLS support. This makes it possible to use
    Hollywood commands like "DownloadFile()" to download files using custom
    protocols that Hollywood itself doesn't support, e.g. SSL/TLS.

    Another way of using hURL is the low-level interface: This interface allows
    you to access the curl API directly from Hollywood scripts. This is
    extremely powerful because it allows you to access hundreds of different
    curl options, making it possible to fine-tune hURL to your specific needs.
    hURL contains over 500 commands to fulfil all your data transfer needs!

    Finally, hURL comes with extensive documentation in various formats like
    PDF, HTML, AmigaGuide, and CHM that contains detailed descriptions about all
    functions and methods offered by the plugin.

    All of this makes hURL the ultimate data transfer tool for Hollywood that
    contains everything you need to send and receive data via almost any
    transfer protocol on the planet.

@ENDNODE

@NODE License "hURL Guide"
@{b}Terms and conditions@{ub}

    hURL is © Copyright 2018-2023 by Andreas Falkenhahn (in the following
    referred to as "the author"). All rights reserved.

    The program is provided "as-is" and the author cannot be made responsible of
    any possible harm done by it. You are using this program absolutely at your
    own risk. No warranties are implied or given by the author.

    This plugin may be freely distributed as long as the following three
    conditions are met:

    1. No modifications must be made to the plugin.
    2. It is not allowed to sell this plugin.
    3. If you want to put this plugin on a coverdisc, you need to ask for
       permission first.

    This software uses curl by Daniel Stenberg. See @{"curl license" LINK LicenseCurl} for details.

    This software uses Lua-cURL by Alexey Melnichuk. See @{"Lua-cURL" LINK LicenseLuaCurl} for details.

    This software uses libssh2. See @{"libssh2 license" LINK LicenseSSH2} for details.

    This product includes software developed by the OpenSSL Project for use in
    the OpenSSL Toolkit (http://www.openssl.org/) See @{"OpenSSL license" LINK LicenseOpenSSL} for
    details.

    Target icon in hURL logo made by Vectors Market from www.flaticon.com is
    licensed by CC 3.0 BY.

    All trademarks are the property of their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "hURL Guide"
@{b}Requirements@{ub}

    - Hollywood 8.0 or better; note that it's recommended to use at least
      Hollywood 9.0 with hURL because only Hollywood 9.0 (or better) allows you
      to take full advantage of hURL's high-level interface
    - macOS: hURL requires at least version 11.0 on arm64 systems, 10.8 on x86
      and x64 systems and 10.4 on PowerPC systems
    - Android: at least Android 6.0 is required
    - AmigaOS 3 and AmigaOS 4: AmiSSL 5 is required
    - AROS: AmiSSL 4 is required
    - MorphOS: at least MorphOS 3.16 is required

@ENDNODE

@NODE Installation "hURL Guide"
@{b}Installation@{ub}

    Installing hURL is straightforward and simple: Just copy the file hurl.hwp
    for the platform of your choice to Hollywood's plugins directory. On all
    systems except on AmigaOS and compatibles, plugins must be stored in a
    directory named Plugins that is in the same directory as the main Hollywood
    program. On AmigaOS and compatible systems, plugins must be installed to
    LIBS:Hollywood instead. On macOS, the Plugins directory must be inside the
    Resources directory of the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources.

    Afterwards merge the contents of the Examples folder with the Examples
    folder that is part of your Hollywood installation. All hURL examples will
    then appear in Hollywood's GUI and you can launch and view them conveniently
    from the Hollywood GUI or IDE.

    On Windows you should also copy the file hURL.chm to the Docs directory of
    your Hollywood installation. Then you will be able to get online help by
    pressing F1 when the cursor is over a hURL function in the Hollywood IDE.

    On Linux and macOS copy the hURL directory that is inside the Docs directory
    of the hURL distribution archive to the Docs directory of your Hollywood
    installation. Note that on macOS the Docs directory is within the
    Hollywood.app application bundle, i.e. in
    Hollywood.app/Contents/Resources/Docs.

@ENDNODE

@NODE Credits "hURL Guide"
@{b}Credits@{ub}

    hURL was written by Andreas Falkenhahn, based on work done by Alexey
    Melnichuk and Daniel Stenberg.

    If you need to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE FAQ "hURL Guide"
@{b}Frequently asked questions@{ub}

    This section covers some frequently asked questions. Please read them first
    before asking on the forum because your problem might have been covered
    here.

    @{b}Q: @{ub}@{b}Is @{ub}@{b}there @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}forum @{ub}@{b}where @{ub}@{b}I @{ub}@{b}can @{ub}@{b}get @{ub}@{b}in @{ub}@{b}touch @{ub}@{b}with @{ub}@{b}other @{ub}@{b}users?@{ub}

    A: Yes, please check out the "Community" section of the official Hollywood
    Portal online at http://www.hollywood-mal.com.


    @{b}Q: @{ub}@{b}Where @{ub}@{b}can @{ub}@{b}I @{ub}@{b}ask @{ub}@{b}for @{ub}@{b}help?@{ub}

    A: There's an active forum at http://forums.hollywood-mal.com. You're welcome
    to join it and ask your question there.


    @{b}Q: @{ub}@{b}I @{ub}@{b}have @{ub}@{b}found @{ub}@{b}a @{ub}@{b}bug.@{ub}

    A: Please post about it in the "Bugs" section of the forum.

@ENDNODE

@NODE ToDo "hURL Guide"
@{b}Future@{ub}

    Here are some things that are on my to do list:

    - add more examples

    Don't hesitate to contact me if hURL lacks a certain feature that is
    important for your project.

@ENDNODE

@NODE History "hURL Guide"
@{b}History@{ub}

    Please read the history bottom-up. Note that the history might list some
    features that were implemented in beta versions and removed later but are
    still mentioned here. This history is a log of the programmer so that he
    can look up what has been done/tried/modified. Things that were implemented
    and removed later are marked with [VOID].

    Version 2.0   (29-Apr-23)
    - Change: Updated documentation
    - Change: Updated inbuilt CA certificates to the latest ones from Mozilla (January 10th, 2023)
    - New [macOS]: Added build for the macOS ARM64 platform which is supported since Hollywood 10
    - New [Linux/x64]: Added separate build for OpenSSL 3 for use with more recent Linux distros
    - Fix: Memory access fault when SFTP authentification failed (reported by Petteri Valli)
    - Fix [Android]: curl's verbose output is now visible in LogCat
    - New [Android]: libssh2 is now supported on Android as well which makes it possible to use the SCP and
      SFTP protocols (among others) with hURL
    - Change [Amiga]: hURL uses the system's root CA certificates now (MOSSYS:Data/SSL/curl-ca-bundle.crt on
      MorphOS and AmiSSL:Certs on the other platforms)
    - New: Added easy:Upkeep() method to perform connection upkeep checks
    - New: Added support for curl's MIME interface; this supersedes the old form interface which is still
      supported by hURL; use easy:MIME() to create a new MIME object and then you can use the following
      methods to work with the MIME object: mime:AddPart(), mime:Easy(), mime:Free(), mimepart:Subparts(),
      mimepart:Data(), mimepart:FileData(), mimepart:Headers(), mimepart:Name(), mimepart:Filename(),
      mimepart:Type() mimepart:Encoder(), mimepart:Free(); after you have initialized your MIME object, you
      can pass it to #CURLOPT_MIMEPOST
    - New: Added support for curl's URL interface; you can use hurl.URL() to construct a URL object and
      then use the following methods to configure the URL object: url:SetFragment(), url:SetHost()
      url:SetOptions(), url:SetPassword(), url:SetPath(), url:SetPort(), url:SetQuery(), url:SetScheme(),
      url:SetURL(), url:SetUser(), url:SetZoneID(), url:GetFragment(), url:GetHost(), url:GetOptions(),
      url:GetPassword(), url:GetPath(), url:GetPort(), url:GetQuery(), url:GetScheme(), url:GetURL(),
      url:GetUser(), url:GetZoneID(), url:Dup(), url:Free(); after you have initialized your URL object
      you can pass it to #CURLOPT_CURLU
    - New: Added #CURLINFO_TOTAL_TIME_T, #CURLINFO_NAMELOOKUP_TIME_T, #CURLINFO_CONNECT_TIME_T,
      #CURLINFO_PRETRANSFER_TIME_T, #CURLINFO_STARTTRANSFER_TIME_T, #CURLINFO_REDIRECT_TIME_T, 
      #CURLINFO_APPCONNECT_TIME_T, #CURLINFO_RETRY_AFTER, #CURLINFO_EFFECTIVE_METHOD, #CURLINFO_PROXY_ERROR,
      #CURLINFO_REFERER, #CURLINFO_CAINFO, #CURLINFO_CAPATH for use with easy:GetInfo()
    - New: Added support for #CURLMOPT_MAX_CONCURRENT_STREAMS for multi objects
    - New: Added support for #CURLOPT_SSH_COMPRESSION, #CURLOPT_TIMEVALUE_LARGE, #CURLOPT_MAXAGE_CONN,
      #CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS, #CURLOPT_HAPROXYPROTOCOL, #CURLOPT_DNS_SHUFFLE_ADDRESSES,
      #CURLOPT_TLS13_CIPHERS, #CURLOPT_DISALLOW_USERNAME_IN_URL, #CURLOPT_DOH_URL, #CURLOPT_UPLOAD_BUFFERSIZE,
      #CURLOPT_UPKEEP_INTERVAL_MS, #CURLOPT_HTTP09_ALLOWED, #CURLOPT_ALTSVC_CTRL, #CURLOPT_ALTSVC, 
      #CURLOPT_SASL_AUTHZID, #CURLOPT_MAIL_RCPT_ALLOWFAILS, #CURLOPT_SSLCERT_BLOB, #CURLOPT_SSLKEY_BLOB,
      #CURLOPT_PROXY_SSLCERT_BLOB, #CURLOPT_PROXY_SSLKEY_BLOB, #CURLOPT_ISSUERCERT_BLOB, 
      #CURLOPT_PROXY_ISSUERCERT, #CURLOPT_PROXY_ISSUERCERT_BLOB, #CURLOPT_SSL_EC_CURVES, #CURLOPT_HSTS_CTRL,
      #CURLOPT_HSTS, #CURLOPT_AWS_SIGV4, #CURLOPT_DOH_SSL_VERIFYPEER, #CURLOPT_DOH_SSL_VERIFYHOST,
      #CURLOPT_DOH_SSL_VERIFYSTATUS, #CURLOPT_CAINFO_BLOB, #CURLOPT_PROXYINFO_CAINFO_BLOB,
      #CURLOPT_MAXLIFETIME_CONN, #CURLOPT_MIME_OPTIONS, #CURLOPT_PROTOCOLS_STR, #CURLOPT_REDIR_PROTOCOLS_STR,
      #CURLOPT_WS_OPTIONS, #CURLOPT_CA_CACHE_TIMEOUT, #CURLOPT_QUICK_EXIT, #CURLOPT_MIMEPOST, #CURLOPT_CURLU,
      #CURLOPT_RESOLVER_START_FUNCTION, #CURLOPT_TRAILERFUNCTION, #CURLOPT_HSTSREADFUNCTION, 
      #CURLOPT_HSTSWRITEFUNCTION, #CURLOPT_PREREQFUNCTION, #CURLOPT_SSH_HOSTKEYFUNCTION; you can set/unset
      these options either using the generic easy:SetOpt() and easy:UnsetOpt() methods or using the specific
      methods like easy:SetOpt_SSH_Compression() or by passing the options in the argument table when creating
      easy handles using hurl.Easy()
    - New [AROS]: Added AROS version of hURL; this requires AmiSSL4 because AmiSSL5 isn't available on AROS yet
    - New [OS3/OS4]: hURL uses AmiSSL 5 instead of AmiSSL 4 now
    - New: Updated to curl 8.0.1 and libssh2 1.10.0
    - Change [MorphOS]: hURL on MorphOS doesn't use AmiSSL any longer but MorphOS' native implementation of
      OpenSSL 3 (openssl3.library); this means that hURL requires MorphOS 3.16 or better now
    - Fix: DownloadFile()'s "PostType" tag wasn't supported by hURL (reported by Petteri Valli)
    - Fix: The "Encoded" tag of the DownloadFile() and UploadFile() commands wasn't handled correctly by hURL
      (reported by Petteri Valli)
    - Fix: The "Fail404" tag of DownloadFile() was ignored by hURL (reported by Anbjorn Myren)

    Version 1.2   (20-Nov-21)
    - Change: Updated documentation
    - Change: Updated inbuilt CA certificates to the latest ones from Mozilla (October 26th, 2021)
    - New: Added some examples for doing some common jobs using the lowlevel interface
    - New [x64-linux/arm-linux]: Added separate builds for OpenSSL 1.1.1 for use on newer Linux versions
      that don't come with OpenSSL 1.0.2 any longer (reported by Niels Schapke)
    - New [Doc]: Added examples for #CURLOPT_HTTPHEADER, #CURLOPT_READFUNCTION and #CURLOPT_WRITEFUNCTION
      (requested by Michael Rupp)
    - New: Added support for Hollywood 9.0's new custom protocol interface; this means that Hollywood's 
      DownloadFile() and UploadFile() commands will now support for all protocols that hURL supports as
      well; this should make things much easier for beginners who are struggling to get started with
      using hURL's functions directly
      
    Version 1.1   (21-Dec-20)
    - Change: Updated documentation
    - Change: Amiga installer will now also copy the plugins for all platforms to Hollywood's linker plugins
      directory so that they can be easily linked to executables (suggested by kas1e)
    - Change: Updated inbuilt CA certificates to the latest ones from Mozilla (December 8th, 2020)
    - New: multi:InfoRead() returns a fourth value now; this return value will contain the easy handle
      that has previously been added to the multi handle (requested by Amile)
    - New: Added support for SFTP and SCP; although hURL 1.0 claimed those to be supported they didn't
      work because hURL was compiled without libssh2; hURL 1.1 now contains libssh2 so SFTP and SCP will
      work as well (reported by Petteri Valli)
    - Fix: All options of type CURLOPT_XXX_LARGE (e.g. CURLOPT_RESUME_FROM_LARGE) were broken on pretty
      much all platforms except 64-bit Windows (reported by Petteri Valli)
    - Fix [MorphOS]: Fixed hURL to be compatible with the 68k version of AmiSSL (reported by Juan Carlos
      Herran Martin and Petteri Valli)
       
    Version 1.0   (31-Mar-19)
    - First Release
@ENDNODE

@NODE UsageOverview "hURL Guide"
@{b}Overview@{ub}

    There are two different ways of using hURL: You can either access the curl
    API directly through a low-level interface or you can use hURL's high-level
    interface which maps some of curl's features to standard Hollywood
    functions.

    Using the high-level interface is really easy and extends Hollywood
    functions like "DownloadFile()" or "UploadFile()" to operate through curl,
    enabling them to use SSL/TLS for example. If you just want to download or
    upload files from/to HTTP(S) and you don't need any fine-tuned control over
    how the transfer is done, the high-level interface is the way to go for you.

    The low-level interface, i.e. accessing curl's API directly, is useful if
    you need more fine-tuned control over the transfer. The low-level interface
    allows you to configure all kinds of options in hURL and makes it possible
    to access all of curl's advanced features, allowing you to meticulously take
    control over how transfers are managed.

@ENDNODE

@NODE HighLevelInterface "hURL Guide"
@{b}Using the high-level interface@{ub}

    Using hURL's high-level interface is really easy. It is mostly used to
    extend Hollywood's "DownloadFile()" and "UploadFile()" commands to support
    SSL/TLS connections, which Hollywood itself doesn't support. To download a
    file using an SSL/TLS connection with hURL through the high-level interface,
    just do the following:

        \@REQUIRE "hurl"
        url$ = "https://www.paypal.com/"
        DownloadFile(url$, {File = "index.html", Adapter = "hurl"})

    The code above will download the main page of https://www.paypal.com/ and
    save it as index.html.

    By passing "hurl" in the "Adapter" tag you tell "DownloadFile()" to let hURL
    handle the download. The same is possible with "UploadFile()" and
    "OpenConnection()". If you get the "Adapter" tag to "hurl" for those
    functions, the connection will automatically be managed by hURL, allowing
    you to use SSL/TLS encryption, for example.

    Hollywood's "DownloadFile()", "UploadFile()", and "OpenConnection()"
    functions also have an "SSL" tag which you can get to TRUE to tell hURL to
    enforce a connection via SSL/TLS. This is normally not necessary when
    passing schemes like https:// or ftps:// but can be useful for custom
    connections.

@ENDNODE

@NODE LowLevelInterface "hURL Guide"
@{b}Using the low-level interface@{ub}

    Using hURL's low-level interface is more difficult than using the high-level
    interface because it allows you to access curl's APIs directly. This means
    that you should first make yourself familiar with curl's API so that you
    know how it is designed and how it can serve your purposes.

    Basically, using a curl API directly involves the following three steps:

    1. Create a curl object handle, e.g. a curl easy handle.
    2. Do something with the handle, e.g. start a transfer.
    3. Destroy the handle.

    For example, to transfer a file using curl's easy interface, you could use
    the following code:

        \@REQUIRE "hurl"

        ; this function will be called whenever there is new data
        Function p_WriteData(data$)
           WriteBytes(1, data$)
        EndFunction

        OpenFile(1, "test.html", #MODE_WRITE)

        ; create easy object and configure it
        e = hurl.Easy({URL = "https://www.paypal.com/", WriteFunction =
                p_WriteData, FollowLocation = True})

        ; transfer data
        e:Perform()

        ; destroy easy object
        e:Close()
        CloseFile(1)

    The code above downloads the page at https://www.paypal.com/ and saves it to
    the file test.html using curl's easy interface. It does so by first creating
    an easy object using @{"hurl.Easy()" LINK hurlEasy} and then setting the options #CURLOPT_URL,
    #CURLOPT_WRITEFUNCTION, and #CURLOPT_FOLLOWLOCATION on that easy object.

    As shown above, curl options can be get directly when creating curl objects.
    Alternatively, you can also create an empty curl object and get the options
    afterwards, like so:

        e = hurl.Easy()
        e:SetOpt_URL("https://www.paypal.com/")
        e:SetOpt_WriteFunction(p_WriteData)
        e:SetOpt_FollowLocation(True)

    This code does the same thing as the code in corresponding section above.
    The only difference is that options aren't get at creation time but after
    creation. Furthermore, you can also get multiple options at once after
    object creation. Here is another alternative for the two code snippets
    above:

        e = hurl.Easy()
        e:SetOpt({URL = "https://www.paypal.com/", WriteFunction = p_WriteData,
                    FollowLocation = True})

    Finally, you can also use @{"easy:SetOpt()" LINK easySetOpt} to get curl options on curl easy
    handles. So there is even a fourth way of doing what the code snippets above
    do. Here it is:

        e = hurl.Easy()
        e:SetOpt(#CURLOPT_URL, "https://www.paypal.com/")
        e:SetOpt(#CURLOPT_WRITEFUNCTION, p_WriteData)
        e:SetOpt(#CURLOPT_FOLLOWLOCATION, True)

    For more information on the function of curl's various options, please refer
    to the following chapters.

@ENDNODE

@NODE hurlEasy "hURL Guide"

   @{b}NAME@{ub}
        hurl.Easy -- start a libcurl easy session

   @{b}SYNOPSIS@{ub}
        handle = hurl.Easy([table])

   @{b}FUNCTION@{ub}
        This function must be the first function to call, and it returns a curl
        easy handle that you must use as input to other functions in the easy
        interface. This call must have a corresponding call to @{"easy:Close()" LINK easyClose} when
        the operation is complete.

        The optional "table" argument allows you to get additional options for
        the easy object. It is possible to use all options here that can also be
        get separately using the @{"easy:SetOpt()" LINK easySetOpt} command. For example, to get
        #CURLOPT_URL, #CURLOPT_VERBOSE, and #CURLOPT_FOLLOWLOCATION at creation
        time, just do the following:

            e = hurl.Easy({URL = "http://www.hollywood-mal.com",
                    Verbose = True, FollowLocation = True})

        This code does the same as:

            e = hurl.Easy()
            e:SetOpt_URL("http://www.hollywood-mal.com")
            e:SetOpt_Verbose(True)
            e:SetOpt_FollowLocation(True)

        Alternatively, you could also use @{"easy:SetOpt()" LINK easySetOpt} to get those options,
        like so:

            e = hurl.Easy()
            e:SetOpt(#CURLOPT_URL, "http://www.hollywood-mal.com")
            e:SetOpt(#CURLOPT_VERBOSE, True)
            e:SetOpt(#CURLOPT_FOLLOWLOCATION, True)

        All of the code snippets above do exactly the same thing.

   @{b}INPUTS@{ub}
        table     optional: table argument containing further options (see
                  above)

   @{b}RESULTS@{ub}
        handle    curl easy handle

@ENDNODE

@NODE hurlForm "hURL Guide"

   @{b}NAME@{ub}
        hurl.Form -- create HTTP multipart/formdata object

   @{b}SYNOPSIS@{ub}
        handle = hurl.Form()

   @{b}FUNCTION@{ub}
        This function creates a HTTP multipart/formdata object and returns it.
        You can then use functions like @{"form:AddFile()" LINK formAddFile}, @{"form:AddBuffer()" LINK formAddBuffer}, or
        @{"form:AddContent()" LINK formAddContent} to fill it with content. This init call must have a
        corresponding call to @{"form:Free()" LINK formFree} when the operation is complete.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    HTTP multipart/formdata object

@ENDNODE

@NODE hurlMulti "hURL Guide"

   @{b}NAME@{ub}
        hurl.Multi -- create a multi handle

   @{b}SYNOPSIS@{ub}
        handle = hurl.Multi([table])

   @{b}FUNCTION@{ub}
        This function returns a curl multi handle to be used as input to all the
        other multi-functions, sometimes referred to as a multi handle in some
        places in the documentation. This init call must have a corresponding
        call to @{"multi:Close()" LINK multiClose} when the operation is complete.

        The optional "table" argument allows you to get additional options for
        the multi object. It is possible to use all options here that can also
        be get separately using the @{"multi:SetOpt()" LINK multiSetOpt} command. See @{"hurl:Easy" LINK hurlEasy} for an
        example.

   @{b}INPUTS@{ub}
        table     optional: table argument containing further options

   @{b}RESULTS@{ub}
        handle    curl multi handle

@ENDNODE

@NODE hurlShare "hURL Guide"

   @{b}NAME@{ub}
        hurl.Share -- create a shared object

   @{b}SYNOPSIS@{ub}
        handle = hurl.Share([table])

   @{b}FUNCTION@{ub}
        This function returns a curl share handle to be used as input to all the
        other share-functions, sometimes referred to as a share handle in some
        places in the documentation. This init call must have a corresponding
        call to @{"share:Close()" LINK shareClose} when all operations using the share are complete.

        This share handle is what you pass to curl using the #CURLOPT_SHARE
        option with @{"easy:SetOpt()" LINK easySetOpt} to make that specific curl handle use the data
        in this share.

        The optional "table" argument allows you to get additional options for
        the share object. It is possible to use all options here that can also
        be get separately using the @{"share:SetOpt()" LINK shareSetOpt} command. See @{"hurl:Easy" LINK hurlEasy} for an
        example.

   @{b}INPUTS@{ub}
        table     optional: table argument containing further options

   @{b}RESULTS@{ub}
        handle    curl share handle

@ENDNODE

@NODE hurlURL "hURL Guide"

   @{b}NAME@{ub}
        hurl.URL -- create a URL object (V2.0)

   @{b}SYNOPSIS@{ub}
        handle = hurl.URL([url$, flags])

   @{b}FUNCTION@{ub}
        Traditionally, URLs are passed to hURL using the @{"easy:SetOpt_URL()" LINK easySetOpt_URL}
        method or its counterparts like #CURLOPT_URL. Starting with hURL 2.0,
        however, you can also pass URLs via URL objects created by this
        function. Once hurl.URL() returns, you can initialize the new URL object
        using methods like @{"url:SetURL()" LINK urlSetURL} or @{"url:SetPort()" LINK urlSetPort} and pass them to an
        easy handle by using @{"easy:SetOpt_CURLU" LINK easySetOpt_CURLU}. Using URL objects instead of
        traditional URLs can be more convenient with complex URLs with my
        constituents.

        Optionally, you can also initialize the URL object by passing a URL in
        "url$". If you don't pass "url$", you need to initialize the URL object
        later using @{"url:SetURL()" LINK urlSetURL}. It's also possible to pass a combination of
        the following flags:

        #CURLU_NON_SUPPORT_SCHEME
                  If get, allows you to get a non-supported scheme.

        #CURLU_URLENCODE
                  When get, libcurl URL encodes the part on entry, except for
                  scheme, port and URL. When setting the path component with URL
                  encoding enabled, the slash character will be skipped. The
                  query part gets space-to-plus conversion before the URL
                  conversion. This URL encoding is charset unaware and will
                  convert the input on a byte-by-byte manner.

        #CURLU_DEFAULT_SCHEME
                  If get, will make libcurl allow the URL to be get without a
                  scheme and then sets that to the default scheme: HTTPS.
                  Overrides the #CURLU_GUESS_SCHEME option if both are get.

        #CURLU_GUESS_SCHEME
                  If get, will make libcurl allow the URL to be get without a
                  scheme and it instead "guesses" which scheme that was intended
                  based on the host name. If the outermost sub-domain name
                  matches DICT, FTP, IMAP, LDAP, POP3 or SMTP then that scheme
                  will be used, otherwise it picks HTTP. Conflicts with the
                  #CURLU_DEFAULT_SCHEME option which takes precedence if both
                  are get.

        #CURLU_NO_AUTHORITY
                  If get, skips authority checks. The RFC allows individual
                  schemes to omit the host part (normally the only mandatory
                  part of the authority), but libcurl cannot know whether this
                  is permitted for custom schemes. Specifying the flag permits
                  empty authority sections, similar to how file scheme is
                  handled.

        #CURLU_PATH_AS_IS
                  When get for CURLUPART_URL, this makes libcurl skip the
                  normalization of the path. That is the procedure where curl
                  otherwise removes sequences of dot-slash and dot-dot etc. The
                  same option used for transfers is called #CURLOPT_PATH_AS_IS.

        #CURLU_ALLOW_SPACE
                  If get, the URL parser allows space (ASCII 32) where possible.
                  The URL syntax does normally not allow spaces anywhere, but
                  they should be encoded as %20 or '+'. When spaces are allowed,
                  they are still not allowed in the scheme. When space is used
                  and allowed in a URL, it will be stored as-is unless
                  #CURLU_URLENCODE is also get, which then makes libcurl
                  URL-encode the space before stored. This affects how the URL
                  will be constructed when curl_url_get is subsequently used to
                  extract the full URL or individual parts.

        #CURLU_DISALLOW_USER
                  If get, the URL parser will not accept embedded credentials
                  for the #CURLUPART_URL, and will instead return for such URLs.

        #CURLU_APPENDQUERY
                  Can only be used with @{"url:SetQuery()" LINK urlSetQuery}. The provided new part
                  will then instead be appended at the end of the existing query
                  - and if the previous part did not end with an ampersand, an
                  ampersand gets inserted before the new appended part. When
                  #CURLU_APPENDQUERY is used together with #CURLU_URLENCODE, the
                  first '=' symbol will not be URL encoded.

        When using the getter methods like @{"url:GetURL()" LINK urlGetURL} or @{"url:GetPort()" LINK urlGetPort} the
        flags will have a different function and there are some more flags. Here
        is a description of the flags that can be used with getter methods:

        #CURLU_DEFAULT_PORT
                  If the handle has no port stored, this option will make curl
                  return the default port for the used scheme.

        #CURLU_DEFAULT_SCHEME
                  If the handle has no scheme stored, this option will make curl
                  return the default scheme instead of error.

        #CURLU_NO_DEFAULT_PORT
                  Instructs curl to not return a port number if it matches the
                  default port for the scheme.

        #CURLU_URLDECODE
                  Asks curl to URL decode the contents before returning it. It
                  will not attempt to decode the scheme, the port number or the
                  full URL. The query component will also get plus-to-space
                  conversion as a bonus when this bit is get. Note that this URL
                  decoding is charset unaware and you will get a string back
                  with data that could be intended for a particular encoding. If
                  there's any byte values lower than 32 in the decoded string,
                  the get operation will return an error instead.

        #CURLU_URLENCODE
                  If get, it will make curl URL encode the host name part when a
                  full URL is retrieved. If not get (default), libcurl returns
                  the URL with the host name "raw" to support IDN names to
                  appear as-is. IDN host names are typically using non-ASCII
                  bytes that otherwise will be percent-encoded. Note that even
                  when not asking for URL encoding, the '%' (byte 37) will be
                  URL encoded to make sure the host name remains valid.

        #CURLU_PUNYCODE
                  If get and #CURLU_URLENCODE is not get, and asked to retrieve
                  the host or URL parts, libcurl returns the host name in its
                  punycode version if it contains any non-ASCII octets (and is
                  an IDN name). If libcurl is built without IDN capabilities,
                  using this bit will make curl return if the host name contains
                  anything outside the ASCII range.

   @{b}INPUTS@{ub}
        url$      optional: URL to initialize object with
        flags     optional: flags to use on initialization (see above)

   @{b}RESULTS@{ub}
        handle    URL object

   @{b}EXAMPLE@{ub}
        e = hurl.Easy()
        u = hurl.URL("https://www.paypal.com/")
        e:SetOpt_CURLU(u)
        e:SetOpt_WriteFunction(p_WriteData)
        e:SetOpt_FollowLocation(True)
        e:Perform()
        e:Close()

        The code above shows how to create and use a URL object with hURL's easy
        interface.

@ENDNODE

@NODE hurlVersion "hURL Guide"

   @{b}NAME@{ub}
        hurl.Version -- returns the libcurl version string

   @{b}SYNOPSIS@{ub}
        v$ = hurl.Version()

   @{b}FUNCTION@{ub}
        Returns a human readable string with the version number of libcurl and
        some of its important components (like OpenSSL version).

        We recommend using @{"hurl.VersionInfo()" LINK hurlVersionInfo}!

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        v$        libcurl version string

@ENDNODE

@NODE hurlVersionInfo "hURL Guide"

   @{b}NAME@{ub}
        hurl.VersionInfo -- returns run-time libcurl version info

   @{b}SYNOPSIS@{ub}
        t = hurl.VersionInfo()

   @{b}FUNCTION@{ub}
        This function returns detailed information about the run-time libcurl
        version.

        The table argument will contain the following fields:

        Version:  An ASCII string for the libcurl version.

        VersionNum:
                  A 24 bit number created like this: <8 bits major number> | <8
                  bits minor number> | <8 bits patch number>. Version 7.9.8 is
                  therefore returned as 0x070908.

        Host:     An ASCII string showing what host information that this
                  libcurl was built for. As discovered by a configure script or
                  get by the build environment.

        Features: This is a table that contains the following boolean fields,
                  all of which are either get to TRUE or FALSE, depending on
                  whether or not the specific feature is available.

                  IPV6:     Supports IPv6
                  Kerberos4:
                            Supports Kerberos V4 (when using FTP)
                  Kerberos5:
                            Supports Kerberos V5 authentication for FTP, IMAP,
                            POP3, SMTP and SOCKSv5 proxy (Added in 7.40.0)
                  SSL:      Supports SSL (HTTPS/FTPS) (Added in 7.10)
                  Libz:     Supports HTTP deflate using libz (Added in 7.10)
                  NTLM:     Supports HTTP NTLM (added in 7.10.6)
                  GSSNegotiate:
                            Supports HTTP GSS-Negotiate (added in 7.10.6)
                  Debug:    libcurl was built with debug capabilities (added in
                            7.10.6)
                  CurlDebug:
                            libcurl was built with memory tracking debug
                            capabilities. This is mainly of interest for libcurl
                            hackers. (added in 7.19.6)
                  AsynchDNS:
                            libcurl was built with support for asynchronous name
                            lookups, which allows more exact timeouts (even on
                            Windows) and less blocking when using the multi
                            interface. (added in 7.10.7)
                  SPNEGO:   libcurl was built with support for SPNEGO
                            authentication (Simple and Protected GSS-API
                            Negotiation Mechanism, defined in RFC 2478.) (added
                            in 7.10.8)
                  LargeFile:
                            libcurl was built with support for large files.
                            (Added in 7.11.1)
                  IDN:      libcurl was built with support for IDNA, domain
                            names with international letters. (Added in 7.12.0)
                  SSPI:     libcurl was built with support for SSPI. This is
                            only available on Windows and makes libcurl use
                            Windows-provided functions for Kerberos, NTLM,
                            SPNEGO and Digest authentication. It also allows
                            libcurl to use the current user credentials without
                            the app having to pass them on. (Added in 7.13.2)
                  GSSAPI:   libcurl was built with support for GSS-API. This
                            makes libcurl use provided functions for Kerberos
                            and SPNEGO authentication. It also allows libcurl to
                            use the current user credentials without the app
                            having to pass them on. (Added in 7.38.0)
                  CONV:     libcurl was built with support for character
                            conversions, as provided by the #CURLOPT_CONV_*
                            callbacks. (Added in 7.15.4)
                  TLSAuthSRP:
                            libcurl was built with support for TLS-SRP. (Added
                            in 7.21.4)
                  NTLM_WB:  libcurl was built with support for NTLM delegation
                            to a winbind helper. (Added in 7.22.0)
                  HTTP2:    libcurl was built with support for HTTP2. (Added in
                            7.33.0)
                  HTTPSProxy:
                            libcurl was built with support for HTTPS-proxy.
                            (Added in 7.52.0)
                  MultiSSL: libcurl was built with multiple SSL backends. (Added
                            in 7.56.0)
                  Brotli:   Supports HTTP Brotli content encoding using
                            libbrotlidec. (Added in 7.57.0)
                  AltSvc:   HTTP Alt-Svc parsing and the associated options.
                            (Added in 7.64.1)
                  HTTP3:    HTTP/3 and QUIC support are built-in. (Added in
                            7.66.0)
                  zstd:     Supports HTTP zstd content encoding using zstd
                            library. (Added in 7.72.0)
                  HSTS:     ibcurl was built with support for HSTS. (HTTP Strict
                            Transport Security) (Added in 7.74.0)

        SSLVersion:
                  An ASCII string for the TLS library name + version used. For
                  example "Schannel", "SecureTransport" or "OpenSSL/1.1.0g".

        SSLVersionNum:
                  Always 0.

        LibzVersion:
                  An ASCII string (there is no numerical version).

        Protocols:
                  This is get to a table of strings, containing the names
                  protocols that libcurl supports (using lowercase letters). The
                  protocol names are the same as would be used in URLs.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        t         table containing information about the libcurl version

@ENDNODE

@NODE easyClose "hURL Guide"

   @{b}NAME@{ub}
        easy:Close -- end a libcurl easy handle

   @{b}SYNOPSIS@{ub}
        easy:Close()

   @{b}FUNCTION@{ub}
        This function must be the last function to call for an easy session. It
        is the opposite of the @{"hurl.Easy()" LINK hurlEasy} function and must be called with the
        same handle as input that a @{"hurl.Easy()" LINK hurlEasy} call returned.

        This might close all connections this handle has used and possibly has
        kept open until now - unless it was attached to a multi handle while
        doing the transfers. Don't call this function if you intend to transfer
        more files, re-using handles is a key to good performance with libcurl.

        Occasionally you may get your progress callback or header callback
        called from within easy:Close() (if previously get for the handle using
        @{"easy:SetOpt()" LINK easySetOpt}). Like if libcurl decides to shut down the connection and
        the protocol is of a kind that requires a command/response sequence
        before disconnect. Examples of such protocols are FTP, POP3 and IMAP.

        Any use of the handle after this function has been called and have
        returned, is illegal. easy:Close() kills the handle and all memory
        associated with it!

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyEscape "hURL Guide"

   @{b}NAME@{ub}
        easy:Escape -- URL encodes the given string

   @{b}SYNOPSIS@{ub}
        e$ = easy:Escape(s$)

   @{b}FUNCTION@{ub}
        This function converts the given input string "s$" to a URL encoded
        string and returns that. All input characters that are not a-z, A-Z,
        0-9, '-', '.', '_' or '~' are converted to their "URL escaped" version
        (%NN where NN is a two-digit hexadecimal number).

        libcurl is typically not aware of, nor does it care about, character
        encodings. easy:Escape() encodes the data byte-by-byte into the URL
        encoded version without knowledge or care for what particular character
        encoding the application or the receiving server may assume that the
        data uses.

        The caller of easy:Escape() must make sure that the data passed in to
        the function is encoded correctly.

   @{b}INPUTS@{ub}
        s$        string to escape

   @{b}RESULTS@{ub}
        e$        escaped string

@ENDNODE

@NODE easyGetInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo -- extract information from a curl handle

   @{b}SYNOPSIS@{ub}
        info = easy:GetInfo(type)

   @{b}FUNCTION@{ub}
        Request internal information from the curl session with this function.
        The "type" argument specifies what information should be retrieved. Use
        this function AFTER a performed transfer if you want to get transfer
        related data.

        The following types are currently supported for "type":

        #CURLINFO_APPCONNECT_TIME
                  Time from start until SSL/SSH handshake completed. See
                  @{"easy:GetInfo_AppConnect_Time" LINK easyGetInfo_AppConnect_Time} for details.
        #CURLINFO_APPCONNECT_TIME_T
                  Time from start until SSL/SSH handshake completed. See
                  @{"easy:GetInfo_AppConnect_Time_t" LINK easyGetInfo_AppConnect_Time_t} for details. (V2.0)
        #CURLINFO_CAINFO
                  Get the default built-in CA certificate path. See
                  @{"easy:GetInfo_CAInfo" LINK easyGetInfo_CAInfo} for details. (V2.0)
        #CURLINFO_CAPATH
                  Get the default built-in CA path string. See
                  @{"easy:GetInfo_CAPath" LINK easyGetInfo_CAPath} for details. (V2.0)
        #CURLINFO_CERTINFO
                  Certificate chain. See @{"easy:GetInfo_CertInfo" LINK easyGetInfo_CertInfo} for details.
        #CURLINFO_CONDITION_UNMET
                  Whether or not a time conditional was met. See
                  @{"easy:GetInfo_Condition_Unmet" LINK easyGetInfo_Condition_Unmet} for details.
        #CURLINFO_CONNECT_TIME
                  Time from start until remote host or proxy completed. See
                  @{"easy:GetInfo_Connect_Time" LINK easyGetInfo_Connect_Time} for details.
        #CURLINFO_CONNECT_TIME_T
                  Time from start until remote host or proxy completed. See
                  @{"easy:GetInfo_Connect_Time_t" LINK easyGetInfo_Connect_Time_t} for details. (V2.0)
        #CURLINFO_CONTENT_LENGTH_DOWNLOAD
                  (Deprecated) Content length from the Content-Length header.
                  See @{"easy:GetInfo_Content_Length_Download" LINK easyGetInfo_Content_Length_Download} for details.
        #CURLINFO_CONTENT_LENGTH_DOWNLOAD_T
                  Content length from the Content-Length header. See
                  @{"easy:GetInfo_Content_Length_Download_t" LINK easyGetInfo_Content_Length_Download_t} for details.
        #CURLINFO_CONTENT_LENGTH_UPLOAD
                  (Deprecated) Upload size. See
                  @{"easy:GetInfo_Content_Length_Upload" LINK easyGetInfo_Content_Length_Upload} for details.
        #CURLINFO_CONTENT_LENGTH_UPLOAD_T
                  Upload size. See @{"easy:GetInfo_Content_Length_Upload_t" LINK easyGetInfo_Content_Length_Upload_t} for
                  details.
        #CURLINFO_CONTENT_TYPE
                  Content type from the Content-Type header. See
                  @{"easy:GetInfo_Content_Type" LINK easyGetInfo_Content_Type} for details.
        #CURLINFO_COOKIELIST
                  List of all known cookies. See @{"easy:GetInfo_CookieList" LINK easyGetInfo_CookieList} for
                  details.
        #CURLINFO_EFFECTIVE_METHOD
                  Last used HTTP method. See @{"easy:GetInfo_Effective_Method" LINK easyGetInfo_Effective_Method} for
                  details. (V2.0)
        #CURLINFO_EFFECTIVE_URL
                  Last used URL. See @{"easy:GetInfo_Effective_URL" LINK easyGetInfo_Effective_URL} for details.
        #CURLINFO_FILETIME
                  Remote time of the retrieved document. See
                  @{"easy:GetInfo_FileTime" LINK easyGetInfo_FileTime} for details.
        #CURLINFO_FTP_ENTRY_PATH
                  The entry path after logging in to an FTP server. See
                  @{"easy:GetInfo_FTP_Entry_Path" LINK easyGetInfo_FTP_Entry_Path} for details.
        #CURLINFO_HEADER_SIZE
                  Number of bytes of all headers received. See
                  @{"easy:GetInfo_Header_Size" LINK easyGetInfo_Header_Size} for details.
        #CURLINFO_HTTP_CONNECTCODE
                  Last proxy CONNECT response code. See
                  @{"easy:GetInfo_HTTP_ConnectCode" LINK easyGetInfo_HTTP_ConnectCode} for details.
        #CURLINFO_HTTP_VERSION
                  The http version used in the connection. See
                  @{"easy:GetInfo_HTTP_Version" LINK easyGetInfo_HTTP_Version} for details.
        #CURLINFO_HTTPAUTH_AVAIL
                  Available HTTP authentication methods. See
                  @{"easy:GetInfo_HTTPAuth_Avail" LINK easyGetInfo_HTTPAuth_Avail} for details.
        #CURLINFO_LASTSOCKET
                  Last socket used. See @{"easy:GetInfo_LastSocket" LINK easyGetInfo_LastSocket} for details.
        #CURLINFO_LOCAL_IP
                  Local-end IP address of last connection. See
                  @{"easy:GetInfo_Local_IP" LINK easyGetInfo_Local_IP} for details.
        #CURLINFO_LOCAL_PORT
                  Local-end port of last connection. See @{"easy:GetInfo_Local_Port" LINK easyGetInfo_Local_Port}
                  for details.
        #CURLINFO_NAMELOOKUP_TIME
                  Time from start until name resolving completed. See
                  @{"easy:GetInfo_NameLookup_Time" LINK easyGetInfo_NameLookup_Time} for details.
        #CURLINFO_NAMELOOKUP_TIME_T
                  Time from start until name resolving completed. See
                  @{"easy:GetInfo_NameLookup_Time_t" LINK easyGetInfo_NameLookup_Time_t} for details. (V2.0)
        #CURLINFO_NUM_CONNECTS
                  Number of new successful connections used for previous
                  transfer. See @{"easy:GetInfo_Num_Connects" LINK easyGetInfo_Num_Connects} for details.
        #CURLINFO_OS_ERRNO
                  The errno from the last failure to connect. See
                  @{"easy:GetInfo_OS_ErrNo" LINK easyGetInfo_OS_ErrNo} for details.
        #CURLINFO_PRETRANSFER_TIME
                  Time from start until just before the transfer begins. See
                  @{"easy:GetInfo_PreTransfer_Time" LINK easyGetInfo_PreTransfer_Time} for details.
        #CURLINFO_PRETRANSFER_TIME_T
                  Time from start until just before the transfer begins. See
                  @{"easy:GetInfo_PreTransfer_Time_t" LINK easyGetInfo_PreTransfer_Time_t} for details. (V2.0)
        #CURLINFO_PRIMARY_IP
                  IP address of the last connection. See @{"easy:GetInfo_Primary_IP" LINK easyGetInfo_Primary_IP}
                  for details.
        #CURLINFO_PRIMARY_PORT
                  Port of the last connection. See @{"easy:GetInfo_Primary_Port" LINK easyGetInfo_Primary_Port} for
                  details.
        #CURLINFO_PROTOCOL
                  The protocol used for the connection. See
                  @{"easy:GetInfo_Protocol" LINK easyGetInfo_Protocol} for details.
        #CURLINFO_PROXY_ERROR
                  Detailed proxy error. See @{"easy:GetInfo_Proxy_Error" LINK easyGetInfo_Proxy_Error} for
                  details. (V2.0)
        #CURLINFO_PROXY_SSL_VERIFYRESULT
                  Proxy certificate verification result. See
                  @{"easy:GetInfo_Proxy_SSL_VerifyResult" LINK easyGetInfo_Proxy_SSL_VerifyResult} for details.
        #CURLINFO_PROXYAUTH_AVAIL
                  Available HTTP proxy authentication methods. See
                  @{"easy:GetInfo_ProxyAuth_Avail" LINK easyGetInfo_ProxyAuth_Avail} for details.
        #CURLINFO_REDIRECT_COUNT
                  Total number of redirects that were followed. See
                  @{"easy:GetInfo_Redirect_Count" LINK easyGetInfo_Redirect_Count} for details.
        #CURLINFO_REDIRECT_TIME
                  Time taken for all redirect steps before the final transfer.
                  See @{"easy:GetInfo_Redirect_Time" LINK easyGetInfo_Redirect_Time} for details.
        #CURLINFO_REDIRECT_TIME_T
                  Time taken for all redirect steps before the final transfer.
                  See @{"easy:GetInfo_Redirect_Time_t" LINK easyGetInfo_Redirect_Time_t} for details. (V2.0)
        #CURLINFO_REDIRECT_URL
                  URL a redirect would take you to, had you enabled redirects.
                  See @{"easy:GetInfo_Redirect_URL" LINK easyGetInfo_Redirect_URL} for details.
        #CURLINFO_REFERER
                  Referrer header. See @{"easy:GetInfo_Referer" LINK easyGetInfo_Referer} for details. (V2.0)
        #CURLINFO_REQUEST_SIZE
                  Number of bytes sent in the issued HTTP requests. See
                  @{"easy:GetInfo_Request_Size" LINK easyGetInfo_Request_Size} for details.
        #CURLINFO_RESPONSE_CODE
                  Last received response code. See @{"easy:GetInfo_Response_Code" LINK easyGetInfo_Response_Code}
                  for details.
        #CURLINFO_RETRY_AFTER
                  The value from the from the Retry-After header. See
                  @{"easy:GetInfo_Retry_After" LINK easyGetInfo_Retry_After} for details. (V2.0)
        #CURLINFO_RTSP_CLIENT_CSEQ
                  RTSP CSeq that will next be used. See
                  @{"easy:GetInfo_RTSP_Client_CSeq" LINK easyGetInfo_RTSP_Client_CSeq} for details.
        #CURLINFO_RTSP_CSEQ_RECV
                  RTSP CSeq last received. See @{"easy:GetInfo_RTSP_CSeq_Recv" LINK easyGetInfo_RTSP_CSeq_Recv} for
                  details.
        #CURLINFO_RTSP_SERVER_CSEQ
                  RTSP CSeq that will next be expected. See
                  @{"easy:GetInfo_RTSP_Server_CSeq" LINK easyGetInfo_RTSP_Server_CSeq} for details.
        #CURLINFO_RTSP_SESSION_ID
                  RTSP session ID. See @{"easy:GetInfo_RTSP_Session_ID" LINK easyGetInfo_RTSP_Session_ID} for details.
        #CURLINFO_SCHEME
                  The scheme used for the connection. See @{"easy:GetInfo_Scheme" LINK easyGetInfo_Scheme}
                  for details.
        #CURLINFO_SIZE_DOWNLOAD
                  (Deprecated) Number of bytes downloaded. See
                  @{"easy:GetInfo_Size_Download" LINK easyGetInfo_Size_Download} for details.
        #CURLINFO_SIZE_DOWNLOAD_T
                  Number of bytes downloaded. See @{"easy:GetInfo_Size_Download_t" LINK easyGetInfo_Size_Download_t}
                  for details.
        #CURLINFO_SIZE_UPLOAD
                  (Deprecated) Number of bytes uploaded. See
                  @{"easy:GetInfo_Size_Upload" LINK easyGetInfo_Size_Upload} for details.
        #CURLINFO_SIZE_UPLOAD_T
                  Number of bytes uploaded. See @{"easy:GetInfo_Size_Upload_t" LINK easyGetInfo_Size_Upload_t} for
                  details.
        #CURLINFO_SPEED_DOWNLOAD
                  (Deprecated) Average download speed. See
                  @{"easy:GetInfo_Speed_Download" LINK easyGetInfo_Speed_Download} for details.
        #CURLINFO_SPEED_DOWNLOAD_T
                  Average download speed. See @{"easy:GetInfo_Speed_Download_t" LINK easyGetInfo_Speed_Download_t} for
                  details.
        #CURLINFO_SPEED_UPLOAD
                  (Deprecated) Average upload speed. See
                  @{"easy:GetInfo_Speed_Upload" LINK easyGetInfo_Speed_Upload} for details.
        #CURLINFO_SPEED_UPLOAD_T
                  Average upload speed. See @{"easy:GetInfo_Speed_Upload_t" LINK easyGetInfo_Speed_Upload_t} for
                  details.
        #CURLINFO_SSL_ENGINES
                  A list of OpenSSL crypto engines. See @{"easy:GetInfo_SSL_Engines" LINK easyGetInfo_SSL_Engines}
                  for details.
        #CURLINFO_SSL_VERIFYRESULT
                  Certificate verification result. See
                  @{"easy:GetInfo_SSL_VerifyResult" LINK easyGetInfo_SSL_VerifyResult} for details.
        #CURLINFO_STARTTRANSFER_TIME
                  Time from start until just when the first byte is received.
                  See @{"easy:GetInfo_StartTransfer_Time" LINK easyGetInfo_StartTransfer_Time} for details.
        #CURLINFO_STARTTRANSFER_TIME_T
                  Time from start until just when the first byte is received.
                  See @{"easy:GetInfo_StartTransfer_Time_t" LINK easyGetInfo_StartTransfer_Time_t} for details. (V2.0)
        #CURLINFO_TOTAL_TIME
                  Total time of previous transfer. See @{"easy:GetInfo_Total_Time" LINK easyGetInfo_Total_Time}
                  for details.
        #CURLINFO_TOTAL_TIME_T
                  Total time of previous transfer. See @{"easy:GetInfo_Total_Time_t" LINK easyGetInfo_Total_Time_t}
                  for details. (V2.0)

   @{b}INPUTS@{ub}
        type      type of information to retrieve

   @{b}RESULTS@{ub}
        info      output value

@ENDNODE

@NODE easyGetInfo_AppConnect_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_AppConnect_Time -- get the time until the SSL/SSH handshake is completed

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_AppConnect_Time()

   @{b}FUNCTION@{ub}
        Returns the time, in seconds, it took from the start until the SSL/SSH
        connect/handshake to the remote host was completed. This time is most
        often very near to the #CURLINFO_PRETRANSFER_TIME time, except for cases
        such as HTTP pipelining where the pretransfer time can be delayed due to
        waits in line for the pipeline and more.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_AppConnect_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_AppConnect_Time_t -- get the time until the SSL/SSH handshake is completed (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_AppConnect_Time_t()

   @{b}FUNCTION@{ub}
        Returns the time, in microseconds, it took from the start until the
        SSL/SSH connect/handshake to the remote host was completed. This time is
        most often close to the #CURLINFO_PRETRANSFER_TIME_T time, except for
        cases such as HTTP pipelining where the pretransfer time can be delayed
        due to waits in line for the pipeline and more.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_CAInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_CAInfo -- get the default built-in CA certificate path (V2.0)

   @{b}SYNOPSIS@{ub}
        path = easy:GetInfo_CAInfo()

   @{b}FUNCTION@{ub}
        Returns a string holding the default built-in path used for the
        #CURLOPT_CAINFO option unless get by the user.

        Note that in a situation where libcurl has been built to support
        multiple TLS libraries, this option might return a string even if the
        specific TLS library currently get to be used does not support
        #CURLOPT_CAINFO.

        This is a path identifying a single file containing CA certificates.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        path      output value

@ENDNODE

@NODE easyGetInfo_CAPath "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_CAPath -- get the default built-in CA path string (V2.0)

   @{b}SYNOPSIS@{ub}
        path = easy:GetInfo_CAPath()

   @{b}FUNCTION@{ub}
        Returns a string holding the default built-in path used for the
        #CURLOPT_CAPATH option unless get by the user.

        Note that in a situation where libcurl has been built to support
        multiple TLS libraries, this option might return a string even if the
        specific TLS library currently get to be used does not support
        #CURLOPT_CAPATH.

        This is a path identifying a directory.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        path      output value

@ENDNODE

@NODE easyGetInfo_CertInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_CertInfo -- get the TLS certificate chain

   @{b}SYNOPSIS@{ub}
        chainp = easy:GetInfo_CertInfo()

   @{b}FUNCTION@{ub}
        Returns a table that holds a number of string lists with info about the
        certificate chain, assuming you had #CURLOPT_CERTINFO enabled when the
        request was made. The table reports how many certs it found and then you
        can extract info for each of those certs by following the string lists.
        The info chain is provided in a series of data in the format
        "name:content" where the content is for the specific named data.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        chainp    output value

@ENDNODE

@NODE easyGetInfo_Condition_Unmet "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Condition_Unmet -- get info on unmet time conditional

   @{b}SYNOPSIS@{ub}
        unmet = easy:GetInfo_Condition_Unmet()

   @{b}FUNCTION@{ub}
        Returns the number 1 if the condition provided in the previous request
        didn't match (see #CURLOPT_TIMECONDITION). Alas, if this returns a 1 you
        know that the reason you didn't get data in return is because it didn't
        fulfill the condition. Returns zero if the condition instead was met.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        unmet     output value

@ENDNODE

@NODE easyGetInfo_Connect_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Connect_Time -- get the time until connect

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Connect_Time()

   @{b}FUNCTION@{ub}
        Returns the total time in seconds from the start until the connection to
        the remote host (or proxy) was completed.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Connect_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Connect_Time_t -- get the time until connect (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Connect_Time_t()

   @{b}FUNCTION@{ub}
        Returns the total time in microseconds from the start until the
        connection to the remote host (or proxy) was completed.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Content_Length_Download "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Content_Length_Download -- get content-length of download

   @{b}SYNOPSIS@{ub}
        content_length = easy:GetInfo_Content_Length_Download()

   @{b}FUNCTION@{ub}
        Returns the content-length of the download. This is the value read from
        the Content-Length: field. Since 7.19.4, this returns -1 if the size
        isn't known.

        #CURLINFO_CONTENT_LENGTH_DOWNLOAD_T is a newer replacement that returns
        a more sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        content_length
                  output value

@ENDNODE

@NODE easyGetInfo_Content_Length_Download_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Content_Length_Download_t -- get content-length of download

   @{b}SYNOPSIS@{ub}
        content_length = easy:GetInfo_Content_Length_Download_t()

   @{b}FUNCTION@{ub}
        Returns the content-length of the download. This is the value read from
        the Content-Length: field. Stores -1 if the size isn't known.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        content_length
                  output value

@ENDNODE

@NODE easyGetInfo_Content_Length_Upload "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Content_Length_Upload -- get the specified size of the upload

   @{b}SYNOPSIS@{ub}
        content_length = easy:GetInfo_Content_Length_Upload()

   @{b}FUNCTION@{ub}
        Returns the specified size of the upload. Since 7.19.4, this returns -1
        if the size isn't known.

        #CURLINFO_CONTENT_LENGTH_UPLOAD_T is a newer replacement that returns a
        more sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        content_length
                  output value

@ENDNODE

@NODE easyGetInfo_Content_Length_Upload_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Content_Length_Upload_t -- get the specified size of the upload

   @{b}SYNOPSIS@{ub}
        content_length = easy:GetInfo_Content_Length_Upload_t()

   @{b}FUNCTION@{ub}
        Returns the specified size of the upload. Returns -1 if the size isn't
        known.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        content_length
                  output value

@ENDNODE

@NODE easyGetInfo_Content_Type "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Content_Type -- get Content-Type

   @{b}SYNOPSIS@{ub}
        ct = easy:GetInfo_Content_Type()

   @{b}FUNCTION@{ub}
        Returns the content-type of the downloaded object. This is the value
        read from the Content-Type: field. If you get Nil, it means that the
        server didn't send a valid Content-Type header or that the protocol used
        doesn't support this.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ct        output value

@ENDNODE

@NODE easyGetInfo_CookieList "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_CookieList -- get all known cookies

   @{b}SYNOPSIS@{ub}
        cookies = easy:GetInfo_CookieList()

   @{b}FUNCTION@{ub}
        Returns a list of all cookies curl knows (expired ones, too). If there
        are no cookies (cookies for the handle have not been enabled or simply
        none have been received) Nil will be returned.

        Since 7.43.0 cookies that were imported in the Set-Cookie format without
        a domain name are not exported by this option.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cookies   output value

@ENDNODE

@NODE easyGetInfo_Effective_Method "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Effective_Method -- get the last used HTTP method (V2.0)

   @{b}SYNOPSIS@{ub}
        methodp = easy:GetInfo_Effective_Method()

   @{b}FUNCTION@{ub}
        Returns a string containing the last used effective HTTP method.

        In cases when you have asked libcurl to follow redirects, the method may
        not be the same method the first request would use.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        methodp   output value

@ENDNODE

@NODE easyGetInfo_Effective_URL "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Effective_URL -- get the last used URL

   @{b}SYNOPSIS@{ub}
        urlp = easy:GetInfo_Effective_URL()

   @{b}FUNCTION@{ub}
        Returns the last used effective URL.

        In cases when you've asked libcurl to follow redirects, it may very well
        not be the same value you get with #CURLOPT_URL.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        urlp      output value

@ENDNODE

@NODE easyGetInfo_FileTime "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_FileTime -- get the remote time of the retrieved document

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_FileTime()

   @{b}FUNCTION@{ub}
        Returns the remote time of the retrieved document (in number of seconds
        since 1 jan 1970 in the GMT/UTC time zone). If you get -1, it can be
        because of many reasons (it might be unknown, the server might hide it
        or the server doesn't support the command that tells document time etc)
        and the time of the document is unknown.

        You must tell libcurl to collect this information before the transfer is
        made, by using the #CURLOPT_FILETIME option to @{"easy:SetOpt()" LINK easySetOpt} or you will
        unconditionally get a -1 back.

        Consider using #CURLINFO_FILETIME_T to be able to extract dates beyond
        the year 2038 on systems using 32 bit longs.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_FTP_Entry_Path "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_FTP_Entry_Path -- get entry path in FTP server

   @{b}SYNOPSIS@{ub}
        path = easy:GetInfo_FTP_Entry_Path()

   @{b}FUNCTION@{ub}
        Returns a string holding the path of the entry path. That is the initial
        path libcurl ended up in when logging on to the remote FTP server. This
        returns Nil if something is wrong.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        path      output value

@ENDNODE

@NODE easyGetInfo_Header_Size "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Header_Size -- get size of retrieved headers

   @{b}SYNOPSIS@{ub}
        sizep = easy:GetInfo_Header_Size()

   @{b}FUNCTION@{ub}
        Returns the total size of all the headers received. Measured in number
        of bytes.

        The total includes the size of any received headers suppressed by
        #CURLOPT_SUPPRESS_CONNECT_HEADERS.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        sizep     output value

@ENDNODE

@NODE easyGetInfo_HTTPAuth_Avail "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_HTTPAuth_Avail -- get available HTTP authentication methods

   @{b}SYNOPSIS@{ub}
        authp = easy:GetInfo_HTTPAuth_Avail()

   @{b}FUNCTION@{ub}
        Returns a bitmask indicating the authentication method(s) available
        according to the previous response. The meaning of the bits is explained
        in the #CURLOPT_HTTPAUTH option for @{"easy:SetOpt()" LINK easySetOpt}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        authp     output value

@ENDNODE

@NODE easyGetInfo_HTTP_ConnectCode "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_HTTP_ConnectCode -- get the CONNECT response code

   @{b}SYNOPSIS@{ub}
        p = easy:GetInfo_HTTP_ConnectCode()

   @{b}FUNCTION@{ub}
        Returns the last received HTTP proxy response code to a "CONNECT"
        request. The returned value will be zero if no such response code was
        available.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        p         output value

@ENDNODE

@NODE easyGetInfo_HTTP_Version "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_HTTP_Version -- get the http version used in the connection

   @{b}SYNOPSIS@{ub}
        p = easy:GetInfo_HTTP_Version()

   @{b}FUNCTION@{ub}
        Returns the version used in the last http connection. The returned value
        will be #CURL_HTTP_VERSION_1_0, #CURL_HTTP_VERSION_1_1, or
        #CURL_HTTP_VERSION_2_0, or 0 if the version can't be determined.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        p         output value

@ENDNODE

@NODE easyGetInfo_LastSocket "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_LastSocket -- get the last socket used

   @{b}SYNOPSIS@{ub}
        socket = easy:GetInfo_LastSocket()

   @{b}FUNCTION@{ub}
        Deprecated since 7.45.0. Use #CURLINFO_ACTIVESOCKET instead.

        Returns the last socket used by this curl session. If the socket is no
        longer valid, -1 is returned. When you finish working with the socket,
        you must call @{"easy:Close()" LINK easyClose} as usual and let libcurl close the socket and
        cleanup other resources associated with the handle. This is typically
        used in combination with #CURLOPT_CONNECT_ONLY.

        NOTE: this API is deprecated since it is not working on win64 where the
        SOCKET type is 64 bits large while its 'long' is 32 bits. Use the
        #CURLINFO_ACTIVESOCKET instead, if possible.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        socket    output value

@ENDNODE

@NODE easyGetInfo_Local_IP "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Local_IP -- get local IP address of last connection

   @{b}SYNOPSIS@{ub}
        ip = easy:GetInfo_Local_IP()

   @{b}FUNCTION@{ub}
        Returns a string holding the IP address of the local end of most recent
        connection done with this curl handle. This string may be IPv6 when that
        is enabled.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ip        output value

@ENDNODE

@NODE easyGetInfo_Local_Port "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Local_Port -- get the latest local port number

   @{b}SYNOPSIS@{ub}
        portp = easy:GetInfo_Local_Port()

   @{b}FUNCTION@{ub}
        Returns the local port number of the most recent connection done with
        this curl handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        portp     output value

@ENDNODE

@NODE easyGetInfo_NameLookup_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_NameLookup_Time -- get the name lookup time

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_NameLookup_Time()

   @{b}FUNCTION@{ub}
        Returns the total time in seconds from the start until the name
        resolving was completed.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_NameLookup_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_NameLookup_Time_t -- get the name lookup time in microseconds (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_NameLookup_Time_t()

   @{b}FUNCTION@{ub}
        Returns the total time in microseconds from the start until the name
        resolving was completed.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Num_Connects "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Num_Connects -- get number of created connections

   @{b}SYNOPSIS@{ub}
        nump = easy:GetInfo_Num_Connects()

   @{b}FUNCTION@{ub}
        Returns how many new connections libcurl had to create to achieve the
        previous transfer (only the successful connects are counted). Combined
        with #CURLINFO_REDIRECT_COUNT you are able to know how many times
        libcurl successfully reused existing connection(s) or not. See the
        connection options of @{"easy:SetOpt()" LINK easySetOpt} to see how libcurl tries to make
        persistent connections to save time.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        nump      output value

@ENDNODE

@NODE easyGetInfo_OS_ErrNo "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_OS_ErrNo -- get errno number from last connect failure

   @{b}SYNOPSIS@{ub}
        errnop = easy:GetInfo_OS_ErrNo()

   @{b}FUNCTION@{ub}
        Returns the errno variable from a connect failure. Note that the value
        is only get on failure, it is not reset upon a successful operation. The
        number is OS and system specific.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        errnop    output value

@ENDNODE

@NODE easyGetInfo_PreTransfer_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_PreTransfer_Time -- get the time until the file transfer start

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_PreTransfer_Time()

   @{b}FUNCTION@{ub}
        Returns the time, in seconds, it took from the start until the file
        transfer is just about to begin. This includes all pre-transfer commands
        and negotiations that are specific to the particular protocol(s)
        involved. It does not involve the sending of the protocol- specific
        request that triggers a transfer.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_PreTransfer_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_PreTransfer_Time_t -- get the time until the file transfer start (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_PreTransfer_Time_t()

   @{b}FUNCTION@{ub}
        Returns the time, in microseconds, it took from the start until the file
        transfer is just about to begin. This includes all pre-transfer commands
        and negotiations that are specific to the particular protocol(s)
        involved. It does not involve the sending of the protocol- specific
        request that triggers a transfer.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Primary_IP "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Primary_IP -- get IP address of last connection

   @{b}SYNOPSIS@{ub}
        ip = easy:GetInfo_Primary_IP()

   @{b}FUNCTION@{ub}
        Returns a string holding the IP address of the most recent connection
        done with this curl handle. This string may be IPv6 when that is
        enabled.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ip        output value

@ENDNODE

@NODE easyGetInfo_Primary_Port "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Primary_Port -- get the latest destination port number

   @{b}SYNOPSIS@{ub}
        portp = easy:GetInfo_Primary_Port()

   @{b}FUNCTION@{ub}
        Returns the destination port of the most recent connection done with
        this curl handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        portp     output value

@ENDNODE

@NODE easyGetInfo_Protocol "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Protocol -- get the protocol used in the connection

   @{b}SYNOPSIS@{ub}
        p = easy:GetInfo_Protocol()

   @{b}FUNCTION@{ub}
        Returns the version used in the last http connection. The returned value
        will be exactly one of the #CURLPROTO_XXX values:

            #CURLPROTO_DICT
            #CURLPROTO_FILE
            #CURLPROTO_FTP
            #CURLPROTO_FTPS
            #CURLPROTO_GOPHER
            #CURLPROTO_HTTP
            #CURLPROTO_HTTPS
            #CURLPROTO_IMAP
            #CURLPROTO_IMAPS
            #CURLPROTO_LDAP
            #CURLPROTO_LDAPS
            #CURLPROTO_POP3
            #CURLPROTO_POP3S
            #CURLPROTO_RTMP
            #CURLPROTO_RTMPE
            #CURLPROTO_RTMPS
            #CURLPROTO_RTMPT
            #CURLPROTO_RTMPTE
            #CURLPROTO_RTMPTS
            #CURLPROTO_RTSP
            #CURLPROTO_SCP
            #CURLPROTO_SFTP
            #CURLPROTO_SMB
            #CURLPROTO_SMBS
            #CURLPROTO_SMTP
            #CURLPROTO_SMTPS
            #CURLPROTO_TELNET
            #CURLPROTO_TFTP

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        p         output value

@ENDNODE

@NODE easyGetInfo_ProxyAuth_Avail "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_ProxyAuth_Avail -- get available HTTP proxy authentication methods

   @{b}SYNOPSIS@{ub}
        authp = easy:GetInfo_ProxyAuth_Avail()

   @{b}FUNCTION@{ub}
        Returns a bitmask indicating the authentication method(s) available
        according to the previous response. The meaning of the bits is explained
        in the #CURLOPT_PROXYAUTH option for @{"easy:SetOpt()" LINK easySetOpt}.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        authp     output value

@ENDNODE

@NODE easyGetInfo_Proxy_Error "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Proxy_Error -- get the detailed (SOCKS) proxy error (V2.0)

   @{b}SYNOPSIS@{ub}
        detail = easy:GetInfo_Proxy_Error()

   @{b}FUNCTION@{ub}
        Returns a detailed error code when the most recent transfer returned a
        #CURLE_PROXY error.

        The error code will be zero (#CURLPX_OK) if no response code was
        available.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        detail    output value

@ENDNODE

@NODE easyGetInfo_Proxy_SSL_VerifyResult "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Proxy_SSL_VerifyResult -- get the result of the proxy certificate verification

   @{b}SYNOPSIS@{ub}
        result = easy:GetInfo_Proxy_SSL_VerifyResult()

   @{b}FUNCTION@{ub}
        Returns the result of the certificate verification that was requested
        (using the #CURLOPT_PROXY_SSL_VERIFYPEER option. This is only used for
        HTTPS proxies.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        result    output value

@ENDNODE

@NODE easyGetInfo_Redirect_Count "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Redirect_Count -- get the number of redirects

   @{b}SYNOPSIS@{ub}
        countp = easy:GetInfo_Redirect_Count()

   @{b}FUNCTION@{ub}
        Returns the total number of redirections that were actually followed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        countp    output value

@ENDNODE

@NODE easyGetInfo_Redirect_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Redirect_Time -- get the time for all redirection steps

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Redirect_Time()

   @{b}FUNCTION@{ub}
        Returns the total time, in seconds, it took for all redirection steps
        include name lookup, connect, pretransfer and transfer before final
        transaction was started. #CURLINFO_REDIRECT_TIME contains the complete
        execution time for multiple redirections.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Redirect_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Redirect_Time_t -- get the time for all redirection steps (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Redirect_Time_t()

   @{b}FUNCTION@{ub}
        Returns the total time, in microseconds, it took for all redirection
        steps include name lookup, connect, pretransfer and transfer before
        final transaction was started. #CURLINFO_REDIRECT_TIME_T contains the
        complete execution time for multiple redirections.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Redirect_URL "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Redirect_URL -- get the URL a redirect would go to

   @{b}SYNOPSIS@{ub}
        urlp = easy:GetInfo_Redirect_URL()

   @{b}FUNCTION@{ub}
        Returns the URL a redirect would take you to if you would enable
        #CURLOPT_FOLLOWLOCATION. This can come very handy if you think using the
        built-in libcurl redirect logic isn't good enough for you but you would
        still prefer to avoid implementing all the magic of figuring out the new
        URL.

        This URL is also get if the #CURLOPT_MAXREDIRS limit prevented a
        redirect to happen (since 7.54.1).

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        urlp      output value

@ENDNODE

@NODE easyGetInfo_Referer "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Referer -- get the referrer header (V2.0)

   @{b}SYNOPSIS@{ub}
        hdrp = easy:GetInfo_Referer()

   @{b}FUNCTION@{ub}
        Returns the referrer header.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        hdrp      output value

@ENDNODE

@NODE easyGetInfo_Request_Size "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Request_Size -- get size of sent request

   @{b}SYNOPSIS@{ub}
        sizep = easy:GetInfo_Request_Size()

   @{b}FUNCTION@{ub}
        Returns the total size of the issued requests. This is so far only for
        HTTP requests. Note that this may be more than one request if
        #CURLOPT_FOLLOWLOCATION is enabled.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        sizep     output value

@ENDNODE

@NODE easyGetInfo_Response_Code "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Response_Code -- get the last response code

   @{b}SYNOPSIS@{ub}
        codep = easy:GetInfo_Response_Code()

   @{b}FUNCTION@{ub}
        Returns the last received HTTP, FTP or SMTP response code. This option
        was previously known as #CURLINFO_HTTP_CODE in libcurl 7.10.7 and
        earlier. The stored value will be zero if no server response code has
        been received. Note that a proxy's CONNECT response should be read with
        #CURLINFO_HTTP_CONNECTCODE and not this.

        Support for SMTP responses added in 7.25.0.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        codep     output value

@ENDNODE

@NODE easyGetInfo_Retry_After "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Retry_After -- returns the Retry-After retry delay (V2.0)

   @{b}SYNOPSIS@{ub}
        retry = easy:GetInfo_Retry_After()

   @{b}FUNCTION@{ub}
        Returns the number of seconds the HTTP server suggests the client should
        wait until the next request is issued. The information from the
        "Retry-After:" header.

        While the HTTP header might contain a fixed date string, the
        #CURLINFO_RETRY_AFTER will always return number of seconds to wait - or
        zero if there was no header or the header could not be parsed.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        retry     output value

@ENDNODE

@NODE easyGetInfo_RTSP_Client_CSeq "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_RTSP_Client_CSeq -- get the next RTSP client CSeq

   @{b}SYNOPSIS@{ub}
        cseq = easy:GetInfo_RTSP_Client_CSeq()

   @{b}FUNCTION@{ub}
        Returns the next CSeq that will be used by the application.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cseq      output value

@ENDNODE

@NODE easyGetInfo_RTSP_CSeq_Recv "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_RTSP_CSeq_Recv -- get the recently received CSeq

   @{b}SYNOPSIS@{ub}
        cseq = easy:GetInfo_RTSP_CSeq_Recv()

   @{b}FUNCTION@{ub}
        Returns the most recently received CSeq from the server. If your
        application encounters a #CURLE_RTSP_CSEQ_ERROR then you may wish to
        troubleshoot and/or fix the CSeq mismatch by peeking at this value.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cseq      output value

@ENDNODE

@NODE easyGetInfo_RTSP_Server_CSeq "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_RTSP_Server_CSeq -- get the next RTSP server CSeq

   @{b}SYNOPSIS@{ub}
        cseq = easy:GetInfo_RTSP_Server_CSeq()

   @{b}FUNCTION@{ub}
        Returns the next CSeq that will be expected by the application.

        Listening for server initiated requests is currently unimplemented!

        Applications wishing to resume an RTSP session on another connection
        should retrieve this info before closing the active connection.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        cseq      output value

@ENDNODE

@NODE easyGetInfo_RTSP_Session_ID "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_RTSP_Session_ID -- get RTSP session ID

   @{b}SYNOPSIS@{ub}
        id = easy:GetInfo_RTSP_Session_ID()

   @{b}FUNCTION@{ub}
        Returns a string holding the most recent RTSP Session ID.

        Applications wishing to resume an RTSP session on another connection
        should retrieve this info before closing the active connection.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        id        output value

@ENDNODE

@NODE easyGetInfo_Scheme "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Scheme -- get the URL scheme (sometimes called protocol) used in the connection

   @{b}SYNOPSIS@{ub}
        scheme = easy:GetInfo_Scheme()

   @{b}FUNCTION@{ub}
        Returns a string holding the URL scheme used for the most recent
        connection done with this CURL handle.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        scheme    output value

@ENDNODE

@NODE easyGetInfo_Size_Download "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Size_Download -- get the number of downloaded bytes

   @{b}SYNOPSIS@{ub}
        dlp = easy:GetInfo_Size_Download()

   @{b}FUNCTION@{ub}
        Returns the total amount of bytes that were downloaded. The amount is
        only for the latest transfer and will be reset again for each new
        transfer. This counts actual payload data, what's also commonly called
        body. All meta and header data are excluded and will not be counted in
        this number.

        #CURLINFO_SIZE_DOWNLOAD_T is a newer replacement that returns a more
        sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        dlp       output value

@ENDNODE

@NODE easyGetInfo_Size_Download_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Size_Download_t -- get the number of downloaded bytes

   @{b}SYNOPSIS@{ub}
        dlp = easy:GetInfo_Size_Download_t()

   @{b}FUNCTION@{ub}
        Returns the total amount of bytes that were downloaded. The amount is
        only for the latest transfer and will be reset again for each new
        transfer. This counts actual payload data, what's also commonly called
        body. All meta and header data are excluded and will not be counted in
        this number.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        dlp       output value

@ENDNODE

@NODE easyGetInfo_Size_Upload "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Size_Upload -- get the number of uploaded bytes

   @{b}SYNOPSIS@{ub}
        uploadp = easy:GetInfo_Size_Upload()

   @{b}FUNCTION@{ub}
        Returns the total amount of bytes that were uploaded.

        #CURLINFO_SIZE_UPLOAD_T is a newer replacement that returns a more
        sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        uploadp   output value

@ENDNODE

@NODE easyGetInfo_Size_Upload_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Size_Upload_t -- get the number of uploaded bytes

   @{b}SYNOPSIS@{ub}
        uploadp = easy:GetInfo_Size_Upload_t()

   @{b}FUNCTION@{ub}
        Returns the total amount of bytes that were uploaded.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        uploadp   output value

@ENDNODE

@NODE easyGetInfo_Speed_Download "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Speed_Download -- get download speed

   @{b}SYNOPSIS@{ub}
        speed = easy:GetInfo_Speed_Download()

   @{b}FUNCTION@{ub}
        Returns the average download speed that curl measured for the complete
        download. Measured in bytes/second.

        #CURLINFO_SPEED_DOWNLOAD_T is a newer replacement that returns a more
        sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        speed     output value

@ENDNODE

@NODE easyGetInfo_Speed_Download_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Speed_Download_t -- get download speed

   @{b}SYNOPSIS@{ub}
        speed = easy:GetInfo_Speed_Download_t()

   @{b}FUNCTION@{ub}
        Returns the average download speed that curl measured for the complete
        download. Measured in bytes/second.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        speed     output value

@ENDNODE

@NODE easyGetInfo_Speed_Upload "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Speed_Upload -- get upload speed

   @{b}SYNOPSIS@{ub}
        speed = easy:GetInfo_Speed_Upload()

   @{b}FUNCTION@{ub}
        Returns the average upload speed that curl measured for the complete
        upload. Measured in bytes/second.

        #CURLINFO_SPEED_UPLOAD_T is a newer replacement that returns a more
        sensible variable type.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        speed     output value

@ENDNODE

@NODE easyGetInfo_Speed_Upload_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Speed_Upload_t -- get upload speed

   @{b}SYNOPSIS@{ub}
        speed = easy:GetInfo_Speed_Upload_t()

   @{b}FUNCTION@{ub}
        Returns the average upload speed that curl measured for the complete
        upload. Measured in bytes/second.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        speed     output value

@ENDNODE

@NODE easyGetInfo_SSL_Engines "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_SSL_Engines -- get a list of OpenSSL crypto-engines

   @{b}SYNOPSIS@{ub}
        engine_list = easy:GetInfo_SSL_Engines()

   @{b}FUNCTION@{ub}
        Returns a table containing a list of OpenSSL crypto-engines supported.
        Note that engines are normally implemented in separate dynamic
        libraries. Hence not all the returned engines may be available at
        run-time.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        engine_list
                  output value

@ENDNODE

@NODE easyGetInfo_SSL_VerifyResult "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_SSL_VerifyResult -- get the result of the certificate verification

   @{b}SYNOPSIS@{ub}
        result = easy:GetInfo_SSL_VerifyResult()

   @{b}FUNCTION@{ub}
        Returns the result of the server SSL certificate verification that was
        requested (using the #CURLOPT_SSL_VERIFYPEER option.

        0 is a positive result. Non-zero is an error.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        result    output value

@ENDNODE

@NODE easyGetInfo_StartTransfer_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_StartTransfer_Time -- get the time until the first byte is received

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_StartTransfer_Time()

   @{b}FUNCTION@{ub}
        Returns the time, in seconds, it took from the start until the first
        byte is received by libcurl. This includes #CURLINFO_PRETRANSFER_TIME
        and also the time the server needs to calculate the result.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_StartTransfer_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_StartTransfer_Time_t -- get the time until the first byte is received (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_StartTransfer_Time_t()

   @{b}FUNCTION@{ub}
        Returns the time, in microseconds, it took from the start until the
        first byte is received by libcurl. This includes
        #CURLINFO_PRETRANSFER_TIME_T and also the time the server needs to
        calculate the result.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Total_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Total_Time -- get total time of previous transfer

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Total_Time()

   @{b}FUNCTION@{ub}
        Returns the total time in seconds for the previous transfer, including
        name resolving, TCP connect etc. The double represents the time in
        seconds, including fractions.

        See also the TIMES overview in the @{"easy:GetInfo()" LINK easyGetInfo} man page.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyGetInfo_Total_Time_t "hURL Guide"

   @{b}NAME@{ub}
        easy:GetInfo_Total_Time_t -- get total time of previous transfer in microseconds (V2.0)

   @{b}SYNOPSIS@{ub}
        timep = easy:GetInfo_Total_Time_t()

   @{b}FUNCTION@{ub}
        Returns the total time in microseconds for the previous transfer,
        including name resolving, TCP connect etc. The value represents the time
        in microseconds.

        When a redirect is followed, the time from each request is added
        together.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        timep     output value

@ENDNODE

@NODE easyMime "hURL Guide"

   @{b}NAME@{ub}
        easy:Mime -- create a mime object (V2.0)

   @{b}SYNOPSIS@{ub}
        handle = easy:Mime()

   @{b}FUNCTION@{ub}
        This creates a new mime object. This mime object can be subsequently
        filled using the mime API, then attached to some easy handle using
        @{"easy:SetOpt_MIMEPost" LINK easySetOpt_MIMEPost} or added as a multipart in another mime handle's
        part using @{"mimepart:Subparts()" LINK mimepartSubparts}.

        Using a mime handle is the recommended way to post an HTTP form, format
        and send a multi-part email with SMTP or upload such an email to an IMAP
        server.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        handle    mime object

   @{b}EXAMPLE@{ub}
        e = hurl.Easy()
        m = e:MIME()
        p = m:AddPart()
        p:Name("data")
        p:Data("This is the field data")
        e:SetOpt_MIMEPost(m)
        e:SetOpt_URL("https://example.com")
        e:Perform()
        e:Close()
        m:Free()

        The code above shows how to create a mime object that contains a single
        field which is then posted to a HTTP server.

@ENDNODE

@NODE easyPause "hURL Guide"

   @{b}NAME@{ub}
        easy:Pause -- pause and unpause a connection

   @{b}SYNOPSIS@{ub}
        easy:Pause(bitmask)

   @{b}FUNCTION@{ub}
        Using this function, you can explicitly mark a running connection to get
        paused, and you can unpause a connection that was previously paused.

        A connection can be paused by using this function or by letting the read
        or the write callbacks return the proper magic return code
        (#CURL_READFUNC_PAUSE and #CURL_WRITEFUNC_PAUSE). A write callback that
        returns pause signals to the library that it couldn't take care of any
        data at all, and that data will then be delivered again to the callback
        when the writing is later unpaused.

        While it may feel tempting, take care and notice that you cannot call
        this function from another thread. To unpause, you may for example call
        it from the progress callback (#CURLOPT_PROGRESSFUNCTION), which gets
        called at least once per second, even if the connection is paused.

        When this function is called to unpause reading, the chance is high that
        you will get your write callback called before this function returns.

        The "bitmask" argument is a get of bits that sets the new state of the
        connection. The following bits can be used:

        #CURLPAUSE_RECV
                  Pause receiving data. There will be no data received on this
                  connection until this function is called again without this
                  bit get. Thus, the write callback (#CURLOPT_WRITEFUNCTION)
                  won't be called.

        #CURLPAUSE_SEND
                  Pause sending data. There will be no data sent on this
                  connection until this function is called again without this
                  bit get. Thus, the read callback (#CURLOPT_READFUNCTION) won't
                  be called.

        #CURLPAUSE_ALL
                  Convenience define that pauses both directions.

        #CURLPAUSE_CONT
                  Convenience define that unpauses both directions.

   @{b}INPUTS@{ub}
        bitmask   desired new state of the connection

@ENDNODE

@NODE easyPerform "hURL Guide"

   @{b}NAME@{ub}
        easy:Perform -- perform a blocking file transfer

   @{b}SYNOPSIS@{ub}
        easy:Perform()

   @{b}FUNCTION@{ub}
        Invoke this function after @{"hurl.Easy()" LINK hurlEasy} and all the @{"easy:SetOpt()" LINK easySetOpt} calls
        are made, and will perform the transfer as described in the options. It
        must be called with the same easy handle as input as the @{"hurl.Easy()" LINK hurlEasy}
        call returned.

        easy:Perform() performs the entire request in a blocking manner and
        returns when done, or if it failed. For non-blocking behavior, see
        @{"multi:Perform()" LINK multiPerform}.

        You can do any amount of calls to easy:Perform() while using the same
        easy handle. If you intend to transfer more than one file, you are even
        encouraged to do so. libcurl will then attempt to re-use the same
        connection for the following transfers, thus making the operations
        faster, less CPU intense and using less network resources. Just note
        that you will have to use @{"easy:SetOpt()" LINK easySetOpt} between the invokes to get
        options for the following easy:Perform().

        You must never call this function simultaneously from two places using
        the same easy handle. Let the function return first before invoking it
        another time. If you want parallel transfers, you must use several curl
        easy handles.

        While the easy handle is added to a multi handle, it cannot be used by
        easy:Perform().

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyRecv "hURL Guide"

   @{b}NAME@{ub}
        easy:Recv -- receives raw data on an easy connection

   @{b}SYNOPSIS@{ub}
        data$, n = easy:Recv(len)

   @{b}FUNCTION@{ub}
        This function receives raw data from the established connection. You may
        use it together with @{"easy:Send()" LINK easySend} to implement custom protocols using
        libcurl. This functionality can be particularly useful if you use
        proxies and/or SSL encryption: libcurl will take care of proxy
        negotiation and connection get-up. You have to pass the number of bytes
        to receive in "len".

        To establish the connection, get #CURLOPT_CONNECT_ONLY option before
        calling @{"easy:Perform()" LINK easyPerform} or @{"multi:Perform()" LINK multiPerform}. Note that easy:Recv() does
        not work on connections that were created without this option.

        The call will return -1 in "n" if there is no data to read - the socket
        is used in non-blocking mode internally. When -1 is returned, sleep for
        a few milliseconds to wait for data. You should sleep for a few seconds
        only if easy:Recv() returns -1 in "n". The reason for this is libcurl or
        the SSL library may internally cache some data, therefore you should
        call easy:Recv() until all data is read which would include any cached
        data.

        Furthermore, easy:Recv() may return -1 in "n" if the only data that was
        read was for internal SSL processing, and no other data is available.

   @{b}INPUTS@{ub}
        len       number of bytes to read

   @{b}RESULTS@{ub}
        data$     data read
        n         number of bytes read

@ENDNODE

@NODE easyReset "hURL Guide"

   @{b}NAME@{ub}
        easy:Reset -- reset all options of a libcurl session handle

   @{b}SYNOPSIS@{ub}
        easy:Reset()

   @{b}FUNCTION@{ub}
        Re-initializes all options previously get on a specified curl easy
        handle to the default values. This puts back the handle to the same
        state as it was in when it was just created with @{"hurl.Easy()" LINK hurlEasy}.

        It does not change the following information kept in the handle: live
        connections, the Session ID cache, the DNS cache, the cookies and
        shares.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easySend "hURL Guide"

   @{b}NAME@{ub}
        easy:Send -- sends raw data over an easy connection

   @{b}SYNOPSIS@{ub}
        sent = easy:Send(data$)

   @{b}FUNCTION@{ub}
        This function sends arbitrary data over the established connection. You
        may use it together with @{"easy:Recv()" LINK easyRecv} to implement custom protocols using
        libcurl. This functionality can be particularly useful if you use
        proxies and/or SSL encryption: libcurl will take care of proxy
        negotiation and connection get-up. You need to pass the data to send in
        "data$". This can also contain binary data.

        To establish the connection, get #CURLOPT_CONNECT_ONLY option before
        calling @{"easy:Perform()" LINK easyPerform} or @{"multi:Perform()" LINK multiPerform}. Note that easy:Send() will
        not work on connections that were created without this option.

        The call will return -1 if it's not possible to send data right now. In
        that case, you need to try to send the data again because curl uses
        non-blocking sockets.

        Furthermore easy:Send() may return -1 if the only data that was sent was
        for internal SSL processing, and no other data could be sent.

   @{b}INPUTS@{ub}
        data$     data to send

   @{b}RESULTS@{ub}
        sent      number of bytes sent

@ENDNODE

@NODE easySetOpt "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt -- get options for a curl easy handle

   @{b}SYNOPSIS@{ub}
        easy:SetOpt(option, parameter)
        easy:SetOpt(table)

   @{b}FUNCTION@{ub}
        easy:SetOpt() is used to tell libcurl how to behave. By setting the
        appropriate options, the application can change libcurl's behavior. All
        options are get with an option followed by a parameter. That parameter
        can be a number, a string, a table, or a function reference, depending
        on what the specific option expects. Read this manual carefully as bad
        input values may cause libcurl to behave badly!

        Options get with this function call are valid for all forthcoming
        transfers performed using this handle. The options are not in any way
        reset between transfers, so if you want subsequent transfers with
        different options, you must change them between the transfers. You can
        optionally reset all options back to internal default with @{"easy:Reset()" LINK easyReset}.

        easy:SetOpt() can be used in two different ways: You can either get a
        single option by passing the "option" and "parameter" arguments or you
        can get multiple options at once by passing a table argument to
        easy:SetOpt(). See below for an example.

        The order in which the options are get does not matter.

        The following option types are currently supported:

        #CURLOPT_ABSTRACT_UNIX_SOCKET
                  Path to an abstract Unix domain socket. See
                  @{"easy:SetOpt_Abstract_Unix_Socket" LINK easySetOpt_Abstract_Unix_Socket} for details.
        #CURLOPT_ACCEPT_ENCODING
                  Accept-Encoding and automatic decompressing data. See
                  @{"easy:SetOpt_Accept_Encoding" LINK easySetOpt_Accept_Encoding} for details.
        #CURLOPT_ACCEPTTIMEOUT_MS
                  Timeout for waiting for the server's connect back to be
                  accepted. See @{"easy:SetOpt_AcceptTimeout_MS" LINK easySetOpt_AcceptTimeout_MS} for details.
        #CURLOPT_ADDRESS_SCOPE
                  IPv6 scope for local addresses. See @{"easy:SetOpt_Address_Scope" LINK easySetOpt_Address_Scope}
                  for details.
        #CURLOPT_ALTSVC
                  Specify the Alt-Svc: cache file name. See @{"easy:SetOpt_AltSvc" LINK easySetOpt_AltSvc}
                  for details. (V2.0)
        #CURLOPT_ALTSVC_CTRL
                  Enable and configure Alt-Svc: treatment. See
                  @{"easy:SetOpt_AltSvc_Ctrl" LINK easySetOpt_AltSvc_Ctrl} for details. (V2.0)
        #CURLOPT_APPEND
                  Append to remote file. See @{"easy:SetOpt_Append" LINK easySetOpt_Append} for details.
        #CURLOPT_AUTOREFERER
                  Automatically get Referer: header. See @{"easy:SetOpt_AutoReferer" LINK easySetOpt_AutoReferer}
                  for details.
        #CURLOPT_AWS_SIGV4
                  AWS HTTP V4 Signature. See @{"easy:SetOpt_AWS_SigV4" LINK easySetOpt_AWS_SigV4} for details.
                  (V2.0)
        #CURLOPT_BUFFERSIZE
                  Ask for alternate buffer size. See @{"easy:SetOpt_BufferSize" LINK easySetOpt_BufferSize} for
                  details.
        #CURLOPT_CA_CACHE_TIMEOUT
                  Timeout for CA cache. See @{"easy:SetOpt_CA_Cache_Timeout" LINK easySetOpt_CA_Cache_Timeout} for
                  details. (V2.0)
        #CURLOPT_CAINFO
                  CA cert bundle. See @{"easy:SetOpt_CAInfo" LINK easySetOpt_CAInfo} for details.
        #CURLOPT_CAINFO_BLOB
                  CA cert bundle memory buffer. See @{"easy:SetOpt_CAInfo_Blob" LINK easySetOpt_CAInfo_Blob} for
                  details. (V2.0)
        #CURLOPT_CAPATH
                  Path to CA cert bundle. See @{"easy:SetOpt_CAPath" LINK easySetOpt_CAPath} for details.
        #CURLOPT_CERTINFO
                  Extract certificate info. See @{"easy:SetOpt_CertInfo" LINK easySetOpt_CertInfo} for
                  details.
        #CURLOPT_CHUNK_BGN_FUNCTION
                  Callback for wildcard download start of chunk. See
                  @{"easy:SetOpt_Chunk_BGN_Function" LINK easySetOpt_Chunk_BGN_Function} for details.
        #CURLOPT_CHUNK_END_FUNCTION
                  Callback for wildcard download end of chunk. See
                  @{"easy:SetOpt_Chunk_End_Function" LINK easySetOpt_Chunk_End_Function} for details.
        #CURLOPT_CONNECT_ONLY
                  Only connect, nothing else. See @{"easy:SetOpt_Connect_Only" LINK easySetOpt_Connect_Only} for
                  details.
        #CURLOPT_CONNECT_TO
                  Connect to a specific host and port. See
                  @{"easy:SetOpt_Connect_To" LINK easySetOpt_Connect_To} for details.
        #CURLOPT_CONNECTTIMEOUT
                  Timeout for the connection phase. See
                  @{"easy:SetOpt_ConnectTimeout" LINK easySetOpt_ConnectTimeout} for details.
        #CURLOPT_CONNECTTIMEOUT_MS
                  Millisecond timeout for the connection phase. See
                  @{"easy:SetOpt_ConnectTimeout_MS" LINK easySetOpt_ConnectTimeout_MS} for details.
        #CURLOPT_COOKIE
                  Cookie(s) to send. See @{"easy:SetOpt_Cookie" LINK easySetOpt_Cookie} for details.
        #CURLOPT_COOKIEFILE
                  File to read cookies from. See @{"easy:SetOpt_CookieFile" LINK easySetOpt_CookieFile} for
                  details.
        #CURLOPT_COOKIEJAR
                  File to write cookies to. See @{"easy:SetOpt_CookieJar" LINK easySetOpt_CookieJar} for
                  details.
        #CURLOPT_COOKIELIST
                  Add or control cookies. See @{"easy:SetOpt_CookieList" LINK easySetOpt_CookieList} for
                  details.
        #CURLOPT_COOKIESESSION
                  Start a new cookie session. See @{"easy:SetOpt_CookieSession" LINK easySetOpt_CookieSession} for
                  details.
        #CURLOPT_CRLF
                  Convert newlines. See @{"easy:SetOpt_CRLF" LINK easySetOpt_CRLF} for details.
        #CURLOPT_CRLFILE
                  Certificate Revocation List. See @{"easy:SetOpt_CRLFile" LINK easySetOpt_CRLFile} for
                  details.
        #CURLOPT_CURLU
                  Set URL to work on with a URL handle. See @{"easy:SetOpt_CURLU" LINK easySetOpt_CURLU}
                  for details. (V2.0)
        #CURLOPT_CUSTOMREQUEST
                  Custom request/method. See @{"easy:SetOpt_CustomRequest" LINK easySetOpt_CustomRequest} for
                  details.
        #CURLOPT_DEBUGFUNCTION
                  Callback for debug information. See @{"easy:SetOpt_DebugFunction" LINK easySetOpt_DebugFunction}
                  for details.
        #CURLOPT_DEFAULT_PROTOCOL
                  Default protocol. See @{"easy:SetOpt_Default_Protocol" LINK easySetOpt_Default_Protocol} for
                  details.
        #CURLOPT_DIRLISTONLY
                  List only. See @{"easy:SetOpt_DirListOnly" LINK easySetOpt_DirListOnly} for details.
        #CURLOPT_DNS_CACHE_TIMEOUT
                  Timeout for DNS cache. See @{"easy:SetOpt_DNS_Cache_Timeout" LINK easySetOpt_DNS_Cache_Timeout} for
                  details.
        #CURLOPT_DNS_INTERFACE
                  Bind name resolves to this interface. See
                  @{"easy:SetOpt_DNS_Interface" LINK easySetOpt_DNS_Interface} for details.
        #CURLOPT_DNS_LOCAL_IP4
                  Bind name resolves to this IP4 address. See
                  @{"easy:SetOpt_DNS_Local_IP4" LINK easySetOpt_DNS_Local_IP4} for details.
        #CURLOPT_DNS_LOCAL_IP6
                  Bind name resolves to this IP6 address. See
                  @{"easy:SetOpt_DNS_Local_IP6" LINK easySetOpt_DNS_Local_IP6} for details.
        #CURLOPT_DNS_SERVERS
                  Preferred DNS servers. See @{"easy:SetOpt_DNS_Servers" LINK easySetOpt_DNS_Servers} for
                  details.
        #CURLOPT_DNS_SHUFFLE_ADDRESSES
                  Shuffle addresses before use. See
                  @{"easy:SetOpt_DNS_Shuffle_Addresses" LINK easySetOpt_DNS_Shuffle_Addresses} for details. (V2.0)
        #CURLOPT_DNS_USE_GLOBAL_CACHE
                  OBSOLETE Enable global DNS cache. See
                  @{"easy:SetOpt_DNS_Use_Global_Cache" LINK easySetOpt_DNS_Use_Global_Cache} for details.
        #CURLOPT_DISALLOW_USERNAME_IN_URL
                  Do not allow username in URL. See
                  @{"easy:SetOpt_Disallow_Username_In_URL" LINK easySetOpt_Disallow_Username_In_URL} for details. (V2.0)
        #CURLOPT_DOH_SSL_VERIFYHOST
                  Verify the host name in the DoH (DNS-over-HTTPS) SSL
                  certificate. See @{"easy:SetOpt_DoH_SSL_VerifyHost" LINK easySetOpt_DoH_SSL_VerifyHost} for details.
                  (V2.0)
        #CURLOPT_DOH_SSL_VERIFYPEER
                  Verify the DoH (DNS-over-HTTPS) SSL certificate. See
                  @{"easy:SetOpt_DoH_SSL_VerifyPeer" LINK easySetOpt_DoH_SSL_VerifyPeer} for details. (V2.0)
        #CURLOPT_DOH_SSL_VERIFYSTATUS
                  Verify the DoH (DNS-over-HTTPS) SSL certificate's status. See
                  @{"easy:SetOpt_DoH_SSL_VerifyStatus" LINK easySetOpt_DoH_SSL_VerifyStatus} for details. (V2.0)
        #CURLOPT_DOH_URL
                  Use this DoH server for name resolves. See @{"easy:SetOpt_DoH_URL" LINK easySetOpt_DoH_URL}
                  for details. (V2.0)
        #CURLOPT_EGDSOCKET
                  Identify EGD socket for entropy. See @{"easy:SetOpt_EGDSocket" LINK easySetOpt_EGDSocket} for
                  details.
        #CURLOPT_EXPECT_100_TIMEOUT_MS
                  100-continue timeout. See @{"easy:SetOpt_Expect_100_Timeout_MS" LINK easySetOpt_Expect_100_Timeout_MS}
                  for details.
        #CURLOPT_FAILONERROR
                  Fail on HTTP 4xx errors. See @{"easy:SetOpt_FailOnError" LINK easySetOpt_FailOnError} for
                  details.
        #CURLOPT_FILETIME
                  Request file modification date and time. See
                  @{"easy:SetOpt_FileTime" LINK easySetOpt_FileTime} for details.
        #CURLOPT_FNMATCH_FUNCTION
                  Callback for wildcard matching. See
                  @{"easy:SetOpt_FNMatch_Function" LINK easySetOpt_FNMatch_Function} for details.
        #CURLOPT_FOLLOWLOCATION
                  Follow HTTP redirects. See @{"easy:SetOpt_FollowLocation" LINK easySetOpt_FollowLocation} for
                  details.
        #CURLOPT_FORBID_REUSE
                  Prevent subsequent connections from re-using this. See
                  @{"easy:SetOpt_Forbid_Reuse" LINK easySetOpt_Forbid_Reuse} for details.
        #CURLOPT_FRESH_CONNECT
                  Use a new connection. See @{"easy:SetOpt_Fresh_Connect" LINK easySetOpt_Fresh_Connect} for
                  details.
        #CURLOPT_FTP_ACCOUNT
                  Send ACCT command. See @{"easy:SetOpt_FTP_Account" LINK easySetOpt_FTP_Account} for details.
        #CURLOPT_FTP_ALTERNATIVE_TO_USER
                  Alternative to USER. See @{"easy:SetOpt_FTP_Alternative_To_User" LINK easySetOpt_FTP_Alternative_To_User}
                  for details.
        #CURLOPT_FTP_CREATE_MISSING_DIRS
                  Create missing directories on the remote server. See
                  @{"easy:SetOpt_FTP_Create_Missing_Dirs" LINK easySetOpt_FTP_Create_Missing_Dirs} for details.
        #CURLOPT_FTP_FILEMETHOD
                  Specify how to reach files. See @{"easy:SetOpt_FTP_FileMethod" LINK easySetOpt_FTP_FileMethod} for
                  details.
        #CURLOPT_FTP_RESPONSE_TIMEOUT
                  Timeout for FTP responses. See
                  @{"easy:SetOpt_FTP_Response_Timeout" LINK easySetOpt_FTP_Response_Timeout} for details.
        #CURLOPT_FTP_SKIP_PASV_IP
                  Ignore the IP address in the PASV response. See
                  @{"easy:SetOpt_FTP_Skip_PASV_IP" LINK easySetOpt_FTP_Skip_PASV_IP} for details.
        #CURLOPT_FTP_SSL_CCC
                  Back to non-TLS again after authentication. See
                  @{"easy:SetOpt_FTP_SSL_CCC" LINK easySetOpt_FTP_SSL_CCC} for details.
        #CURLOPT_FTP_USE_EPRT
                  Use EPTR. See @{"easy:SetOpt_FTP_Use_Eprt" LINK easySetOpt_FTP_Use_Eprt} for details.
        #CURLOPT_FTP_USE_EPSV
                  Use EPSV. See @{"easy:SetOpt_FTP_Use_Epsv" LINK easySetOpt_FTP_Use_Epsv} for details.
        #CURLOPT_FTP_USE_PRET
                  Use PRET. See @{"easy:SetOpt_FTP_Use_Pret" LINK easySetOpt_FTP_Use_Pret} for details.
        #CURLOPT_FTPPORT
                  Use active FTP. See @{"easy:SetOpt_FTPPort" LINK easySetOpt_FTPPort} for details.
        #CURLOPT_FTPSSLAUTH
                  Control how to do TLS. See @{"easy:SetOpt_FTPSSLAuth" LINK easySetOpt_FTPSSLAuth} for details.
        #CURLOPT_GSSAPI_DELEGATION
                  Disable GSS-API delegation. See @{"easy:SetOpt_GSSAPI_Delegation" LINK easySetOpt_GSSAPI_Delegation}
                  for details.
        #CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS
                  Timeout for happy eyeballs. See
                  @{"easy:SetOpt_Happy_Eyeballs_Timeout_MS" LINK easySetOpt_Happy_Eyeballs_Timeout_MS} for details. (V2.0)
        #CURLOPT_HAPROXYPROTOCOL
                  Send an HAProxy PROXY protocol v1 header. See
                  @{"easy:SetOpt_HAProxyProtocol" LINK easySetOpt_HAProxyProtocol} for details. (V2.0)
        #CURLOPT_HEADER
                  Include the header in the body output. See @{"easy:SetOpt_Header" LINK easySetOpt_Header}
                  for details.
        #CURLOPT_HEADERFUNCTION
                  Callback for writing received headers. See
                  @{"easy:SetOpt_HeaderFunction" LINK easySetOpt_HeaderFunction} for details.
        #CURLOPT_HEADEROPT
                  Control custom headers. See @{"easy:SetOpt_HeaderOpt" LINK easySetOpt_HeaderOpt} for details.
        #CURLOPT_HSTS
                  Set HSTS cache file. See @{"easy:SetOpt_HSTS" LINK easySetOpt_HSTS} for details. (V2.0)
        #CURLOPT_HSTS_CTRL
                  Enable HSTS. See @{"easy:SetOpt_HSTS_Ctrl" LINK easySetOpt_HSTS_Ctrl} for details. (V2.0)
        #CURLOPT_HSTSREADFUNCTION
                  Set HSTS read callback. See @{"easy:SetOpt_HSTSReadFunction" LINK easySetOpt_HSTSReadFunction} for
                  details. (V2.0)
        #CURLOPT_HSTSWRITEFUNCTION
                  Set HSTS write callback. See @{"easy:SetOpt_HSTSWriteFunction" LINK easySetOpt_HSTSWriteFunction} for
                  details. (V2.0)
        #CURLOPT_HTTP09_ALLOWED
                  Allow HTTP/0. See @{"easy:SetOpt_HTTP09_Allowed" LINK easySetOpt_HTTP09_Allowed} for details.
                  (V2.0)
        #CURLOPT_HTTP200ALIASES
                  Alternative versions of 200 OK. See @{"easy:SetOpt_HTTP200Aliases" LINK easySetOpt_HTTP200Aliases}
                  for details.
        #CURLOPT_HTTP_CONTENT_DECODING
                  Disable Content decoding. See
                  @{"easy:SetOpt_HTTP_Content_Decoding" LINK easySetOpt_HTTP_Content_Decoding} for details.
        #CURLOPT_HTTP_TRANSFER_DECODING
                  Disable Transfer decoding. See
                  @{"easy:SetOpt_HTTP_Transfer_Decoding" LINK easySetOpt_HTTP_Transfer_Decoding} for details.
        #CURLOPT_HTTP_VERSION
                  HTTP version to use. See @{"easy:SetOpt_HTTP_Version" LINK easySetOpt_HTTP_Version} for details.
        #CURLOPT_HTTPAUTH
                  HTTP server authentication methods. See @{"easy:SetOpt_HTTPAuth" LINK easySetOpt_HTTPAuth}
                  for details.
        #CURLOPT_HTTPGET
                  Do an HTTP GET request. See @{"easy:SetOpt_HTTPGet" LINK easySetOpt_HTTPGet} for details.
        #CURLOPT_HTTPHEADER
                  Custom HTTP headers. See @{"easy:SetOpt_HTTPHeader" LINK easySetOpt_HTTPHeader} for details.
        #CURLOPT_HTTPPOST
                  Multipart formpost HTTP POST. See @{"easy:SetOpt_HTTPPost" LINK easySetOpt_HTTPPost} for
                  details.
        #CURLOPT_HTTPPROXYTUNNEL
                  Tunnel through the HTTP proxy. See @{"easy:SetOpt_HTTPProxyTunnel" LINK easySetOpt_HTTPProxyTunnel}
                  for details.
        #CURLOPT_IGNORE_CONTENT_LENGTH
                  Ignore Content-Length. See @{"easy:SetOpt_Ignore_Content_Length" LINK easySetOpt_Ignore_Content_Length}
                  for details.
        #CURLOPT_INFILESIZE
                  Size of file to send. See @{"easy:SetOpt_InFileSize" LINK easySetOpt_InFileSize} for details.
        #CURLOPT_INFILESIZE_LARGE
                  Size of file to send. See @{"easy:SetOpt_InFileSize_Large" LINK easySetOpt_InFileSize_Large} for
                  details.
        #CURLOPT_INTERFACE
                  Bind connection locally to this. See @{"easy:SetOpt_Interface" LINK easySetOpt_Interface} for
                  details.
        #CURLOPT_IPRESOLVE
                  IP version to resolve to. See @{"easy:SetOpt_IPResolve" LINK easySetOpt_IPResolve} for
                  details.
        #CURLOPT_ISSUERCERT
                  Issuer certificate. See @{"easy:SetOpt_IssuerCert" LINK easySetOpt_IssuerCert} for details.
        #CURLOPT_ISSUERCERT_BLOB
                  Issuer certificate memory buffer. See
                  @{"easy:SetOpt_IssuerCert_Blob" LINK easySetOpt_IssuerCert_Blob} for details. (V2.0)
        #CURLOPT_KEEP_SENDING_ON_ERROR
                  Keep sending on HTTP >= 300 errors. See
                  @{"easy:SetOpt_Keep_Sending_On_Error" LINK easySetOpt_Keep_Sending_On_Error} for details.
        #CURLOPT_KEYPASSWD
                  Client key password. See @{"easy:SetOpt_KeyPasswd" LINK easySetOpt_KeyPasswd} for details.
        #CURLOPT_KRBLEVEL
                  Kerberos security level. See @{"easy:SetOpt_KRBLevel" LINK easySetOpt_KRBLevel} for details.
        #CURLOPT_LOCALPORT
                  Bind connection locally to this port. See
                  @{"easy:SetOpt_LocalPort" LINK easySetOpt_LocalPort} for details.
        #CURLOPT_LOCALPORTRANGE
                  Bind connection locally to port range. See
                  @{"easy:SetOpt_LocalPortRange" LINK easySetOpt_LocalPortRange} for details.
        #CURLOPT_LOGIN_OPTIONS
                  Login options. See @{"easy:SetOpt_Login_Options" LINK easySetOpt_Login_Options} for details.
        #CURLOPT_LOW_SPEED_LIMIT
                  Low speed limit to abort transfer. See
                  @{"easy:SetOpt_Low_Speed_Limit" LINK easySetOpt_Low_Speed_Limit} for details.
        #CURLOPT_LOW_SPEED_TIME
                  Time to be below the speed to trigger low speed abort. See
                  @{"easy:SetOpt_Low_Speed_Time" LINK easySetOpt_Low_Speed_Time} for details.
        #CURLOPT_MAIL_AUTH
                  Authentication address. See @{"easy:SetOpt_Mail_Auth" LINK easySetOpt_Mail_Auth} for details.
        #CURLOPT_MAIL_FROM
                  Address of the sender. See @{"easy:SetOpt_Mail_From" LINK easySetOpt_Mail_From} for details.
        #CURLOPT_MAIL_RCPT
                  Address of the recipients. See @{"easy:SetOpt_Mail_RCPT" LINK easySetOpt_Mail_RCPT} for
                  details.
        #CURLOPT_MAIL_RCPT_ALLOWFAILS
                  Allow RCPT TO command to fail for some recipients. See
                  @{"easy:SetOpt_Mail_RCPT_AllowFails" LINK easySetOpt_Mail_RCPT_AllowFails} for details. (V2.0)
        #CURLOPT_MAXAGE_CONN
                  Limit the age (idle time) of connections for reuse. See
                  @{"easy:SetOpt_MaxAge_Conn" LINK easySetOpt_MaxAge_Conn} for details. (V2.0)
        #CURLOPT_MAXLIFETIME_CONN
                  Limit the age (since creation) of connections for reuse. See
                  @{"easy:SetOpt_MaxLifeTime_Conn" LINK easySetOpt_MaxLifeTime_Conn} for details. (V2.0)
        #CURLOPT_PREREQFUNCTION
                  Callback to be called after a connection is established but
                  before a request is made on that connection. See
                  @{"easy:SetOpt_PreReqFunction" LINK easySetOpt_PreReqFunction} for details. (V2.0)
        #CURLOPT_MAX_RECV_SPEED_LARGE
                  Cap the download speed to this. See
                  @{"easy:SetOpt_Max_Recv_Speed_Large" LINK easySetOpt_Max_Recv_Speed_Large} for details.
        #CURLOPT_MAX_SEND_SPEED_LARGE
                  Cap the upload speed to this. See
                  @{"easy:SetOpt_Max_Send_Speed_Large" LINK easySetOpt_Max_Send_Speed_Large} for details.
        #CURLOPT_MAXCONNECTS
                  Maximum number of connections in the connection pool. See
                  @{"easy:SetOpt_MaxConnects" LINK easySetOpt_MaxConnects} for details.
        #CURLOPT_MAXFILESIZE
                  Maximum file size to get. See @{"easy:SetOpt_MaxFileSize" LINK easySetOpt_MaxFileSize} for
                  details.
        #CURLOPT_MAXFILESIZE_LARGE
                  Maximum file size to get. See @{"easy:SetOpt_MaxFileSize_Large" LINK easySetOpt_MaxFileSize_Large}
                  for details.
        #CURLOPT_MAXREDIRS
                  Maximum number of redirects to follow. See
                  @{"easy:SetOpt_MaxRedirs" LINK easySetOpt_MaxRedirs} for details.
        #CURLOPT_MIME_OPTIONS
                  Set MIME option flags. See @{"easy:SetOpt_MIME_Options" LINK easySetOpt_MIME_Options} for
                  details. (V2.0)
        #CURLOPT_MIMEPOST
                  Post/send MIME data. See @{"easy:SetOpt_MIMEPost" LINK easySetOpt_MIMEPost} for details.
                  (V2.0)
        #CURLOPT_NETRC
                  Enable.netrc parsing. See @{"easy:SetOpt_Netrc" LINK easySetOpt_Netrc} for details.
        #CURLOPT_NETRC_FILE
                  .netrc file name. See @{"easy:SetOpt_Netrc_File" LINK easySetOpt_Netrc_File} for details.
        #CURLOPT_NEW_DIRECTORY_PERMS
                  Mode for creating new remote directories. See
                  @{"easy:SetOpt_New_Directory_Perms" LINK easySetOpt_New_Directory_Perms} for details.
        #CURLOPT_NEW_FILE_PERMS
                  Mode for creating new remote files. See
                  @{"easy:SetOpt_New_File_Perms" LINK easySetOpt_New_File_Perms} for details.
        #CURLOPT_NOBODY
                  Do not get the body contents. See @{"easy:SetOpt_Nobody" LINK easySetOpt_Nobody} for
                  details.
        #CURLOPT_NOPROGRESS
                  Shut off the progress meter. See @{"easy:SetOpt_NoProgress" LINK easySetOpt_NoProgress} for
                  details.
        #CURLOPT_NOPROXY
                  Filter out hosts from proxy use. See @{"easy:SetOpt_NoProxy" LINK easySetOpt_NoProxy} for
                  details.
        #CURLOPT_NOSIGNAL
                  Do not install signal handlers. See @{"easy:SetOpt_NoSignal" LINK easySetOpt_NoSignal} for
                  details.
        #CURLOPT_PASSWORD
                  Password. See @{"easy:SetOpt_Password" LINK easySetOpt_Password} for details.
        #CURLOPT_PATH_AS_IS
                  Disable squashing /. See @{"easy:SetOpt_Path_As_Is" LINK easySetOpt_Path_As_Is} for details.
        #CURLOPT_PINNEDPUBLICKEY
                  Set pinned SSL public key. See @{"easy:SetOpt_PinnedPublicKey" LINK easySetOpt_PinnedPublicKey}
                  for details.
        #CURLOPT_PIPEWAIT
                  Wait on connection to pipeline on it. See @{"easy:SetOpt_PipeWait" LINK easySetOpt_PipeWait}
                  for details.
        #CURLOPT_PORT
                  Port number to connect to. See @{"easy:SetOpt_Port" LINK easySetOpt_Port} for details.
        #CURLOPT_POST
                  How to act on redirects after POST. See @{"easy:SetOpt_Post" LINK easySetOpt_Post} for
                  details.
        #CURLOPT_POSTFIELDS
                  Send a POST with this data. See @{"easy:SetOpt_PostFields" LINK easySetOpt_PostFields} for
                  details.
        #CURLOPT_POSTQUOTE
                  Commands to run after transfer. See @{"easy:SetOpt_PostQuote" LINK easySetOpt_PostQuote} for
                  details.
        #CURLOPT_POSTREDIR
                  How to act on redirects after POST. See @{"easy:SetOpt_PostRedir" LINK easySetOpt_PostRedir}
                  for details.
        #CURLOPT_PRE_PROXY
                  Socks proxy to use. See @{"easy:SetOpt_Pre_Proxy" LINK easySetOpt_Pre_Proxy} for details.
        #CURLOPT_PREQUOTE
                  Commands to run just before transfer. See @{"easy:SetOpt_Prequote" LINK easySetOpt_Prequote}
                  for details.
        #CURLOPT_PROGRESSFUNCTION
                  Callback for progress meter. See @{"easy:SetOpt_ProgressFunction" LINK easySetOpt_ProgressFunction}
                  for details.
        #CURLOPT_PROTOCOLS
                  Allowed protocols. See @{"easy:SetOpt_Protocols" LINK easySetOpt_Protocols} for details.
        #CURLOPT_PROTOCOLS_STR
                  Allowed protocols. See @{"easy:SetOpt_Protocols_Str" LINK easySetOpt_Protocols_Str} for details.
                  (V2.0)
        #CURLOPT_PROXY
                  Proxy to use. See @{"easy:SetOpt_Proxy" LINK easySetOpt_Proxy} for details.
        #CURLOPT_PROXY_CAINFO
                  Proxy CA cert bundle. See @{"easy:SetOpt_Proxy_CAInfo" LINK easySetOpt_Proxy_CAInfo} for
                  details.
        #CURLOPT_PROXY_CAINFO_BLOB
                  Proxy CA cert bundle memory buffer. See
                  @{"easy:SetOpt_Proxy_CAInfo_Blob" LINK easySetOpt_Proxy_CAInfo_Blob} for details. (V2.0)
        #CURLOPT_PROXY_CAPATH
                  Path to proxy CA cert bundle. See @{"easy:SetOpt_Proxy_CAPath" LINK easySetOpt_Proxy_CAPath} for
                  details.
        #CURLOPT_PROXY_CRLFILE
                  Proxy Certificate Revocation List. See
                  @{"easy:SetOpt_Proxy_CRLFile" LINK easySetOpt_Proxy_CRLFile} for details.
        #CURLOPT_PROXY_ISSUERCERT
                  Proxy issuer certificate. See @{"easy:SetOpt_Proxy_IssuerCert" LINK easySetOpt_Proxy_IssuerCert} for
                  details. (V2.0)
        #CURLOPT_PROXY_ISSUERCERT_BLOB
                  Proxy issuer certificate memory buffer. See
                  @{"easy:SetOpt_Proxy_IssuerCert_Blob" LINK easySetOpt_Proxy_IssuerCert_Blob} for details. (V2.0)
        #CURLOPT_PROXY_KEYPASSWD
                  Proxy client key password. See @{"easy:SetOpt_Proxy_KeyPasswd" LINK easySetOpt_Proxy_KeyPasswd} for
                  details.
        #CURLOPT_PROXY_PINNEDPUBLICKEY
                  Set the proxy's pinned SSL public key. See
                  @{"easy:SetOpt_Proxy_PinnedPublicKey" LINK easySetOpt_Proxy_PinnedPublicKey} for details.
        #CURLOPT_PROXY_SERVICE_NAME
                  Proxy authentication service name. See
                  @{"easy:SetOpt_Proxy_Service_Name" LINK easySetOpt_Proxy_Service_Name} for details.
        #CURLOPT_PROXY_SSLCERT
                  Proxy client cert. See @{"easy:SetOpt_Proxy_SSLCert" LINK easySetOpt_Proxy_SSLCert} for details.
        #CURLOPT_PROXY_SSLCERT_BLOB
                  Proxy client cert memory buffer. See
                  @{"easy:SetOpt_Proxy_SSLCert_Blob" LINK easySetOpt_Proxy_SSLCert_Blob} for details. (V2.0)
        #CURLOPT_PROXY_SSLCERTTYPE
                  Proxy client cert type. See @{"easy:SetOpt_Proxy_SSLCertType" LINK easySetOpt_Proxy_SSLCertType} for
                  details.
        #CURLOPT_PROXY_SSL_CIPHER_LIST
                  Proxy ciphers to use. See @{"easy:SetOpt_Proxy_SSL_Cipher_List" LINK easySetOpt_Proxy_SSL_Cipher_List}
                  for details.
        #CURLOPT_PROXY_SSLKEY
                  Proxy client key. See @{"easy:SetOpt_Proxy_SSLKey" LINK easySetOpt_Proxy_SSLKey} for details.
        #CURLOPT_PROXY_SSLKEY_BLOB
                  Proxy client key. See @{"easy:SetOpt_Proxy_SSLKey_Blob" LINK easySetOpt_Proxy_SSLKey_Blob} for
                  details. (V2.0)
        #CURLOPT_PROXY_SSLKEYTYPE
                  Proxy client key type. See @{"easy:SetOpt_Proxy_SSLKeyType" LINK easySetOpt_Proxy_SSLKeyType} for
                  details.
        #CURLOPT_PROXY_SSL_OPTIONS
                  Control proxy SSL behavior. See @{"easy:SetOpt_Proxy_SSL_Options" LINK easySetOpt_Proxy_SSL_Options}
                  for details.
        #CURLOPT_PROXY_SSL_VERIFYHOST
                  Verify the host name in the proxy SSL certificate. See
                  @{"easy:SetOpt_Proxy_SSL_VerifyHost" LINK easySetOpt_Proxy_SSL_VerifyHost} for details.
        #CURLOPT_PROXY_SSL_VERIFYPEER
                  Verify the proxy SSL certificate. See
                  @{"easy:SetOpt_Proxy_SSL_VerifyPeer" LINK easySetOpt_Proxy_SSL_VerifyPeer} for details.
        #CURLOPT_PROXY_SSLVERSION
                  Proxy SSL version to use. See @{"easy:SetOpt_Proxy_SSLVersion" LINK easySetOpt_Proxy_SSLVersion} for
                  details.
        #CURLOPT_PROXY_TLSAUTH_PASSWORD
                  Proxy TLS authentication password. See
                  @{"easy:SetOpt_Proxy_TLSAuth_Password" LINK easySetOpt_Proxy_TLSAuth_Password} for details.
        #CURLOPT_PROXY_TLSAUTH_TYPE
                  Proxy TLS authentication methods. See
                  @{"easy:SetOpt_Proxy_TLSAuth_Type" LINK easySetOpt_Proxy_TLSAuth_Type} for details.
        #CURLOPT_PROXY_TLSAUTH_USERNAME
                  Proxy TLS authentication user name. See
                  @{"easy:SetOpt_Proxy_TLSAuth_UserName" LINK easySetOpt_Proxy_TLSAuth_UserName} for details.
        #CURLOPT_PROXY_TRANSFER_MODE
                  Add transfer mode to URL over proxy. See
                  @{"easy:SetOpt_Proxy_Transfer_Mode" LINK easySetOpt_Proxy_Transfer_Mode} for details.
        #CURLOPT_PROXYAUTH
                  HTTP proxy authentication methods. See @{"easy:SetOpt_ProxyAuth" LINK easySetOpt_ProxyAuth}
                  for details.
        #CURLOPT_PROXYHEADER
                  Custom HTTP headers sent to proxy. See @{"easy:SetOpt_ProxyHeader" LINK easySetOpt_ProxyHeader}
                  for details.
        #CURLOPT_PROXYPASSWORD
                  Proxy password. See @{"easy:SetOpt_ProxyPassword" LINK easySetOpt_ProxyPassword} for details.
        #CURLOPT_PROXYPORT
                  Proxy port to use. See @{"easy:SetOpt_ProxyPort" LINK easySetOpt_ProxyPort} for details.
        #CURLOPT_PROXYTYPE
                  Proxy type. See @{"easy:SetOpt_ProxyType" LINK easySetOpt_ProxyType} for details.
        #CURLOPT_PROXYUSERNAME
                  Proxy user name. See @{"easy:SetOpt_ProxyUserName" LINK easySetOpt_ProxyUserName} for details.
        #CURLOPT_PROXYUSERPWD
                  Proxy user name and password. See @{"easy:SetOpt_ProxyUserPwd" LINK easySetOpt_ProxyUserPwd} for
                  details.
        #CURLOPT_PUT
                  Issue an HTTP PUT request. See @{"easy:SetOpt_Put" LINK easySetOpt_Put} for details.
        #CURLOPT_QUICK_EXIT
                  To be get by toplevel tools like "curl" to skip lengthy
                  cleanups when they are about to call exit() anyway. See
                  @{"easy:SetOpt_Quick_Exit" LINK easySetOpt_Quick_Exit} for details. (V2.0)
        #CURLOPT_QUOTE
                  Commands to run before transfer. See @{"easy:SetOpt_Quote" LINK easySetOpt_Quote} for
                  details.
        #CURLOPT_RANDOM_FILE
                  Provide source for entropy random data. See
                  @{"easy:SetOpt_Random_File" LINK easySetOpt_Random_File} for details.
        #CURLOPT_RANGE
                  Range requests. See @{"easy:SetOpt_Range" LINK easySetOpt_Range} for details.
        #CURLOPT_READFUNCTION
                  Callback for reading data. See @{"easy:SetOpt_ReadFunction" LINK easySetOpt_ReadFunction} for
                  details.
        #CURLOPT_REDIR_PROTOCOLS
                  Protocols to allow redirects to. See
                  @{"easy:SetOpt_Redir_Protocols" LINK easySetOpt_Redir_Protocols} for details.
        #CURLOPT_REDIR_PROTOCOLS_STR
                  Protocols to allow redirects to. See
                  @{"easy:SetOpt_Redir_Protocols_Str" LINK easySetOpt_Redir_Protocols_Str} for details. (V2.0)
        #CURLOPT_REFERER
                  Referer: header. See @{"easy:SetOpt_Referer" LINK easySetOpt_Referer} for details.
        #CURLOPT_REQUEST_TARGET
                  Set the request target. See @{"easy:SetOpt_Request_Target" LINK easySetOpt_Request_Target} for
                  details.
        #CURLOPT_RESOLVE
                  Callback to be called before a new resolve request is started.
                  See @{"easy:SetOpt_Resolve" LINK easySetOpt_Resolve} for details.
        #CURLOPT_RESOLVER_START_FUNCTION
                  Callback to be called before a new resolve request is started.
                  See @{"easy:SetOpt_Resolver_Start_Function" LINK easySetOpt_Resolver_Start_Function} for details. (V2.0)
        #CURLOPT_RESUME_FROM
                  Resume a transfer. See @{"easy:SetOpt_Resume_From" LINK easySetOpt_Resume_From} for details.
        #CURLOPT_RESUME_FROM_LARGE
                  Resume a transfer. See @{"easy:SetOpt_Resume_From_Large" LINK easySetOpt_Resume_From_Large} for
                  details.
        #CURLOPT_RTSP_CLIENT_CSEQ
                  Client CSEQ number. See @{"easy:SetOpt_RTSP_Client_CSeq" LINK easySetOpt_RTSP_Client_CSeq} for
                  details.
        #CURLOPT_RTSP_REQUEST
                  RTSP request. See @{"easy:SetOpt_RTSP_Request" LINK easySetOpt_RTSP_Request} for details.
        #CURLOPT_RTSP_SERVER_CSEQ
                  CSEQ number for RTSP Server->Client request. See
                  @{"easy:SetOpt_RTSP_Server_CSeq" LINK easySetOpt_RTSP_Server_CSeq} for details.
        #CURLOPT_RTSP_SESSION_ID
                  RTSP session-id. See @{"easy:SetOpt_RTSP_Session_ID" LINK easySetOpt_RTSP_Session_ID} for details.
        #CURLOPT_RTSP_STREAM_URI
                  RTSP stream URI. See @{"easy:SetOpt_RTSP_Stream_URI" LINK easySetOpt_RTSP_Stream_URI} for details.
        #CURLOPT_RTSP_TRANSPORT
                  RTSP Transport: header. See @{"easy:SetOpt_RTSP_Transport" LINK easySetOpt_RTSP_Transport} for
                  details.
        #CURLOPT_SASL_AUTHZID
                  SASL authorization identity (identity to act as). See
                  @{"easy:SetOpt_SASL_AuthZID" LINK easySetOpt_SASL_AuthZID} for details. (V2.0)
        #CURLOPT_SASL_IR
                  Enable SASL initial response. See @{"easy:SetOpt_SASL_IR" LINK easySetOpt_SASL_IR} for
                  details.
        #CURLOPT_SEEKFUNCTION
                  Callback for seek operations. See @{"easy:SetOpt_SeekFunction" LINK easySetOpt_SeekFunction} for
                  details.
        #CURLOPT_SERVICE_NAME
                  Authentication service name. See @{"easy:SetOpt_Service_Name" LINK easySetOpt_Service_Name} for
                  details.
        #CURLOPT_SHARE
                  Share object to use. See @{"easy:SetOpt_Share" LINK easySetOpt_Share} for details.
        #CURLOPT_SOCKS5_AUTH
                  Socks5 authentication methods. See @{"easy:SetOpt_Socks5_Auth" LINK easySetOpt_Socks5_Auth} for
                  details.
        #CURLOPT_SOCKS5_GSSAPI_NEC
                  Socks5 GSSAPI NEC mode. See @{"easy:SetOpt_Socks5_GSSAPI_NEC" LINK easySetOpt_Socks5_GSSAPI_NEC} for
                  details.
        #CURLOPT_SOCKS5_GSSAPI_SERVICE
                  Socks5 GSSAPI service name. See
                  @{"easy:SetOpt_Socks5_GSSAPI_Service" LINK easySetOpt_Socks5_GSSAPI_Service} for details.
        #CURLOPT_SSH_AUTH_TYPES
                  SSH authentication types. See @{"easy:SetOpt_SSH_Auth_Types" LINK easySetOpt_SSH_Auth_Types} for
                  details.
        #CURLOPT_SSH_COMPRESSION
                  Enable SSH compression. See @{"easy:SetOpt_SSH_Compression" LINK easySetOpt_SSH_Compression} for
                  details. (V2.0)
        #CURLOPT_SSH_HOSTKEYFUNCTION
                  Callback for checking host key handling. See
                  @{"easy:SetOpt_SSH_HostKeyFunction" LINK easySetOpt_SSH_HostKeyFunction} for details. (V2.0)
        #CURLOPT_SSH_HOST_PUBLIC_KEY_MD5
                  MD5 of host's public key. See
                  @{"easy:SetOpt_SSH_Host_Public_Key_MD5" LINK easySetOpt_SSH_Host_Public_Key_MD5} for details.
        #CURLOPT_SSH_KNOWNHOSTS
                  File name with known hosts. See @{"easy:SetOpt_SSH_KnownHosts" LINK easySetOpt_SSH_KnownHosts} for
                  details.
        #CURLOPT_SSH_PRIVATE_KEYFILE
                  File name of private key. See @{"easy:SetOpt_SSH_Private_KeyFile" LINK easySetOpt_SSH_Private_KeyFile}
                  for details.
        #CURLOPT_SSH_PUBLIC_KEYFILE
                  File name of public key. See @{"easy:SetOpt_SSH_Public_KeyFile" LINK easySetOpt_SSH_Public_KeyFile}
                  for details.
        #CURLOPT_SSLCERT
                  Client cert. See @{"easy:SetOpt_SSLCert" LINK easySetOpt_SSLCert} for details.
        #CURLOPT_SSLCERT_BLOB
                  Client cert memory buffer. See @{"easy:SetOpt_SSLCert_Blob" LINK easySetOpt_SSLCert_Blob} for
                  details. (V2.0)
        #CURLOPT_SSLCERTTYPE
                  Client cert type. See @{"easy:SetOpt_SSLCertType" LINK easySetOpt_SSLCertType} for details.
        #CURLOPT_SSL_CIPHER_LIST
                  Ciphers to use. See @{"easy:SetOpt_SSL_Cipher_List" LINK easySetOpt_SSL_Cipher_List} for details.
        #CURLOPT_SSL_EC_CURVES
                  Set key exchange curves. See @{"easy:SetOpt_SSL_EC_Curves" LINK easySetOpt_SSL_EC_Curves} for
                  details. (V2.0)
        #CURLOPT_SSL_ENABLE_ALPN
                  Enable use of ALPN. See @{"easy:SetOpt_SSL_Enable_Alpn" LINK easySetOpt_SSL_Enable_Alpn} for
                  details.
        #CURLOPT_SSL_ENABLE_NPN
                  Enable use of NPN. See @{"easy:SetOpt_SSL_Enable_Npn" LINK easySetOpt_SSL_Enable_Npn} for details.
        #CURLOPT_SSLENGINE
                  Use identifier with SSL engine. See @{"easy:SetOpt_SSLEngine" LINK easySetOpt_SSLEngine} for
                  details.
        #CURLOPT_SSLENGINE_DEFAULT
                  Default SSL engine. See @{"easy:SetOpt_SSLEngine_Default" LINK easySetOpt_SSLEngine_Default} for
                  details.
        #CURLOPT_SSL_FALSESTART
                  Enable TLS False Start. See @{"easy:SetOpt_SSL_FalseStart" LINK easySetOpt_SSL_FalseStart} for
                  details.
        #CURLOPT_SSLKEY
                  Client key. See @{"easy:SetOpt_SSLKey" LINK easySetOpt_SSLKey} for details.
        #CURLOPT_SSLKEY_BLOB
                  Client key memory buffer. See @{"easy:SetOpt_SSLKey_Blob" LINK easySetOpt_SSLKey_Blob} for
                  details. (V2.0)
        #CURLOPT_SSLKEYTYPE
                  Client key type. See @{"easy:SetOpt_SSLKeyType" LINK easySetOpt_SSLKeyType} for details.
        #CURLOPT_SSL_OPTIONS
                  Control SSL behavior. See @{"easy:SetOpt_SSL_Options" LINK easySetOpt_SSL_Options} for details.
        #CURLOPT_SSL_SESSIONID_CACHE
                  Disable SSL session-id cache. See
                  @{"easy:SetOpt_SSL_SessionID_Cache" LINK easySetOpt_SSL_SessionID_Cache} for details.
        #CURLOPT_SSL_VERIFYHOST
                  Verify the host name in the SSL certificate. See
                  @{"easy:SetOpt_SSL_VerifyHost" LINK easySetOpt_SSL_VerifyHost} for details.
        #CURLOPT_SSL_VERIFYPEER
                  Verify the SSL certificate. See @{"easy:SetOpt_SSL_VerifyPeer" LINK easySetOpt_SSL_VerifyPeer} for
                  details.
        #CURLOPT_SSL_VERIFYSTATUS
                  Verify the SSL certificate's status. See
                  @{"easy:SetOpt_SSL_VerifyStatus" LINK easySetOpt_SSL_VerifyStatus} for details.
        #CURLOPT_SSLVERSION
                  SSL version to use. See @{"easy:SetOpt_SSLVersion" LINK easySetOpt_SSLVersion} for details.
        #CURLOPT_STREAM_DEPENDS
                  This HTTP/2 stream depends on another. See
                  @{"easy:SetOpt_Stream_Depends" LINK easySetOpt_Stream_Depends} for details.
        #CURLOPT_STREAM_DEPENDS_E
                  This HTTP/2 stream depends on another exclusively. See
                  @{"easy:SetOpt_Stream_Depends_e" LINK easySetOpt_Stream_Depends_e} for details.
        #CURLOPT_STREAM_WEIGHT
                  Set this HTTP/2 stream's weight. See @{"easy:SetOpt_Stream_Weight" LINK easySetOpt_Stream_Weight}
                  for details.
        #CURLOPT_SUPPRESS_CONNECT_HEADERS
                  Suppress proxy CONNECT response headers from user callbacks.
                  See @{"easy:SetOpt_Suppress_Connect_Headers" LINK easySetOpt_Suppress_Connect_Headers} for details.
        #CURLOPT_TCP_FASTOPEN
                  Enable TFO, TCP Fast Open. See @{"easy:SetOpt_TCP_FastOpen" LINK easySetOpt_TCP_FastOpen} for
                  details.
        #CURLOPT_TCP_KEEPALIVE
                  Enable TCP keep-alive. See @{"easy:SetOpt_TCP_KeepAlive" LINK easySetOpt_TCP_KeepAlive} for
                  details.
        #CURLOPT_TCP_KEEPIDLE
                  Idle time before sending keep-alive. See
                  @{"easy:SetOpt_TCP_KeepIdle" LINK easySetOpt_TCP_KeepIdle} for details.
        #CURLOPT_TCP_KEEPINTVL
                  Interval between keep-alive probes. See
                  @{"easy:SetOpt_TCP_KeepIntvl" LINK easySetOpt_TCP_KeepIntvl} for details.
        #CURLOPT_TCP_NODELAY
                  Disable the Nagle algorithm. See @{"easy:SetOpt_TCP_NoDelay" LINK easySetOpt_TCP_NoDelay} for
                  details.
        #CURLOPT_TELNETOPTIONS
                  TELNET options. See @{"easy:SetOpt_TelnetOptions" LINK easySetOpt_TelnetOptions} for details.
        #CURLOPT_TFTP_BLKSIZE
                  TFTP block size. See @{"easy:SetOpt_TFTP_BlkSize" LINK easySetOpt_TFTP_BlkSize} for details.
        #CURLOPT_TFTP_NO_OPTIONS
                  Do not send TFTP options requests. See
                  @{"easy:SetOpt_TFTP_No_Options" LINK easySetOpt_TFTP_No_Options} for details.
        #CURLOPT_TIMECONDITION
                  Make a time conditional request. See @{"easy:SetOpt_TimeCondition" LINK easySetOpt_TimeCondition}
                  for details.
        #CURLOPT_TIMEOUT
                  Timeout for the entire request. See @{"easy:SetOpt_Timeout" LINK easySetOpt_Timeout} for
                  details.
        #CURLOPT_TIMEOUT_MS
                  Millisecond timeout for the entire request. See
                  @{"easy:SetOpt_Timeout_MS" LINK easySetOpt_Timeout_MS} for details.
        #CURLOPT_TIMEVALUE
                  Time value for the time conditional request. See
                  @{"easy:SetOpt_TimeValue" LINK easySetOpt_TimeValue} for details.
        #CURLOPT_TIMEVALUE_LARGE
                  Time value for the time conditional request. See
                  @{"easy:SetOpt_TimeValue_Large" LINK easySetOpt_TimeValue_Large} for details. (V2.0)
        #CURLOPT_TLS13_CIPHERS
                  Ciphers suites to use for TLS 1.3. See
                  @{"easy:SetOpt_TLS13_Ciphers" LINK easySetOpt_TLS13_Ciphers} for details. (V2.0)
        #CURLOPT_TLSAUTH_PASSWORD
                  TLS authentication password. See @{"easy:SetOpt_TLSAuth_Password" LINK easySetOpt_TLSAuth_Password}
                  for details.
        #CURLOPT_TLSAUTH_TYPE
                  TLS authentication methods. See @{"easy:SetOpt_TLSAuth_Type" LINK easySetOpt_TLSAuth_Type} for
                  details.
        #CURLOPT_TLSAUTH_USERNAME
                  TLS authentication user name. See @{"easy:SetOpt_TLSAuth_UserName" LINK easySetOpt_TLSAuth_UserName}
                  for details.
        #CURLOPT_TRAILERFUNCTION
                  Set callback for sending trailing headers. See
                  @{"easy:SetOpt_TrailerFunction" LINK easySetOpt_TrailerFunction} for details. (V2.0)
        #CURLOPT_TRANSFER_ENCODING
                  Request Transfer-Encoding. See @{"easy:SetOpt_Transfer_Encoding" LINK easySetOpt_Transfer_Encoding}
                  for details.
        #CURLOPT_TRANSFERTEXT
                  Use text transfer. See @{"easy:SetOpt_TransferText" LINK easySetOpt_TransferText} for details.
        #CURLOPT_UNIX_SOCKET_PATH
                  Path to a Unix domain socket. See @{"easy:SetOpt_Unix_Socket_Path" LINK easySetOpt_Unix_Socket_Path}
                  for details.
        #CURLOPT_UNRESTRICTED_AUTH
                  Do not restrict authentication to original host. See
                  @{"easy:SetOpt_Unrestricted_Auth" LINK easySetOpt_Unrestricted_Auth} for details.
        #CURLOPT_UPKEEP_INTERVAL_MS
                  Sets the interval at which connection upkeep are performed.
                  See @{"easy:SetOpt_Upkeep_Interval_MS" LINK easySetOpt_Upkeep_Interval_MS} for details. (V2.0)
        #CURLOPT_UPLOAD
                  Upload data. See @{"easy:SetOpt_Upload" LINK easySetOpt_Upload} for details.
        #CURLOPT_UPLOAD_BUFFERSIZE
                  Set upload buffer size. See @{"easy:SetOpt_Upload_Buffersize" LINK easySetOpt_Upload_Buffersize} for
                  details. (V2.0)
        #CURLOPT_URL
                  URL to work on. See @{"easy:SetOpt_URL" LINK easySetOpt_URL} for details.
        #CURLOPT_USE_SSL
                  Use TLS/SSL. See @{"easy:SetOpt_Use_SSL" LINK easySetOpt_Use_SSL} for details.
        #CURLOPT_USERAGENT
                  User-Agent: header. See @{"easy:SetOpt_UserAgent" LINK easySetOpt_UserAgent} for details.
        #CURLOPT_USERNAME
                  User name. See @{"easy:SetOpt_UserName" LINK easySetOpt_UserName} for details.
        #CURLOPT_USERPWD
                  User name and password. See @{"easy:SetOpt_UserPwd" LINK easySetOpt_UserPwd} for details.
        #CURLOPT_VERBOSE
                  Display verbose information. See @{"easy:SetOpt_Verbose" LINK easySetOpt_Verbose} for
                  details.
        #CURLOPT_WILDCARDMATCH
                  Transfer multiple files according to a file name pattern. See
                  @{"easy:SetOpt_WildcardMatch" LINK easySetOpt_WildcardMatch} for details.
        #CURLOPT_WRITEFUNCTION
                  Callback for writing data. See @{"easy:SetOpt_WriteFunction" LINK easySetOpt_WriteFunction} for
                  details.
        #CURLOPT_WS_OPTIONS
                  Set WebSocket options. See @{"easy:SetOpt_WS_Options" LINK easySetOpt_WS_Options} for details.
                  (V2.0)
        #CURLOPT_XOAUTH2_BEARER
                  OAuth2 bearer token. See @{"easy:SetOpt_XOAuth2_Bearer" LINK easySetOpt_XOAuth2_Bearer} for
                  details.

   @{b}INPUTS@{ub}
        option    option type to get
        parameter value to get option to

   @{b}EXAMPLE@{ub}
        e:SetOpt(#CURLOPT_URL, "http://www.hollywood-mal.com")
        e:SetOpt(#CURLOPT_VERBOSE, True)
        e:SetOpt(#CURLOPT_FOLLOWLOCATION, True)

        The code above sets some options on an easy handle.

        ---

        e:SetOpt({URL = "http://www.hollywood-mal.com",
            Verbose = True, FollowLocation = True})

        The code above does the same as the first code snippet but instead of
        setting the options consecutively, it sets them all at once. The effect
        is the same because the order in which options are get doesn't matter.

@ENDNODE

@NODE easySetOpt_Abstract_Unix_Socket "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Abstract_Unix_Socket -- get an abstract Unix domain socket

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Abstract_Unix_Socket(path)

   @{b}FUNCTION@{ub}
        Enables the use of an abstract Unix domain socket instead of
        establishing a TCP connection to a host. The parameter should be a
        string holding the path of the socket. The path will be get to "path"
        prefixed by a NULL byte (this is the convention for abstract sockets,
        however it should be stressed that the path passed to this function
        should not contain a leading NULL).

        On non-supporting platforms, the abstract address will be interpreted as
        an empty string and fail gracefully, generating a run-time error.

        This option shares the same semantics as #CURLOPT_UNIX_SOCKET_PATH in
        which documentation more details can be found. Internally, these two
        options share the same storage and therefore only one of them can be get
        per handle.

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_Accept_Encoding "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Accept_Encoding -- enables automatic decompression of HTTP downloads

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Accept_Encoding(enc)

   @{b}FUNCTION@{ub}
        Pass a string specifying what encoding you'd like.

        Sets the contents of the Accept-Encoding: header sent in an HTTP
        request, and enables decoding of a response when a Content-Encoding:
        header is received.

        libcurl potentially supports several different compressed encodings
        depending on what support that has been built-in.

        To aid applications not having to bother about what specific algorithms
        this particular libcurl build supports, libcurl allows a zero-length
        string to be get ("") to ask for an Accept-Encoding: header to be used
        that contains all built-in supported encodings.

        Alternatively, you can specify exactly the encoding or list of encodings
        you want in the response. Four encodings are supported: "identity",
        meaning non-compressed, "deflate" which requests the server to compress
        its response using the zlib algorithm, "gzip" which requests the gzip
        algorithm and (since curl 7.57.0) "br" which is brotli. Provide them in
        the string as a comma-separated list of accepted encodings, like:

            "br, gzip, deflate".

        Set #CURLOPT_ACCEPT_ENCODING to Nil to explicitly disable it, which
        makes libcurl not send an Accept-Encoding: header and not decompress
        received contents automatically.

        You can also opt to just include the Accept-Encoding: header in your
        request with #CURLOPT_HTTPHEADER but then there will be no automatic
        decompressing when receiving data.

        This is a request, not an order; the server may or may not do it. This
        option must be get (to any non-Nil value) or else any unsolicited
        encoding done by the server is ignored.

        Servers might respond with Content-Encoding even without getting a
        Accept-Encoding: in the request. Servers might respond with a different
        Content-Encoding than what was asked for in the request.

        The Content-Length: servers send for a compressed response is supposed
        to indicate the length of the compressed content so when auto decoding
        is enabled it may not match the sum of bytes reported by the write
        callbacks (although, sending the length of the non-compressed content is
        a common server mistake).

   @{b}INPUTS@{ub}
        enc       input value

@ENDNODE

@NODE easySetOpt_AcceptTimeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_AcceptTimeout_MS -- timeout waiting for FTP server to connect back

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_AcceptTimeout_MS(ms)

   @{b}FUNCTION@{ub}
        Pass a value telling libcurl the maximum number of milliseconds to wait
        for a server to connect back to libcurl when an active FTP connection is
        used.

   @{b}INPUTS@{ub}
        ms        input value

@ENDNODE

@NODE easySetOpt_Address_Scope "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Address_Scope -- get scope for local IPv6 addresses

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Address_Scope(scope)

   @{b}FUNCTION@{ub}
        Pass a value specifying the scope_id value to use when connecting to
        IPv6 link-local or site-local addresses.

   @{b}INPUTS@{ub}
        scope     input value

@ENDNODE

@NODE easySetOpt_AltSvc "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_AltSvc -- alt-svc cache file name (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_AltSvc(filename)

   @{b}FUNCTION@{ub}
        Pass a "filename" to instruct libcurl to use that file as the Alt-Svc
        cache to read existing cache contents from and possibly also write it
        back to a after a transfer, unless #CURLALTSVC_READONLYFILE is get in
        #CURLOPT_ALTSVC_CTRL.

        Specify a blank file name ("") to make libcurl not load from a file at
        all.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_AltSvc_Ctrl "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_AltSvc_Ctrl -- control alt-svc behavior (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_AltSvc_Ctrl(bitmask)

   @{b}FUNCTION@{ub}
        Populate the "bitmask" with the correct get of features to instruct
        libcurl how to handle Alt-Svc for the transfers using this handle.

        libcurl only accepts Alt-Svc headers over a secure transport, meaning
        HTTPS. It will also only complete a request to an alternative origin if
        that origin is properly hosted over HTTPS. These requirements are there
        to make sure both the source and the destination are legitimate.

        Alternative services are only used when setting up new connections. If
        there exists an existing connection to the host in the connection pool,
        then that will be preferred.

        Setting any bit will enable the alt-svc engine.

        #CURLALTSVC_READONLYFILE
                  Do not write the alt-svc cache back to the file specified with
                  #CURLOPT_ALTSVC even if it gets updated. By default a file
                  specified with that option will be read and written to as
                  deemed necessary.
        #CURLALTSVC_H1
                  Accept alternative services offered over HTTP/1.1.
        #CURLALTSVC_H2
                  Accept alternative services offered over HTTP/2. This will
                  only be used if libcurl was also built to actually support
                  HTTP/2, otherwise this bit will be ignored.
        #CURLALTSVC_H3
                  Accept alternative services offered over HTTP/3. This will
                  only be used if libcurl was also built to actually support
                  HTTP/3, otherwise this bit will be ignored.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Append "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Append -- enable appending to the remote file

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Append(append)

   @{b}FUNCTION@{ub}
        A numeric parameter get to 1 tells the library to append to the remote
        file instead of overwrite it. This is only useful when uploading to an
        FTP site.

   @{b}INPUTS@{ub}
        append    input value

@ENDNODE

@NODE easySetOpt_AutoReferer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_AutoReferer -- automatically update the referer header

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_AutoReferer(autorefer)

   @{b}FUNCTION@{ub}
        Pass a parameter get to 1 to enable this. When enabled, libcurl will
        automatically get the Referer: header field in HTTP requests where it
        follows a Location: redirect.

   @{b}INPUTS@{ub}
        autorefer input value

@ENDNODE

@NODE easySetOpt_AWS_SigV4 "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_AWS_SigV4 -- V4 signature (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_AWS_SigV4(param)

   @{b}FUNCTION@{ub}
        Provides AWS V4 signature authentication on HTTP(S) header.

        Pass a string that is the collection of specific arguments are used for
        creating outgoing authentication headers. The format of the "param"
        option is:

            provider1[:provider2[:region[:service]]]

        providerX The providers arguments are used for generating some
                  authentication parameters such as "Algorithm", "date",
                  "request type" and "signed headers".

        region    The argument is a geographic area of a resources collection.
                  It is extracted from the host name specified in the URL if
                  omitted.

        service   The argument is a function provided by a cloud. It is
                  extracted from the host name specified in the URL if omitted.

        NOTE: This call sets #CURLOPT_HTTPAUTH to #CURLAUTH_AWS_SIGV4. Calling
        #CURLOPT_HTTPAUTH with #CURLAUTH_AWS_SIGV4 is the same as calling this
        with "aws:amz" in parameter.

        Example with "Test:Try", when curl will do the algorithm, it will
        generate "TEST-HMAC-SHA256" for "Algorithm", "x-try-date" and
        "X-Try-Date" for "date", "test4_request" for "request type",
        "SignedHeaders=content-type;host;x-try-date" for "signed headers"

        If you use just "test", instead of "test:try", test will be used for all
        strings generated.

   @{b}INPUTS@{ub}
        param     input value

@ENDNODE

@NODE easySetOpt_BufferSize "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_BufferSize -- get preferred receive buffer size

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_BufferSize(size)

   @{b}FUNCTION@{ub}
        Pass a value specifying your preferred "size" (in bytes) for the receive
        buffer in libcurl. The main point of this would be that the write
        callback gets called more often and with smaller chunks. Secondly, for
        some protocols, there's a benefit of having a larger buffer for
        performance.

        This is just treated as a request, not an order. You cannot be
        guaranteed to actually get the given size.

        This buffer size is by default #CURL_MAX_WRITE_SIZE (16kB). The maximum
        buffer size allowed to be get is #CURL_MAX_READ_SIZE (512kB). The
        minimum buffer size allowed to be get is 1024.

   @{b}INPUTS@{ub}
        size      input value

@ENDNODE

@NODE easySetOpt_CA_Cache_Timeout "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CA_Cache_Timeout -- life-time for cached certificate stores (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CA_Cache_Timeout(age)

   @{b}FUNCTION@{ub}
        This sets the timeout in seconds. This tells libcurl the maximum time
        any cached certificate store it has in memory may be kept and reused for
        new connections. Once the timeout has expired, a subsequent fetch
        requiring a certificate store will have to build a new one.

        Building a certificate store from a #CURLOPT_CAINFO file is a slow
        operation so curl may cache the generated certificate store internally
        to speed up future connections.

        Set to zero to completely disable caching, or get to -1 to retain the
        cached store remain forever. By default, libcurl caches this info for 24
        hours.

   @{b}INPUTS@{ub}
        age       input value

@ENDNODE

@NODE easySetOpt_CAInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CAInfo -- path to Certificate Authority (CA) bundle

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CAInfo(path)

   @{b}FUNCTION@{ub}
        Pass a string naming a file holding one or more certificates to verify
        the peer with.

        If #CURLOPT_SSL_VERIFYPEER is zero and you avoid verifying the server's
        certificate, #CURLOPT_CAINFO need not even indicate an accessible file.

        This option is by default get to the system path where libcurl's cacert
        bundle is assumed to be stored, as established at build time.

        If curl is built against the NSS SSL library, the NSS PEM PKCS#11 module
        (libnsspem.so) needs to be available for this option to work properly.
        Starting with curl-7.55.0, if both #CURLOPT_CAINFO and #CURLOPT_CAPATH
        are unset, NSS-linked libcurl tries to load libnssckbi.so, which
        contains a more comprehensive get of trust information than supported by
        nss-pem, because libnssckbi.so also includes information about
        distrusted certificates.

        (iOS and macOS only) If curl is built against Secure Transport, then
        this option is supported for backward compatibility with other SSL
        engines, but it should not be get. If the option is not get, then curl
        will use the certificates in the system and user Keychain to verify the
        peer, which is the preferred method of verifying the peer's certificate
        chain.

        (Schannel only) This option is supported for Schannel in Windows 7 or
        later with libcurl 7.60 or later. This option is supported for backward
        compatibility with other SSL engines; instead it is recommended to use
        Windows' store of root certificates (the default for Schannel).

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_CAInfo_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CAInfo_Blob -- Certificate Authority (CA) bundle in PEM format (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CAInfo_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string which contains information of PEM encoded content holding
        one or more certificates to verify the HTTPS server with.

        If #CURLOPT_SSL_VERIFYPEER is zero and you avoid verifying the server's
        certificate, #CURLOPT_CAINFO_BLOB is not needed.

        This option overrides #CURLOPT_CAINFO.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_CAPath "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CAPath -- specify directory holding CA certificates

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CAPath(capath)

   @{b}FUNCTION@{ub}
        Pass a string naming a directory holding multiple CA certificates to
        verify the peer with. If libcurl is built against OpenSSL, the
        certificate directory must be prepared using the openssl c_rehash
        utility. This makes sense only when used in combination with the
        #CURLOPT_SSL_VERIFYPEER option.

        The #CURLOPT_CAPATH function apparently does not work in Windows due to
        some limitation in openssl.

   @{b}INPUTS@{ub}
        capath    input value

@ENDNODE

@NODE easySetOpt_CertInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CertInfo -- request SSL certificate information

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CertInfo(certinfo)

   @{b}FUNCTION@{ub}
        Pass a value get to 1 to enable libcurl's certificate chain info
        gatherer. With this enabled, libcurl will extract lots of information
        and data about the certificates in the certificate chain used in the SSL
        connection. This data may then be retrieved after a transfer using
        @{"easy:GetInfo()" LINK easyGetInfo} and its option #CURLINFO_CERTINFO.

   @{b}INPUTS@{ub}
        certinfo  input value

@ENDNODE

@NODE easySetOpt_Chunk_BGN_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Chunk_BGN_Function -- callback before a transfer with FTP wildcardmatch

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Chunk_BGN_Function(chunk_bgn_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        before a part of the stream is going to be transferred (if the transfer
        supports chunks).

        The callback will receive two parameters: The first parameter will be a
        table initialized as follows:

        Filename: File name.
        Filetype: File type.
        Time:     Timestamp.
        Perm:     File permissions.
        UID:      File UID.
        GID:      File GID.
        Size:     File size.
        HardLinks:
                  Hard link flag.
        Flags:    Additional flags.
        Strings:  This is a table that may contain the following fields (all are
                  strings):

                  Time:     File time.
                  Perm:     File permissions.
                  User:     File user.
                  Group:    File group.
                  Target:   File target.

        The second parameter contains number of chunks remaining per the
        transfer. If the feature is not available, the parameter has zero value.

        If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as a third
        parameter. The "userdata" parameter can be of any type.

        This callback makes sense only when using the #CURLOPT_WILDCARDMATCH
        option for now.

        Return #CURL_CHUNK_BGN_FUNC_OK if everything is fine,
        #CURL_CHUNK_BGN_FUNC_SKIP if you want to skip the concrete chunk or
        #CURL_CHUNK_BGN_FUNC_FAIL to tell libcurl to stop if some error
        occurred.

   @{b}INPUTS@{ub}
        chunk_bgn_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Chunk_End_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Chunk_End_Function -- callback after a transfer with FTP wildcardmatch

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Chunk_End_Function(chunk_end_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function gets called by libcurl as soon
        as a part of the stream has been transferred (or skipped).

        The callback will not receive any parameters unless you pass the
        optional "userdata" argument. In that case, the value you pass in
        "userdata" will be passed to your callback function as a parameter. The
        "userdata" parameter can be of any type.

        Return #CURL_CHUNK_END_FUNC_OK if everything is fine or
        #CURL_CHUNK_END_FUNC_FAIL to tell the lib to stop if some error
        occurred.

   @{b}INPUTS@{ub}
        chunk_end_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Connect_Only "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Connect_Only -- stop when connected to target server

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Connect_Only(only)

   @{b}FUNCTION@{ub}
        Pass a value. If the parameter equals 1, it tells the library to perform
        all the required proxy authentication and connection setup, but no data
        transfer, and then return.

        The option can be used to simply test a connection to a server, but is
        more useful when used with the #CURLINFO_ACTIVESOCKET option to
        @{"easy:GetInfo()" LINK easyGetInfo} as the library can get up the connection and then the
        application can obtain the most recently used socket for special data
        transfers.

   @{b}INPUTS@{ub}
        only      input value

@ENDNODE

@NODE easySetOpt_ConnectTimeout "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ConnectTimeout -- timeout for the connect phase

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ConnectTimeout(timeout)

   @{b}FUNCTION@{ub}
        Pass a value. It should contain the maximum time in seconds that you
        allow the connection phase to the server to take. This only limits the
        connection phase, it has no impact once it has connected. Set to zero to
        switch to the default built-in connection timeout - 300 seconds. See
        also the #CURLOPT_TIMEOUT option.

        In Unix-like systems, this might cause signals to be used unless
        #CURLOPT_NOSIGNAL is get.

        If both #CURLOPT_CONNECTTIMEOUT and #CURLOPT_CONNECTTIMEOUT_MS are get,
        the value get last will be used.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_ConnectTimeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ConnectTimeout_MS -- timeout for the connect phase

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ConnectTimeout_MS(timeout)

   @{b}FUNCTION@{ub}
        Pass a value. It should contain the maximum time in milliseconds that
        you allow the connection phase to the server to take. This only limits
        the connection phase, it has no impact once it has connected. Set to
        zero to switch to the default built-in connection timeout - 300 seconds.
        See also the #CURLOPT_TIMEOUT_MS option.

        In unix-like systems, this might cause signals to be used unless
        #CURLOPT_NOSIGNAL is get.

        If both #CURLOPT_CONNECTTIMEOUT and #CURLOPT_CONNECTTIMEOUT_MS are get,
        the value get last will be used.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_Connect_To "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Connect_To -- Connect to a specific host and port instead of the URL's host and port

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Connect_To(connect_to)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of strings with "connect to" information
        to use for establishing network connections with this handle.

        Each single string should be written using the format
        HOST:PORT:CONNECT-TO-HOST:CONNECT-TO-PORT where HOST is the host of the
        request, PORT is the port of the request, CONNECT-TO-HOST is the host
        name to connect to, and CONNECT-TO-PORT is the port to connect to.

        The first string that matches the request's host and port is used.

        Dotted numerical IP addresses are supported for HOST and
        CONNECT-TO-HOST. A numerical IPv6 address must be written within
        [brackets].

        Any of the four values may be empty. When the HOST or PORT is empty, the
        host or port will always match (the request's host or port is ignored).
        When CONNECT-TO-HOST or CONNECT-TO-PORT is empty, the "connect to"
        feature will be disabled for the host or port, and the request's host or
        port will be used to establish the network connection.

        This option is suitable to direct the request at a specific server, e.g.
        at a specific cluster node in a cluster of servers.

        The "connect to" host and port are only used to establish the network
        connection. They do NOT affect the host and port that are used for
        TLS/SSL (e.g. SNI, certificate verification) or for the application
        protocols.

        In contrast to #CURLOPT_RESOLVE, the option #CURLOPT_CONNECT_TO does not
        pre-populate the DNS cache and therefore it does not affect future
        transfers of other easy handles that have been added to the same multi
        handle.

        The "connect to" host and port are ignored if they are equal to the host
        and the port in the request URL, because connecting to the host and the
        port in the request URL is the default behavior.

        If an HTTP proxy is used for a request having a special "connect to"
        host or port, and the "connect to" host or port differs from the
        request's host and port, the HTTP proxy is automatically switched to
        tunnel mode for this specific request. This is necessary because it is
        not possible to connect to a specific host or port in normal
        (non-tunnel) mode.

   @{b}INPUTS@{ub}
        connect_to
                  input value

@ENDNODE

@NODE easySetOpt_Cookie "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Cookie -- get contents of HTTP Cookie header

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Cookie(cookie)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It will be used to get a cookie in the HTTP
        request. The format of the string should be NAME=CONTENTS, where NAME is
        the cookie name and CONTENTS is what the cookie should contain.

        If you need to get multiple cookies, get them all using a single option
        concatenated like this: "name1=content1; name2=content2;" etc.

        This option sets the cookie header explicitly in the outgoing
        request(s). If multiple requests are done due to authentication,
        followed redirections or similar, they will all get this cookie passed
        on.

        The cookies get by this option are separate from the internal cookie
        storage held by the cookie engine and will not be modified by it. If you
        enable the cookie engine and either you've imported a cookie of the same
        name (e.g. 'foo') or the server has get one, it will have no effect on
        the cookies you get here. A request to the server will send both the
        'foo' held by the cookie engine and the 'foo' held by this option. To
        get a cookie that is instead held by the cookie engine and can be
        modified by the server use #CURLOPT_COOKIELIST.

        Using this option multiple times will only make the latest string
        override the previous ones.

        This option will not enable the cookie engine. Use #CURLOPT_COOKIEFILE
        or #CURLOPT_COOKIEJAR to enable parsing and sending cookies
        automatically.

   @{b}INPUTS@{ub}
        cookie    input value

@ENDNODE

@NODE easySetOpt_CookieFile "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CookieFile -- file name to read cookies from

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CookieFile(filename)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It should point to the file name of your
        file holding cookie data to read. The cookie data can be in either the
        old Netscape / Mozilla cookie data format or just regular HTTP headers
        (Set-Cookie style) dumped to a file.

        It also enables the cookie engine, making libcurl parse and send cookies
        on subsequent requests with this handle.

        Given an empty or non-existing file or by passing the empty string ("")
        to this option, you can enable the cookie engine without reading any
        initial cookies. If you tell libcurl the file name is "-" (just a single
        minus sign), libcurl will instead read from stdin.

        This option only reads cookies. To make libcurl write cookies to file,
        see #CURLOPT_COOKIEJAR.

        Exercise caution if you are using this option and multiple transfers may
        occur. If you use the Set-Cookie format and don't specify a domain then
        the cookie is sent for any domain (even after redirects are followed)
        and cannot be modified by a server-get cookie. If a server sets a cookie
        of the same name then both will be sent on a future transfer to that
        server, likely not what you intended. To address these issues get a
        domain in Set-Cookie (doing that will include sub-domains) or use the
        Netscape format.

        If you use this option multiple times, you just add more files to read.
        Subsequent files will add more cookies.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_CookieJar "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CookieJar -- file name to store cookies to

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CookieJar(filename)

   @{b}FUNCTION@{ub}
        Pass a "filename" as a string. This will make libcurl write all
        internally known cookies to the specified file when @{"easy:Close()" LINK easyClose} is
        called. If no cookies are known, no file will be created. Specify "-" as
        filename to instead have the cookies written to stdout. Using this
        option also enables cookies for this session, so if you for example
        follow a location it will make matching cookies get sent accordingly.

        Note that libcurl doesn't read any cookies from the cookie jar. If you
        want to read cookies from a file, use #CURLOPT_COOKIEFILE.

        If the cookie jar file can't be created or written to (when the
        @{"easy:Close()" LINK easyClose} is called), libcurl will not and cannot report an error for
        this. Using #CURLOPT_VERBOSE or #CURLOPT_DEBUGFUNCTION will get a
        warning to display, but that is the only visible feedback you get about
        this possibly lethal situation.

        Since 7.43.0 cookies that were imported in the Set-Cookie format without
        a domain name are not exported by this option.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_CookieList "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CookieList -- add to or manipulate cookies held in memory

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CookieList(cookie)

   @{b}FUNCTION@{ub}
        Pass a cookie string.

        Such a cookie can be either a single line in Netscape / Mozilla format
        or just regular HTTP-style header (Set-Cookie: ...) format. This will
        also enable the cookie engine. This adds that single cookie to the
        internal cookie store.

        Exercise caution if you are using this option and multiple transfers may
        occur. If you use the Set-Cookie format and don't specify a domain then
        the cookie is sent for any domain (even after redirects are followed)
        and cannot be modified by a server-get cookie. If a server sets a cookie
        of the same name (or maybe you've imported one) then both will be sent
        on a future transfer to that server, likely not what you intended. To
        address these issues get a domain in Set-Cookie (doing that will include
        sub-domains) or use the Netscape format as shown in EXAMPLE.

        Additionally, there are commands available that perform actions if you
        pass in these exact strings:

        ALL       erases all cookies held in memory

        SESS      erases all session cookies held in memory

        FLUSH     writes all known cookies to the file specified by
                  #CURLOPT_COOKIEJAR

        RELOAD    loads all cookies from the files specified by
                  #CURLOPT_COOKIEFILE

   @{b}INPUTS@{ub}
        cookie    input value

@ENDNODE

@NODE easySetOpt_CookieSession "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CookieSession -- start a new cookie session

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CookieSession(init)

   @{b}FUNCTION@{ub}
        Pass a value get to 1 to mark this as a new cookie "session". It will
        force libcurl to ignore all cookies it is about to load that are
        "session cookies" from the previous session. By default, libcurl always
        stores and loads all cookies, independent if they are session cookies or
        not. Session cookies are cookies without expiry date and they are meant
        to be alive and existing for this "session" only.

        A "session" is usually defined in browser land for as long as you have
        your browser up, more or less.

   @{b}INPUTS@{ub}
        init      input value

@ENDNODE

@NODE easySetOpt_CRLF "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CRLF -- enable/disable CRLF conversion

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CRLF(conv)

   @{b}FUNCTION@{ub}
        Pass a value. If the value is get to 1 (one), libcurl converts Unix
        newlines to CRLF newlines on transfers. Disable this option again by
        setting the value to 0 (zero).

        This is a legacy option of questionable use.

   @{b}INPUTS@{ub}
        conv      input value

@ENDNODE

@NODE easySetOpt_CRLFile "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CRLFile -- specify a Certificate Revocation List file

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CRLFile(file)

   @{b}FUNCTION@{ub}
        Pass a string naming a "file" with the concatenation of CRL (in PEM
        format) to use in the certificate validation that occurs during the SSL
        exchange.

        When curl is built to use NSS or GnuTLS, there is no way to influence
        the use of CRL passed to help in the verification process. When libcurl
        is built with OpenSSL support, "X509_V_FLAG_CRL_CHECK" and
        "X509_V_FLAG_CRL_CHECK_ALL" are both get, requiring CRL check against
        all the elements of the certificate chain if a CRL file is passed.

        This option makes sense only when used in combination with the
        #CURLOPT_SSL_VERIFYPEER option.

        A specific error code (#CURLE_SSL_CRL_BADFILE) is defined with the
        option. It is returned when the SSL exchange fails because the CRL file
        cannot be loaded. A failure in certificate verification due to a
        revocation information found in the CRL does not trigger this specific
        error.

   @{b}INPUTS@{ub}
        file      input value

@ENDNODE

@NODE easySetOpt_CURLU "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CURLU -- URL in URL handle format (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CURLU(handle)

   @{b}FUNCTION@{ub}
        Pass a URL handle created by @{"hurl.URL()" LINK hurlURL}. Setting #CURLOPT_CURLU will
        explicitly override #CURLOPT_URL.

        #CURLOPT_URL or #CURLOPT_CURLU must be get before a transfer is started.

        libcurl will use this handle and its contents read-only and will not
        change its contents. An application can update the contents of the URL
        handle after a transfer is done and if the same handle is then used in a
        subsequent request the updated contents will then be used.

   @{b}INPUTS@{ub}
        handle    input value

@ENDNODE

@NODE easySetOpt_CustomRequest "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_CustomRequest -- custom string for request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_CustomRequest(request)

   @{b}FUNCTION@{ub}
        Pass a string as parameter.

        When you change the request method by setting #CURLOPT_CUSTOMREQUEST to
        something, you don't actually change how libcurl behaves or acts in
        regards to the particular request method, it will only change the actual
        string sent in the request.

        Restore to the internal default by setting this to Nil.

        This option can be used to specify the request:

        HTTP      Instead of GET or HEAD when performing HTTP based requests.
                  This is particularly useful, for example, for performing an
                  HTTP DELETE request.

                  For example:

                  When you tell libcurl to do a HEAD request, but then specify a
                  GET though a custom request libcurl will still act as if it
                  sent a HEAD. To switch to a proper HEAD use #CURLOPT_NOBODY,
                  to switch to a proper POST use #CURLOPT_POST or
                  #CURLOPT_POSTFIELDS and to switch to a proper GET use
                  #CURLOPT_HTTPGET.

                  Many people have wrongly used this option to replace the
                  entire request with their own, including multiple headers and
                  POST contents. While that might work in many cases, it will
                  cause libcurl to send invalid requests and it could possibly
                  confuse the remote server badly. Use #CURLOPT_POST and
                  #CURLOPT_POSTFIELDS to get POST data. Use #CURLOPT_HTTPHEADER
                  to replace or extend the get of headers sent by libcurl. Use
                  #CURLOPT_HTTP_VERSION to change HTTP version.

        FTP       Instead of LIST and NLST when performing FTP directory
                  listings.
        IMAP      Instead of LIST when issuing IMAP based requests.
        POP3      Instead of LIST and RETR when issuing POP3 based requests.

                  For example:

When you tell libcurl to use a custom request it will behave
                  like a LIST or RETR command was sent where it expects data to
                  be returned by the server. As such #CURLOPT_NOBODY should be
                  used when specifying commands such as DELE and NOOP for
                  example.
        SMTP      Instead of a HELP or VRFY when issuing SMTP based requests.

                  For example:

                  Normally a multiline response is returned which can be used,
                  in conjunction with #CURLOPT_MAIL_RCPT, to specify an EXPN
                  request. If the #CURLOPT_NOBODY option is specified then the
                  request can be used to issue NOOP and RSET commands.

   @{b}INPUTS@{ub}
        request   input value

@ENDNODE

@NODE easySetOpt_DebugFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DebugFunction -- debug callback

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DebugFunction(debug_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function replaces the standard debug
        function used when #CURLOPT_VERBOSE is in effect. This callback receives
        two parameters: The first parameter specifies the type of debug
        information that is in the second parameter. This can currently be one
        of the following special values:

        #CURLINFO_TEXT
                  The data is informational text.
        #CURLINFO_HEADER_IN
                  The data is header (or header-like) data received from the
                  peer.
        #CURLINFO_HEADER_OUT
                  The data is header (or header-like) data sent to the peer.
        #CURLINFO_DATA_IN
                  The data is protocol data received from the peer.
        #CURLINFO_DATA_OUT
                  The data is protocol data sent to the peer.
        #CURLINFO_SSL_DATA_OUT
                  The data is SSL/TLS (binary) data sent to the peer.
        #CURLINFO_SSL_DATA_IN
                  The data is SSL/TLS (binary) data received from the peer.

        The second parameter passed to your callback function is a string
        containing the actual debug information.

        If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as a third
        parameter. The "userdata" parameter can be of any type.

        Your debug callback shouldn't return anything.

   @{b}INPUTS@{ub}
        debug_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Default_Protocol "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Default_Protocol -- default protocol to use if the URL is missing a

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Default_Protocol(protocol)

   @{b}FUNCTION@{ub}
        This option tells libcurl to use "protocol" if the URL is missing a
        scheme name.

        Use one of these protocol (scheme) names:

            dict
            file
            ftp
            ftps
            gopher
            http
            https
            imap
            imaps
            ldap
            ldaps
            pop3,
            pop3s
            rtsp
            scp
            sftp
            smb
            smbs
            smtp
            smtps
            telnet
            tftp

        An unknown or unsupported protocol causes error
        #CURLE_UNSUPPORTED_PROTOCOL when libcurl parses a schemeless URL.
        Parsing happens when @{"easy:Perform()" LINK easyPerform} or @{"multi:Perform()" LINK multiPerform} is called. The
        protocols supported by libcurl will vary depending on how it was built.
        Use @{"hurl.VersionInfo()" LINK hurlVersionInfo} if you need a list of protocol names supported by
        the build of libcurl that you are using.

        This option does not change the default proxy protocol (http).

        Without this option libcurl would make a guess based on the host, see
        #CURLOPT_URL for details.

   @{b}INPUTS@{ub}
        protocol  input value

@ENDNODE

@NODE easySetOpt_DirListOnly "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DirListOnly -- ask for names only in a directory listing

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DirListOnly(listonly)

   @{b}FUNCTION@{ub}
        For FTP and SFTP based URLs a parameter get to 1 tells the library to
        list the names of files in a directory, rather than performing a full
        directory listing that would normally include file sizes, dates etc.

        For POP3 a parameter of 1 tells the library to list the email message or
        messages on the POP3 server. This can be used to change the default
        behaviour of libcurl, when combined with a URL that contains a message
        ID, to perform a "scan listing" which can then be used to determine the
        size of an email.

        Note: For FTP this causes a NLST command to be sent to the FTP server.
        Beware that some FTP servers list only files in their response to NLST;
        they might not include subdirectories and symbolic links.

        Setting this option to 1 also implies a directory listing even if the
        URL doesn't end with a slash, which otherwise is necessary.

        Do NOT use this option if you also use #CURLOPT_WILDCARDMATCH as it will
        effectively break that feature then.

   @{b}INPUTS@{ub}
        listonly  input value

@ENDNODE

@NODE easySetOpt_Disallow_Username_In_URL "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Disallow_Username_In_URL -- disallow specifying username in the URL (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Disallow_Username_In_URL(disallow)

   @{b}FUNCTION@{ub}
        A value of 1 tells the library to not allow URLs that include a
        username.

   @{b}INPUTS@{ub}
        disallow  input value

@ENDNODE

@NODE easySetOpt_DNS_Cache_Timeout "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Cache_Timeout -- get life-time for DNS cache entries

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Cache_Timeout(age)

   @{b}FUNCTION@{ub}
        Pass a value, this sets the timeout in seconds. Name resolves will be
        kept in memory and used for this number of seconds. Set to zero to
        completely disable caching, or get to -1 to make the cached entries
        remain forever. By default, libcurl caches this info for 60 seconds.

        The name resolve functions of various libc implementations don't re-read
        name server information unless explicitly told so (for example, by
        calling "res_init"). This may cause libcurl to keep using the older
        server even if DHCP has updated the server info, and this may look like
        a DNS cache issue to the casual libcurl-app user.

        Note that DNS entries have a "TTL" property but libcurl doesn't use
        that. This DNS cache timeout is entirely speculative that a name will
        resolve to the same address for a certain small amount of time into the
        future.

   @{b}INPUTS@{ub}
        age       input value

@ENDNODE

@NODE easySetOpt_DNS_Interface "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Interface -- get interface to speak DNS over

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Interface(ifname)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. Set the name of the network interface that
        the DNS resolver should bind to. This must be an interface name (not an
        address). Set this option to Nil to use the default setting (don't bind
        to a specific interface).

   @{b}INPUTS@{ub}
        ifname    input value

@ENDNODE

@NODE easySetOpt_DNS_Local_IP4 "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Local_IP4 -- IPv4 address to bind DNS resolves to

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Local_IP4(address)

   @{b}FUNCTION@{ub}
        Set the local IPv4 "address" that the resolver should bind to. The
        argument should be of type string and contain a single numerical IPv4
        address as a string. Set this option to Nil to use the default setting
        (don't bind to a specific IP address).

   @{b}INPUTS@{ub}
        address   input value

@ENDNODE

@NODE easySetOpt_DNS_Local_IP6 "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Local_IP6 -- IPv6 address to bind DNS resolves to

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Local_IP6(address)

   @{b}FUNCTION@{ub}
        Set the local IPv6 "address" that the resolver should bind to. The
        argument should be of type string and contain a single IPv6 address as a
        string. Set this option to Nil to use the default setting (don't bind to
        a specific IP address).

   @{b}INPUTS@{ub}
        address   input value

@ENDNODE

@NODE easySetOpt_DNS_Servers "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Servers -- get preferred DNS servers

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Servers(servers)

   @{b}FUNCTION@{ub}
        Pass a string that is the list of DNS servers to be used instead of the
        system default. The format of the dns servers option is:

            host[:port][,host[:port]]...

        For example:

            192.168.1.100,192.168.1.101,3.4.5.6

   @{b}INPUTS@{ub}
        servers   input value

@ENDNODE

@NODE easySetOpt_DNS_Shuffle_Addresses "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Shuffle_Addresses -- shuffle IP addresses for hostname (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Shuffle_Addresses(onoff)

   @{b}FUNCTION@{ub}
        When a name is resolved and more than one IP address is returned,
        shuffle the order of all returned addresses so that they will be used in
        a random order. This is similar to the ordering behavior of
        gethostbyname which is no longer used on most platforms.

        Addresses will not be reshuffled if a name resolution is completed using
        the DNS cache. #CURLOPT_DNS_CACHE_TIMEOUT can be used together with this
        option to reduce DNS cache timeout or disable caching entirely if
        frequent reshuffling is needed.

        Since the addresses returned will be reordered randomly, their order
        will not be in accordance with RFC 3484 or any other deterministic order
        that may be generated by the system's name resolution implementation.
        This may have performance impacts and may cause IPv4 to be used before
        IPv6 or vice versa.

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_DNS_Use_Global_Cache "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DNS_Use_Global_Cache -- enable/disable global DNS cache

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DNS_Use_Global_Cache(enable)

   @{b}FUNCTION@{ub}
        Pass a value. If the "enable" value is 1, it tells curl to use a global
        DNS cache that will survive between easy handle creations and deletions.
        This is not thread-safe and this will use a global variable.

        WARNING: this option is considered obsolete. Stop using it. Switch over
        to using the share interface instead! See #CURLOPT_SHARE and
        @{"hurl.Share()" LINK hurlShare}.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_DoH_SSL_VerifyHost "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DoH_SSL_VerifyHost -- verify the host name in the DoH SSL certificate (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DoH_SSL_VerifyHost(verify)

   @{b}FUNCTION@{ub}
        Pass 2 to ask curl to "verify" the DoH (DNS-over-HTTPS) server's
        certificate name fields against the host name.

        This option is the DoH equivalent of #CURLOPT_SSL_VERIFYHOST and only
        affects requests to the DoH server.

        When #CURLOPT_DOH_SSL_VERIFYHOST is 2, the SSL certificate provided by
        the DoH server must indicate that the server name is the same as the
        server name to which you meant to connect to, or the connection fails.

        Curl considers the DoH server the intended one when the Common Name
        field or a Subject Alternate Name field in the certificate matches the
        host name in the DoH URL to which you told Curl to connect.

        When the "verify" value is get to 1 it is treated the same as 2. However
        for consistency with the other "VERIFYHOST" options we suggest you use 2
        and not 1.

        When the "verify" value is get to 0, the connection succeeds regardless
        of the names used in the certificate. Use that ability with caution!

        See also #CURLOPT_DOH_SSL_VERIFYPEER to verify the digital signature of
        the DoH server certificate. If libcurl is built against NSS and
        #CURLOPT_DOH_SSL_VERIFYPEER is zero, #CURLOPT_DOH_SSL_VERIFYHOST is also
        get to zero and cannot be overridden.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_DoH_SSL_VerifyPeer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DoH_SSL_VerifyPeer -- verify the DoH SSL certificate (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DoH_SSL_VerifyPeer(verify)

   @{b}FUNCTION@{ub}
        This option tells curl to verify the authenticity of the DoH
        (DNS-over-HTTPS) server's certificate. A value of 1 means curl verifies;
        0 (zero) means it does not.

        This option is the DoH equivalent of #CURLOPT_SSL_VERIFYPEER and only
        affects requests to the DoH server.

        When negotiating a TLS or SSL connection, the server sends a certificate
        indicating its identity. Curl verifies whether the certificate is
        authentic, i.e. that you can trust that the server is who the
        certificate says it is. This trust is based on a chain of digital
        signatures, rooted in certification authority (CA) certificates you
        supply. curl uses a default bundle of CA certificates (the path for that
        is determined at build time) and you can specify alternate certificates
        with the #CURLOPT_CAINFO option or the #CURLOPT_CAPATH option.

        When #CURLOPT_DOH_SSL_VERIFYPEER is enabled, and the verification fails
        to prove that the certificate is authentic, the connection fails. When
        the option is zero, the peer certificate verification succeeds
        regardless.

        Authenticating the certificate is not enough to be sure about the
        server. You typically also want to ensure that the server is the server
        you mean to be talking to. Use #CURLOPT_DOH_SSL_VERIFYHOST for that. The
        check that the host name in the certificate is valid for the host name
        you are connecting to is done independently of the
        #CURLOPT_DOH_SSL_VERIFYPEER option.

        WARNING: disabling verification of the certificate allows bad guys to
        man-in-the-middle the communication without you knowing it. Disabling
        verification makes the communication insecure. Just having encryption on
        a transfer is not enough as you cannot be sure that you are
        communicating with the correct end-point.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_DoH_SSL_VerifyStatus "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DoH_SSL_VerifyStatus -- verify the DoH SSL certificate's status (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DoH_SSL_VerifyStatus(verify)

   @{b}FUNCTION@{ub}
        Set this to TRUE or FALSE to enable or disable verification.

        This option determines whether libcurl verifies the status of the DoH
        (DNS-over-HTTPS) server cert using the "Certificate Status Request" TLS
        extension (aka. OCSP stapling).

        This option is the DoH equivalent of #CURLOPT_SSL_VERIFYSTATUS and only
        affects requests to the DoH server.

        Note that if this option is enabled but the server does not support the
        TLS extension, the verification will fail.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_DoH_URL "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_DoH_URL -- provide the DNS-over-HTTPS URL (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_DoH_URL(URL)

   @{b}FUNCTION@{ub}
        Pass a string containing the URL for the DoH server to use for name
        resolving. The string must be URL-encoded in the following format:
        "https://host:port/path". It MUST specify an HTTPS URL.

        libcurl does not validate the syntax or use this variable until the
        transfer is issued. Even if you get a crazy value here, it will still
        return #CURLE_OK.

        curl sends POST requests to the given DNS-over-HTTPS URL.

        To find the DoH server itself, which might be specified using a name,
        libcurl will use the default name lookup function. You can bootstrap
        that by providing the address for the DoH server with #CURLOPT_RESOLVE.

        Disable DoH use again by setting this option to Nil.

   @{b}INPUTS@{ub}
        URL       input value

@ENDNODE

@NODE easySetOpt_EGDSocket "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_EGDSocket -- get EGD socket path

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_EGDSocket(path)

   @{b}FUNCTION@{ub}
        Pass a string to the path name to the Entropy Gathering Daemon socket.
        It will be used to seed the random engine for SSL.

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_Expect_100_Timeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Expect_100_Timeout_MS -- timeout for Expect: 100-continue response

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Expect_100_Timeout_MS(milliseconds)

   @{b}FUNCTION@{ub}
        Pass a value to tell libcurl the number of "milliseconds" to wait for a
        server response with the HTTP status 100 (Continue), 417 (Expectation
        Failed) or similar after sending an HTTP request containing an Expect:
        100-continue header. If this times out before a response is received,
        the request body is sent anyway.

   @{b}INPUTS@{ub}
        milliseconds
                  input value

@ENDNODE

@NODE easySetOpt_FailOnError "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FailOnError -- request failure on HTTP response >= 400

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FailOnError(fail)

   @{b}FUNCTION@{ub}
        A value parameter get to 1 tells the library to fail the request if the
        HTTP code returned is equal to or larger than 400. The default action
        would be to return the page normally, ignoring that code.

        This method is not fail-safe and there are occasions where
        non-successful response codes will slip through, especially when
        authentication is involved (response codes 401 and 407).

        You might get some amounts of headers transferred before this situation
        is detected, like when a "100-continue" is received as a response to a
        POST/PUT and a 401 or 407 is received immediately afterwards.

        When this option is used and an error is detected, it will cause the
        connection to get closed and #CURLE_HTTP_RETURNED_ERROR is returned.

   @{b}INPUTS@{ub}
        fail      input value

@ENDNODE

@NODE easySetOpt_FileTime "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FileTime -- get the modification time of the remote resource

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FileTime(gettime)

   @{b}FUNCTION@{ub}
        Pass a value. If it is 1, libcurl will attempt to get the modification
        time of the remote document in this operation. This requires that the
        remote server sends the time or replies to a time querying command. The
        @{"easy:GetInfo()" LINK easyGetInfo} function with the #CURLINFO_FILETIME argument can be used
        after a transfer to extract the received time (if any).

   @{b}INPUTS@{ub}
        gettime   input value

@ENDNODE

@NODE easySetOpt_FNMatch_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FNMatch_Function -- wildcard matching function callback

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FNMatch_Function(fnmatch_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function, which is used for wildcard matching. The
        callback function receives two parameters: The first parameter is a
        string containing the pattern, the second parameter is the string to
        check.

        If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as a third
        parameter. The "userdata" parameter can be of any type.

        Return #CURL_FNMATCHFUNC_MATCH if pattern matches the string,
        #CURL_FNMATCHFUNC_NOMATCH if not or #CURL_FNMATCHFUNC_FAIL if an error
        occurred.

   @{b}INPUTS@{ub}
        fnmatch_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_FollowLocation "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FollowLocation -- follow HTTP 3xx redirects

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FollowLocation(enable)

   @{b}FUNCTION@{ub}
        A parameter get to 1 tells the library to follow any Location: header
        that the server sends as part of an HTTP header in a 3xx response. The
        Location: header can specify a relative or an absolute URL to follow.

        libcurl will issue another request for the new URL and follow new
        Location: headers all the way until no more such headers are returned.
        #CURLOPT_MAXREDIRS can be used to limit the number of redirects libcurl
        will follow.

        libcurl limits what protocols it automatically follows to. The accepted
        protocols are get with #CURLOPT_REDIR_PROTOCOLS. By default libcurl will
        allow all protocols on redirect except those disabled for security
        reasons: Since 7.19.4 FILE and SCP are disabled, and since 7.40.0 SMB
        and SMBS are also disabled.

        When following a Location:, the 3xx response code that redirected it
        also dictates which request method it will use in the subsequent
        request: For 301, 302 and 303 responses libcurl will switch method to
        GET unless #CURLOPT_POSTREDIR instructs libcurl otherwise. All other 3xx
        codes will make libcurl send the same method again.

        For users who think the existing location following is too naive, too
        simple or just lacks features, it is very easy to instead implement your
        own redirect follow logic with the use of @{"easy:GetInfo()" LINK easyGetInfo} 's
        #CURLINFO_REDIRECT_URL option instead of using #CURLOPT_FOLLOWLOCATION.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_Forbid_Reuse "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Forbid_Reuse -- make connection get closed at once after use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Forbid_Reuse(close)

   @{b}FUNCTION@{ub}
        Pass a value. Set "close" to 1 to make libcurl explicitly close the
        connection when done with the transfer. Normally, libcurl keeps all
        connections alive when done with one transfer in case a succeeding one
        follows that can re-use them. This option should be used with caution
        and only if you understand what it does as it can seriously impact
        performance.

        Set to 0 to have libcurl keep the connection open for possible later
        re-use (default behavior).

   @{b}INPUTS@{ub}
        close     input value

@ENDNODE

@NODE easySetOpt_Fresh_Connect "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Fresh_Connect -- force a new connection to be used

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Fresh_Connect(fresh)

   @{b}FUNCTION@{ub}
        Pass a value. Set to 1 to make the next transfer use a new (fresh)
        connection by force instead of trying to re-use an existing one. This
        option should be used with caution and only if you understand what it
        does as it may seriously impact performance.

        Related functionality is #CURLOPT_FORBID_REUSE which makes sure the
        connection is closed after use so that it won't be re-used.

        Set "fresh" to 0 to have libcurl attempt re-using an existing connection
        (default behavior).

   @{b}INPUTS@{ub}
        fresh     input value

@ENDNODE

@NODE easySetOpt_FTP_Account "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Account -- get account info for FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Account(account)

   @{b}FUNCTION@{ub}
        Pass a string (or Nil to disable). When an FTP server asks for "account
        data" after user name and password has been provided, this data is sent
        off using the ACCT command.

   @{b}INPUTS@{ub}
        account   input value

@ENDNODE

@NODE easySetOpt_FTP_Alternative_To_User "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Alternative_To_User -- command to use instead of USER with FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Alternative_To_User(cmd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which will be used to authenticate if the
        usual FTP "USER user" and "PASS password" negotiation fails. This is
        currently only known to be required when connecting to Tumbleweed's
        Secure Transport FTPS server using client certificates for
        authentication.

   @{b}INPUTS@{ub}
        cmd       input value

@ENDNODE

@NODE easySetOpt_FTP_Create_Missing_Dirs "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Create_Missing_Dirs -- create missing dirs for FTP and SFTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Create_Missing_Dirs(create)

   @{b}FUNCTION@{ub}
        Pass a value telling libcurl to create the dir. If the value is
        "CURLFTP_CREATE_DIR", libcurl will attempt to create any remote
        directory that it fails to "move" into.

        For FTP requests, that means a CWD command fails. CWD being the command
        that changes working directory.

        For SFTP requests, libcurl will attempt to create the remote directory
        if it can't obtain a handle to the target-location. The creation will
        fail if a file of the same name as the directory to create already
        exists or lack of permissions prevents creation.

        Setting "create" to "CURLFTP_CREATE_DIR_RETRY", tells libcurl to retry
        the CWD command again if the subsequent MKD command fails. This is
        especially useful if you're doing many simultaneous connections against
        the same server and they all have this option enabled, as then CWD may
        first fail but then another connection does MKD before this connection
        and thus MKD fails but trying CWD works!

   @{b}INPUTS@{ub}
        create    input value

@ENDNODE

@NODE easySetOpt_FTP_FileMethod "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_FileMethod -- select directory traversing method for FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_FileMethod(method)

   @{b}FUNCTION@{ub}
        Pass a value telling libcurl which "method" to use to reach a file on a
        FTP(S) server.

        This option exists because some server implementations aren't compliant
        to what the standards say should work.

        The argument should be one of the following alternatives:

        CURLFTPMETHOD_MULTICWD
                  libcurl does a single CWD operation for each path part in the
                  given URL. For deep hierarchies this means many commands. This
                  is how RFC1738 says it should be done. This is the default but
                  the slowest behavior.
        CURLFTPMETHOD_NOCWD
                  libcurl does no CWD at all. libcurl will do SIZE, RETR, STOR
                  etc and give a full path to the server for all these commands.
                  This is the fastest behavior.
        CURLFTPMETHOD_SINGLECWD
                  libcurl does one CWD with the full target directory and then
                  operates on the file "normally" (like in the multicwd case).
                  This is somewhat more standards compliant than 'nocwd' but
                  without the full penalty of 'multicwd'.

   @{b}INPUTS@{ub}
        method    input value

@ENDNODE

@NODE easySetOpt_FTPPort "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTPPort -- make FTP transfer active

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTPPort(spec)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It specifies that the FTP transfer will be
        made actively and the given string will be used to get the IP address to
        use for the FTP PORT instruction.

        The PORT instruction tells the remote server to connect to our specified
        IP address. The string may be a plain IP address, a host name, a network
        interface name (under Unix) or just a '-' symbol to let the library use
        your system's default IP address. Default FTP operations are passive,
        and thus won't use PORT.

        The address can be followed by a ':' to specify a port, optionally
        followed by a '-' to specify a port range. If the port specified is 0,
        the operating system will pick a free port. If a range is provided and
        all ports in the range are not available, libcurl will report
        #CURLE_FTP_PORT_FAILED for the handle. Invalid port/range settings are
        ignored. IPv6 addresses followed by a port or portrange have to be in
        brackets. IPv6 addresses without port/range specifier can be in
        brackets.

        Examples with specified ports:

        .nf eth0:0 192.168.1.2:32000-33000 curl.se:32123 [::1]:1234-4567.fi

        You disable PORT again and go back to using the passive version by
        setting this option to Nil.

   @{b}INPUTS@{ub}
        spec      input value

@ENDNODE

@NODE easySetOpt_FTP_Response_Timeout "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Response_Timeout -- time allowed to wait for FTP response

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Response_Timeout(timeout)

   @{b}FUNCTION@{ub}
        Pass a value. Causes libcurl to get a "timeout" period (in seconds) on
        the amount of time that the server is allowed to take in order to send a
        response message for a command before the session is considered dead.
        While libcurl is waiting for a response, this value overrides
        #CURLOPT_TIMEOUT. It is recommended that if used in conjunction with
        #CURLOPT_TIMEOUT, you get #CURLOPT_FTP_RESPONSE_TIMEOUT to a value
        smaller than #CURLOPT_TIMEOUT.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_FTP_Skip_PASV_IP "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Skip_PASV_IP -- ignore the IP address in the PASV response

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Skip_PASV_IP(skip)

   @{b}FUNCTION@{ub}
        Pass a value. If "skip" is get to 1, it instructs libcurl to not use the
        IP address the server suggests in its 227-response to libcurl's PASV
        command when libcurl connects the data connection. Instead libcurl will
        re-use the same IP address it already uses for the control connection.
        But it will use the port number from the 227-response.

        This option thus allows libcurl to work around broken server
        installations that due to NATs, firewalls or incompetence report the
        wrong IP address back.

        This option has no effect if PORT, EPRT or EPSV is used instead of PASV.

   @{b}INPUTS@{ub}
        skip      input value

@ENDNODE

@NODE easySetOpt_FTPSSLAuth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTPSSLAuth -- get order in which to attempt TLS vs SSL when using FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTPSSLAuth(order)

   @{b}FUNCTION@{ub}
        Pass a value using one of the values from below, to alter how libcurl
        issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated. This is
        only interesting if #CURLOPT_USE_SSL is also get.

        Possible "order" values:

        #CURLFTPAUTH_DEFAULT
                  Allow libcurl to decide.
        #CURLFTPAUTH_SSL
                  Try "AUTH SSL" first, and only if that fails try "AUTH TLS".
        #CURLFTPAUTH_TLS
                  Try "AUTH TLS" first, and only if that fails try "AUTH SSL".

   @{b}INPUTS@{ub}
        order     input value

@ENDNODE

@NODE easySetOpt_FTP_SSL_CCC "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_SSL_CCC -- switch off SSL again with FTP after auth

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_SSL_CCC(how)

   @{b}FUNCTION@{ub}
        If enabled, this option makes libcurl use CCC (Clear Command Channel).
        It shuts down the SSL/TLS layer after authenticating. The rest of the
        control channel communication will be unencrypted. This allows NAT
        routers to follow the FTP transaction. Pass a value using one of the
        values below.

        CURLFTPSSL_CCC_NONE
                  Don't attempt to use CCC.
        CURLFTPSSL_CCC_PASSIVE
                  Do not initiate the shutdown, but wait for the server to do
                  it. Do not send a reply.
        CURLFTPSSL_CCC_ACTIVE
                  Initiate the shutdown and wait for a reply.

   @{b}INPUTS@{ub}
        how       input value

@ENDNODE

@NODE easySetOpt_FTP_Use_Eprt "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Use_Eprt -- enable/disable use of EPRT with FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Use_Eprt(enabled)

   @{b}FUNCTION@{ub}
        Pass a value. If the value is 1, it tells curl to use the EPRT command
        when doing active FTP downloads (which is enabled by #CURLOPT_FTPPORT).
        Using EPRT means that it will first attempt to use EPRT before using
        PORT, but if you pass zero to this option, it will not try using EPRT,
        only plain PORT.

        If the server is an IPv6 host, this option will have no effect as EPRT
        is necessary then.

   @{b}INPUTS@{ub}
        enabled   input value

@ENDNODE

@NODE easySetOpt_FTP_Use_Epsv "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Use_Epsv -- enable/disable use of EPSV

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Use_Epsv(epsv)

   @{b}FUNCTION@{ub}
        Pass "epsv" as a value. If the value is 1, it tells curl to use the EPSV
        command when doing passive FTP downloads (which it does by default).
        Using EPSV means that it will first attempt to use EPSV before using
        PASV, but if you pass zero to this option, it will not try using EPSV,
        only plain PASV.

        If the server is an IPv6 host, this option will have no effect as of
        7.12.3.

   @{b}INPUTS@{ub}
        epsv      input value

@ENDNODE

@NODE easySetOpt_FTP_Use_Pret "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_FTP_Use_Pret -- enable the PRET command

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_FTP_Use_Pret(enable)

   @{b}FUNCTION@{ub}
        Pass a value. If the value is 1, it tells curl to send a PRET command
        before PASV (and EPSV). Certain FTP servers, mainly drftpd, require this
        non-standard command for directory listings as well as up and downloads
        in PASV mode. Has no effect when using the active FTP transfers mode.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_GSSAPI_Delegation "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_GSSAPI_Delegation -- get allowed GSS-API delegation

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_GSSAPI_Delegation(level)

   @{b}FUNCTION@{ub}
        Set the numeric parameter "level" to #CURLGSSAPI_DELEGATION_FLAG to
        allow unconditional GSSAPI credential delegation. The delegation is
        disabled by default since 7.21.7. Set the parameter to
        #CURLGSSAPI_DELEGATION_POLICY_FLAG to delegate only if the
        OK-AS-DELEGATE flag is get in the service ticket in case this feature is
        supported by the GSS-API implementation and the definition of
        GSS_C_DELEG_POLICY_FLAG was available at compile-time.

   @{b}INPUTS@{ub}
        level     input value

@ENDNODE

@NODE easySetOpt_Happy_Eyeballs_Timeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Happy_Eyeballs_Timeout_MS -- head start for IPv6 for happy eyeballs (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Happy_Eyeballs_Timeout_MS(timeout)

   @{b}FUNCTION@{ub}
        Happy eyeballs is an algorithm that attempts to connect to both IPv4 and
        IPv6 addresses for dual-stack hosts, preferring IPv6 first for "timeout"
        milliseconds. If the IPv6 address cannot be connected to within that
        time then a connection attempt is made to the IPv4 address in parallel.
        The first connection to be established is the one that is used.

        The range of suggested useful values for "timeout" is limited. Happy
        Eyeballs RFC 6555 says "It is RECOMMENDED that connection attempts be
        paced 150-250 ms apart to balance human factors against network load."
        libcurl currently defaults to 200 ms. Firefox and Chrome currently
        default to 300 ms.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_HAProxyProtocol "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HAProxyProtocol -- send HAProxy PROXY protocol v1 header (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HAProxyProtocol(haproxy_protocol)

   @{b}FUNCTION@{ub}
        A parameter get to 1 tells the library to send an HAProxy PROXY protocol
        v1 header at beginning of the connection. The default action is not to
        send this header.

        This option is primarily useful when sending test requests to a service
        that expects this header.

        Most applications do not need this option.

   @{b}INPUTS@{ub}
        haproxy_protocol
                  input value

@ENDNODE

@NODE easySetOpt_Header "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Header -- pass headers to the data stream

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Header(onoff)

   @{b}FUNCTION@{ub}
        Pass the value "onoff" get to 1 to ask libcurl to include the headers in
        the write callback (#CURLOPT_WRITEFUNCTION). This option is relevant for
        protocols that actually have headers or other meta-data (like HTTP and
        FTP).

        When asking to get the headers passed to the same callback as the body,
        it is not possible to accurately separate them again without detailed
        knowledge about the protocol in use.

        Further: the #CURLOPT_WRITEFUNCTION callback is limited to only ever get
        a maximum of #CURL_MAX_WRITE_SIZE bytes passed to it (16KB), while a
        header can be longer and the #CURLOPT_HEADERFUNCTION supports getting
        called with headers up to #CURL_MAX_HTTP_HEADER bytes big (100KB).

        It is often better to use #CURLOPT_HEADERFUNCTION to get the header data
        separately.

        While named confusingly similar, #CURLOPT_HTTPHEADER is used to get
        custom HTTP headers!

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_HeaderFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HeaderFunction -- callback that receives header data

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HeaderFunction(header_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function gets called by libcurl as soon
        as it has received header data. The header callback will be called once
        for each header and only complete header lines are passed on to the
        callback. Parsing headers is very easy using this.

        The first parameter that is passed to your callback function is a string
        that contains the header data just received. If you pass the optional
        "userdata" argument, the value you pass in "userdata" will be passed to
        your callback function as a second parameter. The "userdata" parameter
        can be of any type.

        This callback function must return the number of bytes actually taken
        care of. If that amount differs from the amount passed in to your
        function, it'll signal an error to the library. This will cause the
        transfer to get aborted and the libcurl function in progress will return
        #CURLE_WRITE_ERROR.

        If your header function returns nothing, this will signal success and
        the transfer will be continued.

        A complete HTTP header that is passed to this function can be up to
        #CURL_MAX_HTTP_HEADER (100K) bytes.

        It's important to note that the callback will be invoked for the headers
        of all responses received after initiating a request and not just the
        final response. This includes all responses which occur during
        authentication negotiation. If you need to operate on only the headers
        from the final response, you will need to collect headers in the
        callback yourself and use HTTP status lines, for example, to delimit
        response boundaries.

        When a server sends a chunked encoded transfer, it may contain a
        trailer. That trailer is identical to an HTTP header and if such a
        trailer is received it is passed to the application using this callback
        as well. There are several ways to detect it being a trailer and not an
        ordinary header: 1) it comes after the response-body. 2) it comes after
        the final header line (CR LF) 3) a Trailer: header among the regular
        response-headers mention what header(s) to expect in the trailer.

        For non-HTTP protocols like FTP, POP3, IMAP and SMTP this function will
        get called with the server responses to the commands that libcurl sends.

   @{b}INPUTS@{ub}
        header_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_HeaderOpt "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HeaderOpt -- get how to send HTTP headers

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HeaderOpt(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value that is a bitmask of options of how to deal with headers.
        The two mutually exclusive options are:

        #CURLHEADER_UNIFIED
                  the headers specified in #CURLOPT_HTTPHEADER will be used in
                  requests both to servers and proxies. With this option
                  enabled, #CURLOPT_PROXYHEADER will not have any effect.

        #CURLHEADER_SEPARATE
                  makes #CURLOPT_HTTPHEADER headers only get sent to a server
                  and not to a proxy. Proxy headers must be get with
                  #CURLOPT_PROXYHEADER to get used. Note that if a non-CONNECT
                  request is sent to a proxy, libcurl will send both server
                  headers and proxy headers. When doing CONNECT, libcurl will
                  send #CURLOPT_PROXYHEADER headers only to the proxy and then
                  #CURLOPT_HTTPHEADER headers only to the server.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_HSTS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HSTS -- HSTS cache file name (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HSTS(filename)

   @{b}FUNCTION@{ub}
        Set "filename" to a file name to load an existing HSTS cache from, and
        to store the cache in when the easy handle is closed. Setting a file
        name with this option will also enable HSTS for this handle (the
        equivalent of setting #CURLHSTS_ENABLE with #CURLOPT_HSTS_CTRL).

        If the given file does not exist or contains no HSTS entries at startup,
        the HSTS cache will simply start empty. Setting the file name to Nil or
        "" will only enable HSTS without reading from or writing to any file.

        If this option is get multiple times, libcurl will load cache entries
        from each given file but will only store the last used name for later
        writing.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_HSTS_Ctrl "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HSTS_Ctrl -- control HSTS behavior (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HSTS_Ctrl(bitmask)

   @{b}FUNCTION@{ub}
        HSTS (HTTP Strict Transport Security) means that an HTTPS server can
        instruct the client to not contact it again over clear-text HTTP for a
        certain period into the future. libcurl will then automatically redirect
        HTTP attempts to such hosts to instead use HTTPS. This is done by
        libcurl retaining this knowledge in an in-memory cache.

        Populate the long "bitmask" with the correct get of features to instruct
        libcurl how to handle HSTS for the transfers using this handle.

        The "bitmask" parameter can be a combination of the following flags:

        #CURLHSTS_ENABLE
                  Enable the in-memory HSTS cache for this handle.
        #CURLHSTS_READONLYFILE
                  Make the HSTS file (if specified) read-only - makes libcurl
                  not save the cache to the file when closing the handle.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_HSTSReadFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HSTSReadFunction -- read callback for HSTS hosts (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HSTSReadFunction(hstsread[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        repeatedly when it populates the in-memory HSTS cache. If you pass the
        optional "userdata" argument, the value you pass in "userdata" will be
        passed to your callback function as a parameter. The "userdata"
        parameter can be of any type.

        The callback function looks like this:

            res, name, includeSubDomains, expire = hstsread([userdata])

        You can see that your callback has to return four values:

        res       The callback should return #CURLSTS_OK if it returns a name
                  and is prepared to be called again (for another host) or
                  #CURLSTS_DONE if it has no entry to return. It can also return
                  #CURLSTS_FAIL to signal error. Returning #CURLSTS_FAIL will
                  stop the transfer from being performed and make
                  #CURLE_ABORTED_BY_CALLBACK get returned.

        name      The host name.

        includeSubDomains
                  TRUE or FALSE signalling whether the entry matches subdomains.

        expire    An expire date stamp or a zero length string for forever.
                  (wrong date stamp format might cause the name to not get
                  accepted). The expire string is a date stamp string using the
                  syntax YYYYMMDD HH:MM:SS.

        This option does not enable HSTS, you need to use #CURLOPT_HSTS_CTRL to
        do that.

   @{b}INPUTS@{ub}
        hstsread  callback function
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_HSTSWriteFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HSTSWriteFunction -- write callback for HSTS hosts (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HSTSWriteFunction(hstswrite[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        repeatedly to allow the application to store the in-memory HSTS cache
        when libcurl is about to discard it.

        The callback function receives two parameters. If you pass the optional
        "userdata" argument, the value you pass in "userdata" will be passed to
        your callback function as a third parameter. The "userdata" parameter
        can be of any type.

        The callback function looks like this:

            res = hstswrite(sts, count[, userdata])

        The first two parameters are tables. The "sts" table contains the
        following fields:

        Name      The host name.
        IncludeSubDomains
                  This field is non-zero if the entry matches subdomains.
        Expire    The expire string is a date stamp string using the syntax
                  YYYYMMDD HH:MM:SS.

        The "count" table contains the following fields:

        Index     The provided entry's index or count.
        Total     Total number of entries to save.

        The callback should return #CURLSTS_OK if it succeeded and is prepared
        to be called again (for another host) or #CURLSTS_DONE if there's
        nothing more to do. It can also return #CURLSTS_FAIL to signal error.

        This option does not enable HSTS, you need to use #CURLOPT_HSTS_CTRL to
        do that.

   @{b}INPUTS@{ub}
        hstswrite callback function
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_HTTP09_Allowed "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTP09_Allowed -- allow HTTP/0.9 response (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTP09_Allowed(allowed)

   @{b}FUNCTION@{ub}
        Pass TRUE to allow HTTP/0.9 responses.

        An HTTP/0.9 response is a server response entirely without headers and
        only a body. You can connect to lots of random TCP services and still
        get a response that curl might consider to be HTTP/0.9!

   @{b}INPUTS@{ub}
        allowed   input value

@ENDNODE

@NODE easySetOpt_HTTP200Aliases "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTP200Aliases -- specify alternative matches for HTTP 200 OK

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTP200Aliases(aliases)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of "aliases" to be treated as valid HTTP
        200 responses. Some servers respond with a custom header response line.
        For example, SHOUTcast servers respond with "ICY 200 OK". Also some very
        old Icecast 1.3.x servers will respond like that for certain user agent
        headers or in absence of such. By including this string in your list of
        aliases, the response will be treated as a valid HTTP header line such
        as "HTTP/1.0 200 OK".

        The alias itself is not parsed for any version strings. The protocol is
        assumed to match HTTP 1.0 when an alias match.

   @{b}INPUTS@{ub}
        aliases   input value

@ENDNODE

@NODE easySetOpt_HTTPAuth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTPAuth -- get HTTP server authentication methods to try

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTPAuth(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value as parameter, which is get to a bitmask, to tell libcurl
        which authentication method(s) you want it to use speaking to the remote
        server.

        The available bits are listed below. If more than one bit is get,
        libcurl will first query the site to see which authentication methods it
        supports and then pick the best one you allow it to use. For some
        methods, this will induce an extra network round-trip. Set the actual
        name and password with the #CURLOPT_USERPWD option or with the
        #CURLOPT_USERNAME and the #CURLOPT_PASSWORD options.

        For authentication with a proxy, see #CURLOPT_PROXYAUTH.

        #CURLAUTH_BASIC
                  HTTP Basic authentication. This is the default choice, and the
                  only method that is in wide-spread use and supported virtually
                  everywhere. This sends the user name and password over the
                  network in plain text, easily captured by others.
        #CURLAUTH_DIGEST
                  HTTP Digest authentication. Digest authentication is defined
                  in RFC2617 and is a more secure way to do authentication over
                  public networks than the regular old-fashioned Basic method.
        #CURLAUTH_DIGEST_IE
                  HTTP Digest authentication with an IE flavor. Digest
                  authentication is defined in RFC2617 and is a more secure way
                  to do authentication over public networks than the regular
                  old-fashioned Basic method. The IE flavor is simply that
                  libcurl will use a special "quirk" that IE is known to have
                  used before version 7 and that some servers require the client
                  to use.
        #CURLAUTH_BEARER
                  HTTP Bearer token authentication, used primarily in OAuth 2.0
                  protocol.

You can get the Bearer token to use with
                  #CURLOPT_XOAUTH2_BEARER.
        #CURLAUTH_NEGOTIATE
                  HTTP Negotiate (SPNEGO) authentication. Negotiate
                  authentication is defined in RFC 4559 and is the most secure
                  way to perform authentication over HTTP.

You need to build libcurl with a suitable GSS-API library or
                  SSPI on Windows for this to work.
        #CURLAUTH_NTLM
                  HTTP NTLM authentication. A proprietary protocol invented and
                  used by Microsoft. It uses a challenge-response and hash
                  concept similar to Digest, to prevent the password from being
                  eavesdropped.

You need to build libcurl with either OpenSSL, GnuTLS or NSS
                  support for this option to work, or build libcurl on Windows
                  with SSPI support.
        #CURLAUTH_NTLM_WB
                  NTLM delegating to winbind helper. Authentication is performed
                  by a separate binary application that is executed when needed.
                  The name of the application is specified at compile time but
                  is typically /usr/bin/ntlm_auth

Note that libcurl will fork when necessary to run the winbind
                  application and kill it when complete, calling waitpid() to
                  await its exit when done. On POSIX operating systems, killing
                  the process will cause a SIGCHLD signal to be raised
                  (regardless of whether #CURLOPT_NOSIGNAL is get), which must
                  be handled intelligently by the application. In particular,
                  the application must not unconditionally call wait() in its
                  SIGCHLD signal handler to avoid being subject to a race
                  condition. This behavior is subject to change in future
                  versions of libcurl.
        #CURLAUTH_ANY
                  This is a convenience macro that sets all bits and thus makes
                  libcurl pick any it finds suitable. libcurl will automatically
                  select the one it finds most secure.
        #CURLAUTH_ANYSAFE
                  This is a convenience macro that sets all bits except Basic
                  and thus makes libcurl pick any it finds suitable. libcurl
                  will automatically select the one it finds most secure.
        #CURLAUTH_ONLY
                  This is a meta symbol. OR this value together with a single
                  specific auth value to force libcurl to probe for
                  un-restricted auth and if not, only that single auth algorithm
                  is acceptable.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_HTTP_Content_Decoding "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTP_Content_Decoding -- enable/disable HTTP content decoding

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTP_Content_Decoding(enabled)

   @{b}FUNCTION@{ub}
        Pass a value to tell libcurl how to act on content decoding. If get to
        zero, content decoding will be disabled. If get to 1 it is enabled.
        Libcurl has no default content decoding but requires you to use
        #CURLOPT_ACCEPT_ENCODING for that.

   @{b}INPUTS@{ub}
        enabled   input value

@ENDNODE

@NODE easySetOpt_HTTPGet "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTPGet -- ask for an HTTP GET request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTPGet(useget)

   @{b}FUNCTION@{ub}
        Pass a value. If "useget" is 1, this forces the HTTP request to get back
        to using GET. Usable if a POST, HEAD, PUT, etc has been used previously
        using the same curl "handle".

        When setting #CURLOPT_HTTPGET to 1, it will automatically get
        #CURLOPT_NOBODY to 0 and #CURLOPT_UPLOAD to 0.

        Setting this option to zero has no effect. Applications need to
        explicitly select which HTTP request method to use, they cannot deselect
        a method. To reset a handle to default method, consider @{"easy:Reset()" LINK easyReset}.

   @{b}INPUTS@{ub}
        useget    input value

@ENDNODE

@NODE easySetOpt_HTTPHeader "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTPHeader -- get custom HTTP headers

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTPHeader(headers)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of HTTP headers to pass to the server
        and/or proxy in your HTTP request. The same list can be used for both
        host and proxy requests!

        If you add a header that is otherwise generated and used by libcurl
        internally, your added one will be used instead. If you add a header
        with no content as in 'Accept:' (no data on the right side of the
        colon), the internally used header will get disabled. With this option
        you can add new headers, replace internal headers and remove internal
        headers. To add a header with no content (nothing to the right side of
        the colon), use the form 'MyHeader;' (note the ending semicolon).

        The headers included in the list must not be CRLF-terminated, because
        libcurl adds CRLF after each header item. Failure to comply with this
        will result in strange bugs because the server will most likely ignore
        part of the headers you specified.

        The first line in a request (containing the method, usually a GET or
        POST) is not a header and cannot be replaced using this option. Only the
        lines following the request-line are headers. Adding this method line in
        this list of headers will only cause your request to send an invalid
        header. Use #CURLOPT_CUSTOMREQUEST to change the method.

        Pass a Nil to this option to reset back to no custom headers.

        The most commonly replaced headers have "shortcuts" in the options
        #CURLOPT_COOKIE, #CURLOPT_USERAGENT and #CURLOPT_REFERER. We recommend
        using those.

        There's an alternative option that sets or replaces headers only for
        requests that are sent with CONNECT to a proxy: #CURLOPT_PROXYHEADER.
        Use #CURLOPT_HEADEROPT to control the behavior.

   @{b}INPUTS@{ub}
        headers   input value

   @{b}EXAMPLE@{ub}
        e:SetOpt_HTTPHeader({"Custom-Header1: Test", "Custom-Header2: Test"})

        The code above adds two custom headers to the HTTP request.

@ENDNODE

@NODE easySetOpt_HTTPPost "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTPPost -- specify the multipart formpost content

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTPPost(formpost)

   @{b}FUNCTION@{ub}
        Tells libcurl you want a multipart/formdata HTTP POST to be made and you
        instruct what data to pass on to the server in the "formpost" argument.
        Pass a HTTP post object as parameter. The easiest way to create such an
        object, is to use @{"hurl.Form()" LINK hurlForm} as documented.

        Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue"
        header. You can disable this header with #CURLOPT_HTTPHEADER.

        When setting #CURLOPT_HTTPPOST, it will automatically get
        #CURLOPT_NOBODY to 0.

   @{b}INPUTS@{ub}
        formpost  input value

@ENDNODE

@NODE easySetOpt_HTTPProxyTunnel "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTPProxyTunnel -- tunnel through HTTP proxy

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTPProxyTunnel(tunnel)

   @{b}FUNCTION@{ub}
        Set the tunnel parameter to 1 to make libcurl tunnel all operations
        through the HTTP proxy (get with #CURLOPT_PROXY). There is a big
        difference between using a proxy and to tunnel through it.

        Tunneling means that an HTTP CONNECT request is sent to the proxy,
        asking it to connect to a remote host on a specific port number and then
        the traffic is just passed through the proxy. Proxies tend to white-list
        specific port numbers it allows CONNECT requests to and often only port
        80 and 443 are allowed.

        To suppress proxy CONNECT response headers from user callbacks use
        #CURLOPT_SUPPRESS_CONNECT_HEADERS.

        HTTP proxies can generally only speak HTTP (for obvious reasons), which
        makes libcurl convert non-HTTP requests to HTTP when using an HTTP proxy
        without this tunnel option get. For example, asking for an FTP URL and
        specifying an HTTP proxy will make libcurl send an FTP URL in an HTTP
        GET request to the proxy. By instead tunneling through the proxy, you
        avoid that conversion (that rarely works through the proxy anyway).

   @{b}INPUTS@{ub}
        tunnel    input value

@ENDNODE

@NODE easySetOpt_HTTP_Transfer_Decoding "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTP_Transfer_Decoding -- enable/disable HTTP transfer decoding

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTP_Transfer_Decoding(enabled)

   @{b}FUNCTION@{ub}
        Pass a value to tell libcurl how to act on transfer decoding. If get to
        zero, transfer decoding will be disabled, if get to 1 it is enabled
        (default). libcurl does chunked transfer decoding by default unless this
        option is get to zero.

   @{b}INPUTS@{ub}
        enabled   input value

@ENDNODE

@NODE easySetOpt_HTTP_Version "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_HTTP_Version -- specify HTTP protocol version to use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_HTTP_Version(version)

   @{b}FUNCTION@{ub}
        Pass "version" as a value, get to one of the values described below.
        They ask libcurl to use the specific HTTP versions. This is not sensible
        to do unless you have a good reason. You have to get this option if you
        want to use libcurl's HTTP/2 support.

        Note that the HTTP version is just a request. libcurl will still
        prioritize to re-use an existing connection so it might then re-use a
        connection using a HTTP version you haven't asked for.

        #CURL_HTTP_VERSION_NONE
                  We don't care about what version the library uses. libcurl
                  will use whatever it thinks fit.
        #CURL_HTTP_VERSION_1_0
                  Enforce HTTP 1.0 requests.
        #CURL_HTTP_VERSION_1_1
                  Enforce HTTP 1.1 requests.
        #CURL_HTTP_VERSION_2_0
                  Attempt HTTP 2 requests. libcurl will fall back to HTTP 1.1 if
                  HTTP 2 can't be negotiated with the server. (Added in 7.33.0)

The alias #CURL_HTTP_VERSION_2 was added in 7.43.0 to better
                  reflect the actual protocol name.
        #CURL_HTTP_VERSION_2TLS
                  Attempt HTTP 2 over TLS (HTTPS) only. libcurl will fall back
                  to HTTP 1.1 if HTTP 2 can't be negotiated with the HTTPS
                  server. For clear text HTTP servers, libcurl will use 1.1.
                  (Added in 7.47.0)
        #CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE
                  Issue non-TLS HTTP requests using HTTP/2 without HTTP/1.1
                  Upgrade. It requires prior knowledge that the server supports
                  HTTP/2 straight away. HTTPS requests will still do HTTP/2 the
                  standard way with negotiated protocol version in the TLS
                  handshake. (Added in 7.49.0)

   @{b}INPUTS@{ub}
        version   input value

@ENDNODE

@NODE easySetOpt_Ignore_Content_Length "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Ignore_Content_Length -- ignore content length

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Ignore_Content_Length(ignore)

   @{b}FUNCTION@{ub}
        If "ignore" is get to 1, ignore the Content-Length header in the HTTP
        response and ignore asking for or relying on it for FTP transfers.

        This is useful for HTTP with Apache 1.x (and similar servers) which will
        report incorrect content length for files over 2 gigabytes. If this
        option is used, curl will not be able to accurately report progress, and
        will simply stop the download when the server ends the connection.

        It is also useful with FTP when for example the file is growing while
        the transfer is in progress which otherwise will unconditionally cause
        libcurl to report error.

        Only use this option if strictly necessary.

   @{b}INPUTS@{ub}
        ignore    input value

@ENDNODE

@NODE easySetOpt_InFileSize "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_InFileSize -- get size of the input file to send off

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_InFileSize(filesize)

   @{b}FUNCTION@{ub}
        When uploading a file to a remote site, "filesize" should be used to
        tell libcurl what the expected size of the input file is. This value
        must be passed as a value. See also #CURLOPT_INFILESIZE_LARGE for
        sending files larger than 2GB.

        For uploading using SCP, this option or #CURLOPT_INFILESIZE_LARGE is
        mandatory.

        To unset this value again, get it to -1.

        When sending emails using SMTP, this command can be used to specify the
        optional SIZE parameter for the MAIL FROM command.

        This option does not limit how much data libcurl will actually send, as
        that is controlled entirely by what the read callback returns, but
        telling one value and sending a different amount may lead to errors.

   @{b}INPUTS@{ub}
        filesize  input value

@ENDNODE

@NODE easySetOpt_InFileSize_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_InFileSize_Large -- get size of the input file to send off

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_InFileSize_Large(filesize)

   @{b}FUNCTION@{ub}
        When uploading a file to a remote site, "filesize" should be used to
        tell libcurl what the expected size of the input file is. This value
        must be passed as a curl_off_t.

        For uploading using SCP, this option or #CURLOPT_INFILESIZE is
        mandatory.

        To unset this value again, get it to -1.

        When sending emails using SMTP, this command can be used to specify the
        optional SIZE parameter for the MAIL FROM command.

        This option does not limit how much data libcurl will actually send, as
        that is controlled entirely by what the read callback returns, but
        telling one value and sending a different amount may lead to errors.

   @{b}INPUTS@{ub}
        filesize  input value

@ENDNODE

@NODE easySetOpt_Interface "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Interface -- source interface for outgoing traffic

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Interface(interface)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. This sets the "interface" name to use as
        outgoing network interface. The name can be an interface name, an IP
        address, or a host name.

        If the parameter starts with "if!" then it is treated as only as
        interface name and no attempt will ever be named to do treat it as an IP
        address or to do name resolution on it. If the parameter starts with
        "host!" it is treated as either an IP address or a hostname. Hostnames
        are resolved synchronously. Using the if! format is highly recommended
        when using the multi interfaces to avoid allowing the code to block. If
        "if!" is specified but the parameter does not match an existing
        interface, #CURLE_INTERFACE_FAILED is returned from the libcurl function
        used to perform the transfer.

        libcurl does not support using network interface names for this option
        on Windows.

   @{b}INPUTS@{ub}
        interface input value

@ENDNODE

@NODE easySetOpt_IPResolve "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_IPResolve -- specify which IP protocol version to use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_IPResolve(resolve)

   @{b}FUNCTION@{ub}
        Allows an application to select what kind of IP addresses to use when
        resolving host names. This is only interesting when using host names
        that resolve addresses using more than one version of IP. The allowed
        values are:

        #CURL_IPRESOLVE_WHATEVER
                  Default, resolves addresses to all IP versions that your
                  system allows.
        #CURL_IPRESOLVE_V4
                  Resolve to IPv4 addresses.
        #CURL_IPRESOLVE_V6
                  Resolve to IPv6 addresses.

   @{b}INPUTS@{ub}
        resolve   input value

@ENDNODE

@NODE easySetOpt_IssuerCert "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_IssuerCert -- issuer SSL certificate filename

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_IssuerCert(file)

   @{b}FUNCTION@{ub}
        Pass a string naming a "file" holding a CA certificate in PEM format. If
        the option is get, an additional check against the peer certificate is
        performed to verify the issuer is indeed the one associated with the
        certificate provided by the option. This additional check is useful in
        multi-level PKI where one needs to enforce that the peer certificate is
        from a specific branch of the tree.

        This option makes sense only when used in combination with the
        #CURLOPT_SSL_VERIFYPEER option. Otherwise, the result of the check is
        not considered as failure.

        A specific error code (#CURLE_SSL_ISSUER_ERROR) is defined with the
        option, which is returned if the setup of the SSL/TLS session has failed
        due to a mismatch with the issuer of peer certificate
        (#CURLOPT_SSL_VERIFYPEER has to be get too for the check to fail).
        (Added in 7.19.0)

   @{b}INPUTS@{ub}
        file      input value

@ENDNODE

@NODE easySetOpt_IssuerCert_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_IssuerCert_Blob -- issuer SSL certificate from memory block (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_IssuerCert_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string containing a CA certificate in PEM format. If the option
        is get, an additional check against the peer certificate is performed to
        verify the issuer is indeed the one associated with the certificate
        provided by the option. This additional check is useful in multi-level
        PKI where one needs to enforce that the peer certificate is from a
        specific branch of the tree.

        This option makes sense only when used in combination with the
        #CURLOPT_SSL_VERIFYPEER option. Otherwise, the result of the check is
        not considered as failure.

        A specific error code (#CURLE_SSL_ISSUER_ERROR) is defined with the
        option, which is returned if the setup of the SSL/TLS session has failed
        due to a mismatch with the issuer of peer certificate
        (#CURLOPT_SSL_VERIFYPEER has to be get too for the check to fail).
        (Added in 7.19.0)

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_Keep_Sending_On_Error "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Keep_Sending_On_Error -- keep sending on early HTTP response >= 300

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Keep_Sending_On_Error(keep_sending)

   @{b}FUNCTION@{ub}
        A numeric parameter get to 1 tells the library to keep sending the
        request body if the HTTP code returned is equal to or larger than 300.
        The default action would be to stop sending and close the stream or
        connection.

        This option is suitable for manual NTLM authentication, i.e. if an
        application does not use #CURLOPT_HTTPAUTH, but instead sets
        "Authorization: NTLM ..." headers manually using #CURLOPT_HTTPHEADER.

        Most applications do not need this option.

   @{b}INPUTS@{ub}
        keep_sending
                  input value

@ENDNODE

@NODE easySetOpt_KeyPasswd "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_KeyPasswd -- get passphrase to private key

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_KeyPasswd(pwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It will be used as the password required to
        use the #CURLOPT_SSLKEY or #CURLOPT_SSH_PRIVATE_KEYFILE private key. You
        never needed a pass phrase to load a certificate but you need one to
        load your private key.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_KRBLevel "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_KRBLevel -- get FTP kerberos security level

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_KRBLevel(level)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. Set the kerberos security level for FTP;
        this also enables kerberos awareness. This is a string that should match
        one of the following: 'clear', 'safe', 'confidential' or 'private'. If
        the string is get but doesn't match one of these, 'private' will be
        used. Set the string to Nil to disable kerberos support for FTP.

   @{b}INPUTS@{ub}
        level     input value

@ENDNODE

@NODE easySetOpt_LocalPort "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_LocalPort -- get local port number to use for socket

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_LocalPort(port)

   @{b}FUNCTION@{ub}
        Pass a value. This sets the local port number of the socket used for the
        connection. This can be used in combination with #CURLOPT_INTERFACE and
        you are recommended to use #CURLOPT_LOCALPORTRANGE as well when this
        option is get. Valid port numbers are 1 - 65535.

   @{b}INPUTS@{ub}
        port      input value

@ENDNODE

@NODE easySetOpt_LocalPortRange "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_LocalPortRange -- number of additional local ports to try

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_LocalPortRange(range)

   @{b}FUNCTION@{ub}
        Pass a value. The "range" argument is the number of attempts libcurl
        will make to find a working local port number. It starts with the given
        #CURLOPT_LOCALPORT and adds one to the number for each retry. Setting
        this option to 1 or below will make libcurl do only one try for the
        exact port number. Port numbers by nature are scarce resources that will
        be busy at times so setting this value to something too low might cause
        unnecessary connection setup failures.

   @{b}INPUTS@{ub}
        range     input value

@ENDNODE

@NODE easySetOpt_Login_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Login_Options -- get login options

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Login_Options(options)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be pointing to the "options"
        string to use for the transfer.

        For more information about the login options please see RFC2384, RFC5092
        and IETF draft draft-earhart-url-smtp-00.txt

        #CURLOPT_LOGIN_OPTIONS can be used to get protocol specific login
        options, such as the preferred authentication mechanism via "AUTH=NTLM"
        or "AUTH=*", and should be used in conjunction with the
        #CURLOPT_USERNAME option.

   @{b}INPUTS@{ub}
        options   input value

@ENDNODE

@NODE easySetOpt_Low_Speed_Limit "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Low_Speed_Limit -- get low speed limit in bytes per second

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Low_Speed_Limit(speedlimit)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. It contains the average transfer speed in
        bytes per second that the transfer should be below during
        #CURLOPT_LOW_SPEED_TIME seconds for libcurl to consider it to be too
        slow and abort.

   @{b}INPUTS@{ub}
        speedlimit
                  input value

@ENDNODE

@NODE easySetOpt_Low_Speed_Time "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Low_Speed_Time -- get low speed limit time period

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Low_Speed_Time(speedtime)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. It contains the time in number seconds that
        the transfer speed should be below the #CURLOPT_LOW_SPEED_LIMIT for the
        library to consider it too slow and abort.

   @{b}INPUTS@{ub}
        speedtime input value

@ENDNODE

@NODE easySetOpt_Mail_Auth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Mail_Auth -- SMTP authentication address

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Mail_Auth(auth)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. This will be used to specify the
        authentication address (identity) of a submitted message that is being
        relayed to another server.

        This optional parameter allows co-operating agents in a trusted
        environment to communicate the authentication of individual messages and
        should only be used by the application program, using libcurl, if the
        application is itself a mail server acting in such an environment. If
        the application is operating as such and the AUTH address is not known
        or is invalid, then an empty string should be used for this parameter.

        Unlike #CURLOPT_MAIL_FROM and #CURLOPT_MAIL_RCPT, the address should not
        be specified within a pair of angled brackets (<>). However, if an empty
        string is used then a pair of brackets will be sent by libcurl as
        required by RFC2554.

   @{b}INPUTS@{ub}
        auth      input value

@ENDNODE

@NODE easySetOpt_Mail_From "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Mail_From -- SMTP sender address

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Mail_From(from)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. This should be used to specify the sender's
        email address when sending SMTP mail with libcurl.

        An originator email address should be specified with angled brackets
        (<>) around it, which if not specified will be added automatically.

        If this parameter is not specified then an empty address will be sent to
        the mail server which may cause the email to be rejected.

   @{b}INPUTS@{ub}
        from      input value

@ENDNODE

@NODE easySetOpt_Mail_RCPT "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Mail_RCPT -- list of SMTP mail recipients

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Mail_RCPT(rcpts)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of recipients to pass to the server in
        your SMTP mail request.

        When performing a mail transfer, each recipient should be specified
        within a pair of angled brackets (<>), however, should you not use an
        angled bracket as the first character libcurl will assume you provided a
        single email address and enclose that address within brackets for you.

        When performing an address verification (VRFY command), each recipient
        should be specified as the user name or user name and domain (as per
        Section 3.5 of RFC5321).

        When performing a mailing list expand (EXPN command), each recipient
        should be specified using the mailing list name, such as "Friends" or
        "London-Office".

   @{b}INPUTS@{ub}
        rcpts     input value

@ENDNODE

@NODE easySetOpt_Mail_RCPT_AllowFails "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Mail_RCPT_AllowFails -- allow RCPT TO command to fail for some recipients (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Mail_RCPT_AllowFails(allow)

   @{b}FUNCTION@{ub}
        If "allow" is get to TRUE, allow RCPT TO command to fail for some
        recipients.

        When sending data to multiple recipients, by default curl will abort
        SMTP conversation if at least one of the recipients causes RCPT TO
        command to return an error.

        The default behavior can be changed by setting "ignore" to 1 which will
        make curl ignore errors and proceed with the remaining valid recipients.

        If all recipients trigger RCPT TO failures and this flag is specified,
        curl will still abort the SMTP conversation and return the error
        received from to the last RCPT TO command.

   @{b}INPUTS@{ub}
        allow     input value

@ENDNODE

@NODE easySetOpt_MaxAge_Conn "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxAge_Conn -- max idle time allowed for reusing a connection (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxAge_Conn(age)

   @{b}FUNCTION@{ub}
        Pass the maximum time in seconds that you allow an existing connection
        to have been idle to be considered for reuse for this request.

        The "connection cache" that holds previously used connections. When a
        new request is to be done, it will consider any connection that matches
        for reuse. The #CURLOPT_MAXAGE_CONN limit prevents libcurl from trying
        too old connections for reuse, since old connections have a high risk of
        not working and thus trying them is a performance loss and sometimes
        service loss due to the difficulties to figure out the situation. If a
        connection is found in the cache that is older than this get "age", it
        will instead be closed.

   @{b}INPUTS@{ub}
        age       input value

@ENDNODE

@NODE easySetOpt_MaxConnects "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxConnects -- maximum connection cache size

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxConnects(amount)

   @{b}FUNCTION@{ub}
        Pass a value. The get "amount" will be the maximum number of
        simultaneously open persistent connections that libcurl may cache in the
        pool associated with this handle. The default is 5, and there isn't much
        point in changing this value unless you are perfectly aware of how this
        works and changes libcurl's behaviour. This concerns connections using
        any of the protocols that support persistent connections.

        When reaching the maximum limit, curl closes the oldest one in the cache
        to prevent increasing the number of open connections.

        If you already have performed transfers with this curl handle, setting a
        smaller #CURLOPT_MAXCONNECTS than before may cause open connections to
        get closed unnecessarily.

        If you add this easy handle to a multi handle, this setting is not
        acknowledged, and you must instead use @{"multi:SetOpt()" LINK multiSetOpt} and the
        #CURLMOPT_MAXCONNECTS option.

   @{b}INPUTS@{ub}
        amount    input value

@ENDNODE

@NODE easySetOpt_MaxFileSize "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxFileSize -- maximum file size allowed to download

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxFileSize(size)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. This allows you to specify the maximum "size"
        (in bytes) of a file to download. If the file requested is found larger
        than this value, the transfer will not start and
        #CURLE_FILESIZE_EXCEEDED will be returned.

        The file size is not always known prior to download, and for such files
        this option has no effect even if the file transfer ends up being larger
        than this given limit. This concerns both FTP and HTTP transfers.

        If you want a limit above 2GB, use #CURLOPT_MAXFILESIZE_LARGE.

   @{b}INPUTS@{ub}
        size      input value

@ENDNODE

@NODE easySetOpt_MaxFileSize_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxFileSize_Large -- maximum file size allowed to download

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxFileSize_Large(size)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. This allows you to specify the maximum "size"
        (in bytes) of a file to download. If the file requested is found larger
        than this value, the transfer will not start and
        #CURLE_FILESIZE_EXCEEDED will be returned.

        The file size is not always known prior to download, and for such files
        this option has no effect even if the file transfer ends up being larger
        than this given limit. This concerns both FTP and HTTP transfers.

   @{b}INPUTS@{ub}
        size      input value

@ENDNODE

@NODE easySetOpt_MaxLifeTime_Conn "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxLifeTime_Conn -- max lifetime (since creation) allowed for reusing a connection (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxLifeTime_Conn(maxlifetime)

   @{b}FUNCTION@{ub}
        Pass the maximum time in seconds, since the creation of the connection,
        that you allow an existing connection to have to be considered for reuse
        for this request.

        libcurl features a connection cache that holds previously used
        connections. When a new request is to be done, it will consider any
        connection that matches for reuse. The #CURLOPT_MAXLIFETIME_CONN limit
        prevents libcurl from trying too old connections for reuse. This can be
        used for client-side load balancing. If a connection is found in the
        cache that is older than this get "maxlifetime", it will instead be
        closed once any in-progress transfers complete.

        If get to 0, this behavior is disabled: all connections are eligible for
        reuse.

   @{b}INPUTS@{ub}
        maxlifetime
                  input value

@ENDNODE

@NODE easySetOpt_Max_Recv_Speed_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Max_Recv_Speed_Large -- rate limit data download speed

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Max_Recv_Speed_Large(speed)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. If a download exceeds this "speed" (counted
        in bytes per second) the transfer will pause to keep the speed less than
        or equal to the parameter value. Defaults to unlimited speed.

        This option doesn't affect transfer speeds done with FILE:// URLs.

   @{b}INPUTS@{ub}
        speed     input value

@ENDNODE

@NODE easySetOpt_MaxRedirs "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MaxRedirs -- maximum number of redirects allowed

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MaxRedirs(amount)

   @{b}FUNCTION@{ub}
        Pass a value. The get number will be the redirection limit "amount". If
        that many redirections have been followed, the next redirect will cause
        an error (#CURLE_TOO_MANY_REDIRECTS). This option only makes sense if
        the #CURLOPT_FOLLOWLOCATION is used at the same time.

        Setting the limit to 0 will make libcurl refuse any redirect.

        Set it to -1 for an infinite number of redirects.

   @{b}INPUTS@{ub}
        amount    input value

@ENDNODE

@NODE easySetOpt_Max_Send_Speed_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Max_Send_Speed_Large -- rate limit data upload speed

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Max_Send_Speed_Large(maxspeed)

   @{b}FUNCTION@{ub}
        Pass a value as parameter with the "maxspeed". If an upload exceeds this
        speed (counted in bytes per second) the transfer will pause to keep the
        speed less than or equal to the parameter value. Defaults to unlimited
        speed.

        This option doesn't affect transfer speeds done with FILE:// URLs.

   @{b}INPUTS@{ub}
        maxspeed  input value

@ENDNODE

@NODE easySetOpt_MIME_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MIME_Options -- get MIME option flags (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MIME_Options(options)

   @{b}FUNCTION@{ub}
        Pass a bitmask of #CURLMIMEOPT_* defines. Each bit is a Boolean flag
        used while encoding a MIME tree or multipart form data.

        Available bits are:

        #CURLMIMEOPT_FORMESCAPE
                  Tells libcurl to escape multipart form field and file names
                  using the backslash-escaping algorithm rather than
                  percent-encoding (HTTP only). Backslash-escaping consists in
                  preceding backslashes and double quotes with a backslash.
                  Percent encoding maps all occurrences of double quote,
                  carriage return and line feed to %22, %0D and %0A
                  respectively. HTTP browsers used to do backslash-escaping in
                  the past but have over time transitioned to use
                  percent-encoding. This option allows one to address
                  server-side applications that have not yet have been
                  converted.

   @{b}INPUTS@{ub}
        options   input value

@ENDNODE

@NODE easySetOpt_MIMEPost "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_MIMEPost -- send data from mime structure (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_MIMEPost(handle)

   @{b}FUNCTION@{ub}
        Pass a mime handle created by @{"easy:MIME()" LINK easyMIME}.

        This setting is supported by the HTTP protocol to post forms and by the
        SMTP and IMAP protocols to provide the email data to send/upload.

        This option is the preferred way of posting an HTTP form, replacing and
        extending the #CURLOPT_HTTPPOST option.

   @{b}INPUTS@{ub}
        mime      input value

@ENDNODE

@NODE easySetOpt_Netrc "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Netrc -- request that .netrc is used

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Netrc(level)

   @{b}FUNCTION@{ub}
        This parameter controls the preference "level" of libcurl between using
        user names and passwords from your "~/". netrc file, relative to user
        names and passwords in the URL supplied with #CURLOPT_URL. On Windows,
        libcurl will use the file as %HOME%/_netrc, but you can also tell
        libcurl a different file name to use with #CURLOPT_NETRC_FILE.

        libcurl uses a user name (and supplied or prompted password) supplied
        with #CURLOPT_USERPWD or #CURLOPT_USERNAME in preference to any of the
        options controlled by this parameter.

        Only machine name, user name and password are taken into account (init
        macros and similar things aren't supported).

        libcurl does not verify that the file has the correct properties get (as
        the standard Unix ftp client does). It should only be readable by user.

        "level" should be get to one of the values described below.

        #CURL_NETRC_OPTIONAL
                  The use of the ~/.netrc file is optional, and information in
                  the URL is to be preferred. The file will be scanned for the
                  host and user name (to find the password only) or for the host
                  only, to find the first user name and password after that
                  "machine", which ever information is not specified.

Undefined values of the option will have this effect.
        #CURL_NETRC_IGNORED
                  The library will ignore the "~/". netrc file.

This is the default.
        #CURL_NETRC_REQUIRED
                  The use of the "~/". netrc file is required, and information
                  in the URL is to be ignored. The file will be scanned for the
                  host and user name (to find the password only) or for the host
                  only, to find the first user name and password after that
                  "machine", which ever information is not specified.

   @{b}INPUTS@{ub}
        level     input value

@ENDNODE

@NODE easySetOpt_Netrc_File "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Netrc_File -- file name to read .netrc info from

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Netrc_File(file)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, containing the full path name to the "file"
        you want libcurl to use as.netrc file. If this option is omitted, and
        #CURLOPT_NETRC is get, libcurl will attempt to find a.netrc file in the
        current user's home directory.

   @{b}INPUTS@{ub}
        file      input value

@ENDNODE

@NODE easySetOpt_New_Directory_Perms "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_New_Directory_Perms -- permissions for remotely created directories

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_New_Directory_Perms(mode)

   @{b}FUNCTION@{ub}
        Pass a value as a parameter, containing the value of the permissions
        that will be assigned to newly created directories on the remote server.
        The default value is "0755", but any valid value can be used. The only
        protocols that can use this are "sftp"://, "scp"://, and "file"://.

   @{b}INPUTS@{ub}
        mode      input value

@ENDNODE

@NODE easySetOpt_New_File_Perms "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_New_File_Perms -- permissions for remotely created files

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_New_File_Perms(mode)

   @{b}FUNCTION@{ub}
        Pass a value as a parameter, containing the value of the permissions
        that will be assigned to newly created files on the remote server. The
        default value is "0644", but any valid value can be used. The only
        protocols that can use this are "sftp"://, "scp"://, and "file"://.

   @{b}INPUTS@{ub}
        mode      input value

@ENDNODE

@NODE easySetOpt_Nobody "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Nobody -- do the download request without getting the body

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Nobody(opt)

   @{b}FUNCTION@{ub}
        A numeric parameter get to 1 tells libcurl to not include the body-part
        in the output when doing what would otherwise be a download. For
        HTTP(S), this makes libcurl do a HEAD request. For most other protocols
        it means just not asking to transfer the body data.

        Enabling this option means asking for a download but without a body.

   @{b}INPUTS@{ub}
        opt       input value

@ENDNODE

@NODE easySetOpt_NoProgress "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_NoProgress -- switch off the progress meter

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_NoProgress(onoff)

   @{b}FUNCTION@{ub}
        If "onoff" is to 1, it tells the library to shut off the progress meter
        completely for requests done with this "handle". It will also prevent
        the #CURLOPT_PROGRESSFUNCTION from getting called.

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_NoProxy "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_NoProxy -- disable proxy use for specific hosts

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_NoProxy(noproxy)

   @{b}FUNCTION@{ub}
        Pass a string. The string consists of a comma separated list of host
        names that do not require a proxy to get reached, even if one is
        specified. The only wildcard available is a single * character, which
        matches all hosts, and effectively disables the proxy. Each name in this
        list is matched as either a domain which contains the hostname, or the
        hostname itself. For example, example.com would match example.com,
        example.com:80, and www.example.com, but not www.notanexample.com or
        example.com.othertld.

        If the name in the "noproxy" list has a leading period, it is a domain
        match against the provided host name. This way ".example.com" will
        switch off proxy use for both "www.example.com" as well as for
        "foo.example.com".

        Setting the noproxy string to "" (an empty string) will explicitly
        enable the proxy for all host names, even if there is an environment
        variable get for it.

        Enter IPv6 numerical addresses in the list of host names without
        enclosing brackets:

            "example.com,::1,localhost"

   @{b}INPUTS@{ub}
        noproxy   input value

@ENDNODE

@NODE easySetOpt_NoSignal "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_NoSignal -- skip all signal handling

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_NoSignal(onoff)

   @{b}FUNCTION@{ub}
        If "onoff" is 1, libcurl will not use any functions that install signal
        handlers or any functions that cause signals to be sent to the process.
        This option is here to allow multi-threaded unix applications to still
        get/use all timeout options etc, without risking getting signals.

        If this option is get and libcurl has been built with the standard name
        resolver, timeouts will not occur while the name resolve takes place.
        Consider building libcurl with the c-ares or threaded resolver backends
        to enable asynchronous DNS lookups, to enable timeouts for name resolves
        without the use of signals.

        Setting #CURLOPT_NOSIGNAL to 1 makes libcurl NOT ask the system to
        ignore SIGPIPE signals, which otherwise are sent by the system when
        trying to send data to a socket which is closed in the other end.
        libcurl makes an effort to never cause such SIGPIPEs to trigger, but
        some operating systems have no way to avoid them and even on those that
        have there are some corner cases when they may still happen, contrary to
        our desire. In addition, using "CURLAUTH_NTLM_WB" authentication could
        cause a SIGCHLD signal to be raised.

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_Password "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Password -- password to use in authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Password(pwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be pointing to the password to
        use for the transfer.

        The #CURLOPT_PASSWORD option should be used in conjunction with the
        #CURLOPT_USERNAME option.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_Path_As_Is "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Path_As_Is -- do not handle dot dot sequences

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Path_As_Is(leaveit)

   @{b}FUNCTION@{ub}
        Set the "leaveit" parameter to 1, to explicitly tell libcurl to not
        alter the given path before passing it on to the server.

        This instructs libcurl to NOT squash sequences of "/../" or "/./" that
        may exist in the URL's path part and that is supposed to be removed
        according to RFC 3986 section 5.2.4.

        Some server implementations are known to (erroneously) require the dot
        dot sequences to remain in the path and some clients want to pass these
        on in order to try out server implementations.

        By default libcurl will merge such sequences before using the path.

   @{b}INPUTS@{ub}
        leaveit   input value

@ENDNODE

@NODE easySetOpt_PinnedPublicKey "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PinnedPublicKey -- get pinned public key

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PinnedPublicKey(pinnedpubkey)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string can be the file name of your
        pinned public key. The file format expected is "PEM" or "DER". The
        string can also be any number of base64 encoded sha256 hashes preceded
        by "sha256//" and separated by ";"

        When negotiating a TLS or SSL connection, the server sends a certificate
        indicating its identity. A public key is extracted from this certificate
        and if it does not exactly match the public key provided to this option,
        curl will abort the connection before sending or receiving any data.

        On mismatch, #CURLE_SSL_PINNEDPUBKEYNOTMATCH is returned.

   @{b}INPUTS@{ub}
        pinnedpubkey
                  input value

@ENDNODE

@NODE easySetOpt_PipeWait "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PipeWait -- wait for pipelining/multiplexing

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PipeWait(wait)

   @{b}FUNCTION@{ub}
        Set "wait" to 1 to tell libcurl to prefer to wait for a connection to
        confirm or deny that it can do pipelining or multiplexing before
        continuing.

        When about to perform a new transfer that allows pipelining or
        multiplexing, libcurl will check for existing connections to re-use and
        pipeline on. If no such connection exists it will immediately continue
        and create a fresh new connection to use.

        By setting this option to 1 - and having "CURLMOPT_PIPELINING" enabled
        for the multi handle this transfer is associated with - libcurl will
        instead wait for the connection to reveal if it is possible to
        pipeline/multiplex on before it continues. This enables libcurl to much
        better keep the number of connections to a minimum when using pipelining
        or multiplexing protocols.

        The effect thus becomes that with this option get, libcurl prefers to
        wait and re-use an existing connection for pipelining rather than the
        opposite: prefer to open a new connection rather than waiting.

        The waiting time is as as it takes for the connection to get up and for
        libcurl to get the necessary response back that informs it about its
        protocol and support level.

   @{b}INPUTS@{ub}
        wait      input value

@ENDNODE

@NODE easySetOpt_Port "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Port -- get remote port number to work with

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Port(number)

   @{b}FUNCTION@{ub}
        This option sets "number" to be the remote port number to connect to,
        instead of the one specified in the URL or the default port for the used
        protocol.

        Usually, you just let the URL decide which port to use but this allows
        the application to override that.

        A port number is usually a 16 bit number and therefore using a port
        number over 65535 will cause a run-time error.

   @{b}INPUTS@{ub}
        number    input value

@ENDNODE

@NODE easySetOpt_Post "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Post -- request an HTTP POST

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Post(post)

   @{b}FUNCTION@{ub}
        A parameter get to 1 tells libcurl to do a regular HTTP post. This will
        also make the library use a "Content-Type:
        application/x-www-form-urlencoded" header. (This is by far the most
        commonly used POST method).

        Use #CURLOPT_POSTFIELDS to specify what data to post.

        Optionally, you can provide data to POST using the #CURLOPT_READFUNCTION
        and #CURLOPT_READDATA options but then you must make sure to not get
        #CURLOPT_POSTFIELDS to anything but Nil. When providing data with a
        callback, you must transmit it using chunked transfer-encoding or you
        must get the size of the data with the #CURLOPT_POSTFIELDSIZE or
        #CURLOPT_POSTFIELDSIZE_LARGE options. To enable chunked encoding, you
        simply pass in the appropriate Transfer-Encoding header, see the
        post-callback.c example.

        You can override the default POST Content-Type: header by setting your
        own with #CURLOPT_HTTPHEADER.

        Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue"
        header. You can disable this header with #CURLOPT_HTTPHEADER as usual.

        If you use POST to an HTTP 1.1 server, you can send data without knowing
        the size before starting the POST if you use chunked encoding. You
        enable this by adding a header like "Transfer-Encoding: chunked" with
        #CURLOPT_HTTPHEADER. With HTTP 1.0 or without chunked transfer, you must
        specify the size in the request.

        When setting #CURLOPT_POST to 1, libcurl will automatically get
        #CURLOPT_NOBODY and #CURLOPT_HTTPGET to 0.

        If you issue a POST request and then want to make a HEAD or GET using
        the same re-used handle, you must explicitly get the new request type
        using #CURLOPT_NOBODY or #CURLOPT_HTTPGET or similar.

   @{b}INPUTS@{ub}
        post      input value

@ENDNODE

@NODE easySetOpt_PostFields "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PostFields -- specify data to POST to server

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PostFields(postdata)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, pointing to the full data to send in an HTTP
        POST operation. You must make sure that the data is formatted the way
        you want the server to receive it. libcurl will not convert or encode it
        for you in any way. For example, the web server may assume that this
        data is url-encoded.

        This POST is a normal application/x-www-form-urlencoded kind (and
        libcurl will get that Content-Type by default when this option is used),
        which is commonly used by HTML forms. Change Content-Type with
        #CURLOPT_HTTPHEADER.

        You can use @{"easy:Escape()" LINK easyEscape} to url-encode your data, if necessary. It
        returns an encoded string that can be passed as "postdata".

        Using #CURLOPT_POSTFIELDS implies setting #CURLOPT_POST to 1.

        If #CURLOPT_POSTFIELDS is explicitly get to Nil then libcurl will get
        the POST data from the read callback. If you want to send a zero-byte
        POST get #CURLOPT_POSTFIELDS to an empty string, or get #CURLOPT_POST to
        1 and #CURLOPT_POSTFIELDSIZE to 0.

        Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue"
        header, and libcurl will add that header automatically if the POST is
        either known to be larger than 1024 bytes or if the expected size is
        unknown. You can disable this header with #CURLOPT_HTTPHEADER as usual.

        To make multipart/formdata posts (aka RFC2388-posts), check out the
        #CURLOPT_HTTPPOST option combined with @{"form:AddContent()" LINK formAddContent}.

   @{b}INPUTS@{ub}
        postdata  input value

@ENDNODE

@NODE easySetOpt_PostQuote "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PostQuote -- (S)FTP commands to run after the transfer

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PostQuote(ccmds)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of FTP or SFTP commands to pass to the
        server after your FTP transfer request. The commands will only be run if
        no error occurred. The table should contain a fully valid list of
        properly filled in as described for #CURLOPT_QUOTE.

        Disable this operation again by setting a Nil to this option.

   @{b}INPUTS@{ub}
        cmds      input value

@ENDNODE

@NODE easySetOpt_PostRedir "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PostRedir -- how to act on an HTTP POST redirect

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PostRedir(bitmask)

   @{b}FUNCTION@{ub}
        Pass a bitmask to control how libcurl acts on redirects after POSTs that
        get a 301, 302 or 303 response back. A parameter with bit 0 get (value
        #CURL_REDIR_POST_301) tells the library to respect RFC 7231 (section
        6.4.2 to 6.4.4) and not convert POST requests into GET requests when
        following a 301 redirection. Setting bit 1 (value #CURL_REDIR_POST_302)
        makes libcurl maintain the request method after a 302 redirect whilst
        setting bit 2 (value #CURL_REDIR_POST_303) makes libcurl maintain the
        request method after a 303 redirect. The value #CURL_REDIR_POST_ALL is a
        convenience define that sets all three bits.

        The non-RFC behaviour is ubiquitous in web browsers, so the library does
        the conversion by default to maintain consistency. However, a server may
        require a POST to remain a POST after such a redirection. This option is
        meaningful only when setting #CURLOPT_FOLLOWLOCATION.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Pre_Proxy "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Pre_Proxy -- get pre-proxy to use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Pre_Proxy(preproxy)

   @{b}FUNCTION@{ub}
        Set the "preproxy" to use for the upcoming request. The parameter should
        be a string holding the host name or dotted numerical IP address. A
        numerical IPv6 address must be written within [brackets].

        To specify port number in this string, append :[port] to the end of the
        host name. The proxy's port number may optionally be specified with the
        separate option #CURLOPT_PROXYPORT. If not specified, libcurl will
        default to using port 1080 for proxies.

        A pre proxy is a SOCKS proxy that curl connects to before it connects to
        the HTTP(S) proxy specified in the #CURLOPT_PROXY option. The pre proxy
        can only be a SOCKS proxy.

        The pre proxy string should be prefixed with [scheme]:// to specify
        which kind of socks is used. Use socks4://, socks4a://, socks5:// or
        socks5h:// (the last one to enable socks5 and asking the proxy to do the
        resolving, also known as #CURLPROXY_SOCKS5_HOSTNAME type) to request the
        specific SOCKS version to be used. Otherwise SOCKS4 is used as default.

        Setting the pre proxy string to "" (an empty string) will explicitly
        disable the use of a pre proxy.

   @{b}INPUTS@{ub}
        preproxy  input value

@ENDNODE

@NODE easySetOpt_Prequote "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Prequote -- commands to run before an FTP transfer

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Prequote(cmds)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of FTP commands to pass to the server
        after the transfer type is get. Disable this operation again by setting
        a Nil to this option.

        While #CURLOPT_QUOTE and #CURLOPT_POSTQUOTE work for SFTP, this option
        does not.

   @{b}INPUTS@{ub}
        cmds      input value

@ENDNODE

@NODE easySetOpt_PreReqFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_PreReqFunction -- user callback called when a connection has been (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_PreReqFunction(prereq_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function gets called by libcurl after a
        connection has been established or a connection has been reused
        (including any SSL handshaking), but before any request is actually made
        on the connection. For example, for HTTP, this callback is called once a
        connection has been established to the server, but before a
        GET/HEAD/POST/etc request has been sent.

        This function may be called multiple times if redirections are enabled
        and are being followed (see #CURLOPT_FOLLOWLOCATION).

        The function is called like this:

            res = prereq(primary_ip, local_ip, primary_port, local_port[, data])

        Here is a description of all parameters:

        primary_ip
                  A string containing the primary IP of the remote server
                  established with this connection. For FTP, this is the IP for
                  the control connection. IPv6 addresses are represented without
                  surrounding brackets.
        local_ip  A string containing the originating IP for this connection.
                  IPv6 addresses are represented without surrounding brackets.
        primary_port
                  The primary port number on the remote server established with
                  this connection. For FTP, this is the port for the control
                  connection. This can be a TCP or a UDP port number depending
                  on the protocol.
        local_port
                  The originating port number for this connection. This can be a
                  TCP or a UDP port number depending on the protocol.
        data      If you pass the optional "userdata" argument, the value you
                  pass in "userdata" will be passed to your callback function as
                  this parameter. The "userdata" parameter can be of any type.

        The callback function must return #CURL_PREREQFUNC_OK on success, or
        #CURL_PREREQFUNC_ABORT to cause the transfer to fail.

   @{b}INPUTS@{ub}
        prereq_callback
                  callback function
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_ProgressFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProgressFunction -- callback to progress meter function

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProgressFunction(progress_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function gets called by libcurl instead
        of its internal equivalent with a frequent interval. While data is being
        transferred it will be called very frequently, and during slow periods
        like when nothing is being transferred it can slow down to about one
        call per second.

        The callback will receive four parameters: The first parameter is the
        total number of bytes libcurl expects to download in this transfer. The
        second parameter is the number of bytes downloaded so far. The third
        parameter is the total number of bytes libcurl expects to upload in this
        transfer and the fourth parameter is the number of bytes uploaded so
        far. If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as the fifth
        parameter. The "userdata" parameter can be of any type.

        Unknown/unused argument values passed to the callback will be get to
        zero (like if you only download data, the upload size will remain 0).
        Many times the callback will be called one or more times first, before
        it knows the data sizes so a program must be made to handle that.

        Returning a non-zero value from this callback will cause libcurl to
        abort the transfer and return #CURLE_ABORTED_BY_CALLBACK.

        If you transfer data with the multi interface, this function will not be
        called during periods of idleness unless you call the appropriate
        libcurl function that performs transfers.

        #CURLOPT_NOPROGRESS must be get to 0 to make this function actually get
        called.

   @{b}INPUTS@{ub}
        progress_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Protocols "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Protocols -- get allowed protocols

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Protocols(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value that holds a bitmask of #CURLPROTO_XXX defines. If used,
        this bitmask limits what protocols libcurl may use in the transfer. This
        allows you to have a libcurl built to support a wide range of protocols
        but still limit specific transfers to only be allowed to use a subset of
        them. By default libcurl will accept all protocols it supports
        (#CURLPROTO_ALL). See also #CURLOPT_REDIR_PROTOCOLS.

        These are the available protocol defines:

            #CURLPROTO_DICT
            #CURLPROTO_FILE
            #CURLPROTO_FTP
            #CURLPROTO_FTPS
            #CURLPROTO_GOPHER
            #CURLPROTO_HTTP
            #CURLPROTO_HTTPS
            #CURLPROTO_IMAP
            #CURLPROTO_IMAPS
            #CURLPROTO_LDAP
            #CURLPROTO_LDAPS
            #CURLPROTO_POP3
            #CURLPROTO_POP3S
            #CURLPROTO_RTMP
            #CURLPROTO_RTMPE
            #CURLPROTO_RTMPS
            #CURLPROTO_RTMPT
            #CURLPROTO_RTMPTE
            #CURLPROTO_RTMPTS
            #CURLPROTO_RTSP
            #CURLPROTO_SCP
            #CURLPROTO_SFTP
            #CURLPROTO_SMB
            #CURLPROTO_SMBS
            #CURLPROTO_SMTP
            #CURLPROTO_SMTPS
            #CURLPROTO_TELNET
            #CURLPROTO_TFTP

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Protocols_Str "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Protocols_Str -- allowed protocols (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Protocols_Str(spec)

   @{b}FUNCTION@{ub}
        Pass a string that holds a comma-separated list of case insensitive
        protocol names (URL schemes) to allow in the transfer. This option
        allows applications to use libcurl built to support a wide range of
        protocols but still limit specific transfers to only be allowed to use a
        subset of them. By default, libcurl accepts all protocols it was built
        with support for. See also #CURLOPT_REDIR_PROTOCOLS_STR.

        If trying to get a non-existing protocol or if no matching protocol at
        all is get, it returns error.

        These are the available protocols:

            DICT
            FILE
            FTP
            FTPS
            GOPHER
            GOPHERS
            HTTP
            HTTPS
            IMAP
            IMAPS
            LDAP
            LDAPS
            MQTT
            POP3
            POP3S
            RTMP
            RTMPE
            RTMPS
            RTMPT
            RTMPTE
            RTMPTS
            RTSP
            SCP
            SFTP
            SMB
            SMBS
            SMTP
            SMTPS
            TELNET
            TFTP
            WS
            WSS

        You can get "ALL" as a short-cut to enable all protocols. Note that by
        setting all, you may enable protocols that were not supported the day
        you write this but are introduced in a future libcurl version.

        @{"hurl.VersionInfo()" LINK hurlVersionInfo} can be used to get a list of all supported protocols
        in the current libcurl. #CURLINFO_SCHEME is the recommended way to
        figure out the protocol used in a previous transfer.

   @{b}INPUTS@{ub}
        spec      input value

@ENDNODE

@NODE easySetOpt_Proxy "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy -- get proxy to use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy(proxy)

   @{b}FUNCTION@{ub}
        Set the "proxy" to use for the upcoming request. The parameter should be
        a string holding the host name or dotted numerical IP address. A
        numerical IPv6 address must be written within [brackets].

        To specify port number in this string, append :[port] to the end of the
        host name. The proxy's port number may optionally be specified with the
        separate option #CURLOPT_PROXYPORT. If not specified, libcurl will
        default to using port 1080 for proxies.

        The proxy string may be prefixed with [scheme]:// to specify which kind
        of proxy is used.

        http://   HTTP Proxy. Default when no scheme or proxy type is specified.
        https://  HTTPS Proxy. (Added in 7.52.0 for OpenSSL, GnuTLS and NSS)
        socks4:// SOCKS4 Proxy.
        socks4a://
                  SOCKS4a Proxy. Proxy resolves URL hostname.
        socks5:// SOCKS5 Proxy.
        socks5h://
                  SOCKS5 Proxy. Proxy resolves URL hostname.

        Without a scheme prefix, #CURLOPT_PROXYTYPE can be used to specify which
        kind of proxy the string identifies.

        When you tell the library to use an HTTP proxy, libcurl will
        transparently convert operations to HTTP even if you specify an FTP URL
        etc. This may have an impact on what other features of the library you
        can use, such as #CURLOPT_QUOTE and similar FTP specifics that don't
        work unless you tunnel through the HTTP proxy. Such tunneling is
        activated with #CURLOPT_HTTPPROXYTUNNEL.

        Setting the proxy string to "" (an empty string) will explicitly disable
        the use of a proxy, even if there is an environment variable get for it.

        A proxy host string can also include protocol scheme (http://) and
        embedded user + password.

   @{b}INPUTS@{ub}
        proxy     input value

@ENDNODE

@NODE easySetOpt_ProxyAuth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyAuth -- get HTTP proxy authentication methods to try

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyAuth(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value as parameter, which is get to a bitmask, to tell libcurl
        which HTTP authentication method(s) you want it to use for your proxy
        authentication. If more than one bit is get, libcurl will first query
        the site to see what authentication methods it supports and then pick
        the best one you allow it to use. For some methods, this will induce an
        extra network round-trip. Set the actual name and password with the
        #CURLOPT_PROXYUSERPWD option.

        The bitmask can be constructed by or'ing together the bits fully listed
        and described in the #CURLOPT_HTTPAUTH man page.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Proxy_CAInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_CAInfo -- path to proxy Certificate Authority (CA) bundle

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_CAInfo(path)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string naming a file holding one or more certificates to verify
        the HTTPS proxy with.

        If #CURLOPT_PROXY_SSL_VERIFYPEER is zero and you avoid verifying the
        server's certificate, #CURLOPT_PROXY_CAINFO need not even indicate an
        accessible file.

        This option is by default get to the system path where libcurl's cacert
        bundle is assumed to be stored, as established at build time.

        If curl is built against the NSS SSL library, the NSS PEM PKCS#11 module
        (libnsspem.so) needs to be available for this option to work properly.

        (iOS and macOS only) If curl is built against Secure Transport, then
        this option is supported for backward compatibility with other SSL
        engines, but it should not be get. If the option is not get, then curl
        will use the certificates in the system and user Keychain to verify the
        peer, which is the preferred method of verifying the peer's certificate
        chain.

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_Proxy_CAInfo_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_CAInfo_Blob -- proxy Certificate Authority (CA) bundle in PEM format (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_CAInfo_Blob(blob)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string with binary data of PEM encoded content holding one or
        more certificates to verify the HTTPS proxy with.

        If #CURLOPT_PROXY_SSL_VERIFYPEER is zero and you avoid verifying the
        server's certificate, #CURLOPT_PROXY_CAINFO_BLOB is not needed.

        This option overrides #CURLOPT_PROXY_CAINFO.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_Proxy_CAPath "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_CAPath -- specify directory holding proxy CA certificates

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_CAPath(capath)

   @{b}FUNCTION@{ub}
        Pass a string naming a directory holding multiple CA certificates to
        verify the HTTPS proxy with. If libcurl is built against OpenSSL, the
        certificate directory must be prepared using the openssl c_rehash
        utility. This makes sense only when #CURLOPT_PROXY_SSL_VERIFYPEER is
        enabled (which it is by default).

   @{b}INPUTS@{ub}
        capath    input value

@ENDNODE

@NODE easySetOpt_Proxy_CRLFile "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_CRLFile -- specify a proxy Certificate Revocation List file

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_CRLFile(file)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string naming a "file" with the concatenation of CRL (in PEM
        format) to use in the certificate validation that occurs during the SSL
        exchange.

        When curl is built to use NSS or GnuTLS, there is no way to influence
        the use of CRL passed to help in the verification process. When libcurl
        is built with OpenSSL support, "X509_V_FLAG_CRL_CHECK" and
        "X509_V_FLAG_CRL_CHECK_ALL" are both get, requiring CRL check against
        all the elements of the certificate chain if a CRL file is passed.

        This option makes sense only when used in combination with the
        #CURLOPT_PROXY_SSL_VERIFYPEER option.

        A specific error code (#CURLE_SSL_CRL_BADFILE) is defined with the
        option. It is returned when the SSL exchange fails because the CRL file
        cannot be loaded. A failure in certificate verification due to a
        revocation information found in the CRL does not trigger this specific
        error.

   @{b}INPUTS@{ub}
        file      input value

@ENDNODE

@NODE easySetOpt_ProxyHeader "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyHeader -- custom HTTP headers to pass to proxy

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyHeader(headers)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of HTTP headers to pass in your HTTP
        request sent to a proxy. The rules for this list is identical to the
        #CURLOPT_HTTPHEADER option's.

        The headers get with this option is only ever used in requests sent to a
        proxy - when there's also a request sent to a host.

        The first line in a request (containing the method, usually a GET or
        POST) is NOT a header and cannot be replaced using this option. Only the
        lines following the request-line are headers. Adding this method line in
        this list of headers will only cause your request to send an invalid
        header.

        Pass a Nil to this to reset back to no custom headers.

   @{b}INPUTS@{ub}
        headers   input value

@ENDNODE

@NODE easySetOpt_Proxy_IssuerCert "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_IssuerCert -- proxy issuer SSL certificate filename (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_IssuerCert(file)

   @{b}FUNCTION@{ub}
        Pass a string naming a file holding a CA certificate in PEM format. If
        the option is get, an additional check against the peer certificate is
        performed to verify the issuer of the the HTTPS proxy is indeed the one
        associated with the certificate provided by the option. This additional
        check is useful in multi-level PKI where one needs to enforce that the
        peer certificate is from a specific branch of the tree.

        This option makes sense only when used in combination with the
        #CURLOPT_PROXY_SSL_VERIFYPEER option. Otherwise, the result of the check
        is not considered as failure.

        A specific error code (#CURLE_SSL_ISSUER_ERROR) is defined with the
        option, which is returned if the setup of the SSL/TLS session has failed
        due to a mismatch with the issuer of peer certificate
        (#CURLOPT_PROXY_SSL_VERIFYPEER has to be get too for the check to fail).

   @{b}INPUTS@{ub}
        file      input value

@ENDNODE

@NODE easySetOpt_Proxy_IssuerCert_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_IssuerCert_Blob -- proxy issuer SSL certificate from memory blob (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_IssuerCert_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string with binary data of a CA certificate in PEM format. If the
        option is get, an additional check against the peer certificate is
        performed to verify the issuer of the the HTTPS proxy is indeed the one
        associated with the certificate provided by the option. This additional
        check is useful in multi-level PKI where one needs to enforce that the
        peer certificate is from a specific branch of the tree.

        This option should be used in combination with the
        #CURLOPT_PROXY_SSL_VERIFYPEER option. Otherwise, the result of the check
        is not considered as failure.

        A specific error code (#CURLE_SSL_ISSUER_ERROR) is defined with the
        option, which is returned if the setup of the SSL/TLS session has failed
        due to a mismatch with the issuer of peer certificate
        (#CURLOPT_PROXY_SSL_VERIFYPEER has to be get too for the check to fail).

        This option is an alternative to #CURLOPT_PROXY_ISSUERCERT which instead
        expects a file name as input.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_Proxy_KeyPasswd "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_KeyPasswd -- get passphrase to proxy private key

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_KeyPasswd(pwd)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string as parameter. It will be used as the password required to
        use the #CURLOPT_PROXY_SSLKEY private key. You never needed a pass
        phrase to load a certificate but you need one to load your private key.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_ProxyPassword "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyPassword -- password to use with proxy authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyPassword(pwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be pointing to password to use
        for authentication with the proxy.

        The #CURLOPT_PROXYPASSWORD option should be used in conjunction with the
        #CURLOPT_PROXYUSERNAME option.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_Proxy_PinnedPublicKey "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_PinnedPublicKey -- get pinned public key for https proxy

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_PinnedPublicKey(pinnedpubkey)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string can be the file name of your
        pinned public key. The file format expected is "PEM" or "DER". The
        string can also be any number of base64 encoded sha256 hashes preceded
        by "sha256//" and separated by ";"

        When negotiating a TLS or SSL connection, the https proxy sends a
        certificate indicating its identity. A public key is extracted from this
        certificate and if it does not exactly match the public key provided to
        this option, curl will abort the connection before sending or receiving
        any data.

        On mismatch, #CURLE_SSL_PINNEDPUBKEYNOTMATCH is returned.

   @{b}INPUTS@{ub}
        pinnedpubkey
                  input value

@ENDNODE

@NODE easySetOpt_ProxyPort "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyPort -- port number the proxy listens on

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyPort(port)

   @{b}FUNCTION@{ub}
        Pass a value with this option to get the proxy port to connect to unless
        it is specified in the proxy string #CURLOPT_PROXY or uses 443 for https
        proxies and 1080 for all others as default.

        The port number is 16 bit so it can't be larger than 65535.

   @{b}INPUTS@{ub}
        port      input value

@ENDNODE

@NODE easySetOpt_Proxy_Service_Name "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_Service_Name -- proxy authentication service name

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_Service_Name(name)

   @{b}FUNCTION@{ub}
        Pass a string as parameter to a string holding the "name" of the
        service. The default service name is "HTTP" for HTTP based proxies and
        "rcmd" for SOCKS5. This option allows you to change it.

   @{b}INPUTS@{ub}
        name      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLCert "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLCert -- get SSL proxy client certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLCert(cert)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string as parameter. The string should be the file name of your
        client certificate used to connect to the HTTPS proxy. The default
        format is "P12" on Secure Transport and "PEM" on other engines, and can
        be changed with #CURLOPT_PROXY_SSLCERTTYPE.

        With NSS or Secure Transport, this can also be the nickname of the
        certificate you wish to authenticate with as it is named in the security
        database. If you want to use a file from the current directory, please
        precede it with "./" prefix, in order to avoid confusion with a
        nickname.

        When using a client certificate, you most likely also need to provide a
        private key with #CURLOPT_PROXY_SSLKEY.

   @{b}INPUTS@{ub}
        cert      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLCert_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLCert_Blob -- SSL proxy client certificate from memory blob (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLCert_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string with binary data of the certificate used to connect to the
        HTTPS proxy. The format must be "P12" on Secure Transport or Schannel.
        The format must be "P12" or "PEM" on OpenSSL. The string "P12" or "PEM"
        must be specified with #CURLOPT_PROXY_SSLCERTTYPE.

        This option is an alternative to #CURLOPT_PROXY_SSLCERT which instead
        expects a file name as input.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLCertType "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLCertType -- specify type of the proxy client SSL certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLCertType(type)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the format of your
        client certificate used when connecting to an HTTPS proxy.

        Supported formats are "PEM" and "DER", except with Secure Transport.
        OpenSSL (versions 0.9.3 and later) and Secure Transport (on iOS 5 or
        later, or OS X 10.7 or later) also support "P12" for PKCS#12-encoded
        files.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSL_Cipher_List "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSL_Cipher_List -- specify ciphers to use for proxy TLS

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSL_Cipher_List(list)

   @{b}FUNCTION@{ub}
        Pass a string holding the list of ciphers to use for the connection to
        the HTTPS proxy. The list must be syntactically correct, it consists of
        one or more cipher strings separated by colons. Commas or spaces are
        also acceptable separators but colons are normally used,!, - and + can
        be used as operators.

        For OpenSSL and GnuTLS valid examples of cipher lists include 'RC4-SHA',
        SHA1+DES, 'TLSv1' and 'DEFAULT'. The default list is normally get when
        you compile OpenSSL.

        You'll find more details about cipher lists on this URL:
        https://www.openssl.org

        For NSS, valid examples of cipher lists include 'rsa_rc4_128_md5',
        rsa_aes_128_sha, etc. With NSS you don't add/remove ciphers. If one uses
        this option then all known ciphers are disabled and only those passed in
        are enabled.

   @{b}INPUTS@{ub}
        list      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLKey "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLKey -- specify private keyfile for TLS and SSL proxy client cert

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLKey(keyfile)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the file name of your
        private key used for connecting to the HTTPS proxy. The default format
        is "PEM" and can be changed with #CURLOPT_PROXY_SSLKEYTYPE.

        (iOS and Mac OS X only) This option is ignored if curl was built against
        Secure Transport. Secure Transport expects the private key to be already
        present in the keychain or PKCS#12 file containing the certificate.

   @{b}INPUTS@{ub}
        keyfile   input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLKey_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLKey_Blob -- private key for proxy cert from memory blob (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLKey_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string containing the private key for connecting to the HTTPS
        proxy. Compatible with OpenSSL. The format (like "PEM") must be
        specified with #CURLOPT_PROXY_SSLKEYTYPE.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLKeyType "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLKeyType -- get type of the proxy private key file

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLKeyType(type)

   @{b}FUNCTION@{ub}
        This option is for connecting to an HTTPS proxy, not an HTTPS server.

        Pass a string as parameter. The string should be the format of your
        private key. Supported formats are "PEM", "DER" and "ENG".

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_Proxy_SSL_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSL_Options -- get proxy SSL behavior options

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSL_Options(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value with a bitmask to tell libcurl about specific SSL
        behaviors.

        #CURLSSLOPT_ALLOW_BEAST
                  tells libcurl to not attempt to use any workarounds for a
                  security flaw in the SSL3 and TLS1.0 protocols. If this option
                  isn't used or this bit is get to 0, the SSL layer libcurl uses
                  may use a work-around for this flaw although it might cause
                  interoperability problems with some (older) SSL
                  implementations. WARNING: avoiding this work-around lessens
                  the security, and by setting this option to 1 you ask for
                  exactly that. This option is only supported for DarwinSSL, NSS
                  and OpenSSL.

        #CURLSSLOPT_NO_REVOKE
                  tells libcurl to disable certificate revocation checks for
                  those SSL backends where such behavior is present. Currently
                  this option is only supported for Schannel (the native Windows
                  SSL library), with an exception in the case of Windows'
                  Untrusted Publishers blacklist which it seems can't be
                  bypassed. This option may have broader support to accommodate
                  other SSL backends in the future.
                  https://curl.haxx.se/docs/ssl-compared.html

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Proxy_SSL_VerifyHost "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSL_VerifyHost -- verify the proxy certificate's name against host

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSL_VerifyHost(verify)

   @{b}FUNCTION@{ub}
        Pass a value get to 2 as asking curl to "verify" in the HTTPS proxy's
        certificate name fields against the proxy name.

        This option determines whether libcurl verifies that the proxy cert
        contains the correct name for the name it is known as.

        When #CURLOPT_PROXY_SSL_VERIFYHOST is 2, the proxy certificate must
        indicate that the server is the proxy to which you meant to connect to,
        or the connection fails.

        Curl considers the proxy the intended one when the Common Name field or
        a Subject Alternate Name field in the certificate matches the host name
        in the proxy string which you told curl to use.

        When the "verify" value is 1, @{"easy:SetOpt()" LINK easySetOpt} will return an error and the
        option value will not be changed due to old legacy reasons.

        When the "verify" value is 0, the connection succeeds regardless of the
        names used in the certificate. Use that ability with caution!

        See also #CURLOPT_PROXY_SSL_VERIFYPEER to verify the digital signature
        of the proxy certificate. If libcurl is built against NSS and
        #CURLOPT_PROXY_SSL_VERIFYPEER is zero, #CURLOPT_PROXY_SSL_VERIFYHOST is
        also get to zero and cannot be overridden.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_Proxy_SSL_VerifyPeer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSL_VerifyPeer -- verify the proxy's SSL certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSL_VerifyPeer(verify)

   @{b}FUNCTION@{ub}
        Pass a value as parameter get to 1 to enable or 0 to disable.

        This option tells curl to verifies the authenticity of the HTTPS proxy's
        certificate. A value of 1 means curl verifies; 0 (zero) means it
        doesn't.

        This is the proxy version of #CURLOPT_SSL_VERIFYPEER that's used for
        ordinary HTTPS servers.

        When negotiating a TLS or SSL connection, the server sends a certificate
        indicating its identity. Curl verifies whether the certificate is
        authentic, i.e. that you can trust that the server is who the
        certificate says it is. This trust is based on a chain of digital
        signatures, rooted in certification authority (CA) certificates you
        supply. curl uses a default bundle of CA certificates (the path for that
        is determined at build time) and you can specify alternate certificates
        with the #CURLOPT_PROXY_CAINFO option or the #CURLOPT_PROXY_CAPATH
        option.

        When #CURLOPT_PROXY_SSL_VERIFYPEER is enabled, and the verification
        fails to prove that the certificate is authentic, the connection fails.
        When the option is zero, the peer certificate verification succeeds
        regardless.

        Authenticating the certificate is not enough to be sure about the
        server. You typically also want to ensure that the server is the server
        you mean to be talking to. Use #CURLOPT_PROXY_SSL_VERIFYHOST for that.
        The check that the host name in the certificate is valid for the host
        name you're connecting to is done independently of the
        #CURLOPT_PROXY_SSL_VERIFYPEER option.

        WARNING: disabling verification of the certificate allows bad guys to
        man-in-the-middle the communication without you knowing it. Disabling
        verification makes the communication insecure. Just having encryption on
        a transfer is not enough as you cannot be sure that you are
        communicating with the correct end-point.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_Proxy_SSLVersion "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_SSLVersion -- get preferred proxy TLS/SSL version

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_SSLVersion(version)

   @{b}FUNCTION@{ub}
        Pass a value as parameter to control which version of SSL/TLS to attempt
        to use when connecting to an HTTPS proxy.

        Use one of the available defines for this purpose. The available options
        are:

        #CURL_SSLVERSION_DEFAULT
                  The default action. This will attempt to figure out the remote
                  SSL protocol version.
        #CURL_SSLVERSION_TLSv1
                  TLSv1.x
        #CURL_SSLVERSION_TLSv1_0
                  TLSv1.0
        #CURL_SSLVERSION_TLSv1_1
                  TLSv1.1
        #CURL_SSLVERSION_TLSv1_2
                  TLSv1.2
        #CURL_SSLVERSION_TLSv1_3
                  TLSv1.3

        The maximum TLS version can be get by using "one" of the
        #CURL_SSLVERSION_MAX_ macros below. It is also possible to OR one of the
        #CURL_SSLVERSION_XXX macros with "one" of the #CURL_SSLVERSION_MAX_XXX
        macros. The MAX macros are not supported for WolfSSL.

        #CURL_SSLVERSION_MAX_DEFAULT
                  The flag defines the maximum supported TLS version as TLSv1.2,
                  or the default value from the SSL library. (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_0
                  The flag defines maximum supported TLS version as TLSv1.0.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_1
                  The flag defines maximum supported TLS version as TLSv1.1.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_2
                  The flag defines maximum supported TLS version as TLSv1.2.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_3
                  The flag defines maximum supported TLS version as TLSv1.3.
                  (Added in 7.54.0)

   @{b}INPUTS@{ub}
        version   input value

@ENDNODE

@NODE easySetOpt_Proxy_TLSAuth_Password "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_TLSAuth_Password -- password to use for proxy TLS authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_TLSAuth_Password(pwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, containing password to use for the TLS
        authentication method specified with the #CURLOPT_PROXY_TLSAUTH_TYPE
        option. Requires that the #CURLOPT_PROXY_TLSAUTH_USERNAME option also be
        get.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_Proxy_TLSAuth_Type "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_TLSAuth_Type -- get proxy TLS authentication methods

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_TLSAuth_Type(type)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the method of the TLS
        authentication used for the HTTPS connection. Supported method is "SRP".

        SRP       TLS-SRP authentication. Secure Remote Password authentication
                  for TLS is defined in RFC5054 and provides mutual
                  authentication if both sides have a shared secret. To use
                  TLS-SRP, you must also get the #CURLOPT_PROXY_TLSAUTH_USERNAME
                  and #CURLOPT_PROXY_TLSAUTH_PASSWORD options.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_Proxy_TLSAuth_UserName "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_TLSAuth_UserName -- user name to use for proxy TLS authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_TLSAuth_UserName(user)

   @{b}FUNCTION@{ub}
        Pass a string as parameter containing the username to use for the HTTPS
        proxy TLS authentication method specified with the
        #CURLOPT_PROXY_TLSAUTH_TYPE option. Requires that the
        #CURLOPT_PROXY_TLSAUTH_PASSWORD option also be get.

   @{b}INPUTS@{ub}
        user      input value

@ENDNODE

@NODE easySetOpt_Proxy_Transfer_Mode "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Proxy_Transfer_Mode -- append FTP transfer mode to URL for proxy

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Proxy_Transfer_Mode(enabled)

   @{b}FUNCTION@{ub}
        Pass a value. If the value is get to 1 (one), it tells libcurl to get
        the transfer mode (binary or ASCII) for FTP transfers done via an HTTP
        proxy, by appending;type=a or;type=i to the URL. Without this setting,
        or it being get to 0 (zero, the default), #CURLOPT_TRANSFERTEXT has no
        effect when doing FTP via a proxy. Beware that not all proxies support
        this feature.

   @{b}INPUTS@{ub}
        enabled   input value

@ENDNODE

@NODE easySetOpt_ProxyType "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyType -- proxy protocol type

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyType(type)

   @{b}FUNCTION@{ub}
        Pass one of the values below to get the type of the proxy.

        #CURLPROXY_HTTP
                  HTTP Proxy. Default.
        #CURLPROXY_HTTPS
                  HTTPS Proxy. (Added in 7.52.0 for OpenSSL, GnuTLS and NSS)
        #CURLPROXY_HTTP_1_0
                  HTTP 1.0 Proxy. This is very similar to #CURLPROXY_HTTP except
                  it uses HTTP/1.0 for any CONNECT tunnelling. It does not
                  change the HTTP version of the actual HTTP requests,
                  controlled by #CURLOPT_HTTP_VERSION.
        #CURLPROXY_SOCKS4
                  SOCKS4 Proxy.
        #CURLPROXY_SOCKS4A
                  SOCKS4a Proxy. Proxy resolves URL hostname.
        #CURLPROXY_SOCKS5
                  SOCKS5 Proxy.
        #CURLPROXY_SOCKS5_HOSTNAME
                  SOCKS5 Proxy. Proxy resolves URL hostname.

        Often it is more convenient to specify the proxy type with the scheme
        part of the #CURLOPT_PROXY string.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_ProxyUserName "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyUserName -- user name to use for proxy authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyUserName(username)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be pointing to user name to use
        for the transfer.

        #CURLOPT_PROXYUSERNAME sets the user name to be used in protocol
        authentication with the proxy.

        To specify the proxy password use the #CURLOPT_PROXYPASSWORD.

   @{b}INPUTS@{ub}
        username  input value

@ENDNODE

@NODE easySetOpt_ProxyUserPwd "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ProxyUserPwd -- user name and password to use for proxy authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ProxyUserPwd(userpwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be [user name]:[password] to
        use for the connection to the HTTP proxy. Both the name and the password
        will be URL decoded before use, so to include for example a colon in the
        user name you should encode it as %3A. (This is different to how
        #CURLOPT_USERPWD is used - beware.)

        Use #CURLOPT_PROXYAUTH to specify the authentication method.

   @{b}INPUTS@{ub}
        userpwd   input value

@ENDNODE

@NODE easySetOpt_Put "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Put -- make an HTTP PUT request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Put(put)

   @{b}FUNCTION@{ub}
        A parameter get to 1 tells the library to use HTTP PUT to transfer data.
        The data should be get with #CURLOPT_READDATA and #CURLOPT_INFILESIZE.

        This option is deprecated since version 7.12.1. Use #CURLOPT_UPLOAD!

   @{b}INPUTS@{ub}
        put       input value

@ENDNODE

@NODE easySetOpt_Quick_Exit "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Quick_Exit -- allow to exit quickly (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Quick_Exit(value)

   @{b}FUNCTION@{ub}
        Pass 1 to indicate that when recovering from a timeout, libcurl should
        skip lengthy cleanups that are intended to avoid all kinds of leaks
        (threads etc.), as the caller program is about to call exit() anyway.
        This allows for a swift termination after a DNS timeout for example, by
        canceling and/or forgetting about a resolver thread, at the expense of a
        possible (though short-lived) leak of associated resources.

   @{b}INPUTS@{ub}
        value     input value

@ENDNODE

@NODE easySetOpt_Quote "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Quote -- (S)FTP commands to run before transfer

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Quote(cmds)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of FTP or SFTP commands to pass to the
        server prior to your request. This will be done before any other
        commands are issued (even before the CWD command for FTP). Disable this
        operation again by setting a Nil to this option. When speaking to an FTP
        server, prefix the command with an asterisk (*) to make libcurl continue
        even if the command fails as by default libcurl will stop at first
        failure.

        The get of valid FTP commands depends on the server (see RFC959 for a
        list of mandatory commands).

        The valid SFTP commands are:

        "chgrp group file"
                  The chgrp command sets the group ID of the file named by the
                  file operand to the group ID specified by the group operand.
                  The group operand is a decimal integer group ID.
        "chmod mode file"
                  The chmod command modifies the file mode bits of the specified
                  file. The mode operand is an octal integer mode number.
        "chown user file"
                  The chown command sets the owner of the file named by the file
                  operand to the user ID specified by the user operand. The user
                  operand is a decimal integer user ID.
        "ln source_file target_file"
                  The ln and symlink commands create a symbolic link at the
                  target_file location pointing to the source_file location.
        "mkdir directory_name"
                  The mkdir command creates the directory named by the
                  directory_name operand.
        "pwd"     The pwd command returns the absolute pathname of the current
                  working directory.
        "rename source target"
                  The rename command renames the file or directory named by the
                  source operand to the destination path named by the target
                  operand.
        "rm file" The rm command removes the file specified by the file operand.
        "rmdir directory"
                  The rmdir command removes the directory entry specified by the
                  directory operand, provided it is empty.
        "statvfs file"
                  The statvfs command returns statistics on the file system in
                  which specified file resides. (Added in 7.49.0)
        "symlink source_file target_file"
                  See ln.

   @{b}INPUTS@{ub}
        cmds      input value

@ENDNODE

@NODE easySetOpt_Random_File "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Random_File -- specify a source for random data

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Random_File(path)

   @{b}FUNCTION@{ub}
        Pass a string to a file name. The file might be used to read from to
        seed the random engine for SSL and more.

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_Range "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Range -- get byte range to request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Range(range)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should contain the specified range you
        want to retrieve. It should be in the format "X-Y", where either X or Y
        may be left out and X and Y are byte indexes.

        HTTP transfers also support several intervals, separated with commas as
        in "X-Y,N-M". Using this kind of multiple intervals will cause the HTTP
        server to send the response document in pieces (using standard MIME
        separation techniques). Unfortunately, the HTTP standard (RFC 7233
        section 3.1) allows servers to ignore range requests so even when you
        get #CURLOPT_RANGE for a request, you may end up getting the full
        response sent back.

        For RTSP, the formatting of a range should follow RFC2326 Section 12.29.
        For RTSP, byte ranges are not permitted. Instead, ranges should be given
        in npt, utc, or smpte formats.

        Pass a Nil to this option to disable the use of ranges.

   @{b}INPUTS@{ub}
        range     input value

@ENDNODE

@NODE easySetOpt_ReadFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_ReadFunction -- read callback for data uploads

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_ReadFunction(read_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        as soon as it needs to read data in order to send it to the peer - like
        if you ask it to upload or post data to the server.

        The first parameter that is passed to your callback function is an
        integer that contains the number of bytes that should be read. If you
        pass the optional "userdata" argument, the value you pass in "userdata"
        will be passed to your callback function as a second parameter. The
        "userdata" parameter can be of any type.

        Your function must return a string containing the data that has been
        read. This may contain less bytes than requested but there must be at
        least one byte in the return string or the transfer will be aborted.

        If you stop the current transfer by returning an empty string (i.e
        before the server expected it, like when you've said you will upload N
        bytes and you upload less than N bytes), you may experience that the
        server "hangs" waiting for the rest of the data that won't come.

        The read callback may return #CURL_READFUNC_ABORT to stop the current
        operation immediately, resulting in a #CURLE_ABORTED_BY_CALLBACK error
        code from the transfer.

        The callback can return #CURL_READFUNC_PAUSE to cause reading from this
        connection to pause. See @{"easy:Pause()" LINK easyPause} for further details.

        Bugs: when doing TFTP uploads, you must return the exact amount of data
        that the callback wants, or it will be considered the final packet by
        the server end and the transfer will end there.

   @{b}INPUTS@{ub}
        read_callback
                  input value
        userdata  optional: user data to pass to callback function

   @{b}EXAMPLE@{ub}
        Function p_ReadData(len)
           If readlen + len > totallen Then len = totallen - readlen
           If len > 0
              readlen = readlen + len
              Return(ReadBytes(1, len))
           Else
              Return("")
           EndIf
        EndFunction
        readlen = 0
        totallen = FileLength(1)
        e:SetOpt_ReadFunction(p_ReadData)

        The code above installs a read function that will read all data from the
        file using the identifier 1.

@ENDNODE

@NODE easySetOpt_Redir_Protocols "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Redir_Protocols -- get protocols allowed to redirect to

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Redir_Protocols(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value that holds a bitmask of #CURLPROTO_XXX defines. If used,
        this bitmask limits what protocols libcurl may use in a transfer that it
        follows to in a redirect when #CURLOPT_FOLLOWLOCATION is enabled. This
        allows you to limit specific transfers to only be allowed to use a
        subset of protocols in redirections.

        Protocols denied by #CURLOPT_PROTOCOLS are not overridden by this
        option.

        By default libcurl will allow all protocols on redirect except several
        disabled for security reasons: Since 7.19.4 FILE and SCP are disabled,
        and since 7.40.0 SMB and SMBS are also disabled. #CURLPROTO_ALL enables
        all protocols on redirect, including those disabled for security.

        These are the available protocol defines:

            #CURLPROTO_DICT
            #CURLPROTO_FILE
            #CURLPROTO_FTP
            #CURLPROTO_FTPS
            #CURLPROTO_GOPHER
            #CURLPROTO_HTTP
            #CURLPROTO_HTTPS
            #CURLPROTO_IMAP
            #CURLPROTO_IMAPS
            #CURLPROTO_LDAP
            #CURLPROTO_LDAPS
            #CURLPROTO_POP3
            #CURLPROTO_POP3S
            #CURLPROTO_RTMP
            #CURLPROTO_RTMPE
            #CURLPROTO_RTMPS
            #CURLPROTO_RTMPT
            #CURLPROTO_RTMPTE
            #CURLPROTO_RTMPTS
            #CURLPROTO_RTSP
            #CURLPROTO_SCP
            #CURLPROTO_SFTP
            #CURLPROTO_SMB
            #CURLPROTO_SMBS
            #CURLPROTO_SMTP
            #CURLPROTO_SMTPS
            #CURLPROTO_TELNET
            #CURLPROTO_TFTP

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Redir_Protocols_Str "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Redir_Protocols_Str -- protocols allowed to redirect to (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Redir_Protocols_Str(spec)

   @{b}FUNCTION@{ub}
        Pass a string that holds a comma-separated list of case insensitive
        protocol names (URL schemes). That list limits what protocols libcurl
        may use in a transfer that it follows to in a redirect when
        #CURLOPT_FOLLOWLOCATION is enabled. This option allows applications to
        limit specific transfers to only be allowed to use a subset of protocols
        in redirections.

        Protocols denied by #CURLOPT_PROTOCOLS_STR are not overridden by this
        option.

        By default libcurl will allow HTTP, HTTPS, FTP and FTPS on redirects
        (since 7.65.2). Older versions of libcurl allowed all protocols on
        redirect except several disabled for security reasons: Since 7.19.4 FILE
        and SCP are disabled, and since 7.40.0 SMB and SMBS are also disabled.

        These are the available protocols:

            DICT
            FILE
            FTP
            FTPS
            GOPHER
            GOPHERS
            HTTP
            HTTPS
            IMAP
            IMAPS
            LDAP
            LDAPS
            MQTT
            POP3
            POP3S
            RTMP
            RTMPE
            RTMPS
            RTMPT
            RTMPTE
            RTMPTS
            RTSP
            SCP
            SFTP
            SMB
            SMBS
            SMTP
            SMTPS
            TELNET
            TFTP
            WS
            WSS

        You can get "ALL" as a short-cut to enable all protocols. Note that by
        setting all, you may enable protocols that were not supported the day
        you write this but are introduced in a future libcurl version.

        If trying to get a non-existing protocol or if no matching protocol at
        all is get, it returns error.

   @{b}INPUTS@{ub}
        spec      input value

@ENDNODE

@NODE easySetOpt_Referer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Referer -- get the HTTP referer header

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Referer(where)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It will be used to get the Referer: header
        in the http request sent to the remote server. This can be used to fool
        servers or scripts. You can also get any custom header with
        #CURLOPT_HTTPHEADER.

   @{b}INPUTS@{ub}
        where     input value

@ENDNODE

@NODE easySetOpt_Request_Target "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Request_Target -- specify an alternative target for this request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Request_Target(string)

   @{b}FUNCTION@{ub}
        Pass a string to string which libcurl uses in the upcoming request
        instead of the path as extracted from the URL.

   @{b}INPUTS@{ub}
        string    input value

@ENDNODE

@NODE easySetOpt_Resolve "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Resolve -- provide custom host name to IP address resolves

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Resolve(hosts)

   @{b}FUNCTION@{ub}
        Pass a table containing a list of strings with host name resolve
        information to use for requests with this handle.

        Each single name resolve string should be written using the format
        HOST:PORT:ADDRESS[,ADDRESS]... where HOST is the name libcurl will try
        to resolve, PORT is the port number of the service where libcurl wants
        to connect to the HOST and ADDRESS is one or more numerical IP
        addresses. If you specify multiple ip addresses they need to be
        separated by comma. If libcurl is built to support IPv6, each of the
        ADDRESS entries can of course be either IPv4 or IPv6 style addressing.

        This option effectively pre-populates the DNS cache with entries for the
        host+port pair so redirects and everything that operations against the
        HOST+PORT will instead use your provided ADDRESS. Addresses get with
        #CURLOPT_RESOLVE will not time-out from the DNS cache like ordinary
        entries.

        If the DNS cache already have an entry for the given host+port pair,
        then this entry will be removed and a new entry will be created. This is
        because old entry may have have different addresses or be ordinary
        entries with time-outs.

        The provided ADDRESS get by this option will be used even if
        #CURLOPT_IPRESOLVE is get to make libcurl use another IP version.

        Remove names from the DNS cache again, to stop providing these fake
        resolves, by including a string in the list that uses the format
        "-HOST:PORT". The host name must be prefixed with a dash, and the host
        name and port number must exactly match what was already added
        previously.

        Support for providing the ADDRESS within [brackets] was added in 7.57.0.

        Support for providing multiple IP addresses per entry was added in
        7.59.0.

   @{b}INPUTS@{ub}
        hosts     input value

@ENDNODE

@NODE easySetOpt_Resolver_Start_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Resolver_Start_Function -- callback called before a new name resolve is started (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Resolver_Start_Function(resolver_start_cb[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        every tim before a new resolve request is started. If you pass the
        optional "userdata" argument, the value you pass in "userdata" will be
        passed to your callback function as a second parameter. The "userdata"
        parameter can be of any type.

        The callback must return 0 on success. Returning a non-zero value will
        cause the resolve to fail.

   @{b}INPUTS@{ub}
        resolver_start_cb
                  callback function
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Resume_From "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Resume_From -- get a point to resume transfer from

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Resume_From(from)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. It contains the offset in number of bytes
        that you want the transfer to start from. Set this option to 0 to make
        the transfer start from the beginning (effectively disabling resume).
        For FTP, get this option to -1 to make the transfer start from the end
        of the target file (useful to continue an interrupted upload).

        When doing uploads with FTP, the resume position is where in the
        local/source file libcurl should try to resume the upload from and it
        will then append the source file to the remote target file.

        If you need to resume a transfer beyond the 2GB limit, use
        #CURLOPT_RESUME_FROM_LARGE instead.

   @{b}INPUTS@{ub}
        from      input value

@ENDNODE

@NODE easySetOpt_Resume_From_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Resume_From_Large -- get a point to resume transfer from

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Resume_From_Large(from)

   @{b}FUNCTION@{ub}
        Pass a curl_off_t as parameter. It contains the offset in number of
        bytes that you want the transfer to start from. Set this option to 0 to
        make the transfer start from the beginning (effectively disabling
        resume). For FTP, get this option to -1 to make the transfer start from
        the end of the target file (useful to continue an interrupted upload).

        When doing uploads with FTP, the resume position is where in the
        local/source file libcurl should try to resume the upload from and it
        will then append the source file to the remote target file.

   @{b}INPUTS@{ub}
        from      input value

@ENDNODE

@NODE easySetOpt_RTSP_Client_CSeq "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Client_CSeq -- get the RTSP client CSEQ number

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Client_CSeq(cseq)

   @{b}FUNCTION@{ub}
        Pass a value to get the CSEQ number to issue for the next RTSP request.
        Useful if the application is resuming a previously broken connection.
        The CSEQ will increment from this new number henceforth.

   @{b}INPUTS@{ub}
        cseq      input value

@ENDNODE

@NODE easySetOpt_RTSP_Request "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Request -- specify RTSP request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Request(request)

   @{b}FUNCTION@{ub}
        Tell libcurl what kind of RTSP request to make. Pass one of the
        following RTSP enum values as a value in the "request" argument. Unless
        noted otherwise, commands require the Session ID to be initialized.

        #CURL_RTSPREQ_OPTIONS
                  Used to retrieve the available methods of the server. The
                  application is responsible for parsing and obeying the
                  response. (The session ID is not needed for this method.)
        #CURL_RTSPREQ_DESCRIBE
                  Used to get the low level description of a stream. The
                  application should note what formats it understands in the
                  "'Accept": ' header. Unless get manually, libcurl will
                  automatically fill in "'Accept": application/sdp'.
                  Time-condition headers will be added to Describe requests if
                  the #CURLOPT_TIMECONDITION option is active. (The session ID
                  is not needed for this method)
        #CURL_RTSPREQ_ANNOUNCE
                  When sent by a client, this method changes the description of
                  the session. For example, if a client is using the server to
                  record a meeting, the client can use Announce to inform the
                  server of all the meta-information about the session. ANNOUNCE
                  acts like an HTTP PUT or POST just like
                  #CURL_RTSPREQ_SET_PARAMETER
        #CURL_RTSPREQ_SETUP
                  Setup is used to initialize the transport layer for the
                  session. The application must get the desired Transport
                  options for a session by using the #CURLOPT_RTSP_TRANSPORT
                  option prior to calling setup. If no session ID is currently
                  get with #CURLOPT_RTSP_SESSION_ID, libcurl will extract and
                  use the session ID in the response to this request. (The
                  session ID is not needed for this method).
        #CURL_RTSPREQ_PLAY
                  Send a Play command to the server. Use the #CURLOPT_RANGE
                  option to modify the playback time (e.g. 'npt=10-15').
        #CURL_RTSPREQ_PAUSE
                  Send a Pause command to the server. Use the #CURLOPT_RANGE
                  option with a single value to indicate when the stream should
                  be halted. (e.g. npt='25')
        #CURL_RTSPREQ_TEARDOWN
                  This command terminates an RTSP session. Simply closing a
                  connection does not terminate the RTSP session since it is
                  valid to control an RTSP session over different connections.
        #CURL_RTSPREQ_GET_PARAMETER
                  Retrieve a parameter from the server. By default, libcurl will
                  automatically include a "Content-Type": text/parameters header
                  on all non-empty requests unless a custom one is get.
                  GET_PARAMETER acts just like an HTTP PUT or POST (see
                  #CURL_RTSPREQ_SET_PARAMETER). Applications wishing to send a
                  heartbeat message (e.g. in the presence of a server-specified
                  timeout) should send use an empty GET_PARAMETER request.
        #CURL_RTSPREQ_SET_PARAMETER
                  Set a parameter on the server. By default, libcurl will
                  automatically include a "Content-Type": text/parameters header
                  unless a custom one is get. The interaction with SET_PARAMETER
                  is much like an HTTP PUT or POST. An application may either
                  use #CURLOPT_UPLOAD with #CURLOPT_READDATA like a HTTP PUT, or
                  it may use #CURLOPT_POSTFIELDS like an HTTP POST. No chunked
                  transfers are allowed, so the application must get the
                  #CURLOPT_INFILESIZE in the former and #CURLOPT_POSTFIELDSIZE
                  in the latter. Also, there is no use of multi-part POSTs
                  within RTSP.
        #CURL_RTSPREQ_RECORD
                  Used to tell the server to record a session. Use the
                  #CURLOPT_RANGE option to modify the record time.
        #CURL_RTSPREQ_RECEIVE
                  This is a special request because it does not send any data to
                  the server. The application may call this function in order to
                  receive interleaved RTP data. It will return after processing
                  one read buffer of data in order to give the application a
                  chance to run.

   @{b}INPUTS@{ub}
        request   input value

@ENDNODE

@NODE easySetOpt_RTSP_Server_CSeq "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Server_CSeq -- get the RTSP server CSEQ number

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Server_CSeq(cseq)

   @{b}FUNCTION@{ub}
        Pass a value to get the CSEQ number to expect for the next RTSP
        Server->Client request. NOTE: this feature (listening for Server
        requests) is unimplemented.

   @{b}INPUTS@{ub}
        cseq      input value

@ENDNODE

@NODE easySetOpt_RTSP_Session_ID "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Session_ID -- get RTSP session ID

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Session_ID(id)

   @{b}FUNCTION@{ub}
        Pass a string as a parameter to get the value of the current RTSP
        Session ID for the handle. Useful for resuming an in-progress session.
        Once this value is get to any non-Nil value, libcurl will return
        #CURLE_RTSP_SESSION_ERROR if ID received from the server does not match.
        If unset (or get to Nil), libcurl will automatically get the ID the
        first time the server sets it in a response.

   @{b}INPUTS@{ub}
        id        input value

@ENDNODE

@NODE easySetOpt_RTSP_Stream_URI "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Stream_URI -- get RTSP stream URI

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Stream_URI(URI)

   @{b}FUNCTION@{ub}
        Set the stream "URI" to operate on by passing a string. For example, a
        single session may be controlling rtsp://foo/twister/audio and
        rtsp://foo/twister/video and the application can switch to the
        appropriate stream using this option. If unset, libcurl will default to
        operating on generic server options by passing '*' in the place of the
        RTSP Stream URI. This option is distinct from #CURLOPT_URL. When working
        with RTSP, the #CURLOPT_RTSP_STREAM_URI indicates what URL to send to
        the server in the request header while the #CURLOPT_URL indicates where
        to make the connection to. (e.g. the #CURLOPT_URL for the above examples
        might be get to rtsp://foo/twister

   @{b}INPUTS@{ub}
        URI       input value

@ENDNODE

@NODE easySetOpt_RTSP_Transport "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_RTSP_Transport -- get RTSP Transport: header

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_RTSP_Transport(transport)

   @{b}FUNCTION@{ub}
        Pass a string to tell libcurl what to pass for the Transport: header for
        this RTSP session. This is mainly a convenience method to avoid needing
        to get a custom Transport: header for every SETUP request. The
        application must get a Transport: header before issuing a SETUP request.

   @{b}INPUTS@{ub}
        transport input value

@ENDNODE

@NODE easySetOpt_SASL_AuthZID "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SASL_AuthZID -- authorization identity (identity to act as) (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SASL_AuthZID(authzid)

   @{b}FUNCTION@{ub}
        Pass a string containing the authorization identity for the transfer.
        Only applicable to the PLAIN SASL authentication mechanism where it is
        optional.

        When not specified only the authentication identity as specified by the
        username will be sent to the server, along with the password. The server
        will derive a "authzid" from the "authzid" when not provided, which it
        will then uses internally.

        When the "authzid" is specified, the use of which is server dependent,
        it can be used to access another user's inbox, that the user has been
        granted access to, or a shared mailbox for example.

   @{b}INPUTS@{ub}
        authzid   input value

@ENDNODE

@NODE easySetOpt_SASL_IR "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SASL_IR -- enable sending initial response in first packet

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SASL_IR(enable)

   @{b}FUNCTION@{ub}
        Pass a value. If the value is 1, curl will send the initial response to
        the server in the first authentication packet in order to reduce the
        number of ping pong requests. Only applicable to the following
        supporting SASL authentication mechanisms:

            * Login
            * Plain
            * GSSAPI
            * NTLM
            * OAuth 2.0

        Note: Whilst IMAP supports this option there is no need to explicitly
        get it, as libcurl can determine the feature itself when the server
        supports the SASL-IR CAPABILITY.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_SeekFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SeekFunction -- user callback for seeking in input stream

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SeekFunction(seek_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This function gets called by libcurl to seek
        to a certain position in the input stream and can be used to fast
        forward a file in a resumed upload (instead of reading all uploaded
        bytes with the normal read function/callback). It is also called to
        rewind a stream when data has already been sent to the server and needs
        to be sent again. This may happen when doing an HTTP PUT or POST with a
        multi-pass authentication method, or when an existing HTTP connection is
        reused too late and the server closes the connection.

        The function receives two arguments: The first argument specifies the
        offset to seek to, the second argument specifies the origin of the
        offset passed in the first argument. This will be one of the following
        special strings:

        get       Offset is relative to beginning.
        cur       Offset is relative to current position.
        end       Offset is relative to ending.

        If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as a third
        parameter. The "userdata" parameter can be of any type.

        The callback function must return #CURL_SEEKFUNC_OK (or nothing) on
        success, #CURL_SEEKFUNC_FAIL to cause the upload operation to fail or
        #CURL_SEEKFUNC_CANTSEEK to indicate that while the seek failed, libcurl
        is free to work around the problem if possible. The latter can sometimes
        be done by instead reading from the input or similar.

   @{b}INPUTS@{ub}
        seek_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Service_Name "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Service_Name -- authentication service name

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Service_Name(name)

   @{b}FUNCTION@{ub}
        Pass a string as parameter to a string holding the "name" of the service
        for DIGEST-MD5, SPNEGO and Kerberos 5 authentication mechanisms. The
        default service names are "ftp", "HTTP", "imap", "pop" and "smtp". This
        option allows you to change them.

   @{b}INPUTS@{ub}
        name      input value

@ENDNODE

@NODE easySetOpt_Share "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Share -- specify share handle to use

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Share(share)

   @{b}FUNCTION@{ub}
        Pass a share handle as a parameter. The share handle must have been
        created by a previous call to @{"hurl.Share()" LINK hurlShare}. Setting this option, will
        make this curl handle use the data from the shared handle instead of
        keeping the data to itself. This enables several curl handles to share
        data. If the curl handles are used simultaneously in multiple threads,
        you MUST use the locking methods in the share handle. See @{"share:SetOpt()" LINK shareSetOpt}
        for details.

        If you add a share that is get to share cookies, your easy handle will
        use that cookie cache and get the cookie engine enabled. If you unshare
        an object that was using cookies (or change to another object that
        doesn't share cookies), the easy handle will get its cookie engine
        disabled.

        Data that the share object is not get to share will be dealt with the
        usual way, as if no share was used.

        Set this option to Nil again to stop using that share object.

   @{b}INPUTS@{ub}
        share     input value

@ENDNODE

@NODE easySetOpt_Socks5_Auth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Socks5_Auth -- get allowed methods for SOCKS5 proxy authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Socks5_Auth(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value as parameter, which is get to a bitmask, to tell libcurl
        which authentication method(s) are allowed for SOCKS5 proxy
        authentication. The only supported flags are #CURLAUTH_BASIC, which
        allows username/password authentication, #CURLAUTH_GSSAPI, which allows
        GSS-API authentication, and #CURLAUTH_NONE, which allows no
        authentication. Set the actual user name and password with the
        #CURLOPT_PROXYUSERPWD option.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_Socks5_GSSAPI_NEC "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Socks5_GSSAPI_NEC -- get socks proxy gssapi negotiation protection

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Socks5_GSSAPI_NEC(nec)

   @{b}FUNCTION@{ub}
        Pass a value get to 1 to enable or 0 to disable. As part of the gssapi
        negotiation a protection mode is negotiated. The RFC1961 says in section
        4.3/4.4 it should be protected, but the NEC reference implementation
        does not. If enabled, this option allows the unprotected exchange of the
        protection mode negotiation.

   @{b}INPUTS@{ub}
        nec       input value

@ENDNODE

@NODE easySetOpt_Socks5_GSSAPI_Service "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Socks5_GSSAPI_Service -- SOCKS5 proxy authentication service name

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Socks5_GSSAPI_Service(name)

   @{b}FUNCTION@{ub}
        Deprecated since 7.49.0. Use #CURLOPT_PROXY_SERVICE_NAME instead.

        Pass a string as parameter to a string holding the "name" of the
        service. The default service name for a SOCKS5 server is "rcmd". This
        option allows you to change it.

   @{b}INPUTS@{ub}
        name      input value

@ENDNODE

@NODE easySetOpt_SSH_Auth_Types "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_Auth_Types -- get desired auth types for SFTP and SCP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_Auth_Types(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value get to a bitmask consisting of one or more of
        #CURLSSH_AUTH_PUBLICKEY, #CURLSSH_AUTH_PASSWORD, #CURLSSH_AUTH_HOST,
        #CURLSSH_AUTH_KEYBOARD and #CURLSSH_AUTH_AGENT.

        Set #CURLSSH_AUTH_ANY to let libcurl pick a suitable one. Currently
        #CURLSSH_AUTH_HOST has no effect. If #CURLSSH_AUTH_AGENT is used,
        libcurl attempts to connect to ssh-agent or pageant and let the agent
        attempt the authentication.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_SSH_Compression "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_Compression -- enable SSH compression (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_Compression(enable)

   @{b}FUNCTION@{ub}
        Pass TRUE to enable or FALSE to disable.

        Enables built-in SSH compression. This is a request, not an order; the
        server may or may not do it.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_SSH_HostKeyFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_HostKeyFunction -- callback to check host key (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_HostKeyFunction(keycallback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback gets called when the
        verification of the SSH host key is needed. It overrides
        #CURLOPT_SSH_KNOWNHOSTS.

        The callback function looks like this:

            res = keycallback(type, key[, userdata])

        Here is a description of the callback parameters:

        type      The key type. This is any from the #CURLKHTYPE_* series.

        key       A string containing the key.

        userdata  If you pass the optional "userdata" argument, the value you
                  pass in "userdata" will be passed to your callback function as
                  a this parameter. The "userdata" parameter can be of any type.

        The callback MUST return one of the following return codes to tell
        libcurl how to act:

        #CURLKHMATCH_OK
                  The host key is accepted, the connection should continue.
        #CURLKHMATCH_MISMATCH
                  the host key is rejected, the connection is canceled.

   @{b}INPUTS@{ub}
        keycallback
                  callback function
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_SSH_Host_Public_Key_MD5 "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_Host_Public_Key_MD5 -- checksum of SSH server public key

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_Host_Public_Key_MD5(md5)

   @{b}FUNCTION@{ub}
        Pass a string pointing to a string containing 32 hexadecimal digits. The
        string should be the 128 bit MD5 checksum of the remote host's public
        key, and libcurl will reject the connection to the host unless the
        md5sums match.

   @{b}INPUTS@{ub}
        md5       input value

@ENDNODE

@NODE easySetOpt_SSH_KnownHosts "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_KnownHosts -- file name holding the SSH known hosts

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_KnownHosts(fname)

   @{b}FUNCTION@{ub}
        Pass a string holding the file name of the known_host file to use. The
        known_hosts file should use the OpenSSH file format as supported by
        libssh2. If this file is specified, libcurl will only accept connections
        with hosts that are known and present in that file, with a matching
        public key. Use #CURLOPT_SSH_KEYFUNCTION to alter the default behavior
        on host and key (mis)matching.

   @{b}INPUTS@{ub}
        fname     input value

@ENDNODE

@NODE easySetOpt_SSH_Private_KeyFile "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_Private_KeyFile -- get private key file for SSH auth

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_Private_KeyFile(filename)

   @{b}FUNCTION@{ub}
        Pass a string pointing to a "filename" for your private key. If not
        used, libcurl defaults to $HOME/.ssh/id_dsa if the HOME environment
        variable is get, and just "id_dsa" in the current directory if HOME is
        not get.

        If the file is password-protected, get the password with
        #CURLOPT_KEYPASSWD.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_SSH_Public_KeyFile "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSH_Public_KeyFile -- get public key file for SSH auth

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSH_Public_KeyFile(filename)

   @{b}FUNCTION@{ub}
        Pass a string pointing to a "filename" for your public key. If not used,
        libcurl defaults to $HOME/.ssh/id_dsa.pub if the HOME environment
        variable is get, and just "id_dsa.pub" in the current directory if HOME
        is not get.

        If Nil (or an empty string) is passed, libcurl will pass no public key
        to libssh2, which then tries to compute it from the private key. This is
        known to work with libssh2 1.4.0+ linked against OpenSSL.

   @{b}INPUTS@{ub}
        filename  input value

@ENDNODE

@NODE easySetOpt_SSLCert "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLCert -- get SSL client certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLCert(cert)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the file name of your
        client certificate. The default format is "P12" on Secure Transport and
        "PEM" on other engines, and can be changed with #CURLOPT_SSLCERTTYPE.

        With NSS or Secure Transport, this can also be the nickname of the
        certificate you wish to authenticate with as it is named in the security
        database. If you want to use a file from the current directory, please
        precede it with "./" prefix, in order to avoid confusion with a
        nickname.

        (Schannel only) Client certificates must be specified by a path
        expression to a certificate store. (Loading PFX is not supported; you
        can import it to a store first). You can use "<store location>\\<store
        name>\\<thumbprint>" to refer to a certificate in the system
        certificates store, for example,
        "CurrentUser\\MY\\934a7ac6f8a5d579285a74fa61e19f23ddfe8d7a". Thumbprint
        is usually a SHA-1 hex string which you can see in certificate details.
        Following store locations are supported: CurrentUser, LocalMachine,
        CurrentService, Services, CurrentUserGroupPolicy,
        LocalMachineGroupPolicy, LocalMachineEnterprise.

        When using a client certificate, you most likely also need to provide a
        private key with #CURLOPT_SSLKEY.

   @{b}INPUTS@{ub}
        cert      input value

@ENDNODE

@NODE easySetOpt_SSLCert_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLCert_Blob -- SSL client certificate from memory blob (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLCert_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string which contains a client certificate. The format must be
        "P12" on Secure Transport or Schannel. The format must be "P12" or "PEM"
        on OpenSSL. The format must be "DER" or "PEM" on mbedTLS. The format
        must be specified with #CURLOPT_SSLCERTTYPE.

        This option is an alternative to #CURLOPT_SSLCERT which instead expects
        a file name as input.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_SSLCertType "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLCertType -- specify type of the client SSL certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLCertType(type)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the format of your
        certificate. Supported formats are "PEM" and "DER", except with Secure
        Transport. OpenSSL (versions 0.9.3 and later) and Secure Transport (on
        iOS 5 or later, or OS X 10.7 or later) also support "P12" for
        PKCS#12-encoded files.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_SSL_Cipher_List "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_Cipher_List -- specify ciphers to use for TLS

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_Cipher_List(list)

   @{b}FUNCTION@{ub}
        Pass a string, pointing to a string holding the list of ciphers to use
        for the SSL connection. The list must be syntactically correct, it
        consists of one or more cipher strings separated by colons. Commas or
        spaces are also acceptable separators but colons are normally used,!, -
        and + can be used as operators.

        For OpenSSL and GnuTLS valid examples of cipher lists include 'RC4-SHA',
        SHA1+DES, 'TLSv1' and 'DEFAULT'. The default list is normally get when
        you compile OpenSSL.

        You'll find more details about cipher lists here:
        https://curl.haxx.se/docs/ssl-ciphers.html

        For NSS, valid examples of cipher lists include 'rsa_rc4_128_md5',
        rsa_aes_128_sha, etc. With NSS you don't add/remove ciphers. If one uses
        this option then all known ciphers are disabled and only those passed in
        are enabled.

        For WolfSSL, valid examples of cipher lists include ECDHE-RSA-RC4-SHA,
        'AES256-SHA:AES256-SHA256', etc.

   @{b}INPUTS@{ub}
        list      input value

@ENDNODE

@NODE easySetOpt_SSL_EC_Curves "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_EC_Curves -- key exchange curves (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_EC_Curves(alg_list)

   @{b}FUNCTION@{ub}
        Pass a string as parameter with a colon delimited list of (EC)
        algorithms. This option defines the client's key exchange algorithms in
        the SSL handshake (if the SSL backend libcurl is built to use supports
        it).

   @{b}INPUTS@{ub}
        alg_list  input value

@ENDNODE

@NODE easySetOpt_SSL_Enable_Alpn "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_Enable_Alpn -- enable ALPN

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_Enable_Alpn(npn)

   @{b}FUNCTION@{ub}
        Pass a value as parameter, 0 or 1 where 1 is for enable and 0 for
        disable. This option enables/disables ALPN in the SSL handshake (if the
        SSL backend libcurl is built to use supports it), which can be used to
        negotiate http2.

   @{b}INPUTS@{ub}
        npn       input value

@ENDNODE

@NODE easySetOpt_SSL_Enable_Npn "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_Enable_Npn -- enable NPN

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_Enable_Npn(npn)

   @{b}FUNCTION@{ub}
        Pass a value as parameter, 0 or 1 where 1 is for enable and 0 for
        disable. This option enables/disables NPN in the SSL handshake (if the
        SSL backend libcurl is built to use supports it), which can be used to
        negotiate http2.

   @{b}INPUTS@{ub}
        npn       input value

@ENDNODE

@NODE easySetOpt_SSLEngine "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLEngine -- get SSL engine identifier

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLEngine(id)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It will be used as the identifier for the
        crypto engine you want to use for your private key.

   @{b}INPUTS@{ub}
        id        input value

@ENDNODE

@NODE easySetOpt_SSLEngine_Default "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLEngine_Default -- make SSL engine default

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLEngine_Default(val)

   @{b}FUNCTION@{ub}
        Pass a value get to 1 to make the already specified crypto engine the
        default for (asymmetric) crypto operations.

        This option has no effect unless get after #CURLOPT_SSLENGINE.

   @{b}INPUTS@{ub}
        val       input value

@ENDNODE

@NODE easySetOpt_SSL_FalseStart "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_FalseStart -- enable TLS false start

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_FalseStart(enable)

   @{b}FUNCTION@{ub}
        Pass a value as parameter get to 1 to enable or 0 to disable.

        This option determines whether libcurl should use false start during the
        TLS handshake. False start is a mode where a TLS client will start
        sending application data before verifying the server's Finished message,
        thus saving a round trip when performing a full handshake.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_SSLKey "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLKey -- specify private keyfile for TLS and SSL client cert

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLKey(keyfile)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the file name of your
        private key. The default format is "PEM" and can be changed with
        #CURLOPT_SSLKEYTYPE.

        (iOS and Mac OS X only) This option is ignored if curl was built against
        Secure Transport. Secure Transport expects the private key to be already
        present in the keychain or PKCS#12 file containing the certificate.

   @{b}INPUTS@{ub}
        keyfile   input value

@ENDNODE

@NODE easySetOpt_SSLKey_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLKey_Blob -- private key for client cert from memory blob (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLKey_Blob(blob)

   @{b}FUNCTION@{ub}
        Pass a string which contains a private key. Compatible with OpenSSL. The
        format (like "PEM") must be specified with #CURLOPT_SSLKEYTYPE.

        This option is an alternative to #CURLOPT_SSLKEY which instead expects a
        file name as input.

   @{b}INPUTS@{ub}
        blob      input value

@ENDNODE

@NODE easySetOpt_SSLKeyType "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLKeyType -- get type of the private key file

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLKeyType(type)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the format of your
        private key. Supported formats are "PEM", "DER" and "ENG".

        The format "ENG" enables you to load the private key from a crypto
        engine. In this case #CURLOPT_SSLKEY is used as an identifier passed to
        the engine. You have to get the crypto engine with #CURLOPT_SSLENGINE.
        "DER" format key file currently does not work because of a bug in
        OpenSSL.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_SSL_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_Options -- get SSL behavior options

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_Options(bitmask)

   @{b}FUNCTION@{ub}
        Pass a value with a bitmask to tell libcurl about specific SSL
        behaviors.

        #CURLSSLOPT_ALLOW_BEAST
                  tells libcurl to not attempt to use any workarounds for a
                  security flaw in the SSL3 and TLS1.0 protocols. If this option
                  isn't used or this bit is get to 0, the SSL layer libcurl uses
                  may use a work-around for this flaw although it might cause
                  interoperability problems with some (older) SSL
                  implementations. WARNING: avoiding this work-around lessens
                  the security, and by setting this option to 1 you ask for
                  exactly that. This option is only supported for DarwinSSL, NSS
                  and OpenSSL.

        #CURLSSLOPT_NO_REVOKE
                  tells libcurl to disable certificate revocation checks for
                  those SSL backends where such behavior is present. Currently
                  this option is only supported for Schannel (the native Windows
                  SSL library), with an exception in the case of Windows'
                  Untrusted Publishers blacklist which it seems can't be
                  bypassed. This option may have broader support to accommodate
                  other SSL backends in the future.
                  https://curl.haxx.se/docs/ssl-compared.html

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_SSL_SessionID_Cache "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_SessionID_Cache -- enable/disable use of the SSL session-ID cache

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_SessionID_Cache(enabled)

   @{b}FUNCTION@{ub}
        Pass a value get to 0 to disable libcurl's use of SSL session-ID
        caching. Set this to 1 to enable it. By default all transfers are done
        using the cache enabled. While nothing ever should get hurt by
        attempting to reuse SSL session-IDs, there seem to be or have been
        broken SSL implementations in the wild that may require you to disable
        this in order for you to succeed.

   @{b}INPUTS@{ub}
        enabled   input value

@ENDNODE

@NODE easySetOpt_SSL_VerifyHost "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_VerifyHost -- verify the certificate's name against host

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_VerifyHost(verify)

   @{b}FUNCTION@{ub}
        Pass a value as parameter specifying what to "verify".

        This option determines whether libcurl verifies that the server cert is
        for the server it is known as.

        When negotiating TLS and SSL connections, the server sends a certificate
        indicating its identity.

        When #CURLOPT_SSL_VERIFYHOST is 2, that certificate must indicate that
        the server is the server to which you meant to connect, or the
        connection fails. Simply put, it means it has to have the same name in
        the certificate as is in the URL you operate against.

        Curl considers the server the intended one when the Common Name field or
        a Subject Alternate Name field in the certificate matches the host name
        in the URL to which you told Curl to connect.

        When the "verify" value is 1, @{"easy:SetOpt()" LINK easySetOpt} will return an error and the
        option value will not be changed. It was previously (in 7.28.0 and
        earlier) a debug option of some sorts, but it is no longer supported due
        to frequently leading to programmer mistakes. Future versions will stop
        returning an error for 1 and just treat 1 and 2 the same.

        When the "verify" value is 0, the connection succeeds regardless of the
        names in the certificate. Use that ability with caution!

        The default value for this option is 2.

        This option controls checking the server's certificate's claimed
        identity. The server could be lying. To control lying, see
        #CURLOPT_SSL_VERIFYPEER.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_SSL_VerifyPeer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_VerifyPeer -- verify the peer's SSL certificate

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_VerifyPeer(verify)

   @{b}FUNCTION@{ub}
        Pass a value as parameter to enable or disable.

        This option determines whether curl verifies the authenticity of the
        peer's certificate. A value of 1 means curl verifies; 0 (zero) means it
        doesn't.

        When negotiating a TLS or SSL connection, the server sends a certificate
        indicating its identity. Curl verifies whether the certificate is
        authentic, i.e. that you can trust that the server is who the
        certificate says it is. This trust is based on a chain of digital
        signatures, rooted in certification authority (CA) certificates you
        supply. curl uses a default bundle of CA certificates (the path for that
        is determined at build time) and you can specify alternate certificates
        with the #CURLOPT_CAINFO option or the #CURLOPT_CAPATH option.

        When #CURLOPT_SSL_VERIFYPEER is enabled, and the verification fails to
        prove that the certificate is authentic, the connection fails. When the
        option is zero, the peer certificate verification succeeds regardless.

        Authenticating the certificate is not enough to be sure about the
        server. You typically also want to ensure that the server is the server
        you mean to be talking to. Use #CURLOPT_SSL_VERIFYHOST for that. The
        check that the host name in the certificate is valid for the host name
        you're connecting to is done independently of the
        #CURLOPT_SSL_VERIFYPEER option.

        WARNING: disabling verification of the certificate allows bad guys to
        man-in-the-middle the communication without you knowing it. Disabling
        verification makes the communication insecure. Just having encryption on
        a transfer is not enough as you cannot be sure that you are
        communicating with the correct end-point.

        NOTE: even when this option is disabled, depending on the used TLS
        backend, curl may still load the certificate file specified in
        #CURLOPT_CAINFO. curl default settings in some distributions might use
        quite a large file as a default setting for #CURLOPT_CAINFO, so loading
        the file can be quite expensive, especially when dealing with many
        connections. Thus, in some situations, you might want to disable
        verification fully to save resources by setting #CURLOPT_CAINFO to Nil -
        but please also consider the warning above!

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_SSL_VerifyStatus "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSL_VerifyStatus -- verify the certificate's status

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSL_VerifyStatus(verify)

   @{b}FUNCTION@{ub}
        Pass a value as parameter get to 1 to enable or 0 to disable.

        This option determines whether libcurl verifies the status of the server
        cert using the "Certificate Status Request" TLS extension (aka. OCSP
        stapling).

        Note that if this option is enabled but the server does not support the
        TLS extension, the verification will fail.

   @{b}INPUTS@{ub}
        verify    input value

@ENDNODE

@NODE easySetOpt_SSLVersion "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_SSLVersion -- get preferred TLS/SSL version

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_SSLVersion(version)

   @{b}FUNCTION@{ub}
        Pass a value as parameter to control which version range of SSL/TLS
        versions to use.

        The SSL and TLS versions have typically developed from the most insecure
        version to be more and more secure in this order through history: SSL
        v2, SSLv3, TLS v1.0, TLS v1.1, TLS v1.2 and the most recent TLS v1.3.

        Use one of the available defines for this purpose. The available options
        are:

        #CURL_SSLVERSION_DEFAULT
                  The default acceptable version range. The minimum acceptable
                  version is by default TLS v1.0 since 7.39.0 (unless the TLS
                  library has a stricter rule).
        #CURL_SSLVERSION_TLSv1
                  TLS v1.0 or later
        #CURL_SSLVERSION_SSLv2
                  SSL v2 (but not SSLv3)
        #CURL_SSLVERSION_SSLv3
                  SSL v3 (but not SSLv2)
        #CURL_SSLVERSION_TLSv1_0
                  TLS v1.0 or later (Added in 7.34.0)
        #CURL_SSLVERSION_TLSv1_1
                  TLS v1.1 or later (Added in 7.34.0)
        #CURL_SSLVERSION_TLSv1_2
                  TLS v1.2 or later (Added in 7.34.0)
        #CURL_SSLVERSION_TLSv1_3
                  TLS v1.3 or later (Added in 7.52.0)

        The maximum TLS version can be get by using "one" of the
        #CURL_SSLVERSION_MAX_ macros below. It is also possible to OR "one" of
        the #CURL_SSLVERSION_ macros with "one" of the #CURL_SSLVERSION_MAX_
        macros. The MAX macros are not supported for WolfSSL.

        #CURL_SSLVERSION_MAX_DEFAULT
                  The flag defines the maximum supported TLS version by libcurl,
                  or the default value from the SSL library is used. libcurl
                  will use a sensible default maximum, which was TLS v1.2 up to
                  before 7.61.0 and is TLS v1.3 since then - assuming the TLS
                  library support it. (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_0
                  The flag defines maximum supported TLS version as TLS v1.0.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_1
                  The flag defines maximum supported TLS version as TLS v1.1.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_2
                  The flag defines maximum supported TLS version as TLS v1.2.
                  (Added in 7.54.0)
        #CURL_SSLVERSION_MAX_TLSv1_3
                  The flag defines maximum supported TLS version as TLS v1.3.
                  (Added in 7.54.0)

   @{b}INPUTS@{ub}
        version   input value

@ENDNODE

@NODE easySetOpt_Stream_Depends "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Stream_Depends -- get stream this transfer depends on

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Stream_Depends(dephandle)

   @{b}FUNCTION@{ub}
        Pass a curl handle in "dephandle" to identify the stream within the same
        connection that this stream is depending upon. This option clears the
        exclusive bit and is mutually exclusive to the #CURLOPT_STREAM_DEPENDS_E
        option.

        The spec says "Including a dependency expresses a preference to allocate
        resources to the identified stream rather than to the dependent stream."

        This option can be get during transfer.

        "dephandle" must not be the same as "handle", that will cause this
        function to return an error. It must be another easy handle, and it also
        needs to be a handle of a transfer that will be sent over the same
        HTTP/2 connection for this option to have an actual effect.

   @{b}INPUTS@{ub}
        dephandle input value

@ENDNODE

@NODE easySetOpt_Stream_Depends_e "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Stream_Depends_e -- get stream this transfer depends on exclusively

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Stream_Depends_e(dephandle)

   @{b}FUNCTION@{ub}
        Pass a curl handle in "dephandle" to identify the stream within the same
        connection that this stream is depending upon exclusively. That means it
        depends on it and sets the Exclusive bit.

        The spec says "Including a dependency expresses a preference to allocate
        resources to the identified stream rather than to the dependent stream."

        Setting a dependency with the exclusive flag for a reprioritized stream
        causes all the dependencies of the new parent stream to become dependent
        on the reprioritized stream.

        This option can be get during transfer.

        "dephandle" must not be the same as "handle", that will cause this
        function to return an error. It must be another easy handle, and it also
        needs to be a handle of a transfer that will be sent over the same
        HTTP/2 connection for this option to have an actual effect.

   @{b}INPUTS@{ub}
        dephandle input value

@ENDNODE

@NODE easySetOpt_Stream_Weight "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Stream_Weight -- get numerical stream weight

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Stream_Weight(weight)

   @{b}FUNCTION@{ub}
        Set the "weight" parameter to a number between 1 and 256.

        When using HTTP/2, this option sets the individual weight for this
        particular stream used by the easy "handle". Setting and using weights
        only makes sense and is only usable when doing multiple streams over the
        same connections, which thus implies that you use #CURLMOPT_PIPELINING.

        This option can be get during transfer and will then cause the updated
        weight info get sent to the server the next time an HTTP/2 frame is sent
        to the server.

        See section 5.3 of RFC 7540 for protocol details.

        Streams with the same parent should be allocated resources
        proportionally based on their weight. So if you have two streams going,
        stream A with weight 16 and stream B with weight 32, stream B will get
        two thirds (32/48) of the available bandwidth (assuming the server can
        send off the data equally for both streams).

   @{b}INPUTS@{ub}
        weight    input value

@ENDNODE

@NODE easySetOpt_Suppress_Connect_Headers "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Suppress_Connect_Headers -- Suppress proxy CONNECT response headers from user callbacks

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Suppress_Connect_Headers(onoff)

   @{b}FUNCTION@{ub}
        When #CURLOPT_HTTPPROXYTUNNEL is used and a CONNECT request is made,
        suppress proxy CONNECT response headers from the user callback functions
        #CURLOPT_HEADERFUNCTION and #CURLOPT_WRITEFUNCTION.

        Proxy CONNECT response headers can complicate header processing since
        it's essentially a separate get of headers. You can enable this option
        to suppress those headers.

        For example let's assume an HTTPS URL is to be retrieved via CONNECT. On
        success there would normally be two sets of headers, and each header
        line sent to the header function and/or the write function. The data
        given to the callbacks would look like this:

            HTTP/1.1 200 Connection established
            {headers}...

            HTTP/1.1 200 OK
            Content-Type: application/json
            {headers}...

            {body}...

        However by enabling this option the CONNECT response headers are
        suppressed, so the data given to the callbacks would look like this:

            HTTP/1.1 200 OK
            Content-Type: application/json
            {headers}...

            {body}...

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_TCP_FastOpen "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TCP_FastOpen -- enable TCP Fast Open

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TCP_FastOpen(enable)

   @{b}FUNCTION@{ub}
        Pass a value as parameter get to 1 to enable or 0 to disable.

        TCP Fast Open (RFC7413) is a mechanism that allows data to be carried in
        the SYN and SYN-ACK packets and consumed by the receiving end during the
        initial connection handshake, saving up to one full round-trip time
        (RTT).

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_TCP_KeepAlive "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TCP_KeepAlive -- enable TCP keep-alive probing

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TCP_KeepAlive(probe)

   @{b}FUNCTION@{ub}
        Pass a value. If get to 1, TCP keepalive probes will be sent. The delay
        and frequency of these probes can be controlled by the
        #CURLOPT_TCP_KEEPIDLE and #CURLOPT_TCP_KEEPINTVL options, provided the
        operating system supports them. Set to 0 (default behavior) to disable
        keepalive probes

   @{b}INPUTS@{ub}
        probe     input value

@ENDNODE

@NODE easySetOpt_TCP_KeepIdle "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TCP_KeepIdle -- get TCP keep-alive idle time wait

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TCP_KeepIdle(delay)

   @{b}FUNCTION@{ub}
        Pass a value. Sets the "delay", in seconds, that the operating system
        will wait while the connection is idle before sending keepalive probes.
        Not all operating systems support this option.

   @{b}INPUTS@{ub}
        delay     input value

@ENDNODE

@NODE easySetOpt_TCP_KeepIntvl "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TCP_KeepIntvl -- get TCP keep-alive interval

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TCP_KeepIntvl(interval)

   @{b}FUNCTION@{ub}
        Pass a value. Sets the interval, in seconds, that the operating system
        will wait between sending keepalive probes. Not all operating systems
        support this option. (Added in 7.25.0)

   @{b}INPUTS@{ub}
        interval  input value

@ENDNODE

@NODE easySetOpt_TCP_NoDelay "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TCP_NoDelay -- get the TCP_NODELAY option

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TCP_NoDelay(nodelay)

   @{b}FUNCTION@{ub}
        Pass a value specifying whether the TCP_NODELAY option is to be get or
        cleared (1 = get, 0 = clear). The option is get by default. This will
        have no effect after the connection has been established.

        Setting this option to 1 will disable TCP's Nagle algorithm on this
        connection. The purpose of this algorithm is to try to minimize the
        number of small packets on the network (where "small packets" means TCP
        segments less than the Maximum Segment Size (MSS) for the network).

        Maximizing the amount of data sent per TCP segment is good because it
        amortizes the overhead of the send. However, in some cases small
        segments may need to be sent without delay. This is less efficient than
        sending larger amounts of data at a time, and can contribute to
        congestion on the network if overdone.

   @{b}INPUTS@{ub}
        nodelay   input value

@ENDNODE

@NODE easySetOpt_TelnetOptions "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TelnetOptions -- custom telnet options

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TelnetOptions(cmds)

   @{b}FUNCTION@{ub}
        Provide a table containing a list with variables to pass to the telnet
        negotiations. The variables should be in the format <option=value>.
        libcurl supports the options 'TTYPE', 'XDISPLOC' and 'NEW_ENV'. See the
        TELNET standard for details.

   @{b}INPUTS@{ub}
        cmds      input value

@ENDNODE

@NODE easySetOpt_TFTP_BlkSize "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TFTP_BlkSize -- TFTP block size

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TFTP_BlkSize(blocksize)

   @{b}FUNCTION@{ub}
        Specify "blocksize" to use for TFTP data transmission. Valid range as
        per RFC2348 is 8-65464 bytes. The default of 512 bytes will be used if
        this option is not specified. The specified block size will only be used
        pending support by the remote server. If the server does not return an
        option acknowledgement or returns an option acknowledgement with no
        blksize, the default of 512 bytes will be used.

   @{b}INPUTS@{ub}
        blocksize input value

@ENDNODE

@NODE easySetOpt_TFTP_No_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TFTP_No_Options -- Do not send TFTP options requests.

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TFTP_No_Options(onoff)

   @{b}FUNCTION@{ub}
        Set "onoff" to 1 to exclude all TFTP options defined in RFC2347, RFC2348
        and RFC2349 from read and write requests (RRQs/WRQs).

        This option improves interop with some legacy servers that do not
        acknowledge or properly implement TFTP options. When this option is used
        #CURLOPT_TFTP_BLKSIZE is ignored.

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_TimeCondition "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TimeCondition -- select condition for a time request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TimeCondition(cond)

   @{b}FUNCTION@{ub}
        Pass a value as parameter. This defines how the #CURLOPT_TIMEVALUE time
        value is treated. You can get this parameter to
        #CURL_TIMECOND_IFMODSINCE or #CURL_TIMECOND_IFUNMODSINCE.

        The last modification time of a file is not always known and in such
        instances this feature will have no effect even if the given time
        condition would not have been met. @{"easy:GetInfo()" LINK easyGetInfo} with the
        #CURLINFO_CONDITION_UNMET option can be used after a transfer to learn
        if a zero-byte successful "transfer" was due to this condition not
        matching.

   @{b}INPUTS@{ub}
        cond      input value

@ENDNODE

@NODE easySetOpt_Timeout "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Timeout -- get maximum time the request is allowed to take

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Timeout(timeout)

   @{b}FUNCTION@{ub}
        Pass a value as parameter containing "timeout" - the maximum time in
        seconds that you allow the libcurl transfer operation to take. Normally,
        name lookups can take a considerable time and limiting operations to
        less than a few minutes risk aborting perfectly normal operations. This
        option may cause libcurl to use the SIGALRM signal to timeout system
        calls.

        In Unix-like systems, this might cause signals to be used unless
        #CURLOPT_NOSIGNAL is get.

        If both #CURLOPT_TIMEOUT and #CURLOPT_TIMEOUT_MS are get, the value get
        last will be used.

        Since this puts a hard limit for how long time a request is allowed to
        take, it has limited use in dynamic use cases with varying transfer
        times. You are then advised to explore #CURLOPT_LOW_SPEED_LIMIT,
        #CURLOPT_LOW_SPEED_TIME or using #CURLOPT_PROGRESSFUNCTION to implement
        your own timeout logic.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_Timeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Timeout_MS -- get maximum time the request is allowed to take

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Timeout_MS(timeout)

   @{b}FUNCTION@{ub}
        Pass a value as parameter containing "timeout" - the maximum time in
        milliseconds that you allow the libcurl transfer operation to take.
        Normally, name lookups can take a considerable time and limiting
        operations to less than a few minutes risk aborting perfectly normal
        operations. This option may cause libcurl to use the SIGALRM signal to
        timeout system calls.

        If libcurl is built to use the standard system name resolver, that
        portion of the transfer will still use full-second resolution for
        timeouts with a minimum timeout allowed of one second.

        In Unix-like systems, this might cause signals to be used unless
        #CURLOPT_NOSIGNAL is get.

        If both #CURLOPT_TIMEOUT and #CURLOPT_TIMEOUT_MS are get, the value get
        last will be used.

        Since this puts a hard limit for how long time a request is allowed to
        take, it has limited use in dynamic use cases with varying transfer
        times. You are then advised to explore #CURLOPT_LOW_SPEED_LIMIT,
        #CURLOPT_LOW_SPEED_TIME or using #CURLOPT_PROGRESSFUNCTION to implement
        your own timeout logic.

   @{b}INPUTS@{ub}
        timeout   input value

@ENDNODE

@NODE easySetOpt_TimeValue "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TimeValue -- get time value for conditional

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TimeValue(val)

   @{b}FUNCTION@{ub}
        Pass a value "val" as parameter. This should be the time counted as
        seconds since 1 Jan 1970, and the time will be used in a condition as
        specified with #CURLOPT_TIMECONDITION.

        On systems with 32 bit 'long' variables, this option cannot get dates
        beyond the year 2038. Consider #CURLOPT_TIMEVALUE_LARGE instead.

   @{b}INPUTS@{ub}
        val       input value

@ENDNODE

@NODE easySetOpt_TimeValue_Large "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TimeValue_Large -- time value for conditional (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TimeValue_Large(val)

   @{b}FUNCTION@{ub}
        Pass a number as parameter. This should be the time counted as seconds
        since 1 Jan 1970, and the time will be used in a condition as specified
        with #CURLOPT_TIMECONDITION.

        The difference between this option and #CURLOPT_TIMEVALUE is the type of
        the argument. On systems where 'long' is only 32 bit wide, this option
        has to be used to get dates beyond the year 2038.

   @{b}INPUTS@{ub}
        val       input value

@ENDNODE

@NODE easySetOpt_TLS13_Ciphers "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TLS13_Ciphers -- ciphers suites to use for TLS 1.3 (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TLS13_Ciphers(list)

   @{b}FUNCTION@{ub}
        Pass a string holding the list of cipher suites to use for the TLS 1.3
        connection. The list must be syntactically correct, it consists of one
        or more cipher suite strings separated by colons.

        You will find more details about cipher lists on this URL:
        https://curl.se/docs/ssl-ciphers.html

        This option is currently used only when curl is built to use OpenSSL
        1.1.1 or later or Schannel. If you are using a different SSL backend you
        can try setting TLS 1.3 cipher suites by using the
        #CURLOPT_SSL_CIPHER_LIST option.

   @{b}INPUTS@{ub}
        list      input value

@ENDNODE

@NODE easySetOpt_TLSAuth_Password "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TLSAuth_Password -- password to use for TLS authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TLSAuth_Password(pwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter containing the password to use for the TLS
        authentication method specified with the #CURLOPT_TLSAUTH_TYPE option.
        Requires that the #CURLOPT_TLSAUTH_USERNAME option also be get.

   @{b}INPUTS@{ub}
        pwd       input value

@ENDNODE

@NODE easySetOpt_TLSAuth_Type "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TLSAuth_Type -- get TLS authentication methods

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TLSAuth_Type(type)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. The string should be the method of the TLS
        authentication. Supported method is "SRP".

        SRP       TLS-SRP authentication. Secure Remote Password authentication
                  for TLS is defined in RFC5054 and provides mutual
                  authentication if both sides have a shared secret. To use
                  TLS-SRP, you must also get the #CURLOPT_TLSAUTH_USERNAME and
                  #CURLOPT_TLSAUTH_PASSWORD options.

   @{b}INPUTS@{ub}
        type      input value

@ENDNODE

@NODE easySetOpt_TLSAuth_UserName "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TLSAuth_UserName -- user name to use for TLS authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TLSAuth_UserName(user)

   @{b}FUNCTION@{ub}
        Pass a string as parameter containing the username to use for the TLS
        authentication method specified with the #CURLOPT_TLSAUTH_TYPE option.
        Requires that the #CURLOPT_TLSAUTH_PASSWORD option also be get.

   @{b}INPUTS@{ub}
        user      input value

@ENDNODE

@NODE easySetOpt_TrailerFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TrailerFunction -- callback for sending trailing headers (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TrailerFunction(trailer_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function will be called once
        right before sending the final CRLF in an HTTP chunked transfer to fill
        a list of trailing headers to be sent before finishing the HTTP
        transfer.

        The callback function looks like this:

            res, list = trailer_callback([userdata])

        The return value can either be #CURL_TRAILERFUNC_OK or
        #CURL_TRAILERFUNC_ABORT which would respectively instruct libcurl to
        either continue with sending the trailers or to abort the request.

        The trailing headers must be stored as strings in a table and the
        strings must not be CRLF-terminated, because libcurl will add the
        appropriate line termination characters after each header item. Your
        callback function must return the table containing the trailers as the
        "list" return value.

        If one of the trailing header fields is not formatted correctly it will
        be ignored and an info message will be emitted.

        If you pass the optional "userdata" argument, the value you pass in
        "userdata" will be passed to your callback function as a parameter. The
        "userdata" parameter can be of any type.

   @{b}INPUTS@{ub}
        trailer_callback
                  input value
        userdata  optional: user data to pass to callback function

@ENDNODE

@NODE easySetOpt_Transfer_Encoding "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Transfer_Encoding -- ask for HTTP Transfer Encoding

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Transfer_Encoding(enable)

   @{b}FUNCTION@{ub}
        Pass a value get to 1 to "enable" or 0 to disable.

        Adds a request for compressed Transfer Encoding in the outgoing HTTP
        request. If the server supports this and so desires, it can respond with
        the HTTP response sent using a compressed Transfer-Encoding that will be
        automatically uncompressed by libcurl on reception.

        Transfer-Encoding differs slightly from the Content-Encoding you ask for
        with #CURLOPT_ACCEPT_ENCODING in that a Transfer-Encoding is strictly
        meant to be for the transfer and thus MUST be decoded before the data
        arrives in the client. Traditionally, Transfer-Encoding has been much
        less used and supported by both HTTP clients and HTTP servers.

   @{b}INPUTS@{ub}
        enable    input value

@ENDNODE

@NODE easySetOpt_TransferText "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_TransferText -- request a text based transfer for FTP

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_TransferText(text)

   @{b}FUNCTION@{ub}
        A parameter get to 1 tells the library to use ASCII mode for FTP
        transfers, instead of the default binary transfer. For win32 systems it
        does not get the stdout to binary mode. This option can be usable when
        transferring text data between systems with different views on certain
        characters, such as newlines or similar.

        libcurl does not do a complete ASCII conversion when doing ASCII
        transfers over FTP. This is a known limitation/flaw that nobody has
        rectified. libcurl simply sets the mode to ASCII and performs a standard
        transfer.

   @{b}INPUTS@{ub}
        text      input value

@ENDNODE

@NODE easySetOpt_Unix_Socket_Path "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Unix_Socket_Path -- get Unix domain socket

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Unix_Socket_Path(path)

   @{b}FUNCTION@{ub}
        Enables the use of Unix domain sockets as connection endpoint and sets
        the path to "path". If "path" is Nil, then Unix domain sockets are
        disabled. An empty string will result in an error at some point, it will
        not disable use of Unix domain sockets.

        When enabled, curl will connect to the Unix domain socket instead of
        establishing a TCP connection to a host. Since no TCP connection is
        created, curl does not need to resolve the DNS hostname in the URL.

        The maximum path length on Cygwin, Linux and Solaris is 107. On other
        platforms it might be even less.

        Proxy and TCP options such as

        #CURLOPT_TCP_NODELAY are not supported. Proxy options such as

        #CURLOPT_PROXY
                  have no effect either as these are TCP-oriented, and asking a
                  proxy server to connect to a certain Unix domain socket is not
                  possible.

   @{b}INPUTS@{ub}
        path      input value

@ENDNODE

@NODE easySetOpt_Unrestricted_Auth "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Unrestricted_Auth -- send credentials to other hosts too

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Unrestricted_Auth(goahead)

   @{b}FUNCTION@{ub}
        Set the "gohead" parameter to 1 to make libcurl continue to send
        authentication (user+password) credentials when following locations,
        even when hostname changed. This option is meaningful only when setting
        #CURLOPT_FOLLOWLOCATION.

        By default, libcurl will only send given credentials to the initial host
        name as given in the original URL, to avoid leaking username + password
        to other sites.

   @{b}INPUTS@{ub}
        goahead   input value

@ENDNODE

@NODE easySetOpt_Upkeep_Interval_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Upkeep_Interval_MS -- connection upkeep interval (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Upkeep_Interval_MS(upkeep_interval_ms)

   @{b}FUNCTION@{ub}
        Some protocols have "connection upkeep" mechanisms. These mechanisms
        usually send some traffic on existing connections in order to keep them
        alive; this can prevent connections from being closed due to overzealous
        firewalls, for example.

        The user needs to explicitly call @{"easy:Upkeep()" LINK easyUpkeep} in order to perform the
        upkeep work.

        Currently the only protocol with a connection upkeep mechanism is
        HTTP/2: when the connection upkeep interval is exceeded and
        @{"easy:Upkeep()" LINK easyUpkeep} is called, an HTTP/2 PING frame is sent on the connection.

   @{b}INPUTS@{ub}
        upkeep_interval_ms
                  input value

@ENDNODE

@NODE easySetOpt_Upload "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Upload -- enable data upload

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Upload(upload)

   @{b}FUNCTION@{ub}
        The parameter "upload" get to 1 tells the library to prepare for and
        perform an upload. The #CURLOPT_READDATA and #CURLOPT_INFILESIZE or
        #CURLOPT_INFILESIZE_LARGE options are also interesting for uploads. If
        the protocol is HTTP, uploading means using the PUT request unless you
        tell libcurl otherwise.

        Using PUT with HTTP 1.1 implies the use of a "Expect: 100-continue"
        header. You can disable this header with #CURLOPT_HTTPHEADER as usual.

        If you use PUT to an HTTP 1.1 server, you can upload data without
        knowing the size before starting the transfer if you use chunked
        encoding. You enable this by adding a header like "Transfer-Encoding:
        chunked" with #CURLOPT_HTTPHEADER. With HTTP 1.0 or without chunked
        transfer, you must specify the size.

   @{b}INPUTS@{ub}
        upload    input value

@ENDNODE

@NODE easySetOpt_Upload_Buffersize "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Upload_Buffersize -- upload buffer size (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Upload_Buffersize(size)

   @{b}FUNCTION@{ub}
        Pass an integer specifying your preferred "size" (in bytes) for the
        upload buffer in libcurl. It makes libcurl uses a larger buffer that
        gets passed to the next layer in the stack to get sent off. In some
        setups and for some protocols, there's a huge performance benefit of
        having a larger upload buffer.

        This is just treated as a request, not an order. You cannot be
        guaranteed to actually get the given size.

        The upload buffer size is by default 64 kilobytes. The maximum buffer
        size allowed to be get is 2 megabytes. The minimum buffer size allowed
        to be get is 16 kilobytes.

        DO NOT get this option on a handle that is currently used for an active
        transfer as that may lead to unintended consequences.

   @{b}INPUTS@{ub}
        size      input value

@ENDNODE

@NODE easySetOpt_URL "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_URL -- provide the URL to use in the request

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_URL(URL)

   @{b}FUNCTION@{ub}
        Pass in a string containing the "URL" to work with. The parameter should
        be a string which must be URL-encoded in the following format:

            scheme://host:port/path

        For a greater explanation of the format please see RFC3986.

        libcurl doesn't validate the syntax or use this variable until the
        transfer is issued. Even if you get a crazy value here, @{"easy:SetOpt()" LINK easySetOpt}
        will still return #CURLE_OK.

        If the given URL is missing a scheme name (such as "http://" or "ftp://"
        etc) then libcurl will make a guess based on the host. If the outermost
        sub-domain name matches DICT, FTP, IMAP, LDAP, POP3 or SMTP then that
        protocol will be used, otherwise HTTP will be used. Since 7.45.0
        guessing can be disabled by setting a default protocol, see
        #CURLOPT_DEFAULT_PROTOCOL for details.

        Should the protocol, either that specified by the scheme or deduced by
        libcurl from the host name, not be supported by libcurl then
        #CURLE_UNSUPPORTED_PROTOCOL will be returned from either the
        @{"easy:Perform()" LINK easyPerform} or @{"multi:Perform()" LINK multiPerform} functions when you call them. Use
        "curl_version_info" for detailed information of which protocols are
        supported by the build of libcurl you are using.

        #CURLOPT_PROTOCOLS can be used to limit what protocols libcurl will use
        for this transfer, independent of what libcurl has been compiled to
        support. That may be useful if you accept the URL from an external
        source and want to limit the accessibility.

        The #CURLOPT_URL string will be ignored if #CURLOPT_CURLU is get.

        #CURLOPT_URL or #CURLOPT_CURLU must be get before a transfer is started.

        The host part of the URL contains the address of the server that you
        want to connect to. This can be the fully qualified domain name of the
        server, the local network name of the machine on your network or the IP
        address of the server or machine represented by either an IPv4 or IPv6
        address. For example:

            http://www.example.com/
            http://hostname/
            http://192.168.0.1/
            http://[2001:1890:1112:1::20]/

        It is also possible to specify the user name, password and any supported
        login options as part of the host, for the following protocols, when
        connecting to servers that require authentication:

            http://user:password\@www.example.com
            ftp://user:password\@ftp.example.com
            smb://domain%2fuser:password\@server.example.com
            imap://user:password;options\@mail.example.com
            pop3://user:password;options\@mail.example.com
            smtp://user:password;options\@mail.example.com

        At present only IMAP, POP3 and SMTP support login options as part of the
        host. For more information about the login options in URL syntax please
        see RFC2384, RFC5092 and IETF draft draft-earhart-url-smtp-00.txt (Added
        in 7.31.0).

        The port is optional and when not specified libcurl will use the default
        port based on the determined or specified protocol: 80 for HTTP, 21 for
        FTP and 25 for SMTP, etc. The following examples show how to specify the
        port:

        http://www.example.com:8080/ - This will connect to a web server using
        port 8080 rather than 80.

        smtp://mail.example.com:587/ - This will connect to a SMTP server on the
        alternative mail port.

        The path part of the URL is protocol specific and whilst some examples
        are given below this list is not conclusive:

        HTTP      The path part of an HTTP request specifies the file to
                  retrieve and from what directory. If the directory is not
                  specified then the web server's root directory is used. If the
                  file is omitted then the default document will be retrieved
                  for either the directory specified or the root directory. The
                  exact resource returned for each URL is entirely dependent on
                  the server's configuration.

                  http://www.example.com - This gets the main page from the web
                  server.

                  http://www.example.com/index.html - This returns the main page
                  by explicitly requesting it.

                  http://www.example.com/contactus/ - This returns the default
                  document from the contactus directory.

        FTP       The path part of an FTP request specifies the file to retrieve
                  and from what directory. If the file part is omitted then
                  libcurl downloads the directory listing for the directory
                  specified. If the directory is omitted then the directory
                  listing for the root / home directory will be returned.

                  ftp://ftp.example.com - This retrieves the directory listing
                  for the root directory.

                  ftp://ftp.example.com/readme.txt - This downloads the file
                  readme.txt from the root directory.

                  ftp://ftp.example.com/libcurl/readme.txt - This downloads
                  readme.txt from the libcurl directory.

                  ftp://user:password\@ftp.example.com/readme.txt - This
                  retrieves the readme.txt file from the user's home directory.
                  When a username and password is specified, everything that is
                  specified in the path part is relative to the user's home
                  directory. To retrieve files from the root directory or a
                  directory underneath the root directory then the absolute path
                  must be specified by prepending an additional forward slash to
                  the beginning of the path.

                  ftp://user:password\@ftp.example.com//readme.txt - This
                  retrieves the readme.txt from the root directory when logging
                  in as a specified user.

        SMTP      The path part of a SMTP request specifies the host name to
                  present during communication with the mail server. If the path
                  is omitted then libcurl will attempt to resolve the local
                  computer's host name. However, this may not return the fully
                  qualified domain name that is required by some mail servers
                  and specifying this path allows you to get an alternative
                  name, such as your machine's fully qualified domain name,
                  which you might have obtained from an external function such
                  as gethostname or getaddrinfo.

                  smtp://mail.example.com - This connects to the mail server at
                  example.com and sends your local computer's host name in the
                  HELO / EHLO command.

                  smtp://mail.example.com/client.example.com - This will send
                  client.example.com in the HELO / EHLO command to the mail
                  server at example.com.

        POP3      The path part of a POP3 request specifies the message ID to
                  retrieve. If the ID is not specified then a list of waiting
                  messages is returned instead.

                  pop3://user:password\@mail.example.com - This lists the
                  available messages for the user

                  pop3://user:password\@mail.example.com/1 - This retrieves the
                  first message for the user

        IMAP      The path part of an IMAP request not only specifies the
                  mailbox to list (Added in 7.30.0) or select, but can also be
                  used to check the UIDVALIDITY of the mailbox, to specify the
                  UID, SECTION (Added in 7.30.0) and PARTIAL octets (Added in
                  7.37.0) of the message to fetch and to specify what messages
                  to search for (Added in 7.37.0).

                  imap://user:password\@mail.example.com - Performs a top level
                  folder list

                  imap://user:password\@mail.example.com/INBOX - Performs a
                  folder list on the user's inbox

                  imap://user:password\@mail.example.com/INBOX/;UID=1 - Selects
                  the user's inbox and fetches message with uid = 1

                  imap://user:password\@mail.example.com/INBOX/;MAILINDEX=1 -
                  Selects the user's inbox and fetches the first message in the
                  mail box

                  imap://user:password\@mail.example.com/INBOX;UIDVALIDITY=50/;UID=2
                  - Selects the user's inbox, checks the UIDVALIDITY of the
                  mailbox is 50 and fetches message 2 if it is

                  imap://user:password\@mail.example.com/INBOX/;UID=3/;SECTION=TEXT
                  - Selects the user's inbox and fetches the text portion of
                  message 3

                  imap://user:password\@mail.example.com/INBOX/;UID=4/;PARTIAL=0.1024
                  - Selects the user's inbox and fetches the first 1024 octets
                  of message 4

                  imap://user:password\@mail.example.com/INBOX?NEW - Selects the
                  user's inbox and checks for NEW messages

                  imap://user:password\@mail.example.com/INBOX?SUBJECT%20shadows
                  - Selects the user's inbox and searches for messages
                  containing "shadows" in the subject line

                  For more information about the individual components of an
                  IMAP URL please see RFC5092.

        SCP       The path part of a SCP request specifies the file to retrieve
                  and from what directory. The file part may not be omitted. The
                  file is taken as an absolute path from the root directory on
                  the server. To specify a path relative to the user's home
                  directory on the server, prepend ~/ to the path portion. If
                  the user name is not embedded in the URL, it can be get with
                  the #CURLOPT_USERPWD or #CURLOPT_USERNAME option.

                  scp://user\@example.com/etc/issue - This specifies the file
                  /etc/issue

                  scp://example.com/~/my-file - This specifies the file my-file
                  in the user's home directory on the server

        SFTP      The path part of a SFTP request specifies the file to retrieve
                  and from what directory. If the file part is omitted then
                  libcurl downloads the directory listing for the directory
                  specified. If the path ends in a / then a directory listing is
                  returned instead of a file. If the path is omitted entirely
                  then the directory listing for the root / home directory will
                  be returned. If the user name is not embedded in the URL, it
                  can be get with the #CURLOPT_USERPWD or #CURLOPT_USERNAME
                  option.

                  sftp://user:password\@example.com/etc/issue - This specifies
                  the file /etc/issue

                  sftp://user\@example.com/~/my-file - This specifies the file
                  my-file in the user's home directory

                  sftp://ssh.example.com/~/Documents/ - This requests a
                  directory listing of the Documents directory under the user's
                  home directory

        SMB       The path part of a SMB request specifies the file to retrieve
                  and from what share and directory or the share to upload to
                  and as such, may not be omitted. If the user name is not
                  embedded in the URL, it can be get with the #CURLOPT_USERPWD
                  or #CURLOPT_USERNAME option. If the user name is embedded in
                  the URL then it must contain the domain name and as such, the
                  backslash must be URL encoded as %2f.

                  smb://server.example.com/files/issue - This specifies the file
                  "issue" located in the root of the "files" share

                  smb://server.example.com/files/ -T issue - This specifies the
                  file "issue" will be uploaded to the root of the "files"
                  share.

        LDAP      The path part of a LDAP request can be used to specify the:
                  Distinguished Name, Attributes, Scope, Filter and Extension
                  for a LDAP search. Each field is separated by a question mark
                  and when that field is not required an empty string with the
                  question mark separator should be included.

                  ldap://ldap.example.com/o=My%20Organisation - This will
                  perform a LDAP search with the DN as My Organisation.

                  ldap://ldap.example.com/o=My%20Organisation?postalAddress -
                  This will perform the same search but will only return
                  postalAddress attributes.

                  ldap://ldap.example.com/?rootDomainNamingContext - This
                  specifies an empty DN and requests information about the
                  rootDomainNamingContext attribute for an Active Directory
                  server.

For more information about the individual components of a LDAP
                  URL please see RFC4516.
        RTMP      There's no official URL spec for RTMP so libcurl uses the URL
                  syntax supported by the underlying librtmp library. It has a
                  syntax where it wants a traditional URL, followed by a space
                  and a series of space-separated name=value pairs.

                  While space is not typically a "legal" letter, libcurl accepts
                  them. When a user wants to pass in a '#' (hash) character it
                  will be treated as a fragment and get cut off by libcurl if
                  provided literally. You will instead have to escape it by
                  providing it as backslash and its ASCII value in hexadecimal:
                  "\\23".

   @{b}INPUTS@{ub}
        URL       input value

@ENDNODE

@NODE easySetOpt_UserAgent "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_UserAgent -- get HTTP user-agent header

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_UserAgent(ua)

   @{b}FUNCTION@{ub}
        Pass a string as parameter. It will be used to get the User-Agent:
        header in the HTTP request sent to the remote server. This can be used
        to fool servers or scripts. You can also get any custom header with
        #CURLOPT_HTTPHEADER.

   @{b}INPUTS@{ub}
        ua        input value

@ENDNODE

@NODE easySetOpt_UserName "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_UserName -- user name to use in authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_UserName(username)

   @{b}FUNCTION@{ub}
        Pass a string as parameter, which should be pointing to the user name to
        use for the transfer.

        #CURLOPT_USERNAME sets the user name to be used in protocol
        authentication. You should not use this option together with the (older)
        #CURLOPT_USERPWD option.

        When using Kerberos V5 authentication with a Windows based server, you
        should include the domain name in order for the server to successfully
        obtain a Kerberos Ticket. If you don't then the initial part of the
        authentication handshake may fail.

        When using NTLM, the user name can be specified simply as the user name
        without the domain name should the server be part of a single domain and
        forest.

        To include the domain name use either Down-Level Logon Name or UPN (User
        Principal Name) formats. For example, EXAMPLE\\user and
        user\@example.com respectively.

        Some HTTP servers (on Windows) support inclusion of the domain for Basic
        authentication as well.

        To specify the password and login options, along with the user name, use
        the #CURLOPT_PASSWORD and #CURLOPT_LOGIN_OPTIONS options.

   @{b}INPUTS@{ub}
        username  input value

@ENDNODE

@NODE easySetOpt_UserPwd "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_UserPwd -- user name and password to use in authentication

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_UserPwd(userpwd)

   @{b}FUNCTION@{ub}
        Pass a string as parameter containing the login details for the
        connection. The format of which is: [user name]:[password].

        When using Kerberos V5 authentication with a Windows based server, you
        should specify the user name part with the domain name in order for the
        server to successfully obtain a Kerberos Ticket. If you don't then the
        initial part of the authentication handshake may fail.

        When using NTLM, the user name can be specified simply as the user name
        without the domain name should the server be part of a single domain and
        forest.

        To specify the domain name use either Down-Level Logon Name or UPN (User
        Principal Name) formats. For example, EXAMPLE\\user and
        user\@example.com respectively.

        Some HTTP servers (on Windows) support inclusion of the domain for Basic
        authentication as well.

        When using HTTP and #CURLOPT_FOLLOWLOCATION, libcurl might perform
        several requests to possibly different hosts. libcurl will only send
        this user and password information to hosts using the initial host name
        (unless #CURLOPT_UNRESTRICTED_AUTH is get), so if libcurl follows
        locations to other hosts it will not send the user and password to
        those. This is enforced to prevent accidental information leakage.

        Use #CURLOPT_HTTPAUTH to specify the authentication method for HTTP
        based connections or #CURLOPT_LOGIN_OPTIONS to control IMAP, POP3 and
        SMTP options.

        The user and password strings are not URL decoded, so there's no way to
        send in a user name containing a colon using this option. Use
        #CURLOPT_USERNAME for that, or include it in the URL.

   @{b}INPUTS@{ub}
        userpwd   input value

@ENDNODE

@NODE easySetOpt_Use_SSL "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Use_SSL -- request using SSL / TLS for the transfer

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Use_SSL(level)

   @{b}FUNCTION@{ub}
        Pass a value using one of the values from below, to make libcurl use
        your desired "level" of SSL for the transfer.

        These are all protocols that start out plain text and get "upgraded" to
        SSL using the STARTTLS command.

        This is for enabling SSL/TLS when you use FTP, SMTP, POP3, IMAP etc.

        #CURLUSESSL_NONE
                  Don't attempt to use SSL.
        #CURLUSESSL_TRY
                  Try using SSL, proceed as normal otherwise.
        #CURLUSESSL_CONTROL
                  Require SSL for the control connection or fail with
                  #CURLE_USE_SSL_FAILED.
        #CURLUSESSL_ALL
                  Require SSL for all communication or fail with
                  #CURLE_USE_SSL_FAILED.

   @{b}INPUTS@{ub}
        level     input value

@ENDNODE

@NODE easySetOpt_Verbose "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_Verbose -- get verbose mode on/off

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_Verbose(onoff)

   @{b}FUNCTION@{ub}
        Set the "onoff" parameter to 1 to make the library display a lot of
        verbose information about its operations on this "handle". Very useful
        for libcurl and/or protocol debugging and understanding. The verbose
        information will be sent to stderr, or the stream get with
        #CURLOPT_STDERR.

        You hardly ever want this get in production use, you will almost always
        want this when you debug/report problems.

        To also get all the protocol data sent and received, consider using the
        #CURLOPT_DEBUGFUNCTION.

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_WildcardMatch "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_WildcardMatch -- enable directory wildcard transfers

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_WildcardMatch(onoff)

   @{b}FUNCTION@{ub}
        Set "onoff" to 1 if you want to transfer multiple files according to a
        file name pattern. The pattern can be specified as part of the
        #CURLOPT_URL option, using an fnmatch-like pattern (Shell Pattern
        Matching) in the last part of URL (file name).

        By default, libcurl uses its internal wildcard matching implementation.
        You can provide your own matching function by the
        #CURLOPT_FNMATCH_FUNCTION option.

        A brief introduction of its syntax follows:

        "* - ASTERISK"
                  ftp://example.com/some/path/*.txt (for all txt's from the root
                  directory). Only two asterisks are allowed within the same
                  pattern string.

        "? - QUESTION MARK"
                  Question mark matches any (exactly one) character.

                  ftp://example.com/some/path/photo?.jpeg

        "[ - BRACKET EXPRESSION"
                  The left bracket opens a bracket expression. The question mark
                  and asterisk have no special meaning in a bracket expression.
                  Each bracket expression ends by the right bracket and matches
                  exactly one character. Some examples follow:

                  [a-zA-Z0\\-9] or [f\\-gF\\-G]
                            character interval

                  [abc]     character enumeration

                  [^abc] or [!abc]
                            negation

                  [[:§name:]]
                            class expression. Supported classes are alnum,lower,
                            space, alpha, digit, print, upper, blank, graph,
                            xdigit.

                  [][-!^]   special case \\- matches only '\\-', ']', '[', '!'
                            or '^'. These characters have no special purpose.

                  [\\[\\]\\\\]  escape syntax. Matches '[', ']' or '\\.

                  Using the rules above, a file name pattern can be constructed:

                  ftp://example.com/some/path/[a-z[:upper:]\\\\].jpeg

   @{b}INPUTS@{ub}
        onoff     input value

@ENDNODE

@NODE easySetOpt_WriteFunction "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_WriteFunction -- get callback for writing received data

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_WriteFunction(write_callback[, userdata])

   @{b}FUNCTION@{ub}
        Pass a callback function. This callback function gets called by libcurl
        as soon as there is data received that needs to be saved. For most
        transfers, this callback gets called many times and each invoke delivers
        another chunk of data.

        The first parameter that is passed to your callback function is a string
        that contains the raw binary data just received. If you pass the
        optional "userdata" argument, the value you pass in "userdata" will be
        passed to your callback function as a second parameter. The "userdata"
        parameter can be of any type.

        The callback function will be passed as much data as possible in all
        invokes, but you must not make any assumptions. It may be one byte, it
        may be thousands. The maximum amount of body data that will be passed to
        the write callback is defined as follows: #CURL_MAX_WRITE_SIZE (the
        usual default is 16K). If #CURLOPT_HEADER is enabled, which makes header
        data get passed to the write callback, you can get up to
        #CURL_MAX_HTTP_HEADER bytes of header data passed into it. This usually
        means 100K.

        This function may be called with zero bytes data if the transferred file
        is empty.

        Your callback should return the number of bytes actually taken care of.
        If that amount differs from the amount passed to your callback function,
        it'll signal an error condition to the library. This will cause the
        transfer to get aborted and the libcurl function used will return
        #CURLE_WRITE_ERROR.

        If your write function returns nothing, this will signal success and the
        transfer will be continued.

        If your callback function returns #CURL_WRITEFUNC_PAUSE it will cause
        this transfer to become paused. See @{"easy:Pause()" LINK easyPause} for further details.

   @{b}INPUTS@{ub}
        write_callback
                  input value
        userdata  optional: user data to pass to callback function

   @{b}EXAMPLE@{ub}
        Function p_WriteData(data$)
           WriteBytes(1, data$)
        EndFunction
        e:SetOpt_WriteFunction(p_WriteData)

        The code above will install a write function that will write all data it
        receives to the file using the identifier 1.

@ENDNODE

@NODE easySetOpt_WS_Options "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_WS_Options -- WebSocket behavior options (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_WS_Options(bitmask)

   @{b}FUNCTION@{ub}
        Pass a bitmask to tell libcurl about specific WebSocket behaviors.

        To detach a WebSocket connection and use the WS send and recv functions
        after the HTTP upgrade procedure, get the #CURLOPT_CONNECT_ONLY option
        to 2.

        Available bits in the bitmask:

        #CURLWS_RAW_MODE
                  Deliver "raw" WebSocket traffic to the #CURLOPT_WRITEFUNCTION
                  callback.

        In raw mode, libcurl does not handle pings or any other frame for the
        application.

   @{b}INPUTS@{ub}
        bitmask   input value

@ENDNODE

@NODE easySetOpt_XOAuth2_Bearer "hURL Guide"

   @{b}NAME@{ub}
        easy:SetOpt_XOAuth2_Bearer -- specify OAuth 2.0 access token

   @{b}SYNOPSIS@{ub}
        easy:SetOpt_XOAuth2_Bearer(token)

   @{b}FUNCTION@{ub}
        Pass a string as parameter containing the OAuth 2.0 Bearer Access Token
        for use with HTTP, IMAP, POP3 and SMTP servers that support the OAuth
        2.0 Authorization Framework.

        Note: For IMAP, POP3 and SMTP, the user name used to generate the Bearer
        Token should be supplied via the #CURLOPT_USERNAME option.

   @{b}INPUTS@{ub}
        token     input value

@ENDNODE

@NODE easyUnescape "hURL Guide"

   @{b}NAME@{ub}
        easy:Unescape -- URL decodes the given string

   @{b}SYNOPSIS@{ub}
        e$ = easy:Unescape(s$)

   @{b}FUNCTION@{ub}
        This function converts the given URL encoded input string to a "plain
        string" and returns that. All input characters that are URL encoded (%XX
        where XX is a two-digit hexadecimal number) are converted to their
        binary versions.

   @{b}INPUTS@{ub}
        s$        string to unescape

   @{b}RESULTS@{ub}
        e$        unescaped string

@ENDNODE

@NODE easyUnsetOpt "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt -- unset option for a curl easy handle

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt(option)

   @{b}FUNCTION@{ub}
        This method can be used to unset an option on a curl easy handle, i.e.
        the option is reset to its default value.

        The following option types are currently supported:

        #CURLOPT_ABSTRACT_UNIX_SOCKET
                  Path to an abstract Unix domain socket. See
                  @{"easy:UnsetOpt_Abstract_Unix_Socket" LINK easyUnsetOpt_Abstract_Unix_Socket} for details.
        #CURLOPT_ACCEPT_ENCODING
                  Accept-Encoding and automatic decompressing data. See
                  @{"easy:UnsetOpt_Accept_Encoding" LINK easyUnsetOpt_Accept_Encoding} for details.
        #CURLOPT_ACCEPTTIMEOUT_MS
                  Timeout for waiting for the server's connect back to be
                  accepted. See @{"easy:UnsetOpt_AcceptTimeout_MS" LINK easyUnsetOpt_AcceptTimeout_MS} for details.
        #CURLOPT_ADDRESS_SCOPE
                  IPv6 scope for local addresses. See
                  @{"easy:UnsetOpt_Address_Scope" LINK easyUnsetOpt_Address_Scope} for details.
        #CURLOPT_ALTSVC
                  Specify the Alt-Svc: cache file name. See @{"easy:UnsetOpt_AltSvc" LINK easyUnsetOpt_AltSvc}
                  for details. (V2.0)
        #CURLOPT_ALTSVC_CTRL
                  Enable and configure Alt-Svc: treatment. See
                  @{"easy:UnsetOpt_AltSvc_Ctrl" LINK easyUnsetOpt_AltSvc_Ctrl} for details. (V2.0)
        #CURLOPT_APPEND
                  Append to remote file. See @{"easy:UnsetOpt_Append" LINK easyUnsetOpt_Append} for details.
        #CURLOPT_AUTOREFERER
                  Automatically get Referer: header. See
                  @{"easy:UnsetOpt_AutoReferer" LINK easyUnsetOpt_AutoReferer} for details.
        #CURLOPT_AWS_SIGV4
                  AWS HTTP V4 Signature. See @{"easy:UnsetOpt_AWS_SigV4" LINK easyUnsetOpt_AWS_SigV4} for
                  details. (V2.0)
        #CURLOPT_BUFFERSIZE
                  Ask for alternate buffer size. See @{"easy:UnsetOpt_BufferSize" LINK easyUnsetOpt_BufferSize}
                  for details.
        #CURLOPT_CA_CACHE_TIMEOUT
                  Timeout for CA cache. See @{"easy:UnsetOpt_CA_Cache_Timeout" LINK easyUnsetOpt_CA_Cache_Timeout} for
                  details. (V2.0)
        #CURLOPT_CAINFO
                  CA cert bundle. See @{"easy:UnsetOpt_CAInfo" LINK easyUnsetOpt_CAInfo} for details.
        #CURLOPT_CAINFO_BLOB
                  CA cert bundle memory buffer. See @{"easy:UnsetOpt_CAInfo_Blob" LINK easyUnsetOpt_CAInfo_Blob}
                  for details. (V2.0)
        #CURLOPT_CAPATH
                  Path to CA cert bundle. See @{"easy:UnsetOpt_CAPath" LINK easyUnsetOpt_CAPath} for details.
        #CURLOPT_CERTINFO
                  Extract certificate info. See @{"easy:UnsetOpt_CertInfo" LINK easyUnsetOpt_CertInfo} for
                  details.
        #CURLOPT_CHUNK_BGN_FUNCTION
                  Callback for wildcard download start of chunk. See
                  @{"easy:UnsetOpt_Chunk_BGN_Function" LINK easyUnsetOpt_Chunk_BGN_Function} for details.
        #CURLOPT_CHUNK_END_FUNCTION
                  Callback for wildcard download end of chunk. See
                  @{"easy:UnsetOpt_Chunk_End_Function" LINK easyUnsetOpt_Chunk_End_Function} for details.
        #CURLOPT_CONNECT_ONLY
                  Only connect, nothing else. See @{"easy:UnsetOpt_Connect_Only" LINK easyUnsetOpt_Connect_Only} for
                  details.
        #CURLOPT_CONNECT_TO
                  Connect to a specific host and port. See
                  @{"easy:UnsetOpt_Connect_To" LINK easyUnsetOpt_Connect_To} for details.
        #CURLOPT_CONNECTTIMEOUT
                  Timeout for the connection phase. See
                  @{"easy:UnsetOpt_ConnectTimeout" LINK easyUnsetOpt_ConnectTimeout} for details.
        #CURLOPT_CONNECTTIMEOUT_MS
                  Millisecond timeout for the connection phase. See
                  @{"easy:UnsetOpt_ConnectTimeout_MS" LINK easyUnsetOpt_ConnectTimeout_MS} for details.
        #CURLOPT_COOKIE
                  Cookie(s) to send. See @{"easy:UnsetOpt_Cookie" LINK easyUnsetOpt_Cookie} for details.
        #CURLOPT_COOKIEFILE
                  File to read cookies from. See @{"easy:UnsetOpt_CookieFile" LINK easyUnsetOpt_CookieFile} for
                  details.
        #CURLOPT_COOKIEJAR
                  File to write cookies to. See @{"easy:UnsetOpt_CookieJar" LINK easyUnsetOpt_CookieJar} for
                  details.
        #CURLOPT_COOKIELIST
                  Add or control cookies. See @{"easy:UnsetOpt_CookieList" LINK easyUnsetOpt_CookieList} for
                  details.
        #CURLOPT_COOKIESESSION
                  Start a new cookie session. See @{"easy:UnsetOpt_CookieSession" LINK easyUnsetOpt_CookieSession}
                  for details.
        #CURLOPT_CRLF
                  Convert newlines. See @{"easy:UnsetOpt_CRLF" LINK easyUnsetOpt_CRLF} for details.
        #CURLOPT_CRLFILE
                  Certificate Revocation List. See @{"easy:UnsetOpt_CRLFile" LINK easyUnsetOpt_CRLFile} for
                  details.
        #CURLOPT_CURLU
                  Set URL to work on with a URL handle. See @{"easy:UnsetOpt_CURLU" LINK easyUnsetOpt_CURLU}
                  for details. (V2.0)
        #CURLOPT_CUSTOMREQUEST
                  Custom request/method. See @{"easy:UnsetOpt_CustomRequest" LINK easyUnsetOpt_CustomRequest} for
                  details.
        #CURLOPT_DEBUGFUNCTION
                  Callback for debug information. See
                  @{"easy:UnsetOpt_DebugFunction" LINK easyUnsetOpt_DebugFunction} for details.
        #CURLOPT_DEFAULT_PROTOCOL
                  Default protocol. See @{"easy:UnsetOpt_Default_Protocol" LINK easyUnsetOpt_Default_Protocol} for
                  details.
        #CURLOPT_DIRLISTONLY
                  List only. See @{"easy:UnsetOpt_DirListOnly" LINK easyUnsetOpt_DirListOnly} for details.
        #CURLOPT_DNS_CACHE_TIMEOUT
                  Timeout for DNS cache. See @{"easy:UnsetOpt_DNS_Cache_Timeout" LINK easyUnsetOpt_DNS_Cache_Timeout} for
                  details.
        #CURLOPT_DNS_INTERFACE
                  Bind name resolves to this interface. See
                  @{"easy:UnsetOpt_DNS_Interface" LINK easyUnsetOpt_DNS_Interface} for details.
        #CURLOPT_DNS_LOCAL_IP4
                  Bind name resolves to this IP4 address. See
                  @{"easy:UnsetOpt_DNS_Local_IP4" LINK easyUnsetOpt_DNS_Local_IP4} for details.
        #CURLOPT_DNS_LOCAL_IP6
                  Bind name resolves to this IP6 address. See
                  @{"easy:UnsetOpt_DNS_Local_IP6" LINK easyUnsetOpt_DNS_Local_IP6} for details.
        #CURLOPT_DNS_SERVERS
                  Preferred DNS servers. See @{"easy:UnsetOpt_DNS_Servers" LINK easyUnsetOpt_DNS_Servers} for
                  details.
        #CURLOPT_DNS_SHUFFLE_ADDRESSES
                  Shuffle addresses before use. See
                  @{"easy:UnsetOpt_DNS_Shuffle_Addresses" LINK easyUnsetOpt_DNS_Shuffle_Addresses} for details. (V2.0)
        #CURLOPT_DNS_USE_GLOBAL_CACHE
                  OBSOLETE Enable global DNS cache. See
                  @{"easy:UnsetOpt_DNS_Use_Global_Cache" LINK easyUnsetOpt_DNS_Use_Global_Cache} for details.
        #CURLOPT_DISALLOW_USERNAME_IN_URL
                  Do not allow username in URL. See
                  @{"easy:UnsetOpt_Disallow_Username_In_URL" LINK easyUnsetOpt_Disallow_Username_In_URL} for details. (V2.0)
        #CURLOPT_DOH_SSL_VERIFYHOST
                  Verify the host name in the DoH (DNS-over-HTTPS) SSL
                  certificate. See @{"easy:UnsetOpt_DoH_SSL_VerifyHost" LINK easyUnsetOpt_DoH_SSL_VerifyHost} for details.
                  (V2.0)
        #CURLOPT_DOH_SSL_VERIFYPEER
                  Verify the DoH (DNS-over-HTTPS) SSL certificate. See
                  @{"easy:UnsetOpt_DoH_SSL_VerifyPeer" LINK easyUnsetOpt_DoH_SSL_VerifyPeer} for details. (V2.0)
        #CURLOPT_DOH_SSL_VERIFYSTATUS
                  Verify the DoH (DNS-over-HTTPS) SSL certificate's status. See
                  @{"easy:UnsetOpt_DoH_SSL_VerifyStatus" LINK easyUnsetOpt_DoH_SSL_VerifyStatus} for details. (V2.0)
        #CURLOPT_DOH_URL
                  Use this DoH server for name resolves. See
                  @{"easy:UnsetOpt_DoH_URL" LINK easyUnsetOpt_DoH_URL} for details. (V2.0)
        #CURLOPT_EGDSOCKET
                  Identify EGD socket for entropy. See @{"easy:UnsetOpt_EGDSocket" LINK easyUnsetOpt_EGDSocket}
                  for details.
        #CURLOPT_EXPECT_100_TIMEOUT_MS
                  100-continue timeout. See @{"easy:UnsetOpt_Expect_100_Timeout_MS" LINK easyUnsetOpt_Expect_100_Timeout_MS}
                  for details.
        #CURLOPT_FAILONERROR
                  Fail on HTTP 4xx errors. See @{"easy:UnsetOpt_FailOnError" LINK easyUnsetOpt_FailOnError} for
                  details.
        #CURLOPT_FILETIME
                  Request file modification date and time. See
                  @{"easy:UnsetOpt_FileTime" LINK easyUnsetOpt_FileTime} for details.
        #CURLOPT_FNMATCH_FUNCTION
                  Callback for wildcard matching. See
                  @{"easy:UnsetOpt_FNMatch_Function" LINK easyUnsetOpt_FNMatch_Function} for details.
        #CURLOPT_FOLLOWLOCATION
                  Follow HTTP redirects. See @{"easy:UnsetOpt_FollowLocation" LINK easyUnsetOpt_FollowLocation} for
                  details.
        #CURLOPT_FORBID_REUSE
                  Prevent subsequent connections from re-using this. See
                  @{"easy:UnsetOpt_Forbid_Reuse" LINK easyUnsetOpt_Forbid_Reuse} for details.
        #CURLOPT_FRESH_CONNECT
                  Use a new connection. See @{"easy:UnsetOpt_Fresh_Connect" LINK easyUnsetOpt_Fresh_Connect} for
                  details.
        #CURLOPT_FTP_ACCOUNT
                  Send ACCT command. See @{"easy:UnsetOpt_FTP_Account" LINK easyUnsetOpt_FTP_Account} for details.
        #CURLOPT_FTP_ALTERNATIVE_TO_USER
                  Alternative to USER. See @{"easy:UnsetOpt_FTP_Alternative_To_User" LINK easyUnsetOpt_FTP_Alternative_To_User}
                  for details.
        #CURLOPT_FTP_CREATE_MISSING_DIRS
                  Create missing directories on the remote server. See
                  @{"easy:UnsetOpt_FTP_Create_Missing_Dirs" LINK easyUnsetOpt_FTP_Create_Missing_Dirs} for details.
        #CURLOPT_FTP_FILEMETHOD
                  Specify how to reach files. See @{"easy:UnsetOpt_FTP_FileMethod" LINK easyUnsetOpt_FTP_FileMethod}
                  for details.
        #CURLOPT_FTP_RESPONSE_TIMEOUT
                  Timeout for FTP responses. See
                  @{"easy:UnsetOpt_FTP_Response_Timeout" LINK easyUnsetOpt_FTP_Response_Timeout} for details.
        #CURLOPT_FTP_SKIP_PASV_IP
                  Ignore the IP address in the PASV response. See
                  @{"easy:UnsetOpt_FTP_Skip_PASV_IP" LINK easyUnsetOpt_FTP_Skip_PASV_IP} for details.
        #CURLOPT_FTP_SSL_CCC
                  Back to non-TLS again after authentication. See
                  @{"easy:UnsetOpt_FTP_SSL_CCC" LINK easyUnsetOpt_FTP_SSL_CCC} for details.
        #CURLOPT_FTP_USE_EPRT
                  Use EPTR. See @{"easy:UnsetOpt_FTP_Use_Eprt" LINK easyUnsetOpt_FTP_Use_Eprt} for details.
        #CURLOPT_FTP_USE_EPSV
                  Use EPSV. See @{"easy:UnsetOpt_FTP_Use_Epsv" LINK easyUnsetOpt_FTP_Use_Epsv} for details.
        #CURLOPT_FTP_USE_PRET
                  Use PRET. See @{"easy:UnsetOpt_FTP_Use_Pret" LINK easyUnsetOpt_FTP_Use_Pret} for details.
        #CURLOPT_FTPPORT
                  Use active FTP. See @{"easy:UnsetOpt_FTPPort" LINK easyUnsetOpt_FTPPort} for details.
        #CURLOPT_FTPSSLAUTH
                  Control how to do TLS. See @{"easy:UnsetOpt_FTPSSLAuth" LINK easyUnsetOpt_FTPSSLAuth} for
                  details.
        #CURLOPT_GSSAPI_DELEGATION
                  Disable GSS-API delegation. See
                  @{"easy:UnsetOpt_GSSAPI_Delegation" LINK easyUnsetOpt_GSSAPI_Delegation} for details.
        #CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS
                  Timeout for happy eyeballs. See
                  @{"easy:UnsetOpt_Happy_Eyeballs_Timeout_MS" LINK easyUnsetOpt_Happy_Eyeballs_Timeout_MS} for details. (V2.0)
        #CURLOPT_HAPROXYPROTOCOL
                  Send an HAProxy PROXY protocol v1 header. See
                  @{"easy:UnsetOpt_HAProxyProtocol" LINK easyUnsetOpt_HAProxyProtocol} for details. (V2.0)
        #CURLOPT_HEADER
                  Include the header in the body output. See
                  @{"easy:UnsetOpt_Header" LINK easyUnsetOpt_Header} for details.
        #CURLOPT_HEADERFUNCTION
                  Callback for writing received headers. See
                  @{"easy:UnsetOpt_HeaderFunction" LINK easyUnsetOpt_HeaderFunction} for details.
        #CURLOPT_HEADEROPT
                  Control custom headers. See @{"easy:UnsetOpt_HeaderOpt" LINK easyUnsetOpt_HeaderOpt} for
                  details.
        #CURLOPT_HSTS
                  Set HSTS cache file. See @{"easy:UnsetOpt_HSTS" LINK easyUnsetOpt_HSTS} for details.
                  (V2.0)
        #CURLOPT_HSTS_CTRL
                  Enable HSTS. See @{"easy:UnsetOpt_HSTS_Ctrl" LINK easyUnsetOpt_HSTS_Ctrl} for details. (V2.0)
        #CURLOPT_HSTSREADFUNCTION
                  Set HSTS read callback. See @{"easy:UnsetOpt_HSTSReadFunction" LINK easyUnsetOpt_HSTSReadFunction} for
                  details. (V2.0)
        #CURLOPT_HSTSWRITEFUNCTION
                  Set HSTS write callback. See @{"easy:UnsetOpt_HSTSWriteFunction" LINK easyUnsetOpt_HSTSWriteFunction}
                  for details. (V2.0)
        #CURLOPT_HTTP09_ALLOWED
                  Allow HTTP/0. See @{"easy:UnsetOpt_HTTP09_Allowed" LINK easyUnsetOpt_HTTP09_Allowed} for details.
                  (V2.0)
        #CURLOPT_HTTP200ALIASES
                  Alternative versions of 200 OK. See
                  @{"easy:UnsetOpt_HTTP200Aliases" LINK easyUnsetOpt_HTTP200Aliases} for details.
        #CURLOPT_HTTP_CONTENT_DECODING
                  Disable Content decoding. See
                  @{"easy:UnsetOpt_HTTP_Content_Decoding" LINK easyUnsetOpt_HTTP_Content_Decoding} for details.
        #CURLOPT_HTTP_TRANSFER_DECODING
                  Disable Transfer decoding. See
                  @{"easy:UnsetOpt_HTTP_Transfer_Decoding" LINK easyUnsetOpt_HTTP_Transfer_Decoding} for details.
        #CURLOPT_HTTP_VERSION
                  HTTP version to use. See @{"easy:UnsetOpt_HTTP_Version" LINK easyUnsetOpt_HTTP_Version} for
                  details.
        #CURLOPT_HTTPAUTH
                  HTTP server authentication methods. See @{"easy:UnsetOpt_HTTPAuth" LINK easyUnsetOpt_HTTPAuth}
                  for details.
        #CURLOPT_HTTPGET
                  Do an HTTP GET request. See @{"easy:UnsetOpt_HTTPGet" LINK easyUnsetOpt_HTTPGet} for details.
        #CURLOPT_HTTPHEADER
                  Custom HTTP headers. See @{"easy:UnsetOpt_HTTPHeader" LINK easyUnsetOpt_HTTPHeader} for details.
        #CURLOPT_HTTPPOST
                  Multipart formpost HTTP POST. See @{"easy:UnsetOpt_HTTPPost" LINK easyUnsetOpt_HTTPPost} for
                  details.
        #CURLOPT_HTTPPROXYTUNNEL
                  Tunnel through the HTTP proxy. See
                  @{"easy:UnsetOpt_HTTPProxyTunnel" LINK easyUnsetOpt_HTTPProxyTunnel} for details.
        #CURLOPT_IGNORE_CONTENT_LENGTH
                  Ignore Content-Length. See @{"easy:UnsetOpt_Ignore_Content_Length" LINK easyUnsetOpt_Ignore_Content_Length}
                  for details.
        #CURLOPT_INFILESIZE
                  Size of file to send. See @{"easy:UnsetOpt_InFileSize" LINK easyUnsetOpt_InFileSize} for
                  details.
        #CURLOPT_INFILESIZE_LARGE
                  Size of file to send. See @{"easy:UnsetOpt_InFileSize_Large" LINK easyUnsetOpt_InFileSize_Large} for
                  details.
        #CURLOPT_INTERFACE
                  Bind connection locally to this. See @{"easy:UnsetOpt_Interface" LINK easyUnsetOpt_Interface}
                  for details.
        #CURLOPT_IPRESOLVE
                  IP version to resolve to. See @{"easy:UnsetOpt_IPResolve" LINK easyUnsetOpt_IPResolve} for
                  details.
        #CURLOPT_ISSUERCERT
                  Issuer certificate. See @{"easy:UnsetOpt_IssuerCert" LINK easyUnsetOpt_IssuerCert} for details.
        #CURLOPT_ISSUERCERT_BLOB
                  Issuer certificate memory buffer. See
                  @{"easy:UnsetOpt_IssuerCert_Blob" LINK easyUnsetOpt_IssuerCert_Blob} for details. (V2.0)
        #CURLOPT_KEEP_SENDING_ON_ERROR
                  Keep sending on HTTP >= 300 errors. See
                  @{"easy:UnsetOpt_Keep_Sending_On_Error" LINK easyUnsetOpt_Keep_Sending_On_Error} for details.
        #CURLOPT_KEYPASSWD
                  Client key password. See @{"easy:UnsetOpt_KeyPasswd" LINK easyUnsetOpt_KeyPasswd} for details.
        #CURLOPT_KRBLEVEL
                  Kerberos security level. See @{"easy:UnsetOpt_KRBLevel" LINK easyUnsetOpt_KRBLevel} for
                  details.
        #CURLOPT_LOCALPORT
                  Bind connection locally to this port. See
                  @{"easy:UnsetOpt_LocalPort" LINK easyUnsetOpt_LocalPort} for details.
        #CURLOPT_LOCALPORTRANGE
                  Bind connection locally to port range. See
                  @{"easy:UnsetOpt_LocalPortRange" LINK easyUnsetOpt_LocalPortRange} for details.
        #CURLOPT_LOGIN_OPTIONS
                  Login options. See @{"easy:UnsetOpt_Login_Options" LINK easyUnsetOpt_Login_Options} for details.
        #CURLOPT_LOW_SPEED_LIMIT
                  Low speed limit to abort transfer. See
                  @{"easy:UnsetOpt_Low_Speed_Limit" LINK easyUnsetOpt_Low_Speed_Limit} for details.
        #CURLOPT_LOW_SPEED_TIME
                  Time to be below the speed to trigger low speed abort. See
                  @{"easy:UnsetOpt_Low_Speed_Time" LINK easyUnsetOpt_Low_Speed_Time} for details.
        #CURLOPT_MAIL_AUTH
                  Authentication address. See @{"easy:UnsetOpt_Mail_Auth" LINK easyUnsetOpt_Mail_Auth} for
                  details.
        #CURLOPT_MAIL_FROM
                  Address of the sender. See @{"easy:UnsetOpt_Mail_From" LINK easyUnsetOpt_Mail_From} for
                  details.
        #CURLOPT_MAIL_RCPT
                  Address of the recipients. See @{"easy:UnsetOpt_Mail_RCPT" LINK easyUnsetOpt_Mail_RCPT} for
                  details.
        #CURLOPT_MAIL_RCPT_ALLOWFAILS
                  Allow RCPT TO command to fail for some recipients. See
                  @{"easy:UnsetOpt_Mail_RCPT_AllowFails" LINK easyUnsetOpt_Mail_RCPT_AllowFails} for details. (V2.0)
        #CURLOPT_MAXAGE_CONN
                  Limit the age (idle time) of connections for reuse. See
                  @{"easy:UnsetOpt_MaxAge_Conn" LINK easyUnsetOpt_MaxAge_Conn} for details. (V2.0)
        #CURLOPT_MAXLIFETIME_CONN
                  Limit the age (since creation) of connections for reuse. See
                  @{"easy:UnsetOpt_MaxLifeTime_Conn" LINK easyUnsetOpt_MaxLifeTime_Conn} for details. (V2.0)
        #CURLOPT_PREREQFUNCTION
                  Callback to be called after a connection is established but
                  before a request is made on that connection. See
                  @{"easy:UnsetOpt_PreReqFunction" LINK easyUnsetOpt_PreReqFunction} for details. (V2.0)
        #CURLOPT_MAX_RECV_SPEED_LARGE
                  Cap the download speed to this. See
                  @{"easy:UnsetOpt_Max_Recv_Speed_Large" LINK easyUnsetOpt_Max_Recv_Speed_Large} for details.
        #CURLOPT_MAX_SEND_SPEED_LARGE
                  Cap the upload speed to this. See
                  @{"easy:UnsetOpt_Max_Send_Speed_Large" LINK easyUnsetOpt_Max_Send_Speed_Large} for details.
        #CURLOPT_MAXCONNECTS
                  Maximum number of connections in the connection pool. See
                  @{"easy:UnsetOpt_MaxConnects" LINK easyUnsetOpt_MaxConnects} for details.
        #CURLOPT_MAXFILESIZE
                  Maximum file size to get. See @{"easy:UnsetOpt_MaxFileSize" LINK easyUnsetOpt_MaxFileSize} for
                  details.
        #CURLOPT_MAXFILESIZE_LARGE
                  Maximum file size to get. See @{"easy:UnsetOpt_MaxFileSize_Large" LINK easyUnsetOpt_MaxFileSize_Large}
                  for details.
        #CURLOPT_MAXREDIRS
                  Maximum number of redirects to follow. See
                  @{"easy:UnsetOpt_MaxRedirs" LINK easyUnsetOpt_MaxRedirs} for details.
        #CURLOPT_MIME_OPTIONS
                  Set MIME option flags. See @{"easy:UnsetOpt_MIME_Options" LINK easyUnsetOpt_MIME_Options} for
                  details. (V2.0)
        #CURLOPT_MIMEPOST
                  Post/send MIME data. See @{"easy:UnsetOpt_MIMEPost" LINK easyUnsetOpt_MIMEPost} for details.
                  (V2.0)
        #CURLOPT_NETRC
                  Enable.netrc parsing. See @{"easy:UnsetOpt_Netrc" LINK easyUnsetOpt_Netrc} for details.
        #CURLOPT_NETRC_FILE
                  .netrc file name. See @{"easy:UnsetOpt_Netrc_File" LINK easyUnsetOpt_Netrc_File} for details.
        #CURLOPT_NEW_DIRECTORY_PERMS
                  Mode for creating new remote directories. See
                  @{"easy:UnsetOpt_New_Directory_Perms" LINK easyUnsetOpt_New_Directory_Perms} for details.
        #CURLOPT_NEW_FILE_PERMS
                  Mode for creating new remote files. See
                  @{"easy:UnsetOpt_New_File_Perms" LINK easyUnsetOpt_New_File_Perms} for details.
        #CURLOPT_NOBODY
                  Do not get the body contents. See @{"easy:UnsetOpt_Nobody" LINK easyUnsetOpt_Nobody} for
                  details.
        #CURLOPT_NOPROGRESS
                  Shut off the progress meter. See @{"easy:UnsetOpt_NoProgress" LINK easyUnsetOpt_NoProgress} for
                  details.
        #CURLOPT_NOPROXY
                  Filter out hosts from proxy use. See @{"easy:UnsetOpt_NoProxy" LINK easyUnsetOpt_NoProxy} for
                  details.
        #CURLOPT_NOSIGNAL
                  Do not install signal handlers. See @{"easy:UnsetOpt_NoSignal" LINK easyUnsetOpt_NoSignal} for
                  details.
        #CURLOPT_PASSWORD
                  Password. See @{"easy:UnsetOpt_Password" LINK easyUnsetOpt_Password} for details.
        #CURLOPT_PATH_AS_IS
                  Disable squashing /. See @{"easy:UnsetOpt_Path_As_Is" LINK easyUnsetOpt_Path_As_Is} for details.
        #CURLOPT_PINNEDPUBLICKEY
                  Set pinned SSL public key. See @{"easy:UnsetOpt_PinnedPublicKey" LINK easyUnsetOpt_PinnedPublicKey}
                  for details.
        #CURLOPT_PIPEWAIT
                  Wait on connection to pipeline on it. See
                  @{"easy:UnsetOpt_PipeWait" LINK easyUnsetOpt_PipeWait} for details.
        #CURLOPT_PORT
                  Port number to connect to. See @{"easy:UnsetOpt_Port" LINK easyUnsetOpt_Port} for details.
        #CURLOPT_POST
                  How to act on redirects after POST. See @{"easy:UnsetOpt_Post" LINK easyUnsetOpt_Post} for
                  details.
        #CURLOPT_POSTFIELDS
                  Send a POST with this data. See @{"easy:UnsetOpt_PostFields" LINK easyUnsetOpt_PostFields} for
                  details.
        #CURLOPT_POSTQUOTE
                  Commands to run after transfer. See @{"easy:UnsetOpt_PostQuote" LINK easyUnsetOpt_PostQuote}
                  for details.
        #CURLOPT_POSTREDIR
                  How to act on redirects after POST. See
                  @{"easy:UnsetOpt_PostRedir" LINK easyUnsetOpt_PostRedir} for details.
        #CURLOPT_PRE_PROXY
                  Socks proxy to use. See @{"easy:UnsetOpt_Pre_Proxy" LINK easyUnsetOpt_Pre_Proxy} for details.
        #CURLOPT_PREQUOTE
                  Commands to run just before transfer. See
                  @{"easy:UnsetOpt_Prequote" LINK easyUnsetOpt_Prequote} for details.
        #CURLOPT_PROGRESSFUNCTION
                  Callback for progress meter. See
                  @{"easy:UnsetOpt_ProgressFunction" LINK easyUnsetOpt_ProgressFunction} for details.
        #CURLOPT_PROTOCOLS
                  Allowed protocols. See @{"easy:UnsetOpt_Protocols" LINK easyUnsetOpt_Protocols} for details.
        #CURLOPT_PROTOCOLS_STR
                  Allowed protocols. See @{"easy:UnsetOpt_Protocols_Str" LINK easyUnsetOpt_Protocols_Str} for
                  details. (V2.0)
        #CURLOPT_PROXY
                  Proxy to use. See @{"easy:UnsetOpt_Proxy" LINK easyUnsetOpt_Proxy} for details.
        #CURLOPT_PROXY_CAINFO
                  Proxy CA cert bundle. See @{"easy:UnsetOpt_Proxy_CAInfo" LINK easyUnsetOpt_Proxy_CAInfo} for
                  details.
        #CURLOPT_PROXY_CAINFO_BLOB
                  Proxy CA cert bundle memory buffer. See
                  @{"easy:UnsetOpt_Proxy_CAInfo_Blob" LINK easyUnsetOpt_Proxy_CAInfo_Blob} for details. (V2.0)
        #CURLOPT_PROXY_CAPATH
                  Path to proxy CA cert bundle. See @{"easy:UnsetOpt_Proxy_CAPath" LINK easyUnsetOpt_Proxy_CAPath}
                  for details.
        #CURLOPT_PROXY_CRLFILE
                  Proxy Certificate Revocation List. See
                  @{"easy:UnsetOpt_Proxy_CRLFile" LINK easyUnsetOpt_Proxy_CRLFile} for details.
        #CURLOPT_PROXY_ISSUERCERT
                  Proxy issuer certificate. See @{"easy:UnsetOpt_Proxy_IssuerCert" LINK easyUnsetOpt_Proxy_IssuerCert}
                  for details. (V2.0)
        #CURLOPT_PROXY_ISSUERCERT_BLOB
                  Proxy issuer certificate memory buffer. See
                  @{"easy:UnsetOpt_Proxy_IssuerCert_Blob" LINK easyUnsetOpt_Proxy_IssuerCert_Blob} for details. (V2.0)
        #CURLOPT_PROXY_KEYPASSWD
                  Proxy client key password. See @{"easy:UnsetOpt_Proxy_KeyPasswd" LINK easyUnsetOpt_Proxy_KeyPasswd}
                  for details.
        #CURLOPT_PROXY_PINNEDPUBLICKEY
                  Set the proxy's pinned SSL public key. See
                  @{"easy:UnsetOpt_Proxy_PinnedPublicKey" LINK easyUnsetOpt_Proxy_PinnedPublicKey} for details.
        #CURLOPT_PROXY_SERVICE_NAME
                  Proxy authentication service name. See
                  @{"easy:UnsetOpt_Proxy_Service_Name" LINK easyUnsetOpt_Proxy_Service_Name} for details.
        #CURLOPT_PROXY_SSLCERT
                  Proxy client cert. See @{"easy:UnsetOpt_Proxy_SSLCert" LINK easyUnsetOpt_Proxy_SSLCert} for
                  details.
        #CURLOPT_PROXY_SSLCERT_BLOB
                  Proxy client cert memory buffer. See
                  @{"easy:UnsetOpt_Proxy_SSLCert_Blob" LINK easyUnsetOpt_Proxy_SSLCert_Blob} for details. (V2.0)
        #CURLOPT_PROXY_SSLCERTTYPE
                  Proxy client cert type. See @{"easy:UnsetOpt_Proxy_SSLCertType" LINK easyUnsetOpt_Proxy_SSLCertType}
                  for details.
        #CURLOPT_PROXY_SSL_CIPHER_LIST
                  Proxy ciphers to use. See @{"easy:UnsetOpt_Proxy_SSL_Cipher_List" LINK easyUnsetOpt_Proxy_SSL_Cipher_List}
                  for details.
        #CURLOPT_PROXY_SSLKEY
                  Proxy client key. See @{"easy:UnsetOpt_Proxy_SSLKey" LINK easyUnsetOpt_Proxy_SSLKey} for details.
        #CURLOPT_PROXY_SSLKEY_BLOB
                  Proxy client key. See @{"easy:UnsetOpt_Proxy_SSLKey_Blob" LINK easyUnsetOpt_Proxy_SSLKey_Blob} for
                  details. (V2.0)
        #CURLOPT_PROXY_SSLKEYTYPE
                  Proxy client key type. See @{"easy:UnsetOpt_Proxy_SSLKeyType" LINK easyUnsetOpt_Proxy_SSLKeyType} for
                  details.
        #CURLOPT_PROXY_SSL_OPTIONS
                  Control proxy SSL behavior. See
                  @{"easy:UnsetOpt_Proxy_SSL_Options" LINK easyUnsetOpt_Proxy_SSL_Options} for details.
        #CURLOPT_PROXY_SSL_VERIFYHOST
                  Verify the host name in the proxy SSL certificate. See
                  @{"easy:UnsetOpt_Proxy_SSL_VerifyHost" LINK easyUnsetOpt_Proxy_SSL_VerifyHost} for details.
        #CURLOPT_PROXY_SSL_VERIFYPEER
                  Verify the proxy SSL certificate. See
                  @{"easy:UnsetOpt_Proxy_SSL_VerifyPeer" LINK easyUnsetOpt_Proxy_SSL_VerifyPeer} for details.
        #CURLOPT_PROXY_SSLVERSION
                  Proxy SSL version to use. See @{"easy:UnsetOpt_Proxy_SSLVersion" LINK easyUnsetOpt_Proxy_SSLVersion}
                  for details.
        #CURLOPT_PROXY_TLSAUTH_PASSWORD
                  Proxy TLS authentication password. See
                  @{"easy:UnsetOpt_Proxy_TLSAuth_Password" LINK easyUnsetOpt_Proxy_TLSAuth_Password} for details.
        #CURLOPT_PROXY_TLSAUTH_TYPE
                  Proxy TLS authentication methods. See
                  @{"easy:UnsetOpt_Proxy_TLSAuth_Type" LINK easyUnsetOpt_Proxy_TLSAuth_Type} for details.
        #CURLOPT_PROXY_TLSAUTH_USERNAME
                  Proxy TLS authentication user name. See
                  @{"easy:UnsetOpt_Proxy_TLSAuth_UserName" LINK easyUnsetOpt_Proxy_TLSAuth_UserName} for details.
        #CURLOPT_PROXY_TRANSFER_MODE
                  Add transfer mode to URL over proxy. See
                  @{"easy:UnsetOpt_Proxy_Transfer_Mode" LINK easyUnsetOpt_Proxy_Transfer_Mode} for details.
        #CURLOPT_PROXYAUTH
                  HTTP proxy authentication methods. See @{"easy:UnsetOpt_ProxyAuth" LINK easyUnsetOpt_ProxyAuth}
                  for details.
        #CURLOPT_PROXYHEADER
                  Custom HTTP headers sent to proxy. See
                  @{"easy:UnsetOpt_ProxyHeader" LINK easyUnsetOpt_ProxyHeader} for details.
        #CURLOPT_PROXYPASSWORD
                  Proxy password. See @{"easy:UnsetOpt_ProxyPassword" LINK easyUnsetOpt_ProxyPassword} for details.
        #CURLOPT_PROXYPORT
                  Proxy port to use. See @{"easy:UnsetOpt_ProxyPort" LINK easyUnsetOpt_ProxyPort} for details.
        #CURLOPT_PROXYTYPE
                  Proxy type. See @{"easy:UnsetOpt_ProxyType" LINK easyUnsetOpt_ProxyType} for details.
        #CURLOPT_PROXYUSERNAME
                  Proxy user name. See @{"easy:UnsetOpt_ProxyUserName" LINK easyUnsetOpt_ProxyUserName} for details.
        #CURLOPT_PROXYUSERPWD
                  Proxy user name and password. See @{"easy:UnsetOpt_ProxyUserPwd" LINK easyUnsetOpt_ProxyUserPwd}
                  for details.
        #CURLOPT_PUT
                  Issue an HTTP PUT request. See @{"easy:UnsetOpt_Put" LINK easyUnsetOpt_Put} for details.
        #CURLOPT_QUICK_EXIT
                  To be get by toplevel tools like "curl" to skip lengthy
                  cleanups when they are about to call exit() anyway. See
                  @{"easy:UnsetOpt_Quick_Exit" LINK easyUnsetOpt_Quick_Exit} for details. (V2.0)
        #CURLOPT_QUOTE
                  Commands to run before transfer. See @{"easy:UnsetOpt_Quote" LINK easyUnsetOpt_Quote} for
                  details.
        #CURLOPT_RANDOM_FILE
                  Provide source for entropy random data. See
                  @{"easy:UnsetOpt_Random_File" LINK easyUnsetOpt_Random_File} for details.
        #CURLOPT_RANGE
                  Range requests. See @{"easy:UnsetOpt_Range" LINK easyUnsetOpt_Range} for details.
        #CURLOPT_READFUNCTION
                  Callback for reading data. See @{"easy:UnsetOpt_ReadFunction" LINK easyUnsetOpt_ReadFunction} for
                  details.
        #CURLOPT_REDIR_PROTOCOLS
                  Protocols to allow redirects to. See
                  @{"easy:UnsetOpt_Redir_Protocols" LINK easyUnsetOpt_Redir_Protocols} for details.
        #CURLOPT_REDIR_PROTOCOLS_STR
                  Protocols to allow redirects to. See
                  @{"easy:UnsetOpt_Redir_Protocols_Str" LINK easyUnsetOpt_Redir_Protocols_Str} for details. (V2.0)
        #CURLOPT_REFERER
                  Referer: header. See @{"easy:UnsetOpt_Referer" LINK easyUnsetOpt_Referer} for details.
        #CURLOPT_REQUEST_TARGET
                  Set the request target. See @{"easy:UnsetOpt_Request_Target" LINK easyUnsetOpt_Request_Target} for
                  details.
        #CURLOPT_RESOLVE
                  Callback to be called before a new resolve request is started.
                  See @{"easy:UnsetOpt_Resolve" LINK easyUnsetOpt_Resolve} for details.
        #CURLOPT_RESOLVER_START_FUNCTION
                  Callback to be called before a new resolve request is started.
                  See @{"easy:UnsetOpt_Resolver_Start_Function" LINK easyUnsetOpt_Resolver_Start_Function} for details. (V2.0)
        #CURLOPT_RESUME_FROM
                  Resume a transfer. See @{"easy:UnsetOpt_Resume_From" LINK easyUnsetOpt_Resume_From} for details.
        #CURLOPT_RESUME_FROM_LARGE
                  Resume a transfer. See @{"easy:UnsetOpt_Resume_From_Large" LINK easyUnsetOpt_Resume_From_Large} for
                  details.
        #CURLOPT_RTSP_CLIENT_CSEQ
                  Client CSEQ number. See @{"easy:UnsetOpt_RTSP_Client_CSeq" LINK easyUnsetOpt_RTSP_Client_CSeq} for
                  details.
        #CURLOPT_RTSP_REQUEST
                  RTSP request. See @{"easy:UnsetOpt_RTSP_Request" LINK easyUnsetOpt_RTSP_Request} for details.
        #CURLOPT_RTSP_SERVER_CSEQ
                  CSEQ number for RTSP Server->Client request. See
                  @{"easy:UnsetOpt_RTSP_Server_CSeq" LINK easyUnsetOpt_RTSP_Server_CSeq} for details.
        #CURLOPT_RTSP_SESSION_ID
                  RTSP session-id. See @{"easy:UnsetOpt_RTSP_Session_ID" LINK easyUnsetOpt_RTSP_Session_ID} for
                  details.
        #CURLOPT_RTSP_STREAM_URI
                  RTSP stream URI. See @{"easy:UnsetOpt_RTSP_Stream_URI" LINK easyUnsetOpt_RTSP_Stream_URI} for
                  details.
        #CURLOPT_RTSP_TRANSPORT
                  RTSP Transport: header. See @{"easy:UnsetOpt_RTSP_Transport" LINK easyUnsetOpt_RTSP_Transport} for
                  details.
        #CURLOPT_SASL_AUTHZID
                  SASL authorization identity (identity to act as). See
                  @{"easy:UnsetOpt_SASL_AuthZID" LINK easyUnsetOpt_SASL_AuthZID} for details. (V2.0)
        #CURLOPT_SASL_IR
                  Enable SASL initial response. See @{"easy:UnsetOpt_SASL_IR" LINK easyUnsetOpt_SASL_IR} for
                  details.
        #CURLOPT_SEEKFUNCTION
                  Callback for seek operations. See @{"easy:UnsetOpt_SeekFunction" LINK easyUnsetOpt_SeekFunction}
                  for details.
        #CURLOPT_SERVICE_NAME
                  Authentication service name. See @{"easy:UnsetOpt_Service_Name" LINK easyUnsetOpt_Service_Name}
                  for details.
        #CURLOPT_SHARE
                  Share object to use. See @{"easy:UnsetOpt_Share" LINK easyUnsetOpt_Share} for details.
        #CURLOPT_SOCKS5_AUTH
                  Socks5 authentication methods. See @{"easy:UnsetOpt_Socks5_Auth" LINK easyUnsetOpt_Socks5_Auth}
                  for details.
        #CURLOPT_SOCKS5_GSSAPI_NEC
                  Socks5 GSSAPI NEC mode. See @{"easy:UnsetOpt_Socks5_GSSAPI_NEC" LINK easyUnsetOpt_Socks5_GSSAPI_NEC}
                  for details.
        #CURLOPT_SOCKS5_GSSAPI_SERVICE
                  Socks5 GSSAPI service name. See
                  @{"easy:UnsetOpt_Socks5_GSSAPI_Service" LINK easyUnsetOpt_Socks5_GSSAPI_Service} for details.
        #CURLOPT_SSH_AUTH_TYPES
                  SSH authentication types. See @{"easy:UnsetOpt_SSH_Auth_Types" LINK easyUnsetOpt_SSH_Auth_Types} for
                  details.
        #CURLOPT_SSH_COMPRESSION
                  Enable SSH compression. See @{"easy:UnsetOpt_SSH_Compression" LINK easyUnsetOpt_SSH_Compression} for
                  details. (V2.0)
        #CURLOPT_SSH_HOSTKEYFUNCTION
                  Callback for checking host key handling. See
                  @{"easy:UnsetOpt_SSH_HostKeyFunction" LINK easyUnsetOpt_SSH_HostKeyFunction} for details. (V2.0)
        #CURLOPT_SSH_HOST_PUBLIC_KEY_MD5
                  MD5 of host's public key. See
                  @{"easy:UnsetOpt_SSH_Host_Public_Key_MD5" LINK easyUnsetOpt_SSH_Host_Public_Key_MD5} for details.
        #CURLOPT_SSH_KNOWNHOSTS
                  File name with known hosts. See @{"easy:UnsetOpt_SSH_KnownHosts" LINK easyUnsetOpt_SSH_KnownHosts}
                  for details.
        #CURLOPT_SSH_PRIVATE_KEYFILE
                  File name of private key. See
                  @{"easy:UnsetOpt_SSH_Private_KeyFile" LINK easyUnsetOpt_SSH_Private_KeyFile} for details.
        #CURLOPT_SSH_PUBLIC_KEYFILE
                  File name of public key. See @{"easy:UnsetOpt_SSH_Public_KeyFile" LINK easyUnsetOpt_SSH_Public_KeyFile}
                  for details.
        #CURLOPT_SSLCERT
                  Client cert. See @{"easy:UnsetOpt_SSLCert" LINK easyUnsetOpt_SSLCert} for details.
        #CURLOPT_SSLCERT_BLOB
                  Client cert memory buffer. See @{"easy:UnsetOpt_SSLCert_Blob" LINK easyUnsetOpt_SSLCert_Blob} for
                  details. (V2.0)
        #CURLOPT_SSLCERTTYPE
                  Client cert type. See @{"easy:UnsetOpt_SSLCertType" LINK easyUnsetOpt_SSLCertType} for details.
        #CURLOPT_SSL_CIPHER_LIST
                  Ciphers to use. See @{"easy:UnsetOpt_SSL_Cipher_List" LINK easyUnsetOpt_SSL_Cipher_List} for details.
        #CURLOPT_SSL_EC_CURVES
                  Set key exchange curves. See @{"easy:UnsetOpt_SSL_EC_Curves" LINK easyUnsetOpt_SSL_EC_Curves} for
                  details. (V2.0)
        #CURLOPT_SSL_ENABLE_ALPN
                  Enable use of ALPN. See @{"easy:UnsetOpt_SSL_Enable_Alpn" LINK easyUnsetOpt_SSL_Enable_Alpn} for
                  details.
        #CURLOPT_SSL_ENABLE_NPN
                  Enable use of NPN. See @{"easy:UnsetOpt_SSL_Enable_Npn" LINK easyUnsetOpt_SSL_Enable_Npn} for
                  details.
        #CURLOPT_SSLENGINE
                  Use identifier with SSL engine. See @{"easy:UnsetOpt_SSLEngine" LINK easyUnsetOpt_SSLEngine}
                  for details.
        #CURLOPT_SSLENGINE_DEFAULT
                  Default SSL engine. See @{"easy:UnsetOpt_SSLEngine_Default" LINK easyUnsetOpt_SSLEngine_Default} for
                  details.
        #CURLOPT_SSL_FALSESTART
                  Enable TLS False Start. See @{"easy:UnsetOpt_SSL_FalseStart" LINK easyUnsetOpt_SSL_FalseStart} for
                  details.
        #CURLOPT_SSLKEY
                  Client key. See @{"easy:UnsetOpt_SSLKey" LINK easyUnsetOpt_SSLKey} for details.
        #CURLOPT_SSLKEY_BLOB
                  Client key memory buffer. See @{"easy:UnsetOpt_SSLKey_Blob" LINK easyUnsetOpt_SSLKey_Blob} for
                  details. (V2.0)
        #CURLOPT_SSLKEYTYPE
                  Client key type. See @{"easy:UnsetOpt_SSLKeyType" LINK easyUnsetOpt_SSLKeyType} for details.
        #CURLOPT_SSL_OPTIONS
                  Control SSL behavior. See @{"easy:UnsetOpt_SSL_Options" LINK easyUnsetOpt_SSL_Options} for
                  details.
        #CURLOPT_SSL_SESSIONID_CACHE
                  Disable SSL session-id cache. See
                  @{"easy:UnsetOpt_SSL_SessionID_Cache" LINK easyUnsetOpt_SSL_SessionID_Cache} for details.
        #CURLOPT_SSL_VERIFYHOST
                  Verify the host name in the SSL certificate. See
                  @{"easy:UnsetOpt_SSL_VerifyHost" LINK easyUnsetOpt_SSL_VerifyHost} for details.
        #CURLOPT_SSL_VERIFYPEER
                  Verify the SSL certificate. See @{"easy:UnsetOpt_SSL_VerifyPeer" LINK easyUnsetOpt_SSL_VerifyPeer}
                  for details.
        #CURLOPT_SSL_VERIFYSTATUS
                  Verify the SSL certificate's status. See
                  @{"easy:UnsetOpt_SSL_VerifyStatus" LINK easyUnsetOpt_SSL_VerifyStatus} for details.
        #CURLOPT_SSLVERSION
                  SSL version to use. See @{"easy:UnsetOpt_SSLVersion" LINK easyUnsetOpt_SSLVersion} for details.
        #CURLOPT_STREAM_DEPENDS
                  This HTTP/2 stream depends on another. See
                  @{"easy:UnsetOpt_Stream_Depends" LINK easyUnsetOpt_Stream_Depends} for details.
        #CURLOPT_STREAM_DEPENDS_E
                  This HTTP/2 stream depends on another exclusively. See
                  @{"easy:UnsetOpt_Stream_Depends_e" LINK easyUnsetOpt_Stream_Depends_e} for details.
        #CURLOPT_STREAM_WEIGHT
                  Set this HTTP/2 stream's weight. See
                  @{"easy:UnsetOpt_Stream_Weight" LINK easyUnsetOpt_Stream_Weight} for details.
        #CURLOPT_SUPPRESS_CONNECT_HEADERS
                  Suppress proxy CONNECT response headers from user callbacks.
                  See @{"easy:UnsetOpt_Suppress_Connect_Headers" LINK easyUnsetOpt_Suppress_Connect_Headers} for details.
        #CURLOPT_TCP_FASTOPEN
                  Enable TFO, TCP Fast Open. See @{"easy:UnsetOpt_TCP_FastOpen" LINK easyUnsetOpt_TCP_FastOpen} for
                  details.
        #CURLOPT_TCP_KEEPALIVE
                  Enable TCP keep-alive. See @{"easy:UnsetOpt_TCP_KeepAlive" LINK easyUnsetOpt_TCP_KeepAlive} for
                  details.
        #CURLOPT_TCP_KEEPIDLE
                  Idle time before sending keep-alive. See
                  @{"easy:UnsetOpt_TCP_KeepIdle" LINK easyUnsetOpt_TCP_KeepIdle} for details.
        #CURLOPT_TCP_KEEPINTVL
                  Interval between keep-alive probes. See
                  @{"easy:UnsetOpt_TCP_KeepIntvl" LINK easyUnsetOpt_TCP_KeepIntvl} for details.
        #CURLOPT_TCP_NODELAY
                  Disable the Nagle algorithm. See @{"easy:UnsetOpt_TCP_NoDelay" LINK easyUnsetOpt_TCP_NoDelay} for
                  details.
        #CURLOPT_TELNETOPTIONS
                  TELNET options. See @{"easy:UnsetOpt_TelnetOptions" LINK easyUnsetOpt_TelnetOptions} for details.
        #CURLOPT_TFTP_BLKSIZE
                  TFTP block size. See @{"easy:UnsetOpt_TFTP_BlkSize" LINK easyUnsetOpt_TFTP_BlkSize} for details.
        #CURLOPT_TFTP_NO_OPTIONS
                  Do not send TFTP options requests. See
                  @{"easy:UnsetOpt_TFTP_No_Options" LINK easyUnsetOpt_TFTP_No_Options} for details.
        #CURLOPT_TIMECONDITION
                  Make a time conditional request. See
                  @{"easy:UnsetOpt_TimeCondition" LINK easyUnsetOpt_TimeCondition} for details.
        #CURLOPT_TIMEOUT
                  Timeout for the entire request. See @{"easy:UnsetOpt_Timeout" LINK easyUnsetOpt_Timeout} for
                  details.
        #CURLOPT_TIMEOUT_MS
                  Millisecond timeout for the entire request. See
                  @{"easy:UnsetOpt_Timeout_MS" LINK easyUnsetOpt_Timeout_MS} for details.
        #CURLOPT_TIMEVALUE
                  Time value for the time conditional request. See
                  @{"easy:UnsetOpt_TimeValue" LINK easyUnsetOpt_TimeValue} for details.
        #CURLOPT_TIMEVALUE_LARGE
                  Time value for the time conditional request. See
                  @{"easy:UnsetOpt_TimeValue_Large" LINK easyUnsetOpt_TimeValue_Large} for details. (V2.0)
        #CURLOPT_TLS13_CIPHERS
                  Ciphers suites to use for TLS 1.3. See
                  @{"easy:UnsetOpt_TLS13_Ciphers" LINK easyUnsetOpt_TLS13_Ciphers} for details. (V2.0)
        #CURLOPT_TLSAUTH_PASSWORD
                  TLS authentication password. See
                  @{"easy:UnsetOpt_TLSAuth_Password" LINK easyUnsetOpt_TLSAuth_Password} for details.
        #CURLOPT_TLSAUTH_TYPE
                  TLS authentication methods. See @{"easy:UnsetOpt_TLSAuth_Type" LINK easyUnsetOpt_TLSAuth_Type} for
                  details.
        #CURLOPT_TLSAUTH_USERNAME
                  TLS authentication user name. See
                  @{"easy:UnsetOpt_TLSAuth_UserName" LINK easyUnsetOpt_TLSAuth_UserName} for details.
        #CURLOPT_TRAILERFUNCTION
                  Set callback for sending trailing headers. See
                  @{"easy:UnsetOpt_TrailerFunction" LINK easyUnsetOpt_TrailerFunction} for details. (V2.0)
        #CURLOPT_TRANSFER_ENCODING
                  Request Transfer-Encoding. See @{"easy:UnsetOpt_Transfer_Encoding" LINK easyUnsetOpt_Transfer_Encoding}
                  for details.
        #CURLOPT_TRANSFERTEXT
                  Use text transfer. See @{"easy:UnsetOpt_TransferText" LINK easyUnsetOpt_TransferText} for details.
        #CURLOPT_UNIX_SOCKET_PATH
                  Path to a Unix domain socket. See
                  @{"easy:UnsetOpt_Unix_Socket_Path" LINK easyUnsetOpt_Unix_Socket_Path} for details.
        #CURLOPT_UNRESTRICTED_AUTH
                  Do not restrict authentication to original host. See
                  @{"easy:UnsetOpt_Unrestricted_Auth" LINK easyUnsetOpt_Unrestricted_Auth} for details.
        #CURLOPT_UPKEEP_INTERVAL_MS
                  Sets the interval at which connection upkeep are performed.
                  See @{"easy:UnsetOpt_Upkeep_Interval_MS" LINK easyUnsetOpt_Upkeep_Interval_MS} for details. (V2.0)
        #CURLOPT_UPLOAD
                  Upload data. See @{"easy:UnsetOpt_Upload" LINK easyUnsetOpt_Upload} for details.
        #CURLOPT_UPLOAD_BUFFERSIZE
                  Set upload buffer size. See @{"easy:UnsetOpt_Upload_Buffersize" LINK easyUnsetOpt_Upload_Buffersize}
                  for details. (V2.0)
        #CURLOPT_URL
                  URL to work on. See @{"easy:UnsetOpt_URL" LINK easyUnsetOpt_URL} for details.
        #CURLOPT_USE_SSL
                  Use TLS/SSL. See @{"easy:UnsetOpt_Use_SSL" LINK easyUnsetOpt_Use_SSL} for details.
        #CURLOPT_USERAGENT
                  User-Agent: header. See @{"easy:UnsetOpt_UserAgent" LINK easyUnsetOpt_UserAgent} for details.
        #CURLOPT_USERNAME
                  User name. See @{"easy:UnsetOpt_UserName" LINK easyUnsetOpt_UserName} for details.
        #CURLOPT_USERPWD
                  User name and password. See @{"easy:UnsetOpt_UserPwd" LINK easyUnsetOpt_UserPwd} for details.
        #CURLOPT_VERBOSE
                  Display verbose information. See @{"easy:UnsetOpt_Verbose" LINK easyUnsetOpt_Verbose} for
                  details.
        #CURLOPT_WILDCARDMATCH
                  Transfer multiple files according to a file name pattern. See
                  @{"easy:UnsetOpt_WildcardMatch" LINK easyUnsetOpt_WildcardMatch} for details.
        #CURLOPT_WRITEFUNCTION
                  Callback for writing data. See @{"easy:UnsetOpt_WriteFunction" LINK easyUnsetOpt_WriteFunction} for
                  details.
        #CURLOPT_WS_OPTIONS
                  Set WebSocket options. See @{"easy:UnsetOpt_WS_Options" LINK easyUnsetOpt_WS_Options} for
                  details. (V2.0)
        #CURLOPT_XOAUTH2_BEARER
                  OAuth2 bearer token. See @{"easy:UnsetOpt_XOAuth2_Bearer" LINK easyUnsetOpt_XOAuth2_Bearer} for
                  details.

   @{b}INPUTS@{ub}
        option    option type to unset

   @{b}EXAMPLE@{ub}
        e:UnsetOpt(#CURLOPT_URL)
        e:UnsetOpt(#CURLOPT_VERBOSE)
        e:UnsetOpt(#CURLOPT_FOLLOWLOCATION)

        The code above unsets some options on an easy handle, i.e. it resets
        those options to their default values.

@ENDNODE

@NODE easyUnsetOpt_Abstract_Unix_Socket "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Abstract_Unix_Socket -- get an abstract Unix domain socket

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Abstract_Unix_Socket()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Abstract_Unix_Socket" LINK easySetOpt_Abstract_Unix_Socket} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Accept_Encoding "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Accept_Encoding -- enables automatic decompression of HTTP downloads

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Accept_Encoding()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Accept_Encoding" LINK easySetOpt_Accept_Encoding} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_AcceptTimeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_AcceptTimeout_MS -- timeout waiting for FTP server to connect back

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_AcceptTimeout_MS()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_AcceptTimeout_MS" LINK easySetOpt_AcceptTimeout_MS} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Address_Scope "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Address_Scope -- get scope for local IPv6 addresses

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Address_Scope()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Address_Scope" LINK easySetOpt_Address_Scope} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_AltSvc "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_AltSvc -- alt-svc cache file name (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_AltSvc()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_AltSvc" LINK easySetOpt_AltSvc} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_AltSvc_Ctrl "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_AltSvc_Ctrl -- control alt-svc behavior (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_AltSvc_Ctrl()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_AltSvc_Ctrl" LINK easySetOpt_AltSvc_Ctrl} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Append "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Append -- enable appending to the remote file

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Append()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Append" LINK easySetOpt_Append} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_AutoReferer "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_AutoReferer -- automatically update the referer header

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_AutoReferer()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_AutoReferer" LINK easySetOpt_AutoReferer} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_AWS_SigV4 "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_AWS_SigV4 -- V4 signature (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_AWS_SigV4()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_AWS_SigV4" LINK easySetOpt_AWS_SigV4} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_BufferSize "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_BufferSize -- get preferred receive buffer size

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_BufferSize()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_BufferSize" LINK easySetOpt_BufferSize} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CA_Cache_Timeout "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CA_Cache_Timeout -- life-time for cached certificate stores (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CA_Cache_Timeout()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CA_Cache_Timeout" LINK easySetOpt_CA_Cache_Timeout} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CAInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CAInfo -- path to Certificate Authority (CA) bundle

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CAInfo()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CAInfo" LINK easySetOpt_CAInfo} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CAInfo_Blob "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CAInfo_Blob -- Certificate Authority (CA) bundle in PEM format (V2.0)

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CAInfo_Blob()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CAInfo_Blob" LINK easySetOpt_CAInfo_Blob} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CAPath "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CAPath -- specify directory holding CA certificates

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CAPath()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CAPath" LINK easySetOpt_CAPath} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CertInfo "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CertInfo -- request SSL certificate information

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CertInfo()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CertInfo" LINK easySetOpt_CertInfo} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Chunk_BGN_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Chunk_BGN_Function -- callback before a transfer with FTP wildcardmatch

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Chunk_BGN_Function()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Chunk_BGN_Function" LINK easySetOpt_Chunk_BGN_Function} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Chunk_End_Function "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Chunk_End_Function -- callback after a transfer with FTP wildcardmatch

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Chunk_End_Function()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Chunk_End_Function" LINK easySetOpt_Chunk_End_Function} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Connect_Only "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Connect_Only -- stop when connected to target server

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Connect_Only()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Connect_Only" LINK easySetOpt_Connect_Only} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_ConnectTimeout "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_ConnectTimeout -- timeout for the connect phase

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_ConnectTimeout()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_ConnectTimeout" LINK easySetOpt_ConnectTimeout} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_ConnectTimeout_MS "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_ConnectTimeout_MS -- timeout for the connect phase

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_ConnectTimeout_MS()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_ConnectTimeout_MS" LINK easySetOpt_ConnectTimeout_MS} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Connect_To "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Connect_To -- Connect to a specific host and port instead of the URL's host and port

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Connect_To()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Connect_To" LINK easySetOpt_Connect_To} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_Cookie "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_Cookie -- get contents of HTTP Cookie header

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_Cookie()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_Cookie" LINK easySetOpt_Cookie} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CookieFile "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CookieFile -- file name to read cookies from

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CookieFile()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CookieFile" LINK easySetOpt_CookieFile} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CookieJar "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CookieJar -- file name to store cookies to

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CookieJar()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CookieJar" LINK easySetOpt_CookieJar} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CookieList "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CookieList -- add to or manipulate cookies held in memory

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CookieList()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CookieList" LINK easySetOpt_CookieList} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CookieSession "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CookieSession -- start a new cookie session

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CookieSession()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CookieSession" LINK easySetOpt_CookieSession} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CRLF "hURL Guide"

   @{b}NAME@{ub}
        easy:UnsetOpt_CRLF -- enable/disable CRLF conversion

   @{b}SYNOPSIS@{ub}
        easy:UnsetOpt_CRLF()

   @{b}FUNCTION@{ub}
        See @{"easy:SetOpt_CRLF" LINK easySetOpt_CRLF} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE easyUnsetOpt_CRLFile "hURL