<html>
<!-- generated from muiroyale.meta by MetaDoc 1.7 (c) by Andreas Falkenhahn -->
<head>
<title>Automatic layout engine</title>
<meta name="author" content="Andreas Falkenhahn">
<meta name="generator" content="MetaDoc 1.7">
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<style type="text/css">
<!--
body {font-family: sans-serif;}
ul.toc {list-style: none; margin-left: 20px; padding-left: 0px;}
dt.autodoc {font-variant: small-caps; font-size: larger; margin-top: 10px; margin-bottom: 10px; padding-left: 0.2em; padding-top: 0.2em; padding-bottom: 0.2em;
	background-color: #bae1ff; border-width: 1px; border-color: #3baaff; border-style: solid;}
dt.codelist {margin-bottom: 0.2em;}
h2.heading {background-color: #bae1ff; font-family: Arial; padding-top: 0.4em; padding-bottom: 0.4em;}
code {background-color: #f2f2f2; padding: 2px 4px; font-weight: bold;}
pre {background-color: #f2f2f2; border: 1px solid #ddd; padding: 0.3em;}
		
-->
</style>
</head>
<body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#0000FF" alink="#0000FF">
<h2 class="heading">3.3 Automatic layout engine</h2>

<p>
One of the most important and powerful features of MUI is its dynamic
layout engine. As opposed to other available user interface tools, the
programmer of a MUI application doesn't have to care about gadget sizes
and positions. MUI handles all necessary calculations automatically,
making every program completely screen, window size and font sensitive
without the need for the slightest programmer interaction.

<p>
From a programmer's point of view, all you have to do is to define
some rectangle areas that shall contain the objects you want to see in
your window. Objects of group class are used for this purpose. These
objects are not visible themselves, but instead tell their children
whether they should appear horizontally or vertically.

<p>
For automatic and dynamic layout, it's important that every single
object knows about its minimum and maximum dimensions. Before opening a
window, MUI asks all its gadgets about these values and uses them to
calculate the window's extreme sizes.

<p>
Once the window is opened, layout takes place. Starting with the
current window size, the root object and all its children are placed
depending on the type of their father's group and on some additional
attributes.  The algorithm ensures that objects will never become
smaller as their minimum or larger as their maximum size.

<p>
The important thing with this mechanism is that object placement
depends on window size. This allows very easy implementation of a
sizing gadget: whenever the user resizes a window, MUI simply starts a
new layout process and recalculates object positions and sizes
automatically. No programmer interaction is needed.

<p>
As a consequence, you should never explicitly define fixed sizes
for your windows and your windows' gadgets. Instead, MUI calculates
these automatically depending on the current user preferences. Although
it is possible to use fixed sizes for your window using <a href="WindowWidth.html">Window.Width</a>
and <a href="WindowHeight.html">Window.Height</a> it is against MUI's philosophy to actually
use these. Also, the gadget counterparts <a href="AreaFixWidth.html">Area.FixWidth</a> and
<a href="AreaFixHeight.html">Area.FixHeight</a> should only be used if you have a very good
reason for doing so. Normally, you should leave all layout calculation
as well as gadget and window size determination to MUI's automatic layout
engine which will make sure to give the user the ideal visual representation
of your GUI layout.

<p>
<hr>
<font size=-2><a href="LayoutEngine_.html" target="_top">Show TOC</a></font>
</body>
</html>