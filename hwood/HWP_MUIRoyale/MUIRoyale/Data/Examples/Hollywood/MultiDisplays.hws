/****************************************************************
**                                                             **
** Name:        MultiDisplays (MUI)                            **
** Author:      Andreas Falkenhahn, Effect code by Spectre     **
** Version:     1.1                                            **
** Date:        07.08.12                                       **
** Interpreter: Hollywood 5.2                                  **
** Licence:     Sample program for MUI Royale                  **
** Function:    Demonstrates multiple displays using Hollywood **
**              and MUI Royale                                 **
**                                                             **
** Notes:       Effects based on code by Spectre               **
**                                                             **
** History:                                                    **
**                                                             **
** 1.0: (29.12.09)                                             **
**                                                             **
** - initial release                                           **
**                                                             **
****************************************************************/

/*
** Important! Check if the used Hollywood version is at least
** version 5.2!
*/
@VERSION 5,2


/*
** This script requires the MUI Royale plugin
*/
@REQUIRE "MUIRoyale"


/*
** load some graphics data
*/
@BGPIC 2, "MultiDisplays/bg.png"
@ANIM 1, "MultiDisplays/klappe.jpg", {Width = 100, Height = 118, Frames = 24}
@SPRITE 1, "MultiDisplays/balls.png", {Width = 16, Height = 16, FPR = 1, Frames = 1, Transparency = 0}
@SPRITE 25, "MultiDisplays/balls.png", {X = 16, Width = 16, Height = 16, FPR = 1, Frames = 1, Transparency = 0}


/*
** set up our four displays; note that they will all be hidden because we want to
** position them according to the current screen size
*/
@DISPLAY 1, {Width = 360, Height = 256, Hidden = True, Title = "Sprite display"}
@DISPLAY 2, {Width = 360, Height = 256, Hidden = True, Title = "Double buffered display"}
@DISPLAY 3, {Width = 360, Height = 256, Hidden = True, Layers = True, Title = "Layered display"}
@DISPLAY 4, {BGPic = 2, Hidden = True, Title = "Normal display"}


/* compute sine & cosine table */
Function p_MakeSinTable()

	Local i = 0
	
	costab = {}
	sintab = {}
	
	For Local k = 0 To 1 Step 0.0027777	
		costab[i] = Cos(#PI * 2 * k)
		sintab[i] = Sin(#PI * 2 * k)
		i = i + 1
	Next
	
EndFunction

/* ball effect */
Function p_InitFirstEffect(e)

	If e.init = False
	
		Local n = 0
	
		e.CX = {}
		e.PX1 = {}
		e.PY1 = {}
		e.PX2 = {}
		e.PY2 = {}	
		
		; we'll cycle through different parameters in this effect	
		e.ptab = {
			{XI = 7, YI = 10, XI2 = 10, YI2 = 7, X2 = 90, Y2 = 0, X = 50, Y = 0, GAP = 1, NLINES = 8},
			{XI = 12, YI = 15, XI2 = 9, YI2 = 12, X2 = 0, Y2 = 0, X = 50, Y = 0, GAP = 10, NLINES = 14},			
			{XI = 10, YI = 1, XI2 = 3, YI2 = 8, X2 = 0, Y2 = 0, X = 0, Y = 0, GAP = 50, NLINES = 20},
			{XI = 15, YI = 12, XI2 = 12, YI2 = 9, X2 = 100, Y2 = 0, X = 0, Y = 0, GAP = 56, NLINES = 24},
			{XI = 10, YI = 13, XI2 = 10, YI2 = 7, X2 = 90, Y2 = 0, X = 50, Y = 0, GAP = 10, NLINES = 20},
			{XI = 10, YI = 8, XI2 = 15, YI2 = 10, X2 = 0, Y2 = 100, X = 20, Y = 0, GAP = 3, NLINES = 14}
			}

		; setup cosine table
		For Local tm = 1 To 2

			If tm = 1 Then n = 0
			If tm = 2 Then n = 360

			For Local i = 0 To 360
				e.CX[n] = costab[i] * 81
				n = n + 1
			Next
		Next	
		
		; make a lot of sprite links for our balls
		For Local k = 0 To 22
			CreateSprite(k + 2, #SPRITE, 1)
			CreateSprite(k + 26, #SPRITE, 25)
		Next		
		
		e.c = 0
		e.T = 0
		e.init = True
	EndIf
	
	e.p = e.ptab[e.c]
	e.c = e.c + 1
	If e.c = 5 Then e.c = 0
	
	; precalculate offsets	
	For Local I=1 To e.p.NLINES
		e.PX1[I] = I * 8 - 8
  		e.PY1[I] = I * 8 - 8
  		e.PX2[I] = I * 8 + e.p.GAP
  		e.PY2[I] = I * 8 + e.p.GAP
	Next
	
EndFunction

/* draw one frame of effect #1 */
Function p_FirstEffect(e)

	Local p = e.p
	
	p.X = p.X + p.XI
	If p.X > 359 Then p.X = 0
	
  	p.Y = p.Y + p.YI
  	If p.Y > 359 Then p.Y = 0
  	
	p.X2 = p.X2 + p.XI2
	If p.X2 > 359 Then p.X2 = 0

	p.Y2 = p.Y2 + p.YI2
	If p.Y2 > 359 Then p.Y2 = 0

	; draw balls!
	For Local I = 1 To p.NLINES
		DisplaySprite(I, e.CX[p.X + e.PX1[I]] + 160, e.CX[p.Y + e.PY1[I]] + 105)
		DisplaySprite(I + 24, e.CX[p.X2 + e.PX2[I]] + 160, e.CX[p.Y2 + e.PY2[I]] + 105)
	Next
	
	; change effect parameters after every 150 frames
	e.T = e.T + 1
	If e.T = 150
		p_InitFirstEffect(e)
		e.T = 0
		RemoveSprites
	EndIf	
		
EndFunction

/* init line effect */
Function p_InitSecondEffect(e)

	If e.init = False
	
		Local n = 0
	
		; line effect uses a double-buffered display because we are drawing a lot
		SelectDisplay(2, True)
		BeginDoubleBuffer
		
		e.CX = {}
		e.PX1 = {}
		e.PY1 = {}
		e.PX2 = {}
		e.PY2 = {}	
		
		; different parameters for our line effect
		; we'll change the look of our effect every 150 frames	
		e.ptab = {
			{XI = 7, YI = 10, XI2 = 10, YI2 = 7, X2 = 90, Y2 = 0, X = 50, Y = 0},
			{XI = 12, YI = 9, XI2 = 9, YI2 = 12, X2 = 0, Y2 = 0, X = 50, Y = 0},
			{XI = 12, YI = 9, XI2 = 9, YI2 = 12, X2 = 245, Y2 = 60, X = 60, Y = 0},
			{XI = 5, YI = 10, XI2 = 10, YI2 = 10, X2 = 100, Y2 = 0, X = 0, Y = 0} }

		; setup sine table
		For Local tm = 1 To 2

			If tm = 1 Then n = 0
			If tm = 2 Then n = 360

			For Local i = 0 To 360
				e.CX[n] = costab[i] * 125
				n = n + 1
			Next
		Next	
		
		; precalculate some offsets
		For Local I = 1 To 75
	  		e.PX1[I] = I * 4 - 4
			e.PY1[I] = I * 4 - 4
			e.PX2[I] = I * 4 + 56
			e.PY2[I] = I * 4 + 56
		Next
				
		e.c = 0
		e.T = 0
		e.init = True
	EndIf
	
	e.p = e.ptab[e.c]
	e.c = e.c + 1
	If e.c = 4 Then e.c = 0
	
EndFunction

/* draw one frame of second effect */
Function p_SecondEffect(e)

	Local p = e.p
	
	; flip backbuffer into view
	Flip
	
	; clear backbuffer
	Cls
	
	p.X = p.X + p.XI
	If p.X > 359 Then p.X = 0
	
  	p.Y = p.Y + p.YI
  	If p.Y > 359 Then p.Y = 0
  	
	p.X2 = p.X2 + p.XI2
	If p.X2 > 359 Then p.X2 = 0

	p.Y2 = p.Y2 + p.YI2
	If p.Y2 > 359 Then p.Y2 = 0	
	
	; draw a lot of lines!
	For Local I=1 To 75
		Line(e.CX[p.X + e.PX1[I]] + 160, e.CX[p.Y + e.PY1[I]] + 128, e.CX[p.X2 + e.PX2[I]] + 160, e.CX[p.Y2 + e.PY2[I]] + 128, #RED)
	Next

	; we change the look of our effect after every frame	
	e.T = e.T + 1
	If e.T = 150
		p_InitSecondEffect(e)
		e.T = 0
	EndIf	
		
EndFunction

/* init waving flag */
Function p_InitThirdEffect(e)

	If e.init = False
	
		Local n = 0
		
		; we'll draw a German flag
		Local cols = {#BLACK, #RED, $E4CA42}
	
		e.c = {}
		e.s = {}
		
		; setup sine tables
		For Local i = 0 To 360
			e.c[i] = costab[i] * 8
			e.s[i] = sintab[i] *10
		Next
		
		; we use a brush that is twice the width of the display so that we can
		; scroll it smoothly
		e.brush = CreateBrush(Nil, 720, 256)
		e.tmpbr = CreateBrush(Nil, 360, 256, $636363)
		SelectBrush(e.tmpbr)
		
		; draw sine flag
		For Local num = 1 To 23
			
			Local color = cols[num \ 8]
		
			For Local i = 0 To 360 Step 10
				Plot(e.s[i] + i, e.c[i] + num * 10 - 10 + 10, color)
				Plot(e.s[i] + i+1, e.c[i] + num * 10 - 10 + 10, color)
				Plot(e.s[i] + i, e.c[i] + num * 10 - 10 + 10 + 1, color)
			Next
		Next
		EndSelect
		
		; duplicate flag because we want to scroll it
		SelectBrush(e.brush)
		DisplayBrush(e.tmpbr, 0, 0)
		DisplayBrush(e.tmpbr, 359, 0)
		EndSelect
		
		; can free this now
		FreeBrush(e.tmpbr)
		
		e.sc = 0			
		e.init = True
		
		SelectDisplay(3, False)
		DisplayBrush(e.brush, 0, 0)
	EndIf

EndFunction

/* draw one frame of third effect */
Function p_ThirdEffect(e)
	
	; you can see that this effect is actually very easy to achieve!
	
	e.sc = e.sc + 10
	If e.sc = 360 Then e.sc = 0

	ShowLayer(1, -e.sc, 0)
	
EndFunction

/* our main loop that gets called 25 times per second */
Function p_MainLoop(msg)

	; draw effect 1 to first display
	SelectDisplay(1, True)
	p_FirstEffect(msg.userdata.first)
	
	; draw effect 2 to second display	
	SelectDisplay(2, True)
	p_SecondEffect(msg.userdata.second)
	
	; draw effect 3 to third display	
	SelectDisplay(3, True)
	p_ThirdEffect(msg.userdata.third)
	
	; draw effect 4 to fourth display	
	SelectDisplay(4, True)
	DisplayAnimFrame(1, #CENTER, #CENTER - 25, frame)
	frame = frame + 1
	If frame = 25 Then frame = 1

EndFunction

/*
** Handles all incoming events
*/
Function p_EventFunc(msg)

	Switch msg.action
	Case "MUIRoyale":
		Switch msg.attribute
		Case "CloseRequest":
			End
		Case "Pressed":
			End
		Case "Active":
			For Local k = 1 To 4 Do mui.Set("hwmcc" .. k, "display", IIf(msg.triggervalue = 0, k, msg.triggervalue))
 		EndSwitch

	Case "HideWindow":
		mui.Set("app", "iconified", True)

	Case "ShowWindow":
		mui.Set("app", "iconified", False)
	EndSwitch

EndFunction

userdata = {}
userdata.first = {init = False}
userdata.second = {init = False}
userdata.third = {init = False}

; init sine table
p_MakeSinTable()

; call effect initialization routines
p_InitFirstEffect(userdata.first)			
p_InitSecondEffect(userdata.second)
p_InitThirdEffect(userdata.third)

; dynamically create MUI GUI from an external *.xml file definition
mui.CreateGui(FileToString("MultiDisplays.xml"))

; call p_MainLoop() 25 times per second
SetInterval(1, p_MainLoop, 1000\25, userdata)

; listen to these events!
InstallEventHandler({MUIRoyale = p_EventFunc, HideWindow = p_EventFunc, ShowWindow = p_EventFunc})

frame = 1

; and go!
Repeat
	WaitEvent
Forever	
