@DATABASE RebelSDL.guide
@AUTHOR "Andreas Falkenhahn"
@REMARK "Automatically generated from rebelsdl.meta by MetaDoc 1.9 (c) by Airsoft Softwair"
@$VER: RebelSDL.guide 1.1 (27.09.2020)
@INDEX Reference
@HELP Reference

@NODE Main "RebelSDL Guide"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

                                         -= @{B}@{FG highlight}R E B E L  S D L@{FG text}@{UB} =-

                                           "I'm Just a Rebel"

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

 I. General information
 @{" Introduction                    " LINK Introduction}     What is RebelSDL?
 @{" Terms and conditions            " LINK License}     License information
 @{" Requirements                    " LINK Requirements}     What you need to work with it
 @{" Installation                    " LINK Installation}     How to install RebelSDL

 II. About RebelSDL
 @{" Credits                         " LINK Credits}     Who was involved in this project?
 @{" F.A.Q.                          " LINK FAQ}     Frequently asked questions
 @{" Known issues                    " LINK KnownIssues}     List of things that can cause trouble
 @{" Future                          " LINK ToDo}     What is planned for the future?
 @{" History                         " LINK History}     What happened so far?

 III. Usage
 @{" Activating RebelSDL             " LINK ActivatePlugin}     How to use RebelSDL from your script
 @{" Using a hardware doublebuffer   " LINK HardwareDB}     All scripts need to be double-buffered
 @{" Drawing graphics                " LINK HowToDraw}     The basics on OpenGL drawing
 @{" Using hardware brushes          " LINK HardwareBrushes}     Benefit from hardware-accelerated blitting
 @{" Offscreen rendering             " LINK OffscreenRender}     Accelerated drawing to hardware brushes
 @{" Using the SDL renderer          " LINK SDLRender}     Important information for advanced users
 @{" Joysticks and game controllers  " LINK JoystickNote}     Querying game controllers with RebelSDL
 @{" Increasing execution speed      " LINK MoreSpeed}     Ideas for making your script faster
 @{" RebelSDL as a helper plugin     " LINK SDLGlue}     Using RebelSDL as a patch for Hollywood deficits
 @{" Raspberry Pi peculiarities      " LINK RaspberryPi}     Important information for using RebelSDL on the Pi

 IV. Examples
 @{" RebelSDL examples               " LINK Examples}     Description of included examples

 V. Reference
 @{" Joystick reference              " LINK JoystickFunctions}     List of supported joystick calls
 @{" Keyboard reference              " LINK KeyboardFunctions}     List of supported keyboard calls
 @{" Renderer reference              " LINK RendererFunctions}     List of supported renderer calls
 @{" System reference                " LINK SystemFunctions}     List of supported system calls
 @{" Window reference                " LINK WindowFunctions}     List of supported window calls

 @{" Index                           " LINK Reference}     Quickly find what you are looking for

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 RebelSDL is (C) Copyright © 2014-2020 Andreas Falkenhahn                    All rights reserved
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

@ENDNODE
@NODE Introduction "RebelSDL Guide"
@{b}Introduction@{ub}

    RebelSDL is a plugin for Hollywood that allows you to use SDL (Simple
    DirectMedia Layer) from Hollywood. This makes it possible to write scripts
    that utilize the host system's graphics hardware to create high-performance,
    butter-smooth 2D animation that is produced completely in hardware by the
    GPU of your graphics board. This leads to a huge performance boost over the
    classic Hollywood graphics API which is mostly implemented in software for
    maximum portability and compatibility. Especially systems with slower CPUs
    (like the Raspberry Pi) will benefit greatly from hardware-accelerated
    drawing, scaling, and transformation offered by SDL.

    SDL is a cross-platform development library designed to provide low level
    access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL
    and Direct3D. It is used by video playback software, emulators, and popular
    games. More information about SDL can be obtained from http://www.libsdl.org.
    You can find good tutorials about learning SDL all over the web.

    RebelSDL transparently replaces Hollywood's inbuilt display handler with its
    own display handler managed by SDL. Whenever RebelSDL is activated,
    Hollywood displays are automatically mapped to SDL windows and hardware
    brushes are mapped directly to SDL textures so that they can be drawn,
    scaled, and transformed in an extremely quick way on all supported systems.
    This is especially useful on Windows, macOS, and Linux because Hollywood
    doesn't support hardware double buffers and hardware brushes on these
    platforms by default. With RebelSDL, however, hardware double buffers and
    hardware brushes can be used on these platforms now too. So RebelSDL can
    also act as a helper plugin here which adds this functionality to Hollywood
    without having you write a single line of SDL code to utilize it!

    On top of that, RebelSDL offers wrapper functions for some useful commands
    of the SDL API, for example RebelSDL allows you to call SDL's joystick and
    game controller functions which are much more flexible than Hollywood's
    inbuilt joystick library. RebelSDL also allows you to access Hollywood
    hardware brushes as SDL textures and modify their properties via some
    dedicated SDL calls exposed by RebelSDL.

    Finally, RebelSDL also replaces Hollywood's inbuilt audio driver with the
    audio driver offered by SDL. In contrast to the graphics driver SDL's audio
    driver probably doesn't have any advantage over Hollywood's inbuilt audio
    driver but by using it RebelSDL will make your program into a complete SDL
    application which doesn't only use SDL for graphics output but also for
    audio output.

    RebelSDL utilizes the new display adapter plugin interface introduced with
    Hollywood 6.0. Thus, the plugin will not work with any older versions of
    Hollywood. It requires at least Hollywood 6.0. Whenever RebelSDL is
    activated, all graphics and audio output will automatically be routed
    through SDL. To benefit from hardware-accelered drawing, however, Hollywood
    scripts have to follow some rules as described in this manual.

    RebelSDL comes with extensive documentation in various formats like PDF,
    HTML, AmigaGuide, and CHM that contains information about how to use this
    plugin. On top of that, many example scripts are included in the
    distribution archive to get you started really quickly.

    All of this makes RebelSDL the ultimate scripting experience for all you SDL
    rebels by combining the best of both worlds into one powerful plugin:
    Hollywood's extensive and convenient multimedia function set and SDL's raw
    graphics power!

@ENDNODE

@NODE License "RebelSDL Guide"
@{b}Terms and conditions@{ub}

    RebelSDL is © Copyright 2014-2020 by Andreas Falkenhahn (in the following
    referred to as "the author"). All rights reserved.

    The program is provided "as-is" and the author cannot be made responsible of
    any possible harm done by it. You are using this program absolutely at your
    own risk. No warranties are implied or given by the author.

    This plugin may be freely distributed as long as the following three
    conditions are met:

    1. No modifications must be made to the plugin.
    2. It is not allowed to sell this plugin.
    3. If you want to put this plugin on a coverdisc, you need to ask for
       permission first.

    This software uses Simple DirectMedia Layer (SDL) Copyright (C) 1997-2016
    Sam Lantinga. See @{"SDL license" LINK LicenseSDL} for details.

    This documentation is based in part on the SDL documentation by various
    authors which is available here: http://wiki.libsdl.org/FrontPage

    All trademarks are the property of their respective owners.

    DISCLAIMER: THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
    APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDER
    AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
    THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY REDISTRIBUTE THE PROGRAM AS
    PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL,
    SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
    INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR
    DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
    OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

@ENDNODE

@NODE Requirements "RebelSDL Guide"
@{b}Requirements@{ub}

    - Hollywood 6.0 or better
    - Windows: requires at least Windows 2000
    - macOS: requires at least 10.5 on PowerPC or 10.6 on Intel Macs
    - Raspberry Pi: requires at least a Raspberry Pi 2 and Raspbian Jessie
    - AmigaOS 4: requires SDL 2.0.12 (July 2020 or newer)
    - MorphOS: requires at least MorphOS 3.8

@ENDNODE

@NODE Installation "RebelSDL Guide"
@{b}Installation@{ub}

    Installing RebelSDL is straightforward and simple: Just copy the file
    rebelsdl.hwp for the platform to Hollywood's plugins directory. On all
    systems except on AmigaOS and compatibles, plugins must be stored in a
    directory named Plugins that is in the same directory as the main Hollywood
    program. On AmigaOS and compatible systems, plugins must be installed to
    LIBS:Hollywood instead. On macOS, the Plugins directory must be inside the
    Resources directory of the application bundle, i.e. inside the
    HollywoodInterpreter.app/Contents/Resources directory. Note that
    HollywoodInterpreter.app is stored inside the Hollywood.app application
    bundle itself, namely in Hollywood.app/Contents/Resources.

    Afterwards merge the contents of the Examples folder with the Examples
    folder that is part of your Hollywood installation. All RebelSDL examples
    will then appear in Hollywood's GUI and you can launch and view them
    conveniently from the Hollywood GUI or IDE.

    On Windows you should also copy the file RebelSDL.chm to the Docs directory
    of your Hollywood installation. Then you will be able to get online help by
    pressing F1 when the cursor is over a RebelSDL function in the Hollywood
    IDE.

    On Linux and macOS copy the RebelSDL directory that is inside the Docs
    directory of the RebelSDL distribution archive to the Docs directory of your
    Hollywood installation. Note that on macOS the Docs directory is within the
    Hollywood.app application bundle, i.e. in
    Hollywood.app/Contents/Resources/Docs.

@ENDNODE

@NODE Credits "RebelSDL Guide"
@{b}Credits@{ub}

    RebelSDL was written by Andreas Falkenhahn. Work on this project was started
    in Summer 2014 as a proof-of-concept demonstration of Hollywood 6.0's
    powerful new display adapter and audio adapter API which allows plugins to
    take over Hollywood's entire display and audio handler and replace it with a
    custom driver. Writing RebelSDL also helped to conceptualize Hollywood's
    plugin interfaces to make them as flexible as possible for new backends.
    That is why RebelSDL is also a test case for most of the features offered by
    the Hollywood SDK. RebelSDL has many features that can be optionally enabled
    to test certain functionalities of the Hollywood SDK. See @{"Activating" LINK ActivatePlugin}
    @{"RebelSDL" LINK ActivatePlugin} for details. Later RebelSDL was expanded to allow access to other
    SDL functionality like joystick and game controller support. Finally, some
    wrapper functions were added to allow scripts to access Hollywood hardware
    brushes as SDL textures.

    If you need to contact me, you can either send an e-mail to
    andreas\@airsoftsoftwair.de or use the contact form on
    http://www.hollywood-mal.com.

@ENDNODE

@NODE FAQ "RebelSDL Guide"
@{b}Frequently asked questions@{ub}

    This section covers some frequently asked questions. Please read them first
    before asking on the mailing list or forum because your problem might have
    been covered here.

    @{b}Q: @{ub}@{b}Why @{ub}@{b}is @{ub}@{b}RebelSDL @{ub}@{b}so @{ub}@{b}slow @{ub}@{b}on @{ub}@{b}my @{ub}@{b}Raspberry @{ub}@{b}Pi?@{ub}

    A: First make sure that you're using a 2017 or better version of Raspbian
    Jessie or Stretch. Then make sure to enable the experimental vc4 KMS/DRM
    OpenGL driver for X11 in "raspi-config". See @{"Raspberry Pi peculiarities" LINK RaspberryPi} for
    details. Note that if you're still on a Raspberry Pi 1 there is nothing you
    can do to get hardware acceleration from RebelSDL. The Raspberry Pi 1 is
    currently unsupported by RebelSDL. You need at least a Raspberry Pi 2.


    @{b}Q: @{ub}@{b}By @{ub}@{b}default, @{ub}@{b}RebelSDL @{ub}@{b}uses @{ub}@{b}Direct3D @{ub}@{b}on @{ub}@{b}Windows. @{ub}@{b}How @{ub}@{b}can @{ub}@{b}I @{ub}@{b}force @{ub}@{b}it @{ub}@{b}to @{ub}@{b}use@{ub}
    @{b}OpenGL @{ub}@{b}instead?@{ub}

    A: Just set the "RenderDriver" tag to "opengl" when "\@REQUIRE'ing"
    RebelSDL. See @{"Activating RebelSDL" LINK ActivatePlugin} for details.


    @{b}Q: @{ub}@{b}Why @{ub}@{b}doesn't @{ub}@{b}RebelSDL @{ub}@{b}report @{ub}@{b}non-ASCII @{ub}@{b}keys @{ub}@{b}through @{ub}@{b}OnKeyDown @{ub}@{b}and @{ub}@{b}OnKeyUp?@{ub}

    A: That's a limitation of SDL. It only supports ASCII and control keys
    through the "OnKeyDown" and "OnKeyUp" event handlers. If you have Hollywood
    7.0 or better, you can just listen to the "VanillaKey" event handler to get
    the real keyboard events with full Unicode support.


    @{b}Q: @{ub}@{b}Is @{ub}@{b}there @{ub}@{b}a @{ub}@{b}Hollywood @{ub}@{b}forum @{ub}@{b}where @{ub}@{b}I @{ub}@{b}can @{ub}@{b}get @{ub}@{b}in @{ub}@{b}touch @{ub}@{b}with @{ub}@{b}other @{ub}@{b}users?@{ub}

    A: Yes, please check out the "Community" section of the official Hollywood
    Portal online at http://www.hollywood-mal.com.


    @{b}Q: @{ub}@{b}How @{ub}@{b}do @{ub}@{b}I @{ub}@{b}quit @{ub}@{b}scripts @{ub}@{b}that @{ub}@{b}run @{ub}@{b}in @{ub}@{b}fullscreen @{ub}@{b}mode?@{ub}

    A: Just press CTRL+C. This will always work except when CTRL+C has been
    explicitly disabled using Hollywood's "CtrlCQuit()" function.


    @{b}Q: @{ub}@{b}Where @{ub}@{b}can @{ub}@{b}I @{ub}@{b}ask @{ub}@{b}for @{ub}@{b}help?@{ub}

    A: There's a lively forum at http://forums.hollywood-mal.com and we also
    have a mailing list which you can access at
    airsoft_hollywood\@yahoogroups.com. Visit http://www.hollywood-mal.com for
    information on how to join the mailing list.


    @{b}Q: @{ub}@{b}I @{ub}@{b}have @{ub}@{b}found @{ub}@{b}a @{ub}@{b}bug.@{ub}

    A: Please post about it in the dedicated sections of the forum or the
    mailing list.

@ENDNODE

@NODE KnownIssues "RebelSDL Guide"
@{b}Known issues@{ub}

    Here is a list of things that RebelSDL doesn't support yet or that may be
    confusing in some way:

    - the MorphOS version is very unstable, e.g. fullscreen mode crashes,
      iconifying a window crashes, the mouse pointer is always hidden, etc.;
      this isn't RebelSDL's fault but MorphOS' SDL2 port which seems to be in
      alpha state; I've tried to get in touch with SDL2's MorphOS maintainer but
      didn't get any reply so you'll have to live with these issues for the time
      being
    - menus are unsupported
    - the keyboard listener that is mapped to Hollywood's "OnKeyDown" and
      "OnKeyUp" event handlers currently only supports ASCII and control keys;
      this is because of a limitation in SDL which doesn't support fine-tuned
      listening (i.e. key down, key repeat, key up) using international
      keyboards; people who are on Hollywood 7.0 or better can just use the
      "VanillaKey" event handler instead; this event handler will deliver real
      keyboard events including full Unicode support
    - not all display styles are supported

@ENDNODE

@NODE ToDo "RebelSDL Guide"
@{b}Future@{ub}

    Here are some things that are on my to do list:

    - add support for more SDL calls

    Don't hesitate to contact me if RebelSDL lacks a certain feature that is
    important for your project.

@ENDNODE

@NODE History "RebelSDL Guide"
@{b}History@{ub}

    Please read the history bottom-up. Note that the history might list some
    features that were implemented in beta versions and removed later but are
    still mentioned here. This history is a log of the programmer so that he
    can look up what has been done/tried/modified. Things that were implemented
    and removed later are marked with [VOID].
     
    Version 1.1   (27-Sep-20)

    - Change: Updated documentation
    - New [OS4]: Added support for AmigaOS 4; this requires SDL 2.0.12 (July 2020) or better; 
      since SDL2 on OS4 supports both MiniGL and OpenGL ES 2.0 you can now get full hardware
      accelerated drawing and scaling even on OS4 systems that don't support MiniGL anymore but
      only OpenGL ES 2.0; using hardware accelerated drawing and scaling will dramatically
      improve RebelSDL's performance and can also be used to speed up normal Hollywood scripts
      (thanks to Juha Niemimäki)
    - New [MorphOS]: Added build for PowerSDL; since SDL2 on MorphOS currently doesn't support
      hardware acceleration it's probably better to use PowerSDL, i.e. SDL1, instead because
      SDL2 without hardware acceleration doesn't make much sense; PowerSDL offers hardware
      acceleration but doesn't support all of RebelSDL's features (e.g. multi-window support)
    - New: Added support for Hollywood's palette image interface
    - New: Added mouse wheel support; this requires Hollywood 8.0 or better (requested by Niels
      Schapke)
    - New: RebelSDL now supports direct draw transformation and alpha blending via DisplayBrush();
      if you draw a hardware brush with DisplayBrush() and set one of the transformation tags
      (e.g. "ScaleX", "ScaleY", "Rotate", etc.) or the "Transparency" tag, the specified
      parameters are applied directly on drawing; this should give a good speed boost over the
      old implementation but it requires Hollywood 8.0 or better 
    - New: RebelSDL recognizes the "SmoothScale" tag in LoadBrush(), \@BRUSH, CreateBrush() and
      CopyBrush() now if Hollywood 8.0 or better is in use; this makes sdl.SetScaleQuality()
      somewhat obsolete for people using Hollywood 8.0 or better
    - Fix: Hardware brush rotation was always done in the wrong direction
    - New [Linux/ARM]: RebelSDL only worked on Raspberry Pi systems but not on other ARM Linux
      distributions; two additional builds have been added now: a pure OpenGL build that doesn't
      access the RPi's special hardware and can thus be used on any ARM Linux that supports the
      OpenGL standard; additionally, an OpenGLES build has been added; this can be used on all
      ARM Linux systems that use OpenGLES (e.g. ODROID) (requested by Fabio Falcucci and Samuel
      Crow)
    - Change [Windows]: RebelSDL no longer requires the Visual C++ Redistributable DLLs; it is
      completely stand-alone now! (but about 200kb bigger because it is now statically linked
      against MSVCRT)
    - New: Added sdl.SetScaleQuality() which can be used to specify how a texture/hardware brush
      should be scaled; you can pass "nearest" for no interpolation or "linear" for linear
      filtering; Direct3D also supports "best" for anisotropic filtering; the scale mode is set
      when a hardware brush/texture is created so you need to call sdl.SetScaleQuality() before
      creating a hardware brush/texture; this also means that you cannot use it for brushes
      loaded in the preprocessor commands because those will always be loaded before the script
      execution starts (requested by Fabio Falcucci)

    Version 1.0   (09-Sep-17)
    - First Release
@ENDNODE

@NODE ActivatePlugin "RebelSDL Guide"
@{b}Activating RebelSDL@{ub}

    All you have to do to make your script use SDL instead of Hollywood's
    inbuilt graphics driver is adding the following line to the top of your
    script:

        \@REQUIRE "rebelsdl"

    Alternatively, if you are using Hollywood from a console, you can also start
    your script like this:

        Hollywood test.hws -requireplugins rebelsdl

    Once the RebelSDL plugin has been activated for your script, it will reroute
    all of Hollywood's graphics output through SDL. Note that this will usually
    be slower than Hollywood's inbuilt graphics driver for scripts that aren't
    optimized for RebelSDL. To get an optimal performance with SDL, your script
    needs to use a hardware-accelerated double buffer. See @{"Using a hardware" LINK HardwareDB}
    @{"double buffer" LINK HardwareDB} for details.

    RebelSDL accepts the following arguments in its "\@REQUIRE" call:

    EnableVSync:
              By default, RebelSDL's hardware double buffer is sync'ed with the
              monitor's vertical refresh. This means that "Flip()" will always
              block until the next vertical refresh and then flip the buffers.
              This will generate perfectly smooth graphics but of course it also
              means that you can't draw faster than the monitor's vertical
              refresh, typically around 60 times per second. If you want to
              ignore the monitor's vertical refresh, set this tag to FALSE and
              RebelSDL won't throttle double buffer flipping. It will then flip
              buffers as fast as the hardware allows. Defaults to TRUE.

    ForceFullRefresh:
              If this tag is set to FALSE, RebelSDL will only refresh the parts
              of the display that have actually changed. This is quicker but it
              can lead to some refresh problems depending on the way your script
              draws its graphics. That is why this tag defaults to TRUE, which
              means that RebelSDL will always refresh the full display whenever
              something is drawn. This is slower but guarantees that there will
              be no visual artefacts because front and back buffers will always
              be completely in sync.

    RenderDriver:
              This tag allows you to select a different render driver than the
              default one. This is mostly useful for testing purposes. For
              example, it is possible to force RebelSDL to use OpenGL on Windows
              instead of the default Direct3D driver with this tag. Possible
              values for this tag are "direct3d", "opengl", "opengles",
              "opengles2", "rpi", and "software". See @{"Raspberry Pi peculiarities" LINK RaspberryPi}
              for more information on the rpi driver.

    UseAudioAdapter:
              By default, RebelSDL will replace Hollywood's inbuilt audio driver
              with a custom audio driver that uses SDL to play audio. If you
              don't want that, set this tag to FALSE. Then Hollywood's inbuilt
              audio driver will be used even when RebelSDL is active. Normally,
              however, it's not necessary to set this tag unless you experience
              problems with RebelSDL's audio driver. Defaults to TRUE.

    UseBitmapAdapter:
              If this is set to TRUE, RebelSDL will override Hollywood's inbuilt
              handler for software bitmaps. This doesn't have any practical
              advantages and was only implemented to test the corresponding
              Hollywood SDK functionality. Defaults to FALSE.

    UseDesktopFullScreen:
              SDL offers a special display mode that automatically scales
              windows opened by SDL to the dimensions of the desktop. The window
              will then occupy all screen space without changing the monitor's
              resolution. You can activate this mode by setting this tag to
              TRUE. Setting this tag to TRUE will also automatically activate
              autoscaling for your display. Note that a similar effect can be
              achieved by using Hollywood's "FullScreenScale" display mode but
              it's preferrable to use "UseDesktopFullScreen" because it is
              directly tied to SDL. Defaults to FALSE.

    UseDoubleBufferAdapter:
              If this is set to FALSE, RebelSDL won't support hardware double
              buffers. Since hardware double buffers are one of the most
              important features of RebelSDL, there's probably no case where
              you'd want to disable this feature. It's mostly here for debugging
              purposes. Defaults to TRUE.

    UseSoftwareRenderer:
              By default, SDL will try to use the GPU to draw graphics whenever
              and wherever possible. If you don't want this, you can set this
              tag to TRUE to put SDL into pure software drawing mode. This is
              probably only of use for testing and debugging purposes because
              normally you'd want to use the hardware renderer for the best
              performance. Defaults to FALSE.

    UseVideoBitmapAdapter:
              If this is set to FALSE, RebelSDL won't support hardware brushes.
              Since hardware brushes are one of the most important features of
              RebelSDL, there's probably no case where you'd want to disable
              this feature. It's mostly here for debugging purposes. Defaults to
              TRUE.

    Here is an example of how to pass arguments to the "\@REQUIRE" preprocessor
    command:

        \@REQUIRE "rebelsdl", {UseDesktopFullScreen = True}

    Alternatively, you can also use the -requiretags console argument to pass
    these arguments. See the Hollywood manual for more information.

@ENDNODE

@NODE HardwareDB "RebelSDL Guide"
@{b}Using a hardware double buffer@{ub}

    If you want your script to benefit from RebelSDL's hardware-accelerated
    drawing functions, you need to use a hardware double buffer and do all your
    drawing within that double buffer. Using a hardware double buffer will also
    ensure that graphics output is synchronized with your monitor's refresh rate
    to prevent any flickering. To get an optimal performance with RebelSDL, your
    main loop should always look like this:

        \@REQUIRE "rebelsdl"

        BeginDoubleBuffer(True)  ; set up a hardware double buffer

        Repeat
            ....          ; draw the next frame here
            Flip()        ; wait for vertical refresh, then flip buffers
            CheckEvent()  ; run event callbacks
        Forever

    The call to "CheckEvent()" is only necessary if your script needs to listen
    to event handlers that have been installed using "InstallEventHandler()".
    Note that you should not draw the next frame in an interval callback that
    runs at a constant frame rate (say 50fps) because such a setup won't
    guarantee that drawing is synchronized with the vertical refresh as
    different monitors use different refresh rates so you might get flickery
    graphics. If you do your drawing like above, you can be sure that front and
    back buffers will be flipped in perfect synchronization with the monitor's
    vertical refresh.

    Additionally, you need to take care of how you actually draw your graphics
    because most of Hollywood's drawing commands operate entirely in software
    mode and thus do not benefit from hardware acceleration. See @{"Drawing" LINK HowToDraw}
    @{"graphics" LINK HowToDraw} for details.

    When drawing brushes in a hardware double buffer, make sure that you use
    only hardware brushes because only those can be drawn directly using
    hardware acceleration. Drawing normal brushes to hardware double buffers is
    possible too, but it will be very slow. See @{"Hardware brushes" LINK HardwareBrushes} for details.

    @{b}Important: @{ub}SDL is designed to be used with double buffers. Thus, you can
    only benefit from hardware acceleration when drawing within a double buffer.
    Drawing outside a double buffer is possible but it will be much slower.

@ENDNODE

@NODE HowToDraw "RebelSDL Guide"
@{b}Drawing graphics@{ub}

    For an optimal performance you need to be very careful concerning the way
    you draw your graphics. Most of Hollywood's drawing commands are implemented
    in software only, i.e. they draw using the CPU instead of the GPU. This can
    become quite a bottleneck especially on slower CPUs. Thus, you should know
    which drawing functions are hardware-accelerated and which aren't and then
    write your scripts accordingly.

    The following Hollywood commands are hardware-accelerated when RebelSDL is
    active and they are used within a hardware double buffer:

        Box()
        Cls()
        Line()
        Plot()
        DisplayBrush()

    "DisplayBrush()" will only use hardware acceleration when called with a
    hardware brush. See @{"Using hardware brushes" LINK HardwareBrushes} for details. When used with a
    software brush, i.e. a brush that doesn't reside in video memory,
    "DisplayBrush()" will draw the brush using the CPU which is much slower.

    "Box()", "Line()", and "WritePixel()" will only use hardware acceleration in
    case the fill style is either #FILLNONE or #FILLCOLOR and no other form
    styles like #EDGE or #SHADOW are active. As soon as you want to draw with
    other fill or form styles, these commands will fall back to their software
    counterparts and thus will be very slow. You can work around this problem by
    simply drawing the graphics into a hardware brush first and then just
    drawing this hardware brush. This is a good strategy because then
    Hollywood's software renderer will be used only once, i.e. when drawing the
    graphics into a hardware brush, and after that you'll profit from hardware
    acceleration all the time because hardware brushes can be drawn really
    quickly.

    Finally, don't forget that you should do all your drawing inside a hardware
    double buffer loop. See @{"Using a hardware double buffer" LINK HardwareDB} for details.

@ENDNODE

@NODE HardwareBrushes "RebelSDL Guide"
@{b}Using hardware brushes@{ub}

    RebelSDL supports the creation of hardware brushes. Hardware brushes reside
    in GPU memory and thus can be drawn in no time. On most graphics boards,
    they can also be scaled and transformed by the GPU in an extremely efficient
    way. To make Hollywood create a hardware brush, all you have to do is set
    the optional "Hardware" tag to TRUE. This tag is supported by most of the
    Hollywood commands which create brushes.

    Here is an example:

        \@REQUIRE "rebelsdl"  ; make sure this line is first
        \@BRUSH 1, "sprites.png", {Hardware = True}

    In the code above, RebelSDL will create brush 1 in video memory. It can then
    be drawn using the GPU at almost no cost. Keep in mind, though, that
    hardware brushes can only be drawn to hardware double buffers. See @{"Using a" LINK HardwareDB}
    @{"hardware double buffer" LINK HardwareDB} for details.

    To transform a hardware brush, you can use the "ScaleBrush()",
    "RotateBrush()", and "TransformBrush()" commands. Transformations of
    hardware brushes are usually also GPU-accelerated and thus many times faster
    than transformations done by the CPU.

    Note that hardware brushes can only be drawn to the display that was
    specified when allocating them. Thus, if your script uses multiple displays,
    you need to tell Hollywood the identifier of the display you want to use
    this hardware brush with. This can be done by specifying the "Display" tag
    along the "Hardware" tag. Here is an example:

        \@REQUIRE "rebelsdl"  ; make sure this line is first
        \@DISPLAY 1, {Title = "First display"}
        \@DISPLAY 2, {Title = "Second display"}
        \@BRUSH 1, "sprites.png", {Hardware = True, Display = 1}
        \@BRUSH 2, "sprites.png", {Hardware = True, Display = 2}

    The code above will allocate brush 1 in a way that it can be drawn to
    display 1 and it will allocate brush 2 in a way that it can be drawn to
    display 2. It won't be possible, however, to draw brush 2 to display 1 or
    brush 1 to display 2! RebelSDL hardware brushes are always display-dependent
    and can only be drawn to the display they were allocated for.

    Please see the Hollywood manual for more information on hardware brushes and
    hardware double buffers.

    You can also use RebelSDL as a helper plugin to add hardware brush support
    to Hollywood on Windows, macOS, and Linux. By default, Hollywood doesn't
    support hardware brushes on these systems but RebelSDL can add this feature
    to Hollywood. See @{"RebelSDL as a helper plugin" LINK SDLGlue} for details.

    The SmoothScroll.hws example script that comes with RebelSDL demonstrates
    how to use hardware brushes and a hardware double buffer to achieve
    butter-smooth scrolling that is fully synchronized with the monitor's
    vertical refresh.

@ENDNODE

@NODE OffscreenRender "RebelSDL Guide"
@{b}Offscreen rendering@{ub}

    If you pass TRUE to the @{"sdl.EnableOffscreenRender()" LINK sdlEnableOffscreenRender} command, all hardware
    brushes that are created after the call to @{"sdl.EnableOffscreenRender()" LINK sdlEnableOffscreenRender} can
    be drawn to using Hollywood's "SelectBrush()" command. These drawing
    operations can also be hardware-accelerated which gives them an advantage
    over Hollywood's default offscreen drawing routines which can only draw to
    software brushes.

    There is, however, a major limitation that you have to keep in mind:
    Hardware brushes which can be drawn to using "SelectBrush()" will lose their
    contents on Windows whenever the window size is changed or when the window's
    display mode changes, e.g. from full screen mode to window or the other way
    round. Thus, using hardware brushes which can be drawn to really only makes
    sense if you update them every frame or if you are able to re-initialize
    them whenever the window's size or display mode changes. If your script
    isn't able to handle that, you will be in trouble. Because of this
    limitation, it is also highly advised to call @{"sdl.EnableOffscreenRender()" LINK sdlEnableOffscreenRender}
    with its argument set to FALSE immediately after you have created the
    hardware brushes that you want to use for offscreen drawing. Otherwise, all
    hardware brushes created subsequently will also be prepared for offscreen
    drawing and will thus suffer from the limitations described above.

    Note that in order to utilize hardware acceleration on offscreen drawing you
    need to follow the same rules as when drawing to a hardware double buffer.
    Only a few graphics operations are hardware-accelerated. See @{"Drawing" LINK HowToDraw}
    @{"graphics" LINK HowToDraw} for details.

    It is also important to note that the different combo modes supported by
    "SelectBrush()" won't work with RebelSDL. Instead, graphics are always drawn
    to the color and the alpha channel of the hardware brush, no matter which
    mode you specify. Also, you cannot use "SelectMask()" or
    "SelectAlphaChannel()" with hardware brushes. It's only possible to use
    "SelectBrush()" to draw into color and alpha channels at the same time.

@ENDNODE

@NODE SDLRender "RebelSDL Guide"
@{b}Using the SDL renderer@{ub}

    For advanced users RebelSDL allows you to call SDL renderer functions
    directly for the ultimate flexibility. Take note, though, that if you do
    this then you'll be operating at a very low level and some Hollywood
    features like the autoscaling engine won't work any more because all your
    drawing calls are routed directly through SDL without Hollywood having a
    chance to intervene. This has very little overhead but comes at the expense
    of certain Hollywood features not working any longer, like the autoscaling
    engine.

    If you do make SDL renderer calls directly, you should also not mix them
    with Hollywood drawing calls. You should either draw entirely with Hollywood
    functions or with SDL renderer functions. Mixing both is possible but might
    yield some unexpected results because Hollywood drawing functions will of
    course change state information of the SDL renderer themselves, i.e. if you
    call @{"sdl.SetRenderDrawColor()" LINK sdlSetRenderDrawColor} to set the drawing color to red and then use
    Hollywood's "Box()" command to draw a blue box, then the renderer color will
    suddenly be blue because the call to "Box()" has changed the renderer color
    to blue. These are side effects you have to be able to deal with when mixing
    SDL renderer calls and Hollywood drawing calls.

@ENDNODE

@NODE JoystickNote "RebelSDL Guide"
@{b}Joysticks and game controllers@{ub}

    RebelSDL allows you to access SDL's comprehensive joystick and game
    controller functionalities. For the best compatibility, it is recommended to
    place a file named gamecontrollerdb.txt in the same directory as your
    script. This file has to contain calibration information for all the
    different joysticks and game controllers out there. You can find a
    community-maintained version of this file here:
    https://github.com/gabomdq/SDL_GameControllerDB

@ENDNODE

@NODE MoreSpeed "RebelSDL Guide"
@{b}Increasing execution speed@{ub}

    To increase the raw execution speed of your script, you can disable
    Hollywood's line hook using the "DisableLineHook()" and "EnableLineHook()"
    commands. This will improve your script's execution speed significantly in
    case lots of Hollywood code needs to be run to draw the next frame. Keep in
    mind, though, that you have to enable the line hook for every frame you draw
    or your window will become unresponsive. Here's what a speed-optimized
    implemention of the main loop could look like:

        \@REQUIRE "rebelsdl"

        BeginDoubleBuffer(True)  ; set up a hardware double buffer

        Repeat
            DisableLineHook() ; disable line hook while drawing the next frame
            p_DrawFrame()     ; draw the next frame here
            EnableLineHook()  ; enable line hook again
            Flip()            ; wait for vertical refresh, then flip buffers
            CheckEvent()      ; run event callbacks
        Forever

    Note that you'll only notice a speed difference here if "p_DrawFrame()"
    executes many lines of Hollywood code. If "p_DrawFrame()" only consists of
    20 lines of code, you won't notice any difference. It's only noticeable with
    hundreds of code lines or long loops.

    See the documentation of "DisableLineHook()" and "EnableLineHook()" in the
    Hollywood manual for more information.

@ENDNODE

@NODE SDLGlue "RebelSDL Guide"
@{b}RebelSDL as a helper plugin@{ub}

    RebelSDL can also be used as a helper plugin to work around the problem that
    Hollywood only supports hardware-accelerated double buffers and brushes on
    AmigaOS and compatibles. They aren't supported on Windows, macOS, or Linux.
    If you install and "\@REQUIRE" RebelSDL, however, hardware double buffer and
    hardware brush support will also be available on Windows, macOS, and Linux
    because RebelSDL supports this.

    Thus, you can also use RebelSDL as a helper plugin just to get
    hardware-accelerated double buffer support on Windows, macOS, and Linux. You
    don't even have to use any of the SDL commands directly. You can just
    "\@REQUIRE" RebelSDL, set up a hardware double buffer and then draw to it
    using hardware brushes. This allows you to utilize hardware acceleration
    without having to write a single line of SDL code!

    On AmigaOS and compatibles this isn't necessary since Hollywood already
    supports hardware accelerated double buffers and brushes by default. Still,
    using RebelSDL on AmigaOS as a hardware double buffer driver can be of
    benefit in full screen mode because RebelSDL uses drawing which is perfectly
    synchronized with the monitor's vertical refresh so it usually looks better
    than double buffers managed by Hollywood directly.

    See @{"Using a hardware double buffer" LINK HardwareDB} for details.

    See @{"Using hardware brushes" LINK HardwareBrushes} for details.

    The SmoothScroll.hws example script that comes with RebelSDL demonstrates
    how to use hardware brushes and a hardware double buffer to achieve
    butter-smooth scrolling that is fully synchronized with the monitor's
    vertical refresh.

@ENDNODE

@NODE RaspberryPi "RebelSDL Guide"
@{b}Raspberry Pi peculiarities@{ub}

    RebelSDL can be very useful on the Raspberry Pi because of its comparatively
    poor CPU which makes Hollywood's inbuilt CPU renderer very slow. Using
    RebelSDL will give you hardware-accelerated drawing and scaling which can
    boost your script's performance dramatically. However, there are some things
    that you have to keep in mind. First of all, there are two entirely
    different drivers available for the Raspberry Pi:

    1. VideoCore 4 OpenGL driver (KMS/DRM): Since 2017 Raspbian Jessie ships
       with an experimental vc4 KMS/DRM OpenGL driver. To enable this driver,
       you need to run sudo raspi-config go to the Advanced Options settings and
       then select GL (Full KMS) in the GL Driver menu. Once you have rebooted
       your system, X11 will then use this new vc4 driver and RebelSDL will be
       able to use it too. Note that you have to make sure that you're using a
       recent version of Raspbian Jessie (2017 or newer) or Raspbian Stretch.
       Older versions of Jessie don't have this driver yet. Also note that as of
       September 2017, activating the new vc4 driver breaks HDMI audio output on
       Jessie (not on Stretch). So as of September 2017, you'll only be able to
       get audio through the headphone output on Jessie when the vc4 driver is
       enabled.

    2. Raspberry Pi native driver: This is an alternative driver which directly
       accesses the graphics hardware of the Pi bypassing OpenGL and X11
       completely. This means that you can run your scripts from outside X11 as
       well. This driver will also work with older versions of Raspbian Jessie
       but only if the experimental OpenGL driver (see above) is disabled. To
       activate the native Raspberry Pi renderer, you need to pass "rpi" to the
       "RenderDriver" tag when "\@REQUIRE'ing" RebelSDL, like so:

           \@REQUIRE "rebelsdl", {RenderDriver = "rpi"}

       RebelSDL will then use the native Raspberry Pi renderer. Note that since
       the native Pi renderer operates outside X11 it will always take over the
       whole screen. It is not possible to run the native Pi renderer in
       windowed mode. It will always fill the entire screen. All Hollywood
       features that require a window won't work with the native Pi renderer
       either.

    By default, RebelSDL will use the vc4 OpenGL driver and if it is not there,
    it will fall back to software OpenGL mode, which is of course very slow. The
    native Pi renderer will only be activated if you explicitly request it like
    shown above.

@ENDNODE

@NODE Examples "RebelSDL Guide"
@{b}Examples@{ub}

    RebelSDL comes with a number of examples that demonstrates how to use the
    plugin and should allow you to get started really quickly. Here's a list of
    examples that are distributed with RebelSDL:

    Aladdin   A RebelSDL port of the Prodigy cracktro for Aladdin.
    BeastScroll
              A remake of the famous Shadow of the Beast scroller in RebelSDL.
    CannonFodder
              A RebelSDL port of the Cannon Fodder cracktro by Crystal.
    Creatures A RebelSDL port of the Creatures cracktro by Crystal.
    Dynablaster
              A RebelSDL port of the Dynablaster cracktro by Vision Factory.
    GPUScale  Demonstrates how to use GPU-accelerated scaling and rotation with
              RebelSDL.
    Lemmings  A RebelSDL port of the Lemmings cracktro by Skid Row.
    Moonstone A RebelSDL port of the Moonstone cracktro by Crystal.
    MultiDisplays
              Demonstrates how to use multiple displays with RebelSDL.
    Pang      A RebelSDL port of the Pang cracktro by Horizon.
    PPHammer  A RebelSDL port of the PP Hammer cracktro by Crystal.
    SmoothScroll
              Demonstrates how to achieve perfectly smooth scrolling with
              hardware brushes.
    SteelEmpire
              A RebelSDL port of the Steel Empire cracktro by Crystal.
    Superfrog A RebelSDL port of the Superfrog cracktro by Crystal.
    SuperStardust
              A RebelSDL port of the Super Stardust cracktro by Prestige.
    Turrican2 A RebelSDL port of the Turrican 2 cracktro by Defjam.
    Turrican3 A RebelSDL port of the Turrican 3 cracktro by Hoodlum.
    Zool      A RebelSDL port of the Zool cracktro by Crystal.

@ENDNODE

@NODE sdlForceJoystickMode "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.ForceJoystickMode -- force game controller into joystick mode

   @{b}SYNOPSIS@{ub}
        sdl.ForceJoystickMode(port)

   @{b}FUNCTION@{ub}
        Use this function to force the game controller at the specified port
        into joystick mode. You will then be able to query the game controller's
        state as if it was a joystick.

   @{b}INPUTS@{ub}
        port      game port to use

@ENDNODE

@NODE sdlGetAxis "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetAxis -- query state of specified axis

   @{b}SYNOPSIS@{ub}
        state = sdl.GetAxis(port, axis)

   @{b}FUNCTION@{ub}
        If the device at the specified port is a joystick, "axis" must be the
        number of the axis to query. 0 is typically used for the x-axis and 1
        for the y-axis. Some joysticks use axes 2 or 3 for extra buttons. You
        can use @{"sdl.GetNumAxes()" LINK sdlGetNumAxes} to find out the number of axes.

        If the device at the specified port is a game controller, "axis" must be
        one of the following predefined constants:

            #SDL_AXIS_LEFTX
            #SDL_AXIS_LEFTY
            #SDL_AXIS_RIGHTX
            #SDL_AXIS_RIGHTY
            #SDL_AXIS_TRIGGERLEFT
            #SDL_AXIS_TRIGGERRIGHT

        The return value is a value ranging from -32768 to 32767. It may be
        necessary to impose certain tolerances on these values to account for
        jitter. Note that game controller triggers, however, range from 0 to
        32767. They never return a negative value.

   @{b}INPUTS@{ub}
        port      game port to query
        axis      axis to query

   @{b}RESULTS@{ub}
        state     state of the specified axis (typically -32768 to 32767)

@ENDNODE

@NODE sdlGetBall "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetBall -- query state of specified ball

   @{b}SYNOPSIS@{ub}
        dx, dy = sdl.GetBall(port, ball)

   @{b}FUNCTION@{ub}
        Use this function to get the ball axis change since the last poll. This
        is only possible for joysticks, not for game controllers.

        You have to pass the ball index to query in "ball". Ball indices start
        at index 0. sdl.GetBall() will return the difference in the x and y axis
        position since the last poll. Note that since trackballs can only return
        relative motion these return values are delta values.

   @{b}INPUTS@{ub}
        port      game port to query
        ball      ball index to query

   @{b}RESULTS@{ub}
        dx        the difference in the x axis position since the last poll
        dy        the difference in the y axis position since the last poll

@ENDNODE

@NODE sdlGetButton "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetButton -- query state of specified button

   @{b}SYNOPSIS@{ub}
        state = sdl.GetButton(port, button)

   @{b}FUNCTION@{ub}
        If the device at the specified port is a joystick, "button" must be the
        index of the desired button (starting from 0). The number of joystick
        buttons can be found out by calling @{"sdl.GetNumButtons()" LINK sdlGetNumButtons}.

        If the device at the specified port is a game controller, "button" must
        be one of the following predefined constants:

            #SDL_BUTTON_A
            #SDL_BUTTON_B
            #SDL_BUTTON_X
            #SDL_BUTTON_Y
            #SDL_BUTTON_BACK
            #SDL_BUTTON_GUIDE
            #SDL_BUTTON_START
            #SDL_BUTTON_LEFTSTICK
            #SDL_BUTTON_RIGHTSTICK
            #SDL_BUTTON_LEFTSHOULDER
            #SDL_BUTTON_RIGHTSHOULDER
            #SDL_BUTTON_DPAD_UP
            #SDL_BUTTON_DPAD_DOWN
            #SDL_BUTTON_DPAD_LEFT
            #SDL_BUTTON_DPAD_RIGHT

   @{b}INPUTS@{ub}
        port      game port to query
        button    button to query

   @{b}RESULTS@{ub}
        state     state of the specified button (1 for pressed state, 0
                  non-pressed state)

@ENDNODE

@NODE sdlGetHat "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetHat -- query state of specified hat

   @{b}SYNOPSIS@{ub}
        state = sdl.GetHat(port, hat)

   @{b}FUNCTION@{ub}
        Use this function to get the current state of a POV hat on a joystick.
        This is only possible for joysticks, not for game controllers. You have
        to pass the hat index to get the state from. Hat indices start at index
        0.

        The return value will be one of the following predefined constants:

            #SDL_HAT_CENTERED
            #SDL_HAT_UP
            #SDL_HAT_RIGHT
            #SDL_HAT_DOWN
            #SDL_HAT_LEFT
            #SDL_HAT_RIGHTUP
            #SDL_HAT_RIGHTDOWN
            #SDL_HAT_LEFTUP
            #SDL_HAT_LEFTDOWN

   @{b}INPUTS@{ub}
        port      game port to query
        hat       hat index whose state to get

   @{b}RESULTS@{ub}
        state     state of specified hat

@ENDNODE

@NODE sdlGetJoysticks "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetJoysticks -- get number of available joysticks

   @{b}SYNOPSIS@{ub}
        n = sdl.GetJoysticks()

   @{b}FUNCTION@{ub}
        Use this function to count the number of joysticks attached to the
        system.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        n         number of attached joysticks

@ENDNODE

@NODE sdlGetNumAxes "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetNumAxes -- get number of joystick axes

   @{b}SYNOPSIS@{ub}
        num = sdl.GetNumAxes(port)

   @{b}FUNCTION@{ub}
        Use this function to get the number of general axis controls on a
        joystick. This is only possible for joysticks, not for game controllers.

   @{b}INPUTS@{ub}
        port      game port to query

   @{b}RESULTS@{ub}
        num       number of joystick axes

@ENDNODE

@NODE sdlGetNumBalls "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetNumBalls -- get number of joystick balls

   @{b}SYNOPSIS@{ub}
        num = sdl.GetNumBalls(port)

   @{b}FUNCTION@{ub}
        Use this function to get the number of trackballs on a joystick. This is
        only possible for joysticks, not for game controllers.

   @{b}INPUTS@{ub}
        port      game port to query

   @{b}RESULTS@{ub}
        num       number of joystick trackballs

@ENDNODE

@NODE sdlGetNumButtons "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetNumButtons -- get number of joystick buttons

   @{b}SYNOPSIS@{ub}
        num = sdl.GetNumButtons(port)

   @{b}FUNCTION@{ub}
        Use this function to get the number of buttons on a joystick. This is
        only possible for joysticks, not for game controllers.

   @{b}INPUTS@{ub}
        port      game port to query

   @{b}RESULTS@{ub}
        num       number of joystick buttons

@ENDNODE

@NODE sdlGetNumHats "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetNumHats -- get number of joystick hats

   @{b}SYNOPSIS@{ub}
        num = sdl.GetNumHats(port)

   @{b}FUNCTION@{ub}
        Use this function to get the number of POV hats on a joystick. This is
        only possible for joysticks, not for game controllers.

   @{b}INPUTS@{ub}
        port      game port to query

   @{b}RESULTS@{ub}
        num       number of joystick hats

@ENDNODE

@NODE sdlIsGameController "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.IsGameController -- check if input device is a game controller

   @{b}SYNOPSIS@{ub}
        res = sdl.IsGameController(port)

   @{b}FUNCTION@{ub}
        Use this function to find out whether the input device at the specified
        port is a game controller or a joystick. The function will return True
        for game controllers and False for joysticks.

   @{b}INPUTS@{ub}
        port      game port to query

   @{b}RESULTS@{ub}
        res       boolean value

@ENDNODE

@NODE sdlSetTextInputRect "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetTextInputRect -- set the rectangle used to type Unicode text inputs

   @{b}SYNOPSIS@{ub}
        sdl.SetTextInputRect(x, y, width, height)

   @{b}FUNCTION@{ub}
        Use this function to set the rectangle used to type Unicode text inputs.

   @{b}INPUTS@{ub}
        x         x position
        y         y position
        width     rectangle width
        height    rectangle height

@ENDNODE

@NODE sdlStartTextInput "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.StartTextInput -- start accepting Unicode text events

   @{b}SYNOPSIS@{ub}
        sdl.StartTextInput()

   @{b}FUNCTION@{ub}
        This function will start accepting Unicode text input events in the
        focused RebelSDL window, and start emitting "VanillaKey". Please use
        this function in pair with @{"sdl.StopTextInput()" LINK sdlStopTextInput}.

        On some platforms using this function activates the screen keyboard.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE sdlStopTextInput "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.StopTextInput -- stop receiving Unicode text events

   @{b}SYNOPSIS@{ub}
        sdl.StopTextInput()

   @{b}FUNCTION@{ub}
        Use this function to stop receiving any Unicode text input events. See
        @{"sdl.StartTextInput" LINK sdlStartTextInput} for details.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE sdlEnableOffscreenRender "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.EnableOffscreenRender -- enable hardware brush offscreen rendering

   @{b}SYNOPSIS@{ub}
        sdl.EnableOffscreenRender(on)

   @{b}FUNCTION@{ub}
        This function can be used to enable or disable offscreen rendering to
        hardware brushes, depending on what you pass in the "on" argument.

        Please note that the new setting will only affect hardware brushes
        created after you have made this call. Hardware brushes created before
        your call of this function will use the old setting.

        Also note that hardware brushes that can be drawn to face some
        limitations. See @{"Offscreen rendering" LINK OffscreenRender} for details. That's why you should
        only use this function if your script is able to deal with these
        limitations. The advantage is that sdl.EnableOffscreenRender() allows
        your script to draw to offscreen hardware brushes with hardware
        acceleration. But you have to keep some things in mind when doing so.
        See @{"Offscreen rendering" LINK OffscreenRender} for details.

   @{b}INPUTS@{ub}
        on        boolean indicating whether to enable or disable hardware brush
                  offscreen rendering

   @{b}EXAMPLE@{ub}
        sdl.EnableOffscreenRender(True)
        CreateBrush(1, 640, 480, #BLACK, {Hardware = True})
        sdl.EnableOffscreenRender(False)

        The code above creates brush 1 as a hardware brush that can be drawn to
        using "SelectBrush()". All other hardware brushes cannot be drawn to
        because we immediately set the enable offscreen render flag to FALSE
        again.

@ENDNODE

@NODE sdlGetCurrentRenderDriver "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetCurrentRenderDriver -- get current render driver

   @{b}SYNOPSIS@{ub}
        d$ = sdl.GetCurrentRenderDriver(display)

   @{b}FUNCTION@{ub}
        This function returns the name of the current render driver, e.g.
        "opengl", "direct3d", "opengles", etc.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be retrieved

   @{b}RESULTS@{ub}
        d$        name of the current render driver

@ENDNODE

@NODE sdlGetRenderDrawBlendMode "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetRenderDrawBlendMode -- get draw blend mode

   @{b}SYNOPSIS@{ub}
        blendmode = sdl.GetRenderDrawBlendMode(display)

   @{b}FUNCTION@{ub}
        Use this function to get the blend mode used for drawing operations. See
        @{"sdl.SetRenderDrawBlendMode" LINK sdlSetRenderDrawBlendMode} for a list of blend modes.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        blendmode current blend mode

@ENDNODE

@NODE sdlGetRenderDrawColor "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetRenderDrawColor -- get draw color

   @{b}SYNOPSIS@{ub}
        r, g, b, a = sdl.GetRenderDrawColor(display)

   @{b}FUNCTION@{ub}
        Use this function to get the color used for drawing operations (rect,
        line and clear).

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        r         the red value used to draw on the rendering target (ranging
                  from 0 to 255)
        g         the green value used to draw on the rendering target (ranging
                  from 0 to 255)
        b         the blue value used to draw on the rendering target (ranging
                  from 0 to 255)
        a         the alpha value used to draw on the rendering target (ranging
                  from 0 to 255)

@ENDNODE

@NODE sdlGetRendererOutputSize "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetRendererOutputSize -- get renderer output size

   @{b}SYNOPSIS@{ub}
        w, h = sdl.GetRendererOutputSize(display)

   @{b}FUNCTION@{ub}
        Use this function to get the output size in pixels of a rendering
        context. If an error occurs, -1 is returned in both return values.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        w         output width
        h         output height

@ENDNODE

@NODE sdlGetTextureAlphaMod "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetTextureAlphaMod -- get texture alpha modulation

   @{b}SYNOPSIS@{ub}
        alpha = sdl.GetTextureAlphaMod(tex)

   @{b}FUNCTION@{ub}
        Use this function to get the additional alpha value multiplied into
        render copy operations. The "tex" argument must simply be the identifier
        of a hardware brush.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush

   @{b}RESULTS@{ub}
        alpha     alpha modulation or -1 on error

@ENDNODE

@NODE sdlGetTextureBlendMode "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetTextureBlendMode -- get texture blend mode

   @{b}SYNOPSIS@{ub}
        mode = sdl.GetTextureBlendMode(tex)

   @{b}FUNCTION@{ub}
        Use this function to get the blend mode used for texture copy
        operations. The "tex" argument must simply be the identifier of a
        hardware brush.

        See @{"sdl.SetRenderDrawBlendMode" LINK sdlSetRenderDrawBlendMode} for a list of blend modes.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush

   @{b}RESULTS@{ub}
        mode      the blend mode or -1 on error

@ENDNODE

@NODE sdlGetTextureColorMod "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetTextureColorMod -- get texture color modulation

   @{b}SYNOPSIS@{ub}
        r, g, b = sdl.GetTextureColorMod(tex)

   @{b}FUNCTION@{ub}
        Use this function to get the additional color value multiplied into
        render copy operations. The "tex" argument must simply be the identifier
        of a hardware brush.

        On error, this function returns -1 in all return values.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush

   @{b}RESULTS@{ub}
        r         the red color value multiplied into copy operations (ranging
                  from 0 to 255)
        g         the green color value multiplied into copy operations (ranging
                  from 0 to 255)
        b         the blue color value multiplied into copy operations (ranging
                  from 0 to 255)

@ENDNODE

@NODE sdlRenderClear "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderClear -- clear target

   @{b}SYNOPSIS@{ub}
        sdl.RenderClear(display)

   @{b}FUNCTION@{ub}
        Use this function to clear the current rendering target with the drawing
        color. This function clears the entire rendering target, ignoring the
        viewport and the clip rectangle.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

@ENDNODE

@NODE sdlRenderCopy "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderCopy -- draw texture

   @{b}SYNOPSIS@{ub}
        sdl.RenderCopy(display, tex[, src, dst, angle, center, flip])

   @{b}FUNCTION@{ub}
        Use this function to copy a portion of the texture specified by "tex" to
        the display specified by "display", optionally rotating it by "angle"
        around the given center point and also flipping it top-bottom and/or
        left-right. The "tex" argument must simply be the identifier of a
        hardware brush.

        If specified, "src" and "dst" must be tables containing the following
        fields:

        x         Left position of rectangle.

        y         Top position of rectangle.

        w         Rectangle width.

        h         Rectangle height.

        Alternatively, you can also set "src" and/or "dst" to Nil. Passing Nil
        in "src" and/or "dst" means to use the entire size of the source or
        destination, respectively. If source and destination sizes do not match,
        sdl.RenderCopy() will automatically stretch the texture to fit to the
        destination rectangle.

        If specified, "center" must be a table containing the following fields:

        x         Left position of center point.

        y         Top position of center point.

        Alternatively, you can also set "center" to Nil. In that case, the
        center point will be set to the center of the destination rectangle.

        If specified, "flip" must be a combination of the following predefined
        constants:

        #SDL_FLIP_NONE
                  Do not flip
        #SDL_FLIP_HORIZONTAL
                  Flip horizontally
        #SDL_FLIP_VERTICAL
                  Flip vertically

        The texture is blended with the destination based on its blend mode set
        with @{"sdl.SetTextureBlendMode()" LINK sdlSetTextureBlendMode}.

        The texture color is affected based on its color modulation set by
        @{"sdl.SetTextureColorMod()" LINK sdlSetTextureColorMod}.

        The texture alpha is affected based on its alpha modulation set by
        @{"sdl.SetTextureAlphaMod()" LINK sdlSetTextureAlphaMod}.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        tex       identifier of hardware brush
        src       optional: rectangle in the texture to use (defaults to Nil
                  which means use the whole texture)
        dst       optional: rectangle to draw to the display (defaults to Nil
                  which means fill the entire display)
        angle     optional: angle in degrees to apply to the destination
                  rectangle in clockwise direction (defaults to 0)
        center    optional: point around which to rotate the destination
                  rectangle (defaults to Nil which means destination rectangle
                  center)
        flip      optional: flipping actions that should be performed (defaults
                  to #SDL_FLIP_NONE)

@ENDNODE

@NODE sdlRenderDrawLine "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderDrawLine -- draw line

   @{b}SYNOPSIS@{ub}
        sdl.RenderDrawLine(display, x1, y1, x2, y2)

   @{b}FUNCTION@{ub}
        Use this function to draw a line on the current rendering target.

        The current drawing color is set by @{"sdl.SetRenderDrawColor()" LINK sdlSetRenderDrawColor}, and the
        color's alpha value is ignored unless blending is enabled with the
        appropriate call to @{"sdl.SetRenderDrawBlendMode()" LINK sdlSetRenderDrawBlendMode}.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x1        the x coordinate of the start point
        y1        the y coordinate of the start point
        x2        the x coordinate of the end point
        y2        the y coordinate of the end point

@ENDNODE

@NODE sdlRenderDrawPoint "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderDrawPoint -- draw point

   @{b}SYNOPSIS@{ub}
        sdl.RenderDrawPoint(display, x, y)

   @{b}FUNCTION@{ub}
        Use this function to draw a point on the current rendering target.

        The current drawing color is set by @{"sdl.SetRenderDrawColor()" LINK sdlSetRenderDrawColor}, and the
        color's alpha value is ignored unless blending is enabled with the
        appropriate call to @{"sdl.SetRenderDrawBlendMode()" LINK sdlSetRenderDrawBlendMode}.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x         the x coordinate of the point
        y         the y coordinate of the point

@ENDNODE

@NODE sdlRenderDrawRect "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderDrawRect -- draw rectangle outline

   @{b}SYNOPSIS@{ub}
        sdl.RenderDrawRect(display[, x, y, w, h])

   @{b}FUNCTION@{ub}
        Use this function to draw a rectangle on the current rendering target.
        If you leave out the optional arguments, the whole rendering target will
        be outlined.

        The current drawing color is set by @{"sdl.SetRenderDrawColor()" LINK sdlSetRenderDrawColor}, and the
        color's alpha value is ignored unless blending is enabled with the
        appropriate call to @{"sdl.SetRenderDrawBlendMode()" LINK sdlSetRenderDrawBlendMode}.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x         optional: the x coordinate of the upper left corner
        y         optional: the y coordinate of the upper left corner
        w         optional: the rectangle width
        h         optional: the rectangle height

@ENDNODE

@NODE sdlRenderFillRect "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderFillRect -- draw filled rectangle

   @{b}SYNOPSIS@{ub}
        sdl.RenderFillRect(display[, x, y, w, h])

   @{b}FUNCTION@{ub}
        Use this function to fill a rectangle on the current rendering target.
        If you leave out the optional arguments, the whole rendering target will
        be filled.

        The current drawing color is set by @{"sdl.SetRenderDrawColor()" LINK sdlSetRenderDrawColor}, and the
        color's alpha value is ignored unless blending is enabled with the
        appropriate call to @{"sdl.SetRenderDrawBlendMode()" LINK sdlSetRenderDrawBlendMode}.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x         optional: the x coordinate of the upper left corner
        y         optional: the y coordinate of the upper left corner
        w         optional: the rectangle width
        h         optional: the rectangle height

@ENDNODE

@NODE sdlRenderGetClipRect "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderGetClipRect -- get clip rectangle

   @{b}SYNOPSIS@{ub}
        x, y, w, h = sdl.RenderGetClipRect(display)

   @{b}FUNCTION@{ub}
        Use this function to get the clip rectangle for the current target.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        x         the x coordinate of the upper left corner
        y         the y coordinate of the upper left corner
        w         the rectangle width
        h         the rectangle height

@ENDNODE

@NODE sdlRenderGetLogicalSize "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderGetLogicalSize -- get logical size

   @{b}SYNOPSIS@{ub}
        w, h = sdl.RenderGetLogicalSize(display)

   @{b}FUNCTION@{ub}
        Use this function to get device independent resolution for rendering. If
        this function is called on a renderer which never had its logical size
        set by @{"sdl.RenderSetLogicalSize()" LINK sdlRenderSetLogicalSize}, this function returns 0 in both "w"
        and "h".

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        w         the width of the logical resolution
        h         the height of the logical resolution

@ENDNODE

@NODE sdlRenderGetScale "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderGetScale -- get scaling factors

   @{b}SYNOPSIS@{ub}
        scalex, scaley = sdl.RenderGetScale(display)

   @{b}FUNCTION@{ub}
        Use this function to get the drawing scale for the current target.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        scalex    the horizontal scaling factor
        scaley    the vertical scaling factor

@ENDNODE

@NODE sdlRenderGetViewport "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderGetViewport -- get viewport

   @{b}SYNOPSIS@{ub}
        x, y, w, h = sdl.RenderGetViewport(display)

   @{b}FUNCTION@{ub}
        Use this function to get the drawing area for the current target.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

   @{b}RESULTS@{ub}
        x         the x coordinate of the upper left corner
        y         the y coordinate of the upper left corner
        w         the rectangle width
        h         the rectangle height

@ENDNODE

@NODE sdlRenderPresent "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderPresent -- flip buffers

   @{b}SYNOPSIS@{ub}
        sdl.RenderPresent(display)

   @{b}FUNCTION@{ub}
        Use this function to update the screen with any rendering performed
        since the previous call.

        SDL's rendering functions operate on a backbuffer; that is, calling a
        rendering function such as @{"sdl.RenderDrawLine()" LINK sdlRenderDrawLine} does not directly put a
        line on the screen, but rather updates the backbuffer. As such, you
        compose your entire scene and present the composed backbuffer to the
        screen as a complete picture.

        Therefore, when using SDL's rendering API, one does all drawing intended
        for the frame, and then calls this function once per frame to present
        the final drawing to the user.

        The backbuffer should be considered invalidated after each present; do
        not assume that previous contents will exist between frames. You are
        strongly encouraged to call @{"sdl.RenderClear()" LINK sdlRenderClear} to initialize the
        backbuffer before starting each new frame's drawing, even if you plan to
        overwrite every pixel.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used

@ENDNODE

@NODE sdlRenderSetClipRect "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderSetClipRect -- set clip rectangle

   @{b}SYNOPSIS@{ub}
        sdl.RenderSetClipRect(display[, x, y, w, h])

   @{b}FUNCTION@{ub}
        Use this function to set the clip rectangle for rendering on the
        specified target. If you leave out the optional arguments, clipping will
        be disabled.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x         optional: the x coordinate of the upper left corner
        y         optional: the y coordinate of the upper left corner
        w         optional: the rectangle width
        h         optional: the rectangle height

@ENDNODE

@NODE sdlRenderSetLogicalSize "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderSetLogicalSize -- set logical size

   @{b}SYNOPSIS@{ub}
        sdl.RenderSetLogicalSize(display, w, h)

   @{b}FUNCTION@{ub}
        Use this function to set a device independent resolution for rendering.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        w         the width of the logical resolution
        h         the height of the logical resolution

@ENDNODE

@NODE sdlRenderSetScale "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderSetScale -- set scaling factors

   @{b}SYNOPSIS@{ub}
        sdl.RenderSetScale(display, scalex, scaley)

   @{b}FUNCTION@{ub}
        Use this function to set the drawing scale for rendering on the current
        target. The drawing coordinates are scaled by the x/y scaling factors
        before they are used by the renderer. This allows resolution independent
        drawing with a single coordinate system.

        If this results in scaling or subpixel drawing by the rendering backend,
        it will be handled using the appropriate quality hints. For best results
        use integer scaling factors.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        scalex    the horizontal scaling factor
        scaley    the vertical scaling factor

@ENDNODE

@NODE sdlRenderSetViewport "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.RenderSetViewport -- set viewport

   @{b}SYNOPSIS@{ub}
        sdl.RenderSetViewport(display[, x, y, w, h])

   @{b}FUNCTION@{ub}
        Use this function to set the drawing area for rendering on the current
        target. If you leave out the optional arguments, the viewport is set to
        the entire target. When the window is resized, the current viewport is
        automatically centered within the new window size.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        x         optional: the x coordinate of the upper left corner
        y         optional: the y coordinate of the upper left corner
        w         optional: the rectangle width
        h         optional: the rectangle height

@ENDNODE

@NODE sdlSetRenderDrawBlendMode "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetRenderDrawBlendMode -- set draw blend mode

   @{b}SYNOPSIS@{ub}
        sdl.SetRenderDrawBlendMode(display, blendmode)

   @{b}FUNCTION@{ub}
        Use this function to set the blend mode used for drawing operations
        (fill and line).

        #SDL_BLENDMODE_NONE
                  no blending

                      dstRGBA = srcRGBA

        #SDL_BLENDMODE_BLEND
                  alpha blending

                      dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
                      dstA = srcA + (dstA * (1-srcA))

        #SDL_BLENDMODE_ADD
                  additive blending

                      dstRGB = (srcRGB * srcA) + dstRGB
                      dstA = dstA

        #SDL_BLENDMODE_MOD
                  color modulate

                      dstRGB = srcRGB * dstRGB
                      dstA = dstA

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        blendmode one of the blend modes from above

@ENDNODE

@NODE sdlSetRenderDrawColor "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetRenderDrawColor -- set draw color

   @{b}SYNOPSIS@{ub}
        sdl.SetRenderDrawColor(display, r, g, b[, a])

   @{b}FUNCTION@{ub}
        Use this function to set the color for drawing or filling rectangles,
        lines, and points, and for @{"sdl.RenderClear()" LINK sdlRenderClear}.

        If you want to have alpha blending, use @{"sdl.SetRenderDrawBlendMode()" LINK sdlSetRenderDrawBlendMode} to
        specify how the alpha channel is used.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        r         the red value used to draw on the rendering target (ranging
                  from 0 to 255)
        g         the green value used to draw on the rendering target (ranging
                  from 0 to 255)
        b         the blue value used to draw on the rendering target (ranging
                  from 0 to 255)
        a         optional: the alpha value used to draw on the rendering target
                  (defaults to #SDL_ALPHA_OPAQUE)

@ENDNODE

@NODE sdlSetRenderTarget "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetRenderTarget -- set render target

   @{b}SYNOPSIS@{ub}
        sdl.SetRenderTarget(display[, tex])

   @{b}FUNCTION@{ub}
        Use this function to set a texture as the current rendering target. The
        "tex" argument must simply be the identifier of a hardware brush. If you
        leave out the "tex" argument, the default render target is used.

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        tex       optional: hardware brush to use as target

@ENDNODE

@NODE sdlSetScaleQuality "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetScaleQuality -- set texture scale quality (V1.1)

   @{b}SYNOPSIS@{ub}
        sdl.SetScaleQuality(q$)

   @{b}FUNCTION@{ub}
        This function can be used to specify how textures (or Hollywood hardware
        brushes, they are stored as textures internally) should be scaled. You
        have to pass a string in the "q$" argument. The following scale modes
        are currently supported:

        nearest:  No interpolation.

        linear:   Linear filtering.

        best:     Anisotropic filtering. This is currently only supported on
                  Windows with Direct 3D.

        Note that the scale mode is set when a texture (or hardware brush) is
        created so you need to call sdl.SetScaleQuality() before creating a
        hardware brush/texture. This also means that you cannot use it for
        brushes loaded in the preprocessor commands because those will always be
        loaded before the script execution starts.

   @{b}INPUTS@{ub}
        q$        desired scale quality (see above for possible values)

@ENDNODE

@NODE sdlSetTextureAlphaMod "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetTextureAlphaMod -- set texture alpha modulation

   @{b}SYNOPSIS@{ub}
        r = sdl.SetTextureAlphaMod(tex, alpha)

   @{b}FUNCTION@{ub}
        Use this function to set an additional alpha value multiplied into
        render copy operations. When this texture is rendered, during the copy
        operation the source alpha value is modulated by this alpha value
        according to the following formula:

            srcA = srcA * (alpha / 255)

        Note that alpha modulation is not always supported by the renderer; it
        will return -1 if alpha modulation is not supported.

        The "tex" argument must simply be the identifier of a hardware brush.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush
        alpha     the source alpha value multiplied into copy operations
                  (ranging from 0 to 255)

   @{b}RESULTS@{ub}
        r         0 on success or a negative error code on failure

@ENDNODE

@NODE sdlSetTextureBlendMode "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetTextureBlendMode -- set texture blend mode

   @{b}SYNOPSIS@{ub}
        r = sdl.SetTextureBlendMode(tex, blendmode)

   @{b}FUNCTION@{ub}
        Use this function to set the blend mode for a texture, used by
        @{"sdl.RenderCopy()" LINK sdlRenderCopy}.

        "blendmode" may be one of the following:

        #SDL_BLENDMODE_NONE
                  no blending

                      dstRGBA = srcRGBA

        #SDL_BLENDMODE_BLEND
                  alpha blending

                      dstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))
                      dstA = srcA + (dstA * (1-srcA))

        #SDL_BLENDMODE_ADD
                  additive blending

                      dstRGB = (srcRGB * srcA) + dstRGB
                      dstA = dstA

        #SDL_BLENDMODE_MOD
                  color modulate

                      dstRGB = srcRGB * dstRGB
                      dstA = dstA

        If the blend mode is not supported, the closest supported mode is chosen
        and this function returns -1. The "tex" argument must simply be the
        identifier of a hardware brush.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush
        blendmode the blend mode to use for texture blending (see above)

   @{b}RESULTS@{ub}
        r         0 on success or a negative error code on failure

@ENDNODE

@NODE sdlSetTextureColorMod "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetTextureColorMod -- set texture color modulation

   @{b}SYNOPSIS@{ub}
        r = sdl.SetTextureColorMod(tex, r, g, b)

   @{b}FUNCTION@{ub}
        Use this function to set an additional color value multiplied into
        render copy operations. When this texture is rendered, during the copy
        operation each source color channel is modulated by the appropriate
        color value according to the following formula:

            srcC = srcC * (color / 255)

        Color modulation is not always supported by the renderer; it will return
        -1 if color modulation is not supported.

        The "tex" argument must simply be the identifier of a hardware brush.

   @{b}INPUTS@{ub}
        tex       identifier of hardware brush
        r         the red color value multiplied into copy operations (ranging
                  from 0 to 255)
        g         the green color value multiplied into copy operations (ranging
                  from 0 to 255)
        b         the blue color value multiplied into copy operations (ranging
                  from 0 to 255)

   @{b}RESULTS@{ub}
        r         0 on success or a negative error code on failure

@ENDNODE

@NODE sdlClearError "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.ClearError -- clear last error

   @{b}SYNOPSIS@{ub}
        sdl.ClearError()

   @{b}FUNCTION@{ub}
        Use this function to clear any previous error message.

   @{b}INPUTS@{ub}
        none

@ENDNODE

@NODE sdlGetCurrentVideoDriver "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetCurrentVideoDriver -- get current video driver

   @{b}SYNOPSIS@{ub}
        d$ = sdl.GetCurrentVideoDriver()

   @{b}FUNCTION@{ub}
        This function returns the name of the current video driver, e.g.
        "windows", "cocoa", "x11", etc.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        d$        name of the current video driver

@ENDNODE

@NODE sdlGetError "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetError -- get last error

   @{b}SYNOPSIS@{ub}
        e$ = sdl.GetError()

   @{b}FUNCTION@{ub}
        Returns a message with information about the specific error that
        occurred, or an empty string if there hasn't been an error message set
        since the last call to @{"sdl.ClearError()" LINK sdlClearError}. The message is only applicable
        when an SDL function has signaled an error. You must check the return
        values of SDL function calls to determine when to appropriately call
        sdl.GetError().

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        e$        last error message or empty string

@ENDNODE

@NODE sdlGetVersion "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.GetVersion -- get SDL version

   @{b}SYNOPSIS@{ub}
        ver, rev, patch = sdl.GetVersion()

   @{b}FUNCTION@{ub}
        Use this function to get the version of SDL that is linked against your
        program.

   @{b}INPUTS@{ub}
        none

   @{b}RESULTS@{ub}
        ver       major version
        rev       minor version
        patch     update version (patch level)

@ENDNODE

@NODE sdlSetWindowFullscreen "RebelSDL Guide"

   @{b}NAME@{ub}
        sdl.SetWindowFullscreen -- switch display mode

   @{b}SYNOPSIS@{ub}
        sdl.SetWindowFullscreen(display, mode)

   @{b}FUNCTION@{ub}
        Use this function to set a window's fullscreen state.

        "mode" must be one of the following predefined constants:

        #SDL_WINDOW_FULLSCREEN
                  Real fullscreen with a videomode change

        #SDL_WINDOW_FULLSCREEN_DESKTOP
                  Fake fullscreen that takes the size of the desktop

        #SDL_WINDOW_WINDOW
                  Windowed mode

   @{b}INPUTS@{ub}
        display   identifier of display whose renderer should be used
        mode      new display mode

@ENDNODE

@NODE LicenseSDL "RebelSDL Guide"
@{b}SDL license@{ub}

    Simple DirectMedia Layer Copyright (C) 1997-2016 Sam Lantinga
    <slouken\@libsdl.org>

    This software is provided 'as-is', without any express or implied warranty.
    In no event will the authors be held liable for any damages arising from the
    use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute it
    freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
       claim that you wrote the original software. If you use this software in a
       product, an acknowledgment in the product documentation would be
       appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
       misrepresented as being the original software.

    3. This notice may not be removed or altered from any source distribution.

@ENDNODE

@NODE JoystickFunctions "RebelSDL Guide"
@{b}Joystick reference@{ub}

    @{"sdl.ForceJoystickMode()                   " LINK sdlForceJoystickMode} Force game controller into joystick mode
    @{"sdl.GetAxis()                             " LINK sdlGetAxis} Query state of specified axis
    @{"sdl.GetBall()                             " LINK sdlGetBall} Query state of specified ball
    @{"sdl.GetButton()                           " LINK sdlGetButton} Query state of specified button
    @{"sdl.GetHat()                              " LINK sdlGetHat} Query state of specified hat
    @{"sdl.GetJoysticks()                        " LINK sdlGetJoysticks} Get number of available joysticks
    @{"sdl.GetNumAxes()                          " LINK sdlGetNumAxes} Get number of joystick axes
    @{"sdl.GetNumBalls()                         " LINK sdlGetNumBalls} Get number of joystick balls
    @{"sdl.GetNumButtons()                       " LINK sdlGetNumButtons} Get number of joystick buttons
    @{"sdl.GetNumHats()                          " LINK sdlGetNumHats} Get number of joystick hats
    @{"sdl.IsGameController()                    " LINK sdlIsGameController} Check if input device is a game controller

@ENDNODE

@NODE KeyboardFunctions "RebelSDL Guide"
@{b}Keyboard reference@{ub}

    @{"sdl.SetTextInputRect()                    " LINK sdlSetTextInputRect} Set the rectangle used to type Unicode text inputs
    @{"sdl.StartTextInput()                      " LINK sdlStartTextInput} Start accepting Unicode text events
    @{"sdl.StopTextInput()                       " LINK sdlStopTextInput} Stop receiving Unicode text events

@ENDNODE

@NODE RendererFunctions "RebelSDL Guide"
@{b}Renderer reference@{ub}

    @{"sdl.EnableOffscreenRender()               " LINK sdlEnableOffscreenRender} Enable hardware brush offscreen rendering
    @{"sdl.GetCurrentRenderDriver()              " LINK sdlGetCurrentRenderDriver} Get current render driver
    @{"sdl.GetRenderDrawBlendMode()              " LINK sdlGetRenderDrawBlendMode} Get draw blend mode
    @{"sdl.GetRenderDrawColor()                  " LINK sdlGetRenderDrawColor} Get draw color
    @{"sdl.GetRendererOutputSize()               " LINK sdlGetRendererOutputSize} Get renderer output size
    @{"sdl.GetTextureAlphaMod()                  " LINK sdlGetTextureAlphaMod} Get texture alpha modulation
    @{"sdl.GetTextureBlendMode()                 " LINK sdlGetTextureBlendMode} Get texture blend mode
    @{"sdl.GetTextureColorMod()                  " LINK sdlGetTextureColorMod} Get texture color modulation
    @{"sdl.RenderClear()                         " LINK sdlRenderClear} Clear target
    @{"sdl.RenderCopy()                          " LINK sdlRenderCopy} Draw texture
    @{"sdl.RenderDrawLine()                      " LINK sdlRenderDrawLine} Draw line
    @{"sdl.RenderDrawPoint()                     " LINK sdlRenderDrawPoint} Draw point
    @{"sdl.RenderDrawRect()                      " LINK sdlRenderDrawRect} Draw rectangle outline
    @{"sdl.RenderFillRect()                      " LINK sdlRenderFillRect} Draw filled rectangle
    @{"sdl.RenderGetClipRect()                   " LINK sdlRenderGetClipRect} Get clip rectangle
    @{"sdl.RenderGetLogicalSize()                " LINK sdlRenderGetLogicalSize} Get logical size
    @{"sdl.RenderGetScale()                      " LINK sdlRenderGetScale} Get scaling factors
    @{"sdl.RenderGetViewport()                   " LINK sdlRenderGetViewport} Get viewport
    @{"sdl.RenderPresent()                       " LINK sdlRenderPresent} Flip buffers
    @{"sdl.RenderSetClipRect()                   " LINK sdlRenderSetClipRect} Set clip rectangle
    @{"sdl.RenderSetLogicalSize()                " LINK sdlRenderSetLogicalSize} Set logical size
    @{"sdl.RenderSetScale()                      " LINK sdlRenderSetScale} Set scaling factors
    @{"sdl.RenderSetViewport()                   " LINK sdlRenderSetViewport} Set viewport
    @{"sdl.SetRenderDrawBlendMode()              " LINK sdlSetRenderDrawBlendMode} Set draw blend mode
    @{"sdl.SetRenderDrawColor()                  " LINK sdlSetRenderDrawColor} Set draw color
    @{"sdl.SetRenderTarget()                     " LINK sdlSetRenderTarget} Set render target
    @{"sdl.SetScaleQuality()                     " LINK sdlSetScaleQuality} Set texture scale quality
    @{"sdl.SetTextureAlphaMod()                  " LINK sdlSetTextureAlphaMod} Set texture alpha modulation
    @{"sdl.SetTextureBlendMode()                 " LINK sdlSetTextureBlendMode} Set texture blend mode
    @{"sdl.SetTextureColorMod()                  " LINK sdlSetTextureColorMod} Set texture color modulation

@ENDNODE

@NODE SystemFunctions "RebelSDL Guide"
@{b}System reference@{ub}

    @{"sdl.ClearError()                          " LINK sdlClearError} Clear last error
    @{"sdl.GetCurrentVideoDriver()               " LINK sdlGetCurrentVideoDriver} Get current video driver
    @{"sdl.GetError()                            " LINK sdlGetError} Get last error
    @{"sdl.GetVersion()                          " LINK sdlGetVersion} Get SDL version

@ENDNODE

@NODE WindowFunctions "RebelSDL Guide"
@{b}Window reference@{ub}

    @{"sdl.SetWindowFullscreen()                 " LINK sdlSetWindowFullscreen} Switch display mode

@ENDNODE

@NODE Reference "RebelSDL Guide"
@{b}Reference@{ub}

    @{"Activating RebelSDL                       " LINK ActivatePlugin} How to use RebelSDL from your script
    @{"Credits                                   " LINK Credits} Who was involved in this project?
    @{"Drawing graphics                          " LINK HowToDraw} The basics on OpenGL drawing
    @{"F.A.Q.                                    " LINK FAQ} Frequently asked questions
    @{"Future                                    " LINK ToDo} What is planned for the future?
    @{"History                                   " LINK History} What happened so far?
    @{"Increasing execution speed                " LINK MoreSpeed} Ideas for making your script faster
    @{"Installation                              " LINK Installation} How to install RebelSDL
    @{"Introduction                              " LINK Introduction} What is RebelSDL?
    @{"Joysticks and game controllers            " LINK JoystickNote} Querying game controllers with RebelSDL
    @{"Known issues                              " LINK KnownIssues} List of things that can cause trouble
    @{"Offscreen rendering                       " LINK OffscreenRender} Accelerated drawing to hardware brushes
    @{"Raspberry Pi peculiarities                " LINK RaspberryPi} Important information for using RebelSDL on the Pi
    @{"RebelSDL as a helper plugin               " LINK SDLGlue} Using RebelSDL as a patch for Hollywood deficits
    @{"RebelSDL examples                         " LINK Examples} Description of included examples
    @{"Requirements                              " LINK Requirements} What you need to work with it
    @{"sdl.ClearError()                          " LINK sdlClearError} Clear last error
    @{"sdl.EnableOffscreenRender()               " LINK sdlEnableOffscreenRender} Enable hardware brush offscreen rendering
    @{"sdl.ForceJoystickMode()                   " LINK sdlForceJoystickMode} Force game controller into joystick mode
    @{"sdl.GetAxis()                             " LINK sdlGetAxis} Query state of specified axis
    @{"sdl.GetBall()                             " LINK sdlGetBall} Query state of specified ball
    @{"sdl.GetButton()                           " LINK sdlGetButton} Query state of specified button
    @{"sdl.GetCurrentRenderDriver()              " LINK sdlGetCurrentRenderDriver} Get current render driver
    @{"sdl.GetCurrentVideoDriver()               " LINK sdlGetCurrentVideoDriver} Get current video driver
    @{"sdl.GetError()                            " LINK sdlGetError} Get last error
    @{"sdl.GetHat()                              " LINK sdlGetHat} Query state of specified hat
    @{"sdl.GetJoysticks()                        " LINK sdlGetJoysticks} Get number of available joysticks
    @{"sdl.GetNumAxes()                          " LINK sdlGetNumAxes} Get number of joystick axes
    @{"sdl.GetNumBalls()                         " LINK sdlGetNumBalls} Get number of joystick balls
    @{"sdl.GetNumButtons()                       " LINK sdlGetNumButtons} Get number of joystick buttons
    @{"sdl.GetNumHats()                          " LINK sdlGetNumHats} Get number of joystick hats
    @{"sdl.GetRenderDrawBlendMode()              " LINK sdlGetRenderDrawBlendMode} Get draw blend mode
    @{"sdl.GetRenderDrawColor()                  " LINK sdlGetRenderDrawColor} Get draw color
    @{"sdl.GetRendererOutputSize()               " LINK sdlGetRendererOutputSize} Get renderer output size
    @{"sdl.GetTextureAlphaMod()                  " LINK sdlGetTextureAlphaMod} Get texture alpha modulation
    @{"sdl.GetTextureBlendMode()                 " LINK sdlGetTextureBlendMode} Get texture blend mode
    @{"sdl.GetTextureColorMod()                  " LINK sdlGetTextureColorMod} Get texture color modulation
    @{"sdl.GetVersion()                          " LINK sdlGetVersion} Get SDL version
    @{"sdl.IsGameController()                    " LINK sdlIsGameController} Check if input device is a game controller
    @{"sdl.RenderClear()                         " LINK sdlRenderClear} Clear target
    @{"sdl.RenderCopy()                          " LINK sdlRenderCopy} Draw texture
    @{"sdl.RenderDrawLine()                      " LINK sdlRenderDrawLine} Draw line
    @{"sdl.RenderDrawPoint()                     " LINK sdlRenderDrawPoint} Draw point
    @{"sdl.RenderDrawRect()                      " LINK sdlRenderDrawRect} Draw rectangle outline
    @{"sdl.RenderFillRect()                      " LINK sdlRenderFillRect} Draw filled rectangle
    @{"sdl.RenderGetClipRect()                   " LINK sdlRenderGetClipRect} Get clip rectangle
    @{"sdl.RenderGetLogicalSize()                " LINK sdlRenderGetLogicalSize} Get logical size
    @{"sdl.RenderGetScale()                      " LINK sdlRenderGetScale} Get scaling factors
    @{"sdl.RenderGetViewport()                   " LINK sdlRenderGetViewport} Get viewport
    @{"sdl.RenderPresent()                       " LINK sdlRenderPresent} Flip buffers
    @{"sdl.RenderSetClipRect()                   " LINK sdlRenderSetClipRect} Set clip rectangle
    @{"sdl.RenderSetLogicalSize()                " LINK sdlRenderSetLogicalSize} Set logical size
    @{"sdl.RenderSetScale()                      " LINK sdlRenderSetScale} Set scaling factors
    @{"sdl.RenderSetViewport()                   " LINK sdlRenderSetViewport} Set viewport
    @{"sdl.SetRenderDrawBlendMode()              " LINK sdlSetRenderDrawBlendMode} Set draw blend mode
    @{"sdl.SetRenderDrawColor()                  " LINK sdlSetRenderDrawColor} Set draw color
    @{"sdl.SetRenderTarget()                     " LINK sdlSetRenderTarget} Set render target
    @{"sdl.SetScaleQuality()                     " LINK sdlSetScaleQuality} Set texture scale quality
    @{"sdl.SetTextInputRect()                    " LINK sdlSetTextInputRect} Set the rectangle used to type Unicode text inputs
    @{"sdl.SetTextureAlphaMod()                  " LINK sdlSetTextureAlphaMod} Set texture alpha modulation
    @{"sdl.SetTextureBlendMode()                 " LINK sdlSetTextureBlendMode} Set texture blend mode
    @{"sdl.SetTextureColorMod()                  " LINK sdlSetTextureColorMod} Set texture color modulation
    @{"sdl.SetWindowFullscreen()                 " LINK sdlSetWindowFullscreen} Switch display mode
    @{"sdl.StartTextInput()                      " LINK sdlStartTextInput} Start accepting Unicode text events
    @{"sdl.StopTextInput()                       " LINK sdlStopTextInput} Stop receiving Unicode text events
    @{"Terms and conditions                      " LINK License} License information
    @{"Using a hardware doublebuffer             " LINK HardwareDB} All scripts need to be double-buffered
    @{"Using hardware brushes                    " LINK HardwareBrushes} Benefit from hardware-accelerated blitting
    @{"Using the SDL renderer                    " LINK SDLRender} Important information for advanced users

@ENDNODE
