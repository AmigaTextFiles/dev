
		Notes On The Amiga Shopper Demo
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 Amiga Shopper offered to put disk one of the ACC Manual onto the cover of a
future edition. This first disk contains all the utilities used by the manual
and a beginners guide to assembly language. There is no hardware specific
code to be found, so what was needed was a little demo that shows some of the
subjects covered. Enter this source.

 My main objective was to have a scroll text at the bottom of the display, a
logo at the top and things happening in the middle. The scroll text needed to
support two embedded characters, one to pause the display and the other to
signal that the next part of the demo should start. This was not to difficult
and I elected to use a '1' to signal next part start and a '2' to insert a
pause. The '2' is followed by the number of frames to pause for, one byte,
meaning that a single pause can last up to 5 seconds ( 255 frames is approx
5 seconds on a PAL machine ).

 Having decided that an embedded '1' was to signal the start of the next part
I needed a means of implementing this. The simplest way was to use a vector
table in which successive entries point to sucess parts of the demo, when the
scroll text reads a '1' byte, it simply loads the next vector from the table.

 The level 3 interrupt routine gels everything together. The first task 
performed is to check if next part should be run, this is handled by the
subroutine 'CheckSwitch'. If the next part is to be run, it's vector is
read and stored in the variable 'CurrentRoutine'. The address stored in
'CurrentRoutine' is then called as a subroutine.

 The level 3 handler finishes by calling the scroll text routine and clearing
the interrupt request. Should the scroll text routine read a '1' it will set
a flag that will cause 'CheckSwitch' to read the vector for the next part at
the start of the next interrupt.

 The section of code described above was written and tested. Successive parts
of the demo simply changed the background colour. Once I new the program
control code worked, I started working on each part of the module. My
intention was to start with a blank screen and start adding to it as things
were explained in the scroll text.

 Part 1: Setting The Blue Copper Bars
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Piece of cake! The Copper list contains a sequence of Wait, Move commands
that alter the background colour at the start of each scan line for the
bottom section of the display. When the program starts, each Move instruction
is setting a Black background. The first code module simply copies colour
values from a table into the Copper list, one value each interrupt. The net
effect is that the blue bars seem to scroll into exsistence just as the scroll
text announces their presence.

 Part 2: Scrolling The Blue Copper Bars
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Again only a simple routine was required for this. The code copies the colour
values defined in the Copper list up one line each interrupt. This is done
using a simple processor loop.

 Part 3: Play Music
 ~~~~~~~~~~~~~~~~~~
 No prizes! All the third part does is call the replayer code.
 
 Part 4: Show Logo
 ~~~~~~~~~~~~~~~~~
 When the program first starts the Copper list is initialised so that the top
two sections of the display both show the sames empty bitplanes. To show the
logo, the bitplane pointers for the top section are set to point to the logo
graphics.

 Part 5: Text
 ~~~~~~~~~~~~
 The text routines used in the demo are the ones I threw together some time
ago. Info on how the routines work can be found in the include file
'HW_Text.i'.

 Part 6: Screen Wipe
 ~~~~~~~~~~~~~~~~~~~
 An attempt at a not-so-boring screen wipe that failed:-) The Blitter is used
to copy the screen data to itself using a mask that has a 1 pixel hole in it.
Each time the routine is called, the mask is shifted resulting in the next
vertical strip of pixels being wiped. A delay is used by the routine so that
it takes a second or so for the screen to be completly wiped.

 Part 7: PacMan Sprite Right
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~
 As part of the manual, routines were developed to simplify the display,
movement and animation of sprites. These routines are used to animate two
normal sprites across the screen from left to right. Probably the most useful
sprite routine is the one which converts X,Y coords into hardware sprite
control words, this can be found in 'HW_Sprites.i' along with other sprite
code.

 Part 8: PacMan Sprite Left
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 As above, except a 16 colour sprite, wider than 16 pixels is displayed. This
is achieved using 4 hardware sprites in attach mode and moving them all as
one object.

 Part 9: Sprite Star Fields
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 To display a star field, reuse a sprite DMA channel and diplay points at
different x positions down the screen. To move the stars, simply bump the x
position once every interrupt. This code uses two sprites, so two fields of
different colours are visible. One field is also moved faster than the other
to give the illusion of depth.

 Part 10: Vector Balls
 ~~~~~~~~~~~~~~~~~~~~~
 This part displays 24 balls on the screen using the Blitter. A list of x,y,z
coordinates are maintained for the balls and are passed to a generic rotate
routine and then a generic sort routine, both found in 'HW_Rotate.i', to
produce a list of depth sorted points. This ensures the illusion of depth is
maintained.

 The screen clear code relies upon the min x and y values in the list. Rather
than clear the position at which each bob appears, a section 3 words wide and
48 lines high is cleared. This minimises the amount of calculation required
just to clear the screen!

 Part 11: User Controlled Vector Balls
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Routines for reading the mouse are supplied in 'HW_Input.i', this part just
monitors mouse movements and updates the x,y position of the center of
rotation of the balls based on mouse moves.

 Part 12: 3D Vectors
 ~~~~~~~~~~~~~~~~~~~
 Routines for displaying 3D objects can be found in 'HW_Rotate.i', this part
uses the routines to display a rotating pyramid. By using negative screen
modulos, the object is reflected in the bottom half of the display.

 Part 13: Text
 ~~~~~~~~~~~~~
 Yet more text! Had to fill the scren with something while the scroller
trudged through the greets list:-)

 Part 14: Screen Copy
 ~~~~~~~~~~~~~~~~~~~~
 Easy or what! One line of pixels is copied from bitplane1 into two
consecutive lines of bitplane 2. The net effect is a stretched image of the
top section of the display in the middle section, that is still being
reflected.

 Part 15: Flash
 ~~~~~~~~~~~~~~
 By flashing the middle section of the screen I ensure the viewer soon
becomes very irritated and presses the left mouse button. The flash is
achieved by NOTing a colour value in the Copper list.

 Well that's it really. I threw it all together on an A1200, sat back and
watched it run and thought that was the end of it! In truth, some routines
had to be fiddled with to get it to run on an A500 without any flashing.
If you look at the code there is no double-buffering used, so loads more
could be done if the source was altered accordingly!

							Mark.


























