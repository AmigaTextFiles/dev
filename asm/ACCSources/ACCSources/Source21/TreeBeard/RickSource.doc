----------------------------------------------------------------------------


Recently I restarted (for the third time) a successor to Helper V1.0 (as seen
on ACC 10).  I got everything working fine.  Then it started crashing when I
closed the window once the gadgets were added.  I then added Steve Marshall's
CloseWindowSafely, so that now the window closes fine but the program cocks
up on the gadgets (which worked fine before).  I've included this, without
any doc since it aint complete, so perhaps someone like Mark or Steve might
give it a bit of a post-mortem.  This has put me off the system so since then
I've just stuck to the hardware.

----------------------------------------------------------------------------

SECTOR CONTROL
~~~~~~~~~~~~~~
This is the result of messing about with the trackdisk device.  It is a util
so that you can load an ORGed program (ie. a program which has been assembled
at a fixed address with DevPac) and save it in any sector on the disk,
helping the creating of non-system disks.  There's also a facility of loading
binary data in and saving that in the same way.

LOAD:		Load an ORGed program - the programs are saved with a
	20-byte long DOS hunk at the start, so its just a case of loading
	it in and writing the data 20 bytes from the start of the file.

LOAD BINARY:	Load in a file and write it just as it is

WRITE:		Write the data to the disk at the sector given.  The sector
	number is 0-1759, given by the formula

	Sector + Surface*11 + Track*22
	(0-10)   (0 or 1)     (0-79)

Simple program really - even so there are some bugs (what a Lamer, eh?):
Sometimes nothing is saved, sometimes something is saved, but it starts at
the wrong address (eg. sometimes misses a byte), and sometimes its fine.
(Its the system again- all my system stuff seems to have bugs whereas
hardly any hardware stuff has).

Now onto the real (hardware) stuff:


3D VECTOR BOBS
~~~~~~~~~~~~~~
Ages ago I tried a 3D rotater (except the object itself was only 2D) and
it was a flop.  As a result of reading Mark's tutorial and wanting to
redeem the embarrasing contribution to ACC, I wrote this to prove I can
actually do a decent rotation.

The source is all my own (although Shadow's (or whatever he's called) is
probably better, I wanted to see if I could write one of my own).  There's
no point in saying much about it since Mark has said it all before.


ISOMETRIC 3-D
~~~~~~~~~~~~~
I bought the Zero mag, and was impressed with the Populous II demo (how long
will it be before THAT's cracked?  [Late addition: Ages ago]).  And I thought
that a (flat) 3D landscape in a similar vein as Populous shouldn't be too
difficult.  This is the result.  It hasn't been polished up since it is only
intended to be part of a later project (it flickers since the whole screen is
cleared instead of just the part which the landscape covers, and also it is
in 32 colours, though less than 16 are used - will add more blocks (needing
more colours) later.

What are the advantages of this type of 3D?  Well, it looks pretty
impressive (so you can get away with pretty naf graphics - as you'll
see when you run it), and is the easiest type of 3D to do.  Its really
just an extension of the good old tile screens.

THE WAY IT WORKS

The blocks: In this demo, the bases are 32 pixels wide by 15 down.  The
	blocks can be as high as you like (within reason) - blocks are
	joined together by the bases so that the height doesn't matter.

The map: You also need a map, laid out in the following way:

	MAP ---	1 1 0 0 0 1 1
		1 1 0 0 0 0 1
		1 1 0 0 0 1 1
		1 0 0 0 0 1 1
		1 0 0 0 0 1 1
		1 0 0 0 0 1 1

	The 3D is just the map tilted at 45° to the right

	3D ---		1
		      1   1
		    1   1   0
		  1   1   0   0
		1   0   0   0   0
	      1   0   0   0   0   1
		0   0   0   0   0
		  0   0   0   1
		    0   0   1
		      0   1
			1

	Going horizontally, the number added to the current map pointer
	is the Map's width -1.  In the top half, the start of the line
	is on the left edge, in the bottom half it's on the bottom edge
	So that's how you work out which block you're supposed to display

Displaying the Block: The width of the block is 32, the height is 15
	Since the blocks have got to mesh neatly together, in the top
	half, you need to move down 8 (15/2) lines and left 16 pixels
	(32/2) to get to the next line.  In the bottom half, move 8
	pixels down and 16 right.

	To display the block
	1. Create the mask for the block you want to display
	   - see Raistlin's Mask Maker on ACC15 (I think)
	2. Since the blocks can be any height, the position on the
	   screen must sometimes be modified:
		eg. a totally flat block (soil, water, etc.) has
		    a height of 15.  A block with a stick jutting out
		    of it might have a height of 20.  If this is displayed
		    at the same place as the soil would be, it would be too
		    low - it should be displayed 5 (20-15) lines higher.
	3. Display it using cookie cut routines



16 COLOUR PARALLAX SCROLLER
~~~~~~~~~~~~~~~~~~~~~~~~~~~
No shoot-em-up seems to be complete without a parallax background these days,
and none of them seem to use dual playfields (the main screen has more than
8 colours).  In fact it is simpler to have a 2 colour parallax screen without
using dual playfields at all.

Take a 16 colour screen with a 2 colour parallax.  This means 5 (4+1)
bitplanes.  This is really what we are doing, creating a 32 colour screen,
but the bitplanes move at different speeds.  With a 16 colour screen
bitplanes 1-4 will be the main screen and bitplane 5 the parallax.  Therefore
bitplanes 1-4 can move at one speed and bitplane 5 at another.

The most important bit is the arrangement of the colour.  The parallax
screen should only show through on colour 0 of the main screen.  Since for
colours 1-15 the bit in the 5th bitplane could be either 0 or 1, and the
resultant colour should be the same either way, colours 17-31 should be
the same as colours 1-15.  Colours 0 and 16 are the parallax screen's
two colours.

Take a smaller example, 4 colour screen with 2 colour parallax.  The
main screen has these colours:

	0	$000
	1	$c20
	2	$472
	3	$333

And the parallax screen has colours

	0	$025
	1	$052

The result would be

	0	$025	; Colour 0 is for the parallax
	1	$c20	; Colours 1-3 are the main screen's
	2	$472
	3	$333
	4	$052	; Colour 4 = Colour 1 of parallax
	5	$c20	; Colours 5-7 = Colours 1-3
	6	$472
	7	$333

THE CODE

For those who haven't done a continuous vertical screen scroller before, it
revolves round the copper list.  Set up the bitplanes in the usual way

; Main Screen's bitplanes
	dc.w	bpl1ptl
b1l	dc.w	0,bpl1pth
b1h	dc.w	0,bpl2ptl
b2l	dc.w	0,bpl2pth
b2h	dc.w	0

After all the colour definitions, we need to have a wait instruction which
will reset the bitplane pointers (eg. when we have scrolled half of the
screen, we need to reset the bitplanes to the start of the screen half way
down the screen).

ResetBPLWait:
	dc.w	$f401,$fffe	; $f4 is the end of the screen for a standard
				; 200 line high screen (with $2c as the start)
	dc.w	bpl1ptl
WaitB1l	dc.w	0,bpl1pth
WaitB1h	dc.w	0,bpl2ptl
WaitB2l	dc.w	0,bpl2pth
WaitB2h	dc.w	0

These bitplane pointers always point to the start of the screen, so set them
up at the start of the program.

To move the screen up, add 40 to the first set of bitplane pointers:

	add.w	#40,b1l		; Add 40 to low word of bitplane 1
	bcc	.loop		; If carry set, there was an overflow
	addq.w	#1,b1h		; so we need to add 1 to high word
.loop	add.w	#40,b2l		; Do same for bitplane 2
	bcc	.loop1
	addq.w	#1,b2h
.loop1	....

If we have moved down the screen at the top (scrolled screen up), we need
to reset the pointers 1 line earlier than before, ie. modify copper wait
command.

	subq.b	#1,ResetBPLWait	; Wait for 1 line earlier than before

When the whole screen has been scrolled, the first bitplane pointers have to
be pointed to the start of the screen again and the copper wait command
reset to $f4 (or whatever).  Then the whole process can be repeated

The problem with 256 line high screens is that another wait has to be added
since the raster line these screens finish on is $12c and this vertical
position can't be put into 1 wait instruction.

BPLWait1
	dc.w	$0001,$fffe	; 1st Wait
BPLWait2
	dc.w	$2c01,$fffe	; 2nd Wait

When the screen is reset between raster lines $100 and $12c, the 1st
wait has to be the standard PAL wait.  When reset between raster lines
$02c and $0ff,  the 1st wait has to be made bogus (as it is in the
copper list above)

For parallax scrolling it is just the same.  The major problem is
when both screens are moving - you have to make sure that the wait
commands are in the right order (eg. if the main screen's wait is
$e001 and the parallax's is $3001 the parallax wait should be first
in the copper list and vice versa).

In the code I have used a 200 line screen (cop out!), a 16 colour main
screen and a 2 colour parallax and only the parallax screen moves
(Lamer!).  There is little real explanation in the source - its all in this
doc instead.

NOTE: If you want to have places in black on the main screen which the
parallax screen shouldn't show through, you'll have to define another
colour in the screen as black.

P.S.	Like the Menu Mark - it looks a lot nicer than Program Selector.
