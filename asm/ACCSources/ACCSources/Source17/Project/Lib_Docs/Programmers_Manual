
		The acc.library Programmers Manual
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


 Introduction
 ~~~~~~~~~~~~
 The acc.library has been written to aid newcommers to assembly language
programming on the Amiga. At the same time the routines contained in the
library will assist old hands by speeding up development of their own
programms.

 To accompany the library is an assembler include file, acc_lib.i, which
contains all the _LVO offsets for the functions detailed below. This file
also contains a few equates specific to the library, these will be covered
at the appropriate time.

 To enable you to quickly locate details of any particular function of the
library, each function description starts with three hash ( ### ) symbols
followed by the functions name. Using a text file viewer such as PPMore,
you can use the search facility to quickly move to the information you
require ( cheers to Dave Edwards for this tip ).

 ACC is a disc based mag, of sorts, that is aimed at assembly language
programmers. Details are available from Amiganuts United at the following
address:
		Amiganuts United.
		169 Dale Valley Road,
		Southampton,
		Hant's,
		England.

 Full source code for the library is available from Amiganuts, Ray will
advise you of the latest version.

 ACC is interested to hear of any programmers using the library and also
seeing any programs that utalise it. Please write to me at the following
address:
		Mark Meany,
		216 Bluebell Road,
		Swaythling,
		Southampton,
		Hant's.

 Snail mail is the only means of communication I'm afraid as I can't afford
to run a modem, yet!

 Where To Put The Include File
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 The first steps you should take prior to using the library are copying the
include file into the Include/libraries directory on your source disc.
After doing this, copy the library into the libs directory on the same
disc.

 For the lazy ones, there is an instalation script file that will do the
above for you. It assumes that you have booted up using your assembler
workdisc. Simply double-click the 'Install_Lib' icon.

 As with all disc based libraries, acc.library must be located in the libs
directory of all boot discs that contain programs requiring it.

 Opening The Library
 ~~~~~~~~~~~~~~~~~~~
 There is no reason why the library cannot be opened in the normal way,
calling OpenLibrary(). To assist programmers who prefer this technique
there is a macro in the include file, 'ACCNAME'.

 This macro declares the name of the library for you. An example of it's
use follows:

		include		libraries/acc_lib.i

		lea		accname,a1	a1->library name
		moveq.l		#0,d0		any version
		CALLEXEC	OpenLibrary	and open the library

		< rest of the program >

accname		ACCNAME

 To simplify life even more is a macro that opens the library for you. As
you may have guessed, it's called OPENACC. This macro was written to save
time, it opens the library or aborts the program.

 Contained in the OPENACC macro is the name of the library and also storage
space for the library base pointer. The macro contains only one label,
_OpenAccLib, which you should not duplicate in your code.

 The macro preserves the contents of a0 and d0 should you wish to examine
any calling parameters.

 This macro should be one of the first lines of your program:

		include		libraries/acc_lib.i

		OPENACC

		< rest of program >

 Calling A Library Function
 ~~~~~~~~~~~~~~~~~~~~~~~~~~
 To simplify calling functions from the library there is a macro, CALLACC.
This macro does not preserve the contents of any registers, it simpliy
loads register a6 with the library base and then jumps to the required LVO.

 Example:
		CALLACC		GetLibs

 This will be expanded to the following:

		move.l		_AccBase,a6
		jsr		_LVOGetLibs(a6)

 As you can see, in order to use this macro you must store the library base
pointer at the label _AccBase. This is done for you if you use the OPENACC
macro.
 
###GetLibs()

 Accessing Other Libraries, GetLibs()
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 Once acc.library has been opened, the base pointers to three other
libraries can easily be obtained. The library pointers available are those
to the Exec, Intuition and Graphics libraries. This is possible since these
libraries are opened by the reset routine and so are always available.

 There is a function in acc.library that will supply these pointers to your
program. It requires a block of memory twelve bytes ( three long words ) to
copy the pointers into. Register a0 should contain the address of the first
of these three long words prior to calling GetLibs(). The pointers are
returned in the order stated above.

 Example:
		lea		_DOSBase,a0
		CALLACC		GetLibs

		< rest of program >

_DOSBase	dc.l		0	{ These base pointers will be set
_IntuitionBase	dc.l		0	{ by GetLibs() allowing access to
_GfxBase	dc.l		0	{ all three libraries!

 If acc.library opens, you are gaurenteed that the above three libraries
are open and available for your use. GetLibs() saves you from having to
open and close each library in turn. Once GetLibs() has been called, you
may use the base pointers returned to call functions from any of the three
libraries.

 The Functions
 ~~~~~~~~~~~~~
 There now follows a complete list of all functions contained within the
acc.library. The best way to familiarise yourself with them is to
experiment, remember
			'I hear and I forget,'
			'I see and I remember,'
			'I do and I understand.'

###GetLibs

 GetLibs()
 ---------

 SYNOPSIS	lib pointers = GetLibs ( *mem_block )
		  			     a0

 FUNCTION	This function will write the library base pointers into the
		block of memory pointed to by a0. The base pointers are
		written in the following order:
						_DOSBase
						_IntuitionBase
						_GfxBase
		Functions from these libraries may then be accessed without
		having explicitly opening the required library.

 INPUTS		*mem_block	- a pointer to three long words of memory
				  where the base pointers will be written.

 RESULTS	The three long words will contain the library base pointers
		as detailed above.

 CONSIDERATIONS	If acc.library opens then the other three libraries in
		question will be open. There is no chance of a bad pointer
		being returned.

 BUGS		None known.

 SEE ALSO	

 AUTHOR		M.Meany

 REVISED	

 EXAMPLE		lea		_DOSBase,a0
			CALLACC		GetLibs

			< rest of program >

_DOSBase		dc.l		0
_IntuitionBase		dc.l		0
_GfxBase		dc.l		0


###LoadFile

 LoadFile
 --------

 SYNOPSIS	*buffer,len = LoadFile ( *filename, mem_type )
		   a0    d0		     a0		d0

 FUNCTION	This function will load the contents of a file into memory.
		A block of memory is allocated by the function, it's size
		determined by the size of the file.

 INPUTS		*filename	- a pointer to the NULL terminated name of
				  the file to load.
		mem_type	- memory requirements ( see below ).

 RESULTS	*buffer		- pointer to the buffer containing the file

		len		- size of the buffer and hence the file.
				  If the file was not loaded for some
				  reason, this will be set to NULL. Always
				  test this value, never assume a file has
				  loaded.

 CONSIDERATIONS Any program calling this function is responsible for 
		releasing the memory block it allocates. This can be done
		by storing the address and length of the buffer as returned.
		When the data is finished with, use the Exec function
		FreeMem() to release the buffer.
		 The memory requirements you specify will be adhered to. If
		you specify CHIP memory, but there is not enough available
		the function will abort.
		 The library include file contains a few equates you can 
		use to specify memory requirements, this was done for two
		reasons. To save you having to include exec/memory.i just
		to use this facility and also the MEMF_ notation is so long
		winded. Memory types available are:
							PUBLICMEM
							CHIPMEM
							FASTMEM
		Note also that the size of the buffer is the size of the
		file.

 BUGS		None known.

 SEE ALSO	SaveFile(), FileLen().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		filename,a0		pointer to filename
		moveq.l		#PUBLICMEM,d0		mem type
		CALLACC		LoadFile		read in data
		move.l		d0,buf_len		save buffer size
		beq		ERROR		branch if load failed

		move.l		a0,buffer		save buffer pointer

		< rest of program >

		move.l		buffer,a1		pointer to mem
		move.l		buf_len,d0		size
		CALLEXEC	FreeMem			release it

		< more program >

filename	dc.b		'df1:raw/my_screen.bm',0
		even
buffer		dc.l		0
buf_len		dc.l		0


###SaveFile

 SaveFile
 --------

 SYNOPSIS	error = SaveFile ( *filename, *buffer, bytes )
		 d0			a0	 a1	 d0

 FUNCTION	To copy a block of data from memory into a disc file.

 INPUTS		*filename	- pointer to name of file to create.
		*buffer		- pointer to data in memory
		bytes		- number of bytes to copy into file.

 RESULTS	error		- NULL only if an error occurs such as file
				  could not be created.

 CONSIDERATIONS If you specify a filename that already exsists, the file
		will be written over with no warning.

 BUGS		None known.

 SEE ALSO	LoadFile(), FileLen()

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		filename,a0	pointer to file name
		lea		Text,a1		pointer to data
		move.l		#TextLen,d0	size of data
		CALLACC		SaveFile	and save to disc

		< rest of program >

filename	dc.b		'ram:temp',0
		even
Text		dc.b		'Test to see if function works',$0a,$0a,0
TextLen		equ		*-Text
		even


###FileLen

 FileLen
 -------

 SYNOPSIS	length = FileLen ( *filename )
		  d0		       a0

 FUNCTION	Returns the length of the specified file in bytes.

 INPUTS		*filename	- pointer to name of file to examine.

 RESULTS	length		- size of file in bytes, or NULL if file
				  could not be examined for some reason.

 CONSIDERATIONS	

 BUGS		None known.

 SEE ALSO	LoadFile(), SaveFile()

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		filename,a0	pointer to filename
		CALLACC		FileLen		get file size
		move.l		d0,filesize	and save it
		beq		ERROR		branch if error

		< rest of progrram >

filename	dc.b		's:staretup-sequence',0
		even
filesize	dc.l		0


###StringCmp

 StringCmp
 ---------

 SYNOPSIS	priority = StringCmp ( *string1, *string2 )
		   d0			  a0	    a1

 FUNCTION	Compares two NULL terminated text strings and determines the
		alphabetic reletionship between them. A value is returned in
		register d0 as detailed below.

 INPUTS		*string1	- pointer to first NULL terminated string.
		*string2	- pointer to second NULL terminated string.

 RESULTS	priority	- 0 if strings are identical.
				  1 if 1st string preceeds 2nd string.
				  2 if 2nd string preceeds 1st string.

 CONSIDERATIONS This rountine was intended for use with ASCII strings, but
		there is no reason why it cannot be applied to any NULL
		terminated data.

 BUGS		None Known.

 SEE ALSO

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		str1,a0		pointer to 1st string
		lea		str2,a1		pointer to 2nd string
		CALLACC		StringCmp	compare strings

		tst.l		d0		are they same?
		beq		SAME		if so branch

		subq.l		#1,d0		now d0=0 if str1 < str2
		beq		ASCENDING	branch if str1 < str2

		bra		DECENDING	must be str2 < str1

		< rest of program >

str1		dc.b		'first',0
		even
str2		dc.b		'second',0
		even


###FindStr

 FindStr
 -------

 SYNOPSIS	*address = FindStr ( *string, str_len, *buffer, buf_len )
		   d0		       a0	d0	 a1	  d1

 FUNCTION	Search a block of memory for a specified pattern of bytes.

 INPUTS		*string		- pointer to string to find
		str_len		- size of string to find
		*buffer		- pointer to address to start searching from
		buf_len		- size of memory block to search 

 RESULTS	*address	- address in memory block if a match is
				  found, NULL otherwise.		

 CONSIDERATIONS This routine was intended for use with ASCII strings, but
		there is no reason why it cannot be applied to any data.

 BUGS		If the buffer is the same size as the search string and also
		contains the same data ( ie. buffer = string at a different
		memory location ), the search fails!

 SEE ALSO

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		Author,a0	string
		moveq.l		L1,d0		size
		lea		$0		search start address
		move.l		#512*1024	a11 low memory
		CALLACC		FindStr		find it!
		tst.l		d0		is it there?
		beq		NOT_FOUND	nope, so branch!

		< rest of program >

Author		dc.b		'Meany',0
		even

###Ucase

 Ucase
 -----

 SYNOPSIS	Ucase ( *string )
			   a0

 FUNCTION	Converts all characters in a NULL terminated text string to
		upper case.

 INPUTS		*string		- pointer to NULL terminated ASCII string

 RESULTS	None returned

 CONSIDERATIONS

 BUGS

 SEE ALSO	Lcase(), UcaseMem(), LcaseMem().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		name,a0
		CALLACC		Ucase

		< rest of program >

name		dc.b		'M.Meany',0
		even

###Lcase

 Lcase
 -----

 SYNOPSIS	Lcase ( *string )
			   a0

 FUNCTION	Converts all characters in a NULL terminated text string to
		lower case.

 INPUTS		*string		- pointer to NULL terminated ASCII string

 RESULTS	None returned

 CONSIDERATIONS

 BUGS

 SEE ALSO	Ucase(), UcaseMem(), LcaseMem().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		name,a0
		CALLACC		Lcase

		< rest of program >

name		dc.b		'M.Meany',0
		even

###UcaseMem

 UcaseMem
 --------

 SYNOPSIS	UcaseMem ( *buffer, buf_len )
			      a0       d0

 FUNCTION	Converts all characters in a specified buffer to upper case.

 INPUTS		*buffer		- pointer to buffer
		buf_len		- size of the buffer

 RESULTS	None returned

 CONSIDERATIONS

 BUGS

 SEE ALSO	Lcase(), Ucase(), LcaseMem().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		move.l		buffer,a0	get addr of buffer
		move.l		buf_len,d0	and it's size
		CALLACC		UcaseMem	convert to upper case

		< rest of program >

buffer		dc.l		0		set by a call to LoadFile
buf_len		dc.l		0		or some other routine!


###LcaseMem

 LcaseMem
 --------

 SYNOPSIS	LcaseMem ( *buffer, buf_len )
			      a0       d0

 FUNCTION	Converts all characters in a specified buffer to lower case.

 INPUTS		*buffer		- pointer to buffer
		buf_len		- size of the buffer

 RESULTS	None returned

 CONSIDERATIONS

 BUGS

 SEE ALSO	Lcase(), Ucase(), UcaseMem().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		move.l		buffer,a0	get addr of buffer
		move.l		buf_len,d0	and it's size
		CALLACC		LcaseMem	convert to lower case

		< rest of program >

buffer		dc.l		0		set by a call to LoadFile
buf_len		dc.l		0		or some other routine!


###DOSPrint

 DOSPrint
 --------

 SYNOPSIS	DOSPrint ( *text, handle )
			     a0     d0

 FUNCTION	To print a NULL terminated message into any open file. In
		particular this routine can be used to display information
		to the user in the CLI or an open CON/RAW window.

 INPUTS		*text		- pointer to NULL terminated text string.
		handle		- handle of an open file to print into.

 RESULTS	None.

 CONSIDERATIONS This function does not follow each line with a line-feed.
		Your program must take care of this. NEVER call with an
		invalid handle, the Guru is sure to visit if you do!

 BUGS		None known.

 SEE ALSO

 AUTHOR		M.Meany

 REVISED

 EXAMPLE
		lea		_DOSBase,a0
		CALLACC		GetLibs		get library base pointers

		CALLDOS		Output		get CLI output handle
		move.l		d0,d7		store it out of harms way

		lea		msg,a0		pointer to text
		move.l		d7,d0		handle
		CALLACC		DOSPrint	and print text

		< rest of program >

_DOSBase	dc.l		0
_IntuitionBase	dc.l		0
_GfxBase	dc.l		0

msg		dc.b		'This utility uses acc.library.',$0a,0
		even

 Lists
 ~~~~~
 Before continuing, it is necessary to explain the structure and
manipulation of the lists supported by this library. If you are familiar
with Exec lists you should not have any problems followin this as there are
only very slight differences.

 A list is a collection of small blocks of data chained together via
pointers. Each block of data is called a 'node' and has the following
structure:

nd_Succ		LONG		pointer to next node in chain
nd_Pred		LONG		pointer to previous node in chain
nd_Data		LONG		pointer to the data for this node

 Each chain must have a start and end, known as the 'head' and 'tail' of
the list. The 'head' has no predecessor and the 'tail' has no successor. An
empty list consists of just a 'head' and 'tail' as shown below:

	'head'			'tail'
	______			______
       |      |		       |      |
       | Succ | -------------> | NULL |
       |______|		       |______|
       |      |		       |      |
       | NULL | <------------- | Pred |
       |______|                |______|

 A list containing two entries will look as follows:

	'head'		'node'		'node'		'tail'
	______		______          ______          ______
       |      |	       |      |        |      |        |      |
       | Succ | -----> | Succ | -----> | Succ | -----> | NULL |
       |______|	       |______|        |______|        |______|
       |      |	       |      |        |      |        |      |
       | NULL | <----- | Pred | <----- | Pred | <----- | Pred |
       |______|        |______|        |______|        |______|
                       |      |        |      |
                       | Data |        | Data |
		       |______|        |______|


 List Header
 ~~~~~~~~~~~
 Ever list has a start and end point. For convenience, these are merged
into one block and called the list header. This can be shown diagrmatically
also, below shows how an empty list looks. On the left is the form used
above, on the right with 'head' and 'tail' in one block.

	'head'		'tail'			'header'
	______		      			 ______
       |      |	__________			|      |
   +-> | Succ |	          |		   +-->	| Succ | ---+
   |   |______|		__V___		   |	|______|    |
   |   |      |        |      |		   |	|      |    |
   |   | NULL |        | NULL |		   |	| NULL | <--+
   |   |______|        |______|		   |	|______|
   |		       |      |		   |	|      |
   |__________________ | Pred |		   +---	| Pred |
		       |______|			|______|

 Now the list 'head' and 'tail' are combined into a unit the same size as
all other node entries. This allows us to treat it as a special node.

 The nd_Succ entry in the header always points to the first node in the
list, the nd_Data entry to the last, except when the list is empty. If this
is the case, nd_Data points to the 'head' of the list.

 To understand the usefulness of the above paragraph, consider adding a
node to the start of the list. The function AddNode() requires a pointer to
a node already in the list, the node to be added is always positioned after
this node. If you supply the 'head' as the node to insert after, you will
always add to the start of the list.

 To add a node to the end of the list, you require a pointer to the last
node in the list. You can obtain this pointer fromthe nd_Data field of the
list header. When the new node is added the nd_Data field in the list
header is updated to point to this node, ensuring this field always points
to the last node in the list.

 Testing for an empty list, if required, is done by comparing the nd_Data
field of the list header to the address of the list header. If the pointer
points to the header itself, the list is empty!

 To test if a particular node is the 'head', see if nd_Prev is NULL.

 To test if a particular node is the 'tail', see if nd_Succ is NULL.

 Stepping through the chain just requires accessing the nd_Succ or nd_Pred
entry of a node, depending on direction.

 The nd_Data field is for your own use. It can point to a structure of your
own design or to actual data. As an example of each, first consider a
database program. This could revolve around a list with the data holding a
pointer to a structure that contained pointers to the relevant data on each
entry in the database. Now consider a list of filenames, the data entry of
each node points to a different filename.

 I mentioned the second example on purpose, as there is a library function
that builds a list of filenames for all entries in a specified directory,
more on that soon.

 Building A List
 ~~~~~~~~~~~~~~~
 There are only the most basic list routines available. To start a list,
call NewList() ( see later for specific details ). This will generate a
list header and set it's pointers up for an empty list.

 When you have an entry you wish to add to the list, call AddNode(). This
will insert a node in the list for you, updating all pointers. After the
node has been added, write the pointer to it's data in the nd_Data field.

 To delete a single entry from the list, first release pull the pointer to
the data from the nd_Data field ( this is only required the data is sitting
in memory your program has allocated, you will need the address to FreeMem
it ). After obtaining the data pointer, call DeleteNode and it will be
removed leaving the rest of the list intact.

 To delete an entire list, call FreeList(). This frees all nodes and then
the list header as well.

 Your program may have as many active lists as memory permits ( quite a few
even on a standard A5OO ). All you have to keep track of is the headers to
each list.


###GetDirList

 GetDirList
 ----------

 SYNOPSIS	*header = GetDirList( *dirname )
		  d0			a0

 FUNCTION	Given a valid directory name this function will return a list
		that contains an entry for each file/directory contained in
		the specified directory.
		 The data for each entry in the list consists of a single
		identifier ( F for file, D for directory ) followed by the
		name of the entry.
		 The memory for the data linked to each node via the nd_Data
		field is allocated as each entry is created. The field is 
		110 bytes long. It is important to follow this if you ever
		intend to add entries to a list returned by this function
		and also wish FreeDirList to properly de allocate the data
		memory for you. Failure to do so will cause a system crash!
		 The first entry is always the correct name of the directory
		under examination and will always have a D identifier, even
		when it is infact a volume.	

 INPUTS		*dirname	- pointer to null terminated name of 
				  directory to examine.

 RESULTS	*header		- pointer to list header if operation was
				  successfull, else NULL to indicate an error

 CONSIDERATIONS The list is not sorted in any way, all entries are as they
		appear on disc. May add a function to sort directory later.

 BUGS		None known.

 SEE ALSO	FreeDirList(), AddNode(), DeleteNode()

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See Dir example elsewhere on this disc.


###FreeDirList

 FreeDirList
 -----------

 SYNOPSIS	FreeDirList( *header )
				a0

 FUNCTION	Releases all memory allocated by a call to GetDirList. This
		simplifies operations involving directory jumps followed by
		directory lists.

 INPUTS		*header		- list header returned by GetDirList.

 RESULTS	All memory tied up in the list is released.

 CONSIDERATIONS Do not call with a NULL pointer, system will crash if you do.
		If you have added your own nodes to a list created by 
		GetDirList() then the nd_Data field should point to a block
		of memory, allocated to your application, 11O bytes long.
		If this is not the case prepare to meet thy Guru!

 BUGS		Does not cater for NULL pointer.

 SEE ALSO	GetDirList(), AddNode(), DeleteNode().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See Dir example elsewhere on this disc.


###NewList

 NewList
 -------

 SYNOPSIS	*header = NewList()
		   d0

 FUNCTION	Creates a list header an initialises as an empty list.

 INPUTS		None

 RESULTS	*header		- pointer to list header or NULL if memory
				  allocation failed.

 CONSIDERATIONS	

 BUGS		None known.

 SEE ALSO	AddNode(), DeleteNode(), FreeList().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See sort example elsewhere on this disc.



###AddNode

 AddNode
 -------

 SYNOPSIS	err, *newnode = AddNode( *node )

 FUNCTION	to add a node into a list.

 INPUTS		*node		- pointer to node to insert new node after.

 RESULTS	err		- error code:	
					0 => node added.
					1 => memory allocation error.
					2 => attempted to add node after 
					     'tail' of list.

		*newnode	- if err=0 then newnode points to the node
				  added to the list.

 CONSIDERATIONS Never assume a node has been added successfully, always test
		register d0.

 BUGS		None Known.

 SEE ALSO	NewList(), FreeList(), DeleteNode(), GetDirList(),
		FreeDirList().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See sort example.



###DeleteNode

 DeleteNode
 ----------

 SYNOPSIS	DeleteNode( *node )
			      a0

 FUNCTION	To remove a node from a list and update all list pointers.

 INPUTS		*node		- pointer to node to delete.

 RESULTS	node will be removed from list.

 CONSIDERATIONS Will not remove the head or tail of a list.

 BUGS		None known.

 SEE ALSO	AddNode(), NewList(), FreeList(), GetDirList(), FreeDirList()

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See sort example.



###FreeList

 FreeList
 --------

 SYNOPSIS	FreeList( *header )
			     a0

 FUNCTION	To release all memory occupied by nodes in a list and also
		that occupied by the list header.

 INPUTS		*header		- pointer to list header.

 RESULTS	all memory tied up by list is released.

 CONSIDERATIONS	Does not free memory allocated by applications who store the
		pointer in the nd_Data field. The responsability lies with
		the application for this memory.

 BUGS		None known.

 SEE ALSO	NewList(), AddNode(), DeleteNode().

 AUTHOR		M.Meany

 REVISED

 EXAMPLE	See sort example.


 A Final Word
 ~~~~~~~~~~~~
 You will find the list node structure is defined in the assembler include
file. At present only assembler is supported, but I am hoping to fix this
very soon.

 If you discover a bug within any of the routines, please contact me and
let me know.

