                   Intuition Part 4    
                   ~~~~~~~~~~~~~~~~ 
   Gadgets ( continued ). 
   ~~~~~~~~~~~~~~~~~~~~~~  
 In the last Intuition tutorial I  covered  using Borders with gadgets. Using 
custom imagery is  very  similar  to  using  Borders,  it  is  just a case of 
replacing the Border structure  pointer  to an Image structure pointer in the 
gg_GadgetRender field of  the gadget structure and also setting the GADGIMAGE 
flag in the gg_Flags field of the gadget structure. 
 
   You have a choice of actions to take  when  the  gadget is clicked on, you 
can either have the gadget Image  displayed  in inverse colours ( Yeuk ! ) or 
you can opt for a second  Image  to  be  displayed.  To  have  a second image 
displayed   requires  a  pointer   to  the   second  Image  structure in  the  
gg_SelectRender  field  of  the gadget structure  and setting  the GADGHIMAGE
flag in the gg_Flags field. Opting for a simple inverse image is just a  case
of  setting  the  GADGHCOMP flag in the gg_Flags field. 
 
   A point worth mentioning is that you  should  match the ' hit box ' of the 
gadget to the same size as the  image  you  are  using.  This avoids problems 
caused by using large images and small hit boxes ..... user clicks on part of 
image outside  hit box  and nothing  happens ..... and also small images  and 
large  hit  boxes ..... user  clicks  on  blank  area  of  window  and gadget
activates. 
 
   Using Images has been covered before  and  I'm  not going to repeat it all 
here! Assuming you have the raw data for  two images ( IM1 & IM2 ) both sized 
16x9 pixels, the  following  structures  tie  theses  Images to a gadget. One 
Image is used for the render imagery and the other for the select imagery:   
 
Gadget1  dc.l  0                               Ptr to next gadget 
         dc.w  100                             x coord of origin 
         dc.w  100                             y coord of origin 
         dc.w  16                              hit box width ( = IMx width ) 
         dc.w  9                               hit box height 
         dc.w  GADGIMAGE!GADGHIMAGE            select & render 
         dc.w  RELVERIFY                       release verify gadget 
         dc.w  BOOLGADGET                      it's a boolean gadget 
         dc.l  IM1                             ptr to ' render ' image data 
         dc.l  IM2                             ptr to ' select ' image data 
         dc.l  0                               no IText 
         dc.l  0                               not mutually exclusive 
         dc.l  0                               not a string/int gadget 
         dc.w  0                               ID, who cares? 
         dc.l  server                          label of service routine 
 
IM1      dc.w  0                               relative x origin 
         dc.w  0                               relative y origin 
         dc.w  16                              image width 
         dc.w  9                               image height 
         dc.w  2                               2 bitplanes 
         dc.l  IM1Data                         ptr to raw bpl data 
         dc.b  3                               PlanePick ( use both of 'em) 
         dc.b  0                               PlaneOnOff 
         dc.l  0                               No more images 
 
IM2      dc.w  0                               relative x origin 
         dc.w  0                               relative y origin 
         dc.w  16                              image width 
         dc.w  9                               image height 
         dc.w  2                               2 bitplanes 
         dc.l  IM2Data                         ptr to raw bpl data 
         dc.b  3                               PlanePick ( use both of 'em) 
         dc.b  0                               PlaneOnOff 
         dc.l  0                               No more images 
 
         << Other data here >>  
 
         section  gfx,data_c                    CHIP ram for gfx data 
 
IM1      incbin  <filename> 
IM2      incbin  <filename> 
 
 I am not going to dwell on this, there is  an example of using a super-duper 
QUIT gadget on the disc called eg_1.s, assemble and run this. 
 
   Preparing Gadget Imagery  
   ~~~~~~~~~~~~~~~~~~~~~~~~ 
 Well adding an image to a gadget is simple enough, but how do you design the 
image itself? Let me outline one  method  that  you can use or modify produce 
the raw data required in the above example listing: 
 
   1/ Load DPaint with a 640x256 screen, using 4 colours. 
 
   2/ Draw your gadget. 
 
   3/ Switch on coordinates ( Rightmost menu on DPaint2 ). 
 
   4/ Cut your gadget out as a brush. Keep the brush as small as you      can 
to save memory. Record the width  and  height  of  the  brush      ( read the 
coordinates display as you cut ). 
 
   5/ Save the brush. 
 
   6/ Use an IFF converter to save the brush  as raw data, be sure to    save 
with NO colour map ( sometimes referred to as CMAP ). 
 
   7/ Construct suitable gadget and image structures  to suit the raw    data 
you have saved,  ie.  Use  the  width  and  height  of  the  brush  as    the 
dimensions of the gadgets ' hit box ' and image. 
 
   8/ Incbin the raw data file into the structure source. 
 
   NOTE: If using a separate image for select,  ensure it has same dimensions 
as image used for render. 
 
   NOTE: Some IFF Converters always display brushes in a  320x256 display. Do 
not worry about this, the data saved should still be in the correct format.    
 
   NOTE: The bigger the image, the more  CHIP  memory it gobbles up. A simple 
16x9 gadget, displayed in two planes ( four  colours ), requires 36 bytes and 
will seem minute! 
 
 Well that is one way of obtaining the data for an image, what a carry on! To 
make life easier I have developed a utility  to simplify things somewhat. The 
utility is called ImageMaker ( original as ever ). 
 
 This utility lets you load an  IFF  brush  and  save  out a source file that 
contains the required image structure  AND  the image data. The image data is 
converted into dc.w statements for completeness. 
 
 Once you have created a  gadget  in  DPaint,  save  it  as a brush. Next run 
ImageMaker and convert the gadget  brush  into an Image source file. Finally, 
add the gadget structure of your  own  design  to  the  code and away you go! 
Again it makes sense to set the   gadgets  hit box   dimensions the  same  as
image dimensions. You can see the image dimensions by examining the structure
ImageMaker creates ( isn't life easy! ). 
 
 Hopefully, by next month, I will have added the code to ImageMaker that will 
allow a complete gadget structure to be created with SELECT and RENDER images 
attached to it. This will simplify things even further. 
 
 There is a tutorial supplied  with  ImageMaker  that  takes  you through the 
steps required to create two gadgets  with  images  linked to them. I suggest 
you work through it as this utility can save a lot of time! 
 
   Mutually Exclusive Gadgets. 
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 If you have looked at  the  gadget  structure  presented  earlier  you  will 
remember seeing a gg_MutualExclude field. Forget about it! The 1.2/1.3 system 
does not support this feature, all  mutual  exclusion  must be handled by the 
programmer. 
 
 So what is mutual exclusion? Put  simply,  selecting  one gadget will either 
de-select other gadgets or  prevent  other  gadgets  from being activated. An 
example: 
 
 Suppose you have written a search routine  that has the option of being case 
sensitive. You  may  use  two  gadget  to  allow  the  user  to  switch  case 
sensitivity on/off: 
 
                  +--+  +---+  
case sensitivity: |ON|  |OFF| 
                  +--+  +---+ 
 
 If the user clicks on the OFF gadget, the ON gadget should be deselected and 
visa versa. Having both or  none  of  the  gadgets  selected  is meaningless. 
What this means to the programmer is playing  with gadget structures gg_Flags 
fields. Of course life is not that simple, you  must  not  alter  this  field
while the gadget is under the systems control. This means the following steps
need to be followed each time a mutually  exclusive gadget is selected by the
user: 
 
   1/ Remove all  gadget  to  be  excluded  from  the  active  gadget list of 
the window. 
 
   2/ Set and Reset the the appropriate gadgets SELECT flag. 
 
   3/ Add gadgets back to the windows active gadget list. 
 
 This system was introduced to me by  Steve  Marshall and to this day I still 
use the same two  subroutines  to  remove  gadgets  and  add them back to the 
active gadget list that Steve sent me. 

 It is necessary to make  the gadgets  GADGETIMMEDIATE so  that a message  is
sent to your program as soon as the user ' clicks ' on one of them. 
 
 To explain how the system  works,  consider  a  program  that opens a window 
containing two gadgets. One gadget is  an  OFF gadget, the other an ON gadget 
as discussed above. 
 
 The gg_UserData field of each  gadget  holds  the  address of the routine to 
call should that gadget be selected in the usual manner. The program enters a   
wait loop while the user decides on  which  gadget to click. The wait loop is 
the standard one I normally use that  waits  for  a message to arrive, if the 
message is from a gadget then control  passes  to the subroutine whos address 
is stored in the gg_UserData field of the gadget: 
 
 
WaitForMsg 
         move.l   window.up,a0                 a0-->user port 
         CALLEXEC WaitPort                     wait for something to happen 
         move.l   window.up,a0                 a0-->window pointer 
         CALLSYS  GetMsg                       get any messages 
         tst.l    d0                           was there a message ? 
         beq.s    WaitForMsg                   if not loop back 
         move.l   d0,a1                        a1-->message 
         move.l   im_Class(a1),d2              d2=IDCMP flags 
         move.l   im_IAddress(a1),a5           a5=addr of structure 
         CALLSYS  ReplyMsg                     answer os or it get angry 
 
         move.l   d2,d0                        get message type			
         and.l    #GADGETUP!GADGETDOWN,d0      was it a gadget ?
         beq.s    .test_win                    if not skip next bit
         move.l   gg_UserData(a5),a0           else get addr of subroutine
         jsr      (a0)                         and call it
 
         cmp.l    #CLOSEWINDOW,d2              window closed ? 
         bne.s    WaitForMsg                   if not then jump 
         rts 
     
 
 You  should  be familiar  with this  routine by now!  On receiving  a gadget
message, the address stored in  the gg_UserData field  is moved into register
a0 and then the subroutine at that address is called.

 Suppose that selecting the ON  gadget  caused  a  subroutine called DoOn and 
selecting the OFF gadget a subroutine  called  DoOff.  DoOn must first remove 
the ON and OFF gadget from the  windows  gadget list, set the SELECT flag for 
the ON gadget, clear the SELECT  flag  for  the  OFF  gadget and then add the 
gadget back to the windows gadget list. 
 
 The DoOff routine will also  remove  both  gadgets  from  the windows gadget 
list, except this time the SELECT flag of the OFF gadget will be set and that  
of the ON gadget will  be  reset  before  the  gadgets  are added back to the 
windows gadget list. 
 
 Of course both routines  will  have  to  preform  some  other  task, such as 
setting a flag so the program knows what  action to take ( though there is no 
reason why your program cannot just test the gg_Flags field of the gadgets to  
determine which is selected ). 
 
 Below are two routines that do the required tasks: 

;-------------- 
;-------------- Deal with ON gadget selection 
;-------------- 
 
DoOn 
         lea      OnGadg(pc),a1               a1-> first gadget 
         moveq    #2,d0                       d0=num of gadgets to remove 
         bsr      RemoveGad                   and remove from list 
         move.w   #SELECTED,d1                d1=SELECT bit 
         lea      OnGadg(pc),a1               a1->ON gadget 
         or.w     d1,gg_Flags(a1)             SELECT ON gadget 
         not.w    d1                          d1=not SELECTED 
         lea      OffGadg(pc),a1              a1->OFF gadget 
         and.w    d1,gg_Flags(a1)             de SELECT OFF gadget 
         lea      OnGadg(pc),a1               a1-> first gadget 
  
         moveq    #2,d1                       add gadgets back to list 
         bsr      AddGad 
 
         moveq.l   #1,CaseFlag                set program flag 
         rts                                  and return 
 
;-------------- 
;-------------- Deal with OFF gadget selection 
;-------------- 
 
DoOff 
         lea      OnGadg(pc),a1               a1-> first gadget 
         moveq    #2,d0                       d0=num of gadgets to remove 
         bsr      RemoveGad                   and remove from list 
         move.w   #SELECTED,d1                d1=SELECT bit 
         lea      OffGadg(pc),a1              a1->OFF gadget 
         or.w     d1,gg_Flags(a1)             SELECT OFF gadget 
         not.w    d1                          d1=not SELECTED 
         lea      OnGadg(pc),a1               a1->ON gadget 
         and.w    d1,gg_Flags(a1)             de SELECT ON gadget 
         lea      OnGadg(pc),a1               a1-> first gadget 
  
         moveq    #2,d1                       add gadgets back to list 
         bsr      AddGad 
 
         moveq.l   #0,CaseFlag                reset program flag 
         rts                                  and return 
 
                                                
 It is important that the RemoveGad and AddGad  subroutines are called with a 
pointer to the first defined gadget to remove from the list. 
 
 Well the above routines make little  sense  without the RemoveGad and AddGad 
subroutines, so I will now present these: 
 
;-------------- 
;-------------- Remove gadgets from list 
;-------------- 
 
RemoveGad 
         move.l    window.ptr,a0  ;get window pointer 
         CALLINT   RemoveGList    ;remove the gadgets 
         rts 
 
;-------------- 
;-------------- Add gadgets back to list 
;-------------- 
 
AddGad 
         movem.l   d1/a1,-(sp)    ;save d1,a1 numgad,gadget 
         move.l    window.ptr,a0  ;get window ptr 
         sub.l     a2,a2          ;clear a2 
         CALLINT   AddGList       ;d0 should remain unchanged 
         move.l    window.ptr,a1  ;since RemoveGList 
         movem.l   (sp)+,d0/a0    ;set up d0,a0 numgad,gadget   
         CALLSYS   RefreshGList   ;refresh gadgets  
         rts   
 
 
 That's all there is to it! On  this  disc  you  will find the source for the 
example discussed, I have tried to keep it as simple as possible. 
 
 If you write a  program  that  requires  more  than  two  mutually exclusive 
gadgets, remember to remove all of them, SELECT and de SELECT the appropriate  
gadgets, then add them all back again. 
 
 If you feel like experimenting with  AddGList  and  RemoveGList, here is the 
information you require: 
 
  Position = RemoveGList ( Window, Gadget, NumGadgd ) 
        d0                      a0      a1       d0 
 
 Removes NumGadg gadgets from the gadget list of the specified window. 
 
 NOTE: The last gadget removed does NOT have it's link zeroed. 
 
 Window   -   Pointer to the window containing the gadgets. 
 Gadget   -   Pointer to the first gadget to remove. 
 NumGadg  -   Number of gadgets to remove. 
 
 
  RealPosition = AddGList ( Window, Gadget, Position, Numgad, Requester ) 
      d0                      a0      a1       d0       d1        a2 
 
 Adds the list of gadgets to the gadget list  of the window ( or requester ), 
linked in at the position specified. 
 
 NOTE: The link field of the last gadget  added will be modified by a call to 
this routine. For example, if you are  adding  the first three gadgets from a 
linked list of four, the link from the third to the fourth will be lost. 
 
 Window    -  A pointer to window to add gadgets to. 
 Gadget    -  A pointer to the first gadget to add. 
 Position  -  The position in gadget list to add gadgets at. 
              ( starts at position zero ). 
 Numgad    -  The number of gadgets to add. 
 Requester -  Pointer to requester to add gadgets to ( set to NULL if 
              not required ). 


 Well that's it from me 'till next month,

					byeee! Mark.

