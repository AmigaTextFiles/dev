****************************************************
* DiskDecoder :- Version 2.00  (c)1991 Dean Ashton *
*                                                  *
* Includes support for DiskCoder V2.0 random track *
* algorithm and CIA timer routines..  Enjoy!       *
*                                                  *
****************************************************

	SECTION STARTUP,CODE_C
	INCDIR	"source:dean/INCLUDE/"
	INCLUDE	"HW_EXAMPLES.I"
	INCLUDE	"DISKMACROS2.I"

ALLOCMEM	EQU 	-$C6		; exec.library Memory Allocation
FREEMEM	EQU	-$D2		; exec.library Memory Deallocation
SCRWIDTH	EQU	80		; 80 characters wide
SCRHEIGHT	EQU	200		; 200 lines high
PLANES	EQU 	2		; 2 plane deep (max 4 colours)
PASSLEN	EQU 	21		; Password can be up to 21 characters.
RNDNUMBER	EQU	20		; We'll encode 20 tracks
READTRIES	EQU	3		; Maximum no. of Track re-trys

DECODEPRG	BRA.S	STOPSYS		; Call main Decoder

CHECKVAL	DC.L	0		; Checksum for Track Two
RANDOMS	DCB.W	RNDNUMBER,0	; Space for Random tracks

STOPSYS	MOVEM.L	D0-D7/A0-A6,-(A7)	; Stack registers for system return
	LEA	SUPERMODE(PC),A0	; Get into supervisor mode
	MOVE.L	A0,$80.W		; by doing a TRAP #0
	TRAP	#0		; Do It
	MOVEM.L	(A7)+,D0-D7/A0-A6	; Restore system registers
	RTS
	
SUPERMODE	LEA	VARIABLES(PC),A5	; Point to internal variables list
	LEA	CUSTOM,A6		; Point to Hardware Registers
	MOVE.W	DMACONR(A6),OLDDMA(A5)
	MOVE.W	INTENAR(A6),OLDINT(A5)
	MOVE.L	$6C.W,OLDLEV3(A5)	
	MOVE.L	$68.W,OLDLEV2(A5)
	MOVE.W	#$7FFF,D0		; D0 holds disable value
	MOVE.W	D0,DMACON(A6)	; Kill system DMA
	MOVE.W	D0,INTENA(A6)	; Kill system Interrupts (Enable)
	
	LEA	LEVEL3(PC),A0	; Point to my Level 3 interrupt
	MOVE.L	A0,$6C.W		; Insert our interrupt! (Copper)
	LEA	LEVEL2(PC),A0	; Point to my Level 2 interrupt 
	MOVE.L	A0,$68.W		; Insert our interrupt! (Keys)
	
	BSR	SETUP		
	
STARTSYS	LEA	CUSTOM,A6		; Point to Hardware Registers

	MOVE.W	#$7FFF,D0		; D0 holds disable value
	MOVE.W	D0,DMACON(A6)	; Kill system DMA
	MOVE.W	D0,INTENA(A6)	; Kill system Interrupts (Enable)
	
	MOVE.L	OLDLEV3(A5),$6C.W	; Restore Level 3 Interrupt Vector
	MOVE.L	OLDLEV2(A5),$68.W	; Restore Level 2 Interrupt Vector
	
	MOVE.W	OLDDMA(A5),D0	; Get old DMACON values
	OR.W	#$8200,D0		; Set 'SET' and 'ENABLE' bits
	MOVE.W	D0,DMACON(A6)	; Restore DMACON values
	
	MOVE.W	OLDINT(A5),D0	; Get old INTENA values
	OR.W	#$C000,D0		; Set 'SET' and 'MASTER' bits
	MOVE.W	D0,INTENA(A6)	; Restore INTENA values
	
	RTE			; Exit Trap #0 code
	
SETUP	MOVE.L	4.W,A6		; Get ExecBase
	LEA	GFXNAME(PC),A1	; Point to 'graphics.library'
	MOVEQ	#0,D0		; Any version will do...
	JSR	-$228(A6)		; OpenLibrary
	TST.L	D0		; Has it opened ok?
	BEQ	SETEXIT		; No? Exit Main Process
	MOVE.L	D0,A1		; Move to an address register
	MOVE.L	38(A1),OLDLIST(A5)	; Store system copperlist address
	MOVE.L	4.W,A6		; Get ExecBase
	JSR	-$19E(A6)		; CloseLibrary
	
	MOVE.L	#SCRWIDTH*SCRHEIGHT*PLANES,D0	; Size for Screen
	ADD.L	#20000,D0		; Add in size for diskbuffers
				; 20000 Bytes for Buffers
	MOVE.L	#$10002,D1	; Cleared Chip memory
	MOVE.L	4.W,A6		; Get ExecBase
	JSR	ALLOCMEM(A6)	; Allocate memory
	TST.L	D0		; Has it worked?
	BEQ	SETEXIT		; No? Exit Main Process
	
	MOVE.L	D0,SCREEN(A5)	; Store screen address
	
	ADD.L	#SCRWIDTH*SCRHEIGHT*PLANES,D0	; Skip over screen memory
	
	MOVE.L	D0,TRACK(A5)	; Store address of Track (Decoded)
	
	ADD.L	#6144,D0		; Find address of Track Gap (Raw)
	MOVE.L	D0,TRACKGAP(A5)	; Store address of Track Gap
	
	ADD.L	#700,D0		; Find address of Track Buffer (Raw)
	MOVE.L	D0,TRACKBUFF(A5)	; Store address of Track Buffer (Raw)

	MOVE.L	TRACKGAP(A5),A0	; Retrieve address of Track Gap
	MOVE.L	#(13756/4)-1,D0	; Number of Longwords to Initialise
INITMFM	MOVE.L	#$AAAAAAAA,(A0)+	; Write MFM coded Zero Bytes away..
	DBF	D0,INITMFM
	
SETPLANE1	MOVE.L	SCREEN(A5),D0	; Retrieve Screen Address
	LEA	PLANE1LO(PC),A0	; Point to BitPlane Low Word
	MOVE.W	D0,(A0)		; Move into copperlist
	SWAP	D0
	LEA	PLANE1HI(PC),A0	; Point to BitPlane High Word
	MOVE.W	D0,(A0)		; Move into copperlist
	SWAP	D0		; Swap address back to normal
	
SETPLANE2	ADD.L	#SCRWIDTH,D0	; Point to next Bitplane
	LEA	PLANE2LO(PC),A0	; Point to BitPlane Low Word
	MOVE.W	D0,(A0)		; Move into copperlist
	SWAP	D0
	LEA	PLANE2HI(PC),A0	; Point to BitPlane High Word
	MOVE.W	D0,(A0)		; Move into copperlist
	SWAP	D0		; Swap address back to normal
	
SETMOUSE	LEA	DEADSPR(PC),A0	; Point to Mouse Sprite
	MOVE.L	A0,D0		; Transfer to Data Register
	LEA	SPR0LO(PC),A0	; Point to Sprite 0 Low Word
	MOVE.W	D0,(A0)		; Move into copperlist
	SWAP	D0	
	LEA	SPR0HI(PC),A0	; Point to Sprite 0 High Word
	MOVE.W	D0,(A0)		; Move into copperlist

SETDEADSP	LEA	DEADSPR(PC),A0	; Point to Null Sprite Data
	MOVE.L	A0,D0		; Transfer to Data Register
	LEA	NOSPRITES(PC),A0	; Point to No Sprite List
	MOVE.W	D0,6(A0)		; Sprite 1 Low Word
	MOVE.W	D0,14(A0)		; Sprite 2 Low Word
	MOVE.W	D0,22(A0)		; Sprite 3 Low Word
	MOVE.W	D0,30(A0)		; Sprite 4 Low Word
	MOVE.W	D0,38(A0)		; Sprite 5 Low Word
	MOVE.W	D0,46(A0)		; Sprite 6 Low Word
	MOVE.W	D0,54(A0)		; Sprite 7 Low Word
	SWAP	D0		
	MOVE.W	D0,2(A0)		; Sprite 1 High Word
	MOVE.W	D0,10(A0)		; Sprite 2 High Word
	MOVE.W	D0,18(A0)		; Sprite 3 High Word
	MOVE.W	D0,26(A0)		; Sprite 4 High Word
	MOVE.W	D0,34(A0)		; Sprite 5 High Word
	MOVE.W	D0,42(A0)		; Sprite 6 High Word
	MOVE.W	D0,50(A0)		; Sprite 7 High Word

	LEA	NEWCOPPER(PC),A0	; Point to our new copperlist
	LEA	CUSTOM,A6		; Point to Custom registers
	
	MOVE.L	A0,COP1LC(A6)	; Move address to copperlist pointer
	MOVE.W	#0,COPJMP1(A6)	; Strobe copperlist #1
	
	BSR	MAIN		; Perform Main code section
	
	BSR	BLITWAIT		; Wait for Blitter to finish
	
	MOVE.L	OLDLIST(A5),A1	; Get system copperlist address
	MOVE.L	A1,COP1LC(A6)	; Make system copperlist current
	MOVE.W	#0,COPJMP1(A6)	; Strobe copperlist #1
	
	MOVE.L	SCREEN(A5),A1	; Get Screen Memory address
	MOVE.L	#SCRWIDTH*SCRHEIGHT*PLANES,D0	; Size for Screen
	ADD.L	#20000,D0		; Add size for Disk Buffers
	MOVE.L	4.W,A6		; Get ExecBase
	JSR	FREEMEM(A6)	; Free screen memory
	
SETEXIT	RTS			; Return and restore resources


********************************
* MAIN :- Main Process Section *
********************************

MAIN	MOVE.W	#%1100000000011000,INTENA(A6)	; Enable Copper/Ports/Disk
	MOVE.W	#%1000001111110000,DMACON(A6)	; All DMA except Audio

	DRIVEOFF	1111		; All drives off!
	
	LEA	TITLEMESS(PC),A0	; Point to Title Bar Message
	MOVEQ	#28,D1		; Set X position in characters
	MOVEQ	#80,D2		; Set Y position in scanlines
	BSR	PRINTLINE		; Print line of text
	
	LEA	CREDMESS(PC),A0	; Point to Credits Message
	MOVEQ	#7,D1		; Set X position in characters
	MOVEQ	#91,D2		; Set Y position in scanlines
	BSR	PRINTLINE		; Print line of text
	
	LEA	WAITMESS(PC),A0	; Print 'Waiting' message
	BSR	PRINTSTAT		; on the Status line
		
	BSR	CONTROL
		
	RTS
	
	
	
************************************************
* GETCODE :- Read a password from the keyboard *
************************************************

GETCODE	LEA	PASSWORD(PC),A0	; Point to the Password
	MOVEQ	#PASSLEN-1,D1	; We're going to clear the password
CLPASSLP	MOVE.B	#32,(A0)+		; Move a space character in
	DBF	D1,CLPASSLP	; Back for next byte.
	
	BSR	PRINTPASS		; Print the Password (It's Spaces!)
	
	MOVE.W	#0,CURSOR(A5)	; Cursor position at start
	BSR	DOCURSOR		; Print the current cursor
	
GETCODELP	MOVE.W	AMIGAKEY(A5),D1	; Get our ASCII code...
	TST.W	D1		; Is it a valid keypress?
	BEQ.S	GETCODELP		; No? 
	CMP.W	#$01,D1		; Is it a 'Delete'?
	BEQ.S	CHARDEL		; Yeah! 
	CMP.W	#$02,D1		; Is it the other 'Delete'?
	BEQ.S	CHARDEL		; Yes! (Only one delete supported!)
	CMP.W	#$03,D1		; Is it 'Cursor Left'?
	BEQ.S	GETCODELP		; Unsupported Keypress! Ha!
	CMP.W	#$04,D1		; Is is 'Cursor Right'?
	BEQ.S	GETCODELP		; Yet another unsupported keypress!
	CMP.W	#$0D,D1		; Is it a 'Return' or 'Enter'?
	BEQ.S	CHARENTER		; Yes! End the input

NORMALCHR MOVE.W	CURSOR(A5),D3	; Retrieve cursor position	
	CMP.W	#PASSLEN,D3	; Is this the spare cursor slot
	BNE.S	NOTSPARE		; No? Carry on as normal
	MOVE.W	#$770,COLOR00(A6)	; Max. Length reached so flash screen
	BRA.S	NOCURSINC		; Reset key then go back...
NOTSPARE	MOVE.B	D1,(A0,D3.W)	; Move into Password
	BSR	PRINTPASS		; Print the Password 
	CMP.W	#PASSLEN,D3	; Check against Maximum length + 1
	BEQ.S	NOCURSINC		; Don't increase position if greater
	BSR	DOCURSOR		; Delete the old cursor
	ADD.W	#1,CURSOR(A5)	; Not maximum, so increase position
	BSR	DOCURSOR		; Print cursor at new position
NOCURSINC	MOVE.W	#0,AMIGAKEY(A5)	; Reset for next keypress
	BRA	GETCODELP		; Back for the next character!

CHARDEL	MOVE.B	#32,D1		; We want to space the character out
	MOVE.W	CURSOR(A5),D3	; Retrieve cursor position
	TST.W	D3		; Is this character zero?
	BEQ.S	NOCURSDEC		; Yes? Then don't do anything
	
	CMP.W	#PASSLEN,D3	; Is the cursor in spare slot?
	BEQ.S	NOPRIDEL		; No Primary Delete 
	MOVE.B	D1,(A0,D3.W)	; Delete current character
NOPRIDEL	SUB.W	#1,D3		; Cursor back one place
	MOVE.B	D1,(A0,D3.W)	; Delete character at new cursor pos.
	
	BSR	PRINTPASS		; Print the Password
	BSR	DOCURSOR		; Delete the old cursor
	MOVE.W	D3,CURSOR(A5)	; Store new cursor position
	BSR	DOCURSOR		; Print cursor at new position
	
NOCURSDEC	MOVE.W	#0,AMIGAKEY(A5)	; Reset for next keypress
	BRA	GETCODELP		; Back for another key

CHARENTER	TST.W	CURSOR(A5)	; Is this character zero
	BNE.S	ENTEROK		; No? Then it's ok to exit
	MOVE.W	#$770,COLOR00(A6)	; Flash screen
	MOVE.W	#0,AMIGAKEY(A5)	; Reset for next keypress
	BRA	GETCODELP		; Back for another key
	
ENTEROK	BSR	DOCURSOR		; Remove the cursor
	ADD.W	#1,CURSOR(A5)	; Increase position
	MOVE.W	CURSOR(A5),D3	; Retrieve position
	MOVE.B	#0,(A0,D3.W)	; Place 'End_Of_Text' marker
	
	RTS			; Return to main caller

PRINTPASS	LEA	PASSWORD(PC),A0	; Point to start of Password
	MOVEQ	#28,D1		; I'm doing this so that I don't
	MOVEQ	#102,D2		; have to print individual chars.
	BSR	PRINTLINE		; Print up spaces
	RTS	
	
DOCURSOR	MOVEM.L	D1-D4/A0,-(A7)	; Stack Registers
	MOVEQ	#0,D1		; Clear D0
	MOVE.W	CURSOR(A5),D1	; Get cursor position
	ADD.W	#28,D1		; Add Password start position
	MOVEQ	#102,D2		; Always same vertical position
	MOVE.L	SCREEN(A5),A0	; Retrieve screen address
	MOVE.L	#SCRWIDTH*PLANES,D4	; D4 holds line length
	ADD.L	#SCRWIDTH,A0	; Point to a different bitplane
	MOVE.L	D4,D3		; We don't want to scrap D4 yet!
	MULU.W	D2,D3		; D3 now points to correct scanline
	ADD.W	D1,D3		; D3 now points to correct offset
	LEA	(A0,D3),A0	; A3 now has the actual screen addr.
	MOVEQ	#7-1,D0		; Repeat 7 times
CURSORLP	NOT.B	(A0)		; Do a line of the old cursor
	ADD.L	D4,A0		; Add line length from above
	DBF	D0,CURSORLP	; Loop back for next screen line
	MOVEM.L	(A7)+,D1-D4/A0	; Restore Registers
	RTS			; Back we go!
	
*************************************************
* PRINTSTAT :- Prints text in status box        *
*              A0.L ---> Address of status text *
*************************************************
PRINTSTAT	MOVEM.L	D1-D2,-(A7)	; Stack coords
	MOVEQ	#27,D1		; X Coordinate
	MOVEQ	#113,D2		; Y Coordinate
	BSR	PRINTLINE		; Lets print that text!
	MOVEM.L	(A7)+,D1-D2	; Unstack coords
	RTS			; Return
	
*****************************************************
* PRINTLINE :- Prints text string at position X,Y   *
*              A0.L ---> Address of message text    *
*              D1.B	---> X position (in characters) *
*              D2.B	---> Y position (in lines)      *
*****************************************************

PRINTLINE	MOVEM.L	D0-D1/A0,-(A7)	; Stack registers
	MOVEQ	#0,D0		; Make sure D0 is clear
PLLOOP	TST.B	(A0)		; Is this end_of_string?
	BEQ.S	PLINEEXIT		; Yeah! Lets head home!
	MOVE.B	(A0)+,D0		; Get next character
	BSR	PRINTCHAR		; Print the character
	ADDQ	#1,D1		; Next X position
	BRA.S	PLLOOP		; Back for next one!
PLINEEXIT	MOVEM.L	(A7)+,D0-D1/A0	; Retrieve registers
	RTS			; Return to caller
	
***************************************************
* PRINTCHAR :- Prints a character at position X,Y *
* Parameters:- Character Code (ASCII code!)    D0 *
*	     X coordinate (in 8 pixel steps) D1 *
*	     Y coordinate (in 1 pixel steps) D2 *
***************************************************

PRINTCHAR	MOVEM.L	D0-D4/A0-A1,-(A7)	; Stack registers
	MOVE.L	SCREEN(A5),A0	; Retrieve screen address
	MOVE.L	#SCRWIDTH*PLANES,D4	; D4 holds line length
	MOVE.L	D4,D3		; We don't want to scrap D4 yet!
	MULU.W	D2,D3		; D3 now points to correct scanline
	ADD.W	D1,D3		; D3 now points to correct offset
	LEA	(A0,D3),A0	; A3 now has the actual screen addr.
	
	LEA	FONT(PC),A1	; Point to our font...
	SUB.W	#32,D0		; First character is 'Space'
	LSL.W	#3,D0		; Multiply by 8 to get font offset
	LEA	(A1,D0.W),A1	; A0 points to correct place in font
	MOVEQ	#8-1,D0		; Repeat 8 times
PRTCHARLP	MOVE.B	(A1)+,(A0)	; Move line into screen memory
	ADD.L	D4,A0		; Add line length from above
	DBF	D0,PRTCHARLP	; Loop back for next screen line
	MOVEM.L	(A7)+,D0-D4/A0-A1	; Restore registers
	RTS
	
******************************************
* BLITWAIT :- Wait for Blitter to finish *
******************************************
		
BLITWAIT	BTST	#14,DMACONR(A6)
	BNE.S	BLITWAIT
	RTS

***************************************************
* LEVEL3 :- This is the Level 3 interrupt routine *
***************************************************
LEVEL3	MOVEM.L	D0-D7/A1-A6,-(A7)
	AND.W	#$0010,INTREQR(A6)	; Mask the COPPER bit from INTENAR
	BEQ.S	LEVEL3EX		; Not from copper!
	
MYLEVEL3	NOP			; No Interrupt in Decoder! 

	MOVE.W	#$0010,INTREQ(A6)	; Clear copper interrupt bit
				; My Interrupt routine follows
LEVEL3EX	MOVEM.L	(A7)+,D0-D7/A1-A6
	RTE

***************************************************
* LEVEL2 :- This is the Level 2 interrupt routine *
***************************************************
LEVEL2	MOVEM.L	D0-D7/A1-A6,-(A7)
	
	BTST	#3,$BFED01	; Is Ciaa interrupt for SP/Keyboard
	BEQ.S	LEVEL2EX		; No? Then Exit this Interrupt Code.
	
MYLEVEL2	BSR	READKEYS		; Read the Keyboard...

LEVEL2EX	MOVE.W	#$0008,INTREQ(A6)	; Clear ports interrupt bit

	MOVEM.L	(A7)+,D0-D7/A1-A6
	RTE

****************************************************************************
* READKEYS :- Reads the keyboard and translates to Ascii on Ciaa interrupt *
****************************************************************************

READKEYS	MOVEM.L	D0-D2/A0,-(A7)	; Stack registers
	BSET	#6,$BFEE01	; Start Handshake with Keyboard
	MOVEQ	#0,D0		; Clear D0 to prepare for Calculation
	MOVE.L	D0,D1		; Clear D1 for later on...
	
	MOVE.W	D0,AMIGAKEY(A5)	; Clear ASCII value
	
	MOVE.B	$BFEC01,D0	; Get Raw Key value
	
	NOT.B	D0		; Invert all bits
	LSR.B	#1,D0		; Put bits in correct order
	BCS.S	RKEYEXIT		; We only want 'Down' presses
	
	CMP.W	LASTRAW(A5),D0	; Is this the same key?
	BEQ.S	RKEYEXIT		; Yes? Then we don't want it!
	
	LEA	KEYTABLE(PC),A0	; Point to our Keyboard Table
	MOVE.B	(A0,D0.W),D1	; D1 should hold our ASCII value.
	MOVE.W	D1,AMIGAKEY(A5)	; Store a our ASCII value...
	
RKEYEXIT	MOVE.W	#9,D0		; Wait 90 microseconds to be sure of
	BSR	WAIT		; a successful handshake...

	BCLR	#6,$BFEE01	; Complete Handshake. Must be > 85µs	
	MOVEM.L	(A7)+,D0-D2/A0	; Restore Registers
	RTS			


***************************************************************
* CONTROL :- This performs all of the main tasks of DiskCoder *
***************************************************************
CONTROL	MOVEM.L	D1-D4/A0,-(A7)	; Stack registers
	BSR	GETCODE		; Read Password!

TRYAGAIN	MOVEQ	#0,D1		; Response register is reset!
	
	LEA	$BFD100,A0	; Point to Drive Select Register
	MOVE.B	#$79,(A0)		; Motor is to be turned on
	BCLR	#3,(A0)		; Select drive to be turned on...
	
	MOVE.W	#500,D0		; Must wait 500ms before continuing
	BSR	WAIT		; See Hardware Ref. Manual Page 239!
	
	STEP	OUT		; We only want to step the
	STEPTRACK	3,WAIT		; disk to get all of the drive flags
				; Wait the 3 milliseconds as stated
				; in Hardware Reference Manual...
	STEP	IN		; We'll step out and then back in 
	STEPTRACK	3,WAIT		; again, so we don't break the drive!
	
	BTST	#2,$BFE001	; Is there a disk in the drive?
	BNE.S	DSKTHERE		; Yes? Then continue!
	
	LEA	DISKMESS(PC),A0	; Point to 'No Disk' message
	BRA	CHECKFAIL		; Failure handler
	
DSKTHERE	BTST	#3,$BFE001	; Is the disk write protected?
	BNE.S	DISKOK		; No? Then all validation is Ok!
	
	LEA	WRITEMESS(PC),A0	; Point to 'Disk Write Protected'
	BRA	CHECKFAIL		; Failure handler
	
DISKOK	BTST	#5,$BFE001	; Is the Drive up to speed?
	BNE.S	DISKOK		; No? Wait until it is!

	BSR	CODEDISK		; Encode the tracks and install disk
	
	LEA	DONEMESS(PC),A0	; Point to 'Coding Completed'
	BSR	PRINTSTAT		; Print status line
	MOVEQ	#0,D1		; Response indicates success
	
CONTWAIT	LEA	$BFD100,A0	; Point to Drive Select Register
	MOVE.B	#$F9,(A0)		; Motor is to be turned off
	BCLR	#3,(A0)		; Select drive to be turned off...
	
	MOVE.W	#2000,D0		; We'll wait for 2 seconds 
	BSR	WAIT		; Wait before erasing message

	TST.B	D1		; Was this a successful run?
	BNE	TRYAGAIN		; No? Then go back and try again!
	
	MOVEM.L	(A7)+,D1-D4/A0	; Restore register contents
	RTS

CHECKFAIL	BSR	PRINTSTAT		; Print reason for failure
	MOVEQ	#1,D1		; Response is FAILURE
	BRA	CONTWAIT		; Back to Wait/Motor off/Retry
	
************************************************************************
* WAIT :- Waits for a specific amount of time to pass before returning *
*         Pass the number of Milliseconds in register D0.              *
************************************************************************
	
WAIT	MOVEM.L	D0-D1/A0,-(A7)	; Stack registers
	LEA	$BFE001,A0	; Point to CIAA addresses
	MOVE.B	$E00(A0),D1	; Set control register A on CIAA
	AND.B	#%11000000,D1	; Don't trash bits we are not
	OR.B	#%00001000,D1	; using.....
	MOVE.B	D1,$E00(A0)	; Write bits back...
	MOVE.B	#$CC,$400(A0)	; Set Timer to wait for exactly
	MOVE.B	#$02,$500(A0)	; 1 millisecond..
	AND.L	#$FFFF,D0		; Mask off the upper word
WAITTIMER	BTST.B	#0,$D00(A0)	; Is Timer-Expired flag set?
	BEQ.S	WAITTIMER		; No? Then wait until it is!
	BSET.B	#0,$E00(A0)	; Restart timer...	
	DBF	D0,WAITTIMER	; Back until done.
	MOVEM.L	(A7)+,D0-D1/A0	; Restore registers
	RTS
	
*************************************************
* CODEDISK :- Copy Track Zero into Memory       *
*             Encode our random tracks          *
*             Write Track Zero on Track 160     *
*             Install DiskDecoder on Track Zero *
*************************************************

CODEDISK	BSR	PASSKEY		; Calculate Password Key
	BSR	SETDISK		; Set Disk DMA values
	
	MOVE.W	#0,CURRTRACK(A5)	; Set as reference for FindTrack
	SEEKZERO	3,WAIT		; Find Track Zero
	LOWERHEAD			; Place head on correct side
	
	MOVEQ	#2,D0		; We have to load Track Two
	BSR	FINDTRACK		; so that we can tell if the 
	BSR	READTRACK		; password is correct!
	TST.B	D1		; Did it work?
	BNE	FAILURE		; Oh.... I'm stopping then!

	BSR	PASSCRYPT		; Decrypt track using user password!
	
	BSR	CHECKSUM		; Calculate checksum for Track Two
	
	MOVE.L	CHECKVAL(PC),D0	; D0 now holds the checksum
	CMP.L	CHECK(A5),D0	; Is it what we expected?
	BEQ	CODEVALID		; Yes? Then carry on!
	
	LEA	WRONGMESS(PC),A0	; Point to 'Wrong Password' message
	BRA	PASSFAIL		; Go to our Failure Handler
	
CODEVALID	LEA	CODEMESS(PC),A0	; Point to 'Decoding Disk' 
	BSR	PRINTSTAT		; Print on Status Line
	MOVEQ	#0,D0		; Clear D0
	LEA	RANDOMS(PC),A0	; Point to Random Tracks
	MOVEQ	#RNDNUMBER-1,D7	; Set number of 'Random' tracks
ENCODETRK	MOVE.W	(A0)+,D0		; Get the next track number
	BSR	FINDTRACK		; Locate it.
	BSR	READTRACK		; Read it.
	TST.B	D1		; Did it Fail in any way?
	BNE	FAILURE		; Yes? Go to that bit then!
	BSR	PASSCRYPT		; Scramble it!
	BSR	SAVETRACK		; Write track back to disk
NOABORT	DBF	D7,ENCODETRK	; Back for next Track!
	
	MOVE.W	#160,D0		; We'll read original Track Zero
	BSR	FINDTRACK		; Locate it.
	BSR	READTRACK		; Read into our buffers
	TST.B	D1		; Did it work?
	BNE.S	FAILURE
	
	LEA	BOOTMESS(PC),A0	; Point to our 'Installing' message
	BSR	PRINTSTAT		; Print on status line
	
	MOVEQ	#0,D0		; Find Track Zero position
	BSR	FINDTRACK		; Locate it...
	BSR	SAVETRACK		; Save Track Zero back to Disk
	
	MOVEQ	#0,D0		; Response is Success!
CODEDONE	RTS			; Return
	
FAILURE	LEA	FAILMESS(PC),A0	; Point to Disk Failure message
PASSFAIL	BSR	PRINTSTAT		; Print on status line
	MOVE.W	#2000,D0		; We'll wait for 2 seconds
	BSR	WAIT		; Wait....
	BRA	REBOOT		; Reboot!


*************************************************
* REBOOT :- Kills the machine with a FULL reset *
*************************************************

REBOOT	LEA	RESETCODE(PC),A0	; Point to Reset Code
	MOVE.L	A0,$80.W		; Trap #0 vector changed!
	TRAP 	#0		; Get into Supervisor Mode
	CNOP	0,4		; Longword aligned!
RESETCODE	LEA	2.W,A0		; Point to JMP at start of ROM
	RESET			; RESET!
	JMP	(A0)		; Prefetch gets this instruction!

**************************************************************
* FINDTRACK :- Load a specified track ( track number in D0 ) *
**************************************************************

FINDTRACK	MOVEM.L	D0-D2,-(A7)	; Save registers
	MOVE.W 	D0,NEWTRACK(A5)	; Store new track number.
	MOVE.W	CURRTRACK(A5),D2	; Retrieve current track number
	BTST 	#0,D0		; Is the new track number odd?
	BEQ.S	TRACKLOW		; Yes? Then read the Lower Side
	UPPERHEAD			; No? Then read the Upper Side
	BRA.S	FINDDIFF	
TRACKLOW	LOWERHEAD			; In that case read the UPPER side!
FINDDIFF	CMP.W	D2,D0		; Is current track > new track
	BLE.S 	MOVEIN		; Yes? Then move towards Track Zero
	STEP	OUT		; Otherwise move to Track 159
	BRA.S	FINDNUMB
MOVEIN	STEP	IN	
FINDNUMB	LSR.W	D2		; Divide tracks by two because we
	LSR.W	D0		; we aren't dealing with sides here!
	SUB.W	D2,D0		
	BPL.S	NUMBEROK
	NEG.W	D0		; How many tracks away is new track?
NUMBEROK	TST.W	D0		; If D0 is zero then we don't need
	BEQ.S	OVERTRACK		; to step any tracks,and we've 
	SUBQ	#1,D0		; Subtract one from it for counter.
LOCATEIT	STEPTRACK	3,WAIT		; Step that track! 3ms wait time.
	DBF	D0,LOCATEIT	; Until I've reached the new track

OVERTRACK	MOVE.W	NEWTRACK(A5),CURRTRACK(A5) ; Current Track is New Track
	MOVEM.L	(A7)+,D0-D2	; Restore registers
	RTS

***************************************************************************
* PASSCRYPT :- Encrypts/Decrypts a single track side using the Passkey    *
***************************************************************************
PASSCRYPT	MOVEM.L	D0-D2/A0,-(A7)	; Save registers
	MOVE.L	TRACK(A5),A0	; Point to sector buffer
	MOVE.L	PASSVALUE(A5),D0	; Retrieve Password Key value
	MOVE.L	#(11*512)/4,D1	; Encrypt one track.
CRYPTLOOP	MOVE.L	(A0),D2		; Get Longword
	EOR.L	D0,D2		; EOR with Password Key
	EOR.L	D1,D2		; EOR with Offset Value
	EOR.L	#$C5EAD12B,D2	; EOR with my own 'Random' Value
	MOVE.L	D2,(A0)+		; Write Longword back
	SUBQ.L	#1,D1		; Decrease counter
	BNE.S	CRYPTLOOP		; Loop until finished
	MOVEM.L	(A7)+,D0-D2/A0	; Restore registers
	RTS			; Go Back

************************************************
* CHECKSUM :- Calculate checksum for Track Two *
************************************************
CHECKSUM	MOVEM.L	D0-D2/A0,-(A7)	; Stack registers
	MOVE.L	CHECK(A5),D0	; Retrieve Current Checksum
	MOVE.L	TRACK(A5),A0	; Point to Sector Buffer
	MOVE.L	#(11*512)/4,D1	; Repeat for 11 Sectors/1 Track
CHECKLOOP	ADD.L	(A0)+,D0		; Add Longword into Checksum
	MOVE.L	PASSVALUE(A5),D2	; Retrieve Password Key
	EOR.L	D2,D0		; Scramble further using Password Key
	SUBQ.L	#1,D1		; One from counter
	TST.L	D1		; Are we Finished?
	BNE.S	CHECKLOOP		; No? Then do another Longword
	MOVE.L	D0,CHECK(A5)	; Store checksum.
	MOVEM.L	(A7)+,D0-D2/A0	; Retrieve registers
	RTS			; Go back.

***************************************************************************
* PASSKEY :- Calculates a longword (returned in D0) based on the Password *
***************************************************************************
PASSKEY	MOVEM.L	D0-D1/A0,-(A7)	; Save registers
	LEA	PASSWORD(PC),A0	; Point to Password string
	MOVEQ.L	#0,D0		; Clear D0
	MOVEQ.L	#0,D1		; Clear D1
PKEYLOOP	MOVE.B	(A0)+,D1		; Get byte from Password
	BEQ.S	PASSKEYX		; Have we finished??
	ROL.L	#6,D0		; Rotate 6 bits to the left 
	ADD.L	D1,D0		; Add password character
	EOR.L	#$07061969,D0	; Scramble with my Birthday!
	EOR.L	D1,D0		; Exclusive or with character
	ROL.L	#5,D1		; Rotate a few bits!
	BRA.S	PKEYLOOP		; Back for next character!
PASSKEYX	MOVE.L	D0,PASSVALUE(A5)	; Store the Password Key
	MOVEM.L	(A7)+,D0-D1/A0	; Restore registers
	RTS			; Go Back.

***********************************************
* SETDISK :- This sets the Disk DMA registers *
***********************************************
SETDISK	MOVE.W	#$4489,DSKSYNC(A6)	; Syncword
	MOVE.W	#$4000,DSKLEN(A6)	; Disable writing
	RTS

**********************************************************
* READTRACK :- Read a track in MFM Format using Disk DMA *
**********************************************************
READTRACK MOVEQ	#READTRIES-1,D2	; Maximum number of read attempts
RTRKLOOP	MOVE.L	TRACKBUFF(A5),DSKPTH(A6)
	MOVE.W	#$7F00,ADKCON(A6)	; Clear ADKCON
	MOVE.W	#$9500,ADKCON(A6)	; MFM, with PRECOMP
	MOVE.W	#$9980,DSKLEN(A6)
	MOVE.W	#$9980,DSKLEN(A6)	; Read $1980 Words
	WAITDISK			; Wait for Disk DMA to Stop
	BSR.S	DECODE	
	TST.B	D1		; Has the Decode worked?
	BEQ.S	READEXIT		; Yes! Let's quit it!
	DBF	D2,RTRKLOOP	; No? Let's try again!
READEXIT	RTS

***********************************************************
* SAVETRACK :- Write a track in MFM Format using Disk DMA *
***********************************************************
SAVETRACK	BSR	ENCODE		; Encode Scrambled Track to MFM Data
	MOVE.L	TRACKGAP(A5),DSKPTH(A6)
	MOVE.W	#$7F00,ADKCON(A6)	; Clear ADKCON
	CMP.W	#80,CURRTRACK(A5)	; Is current track greater than 80
	BLT.S	PRECOMP		; No? Then skip this setting
	MOVE.W	#$A500,ADKCON(A6)	; Set precomp to 140ns
	BRA.S	SAVEIT		; Skip next setting
PRECOMP	MOVE.W	#$9500,ADKCON(A6)	; Set no precomp
SAVEIT	MOVE.W	#$D980,DSKLEN(A6)
	MOVE.W	#$D980,DSKLEN(A6)	; Write $1980 words 
	WAITDISK			; Wait for Disk DMA to Stop
	MOVE.W	#$4000,DSKLEN(A6)	; Disable writing...
	RTS

******************************************************************
* DECODE :- Decodes MFM Format track pointed at by TRACKBUFF(A5) *
******************************************************************
DECODE	MOVEM.L	D0/D2-D6/A0-A2,-(A7); Save registers
	MOVE.L	TRACK(A5),A0	; Pointer to decoded data
	MOVE.L	TRACKBUFF(A5),A1	; Pointer to trackbuffer
	MOVE.L	#$55555555,D3	; Value for decoder
	MOVEQ	#10,D5		; Decode 11 blocks
DECNEXTBK	CMP.W	#$4489,(A1)+	; Check for next sync word
	BEQ.S	NOGAP		; Hey! There's no other syncs!
NOSYNC	CMP.W	#$4489,(A1)+	; Search for next sync
	BNE.S	NOSYNC		; Not there! Back we go!
NOGAP	CMP.W	#$4489,(A1)	; Skip all remaining syncs
	BNE.S	SKIPSYNC		
	ADDQ.W	#2,A1
	BRA.S	NOGAP
SKIPSYNC	MOVE.L	(A1)+,D0		; Read data from buffer
	MOVE.L	(A1)+,D1
	AND.L	D3,D0		; Remove clock bits
	AND.L	D3,D1
	ADD.L	D0,D0
	OR.L	D1,D0
	MOVE.L	D0,D1
	AND.L	#$FF000000,D1	; Check if header is alright
	CMP.L	#$FF000000,D1
	BNE.S	FATALERR		; If not -> ERROR
	AND.L	#$0000FF00,D0	; Get sector number
	ADD.L	D0,D0
	MOVE.L	A0,A2
	ADD.L	D0,A2		; Add to get the right pos.
	ADD.L	#$28,A1		; Skip the rest
	MOVE.L	(A1)+,D4		; Decode Data-Checksum
	MOVE.L	(A1)+,D1		; Store it in D4
	AND.L	D3,D4
	AND.L	D3,D1
	ADD.L	D4,D4
	OR.L	D1,D4
	MOVEQ	#127,D6		; Decode 2*128 longwords
	MOVEQ	#0,D2
DECNEXT	MOVE.L	512(A1),D1	; Decode data block
	MOVE.L	(A1)+,D0
	EOR.L	D0,D2		; Calculate Checksum
	EOR.L	D1,D2
	AND.L	D3,D0		; Decode longword
	AND.L	D3,D1
	ADD.L	D0,D0
	OR.L	D1,D0
	MOVE.L	D0,(A2)+		; Store longword in buffer
	DBF	D6,DECNEXT	; Decode next longword
	AND.L	D3,D2		; Skip illegal bits
	CMP.L	D4,D2		; Compare checksums
	BNE.S	FATALERR		; If not equal -> error
	ADD.W	#$0200,A1		; Add for next block
	DBF	D5,DECNEXTBK	; Back for next block
	MOVEQ	#0,D1		; Return code : OK
DCODEEXIT	MOVEM.L	(A7)+,D0/D2-D6/A0-A2; Restore registers
	RTS

FATALERR	MOVEQ	#-1,D1		; Failure
	BRA.S	DCODEEXIT		; Leave properly!

**********************************************************
* ENCODE : Codes a track into MFM format for Writing     *
**********************************************************

ENCODE	MOVEM.L	D0-D7/A0-A4,-(A7)	; Save registers
	MOVE.L	TRACK(A5),A0	; Get Data address
	MOVE.L	TRACKBUFF(A5),A1	; Get MFM Buffer address
	MOVE.L	#$55555555,D5	; Mask For Even Bits
	MOVEQ	#11,D7		; Code 11 Sectors
	MOVEQ	#0,D6		; Sector Number

CODELOOP	LEA	8(A1),A2
	MOVE.L	A1,A3
	MOVE.L	#$FF000000,D0	; Format Sign
	MOVEQ	#0,D1
	MOVE.W	CURRTRACK(A5),D1	; Track number is needed for MFM
	SWAP	D1
	OR.L	D1,D0		; Store Track Number (0-159)
	MOVE.W	D6,D1
	ASL.W	#8,D1
	OR.W	D1,D0		; Store Sector Number (0-10)
	OR.W	D7,D0		; Store Sectors until gap (11-1)

	MOVE.L	#$00000000,(A1)+	; Store coded zero bytes
	MOVE.L	#$44894489,(A1)+	; Move in Sync bytes
	BSR	CODELONG		; Code the Info-Block
	MOVE.L	D0,(A1)+		; Move in Odd Data
	MOVE.L	D1,(A1)+		; Move in Even Data

	MOVEQ	#8-1,D2		
STORELAB	CLR.L	(A1)+		; Store sector label ( not used )
	DBF	D2,STORELAB	

	MOVEQ	#0,D0
	MOVEQ	#10-1,D2		; Calculate checksum over 40 bytes
HEADCHECK	MOVE.L	(A2)+,D1
	EOR.L	D1,D0
	DBF	D2,HEADCHECK
	BSR.S	CODELONG		; Code the Header Checksum
	MOVE.L	D0,(A1)+		; Store Header Checksum (Odd)
	MOVE.L	D1,(A1)+		; Store Header Checksum (Even)

	LEA	16(A2),A2		; Point to buffer for Odd bits
	LEA	512(A2),A4	; Point to buffer for Even bits
	MOVEQ	#128-1,D2		; Code 128 longwords...

CODEDATA	MOVE.L	(A0)+,D0		; Fetch program data from memory
	BSR.S	CODELONG
	MOVE.L	D0,(A2)+		; Store Coded Data (Odd)
	MOVE.L	D1,(A4)+		; Store Coded Data (Even)
	DBF	D2,CODEDATA

	LEA	8(A1),A2		; Skip space for Data Checksum
	MOVEQ	#0,D0		; Clear checksum 
	MOVE.W	#256-1,D2
DATACHECK	MOVE.L	(A2)+,D1
	EOR.L	D1,D0		; Calculate Data Checksum
	DBF	D2,DATACHECK
	BSR.S	CODELONG		; Code it into MFM format
	MOVE.L	D0,(A1)+		; Store Data Checksum (Odd)
	MOVE.L	D1,(A1)+		; Store Data Checksum (Even)

	MOVEQ	#0,D4		; Set Clock bits for InfoBlock
	BSR.S	SETCLOCKS

	LEA	4(A3),A3		; Skip syncs
	MOVE.W	#270-1,D4		; Set Clock bits for 270 Longwords
	BSR.S	SETCLOCKS

	ADD.W	#1024,A1		; Skip coded Data bits
	ADDQ.W	#1,D6
	SUBQ.W	#1,D7
	BNE	CODELOOP		; Right! Back for the next Sector
	MOVEQ	#0,D0
	MOVEM.L	(A7)+,D0-D7/A0-A4	; Restore registers
	RTS			; Back to the main program

SETCLOCKS	MOVE.B	-1(A3),D3		; Byte from previous longword
	NOT.B	D3		; Invert it.
	ANDI.L	#1,D3		; Mask off Bit 0
	ROR.L	#1,D3		; Shift Bit 0 to Bit 31
	MOVE.L	(A3),D0		; Fetch next longword
	MOVE.L	D0,D1
	EOR.L	D5,D0
	MOVE.L	D0,D2
	LSL.L	#1,D0
	LSR.L	#1,D2		
	OR.L	D3,D2		; Set Bit 31 if necessary
	AND.L	D2,D0
	OR.L	D1,D0
	MOVE.L	D0,(A3)+
	DBF	D4,SETCLOCKS
	
	RTS

CODELONG	MOVE.L	D0,D1
	LSR.L	#1,D0
	AND.L	D5,D0		; D0 is coded Odd  bits
	AND.L	D5,D1		; D1 is coded Even bits
	RTS

***********************************
* Data for Variables & CopperList *
***********************************
	RSRESET
OLDDMA	RS.W	1	; For DMA status of Amiga OS
OLDINT	RS.W	1	; For Interrupt status of Amiga OS
OLDREQ	RS.W	1	; For Interrupt Request status of Amiga OS
OLDLEV3	RS.L	1	; Old Autovector Level 3 storage
OLDLEV2	RS.L	1	; Old Autovector Level 2 storage
OLDLIST	RS.L	1	; System CopperList address
SCREEN	RS.L	1	; Address of our Custom Screen
AMIGAKEY	RS.W	1	; ASCII value from Keyboard routine
LASTRAW	RS.W	1	; Last RawKey value from CIA
CURSOR	RS.W	1	; Cursor position within Password String
PASSVALUE	RS.L	1	; Password Key Value
TRACK	RS.L	1	; Holds address of Decoded Track Data
TRACKGAP	RS.L	1	; Holds address of Track Gap prior to MFM Data
TRACKBUFF	RS.L	1	; Holds address of MFM Data Buffer
CURRTRACK	RS.W	1	; Holds current track number
NEWTRACK	RS.W	1	; Holds new track number
CHECK	RS.L	1	; Holds checksum calculated from Track Two
VARLENGTH	RS.W	0

VARIABLES	DCB.B	VARLENGTH,0

GFXNAME	DC.B	"graphics.library",0
	EVEN
TITLEMESS	DC.B	"DiskDecoder Version 2.0",0
	EVEN
CREDMESS	DC.B	"Coded in June 1991 By Dean Ashton. "
	DC.B	"Ideas by Ronan Jezequel.. Thanks!",0
	EVEN
WAITMESS	DC.B	"Enter Password for Disk",0
	EVEN
WRONGMESS	DC.B	" Password is Incorrect ",0
	EVEN
CODEMESS	DC.B	"I'm Decoding your Disk!",0
	EVEN
DISKMESS	DC.B	"Hey! Where's the Disk!!",0
	EVEN
WRITEMESS	DC.B	"Disk is Write Protected",0
	EVEN
BOOTMESS	DC.B	" Restoring Track Zero! ",0
	EVEN
DONEMESS	DC.B	" ** Coding Complete ** ",0
	EVEN
FAILMESS	DC.B	"Fatal Disk Format Error",0
	EVEN
BYEMESS	DC.B	"    **  Bye Bye!  **   ",0
	EVEN
PASSWORD	DCB.B	PASSLEN,0		; Zero fill password initially
	EVEN
************************************
*  Copper List for Screen Display  *
************************************
NEWCOPPER	DC.W	DIWSTRT,$3481	; Top left corner of screen.
	DC.W	DIWSTOP,$FCC1	; Bottom right corner of screen.
	DC.W	DDFSTRT,$3C	; Data fetch start.
	DC.W	DDFSTOP,$D4	; Data fetch stop.
	DC.W	BPL1MOD,SCRWIDTH	; Set modulo for odd planes.
	DC.W	BPL2MOD,SCRWIDTH	; Set modulo for even planes.
 	DC.W	BPLCON0,$A200	; Set BPLCON0 to 2 bitplane hi-res.
				
	DC.W	COLOR00,$0000 	; Light Grey ---
	DC.W	COLOR01,$0000	; Black        |_ Looks like
	DC.W	COLOR02,$0FFF	; White        |  System 2.0!
	DC.W	COLOR03,$079F	; Sky Blue   ---

 	DC.W	BPL1PTH		; Bitplane high word.
PLANE1HI	DC.W	0
	DC.W	BPL1PTL		; Bitplane low word.
PLANE1LO	DC.W	0
 	DC.W	BPL2PTH		; Bitplane high word.
PLANE2HI	DC.W	0
	DC.W	BPL2PTL		; Bitplane low word.
PLANE2LO	DC.W	0

	DC.W	SPR0PTH		; Sprite 1 high word.
SPR0HI	DC.W	0		 
	DC.W	SPR0PTL		; Sprite 1 low word.
SPR0LO	DC.W	0
				; Byte Offsets for Words
NOSPRITES	DC.W	SPR1PTH,0,SPR1PTL,0	;  0001,0203,0405,0607
	DC.W	SPR2PTH,0,SPR2PTL,0	;  0809,1011,1213,1415
	DC.W	SPR3PTH,0,SPR3PTL,0	;  1617,1819,2021,2223
	DC.W	SPR4PTH,0,SPR4PTL,0	;  2425,2627,2829,3031	
	DC.W	SPR5PTH,0,SPR5PTL,0	;  3233,3435,3637,3839
	DC.W	SPR6PTH,0,SPR6PTL,0	;  4041,4243,4445,4647
	DC.W	SPR7PTH,0,SPR7PTL,0	;  4849,5051,5253,5455

* BACK = $999
	DC.W	$820F,$FFFE,$0180,$E55,$0182,$EEE
	DC.W	$830F,$FFFE,$0180,$833
	DC.W	$8C0F,$FFFE,$0180,$522,$0182,$000
	
	DC.W	$8D0F,$FFFE,$0180,$88D,$0182,$EEE
	DC.W	$8E0F,$FFFE,$0180,$55B
	DC.W	$970F,$FFFE,$0180,$229,$0182,$000
	
	DC.W	$980F,$FFFE,$0180,$EE7
	DC.W	$990F,$FFFE,$0180,$885
	DC.W	$A20F,$FFFE,$0180,$553
	
	DC.W	$A30F,$FFFE,$0180,$5EE,$0182,$FFF
	DC.W	$A40F,$FFFE,$0180,$388
	DC.W	$AD0F,$FFFE,$0180,$255,$0182,$000
	DC.W	$AE0F,$FFFE,$0180,$000
	


	DC.W	INTREQ,$8010	; Cause copper interrupt!

ENDCOPPER	DC.L	COPPER_HALT	; CopperList end marker

DEADSPR	DC.L	0		; Null Sprite!

FONT	INCBIN	"source:dean/Data/System.Fnt"	    ; Load system font (Pearl 8)

*****************************************************
* KEYTABLE Information... 	Delete Back     = $01 *
*			Delete Forwards = $02 *
*			Cursor Left     = $03 *
*			Cursor Right    = $04 *
*****************************************************

KEYTABLE	DC.B	"'1234567890-=\",0,"0"
	DC.B	"QWERTYUIOP[]",0,"123"
	DC.B	"ASDFGHJKL;#",13,0,"456"
	DC.B	0,"ZXCVBNM,./",0,".789"
	DC.B	" ",1,0,13,13,0,2,0,0,0,"-",0,0,0,4,3
KEYEND	EQU 	KEYTABLE-*
	DCB.B	128-KEYEND,0	; Fill rest of keytable..
	EVEN
	
