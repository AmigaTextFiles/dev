*******************************************************************************
* BOOT MENU V2.0 CODED BY PROFFESIONALS FOR LAMERS
* MAIN USER INTERFACE START UP CODED 9/2/91 - 10/2/91
* UPDATED 12/2/91 TO INCLUDE GADGET SELECTION AND EVENT CHECKING
* ALL CODE AND GFX BY THE ONE AND ONLY TROG/ODESSA
* YET ANOTHER FINE UTILITY SOURCE WITH FULL DOCUMENTATION BY TROG
* ALL AMIGA COMPATIBLE INC (KICKSTART V2.04 37.175)
* I DON'T USE INCLUDE FILES BECASE I HAVE'T GOT ALL DAY AND NO HARD DRIVE
* COPYRIGHT (C) 1992 
*******************************************************************************
 OPT     C-		            * NO CASE SENSATIVE
 INCLUDE source:include/LIBOFFSETS.I  * THE ONE AND ONLY MAGIC INCLUDE FILE
*******************************************************************************
MAIN:
	JSR	OPENLIBRARYS		* OPEN VARIOUS SYSTEM LIBRARYS
	MOVE.L	ERRORFLAG,D6		* COPY ERROR FLAG TO D6
	TST.L	D6			* TEST ERROR FLAG
	BEQ	QUIT			* ZERO = ERROR 1 = O.K
	JSR	ALLOCATEMEM		* RESERVE MEMORY FOR BMAP
	MOVE.L	ERRORFLAG,D6		* SEE ABOVE FOR DETAILS
	TST.L	D6			
	BEQ	LIBCLOSE
	JSR	SETUPBITMAP		* INTIALIZE A BITMAP
	JSR	OPENNEWSCREEN		* OPEN UP A CUSTOM SCREEN
	MOVE.L	ERRORFLAG,D6		* SEE ABOVE FOR DETAILS
	TST.L	D6
	BEQ	NOSCREEN
	JSR	COPYCOLORS		* COPY BMAP COLORS INTO H/WARE REGISTERS
	JSR	WINDOPEN		* OPEN WINDOW
	MOVE.L  ERRORFLAG,D6		* SEE ABOVE FOR DETAILS
	TST.L	D6
	BEQ	NOWINDOW
	JSR	STATUSBORDER		* DRAW BORDER FOR STATUS TEXT
	JSR	STATUSTEXT		* START UP STATUS TEXT
	JSR	MAINPRG			* MAIN ROUTINE TO TEST EVENTS
CLOSEALL:
	JSR	WINDCLOSE		* CLOSE WINDOW
NOWINDOW:	
	JSR	CLOSENEWSCREEN		* CLOSE SCREEN
NOSCREEN:
	JSR	DEALLOCATEMEM		* FREE RESERVED MEMORY
LIBCLOSE:	
	JSR	CLOSELIBRARYS		* CLOSE SYSTEM LIBRARIES
QUIT:
	RTS				* RETURN TO CLI
*******************************************************************************
OPENLIBRARYS:
	MOVE.L  $4,A6		* EXECBASE ADRESS
	LEA     DOS(PC),A1	* POINTER TO DOS.LIBRARY
        MOVEQ   #$0,D0		* ANY VERSION WILL DO
	JSR	OPENLIBS(A6)	* OPENLIBRARY
	TST.L	D0		* IF ERROR NO LIBRARY RETURN TO VLI
	BEQ	RETURNTOCLI	* NO LIBRARY THE QUIT BACK TO CLI
	MOVE.L  D0,DOSBASE	* STORE DOS.LIBRARY BASE ADRESS

	LEA	GRAPH(PC),A1	* OPEN GRAPHICS.LIBRARY
	MOVEQ	#$0,D0		* SAME AS ABOVE
	JSR	OPENLIBS(A6)
	TST.L   D0
	BEQ	DOSCLOSE
	MOVE.L  D0,GRAPHBASE

	LEA	INT(PC),A1	* OPEN INTUITION.LIBRARY
	MOVEQ	#$0,D0		* SAME AS ABOVE
	JSR	OPENLIBS(A6)
	TST.L   D0
	BEQ	GRAPHCLOSE
	MOVE.L  D0,INTBASE
ALLLIBSOPEN:
	MOVE.L	#1,ERRORFLAG	* NO ERROS EVERYTHING OPENEND O.K
	RTS			
*******************************************************************************
CLOSELIBRARYS:
INTCLOSE:
	MOVE.L  $4,A6		* EXECBASE
	MOVE.L  INTBASE,A1	* INTUITION.LIBRARY POINTER TO LIB
	JSR	CLOSELIBS(A6)	* SYSTEM CALL TO CLOSE LIB

GRAPHCLOSE:
	MOVE.L  $4,A6		* EXECBASE	
	MOVE.L  GRAPHBASE,A1	* GRAPHICS.LIBRARY POINTER TO LIB
	JSR	CLOSELIBS(A6)	* SAME AS ABOVE
	
DOSCLOSE:
	MOVE.L  $4,A6		* EXECBASE
	MOVE.L	DOSBASE,A1	* DOS.LIBRARY BASE POINTER TO LIB
	JSR	CLOSELIBS(A6)	* SAME AS ABOVE

RETURNTOCLI:
	MOVE.L	#0,ERRORFLAG	* UNKNOWN ERROR QUIT FAST
	RTS
*******************************************************************************
*OPENSCREEN AND MENU ROUTINE
*******************************************************************************
OPENNEWSCREEN:
	MOVE.L  INTBASE,A6		* INTUITION LIBRARY BASE ADRESS
	LEA	SCREEN,A0		* SCREEN START ADRESS
	JSR	OPENSCREEN(A6)		* LIBRARY CALL TO OPEN SCREEN
	MOVE.L	D0,SCREENADRESS		* STORE SCREEN START ADRESS
	MOVE.L  D0,SCRNADRESS		* STORE SCREEN POINTER FOR WINDOW
	BEQ	CLEARMEM        	* WAS THERE A ERROR IF SO CLOSE DOWN
	MOVE.L	#1,ERRORFLAG		* SCREEN O.K NO ERRORS
	RTS
CLEARMEM:
	MOVE.L	#0,ERRORFLAG		* UNKNOWN ERROR OCURED
	RTS				* FREEMEM CLOSE LIBS AND QUIT

*******************************************************************************
CLOSENEWSCREEN:
	MOVE.L  INTBASE,A6		* INTUITION BASE ADRESS
	MOVE.L  SCREENADRESS,A0		* CUSTOM SCREEN START ADRESS
	JSR	CLOSESCREEN(A6)		* LIBRARY CALL TO CLOSE SCREEN
	RTS
*******************************************************************************
* SET UP A BITMAP SCREEN
*******************************************************************************
SETUPBITMAP:	MOVE.L		BITMAP,A0	*A0->UNINITIALISED BM STRUCT
		MOVE.L		A0,A3		*STORE A COPY FOR LATER
		MOVEQ.L		#2,D0		*D0=SCREEN DEPTH
		MOVE.L		#320,D1		*D1=SCREEN WIDTH
		MOVE.L		#256,D2		*D2=SCREEN HEIGHT
		MOVE.L		GRAPHBASE,A6    *GRAPHICSBASE ADRESS
		JSR		INITBITMAP(A6)  *LIBRARY CALL TO MAKE BITMAP

		MOVE.L		A3,A0		*A0->BITMAP STRUCTURE
		ADD.L		#$8,A0		*A0->ADDR OF PLANE POINTERS
		MOVE.L		#PIC,D0	*D0=ADDR OF PICTURE
		MOVE.L		#(320/8)*256,D1	*D1=SIZE OF EACH PLANE
		MOVEQ.L		#1,D2		*D2=NUM OF PLANES - 1
LOOP:		MOVE.L		D0,(A0)+	*ADDR OF NEXT PLANE INTO STRUCT
		ADD.L		D1,D0		*D0=ADDR OF NEXT PLANE
		DBRA		D2,LOOP 	*FOR ALL PLANES
		MOVE.L		D0,A3		*A3->COLOURS
		RTS

COPYCOLORS:	
		MOVE.L		SCREENADRESS,A0	*A0->SCREEN STRUCTURE
		ADD.L		#$2C,A0 	*A0->SCREENS VIEWPORT STRUCT
		LEA		COLORS,A1	*A1->COLOURS
		MOVEQ.L		#4,D0		*D0=NUMBER OF COLOURS
		MOVE.L		GRAPHBASE,A6	*GRAPHICSBASEADRESS
		JSR		LOADRGB4(A6)	*LOAD COLORS INTO COL REG
		RTS
*******************************************************************************
*MEMORY ALLOCATION ROUTINE FOR THE BOOT BUFFER
*******************************************************************************
ALLOCATEMEM:
	MOVE.L  $4,A6				* ABSOLOTE EXECBASE ADRESS
	MOVE.L 	#30780,D0			* NUMBER OF BYTES TO RESERVE
	MOVE.L	#MEMF_CHIP!MEMF_CLEAR,D1	* TYPE OF RAM CHIP
	JSR	ALLOCMEM(A6)			* EXEC LIBRARY CALL
	MOVE.L  D0,BITMAP			* START ADRESS OF RESERVED MEMORY
	MOVE.L	D0,SBITMAP			* STORE START IN SCREEN STRUC
	TST.L	D0				* NON ZERO MEM START ADRESS
	BEQ	NOMEM				* NO MEMORY AVAILABLE
	MOVE.L  #1,ERRORFLAG			* EVERYTHING O.K
	RTS
NOMEM::
	MOVE.L	#0,ERRORFLAG			* UNKNOWN ERROR CLOSE LIBS
	RTS
*******************************************************************************
DEALLOCATEMEM:
	MOVE.L	$4,A6		* RETURN MEMORY BACK TO THE SYSTEM POOL
	MOVE.L  #30780,D0	* NUMBER OF BYTES TO RETERN
	MOVE.L  BITMAP,A1	* START OF RESERVED MEMORY
	JSR	FREEMEM(A6)	* EXEC LIBRARY CALL TO FREE MEM
	RTS
*******************************************************************************
*OPEN WINDOW SCREEN
*******************************************************************************
WINDOPEN:
	MOVE.L	INTBASE,A6	* INTUITION LIBRAY BASE ADRESS
	LEA	WINDOW,A0	* WINDOW START ADRESS
	JSR	OPENWINDOW(A6)	* OPENWINDOW LIBRARY OFFSET
	MOVE.L	D0,WINDOWADRESS	* STORE SCREEN START ADRESS
	TST.L	D0		* TEST FOR A ZERO
	BEQ	WINDOWERROR	* ZERO THEN QUIT (NO WINDOW)
	MOVE.L	#1,ERRORFLAG	* EVERYTHING O.K
	RTS
WINDOWERROR:
	MOVE.L	#0,ERRORFLAG	* CLEAR ERROR FLAG (UNKNOWN ERROR OCURED)
	RTS
WINDCLOSE:
	MOVE.L	INTBASE,A6	* INTUITION BASE ADRESS
	MOVE.L	WINDOWADRESS,A0	* WINDOW ADRESS
	JSR	CLOSEWINDOW(A6) * SYS CALL TO CLOSE WINDOW
	RTS
*******************************************************************************
* DRAW BORDER FOR STATUS LINE
*******************************************************************************
STATUSBORDER:
	MOVE.L  INTBASE,A6		* INTUITION BASE ADRESS
	LEA	BORDER,A1		* BORDER STRUCTURE
	MOVE.W	#20,D0			* BORDER X POSTION
	MOVE.W  #150,D1			* BORDER Y POSTION
	MOVE.L	WINDOWADRESS,A0		* WINDOW START ADRESS
	MOVE.L	50(A0),A0		* WINDOWS RASTPORT STRUCTURE
	JSR	DRAWBORDER(A6)		* O/S CALL TO DRAW BORDER
	RTS
*******************************************************************************
* PRINT STATUS TEXT START MESSAGE
*******************************************************************************
STATUSTEXT:
	MOVE.L  INTBASE,A6		* INTUITION BASE ADRESS
	LEA	STATUSTXT,A1		* POINTER TO TEXT TO BE OUTPUT
	MOVE.L  #28,D0			* TEXT START X POSTION
	MOVE.L  #136,D1			* TEXT START Y POSTION
	MOVE.L  WINDOWADRESS,A0		* WINDOW START ADRESS
	MOVE.L  50(A0),A0		* WINDOWS RASTPORT STRUCTURE
	JSR	PRINTITEXT(A6)		* O/S CALL TO PRINT TEXT
	RTS					
*******************************************************************************
*LIBRARY NAMES POINTERS ECT
*******************************************************************************
LIBRARYS:
DOS:  	DC.B "dos.library",0		* NAME OF THE LIBRARIES TO
      	EVEN				
GRAPH: 	DC.B "graphics.library",0	* OPEN DOS INTUITION AND
	EVEN
INT:   	DC.B "intuition.library",0	* GRAPHICS
	EVEN
*******************************************************************************
* VARIOUS STORAGE AND SYS POINTERS
*******************************************************************************
DOSBASE:   	DC.L 0		* STORE FOR DOS.LIBRARY BASE ADRESS
GRAPHBASE: 	DC.L 0		* STORE FOR GRAPHICS.LIBRARY BASE ADRESS
INTBASE:   	DC.L 0		* STORE FOR INTUTION.LIBRARY BASE ADRESS
BITMAP:	   	DC.L 0		* POINTER TO RESERVED BMAP MEMORY
ERRORFLAG: 	DC.L 0		* POINTER TO ERROR FLAG
SCREENADRESS:   DC.L 0  	* POINTER TO CUSTOM SCREEN
WINDOWADRESS:	DC.L 0		* POINTER TO WINDOW
*******************************************************************************
* BINARY INCLUDE FILES AND VARIOUS BITS AND BOBS
*******************************************************************************
COLORS:		  DC.W	$000,$FFF,$AAA,$CCC			* BMAP COLORS
PIC:		  INCBIN		source:Trog/BITMAPS/MENU2.BM	* TITLE LOGO
QUITGAD:	  INCBIN		source:Trog/BITMAPS/QUIT.BM	* GADGET IMAGES
ABOUTGAD:	  INCBIN		source:Trog/BITMAPS/ABOUT.BM
NOTICEGAD:	  INCBIN		source:Trog/BITMAPS/NOTICE.BM
MENUGAD:	  INCBIN		source:Trog/BITMAPS/MENU.BM
COLORGAD:	  INCBIN		source:Trog/BITMAPS/COLOR.BM
SCROLLGAD:	  INCBIN		source:Trog/BITMAPS/SCROLL.BM
DRIVE0GAD:	  INCBIN		source:Trog/BITMAPS/DRIVE0.BM
DRIVE1GAD:	  INCBIN		source:Trog/BITMAPS/DRIVE1.BM
INSTALLLOADERGAD: INCBIN		source:Trog/BITMAPS/INSTALLL.BM
INSTALLMENUGAD:	  INCBIN		source:Trog/BITMAPS/INSTALLM.BM
INSTALLBOOTGAD:   INCBIN		source:Trog/BITMAPS/INSTALLB.BM 
LOGOGAD:	  INCBIN		source:Trog/BITMAPS/LOGOGAD.BM
*******************************************************************************
*SCREEN DEFINICION AND SCREEN POINTERS
*******************************************************************************
TITLESCREEN:   DC.B "    BOOT MENU VERSION 2 (ENHANCED)",0	* SCREEN NAME
	       EVEN
SCREEN:
X_POSITION: 	DC.W 0				*X STARTING POSITION
Y_POSITION:  	DC.W 0				*Y STARTING POSITION
SCWIDTH:	DC.W 320			*SCREEN WIDTH
SCHEIGHT:	DC.W 256			*DCREEN HEIGHT
DEPTH:		DC.W 2				*NUMBER OF PLANES
DETAIL_PEN:	DC.B 1				*FOREGROUND PEN COLOR
BLOCKPEN:	DC.B 3				*BACKGROUND PEN COLOR
VIEW_MODES:	DC.W 2				*VIEWING MODES (NORMAL)
SCREEN_TYPE:    DC.W CUSTOMSCREEN!CUSTOMBITMAP  *SCREENTYPE
FONT:		DC.L 0				*POINTER TO FONT
TITLE:		DC.L TITLESCREEN		*POINTER TO TITLE
GADGETS:	DC.L 0				*CUSTOM GADGETS
SBITMAP:	DC.L 0				*POINTER TO BITMAP
		EVEN
*******************************************************************************
* WINDOW STRUCTURE
*******************************************************************************
WINDOW:
XPOS:		DC.W	0		* X POSTION WINDOW START
YPOS:		DC.W	50		* Y POSTION WINDOW START
WIDTH		DC.W	320		* WINDOW WIDTH
HEIGHT		DC.W	180		* WINDOW HEIGHT
PCOLR		DC.B	1		* PRINT COLOR
BCOLR		DC.B	3		* BACKGROUNDCOLOR	
ICDMP:		DC.L	GADGETUP	* WHAT EVENTS INTUITION SHOULD REPORT
ACTI:		DC.L	RMBTRAP!BORDERLESS * ACTIVE GADGETS
GAD:		DC.L	QUITGADGET	* FIRST GADGET	
CMARK:		DC.L	0		* CHECKMARK
NAME:		DC.L	0		* WINDOW NAME
SCRNADRESS:	DC.L	0		* SCREEN BASE ADRESS POINTER
BMAP:		DC.L	0		* BITMAP FOR WINDOW
SWIDTH:		DC.W	0		* SMALLEST WIDTH
SHIEGHT:	DC.W	0		* SMALLEST HEIGHT
MWIDTH:		DC.W	0		* MAX WIDTH
MHIEGHT:	DC.W	0		* MAX HEIGHT
STYPE:		DC.W	CUSTOMSCREEN	* SCREEN TYPE
*******************************************************************************
*SCREEN GADGET STRUCTURES
*******************************************************************************
QUITGADGET:
	DC.L	ABOUTGADGET		* POINTER TO NEXT GADGET
	DC.W	5			* X POSTION OF GADGET
	DC.W	5			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	QUITBM			* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	PRGEND			* USER DATA
QUITBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	QUITGAD			* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
ABOUTGADGET:
	DC.L	NOTICEGADGET		* POINTER TO NEXT GADGET
	DC.W	110			* X POSTION OF GADGET
	DC.W	5			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	ABOUTBM			* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	1			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
ABOUTBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	ABOUTGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
NOTICEGADGET:
	DC.L	MENUGADGET		* POINTER TO NEXT GADGET
	DC.W	220			* X POSTION OF GADGET
	DC.W	5			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	NOTICEBM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
NOTICEBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	NOTICEGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
MENUGADGET:
	DC.L	COLORGADGET		* POINTER TO NEXT GADGET
	DC.W	5			* X POSTION OF GADGET
	DC.W	40			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	MENUBM			* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
MENUBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	MENUGAD			* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
COLORGADGET:
	DC.L	SCROLLGADGET		* POINTER TO NEXT GADGET
	DC.W	110			* X POSTION OF GADGET
	DC.W	40			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	COLORBM			* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
COLORBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	COLORGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
SCROLLGADGET:
	DC.L	INSTALLBOOTGADGET	* POINTER TO NEXT GADGET
	DC.W	220			* X POSTION OF GADGET
	DC.W	40			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	SCROLLBM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
SCROLLBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	SCROLLGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
INSTALLBOOTGADGET:
	DC.L	INSTALLMENUGADGET	* POINTER TO NEXT GADGET
	DC.W	5			* X POSTION OF GADGET
	DC.W	80			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	INSTALLBOOTBM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	WRITE0			* USER DATA
INSTALLBOOTBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	INSTALLBOOTGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
INSTALLMENUGADGET:
	DC.L	INSTALLLOADERGADGET	* POINTER TO NEXT GADGET
	DC.W	110			* X POSTION OF GADGET
	DC.W	80			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	INSTALLMENUBM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
INSTALLMENUBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	INSTALLMENUGAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
INSTALLLOADERGADGET:
	DC.L	DRIVE0GADGET		* POINTER TO NEXT GADGET
	DC.W	220			* X POSTION OF GADGET
	DC.W	80			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	INSTALLLOADERBM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
INSTALLLOADERBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	INSTALLLOADERGAD	* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
DRIVE0GADGET:
	DC.L	DRIVE1GADGET		* POINTER TO NEXT GADGET
	DC.W	5			* X POSTION OF GADGET
	DC.W	120			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	DRIVE0BM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
DRIVE0BM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	DRIVE0GAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
DRIVE1GADGET:
	DC.L	LOGOGADGET		* POINTER TO NEXT GADGET
	DC.W	110			* X POSTION OF GADGET
	DC.W	120			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	DRIVE1BM		* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
DRIVE1BM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	DRIVE1GAD		* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
*******************************************************************************
LOGOGADGET:
	DC.L	0			* POINTER TO NEXT GADGET
	DC.W	220			* X POSTION OF GADGET
	DC.W	120			* Y POSTON OF GADGET
	DC.W	82			* GADGET WIDTH		
	DC.W	21  			* GADGET HEIGHT
	DC.W	GADGIMAGE		* GADGET TYPES
	DC.W	RELVERIFY		* ACTIVATION FLAGS
	DC.W	BOOLGADGET		* GADGET TYPE BOOLAN
	DC.L	LOGOBM			* PONTER TO GADGET GFX	
	DC.L	0			* POINTER TO NEXT GFX GADGET
	DC.L	0			* POINTER TO GADGET TEXT	
	DC.L	0			* DEACTIVATE GADGETS ONCE SELECTED
	DC.L	0			* SPECIAL GADGET INFO
	DC.W	0			* GADGET I.D NUMBER
	DC.L	0			* USER DATA
LOGOBM:
	DC.W	0			* X POSTION OF GADGET
	DC.W	0			* Y POSTION OF GADGET
	DC.W	82			* X BITMAP SIZE
	DC.W	22			* Y BITMAP SIZE
	DC.W	2			* NUMBER OF PLANES
	DC.L	LOGOGAD			* POINTER TO BITMAP DATA
	DC.B	1			*
	DC.B	6			* 
	DC.L	0			* NEXT IMAGE STRUCTURE
***********************************************************************************
* BORDER STRUCTURE TO FRAME TEXT
***********************************************************************************
BORDER:
	DC.W	0			* X POSTION OFFSET
	DC.W	0			* Y POSTION OFFSET
	DC.B	3			* COLOR
	DC.B	3			* COLOR
	DC.B	0			* MODE (JAM1)
	DC.B	5			* 5 X/Y PAIRS
	DC.L	COORD			* POINTER TO CORDINATES TABLE
	DC.L	0			* NO MORE USER DATA OR STRUCTURES
COORD:
	DC.W	-2			* X POSTION START UPPER LEFT
	DC.W	-2			* Y POSTION START UPPER LEFT
	DC.W	270			* X POSTION START UPPER RIGHT
	DC.W	-2			* Y POSTION START UPPER RIGHT
	DC.W	270			* X POSTION START LOWER LEFT
	DC.W	9			* Y POSTION START LOWER LEFT
	DC.W	-2			* X POSTION START LOWER LEFT
	DC.W	9			* Y POSTION START LOWER LEFT
	DC.W	-2			* BACK TO X POSTION START
	DC.W	-2			* BACK TO Y POSTION START
*********************************************************************************
* STATUS LINE START UP TEXT STRUCTURE
*********************************************************************************
STATUSTXT:	DC.B	1,0,1
		EVEN
		DC.W	-8,14
		DC.L	0
		DC.L	STARTUPTXT
		DC.L	0
STARTUPTXT:	DC.B	"STATUS = O.K WAITING FOR COMMANDS",0
		EVEN
*******************************************************************************
* MAIN PRG ROUTINE TO TEST GADGET SELECTION AND EXECUTE EVENTS THAT HAPPEN
*******************************************************************************
MAINPRG:
	MOVE.L	4,A6			* EXECBASE ADRESS
	MOVE.L	WINDOWADRESS,A0		* WINDOW STRUCTURE START ADRESS
	MOVE.L  USERPORT(A0),A0		* POINTER TO USER PORT
	JSR	WAITPORT(A6)		* WAIT FOR SOMETHING TO HAPPEN
	MOVE.L	WINDOWADRESS,A0		* WINDOW STRUCTURE
	MOVE.L	USERPORT(A0),A0		* USER PORT OF WINDOWSTRUCTURE
	JSR	GETMSG(A6)		* O/S CALL TO SEE IF ANYTHING HAPPEND
	MOVE.L	D0,A1			* COPY D0 TO A1 FOR O/S REPLY (BE NICE)
	MOVE.L  IDFLAG(A1),D2		* REPORT EVENTS FROM INTUITION
	MOVE.L	GADGETA(A1),A2		* SAVE GADGET ADRESS
	JSR	REPLYMSG(A6)		* TELL O/S MESSAGE RECIEVED
	CMP.L	#GADGETUP,D2		* WAS A GADGET SELECTED
	BEQ	EVENT			* IF IT WAS THEN BRANCH
	BRA	MAINPRG			* ELSE WAIT FOR ANOTHER EVENT
PRGEND:        
	RTS				* QUIT WAS SELECTED CLOSE ALL AND LEAVE
EVENT: 
	MOVE.L	GUSERDATA(A2),A0	* POINTER TO ROUTINE TO EXECUTE
	CMPA.L	#0,A0			* TEST TO SEE IF GADGET IS SELECTABLE
	BEQ	MAINPRG			* NO! THEN CARRY ON WAITING
	JMP	(A0)			* JUMP TO GAGET ROUTINE
*******************************************************************************
* GADGET SUBROUTINES FOLLOW
* THIS ROUTINE OPENS AND CLOSES THE TRACK DISK DEVICE
*******************************************************************************
OPENTRACK:
	MOVE.L	$4,A6			*EXECBASE STRUCTURE
	MOVE.L	#$0,A1			*NAME OF TASK TO FIND (0)
	JSR	FINDTASK(A6)		*FIND TASK
	MOVE.L	D0,TRACKPORT+$10	*STORE POINTER IN PORT+1 (HEX $10)
	LEA	TRACKPORT,A1		*POINTER TO TRACK PORT
	JSR	ADDPORT(A6)		*ADDPORT TO SYSTEM LIST (REPLY PORT)
	LEA	DISKIO,A1		*POINTER TO DISK I/O AREA
	MOVE.L	#$0,D0			*DRIVE 0
	CLR.L	D1			*NO FLAGS
	LEA	TRACKDISK,A0		*DEVICE TO OPEN *TRACKDISK.DEVICE*
	JSR	OPENDEVICE(A6)		*OPEN DEVICE
	TST.L	D0			*TEST FO ERRORS
	BNE	TERROR	        	*BRANCH IF ERROR OCURED
	RTS				*ELSE TRACKDISK IS OPEN FOR USE
*******************************************************************************
CLOSETRACK:
	MOVE.L	$4,A6			*EXECBASE STRUCTURE
	LEA	TRACKPORT,A1		*POINTER TO PORT (REPLY)
	JSR	REMPORT(A6)		*REMOVE PORT FROM SYSTEM LIST
	LEA	DISKIO,A1		*POINTER TO DISK I/O AREA
	JSR	CLOSEDEVICE(A6)		*CLOSE TRACKDISK
TERROR:	RTS  				*PROGRAME RETURN
*******************************************************************************
*THIS ROUTINE WRITES BOOT BLOCKS AND CALCULATES CHECKSUMS
*******************************************************************************
CHECK: 
	MOVE.L	BOOTDATA,A0			*BOOTBLOCK PRG STORAGE (1K)
	LEA	4(A0),A1			*POINTER TO BOOT CHECKSUM
	CLR.L	(A1)				*CLEAR REGISTER
	MOVE.W	#$FF,D1				*LONGWORDS IN BLOCK -1
	MOVEQ	#$0,D0				*CLEAR REGISTER
ADLONG:	ADD.L	(A0)+,D0			*ADD NEXT LONGWORD TO D0
	BCC	NXTLNG				*CHECK D1 IF CHANGE IN   FLAG
	ADDQ.L	#1,D0				*THEN ADD LAST LONGWORD (256)
NXTLNG:	DBF	D1,ADLONG			*SUB 1 FROM D1 AND BRA
	NOT.L	D0				*REVERSE D0
	MOVE.L	D0,(A1)				*WRITE NEW CHECKSUM TO BOOTPRG
	RTS
WRITE0:	
	BRA	BOOTMEM				*RESERVE BOOT MEMORY
BOOTOK:
	MOVE.W	#512,D1				*AMOUNT OF L/WORDS TO COPY
	LEA	BOOTPRG,A0			*ADRESS OF BOOT PROG
	MOVE.L	BOOTDATA,A1			*ADRESS OF CHIP RAM TO COPY TO
MOVEBT:	MOVE.W	(A0)+,(A1)+			*COPY PROG TO CHIP RAM:
	DBRA	D1,MOVEBT			*BRANCH AND TILL DONE
	BSR	CHECK

WRITEBOOT:
	BSR	OPENTRACK                       *OPEN TRACKSIDE USER TASK
	MOVE.L	$4,A6				*EXECBASE STRUCTURE
	LEA	DISKIO,A1			*DISK I/O STRUCTURE
	MOVE.L  #TRACKPORT,14(A1)		*PORT REPLY STRUCTURE
	MOVE.W	#CMD_WRITE,IO_COMMAND(A1)	*TRACK COMMAND WRITE (3)
	MOVE.L  BOOTDATA,IO_DATA(A1)		*START OF DATA TO WRITE
	MOVE.L  #2*512,IO_LENGTH(A1)		*AMOUNT OF DATA TO WRITE 
	MOVE.L  #0*512,IO_OFFSET(A1)		*OFFSET 0 = BOOTBLOCK
	JSR	DOIO(A6)			*WRITE BOOT

	LEA	DISKIO,A1			*SAME ROUTINE AS THE
	MOVE.L	#TRACKPORT,14(A1)		*ONE ABOVE DOES EVERYTHING
	MOVE.W	#CMD_READ,IO_COMMAND(A1)	*THE SAME EXCEPT IT READS
	MOVE.L	BOOTDATA,IO_DATA(A1)		*BLOCK 100 INSTEAD AND READ
	MOVE.L  #2*512,IO_LENGTH(A1)		*FORCES THE
	MOVE.L  #100*512,IO_OFFSET(A1)		*BUFFER TO BE EMPTIED HENCE
	JSR	DOIO(A6)			*WRITES THE BOOTBLOCK 

MOTOROFF:
	LEA	DISKIO,A1			*DISK I/O STRUCTURE
	MOVE.W	#TD_MOTOR,IO_COMMAND(A1)	*COMMAND MOTOR O=OFF 1=ON
	MOVE.L	#0,IO_LENGTH(A1)		*0= TURN MOTOR OFF
	JSR	DOIO(A6)			*TURN MOTOR OFF
	BSR	CLOSETRACK			*CLOSE TRACKDISK USER TASK
	BSR	FREEBOOT			*RETURN BOOT MEM
NOBOOT:	BRA	MAINPRG				*RETURN TO PROGRAME
*******************************************************************************
* RESERVE MEMORY FOR BOOT BUFFER 
*******************************************************************************
BOOTMEM:
	MOVE.L	4,A6				* EXECBASE ADRESS
	MOVE.L  #1024,D0			* AMOUNT OF MEM TO RESERVE
	MOVE.L  #MEMF_CHIP!MEMF_CLEAR,D1	* MEM TYPE
	JSR	ALLOCMEM(A6)			* O/S TO RESERVE MEMORY
	TST.L	D0				* ZERRO THEN NO MEM
	BEQ	NOBOOT				* ERROR ROUTINE
	MOVE.L	D0,BOOTDATA			* STORE RESERVED MEMORY
	BRA	BOOTOK
FREEBOOT:
	MOVE.L	4,A6				* EXECBASE ADRESS
	MOVE.L	#1024,D0			* AMOUNT OF MEM TO RETURN
	MOVE.L	BOOTDATA,D1			* START OF RESERVED MEM
	JSR	FREEMEM(A6)			* O/S CALL TO FREEMEM
	RTS
*******************************************************************************
*TRACKDISK VARIBLES I/O STRUCTURES AND PORTS ECT
*******************************************************************************
TRACKDISK:	DC.B "trackdisk.device",0 *NAME OFF DEVICE
		EVEN				
DISKIO:		DS.L	20		  *RESERVE 20 LONGWORDS FOR STRUCTURE
TRACKPORT:	DS.L	8		  *RESERVE 8 LONGWORDS FOR STRUCTURE
BOOTDATA:	DC.L	0		  *POINTER TO BOOT BUFFER MEMORY
BOOTPRG:	INCBIN		source:Trog/BOOT.S
