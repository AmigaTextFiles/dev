©1991 DragonMasters/Unity

		********************************************
		** Having done FA for the last few months **
		** I'm back with a vengence...Raistlin 91 **
		********************************************

   	      Blitting an object & moving it over a background
	  ----------------------------------------------------------
Or the cookie doodle as I like to call it.

Before I start this doc I presume a few things:-

1. That you read ACC  
2. You are competent with the blitter (ie understand all its registers
   and their use).
3. It would be best if you already understand either:-
   i)How to move bobs left & right   or   ii)Understand the cookie cut 
					     function
3. You definately need to know how to scroll playfields left & right
   (wierd but true)




This doc is in two parts.  Part one describes the theory behind the cookie
-cut fuction & moving bobs & also gives you a few suggestions. Part two is 
the actual source tutorial.


PART1
-----
As we all know the blitter has 4 channels, A B C D.  Those of you that only
do bob-screen blits will only have used A-D.  When blitting to a background
though you need to use ABCD.  Heres what is loaded into each channel:-

A =Actual bob data
B =Mask of the bob
C =Previously saved background data
D =Destination

What goes in channel A and D is the same as usual.  But whats this mask?
Well Mike Cross said in his tutorial it didn't matter, baloney!  The mask
is extremely important.  So what is it?  Pretend your object is real & its
infront of you & the sun is behind it.  A shadow will be cast infront of
it.  This shadow is black whereever the sun is blocked & none existant where
the sun gets through (ie hole in object).  So what am I getting at.  Well
The object was initially 3D, just as your bob has so many bitplanes.  The
shadow is 2D just as your mask will only be ONE bitplane.  So your mask
is 1 when there is a one in ANY of the bitplanes of your bob & zero when
their is a zero in ALL the bitplanes.  An example is called for:-

A Triangle shaded in 3 bitplanes might look like:-

plane1	plane2	plane3		The mask would be

0001000	0001000	0000000		0001000
0000000	0011100	0011100		0011100
0111110	1000111	0101110		0111110
0001111	1111111	1111000		1111111

As you can see the mask is a silhouete outline of the triangle.

So how do you make your mask?  Entirely up to you but I advise:-

1.When you have finished your masterpiece of a bob in Dpaint save it
2.Pic up the bob as a brush
3.Clear the Screen
4.Select color1 as your drawing color.
5.Select color1 as your background color
6.Press the RMB while positioning the brush/bob on screen.
  Clear the brush & you will see a silhouete of your bob
7.Set background & pen colour back to normal
8.Save the mask & convert it to RAW format & you've finished
9.Send me a fiver!

or 2

Use my mask maker routine (or develop your own)

*NB convert your actual bob & mask to the same size & save both
    with the same co-ordanates.

So you've got the mask.  whats the C channel got in it?
The data for the background where you wish to blit.  An example:-
If you are blitting a bob to the Screen+55*40 & the bob is W44 H55
you need to save Screen+55*40 W44 H55 smewhere.  You are simply
saving the background where you are blitting to

You normally copy the area of background somewhere with the blitter BEFORE 
you begin the actual cookie-cut routine.

So how does it work?  Ok here you, the little old reader have a choice:-
1. Read the next paragraph, understand how you select the correct miniterms
   and then go on to perform wonderfull tricks with the blitter.

2. Do the same thing reading someone elses tutorial.

3. Sod the next paragraph,  say to yourself the miniterms are always the same
   for this particular use of the cookie-cut (which they are) and don't learn
   how to do alsorts of weird things with the good old blitter.

Decided? good

you made a good choice there pal (ged it?).  

The blitter can combine the 4 channels in upto 256 different ways.  Now this
may make you think, god this is going to be hell, however it is simple when
you know how.  However everyone makes a pigs ear of explaining the miniterms
& so I probably will, my advice is to experiment & learn.

The posible miniterm combinations are:-

 A  B  C  D		BLTCON0 pos 
 0  0  0  ?		     0
 0  0  1  ?		     1
 0  1  0  ?		     2
 0  1  1  ?		     3
 1  0  0  ?		     4
 1  0  1  ?		     5
 1  1  0  ?		     6
 1  1  1  ?		     7

(Taken from Hardware reference manual) (by the way the HRM makes the best 
attempt at explaining these miniterms)

In the above table a 0 means not & a 1 means on.
each of these miniterms mean (in order)

  A	    B		C		BLTCON0 pos
		 
NOT A	   NOT B       NOT C		    0
NOT A  	   NOT B       	   C		    1
NOT A          B       NOT C 		    2
NOT A          B   	   C		    3
    A 	   NOT B       NOT C		    4
    A 	   NOT B           C		    5
    A          B       NOT C		    6
    A          B           C		    7
		
And what the bloody hell does that mean?  Simply put when you turn on
a miniterm the blitter blits a 1 (oposed to a zero) if one of the
set miniterms meets the conditions that the 3 channels are in. 

The 3 letters are AND'd together. so The first line produces a one when 

notA and notB and notC =1   

the second line

notA and notB and C=1

 An example

I want a one blitted if:-
SourceA=1 SourceB=1 SourceC=0
this can be writen as either

A  B  C
1  1  0

or 
A and B and NOT C 


but you have 8 minterms so what about the other 7?  Well if you only
wanted the above combination to produce a 1 all of the other miniterms
would be turned off.  However generally we want several conditions to
produce a 1.

When this is the case the miniterms are OR'd. ie


notA and notB and notC
or
A and B and C
=1

A final example, close to home. For your A-D normal blit the miniterms
are:-

A and B and C
or
A and B and notC
or
A and notB and C
or
A and notB and notC

because you only want a 1 when the A source is set & don't care about
the rest seing as they are unitialized.

OK exaplaining over heres how the miniterms affect us.
Channels are
A=Actual source data
B=bob mask
C=Saved destiation data
D=Destination (screen0

We wont the following conditions
1 when the bob has a 1

1 when the background has a 1 and the bob has a zero because in this 
condition the bob is transparent

1 when the background has a 0 and the bob has a 1 becuase the bob has
priority as it is being blitted over the background

0 At all other


The miniterms we use are

A  B  C  D	pos
0  0  0  0	0
0  0  1  1	1
0  1  0  0	2
0  1  1  0  	3
1  0  0  1	4
1  0  1  1	5
1  1  0  1	6
1  1  1  1	7

I'll say why now for each position.

0) If there is a zero in all source planes a zero is obvioulsy to be blitted

1) There is no mask or source set to 1 and so the bob obviously aint going
   to be blitted here (during an A-D blit the background would be blitted 0
   during this condition) and so we want the background to show through.  
   Here we see the background (C) is a 1 & so a one must be blitted.

2) Here only the mask has a 1.  This means the source data is actualy 
   covering this pixel but this particular bitplane has a 0 in this position.  
   For this reason we blit a zero.

3) O.K. here the mask & background has a 1 but the actual bob data has a 0.
   So the bob actualy covers this part of the background so we disregard
   the C destination.  Again this particaular plane has a zero in this pos
   & so we blit a zero

4) Here anyone understanding the use of the mask will say impossible! Why
   well we see a 1 set in the source but a 0 set in the mask. However wherever
   a 1 is set in the bob data a one should have been set in the mask.  If this
   condition was ever true YOU didn't make the mask right.  Because this
   condition will never arise it shouldn't matter what you put here.  But a
   1 is better becuase you want a 1 whenver the bob Source or if the 
   background has a 1 just incase you make a mistake

5) Again this should never happen (not explaining again) should be set to 1
   although shouldn't matter if you use a proper mask.

6) Here the mask & the source data has a 1.  So we want to blit a 1

7) Evrything has a 1 so this should be obvious





Thats my explination of miniterms.  I'm not going any deeper as this
is not a blitter tutorial as such but rarther a 'technique' turorial.

Everyone understanding that should now join MENSA.


If you don't understand it, its because you are thinking too complicatedly.
Miniterms are easy, indeed anything about a comouter is easy, its just
a series of zeros & ones, nothing else.  Things beome hard when we start
applying that logic or we listen to the ignorant,  "God the blitter is
solid to program"  As we all know to actualy set-up the blitter is
easy, however its when we apply that knowledge to something difficult
like a scroller or indeed the cookie-cut that things become hard. 


Now you can all do the cookie cut how is a bob moved?  Here my thanks
must go to Blaine Evans.  I knew the shifts would be used but I was looking
for complicated answers, to move a bob is actualy easier than the cookie
cut (my opinion of course)

A simple shifting is all that is needed.

Thats not quite true.  If you want to save memory then you must use masking
negative modulos & other such things.  Those wishing to adopt this process
should see my move bob across a blank background routine.  However uptil
know I adopt this method:-

Whenever you intend to move a bob always save it with a blank word on its
furthest right side.  This obviously means the blit & mask size will be
one word loner, as well as other such things.



To move a bob right you simply increment its shift value before every blit.
When the shift value is 15 you reset the shift value & add 2 to the 
destination ponters.  To move a bob left you sub 1 from the shift values &
when shift value is 0 reset it to #15 and sub two from the destination 
pointers.  This is obviously exactly the same as moving a playfield 
horizontaly.  Remember that when using the cookie-cut you must do the
same for the B channels shift values.



Part 2
------
Time for the source doc!  if you understood part 1 this section will be
a dodle.  If you skipped part one then don't complain as I'll not describe
them again!

Before I go any further I'd like to say thanks to a few people that helped
me to understand the blitter & its more advanced functions (I'm being
taught line draw mode by Rick now, 3D tutorial next month?)

Thanks to:-

Blaine for the source code on moving a bob left & right.

Rick for teaching me how to use the blitter & the cookie cut function.

Wing for designing the grafix to go with this source.

And of course to Dave Edwards, & Mike Cross for the tutorials (understand
about the mask now Mike?  Who is Mr My interrupt routine is better than
yours anyway?

*********************************************************************
* I advise you to view the source at the same time as reading this  *
* I am!								    *
*********************************************************************
First of all here is what the variables mean:-
gfxaname	usual
gfxbase		usual

Offset		where on screen bob should be blitted

ScrollR		like when scrolling a screen is used to keep track of how
ScrollL		far bob has been moved left & right.
The bitplane is set-up normally (and if you don't know how to set-up a 
bitplane why the hell aren't you reading Mikes tutorial instead of mine?)
and then the colours are loaded using a routine from ACC2 on mikes 
bitplane tutorial (Yep I do read ALL his tutorials)

Next the DMA is set-up the Neil Johnstone way.  I hope your way really does
prevent sprite corruption Neil (Tech -sorry!).


Next D3 is loaded with the information I'd like to pass to bltcon0.
That is , an ABCD blit and minterms 11110010.

D5 is loaded with the information I'd like to pass to bltcon1.
ie no shift value as yet & bottom 12 bits set to zero for ever!

a branch is made to my wait vbl routine & then a branch is made to the
GETSOURCE blitter routine.

**MOVE SOURCE TO THE GET SOURCE BLITTER ROUTINE!**
I'll now describe the GETSOURCE blitter routine

firstly the start address of the screen is loaded into a0.  The offset
is then added to this value.  The address of the area in memory where
the block of screen data is to be saved to is loaded into a1.

Next comes the usual bitplane loop:-
0. Number of bitplanes-1 for dbra in d0.
1. Test the blitter is free (not married or dating)
1. Number of bitplanes-1 for dbra in d0.
2. do the blit for this plane
3. get to next plane for screen
4. Point to address in memory just after last bitplane was copied to.
5. Keep doing loop until D0=FF(-1) and then exit

.BlitBob
The pointers are loaded.  The a modulo is set to 18 because we are bltting
a block from the screen the same size as the bob & seeing as the bob is
22 bytes wide 40-22=18.  There is no D modulo as I want all the data in
sequental (posh for in order or after each other) memory locations.
there are no masks, like usual blitting. Bltcon1 is set to zero like
usual & bltcon0 is set-up for a normal A-D blit becuase all we are doing is
copying one piece of memory to another (no fancy graphic routines for this
blit thankyou!). Finaly the bltsize register is loaded & away goes the blitter.


**MOVE SOURCE TO THE CLEAR SOURCE BLITTER ROUTINE!**
I'll now describe the CLEAR SOURCE blitter routine.

This is exactly the same as the previous routine except the area
in memory is now the source & the screen is now the destination so
it is EXACLTY the same as a normal A-D blit which I presume you
understand to I'll leave the rest for you to view.


**MOVE SOURCE TO THE CLEAR SOURCE BLITTER ROUTINE!**
I'm very sorry but now its time for the big one! oo-er

First of all some registers are initialized.
1.A0 points to the address of the actual bob data
2.A1 points to the mask
3.A2 points to the area of meory holding the saved background
4.A3 Points to the start address of the screen
5.The offset is added to the screen address in A3

Next a bitplane loop is set-up:-
1. D0=Number of planes-1 (4 for me)
2. Test the blitter status
3. Do the blit for this plane
4. Add #22*55 to A0.  This is effectively pointing to the next bob plane
   as you would do for the normal A-D blit
5. Add #22*55 to A2.  Because the background data saved is the same size
   as the bob each plane of the saved data is the same save as the bob plane
   for this reason we add #22*55 to get to the next saved background plane.
6. Point to the next screen plane as normal in A-D blit
7. Keep blitting & return.

The is only 1 plane and so there is no need(or no way) to point to its
next plane as it only has the one.

Now the actual blitter routine.

All channels are initialised.
A=Actual bob data
B=Mask
C=Saved background data
D=Destination (screen)

The actual bob data, the mask & the saved screen data all lie in sequental
memory & so they don't have a modulo so A's B's & C's modulos are reset.
As normal the destination needs a modulo for the normal reason.  There
is no mask becuase the bob data & mask data has a blank word at the end
so this is normal.
Bltcon0 equals whatever D3 equals (so shift values can be altered)
Bltcon1   '        '    D5   '    ( '   '     '     '   '    '   )

The size is enterd & the blitter zooms away.

Breathe!  If you understood that you can now do the cookie cut
function.  Lets go back to the bra to the GETSOURCE blitter routine, just
above the label mouse wait if you forgot!


Having copied the background destinatin data safely a branch is made to
the main blitter routine (the cookie-cut one!)

Now we enter the main loop.  As usual its a WAITLMB loop (I'm origional
aren't I?)

Inside the loop
---------------
Every loop a branch is made to WaitVbl to synchronize (big words eh?) the
routines with the screen update a branch is then made to the MOVEBOB routine.

Guess what?  Where now going to the move bob routine!!


O.K. move the source to the MOVEBOB routine!
--------------------------------------------
Compared to the blitter operations this is a piece of cake.  Its just like
moving a screen with a bit extra just to be akward!

We have two counters.
The Bob is first moeved right so a branch is made to the MOVEBOBRIGHT routine.
Here the SCROLLR flag is incremented.  
D3 (holds the value to be inserted into bltcon0 remember) is copied to D4.
the bottom 12 bits are masked out with the AND instruction as we only want to
view the current shift value. We then compare the shift value to 15.  If it
is 15 then a branch is made to .INCDEST else 0001000000000000 is added to
the current shift value (doing this only affects the top 4 bits, the shift
value) in both D3(bltcon0) and D4(bltcon1) Because both mask & bob need to be
in the same place whatever we do to D3 we do to D4 (its the same as doing to
Bltcon1 as we do to Bltcon0).  After that the proggy returns from the 
subroutine.

If the shift values where at 15. Then a branch will have been made to 
.INCDEST  Here the 4MSB are masked out with an AND and rhe 12LSB are left
alone.  The same is done to D5
The current SavedBackground data is then replacedon the screen before we
increment the offsets, if the Saved Background data wasn't replaced first
then when the offset was incremented it would be replaced one word too far
to the right & the background would get corupted.  Before returning a branch
is made to the GETSOURCE blitter routine & the BLITTER routine.  If this wasn't
done then the CLEARSOURCE routine would be accessed twice in a row & would
give wierd results.  The program then jumps back to the LMBWAIT loop.

If the bob is moved left then almost the same thing happens.  The main 
difference is that the shift values are decremented so as to make the bob
move left & the offset is also decremented instead of incremented.  the
other main differnec is that when reseting the shift values

1111000000000000 is ORd to D3 & D5 
instead of
0000111111111111 being added.

The reason for this is that previously we wished to scrub the shift values
however here we wish to reset them.  ANDing would obviously not work because
D5 & D3 are a zero.  ORing however inserts a 1 & leaves the 12LSB alone
we OR them with zero.  You could alternatively use 
ADD #%1111000000000000 for this routine 
&
SUB #%1111000000000000 for the previous routine.  I just prefer it
this way.


BACK TO LMB LOOP
----------------
You now know how the routines work.  However it is important to access
the routines in the order I have set.  That is.

1. Wait for the VBL
2. Get the background source data
3. Blit the bob
4. Now enter LMB loop
5. Wait for the VBL again
6. Move the bob
7. Clear the background
8. Get the background data
9. Blit the bob
10. Wait VBL

you may that this order is logical. So are a few more, however for my
routines this is the only order that works.  You're all coders & so
can work out why!

If you learned anything from this tutorial then can I ask you to design
a routine to blit a car going across a road & then disapearing behind
a bridge & then re-appearing.  I would do it myself but I'm off on
my hols tommorrow & so I want have time.



			Happy coding (or code hard to D. Edwards fans)
				
					Raistlin '91

Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!Unity!
