@database 03ce4198-0
@master dh1:Trashcan/PPC68kGuide/PPC680x0.guide
@$VER: 1.0
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" "Index"


            @{b}@{i}@{fg shine}PPC680x0 Official Guidefile version 1.10P@{ub}@{ui}@{fg text}
          ---------------------------------------------
          @{b}@{i}@{fg shine}Written in March-November 1999 by Coyote Flux@{ub}@{ui}@{fg text}


                      @{"PROMO NOTE - READ THIS FIRST" link "PROMONOTE" 0}

                      @{"Prologue" link "Prologue" 0}
                      @{"Missing Functions" link "Missing" 0}
                      @{"What is PPC680x0?" link "WhatIs" 0}
                      How does it work?
                        - @{"External" link "WorkExt" 0}
                        - @{"Internal" link "WorkInt" 0}
                      Usage
                        - @{"General" link "Usage Index" 0}
                        - @{"Programming Environments" link "UsagePG" 0}
                        - @{"Instruction Set Details" link "InsIndex" 0}
                        - Optimizing
                        - @{"Converting Old Programs" link "ConvertOld" 0}
                      @{"Quick Guide" link "Quick" 0}
                      @{"Notes & Thank You's" link "Notes" 0}
                      @{"Copyright?" link "Copyright" 0}
                      @{"Where To Get?" link "Where To Get" 0}
                      @{"Authors" link "Author" 0}
                      @{"History" link "Missing" 35}
                      @{"Our Great Amiga" link "AMIGA" 0}
                      @{"PC Must Die!" link "PC" 0}

@{b}@{i}Good luck!@{ub}@{ui}
@endnode

@node "Prologue" "Prologue"
@{b}@{i}@{fg shine}Prologue@{ub}@{ui}@{fg text}

Welcome to @{"PPC680x0" link "WhatIs" 0}! What you have here is the first source-code  convertor
for the Amiga-PPC platform and the very first one to support kernel-call
detections and support for all the PowerPC features in a 68k
backwards-compatible machine-language.

This is a very complex program. Please understand that there might be small
differences in operation which will be fixed as soon as spotted or
reported.


Let's hope this utility will make PPC programming easier for all  of you!

Now impress us and make a super PPC demo or game!!!

Just a little note: PPC680x0 is a big library function that is  called
everytime you push a button on the PPC68k interface. The library version
will be released somewhere in the near future, allowing realtime conversion
etc.

Also, AltiVec assembling will enter PPC680x0 at the far end of 1999.

Please remember that we are always happy to see bug reports if you think you
have some!!!

Before you start coding, it might be useful to read the @{"Control Instructions" link "InsControl" 0}
@{"" link "InsControl" 0}section as it contains very useful and important commands.
@endnode

@node "Missing" "Missing Functions"
@{b}@{i}@{fg shine}WHAT'S STILL MISSING IN THIS VERSION@{ub}@{ui}@{fg text}


 * some extremely low-level instructions which include trapping
   instructions.
 * Intelligent label detection:
    At this moment PPC680x0 does not detect brackets in labels
    which results in errors when they are used. The final version 
    will detect labels as well as their perfect sizes for 
    optimizations
 * equr, fequr, equrl, reg directives (December 99)
 * Good support for MACROS (December 99)
 * The following instructions:

 bfffo, bfins, bkpt, callm, cas, cas2, chk, chk2, cmp2, cpgen
 cprestore, cpsave, cptrap(cc), pack, pflush, pflusha, ploadr, 
 ploadw, pmove, ptestr, ptestw, reset, rtm, rtr, stop, trap, 
 trapcc, unpk, fmovem, ColdFire MAC commands (December 99)
 
 * AltiVec support and assembler (December 99)
 * SR/CCR loading/storing (such as move SR,d0) (December 99)
 * next 10% of SUPER architecture instructions (December 99)
 * IFF-pictures with schedules and conversion methods
 * PPC680x0.library for low-level usage
 * FPU Conditional instructions are bad (fbcc, fscc etc.) (Dec. 99)
 * See 'Converting Old Programs' for conversion limitations!

@{b}OPTIONAL@{ub}

 * output-organ extensions: There's a possibility that there will
   be new output languages for PPC680x0, which means you can then
   convert your codes to PowerPC, ColdFire etc.. 


@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10g  (November 26th 1999)@{ub}@{fg text}

- Several tiny bug-fixes

- Added some control commands to make things easier...

- Big fat test session!

- Example-files added! (Finally....)

- ??? A LOT!!! Sorry for not remembering all the changes!!!

@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10e  (October 26th 1999)@{ub}@{fg text}

- all PowerAsm incompatibility-bugs FIXED

- push/popgpr added to head/lastrts

- several bug-fixes and changes (sorry for not reporting all the
  changes in detail: A lot of changes have been made without 
  writing it down...!)

- example-files added

- new file-scanning and label detection: MUCH slower conversion,
  MUCH faster code!

- 'adrabs' and 'adrrel' commands added

- ERRORS found to be fixed: Floating Point Condition Commands are
  bad; aligning isn't done automatically

@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10c+  (October 1st 1999)@{ub}@{fg text}

- conditional assembly commands added: not tested, though!

- codeppc / code68k control commands added


@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE 1.10c  (30th September 1999)@{ub}@{fg text}

- zeronorm / zerokill commands added: First commands to use
  backwards block-based referencing.

- Control Commands changing button options now change GUI buttons
  while converting

- 'scc' and 'fscc' commands FIXED

- some commands produced the 'nor' and 'nand' commands instead
  of the required 'orc' and 'andc' commands

- survived 5th test session

- tab termination FIXED

- now works on 68000/010 (tab termination produced GURU!)


@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE 1.10b+ (18th September 1999)@{ub}@{fg text}

@{b}1. FIXES:@{ub}

- WarpUp disabling bad with 'head'

- Some Enforcer hits when quitting. FIXED

- Address calculation bad for 'jsr/jmp/pea (aN)'. FIXED

- 'bsr.s' didn't work. FIXED

- floating point unit was not working properly as nearly 
  80% of the source-code was damaged. I don't know how it
  got damaged so badly, but think it is caused by some
  really bad file-accessing on my up-kicked Amiga. Promo-
  code was mixed throughout the commercial sources. But,
  everything has been totally recoded(!) and FPU support
  is MUCH better now!

- 'bfclr' caused 'nand' command instead of 'andc'

- allocation/deallocation of libraries gave problems when
  libraries didn't exist. This was because PPC68k called
  EasyRequest even when there was no window opened. FIXED

- 64-bits mode caused three extension commands instead of 
  two when direct modes were used. Not a fatal bug, but 
  not really optimized... FIXED

- The ERROROVERFLOW sometimes appeared without any reason.
  This error should actually NEVER appear, so this was a
  bad bug...! You won't see it again, though... FIXED

- The user-editable 'fprom.s' file was not supplied with 
  the release of PPC680x0. My fault... It shouldn't give 
  problems except if the ROM was used by a program. For 
  example:

        fmovecr #2,fp0

  could not be converted. FIXED

- CALL command and several WarpUp/PowerUp commands were
  really bad. FIXED


@{b}2. NEW FEATURES:@{ub}

 - context-switching macro-call commands added (warp, go68,
   wait68, go68s, wait68s, WAITFOR68K, RUN68K, RUN68K_XL)
 - WarpUp kernel offsets added (in 'warp' command)
 - regtables added (regequ, fregequ, crfequ, crequ)
 - Command Line Interface (CLI) added
 - in-line PPC68k control commands
 - WarpUp simple kernel call commands added (via CALL)
 - New commands added: move16, fsabs, fdabs, fsdiv, fddiv,
   fsmove, fdmove, fsneg, fdneg, fsgldiv, fsglmul, fssqrt,
   fdsqrt, fssub, fdsub, fsadd, fdadd, fsmul, fdmul
 - EXTREMELY optimized 32-bits integer->float conversion. 
   Requires only a few cycles on a PPC604. (The PPC has no
   hardware conversion in 32-bits implementations!)
 - New Floating Point Unit
 - PPC680x0 ignores the 'opt' command
 - PPC can access Amiga 68k Libraries with simple DevPac-
   like commands such as 'CALLEXEC', 'CALLDOS' etc. or 
   even with:
 
        move.l  librarybase,a6
        jsr     -offset(a6)

   resulting in ready-to-run code-conversion
 - commands for 68k calls: CALLEXEC, CALLDOS, CALLINT,
   CALLGRAF, libon, liboff

@{b}@{fg shine}
ADDED IN COMMERCIAL RELEASE 1.0 (7th July 1999)@{ub}@{fg text}

 - A LOT EXTRA!!!
 - rN suffix
 - good guidefile
 - most bitfield commands
 - optimizations (too much to list!)
 - bug-fixes (too much to list!)
 - dctv.library conversion routines succesfully converted

@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE EDITION 0.82  (5th July 1999)@{ub}@{fg text}

 - link/unlk set to enabled
 - return terminators added to prevent spaces in between code
 - rest emulation added
 - ext carry emulation fixed
 - many tiny fixes for parts that created trash or forgotten tabs
 - Bit Fields are now in the work-in-progress state, they don't
  give an error, but don't give an output either. Expect them
  tomorrow...!

@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE EDITION 0.8@{ub}@{fg text}

 - link, unlk
 - 68060 Floating Point Unit working and enabled
 - bug-fixes for all conditional and branching instructions
 - optimizations in loading/storing
 - 40% EXTRA of Super Architecture
 - new guidefile
 - better immediate handling
 - modular interface native functions
 - X=D button
 - header questions enable/disable
 - carry emulation now better
 - 'not' fixed
 - better low-level register handling

@{b}@{fg shine}ADDED IN PROMO 1.5:@{ub}@{fg text}

 - Bug Fixes and optimizations:
  - exg defaulted to .W FIXED
  - move.l   d0,(a1) caused problems
  - rol      #imm,<D> now faster and FIXED
  - mulu/muls/divu/divs FIXED (big bug!)
  - mathematical model caused trash or unnecessary instructions
  - equr/equrl/reg/fequr now set to promo status. Disabled! The final
    version will have full support for them. They were already 
    disabled but they didn't give an ERROR message as they do now!
  - (sp) usage caused trouble sometimes
  - moveq fixed (no more .w usage)
  - asr.l    #imm,<D>
  - shifting is now much faster and works(!) much better
  - moveq    #0,<D>  now set to clear status
  - simple range checking enabled so that immediate values now
   default to quick format if low enough. This is not yet as 
   complicated as in the final version though! Simple means that 
   it detects binary/octal/hex/decimal NUMBERS ONLY. No sums, that
   is....
  - moveq now has detection for zeroes
  - PPC immediate value support for shifting/rotating added
  - more??? Probably! (rlwimi's, exts's etc. removed or changed to a
    working version!)

 - History link added to guide
 - New Important Notes and Information added to guide

@{b}@{fg shine}ADDED IN PROMO 1.4:@{ub}@{fg text}

 - lea/pea/jsr/jmp <label>.w produced trash
 - interleaving went active after a few lines when it was disabled
 - new extremely useful PPCDIRECT command added:

 The smove command is an extremely handy substitute for all normal
 load/store commands of the PPC. It works as follows:

  smove.size     (<label>,reg1),reg2
  smove.size     (reg1,reg2),reg3
  smove.size     reg1,(<label>,reg2)
  smove.size     reg1,(reg2,reg3)

 A plus behind the brackets means update enabled. Example:

  smove.l        (label,d3)+,a4

 means <ea> is label+d3. This is loaded in a4. d3 is updated and
 keeps the <ea> used for this mode which is label+d3.

 This command is directly translated to one single PPC instruction

@{b}@{fg shine}ADDED IN PROMO 1.3:@{ub}@{fg text}

 - There were terrible bugs in 'Full' addressing modes. Changing a 
   slight part of the source code caused everything to change in a 
   direction with bad side-effects. This is now fixed.
 - Double extension bug fixed
 - Many little bugs and logical parts fixed
 - Missing dot for subroutines added: This caused a bug that 
   destroyed subroutine emulation
 - 'head' and 'tail' command added. This makes the promised 
   'autoheader' questions obsolete as the 'head' instruction makes
   an PPC680x0 Start Header and the 'tail' instructions an PPC680x0
   End Header. Can be used only once!!! (Although using it twice 
   won't give any errors!!!)
 - PPC680x0 source code succesfully converted to PPC using this 
   software!
 - Changes in guide-file: Missing section, Prologue, Copyright and
   Ordering.

@{b}@{fg shine}ADDED IN PROMO 1.2:@{ub}@{fg text}

 - Macro support for non-68k-command macro's
 - New address-loading mechanism (USE Full/QB button for old one
   where QB falls to the old mode. Experience needed!)
 - Help button calls guidefile when available in directory
   where PPC680x0: is assigned to
 - Power StormASM Predefined Symbols added
 - =/== added
 - Block comments added
 - Floating Joint natives added. No effect though!!!
@endnode

@node "WhatIs" "WhatIsPPC680x0"
@{b}@{i}@{fg shine}WHAT IS PPC680x0???@{ub}@{ui}@{fg text}

(If you just want to start, refer to the @{"quick guide" link "Quick" 0})

PPC680x0 is a source-level converting utility (which means you can convert
your old 680x0 source codes straight to PowerPC source-codes) and a highly
powerful 680x0-based programming  language. 

There's a lot of programmers who don't seem to be happy with the programming
architecture of the Motorola/IBM PowerPC family. Although the PPC is an
extremely powerful piece of silicon, it suffers a bit from its
not-exactly-user-friendly design.

Although many people (and even universities) seem to deny it, machine
language is the only way to make programs run at maximum speed. Just take a
look at the demo-scene, where coders push the most advanced effects through
a 'theoretically slow' 68k CPU.

PPC680x0 is a program that should help out coders in a easy but (when used
in the right way) extremely powerful way. You can actually treat the PowerPC
CPU as a very big 68060.

Try to imagine yourself an 68060 with over 27 general purpose registers
(which means it doesn't matter if you use one as an  address or data
register), many extra instructions, more addressing modes, Quad-word
operations, etc. etc... It is now possible, thanks to PPC680x0...

You can now also convert old 68k codes to PowerPC: Little  manipulations are
needed for the old code to convert it and the output code is highly
optimized and takes care of pipelining and multiple instruction executed
simultaneously.

Not only the 68K codes are converted, but also 68K library- calls and kernel
usage.

PPC680x0 outputs 100% @{b}@{fg shine}Storm PowerAsm@{ub}@{fg text} compatible code.
@endnode

@node "WorkExt" "External Workings"
@{b}@{i}@{fg shine}HOW DOES IT WORK???@{ub}

@{b}@{fg text}(GENERAL)@{ub}@{ui}

Before we start with the inside details, lets first tell you how the
interface and the general environment works:

PPC680x0 is a 'Pass 0' assembler, which means that it does not detect or
display all the reported bugs. When you will assemble the output file using
an assembler it may give some other bugs concerning an area that is
incorrect. This should always be a mistake in the input 68k source-code that
caused PPC680x0 to convert it in the wrong way.

How does it work: You write your source-code in any editor (or in an 680x0
assembler if you are not using any extensions), which means you have the
following, for example:


;Source code for predictable change volume ;By Ernie & Bert in 1999

 x
        movem.l  d0-d3/d14/d16,table
        move.l   a0,d0
        move.l   a1,d1
        clr.l    d3
        smovex.w (2,d0)+,d2
        asl.l    #16,d2
        divs.l   d14,d2
        asr.l    #16,d2
        addx.l   d3,d2
        smove.w  d2,(2,d1)+
        add.l    d2,d14
        add.l    d14,d16
        bmi.s    quit
        clr.l    notneeded
 quit   movem.l  table,d0-d3/d14/d16
        lastrts 

 table  ds.l    18
 notneeded
        dc.l    0


Now you have a source code which uses special PPC680x0 extensions. Of course
it could also be any source code without those! You want to convert this
source code to a PPC source code. So what do you do? You load up PPC680x0,
select the things you prefer and the optimizations. Select this as a source
file, select  a destination file and finally press the @{"convert" link "UsageGen" 200} button. You
get some questions, and after giving the answers to them you can load your
destination file in a PowerPC assembler and run it (or look at it in any
editor!)... Of course you should make sure that you only call PPC based
kernel routines such as WarpUp/PowerUp. You  can use 'call' for this, which
is automatically converted to the right instruction...

It is as simple as that. Just try it out! If there's something you don't
seem to understand you can use the @{"quick guide" link "Quick" 0} or simply  read the entire
manual...
@endnode

@node "WorkInt" "Internal Workings"
@{b}@{i}@{fg shine}HOW DOES IT WORK???@{ub}@{ui}@{fg text}

@{i}(INSIDE DETAILS)@{ui}

The inside activities of PPC680x0 are much more difficult to understand,
though! Lets try to give you an idea of how it works:

PPC680x0 works with a mathematical model of an 68k CPU.  The 68k is split up
in parts, where some of them built a formula on a complex plane (which could
be called the graph of a 'complex' formula, based on the square-roots of
-1).

For example, we could take the pixels on a monitor as some points of a
complex plane. Every region of the monitor corresponds with a region of the
68k CPU (which can be any different mode). We could say that in the entire
complex plane, all possible addressing modes are placed changing slightly
when moving from point to point. (For example: When moving a relatively
small end from the point corresponding with the addressing-mode d0,d4 and in
the right direction, you get d0,d5). This interpretation method is possible
because the 68k CPU is built in a very flexible way.

Perhaps you are wondering why we took so much time in creating a
mathematical model of the chip. Well, its quite easy to guess why if you
take a look in terms of performance. The earliest versions of PPC680x0 were
based on simple straight conversions. As a result, in couldn't predict every
combination possible, meaning that so called trash was generated. For
example, the following mode:

        move.l  (worst.b,d2.l),d1

could be converted to something like

        addi    r28,worst
        add     r28,r28,r5     (where r3 corresponds with d0)
        lwz     r4,0(r28)

Now it seems logical that a program detects everything, but with linear
programming you cannot make sure this is done right unless you put a special
routine in your code that helps. PPC680x0's mathematical model takes samples
of the code, analyses the samples and finally converts it to the PPC model.
The output code will be

        lwz     r4,worst(r5)

which is the most efficient way. Besides, linear code is not as flexible as
analysing code. PPC680x0 allows the following:

move.l ([worst.q,d0*16,d4.l*2],help.b,table.w,d14.b*32,a2),(a0)+

As a matter of fact, sampling goes in an infinite way, which means indirect
addressing modes can be seen as:

        a0([b1,b2,b3,b4,b5,...],a1,a2,a3,a4,a5,...)

which means

        load    b1+b1+b2+b3+... in IOREGISTER
        load    IOREGISTER+a0+a1+a2+a3+a4+... in IOREGISTER

(and where a/b are registers.size*multi or label.size)

Every part of the 68k CPU is treated this way to optimize output-codes.


@{i}@{fg shine}Explanation of some terms concerning PPC680x0:@{ui}@{fg text}

 INTEGRATING     - sampling of the source-code
 TRANSFORMING    - changing the samples to a standard form
 DIFFERENTIATING - converting the transformed samples to the
                   output source-code
 LAYERS          - the layers in which the 68k is split up
 BLOCKS          - a block of 100 lines of code for analysing
 LINE            - 1/100th of a block, one line of the input 
                   source-code
 L. AREA         - Label area (starting at first char of line)
 I. AREA         - Instruction area (starting after L. AREA)
 BWL AREA        - area that holds size (.b/.w/.l/.q/.s/.d/.x)
 T. AREA         - Type area (starting after BWL area)
 C. AREA         - Comment area (starts with ';', '*', etc.)
@endnode

@node "Usage Index" "UsageIndex"
@{b}@{i}@{fg shine}PPC680x0 - THE USAGE@{ub}@{ui}@{fg text}
 
 For info on what's missing in this version, please refer to 
 the @{"Missing Options" link "Missing" 0}!

 If you 'just want to convert a file' please refer to the @{"quick" link "Quick" 0} @{" guide" link "Quick" 0}!

  @{"Requirements" link "UsageGen" 0}
  @{"General Usage" link "UsageGen" 10}
  @{"CLI Usage" link "CLI" 0}
  @{"Buttons" link "UsageGen" 41}
   @{"Button 1  - Two arrows" link "UsageGen" 46}
   @{"Button 2  - r1" link "UsageGen" 66}
   @{"Button 3  - a7=sp" link "UsageGen" 79}
   @{"Button 4  - Wup" link "UsageGen" 101}
   @{"Button 5  - Gpr" link "UsageGen" 106}
   @{"Button 6  - ?ERR" link "UsageGen" 114}
   @{"Button 7  - Proc Dir" link "UsageGen" 120}
   @{"Button 8  - 32" link "UsageGen" 144}
   @{"Button 9  - 00 0" link "UsageGen" 151}
   @{"Button 10 - Rest Off" link "UsageGen" 159}
   @{"Button 11 - Stat Off" link "UsageGen" 163}
   @{"Button 12 - Frc" link "UsageGen" 168}
   @{"Button 13 - Asl In" link "UsageGen" 177}
   @{"Button 14 - Asl Out" link "UsageGen" 182}
   @{"Button 15 - Big 'M'" link "UsageGen" 187}
   @{"Button 16 - Full" link "UsageGen" 213}
   @{"Button 17 - X=D" link "UsageGen" 234}
   @{"Button 18 - Head" link "UsageGen" 241}
   Button 19 - Learn First (LF)
   Button 20 - Learn Next (LN)
  @{"Display Information" link "UsageGen" 248}
  @{"Error Messages" link "UsageGen" 277}
@endnode

@node "CLI" "CLI Usage"
 @{b}@{i}@{fg shine}CLI-USAGE@{ub}@{ui}@{fg text}
 ---------

The CLI interface of PPC680x0 always has the same default options as the
PPC680x0 GUI. If you want to change any options you should give optional
inputs.

@{i}@{fg shine}ppc68k <inputfile> <outputfile> <options> <learn>@{ui}@{fg text}

@{i}@{fg shine}<input>@{ui}@{fg text} and @{i}@{fg shine}<output>@{ui}@{fg text} are vital: These should contain the filenames of the
file to be converted and the  file to convert from

The @{i}@{fg shine}<options>@{ui}@{fg text} field can have the following:

@{b}@{fg shine} IOFF@{ub}@{fg text}
 ----

Interleaving Disable

@{b}@{fg shine} R27@{ub}@{fg text}
 ---

Use r27 as stack pointer

@{b}@{fg shine} A7@{ub}@{fg text}
 --

A7 is not equal to SP usage. See guidefile for more information

 @{b}@{fg shine}SA7=<SIZE>@{ub}@{fg text}
 ----------

String for the user-r27-stacksize in longwords (if  active), defaults to
10000 longwords

 @{b}@{fg shine}PUP@{ub}@{fg text}
 ---

Enable PowerUp instead of WarpUp

@{b}@{fg shine} FPR@{ub}@{fg text}
 ---

Display FPRs in results display

@{b}@{fg shine} ERR@{ub}@{fg text}
 ---

Display 'UNKNOWNERRORS'

@{b}@{fg shine} DIR@{ub}@{fg text}
 ---

Process directory to directory

@{b}@{fg shine} 64@{ub}@{fg text}
 --

Enable 64-bits implementation-mode

@{b}@{fg shine} CA@{ub}@{fg text}
 --

Carry emulation on

@{b}@{fg shine} REST@{ub}@{fg text}
 ----

Rest emulation on

@{b}@{fg shine} STAT@{ub}@{fg text}
 ----

Status Register emulation on

@{b}@{fg shine} FRC@{ub}@{fg text}
 ---

Force 32-bits address-bus@{b}@{fg shine}

 QB@{ub}@{fg text}
 --

'Quick-Bad' Loading

@{b}@{fg shine} NOXD@{ub}@{fg text}
 ----

No FPU .X=.D

@{b}@{fg shine} OW@{ub}@{fg text}
 --

Force overwrite existing file

@{b}@{fg shine} ND@{ub}@{fg text}
 --

No delay after conversion or errors


@{i}@{fg shine} <learn>@{ui}@{fg text} is always the last input:


@{b}@{fg shine} LEARN <files>@{ub}@{fg text}
 -------------

Learn macro's, equr's, equrl's, fequr's and reg directives from other files
than the main one.
@endnode

@node "UsageGen" "Usage"
@{b}@{i}@{fg shine}Requirements:@{ub}@{ui}@{fg text}

 - An @{"Amiga" link "AMIGA" 0}
 - At least 430kb of Fast memory
 - The Fonts: drawer installed
 - Kickstart 2.04+ (Including libraries etc.)
 - MagicWB


@{b}@{i}@{fg shine}General Usage:@{ub}@{ui}@{fg text}

Perhaps we should start with the programming environments, but as there's
quite a lot of users who want to use this as a conversion utility, we have
placed a special @{"Programming Environment" link "UsagePG" 0} section in this guide.

So, you can install the font by simply double-clicking on the 'Install Font'
icon or by copying the fonts into your Fonts: drawer. After you have copied
the fonts, you can either double click on the PPC68k icon to start the
program or drag the icon to a place on your harddisk where you would like to
have it.

It is required to copy the 's/fprom.s' to your s: drawer if you want to make
use of the user-configurable constant ROM file or the 'movecr' command

@{fg shine}Make sure you have PPC680x0: assigned to the drawer where you've put it.@{fg text}

After you have double-clicked on the icon, you get a window with some
buttons, a picture and a scrolltext

Pressing any button will cause the picture to change into an information
display.

PPC680x0 is a 'Pass 0' assembler, which means that it does not detect or
display all the reported bugs. When you will assemble the output file using
an assembler it may give some other bugs concerning an area that is
incorrect. This should always be a mistake in the input 68k source-code that
caused PPC680x0 to  convert it in the wrong way. So bugs in a piece of code
can be spotted by PPC680x0 OR the assembler used after the conversion
phase.

@{b}@{i}@{fg shine} Buttons@{ub}@{ui}@{fg text}

There's 18 buttons on top-left of the window and a few more outside of that
cluster. The buttons mean the following:

@{fg shine}Button 1 - The two arrows@{fg text}

The two arrows select if you want interleaving enabled. Interleaving means
that the original 68k source code is inserted throughout the output-file.
With interleaving disabled (arrows point in opposite direction, you get
something like:

 x
         move.l  (d13),d1
         add.l   d1,d2

With interleaving enabled (default), the code is converted to:

 ;x
 x
 ;       move.l  (d13),d1
         lwz     r4,0(r10)
 ;       add.l   d1,d2
         addco.  r5,r5,r4

@{fg shine}Button 2 - r1@{fg text}

With this button you can select the stackpointer. Pressing this  button will
make it change to r27, which equals a7. You should use this button if you
don't want to use the userstack which is given to you by PowerUp/WarpUp. The
user-stackpointer for this userstack is normally r1. Using a7 as stack
pointer means that stack emulation sohuld work with any kernel.

When you select r27 as a stack pointer, PPC680x0 automatically adds a space
in the end header of the output file. This space is the size of the
stackpointer in longwords as selected in the string-gadget named 'stacksize
a7'.

@{fg shine}Button 3 - a7 sp@{fg text}

This button is used in combination with button 2. 'a7=sp' means that using
'sp' in your code is treated the same as using 'a7'.

Why should you use this? Well, it's all quite logical: Because of the
advanced register model of PPC680x0, it could be possible that you want to
use a7 as a general purpose register instead of a stackpointer.

For example, using:

        move.l  (a7),d0

can have different effects. The command 'move.l  (a7),d0' means that you
want to copy the indirect value of a7 into d0 with a longword size. In
original 680x0 code, a7 is always used as the stackpointer, meaning that the
instruction is entirely the same as 'move.l  (sp),d0'. Disabling the 'a7=sp'
button means that you can use a7 and sp as two different registers. Of
course this button has no effect if button 2 is set to 'r27', which means
that 'sp' is always decoded to r27. When converting original 680x0 code,
this button should always be set to 'a7=sp'. Default is Off.

@{fg shine}Button 4 - Wup@{fg text}

Select goodies for WarpUp (Wup) or PowerUp (Pup). Take a look in the Missing
Options section to find out for how far this has been developed...

@{fg shine}Button 5 - Gpr@{fg text}

Display the General Purpose Registers or Floating Point Registers in the
information window.  There's a part in the information window called '680x0
register usage'. This button switches between displaying the amount of GPR's
used and the amount of FPR's used. Registers are always 68k sided, which
means that 0 means d0 etc.

@{fg shine}Button 6 - ?ERR@{fg text}

When enabled (not masked out) all totally unknown errors (which are usually
trash) are copied as ERRORUNKNOWN. When disabled (selected) these errors are
ignored.@{fg shine}

Button 7 - Proc Dir@{fg text}

Process Directory. Pushing this button will start the process directory
procedure, allowing the user to convert an entire directory. Please note
that the input dir should not have binary files as they will be treated as
source-codes, resulting in null-files or a trash-error.

So, how does it work? When pressing the button, you get an asl-requester
where you should select the input directory. After selecting the input
directory, you get a requester asking for the output directory (which should
of course not be the same as the input directory). When you have selected
the right directories, you are asked the following (with 'head' enabled):

@{i} 'Should I Add Headers To All Files?'@{ui}

Selecting 'Yes' means that every file in the directory gets a stack-pointer
(when enabled) and a startup-code from PPC680x0. This should only be used if
every source-code is an individual program, meaning that you can assemble
every file individually.

Normally, you should select 'No', meaning that no file gets a header. You
should convert the file that needs a header afterwards, using the normal
'convert' button.

@{fg shine}Button 8 - 32@{fg text}

Selects if your output code should be PowerPC 32-bits implementation or
64-bits implementation compatible. If you don't know in what mode your PPC
is running you should check the WarpUp/PowerUp manual. Normally this is
32-bits and therefore the button defaults to that.

@{fg shine}Button 9 - 00 0@{fg text}

Carry Emulation On/Off. When set to '00 1', carry emulation is enabled.
Carrying goes in quite a different way on the PowerPC, as there's no carry
in the Status Register anymore but in a special register called the XER.
Selecting carry emulation means that almost all instructions change the
carry in the way they should change it on an 680x0 CPU.

@{fg shine}Button 10 - Rest Off@{fg text}

Rest emulation for divisions enable/disable.

@{fg shine}Button 11 - Stat Off@{fg text}

Status Register/Condition Code/Lowlevel Emulation. Take a look in the
Missing Options to find out for how far this has been developed.

@{fg shine}Button 12 - Frc@{fg text}

Now this is quite a useful button! When selected (default), all  address
accesses are forced to 32-bits when working in 64-bits implementations. This
is useful if your PPC does not support more than a 32-bits address-bus.
Effective Address calculation then automatically zeroes the upper 32-bits of
the address. This button has no effect if Button 8 is set to 32-bits
implementations.

@{fg shine}Button 13 - Asl In@{fg text}

This is the disk-button on left of the input selection string. Pressing this
button pops up an ASL requester to select the source file.

@{fg shine}Button 14 - Asl Out@{fg text}

This is the disk-button on left of the output selection string. Pressing
this button pops up an ASL requester to select the destination file.

@{fg shine}Button 15 - Big 'M'@{fg text}

Press this button to start converting the files selected using buttons 13
and 14. When pressing this button you get a requester prompting (when 'head'
is on):

@{i} 'Should I Make A Start Header?'@{ui}

Selecting 'Yes' means that there will be a header on top of the file
allowing the PPC assembler to start this file. The return address is taken
from the link register and placed in the count register.  You should only
select 'Yes' if this is the file that will be assembled and runned in the
assembler. You should select 'No' for everything else such as includes etc.

After selecting this, PPC680x0 will start converting. When it's ready, you
get a requester (when 'head' is on):

@{i} 'Should I Make An End Header?'@{ui}

You should select 'Yes' if you want PPC680x0's internal data to be placed on
bottom of this output file. It is recommended to put this on bottom of the
startup/close file or in the data includes.

When you have selected this, your file is converted and can be loaded with
any editor...!

@{fg shine}Button 16 - Full@{fg text}

This button switches between perfect address loading and 'Quick Bad'
loading. Quick Bad loading should not be used if you don't know much about
the PPC. It adds all the 16-bit parts as signed  data in a following way:

 move HighWord,regA
 add  LowWord,regA

This causes an overflow, though, as $7fff as low-word is still a positive
add and $8000 a negative add. This means that when  the high word is $1234
and the low word $7fff you will get 

 $12347fff

but when the low word is $8000 you will get

 $12338000

which is clearly wrong.

@{fg shine}Button 17 - X=D@{fg text}

This button makes you select if you want to emulate Floating Point .X
extended precision values. When enabled (Default),  they will automatically
be converted to double precision. When disabled, .X usage results in
ERRORs.

@{fg shine}Button 18 - Head@{fg text}

This button makes you select if you want the header questions enabled when
pushing the convert or convert dir button. This was on request by many
people who wanted the header questions removed as option.


@{b}@{i}@{fg shine}DISPLAY INFORMATION@{ub}@{ui}@{fg text}

The display information means the following:

 'errors' counts the amount of errors occured

 'predec' counts the amount of pre-decrements used
 'pstinc' counts the amount of post-increments used
 'integr' counts the amount of integrate-modes used
 'immval' counts the amount of immediate values used
 'direct' counts the amount of direct registers used

 'normal' counts the amount of normal instructions used
 'single' counts the amount of single instructions used
 'genera' counts the amount of general instructions used
 'specia' counts the amount of special instructions used
 'psuper' counts the amount of super instructions used
 'implie' counts the amount of implied instructions used
 'branch' counts the amount of branching instructions used
 'extend' counts the amount of extend instructions used

 'lineno' displays the line being processed. (every 128)

  The 680x0 register usage counts all the registers that are used during the
code. 0 equals d0 (=r3) and 17-24 equals a0-a7  (=r20-r27). SP means stack
pointer, FP means FPU register usage. Button 5 selects if this part displays
the GPR's or FPR's used in the code.


@{b}@{i}@{fg shine}ERROR MESSAGES@{ub}@{ui}@{fg text}

At this moment, PPC680x0 has 30 error messages. Here's a quick guide through
them:

@{fg shine}GENERAL ERRORS@{fg text}

 * ERROROVERFLOW

 Although theoretically impossible, this error detects a buffer
 overflow. PPC680x0 allocates 256kb for 100 lines of decoding which
 is impossible to achieve, except if all 100 lines use 2*32 indices
 etc.. This error is always on bottom of the file.

 * ERRORUNKNOWN

 This is an error that is usually caused by trash in the
 instruction area. For example:

 mofe.l  (a0),d0

 causes this error to pop up. It might also be any other undetected
 error...

@{fg shine}OTHER ERRORS (ALL USER ERRORS!)@{fg text}

 * ERROR1

 This means that there a problem in the BWL area of the
 instruction. This can be caused by things as 'move.k' or 'move.'.
 Should always be a user error.

 * ERROR2

 Instruction not really implied.
 You have placed a non-implied instruction in an implied way.
 For example:

  divu.l

 causes this error to come, as there should be some input for the
 command. 'divu' is not an implied instruction.

 * ERROR3

 Instruction not supported.
 The instruction you have used is not supported by the promo version 
 of PPC680x0.

 * ERROR4

 Unknown. Probably trash or forgotten comma.

 * ERROR5

 Bracket expected after label. PPC680x0 is scanning for a bracket
 but cannot find one...

 * ERROR6, ERROR7, ERROR8

 Error in element A, B or C respectively. This is an error caused
 by bugs in the elements of the integrator unit input. (See
 InsideDetails) Elements are placed in the following way:

   A([B1,B2,B3,B4,...],C1,C2,C3,C4,C5,...)

 * ERROR9

 64-bits in 32-bits mode. This error pops up when you are using
 64-bits instructions without 64-bits implementations (Button 8)
 enabled.

 * ERROR10

 Wrong lea mode. The lea (load effective address) mode you are
 using is wrong.

 * ERROR11

 Destination immediate. Come on...! A destination cannot be
 immediate!!! (i.e.  move.l  d0,#13)

 * ERROR12

 Super Group Unknown. The super instruction you are using is not
 known by PPC680x0.

 * ERROR13

 Super Command Bad. The super instruction you are using has
 register-only operation for the selected field.

 * ERROR14

 Super Command Bad. The super instruction you are using has
 label-only operation for the selected field.

 * ERROR15

 Super Command Bad. Both fields (label and register) are bad.

 * ERROR16

 Bad Super Command Nth element. The super command you are using has
 a bug in one of the higher elements.

 * ERROR17

 Dh:Dl expected. You have placed a ':' behind a register but no
 second register behind the ':'.

 * ERROR18

 Movem register bug. Something is wrong with your 'movem'
 instruction...

 * ERROR19

 (movem) '-' , '/' , ',' expected.

 * ERROR20

 Movem needs directfield and integration field.

 * ERROR21

 Floating point .s/.d/.x detected without FPU enabled
 (Only for promo, now comes with .x used and no .x 
 emulation enabled)

 * ERROR22

 Floating point .p not supported

 * ERROR23

 Floating point unit not found (PROMO-ONLY)

 * ERROR24

 Bad Register

 * ERROR25

 Floating point .x not enabled

 * ERROR26

 Floating Point Group BAD, report to author

 * ERROR27

 (Promo only) Not supported

 * ERROR28

 FPR Expected

 * ERROR29
 
 aN expected

 * ERROR30

 No WarpUp Mode

 * ERROR31

 equr/equrl/reg/fequr incorrect

 * ERROR32

 move16 addressing mode not supported

 *
@endnode

@node "UsagePG" "Programming Environments"
@{b}@{i}@{fg shine}PROGRAMMING ENVIRONMENTS & GUIDELINES@{ub}@{ui}@{fg text}


@{fg shine}Introduction@{fg text}

Because PPC680x0 uses a mathematical model of an 680x0 CPU, it is able to
detect almost every addressing mode for every command. Although there's a
few exceptions to this rule, it can be said that 'single' and 'double'
instructions always support all (addressing & operation) modes.

The commands of PPC680x0 are split in the following groups:

 normal
 single
 general
 special
 super
 implied
 branch
 extend
 
 Here's a small description of these modes:

 normal  - Commands that support the standard  'cmd    S,D'
           instruction form, where S and D stand for Source and
           Destination
 single  - Commands that support the standard  'cmd    D'
           instruction form, where D stands for Destination
 general - Commands that are general assembler instructions.
           These instructions are normally assembler directives
 special - Commands that have special treatment (bitfields etc.)
 super   - PPC680x0's own direct PPC instruction set
 implied - Commands that are implied (like rts, nop etc.)
 branch  - All Flow Control instructions (bcc, dbcc, jsr etc.)
 extend  - Extension instructions (ext, extb)

Normal and single modes use the pre-integrator unit to extract the
addressing modes. The main 'parts' of the integrator are  known as the
following:

 predec  - Pre-decrement mode. Internally known as i(+x)
 pstinc  - Post-increment mode. Internally known as -i(+x)
 integr  - Integrator mode. Internally known as 0+(x)
 immval  - Immediate value. Internally known as (-)2i(+x)
 direct  - Direct value. Internally known as absolute 0

The x-part of the formula is not important right now, but it might be on
later revisions if they will support displays of the complex plane etc.

Pre-decrementing is known as -(reg) and post-incrementing is known as
(reg)+. Integrating is known as every mode that uses labels and is not
immediate. So actually any kind of non-single-register memory access is
decoded in this mode. Immediate values quite speak for theirself, except
that PPC680x0 does not support immediate values that keep termination codes.
The following is NOT supported:

        move.l  #'AB,C',d0

So beware! Finally, direct modes are known as all modes that use direct
register access.

So..... Now we are not going to tell you how to program a 680x0 CPU! If you
have zero experience with the 68k, you should get some document files from
Aminet or check Motorola as they might have some books for you!


@{fg shine}PPC680x0 PROGRAMMING@{fg text}

What we ARE going to tell you are the differences between 680x0 and PPC680x0
machine language. We are of course also giving you  the super (directPPC)
instruction set and information on how to program the extensive 68k
language.

PPC680x0 has support for few Storm PowerAsm Pseudo Mnemonics which are
required to make a WarpUp code. These are ALL PUSH and  POP commands and the
'prolog' and 'epilog' commands.

We would like to notify you that the current Amiga-PPC cards are running in
32-bits mode. Your configuration should be set to  '32-bits' with 'FRC'
enabled (which is the default).

@{fg shine}Differences@{fg text}

 * PPC680x0 supports all addressing modes for normal & single
   instructions. (Few exceptions to the rule!)
 * PPC680x0 has an additional instruction set
 * PPC680x0 has true quadword support (you can use .Q now)
 * PPC680x0 supports unlimited indices
 * PPC680x0 supports 28 registers maximally
 * PPC680x0 supports scaling modes from *1 to *32
 * PPC680x0 can enable/disable native carry/sr/ccr support
 * PPC680x0 can use a7 as GPR
 * PPC680x0 is generally faster in .L/.Q access than .B/.W access
 * PPC680x0 supports all non-macro Storm PowerASM commands
   (except one that has been renamed!!!)
 * PPC680x0 supports quick values from 0-65535
 * PPC680x0 uses no extend bit. (all done via carry)
 * PPC680x0 supports ONLY the 68060 FPU (except for the 
   movecr instruction which IS emulated
 * PPC680x0 supports the rN suffix for direct PPC register
   usage

You can actually program PPC680x0 in the same way as a normal 68k CPU except
that optimizing rules have changed. 

When you have selected 64-bits implementations, it is possible to use .Q
operations with any command. Scaling and rotation in 64-bits is not
supported, though.

So... How do you program PPC680x0? Well, just act like you are using an
68060 Amiga with extra instructions. The 68060 registers are treated in the
following way:

  68k         PPC
  ---         ---
 d0-d24      r3-r27
 d25-d28     r28-r31  (Internal I/O registers. Don't use)
 a0-a7       r20-r27

Yes, you are right, a0-a7 are exactly the same as d17-d24. This means you
may use both the 'd' or 'a' suffix. Using the 'a'  suffix for addressing is
easier as it defaults to 32/64-bits.  Data registers always default to
16-bits if no size is given. This means that:

 move.l (a0),d0

Is the same mode as

 move.l (d17.l),d0

AND the same mode as

 move.l (r14.l),d0

and is executed in the same amount of time. Using:

 move.l (d17),d0

defaults to word access, meaning that you are loading a value  from a
16-bits address...!

PPC680x0 is very flexible. You can use as much indices (up to 32) as you
want, meaning that the following is legal:

  add.q   label1([label2.b,d0.l*32,d1],label3.w,label4.l),d23

A sum is created in the following way:

 label1+label3&$ffff+label4&$ffffffff=replacement
 load replacement in I/O
 I/O+label2&$ff+d0&$ffffffff<<5+d1&$ffff=replacement
 load replacement in d23

All the normal and single instructions support all addressing modes. You
should always keep in mind that the default modes are always the same as
with the 680x0 CPU. (no size = .w except for address registers and some
special modes)

The mathematical model has some side-effects, meaning that some commands
will default to the best mode. For example: When you are using 64-bits
implementations without 32-bits Force enabled, a lea without size will
default to .q as this is the most logical size.@{fg shine}

VERY IMPORTANT@{fg text}

PPC680x0's machine language does not return to the program that runs it when
using an 'rts'. You will even get a crash!!! You should use the 'lastrts'
command for the exiting 'rts'. This means that using 'rts' is strictly for
subroutines and 'lastrts' is to exit your code.

The Storm PowerASM command 'rs' is renamed to 'rs2' to keep compatibility
with the command 'rs' used in many 68k assemblers.

There's also new rules for quick access. Moveq, addq, subq now support
immediate values from -32768-32767.

The exceptions to the rule:

 - lea (b/w/l/q) is treated different. They only support the
   'normal' 680x0 addressing modes but have .q and integrator
   access added
 - bcd instructions ALWAYS default to byte access
 - pea (b/w/l/q) is treated different. They only support the
   'normal' 680x0 addressing modes but have .q and integrator
   access added
 - swapping is always .L
 - linking/unlinking is always .MAX (.L in 32bits/.Q in 64bits)
 - moveq is always .L
 - everything that does not default to .W in an 680x0 will not
   default to .W in PPC680x0 either!!!

@{fg shine}Working without carry emulation:@{fg text}

When carrying is not emulated, there's only a few commands with support for
carrying:

 roxr, roxl
 additions (with or without extend)
 substractions (with or without extend)

Other instructions only change the Positive, Negative, Zero and Overflow
bits in CR0 of the PPC status register.

The order of a PPC program would look like this:

(On WarpUP)

 1. prolog (*)
  2. head
  3.  (program)
 4. lastrts (**)

 5. tail

(On PowerUp)

 1. head
 2.  (program)
 3. lastrts

 4. tail

Make sure you do not use multiple heads and tails! Also make  sure you take
care of the lastrts instruction!@{fg back}

(*) IMPORTANT WarpUp Note: Don't forget to save registers that should be
returned at the end of the program. These can be found in the WarpUp
documentation. The 'popgpr' and 'pushgpr' directives can be used as with
'original' PowerAsm code. PPC680x0 uses r0 and r28-r31 as I/O registers.

(**) Of course the registers of (*) also must be loaded back!@{fg text}
@endnode

@node "InsIndex" "Instruction Index"
@{b}@{i}@{fg shine} INSTRUCTION SET INDEX@{ub}@{ui}@{fg text}
 ---------------------

  @{"Important General Information" link "InstructionSet" 0}

@{fg shine} CATEGORY 1 - PPC680x0 Instructions@{fg text}

  @{"68K/PPC Kernel Instructions" link "InsKernel" 0}
  @{"Compatibility Instructions" link "InsCompatibility" 0}
  @{"Control Instructions" link "InsControl" 0}
  @{"Vital Instructions" link "InsVital" 0}

@{fg shine} CATEGORY 2 - PPCDirect Instructions@{fg text}

  @{"Arithmetic Instructions" link "InsArithmetic" 0}
  @{"Data Transfer Instructions" link "InsDataTrans" 0}
  @{"Floating Point Instructions" link "InsFloat" 0}
  @{"Logic Instructions" link "InsLogic" 0}
  @{"Low Level Instructions" link "InsLowLevel" 0}
  @{"Rotate and Shift Instructions" link "InsShift" 0}
@endnode

@node "InstructionSet" "Instruction Set"
@{b}@{i}@{fg shine} PPCDirect Extended Instruction Set@{ub}@{ui}@{fg text}
 ----------------------------------

These parts describes all the PPCDirect Instructions of PPC680x0.

These instructions are only useful if you want to optimize your codes or if
you want to know a few extra handy instructions.  There's an @{"important" link "ImpCommand" 0}
@{"command section" link "ImpCommand" 0}  where important or extremely useful commands are
highlighted.

All super PPCDirect instructions are indicated with an 's' in front of the
instruction. Instruction may look tricky at first sight, but when you cover
up the first letter you will find out they look usually quite similar to 68k
instructions.

PPCDirect instructions always work in the bitmode chosen in  PPC680x0: This
means that if you have selected 64-bits  implementations all the registers
are treated as 64-bits, unless the description states something else.

For most commands (except a few where noted) you can select if you want the
Condition Register to be updated. It works in the same way as with PPC
machine-code by putting a dot at the end of the instruction. No dot means no
Condition Register update.

For example:

        sadd    d0,d1,d2

 will add register d0 to d1 and put the result in d2. The status
 register remains the same as it was before the instruction. 

        sadd.   d0,d1,d2

 does the same, except that the status register is updated.


Please remember that the PPC Condition Register has no carry flag! This is
done via a special register called XER. The CCR has bits for Positive,
Negative, Zero and Overflow. Overflowing by an instruction sets both the
overflow bit of the CCR and the XER.

These instructions (except the directive commands) should not be  used
together with CARRY emulation enabled if you don't have  little knowledge of
the PPC processor and architecture.


 SIMM  means Signed Immediate Value, which is always 16-bits
 UIMM  means Unsigned Immediate Value, which is always 16-bits
 rA,rB means any register
 rD    means any register (destination operand)
 M     means mask (see instruction for description)
@endnode

@node "InsArithmetic" "Arithmetic"
@{b}@{i}@{fg shine} Arithmetics Instructions@{ub}@{ui}@{fg text}
 ------------------------

 Simple description of the letters behind the names:

 s = shifted 16 bits to the left
 v = XER overflow enabled
 c = XER carry enabled
 m = minus one
 z = zero
 x = extended

@{fg shine} NAME    FORMAT         DESCRIPTION
 ----    ------         -----------@{fg text}

 sadd    rA,rB,rD     - place the sum rA+rB in rD

 sadd    #SIMM,rB,rD  - place the sum SIMM+rB in rD
         @{b}@{fg shine}               (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 sadds   #SIMM,rB,rD  - SIMM is a signed immediate value and is
                        shifted left 16 bits. The sum is 
                        (SIMM<<16)+rB and is placed in rD
                     @{b}@{fg shine}   (DOES NOT SUPPORT CONDITION UPDATE@{ub}@{fg text}

 saddv   rA,rB,rD     - place the sum rA+rB in rD with overflow
                        enabled

 ssub    rA,rB,rD     - place the sum rA-rB in rD

 ssubv   rA,rB,rD     - place the sum rA-rB in rD with overflow
                        enabled
 
 saddc   rA,rB,rD     - place the sum rA+rB in rD with carrying
                        enabled

 saddc   #SIMM,rB,rD  - place the sum SIMM+rB in rD with carrying
                        enabled

 ssubc   rA,rB,rD     - place the sum rA-rB in rD with carrying
                        enabled
 
 ssubc   #SIMM,rB,rD  - place the sum SIMM-rB in rD with carrying
                        enabled

 ssubcv  rA,rB,rD     - place the sum rA-rB in rD with carrying and
                        overflow enabled

 saddcv  rA,rB,rD     - place the sum rA+rB in rD with carrying and
                        overflow enabled

 saddx   rA,rB,rD     - place the sum rA+rB+CARRY(XER) in rD

 saddxv  rA,rB,rD     - place the sum rA+rB+CARRY(XER) in rD with
                        overflow enabled

 ssubx   rA,rB,rD     - place the sum rA-rB+CARRY(XER) in rD

 ssubxv  rA,rB,rD     - place the sum rA-rB+CARRY(XER) in rD with
                        overflow enabled

 saddm   rA,rD        - place the sum -1+rA+CARRY(XER) in rD

 saddmv  rA,rD        - place the sum -1+rA+CARRY(XER) in rD with 
                        overflow enabled

 ssubm   rA,rD        - place the sum -1-rA+CARRY(XER) in rD

 ssubmv  rA,rD        - place the sum -1-rA+CARRY(XER) in rD with 
                        overflow enabled

 saddz   rA,rD        - place the sum 0+rA+CARRY(XER) in rD

 saddzv  rA,rD        - place the sum 0+rA+CARRY(XER) in rD with 
                        overflow enabled

 ssubz   rA,rD        - place the sum 0-rA+CARRY(XER) in rD

 ssubzv  rA,rD        - place the sum 0-rA+CARRY(XER) in rD with 
                        overflow enabled
@endnode

@node "InsCompatibility" "Compatibility"
@{b}@{i}@{fg shine} Compatibility Instructions@{ub}@{ui}@{fg text}
 --------------------------

 regequ 
 fregequ 
 crfequ 
 crequ   - places register offsets
         for assemblers that do not support the letter
         suffix before registers: For example, regequ 
         converts to:

 r0      =       0
 r1      =       1
 r2      =       2
 r...    =       ...
 r31     =       31

       and crfequ converts to:

 crf0    =       0
 crf1    =       1
 crf2    =       2
 crf...  =       ...
 crf7    =       7
@endnode

@node "InsKernel" "Kernel"
@{b}@{i}@{fg shine} Kernal Instructions@{ub}@{ui}@{fg text}
 -------------------

 PowerPC Side (WarpUp And PowerUp)

call    - calls PPC WarpUp or PowerUp kernal routine

 PowerPC Side (WarpUp ONLY)

Make sure you have the Haage&Partner 'powerpc/' includes in your source-code
if you want to use the following functions!

warp    - places all WarpUp library routine offsets 
        (recommended to place this above the first source-
        code file of your program)

go68    - calls the Run68k routine from the WarpUp
        kernel. This requires the input PPStruct 
        structure to be configured in advance

wait68  - calls the Wait68k routine from the WarpUp
        kernel. All the routine inputs have to be
        configured by the user

go68s   - does the same as go68, but calculates the
        address in a relative way. Make sure the 
        PowerPC base is within 64k away of the program
        counter

wait68s - same story as go68s, but calls Wait68K

(Read the WarpUp routine and macro documentation for  the following:)

WAITFOR68K - calls the WAITFOR68K macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source-code

RUN68K -     calls the RUN68K macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source-code

RUN68K_XL -  calls the RUN68K_XL macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source-code

@{b}@{fg shine}CALLING 68K FUNCTIONS@{ub}@{fg text}

PPC680x0 detects 68K library calls and runs them when detected. When the
following occurs:

        jsr     offset(a6)

or any jsr that uses 'a6' as a pointer with offsets, PPC680x0 converts it to
code so that it can run as if it was called from a real 68K CPU.

Detection is standard ON, but it can be disabled and re-enabled during
conversion.

 libon  -     enable library-call-detection
 liboff -     disable library-call-detection

As an addition to this detection method, you can use CALLEXEC, CALLDOS,
CALLINT and CALLGRAF as in the HiSoft DevPac assembler. 

@{b}@{fg shine}IMPORTANT@{ub}@{fg text}: Make sure that the execbase is stored in  a location called
'_SysBase' (and for the other  libraries use: _GfxBase, _IntuitionBase,
_DOSBase as in DevPac)
@endnode

@node "InsControl" "Control"
@{b}@{i}@{fg shine} PPC680x0 Control Instructions@{ub}@{ui}@{fg text}
 -----------------------------

@{b}Use these 41 (2x20+1) commands to change options  while converting your
file:@{ub}

Note: @{fg shine}xxxxxx@{fg text} = default enabled

1- @{fg shine}domrg@{fg text} / nomrg

EnableMerging / DisableMerging (=Interleaving!)

2- r27sp / @{fg shine}r1sp@{fg text}

r27 is stack pointer / r1 is stack pointer

3- @{fg shine}a7issp@{fg text} / a7notsp

a7=sp / a7notequaltosp

4- dopup / @{fg shine}dowup@{fg text}

PowerUp/ WarpUp

5- @{fg shine}doerr@{fg text} / noerr

unknown error messages / no unknown errormessages

6- do64 / @{fg shine}do32@{fg text}

goto 64-bits mode / goto 32-bits mode

7- docarry / @{fg shine}nocarry@{fg text}

enable carry emulation / disable carry emulation

8- dorest / @{fg shine}norest@{fg text}

enable rest emulation / disable rest emulation

9- dostat / @{fg shine}nostat@{fg text}

enable sr emulation / disable sr emulation

10- @{fg shine}dofrc@{fg text} / nofrc

enable FRC32 / disable FRC32

11- doqb / @{fg shine}noqb@{fg text}

enable Quick Bad / disable Quick Bad

12-@{fg shine} doxd@{fg text} / noxd

enable FPU .X=.D / disable FPU .X=.D

13- @{fg shine}dosub@{fg text} / nosub

enable / disable the substraction command to emulate a 'cmp' instruction.
Default is on. Disabling will cause incompatibility with the blo/bhi
commands

14- killzero / @{fg shine}normzero@{fg text}

'killzero' is a command to optimize 'clr' instructions It actually remembers
if the 'clr' instruction has been used on non-direct modes and does not
produce an 'andi   r30,r30,0' instruction when it's not needed. The default
is off, though, as branching to just before  the commands not producing the
'andi', will cause codes to be bad. For example:

        clr.l   d0
        clr.l   label
        add.l   d0,d3
 jump
        mulu.l  d4,r4
        move.l  r29,r31
        clr.l   label23

will produce a 'andi r30,r30,0' for the 'clr.l  label' instruction. The
'clr.l label23' instruction will know that an 'andi' is no longer needed a
second time as r30  is already zero.  The bug comes when there is a 'jmp',
'bra' or 'bcc' to  the 'jump' label: r30 is no longer zero...!  So, the
default is 'normzero'...

15- codeppc / @{fg shine}code68k@{fg text}

You can now insert PowerPC native code sections throughout the source-code
or use this command for other trickery.  'code68k' is the default mode in
which PPC680x0 always usually works. When you use the 'codeppc' command,
PPC680x0 stops converting and enters copy-mode. This is handy if you want to
use sections containing non-supported commands or PPC native code. 'codeppc'
does NOT use any of the conversion options or features. The entire block is
copied until  terminated with the 'code68k' command. Normal conversion
follows after the command.

For example:

 x      move.l  d0,d1
        add.l   d1,d1
        add.l   d0,d1
        codeppc
        mflr    r0
        mtctr   r0
        isync
        code68k
        move.l  d1,(a0)+
        move.l  d0,label
        rts
 label  dc.l    0

will convert the first three lines as usual, then copy the lines in-between
the two 'codexxx' commands and finally convert the last three commands as it
used to do. Currently can be used to control AltiVec instructions as well,
although PPC680x0 will have an extensive AltiVec instruction set and support
in the near future.

16- adrabs / @{fg shine}adrrel@{fg text}

Commands to switch between absolute address-loading or relative
address-loading. PowerOpen/WarpUp only supports relative address-loading, so
this is the default.

17 -@{fg shine} powerbug@{fg text} / poweroff

Storm PowerAsm still has some bugs in it...! For example, the recommended
Motorola command 'addi(s)   rD,0,label' gives a crash in PowerAsm. PowerAsm
requires the 'r' suffix even though it is the value '0' being used here.
Therefore, the default  mode (powerbug) will produce code that will not
crash!

18 - warpreq

Places a header with required PowerAsm includes. Make sure you have set the
PPC include-path using the 'incdir' directive...!

The command translates to:

        xref    _PowerPCBase
        xref    _SysBase
 ;      xref    _DOSBase
        xref    _LinkerDB

        executable

So you can decide by yourself if you want to use the '_DOSBase' from an
'xref' (by removing the ';') or use it by opening the  library and store it
at an address.

19 - @{fg shine}dolvo @{fg text}/ nolvo

Commands to enable/disable the _LVO suffix for CALLEXEC and other DevPac
library call commands. Default is enabled...

20 - noalign / @{fg shine}doalign@{fg text}

Disable / enable auto-alignment. Default is enabled. Auto- alignment means
that PPC680x0 tries to find code-parts which are not placed on an address
dividable by 4. These are automatically set to an address dividable by 4
using the 'align.l' command.

21 - @{fg shine}onexec@{fg text} / offexec

Enables / disables exec-detection. When loading occurs from address $4,
PPC680x0 tries to detect that and replace it with a load from '_SysBase'.
But beware: Not everything can be detected. For example, the common form:

        movea.l  #$4,a0
        move.l   (a0),d0

will cause a big crash when you run it...! Make sure you have replaced the
first command with a 'lea     _SysBase,a0' before  assembling!
@endnode

@node "InsDataTrans" "DataTransfer"
@{b}@{i}@{fg shine} Data Transfer instructions@{ub}@{ui}@{fg text}
 --------------------------

 Data transfer instructions are very important. All the normal 
 load and store instructions of the PPC are implemented in just 
 two instructions. Sizes for smove are byte, word, long or quad 
 and single or double for the sfmove. Addressing modes and sizes 
 are the same as with an 680x0, and the following modes are 
 allowed:

 instruction.size:

 sfmove (.s/.d)
 smove  (.b/.w/.l/.q)

 addressing modes:

        (rA,rB),rD
        (<label>,rB),rD

        rA,(rC,rD)
        rA,(<label>,rD)

        (rA,rB)+,rD
        (<label>,rB)+,rD

        rA,(rC,rD)+
        rA,(<label>,rD)+

 <label> is always a 16-bits signed displacement, the + suffix 
 means that the effective address calculated between the brackets 
 is placed in the second register used. Registers are always 
 32-bits in 32-bits implementations and 64-bits in 64-bits 
 implementations, which means that all other bits beyond the
 size selected are set to zero. One exception to the rule:

 using smovex.w (and smovex.w ONLY) automatically extends the
 loaded word to 32-bits or 64-bits depending on the mode.

 For example:

  smove.w (data,d5)+,d4

 adds the 16-bits value 'data' to d5 and loads a word from
 memory which is placed in d4. d5 is set to d5+data. All the
 other bits in d4 are cleared.
@endnode

@node "InsFloat" "Float"
@{b}@{i}@{fg shine} Floating Point Instructions@{ub}@{ui}@{fg text}
 ---------------------------

 Little Note: an instruction with no explanation is the same 
 as the instruction above it, only with single precision instead
 of double.

 sfadd   fpA,fpB,fpD        - fpA + fpB = fpD
 sfadds  fpA,fpB,fpD        - same, but single precision

 sfsub   fpA,fpB,fpD        - fpB - fpA = fpD
 sfsubs

 sfmul   fpA,fpB,fpD        - fpA * fpB = fpD
 sfmuls

 sfdiv   fpA,fpB,fpD        - fpB / fpA = fpD
 sfdivs
 
 sfsqrt  fpA,fpD            - sqr(fpA)  = fpD
 sfsqrts

 sfres   fpA,fpD            - the single precision estimate
                              of the reciprocal from fpA is 
                              placed in fpD

 sfrsqrt fpA,fpD            - calculate the reciprocal of the
                              square-roots from fpA and place
                              it in fpD

 sfsel   fpA,fpB,fpC,fpD    - fpA is compared to 0. If fpA is
                              greater or equal to 0, fpD is set
                              to fpC. If fpA is less than zero
                              or a NaN, fpD is set to fpB. The
                              comparison is unsigned

 sfmadd  fpA,fpB,fpC,fpD    - fpA * fpC + fpB = fpD
 sfmadds

 sfmsub  fpA,fpB,fpC,fpD    - fpA * fpC - fpB = fpD
 sfmsubs

 sfnmadd fpA,fpB,fpC,fpD    - -(fpA * fpC + fpB) = fpD
 sfnmadds

 sfnmsub fpA,fpB,fpC,fpD    - -(fpA * fpC - fpB) = fpD
 sfnmsubs

 sfround fpA,fpD            - fpA is rounded to single
                              precision and placed in fpD

 sfconvf fpA,fpD            - convert the integer double
                              word in fpA to an double precision
                              FPU value and place it in fpD
                              (64-bits only)

 sfconvt fpA,fpD            - convert the double-precision FPU
                              value to an integer double word
                              (64-bits only) (fpA -> fpD)

 sfconvtz fpA,fpD           - convert fpA to integer double word
                              and place it in fpD, with round
                              towards zero (64-bits only)

 sfconvtw fpA,fpD           - convert fpA to an integer word and
                              place it in fpD

 sfconvtwz fpA,fpD          - convert fpA to an integer word with
                              round towards zero and place it in
                              fpD

 sfneg   fpA,fpD            - negate fpA and place it in fpD

 sfabs   fpA,fpD            - put the absolute value of fpA in 
                              fpD

 sfnabs  fpA,fpD            - put the negative absolute value of
                              fpA into fpD
@endnode

@node "InsLogic" "Logic"
@{b}@{i}@{fg shine} Logical Instructions@{ub}@{ui}@{fg text}
 --------------------

@{fg shine} Small description of letters behind names:

 v   = overflow
 l   = longword operation
 q   = quadword operation
 s   = shifted 16 bits to the left
 i   = immediate
 <<n = shifted left n times@{fg text}

 sneg    rA,rD        - negate rA in rD

 snegv   rA,rD        - negate rA in rD with overflow enabled

 scmp.l  rA,rD        - compare rA/SIMM with rD treating operands
         #SIMM,rD       as signed 32-bits integers
                     @{b}@{fg shine}   (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 scmpl.l rA,rD        - compare rA/UIMM with rD treating operands
         #UIMM,rD       as unsigned 32-bits integers
                     @{b}@{fg shine}   (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 scmp.q  rA,rD        - compare rA/SIMM with rD treating operands
         #SIMM,rD       as signed 64-bits integers
                      @{b}@{fg shine}  (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 scmpl.q rA,rD        - compare rA/UIMM with rD treating operands
         #SIMM,rD       as unsigned 64-bits integers
                      @{b}@{fg shine}  (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 sandi   #UIMM,rB,rD  - UIMM AND rB, place result in rD. All other
                        bits than UIMM are set to zero
                     @{b}@{fg shine}   (ALWAYS SUPPORTS CONDITION UPDATE)@{ub}@{fg text}

 sandis  #UIMM,rB,rD  - UIMM<<16 AND rB. place result in rD. All
                        other bits than UIMM are set to zero
                   @{b}@{fg shine}     (ALWAYS SUPPORTS CONDITION UPDATE)@{ub}@{fg text}

 sori    #UIMM,rB,rD  - UIMM OR rB, place result in rD
                    @{b}@{fg shine}    (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 soris   #UIMM,rB,rD  - UIMM<<16 OR rB, place result in rD
                       @{b}@{fg shine} (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 seori   #UIMM,rB,rD  - UIMM EOR rB, place result in rD
                     @{b}@{fg shine}   (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 seoris  #UIMM,rB,rD  - UIMM<<16 EOR rB, place result in rD
                     @{b}@{fg shine}   (DOES NOT SUPPORT CONDITION UPDATE)@{ub}@{fg text}

 sand    rA,rB,rD     - rA AND rB, place result in rD

 sor     rA,rB,rD     - rA OR rB, place result in rD

 seor    rA,rB,rD     - rA EOR rB, place result in rD

 snand   rA,rB,rD     - rA NAND rB, place result in rD

 snor    rA,rB,rD     - rA NOR rB, place result in rD

 seqv    rA,rB,rD     - rA EOR rB, then complement and place result
                        in rD

 sandc   rA,rB,rD     - Logical AND rA with the one's complement of
                        rB and place result in rD

 sorc    rA,rB,rD     - Logical OR rA with the one's complement of
                        rB and place result in rD

 scountl rA,rD        - count the amount of leading zero's in
                        longword rA and place that amount in rD

 scountq rA,rD        - count the amount of leading zero's in 
                        quadword rA and place that amount in rD
@endnode

@node "InsLowLevel" "LowLevel"
@{b}@{i}@{fg shine} Low Level Instructions@{ub}@{ui}@{fg text}
 ----------------------

 Please hang on! These are under development!
@endnode

@node "InsShift" "Shift And Rotate"
@{b}@{i}@{fg shine} Shift & Rotate Instructions@{ub}@{ui}@{fg text}
 ---------------------------

@{fg shine} Small description of letters behind names:

 l = longword operation
 q = quadword operation

 Note about mask generation: On PPC, the leftmost bit is called bit
 0 and the rightmost bit 63 or 31 depending on QUAD or LONG
 operation. This means that the most significant bit is always bit0@{fg text}

 srolcl  rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the 
         #SIMM,rB,rD,M        result with the generated mask and
                              place it in rD. The mask is generated
                              having 1 bits from M to bit 31 and 
                              0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolcr  rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the
         #SIMM,rB,rD,M        result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from bit 0 to M and 
                              0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolc   rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the
         #SIMM,rB,rD,M        result with the generated mask and
                              place it in rD. The mask is generated
                              having 1 bits from M to bit 63-SIMM 
                              and 0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolal  #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times, AND the
                              result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from M1 to M2 and 0
                              bits elsewhere (longword)

 srolmil #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (longword)

  Example:    srolmil #4,d1,d2,28,31

  rotate register d1 4 times. The mask is set from bit 28 to bit
  31, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.

 slsll   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (longword)

 slsrl   rA,rB,rD           - shift right rB by rA times and place
                              the result in rD (longword)

 sasll   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (longword)
 
 sasrl   rA,rB,rD           - shift right rB by rA times with
                              arithmetical sign extension and place
                              the result in rD (longword)

 srolmiq #SIMM,rB,rD,M1,M2  - rotate left rB by SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (quadword/NOT WORKING ON PPC603/604)

  Example:    srolmiq #4,d1,d2,60,63

  rotate register d1 4 times. The mask is set from bit 60 to bit
  63, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.


 slslq   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (quadword)

 slsrq   rA,rB,rD           - shift right rB by rA times and place
                              the result in rD (quadword)

 saslq   rA,rB,rD           - shift left rB by rA times and place 
                              the result in rD (quadword)

 sasrq   rA,rB,rD           - shift right rB by rA times with
                              arithmetical sign extension and place
                              the result in rD (quadword)
@endnode

@node "InsVital" "Vital"
@{b}@{i}@{fg shine} Vital Instructions@{ub}@{ui}@{fg text}
 ------------------

 lastrts - quits source code. should ALWAYS be the last 
           instruction your code executes. 
           The instruction is decoded to the PPC code:

           (On PowerUp)

                   mfctr  0
                   mtlr   0
                   blr

           (On WarpUp)

                   mfctr  0
                   mtlr   0
                   epilog

           Note: On WarpUp, code often ends with the RUN68K 
                 command

 head    - makes a header, a header is used on top of the code 
           you wish to run. They set the stackpointer (if needed)
           and save return addresses from the link to the count 
           register. Headers are automatically made when you 
           select 'yes' for making a start header
           The header also contains the RUN680X0 MACRO which is
           required for 68K library calls.

 tail    - makes a tail, tails contain the used data of PPC680x0.
           One MUST exist if you want to be able to assemble
           your code. Tails contain the stack (when selected), 
           FPU I/O dataspaces and other data. Tails are made
           automatically when selecting 'yes' for making an end
           header (=tail)

 setlr   - revives the Link Register from the Count Register.
           The 'head' commands does the vice-versa process.
@endnode

@node "Quick" "Quick Guide"
@{b}@{i}@{fg shine}PPC680x0 QUICK GUIDE@{ub}@{ui}@{fg text}

Wanna have a quick start? Good... Here we go then. Go to Workbench and copy
the PPC680x0:Fonts/ directory into the SYS:Fonts/ directory or simply
double-click the 'install font' icon. Then copy the s/fprom.s file to the s:
directory of your boot-partition. You can now double the 'PPC68k' icon from
anywhere. 

After double-clicking the PPC68k icon, you get a window with some buttons,
strings, a scroller and a picture. 

Pressing any button will remove the picture and display all the information
on the place of the picture.

The buttons mean the following:

Button 1 - two arrows: This means interleaving on/off. Interleaving means
that the original 68k source-code file is placed throughout the file as
comments. Default is on.

Button 2 - r# 1      : This button selects the stackpointer register.
Default is r1 (the official stackpointer) but you can change it to r27 (=a7)
to create a user-stackpointer with the size (in longwords) as selected in
the 'stacksize a7' string. This will  put a user-stack on bottom of the
output source-code. (ds.l size)

Button 3 - a7 sp     : This means that (a7) is treated exactly the same as
(sp). Default is on. When disabled, you can use (a7) as a general purpose
register (if r1 is selected as the stackpointer).

Button 4 - Wup       : WarpUp goodies/PowerUp goodies. Default is WarpUp.
Sadly, this is disabled in the promo version!

Button 5 - Gpr       : Display General Purpose Registers or Floating Point
registers in the '680x0 register usage' part. Default is General Purpose
Registers. You can switch in realtime.

Button 6 - ?ERR      : Display unknown errors or trash as ERRORUNKNOWN. When
disabled, unknown errors or trash is ignored. A pushed button means no
trash-error-reports.

Button 7 - Proc Dir  : Process Directory. Allows you to convert an entire
directory.

Button 8 - 32        : Switch between 32/64-bits implementations. Default is
32-bits.

Button 9 - 00 0      : Carry emulation on/off. Default is off.

Button 10 - Rest Off : Rest emulation for divisions. Default is off.

Button 11 - Stat     : Status register/Condition Code register/ Lowlevel
emulation on/off. Beware: check the missing options section to find out for
how far this has been implemented

Button 12 - Frc      : Force 32-bits addressing modes. Default is on. This
selects if you want to use 32-bits addresses as standard when working in
64-bits implementations. This is useful if you are using a PPC processor
with a 32-bits address-bus. Has no effect when working in 32-bits
implementations.

Button 13 - (disk 1) : ASL requester for source-file selection

Button 14 - (disk 2) : ASL requester for destination-file selection

Button 15 - M        : Big Motorola M. Push to start converting

Button 16 - Full     : Full address loading or BAD address loading

Button 16 - X=D      : Emulate FPU .X by converting to .D

Button 17 - Head     : Enable/Disable Header Questions

Go to a file editor and load the non-reassembler example-file  called
'freemem.68k' into any text editor. Put an 

        incdir  <ppcasmincludedirectory>
        include powerpc/powerpc.i

        warpreq

above the source code. Then re-route the includes to the ppc include
directory and remove the easystart.i include.

 Add the following instructions just before the first instruction to be
executed:

        prolog  1024
        head

Then, change the last instruction to be executed (the 'returning' rts) into
a 'lastrts' instruction. Finally add a 'tail' instruction underneath the
source-code and save the file away. The file should now look like the
'freemem.ppc68k' file.

Select the saved file as the input file in PPC680x0, and select an output
file (ie 'Ram:output'). Disable the 'head' questions by  pushing the button
once, and finally press the 'M' button.

You are now ready! Load your file with any editor or try to assemble it! The
output code is Storm PowerAsm compatible and can be run after conversion.
@endnode

@node "Notes" "Notes & Thank you's"
@{b}@{i}@{fg shine}NOTES AND THANK YOU'S@{ui}

@{fg text}We would like to thank and greet the following people (in no particular
order!):@{ub}

 @{b}@{fg shine}*Teemu Suikki and all of Petsoff Limited Partnership*@{ub}@{fg text} for giving 
 us the ability to support the best sound card on the Amiga: Delfina

@{b}@{fg shine} *Sam Jordan*@{ub}@{fg text} from Haage and Partner for giving us the ability to
 add Storm PowerAsm support to PPC680x0 and supplying us with help.

@{b}@{fg shine} *Jurgen Haage*@{ub}@{fg text} from Haage and Partner for giving great help.

@{b}@{fg shine} *Petro Tyschtschenko*@{ub}@{fg text} for great help and keeping the Amiga alive.

@{b}@{fg shine} *Ian Greenaway*@{ub}@{fg text} from White Knight Technology for helping and
 supporting us. Thanks for everything!!!

@{b}@{fg shine} *Parents*@{ub}@{fg text} for everything!

 @{b}@{fg shine}*EBV Elektronik*@{ub}@{fg text} for all the great information, support and help!

@{b}@{fg shine} *Sander Assenbroek Machielsen* @{ub}@{fg text}for being one of the very last 
 good Amiga freaks and supporting/helping us A LOT!!! THANKS!!!!

@{b}@{fg shine} *Bieuw (AKA Bart Neumann)*@{ub}@{fg text} for being a cool dude and of course
 a good Amiga freak as well!!!

@{b}@{fg shine} *Rached Gentile*@{ub}@{fg text} (Raef)
 
@{b}@{fg shine} *Stephen Fellner* @{ub}@{fg text}(RiVa) for great help! 

@{b}@{fg shine} *Barlage Den Haag*@{ub}@{fg text} for great help!!!

@{b}@{fg shine} *(anyone we forgot)*@{ub}@{fg text}
@endnode

@node "Copyright" "Copyright"
@{b}@{i}@{fg shine}Copyright?@{ub}@{ui}@{fg text}

This is a freeware promotional edition. Everything may be done with it
except re- or disassembling. Also, the archive must remain in the original
form.


@{b}TO ALL STUPID PIRATES:@{ub}

@{b}@{fg shine}A PROGRAM WORTH USING IS A PROGRAM WORTH BUYING!!!@{ub}@{fg text}


@{b}OTHER RIGHTS:@{ub}

 PowerUp is courtesy of phase5
 WarpUp & Storm PowerAsm is courtesy of Haage&Partner
 PowerPC is a trademark of Motorola and IBM
 ColdFire is a trademark of Motorola
 Amiga is a trademark of Amiga Int., Inc.
@endnode

@node "Author" "Author"
@{b}@{i}@{fg shine}Contacting Us!@{ub}@{ui}@{fg text}

Do you want the full version of PPC680x0??? Or perhaps you have questions or
want to talk about Mighty Mouse or anything... Well, you can always contact
us at:

 Coyote Flux WHQ
 Rijenpad 21
 1324 WC Almere
 Holland

or call:

 +31(0)36-5334238

or E-mail:

 sraghoeb@ocenl.nl


@{b}@{i}@{u}@{fg shine}THE AMIGA & C64 ARE THE GREATEST MACHINES EVER BUILT!!!@{ub}@{ui}@{uu}@{fg text}

Coyote Flux has been with the C64 for about 12 years and with the Amiga for
about 8. The Amiga is the best machine on the planet and can do anything
every other machine can do. If you don't agree with us please contact us and
we will tell you why you're wrong! PC SUXX!!!

@{fg shine}COMING SOON:@{fg text}

CoyoteSound - The fastest and best sound-editor on the Amiga. Free Public
Domain Mono version available. This program plays 14-bits sounds in 58 kHz
on an 7.14 MHz 68000 Amiga and can play REAL 16-bits sound via Paula. It is
also the only package that fully supports the Delfina 56k DSP in parallel to
the Amiga.

Burnin' Rubber 2000 - A game that fits 2 CD's. Works on all ECS+ Amiga's
with at least an 68030/50MHz, 4-speed CD-ROM, 1 MB Chip/4 MB Fast, harddisk
and supports and fully utilitises Delfina DSP for 4 speaker surround sound,
DSP screen and sound effects etc. The 2D section will have 4096 colors on
screen with many lines of parallax scrolling, zooming, rotation etc. and the
3D section should beat EVERY 3D game on the other platforms! (unlimited
polygons, morphing, phong, gouraud, fog, 24-bits, bumpmapping etc.)

Contact us for questions or information sheets!

@{i}@{fg shine}TIME TO SHOW THE PC-GEEKS THAT AMIGA IS STILL NO #1 !!!!!!@{ui}@{fg text}
@endnode

@node "AMIGA" "AMIGA RULEZ!"
@{b}@{i}@{fg shine}OUR GREAT AMIGA@{ub}@{ui}@{fg text}

This program is dedicated to all the Amigans still living today and of
course to the great @{b}@{i}@{u}@{fg shine}Jay Miner@{ub}@{ui}@{uu}@{fg text}. Thanks to all of you!

Amiga shall rise again!!!
@endnode

@node "PC" "PC SUXX!"
@{b}@{i}@{fg shine}PC MUST DIE!@{ub}@{ui}@{fg text}

Don't you think so?

Let's help the Amiga and kick all pirates to the pathetic PC platform...

@{b}@{u}@{fg shine}PIRACY KILLS!@{ub}@{uu}@{fg text}

For all who truly love the Amiga and didn't stop pirating: We truly don't
believe you 'love the Amiga' so get yourself a baseball bat and do something
about yourself or get a life...
@endnode

@node "ConvertOld" "Converting Old Programs"
@{b}@{i}@{fg shine}CONVERTING OLD PROGRAMS@{ub}@{ui}@{fg text}

This is a section about converting old 68K executables to PowerPC.  It may
look very easy when you read it but we would like to note  that it may get
more complicated if the input-code uses interrupts,  low-level commands,
self-modifying code etc..

Please keep in mind that this section is written for systems running Haage &
Partners' WarpOS.


@{i}Here we go!@{ui}

First of all, you should get yourself a reassembler that is able to recreate
all kind of codes in an efficient way, so that you can make sure everything
is reassembled correctly.

One of the best reassemblers around on the Amiga is @{fg shine}Ingo Molter's 'In_Go'@{fg text},
which is available from the Aminet.

So you want to convert a program to PPC: For example, you take a utility
that needs to be converted.

Of course, you first load it into the reassembler and save it as an
assembler source-code. Make sure that all the code sections  are reassembled
correctly, as several reassemblers do not take  care of this automatically.
You now have a source-code of the program you wish to convert.

Now comes the tricky part of the conversion: Enhancing the program to make
it run on a PPC.

So, first of all you should find the first instruction that needs to be
executed and put a 'prolog' (with the size of your stack frame) there,
followed by a 'head' command. Then search the very last *returning* 'rts'
and change it to a 'lastrts' instruction. Finally, scroll to the bottom of
the file and put a 'tail' instruction there.  Now, go to the top of the
source-code and put the incdir (include-path) and 'powerpc.i' include there,
followed by a 'warpreq' command.

It may be useful to remove ALL 'section' commands as multiple sections may
cause crashes after assembly with PowerAsm. (Especially when loading from an
other section occurs...) 

Save your file away now!

Okay, the most important things have been done now. 

The next step in the PPC680x0 conversion: Load your source-code into
PPC680x0 and select a destination output-file. The default settings of
PPC680x0 should be good for most current PowerPC CPUs and all current
603/604 Amiga implementations.

It might be necessary (for some programs) to make a stack if you  want to
use an other stack pointer than r13: In that case set the stacksize to a
value from which you think it should be big  enough. The 40000 bytes (10000
long) default should be more than enough. Don't forget to push the 'r13'
button (Button 2) for this mode! Remember: This is @{b}@{fg shine}NOT@{ub}@{fg text} required for most
programs. Using the 'prolog' command does nearly the same but doesn't makes
your source-code bigger!!!

Finally, press the 'Motorola M' convert button and wait until the conversion
is finished. When the header questions pop up, answer them with 'No': You
have already used the 'head' and 'tail' commands for this.

You should now load your program into Storm PowerAsm or any similar
assembler and assemble the file you have converted. The output-file should
be executed as documented in the WarpUp manuals. (Assembling is usually:
'@{fg shine}powerasm <file> TO <exe>@{fg text}')

If PowerAsm gives 'alignment errors' you should go to a text- editor like
'CygnusEd' and find the line that causes it (The line that is shown in the
PowerAsm error-report). Place an 'align.l'  in front of that line, just
after the data (dc.x etc.) that causes it. PPC680x0 does automatically
aligns code but may skip an alignment command when it is positioned between
two block- boundaries. In many cases, no alignment errors will occur.@{b}@{fg shine}

IMPORTANT NOTES!!!@{ub}@{fg text}

Currently (Version 1.10e) the fbcc, fscc, cpbcc and other FPU or
Co-processor conditional instructions are bad. They are being fixed now.

Also, a pre-caution must be taken when converting:

THIS WILL HAVE AUTODETECTION SOON!

The execbase is detected in most cases: It is illegal to use address $4 for
this from the PPC side, so those commands  should be changed from:

        move.l  #$4,a0
        move.l  (a0),a6

TO:

        move.l  _SysBase,a6

Direct loading from address $4/%100/@4/4 (with or without leading zeros) or
'execbase' is always detected.


Final Note:

It is always useful to take a look at the program before you  start the
conversion job: Interrupts, CCR/SR access and several other low-level
commands are not always converted perfectly and should be modified by the
user. These commands are used rarely.  Usually, these commands are only used
in very small parts of a  code (or not used at all).
@endnode

@node "ImpCommand" "Very Useful Commands"
@{b}@{i}@{fg shine}USEFUL PPCDirect INSTRUCTIONS@{ub}@{ui}@{fg text}

This section contains information about commands that should definitely be
used for optimizing!


@{b}@{fg shine} Arithmetic Class@{ub}@{fg text}

 sadd    rA,rB,rD     - place the sum rA+rB in rD

 sadd    #SIMM,rB,rD  - place the sum SIMM+rB in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sadds   #SIMM,rB,rD  - SIMM is a signed immediate value and is
                        shifted left 16 bits. The sum is 
                        (SIMM<<16)+rB and is placed in rD
                        (DOES NOT SUPPORT CONDITION UPDATE

 ssub    rA,rB,rD     - place the sum rA-rB in rD

 saddc   rA,rB,rD     - place the sum rA+rB in rD with carrying
                        enabled

 saddc   #SIMM,rB,rD  - place the sum SIMM+rB in rD with carrying
                        enabled

 ssubc   rA,rB,rD     - place the sum rA-rB in rD with carrying
                        enabled
 
 ssubc   #SIMM,rB,rD  - place the sum SIMM-rB in rD with carrying
                        enabled

@{b}@{fg shine} Data Transfer Class@{ub}@{fg text}

 instruction.size:

 sfmove (.s/.d)
 smove  (.b/.w/.l/.q)

 addressing modes:

        (rA,rB),rD
        (<label>,rB),rD

        rA,(rC,rD)
        rA,(<label>,rD)

        (rA,rB)+,rD
        (<label>,rB)+,rD

        rA,(rC,rD)+
        rA,(<label>,rD)+

 <label> is always a 16-bits signed displacement, the + suffix 
 means that the effective address calculated between the brackets 
 is placed in the second register used. Registers are always 
 32-bits in 32-bits implementations and 64-bits in 64-bits 
 implementations, which means that all other bits beyond the
 size selected are set to zero. One exception to the rule:

 using smovex.w (and smovex.w ONLY) automatically extends the
 loaded word to 32-bits or 64-bits depending on the mode.

 For example:

  smove.w (data,d5)+,d4

 adds the 16-bits value 'data' to d5 and loads a word from
 memory which is placed in d4. d5 is set to d5+data. All the
 other bits in d4 are cleared.

@{b}@{fg shine} Floating Point Class@{ub}@{fg text}

 Little Note: an instruction with no explanation is the same 
 as the instruction above it, only with single precision instead
 of double.

 sfadd   fpA,fpB,fpD        - fpA + fpB = fpD
 sfadds  fpA,fpB,fpD        - same, but single precision

 sfsub   fpA,fpB,fpD        - fpB - fpA = fpD
 sfsubs

 sfmul   fpA,fpB,fpD        - fpA * fpB = fpD
 sfmuls

 sfdiv   fpA,fpB,fpD        - fpB / fpA = fpD
 sfdivs
 
 sfsel   fpA,fpB,fpC,fpD    - fpA is compared to 0. If fpA is
                              greater or equal to 0, fpD is set
                              to fpC. If fpA is less than zero
                              or a NaN, fpD is set to fpB. The
                              comparison is unsigned

 sfmadd  fpA,fpB,fpC,fpD    - fpA * fpC + fpB = fpD
 sfmadds

 sfmsub  fpA,fpB,fpC,fpD    - fpA * fpC - fpB = fpD
 sfmsubs

 sfnmadd fpA,fpB,fpC,fpD    - -(fpA * fpC + fpB) = fpD
 sfnmadds

 sfnmsub fpA,fpB,fpC,fpD    - -(fpA * fpC - fpB) = fpD
 sfnmsubs

@{b}@{fg shine} Logic Class@{ub}@{fg text}

 sandi   #UIMM,rB,rD  - UIMM AND rB, place result in rD. All other
                        bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sandis  #UIMM,rB,rD  - UIMM<<16 AND rB. place result in rD. All
                        other bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sori    #UIMM,rB,rD  - UIMM OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 soris   #UIMM,rB,rD  - UIMM<<16 OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seori   #UIMM,rB,rD  - UIMM EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seoris  #UIMM,rB,rD  - UIMM<<16 EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sand    rA,rB,rD     - rA AND rB, place result in rD

 sor     rA,rB,rD     - rA OR rB, place result in rD

 seor    rA,rB,rD     - rA EOR rB, place result in rD

 snand   rA,rB,rD     - rA NAND rB, place result in rD

 snor    rA,rB,rD     - rA NOR rB, place result in rD

 sandc   rA,rB,rD     - Logical AND rA with the one's complement of
                        rB and place result in rD

 sorc    rA,rB,rD     - Logical OR rA with the one's complement of
                        rB and place result in rD

 scountl rA,rD        - count the amount of leading zero's in
                        longword rA and place that amount in rD

 scountq rA,rD        - count the amount of leading zero's in 
                        quadword rA and place that amount in rD

@{b}@{fg shine} Shifting Class@{ub}@{fg text}

 srolal  #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times, AND the
                              result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from M1 to M2 and 0
                              bits elsewhere (longword)

 srolmil #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (longword)

  Example:    srolmil #4,d1,d2,28,31

  rotate register d1 4 times. The mask is set from bit 28 to bit
  31, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.
@endnode

@node "Where To Get" "Where To Get?"
@{b}@{i}@{fg shine}Where To Get?

@{ub}@{ui}@{fg text}
That's a difficult issue here! As a matter of fact, the first negotiations
with a publisher are being held now, so it won't be long until PPC680x0 will
not be available at home-sales anymore. Currently, the program is available
at @{"Coyote Flux" link "Author" 0}, and sells at $75. Contact us for any questions about this
and the current state of the publisher-negotiations.
@endnode

@node "PROMONOTE" "PROMONOTE"
@{b}@{i}@{fg shine} Important PROMO Note@{ub}@{ui}@{fg text}
 --------------------

Hello and welcome to the new Aminet promo-release of PPC680x0... This
promo-edition contains about 50% less features than the commercial version.
The guidefile (PPC680x0.guide) is the  original taken from the commercial
version. This section  contains important information on what is left in and
left out in this version.

First of all, no changes have been made to the guidefile, except that this
section has been added and the 'optimizations' section has been removed.
Also, the '@{"Copyright" link "Copyright" 0}' section has been changed and a '@{"Where To Get" link "Where To Get" 0}' section
has been added.

When reading the guidefile, there should be kept in mind that not  all the
described features are available in the PROMO-version. A  list of removed
options and features can be found in this section.

The program itself has been cut-down quite a lot, looking more like the
PPC68EC0x0 (Non-FPU) version which will also be  available soon. The
following features and options are not  available in the promo-version or
are changed:

 - The FPU is set to DISABLED
 - All the bit field commands are set to 'not supported'
 - The following commands are set to NOTSUPPORTED: 'rte', 'divsl',
   'divul', 'link', 'unlk', 'mulu', 'muls'
 - Carry Emulation can not be enabled
 - ONLY the PPC 32-bits implementation mode is supported
 - The 'SUPER2' and 'SUPER3' PPCDirect command set have been 
   disabled: This means that only the first 50% of the PPCDirect 
   commands are available for usage. Other commands will give a
   'notsupported' error.
 - There's no macro support at all
 - There's wont be an AltiVec module for the promo
 - There's no STOP button... (Sorry dudes...)

Finally, we would like to say that we are not responsible for any bugs that
this Aminet-edition may have. Although the full version has been tested
quite intensively some new bugs may have entered this version as a result of
disabling several options.

Theoretically, the 'disabling'-process shouldn't be able to cause any bugs:
We just want to notify you that it's not impossible.

Also, we would like to notify coders out there that parts have not just been
set to 'disabled' but have actually been removed from the program. The
executable is therefore smaller than the commercial one and no removed parts
can be revived in any way.


@{i}Greetings and cheers,

 Sharwin & Rakesh Raghoebardayal
 Coyote Flux@{ui}
@endnode

