
                             PREASSEMBLER 1.4

                               Version 1.40

                                CD-Release

                                    von

                                  Cyborg

 ,-----------------------------------------------------------------------,
 |                                                                       |
 |  Dieses Programm ist Freeware, es darf frei kopiert werden, solange   |
 |  das Archiv zusammenbleibt, nichts geändert wird oder Ich mir das     |
 |  anders überlege. Ich übernehme keine Garantie für die Funktion des   |
 |  Programms oder der programmtechnischen Folgen für Files und Fest-    |
 |  platten. Bis dato ist allerdings noch kein solches Fehlverhalten des |
 |  Programms gemeldet worden.                                           |
 |                                                                       |
 `-----------------------------------------------------------------------'

    Einige Vereinbarungen vorweg, bekannte Libs sind:

    exec_lib.fd                     commodities_lib.fd   
    dos_lib.fd                      console_lib.fd       
    asl_lib.fd                      datatypes_lib.fd     
    graphics_lib.fd                 diskfont_lib.fd      
    intuition_lib.fd                disk_lib.fd          
    mathffp_lib.fd                  dtclass_lib.fd       
    expansion_lib.fd                keymap_lib.fd        
    gadtools_lib.fd                 layers_lib.fd        
    icon_lib.fd                     locale_lib.fd
    iffparse_lib.fd                 lowlevel_lib.fd
    input_lib.fd                    misc_lib.fd
    mathieeedoubbas_lib.fd          nonvolatile_lib.fd        
    mathieeedoubtrans_lib.fd        potgo_lib.fd        
    mathieeesingbas_lib.fd          ramdrive_lib.fd                
    mathieeesingtrans_lib.fd        realtime_lib.fd                
    mathtrans_lib.fd                rexxsyslib_lib.fd        
    battclock_lib.fd                timer_lib.fd        
    battmem_lib.fd                  translator_lib.fd
    bullet_lib.fd                   triton_lib.fd
    cardres_lib.fd                  utility_lib.fd
    cia_lib.fd                      wb_lib.fd
    colorwheel_lib.fd               amigaguide_lib.fd        
    Guienv_lib.fd                   sowie : MUI, XPK ,XPR

    Kommentare sollten lieber in einzelne Zeilen geschrieben werden,
    da einige Funktionen ein Leerzeichen oder TAB als Markierung
    fuer nachfolgende Anweisungen Interpretieren. Gilt nicht für
    Libraryaufrüfe.
 
  *********************************************************************
  *                                                                   *
  * Bei Funktionen die Preass anbietet, kann nicht davon ausgegangen  *
  * werden, daß die Register D0 oder A0 unberührt bleiben.            *
  *                                                                   *
  *********************************************************************

    Wie benutze ich Preass ?

    Preass ist ein CLI-Kommando und sollte in C: stehen. Es schreibt das
    File Source.p um in das ASMONEkompatible File Source.s (oder wie
    man es auch nennen will). AsmOnekompatibel heißt nun,daß gewisse 
    Eigenarten des ASMONE berücksichtig werden , wie z.B.: 

    EVEN fuer Gerade Adressen,dc.b "  für Strings, BLK.b für Blöcke
    bzw. Speicherbereiche die vorhanden sein sollten. Vom Assembler
    werden z.b. die Relativen Sprünge berechnet (.S,.W,.L) usw.
    Dies könnte auf einem anderen Assembler nicht funktionieren. In 
    diesem Fall müßte der Source dementsprechend geändert werden.
    Sämtliche mitgelieferten Files (includes) sind Asmonekompatibel
    und entsprechen nicht mehr den Commodoreoriginalen!
     
    Der Aufruf erfolgt wie folgt:

 !                            PREASS SOURCE.p                              !

    Was macht das Programm PREASSEMBLER nun eigentlich?

    Also, ich bin vor einiger Zeit zu dem Schluss gekommen,daß es doch
    ziemlich aufwendig ist ein Assemblerprogramm zu schreiben, dauernd muss
    man Move.l Was_weiss_ich,nach_wohin_dengleich tippen. Ständig neue
    Macros schreiben (ich hab noch NIE ein Macro geschrieben oder benutzt
    muss ich eingestehen) war mir dann doch zu aufwendig und so kam mir 
    der Gedanke ein Programm zu entwickeln,dass die Informationen der FD
    Files (endlich sind die mal von Bedeutung) nutzt um mir viel Schreib-
    kram abzunehmen.

    Anstatt zu tippen:

    Move.l Dosbase,a6
    move.l Filehandle,d1
    move.l #Puffer,d2
    move.l #1024,d3
    jsr Write(a6)

    tippt man nun nur noch :

    Write(Filehandle,#Puffer,#1024)

    Das macht die Sache kurz und übersichtlicher. Natürlich sind jetzt 
    einige Möglichkeiten nicht mehr vorhanden. Man kann jetzt vor dem
    eigentlichen Aufruf durch JSR write(a6) nichts mehr an den Daten ver-
    ändern, wie z.b. SUB.l D2,D3 oder sowas in der Art. Das muss man jetzt
    ebend vorher machen bzw. anders z.b.
    
    Move.l Dosbase,a6           ;Dosbase übergeben
    move.l Filehandle,d1        ;Filehandle übergeben
    move.l #Textanfang,d2       ;Anfangsadresse des Textes
    move.l #Textende,d3         ;Endadresse d.T.
    sub.l D2,D3                 ;Damit errechnet sich die Länge des T.
    jsr Write(a6)
    ...
    
    Textanfang: dc.b `Aber Hallo`
    Textende:   dc.b 0

    das müsste dann so aussehen:

    Write(Filehandle,#Textanfang,#Textende-Textanfang)
                                          ^^^^
                                          Völlig I.O.!


    Ab Version 1.39 kann man für Zeiger auf Strings o.ä. die normalerweise
    der Gestalt : Openlibrary(#Libname,Versionsnummer) entsprechen, auch
    Openlibrary(&Libname,Versionsnummer) schreiben, welches den Compiler
    dazu bringt, wenn möglich, einen LEA statt einem MOVE.l # zubenutzen.
    LEA ist schneller als MOVE und steigert so die Ablaufgeschwindigkeit.
    Es ist sicher dieses Symbol auch bei Zeigern zu benutzen, die in ein
    Datenregister schreiben, da dann automatisch MOVE verwendet wird.
    

    TAGLISTEN - Strukturen
    ----------------------

    Preassembler hat nun die Möglichkeit Strukturen direkt im Source
    zu lesen,d.h. ich kann in der Befehlszeile z.b. alle Tags und ihren
    Wert angeben.Dazu muss der Strukturname mit einem ">" beginnen(siehe
    beispiel),ferner muss er mit einem Space oder einem ":" enden. Alles
    was danachkommt wird schon als Inhalt der Struktur angesehen. Tags
    oder Inhalte werden mit einem "|" getrennt. Wenn eine Zeile nicht
    ausreicht,dann muss trotzdem ein "|" als Inhaltende gesetzt sein,sonst
    wird das EOL [LF ($0A)] als Fehler betrachtet. Eine Klammerzu ")"
    beendet den kompletten Befehl,sollte ein Strukturinhalt davor stehen,
    braucht er nicht mit "|" beendet zu werden.

    ACHTUNG: Noch werden alle Inhalte als LONGWORD interpretiert!

    Beispiel:
        
    screen=opennewscreentaglist(#0,>newscreentaglist:SA_left,0|SA_Top,0|
                                                     SA_....,...|...,...)

    window=opennewwindowtaglist(#0,>newwindow:WA_left,0|WA_top,0)

    Das Ergebnis sieht so aus:

    newscreentaglist:
	    dc.l SA_left,0
    	dc.l SA_top,0
	    dc.l SA_width,100
    	dc.l SA_Height,100


    Taglisten - STRUKTUREN
    ----------------------

    Systemstrukturen können mit der Syntax:

    »INCLUDENAME:STRUKTURNAME[>NeuerName]:ITEMS|ITEMS|ITEMS|...

    benutzt werden. Der Includename wird von einem `:` abgeschlossen!
    Daher darf kein DEVICE angegeben werden!Um dies zu gewährleisten,
    kann PREASS über die Compilerinfo {* INCDIR: XXXX *} das Haupt-
    includeverzeichniss angegeben werden. Sie sollte ganz vorn im Source
    stehen. Die Info kann sooft überschrieben werden ,wie sie Lust haben!
    d.h. sollten Sie aus irgendeinem Grund ein anderes INCUDE-verzeichniss
    brauchen, geben sie es nur an.

    Beispiel:

    ; Testsource V1.14
    {* INCDIR: DH0:Coder/Includefiles/Assembler/ *}

    ...
    
    screen=openscreen(»intuition/screens.i:NewScreen:0|0|640|256|
                       3|1|2|$0804|0|0|Screentitle|0|0)
        
    Fertig! Die Struktur wird nun erzeugt und zwar in der in den 
    Includes vorgegebenen Weite für das entsprechende Feld.
    Anstatt eines "|" kann hier ein "," stehen. Aber nur bei Strukturen,
    bei Taglisten MUSS ein "|" stehen!Und ein "|" oder ein "," MüSSEN
    auch das letzte Item abschliessen,wenn noch weitere Angaben zur
    Funktion folgen!

    Beispiel: 

    ????(»XXX:FDFSA:033,356,,#0)
         ^^^^^^^^^^^^^^^^^^^ ^^---Dieser nicht mehr!
         Dieser Teil gehört
         noch zur Struktur.


    Beispiel:

    Addgadget(»intuition/intuition.i:Gadget>Aendern_gadget:.....,...)
              ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^ ^^^^^^^^^^^^^^
              Name des Includefiles  Name         Name der Str. im Source
                                     der Struktur

    
      
    Strings
    -------


    Strings können ab sofort nicht nur über PRINT ausgegeben werden,
    sondern auch direkt Write,allerdings mit keinen Einschränkungen:

    WRITE(Filehandle,"Hello World!",?)

    Diese wird wie folgt übersetzt:

    move.l Dosbase,a6
    move.l filehandle,d1
    move.l #Helloname,d2        ; Der Name wird selbstständig erzeugt!
    moveq.l #$0D,d3             ; Die Länge des Strings wird bei ?
    jsr Write(a6)               ; automatisch eingesetzt. Sie steht aber 
    ...                         ; auch in anderen Funktionen mit ? zur

    Verfügung.D.h. man kann die Länge des LETZTEN Strings in allen,
    dem Source NACH,nächsten Befehlen benutzen. Seit Version 1.3 wird
    jedem String eine Nummer angehängt, so das es keine doppelten Strings
    mehr gibt. Daher kann der Programmierer selbst keine Stringnamen von
    Preass mehr zusammensetzen.
    
    Ferner kann man durch den Befehl ?»Name ,die Länge in eine Variable 
    mit freiwählbarem Namen geschrieben.

    Beispiel:   

    ?»Hellolänge

    Move.l #$XX,hellolänge

    Die Variable wird automatisch erzeugt.

    INC - BEFEHLE
    -------------

    Syntax : {* INCXXX [: Anweisung] *}

    1. INCDIR: Pfad/Pfad/Pfad/ 
    ==========================

    Siehe Strukturen

    2. IncVAR: Name_der_Variablen
    =============================

    Die Variable wird in die Variablenliste aufgenommen und am Schluss
    angehängt. Das INCVAR kann überall im Source in einer einzelnen Zeile
    stehen,die dann beim Übersetzen wegfällt.

    3. IncBlock: name,Anzahlbytes
    =============================

    Im Source wird ein Speicherbereich mit dem Namen "NAME" und der ange-
    gebenen Bytes belegt. Dies sieht wie folgt im Source aus:

    NAME: blk.b ANZAHLBYTES,0
    even
    
    Das Even wird angehängt,damit es keine ungeraden Adressen gibt.

    4. IncSYSBlock: Name,Anzahlbytes
    ================================

    Es gilt eigentlich alles wie bei INCBLOCK ,nur dass der Block an eine
    durch 4 teilbare Adresse gelegt wird!

    {* INCSYSBLOCK: FIB,260*}

    CNOP 0,4
    FIB:  blk.b 260,0
    even

    5. Nolibrarynames
    =================

    Syntax: {* NoLibNames *}

    Die Funktion schaltet das automatische Generieren von Librarynamen
    aus. D.h. wenn ich eine Dos-Funktion benutze,wird auch die Library im 
    Speicher angelegt,öffnen muss man sie natürlich selbst!
    Preass erzeugt immer den korrekten Namen,denn bei Libs und Devices
    muss man auch auf die Groß- und Kleinschreibung achten. Mit NoLibrary-
    Names kann die automatische Ermittlung unterbunden werden. Dafür 
    hat der Programmierer dann selbst auf Groß und Klein zu achten.

    Im Normalfall muss eine Lib z.b. so geöffnet werden :

    DosBase=Openlibrary(#DosName,#Version)

    Der Name wird also selbst nicht angegeben,sondern nur das Label des
    Namens,der selbst erzeugt wird. Es ist zwar nicht schwer den Label
    zu bestimmen,aber wem der Source besser gefällt ...

    Am Anfang des Sourccodes muß die Anweisung :

    {* NoLibNames *}

    stehen,dann wird eine Lib z.b. so geöffnet:

    DosBase=OpenLibrary("dos.library",#Version)

    6. Delayaus  
    ===========

    Syntax : {* Delayaus *}

    Macht eigentlich nichts ,außer die Anzeigepause am Ende des Über-
    setzens abzuschalten.

    7. Autolib
    ==========

    Syntax: {* AutoLib an *} oder {* AutoLib aus *}

    Diese Funktion erschliesst dem "faulen" Programmierer ,die Welt der
    Hochsprachen,naja,jedenfalls einen Teil davon. Wenn * Autolib an *
    gewählt wird,dann erzeugt das Programm die Routinen Openlibs und
    Closelibs automatisch,auch die Basenames und die Base-Variablen.
    Es werden alle bekannten Libs erzeugt. Alle Libs die Preass nicht
    kennt müßen von Programmierer selbst eingebunden werden. * Autolib an *
    schaltet * Nolibnames * ab,weil das System sonst nicht laeuft. Die
    Probleme,die normalerweise auftretten,wenn man NOLIBNAMES und 
    * DosBase=OpenLibrary("dos.library",#Version) * verwendet,können
    bei einer unbekannten Lib nicht auftretten,da diese nicht automatisch
    erzeugt wird. Sie können also unbesorgt mit einer unbekannten Lib
    arbeiten wies ihnen gefällt.

    siehe auch 9.

    8. AutoStartup
    ==============

    Syntax : {* START:XXXX *}
             ( XXXX steht fuer den Namen ihrer Hauptroutine )

    Es wird ab der Position im Sourcecode eine Routine MAIN: angelegt,
    die OPENLibs aufruft,testet obs ging und danach ihre Hauptroutine
    anspringt. Diese muss mit RTS abgeschlossen werden ,sonst herrscht das
    Chaos :-). Sobald ihre XXXX abgelaufen ist,wird CLOSELibs aufgerufen
    und das Programm mit dem aktuellen Errorcode verlassen. Dieser ist
    in der Variable ERROR gespeichert. Soll also ihr Programm eine Fehler-
    meldung ausgeben,dann schreiben sie den Fehlercode bitte in Error.
    Er wird auch ein Startup.i includet,das die Dosanpassung vornimmt
    und ggf. eine WB-message replyed. Dieses Startup.i können sie ggf.
    selbst erweitern und anpassen ,es befindet sich im Preassverzeichnis.
    Um an das mitgelieferte Startup.i angepasst zusein,werden die Variablen
    WBmessage,Laenge,Adresse,Error erzeugt,natürlich auch wenn sie
    Startup.i ändern sollten,denn das kann Preass ja nicht wissen.

    9. Fremde FD Files
    ==================

    Syntax : {* UseFD:XXXXXX *}
    Syntax : {* FlushFD *}

    Hab dieser Version sind sie nicht mehr auf eine neue Version von Preas
    angeweisen,wenn Sie eine neue Lib verwenden möchten. Sie brauchen nur
    noch das nach Commodorerichtlinien erstellte FD File bei dem Befehl
    USEFD (komplett mit PFAD!) angeben und sobald eine Funktion nicht in
    den internen Dateien gefunden wird,such Preass in dieser Externen. Damit
    diese Operation nicht zu lange dauert,wird das Fd nachgeladen,sobald es
    bekannt ist. Wollen sie mehrere neue Libs verwenden,kopieren Sie bitte
    alle zu einem File zusammen. Ansonsten müßten Sie FLUSHFD benutzen um 
    den FD SPeicher freizugeben und mit USEFD ein neues FDfile einladen.

    Da es sich um ein Standartfile handelt,wird auch der korrekte Name und
    die Basebezeichnung verwendet,z.b. beim automatischen Erstellen von 
    Openlibrary.
    

    10. Libraryversionen
    ====================

    Syntax: {* Version: XXX=40 *}
                      
    Preass öffnet Lib mit der Versionsnummer 0! d.h. falls sie eine
    bestimmte Version wünschen ,müßen Sie sie vorher bestimmen. Ob Sie
    dabei die Lib z.b. Dos.library oder nur Dos nennen,ist völlig egal.
  
        Beispiel: {* version: Intuition=39 *}
    
    Die Intuitionlibrary wird nun mit der Versionsnummer 39 geöffnet
    (OS3.0). Falls das nicht klappt,wird das erstellte Programm beendet.

    11. RETURN Werte
    ================

    Syntax: {* Return XXXX *} bzw. {* ReturnQ XXX *}
                      
    An die Stelle im Sourcecode wird wie in C der Returnwert eingebunden.
    Return funktioniert bei jedem Wert,ReturnQ sollte bei allen unter 256
    angegeben werden,Preass benutzt dann die Quickvariante des Befehls.

    12. INIT
    ========

    Syntax1: {* InitXXXX: Name,Name2,Name3,...*}
                                           ^^^^^
    Syntax2: {* InitXXXX: Name,Inhalt1,Inhalt..,..*}

    Es wird eine XXXX Liste,Node usw. initaliesiert im StrukturSpeicher  
    abgelegt. Zur Zeit kann Preass folgende Systemlisten verwenden:

      *SOL*
    1. MinList Syntax1
    2. MinNode Syntax1
    3. Node    Syntax2
    4. List    Syntax2    
      *EOL*

    Beispiel: {* InitMinList: Alist,Clist,DList*}
              Es werden jetzt drei Listen erstellt.

              {* InitMinNode: Anode,BNode*}

              {* InitList: Name,Type*}
        
              {* InitNode: Name,Type,Pri,Zeiger_auf_den_Namen*}

    Mit den Anweisung sollte man vorsichtig sein,ich geb abern Source
    mit der das benutzt,jedenfalls die MinList.

 !  Im Namen sind *KEINE SPACE* erlaubt und das Abschlußzeichen * muss !
 !  OHNE SPACE DIREKT am Ende des Namens des letzten Eintrags stehen!  !

    13. {* Ausgabe: name*}
    ======================


    Das Preass-Processwindow wird geschlossen und alle Ausgaben wandern
    in das File NAME. Das kann natürlich auch eine virtuelle Datei sein,
    z.b. Con: RAW: oder sowas.

    14. {* WB2F *} & {* WB2B *}
    ===========================

    WB2F = WorkBenchToFront

    WB2B = WorkBenchToBack

    Die beiden Funktionen bewegen Preass dazu die WB nach vorn zu bringen
    bzw. den alten Screen nach vorn zu holen. Das hat den Vorteil,dass man
    nicht ständig die Screens wechseln muss um den Compilationsvorgang
    zu beobachten.


    15. {* AutoLVO *}
    =================

    Alle zu benutzenden LVO-Files z.B.: Dos_lib.i werden automatisch ein-
    gebunden. Sie tauchen am Ende des Zielfiles auf. ASMone hat damit keine
    Probleme, was nicht heißt, daß andere Assembler das auch so hinnehmen.

    Hinweis: Sollte die Funktion `LIBNAMESAUS` in Funktion sein, dann ist
    AutoLVO auch ausgeschaltet.


    16. {* Flush *}
    ===============

    Der Librarynamespeicher wird gelöscht,d.h. jeder folgenden Funktion
    wird die entsprechende Librarybase vorgesetzt,so als ob ein globales
    Label gesetzt worden wäre. --> Labels
    
    17. {* Array[TYPE]: Name,Date1,Date2,Date3,....,Daten*}
    =======================================================

    Es wird ein Datenfeld im Speicher angelegt vom Typ `TYPE`,wobei
    Type={Long,Word,Byte} sein kann.

    18. {* String: Name="Inhalt"*}
    ==============================

    Legt einen Null-Terminierten String `Name` an.

    19. {* IncFFPVar: Name=[-]Zahl*}
    ================================

    Eine EinfachFiessKommaZahl (8 Stellen nach dem Komma) wird unter
    Name angelegt und kann `.` oder `,` als Kommastelle haben.     
    Wenn ein "-" angegeben wird, dann wird die Zahl negativ.

    Die Umwandlung erfolgt für beide Seiten des Kommas getrennt, sodaß
    Zahlen bis 4.2 Milliarden gewandelt werden können. Dabei treten
    aber aufgrund der Matissenrechnung Rundungsfehler in der MathFFP-
    library auf, die z.b. die Zahl 100000003.1415 als 100000000 heraus-
    kommen lassen. Dies ist kein Fehler von Preass!
   
    Nach dem Assemblieren des Sources ist die Variable sofort benutzbar.

        {* IncFFPVar: pi=3.141592*}

                ||
                \/
   
    pi:       dc.l $C90FD8C2

    20. NewProc         (Neue Prozedur)
    ===========

    Syntax: NewProc=Name[Name,Name,...][Register,Register,...]

    Im Speicher wird ein Eintrag eingerichtet,die Anzahl der Einträge ist
    auf 10KB Text begrenzt. Dieser Eintrag muss aussehen wie ein FD-File-
    Eintrag ,nur mit dem Unterschied , daß anstatt runden Klammern, eckige
    verwendet werden. Beim aufrufen der Prozedur nimmt  man ganz normale
    Klammern. Das ganze arbeitet nun folgendermassen. Der Aufruf wird normal
    erstellt,also alle Angaben wie bei normalen Libraryaufrüfen. Dann wird
    mittels JSR die Routine aufgerufen. Sie muß natürlich existieren,sonst
    meckert der Assembler. Der User muß selbst dafür sorgen , daß seine an-
    gegebenen Register von ihm auch so gelesen werden.

    {* NewProc=TestProzedur[Zeiger,TestDate][a0,d0]*}

    Result=TestProzedur(#zeiger,Date)

    TestProzedur:
        Move.l a0,Internerzeiger
        Move.l d0,InterneVariable
        ...
    {* Return 0*}   ; z.b. 0 , oder 1 oder 
        Move.l Ergebnis,d0
        RTS

    21. Include 
    ===========

    Syntax: Include Vol:Pfad/Name

    Im UpdateInfo (unten) steht schon alles wesentliche,anhand des Grund2.p
    Sourcecodes wird das nun erläutert:

    ; GrundSource 2 
    ; 
    ; (c) 1995 Cyborg 

	IncDir 	"Sys:Coder/"
	Include     "Preass/Konstanten.inc"
	Include     "Preass/ASL_lib.inc"
    Include     "Preass/intuition.inc"
    Include     "Include/Guienv.i"
    Include     "Include/Libraries/gadtools.i"

  ,---------------------------------------------,
  |                                             |
  |  {* Include sys:coder/preass/Options.p *}   |
  |  {* Include sys:coder/preass/Prozeduren.p *}|
  |                                             |
  `---------------------------------------------'

    {* String: Version="$VER: (C) CYBORG 95"*}

    Start:

    Die ersten Includes sind für den Assembler, die anderen beiden Includen
    in den HauptSource die File Options.p und Prozeduren.p. Dies alleine
    wäre ja nichts besonderes,daher werden die Sources compiliert und dann
    dem HauptSource included. Damit alle Funktionen funktionieren sollten
    alle Prozeduren am Anfang included werden, sonst finden vorherige
    Routinen sie nicht. Ferner werden alle Compilerangaben,Variablen,Bloecke
    usw. als GLOBAL benutzt, was einfach bedeutet, daß es keinen Unterschied
    macht, ob die Variable in einem Include erzeugt wurde oder woanders.

    22. Optimierung 
    ===============

    Syntax: Optimierung an

    Optimiert einen kleinen Schönheitsfehler von Preass weg:

    z.b. Ok=Funktion()
         CheckF Ok,.error

         als Source:

         jsr Funktion(a6)
         move.l d0,ok
         move.l ok,d0
         tst.l d0
         beq .error

    Wie man sehen kann, ist da "move.l ok,d0" zu viel drin. Das wird
    entfernt! Weitere und bessere Optimierungen sind geplant.

    23. ErrorHandling
    =================

    Syntax : {* Error: Sourcecode_für_Errorhandling *}

    Entweder kann hinter Error: include `XXXXX:XXXX/Xxxx.s` stehen
    oder gleich der Source der verwendet werden soll. Wird diese
    Funktion nicht benutzt gelten die in "StandartError.p" definierten
    Standartfehlercodes.
    Diese Standartcodes (5 Stück) sollten nicht geändert werden, weil
    Preass selbst diese Codes benutzt, d.h. Wenn eine Lib nicht gefunden
    werden konnte, dann sprint die Hauptroutine nach Errorhandling.
    Eine eigene Errorroutine MUß mit einem RTS beendet werden!


    24. IncBssBlock: Sectionname,Name,Anzahlbytes[,Name,AnzahlBytes...]
    ===================================================================

    Es wird eine Sektion `Sektionname` angelegt in der mehrere Blöcke
    angelegt werden können. 

    {* INCBSSBLOCK: A,Eins,260,Zwei,2000,Drei,2001*}

    Setction A,Bss_c
    Eins:       ds.b 260
    zwei:       ds.b 2000
    drei:       ds.b 2001

    Der Vorteil dieser Blöcke liegt drin, daß sie nur 8 Byte Speicher im
    ausführbaren Programm belegen. 
    Der Nachteil ist, daß diese Blöcke nicht geleert werden, also Daten-
    müll enthalten.

    25. DIM Name(X,Y,...)
    =====================

    Eine Speicherbereich mit der nötigen Länge um X*Y*... Longs zuspeichern
    wird angelegt.

    {* DIM T(100,200)*}

    Vereinfacht etwas die Blockallokierung.

    NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*

    26. Struktur-Offsets
    ====================
    
    {* Structure BasisName(Gesamtlänge),A(A-Offset),b(b-Offset),...*}

    Es wird ein Speicherblock mit Gesamtlänge in Bytes belegt. Der Basisname
    + "." + Offset wird als Konstante definiert mit dem Wert Offset.

    {* Structure Tiger(100),Kopf(0),Kralle(4),Hals(10)*}

    Tiger.Kopf=0
    Tiger.Kralle=4
    Tiger.Hals=10

    Diese Offsets können später z.B. so verwendet werden:

    Krallenstatus=.lTiger.Kralle(#Tiger) 
    Hals=Tiger.Hals(Tiger)

    Die Konstanten können natürlich global verwendet werden. Also auch in 
    normalem Assemblercode oder in Mathe1-Anweisungen.

    Wird die Gesamtlänge nicht angegeben, wird auch kein Speicher belegt,
    die Konstanten werden ungeachtet dessen definiert.

    {* Structure Tiger,Kopf(0),Kralle(4),Hals(10)*}

    Es gibt noch eine Möglichkeit die Struktur halbautomatisch anzulegen. 
    
    {* Structure Kralle(20),A(4),B(8),C(16)*}
    {* Structure Tiger(100),Kralle(STRUCT Kralle),Hals(LONG),Pad(BYTE)*}

    Tiger.kralle=0
    Tiger.Hals=20
    Tiger.Pad=24

    Wie man sehen kann, werden die Offsets selbst berechnet, dies klappt
    nur wenn alle Offsets angegeben werden. Als Länge eines Offsets kann
    man : LONG,ULONG,APTR,BPTR,CHAR,UWORD,WORD,BYTE und STRUCT angeben.
    Bei STRUCT muß nur der Name der Strukture angegeben werden. Diese muß
    aber bereits mit dem Befehl Structure erstellt worden sein und auch
    mit einer Gesamtlänge angegeben sein, sonts bricht das Programm ab.

    27. Konstanten
    ==============

    Syntax:  {* Const Konstante1=1,Konstante2=2 *}

    Alle Konstanten werden in Libraryaufrüfen erkannt und sind für Struktur-
    schreiben verwendbar.

    Beispiel:

    mem=Allocmem(Sizeof(Structure),MemF_Fast)

    28. PowerPC
    ===========

    Syntax:  {* DoNotUsePPC *}

    Dieser Befehl veranlaßt den Compiler Anweisungen, welche die ppc.library
    von Phase5 ansprechen, zu ignorieren.

    Dies ist nötig um Programme zu schreiben, welche durch Öffnen der
    ppc.library feststellen, ob Sie PPC-Code nutzen können oder nicht.

    Wenn Sie das so machen wollen, dann müßen sie das File "PPC_LIB.FD"
    via {* USEFD: ... *} benutzen.


    29. NewCProc         (Neue C-Prozedur)
    ============

    Syntax: NewCProc=Name[Long,Word,Byte,....]

    Die Funktion definiert eine C-Prozedur, so daß diese von Assembler
    aufgerufen werden kann. Dabei müßen sie beachten, daß sie der Funktion,
    die sie definieren wollen, einen "_" voran stellen, sonst kann sie nicht 
    gelinkt werden. Der ASMONE macht aus dem Funktions-namen einen UPPERCASE-
    String. Dies wird vom SAS-C-Linker z.B. bemängelt! Ändern sie in dem Objekt-
    file einfach den String in LOWERCASE!!! 

    Die Parameter werden in umgekehrter Reihenfolge über den Stack übergeben.
    Dazu müßen Sie angeben, welche Länge der Parameter hat, also Long,Word 
    oder Byte.

    Fügen Sie das C-Keyword __saveds for jede Funktion, welche von Assembler aus 
    aufgerufen wird! Es stellt sicher, daß der Datensegement-Zeiger in A4
    geschrieben wird. 

    Linken Sie ihr mit "WL" erzeugtes Object als erstes Object in der Linker-
    Anweisung, da so der korrekte Startup-Code von Preass benutzt wird, statt 
    des C-Codes, welcher die Assembler-Variablen nicht setzt. Am besten
    schreiben Sie ein C-Init, welches z.b. die Dosbase öffnet. Sie können Sie 
    natürlich auch einfach als Parameter übergeben. Wichtig ist z.b. daß
    Ausgaben aus einem C-Object nicht erfolgen, weil die Variable "stdout" sich
    nicht mit einem neuen Wert überschreiben läßt ( ich habs jedenfalls nicht
    geschafft )

    Beispiel:
    =========

    void Telefax (char *name, word *anzahl)
    
    {* NewCProc=_Telefax[Word,Long]*}

    _Telefax(&Anz,&Loadname)
    
    NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*


    Stringoperationen:
    ==================

    Syntax: Ziel=="Text"[+"Text1"...[+Puffer+]...[+Left$(Puffer,MaxChars)+]]
    
    In den Puffer >Ziel< wird der String "Text" kopiert. Der Puffer muß
    groß genug sein. Zu diesem Text kann in den Puffer noch ein weiterer
    Text eingelesen werden. Dieser Text kann angegeben werden oder aus
    einen anderen Textpuffer ausgelesen werden.

    Puffer >Ziel< wird nicht angelegt,sondern wird vorausgesetzt. Der 
    Puffer enthält eine Null als Terminierung.

    Beispiel:

    Name=="Name: "+ReadPuffer+"\n"

    Es kann (noch) nicht mit Puffern angefangen werden.

    Dafür gibt es eine Funktion bei Strings LEFT$() , die Maxchars ,
    von Links her , ausgibt. Sollten nicht genug Zeichen im String sein,
    wird dieser mit SPACES aufgefüllt. Das ist deshalb so,damit man 
    Tabellenausgaben mit definierter Länge machen kann.


    For-Next-Schleifen
    ==================

    Syntax:     For I=A To B [Step {-}C]
                Next I{-}
    Step ist optional , es wird normalerweise 1 angenommen.
    `-` ist fuer negative Schleifen,es muß beim Next auch mit angegeben
    werden sonst klappts nicht. Da dies ein ONE-PASS-Compiler ist , gehts
    leider nicht anders (iss zu viel Aufwand).

    Statt A , B und C kann man natürlich auch Zahlen einsetzen :-)

    NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*NEU*

    Der Preassembler übersetzt nur den PreassSource in einen Assemblersource,
    dabei ist zu beachten:

    1. Speicherstellen,auf die gezeigt werden soll, wie im letzten
       Beispiel Textanfang und Textende , müssen mit einem # davor
       übergeben werden.

    2. Variablen sind ohne # verwendbar

    3. Konstanten müssen mit # verwendet werden, es sei den Sie sind mit
       {* CONST *} definiert worden und werden in einem Libraryaufruf 
       benutzt.

    Dazu ist zu sagen, daß der Preassembler nicht wissen kann was welche
    Variable darstellt,dies ist auch aus dem FD File nicht ablesbar,da 
    es auch Datenregister gibt,die Zeiger auf Adressen beinhalten können.

    Der PREASSEMBLER übersetzt in MOVE.L Kommandos,d.h. die Variablen
    dürfen NICHT WORD oder BYTE Weite haben,da es sonst instabil wird
    eine einfache Methode um Worte oder Byte in Langworte zu wandeln ist:

    clr.l d0
    move.b Variable,d0 bzw. move.w Variable,d0
    move.l d0,Variable

    und schon ist die Variable sicher gewandelt. Im A1200 ist sowieso ein
    32 Bit Datenbus vorhanden,daher sind Langwordoperationen ohne Zeit-
    verlust zu Wordzugriffen verwendbar(das gilt natürlich auch für
    alle anderen "Gross"-Prozessoren nach dem 68010).

    Noch eins,die Sache mit den Librarybases:

    Ich hab mir gedacht,wenn schon FD-Files,dann richtig. Im FD-File
    steht die Librarybase drin. Das Programm schaut nach,zu welcher Library
    der Aufruf gehört und merkt sich die Base. Wird eine weitere Funktion
    der selben Library vorgefunden,so wird auf den Befehl:
    move.l LIBBASE,a6 verzichtet. Wird allerdings eine anderen Lib verwendet,
    so wird die entsprechende Base vor die Funktion geschrieben,ganz
    Automatisch. Dies bezieht sich auf den AUFRUF DIREKT im SOURCECODE,nicht
    auf die tatsächliche Reihenfolge die nach dem Prgrammstart erfolgt.

    Weil es damit zu keinen Problemen kommen konnte wird nach einem neuen
    LABEL das NICHT LOKAL sondern GLOBAL ist der `Welche Lib ist doch grad
    dran?` Speicher geflusht und generell die Base vorgeschrieben.

    [Lokal = .Label2: und Global = Label1: ]

    Wie das Funktioniert zeigt u.a. einer der Beispielsources.

    Änderungen zum V1.0 Preassembler:

    Einige Funktionen liefern einen Wert in D0 zurück. Wenn Sie diesen
    Rückgabewert nutzen wollen brauchen Sie nur den Namen der Variable
    vor den Aufruf zu schreiben und mit einem Gleichzeichen zu verbinden.

    Beispiel:

    DosBase=OpenLibrary(#DosName,#0)

    daraus wird:

    Move.l ExecBase,a6
    move.l #Dosname,A1
    move.l #0,D0
    jsr OpenLibrary(a6)
    Move.l D0,DosBase

    Eine weitere Neuheit ist die Funktion:

    CHECK xxxx,LABEL

    Check ersetzt folgende typische Codekombination:

    TST.l DOSBASE   < Oder auch XXXXX
    BEQ LABEL

    Möchte Ich testen ob die Doslib geöffnet werden konnte,teste ich die
    Dosbase mit dem TST Befehl. Sollte eine Null in Dosbase sein,so konnte
    die nicht geöffnet werden und es wird zu LABEL verzweigt.
    Konnte Sie geöffnet werden,so wird nach dem Check weiter gemacht.

    Dabei unterteilt sich Check in CheckF(alse) und CheckT(rue).
    CheckF prüft ob die Variable (oder Register) Null ist und verzweigt.
    CheckT prüft ob die V. DOSTRUE ist und verzweigt dann.

    Ab V1.24 kann der Compiler auch leichte Rechungen verstehen.

    + : Plus
    - : Minus
    * : Multiplizieren
    / : Dividieren (ohne Rest)
    ^2: Quadrieren
    -X: Negieren

    ++: +1
    --: -1

    & : Logisch Und-Verknüpfen
    ! : Logisch Oder-Verknüpfen
    ~ : Logisch Exklusiv-Oder-Verknüpfen

    Als Erkennung gilt ein `==` :

    Beispiel: 

    Pro==Pro*12         
    Pro==12/pro 
    Pro==-Pro           ; Das wäre negieren

    Pro==handle&$FF     ; Handle wird mit 256 -und- verknüpft.

    Pro==Pro++          ; Pro wird um einen erhöht

    Es gehen auch Zuweisungen :

    Dasda==1004 ; Die Variable wird erzeugt und enthaelt 1004.

    Alle Unbekannten Variablen werden automatisch erzeugt.

    Eine ganz tolle Zuweisung ist für Taglisten geeignet:

    lea Tagliste,a0     ; in die Position 4 wird LONG der Inhalt
    4(a0)==GuiGadgetInfo; der Variable GuigadgetInfo geschrieben.

    4(a0) wird natürlich nicht erzeugt!

    Ab Version 1.35 kann man indizierte Variablen verwenden:
    
    Diese sind nur für {* Arrays *} zulässig, nicht für über Allocmem()
    geordertern Speicher.

    Name[Index]==Name[Index]+Name[Index]
    
    Es sind aber auch Kombinationen wie:

    Name==Name[Index] oder Name[Index]==Name1+Name2

    usw. usw. 

 !                                                                         !
 ! Achtung : Die zwei einzigen Kombinationen die nicht gehen,sind diese    !
 !           Name[Index]==Name+Name[Index] und Name==Name+Name[Index]      !
 !                                                                         !
    

    Mathematik
    ==========
    
    Syntax: 

    Result=®Term1øTerm2ø...

    wobei ø einer dieser Operatoren sein kann : * / + -

    Term können Zahlen, Variablen oder Funktionen sein.

    Zahlen: Es können Ganzzahlen oder Fließkommazahlen verwendet werden.
            Fließkommazahlen sind einfach lange FFP`s, d.h. maximal 8 Vor-
            und 8-Nachkommastellen. Als Komma kann auch ein "," verwendet
            werden.

      Bsp.: Result=®34+1.246754

    Variablen: Es dürfen keine indizierten Variablen verwendet werden, da
               diese Funktion noch nicht enthalten ist. Sollte eine
               Variable noch keine REAL-Zahl beinhalten, sondern nur eine
               INTEGER-Zahl, dann kann diese Variable trotzdem in dem 
               Rechenterm verwendet werden, wenn die Funktion FLT() benutzt
               wird --> Funktionen.

         Bsp.: X==-10
               Result=®FLT(X)*90+(FLT(X)+5)*I2
               
    Funktionen: Zur Zeit sind folgende Funktionen, welche auch geschachtelt
                werden können, definiert:

                INT()   -> Wandelt Parameter in eine FFP-Ganzzahl um,
                           löschen der Nachkommastellen auf X.00000.

                ABS()   -> Wandelt den Parameter in eine positive Zahl um,
                           keine Wirkung wenn Parameter schon positiv ist.
                           
                FLT()   -> Wandelt Parameter zum Zeitpunkt der Berechnung 
                           in Real um. Der angegebene Parameter wird nicht
                           verändert!

                NEG()   -> Negiert den Parameter

                LN()    -> Logarithmus Naturalis

                LOG()   -> Logarithmus zur Basis 10

                EXP()   -> e hoch x -> potenz=®EXP(X)

                SIN()   -> Sinus   im Bogenmaß
                COS()   -> Cosinus im Bogenmaß
                TAN()   -> Tangens im Bogenmaß

                SIN°()  -> Sinus   in Grad
                COS°()  -> Cosinus in Grad
                TAN°()  -> Tangens in Grad

                ASIN()  -> ArcusSinus   im Bogenmaß
                ACOS()  -> ArcusCosinus im Bogenmaß
                ATAN()  -> ArcusTangens im Bogenmaß

                SINH()  -> Sinus hyperbolicus   im Bogenmaß
                COSH()  -> CoSinus hyperbolicus im Bogenmaß
                TANH()  -> Tangens hyperbolicus im Bogenmaß
                
                SQR()   -> 2.Wurzel aus X

     *** Alle Funktionen müßen in GROßBUCHSTABEN geschrieben werden. ***

    BDF:

    Benutzerdefinierte Funktionen sind, einfache Prozeduren, die in einem 
    Term vorkommen dürfen. Der Parameter wird in der lokalen Variable X
    übergeben. Ihre Prozedur muß also mit dem Wert X arbeiten. Das Ergebnis
    muß in d0 zurückgegeben werden.

    Beispiel:

    Hoch2[]:
        X=®X*X
        move.l X,d0
        RTS

    Integral[A,B]:
        I=Spflt(0)
        For X=A to B
           Y=®ABS(5*Hoch2(Hoch2(X))+3/4*X*Hoch2(X)-Hoch2(X)+X+1/89)
           I=®I+Y
        Next X
        I=®I/(B-A)
        move.l i,d0
        RTS

    Dieses Beispiel zeigt eine Berechnung eines numerischen Integrals in
    den Grenzen A und B der Funktion f(x)=5x^4+3/4x^3-X^2+X+1/89.
    Kleiner Hacken: X ist Integer und müßte überall mit FLT(X) eingesetzt
                    sein und X ist zu grob um einen genauen Wert zuerhalten.

    Klammern:   Klammern können beliebig verwendet werden. 
    
                ! Klammer- vor Punkt- vor Strich-Rechnung !

    Die Mathematikfunktionen sind eigenständig. Ergebnisse dürfen
    ohne Umwandlung mittels SPFIX() nicht außerhalb der REAL-Berechnungen
    verwendet werden. Also einfach mit herkömlichen Funktionen mischen.

    Ein korrektes BEISPIEL: 

          Result=®irgendwas...
          If Spfix(Result)>#2 --> irgendwohin
                        
    Sollte SpFix() weggelassen werden, kann zwar nicht alles mögliche passieren,
    aber der Vergleich stimmt zu 99.9% nicht ( der Rest ist Zufall ).

    Zwei REALZahlen werden also mit SpCmp() verglichen, es gelten die 
    üblichen Ergebniswerte wie sie in den Autodocs zu finden sind.



    While-Schleifen
    ===============

    Whileschleifen sind ab der Version 1.38 möglich. Sie haben den 
    gleichen Aufbau wie IF-Anweisungen. Der einzige Unterschied ist,
    daß vor der Auswertung der Parameter ein lokales Label geschrieben
    wird, zu dem nach Beendigung des Blocks zurückgesprungen wird.
    logischerweise sind nur Blöcke sinnvoll, obwohl auch Sprünge angegeben
    werden können.

    Syntax:

    While (Vergleich) {  ( Funktionsblock)  }
    
    Beispiel:

    While (X=matheformel(X))<Y {
                                 X=X+1
                               }

    Als Spezialfall kann man auch ne Leerzeile als Funktionsblock angeben:

    While Rnd(100)>80 {
;                       Leerer Funktionsblock
                      }

    Syntax: While Funktion()=#0 and/or Irgendwas() { ... }

    Die Vergleiche und Verknüpfungen gelten wie in der IF-Anweisung.


    IF-Anweisungen
    ==============

    Ab der Version V1.23 ist die Funktion IF verfügbar:

    Syntax:     IF AAA_BBB --> Sprungmarke ELSE Sprungmarke2
                IF AAA_BBB --» Sprungmarke
    
    --> Sprungbereich 16-Bit ( Word )
    --» Sprungbereich 32-Bit ( Long )

    fuer `_` kann stehen:

    = für AAA   GLEICH    BBB

    # für AAA UNgleich    BBB    

    > für AAA Größer als  BBB

    < für AAA Kleiner als BBB

    wobei AAA[BBB] eine Variable,eine Konstante(Zahl) oder ein Zeiger 
    auf eine Speicherstelle sein kann. Zur Errinnerung:

    Konstanten werden in Assemblern mit AAA=1234 definiert und müßen so
    wie Zeiger ein `#` vor sich in der Anweisung haben.

    Beispiel:

    Speicher=Allocmem(#10000,#MFM_not)
    IF Speicher=#0 --> Hat_nicht_geklappt_label
    IF Speicher>#$F0000000 --> FASTRAM  ; oder sonstwas
     
    Beispiel:

        ...
    in: Addq.l #1,D0
        if d0>#100 --> geschafft_label ; D0 ist größer als 100
        If D0##90 --> ungleich90_label ; D0 ist nicht 90

    Wie man hier schön sehen kann,ist es egal ob nach dem UNGLEICH
    in Doppelkreuz folgt.

    Beispiel:

        clr.l d0
    .in:Addq.l #1,d0
        If D0##90 --> .in Else .ende    ; So gehts auch.
    .ende:RTS

    Sicherlich kann man noch mehr Verknüpfungen einbauen z.B.: >=,<> usw.
    aber kann sie aber auch durch zwei IF kombinieren. Daher hab Ich mir
    die Mühe nicht gemacht. Falls daran Interesse besteht,werde ich sie 
    einbauen.

    Ab Version 1.26 kann statt einer Sprunganweisung auch eine Funktion
    zur Ausführung kommen. Eine Funktion wird mit DO statt --> angegeben

    Beispiel: 

    IF Success=#Ger_ok Do Filehandle=Open("HALLO",#Mode_old)
    
    Inwieweit ein Open an der Stelle sinnvoll ist,sei dahingestellt.

    Ferner kann auch noch eine Sprungmarke angegeben werden,an die
    nach der Funktion gesprungen werden soll.

    If X=Y Do Delay(100):--> .ende

    Der Doppelpunkt zeigt das ende der Funktion an und --> ist der
    Sprungbefehl. Hier wird ein BRA benutzt,also nur innerhalb 64 KB
    verwendbar. Das wird aber der Assembler als Fehler rauswerfen,falls
    der 64KB Adressbereich verlassen wird.

    Ab Version 1.27 kann statt einer Sprunganweisung auch eine Mathefunktion
    zur Ausführung kommen. Eine Mathefunktion wird mit CALC statt --> 
    angegeben.

    Beispiel: 

    IF Success=#Ger_ok Calc Zehn=Zehn+1:---> LABEL
    
  ! !!! ACHTUNG: Bei If-Anweisungen reicht 1 "=" !!!

  ! Ab Version V1.27 ist auch eine Multi Funktion ,d.h. man kann mehrere
  ! Anweisung in eine Zeile der If-Anweisung packen.

    Beispiel:

    If X=Y do Delay(100):Calc Spe=Psa+psy:Do Open("FXY",#Mode_old):---> .free

    Die entsprechenden kennzeichen DO , CALC und ---> muessen immer dabei
    stehen !

    Siehe IF-TEST.p source!

    Ab Version 1.32 kann auch ein Block von Anweisungen hinter dem If
    ausgeführt werden.

    If A=#1 { IF B=#1 do DisplayBeep()
              If B=#2 do CloseScreen(screen)
              C==C+1
              FH=Open(File,mode)
              IF FH=#False do Close(FH):do Displaybeep() }

    Damit lassen sich u.a. UND und ODER Verknüpfungen bauen , Mehrfach-
    anweisungen nach If zusammensetzen und vieles mehr machen.

    Ab Version 1.33 können Blöcke auch geschachtelt werden.

        If I=#1 { OH=Output()
                  IH=Input() }
        If I=#2 { If J=#1 { Displaybeep(Screen)
                            IH=Input() }
                  If J=#2 { Open(Screen,dummy)
                            IH=Output() } }


    Ab Version 1.37 können auch Funktionen als IF-Parameter verwendet
    werden:

        IF Calculation(Par1,Par2,...)=#0 { Displaybeep(Screen) }

        If Open("name",#Modus)##0 {
                                    move.l d0,Filehandle
                                               ...
                                  }    
    Es sollten hier bei nur Funktionen verwendet werden die auch einen
    Rückgabewert haben. Alle Prozeduren müßen in D0 zurückgeben.
    Wer sichergehen will , daß seine Funktionen auch korrekt arbeiten,
    sollte {* Return *} verwenden.
    Um zu verhindern, daß Rückgabeparameter zu Verwirrungen führen kann der
    Funktionsterm auch geklammert werden.

    If (Filehandle=Open(..,..))##0 .....
                ^^^^^
    Dieses "=" würde den Compiler dazu bringen, die ganze Abfrage als Frage
    nach der Gleichheit von Filehandle und Rückgabewert von Open zu erkennen.
    
    Warum nicht nur " If Open(...,...)##0 ---> ... " ? 
    
    Weil man dann soetwas nicht machen könnte:

    If (FH=Open(Filename,#Mode_old))##0 { Read(FH,Puffer,10000)
                                          Close(FH)
                                          [...]                  }

    !!! `and` und `or` immer KLEIN schreiben !!!

        IF A=B or B=C --> ziel 

    Die Oder-Verknüpfung funktioniert NICHT für Blöcke!

        IF A=B and B=C --> Ziel

    Die Und-Verknüpfung funktioniert immer.

    Es können auch Kombinationen von Und/Oder auftreten. Einige Beispiele:

    Bei den Kombinationen wird die allgemeine Konvention über 

!                        and VOR or GEBROCHEN !!!!                          !

    Preass:                                  Klammern

    If A=B and C=D or D=A --> Exit           A=B and ( C=D or D=A ) 
    IF A=E or B=C and D=C and C=A -->        A=E or ( B=C=D=A )
    IF A=B or B=C or D=A and T=#1 -->        ( A=B or B=C or D=A ) and T=#1

    Man kann auch abkürzen!

    IF A=B or =C and =D -->                  ( A=B or A=C ) and A=D   

    Ab Version 1.39 kann auch die Syntax:

                            If A=B returnvar -1
    
    benutzt werden. Man kann also per Vergleich aus einer SubRoutine
    zurückkehren und einen Rückgabewert setzen, wobei dieser auch eine Variable
    sein kann. 

    Beispiel:

    Proc[]:
        For I=1 TO B
                If I=Fiktiverwert ReturnVar I
        Next I
        {* Return 0*}
        
    Die gleiche Funktion gibt`s auch ohne Rückgabewert, da lautet die 
    Anweisung dann:

    If A=B ReturnNoVar


    Strukturen Lesen&Schreiben
    ==========================

    *NEU* in Version 1.38:

           Schreiben                 Lesen


    (X,Y,Z,..)->Struktur   und  Struktur->(X,Y,Z,..)

    Diese Anweisungen können ganze Gruppen von Variablen lesen und
    schreiben. Dies ist z.B. beim Auslesen eines selbstgebauten Arrays
    sehr gut einsetzbar:

    Beispiel:

    Long=4
    Eintrag_laenge=3*Long
    OH=Output()
    If (MB=Allocmem(#Eintrag_laenge*1000,#MEMF_FAST!MEMF_Clear))##0 {
        InHandle=Input()
        Zeiger==MB
        While Nochzeichen(InHandle)##0 {
                                         X=ReadVariable(IH)
                                         Y=ReadVariable(IH)
                                         Z=ReadVariable(IH)
                                         (X,Y,Z)->Zeiger
                                         Eintraege==Eintrage++
                                       }
        Freemem(MB,#Eintrag_laenge*1000)
                                                                    }
    Convertzahl(Eintraege,OH)
    Write(OH," Einträge gelesen.\n",?)
    
    Beispiel Ende.
    
    In Assembler wird dies so ausgedrückt:

    (X,Y,Z)->zeiger     | zeiger->(X,Y,Z)
    --------------------+------------------
    Move.l Zeiger,a0    | Move.l Zeiger,a0
    Move.l X,(a0)+      | Move.l (a0)+,X
    Move.l Y,(a0)+      | Move.l (a0)+,Y
    Move.l Z,(a0)+      | Move.l (a0)+,Z
    Move.l a0,Zeiger    | Move.l a0,Zeiger
    
    Es könnte auch so ein Ausdruck genommen werden:

    (#Buffer,#Buffer+4,#Buffer+8)->Zeiger

    Da immer LONG verwendet wird, sollten keine WORT Strukturen geschrieben 
    oder gelesen werden!

    Strukturen schreiben                *NEU* in Version 1.40
    ====================                

    Systemstrukturen lassen sich nun ja ganz leicht leicht erzeugen.

    {* Structure Test(),A(LONG),B(WORD),C(STRUCT NewWindow)*}
    
    Wenn Sie nun solche eine Struktur beschreiben wollen, so hätten Sie
    lange Ketten von LEA Befehlen schreiben müssen. Preass bietet nun an,
    dies für Sie zu erledigen. Dabei achtet Preass auch noch auf die Länge
    des Eintrags der Struktur, sofern bekannt, und trägt u.a. auch
    Konstanten ein.

    {* Structure Krallen(),Links(STRUCT Kralle),Rechts(STRUCT Kralle)*}
    {* Structure Kralle(),Zehen(STRUCT Zehen),Glieder(STRUCT Glieder)*}
    {* Structure Zehen(),Zehe1(LONG),Zehe2(LONG),Zehe3(LONG)*}

    Zehentype=>Krallen.links=>Kralle.Zehen=>Zehen.Zehe1

    Sie können Variablen, Zahlen in Binär und Dezimal und Konstanten angeben.
    Hex-Zahlen müssen ein "#" als Erkennung tragen, damit man mit "$" Adressen
    angeben kann. Konstanten müssen mit {* CONST *} definiert worden sein!
 
    Struktur Krallen
    Links Struktur Kralle
        Struktur Zehen
                 Zehe1
                 Zehe2
                 zehe3
        Struktur Glieder
                 ....
    Rechts Struktur Kralle
        Struktur Zehen
                 Zehe1
                 Zehe2
                 zehe3
        Struktur Glieder
                 ....

   Wenn Sie eine Struktur von Type 
    
             {* Structure Krallen(),Links(APTR),Rechts(APTR)*}

    haben und Sie wollen in die Struktur Links etwas eintragen, dann
    können Sie dies so machen:

    Zehentype=>Krallen.links=>(Kralle.Zehen)=>Zehen.Zehe1

    Die Klammern geben an, welches Element bereits hinter einem Strukturzeiger
    steht. Die Kammer löst den Sprung hinter dem Zeiger "Krallen.links" aus.
    Alles weitere funktioniert normal:

    Struktur Krallen
    Links              --->     Links Struktur Zehen
    Rechts ...                                 Zehe1
                                               Zehe2
                                               Zehe3
                                      Struktur Glieder
                                               ....


    Strukturen auslesen
    ===================

    Zur Erleichterung ist eine Funktion eingebaut worden , die es
    ermöglicht , leicht an etwaige Parameter von Strukturen zu kommen.
    Konkret heisst das,wenn z.b. der RASTPORT des Intuitionsscreens
    erfasst werden muss,gibt man nur noch ein:

    Screen=OpenNewScreenTaglist(#0,#NewScreentaglist)
    checkf screen,.error
    Rastport=84(Screen)
    ViewPort=44(Screen)

    und das wars dann schon !

    Das ergibt: 

    move.l Screen,a0
    lea 84(a0),a0
    move.l a0,RastPort

    Damit ist der Screen geöffnet und Rastport und Viewport bestimmt.
 
    Von dieser Methode gibts noch eine Variante:

    Rastport=.x84(Screen)

    Move.l Screen,a0
    move.x 84(a0),Rastport
            
    Was ist hier der Unterschied? Das .x machts aus. Das heißt hierbei 
    wird der Inhalt der Adresse Screen+84 in die Variable Rastport
    geschrieben,und zwar mit der Länge .x (.l,.w,.b).Bei

    Rastport=84(Screen) wird die Adresse Screen+84 in Rastport gesch-
    rieben.



                               Preass & C :
                               ============

    Die beiden vorangegangen Befehle sind nicht einfach nur so dabei.
    Wenn man z.b. die Offsets für die häufig gebrauchten Systemstrukturen
    in einer Datei included, dann kann man nützliche Befehle aus C 
    leicht übersetzen.

    Ich definiere nun mal den WindowUserport:

    userport = 86

    WindowUserPort=.lUserport(Window)

    Das entspricht dem folgenden Befehl in C :

    WindowUserport = Window->UserPort

    C hat dabei den Vorteil ,daß sich der User nicht um die Länge kümmern
    muß , im Gegensatz zu Preass .

    Ich überlege mir mal ob ich eine Includedatei generieren sollte die
    etwa so aussieht:

        ; Preass Userkonstanten

        Xoffset[BYTE]=80
        Userport[LONG]=86
        Rastport[LONG]=50
        ....

    Die Liste könnte der User dann selbst entwerfen und erweitern.
    
    Praktisch wäre das um C Programm in Preass zu übersetzen, aber das
    bringt einen natürlich immer näher an C ran .... :-(

    Mal sehen :-)

    Zum Abschluß möchte ich einen Befehl nicht verschweigen, den ich zwar
    nicht benutzte, weil es einen echten Hack darstellt, aber der dem 
    einen oder anderen sicherlich helfen wird:

    PRINT HANDLE,`TEXT`

    Das Handle muss geöffnet sein und es muss ein DOShandle sein, kein
    Intuitionhandle(windowrastport oder so etwas).

    Handle=Output()
    PRINT Handle,`Ich gebe jetzt was auf der STANDART I/O aus`,$0a,$0d
    ...
    
    Dies wäre z.b. ein gültiges Handle. Oder ein CON-Window,ein File usw.
    Der Source wird nach dem Print Befehl etwas wüst aussehen,stellt
    aber eine reguläre Methode dar, sie läuft mit Caches , Bursts bis
    hin zum 68030. Der Text wird praktisch nach dem JSR PRINT abgelegt und 
    am Schluss wird ein File Includet,was den eigentlichen Print Source 
    ausmacht. Dieser muss als PRINT.i im Preass-Verzeichniss ihrer INCDIR
    liegen. Print.i kann auch angepasst werden,der Code ist sehr einfach,
    wer sich z.b. ein Print für Intuitionwindows schreiben will , kann
    seinen Code dort mit einbringen!

                           Also dann bis demnext , euer Cyborg.

    Noch etwas zum Schluss, das Update-Info :

    V1.38  --> V1.39

    ReturnVar und ReturnNoVar

    Zeigeroptimierung von MOVE.L # auf LEA.

    Mathematik macht das Leben schwer.

    V1.37  --> V1.38

    While-Schleife eingeführt

    BugFix: Abgleich der Parameter mit den Argumenten einer Funktion 
            jetzt "immer" korrekt: 

            vorher war Zeiger=Weiter, weil beide auf `ER` enden.

    V1.36  --> V1.37

    IF (Funktion)=X or/and .... eingeführt.

    If Delta/2*4+Rechts>Links ..... {[(Delta/2)*4]+Rechts}>Links
    
    Es können beliebig viele Operationen verwendet werden. Wie aus dem
    Beispiel ersichtlich ist, gibts KEINE Klammerung oder Punkt-vor-
    Strich-Regel.

    Fehler in der DO Funktion der IF-Anweisungen behoben.Es können nun
    wieder Blöcke und DO Funktionen gemischt werden!

