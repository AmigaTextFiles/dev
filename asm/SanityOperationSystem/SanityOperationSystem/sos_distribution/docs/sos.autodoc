-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                   Autodocs


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



TABLE OF CONTENTS

AGAC.library/AGABEGIN
AGAC.library/AGADDFSTOP
AGAC.library/AGAEND
AGAC.library/AGAFETCH
AGAC.library/AGAMODIFY
AGAC.library/CopyAgaCop32
AGAC.library/CopyAgaCopper
AGAC.library/CopyAgaHard
AGAC.library/DoAgaFade
AGAC.library/InitAgaCop32
AGAC.library/InitAgaCopper
AGAC.library/InitAgaFade
DBUG.library/CheckDBUG
DBUG.library/LoadDebugger
DBUG.library/SetPSS
dbug.library/StripColor0
SINE.library/GenSinusTags
sos.library/AllocBlock
sos.library/AllocMem
sos.library/AltKick
sos.library/AltMemory
sos.library/BailOut
sos.library/CauseTimer
sos.library/CheckForFile
sos.library/CheckRelease
sos.library/Close
sos.library/CloseScreen
sos.library/ClrDefault
sos.library/ClrInt
sos.library/DoubleBuffer
sos.library/Error
sos.library/Fade
sos.library/FastRand
sos.library/FileLenght
sos.library/FirstRand
sos.library/FreeAll
sos.library/FreeMem
sos.library/GetFilePos
sos.library/GetKey
sos.library/GetPISS
sos.library/InbitDiskPrefech
sos.library/InitAltMemory
sos.library/INITSOS
sos.library/LastRand
sos.library/Load
sos.library/LoadDecrunch
sos.library/LoadSeg
sos.library/LoadSegMem
sos.library/MemType
sos.library/ModDefault
sos.library/MotorOff
sos.library/Open
sos.library/OpenLibrary
sos.library/OpenScreen
sos.library/PPDecrunch
sos.library/PrefetchDisk
sos.library/PutScreen
sos.library/Randomize
sos.library/Read
sos.library/ReLoad
sos.library/RemoveRamDisk
sos.library/ResetRand
sos.library/Save
sos.library/ScanTagList
sos.library/Seek
sos.library/SetCopperAdr
sos.library/SetCopperCol
sos.library/SetDefault
sos.library/SetInt
sos.library/SetIntDev
sos.library/SetIntFast
sos.library/SoundOff
sos.library/StartIt
sos.library/Trap13
sos.library/Trap14
sos.library/UnfinishedIrq
sos.library/WaitTimer
sosmacros.i/--background--
sosmacros.i/CLRFAST
sosmacros.i/ENVDO
sosmacros.i/ENVEND
sosmacros.i/ENVINIT
sosmacros.i/ENVWAIT
sosmacros.i/GENLOCK
sosmacros.i/GENSINUS
sosmacros.i/OPENLIB
sosmacros.i/SEC-diverse-
sosmacros.i/SETCADR
sosmacros.i/SETCCOL
sosmacros.i/SETCSPR
sosmacros.i/SETINT
TEXT.library/PrintF
TEXT.library/SetOutput
AGAC.library/AGAMODIFY
***************************************************************************** 
AGAC.library/AGABEGIN                                   AGAC.library/AGABEGIN
***************************************************************************** 

   NAME
       AGABEGIN -- Begin AGA adeption

   SYNOPSIS
       AGABEGIN    (MACRO)

   FUNCTION
       AGABEBIN, AGAEND and AGAMODIFY should be used to 
       automatically adept an OCS/ECS copperlist for advanced AGA
       fetchmodes.

       Example:

             AGABEGIN
             AGAMODIFY  Cop094,#$d8-$20
             AGAMODIFY  Cop1fc,#$3
             AGAEND

       The AGABEGIN checks if AGA is enabled. If it is not, it skips to
       AGAEND. It it is, all commands between AGABEGIN and AGAEND are
       executed.
       The above example would upgrade a standard copperlist.
       Special commands for easiert update of important registers are
       available.
       Since AGABEGIN and AGAEND use local labels, you must not use
       global labels inside the block, and you must set at least
       one global label between two blocks.

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

***************************************************************************** 
AGAC.library/AGADDFSTOP                               AGAC.library/AGADDFSTOP
***************************************************************************** 

   NAME
       AGADDFSTOP -- Modify ddfstop-register

   SYNOPSIS
       AGADDFSTOP Label,#Value   (MACRO)

   FUNCTION
       This macro will subtract the value from the copperlist-instruction
       This is usefull for the DDFSTOP-Register, since you usually 
       must subtract $20 from it when switching on the Fetchmode.

   INPUTS
       Label  - Label of the copperlist-instruction for Fetchmode
       Value  - Value to subtract, including # for immediate values.

   EXAMPLE
       a slightly shorter version of the example in AGABEGIN
       
             AGABEGIN
             AGAFETCH   Cop1fc
             AGADDFSTOP Cop094,#$20
             AGAEND

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

***************************************************************************** 
AGAC.library/AGAEND                                       AGAC.library/AGAEND
***************************************************************************** 

   NAME
       AGAEND -- End AGA adeption block

   SYNOPSIS
       AGAEND   (MACRO)

   FUNCTION
       Marks the end of an AGA adeption block

   EXAMPLE
       see AGABEGIN

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

***************************************************************************** 
AGAC.library/AGAFETCH                                   AGAC.library/AGAFETCH
***************************************************************************** 

   NAME
       AGAFETCH -- Modify fetchmode-register

   SYNOPSIS
       AGAFETCH Label   (MACRO)

   FUNCTION
       This macro will set the maximum fetchmode

   INPUTS
       Label  - Label of the copperlist-instruction for Fetchmode

   EXAMPLE
       see AGADDFSTOP

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

***************************************************************************** 
AGAC.library/AGAMODIFY                                 AGAC.library/AGAMODIFY
***************************************************************************** 

   NAME
       AGAMODIFY -- Modify register in copperlist

   SYNOPSIS
       AGAMODIFY Label,#Value    (MACRO)

   FUNCTION
       The Label will be interpreted as the label before a copperlist
       instruction. The Value will be copied in the value-field of
       the copperlist-instruction, i.e. Label+2.

   INPUTS
       Label  - Label of the copperlist-instruction
       Value  - Value to copy, including # for immediate values.

   EXAMPLE
       see AGABEGIN

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

***************************************************************************** 
AGAC.library/CopyAgaCop32                           AGAC.library/CopyAgaCop32
***************************************************************************** 

   NAME
       CopyAgaCop32 -- Copy 32 Colors in copperlist.

   SYNOPSIS
       CopyAgaCop32(Colors,CopCol,Start,End)
                     a0     a1     d0    d1

       void CopyAgaCopper(struct AGAColors *, UWORD *,UWORD,UWORD)

   FUNCTION
       Copy the specified Range of registers from the AGAColors structure
       in the copperlist.

   INPUTS
       Colors     - AGAColors Colors to set
       CopCol     - Pointer to part of copperlist to modify
       Start      - First color register to effect
       End        - Last color register to effect

   BUGS

   SEE ALSO
       InitAgaCop32().

***************************************************************************** 
AGAC.library/CopyAgaCopper                         AGAC.library/CopyAgaCopper
***************************************************************************** 

   NAME
       CopyAgaCopper -- Copy Colors in copperlist.

   SYNOPSIS
       CopyAgaCopper(Colors,CopCol,Start,End)
                     a0     a1     d0    d1

       void CopyAgaCopper(struct AGAColors *, UWORD *,UWORD,UWORD)

   FUNCTION
       Copy the specified Range of registers from the AGAColors structure
       in the copperlist.

   INPUTS
       Colors     - AGAColors Colors to set
       CopCol     - Pointer to part of copperlist to modify
       Start      - First color register to effect
       End        - Last color register to effect

   BUGS

   SEE ALSO
       InitAgaCopper().

***************************************************************************** 
AGAC.library/CopyAgaHard                             AGAC.library/CopyAgaHard
***************************************************************************** 

   NAME
       CopyAgaHard -- Copy AGA Colors directly in Hardware.

   SYNOPSIS
       CopyAgaHard(Colors,Start,End)
                   a0     d0    d1

       void CopyAgaHard(struct AGAColors *,UWORD,UWORD)

   FUNCTION
       Copy the spezified range of color registers directly in 
       the Hardware.

   INPUTS
       Colors     - AGAColors Colors to set
       Start      - First color register to effect
       End        - Last color register to effect

   BUGS
       not implemented --- illegal 

   SEE ALSO

***************************************************************************** 
AGAC.library/DoAgaFade                                 AGAC.library/DoAgaFade
***************************************************************************** 

   NAME
       DoAgaFade -- Perform fade step

   SYNOPSIS
       DoAgaFade(Buffer,Target,Start,End)
                 a0     a1     d0    d1

       void DoAgaFade(struct AGAFade *,struct AGAColors *,int,int)

   FUNCTION
       Perform one step of fading.
       It is you job to copy the faded colors somehow from the 
       Target buffer into the hardware.
       The Target buffer must not be initialised and may be changed
       between subsequent calls of DoAgaFade(). The Buffer holds the
       complete fading state.
       You must take care to call DoAgaFade() exactly as often, as
       specified by InitAgaFade().

   INPUTS
       Buffer     - Buffer created with InitAgaFade
       Target     - AGAColors Colors to fade
       Start      - Start color register to effect
       End        - Last color register to effect

   BUGS

   SEE ALSO
       CopyAgaCopper(), CopyAgaHard().

***************************************************************************** 
AGAC.library/InitAgaCop32                           AGAC.library/InitAgaCop32
***************************************************************************** 

   NAME
       InitAgaCop32 -- Initialise 32 AGA-Colors Copperlist

   SYNOPSIS
       InitAgaCop32(CopCol)
                     a0

       voit InitAgaCop32(UWORD *);

   FUNCTION
       Initialise a peace of copperlist that sets a complete
       set of 32 AGA color registers, including all bank
       switching and stuff.

       If AGA is not available, construct a OCS/ECS copperlist
       of the same size

       This function is exspecially usefull to implement
       AGA-Sensitive Fades for ECS-Screens.

   INPUTS
       CopCol     - Pointer to uninitialised part of copperlist

   BUGS

   SEE ALSO
       CopyAgaCop32().

***************************************************************************** 
AGAC.library/InitAgaCopper                         AGAC.library/InitAgaCopper
***************************************************************************** 

   NAME
       InitAgaCopper -- Initialise AGA-Colors Copperlist

   SYNOPSIS
       InitAgaCopper(CopCol)
                     a0

       voit InitAgaCopper(UWORD *);

   FUNCTION
       Initialise a peace of copperlist that sets a complete
       set of 256 AGA color registers, including all bank
       switching and stuff.

   INPUTS
       CopCol     - Pointer to uninitialised part of copperlist

   BUGS

   SEE ALSO
       CopyAgaCopper().

***************************************************************************** 
AGAC.library/InitAgaFade                             AGAC.library/InitAgaFade
***************************************************************************** 

   NAME
       InitAgaFade -- Initialise fade-buffer.

   SYNOPSIS
       InitAgaFade(Source,Dest,Buffer,Count)
                   a0     a1   a2     d0

       void InitAgaFade(struct AGAColors *,struct AGAColors *,struct AGAFade 
*,UWORD,UWORD,UWORD)

   FUNCTION
       Prepare fading from one set of colors to another one.

   INPUTS
       Source     - AGAColors Colors of first frame
       Dest       - AGAColors Colors of last frame
       Buffer     - Set up some structs here
       Count      - number of frames

   BUGS

   SEE ALSO
       DoAgaFade().

***************************************************************************** 
DBUG.library/CheckDBUG                                 DBUG.library/CheckDBUG
***************************************************************************** 

   NAME
       CheckDBUG -- Test if debugger should be activated.

   SYNOPSIS
       CheckDBUG()

       void CheckDBUG(void);

   FUNCTION
       Checks if the hotkey for the debugger was pressed.
       If it is pressed, the small system debugger is called.

       You need not supply the library base.

   BUGS

***************************************************************************** 
DBUG.library/LoadDebugger                           DBUG.library/LoadDebugger
***************************************************************************** 

   NAME
       LoadDebugger -- Load and start the MOD3 monitor.

   SYNOPSIS
       LoadDebugger(PSS)
                    a0

       void LoadDebugger(struct ProcessorStatus *);

   FUNCTION
       Load and start the MOD3 debugger and pass the processor 
       register structure.

   INPUTS
       PSS   - Zeiger auf eine Processor Save Structur

   BUGS

***************************************************************************** 
DBUG.library/SetPSS                                       DBUG.library/SetPSS
***************************************************************************** 

   NAME
       SetPSS -- Create ProcessorSave structure.

   SYNOPSIS
       SetPSS(PSS,Stack)
              a0  a1

       void SetPSS(struct ProcessorSave,APTR);

   FUNCTION
       This routine initialises a ProcessorSave structure.
       
       When the MOD3 debugger is called with hotkey, it is not
       possible to find the real register values for d0-d7/a0-a6.
       therefore these registers are set zero or filled with
       values that have a special meaning in the system. 
       These values are documented in the main documentation.

       This function does the neccessary setup.

   INPUTS
       PSS       - pointer to an empty PSS
       Stack     - Pointer to stack, needed to find a good value for PC.

   BUGS

   SEE ALSO
       LoadDebugger(), CheckDBUG().

***************************************************************************** 
dbug.library/StripColor0                             dbug.library/StripColor0
***************************************************************************** 

   NAME
       StripColor0 -- remove all CMOVE x,Color0 from CList.

   SYNOPSIS
       StripColor0(CList)
                   a0

       void StripColor0(UWORD *);

   FUNCTION
       Replace all CMOVE x,$0180 by CMOVE x,$01fe (nop).
       The modified copperlist will leave the background color
       unchanged. This simplifies debugging with DEBCOL.
       This is especially usefull when working with generated 
       copperlists as done in the Inyerface/Broken Promisses system.
       The copperlist must end with $fffffffe, even if you exit with
       a copperjump. In this case you must simply add the $fffffffe.
       Copperjumps are not processed.

   INPUTS
       CList  - Pointer to copperlist

   BUGS

   SEE ALSO

***************************************************************************** 
SINE.library/GenSinusTags                           SINE.library/GenSinusTags
***************************************************************************** 

   NAME
       GenSinusTags -- Create sinelist from tags.

   SYNOPSIS
       GenSinusTags (Taglist)

   FUNCTION
       Create a sinelist in memory. This is done by interpolating
       a build-in sine list of 256 Words length.

       The accuracy is an error of 0.5 for a range from $7fff to -$8000.
       This should be sufficiant for all your needs. Using the 
       sinelist generator will save you some memory and is more
       comfortable then working with extern sinelist generators.

   INPUTS
       Taglist  - A TagItemArray with the following tags:

       ST_ADRESS   - Pointer to free memory
       ST_FORMAT   - SINE_WORD or SINE_BYTE
       ST_RANGEPOT - Half amplitude of the sinewave as power of 2
                     See notes.
       ST_SIZEPOT  - Number of elements for each sine quarter as power of 2
                     See notes.
       ST_QUARTERS - number of sine quarters (4 for full sinus, 5 for 
                     combined sinus/cosinus table.)                          
  
       ST_START    - Number of first quarters.
                     0 sinus
                     1 cosinus
                     2 -sinus
                     3 -cosinus

   NOTES
       Sizes are encoded like this.

       Value    Elemtens per quarter       Minimum  Maximum
       -----------------------------------------------------
       2        4                          -3       3
       4        16                         -15      15
       8        256                        -255     255
       9        512                        -511     511
       10       1024                       -1023    1023 
       11       2048                       -2047    2047 
       12       4096                       -4095    4095 
       13       8192                       -8191    8191 
       14       16384                      -15383   15383
       15       32768                      -32767   32767

   BUGS

***************************************************************************** 
sos.library/AllocBlock                                 sos.library/AllocBlock
***************************************************************************** 

   NAME
       AllocBlock -- Allocate with increased alignment restrictions.

   SYNOPSIS
       Adress = AllocBlock (Size,Attributes)
       d0                   d0   d1

       APTR AllocBlock(ULONG,ULONG);

   FUNCTION
       Allocate a block of memory just as AllocMem does, but
       ensure that there is no 64k-boundary in the block of memory.
       If the block you requested is longer then 64k, it is
       guaranteed to END at a 64k-boundary.

       This allowed you special optimisations, especially when
       you program the blitter or complex copperlists.

       If you specify a size of 64k, you will get a block that 
       starts and ends at a 64k-boundary. If you specify less,
       the remaining part of the memory may be used for additional
       AllocMem(), AllocBlock() or similar calls. You should allocate
       64k-block before you allocate anything else to avoid memory
       fragmentation. This will happen especially if you allocate
       a smaller block with AllocBlock and then a bigger one.
       The system will try to avoid fragmentation, but you must
       help a bit.

   INPUTS
       Size           - Size of memoryblock in bytes.
                        Will be rounded up to a multiple of 16.
       Attributes     - A value such as MAT_CHIP 

   RESULT
       Adress         - Adress of the allocated block.

   ERRORS
       ERR_NoMemBlock - if there is not enough memory left

   NOTES
       Don't call from interrupt.
       MAT_Clear is not working.

   BUGS

   SEE ALSO
       AllocMem(), TryAlloc(), MemType(), FreeAll()
       OpenScreen(), CloseScreen()

***************************************************************************** 
sos.library/AllocMem                                     sos.library/AllocMem
***************************************************************************** 

   NAME
       AllocMem -- Reserve memory.

   SYNOPSIS
       Adress = AllocMem (Size,Attributes)
       d0                 d0    d1

       APTR AllocMem(ULONG,ULONG);

   FUNCTION
       Try to allocate the specified amount of memory with the
       specified attributes.

   INPUTS
       Size           - Size of memoryblock in bytes.
                        Will be rounded up to a multiple of 16.
       Attributes     - A value such as MAT_CHIP 

   RESULT
       Adress         - Adress of the allocated block.

   ERRORS
       If this function fails the program will be aborted with
       the message ERR_NoMemory. Therefore you don't need to check
       for errors.

   NOTES
       This function may not be called from interrupts.

   BUGS

   SEE ALSO
       AllocBlock(), TryAlloc(), MemType(), FreeAll()
       OpenScreen(), CloseScreen()

***************************************************************************** 
sos.library/AltKick                                       sos.library/AltKick
***************************************************************************** 

   NAME
       AltKick -- Kick the other programm out of the memory

   SYNOPSIS
       AltKick()

       void AltKick(void);

   FUNCTION
       If you use alternating memory mode, you may kick out the
       other program with this call. Be shure that the interrupt
       is well under your controll, or you Kick yourself and the
       complete system into Guru-heaven.

       After this call you have the complete Memory for you!

   BUGS

   SEE ALSO

***************************************************************************** 
sos.library/AltMemory                                   sos.library/AltMemory
***************************************************************************** 

   NAME
       AltMemory -- Reverse allocation order.

   SYNOPSIS
       AltMemory()

       void AltMemory(void);

   FUNCTION
       Reverse order of allocation in alternating memory mode.

   BUGS

   SEE ALSO
       AltKick(), InitAltMemory()

***************************************************************************** 
sos.library/BailOut                                       sos.library/BailOut
***************************************************************************** 

   NAME
       BailOut() -- Eject out of SOS 

   SYNOPSIS
       BailOut()

       void BailOut(void);

   FUNCTION
       DEV variation: eject out to Kickstart.
       RUN variation: do nothing.

   NOTES
       You can use this function to terminate your 
       program when somebody presses a key when running in the
       DEV variation, but not when running in the RUN variation.

       This is usefull for debugging but does not harm when the
       final trackmo is released.

   BUGS

   SEE ALSO
       Error()

***************************************************************************** 
sos.library/CauseTimer                                 sos.library/CauseTimer
***************************************************************************** 

   NAME
       CauseTimer -- set up timer interrupt.

   SYNOPSIS
       CauseTimer(Time,Unit,Code)
                  d0   d1   a0

       void CauseTimer(ULONG,ULONG,void(*)(void));

   FUNCTION
       Set up a timer interrupt that calls the routine specified by
       you when the time has elapsed. Your code may only
       change d0 and a0 and must end with RTS.

   INPUTS
       Time     - Value of time to wait
       Unit     - Unit of time to wait, TI_MILI oder TI_MICRO.
       Code     - Pointer to your interrupt server code.

   NOTES
       Only 2 timers can be used. The routine can be called simultanously
       from the main progremm (diskloader) and from the interrupt routine
       (reply). The timers are shared with CaueseTimer() and are
       allocated dynamically. 

       You may not access the CIA-hardware by yourself (in the replay),
       otherwise you destroy the setup made for these routines and all
       disk access that is build upon them will fail.

   BUGS

   SEE ALSO
       WaitTimer()

***************************************************************************** 
sos.library/CheckForFile                             sos.library/CheckForFile
***************************************************************************** 

   NAME
       CheckForFile -- Check if file is available.

   SYNOPSIS
       Result = CheckForFile(Name)
       d0                    a0
       
       ULONG CheckForFile(char *)

   FUNCTION
       Check if a file is available. This allows you to check
       before opening a file. Open will abort the program if the 
       file is not available. This function will give you a 
       proper return code.

   INPUTS
       Name   - Pointer to filename.

   RESULT
       Result - 0 = file not found
               >0 = file found.

   BUGS

***************************************************************************** 
sos.library/CheckRelease                             sos.library/CheckRelease
***************************************************************************** 

   NAME
       CheckRelease -- Check release of sos.library.

   SYNOPSIS
       CheckRelease(Release,Text)
                    d0      a0

       void CheckRelease(UWORD,char *);

   FUNCTION
       Check if the loaded sos library has the right version.
       If the version is incompatible to the requested version,
       an error message will be displayed and the program will
       be aborted.

       Since SOS versions before 2.0 are completely different,
       this function will fail if you specify a version
       below 2.0 and try to run on a 2.0 or newer system

       This function was of great importance in the early
       SOS designs, but the underlying concepts were never
       implemented.

       You may specify a text that will be written to the debug screen.
       Then this function will wait for a keystroke.

   INPUTS
       Release       - Release number (see NOTES)
       Text       - Optional pointer to banner text.

   ERRORS
       ERR_WrongRelease - This release is not any longer or not yet
                          supportet.

   NOTES
       Release numbers so far

       0 - V0.0  first testversion
       1 - V1.1  early Jesterday-previews
       2 - V1.2  Jesterday Musicdisk
       3 - V1.5  Optimum Fuckup
       4 - V1.7  intermediate version
       5 - V1.8  World of Commodore;Turbo and Genlock, $bc ommited,
                 new meaning for SetDefault()!
       6 -       intermediate version
       7 - V2.0ß New SOS V2.0, OpenLib(), Tags, no more shortmem.
       ********* total reorganisation of the SOS system.
       8 - V2.0  cleaning up, removing useless versions
       8 - V2.1  new DOS-system
       9 - V2.2  diverse bugfixes
       10- V2.3  diverse bugfixes
       10- V2.3  diverse bugfixes
       ...
       13- V2.6  Ready for official release

   NOTE
       This function should (if at all) only be called once at the
       start of the production.

   BUGS

***************************************************************************** 
sos.library/Close                                           sos.library/Close
***************************************************************************** 

   NAME
       Close -- Close a file.

   SYNOPSIS
       Close()

       void Close(void);

   FUNCTION
       Tell the system that you have finished with this file.
       The next Open()- call will not result into an error.

   ERRORS
       ERR_NotOpened - You have not opened a file.

   EXAMPLE
       See Open().

   BUGS

   SEE ALSO
       Load(), Open(), Read(), Seek(), GetFilePos()

***************************************************************************** 
sos.library/CloseScreen                               sos.library/CloseScreen
***************************************************************************** 

   NAME
       CloseScreen() -- Close the small screen

   SYNOPSIS
       CloseScreen()

       void CloseScreen(void);

   FUNCTION
       Close the screen that has been opened with OpenScreen()
       and initalise the default copperlist that does nothing.

   NOTES
       Usually you won't need to close the screen manually.
       You may call this if the screen has already been closed.

   BUGS

   SEE ALSO
       OpenScreen(), ClearScreen(), PutScreen(), CrScreen()

***************************************************************************** 
sos.library/ClrDefault                                 sos.library/ClrDefault
***************************************************************************** 

   NAME
       ClrDefault -- Restore environment and pop it.

   SYNOPSIS
       ClrDefault()

       void ClrDefault(void)

   FUNCTION
       Restore environment as set with SetDefault and pop it from
       the SetDefault()/ClrDefault() stack.

       All memory allocated since the last SetDefault()-call will
       be freed, the old interrupt and Copperlist will be restored.

   BUGS

   SEE ALSO
       SetInt(), ClrInt(), SetDefault()

***************************************************************************** 
sos.library/ClrInt                                         sos.library/ClrInt
***************************************************************************** 

   NAME
       ClrInt -- Switch back to default environment

   SYNOPSIS
       ClrInt()

       void ClrInt(void)

   FUNCTION
       This call switches back to the interrupt and Copperlist environment
       set with the last SetDefault() command. All memory allocated since
       the last SetDefault() will be freed. The environment will
       NOT be popped from the SetDefault()/ClrDefault() stack!

   BUGS

   SEE ALSO
       SetInt(), SetDefault(), ClrDefault()

***************************************************************************** 
sos.library/DoubleBuffer                             sos.library/DoubleBuffer
***************************************************************************** 

   NAME
       DoubleBuffer -- Perform double buffer switching.

   SYNOPSIS
       Result = DoubleBuffer(&Variable,List,Buffers)
       d0                    a0        a1   d0

       APTR *DoubleBuffer(UWORD *,APTR *,ULONG);

   FUNCTION
       Perform simple calculations for double, tiple, quadro,..
       buffering. This is one of the handy functions that make
       life easier.

   INPUTS
       Variable - Pointer to a word variable that is used for counting
                  the current buffer-state. This variable should be
                  initialised with 0.
                  
       List     - Pointer to an array of pointers to your bitmap.
                  You must specify all pointers twice, see example.

       Buffers  - Number of buffers, 2 for double buffering, etc.

   RESULT
       Result   - Pointer to an array of pointers to your bitmap.

   EXAMPLE (not tested)

       ; Typical triple buffering for a dot effect.
       
       TripBuf  lea      (DBuff).w,a0      ; set &Variable
                lea      List,a1           ; set List
                moveq    #3,d0             ; set Buffers
                jsr      _DoubleBuffer(a6) ; SOS-Call
                movem.l  (a0),a0-a2        ; Get pointers
                move.l   a0,(ShowPl).w     ; a0 = plane ready to show
                move.l   a1,(DrawPl).w     ; a1 = plane to draw in
                move.l   a2,(ClrPl).w      ; a2 = plane to clear
                rts

       List     dc.l     Buffer1           ; the buffers
                dc.l     Buffer2
                dc.l     Buffer3
                dc.l     Buffer1           ; and again
                dc.l     Buffer2           
                dc.l     Buffer3

   BUGS

***************************************************************************** 
sos.library/Error                                           sos.library/Error
***************************************************************************** 

   NAME
       Error -- Print error and abort.

   SYNOPSIS
       Error(Number,Par1,Par2)
             d0     d1   d2

       void Error(ULONG,ULONG,char *);

   FUNCTION
       Print an error-message on the small screen.

   INPUTS
       Number   - Error-number (ERR_xxx)
       Par1     - optional first parameter (will be printed in hex)
       Par2     - optional second parameter (will be printed as string)

   NOTES
       This function can be called without the SOSBase in a6.
       This routine will allow the user to call the debugger.
       In such a case the DBUG.library will be loaded and called.

   BUGS

   SEE ALSO
       BailOut()

***************************************************************************** 
sos.library/Fade                                             sos.library/Fade
***************************************************************************** 

   NAME
       Fade -- Simple linear fade function (non aga)

   SYNOPSIS
       Done = Fade(Colors,Buffer,Count,Inc)
       d0          a0     a1     d0    d1

       ULONG Fade(UWORD *,UWORD *,UWORD,ULONG);

   FUNCTION
       Fade from one set of colors to another one. This function
       can be used for a buffer as well as for directly changing
       a copperlist.

       All colors-parts (red, green, blue) will be stepped one
       step towards its destination. If all colors have reached thier
       destination, a value of 0 will be returned.

   INPUTS
       Colors   - Final colors that should be reached
       Buffer   - Current colors, will be changed.
       Count    - Number of colors.
       Inc      - Preincrement for Buffer. Use 0 for normal buffers,
                  2 for use in copperlist. This value will be added
                  to Buffer before each color is referenced.

   RESULT
       Done     - 0 if Buffer[] = Colors[].

   NOTES
       This routine is not fast or good, but very handy.

   BUGS

***************************************************************************** 
sos.library/FastRand                                     sos.library/FastRand
***************************************************************************** 

   NAME
       FastRand -- Get a random number.

   SYNOPSIS
       Number,Seed = FastRand(Seed)
       d0     d6/d7           d6/d7

   FUNCTION
       Quick and bad random number generator. Create a new number
       from the seed and change the seed.
       Don't create the Seed by yourself, use FastRand and FirstRand().

       The random numbers are good enough for spreading stars
       at a screen, but you shouldn't bould a poker-game on them.
       You can use single bit's of the result without danger,
       but if you use all bit's you might be surprised by the
       results.

   INPUTS
       Seed     - Seed as generated by FastRand() and FirstRand().

   RESULT
       Number   - 32 Bit "random" number.
       Seed     - Seed, as used by FastRand() and LastRand().

   EXAMPLE
       Siehe Randomize()

   NOTES
       This function may only be used after calling FirstRand(),
       and you should call LastRand() when you have finished 
       creating random numbers.
       d6 and d7 are used and changed!

   BUGS

   SEE ALSO
       FirstRand(), LastRand(), Randomize(), ResetRand()

***************************************************************************** 
sos.library/FileLenght                                 sos.library/FileLenght
***************************************************************************** 

   NAME
       FileLenght -- Get length of file.

   SYNOPSIS
       Size = FileLenght(Name)
       d0                a0

       ULONG FileLength(char *);

   FUNCTION
       Get the length of the file.

   INPUTS
       Name     - Pointer to filename

   RESULTS
       Size     - Size of the file in bytes.

   ERRORS
       ERR_FileNotFound   - File not found.

   BUGS

***************************************************************************** 
sos.library/FirstRand                                   sos.library/FirstRand
***************************************************************************** 

   NAME
       FirstRand -- Get seed and create random numbers.

   SYNOPSIS
       Zahl,Seed = FirstRand()
       d0   d6/d7

   FUNCTION
       Get the seed and create a first random number.
       You may create random numbers by subsequently calling
       FirstRand(), but it is faster to call FastRand() for all
       following numbers and LastRand() for the last one.

   RESULT
       Zahl     - 32 Bit random number
       Seed     - Seed, as used by FastRand() and LastRand().

   EXAMPLE
       See Randomize()

   NOTES
       d6 and d7 are used and changed!

   BUGS

   SEE ALSO
       FastRand(), LastRand(), Randomize()

***************************************************************************** 
sos.library/FreeAll                                       sos.library/FreeAll
***************************************************************************** 

   NAME
       FreeAll -- Free memory.

   SYNOPSIS
       FreeAll()

       void FreeAll(void)

   FUNCTION
       Free all memory that was allocated since the last SetDefault()-
       call. 

   NOTES
       Don't Call this function from interrupts.

   BUGS

   SEE ALSO
       AllocMem(), AllocBlock(), TryAlloc(), MemType(), FreeAll()
       SetDefault(), ClrDefault(),

***************************************************************************** 
sos.library/FreeMem                                       sos.library/FreeMem
***************************************************************************** 

   NAME
       FreeMem -- Free allocated memory.

   SYNOPSIS
       status=FreeMem(Adress, Size)
       d0             a0      d0

   FUNCTION
       Try to give the memory back to the system.

       Don't use this function unless you know what you are 
       doing. As you can read in the main documentation file,
       SOS has a stack-like memory organisation. Use SetDefault()
       and ClrDefault(). FreeMem woun't really work as you might
       guess.

   INPUTS
       Adress  -.Startadress of memoryblock to free.
       Size    - Size of the block.

   RESULT
       status  - 0 All OK.
                 1 It was neccesary to create a new chunk of memory.
                   The block of memory will lose it's attributes!
                 2 It was neccasary to create a new chunk of memory,
                   but impossible.

   NOTES
       !!! WARNING !!!
       Inproper use of this function will fragmentate memory in a 
       very dangerous way. Do only use it if you know how SOS
       memory managment works. Or even better, don't use it at all.

       Don't call this function from interrupts.

   BUGS

   SEE ALSO
       AllocMem(), AllocBlock(), FreeAll().

***************************************************************************** 
sos.library/GetFilePos                                 sos.library/GetFilePos
***************************************************************************** 

   NAME
       GetFilePos -- Ask current position in file.

   SYNOPSIS
       Position = GetFilePos()
       d0

       ULONG GetFilePos(void);

   FUNCTION
       Ask current position in file. This function in 
       combination with Seek() can simulate the seek-modes
       not supported by SOS.

   RESULT
       Position - Current byte-position in the file

   ERRORS
       ERR_NotOpened - You have not opened a file.

   BUGS

   SEE ALSO
       Load(), Open(), Read(), Close(), Seek()

***************************************************************************** 
sos.library/GetKey                                         sos.library/GetKey
***************************************************************************** 

   NAME
       GetKey -- Get a key.

   SYNOPSIS
       key = GetKey()
       d0

       char GetKey(void);

   FUNCTION
       Get a key from the keyboard and convert it to ASCII (or at
       least something similar...)

   RESULT
       Taste     - ASCII-like code of the pressed key or 0.

   NOTES
       If a key has been released, ASC_KEYUP will be send. You
       can not find out WHAT key has been released, just that a
       key has been released.
       If you want to wait for a keypress, you should remember that
       you might get a ASC_KEYUP value.

       If the DEV-variation switches from Kickstart back to SOS,
       it might send an extra ASC_KEYUP to avoid problems with
       keys that have been released while Kickstart was running.

       Some key-values have been defined for special keys:

       Wert   Label           Bedeutung
       ---------------------------------------
       24     ASC_SAE         großes Ä
       25     ASC_SOE         großes Ö
       26     ASC_SUE         großes Ü
       27     ASC_AE          kleines ä
       28     ASC_OE          kleines ö
       29     ASC_UE          kleines ü
       30     ASC_SZ          ß
       96     ASC_APO         Apostroph `
       128    ASC_CUP         cursor up
       129    ASC_CDOWN       cursor down
       130    ASC_CLEFT       cursor left
       131    ASC_CRIGHT      cursor right
       132    ASC_BACKSPACE   backspace
       133    ASC_DELETE      delete
       134    ASC_INSERT      shift backspace
       135    ASC_HELP        help
       136    ASC_RETURN      return
       137    ASC_ESCAPE      escape
       138    ASC_TAB         tabulator
       139    ASC_SRETURN     shift return
       140    ASC_SCUP        shift cursor up
       141    ASC_SCDOWN      shift cursor down
       142    ASC_SCLEFT      shift cursor left
       143    ASC_SCRIGHT     shift cursor right
       144    ASC_F1          Function key 1
       145    ASC_F2          Function key 2
       146    ASC_F3          Function key 3
       147    ASC_F4          Function key 4
       148    ASC_F5          Function key 5
       149    ASC_F6          Function key 6
       150    ASC_F7          Function key 7
       151    ASC_F8          Function key 8
       152    ASC_F9          Function key 9
       153    ASC_F10         Function key 10
       154    ASC_SESCAPE     shift escape
       155    ASC_SHELP       shift help
       156    ASC_KEYUP       keyUp-code

   EXAMPLE (from Error(), DEV Variation)

       .wait    jsr      _GetKey(a6)       ; wait for key
                tst.b    d0
                beq.s    .wait              ; no key
                bmi.s    .wait              ; special key or ASC_KEYUP

   BUGS

***************************************************************************** 
sos.library/GetPISS                                       sos.library/GetPISS
***************************************************************************** 

   NAME
       GetPISS -- Get pointer to  Public Information System Structure

   SYNOPSIS
       PISS=GetPISS()
       d0

       struct PISS *GetPiss(void);

   FUNCTION
       Get the pointer to the Public Information System Structure.
       This is a global structure that holds many information about
       the hardware configuration and input from mouse and keyboard.
       You may read the information, and in some cases you may even
       modify it.

   RESULT
       PISS  - Pointer to PISS

   NOTE
       Do never modify PISS-entries, except this is explicity 
       allowed in the include file. Do never peek into the SOSBase
       itself, since the SOSBase chages from variation to variation.

       The result will also be given in a0 because of backwards 
       compatibility, never use this feature!

   SEE ALSO
       sos.i 

***************************************************************************** 
sos.library/InbitDiskPrefech                     sos.library/InbitDiskPrefech
***************************************************************************** 

   NAME
       InitDiskPrefetch -- Initialise prefech-system

   SYNOPSIS
       InitDiskPrefetch(Memory)
                        d0

       void InitDiskPrefetch(Memory)
                             d0

   FUNCTION
       Initialise prefetch-system. From now on all disk accesses will
       be cached automatically and calls of PrefetchDisk() will
       use free processortime to prefetch data from disk.
       This function can only be called once.

   INPUTS
       Memory    - Amount of memory that will be left to the System.
                   All other memory will be used for prefetching.
                   Use 0 to allocate ALL memory. all further 
                   AllocMem() or similar calls will fail.

   EXAMPLE
       see PrefetchDisk().

   NOTES
       You should not call AllocBlock() before calling InitDiskPrefetch()
       to avoid memory-leaks. Normally you should call this 
       function as early as possible or after the last allocation.


   BUGS

   SEE ALSO
       PrefetchDisk()

***************************************************************************** 
sos.library/InitAltMemory                           sos.library/InitAltMemory
***************************************************************************** 

   NAME
       InitAltMemory -- Initialise alternating Memory Managment

   SYNOPSIS
       InitAltMemory(dummy)
                     d0

       void InitAltMemory(int dummy);

   FUNCTION
       Set up alternating direction memory managment system.
       This will be in Function till the next ClrInt() or ClrDefault()
       call.

       After this call, all memory allocations will be made from the 
       beginning of the blocks of free memory. When you make your next 
       call to AltMemory(), the memory
       end pointers will be reset to SetDefault()-values and all 
       allocations will be done from the end of the memory blocks. Calling
       SetInt() once more will restore the normal allocation direction
       and reset the block start pointers.

       You can now make simple multipart Demos: You call AltMemory() 
       after all allocations for an effect are done and before you start
       to allocate the next effect. Then you remove the ENVEND-Macro
       If the effects run completely in interrupt, the following effect
       will be loaded, decruched and initialised while the current effect
       runs. Be shure, you don't use the Blitter in initialisation and
       interrupt, otherwise you'll crash.

       Since AltMemory()-calls restore the memory-pointers, it is
       saver to call SetDefault() before calling InitAltMemory()
       Calling SetDefalt() after InitAltMemory (when alternating
       memory is active) may lead to unpredicted and undesired 
       results, exspecially if you call AltMemory() after unmatched
       SetDefault()s in alternating memory mode.

   INPUT
       dummy  - allways 0

   BUGS

   SEE ALSO

***************************************************************************** 
sos.library/INITSOS                                       sos.library/INITSOS
***************************************************************************** 

   NAME
       INITSOS -- Header for SOS-Programme

   SYNOPSIS
       INITSOS  Start         (Macro)
       INITSOS2 Start         (Macro)

   FUNCTION
       Createa an SOS-Header as needed for SLOAD, SLOADHYB, 
       the trackdisk loader and the executable driver.

       One of these macros must be used at the beginning
       of each SOS-program.

       The INITSOS macro is much smaller then the INITSOS2 macro.

       INITSOS will be sufficient for starting demos with SLOAD and
       similar utilities.

       INITSOS2 has the additional feature of a Shell/Workbench start.
       When started from Shell or Workbench the sos.library will be 
       loaded automatically and the functionality of SLOAD is
       build in.

   INPUTS
       Start  - Startadress of your code.

   BUGS

***************************************************************************** 
sos.library/LastRand                                     sos.library/LastRand
***************************************************************************** 

   NAME
       LastRand -- Store last used Seed

   SYNOPSIS
       Zahl,Seed =FastRand(Seed)
                           d6/d7

   FUNCTION
       Store the seed for use with FirstRand().

   INPUTS
       Seed     - Seed as generated by FastRand() and FirstRand().

   EXAMPLE
       See Randomize()

   NOTES
       d6 and d7 are used and changed!

   BUGS

   SEE ALSO
       FirstRand(), LastRand(), Randomize()

***************************************************************************** 
sos.library/Load                                             sos.library/Load
***************************************************************************** 

   NAME
       Load -- Load file.

   SYNOPSIS
       Load(Size,Name,Buffer)
            d0   a0   a1

       void LoadDecruch(ULONG,char *,APTR);

   FUNCTION
       Load file in buffer.

   INPUTS
       Size     - Maximum size that will be read.
       Name     - Pointer to filename.
       Buffer   - Destination buffer.

   ERRORS
       Diverse diskerrors that will abort the Program.

   BUGS

   SEE ALSO
       LoadDecrunch(), Open(), Read(), Close()

***************************************************************************** 
sos.library/LoadDecrunch                             sos.library/LoadDecrunch
***************************************************************************** 

   NAME
       LoadDecrunch -- Lade and decrunch file.

   SYNOPSIS
       LoadDecrunch(Name,Destnation)
                    a0   a1  

       void LoadDecrunch(char *,APTR);

   FUNCTION
       Load file and decruch. See PPDecrunch() for detailed information
       about supported crunchers.

   INPUTS
       Name          - Pointer to filename
       Destination   - Pointer to destination buffer

   ERRORS
       Diverse diskerrors that will abort the Program.

   BUGS

   SEE ALSO
       Load(), PPDecrunch()

***************************************************************************** 
sos.library/LoadSeg                                       sos.library/LoadSeg
***************************************************************************** 

   NAME
       LoadSeg -- Load and relocate segment

   SYNOPSIS
       Adress = LoadSeg(Name)
       d0               a0

       APTR LoadSegment(char *)

   FUNCTION
       Load and relocate segment. It may have been crunched with 
       the SegCrunch utility.

   INPUTS
       Name     - Pointer to name.

   RESULT
       Adress   - Pointer to the first byte of relocated code.
                  

   ERRORS
       Diverse Errors from Open(), Read(), Close()
       ERR_NoSegment - File is not a segment
       ERR_NoMemory  - No memory to allocate file.

   NOTES
       Normal SOS-programms with SOS-Header for SLoad/SLoadHyb
       should be started with jsr 6(a0).
       There is no header and linkage information like AmigaDos
       supplies. 

   BUGS

   SEE ALSO
       LoadSegMem()

***************************************************************************** 
sos.library/LoadSegMem                                 sos.library/LoadSegMem
***************************************************************************** 

   NAME
       LoadSegMem -- Relocate from memory

   SYNOPSIS
       Adress = LoadSegMem(Memory)
       d0                  a0

       APTR LoadSegment(char *);

   FUNCTION
       Relocate an already loaded Segmentfile.
       This function was supposed to allow decrunching of
       segments, but LoadSeg and the SegCrunch util supply a much
       better way of doing this.

       This function is not very memory-efficient since it hold
       both the segment file and the relocated segment in memory.
       You shouldn't really use it, and it has never been used.

       If you want to use if please contact Chaos because I might
       kick it one day if I don't get feedback that somebody needs it. 

   INPUTS
       Memory   - Pointer to an already loaded segment.

   RESULT
       Adress   - Pointer to the relocated segment.

   BUGS

   SEE ALSO
       LoadSeg()

***************************************************************************** 
sos.library/MemType                                       sos.library/MemType
***************************************************************************** 

   NAME
       MemType -- Find out attributes of an adress.

   SYNOPSIS
       Attributes = MemType(Adress)
       d0                   a0

       ULONG MemType(APTR);

   FUNCTION
       Search the internal memory lists for the adress and find
       out its attributes.

   INPUTS
       Adress            - Adress to check

   RESULT
       Attributes        - MAT_xxx value

   ERRORS
       ERR_IllegalAdress - Adress is not part of the memory controlled
                           by SOS. Program aborts.

   BUGS

   SEE ALSO
       AllocMem(), AllocBlock(), TryAlloc(), MemType(), FreeAll()

***************************************************************************** 
sos.library/ModDefault                                 sos.library/ModDefault
***************************************************************************** 

   NAME
       ModDefault -- Modify default environment.

   SYNOPSIS
       ModDefault(Copper,Irq,Enable)
                  a0     a1  d0

       void ModDefault(UWORD,UWORD *,void (*)(void));

   FUNCTION
       Change the setting made with SetDefault().
       After calling ClrDefault() or ClrInt(), these
       values will be used instead of the originally stored ones.

   INPUTS
       Enable   - Interrupt Enable, a comnbination of $0010, $0020 and
                  $0040 for copper, vertical blanking and blitter
                  interrupt. $0000 when no change of interrupts is
                  desired.
       Copper   - Pointer to Clist or 0 (use old one)
       Irq      - Pointer to your IRQ code, unimportant if Enable=0.

   NOTES
       Remember that all Memory that has been allocated since
       SetDefault will be freed! You might loose ground beneath your
       feet if your new interrupt code lies in freshly allocated memory!

   BUGS

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault()

***************************************************************************** 
sos.library/MotorOff                                     sos.library/MotorOff
***************************************************************************** 

   NAME
       MotorOff -- End a series of disk accesses.

   SYNOPSIS
       MotorOff()

   FUNCTION
       This allows you to switch of the motor of the disk drive.
       All disk accessing functions switch it on, but nobody
       switches it off to save time. If you made the last
       of a sequence of disk accesses you should call this.

       As a matter of fact, this function has never been implemented.
       If you call it, nothing happens. The motor will run for ever.

   SEE ALSO
       Open(), Close(), Read(), MotorOff(), Prefetch()

***************************************************************************** 
sos.library/Open                                             sos.library/Open
***************************************************************************** 

   NAME
       Open -- Open file for partial loading with Read().

   SYNOPSIS
       Open(Name)
            a0

       void Open(char *);

   FUNCTION
       The file will be opened. Only one file can be open at a time.

   INPUTS
       Name     - Pointer to filename

   ERRORS
       ERR_FileNotFound   - File not found
       ERR_OpenedTwice    - Remember! only one file at a time!

   EXAMPLE
       Load     movem.l  d2-d3,-(a7)       ; SOS Load Routine
                move.l   d0,d2             ; d2 = länge
                move.l   a1,d3             ; d3 = Adresse
                bsr      Open              ; Open
                move.l   d2,d0
                move.l   d3,a0
                movem.l  (a7)+,d2-d3
                bsr      Read              ; Read
                bra      Close             ; Close

   BUGS

   SEE ALSO
       Load(), Read(), Close(), Seek(), GetFilePos()

***************************************************************************** 
sos.library/OpenLibrary                               sos.library/OpenLibrary
***************************************************************************** 

   NAME
       OpenLibrary -- Look for a library and load it if neccessary   (V2.0)

   SYNOPSIS
       LibBase=OpenLibrary(Name)
       d0                  d0

       struct Library *OpenLibrary(ULONG);

   FUNCTION
       Search library in the library list of libraries. 
       If it can't be found, try to load a file called
       "xxxx.soslibrary" where xxxx is the name of the library.

   INPUTS
       Name     - A four letter ASCII-Literal.

   RESULT
       LibBase  - Library base pointer, functiontable.

   NOTES
       Already used library-names:
       DBUG  - small system debugger
       SINE  - sinelist generator
       INYF  - Inyerface user interface (broken promisses)
       MATH  - Math library (simple splines, 32 bit arithmetic)

       If you want to make your own library you must ask Chaos/Sanity
       (Dierk Ohlerich), the author of this System to avoid
       Library name conflickts.

       Many libraries want their base pointer in a4 when you 
       call a function!

   BUGS

***************************************************************************** 
sos.library/OpenScreen                                 sos.library/OpenScreen
***************************************************************************** 

   NAME
       OpenScreen -- Open small message screen.

   SYNOPSIS
       OpenScreen()

       void OpenScreen();

   FUNCTION
       This allocated the smal message screen that is used to
       display debugging messages and similar stuff. The memory
       for the Bitmap is taken from the top of the memory.
       The screen will be closed when you call CloseScreen(),
       call AllocMem() and there is not enough memory left,
       call AllocBlock() or call one of the SetInt()-functions.

   EXAMPLE (from Checkrelease)

                move.l   a0,-(a7)    
                jsr      _OpenScreen(a6)   ; Öpen Screen
                move.l   (a7)+,a0          ; Write text
                jsr      _PutScreen(a6)    

       It is not neccessary to close the screen manually since it
       closes itself when SetInt is called. No memory is wasted
       since the screen is in the free memory region and closes 
       itself when the memory is needed.

   BUGS

   SEE ALSO
       CloseScreen(), PutScreen(), ClearScreen(), CrScreen()

***************************************************************************** 
sos.library/PPDecrunch                                 sos.library/PPDecrunch
***************************************************************************** 

   NAME
       PPDecrunch -- Unversal decruching routine

   SYNOPSIS
       PPDecrunch(Source,Dest,Lenght)
                  a0     a1   d0

       void PPDecrunch(APTR,APTR,ULONG);

   FUNCTION
       Find out what cruncher was used to the data and decruch it
       if you can. If the data is not cruched, or the cruncher is
       unknown, the data will be simply copied.

       All supportet crunchers may be used with Source=Destination.

   INPUTS
       Source   - Cunched data.
       Dest     - Buffer for decrunched data.
       Lenght   - Lenght of crunched data.

   NOTES
       At the moment the following crunchers are supportet:

       PP20      - Powerpacker 2.0 - 4.0
       IMP!      - Imploder
       CrM!      - Crunchmania
       CrM2      - Crunchmania

       Note the copyrights of these crunchers!

   BUGS

***************************************************************************** 
sos.library/PrefetchDisk                             sos.library/PrefetchDisk
***************************************************************************** 

   NAME
       PrefetchDisk -- try to prefetch a track.

   SYNOPSIS
       PrefetchDisk()

   FUNCTION
       Load a track from disk, that might be used. In applications
       like musicdisk or games with many levels this might reduce
       loading times to zero.

       This can only be used correctly if you do ALL your work in
       interrupt and call this function in a loop from the main-code.
       This function may take a while.

   ERROR
       If you call PrefetchDisk() without calling InitDiskPrefetch(),
       nothing will happen, not even something bad.

   EXAMPLE (untested)

       Main     bsr      Init              ; Initialise for a demo that
                moveq    #512*1024,d0      ; runs on 512K-Amigas
                jsr      _InitDiskPrefetch(a6)
                     ...
       MainLoop jsr      _PrefetchDisk(a6) ; read track
                tst.w    EndFlag           ; end-signal vom IRQ?
                bne.s    Ende              ; yes -> exit
                btst     #6,$bfe001        ; left mouse button?
                bne.s    MainLoop          ; -> looping
       Ende     bsr      Exit              ; end of programm
                rts

       IRQ           ...                   ; here the real work
                bne.s    EndIrq            ; end of effect?
                move.w   #1,EndFlag           ; yes!
       EndIrq        ...                   ; No

   BUGS

   SEE ALSO
       InitDiskPrefetch()

***************************************************************************** 
sos.library/PutScreen                                   sos.library/PutScreen
***************************************************************************** 

   NAME
       PutScreen -- Write text to screen.

   SYNOPSIS
       PutScreen(Text)
                 a0

       void PutScreen(char *);

   FUNCTION
       Write text to the screen, if the screen has been opened.
       If no screen is open nothinh happens.

   INPUTS
       Text     - Pointer to text. $a as code for return/linefeed
                  is supported.

   BUGS

   SEE ALSO
       OpenScreen(), CloseScreen(), ClearScreen(), CrScreen()

***************************************************************************** 
sos.library/Randomize                                   sos.library/Randomize
***************************************************************************** 

   NAME
       Randomize -- Create new random seed

   SYNOPSIS
       Randomize()

       void Randomize(void);

   FUNCTION
       Create a new random seed by mixing some "random" values
       from the hardware, mainly CIA-timers and raster position.

       You should only call this function if you want your
       values to be different everytime you run your program.
       Ususally it is more safe to use allways the same values.
       It might be a good idea to call this function during debuging
       to see if your code works with different values, too.

   EXAMPLE (not tested)

                jsr      _Randomize(a6)    ; mix it all 

                jsr      _FirstRand(a6)    ; create one random number
                bsr      UseRandom

                                           ; create many random numbers
                jsr      _FirstRand(a6)    ; get seed, ignore d0
                moveq    #100-1,d0         ; create 100 numbers
       Loop     jsr      _FastRand(a6)
                bsr      UseRandom
                dbf      d0,Loop
                jsr      _LastRand(a6)     ; write back seed.

   BUGS

   SEE ALSO
       FirstRand(), LastRand(), FastRand(a6)

***************************************************************************** 
sos.library/Read                                             sos.library/Read
***************************************************************************** 

   NAME
       Read -- Read part of a file.

   SYNOPSIS
       Read(Size,Buffer)
            d0   a0

       void Read(ULONG,APTR);

   FUNCTION
       Read a part from a file that has been opened with Open().

   INPUTS
       Size     - Number of bytes to read.
       Buffer   - Pointer to destination buffer.

   ERRORS
       ERR_NotOpened     - no file opened
       ERR_DiskReadErr   - diskerror

   EXAMPLE
       See Open.

   BUGS

   SEE ALSO
       Load(), Open(), Close(), Seek(), GetFilePos()

***************************************************************************** 
sos.library/ReLoad                                         sos.library/ReLoad
***************************************************************************** 

   NAME
       ReLoad() -- Resume with another Segment

       void ReLoad(void);

   SYNOPSIS
       ReLoad(SegmentName)
              a0

   FUNCTION
       Free all userallocated Memory, Load and Execute a segment.
       This call is thought to link two independent Parts together.

   INPUTS
       SegmentName  - Pointer to filename

   NOTES
       This function does not return, the old segment will be 
       freed. Therefore you should call it with JMP, not JSR.
       The stack should be "clean", the Stackpointer(s) should
       point to thier initial values. Then the last part of a
       "ReLoad"-Chain can RTS out of the demo.

   BUGS
       Filename should not be longer then 15 letters + a terminating 0.

***************************************************************************** 
sos.library/RemoveRamDisk                           sos.library/RemoveRamDisk
***************************************************************************** 

   NAME
       RemoveRamDisk -- Release memory of the Ramdisk.

   SYNOPSIS
       RemoveRamDisk()

   FUNCTION
       This function is now obsolate. Is was only used in the
       Optimum Fuckup demo.

   BUGS

   SEE ALSO
       Main()

***************************************************************************** 
sos.library/ResetRand                                   sos.library/ResetRand
***************************************************************************** 

   NAME
       ResetRand -- Reset Random Generator to defined start.

   SYNOPSIS
       ResetRand()

   FUNCTION
       Sometimes you want to have allways the same sequence of
       Random numbers. Just imagine you generate a fractal 
       landscape and you must ensure that this landscape is the
       same for each time yu programm is called. 

       If other effects have used the random generator before,
       you will get different values. If you call this function, 
       the internal Seed is reset to standard values and you will
       get the standard sequence of numbers.

       Please Note that the random function uses d0 and d1 as
       "hidden" input to make the number even more random.
       If you want defined values, you must enshure that these
       registers have defined values each time you call
       FirstRand(), FastRand() or LastRand().

   BUGS

   SEE ALSO
       FirstRand(), LastRand(), FastRand()

***************************************************************************** 
sos.library/Save                                             sos.library/Save
***************************************************************************** 

   NAME
       Save -- Save a file

   SYNOPSIS
       Save (Name,Buffer,Size)
             a0   a1     d0

       void Save(char *,APTR,ULONG);

   FUNCTION
       Save a file. The file must be already existing and must
       have the same size.
       This is thought for highscores and similar. SOS does not
       want to supply a complete filesystem.

   INPUTS
       Name     - Pointer to filename.
       Buffer   - Pointer to data.
       Size     - Size of the file.

   BUGS
       This function works only in DEV-Variation, not for Trackmos.

***************************************************************************** 
sos.library/ScanTagList                               sos.library/ScanTagList
***************************************************************************** 

   NAME
       ScanTagList -- Convert Taglist to Array.           (V2.0)

   SYNOPSIS
       ScanTagList (TagList, Array, Default, Maximum)
                    a0       a1     a2       d0

       void ScanTagList(struct TagItem *,APTR,APTR,ULONG);

   FUNCTION
       Tags are used for extendable parameter structures.
       Some function can be called with an TagItemArray as 
       parameter. Using Tags it is easy to include new parameters
       for new versions of this function. Each TagItem
       consists of a Tag and a Value. The Tag tells what
       meaning the Value has. TagItems are inefficient but
       flexible, and they should only be used for
       initialisation and similar.

       This function converts a TagItemArray into  a structure.

       If you pass a default array, this array will be copied into 
       the destination array. After that, all Tags will be 
       inserted into that destination array.

       In SOS, Tags are symbolic memory storage commands.
       All Tags are build like this:

       Bits   Meaning
       00-15  Offset in TagArray, sign extended!
       16-17  Size.
               00 = Longword
               01 = Wort
               10 = Byte
               11 = Bit    (unimplementiert)
       18-21  Bitnummer for Size 11.
          31  Special.

       Special Tags:
       $80000000 TAGEND    End of Taglist
       $80000001 TAGSKIP   This tag is empty
       $80000002 TAGMORE   Jump to somewhere.


   INPUTS
       TagList  - TagItemArray
       Array    - Destination structure
       Default  - Optional default values
       Maximum  - Length of destination structure.

   BUGS
       - TagItemArray must not be longer then 32K
       - Tags and maximum müst smaler then $8000.
       - The whole design of this tag implementation is broken and
         allmost useless. But it's good enough for the few cases
         where I need it.

***************************************************************************** 
sos.library/Seek                                             sos.library/Seek
***************************************************************************** 

   NAME
       Seek -- Manipulate file-pointer.

   SYNOPSIS
       Seek(Offset)
            d0

       void Seek(ULONG);

   FUNCTION
       Set the readmark to a specified position.
       This is very usefull if you have for random access to a file.

   INPUTS
       Offset - Offset in bytes into the file.

   ERRORS
       ERR_NotOpened - You have not opened a file.

   BUGS

   SEE ALSO
       Load(), Open(), Read(), Close(), GetFilePos()

***************************************************************************** 
sos.library/SetCopperAdr                             sos.library/SetCopperAdr
***************************************************************************** 

   NAME
       SetCopperAdr -- Initialise pointers in a copperlist.

   SYNOPSIS
       SetCopperAdr(Copper,Plane,Offset,Count,Register)
                    a0     d0    d1     d2    d3

       void SetCopperAdr(UWORD *,APTR,ULONG,UWORD,UWORD);

   FUNCTION
       Sets several bitplane- or spritepointer in a copperlist.

   INPUTS
       Copper   - Adresse of the first CMOVE-command.
       Plane    - Value that is stored in the Copperlist
       Offset   - Offset from one plane to another.
       Count    - Number of adresses to write.
       Register - Number of the first Register.


   EXAMPLE (not tested)
       Initialise an interleaved bitplane lores, 40 bytes, 5 planes.

                lea      CopIn,a0          ; SetCopperAdr()
                move.l   #PlaneDat+64,d0   ; Grafikdaten from byte 64
                moveq    #40,d1     
                moveq    #5,d2
                move.w   #$e0,d3
                jsr      _SetCopperAdr(a6)

                lea      CopCol,a0         ; SetCopperCol()
                lea      PlaneDat,a1       ; colors stored before planes
                moveq    #0,d0
                moveq    #32,d1
                jsr      _SetCopperCol(a6)
                     ...
                dc.w     $0108,40*4        ; Set modulo
                dc.w     $010a,40*4
       CopIn    dcb.l    2*5               ; planeptrs here
       CopCol   dcb.l    32                ; colors here
                     ...
       PlaneDat INCBIN   'picture.raw'     ; include picture

   BUGS

   SEE ALSO
       SetCopperCol()

***************************************************************************** 
sos.library/SetCopperCol                             sos.library/SetCopperCol
***************************************************************************** 

   NAME
       SetCopperCol -- Initialisiere colors in copperlist

   SYNOPSIS
       SetCopperCol(Copper,Colors,Register,Count)
                    a0     a1     d0       d1

       void SetCopperCol(UWORD *,UWORD *,UWORD,UWORD);

   FUNCTION
       Initialises some CMOVE-commands that could set up a 
       color palette.

   INPUTS
       Copper   - Where to write the copperlist
       Colors   - Pointer to palette
       Register - First colorregister from 0 to 31 (!).
       Count    - Number of colorregisters to set.

   EXAMPLE
       siehe SetCopperAdr()

   BUGS

   SEE ALSO
       SetCopperCol()

***************************************************************************** 
sos.library/SetDefault                                 sos.library/SetDefault
***************************************************************************** 

   NAME
       SetDefault -- Setze default environment

   SYNOPSIS
       SetDefault()

       void SetDefault(void);

   FUNCTION
       Remember copper, interrupt and memory environment.
       This environment will be pushed onto a stack. You may 
       restore this environmen with ClrInt(), and you can pop it
       with ClrDefault().

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault()

***************************************************************************** 
sos.library/SetInt                                         sos.library/SetInt
***************************************************************************** 

   NAME
       SetInt -- Setze Interrupt und Copper

   SYNOPSIS
       SetInt(Copper,Irq,Enable)
              a0     a1  d0

       void SetInt(UWORD,UWORD *,void (*)(void));


   FUNCTION
       Switch from one environment containing Copperlist and
       interrupts to another. Be shure that a copperinterrupt
       is called with the accociated copperlist.

       This routine will wait until the next frame to ensure 
       smooth transitions.

       If you want the debugger to work properly, you MUST use
       this function to change the COP1LC-register. You may 
       only access this register manually if you do some kind 
       of copper-doublebuffering. If you change from one effect
       to the other you MUST call SetInt.

       If the debugger is called, it can not find out what
       copperlist you have set by peeking the hardware. It uses
       the SetDefault(), ClrDefault() mechanism to set it's own
       Copperlist and restore the old one, and these function
       rely totally on SetInt to find out your copperlist.
       If you change the copperlist manually, you must remember that
       after calling the debugger the copperlist you set with SetInt
       will be restored. Please design your Copper-doublebuffering
       carefully to handle these errors correct and ALLWAYS use
       SetInt() when you change from one part to another.

       This function is the most important function in SOS!

   INPUTS
       Enable   - Interrupt Enable, a comnbination of $0010, $0020 and
                  $0040 for copper, vertical blanking and blitter
                  interrupt. $0000 when no change of interrupts is
                  desired.
       Copper   - Pointer to Clist or 0 (use old one)
       Irq      - Pointer to your IRQ code, unimportant if Enable=0.

   NOTES
       This routine may NOT be called from interrupt. Use 
       SetIntFast() instead!.

   BUGS
       Somehow, transitions are sometimes not as smooth as I hoped.

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault()

***************************************************************************** 
sos.library/SetIntDev                                   sos.library/SetIntDev
***************************************************************************** 

   NAME
       SetIntDev -- Set Interrupt und Copper for Kickstart calls

   SYNOPSIS
       SetIntDev(Enable,Copper,Irq)
                 d0     a0     a1

       void SetIntdev(UWORD,UWORD *,void (*)(void));

   FUNCTION
       This routine sets a copper and interrupt state that is used
       when SOS DEV variation switches back to Kickstart mode.
       This allows you to display a recent screen when kickstart
       is called. Remember that copperlist and interrupts must run
       in a multitasking environment, you may not use the Blitter!

       Unfortunatly, this feature is not fully implemented...
       When SOS switches back to Kickstart, ugly things will happen.

   INPUTS
       Enable   - Interrupt Enable, only $0020 is allowed!
                  0 if no interrupt is desired.
       Copper   - Pointer to Clist or 0 (use old one)
       Irq      - Pointer to your IRQ code, unimportant if Enable=0.

   BUGS

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault(), SetInt().

***************************************************************************** 
sos.library/SetIntFast                                 sos.library/SetIntFast
***************************************************************************** 

   NAME
       SetIntFast -- Set interrupt and copper from interrupt

   SYNOPSIS
       SetIntFast(Enable,Copper,Irq)
                  d0     a0     a1

       void SetIntFast(UWORD,UWORD *,void (*)(void));

   FUNCTION
       You can not call SetInt from interrupt because SetInt waits
       till the next interrupt. If you want to change these settings
       from Interrupt you must call this function.

   INPUTS
       Enable   - Interrupt Enable, a comnbination of $0010, $0020 and
                  $0040 for copper, vertical blanking and blitter
                  interrupt. $0000 when no change of interrupts is
                  desired.
       Copper   - Pointer to Clist or 0 (use old one)
       Irq      - Pointer to your IRQ code, unimportant if Enable=0.

   BUGS
       You can not disable all interrupt because a value of 0 for
       Enable will leave the interrupts unchanged. This is a design
       bug in this function. But I never needed all interrupts
       disabled...

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault(), SetInt().

***************************************************************************** 
sos.library/SoundOff                                     sos.library/SoundOff
***************************************************************************** 

   NAME
       SoundOff() -- Avoid noises when switching on audio-channels.

   SYNOPSIS
       SoundOff()

       void SoundOff(void);

   FUNCTION
       You may know these strange noises that you can sometimes 
       hear when the first note of a song is played. This problem
       arises very strongly when using copper-audio techniques.
       This function switches all audiochannels off in a very
       carefull way. This should avoid these problems, but it doesn't.

   NOTES
       Needs a timer!

   BUGS
       It doesn't really solve the problem, but it's worth a try...

***************************************************************************** 
sos.library/StartIt                                       sos.library/StartIt
***************************************************************************** 

   NAME
       StartIt -- initialise SOS 

   SYNOPSIS
       StartIt(Code)
               a0

       void StartIt(void (*)(void));

   FUNCTION
       Initialise SOS, start the specified routine, restore (if
       possible) operating system.

       Your code must end with RTS and may change all registers.

       The DEV variation will return safely back to Kickstart.
       The RUN variation will give an error to the small Screen
       when your Code returns.

   INPUTS
       Code   - Your demo or game.

   ERRORS
       All of them...

   NOTES
       This function should only be used by loaders like SLOAD, 
       SLOADHYB, the trackdisk loader installed by SOSCON or the
       sos.library header macro INITSOS2.

       The RUN-variation must call this in supervisor mode. 
       Your code is then called in user-mode. When your code
       returns, a Reload() will be performed. But
       you should not even THINK of calling this function in the
       RUN-variation!

   BUGS

   SEE ALSO
       BailOut(), Error(), ReLoad()

***************************************************************************** 
sos.library/Trap13                                         sos.library/Trap13
***************************************************************************** 

   NAME
       Trap13 -- Cache und CPUSetup subroutines

   SYNOPSIS
       moveq   #T13_xxx,d0
       trap    #13

   FUNCTION
       call one of the following functions

       T13_DataOn      - enable data cache
       T13_DataOff     - disable data cache
       T13_InstOn      - enable instruction cache
       T13_InstOff     - disable instruction cache
       T13_DataFlush   - flush datacache

       T13_ModFlush    - flush needed for selfmodifying code
       T13_PreDMA      - Pre-DMA cache flush
       T13_PostDMA     - Post-DMA cache flush

       T13_Standard    - standart setting: all caches on
       T13_Paranoid    - paranoid setting: all caches off (for the lamers)
       T13_BigTable    - usefull setting when working with big tables
                         very usefull for A4000/40!

   INPUTS
       T13_xxx  - name of the routine (sos.i)

   NOTES
       Only d0 will be changed. This routine automatically adepts
       to the current CPU.

   BUGS

***************************************************************************** 
sos.library/Trap14                                         sos.library/Trap14
***************************************************************************** 

   NAME
       Trap14 -- Call code in supervisor mode.

   SYNOPSIS
       lea     Routine(pc),a0
       trap    #14

   FUNCTION
       Call code in supervisor mode.

   INPUTS
       Routine - Pointer to a peace of code, ending with RTS

   EXAMPLE (untested)

       SetSR   lea     Routine(pc),a0   ; Get SR in a compatible way
               trap    #14              ; Supervisor call
               move.w  d0,_SR(a5)       ; Store SR somewhere
               rts

       Routine move.w  SR,d0              ; This command is protected
               rts                     ; for 68010+

   NOTES
       No registers will be changed by the trap-handler. a0 is only
       used as parameter and not changed either.

   BUGS

***************************************************************************** 
sos.library/UnfinishedIrq                           sos.library/UnfinishedIrq
***************************************************************************** 

   NAME
       UnfinishedIrq -- Avoid irq-switch.

   SYNOPSIS
       UnfinishedIrq()

       void UnfinishedIrq(void);

   FUNCTION
       SetInt() wait till the next irq before it sets the new
       parameters. This call will avoid switching after THIS
       interrupt.

       This is usefull if you want to be shure that following 
       Blitter or Copper-interrupts are processed before
       SOS switches to another interrupt environment.
       Blitter-irq's will never be switched.

   BUGS

   SEE ALSO
       SetInt(), ClrInt(), SetDefault()

***************************************************************************** 
sos.library/WaitTimer                                   sos.library/WaitTimer
***************************************************************************** 

   NAME
       WaitTimer -- Wait a little time

   SYNOPSIS
       WaitTimer(Time,Unit)
                 d0   d1

   FUNCTION
       Wait until a certain time period has elapsed. CIA-timers are used.
       The period can be specified in different units.

   INPUTS
       Time     - Value of time to wait
       Unit     - Unit of time to wait, TI_MILI oder TI_MICRO.

   NOTES
       Only 2 timers can be used. The routine can be called simultanously
       from the main progremm (diskloader) and from the interrupt routine
       (reply). The timers are shared with CaueseTimer() and are
       allocated dynamically. 

       You may not access the CIA-hardware by yourself (in the replay),
       otherwise you destroy the setup made for these routines and all
       disk access that is build upon them will fail.
.
   BUGS

   SEE ALSO
       CauseTimer()

***************************************************************************** 
sosmacros.i/--background--                         sosmacros.i/--background--
***************************************************************************** 

       All ENV-Macros must be called with a5 pointing to Vars.

***************************************************************************** 
sosmacros.i/CLRFAST                                       sosmacros.i/CLRFAST
***************************************************************************** 

   NAME
       CLRFAST -- Easy memory clearer.                        (v1.8)

   SYNOPSIS
       CLRFAST Adress,Size

   FUNCTION
       Clear memory in a fast to type and fast to execute way.
       The memoryarea must meet the following conditions:
       - Adress must be even
       - Size must be a multiple of 4
       - Size must not be larger then 256 KBytes
       - Size must not be 0

   INPUTS
       Adresse  - Label of memory to clear.
       Länge    - Size of memory to clear.

   BUGS

***************************************************************************** 
sosmacros.i/ENVDO                                           sosmacros.i/ENVDO
***************************************************************************** 

   NAME
       ENVDO -- Environment interrupt routine.

   SYNOPSIS
       ENVDO  label           (MACRO)

   FUNCTION
       Call the Environment interrupt code, usually the replay.
       Increase the ENV_Tick timer.

       If DEBUG is defined, the routine will check the left mousebutton.
       If it is pressed and you set the label behind your main routine,
       your main routine will be called only every 16th frame (see
       examble at ENVINIT). Set the label directly after the ENVDO-macro
       to disable this feature.

   EXAMPLE
       siehe ENVINIT

   BUGS

   SEE ALSO
       ENVVARS, ENVINIT, ENVWAIT, ENVCODE

***************************************************************************** 
sosmacros.i/ENVEND                                         sosmacros.i/ENVEND
***************************************************************************** 

   NAME
       ENVEND -- Warte auf Ende

   SYNOPSIS
       ENVEND loop  (MACRO)

   FUNCTION
       Wait for the end tick of the demo. Call the ENV_Job field.
       If the demo is not finished, jump back to the loop-label.

   INPUTS
       loop  - Label for loop.
   
   EXAMPLE
       siehe ENVINIT

   BUGS

   SEE ALSO
       ENVVARS, ENVINIT, ENVWAIT, ENVCODE, ENVDO

***************************************************************************** 
sosmacros.i/ENVINIT                                       sosmacros.i/ENVINIT
***************************************************************************** 

   NAME
       ENVINIT -- Initialise standard environment system

   SYNOPSIS
       ENVINIT EnvFlags,Time    (MACRO)

   FUNCTION
       Try to find environments. If the environments are already
       set, use them. If one of the features you requested for your
       environment is not available (such as the memory pool) it will
       be created and added to the environment.

       The standard environment will abort the demo if you press the
       right mousebutton. If you define the label NORMBX this feature 
       will be suppresed. Don't forget this for the final demo.

   INPUTS
       EnvFlags         - What features should be installed?
           ENVFf_Code   - Code for Job and Irq (specify this allways!)
           ENVFf_Timer  - Initialise timer. 
           ENVFf_Memory - Allocate memory pool.
       Time             - How many ticks the demo should run by default.

   EXAMPLE
                RSRESET
       SOSBase  RS.l     1
       DBUGBase RS.l     1
                ...

                ...
                ENVINIT  ENVFf_Code+ENVFf_Timer,$400  ; init environment
                ...
                ENVWAIT                ; wait for starting tick
                ...
                jsr      SetInt(a6)    ; set your irq

       Loop     bsr      Jobs          ; main loop
                ENVEND   Loop   
                moveq    #0,d0         ; end
                rts

       MainIrq  movem.l  ...           ; interrupt
                lea      Vars,a5       ; a5 variables
                move.l   SOSBase(a5),a6; set library base
              
                ENVDO                  ; ENV. interrupt (music)
                ...
                nop
                rte

   BUGS

   SEE ALSO
       ENVVARS,ENVINIT,ENVWAIT,ENVDO

***************************************************************************** 
sosmacros.i/ENVWAIT                                       sosmacros.i/ENVWAIT
***************************************************************************** 

   NAME
       ENVWAIT -- Warte for starting tick.

   SYNOPSIS
       ENVWAIT   (MACRO)

   FUNCTION
       Wait for the exact timer tick that should start the part.
       This moment can be set in ENV_FirstTick by the loader.
       The default value is 0

   EXAMPLE
       see ENVINIT

   BUGS

   SEE ALSO
       ENVVARS, ENVINIT, ENVDO, ENVEND

***************************************************************************** 
sosmacros.i/GENLOCK                                       sosmacros.i/GENLOCK
***************************************************************************** 

   NAME
       GENLOCK -- Adept copperlist for genlock usage.

   SYNOPSIS
       GENLOCK CLabel    (MACRO)

   FUNCTION
       if you set the number of planes, you will usuallly write something
       like

              dc.w       $0100,$a200              ; 2 planes hires

       in your copperlist. But if a genlock is attached to your Amiga,
       you will have to enable it by writing:

              dc.w       $0100,$a302              ; genlock enables

       If you write this on an Amiga without genlock, your computer
       will crash since there are no syncronisations signals from
       the genlock.
       The GENLOCK and GENLOCK2 macro will change the copperlist
       to reflect the state of the genlock bits. In future you should
       write

              dc.w       $0100,$a000              ; 2 planes hires

       all other bits will be set by the Macro. Since the operating-
       system is used to determine weather a genlock is used, there 
       might arise problems since early versions of Kickstart had
       a bug in the genlock detection.

   INPUTS
       CLabel - Label to a coppermove instruction that changes BPLCON0.

   EXAMPLE (untested!)
       here     GENLOCK  genlock1      ; adept first cmove
                GENLOCK2 genlock2      ; more cmoves
                GENLOCK2 genlock3 
                ....
                move.w   #$3000,d2     ; enale 3 planes lores
                GENLOCK  d2;           ; adept (ATTENTION! SEMIKOLON importan
t)
                move.w   d2,genlock2+2 ; and write..
                ....
       Clist    dc.w     D0180,$f0f
       genlock1 dc.w     $0100,$2000   ; 2 planes Lores
                ...
       genlock2 dc.w     $0100,$0000   ; of
                ...
       genlock3 dc.w     $0100,$a000   ; 2 planes hires

   NOTES
       if you want to change a register, you must write a semicolon
       behind the register to avoid the build in "+2".

       If you want to change many positions in the copperlist, you
       can use the GENLOCK2 macro for all subsequent positions.

       In case of trouble just look in the macro definition. These
       macros were included to make genlock adaption as easy as possible.
       But this hasn't stopped us (Chaos/Mr. Pet) to forget it many times.

   BUGS

***************************************************************************** 
sosmacros.i/GENSINUS                                     sosmacros.i/GENSINUS
***************************************************************************** 

   NAME
       GenSinus -- Generate sinelist.      (MACRO)                 (v1.8)

   SYNOPSIS
       GenSinus Adresse,Format,Range,Size,Quaters

   FUNCTION
       Create a sinelist in memory. This is done by interpolating
       a build in sine list of 256 Words length.

       The accuracy is an error of 0.5 for a range from $7fff to -$8000.
       This should be sufficiant for all your needs. Using the 
       sinelist generator will save you some memory and is more
       comfortable then working with extern sinelist generators.

       The macro needs a variable called SINEBase relative to a5 that
       holds the adress of a loaded SINE.soslibrary.

   INPUTS
       Adresse  - Pointer to free memory
       Format   - SINE_WORD or SINE_BYTE
       Range    - Half amplitude of the sinewave as potenz of 2
                  See notes.
       Size     - Number of elements for each sine quarter as potenz of 2
                  See notes.
       Quaters  - number of sine quarters (4 for full sinus, 5 for 
                  combined sinus/cosinus table.

   NOTES
       Sizes are encoded like this.

       Potenz   Elemtens per quarter       Minimum  Maximum
       -----------------------------------------------------
       2        4                          -3       3
       4        16                         -15      15
       8        256                        -255     255
       9        512                        -511     511
       10       1024                       -1023    1023 
       11       2048                       -2047    2047 
       12       4096                       -4095    4095 
       13       8192                       -8191    8191 
       14       16384                      -15383   15383
       15       32768                      -32767   32767

   BUGS

***************************************************************************** 
sosmacros.i/OPENLIB                                       sosmacros.i/OPENLIB
***************************************************************************** 

   NAME
       OPENLIB -- Load library

   SYNOPSIS
       LibBase=OPENLIB NAME   (MACRO)
       a0

   FUNCTION
       Load a library and return a pointer to it. This function also
       sets a label relative to a5 called NAMEBase that can be used
       for further Library calls.

       Remember that most extern library want thier library pointer in a4!
       Remember that all libraries are deletet from memory with
       ClrDefault(), ClrInt().

   INPUTS
       'NAME'   - 4 letter ASCII literal of the library name

   RESULT
       LibBase  - Pointer to library.

   BUGS

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault()

***************************************************************************** 
sosmacros.i/SEC-diverse-                             sosmacros.i/SEC-diverse-
***************************************************************************** 

   NAME
       SECCODE   -- Start code section
       SECBSS    -- Start BSS section
       SECCODE_C -- Start code section Chipmem
       SECBSS_C  -- Start BSS section Chipmem

   SYNOPSIS
       SECCODE
       SECBSS
       SECCODE_C
       SECBSS_C

   FUNCTION
       These macros are simpler to type then the corresponding 
       Section-commands. 

       A special feature has been introduced. If you define the
       CHIPMEM label, all sections will be forced to chipmemory. 
       This allows you to check how slow your routine gets on 
       a computer that has no fastmemory if your development 
       computer has fast memory. You should allways spread the
       version with CHIPMEM reset, just to be shure.

   BUGS

***************************************************************************** 
sosmacros.i/SETCADR                                       sosmacros.i/SETCADR
***************************************************************************** 

   NAME
       SETCADR -- Initialisiere Adresse(n) in einer Copperliste.    (v1.8)

   SYNOPSIS
       SETCADR Copper,Plane,Offset,Count

   FUNCTION
       Sets several bitplane- or spritepointer in a copperlist.

   INPUTS
       Copper   - Adresse of the first CMOVE-command.
       Plane    - Value that is stored in the Copperlist
       Offset   - Offset from one plane to another.
       Count    - Number of adresses to write.
       Register - Number of the first Register.

   EXAMPLE (not tested)
       Initialise an interleaved bitplane lores, 40 bytes, 5 planes.

                SETCADR  CopPln,#PlaneDat+64,40,5,$e0
                SETCCOL  CopCol,PlaneDat,0,32
                SETCSPR  CopSpr
                     ...
                dc.w     $0108,40*4        ; set modulo
                dc.w     $010a,40*4
       CopPln   dcb.l    10                ; BPLxPT's 
       CopSpr   dcb.l    16                ; SPRxPT's
       CopCol   dcb.l    32                ; COLORxx's
                     ...
       PlaneDat INCBIN   'picture.raw'     ; palette and planes

   BUGS

   SEE ALSO
       SetCopCol()

***************************************************************************** 
sosmacros.i/SETCCOL                                       sosmacros.i/SETCCOL
***************************************************************************** 

   NAME
       SETCCOL -- Initialisiere colors in copperlist.   (v1.8)

   SYNOPSIS
       SETCCOL Copper,Colors,Register,Count      (MACRO)

   FUNCTION
       Initialises some CMOVE-commands that could set up a 
       color palette.

   INPUTS
       Copper   - Where to write the copperlist
       Colors   - Pointer to palette
       Register - First colorregister from 0 to 31 (!).
       Count    - Number of colorregisters to set.

   EXAMPLE
       siehe SETCADR

   BUGS

   SEE ALSO
       SetCopperCol()

***************************************************************************** 
sosmacros.i/SETCSPR                                       sosmacros.i/SETCSPR
***************************************************************************** 

   NAME
       SETCSPR -- Reset spritepointer                    (v1.8)

   SYNOPSIS
       SETCSPR Sprites            (MACRO)

   FUNCTION
       This macro sets all 8 spritepointers to an adress that holds 
       zero in a copperlist. You must provide a label called Zeros
       that declares a longword 0 in chipmemory.

   INPUTS
       Sprites   - label to 64 free bytes in a copperlist

   NOTES
       This macro calls SetCopperAdr().

   EXAMPLE
       siehe SETCADR

   BUGS

   SEE ALSO
       SetCopperAdr(), SetCopperCol()

***************************************************************************** 
sosmacros.i/SETINT                                         sosmacros.i/SETINT
***************************************************************************** 

   NAME
       SETINT -- Set Interrupt and Copper                         (v1.8)

   SYNOPSIS
       SETINT Copper,Irq,Enable   (MACRO)

   FUNCTION
       Switch from one environment containing Copperlist and
       interrupts to another. Be shure that a copperinterrupt
       is called with the accociated copperlist.

       This routine will wait until the next frame to ensure 
       smooth transitions.

       If you want the debugger to work properly, you MUST use
       this function to change the COP1LC-register. You may 
       only access this register manually if you do some kind 
       of copper-doublebuffering. If you change from one effect
       to the other you MUST call SetInt.

       If the debugger is called, it can not find out what
       copperlist you have set by peeking the hardware. It uses
       the SetDefault(), ClrDefault() mechanism to set it's own
       Copperlist and restore the old one, and these function
       rely totally on SetInt to find out your copperlist.
       If you change the copperlist manually, you must remember that
       after calling the debugger the copperlist you set with SetInt
       will be restored. Please design your Copper-doublebuffering
       carefully to handle these errors correct and ALLWAYS use
       SetInt() when you change from one part to another.

       This function is the most important function in SOS!

   INPUTS
       Enable   - Interrupt Enable, a comnbination of $0010, $0020 and
                  $0040 for copper, vertical blanking and blitter
                  interrupt. $0000 when no change of interrupts is
                  desired.
       Copper   - Pointer to Clist or 0 (use old one)
       Irq      - Pointer to your IRQ code, unimportant if Enable=0.

   NOTES
       This routine may NOT be called from interrupt. Use 
       SetIntFast() instead!.

   BUGS

   SEE ALSO
       ClrInt(), SetDefault(), ClrDefault()

***************************************************************************** 
TEXT.library/PrintF                                       TEXT.library/PrintF
***************************************************************************** 

   NAME
       PrintF -- C-like textformater

   SYNOPSIS
       String = PrintF(FString,Args);
       d0              a0      a1

       char *PrintF(char *,ULONG *);

   FUNCTION
       PrintF like formating is done. %s, %d and %x are supported.
       You may specify a lenght. The result string will be passed
       to the output function set with SetOutput().

   INPUTS
       FString - format string
       Args    - pointer to arguments.

   RESULT
       String  - pointer to result string.

   NOTES
       The output buffer is limited to 2000 characters.
       There is only one output buffer. If you call PrintF() a
       second time, the same buffer will be reused!

   SEE ALSO
       SetOutput().

***************************************************************************** 
TEXT.library/SetOutput                                 TEXT.library/SetOutput
***************************************************************************** 

   NAME
       SetOutput -- Set output routine for PrintF

   SYNOPSIS
       SetOutput(Code)
                 a0

       void SetOutput(void(*)(char *));

   FUNCTION
       Set the output function that is used by the PrintF()
       function. The prototype of this function is:

           void Code(String)
                     a0

           void Code(char *);

   INPUTS
       Code - your print routine.

   BUGS

   SEE ALSO
       PrintF().

***************************************************************************** 
AGAC.library/AGAMODIFY                                 AGAC.library/AGAMODIFY
***************************************************************************** 

   NAME
       AGAMODIFY -- Modify register in copperlist

   SYNOPSIS
       AGAMODIFY Label,#Value    (MACRO)

   FUNCTION
       The Label will be interpreted as the label before a copperlist
       instruction. The Value will be copied in the value-field of
       the copperlist-instruction, i.e. Label+2.

   INPUTS
       Label  - Label of the copperlist-instruction
       Value  - Value to copy, including # for immediate values.

   EXAMPLE
       see AGABEGIN

   BUGS

   SEE ALSO
       AGABEGIN, AGAEND, AGAMODIFY.

