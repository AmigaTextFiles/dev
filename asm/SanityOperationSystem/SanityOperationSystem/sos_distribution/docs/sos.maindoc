; ===================================================================
;
;                                 S O S
;
;                         Sanity Operating System
;
;                                 V 2.6
;
;
;                           Main Documentation
;
; ===================================================================


SOS Sanity Operating System by

Dierk Ohlerich (alias Chaos/Sanity)
Thuner Str. 181
21680 Stade
Germany

tel. 04141/69509

(c) copyright by Dierk Ohlerich 1994



1	Introduction

The  Sanity  Operating  System  (SOS)  is  a complete operating system
designed   to   simplify   writing   compatible  and  powerful  demos.
"Compatible" and "powerful" are antonyms.  It is easy to make a stupid
little  demo  that  runs  everywhere,  but  if  you  bang the hardware
completely  you  will  get  in trouble because of different CPU types,
memory  managment,  etc.   SOS  was  designed  to  supply all the many
routines  that  are  needed to take over the Amiga hardware completely
and replace the most important functions of the Amiga Operating System
such  as  memory  managment, IO and CPU control.  Further SOS contains
some  very powerful debugging aids and simplifies creation of trackmos
a  lot.   Allthough  complete compatibility wasn't reached by SOS, the
Arte  demo  build with SOS is perhaps the most compatible trackdemo in
the  top  10.   So if you are a coder you can't make too much wrong if
you use SOS.

I  originally  wanted  SOS  to be "trade secret" of Sanity.  I gave it
only  to  a  few friends and Sanity members.  But after the release of
Arte  and  the  Not Again demo by SCALA (Sanity Complex Avena Lego And
others) I got many letters from coders who wanted to have it, and even
want  to  pay for it.  It is also sad to see so many demos crash on my
A4000/40  just  because  of  lame  coding.  Perhaps the most important
reason  that  made  me  relase  this  System  is that many coders have
developed  their  own  SOS-like  systems.   These system often present
themself to the user with big system-info screens, and even more often
crash  immediatly  after  displaying the system configuration (or even
before).   Most  of these systems are simply crap, and I think none of
them  can  be  compared to this system, which is under development for
more then 2 years now (when it comes to trackmos).  It has been widely
tested in well known demos like Yesterday, World of Commodore and Arte
(and some more) and can be assumed as quite usefull.


1.1	Minimal configuration

SOS-Productions  should  run  on  all  Amigas.   Just 68060-processors
should make trouble.  But as an SOS-Developer you should have an a bit
more powerfull Amiga:

- Kickstart 2.04 or better is a must.
- 2 MB of RAM should be there.
- 2 Diskdrives or a Harddisk and a Diskdrive. Prefereble a Harddisk.

As  you  see,  this is not really much, but it has to be said.  Please
note  that all SOS-Tools need Kickstart 2.04 or better, and the SOSCON
Disk  writer  buffers the complete disk before it starts to write, and
therefore needs an 880KB Buffer, which is quite much for 1MB Amigas.

SOS  does  not need special amount of Chipmemory, it even helps saving
Chipmemory  by  supporting  the  standard  Amiga  sections in loadable
executables.


1.2	What do you get?

SOS can

- handle all CPU's from 68000 to 68040 correctly
- find all autoconfig memory expansions
- handle Genlocks correctly (with a little help from the application
  code)
- debug trackmos from harddisk
- write trackmos to disk in a very comfortable way
- write filedemos with simplified Memory managment
- help you debugging A LOT
- memory managment that allows to allocate 64k blocks in 64k
  alignement
- Very usefull memory managment for background effect loading
  and initialisation
- avoid memory fragmentation totally
- kill the operating system totally
- handle chip and fastmemory correctly
- load and relocate segments with respect to chip and fast memory
- support different crunchers
- can load and relocate crunched segments without memory overhead
- longtack support for games (contact me)
- supply an optional system that helps creating a complex trackmo
  from normed components. (Environment System)
- very easy to join effect to a trackmo
- automatic disk caching and prefetching (as Jesterday Musicdisk)
- a fast and awfull replay (in the environment handler example)
- the final demo will run with any operating system version.
- In some cases possible incompatibilities that are my fault can
  be fixed by an SOS-update that is easy to apply to the final demo.

SOS

- can't be bugfree
- can't handle pathnames
- can't work with absolute adresses (useless anyway)
- developers need Kickstart 2.0
- might be SLIGHTLY incompatible to old versions when updates come
- can't be frendly to the operating system and respect RTG
- can't make multi disk trackmos (planned)
- has limited memory managment for Filedemos. (better systen planned)
- doesn't yet support 68060 CPU's (give me a chance to test it and
  you get it!)

You  must  keep  some  rules in mind:  If you use SOS, you must use it
entirely.  You can not mix SOS and Kickstart, and you must follow some
coding  guidelines  under SOS.  These guidelines will not harm your in
any  way,  it's  simply that you must follow certain rules to keep SOS
running.   Some  rules  might  be  "hard" for you, but these rules are
unavoidable, like "never use absolute adresses".


1.3	Installing SOS

The  best  way  of  installing  SOS  is  to  copy the SOS_DESTRIBUTION
directory  somewhere  on  your harddisk.  Don't change anything inside
this  directory  (like  putting  your own effects in there), since the
easiest  way  of  installing  a  new SOS version is to rename your old
directory  and  copy  the new one to your HD.  If everything runs, you
can delete the old one.

Copy the file s/sosdirs to your s:  directory.  You may need to modify
it  after  you  found out what it's good for.  The contens of the libs
directory must go to LIBS:.  You will need 2 assigns set up:

   assign SOSBIN: sos_distribution/sosbin
   assign INCLUDE: sos_distribution/include

It  might  be neccessary to use the "ADD" option for the second assign
to  avoid  problems  with a possibly installed C compiler.  You should
not  mix  the  sos/include directory with the include directory of you
C-compiler.   Otherwise  you  will  get  in deep trouble each time you
update  your  C  compiler.   SASC  advises  you not to change anything
inside  your  SC directory.  You should follow this advise and use the
"ADD" option.

You will want to have a path to the SOS CLI utilities. 

   path sos_distribution/tools


That's all you must do to install the SOS development package.  If you
want  to  show  your  (unfished)  effects  to  somebody,  you need the
sos.librarary and a s:sosdirs file.  The final production will need no
further files to run.



2	The SOS System

The SOS library consists of the following components:

- Kernal that resets the hardware to a defined situtation.
 - Stackpointers
 - VBR = 0 (don't rely on this one)
 - set some variables to reflect system configuration
 - scan memory in a Kickstart conform way
 - enable caches

- cache control code that allows you to make selfmodifying code
- complete trackmo dos with filesystem
- usefull utility functions for copperlists, fading, random, etc
- simple screen for error messages.
- complex debugging utilities including the full featured monitor MOD3
  (you won't need an action replay any more to debug your software)

All  SOS  functions  can  be  called  like normal Amiga shared library
functions,  but  SOS  is  usually  not  a  real  shared  library under
Kickstart.


2.1	Implementation

SOS  is  now  version  2.6.   but beside the version number, sos comes
allways  in  different  VARIATIONS.  The most important variations are
the RUN and the DEV variation.

The RUN variation will be written to the bootblock.  You create a file
that  contains a list of filenames.  Then you start the SOSCON program
that  writes  all  files  specified by your input file to the disk and
puts  the  SOS  RUN  variation  into  the bootblock (and the following
blocks).   If  the  disk  is  booted,  the RUN variation will kill the
system and start the demo by loading a file called LOADER.

This  is totally useless for developing a trackmo.  Especially because
all  parts  can only be tested when SOS is running.  Therefore I wrote
the  DEV  variation.   If you start a SOS program from shell by typing
SLOAD  <your  filename>,  SLOAD  will  load  the  SOS  system and your
program, and then start SOS with your program.  SOS will take over the
hardware  in  a system conform manner.  It will restore Kickstart when
your demo has finished.  It will switch back to Kickstart whenever you
want  to  load  something  from disk, and resume your demo when it has
finished  loading.   Your  demo will run from Harddisk just the way it
would run from Trackdisk, you will need to track your demo only in the
last  phase  of  development.   The  demo  will  only  notice  a small
difference between RUN and DEV.  In the DEV variation, all Disk access
seems  to be finished immediatly because SOS completely stops the demo
and  start  Kickstart.   During the disk access the demo is paralysed.
It won't notice that time passes.  If you track your trackmo you might
get  timing  problems because of the load times.  You will see that it
is not advisable to release a demo in the DEV version since it will be
interrupted at each disk access.  I have started to include some hacks
in  the  system  to  make  good  looking demo in DEV mode possible (->
harddisk installable demos), but I havn't finished it.

When  the  DEV  mode  is  initialising  itself, it loads a file called
S:SOSDIRS.   This  file  contains  a  number  in  the  first  line and
directory  names  in all other lines.  The number tells the system how
much  space  it  must  allocate  for  filenames.   Then  it  loads all
directories  you  specified  and  the current directory.  SOS knows no
path names.  You must specify all filenames without path.  If you want
to  open  a  file,  SOS  looks  in his file list and finds out in what
directory  the  file is located.  You can imagine that all directories
you specified make a big directory for SOS.  Problems can arise if you
have  two  files with the same name.  The first one will be taken, and
that  might  not  be  what  you  had  in  mind.  The system will crash
completely  if  you  specify the number of files to small, sorry.  You
may  comment  out some lines by setting a ';'.  The meaning of this is
to  simplify  comming multi-disk-trackmo support.  Then all Disks will
merge  into a common and your demo could run without taking care about
diskchanges.  I plan to allow you to implement your own code that asks
the user to turn the Disk.  But I don't know when I will implement all
this.

There  is  a  second  method of entering the DEV mode.  If you use the
(somewhat  larger)  INITSOS2  macro at the beginning of your code, you
can  start the code directly from Workbench or Shell without the SLoad
program.   In  this  case an amiga shared library called "sos.library"
will  be  used.   This  mainly  allows  you  to  use simple integrated
development  environments  as  the  seka-clones  have.   I  personally
recoment to use assemblers with a real command line interface.

A  third  variation of SOS is the hybrid variation.  In the last phase
of  developing  a demo you might need to track it to disk and check if
all  timings  are  correct.   You  might  be  unable  to  see  if  the
transitions from one effect to the next are clean when you use the DEV
variation  because  the  DEV  variation of SOS lets the screen flicker
when  it  switches  to  Kickstart to load something with AmigaDos.  It
might  nerve  you  to reboot your machine for each test cycle (writing
the  data  to  disk is bad enough).  The hybrid variation combines the
memory  model  of the DEV variaton that allows to start and exit demos
safely  with  the  trackdisk reader of the RUN variation that does not
need to switch back to the system.  You must type "SLOADHYB loader" to
check  the  complete  trackmo or "SLOADHYB <your filename>" to check a
single  file.  You might have some fun with the latest SOS productions
NOT  AGAIN  and  ARTE,  because you can load individual effects or the
complete  demo  with  SLOADHYB  and  still exit back to Kickstart (try
"SLOADHYB main" with Arte)

If  you  want  to  make  filedemos,  you  may  use  the SOS_RAM2MB and
SOS_RAM3MB  variations.   These are used in executbles that contin all
disk  data.   These  will  be  loaded completely into memory, and then
simulate  a  RAM-disk  that allows your Trackmo to execute as a normal
Trackmo.   Assume that you planned a demo for 1MB of RAM.  If you want
to  start  as a filedemo, you need 880K for the disk-data.  Since 120K
are  not  sufficiant  for the OS, you must kill the OS if you want the
demo  to  run  on  an  2MB  Amiga.   This  is  what  SOS_RAM2MB  does.
Unfortunatly,  it  is  not  at  all save to kill the system unless you
start from the bootblock.  MMU-Tables and other progamms may have been
started, and therefore you should use the 3MB-Version, that needs just
bit  more Memory (not really 3MB, more like 2.4 MB) to run because the
OS  will  be  preserved.   It also allows to return to the OS.  If you
don't need the whole disk, you might even be able to start small demos
on a 2MB Amiga using the 3MB-Version. 

You  should  never  use the 2MB Version unless you have a good reason.
Notice  that  the  names  2MB  and  3MB refere to the amount of memory
needed  to  start  a  demo as a filedemo that was designed to run as a
trackmo on 1 MB Amigas


2.2	How to write SOS programs

All  SOS  programs  that  should  be  loadable  from  SLOAD, SLOADHYB,
Trackloader  or  the  effect handler LOADER must start with one of the
macros INITSOS or INITSOS2.  These macros contain a header that allows
the  system to recognise them as SOS programs.  If you use INITSOS and
start  the file from shell you will get an "unkown command" error.  If
you  use  INITSOS2  (which is a little bit longer) the macro will load
the  "sos.library"  and initialise the SOS system before starting your
program.  It will also handle Workbench start properly.

Your  code  will be called with a pointer to some kind of library base
in a6.  All SOS functions must be called with this pointer in a6.  All
SOS  functions  change  d0/d1/a0/a1  and  no  other  registers  unless
otherwise documented.  Some SOS functions are called by traps.

You  may  not  rely  on memory cell 0 containing a zero.  Not even for
killing the sprites (see SETCSPR macro)

You may not access variables from the SOS base.  This structure is not
documented  and  changes  from  VARIATION  TO  VARIATION.   The Public
Information   System   Structure  (PISS)  provides  a  window  to  all
interesting variables (see GetPISS())

The  Vector Base Register (VBR) might be changes.  At the moment it is
kept  0,  but  I  might shift it to fast memory for future versions of
SOS,  so  if  you  want to stay compatible you may not access exection
vectors  directly,  you access them relative to the VBR value that can
be optained from the PISS.  Setting the VBL must be done with SetInt()
or  simiar  funcitons  anyway, and if you want to jump into supervosor
mode you can use trap 14.

Trap  0-3  are used by the MOD3 monitor, Trap 12-15 by the SOS system.
avoid these traps, or better, avoid all traps.

All  waiting  loops in replays must be converted into cia timing.  dbf
loops  are  not usefull nowadays.  You may not acces the CIA timers by
youself,  you  must  use the (very handy) WaitTimer() and CauseTimer()
calls.   Otherwise you might irritate the diskloader.  In other words:
you will need to change the replay you use.

If  you  want  to  be  Genlock  compatible,  you  may  "or"  the value
PISS_BPLCON0  to  all  accesses  (including  copper)  to  the  BPLCON0
register  ($100).   See  the  GENLOCK macro in include/sosmacros.i for
full details.

All  exeptions  that  are not used otherwise will be caught.  You will
find    all   registers   at   the   given   adress   in   the   order
d0-d7/a0-a6/SSP/USP/SR.l/PC.   If  you  use the MOD3 debugger, you can
examine these registers more comfortably.

If  an SOS command fails, it will jump directly into an error routine.
You  can  not  check  for  errors,  all  error handling is done by the
system.   Where  is  a reason to continue a demo if a file couldn't be
found?   In  demo  coding there is no need for error checking.  Either
the  demo  is  working  or  it isn't.  But some functions allow you to
avoid  these  errors  before  they  happen,  like CheckForFile() which
allows you to check for the existents of a file before you open it.

You  may  use  the  memory  from  $400  to $7ff for absolute variables
without  any  fear  (Piss  of all OSlamics.  There's no kickstart left
when  SOS runs therefore there can and will be no problens!).  You may
use  the memory from $100 to $3ff for absolute variables with the risk
of  incompatibility to future amigas.  You may not use the memory from
$000  to  $0ff  for  absolute  adresses.  $0c0 to $0ff is reserved for
coprocessor  exeptions, $000 to $007 is reserved for SOS, $008 to $0bf
is used for processor exeptions.


2.3	SOS and Kicksart

If  you  use SOS you must not use Kickstart.  Your program may not use
SOS  and Kickstart includes simultaniously.  Many names are similar or
the   same.   I  called  my  functions  like  Commodore  called  thier
functions.   There  is  simply  no better name for opening a file then
Open().  This will not be a problem since SOS and Kickstart can not be
used  in  the  same program anyway, and you should NEVER try to.  Also
note  that  things  that  are forbidden when using Kickstart (like low
memory  access) are quite normal and totally compatible under SOS.  So
you should better switch off your enforcer.


2.4	SOS Utilities

2.4.1   SLOAD file

Loads  and  starts the DEV variation of SOS.  Then the SOS loadsegment
function  loads  your  file which must be an SOS program starting with
the  INITSOS  or  INITSOS2  macro.  Then start SOS and you program and
return  to  Kickstart after your code has terminated.  It is important
to  know  that the SOS loadsegment loads the file, since it differs in
some  details  from  the  original  loadsegment.  It supports crunched
Segments but it does not support debug and symbol hunks.


2.4.2	SLOADHYB file

Load  the  HYB  (hybrid)  variation  of  SOS  and start your file from
trackdisk.   All  Disk  accesses will be performed on trackdisk.  When
your  programm  terminates  SLOADHYB  will return to Kickstart safely.
Use loader as filename to load the complete trackmo


2.4.3	SOSCON file,drive/a,install/s

If you specify a file and a drive (like df0:, df1:,...), the file will
be  read  and  treated  as a list of filenames.  All files will be put
onto  a  disk  in  the  specified  drive.   Then  a bootloader will be
installed.  This loader contains the SOS RUN variation.  It will (when
you  boot  the disk) load a file called loader that has to be supplied
by you and start it.

If  you  specify  only  install, only the bootblock will be installed.
This  option  was  used  by  me  (the  Author) to quickly test new SOS
versions without having to track the complete demo.

If  you specify a filename instead of the diskname all data (including
bootloader) will be written to that file.


2.4.4	SEGCRUNCH FROM/A TO/A SPEED/A

A standard Amiga executable segment will be loaded and crunched into a
format  that  can  be  processed  by  the  SOS  loadseg function.  The
crunched parts will be automatically recognised by LoadSeg without any
change in your function call.  You can allways crunch segments without
changing  your  code  if  you need to squeeze some bytes, but you must
mind  the decrunch time.  Speed values range from 0 to 11, I prefer 3.
Low values are unstandable slow.  A version of Imploder is used that I
ripped out of beermon.


2.4.5	SOSRAM FROM/A TO/A 2MB/S 3MB/S BRIEF/S

This command read a disk-image file as produced by SOSCON (or by
yourself) and creates a 2MB or 3MB (default)-type Filedemo (see above
for a definition of these terms). It will give you some statistics
that can be suppressed by the BRIEF option. The result is a ready to
spread filedemo.


3	The system documentation

All  detailed information can be found in the autodoc file.  This file
explains  the  fundamental  issues that are difficult to understand in
the autodocs.

The  following  subchapters  will  tell  you  something about the most
important  aspects of SOS.  But you should read the autodocs carefully
because  you  will find  a lot of usefull functions there that are not
mentioned here.


3.1	Setting interrupt and copperlist

The  most  important  command  of  SOS is SetInt().  You must set your
VBL/Copper/Blitter  Irq  and  your  copperlist with this command.  You
MUST  use  this command!  You will understand this when you read about
memory  managment.   At  the  moment  just  an  explanation  about the
copperlist.   The  value  you supply will be stored.  If you start the
debugger,  it  will build it's own copperlist.  To enable the debugger
to  restore  your  old  copperlist it must know about it's adress, and
that  adress  can't be read from the hardware.  The SetInt() call will
store  the  adress  and  the  debugger  can  read  it later.  (in fact
SetDefault() and ClrDefault() are used, the debugger must not read the
value, all work is done by SOS.)



3.2	Memory managment 

There  is  an  AllocMem()-  function  that  behaves  just as you might
expect.   It  can  even  handle chip and fast memory.  But there is no
FreeMem()  function.   Ok, there is a FreeMem() function, but it's not
working as good as you might hope.

SOS  allocates  memory  in a stack.  For each chunk of memory (usually
there  are  1 to 3 of these chunks, one for chip, one for fast and one
for  a memory expension.  SOS can handle up to 6 chunks at the moment)
two  pointers  are maintained that point to the start and the end.  If
you  allocate  memory,  these pointers will be increased or decreased.
Normal memory allocations with AllocMem() will be taken from the lower
end  of  the chunk.  If you want to allocate a block of memory that is
aligned to a 64K border, the upper end of the chunk will be used.  You
can  not simply free some memory from the middle of the block, because
no  real  list  of free memory blocks is maintained.  So don't use the
FreeMem()  command,  it's not working correctly if the block of memory
is not at the end of the chunk.

The  correct  way to free Memory is to call FreeAll().  SOS has stored
the original start and end adresses of all chunks.  FreeAll() restores
them.

But  this is too primitive.  SOS implements some kind of memory stack.
You  may  call SetDefault() to store the current memory status on that
stack  and  ClrDefault()  to  pop the status back.  But these commands
also  push  and  pop the values set with SetInt:  The interrupt vector
and  the copperlist.  Each interrupt and copperlist is associated with
a  memory  status.   You  can't  pop  the  memory when a copperlist or
interrupt  still  needs  the memory.  I think this function makes well
sense.

The  ReLoad()  command will help you to load the next part of the demo
without having to leave the loader in memory.

Usually  a trackmo works like this:  First the loader loads the module
and similar stuff.  Then it calls SetInt to setup a default copperlist
(black) and a default interrupt (music).  SetDefault saves the current
structure.   Now  you  can  load  and  execute an effect (ore multiple
effects), afterwards you reset the memory with ClrInt() (this restores
the  old  values  without poping them from the stack) or ClrDefault().
You  can  allocate  a  small  amount of memory (64-128K) in the loader
before SetDefault().  You can make a small effect or display a picture
with this memory while you load the next part(s).

The   advantage   of   this  system  is  that  you  can  avoid  memory
fragmentation.   You  will  also  not  need  to care about freeing the
memory.  The disadvantage is that you can't show effects alternating.

But  this is still too primitive for complex demos.  Therefore you can
switch   SOS   into  alternating  memory  mode.   Once  enabled  (with
InitAltMem()),  all  memory  allocation (64K-block or normal) are done
either  from  the  top  or  the  button of the memory chunks.  You can
toggle  the  direction  with  AltMemory().  If AltMemory() switches to
allocation  from  low adresses, the lower adresspointers will be reset
to default, and vice versa.

How to use it?

First  you load your loader, reply, module and other stuff that is the
same  for  all effects.  Then you enable the alternating memory system
with  InitAltMem().   Now you make shure that all effects only contain
an   initialisation   and   an  interrupt.   After  the  interrupt  is
initialised,   the   effect  must  return  immediatly.   You  may  use
Softwareinterrupts  to  start  proceses  that  run  in the background.
Between all effects you call AltMemory().

First  you  call  InitAltMemory().   All  allocations  are done in the
lowerr  memory  region.   The first effect will be loaded, initialised
and  started.   While  the  effect runs, AltMemory() must be executed.
the  second  effect  will  be  loaded,  initialised, and (syncronised)
started in the upper memory region.  You call AltMemory() again.  This
resets  the  lower  memory  pointer and kicks out the first effect.  I
just  hope  its  code and data is not needed anymore, since the second
effect  is running at this moment.  Now the third effect can be loaded
over the first one in the lower memory region.

This  allows you to switch from one effect to the next one without any
gap.  You don't even need a textpage.  But you must take care that two
squential  effect fit together into the memory.  If you have problems,
you  can  first  do  complex initialisation, then call SetInt() with a
dummy  copperlist  and  IRQ,  then  kick  out  the  other  effect with
AltKick(),   then   allocate   more  memory,  do  (hopefully  trivial)
initialisation  for  the  new  memory and then start (syncronised) the
main IRQ and Copper.  This gives you absolute minimal switching times.

Be  shure  that  not both current IRQ and following initialisation use
the  Blitter,  otherwise crash.  It is no problem to call disk loading
routines  from  SOS in the initialisation.  You should not use 100% of
the  processortime in the IRQ if you want to do initialisations in the
background,  but usually the used time varies a lot (with object size,
fade  in/out,  building  up  the  effect,  music  replay  etc).  It is
suficciant if at least sometimes a bit of time is left.



3.3	DOS

SOS  does  not  know about subdirectories.  The disk is treated as one
unit.   The  DEV  variation  links  this  unit of files from different
directories by reading the S:SOSDIRS file (see explanation above).

There is not much to say about DOS.  Load(), LoadSeg(), LoadDecrunch()
load   files   completely.    Open(),   Read(),  Seek(),  Close()  and
GetFilePos()  can  be  used  to  load parts of a file.  CheckForFile()
checks if a file is present.


3.4     Screen

You  can access the simple screen that prints the error messages.  This
is  quite  useless for a demo since this screen is really bad looking,
but you might have your reasons (extended debugging, etc.)


3.5     Timer

You  may  not  use  DBF-loops  for  waiting.  I think this is clear to
everybody.   The CauseTimer() and WaitTimer() functions will provide a
simple  interface  to  the  CIA  hardware.  You may not access the CIA
hardware  by yourself, otherwise these functions can not work anymore.
Since they are used by the trackloader there is no way to avoid them!


3.6     Libraries

To reduce the size of SOS, I removed some parts to external libraries.
They are similar but not the same then normal Amgia shared libraries.

See the examples to understand how libraries must be build.

You  must  use  the  OpenLib()  function  to  load them.  They will be
removed  when  you  pop  the  memory  of  the library with ClrInt() or
ClrDefault().


3.7     Cache

You  can  access  the  Caches  with  Trap #13.  A parameter in d0 will
select  one  of  many  functions.   Mainly  you will use T13_Standard,
T13_Paranoid,  T13_BigTable  and  T13_ModFlush.   The  actions  may be
different  for  different  CPU's.   Especially 68040 processors need a
completely different handling.

T13_ModFlush  will  do  all  cache  actions  that must be done to make
selfmodifying code work.

T13_Standard  will  enable  all caches, T13_Paranoid will disable them
all.   T13_BigTable  will set the caches in a way that increases speed
when  you  work with many memory accesses to big tables (especially on
68040 processors).


3.8	Disk Prefetch and Caching.

You  can  initialise  a complete disk caching system by simply calling
InitDiskPrefetch().   From  now  on  free memory will be used to cache
every  disk  access.   You can start a disk prefetch action by calling
PrefetchDisk().   Then  SOS will automatically use free processor time
to prefetch some tracks from disk.


4	Environment-Pointer

SOS  allows you to read and write an environment pointer.  You can use
it to pass paramters from the loader to the effects, like a pointer to
the  replay.  You can use this pointer as you like, and you may ignore
it.  But if you use the default environment system and it's macros you
will  save a lot of work and get compatibility with everybody who uses
it too.

When  we  made the SCALA demo, it was possible to combine effects from
many different coders that have never worked together before in a very
efficient way because all used this system.

The  environment system discribed here is as good as any other system.
It is not prefered by the SOS library.  It is only a set of rules that
have  advantages  if you follow them.  You might write your own system
as well as using this, or you may use no real system.  But many of the
debugging  features  are  implemented here and not in the SOS library.
Therefore  you  can  disable  them  easily or replace them by your own
system.   Ofcourse  you can easily implement the debugging features in
your own system.

The environment pointer is part of the PISS (Public Information System
Structure). My environment system can be found in include/sosmacros.i


4.1	Features of the Environment Standard

The environment standard allows you to set the following properties:

- additional interrupt routine (for replay)
- additional background routine (disk prefetch, debugger call)
- syncronised start of effect
- syncronised end of effect
- pointer to a memory pool (see memory managment above for usage)

If  you  use  the  environment macros as discribed in the examples and
autodocs, your programm will have the following functionality:


4.2	Starting from SLOAD/Shell

If  you  start the effect alone, perhaps for debugging and development
of  the  effect,  it  will  set  up  it's  own  environment (since the
environment  pointer  is 0).  This will contain (if you have specified
ENVINIT ENVFf_Normal,$1000) an interrupt routine that checks the right
mousebutton.  If it is pressed, the effect will be aborted.  I use the
right   mousebutton   because  it  is  less  critical  to  have  right
mousebutton  clicks  at  random  position  on  the workbench then left
mousebutton  clicks.   The  main  loop  will check if the debugger was
called.   If  you  press fire button and any key you will get into the
small  system  debugger  (see  below  for  detailed discription).  The
effect  will  start immediatly and stop after $1000 frames (the number
specified  at ENVINIT).  If you set ENVFf_Memory, a 64K buffer will be
allocated for the memory pool.


4.3	Writing a Loader that sets up the Environment

If  the effect is called with the environment pointer set, it will use
the  given  environment instead of building it's own.  It is now up to
you  to  create  a  loader  that  loads  the  effects  and  sets up an
environment.   You  may  leave  the  debugging  features  intact (as I
usually  do) or you may remove them.  You may use the ENVINIT macro to
create  the  default environment or you may do it by yourself.  In all
cases  you  will  want  to  add  your  own  replay  to the environment
interrupt pointer.  You may code the sequence of effects in assembler,
or  you may code a list, or you may even write an interpreter.  Its up
to you.


4.4	Example Effect Handler.

I wrote a quite complex effect handler that has a build in interpreter
language to handle the sequence of effects.  a file called script will
be  loaded  that  holds  information  about  memory  managment and the
effects. Unfortunatly, this system is not documented in any form. If
you are lucky, then there is a complete example of a filedemo or 
trackmo that shows how to use the effect handler.

Very  interesting  is  the  music replay in this handler.  See it as a
"bonus"   of   the   SOS  package.   It  follows  the  same  copyright
restrictions  as the whole package.  It is very fast, but doesn't play
all  effects.   Use  at  own  risk, and allways send a preview to your
musician, otherwise he might rip off your head.


5       The Debuggers

The DEBLOAD macro loads the small system debugger.  If you call DEBJOB
regulary,  you  can  jump  with "joystick fire + a key" into the small
system  debugger.  If the key is a valid command key, the command will
be executed immediatly.  Otherwise a small menu will be displayed.

You  can  activate  the  big debugger, MOD3, by pressing "d".  In this
case  a  file calles MOD3_SOS will be loaded, this is usually the MOD3
debugger, but you can put your own file here.

The  small  system  debugger  resides in the DBUG.soslibrary, which is
available  as source in this archive.  You may change or even exchange
it.   You  must  leave  the copyright notice intact, even if you write
your  completely  own debugger.  You may add your own copyright.


5.1     Commands


5.1.1	A - About

Just a small copyright message


5.1.2	C - Continue

Exit the monitor and continue the demo


5.1.3	D - Debugger

Load the big debugger MOD3.

Mod3  was  build  to  work  with  intuition.   Normally,  MOD3 opens an
intuition  screen  and  multitasks  well.   But  it was designed to be
adeptable  to  any 680xx system, and therefore it was easy to adept it
to  SOS.  This program is very buggy and not really finished.  But
even in this unfinished state it is very powerfull, by far superior to
beermon and action replay if you want to debug your programs.

There  is  no english documentation about this program, but it is easy
to  use.  Press help for a small list of commands (an * tells you that
the  function has been implemented, all other functions do not exist).
You  may  use  any expression whereever you need to type a number at a
command.   Therefore hexadezimal numbers must start with a $.  You may
use  labels or register names wherever you want.  Some funtions woun't
work  properly  with  SOS as they are designed for Kickstart (like the
reassembler).

Since  the  debugger runs on the same stack as the demo, you can't use
the  trace and go commands.  If you want to trace, you must first load
MOD3_SOS  (from  shell) and then your programm (with lo).  Now you can
use the tracer (I hope).

If you call the debugger after an exeption you will be able to examine
all  registers.  If you call it after another error or the hotkey, you
will find other usefull values in the registers:

a5,  a6  and usp are unchanges, since they usually hold the variables,
the SOSBase and the stack.

a0  and  a1  hold  the  first  2 values from the stack, usually return
adresses  to your code.  a2 points to your interrupt routine and a3 to
your copperlist. You can view the Copperlist by typing "c a3".


5.1.4	M - Memory

Output a list of free memory.


5.1.5	S - System

Display system configuration.


5.1.6	X - Exit

Exit to Kickstart if possible.


5.2	Copperliste and Debugger

You  must  use  the  SetInt  command  if  you  change your copperlist.
Otherwise the debugger has no chance of restoring your copperlist.


5.3     Other features

You  will  be able to abort most faulty programs.  But if you run into
an  dead  end loop there is no way stopping it.  If you have an action
replay, you should jump to $120.  This will clean up things and return
safely  to Kickstart.  You can also try to modify the dead end loop to
crash  with an exeption.  The exeption will be properly caught and you
are back in control.


6	Stuff


6.1	Tips & Tricks (legal and illegal)


6.1.1	AGA-Detection

If  you  use  code  that  adepts  itself  to  a given configuration by
checking the PISS, as the AGAC.soslibrary does or perhaps special code
for  large  blit  Agnus,  you may change the PISS directly to test how
your  code  behaves.   This is ofcourse illegal, but if you remove the
modification code in the final version, it's OK.

;	jsr	_GetPISS(a6)
;	move.b	#0,PISS_Level(a0)	; no AGA will bedetected




