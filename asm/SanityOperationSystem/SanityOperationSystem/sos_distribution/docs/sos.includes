-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                                 S O S
;   
;                         Sanity Operating System
;
;                                 V 2.6
;
;
;                              Include-file
;
; ===================================================================

; ===================================================================
;
; Variations when assembling SOS:
;
; DEV        Development-Variation (restore Kickstart after demo)
; RUN        Runtime-Variante (kill Kickstart)
; DOSDISK    Use AmigaDos
; SOSDISK    Use hardware trackloader
; RAMDISK    Load all data into ram and use as ramdisk.
; LONGTRACK  use longtracks for trackloader
;
; Variations when assembling applications:
;
; HARDWARE   Your hardware base.
; DEBUG      Debug color-bars for timing.
; NORMBX     Right mousebutton will not stop demo. For ENV-macros.
; CHIPMEM    force all sections to chip if you use SEC-macros.
;
; ===================================================================


		IFD DEV			; set up defaults
		IFND	SOSDISK
		IFND	RAMDISK
DOSDISK		EQU	1
		ENDC
		ENDC
		ENDC

		IFD	RUN
		IFND	RAMDISK
SOSDISK		EQU	1
		ENDC
		ENDC

		IFD	DEV
		IFD	SOSDISK
HYB		equ	1
		ENDC
		ENDC

		IFND	LONGTRACK	; set up disk geometry.
DSK_Sectors	equ	11
DSK_SecMask	equ	$7ff
DSK_Lenght	equ	$3200
		ENDC
		IFD	LONGTRACK
DSK_Sectors	equ	12
DSK_SecMask	equ	$fff
DSK_Lenght	equ	$3ffe
		ENDC

; ===================================================================
;
;  Hardware-Register
;
; ===================================================================

	include	"include:sos/soshardware.i"

; ===================================================================
;
;  Konstanten
;
; ===================================================================

SOSVERSION	equ	2		; Version 
SOSREVISION	equ	6		; Revision 
SOSRELEASE	equ	13		; Release 

SOSTRUE		equ	-1		; TRUE: everything not 0
SOSFALSE	equ	0		; FALSE: 0
BTRUE		MACRO			; branch if true
		bne.s	\1
		ENDM
BFALSE		MACRO			; branch if false
		beq.s	\1
		ENDM

; ===================================================================
;
;  Equates
;
; ===================================================================

;
;  Memory aatributes
;

MAT_PUBLIC	equ	0		; Any memory
MAT_CHIP	equ	1		; ChipMem
MAT_SHORT	equ	2		; ShortMem (obsolete)
MAT_CLEAR	equ	$40		; Clear memory
MATb_CLEAR	equ	6

;
; Timer units
;

TI_MICRO	EQU	1		; microseconds
TI_MILI		EQU	2		; milliseconts


; ===================================================================
;
;  Public Info System Structure
;
; ===================================================================

; this structure holds information about SOS, the hardware and
; input from Mouse and Keyboard.

		RSRESET
PISS_TurboCPU:	RS.W	1		; CPU value(dezimal 00/10/20..)
PISS_TurboFPU:	RS.W	1		; FPU value
					; 0 = none
					; 1 = 68881 or 68882
					; 2 = 68040
PISS_TurboMMU:	RS.W	1		; MMU value
					; 0 = keine
					; 1 = PMMU
PISS_TurboVBR:	RS.L	1		; Vector-Basis-Register (VBR)
					; allways access exeption vectors
					; relative to this adresss!
PISS_Configur:	RS.W	1		; free for future extensions
PISS_Computer	RS.B	1		; Amiga, Atari (see below)
PISS_Level	RS.B	1		; OCS,ECS,AGA (see below)

; These variables can be used to read the amount of free memory.
; TopicMem and TotalMem point to "MemAgents" that hold the current
; and total memory size. Each MemAgent consists of "Chunks" chunks.
; each chunk countains the Start- and Endadress of the memory if
; controlls. the first "ChunksPublic" are of type "AnyMem", the others
; are ChipMemory.
; These information is only provided to allow the debugger to display
; the amount of free memory. Don't use it for other then diagnostic
; applications, because the way SOS handles it's memory might change 
; in future.

PISS_TopicMem:	RS.L	1		; Zeiger auf TopicMem
PISS_TotalMem:	RS.L	1		; Zeiger auf TotalMem
PISS_Chunks:	RS.B	1		; Anzahl Chunks insgesamt
PISS_ChunksPublic: RS.B	1		; Anzahl Public Chunks

; Now hardware dependent things:

PISS_Copper:	RS.L	1		; current Copper-Liste
PISS_BPLCON0:	RS.W	1		; Genlock-Value for BLTCON0

; More memory (V1.8)

PISS_DefaultMem: RS.L	1		; current MemNode

; Dos (v2.0)

PISS_Directory:	RS.L	1		; Pointer to directory

; Environment (2.1)

PISS_Environment: RS.L	1		; Environment-Variable

; Input (2.1)

PISS_Key:	RS.B	1		; KeyCode
					; If you have read a key with
					; GetKey() that you don't
					; need, you should write it 
					; back here. This will allow
					; the character to be read again.
					; This is my hopeless try to implement
					; some kind of simple input-handler.
PISS_pad00:	RS.B	1
PISS_LMB:	RS.B	1		; 1 = left button currently pressed
PISS_RMB:	RS.B	1		; 1 = right button currently pressed
PISS_LMBFlag:	RS.B	1		; 1 = left button has been pressed 
PISS_RMBFlag:	RS.B	1		; 1 = right button has been pressed
					; the last two flags are set by SOS
					; and must be reset by you after
					; reading.
PISS_MouseX:	RS.W	1		; maus X delta
PISS_MouseY:	RS.W	1		; maus Y delta

; Parameters (v2.2, Release 10)

PISS_Parameter:	RS.L	1		; New parameter passing since v2.2
					; points to an array of pointers
					; to parameter strings. end with 0

PISS_SIZEOF	EQU	__RS

; ===================================================================

PISSC_AMIGA	equ	1		; AMIGA
PISSC_ATARI	equ	2		; ATARI

; COMMODORE Amiga

PISSLC_OCS	equ	1		; original chip set
PISSLC_ECS	equ	2		; full enhaced chip sEt
PISSLC_AGA	equ	3		; AGA- chip set
PISSLC_AAA	equ	4		; AAA chip set

PISSFC_LARGEBLT	equ	$0001		; large blits possible (ECS blitter)

; ATARI ST

PISSLA_ST	equ	1		; ST
PISSLA_STE	equ	2		; STE
PISSLA_TT	equ	3		; TT
PISSLA_FALCON30	equ	4		; Falcon 030

PISSFA_BLITTER	equ	$0001		; Blitter available


; ===================================================================
;
;  Disk
;
; ===================================================================

					; Directory entry. 
					; should be private
RB_Block	EQU	0		; offset for first byte
RB_Lock		EQU	0		; directory lock
RB_Lenght	EQU	4		; length of file
RB_Name		EQU	8		; complete pathname relative to 
					; disk/lock.
RB_SIZEOF	EQU	32

; ===================================================================
;
;  Library-Struktur
;
; ===================================================================

		rsreset
LIB_Next	rs.l	1		; Nächste library in liste or 0
LIB_Name	rs.l	1		; Name literal of Library
					; NOT pointer, ULONG!
LIB_SIZEOF	rs.w	0

LIB_Pad0	EQU	-6		; must return 0
LIB_First	EQU	-12		; first free entry

; ===================================================================
;
;  Tags
;
; ===================================================================

STAG_DONE	equ	$80000000	; end of taglist
STAG_SKIP	equ	$80000001	; empty entry
STAG_MORE	equ	$80000002	; continue at position

STAGITEM	MACRO	; Tag,Value
		dc.l	\1,\2
		ENDM

; Never use STAGITEM for STAG_DONE, STAG_SKIP or STAG_MORE

STAGDONE	MACRO
		dc.l	STAG_DONE,0
		ENDM



; ===================================================================
;
;  SOS-Library
;
; ===================================================================

_LASTOFFSET	equ	-366
_AltKick	equ	-360
_ResetRand	equ	-354
_AltMemory	equ	-348
_InitAltMemory	equ	-342
_SetIntDev	equ	-336
_ModDefault	equ	-330
_CheckForFile	equ	-324
_ScanTagList	equ	-318
_OpenLibrary	equ	-312
_SetIntFast	equ	-306
_FreeMem	equ	-300
_ReLoad		equ	-294
_UnfinishedIrq	equ	-288
_GetPISS	equ	-282
_RemoveRamDisk	equ	-276
_LoadSegMem	equ	-270
_LoadDecrunch	equ	-264
_InitDiskPrefetch equ	-258
_PrefetchDisk	equ	-252
_CauseTimer	equ	-246
_WaitTimer	equ	-240
_MotorOff	equ	-234
_Save		equ	-228
_GetFilePos	equ	-222
_Seek		equ	-216
_Close		equ	-210
_Read		equ	-204
_Open		equ	-198
_GetKey		equ	-192
_CheckRelease	equ	-186
_PutScreen	equ	-180
_OpenScreen	equ	-174
_CloseScreen	equ	-168
_Fade		equ	-162
_SetCopperCol	equ	-156
_PPDecrunch	equ	-150
_DoubleBuffer	equ	-144
_LastRand	equ	-138
_FastRand	equ	-132
_FirstRand	equ	-126
_Randomize	equ	-120
_SetCopperAdr	equ	-114
_Error		equ	-108
_ClrDefault	equ	-102
_SetDefault	equ	-096
_ClrInt		equ	-090
_SetInt		equ	-084
_FileLength	equ	-078
_LoadSeg	equ	-072
_Load		equ	-066
_MemType	equ	-060
_FreeAll	equ	-054
_AllocBlock	equ	-048
_AllocMem	equ	-042
_BailOut	equ	-036
_StartIt	equ	-030

; ===================================================================
;
;  Trap13 Calls
;
; ===================================================================

T13_DataOn	equ	0		; Low Level, do not use
T13_InstOn	equ	1
T13_DataOff	equ	2
T13_InstOff	equ	3
T13_DataFlush	equ	4
T13_ModFlush	equ	5		; High Level Flushs
T13_PreDMA	equ	6
T13_PostDMA	equ	7
T13_Standard	equ	8		; High Level Setups
T13_Paranoid	equ	9
T13_BigTable	equ	10
T13_SetAll	equ	11		; INTERN !!!

; ===================================================================
;
;  Tastatur
;
; ===================================================================

; more information about these in AutoDoc GetKey()

ASC_SAE		equ	24
ASC_SOE		equ	25
ASC_SUE		equ	26
ASC_AE		equ	27
ASC_OE		equ	28
ASC_UE		equ	29
ASC_SZ		equ	30
ASC_APO		equ	96
ASC_CUP		equ	128
ASC_CDOWN	equ	129
ASC_CLEFT	equ	130
ASC_CRIGHT	equ	131
ASC_BACKSPACE	equ	132
ASC_DELETE	equ	133
ASC_INSERT	equ	134
ASC_HELP	equ	135
ASC_RETURN	equ	136
ASC_ESCAPE	equ	137
ASC_TAB		equ	138
ASC_SRETURN	equ	139
ASC_SCUP	equ	140
ASC_SCDOWN	equ	141
ASC_SCLEFT	equ	142
ASC_SCRIGHT	equ	143
ASC_F1		equ	144
ASC_F2		equ	145
ASC_F3		equ	146
ASC_F4		equ	147
ASC_F5		equ	148
ASC_F6		equ	149
ASC_F7		equ	150
ASC_F8		equ	151
ASC_F9		equ	152
ASC_F10		equ	153
ASC_SESCAPE	equ	154
ASC_SHELP	equ	155
ASC_KEYUP	equ	156

; ===================================================================
;
;  Startup-Macros
;
; ===================================================================

******* sos.library/INITSOS ************************************************
*
*   NAME
*	INITSOS -- Header for SOS-Programme
*
*   SYNOPSIS
*	INITSOS  Start         (Macro)
*	INITSOS2 Start         (Macro)
*
*   FUNCTION
*	Createa an SOS-Header as needed for SLOAD, SLOADHYB, 
*	the trackdisk loader and the executable driver.
*
*	One of these macros must be used at the beginning
*	of each SOS-program.
*
*	The INITSOS macro is much smaller then the INITSOS2 macro.
*
*	INITSOS will be sufficient for starting demos with SLOAD and
*	similar utilities.
*
*	INITSOS2 has the additional feature of a Shell/Workbench start.
*	When started from Shell or Workbench the sos.library will be 
*	loaded automatically and the functionality of SLOAD is
*	build in.
*
*   INPUTS
*	Start  - Startadress of your code.
*
*   BUGS
*
****************************************************************************

	IFND	ATARI

INITSOS	MACRO
	moveq	#-1,d0
	rts
	nop
	jmp	\1
	dc.b	'sos',0
	ENDM

INITSOS2	MACRO
	jmp	\@1			; Standart Start
	jmp	\1
	dc.b	'sos',0

\@1	move.l	4.w,a6
	move.l	a0,a3

	move.l	$114(a6),a4		; save TaskPtr
	tst.l	$AC(a4)			; CLI start?
	bne.s	\@CLI			; yes->

	lea	$5c(a4),a0		; Wait for workbench message
	JSR	-384(a6)		; WaitPort
	lea	$5c(a4),a0		; and reply it...
	JSR	-372(a6)		; GetMsg
	move.l	d0,\@WBMsg
	bra.s	\@WBend

\@CLI	lea	\@Args(pc),a2		; a2 = Ziel
	moveq	#9,d0			; d0 = MaxArgCnt
.loop	cmp.b	#32,(a3)+		; überlese Spaces
	beq.s	.loop			; <32 = ende
	blo.s	.end
	subq.l	#1,a3			; schreibe
	move.l	a3,(a2)+
.loop2	cmp.b	#32,(a3)+		; lese bis nächstes Space
	blo.s	.end
	bne.s	.loop2
	clr.b	-1(a3)			; schreibe Endemarkierun
	dbf	d0,.loop		; nächsten eintrag
.end	clr.b	-1(a3)

\@WBend	lea	\@lib(pc),a1		; Open sos.library
	moveq	#0,d0
	move.l	4.w,a6
	jsr	-552(a6)
	tst.l	d0
	beq.s	\@end
	move.l	d0,a6			; KillSystem
	move.l	a6,-(a7)
	lea	\@Code,a0
	jsr	_StartIt(a6)
	move.l	(a7)+,a1		; Close sos.library
	move.l	4.w,a6
	jsr	-414(a6)

\@end	move.l	\@WBMsg(pc),d2		; Was it a CLI/Shell start?
	beq.s	\@cli2			; yes->

	move.l	4.w,a6			; WB cleanup
	JSR	-132(a6)		; Forbid
	move.l	d2,a1			; reply workbench message
	JSR	-378(a6)		; ReplyMsg

\@cli2	moveq	#0,d0			; Dos-Ende
	rts

\@Code	jsr	_GetPISS(a6)		; Setze Args
	lea	\@Args(pc),a1
	move.l	a1,PISS_Parameter(a0)
	jmp	\1

\@WBMsg	dc.l	0
\@Args	dcb.l	11,0			; 10 Argumente und 0
\@lib	dc.b	'sos.library',0
	even

	ENDM

	ENDC


; ===================================================================
; ===================================================================
;
;  Atari-Stuff
;
; ===================================================================
; ===================================================================


	IFD	ATARI

; ===================================================================
;
;  Interrupt-Struktur
;
; ===================================================================


		rsreset
INT_VBL		rs.l	1	; VBL muß initialisiert sein!
INT_HBL		rs.l	1	; wer will, kann.
INT_TimerB	rs.l	1	; mal sehn was dies mal wird.
INT_SIZEOF	rs.w	0


	ENDC
-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                                 S O S
;   
;                         Sanity Operating System
;
;                                 V 2.6
;
;
;             small macro language and environment starndard
;
; ===================================================================



*#***** sosmacros.i/ *******************************************************
*
*   NAME
*
*   SYNOPSIS
*
*   FUNCTION
*
*   INPUTS
*
*   RESULT
*
*   ERRORS
*
*   EXAMPLE
*
*   NOTES
*
*   BUGS
*
*   SEE ALSO
*
****************************************************************************


; ===================================================================
;
;  BPLCON0 - Genlock adaptions
;
; ===================================================================

******* sosmacros.i/GENLOCK **********************************************
*
*   NAME
*	GENLOCK -- Adept copperlist for genlock usage.
*
*   SYNOPSIS
*	GENLOCK CLabel    (MACRO)
*
*   FUNCTION
*	if you set the number of planes, you will usuallly write something
*	like
*
*		dc.w	$0100,$a200		; 2 planes hires
*
*	in your copperlist. But if a genlock is attached to your Amiga,
*	you will have to enable it by writing:
*
*		dc.w	$0100,$a302		; genlock enables
*
*	If you write this on an Amiga without genlock, your computer
*	will crash since there are no syncronisations signals from
*	the genlock.
*	The GENLOCK and GENLOCK2 macro will change the copperlist
*	to reflect the state of the genlock bits. In future you should
*	write
*
*		dc.w	$0100,$a000		; 2 planes hires
*
*	all other bits will be set by the Macro. Since the operating-
*	system is used to determine weather a genlock is used, there 
*	might arise problems since early versions of Kickstart had
*	a bug in the genlock detection.
*
*   INPUTS
*	CLabel - Label to a coppermove instruction that changes BPLCON0.
*
*   EXAMPLE (untested!)
*	here     GENLOCK  genlock1      ; adept first cmove
*	         GENLOCK2 genlock2      ; more cmoves
*	         GENLOCK2 genlock3 
*	         ....
*	         move.w   #$3000,d2     ; enale 3 planes lores
*	         GENLOCK  d2;           ; adept (ATTENTION! SEMIKOLON important)
*	         move.w   d2,genlock2+2 ; and write..
*	         ....
*	Clist    dc.w     D0180,$f0f
*	genlock1 dc.w     $0100,$2000   ; 2 planes Lores
*	         ...
*	genlock2 dc.w     $0100,$0000   ; of
*	         ...
*	genlock3 dc.w     $0100,$a000   ; 2 planes hires
*
*   NOTES
*	if you want to change a register, you must write a semicolon
*	behind the register to avoid the build in "+2".
*
*	If you want to change many positions in the copperlist, you
*	can use the GENLOCK2 macro for all subsequent positions.
*
*	In case of trouble just look in the macro definition. These
*	macros were included to make genlock adaption as easy as possible.
*	But this hasn't stopped us (Chaos/Mr. Pet) to forget it many times.
*
*   BUGS
*
****************************************************************************


GENLOCK	MACRO	; Copperlabel
	jsr	_GetPISS(a6)
	move.w	PISS_BPLCON0(a0),d0
	or.w	d0,\1+2
	ENDM

; Fals weitere Anpassungen nötig sind:

GENLOCK2	MACRO	; Copperlabel
	or.w	d0,\1+2
	ENDM

; ===================================================================
;
;  Environment Sync Macros
;
; ===================================================================

; The PISS allows you to create environment variables. You can use
; whatever structure you like for environments, but the structure 
; discribed here has been used by Chaos/Mr. Pet and is well tested.
; It allows simple creation of trackmos by simply linking effects.
; see main documentation and the RAW demo handler for full discussion.

; All ENV-Macros need a5 set to your variables as discribed in the 
; main documentation and the demo sources to work properly. You must
; provide some variables and labels:

; SOSBase	rs.l	1		; variable relative to a5
; DBUGBase	rs.l	1		; variable relative to a5
; Vars		ds.b	VARS_SIZEOF	; where the a5-variables are put

; ===================================================================

		rsreset
ENV_Flags	rs.l	1	; see below
ENV_Job		rs.l	1	; environment-job
				; usually debugger
ENV_Do		rs.l	1	; environment-irq
				; usually music
ENV_Tick	rs.w	1	; general vbl-counter
ENV_LastTick	rs.w	1	; last tick of effect
ENV_FirstTick	rs.w	1	; first tick of effect
ENV_TotalTicks	rs.w	1	; #ticks of this effect
ENV_MemoryPool	rs.l	1	; should be 0 or point to at least 64 K chip
ENV_Debugger	rs.l	1
ENV_SIZEOF	rs.l	0

ENVFb_Code	equ	0	; _Job and _Do used
ENVFb_Timer	equ	1	; _Ticks used
ENVFb_Memory	equ	2	; Memorypool installed

ENVFf_Code	equ	1
ENVFf_Timer	equ	2
ENVFf_Memory	equ	4

ENVFf_Normal	equ	ENVFf_Code+ENVFf_Timer

******* sosmacros.i/--background-- ****************************************
*
*	All ENV-Macros must be called with a5 pointing to Vars.
*
***************************************************************************


******* sosmacros.i/ENVINIT ************************************************
*
*   NAME
*	ENVINIT -- Initialise standard environment system
*
*   SYNOPSIS
*	ENVINIT EnvFlags,Time    (MACRO)
*
*   FUNCTION
*	Try to find environments. If the environments are already
*	set, use them. If one of the features you requested for your
*	environment is not available (such as the memory pool) it will
*	be created and added to the environment.
*
*	The standard environment will abort the demo if you press the
*	right mousebutton. If you define the label NORMBX this feature 
*	will be suppresed. Don't forget this for the final demo.
*
*   INPUTS
*	EnvFlags         - What features should be installed?
*	    ENVFf_Code   - Code for Job and Irq (specify this allways!)
*	    ENVFf_Timer  - Initialise timer. 
*	    ENVFf_Memory - Allocate memory pool.
*       Time             - How many ticks the demo should run by default.
*
*   EXAMPLE
*	         RSRESET
*	SOSBase  RS.l     1
*	DBUGBase RS.l     1
*	         ...
*
*	         ...
*	         ENVINIT  ENVFf_Code+ENVFf_Timer,$400  ; init environment
*	         ...
*	         ENVWAIT                ; wait for starting tick
*	         ...
*	         jsr      SetInt(a6)    ; set your irq
*
*	Loop     bsr      Jobs          ; main loop
*	         ENVEND   Loop   
*	         moveq    #0,d0         ; end
*	         rts
*
*	MainIrq  movem.l  ...           ; interrupt
*	         lea      Vars,a5       ; a5 variables
*	         move.l   SOSBase(a5),a6; set library base
*	       
*	         ENVDO                  ; ENV. interrupt (music)
*	         ...
*	         nop
*	         rte
*
*   BUGS
*
*   SEE ALSO
*	ENVVARS,ENVINIT,ENVWAIT,ENVDO
*
****************************************************************************

ENVINIT	MACRO

	move.l	a2,-(a7)
	jsr	_GetPISS(a6)		; Hole Env.
	move.l	a0,a2
	move.l	PISS_Environment(a2),a0
	move.l	a0,d0
	bne.s	.\@1			; vorhanden, OK
	moveq	#ENV_SIZEOF,d0		; Alloc Env.
	moveq	#MAT_PUBLIC,d1
	jsr	_AllocMem(a6)
	move.l	d0,a0			; Clr Mem
	moveq	#ENV_SIZEOF/4-1,d1
.\@clr	clr.l	(a0)+
	dbf	d1,.\@clr
	move.l	d0,PISS_Environment(a2)
.\@1	move.l	d0,a2			; a2 = Env
	move.l	a2,Env(a5)		; Setze Env

	IFNE	\1&ENVFf_Memory
	tst.l	ENV_MemoryPool(a2)	; Hole evt. Speicher
	bne.s	.\@2
	move.l	#$10000,d0
	move.l	#MAT_CHIP,d1
	jsr	_AllocBlock(a6)
	move.l	d0,ENV_MemoryPool(a2)
.\@2	;
	ENDC

	IFNE	\1&ENVFf_Timer
	tst.w	ENV_LastTick(a2)		; Setze Timer
	bne.s	.\@3
	move.w	#\2,ENV_LastTick(a2)
	move.w	#\2,ENV_TotalTicks(a2)
.\@3
	ENDC
	IFNE	\1&ENVFf_Code
	tst.l	ENV_Job(a2)		; Setze Job
	bne.s	.\@4
	DEBLOAD				; Load Debugger
	move.l	#.\@Job,ENV_Job(a2)
.\@4	tst.l	ENV_Do(a2)		; Serze Irq
	bne.s	.\@5
	move.l	#.\@Do,ENV_Do(a2)
	bra.s	.\@5
	ENDC

.\@Job	move.l	a5,-(a7)
	lea	Vars,a5
	DEBJOB
	move.l	(a7)+,a5
	rts
.\@Do	move.l	a5,-(a7)
	lea	Vars,a5
	move.l	Env(a5),a0
	IFND	NORMBX
	btst	#2,$dff016
	bne.s	.2
	move.w	ENV_LastTick(a0),ENV_Tick(a0)
	move.l	(a7)+,a5
	rts
	ENDC
.2	move.l	(a7)+,a5
	addq.w	#1,ENV_Tick(a0)
	rts
.\@5	move.l	(a7)+,a2
	ENDM


******* sosmacros.i/ENVWAIT *******************************************************
*
*   NAME
*	ENVWAIT -- Warte for starting tick.
*
*   SYNOPSIS
*	ENVWAIT   (MACRO)
*
*   FUNCTION
*	Wait for the exact timer tick that should start the part.
*	This moment can be set in ENV_FirstTick by the loader.
*	The default value is 0
*
*   EXAMPLE
*	see ENVINIT
*
*   BUGS
*
*   SEE ALSO
*	ENVVARS, ENVINIT, ENVDO, ENVEND
*
****************************************************************************

; Warte bis Startsignal gegeben wurde

ENVWAIT	MACRO
\@xxx	move.l	Env(a5),a0		; Do Job
	move.l	ENV_Job(a0),a0
	jsr	(a0)
	move.l	Env(a5),a0
	move.w	ENV_Tick(a0),d0
	cmp.w	ENV_FirstTick(a0),d0
	blo.s	\@xxx
	ENDM


******* sosmacros.i/ENVDO *****************************************************
*
*   NAME
*	ENVDO -- Environment interrupt routine.
*
*   SYNOPSIS
*	ENVDO  label           (MACRO)
*
*   FUNCTION
*	Call the Environment interrupt code, usually the replay.
*	Increase the ENV_Tick timer.
*
*	If DEBUG is defined, the routine will check the left mousebutton.
*	If it is pressed and you set the label behind your main routine,
*	your main routine will be called only every 16th frame (see
*	examble at ENVINIT). Set the label directly after the ENVDO-macro
*	to disable this feature.
*
*   EXAMPLE
*	siehe ENVINIT
*
*   BUGS
*
*   SEE ALSO
*	ENVVARS, ENVINIT, ENVWAIT, ENVCODE
*
****************************************************************************

; Führe Interrupt-Routine aus. Alle Register werden verändert

ENVDO	MACRO
	move.l	Env(a5),a0
	move.l	ENV_Do(a0),a0
	jsr	(a0)
	IFD	DEBUG
	lea	.IrqCnt(pc),a0
	addq.w	#1,(a0)
	btst	#6,$bfe001
	bne.s	.ok
	moveq	#$f,d0
	and.w	(a0),d0
	bne	\1
	bra.s	.ok
.IrqCnt	dc.w	0
.ok	;
	ENDC
	ENDM


******* sosmacros.i/ENVEND *************************************************
*
*   NAME
*	ENVEND -- Warte auf Ende
*
*   SYNOPSIS
*	ENVEND loop  (MACRO)
*
*   FUNCTION
*	Wait for the end tick of the demo. Call the ENV_Job field.
*	If the demo is not finished, jump back to the loop-label.
*
*   INPUTS
*	loop  - Label for loop.
*   
*   EXAMPLE
*	siehe ENVINIT
*
*   BUGS
*
*   SEE ALSO
*	ENVVARS, ENVINIT, ENVWAIT, ENVCODE, ENVDO
*
****************************************************************************

; Warte auf ende der Aktion. Springe, wenn nicht zuende zum angegebenen 
; Label. Tue Job

ENVEND	MACRO
	move.l	Env(a5),a0		; Do Job
	move.l	ENV_Job(a0),a0
	jsr	(a0)
	move.l	Env(a5),a0		; Wait
	move.w	ENV_Tick(a0),d0
	cmp.w	ENV_LastTick(a0),d0
	blo	\1
	ENDM



; ===================================================================
;
;  Debugger Macros
;
; ===================================================================
;
; Zwei Macros zum starten des kleinen Debuggers.
; Das erste läedt ihn, daß zweite muß im Mainloop laufen.
; Das Label "Debugger" wird gebraucht!
; Beide Proigramme benötigen SOSBase in a6!


*****i* sosmacros.i/DEBLOAD ************************************************
*
*   NAME
*	DEBLOAD -- Lade kleinen Debugger
*
*   SYNOPSIS
*	DEBLOAD   (MACRO)
*
*   FUNCTION
*	Lade den Debugger.
*
*   NOTES
*	Ist in den Standart-Environment enthalten.
*
*   BUGS
*
****************************************************************************

DEBLOAD	MACRO
	move.l	#'DBUG',d0
	jsr	_OpenLibrary(a6)
	move.l	Env(a5),a1
	move.l	a0,ENV_Debugger(a1)
	ENDM


*****i* sosmacros.i/DEBJOB *************************************************
*
*   NAME
*	DEBJOB -- Rufe Debugger auf.
*
*   SYNOPSIS
*	DEBJOB  (MACRO)
*
*   FUNCTION
*	Rufe den Debugger auf. Dieser testet, ob seine Aktivierungsaktion
*	vollzogen wurde. Wenn nein, springt er gleich wieder zurück.
*	Der momentane (v2.0) Standartdebugger läßt sich mit 
*	Feuerknopf+Taste aufrufen. Feuerknopf+Help zeigt eine Hilfe an.
*
*   NOTES
*	Diese Routine darf nicht aus dem Interrupt aufgerufen werden.
*	Siehe debugger.doc und mod3.doc
*
*	Sie benötitgt einen Zeiger auf die SOSBase in a6 und 
*	einen auf den Variablenraum in a5
*
*   BUGS
*
****************************************************************************

DEBJOB	MACRO
	move.l	Env(a5),a4
	move.l	ENV_Debugger(a4),a4
	jsr	LIB_First(a4)
	ENDM





; ===================================================================
;
;  Helpfull macros for calling SOS-routines
;
; ===================================================================

******* sosmacros.i/SETINT *************************************************
*
*   NAME
*	SETINT -- Set Interrupt and Copper                         (v1.8)
*
*   SYNOPSIS
*	SETINT Copper,Irq,Enable   (MACRO)
*
*   FUNCTION
*	Switch from one environment containing Copperlist and
*	interrupts to another. Be shure that a copperinterrupt
*	is called with the accociated copperlist.
*
*	This routine will wait until the next frame to ensure 
*	smooth transitions.
*
*	If you want the debugger to work properly, you MUST use
*	this function to change the COP1LC-register. You may 
*	only access this register manually if you do some kind 
*	of copper-doublebuffering. If you change from one effect
*	to the other you MUST call SetInt.
*
*	If the debugger is called, it can not find out what
*	copperlist you have set by peeking the hardware. It uses
*	the SetDefault(), ClrDefault() mechanism to set it's own
*	Copperlist and restore the old one, and these function
*	rely totally on SetInt to find out your copperlist.
*	If you change the copperlist manually, you must remember that
*	after calling the debugger the copperlist you set with SetInt
*	will be restored. Please design your Copper-doublebuffering
*	carefully to handle these errors correct and ALLWAYS use
*	SetInt() when you change from one part to another.
*
*	This function is the most important function in SOS!
*
*   INPUTS
*	Enable   - Interrupt Enable, a comnbination of $0010, $0020 and
*	           $0040 for copper, vertical blanking and blitter
*	           interrupt. $0000 when no change of interrupts is
*	           desired.
*	Copper   - Pointer to Clist or 0 (use old one)
*	Irq      - Pointer to your IRQ code, unimportant if Enable=0.
*
*   NOTES
*	This routine may NOT be called from interrupt. Use 
*	SetIntFast() instead!.
*
*   BUGS
*
*   SEE ALSO
*	ClrInt(), SetDefault(), ClrDefault()
*
****************************************************************************

SETINT	MACRO
	lea	\1,a0
	lea	\2,a1
	moveq	#\3,d0
	jsr	_SetInt(a6)
	ENDM

******* sosmacros.i/SETCADR ************************************************
*
*   NAME
*	SETCADR -- Initialisiere Adresse(n) in einer Copperliste.    (v1.8)
*
*   SYNOPSIS
*	SETCADR Copper,Plane,Offset,Count
*
*   FUNCTION
*	Sets several bitplane- or spritepointer in a copperlist.
*
*   INPUTS
*	Copper   - Adresse of the first CMOVE-command.
*	Plane    - Value that is stored in the Copperlist
*	Offset   - Offset from one plane to another.
*	Count    - Number of adresses to write.
*	Register - Number of the first Register.
*
*   EXAMPLE (not tested)
*	Initialise an interleaved bitplane lores, 40 bytes, 5 planes.
*
*	         SETCADR  CopPln,#PlaneDat+64,40,5,$e0
*	         SETCCOL  CopCol,PlaneDat,0,32
*	         SETCSPR  CopSpr
*	              ...
*	         dc.w     $0108,40*4        ; set modulo
*	         dc.w     $010a,40*4
*	CopPln   dcb.l    10                ; BPLxPT's 
*	CopSpr   dcb.l    16                ; SPRxPT's
*	CopCol   dcb.l    32                ; COLORxx's
*	              ...
*	PlaneDat INCBIN   'picture.raw'     ; palette and planes
*
*   BUGS
*
*   SEE ALSO
*	SetCopCol()
*
****************************************************************************

SETCADR	MACRO
	move.l	\2,d0
	lea	\1,a0
	move.l	#\3,d1
	moveq	#\4,d2
	move.w	#\5,d3
	jsr	_SetCopperAdr(a6)
	ENDM

******* sosmacros.i/SETCSPR ************************************************
*
*   NAME
*	SETCSPR -- Reset spritepointer                    (v1.8)
*
*   SYNOPSIS
*	SETCSPR Sprites            (MACRO)
*
*   FUNCTION
*	This macro sets all 8 spritepointers to an adress that holds 
*	zero in a copperlist. You must provide a label called Zeros
*	that declares a longword 0 in chipmemory.
*
*   INPUTS
*	Sprites   - label to 64 free bytes in a copperlist
*
*   NOTES
*	This macro calls SetCopperAdr().
*
*   EXAMPLE
*	siehe SETCADR
*
*   BUGS
*
*   SEE ALSO
*	SetCopperAdr(), SetCopperCol()
*
****************************************************************************

SETCSPR	MACRO
	lea	\1,a0
	move.l	#Zeros,d0
	moveq	#0,d1
	moveq	#8,d2
	move.w	#$120,d3
	jsr	_SetCopperAdr(a6)
	ENDM

******* sosmacros.i/SETCCOL ************************************************
*
*   NAME
*	SETCCOL -- Initialisiere colors in copperlist.   (v1.8)
*
*   SYNOPSIS
*	SETCCOL Copper,Colors,Register,Count      (MACRO)
*
*   FUNCTION
*	Initialises some CMOVE-commands that could set up a 
*	color palette.
*
*   INPUTS
*	Copper   - Where to write the copperlist
*	Colors   - Pointer to palette
*	Register - First colorregister from 0 to 31 (!).
*	Count    - Number of colorregisters to set.
*
*   EXAMPLE
*	siehe SETCADR
*
*   BUGS
*
*   SEE ALSO
*	SetCopperCol()
*
****************************************************************************

SETCCOL	MACRO
	lea	\1,a0
	lea	\2,a1
	moveq	#\3,d0
	moveq	#\4,d1
	jsr	_SetCopperCol(a6)
	ENDM

******* sosmacros.i/GENSINUS ***********************************************
*
*   NAME
*	GenSinus -- Generate sinelist.      (MACRO)                 (v1.8)
*
*   SYNOPSIS
*	GenSinus Adresse,Format,Range,Size,Quaters
*
*   FUNCTION
*	Create a sinelist in memory. This is done by interpolating
*	a build in sine list of 256 Words length.
*
*	The accuracy is an error of 0.5 for a range from $7fff to -$8000.
*	This should be sufficiant for all your needs. Using the 
*	sinelist generator will save you some memory and is more
*	comfortable then working with extern sinelist generators.
*
*	The macro needs a variable called SINEBase relative to a5 that
*	holds the adress of a loaded SINE.soslibrary.
*
*   INPUTS
*	Adresse  - Pointer to free memory
*	Format   - SINE_WORD or SINE_BYTE
*	Range    - Half amplitude of the sinewave as potenz of 2
*	           See notes.
*	Size     - Number of elements for each sine quarter as potenz of 2
*	           See notes.
*	Quaters  - number of sine quarters (4 for full sinus, 5 for 
*	           combined sinus/cosinus table.
*
*   NOTES
*	Sizes are encoded like this.
*
*	Potenz   Elemtens per quarter       Minimum  Maximum
*	-----------------------------------------------------
*	2        4                          -3       3
*	4        16                         -15      15
*	8        256                        -255     255
*	9        512                        -511     511
*	10       1024                       -1023    1023 
*	11       2048                       -2047    2047 
*	12       4096                       -4095    4095 
*	13       8192                       -8191    8191 
*	14       16384                      -15383   15383
*	15       32768                      -32767   32767
*
*   BUGS
*
****************************************************************************

GENSINUS	MACRO
	move.l	a4,-(a7)
	move.l	SINEBase(a5),a4
	lea	.\@tags(pc),a0
	jsr	_GenSinusTags(a4)
	bra.s	.\@skip

.\@tags	STAGITEM	ST_ADRESS,\1
	STAGITEM	ST_FORMAT,\2
	STAGITEM	ST_RANGEPOT,\3
	STAGITEM	ST_SIZEPOT,\4
	STAGITEM	ST_QUARTERS,\5
	STAGITEM	ST_START,0\6
	STAGDONE

.\@skip	move.l	(a7)+,a4
	ENDM

******* sosmacros.i/CLRFAST ************************************************
*
*   NAME
*	CLRFAST -- Easy memory clearer.                        (v1.8)
*
*   SYNOPSIS
*	CLRFAST Adress,Size
*
*   FUNCTION
*	Clear memory in a fast to type and fast to execute way.
*	The memoryarea must meet the following conditions:
*	- Adress must be even
*	- Size must be a multiple of 4
*	- Size must not be larger then 256 KBytes
*	- Size must not be 0
*
*   INPUTS
*	Adresse  - Label of memory to clear.
*	Länge    - Size of memory to clear.
*
*   BUGS
*
****************************************************************************

CLRFAST	MACRO				; Lösche Speicher bis 256K
	lea	\1,a0
	move.w	#\2/4-1,d0
	moveq	#0,d1
.\@clr	move.l	d1,(a0)+
	dbf	d0,.\@clr
	ENDM

; ===================================================================
;
;  Sections
;
; ===================================================================

******* sosmacros.i/SEC-diverse- *******************************************
*
*   NAME
*	SECCODE   -- Start code section
*	SECBSS    -- Start BSS section
*	SECCODE_C -- Start code section Chipmem
*	SECBSS_C  -- Start BSS section Chipmem
*
*   SYNOPSIS
*	SECCODE
*	SECBSS
*	SECCODE_C
*	SECBSS_C
*
*   FUNCTION
*	These macros are simpler to type then the corresponding 
*	Section-commands. 
*
*	A special feature has been introduced. If you define the
*	CHIPMEM label, all sections will be forced to chipmemory. 
*	This allows you to check how slow your routine gets on 
*	a computer that has no fastmemory if your development 
*	computer has fast memory. You should allways spread the
*	version with CHIPMEM reset, just to be shure.
*
*   BUGS
*
****************************************************************************

SECCODE	MACRO
	IFD	CHIPMEM
	SECTION	'code',CODE_C	; Chipmem!
	ENDC
	IFND	CHIPMEM
	SECTION	'code',CODE
	ENDC
	ENDM

SECBSS	MACRO
	IFD	CHIPMEM
	SECTION	'bss',BSS_C	; Chipmem!
	ENDC
	IFND	CHIPMEM
	SECTION	'bss',BSS
	ENDC
	ENDM

SECCODE_C MACRO
	SECTION	'code_c',CODE_C
	ENDM

SECBSS_C	MACRO
	SECTION	'bss_c',BSS_C
	ENDM


******* sosmacros.i/OPENLIB *************************************************
*
*   NAME
*	OPENLIB -- Load library
*
*   SYNOPSIS
*	LibBase=OPENLIB NAME   (MACRO)
*	a0
*
*   FUNCTION
*	Load a library and return a pointer to it. This function also
*	sets a label relative to a5 called NAMEBase that can be used
*	for further Library calls.
*
*	Remember that most extern library want thier library pointer in a4!
*	Remember that all libraries are deletet from memory with
*	ClrDefault(), ClrInt().
*
*   INPUTS
*	'NAME'   - 4 letter ASCII literal of the library name
*
*   RESULT
*	LibBase  - Pointer to library.
*
*   BUGS
*
*   SEE ALSO
*	ClrInt(), SetDefault(), ClrDefault()
*
****************************************************************************

OPENLIB	MACRO
	move.l	#'\1',d0
	jsr	_OpenLibrary(a6)
	move.l	d0,a0
	move.l	a0,\1Base(a5)
	ENDM
-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                                 S O S
;   
;                         Sanity Operating System
;
;                                 V 2.6
;
;
;                      Hardware-Register Definitions
;
; ===================================================================

; ===================================================================
;
;  Hardware Register wenn angefordert
;
; ===================================================================

	IFD	HARDWARE

DMACONR	 EQU	$dff002-HARDWARE
VPOSR	 EQU	$dff004-HARDWARE
VHPOSR	 EQU	$dff006-HARDWARE
JOY0DAT	 EQU	$dff00A-HARDWARE
JOY1DAT	 EQU	$dff00C-HARDWARE
CLXDAT	 EQU	$dff00e-HARDWARE
ADKCONR	 EQU	$dff010-HARDWARE
POTGOR	 EQU	$dff016-HARDWARE
DSKBYTR	 EQU	$dff01a-HARDWARE
INTENAR	 EQU	$dff01c-HARDWARE
INTREQR	 EQU	$dff01e-HARDWARE
DSKPTH	 EQU	$dff020-HARDWARE
DSKLEN	 EQU	$dff024-HARDWARE
VPOSW	 EQU	$dff02a-HARDWARE
COPCON	 EQU	$dff02e-HARDWARE
JOYTEST	 EQU	$dff036-HARDWARE
BLTCON0	 EQU	$dff040-HARDWARE
BLTCON1	 EQU	$dff042-HARDWARE
BLTAFWM	 EQU	$dff044-HARDWARE
BLTALWM	 EQU	$dff046-HARDWARE
BLTCPTH	 EQU	$dff048-HARDWARE
BLTCPTL	 EQU	$dff04a-HARDWARE
BLTBPTH	 EQU	$dff04c-HARDWARE
BLTBPTL	 EQU	$dff04e-HARDWARE
BLTAPTH	 EQU	$dff050-HARDWARE
BLTAPTL	 EQU	$dff052-HARDWARE
BLTDPTH	 EQU	$dff054-HARDWARE
BLTDPTL	 EQU	$dff056-HARDWARE
BLTSIZE	 EQU	$dff058-HARDWARE
BLTCON0L EQU	$dff05a-HARDWARE
BLTSIZV	 EQU	$dff05c-HARDWARE
BLTSIZH	 EQU	$dff05e-HARDWARE
BLTCMOD	 EQU	$dff060-HARDWARE
BLTBMOD	 EQU	$dff062-HARDWARE
BLTAMOD	 EQU	$dff064-HARDWARE
BLTDMOD	 EQU	$dff066-HARDWARE
BLTCDAT	 EQU	$dff070-HARDWARE
BLTBDAT	 EQU	$dff072-HARDWARE
BLTADAT	 EQU	$dff074-HARDWARE
LISAID	 EQU	$dff07c-HARDWARE
DSKSYNC	 EQU	$dff07e-HARDWARE
COP1LCH	 EQU	$dff080-HARDWARE
COP2LCH	 EQU	$dff084-HARDWARE
COPJMP1	 EQU	$dff088-HARDWARE
COPJMP2	 EQU	$dff08a-HARDWARE
DIWSTRT	 EQU	$dff08E-HARDWARE
DIWSTOP	 EQU	$dff090-HARDWARE
DDFSTRT	 EQU	$dff092-HARDWARE
DDFSTOP	 EQU	$dff094-HARDWARE
DMACON	 EQU	$dff096-HARDWARE
CLXCON	 EQU	$dff098-HARDWARE
INTENA	 EQU	$dff09A-HARDWARE
INTREQ	 EQU	$dff09C-HARDWARE
ADKCON	 EQU	$dff09E-HARDWARE
BPL1PTH	 EQU	$dff0E0-HARDWARE
BPL1PTL	 EQU	$dff0E2-HARDWARE
BPL2PTH	 EQU	$dff0E4-HARDWARE
BPL2PTL	 EQU	$dff0E6-HARDWARE
BPL3PTH	 EQU	$dff0E8-HARDWARE
BPL3PTL	 EQU	$dff0EA-HARDWARE
BPL4PTH	 EQU	$dff0EC-HARDWARE
BPL4PTL	 EQU	$dff0EE-HARDWARE
BPL5PTH	 EQU	$dff0F0-HARDWARE
BPL5PTL	 EQU	$dff0F2-HARDWARE
BPL6PTH	 EQU	$dff0F4-HARDWARE
BPL6PTL	 EQU	$dff0F6-HARDWARE
BPL7PTH	 EQU	$dff0F8-HARDWARE
BPL7PTL	 EQU	$dff0FA-HARDWARE
BPL8PTH	 EQU	$dff0FC-HARDWARE
BPL8PTL	 EQU	$dff0FE-HARDWARE
BPLCON0	 EQU	$dff100-HARDWARE
BPLCON1	 EQU	$dff102-HARDWARE
BPLCON2	 EQU	$dff104-HARDWARE
BPLCON3	 EQU	$dff106-HARDWARE
BPL1MOD	 EQU	$dff108-HARDWARE
BPL2MOD	 EQU	$dff10a-HARDWARE
BPLCON4	 EQU	$dff10c-HARDWARE
CLXCON2	 EQU	$dff10e-HARDWARE
COLOR0	 EQU	$dff180-HARDWARE

HTOTAL	 EQU	$dff1c0-HARDWARE
HSSTOP	 EQU	$dff1c2-HARDWARE
HBSTRT	 EQU	$dff1c4-HARDWARE
HBSTOP	 EQU	$dff1c6-HARDWARE
VTOTAL	 EQU	$dff1c8-HARDWARE
VSSTOP	 EQU	$dff1ca-HARDWARE
VBSTRT	 EQU	$dff1cc-HARDWARE
VBSTOP	 EQU	$dff1ce-HARDWARE
BEAMCON0 EQU	$dff1dc-HARDWARE
HSSTRT	 EQU	$dff1de-HARDWARE
VSSTRT	 EQU	$dff1e0-HARDWARE
HCENTER	 EQU	$dff1e2-HARDWARE
DIWHIGH	 EQU	$dff1e4-HARDWARE
FMODE	 EQU	$dff1fc-HARDWARE

_BLTCON0  EQU	$040
_BLTCON1  EQU	$042
_BLTAFWM  EQU	$044
_BLTALWM  EQU	$046
_BLTCPTH  EQU	$048
_BLTCPTL  EQU	$04a
_BLTBPTH  EQU	$04c
_BLTBPTL  EQU	$04e
_BLTAPTH  EQU	$050
_BLTAPTL  EQU	$052
_BLTDPTH  EQU	$054
_BLTDPTL  EQU	$056
_BLTSIZE  EQU	$058
_BLTCON0L EQU	$05a
_BLTSIZV  EQU	$05c
_BLTSIZH  EQU	$05e
_BLTCMOD  EQU	$060
_BLTBMOD  EQU	$062
_BLTAMOD  EQU	$064
_BLTDMOD  EQU	$066
_BLTCDAT  EQU	$070
_BLTBDAT  EQU	$072
_BLTADAT  EQU	$074
_LISAID	  EQU	$07c
_DSKSYNC  EQU	$07e
_COP1LCH  EQU	$080
_COP2LCH  EQU	$084
_COPJMP1  EQU	$088
_COPJMP2  EQU	$08a
_DIWSTRT  EQU	$08E
_DIWSTOP  EQU	$090
_DDFSTRT  EQU	$092
_DDFSTOP  EQU	$094
_DMACON	  EQU	$096
_CLXCON	  EQU	$098
_INTENA	  EQU	$09A
_INTREQ	  EQU	$09C
_ADKCON	  EQU	$09E
_BPL1PTH  EQU	$0E0
_BPL1PTL  EQU	$0E2
_BPL2PTH  EQU	$0E4
_BPL2PTL  EQU	$0E6
_BPL3PTH  EQU	$0E8
_BPL3PTL  EQU	$0EA
_BPL4PTH  EQU	$0EC
_BPL4PTL  EQU	$0EE
_BPL5PTH  EQU	$0F0
_BPL5PTL  EQU	$0F2
_BPL6PTH  EQU	$0F4
_BPL6PTL  EQU	$0F6
_BPL7PTH  EQU	$0F8
_BPL7PTL  EQU	$0FA
_BPL8PTH  EQU	$0FC
_BPL8PTL  EQU	$0FE
_BPLCON0  EQU	$100
_BPLCON1  EQU	$102
_BPLCON2  EQU	$104
_BPLCON3  EQU	$106
_BPL1MOD  EQU	$108
_BPL2MOD  EQU	$10a
_BPLCON4  EQU	$10c
_CLXCON2  EQU	$10e
_COLOR0	  EQU	$180

_HTOTAL	  EQU	$1c0
_HSSTOP	  EQU	$1c2
_HBSTRT	  EQU	$1c4
_HBSTOP	  EQU	$1c6
_VTOTAL	  EQU	$1c8
_VSSTOP	  EQU	$1ca
_VBSTRT	  EQU	$1cc
_VBSTOP	  EQU	$1ce
_BEAMCON0 EQU	$1dc
_HSSTRT	  EQU	$1de
_VSSTRT	  EQU	$1e0
_HCENTER  EQU	$1e2
_DIWHIGH  EQU	$1e4
_FMODE	  EQU	$1fc


BLTH	MACRO					; Blitter high priority
	move.w	#$8400,DMACON(a4)
	ENDM

BLTL	MACRO					; Blitter low priority
	move.w	#$0400,DMACON(a4)
	ENDM

BLTW	MACRO					; Blitter wait
	IFEQ	DMACONR
.\@a	btst	#6,(a4)
	ENDC
	IFNE	DMACONR
.\@a	btst	#6,DMACONR(a4)
	ENDC
	bne.s	.\@a
	ENDM

	ENDC

DEBCOL	MACRO					; change color if debug
	IFD	DEBUG
	move.w	#\1,($dff180)
	ENDC
	ENDM


DEBCOL2	MACRO					; set color and wait if debug
	movem.l	d0/d1,-(a7)
	moveq	#15,d1
	moveq	#-1,d0
.\@loop	move.w	#\1,$dff180
	nop
	dbf	d0,.\@loop
	dbf	d1,.\@loop
	movem.l	(a7)+,d0/d1
	ENDM

	IFD	DEBUG				; use this in copperlists
D0180	equ	$01fe				; do define background color.
	ENDC					; if you assembler with
	IFND	DEBUG				; debug, your copperbars
D0180	equ	$0180				; will not interfere with
	ENDC					; the debug-colors.
-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                             TEXT.soslibrary
;   
;                    Testausgabe/Formatierungsroutinen
;
;                                 V 1.0
;
;
;                             include-datei
;
; ===================================================================

; Library Offsets

_PrintF		equ	-18
_SetOutput	equ	-12

TEXT_DEFBUFLEN	equ	2048		; Default Buffer Lenght

-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                             DBUG.soslibrary
;   
;                           Debugging Functions
;
;                                 V 1.3
;
;
;                             include-datei
;
; ===================================================================

; Library Offsets

_SetPSS		equ	-30
_StripColor0	equ	-24
_LoadDebugger	equ	-18
_CheckDBUG	equ	-12


; ===================================================================
;
;  Processor Save Structure
;
; ===================================================================

		rsreset
PSS_Data		rs.l	8	; 8 Datenregister
PSS_Adress	rs.l	7	; 7 Adressregister
PSS_USP		rs.l	1	; User Stack Pointer (USP)

PSS_ISP		rs.l	1	; Supervisor Stack Pointer 1 (SSP/ISP)
PSS_MSP		rs.l	1	; Supervisor Stack Pointer 2 (SSP/MSP)
PSS_PC		rs.l	1	; Programm Counter
PSS_ACCESS	rs.l	1	; Zugriffsadresse bei Bus/Adressfehler
PSS_SR		rs.w	1	; Status Register
PSS_ER		rs.w	1	; Error Register (Bus/Adressfehler)
PSS_SIZEOF	rs.w	0


-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                             SINE.soslibrary
;   
;                          Sinuslistengenerator
;
;                                 V 1.0
;
;
;                             include-datei
;
; ===================================================================

; Library Offsets

_GenSinusTags	equ	-12

; ===================================================================
;
;  Tags
;
; ===================================================================

		rsreset
ST_Pad1		rs.l	1
ST_ADRESS	rs.l	1
ST_FORMAT	rs.l	1
ST_RANGEPOT	rs.l	1
ST_SIZEPOT	rs.l	1
ST_QUARTERS	rs.l	1
ST_START		rs.l	1
ST_LAST		rs.w	0

; ===================================================================
;
;  SINEBase
;
; ===================================================================

		rsreset
SINEB_Library	rs.b	LIB_SIZEOF
SINEB_Tags	rs.b	ST_LAST
SINEB_SIZEOF	rs.w	0

; ===================================================================
;
;  Format-Defines
;
; ===================================================================

SINE_WORD	equ	1
SINE_BYTE	equ	2

-----------------------------------------------------------------------------


                                    S O S

                           Sanity Operating System


                                    V2.6

                                    $name


-----------------------------------------------------------------------------











COPYRIGHT:

The Sanity Operaing System is (c) copyright 1994 by Dierk Ohlerich

If you want to use it in your own productions, you MUST read the 
sos.copyright file.

If you want to use it in comercial productions, you MUST contact Dierk
Ohlerich. See sos.copyright for full adress.



; ===================================================================
;
;                             SINE.soslibrary
;   
;                          Sinuslistengenerator
;
;                                 V 1.0
;
;
;                             include-datei
;
; ===================================================================

; Library Offsets

_GenSinusTags	equ	-12

; ===================================================================
;
;  Tags
;
; ===================================================================

		rsreset
ST_Pad1		rs.l	1
ST_ADRESS	rs.l	1
ST_FORMAT	rs.l	1
ST_RANGEPOT	rs.l	1
ST_SIZEPOT	rs.l	1
ST_QUARTERS	rs.l	1
ST_START		rs.l	1
ST_LAST		rs.w	0

; ===================================================================
;
;  SINEBase
;
; ===================================================================

		rsreset
SINEB_Library	rs.b	LIB_SIZEOF
SINEB_Tags	rs.b	ST_LAST
SINEB_SIZEOF	rs.w	0

; ===================================================================
;
;  Format-Defines
;
; ===================================================================

SINE_WORD	equ	1
SINE_BYTE	equ	2

