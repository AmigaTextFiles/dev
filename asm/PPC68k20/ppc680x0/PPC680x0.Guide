@database 03d34f18-0
@master Work:Projects/PPC680x0/PPC680x0.Guide
@$VER: 1.0
@width 76
@remark Created with Heddley v1.20ß © Edd Dumbill 1994-5

@node "Main" "PPC680x0 Index"


            @{b}@{i}@{fg shine} @{ui}PPC680x0 Official Guidefile version 2.0@{ub}@{fg text}
        -------------------------------------------------
        @{b}@{fg shine}Written in March 1999-December 2004 by Coyote Flux@{ub}@{fg text}

                 @{"PPC680x0 V2.0 Notes" link "PPC68kV2" 0}

                 @{"Prologue" link "Prologue" 0}
                 @{"Future of PPC680x0" link "The Future" 0}
                 @{"What is PPC680x0?" link "WhatIsPPC680x0?" 0}
                 How does it work?
                   - @{"External" link "ExternalWorkings" 0}
                   - @{"Internal" link "InternalWorkings" 0}
                 Usage
                   - @{"General" link "UsageGeneralIndex" 0}
                   - @{"Porting Programs" link "PortingIndex" 0}
                   - @{"Programming Environments" link "ProgrammingEnvironmentIndex" 0}
                   - @{"Instruction Set Details" link "InstructionSetDetailsIndex" 0}
                   - @{"Troubleshooting" link "TroubleShooting" 0}
                 AmigaOS4+ compatibility
                   - @{"Selective Lib Conversion Bridge" link "SelectiveLibraryConversion" 0}
                 @{"Quick Guide" link "QuickGuide" 0}
                 @{"Notes & Thank You's" link "NotesAndThankYous" 0}
                 @{"Copyright?" link "Copyright" 0}
                 @{"Authors" link "Authors" 0}
                 @{"History" link "History" 0}
                 @{"Our Great Amiga" link "Amiga" 0}
                 @{"Get Lost PC!" link "Toilet" 0}

@{b}@{i}Enjoy!@{ub}@{ui}
@endnode

@node "PPC68kV2" "PPC68kV2"
@{b}@{fg shine}PPC680x0 Version 2.0 BETA1 Notes@{ub}@{fg text}

First of all, our hearts are with the people who have been involved with
the disaster in Asia. Oh my God oh my God this is horrible. No reason to
celebrate the end of the year.



Welcome to the first release of PPC680x0 V2.0!

Finally, PPC680x0 has become freeware, this means that anyone is allowed
to use it freely as long as the archive and contents remain in their 
original state.

PPC680x0 V2.0 is not entirely finished yet, which means that there may
still be some bugs present in the program. The following limitations or
problems are known:

- PPC68k V2.0 Dynamic Cache system is only partially implemented. Therefore
  it still has no effect
  
- The Floating Point Unit may contain some bugs

- Complex immediate modes (ie with brackets etc.) are still not supported

- PPC680x0 Native Mode may cause problems when called from PPC680x0. Only 
  (nested or non-nested) macro calls may be affected by this

- Parts of the conversion code have been rewritten many years ago, this
  may or may not cause problems. Actually it has not been tested yet!

- PowerUp mode is untested and probably does not work or produces garbage

The new features are not discussed in other parts of this document. Here
follows a brief description.

1. Automatic Conversion

Automatic file conversion is now supported, although only from the GUI (in
single file mode only!) and not from the CLI. When converting a file, it is 
no longer necessary to add the head/tail/lastrts instructions anymore. 
PPC680x0 will call the first instruction as a subroutine.

Automatic conversion works as follows:

First of all, it is useful to know that the example files all require the
Manual Conversion! This is because Automatic Conversion is new in v2.0.

Select the source file, destination file and settings. Then press the
Convert button as is the case in older version. A requester will ask whether
to use automatic or manual conversion. Manual conversion simply converts
files in the old way. After selecting Automatic, another requester will
appear asking "Choose Line" or "Auto Detect". Auto Detect will simply detect
the first line of code and makes that line the entry point. When selecting
Choose Line, a small text display appears in which this detected entry point 
becomes visible as a white line of text. You can use the mouse to select
another line or scroll using the bar and arrows on the right. The three
buttons on the left of the bar are as follows:

The upper button is "Goto Line", which simply makes the text display jump to
the given line.

The middle button is "Accept", which takes this line and goes to the next
step.

The lower button is "Cancel", which stops the automatic conversion process.

After pressing Accept, a new requester appears. Here you can select
"Include Modify" or "Include Leave". Include Leave does not change anything
and conversion starts. When selecting Include Modify, PPC680x0 will search
for all "include" and "incbin" lines and open a new window. In this window
you can change the paths if necessary and press OK to start conversion.

2. Internal Optimizations

Some bugfixes and optimizations have been done to improve PPC680x0's
conversion capabilities. However, many of them are untested, so if you
find any bugs, please report them to us (info@coyoteflux.nl). Also the
CLI handling and standard output routines have been replaced and Native
Mode calls should be a bit more stable now.

3. More! But this was added 4 years ago and was not listed. Tell us if you
discover anything new... ;-)

@endnode


@node "Prologue" "Prologue"
@{b}@{fg shine}Prologue@{ub}@{fg text}

Welcome to PPC680x0! What you have here is the first source-code convertor
for the Amiga platform and the very first one to support kernel call
detection and support for all the PowerPC features in a 68k
backwards compatible machine language.

This is a very complex program. It can acknowledge over 12 billion
(12000000000) instructions per line: Please understand that there might
still be small differences in the operation of some of those instructions
which will be fixed as soon as found and/or reported. 

PPC680x0 is a big library function that is  called everytime you push a 
button on the PPC68k interface. The library is now accessible using the 
PPC680x0 NATIVE mode.

AltiVec assembling will enter PPC680x0 as soon as G4 boards will arrive. 
With the current situation it seems unlikely to happen, but perhaps miracles
can still happen.

Please remember that we are always open for bug reports if you think you
have some!!!

Before you start coding, please read the guidefile: It contains a lot of
useful information.
@endnode

@node "The Future" "The Future"
@{b}@{fg shine} WHAT WE WANT TO ADD IN THE FUTURE@{ub}@{fg text}
 ---------------------------------


 @{b}* Intelligent label detection:@{ub}
    At this moment PPC680x0 does not detect brackets in labels
    which may result in errors when they are being used. The final version 
    will detect labels as well as their perfect sizes for 
    optimizations

   @{fg shine}BEWARE: Complex immediate values may also produce wrong 
           results. Place brackets among them:@{fg text}

    move.l      #12*35/24-4+5,d7

   would be buggy because "12*35/24-4+5&$ffff" will only and $ffff
   with 5 and not with the complete sum. This will fix it:

    move.l      #(12*35/24-4+5),d7

 @{b}* AltiVec support and assembler
 * 64 bits divisions (yes, this is not implemented)@{ub}


@{b}@{fg shine}OPTIONAL@{ub}@{fg text}

@{b} * output extensions: There's a possibility that there will
   be new output languages for PPC680x0, which means you can then
   convert your codes to PowerPC, ColdFire etc.. @{ub}


@{b}@{fg shine} WHAT WE ARE NOT GOING TO ADD IN THE FUTURE (unless requested...)@{ub}@{fg text}
 ----------------------------------------------------------------

 @{b}* Non-supported commands:@{ub}

 bkpt, callm, cas, cas2, chk, chk2, cmp2, cpgen
 cprestore, cpsave, cptrap(cc), pack, pflush, pflusha, ploadr, 
 ploadw, pmove, ptestr, ptestw, reset, rtm, rtr, stop, trap, 
 trapcc, unpk
@endnode

@node "WhatIsPPC680x0?" "WhatIsPPC680x0?"
@{b}@{fg shine}PPC680x0@{ub}@{fg text}

@{i}High-Quality 680x0->PowerPC source-level assembly-porter and  powerful 680x0
backwards-compatible PPC assembly-language for the Amiga.@{ui}


@{b}Introduction@{ub}

PPC680x0 is a source-level converting utility. It allows you to convert
your 'old' 680x0 source-codes straight to PowerPC source-codes. It uses
several methods to optimize the output code and therefore adapts it to work
optimal with the  pipelines and parallel instruction system of the PowerPC
family. Both hand @{"pre-" link "Pre-Optimizing" 0} and @{"post-optimizing" link "Post-Optimizing" 0} is possible.

There are a lot of programmers who do not seem to be happy with the programming
architecture of the Motorola/IBM PowerPC family. Although the PPC is an
extremely powerful piece of silicon, it suffers a bit from its 'hard to
program in assembler if you are not experienced' design.

Even though many people (and even universities) seem to deny it, machine
language is the only way to make programs run at maximum speed. Just take a
look at the demo-scene, where coders push the most advanced effects through
a 'theoretically slow' 68k CPU.

PPC680x0 is a program that should help out coders in an easy but powerful
way. You can actually treat the PowerPC CPU as a very  big 68060 and program
it like that. For example, nearly all the  68060 features are supported, as
well as many 68030 specific instructions. 

Try to imagine yourself an 68060 with 32 general purpose  registers, 32
Floating Point registers, new instructions, more addressing modes, Quad-word
(64-bits) operations, etc. etc...  It is now possible with PPC680x0: You can
actually port 680x0 source codes with it, and program the PowerPC at high
performance in the same assembly language as used before.

@{fg shine}PPC680x0 outputs Storm PowerAsm compatible code.@{fg text}


@{b}Features include:@{ub}

 * 680x0 backwards compatible assembly language for the PowerPC.
 * Supports many PowerPC modes and processors.
 * PowerUp support.
 * Extensive WarpUp support: Call WarpOS routines as well as 68K 
   library routines with a single command. Allows context
   switches and PPC kernel calls using DevPac style commands.
 * Native Library call detection: When a 680x0 program is ported,
   PPC680x0 will automatically convert 'native' 680x0 library calls
   to a PowerPC compatible call. Therefore 680x0 programs utilizing
   libraries can be converted without any trouble.
 * Detection for 'execbase' and other important constants.
 * Highly useful for compatibility with successors of OS3.5, as the
   output code is built using a 'bridging' system. 
   Library calls can be redirected to both 680x0 and PowerPC 
   processors with a single command to remain upwards compatible
   with future native PPC AmigaOS when coding.
 * Full Storm PowerAsm support.
 * Highly Optimized output-code
 * Use 32 GPRs and 32 FPRs in 680x0 style code.
 * Interleaved code output: Inserts the 680x0 assembly line as a
   comment between the converted PowerPC output.
 * Directory Processing
 * File Learning: Reads all macros, symbols etc. from a directory
   or files.
 * Built for 68040/68060 (with FPU) input code, supports most
   68020/68030 instructions as well.
 * Block based decoding: PPC680x0 analyses blocks of input code to
   optimize the PowerPC output code.
 * Post-Optimizing possible as everything is converted at source
   level.
 * Freely Upgradable.
 * Extensive Macro support.
 * Additional instruction set to gain control over all the PowerPC
   features and PPC680x0 itself.
 * MagicWB GUI as well as a CLI-interface.
 * Switchable Carry Emulation.
 * Switchable Status Register Emulation
 * Switchable rest emulation for divisions
 * Switchable Address Bus (32 or 64-bits)
 * Quad word (.q) 64-bits support for 64-bits PowerPC CPUs (still 
   bad though!)
 * High speed software Integer<->Float conversions
 * Auto-Alignment for uneven addresses
 * Use alternative Stack Pointer with definable stacksize.
 * Status Display with most sampled information from the source-
   code
 * Insert PowerPC native blocks of code.
 * Between 35 and 75 times cheaper than the only rival PortAsm,
   available on other platforms. PortAsm can only port source codes 
   and does not have many additional features like PPC680x0.
 * Support for equrl, reg, equr, fequr directives
 * From/to CCR/SR instructions also emulated
 * Much more...!
@endnode

@node "ExternalWorkings" "ExternalWorkings"
@{b}@{fg shine}HOW DOES IT WORK???@{ub}@{fg text}

@{b}(GENERAL)@{ub}

Before we start with the inside details, lets first tell you how the
interface and the general environment works:

PPC680x0 is a 'Pass 0' assembler, which means that it does not detect or
display all the reported bugs. When you will assemble the output file using
an assembler it may report other bugs caused in the conversion process.


How does it work: You write your source code in any editor (or in an 680x0
assembler if you are not using any extensions), which means you have the
following, for example:


@{i};Source code for predictable volume bla ;by blabla in 1999@{ui}

 x
        movem.l  d0-d3/d14/d16,table
        move.l   a0,d0
        move.l   a1,d1
        clr.l    d3
        smovex.w (2,d0)+,d2
        asl.l    #16,d2
        divs.l   d14,d2
        asr.l    #16,d2
        addx.l   d3,d2
        smove.w  d2,(2,d1)+
        add.l    d2,d14
        add.l    d14,d16
        bmi.s    quit
        clr.l    notneeded
 quit   movem.l  table,d0-d3/d14/d16
        lastrts 

 table  ds.l    18
 notneeded
        dc.l    0


Now you have a source code which uses special PPC680x0 extensions. Of course
it could also be any source code without those! You want to convert this
source code to a PPC source code. So you run PPC680x0, select the options
you like and the optimizations. Select the code above as a source  file,
select a destination file and finally press the convert  button. After the
converting procedure, you can load your destination file in a PowerPC
assembler and run  it (or look at it in any text editor)... Ofcourse some
precautions should be taken when converting the files, but this is all
discussed throughout the guidefile.

PPC680x0 detects and handles both @{"68k" link "68K Calling" 0} and @{"PPC library" link "PPC Calling" 0} calls.
@endnode

@node "InternalWorkings" "InternalWorkings"
@{b}@{fg shine}HOW DOES IT WORK???@{ub}@{fg text}

@{b}(INSIDE DETAILS)@{ub}

The inside operation of PPC680x0 is much more difficult to understand,
though! Lets try to give you an idea of how it works:

PPC680x0 works with a mathematical model of an 68k CPU.  The 68k is split up
in parts, where some of them build a formula on a complex plane. 

For example, we could take the pixels on a monitor as some points of a
complex plane. Every region of the monitor corresponds with a region of the
68k CPU (which can be any different mode). We could say that in the entire
complex plane, all possible  addressing modes are placed changing slightly
when moving from point to point. (For example: When moving a relatively
small end from the point corresponding with the addressing-mode d0,d4 and in
the right direction, you get d0,d5). This interpretation method is possible
because the 68k CPU is built in a very  flexible way.

Perhaps you are wondering why we took so much time in creating a
mathematical model of the chip. Well, its quite easy to guess why if you
take a look in terms of performance. The earliest versions of PPC680x0 were
based on simple straight conversions. As a result, in could not predict so 
many combinations, resulting in so called trash being generated. For
example, the following mode:

        move.l  (worst.b,d2.l),d1

could be converted to something like

        addi    r28,worst
        add     r28,r28,r5     (where r3 corresponds with d0)
        lwz     r4,0(r28)

Now it seems logical that a program can detect everything, but with linear
programming you cannot make sure this is done correctly unless you put a 
special routine in your code for every single  exception. PPC680x0's 
mathematical model takes samples of the code, analyses the samples and 
finally converts it to the PPC model. The output code will be

        lwz     r4,worst(r5)

which is the most efficient way.

Besides, linear code is not as flexible as analysing code. PPC680x0 allows
the following:

move.l ([worst.q,d0*16,d4.l*2],help.b,table.w,d14.b*32,a2),(a0)+

As a matter of fact, sampling goes in an infinite way, which means indirect
addressing modes can be seen as:

        a0([b1,b2,b3,b4,b5,...],a1,a2,a3,a4,a5,...)

which means

        load    b1+b1+b2+b3+... in IOREGISTER
        load    IOREGISTER+a0+a1+a2+a3+a4+... in IOREGISTER

(and where a/b are registers.size*multi or label.size)

Every part of the 68k CPU is treated this way to optimize the output code.

Most of the conversions are done line by line, although there are already 
several block based conversions implemented as well.


@{fg shine}Explanation of terms used in PPC680x0:@{fg text}

 INTEGRATING     - sampling of the source-code
 TRANSFORMING    - changing the samples to a standard form
 DIFFERENTIATING - converting the transformed samples to the
                   output source-code
 LAYERS          - the layers in which the 68k is split up
 BLOCKS          - a block of 100 lines of code for analysing
 LINE            - 1/100th of a block, one line of the input 
                   source-code
 L. AREA         - Label area (starting at first char of line)
 I. AREA         - Instruction area (starting after L. AREA)
 BWL AREA        - area that holds size (.b/.w/.l/.q/.s/.d/.x)
 T. AREA         - Type area (starting after BWL area)
 C. AREA         - Comment area (starts with ';', '*', etc.)
@endnode

@node "UsageGeneralIndex" "UsageGeneralIndex"
@{b}@{fg shine}PPC680x0 - THE USAGE@{ub}@{fg text}
 

@{b} For information on programming PPC680x0, go to the Programming
 Environments section.@{ub}

  @{"Requirements" link "Requirements" 0}
  @{"General Usage" link "GeneralUsage" 0}
  @{"CLI Usage" link "CLI Usage" 0}
  @{"Native mode Usage" link "Native Mode Usage" 0}
  @{"Working with a Learn File" link "Working With A Learnfile" 0}
  @{"Buttons" link "Buttons" 0}
   @{"Button 1  - Two arrows" link "Buttons" 6}
   @{"Button 2  - r1" link "Buttons" 26}
   @{"Button 3  - a7=sp" link "Buttons" 39}
   @{"Button 4  - Wup" link "Buttons" 61}
   @{"Button 5  - Gpr" link "Buttons" 65}
   @{"Button 6  - ?ERR" link "Buttons" 73}
   @{"Button 7  - Proc Dir" link "Buttons" 79}
   @{"Button 8  - 32" link "Buttons" 118}
   @{"Button 9  - 00 0" link "Buttons" 126}
   @{"Button 10 - Rest Off" link "Buttons" 134}
   @{"Button 11 - Stat Off" link "Buttons" 138}
   @{"Button 12 - Frc" link "Buttons" 144}
   @{"Button 13 - Asl In" link "Buttons" 153}
   @{"Button 14 - Asl Out" link "Buttons" 158}
   @{"Button 15 - Big 'M'" link "Buttons" 163}
   @{"Button 16 - Full" link "Buttons" 171}
   @{"Button 17 - X=D" link "Buttons" 192}
   @{"Button 18 - CFG" link "Buttons" 199}
  @{"Display Information" link "Display Information" 0}
  @{"Error Messages" link "Errorrrrrrrrrrrrrrrr" 0}
@endnode

@node "Requirements" "Requirements"
@{b}@{fg shine}Requirements:@{ub}@{fg text}

 - An Amiga with 68020+
 - At least 1MB of Fast memory (the more the better)
 - Kickstart 2.04+ (Including libraries etc.)
 - MagicWB or BagitMan to steal colors on Cybergraphics. Get it in one
   package with other stuff from our website www.coyoteflux.nl

@{b}@{fg shine}Recommended:@{ub}@{fg text}

 - PPC for testing codes...
 - 4 MB Fast Memory
 - Kickstart 3.0+
 - Fast processor (040/060 does the job...!)
 - Storm PowerAsm
@endnode

@node "GeneralUsage" "GeneralUsage"
@{b}@{fg shine}General Usage@{ub}@{fg text}

Perhaps we should start with the programming environment, but as there are
quite a lot of users who want to use this as a conversion utility, we have
placed a special @{"Programming Environment" link "ProgrammingEnvironmentIndex" 0} section in this guide.

You can install the program by simply double-clicking on the 'Install'
icon or by copying the fonts into your Fonts: drawer. After you have copied
the fonts, you can either double click on the PPC68k icon to start the
program or drag the icon to a place on your harddisk where you would like to
have it. Make sure to have a copy in the C: directory as well!!!

It is required to copy the 's/fprom.s' to your s: drawer if you want to make
use of the user configurable constant ROM file or the 'movecr' command

Make sure you have PPC680x0: assigned to the drawer where you've put the
executable. (assign >NIL: PPC680x0: <drawer>) This is only necessary when
you did not use the installer.

After you have double-clicked on the icon, you get a window with some
@{"buttons" link "Buttons" 0} and a picture.

Pressing any @{"button" link "Buttons" 0} will cause the picture to change into an information
display. Pressing HELP will call the online help if everything is installed
correctly. Workbench 2.0 owners should copy the program 'amigaguide',
'ppguide' or 'xpkguide' into their sys:utilities/ drawers and rename it to
'multiview.

PPC680x0 is a 'Pass 0' assembler, which means that it does not detect or
display all the bugs. When you will assemble the output file using
an assembler it may report some other errors concerning a piece of text with
bugs. Bugs in a piece of code  can be spotted by PPC680x0 OR the assembler
used after the  conversion phase. Go to the @{"Trial and Error" link "TrialAndError" 0} or @{"Assembly" link "Assembling" 0}
section  for more information on assembling a file.

@{b}@{fg shine}CONVERSION CAN BE STOPPED USING THE CLOSE GADGET!!!@{ub}@{fg text}
@endnode

@node "CLI Usage" "CLI Usage"
@{b}@{fg shine} CLI-USAGE@{ub}@{fg text}
 ---------

The CLI interface of PPC680x0 always has the same default options as the
PPC680x0 GUI. If you want to change any options you should give optional
inputs.

@{i}ppc68k <inputfile> <outputfile> <options> <learn>@{ui}

<input> and <output> are vital: These should contain the names of the file
to be converted and the file to  convert to.

The <options> field can have the following:

 IOFF
 ----

Interleaving Disable

 R27
 ---

Use r27 as stack pointer

 A7
 --

A7 is not equal to SP usage. See guidefile for more information

 SA7=<SIZE>
 ----------

String for the user-r27-stacksize in longwords (if  active), defaults to
10000 longwords

 PUP
 ---

Enable PowerUp instead of WarpUp

 FPR
 ---

Display FPRs in results display

 ERR
 ---

Outputs 'UNKNOWNERRORS' throughout file

 DIR
 ---

Process directory to directory (Make sure  the input and output files are
directories!)

 64
 --

Enable 64-bits implementation-mode

 CA
 --

Carry emulation on

 REST
 ----

Rest emulation on

 STAT
 ----

Status Register emulation on

 FRC
 ---

Force 32-bits address-bus

 QB
 --

'Quick-Bad' Loading

 NOXD
 ----

No FPU .X=.D

 OW
 --

Force overwrite existing file

 ND
 --

No delay after conversion or errors


 <learn> is always the last input:


 LEARN <directory>
 -----------------

Learn macro's, equr's, equrl's, fequr's and reg directives from other files
than the main one. See chapter Learning
@endnode

@node "Native Mode Usage" "Native Mode Usage"
@{b}@{fg shine}NATIVE Mode Usage@{ub}@{fg text}


This is for the more experienced programmers.

NATIVE mode is a low-level mode which can only be accessed using the CLI,
and allows to directly call PPC680x0s conversion routines to convert from an
address to another address.

Entering NATIVE mode is not too difficult. For example:

PPC68k A B ADR=03=<<08803=;<088000000:9 ND QUIET

calls nativemode. The 'A' and 'B' have to be there as dummy input and
outputfiles.

The addressfield (ADR=<address>) contains three hexadecimal addresses. The
addresses are entered as follows:

 0-9 = 0-9
 A   = ':'
 B   = ';'
 C   = '<'
 D   = '='
 E   = '>'
 F   = '?'

which means that for example 789ABCDE is equal to 789:;<=>

There are 24 characters that have to be supplied as input: The first 8 are
the source address, the second 8 are the destination address and the last 8
are the input filesize.

The 'ND' and 'QUIET' inputs at the above example are two  of the options
which are described in CLI Usage. Ofcourse,  the user selects which options
have to be enabled or  disabled when using NATIVE mode (the above is just an
example).

NATIVE mode is useful for programmers that want to use PPC680x0s conversion
routines in their own programs or directly from/to memory.

The reason for not using the characters A-F is because rendering command 
lines from a program is easier this way. simply logical or $30 with every 
digit of the address and output this as a char. 


@{fg shine}Example:@{fg text}

A PPC68k source code is located at address $1abc7832

A destination memory space is located at $1c000000

The size of the source code to be converted is $524 bytes

Options: carry emulation, rest emulation

Command line to be executed will be:

PPC68k A B ADR=1:;<78321<00000000000524 CA REST ND QUIET
@endnode

@node "Working With A Learnfile" "Working With A Learnfile"
@{b}@{fg shine}Working with the Learnfile@{ub}@{fg text}


This chapter contains information about the learnfile which is saved on the
Ram Disk while using PPC680x0.

The learnfile (called MACROFILE) is a self expanding file containing all the
important symbols and labels which have to be  resident for a proper
conversion. Before a file is converted, PPC680x0 automatically learns that
specific file. Using the Learn button it is possible to learn all symbols
from a specific directory, which is useful for converting multiple files.

In the learnfile, there are a few types of symbols that can be found,
although it doesn't make sense to read them by hand:

 - All the macros are stored there
 - All the register assignments are stored there (including
   floating point registers and registerlists)
 - All the immediate symbols are stored there

The learnfile is not deleted after the usage of PPC680x0. This has a reason,
as the learnfile can be used multiple times.

For example, you want to convert a directory with files that require symbols
from other files outside that directory. First of all, you learn the main
directory (See chapter Learning) where the source code files are present.
Then, select learning again and chose the directory where the other files
are present. The learnfile is now finished.

If you think you might need this learnfile again, you can simply copy it to
a place on your harddisk (for example the output directory) and copy it back
a few days later when you need it once again. Make sure the file is placed
on the Ram Disk and has the correct name. (MACROFILE)

@{i}@{fg shine}Flush the learnfile when a new project is started! It may contain data which
is not valid for the new project. Also, a bigger learnfile will slow down
conversion times (this can be drastically, beware!).@{ui}@{fg text}
@endnode

@node "Buttons" "Buttons"
@{b}@{fg shine}Buttons@{ub}@{fg text}

@{b}There's 15 buttons on top-left of the window and a few more outside of that
cluster. The buttons mean the following:@{ub}

@{fg shine}Button 1 - The two arrows@{fg text}

The two arrows select if you want interleaving enabled. Interleaving means
that the original 68k source code is inserted throughout the output file.
With interleaving disabled (arrows point in opposite direction) you will only
see the PPC code.

 x
         move.l  (d13),d1
         add.l   d1,d2

With interleaving enabled (default), the code is converted to:

 ;x
 x
 ;       move.l  (d13),d1
         lwz     r4,0(r10)
 ;       add.l   d1,d2
         addco.  r5,r5,r4

@{fg shine}Button 2 - r13@{fg text}

With this button you can select the stackpointer. Pressing this  button will
make it change to r27, which equals a7. You should use this button if you
don't want to use the userstack which is given to you by PowerUp/WarpUp. The
user-stackpointer for this userstack is normally r13. Using a7 as stack
pointer means that stack emulation sohuld work with any kernel.

When you select r27 as a stack pointer, PPC680x0 automatically adds a space
in the end header of the output file. This space is the size of the
stackpointer in longwords as selected in the string-gadget named 'stacksize
a7'.

@{fg shine}Button 3 - a7 sp@{fg text}

This button is used in combination with button 2. 'a7=sp' means that using
'sp' in your code is treated the same as using 'a7'.

Why should you use this? Well, it's all quite easy: Because of the
advanced register model of PPC680x0, it could be possible that you want to
use a7 as a general purpose register instead of a stackpointer.

For example, using:

        move.l  (a7),d0

can have different effects. The command 'move.l  (a7),d0' means that you
want to copy the indirect value of a7 into d0 with a longword size. In
original 680x0 code, a7 is always used as the stackpointer, meaning that the
instruction is entirely the same as 'move.l  (sp),d0'. Disabling the 'a7=sp'
button means that you can use a7 and sp as two different registers. Of
course this button has no effect if button 2 is set to 'r27', which means
that 'sp' is always decoded to r27. When converting original 680x0 code,
this button should always be set to 'a7=sp'. Default is Off.

@{fg shine}Button 4 - Wup@{fg text}

Select WarpUp (Wup) or PowerUp (Pup) porting mode.

@{fg shine}Button 5 - Gpr@{fg text}

Display the General Purpose Registers or Floating Point Registers in the
information window.  There's a part in the information window called '680x0
register usage'. This button switches between displaying the amount of GPR's
used and the amount of FPR's used. Registers are always 68k sided, which
means that 0 means d0 etc.@{fg shine}

Button 6 - ?ERR@{fg text}

When enabled (not masked out) all totally unknown errors (which are usually
trash) are copied as ERRORUNKNOWN. When disabled (selected) these errors are
ignored.

@{fg shine}Button 7 - Proc Dir@{fg text}

Process Directory. Pushing this button will start the directory processor
and learner, allowing the user to convert an entire directory. Please note
that the input dir should not  contain binary files as they will be treated
as source codes,  resulting in null files or a trash error.

After pressing this button, a requester pops up asking the following
question:

@{i}'What Should I Do?'@{ui}

with three buttons:

@{i}'Process Dir'   'Learn'   'Flush'@{ui}

'Process Dir' allows the user to convert an entire directory. Before this
can be done, the directory should first be 'learned'.

The 'Learn' button does this job: It is only required once every project.
After pushing the 'Learn' button, an ASL requester pops up asking for the
input directory. This should be a directory with 68k source files containing
symbols, macros etc. that have to be resident for converting the directory.
All the important symbols are @{"learned" link "Learning" 0} to 'ram:MACROFILE'. This MACROFILE may
be copied by the user at any time. Therefore, if you have learned a
directory you can drag the ram:MACROFILE to a place on your harddisk while
you are in Workbench. When you need that file a few weeks later, you simply
drag it back to RAM:.

The 'Flush' button clears the ram:MACROFILE. This should be done when a new
project is about to be converted.

So, how does the directory processing work? When pressing the  'Process dir'
button, you get an asl requester where you should  select the input
directory. After selecting the input directory,  you get a requester asking
for the output directory (which  should of course not be the same as the
input directory). When you have selected the directories, conversion
is started and can be stopped using PPC680x0s close gadget.

@{fg shine}Button 8 - 32@{fg text}

Selects if your output code should be PowerPC 32-bits implementation or
64-bits implementation compatible. If you don't know in what mode your PPC
is running you should check the WarpUp/PowerUp manual. Normally (in all
Amiga PPC implementations before the 28th of December 2004) this is 32-bits 
and therefore the button defaults to that. 64-bits mode is untested,

@{fg shine}Button 9 - 00 0@{fg text}

Carry Emulation On/Off. When set to '00 1', carry emulation is enabled.
Carrying goes in quite a different way on the PowerPC, as there's no carry
in the Status Register anymore but in a special register called the XER.
Selecting carry emulation means that almost all instructions change the
carry in the way they should change it on an 680x0 CPU. (Default is off)

@{fg shine}Button 10 - Rest Off@{fg text}

Rest emulation for divisions enable/disable. (default=off)

@{fg shine}Button 11 - Stat Off@{fg text}

Status Register/Condition Code/Lower-level Emulation. 

Enables no-carry SR/CCR emulation. Default is disabled.

@{fg shine}Button 12 - Frc@{fg text}

When selected (default), all  address accesses are forced to 32-bits when 
working in 64-bits implementations. This is useful if your PPC does not 
support more than a 32-bits address bus. Effective Address calculation then
automatically zeroes the upper 32-bits of the address. This button has no 
effect if Button 8 is set to 32-bits implementations.

@{fg shine}Button 13 - Asl In@{fg text}

This is the disk button on left of the input selection string. Pressing this
button pops up an ASL requester to select the source file.

@{fg shine}Button 14 - Asl Out@{fg text}

This is the disk button on left of the output selection string. Pressing
this button pops up an ASL requester to select the destination file.

@{fg shine}Button 15 - Big 'M'@{fg text}

Press this button to start converting the files selected using buttons 13
and 14. 

After pushing this button, PPC680x0 will start converting.  Conversion can
be stopped using PPC680x0s close gadget.

@{fg shine}Button 16 - Full@{fg text}

This button switches between perfect address loading and 'Quick Bad'
loading. Quick Bad loading should not be used if you don't know much about
the PPC. It adds all the 16-bit parts as signed  data in a following way:

 move HighWord,regA
 add  LowWord,regA

This causes an overflow, though, as $7fff as the low word is still a positive
add and $8000 a negative add. This means that when  the high word is $1234
and the low word $7fff you will get 

 $12347fff

but when the low word is $8000 you will get

 $12338000

which is obviously wrong.

@{fg shine}Button 17 - X=D@{fg text}

This button lets you select if you want to emulate Floating Point .X
extended precision values. When enabled (Default),  they will automatically
be converted to double precision. When disabled, .X usage results in
ERRORs.

@{fg shine}Button 18 - CFG@{fg text}

You can load or save the configuration here. Pushing this button pops up a
requester asking you to load, save or  cancel the operation. Loading and
saving can be done to and from 6 different slots stored in the SYS:s/
directory.
@endnode

@node "Display Information" "Display Information"
@{b}@{fg shine}DISPLAY INFORMATION@{ub}@{fg text}

@{i}The display information means the following:@{ui}

 'errors' counts the amount of errors occured

 'predec' counts the amount of pre-decrements used
 'pstinc' counts the amount of post-increments used
 'integr' counts the amount of integrate-modes used
 'immval' counts the amount of immediate values used
 'direct' counts the amount of direct registers used

 'normal' counts the amount of normal instructions used
 'single' counts the amount of single instructions used
 'genera' counts the amount of general instructions used
 'specia' counts the amount of special instructions used
 'psuper' counts the amount of super instructions used
 'implie' counts the amount of implied instructions used
 'branch' counts the amount of branching instructions used
 'extend' counts the amount of extend instructions used

 'lineno' displays the line being processed. (every 128)

@{fg shine}  The 680x0 register usage counts all the registers that are used during the
code. 0 equals d0 (=r3) and 17-24 equals a0-a7  (=r20-r27). SP means stack
pointer, FP means FPU register usage. Button 5 selects if this part displays
the GPR's or FPR's used in the code.@{ub}@{uu}@{fg text}
@endnode

@node "Errorrrrrrrrrrrrrrrr" "Errorrrrrrrrrrrrrrrr"
@{b}@{fg shine}ERROR MESSAGES@{ub}@{fg text}

@{i}At this moment, PPC680x0 has 37 error messages. Here's a quick guide through
them:@{ui}

@{fg shine}GENERAL ERRORS@{fg text}

 * ERROROVERFLOW

 Although theoretically impossible, this error detects a buffer
 overflow. PPC680x0 allocates 256kb for 100 lines of decoding which
 is impossible to achieve, except if all 100 lines use 2*32 indices
 etc.. This error is always on bottom of the file.

 * ERRORUNKNOWN

 This is an error that is usually caused by trash in the
 instruction area. For example:

 mofe.l  (a0),d0

 causes this error to pop up. It might also be any other undetected
 error...

@{fg shine}OTHER ERRORS (ALL USER ERRORS!)@{fg text}

 * ERROR1

 This means that there a problem in the BWL area of the
 instruction. This can be caused by things as 'move.k' or 'move.'.
 Should always be a user error.

 * ERROR2

 Instruction not really implied.
 You have somehow placed a non implied instruction in an implied form.
 For example:

  divu.l

 causes this error to come, as there should be some input for the
 command. 'divu' is not an implied instruction.

 * ERROR3

 Instruction not supported.
 The instruction you have used is not supported by the promo version 
 of PPC680x0.

 * ERROR4

 Unknown. Probably trash or forgotten comma.

 * ERROR5

 Bracket expected after label. PPC680x0 is scanning for a bracket
 but cannot find one...

 * ERROR6, ERROR7, ERROR8

 Error in element A, B or C respectively. This is an error caused
 by bugs in the elements of the integrator unit input. (See
 InsideDetails) Elements are placed in the following way:

   A([B1,B2,B3,B4,...],C1,C2,C3,C4,C5,...)

 * ERROR9

 64-bits in 32-bits mode. This error pops up when you are using
 64-bits instructions without 64-bits implementations (Button 8)
 enabled.

 * ERROR10

 Wrong lea mode. The lea (load effective address) mode you are
 using is wrong.

 * ERROR11

 Destination immediate. Come on...! A destination cannot be
 immediate!!! (i.e.  move.l  d0,#13)

 * ERROR12

 Super Group Unknown. The super instruction you are using is not
 known by PPC680x0.

 * ERROR13

 Super Command Bad. The super instruction you are using has
 register-only operation for the selected field.

 * ERROR14

 Super Command Bad. The super instruction you are using has
 label-only operation for the selected field.

 * ERROR15

 Super Command Bad. Both fields (label and register) are bad.

 * ERROR16

 Bad Super Command Nth element. The super command you are using has
 a bug in one of the higher elements.

 * ERROR17

 Dh:Dl expected. You have placed a ':' behind a register but no
 second register behind the ':'.

 * ERROR18

 Movem register bug. Something is wrong with your 'movem'
 instruction...

 * ERROR19

 (movem) '-' , '/' , ',' expected.

 * ERROR20

 Movem needs directfield and integration field.

 * ERROR21

 Floating point .s/.d/.x detected without FPU enabled

 * ERROR22

 Floating point .p not supported

 * ERROR23

 Floating point unit not found

 * ERROR24

 Bad Register

 * ERROR25

 Floating point .x not enabled

 * ERROR26

 Floating Point Group BAD, report to author

 * ERROR27

 Not supported (RESERVED)

 * ERROR28

 FPR Expected

 * ERROR29
 
 aN expected

 * ERROR30

 No WarpUp Mode

 * ERROR31

 equr/equrl/reg/fequr incorrect

 * ERROR32

 move16 addressing mode not supported

 * ERROR33

 MACRO not terminated (no end sign)

 * ERROR34

 Illegal SR/CCR access

 * ERROR35

 fmovem Dn,Dn not allowed

 * ERROR36

 PPCDirect Super III command bad

 * ERROR37

 PPCDirect Super III RESERVED ERROR (may occur!)
 Usually an unsupported addressing mode
@endnode

@node "PortingIndex" "PortingIndex"
 @{b}@{fg shine}PORTING PROGRAMS@{ub}@{fg text}
 ----------------

  @{"Pre-optimizing" link "Pre-Optimizing" 0}
  @{"Converting" link "Converting" 0}
  @{"Post-Optimizing" link "Post-Optimizing" 0}
  @{"Branch Prediction" link "Branch Prediction" 0}
  @{"Trial And Error" link "TrialAndError" 0}
  @{"Assembling" link "Assembling" 0}
  @{"PowerAsm trouble?" link "PowerAsmTrouble" 0}
  @{"Interrupts" link "Interrupts" 0}
  @{"Learning" link "Learning" 0}
  @{"FD File Usage" link "FD File Usage" 0}
@endnode

@node "Pre-Optimizing" "Pre-Optimizing"
@{b}@{fg shine}Pre-Optimizing@{ub}@{fg text}

This is the first step that can be taken when you wish to port a 68k program
to PPC. Pre-optimizing is performed in the input 680x0 source code.

This step is only important if you wish to make your port faster than it
already is. Therefore, it might only be useful to do this after the PPC port
is running without pre-optimizations: It doesn't make sense to pre-optimize
a program that already runs at full speed.

Pre-optimizing requires knowledge of the PPC processor and its design.
PPC680x0 has quite a powerful optimizer, so pre-optimizing  may not have
much effect on the performance.

There are some PPC commands which might be useful when pre-optimizing a
source code. The most important commands are described in the Useful
Commands section. One of the commands that should really be used is the
'srolmi' (PPC: rlwimi) command as it can be very powerful.

Take a look at the @{"Optimizing" link "Reaching PPC Native Speed" 0} chapter to find out how you can make programs
faster in general.

@{b}@{fg shine}Other Pre-Optimizations...@{ub}@{fg text}

It might be useful to chose the correct porting modes for certain parts of
the source code to make it run faster. One of the most important features to
take care of are Status Register Emulation and Carry Emulation. Both may
cause the program to run a bit slower than it used to be, as they have to
alter parts of the status register by inserting/clearing/setting certain
bits. Therefore it is recommended to only use these options in a more
efficient way. Most of the time, carry emulation is only useful for
rotate/shift commands: Use the 'shiftcarry' option in that case. Status
Register emulation rarely has effect on the way a program executes so it is
recommended to keep this disabled when you don't think it might be useful.

@{b}When you are a more experienced programmer it is always better to change the
options throughout the program. For example:@{ub}

 start
         <program>
         dostat
         swap    d0
         bvc     label
         nostat
         <rest of program>
 label

will assemble the 'swap' command correctly by clearing the overflow-flag in
the status register.

Also useful is the "CTR" or Count Register. Check your PPC manual for more
information about this register used mostly for conditional loops.

@{b}Two options that are always recommended to be enabled when porting are the
'forceb' and 'shiftcarry' options.@{ub}
@endnode

@node "Converting" "Converting"
@{b}@{fg shine}CONVERTING OLDER 68K PROGRAMS@{ub}@{fg text}

@{i}This is a section about converting older 68K executables or source codes to
the PowerPC platform. @{ui}

It may look very easy when you read it but we would like to note  that it
may get more complicated if the input code uses complex interrupts,
low-level instructions, self-modifying code or multiple  sections... However, 
many programs can be converted without too much problems.

@{b}Please keep in mind that this section is written for systems running Haage &
Partners' WarpOS: Although PPC680x0 supports PowerUP, no real testing has
been done for this mode. It is time to switch to just one kernel instead of
two, and the best of the two is definitely WarpOS.@{ub}


@{i}Here we go!@{ui}

First of all, you should get yourself a reassembler that is able to recreate
codes in an efficient way, so that you can make sure everything is reassembled 
correctly.

One of the best reassemblers around on the Amiga is @{fg shine}Ingo Molter's 'In_Go'@{fg text},
which is available from the Aminet. Another good one is the @{fg shine}Maxon
Reassembler@{fg text} supplied with Maxon Asm. Older versions may have become freeware
on magazine covers so it shouldn't be a problem to get it somewhere. Using
multiple reassemblers is sometimes more effective than using just one...

Assume you want to convert a program to the PPC: For example, you  take a
utility that needs to be converted.

Of course, you first load it into the reassembler and save it as an
assembler source code.@{fg shine} Make sure that all the code sections  are reassembled
correctly, as several reassemblers do not take  care of this automatically.
Also, data should not be reassembled as code! Read the manual of the
reassembler before using it!!!@{fg text} When  all this is done, you have a
source code of the program you wish  to convert.

Now comes the first part of the PPC680x0 conversion: Enhancing the program
to make it run on a PPC.

First of all, you have to find the first instruction that needs to be
executed and put a 'prolog' (with the size of your stack frame) there,
followed by a 'head' command.

x
        prolog
        head
        <program>

@{i}or@{ui}

x
        prolog  16384      (if you fancy a bigger stack frame)
        head
        <program>

Then search the very last @{b}*returning*@{ub} 'rts' and change it to a 'lastrts'
instruction. Finally, scroll to the bottom of the file and put a 'tail'
instruction there:

x
        prolog  16384
        head
        jsr     routa
        jsr     routb
        lastrts

routa   move.l  #1,d0
        rts

routb   move.l  #2,d0
        rts

        tail

Now, go to the top of the source code and put the incdir (include-path) and
'powerpc.i' include there, followed by a 'warpreq' command. It might be
necessary to add the 'forceb' command after the 'warpreq' as well. Also,
'shiftcarry' is recommended for most source codes.

        incdir  ppcinclude:
        include powerpc/powerpc.i

        warpreq
        shiftcarry
        forceb

x
        prolog  16384
        head
        jsr     routa
        jsr     routb
        lastrts

routa   move.l  #1,d0
        rts

routb   move.l  #2,d0
        rts

        tail

@{fg shine}It may be useful to remove ALL 'section' commands as multiple sections may
cause crashes after assembly with PowerAsm.@{fg text} (Especially when loading or
storing from/to an other section  occurs...) But beware: New versions of
PowerAsm may have this  fixed, what makes converting a lot more easier.

Also, make sure there are NO double symbols. Especially '_SysBase' must be
defined by PPC680x0. @{fg shine}A '_SysBase = 4' will cause a big crash so watch
out!!!@{fg text}

@{b}Save your file away now!@{ub}

Okay, the most important things have been finished now. 

The next step in the PPC680x0 conversion: Load your source code into
PPC680x0 and select a destination output file. The default settings of
PPC680x0 should be good for most current PowerPC CPUs and all current
603/604 Amiga implementations.

It might be necessary (for some programs) to make a stack if you  want to
use an other stack pointer than r13: In that case set the stacksize to a
value from which you think it should be big  enough. The 40000 bytes (10000
long) default should be more than enough. Don't forget to push the 'r13'
button (Button 2) for this mode! Remember: @{b}This is NOT required for most
programs. Using the 'prolog' command does nearly the same but doesn't makes
your source code bigger!!! So remember: User stack frames are usually
useless for porting...!@{ub}

Finally, press the 'Motorola M' convert button and wait until the conversion
is finished. 

You should now assemble your program with Storm PowerAsm or any similar
assembler. Select the file you have converted:

@{i}powerasm <file.ppc> TO <file.ppcexe>@{ui}

The output file should be executed as documented in the WarpUp manuals.
Double clicking should be well enough for normal programs.

Normally, the file is not assembled at once. PowerAsm reports some errors
while assembling, and it is vital to remove those errors. Take a look at the
@{"Trial And Error" link "TrialAndError" 0} section when this occurs.


@{b}@{fg shine}IMPORTANT NOTES!!!@{ub}@{fg text}

One precaution must be taken when converting:

The execbase is detected in most cases, but there are a few exceptions to
the rule. One of those exceptions is the following: 

        move.l  #$4,a0
        move.l  (a0),a6

This will not be detected and therefore it has to be modified by hand.

It can be illegal to use address $4 for this from the PPC side, so  those
commands should be changed from:

        move.l  #$4,a0
        move.l  (a0),a6

TO:

        move.l  _SysBase,a6

Direct loading from address $4/%100/@4/4 (with or without leading zeros),
'_SysBase' or 'execbase' is always detected and does not need any
assistance.

Also, take care that there are no multiple symbols with  different values:
For example, 'label  set  value' should not be used multiple times using the
same label but a different value.


@{b}@{fg shine}Final Note:@{ub}@{fg text}

It is always useful to take a look at the program before you  start the
conversion job: Interrupts and several other  low-level commands are not
always converted perfectly and should be modified by the user. These
commands are used rarely: Usually, they are only used in very small parts of
a code.  Please remember that the PPC interrupt model differs a lot  from
the 68k model, which means that the best way to use most Amiga interrupts on 
WarpUp is by using the 68k processor for that.
@endnode

@node "Post-Optimizing" "Post-Optimizing"
@{b}@{fg shine}Post-optimizing@{ub}@{fg text}

Post-optimizing is a step that should only be taken if you think it is
useful. This step means that the PPC output source code of PPC680x0 is
edited to optimize the  program.

Only experienced PPC programmers will find any use in post-optimizations.
However, taking a look at the output source code can be very useful for
programmers who want to understand the PPC CPU a little better.

In most cases, post-optimizing makes no sense, as all the post-optimizations
can be done as @{"pre-optimizations" link "Pre-Optimizing" 0} which are much easier to handle, as they
are performed on a smaller source code (the input) and can be ported
multiple times afterwards. (All post-optimizations are gone when you have to
port the 68k source code for another time, as the output source code in
which the optimizations had been done, will be replaced with a new one.)
Therefore, @{"pre-optimizing" link "Pre-Optimizing" 0} is always  recommended.

@{fg shine}A useful hint for all post-optimizers:@{fg text}

Make sure that not only ppc instructions are replaced with new ones: It is
very easy to make @{"context-switches" link "ContextSwitches" 0} a bit faster by removing registers
loads/stores that are not used by any of the  @{"68k library calls" link "68K Calling" 0} in the input
program. Simply seek the RUN680x0  macro in the output source-code and
remove the unnecessary lines. For example, register d7 is not used as an
input for most library calls. Therefore the stw/lwz lines storing and
loading r10 can be removed. But beware, don't remove important lines!!!

Check FD file usage to make PPC680x0 auto detect register usage for library
calls.

@endnode

@node "Branch Prediction" "Branch Prediction"
@{b}@{fg shine}Branch Prediction@{ub}@{fg text}

The PowerPC processor has some nice on-chip features from which one of
them is called Branch Prediction. This feature uses some standard rules 
to possibly make code run faster. For example, you can chose if a 
conditional branch instruction is more  likely to be taken or more 
likely to be missed:

        beq+    label

means that the instruction is optimized for taking the branch, while

        beq-    label

optimizes the instruction for not taking the branch.

This means that when the programmer thinks that there is more chance for a
branch to be taken (s)he adds a '+' and if not (s)he adds a '-'.

There are three options to select the current branch prediction mode for
PPC680x0. 'branchyes' defaults all the conditional branch commands to a '+',
'branchno' defaults them to a '-' and 'branchdef' uses the default mode.
@endnode

@node "TrialAndError" "TrialAndError"
@{b}@{fg shine}Trial And Error@{ub}@{fg text}

Trial And Error is a debug method which is used to remove errors from the
PPC68k output source code. Actually, PowerAsm or any other good compatible
assembler is the tool that helps you in finding these bugs. When these
errors are located, they can be removed easily to allow the output file to
be assembled.

It is quite easy to get through this part of the conversion.

After converting the source code with PPC68k, it has to be assembled. When
the file is being assembled, it is highly  possible that some errors occur
which could not be eliminated by  PPC68k. Happily, the assembler does detect
certain bugs, so it  makes it useful to search for them.

So how does it work? First of all, try to assemble the output file:

<CLI> @{i}powerasm input TO output@{ui}

In some cases, alignment errors will occur.

If PowerAsm reports 'alignment errors' you should go to a text editor like
'CygnusEd' and find the line that causes it (The line that is shown in the
PowerAsm error output). Place an 'align.l'  in front of that line, just
after the data (dc.x etc.) that causes it. PPC680x0 does automatically
aligns code but may skip an alignment command when it is positioned between
two block boundaries. In many cases, no alignment errors will occur.

After this is done you should assemble the file again to find out where the
next errors are located. This should be repeated until the entire file is
finished and assembled.

@{fg shine}A list of other common errors are:@{fg text}

 * Illegal branch to another section

When this occurs, multiple sections have been used in the source code.
PowerAsm often has problems with different/multiple  sections so this error
can only be fixed by removing all the section commands throughout the
source code.

 * Illegal use of a relative symbol

Usually a result of a badly detected symbol or a relative branch where an
absolute branch is required. Take a look at the line where the error is
located: When the error is caused by a branch, the 'b' or 'bc' command has
to be replaced with a  'ba' or 'bca'. (Or you can also replace the 68k
command with a 'jmp' instead of a 'bra') When the error is not caused by a
branch, it might be the result of an unknown 680x0 command.

 * Command/Directive not allowed in BSS Section

Some reassemblers create BSS sections with other data than zeros. In this
case, remove the BSS section by masking out the "section BSS". (Best is to 
remove all the section instructions except for the 'main'-section)

 * (after assembly) file is not executable

Remove sections, this is a bug caused by PowerAsm. If this does not work it
might be possible that the 'powerbug' mode has been disabled using the
'poweroff' command.
@endnode

@node "Assembling" "Assembling"
@{b}@{fg shine}Assembling@{ub}@{fg text}

Ofcourse, the output file of PPC680x0 has to be assembled. Before you read
this section, make sure you have read the @{"Trial And Error" link "TrialAndError" 0} section as it
contains very important information on assembling as well.

PPC680x0 is built for WarpUp and fully supports Storm  PowerAsm. Therefore,
the most useful PPC assembler to assemble the output source codes is by no
doubt PowerAsm available from Haage&Partner. There are a few bugs in this
assembler, but the wide amount of features makes it a real must.

To assemble the output file, you should open a Shell or CLI and enter:

@{i}powerasm <ppc68koutputfile> TO <ppcexecutable>@{ui}

PowerAsm's default options should be well enough to assemble PPC680x0s
output. For trouble with PowerAsm, please approach author Sam Jordan.

After assembling, the executable can be double-clicked and run if it is
ported properly. Elsewise, there might be a few complications caused by
complex brackets, interrupts or anything that is not supported perfectly.
Tracing those bugs shouldn't be too difficult, though.
@endnode

@node "PowerAsmTrouble" "PowerAsmTrouble"
@{b}@{fg shine}PowerAsm Trouble?@{ub}@{fg text}

@{i}Even though PowerAsm is a very powerful assembler, it is absolutely not
bug free. Therefore, this section has been added to the guidefile.@{ui}

First of all, the most dangerous bug in PowerAsm is the multiple
sections bug. When data is loaded or stored from a chip ram section and code
is located in fast ram, PowerAsm will not assemble the file correctly if the
file is bigger than a certain amount of assembly lines. This bug can be
tested on both 68k and PPC based machines, as it creates a file that is not
executable.

Another bug can be found in commands using the value '0' when 'r0' is being
used. Motorola recommends to use

        addi    r3,0,100      (add 100+0 into r3)

instead of

        addi    r3,r0,100

as it is more logically. Register r0 is not being used. PowerAsm can give
fatal crashes when the 'addi    r3,0,100' suffix is being used. Therefore,
ONLY use the 'r0' suffix when using PPC native commands.

There are more tiny bugs in PowerAsm, but as they don't often occur it is not
worth mentioning them. Solving the bugs is normally quite easy, so it
shouldn't be a problem that they exist. Just make sure that the above
mentioned bugs don't get a chance to crash your machine, as it can be highly
frustrating: We have had several harddisk validation sessions when we didn't
know about them...
@endnode

@node "Interrupts" "Interrupts"
@{b}@{fg shine}Interrupts@{ub}@{fg text}

The Amiga's PowerPC implementation is totally different  from the 680x0 when
it comes to interrupts. This is  mainly because the 680x0 has all the
custom chip interrupt  lines connected and the PPC has none. Therefore it is
recommended to leave custom chip interrupts to the 68K.

A very nice PPC IRQ is the Time Base. A special section has been dedicated to
that feature.

PPC Interrupts are mainly referred to as exceptions. Therefore we will refer
to them as exceptions as well. PPC exceptions are divided into 4 classes:

@{fg shine} 1. Asynchronous / nonmaskable@{fg text}

    (Machine Check and System Reset exceptions)

@{fg shine} 2. Asynchronous / maskable@{fg text}

    (External Interrupt and Decrementer exceptions)@{fg shine}

 3. Synchronous  / precise@{fg text}

    (Instruction-caused exceptions, but no FPU-imprecise)

@{fg shine} 4. Synchronous  / imprecise@{fg text}

    (All instruction-caused (FPU) imprecise instructions)

@{b}Exceptions are split up in 3 stages:@{ub}

 - Recognition: The processor identifies the condition
                causing an exception
 - Taken:       Control of the instruction execution is
                passed to the exception handler: The
                context is saved and the instruction at the
                appropriate vector offset is fetched to 
                start the exception handler routine in
                supervisor mode
 - Handling:    The software linked to the vector offset 
                address is begun in supervisor mode

When using PowerPC exception, make sure you save the contents of SRR0 and
SRR1 at the beginning of the exception handler routine. A higher level
interrupt may cause the registers to be flushed or changed, which may result
in a bad instruction flow.

Don't ever use exceptions by banging the PPC!!! Use the library functions
supplied with WarpOS.

In Amiga systems, it is highly recommended to use the 680x0 CPU for
exception handling (as it is connected to the custom chips). The 680x0 then
supplied data to the PowerPC  when required.

For more information on the exceptions itself, please refer to the PowerPC
Programming Environments Manual. Using exceptions requires a lot of
knowledge of the PPC  programming architecture.@{fg shine}

For information on the Amiga's PPC exceptions, please refer to the guidefile
supplied with WarpOS. It contains quite some information on how to use PPC
exceptions on the Amiga.@{fg text}
@endnode

@node "Learning" "Learning"
@{b}@{fg shine}Learning@{ub}@{fg text}

Learning is the process required to understand all the symbols of a
source code. For example, a symbol can be an absolute value or an address.
If there is no knowledge of the type of that symbol, the program will not be
assembled correctly. Allow us to demonstrate:

label
        move.l  #label,d0

is different than

label   equ     $12345

        move.l  #label,d0

The first one will load the address 'label' into d0, while the second one
loads the value $12345 into d0. PPC680x0 learns all the required symbols to
prevent mistakes.

All the learned symbols are placed onto the Ram Disk. When files are learned
multiple times, PPC680x0 uses the first one available in the learnfile.

There are two operations that PPC680x0 can perform on a learnfile. The first
one is expanding the @{"learnfile" link "Working With A Learnfile" 0} by  learning new files, the second one is
clearing (flushing) the learnfile for use with a new project.

@{b}ALL files that contain data for the input source code have to be learned,
which means that it is useful to put all external includes in a single
'learn directory' to make sure that no errors are produced during
conversion.@{ub}

Reassembled files usually don't need any system includes, so learning files
is often not necessary for that.
@endnode

@node "FD File Usage" "FD File Usage"
@{b}@{fg shine} FD File Usage@{ub}@{fg text}
 -------------

This is a very new option which has been added since version 1.20. In the
PPC680x0: path a new file has been added called "PPC680x0.fd". This file is
a standard .fd file containing  library function names and the registers
being used by those  functions. When 'usefd' is enabled, PPC680x0 has direct
access to this .fd file and is able to detect which registers should  be
saved or restored when a certain function is called. The  .fd file is freely
editable, so anyone can add extra functions  or libraries to it. @{fg shine}IT IS A
MUST TO ENABLE THIS OPTION WHEN 68K LIBRARIES ARE BEING USED@{fg text}. When 
libraries cannot be found in the .fd file, PPC680x0 automatically saves/restores 
the registers selected using allregs/mostregs/someregs. @{b}Make sure the names of
library calls correspond with the names as found in the official AMIGA
Kernel documentation.@{ub}

Currently the following libraries are supported:

 - amigaguide
 - asl
 - battclock
 - battmem
 - bullet
 - cardres
 - cia
 - colorwheel
 - commodities
 - console
 - datatypes
 - diskfont
 - disk
 - dos
 - dtclass
 - exec
 - expansion
 - gadtools
 - graphics
 - icon
 - iffparse
 - input
 - intuition
 - keymap
 - layers
 - locale
 - lowlevel
 - mathffp
 - mathieeedoubbas
 - mathieeedoubtrans
 - mathieeesingbas
 - mathieeesingtrans
 - mathtrans
 - misc
 - nonvolatile
 - potgo
 - ramdrive
 - realtime
 - rexxsyslib
 - timer
 - translator
 - utility
 - wb
@endnode

@node "ProgrammingEnvironmentIndex" "ProgrammingEnvironmentIndex"
@{b}@{fg shine} PPC680x0 PROGRAMMING ENVIRONMENTS@{ub}@{fg text}
 ---------------------------------


  @{b}PPC Programming Model@{ub}
   - @{"UISA, VEA, OEA" link "UISA VEA OEA" 0}
   - @{"PPC Conventions" link "PPC Conventions" 0}
   - @{"Reaching PPC native speed with PPC680x0" link "Reaching PPC Native Speed" 0}

  @{b}Entering Warpspeed@{ub}
   - @{"68K Kernel Calls" link "68K Calling" 0}
   - @{"PPC Kernel Calls" link "PPC Calling" 0}
   - @{"Context Switching?" link "ContextSwitches" 0}
   - @{"Parallel 68k/PPC tasks" link "Parallel Tasks" 0}
   - @{"Usage of the PPC Time Base Register" link "Usage Of The TBR" 0}
@endnode

@node "UISA VEA OEA" "UISA VEA OEA"
@{b}@{fg shine}UISA, VEA, OEA@{ub}@{fg text}

@{i}These are the three operating modes of the PowerPC. They can be ordered in
the following way:@{ui}

UISA is a part of the VEA, which is a part of the OEA. This means  that the
OEA defines the entire PPC architecture, while both VEA  and UISA define a
part of it. UISA defines a part of the VEA.

UISA stands for User Instruction Set Architecture, which is equal  to the
user level of the MC680x0 CPUs. This means that you are  able to run all
non supervisor level instructions in this mode. Supervisor level is often
referred to as the 'priviliged' level of a processor.


@{fg shine}The following registers belong to the UISA@{fg text}


GPRs (General Purpose Registers) 0-31

 32 registers which are 32-bits in 32-bits mode and 64-bits in
 64-bits mode. Can be used for general purpose.

FPRs (Floating Point Registers) 0-31

 32 64-bits registers for Floating Point data.

Conditon Register

 32-bits register with 8 condition register fields:

         CR0 CR1 CR2 CR3 CR4 CR5 CR6 CR7

 all being 4 bits in size. The 4-bits are defined as follows:

      LT GT EQ SO
 bit   0  1  2  3 

 where LT = negative result
       GT = positive result
       EQ = zero
       SO = Copy of XER[SO] bit

Floating Point Status and Control Register (FPSCR)

 32-bits register with all the FPU exceptions and control tags

XER Register (XER)

 32-bits register:

     SO OV CA | 00000000 |     Byte Count
 bit  0  1  2 | -------- | 25 26 27 28 29 30 31

 where SO = Summary Overflow (STICKY, not automatically cleared)
       OV = Overflow
       CA = Carry

Link Register (LR)

 64/32-bits address register, mainly for use with branching 
 instructions

Count Register (CTR)

 64/32-bits address register, mainly for use with conditional
 branching instructions. (For example: CTR automatically 
 decrements at every 'dbcc' and program continues when CTR=0)


@{fg shine}The following registers belong to the VEA:@{fg text}


All registers of the UISA.

@{"TBL/TBU" link "Usage Of The TBR" 0} (2x32 bits)

 Time Base Register Low and High, contains periodically
 incremented value for use with timing etc.. However, this
 register is implementation dependent, which means it may
 operate completely different on different implementations...

 You can simply read both of them in rA:rB by using:

 smovec   TBR,rA:rB

 Both the VEA and OEA instruction set and registers can 
 only be accessed in supervisor mode!


@{fg shine}The following register belong to the OEA:@{fg text}


All registers of the UISA and VEA.

Machine State Register - MSR

 Contains configuration of the PPC operating mode.

Processor Version Register - PVR

 Contains the ID of the processor

All MMU and Exception registers

Time Base Write and Decrementer register
@endnode

@node "PPC Conventions" "PPC Conventions"
@{b}@{fg shine}PPC Conventions@{ub}@{fg text}

The question is: To PPC or not to PPC? There are now two processors which
can be utilitized: The 68k and the PPC processor. Sometimes, the 68k can be
very useful to do part of the calculations: However, the memory bus of the
current mixed 68k/PPC accelerators is shared, meaning that PPC performance 
can drop when the 68k is intensively using memory (or vice versa).

On the other hand, several algorithms that do not require much memory access
can be run on one CPU, while the other does the memory intensive tasks.
Memory accesses slowdown relatively more on a PPC than on a 68k: In the time
of one memory access, the PPC can execute a whole lot of non memory access
instructions.

Even though the PPC is so fast in comparison to the 68060, it makes no sense
to leave the 680x0 alone. For example, the 680x0 can do C2P (Chunky To
Planar) conversions while the PPC is busy rendering the picture. Also,
general sound and stats routines  can be done by the 680x0 as they usually
don't take up too much CPU-time.

While designing a PPC program, the programmer should always keep in mind
that interfacing with the 68k takes up to 0.5 ms per switch. Therefore, don't
use any (or nearly no) @{"library calls" link "68K Calling" 0} in the middle of a complex algorithm.
They will slow down the algorithm too much and lower the PPC performance.

This means that it is more useful to do all 68k library calls etc. before
the main program (or algorithm) starts, and try to use as few as possible 68k
library calls in the 'main loop'.

@{fg shine}PPC libraries can ofcourse be used more intensively!@{fg text}
@endnode

@node "Reaching PPC Native Speed" "Reaching PPC Native Speed"
@{b}@{fg shine}Reaching PPC native speed with PPC680x0@{ub}@{fg text}

@{i}This is a very short chapter with a list of rules which should be utilized
if you want to make your program running at full PPC speed. Ofcourse, this
is not necessary for opening/closing library resources, but only for
CPU intensive algorithms.@{ui}

 1* Use as many .max accesses as possible with instruction forms.
    .max means that when you are using 32-bits implementations
    you should use as much .L instructions as possible and with
    64-bits implementations you should use as much .Q as
    possible, except for loading, storing, shifting and 
    rotations. On current Amiga implementations, 32-bits access
    and non 8/16-bits commands are always preferred.

 2* Use as much direct register modes as possible: Because of 
    the PPC design, it is much faster to load a value in a 
    register before manipulating it. This goes in the following
    way:

    move.l      (a0),d0     ;load from (a0)
    add.l       d0,d2       ;manipulate (a0) in register
    asr.l       d1,d2
    (other commands altering d0)
    move.l      d0,(a0)     ;store in (a0)

 3* For displacements, you should use as much .B/.W sizes as
    possible. So this means that when you are using an index 
    it is recommended to use a 16 or 8-bits displacement instead 
    of a 32-bits displacement. The register, however, is always
    recommended to be 32-bits.

    move.l      (label.w,d0.l),d4

    translates directly to:

    lwz         r7,label(r3)
    (=smove.l   (label,d0),d4)

 4* Use quick operands for move, add, sub when you are using
    immediate values from -32768 up to 32767. This is usually
    detected, but not always! Using a quick operand with a
    longword move and a register as the destination will
    convert to one single instruction:

    moveq.l     #12453,d0
  
    translates directly to:

    addi        r3,r0,12453
    (sadd       #12453,r0,d0)

 5* Try coding without carry emulation as it is much faster. 
    Without carry emulation, SR bits are set to the same values
    used in PPC assembly with CR update.
    Most instructions have condition update enabled, so the XER
    and CR should always contain the correct value.

 6* Pre-decrement is faster than post-increment. Try using it
    more often!

 7* Use FRC when your 64-bits PPC does not support 64-bits 
    addressing modes. This makes address calculation 32-bits 
    only.

 8* Use r13 as stack pointer for WarpUp output code. The 
    stack pointer of the kernel should use the same push/pop
    method as the default 68k model. 

 9* Try using some @{"super instructions" link "InstructionSetDetailsIndex" 0} as they can drastically
    improve performance:

      smove for moving data from/to memory
      sfmove for moving floating point data from/to memory
      rotations with masking (VERY USEFUL)

 10* Rest emulation for divisions is not slow! Use it if you want
     it! There's no need to use other methods if you need it!

 11* Use the FPU constant ROM as it IS emulated (and can even
     be edited by hand in s:fprom.s)!!!

 12* Subroutines are now fast enough! Use them...

 15* Integration is handy, but don't overdo it:
     2 labels and 2 registers with or without scaling  should be
     the maximum if you want optimal output code. Best way is
     to simply not it: See rule 3!

 16* Try to use nearly no memory access if possible! PPC CPUs 
     can execute many instructions in the time that memory access 
     is performed. A good way is to first load stuff from memory 
     into the desired registers and then calculate everything.
     More than one load/store command following another will
     cause slowdowns, so try to put them in the middle of
     several non memory access instructions.

     The best method is to use memory access only when it is
     *really* vital. Use them once every 20+ instructions and you
     will have an enourmous speed increase.

 17* Use the commands described in the @{"Important Commands" link "Instructions Useful" 0} section.
     Most of them are very useful for optimizing code!

 18* Don't use too many context switches. @{"Context switches" link "ContextSwitches" 0} are
     relatively slow and will lower the PPC performance level.

 19* The 603 and 604 have the following execution units:

     Integer  (3 integer units on 604!!!)
     Float
     Branch
     Load/Store
     System

     Make sure you design your program for optimal usage!
     Even though PPC680x0 has a powerful optimizer, it is
     like with modern compilers: @{"Hand-optimizing" link "Pre-Optimizing" 0} can be 
     faster!

 20* DON'T use BCD commands: They were added only for 
     compatibility and are slow! 'abcd', 'sbcd' and 'nbcd' are
     ONLY useful for porting.
@endnode

@node "68K Calling" "68K Calling"
@{b}@{fg shine} 68K Kernel Calls@{ub}@{fg text}
 ----------------

These are library calls that require a so called @{"context switch" link "ContextSwitches" 0}. Therefore,
these libraries should not be used in the middle of a complex algorithm as it
will slowdown the program a lot.

One @{"context switch" link "ContextSwitches" 0} takes up about 0.5 ms, a library call requires two
context switches.

@{b}68K library calling is very easy:@{ub}

First of all, you can use CALLEXEC, CALLGRAF, CALLINT and  CALLDOS to call
exec, graphics, intuition and dos routines respectively.

@{i}Example:@{ui}

         move.l  #25,d1
         CALLDOS Delay

PPC680x0 also has detection for library calling in the 'normal' way.
libon/liboff enables or disables this detection. Default is enabled. With
onexec/offexec, address 4 detection can be enabled or disabled. 

@{i}Example (library-calling with libon):@{ui}
 
 Delay   equ     -198

         move.l  #25,d1
         move.l  _DOSBase,a6
         jsr     Delay(a6)

@{i}Example (translation with onexec):@{ui}

         move.l  #4,a6

 will translate to:

         lw      r26,_SysBase

This means that coding can be done in a similar way as done before:
Library calls are automatically taken care of.
@endnode

@node "PPC Calling" "PPC Calling"
@{b}@{fg shine} PPC Kernel Calls@{ub}@{fg text}
 ----------------

@{i}PPC Kernel calling is very easy. There are several commands to make it even
more easy...!@{ui}

First of all, the 'warp' command automatically places a table with all
WarpOS library offsets in the source code.

To call a PPC library routine, the following should be done after loading
the correct inputs in the required registers:

        call     <routinename>

PPC680x0 makes a fully functional powerpc.library call from  the
instruction.

It may be the case that a macro named 'call' is already in  use be the
source code. Happily, the 'anticall' command  removes 'call' from PPC680x0s
instruction list and renames it  to 'callppc'.
@endnode

@node "ContextSwitches" "ContextSwitches"
@{b}@{fg shine} Context Switching?@{ub}@{fg text}
 ------------------

The process of switching between the 680x0 and PowerPC processor is called
'context switching'. Switching from one CPU to another takes up a relatively
long amount of time, though, which means that using them too intensively
will cause the program to slow down. One context switch takes up to 0.5
milliseconds of time, so using them should be done in a very careful way,
especially in the middle of complex algorithms (that should take as little
time as possible to finish).

Although it is theoretically not possible to switch at faster levels because
of the hardware design, software can prove the other way round. Sadly, a lot
of testing and timing is required to make the switches faster: Without
perfectly timed switches, the CPU gets strained or the machine will run
instable.

It takes up to two context switches using a @{"68K library call" link "68K Calling" 0} with  the PPC
processor: One to switch to the 68K, and one to switch back to the PPC.

Except for opening and closing libraries and allocating devices,  there is
no real need to call OS routines for several projects.  Most functions can
be done using PPC only code. (And maximally two context switches for the
graphic/sound handling.)
@endnode

@node "Parallel Tasks" "Parallel Tasks"
@{b}@{fg shine} Parallel 68k/PPC Tasks@{ub}@{fg text}
 ----------------------

@{i}It is possible to use both the 68K and PPC processors at the same time.
However, a lot of knowledge is required to do this in a safe way.@{ui}

First of all, when using parallel 68K/PPC tasks you must take care that one
of the processors does not require too many (or even better: none at all)
memory accesses. The bus of the  PowerPC board is divided over the two CPUs,
which means that  performance will drop drastically when both CPUs try to
load/store from/to memory.

Also, the CPU has to wait for the other CPU when it wants to know if it has
finished its task. Therefore, synchronization can be a tough job and is
often not even worth the effort.

On the other hand, if a programmer does manage to use both processors in an
ideal way, it can speedup things a lot.

Parallel @{"context switches" link "ContextSwitches" 0} can be achieved by using the WarpUp macros
'RUN68K', 'RUN68K_XL' and 'WAITFOR68K'. 

For more information please read the WarpUp documentation.
@endnode

@node "Usage Of The TBR" "Usage Of The TBR"
@{b}@{fg shine} Usage of the PPC Time Base Register@{ub}@{fg text}
 -----------------------------------

@{b}<UNDER CONSTRUCTION, FINISHED AFTER HARDWARE-SHEET ARRIVES>@{ub}
@endnode

@node "InstructionSetDetailsIndex" "InstructionSetDetailsIndex"
@{b}@{fg shine} INSTRUCTION SET INDEX@{ub}@{fg text}
 ---------------------

  @{"Introduction and Information" link "Instructions General" 0}
  @{"Highly Useful Instructions" link "Instructions Useful" 0}

@{fg shine} CATEGORY 1 - PPC680x0 Instructions@{fg text}

  @{"68K/PPC Kernel Instructions" link "Instructions Context" 0}
  @{"Compatibility Instructions" link "Instructions Compatibility" 0}
  @{"Control Instructions" link "Instructions Control" 0}
  @{"Vital Instructions" link "Instructions Vital" 0}

@{fg shine} CATEGORY 2 - PPCDirect Instructions@{fg text}

  @{"Arithmetic Instructions" link "Instructions Arithmetic" 0}
  @{"Data Transfer Instructions" link "Instructions Data Transfer" 0}
  @{"Other Data Transfer Instructions" link "Instructions Other Data" 0}
  @{"Floating Point Instructions" link "Instructions Float" 0}
  @{"Logic Instructions" link "Instructions Logic" 0}
  @{"Rotate and Shift Instructions" link "Instructions Rotate" 0}
  @{"Branching Instructions" link "Instructions Branch" 0}
  @{"Condition Register Instructions" link "Instructions CR" 0}
  @{"Low-level Instructions" link "Instructions Low Level" 0}
@endnode

@node "Instructions General" "Instructions General"
@{b}@{fg shine} PPCDirect Extended Instruction Set@{ub}@{fg text}
 ----------------------------------

@{i}This section describes all the PPCDirect Instructions of PPC680x0.@{ui}

These instructions are only useful if you want to optimize your codes or if
you want to know a few extra handy instructions.  There's an @{"important" link "Instructions Useful" 0}
@{"command section" link "Instructions Useful" 0}  where important or extremely useful commands are
highlighted.

@{fg shine}If you want to reach PPC native speed make sure you use the important
commands for optimizing!!!@{fg text}

All super PPCDirect instructions are indicated with an 's' in front of the
instruction. Instruction may look tricky at first sight, but when you cover
up the first letter you will find out they look usually quite similar to 68k
instructions.

PPCDirect instructions always work in the bitmode chosen in  PPC680x0: This
means that if you have selected 64-bits  implementations all the registers
are treated as 64-bits, unless the description states something else. For
example, an 'add' instructions adds two 64-bits values in 64-bits mode and
two 32-bits values in 32-bits mode, while a 'srolmil' always uses a 32-bits
value.

For most commands (except a few where noted) you can select if you want the
Condition Register to be updated. It works in the same way as with PPC
machine-code by putting a dot at the end of the instruction. No dot means no
Condition Register update. Take a look at the PPC Programming Environments
section...

@{b}For example:@{ub}

        sadd    d0,d1,d2

 will add register d0 to d1 and put the result in d2. The status
 register remains the same as it was before the instruction. 

        sadd.   d0,d1,d2

 does the same, except that the status register is updated.


Please remember that the PPC Condition Register has no carry flag! This is
done via a special register called XER. The CCR has bits for Positive,
Negative, Zero and Overflow. Overflowing by an instruction sets both the
overflow bit of the CCR and the XER. Carry emulation makes use of the
XER(CA) bit to emulate the  68k carry flag.

Some of these instructions may require knowledge of the PPC CPU. Most of
them should be usable by any programmer, though.


 SIMM  means Signed Immediate Value, which is always 16-bits
 UIMM  means Unsigned Immediate Value, which is always 16-bits
 rA,rB means any register
 rD    means any register (destination operand)
 M     means mask (see instruction for description)
 frN   means floating point register N
 crN   means condition field N
 crfN  means condition field N
 crbN  means condition bit N


@{b}@{fg shine}IMPORTANT NOTE

PPC680x0 DOES NOT SUPPORT THE:@{ub}

@{fg text}label=123

suffix. Make sure you have spaces or tabs after the label and before the
value! Making it look like:

label   =       123
@endnode

@node "Instructions Useful" "Instructions Useful"
@{b}@{fg shine}USEFUL PPCDirect INSTRUCTIONS@{ub}@{fg text}

@{i}This section contains information about commands that should definitely be
used for optimizing!@{ui}


@{fg shine} Arithmetic Class@{fg text}

 sadd    rA,rB,rD     - place the sum rA+rB in rD

 sadd    #SIMM,rB,rD  - place the sum SIMM+rB in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sadds   #SIMM,rB,rD  - SIMM is a signed immediate value and is
                        shifted left 16 bits. The sum is 
                        (SIMM<<16)+rB and is placed in rD
                        (DOES NOT SUPPORT CONDITION UPDATE

 ssub    rA,rB,rD     - place the sum rA-rB in rD

 saddc   rA,rB,rD     - place the sum rA+rB in rD with carrying
                        enabled

 saddc   #SIMM,rB,rD  - place the sum SIMM+rB in rD with carrying
                        enabled

 ssubc   rA,rB,rD     - place the sum rA-rB in rD with carrying
                        enabled
 
 ssubc   #SIMM,rB,rD  - place the sum SIMM-rB in rD with carrying
                        enabled@{fg shine}

 Data Transfer Class@{fg text}

@{b} instruction.size:@{ub}

 sfmove (.s/.d)
 smove  (.b/.w/.l/.q)

@{fg shine} addressing modes:@{fg text}

        (rA,rB),rD
        (<label>,rB),rD

        rA,(rC,rD)
        rA,(<label>,rD)

        (rA,rB)+,rD
        (<label>,rB)+,rD

        rA,(rC,rD)+
        rA,(<label>,rD)+

 <label> is always a 16-bits signed displacement, the + suffix 
 means that the effective address calculated between the brackets 
 is placed in the second register used. Registers are always 
 32-bits in 32-bits implementations and 64-bits in 64-bits 
 implementations, which means that all other bits beyond the
 size selected are set to zero. One exception to the rule:

 using smovex.w (and smovex.w ONLY) automatically extends the
 loaded word to 32-bits or 64-bits depending on the mode.

 For example:

  smove.w (data,d5)+,d4

 adds the 16-bits value 'data' to d5 and loads a word from
 memory which is placed in d4. d5 is set to d5+data. All the
 other bits in d4 are cleared.

@{fg shine} Floating Point Class@{fg text}

@{i} Little Note: an instruction with no explanation is the same 
 as the instruction above it, only with single precision instead
 of double.@{ui}

 sfadd   fpA,fpB,fpD        - fpA + fpB = fpD
 sfadds  fpA,fpB,fpD        - same, but single precision

 sfsub   fpA,fpB,fpD        - fpB - fpA = fpD
 sfsubs

 sfmul   fpA,fpB,fpD        - fpA * fpB = fpD
 sfmuls

 sfdiv   fpA,fpB,fpD        - fpB / fpA = fpD
 sfdivs
 
 sfsel   fpA,fpB,fpC,fpD    - fpA is compared to 0. If fpA is
                              greater or equal to 0, fpD is set
                              to fpC. If fpA is less than zero
                              or a NaN, fpD is set to fpB. The
                              comparison is unsigned

 sfmadd  fpA,fpB,fpC,fpD    - fpA * fpC + fpB = fpD
 sfmadds

 sfmsub  fpA,fpB,fpC,fpD    - fpA * fpC - fpB = fpD
 sfmsubs

 sfnmadd fpA,fpB,fpC,fpD    - -(fpA * fpC + fpB) = fpD
 sfnmadds

 sfnmsub fpA,fpB,fpC,fpD    - -(fpA * fpC - fpB) = fpD
 sfnmsubs

@{fg shine} Logic Class@{fg text}

 sandi   #UIMM,rB,rD  - UIMM AND rB, place result in rD. All other
                        bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sandis  #UIMM,rB,rD  - UIMM<<16 AND rB. place result in rD. All
                        other bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sori    #UIMM,rB,rD  - UIMM OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 soris   #UIMM,rB,rD  - UIMM<<16 OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seori   #UIMM,rB,rD  - UIMM EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seoris  #UIMM,rB,rD  - UIMM<<16 EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sand    rA,rB,rD     - rA AND rB, place result in rD

 sor     rA,rB,rD     - rA OR rB, place result in rD

 seor    rA,rB,rD     - rA EOR rB, place result in rD

 snand   rA,rB,rD     - rA NAND rB, place result in rD

 snor    rA,rB,rD     - rA NOR rB, place result in rD

 sandc   rA,rB,rD     - Logical AND rA with the one's complement of
                        rB and place result in rD

 sorc    rA,rB,rD     - Logical OR rA with the one's complement of
                        rB and place result in rD

 scountl rA,rD        - count the amount of leading zero's in
                        longword rA and place that amount in rD

 scountq rA,rD        - count the amount of leading zero's in 
                        quadword rA and place that amount in rD

@{fg shine} Shifting Class@{fg text}

 srolal  #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times, AND the
                              result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from M1 to M2 and 0
                              bits elsewhere (longword)

 srolmil #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (longword)

  Example:    srolmil #4,d1,d2,28,31

  rotate register d1 4 times. The mask is set from bit 28 to bit
  31, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.
@endnode

@node "Instructions Context" "Instructions Context"
@{b}@{fg shine} Kernal Instructions@{ub}@{fg text}
 -------------------

@{fg shine} PowerPC Side (WarpUp And PowerUp)@{fg text}

call    - calls PPC WarpUp or PowerUp kernal routine

@{fg shine} PowerPC Side (WarpUp ONLY)@{fg text}

@{b}Make sure you have the Haage&Partner 'powerpc/' includes in your source-code
if you want to use the following functions!@{ub}

warp    - places all WarpUp library routine offsets 
        (recommended to place this above the first source-
        code file of your program)

go68    - calls the Run68k routine from the WarpUp
        kernel. This requires the input PPStruct 
        structure to be configured in advance

wait68  - calls the Wait68k routine from the WarpUp
        kernel. All the routine inputs have to be
        configured by the user

go68s   - does the same as go68, but calculates the
        address in a relative way. Make sure the 
        PowerPC base is within 64k away of the program
        counter

wait68s - same story as go68s, but calls Wait68K

@{b}(Read the WarpUp routine and macro documentation for  the following:)@{ub}

WAITFOR68K - calls the WAITFOR68K macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source code

RUN68K -     calls the RUN68K macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source code

RUN68K_XL -  calls the RUN68K_XL macro. Requires
             'powerpc/powerpc.i' included somewhere
             throughout the entire source code

@{b}@{fg shine}CALLING 68K FUNCTIONS@{ub}@{fg text}

PPC680x0 detects 68K library calls and runs them when detected. When the
following occurs:

        jsr     offset(a6)

or any jsr that uses 'a6' as a pointer with offsets, PPC680x0 converts it to
code so that it can run as if it was called from a real 68K CPU.

Detection is standard ON, but it can be disabled and reenabled during
conversion.

 libon  -     enable library call detection
 liboff -     disable library call detection

As an addition to this detection method, you can use CALLEXEC, CALLDOS,
CALLINT and CALLGRAF as in the HiSoft DevPac assembler. 

@{b}@{fg shine}IMPORTANT@{ub}@{fg text}: Make sure that the execbase is stored in  a location called
'_SysBase' (and for the other  libraries use: _GfxBase, _IntuitionBase,
_DOSBase as in DevPac)
@endnode

@node "Instructions Compatibility" "Instructions Compatibility"
@{b}@{fg shine} Compatibility Instructions@{ub}@{fg text}
 --------------------------

 @{b}regequ@{ub} 
@{b} fregequ@{ub} 
@{b} crfequ@{ub} 
@{b} crequ@{ub}   - places register offsets
         for assemblers that do not support the letter
         suffix before registers: For example, regequ 
         converts to:

 r0      =       0
 r1      =       1
 r2      =       2
 r...    =       ...
 r31     =       31

       and crfequ converts to:

 crf0    =       0
 crf1    =       1
 crf2    =       2
 crf...  =       ...
 crf7    =       7

@{b} zeropage@{ub} - inserts a piece of code to retrieve the VBR and load 
            from a "zeropage" location. For example, when the 
            following command occurs, like in the Guru example,
            you can now use the "zeropage" command to fix the
            Guru meditation. The PPC hasnt always got access to
            the zero page, so it actually calls the 68k function
            SuperVisor to obtain it:

            move.l   $100.w,d3      (InGo will detect this and put
                                     a Points To Zero page comment
                                     next to it...)

            should be modified in the following way:

 ;          move.l   $100.w,d3      (masked out with ;)
            zeropage

            Then, after conversion, the following output will
            be produced:

 ;;      move.l  $100.w,d3
 ;       move.l  $100.w,d3
 ;       zeropage

         la      r31,NAME1
         stw     r25,0(r31)
         stwu    r26,4(r31)
         la      r25,NAME2
         lw      r26,_SysBase
         addis   r31,r0,-30>>16
         ori     r31,r31,-30&$ffff
         RUN680X0
         la      r29,NAME1
         lwz     r25,0(r29)
         lwzu    r26,4(r29)
         la      r31,NAME1
         stw     r20,0(r31)
         mr      r20,r3
         lwz     r3,>>>FILLER<<<(r20)
         la      r29,NAME1
         lwz     r20,0(r29)
         b       NAME3
 NAME2   dc.l    $4e7a0801,$4e730000
 NAME1   ds.l    2
 NAME3

            >>>FILLER<<< must be replaced with the zeropage
            address to be read.

            NAME1-NAME3 must have a unique name when 'zeropage' 
            is used multiple times. The VBR is returned in d0, 
            so you can also save d0 if you want to use the VBR
            contents multiple times. Beware, the original
            contents of d0 are flushed...!
@endnode

@node "Instructions Control" "Instructions Control"
 @{b}@{fg shine}PPC680x0 Control Instructions@{ub}@{fg text}
 -----------------------------

@{b}Use these commands to change options while converting your  file:@{ub}

@{b}Note:@{ub} @{fg shine}xxxxxx@{fg text} = default enabled

1- @{fg shine}domrg@{fg text} / nomrg

EnableMerging / DisableMerging (=Interleaving!)

2- r27sp / @{fg shine}r13sp@{fg text}

r27 is stack pointer / r13 is stack pointer

3- @{fg shine}a7issp@{fg text} / a7notsp

a7=sp / a7notequaltosp

4- dopup / @{fg shine}dowup@{fg text}

PowerUp/ WarpUp

5- @{fg shine}doerr@{fg text} / noerr

unknown error messages / no unknown errormessages

6- do64 / @{fg shine}do32@{fg text}

goto 64-bits mode / goto 32-bits mode

7- docarry / @{fg shine}nocarry@{fg text}

enable carry emulation / disable carry emulation

8- dorest / @{fg shine}norest@{fg text}

enable rest emulation / disable rest emulation

9- dostat / @{fg shine}nostat@{fg text}

enable sr emulation / disable sr emulation

10- @{fg shine}dofrc@{fg text} / nofrc

enable FRC32 / disable FRC32

11- doqb / @{fg shine}noqb@{fg text}

enable Quick Bad / disable Quick Bad

12- @{fg shine}doxd@{fg text} / noxd

enable FPU .X=.D / disable FPU .X=.D

13- @{fg shine}dosub@{fg text} / nosub / onlysub

enable / disable the substraction command to emulate a 'cmp' instruction.
Disabling the substraction will cause incompatibility with the blo/bhi
commands. 'dosub' enables the command (default), 'nosub' disables it leaving
only a compare instruction and 'onlysub' disables the compare instruction
leaving only a substraction  command. Normally, 'onlysub' is the best and
fastest option.

14- @{fg shine}killzero@{fg text} / normzero

'killzero' is a command to optimize 'clr' instructions It actually remembers
if the 'clr' instruction has been used on non direct modes and does not
produce an 'andi   r30,r30,0' instruction when it's not needed.

        clr.l   label
        clr.l   label2

will cause two 'andi.   r29,r0,0', while only one is required.

15- codeppc / @{fg shine}code68k@{fg text}

You can now insert PowerPC native code sections throughout the source-code
or use this command for other trickery.  'code68k' is the default mode in
which PPC680x0 always usually works. When you use the 'codeppc' command,
PPC680x0 stops converting and enters copy mode. This is handy if you want to
use sections containing non supported commands or PPC native code. 'codeppc'
does NOT use any of the conversion options or features. The entire block is
copied until  terminated with the 'code68k' command. Normal conversion
follows after the command.

For example:

 x      move.l  d0,d1
        add.l   d1,d1
        add.l   d0,d1
        codeppc
        mflr    r0
        mtctr   r0
        isync
        code68k
        move.l  d1,(a0)+
        move.l  d0,label
        rts
 label  dc.l    0

will convert the first three lines as usual, then copy the lines in between
the two 'codexxx' commands and finally convert the last three commands as it
used to do. Currently can be used to control AltiVec instructions as well,
although PPC680x0 will have an extensive AltiVec instruction set and support
in the near future.

16- adrabs / @{fg shine}adrrel@{fg text}

Commands to switch between absolute address loading or relative
address loading. PowerOpen/WarpUp only supports relative address loading, so
this is the default.

17 - @{fg shine}powerbug@{fg text} / poweroff

Storm PowerAsm still has some bugs in it...! For example, the recommended
Motorola command 'addi(s)   rD,0,label' gives a crash in PowerAsm. PowerAsm
requires the 'r' suffix even though it is the value '0' being used here.
Therefore, the default  mode (powerbug) will produce code that will not
crash!

18 - warpreq

Places a header with required PowerAsm includes. Make sure you have set the
PPC include path using the 'incdir' directive...!

The command translates to:

        xref    _PowerPCBase
        xref    _SysBase
 ;      xref    _DOSBase
        xref    _LinkerDB

        executable

So you can decide by yourself if you want to use the '_DOSBase' from an
'xref' (by removing the ';') or use it by opening the  library and store it
at an address.

19 - @{fg shine}dolvo@{fg text} / nolvo

Commands to enable/disable the _LVO suffix for CALLEXEC and other DevPac
library call commands. Default is enabled...

20 - noalign / @{fg shine}doalign@{fg text}

Disable / enable auto alignment. Default is enabled. Auto alignment means
that PPC680x0 tries to find code parts which are not placed on an address
dividable by 4. These are automatically set to an address dividable by 4
using the 'align.l' command.

21 - @{fg shine}onexec@{fg text} / offexec

Enables / disables exec detection. When loading occurs from address $4,
PPC680x0 tries to detect that and replace it with a load from '_SysBase'.
But beware: Not everything can be detected. For example, the common form:

        movea.l  #$4,a0
        move.l   (a0),d0

will cause a big crash when you run it...! Make sure you have replaced the
first command with a 'lea     _SysBase,a0' before  assembling!

22 - forceb - @{fg shine}noforceb@{fg text}

Forces all absolute jumps/subroutine calls to use the relative 'b' suffix
instead of the absolute 'ba'. This is required for several source codes as
Storm PowerAsm will give errors instead.

23 - (RESERVED) alwaysb

Enables 'forceb', only disables after the entire conversion session. Useful
for directory processing, but its tricky to find the first file to be
converted. You should first take a look at the directory processor to find
out where the 'alwaysb' has to be placed. The first file that is converted
is the file where it should be placed on top. This option may be replaced by
a button soon.

24 - mostregs / someregs / @{fg shine}allregs@{fg text}

These are commands to alter the context switch model for 68k library calls.
'allregs' means that all the registers (which are d0-d7/a0-a6) are being
transfered to and from the 68k. 'mostregs' transfers d0-d7/a0-a3/a5 and
'someregs' transfers only d0-d3/a0-a3.

25 - @{fg shine}branchdef@{fg text} / branchyes / branchno

Options to alter the 'branch prediction' mode of PPC680x0. 'branchyes'
selects that jumps are most obvious to be taken, 'branchno' selects that
jumps are most obvious to fail while 'branchdef' switches to the current
default model.

26 - branchcarry / shiftcarry

IMPORTANT ENHANCED CARRY OPTIONS. Use these options only  when carry
emulation is disabled. 'branchcarry' does ONLY  calculates carry emulation
for branching instructions, while 'shiftcarry' ONLY calculates
carry emulation for shift and rotate instructions. 'branchcarry' and
'shiftcarry' CAN be used in combination with each other.

27 - anticall / @{fg shine}noanticall@{fg text}

'anticall' is an option for people who want to reserve the CALL command for
other usage. When enabled, PPC-calling can no longer be achieved with 'CALL'
but only with 'CALLPPC'. This means that a macro with the name 'call' can be
used throughout the source code.

28 - @{fg shine}movemu@{fg text} / nomovemu

'movemu' is a command for use with the 680x0 'movem' command. On a 680x0,
'movem   d0-a6' saves all registers from d0 to a6. PPC680x0 can use all the
PPC registers as well. Therefore, 'nomovemu' disables the emulation mode,
which means that 'movem   d0-a6' moves all the registers (including d10, d11
etc.) instead of just the 68k ones. Defaults to 'movemu'...

29 - @{fg shine}libon@{fg text} / liboff

enables or disables Library detection for jsr -offset(a6)

30 - usefd / @{fg shine}nofd@{fg text}

enables or disables .fd file usage. DEFAULT IS DISABLED!!! SET THIS TO
ENABLED IF YOU WANT A SMART CONTEXT SWITCH MODEL!

31 - fasteddie / @{fg shine}fulleddie@{fg text}

'fasteddie' disables CR update for "addq.l  #<value>,dN" and the "subq"
equivalent. This means that a certain command can be converted to a single
PPC instruction. Default is disabled.

32 - noca / @{fg shine}doca@{fg text}

disabled or enables carry emulation for several arithmetic commands such as
substract/add/multiply/divide. The 'c' will be left out of the instruction
name when noca is activated, slightly increasing the performance. However,
carry emulation  for these commands are quite vital normally. It is better
to disable the overflow bit using 'noov'.

33 - noov / @{fg shine}doov@{fg text}

disables or enables overflow emulation for several arithmetic commands such
as substract/add/multiply/divide. The 'o' will be left out of the
instruction name when noov is activated, slightly increasing the
performance.

34 - @{fg shine}subdummy@{fg text} / nosubdummy

IMPORTANT! 'subdummy' enables a dummy command to correct the carry emulation
for substract commands. The carry of the PPC works different for substract
commands, inverting all the carry results. This is highly useful for 68k
code compatibility when porting.

35 - crpatch / @{fg shine}nocrpatch@{fg text}

enables / disabled CR update for move instructions. Default is disabled as
not many coders use the direct CR output of move  instructions. However,
enabling this options may cause several programs to be ported well.

36 - @{fg shine}bhibls1@{fg text} / bhibls2

Two different modes for emulating the bhi/bls instructions. Default is
bhibls1, if it doesn't work, try the other mode...
@endnode

@node "Instructions Vital" "Instructions Vital"
@{b}@{fg shine} Vital Instructions@{ub}@{fg text}
 ------------------

 lastrts - quits source code. should ALWAYS be the last 
           instruction your code executes. 
           The instruction is decoded to the PPC code:

           (On PowerUp)

                   mfctr  0
                   mtlr   0
                   blr

           (On WarpUp)

                   mfctr  0
                   mtlr   0
                   epilog

           Note: On WarpUp, code often ends with the RUN68K 
                 command

 head    - makes a header, a header is used on top of the code 
           you wish to run. They set the stackpointer (if needed)
           and save return addresses from the link to the count 
           register. Headers are automatically made when you 
           select 'yes' for making a start header
           The header also contains the RUN680X0 MACRO which is
           required for 68K library calls.

 tail    - makes a tail, tails contain the used data of PPC680x0.
           One MUST exist if you want to be able to assemble
           your code. Tails contain the stack (when selected), 
           FPU I/O dataspaces and other data. Tails are made
           automatically when selecting 'yes' for making an end
           header (=tail)

 setlr   - revives the Link Register from the Count Register.
           The 'head' commands does the vice versa process.

 forceb  - kills all absolute jumps and adapts them to relative
           jumps. Often required with Storm PowerAsm usage.
@endnode

@node "Instructions Arithmetic" "Instructions Arithmetic"
@{b}@{fg shine} Arithmetic Instructions@{ub}@{fg text}
 -----------------------

@{b} Simple description of the letters behind the names:

 s = shifted 16 bits to the left
 v = XER overflow enabled
 c = XER carry enabled
 m = minus one
 z = zero
 x = extended

 NAME    FORMAT         DESCRIPTION
 ----    ------         -----------@{ub}

 sadd    rA,rB,rD     - place the sum rA+rB in rD 
 sadd    #SIMM,rB,rD  - place the sum SIMM+rB in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sadds   #SIMM,rB,rD  - SIMM is a signed immediate value and is
                        shifted left 16 bits. The sum is 
                        (SIMM<<16)+rB and is placed in rD
                        (DOES NOT SUPPORT CONDITION UPDATE

 saddv   rA,rB,rD     - place the sum rA+rB in rD with overflow
                        enabled

 ssub    rA,rB,rD     - place the sum rA-rB in rD

 ssubv   rA,rB,rD     - place the sum rA-rB in rD with overflow
                        enabled
 
 saddc   rA,rB,rD     - place the sum rA+rB in rD with carrying
                        enabled

 saddc   #SIMM,rB,rD  - place the sum SIMM+rB in rD with carrying
                        enabled

 ssubc   rA,rB,rD     - place the sum rA-rB in rD with carrying
                        enabled
 
 ssubc   #SIMM,rB,rD  - place the sum SIMM-rB in rD with carrying
                        enabled

 ssubcv  rA,rB,rD     - place the sum rA-rB in rD with carrying and
                        overflow enabled

 saddcv  rA,rB,rD     - place the sum rA+rB in rD with carrying and
                        overflow enabled

 saddx   rA,rB,rD     - place the sum rA+rB+CARRY(XER) in rD

 saddxv  rA,rB,rD     - place the sum rA+rB+CARRY(XER) in rD with
                        overflow enabled

 ssubx   rA,rB,rD     - place the sum rA-rB+CARRY(XER) in rD

 ssubxv  rA,rB,rD     - place the sum rA-rB+CARRY(XER) in rD with
                        overflow enabled

 saddm   rA,rD        - place the sum -1+rA+CARRY(XER) in rD

 saddmv  rA,rD        - place the sum -1+rA+CARRY(XER) in rD with 
                        overflow enabled

 ssubm   rA,rD        - place the sum -1-rA+CARRY(XER) in rD

 ssubmv  rA,rD        - place the sum -1-rA+CARRY(XER) in rD with 
                        overflow enabled

 saddz   rA,rD        - place the sum 0+rA+CARRY(XER) in rD

 saddzv  rA,rD        - place the sum 0+rA+CARRY(XER) in rD with 
                        overflow enabled

 ssubz   rA,rD        - place the sum 0-rA+CARRY(XER) in rD

 ssubzv  rA,rD        - place the sum 0-rA+CARRY(XER) in rD with 
                        overflow enabled
@endnode

@node "Instructions Data Transfer" "Instructions Data Transfer"
@{b}@{fg shine} Data Transfer instructions@{ub}@{fg text}
 --------------------------

 Data transfer instructions are very important. All the normal 
 load and store instructions of the PPC are implemented in just 
 two instructions. Sizes for smove are byte, word, long or quad 
 and single or double for the sfmove. Addressing modes and sizes 
 are the same as with an 680x0, and the following modes are 
 allowed:

@{fg shine} instruction.size:@{fg text}

 sfmove (.s/.d)
 smove  (.b/.w/.l/.q)

@{fg shine} addressing modes:@{fg text}

        (rA,rB),rD
        (<label>,rB),rD

        rA,(rC,rD)
        rA,(<label>,rD)

        (rA,rB)+,rD
        (<label>,rB)+,rD

        rA,(rC,rD)+
        rA,(<label>,rD)+

 <label> is always a 16-bits signed displacement, the + suffix 
 means that the effective address calculated between the brackets 
 is placed in the second register used. Registers are always 
 32-bits in 32-bits implementations and 64-bits in 64-bits 
 implementations, which means that all other bits beyond the
 size selected are set to zero. One exception to the rule:

 using smovex.w (and smovex.w ONLY) automatically extends the
 loaded word to 32-bits or 64-bits depending on the mode.

@{fg shine} For example:@{fg text}

  smove.w (data,d5)+,d4

 adds the 16-bits value 'data' to d5 and loads a word from
 memory which is placed in d4. d5 is set to d5+data. All the
 other bits in d4 are cleared.
@endnode

@node "Instructions Other Data" "Instructions Other Data"
@{b}@{fg shine} Special Data Transfer Instructions@{ub}@{fg text}
 ----------------------------------

@{i}These are data transfer instructions that are for special use.@{ui}

@{b}inputs are:

  frN  ->   floating point register 0-31
  crfN ->   condition register field 0-7
  crbN ->   condition register bit 0-31
  rN   ->   general purpose register
  bd   ->   immediate base displacement
  #imm ->   immediate value
  crN  ->   condition register field 0-7 or entire CR
  XER  ->   XER register
  CRM  ->   CR field mask
  TBR  ->   time base register (64-bits H:L)
  MSR  ->   machine state register
  LR   ->   link register
  CTR  ->   count register
  SRn  ->   segment register (n is value between 0 and f)@{ub}

 smovefs     frD               Move FPSCR into frD
 smovecrfs   crfS,crfD         Move to FPSCR field from CR field
             #imm,crfD         Move to FPSCR field immediate
 smovefs0    crbD              Move 0 into bit crbD
 smovefs1    crbD              Move 1 into bit crbD
 smover.l    (rA,rB),rD        Move longword byte-reversed
             rA,(rB,rC)        
 smover.w    (rA,rB),rD        Move word byte-reversed
             rA,(rB,rC)
 smovem.l    (bd,rB),rD        Move multiple (always 32-bits)
             rS,(bd,rB)        starting at rS|rD
 smoves.l    rA,rB,#imm        Move stringword: #imm or XER[25-31]
             (rA,rB),rD        is amount of bytes to move. (=n) 
             #imm,rA,rB ---->  Store from rA to rB, #imm times
             rS,(rB,rC)

 NOTE: Stringword instructions start operating at register
       rS|rD and load/store bytes until n=0.

 smoves.d    rA,rB,#imm        Same for 64-bits mode/access
             (rA,rB),rD
             #imm,rA,rB
             rA,(rB,rC)
 sfmovei     frA,(rA,rB)       EA=rA+rB, move frA as integer word
                               into EA
 smovec      crA,crD           Move from/to control/other register
             XER,crD
             TBR,rA:rB
             MSR,rD
             rS,MSR
             LR,rD
             rS,LR
             CTR,rD
             rS,CTR
             XER,rD
             rS,XER
             rS,SRn   ------>  n = 0 to f
             SRn,rD
             rS,#CRM           Place the contents of rS into the
                               CR under control of the field 
                               mask specified by CRM. The field 
                               mask identifies the 4-bit field 
                               affected. Let i be an integer in 
                               the range 0-7. If CRM(i)=1, CR
                               field i (CR bits 4*i through 4*i+3)
                               is set to the contents of the
                               corresponding field of rS
             crA,rD            Move entire CR into rD. 'A' is 
                               ignored. (ie cr3,d3 = cr0,d3)
 smoveres.l  (rA,rB),rD        EA=rA+rB, move contents of EA into
                               rD and reserve. (See PPC manual)
 smoveres.d  (rA,rB),rD        EA=rA+rB, move contents of EA into
                               rD and reserve. (See PPC manual)
 smoveco.l   rS,(rA,rB)        EA=rA+rB, if reservation exists
                               and the EA specified is equal to
                               the EA supplied with the smoveres
                               command, rS is stored into EA and
                               the reservation is cleared.
                               If the EA is not equal to the one
                               supplied with the smoveres command,
                               the reservation is cleared but it
                               is undefined whether rS will be
                               stored.
                               If no reservation exists, the
                               instruction completes without
                               altering anything.
 smoveco.d   rS,(rA,rB)        Same as smoveco.l for 64-bits
 
 smovetsr    rS,rD             Move rS to segment register 
                               selected by bits 0-3 of rD
 smovefsr    rS,rD             Move into rS from segment register 
                               selected by bits 0-3 of rD
@endnode

@node "Instructions Float" "Instructions Float"
@{b}@{fg shine} Floating Point Instructions@{ub}@{fg text}
 ---------------------------

@{i} Little Note: an instruction with no explanation is the same 
 as the instruction above it, only with single precision instead
 of double.@{ui}

 sfadd   fpA,fpB,fpD        - fpA + fpB = fpD
 sfadds  fpA,fpB,fpD        - same, but single precision

 sfsub   fpA,fpB,fpD        - fpA - fpB = fpD
 sfsubs

 sfmul   fpA,fpB,fpD        - fpA * fpB = fpD
 sfmuls

 sfdiv   fpA,fpB,fpD        - fpA / fpB = fpD
 sfdivs
 
 sfsqrt  fpA,fpD            - sqr(fpA)  = fpD
 sfsqrts

 sfres   fpA,fpD            - the single precision estimate
                              of the reciprocal from fpA is 
                              placed in fpD

 sfrsqrt fpA,fpD            - calculate the reciprocal of the
                              square-roots from fpA and place
                              it in fpD

 sfsel   fpA,fpB,fpC,fpD    - fpA is compared to 0. If fpA is
                              greater or equal than 0, fpD is set
                              to fpC. If fpA is less than zero
                              or a NaN, fpD is set to fpB. The
                              comparison is unsigned

 sfmadd  fpA,fpB,fpC,fpD    - fpA * fpB + fpC = fpD
 sfmadds

 sfmsub  fpA,fpB,fpC,fpD    - fpA * fpB - fpC = fpD
 sfmsubs

 sfnmadd fpA,fpB,fpC,fpD    - -(fpA * fpB + fpC) = fpD
 sfnmadds

 sfnmsub fpA,fpB,fpC,fpD    - -(fpA * fpB - fpC) = fpD
 sfnmsubs

 sfround fpA,fpD            - fpA is rounded to single
                              precision and placed in fpD

 sfconvf fpA,fpD            - convert the integer double
                              word in fpA to an double precision
                              FPU value and place it in fpD
                              (64-bits only)

 sfconvt fpA,fpD            - convert the double-precision FPU
                              value to an integer double word
                              (64-bits only) (fpA -> fpD)

 sfconvtz fpA,fpD           - convert fpA to integer double word
                              and place it in fpD, with round
                              towards zero (64-bits only)

 sfconvtw fpA,fpD           - convert fpA to an integer word and
                              place it in fpD

 sfconvtwz fpA,fpD          - convert fpA to an integer word with
                              round towards zero and place it in
                              fpD

 sfneg   fpA,fpD            - negate fpA and place it in fpD

 sfabs   fpA,fpD            - put the absolute value of fpA in 
                              fpD

 sfnabs  fpA,fpD            - put the negative absolute value of
                              fpA into fpD

 sfcmpu  crfN,frA,frB       - floating compare unordered in 
                              Condition Register Field N
                              (compare frA with frB, result in crfN)

 sfcmpo  crfN,frA,frB       - floating compare ordered in
                              Condition Register Field N
@endnode

@node "Instructions Logic" "Instructions Logic"
@{b}@{fg shine} Logical Instructions@{ub}@{fg text}
 --------------------

@{i} Small description of letters behind names:

 v   = overflow
 l   = longword operation
 q   = quadword operation
 s   = shifted 16 bits to the left
 i   = immediate
 <<n = shifted left n times@{ui}

 sneg    rA,rD        - negate rA in rD

 snegv   rA,rD        - negate rA in rD with overflow enabled

 scmp.l  rA,rD        - compare rA/SIMM with rD treating operands
         #SIMM,rD       as signed 32-bits integers
                        (DOES NOT SUPPORT CONDITION UPDATE)

 scmpl.l rA,rD        - compare rA/UIMM with rD treating operands
         #UIMM,rD       as unsigned 32-bits integers
                        (DOES NOT SUPPORT CONDITION UPDATE)

 scmp.q  rA,rD        - compare rA/SIMM with rD treating operands
         #SIMM,rD       as signed 64-bits integers
                        (DOES NOT SUPPORT CONDITION UPDATE)

 scmpl.q rA,rD        - compare rA/UIMM with rD treating operands
         #SIMM,rD       as unsigned 64-bits integers
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sandi   #UIMM,rB,rD  - UIMM AND rB, place result in rD. All other
                        bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sandis  #UIMM,rB,rD  - UIMM<<16 AND rB. place result in rD. All
                        other bits than UIMM are set to zero
                        (ALWAYS SUPPORTS CONDITION UPDATE)

 sori    #UIMM,rB,rD  - UIMM OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 soris   #UIMM,rB,rD  - UIMM<<16 OR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seori   #UIMM,rB,rD  - UIMM EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 seoris  #UIMM,rB,rD  - UIMM<<16 EOR rB, place result in rD
                        (DOES NOT SUPPORT CONDITION UPDATE)

 sand    rA,rB,rD     - rA AND rB, place result in rD

 sor     rA,rB,rD     - rA OR rB, place result in rD

 seor    rA,rB,rD     - rA EOR rB, place result in rD

 snand   rA,rB,rD     - rA NAND rB, place result in rD

 snor    rA,rB,rD     - rA NOR rB, place result in rD

 seqv    rA,rB,rD     - rA EOR rB, then complement and place result
                        in rD

 sandc   rA,rB,rD     - Logical AND rA with the one's complement of
                        rB and place result in rD

 sorc    rA,rB,rD     - Logical OR rA with the one's complement of
                        rB and place result in rD

 scountl rA,rD        - count the amount of leading zero's in
                        longword rA and place that amount in rD

 scountq rA,rD        - count the amount of leading zero's in 
                        quadword rA and place that amount in rD
@endnode

@node "Instructions Rotate" "Instructions Rotate"
@{b}@{fg shine} Shift & Rotate Instructions@{ub}@{fg text}
 ---------------------------@{i}

 Small description of letters behind names:

 l = longword operation
 q = quadword operation

 Note about mask generation: On PPC, the leftmost bit is called bit
 0 and the rightmost bit 63 or 31 depending on QUAD or LONG
 operation. This means that the most significant bit is always bit0@{ui}

 srolcl  rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the 
         #SIMM,rB,rD,M        result with the generated mask and
                              place it in rD. The mask is generated
                              having 1 bits from M to bit 31 and 
                              0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolcr  rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the
         #SIMM,rB,rD,M        result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from bit 0 to M and 
                              0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolc   rA,rB,rD,M         - rotate rB left rA/SIMM times, AND the
         #SIMM,rB,rD,M        result with the generated mask and
                              place it in rD. The mask is generated
                              having 1 bits from M to bit 63-SIMM 
                              and 0 bits elsewhere (quadword)
                              (NOT WORKING ON PPC603/604)

 srolal  #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times, AND the
                              result with the generated mask and 
                              place it in rD. The mask is generated
                              having 1 bits from M1 to M2 and 0
                              bits elsewhere (longword)

 srolmil #SIMM,rB,rD,M1,M2  - rotate rB left rA/SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (longword)

  Example:    srolmil #4,d1,d2,28,31

  rotate register d1 4 times. The mask is set from bit 28 to bit
  31, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.

 slsll   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (longword)

 slsrl   rA,rB,rD           - shift right rB by rA times and place
                              the result in rD (longword)

 sasll   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (longword)
 
 sasrl   rA,rB,rD           - shift right rB by rA times with
                              arithmetical sign extension and place
                              the result in rD (longword)

 srolmiq #SIMM,rB,rD,M1,M2  - rotate left rB by SIMM times. The
                              result inserted in rD at the place of 
                              a mask generated from M1 to M2
                              (quadword/NOT WORKING ON PPC603/604)

  Example:    srolmiq #4,d1,d2,60,63

  rotate register d1 4 times. The mask is set from bit 60 to bit
  63, meaning that only the least significant 4 bits are replaced
  with the least significant 4 bits of the result.


 slslq   rA,rB,rD           - shift left rB by rA times and place
                              the result in rD (quadword)

 slsrq   rA,rB,rD           - shift right rB by rA times and place
                              the result in rD (quadword)

 saslq   rA,rB,rD           - shift left rB by rA times and place 
                              the result in rD (quadword)

 sasrq   rA,rB,rD           - shift right rB by rA times with
                              arithmetical sign extension and place
                              the result in rD (quadword)
@endnode

@node "Instructions Branch" "Instructions Branch"
@{b}@{fg shine} Flow Control Instructions@{ub}@{fg text}
 -------------------------

This section contains information on all the flow control instructions. It
is still recommended not to use these commands unless you are an experienced
programmer. The following commands should be used for normal conditional
branches:

blt, ble, beq, bge, bgt, bne, bvc, bvs

PowerPC conditional branches are a bit tricky to use in comparison to 68k
conditional branches. First of all, the programmer should supply a 'BO' and
a 'BI' field to tell the PPC under which conditions a branch should be
taken. The 5-bits 'BO' field is configured as follows:

(where CTR = CounT Register; z = bit ignored; y = branch prediction bit:
When set to 1, it predicts that ONLY if a  branch conditional is used with a
negative value, the branch  is taken, else not. Set to 0, it reverses the
prediction)


BO = 0000y

Decrement the CTR, then branch if the decremented CTR is not equal to 0 and
the condition is FALSE

BO = 0001y

Decrement the CTR, then branch if the decremented CTR is equal to 0 and the
condition is FALSE

BO = 001zy

Branch if the condition is FALSE

BO = 0100y

Decrement the CTR, then branch if the decremented CTR is not equal to 0 and
the condition is TRUE

BO = 0101y

Decrement the CTR, then branch if the decremented CTR is equal to 0 and the
condition is TRUE

BO = 011zy

Branch if the condition is TRUE

BO = 1z00y

Decrement the CTR, then branch if the decremented CTR is not equal to 0

BO = 1z01y

Decrement the CTR, then branch if the decremented CTR is equal to 0

BO = 1z1zz

Branch Always


The (5-bits) BI field points to one of the 32-bits of the PPC condition
register:

 Bit 0 is the MSB of the CR, bit 31 the LSB.

The 32-bits CR contains 8 fields configured as follows:

 CR0 CR1 CR2 CR3 CR4 CR5 CR6 CR7

where every CRx contains 4-bits:

 0 = lt     (less than)
 1 = gt     (greater than)
 2 = eq     (equal)
 3 = so/un  (summary overflow/unordered)


@{fg shine}The instruction set contains the following commands:@{fg text}

@{b}(where jump is absolute and branch is relative)@{ub}

 sbra     <label>          = Branch to <label>
 sbral    <label>          = Branch to <label>, place next
                             instruction in Link Register
 sjmp     <label>          = Jump to <label>
 sjmpl    <label>          = Jump to <label>, place next
                             instruction in Link Register
 sbcc     BO,BI,<label>    = Branch conditional to <label>
 sbccl    BO,BI,<label>    = Branch conditional to <label>,
                             place next instruction in
                             Link Register
 sjcc     BO,BI,<label>    = Jump conditional to <label>
 sjccl    BO,BI,<label>    = Jump conditional to <label>,
                             place next instruction in
                             Link Register
 sblink   BO,BI            = Branch conditional to address 
                             in Link Register
 sblinkl  BO,BI            = Branch conditional to address 
                             in Link Register, place next
                             instruction in Link Register
 sbcount  BO,BI            = Branch conditional to address 
                             in Count Register
 sbcountl BO,BI            = Branch conditional to address 
                             in Link Register, place next
                             instruction in Link Register
@endnode

@node "Instructions CR" "Instructions CR"
@{b}@{fg shine} CONDITION REGISTER LOGICAL INSTRUCTIONS
@{ub}@{fg text} ---------------------------------------

These are instructions of the following format:

  s???cr   crbA,crbB,crbD

where ??? can be:

 and       -     crbA  AND  crbB  =  crbD
 or        -     crbA   OR  crbB  =  crbD
 eor       -     crbA  EOR  crbB  =  crbD
 nand      - NOT(crbA  AND  crbB) =  crbD  
 nor       - NOT(crbA   OR  crbB) =  crbD
 eqv       - NOT(crbA  EOR  crbB) =  crbD
 andc      -   crbA AND NOT(crbB) =  crbD
 orc       -   crbA  OR NOT(crbB) =  crbD

These commands perform a logical operation between bits crbA and crbB, the
result is placed in crbD. The operands  can be any of the 32 condition
register bits.

@{fg shine}Example:@{fg text}

 snandcr   crb10,crb3,crb5

 The condition registers bit 10 is anded with bit 3 and the
 result is placed into bit 5.
@endnode

@node "Instructions Low Level" "Instructions Low Level"
@{b}@{fg shine} Low Level Instructions@{ub}@{fg text}
 ----------------------

@{i}These require knowledge of the PowerPC CPU. Instructions with both a
register and a '-' can be used with or without an operand. Most of these
desciptions are taken from Motorola's PPC Programming Environments manuals.
(MPCFPE/AD and MPCFPE32F/AD)@{ui}

@{b} EA   = Effective address
 rA|0 = r1-r31 or 0

 NAME     FORMAT         DESCRIPTION
 ----     ------         -----------@{ub}

 smovetsr rS,rD          (Privileged 32-bits only) Moves the
                         contents of rS into the the segment
                         register selected by bits 0-3 of rD.

 smovefsr rS,rD          (Privileged 32-bits only) Moves the
                         contents of the segment register
                         selected by bits 0-3 of rS into rD

 strap.l  #imm,rA,TO     (32-bits) The contents of rA are 
          rA,rB,TO       compared with the sign-extended SIMM
                         operand. If any bit in the TO operand
                         is set and its corresponding 
                         condition is met by the result of the
                         comparison, the system trap handler
                         is invoked.

 scall    -              Calls the operating system to perform
                         a service. When the called program 
                         returns, the contents of the registers 
                         are depending on the called program.

 ssync    -              Completes all instructions and
                         memory access activity before
                         continuing.

 sforce   -              This instruction provides an ordering
                         function for the effects of loads and
                         stores executed by the processor.
                         (Read PPC manual for more info on the
                         'eieio' command) (PRIVILIGED)

 sisync   -              Waits for all instructions to be
                         completed before continuing.
                         (PRIVILIGED)

 sdcbt    rA,rD          EA=rA|0+rD. This instruction is a
                         hint that performance will probably 
                         be improved if the block containing
                         the byte addressed by EA is fetched
                         into the data cache, because the
                         probably soon load from that address.

 sdcbtst  rA,rD          EA=rA|0+rD. This instruction is a
                         hint that performance will probably 
                         be improved if the block containing
                         the byte addressed by EA is fetched
                         into the data cache, because the
                         probably soon store from that 
                         address.

 sdcbz    rA,rD          EA=rA|0+rD. If the byte addressed
                         by EA is in the data cache, all
                         bytes of the cache block are cleared
                         to zero.
                         If the page containing the byte
                         addressed by the EA is not in the
                         data cache and the corresponding 
                         page is marked caching allowed
                         (I=0), the cache block is established
                         in the data cache without fetching 
                         the block from main memory, and all
                         bytes of the cache block are cleared 
                         to zero.
                         If the page containing the byte
                         addressed by the EA is marked caching 
                         inhibited (WIM=x1x) or write-through 
                         (WIM=xx1), either all bytes of the 
                         area of main memory that corresponds 
                         to the addressed cache block are 
                         cleared to zero, or an alignment 
                         exception occurs.
                         If the cache block addressed by the 
                         EA is located in a page marked as 
                         memory coherent (WIM=xx1) and the 
                         cache block exists in the caches of 
                         other processors, memory coherence 
                         is maintained in those caches.
                         The 'sdcbz' instruction is treated as 
                         a store to the addressed byte with 
                         respect to address translation, 
                         memory protection, referenced and 
                         changed recording, and the ordering 
                         enforced by 'sforce' or by the 
                         combination of caching-inhibited and
                         guarded attributes for a page.

 sdcbst   rA,rD          EA=rA|0+rD. If the cache block
                         containing the byte addressed by the
                         EA is located in a page marked memory coherent
(WIM=xx1), and a cache block containing the byte addressed by EA is in the
data cache of any processor and has been modified, the cache block is
written to main memory. If the cache block containing the byte addressed by
the EA is located in a page not marked memory coherent (WIM=xx0), and a
cache block containing the byte addressed by EA is in the data cache of this
processor and has been modified, tha cache block is written to main memory.
The function of this instruction is independent of the
write-through/write-back and caching-inhibited/caching-allowed modes of the
cache block containing the byte addresed by the EA. The 'dcbst' instruction
is treated as a load from the addressed byte with respect to address
translation and memory protection. It may also be treated as a load for
referenced and changed bit recording except that referenced and changed bit
recording may not occur.

 sdcbf    rA,rD          EA=rA|0+rD. The action depends on the
                         memory mode associated with the 
                         target, and on the state of the block.  The
following list describes the action taken for the various  cases, regardless
of whether the page or block containing the  addressed byte is designed as
write-through or if it is in the  caching-inhibited or caching-allowed
mode.

* Coherency required (WIM=xx1)

- Unmodified block - invalidates copies of the block in the caches of all
processors. - Modified block - Copies the block to memory. Invalidates
copies of the block in the caches of all processors. - Absent block - If
modified copies of the block are in the caches of other processors, causes
them to be copied to memory and invalidated. If unmodified copies are in the
caches of other processors, causes those copies to be invalidated.

* Coherency not required (WIM=xx0)

- Unmodified block - Invalidates the block in the processors cache. -
Modified block - Copies the block to memory. Invalidates the block in the
processors cache. - Absent block - Does nothing.

The function of this instruction is independent of the
write-through/write-back and caching-inhibited/caching-allowed modes of the
cache block containing the byte addresed by the EA.

The 'sdcbf' instruction is treated as a load from the addressed byte with
respect to address translation and memory protection. It may also be treated
as a load for referenced and changed bit recording except that referenced
and changed bit recording may not occur.

 sicbi    rA,rD          EA=rA|0+rD. If the cache block
                         containing the byte addressed by the 
                         EA is located in a page marked memory  coherent
(WIM=xx1), and a cache block containing the byte  addressed by eA is in the
instruction cache of any processor,  the cache block is made invalid in all
such instruction  caches, so that the next reference causes the cache block
to  be refetched.

If the cache block containing the byte addressed by EA is located in a page
not marked memory coherent (WIM=xx0), and a cache block containing the byte
addressed by EA is in the instruction cache of this processor, the cache
block is made invalid in that instruction cache, so that the next reference
causes the cache block to be refetched.

The function of this instruction is independent of the
write-through/write-back and caching-inhibited/caching-allowed modes of the
cache block containing the byte addresed by the EA.

The 'sicbi' instruction is treated as a load from the addressed byte with
respect to address translation and memory protection. It may also be treated
as a load for referenced and changed bit recording except that referenced
and changed bit recording may not occur.

 secilx   rA,rB,rD       Optional, see PPC manual

 secolx   rA,rB,rD       Optional, see PPC manual

The next instructions are PRIVILIGED:

 sdcbi    rA,rB          The action depends on the memory 
                         mode associated with the target, and 
                         on the state of the block. The  following list
describes the action taken for the various  cases, regardless of whether the
page or block containing the  addressed byte is designed as write-through or
if it is in  the caching-inhibited or caching-allowed mode.

* Coherency required (WIM=xx1)

- Unmodified cache blocks - Invalidates copies of the cache block in the
caches of all processors. - Modified cache blocks - Invalidates copies of
the cache block in the caches of all processors. (Discards the modified
contents) -Absent cache block - If copies are in the caches of any other
processor, causes the copies to be invalidated. (Discards any modified
contents)

* Coherency not required (WIM=xx0)

- Unmodified cache block - Invalidates the cache block in the local cache. -
Modified cache block - Invalidates the cache block in the local cache.
(Discards the modified contents) - Absent cache block - No action is taken.

When data address translation is enabled, MSR[DT1]=1, and the logical
(effective) address has no translation, a data access exception occurs.

The function of this instruction is independent of the
write-through/write-back and caching-inhibited/caching-allowed modes of the
cache block containing the byte addresed by the EA.

This instruction is treated as a store to the addressed byte with respect to
address translation and protection, except that the change bit need not be
set, and if the change bit is not set then the reference bit need not be
set.

 sslbi    rD             EA=rD. The entry corresponding to the
                         EA is removed from the SLB. (64-bits)

          -              All SLB entries are made invalid.
                         (64-bits)

 stlbi    rD             EA=rD. The entry corresponding to the
                         EA is removed from the TLB.
                         The TLB is invalidated regardless of
                         MSR[IR] and MSR[DR] and the command
                         affects all processors.

          -              All TLB entries are made invalid.
                         The TLB is invalidated regardless of
                         MSR[IR] and MSR[DR]. This command
                         does not affect other processors.

 stlbsync -              Waits for all current 'stlbi'
                         instruction to finish on all 
                         processors.
@endnode

@node "TroubleShooting" "TroubleShooting"
Troubleshooting

Q. After assembly, the file is not executable.

A. This can be caused by two reasons: First of all, make sure you haven't
forgot the 'warpreq' command before the source code. If you haven't forgot
this command, the error is caused by a familiar bug in Storm PowerAsm. To
prevent this bug from being there, remove all the 'sections' from the
source code. The executable should work now. If not, you might have to learn
some files that weren't learned before.

Q. The assembler gives errors just after porting a source- code.

A. See @{"Trial And Error" link "TrialAndError" 0}...

Q. The status-display is empty.

A. Install the font in your fonts: directory.

Q. After directory-processing, several symbols have been interpreted in a
wrong way.

A. This is caused by symbols which haven't been learned and are therefore
not understood correctly. Make sure you have learned all the source-code
files that are needed for the source code that has to be ported. Also,
always flush the @{"learn file" link "Working With A Learnfile" 0} when a new project is started.

Q. How much faster can programs get after porting from 68k?

A. Ported programs can become MUCH faster and even get close  to real
PPC assembly speed. Sadly, @{"context switches" link "ContextSwitches" 0} are very slow so the coder
should make sure that CPU intensive  algorithms are not stalled by too many
68k calls. 

However, only one command has to be altered when a native PPC  port of
Workbench is finished: This means that all the PPC680x0 ported programs
will run without context switches on future Workbench revisions.

Q. What is QB loading???

A. This was a left over from older revisions of PPC680x0. It causes bugs
when the low word of a calculated address or value  is higher than $7fff. On
the other side it is a tad faster than the normal loading mechanism for
PowerUp, so experienced programmers may find it useful sometimes. It is
useless for WarpUp, though...!

Q. What happened to AltiVec support?

A. Ask phase5...

Q. Why is there not much PowerUp support?

A. Because PowerUp support is no longer useful since nearly  everyone moved
over to WarpUp. There's no reason to use PowerUp  anymore as WarpUp is
simply more flexible.

Q. Labels are not converted correctly. What's going on?

A. This problem can be caused by two reasons: First of all,
   PPC680x0 does not support complex brackets. Therefore, the
   following cannot be done:

       move.l   ((3*4),d0),d1

   Make sure the program does not contains brackets in between
   brackets. Also, several sums will cause strange results.
   This should do the job:

       move.l   (12,d0),d1

   However, complex immediate values ARE supported:

       move.l   #((3*2+(3*6/2)-1)*3),d0

   is converted correctly. @{fg shine}However, make sure the immediate
   values are placed between brackets when a sum is being
   used as the input. @{fg text}

   The second reason for incorrect label conversion is a
   fault of the user, caused by not flushing the @{"learnfile." link "Working With A Learnfile" 0}
   When a source code contains:

_SysBase        equ     $4
  
   and you have converted it using PPC680x0, the @{"learnfile" link "Working With A Learnfile" 0}
   contains data claiming that '_SysBase' is a value.
   Assembling the output file will cause a 'double symbol'
   error, which means that the line has to be removed. For
   example:

;_SysBase       equ     $4

   will remove the line. However, the learnfile MUST be
   flushed to make PPC680x0 know about the changes. Elsewise
   the learnfile will keep on claiming that '_SysBase' is
   equal to $4!

Q. Any notes about register usage?

A. Yes: Don't use r0-r2 or r28-r31 as they are in use by 
   PPC680x0s emulation code system. r13 is the WarpOS Stack 
   Pointer, so don't use this one as well! And finally, remember 
   that BCD emulation has been implemented for compatibility 
   only: Using them will flush r11 and r12.

Q. Guru meditation? CLI pops up with MACRO usage while using GUI?

A. Hmmm. Conflict with another program: This should happen only on
   soft kicked machines. Even Enforcer doesn't seem to report any
   illegal accesses. Please report me when this happens as I only
   managed to find the crash on one machine (which is crashing
   very often also without PPC680x0...!)
@endnode

@node "SelectiveLibraryConversion" "SelectiveLibraryConversion"
 @{b}@{fg shine}Selective Library Conversion Bridge@{ub}@{fg text}
 -----------------------------------

PPC680x0 has been made compatible with future releases of AmigaOS, assuming
that even the PPC version of AmigaOS will contain the same (or more)
functions and offsets as  the current AmigaOS. 

The 'RUN680x0' routine is a macro that does all the 68K library-call
handling. Internally, two options have been added to alter the RUN680x0
macro. For example, RUN680x0 can be redirected to call a PPC library instead
of a 68K library. This means that when a native PPC version of  exec.library
is released in the future,  it is a piece of cake to make a PPC680x0 program
run on that library.

The two yet unimplemented commands 'lib68add' and  'lib68rem' can redirect
every single library to a certain processor. These commands have not been
implemented yet because there's is no version of PPC AmigaOS: Even though
development can start any moment now, it is too early to define the process
to call a library function. RUN680x02 is yet undefined and will be activated
internally as soon  as new developments will succeed.

@{fg shine}Example usage of 'lib68add' and 'lib68rem':@{fg text}

@{i}lib68add     'graphics.library'@{ui}

Redirects 'graphics.library' to RUN680x02. This means that all
'graphics.library' calls will be rerouted to the RUN680x02 routine and will
call the PPC graphics.library instead of the 68K version.

@{i}lib68rem     'graphics.library'@{ui}

Redirects the library function back to 68K.

This bridge is a feature that will make assembly ports to the next OS much
easier to make: Don't forget that calling PPC functions takes up no
context switch at all.

'@{"Context switching" link "ContextSwitches" 0}' will no longer cause stalls
if this will happen, because they do not exist anymore!
@endnode

@node "QuickGuide" "QuickGuide"
@{b}@{fg shine}PPC680x0 QUICK GUIDE@{ub}@{fg text}

Good... Here we go then. Go to Workbench and copy the  PPC680x0:Fonts/
directory into the SYS:Fonts/directory  or simply double-click the 'install
font' icon. Then copy the s/fprom.s file to the s: directory of your
boot partition and make the following assign:

@{i}assign >NIL: PPC680x0: <path of ppc68k>@{ui}

You can now double-click on the 'PPC68k' icon. 

After double-clicking on the PPC68k icon, you get a window with some
buttons, strings, a scroller and a picture. 

Pressing any button will remove the picture and display all the
project information on the place of the picture.

@{fg shine}The buttons mean the following:@{fg text}

Button 1 - two arrows: This means interleaving on/off. Interleaving means
that the original 68k source code file is placed throughout the file as
comments. Default is on.

Button 2 - r#13      : This button selects the stackpointer register.
Default is r13 (the official stackpointer) but you can change it to r27
(=a7) to create a user stackpointer with the size (in longwords) as selected
in the 'stacksize a7' string. This will  put a user-stack on bottom of the
output source code. (ds.l size)

Button 3 - a7 sp     : This means that (a7) is treated exactly the same as
(sp). Default is on. When disabled, you can use (a7) as a general purpose
register (if r13 is selected as the stackpointer).

Button 4 - Wup       : WarpUp goodies/PowerUp goodies. Default is WarpUp.

Button 5 - Gpr       : Display General Purpose Registers or Floating Point
registers in the '680x0 register usage' part. Default is General Purpose
Registers. You can switch in realtime.

Button 6 - err       : Display unknown errors or trash as ERRORUNKNOWN. When
disabled, unknown errors or trash is ignored. A pushed button means no
"trash error reports".

Button 7 - D         : Process Directory. Allows you to (1) convert  an
entire directory, (2) learn all the files from a directory or (3)  flush the
learnfile. Pushing this button brings up a requester where  you can select
one of those three.

Button 8 - 32        : Switch between 32/64-bits implementations. Default is
32-bits.

Button 9 - 00 0      : Carry emulation on/off. Default is off.

Button 10 - Rest     : Rest emulation for divisions. Default is off.

Button 11 - Stat     : Status register/Condition Code register/ Lower-level
emulation on/off.

Button 12 - Frc      : Force 32-bits addressing modes. Default is on. This
selects if you want to use 32-bits addresses as standard when working in
64-bits implementations. This is useful if you are using a PPC processor
with a 32-bits address-bus. Has no effect when working in 32-bits
implementations.

Button 13 - (disk 1) : ASL requester for source file selection

Button 14 - (disk 2) : ASL requester for destination file selection

Button 15 - M        : Big Motorola M. Push to start converting

Button 16 - Full     : Full address loading or BAD address loading

Button 16 - X=D      : Emulate FPU .X by converting to .D (Default
                       is on)

Button 17 - CFG      : Load/Save Config to/from any of the 6 slots

Go to a file editor and load the non reassembler example file  called
'freemem.68k' into any text editor. Put an 

@{i}        incdir  <ppcasmincludedirectory>
        include powerpc/powerpc.i

        warpreq
        forceb@{ui}

above the source code. Then redirect the includes to the ppc include
directory and remove the easystart.i include.

Add the following instructions just before the first instruction to be
executed:@{i}

        prolog  1024
        head@{ui}

Then, change the last instruction to be executed (the 'returning' rts) into
a 'lastrts' instruction. Finally add a 'tail' instruction underneath the
source-code and save the file away. The file should now look like the
'freemem.ppc68k' file.

Select the saved file as the input file in PPC680x0, and select an output
file (ie 'Ram:output'). Press the 'M' button...

You are now ready! Load your file with any editor or try to assemble it! The
output code is Storm PowerAsm compatible and can be run after conversion.

If assembling has some errors, go to the @{"Trial And Error" link "TrialAndError" 0} section.
@endnode

@node "NotesAndThankYous" "NotesAndThankYous"
@{b}@{fg shine}NOTES AND THANK YOU'S@{ub}@{fg text}

We would like to thank and greet the following people (in no particular
order!):

 @{fg shine}*Teemu Suikki and all of Petsoff Limited Partnership*@{fg text} for giving 
 us the ability to support the best sound card for the Amiga: Delfina

 @{fg shine}*Sam Jordan*@{fg text} from Haage and Partner for giving us the ability to
 add Storm PowerAsm support to PPC680x0 and supplying us with help.@{fg shine}

 *Jurgen Haage*@{fg text} from Haage and Partner for giving great help.

 @{fg shine}*Petro Tyschtschenko*@{fg text} for great help.

 @{fg shine}*Ian Greenaway*@{fg text} from White Knight Technology for helping and
 supporting us. Thanks for everything!!!

 @{fg shine}*Parents*@{fg text} for everything!

 @{fg shine}*EBV Elektronik*@{fg text} for all the great information, support and help!

 @{fg shine}*Sander Assenbroek Machielsen*@{fg text} for being one of the very last 
 good Amiga freaks and supporting/helping us A LOT!!! THANKS!!!!

 @{fg shine}*Stefan Settels@{fg text} for being a good friend!!!

 @{fg shine}*Bieuw (AKA Bart Neumann)*@{fg text} for being a friend and of course
 a good Amiga freak as well!!! Again thanks for everything!

 @{fg shine}*Rached Gentile*@{fg text} (Raef)
 
 @{fg shine}*Stephen Fellner*@{fg text} (RiVa) for great help! 

 @{fg shine}*Barlage Den Haag*@{fg text} for great help!!!

 @{fg shine}*Martin Kuchinka*@{fg text} for a bug report that came in just in time :)@{fg shine}

 @{fg shine}*Vincent Poolman@{fg text} for always and itsumo moral support!!! THANK YOU, you
 make me smile!

 @{fg shine}*Julia Matkina*@{fg text} for always and itsumo moral support!!! THANK YOU, you
 make me smile!

 @{fg shine}*Amiga Harry*@{fg text} for keeping PPC680x0 alive. Thanks for the motivation!
 
 *(anyone we forgot)*@{fg text}
@endnode

@node "Copyright" "Copyright"
@{b}@{fg shine}Copyright?@{ub}@{fg text}

Not anymore!

@{b}@{fg shine}TO ALL STUPID PIRATES:@{ub}@{fg text}

@{b}A PROGRAM WORTH USING IS A PROGRAM WORTH BUYING!!!@{ub}


@{b}@{fg shine}OTHER RIGHTS:@{ub}@{fg text}

 PowerUp is courtesy of phase5
 WarpUp & Storm PowerAsm is courtesy of Haage&Partner
 PowerPC is a trademark of Motorola and IBM
 ColdFire is a trademark of Motorola
 Amiga is a trademark of Amiga Int., Inc.
@endnode

@node "Authors" "Authors"
@{b}@{fg shine}Contacting Us!@{ub}@{fg text}

@{i}Do you have questions or want to talk about anime or anything... 
Well, you can always contact us at:@{ui}

 Coyote Flux WHQ
 Rijenpad 21
 1324 WC Almere
 Holland

@{i}or E-mail:@{ui}

 info@coyoteflux.nl


@{b}@{fg shine}THE AMIGA, PS2 & C64 ARE THE GREATEST MACHINES EVER BUILT!!!@{ub}@{fg text}

If you do not agree....... you are a lamer! I guess then you should go to Seattle and
live there. Surely your friend for life has a dominant company there...

Today is a good day for games, because we have just received Metal Gear Solid 3, thanks 
Hideo Kojima. Those PC geeks might also get these type of quality graphics in another 
five years... Haha!

@endnode

@node "History" "History"
@{b}@{fg shine}ADDED IN FINAL RELEASE 1.20 TURBO (15th October 2000)@{ub}@{fg text}

- call(s) command had no tab termination FIXED

- bug in bpl/bmi FIXED

- move.l   (dN,aM),dO FIXED (produced crap register!)

- MACRO crashes: File was assembled in 68010 mode instead of
  68020 mode and gave fatal crashes because of that. FIXED

- btst #n,$address produced trash with n>7 (Thanks to Martin
  Kuchinka for this one!) FIXED

- Experimental .fd mode added. VERY USEFUL! Now saves/restores
  only the required registers when calling 68k functions, as
  long as the register-configuration is written in the PPC680x0.fd
  file. ADDED

- CGX Interface ADDED. Works with and without CGX library, although
  CGX owners have a nice 24-bits picture (but no scroll)...!

- 'fasteddie' mode added. Immediate .L add/sub commands don't 
  support CR update in this mode but decode to one command when
  using a register as destination. OPTIMIZATION


@{b}@{fg shine}ADDED IN FINAL RELEASE 1.12 TURBO (29th July 2000)@{ub}@{fg text}

- 'subonly' command for cmp emulation. Comparisons will only
  produce a 'subfco.' instead of the 'subfco/cmp' combination
  when this is activated. Definitely the best and fastest mode
  to work in.

- Optimizations for the 'move' command. Try 'move.l (a0,a1),d0'
  or 'move.w    (d0.w,a1),(r3.l,a3)' or anything using two
  registers between the brackets. The 'lwzx' and 'stwx' commands
  are now being used...!

- RUN680x02 now implemented for future context-switch opts.

@{b}@{fg shine}ADDED IN FINAL RELEASE 1.11 TURBO (7th June 2000)@{ub}@{fg text}

- TOO MUCH TO REMEMBER!!! (native mode, learning, macros,
  equr/equrl/reg/fequr, big bugfixes, config options, SUPER III,
  fmovem, bfffo, bfins, more support commands etc. etc.)

@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10g  (November 26th 1999)@{ub}@{fg text}

- Several tiny bug-fixes

- Added some control commands to make things easier...

- Big fat test session!

- Example-files added! (Finally....)

- ??? A LOT!!! Sorry for not remembering all the changes!!!

@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10e  (October 26th 1999)@{ub}@{fg text}

- all PowerAsm incompatibility-bugs FIXED

- push/popgpr added to head/lastrts

- several bug-fixes and changes (sorry for not reporting all the
  changes in detail: A lot of changes have been made without 
  writing it down...!)

- example-files added

- new file-scanning and label detection: MUCH slower conversion,
  MUCH faster code!

- 'adrabs' and 'adrrel' commands added

- ERRORS found to be fixed: Floating Point Condition Commands are
  bad; aligning isn't done automatically

@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.10c+  (October 1st 1999)@{ub}@{fg text}

- conditional assembly commands added: not tested, though!

- codeppc / code68k control commands added


@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE 1.10c  (30th September 1999)@{ub}@{fg text}

- zeronorm / zerokill commands added: First commands to use
  backwards block-based referencing.

- Control Commands changing button options now change GUI buttons
  while converting

- 'scc' and 'fscc' commands FIXED

- some commands produced the 'nor' and 'nand' commands instead
  of the required 'orc' and 'andc' commands

- survived 5th test session

- tab termination FIXED

- now works on 68000/010 (tab termination produced GURU!)


@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE 1.10b+ (18th September 1999)@{ub}@{fg text}

@{b}1. FIXES:@{ub}

- WarpUp disabling bad with 'head'

- Some Enforcer hits when quitting. FIXED

- Address calculation bad for 'jsr/jmp/pea (aN)'. FIXED

- 'bsr.s' didn't work. FIXED

- floating point unit was not working properly as nearly 
  80% of the source-code was damaged. I don't know how it
  got damaged so badly, but think it is caused by some
  really bad file-accessing on my up-kicked Amiga. Promo-
  code was mixed throughout the commercial sources. But,
  everything has been totally recoded(!) and FPU support
  is MUCH better now!

- 'bfclr' caused 'nand' command instead of 'andc'

- allocation/deallocation of libraries gave problems when
  libraries didn't exist. This was because PPC68k called
  EasyRequest even when there was no window opened. FIXED

- 64-bits mode caused three extension commands instead of 
  two when direct modes were used. Not a fatal bug, but 
  not really optimized... FIXED

- The ERROROVERFLOW sometimes appeared without any reason.
  This error should actually NEVER appear, so this was a
  bad bug...! You won't see it again, though... FIXED

- The user-editable 'fprom.s' file was not supplied with 
  the release of PPC680x0. My fault... It shouldn't give 
  problems except if the ROM was used by a program. For 
  example:

        fmovecr #2,fp0

  could not be converted. FIXED

- CALL command and several WarpUp/PowerUp commands were
  really bad. FIXED


@{b}2. NEW FEATURES:@{ub}

 - context-switching macro-call commands added (warp, go68,
   wait68, go68s, wait68s, WAITFOR68K, RUN68K, RUN68K_XL)
 - WarpUp kernel offsets added (in 'warp' command)
 - regtables added (regequ, fregequ, crfequ, crequ)
 - Command Line Interface (CLI) added
 - in-line PPC68k control commands
 - WarpUp simple kernel call commands added (via CALL)
 - New commands added: move16, fsabs, fdabs, fsdiv, fddiv,
   fsmove, fdmove, fsneg, fdneg, fsgldiv, fsglmul, fssqrt,
   fdsqrt, fssub, fdsub, fsadd, fdadd, fsmul, fdmul
 - EXTREMELY optimized 32-bits integer->float conversion. 
   Requires only a few cycles on a PPC604. (The PPC has no
   hardware conversion in 32-bits implementations!)
 - New Floating Point Unit
 - PPC680x0 ignores the 'opt' command
 - PPC can access Amiga 68k Libraries with simple DevPac-
   like commands such as 'CALLEXEC', 'CALLDOS' etc. or 
   even with:
 
        move.l  librarybase,a6
        jsr     -offset(a6)

   resulting in ready-to-run code-conversion
 - commands for 68k calls: CALLEXEC, CALLDOS, CALLINT,
   CALLGRAF, libon, liboff


@{b}@{fg shine}ADDED IN COMMERCIAL RELEASE 1.0 (7th July 1999)@{ub}@{fg text}

 - A LOT EXTRA!!!
 - rN suffix
 - good guidefile
 - most bitfield commands
 - optimizations (too much to list!)
 - bug-fixes (too much to list!)
 - dctv.library conversion routines succesfully converted

@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE EDITION 0.82  (5th July 1999)@{ub}@{fg text}

 - link/unlk set to enabled
 - return terminators added to prevent spaces in between code
 - rest emulation added
 - ext carry emulation fixed
 - many tiny fixes for parts that created trash or forgotten tabs
 - Bit Fields are now in the work-in-progress state, they don't
  give an error, but don't give an output either. Expect them
  tomorrow...!

@{b}@{fg shine}ADDED IN COMMERCIAL PRE-RELEASE EDITION 0.8@{ub}@{fg text}

 - link, unlk
 - 68060 Floating Point Unit working and enabled
 - bug-fixes for all conditional and branching instructions
 - optimizations in loading/storing
 - 40% EXTRA of Super Architecture
 - new guidefile
 - better immediate handling
 - modular interface native functions
 - X=D button
 - header questions enable/disable
 - carry emulation now better
 - 'not' fixed
 - better low-level register handling

@{b}@{fg shine}ADDED IN PROMO 1.5:@{ub}@{fg text}

 - Bug Fixes and optimizations:
  - exg defaulted to .W FIXED
  - move.l   d0,(a1) caused problems
  - rol      #imm,<D> now faster and FIXED
  - mulu/muls/divu/divs FIXED (big bug!)
  - mathematical model caused trash or unnecessary instructions
  - equr/equrl/reg/fequr now set to promo status. Disabled! The final
    version will have full support for them. They were already 
    disabled but they didn't give an ERROR message as they do now!
  - (sp) usage caused trouble sometimes
  - moveq fixed (no more .w usage)
  - asr.l    #imm,<D>
  - shifting is now much faster and works(!) much better
  - moveq    #0,<D>  now set to clear status
  - simple range checking enabled so that immediate values now
   default to quick format if low enough. This is not yet as 
   complicated as in the final version though! Simple means that 
   it detects binary/octal/hex/decimal NUMBERS ONLY. No sums, that
   is....
  - moveq now has detection for zeroes
  - PPC immediate value support for shifting/rotating added
  - more??? Probably! (rlwimi's, exts's etc. removed or changed to a
    working version!)

 - History link added to guide
 - New Important Notes and Information added to guide

@{b}@{fg shine}ADDED IN PROMO 1.4:@{ub}@{fg text}

 - lea/pea/jsr/jmp <label>.w produced trash
 - interleaving went active after a few lines when it was disabled
 - new extremely useful PPCDIRECT command added:

 The smove command is an extremely handy substitute for all normal
 load/store commands of the PPC. It works as follows:

  smove.size     (<label>,reg1),reg2
  smove.size     (reg1,reg2),reg3
  smove.size     reg1,(<label>,reg2)
  smove.size     reg1,(reg2,reg3)

 A plus behind the brackets means update enabled. Example:

  smove.l        (label,d3)+,a4

 means <ea> is label+d3. This is loaded in a4. d3 is updated and
 keeps the <ea> used for this mode which is label+d3.

 This command is directly translated to one single PPC instruction

@{b}@{fg shine}ADDED IN PROMO 1.3:@{ub}@{fg text}

 - There were terrible bugs in 'Full' addressing modes. Changing a 
   slight part of the source code caused everything to change in a 
   direction with bad side-effects. This is now fixed.
 - Double extension bug fixed
 - Many little bugs and logical parts fixed
 - Missing dot for subroutines added: This caused a bug that 
   destroyed subroutine emulation
 - 'head' and 'tail' command added. This makes the promised 
   'autoheader' questions obsolete as the 'head' instruction makes
   an PPC680x0 Start Header and the 'tail' instructions an PPC680x0
   End Header. Can be used only once!!! (Although using it twice 
   won't give any errors!!!)
 - PPC680x0 source code succesfully converted to PPC using this 
   software!
 - Changes in guide-file: Missing section, Prologue, Copyright and
   Ordering.

@{b}@{fg shine}ADDED IN PROMO 1.2:@{ub}@{fg text}

 - Macro support for non-68k-command macro's
 - New address-loading mechanism (USE Full/QB button for old one
   where QB falls to the old mode. Experience needed!)
 - Help button calls guidefile when available in directory
   where PPC680x0: is assigned to
 - Power StormASM Predefined Symbols added
 - =/== added
 - Block comments added
 - Floating Joint natives added. No effect though!!!
@endnode

@node "Amiga" "Amiga"
@{b}@{fg shine}OUR GREAT AMIGA@{ub}@{fg text}

@{b}This program is dedicated to all the Amiga respecting Amigans still 
active today  and of course to Jay Miner. Thanks to all of you!

@{ub}@{fg shine}Amiga shall rise again!!!@{fg text}
@endnode

@node "Toilet" "Toilet"
@{b}@{fg shine}PC SUXX!@{ub}@{fg text}

@{i}Don't you think so?@{ui}

No? Then why are you still here? Go away.

@{b}@{u}@{fg shine}AMIGA RULEZ!@{ub}@{uu}@{fg text}
@endnode

