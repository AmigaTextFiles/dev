@DATABASE "Abakus.guide"

@NODE MAIN "Abakus.guide"

                    Abakus Compiler

                   Version  0.950705

         Copyright 1995-2095   Andrea Tobian-Mezger




                  @{" Information   " Link Information}
                  @{" Kurzanleitung " Link Kurzanleitung}
@ENDNODE

@NODE Information "Information"

          @{" Was ist Abakus          " Link Was_ist_Abakus}
          @{" Verbreitung             " Link Verbreitung}
          @{" Copyright               " Link Copyright}
          @{" Updates und Hotline     " Link Updates_und_Hotline}
          @{" geplante Verbesserungen " Link geplante_Verbesserungen}
          @{" Verbesserungen          " Link Verbesserungen}
@ENDNODE

@NODE Was_ist_Abakus "Was ist Abakus"


 Abakus ist der Sammelname meiner Programme, zur Zeit sind
 zwei Programme in der Entwicklung:
 Der Abakus Compiler, welchen ich in der Version 0.950628
 ins Aminet gegeben habe.
 Und Abakus BBS, welches aber erst zu 50% fertig ist.

 Der Abakus Compiler ist in seiner ersten veröffentlichten
 Version >> Geschenkware << , d.h. ich erwarte eine
 Gegenleistung.

 Falls in Zukunft nur Ansprüche an mich erhoben werden,
 aber keine oder nur sehr geringe Gegenleistungen erbracht
 werden, dann ergibt sich daraus zwangsläufig das alle
 weiteren Versionen nur noch gegen Bargeld erworben werden
 können.

@ENDNODE

@NODE Verbreitung "Verbreitung"


 Der Abakus Compiler darf in der Version 0.950628 nur
 im Aminet verbreitet werden und in Boxen zum Download
 angeboten werden, solange die Box keine Gebühr für's
 Downloaden erhebt.

 Verbreitung in Serien oder auf eine anderweitige Art
 ist ohne meine schriftliche Genemigung verboten.



@ENDNODE

@NODE Copyright "Copyright"


 Das Copyright des Abakus Compiler der Versionen

    0.950628 bis unendlich

 liegt bei Andrea Tobian-Mezger.

@ENDNODE

@NODE Updates_und_Hotline "Updates und Hotline"


 Updates können bei mir bezogen werden.
 Informationen darüber können über die Hotline
 abgerufen werden.

 Hotline:
           ABAKUS BBS (49)(0)7045-40283
            9:00 - 15:00
           21:00 - 23:00
           bei Gewitter Urlaub usw. Offline.

 Diese Nummer gilt bis ca. Frühjahr 1996, danach
 entweder in der 07er Liste nachschauen oder
 warten bis eine Nummer bekannt gegeben wird.

 In der Inside in Karsruhe bei Mathias Supp kann ich
 auch als Online User erreicht werden.
 Einfach Private Mail an Andrea Tobian-Mezger schreiben.

 Übers FIDO bin ich zur Zeit über zwei Adressen erreichbar,
 Andrea Tobian-Mezger 2:2474/350.18
 und
 Andrea Tobian-Mezger 2:2474/530.7

 Wer eine Netmail schreibt und bei Betreff/Subject ein .hot an den
 Anfang stellt, erklärt sich damit bereit das diese Netmail
 in die Abakus Support Area geforwardet wird, welche z.Z.
 in der Hotline für Abakus User eingerichtet ist.

 Am schnellsten wird allerdings in der Hotline geantwortet.
 Diese Möglichkeit unbedingt vorziehen.
 Briefe über den Postweg kann ich keine beantworten,
 da ich keine Briefmarken Druckerei besitze ;-)

 Gültige Adressen:
 Bis ca. Frühjahr 1996

           Andrea Tobian-Mezger
           Heilbronner Str. 29-1
           75447 Sternenfels
           Tel.: 07045-8630
           Box.: 07045-40283

 ab ca. Frühjahr 1996

           Andrea Tobian-Mezger
           Mühlwaldstr. 1
           75433 Maulbronn/Zaisersweiher
           Tel.: ????
           Box.: ????

@ENDNODE

@NODE geplante_Verbesserungen "geplante Verbesserungen"

 Eigene Abakus Macro's verarbeiten, und erkennen ob
 movea.l #Label,a0  oder movea.l Label,a0 verwendet wird
 ggf. in lea Label,a0 umwandeln.

 Evtl. Optimizer schreiben.
 Case/Gosub verbessern.
 Push/Pull ein Register erkennen sowie Push all angeben.
 Library Macros > SLI verbessern.
 Array's verwalten .. mal sehen.


 Die Anleitung verbessern!
 Einsteiger Kurs schreiben.
 Mehr Demo Programme schreiben .. oder sammeln :-)
 Englische Übersetzung schreiben, oder schenken lassen :-))
 Meine Assemblermacrosammlung überarbeiten und beilegen.
 Fehler beseitigen :-(
 Was mir sonst noch einfällt, irgendwann einmal.

@ENDNODE

@NODE Verbesserungen "Verbesserungen"

  Seit 0.950628
  -------------

 -        Let.b a = b + #20  setzte kein Linefeed nach erstem Befehl.
   erzeugte:
          move.b b,a    add.b #20,a
   jetzt:
          move.b b,a
          add.b #20,a

 -        Versionsnummer kann nun mit "Version Abakus" abgerufen werden.

  Seit 0.950704
  -------------

 -        Else / End Else  Funktionen eingeführt.

  Seit 0.950801
  -------------

 -        Start obj name / End obj
 -        Start ptr  /  End ptr
 -        Macros für einfachen Serial.device Aufruf
 _________________________________________________________________________


@ENDNODE

@NODE Kurzanleitung "Kurzanleitung"

          Aufruf:
          Abakus <file>
          erzeugt:
          <file.asm> assemblieren und linken <file> :-((

 Vorsicht wenn man nun <file.asm> assembliert und linkt
 wird <file> überschrieben, ich hänge ein Prefix an den Filenamen.

          Aufruf:
          Abakus <file.a>
          erzeugt:
          <file.a.asm> assemblieren und linken <file> :-))


          @{" Allgemeines " Link Allgemeines}
          @{" Befehle     " Link Befehle}
          @{" Macros      " Link Macros}

@ENDNODE

@NODE Allgemeines "Allgemeines"

 Der Abakus Compiler ist eigentlich ein Aufsatz oder eine Erweiterung
 für den A68k Assembler, der Compiler hat keine eigene String oder
 Variablen Verwaltung.
 Ich habe ihn geschrieben um den Assemblertext etwas übersichtlicher
 und die Makros freier gestalten zu können.
 Ausserdem muss man bei Vergleichen nicht auf die Adressierungsarten
 achten.


 Strings und Variablen werden wie in Assembler deklariert und genau so
 übernommen.

 z.B.

 File  dc.b "Ram:Testfile",0

           cnop 0,2
 Fileadr ds.l 1


 Assemblerbefehle zwischen dem Abakus Quelltext wird als Assemblerquelltext
 übergeben, besser ist aber diese Textzeilen mit einem >#< am Zeilenanfang
 zu markieren oder zwischen Start asm und End asm einzufügen.
 Diese Zeilen werden dann nicht durch den Parser geschickt und das compilieren
 beschleunigt sich geringfügig.

 z.B.

 #         move.l d1,d2

 oder
           Start asm
           move.l d1,d2
           add.l #4,d2
           .... usw.
           End asm

 Kommas eckige Klammern und Leerzeichen werden als Trennzeichen erkannt,
 dadurch kann man das Aussehen des Quelltextes individueller gestalten.

 z.B.

           When.b [x = #2] goto wasweisichwohin
           when.b,x,=,#2,goto,wasweisichwohin
           when.b[x = #2 goto wasweisichwohin]
           when.B x = 2 GOTO [wasweisichwohin]
           when  b  x = 2 GOTO [wasweisichwohin]
           when  [b]  x = 2 [GOTO] [wasweisichwohin]
 ist alles das selbe, ob Sinnvoll oder nicht ist geschmackssache.


 Auf Gross und Kleinschreibung wird bei den Abakus Befehlen nicht geachtet,
 bei den Assembler Label aber schon, da muss auf Gross-Kleinschreibung geachtet
 werden.

 Lokale Label können mit einem Punkt beginnen, müssen allerdings zwischen
 zwei globalen Labeln stehen.
 Der Punkt wird von Abakus in einen Backslash gewandelt.

 z.B.

 Global1

 .loop

 Global2

 .loop

 Global3

 Assembler Macros Aufrufe können auch auf diese Weise gestaltet werden,
 denn Abakus behandelt jede Zeile wie folgt:

     Befehl[.n] Wort1 ... Wort 18
 Der Befehl kann .b .w oder .l als Prefix enthalten.
 b w oder l kann aber auch ohne Punkt als 2. Wort übergeben werden.
 .bwl wird beim A68k Macro als \0 Wert übergeben.

 z.B. Das Assemblermacro Write DATEI,PUFFER,LÄNGE

           Write stdout [#Text #Textlänge]
           Write [stdout #Text #Textlänge]
           wird übersetzt
           Write stdout,#Text,#Textlänge

 Alle Schleifen können auch mit Goto oder Gosub verlassen werden.
 Oder auch mit bra bsr beq bne usw.  jmp und jsr.

 Schleifen benötigen immer ein Label!

   Schleifenbefehl[.n] Label ....

 Das Label darf in einem Programm bei ein und demselben Schleifentyp nur
 einmal vorkommen.
 Dasselbe Label wird für Exit, Else und End Befehle verwendet.

 z.B.

          If.b Label_1 [ x = #555]      ;hier das Label > Label_1
            inc.b y
            dec.b z
          Else Label_1                  ;und hier das Label > Label_1
            dec.l XYZ
          End If Label_1                ;und hier das Label > Label_1


@ENDNODE

@NODE Befehle "Befehle"



          @{" Module            " Link Module}
          @{" Start asm         " Link Start_asm}
          @{" Push Pull         " Link Push_Pull}
          @{" Again             " Link Again}
          @{" Let               " Link Let}
          @{" Externe Programme " Link Externe_Programme}
          @{" #                 " Link #}
          @{" Clear             " Link Clear}
          @{" When              " Link When}
          @{" Goto Gosub Return " Link Goto_Gosub_Return}
          @{" Select Case       " Link Select_Case}
          @{" If  End If        " Link If__End_If}
          @{" Else   End Else   " Link If__End_If}
          @{" Repeat Until      " Link Repeat_Until}
          @{" Loop  End Loop    " Link Loop__End_Loop}
          @{" For Next          " Link For_Next}
          @{" IFL  IFNL         " Link IFL__IFNL}
          @{" Inc Dec           " Link Inc_Dec}
          @{" Error             " Link Error}
          @{" Set7              " Link Set7}
          @{" Start Obj         " Link Start_Obj}
          @{" Start Ptr         " Link Start_Ptr}

@ENDNODE

@NODE Module "Module"

           Module
oder       Module wb
           Module cli
 ----------------------------------------------------
 Module bindet die Startup Sequenz sowie eine kleine
 Macrosammlung am Anfang ein.

          module oder module wb
          bindet Startup Sequenz für WB Start ein.
          module cli
          bindet CLI Startup ein, man kann den Programmen
          kein Icon verpassen.

 Bitte unbedingt an den Programmanfang stellen.
 Dieser Befehl wird noch überarbeitet.

 ----------------------------------------------------
@ENDNODE

@NODE Start_asm "Start asm"

   Start asm
   end asm
 ----------------------------------------------------

 Die Zeilen zwischen Start asm und End asm werden
 vom Abakus Compiler ignoriert.
 Man kann hier Assembler Quelltext oder den Quelltext eines
 anderen Compilers einfügen.

 ----------------------------------------------------
@ENDNODE

@NODE Push_Pull "Push Pull"

   push <Register>
   pull <Register>
 ----------------------------------------------------
 Mit push werden die genannten Register im Stack
 abgelegt.
 D.h. der Inhalt dieser Register wird im Stack zwischengespeichert,
 somit kann man die Register z.B. in einer Subroutine benutzen
 anschliessend mit pull vom Stack holen und mit dem alten
 Inhalt weiter arbeiten.

           push d1-d4/a3-a5
           push.l d1-d4/a3-a5

 entspricht in Assembler

           movem.l d1-d4/a3-a5,-(sp)

 Mit pull werden die abgelegten Register wieder vom
 Stack geholt.

           pull d1-d4/a3-a5
           pull.l d1-d4/a3-a5

 entspricht in Assembler

           movem.l (sp)+,d1-d4/a3-a5


 ----------------------------------------------------
@ENDNODE

@NODE Again "Again"

   again <Label> <wert>
   exit again <Label>
   end again <Label>
 ----------------------------------------------------
 Mit Again - End Again wird eine Schleife aufgebaut, die
 so oft durchlaufen wird wie in Wert angegeben.
 Bei der angabe des Labels muss auf Groß-Kleinschreibung
 geachtet werden.
 Exit Again Label beendet Schleife vorzeitig.

           Again ABC #7
           .
           .
           .
           End Again ABC

           Again xyz #7
           ...
             Exit Again xyz
           ...
           End Again xyz

 Als Schleifenzähler wird Standardmässig das Register D7 verwendet.

 ----------------------------------------------------
@ENDNODE

@NODE Let "Let"

   let.n <Wert> = <Wert> <1> <2> <3> <4> <5> <6> <7>
 ----------------------------------------------------
 Let.n ohne <1> - <7> weist einer Variable oder einem Register einen Wert zu.

           Let.l d4 = #444000
 entspricht in Assembler
           move.l #444000,d4

 es können noch 7 weitere Operationen durchgeführt werden,
 entweder als Addition, Subtraktion, Multiplikation oder Division.

 z.b. für <1>   + #6 einsetzen

           Let.l d4 = Variable + #6
           Let.l d4 = d4 + wert9 - #33 * d4 \ (a3)

 Die Operationen werden der Reihe nach durchgeführt, es können keine
 Klammern verwendet werden.


 ----------------------------------------------------
@ENDNODE

@NODE Externe_Programme "Externe Programme"

 > <Programmname>
 ----------------------------------------------------
 Mit > am Zeilenanfang kann ein externes Programm gestartet werden.
 Z.B. ein Arexxprogramm um einen neuen Befehl einzuführen.
 Externe Programme müssen im Verzeichnis Abakus:alien/ liegen.

 z.B.
 >  test.rexx

 ----------------------------------------------------
@ENDNODE

@NODE # "#"
 #
 ----------------------------------------------------
 Bei einem # am Zeilenanfang wird diese Zeile ignoriert, entspricht
 Start asm - End asm

 ----------------------------------------------------
@ENDNODE

@NODE Clear "Clear"

   clear.n
 ----------------------------------------------------
 Clear.n löscht ein Register oder eine Variable.

           Clear.l d6         >> moveq.l #0,d6
           Clear.b Variable   >> move.b  #0,Variable
           Clear.l A3         >> sub.l   a3,a3

 ----------------------------------------------------
@ENDNODE

@NODE When "When"

   When.n <Wert> <Vergleich> <WERT> <Goto/Gosub> <Label>
 ----------------------------------------------------
 Wert kann alle Inhalte haben, z.B. Register , Variable , Konstante

 Beispiele:

           when.l d0 = #0 goto Ende
           when.b a < b goto machAgrösser
           when.w x >= y gosub Loop4
           when.b x not d5 gosub oh_nein
           when.w d4 <> xy goto vonVorne
           when.b (a4)+ < (a3)+ goto Loop24

 Bei manchen Vergleichen wird das Register D7 standardmässig
 als Vergleichsregister verwendet.
 z.B.
           when.l wertA = wertB goto IrgendWohin
 wird übersetzt:
           move.l wertB,d7
           cmp.l wertA,d7
           beq IrgendWohin

           when.b d3 = #0 goto Speichern
 wird übersetzt:
           tst.b  d3
           beq Speichern


 Nicht möglich ist:
 z.B.
           when.b #5 = #4 goto blabla  ... 5 ist nie 4

 ----------------------------------------------------
@ENDNODE

@NODE Goto_Gosub_Return "Goto Gosub Return"

   Goto <Label>

   Gosub <Label>

   Return
 ----------------------------------------------------
           Goto Label
 entspricht in Assembler
           bra Label

           Gosub Label
 entspricht in Assembler
           bsr Label

           Return
 entspricht in Assembler
           rts

 ----------------------------------------------------
@ENDNODE

@NODE Select_Case "Select Case"

   Case / Goto , Case / Gosub , Case / End Case
   Select , Select / End Select

   select <Wert> [Label]
   exit select <Label>

   case.n [Vergleich] <Wert> <Goto> <Label>
    oder
   case.n [Vergleich] <Select_Label Case_Label> <Wert> <Gosub> <Label>
    oder
   case.n <Select_Label Case_Label> <Wert>
   end case

   exit case  <Label>
   end select <Label>
 ----------------------------------------------------
 Select übergibt einen beliebigen Vergleichswert ins Register D7
 Case vergleicht ihn mit einem zweiten Wert beliebiger Art und
 Verzweigt zum angegebenen Label oder Subroutine.
 Mit Exit Select <Label> oder Exit Case <Label>  kann die Select - End Select
 Schleife unterbrochen werden.

 In diesem Beispiel muss kein End Select angegeben werden.
 Bei Case ... Goto werden keine Select_Label und Case_Label verwendet.
 z.B.
           select.b ZahlA
             case.b #1 goto Ist1
             case.b #2 goto Ist2
             case.b #3 goto Ist3
             case.b #4 goto Ist4
             case.b not #7 goto Nicht7
             case.b < #10 goto Kleiner10

 Beispiele mit Select_Label und Case_Label
 z.B.
           select.b ZahlB SELa
             case.b SELa CSa #1
              ....usw...
             end case SELa CSa
           end select SELa
 dasselbe:
           select.b ZahlB [SELa]
             case.b [SELa,CSa] #1
              ....usw...
             end case [SELa,CSa]
           end select [SELa]

 z.B.
           Select.l Along [SELb]
             Case.l [SELb CS1] #4 gosub Nach4
             Case.l not [SELb CS2] #4 gosub NachNOT4
             Case.l <= [SELb CS3] #5 gosub NachLE5
           End Select [SELb]
 ----------------------------------------------------
@ENDNODE

@NODE If__End_If "If  End If"

           if.n <Label> <Wert> <Vergleich> <Wert>
           end if <Label>
 oder
           if.n <Label> <Wert> <Vergleich> <Wert>
           else <Label>
           end else <Label>
 ----------------------------------------------------
 Eine If "Schleife" wird mit End If beendet.
 Wenn Else vorkommt wird mit End Else beendet.

 Falsch:
           If.l [Fehler] a = b

           Else [Fehler]

           End If [Fehler]

  ________________________________________

           If.b [Alpha] d1 = d2
            ...
            ...
           End If [Alpha]

 Wenn d1 gleich d2 ist dann wird der Programmteil innerhalb
 If und End If  ausgeführt, ansonsten wird zu End If verzweigt.
  _________________________________________

           If.b [Beta] d1 <= d2
            ...
           Else [Beta]
            ...
           End Else [Beta]

 Wenn d1 kleiner oder gleich d2 ist wird der Programmteil
 zwischen If und Else ausgeführt und anschliesend zu End Else
 verzweigt.
 Wenn nicht wird der Programmteil zwischen Else und End Else
 ausgeführt.

 ----------------------------------------------------
@ENDNODE

@NODE Repeat_Until "Repeat Until"

           repeat <Label>
           exit repeat <Label>
           until.n <Label> <Wert> <Vergleich> <Wert>
           exit until <Label>
 ----------------------------------------------------
 Mit Repeat beginnt die Repeat/Until Schleife, sie wird
 solange durchlaufen bis die Bedingung eintrifft.

 In diesem Fall wird die Schleife beendet wenn (a5) kleiner
 als Puffer ist.

           Repeat [Beta]
            ....
            ....
           Until.w [Beta] (a5) < Puffer
 ----------------------------------------------------
@ENDNODE

@NODE Loop__End_Loop "Loop  End Loop"

           loop <Label>
           exit loop <Label>
           end loop <Label>
 ----------------------------------------------------
 Eine Loop/ End Loop Schleife kann mit einem Exit Loop
 abgebrochen werden oder mit Goto und Gosub verlassen
 werden.
           Loop Aloop
            ...
            ......
           End Loop Aloop
 ----------------------------------------------------
@ENDNODE

@NODE For_Next "For Next"

           For.n <Label> <Wert> = <Wert> To <Wert> Step <Wert>
           Next <Label>
 ----------------------------------------------------
           For.b [a1] zz = #48 to #57
             ...
           Next [a1]


           For.b [a2] zz = #"A" to #"z" Step #3
             ...
           Next [a2]

 ----------------------------------------------------
@ENDNODE

@NODE IFL__IFNL "IFL  IFNL"

           ifl <Label>  <SprungMarke>
           ifnl <Label>  <SprungMarke>
 ----------------------------------------------------
 Für spätere Macro Verarbeitung eingeführt.
 Bedingtes Compilieren.

 z.B.
          ifl [xa1] Marke1
            ;Dieser Teil wird nur ausgeführt wenn
            ;Die Sprungmarke 'Marke1' existiert.
          end ifl [xa1]
          ifnl [a2] Loop5
            ;Dieser Teil wird nur ausgeführt wenn
            ;die Sprungmarke 'Loop5' NICHT existiert.
          end [a2] ifnl

 Eine Sprungmarke ist ein Label und kann beim Assembler auch eine
 sogenannte Variable sein.
 Variablen werden in Assembler durch Label markiert.

 ----------------------------------------------------
@ENDNODE

@NODE Inc_Dec "Inc Dec"

           dec.n <Wert>
           inc.n <Wert>
 ----------------------------------------------------
 Mit Inc.n wird eine Variable oder ein Register um eins erhöht.
 Mit Dec.n wird eine Variable oder ein Register um eins erniedrigt.

 z.B.     dec.b zz    in Assembler>   sub.b #1,zz
          inc.b d0    in Assembler>   addq.b #1,d0
          dec.l (a0)  in Assembler>   sub.l #1,(a0)


 ----------------------------------------------------
@ENDNODE

@NODE Error "Error"

           Error <Label>
 ----------------------------------------------------
 Die meisten Library Routinen geben bei einem Fehler
 eine Null im Register D0 zurück, Error testet dieses
 Register auf Null und verzweigt bei einem Fehler zu dem
 angegebenen Label.
 ----------------------------------------------------
@ENDNODE

@NODE Set7 "Set7"

           Set7 <DatenRegister Nummer>
 ----------------------------------------------------
 Mit set7 kann man das voreingestellte Register D7
 z.B. bei Select, Repeat, usw. ändern.
 Dies kann nötig sein bei verschachtelten Schleifen,
 wenn set7 aufgerufen wurde muss erneut ein set7 7
 aufgerufen werden um das Register D7 wieder einzustellen.

 z.B.
 Falsch!!!
          Repeat [aa]
           If.b [bb] x = y    ;hier wird d7 benutzt
             ; irgendwas
           End If [bb]
           ; sonst noch irgendwas
          Until.b [aa] b = a  ;und hier wird d7 benutzt


 man muss nun entweder das Register auf den Stack retten
 oder mit set7 6 zum Beispiel ein anderes Register
 einstellen.

 z.B.
 Richtig!!!
          Repeat [aa]
           If.b [bb] x = y    ;hier wird d7 benutzt
             ; irgendwas
           End If [bb]
           ; sonst noch irgendwas
           set7 6             ;hier wird als Standard Vergleichsregister d6
                              ;eingestellt
          Until.b [aa] b = a  ;und hier wird d7 benutzt

 nach verlassen der Schleife am besten wieder mit set7 7
 das Register d7 einstellen.
 Dieser Befehl ist Compiler intern und vergrössert den
 Code nicht, nur den Quellcode ein klein wenig.




 ----------------------------------------------------



@ENDNODE

@NODE Start_Obj "Start Obj"

          Start Obj TEST
            dc.b "blabla bla",0
            dc.b 10,10,0
            dc.b ".............. irgendwas",10
          End Obj

ergibt:

TEST1       dc.b "blabla bla",0
TEST2       dc.b 10,10,0
TEST3       dc.b ".............. irgendwas",10

@ENDNODE

@NODE Start_Ptr "Start Ptr"

          Start Ptr
            TextAdr
            FileAdr
            DevicePort
          End Ptr

ergibt:

TextAdr             ds.l 1
FileAdr             ds.l 1
DevicePort          ds.l 1



@ENDNODE




@NODE Macros "Macros"

                    @{" raw             " Link raw}
                    @{" con             " Link con}
                    @{" Reads           " Link Reads}
                    @{" ReadsChar       " Link ReadsChar}
                    @{" Waits           " Link Waits}
                    @{" Randomize_timer " Link Randomize_timer}
                    @{" RND             " Link RND}
                    @{" Numb0           " Link Numb0}
                    @{" WriteS          " Link WriteS}
                    @{" Write0          " Link Write0}
                    @{" Instring        " Link Instring}
                    @{" Str             " Link Str}
                    @{" Val             " Link Val}
                    @{" Time            " Link Time}
                    @{" Fillstring      " Link Fillstring}
                    @{" Nullstring      " Link Nullstring}
                    @{" Getstring       " Link Getstring}
                    @{" Chain           " Link Chain}
                    @{" Comp            " Link Comp}
                    @{" Getword         " Link Getword}
                    @{" OpenSer         " Link OpenSer}
                    @{" CloseSer        " Link CloseSer}
                    @{" WriteSer        " Link WriteSer}
                    @{" ReadSer         " Link ReadSer}
                    @{" PutSer          " Link PutSer}
                    @{" GetSer          " Link GetSer}
                    @{" SetSerParams    " Link SetSerParams}
@ENDNODE

@NODE raw "raw"
schaltet CON-Window in RAW Window um.
_________________________________________________

@ENDNODE

@NODE con "con"
schaltet RAW-Window in CON Window um.
_________________________________________________

@ENDNODE

@NODE Reads "Reads"
Reads <Puffer> <Anzahl-Zeichen>

liest Anzahl-Zeichen in Puffer von stdin
_________________________________________________

@ENDNODE

@NODE ReadsChar "ReadsChar"
ReadsChar <Puffer>

liest ein Zeichen in Puffer von stdin
_________________________________________________

@ENDNODE

@NODE Waits "Waits"

waits <Label>

Wartet auf ein Zeichen von stdin, wenn kein
Zeichen da ist dann verzweige zu Label.
_________________________________________________

@ENDNODE

@NODE Randomize_timer "Randomize_timer"

Startwert für RND, wenn RND ohne Randomize_Timer
gestartet wird, dann wird immer dieselbe Reihenfolge
an Zahlen bei Programmstart erzeugt.
_________________________________________________

@ENDNODE

@NODE RND "RND"

rnd [min] max [var] [step]

Gibt Zufallswerte im Wordbereich aus.

Mögliche Aufrufsarten:

rnd <max>

Gibt Zufallwert zwischen 0 und max aus.
Resultat in d0.

rnd <max> <var>

Gibt Zufallszahl zwischen  0 und max aus
und legt Zahl in var (LONG) ab.

rnd <min> <max> <var>

Gibt Zufallszahl zwischen min und max aus
und legt Zahl in var (LONG) ab.

rnd <min> <max> <var> <step>

Gibt Zufallszahl zwischen min und max in step
Schritten aus und legt sie in var (LONG) ab.
_________________________________________________

@ENDNODE

@NODE Numb0 "Numb0"


numb0 <Puffer> [var]

Zähle Zeichen in einem Null terminierten Puffer.
Zählt die Zeichen eines Speicherbereiches bis eine
Null kommt.

numb0 <Puffer> gibt Resultat in d3 aus.

numb0 <Puffer> <var> legt Resultat in var (LONG) ab.
_________________________________________________

@ENDNODE

@NODE WriteS "WriteS"

writeS <Puffer> [len]

Gibt Null terminierten String/Puffer in stdout aus.
Wenn Länge angegeben, dann String,Länge in stdout.
_________________________________________________

@ENDNODE

@NODE Write0 "Write0"

write0 <Ausgabe> <Puffer>

Gibt Null terminierten String/Puffer in Ausgabe
aus.
Ausgabe kann ein Fenster oder eine Datei/File sein.
_________________________________________________

@ENDNODE

@NODE Instring "Instring"

instring <String> <Puffer>
instring <String> <Puffer> <var>

Finde String in Puffer und gebe Position in d0
oder var aus.

String und Puffer müssen beide Null terminiert sein.

Wenn String nicht in Puffer vorhanden ist, dann ist
das Ergebnis 0

z.B.
String = "abc",0
Puffer = "abcde",0

dann ist das Ergebnis 1

z.B.
String = "abc",0
Puffer = "xx_pp_abcde",0

dann ist das Ergebnis 7
_________________________________________________

@ENDNODE

@NODE Str "Str"

str(.n) <Zahl> <String>
str(.n) <Zahl> <String> [var]

Wandelt Zahl in einen String.

Ergebnis in d0 oder var enthält 0 wenn Zahl
positiv oder -1 wenn Zahl negativ war.
_________________________________________________

@ENDNODE

@NODE Val "Val"

val(.n)

_________________________________________________

@ENDNODE

@NODE Time "Time"


holt Datums/Zeitstempel

Ergebnis in:

xds_std    Long
xds_min    Long
xds_tick   Long
_________________________________________________

@ENDNODE

@NODE Fillstring "Fillstring"

Fillstring <String> <Zeichen> <Anzahl>


Füllt String/Speicherbereich mit Anzahl Zeichen.
_________________________________________________

@ENDNODE

@NODE Nullstring "Nullstring"

Nullstring <String> <Anzahl>


Füllt String mit 0   Anzahl mal auf.
_________________________________________________

@ENDNODE

@NODE Getstring "Getstring"

Getstring <String> <Anzahl>


getstring <String> <Puffer> <Anzahl>
getstring <String> <Puffer> <Anzahl> <ab Position>

Kopiere Anzahl Stellen aus Puffer ab Position in String.

getstring <String> <Anzahl>
kopiert Anzahl Stellen aus A0 in String

getstring <String> <Puffer> <Anzahl>
kopiert Anzahl stellen aus Puffer in String.

getstring <String> <Puffer> <Anzahl> <ab Position>
kopiert Anzahl Stellen aus Puffer ab Position in String.
_________________________________________________

@ENDNODE

@NODE Chain "Chain"

Chain <Puffer> <String1> <String2> <max. Anzahl>


Es werden String1 und String2 nacheinander in Puffer kopiert,
max. Anzahl gibt an wieviel Stellen maximal in Puffer kopiert werden.

String1 und String2 müssen Null terminiert sein.
z.B.

String1 dc.b "1234567890",0
String2 dc.b "0987654321",0
Puffer ds.b 15

  chain #Puffer #String1 #String2 #15

In Puffer steht dann:

Puffer = "123456789009876"

z.B.

String1 dc.b "1234567890",0
String2 dc.b "0987654321",0
Puffer ds.b 25

  chain #Puffer #String1 #String2 #25

In Puffer steht dann:

Puffer = "12345678900987654321",0,0,0,0,0

_________________________________________________

@ENDNODE

@NODE Comp "Comp"

Comp String1 String2 [Anzahl (Standard=#255) ]

Vergleicht String1 mit String2 auf Anzahl Stellen,
ist Anzahl nichtangegeben wird auf 255 Stellen getestet.

Ergebnis:
Wenn String1 grösser als String2 ist dann ist d0=1
Wenn String1 kleiner als String2 ist dann ist d0=-1
Wenn String1 gleich String2 ist dann ist d0=0

_________________________________________________

@ENDNODE

@NODE Getword "Getword"

Getword <von Puffer> <nach Puffer> [ab Pos]
_________________________________________________

@ENDNODE

@NODE OpenSer "OpenSer"

OpenSer Nr,Name,Unit,[Baud,#19200,Bits,#8,Flags,#180,Stop,#1,
                      Buffer,#32000,Break,#250000]

Öffnet das serial.device,
Nr. ist die KennNummer für's Programm, falls man mehrere Lines
mit evtl. verschiedenen Devices öffnen will.

Name ist der Name des Devices welches geöffnet werden soll,
z.B. serial.device oder nullmodem.device etc.

Unit ist die Unit Nummer des Devices, idR. Unit 0

Es werden Prinzipiell 2 IORequest Strukturen angelegt, eine
fürs Lesen und eine fürs Schreiben.

Die Angaben in eckigen Klammern sind optional, sie müssen
auch nicht in der Reihenfolge angegeben werden,
allerdings muss nach einem Stichwort auch ein entsprechender Wert
angegeben werden, z.B.

  OpenSer 1 DevName #0 [Flags #164, Buffer #64000]

Stichworte:                                       Default
Baud  ->  Baudzahl angeben                         19200
Bits  ->  7 oder 8 Bits                                8
Flags ->  Werte zusammen zählen und angeben.         180
Stop  ->  Anzahl Stopbits  1 oder 2                    1
Buffer -> Read,Write Buffer Grösse                 32000
Break  -> Länge der Break Unterbrechung angeben.  250000

Werden keine Stichworte oder nur einige angegeben, dann gelten
jeweils die Default Werte.
______________________________________________

@ENDNODE

@NODE CloseSer "CloseSer"

CloseSer Nr.

Schliesst das serial.device mit der KennNummer
______________________________________________

@ENDNODE

@NODE WriteSer "WriteSer"

.WriteSer Nr.  Puffer Länge

Schreibt Puffer/Länge ins Serial.device mit KennNummer.
______________________________________________

@ENDNODE

@NODE ReadSer "ReadSer"

ReadSer Nr.  Puffer  Anz.

Liest Anzahl Zeichen in Puffer aus Serial.device mit KennNummer.
______________________________________________

@ENDNODE

@NODE PutSer "PutSer"

.PutSer Nr., Puffer, Länge

Schreibt Puffer/Länge ins Serial.device mit KennNummer.
Mittels SendIO, wartet nicht!!
______________________________________________

@ENDNODE

@NODE GetSer "GetSer"

.GetSer Nr., Puffer, Anz.

Liest Anzahl Zeichen in Puffer aus Serial.device mit KennNummer.
Mittels SendIO, wartet nicht!!
______________________________________________

@ENDNODE

@NODE SetSerParams "SetSerParams"

.SetSerParams IOReq,[Baud,#19200,Bits,#8,Flags,#180,Stop,#1,
                    Buffer,#32000,Break,#250000]

Stichworte:                                       Default
Baud  ->  Baudzahl angeben                         19200
Bits  ->  7 oder 8 Bits                                8
Flags ->  Werte zusammen zählen und angeben.         180
Stop  ->  Anzahl Stopbits  1 oder 2                    1
Buffer -> Read,Write Buffer Grösse                 32000
Break  -> Länge der Break Unterbrechung angeben.  250000

Werden keine Stichworte oder nur einige angegeben, dann gelten
jeweils die Default Werte.

z.B.
          SetSerParams _SerReadReq1 Buffer #2000

          setzt den Puffer der ReadRequest Struktur
          mit der KennNummer 1 auf 2000 Bytes.

_SerReadReq+KennNr.
_SerWriteReq+KennNr.
______________________________________________

______________________________________________




@ENDNODE


