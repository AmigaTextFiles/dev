*************************************************
*						*
*		 (C)opyright 1991		*
*						*
*		by  Tomi Blinnikka		*
*						*
*	Don´t try to understand the code	*
*						*
* Version: See info from main source code	*
*						*
*************************************************

;Includes

	INCLUDE	"JMPLibs.i"
	INCLUDE	"XREF:exec.xref"
	INCLUDE	"XREF:dos.xref"
	INCLUDE	"XREF:intuition.xref"

	INCLUDE	"libraries/reqbase.i"
	INCLUDE	"exec/types.i"

; XDEFs

	XDEF	Load
	XDEF	LoadV
	XDEF	VLoad
	XDEF	Save
	XDEF	SaveAs
	XDEF	IOMode

;XREFs

	XREF	OKTxt
	XREF	FCorruptTxt1
	XREF	FileMem1
	XREF	FileLeng1
	XREF	DesLeng
	XREF	InitQAList
	XREF	AddQues
	XREF	_DosBase
	XREF	_IntuitionBase
	XREF	SetActivation
	XREF	OthActivation
	XREF	OthActivation1
	XREF	SleepPointer
	XREF	NormalPointer
	XREF	AddMode
	XREF	Mode
	XREF	NumQ
	XREF	QueCount
	XREF	QueCount2
	XREF	MenusOff
	XREF	MenusOn
	XREF	Speaker
	XREF	LoadName
	XREF	LoadName2
	XREF	SaveName
	XREF	SaveName2
	XREF	FileRequester
	XREF	FRPathName
	XREF	QueFile
	XREF	FileError
	XREF	CheckFile
	XREF	VCheckFile
	XREF	KillQueMem1
	XREF	DesMem1
	XREF	QAList
	XREF	Find
	XREF	SS_ERR_File1
	XREF	SS_ERR_File2
	XREF	SS_ERR_File3
	XREF	SS_ERR_File4
	XREF	SS_Done
	XREF	SS_Load
	XREF	SS_Load2
	XREF	SS_Save
	XREF	SS_SaveAs
	XREF	NoMem1
	XREF	NotSupported
	XREF	Game
	XREF	DoTeach
	XREF	PrintTeach
	XREF	Window1IDCMP
	XREF	SaveQuestion
	XREF	AskReplace
	XREF	TwoGadRequest
	XREF	Que
	XREF	GetLength
	XREF	Window1
	XREF	MainMGad1
	XREF	MainMenu

EOD:		EQU	$E6		;End Of Desc
EOQ:		EQU	$E7		;End Of Ques
EOA:		EQU	$E8		;End Of Ans
EOF:		EQU	$E9		;End Of File
EOL:		EQU	$EA		;End Of Line
EOB:		EQU	$F0		;End of both (Q+A)

LoadV:		move.w	#1,IOMode
Load:		jsr	SleepPointer

		cmp.w	#$00,Mode
		bne	LoadCont1

		move.l	Window1,a0
		lea.l	MainMGad1,a1
		move.l	#-1,d0
		lib	Intuition,RemoveGList

LoadCont1:	cmp.w	#$02,Mode
		bne	Load0.1
		move.w	NumQ,d6
		clr.w	NumQ
		jsr	SetActivation
		jsr	OthActivation
		move.w	d6,NumQ

Load0.1:	jsr	MenusOff

		lea.l	SS_Load,a0
		jsr	Speaker

		cmp.w	#$01,IOMode
		bne	Load0.2
		lea.l	LoadName2,a5
		jmp	Load0.3
Load0.2:	lea.l	LoadName,a5
Load0.3:	move.l	#FRQABSOLUTEXYM+FRQLOADINGM,d5
		jsr	FileRequester
		tst.l	d0
		beq	Load_Out1

		lea.l	FRPathName,a1
		move.l	a1,d1
		cmp.b	#$00,(a1)
		beq	Load_Out1
		move.l	#MODE_OLDFILE,d2
		lib	Dos,Open
		move.l	d0,QueFile
		bne	Load1
		jsr	FileError
		jmp	Load_Out1

;reading "logic"

Load1:		cmp.w	#$01,IOMode
		beq	VLoad

		jsr	CheckFile
		tst.l	d0
		beq	Load_Out2

		jsr	KillQueMem1

		lea.l	SS_Load2,a0
		jsr	Speaker

;Load descriptions (2 lines)

		move.l	DesMem1,d4
Load1.1:	move.l	QueFile,d1
		move.l	d4,d2
		move.l	#1,d3
		lib	Dos,Read
		tst.l	d0
		beq	Load5
		move.l	d4,a2
		add.l	#1,d4
		tst.b	(a2)
		bne	Load1.1

		move.l	DesMem1,d4
		add.l	#LineLeng,d4
Load1.2:	move.l	QueFile,d1
		move.l	d4,d2
		move.l	#1,d3
		lib	Dos,Read
		tst.l	d0
		beq	Load5
		move.l	d4,a2
		add.l	#1,d4
		tst.b	(a2)
		bne	Load1.2

;Then load the questions and answers MAYBE USE 'AddQues'!!!

		move.w	#$00,d4
Load2:		move.l	#QA_SIZE,d0		;reserve memory for node
		move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
		lib	Exec,AllocMem
		tst.l	d0
		bne	Load2.01
		jmp	Load6
Load2.01:	move.l	d0,a2			;Hold node address in a2
		move.l	#NextQues,d0		;Reserve ques-ans memory
		move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1
		lib	Exec,AllocMem		
		tst.l	d0
		bne	Load2.02
		move.l	a2,a1			;No mem. Clear Node mem
		move.l	#QA_SIZE,d0
		lib	Exec,FreeMem
		jmp	Load6
Load2.02:	move.l	d0,a3			;Hold memory info in a3
		lea.l	QAList,a0
		move.l	a2,a1
		ADDTAIL				;Add Node to list
		move.l	a3,QA_Data(a2)		;Add memory info to node

Load2.1:	add.w	#1,d4
		cmp.w	NumQ,d4
		bne	Load2

		move.w	#$00,QueCount		;Start from first question
Load3:		move.b	#$00,d5			;d5 = question line counter
		jsr	Find			;get mem add of QueCount'th ques
Load3.1:	move.l	QueFile,d1		;file stuff
		move.l	a4,d2			;get question mem address
		move.l	#1,d3			;read one byte only
		lib	Dos,Read		;read
		tst.l	d0			;errors?
		beq	Load5			;if so goto Load5
		add.l	#1,a4			;increase memory pointer
		tst.b	-1(a4)			;was last read zero?
		bne	Load3.1			;if not continue looping

;Read two lines of questions

		cmp.b	#$01,d5			;see if done two questoions
		beq	Load3.2			;if so, goto Load3.2
		add.b	#$01,d5			;no. add ques line counter
		jsr	Find			;get start of memory again
		add.l	#LineLeng,a4		;add LineLeng to get next
		jmp	Load3.1			;lines address. Loop.

;Read 9 + one fake answers

Load3.2:	jsr	Find			;get start of curr memory
		add.l	#QueLeng,a4		;skip questions
		move.w	#$00,d5			;d5 = answer line counter
Load3.3:	move.l	QueFile,d1		;file stuff
		move.l	a4,d2			;move memory address
		move.l	#1,d3			;read one byte only
		lib	Dos,Read		;read.
		tst.l	d0			;errors?
		beq	Load5			;If so goto Load5
		add.l	#1,a4			;increase mem address
		tst.b	-1(a4)			;was last byte zero?
		bne	Load3.3			;if not continue looping

		cmp.w	#8,d5			;done 9 answers?
		beq	Load3.4			;if so continue at Load3.4
		add.w	#$01,d5			;increase counter
		jsr	Find			;get start of current mem
		move.w	d5,d1
		add.l	#QueLeng,a4		;Skip questions
		mulu.w	#AnsLeng,d1		;skip read answers
		add.l	d1,a4
		jmp	Load3.3			;loop.

Load3.4:	add.w	#$01,QueCount		;increase QueCounter
		move.w	QueCount,d1		;compare with NumQ
		cmp.w	NumQ,d1			;to see if done all
		beq	Load4
;--- CUT ---
		move.l	QueFile,d1
		move.l	#1,d2
		move.l	#0,d3
		lib	Dos,Seek

;--- CUT ---
;		bne	Load3			;questions. loop if not
		jmp	Load3

Load4:		move.l	QueFile,d1		;Close File
		lib	Dos,Close
		move.l	#$00,QueFile
		move.w	#$00,QueCount		;Reset QueCount
		jmp	Load_Out		;-->OUT

;Come here if read error during des/que/ans

Load5:		jsr	FileError
		lea.l	SS_ERR_File1,a0
		jsr	Speaker
		jsr	KillQueMem1
		move.w	#00,NumQ
		jmp	Load4

;Come here if no memory available

Load6:		jsr	NoMem1
		lea.l	SS_ERR_File1,a0
		jsr	Speaker
		jsr	KillQueMem1
		move.w	#00,NumQ
		jmp	Load4

;come here if everything ok during load

Load_Out:	lea.l	SS_Done,a0
		jsr	Speaker
		jsr	MenusOn
		jsr	NormalPointer
		cmp.w	#$02,Mode
		bne	Game
		jsr	SetActivation
		jsr	OthActivation1
		jmp	DoTeach

;come here if users clicked closewindow or couldn't open that file

Load_Out1:	jsr	MenusOn
		jsr	NormalPointer
		cmp.w	#$02,Mode
		bne	GoMainMenu
		jsr	SetActivation
		jsr	OthActivation1
		jmp	Window1IDCMP

;Incorrect file etc.

Load_Out2:	lea.l	SS_ERR_File2,a0
		jsr	Speaker
		move.l	QueFile,d1
		lib	Dos,Close
		move.l	#$00,QueFile
		jsr	MenusOn
		jsr	NormalPointer
		move.w	#$00,NumQ
		cmp.w	#$02,Mode
		bne	GoMainMenu
		jsr	SetActivation
		jsr	OthActivation1
		jmp	Window1IDCMP

GoMainMenu:	jsr	MainMenu
		jmp	Window1IDCMP

SaveAs:		jsr	SleepPointer
		jsr	SaveQuestion

		cmp.w	#$02,Mode
		bne	SaveAs0.1
		move.w	NumQ,d6
		clr.w	NumQ
		jsr	SetActivation
		move.w	d6,NumQ
		jsr	OthActivation

SaveAs0.1	jsr	MenusOff
		move.w	QueCount,QueCount2
	
		lea.l	SS_SaveAs,a0
		jsr	Speaker

		lea.l	SaveName,a5
		move.l	#FRQABSOLUTEXYM+FRQSAVINGM,d5
		jsr	FileRequester
		tst.l	d0
		beq	SaveOut

		lea.l	FRPathName,a1
		move.l	a1,d1
		cmp.b	#$00,(a1)
		beq	SaveOut
		move.l	#MODE_OLDFILE,d2
		lib	Dos,Open
		move.l	d0,QueFile
		beq	Save1		;file doesn't exist...

;The file already exists so we'll ask if the user wants to replace old file 

		lea.l	SS_ERR_File3,a0
		jsr	Speaker

		lea.l	AskReplace,a0
		move.l	#$00,a1
		jsr	TwoGadRequest
		tst.l	d0
		beq	Save5

		move.l	QueFile,d1
		lib	Dos,Close
		move.l	#$00,QueFile

SaveAsOut:	jsr	MenusOn
		jsr	SetActivation
		jsr	OthActivation1
		jsr	NormalPointer

Save:		jsr	SleepPointer
		cmp.w	#$02,Mode
		bne	Save0.1
		move.w	NumQ,d6
		clr.w	NumQ
		jsr	SetActivation
		move.w	d6,NumQ
		jsr	OthActivation

Save0.1:	jsr	MenusOff
		jsr	SaveQuestion

		lea.l	SS_Save,a0
		jsr	Speaker

Save1:		tst.l	QueFile
		bne	Save2
		lea.l	FRPathName,a1
		move.l	a1,d1
		move.l	#MODE_NEWFILE,d2
		lib	Dos,Open
		move.l	d0,QueFile
		bne	Save2
		jsr	FileError
		jmp	SaveOut

		move.l	#"Ques",Que

Save2:		move.l	QueFile,d1
		lea.l	Que,a0
		move.l	a0,d2
		move.l	#8,d3
		lib	Dos,Write
		cmp.l	#-1,d0
		beq	SaveError

;Save description for questions

		move.l	DesMem1,d2
		jsr	GetLength
		move.l	QueFile,d1
		move.l	DesMem1,d2
		lib	Dos,Write
		tst.l	d0
		beq	SaveError

		move.l	DesMem1,d2
		add.l	#LineLeng,d2
		jsr	GetLength
		move.l	QueFile,d1
		lib	Dos,Write
		tst.l	d0
		beq	SaveError

		move.w	QueCount,QueCount2		;save position
		move.w	#$00,QueCount
Save3:		move.b	#$00,d5
		jsr	Find
Save3.1:	move.l	a4,d2
		jsr	GetLength
		move.l	QueFile,d1
		lib	Dos,Write
		tst.l	d0
		beq	SaveError

;Save two lines of questions

		cmp.b	#$01,d5
		beq	Save3.2
		add.b	#$01,d5
		jsr	Find
		add.l	#LineLeng,a4
		jmp	Save3.1

;Save 9 answers

Save3.2:	jsr	Find
		add.l	#QueLeng,a4
		move.w	#$00,d5
Save3.3:	move.l	a4,d2
		jsr	GetLength
		move.l	QueFile,d1
		lib	Dos,Write
		tst.l	d0
		beq	SaveError

		cmp.w	#8,d5
		beq	Save3.4
		add.w	#$01,d5
		jsr	Find
		move.w	d5,d1
		add.l	#QueLeng,a4
		mulu.w	#AnsLeng,d1
		add.l	d1,a4
		jmp	Save3.3

Save3.4:	add.w	#$01,QueCount
		move.w	QueCount,d1
		cmp.w	NumQ,d1
		bne	Save3

;Close the file

Save5:		move.l	QueFile,d1
		lib	Dos,Close
		move.l	#$00,QueFile
		move.w	QueCount2,QueCount		;Get position
		jsr	Find
		jsr	PrintTeach

SaveOut:	lea.l	SS_Done,a0
		jsr	Speaker
		jsr	MenusOn
		jsr	SetActivation
		jsr	OthActivation1
		jsr	NormalPointer
		jmp	Window1IDCMP

SaveError:	jsr	FileError
		lea.l	SS_ERR_File1,a0
		jsr	Speaker
		jmp	Save5

;The Visama .QIZ loader
;It reserves memory (size of file), finds descriptions, questions+answers
;and puts them into list and dealloctates memory.

VLoad:		jsr	VCheckFile
		tst.l	d0
		beq	VLoad_Out2

		jsr	KillQueMem1
		move.w	#0,NumQ

		lea.l	SS_Load2,a0
		jsr	Speaker

;Get length

		move.l	QueFile,d1
		move.l	#00,d2
		move.l	#01,d3
		lib	Dos,Seek
		move.l	QueFile,d1
		lib	Dos,Seek
		tst.l	d0
		beq	VLoad_ERR1
		move.l	d0,FileLeng1
		move.l	d0,d5
		add.l	#12,FileLeng1		;Just in case

;Seek position #$3F, start of description

		move.l	QueFile,d1
		move.l	#$3f,d2
		move.l	#-1,d3
		lib	Dos,Seek

;Allocate memory

		move.l	FileLeng1,d0
		move.l	#MEMF_CLEAR!MEMF_PUBLIC,d1	;Type of memory wanted
		lib	Exec,AllocMem			;Allocate memory
		move.l	d0,FileMem1
		beq	VLoad_ERR2

;Read whole file
;d5 = Real file length (not FileLeng1)

		move.l	QueFile,d1
		move.l	FileMem1,d2
		move.l	d5,d3
		lib	Dos,Read
		tst.l	d0
		beq	VLoad_ERR1

;Copy descriptions (3 lines)
;Copies until reaches End Of Description (EOD) or length = DesLeng

		move.l	FileMem1,a0		;Source is FileMem1
		move.l	DesMem1,a1		;Destination is DesMem1
		move.w	#$00,d5			;Reset character counter
VLoad1.1:	move.b	(a0)+,(a1)+		;Copy one byte
		add.w	#1,d5			;Increase character counter
		cmp.w	#DesLeng,d5		;See if done maximum amount
		beq	VLoad1.2		;If so goto VLoad1.2
		cmp.b	#EOD,-1(a1)		;See if found End Of
		bne	VLoad1.1		;Description
		clr.b	-1(a1)			;EOD -> NULL

;Change last character of all description lines to NULL

VLoad1.2:	push	a0			;Save start of questions
		move.l	DesMem1,a1		;Get start od descs
		add.l	#DLineLeng,a1		;Find end of 1st line
		clr.b	-1(a1)			;Clear
		add.l	#DLineLeng,a1		;Find end of 2nd line
		clr.b	-1(a1)			;Clear
		add.l	#DLineLeng,a1		;Find end of 3rd line
		clr.b	-1(a1)			;Clear

;Find out how many questions we have loaded.
;Allocate memory for each node and questions and answer
;Then copy the questions and answers into memory
; a0 = start of questions

VLoad2:		move.l	FileMem1,a1		;Get end of File
		add.l	FileLeng1,a1		;in memory
		clr.w	NumQ			;Clear NumQ

VLoad2.1:	cmp.b	#EOF,(a0)		;Found End Of File?
		beq	VLoad2.2		;Yes -> continue
		cmp.l	a0,a1			;Just make sure if EOF
		beq	VLoad_ERR3		;isn't present (no lockup)
		cmp.b	#EOQ,(a0)+		;End Of Question?
		bne	VLoad2.1		;No -> check next byte
		add.w	#1,NumQ			;Increase amount of
		jmp	VLoad2.1		;questions

VLoad2.2:	jsr	InitQAList		;Initialize QAList

		move.w	#$00,d6			;Reset counter
		move.w	AddMode,d5		;Change add mode
		move.w	#0,AddMode		;temporarily to 'add to end'
VLoad2.3:	jsr	AddQues			;Add question
		sub.w	#1,NumQ			;AddQues increases it!
		add.w	#1,d6			;Increase counter
		cmp.w	NumQ,d6			;Done all?
		bne	VLoad2.3		;No -> do more
		move.w	d5,AddMode		;Change add mode back

;Copy questions into memory

		pull	a0			;Get start of questions

		move.w	#$00,QueCount		;Start from first question
VLoad2.99:	jsr	Find			;get mem add of QueCount'th ques
		move.l	a4,a1			;Destination
VLoad3:		cmp.b	#EOL,(a0)		;If next byte is EOL
		beq	VLoad3.1		;go get next question
		move.b	(a0)+,(a1)+		;Copy byte
		jmp	VLoad3

;Read two lines of questions

VLoad3.1:	move.b	#$00,(a1)+		;Clear EOL
		add.l	#1,a0			;Skip EOL in source
		cmp.b	#EOQ,(a0)		;End Of Questions?
		beq	VLoad3.2		;if so, goto VLoad3.2
		jsr	Find			;get start of memory again
		add.l	#LineLeng,a4		;add LineLeng to get next
		move.l	a4,a1			;lines address.
		jmp	VLoad3			;Loop

;Copy answers into memory

VLoad3.2:	add.l	#1,a0			;Skip EOQ in source
		jsr	Find			;get start of curr question
		add.l	#QueLeng,a4		;skip questions
		move.w	#$00,d5			;reset counter
		move.l	a4,a1			;Destination
VLoad3.3:	cmp.b	#EOL,(a0)		;If next byte is EOL
		beq	VLoad3.4		;go get next answer
		move.b	(a0)+,(a1)+		;Copy byte
		jmp	VLoad3.3

VLoad3.4:	move.b	#$00,(a1)+		;Clear EOL in dest.
		add.l	#1,a0			;Skip EOL in source
		cmp.b	#EOA,(a0)		;End Of Answers?
		beq	VLoad3.5		;Yes -> continue
		add.w	#$01,d5			;increase counter
		jsr	Find			;get start of current mem
		move.w	d5,d1
		add.l	#QueLeng,a4		;Skip questions
		mulu.w	#AnsLeng,d1		;skip read answers
		add.l	d1,a4
		move.l	a4,a1			;Destination
		jmp	VLoad3.3		;loop.

;When we get here, we've finished copying a question+answers

VLoad3.5:	move.b	#$00,(a1)+		;Clear EOA in dest.
		add.l	#2,a0			;Skip EOA  & Case etc. in source
		add.w	#$01,QueCount		;increase QueCounter
		move.w	QueCount,d1		;compare with NumQ
		cmp.w	NumQ,d1			;to see if done all
		bne	VLoad2.99		;questions. loop if not

VLoad5:		move.l	QueFile,d1		;Close File
		lib	Dos,Close
		move.l	#$00,QueFile
		move.w	#$00,QueCount		;Reset QueCount
		move.l	FileMem1,a1		;Free temp memory
		move.l	FileLeng1,d0
		lib	Exec,FreeMem
		move.l	#$00,FileMem1
		jmp	VLoad_Out		;-->OUT

;Come here if read error during des/que/ans

VLoad_ERR1:	jsr	FileError
		lea.l	SS_ERR_File1,a0
		jsr	Speaker
		jsr	KillQueMem1
		move.w	#00,NumQ
		jmp	VLoad5

;Come here if no memory available

VLoad_ERR2:	jsr	NoMem1
		lea.l	SS_ERR_File1,a0
		jsr	Speaker
		jsr	KillQueMem1
		move.w	#00,NumQ
		jmp	VLoad5

;Come here if couldn't find EOF

VLoad_ERR3:	move.l	Window1,a0
		lea.l	FCorruptTxt1,a1
		move.l	#$00,a2		;positive text
		lea.l	OKTxt,a3	;a bit the wrong way around but...
		move.l	#$00,d0
		move.l	#$00,d1
		move.l	#$90,d2
		move.l	#$40,d3
		lib	Intuition,AutoRequest

		lea.l	SS_ERR_File4,a0
		jsr	Speaker
		jsr	KillQueMem1
		move.w	#00,NumQ
		jmp	VLoad5

;come here if everything ok during VLoad

VLoad_Out:	lea.l	SS_Done,a0
		jsr	Speaker
		jsr	MenusOn
		jsr	NormalPointer
		cmp.w	#$02,Mode
		bne	Game
		jsr	SetActivation
		jsr	OthActivation1
		jmp	DoTeach

;come here if users clicked closewindow or couldn't open that file

VLoad_Out1:	jsr	MenusOn
		jsr	NormalPointer
		cmp.w	#$02,Mode
		bne	GoMainMenu
		jsr	SetActivation
		jsr	OthActivation1
		jmp	Window1IDCMP

;Incorrect file etc.

VLoad_Out2:	lea.l	SS_ERR_File2,a0
		jsr	Speaker
		move.l	QueFile,d1
		lib	Dos,Close
		move.l	#$00,QueFile
		jsr	MenusOn
		jsr	NormalPointer
		move.w	#$00,NumQ
		cmp.w	#$02,Mode
		bne	GoMainMenu
		jsr	SetActivation
		jsr	OthActivation1
		jmp	Window1IDCMP


		INCLUDE	"FH1:Language/WF/Questions/Que.i"

		STRUCTURE  QA,MLN_SIZE
		    APTR    QA_Data
		    LABEL   QA_SIZE

IOMode:		dc.w	0			(0=Q, 1=V)

		END
