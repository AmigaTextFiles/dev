@Database "PhxAss_d.guide"


@Node Main "PhxAss V4.39 Anleitung (17.11.98)"
                  /\\__________ ________ _________  ____ _____
                  \\___  /  /  /__ ____ _\\ ._ __  /  __/___ _/
                  _/ __/     /    /  / /// /    /__  / / / /
                  \\  //__/__/_/__/__/__/__/_/__/___ /_/_/_/
                   \\/             Phantasm's
=============================================================================
   P H X A S S   V 4 . x x      MC680x0 / 68851 / 6888x  Macro Assembler
=============================================================================
       @{"         Einführung         " link preface}       @{"        CLI Parameter       " link params}
       @{"  Verbesserungen seit V2.00 " link modifications2}       @{"     Programmierer Info     " link prginfo}
       @{"  Verbesserungen seit V3.00 " link modifications3}       @{"       Fehlermeldungen      " link errors}
       @{"  Verbesserungen seit V4.00 " link modifications4}       @{"           Linker           " link linker}
       @{" Beseitigte Bugs seit V2.11 " link bugfixes2}       @{"    Entstehungsgeschichte   " link history}
       @{" Beseitigte Bugs seit V3.00 " link bugfixes3}       @{"        Danksagungen        " link acknow}
       @{" Beseitigte Bugs seit V4.00 " link bugfixes4}       @{"       Bekannte Fehler      " link bugs}
       @{"       PhxAss starten       " link starting}       @{"     Adresse des Autors     " link author}
@EndNode


@Node preface "Einführung"
PhxAss V4.xx ist ein hochoptimierender Makro Assembler für Motorolas 680x0
CPUs, 6888x FPUs und 68851 MMU (die 030er, 040er und 060er MMUs werden
natürlich ebenfalls unterstützt).

PhxAss V4.xx benötigt OS2.04 (V37) als Minimalkonfiguration und wird ältere
Betriebssysteme auch in Zukunft nicht mehr unterstützen! (Kick 1.x Besitzer
sollten daher zu PhxAss V3.97 greifen, welches die letzte Version war, die
noch unter 1.x läuft). 1 MB RAM wird empfohlen.

PhxAss V3.95 gibt es unter
http://fiction.pb.owl.de/~frank/phxass.html

PhxAss V4.xx ist FREEWARE und © copyright 1994-97 by Frank Wille.
Ohne meine ausdrückliche Erlaubnis ist der kommerzielle Vertrieb dieses
Programms strikt untersagt!

Die hervorstechendsten Features:
o Symbolisches und Source Level Debugging. Source Level Debugging auf Hoch-
  sprachenebene für aufsetzende Compiler ist möglich.
o Automatische Erzeugung von ausführbaren Programmen (wenn möglich).
o Erzeugt relocatible Amiga-DOS Objekte oder absoluten Code (welcher in
  eine Datei (Rohformat oder Motorola S-Format), in den Speicher oder
  direkt auf eine Diskette geschrieben werden kann).
o Unterstützung von Small Code und Small Data (auch '__MERGED' Sectionen).
o Listing File, Cross Reference Listing, Equates File.
o Vollständige Unterstützung von Fließkomma: Beliebig komplexe Fließkomma-
  ausdrücke, inklusive einiger Fließkommafunktionen (Sinus, Logarithmus,
  Quadratwurzel, Potenzierung, etc.), können überall verwendet werden, z.B.
  zur Definition von Fließkomma-EQUaten oder SETs.
o Schalter für zehn verschiedene Optimierungen.
o Lokale Symbole (xxx$ und .xxx Typen).
o Bis zu 36 Makro-Parameter können verwendet werden.
o Unterstützt Motorolas alte und neue Operanden-Schreibweise (selbst im
  68000 Modus).
o Nutzung der locale.library (Sprachen bisher: englisch, deutsch, schwe-
  disch, norwegisch, italienisch, dänisch, niederländisch, ungarisch und
  französisch ).
o Nahezu alle Direktiven der am meisten verbreitetsten Assembler, wie Seka,
  DevPac oder AS (Aztec), werden unterstützt. Beispiele: INCBIN, INCDIR,
  CODE_C, REPT, RS, RSRESET, EQUR, REG, OFFSET, XDEF, XREF, PUBLIC, OUTPUT
o PhxAss kann resident im Speicher gehalten werden.


Das PhxAss 4 Archiv sollte zwei verschiedene Versionen enthalten:

1. PhxAss: Der standard 680x0,FPU,MMU Makro Assembler.

2. GigaPhxAss: Identisch zur standard Version, ist aber nicht mehr auf maxi-
   mal 65535 Zeilen im Quellcode beschränkt und eignet sich daher hervor-
   ragend zum Übersetzen von Reassembler-Ausgaben.

@EndNode


@Node modifications2 "Verbesserungen seit PhxAss V2.xx"
Register Symbole (@{"EQUR" link equr}) müssen, bevor sie benutzt werden, erst einmal
definiert werden. Das ermöglicht eine schnellere Erkennung der
Adressierungsart.

Einige neue Optimierungen möglich. Die Optimierungs-Schalter, welche direkt
hinter -n (seit V4.00: OPT) oder nach der @{"OPT" link opt} Direktive angegeben werden,
haben sich komplett geändert (siehe @{"CLI Parameter" link params}).

Wenn das @{"near code" link near} Modell gewählt wurde, werden alle Sprünge auf externe
Symbole nach PC-Relativ konvertiert anstatt nach Long-Branch.

Das '*'-Symbol beinhalten die aktuelle Adresse. Zum Beispiel würde 'bra *+10'
auf eine 12 Bytes entfernte Position hinter dem 'bra'-Opcode verzweigen.

Neue Direktiven: @{"FPU" link fpu}, @{"PMMU" link pmmu}, @{"CODE_C" link chip}
, @{"CODE_F" link chip}, @{"DATA_C" link chip}, @{"DATA_F" link chip},
@{"BSS_C" link chip}, @{"BSS_F" link chip} and @{"INCDIR" link incdir}.

Die @{"Instruktionen" link instroverview} und @{"Adressierungsarten" link extaddr}
vom 68020-68060, 68851(PMMU)
und 6888x(FPCP) werden vollständig unterstützt. Motorolas neue Schreibweise
für Adressierungsarten kann selbst im 68000 Modus eingesetzt werden (z.B.
MOVE (4,A5),D0 ).

Die neue Adressierungsarterkennung hat bei Verwendung von runden Klammern
'()' statt eckigen '[]', um einen Ausdruck zu klammern, keine Schwierig-
keiten mehr. Ein Operand, wie z.B.

 -([x|y]*z)+6([addr+2,A4,regxy*QSIZE],[outdisp+$10<<(1+3)]),((abc-xyz)+2,A3)

sollte keinerlei Probleme verursachen.

PhxAss emöglicht die Benutzung von Fließkommazahlen in 6888x (FPCP) Instruk-
tionen. Zum Beispiel:      fmove.d  #3.1415926536,fp7
speichert die doppelt genaue Fließkommazahl Pi im FPCP Register sieben.

@EndNode


@Node modifications3 "Verbesserungen seit PhxAss V3.00"
V3.10:
o PhxAss kann Vorwärts-Branches optimieren, die erst durch Optimierung des
  nachfolgenden Codes optimierbar werden. Dadurch können weitere Vorwärts-
  Branches in Reichweite kommen, u.s.w.

V3.30:
o Symbole, die mit einem '.' begonnen werden, werden ebenfalls als
  @{"Lokale Symbole" link labels} betrachtet.
o Spezialversion von PhxAss (GigaPhxAss) ist verfügbar, die nicht mehr auf
  eine maximale Anzahl von 65535 Quelltextzeilen beschränkt ist.

V3.40:
o @{"Macro" link macro} Parameter dürfen nun 63 Zeichen beinhalten.
o Die @{"020+ Adressierungsarterkennung" link extaddr} verarbeitet jetzt auch die Zero-
  Register ZD0-ZD7 und ZA0-ZA7 um ein @{"unterdrücktes Register" link zeroregs} genauer zu
  bezeichnen.
o Zwei neue @{"Escapce Codes" link expressions} verfügbar:
  \\e = Escape ($1b)  und  \\c = Control Sequence Introducer ($9b).

V3.42:
o @{"Fließkomma Konstanten" link expressions} dürfen auch durch Hex-Konstanten ausgedrückt werden.
o Wenn Branch-Optimierung eingeschaltet ist, wird die Opcode-Extension nicht
  mehr geprüft. Es wird sowieso der bestmögliche Code generiert.

V3.47
o Neuer @{"Optimierungs Schalter" link params}: 'I' zwingt PhxAss dazu einen 'Too large
  distance' Fehler zu ignorieren.

V3.50
o @{"'@'" link labels} darf als erstes Zeichen eines Symbols verwendet werden, unter der
  Voraussetzung, daß das zweite Zeichen keine Ziffer ist.
o Die @{"RORG" link rorg} Direktive wurde implementiert.
o Untersützung zweier DevPac-spezifischen Direktiven:
  @{"RSRESET" link rsreset} und @{"RS.x" link rs} zum schnelleren Verarbeiten von (Devpac) Includes.
o Die neue Option @{"'-c' (V4:CASE)" link params} kann dazu benutzt werden, die Beachtung
  der Groß/Kleinschreibung von Symbolen auszuschalten.

V3.51
o @{"RSSET" link rsset} hatte ich in V3.50 vergessen.
o Neue Direktiven: @{"IDNT" link idnt}, @{"COMMENT" link comment}, @{"SUBTTL" link subttl}

V3.55
o Von nun an können @{"near-data" link near} Symbole außer durch absolute Adressierung,
  auch im Address Register Indirect Modus (mit (An) als Basisregister) ange-
  sprochen werden. Als positiver Nebeneffekt läuft die Übersetzung solch
  eines Quelltextes sehr viel schneller ab, da PhxAss viel weniger opti-
  mieren muß. Zusätzlich werden dann @{"XREFs" link xref} korrekt interpretiert
 und müssen nicht durch @{"NREFs" link nref} ersetzt werden.
o Wenn ein Unit Name nicht explizit durch @{"TTL oder IDNT" link idnt} angegeben wird,
  verwendet PhxAss den Namen des Quelltextes ohne seine Namenserweiterung.
o Die @{"OFFSET" link offset} Direktive wird unterstützt.

V3.60
o PhxAss V3.60 ist Pure! Er kann durch den CLI-Befehl RESIDENT zur Resident-
  Liste des Betriebssystems hinzugefügt werden.

V3.70
o '.W' and '.L' als Erweiterung an einem Displacement aktivieren automatisch
  den 68020 Base-Displacement Modus.

V3.71
o @{"PROCSTART/PROCEND" link diceproc} Direktiven für Kompatibilität mit DICE-C.

V3.75
o Bei Immediate-Werte wird genau geprüft, ob sie sich im richtigen Bereich
  befinden. Zum Beispiel würde ein "MOVE.B #$1234,D0" von nun an zu einer
  Fehlermeldung führen.

V3.80
o Neue Option @{"'-w' (V4:ERRORS)" link params} um die maximale Anzahl an Fehlermeldungen
  zu bestimmen, die angezeigt werden bevor eine Abfrage erscheint.
o Die Syntax der Adressierungsarten wird viel genauer geprüft (z.B. akzep-
  tierten die Vorläuferversionen "(SP)-").

V3.81
o @{"DC.W und DC.L" link dc} Strings müssen nicht mehr genau auf Wort, bzw. Langwort-
  grenzen ausgerichtet sein (z.B. DC.L "x"  ->  $00000078).

V3.90
o PhxAss wurde durch Einsatz der "locale.library" lokalisiert. Verfügbare
  Sprachen (im August '94) sind: englisch, deutsch und polnisch.
o Die Anleitung wurde ins AmigaGuide Format konvertiert.

V3.92
o Neue Option @{"'-v' (V4:VERBOSE)" link params} um die Namen aller Include-Dateien und
  Makros anzuzeigen, die während der Assemblierung aufgerufen werden.
o Neue Direktive @{"ELSEIF" link ifendc} für Kompatibilität mit DevPac.
o Die Protection-Flags der erzeugten Object-Datei werden auf "rw-d" gesetzt.

V3.94
o Bei BTST, BSET, BCLR and BCHG wird genau geprüft, ob sich die Immediate-
  Werte im Bereich von 0-7 oder 0-31 befinden.
o Jetzt muß erst (S)pecial Optimization eingeschaltet werden um einen ZRn-
  Index wegzuoptimieren, da ich der Meinung bin, daß ein ausdrückliches
  'ZRn' im Quelltext nicht schon bereits durch (N)ormal Optimization wieder
  verschwinden sollte.

V3.95
o Distanzen dürfen ge'shiftet' werden! Beispiel:
   move.w   #(label2-label1)>>1,d0
  Obwohl dies eigentlich dasselbe wie "(label2-label1)/2" ist, ist Division
  und Multiplikation für Distanzen nicht erlaubt. Statt dessen sollten
  Rechts- oder Linkverschiebungen verwendet werden.
  Oft ist es recht nützlich "((label2-label1)>>1)-1" zu schreiben, um z.B.
  den Zähler einer DB<cc>-Schleife zu initialisieren - aber Vorsicht!
  Addition und Subtraktion hinter einem Distanz-Shift wird nicht wirklich
  unterstützt, obwohl es in diesem Spezialfall, wenn die Distanz zwischen
  label1 und label2 durch zwei teilbar ist, zu funktionieren scheint.
  Der Grund ist, daß die Verschiebung grundsätzlich als letztes ausgeführt
  wird, was bedeutet daß die "-1" sich direkt auf die Distanz *vor* der
  Verschiebung auswirkt.

V4.00:
o Umstellung auf OS 2. Neues Commandline-Parsing mittels ReadArgs() und neue
  Namen für die möglichen Argumente.
o Automatische Erzeugung von ausführbaren Load Files. Wenn im Code keinerlei
  externe Referenzen vorkommen, wird kein Linker mehr benötigt.
  Dieses Feature kann durch @{"NOEXE" link params} auch ausgeschaltet werden.
o Source Level Debugging wird unterstützt! Durch @{"LINEDEBUG" link params} wird
  PhxAss dazu veranlaßt einen Linedebug Block zu für jede Section zu erzeu-
  gen, die zu jeder Zeile des Quelltexted die zugehörige Adresse enthält.
o Operandenpuffer von 80 auf 128 Zeichen erweitert.
o Fließkomma Symbole und Konstanten können ab jetzt in belibig komplizierten
  @{"Ausdrücken" link expressions} verwendet werden (wie bei Integer). PhxAss untersützt fünf
  binäre Operatoren, +(plus), -(Minus), (*Mult.). /(Division), ^(Poten-
  zierung), und sechs unäre Operatoren: SIN(Sinus), COS(Cosinus),
  TAN(Tangens), EXP(Exponentialfkt.), LOG(nat. Logarithmus), SQR(Quadrat-
  wurzel).
o Neue Direktive @{"SET.x" link setx} für variable Fließkommasymbole.
o Neue Direktive @{"INT" link int} um das Ergebnis eines Fließkommaausdrucks in ein
  Integer SET-Symbol zu überführen.
o @{"REPT ... ENDR" link rept} Direktiven, wie in DevPac.
o Fließkommasymbole in einem Listing File werden jetzt auch wirklich in
  Fließkommaschreibweise ausgegeben statt als Hexadezimalzahlen.
o Fließkommasymbole erscheinen auch im Equates File.
o Zwei neue Standardoptimierungen (die ich bisher wohl vergessen haben muß):
  1. move.l #0,An  ->  suba.l An,An     2. move.l #x,An  ->  move.w #x,An
o Neuer Small-Data Modus: Durch @{"NEAR A4,-2" link near} werden nur noch die Sectionen
  als Small-Data Sectionen angesehen, die den Namen "__MERGED" tragen
  (wie bei SAS/C).
o 68060 Instruktionen implementiert (bis auf PLPA, da es für mich bis heute
  leider nicht möglich war, den Code in Erfahrung zu bringen).

@EndNode


@Node modifications4 "Verbesserungen seit PhxAss V4.00"
V4.01:
o Die INCLUDE Direktive kann jetzt zusammen mit einem Label in einer
  Zeile stehen.
o 'INCPATH' darf durch 'I' und 'HEADINC' durch 'H' abgekürzt werden.

V4.05:
o Wenn Code-Sectionen nicht auf einer 32-Bit Grenze enden, wird das
  fehlende Word mit $4E71 (NOP) statt mit $0000 gefüllt.
o Die DevPac Optionen 'C', 'L', 'D' und 'O' werden verstanden.
o DS.L 0 kommt einem CNOP 0,4 gleich, DS.Q 0 einem CNOP 0,8, etc..
  Bisher funktionierte dies nur mit DS.W 0.

V4.10:
o Operand darf Leerzeichen enthalten. Beispiel: 'DC.B 1, 2, 3, 4'
o Endlich sind Operatoren mit gleicher Priorität möglich! Beispiele: '*'
  und '/' sowie '<<' und '>>'.
o INCDIR "" ist aus Kompatibilitätsgründen erlaubt.
o Ein Operand darf jetzt bis zu 511 Zeichen beinhalten (bisher 127).
o Neue Parsing-Routinen beschleunigen PhxAss um 5% - 25% !
o Schwedischer Catalog.

V4.12:
o Neue Direktive für Kompatibilität: @{"DX" link ds}. Verhält sich genauso wie DS.
o Die 68060 Instruktionen @{"PLPAR und PLPAW" link pmmu040} sind implementiert!
o Wenn der Übersetzungsvorgang fehlschlug, gibt PhxAss einen Return-
  Code von 20 statt 1 zurück.

V4.14:
o Das @{"__RS" link rs} Symbol wurde implementiert.
o Namenskonflikte zwischen Makros und Direktiven sowie Instruktionen werden
  nun streng geprüft.
o "" und '' werden als einzelnes " bzw. ' in einem String erkannt.
o Wenn eine Code-Section auf mindestens acht Null-Bytes endet, wird von dem
  in V4.05 eingeführten NOP-padding abgesehen.
o Italienischer Catalog.

V4.15:
o Kompatibilität zu alten Seka-Sources verbessert. Bei '=' (EQU) und hinter
  einem Label mit ':' werden keine Leerzeichen bzw. TABs mehr benötigt.
o Wegen starker Nachfrage sind nun Punkte ('.') innerhalb von Symbolnamen
  erlaubt. Ich warne allerdings davor, Symbole auf ".w" oder ".l" enden
  zu lassen!
o Neue Direktive @{"SFORM" link sform} erlaubt im absoluten Modus die Ausgabe von Motorola
  S-Records.
o Dänischer Catalog.

V4.16:
o Die Anzahl der möglichen Makro-Parameter wurde von 9 auf 15 erhöht.
  Die neuen Parameter sind über '\\a' bis '\\f' anzusprechen.
o Durch das neue CLI-Argument "RC=ERRCODE/K/N" kann man nun den Return-
  Code im Fall eines Übersetzungsfehlers direkt bestimmen.

V4.18:
o Bei MOVEQ #x,Dn mit 128<x<255 wird eine Warnung ausgegeben, die sich
  mit der neuen Option NOWARN/S deaktivieren läßt.
o Die Anzahl der möglichen Makro-Parameter wurde weiter erhöht. Jetzt
  sind es 36! (\\0 - \\9 und \\a - \\z)
o Die Größe der Puffer wurde von 512 auf 1024 Bytes erhöht.
o Französischer Catalog.

V4.19:
o Relocatible Symbolwerte bekommen im Listingfile ein Hochkomma ' nachge-
  stellt.
o SECTION erlaubt als dritten Parameter, neben chip und fast, auch einen
  numerischen Parameter (der natürlich entweder $40000000 oder $80000000
  sein sollte!)
o Freeware-PhxAss für Compilerbauer übersetzt jetzt auch 68030-060, FPU
  und MMU Code.

V4.20:
o Niederländischer Catalog.
o @{"EQUR" link equr} funktioniert auch mit Registersymbolen.
o Neue Direktive @{"FREG" link freg}. Funktioniert wie @{"REG" link reg}, aber für die FPU
  Register. Somit können FMOVEMs ohne Register, wie es ein Compiler schon
  einmal erzeugen kann, einfach wegoptimiert werden.
o Die PHXOPTIONS Option Files, wie sie von Johan Johanssens PhxOpts er-
  zeugt werden, werden unterstützt. PhxOpts bietet eine GUI zum Vorbe-
  stimmen und Speichern von PhxAss-Optionen. Natürlich haben Optionen,
  die über die Kommandozeile eingegeben werden, weiterhin Priorität.
o PHXASSINC sollte sich jetzt, wie das globale PHXOPTIONS, in ENV:PhxAss/
  befinden.
o Zwei neue Direktiven @{"SAVE" link save} und @{"RESTORE" link restore} um sich Namen und Typ der
  aktuellen Section zu merken um diese dann später wieder herstellen zu
  können. Praktisch innerhalb von Makros.

V4.21
o Wenn ein Fehler innerhalb eines Makros auftritt, wird immer Zeilen-
  nummer und Name des übergeordneten Quelltextes ausgegeben. Die Zeilen-
  nummer innerhalb des Makros wird dann in einer Extra-Zeile ausgegeben.

V4.23
o 68060 Debugging Instruktionen HALT und PULSE implementiert (nur der
  Vollständigkeit halber ;)

V4.25
o Neue Direktive IF, als Alias für IFNE.

V4.26
o Die zwei neuen Direktiven @{"DEBUG" link debug} und @{"DSOURCE" link dsource} ermöglichen die
  Generierung von Source Level Debugging Informationen auch für
  Hochsprachen.
o Bei eingeschalteter @{"Branch-Optimierung" link params} kann PhxAss eine B<cc>.w
  Instruktion, die im 68000 oder 68010-Modus außer Reichweite gera-
  ten ist, in eine B<!cc>.b/JMP Kombination umwandeln.

V4.30
o Eine Differenz aus zwei Adressen, die nicht aus der Code-Section stammen,
  ist von nun an absolut! Alle arithmethischen und logischen Operationen
  sind damit erlaubt. Für Differenzen aus der Code-Section gelten die aus
  Gründen der Optimierung bekannten @{"Einschränkungen" link expressions}.
o Symbolnamen dürfen von nun an auch die ASCII-Zeichen 192 - 214, 216 - 246
  und 248 - 254 enthalten. Dies beinhaltet zum Beispiel auch die deutschen
  Umlaute.
o @{"MACHINE 68000" link machine} kann dazu verwendet werden, den PMMU Modus zu deakti-
  vieren.
o @{"CNOP" link cnop} verwendet in der Code Section NOP-Instruktionen, solange eine gerade
  Anzahl Bytes zu füllen ist.
o Drei neue Abkürzungen für die gebräuchlisten @{"Optimierungen" link params}, da mit den
  alten ('*' z.B.) häufiger Probleme auftraten (z.B. in Makefiles).
  OPT 1 = standard, OPT 2 = OPT *, OPT 3 = OPT !
o Da die Optimierung von MOVEM in MOVE meistens die Conditioncodes 
  beeinflußt, wurde hierfür das neue Optimierungsflag @{"D" link params} geschaffen, 
  welches sich zur 'M'-Optimierung bei Bedarf hinzuschalten läßt. 
o @{"SECTION" link section} versteht neben CODE_C, DATA_C und BSS_C nun auch die #?_F 
  Varianten.
o Neue @{"Kommandozeilen-Parameter" link params}: MACHINE, FPU und PMMU.
o Mit der neuen Direktiven @{"OUTPUT" link output} ist es möglich im Quelltext den
  Namen der Zieldatei zu spezifizieren (äquivalent zum Kommandozeilen-
  Parameter @{"TO" link params}, nur mit höherer Priorität).

V4.31
o Der XREF-Subtyp EXT_RELREF32 ($88) für 32-Bit PC-Relative Referenzen 
  wird unterstützt. Externe Symbole sind jetzt wirklich in allen möglichen
  Adressierungsarten erlaubt.
o Beim Erzeugen der Zieldatei wird nun Buffered I/O (FWrite) verwendet.

V4.32
o PhxAss ist FREEWARE.
o Anstelle der dos.library Buffered I/O Routinen werden eigene, schnellere, 
  benutzt. Die Größe des Buffers läßt sich über den neuen CLI-Parameter
  @{"BUFSIZE/K/N" link params} variieren und ist auf 8192 voreingestellt.
o Das '%'-Zeichen ist innerhalb von Symbolnamen erlaubt.
o Makro-Parameter dürfen jetzt aus bis zu 127 Zeichen bestehen.
o Die IDNT Direktive versteht jetzt zusätzlich die Syntax in der der Name
  der Unit als Label angegeben ist, wie z.B.:
  unitname	idnt	2,1 testprogram
o PhxAss erzeugt bei den Bit-Manipulationsinstruktionen, wie BTST, BCHG,
  BSET und BCLR keine Fehlermeldung mehr, wenn die Bit-Nummer außerhalb
  des erlaubten Rahmens liegt, sondern nur noch eine Warnung.
o Im Operanden einer FPU-Instruktion ist neben #$xxxx auch #:xxxx zur
  Spezifikation einer hexadezimalen Konstante erlaubt.
o Neue Assembler-Direktiven. Struktur-Offset: @{"SO" link rs}, @{"CLRSO" link rsreset}, @{"SETSO" link rsset}.
  Frame-Offset: @{"FO" link fo}, @{"CLRFO" link foreset}, @{"SETFO" link foset}. Code generation: @{"MC680x0" link mc680x0}.
o PhxAss kann jetzt auch S-Records variabler Länge für 16- und 32-Bit
  Adressen erzeugen. Dazu existiert die neue Direktive @{"STYPE" link stype}.

V4.33
o Neue HashTables für globale und lokale Symbole sowie für alle Mnemonics
  verkürzen die Übersetzungsdauer um durchschnittlich 10-30%. Die
  Größe der HashTables kann mit @{"GLOBHASHTAB/K/N" link params}, @{"LOCHASHTAB/K/N" link params} und 
  @{"MNEMOHASHTAB/K/N" link params} verändert werden.
o @{"CARG" link set} SET-Symbol selektiert einen @{"Makro-Parameter" link macro}, der dann über \\-,
  \\+ oder \\. indirekt angesprochen werden kann. Eine anschließende Inkre-
  mentierung bzw. Dekrementierung von CARG ist mit \\+ bzw. \\- möglich.
o @{"__CPU" link set} enthält die mit @{"MACHINE" link machine} eingestellte CPU, @{"__FPU" link set} enhält
  die mit @{"MACHINE" link machine} bzw. @{"FPU" link fpu} eingestellte FPU-Id und @{"__MMU" link set} zeigt an, ob
  PMMU-Codeerzeugung erlaubt ist.
o Mit dem CLI-Parameter @{"TO" link params} kann jetzt auch ein Directory als Ziel
  angegeben werden. Ein File mit dem Namen des Quelltextes + ".o"-Endung
  wird dort erzeugt.
o Neue Option @{"SHOWOPT/S" link params} listet alle optimierten Quelltextzeilen, zusammen
  mit der Anzahl der gewonnen Bytes, auf.
o A0 und A1 sind zusätzlich als @{"Small-Data" link near} Basisregister erlaubt.
o Das Basisregister kann durch @{"NEAR An" link near} im Verlauf des Quelltextes
  beliebig oft gewechselt werden.
o Makro Parameter @{"\0" link macro} (Extension) kann jetzt auch in Strings eingesetzt
  werden.
o @{"FEQUR" link fequr} Direktive (EQUR für FPn) implementiert.
o @{"Makro-Parameter" link macro} dürfen mit spitzen Klammern zusammengefaßt werden, 
  z.B. <Hello World!> oder <"Test",0>.
o Alle undefinierten XDEF-Symbol werden am Ende der Übersetzung
  aufgelistet.

V4.34
o Neue Direktive @{"SYMDEBUG" link symdebug} erfüllt die gleiche Funktion wie der CLI-
  Parameter @{"DS=SYMDEBUG/S" link params}.
o Neue Direktive @{"LINEDEBUG" link linedebug} erfüllt die gleiche Funktion wie der CLI-
  Parameter @{"DL=LINEDEBUG/S" link params}.

V4.35
o Small Data Adressierung ist auch mit den erweiterten 020+ Adressierungs-
  arten möglich. Z.B. indirekt: ([label,a4])
o Mit @{"PRI/K/N" link params} kann man die Prozeß-Priorität von PhxAss während des
  Übersetzens beeinflussen.
o Durch Setzen des neuen Schalters @{"EXE/S" link params} wird auch dann versucht eine
  direkt ausführbare Datei zu erzeugen, wenn XDEFs vorhanden sind.
o Norwegischer Catalog.

V4.36
o DS/DCB/BLK <n>  benötigen nun mit einem großen <n> nicht mehr Über-
  setzungszeit als bei kleinem <n>.
o Wenn das Format der PHXOPTIONS Datei nicht in Ordnung ist, wird die
  Fehlermeldung "Illegal PHXOPTIONS file" ausgegeben.
o Durch @{"ZEROPADDING/S" link params} wird PhxAss dazu veranlaßt bei CNOP grundsätzlich
  mit Nullbytes aufzufüllen, statt mit NOP-Instruktionen.
o Neue Direktive @{"IMAGE" link incbin} für AsmOne Kompatibilität. Diese verhält sich
  genauso wie @{"INCBIN" link incbin}.
o Direktiven für OMA 3.x Kompatibilität: @{"EQURL" link reg} (verhält sich wie
  @{"REG" link reg}) und @{"FEQURL" link freg} (verhält sich wie @{"FREG" link freg}).
o CMPI #0 und SUBI #0 werden nun zu TST optimiert, sofern 
  @{"(n)ormale Optimierung" link params} aktiviert wurde.
o (outerDisp,[...]) wird automatisch in die 020+ Adressierungsart
  ([...],outerDisp) umgewandelt.

V4.37
o Bei aktivierter @{"(S)pecial Optimization" link params} werden unnötige
  Branches, wie z.B.
    b<cc> label
  label:
  komplett entfernt.
o PhxAss ist ein wenig "Reassembler-freundlicher" geworden.
  ADD/SUB #x,Dn werden nicht mehr nach ADDI/SUBI #x,Dn konvertiert.
o ADDI #0 kann ebenfalls zu TST optimiert werden (siehe v4.36).
o Neue Direktive @{"SHOWOFFSET" link showoffset} gibt den aktuellen Section-Offset über
  stdout (Console) aus.
o Absolut leere Quelltexte sind erlaubt ("empty"). PhxAss erzeugt dann
  ein Object mit einer Code Section die 0 Bytes enthält.
o CMPA #0,An wird zu TST An optimiert, wenn @{"(N)ormal Optimization" link params}
  und @{"020 Code-Generierung" link machine} eingeschaltet sind.
o Einige Fehlermeldungen des Typs "68 Außer Reichweite (Out of range)"
  in "97 Immediate-Operand ist außerhalb seines erlaubten Bereichs
  (Immediate operand size error)" umgewandelt.
o Neue Direktiven @{"ENDASM/ASM" link endasm} um beliebig viele Zeilen eines Quelltextes
  auf einmal auszukommentieren (vergleichbar mit IF 0/ENDIF).
o @{"INITNEAR" link initnear} erzeugt nur noch ein einzelnes LEA base(PC),An falls die
  Small Data Section mit der aktuellen Section identisch ist.
o SF wird zu CLR.B optimiert, wenn @{"(S)pecial Optimization" link params} aktiviert
  ist.

V4.38
o @{"EQUR" link equr} erlaubt maximal 16 lokale Registersymboldefinitionen.
o @{"REM/EREM" link erem} für AsmOne-Kompatibilität eingebaut. Sie sind identisch
  zu @{"ENDASM/ASM" link endasm}.
o Neue Direktive @{"OPTC" link optc} um die Opt-Flags als numerischen Ausdruck verändern
  zu können.
o Das Spezialsymbol "\\@" erlaubt nun 10000 Makroaufrufe anstatt 1000.
o @{"PhxOpts" link phxopts} ist nicht mehr Bestandteil von PhxAss.

V4.39
o Zugriff auf die lokalen Symbole eine fremden Blocks, wie bei AsmOne,
  wird unterstützt. Beispiel: GlobalSym/.LocalSym
o MOVEM erlaubt numerische Konstanten als Registerliste. Beispiel:
    movem.l :$7fff,-(sp)
@EndNode


@Node bugfixes2 "Beseitigte Bugs seit V2.11"
o Einige Instruktionen erzeugten eine falsche Fehlermeldung, z.B. generier-
  ten TRAP und STOP 'Assembly aborted' anstatt 'Out of range'.
o 'move.l  #xxxx,-(a0)' erzeugte einen illegalen Opcode.
o Wenn jemand ein Programm schreibt, ohne vorher eine Section mit CODE/CSEG,
  SECTION oder einem Label begonnen zu haben, erhielten alle Labels falsche
  Werte.
o Teilweise Abstürze beim Erzeugen des Equates Files.
o Ein XDEF mit einem Symbol, das schon in einer anderen Section definiert
  wurde zwang dieses in den Extern-Hunk der augenblicklich aktiven Section.
o Bei Jump und Branch Optimierungen wurde die Adressierungsart der JMP/JSR-
  Instruktion völlig außer Acht gelassen. Es wurden einfach alle Adressie-
  rungsarten optimiert.
o Long Branch auf eine direkt nachfolgende Adresse wurde fälschlicherweise
  zu $6x00 optimiert, was natürlich wieder ein Long Branch ist.
o B<cc>.B wurde nicht als Short Branch erkannt, sondern nur B<cc>.S.
o Die CNOP Direktive verbot sämtliche Optimierungen in ihrer Section.
o Die 'Word at odd address'-Fehlermeldung ließ PhxAss manchmal abstürzen.
o INITNEAR funktionierte im Absoluten Modus überhaupt nicht.
@EndNode


@Node bugfixes3 "Beseitigte Bugs seit V3.00"
V3.01 (03.03.93)
o Die 68020 Adressierungart ([Rn]) wurde in Pass 1 mit einem anderen
  Speicherbedarf übersetzt als in Pass 2. Folge: Alle nachfolgenden Labels
  verschoben.

V3.02 (20.04.93)
o TRACKDISK scheint jetzt endlich fehlerlos zu sein.

V3.05 (30.05.93)
o Die Adressierungsraum für Near-Data Symbole wurde im fertigen Object
  Module fälschlicherweise auf 32k begrenzt.
o Formatierte Textausgaben sollten jetzt auch unter OS2.xx/OS3.xx klappen.
o MOVE USP,An , MOVES und MOVEP  erzeugten falschen Code.
o GLOBAL und BSS zerstörten die MSW-Bits im BSS Hunk-Typenfeld ($000003eb).

V3.10 (04.06.93)
o PhxAss wollte keine Oktalzahlen (@xxx) akzeptieren.

V3.11 (06.06.93)
o CNOP ist (hoffentlich) endgültig fehlerlos.
o CMPI #x,(PC) (>=68020)

V3.12 (08.06.93)
o Bitfeldbreite 32 war nicht möglich.

V3.15 (12.06.93)
o Fehler während MOVEM-Optimierung beseitigt.

V3.20 (03.07.93)
o Das "\\@"-Symbol besaß nach einer weiteren Makro-Verschachtelung innerhalb
  eines Makros einen falschen Wert.

V3.21 (05.07.93)
o Bisher ließ "\\@" nur 999 Makro-Aufrufe zu. Jetzt gibt es keine
  Limitierung mehr.

V3.22 (06.07.93)
o Probleme mit einigen erweiterten Adressierungsarten:
  ([..],Rn.s|*x,od) und ([PC..  wurden in Pass 1 mit einer anderen Größe
  übersetzt,  ([BaseDisp])  führte zu einer Fehlermeldung und  (bd,An/PC,Xn)
  (wobei bd mind. 16 Bit benötigt) führte zu einem Absturz.

V3.25 (17.07.93)
o Bug mit MOVES beseitigt.
o FETOXM1 habe ich völlig übersehen (mein Reference Manual allerdings auch).

V3.26 (18.07.93)
o TAB-Codes innerhalb von Strings wurden nicht richtig expandiert.

V3.30 (25.07.93)
o Weitere Fehler mit erweiterten Adressierungsarten ([..],Rn.x/*y,od),
  ([pc],.. und ([pc,Rn],..  beseitigt.

V3.31 (28.07.93)
o INITNEAR war im Small-Data Modus völlig nutzlos.

V3.40 (07.08.93)
o Include-Pfade die auf ':' endeten (z.B. Volume-Namen) wurden nicht
  erkannt.
o FMOVEM.L Dn,FPcr  war in Pass 1 vier Bytes länger als in Pass 2.
o Ab Seite 100 wurde das Listing File völlig unleserlich.
o Die 'Out of memory' Fehlermeldung war eigentlich überflüssig, da PhxAss
  bisher in solch einem Fall sowieso abstürzte.
o CPUSHL,CINVL,CPUSHP,CINVP funktionierten nicht.
o BTST Dn,#x hatte ich vergessen.

V3.42 (24.08.93)
o Die neue Vorwärts-Branch Optimierung zerstörte alle CNOP-Alignments, die
  sich zwischen der Branch-Instruktion und dem Sprungziel aufhielten.

V3.46 (02.09.93)
o PhxAss versuchte "MOVEP (d16,An)" mit d16=0 zu "MOVEP (An)" zu
  optimieren. Das war natürlich ein Bug!

V3.50 (15.09.93)
o Fehler mit dem '*'-Symbol, das die Adresse der aktuellen Zeile enthält,
  beseitigt.
o ".local" war für Fließkommasymbole nicht möglich.

V3.57 (22.09.93)
o PTESTR/PTESTW (68030) ignorierten ihren vierten Operanden.

V3.58 (23.09.93)
o NARG war bei einem Makro-Aufruf ohne Parameter nicht Null, wie es eigent-
  lich hätte seien sollen.
o INCLUDE/INCBIN ohne Anführungszeichen führten zu einer Fehlermeldung.

V3.61 (02.10.93)
o Auf IFC '\\1','' konnte man sich bisher nur verlassen, wenn \\1 vorher
  noch nicht benutzt wurde.

V3.64 (24.11.93)
o Die 16/32-Bit Displacements in der Adressierungsart 'PC Indirect with
  Index' waren um zwei Bytes verschoben.

V3.65 (10.12.93)
o Fehler bei der AbsLong->AbsShort und Logical Shifts Optimierung.

V3.70 (15.12.93)
o Fehler (d16,An,ZRn) und (bd,PC) beseitigt.
o PhxAss versuchte 'CMPI #x,AbsLong' immer zu PC-Relativ zu optimieren, was
  im 68000/010 Modus natürlich illegal ist.

V3.76 (07.04.94)
o Ein weiterer Fehler in der Vorwärts-Branch Optimierung (T-Schalter)
  brachte die Object Datei in einigen Spezialfällen vollkommen durch-
  einander.
o Bcc.B *+2 wird jetzt endlich in Bcc.W *+4 umgewandelt (statt *+2).

V3.77 (21.04.94)
o Mehr als 13 Sectionen in einem Quelltext führten entweder zu einem
  Absturz oder einer Endlosschleife.

V3.78 (27.04.94)
o Wenn PhxAss einen Fehler in einer Zeile >= 32768 entdeckte, wurde weder
  die fehlerhafte Zeile noch deren Zeilennummer ausgegeben (jetzt klappt es
  bis 65000).

V3.79 (01.05.94)
o Absolute Adressierung mit runden Klammern führte zu Fehlern.
  Z.B.: "move.w  label+(x+y)*z", aber "move.w  (x+y)*z+label" funktioniert.

V3.90 (16.09.94)
o Makro Argumente mit einem Komma (z.B. (d,An)) konnten nicht angewandt
  werden.

V3.93 (25.09.94)
o Ein ausdrücklicher B<cc>.L - Sprung wurde im 020+ Modus als zwei Bytes zu
  kurz und sonst als zwei Bytes zu weit bestimmt.

V3.94 (09.10.94)
o Der Code, der durch MOVE.B #-1,d0 (auch: cmp, and, or, eor, etc.) erzeugt
  wurde, war $103C $FFFF, obwohl die Bits 8-15 des ersten Extension-Words
  laut Motorola für eine Byte-Instruktion reserviert sind, also Null sein
  müssen. Jetzt erzeugt PhxAss $103C $00FF, wie es schon immer sein sollte.
o PhxAss änderte ein (d,PC,ZRn) in ein (d,ZPC,ZRn) um.

V3.96 (23.10.94)
o Wenn die Makro-Verschachtelungstiefe acht überstieg, gab es Abstürze.

V3.97 (01.11.94)
o Distanzen, die unter anderem aus einem Label bestanden der direkt nach
  einem CNOP folgte, waren manchmal falsch.
o Durch umgangreiche Geschwindigkeitsverbesserungen in 3.96 oder 3.95 konn-
  ten in diesen Versionen keine Makro-Argumente im Opcode benutzt werden.

V4.00 (26.12.94)
o Wenn eine bestimmte Anzahl von Include Dateien benötigt wurde stürzte
  PhxAss ab.
o Probleme beim automatischen Entfernen von leeren Sectionen.
o ELSEIF wird zwar in der Anleitung dokumentiert, war aber noch gar nicht
  eingebaut (wohl vergessen).

@EndNode


@Node bugfixes4 "Beseitigt Bugs seit V4.00"
V4.01 (07.01.95)
o Multiplikation hat jetzt eine niedrigere Priorität als Division/Modulo,
  um Situationen wie 12/4*3 = 1 zu verhindern.
  Ich weiß natürlich, daß '*', '/' und '//' eigentlich dieselbe Priorität
  haben müßten, doch momentan erlauben meine Ausdruck-Auswertungsroutinen
  nur eine bestimmte Priorität pro Operator. Wahrscheinlich werde ich
  diese Routinen demnächst einmal völlig neu schreiben müssen.

V4.05 (25.01.95)
o FreePhxAss erzeugte gar keine Object-Files!!! :(((  (böser Fehler)
o Der NOT-Operator (~) wirkt sich nur noch in der Datenbreite der
  aktuellen Instruktion aus. Somit erhält man bei "move.b #~$80,d0"
  keinen Error 97 mehr.
o Leere Sectionen, die beim Erzeugen der Object-Datei entfernt werden,
  hatten sämtliche XREFs der nachfolgenden Sectionen gelöscht.
o \\" und \\' innerhalb von Strings funktionierten noch nicht richtig.
o Bisher konnte man nur dann Makro-Parameter im Opcode-Feld verwenden,
  wenn man Großbuchstaben benutzt.

V4.10 (09.02.95)
o INCLUDE und INCBIN funktionierten nicht, wenn der Dateiname Leerzeichen
  enthielt.

V4.11 (21.02.95)
o CLI-Parameter mit numerischen Werten, z.B. "SMALLDATA x,y" führten jedes-
  mal zu einem Absturz. Dieser Fehler lag in den massiven Änderungen, die
  ich in V4.10 getätigt hatte, begründet.

V4.14 (19.03.95)
o Ab Fehler 89 waren die durch die Catalogs erzeugten Texte falsch.

V4.15 (30.04.95)
o Wenn der Quellcode kein einziges Byte enthält, konnte es vorkommen,
  daß PhxAss abstürzt.

V4.16 (13.05.95)
o Durch einige Verbesserungen in V4.15 funktionierte der @{"OPT" link params}-Parameter
  leider nicht mehr. :(

V4.17 (18.05.95)
o MOVE16 funktionierte nicht mit absoluten Adressen kleiner als $8000.

V4.18 (07.06.95)
o #'"' und #"'" funktionierten seit V4.15 nicht mehr.

V4.19 (27.06.95)
o Long-Branches, die der Programmierer explizit als Byte-Branches definiert
  hat wurden nur zu Word anstatt zu Long gemacht. Dies erzeugte dann einen
  Fehler in einer nachfolgenden Branch-Optimierung.
o Distance-Shifts funktionierten nicht mit Equaten (EQU).
o Distance-Shifts hatten im Listing-File einen falschen Wert.
o Hatte vergessen während des Clean-Ups zwei Mathe-Libraries zu schließen.

V4.20 (12.08.95)
o Adressierungsarten mit Scaling führen nun im 68000 Modus zu einer Feh-
  lermeldung.
o ASL wird jetzt bei @{"(n)ormaler Optimierung" link params} link zu ADD optimiert (wenn
  möglich).
o @{"\@" link macro} erzeugt jetzt '_000' Labels statt '000'. Dadurch gibt es keine
  Probleme beim Übersetzen von exec/types.i mehr.
o Es ist wieder möglich ein Object File zu erzeugen, welches nur aus
  absoluten @{"XDEFs" link xdef} besteht. Es war schonmal möglich - vor v4.00. ;)
o Symbole, die innerhalb von Makros mehrfach definiert wurden, erzeugten
  keine Fehlermeldung.
o Wenn im Small Data Modus die Data und BSS Sections beide leer sind,
  erzeugte PhxAss ein Object File mit 65535 Längenangaben im Hunk Header.

V4.21 (20.09.95)
o Bei d(xxx) oder (d,xxx) wurde xxx, wenn es kein Adressregister ist,
  einfach ignoriert. Jetzt erzeugt dies einen Syntax Error!
o Byte/Word-Range Check bei DC, DCB und BLK eingebaut.
o Statt 'Out of memory' wurde fälschlicherweise 'Shift error' erzeugt.

V4.22 (22.09.95)
o Seit v4.20 ist ein '+' vor einem Ausdruck erlaubt. Leider galt dies
  aber noch nicht für Fließkommaausdrücke.

V4.23 (03.10.95)
o Die Opcode-Extension wird viel strenger geprüft. Bisher war es z.B.
  möglich MOVE.P zu schreiben, woraufhin PhxAss ohne jede Warnung
  völlig falschen Code erzeugte. Außerdem werden Dinge wie z.B.
  SWAP Dn,Dm nicht weiter unterstützt... ;)
o Durch das genauere Prüfen der d(xxx)-Ausdrücke in V4.21 konnten keine
  Operanden der Form ea{x:y} mehr verwendet werden.

V4.24 (08.10.95)
o Der Domino-Effekt bei der FwdBranch-Optimierung (T) konnte in
  einigen fällen zu verschobenen Sprungzielen führen.

V4.25 (15.11.95)
o Symbole mit anderen Endungen als .W oder .L erzeugten seit v4.21 eine
  'Undefiniertes Symbol'-Fehlermeldung.
o Negative RORG-Offsets sind jetzt verboten.
o S-Optimierung  MOVE.x #0,An -> CLR.x An  verhindert.
o Fehler bei S-Optimierung  PEA 0.L -> CLR.L -(SP), verschob die nach-
  folgenden Symbole um zwei Bytes.
o OPT N hat jetzt absolute Priorität über OPT P. Dadurch kann MOVE.L #0,An
  trotz P-Optimierung zu SUBA.L An,An optimiert werden (statt LEA 0.w,An).
o Abstürze bei nicht-terminierten Strings, z.B. MOVE #"abc,<ea>.
o BF??? (d,An){x:y} funktionierte seit v4.21 nicht mehr.
o Fehlermeldung "Fehlerhafte Registerliste" bei FMOVEM.X label,<freglist>.
o DC.? "xxx" wird als Ausdruck anstatt als String behandelt, wenn "xxx"
  in den angegebenen Datentyp paßt. Dadurch ist z.B. DC.L "DOS"<<8
  wieder erlaubt.
o "Syntax Error" bei DC.? ("xxx") in Pass 1.
o FILE, TTL, SFORM erlauben jetzt auch Argumente ohne " oder ', wie
  bei INCLUDE oder INCBIN.

V4.30 (05.03.96)
o Die Forward-Branch Optimierung von B<cc>.L nach B<cc>.W funktionierte 
  nicht.
o FMOVEM.L <FPControlRegs> war in Pass 2 vier Bytes länger als in Pass 1.
o @{"DC.? '\'" link dc} verschob in Pass 1 alle nachfolgenden Labels um eine zu-
  fällige Anzahl Bytes.
o CMP #x,#y erzeugte keine Fehlermeldung.
o Die @{"MOVEC" link movec} Register MSP, ISP und MMUSR existieren auf einem 68060 über-
  haupt nicht.
o Der Kommandozeilenparameter @{"SET" link params} ließ nur dann mehrfache Definitionen,
  getrennt durch Komma, zu, wenn jedem Symbol mittels '=' ein bestimmter
  Wert zugewiesen wurde.
o Die PC-relativen 020+ Adressierungsarten beinhalten ein Format-Word
  direkt hinter dem Instruktions-Word und dürfen keine externen Symbole
  enthalten. Der Grund ist, daß alle Linker den Distanzwert relativ zu
  der Adresse berechnen, an der dieser eingesetzt werden soll. In diesem
  Fall müßte die Berechnung aber relativ zum Format-Word stattfinden. Da
  es hierfür keinen offiziellen Support gibt, bin ich gezwungen diese
  Adressierungsarten durch eine Fehlermeldung zu unterbinden.
o Die Adressierungsart (<xrefsym>.L,An) erzeugte fälschlicherweise eine
  Fehlermeldung.

V4.31 (27.03.96)
o Die Unterstüzung für die ASCII-Zeichen $c0-$fe in Symbolen funktionierte
  noch nicht einwandfrei. Es gab besonders dann Probleme, wenn ein Symbol
  mit solch einem Zeichen begann.
o ([xrefsym,PC],od) erzeugte falsche Informationen im HUNK_EXT-Block.
o MOVEM (An)+xxxx  wurde bisher ohne Fehlermeldung akzeptiert.

V4.32 (27.05.96)
o PhxAss erzeugte ein unnötiges Line Feed im Cross Reference Listing nach
  exakt sechs Referenzangaben.
o Bei aktivierter @{"DC-Align" link params} Option konnte ein Label, der sich in 
  derselben Zeile wie eine DC-Direktive befand, einen falschen Wert
  erhalten.
o Hex-, Binär- und Oktal-Konstanten ohne jede Ziffer erzeugten keine
  Fehlermeldung.
o PhxAss erzeugt eine Warnung, wenn eine @{"Near" link near} Adressierungsart sich
  außer Reichweite befindet und zudem 020+ Code-Generierung eingeschal-
  tet ist (im 68000/010-Modus würde es in dem Fall sowieso eine Fehler-
  meldung geben).

V4.33 (17.10.96)
o Negation der @{"Fließkommafunktionen" link expressions} war nicht möglich (z.B. -sin(x)).
o Endlosschleife bei @{"SECTION BSS_F" link section} oder unbekanntem Sections-Typ.
o "section blah,code,chip" und "section blah,code,fast" wurden nicht
  unterschieden, sondern zu einer Section mit den MemFlags der ersten
  Definition verschmolzen.
o @{"__RS" link set} erhielt fälschlicherweise immer den Wert des letzten Offsets,
  anstatt den des RS-Zählers.
o Generierung eines absoluten Files mit der @{"FILE" link file} Direktive funktio-
  nierte nicht mehr und produzierte einen Absturz. Der Bug existierte
  seit der Umstellung auf Buffered I/O in v4.31.
o Setzen neuer Optimierungs-Flags im Quelltext mit der @{"OPT" link opt} Direktive
  bewirkte nur ein Hinzufügen der Flags statt eine völlige Neu-
  definition.
o Weitere Probleme mit @{"CNOP" link cnop} behoben. Ein Short-Branch über eine CNOP-
  Direktive hinweg, konnte in einige Fällen außer Reichweite gelangen.
o Leere Sectionen, auf deren Anfangsadresse eine Referenz existiert,
  werden nun nicht mehr entfernt, sondern mit Länge 0 im Object- bzw.
  Load-File behalten.
o Laut Motorola's 6888x User's Manual sind nur .b, .w, .l und .s für
  FMOVE.? Dm,FPn bzw. FMOVE.? FPm,Dn erlaubt.         
o @{"IFD/IFND" link ifendc} funktionierte nicht, wenn das Symbol den Wert Null hat.
o Wenn @{"DS" link ds} die aktuelle Adresse automatisch gerade macht, so war die
  Adresse eines Labels in derselben Programmzeile davon nicht betroffen.
o Bitfield Instruktionen BFxxx <ea>{x:y} wurden mit einem Syntax Error
  quittiert, wenn die Adressierungsart Absolut-Short/Long war.

V4.34 (22.10.96)
o Distanzbildung mit Adressen aus DATA und BSS Sectionen, wobei Minuend
  und Subtrahend durch mindestens ein CNOP getrennt sind, funktionierte
  in v4.33 nicht mehr.
o PhxAss erlaubte innerhalb von Makros keine Zuweisung von Distanzen
  an ein Symbol, z.B.: 
  \\1 EQU *-label

V4.35 (11.02.97)
o Das "B<cc>.B *+0" Problem ist gelöst! Wenn dieser Fall von nun an
  durch Optimierungen auftreten sollte, wird stattdessen ein NOP
  in den Code eingefügt.
o <...> funktionierte nicht richtig.
o Der (hoffentlich letzte) große CNOP-Bug ist behoben. Die folgende
  Konstellation macht jetzt auch keine Probleme mehr:
  label1: cnop 0,4
  label2:
o Die Symbole __CPU, __FPU und __MMU waren undefiniert, solange keine
  MACHINE, FPU oder PMMU Direktive im Quelltext vorkam.
o Symbole im Operanden von Fließkomma-Instruktionen, die mit "FP"
  beginnen, führten zu Verwechselungen mit einem FPU-Register, was
  eine Fehlinterpretation der Adressierungsart in Pass 1 zur Folge hatte.
o Wenn der Name der Zieldatei einen '.' beinhaltete, so entfernte PhxAss
  immer alle Zeichen inklusive des '.', wenn er eine ausführbare Datei
  erzeugen konnte. Jetzt geschieht dies nur noch bei ".o"-Endungen.
o Seit V4.33 verlor PhxAss immer 48K Speicher, wenn eine PHXOPTIONS
  Datei vorhanden war.
o Lokale Labels mit den Namen ".W" und ".L" waren nicht möglich.
o Die Zuweisung eines externen Symbols mit der EQU Direktive führt nun
  zu einer Fehlermeldung. Bisher wurde kommentarlos eine Null zugewiesen.

V4.36 (01.06.97)
o Die @{"PUBLIC" link public} Direkive funktionierte nicht innerhalb eines Makros.
o @{"IFND" link ifendc} <external symbol> hatte den Nebeneffekt die Optimierung in allen
  anschließend definierten Sectionen zu verbieten.
o Die Zuweisung einer Adresse an ein globales Symbol mit @{"EQU" link equ} hatte den-
  selben Effekt wie die Definition eines globalen Labels und bewirkte das
  Ende der Gültigkeit eines lokalen Label-Blocks. Beispiel:
  start   bra     .l1
  symbol  equ     start
  .l1     rts
o Die Branch-Optimierung machte aus JMP *+6 ein BRA.W *+6 statt BRA.W *+4.
o PhxAss erzeugte kein Object File wenn der Quelltext keinen Code enthielt.
  Um Probleme mit Makefiles zu vermeiden, wird nun ein leeres Object File
  erzeugt.

V4.37 (01.12.97)
o Die Optimierung von CMPI.L #0,d(PC) nach TST.L d(PC) erzeugte ein
  falsches Displacement.
o Sporadischer Syntax Error bei @{"Fließkommaausdrücken" link expressions} mit Exponent.
o Manchmal Abstürze nach der Fehlermeldung "Word an ungerader Adresse"
  (word at odd address).
o @{"\+, \- and \." link macro} funktionierten innerhalb von Strings nicht.
o Große Probleme mit der @{"EQU" link equ} Direktive, sobald eine Adresse oder
  Adressdistanz zugewiesen wird, die sich in einer anderen Section
  befindet. Im ersten Fall wird eine falsche Relocation Information
  in die Zieldatei geschrieben, während im zweiten Fall die Distanz
  einen Falsch Wert bekommen konnte. Beispiel:
          code
  sym1    equ     sym2
          data
  sym2:   dc.l    0
o @{"SHOWOPT" link params} zeigte bei Optimierungen innerhalb von
  Makros immer "-56 bytes optimized" an.

V4.38 (07.06.98)
o Registersymbole wurden von IFD/IFND nicht erkannt, was zur Folge
  hatte, daß sie immer als 'undefiniert' behandelt wurde.
o Strengere Syntaxprüfung bei LSd/ASd/ROd <ea> und bei DS/DCB/BLK.
o Die Größe des Base Displacements in der 020+ Adressierungsart (bd,Rn,...)
  wird nun bereits in Pass 1 bestimmt, wodurch einige der seltsamen
  "Symbolverschiebungs-Bugs" in Pass 2 verschwunden sind.
o Wenn bei "do you want to continue (y/n)?" eine Funktions- oder Cursor-
  taste betätigt wird, verbleibt ein Zeichen im Eingabepuffer.
o Einige illegale Opcode-Extensions, wie z.B. "ÿ" erzeugten Systemabstürze.

V4.39 (17.11.98)
o Mehrere schlimme Bugs, Enforcer Hits und Abstürze (beim Benutzen
  lokaler Symbole z.B.) aus V4.38 wurden behoben. Diese Version war
  wirklich Müll. :)
o Bug in (Rn.s) Adressierungsarten (020+) behoben (V4.38 Bug).
o .x(Rn) und (.x,Rn) erzeugten im 020+ Modus einen Syntax Error. Die
  lokalen Symbole/Register wurden fälschlicherweise für Extensions
  gehalten (noch ein V4.38 Bug!).

@EndNode


@Node starting "PhxAss starten"
PhxAss kann nur von der Shell aus genutzt werden. Am besten kopieren Sie 
ihn nach "C:" oder definieren wenigstens einen Pfad oder Link. Wenn PhxAss 
häufiger benutzt wird, kann es durchaus von Vorteil sein, das Programm 
mittels "Resident PhxAss" resident im Speicher zu halten.
Aufruf:

Format:    PhxAss [FROM] <Quelltext> [TO <Zieldatei>] [OPT <opt Schalter>]
           [EQU <Equ File>] [LIST <List File>] [INCPATH {<Include Pfade>}]
           [HEADINC {<Incl. Dateien>}] [PAGE=<n>] [ERRORS=<n>]
           [ERRCODE=<n>] [SMALLDATA <basReg>,[<sec>]] [SMALLCODE] [LARGE]
           [VERBOSE] [SYMDEBUG] [LINEDEBUG] [ALIGN] [case] [XREFS] [QUIET]
           [NOWARN] [NOEXE] [MACHINE=<n>] [FPU=<n>] [PMMU] [BUFSIZE=<n>]
           [SHOWOPT] [PRI=<n>] [EXE] [GLOBHASHTAB=<n>] [LOCHASHTAB=<n>]
           [MNEMOHASHTAB=<n>] [ZEROPADDING]
           [SET "<Symbol>[=<n>][,<Symbol>...]"]

Schablone: FROM/A,TO/K,OPT/K,EQU/K,LIST/K,I=INCPATH/K,H=HEADINC/K,PAGE/K/N,
           ERRORS/K/N,RC=ERRCODE/K/N,SD=SMALLDATA/K,SC=SMALLCODE/S,LARGE/S,
           VERBOSE/S,DS=SYMDEBUG/S,DL=LINEDEBUG/S,A=ALIGN/S,C=CASE/S,
           XREFS/S,Q=QUIET/S,NOWARN/S,NOEXE/S,M=MACHINE/K/N,FPU/K/N,
           PMMU/S,BUFSIZE/K/N,SHOWOPT/S,PRI/K/N,EXE/S,GH=GLOBHASHTAB/K/N,
           LH=LOCHASHTAB/K/N,MH=MNEMOHASHTAB/K/N,Z=ZEROPADDING/S,SET/K

Wenn PhxAss ohne Parameter oder nur mit einem '?' aufgerufen wird, wird eine
Kurzbeschreibung der wichtigsten Argumente ausgegeben. Für eine genauere
Beschreibung sollten Sie in @{"CLI Parameter" link params} nachschlagen.

PhxAss kann durch Halten der Tasten CTRL-C jederzeit unterbrochen werden.

@EndNode


@Node params "CLI Parameter"
Die Standard Version von PhxAss versteht die folgenden Argumente:

FROM/A                  Der einzige Parameter der zwingend verlangt wird,
[FROM] <Quelltext>      ist der Name des zu Übersetzenden Quelltextes. Wenn
                        der angegebene Name keine Erweiterung besitzt, hängt
                        PhxAss automatisch ein ".asm" daran.
                        Der Quelltext muß ein ASCII Text, bei dem jede Zeile
                        durch ein Linefeed ($0a) abgeschlossen wird, sein
                        (das Format, daß normalerweise alle Amiga Editoren
                        erzeugen). TAB-Codes ($09) sind erlaubt und werden
                        auch unterstützt.

TO/K                    Bestimmt den Namen der Zieldatei. Wenn keiner an-
TO <Zieldatei/Verz.>     gegeben wird nimmt PhxAss den Quelltextnamen und
                        ersetzt seine Namenserweiterung durch ".o". Wenn es
                        PhxAss sogar möglich ist, eine ausführbare Datei
                        statt eines Object-Moduls zu erzeugen, wird das
                        ".o" wieder gestrichen. Seit v4.33 ist auch die
                        alleinige Angabe des Zielverzeichnisses erlaubt.

EQU/K                   Erzeugt ein Equates File. Wenn der <Dateiname> "*"
EQU <Dateiname>         ist, so wird der Name des Quelltextes, allerdings
                        mit ".equ" Namenserweiterung, verwendet. Seit V4.00
                        erscheinen im Equates File auch Fließkommasymbole.

LIST/K                  Erzeugt ein Listing File. Wenn der <Dateiname> "*"
LIST <Dateiname>        ist, so wird der Name des Quelltextes, allerdings
                        mit ".lst" Namenserweiterung, verwendet.

PAGE/K/N                Bestimmt die Seitenlänge für Equates- und Listing-
PAGE=<Zeilen>           Files. Wenn <Zeilen> gleich Null ist, werden keine
                        FF ($0c) Zeichen zum Seitenvorschub erzeugt. Der
                        voreingestellte Wert ist 60 Zeilen.

XREFS/S                 Hängt eine Referenztabelle aller im Quelltext be-
XREFS                   nutzten globalen Symbole an das Listing File an.
                        Wenn kein Listing File benutzt wurde, wird dieser
                        Schalter zu einer Fehlermeldung führen.

I=INCPATH/K             Definiert ein oder mehrere Include-Pfade, welche
I <Pfad1>[,<Pfad2>,...] dann von den Direktiven @{"INCLUDE" link include} und @{"INCBIN" link incbin}
                        benutzt werden. Diese Pfade werden dann benutzt,
                        wenn der Pfad der durch die Umgebungsvariable
                        PHXASSINC gegeben ist, zu keinem Erfolg führt.
                        Wichtig: Wenn die Pfad- oder Dateinamen hinter
                        INCPATH oder HEADINC Leerzeichen enthalten, sollte
                        man unbedingt *alle* Namen in Anführungszeichen ein-
                        betten, nicht nur den, der die Leerzeichen enthält.
                        Beispiel:
                        INCPATH "include:,dh1:inc dir"

H=HEADINC/K             Erzeugt eine oder mehrere INCLUDE Direktiven am An-
H <Inc1>[,<Inc2>,...]   fang des Quelltextes. Siehe auch: INCPATH.


DS=SYMDEBUG/S           Alle globalen Symbolnamen werden als Symbol Data
DS                      Blocks der Zieldatei hinzugefügt. Ein Debugger kann
                        diese Namen dann anstatt Adressen verwenden.

DL=LINEDEBUG/S          PhxAss erzeugt einen Linedebug Block, der einem
DL                      Source Level Debugger für jede Adresse im Code die
                        zugehörige Quelltextzeile nennt. Der Ort des Quell-
                        textes wird in diesem Block mit komplettem Pfad ge-
                        speichert, z.B. "Work:Programs/Assembler/Tools/
                        Source/Test.asm" (das ist zum Beispiel nicht der
                        Fall bei SAS's ASM :-).
                        Compiler sollten die Direktiven @{"DEBUG" link debug} und
                        @{"DSOURCE" link dsource} statt dieser Option verwenden.
                        Ein brauchbarer PD-Debugger mit Source Level Debug-
                        ging Fähigkeiten ist beispielsweise "PowerVisor
                        v1.42". Zu finden ist er im Aminet unter
                        dev/debug/pv142.lha oder auf der GoldFish-CD.

SD=SMALLDATA/K          Zwingt PhxAss dazu in allen Sectionen das Small Data
SD <basReg>,[<Sect>]    Modell zu verwenden. <basReg> (normal: 4) bestimmt
                        das Adressregister, welches ständig als Zeiger auf
                        die Small Data Section verwendet werden soll. Er-
                        laubt sind die Register A2-A6. <sec> ist die Nummer
                        der Section die im Small Data Modus adressiert wer-
                        den soll (voreingestellt ist -2).
                        Bei <sec> = -1 werden alle Data und Bss Sectionen
                        als eine große Small Data Section betrachtet.
                        Bei <sec> = -2 werden nur die Sectionen mit Namen
                        "__MERGED" zur Small Data Section hinzugenommen.

SC=SMALLCODE/S          Zwingt PhxAss das Small Code Modell zu vewenden, bei
SC                      dem alle JMP und JSR Instruktionen, die auf externe
                        (XREF) Symbole zugreifen, in PC-Relative 16-Bit
                        Sprünge umgewandelt werden.

LARGE/S                 Zwingt die Benutzung des Larg Code und Large Data
LARGE                   Modells für alle Sectionen. @{"NEAR" link near} Direktiven
                        im Quelltext werden dadurch ignoriert.

SET/K                   Ein Symbol wird mittels der @{"SET" link set} Direk-
SET "<Symbol>[=<Wert>]" tive vordefiniert. Wenn Sie mehrere Symbole definie-
                        ren wollen, müssen Sie sie durch ein Komma vonein-
                        ander trennen. Wenn <Wert> nicht angegeben ist, wird
                        der voreingestellte Wert '1' verwendet.
                        Die SET-Definitionen müssen immer von zwei Anfüh-
                        rungszeichen eingeschlossen sein (da ReadArgs()
                        sonst Probleme bekommt)!

A=ALIGN/S               Schaltet die automatische Ausrichtung für @{"DC.x" link dc}
A                       Direktiven ein. Alle DC.W,DC.L,etc. werden dadurch
                        auf Wortgrenzen ausgerichtet.

C=CASE/S                Schaltet die Unterscheidung von Groß/Kleinschreibung
C                       aus. Die Symbolnamen werden alle in Großbuchstaben
                        umgewandelt. PhxAss wird dadurch etwa 5% langsamer.

NOWARN/S                Schaltet die Ausgabe von Warnungen ab.

ERRORS/K/N              Bestimmt die Anzahl der Fehlermeldungen, die bis zur
ERRORS=<max Fehler>     nächsten "Fortfahren?"-Abfrage ausgegeben werden.
                        Wenn man <max errors> auf Null setzt, macht PhxAss
                        überhaupt gar keine Abfrage mahr.

RC=ERRCODE/K/N          Bestimmt den Return Code für die Shell der im Fall
RC=<rc>                 eines Übersetzungsfehlers übergeben wird. Normaler-
                        weise ist dies 20.

VERBOSE/S               Alle Include-Dateien und Makros, die während des
VERBOSE                 Übersetzungsvorgangs aufgerufen werden, werden nach
                        Verschachtelungstiefe eingerückt ausgegeben. Das
                        kann z.B. recht hilfreich sein, wenn man Fehler mit
                        Makros lokalisieren will.

Q=QUIET/S               Durch diesen Schalter macht PhxAss keine Ausgaben,
Q                       außer es kommt zu einem Fehler.

NOEXE/S                 PhxAss versucht normalerweise immer ein ausführbares
NOEXE                   Load File, statt eines Object Moduls, welches danach
                        noch einen Linker benötigen würde, zu erzeugen.
                        Durch NOEXE wird PhxAss dazu gezwungen in jedem Fall
                        ein Object Modul zu generieren.

M=MACHINE/K/N           Wie bereits mit der "MACHINE" Direktive, so läßt
M=<cpu>                 sich auch hiermit wählen, für welche CPU der Code
                        erzeugt werden soll.
                        Einziger Unterschied: Neben 68000 ... 68060, sind
                        auch die Ziffern 0,1,2,3,4,6 erlaubt.

FPU/K/N                 Bestimmt, ob FPU-Instruktionen erlaubt sind (siehe
FPU=<fpuid>             auch: @{"FPU" link fpu} Directive).

PMMU/S                  68851 PMMU Instruktionen werden verwendet (siehe
PMMU                    auch: @{"PMMU" link pmmu} Directive).

BUFSIZE/K/N             Ändert die Größe des Puffers, der für Buffered
BUFSIZE=<Größe>         I/O verwendet wird. Die Standarteinstellung
                        ist 8192 Bytes.

GH=GLOBHASHTAB/K/N      Größe der Hashcode-Tabelle für globale Symbole
GH=<Größe>              als Zweierpotenz im Bereich von 2^8 bis 2^16.
                        Standartgröße ist 2^12 = 4096 Einträge.

LH=LOCHASHTAB/K/N       Größe der Hashcode-Tabelle für lokale Symbole
LH=<Größe>              als Zweierpotenz im Bereich von 2^2 bis 2^10.
                        Standartgröße ist 2^4 = 16 Einträge.

MH=MNEMOHASHTAB/K/N     Größe der Hashcode-Tabelle für Mnemonics als
MH=<Größe>              Zweierpotenz im Bereich von 2^6 bis 2^16.
                        Standartgröße ist 2^10 = 1024 Einträge.

SHOWOPT/S               Anzeigen sämtlicher optimierten Quelltextzeilen,
SHOWOPT                 zusammen mit der Anzahl der gewonnen Bytes.

PRI/K/N                 Bestimmt die Prozess-Priorität, die PhxAss
PRI=<Priorität>         während des Übersetzens besitzt. Sinnvolle Werte
                        liegen zwischen -10 und 10.

EXE/S                   Solange keine externen Referenzen oder ein expli-
EXE                     zites NOEXE/S vorhanden ist, versucht PhxAss immer
                        ein Load File zu erzeugen. Mit EXE/S tut er dies
                        sogar dann, wenn XDEFs im Quelltext vorkommen.

Z=ZEROPADDING/S         Hierdurch wird grundsätzlich bei CNOP mit Null-
Z                       Bytes aufgefüllt, statt mit NOP-Instruktionen.

OPT/K                   Setzt die Optimierungs-Schalter. Folgende Schalter
OPT <flags>             können, ohne daß sie durch Leerzeichen getrennt wer-
                        den, hinter OPT angegeben werden:

                        0 (None)
                           Optimierung ist verboten. Dieser Schalter sollte
                           nur einzeln auftreten.

                        N (Normal)
                           Standard Optimierungen:
                           clr.l Dn          ->  moveq #0,Dn
                           move.l #x,Dn      ->  moveq #x,Dn
                           move.l #0,An      ->  suba.l An,An
                           move.l #xxxx,An   ->  move.w #xx,An
                           link.l(68020)     ->  link.w
                           adda/suba         ->  lea
                           ($xxxx).L         ->  ($xx).W
                           (0,An)            ->  (An)
                           asl #1,Dn         ->  add Dn,Dn
                           asl.w/b #2,Dn     ->  add Dn,Dn  add Dn,Dn
                           addi/subi/cmpi #0 ->  tst
                           cmpa #0,An(68020) ->  tst An
                           sf                ->  clr.b

                        R (Relativ)
                           ($xxxx)  ->  (xx,PC)

                        Q (Quick)
                           Konvertierungen nach addq/subq

                        B (Branchoptimierung)
                           Bcc.l(020) -> Bcc.w -> Bcc.b, jmp/jsr -> bra/bsr
                           Bcc.w(000/010) -> B!cc.b, jmp
                           Beispiel:
                                        beq.w   label
                           wird konvertiert in ->
                                        bne.b   *+8
                                        jmp     label
                           falls label weiter als 32766 Bytes entfernt ist.

                        T (Totale Branch Optimierung)
                           Bcc.l(020) -> Bcc.w -> Bcc.b (Vorwärts Branches)
                           Ist nur aktiv wenn 'B' auch gewählt wurde.
                           WARNUNG! Wenn diese Optimierung zusammen mit
                           einem Listing File benutzt wird, ist auf die
                           Zeilenadressen darin leider kein großer Verlaß
                           mehr, da sich diese nachträglich alle verschie-
                           ben können.

                        L (Logische Shifts)
                           lsl #1,Dn  ->  add Dn,Dn
                           lsl.w/b #2,Dn  ->  add Dn,Dn + add Dn,Dn

                        P (PEA/LEA Konvertierung)
                           move.l #x,An    -> lea x,An
                                           -> lea (x,PC),An / lea x.w,An
                           move.l #x,-(SP) -> pea x  -> pea (x,PC) / pea x.w

                        S (Spezielle Optimierungen)
                           pea 0                         ->  clr.l -(SP)
                           add/sub #0,An / lea (0,An),An ->  (gelöscht)
                            Bcc lab                      ->  (gelöscht)
                           lab:
                           (d,An,ZRn)                    ->  (d,An) -> (An)
                           (d,PC,ZRn)                    ->  (d,PC)
                           Die folgenden sind für einen 68000, der direkt
                           auf Hardwareregs. zugreift, nicht zu empfehlen:
                           move #0,<ea>                   ->  clr <ea>
                           move.b #-1,<ea>                ->  st <ea>

                        M (MOVEM/FMOVEM leere Registerliste)
                           movem ,<ea>  / movem <ea>,   ->  (gelöscht)
                           fmovem ,<ea> / fmovem <ea>,  ->  (gelöscht)

                        D (MOVEM einzelnes Register) seit v4.30
                           movem  ->  move
                           Vorsicht! Diese Optimierung beeinflußt die Con-
                           dition Codes und kann nur gemeinsam mit der M-
                           Optimierung verwendet werden.

                        I (Ignoriere zu große Distanzen)
                           Distanzen, die sich nicht in Reichweite befinden
                           erzeugen keinen Fehler. Das kann z.B. beim Über-
                           setzen eines Reassembler-Outputs nützlich sein,
                           oder wenn mach sicher ist, daß die Distanz durch
                           Optimierung des nachfolgenden Codes wieder in den
                           korrekten Bereich zurückkehrt.
                           Aber VORSICHT!!! Wenn die Distanz *nicht* opti-
                           miert werden kann, erzeugt PhxAss natürlich völ-
                           lig falschen Code.


                        Wenn das Schlüsselwort OPT nicht angegeben wurde,
                        benutzt der Assembler die standard Optimierungen
                        OPT nrqb.


                        Es folgen einige Abkürzungen für die gebräuch-
                        lichsten Optimierungen:

                        OPT *   =   OPT nrqbt (Standard + T)
                        OPT !   =   OPT nrqbtlpsmd (Alle Optimierungen)

                        Seit v4.30:
                        OPT 1   =   OPT nrqb (Standard)
                        OPT 2   =   OPT nrqbt (Standard + T)
                        OPT 3   =   OPT nrqbtlpsmd (Alle Optimierungen)
@EndNode


@Node prginfo "Programmierer Info"

                        @{"        Kommentare       " link comments}
                        @{"  Sprungmarken (Labels)  " link labels}
                        @{"   M68000 Instruktionen  " link m68000}
                        @{"        Ausdrücke        " link expressions}
                        @{"   Assembler Direktiven  " link directives}
                        @{" Compiler Kompatibilität " link compiler}
                        @{"         PhxOpts         " link phxopts}
                        @{"  Environment Variablen  " link envvars}
@EndNode


@Node comments "Kommentare"
Kommentare werden durch ein ';' oder ein '*' eingeleitet.

Beispiele:

; Kommentartext
        moveq   #0,d0
** Dies ist ebenfalls ein Kommentar **
        nop                             ; Kommentar
        add.l   d0,d0                   * und noch ein Kommentar


Wenn kein Operandenfeld existiert, z.B. nach einer NOP Instruktion, *muß*
der Kommentar durch ein ';' eingeleitet werden. Beispiele:

        nop     * comment               -> Fehler!
        nop     comment                 -> Fehler!

@EndNode


@Node labels "Sprungmarken (Labels)"
Labels müssen in der ersten Spalte einer Zeile beginnen. Der Doppelpunkt
hinter dem Label ist optional. Bei fehlendem Doppelpunkt muß mindestens
ein Leerzeichen oder TAB zwischen Label und Opcode stehen.

Beispiel:
         Label:   moveq   #0,d0

Lokale Labels werden entweder durch ein '$' abgeschlossen oder beginnen mit
einem '.' (seit V3.30). Sie sind nur im Bereich zwischen zwei globalen
Labels gültig.

Beispiel:
         Global1: add.w    d0,d1
                  beq.s    local1$
                  bpl.s    .local2
                  rts
         local1$: moveq    #-1,d0
         .local2: rts
         Global2: lea      Global1/.local2,a0

Lokale Symbole innerhalb eines fremden Blocks können wie hier im Beispiel
mit "Global1/.local2" angesprochen werden (seit V4.39).

Die Länge der globalen und lokalen Labels ist unbegrenzt. Es folgen die
gültigen Zeichen für Labels:
'a' - 'z'
'A' - 'Z' 
'0' - '9'
'_'
Seit V4.15:
'.'
Seit V4.30:
'À' - 'Ö' (192 - 214)
'Ø' - 'ö' (216 - 246)
'ø' - 'þ' (248 - 254, 255 wird intern benötigt)

'%' und '$' sind nur innerhalb eines Labels erlaubt (V4.32).

Das erste Zeichen darf auch ein '@' sein (unter der Vorraussetzung, daß 
das zweite Zeichen keine Ziffer ist) sein. Globale Labels dürfen nicht 
mit einer Ziffer beginnen.

Das spezielle Symbol '*' enthält immer die Adresse der aktuellen Quelltext
Zeile. Dadurch werden Anweisungen wie z.B. "bra *+4" möglich.

VORSICHT! Vorwärtsreferenzen auf '*' werden von PhxAss bei einer Optimierung
korrigiert, Rückwärtsreferenzen hingegen nicht! Um wirklich sicher zu sein,
sollte man sowieso immer Labels verwenden.
@EndNode


@Node m68000 "Ausführbare M68000 Instruktionen"

                        @{"       Instruktionsformat      " link genformat}
                        @{"  Standard Adressierungsarten  " link stdaddr}
                        @{" Erweiterte Adressierungsarten " link extaddr}
                        @{"  Unterdrückte Register (020+) " link zeroregs}
                        @{"  M68000 Instruktionsüberblick " link instroverview}
@EndNode

@Node genformat "Instruktionsformat"
Eine Assembler Quelltextzeile hat üblicherweise das Format:

<Label>     <Opcode>    <Operanden>

Phxass erkennt alle Operationen aus Motorolas M68000PM/AD Programmer's Refe-
rence Manual sowie alle gebräuchlichen Abkürzungen wie BHS statt BCC, BLO
statt BCS, MOVE statt MOVEA, ADD statt ADDI, usw. . In der vorliegenden
Version werden alle MC68000,68010,68020,68030,68040,68060,68851,68881 und
68882 Instruktionen vollständig unterstützt.

Labels müssen unbedingt mit der ersten Spalte einer Zeile beginnen. Opcodes
(M68000 Instruktionen sowie Assembler Direktiven) müssen durch wenigstens
ein Leerzeichen eingeleitet werden.

Das Operandenfeld kann aus bis zu vier (beim 68851) Operanden bestehen, die
durch Kommas getrennt werden. Seit V4.10 darf das Operandenfeld auch Leer-
zeichen enthalten.
@EndNode

@Node stdaddr "M68000 Standard Adressierungsarten"
Bedeutung, der in diesem Abschnit verwendeten Abkürzungen:
   EA       - Effektive Adresse
   An       - Adressregister n
   Dn       - Datenregister n
   Xn.SIZE  - Bezeichnet Indexregister n (Data- oder Adressreg.) und sein
              Format (W für Wort oder L für Langwort)
   PC       - Programmzähler (Program Counter)
   dn       - Displacement (Verschiebung), mit n Bits Breite
   ( )      - Identifiziert eine indirekte Adresse in einem Register


 Data Register Direct
 (Datenregister Direkt)
Syntax:           Dn
Generation:       EA = Dn
Extension Words:  0

 Address Register Direct
 (Adressregister Direkt)
Syntax:           An
Generation:       EA = An
Extension Words:  0

 Address Register Indirect
 (Adressregister Indirekt)
Syntax:           (An)
Generation:       EA = (An)
Extension Words:  0

 Address Register Indirect with Postincrement
 (Adressregister Indirekt mit nachfolgender Inkrementierung)
Syntax:           (An)+
Generation:       EA = (An), An = An + SIZE
Extension Words:  0

 Address Register Indirect with Predecrement
 (Adressregisrer Indirekt mit vorausgehender Dekrementierung)
Syntax:           -(An)
Generation:       An = An - SIZE, EA = (An)
Extension Words:  0

 Address Register Indirect with Displacement (16-Bit)
 (Adressregister Indirekt mit 16-Bit Verschiebung)
Syntax:           (d16,An)  or  d16(An)
Generation:       EA = (An) + d16
Extension Words:  1

 Address Register Indirect with Index (8-Bit Displacement)
 (Adressregister Indirekt mit Index und 8-Bit Verschiebung)
Syntax:           (d8,An,Xn.SIZE)  or  d8(An,Xn.SIZE)
Generation:       EA = (An) + (Xn) + d8
Extension Words:  1

 Program Counter Indirect with Displacement (16-Bit)
 (Programmzähler Indirekt mit 16-Bit Verschiebung)
Syntax:           (d16,PC)  or  d16(PC)
Generation:       EA = (PC) + d16
Extension Words:  1

 Program Counter Indirect with Index (8-Bit Displacement)
 (Programmzähler Indirekt mit Index und 8-Bit Verschiebung)
Syntax:           (d8,PC,Xn.SIZE)  or  d8(PC,Xn.SIZE)
Generation:       EA = (PC) + (Xn) + d8
Extension Words:  1

 Absolute Short Addressing
 (Absolute 16-Bit Adressierung)
Syntax:           (xxx).W  or  xxx.W
Generation:       EA bereits gegeben
Extension Words:  1

 Absolute Long Addressing
 (Absolute 32-Bit Adressierung)
Syntax:           (xxx).L  or  xxx.L
Generation:       EA bereits gegeben
Extension Words:  2

 Immediate Data
 (Unmittelbare Adressierung)
Syntax:           #xxx
Generation:       Operand gegeben
Extension Words:  1 or 2
@EndNode

@Node extaddr "68020+ Erweiterte Adressierungsarten"
Bedeutung, der in diesem Abschnit verwendeten Abkürzungen:
   EA             - Effektive Adresse
   An             - Adressregister n
   Dn             - Datenregister n
   Xn.SIZE*SCALE  - Bezeichnet Indexregister n (Data- oder Adressreg.), sein
                    Format (W für Wort oder L für Langwort) und den Faktor
                    mit dem der Index multipliziert wird (1, 2, 4 oder 8).
   PC             - Programmzähler (Program counter)
   dn             - Displacement (Verschiebung), mit n Bits Breite
   bd             - Basis Displacement (base displacement)
   od             - Äußeres Displacement (outer displacement)
   ( )            - Identifiziert eine indirekte Adresse in einem Register
   [ ]            - Identifiziert eine indirekte Adresse im Speicher


 Address Register Indirect with Index
 (Adressregister Indirekt mit Index, Erweiterung des Standardformats)
Syntax:           (d8,An,Xn.SIZE*SCALE)
Generation:       EA = (An) + (Xn)*SCALE + d8
Extension Words:  1

 Address Register Indirect with Index and Base Displacement
 (Adressregister Indirekt mit Index und Basis Verschiebung)
Syntax:           (bd,An,Xn.SIZE*SCALE)
Generation:       EA = (An) + (Xn)*SCALE + bd
Extension Words:  1, 2 or 3

 Memory Indirect Postindexed
 (Speicher Indirekt mit nachfolgender Indizierung)
Syntax:           ([bd,An],Xn.SIZE*SCALE,od)
Generation:       EA = (bd + An) + Xn.SIZE*SCALE + od
Extension Words:  1, 2, 3, 4 or 5

 Memory Indirect Preindexed
 (Speicher Indirekt mit vorausgehender Indizierung)
Syntax:           ([bd,An,Xn.SIZE*SCALE],od)
Generation:       EA = (bd + An + Xn.SIZE*SCALE) + od
Extension Words:  1, 2, 3, 4 or 5

 Program Counter Indirect with Index
 (Programmzähler Indirekt mit Index, Erweiterung des Standardformats)
Syntax:           (d8,PC,Xn.SIZE*SCALE)
Generation:       EA = (PC) + (Xn)*SCALE + d8
Extension Words:  1

 Program Counter Indirect with Index and Base Displacement
 (Programmzähler Indirekt mit Index und Basis Verschiebung)
Syntax:           (bd,PC,Xn.SIZE*SCALE)
Generation:       EA = (PC) + (Xn)*SCALE + bd
Extension Words:  1, 2 or 3

 Program Counter Memory Indirect Postindexed
 (Programmzähler Speicher Indirekt mit nachfolgender Indizierung)
Syntax:           ([bd,PC],Xn.SIZE*SCALE,od)
Generation:       EA = (bd + PC) + Xn.SIZE*SCALE + od
Extension Words:  1, 2, 3, 4 or 5

 Program Counter Memory Indirect Preindexed
 (Programmzähler Speicher Indirekt mit vorausgehender Indizierung)
Syntax:           ([bd,PC,Xn.SIZE*SCALE],od)
Generation:       EA = (bd + An + Xn.SIZE*SCALE) + od
Extension Words:  1, 2, 3, 4 or 5


Die erweiterten Adressierungsarten haben ein paar Mehrdeutigtkeiten:
Z.B. würde (0,A0) gewöhnlich zu (A0) (ein Wort) optimiert, aber vielleicht
möchten Sie gerne, daß die Null ein 32-Bit Displacement ist, und außerdem
noch ein unterdrücktes D7 Register? Diese Instruktion würde dann genau die-
selben Auswirkungen haben, wenn sie ausgeführt wird, allerdings benötigt sie
acht Worte im Speicher, statt nur einem.
Seit PhxAss V3.70 muß man, um dies zu erreichen, nur "(0.L,A0,ZD7)"
schreiben.
@EndNode


@Node zeroregs "Unterdrückte 68020+ Register"
Die 'Memory Indirect Post/Preindexed' Adressierungsarten ermöglichen es
dem Programmierer praktisch alles zu unterdrücken. Das bedeutet, daß man
sich zum Beispiel aus dem in Reference Manuals angegebenem Standardformat
([bd,An,Xn.SIZE*SCALE],od) die folgenden Adressierungsarten bauen kann:
o  ([bd,An,Xn.SIZE*SCALE])
o  ([An,Xn.SIZE*SCALE],od)
o  ([bd],od)
o  ([An])
o  ([Xn.SIZE*SCALE])
o  ([An],od)
usw...

Um das unterdrückte Register genau zu spezifizieren, können die Zero-
Register Symbole ZRn, ZPC verwendet werden. Durch den Einsatz dieser
Zero-Register sowie der Displacement-Extensions '.W' und '.L' kann wirk-
lich jede 68020 Instruktion erzeugt werden (hilfreich für Reassembler).
Durch eine .W/.L Extension am ersten Displacement wechselt PhxAss automa-
tisch in den 020+ Base-Displacement Modus und schaltet die Optimierung
für die aktuelle Instruktion ab.

Die unterdrückten Register werden durch die folgenden Symbole repräsen-
tiert:
o Unterdrücktes Datenregister D0-D7: ZD0-ZD7
o Unterdrücktes Adressregister A0-A7: ZA0-ZA7
o Unterdrückter PC: ZPC

Unterdrückte Register können nicht, durch EQUR, einem Symbol zugewiesen
werden.
@EndNode


@Node instroverview "M68000 Instruktionsüberblick"

              @{"   Integer Instruktionen für alle Prozessoren   " link inti_all}
              @{" Integer Instruktionen für 010,020,030,040,060  " link inti_010}
              @{"   Integer Instruktionen für 020,030,040,060    " link inti_020}
              @{"        Integer Instruktionen für 040,060       " link inti_040}
              @{"         Integer Instruktionen für 68060        " link inti_060}
              @{"             MOVEC Kontrollregister             " link movec}
              @{"     Fließkommainstruktionen 881,882,040,060    " link intfpu}
              @{"        040/060er Fließkommainstruktionen       " link intfpu040}
              @{"             68851 PMMU Instruktionen           " link pmmu851}
              @{"             68030 PMMU Instruktionen           " link pmmu030}
              @{"           68040/060 PMMU Instruktionen         " link pmmu040}
@EndNode

@Node inti_all "Integer Instruktionen (68000,68010,68020,68030,68040,68060)"
ABCD        Dy,Dx                      Add Decimal with Extend
ABCD        -(Ay),-(Ax)
ADD.x       <ea>,Dn                    Add
ADD.x       Dn,<ea>
ADDA.x      <ea>,An                    Add Address
ADDI.x      #<data>,<ea>               Add Immediate
ADDQ.x      #<data>,<ea>               Add Quick
ADDX.x      Dy,Dx                      Add Extended
ADDX.x      -(Ay),-(Ax)
AND.x       <ea>,Dn                    And Logical
AND.x       Dn,<ea>
ANDI.x      #<data>,<ea>               And Immediate
ANDI.x      #<data>,CCR                And Immediate to Condition Codes
ANDI.x      #<data>,SR                 And Immediate to the Status Register
ASL/ASR.x   Dx,Dy                      Arithmetic Shift Left/Right
ASL/ASR.x   #<data>,Dy
ASL/ASR     <ea>
B<cc>.x     <label>                    Branch Conditionally
BCHG        Dn,<ea>                    Test a Bit and Change
BCHG        #<data>,<ea>
BCLR        Dn,<ea>                    Test a Bit and Clear
BCLR        #<data>,<ea>
BRA.x       <label>                    Branch Always
BSET        Dn,<ea>                    Test a Bit and Set
BSET        #<data>,<ea>
BSR.x       <label>                    Branch to Subroutine
BTST.x      Dn,<ea>                    Test a Bit
BTST.x      #<data>,<ea>
CHK.x       <ea>,Dn                    Check Register Against Bounds
CLR.x       <ea>                       Clear an Operand
CMP.x       <ea>,Dn                    Compare
CMPA.x      <ea>,An                    Compare Address
CMPI.x      #<data>,<ea>               Compare Immediate
CMPM.x      (Ay)+,(Ax)+                Compare Memory
DB<cc>      Dn,<label>                 Test Condition, Decrement, and Branch
DIVS        <ea>,Dn                    Signed Divide
DIVU        <ea>,Dn                    Unsigned Divide
EOR.x       Dn,<ea>                    Exclusive-OR Logical
EORI.x      #<data>,<ea>               Exclusive-OR Immediate
EORI.x      #<data>,CCR                Exclusive-OR Immediate to Cond. Codes
EORI.x      #<data>,SR                 Exclusive-OR Immediate to Status Reg.
EXG         Rn,Rm                      Exchange Registers
EXT.x       Dn                         Sign Extend
ILLEGAL                                Take Illegal Instruction Trap
JMP         <ea>                       Jump
JSR         <ea>                       Jump to Subroutine
LEA         <ea>,An                    Load Effective Address
LINK        An,#<displacement>         Link and Allocate
LSL/LSR.x   Dx,Dy                      Logical Shift Left/Right
LSL/LSR.x   #<data>,Dy
LSL/LSR     <ea>
MOVE.x      <ea>,<ea>                  Move Data from Source to Destination
MOVEA.x     <ea>,An                    Move Address
MOVE        <ea>,CCR                   Move to Condition Codes
MOVE        <ea>,SR                    Move to the Status Register
MOVE        SR,<ea>                    Move from Status Register
MOVE        USP,An                     Move User Stack Pointer
MOVE        An,USP
MOVEM.x     <register list>,<ea>       Move Multiple Registers
MOVEM.x     <ea>,<register list>
MOVEP.x     Dx,(d,Ay)                  Move Peripheral Data (nicht 68060!)
MOVEP.x     (d,Ay),Dx
MOVEQ       #<data>,Dn                 Move Quick
MULS        <ea>,Dn                    Signed Multiply
MULU        <ea>,Dn                    Unsigned Multiply
NBCD        <ea>                       Negate Decimal with Extend
NEG.x       <ea>                       Negate
NEGX.x      <ea>                       Negate with Extend
NOP                                    No Operation
NOT.x       <ea>                       Logical Complement
OR.x        <ea>,Dn                    Inclusive-OR Logical
OR.x        Dn,<ea>
ORI.x       #<data>,<ea>               Inclusive-OR Immediate
ORI.x       #<data>,CCR                Inclusive-OR Immediate to Cond. Codes
PEA         <ea>                       Push Effective Address
RESET                                  Reset External Devices
ROL/ROR.x   Dx,Dy                      Rotate (without Extend) Left/Right
ROL/ROR.x   #<data>,Dy
ROL/ROR     <ea>
ROXL/ROXR.x Dx,Dy                      Rotate Left/Right with Extend
ROXL/ROXR.x #<data>,Dy
ROXL/ROXR   <ea>
RTE                                    Return from Exception
RTR                                    Return and Restore Condition Codes
RTS                                    Return from Subroutine
SBCD        Dx,Dy                      Subtract Decimal with Extend
SBCD        -(Ax),-(Ay)
S<cc>       <ea>                       Set According to Condition
STOP        #<data>                    Load Status Register and Stop
SUB.x       <ea>,Dn                    Subtract
SUB.x       Dn,<ea>
SUBA.x      <ea>,An                    Subtract Address
SUBI.x      #<data>,<ea>               Subtract Immediate
SUBQ.x      #<data>,<ea>               Subtract Quick
SUBX.x      Dx,Dy                      Subtract with Extend
SWAP        Dn                         Swap Register Halves
TAS         <ea>                       Test and Set an Operand
TRAP        #<vector>                  Take Trap Exception
TRAPV                                  Trap on Overflow
TST.x       <ea>                       Test an Operand
UNLK        An                         Unlink

Integer Condition Codes <cc>:
CC (HS)  carry clear (higher or same)  CS (LO)  carry set (lower)
EQ       equal                         F        never true
GE       greater or equal              GT       greater than
HI       higher                        LE       less or equal
LS       less or same                  LT       less than
MI       negative                      NE       not equal
PL       positive                      T        always true
VC       overflow clear                VS       overflow set
@EndNode

@Node inti_010 "Integer Instruktionen (68010,68020,68030,68040,68060)"
BKPT        #<data>                    Breakpoint
MOVE        CCR,<ea>                   Move from the Condition Code Register
MOVEC       Rc,Rn                      Move Control Registers
MOVEC       Rn,Rc
MOVES       Rn,<ea>                    Move Address Space
MOVES       <ea>,Rn
RTD         #<displacement>            Return and Deallocate
@EndNode

@Node inti_020 "Integer Instruktionen (68020,68030,68040,68060)"
BFCHG       <ea>{offset:width}         Test Bit Field and Change
BFCLR       <ea>{offset:width}         Test Bit Field and Clear
BFEXTS      <ea>{offset:width},Dn      Extract Bit Field Signed
BFEXTU      <ea>{offset:width},Dn      Extract Bit Field Unsigned
BFFFO       <ea>{offset:width},Dn      Find First One in Bit Field
BFINS       Dn,<ea>{offset:width}      Insert Bit Field
BFSET       <ea>{offset:width}         Test Bit Field and Set
BFTST       <ea>{offset:width}         Test Bit Field
CALLM       #<data>,<ea>               Call Module (nur 68020!)
CAS.x       Dc,Du,<ea>                 Compare and Swap with Operand
CAS2.x      Dc1:Dc2,Du1:Du2,(Rn1):(Rn2) (nur 020-040!)
CHK2.x      <ea>,Rn  (nur 020-040!)    Check Register Against Bounds
CMP2.x      <ea>,Rn  (nur 020-040!)    Compare Register Against Bounds
DIVS.L      <ea>,Dq                    Signed Divide
DIVS.L      <ea>,Dr:Dq  (nur 020-040!)
DIVSL.L     <ea>,Dr:Dq
DIVU.L      <ea>,Dq                    Unsigned Divide
DIVU.L      <ea>,Dr:Dq  (nur 020-040!)
DIVUL.L     <ea>,Dr:Dq
EXTB.L      Dn                         Sign Extend
LINK.L      An,#<displacement>         Link and Allocate
MULS.L      <ea>,Dl                    Signed Multiply
MULS.L      <ea>,Dh:Dl
MULU.L      <ea>,Dl                    Unsigned Multiply
MULU.L      <ea>,Dh:Dl
PACK        -(Ax),-(Ay),#<adjustment>  Pack BCD
PACK        Dx,Dy,#<adjustment>
RTM         Rn                         Return from Module (nur 68020!)
TRAP<cc>                               Trap on Condition
TRAP<cc>.x  #<data>
UNPK        -(Ax),-(Ay),#<adjustment>  Unpack BCD
UNPK        Dx,Dy,#<adjustment>
@EndNode

@Node inti_040 "Integer Instruktionen (68040,68060)"
CINVL       <caches>,(An)              Invalidate Cache Lines
CINVP       <caches>,(An)              (<caches> = DC, IC, BC or NC)
CINVA       <caches>
CPUSHL      <caches>,(An)              Push and Invalidate Cache Lines
CPUSHP      <caches>,(An)
CPUSHA      <caches>
MOVE16      (Ax)+,(Ay)+                Move 16 Bytes Block
MOVE16      xxx.L,(An)
MOVE16      xxx.L,(An)+
MOVE16      (An),xxx.L
MOVE16      (An)+,xxx.L
@EndNode

@Node inti_060 "Integer Instruktionen (68060)"
LPSTOP      #x                         Low-Power Stop
HALT                                   Processor halted
PULSE                                  Send $14 pulse on PSTx

Die Integer Instruktionen, die vom 68060 nicht direkt unterstützt
werden, wie DIVUL, DIVSL, CAS2, CHK2, CMP2, MOVEP, werden trotzdem
übersetzt, da sie meines Wissens durch die "68060.library" emuliert
werden (so hoffe ich zumindest... :-).
@EndNode

@Node movec "MOVEC Kontrollregister (Rc)"
                                          68010 68020 68030 68040 68060
SFC   Source Function Code                  x     x     x     x     x
DFC   Destination Function Code             x     x     x     x     x
USP   User Stack Pointer                    x     x     x     x     x
VBR   Vector Base Register                  x     x     x     x     x
CACR  Cache Control Register                      x     x     x     x
CAAR  Cache Address Register                      x     x
MSP   Master Stack Pointer                        x     x     x
ISP   Interrupt Stack Pointer                     x     x     x
TC    MMU Translation Control Register                        x     x
ITT0  Instr. Transparent Translation Reg. 0                   x     x
ITT1  Instr. Transparent Translation Reg. 1                   x     x
DTT0  Data Transparent Translation Reg. 0                     x     x
DTT1  Data Transparent Translation Reg. 1                     x     x
MMUSR MMU Status Register                                     x
URP   User Root Pointer                                       x     x
SRP   Supervisor Root Pointer                                 x     x
BUSCR Bus Control Register                                          x
PCR   Processor Control Register                                    x
@EndNode

@Node intfpu "Fließkomma Instruktionen (68881,68882,68040,68060)"
Viele von den nachfolgenden Instruktionen müssen für einen 68040 oder
68060 Software-emuliert werden. Trotzdem wird PhxAss den entsprechen-
den Code ohne jegliche Warnung erzeugen.

Emulierte Instruktionen beim 68040:
FACOS,FASIN,FATAN,FCOS,FCOSH,FETOX,FETOXM1,FGETEXP,FGETMAN,FINT,
FINTRZ,FLOG10,FLOG2,FLOGN,FLOGNP1,FMOD,FMOVECR,FREM,FSGLDIV,
FSGLMUL,FSIN,FSINCOS,FSINH,FTAN,FTANH,FTENTOX,FTWOTOX

Emulierte Instruktionen beim 68060:
FACOS,FASIN,FATAN,FCOS,FCOSH,FDB<cc>,FETOX,FETOXM1,FGETEXP,FGETMAN,
FLOG10,FLOG2,FLOGN,FLOGNP1,FMOD,FMOVECR,FREM,FSGLDIV,FSGLMUL,FS<cc>,
FSIN,FSINCOS,FSINH,FTAN,FTANH,FTENTOX,FTWOTOX


Monadic operations:
Fxxxx       <ea>,FPn
Fxxxx       FPm,FPn
Fxxxx       FPn

FABS        Floating-Point Absolute value
FACOS       Arc Cosine
FASIN       Arc Sine
FATAN       Arc Tangent
FATANH      Hyberbolic Arc Tangent
FCOS        Cosine
FCOSH       Hyperbolic Cosine
FETOX       e to x
FETOXM1     e to x minus one
FGETEXP     Get Exponent
FGETMAN     Get Mantissa
FINT        Integer Part
FINTRZ      Integer Part, Round to Zero
FLOG10      log10
FLOG2       log2
FLOGN       loge
FLOGNP1     loge (x+1)
FNEG        Floating-Point Negate
FSIN        Sine
FSINH       Hyperbolic Sine
FSQRT       Floating-Point Square Root
FTAN        Tangent
FTANH       Hyperbolic Tangent
FTENTOX     10 to x
FTWOTOX     2 to x

Dyadic operations:
Fxxxx       <ea>,FPn
Fxxxx       FPm,FPn

FADD        Floating-Point Add
FCMP        Floating-Point Compare
FDIV        Floating-Point Divide
FMOD        Modulo Remainder
FMUL        Floating-Point Multiply
FREM        IEEE Remainder
FSCALE      Scale Exponent
FSGLDIV     Single Precision Divide
FSGLMUL     Single Precision Multiply
FSUB        Floating-Point Subtract

Special operations:
FB<cc>.x    <label>                    Floating-Point Branch Conditionally
FDB<cc>     Dn,<label>                 FP Test Cond., Decr., and Branch
FMOVE.x     <ea>,FPn                   Move Floating-Point Data Register
FMOVE.x     FPm,<ea>
FMOVE.P     FPm,<ea>{Dn}
FMOVE.P     FPm,<ea>{#k}
FMOVE.L     <ea>,FPcr                  Move FP System Control Register
FMOVE.L     FPcr,<ea>                  (FPcr = FPCR, FPSR or FPIAR)
FMOVECR     #ccc,FPn                   Move Constant ROM
FMOVEM      <list>,<ea>                Move Multiple FP Data Registers
FMOVEM      Dn,<ea>
FMOVEM      <ea>,<list>
FMOVEM      <ea>,Dn
FMOVEM.L    <list>,<ea>                Move Multiple FP Control Regs.
FMOVEM.L    <ea>,<list>                (<list> = comb. of FPCR,FPSR,FPIAR)
FNOP                                   No Operation
FRESTORE    <ea>                       Restore Internal FP State
FSAVE       <ea>                       Save Internal Floating-Point State
FS<cc>      <ea>                       Set According to FP Condition
FSINCOS.x   <ea>,FPc:FPs               Simultaneous Sine and Cosine
FSINCOS     FPm,FPc:FPs
FTRAP<cc>                              Trap on Floating-Point Condition
FTRAP<cc>.x #<data>
FTST.x      <ea>                       Test Floating-Point Operand
FTST        FPm

Floating-Point Condition Codes <cc>:
F        false                         EQ       equal
OGT      ordered greater than          OGE      ordered gt. than or equal
OLT      ordered less than             OLE      ordered less than or equal
OGL      ordered greater or less than  OR       ordered
UN       unordered                     UNE      unordered or equal
UGT      unordered or greater than     UGE      unord. or gt. than or equal
ULT      unordered or less than        ULE      unord. or less than or equal
NE       not equal                     T        true
SF       signaling false               SEQ      signaling equal
GT       greater than                  GE       greater than or equal
LT       less than                     LE       less than or equal
GL       greater than or less than     GLE      gt. or less than or equal
NGLE     not (gt. or less or equal)    NGL      not (greater or less than)
NLE      not (less than or equal)      NLT      not (less than)
NGE      not (greater than or equal)   NGT      not (greater than)
SNE      signaling not equal           ST       signaling true
@EndNode

@Node intfpu040 "Fließkomma Instruktionen (68040,68060)"
FSADD       Add Single Precision
FDADD       Add Double Precision
FSDIV       Single Precision Divide
FDDIV       Double Precision Divide
FSMOVE      Single Precision Move
FDMOVE      Double Precision Move
FSMUL       Single Precision Multiply
FDMUL       Double Precision Multiply
FSNEG       Single Precision Negate
FDNEG       Double Precision Negate
FSSQRT      Single Precision Square Root
FDSQRT      Double Precision Square Root
FSSUB       Subtract Single Precision
FDSUB       Subtract Double Precision
@EndNode

@Node pmmu851 "PMMU Instruktionen (68851)"
PB<cc>.x    <label>                    Branch on PMMU Condition
PDB<cc>     Dn,<label>                 Test, Decr., and Branch on PMMU Cond.
PFLUSHA                                Invalidate Entries in the ATC
PFLUSH      <fc>,#<mask>
PFLUSHS     <fc>,#<mask>
PFLUSH      <fc>,#<mask>,<ea>
PFLUSHS     <fc>,#<mask>,<ea>
PFLUSHR     <ea>                       Invalidate ATC and RPT Entries
PLOADR      <fc>,<ea>                  Load an Entry into the ATC
PLOADW      <fc>,<ea>
PMOVE       <PMMU Register>,<ea>       Move PMMU Register
PMOVE       <ea>,<PMMU Register>
PRESTORE    <ea>                       PMMU Restore Function
PSAVE       <ea>                       PMMU Save Function
PS<cc>      <ea>                       Set on PMMU Condition
PTESTR      <fc>,<ea>,#<level>         Get Information About Log. Address
PTESTR      <fc>,<ea>,#<level>,An
PTESTW      <fc>,<ea>,#<level>
PTESTW      <fc>,<ea>,#<level>,An
PTRAP<cc>                              Trap on PMMU Condition
PTRAP<cc>.x #<data>

PMMU Condition Codes <cc>:
BS, BC  Bus Error
LS, LC  Limit Violation
SS, SC  Supervisor Only
AS, AC  Access Level Violation
WS, WC  Write Protected
IS, IC  Invalid Descriptor
GS, GC  Gate
CS, CC  Globally Sharable

PMMU Registers:
CRP, SRP, DRP, TC, BACx, BADx, AC, PSR, PCSR, CAL, VAL, SCC
@EndNode

@Node pmmu030 "PMMU Instruktionen (68030)"
PFLUSHA                                Flush Entry in the ATC
PFLUSH      <fc>,#<mask>
PFLUSH      <fc>,#<mask>,<ea>
PLOADR      <fc>,<ea>                  Load an Entry into the ATC
PLOADW      <fc>,<ea>
PMOVE       MRn,<ea>                   Move to/from MMU Registers
PMOVE       <ea>,MRn
PMOVEFD     <ea>,MRn
PTESTR      <fc>,<ea>,#<level>         Test a Logical Address
PTESTR      <fc>,<ea>,#<level>,An
PTESTW      <fc>,<ea>,#<level>
PTESTW      <fc>,<ea>,#<level>,An

PMMU Registers (MRn):
SRP, CRP, TC, MMUSR(PSR), TT0, TT1
@EndNode

@Node pmmu040 "PMMU Instruktionen (68040,68060)"
PFLUSH      (An)                       Flush ATC Entries
PFLUSHN     (An)
PFLUSHA
PFLUSHAN

PTESTR      (An)                       Test a Logical Address
PTESTW      (An)                       (68040 only!)

PLPAR       (An)                       Translate Logical to Physical
PLPAW       (An)                       (68060 only!)
@EndNode


@Node expressions "Ausdrücke"
Ausdrücke bestehen aus Symbolen und Konstanten. Symbole können absolut,
relocatibel oder extern sein. PhxAss unterstützt die folgenden arithme-
tischen und logischen Operationen für INTEGER Ausdrücke (von der höchsten 
zur niedrigsten Priorität) :

1.  ~    Nicht (unär)      -    Negation (unär)
2.  <<   Links Shift       >>   Rechts Shift
3.  *    Multiplikation    /    Division                 //   Modulo
4.  &    Und               |    Oder ('!' auch erlaubt)  ^    Exklusiv Oder
5.  -    Subtraktion       +    Addition
6.  ( )  runde Klammern    [ ]  eckige Klammern

Für absolute Symbole und Konstanten (die ebenfalls absolut sind), sind alle
arithmetischen Operationen erlaubt.
Wenn relocatible oder externe Symbol im Ausdruck erscheinen, ist nur Sub-
traktion und Addition mit einigen Einschränkungen möglich:

   reloc - abs          extern - abs         reloc - reloc
   reloc + abs          extern + abs         abs + reloc        abs + extern
   (reloc-reloc)<<abs   (reloc-reloc)>>abs   (seit V3.95)

sind erlaubt, alle anderen Ausdrücke sind illegal.


Fließkomma Ausdrücke bestehen aus Fließkomma Konstanten und Symbolen, sowie
absoluten Integer Konstanten und Symbolen. Die folgenden Operationen und
Funktionen sind für Fließkommaausdrücke erlaubt (seit V4.00):

Binär:
   +    Plus               -    Minus              *    Multiplikation
   /    Division           ^    Potenzierung
Unär:
   -    Negation           sqr  Quadratwurzel      exp  e^x
   log  Nat. Logarithmus   sin  Sinus              cos  Cosinus
   tan  Tangens

SQR, EXP, LOG, SIN, COS und TAN sind Funktionen und können aus Groß- oder
aus Kleinbuchstaben bestehen. Normalerweise werden sie direkt vor einen
geklammerten Term geschrieben, z.B. "sin(3.14159)". Wenn aber, wie im letz-
ten Beispiel, der Term nur aus einer einzigen Konstante besteht, ist es
auch erlaubt "sin:3.14159" zu schreiben. Der ':' ist unbedingt erfoderlich
um den Funktionsnamen von einem möglichen Symbolnamen trennen zu können.

Es gibt sechs verschiedene Arten von Konstanten:

Hexadezimale, eingeleitet durch ein '$', bestehen aus '0'-'9' und 'A'-'F'
 (oder 'a'-'f')
Dezimale, bestehen aus '0'-'9'
Fließkomma, haben das Format [+/-][integer][.nachkomma][E[+/-]exponent]
Oktale, eingeleitet durch ein '@', bestehen aus '0'-'7'
Binäre, eingeleitet durch ein '%', bestehen aus '0' und '1'
String-, eingebettet von ' oder ", bestehen aus bis zu vier Zeichen.

Das '\\' Zeichen ist ein Escape-Symbol, das die folgenden Codes erzeugen
kann:
  \\\\     der '\\'-character selbst
   \\'    character #39 (Apostroph)
   \\"    character #34 (Anführungszeichen)
   \\0    character #0  (Stringbegrenzer)
   \\n    character #10 (Zeilenvorschub)
   \\f    character #12 (Formularvorschub)
   \\b    character #8  (Rückstelltaste)
   \\t    character #9  (Tabulator)
   \\r    character #13 (Returntaste)
   \\e    character #27 (Escape Code)
   \\c    character #155(leitet Kontrollsequenz (CSI) ein)

"" und '' innerhalb von Strings werden durch " bzw. ' ersetzt (V4.14).
@EndNode


@Node directives "Assembler Direktiven"
In den folgenden Abschnitten werden alle Direktiven die PhxAss unterstützt
ausführlich beschrieben.
Wichtiger Hinweis! Direktiven dürfen *nicht* in der ersten Spalte einer
Zeile beginnen, oder sie werden als Labels behandelt! (das war ein Hinweis
für Seka User :-)

Folgende Direktiven werden von PhxAss unterstützt:

  @{"    ASM    " link endasm}  Assemblierung für nachfolgende Zeilen erlauben
  @{"    BLK    " link dcb}  Konstanten Block definieren
  @{"    BSS    " link bss1}  Bss Section
  @{"    BSS    " link bss2}  Speicher für ein Bss Symbol reservieren
  @{"   BSS_C   " link chip}  Chip-RAM Bss Section
  @{"   BSS_F   " link chip}  Fast-RAM Bss Section
  @{"   CLRFO   " link foreset}  FO-Zähler auf Null zurücksetzen
  @{"   CLRSO   " link rsreset}  SO-Zähler auf Null zurücksetzen
  @{"   CNOP    " link cnop}  Nachfolgenden Code ausrichten
  @{"   CODE    " link cseg}  Code Section
  @{"  CODE_C   " link chip}  Chip-RAM Code Section
  @{"  CODE_F   " link chip}  Fast-RAM Code Section
  @{"  COMMENT  " link comm}  Kommentarzeile
  @{"   CSEG    " link cseg}  Code Section
  @{"   DATA    " link dseg}  Data Section
  @{"  DATA_C   " link chip}  Chip-RAM Data Section
  @{"  DATA_F   " link chip}  Fast-RAM Data Section
  @{"    DC     " link dc}  Konstante definieren
  @{"    DCB    " link dcb}  Konstanten Block definieren
  @{"   DEBUG   " link debug}  Akt. Adresse im Line Debug Block speichern
  @{"    DS     " link ds}  Speicherplatz reservieren
  @{"   DSEG    " link dseg}  Data Section
  @{"  DSOURCE  " link dsource}  Quelltextpfad für Line Debug Block setzen
  @{"    DX     " link ds}  Speicherplatz reservieren
  @{"   ECHO    " link echo}  Text ausgeben
  @{"   ELSE    " link ifendc}  ELSE-Teil für bedingte Assemblierung definieren
  @{"  ELSEIF   " link ifendc}  ELSE-Teil für bedingte Assemblierung definieren
  @{"  ENDASM   " link endasm}  Assemblierung für nachfolgende Zeilen verbieten
  @{"    EQU    " link equ}  Ausdruck einem Symbol zuweisen
  @{"   EQU.x   " link equx}  Fließkommaausdruck einem Symbol zuweisen
  @{"   EQUR    " link equr}  Register einem Symbol zuweisen
  @{"   EQURL   " link reg}  Dem Symbol eine Registerliste zuweisen (OMA)
  @{"    END    " link end}  Ende des Quelltextes
  @{"   ENDC    " link ifendc}  Ende der bedingten Assemblierung
  @{"   ENDIF   " link ifendc}  Ende der bedingten Assemblierung
  @{"   ENDM    " link macro}  Ende einer Makro Definition
  @{"   ENDR    " link rept}  Ende der REPT Schleife
  @{"   EREM    " link erem}  Assemblierung für nachfolgende Zeilen erlauben
  @{"   EVEN    " link even}  Nachfolgenden Code auf gerade Adresse ausrichten
  @{"   FAIL    " link fail}  Übersetzungsvorgang abbrechen
  @{"    FAR    " link far}  In den FAR-Code/Data Modus wechseln
  @{"   FEQUR   " link fequr}  FPU Register einem Symbol zuweisen
  @{"  FEQURL   " link freg}  Dem Symbol eine FPU-Registerliste zuweisen (OMA)
  @{"   FILE    " link file}  Name der Zieldatei für absoluten Code
  @{"    FO     " link fo}  Wert des FO-Zählers einem Symbol zuweisen
  @{"    FPU    " link fpu}  FPU Codeerzeugung erlauben
  @{"   FREG    " link freg}  Dem Symbol eine FPU-Registerliste zuweisen
  @{"  GLOBAL   " link global}  Speicherplatz für globales Bss Symbol reservieren
  @{"   IDNT    " link idnt}  Unit Namen definieren
  @{"    IFC    " link ifendc}  Bed.Ass.: Zwei Strings auf Gleichheit testen
  @{"    IFD    " link ifendc}  Bed.Ass.: Testen ob ein Symbol definiert ist
  @{"   IFEQ    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck Null ist
  @{"   IFGT    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck größer Null ist
  @{"   IFGE    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck größer oder gleich Null ist
  @{"   IFLT    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck kleiner Null ist
  @{"   IFLE    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruch kleiner oder gleich Null ist
  @{"   IFNC    " link ifendc}  Bed.Ass.: Testet zwei Strings auf Verschiedenheit
  @{"   IFND    " link ifendc}  Bed.Ass.: Testen ob ein Symbol undefiniert ist
  @{"   IFNE    " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck ungleich Null ist
  @{"    IF     " link ifendc}  Bed.Ass.: Testen ob ein Ausdruck ungleich Null ist
  @{"   IMAGE   " link incbin}  Binärdatei einbinden (AsmOne)
  @{"  INCBIN   " link incbin}  Binärdatei einbinden
  @{"  INCDIR   " link incdir}  Pfad für Include-Dateien setzen
  @{"  INCLUDE  " link include}  Quelltext einbinden
  @{"  INITNEAR " link initnear}  Near-Modus Basisregister initialisieren
  @{"    INT    " link int}  Wert eines Fließk.ausdrucks an ein Int. SET-Symbol übergeben
  @{" LINEDEBUG " link linedebug}  Debug-Hunk für Source-Level Debugger
  @{"   LIST    " link list}  Die folgenden Zeilen erscheinen im Listing File
  @{"   LOAD    " link load}  Zieladresse für absolute Codeerzeugung
  @{"  MACHINE  " link machine}  CPU-Typ bestimmen
  @{"   MACRO   " link macro}  Makro Definition
  @{"  MC680x0  " link mc680x0}  CPU-Typ bestimmen
  @{"   MEXIT   " link mexit}  Makro vorzeitig verlassen
  @{"   NEAR    " link near}  Near Modus
  @{"  NOLIST   " link nolist}  Folgezeilen sind im Listing File unsichtbar
  @{"   NREF    " link nref}  Near Modus Symbol importieren (wie XREF)
  @{"  OFFSET   " link offset}  Beginnt eine OFFSET Section
  @{"    OPT    " link opt}  Optimierungsmodus ändern (symbolisch)
  @{"   OPTC    " link optc}  Optimierungsmodus ändern (numerisch)
  @{"    ORG    " link org}  Startadresse für absolute Codeerzeugung
  @{"  OUTPUT   " link output}  Bestimmt den Namen der Zieldatei
  @{"   PMMU    " link pmmu}  68851 Code Generierung
  @{" PROCSTART " link diceproc}  Beginn einer C-Funktion beim DICE-Compiler
  @{"  PROCEND  " link diceproc}  Ende einer C-Funktion beim DICE-Compiler
  @{"  PUBLIC   " link public}  Importiere oder exportiere Symbol
  @{"    REG    " link reg}  Dem Symbol eine Registerliste zuweisen
  @{"    REM    " link erem}  Assemblierung für nachfolgende Zeilen verbieten
  @{"   REPT    " link rept}  Zeilen zwischen REPT...ENDR werden beliebig oft wiederholt
  @{"  RESTORE  " link restore}  Letzte mit SAVE gerettete Section reaktivieren
  @{"   RORG    " link rorg}  Abstand zum Anfang der Section für den nachfolgenden Code
  @{"    RS     " link rs}  Wert des RS-Zählers einem Symbol zuweisen
  @{"  RSRESET  " link rsreset}  RS-Zähler auf Null zurücksetzen
  @{"   RSSET   " link rsset}  RS-Zähler auf bestimmten Wert setzen
  @{"   SAVE    " link save}  Zustand der aktuellen Section retten
  @{"  SECTION  " link section}  Der folgende Code kommt in die angegebene Section
  @{"    SET    " link set}  Wert eines SET-Symbols ändern
  @{"   SET.x   " link setx}  Wert eines Fließkomma SET-Symbols ändern
  @{"   SETFO   " link foset}  FO-Zähler auf bestimmten Wert setzen
  @{"   SETSO   " link rsset}  SO-Zähler auf bestimmten Wert setzen
  @{"   SFORM   " link sform}  Programm wird im Motorola S-Record Format gespeichert
  @{" SHOWOFFSET" link showoffset}  Aktuellen Section-Offset anzeigen lassen
  @{"    SO     " link rs}  Wert des SO-Zählers einem Symbol zuweisen
  @{"   STYPE   " link stype}  Wählt ein S-Record Format und dessen Länge aus
  @{"  SUBTTL   " link subttl}  (ohne Funktion)
  @{"  SYMDEBUG " link symdebug}  Globale Symbole für Debugger sichtbar machen
  @{"    TTL    " link idnt}  Namen der Unit bestimmen
  @{" TRACKDISK " link trackdisk}  Schreibt absoluten Code direkt auf eine Diskette
  @{"   XDEF    " link xdef}  Symbol exportieren
  @{"   XREF    " link xref}  Symbol importieren
@EndNode

@Node equ "EQU"

         symbol   equ      <ausdruck>
         symbol   =        <ausdruck>

      Der Ausdruck wird dem Symbol zugewiesen.
@EndNode

@Node equx "EQU.x"

         symbol   equ.x    <fließkommaausdruck>
         symbol   =.x      <fließkommaausdruck>

      Ein EQU mit .d,.f,.p,.s,.x-Erweiterung übergibt sen Wert eines Fließ-
      kommaausdrucks an ein Symbol. Wenn Sie mehr über Fließkommaausdrücke
      wissen wollen, schlagen sie im Abschnitt @{"Ausdrücke" link expressions} nach.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node equr "EQUR"

         symbol   equr     <register>

      Durch diese Direktive wird einem Symbol ein CPU Register (D0-D7, A0-
      A7 oder SP) oder (seit v4.20) ein anderes Registersymbol zugewiesen.
      Seit V3.00 muß das Registersymbol bereits vor der ersten Benutzung
      definiert sein.
      Seit V4.38 dürfen auch lokale Symbole verwendet werden, allerdings
      höchstens 16 lokale Symboldefinitionen pro Register.
@EndNode

@Node reg "REG"

         symbol   reg      <registerliste>
         symbol   equrl    <registerliste>

      Hiermit wird ein Symbol mit einer ganzen Registerliste belegt. Gültige
      Registerlisten dürfen mehrere Registernamen (siehe @{"EQUR" link equr}),
      getrennt durch '/'-Zeichen, enthalten. Das '-'-Zeichen definiert einen
      ganzen Bereich von Registern. Es folgen Beispiele für gültige Regis-
      terlisten:
         a1/a3-a5/d0/d2/d4
         d0-d7/a2-a6
         d1-3/d5-7/a0-1/a3-6  (seit V3.56)
@EndNode

@Node freg "FREG"

         symbol   freg     <registerliste>
         symbol   fequrl   <registerliste>

      Dem Symbol wird eine FPU Registerliste zugewiesen. Gültige Register-
      listen dürfen die FPU Register FP0-FP7, getrennt durch '/'-Zeichen
      enthalten. Das '-' Zeichen definiert eine ganzen Bereich von FPU Re-
      gistern. Es folgen Beispiele für gültige Registerlisten:
         fp1/fp3-fp5/fp0
         fp0-fp7
@EndNode

@Node fequr "FEQUR"

         symbol   fequr    <fpu register>

      Durch diese Direktive wird einem Symbol ein FPU Register (FP0-FP7)
      oder ein anderes FPU-Registersymbol zugewiesen. Das Registersymbol
      muß bereits vor der ersten Benutzung definiert sein.
@EndNode

@Node set "SET"

         symbol   set      <absoluter ausdruck>

      Der Wert eines absoluten Ausdrucks wird einem SET-Symbol zugewiesen.
      In diesem Ausdruck sind keine relocatiblen oder externen Symbol zu-
      lässig. Ein Symbol, das durch SET definiert wurde, kann jederzeit
      durch eine weitere SET Direktive geändert werden.
      Einige SET-Symbole sind schon von PhxAss vordefiniert:

      _PHXASS_    set      1
      _VERSION_   set      version<<16+revision

      Je nachdem welcher Prozessor und Coprozessor im System vorhanden ist,
      definiert PhxAss auch die folgenden Symbole:
      _MC68000_, _MC68010_, _MC68020_ and  _MC68881_. The symbols _MC68030_,
      _MC68040_, _MC68060_, _MC68881_ und _MC68882_.

      Je nachdem für welchen Prozessor und Coprozessor mittels der
      Direktiven @{"MACHINE" link machine}, @{"FPU" link fpu} und @{"PMMU" link pmmu} Code-Erzeugung erlaubt wurde,
      werden die folgenden Symbole gesetzt:
      __CPU : 68000, 68010, 68020, 68030, 68040, 68060
      __FPU : 0 oder FPU-ID 1-7
      __MMU : 0 oder 1 bei PMMU Code-Erzeugung

      NARG enthält die Anzahl der übergebenen Makro-Parameter und ist
      außerhalb eines Makros immer Null.

      CARG wird beim Eintreten in ein Makro mit 1 initialisiert und
      kann dazu verwendet werden, bestimmte Makro-Parameter indirekt
      auszuwählen. Dies geschieht über die Spezialsymbole \\., \\+ und \\-
      (siehe @{"MACRO" link macro} Direktive).

      __RS enthält immer den aktuellen Wert des @{"RS-Zählers" link rs}.
@EndNode

@Node setx "SET.x"

         symbol   set.x    <fließkommaausdruck>

      Ein SET mit .d,.f,.p,.s,.x-Erweiterung weist einem Symbol den
      Wert eines Fließkommaausdrucks zu. Dieser Wert darf durch weitere
      SETs verändert werden, unter der Voraussetzung das der Typ des
      Symbols nicht verändert wird (z.B. bei "symbol SET.S" gefolgt von
      "symbol SET.D").
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node int "INT"

         symbol   int      <fließkommaausdruck>

      Der Fließkommaausdruck wird berechnet und sein Resultat, ohne den
      Nachkommateil, einem Integer SET-Symbol zugewiesen.
@EndNode

@Node rsreset "RSRESET,CLRSO"
      Diese Direktive setzt die internen RS und SO Struktur-Offset-Zähler 
      auf Null zurück.
@EndNode

@Node rsset "RSSET,SETSO"

                  rsset    [<zähler>]
                  setso    [<zähler>]

      Diese Direktive setzt die internen RS und SO Struktur-Offset-Zähler
      auf den Wert des <zähler> Ausdrucks.
@EndNode

@Node rs "RS,SO"

         [symbol] rs.x     [<anzahl>]
         [symbol] so.x     [<anzahl>]

      Durch RS oder SO wird der aktuelle Wert des internen RS/SO-Zählers
      einem Symbol zugewiesen (wenn eines angegeben wurde). Danach wird
      der RS/SO-Zähler um die in der Opcode-Erweiterung angegebene Daten-
      breite, multipliziert mit <anzahl>, inkrementiert. Wenn <anzahl>
      fehlt, wird sie gleich Null gesetzt. Gültige Opcode-Erweiterungen
      können Sie z.B. im Abschnitt der @{"DC" link dc} Direktive erfahren.
      Der augenblickliche Zustand des RS/SO-Zählers kann zusätzlich über
      die Symbole __RS und __SO abgefragt werden.
@EndNode

@Node foreset "CLRFO"
      Diese Direktive setzt den internen Frame-Offset-Zähler FO auf Null
      zurück.
@EndNode

@Node foset "SETFO"

                  setfo    [<zähler>]

      Diese Direktive setzt den internen Frame-Offset-Zähler auf den Wert
      des <zähler> Ausdrucks.
@EndNode

@Node fo "FO"

         [symbol] fo.x     [<anzahl>]

      FO dekrementiert den internen Frame-Offset-Zähler um die in der
      Opcode-Erweiterung angegebene Datenbreite multipliziert mit <anzahl>
      und weist diesen Wert einem Symbol zu (falls vorhanden). Wenn 
      <anzahl> fehlt, wird sie gleich Null gesetzt. Gültige Opcode-Erwei-
      terungen können Sie z.B. im Abschnitt der @{"DC" link dc} Direktive erfahren.
      Der augenblickliche Zustand des FO-Zählers kann zusätzlich über das
      __FO Symbol abgefragt werden.
@EndNode

@Node idnt "IDNT"

                  idnt     <name>
                  ttl      <name>

      Diese Direktiven bestimmen den Namen der Object Modul Unit, die der
      Assembler erzeugen wird. Normalerweise wird dazu der Name des Quell-
      textes, ohne seine Namenserweiterung, verwendet.
@EndNode

@Node subttl "SUBTTL"
      Ein Quelltext, der SUBTTL enthält, wird auf PhxAss keinen Fehler
      erzeugen, aber bisher tut die Direktive auch noch nichts.
      (Um ehrlich zu sein, ich wüßte auch gar nicht was sie tun sollte?
      Wenn jemand weiß, worum es sich hier handelt, kann er mir ja mal
      schreiben...)
@EndNode

@Node comm "COMMENT"

                  comment  text

      Hinter diese Direktive kann beliebiger Kommentartext geschrieben
      werden.
@EndNode

@Node list "LIST"
      Der nachfolgende Quelltext wird in einem Listing File zu sehen
      sein.
@EndNode

@Node nolist "NOLIST"
      Der nachfolgende Quelltext wird in einem Listing File nicht zu
      sehen sein.
@EndNode

@Node opt "OPT"

                  opt      <optimierungsschalter>

      Ändert den Optimierungsmodus. Eine Auflisting aller Optimierungs-
      schalter ist in @{"CLI Parameter" link params} enthalten.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node optc "OPTC"

                  optc     <ausdruck>

      Ändert den Optimierungsmodus. Jedes Bit in <ausdruck> ist für den
      Zustand eines der 10 Optimierungs-Flags verantwortlich.

      Bit  Optimierungsmodus
       0   Normal (N)
       1   Relative (R)
       2   Quick (Q)
       3   Branches (B)
       4   Shifts (L)
       5   Pea/Lea (P)
       6   Special (S)
       7   Movem (M)
       8   TotalBranch (T)
       9   Movem2Move (D)

      Eine genaue Beschreibung aller Optimierungsschalter ist in
      @{"CLI Parameter" link params} nachzulesen. Der aktuelle Zustand
      der Optimierungs-Flags kann über das Assembler-Symbol "__OPTC"
      jederzeit ausgelesen, oder einem SET- oder EQU-Symbol zugewiesen
      werden.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node macro "MACRO, ENDM"

         symbol   macro
                  ...text...
                  endm

                  macro    symbol
                  ...text...
                  endm

      Durch diese Direktive wird ein Makro definiert. Der Name des Makros
      darf auf der linken oder der rechten Seite erscheinen. Wenn PhxAss
      im Quelltext auf einen Makronamen stößt, wirdern die Zeilen zwischen
      MACRO und ENDM in den Quelltext eingefügt. Bei einem Makroaufruf kön-
      nen bis zu 35, durch Kommas getrennte, Parameter im Operandenfeld
      angegeben werden. Sie werden im Makro als '\\1' bis '\\9' und (seit
      V4.18) als '\\a' bis '\\z', für die letzten 26, bezeichnet.
      '\\0' ist für die Opcode-Erweiterung reserviert. Beispiel:

         bhs      macro
                  bcc.\\0   \\1
                  endm

      Das Makro wird aufgerufen durch:      bhs.s    label
      Dabei wird ".s" in \\0 und "label" in \\1 gespeichert.
      '\\@' im Makro wird durch eine einzigartige, dreistellige, Ziffern-
      folge ersetzt, die bei jedem neuen Makro-Aufruf anders ist.

      Labels innerhalb eines Makros sollten unbedingt '\\@' enthalten,
      um eine Mehrfach-Definition von Labels zu verhindern.

      Bei der Benutzung der Makro-Parameter in String-Konstanten gibt
      es eine Einschränkung. Dort sind nur die Parameter \\1 bis \\9
      erlaubt, um Probleme mit den gleichnahmigen Escape-Symbolen zu
      vermeiden. Seit v4.33 ist \\0 ebenfalls erlaubt, daher Vorsicht
      mit dem Escape-Symbol für String-Termination innerhalb von Makros.

      V4.33:
      Mit \\., \\+ und \\- kann indirekt auf einen Makro-Parameter zuge-
      griffen werden, dessen Nummer im Set-Symbol @{"CARG" link set} steht.
      Dabei wird CARG bei Benutzung von \\+ nach der Operation auto-
      matisch inkrementiert und bei Benutzung von  \\- dekrementiert.
      \\. läßt CARG unverändert.

      Desweiteren dürfen Makro-Parameter durch < ... > geklammert
      werden, so daß ein größerer Bereich als ein einziger unteil-
      barer Parameter zusammengefaßt werden kann. Beispiele:

                  PRINT     <Hello World>
                  DCB       <"Test",0>

@EndNode

@Node mexit "MEXIT"
      Wenn der Assembler innerhalb eines Makros auf diese Direktive stößt,
      sucht er sofort nach @{"ENDM" link macro} und verläßt das Makro.
@EndNode

@Node end "END"
      Im ersten Durchgang wird der Rest des Quelltextes hinter END igno-
      riert. Im zweiten Durchgang schließt der Assembler alle offenen
      Dateien und beendet den Übersetzungsvorgang.
      Normalerweise geschieht dies automatisch am Ende eines Quelltextes.
@EndNode

@Node fail "FAIL"
      PhxAss gibt die Fehlermeldung "69 Assembly abortet!" aus, und beendet
      den Überetzungsvorgang.
@EndNode

@Node echo "ECHO"

                  echo     <string>

      Der angegebene String wird auf StdOut ausgegeben (normalerwiese CLI-
      Fenster). Wenn kein String angegeben wurde, wird nur ein Zeilen-
      vorschub ausgegeben.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node machine "MACHINE"

                  machine  <processor>

      Diese Direktive bestimmt den Prozessortyp für den der nachfolgende
      Code generiert werden soll. Gültige Prozessoren sind:
      68000, 68010, 68020, 68030, 68040, 68060
      MACHINE 68000 deaktiviert auch die mittels @{"PMMU" link pmmu} aktivierte 68851
      Codegenerierung (v4.30).
      Die Implementierung dieser Direktive kann auf anderen Assemblern
      abweichen.
@EndNode

@Node mc680x0 "MC680x0"

                  mc68000
                  mc68010
                  mc68020
                  mc68030
                  mc68040
                  mc68060
                  mc68881
                  mc68882
                  mc68851

      Änhlich wie @{"MACHINE" link machine} bestimmt diese Direktive den Prozessortyp
      für den der nachfolgende Code generiert werden soll.
@EndNode

@Node fpu "FPU"

                  fpu [<cpID>]

      Code Generierung für einen MC68881/68882 Coprozessor wird erlaubt.
      Normalerweise sollte <cpID> auf '1' gesetzt werden, da dies auf den
      meisten Systemen die korrekte ID für einen Fließkommacoprozessor ist.
      (Vielleicht haben Sie aber auch mehrere FPUs, die unter verschiedenen
      IDs angesprochen werden müssen :-)
      <cpID> sollte auf jeden Fall niemals auf '0' gesetzt werden, da diese
      ID fest für eine PMMU reserviert ist.
      Wenn als Prozessortyp bereits schon 68040 oder 68060 gewählt wurde,
      sollte diese Direktive nicht verwendet werden (wegen interner FPU).
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node pmmu "PMMU"
      Code Generierung für eine MC68851 Paged Memory Management Unit wird
      hierdurch ermöglicht. PMMU macht nur Sinn, wenn als Prozessortyp
      bereits '68020' gewählt wurde.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node section "SECTION"

                  section  <name>[,<typ>[,<memflag>]]

      Der nachfolgende Code wird in die Section mit dem Namen <name>
      plaziert. Es gibt drei verschiedene Sectionstypen: CODE,DATA und BSS.
      CODE enthält die ausführbaren M68000 Instruktionen, DATA enthält
      initialisierte und BSS uninitialisierte Daten (werden beim Programm-
      start auf Null gesetzt). Wird <typ> nicht angegeben, so entspricht
      dies einer CODE Section.
      Die Section wird normalerweise in den Speicher mit der höchsten
      Priorität geladen. Durch Angabe des <memflag> als FAST oder CHIP,
      kann man aber auch bestimmen ob die Section unbedingt ins Fat- oder
      Chip-Ram geladen werden muß.

      Aus Gründen der Kompatibilität werden CODE_C, DATA_C und BSS_C eben-
      falls als Sectionstypen anerkannt (seit V3.56) (die ???_F-Typen 
      seit v4.30).

      Durch das Erzeugen einer Section wechselt der Assembler in den Relo-
      catiblen Modus, in dem dann die folgenden Direktiven nicht mehr be-
      nutzt werden können:
      @{"org" link org}, @{"load" link load}, @{"file" link file}, @{"trackdisk" link trackdisk}.
@EndNode

@Node cseg "CODE, CSEG"
      Diese Direktiven entsprechen: @{"section" link section}  "CODE",code
@EndNode

@Node dseg "DATA, DSEG"
      Diese Direktiven entsprechen: @{"section" link section}  "DATA",data
@EndNode

@Node chip "CODE_C, CODE_F, DATA_C, DATA_F, BSS_C, BSS_F"
      Siehe @{"CODE" link cseg}, @{"DATA" link dseg} oder @{"BSS" link bss1}. Außerdem wird <memflag> definiert,
      wodurch die Section ins Fast- (xxx_F) oder ins Chip-Ram (xxx_C)
      gezwungen wird.
@EndNode

@Node bss1 "BSS"
      Diese Direktive entspricht: @{"section" link section}  "BSS",bss
@EndNode

@Node bss2 "BSS"

                  bss      symbol,<anzahl>

      Wenn BSS Parameter im Operandenfeld besitzt, entspricht dies einer
      völlig anderen Direktive: Das angegebene Symbol wird in der @{"BSS" link bss1}-
      Section plaziert, und es werden hierfür <anzahl> Bytes Speicher re-
      serviert.
      Diese Direktive ist nur zur Kompatibilität mit Aztec-C vorhanden.
@EndNode

@Node global "GLOBAL"

                  global   symbol,<anzahl>

      Diese Direktive tut praktisch dasselbe wie @{"BSS" link bss2} symbol,<anzahl>,
      allerdings wird das Symbol gleichzeitig, mittels @{"XDEF" link xdef} exportiert.
      Diese Direktive ist nur zur Kompatibilität mit Aztec-C vorhanden.
@EndNode

@Node offset "OFFSET"

                  offset   [<start offset>]

      Kennzeichnet den Anfang einer speziellen Offset-Section. Alle Labels,
      die in dieser Section definiert wurden, werden wie absolute Offsets
      behandelt, statt wie Adressen. <start offset> ist normalerweise Null.
      Solch eine Section kann nützlich sein, um Struktur-Offsets mit Hilfe
      der @{"DS.x" link ds} Direktive zu erzeugen.
      Solange Sie Ihre Programme aber mit PhxAss schreiben, sollten sie die
      viel schnelleren @{"RSRESET" link rsreset}, @{"RSSET" link rsset} und @{"RS.x" link rs} Direktiven
      verwenden.
      OFFSET wurde nur aus Gründen der Kompatibilität implementiert.
@EndNode

@Node rorg "RORG"

                  rorg     <section offset>

      Hiermit wird die genaue Position des nachfolgenden Code, relativ zum
      Start der aktuellen Section, bestimmt. <section offset> muß positiv
      sein.
@EndNode

@Node incdir "INCDIR"

                  incdir   <pfad1>[,<pfad2>,...]

      Diese Direktive macht dasselbe wie das INCPATH Argument (siehe auch
      @{"CLI Parameter" link params}).
      Andere Assembler unterstützen meistens keine Mehrfachpfaddefinitionen.
@EndNode

@Node include "INCLUDE"

                  include  <datei>

      Durch diese Direktive wird PhxAss dazu veranlaßt die Übersetzung des
      momentanen Quelltextes zu unterbrechen und den Quelltext aus <datei>
      zu übersetzen. Wenn dies geschafft ist, wird mit dem Original-Quell-
      text weiter gemacht.
      Wenn PhxAss die Include-Datei nicht finden kann, wird zuerst im Ver-
      zeichnis, das in der Environment-Variablen PHXASSINC gespeichert wur-
      de, nachgesehen. Dann werden die Verzeichnisse, die durch mögliche
      INCPATH-Parameter (siehe @{"CLI Parameter" link params}) bezeichnet wurden, durchsucht.
      Zum Schluß wird in den durch @{"INCDIR" link incdir} spezifizierten Verzeichnissen
      nachgesehen. Dann erst gibt es eine Fehlermeldung.
@EndNode

@Node incbin "INCBIN"

                  incbin   <datei>
                  image    <datei>

      Die angegebene Binärdatei wird in die aktuelle Section eingefügt (das
      können z.B. Grafiken, Samples oder trigonometrische Tabellen sein).
      PhxAss durchsucht dabei dieselben Include-Verzeichnisse wie die
      @{"INCLUDE" link include} Direktive.
@EndNode

@Node xref "XREF"

                  xref     symbol1[,symbol2,...]

      Die hier angegebenen Symbole sind extern definiert und werden erst
      durch den Linker eingesetzt.
      Andere Assembler unterstützen meistens nur ein Symbol.
@EndNode

@Node nref "NREF"

                  nref     symbol1[,symbol2,...]

      NREF tut praktisch dasselbe wie @{"XREF" link xref}, aber der Assembler wird
      dazu gezwungen, diese Symbole im Near-Modus zu adressieren.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node xdef "XDEF"

                  xdef     symbol1[,symbol2,...]

      Die angegebenen Symbole werden exportiert, in dem ihre Namen und
      Adressen im External-Block der Object-Datei gespeichert werden. Da-
      durch kann der Linker die Adressen dieser Symbole lesen und sie in
      andere Object-Dateien einsetzen.
      Andere Assembler unterstützen meistens nur ein Symbol.
@EndNode

@Node public "PUBLIC"

                  public   symbol1[,symbol2,...]

      Wenn das angegebene Symbol im vorliegenden Quelltext definiert ist,
      macht PUBLIC dasseble wie @{"XDEF" link xdef}. Ansonsten, wenn es unbekannt ist,
      ist PUBLIC mit @{"XREF" link xref} identisch.
      Diese Direktive ist nur zur Kompatibilität mit Aztec-C vorhanden.
@EndNode

@Node org "ORG"

                  org      adresse

      Definiert die absolute Startadresse des nachfolgenden Codes und läßt
      den Assembler in den absoluten Modus wechseln. Ab V1.8 sind auch meh-
      rere ORG Direktiven im Quelltext erlaubt, wobei jede als der Beginn
      einer neuen Section gesehen werden kann. Folgende Direktiven sind im
      absoluten Modus nicht verfügbar:
      @{"ttl" link idnt}, @{"code" link cseg}, @{"cseg" link cseg}, @{"data" link dseg}, @{"dseg" link dseg}, @{"bss" link bss1}, @{"section" link section}, @{"offset" link offset},
      @{"xref" link xref}, @{"nref" link nref}, @{"xdef" link xdef}, @{"public" link public}, @{"idnt" link idnt}.
@EndNode

@Node load "LOAD"

                  load     adresse

      Nachdem der Übersetzungsvorgang beendet ist, wird der absolute Code
      ab der angegebenen Adresse im Speicher abgelegt. Normalerweise wird
      er an die Adresse gespeichert, die bereits als Startadresse festge-
      legt worden ist. Seien Sie vorsichtigt mit dieser Direktive, da der
      Speicher an der Zieladresse weder geprüft noch allociert wird.
      Diese Direktive ist PhxAss-speziell (auch von SEKA bekannt).
@EndNode

@Node file "FILE"

                  file     <datei>

      Nachdem der Übersetzungsvorgang beendet ist, wird der absolute Code
      in der angegebenen Datei gespeichert.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node sform "SFORM"

                  sform    <datei>

      Nach dem Übersetzungsvorgang wird der absolute Code im Motorola
      S-Record Format in der angegebenen Datei gespeichert.
      Man sollte jedoch dabei bedenken, daß das S-Format nur 24-Bit
      Adressen unterstützt.
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node stype "STYPE"

                  stype    <s-format>[,<record-länge>]

<s-format> wählt eines der folgenden S-Record Formate:
1: S0-Header, S1-Data (16-Bit Adressen), S9-Trailer
2: S0-Header, S2-Data (24-Bit Adressen), S8-Trailer (Voreingestellt)
3: S0-Header, S3-Data (32-Bit Adressen), S7-Trailer

Der optionale Parameter <record-länge> bestimmt die Anzahl der ASCII-
Zeichenpaare in einem Data-Record und muß zwischen 16 und 255 liegen.
@EndNode

@Node trackdisk "TRACKDISK"

                  trackdisk <laufwerk>,<startblock>[,<offset>]

      Nachdem der Übersetzungsvorgang beendet ist, wird der absolute Code
      direkt, unter Benutzung des 'trackdisk.device' auf Diskette geschrie-
      ben. Dabei ist <laufwerk> von 0 bis 3 und <startblock> von 0 bis 1759
      gültig (bei HD-Disks doppelt soviel). <offset> ist normalerweise Null,
      und bestimmt den Abstand zum Blockanfang (0-511).
      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node output "OUTPUT"

                  output   <datei>

      Bestimmt den Namen der Zieldatei und überschreibt den Default- oder
      den mittels @{"TO" link params} in der Kommandozeile spezifizierten Namen.
@EndNode

@Node symdebug "SYMDEBUG"

                  symdebug

      Alle globalen Symbolnamen werden als Symbol Data Blocks der Ziel-
      datei hinzugefügt. Ein Debugger kann diese Namen dann anstatt 
      Adressen verwenden. Äquivalent zum CLI-Parameter @{"DS=SYMDEBUG/S" link params}.
@EndNode

@Node linedebug "LINEDEBUG"

                  linedebug

      PhxAss erzeugt einen Linedebug Block, der einem Source Level Debugger
      für jede Adresse im Code die zugehörige Quelltextzeile nennt. Der
      Ort des Quelltextes wird in diesem Block mit komplettem Pfad ge-
      speichert, z.B. "Work:Programs/Assembler/Tools/Source/Test.asm" 
      (das ist zum Beispiel nicht der Fall bei SAS's ASM :-). LINEDEBUG
      ist äquivalent zum CLI-Parameter @{"DL=LINEDEBUG/S" link params}.

      Compiler sollten die Direktiven @{"DEBUG" link debug} und 
      @{"DSOURCE" link dsource} statt dieser Option verwenden. Ein brauch-
      barer PD-Debugger mit Source Level Debugging Fähigkeiten ist bei-
      spielsweise "PowerVisor v1.42". Zu finden ist er im Aminet unter
      dev/debug/pv142.lha oder auf der GoldFish-CD.
@EndNode


@Node near "NEAR"

                  near     [An[,<secnum>]]

      Diese Direktive initialisiert die vom Near/Small-Data Modell benötig-
      ten Parameter. NEAR inklusive Argumenten darf seit v4.33 beliebig
      oft im Quelltext benutzt werden, um für einzelne Abschnitte z.B.
      unterschiedliche Basisregister zu wählen. Durch NEAR und @{"FAR" link far}
      ohne Argumente kann der Near/Small-Data Modus auf einfache Weise an
      und ausgeschaltet werden. 'NEAR An,0' sollte allerdings nicht vor der
      ersten SECTION, CODE, DATA, etc. Direktive angewandt werden.
      In diesem Modus ist es möglich Symbole über 'NearSymbol(An)' anzu-
      sprechen. Absolute Referenzen auf Near-Symbole werden automatisch nach
      'Address Register Indirect' konvertiert (wenn möglich).
      Das erste Argument, das Adressregister, ist von A0 bis A6 gültig und
      ist A4, wenn es nicht näher bestimmt wurde. <secnum> ist mit -2 vor-
      eingestellt und bestimmt die Nummer der Near-Section.
      Durch <secnum>=-1 werden alle Data und Bss Sectionen zu einer großen
      Small-Data Section vereinigt. Entwender geschieht das direkt durch
      PhxAss, falls es möglich war sofort eine ausführbare Datei zu er-
      zeugen, oder ein Linker muß mit der passenden Small-Data Option auf-
      gerufen werden.
      Durch <secnum>=-2 werden nur die Data oder Bss Sectionen die den
      Namen "__MERGED" tragen, zur Small-Data Section hinzugefügt.


                  near     code

      Wenn der String "CODE" als Argument verwendet wird, aktiviert PhxAss
      den Small-Code Modus, in dem alle extern definierten, absoluten, JMPs
      und JSRs nach PC-Relativ (16-Bit) konvertiert werden.

      Andere Assembler akzeptieren keine Argumente hinter NEAR.
@EndNode

@Node far "FAR"
      Deaktiviert den Small-Code/Data Modus, falls er aktiv war.
@EndNode

@Node initnear "INITNEAR"
      Hierdurch werden zwei Instruktionen in den Code eingefügt, welche den
      Small-Data Modus unter Verwendung der bei @{"NEAR" link near} getätigten Definitionen
      initialisieren. Folgender Code wird dabei erzeugt (10 Bytes):
                  lea      SmallDataBase,An
                  lea      32766(An),An
      Wenn sich die SmallDataBase in der aktuellen Section befindet,
      so wird der folgende Code erzeugt (4 Bytes):
                  lea      SmallDataBase(PC),An

      Diese Direktive ist PhxAss-speziell.
@EndNode

@Node dc "DC"

         label    dc.?     <ausdruck>[,<ausdruck>,...]
         label    dc.b/w/l "string"[,...]

      Die DC (Define Constant) Direktive reserviert und initialisiert ein
      oder mehrere Speicherfelder. Jedes Feld hat dieselbe Größe, die durch
      die Opcode-Erweiterung bestimmt wird. Jeder Byte-,Word- oder Longword-
      <ausdruck> kann ein Ausdruck sein und Vorwärtsreferenzen beinhalten.
      Folgende Opcode-Erweiterungen sind möglich:
      .B    (1 byte)    Byte              .W    (2 bytes)   Word
      .L    (4 bytes)   Longword          .F    (4 bytes)   Fast Flt. Point
      .S    (4 bytes)   Single Precision  .D    (8 bytes)   Double Precision
      .Q    (8 bytes)   Quadword(V3.42)   .X    (12 bytes)  Ext. Precision
      .P    (12 bytes)  Packed BCD

      Andere Assembler könnten mit Fließkomma oder Quadwords Probleme
      bekommen.
@EndNode

@Node dcb "DCB, BLK"

         label    dcb.x    <num>[,<füllwert>]
         label    blk.x    <num>[,<füllwert>]

      Diese Direktiven reservieren einen Speicherblock mit <num> Einträgen.
      Der verfügbaren Größen der Einträge sind dieselben wie in @{"DC" link dc}.
      Der Block wird mit <füllwert> initialisiert, der Null ist, wenn kein
      besonderer Wert angegeben wurde. Alle erlaubten Opcode-Erweiterungen
      sind bei @{"DC" link dc} nachzulesen.
@EndNode

@Node ds "DS, DX"

         label    ds.x     <anz>
         label    dx.x     <anz>

      Ein Speicherblock mit <anz> Einträgen wird reserviert und mit Null
      initialisiert. Siehe auch @{"DCB" link dcb} oder @{"BLK" link dcb}.
@EndNode

@Node cnop "CNOP"

                  cnop     <offset>,<align>

      Die Adresse des nachfolgenden Codes wird auch eine durch <align> teil-
      bare Adresse ausgerichtet. Danach wird der <offset> hinzuaddiert.
      Beispiel:  cnop  2,4  . Dieses Beispiel würde die nächste Adresse
      auf zwei Bytes nach der nächsten Longword-Grenze ausrichten.
      Werte für <align>, die größer als acht sind, machen keinen Sinn für
      relocatiblen Code (siehe AllocMem(), exec.library).

      Zugriff auf eine Adresse vor einem cnop bei gleichzeitiger
      Benutzung eines Labels nach dem cnop sollte UNBEDINGT vermieden
      werden:
                  lea      label-4,a0
                  CNOP     0,4
      label:

@EndNode

@Node even "EVEN"
      Diese Direktive entspricht einem @{"cnop" link cnop} 0,2  was dafür sorgt, daß die
      nächste Adresse gerade ist.
@EndNode

@Node ifendc "IFcond, ELSEIF, ELSE, ENDIF, ENDC"
      Diese Direktiven ermöglichen bedingte Assemblierung. Die übliche Form
      der IF Direktive ist:
                  IF<bedingung>   <ausdruck> oder Symbol
                  ...
                  [ELSE (oder ELSEIF)
                  ...]
                  ENDC (oder ENDIF)

      PhxAss unterstützt die folgenden Bedingungen:
         IFC "string1","string2" Vergleicht zwei Strings. Die kann innerhalb
                                 von Makros nützlich sein, wenn die Strings
                                 z.B. '\\x'-Makroargumente enthalten.
         IFD/IFND symbol         Testet ob das Symbol definiert/undef. ist.
         IFEQ/IFNE <exp>         Testet ob <exp> Null/nicht Null ist.
         IFGT/IFLT <exp>         Testet ob <exp> größer/kleiner Null ist.
         IFGE/IFLE <exp>         Testet ob <exp> größer/kleiner Null oder
                                 gleich Null ist.
         IF <exp>                entspricht IFNE.
@EndNode

@Node diceproc "PROCSTART,PROCEND"
      Diese Direktiven sind zur Kompatibilität mit dem DICE-C System vor-
      handen, doch bewirken sie zu diesem Zeitpunkt noch überhaupt nichts.
      In der Zukunft sollte es hiermit möglich sein LINK A5,#0 / UNLK A5
      aus einer C-Funktion zu entfernen, wenn A5 zwischen PROCSTART und
      PROCEND nicht referenziert wurde.
@EndNode

@Node rept "REPT/ENDR"

                  rept     <zähler>
                  ...
                  endr

      Der Teil des Quelltextes, der von REPT/ENDR eingeschlossen ist, wird
      so oft wiederholt wie es <zähler> angibt. Ein negativer <zähler> ist
      natürlich verboten.
@EndNode

@Node save "SAVE"

                  save

      Rettet den Namen und Typ der aktuellen Section, so daß sie später
      durch @{"RESTORE" link restore} wieder reaktiviert werden kann. Dies kann sehr
      nützlich innerhalb von Makros sein. Beispiel:

         print    macro
                  save
                  section  strings,data
         \\@       dc.b     \\1,0
                  restore
                  lea      \\@,a0
                  bsr      printstring
                  endm
@EndNode

@Node restore "RESTORE"

                  restore

      Reaktiviert die Section, die zuletzt mittel der @{"SAVE" link save}
      Directive gerettet worden ist.
@EndNode

@Node debug "DEBUG"

                  debug    <Zeilennummer>

      Erzeugt eine Verbindung zwischen der Zeile <Zeilennummer> eines
      Hochsprachenquelltexts (vollständiger Pfad sollte bereits durch
      @{"DSOURCE" link dsource} definiert worden sein) und der aktuellen Adresse und
      speichert diese Information im Line Debug Block. Nützlich für
      Compiler, um Source Level Debugging anbieten zu können.
      Der @{"LINEDEBUG/S" link params} Schalter darf dabei nicht zusätzlich gesetzt
      sein!
@EndNode

@Node dsource "DSOURCE"

                  dsource  <Quelltextpfad>

      Definiert den vollständigen Pfad Ihres Hochsprachenquelltextes.
      Zum Beispiel "Work:Programs/C/Test/Source/HelloWorld.c".
      Siehe @{"DEBUG" link debug} für weitere Informationen.
@EndNode

@Node showoffset "SHOWOFFSET"

                  showoffset [text]

      Zeigt den Section-Offset zum Zeitpunkt des Aufrufs als acht-
      stellige Hexadezimalzahl in der Console an. Der optionale Text
      wird direkt vor der Zahl (getrennt durch ein Leerzeichen)
      dargestellt.
      Manchmal hilfreich zum Debugging.
@EndNode

@Node endasm "ENDASM/ASM"

                  endasm
                  asm

      Der Teil des Quelltextes, der sich zwischen den ENDASM und ASM
      Direktiven befindet, wird nicht übersetzt.
@EndNode

@Node erem "REM/EREM"

                  rem
                  erem

      Der Teil des Quelltextes, der sich zwischen den REM und EREM
      Direktiven befindet, wird nicht übersetzt.
@EndNode


@Node compiler "Compiler Kompatibilität"
Ein Hauptgrund, warum ich damals begann PhxAss zu schreiben, war einen
Assembler zu besitzen der den unglaublich langsamen AS-Assembler von Aztec-
C ersetzt. Daher existieren sehr viele Direktiven um Aztec-Kompatibilität
zu erreichen, doch seit V3.30, wo Symbole die mit einem '.' beginnen als
lokale Symbole betrachtet werden, ist es praktisch unmöglich Aztec-Compiler
Code zu übersetzen. Die einzige Lösung wäre z.B. ein Programm zu schreiben,
das alle '.nnn' Symbole in '_nnn' umwandelt.

Seit der Einführung der neuen Direktiven @{"PROCSTART" link diceproc} und @{"PROCEND" link diceproc} in V3.71
werden DICE-C Quelltexte vollkommen unterstützt.
@EndNode

@Node phxopts "PhxOpts"
PhxOpts wurde aus dem PhxAss-Archiv entfernt, da ich nun seit beinahe
drei Jahren (!) auf ein Update warte, welches die zahlreichen Enforcer
Hits behebt.

Es existieren ein paar Alternativen hierzu im Aminet.
@EndNode

@Node envvars "Environment Variablen"
PhxAss sucht in ENV:PhxAss/ nach Environment Variablen. Momentan existieren
zwei Stück:

PHXASSINC   Bestimmt den Pfad, in dem nach Include Dateien gesucht wird,
            wenn sie im aktuellen Pfad nicht gefunden werden können.
            Achtung: PHXASSINC befindet sich seit v4.20 nicht mehr in ENV:
            sondern in ENV:PhxAss/ !

PHXOPTIONS  Diese Datei enthält mehrere vordefinierte globale Optionen,
            die PhxAss übergeben werden, wenn kein lokales PHXOPTIONS im
            aktuelles Verzeichnis gefunden werden konnte.
            Die Optionen, die PhxAss direkt über die Kommandozeile er-
            hält, haben natürlich Priorität über die, die in PHXOPTIONS
            definiert werden.
@EndNode


@Node linker "Linker"
Jeder Linker, der das standard Amiga DOS Object Modul Format unterstützt,
darf verwendet werden. Also z.B. vlink, blink oder dlink.

Ich empfehle die Verwendung von PhxLnk, obwohl ich ihn in naher Zukunft
wohl vollständig durch vlink ersetzen werden. PhxLnk befindet sich unter
dem Namen PhxLnk4xx.lha in dev/asm auf dem Aminet.

Ab V4.00 wird der Linker sowieso nur noch für das zusammenbinden von meh-
reren Modulen benötigt. PhxAss erzeugt automatisch ein ausführbares Pro-
gramm, solange keine externen Referenzen vorhanden sind.

Zwei Features von PhxLnk/vlink sind nicht in PhxAss implementiert:
1. Erzeugung von HUNK_RELOC32SHORT Blöcken (16-Bit Offsets)
2. Entfernen von Null-Bytes am Ende einer Code- oder Data-Section (die
   sogenannten Code-Bss bzw. Data-Bss Sectionen)
Wenn Sie eines dieser Features nutzen möchten (wobei Ihr Programm dann
allerdings nur noch ab OS2.04 läuft), sollten Sie den @{"NOEXE" link params} Schalter
setzen und anschließend PhxLnk/vlink aufrufen.

@EndNode


@Node errors "Fehlermeldungen"
In der vorliegenden Version von PhxAss können die folgenden Fehlermeldungen
auftreten:

01 Nicht genügend Speicher vorhanden.

02 Kann die utility.library nicht öffnen

03 Kann das timer.device nicht öffnen

04 DREL16 Symbol ist außer Reichweite
   Ihr Small Data Segment ist zu groß. Alle Data und Bss Sections dürfen
   zusammen nicht 64k überschreiten.

07 HEADINC: Dateiname erwartet
   Beispiel: PhxAss HEADINC "dh0:datei1,dh1:xdir/datei2,"

08 IncDir Pfadname erwartet
   Beispiel: incdir "dir1","dir2",
   Kann auch durch INCPATH ausgelöst werden.

10 SMALLDATA: Illegales Basisregister
   Erlaubt sind 2-6 für A2-A6. A4 ist Standard.

11 Diese MACHINE wird nicht unterstützt
   Ungültiger Prozessortyp angegeben. Die aktuelle Version von PhxAss unter-
   stützt die Prozessoren 68000, 68010, 68020, 68030, 68040 und 68060.

12 Datei existiert nicht
   Es war nicht möglich die Quelltextdatei zu öffnen.

13 Kein Include-Dateiname angegeben

14 Lesefehler

15 Überlauf des Stringpuffers
   Die Länge eines Labels, Opcodes oder Operandenfeldes darf 128 Zeichen
   nicht überschreiten.

16 Zu viele Sectionen
   Maximal möglich sind 250.

17 Symbol kann nicht extern gemacht werden
   XDEF kann nur auf absolute oder ralocatible Symbole angewandt werden.

18 Symbol wurde doppelt deklariert

19 Symbol kann kein XREF werden
   Ein Symbol, das bereits im aktuellen Quelltext definiert worden ist,
   kann nicht gleichzeitig extern definiert worden sein. Oder: Ein Symbol,
   das bereits mit XREF als extern definiert wurde, darf nicht im aktuel-
   len Quelltext definniert werden.

20 Illegale Namenserweiterung im Opcode Feld
   Erlaubt: .b .w .l .s .f .d .x .p .q

21 Ungültiger Makro Parameter
   Mögliche Parameter sind: \\0 (Opcode-Erweiterung), \\1 - \\9,
   \\a - \\z und \\@

22 Ungültige Zeichen in der Sprungmarke
   Siehe @{"Marken (Labels)" link labels} im Programmierer Info Abschnitt.

23 Unbekannte Direktive
   Der Opcode ist weder ein 680x0-Mnemonic noch eine Assembler Direktive
   oder ein Makro.

24 Zu viele Makroparameter
   36 Parameter ( \\1 bis \\9 und \\a bis \\z ) sind maximal möglich.

25 Kann das trackdisk.device nicht öffnen

26 Argumentenpuffer ist übergelaufen
   Argumente sind in den meisten Fällen auf 128 Zeichen beschränkt.

27 Fehlerhafte Registeliste
   Gültige Registerlisten:
   d0-d3  d3-d4/a2  d2/d3/a4-a6  d7  a0/d2  d2-6/a0-4

28 Vermisse die Sprungmarke
   Die Direktive benötigt eine Marke (Label).
   Beispiel: EQU <exp>   -> Error 28

29 Illegales Trennzeichen für eine Registerliste
   Gültige Trennzeichen sind '-' und '/'.

30 Für ein lokales Symbol sind SET, MACRO, XDEF, XREF und PUBLIC nicht
   erlaubt

31 Kein Register (versuchen Sie d0-d7, a0-a7 oder sp)

32 Zu viele ')'

33 Unbekannter Adressierungsmodus
   Siehe @{"Standard Adressierungsarten" link stdaddr} und @{"Erweiterte Adressierungsarten" link extaddr}
   für eine genaue Beschreibung aller möglichen Adressierungsarten.

34 Adressierungsmodus wird nicht unterstützt
   Beispiel:   move.b  d0,a1  /  move  usp,d2  /  clr.w  (d3)+  -> Error 34

35 Makro darf nicht im Operanden stehen

36 Undefiniertes Symbol

37 Vermisse Register
   Beispiel:   mulu   d0,   -> Error 37

38 Benötige ein Datenregister

39 Benötige ein Adressregister

40 Word an ungerader Adresse
   Beispiel:  dc.b "Hallo"
              dc.w 0        -> Error 40
   Fügen Sie ein CNOP 0,2 oder EVEN nach String-Konstanten ein.

41 Syntaxfehler im Operanden

42 Relozierungsfehler
   Beispiel:  move.l  label(pc),d0  , wobei Label keine Adresse aus der
    aktuellen Section ist.  -> Error 42

43 Zu große Distanz
   Beispiel:   move.w  50000(a0),d0   -> Error 43
   Zu große Distanz bei indirekter Adressierung oder einem Branch-Befehl.
   Byte-Branches haben eine Reichweite von +126/-128 Bytes. Word-Branches
   haben eine Reichweite von +32766/-32768 Bytes.

44 Distanzwert erwartet
   Beispiel:   label: move.l  label(a2),d1   -> Error 44

45 Gültige Adresse erwartet

46 Vermisse Argument

47 Benötige numerisches Symbol

48 Distanz ist außerhalb der Section
   Beispiel:   bra  label   , wobei label in der aktuellen Section undefi-
   niert ist:  -> Error 48

49 Nur eine Distanz erlaubt
   Ausdruck darf nicht mehrere Distanzen beinhalten.
   Beispiel:   move.l  #(label1-label2)+(label3-label4),d0   -> Error 49

50 Vermisse Klammer

51 Ausdrucksstapel ist übergelaufen
   Maximal 128 Argumente sind pro Ausdruck möglich.

52 Adressen können nicht negiert werden

53 Distanz und Reloc-Adresse dürfen nicht im selben Ausdruck stehen
   Beispiel:   move.l  #(label1-label2)+label3,d0   -> Error 53

54 Fehler beim Shiften (nur abs. Ausdrücke oder Distanzen erlaubt)
   Beispiel: 1<<-1               -> Error 54
            label<<1             -> Error 54

55 Adressen können nicht multipliziert werden
56 Überlauf während Multiplikation
57 Adressen können nicht dividiert werden
58 Division durch Null
59 Logische Operation mit Adressen sind illegal
60 Für eine Distanz werden zwei Adressen benötigt
61 Adressen können nicht summiert werden

62 Schreibfehler

63 Kein Byte-, Word- oder Longword String
   Beispiel:   dc.d "XYZ"   -> Error 63

64 XREF kann nicht subtrahiert werden
   Erlaubte Operationen mit XREFs: ext + abs , abs + ext  und  ext - abs

65 Im absoluten Modus unmöglich
   Folgende Direktiven können im absoluten Modus nicht verwendet werden:
   ttl, code, cseg, data, dseg, bss, section, xref, nref, xdef, public

66 Unbekannter Fehler (Fataler Programmfehler)
   Teile des Assemblers oder seines Speicherbereichs wurden durch ein
   fehlerhaftes Programm, das zur selben Zeit lief, zerstört.

67 Externe Symbole sind im absoluten Modus nicht möglich
   Siehe Fehler 65.

68 Außer Reichweite
   Beispiel:   addq.l  #9,d1   -> Error 68

69 Assemblierungs abgebrochen
   Wird durch die FAIL Direktive hervorgerufen.

70 Vermisse ENDC/ENDIF

71 Vermisse den Makronamen

72 Vermisse ENDM

73 In einem Makro ist keine weitere Makrodefinition möglich

74 Überflüssiges ENDM

75 Überflüssiges ENDC/ENDIF

76 Im relativen Modus nicht möglich
   Folgende Direktiven können im relativen (relocatiblen) Modus nicht
   benutzt werden: org, file, load, trackdisk.

77 Parameterpuffer ist übergelaufen
   Makroparameter dürfen maximal 127 Zeichen enthalten.

78 Ungültiger REPT Zähler
   Der Startzähler für REPT sollte nicht negativ sein.

79 Kann Datei nicht erzeugen
   Vielleicht ist die Zieldiskette schreibgeschützt.

80 Für eine Referenztabelle muß ein Listing File existieren
   Der XREFS Schalter wurde ohne den LIST Schalter gesetzt.

81 Hier ist keine Adresse erlaubt
   Beipspiel:   ds.l label   -> Error 81

82 Symbol enthält ungültige Zeichen
   Siehe auch Fehlermeldung 22.

83 Quelltext ist zu lang (maximal 65535 Zeilen)

84 Fließkomma ohne die erforderlichen Mathe-Libraries ist nicht möglich
   Um Fließkommasymbole zu benutzen, müssen sich die folgenden Libraries in
   Ihren LIBS: Verzeichnis befinden:
      mathtrans.library, mathieeedoubbas.library, mathieeedoubtrans.library

85 Überlauf während Fließkommaberechnung
   Meistens geschieht dies, wenn das Ergebnis eines Fließkommaausdrucks
   in einen Fließkommatyp niedrigerer Präzision konvertiert werden muß,
   z.B. nach FFP oder Single Precision.

86 Fließkommaausdruck enthält ungültigen Symboltyp
   Benutzen Sie keine relozierbaren Symbole in Fließkommaausdrücken.

89 Symboltyp darf mit SET nicht geändert werden
   Beispiel: symbol   set.d    3.14159265
             symbol   set.x    -0.1        -> Error 89
   Der Wert eines SET-Symbols ist variabel, aber nicht sein Typ!

90 LOAD, FILE und TRACKDISK können nicht gemischt verwendet werden
   Beispiel:  load $70000
              file "mycode"   -> Error 90

91 Near-Modus ist nicht aktiv
   Der Near-Modus muß, bevor man die INITNEAR Direktive verwendet kann, erst
   durch NEAR aktiviert werden.

92 Instruktion mit eingestellter MACHINE nicht möglich
   Die Instruktion existiert für einen anderen Prozessortyp, aber nicht für
   den gerade eingestellten. Benutzen Sie MACHINE um dies zu ändern.

93 Ungültiger Scale Faktor
   Beispiel:    move.w  (a1,d2*3)    -> Error 93
   Erlaubt sind die Faktoren 1, 2, 4 und 8.

94 Vermisse einen Operanden
   Beispiel:    move.l  (a0)+        -> Error 94

95 Diese Section existiert nicht
   Dieser Fehler wird durch die Angabe einer falschen Sections-Nummer in
   der NEAR-Direktive verursacht.

96 Ungültiger RORG Offset
   Der relative Offset darf keine Adresse vor der gerade übersetzten Adresse
   sein.

97 Immediate-Operand ist außerhalb seines erlaubten Bereichs
   Beispiel:    move.b   #$1234,d0   -> Error 97

98 Vermisse ein ENDR
   Offene REPT-Schleife beim Verlassen des Quelltextes, einerInclude-Datei
   oder eines Makros, entdeckt.

99 Überflüssiges ENDR
   Für dieses ENDR existiert keine passende REPT-Direktive.

100 Maximale REPT-Verschachtelungstiefe überschritten
   Die maximale Verschachtelungstiefe ist 255.

101 Name existiert schon als Direktive
   Es wurde ein Makro mit einem Namen definiert, der bereits von einer
   eingebauten Direktive oder Instruktion verwendet wird.

102 Maximale SAVE-Verschachtelungstiefe überschritten
   Die maximale Verschachtelungstiefe ist 8.

103 Überflüssiges RESTORE
   Für dieses RESTORE existiert keine passende SAVE-Direktive.

104 Vermisse ein RESTORE
   Am Ende des Quelltextes fehlt mindestens noch ein RESTORE.

@EndNode


@Node history "Entstehungsgeschichte / Literatur"
Nachdem ich sechs Jahre lang mit Assemblern wie SEKA, AS (Aztec-C) und A68k
gearbeitet habe, kam ich im Dezember 1991 zu dem Entschluß, daß ich einen
neuen mächtigeren Assembler benötige. Ich habe erst einige Zeit darüber nach-
gedacht, ob ich mir nicht O.M.A. oder Devpac kaufe, aber eigentlich mag ich
diese modernen Assembler mit einem integrierten Editor nicht besonders.
Weitere Gründe für den Startschuß zur Entwicklung von PhxAss waren mein
chronischer Geldmangel (da ich zu dem Zeitpunkt noch Student war) und die
Möglichkeit einen Assembler nach meinen persönlichen Wünschen zu schaffen
(meistens unterstützt ein Assembler ja immer gerade das nicht, was man
unbedingt benötigt :-).

Die Arbeiten an der ersten lauffähigen Version, V1.00, waren am 28.01.92 ab-
geschlossen. Von nun an konnte ich PhxAss dazu benutzen sich selber zu über-
setzen (vorher mußte ich A68k verwenden). Es kostete mich mehr als ein
Jahr und 23 Versionen um V3.00 zu erreichen und beinahe weitere zwei Jahre
und 52 Versionen für V4.00 (natürlich war PhxAss in diesem Zeitraum nicht
mein einziges Projekt).


Es folgt eine Liste meiner Hardware und Literatur, wodurch die Entwicklung
von PhxAss ermöglicht wurde:

Hardware:  Mein guter, alter A1000 (Rev.1 mit Piggyback von '85) mit 
           68010 CPU, 2 MB Fast-RAM und eine 33 MB Harddisk.
           (seit Dezember '93:) A4000, 68040, 18 MB RAM, 3 GB Harddisk.
           (seit Oktober '97:) A3000, CSPPC 68060/50 und PowerPC 604e/200,
           82 MB RAM, 4 GB UW-SCSI und eine Vielzahl an SCSI2 Geräten.

Literatur: Motorola MC68000/68008/68010/68HC000 8-/16-/32-Bit Microprocessor
           User's Manual (Prentice Hall)

           Motorola MC68020 32-Bit Microprocessor User's Manual (Prentice
           Hall)

           Motorola MC68040/68EC040/68LC040 Microprocessor User's Manual
           (Motorola)

           Motorola MC68881/882 Floating-Point Coprocessor User's Manual
           (Prentice Hall)

           Motorola MC68851 Paged Memory Management Unit User's Manual
           (Prentice Hall)

           Motorola M68000,MC68020,MC68030,MC68040,MC68851,MC68881/882
           Programmer's Reference Manual (Motorola)

           Amiga ROM Kernel Reference Manual: Libraries & Devices (Addison-
           Wesley)

           Amiga ROM Kernel Reference Manual: Includes & Autodocs (Addison-
           Wesley)

           Amiga Intern (Data Becker)

           Amiga Intern Band 2 (Data Becker)

           The Amiga Guru Book (Taunusstein)
@EndNode


@Node acknow "Danksagungen"
Den folgenden Personen, die PhxAss intensiv getestet und durch konstruktive
Bug-Reports die Entwicklung beschleunigt haben, möchte ich meinen Dank
aussprechen:

   Fabien Campagne (F)
   Tim Rühsen                   SiliconSurfer@Blackbox.shnet.org
   Wojciech Czyz (PL)
   Thomas Hagen Johansen (DK)   tjohansen@thj.adsp.sub.org
   Matthias Bock                starfox@cow.mayn.de
   Christian Bauer              cebix@ng-box.wwbnet.de
   Dave Dustin (NZ)             dave@eclipsnz.manawatu.gen.nz
   Richard Körber               shred@chessy.aworld.de
   Christian Wasner             Christian.Wasner@hamburg.netsurf.de
   Mark Knibbs (USA)            markk@msmail01.liffe.com
   David Neale (GB)             david@reeve.demon.co.uk
   Andy Church (USA)            achurch@binx.mbhs.edu
   Volker Barthelmann           volker@vb.franken.de
   Jorma Oksanen (SF)           tenu@sci.fi
   Joop van de Wege (NL)        joop.vandewege@medew.ento.wau.nl
   Carsten Schlote              schlote@stud.uni-frankfurt.de
   Sam Jordan (CH)              sam_jordan@bluewin.ch
   Dave Jones (GB)              djones@cardiffcybercafe.co.uk
   Miguel Mendez (E)            c950158@zipi.fi.upm.es


Schwedische Catalogs von:
   Marcus Geelnard (S)          e4geeln@etek.chalmers.se

Italienische Catalogs von:
   Simone Tellini (I)           Simone.Tellini@f502.n332.z2.fidonet.org

Dänische Catalogs von:
   Morten Holm (DK)             mortenh@viking.roskildees.dk

Französische Catalogs von:
   Georges Goncalves (F)        kersten_emmrich@ramses.telesys-innov.fr

Niederländische Catalogs von:
   Leon Woestenberg (NL)        leon@stack.urc.tue.nl

Ungarische Catalogs von:
   Attila Tajti (H)             tajtia@info.pmmf.hu

Norwegische Catalogs von:
   Arild Kvalbein (N)


Ein weiterer Dank geht an Commodore und seine ehemaligen Mitarbeiter:

Danke für den einzigen Computer der heutigen Zeit, mit dem das Arbeiten
wirklich noch Spaß macht :-)
@EndNode


@Node bugs "Bekannte Fehler in Version V4.39"
o Die Vorwärts-Branch Optimierung (T-Schalter) kann nicht sämtliche Zeilen-
  adressen im Listing File, die sich dadurch verschoben haben könnten,
  korrigieren.

o DC.B "xyz''abc" wird fälschlicherweise zu "xyz'abc".

o Die Benutzung extrem großer Extended Precision Zahlen in
        fmove.x #xxx.yyyEzzz,FPn
  führt zu einem Overflow Error, da alle Fließkommazahlen erst nach
  Double Precision konvertiert werden müssen. Es gibt leider keine
  Math-Library für Extended Precision und ich habe nicht vor, User
  ohne FPU auszuschließen.


Wenn noch irgendwelche Fehler oder Fragen auftauchen sollten, schreiben
Sie an :

                        @{"Meine Adresse" link author}
@EndNode


@Node author "Meine Adresse"

SMail:                  Frank Wille
                        Auf dem Dreische 45
                        32049 Herford
                        DEUTSCHLAND

EMail:                  frank@phoenix.owl.de

World Wide Web:         http://home.owl.de/~frank/phxass.html
                           _
                        _ //
                        \\X/  A M I G A   F O R E V E R  !
@EndNode
