@database PhxMacros.guide
@author "Richard Körber"
@(c) "1996-97 Richard Körber - all rights reserved"
@$VER: phxmacros.guide V1.5 (27.2.97) [English]
@wordwrap
@width 80
@Node Main "PhxMacros: Table Of Contents"

                        _                _ _    _
                       |_)|_ \\/  |\\/| /|/ |_)/\\(_
                       |  | )/\\  |  |/-|\\_| \\\\/ _)


                         == TABLE OF CONTENTS ==

                @{" General Notes                    " link General}
                @{" Copyright                        " link Copyright}

                @{" Meta Instructions                " link Meta}
                @{" FPU Meta Instructions            " link FPUMeta}
                @{" Assembler Compatibility          " link AsmCompat}
                @{" Data Definitions                 " link DataDef}
                @{" String Operation                 " link StringOp}
                @{" Amiga Macros                     " link Amiga}
                @{" Miscellaneous Macros             " link Misc}

                @{" History                          " link History}

    © 1996-97 Richard Körber -- all rights reserved
    PhxAss is © 1991-97 by Frank Wille

@EndNode
@Node General "PhxMacros: General Notes"

 GENERAL NOTES
***************

· This macro library REQUIRES some special abilities of PhxAss
  Version 4.33 or higher, for full functionality. Some macros may
  cause trouble or produce errors on other assemblers or older
  PhxAss versions.


· The "peek" macro has been renamed to "top" ("peekm" is now called
  "topm"). The new name is commonly used in the computer world for
  this purpose. Please fix your sources if you've used this macro.
  I promise that this will be the first and last name change.

@EndNode
@Node Copyright "PhxMacros: Copyright"

PhxMacros are © 1996-97 by Richard Körber. All Rights Reserved.

This Macro collection is FreeWare!

This archive may be distributed freely as long as the archive  remains
complete  and unchanged. You are allowed to charge a maximum fee of DM
8 (or equivalent)  to  cover  all  costs  including  media.  Otherwise
written  permission  from  the  author is required. The package may be
compressed by the usual (and free)  programs  (like  lha,  lzh,  lzx).
Single files of the package must not be compressed!

I allow the Fred Fish library and AmiNet to include  this  package  on
their  CDs.  Permission is also granted to Frank Wille to include this
package in his PhxAss package.

The archive consists of the following files:

· PhxMacros.i                   The macro library
· PhxMacros.guide               This guide file

Usage for fascist or military purposes is FORBIDDEN!

You use this package "as is" and at your own risk. The author (Richard
Körber)  is not responsible for any damage, including (but not limited
to) hard- or software damages or data loss.

Please delete this archive and all related files *NOW* if  you do  not
agree with these copyright notes.


For questions, bug reports, suggestions and all that jazz, please get
in contact with me via E-Mail:

        shred@chessy.aworld.de

If this E-Mail address should trouble, you can also try to reach me at:

        shred@eratosth.dssd.sub.org     (Germany only!)

You may also want to visit my home page:

        http://www.is-koeln.de/einwohner/shred



    PhxAss is © Frank Wille (e.g. AmiNet)

    AmigaGuide is © Commodore-Amiga. (e.g. Fish Disk #920)

@EndNode
@Node Meta "PhxMacros: Meta Instructions"

 META INSTRUCTIONS
*******************

Meta instructions (also called Pseudo Commands) behave like real 680x0
instructions, yet they are emulated by a macro.


inc.? <ea>      Increments the <ea> by one.

                Examples:       inc.b   d0
                                inc     (a0)


dec.? <ea>      Decrements the <ea> by one.

                Examples:       dec.b   d0
                                dec     (a0)


push.? <ea>     Pushes the <ea> to the stack. !!! Only .w or .l allowed !!!
                Attention: .b will be accepted without warning!

                Examples:       push    d0
                                push.l  (4,a0)


top.? <ea>      Read the top entry of the stack, without removing.

                Examples:       top     d0
                                top.l   (a4)


pop.? <ea>      Pops from the stack. !!! Only .w or .l allowed !!!
                Attention: .b will be accepted without warning!

                Examples:       pop     d0
                                pop.l   (a3)


pushm.? <set>   Pushes the register set to the stack. !!! Only .w or .l !!!

                Example:        pushm.l d0-d3/a0-a3


topm.? <set>    Read the top register set of the stack, without removing.

                Example:        topm.l  d0-d3


popm.? <set>    Pops a register set from the stack. !!! Only .w or .l !!!

                Example:        popm.l  d0-d3/a0-a3


store           Stores the registers d0-d7 and a0-a6 on the stack.


recall          Restores the registers d0-d7 and a0-a6 from the stack.


r<cc>           Conditional rts. You may use all the standard condition
                codes.

                Examples:       req
                                rvs


bsr<cc>.? <a>   Conditional branch to subroutine. You may use all the
                standard condition codes. Branch optimizer works here
                as usual.

                Examples:       bsreq.b near_eq
                                bsrvs   vs_error
                                bsrhi.l far_hi     ; 68020+ only


flip.? <data>   Flips the data register <data> between big endian and
                little endian. Only .w or .l allowed.

                Examples:       flip.l  d0
                                flip    d3


extbl <data>    Sign extends the data register <data> from byte to
                longword. The extb.l instruction will be used by this
                macro if MACHINE 68020 or higher is set.

                Example:        extbl   d0


clra.? <adr>    Clears an address register. Only .w or .l allowed.
                Important: condition codes will not be affected!

                Example:        clra.l  a0

@EndNode
@Node FPUMeta "PhxMacros: FPU Meta Instructions"

 FPU META INSTRUCTIONS
***********************

FPU meta instructions behave like real FPU instructions, yet they are
emulated by a macro.


fpush.? FPn     Pushes the FPn register to the stack.

                Examples:       fpush.l fp0
                                fpush.x fp3


ftop.? FPn      Read the top entry of the stack into the FPn register,
                without removing.

                Examples:       ftop.w  fp0
                                ftop.x  fp4


fpop.? FPn      Pops from the stack into the FPn register.

                Examples:       fpop.d  fp0
                                fpop.x  fp0


fpushm <set>    Pushes the float register set to the stack. Extended
                resolution will be taken automatically.

                Example:        fpushm  fp0-fp2


ftopm <set>     Read the top float register set of the stack, without
                removing. Always extended resolution.

                Example:        ftopm   fp3-fp4


fpopm <set>     Pops a float register set from the stack. Always extended
                resolution.

                Example:        fpopm   fp1-fp2


fstore          Stores the float registers fp0-fp7 on the stack, using
                extended resolution.


frecall         Restores the float registers fp0-fp7 from the stack.

@EndNode
@Node AsmCompat "PhxMacros: Assembler Compatibility"

 ASSEMBLER COMPATIBILITY
*************************

These Macros provide compatibility to other assembler, like Seka,
DevPac or AsmOne. Please note that they are obsoleted. Don't use
them in new code!


align <val>     Aligns the address counter to a multiple of <val>.
                (Seka, DevPac, AsmOne)

                Example:        align   4       ;Align to long word


odd             Opposite of 'even': aligns to an odd address.
                (Seka, DevPac, AsmOne)


pushem.? <set>  Pushes the register set to the stack. !!! Only .w or .l !!!
                (DevPac)

                Example:        pushem.l d0-d3/a0-a3


popem.? <set>   Pops a register set from the stack. !!! Only .w or .l !!!
                (DevPac)

                Example:        popem.l  d0-d3/a0-a3


db <val>[,<val>...]
dw <val>[,<val>...]
dl <val>[,<val>...]
                These macros are equivalent to dc.b, dc.w and dc.l .
                (DevPac ?)

                Example:        db      "Hello, world!",0

@EndNode
@Node DataDef "PhxMacros: Data Definitions"

 DATA DEFINITIONS
******************

The following macros will define strings or data in the DATA section.
Note that all strings will automatically be 0 terminated.


leastr <string>,<adr>
                The string <string> is created in the DATA section. A
                pointer to this string is provided in the address register
                <adr>.

                Example:        leastr  "dos.library",a1


peastr <string>  The string <string> is created in the DATA section. A
                pointer to this string is provided on the stack. This is
                useful for e.g. taglist construction on stack.

                Example:        peastr  "TestWindow"
                                pea     WA_Title


defstr <label>,<str>
                Defines the string <str> in the DATA section and references
                it by <label>.

                Example:        defstr  dosname,"dos.library"


def.? <label>[,<label>...]
                Defines label with the size ? and value 0 in the BSS section.

                Examples:       def.l   sysbase,dosbase,gfxbase
                                def.b   flag1,flag2,flag3

@EndNode
@Node StringOp "PhxMacros: String Operation"

 STRING OPERATION
******************

String operation macros provide instruction for easy string handling.
Important: the default size of these macros is WORD !

copy.? <src>,<dest>
                Copies the string from source to destination. The copy
                process is terminated after 0 has been copied. None of
                the provided registers will be stored!

                Examples:       copy.b  (a0)+,(a1)+
                                copy.l  (a0)+,-(sp)


strln.? <str>,<lenreg>
                Finds out the string length of the string provided by
                the address register <str>. The length is returned in
                the address/data register <lenreg>. Except for the
                <lenreg>, no registers will change its contents. The
                length includes the termination and is divided by
                2 (4) if word (longword) size was used.

                Examples:       leastr  "Teststring",a0
                                strln.b a0,d0   ;Length is in d0
                                strln.l a1,d0   ;Number of e.g. tags

@EndNode
@Node Amiga "PhxMacros: Amiga Macros"

 AMIGA MACROS
**************

These macros require the Amiga custom chip set. You may especially
use them with the hardware/#? include files provided with the PhxAss
packet.

Annotation from the author: please try to write system friendly
software whereever possible! This macros are ONLY for demo/intro and
game purposes. You should never need to use them in tools.


clrrg <hwregister>
                Clears a custom chip register. It will use clr on
                68010+ while using move #0 on 68000 processors.
                Always word size.

                Examples:       clrrg   COLOR00
                                clrrg   $180


setrg.? <ea>,<hwregister>
                Sets the custom chip register with the <ea>.
                !!! Only .w and .l allowed !!!
                Attention: .b will be accepted without warning!

                Examples:       setrg.w d0,COLOR00
                                setrg.l (a0)+,BLTAPT


getrg <hwregister>,<ea>
                Reads the custom chip register to <ea>.
                Always word size.

                Examples:       getrg   INTENAR,d0
                                getrg   DMACONR,old_dma


trigger <hwregister>
                Triggers a strobe custom chip register.

                Example:        trigger COPJMP2


keycode <datareg>
                Decodes a keycode as received from the Amiga keyboard.
                Z and N flags are set accordingly to the result.
                Always byte size.

                Example:        keycode d0



The following macros are useful for writing copper lists:

copinit         Initializes a copper list. You must always use this
                macro as first copper command! In fact, this macro just
                initializes some internal variables, but writes no single
                byte of code.


copbfe          Blitter finish enabled: copwait and copskip will also
                wait for blitter to finish.


copbfd          Blitter finish disabled: copwait and copskip will not
                wait for blitter to finish. This is the default.


copmove <data>,<hwreg>[,<data>,<hwreg>...]
                Write the data into the custom chip register. Note that
                the source is on the left and the destination is on the
                right!

                Examples:       copmove $00F0,$0180
                                copmove $0000,COLOR00,$0FF0,COLOR01


copline <vp>    Wait for the scan line number. If <vp> is greater than
                256, coppal will automatically be inserted.

                Example:        copline 80
                                copline 302


copwait <hp>,<vp>[,<hpm>,<vpm>]
                Wait for the scan line and column. If provided, mask will
                also be used. Waits for blitter if enabled. If <vp> is
                greater than 256, coppal will automatically be inserted.
                Note that the horizontal position comes first!

                Example:        copwait 28,80
                                copwait 28,80,$FF,$FF


copskip <hp>,<vp>[,<hpm>,<vpm>]
                Skip next command if past this scan line and column. If
                provided, mask will also be used. Waits for blitter if
                enabled. If <vp> is greater than 256, coppal will auto-
                matically be inserted. Note that the horizontal position
                comes first!

                Example:        copskip 28,80
                                copskip 28,80,$FF,$FF


coppal          Wait for the end of the 255th scan line. All further waits
                refer to the lower part of a PAL screen. This macro is
                executed only once per copper list.

                Example:        coppal


copend          Finishes a copper list.

                Example:        copend


This is an example of a copper list, using these macros:

coplist:        copinit                 ; always the first command!
                copbfd                  ; default, not necessary
                copmove $0008,COLOR00,$0000,COLOR01
                copline 40
                copmove $0000,COLOR00
                copline 126
                copmove $0F00,COLOR00
                copline 212
                copmove $0FF0,COLOR00
                copline 300             ; coppal inserted automatically
                copmove $0008,COLOR00
                copend

@EndNode
@Node Misc "PhxMacros: Miscellaneous Macros"

 MISCELLANEOUS MACROS
**********************

These are frequently used macros for miscellaneous purposes.


proc <name>,<set>
                Defines a procedure header. The procedure is called
                <name> and stores the register set <set> on the stack.

xproc <name>,<set>
                Like proc, but the procedure name is also referenced
                using XDEF <name>.

endp <name>     Terminates a procedure. The register set is restored,
                and the procedure returns by ret instruction.

                Example:        proc    testprog,d1-d3/a0-a3
                                ; your procedure
                                endp    testprog


args <arg>[,<arg>...]
                Pass a list of arguments to the stack. All arguments
                will be longwords! After this operation, the stack
                pointer points to the first provided parameter.

margs <arg>[,<arg>...]
                Puts more arguments to the stack. Note that even though
                the parameters seem to be in right order (in fact, the
                macro reads them from the right to the left), you have
                to pass the last parameter list first, using "args",
                and then use "margs" in backward order.

unargs          Removes the parameters provided by "args" and "margs"
                from the stack. The "unargs" macro always refers to the
                last "margs" macro calls up to the first previous "args"
                macro call. IMPORTANT: Do not nest "args" and "unargs"
                calls! Always use "unargs" *below* the appropriate "args"
                and "margs" in your source code!

                Example:        args    #TAG_DONE       ; Note that they
                                margs   #WA_InnerHeight,d1 ; must be
                                margs   #WA_InnerWidth,d0  ; upside down!
                                move.l  sp,a1           ; Parameters in A1
                                ; use the args
                                unargs

@EndNode
@Node History "PhxMacros: History"

 HISTORY
*********

V1.5 (27. 2.97)
        - Minor spelling corrections and improvements in the guide file
        - Added "fpush", "ftop", "fpop", "fpushm", "ftopm", "fpopm",
          "fstore", "frecall", "clra"

V1.4 (14. 2.97)
        - Added "db", "dw" and "dl", for compatibility
        - Added the Amiga macros

V1.3 (21.10.96)
        - Renamed "peek" and "peekm" to "top" and "topm".
        - Reviewed the corrections from Frank Wille.
        - Now uses the "def2" macro from Frank as "def" macro.
        - Added "args", "margs", and "unargs".

V1.2 (14.10.96) [by Frank Wille]
        - Removed IFCPU macro.
        - Fixed ODD macro.
        - Fixed FLIP macro.
        - Fixed EXTBL macro.
        - Added "def2" macro as improvement for "def".

V1.1 ( 9. 9.96)
        - Added conditional bsr and conditional rts.
        - Added "proc", "xproc" and "endp".
        - Added "pushem" and "popem" for assembler compatibility.
        - Added "copy" and "strlen".

V1.0 ( 28. 8.96)
        - First internal release.

@EndNode

