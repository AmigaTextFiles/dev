@DATABASE  "IN_GO Dokumentation

@NODE MAIN "IN_GO 3.1 REASSEMBLER DOKUMENTATION"
 @{"Was ist In_Go           " LINK WAS}
 @{"Sinn & Zweck            " LINK ZWE}
 @{"Tutorium1               " LINK TU1}
 @{"Einleitung              " LINK EIN}
 @{"Installation            " LINK INS}
 @{"Voraussetzungen         " LINK VSE}
 @{"Häufige Fragen          " LINK HFR}
 @{"Glosar                  " LINK GLO}
 @{"Menü                    " LINK MEN}
 @{"Copyright & Distribution" LINK COP}
 @{"Updates                 " LINK UPD}

 @{"Autor                   " LINK AUT}
 @{"Wo ich Hilfe benötige ! " LINK HME}
 @{"Dank an ...             " LINK DAN}

@ENDNODE

@NODE TU1 "Tutorium1"

 Da immer wieder die gleichen Fragen auftauchen habe ich mich entschieden
 Ein kleines Programm zu schreiben welches die Funktion von In_Go verdeutlicht.
 Text, Programm, Assemblertext finden Sie im Verzeichnis Tutorium.

@ENDNODE

@NODE HFR "Häufige Fragen zu In_Go" 
@{"Wie kann ich In_Go mitteilen daß ein Bereich Code beinhaltet ?  " LINK CODEBESTIMMEN}
@{"Wie kann ich In_Go mitteilen daß ein Bereich Data enthält    ?  " LINK REASSEMBLERFEHLER}

@ENDNODE

@NODE REASSEMBLERFEHLER "Wie wird Data bestimmt"

  @{u}Wie kann ich Code in Data umwandeln@{uu}

  Dies sollte normalerweise nur nach einem Reassemblerfehler auftreten !
  Daher es wird Code (überwiegend schwarz) angezeigt, obwohl der Bereich als Data von Ihnen 
  erkannt wurde !
  @{b}Gehen Sie mit der Aktuellen Zeile auf den Anfang des falschen Codebereiches,
  Wählen Sie nun im Editmenü `Mache Code zu Data von AL an`;
  Nun wir der @{u}ganze Bereich@{uu} danach wieder in Data verwandelt. @{ub}
  @{ub}Dies sollte nur im Notfall angewendet werden !  

@ENDNODE

@NODE CODEBESTIMMEN "Wie wird Code bestimmt ?"

  @{u}Wie kann man In_Go mitteilen daß ein Bereich Code oder Data beinhaltet ?@{uu}

  In_Go kennt nur Code-Bereiche, der Rest wird als Data betrachtet ! 
  Nach erstmaligem Laden existieren keinerlei Code-Bereiche (Anzeige gelb ) !
  In_Go zeigt zwar den Code an (gelb) er ist jedoch noch nicht bearbeitet !
  Durch Drücken der `Space` Taste wird die eigentliche Reassemblierung (Bearbeitung !) gestartet .
  Nun durchforstet In_Go die geladene Quelle von der Startadresse (Segment 0, Offset 0 ) beginnend. 
  Dabei werden immerzu neue Code-Bereiche gefunden. Nach einiger Zeit stopt In_Go,
  weil alle direkten Aufrufe gefunden sind hörbar mit einem Beep. 
   
  Erkannter Code wird schwarz ( Wenn sich keine andere Farbänderung ergibt) ausgegeben .
  Mit `d` können Databereiche als Data @{u}oder@{uu} als Code ausgegeben werden
  (`d` schaltet Ein und Aus )!

  @{b}Wenn ich nun die Aktuelle Zeile auf den Anfang eines unerkannten Codebereiches stelle,
  wird mit Amiga Taste + `j` in der Aktuellen Zeile die Reassemblierung erneut gestartet.

  Der Bereich wird nun von In_Go als Code betrachtet !
  Dies ist mit Vorsicht anzuwenden !@{ub}

@ENDNODE

@NODE WAS "Was ist In_Go"

 Wenn Sie nicht wissen was ein Reassembler ist dürfte dieses Programm
 relativ uninteressant für Sie sein.@{uu}
 
 Mit In_Go können Sie Programme in die kleinsten Schritte der Programierung
 auflösen. Diese Sprache der kleinsten Schritte bezeichnet man als `Assembler`
 Nach der Reassemblierung (Rückübersetzung),kann ein Textfile erzeugt werden,
 welches von einem geeigneten Übersetzungsprogramm wieder in lauffähigen Code
 umgewandelt werden kann.
 Das sind keine einfachen Zusammenhänge ! 
 Wenn Sie damit nicht vertraut sind . . . Finger weg (Reise nach Indien) !   
 Weitere Informationen finden sie in der @{"Einführung" LINK "EIN"}   

@ENDNODE

@NODE EIN "Einführung"

@{u}Rekonstruktion@{uu}

Stellen sie sich vor: Sie finden in Griechenland die Hand einer Statue,
und wollen nun `anhand` dieser Information die Statue rekonstruieren.
Ein ähnliches Problem versucht In_Go zu lösen.
Dabei können Sie entscheidend mitwirken.

@{u}Drama: Die Jungfrau und der Hammer@{uu}

Wie jedes andere Werkzeug können Sie auch In_Go mißbrauchen.
Sie Können sich Einblicke in anderer Leute Programm verschaffen
( die Jungfrau mit dem Hammer erschlagen ), aber auch Ihre eigenen
Machwerke `durchsichtig` machen.
Die meisten größeren Programme werden ja Heute in Compilersprachen
geschrieben. Hier kommt es nicht selten zu merkwürdigen Problemen
infolge falschen Implementationen.
In_Go ermöglicht Ihnen nun einen Einblick auf unterster Ebene, dabei
können Sie auch laufende Tasks beobachten, und deren Variablen auslesen.

@{u}Was kostet die Welt ?@{uu}

2.147.483.647 das ist die größte vorzeichenbehaftete Zahl die der
68000er intern verarbeiten kann: der implementierte Kalkulator von
In_Go beherscht diesen Bereich mit ca. 40 verschiedenen logischen und
arithmethischen Funktionen.

@{u}Zeige mir den Zeiger@{uu}

Die erste Betrachtung des Reassemblercodes führt oft zu Entäuschungen;
man kann insbesondere die indirekten Zugriffe über die Adressregister,
zb. CLR -$7800(A5) nicht richtig zuordnen. In_Go kann diese Adressen
richtig zuordnen, wenn die Basis eine Konstante ist. Für A6 jedoch
können nur positive Werte verarbeitet werden, negative werden ja als
Libraryaufruf interpretiert.
Zusätzlich können die gültigen Bereiche für diese Auslegung begrenzt
werden.

@{u}Wohin soll Das noch führen ?@{uu}

Nach dem Laden, (D)Reloc_32 und Namen werden eingelesen, kann durch
Anwahl von `Disassemble` (Space !) die Reassemblierung gestartet werden.
Dabei wird von der Startadresse an versucht, die Codeteile zu finden.
Beim einlesen von `RTS` oder JMP` wird die Reassemblierung an anderer
Stelle fortgeführt. Dabei werden immerzu neue Labels und Bereiche
gefunden bis auch der letzte direkte Aufruf bearbeitet ist. In den
meisten Fällen ist nun keineswegs das ganze Programm decodiert,
da In_Go bei den gefundenen Adressen eine strenge Prüfung vornimmt
und nur ausdrückliche ( BSR, BRA, Bxx, JSR, JMP ) Sprungadressen
automatisch reassembliert. Verschiedene Codebereiche bleiben bei
diesem Algorithmus unentdeckt. Mit hilfe von `n` können solche
Bereiche gefunden werden und, interaktiv, durch Amiga + `j`
reassembliert werden.

@{u}Wer ist tabellensüchtig ?@{uu}

Tabellen kommen in manigfaltigen Variationen vor. In_Go bietet geeignete
Instrumente zum finden und einlesen derselben:
- relative Wortreferenzen zu einer Basisadresse, die Basisadresse
  muß dabei nicht identisch mit dem Tabellenanfang sein,
  dies wird jedoch als der Normalfall angesehen.
- absolute Langwortadressen.
- selbstbezügliche Wortreferenzen.
- Labelerzeugung in eingestellter Distanz.
- Verkettete Listen mit unterschiedlich langen Elementen.
Die Distanzen können in 2 Byte Abständen frei gewählt werden.
Die Ausgabe im Display zeigt dabei in welcher Form die Labelcreation
zustande kam: zB. dc.w L100-L103+2
Sie können auch die Labelart der errechneten Label bestimmen !
Da solches Tun den höheren Künsten zuzurechnen ist, kann
In_Go ca 100 verschiedenartige Tabellen erkennen !

@{u}Wie heißt das Kind ?@{uu}

Sie können jede Adresse innerhalb der Quelle benennen.
Die Programmzeile kann mit einem Komentar versehen werden.
Libraryaufrufe werden @{b}nach@{ub} Festlegung der Basen als Mnemonics
angezeigt. Die Lerne Funktion unterstützt Sie bei der Namensgebung
jener kleinen Librarysubroutinen die für viele Kompilate
typisch sind, der Name wird dabei erweitert.

@{u}Wie wärs mit Abschalten ?@{uu}

Wenn Sie die Bearbeitung zu einem anderen Zeitpunkt fortführen
wollen, können Sie Ihre Geistesblitze abspeichern,
dies ist auch bei Tasks möglich !

@{u}Doch er fand das Label nicht....@{uu}

Mit dem implementierten Sucher kann fast alles, auch indirekte und
relative Aufrufe gefunden werden. Die Suche kann auf das momentane
Segment begrenzt werden. Ein Menü hilft Wichtiges (Openlibrary)zu finden.
Da In_Go keine Texte im Hintergrund bereithält kann ein Ausdruck wie
`add #5,d0` nur in der Form seines Opcodes gefunden werden !

@{u}Und wer will mich ?@{uu}

Nach erfolgreichem Reassemblieren liegen alle Referenzen vor.
Bewege ich nun den Zeilenkursor auf ein bestimmtes Label,
kann mit `r` ein Requester aufgerufen werden der alle Aufrufe
Dieser Adresse ausgibt.
Nur durch Reloc_32 gefundenen Label bleiben unberücksichtigt.

@{u}Ich würde es ja verstehen: Wenn ich nur die Source hätte !@{uu}

Dem kann abgeholfen werden: Nachdem möglichst alle Codebereiche
gefunden wurden, kann ein Textfile erzeugt werden.

@{u}Was heißt hier Früchte, ich will Bananen !@{uu}

Leider sind Assembler ziemlich unterschiedlich, Einige fordern dies,
andere geben bei jenem eine Fehlermeldung aus.
Daher sind verschiedene Assecoirs schaltbar.

@{u}Fehler über Fehler@{uu}

Beim Reassemblieren wird jeder nichterlaubte Opcode angezeigt.
In vielen Fällen kann so auch selbstmodifizierender Code gefunden
werden (Anzeige mit `e`).


@{u}Gehts nicht noch`n wenig kleiner ?@{uu}

Lokale Label zu erzeugen, ist alles andere als einfach. Dabei müssen
jegliche Zugriffe innerhalb Programms erkannt werden !
In_Go hats !

@{u}Jetzt hab ichs ! ... und weiß genau soviel wie vorher.@{uu}

Assembler Prgs sind oft nach Spagetti-Manier geschrieben: Da ein
Sprüngchen ... auf einen anderen Sprung der wiederum....usw
Wie soll man da zusammenhängendes erkennen ?
In_Go bietet die Möglichkeit lokale Label anzulegen !
Dieses mehr unscheinbare Tool hats in sich:
Zusammenhängendes wird nicht mehr auseinandergerissen...

@{u}Wie löß ich den Knoten ?@{uu}

Alle mit In_Go erzeugten Amigaguide-Files enthalten `Referenzen`
am Ende jeder Node, die fast alle Aufrufe dieser Node enthalten,
ausgenommen sind Aufrufe über einige Tabellen (selten !).
In Form eines Amigaguide-Files kann so eine kaum übertreffbare
Transparenz erreicht werden ! Guide Files können auch ohne
lokale Label ausgegeben werden, es mangelt jedoch an ... Transparenz.

@{u}Panne ? Hät` ich doch ein Reserverad !@{uu}

Viele Programme allocieren erst während des ablaufens Speicher,
in dem dann Variable angelegt und erwartet werden.
Da dieser Bereich dynamisch angelegt sein kann, scheitert
jeder Versuch einer absoluten lokalisierung..
Für solche Fälle können im F3 Requester Pseudo-Bereiche
angelegt werden. In diesen Pseudobereichen werden dann während
des Reassemblierens Variable angelegt die man auch benennen kann.

@{u}Jetzt wirst Du gelinkt@{uu}

Insbesondere `C` besorgt sich den Bereich für lokale Variablen
mit Hilfe von `Link` Ax ! Solche `Proceduren` können von In_Go
im `F3` Requester gesucht werden und als `Bereiche`
angelegt werden. Dies erfolgt weitgehend selbsttätig für
Register A4 - A6 , nach Anklicken der entsprechenden Option.

@{u}Unterprogramm... ins Nichts ?@{uu}

Manche Programme benutzen Fehlerroutinen (oder ähnliches !)
die mit Bsr oder Jsr aufgerufen werden, nach Aufruf jedoch wird
die Herkunftsadresse vom Stack genommen und zu einem anderen
Programmteil verzweigt. Wenn solche Label in der aktuellen Zeile mit
`Erzeuge Interruptlabel` Behandelt werden kann ein Reassemblerfehler
verhindert werden.

@{u}Reloc oder Dreloc, ist das Was von Shakespeare ?@{uu}

In_Go bietet die Möglichkeit ein lauffähiges Modul mit  Labeln und Namen
abzuspeichern. (Sie haben sich nicht verlesen !)
 Verschiedene Optionen werden unterstütz:

 - Nur eigene (spezifische) Namen in Code als Symbolhunk für einen Profiler
 - Alle eigenen Namen als Symbolhunk
 - Alle Label als Symbolhunk

 Optimierung Reloc_32 nach Dreloc_32 ist möglich wenn 
 die Offsets >=0 und <65500 sind, jedoch nur Global.
 Dies ist jedoch meist nur bei kleineren Prgs möglich ! 
Auch mit `In den Speicher schreiben` vorgenommene Änderungen werden
abgespeichert.  
( Jedoch bitte keine A_ Adressen oder (D)reloc_32 Einträge verändern ! )
Der Name des geladenen Prgs wird dabei mit `q` erweitert.

@{u}Das ROM als lauffähiges Programm ?@{uu}

Sicherlich das nicht; aber Überschaubarkeit. Die im Rom gelegenen
Libraries werden als Mnemonic angelegt (ca. 1000) dies sollte auch bei nach-
geladenen Kickstarts funktionieren. 

@{u}Indirekt indirekt - ist das ein Witz ?@{uu}

Nun jedenfalls gibt es das, und das kann einem ganz schön plagen,
da das eigentliche Sprungziel `verschleiert` ist.
Mit Einschalten von <indirekt indirekt` .... kein Problem.
Solche Fälle werden auch ins Amigaguidefile mit übernommen.

@{u}Enforce den Enforcer ?@{uu}

Der Enforcer kann Enforcerhits eines Prgs mit Hunk + Offset ausgeben,
wenn Segtracker installiert ist. 

Bei In_Go ist diese Adresse durch Umschaltung mit `z` leicht zu erkennen !

@{u}Kein Papagei ist so bunt !@{uu}

Farben erleichtern die Übersicht. Da läst sich schnell erkennen
ob dieses oder jenes in der Zeile ist. Das ist auch der Grund
weshalb In_Go einen Screen mit 8 Farben öffnet !
Farbliche Unterschiede finden sich auch in Assembler-Guidefiles.

@{u}So primitiv war noch kein Symbolprocessor !@{uu}

Aber doch.. er hilft einfache Sachverhalte zu erkennen.
Insbesondere erkennt er das Hin-und Herschieben im Processor.
Dies können Library-Basen sein oder ähnliches, die für eine
weitergehende Interpretation benötigt werden.

@{u}Darfs ein bißchen mehr sein ?@{uu}

Neuere Programme sind oft mit nur auf dem 68020 lauffähigen
Code versehen. Nach Einschalten der entsprechenden Option
werden diese richtig (Schreib `nen Brief wenn nicht !) decodiert.

@{u}Ich wills fließend...@{uu}

Viele Amigas besitzen einen Math-Coprocessor. Nach Einschalten
der entsprechenden Option werden diese Opcodes richtig zugeordnet.
Die gängigsten Real-Formate werden ebenfalls decodiert.

@ENDNODE

@NODE ZWE "Sinn & Zweck"


 @{b} Philosophie@{ub}

  Beim Interpretieren eines fremden Sachverhaltes tretten zwei
  grundsätzliche Prinzipien in Erscheinung:

  a) `Gewissheit`

  b) `Wahrscheinlichkeit`

  Fall a) ist langwierig, er erfordert die volle Durchmusterung
          der Quelle: Jeder Fall muß entschieden werden !

  Fall b) Es wird eine Interpretation nach der Wahrscheinlichkeit
          durchgeführt. - Dies kann jedoch zu Fehlern führen

  In_Go arbeitet nach dem zweiten Prinzip. Beispiel:

  movea.l $4,A6          ; 1.Stufe jetzt befindet sich _ExecBase in A6
  ....
  jsr     _LVOGetMsg(A6) ; 2.Stufe  Aufruf der Exec Library
  ....                   ; 3.Stufe Dieser Aufruf liefert
  ....                   ;   eine Message-Structur in D0
  movea.l D0,A0          ; 4.Stufe MessageStruktur nun auch in A0
  move.l seconds(a0),a2  ; 5.Stufe wäre nur bei einer Intuition_Msg
  .....                  ;   richtig. Bei einer WBStartup-Msg wäre
                         ;   sm_ArgList(a0) richtig !

  Sie sehen also, Fehler sind möglich....

  Richtige Namensgebung kann für eine automatische Interpretation
  nützlich sein !

  Beispiel:
            move.l Unser_Screen,a0

            der Preprocessor geht nun davon aus das a0 auf eine
            Screenstruktur zeigt.

  Durch den Kommentar `[d0]=_WBStartup` läßt sich ein Register des
  @{"Symbolischer Processor" LINK SYMPR}  richtigstellen !
  Der Kommentar ist jedoch erst in der Folgezeile wirksam.

  In_Go speichert keine Texte, die zur Ausgabe bereitgehalten werden,
  Der jeweilige sichtbare Text wird erst bei der Ausgabe erzeugt.
  Im Interpretationsfalle kann so von falschen Registerinhalten
  ausgegangen werden. Der große Vorteil einer solchen Handhabung:
  bearbeitbare Prgs können als Textfile wesentlich größer als der
  zur Verfügung stehende Speicher sein. Der Nachteil:
  Fehler bei der sichtbaren Ausgabe sind möglich !

  Übrigens auch dieser Text ist noch in Arbeit Stand April 97

@ENDNODE

@NODE COP "Copyright & Distribution"

 @{" COPYRIGHT " Link Copy1}

 @{" DISTRIBUTION " Link Copy2}

 @{" DISCLAIMER " Link Copy3}

 @{" SHAREWARE " Link Copy4}

@ENDNODE

@NODE Copy1 "COPYRIGHT"

 @{u}In_Go@{uu}
 ist copyrighted (C) 1996 by @{"Ingo Molter" Link AUT}.
 Das bedeutet, daß es @{b}NICHT ERLAUBT@{ub} ist,
 irgendeinen Bestandteil des Programms, der Anleitung
 oder sonst einem enthaltenen File in irgendeiner Weise
 zu verändern. Außerdem darf weder diese Anleitung noch
 ein anderes File aus dem Archiv gelöscht werden.

 Es ist @{b}NICHT@{ub} erlaubt, dieses Programm in einer
 anderen Weise zu benutzen, als es in dieser Anleitung
 beschrieben ist.
 In_Go ist @{"SHAREWARE" Link Copy4}!

@ENDNODE

@NODE Copy2 "DISTRIBUTION"

 @{u}In_go@{uu} darf frei kopiert werden.
 Das bedeutet, daß jeder dieses Archiv verbreiten darf,
 solange folgende Punkte erfüllt sind:

 - Das Archiv muß intakt bleiben, es ist @{b}NICHT ERLAUBT@{ub},
   irgendwelche Files aus diesem Archiv zu löschen
   oder hinzuzufügen.

 - Dieses Archiv darf frei über Mailboxen,
   das InterNet sowie über PD-Serien vertrieben werden.
   Der Vertrieb auf anderen Datenträgern bedarf
   meiner Genehmigung.

 - Disketten-Magazine oder Anbieter,
   die spezielle Gebühren für den File-Transfer verlangen
   dürfen das Archiv @{b}NICHT@{ub} ohne schriftliche
   Genehmigung von @{"Ingo Molter" Link AUT} verbreiten.
   Bei Aufnahme von In_Go in eine PD-Library,
   eine CD-ROM o.ä. würde @{"ich" Link AUT}
   mich sehr über ein Freiexemplar oder zumindest
   über eine Benachrichtigung freuen.

@ENDNODE

@NODE Copy3 "DISCLAIMER"

 Der Benutzer dieses Produkts übernimmt die @{b}VOLLE@{ub}
 Verantwortung für Schaden und Fehler aller Art,
 die durch die unsachgemäße Anwendung dieses Produkts entstehen
 könnten. Der Autor dieses Programms kann dafür @{b}NICHT@{ub}
 verantworlich gemacht werden.

@ENDNODE

@NODE Copy4 "SHAREWARE"

 Dieses Programm ist @{u}@{b}SHAREWARE@{ub}@{uu}.
 @{u}Frei kopierbar@{uu} bedeutet nur, daß es erlaubt ist,
 die unregistrierte Version des Programms zu kopieren.
 Das Programm darf für 30 Tage getestet werden,
 danach sollte man sich @{"registrieren LINK UPD} lassen.
@ENDNODE

@NODE INS "Installation"
 Einfach das In_Go Archiv  auf Ihren Datenträger ziehen
@ENDNODE

@NODE VSE "Voraussetzungen"
 Mindestens Kickstart 2.04
 Mindestens 2 MB Ram
@ENDNODE

@NODE AUT "Autor"
     Ingo Molter

     Dunzweilerstr.42
   D-66903 Dittweiler
     Tel. 06386-1312              
     Aber: Sende einen Brief !
@ENDNODE

@NODE UPD "Updates"
 Bitte senden Sie 30 Mark oder 20 $ an mich.
 Sie erhalten dann ein ausführliche Bedienungsanleitung !

  Ingo Molter
  Dunzweilerstr.42

  D-66903 Dittweiler

 Ich benötige jedoch auch @{"Hilfe" LINK HME}

@ENDNODE

@NODE HME "Wo ich Hilfe benötige"

  In_Go ist keineswegs perfekt
  Es wurde zwar ausgiebig getestet,
  
  Wenn Sie Einen Tip haben, senden Sie mir einen an Sie
  adressierten mit 3 DM frankierten Briefumschlag.
  Sie erhalten dann die neueste Version

  Ich benötige auch jemand der mir hilft eine
  Englische Version herauszugeben.

@ENDNODE

@NODE DAN "DANKE ...."
 Siehe im eingebauten Helptext von In_Go

@ENDNODE

@NODE GLO "GLOSAR  A-Z"
  @{"AL  AKTUELLE ZEILE                  " LINK AKTZE}
  @{"AMIGAGUIDE                          " LINK AMIGU}
  @{"AMIGAGUIDEFILE SPEICHERN            " LINK SPAG}
  @{"BSS                                 " LINK BSSGL}

  @{"CHIP RAM                            " LINK CHIPG}
  @{"CODE                                " LINK CODEG}

  @{"DATA                                " LINK DATAG}
  @{"DRELOC_32                           " LINK DRELO}
  @{"FAST                                " LINK FASTG}

  @{"HUNK                                " LINK HUNKG}

  @{"IN_GO FILE                          " LINK IN_GO}

  @{"LAUFFÄHIGES PROGRAMM ABSPECHERN     " LINK SPRU}

  @{"MARKE                               " LINK MARKE}

  @{"OBJECTFILE                          " LINK OBJEC}
  @{"OPCODE                              " LINK OPCOD}

  @{"PROFILER                            " LINK SPRU}

  @{"RELOC_8                             " LINK RELOC}
  @{"RELOC_16                            " LINK RELOC}
  @{"RELOC_32                            " LINK RELOC}

  @{"SEGMENT                             " LINK SEGME}
  @{"SYMBOLISCHER PROCESSOR              " LINK SYMPR}
@ENDNODE

@NODE AKTZE "Al Aktuelle Zeile"

 Als Aktuelle Zeile wird diejenige Zeile angesehen die von
 einem roten Kursor eingerahmt ist.

@ENDNODE

@NODE AMIGU "Amigaguide"

 Als Amigaguide-File wird ein File bezeichnet bei dem Querverweise
 durch Anklicken angezeigt werden können.
 Dieses Helpfile ist ein Amigaguide-File !

@ENDNODE

@NODE IICON "Icon"

 Alle von In_Go erzeugte Textfiles können mit Icons versehen werden.

@ENDNODE

@NODE FASTG "FAST-Memory"

 Meist ist das nachträglich eingefügte RAM Modul FAST-RAM
 Der 680X0 Processor hat hier den alleinigen Zugriff !

@ENDNODE

@NODE CHIPG "CHIP-Memory"

 Der 500 er hatte in seiner Originalversion 500 kB CHIP-RAM

 Der 1200 er hat 2 MB CHIP-RAM
 Der Grahpic-Processor kann nur auf CHIP-RAM zugreifen.

@ENDNODE

@NODE DATAG "DATA Segment"

 Ein lauffähiges Prg besitzt meist auch Datasegmente.
 Dies ist nie das erste Segment !
 Datasegmente können jedoch auch Code enthalten !

@ENDNODE

@NODE CODEG "CODE Segment"

 Ein lauffähiges Prg besteht aus mindestens einem
 CODE Segment

@ENDNODE

@NODE BSSGL "BSS Segment"
 Ein BSS Segment wird erst von der Amiga-Laderoutine
 belegt.Im Abgespeicherten Prg wird nur ein @{"Hunk" LINK HUNKG}
 belegt.
 Eine Adresskorrektion im @{"CODE Segment" LINK CODEG} erfolgt dann
 durch die Loadseg Routine der Dos Library.
 Dies ist im Grunde ein Data Segment, nur das hier alle vorgegebenen Daten
 uninitialisiert oder Null sind !

 Beim Laden eines linkbaren Objectmodules expandiert In_Go
 diese Bereiche nicht, so das Offsets ausgegeben werden.

@ENDNODE

@NODE HUNKG "Hunk"
 Der Begriff Hunk ist teilweise mit dem Begriff
 @{"Segment" LINK SEGME} identisch.
 Lauffähige Module bestehen meist aus mehreren Segmenten
 wobei allgemein 3 Arten unterschieden werden

 CODE       Hier kann alles stehen auch Data !
 DATA       Hier werden Daten ausgelagert.
 BSS        Hier werden nur Speicherbereiche in der geforderten Größe angefordert.

 Der tiefere Sinn einer solchen Aufteilung:

 - Der angeforderte Speicherbereich kann kleiner als die gesammte
   Programmlänge sein; Dies ist insbesondere bei stark
   fragmentiertem Speicher notwendig.

 - BSS Bereiche machen das abgespeicherte Programm
   nur unwesentlich länger. Dieser Speicher wird erst beim
   laden des Prgs durch die Loadseg Routine allokiert.

 - Für manche Anwendungen ist eine bestimmte Speicherart
   notwendig. Manche Coprocessoren haben nur Zugriff auf das
   CHIP-RAM.

 - Die CPU hat zwar Zugriff zu allen Speicherarten
   jedoch erfolgt ein Zugriff aufs FAST-RAM meist
   schneller als aufs CHIP-RAM, da die Coprocessoren
   teilweise Paralell aufs CHIP-RAM zugreifen können !

 Da der Amiga ein Multitask Computer ist müssen alle
 Programme an verschiedenen Adressen lauffähig sein
 Daher enthält fast jedes Programm auch Tabellen
 von Adressen, die vor dem Starten berichtigt werden müssen.
 Diese Tabellen werden zum Beispiel Reloc_32 Hunk genannt.
 In linkbaren Objectfiles können noch andere Hunks auftauchen.

@ENDNODE

@NODE IN_GO "In_Go File"

 Ein .In_Go File ermöglicht das Zwischenspeichern
 Ihrer Arbeit mit In_Go.

 Normalerweise wird das In_Go File im gleichen
 Pfad wie das bearbeitete File abgespeichert.

 Ein In_Go File enthält:

 @{"Marken" LINK MARKE}
 @{"Reloc_32" LINK RELOC}
 
@ENDNODE

@NODE OBJEC "Objectfile"

Es gibt grundsätzlich drei Arten:

 - Lauffähige Objectfiles
   Diese können von der Workbench oder dem CLI gestartet werden.
   Die Hunkrelation stimmt hier.

 - Linkfähige Objectfiles die ein lauffähiges Objectfile ergeben
   Die letzte Stufe einer Compilation die nur noch mit einer
   bestimmten Library gelinkt werden müßen.
   Die Hunkrelation ist hier richtig:
   Ein Verweis auf Hunk 2 stimmt hier
   Im Laderequester kann diese Art angeklickt werden !

 - Objectfile-Kollektionen wie zB die Amiga-Lib
   Hier werden viele Objectfiles aneinandergefügt. Die Hunkrelation
   ist falsch: Ein Verweis auf Hunk 2 zeigt hier NICHT auf den
   2. Hunk der Kollektion.

   Erst durch Linken der entsprechenden Teile mit anderen Teilen
   ergibt sich als Endergebnis ein lauffähiges Modul.


@ENDNODE

@NODE OPCOD "Opcode"

 Wenn eine bestimmte Instruktion im Speicher als eine
 Folge von Hexzahlen existiert, so wird diese Hexzahl
 von mir als Opcode bezeichnet.

 Beispiel: RTS erscheint als $4e75

@ENDNODE

@NODE RELOC "RELOC_XX"

 In lauffähigen Files sorgen Reloc_32 Tabellen für
 Lauffähigkeit an verschiedenen Adressen
 Es handelt sich dabei um eine Tabelle die anzeigt
 welche Adresse `Angepasst` werden muß

 Reloc_8 und Reloc 16 Tabellen tauchen nur in linkbaren
 Objektfiles auf.

 Siehe auch @{"Hunk LINK HUNKG}

@ENDNODE

@NODE DRELO "DRELOC_32"

 In lauffähigen Files sorgen Dreloc_32 Tabellen für
 lauffähigkeit an verschiedenen Adressen.

 Dreloc_32 Hunks sind Platzsparender gegenüber @{"Reloc_32" LINK "RELOC"} Hunks
 Diese Hunkart ist nur bei kleineren Prgs möglich !
 
@ENDNODE

@NODE SEGME "Segment"

 Ein Segment in linkbaren Ojectfiles kann aus mehreren
 Hunks bestehen.

 Besteht ein Segment nur aus einem Hunk sind beide
 Begriffe identisch.

 Die Umschaltung der Segment erfolgt mit <+> und <->

 Siehe auch @{"In_Go File" LINK IN_GO}

@ENDNODE

@NODE MARKE "Marken"

 Marken sind vom Benutzer festgelegte Punkte
 Sie sind nur für die Anzeige von Bedeutung.
 In_Go interstützt 10 Marken von 0 bis 9.

 Marken liegen grundsätzlich innerhalb der geladenen Segmente !

 Setzen einer Marke mit `Amiga Taste` + `0-9` Taste
 Abrufen einer Marke mit Taste `0-9`

 Sind Marken nicht belegt wird zu Segmentnummer verzweigt

 Siehe auch @{"In_Go File" LINK IN_GO}

@ENDNODE

@NODE SYMPR "Symbolischer Processor"

 Der Symbolische Processor versucht das Hin- und Herschieben
 von Registerinhalten zu simulieren.

 Dies hat natürlich dort seine Grenzen wo auf Speicherinhalte,
 Stack usw. zurückgegriffen wird.

 Wie auch immer... mit F6 kann der Inhalt für jede angezeigte
 Zeile angezeigt werden.

 Mit einem Komentar kann eine Belegung erzwungen werden !
 Beispiel: Komentar [A0]=_WBStartup
 Die Belegung ist erst in der folgenden Zeile wirksam.

 In der vorliegenden Version hat diese Belegung keinen Einfluß
 auf die Wortinterpretation der Bereiche im F3 Requester
 da dieser eine höhere Priorität zugeordnet ist !

@ENDNODE

@NODE MEN Die "Menüs der Hauptanzeige"

      @{"Acti        " Link ACTI}
      @{"Jump        " Link JUMP}
      @{"Edit        " Link EDIT}
      @{"Line        " LINK LINE}
      @{"Misc        " Link MISC}
      @{"Requ        " Link REQU}
      @{"Processor   " Link PROC}
      @{"Hunk/Segment" Link HUSE}

@ENDNODE

@NODE ACTI "Das Action Menü"

      @{"Laden                         " LINK LADE}
      @{".In_Go abspeichern            " LINK SPIN}
      @{"Assembler Textfile abspeichern" LINK SPTE}
      @{"Amiga-Guide File abspeichern  " LINK SPAG}
      @{"Lauffähiges Modul Abspeichern " LINK SPRU}
      @{"Objectfile abspeichern        " LINK SPOB}
      @{"Voreinstellung Abspeichern    " LINK SPVO}
      @{"Disassembliere                " LINK DISA}
      @{"Drucke sichtbaren Text        " LINK DRST}
      @{"Iconify                       " LINK ICOY}
      @{"Help                          " LINK HELP}
      @{"New                           " LINK KNEW}

@ENDNODE

@NODE LADE "Lade Quelle"

 @{"Lade File" LINK LADEFIL}
 @{"Lade Task" LINK LADETAS}
 @{"Lade ROM " LINK LADEROM}
 @{"Lade RAM " LINK LADERAM}

  Nach dem Laden werden hier die Segmente angezeigt.
  Dabei kann auch die Hunkart durch Doppelklick editiert werden.

  Beim erstmaligen Laden wird zum Reassemblerpreferencesrequester verzweigt.

@ENDNODE

@NODE LADEFIL "Lade File"

Hier existieren 5 Schalter:

 - `Interpretiere Reloc_32`
    Sollte immer eingeschaltet sein !

 - `Interpretiere Langtabellen in Codesegmenten, als Sprung`
    Einige Compilate legen Langworttabellen in Codesegmenten an,
    die hiermit als Reassemblerrestartadressen interpretiert werden.
    Mit Vorsicht anwenden !

 - `Lese Symbol Hunk Units`
    Sollte immer angeschaltet sein !

 - `Sprünge in Data Segmente existieren`
    Einige Compiler generieren Sprünge in Data Segmente, dies führt
    dann zu Interpretationsfehlern wenn der Codeteil im Datasegment
    Reloc_32 Adressen beinhaltet.
    Normalerweise immer aus !

 - `Reales Prg. (nur für linkfähige Objectfiles)
    Nur von Interesse wenn linkfähige Objectfiles geladen werden !
    Hier wird zwischen einer Objectfilecollection und der letzten
    Stufe eines Compilers unterschieden.
    Allgemein gilt: Stimmen die Hunkrelationen des Objectfiles dann
    einschalten !
          
@ENDNODE

@NODE LADETAS "Lade Task"

 Wenn Sie bereits ein `in_go` File der entsprechenden Task gespeichert
 haben, so sollten Sie erst den In_Go Pfad anwählen.
 Selectieren Sie die Task durch Anklicken im Requester

 Bedenken Sie Bitte das eine Task keinerlei Hinweise auf Reloc_32
 Daten enthält !

@ENDNODE

@NODE LADEROM "Lade ROM"

 In_Go ermöglicht auch das ROM einzuladen !
 Dabei werden ca. 1000 Symbole erzeugt.
 Dies sollte auch bei nachgeladenem ROM funktionieren.
 Dabei kann es zu Enforcerhits kommen da In_Go auch die Zero-Page
 auswertet. Beim erstmaligen Einladen sollten Sie @{u}alle@{uu} Schaltmöglichkeiten
 einschalten.

@ENDNODE

@NODE LADERAM "Lade RAM"

 Wenig empfehlenswert !
 Ergebnis Kann nicht abgespeichert werden !

@ENDNODE

@NODE SPIN "Speichere In_Go File"

 Hier kann ein File mit allen Labeln, Referenzen, Relocs, Labelnamen usw.
 abgespeichert werden. Die sollte in der Regel im gleichen Verzeichnis
 wie das geladene File, passieren.
 Dort wird es bei nochmaligen Laden auch gesucht.
 @{u}Dieses File enthält nicht das eigentliche Programm !@{uu}
 Durch laufendes Speichern kann eine Art UNDO erreicht werden,
 dies sollte insbesondere bei unsicherem Tabelleneinlesen erfolgen.

@ENDNODE

@NODE SPTE "Assembler Textfile abspeichern"

 Hier kann ein ASCII-File der geladenen Quelle abgespeichert werden.
 dabei sind verschiedene Optionen möglich:

 - Liste mit Segmenten Einfügen.
 - Liste der Code Bereiche einfügen.
 - Labelliste einfügen.
 - Sende keine undefinierten Segmente.
   Dies ermöglicht die Beseitigung von nicht benötigten Segmenten.
 - Versionstring einfügen
 - Icon mitspeichern.                    

@ENDNODE

@NODE SPAG "Amiga-Guide-File abspeichern"

 Hier kann ein ASCII-File  der geladenen Quelle im Amigaguide-Format
 abgespeichert werden.
 dabei sind verschiedene Optionen möglich:

  - Liste mit Segmenten Einfügen.

  - Liste der Code Bereiche einfügen.

  - Labelliste einfügen.

  - Sende keine undefinierten Segmente.
    Dies ermöglicht die Beseitigung von nicht benötigten Segmenten.

  - Versionstring einfügen

  - Icon mitspeichern.

@ENDNODE

@NODE SPRU "Lauffähiges Programm abspeichern"

  Hier kann ein geladenes lauffähiges Programm wieder abgespeichert werden.
  Dabei sind verschiedene Optionen möglich:

   - Debug-Hunks mit allen Labeln einfügen 

   - Debug-Hunks mit Namen in Code einfügen. Diese Option ermöglicht das
      sparsame speichern von eigenen Labelnamen die in Code stehen.
      Der tiefere Sinn dabei; ein Profiler, also ein Programm das die
      Laufzeiten der verschiedenen Programmteile aufzeichnet wird nicht
      durch balastartige Datalabel verwirrt !

   - Debug Hunks nur mit eigenen Namen einfügen. Hier werden also keine
      In_Go erzeugten Labelnamen in der Form (A)(J)(L)+Hunk+`_`+Offset 
      abgespeichert.

  Wenn es sich um kleinere Programme handelt kann In_Go die Reloc_32
  Einträge auch in Dreloc_32 Einträge umwandeln. Das spart Speicherplatz! 
  Diese Option ist nur für das ganze Prg verfügbar.
       
@ENDNODE

@NODE SPOB "Object-File abspeichern"

 Auch hier existieren wieder verschiedene Modi.

 Damit lassen sich Objectfilecollectionen editieren !


   - Alles zusammen                Selbstredend

   - Nur sichtbares Segment        Selbstredend

   - Sichtbares Segment nicht      Unterdrücke sichtbares Segment

   - Alles spliten                 Jedes Segment separat

   - Tausche sichtbaren Hunk aus   Das sichtbare austauschen mit anderem

   - Füge anderes Object ein       Ein Segment einfügen

@ENDNODE

@NODE SPVO "Voreinstellung abspeichern"

 Die Voreinstellung wird im S: Verzeichnis abgespeichert.

@ENDNODE

@NODE DISA "Disassembliere"

 Nach Anwahl dieses Punktes startet die Reasemblierung.

 Erreichbar durch Leertaste

 Abbruch durch Mausklick in die Scrollbox.

@ENDNODE

@NODE DRST "Drucke sichtbaren Text"

 Der gerade in der Anzeige sichtbare Text wird ausgegeben.

@ENDNODE

@NODE ICOY "Iconifiziere In_Go"

 In_Go schliest seinen Screen und ist auf der Workbench
 als Icon wieder aufrufbar.

@ENDNODE

@NODE HELP "Help"

 Ein Helptext wird angezeigt.
 Nur in der Hauptanzeige wirksam.

@ENDNODE

@NODE KNEW "New"

 Alle Resourcen werden zurückgegeben, Ingo startet erneut.

@ENDNODE

@NODE JUMP "Jump Menü"

 @{"Setze Marke                            " LINK SEMA}
 @{"Zeige Marke oder Segment               " LINK ZEMA}
 @{"Springe zum linken Operanden           " LINK JLIO}
 @{"Springe zum rechten Operanden          " LINK JREO}
 @{"ZurückSpringen                         " LINK JRET}
 @{"Springe zum nächsten Data/Code Wechsel " LINK NEDC}
 @{"Springe nächste Tabelle                " LINK NETA}
 @{"Springe nächstes jmp(Ax)               " LINK NJAX}
 @{"Springe nächsten Fehler                " LINK NERR}
 @{"Springe zum nächsten Label             " LINK NELA}
 @{"Springe zum vorherigen Label           " LINK VOLA}
 @{"Springe zum nächsten Langwort Label    " LINK NELL}
 @{"Springe zum nächsten Komentar          " LINK NEKO}
 @{"Springe zum Segmentbeginn              " LINK SEBE}
 @{"Springe zum Segmentende                " LINK SEEN}
 @{"Springe nach Label ...                 " LINK LARE}
 @{"Springe zur Referenz ...               " LINK RERE}

@ENDNODE

@NODE SEMA "Setze Marke"

 In_Go unterstützt bis zu 10 @{"Marken LINK MARKE} im Programm
 Durch Drücken von Amigataste + 0-9 wird eine Marke
 gesetzt.
 Durch Drücken der Taste 0-9 wird die entsprechende
 @{"Marke" LINK MARKE} angesprungen.
 Marken werden auch im @{"In_Go File" LINK IN_GO} abgespeichert

 Siehe auch @{"Zeige Marke oder Segment" LINK ZEMA}

@ENDNODE

@NODE ZEMA "Zeige Marke oder Segment"

 Durch Drücken der Taste 0-9 wird die entsprechende
 @{"Marke" LINK MARKE} angesprungen.

 Ist eine Marke unbelegt wird zum entsprechenden
 Segment verzweigt.

@ENDNODE

@NODE JLIO "Springe zum linken Operanden"

 Es wird versucht zum linken Operanden zu springen.
 Die Letzte Anzeigeadresse wird abgespeichert.
 Mit @{"<Kursor links>" LINK JRET} kann wieder zur
 letzten Anzeigeadresse zurückgesprungen werden.
 max. Tiefe  10

@ENDNODE

@NODE JREO "Springe zum Rechten Operanden"

 Es wird versucht ab dem rechten Operanden anzuzeigen.
 Die Letzte Anzeigeadresse wird abgespeichert.
 Mit @{"<Kursor links>" LINK JRET} kann wieder zur
 letzten Anzeigeadresse zurückgesprungen werden.
 max. Tiefe  10

@ENDNODE

@NODE JRET "Springe Zurück"

 Tastatur <Kursor links>

@ENDNODE

@NODE NEDC "Springe zum naechsten Data/Code Wechsel"

 Funktioniert immer vorwärts !

@ENDNODE

@NODE NETA "Springe nächste Tabelle"

Es wird versucht eine mögliche Sprungtabelle anzuzeigen !

@ENDNODE

@NODE NJAX "Springe zum nächsten Jmp(ax)"

Springt zum nächsten Indirekten Sprung jmp (ax) oder  jsr (ax)

@ENDNODE

@NODE NERR "Springe zum naechsten Fehler"

Alle Reassemblerfehler werden nacheinander angezeigt.

@ENDNODE

@NODE NELA "Springe zum nächsten Label"

 `>` Aktuelle Zeile zum nächsten Label

@ENDNODE

@NODE VOLA "Springe zum vorherigen Label"

`<` aktuelle Zeile zum letzten Label

@ENDNODE

@NODE NELL "Springe zum naechsten Langwort-Label"

 Springt zum naechsten Langwortlabel

@ENDNODE

@NODE NECO "Springe zum nächsten Komentar"

 Springe nächsten Komentar an

@ENDNODE

@NODE SEBE "Springe zum Segmentbeginn"

 selbstredend

@ENDNODE

@NODE SEEN "Springe zum Segmentende"

selbstredend

@ENDNODE

@NODE LARE "Springe zum Label ..."

 Ein Requester wird angezeigt: Das angeklickte Label wird angezeigt

@ENDNODE

@NODE RERE "Springe zur Referenz..."

Existieren Referenzen auf die Aktuelle Zeile,
Wird ein Auswahl-Requester angezeigt.

Durch anklicken wird die aufrufende Stelle angezeigt.

@ENDNODE

@NODE EDIT "Edit Menü"

 @{"Mache Code zu Data von Al an                             " LINK CDAL}
 @{"Lösche Zeilenlabel in der Al                             " LINK LZLA}
 @{"Lösche alle Codebereiche                                 " LINK ALLC}
 @{"Erzeuge Datalabel in der Al                              " LINK CDAL}
 @{"Erzeuge Jl in der Al                                     " LINK CJLA}
 @{"Erzeuge Jl in der Al und reassembliere                   " LINK CJLR}
 @{"Erzeuge Jl in der Al, reassemble und springe nach Data   " LINK CJRJ}
 @{"Erzeuge Interuptlabel/NormalLabel in der Al              " LINK CINT}
 @{"Reassemblerhilfe in der Al für Operand 1                 " LINK RHO1}
 @{"Reassemblerhilfe in der Al für Operand 2                 " LINK RHO2}
 @{"Tabellenhilfe in der Al                                  " LINK THAL}
 @{"Erzeuge lokale labeln                                    " LINK CLOL}
 @{"Benenne typische Amiga Strings                           " LINK CTYA}
 @{"Finde Reloc32 (nur für Tasks)                            " LINK FIRE}
 @{"Vergleiche Reloc_32 (nur für Tasks)                      " LINK VERE}
 @{"Suche vorwärts                                           " LINK SUVO}
 @{"Suche rückwärts                                          " LINK SURE}

@ENDNODE

@NODE CDAL "Mache Code zu Data von Al an"

 Bitte nur im Notfall benutzen da vorher gefundene Referenzen
 nicht mitgelöscht werden.
 Dies kann zu Problemen führen...

@ENDNODE

@NODE LZLA "Lösche Zeilenlabel in der Al"

 Wenig empfehlenswert:
 Referenzen bleiben erhalten.
 Das Löschen von durch Reloc_32 erzeugten Labeln ist nicht möglich !

@ENDNODE

@NODE ALLC "Lösche alle Code Bereiche"

 Werden im F3 Requester neue Bereiche eingetragen so ist
 eine erneute Reassemblierung fällig !
 Die Labeln werden beibehalten.

@ENDNODE

@NODE CDAL "Erzeuge Datalabel in der Al"

 Ein Label vom Typ `L` wird angelegt
 Diese Label wird NICHT automatisch vom Reassembler angesprungen.

@ENDNODE

@NODE CJLA "Erzeuge Jumplabel in der Al"

 Ein Label vom Typ `JL` wird angelegt.
 Beim Nächsten Reassemblerstart wird ab diesem Label
 reassembliert.

@ENDNODE

@NODE CJLR "Erzeuge Jumplabel in der Al und Reassembliere"

 Wie @{"Erzeuge Jumplabel in der Al" LINK CJLA}
 Anschliesend wird jedoch Reassembliert

@ENDNODE

@NODE CJRJ "Erzeuge Jumplabel in der Al, reassembliere,nächstes Data"

 Wie @{"Erzeuge Jumplabel in der Al" LINK CJLA}
 Nach dem reassemblieren wird zum nächsten
 Data/Code Wechsel gesprungen.
 Damit können auch unsichere unerkannte Codeteile reassembliert werden.

@ENDNODE

@NODE CINT "Erzeuge Interuptlabel/Normallabel in der Al"

 Manche Programme verzweigen mit `bsr xxx` oder `jsr xxx` zu bestimmten Unterprogrammen.
 Innerhalb dieser Unterroutinen wird die Herkunftsadresse vom Stack gehohlt, und
 zu einem anderen Programmteil verzweigt.
 Befinden sich hinter dem Aufruf Datas führt dies zu Reassemblerfehlern.

 Fahren sie mit der Aktuellen Zeile auf die Routine auf dieses Label (nicht auf den Aufruf ! ),
 wählen Sie diesen Punkt an, beantworten Sie den Requester Richtig.
 Trift der Reassembler nun auf einen Aufruf jsr/bsr
 wird dahinter nicht automatisch weiter reassembliert.

 Bei nochmaliger Anwahl kann dieser Zustand wieder beseitigt werden.

@ENDNODE

@NODE RHO1 "Reassemblerhilfe in der Al für linken Operanden"

 Der linke Operand wird im Reassemblerhelprequester zur Edition
 angeboten.
 Handelt es sich um ein Register oder ähnliches wird der
 rechte Operand genommen !

@ENDNODE

@NODE RHO2 "Reassemblerhilfe in der Al für rechten Operanden"

 Der rechte Operand wird im Reassemblerhelprequester zur Edition
 angeboten.
 Handelt es sich um ein Register oder ähnliches wird der
 linke Operand genommen !

@ENDNODE

@NODE THAL "Tabellenhilfe in der Al"

Hier wird ein Tabellenhilfsrequester angezeigt
Die Aktuelle Zeile wird als Adresse übergeben.

@ENDNODE

@NODE CLOL "Erzeuge lokale Labeln"

 Sollte erst nach einer vollständigen Reassemblierung
 angewendet werden.
 Diese unscheinbare Tool hats in sich . . .

@ENDNODE

@NODE CTYA "Benenne typische Amiga Strings"

Mit diesem Aufruf werden Amigatypische Strings benannt.
Sie werden also als Label abgespeichert.

@ENDNODE

@NODE FIRE "Finde Reloc_32"

 Da bei Tasks keine Reloc_32 Tabelle existiert
 werden hiermit alle Segmente auf Adressen untersucht
 die in die Segmente zeigen.

 Durch  Laden an verschiedenen Adressen und anschliesendes
 Aufrufen der Funktion @{"Vergleiche Reloc_32" LINK VERE}
 werden alle rein zufällig in die Segmente zeigenden Zeiger
 eliminiert.

 Dies ist alles etwas problembehaftet!
 Diese Funktion kann nur bei Tasks angewählt werden !

@ENDNODE

@NODE VERE "Vergleiche Reloc_32"

 Da bei Tasks keine RELOC_32 Tabelle existiert
 werden hiermit alle mit @{"Finde Reloc_32" LINK FIRE}
 gefundenen Reloc_32 verglichen.

 Durch  Laden an verschiedenen Adressen
 ( der Task mit .In_Go File )
 und anschliesendes Aufrufen dieser Funktion, werden alle
 rein zufällig in die Segmente zeigenden Zeiger eliminiert.

 Dies ist alles etwas problembehaftet!
 Diese Funktion kann nur bei Tasks angewählt werden !

@ENDNODE

@NODE SUVO "Suche Vorwärts"

Selbstredend

@ENDNODE

@NODE SURE "Suche Rückwärts"

selbstredend

@ENDNODE

@NODE LINE "Line Menü"

 @{"Zeilenadressanzeige                " LINK ZADR}
 @{"Zeige Data als                     " LINK DAAL}
 @{"Zeilenlabelbreite                  " LINK ZLAB}
 @{"Data Optionen                      " LINK DAOP}
 @{"Zeige Opcode in Hex                " LINK ZOPC}
 @{"Zeige Library interpretation       " LINK ZLIB}
 @{"Zeige Wort interpretation          " LINK ZWIN}
 @{"Zeige Langwort interpretation      " LINK ZLIN}
 @{"Zeige indirekt-indirekte Zeiger    " LINK ININ}
 @{"Zeige Lokale Labelform             " LINK ZLOL}

@ENDNODE

@NODE ZADR "ZeilenAdressanzeige"

 Mit verschieden Modi

 - Absolut als Speicheradresse, bei Objectfiles sinnlos

 - Relativ zum Segmentanfang

 - Keine Anzeige

 Mit `z` weiterschaltend umschaltbar.

@ENDNODE

@NODE DAAL "Zeige Data als"

 Einmal erkannter Code wird immer als Code dargestellt ( Überwiegend schwarz ).

 Datas oder unerkannter Code können hiermit
 in wählbarer Anzeigeart dargestellt werden ( überwiegend gelb ).

 Wird ein Codeteil gelb dargestellt wird er jedoch immer als Data in ein
 Textfile ausgegeben !

 Auch wenn die Anzeige dies nicht tut !

@ENDNODE

@NODE ZLAB "Zeilenlabelbreite"

selbstredend

@ENDNODE

@NODE DAOP "Data Optionen"

 Datas können verschieden Dargestellt werden !

 - Anzeige von Strings
 - Nullen sammeln


 Im Gegensatz zu anderen Reassemblern kann bei In_Go die Data-Art
 nur Global eingestellt werden.

 Wenn Sie eine bestimmte Adresse benötigen die durch die Anzeigemodi
 normal irgendwie nicht zugänglich ist, bringen Sie diese Adresse
 oberhalb des sichtbaren Bereiches.
 durch Rückschritt (er findet in Wordbreite statt) kommt diese dann auch zur Anzeige

 Dies scheint mir verbesserungswürdig !
@ENDNODE

@NODE ZOPC "Zeige Opcode in Hex"

 Die ersten 10 Bytes werden als Hexzahl ausgegeben.

@ENDNODE

@NODE ZLIB "Zeige Library Interpretation"

 Dieser Schalter ermöglicht das Ein- und Ausschalten der Library- Interpretation.
 Zum richtigen Interpretieren eines Library-Aufrufes müssen die Variablen welche
 die Basen beinhalten richtig benannt werden !

 Durch richtige Namensgebung der Librarybasen erkennt der Symbolische Processor
 von In_Go, die aufgerufene Library.

 Richtige Namensgebung wird durch eine Bennennung erreicht, welche den Namen im
 Reassemblerhilfsrequester entspricht.

  Daher sollten Sie zuerst die Openlibrary Funktionen suchen.
  In_Go hat im Suchrequester (F7) ein Menüeintrag der dies initiert. Die Suche selbst
  findet in der Hauptanzeige durch Amiga + `f` oder Amiga + `b`
  Erst sollten sie aber `Finde Typische Amiga Strings` aufrufen.
  dieses wird Durch Amiga +Shift +`$` erreicht.

  Nun haben wir also einen OpenLibrary Aufruf gefunden:

  Beispiel:
            movea.l     $4.W,A6          ;Execbase nach A6
            lea         dosname,A1       ;Name der zu öffnenden Library nach A1
            moveq.l     #$25,D1          ;Die minimal geforderte Version
            jsr         OpenLibrary(A6)  ;Aufruf der Exec Funktion
                                         ;wenn erfolgreich befindet sich nun die
                                         ;LibraryBase in D0
            Irgendwo darunter...         ;jetzt wird meist irgendwie getestet ob
            ...                          ;das öffnen erfolgreich war
            ...                          ;
            move.l      D0,Lxxxxxx       ;Hier beginnt die für uns interessannte
                                         ;Zeile: Die Base wird abgespeichert !
  Nun klicken wir das Label Lxxxxxx an; Der erscheinende Reassembler-
  hilfsrequester ermöglicht uns eine Benennung dieses Labels. Im
  Falle Dos geben wir den Namen `_DOSBase` ein.
  Nach erfolgreicher Benamung erkennt der symbolische Processor nun
  überall im Programm wenn Eine Dos Funktion Aufgerufen wird !

  Manche Programme speichern auch die Execbase in einer Variablen ab
  (dies wird von Commodore empfohlen) diese Abspeichern
  erfolgt meist direkt am Anfang des Programms Beispiel:
             bsr INIT
             .....
      INIT: movea.l $4,A6        ;ExecBase nach A6
            move.l A6, Lxxxxxx   ;ExecBase wird in Variable abgespeichert
            rts
  Klicken Sie Lxxxxxx An; Der erscheinende Reassemblerhilfsrequester ermöglicht
  nun die benennung dieses Labels in `ExecBase`

 Sollten Die Basen Indirekt(Ax) oder Pseudo(Ax) abgespeichert werden
 muß dieser Fall erst im F3 Requester bearbeitet werden !


@ENDNODE

@NODE ZWIN "Zeige Wort Interpretation"

 Mit Hilfe des In_Go internen Symbolprocessors können Strukturoffsets als Symbol
 ausgegeben werden.
 Hiermit kann diese Interpretation Aus- und Eingeschaltet werden.

@ENDNODE

@NODE ZLIN "Zeige Langwort Interpretation"

 In In_Go sind bereits gängige Langwortkonstannten abgespeichert.
 Hiermit kann die Interpretation Ein- und Ausgeschaltet werden.

@ENDNODE

@NODE ININ "Zeige indirekt-indirekte Zeiger"

 Zeigen Sprungadressen auf andere Sprungadressen kann durch Einschalten
 dieser Option das eigentliche Sprungziel ausgegeben werden.
 Dies sollte auch bei Langwort-Datas funktionieren.

@ENDNODE

@NODE ZLOL "Zeige lokale Labelform"

 Wenn lokale Label errechnet wurden, kann mit diesem Menüpunkt die Ausgabe
 Ein- und Ausgeschaltet werden.
 Bedenken Sie Bitte Das durch Eingabe eines einzigen (!) Labels alle lokalen
 Labeln erneut berechnet werden sollten.

@ENDNODE

@NODE MISC "MISC-Menü"

 @{"Lerne Strings    " LINK LEST}

 @{"Lerne Libs       " LINK LELI}

 @{"Lerne Libs Prefs " LINK LELP}

 @{"Auto Rea Klick   " LINK ARCL}

 @{"Cleanup          " LINK CLEA}

@ENDNODE

@NODE LEST "Lerne Strings"

 Siehe In_Go internen  Helptext

@ENDNODE

@NODE LELI "Lerne Libs"

Siehe In_Go internen  Helptext

@ENDNODE

@NODE LELP "Lerne libs Prefs"

Siehe In_Go internen  Helptext

@ENDNODE

@NODE ARCL "Auto Rea Klick"

 Durch Anklicken eines Zeilenlabels wird die Reassemblierung gestartet.
 Wenig empfehlenswert !

@ENDNODE

@NODE CLEA "Cleanup"

 Diesen Eintrag sollten Sie eigentlich nie aufrufen müssen !

@ENDNODE

@NODE REQU "Requ Menü"
 @{"Quelle in Hex und ASCII      " LINK QUHA}
 @{"Quelle als Text              " LINK QUAT}
 @{"Bildschirm,Speicher          " LINK BISP}
 @{"Assembler Voreinstellung     " LINK ASVO}
 @{"Reassembler Voreinstellung   " LINK REVO}
 @{"Rechner                      " LINK RECH}
 @{"Inhalte                      " LINK INHA}
 @{"Symbolischer Processor       " LINK SYPR}
 @{"Suchen                       " LINK SUCH}
 @{"In den Speicher schreiben    " LINK SMEM}
 @{"Speicheranzeige Hex/ASCII    " LINK ASPE}
 @{"Optimierung aus der Quelle   " LINK OPTI}
@ENDNODE


@NODE QUAH "Quelle in Hex und ASCII"

 Hier wird ein Requester ausgegeben der die geladene Quelle in Hex und ASCII ausgibt,
 Durch `+` und `-` kann zwischen den verschiedenen Segmenten umgeschaltet werden.

@ENDNODE

@NODE QUAT "Quelle als Text"

 Hier wird ein Requester ausgegeben der die geladene Quelle als Text interpretiert.
 Durch `+` und `-` kann zwischen den verschiedenen Segmenten umgeschaltet werden.

@ENDNODE

@NODE BISP "Bildschirm, Speicher"

 In diesem Requester können Sie verschiedene Einstellungen bezüglich Speicher
 und Anzeige editieren.

  Die Scrollbox kann 2 Modi annehmen

     - Grenzen: Hier werden Die maximalen und aktuellen Limits der In_Go internen
                Variablen ausgegeben. Eine Edition ist nicht möglich.
     - Farben : In_Go ermöglicht die Ausgabe von verschiedenen Farben. Darum
                öffnet In_Go auch einen Screen in 8 Farben !
                In vielen Fällen lassen Sich hier die Farben der zeilenausgabe ändern !
                nach dem anklicken der entsprechenden Zeile.

 `Wähle Screen` der von In_Go geöffnete Screen kann bestimmt werden.
 `Wähle Font  ` der in den Scrollboxen verwendete Font kann eingestellt werden.
                Dabei können nur lineare Fonts benutzt werden !
 `Internen Speicher definieren`
                In_Go benutzt keine dynamischen Speicherbereiche.
                Zum minimalen funktionieren werden jeweils 100000 Byte für Labeln
                und Referenzen benötigt.
                Allgemein gilt Speicher für Labeln und Xrefs jeweils so groß wie
                die zu ladende Quelle.
                Nach einer Neudefinition ist ein New fällig: Alles geht verloren !

@ENDNODE

@NODE ASVO "Assembler Voreinstellung"
 eigentlich selbstredend
 einzig: Wählen Sie Ihren Assembler. . .
@ENDNODE
@NODE INDIREKT "Indirekt a4 - a6"
     Hier wird auf ein bereits beim Laden existierenden Speicherbereich
     zugegriffen, meist ist dies ein BSS Segment.
     Viele Programme benutzen Register mit einem Zeiger auf Data oder Code
     Diese Initierung erfolgt meist am Anfang von Segment 0
     Ein Beispiel: `lea BaseA4,A4` ;hier wird die Adresse von Label BaseA4 in A4 abgelegt
     Danach können alle Aufrufe die A4 enhalten auf jenen Speicherbereich zugreifen
     auf den A4 zeigt:
     Beispiel.:  `movea.l $xxxx(A4),A1` `addq.l #$1,$xxxx(A4)` `move.w xxxx(a4),yyyy(a4)`
     Sie sehen also, hier wird ein bestimmter Wert in A4 erwartet.
     Diese $xxxx und $yyyy stehen für einen vorzeichenbehafteten Wert von Wortlänge.
     Der Vorteil einer solchen Adressierung: es wird keine Korrektion erforderlich, da
     alle Aufrufe relativ zu A4 erfolgen.
     Da dieser `Wert in Wortlänge` vorzeichenbehaftet ist, wird oft noch ein zweiter Wert
     dazuaddiert so das sich Adressierungsmöglichkeiten im Bereich von 2^16 also 65535 Byte
     ergeben.
     In_Go unterstützt Sie bei der Suche nach solchen Zeigern mit dem Schalter
     `Suche indirekte Basen`.Sollten Sie sich im `Pseudo a0-a6` Modus befinden wird
     dabei Automatisch in den `indirekt a4-a6` Modus zurückgeschaltet.
     Meist werden dabei zuviele Einträge gefunden. Es bleibt Ihnen dann Überlassen
     durch Nachforschung in der Quelle die zuviel gefundenen Bereiche nach Anklicken
     mit dem Schalter `Del` zu eliminieren. Meist ist nur ein einziger Zeiger auf A4
     gültig.
     Ein Eintrag für Indirekt `a4-a6` enthält folgende Angaben

      - Das Register für welches diese Definition gültigkeit hat.
      - Zeiger auf das Label auf das A4 zeigt (oben BaseA4)
      - Den Anfang des Codebereiches ab dem diese Definition gültig ist( oder 0 dann Global).
      - Das Ende   des Codebereiches ab dem diese Definition gültig ist( oder 0 dann Global).
      - Ein eventueller Offset in Wortform der dazuaddiert wird (meist $7FFE, wenn überhaupt)
      - Ein Schalter der diese Wortadition einschaltet !
      - Ein Schalter der Sprunglabelcreation zulässt (Dies ist äußerst selten ).
      - Ein Schalter der Datalabelcreation zulässt (Dies ist der Normalfall).
      - Ein Schalter der diesen Eintrag insgesammt aktiviert

     Sie können diese Einträge auch Ändern mit Schalter `Edit`
     Neue Einträge hinzufügen mit Schalter `New`
     Wenn Sie in der Hauptanzeige im Misc Menü Variablen belegt haben Können Sie mit `Vare`
     Diese in einen neuen Eitrag Übernehmen.
@ENDNODE
@NODE PSEUDO "Pseudo a0-a6"

 `Pseudo a0-a6` Diese Einträge beinhalten, ähnlich wie der vorherige Modus, indirekte
     Aufrufe, Diese indirekte Aufrufe zeigen jedoch nicht auf einen Teil der Quelle !
     Typisch für Pseudo-Bereiche sind Link-Unlink Module von `C` - Compilate ,
     aber auch reentrante Programme die Ihren Speicher erst während des Laufens allocieren.

     In_Go unterstützt Sie bei der Suche nach solchen Bereichen mit dem Schalter
     `Suche Link Module`.Sollten Sie sich im `Indirekt a4-a6` Modus befinden, wird
     dabei Automatisch in den `Pseudo a0-a6` Modus geschaltet.
     Ein Eintrag für Pseudo `a0-a6` enthält folgende Angaben

      - Das Register für welches diese Definition gültigkeit hat.
      - Den Anfang des Codebereiches ab dem diese Definition gültig ist( oder 0 dann Global).
      - Das Ende   des Codebereiches ab dem diese Definition gültig ist( oder 0 dann Global).
      - Ein Schalter der diesen Eintrag insgesammt aktiviert.

     Sprunglabel werden innerhalb dieses Moduses nicht unterstütz.

     Sie können diese Einträge auch Ändern mit Schalter `Edit` oder Anklicken
     Neue Einträge hinzufügen mit Schalter `New`
     Wenn Sie in der Hauptanzeige im Misc Menü Variablen belegt haben, Können Sie mit `Vare`
     diese in einen neuen Eitrag Übernehmen.

@ENDNODE
@NODE REVO "Reassembler Voreinstellung"
 Hier können verschiedene Einstelllungen vorgenommen werden,
 die das Reassemblieren betreffen.
 Für die Scrollbox existieren dabei zwei Modi:

   - @{"Indirekt a4-a6" LINK INDIREKT} mit Unteroption `Suche indirekte Basen`

   - @{"Pseudo a0-a6  " LINK PSEUDO}   mit Unteroption `Suche Link Module`

    Durch Anklicken der Einträge oder `New` können neue Bereiche in einem
    dann erscheinenden Requester eingegeben werden.

 Allgemein Wirksam sind folgende Optionen:

   - Tabellenautomatik
           Mit diesem Einsteller kann das automatische Tabelleneinlesen beeinflusst werden.

           Stufe 1:  Sicheres Einlesen verschiedener Tabellen
           Stufe 2:  Einige Etwas unsichere Tabellen werden nun auch automatisch eingelesen.

           Das automatische Tabelleneinlesen erfolgt beim Reassemblieren (`Space` Taste ! )

   - Keine Kreation wenn: Diese Schalter Unterdrücken die Labelcreation beim Reassemblieren
           Dadurch werden Fehler vermieden, die durch zufällig in die Segmente zeigenden Datas
           verursacht werden. Beispiel move #$100000,D0 : Wenn nun Segment 0 von $99000 - $101000
           gelegen ist würde an Adresse 100000 ein Label generiert werden.
           Dabei sind folgende Schaltmöglichkeiten vorhanden:

           - Pea.l
           - Effektive Adresse
           - Unmittelbar.l Instruktionen
           - Langwort allgemein (Schliest die letzten 3 Optionen Mit ein !)

   - Reassembler restart wenn: Diese Schalter ermöglichen einen Reassembler Restart auch an
           nicht ausdrücklich als Sprungadresse gekennzeichneten Adressen, die nur indirekt
           aufgerufen werden. Dabei sind folgende Schaltmöglichkeiten vorhanden:

           - move.l A6,-(A7)
           - movem allgemein (nicht jedoch: PC)
           - Link  allgemein

   - Owninstruktion Macro.w Ermöglicht die Generierung von einer eigenen Instruktion
            in Wortbreite: dabei kann Wert und Namen Editiert werden. Mit einem
            Schalter kann diese Option eingeschaltet werden.
            Normalerweise werden Sie diese Option nicht benötigen .

@ENDNODE

@NODE RECH "Rechner"

 Rechnen auf Processorebene
 ca 40. verschiedene Funktionen.
 Errechnete Werte können weiterverarbeitet werden:
 - eine Taste belegen
 - als Jumplabel (Reassemblerrestartadresse) anlegen.
 - als Data Label anlegen.

@ENDNODE

@NODE INHA "Inhalte"
 Hier können verschiedene Inhalte gesichtet werden.

 - Selectionsschlüssel  Nur für mich von Bedeutung.
 - Codebereiche         Erkannte Bereiche die Code enthalten.
 - Labels,Flags         Erkannte Label und deren Interpretation.
 - Labelnamen           Eigene Namen. 
 - Status Script        Fileeigenschaften, Fehler usw.
 - Strukturen           Bekannte Strukturen, Die aktuelle Zeile.
                        erlaubt eine Einsicht von Unterstrukturen.
 - Langwortkonstanten   Langwortkonstanten und deren Interpretation.
 - Reloc_32 Referenzen  Alle eingeladenen (D)Reloc_32 Referenzen.
 - Andere Referenzen    Alle wärend des Reassemblierens gefundenen Refs.
 - Pseudo Bereiche      Alle Pseudobereiche.
 - Komentare            Alle Komentare.
 
@ENDNODE

@NODE SYPR "Symbolischer Processor"
 Hier können die Inhalte des symbolischen Processors
 eingesehen (nicht geändert !) werden.
@ENDNODE

@NODE SUCH "Suchen"
 Hier wird eine Suche initiert.
 dabei kann folgendes gesucht werden:

 - 1 Byte
 - 1 Wort
 - 1 Langwort
 - String  
 - Label
  
 Dabei können auch einige Erweiterungen angefordert werden

 - `relativ.l (PC) ` für relative Aufrufe ab 68020
 - `relativ.w (PC) ` für relative Aufrufe
 - `relativ.b (PC) ` für relative Aufrufe
 - `indirekt(Ax)   ` für indirekte Aufrufe wie im F3 Requester eingegeben.
 - `global`        ` die Suche wird auf alle folgenden Segmente ausgedehnt.
 
 @{u}Die eigentliche Suche wird nur in der Hauptanzeige durchgeführt !@{uu}
 Amiga + f sucht vorwärts.
 Amiga + b sucht rückwärts.@{uu}
 
 Einige wichtige Suchwerte können per Menü angefordert werden.

 - OpenLibrary
 - AllocMem
 - lea labelx

@ENDNODE

@NODE SMEM "In den Speicher schreiben"

 Hier wird die aktuelle Adresse zum überschreiben angeboten.
 dabei kann folgendes geschrieben werden:

 - 1 Byte
 - 1 Wort
 - 1 Langwort
 - String mit max. 40 Zeichen 
 - CString mit max. 40 Zeichen (Hier wird ein 0 Byte angefügt)

@ENDNODE

@NODE ASPE "Speicheranzeige in Hex und ASCII"

 Mit dieser Anzeige kann eine frei wählbarer Speicherbereich angesehen werden.

@ENDNODE

@NODE OPTI "Optimierungen aus der Quelle"

 Aufruf durch F10 oder Menü.

 Im Hauptmenü kann diese Option durch `o` geschaltet werden

 Der Requester bietet folgende Schlaltmöglichkeiten:

 - ext.w Dx  gefolgt von  ext.l Dx          -->   extb.l Dx
   ( spart 2 Byte bei 68020 Processor)

 - jmp/jsr Langwort                         -->   bra.l/bsr.l
   (spart bis zu 8 Byte bei 68020 Processor)

 - <asl.l #1,dx>  gefolgt von  <move.l $cc(Ay,Dx),Dz>
   -->  <move.l $cc(Ay,Dx*2),Dz> das <asl.l #1,dx>
    wird dann wegelassen.
   Diese Option wird nicht nur bei obiger Instruktion
   wirksam, diese wurde nur als Beispiel gewählt !
   Diese Option kann zu Fehlern führen da das Ergebnis von
   dx verworfen wird !

 - <add.l dx,dx>  gefolgt von <move.l $cc(Ay,Dx),Dz>
   -->  <move.l $cc(Ay,Dx*2)> das <add.l Dx,Dx> wird wegelassen.
   Diese Option kann zu Fehlern führen da das Ergebnis von
   dx verworfen wird !
   Diese Option wird nicht nur bei <move.l> wirksam,
   dieses wurde nur als Beispiel gewählt !

 - <move.l cc(Ax),Ay>   gefolg von <move.x (Ay),Dz>
   -->  <move [(cc,Ax)],Dz>
   Diese Option kann zu Fehlern führen da das Ergebnis von
   Ay verworfen wird. !
   Diese Option wird nicht nur bei <move.l> wirksam,
   dieses wurde nur als Beispiel gewählt !

 Optimierung mit Hilfe von Makros
   Makros erhöhen die Übersichtlichkeit in der Anzeige !


 - Makrooptimierung Aus- und Einschalten
   Mit diesem Schalter kann bestimmt werden ob In_Go
   überhaupt Makros erzeugen soll !
 - Multi Stack Makros
   Stackbefehle werden zusammengefasst
 - Instruktion + Branch Befehle
   Die Instruktion und der Branchbefehl werden zusammengefasst
 - Gfa-Makros
   Einige spezielle Gfa-Makros werden ausgegeben,sie sind
   für andere Quellen uninteressant.
 - Optimierung Ein/Aus
   Diese Funktion ist mit der Funktion Taste <o> in
   der Hauptanzeige identisch.


@ENDNODE

@NODE PROC "Prozessor Menü"

 Zur Zeit unterstützt In_Go die folgenden Processoren:

  - 68000
  - 68010
  - 68020

 Als Koprocessoren werden unterstützt:

  - MMU
  - Math

  Wenn die entsprechende Option eigestellt ist
  erkennt In_Go die entsprechenden Erweiterungen;
  andernfalls wird ein Fehler angenommen
  und an anderer Stelle wird die Reassemblierung
  fortgeführt.

@ENDNODE

@NODE HUSE "Hunk/Segment Menü"

 Es wird je nach Anwahl zum entsprechenden
 Segment/ @{"Hunk" LINK HUNKG} verzweigt.

 Ein bestimmtes Segment kann auch mit Hilfe der
 Tastatur Marken 0 - 9 Angesprungen werden,
 wenn diese nicht belegt sind.

 Dies funktioniert jedoch nur bei Hunk 0-9

@ENDNODE
