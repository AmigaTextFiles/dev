
; Lektion 13

DESIRE "ONE": DIE KODIERUNG EINES BBS-INTROS AUF AMIGA
9. August 2019 Amiga, Blitter

Endlich der letzte! Nach ein paar Jahren in der Vergangenheit, um die
Programmierung der Amiga-Hardware zu überdenken, ist hier Desire "ONE", die
letzte der Produktionen einer Serie, deren Idee es war, den großen Figuren der
Bühne Tribut zu zollen. Nachdem ich nacheinander den Verdienst von
Grafikdesignern in Scoopex "TWO", Programmierern in Scoopex "ONE", Crackern
in Scoopex "THREE" gelobt habe, ist es daher auf einer Begrüßung an Sysops,
dass der Vorhang definitiv fällt.

Desire "ONE": EIN BBS-Intro über Amiga

Zweifellos gibt es immer noch genug Aspekte der Hardware, die es zu erkunden
gilt, um die Möglichkeit zu finden, Tribute an viele andere Figuren zu
produzieren: Musiker, Swapper, Lieferanten, Spreader, Redakteure und wer weiß.
Wir müssen jedoch mit dem technischen Fortschritt Schritt halten, und ohne
vorzugeben, ein Spezialist zu werden, sondern nur ein wenig zu wissen, wovon
wir sprechen, erfordert es derzeit eine Ausbildung in dichten und vielfältigen
Themen wie nie zuvor: Cloud, Machine Learning, Ethical Hacking, Raytracing usw.
Da die Zeit begrenzt ist - Entwicklung ist nicht meine Aufgabe - scheint mir
diese Einstellung der Zeit eine Priorität zu sein.
Die Produktion, die hier besprochen wird, ist ein BBS-Intro. Mit anderen
Worten, es ist ein Intro, das der Förderung eines Bulletin Board Systems (BBS)
gewidmet ist. Es ist das Ergebnis einer Zusammenarbeit mit der Gruppe Desire,
die auf mehreren Bühnen, einschließlich der Amiga-Szene, sehr aktiv bleibt.
Wie immer: Code, Daten und Erklärungen in allem, was folgt...
Update 15.09.2019: Das BBS-Intro wurde auf der Function 2019 in Budapest
verteilt und das Archiv mit der ADF sowie der Quelle und den Daten steht nun
zum Download bereit.
Um beim Lesen des Artikels zuzuhören...

Klicken Sie hier, um das Archiv mit ADF, Code und Daten aus dem BBS-Intro
herunterzuladen.

CODIERUNG VON
Sobald es nicht üblich ist, beginnen wir mit der kleinen Geschichte. Es ist
wahr, dass es Licht auf die Gründe wirft, warum die technischen Erklärungen,
die Teil für Teil folgen werden, manchmal kurz und bündig sind.
Anfang 2019 ist das Programm, das ich mir gesetzt hatte - ein Intro pro Rolle
der Amiga-Szene zu produzieren, um ihm Tribut zu zollen: Programmierer,
Grafikdesigner usw. - noch nicht fertig. Ich habe jedoch noch ein paar FX auf
Lager, die während des sehr produktiven Sommers 2017 codiert wurden, als ich
wieder anfing, auf Amiga zu programmieren, um Artikel für die Vintage-Sektion
von Programmez! zu schreiben. Darüber hinaus denke ich, dass es an der Zeit 
war, weiterzumachen, nachdem ich begonnen hatte, an anderen ziemlich 
umfangreichen Themen zu arbeiten, einschließlich Machine Learning in Python.
All dies treibt mich an, diese FX so schnell wie möglich in Form einer 
ultimativen Produktion zu verpacken.
Diesmal wende ich mich an die Gruppe Desire, insbesondere Ramon B5, der mir gut
geholfen hat, indem er mir erlaubte, den Grafikdesigner in einer Katastrophe
zu wechseln, um Scoopex "TWO" pünktlich zu veröffentlichen. Im Gegenzug
verpflichtete ich mich, ein BBS-Intro für die Band zu produzieren.
Nachdem ich die FX durchgegangen bin, die ich verwenden könnte, schlage ich
Anfang Juni Ramon B5 das folgende Szenario vor, der es übernimmt - nun, es ist
nicht so, dass ich ihm die Wahl lasse, weil ich überhaupt nicht beabsichtige,
neue FX zu beginnen ... :

Hallo Ramon
Wie bereits erwähnt, ist das Intro eine Hommage an Sysops und Sie haben 
Fastline erwähnt, das eines Ihrer BBS ist (oder war?). Dies kann also ein
BBS-Intro für Fastline sein.
Der erste Teil ist das Signal aus Partikeln, der zweite Teil ist die Wand aus
Scolltexten und der letzte Teil ist das drahtgebundene Netz.
Wir können diese FX verwenden, um eine kleine Geschichte darüber zu erzählen,
wie sich der Datenaustausch auf Wire im Laufe der Zeit entwickelt hat. Zuerst 
gab es nichts (Textbildschirm). Dann ein Träger, um Menschen zu verbinden
(Parrticles). So können die Leute (Wand aus Schriftrollen) auf dem BBS chatten.
Dann kommt das Web (Drahtgeflecht), falls jemals Fastline ins Web verschoben
wurde. Das ist ein bisschen weit hergeholt, aber wir machen es mit jedem FX, 
der verfügbar ist.
Also müssten wir die Geschichte mit Textbildschirmen zwischen den FX erzählen.
Die Texte müssen kurz sein. Sie sind:
1/ Öffnen, um zu sagen, dass der Träger gehört wird
2/ Erzählen Sie nach dem Spediteur, dass Menschen aus ganz Europa mit der
   Fastline BBS verbunden sind und anfangen zu sprechen (Texte werden in
   mehreren Sprachen sein, vorausgesetzt, sie verwenden die A ... Z-Zeichen)
3/ Nachdem die Leute gesprochen haben, sagen Sie, dass die BBS-Ära vorbei ist
   und jetzt die WWW-Ära ist
4/ Schließen Sie, sagen Sie den Leuten, dass sie sich mit jeder Desire-Website
   verbinden können, um weiter zu reden
Ich muss sagen, dass es eine gute Überraschung ist, denn Ramon B5 ist besonders
effektiv, um einen Grafikdesigner und einen Musiker zu finden. Zweifellos zieht
sich der Fall im Sommer hin, weil diese Künstler im Urlaub sind. Das ist jedoch
mein sehr großer Fehler, denn ich wollte sie nicht bitten, etwas zu 
produzieren, bis der Code fertig war.

Alles in allem war die Codierung daher viel weniger chaotisch als die, die ich
im Fall von Scoopex "TWO" erzählt habe." Was man sich merken sollte, ist, dass
ich, was mich betrifft, nämlich den Code, größtenteils damit zufrieden war, zu
verpacken, was es mir ermöglichte, mich genug um die Übergänge zwischen den
verschiedenen Teilen des BBS-Intros zu kümmern. So verschwinden die Partikel,
die Scrolltexte stoppen, das Netz löst sich auf, die Quadrate stabilisieren 
sich allmählich, und all dies wird mit Palettenverblassen kombiniert, die den
Eindruck verstärken, dass alles ruhig miteinander verbunden ist.

DAS SIGNAL: EIN SYSTEM VON PARTIKELN

In diesem Teil zirkuliert ein Teilchengenerator entlang einer Kurve. In
regelmäßigen Abständen erzeugt es ein Teilchen, das sich in eine Richtung
bewegt, die mit der des Generators korreliert. Im Laufe der Zeit verlangsamt
und verdunkelt sich das Teilchen, bis es verschwindet. Bis dahin, wenn es
einen Rand des Bildschirms erreicht, prallt das Partikel davon ab.

Das Signal: eine Nutzung des Partikelsystems
FX basiert auf dem gleichen Partikelsystem wie das von Scoopex "ONE" und wurde
daher bereits ausführlich beschrieben. Der einzige Unterschied besteht in der
Berechnung der Koordinaten des Direktorvektors der Flugbahn eines Teilchens 
bei seiner Erzeugung.
Im vorherigen Fall war dieser Director-Vektor eine Annäherung an die Tangente
zur Trajektorie, die gröbste, weil sie auf die Variation (DX, DY) der
Koordinaten des Generators zwischen dem vorherigen Frame und dem aktuellen
Frame reduziert wurde. In diesem Fall wird dieser Vektor pseudo-zufällig leicht
gestört, indem Größen zu den absoluten Werten von DX und DY addiert werden:

	btst #0,VHPOSR+1(a5)				;Randomize (|DX| += n * bit #1 of raster X position)
	beq _sngNewParticleNoRandomnessX
	addq.w #6,d0						;n set to 6
_sngNewParticleNoRandomnessX:
	btst #0,VHPOSR(a5)					;Randomize (|DY| += n * bit #0 of raster Y position)
	beq _sngNewParticleNoRandomnessY
	addq.w #2,d1						;n set to 2
_sngNewParticleNoRandomnessY:

Wie man sehen kann, liegt die Zufälligkeit in der Position des Rasters zum
Zeitpunkt der Berechnung. Es wird nicht weit schauen, aber es genügt, um das
gewünschte Ergebnis zu erzielen, nämlich dass die Teilchen eine Spur bilden,
die weder zu vorhersehbar noch zu unvorhersehbar vom Generator ist, sozusagen
einen Kometenschweif. Dazu war es besonders wichtig, dass die Trajektorien von
Teilchen, die mit hoher Frequenz erzeugt werden, unterschiedliche
Richtungsvektoren annehmen.
Was die Flugbahn des Generators betrifft, so war es nicht erforderlich, sie in
Echtzeit zu berechnen. Es wurde klugerweise in Excel vorberechnet, in Form
einer Zusammensetzung von Sinus und Kosinus, die als Einführung in einen Kurs
über die Zerlegung von Fourierreihen dienen könnte:
Vorberechnung der Partikeltrajektorie in Excel

DIE BBS: EINE WAND AUS SCROLLTEXTEN IM BLITTER

In diesem Teil wird der Bildschirm in horizontale und vertikale Bildläufe
geschnitten. Der Text wird mit unterschiedlichen Geschwindigkeiten gescrollt
und mit Schriftarten unterschiedlicher Größe mit variabler Breite angezeigt.
Eine Wand aus Scrolltexten in Schriftarten mit variablem Raum
in Excel formalisiert, ist die Aufteilung wie folgt - die Zahlen geben die
Reihenfolge an, in der die Schriftrollen gestartet werden:
Aufbau der Scrollwand
Es ging sicherlich nicht darum, auf die Details der Schriftformate mit
variabler Breite des Systems einzugehen, um den Text anzuzeigen. Stattdessen
wurden Schriftarten dieses Typs auf dem PC von ihrem Vektorformat in das
Bitmap-Format konvertiert, wobei ein Tool verwendet wurde, das von allen, die
in 3D programmieren, sicherlich geschätzt wird: Codeheads Bitmap Font Generator:
Bitmap-Schriftartengenerator von Codehead
Dieses Tool erzeugt jedoch nur eine Bitmap. Es war notwendig, daran zu 
arbeiten, um die notwendigen Informationen zu extrahieren, einschließlich der
Breite jedes Zeichens und der Abszisse seines ersten verwendeten Pixels, und
allgemeiner, um die Pixel in einer Form zu ordnen, die leichter ausgenutzt
werden kann, um eine Schriftrolle anzuzeigen. Die Bitmap-Transformation wurde
mit einem Tool durchgeführt, das gelegentlich in JavaScript codiert wurde:
Der Konverter für Schriftarten mit variabler Breite
Am Ende wird eine Bitmap in eine .vfnt-Datei konvertiert, deren Format
maßgeschneidert ist:

0	Anzahl der Zeichen
1	ASCII-Code des ersten Zeichens
2	Breite eines Zeichens (N für 2N Pixel)
3	Höhe eines Zeichens (N für 2N Pixel)
4	Polsterung rechts
5	Breite des Abstands zwischen zwei Zeichen

Die Polsterung auf der rechten Seite ist ein leeres Feld auf der rechten Seite
des Zeichens, so dass das nächste nicht sofort daran klebt, auch wenn der
Abstand zwischen den Zeichen Null ist. Um ehrlich zu sein, ich erinnere mich
nicht einmal, warum ich das geplant habe ...
Darauf folgt eine Tabelle mit Charakterinformationen. Für jeden finden wir
einfach:
0	Abszisse, bei der der Charakter in seiner Bitebene beginnt
1	Abszisse, bei der das Zeichen in seiner Bitebene endet, plus das Paddding
    auf der rechten Seite

Folgen Sie den tatsächlichen Daten der Zeichen, dh nacheinander, den Zeilen
der Bitebene von jedem.
Die Darstellung einer Schriftrolle hat keine Subtilität. In jeder Phase wird
der Teil, der sichtbar bleiben muss, kopiert, wobei der Blitter in Richtung
der Parade verschoben wird, und ein neuer Teil des letzten Charakters und / 
oder des nächsten Charakters wird im freigegebenen Teil angezeigt. Die einzige
Subtilität ist, dass dieser neue Teil unterschiedlich angezeigt wird, je
nachdem, ob der Bildlauf horizontal oder vertikal ist:
Wenn der Bildlauf horizontal ist, wird der Blitter verwendet, um gerade Linien
zu zeichnen, deren Muster einer 16-Pixel-Spalte eines Zeichens entspricht - 
was mehrere Rechtsstriche erfordern kann, wenn die Höhe des Zeichens mehr als
16 Pixel beträgt. Diese Technik wurde bereits hier beschrieben, wo sie 
verwendet wird, um die 16-Pixel-Spalten der Zeichen einer Sinusrolle zu 
zeichnen. Warum den Blitter verwenden? Denn dies ermöglicht es, auf 
komplizierte Operationen des Maskierens und Verschiebens von Bits in 
Spalten von Bits, die dasselbe Wort von aufeinanderfolgenden Zeilen des
Bildschirms kreuzen, zu verzichten oder sie zu positionieren oder zu löschen.
Umgekehrt, wenn der Bildlauf vertikal ist, ist es die CPU, die verwendet wird,
um genau dasselbe zu tun. Warum die CPU? Denn es geht hier nie darum, ein oder
mehrere Wörter zu schreiben, die eine Pixelspalte eines Charakters bilden. 
Keine Notwendigkeit für komplizierte Maskierungs- und Schaltvorgänge, also
keine Notwendigkeit für Blitter, um Ihr Leben zu vereinfachen.
Um all dies zu optimieren, sehen wir, dass es notwendig war, dass die Höhe
eines Charakters immer ein Vielfaches von 16 war. Aus diesem Grund besteht die
Wand nur aus Bildblättern mit einer Höhe von 16, 32 oder 64 Pixeln, wenn sie
horizontal sind, breit, wenn sie vertikal sind.

DAS WEB: EIN 2D-NETZ, DAS DURCH EINEN ATTRAKTOR VERZERRT WIRD

In diesem Teil scheint sich ein Netz periodisch zu bewegen und zurückzuziehen,
während es eine lokalisierte Verformung erfährt, wobei die Zertifikate seiner
Punkte von einem unsichtbaren Attraktor in Bewegung angezogen zu werden
scheinen. Darüber hinaus ist das Netz gefärbt, als ob es ein relatives Relief 
hätte.
Ein Netz, das durch einen unsichtbaren Attraktor verzerrt wird
Die grundlegenden Mechaniken stammen aus einem kurzen JavaScript-Programm, das
hier vorgestellt wird und das ich vor langer Zeit geschrieben habe, als ich 
lernte, wie man Vertex-Shader für WebGL programmiert.
Das Netz ist also nicht in 3D, sondern in 2D. Es setzt sich aus MESH_DX in
MESH_DY Punkten zusammen. An jedem Frame wird ein Punkt entlang des Vektors
bewegt, der den Attraktor an diesem Punkt verbindet, entsprechend einer
Amplitude, die vom Verhältnis zwischen der "Entfernung" des Punktes zum 
Attraktor und der von diesem ausgeübten Kraft abhängt. Die Entfernung wird in
Anführungszeichen angegeben, da wir uns auf eine Annäherung verlassen:
d = max (|dx|, |dy|) + (min (|dx|, |dy|) >> 2) + (min (|dx|, |dy|) >> 3)
Diese Annäherung ist wohl schon von überflüssiger Präzision, denn wie immer
zählt bei einem FX nur das Ergebnis. Mit anderen Worten, die Strenge der
Berechnungen spielt keine Rolle, es reicht aus, dass es auf dem Bildschirm gut
"geht".
Der Attraktor dreht sich auf einem Kreis, der auf dem Bildschirm zentriert ist,
Radius MSH_RADIUS. Seine Stärke variiert je nach linearer Interpolation 
zwischen einem minimalen MSH_STRENGTH_START und einem maximalen 
MSH_STRENGTH_END in MSH_STRENGTH_STEPS Schritten, wobei das Minimum und das
Maximum umgekehrt werden, wenn die Kraft einen dieser Terminals erreicht.
So variiert die Kraft, die der Attraktor auf einen Punkt ausübt, unabhängig
von diesem Punkt - er oszilliert zwischen zwei Enden - und er variiert auch je
nach letzterem - er nimmt ab, während der Abstand vom Punkt zum Attraktor 
zunimmt. Wie immer ist es daher die Konjugation elementarer Transformationen,
die es ermöglicht, eine scheinbar komplexe Transformation zu erzeugen, da das
Netz wie in 3D erscheint.
Der einzige Punkt, der ein wenig knifflig ist, ist das Clipping. Tatsächlich
kann die Verformung des Netzes dazu führen, dass Punkte aus der Oberfläche 
des Bildschirms hervortreten. Eine Lösung wäre gewesen, sich mit einer 
größeren Rendering-Oberfläche als der angezeigten Marge zu versehen. Es wäre
somit möglich gewesen, innerhalb einer bestimmten Grenze gerade Linien über 
den Bildschirm zu ziehen, ohne sich Gedanken darüber machen zu müssen, sie
beschneiden zu müssen. Zum Spaß ist es eine weniger bequeme Lösung, die 
angenommen wurde, die daher aus Clipper besteht.
Das Beschneiden einer geraden Linie ist keine komplizierte Operation - es ist
nicht wie das Beschneiden eines Polygons. Der erste Schritt besteht darin, die
Enden der rechten Seite zu ziehen, um immer mit dem höchsten Punkt zu beginnen.
Es folgt ein vertikaler Ausschnitt, der einfach auf dem Satz von Thales 
basiert. Die Punkte werden dann so sortiert, dass sie immer mit dem Punkt ganz
links beginnen, bevor mit dem horizontalen Beschneiden fortgefahren wird. Das
Sortieren von Punkten schränkt die Vorgänge zum Testen des Zeichens ein.
Schließlich wird die Färbung des Netzes sehr einfach durch Nachglühen erzeugt.
Bei jedem Frame wird die Bitebene 2 zu 3, aus 3 wird 4 und 4 wird aus der 
Ansicht entfernt, um als Backbuffer für den nächsten Frame zu dienen. Was die 
Bitebene 2 betrifft, so wird sie durch den Backbuffer des aktuellen Frames 
ersetzt, dh die Bitplane, die nicht angezeigt wird, wo das neue Bild der
Mesh-Animation gerade gerendert wurde. Unter diesen Bedingungen überlappen 
sich die in Bitebenen verwendeten Bits umso mehr, als sich das Netz wenig 
von einem Bild zum anderen bewegt hat. Dies, um die Amplitude der Bewegung
mehr oder weniger mit Farben über eine Palette in Beziehung zu setzen, deren 
Farben auf Lila ziehen, wo sich das Netz wenig bewegt, und auf Blau, wo es 
sich viel bewegt.
Am Ende des Spiels verschwindet das Netz allmählich. Da alle Linien zum 
Blitter aufgetragen werden - missbräuchlich, übrigens, weil der Coprozessor 
nur verwendet werden sollte, wenn es sich lohnt - ist der Effekt einfach zu 
erzeugen. In der Tat, wie im Fall der zuvor beschriebenen vertikalen 
Scrollanzeige, geht es darum, mit dem Wert von BLTBDAT zu spielen, der dem 
Muster entspricht, das der Blitter wiederholt, wenn er eine Linie zeichnet.
Ausgehend von einem Wert von $FFFF, der einer durchgezogenen Linie entspricht,
geht es darum,Bits dieses Wertes allmählich zu löschen, um die Linie allmählich
zu löschen. Was die Wahl des neuen Bits betrifft, das bei jedem Schritt 
gelöscht werden soll, muss es von der Ästhetik diktiert werden. Hier geht es
darum, die gelöschten Bits so gut wie möglich auf der rechten Seite zu 
verteilen:
Animieren des Musters einer Netzlinie

CONSUMMATUM IST...

Bitte schön! Wie üblich lohnt es sich, mit den unvermeidlichen Grüßen zu
schließen. Ich möchte daher insbesondere folgendem danken:
Ramon B5 für seine Führung und seine Texte;
Bokanoid für Grafiken.
Gelitten für die Musik.
Und ich grüße diejenigen, die so weit gegangen sind, das BBS-Intro auf der
Function 2019 auf echter Hardware zu präsentieren:
Desire "ONE" auf der Function 2019
Wie zu Beginn dieses Artikels erwähnt, ist es diesmal wirklich das letzte.
WinUAE bleibt nur auf meinem PC, damit ich für einen Moment in die 
Vergangenheit reisen kann, nicht um etwas zu programmieren.
Im Nachhinein finde ich es durchaus amüsant, auf demjenigen, der in den wenigen
Jahren - vom Sommer 2017 bis zum Frühjahr 2019, vor allem aber 2018 - meine
Lieblingsmaschine bleiben wird, wohl mehr produziert zu haben als in den 90er
Jahren. Aber es muss gesagt werden, dass ich zu dieser Zeit das Programmieren
entdeckte, ohne auch von der Möglichkeit zu profitieren, Werkzeuge so einfach
erstellen zu können, die mir helfen wie die, die ein Webbrowser bieten kann.
Und schließlich habe ich nicht viel mehr Zeit damit verbracht, aus den
Cracktros herauszukommen, nach den Daten zu urteilen, die auf Janeway berichtet
wurden. Trotzdem habe ich fast nur das getan, was am Ende des Jahrzehnts 
sicherlich nicht der Fall war, wie jeder anhand der Vielfalt der Themen 
beurteilen kann, die in diesem Blog behandelt werden...
Es ist notwendig, die Chance zu messen, die das Web bieten kann, um in die
Vergangenheit zu reisen, um sich in den Kontext einer Ära zu stellen, in der
Enthusiasten darum kämpfen, das zu bewahren, was es für sie zur Hauptattraktion
gemacht hat. Sie kämpfen nicht gegen den allgemeinen Fluss der Zeit, der
unaufhaltsam vergeht und alles in Vergessenheit gerät - wer könnte das? Auf 
Kosten erheblicher Anstrengungen gruben sie einen Kanal, um das zu unterhalten,
was sie für wichtig hielten, was zu einem Rückhaltebecken führt, in dem alles
erhalten ist, ein echter Jungbrunnen für denjenigen, der wie sie die Zeit
kannte, wenn er beschließt, seinen Fuß darin zu tauchen.
Die Herausforderung besteht nur darin, die Hand zu reichen. Aber wer 
interessiert sich heute unter denen, die ihn damals nicht kannten, für den
Amiga? Ich bezweifle, dass es viele von ihnen gibt. Dennoch, da es schließlich
nur einen braucht, um eine Stadt zu retten, muss die Aufgabe darin bestehen,
Berufungen zu wecken, indem man das gute Wort verbreitet. Wenn Scoopex "ONE",
Scoopex "TWO", Scoopex "THREE" und Desire "ONE"," sowie alle Artikel, die auf
diesem Blog und im Programm veröffentlicht wurden! Eines Tages helfen können,
wird mein Moment der Herrlichkeit dieser sein. 
