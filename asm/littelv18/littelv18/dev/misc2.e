OPT MODULE 
 
OPT LARGE 
 
->modul f”r lc16.e 
->hehe! created superb new tempstring : streamstring ! 
->no more guessing the size of tempdata! 
->when the bugffer is reached, it writes out the 
->contents and the buffer is empty and ready for more strings. 
-> hmm.. joining the files is back... 
-> gotta do that... 
-> 21 Feb 00 : changing streamstring into 'stream'.. 
-> more allround, can now be used for any data. 
 
MODULE 'dos/dos' 
 
 
EXPORT OBJECT longstack 
   PRIVATE 
   ptr:PTR TO LONG 
   mem 
   size 
ENDOBJECT 
 
EXPORT OBJECT stringstack 
   PRIVATE 
   first 
   current 
   nrof 
ENDOBJECT 
 
OBJECT stream 
   PRIVATE 
   mem 
   ptr 
   blocksize 
   currlen 
   fh 
ENDOBJECT 
 
 
   ->EXPORT DEF procnum 
   ->EXPORT DEF nostartup 
   EXPORT DEF modestr, linkfiles, filename 
 
   DEF fh2 
   DEF fh3 
   DEF fh4 
   DEF fh5 
 
   ->DEF bs1:PTR TO bigstring  -> EQU o likn 
   DEF bs2:PTR TO stream  -> incdir, include..xref, xdef.. 
   DEF bs3:PTR TO stream  -> code 
   DEF bs4:PTR TO stream  -> data 
   DEF bs5:PTR TO stream  -> bss 
 
 
 
EXPORT PROC write1(str, len=NIL) IS bs2.add(str, StrLen(str)) 
 
EXPORT PROC write2(str, len=NIL) IS bs2.add(str, StrLen(str)) 
 
EXPORT PROC write3(str, len=NIL) IS bs3.add(str, StrLen(str)) 
 
EXPORT PROC write4(str, len=NIL) IS bs4.add(str, StrLen(str)) 
 
EXPORT PROC write5(str, len=NIL) IS bs5.add(str, StrLen(str)) 
 
EXPORT PROC misc_initmodule() 
   openWrite() 
ENDPROC 
 
EXPORT PROC misc_endmodule() 
   closeWrite() 
ENDPROC 
 
PROC file2header() 
   write2('\n MACHINE 68020\n') 
   IF StrCmp(modestr, 'LIBRARY') THEN RETURN 
   write2('\n xdef programstart_\n') 
   write2(' xref littel_a4\n') 
   write2(' xref _DOSBase, _SysBase, _IntuitionBase\n') 
   write2(' xref _GraphicsBase, _UtilityBase\n') 
   write2(' xref _arg, _stdin, _stdout\n') 
   write2(' xref _exception, _exceptioninfo\n') 
   write2(' xref _G1, _G2, _G3, _G4\n') 
ENDPROC 
 
 
PROC openTempFiles() 
   fh2 := Open('t:littel_2', MODE_NEWFILE) 
   fh3 := Open('t:littel_3', MODE_NEWFILE) 
   fh4 := Open('t:littel_4', MODE_NEWFILE) 
   fh5 := Open('t:littel_5', MODE_NEWFILE) 
   Write(fh2, '     \n', 6) 
   Write(fh3, '     \n', 6) 
   Write(fh4, '     \n', 6) 
   Write(fh5, '     \n', 6) 
ENDPROC 
 
PROC closeTempFiles() 
   Close(fh2) 
   Close(fh3) 
   Close(fh4) 
   Close(fh5) 
ENDPROC 
 
PROC deleteTempFiles() 
   ->DeleteFile('t:littel_2') 
   ->DeleteFile('t:littel_3') 
   ->DeleteFile('t:littel_4') 
   ->DeleteFile('t:littel_5') 
ENDPROC 
 
PROC joinTempFiles() 
   DEF str[200]:STRING 
   StringF(str, 
   'JOIN t:littel_2 t:littel_3 t:littel_4 t:littel_5 TO t:\s.asm', 
   FilePart(filename))
   SystemTagList(str, NIL) 
ENDPROC 
 
PROC openWrite() 
   openTempFiles() 
   NEW bs2.new(1000, fh2) -> 4x 1k writebuffers 
   NEW bs3.new(1000, fh3) -> 
   NEW bs4.new(1000, fh4) -> 
   NEW bs5.new(1000, fh5) -> 
   write1('\n;code generated by LITTEL (littel_a68k.library v5.17b)\n') 
   write3('\n NEAR A4,-1\n CODE\n\n') 
   write3('programstart_:\n') 
   write4('\n ;DATA.. in code-section...\n') 
   write5('\n BSS           \n') 
ENDPROC 
 
PROC closeWrite() 
   file2header() 
   write5('\n END\n') 
   bs2.flush() 
   bs3.flush() 
   bs4.flush() 
   bs5.flush() 
   closeTempFiles() 
   joinTempFiles() 
   deleteTempFiles() 
ENDPROC 
 
EXPORT PROC phxassIt() 
   DEF str[200]:STRING 
   IF StrCmp(modestr, 'EXE') 
      StringF(str, ' PHXASS t:\s.asm TO t:\s.o QUIET NOEXE OPT 3',
      FilePart(filename), FilePart(filename))
   ELSEIF StrCmp(modestr, 'OBJECT') 
      StringF(str, ' PHXASS t:\s.asm TO \s.o QUIET NOEXE OPT 3',
      FilePart(filename), FilePart(filename))
   ELSEIF StrCmp(modestr, 'LIBRARY') 
      StringF(str, ' PHXASS t:\s.asm TO t:\s.o QUIET NOEXE OPT 3',
      FilePart(filename), FilePart(filename))
   ENDIF 
   SystemTagList(str, NIL) 
   StringF(str, 't:\s.asm', filename) 
   ->DeleteFile(str) 
ENDPROC 
 
EXPORT PROC linkIt() 
   DEF str[200]:STRING 
   IF StrCmp(modestr, 'EXE') 
      StringF(str, 
'phxlnk LITTEL:lib/startup.o \s t:\s.o TO \s SD SC', 
      linkfiles, FilePart(filename), filename)
   ELSEIF StrCmp(modestr, 'OBJECT') 
      RETURN 
   ELSEIF StrCmp(modestr, 'LIBRARY') 
      StringF(str, 'phxlnk \s t:\s.o TO \s', 
      linkfiles, FilePart(filename), filename)
   ENDIF 
   SystemTagList(str, NIL) 
   StringF(str, 't:\s.o', filename) 
   ->DeleteFile(str) 
ENDPROC 
 
EXPORT PROC new(size) OF longstack 
   self.mem := AllocMem(size, NIL) 
   self.ptr := self.mem 
   self.size := size 
ENDPROC 
 
EXPORT PROC end() OF longstack IS FreeMem(self.mem, self.size) 
 
EXPORT PROC next() OF longstack 
   self.ptr := 4 + self.ptr 
ENDPROC 
 
EXPORT PROC prev() OF longstack 
   self.ptr := (self.ptr) - 4 
ENDPROC 
 
EXPORT PROC get() OF longstack IS self.ptr[] 
 
EXPORT PROC set(value) OF longstack 
   self.ptr[] := value 
ENDPROC 
 
 
PROC new() OF stringstack 
   self.first := String(10) 
   self.current := self.first 
   self.nrof := NIL 
ENDPROC 
 
PROC end() OF stringstack 
   DisposeLink(self.first) 
ENDPROC 
 
PROC add(str, strlen=NIL) OF stringstack 
   DEF newstr 
   IF strlen = NIL THEN strlen := StrLen(str) 
   newstr := String(strlen + 1) 
   StrAdd(newstr, str) 
   Link(self.current, newstr) 
   self.current := newstr 
   self.nrof := 1 + self.nrof 
ENDPROC 
 
PROC rem() OF stringstack 
   DEF str 
   DEF n 
   DisposeLink(self.current) 
   self.nrof := (self.nrof) - 1 
   n := self.nrof 
   str := self.first 
   WHILE n > 0 
      str := Next(str) 
      n-- 
   ENDWHILE 
   Link(str, NIL) 
   self.current := str 
ENDPROC 
 
PROC get() OF stringstack IS self.current 
 
 
PROC new(blocksize, fh) OF stream 
   self.mem := AllocMem(blocksize, NIL) 
   self.ptr := self.mem 
   self.blocksize := blocksize 
   self.currlen := 0 
   self.fh := fh 
ENDPROC 
 
PROC end() OF stream IS FreeMem(self.mem, self.blocksize) 
 
PROC add(str, len) OF stream 
   IF (len + 1 + self.currlen) > self.blocksize THEN self.flush() 
   AstrCopy(self.ptr, str, len + 1) 
   self.ptr := (self.ptr) + len 
   self.currlen := (self.currlen) + len 
ENDPROC 
 
PROC flush() OF stream 
   Write(self.fh, self.mem, self.currlen) 
   self.ptr := self.mem 
   self.currlen := 0 
ENDPROC 
 
 
 
 
  
