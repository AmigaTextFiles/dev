@database "LITTEL.guide" 
@node Main "LITTEL v18 b" 
 
 
       LITTEL v18  
 
      @{" Read Me First                   " link rmf}
      @{" Introduction                    " link intr} 
      @{" Installation                    " link inst} 
      @{" Data, Values, Regs, variables   " link dav} 
      @{" Integer Instructions            " link Int} 
      @{" Logic Instructions              " link Logic} 
      @{" Shift Instructions              " link Shift} 
      @{" Bit Instructions                " link Bit} 
      @{" Data Transfer Instructions      " link DataTrans} 
      @{" Flow Control Instructions       " link Flow} 
      @{" Exception Handling Instructions " link Exceptions} 
      @{" Misc Keywords                   " link misckeys} 
      @{" Regular Keywords                " link regukeys} 
      @{" Misc Support Keywords           " link miscsupps} 
      @{" Compiler Control Keywords       " link compkeys} 
      @{" Startup Globals                 " link stgl} 
      @{" What is new ?                   " link win} 
      @{" Whats up ?                      " link future}
      @{" Bugs / Limitations              " link buglim}
      @{" Author                          " link aut}
      @{" Alphabetical Index              " link Index} 
 
      ·········································· ° 
          _ ° ___ ______ _____°____ _ 
      ° ° ||  |__||__  _¡_  __|| __||| °   ° ° 
       °  || ° __°  | |   | |  | __ || °   ° 
         °||__ | |° | | ° | | °| __ ||__ ° 
        ° |___||_|° |_|° °|_|° |___||___|° ° 
        ° ° ° ° ° ° ° ° ° ° ° ° ° ° ° ° ° ° ° 
      ·········································· 
 
                 Public Release 6 
 
             © Leif Salomonsson 1999-2000 
 
 
@endnode 
 
********************************************************** 

@node rmf "Read Me First"

   LittelComp.lha v18b Public Release 6

   Distribution
      As original untouched archive only.

   Terms Of Usage
      Any contents of this package may NOT be used
      for any Commercial or Military purposes.

   Warranty
      NONE WHAT SO EVER


@endnode
 
@node intr "Introduction" 
 
   LITTEL (littel_a68k.library) is a compiler with library-interface. 
   With the supplied parser (LC/lc17) for textfiles, you can compile 
   .l files. 
 
   o Small and fast binaries. 
   o Easy and powerful Creation/Use of .library and .object files. 
   o Typeless in that it treats all values as LONGs. 
   o Smart optimisation of loops and selects. 
   o Exception handling. 
   o MacroFunctions
   o Its FREE! 
 
@endnode 
 
@node inst "Installation" 
 
   Add 'assign LITTEL: drawerwhereitwasunpacked' to user-startup. 
   Copy littel_a68k.library to libs: 
 
@endnode 
 
@node dav "Data, Values, Regs and Variables" 
 
   They can all be used the same way 
   from now on called xxx 
 
   xxx 
   xxx[] 
   xxx[L/W/B] 
   xxx[].offset    ;offset is an numericvalue/constant, does NOT work like an INDEX. 
 
   Regs            : A0 a0 D3 d2 etc 
   Global variable : _anynameAnycase 
   Local Variable  : beginsWithLowercase 
   STRING,L/W/BLKK,LONGS,WORDS,BYTES : _anynameAnycase
 
   LITTEL uses d4,d5/a6 for scratch. 
   d6 for internal optimisations. 
   d7 for exceptions. 
   A5 for local vars. 
   D0-D3/A0-A3 an always be used by programmer. 
 
   See examples for more info. 
 
@endnode 
 
 
*********************************************************** 
 
@node Int "Integer Instructions" 
 
   @{"ADD   " link Add} 
   @{"SUB   " link Sub} 
   @{"DIV   " link Divs} 
   @{"DIVF  " link DivF} 
   @{"MUL   " link Mul} 
   @{"NEG   " link Neg} 
   @{"ABS   " link Abs} 
   @{"MAX   " link Max} 
   @{"MIN   " link Min} 
   @{"LMT   " link Lmt} 
   @{"INC   " link Inc} 
   @{"DEC   " link Dec} 
   @{"CND   " link Cnd} 
   @{"NOP   " link Nop} 
@endnode 
 
@node Add "ADD" 
 
   Add x to d 
 
      ADD x, d 
      ADD x, d, ad 
@endnode 
 
@node Sub "SUB" 
 
   Sub x from d 
 
      SUB x, d 
      SUB x, d, ad 
@endnode 
 
@node Div "DIV" 
 
   Divide t with w  (020+) 
 
      DIV w, t 
      DIV w, t, ad 
@endnode 
 
@node DivF "DIVF" 
 
   Divide t with w and put result in quotinent, remainder (020+) 
 
      DIVF w, t, q, r 
 
@node Mul "MUL" 
 
   Multiply t with w  (020+) 
 
      MUL w, t 
      MUL w, t, ad 
@endnode 
 
@node Neg "NEG" 
 
   Negate t 
 
      NEG t 
      NEG t, ad 
@endnode 
 
@node Abs "ABS" 
 
   Make vaule in t absolute 
 
      ABS t 
      ABS t, ad 
@endnode 
 
@node Max "MAX" 
 
   Get the maximum value of x and y in d 
 
      MAX x, y, d 
@endnode 
 
@node Min "MIN" 
 
   Get the minimum value of x and y in d 
 
      MIN x, y, d 
@endnode 
 
@node Lmt "LMT" 
 
   Truncate the value in t to min and max bounds 
 
      LMT max, min, t 
@endnode 
 
@node Inc "INC" 
 
   Increase t by 1 
 
      INC t 
 
   Increase t by value val 
 
      INC t, val:dvc 
      INC t, val:dvc, ad 
@endnode 
 
@node Dec "DEC" 
 
   Decrease t by 1 
 
      DEC t 
 
   Decrease t by the value val 
 
      DEC t, val:dvc 
      DEC t, val:dvc, ad 
@endnode 
 
@node Cnd "CND" 
 
   IF condition a ?? b then put TRUE in D0 else FALSE 
 
      CND a ?? b 
 
   IF condition a ?? b then put TRUE in d else FALSE 
 
      CND a ?? b, d 
 
      ?? = </>/=/<>/<=/>= 
@endnode 
 
@node Nop "NOP" 
 
   Do nothing (puts a 68k NOP instruction) 
 
      NOP 
@endnode 
 
 
*********************************************************** 
 
@node Logic "Logic Instructions" 
 
   @{"AND " link And} 
   @{"XOR " link Xor} 
   @{"OR  " link Or} 
   @{"NOT " link Not} 
@endnode 
 
@node And "AND" 
 
   Logical AND a into b 
 
      AND a, b 
      AND a, b, ad 
@endnode 
 
@node Xor "XOR" 
 
   Logical XOR a into b 
 
      XOR a, b 
      XOR a, b, ad 
@endnode 
 
@node Or "OR" 
 
   Logical OR a into b 
 
      OR a, b 
      OR a, b, ad 
@endnode 
 
@node Not "NOT" 
 
   Logical NOT a 
 
      NOT a 
      NOT a, ad 
@endnode 
 
 
*********************************************************** 
 
@node Shift "Shift Instructions" 
 
   @{"SHL " link Shl} 
   @{"SHR " link Shr} 
@endnode 
 
@node Shl "SHL" 
 
   Logical Shift a one step to left 
 
      SHL a 
 
   Logical shift a b steps to left 
 
      SHL a, b 
      SHL a, b, ad 
@endnode 
 
@node Shr "SHR" 
 
   Logical Shift a one step to right 
 
      SHR a 
 
   Logical shift a b steps to right 
 
      SHR a, b 
      SHR a, b, ad 
@endnode 
 
 
 
*********************************************************** 
 
@node Bit "Bit(32) Manipulation Instructions" 
 
   @{"BCHG" link Bchg} 
   @{"BCLR" link Bclr} 
   @{"BSET" link Bset} 
   @{"BGET" link Bget} 
@endnode 
 
@node Bchg "BCHG" 
 
   Toggle bit b in a 
 
      BCHG b, a 
      BCHG b, a, ad 
 
@endnode 
 
@node Bclr "BCLR" 
 
   Clear bit b in a 
 
      BCLR b, a 
      BCLR b, a, ad 
@endnode 
 
@node Bset "BSET" 
 
   Set bit b in a 
 
      BSET b, a 
      BSET b, a, ad 
@endnode 
 
@node Bget "BGET" 
 
   Get bit b in a and put result in c 
 
      BGET b, a, c 
 
      NOTE : c will be <> NIL if bit is 1, else NIL 
                       ^^^^^^ 
@endnode 
 
 
*********************************************************** 
 
@node DataTrans "Data tranfer Instructions" 
 
   @{"COPY " link Copy} 
   @{"SWAP " link Swap} 
   @{"PUSH " link Push} 
   @{"POP  " link Pop} 
   @{"REMS " link Rems} 
   @{"RTOS " link Rtos} 
   @{"STOR " link Stor} 
@endnode 
 
@node Copy "COPY" 
 
   Copy from a to b 
 
      COPY a, b 
@endnode 
 
@node Swap "SWAP" 
 
   Swap contents of a and b 
 
      SWAP a, b 
@endnode 
 
@node Push "PUSH" 
 
   Push data to stack 
 
      PUSH a, b, c, d,... etc 
 
      NOTE : data is pushed from left. 
@endnode 
 
@node Pop "POP" 
 
   Pop data from stack into 'vars' 
 
      POP a, b, c, d,... etc 
 
      NOTE : first value in a 
@endnode 
 
@node Rems "REMS" 
 
   Remove n nr of values from stack (cleanup) 
 
      REMS n:dvc 
@endnode 
 
@node Rtos "RTOS" 
 
   Push regs to stack 
 
      RTOS reglist 
@endnode 
 
@node Stor "STOR" 
 
   Pop regs from stack 
 
      STOR reglist 
@endnode 
 
*********************************************************** 
 
@node Flow "Flow Control Instructions" 
 
   @{"BIC   " link Bic} 
   @{"BAL   " link Bal} 
   @{"DPR   " link Dpr} 
   @{"CDPR  " link Cdpr} 
   @{"CLL   " link Cll} 
   @{"CCLL  " link Ccll} 
   @{"DMF   " link Dmf} 
   @{"RET   " link Ret} 
@endnode 
 
@node Bic "BIC" 
 
   Branch If Condition (is true) 
 
      BIC a ?? b, label 
 
      ?? = </>/<>/=/<=/>= 
@endnode 
 
@node Bal "BAL" 
 
   Branch ALways 
 
      BAL label 
@endnode 
 
@node Dpr "DPR" 
 
   Do PROC 
 
      DPR label (arguments,,) 
@endnode 
 
@node Cdpr "CDPR" 
 
   Do PROC with Exception Check 
 
      CDPR label (arguments,,) 
@endnode 
 
@node Cll "CLL" 
 
   Call subroutine by adress and offset 
 
      CLL baseaddress offset:dvc 
@endnode 
 
@node Ccll "CCLL" 
 
   Call subroutine by address and offset -with Exception Check- 
 
      CCLL baseaddress offset:dvc 
@endnode 
 
@node Dmf "DMF" 
 
   Call Macro Function (considered keyword) 
 
      DMF NameOfFunction [,arguments,,.] 
@endnode 
 
@node Ret "RET" 
 
   Return earlier from subroutine 
 
      RET [returnvalues,,] 
@endnode 
 
 
 
 
*********************************************************** 
 
@node Exceptions "Exception Handling Instructions" 
 
   ;@{"CHECK " link Check} 
   @{"THROW " link Throw} 
   @{"RTHRW " link Rthrw} 
   @{"RAISE " link Raise} 
@endnode 
 
@node Throw "THROW" 
 
   Throw an exception (from within EXCEPT block) 
 
      THROW exception [exceptioninfo] 
@endnode 
 
@node Rthrw "RTHRW" 
 
   Throw current exception (from within EXCEPT block) 
 
      RTHRW 
@endnode 
 
@node Raise "RAISE" 
 
   Raise an exception (not allowed within EXCEPT block) 
 
      RAISE exception [exceptioninfo] 
 
   With condition 
 
      RAISE exception, exceptioninfo, a ?? b 
@endnode 
 
************************************************************ 
 
@node regukeys "Regular Keywords" 
 
   @{"LAB       " link Lab} 
   @{"PROC      " link Proc} 
   @{"ENDPROC   " link Endproc} 
   @{"CODESTART " link Codestart} 
   @{"EXCEPT    " link Except} 
   @{"VAR       " link Var} 
   @{"GVAR      " link Gvar} 
   @{"STRING    " link String} 
   @{"LONGS     " link Longs} 
   @{"WORDS     " link Words} 
   @{"BYTES     " link Bytes} 
   @{"LBLK      " link Lblk} 
   @{"WBLK      " link Wblk} 
   @{"BBLK      " link Bblk} 
   @{"MKLBLK    " link MkLBlk} NEW!
@endnode 
 
@node Lab "LAB" 
 
   Define a code-label 
 
      LAB labelname 
@endnode 
 
@node Proc "PROC" 
 
   Declare start and name of Procedure 
 
      PROC procname () 
 
   With receiving of parameters on the stack 
 
      PROC procname (%param1,%mypar2,%par3...) etc 
@endnode 
 
@node Endproc "ENDPROC" 
 
   Declare end of procedure 
 
      ENDPROC 
 
   With returnvalues 
 
      ENDPROC val1,val2,val3,,.. etc  (max 6) 
@endnode 
 
@node Codestart "CODESTART" 
 
   Tell where code starts in PROC with params or local vars 
 
      CODESTART 
@endnode 
 
@node Except "EXCEPT" 
 
   Define Except block for a PROCedure 
 
      EXCEPT 
      EXCEPT DO 
@endnode 
@node Var "VAR" 
 
   Define local variable(s) 
 
      VAR varname [varname,varname,va....] 
@endnode 
@node Gvar "GVAR" 
 
   Define Global Variable(s) 
 
      GVAR _name [_name,_na..] 
@endnode 
@node String "STRING" 
 
   Define a String 
 
      STRING _name "stringcontents" 
 
      NOTE : nil-termenation is automatic 
@endnode 
@node longs "LONGS" 
 
   Define an initialised block of LONGs. 
 
   LONGS _name 1,2,3,4,5,-32,90 
@endnode 
@node words "WORDS" 
 
   Define an initialised block of WORDs. 
 
   WORDS _name 1,2,3,4,5,-32,90 
@endnode 
@node bytes "BYTES" 
 
   Define an initialised block of BYTEs. 
 
   BYTES _name 1,2,3,4,5,32,90 
@endnode 
@node lblk "LBLK" 
 
   Define an uninitialised block of LONGs. 
 
   LBLK _name nrofelements 
@endnode 
@node wblk "WBLK" 
 
   Define an uninitialised block of WORDs. 
 
   WBLK _name nrofelements 
@endnode 
@node bblk "BBLK" 
 
   Define an uninitialised block of BYTEs. 
 
   BBLK _name nrofelements 
@endnode 

@node MkLBlk "MKLBLK" 
 
   This is an instruction, really.

   Make Local Block 
 
   MKLBLK varname size

   varname is here the already declared
   local variable that will point to this block.

   size is the size of the block (MUST be divable by four (4) !)

   Implementation of this one can change in future.
 
@endnode 
 
************************************************************ 
 
@node compkeys "Compiler Control Keywords" 
 
   @{"#mode            " link Mode} 
   @{"#link            " link Link} 
   @{"#incdir          " link Incdir} 
   @{"#include         " link Include} 
   @{"#xdef            " link Xdef} 
   @{"#xref            " link Xref} 
   @{"#equ             " link Equ} 
   @{"#fdef            " link Fdef} 
   @{"#endfdef         " link Endfdef} 
   @{"#makei           " link Makei} 
   @{"#makefd          " link Makefd} 
   @{"#makelvo         " link Makelvo} 
   @{"#libraryEnv      " link LE} 
   @{"#RegPreserve     " link RP} 
@endnode 
 
@node Mode "#mode" 
 
   Choose between EXE(default), OBJECT and LIBRARY 
 
   #mode OBJECT 
 
   #mode EXE 
 
   #mode LIBRARY ver rev name id 
 
@endnode 
 
@node link "#link" 
 
   Link with .o or .lib file(s) 
 
   #link mylinklib.lib myobject.o 
 
@endnode 
 
@node incdir "#incdir" 
 
   Define path for includes 
   Can be used multiple times for different paths 
 
   #incdir "myincdir:" 
 
@endnode 
 
@node include "#include" 
 
   Include .i file(s) with constants and or offsets 
 
   #include "exec.i" 
 
@endnode 
 
@node xdef "#xdef" 
 
   Export functions and stuff 
 
   #xdef myfunction 
 
@endnode 
 
@node xref "#xref" 
 
   Import functions and offsets etc 
 
   #xref _puts 
 
@endnode 
 
@node equ "#equ" 
 
   Define constant 
 
   #equ Myconstant 10 
 
@endnode 
 
@node fdef "#fdef" 
 
   Define public libraryfunction 
 
   #fdef mylibraryfunction [info 
 
@endnode 
 
@node endfdef "#endfdef" 
 
   Mark end of public libraryfunctions 
 
   #endfdef 
 
@endnode 
 
@node makei "#makei" 
 
   Switch to tell compiler to generate .i file 
   with public functions offsets in. 
 
   #makei name 
 
@endnode 
 
@node makefd "#makefd" 
 
   Switch to tell compiler to generate .fd file 
   with public functions offsets in. 
 
   #makefd name 
 
@endnode 
 
@node makelvo "#makelvo" 
 
   Switch to tell compiler to generate .lvo file 
   with public functions offsets in. 
 
   #makelvo name 
 
@endnode 
 
@node LE "#libraryEnv" 
 
   Set the way libraries handles global environment. 
 
   #libraryEnv OFF 
 
      * NO environment is fetched. 
      IF library will ONLY be called by LITTEL code, 
      then its okey to use the startupglobals directly 
      from the librarycode !! 
 
   #libraryEnv SHARED 
 
      * Makes following PROCedures use the librarys own (shared by all tasks) globals. 
        Be sure to preserve A4 !! -> See #libraryRP 
 
   #libraryEnv can be inserted with its argument 
   anywhere outside PROC/ENDPROC, any nr of times, to set 
   specific PROCedures behaviour. 
 
@endnode 
 
@node RP "#RegPreserve" 
 
   Set the way PROCedures preserve registers 
 
   #RegPreserve reglist (regular reglist argument used in asm, ex : d2-d3/a4/a6 
 
   #RegPreserve OFF 
 
      NO registers are preserved. 
 
   When in LIBARRY mode : 
 
   1. Remember That LITTEL uses d4/d5/a6 for scratch, 
      you will probably always need to preserve atleast theese. 
 
   2. Also, if any LOOP/FOR/SELECT is used, then 
      d6 must be preserved. 
 
   3. Additionally, if exceptions is used, preserve d7 too. 
 
   IF the library is NOT to be called by any other code 
   then LITTEL, you dont have to worry about points 1-3. 
   (no regs needs to be preserved) 
 
   Default is OFF for EXE and OBJECT, d2-d7/a2-a4/a6 in LIBRARY mode. 
 
   #RegPreserve can be inserted with its argument 
   anywhere outside PROC/ENDPROC, any nr of times, to set 
   specific PROCedures behaviour. 
@endnode 
 
************************************************************ 
 
@node miscsupps "Misc Support Keywords" 
 
   @{"IF/ELSE/ENDIF                      " link IfElseEndif} 
   @{"SELECT/CASE/CONT/DEFAULT/ENDSELECT " link SCCDE} 
   @{"WHILE/ENDWHILE                     " link While} 
   @{"REPEAT/ENDREPEAT                   " link Repeat} 
   @{"LOOP/ENDLOOP                       " link Loop} 
   @{"FOR/ENDFOR                         " link For} 
@endnode 
 
@node IfElseEndif "IF/ELSE/ENDIF" 
 
   IF a ?? b 
 
   (ELSE) 
 
   ENDIF 
 
   ?? = </>/=/<>/>=/<= 
 
@endnode 
 
@node SCCDE "SELECT/CASE/CONT/DEFAULT/ENDSELECT" 
 
   SELECT xxx 
   CASE 14 
      blabla1 
   CASE -10 
      blabla2 
   DEFAULT 
      blabla4 
   ENDSELCT 
 
   xxx gets loaded into a register, so 
   it cant be changed between SELECT/ENDSELECT. 
 
 
   This one works like ELSEIF : 
 
   SELECT IF 
   CASE xxx > 14 
      blabla1 
   CASE yyy = _myglobal 
      blabla2 
   CONT zzz < 100 
      blabla3 
   DEFAULT 
      blabla4 
   ENDSELECT 
 
   The CONT(inue) makes the checking 
   continue if previous CASE/CONT was true. 
 
@endnode 
 
@node While "WHILE/ENDWHILE" 
 
   WHILE xxx ?? yyy 
 
   ENDWHILE 
 
 
   ?? = </>/=/<>/>=/<= 
 
@endnode 
 
@node Repeat "REPEAT/ENDREPEAT" 
 
   REPEAT 
 
   ENDREPEAT xxx ?? yyy 
 
 
   ?? = </>/=/<>/>=/<= 
 
@endnode 
 
@node Loop "LOOP/ENDLOOP" 
 
   LOOP 
 
   ENDLOOP 
 
 
   LOOP xxx 
 
   ENDLOOP 
 
 
   xxx = nr of times (static) 
   xxx gets loaded into a register, so it cant be changed
   while between LOOP/ENDLOOP. Its okey to _use_ it.
 
@endnode 
 
@node For "FOR/ENDFOR" 
 
   FOR x y z s 
 
   ENDFOR 
 
   (FOR x := y TO z STEP s) 
 
   z gest loaded into a register, so it cant be altered 
   while between FOR/ENDFOR. 
 
@endnode 
 
************************************************************* 
 
@node misckeys " Misc Keywords" 
 
   @{"GETA4     " link Geta4} 
@endnode 
 
************************************************************* 
 
@node geta4 "GETA4" 
 
   Get global environment. 
 
   GETA4 
@endnode 
@node stgl "Startup Globals" 
 
   _SysBase       ; exec 
   _DOSBase       ; dos 
   _IntuitionBase ; intuition 
   _GxfBase       ; graphics 
   _UtilityBase   ; utility 
   _arg           ; cli arg 
   _stdin         ; standard input 
   _stdout        ; standard output 
   _exception     ; current exception 
   _exceptioninfo ; current exception info 
   _LITTEL        ; $C7974747 if initialized by LITTEL startup 
   _G1            ; general purpose 1 
   _G2            ;                 2 
   _G3            ;                 3 
   _G4            ;                 4 
 
   NOTE : Libraries (can) have access to theese also! 
 
@endnode 
 
@node win "news sinse v17b" 
 
   o Fixed bug in Div and made it 020+ at the same time. 
 
   o Added DivF to handle floats, also 020+ 
 
   o Made Mul 020+ 
 
   o Changed the way #libraryenv keyword works. 
 
   o Added #RegPreserve keyword. (great speedups in libraries can be achived here) 
 
   o Removed startup global _ExecBase, Use _SysBase.

   o Added New Instruction -> MkLblk : Make Local Block 

   o Fixed a nasty bug in LIBRARY code that could cause crashes.

   o Reworked LIBRARY mode :
       PROC init, open, close, expunge is now required.
       This opens up new posybillities.
       Only Exec is opened automatically
       and is set as _SysBase.
       All other startupglobals are available,
       but not set. set them in init/open if neccessary.
 
   o New linkerlib : library2.o
     It opens all (exec/intui/util/gfx/dos) libraries
     automatically (and closes)

   o Fixed Abs, again. It really works now.

   o Fixed some problems with exceptions.
     They can have any value now (except NIL),
     and interfacing to other languages is now
     possible; the function returns the exception
     in D7. IF its <> NIL, an exception has occoured.

   o Optimisations, as usual..

***** since 0.16b : *****

 LIBRARY mode fully implemented. (except for OWN Globals)

 More Documentation.

 Bugs Fixed.

 Sourcecode for compiler in E included!

 MacroFunctions!

 Alot small stuff.

***** since 0.15b :   *****

 Alot internal sniffsnuff!

 Bugs fixed.

 New Instructions and keywords. And some removed.

 Removed enforcer hits.

 LITTEL can now create Shared Libraries !!

 Alot has changed ..again! but for the better i hope!

***** since 0.13b :  *****

 AmigaGuide Documentation!

 Added new 'adressingmodes'

 Added ABS, NEG, MAX, MIN, LIMIT

 Added support for external PROCs/subroutines
 with no own stackcleanup!

 Added returnvalues after ENDPROC.

 Added RETURN instruction..

 SELECT now handles any type

 Complete rewrite of the COPY instruction (witch other instructions uses)
 much smarter and efficient.

 DEFAULT in SELECT block no longer must be there.

 Added CONT, an alternativ to CASE.

 Added #nostartup keyword.

 Added GETA4.

 Object .o creation is now possible!

 Optimisations and more ...

 
@endnode 
 
 
@node future "What the future might bring"
   
   o xxx[].+  xxx[].-  (I really want to add this :))

   o More control in LIBRARY mode. (mostly done now)

   o support for devices. (mail me if you want it)

   MORE FUTURE

   o PPC / VP

@endnode


@node buglim "Bugs / Limitations"

   


   * OBSOLETE *

   If exceptions is used in libraries,
   it will only work if the caller is LITTEL code.
   This has to to with the fact that exceptionsnooping
   is done by looking in D7, other languages can have
   any value in this. A solution to this could be
   to just put $1 in D7 before calling.
   Maybe #fdef MyFunc (value, exctrig=1)(d0/d7)
   would be a good idea.
   Now, if MyFunc returns -1 in D7, an exception
   has occoured. be aware of it.
   AT the moment, it isnt possible to get the
   real exceptionvalue from other languages.
   This goes against the rules of returnvalues
   from Amiga Shared Libraries! Use it or not.
   Best is probably to not let exceptions leek
   out from libraries. (take care of them internally)

   Again, LITTEL callers need not to bother about this.

@endnode

@node aut "Author"

  leif_salomonsson@swipnet.se

@endnode

