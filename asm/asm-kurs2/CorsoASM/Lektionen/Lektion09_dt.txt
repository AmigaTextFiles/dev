Nun fahren wir mit der Praxis fort, ich rate euch vorher  aber,  68000.TXT

                                  '''
                                 (o o)
+---------------------------oOOO--(_)-------------------------------------+
|									  |
|		  ASSEMBLERKURS - LEKTION 9			  |
|									  |
+--------------------------------------oOOO-------------------------------+
                                |__|__|
                                 || ||
                                ooO Ooo

Autor: Luca Forlizzi, Alvise Spano', Fabio Ciucci

(Verzeichnis Sorgenti5) - dann schreibe "V Assembler2:sorgenti5"

     иОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОи
			     BLITTER
     иОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОииОXОи

In dieser Lektion werden wir anfangen, über den Blitter zu sprechen. Jeder, der
einen Amiga besitzt wird sicherlich von diesem speziellen Schaltkreis, der in seinem 
Computer platziert ist, gehört haben. Er stellt sich als einer der größten in
Punkto Stärke heraus, wenn man ihn mit anderen Computern vergleicht. Nicht alle
aber wissen, was der Blitter eigentlich ist und aus welchen Gründen er so nützlich 
ist. In der Tat die Mehrheit der Spezialeffekte, die sie in den Demos bewundern
können (wie sinusförmigen Scrolltext oder Vektorkugeln) benutzen den Blitter. 
Und dann wirst du fragen, warum diese Effekte selbst auf PCs nicht vorhanden sind.
Der Grund ist, dass in Wirklichkeit alles was der Blitter kann,
könnte auch mit dem Mikroprozessor gemacht werden. Und es ist tatsächlich so.
So machen es die PCs. Der Blitter kann jedoch die Aufgaben viel schneller lösen,
in manchen Fällen sogar 10 Mal schneller.  Es ist der Dank an den Blitter, 
dass spezielle Effekte, die mit einem PC nur realisiert werden können, wenn Sie eine 
386 oder schneller z.B. ein 486 haben, während ein Amiga 500 mit gewöhnlicher 
Ausstattung mit seinem Prozessor (68000 mit 7Mhz, wie Sie gut wissen) viel langsamer
als der 386 und 486 ist. 
So werden Sie verstehen, dass für diejenigen, die Demos oder Spiele auf dem Amiga 
programmieren wollen das Wissen um den Blitter essentiell ist. Wir beginnen
das Studium der Fähigkeit des Blitters ausgehend vom Einfachsten.
Auf den ersten Blick mögen sie langweilig erscheinen, aber dann werden wir allmählich 
die versteckte Macht entdecken, die die Schaffung von Spielen und spektakuläreren Demos
erlaubten. Es sollte jedoch beachtet werden, dass die Programme die für den 68020+ geschrieben
wurden, eher dazu tendieren, die CPU als den Blitter zu verwenden.
Letzteres erhöht nicht die Geschwindigkeit.

      .    .
  ,      ,   ,  ..            ______________
    .     ..     и ..        /      ,      г\           ____
      .    и:: ..   и:. .:,_/  »»»»»  -----' \         `----'
                и::: ..: ::`________  ________\ ____________________
    .и  :и  и :::. . .  и:  )(  г(X ) ) О)» )  \                  _/
           ,   :::и.  ..:. ,  »»»»»» (»»»»»»   /_____________ ___ T
       и:    .       . и '»\_   _    »\  _   _/   `-----||( АА:::!|
  .       :и      .        /    /   (,_) \    \ xCz     ll  !|:::||
     .,             _______\   / ________ \   /_______   »»T |:::||
                  /ппппппппп\   /_T_T_T_T\   /ппппппппп\   | !ддд!|
                 /ппппппппппп\__» » » » »»__/ппппппппппп\  l______!
                /пппппппппппппп`----------'пппппппппппппп\  `----'
               иппппппппппппппппппппппппппппппппппппппппппи


*******************************************************************************
*			FUNKTIONEN DES BLITTER				      *
*******************************************************************************

Das Wort "Blitter" ist eine Abkürzung für "BLock Image TransferER"
oder "Bildblockkopierer". Der Blitter ist daher ein Werkzeug, mit dem wir 
"Teile" von Bildern bewegen können. In Wirklichkeit wie Sie später herausfinden
werden, ist dies nur eine der Möglichkeiten. Der Blitter kann noch komplexere 
Operationen ausführen.
Wie Sie wissen, besteht ein Bild im Amiga einfach aus einem Speicherbereich, der
die von ihnen definierten Daten enthält. Die Farbe jedes einzelnen Pixels.
Wenn Sie sich nicht gut erinnern, wie das Bilden der Bilder funktioniert, dann 
ist es gut, wenn Sie noch einmal die Lektionen 4 und 5 wiederholen
und dann weiter fortfahren. 
Wenn der Blitter eine Operation an einem Bild "Stück" ausführt, arbeitet er
tatsächlich auf dem Speicherbereich, der das "Stück" vom Bild enthält.
Tatsächlich arbeitet der Blitter einfach weitere Speicherzonen ab, unabhängig davon, 
ob sie ein Bild einer Grafik, ein Sound oder den  Programmcode enthalten.
Dies bedeutet, dass der Blitter auch in solchen Aufgaben verwendet werden kann
die nicht die Grafik betreffen.
Es ist jedoch wichtig zu wissen, dass der Blitter, wie der Copper, die
Audio-Schaltkreise und der ganze Rest der Customs Chips des Amigas, nicht
in der Lage ist, auf allen verfügbaren Speicher zuzugreifen, sondern nur auf einem
Teil davon den sogenannten "Chip RAM".

Um auf den Speicher zuzugreifen, verwendet der Blitter die erwähnten DMA-Kanäle
die in Lektion 8 ganz allgemein erklärt wurden, auf die ich im Zweifelsfall Bezug nehme.
Der Blitter verfügt über 4 DMA-Kanäle, von denen 3 (benannt A, B und C) 
verwendet werden , um Daten aus dem RAM auszulesen "Quelle" (und dafür werden sie Kanäle genannt), 
während der vierte (Kanal D) zum Schreiben in den Speicher dient
(und deshalb wird er "Ziel" -Kanal genannt). Wie bei allen DMA-Kanälen
des Blitters übertragen sie jeweils ein Datenwort.

Das allgemeine Schema einer Blitter-Operation ("BLITTATA" genannt) ist vereinfacht:
Der Blitter liest über die Kanäle A, B und C Daten aus dem Speicher,
führt Operationen an ihnen durch und schreibt das Ergebnis über den D - Kanal in den Speicher.
Für eine erfolgreiche Blitter-Operation sind folgende Information sind notwendig:

1) welche Kanäle für dies Operation verwendet werden sollen
2) welche Operation an den gelesenen Daten durchzuführen sind
3) für jeden verwendeten Kanal die Adresse, an der das Lesen und Schreiben beginnt
4) wie viel Daten zu lesen oder zu schreiben sind

Beachten Sie, dass die Menge an Daten, die während einer Operation gelesen (oder geschrieben) werden, 
für alle vier Kanäle gleich ist: Wenn ich in einer Operation die Kanäle A, B und D verwende,
sind die Anzahl der Wörter, die über Kanal A gelesen werden, gleich der Anzahl
von Wörtern, die durch Kanal B gelesen werden und gleich der Anzahl von Wörtern, die
über Kanal D geschrieben werden.

Diese Informationen werden durch einige Hardware-Register spezifiziert. Die Register, die 
den Blitter steuern, sind wie alle Hardware-Register 16-Bit. Es gibt jedoch viele Register 
mit aufeinanderfolgenden Adressen. Diese Tatsache macht es möglich, mit "move.l" paarweise 
darauf zuzugreifen statt mit "move.w", ähnlich dem, wie wir es für andere Paare gesehen haben,
z.B. den Registern BPLxPT ($dff0e0 ...) und COPxLC ($dff080 ...).

Bevor Sie mit dem Schreiben in die Register beginnen, müssen Sie sicher sein, dass der Blitter 
im stationären Zustand ist, d.h. das er aktuell noch keine Operation macht.
Es ist wichtig zu warten, bis die letzte "Blittata" fertig ist, bevor Sie eine andere machen,
sonst könnte es Explosionen und Zusammenbrüche innerhalb eines Radius von 100 Meter verursachen,
eine echte Katastrophe, vergleichbar mit einem Luftangriff.

Um zu wissen, ob der Blitter stationär ist oder das "Blitting" noch läuft, wird 
der Status eines Bits (Bit 6) des DMACONR-Registers ($dff002) einfach überprüft.
Wenn dieses Bit 1 ist, dann arbeitet der Blitter, während es, wenn es 0 ist, uns
sagt, dass der Blitter fertig ist.

In der Praxis genügt dann eine einfache Abfrage:

waitBlit:
	btst	#6,$dff002	; dmaconr - ist der Blitter fertig?
	bne.s	waitBlit	; geh nicht weiter, bis du fertig bist


Leider ist ein sehr nerviger Hardware Bug in der
früheren Versionen des Agnus - Chips (der Chip, der den Blitter enthält) enthalten,
der die Dinge verkompliziet.
So wird beim ersten Lesen des fraglichen Bits ein falsches Ergebnis geliefert.
Deswegen muss eine Leermessung durchgeführt werden um den Status des Bits genau zu kennen.

Nachdem wir sichergestellt haben, dass der Blitter stationär ist, können wir
die für die Blittata notwendigen Informationen, wie in den Aufzeichnungen
oben aufgelistet, schreiben.

Lassen Sie uns nun im Detail sehen, wie es weitergeht.

1) Für jede Blittata können wir unabhängig voneinander nur die DMA-Kanäle aktivieren oder 
  deaktivieren die uns interessieren. Durch die Freigabebits, die, wenn sie auf 1 gesetzt sind, 
  den Kanal aktivieren, bzw. wenn sie zurückgesetzt sind, deaktiviert sind. 
  Die Aktivierungsbits finden wir im Steuerregister BLTCON0 ($dff040):

Kanal	Name Aktivierungsbit		Bitposition in BLTCON0

  A			SRCA						8
  B			SRCB						9
  C			SRCC						10
  D			DEST						11

2) Um festzulegen, welche Operation ausgeführt werden soll, werden die Bits 0 bis 7 des
  BLTCON0-Steuerregister beschrieben, die sogenannten MINTERMS. Der Wert, den sie annehmen
  bestimmt die vom Blitter durchgeführte Operation. Die Wirkungsweise der
  MINTERMS ist ziemlich kompliziert, und wir werden sie später ausführlich erklären.
  
3) Jetzt sehen wir, wie man die Startadressen der Kanäle festlegt.  
  Jeder Kanal ist mit einem Zeiger zum RAM-Speicher, welcher die Startadresse der 
  Operation enthält, verbunden. Während der Operation
  ändert sich der im Zeiger enthaltene Wert automatisch und zeigt immer
  auf die Adresse des Wortes, das der Blitter liest oder schreibt. 
  Ein Zeiger wird erstellt (wie für die DMA-Kanäle von Sprites und Ebenen)
  aus einem Paar von 16-Bit-Registern, von denen eines die niederwertigen signifikanten 
  16 Bits enthält und eins, das den Rest enthält (hoch).
  Diese Tabelle fasst die Namen und Adressen der Zeiger zusammen:
    
hoher Registerkanal				niedrig Registerkanal

		Name	   Adresse		Name	   Adresse	

  A		BLTAPTH	   $DFF050		BLTAPTL	   $DFF052
  B		BLTBPTH	   $DFF04C		BLTBPTL	   $DFF04E
  C		BLTCPTH	   $DFF048		BLTCPTL	   $DFF04A
  D		BLTDPTH	   $DFF054		BLTDPTL	   $DFF056  

Diese Registerpaare können eindeutig wie einzelne 32-Bit-Register behandelt werden
- wie für CopperList und Plane-Zeiger - und daher mit einer einzigen Anweisung "move.l" 
an die Adresse von BLTxPTH geschrieben werden. Daher werden wir sie von nun an als 
individuelle 32-Bit-Register betrachten, mit den  BLTxPT-Namen und Bezug auf die
$dff050-Adressen. Mit Ausnahme von $dff04c, $dff048 und $dff054 auf 
die wir angemessen zu berichten kommen werden. 
Die Zeigerregister sollten mit einer Adresse in Bytes beschrieben werden, aber
da der Blitter nur mit WORDS funktioniert, werden die am niedrigstwertigen signifikanten Bits von 
unserer Adresse ignoriert. 
Denken Sie daran, dass die Adressen immer gerade sein müssen und das wird mit WORDS aerreicht.
Deshalb muss man sich erinnern, dass nur die geraden Adressen der CHIP-Speicher, 
sowohl für die Quellen als auch für das Ziel geschrieben werden.

HINWEIS: Weisen Sie unbenutzten Bits immer eine Null zu, insbesondere solchen, die nicht vorhanden sind
und keine Funktion auch in ECS haben, da es in zukünftigen Versionen sein könnte, das sie
für wer weiß welche Zwecke verwendet werden. Die Ergebnisse wären unvorhersehbar.

4) Die letzte auszuführende Operation besteht darin, die Datenmenge anzugeben, die
gelesen oder geschrieben werden soll. Dies geschieht über das Register
BLTSIZE ($dff058). Dieses Register erlaubt dem Blitter, die Daten die gelesen oder
geschrieben werden nicht als einfache Wortfolge zu berücksichtigen, sondern als eine Art
zweidimensionales Rechteck, das aus Wörtern besteht. Zum Beispiel betrachtet der Blitter
eine Folge von 8 Wörtern, wie ein Rechteck, 8 Wörter breit und 1 Linie hoch:

                          Breite=8 WORD
                     _______________|_______________
                    /                               \

                   ein word
                     _|_
                    /   \ 
                 /  +---+---+---+---+---+---+---+---+
Höhe = 1 Linie -    | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
                 \  +---+---+---+---+---+---+---+---+

			fig. 1	Rechteck der Words 8*1


Nehmen wir ein anderes Beispiel: Eine Folge von 50 Wörtern kann berücksichtigt werden
als ein Rechteck von 10 Wörtern X 5 Zeilen:

                           Breite=10 WORD
                     _______________|_______________
                    /                               \

                   ein word
                     _|_
                    /   \ 
                  / +---+---+---+---+---+---+---+---+---+---+
                 |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
                 |  +---+---+---+---+---+---+---+---+---+---+
                 |  |   |   |   |   |   |   |   |   |   |   |
                 |  +---+---+---+---+---+---+---+---+---+---+
Höhe=5 Linie -	 |  |   |   |   |   |   |   |   |   |   |   |
                 |  +---+---+---+---+---+---+---+---+---+---+
                 |  |   |   |   |   |   |   |   |   |   |   |
                 |  +---+---+---+---+---+---+---+---+---+---+
                 |  |   |   |   |   |   |   |   |   |   |   |
                 \  +---+---+---+---+---+---+---+---+---+---+

			fig. 2	Rechtecks der Words 10*5

Diese Tatsache, die auf den ersten Blick wie eine unnötige Komplikation erscheinen mag, 
ist eine der Eigenschaften, die den Blitter so großartig machen.
In einem Moment werden wir sehen warum. Aber lass uns zuerst sehen, wie BLTSIZE funktioniert.
Um die Menge der Daten anzugeben, die in der Blittata involviert sind, schreiben wir in 
BLTSIZE die Dimensionen des Rechtecks ​​der Wörter, die die Daten bilden.
In den 6 unteren Bits wird die horizontale Dimension ausgedrückt, das ist die ANZAHL VON
WORD, die jede horizontale Linie bildet. In den oberen 10 Bits muss die Anzahl der horizontalen
Linien ausgedrückt werden, aus denen das Rechteck besteht:
In den 6 niedrigen Bits geht es um die Breite X des Rechtecks.
In den oberen 10 Bits geht es um die Höhe Y des oben erwähnten Rechtecks.
Es sollte beachtet werden, dass, wenn der Wert der 10-Bit-High (Höhe) 0 ist, der Blitter
1024 Zeilen, und wenn der Wert der 6 niedrigen Bits (Breite in Wort) 0 ist,
der Blitter 64 Words bearbeitet und wir daher die Größte 'Blittata" erhalten.

Schreiben "move.w #$0000,$dff058".
Wird es 64 Worte X 1024 Zeilen und damit (= 64 * 2 * 1024 = 128 Kb) sein.
Das BLTSIZE-Register hat noch eine weitere wichtige Funktion: WRITE it
DER BLITTER WIRD AKTIVIERT und startet den angegebenen Vorgang.

Aus diesem Grund MÜSSEN SIE IMMER NACH DER HAUPTSEITE AUF DER BLTSIZE REGISTRIEREN
SCHRIFTLICH IN ALLEN ANDEREN REGISTERN DES BLITTERS, sonst die
Blittata wird gestartet, bevor Sie alle korrekt eingestellt haben
registriert, Ergebnisse produziert, die von den gewünschten abweichen.

	                    ._________________
	                    |    _________    |
	                    |   (_________)   |
	                    |_________________|
	                     |:и            и|
	                    _|______   ______|_
	                     |______. .______|
	                   _/       |^|       \_
	                 __\\_______|_|_______//__
	                /__/    __(_____)__    \__\
	               //\/    /           \    \/\\
	               \_/    /_____________\    \_/
	                /    /»    _____    »\    \
	                \        _  /    _        /  ___________
	    .____________\_______(       )_______/__/           \
	    | ___/                \_____/          / _     _   _ \
	    | | \_________________________________/  \|    |   |  \
	    | |      g«m|         _________      /    \    |   |   \
	  __| |__       |       »»   /|\   »»   /______\___|___|___/
	 /       \ _____|___________  |  ______//______\\     )
	(__|_| |_//                 \_|_/      \        /____/
	     |_| /___________________\ /_____ __\______/____\


An dieser Stelle ist es gut, das Gelernte in die Praxis umzusetzen. Wir werden
einige Beispiele betrachten. In diesen Beispielen verwenden wir auch andere
Register, über die wir noch nicht gesprochen haben, wie BLTDMOD und BLTCON1.
Für den Moment ignoriere sie, wir werden sie später erklären.

In Lektion 9a1.s sehen Sie, wie Sie mit dem Blitter einen Speicherbereich löschen.
Um einen Löschvorgang durchzuführen, müssen Sie nur den Kanal D aktivieren. Weil wir nur 
Wörter schreiben müssen um den Speicher zurücksetzen.  Für das Deaktivieren des Quell- und 
Zielkanals wird $00  geschrieben. Um eine Löschoperation zu definieren, ist es notwendig 
den Wert $00 in den MINTERMS zu schreiben, d.h. in den Bits 0-7 (das niederwertige Byte) 
des Registers BLTCON0.

In Lektion 9a2.s verwenden wir den Blitter, um Daten aus einer Zone in eine andere Zone zu kopieren.
Für diesen Vorgang werden wir die Kanäle A und D verwenden. 
Die Daten werden über Kanal A aus dem Speicher gelesen und über Kanal D in den Speicher geschrieben.
Um einen Kopiervorgang von Kanal A zum Kanal D zu definieren ist es notwendig, den Wert $F0 in 
die MINTERMS zu schreiben.

		__________
		\ AMIGA! /       lllll
		 \ !!!! /     __/     \__
		  \____/      \/ (o!o) \/
		    ||        / \_____/ \
		    ||       /___________\\\\\
		    ||           _| |_     \  \
		    ||__________/     \_____\_ \
		    ()(________/       \________)
		    ||        /_________\
		    ||       (_____░_____)
		    ||        \    Y    /
		    ||       __\___|___/__
		  __||____ __\_____!_____/_____

*******************************************************************************
*		ERSTE ANWENDUNGEN DES BLITTER				      *
*******************************************************************************

Wir werden nun beginnen, den Blitter in grafischen Anwendungen zu verwenden. Wie wir wissen
besteht ein Bild aus Datenworten im Speicher. Mit dem Blitter können wir Operationen
an den Daten im Speicher ausführen. Wir können eine Veränderung des Bildes selbst verursachen.

Lassen Sie uns einen kurzen Überblick über die Darstellung der Bilder geben. Wir
beschränken uns auf den Fall einer einzelnen Bitebene.

Eine Bitebene ist eine Menge von Wörtern, von denen jeder den Zustand eines Pixels darstellt: 
Ein Wort steht für 16 horizontal angeordnete Pixel. Das erste Wort der Bitebene repräsentiert 
die 16 Pixel links von der ersten Zeile des Bildes.
Die folgenden Wörter repräsentieren alle Pixel in der ersten Reihe der Reihe nach.
Wenn die Pixel der ersten Zeile fertig sind, starten wir auf die gleiche Weise mit
der zweiten Zeile.
Wenn beispielsweise 320 Pixel auf einer Zeile stehen, sind 320/16 = 20 Wörter erforderlich
um alles darzustellen. Deshalb stellen die ersten 20 Wörter der Bitebene 
die erste Zeile des Bildes dar, die Wörter von 21. bis 39. stellen die zweite Zeile dar usw.

		 ____ ____ ____ ____ _ _ _ _ _ _ ____
		|    |    |    |    |			|    |
		| 0  | 1  |  2 |  3 |			| 19 |
		|____|____|____|____|			|____|
		|    |    |    |    |			|    |
		| 20 | 21 | 22 | 23 |			| 39 |
		|____|____|____|____|			|____|
		|    |    |    |    |			|    |
		| 40 | 41 | 42 | 43 |			| 59 |
		|____|____|____|____|			|____|
		|									 |
		|									 |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |
		|    |    |    |    |			|    |
		|____|____|____|____|_ _ _ _ _ _|____|

		Fig. 3  Darstellung des Speichers eines Bildes:
				Jedes Quadrat ist ein Word 


Wir haben gesehen, dass wir mit dem Blitter Daten von einem Punkt zum Anderen kopieren können.
Zur Erinnerung, wenn wir Daten innerhalb einer Bitebene kopieren um das Bild auf dem Bildschirm 
zu bilden, arbeitet der Blitter wie gesagt, mit Daten in der WORD (16 Bit)-Dimension.
Es erlaubt das Bild in Gruppen von WORD zu ändern, das heißt in Gruppen von 16 Pixeln.
Zum Beispiel, wenn wir das 21-te Wort der Bitebene auf dem Blitter eingeben, werden wir 
die 16 Pixel links von der zweiten Zeile im Bild ändern.
Nehmen wir an, wir haben ein einzelne Zeile und eine bestimmte Anzahl L von Pixeln als ein 
einzelnes Bild. Gerade weil die Bitebene in Worten die 16 Pixel enthalten geteilt ist,
ist es zweckmäßig, dass die Breite in Pixel unseres Bildes, d.h. L, ein Vielfaches von 16 ist, 
so dass das Bild genau L / 16 Word enthält. Dies kann erreicht werden durch Hinzufügen von
0-Pixel am Ende unseres Bildes, wie anhand des folgenden Beispiels veranschaulicht:

Dies ist ein 20 Pixel breites Bild und nur eine Zeile hoch.
	
	1100110101010001.1001
	\__________________/
 		 |
	     20 pixel

		 
Es ist unangenehm zu handhaben, weil 20 kein Vielfaches von 16 ist.
Wir fügen daher 0-Wert-Pixel am Ende hinzu, um die Breite von 32 Pixel zu 
erhalten, d.h. gleich einem Vielfachen von 16.

	1100110101010001.1001000000000000
	\______________________________/
		|
	    32 pixel

Unser Bild ist in den Daten unseres Programms gespeichert. Um es auf dem Bildschirm 
erscheinen zu lassen, müssen wir den Speicherbereich der Bitebene kopieren.
Das Bild nimmt eine entsprechende Position zu den Worten der Bitebene auf dem Bildschirm ein,
in die wir es kopieren werden. Angenommen, wir wollen das Bild auf dem Bildschirm zeichnen,
so dass das erste Pixel davon, das ist das Pixel am weitesten links, die X - und Y - Koordinaten annimmt.
(ich erinnere dich daran, dass das System von Koordinaten des Bildschirms ihren Koordinatenursprung, 
das ist der Koordinatenpunkt X = 0 und Y = 0, in der linken oberen Ecke hat. Die X-Koordinatoren 
wachsen nach rechts während das Y nach unten wächst).

Dieses Pixel ist in einem Wort der Bitebene enthalten. Für den Moment betrachten wir den Fall, 
in dem X auch ein Vielfaches von 16 ist. Dies stellt sicher, dass unser Pixel das erste ist 
(d.h. das Pixel auf der linken Seite) des Wortes, zu dem es gehört. Auf diese Weise, wenn einmal die Adresse
dieses Wortes berechnet ist, können wir (mit dem Blitter) das erste Wort des Bildes kopieren.
Die anderen Wörter, die unser Bild formen, werden natürlich in den Wörtern der nächsten Bitebenen kopiert.
All dies, da der Blitter Wortsequenzen kopieren kann, wird mit einem einzelnen Blitt gemacht, 
der die Quelladresse des ersten Wortes des Bildes und als Zieladresse die Adresse des
Wort der Bitebene, zu der das X- und Y-Koordinatenpixel gehört.

Sehen wir uns an, wie man diese Adresse berechnet.
Wir nummerieren die Wörter der Bitebenen beginnend bei 0, wie in der Figur gezeigt, und
wir berechnen die Nummer des Wortes, das uns interessiert: Von dieser Nummer werden wir wieder hinaufgehen
dann zu der tatsächlichen Adresse.
Beginnen wir damit, die Nummer des ersten Wortes der Y-Linie zu berechnen, indem wir uns erinnern,
dass jede Zeile aus 20 Wörtern besteht und dass die Zeilen von 0 beginnend nummeriert werden (sind).
Sie können aus der Abbildung sehen, dass das erste Wort der Zeile 0 (die erste Zeile) die Nummer 0 hat, 
das erste Wort der Zeile 1 (die zweite Zeile) hat die Nummer 20, das erste Wort der Zeile 2 hat die Nummer 40, 
das erste Wort von Zeile 3 hat die Nummer 60 und so weiter.
Im Allgemeinen hat daher das erste Wort der Zeile Y die Nummer Y * 20.
Die Nummern der anderen Wörter in der Reihe sind denen der ersten folgend:
Das zweite Wort der Zeile hat die Nummer Y * 20 + 1, das dritte Wort der Zeile hat die
Nummer Y * 20 + 2 und so weiter.
Wir können nun den "Abstand" eines bestimmten Wortes R vom ersten Wort der Linie nennen, 
also den Betrag, der zu der Nummer des ersten Wortes der Linie hinzugefügt werden muss
um das Wort R (Nummer) zu erhalten: 

In der Praxis:
Das zweite Wort der Zeile hat die Nummer Y * 20 + 1, sagen wir, dass es den "Abstand" 1 hat
vom ersten Wort der Zeile. In gleicher Weise hat das dritte Wort der Zeile, welches
die Nummer Y * 20 + 2, den Abstand 2 vom ersten Wort der Zeile und so weiter.
Wir können auch sagen, dass das erste Wort der Zeile den Abstand 0 von sich selbst hat.
Es ist sehr einfach, den Abstand zwischen dem Wort mit dem Pixel zu berechnen.
Mit der folgenden Abbildung können wir auf die X - Koordinate und das erste Wort der Zeile sehen:

			 ________ ________ ________ ________ _ _ _
			|        |        |        |        |		
Reihe Y		| Y*20+0 | Y*20+1 | Y*20+2 | Y*20+3 |
			|________|________|________|________|_ _ _

Entfernung 
vom 
Wordanfang  |   0	 |   1	  |   2    |   3    | -  -

Pixel
Inhalt:		|  0-15  |  16-31 |  32-47 |  48-63 | -  -

			fig. 4	Reihe der words

Die X-Koordinate unseres Pixels repräsentiert die Entfernung (in Pixeln) zwischen ihnen
und des ersten Pixels der Linie. Da jedes Wort 16 Pixel enthält, folgt:
Das erste Wort einer Zeile enthält die ersten 16 Pixel der Zeile, deren
X-Koordinate (= ein Abstand von der Kante) von 0 bis 15 hat.
Das zweite Wort enthält stattdessen die Pixel, deren X-Koordinate von 16 bis 31 variiert.
Das dritte Wort die Pixel mit X von 32 bis 47 und so weiter: alle 16 Pixel
Wir haben ein Wort.

Um also den Abstand zwischen den Wörtern zu berechnen, teilen Sie einfach die Entfernung in
Pixel (das ist der Wert von X) für 16 mit. Da wir ein X-Vielfaches von 16 gewählt haben.

Das Ergebnis wird eine ganze Zahl sein. Wenn beispielsweise X = 32 ist, ist die Wortentfernung 
32/16 = 2 gültig. Wie man in der Abbildung sehen kann, ist das Pixel 32 der Linie Y tatsächlich
das erste Pixel des zweiten Wortes der Zeile, dessen Nummer genau Y * 20 + 1 ist.

Mit derselben Berechnung sehen wir, dass das Pixel, das X = 64 hat, in dem Wort enthalten ist
welches 64/16 = 4 ist, das Wort, dessen Nummer Y * 20 + 3 ist. Diese Berechnung funktioniert auch
wenn X = 0: tatsächlich haben wir Abstand 0/16 = 0, das ist das Wort der Zahl Y * 20 + 0
genau das erste Wort der Zeile.

Insgesamt ist dann das Wort mit dem Pixel X, Y (das Wort mit der Nummer N)
durch die folgende Formel gegeben :

N = (Y * 20) + (X / 16)

Diese Formel gilt für die Bitebene, in der eine Zeile aus 20 Wörter besteht.
Im Allgemeinen lautet die Formel:

N = (Y * Anzahl der Wörter einer Zeile) + (X / 16)

Von der Wortnummer können wir zurück zur entsprechenden Adresse gehen:
Einfach die Adresse des ersten Wortes der Bitebene nehmen und die
Zahl des Wortes multipliziert mit 2 (Multiplikation ist notwendig, weil
die Adresse in Bytes und 1 Wort = 2 Bytes ausgedrückt wird) hinzufügen:

Wortadresse = (Bitplaneadresse) + N * 2.

Im Beispiel Lektion 9b1.s finden Sie die Anwendung von allem, was wir hier gesagt haben.
Im Beispiel Lektion 9b2.s sehen Sie eine Reihe verschiedener Blittings von
Bildschirmpositionen.

Beginnen wir nun mit Bildern, deren Höhe größer als eine Zeile ist.
Wir haben gesehen, als wir über das BLTSIZE-Register gesprochen haben, wie der Blitter
die Daten betrachtet. Der Blitter sieht die Daten als "Rechtecke" von Wörtern. 
Dieses Merkmal ist sehr nützlich, weil es es uns ermöglicht, leicht mit rechteckigen Bildern
zu arbeiten. Angenommen, Sie möchten eine Bitebene eines 32 Pixel breiten und 2 Zeilen hohen 
Bildes nach innen kopieren. Dieses kleine Bild belegt einen kleinen Teil der Bitebene, 
hervorgehoben in der Abbildung mit schrägen Linien.

		 ____ ____ ____ ____ _ _ _ _ _ _ ____
		|    |    |    |    |			|    |
		| 0  | 1  |  2 |  3 |	        | 19 |
		|____|____|____|____|			|____|
		|    |\\\\|\\\\|    |			|    |
		| 20 |\21\|\22\| 23 |			| 39 |
		|____|\\\\|\\\\|____|			|____|
		|    |\\\\|\\\\|    |			|    |
		| 40 |\41\|\42\| 43 |			| 59 |
		|____|\\\\|\\\\|____|			|____|
		|									 |
		|									 |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |
		|    |    |    |    |			|    |
		|____|____|____|____|_ _ _ _ _ _|____|

		Fig. 5  Eine Bitebene mit hervorgehobenem Bereich
				auf dem wir einen blit machen

Es ist ein kleines Rechteck, 2 Wörter breit (d.h. 32 Pixel) und 2 Zeilen hoch.
Sie werden sofort verstehen, dass, um die Kopie zu machen, es notwendig ist
die Größe des Rechtecks ​​in BLTSIZE anzugeben. Aber das ist nicht ausreichend. 

Um dies zu realisieren, lassen Sie uns für einen Moment in die Rolle des
Blitters schlüpfen. Lass uns versuchen, unsere Aufmerksamkeit darauf zu konzentrieren, 
die Kopie zu durchzuführen. Im Moment nur in der Schreibphase.

Wir kennen (weil es in BLTDPT geschrieben ist) die Adresse des Wortes oben links im Rechteck
(das Wort 21 in der Abbildung). Wir kennen auch (es ist in BLTSIZE geschrieben) die
Dimensionen des Rechtecks. Sehr gut. Wir lesen das erste Wort und kopieren es an die 
Adresse des Wortes 21. Jetzt müssen wir das zweite Wort der ersten Zeile kopieren.
Wir wissen, dass dieses Wort dem ersten Wort folgt und addieren 2 zu der Adresse des
ersten Wortes (das in BLTDPT geschrieben ist) Jetzt kennen wir die Adresse des 
zweiten zu schreibenden Wortes. Wir schreiben es und wir haben die erste Zeile beendet.
Sehr zufrieden bereiten wir uns vor, die zweite Zeile zu schreiben. Und hier erkennen wir, 
dass es ein kleines Problem gibt:
Das erste Wort der zweiten Zeile folgt nicht dem letzten Wort der ersten Zeile!
In der Tat, wie Sie aus der Abbildung sehen können, ist das letzte Wort der ersten Zeile 
das Wort 22 während der in der zweiten Zeile das Wort 41 steht.

Wie berechnen wir die Adresse des ersten Wortes der zweiten Zeile?
In der Abbildung wird eine 20 Worte breite Bit-Ebene gezeigt, aber es ist nur ein Beispiel.
Woher weiß der arme Blitter, wie viele Wörter die Bitebene hat? Tatsächlich
könnten wir uns in einer größeren Bitplane als dem sichtbaren Bildschirm befinden!
Wer sagt es dem Blitter, dass wir ihn zum Kopieren eines Rechtecks auf dem Bildschirm 
benutzen wollen? Und wenn wir stattdessen einfach Daten in die Copperliste kopiert haben?

Es ist offensichtlich, dass der Blitter allein nicht weiß wie er aus der misslichen
Lage kommt.

Aber es gibt kein Problem, wir helfen ihm. Was der Blitter zu wissen braucht,
ist einfach, wie man die Adresse des ersten Wortes einer Zeile berechnet, wenn man
die Adresse des letzten Wortes der vorherigen Zeile kennt.
Wenn du dir einen Moment die Abbildung ansiehst, siehst du das der Blitter einfach
die Wörter von 23 bis einschließlich 40 "überspringen" muss. Dies kann durch Hinzufügen 
an der Adresse des Wortes 22 (das ist die Adresse des letzten Wortes des ersten
Zeile, die der Blitter bereits kennt) die Anzahl der Bytes der Differenz verglichen
zu dem Wort 40 (welches genau das erste Wort der neuen Zeile ist) erfolgen. 
Diese Anzahl von Bytes,MODULO genannt, ist offensichtlich gleich der Anzahl der Wörter des
"Sprung" multipliziert mit 2 (da wie Sie wissen, ein Wort 2 Bytes belegt).

word		0            X            X+L             H
Reihe y		|------------|*************|--------------|
Reihe y+1	|------------|*************|--------------|
			\____________/\____________/\_____________/
	 			   |		    |			   |
	 			 word zum	word Bild		word zum
				 Springen	Größe L			Springen
				
			Fig. 6	Modulo
		
Im Allgemeinen, wenn wir ein Rechteck von L Wörtern innerhalb einer H-Word-breiten-Bitmap
kopieren müssen, wird das als MODULO, in Bytes ausgedrückt. 
Mit der folgenden Formel:

MODULO = (H-L) * 2

Die H-L-Berechnung würde uns die in Worten ausgedrückte Form geben. Multiplikation mit 2
dient dazu, es in Bytes auszudrücken. In unserem Beispiel enthält das MODULO (20-2) * 2.
Wenn Sie sich erinnern, hatten wir bereits das Konzept eines relativ neuen MODULO zu Bitebenen
getroffen. Das Blitter-Modulo funktioniert genauso.
Es ist möglich, jedem DMA-Kanal ein anderes Modulo zuzuweisen. Auf diese Weise können
Daten zwischen Bitebenen unterschiedlicher Breite kopiert und bewegt werden.
Der Wert des MODULOS wird in 4 spezifische Register geschrieben, eines für jeden DMA-Kanal:
BLTAMOD für Kanal A ($dff064), BLTBMOD für B ($dff062),
BLTCMOD für Kanal C ($dff060), BLTDMOD für D ($dff066). MODULO-Werte sind in Bytes,
und nicht als Wörter anzugeben. Da der Blitter nur mit Worten arbeiten kann, wird das 
niederwertigste Bit ignoriert,das bedeutet, dass der Wert der Form gerade sein muss.

Der Wert, positiv oder negativ, wird den Registern (BLTxPT - sie zeigen auf Adressen)
jedes Mal, wenn der Blitter das Kopieren beendet hat automatisch hinzugefügt. Dies 
geschieht in der Art wie die Adresse des ersten Wortes der nächsten Zeile berechnet wird.
Negative Werte als Ergebnis der Berechnung können in vielen Fällen nützlich sein, z.B. zum
Wiederholen einer Zeile, indem Sie das MODULO als Breite der Bitebene negativ festlegen.
Wir haben bereits in Lektion 5 gesehen, wie man eine Linie wiederholt in dem 
die Register BPL1MOD / BPL2MOD bei -40, oder auf jeden Fall eine lineare Länge haben.

		          ._________
		          |  _ ____/
		       ___|______|___
		     _/              \_
		     \________________/
		          \_ Oo _/
		        /\_(»»»»)_/\
		       /    \  /    \
		     ./ /\   \/   /\ \.))
		     | |  \__  __/  | |
		     | |   |    |   | |
		     | \   |    |   / |
		   (( \ \__|____|__/ /
		       \/ _/    \_ \/
		        \||______||/
		       /|_|  |   |_|\
		      / ||   |    || \
		     ( (»    |     ») )
		     | |     |      | |
		     | |     |      | |
		    _|_|     |      |_|_
		    \  |     |______|  /
		     ) |           g| (
		 ___/  |           «|  \___
		/______|           m|______\


An dieser Stelle wissen wir, wie man ein Rechteck innerhalb einer Bitmap kopiert.
Lassen Sie uns mit einem Beispiel alle notwendigen Berechnungen zusammenfassen: 

Angenommen, wir möchten auf einem Abschnitt einer 320 x 200 großen Bitmap arbeiten, die
bei Zeile 13, Wort 6 (beide sind von Null nummeriert) 5 Wort breit beginnt.
Zuerst müssen wir die Adresse des ersten Wortes des Rechtecks ermitteln,
und schreiben es dann in das BLTxPT-Register des Kanals, das uns interessiert.
Die Berechnung erfolgt folgendermaßen: Wir nehmen die Adresse des ersten
Worts der Bitebene und fügen 13 * 20 * 2 Bytes hinzu, um die Adresse des
erstes Byte der Zeile 13 (tatsächlich belegt jede Zeile 20 Wörter = 40 Bytes) und schließlich
addiere wir 12 Bytes (= 6 Wörter), um zur rechten horizontalen Position zu kommen.
Die Breite beträgt 5 Wörter (10 Bytes). Am Ende jeder Zeile müssen wir 30 Bytes springen
um zum Anfang der nächsten Zeile zu kommen, also verwenden wir ein MODULO von 30.
Im Allgemeinen enstspricht die Breite (in Worten) plus dem Modulo-Wert (in Byte)
gleich der vollen Breite der Bitebene des Bildes in Bytes.

Die Berechnung der erforderlichen Werte der Blitter-Register
BLTxMOD und BLTxPTR (BLTxPTH und BLTxPTL) ist in der Abbildung dargestellt.


<Speicher_Addr> = Adresse (0,0)
	     \
	      \
	       \ Anzahl BYTE (SPALTE)
	        \ 0	    10	      20	30	 39
			 \|	     |	       |	 |	  |
			  +----------------------------------------+ - -
			 0|ииииииииииииииииииииииииииииииииииииииии|	|
			 1|ииииииииииииииииииииииииииииииииииииииии|
			 2|ииииииииииииииииииииииииииииииииииииииии|	|
			 3|ииииииииииииииииииииииииииииииииииииииии|
			 4|ииииииииииииииииииииииииииииииииииииииии|	|
			 5|ииииииииииииииииииииииииииииииииииииииии|
			 6|ииииииииииииииииииииииииииииииииииииииии|	|
			 7|ииииииииииииииииииииииииииииииииииииииии|
			 8|ииииииииииииииииииииииииииииииииииииииии|	|
			 9|ииииииииииииииииииииииииииииииииииииииии|
	 Zeilen	10|ииииииииииииииииииииииииииииииииииииииии|	|
	 nummer	11|ииииииииииииииииииииииииииииииииииииииии|
			12|ииииииииииииииииииииииииииииииииииииииии|	|- - Fenster
			13|ииииииииииии##########ииииииииииииииииии|	     Bitmap
			14|ииииииииииии##########ииииииииииииииииии|	|
			15|иSprung Anf ##########иии Sprung Ziel.ии|
			16|<---------->##########<---------------->|	|
			17| = 12 bytes ##########иии = 18 bytes иии|
			18|ииииииииииии##########ииииииииииииииииии|	|
			19|иииииииииииииииии\ииииииииииииииииииииии|
			20|ииииииииииииииииии\иииииииииииииииииииии|	|
			 -|иииииииииииииииииии\ииииииииииииииииииии|
			 -|ииииииииииииииииииии\иииииииииииииииииии|    |
			 -|иииииииииииииииииииии\ииииииииииииииииии|
			 -|ииииииииииииииииииииии\иииииииииииииииии|	|
			  +-----------------------\------------\---+ - -
									   \			\
									    \			 \
							zu manipulierendes Bild	  \
													   \
													ein Byte

	BLTxPTR = <Speicher-Addresse> + (40*13) + 12
			= <Speicher-Addresse> + 532

	BLTxMOD = 12 + 18
			= 30 bytes

		Fig. 7  Berechnung für BLTxPTR und BLTxMOD
		
An diesem Punkt ist es gut, anzuhalten und einige Beispiele zu betrachten.

In Lektion 9c1.s und Lektion9c2.s finden Sie einfache Beispiele für das Kopieren von rechteckigen 
Bereichen. Studiere sie sorgfältig und konzentriere dich auf die Berechnung der
Adressen und MODULO, die in den Blittings verwendet werden.

In Lektion 9c3.s gibt es ein Beispiel, in dem eine negative Form einer Blittata gemacht wird.

In Lektion 9d1.s und Lektion 9d2.s sehen Sie die ersten Beispiele für Animationen mit dem
Blitter.

Die Idee ist sehr einfach. 
Die Idee der Bewegung unserer Figur ist einfach, sie jedes Mal an einer anderen Position neu
zu zeichnen, so ähnlich wie wir es mit den Sprites getan haben.
Anders als da aber, bevor die Figur in die neue Position gezeichnet wird,
müssen wir sie aus der alten löschen, sonst werden wir einen "Trail"(Nachzieh-) Effekt bekommen.

In diesen 2 Beispielen verschieben wir die untere Figur in der Zeile von Zeit zu Zeit,
durch Hinzufügen von jeweils 40 Bytes zur BLTxPT-Adresse.

In Lektion 9d3.s wenden wir die gleiche Technik an, um die Figur horizontal zu bewegen.
Beachten Sie jedoch, dass das Ändern der Adresse dem Verschieben des Rechtecks
nach rechts (oder links) eines oder mehreren Wörtern entspricht. Ein Wort
entspricht 16 Pixeln, auf diese Weise können wir die horizontale Bewegung
nur in Schritten von 16 Pixel machen, was man, wie Sie im Beispiel sehen können
die Bewegung nicht sehr flüssig und zu schnell macht.

	              .       :
	                      и
	              д:.:.:.:д
	              l______ |
	              (░X░ )  »)
	              |C_»»__ T___
	 ________     l_____г l _ \
	(_____   \________T____/ ) \
	    (__   ______________/   \
	     (____/      /\░         \
	                / /\░         \
	               / /  \░         \
	      .и.     / /    \░_________\
	    .и   и. _/  \     »\ _..  г\  xCz
	  .и       (_   _)      \/и:    \____
	.и          `-`-'       /и:      \.  \__
	ииии.     .иииии       /и:        \:. \ \
	    :     :            \и:.        \::.\ \
	....:..  .:...........  \и::.       \___\ \
	                       __\___________\ `-\_)
	                      (_____________)

Bis jetzt haben wir uns darauf beschränkt, Figuren mit dem linken Pixel in eine Mehrfachposition 
von 16 zu zeichnen. Um eine reibungslose Bewegung zu haben, ist jedoch notwendig, die Figur
in einer beliebigen Position des Bildschirms zu zeichnen. Nehmen wir ein Beispiel und stellen uns vor,
wir hätten das Image eines Autos, das wir auf dem Bildschirm bewegen wollen.
Durch die korrekte Berechnung der Adresse des Rechtecks, das unser Auto "block" enthält, können wir
es überall auf dem Bildschirm abbilden. 
*/
Wenn unser Auto Bild, zum Beispiel ein 5-Türer,
Pixel von seiner extremen linken, können wir es zusammen mit dem Auto bewegen,
5 Pixel vom Anfang eines Bildschirmworts. 

Wenn wir es nach rechts bewegen wollen können wir "blittata" ab dem nächsten Wort beginnen.

Das Ergebnis wäre ein "Snap" von jeweils 16 Pixeln. Aber wenn wir das Auto um jeweils einen Pixel 
nach rechts oder links scrollen wollen, oder z.B. wir wollen es in eine horizontalen Position setzen, 
die kein Vielfaches von 16 ist, wie machst du es?

Wir müssen sicherstellen, dass die Pixel, aus denen das Bild besteht, NICHT beginnend 
mit dem ersten Bit des ersten Wortes, sondern beginnend mit einem beliebigen Bit innerhalb 
dieses Worte kopiert werden, wie in der folgenden Abbildung dargestellt.

		kopiere mit X multipliziere mit 16

erstes word
Quelle			1 0 0 1 1 0 1 0 1

				| | | | | | | | |
				| | | | | | | | |
				v v v v v v v v v
erstes word 	_ _ _ _ _ _ _ _ _ _
Ziel	       |_|_|_|_|_|_|_|_|_|_

bit				0 1 2 3 4 5 6 7 8 ..


		kopiere mit X willkürlich

erstes word
Quelle	 			  1 0 0 1 1 0 1 0 1

					  | | | | | | | | |
					  | | | | | | | | |
					  v v v v v v v v v
erstes word 	_ _ _ _ _ _ _ _ _ _
Ziel	       |_|_|_|_|_|_|_|_|_|_

bit				0 1 2 3 4 5 6 7 8 ..

		Fig. 8  Shift 

In der Praxis müssen wir die Bits, aus denen die Figur besteht, von links nach rechts verschieben.

Der Blitter hat einen Hardware-Shifter für die Kanäle A und B, der alle Wortbits die aus den Kanälen A und B 
gelesen werden nach rechts verschiebt.

Die Bits werden um die Anzahl der Positionen verschoben, die von 0 bis 15 variieren können.
Das Verschieben von 0 Positionen ist gleichbedeutend damit, überhaupt nichts zu verschieben: all die Blittings, die
wir bis jetzt gesehen (und getan) haben waren blittate mit Verschiebung von 0 Positionen.
Der Verschiebungswert für Kanal A wird mit den Bits von 15 bis 12 im Register BLTCON0 ($dff040) zugewiesen.
Der Verschiebungswert von Kanal B wird mit den Bits von 15 bis 12 im Register BLTCON1 ($dff042) zugewiesen. 
Wenn du dich erinnerst, haben wir diese Bits bisher immer auf den Wert 0 belassen, der eine Verschiebung von 
0 Positionen bedeutet.
Kanal C hingegen ist ein Proletarier. Er hat keinen Schalthebel.
(Für diejenigen, die es vergessen haben, bedeutet das Verschieben von Bits "Scrollen" 
 nach rechts oder nach links ....)
Der Schaltvorgang wird zur gleichen Zeit wie das normale kopieren ausgeführt
und beeinflusst nicht die Geschwindigkeit des Blitters: was auch immer der Wert der
Verschiebung ist, die Zeit für die Blittata ist immer gleich.

Dank der Verschiebung können wir eine Figur mit dem Pixel plus a links in einer beliebigen X-Position zeichnen.
In der Tat die Adresse des Ziels einer Figur zu einer Position können wir wie üblich zu mehrere X von 16 berechnen.
Aktivieren Sie den Shifter zur gleichen Zeit, können wir es weiter nach rechts verschieben und 
damit die gewünschte Position erreichen.

Angenommen, Sie möchten eine X-Position von 38 Pixeln.
Durch die Berechnung der Adresse können wir das Objekt um 32 Pixel verschieben
(32 ist ein Vielfaches von 16) rechts von der Grenze 0 und wir können dann das Objekt weitere 6 Bits 
(38-32 = 6) nach rechts bewegen, in dem wir eine Verschiebung von 6 einstellen. 

Im Allgemeinen, wenn X kein Vielfaches von 16 ist, wird die gesamte Division X / 16 ausgeführt.
Wir erhalten ein Integer-Ergebnis (mit dem wir die Ziel-Adresse berechnen) 
und einen Rest, der uns sagt, wie viel die Verschiebung sein sollte.
Berechnen Sie die Nachkommastellen des Ergebnisses. Zum Beispiel 7/3 = 2 mit dem Rest von 1.

Im Fall einer horizontalen Position X = 100 haben wir 100/16 = 6 mit dem Rest von
4 (tatsächlich 16 * 6 = 96 und 100-96 = 4). Daher ist der Abstand zwischen dem ersten Wort
der Zeile und dem Ziel gleich 6 Worten, d.h. 12 Bytes und der Verschiebungswert beträgt 4 Bits.

Bevor wir mit der Verschiebung beginnen, müssen wir jedoch verstehen, wie sie funktioniert.
Zu Beginn werden einige Bits natürlich direkt aus dem Wort zu dem sie gehörten heraus verschoben.
Von links muss für diese Bits etwas nach innen verschoben werden.
Ersetzen Sie die ausgehenden Bits. Wie genau? Im ersten Wort werden Nullen eingeschoben.
Für jedes nachfolgende Wort die Bits, die aus dem vorherigen Wort verschoben wurden.
Kurz gesagt, was von einer Seite (rechts) kommt geht in die andere Seite (links!) im folgenden Wort rein.

Nehmen wir ein kleines Beispiel und helfen uns mit einer Figur, um es besser zu verstehen.
Nehmen wir an, wir kopieren 3 Wörter (eine Zeile kann ein einzeiliges Rechteck bilden)
3 Wörter breit oder 3 Zeilen hoch und 1 Wort breit,es macht keinen Unterschied von dem Punkt beim
Blick auf die Schicht) mit einem Shift-Wert von 3.

Schauen wir uns an, was passiert:

Quelle
word 1					 word 2					word 3
10001100.01010101		00010010.01000110		10101010.10101010
			  ^^^					  ^^^
Ziel
word 1					word 2					word 3
000100011.0001010		10100010.01001000		11010101.01010101
^^^						^^^						^^^

diese 3 Bits sind		diese 3 Bits sind das	diese 3 Bits sind das
Nullen sind nach innen	verschoben aus dem		verschoben aus dem
verschoben worden		ersten Word				zweiten Word
im ersten Word						

Die Bits werden durch verschieben, verlagert. 

		Fig. 9  shift

Beachten Sie, dass die letzten 3 Bits des Quellworts 3 von keinem Teil kopiert werden!
Diese drei Bits gehen somit verloren (Anm. GS)

Betrachten wir zum Beispiel eine drei Wörter breite und zwei Wörter hohe Blittata, mit einer
4-Bit-Verschiebung.

Der Einfachheit halber gehen wir davon aus, dass es sich um eine normale Kopie von A nach D handelt.
Das erste Wort, das in D geschrieben wird, ist das erste Wort aus A, verschoben nach
rechts um vier Bits. Die ersten 4 Bits werden zurückgesetzt bzw. von links nach innen mit Nullen eingeschoben.

Das zweite Wort ist das zweite Wort aus A, nach rechts verschoben, aufgefüllt um die
vier weniger signifikanten Bits (rechts) des ersten Wortes. Die anderen Bits werden nach innen verschoben.

Als nächstes wird das erste Wort der zweiten Zeile aus A geschrieben. Es wird mit den vier niedrigstwertigen 
Bits des letzten Wortes aus der ersten Zeile um vier Bit nach innen verschoben

Dies wird fortgesetzt, bis das Verschieben beendet ist.

In Lektion 9e1.s sehen Sie ein Beispiel für die Verwendung der Verschiebung, die es ermöglicht
eine Figur, die sich um jeweils einen Pixel nach rechts bewegt. Das Ergebnis ist jedoch
nicht sehr gut aufgrund der Tatsache, dass die Bits herausgeschoben werden.
Herausgeschoben aus einem Wort werden in das nächste Wort, das eine eins ist, in die 
Linie darunter verschoben.

Die von rechts kommenden Bits fallen also von links in der nächsten Zeile! 
Die Situation wird durch die folgende Abbildung veranschaulicht,
Annahme einer 4-Bit-Verschiebung:

Quelle
word 1		10000011.11100000
  "  2		11001111.11111000
  "  3		11111111.11101100
  "  4		11111111.11111110
  "  5		11001111.11111000
word 6		10000011.11100000


Ziel
word 1		00001000.00111110
  "  2		00001100.11111111
  "  3		10001111.11111110
  "  4		11001111.11111111
  "  5		11101100.11111111
word 6		10001000.00111110
		    ^^^^

		
Diese 4 Bit-Spalten bestehen aus den Bits, die von links eingegeben werden:
Wie Sie sehen (außer der ersten Zeile) in jeder Zeile.
Die Bits, die aus der vorherigen Zeile kommen, gehen in die Zeile ein.

Abb. 10 Verschiebung eines Rechtecks

Glücklicherweise kann dieses Problem auf sehr einfache Weise gelöst werden.
Wenn Sie darüber nachdenken, was wir möchten, sollen die Bits, die rechts aus einem Wort herauskommen
NICHT links in die nächste Zeile kommen, sondern eher in einem WORT MEHR RECHTS sein! 

Wir müssen daher auch in die Wörter auf der rechten Seite in der Blitata "eingreifen"
Dies kann einfach durch Erhöhung der Breite der Figur durch Hinzufügen eines 
NULLWERT-Wortes "Spalte" auf der rechten Seite erfolgen. 
 
Auf diese Weise ist die zusätzliche Spalte unsichtbar und darüber hinaus die Bits,
die außerhalb der Wörter, die sie bilden, verschoben werden, sind alle null und daher
werden sie sich nicht die Mühe machen, zu den Worten der folgenden Zeile zurückzukehren.
Um deine Ideen zu klären, passiert Folgendes:

Quelle
			word 1			 word 2
Reihe 1		1000001111100000.0000000000000000
  "  2		1100111111111000.0000000000000000
  "  3		1111111111101100.0000000000000000
  "  4		1111111111111110.0000000000000000
  "  5		1100111111111000.0000000000000000
  "  6		1000001111100000.0000000000000000
							 ^^^^^^^^^^^^^^^^
				
			Dies ist die Spalte der hinzugefügten Wörter

Ziel
			word 1			 word 2
Reihe 1		0000100000111110.0000000000000000
  "  2		0000110011111111.1000000000000000
  "  3		0000111111111110.1100000000000000
  "  4		0000111111111111.1110000000000000
  "  5		0000110011111111.1000000000000000
  "  6		0000100000111110.0000000000000000
			^^^^		     ^^^^
							 |	
							 Diese 4 Bits stammen aus dem Wort 1 und 
							 sie gingen in Wort 2 ein.
			|
			Diese 4 Bits stammen aus dem Wort 2 der vorherigen Zeile.

(außer in Wort 1 der Zeile 1, dort werden im Wort 1 die 4 Bits
 automatisch auf Null gesetzt werden)


Abb. 11 Verschiebung eines Rechtecks

In der Beispiellektion 9e2.s wird diese Technik angewendet, die es Ihnen erlaubt
eine Bild nach rechts mit einer Anzahl von Pixeln zwischen 1 und 15 zu verschieben.
(Tatsächlich reichen die möglichen Verschiebungswerte von 0 bis einschließlich 15).	
Im Beispiel Lektion 9e3.s sehen wir endlich, wie sich unsere Figur nach
rechts um eine beliebige Anzahl von Pixeln bewegt.

Beispiele lesson9d3.s und lesson9e2.s

                     __---__
	                  _-       _--______
	              __--( /     \ )XXXXXXXXXXXXX_
	            --XXX(   O   O  )XXXXXXXXXXXXXXX-
	           /XXX(       U     )        XXXXXXX\
	         /XXXXX(              )--_  XXXXXXXXXXX\
	        /XXXXX/ (      O     )   XXXXXX   \XXXXX\
	        XXXXX/   /            XXXXXX   \__ \XXXXX----
	        XXXXXX__/          XXXXXX         \__-----
	---___  XXX__/          XXXXXX      \__         ---
	  --  --__/   ___/\  XXXXXX            /  ___---=
	    -_    ___/    XXXXXX              '--- XXXXXX
	      --\/XXX\ XXXXXX                      /XXXXX
	        \XXXXXXXXX                        /XXXXX/
	         \XXXXXX                        _/XXXXX/
	           \XXXXX--__/              __-- XXXX/
	            --XXXXXXX---------------- XXXXX--
	               \XXXXXXXXXXXXXXXXXXXXXXXX-
	                 --XXXXXXXXXXXXXXXXXX-

*******************************************************************************
*		BLITTATE "IN FARBEN"					      *
*******************************************************************************

Bis jetzt haben wir uns darauf beschränkt, Bilder zu betrachten, die nur von einer
Bitebene, d.h. nur 2 Farben haben. Normalerweise sind beim Arbeiten mit
Mehrfarbbilder, die Bitebenen nacheinander im Speicher angeordnet, so dass
unmittelbar nach dem letzten Wort einer Bitebene das erste Wort der nächste Bitebene folgt.

Das Bild ist dann wie folgt strukturiert:

bitplane 1	|    |    |    |    |			|    |
			| 0  | 1  |  2 |  3 |			| 19 |	Reihe 0 bitplane 1
			|____|____|____|____|			|____|
			|    |    |    |    |			|    |
			| 20 | 21 | 22 | 23 |			| 39 |	Reihe 1 bitplane 1
			|____|____|____|____|			|____|
			|								     |
			|								     |


			|____ ____ ____ ____			 ____|
			|    |    |    |    |			|    |
			|    |    |    |    |			|    |	letzte Reihe bitplane 1
			|____|____|____|____|_ _ _ _ _ _|____|
bitplane 2	|    |    |    |    |			|    |
			| 0  | 1  |  2 |  3 |		    | 19 |	Reihe 0 bitplane 2
			|____|____|____|____|			|____|
			|								     |
			|									 |


			|____ ____ ____ ____			 ____|
			|    |    |    |    |			|    |
			|    |    |    |    |			|    |	letzte Reihe bitplane 2
			|____|____|____|____|_ _ _ _ _ _|____|
bitplane 3	|    |    |    |    |			|    |
			|    |    |    |    |			|    |	Reihe 0 bitplane 3
			|____|____|____|____|_ _ _ _ _ _|____|
			|									 |


			|____ ____ ____ ____			 ____|
			|    |    |    |    |			|    |	letzte Reihe
			|    |    |    |    |			|    |	letzte bitplane
			|____|____|____|____|_ _ _ _ _ _|____|

		Fig. 12  Repräsentation eines Bildes im Speicher
			für mehrere-Bitebene (jedes Quadrat ist ein Wort)*/


Wie Sie bereits wissen, belegt ein Bitebene mit H-Wörter und V-Zeilen, H * V Wörter 
oder 2 * H * V Bytes. 
(normalerweise H = 20 und V = 256, denn eine Bitebene belegt 40 * 256 Bytes). 

Dies bedeutet, dass die Bitebenen im Speicher nacheinander angeordnet sind.
Wenn Bitebene 1 bei Adresse PLANE1 beginnt, dann startet die Bitebene 2
bei PLANE2 = PLANE1 + 2 * H * V. In ähnlicher Weise beginnt die Bitebene 3 
bei PLANE3 = PLANE2 + 2 * H * V und so weiter. 

Die gleiche Formel gilt für die Bestimmung der Adresse eines bestimmten Wortes in
der Bitebene. Beispielsweise erfolgt die Berechnung der Adresse des siebten Wortes 
der ersten bzw. zweiten Bitebene mit:

Adresse ADDRESS1 = PLANE1 + 2 * 7, 
Adresse ADDRESS2 = PLANE2 + 2 * 7, 
während das siebte Wort der zweiten Bitebene die Adresse
//ADDRESS2 = PLANE1 + 2 * H * V + (2 * 7) hat.							?????

Aber seit 
ADDRESS1 = PLANE1 + 2 * 7 haben die folgende Formel:
ADRESSE2 = ADRESSE1 + 2 * H * V.

Diese Formel wird uns in Kürze sehr nützlich sein. Ein rechteckiges Bild,
(in einem Bildschirm) mit N-Bitebenen, wird durch N Rechtecke für jede Bitebene gebildet.
Also, um es mit dem Blitter zu manipulieren, führe einfach für jede Bitebene einen Blittata aus.

In der Abbildung unten sehen Sie einen 3-Bitebenen-Bildschirm, der ein 3-reihiges Bild hervorhebt.

Im Speicher bilden die Reihen jeder Bitebene ein anderes Rechteck von Wörtern.
(Wir haben in jeder Zeile des Bildes die Bitebene angegeben, zu der es gehört.)
Wie Sie sehen können, liegen die Linien jeder Bitebene (den Reihen der anderen Ebenen)
entfernt voneinander. Sie müssen deshalb mit verschiedenen Blittings manipuliert werden.

		  +----------------------------------------+
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|

		  |ииииииииииииииииииииииииииииииииииииииии|
		  +----------------------------------------+
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|

		  |ииииииииииииииииииииииииииииииииииииииии|
		  +----------------------------------------+
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|

		  |ииииииииииииииииииииииииииииииииииииииии|
		  +----------------------------------------+ 

		  Abb. 13 Bildschirm mit hervorgehobenem Bild.

Wenn wir zum Beispiel eine Figur auf dem Bildschirm bringen, blittern wir zuerst
die erste  Ebene der Figur in die ersten Ebene des Bildschirms, dann 
die zweite Ebene der Figur in die zweiten Ebene des Bildschirms, dann machen wir das gleiche
mit der dritten Ebene. (und nach und nach mit den anderen Bitebenen.)

Normalerweise besteht dann eine Schleife aus folgenden blittate:

	move.w	#NUMEROPLANES-1,d1	; Schleifenzähler
LOOP:
waitblit:				; warte auf das Ende des Blitters
	btst	#6,2(a5)	; des vorherigen Blittings
	bne.s	waitblit

	move.l	#$09f00000,$40(a5)	; bltcon0 und BLTCON1 - Kopie von A und D
	
; Laden Sie die anderen Blitter-Protokolle

; starte die Blittata

	dbra	d1,LOOP		; Schleife

Die in die Blitterregister zu ladenden Werte sind bei jedem Blittata immer gleich,
außer natürlich für die BLTxPT Register, weil die Adressen der verschiedenen Bitebenen 
natürlich unterschiedlich sind.
An diesem Punkt kommt die Formel, die wir gesehen haben, ins Spiel.
Nach dieser Formel kennen wir die Adressen, die in BLTxPT geschrieben werden sollen,
für die erste Blittata (d.h. für die Blittata bezogen auf die erste Bitebene).
Wir sind in der Lage die Adressen (für die in die BLTxPT-Register) für die nachfolgenden
Bitebenen zu berechnen.
Es ist genug in eine Variable die Adresse (relativ) zur ersten Bitebene zu setzen,
und zu dieser Adresse 2 * H * V bei jedem Schleifendurchlauf hinzufügen.
In der Beispiellektion 9f1.s sehen Sie, wie diese Technik angewendet wird. Nicht immer
werden jedoch Schleifen dieses Typs verwendet.

In den Beispielen lesson9f2.s und lesson9f3.s gibt es weitere Beispiele für Blittings
"in Farbe".

Es gibt jedoch eine andere Möglichkeit, die Bitebene im Speicher zu speichern, was uns ermöglicht
mit einem Schlag alle Bitplanes eines Bildes, zu tupfen. Es wird genannt 
"INTERLEAVED BITMAP" oder interlaced Bitmap. 
Wie der Name schon sagt,besteht diese Technik darin, die Linien der verschiedenen Ebenen miteinander 
zu "vermischen".
Anstatt zuerst alle Reihen (Zeilen) der ersten Ebene zu setzen, und dann die der zweiten
und so weiter, setzen wir zuerst die Zeile 0 (Linie 0 zuerst) der ersten Bitebene, dann die
Zeile 0 der zweiten Bitebene und dann in der Reihenfolge die Zeilen 0 der anderen Ebenen.
Nach den Zeilen 0 aller Ebenen setzen wir die Zeile 1 der ersten Ebene, dann die
Zeile 1 der zweiten und dann alle Zeilen 1 der anderen Ebenen.
So machen wir dann mit den anderen Linien (Zeilen) weiter.

Um dies zu verstehen, sehen Sie sich das folgende Bild an und
vergleichen Sie es mit Abb. 12, wo die normale Anordnung gezeigt ist:

		Bitebenen.

		|    |    |    |    |			|    |
		| 0  | 1  |  2 |  3 |	        | 19 |	Reihe 0 bitplane 1
		|____|____|____|____|			|____|
		|    |    |    |    |			|    |
		| 20 | 21 | 22 | 23 |			| 39 |	Reihe 0 bitplane 2
		|____|____|____|____|			|____|
		|									 |
		|									 |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |
		|    |    |    |    |			|    |	Reihe 0 letzte bitplane
		|____|____|____|____|_ _ _ _ _ _|____|
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |	Reihe 1 bitplane 1
		|____|____|____|____|			|____|
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |	Reihe 1 bitplane 2
		|____|____|____|____|			|____|
		|								     |
		|								     |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |
		|    |    |    |    |			|    |	Reihe 1 letzte bitplane
		|____|____|____|____|_ _ _ _ _ _|____|
		|									 |
		|									 |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |
		|    |    |    |    |			|    |	letzte Reihe bitplane 1
		|____|____|____|____|_ _ _ _ _ _|____|
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |	letzte Reihe bitplane 2
		|____|____|____|____|			|____|
		|									 |


		|____ ____ ____ ____			 ____|
		|    |    |    |    |			|    |	letzte Reihe
		|    |    |    |    |			|    |	letzte bitplane
		|____|____|____|____|_ _ _ _ _ _|____|


		Abb. 14 Darstellung eines Bildes im Speicher
		mit mehreren Bitebenen (jedes Quadrat ist ein Wort)
		mit der INTERLEAVED (oder RAWBLIT) -Technik.

Lassen Sie uns zuerst sehen, wie wir Bilder in diesem Format anzeigen können,
wenn wir den Blitter für einen Moment beiseite lassen. 

Die Anzahl der Linien und damit der Wörter, aus denen die Bitplane besteht ist immer gleich.
Was sich ändert, ist die relative Bestimmung der Linien. 

Das bedeutet für uns 2 Änderungen an der Prozedur, die wir normalerweise verwenden
um auf die Bitebenen zu sehen. 

Die erste betrifft die Art und Weise, wie wir die Adressen berechnen, die in die 
BPLxPT-Register eingetragen werden.

Um die Adressen der Bitebenen in die Copperliste zu bringen, berechnen wir 
die Adressen der Bitebene normalerweise ausgehend von der der ersten Adresse. (nach der ersten), 

durch Hinzufügen der Anzahl der Bytes, die jedes Mal von einer Zeile belegt wird,
multipliziert mit der Anzahl der Zeilen, die die Bitebene bilden.

Dies liegt daran, dass die erste Zeile einer Bitebene gespeichert ist  
nach der letzten vorherigen Bitebene und das die erste Zeile einer Bitplane 
vor einer Anzahl von Zeilen, die gleich der Höhe der Bitebene selbst ist.

Bei der verschachtelten Anordnung ist jedoch die Zeile 0 der Bitebene
unmittelbar nach der Zeile 0 der vorhergehenden Bitebene gespeichert.

Dies bedeutet, dass wir in der Schleife, welche die Bitebenenadressen berechnet,  
die Nummer einer Bitebene jedes Mal zur Adresse in Bytes einer Bitebene
addieren müssen, die von einer Zeile belegt sind, um die Adresse der nächsten Bitebene zu erhalten.

Wir müssen auch beachten, dass im Gegensatz zum Normalfall die Zeilen, die
eine Bitebene bilden, NICHT aufeinanderfolgend im Speicher angeordnet ist.

Zwischen der Y-Zeile und der Y + 1-Zeile (Reihe) befinden sich tatsächlich die Zeilen 
(Reihen) der anderen Bitebenen.

Dies bedeutet, dass der Bitebenenzeiger jedes Mal, wenn er am Ende einer Linie ankommt,
die Linien der anderen Bitebenen "überspringen" muss, um zum Anfangspunkt der 
nächsten Zeile zu kommen.

Wie Sie vielleicht bereits erraten haben, müssen wir die Formel verwenden, um es abzurufen.

Ich erinnere Sie daran, dass sogar die Bitplanes ihre MODULO enthalten, die in der
BPLxMOD registriert sind. (wobei x = 1 für ungerade und x = 2 für gerade Bitebenen steht).

Mit der normalen Anordnung der Bitebenen, beginnt nach dem Ende einer
Zeile die nächste Zeile. Wir setzen das Modulo auf 0 (außer wir wollen
den Flut-Effekt machen oder wir haben ein größeres Bild des Bildschirms).

Sehen wir uns stattdessen den Wert an, der mit der Interleaved-Bestimmung zu verwenden ist.
Wir geben mit N die Nummer der von uns verwendeten Bitebenen an. 
Betrachten wir die Bitebene 1: Am Anfang der Zeile Y zeigt das Register BPLPT1
auf das erste Wort der Zeile Y der Bitebene 1.
Während die Y-Linie auf dem Monitor angezeigt wird, bewegt sich das BPLPT1-Register,
in dem es auf die folgenden Wörter zeigt.
Am Ende der Zeile Y zeigt BPLPT1 auf das erste Wort der Zeile Y von bitplane2.
An dieser Stelle wird die (Formel) hinzugefügt.
Wir wollen, dass BPLPT1 auf das erste Wort der Y + 1 Zeile der Bitebene 1 zeigt.

Wir müssen daher die Linien 2, 3 usw. bis zur N zum Zeiger addieren.
Insgesamt sind dies N-1 Zeilen. (Wenn wir zum Beispiel 4 Bit-Ebenen haben, müssen 
wir die Y-Linien der Bitebenen 2, 3 und 4, also 3 Zeilen überspringen.)
Wenn also eine Zeile L Wörter belegt, also 2 * L Bytes, dann ist der korrekte Wert der
Modulo 2 * L * (N-1).

		 ____ ____ ____ ____ _ _ _ _ _ _ ____
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |		Reihe Y bitplane 1
		|____|____|____|____|			|____|
	/	|    |    |    |    |			|    |
	|	|    |    |    |    |			|    |		Reihe Y bitplane 2
	|	|____|____|____|____|			|____|
	|	|									 |
	|	|								  |
	|
	|
wir müssen springen
 diese N-1 Linien
	|
	|
	|	|____ ____ ____ ____			 ____|
	|	|    |    |    |    |			|    |
	|	|    |    |    |    |			|    |		Reihe Y bitplane N
	\	|____|____|____|____|_ _ _ _ _ _|____|
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |		Reihe Y+1 bitplane 1
		|____|____|____|____|			|____|

		Fig. 15 Werte der MODULO mit der INTERLEAVED-Technik.


Natürlich müssen bei allen Bilder, die wir auf dem Bildschirm anzeigen wollen, 
die Bitebenen im verschachtelten Format angeordnet sein.

Wenn ein Bild direkt in unserer Quelle (durch die DC.w ...) definiert ist
müssen wir die Zeilen, die wir erwarten dieses Format haben.  

Wenn wir stattdessen das Bild in einer externen Datei haben, das durch die 
INCBIN-Direktive aufgenommen werden soll, müssen wir es NICHT ins RAW-Format 
(das ist das normale Format) konvertieren,sondern ins Interleaved-Format. 

Alle Konvertierungsprogramme unterstützen dieses Format. Obwohl viele dies tun
weichen die Namen mit denen sie es aufrufen voneinander ab.

Wir haben den KEFRENS CONVERTER verwendet. Dort wird das Format "RAW-BLIT" genannt.
Andere Konverter nennen es "RASTER MODULO". 

Sei also vorsichtig, um das Bild in das richtige Bild zu konvertieren,
sonst sehen Sie nichts und verbringen Stunden damit, nach Ihrem zu suchen und sie
programmieren einen nicht existierenden BUG!

In Lektion 9g1.s sehen Sie ein Beispiel für die Anzeige einer verschachtelten Bitmap.

		               ___
		             _/   г\
		            /      .г\
		           /._/\\_\ \ \
		          (( _/\__\\ \<
		          /\/__.  \_.  \
		         <__ \Э\\__Y\\  \
		      ____<   »»___///  /
		     /Э   Y       .//  /
		    //    |_  э---|` ./
		   /`      /\__  ^/\ |
		  /.    .  [_  \_/  \|
		.//   _/     \_/ ~\  
		|(    |        ,   \
		|?    | (   . /    ))
		|и    | Э    Y    //  _
		|  _  | ?    |   / \ (%)
		| |_| | |    ?  ` /"XI_I_ 
		?_| |_? ?    и\  ` [____г\
		/?? ??\ и      \_  [____ (
		)     ( ._   _.  \_[_____/
		\_____/   \_/      |эaXeэ|
		                   X_____X

Lassen Sie uns jetzt sehen, warum dieses Format durch die Verwendung des Blitters bequem ist.

In der folgenden Abbildung wird ein interleaved Bildschirm mit einem hervorgehobenen rechteckigen 
Bereich angezeigt.
Wie Sie sehen können, werden (bilden) die Linien der verschiedenen Bitebenen miteinander "vermischt" 
und bilden ein einziges Rechteck im Speicher. (Wir haben in jeder Zeile des Bildes die Bitebene angegeben, 
zu der es gehört.) 
Vergleichen Sie diese Abbildung mit der Abbildung 13, die eine ähnliche Situation in einem "normalen" 
Bildschirm zeigt. Im Normalfall sind die Zeilen der N Bitebenen des Bildes
in N unterschiedlichen Rechtecken von Wörtern, jeweils so hoch Zeilen (wie Linien) im Bild sind. 
Im verschachtelten Fall stattdessen bilden die Linien der N Bitebenen, die sich vermischen,  
ein einzelnes Wortrechteck.
Beachten Sie, dass dieses Rechteck eine Höhe hat, die der Höhe des Bildes entspricht
multipliziert mit der Anzahl der Bitebenen, die es bilden. 
Tatsächlich haben wir ein Bild mit 3 Bitplanes mit je 3 Linien hoch.
Das Rechteck der Wörter hat 9 Zeilen.

		  +----------------------------------------+
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииии#####1####ииииииииииииииииии|
		  |ииииииииииии#####2####ииииииииииииииииии|
		  |ииииииииииии#####3####ииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|

		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  |ииииииииииииииииииииииииииииииииииииииии|
		  +----------------------------------------+

		  Abb. 16 INTERLEAVED-Bildschirm mit hervorgehobenem Bild.

Die Tatsache, dass die Zeilen der Bitebenen eines Bildes verschachtelt werden um
ein einzelnes Rechteck im Speicher zu bilden, ist es sehr wichtig, weil es uns erlaubt
das Bild mit einer einzigen Blittata zu bearbeiten. 

Natürlich, unterscheidet sich das Blittata von den Blittlings, die wir im Normalfall machen.

Zuallererst ist die Größe (der Glückseligkeit) anders.
Im Normalfall hat jede Blittata eine Höhe, die der Höhe des Bildes entspricht. 
Während im verschachtelten Fall das Rechteck der Wörter eine Höhe gleich der Höhe des Bildes 
multipliziert mit der Anzahl von Bitplanes hat, die es bilden, und deshalb muss das die Höhe von 
unser blittata sein.

Zweitens ist die Art, wie wir die Adressen der Speicherplätze berechnen anders.
Insbesondere müssen wir die Art ändern, wie wir die Adresse des ersten Wortes einer Zeile berechnen.

Im Normalfall haben wir gesehen, dass wenn das auzublendende Rechteck in Linie Y beginnt, der
"Abstand" (Offset) vom ersten Wort der Y-Linie vom Anfang der Bitebene ist Y * ist.
(ANZAHL BYTES, DIE VON EINER LINIE BESETZT SIND).

Und das ist logisch, weil in einem normalen Bildschirm die Zeilen einer Bitebene angezeigt werden
die aufeinanderfolgend im Speicher sind.

In einem INTERLEAVED-Bildschirm sind die Dinge jedoch anders, weil die Zeilen von
einer Bitebene nicht aufeinanderfolgend sind.

Tatsächlich gibt es, wie Sie wissen, nach der Y-Linien der ersten Bitebene die Y-Linien
der anderen Bitebenen und danach die Zeile Y + 1 der ersten Bitebene.

Somit ist der Abstand zwischen dem ersten Wort der Y-Reihe der ersten Bitebene und dem
ersten Wort der Zeile Y + 1 der ersten Bitebene gleich der Anzahl der Bytes
besetzt durch die Linien Y aller Bitebenen der Figur.

Mit der gleichen Argumentation verstehst du leicht der Abstand zwischen dem ersten Wort
der Zeile Y der ersten Bitebene und dem Anfang des Bildschirms ist gleich:

Y * (ANZAHL VON BYTES, DIE VON EINER REIHE BESCHÄFTIGT WERDEN) * (Anzahl Bitplanes)

Zusammenfassend ist daher die Berechnung der Adresse für ein ein Rechteckblock,
beginnend bei den X- und Y-Koordinaten für einen INTERLEAVED-Bildschirm:

Address_word = (Address_bitplane) + N * 2

mit:
N = (Y * (ANZAHL DER WÖRTER DIE EINE ZEILE BILDEN) * (Anzahl Bitplanes)) + (X / 16).

Mache ein einziges Blitting statt vieler, dadurch wird es einfacher und das Programm wird 
dadurch auch schneller.
Bitte beachten Sie, dass die vom Blitter benötigte Zeit (mehr oder weniger) gleich ist
für einen Blittata.

Die Höhe des Blittings ist gleich der Summe der Höhen der Einzel Blittings und dafür braucht 
es (im Normalfall) die gleiche Zeit, weil die Geschwindigkeit des Blitters gleich ist. Es wird 
bestimmt durch die Anzahl der Wörter der Dimension (Rechteckss) die verändert werden.

Der Vorteil liegt am Prozessor.

Allerdings kommt dem Prozessor (nur) eine einzige Blittata zugute, wie
Sie im folgenden Diagramm, das die auszuführenden Operationen der 2 Fälle 
(Bildschirm mit 3 Bitebenen) vergleicht, sehen können. (verstehen können) 


NORMALER BILDSCHIRM				INTERLEAVED BILDSCHIRM

1) warte auf das Ende			warte auf das Ende
   der (eventuellen) Blittata	der (eventuellen) Blittata

2) lädt die Blitter Register	lädt die Blitter Register für den
   für den ersten Blittata		ersten und einzigen Blittata							

3) warte auf das Ende
   des ersten Blittata

4) lädt die Blitter Register 
   für den zweiten Blittata

5) warte auf das Ende
   der zweiten Blittata

6) lädt die Blitter Register
   für den dritten blittata

Wie Sie sehen können, muss der Prozessor im Falle eines verschachtelten Bildschirms weniger Operationen machen
und vor allem er muss nur warten, bis der Blitter fertig ist, während er bei einem normalen Bildschirm mit
einer geraden Anzahl von Bitplanes (zur Anzahl von Zeichnen) warten muss.

Während einer Wartezeit macht der Prozessor nichts nützliches.(und muss nicht ausruhen,)
Es ist ratsam, ihn nach Möglichkeut die meist Zeit arbeiten zu lassen,
indem die Anzahl der Wartezeiten verringert wird.

Das Beispiel lesson9g2.s ist die INTERLEAVED-Version des Beispiels lesson9f1.s.
Schau sie dir zusammen an und bemerke die Unterschiede, die sie zeigen.

Das Beispiel lesson9g3.s ist stattdessen die INTERLEAVED-Version des Beispiels
lezione9f3.s. Vergleichen Sie auch diese.

					               ........
					           .::::::::::::::.
					          ::::::::::::::::::
					         :::       :::::::::.
					        :::          ::::::::
					       ::(__   ___    ::::::::
					       .::/_)  /__,  :/_\::::.
					      .:::o/    o   .: //::::::
					       .::/        .::./::::::
					       ::(__  )   .::  ::::::
					       .::/()    .::   ::::::'
	 _n_____________n__                      (___           ::::
	|-----------\\\--__F                       \ ~           |
	|_____________ (O_.\________      __________\___.      ./X\
	         \(__D)__\   \\     ~~~~~~             \______/.xST\
	          `-(___O)|_  ||        .                         XX|
	            (___O) \_//          :          .:    .        О|
	              (__O)///__________ //________.:     :        .|
	                                ~~~        :      :         :
	                                           .      .         .


*******************************************************************************
*				MASKEN				      *
*******************************************************************************

Der Blitter hat die Möglichkeit, das erste und das letzte Wort jeder Zeile eines Bildes zu 
maskieren, die durch Kanal A verläuft.
Maskierung bedeutet einige Bits solcher Wörter zu lesen und andere zu ignorieren.
Diese Operation kommt dank zweier Register, die wir bisher benutzt hatten, ohne sie zu erklären.
Diese beiden Register heißen BLTAFWM ($dff044) und BLTALWM ($dff046), und dienen jeweils dazu,
das erste und das letzte Wort jeder Zeile, das durch den Kanal A gelesen wird, zu maskieren. 
Jeder von ihnen enthält ein Wort, die Maske.

Der Blitter führt eine logische UND-Verknüpfung der korrespondierenden Bits des Wortes zwischen 
dem gelesenen Wort und der Maske beim Lesen des ersten oder letzten Wortes einer Zeile von Kanal A durch.

Wenn in der Maske ein Bit auf 0 gesetzt ist, wird es gelöscht.
Lass uns ein paar Beispiele sehen:

Word gelesen von
Kanal A		%10011011.00010111
Maske		%11111111.00000000
					  ^^^^^^^^
_________________________________

Ergebnis	%10011011.00000000

Auf diese Weise haben wir nur die 8 Bits, des rechten Teils des Wortes ausgewählt.

Word gelesen von
Kanal A		%10011011.00010111
Maske		%11111100.00111111
				   ^^ ^^
_________________________________

Ergebnis	%10011000.00010111

Auf diese Weise haben wir die 4 Bits in der Mitte der Maske zurückgesetzt.
Wenn wir die Maske vollständig zurücksetzen, löschen wir das ganze Wort:

Word gelesen von
Kanal A		%10011011.00010111
Maske		%00000000.00000000
_________________________________

Ergebnis	%00000000.00000000

Wenn wir stattdessen die Maske auf $ffff =%11111111.11111111 = -1 setzen
löscht die Maske nichts oder "übergibt" das ganze Wort:

Word gelesen von
Kanal A		%10011011.00010111
Maske		%11111111.11111111
_________________________________

Ergbebnis	%10011011.00010111

In all den Beispielen, die wir bisher gesehen haben, mussten wir nichts maskieren 
und tatsächlich haben wir beide Masken mit dem Wert $ffff initialisiert.
Das erste Wort jeder Zeile (d.h. das Wort ganz links) ist AND verbunden über BLTAFWM,
und das letzte Wort (das Wort auf der rechten Seite) ist AND verbunden mit BLTALWM.
Sie können es sich leicht merken, weil das F im Namen BLTAFWM für "First" steht,
das wie jeder weiß, "vorher" bedeutet und das L in BLTALWM bedeutet "Last",
das ist zuletzt.

Natürlich können die 2 Masken voneinander abweichend sein
(wofür würden wir sonst 2 Register brauchen?

Wenn die Linienbreite ein Einzelwort ist, werden beide Masken gleichzeitig auf das selbe Wort
angewendet.

Da die 2 BLTAFWM- und BLTALWM-Register aufeinanderfolgende Adressen haben ist
es möglich, sie mit einer einzigen MOVE.L-Anweisung #mask,$dff044 zu initialisieren.

Es ist wichtig zu beachten, dass die Masken auf die Daten vor der Ausführung des 
Shiftens angewendet werden.

Die Kanäle B und C haben nicht die Möglichkeit der Maskierung der gelesenen Wörter.

Im Beispiel Lektion 9h1.s zeigen wir die Wirkungsweise von Masken mit einfachen
Kopiervorgängen.

In Lektion 9h2.s haben wir eine Demonstration der Nützlichkeit der Masken
im "Extrahieren" von nur einenm Teil von einem Bild, das uns interessiert.

In Lektion 9h3.s und Lektion9h4.s präsentieren wir 2 neue Effekte mit der
Verwendung von Masken.

Die Beispiele lesson 9h2r.s, lesson9h3r.s und lesson9h4r.s sind die Versionen mit
Rawblit-Format (interleaved) von lesson9h1.s lesson9h2.s und lesson9h3.s.

Machen Sie einen Kreuzvergleich und beachten Sie alle Unterschiede.
Beachten Sie insbesondere, dass alle Interleaved-Version-Routinen nicht die Notwendigkeit haben,
eine Schleife zum Mischen auf jeder Ebene zu machen und daher eine viel einfachere Struktur haben.

Nachdem wir die neuen Effekte gesehen haben, wollen wir uns wieder mit einem alten Effekt,
dem Fisch, der auf dem Bildschirm schwimmt, befassen. Mit unserem neuen (entdecken)
Wissen über den Blitter können wir eine wichtige Verbesserung erreichen.

Wir haben in der Tat gesehen, dass es richtig ist eine "Spalte" mit Null-Wörtern rechts von der 
Figur hinzuzufügen, um die Figur richtig zu verschieben. 
Diese Tatsache zwingt uns dazu, mehr Speicher zu verschwenden als nötig, um sich die Zahlen zu merken.
Aber jetzt, dank der Masken, können wir diese Verschwendung vermeiden.
Um es zu verschieben, ist es notwendig, dass das letzte Wort jeder Zeile der Figur zurückgesetzt ist.
Anstatt ein gelöschtes Wort direkt aus dem Speicher zu lesen, können wir
ein beliebiges Wort einlesen und setzen es mit der Maske zurück.

Da die Maskierung wird vor dem Shiften ausgeführt wird, wird das Shift-Word ankommen 
als das letzte Word von jeder Nullreihe und alles ist es verhält sich so, als ob das 
Nullwort aus dem Speicher gelesen worden wäre.

Da der Wert des letzten Wortes in der Zeile keine Rolle spielt, können wir
ein Wort von irgendeinem Wert einlesen.

Also versuchen wir das folgende Spiel: Wir fügen kein Wort rechts neben dem Bild hinzu,
aber ohne es dem Blitter zu sagen, das heißt, wir setzen die Breite des Bildes 
so fest, als ob es ein Wort auf der rechten Seite der Figur gäbe.

Der Blitter wird daher nach dem Lesen des letzten Wortes einer Zeile denken
ein Wort erneut zu lesen und daher das Wort der Linie daneben lesen.

Was ist dieses Wort?
Wenn wir ein Bild im normalen Format verwenden, wird das erste Wort der nächsten Zeile zur 
gleichen Bitebene gehören, während es, wenn das Bild im verschachtelten Format ist, wird
das erste Wort zu einer Reihe einer anderen Bitebene gehören. 
In jedem Fall wird es jedoch ein Wort ungleich Null sein.
Für uns gibt es kein Problem, da wir es mit der Maske zurücksetzen können.

An dieser Stelle haben wir nur ein Problem: Wenn wir ein Wort zu viel gelesen haben,
hat der Quellzeiger sich ein Wort vorwärts bewegt.
Wenn es beginnt, die nächste Zeile zu lesen, beginnt es mit dem zweiten Wort 
statt des ersten in der Zeile. 

Wie können Sie den Zeiger zurückgeben?
Natürlich mit dem alten Trick der Negativform! Durch Festlegen des Wertes
der Quelle bei -2 (das Modulo ist in Bytes ausgedrückt), wird der Blitter neu positioniert
auf das erste Wort der folgenden Zeile. 
Wir fassen alles zusammen, indem wir zum Beispiel von den Fischen, die wir benutzten, zurückkehren
um die Verschiebung zu veranschaulichen.
Also haben wir ein Bild einer einzelnen Bitebene, 1 Wort breit und 6 Zeilen hoch. Wie gesagt, 
es wird keine Wortspalte rechts hinzugefügt.

Quelle
			word 1		
Reihe 1		10000011.11100000
  "  2		11001111.11111000
  "  3		11111111.11101100
  "  4		11111111.11111110
  "  5		11001111.11111000
  "  6		10000011.11100000
				
		Fig. 17 Wir fügen KEINE Spalten von Wörtern hinzu

Stellen wir uns jedoch vor, dass die zusätzliche Spalte vorhanden ist, und dann bauen wir hieraus
ein Rechteck, 2 Wörter breit und 6 Zeilen hoch. Der Blitter liest dann 2 Wörter.
Nehmen Sie für jede Zeile das erste Wort der nächsten Zeile als zweites Wort.
Sehen wir uns insbesondere anhand der folgenden Abbildung an, was während des Spiels passiert.
Lesen der ersten Zeile:

Quelle

			word 1		
Reihe 1		10000011.11100000--------
  "  2		11001111.11111000-------+-----------------------
  "  3		11111111.11101100		|						|
  "  4		11111111.11111110		|						|
  "  5		11001111.11111000		|						|
  "  6		10000011.11100000		|						|
									|						|
									V						V
WORDS (LETTE)				
vom Kanal A					10000011.11100000		11001111.11111000
									|						|
									|						|
									V						V
Das letzte Word
der Reihe wird maskiert		10000011.11100000		00000000.00000000
									|						|
									|						|
									V						V

SHIFT (2 pixel)				00100000.11111000		00000000.00000000
									|						|
									|						|
									V						V

				
					geschrieben in Kanal D			geschrieben in Kanal D

		Fig. 18	 Shift mit Zurücksetzen des letzten Wortes.

Wie Sie sehen können, wird das zweite gelesene Wort gelöscht, bevor es verschoben wird.
Nach der Verschiebung werden die 2 Wörter durch den Kanal D geschrieben.
In der Zwischenzeit hat sich der Zeiger auf Kanal A um 2 Worte vorwärts bewegt,
und zeigt auf das erste Wort der dritten Zeile. Wir müssen es stattdessen
auf das erste Wort der zweiten Zeile zeigen, d.h. wir müssen es zurückbekommen,
um ein Wort. Also verwenden wir ein Modulo gleich -2. Die Bewegungen
des Zeigers sind in der folgenden Abbildung dargestellt:


	Quelle				   WORD 	      WORD 			Zwischenword
						  Anfang	  nach dem Ersten	Hinzufügen
							 |	  Reihe			 MODULO
	10000011.11100000	<----				|			  |
	11001111.11111000	<-------------------+--------------
	11111111.11101100	<-------------------
	11111111.11111110
	11001111.11111000
	10000011.11100000

		Fig. 19	 Bewegung des Zeigers zur Quelle.

Um unseren Fisch in Aktion zu sehen, sehen Sie sich das Beispiel lesson9i1.s an. 

Jetzt wissen wir, wie man die Figuren auf dem Bildschirm sehr gut mit dem Blitter bewegt.
Diese Figuren werden BOB genannt, was eine Abkürzung des englischen Begriffs "Blitter OBject"
ist, oder Objekte, die vom Blitter erstellt wurden.
 
Mit BOB können wir die gleichen Dinge tun, die wir mit den Hardware-Sprites machen können.
BOBs sind jedoch langsamer als Sprites, weil der Blitter einige Zeit, zum Kopieren der Daten verwendet.
Im Gegensatz dazu leiden die BOBS nicht unter der Beschränkungen von Sprites in Bezug auf Größe, Farben 
und maximale Anzahl.

In der Tat kann ein BOB so groß sein, wie wir es wollen. (Es ist offensichtlich, dass sie
wachsen können bis der Speicher belegt ist, und von
folglich die Zeit, die notwendig ist, damit der Blitter sie bewegt, 
und es kann eine Anzahl von Farben haben, die der des Bildschirms entspricht.
Darüber hinaus gibt es keine Begrenzung für die Anzahl der Bobs die
gleichzeitig auf dem Bildschirm sind. (Offensichtlich sind mehr Bobs da, 
verlieren wir mehr Zeit, um sie zu zeichnen).
"Wie nett", sagst du, "wir können anfangen, ein Spiel zu machen!". Ein Moment noch, Lass
uns nicht zu aufgeregt werden.  Sind wir sicher, mit BOBs die gleichen Dinge zu tun
die wir mit Sprites machen können?
Wir haben einen farbigen BOB, den wir frei mit der Maus auf dem Bildschirm bewegen können.
Aber es gibt ein Problem ... Bewegen Sie den BOB,löschen wir den Hintergrund! 
Dies passiert bei Sprites nicht, da Sprites kleine Bitebenen sind, die
getrennt von den Bitebenen des Hintergrunds sind. ???
Stattdessen werden die BOBs direkt auf der Hintergrundbild-Bitebene gezeichnet,
teilweise überschreiben sie sie.
Eine erste Lösung des Problems ist in den Beispielen lesson9i3.s und lezione9i3r.s dargestellt.
(Natürlich ist der zweite die RAW-BLIT-Version des Ersten).
Wie Sie sehen werden, ist es jedoch noch nicht befriedigend.

Im Beispiel lesson9i4.s versuchen wir eine andere Lösung, aber es präsentiert auch
Probleme.

Im Beispiel lesson9i5.s sehen wir stattdessen ein BOB-Beispiel, das mit dem Joystick bewegt wurde.
Es kommt teilweise aus dem Bildschirm.

Wir haben angefangen die BOBs kennenzulernen, aber wir haben leider bis jetzt noch kein befriedigendes 
Ergebnis erreicht, die uns ermöglichen die typischen Operationen mit BOBs, wie bei Videospielen,
wegen des Problems des Hintergrundes durchführen zu können.

Unglücklicherweise mit dem was wir bis jetzt wissen, können wir es nicht besser.

Aber keine Sorge: Es gibt noch viel zu lernen über den Blitter, und
einer davon wird uns helfen, das Problem zu lösen!
Kraft und Mut, deshalb ist der Weg noch lang!

			 .
			  )                       \\\..
			(                       __/ __ \
			 )                      (.__.)  O
			(  n_______n            /(__,    \
			  |________ }__________/ ____,    )__
			       ((O) \\.       (__________/   \
			        =(_O) |          /(    )\     \
			          (_O)|_______   \_\  /_/  \   )
			                      \    \)(/     | /
			                       )   /. \     |/
			                       |  / .  \    |
			                       | (__.___)   |
			                       |_|==()==|___|
			                        |   _      |
			                        |   |      |
			                        |   |      |


*******************************************************************************
*		KOPIEREN VON ÜBERLAPPENDEN SPEICHERBEREICHEN 			      *
*******************************************************************************

Wir werden nun ein weiteres Merkmal des Blitters illustrieren, das von der
Kopie von Rechtecken, eine Operation, die wir jetzt gut kennen.
Was passiert wenn die Quelle und das Ziel der Blittata überlappend sind, d.h.
Teile der 2-Wort-Rechtecke gemeinsame Teile haben? 
Es ist offensichtlich, dass die Blittata das gesamte Ziel ändern wird,
einschließlich der Teile, die mit der Quelle gemeinsam sind.
Die Kopie zwischen überlappenden Bereichen besteht also darin, den Inhalt der
Quelle vor dem Kopieren auf das Ziel zu nehmen.
Nach dem Kopieren wird der Inhalt der Quelle geändert.
Daher wird das Ziel nach dem Kopieren NICHT gleich der Quelle sein !!
Lassen Sie uns wiederholen, es wird das gleiche wie die Quelle vor der Kopie sein!
Kurz gesagt, stellen Sie sich vor, dass das Ziel eine Aufnahme der Quelle ist,
und das während der Zeit, die der Fotograf zur Entwicklung der Fotos braucht,
die Quelle schnell genug gealtert ist, um ganz anders auszusehen wie es auf dem Bild aussieht.
Ist es unter diesen Bedingungen immer eine Kopie?
Wir müssen das Problem gut studieren.
Lassen Sie uns sehen, was in einem Beispiel für eine Kopie eines 
2 Linien und 3 Wörter breiten Rechtecks ​​passiert.
Angenommen, die Quelle ist niedriger als das Ziel, z.B.
illustriert durch die folgende Abbildung:


		 ____ ____ ____ ____ ____ ____
		|    |\\\\|\\\\|\\\\|    |    |
		|    |\\\\|\\\\|\\\\|    |    |
		|____|\\\\|\\\\|\\\\|____|____|		Rechteck Quelle=////
		|    |\\\\|XXXX|XXXX|////|    |
		|    |\\\\|XXXX|XXXX|////|    |		Rechteck Ziel=\\\\
		|____|\\\\|XXXX|XXXX|////|____|
		|    |    |////|////|////|    |		Rechteck gemeinsam=XXXX
		|    |    |////|////|////|    |
		|____|____|////|////|////|____|
		|    |    |    |    |    |    |
		|    |    |    |    |    |    |
		|____|____|____|____|____|____|


		Fig. 20	 Blittata zwischen überlappenden Rechtecken

Lassen Sie uns mit Hilfe einer Reihe von Zahlen die folgenden Phasen im Betrieb analysieren.
Wir bezeichnen mit den Buchstaben A, B, C, D, E, F den Inhalt der 6 Wörter,
die wir kopieren möchten, und mit dem Symbol "?" den Inhalt der Wörter, die
uns nicht interessieren und deshalb können wir auch abbrechen.
Bevor wir die Kopie starten, haben wir folgende Situation:

		 ____ ____ ____ ____ ____ ____
		|    |\\\\|\\\\|\\\\|    |    |
		|    |  ? |  ? |  ? |    |    |
		|____|\\\\|\\\\|\\\\|____|____|		Rechteck Quelle=////
		|    |\\\\|XXXX|XXXX|////|    |
		|    |  ? |  A |  B |  C |    |		Rechteck Ziel=\\\\
		|____|\\\\|XXXX|XXXX|////|____|
		|    |    |////|////|////|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  E |  F |    |
		|____|____|////|////|////|____|


		Fig. 21a Blittata zwischen überlappenden Rechtecken

Wie wir wissen, kopiert der Blitter die Wörter einzeln beginnend von oben links und
weiter nach unten und nach rechts. Die erste Zeile wird gelesen und in einen Bereich
des Ziels kopiert, der nicht gemeinsam ist, und das damit wir es sicher überschreiben 
können. Hier ist die Situation nach dem Kopieren der ersten Zeile:

		 ____ ____ ____ ____ ____ ____
		|    |\\\\|\\\\|\\\\|    |    |
		|    |  A |  B |  C |    |    |
		|____|\\\\|\\\\|\\\\|____|____|		Rechteck Quelle=////
		|    |\\\\|XXXX|XXXX|////|    |
		|    |  ? |  A |  B |  C |    |		Rechteck Ziel=\\\\
		|____|\\\\|XXXX|XXXX|////|____|
		|    |    |////|////|////|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  E |  F |    |
		|____|____|////|////|////|____|


		Fig. 21b Blittata zwischen überlappenden Rechtecken

An dieser Stelle müssen wir die zweite Zeile kopieren. Die zweite Zeile des
Ziel überlappt mit der ersten Zeile der Quelle. Das bedeutet
wenn wir Daten in das Ziel schreiben, überschreiben wir ein Teil
der Quelle und zerstören ihren Inhalt. Allerdings gehören die überschriebenen 
Daten zur ERSTEN Zeile der Quelle, die wir bereits kopiert haben,
und deshalb brauchen wir es nicht mehr. Daher gibt es keine Probleme.
Die Situation nach der Kopie der zweiten (und letzten) Zeile ist wie folgt:

		 ____ ____ ____ ____ ____ ____
		|    |\\\\|\\\\|\\\\|    |    |
		|    |  A |  B |  C |    |    |
		|____|\\\\|\\\\|\\\\|____|____|		Rechteck Quelle=////
		|    |\\\\|XXXX|XXXX|////|    |
		|    |  D |  E |  F |  C |    |		Rechteck Ziel=\\\\
		|____|\\\\|XXXX|XXXX|////|____|
		|    |    |////|////|////|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  E |  F |    |
		|____|____|////|////|////|____|


		Fig. 21c Blittata zwischen überlappenden Rechtecken

Wir haben genau das bekommen was wir wollten, denn das Ziel-Rechteck
ist jetzt die exakte Kopie des Inhalts des Quellrechtecks, ​​bevor
wir die Blittata begonnen haben. Beachten Sie, dass der Inhalt der Quelle
sich jetzt geändert hat, aber das war unvermeidlich.

Im Beispiel lesson9l1.s können Sie alles in der Praxis sehen.

Es scheint daher, dass die bei Überschneidung zwischen Quelle und Ziel keine Probleme entsteht.
Wir versuchen jedoch, den Fall zu untersuchen, in dem sich das Ziel niedriger als die Quelle befindet:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |////|////|////|    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |////|XXXX|XXXX|\\\\|    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |\\\\|\\\\|\\\\|    |
		|____|____|\\\\|\\\\|\\\\|____|
		|    |    |    |    |    |    |
		|    |    |    |    |    |    |
		|____|____|____|____|____|____|


		Fig. 22	 Blittata zwischen überlappenden Rechtecken

Vor dem Blittata ist die Situation wie folgt:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  E |  F |  ? |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  ? |  ? |  ? |    |
		|____|____|\\\\|\\\\|\\\\|____|

		Fig. 23a Blittata zwischen überlappenden Rechtecken

Beginnen wir mit dem Kopieren der ersten Zeile. Die erste Zeile des Ziels ist
teilweise überlappt mit der zweiten Zeile der Quelle, die noch nicht kopiert ist.
Hier ist, was Sie bekommen:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  A |  B |  C |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  ? |  ? |  ? |    |
		|____|____|\\\\|\\\\|\\\\|____|

		Fig. 23b Blittata zwischen überlappenden Rechtecken

Wie Sie sehen können, haben wir die Werte E und F verloren! Es scheint, dass dieses Mal
die Kopie nicht erfolgreich sein wird! Wir kopieren jedoch auch die zweite Zeile und sehen
was los ist?

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  A |  B |  C |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  A |  B |    |
		|____|____|\\\\|\\\\|\\\\|____|


		Fig. 23c Blittata zwischen überlappenden Rechtecken


Hier ist es. Die Blittata ist vorbei, aber das Ergebnis ist nicht das, was wir wollten.
Bist du überzeugt?

Nein? Schauen Sie sich das Beispiel lesson9l2.s an und überzeugen Sie sich selbst!

Wir versuchen zu verstehen, warum es das erste Mal funktioniert hat und dieses Mal nicht.
Das Problem entsteht, wenn wir auf Teile des Ziels schreiben die mit der Quelle überlappt sind, 
weil wir in diesem Fall einige Daten überschreiben.
Im ersten Fall gab es keine Probleme, da wir die Daten die dort überschrieben wurden
schon kopiert hatten.
Dies geschah, weil die Quelle weiter unten liegt zu den höherliegenden Adressen
des Ziels, und die Überschneidung tritt zwischen der ersten Zeile der
Quelle und der zweiten Zeile des Ziels.
Da der Blitter das Kopieren von der ersten Zeile beginnt, werden die  Daten aus der ersten Zeile
der Quelle kopiert, BEVOR sie von der zweiten Zeile des Ziels überschrieben werden.
Im zweiten Fall stattdessen ist die Quelle jedoch höher (an tieferen Adressen)
des Ziels, und die Überlappung tritt zwischen dem zweiten Zeile der Quelle 
und der ersten Zeile des Ziels auf.
Die Daten der zweiten Zeile der Quelle werden daher überschrieben
während der Kopie der ersten Zeile, d.h. BEVOR sie nacheinander kopiert werden, 
deshalb sind sie verloren.
Um dieses Problem zu lösen, sollten Sie zuerst die zweite und dann die erste Zeile kopieren.
Dies ist möglich mit dem DESCENDING MODE des Blitters.
Bei Verwendung dieses Weges erstellt der Blitter die Kopie (oder eine andere Operation)
in die entgegengesetzte Richtung, als sie normalerweise getan wird, 
das heißt, er startet mit dem Word weiter unten rechts vom Rechteck und geht weiter nach links
und nach oben. 
Die Worte, die der Blittata diesem Pfad folgen, werden allmählich kleiner.
Es wird daher gesagt, dass der Blitter im Speicher absteigt, daher der Name der
Betriebsart (im Gegensatz dazu wird der Normalmodus auch als ASCENDING-MODE bezeichnet,
in der Tat werden normalerweise Wörter mit Adressen schrittweise ansteigend. (wachsend).
Bevor im Detail untersucht wird, wie man den Blitter den DESCENDING MODE benutzt,
lassen Sie uns zu dem Problem des Kopierens überlappender Regionen zurückkehren und überprüfen
das der absteigende Weg die richtige Lösung ist.

Die Ausgangssituation ist wie folgt:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  E |  F |  ? |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  ? |  ? |  ? |    |
		|____|____|\\\\|\\\\|\\\\|____|

		Fig. 24a Blittata zwischen überlappenden Rechtecken

Diesmal benutzen wir den absteigenden Weg, also fangen wir mit dem Kopieren von
der letzten Zeile an. Auf diese Weise schreiben wir von Beginn nicht auf den 
übereinanderliegenden Teil:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  E |  F |  ? |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  E |  F |    |
		|____|____|\\\\|\\\\|\\\\|____|

		Fig. 24b Blittata zwischen überlappenden Rechtecken 

Jetzt kopieren wir die erste Zeile. Dabei überschreiben wir die zweite Zeile des
Quelle, aber da wir sie bereits kopiert haben, ist das kein Problem:

		 ____ ____ ____ ____ ____ ____
		|    |////|////|////|    |    |
		|    |  A |  B |  C |    |    |
		|____|////|////|////|____|____|		Rechteck Quelle=////
		|    |////|XXXX|XXXX|\\\\|    |
		|    |  D |  A |  B |  C |    |		Rechteck Ziel=\\\\
		|____|////|XXXX|XXXX|\\\\|____|
		|    |    |\\\\|\\\\|\\\\|    |		Rechteck gemeinsam=XXXX
		|    |    |  D |  E |  F |    |
		|____|____|\\\\|\\\\|\\\\|____|

		Fig. 24c Blittata zwischen überlappenden Rechtecken


OK! Diesmal sind wir hier. Jetzt hat das Ziel das gleiche Aussehen wie die
Quelle, bevor Sie die Blittata gemacht haben.

Abschließend können wir also sagen, dass wenn wir eine Kopie mit überlappender
Quelle und Ziel machen, wenn die Quelle an Speicheradressen liegt die
größer als die Ziel-Speicheradressen ist, müssen Sie den Durchlauf in Gang setzen
normal (ASCENDING), wenn die Quelle stattdessen an Speicheradressen ist die
niedriger als  die Ziel-Speicheradressen ist muss der DISCENDING-Modus verwendet werden.

		               __________
		              /          \
		             |_________ _ |
		             / _______ \| |
		            | /  o_o  \ | |
		             \|  ___  |/\_|
		         _____|\/ = \/|_(_)__
		        /     |       |      \
		       /      |       |       \
		      /  _.    \_____/    __  _\_____
		  ___/__ |        o        | _\_     \____
		 /   \_ \|        o        |/ __\__|     /
		|     |) |\_______________/|\(__/  \_/__/__
		O==o==O_/|     ||__||      | / ____        \_
		| `-' |   \____||__||_____/ /   / _    ___   \
		| sk8 |    \             / (   / (_)\/ \      |
		| .-. |     |_____Y_____|   \       / \/     /
		O==o==O   __|     |    _|_   |           '   )
		|     |  / ``     |    '' \  (              /
		 \___/  (_________|________)  \_____________)

An dieser Stelle können wir im Detail den absteigenden Weg hinuntergehen.
Zuerst muss der absteigende Modus durch ein Steuerbit aktiviert werden.
Dies ist Bit 1 des BLTCON1-Registers, das, wenn es auf 1 gesetzt ist, den Descending-Modus aktiviert.
Während wenn es zurückgesetzt ist, (wie wir es bisher getan haben), den Ascending-Modus aktivieren.

Wie wir bereits gesagt haben, geht der Blitter bei Descending "runterwärts"
das heißt, er bewegt sich zu den Speicherorten einer niedrigeren Adressen.
Dazu müssen die Zeiger der DMA-Kanäle zu Beginn der Blittata auf das Wort der Blittata zeigen,
das die höchste Adresse hat, das ist das erste Wort.
Es ist, wie Sie wissen, das Wort weiter unten und am weitesten rechts vom Rechteck von Wörtern. (die gemischt werden.)

Zum Beispiel, wenn Sie ein 3 Wörter breites und 2 Zeilen hohes Rechteck blitten möchten,
müssen die Zeiger mit der Adresse des dritten Wortes der zweiten Zeile des Rechtecks initialisiert werden,
welches in in der Figur mit zwei Sternchen (**) angegeben ist.

		 ____ ____ ____ ____ _ _ _ _ _ _ ____
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |
		|____|____|____|____|			|____|
		|    |\\\\|\\\\|\\\\|			|    |
		|    |\\\\|\\\\|\\\\|			|    |
		|____|\\\\|\\\\|\\\\|			|____|
		|    |\\\\|\\\\|\\\\|			|    |
		|    |\\\\|\\\\| ** |			|    |
		|____|\\\\|\\\\|\\\\|			|____|
		|    |    |    |    |			|    |
		|    |    |    |    |	        |    |
		|____|____|____|____|			|____|
		|									 |
		|									 |

		Fig. 25 Word-Rechteck mit hervorgehobenem Wort
				welches auf den Anfang der Blittata zeigt 

Um die Adresse dieses Wortes zu berechnen, folgen wir einem ähnliche Ansatz wie
wir es im ascending-Mode erledigt haben. 
Wir müssen den Abstand (Offset) dieses Wortes vom Anfang der Bitebene berechnen. 
Angenommen, wir kennen die Xa - und Ya - Koordinaten der
Pixel oben links vom Rechteck, und auch die Breite L in Worten
und die Höhe A des Rechtecks. Das Wort, an dem wir interessiert sind, gehört zur letzten
Reihe des Rechtecks, das die Yb = Ya + A-Koordinate hat. Der Offset des ersten Wortes von
dieser Zeile ist durch folgende Formel gegeben:

OFFSET_Y = 2 * (Yb * ANZAHL_WORDS_PRO_REIHE) im Normalfall und

OFFSET_Y = 2 * (Yb * ANZAHL_WORDS_PRO_REIHE * ANZAHL_BITPLANES) im interleaved Fall.

Jetzt müssen wir den Abstand zwischen dem ersten Wort der Zeile und dem letzten Wort des 
Rechtecks berechnen. Wie wir wissen, ist diese Entfernung durch 2 * (Xa / 16) gegeben.

Auf der anderen Seite gibt es zwischen dem ersten und dem letzten Wort des Rechtecks ​​L-1 Worte, die
gleichbedeutend mit einer Entfernung (ausgedrückt in Bytes) von 2 * (L-1) sind .
Addieren Sie die 2 Unterschiede, die wir haben:

Offset_x = 2 * (Xa / 16 + L-1).


	|    |				|    |\\\\|\\\\|	|\\\\|
	|  A |				|    |  B |\\\\|	|  C |
	|____|_ _			|____|\\\\|\\\\|_ _	|\\\\|

	\____________________/\______________________/
		|			|
	    Xa/16 words		   L words

	Abstand zwischen Wort A und Wort B = 2*(Xa/16)
	Abstand zwischen Wort A und Wort B = 2*(L-1)

		Fig. 26 Berechnung OFFSET_X
	

Daher ist die in den DMA-Kanalzeigern zu schreibende Adresse gegeben durch:

ADDRESS_WORD = ADDRESS_BITPLANE + OFFSET_Y + OFFSET_X.

Was die Modulo und die Größe der Blittata betrifft, gibt es keine
Unterschiede mit dem ascending Mode. Sie werden alle mit denselben Formeln berechnet.
Jetzt können wir endlich 2 rechteckige überlappende Regionen erfolgreich kopieren,
auch wenn die Quelle bei einer kleineren Speicheradresse als die von dem des Ziel beginnt:
Es ist das Beispiel 9l3s.s.

In absteigender Reihenfolge verhalten sich die Masken und die Verschiebung unterschiedlich
in Bezug auf den aufsteigenden Modus.
Die Masken funktionieren immer auf die gleiche Weise, aber sie ändern die Wörter, zu denen Sie gehören.

Die in BLTAFWM enthaltene Maske wird wie beim aufsteigenden (ascending) Fall 
zum ersten Wort in jeder Zeile angewendet.
Da wir jedoch im Gegenteil absteigen (descending), ist das erste Wort das
Wort ganz rechts auf der rechten Seite des Rechtecks, während es im aufsteigenden (ascending) 
Modus das Wort ganz links ist.
Auf die gleiche Weise wird immer die in BLTALWM enthaltene Maske bei einem blittata
auf das letzte Wort jeder Zeile angewendet, nur im absteigenden (descending) Fall
ist es das Wort auf der linken Seite. 
Zusammenfassend:

- Im aufsteigenden (normalen) Modus BLTAFWM wird auf das Wort ganz links angewendet
  und BLTALWM zu dem Wort auf der rechten Seite.

- Absteigend gilt BLTAFWM für das Wort rechts und BLTALWM
  zu dem Wort auf der linken Seite. 

Wenn wir uns das Bild ansehen, erscheint auf dem Video der Wechsel in den descending Modus.
Die Masken tauschen die Spalten aus, auf denen sie arbeiten.

Um es zu überprüfen, laden und führen Sie das Beispiel lesson9m1.s aus.  
Es führt exakt die gleichen Dinge aus wie Lektion 9h1.s, nur das es descending (absteigend) arbeitet.
Sie werden sehen, dass die Masken die gleichen Effekte verursachen, aber durch den Austausch der Spalten.
Die Verschiebung in (descending) absteigender Reihenfolge zeigt einen grundlegenden Unterschied: 
Es ist getan (entgegen) nach LINKS anstatt nach rechts. 

Wenn wir einen Shift-Wert von zum Beispiel 2 angeben, wird die Quelle um 2 Pixel nach LINKS geshiftet.
Wenn wir diese Eigenschaften nutzen können wir den Scrolleffekt "Bild nach links scrollen" erreichen. 

Sie finden es im Beispiel lesson9m2.s.

An diesem Punkt können wir schließlich einen der klassischen Effekt von Demos erzielen:
der SCROLLTEXT, das ist ein Text der auf dem Bildschirm von rechts nach links scrollt.

Ein einfaches aber bedeutendes Beispiel ist die Lektion 9n1.s, in der Sie alle Erklärungen finden werden.
Ich empfehle dieses Beispiel gut zu studieren, weil zu wissen wie man einen
Scrolltext macht ist absolut notwendig für einen Demo-Coder!

Im Beispiel Lektion9n2.s finden Sie den Scrolltext der Diskette intro1.


	                                      .-%%%-,
	                                     (       )
	                                   (         )
	              -~x~-               (          )
	            /%     %\           (           )
	           |         |         (           )
	           |         |        (           )
	           |     __ _,       (%%%%-(     )
	          /\/\  (. ).)       `_'_', (   )
	           C       __)       (.( .)-(  )
	           |   /%%%  \      (_      ( )
	           /   \ %===='    /_____/` D)
	         /`-_   `---'         \     |
	    .__|%-/~\-%|_/_   |~~~~~~~||    |
	   __.         ||/.\  |       |OooooO
	   \           ---. \ |       |      \ _
	  _-    ,`_'_'  .%\  \|__   __|-____  / )
	 <     -(. ).)   > \  ( .\ (. )     \(_/ )
	  %-       _) \_- ooo @  (_)  @      \(_//.
	 / /_C (-.____)  /((O)/       \     ._/\%_.
	/   |_\     /   / /\\\\`-----''    _|>o<  |__
	|     \ooooO   (  \ \\ \\___/     \ `_'_',  /
	 \     \__-|    \  `)\\-~\\ ~--.  /_(.(.)- _\
	  \   \ )  |-`--.`--=\-\ /-//_  '  ( c     D\
	   \_\_)   |-___/   / \ V /.% \/\\\ (@)___/ %|
	  /        |       /   | |.  /`\\_/\/   /   /
	 /         |      (   C`-'` /  |  \/   (/  /
	/_________-        \  `C__-%   |  /    (/ /
	     | | |          \__________|  \     (/

Hast du verstanden, wie der Scrolltext funktioniert? Wenn die Antwort bejahend ist,
können sie damit beginnen, mit dem Gelernten zufrieden zu sein. Inzwischen kennen 
Sie die Grundfunktionen des Blitters. In der nächsten Lektion werden wir die
verborgensten Geheimnisse dieses mächtigen Freundes entdecken.  
Dem am Schwierigsten zu verstehen, mit dem wir es da zu hatten
in dieser Lektion, aber wir haben immer vermieden haben:
die Funktionsweise der MINTERMS!*/