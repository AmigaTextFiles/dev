                             .      :  .
                           ¦.:.:.:..::.::.¦
                           |::··    _____:!
                           |  _____  ____ |
                          _!  '____ |    ||
                         / __ |    ||    ||
                         \ /\ `--°-'`-°--'| xCz
    _ __ _________________)\ \____C¯  l___l___________________ __ _
                            ¯¯    `---'
		ASSEMBLERKURS - LEKTION 10
    - -- ----------------------------------------------------- -- -
In dieser Lektion lernen wir die Verwendung der fortschrittlichsten Funktionen 
des Blitters kennen.

*******************************************************************************
*				MINTERMS				      *
*******************************************************************************

In Lektion 9 haben wir gesagt, dass der Blitter uns erlaubt mit verschiedenen  
Arten von Operationen zu spielen. Wir haben auch gesagt, dass die Art der 	   
Operation definiert wird durch die MINTERMS, welche die Bits 0 bis 7 des 	   
BLTCON0-Registers sind, d.h. das Low-Byte (genannt LF - Logic Function Byte)   
dieses Registers. Abhängig vom Wert, der in diese Bits geschrieben wird, 	   
ändert es die vom Blitter ausgeführte Operation.
Zum Beispiel wissen wir, dass zum Löschen des Speichers das LF-Byte auf den    
Wert $00 gesetzt sein muss, während wenn von Kanal A nach Kanal D kopiert 	   
werden soll es den Wert $f0 haben muss. Diese Werte wurden nicht zufällig von  
den Blitter-Designern gewählt, sondern sie folgen einer sehr genauen Logik, die
wir jetzt erklären werden. Zunächst weisen wir darauf hin, dass die 
Operationen, die vom Blitter ausgeführt werden können, LOGISCHE Operationen,   
d.h. NICHT, UND und ODER sind, die Sie jetzt gut kennen sollten.
(In Wirklichkeit gibt es noch jemanden, der arithmetische Operationen durch-   
führen kann. Wir werden vielleicht auf der nächsten Disk darüber reden!).	   
Der Blitter kann auch mehrere Operationen dieses Typs in einer einzelnen 	   
Blittata kombinieren. Aber lass uns der Reihe nach gehen.
Wie Sie wissen, hat der Blitter 3 Eingangskanäle und einen Ausgangskanal. Für  
den Moment mach dir keine Gedanken über das Aktivieren oder Deaktivieren von   
Kanälen. Ein Blitt ist eine logische Operation, die 3 Eingabewerte über die    
3 Kanäle A, B, C benötigt und ein Ergebnis über den Kanal D erzeugt. Wie bei   
allen logischen Operationen wird dieses Bit-zu-Bit durchgeführt, auch wenn der 
Blitter immer Wörter liest (und schreibt), genau wie 68000 mit einer logischen 
UND-Anweisung.

Daher wird jedes Bit des Ausgabewortes basierend auf den Werten der 		   
korrespondierenden Bits der Eingabewörter berechnet. Die 3 Bits in der Eingabe 
können 8 verschiedene Kombinationen führen. Eine Blitter-Operation wird		   
definiert, indem für jeden möglichen Fall eine Feststellung getroffen wird, in
Kombination von Eingangsbits, wenn das Ausgangsergebnis 0 oder 1 ist.		   
In der Praxis kommt jeder der 8 Minterms (Bits 0 bis 7 von BLTCON0) in		   
Verbindung mit einer anderen Kombination von Eingangsbits; Wenn der Minterm    
den Wert 0 hat, bedeutet es, dass die Eingangskombination 0 ergibt, falls 	   
es stattdessen den Wert 1 hat, wird das Ergebnis eine 1 sein.

Dies kann mit einer Wahrheitstabelle angezeigt werden, wie unten gezeigt.	   
Die drei Quellkanäle sind aufgelistet und die möglichen Werte für ein einzelnes
Bit von jedem. Als nächstes folgt das Bit, das jeder Kombination zugeordnet    
ist.

	A	B	C	 	Position BLTCON0
	-	-	-	    -----------------
						
	0	0	0			0
						
	0	0	1			1
						
	0	1	0			2
						
	0	1	1		 	3
						
	1	0	0			4
						
	1	0	1			5
						
	1	1	0			6

	1	1	1			7

		Fig. 27	MINTERMS
		
Zum Beispiel, wenn wir möchten, dass ein Blitt eine Ausgabe von 1 erzeugt,     
wenn am Eingang A=0, B=1 und C=0 ist und in allen anderen Fällen gleich 0,	   
müssen wir den Minterm 2 auf 1 und all die anderen Minterms auf null setzen.   
Wir schreiben dann den Wert $04 in das LF-Byte. Für ein anderes Beispiel wird  
der Wert $80 (= 1000.0000 binary) in die LF Bits geschrieben, wenn das Ziel auf
1 gesetzt werden soll, wenn die entsprechenden Bits der Quellen A, B und C alle
auf 1 gesetzt sind.
Alle anderen Bits im Ziel, mit denen die andere Kombinationen für A, B und C   
übereinstimmen werden auf Null gesetzt. Dies liegt daran, da die Bits 6 bis 0  
des LF-Bytes den Wert 0 annehmen. Natürlich ist es möglich, mehr als einen     
Minterm gleichzeitig auf 1 zu setzen. Zum Beispiel, wenn wir LF auf $ 42 setzen
(= 0100.0010 in binär) schalten wir 2 Minterms ein.

Also mit diesem Wert werden wir eine Ausgabe von 1 in 2 Fällen haben: im Fall  
A=0, B=0 und C=1 (entspricht Bit 1 von LF) und im Fall A=1, B=1 und C=0		   
(entspricht Bit 6 von LF). In den anderen Fällen haben wir eine Ausgabe von 0. 
Versuchen wir nun, die Bedeutung der Werte unserer Minterme die zum Löschen und
Kopierenzu verwendet werden zu verstehen. Im Falle einer Löschung haben Sie    
LF = $00.
Alle Minterms haben den Wert 0. Dies bedeutet, dass für jede Kombination der   
Quellkanäle immer eine 0 ausgegeben wird. In der Praxis schreiben wir immer,   
egal was wir lesen, eine 0, d.h. wir löschen. (Tatsächlich lesen wir während   
der Löschung nichts, weil wir die Kanäle A, B und C nicht aktivieren, aber wir 
müssen immer noch LF = $00 eintragen, warum erklären wir später). Um (sagen wir
mal) eine Kopie von A nach D zu machen, schreiben wir LF = $F0 (=% 1111.0000). 
Auf diese Weise ist die Ausgabe 1 in entsprechend 4 verschiedene Kombinationen,
während in den restlichen 4 Kombinationen der Wert 0 ist.
Wie du in der Abb. 27 lesen kannst, werden die Kombinationen, die den Minterms 
entsprechen auf 1 gesetzt. Das sind alle möglichen Kombinationen mit A = 1. In 
gleicher Weise werden die Kombinationen, die den Minterms nicht entsprechen    
auf 0 gesetzt. Es sind diejenigen mit A = 0. 
Dies bedeutet, dass jedes Mal, wenn A=1 ist, der Ausgang 1 ist und wenn statt- 
dessen A = 0 ist, ist die Ausgabe 0, unabhängig von dem Wert von B und von C.  
In der Praxis nimmt also der Ausgang den gleichen Wert wie der Kanal A an, und 
daher ist es die genaue Kopie. 
Wenn wir stattdessen von Kanal B zu Kanal D kopieren wollten, müssen wir einen 
anderen LF-Wert verwenden und die Minterms auf 1 setzen bei den die Kombina-   
tionen mit B = 1 sind. (Das sind , wie wir in Abb. 27 lesen, die Minterme 2,3, 
6 und 7) und setzen sie. Die anderen Minterms 0,1,4 und 5 sind zurückgesetzt   
und Sie erhalten LF = $CC (=%11001100).
Durch entsprechende Programmierung der Minterms können viele Operationen mit   
den Blitter ausgeführt werden. Angenommen, Sie möchten alle Pixel in einem     
Rechteck auf 1 setzen (in der Praxis die umgekehrte Operation der Löschung, die
stattdessen alle Bits auf 0 setzt). Für die Löschung verwenden wir nur den Aus-
gabekanal. Was wir wollen ist, dass die Ausgabe immer 1 ist, für jede Kombina- 
tion von den Eingängen. Um dieses Ergebnis zu erhalten, setzen wir alle Min-   
terms auf 1 und erhalten LF = $FF.

Sie können dies im Beispiel lesson10a1.s sehen.
In der Beispiel-Lektion 10a2.s zeigen wir stattdessen die NOT-Operation.

Wir verweisen auf die Auflistung für die Erklärung.

	     ______                                ______
	    (:::::\`~-.     ___   /|\   ___    .-~ /:::::)
	     `\:::::\  `\  __\\\\|||||////__ /'  /:::::/'
	       `\-::::\_ `\.\\\\\|||||////./' _/::::-/'
	         `--..__`\/    \\\\|////   \/ __..--'
	                >' .--. `\   /'.--. `<
	         _...--/ -<    |      |    >- \--..._
	    /    \         `\()|      |()/'         /    \
	  /||     `\|  ____. `          ' .____  |/'     ||\
	 /|||       | ' `\       /::\       /' ` |       |||\
	|||||\    .---. __|_.  /::::::\  ._|__ .---.    /|||||
	|||||||-._|_   `-._  /::::::::::\  _.-'   _|_.-|||||||
	 \|||||||||||      /::/' |::| `\::\      |||||||||||/
	  \||||||||||     /::/   |::|   \::\     ||||||||||/
	   `\||||||||\   (:::`---'::`---':::)   /||||||||/'
	        /     `-._`-.::::::::::::.-'_.-'     \
	       |              .________.              |
	       |                                      |
	       |                                      |
	       |                                      |
	        \                                    /
	        `\                                /'
	           `~-.________________________.-~'


Kommen wir nun zu einem Beispiel für eine 2-Operanden-Operation, zum Beispiel  
das ODER. Wir wollen, dass der Ausgang dem OR der Kanäle A und B entspricht. Im
Rückblick auf die Wahrheitstabelle des OR verstehen wir, dass die Ausgabe den  
Wert 1 in allen Fällen, in denen A = 1 und in allen Fällen, in denen B = 1 ist 
sein muss. Wie Sie aus Abb. 27 sehen, gibt es insgesamt 6 Fälle, bei denen die 
Bedingung gilt (bei LF = $FC).

Die Beispiellektion 10b1.s zeigt eine OR-Operation, während das Beispiel
lesson10b2.s eine UND-Operation ausführt.

Eine andere Möglichkeit, das LF-Byte zu berechnen, das eine bestimmte Operation
ausführt, ist durch die Verwendung des Venn-Diagramm:


		     ______  0 ______
		    /	   \  /      \
		   /	    \/	      \
		  /	        /\	       \
		 /   A	   /  \     B	\
		|    -	  |    |    -	 |
		|	      |  6 |	     |
		|	 4    |____| 2	     |
		|	     /|    |\	     |
		|	    / |  7 | \	     |
		 \     /   \  /   \	    /
		  \   /  5  \/  3  \   /
		   \ |	    /\	    | /
		    \|_____/  \_____|/
		     |		        |
		     |	    1	    |
		     |		        |
		      \		       /
		       \     C	  /
		        \    -   /
		         \______/


		Fig. 28	Venn-Diagramm

Wir veranschaulichen die Verwendung dieses Diagramms anhand einiger Beispiele. 

1. Um eine Funktion auszuwählen D = A (d.h. Ziel = nur Quelle A),
   Wählen Sie nur die Minterms aus, die im Kreis A vollständig enthalten sind  
   Abbildung oben. Dies ist die Reihe der Minterms 7, 6, 5 und 4. Wenn sie als 
   eine Reihe mit 1 für die ausgewählten Minterms und mit 0 für die nicht      
   ausgewählten, geschrieben sind, wird der Wert zu:
   
		Anzahl Minterm		7 6 5 4 3 2 1 0
		Minterm ausgewählt	1 1 1 1 0 0 0 0
							---------------
							F   0       nämlich $F0

2. Um eine Kombinationsfunktion aus zwei Quellen auszuwählen, suchen Sie nach  
   Minterms von beiden Kreisen (deren Kreuzung). Zum Beispiel, die Kombination 
   A "UND" B wird durch den gemeinsamen Bereich der Kreise dargestellt A und B,
   d.h. Minterms 7 und 6.
   
		Anzahl Minterm		7 6 5 4 3 2 1 0
		Minterm ausgewählt	1 1 0 0 0 0 0 0
							---------------
							C   0       nämlich $C0
							
3. Um eine inverse Funktion zu verwenden, das "NOT" einer der Quellen, zB:     
   NICHT A
   nimm alle Minterms, die nicht in dem von A dargestellten Kreis enthalten    
   sind. In diesem Fall haben wir Minterms 0, 1, 2 und 3.
   
		Anzahl Minterm		7 6 5 4 3 2 1 0
		Minterm ausgewählt	0 0 0 0 1 1 1 1
							---------------
							0   F       nämlich $0F
							
4. Um MINTERMENS zu kombinieren, das ist ein ODER zwischen ihnen, machen Sie  
   ein OR der Werte. Zum Beispiel wird die Operation (A UND B) ODER (B und C) 
							
		Anzahl Minterm			7 6 5 4 3 2 1 0
		A AND B					1 1 0 0 0 0 0 0
		B AND C					1 0 0 0 1 0 0 0
								---------------
		(A AND B) OR (B AND C)	1 1 0 0 1 0 0 0
								---------------
								C   8       nämlich $C8

In jedem Fall, wenn Sie sich wirklich die Mühe ersparen wollen, zeigen wir 	   
Euch eine Tabelle der am häufigsten verwendeten Minterm-Werte.			
Diese Tabelle verwendet eine andere Notation als die bisher verwendete:

Wenn zwei Begriffe benachbart sind, wird ein AND zwischen ihnen gemacht
(z.B. bedeutet AB A und B);

Ein Bindestrich über einem Begriff zeigt NOT an:
      _
(z.B. A bedeutet NICHT A);

Wenn zwei Terme durch ein "+" getrennt sind, wird ein OR zwischen ihnen gemacht
(z.B. bedeutet A + B  A oder B);

UND hat die höchste Priorität, also ist AB + BC gleich (A UND B) ODER (B und C).
Hier ist die Tabelle:

	Operation	 Wert		Operation	 Wert
	ausgewählt	  LF		ausgewählt	  LF
	--------	-------		--------	-------
	D = A		 $F0		D = AB		 $C0
	    _					     _
	D = A		 $0F		D = AB		 $30
					            _
	D = B		 $CC		D = AB		 $0C
	    _				        __
	D = B		 $33		D = AB		 $03

	D = C		 $AA		D = BC		 $88
	    _				         _
	D = C		 $55		D = BC		 $44
					            _
	D = AC		 $A0	 	D = BC		 $22
	     _				        __
	D = AC		 $50		D = AC		 $11
	    _					         _
	D = AC		 $0A		D =  A + B	 $F3
	    _				         _	 _
	D = AC		 $05		D =  A + B	 $3F
					                 _
	D = A + B	 $FC		D =  A + C	 $F5
	    _				         _	 _
	D = A + B	 $CF		D =  A + C	 $5F
					                 _
	D = A + C	 $FA		D =  B + C	 $DD
	    _				         _	 _
	D = A + C	 $AF		D =  B + C	 $77
						               _
	D = B + C	 $EE		D =  AB + AC	 $CA
	    _
	D = B + C	 $BB


		Fig. 29	Minterms oft verwendet

HINWEIS: Um den gewünschten Wert von LF für Ihre Zwecke zu finden, können Sie  
auch das Dienstprogramm "minterm", das von Deftronic Trash'M'One programmiert  
wurde verwenden.
Das fragliche kurze Dienstprogramm kann auf dieser CD gefunden werden. Die     
Syntax ist folgende: Für das NOT, setzen Sie den Buchstaben des Kanals nicht   
verschoben in Kleinbuchstaben, zum Beispiel "abc".
Für den normalen Kanal wird der Shift-Buchstabe (Großbuchstabe) verwendet. Zwei
benachbarte Buchstaben bedeuten ein UND zwischen den Kanälen, wenn sie getrennt
sind bedeutet dies ein ODER ("+") zwischen den Kanälen.

						    __
Beispiel 1: wenn du willst ABC:

	minterm	Abc

	Ergebnis: $10

Beispiel 2: wenn Sie nur die Quelle möchten A:

	minterm	A

	Ergebnis: $F0	(wie du es beweisen wolltest)

Beispiel 3: wenn du nur willst(A AND B) OR C:

	minterm	AB+C

	Ergebnis: $DA.

	               ___________
	               \        _/___
	                \____________)
	                 |.  _  |
	                 |___/  |
	                 `------'
	                ./   _  \.
	             __ |___/ )  |
	            (__|_____/   |
	                |________|____.                  _ __ ____
	                   |  _)      |  - --- --- --- -(         )
	                   |  |----.  |        -- -    (  (  )     )
	                 __|  |    |__| _    - -- --      vrooom )  )
	             ___|_____|________/ | --- -- - ---( (    (    )
	            (____________________|              (____ _ __)
	             (_)              (_)

*******************************************************************************
*				DIE BOBS					      *
*******************************************************************************

Wir sind fast am Hauptkurs angekommen, den BOBs.
Bevor man sie anpackt, ist es notwendig, eine andere Idee zu präsentieren: die 
Masken-Bitebene. Es ist einfach eine Bitplane, die "den Schatten" von einer	   
Figur hat, das ist eine Bitebene mit der gleichen Dimensionen wie die Figur.   
Setze die Pixel auf 1, die den Pixeln der Figur entsprechen, die mit einer     
Farbe gefärbt sind, die sich vom Hintergrund unterscheidet, und setze die Pixel
auf 0, die der Hintergrundfarbe der Figur entsprechen.

Betrachten Sie zum Beispiel die folgende Zahlentabelle:


	0020
	0374
	5633
	0130

es stellt ein 8-farbiges Bild (3 Bit-Ebenen) 4 Pixel breit und 4 Linien hoch   
dar. Jede Zahl gibt die Farbe an, die dem Pixel zugeordnet ist. Die Maske davon
des Bildes ist wie folgt:

	0010
	0111
	1111
	0110
	
Wir beobachten, dass Farben außer 0 (der Hintergrund) mindestens eine Bit-Ebene
haben auf 1 gesetzt werden.

Daher kann die Maske ausgehend von der Figur konstruiert werden, indem das ODER
aller Bitebenen ausgeführt wird, so wie es in den Beispielen Lektion 10c1.s und
Lektion10c2.s dargestellt ist. Das erlaubt Ihnen auch, die Verwendung der 	   
logischen Operationen des Blitters zu überprüfen. Insbesondere in 
Lektion 10c2.s zeigen wir für die erste Zeit eine Blittata, die alle 4 Kanäle  
des Blitters verwendet.

Der Kefrens Converter hat jedoch eine Option zum automatischen Erstellen der   
Maske einer Figur. Maskenbitebenen sind nützlich, weil sie uns erlauben, einige
Teile eines Bildes anzuzeigen, basierend auf der Form eines anderen Bildes.    

Wir sehen Beispiele in Lektion 10c3.s und Lektion10c4.s, wo wir eine Maske ver-
wenden in Form eines Kreises, um einen Reflektor zu erzeugen, der ein Bild be- 
leuchtet um einen Teil sichtbar zu machen.

Die 2 Beispiele, obwohl sie den gleichen Effekt erzielen, verwenden viele      
Techniken anders, als wie in den Kommentaren erläutert. Studiere die Lektion   
sehr gut, was wichtig ist, um dann die BOBs zu verstehen.

In diesem Beispiel wird die Maskenbitebene zum Auswählen der Teile eines Bildes
von 5 Bitebenen verwendet. Die Auswahl wird getroffen, indem man eine Operation
von AND zwischen der Bitebenenmaske und den 5 Bit-Ebenen macht, die das Bild   
ausmachen. Da das Bild im normalen Format ist, werden 5 verschiedene Blittings 
gemacht, eine für jede Ebene. Die Maske ist natürlich immer die Gleiche für    
jede Blittata (wird von einer einzelnen Bitebene gebildet).

Möchten Sie die Technik der Beispiellektion 10c4.s auf einen Bildschirm im     
Interleaved-Format anwenden, stehen wir vor einem Problem. Wenn wir in diesem  
Format operieren, blitten wir alle Bitplanes gleichzeitig ab.

Aber die Maske hat die Größe einer Ebene, das kann nicht in einer Blittata	   
verwendet werden, wo die Dimension gleich der Anzahl der Ebenen ist aus denen  
das Bild zusammengesetzt ist.

Um dieses Problem zu lösen, müssen wir unsere Maske ändern. Da jede Zeile der  
Figur die Zeile auswählen muss, müssen wir die Zeile sooft wiederholen wie es  
Bitplanes gibt. Im interleaved Format müssen wir also eine Bitplane-Maske 	   
verwenden bei der jede Zeile so oft wiederholt wird, wie es Bitebenen der Figur
gibt.

Im Fall der Figur, die wir vorher gesehen haben (3 Ebenen) ist unsere ver-
schachtelte Maske wie folgt:


	0010\
	0010 |	- erste Zeile der normalen Maske dreimal wiederholt
	0010/
	0111
	0111
	0111
	1111
	1111
	1111
	0110
	0110
	0110

Wie Sie sehen können, müssen wir um die interleaved Maske zu bekommen, da das  
Bild aus 3 Bitplanes besteht, jede Zeile 3mal wiederholen. Das interleaved     
Format zwingt uns daher eine Maske zu verwenden, die mehr Speicher beansprucht 
als von der normale Größe angefordert wird.

Das Beispiel lesson10c5.s ist die Interleaved-Version von lesson10c4.s und dort
können sie sehen, was in der Praxis gesagt wurde.

		                 ___
		               _(   )_        
		            __( . .  .)__     
		          _(   _ .. ._ . )_   
		         ( . _/(_____)\_   )  
		        (_  // __ | __ \\ __) 
		        (__( \/ o\ /o \/ )__) 
		         ( .\_\__/ \__/_/. )  
		          \_/¬(_.   ._)¬\_/   
		           /___(     )___\    
		          ( |  |\___/|  | )   
		           ||__|  |  |__||    
		           ||::|__|__|::||    
		           ||:::::::::sc||    
		          .||:::__|__:;:||    
		          /|. __     __ .|\.  
		        ./(__..| .  .|.__) \. 
		        (______|. .. |______) 
		           /|  |_____|        
		                 /|\          
		                  :

Wenn Sie die Funktionsweise der Masken verstanden haben, sind Sie bereit für   
das Lösen des Hintergrundproblems mit den BOBS (ein für alle mal). Wie Sie sich
sicherlich erinnern, sind wir im Beispiel lesson9i3.s ziemlich nah an der      
Lösung des Problems gewesen. Der Hintergrund wird gespeichert und anschließend 
an seiner Stelle neu gestaltet. Das einzige Problem ist, das das umschließende 
Rechteck der Figur des BOBs den Hintergrund löscht und durch die Farbe 0 	   
ersetzt wird.
Wenn wir ein BOB zeichnen, verwenden wir die Farbe 0 und keine Farbe, aber ein-
fach nur um die Pixel des Rechtecks zu bezeichnen, die nicht zur BOB-Figur     
gehören. Es ist genau dasselbe, bei den Sprites wo wir die Farbe 0 als  
"transparent" verwenden.
Wenn wir das BOB auf dem Bildschirm zeichnen, möchten wir es in farbigen  	   
Pixeln. Mit der Farbe 0 erscheint der Hintergrund. In der Praxis sollten wir   
auf den Bildschirm nur Pixel einer anderen Farbe als 0 schreiben können.	   
Dies ist nicht möglich, weil, wie Sie wissen, der Blitter IMMER VOLLSTÄNDIGE   
Wörter schreibt (und liest).

Eine andere Strategie wird daher angenommen. Anstatt eine einfache Kopie des   
BOBs am Ziel zu machen, machen wir einen komplizierteren Blitt.
Wir lesen aus dem Speicher, neben dem BOB, auch den Hintergrund, und 
"vermischen" sie miteinander, so dass die Pixel des BOBs anstelle der 0 Pixel  
(vom BOB-Hintergrund) erscheinen, und wir schreiben das Ergebnis auf dem 	   
Bildschirm.
Die Strategie ist in der folgenden Abbildung dargestellt, in der wir ein BOB   
haben und ein 6 × 8-Pixel-Hintergrundstück.
Das Symbol "." stellt ein Pixel der Farbe 0 dar, das Symbol "#" repräsentiert  
ein Pixel vom BOB mit unterschiedlicher Farbe und das Symbol "o" repräsentiert 
ein Pixel vom Hintergrund. (der verschiedenen Farbe):

	BOB				Hintergrund

	........		...o....
	..####..		...oo...
	.#.##.#.		..oooo..
	..####..		..ooooo.
	...##...		.ooooooo
	..#..#..		oooooooo

	   \			   /
	    \			  /
	     \			 /  

	BOB überlagert auf HINTERGRUND
			...o....
			..####..
			.#o##o#.
			..####o.
			.oo##ooo
			oo#oo#oo


	Fig. 30	Bob und Hintergrund
	
Auf diese Weise erhalten wir den gewünschten Effekt.
Es bleibt zu verstehen, wie man das BOB mit dem Hintergrund "mischt". Um 	   
"richtig" zu mischen, müssen wir wissen, welche Pixel des BOB aus der Farbe 0  
und welche nicht bestehen. Diese Information ist in der Bitplanenmaske des BOB 
enthalten, die wie sie wissen, für jedes Pixel der Farbe 0 des BOB ein Bit     
auf 0 und für jedes Pixel einer anderen Farbe ein Bit auf 1 hat.
Der Mischvorgang läuft folgendermaßen ab:

- Für jedes Pixel lesen wir die Maske
- Wenn die Maske den Wert 1 hat, kopieren wir das entsprechende Pixel des BOB  
- Wenn die Maske den Wert 0 hat, kopieren wir das entsprechende Pixel des 	   
  Hintergrunds.
  
Wir können diesen Vorgang mit nur einer Blittata auf folgende Weise durchführen:
Wir lesen die Maske durch den Kanal A des Blitters, den BOB durch den Kanal B,  
für den Hintergrund durch den Kanal C, benutzen wir die Maske.
Wählen Sie die zu kopierenden Pixel (oder den Hintergrund oder das BOB) und    
schreiben Sie das Ergebnis in Kanal D (Kanalzuweisung ist nicht zufällig).	   
Die Auswahl erfolgt anhand der folgenden logischen Gleichung:

D = (A AND B) OR ( (NOT A) AND C)

Diese Gleichung verhält sich genau wie das oben beschriebene Auswahlverfahren. 
In der Tat, wenn die Maske A = 1 ist (d.h. wir haben ein BOB Pixel mit der     
Farbe anders als 0) vereinfacht sich die Gleichung in der folgenden Art und    
Weise:

D = (1 AND B) OR ( (NOT 1) AND C) = B OR (0 AND C) = B OR 0 = B

Dann wird das BOB-Pixel kopiert. Wenn stattdessen A = 0 ist (d.h. wir haben ein
Pixel des BOBs der Farbe 0), wird die Gleichung:

D = (0 AND B) OR ( (NOT 0) AND C) = 0 OR (1 AND C) = 0 OR C = C

Dann wird das Hintergrundpixel kopiert.
Diese logische Gleichung wird vom Blitter ausgeführt (wie sie selbst berechnen 
können) durch Setzen von LF = $CA, ein Wert bekannt als "COOKIE CUT" oder      
"Keks Ausschneiden". Wie wir bereits erwähnt haben, war die Kanalzuweisung	   
basierend auf den Eigenschaften der Kanäle selbst.							   
In der Tat, um eine horizontale flüssige Verschiebungen zu machen, ist es not- 
wendig für den BOB und für die Maske die Verschiebung des Blitters zu verwenden
und den Kanal C (welcher die Verschiebung nicht kann) wird für den Hintergrund 
zu verwenden. 
Im Weiteren wenden wir den Trick an, das letzte Wort der Bitebene zu maskieren,
so dass das letzte Wort zurückgesetzt wird, so dass es im letzten Wort kommt   
der Hintergrund wurde gemischt.

Die Beispiele lesson10d1.s und lesson10d1r.s zeigen (jeweils in Version normal 
und interleaved) den lang erwarteten BOB, der sich auf einem Hintergrund bewegt.

*******************************************************************************
*		 DIE GESCHWINDIGKEIT DES BLITTERS (UND NICHT NUR))			      	  *
*******************************************************************************

Es ist an der Zeit, sich mit einer sehr wichtigen Frage zu befassen: der	   
Geschwindigkeit des Blitters. In der Tat, wie Sie wissen, verwendet der Blitter
eine bestimmte Menge an Zeit, um seine Aufgaben zu erfüllen, und es ist not-   
wendig dies bei der Programmierung komplexer Effekte zu berücksichtigen. Um die
Geschwindigkeit des Blitters zu messen, verwenden wir eine sehr einfache 	   
Technik, bekannt als "copper monitor", der uns das Ergebnis in Echtzeit auf    
dem Bildschirm anzeigt.
Die Technik ist sehr einfach: Wir verwenden eine bestimmte Farbe (normalerweise
schwarz) als Hintergrund. Dann, kurz vor dem Start der Blittata, ändern Sie die
die Hintergrundfarbe mit dem Prozessor, über ein "MOVE.W #$xxx,$dff180". Wenn  
der Blitt endet, setzen wir den Hintergrund auf die Ausgangsfarbe zurück. Auf  
diese Weise wissen wir, dass der Blitt eine proportionale Zeit zu dem anders-  
farbigen Teil des Bildschirms benötigt.
Es sollte beachtet werden, dass diese Technik verwendet wird, um jede Art von  
Routine zu messen, und es ist besonders nützlich zu verstehen, wann es 		   
schneller oder langsamer wird nach einer Änderung, zum Beispiel einer 		   
Optimierung.

Ein Beispiel ist in Lektion 10e1.s gezeigt

In diesem Beispiel verwenden wir den Blitter, um ein Rechteck auf dem Bild-	   
schirm zu kopieren. Ausgehend von diesem Beispiel können wir einige Über-	   
legungen auf die Geschwindigkeit des Blitters anstellen. Vor allem, wie wir    
bereits erwähnt haben, die Geschwindigkeit hängt von der Größe der Blittata ab.
Versuchen Sie das Beispiel, ändern sie die Höhe und / oder Breite des Rechtecks
und du wirst es selbst erkennen.

Das ist normal, denn je größer das Rechteck ist, desto größer ist auch die     
Anzahl der zu bewegenden Wörter. Ebenso die Anzahl der Bitebenen beeinflusst   
die Geschwindigkeit. (Versuchen sie es in Lektion10e1.s, in dem die Anzahl der 
Iterationen der Routine "DisegnaOggetto" geändert wird.) Je mehr Bitplanes es  
gibt, je größer ist die Menge der zu verschiebenden Daten.

Das Beispiel lesson10e1r.s ist die Rawblitversion des vorherigen Beispiels.    

Wenn Sie es ausführen, werden Sie feststellen, dass es schneller ist, aber sehr
klein. Aber dann, fragen Sie, nach allen Vorteilen von RawBlit?
In der Realität, wie wir bereits gesagt haben, ist die Rawblit-Technik nicht   
praktisch, weil es den Blitter beschleunigt, sondern weil es dem Prozessor Zeit
spart.

In den 2 Beispielen, die wir bisher gesehen haben, haben wir nur die Zeit      
gemessen vom Blitter.

In den Beispielen lesson10e2.s und lesson10e2r.s verwenden wir stattdessen 	   
verschiedene Farben um sowohl die vom Blitter benötigte Zeit als auch die vom  
Prozessor anzuzeigen.

Der Vergleich zwischen diesen Beispielen zeigt uns die Vorteile des rawblit-   
Modus: mit dieser Technik wird der Prozessor sehr wenig verwendet, nur die Zeit
zum Laden der Blitter-Register, und dann ist er frei, um andere Aufgaben zu    
erledigen, anders als das was mit dem normalen Weg passiert, wo der Prozessor  
auf das Ende einer Blittata warten muss, um die nächste Blittata des Bitplane  
zu starten.

Es ist klar, um den Vorteil der Rawblit-Technik zu bekommen, das die Routine   
die der Blittata folgt nicht den Blitter benutzt. In der Tat, wenn (wie in den 
Beispielen gezeigt) es nach einer Blittata sofort eine Routine gibt, die den   
Blitter verwendet, muss der Prozessor immer noch darauf warten, bis der Blitter
seine Aufgabe beendet, und wir werden daher keinen Vorteil haben.
Ein Kriterium zur Optimierung der Programme ist also wenn möglich, Routinen,   
zu verwenden, die "entfernte" Blitteroperationen ausführen, d.h. durchsetzt mit
anderen Routinen, die es nicht benutzen, so das der Blitter und der Prozessor  
parallel ablaufen.
Es muss jedoch gesagt werden, dass dieses Kriterium vor allem auf Maschinen die
mit FAST Memory ausgestattet sind gilt, als ob der Prozessor auf den    	   
Speicher zugreifen muss. Beim Zugriff auf Speicher werden durch die Chips 	   
Konflikte generiert, über die wir besser in einem Moment sprechen werden.	   

Für den Moment bemerken wir noch etwas über die Beispiele lesson10e2.s und 	   
lesson10e2r.s:
Der Blitter braucht in etwa die gleiche Zeit für die Löschung (grüner Bild-	   
schirm) und für die Zeichnung (roter Bildschirm). Wenn Sie darüber nachdenken, 
sollte dies seltsam erscheinen: In der Tat ist es wahr, dass die 2 Blittos die 
gleiche Größe haben.
Beachten Sie jedoch, dass die Löschung eine Blittata ist, die nur einen Kanal  
verwendet, während die Kopie 2 verwendet. Es ist klar, dass, wenn die Zahl der 
Kanäle zunimmt, erhöht sich die Anzahl der Wörter die vom der Blitter gelesen  
und geschrieben werden, und dann sollte die Blittata mehr Zeit brauchen.

                      o    .  o  .  o .  o  .  o  .  o
                 o
              .
            .        ___
           _n_n_n____i_i ________ ______________ _++++++++++++++_
        *>(____________I I______I I____________I I______________I
          /ooOOOO OOOOoo  oo oooo oo          oo ooo          ooo
      ------------------------------------------------------------

Aber schau dir das Beispiel lesson10e3.s an.

Dieses Beispiel ähnelt dem vorherigen, aber es handelt sich nicht um eine ein- 
fache Kopie. Die Figur führt eine ODER-Operation zwischen der Figur und einer  
Null-Ebene durch. Natürlich ist der Effekt immer der gleiche, aber Sie können  
sehen, wie es jetzt ist, das durch die Routine, die einen 3-Kanal-Strahl 
(D = A OR B) es spürbar langsamer macht.
Die Geschwindigkeit hängt davon ab, welche und wie viele Kanäle auf einmal ge- 
nutzt werden. Dies ist recht kompliziert, was sich in der folgenden Tabelle    
zusammenfassen lässt:

    bit 8-11
       von      Kanäle 
    BLTCON0     benutzt		Speicherzugriffsfolge
   ---------    --------    --------------------------------------
       F        A B C D     A0 B0 C0 -  A1 B1 C1 D0 A2 B2 C2 D1 D2
       E        A B C       A0 B0 C0 A1 B1 C1 A2 B2 C2
       D        A B   D     A0 B0 -  A1 B1 D0 A2 B2 D1 -  D2
       C        A B         A0 B0 -  A1 B1 -  A2 B2
       B        A   C D     A0 C0 -  A1 C1 D0 A2 C2 D1 -  D2
       A        A   C       A0 C0 A1 C1 A2 C2
       9        A     D     A0 -  A1 D0 A2 D1 -  D2
       8        A           A0 -  A1 -  A2
       7          B C D     B0 C0 -  -  B1 C1 D0 -  B2 C2 D1 -  D2
       6          B C       B0 C0 -  B1 C1 -  B2 C2
       5          B   D     B0 -  -  B1 D0 -  B2 D1 -  D2
       4          B         B0 -  -  B1 -  -  B2
       3            C D     C0 -  -  C1 D0 -  C2 D1 -  D2
       2            C       C0 -  C1 -  C2
       1              D     D0 -  D1 -  D2
       0        niemand     -  -  -  -
	   
Diese Tabelle zeigt die Reihenfolge für jede Kombination der aktiven Kanäle	   
beim Zugriff auf den Speicher durch den Blitter. In diesem Fall einer Blittata 
von 3 Wörter.
Für jeden Zugriff wird der Kanal, der es trägt angezeigt, und die Bindestriche 
zeigen die Buszyklen an, der vom Blitter nicht genutzt wird. 
Zum Beispiel die Zeichenfolge:

A0 B0 -  A1 B1 -  A2 B2

Zeigt an, dass der Kanal A (A0), dann der B (B0), dann der Blitter, zuerst auf 
den Bus zugreift verwendet keinen Buszyklus (ermöglicht dem Prozessor den 	   
Zugriff auf die Speicher), tippen Sie dann zurück auf Kanal A (A1) und so 	   
weiter.

Die in der Realität gezeigte Tabelle ist nur indikativ, weil viele Faktoren    
nicht berücksichtigt werden, wie die Verwendung von speziellen Blittermodi und 
die Konkurrenz mit dem Prozessor und anderen DMA-Kanälen (siehe auch 		   
Lektion 8). Trotzdem ist es sehr nützlich, eine Vorstellung davon zu haben, was
die besten Kanalkombinationen sind? Beachten Sie, dass diese Tabelle  sich auf 
einen 3-Wörter-Blitt bezieht. Für mehr Blitting Wörter, wiederholt der Blitter 
die Sequenz von Zugriffen mehrmals, die in der Tabelle "in der Mitte" sind.    
Zum Beispiel ein 5-Wörter-Blitt mit den Kanälen A und D hat die folgende	   
Sequenz:

A0 -  A1 D0 A2 D1 A3 D2 A4 D3 A5 D4 -  D5

Das Studium der Tabelle erlaubt uns einige interessante Beobachtungen. Wenn wir
uns die Sequenz anschauen, die nur die Verwendung von Kanal D betrifft, sehen  
wir, dass der Blitter einen Ja- und einen Nein-Zyklus auf dem Bus verwendet. Im
Gegenteil, wenn sie die Kanäle A und D benutzten, nutzt der Blitter (außer in  
den Fällen des ersten und des letztes Wortes) alle Buszyklen.
Diese Tatsache erklärt warum, in den Beispielen für die Löschroutine (Kanal D) 
ungefähr die gleiche Geschwindigkeit wie die der Zeichenroutine (Kanäle A und  
D) brauchen. Beachten Sie jedoch, dass wenn wir eine Kopie von B nach D machen,
die Dinge anders sind.

Sie können es in der Praxis in Lektion 10e4.s sehen.

Ähnlich sehen wir in der Tabelle, dass im Fall von Blittings mit 2 Quellen 	   
sollten A und B oder A und C verwenden, aber nicht B und C, weil sie mehr      
Zyklen verschwendet.

Sie müssen jedoch daran denken, dass die Geschwindigkeit des Blitters auch von 
möglichen Konflikten durch die anderen DMA-Kanäle (Video, Audio, Cupfer, 	   
Prozessor) abhängt. Diese können Zyklen "stehlen", und damit es verzögern. 	   
In der Tat, wie wir es in der Lektion 8 erklärt haben, hat der Blitter im 	   
Buszugriff nur auf der CPU Priorität. Dies bedeutet, dass wenn ein anderes     
Gerät (z.B. Copper) auf den RAM gleichzeitig mit dem Blitter zugreifen möchte, 
hat das anderen Gerät Vorrang.

Der einzige Narr, der dem Blitter den Vorzug gibt, ist der Prozessor. Aber auch
hier ist die Priorität nicht vollständig. In der Tat der Blitter, ist von 	   
großer Großzügigkeit, wenn er den Prozessor 3 mal hintereinander bemerkt,	   
das er versucht, auf den Bus zuzugreifen, aber es gelang ihm nicht, weil 	   
jemand anderes den Vorrang hat, sagt er ihm: "Du gehst diesmal, vah" und 	   
gewährt ihm den Bus für einen Zyklus.
Dieser Mechanismus reduziert die Möglichkeit, dass in Fällen von DMA Über-	   
lastung, der Prozessor blockiert ist und  zu lange auf den Bus warten muss.	   
Es ist jedoch möglich, die Großzügigkeitsbewegungen des Blitters zu unter-	   
drücken. Setze Bit 10 auf 1 (genannt blitter_nasty, also schlechter Blitter)   
im DMACON Register. Der Blitter verhält sich nicht mehr so, und hat jetzt jedes
Mal Vorrang vor dem Prozessor.
Falls die Routinen unseres Programms den ganzen Blitter benutzen, also der	   
Prozessor lädt  nur die Register und geht in den Wartemodus, ist es besser,    
dieses Bit auf 1 zu setzen.
Offensichtlich macht dieser Diskurs Sinn, wenn das Programm im Speicherchip    
enthalten ist und in Abwesenheit von Caches, denn sonst wird es keine Konflikte
zwischen dem Prozessor und dem Blitter beim Zugriff auf den RAM geben.

Ein Beispiel für den Nasty Bit Blitter findet sich in Lektion 10e5.s.

Um den Gebrauch des Blitters zu maximieren, müssen Sie das Schreiben der damit 
verbundenen Register auf das Maximum beschleunigen.
In den Beispielen, die wir bisher gemacht haben und auch in dem, was wir in dem
Rest machen, um die Übersichtlichkeit zu erhöhen, haben wir das Schreiben der  
Register nicht optimiert, wie wir konnten.
Während einer Blittata sind die einzigen Register, die variieren, BLTxPT und   
die BLTSIZE. Die Register BLTCONx, BLTxMOD und BLTxWM bleiben konstant. Dies   
bedeutet, dass wenn der Inhalt dieser Register nicht durch andere Routinen ge- 
ändert wird, müssen Sie sie nicht am Anfang jeder Blittata neu schreiben.

Eine Vorsichtsmaßnahme, um die Routinen für den Fall zu optimieren, kann	  
in den Schleifen von Blittings, die Werte, die in die Blitter Register in den 
Registern des Prozessors zu schreiben getroffen werden. 
Ersetzen Sie innerhalb der Schleife das MOVE.W #YYY,$DFFxxx mit dem etwas     
schnellerem MOVE.W Dx,$DFFxxx. Diese Optimierungen beim Schreiben der Register
nahm eine sehr niedrige Geschwindigkeitsstufe, was mit dem Coppermonitor 	  
schwierig ist beachten. Aber in einer Demo mit vielen komplexen Effekten, 
zusammen haben die ihr Gewicht.

Schauen Sie sich als Beispiel das Listing lesson10e6.s an, das eine optimierte
Version der Lektion lesson10c3.s ist.

                                 \\\|///                            
                               \\  ~ ~  //
                                (  @ @  )
______________________________oOOo_(_)_oOOo____________________________________
*******************************************************************************
*			 DOUBLE BUFFERING				      *
*******************************************************************************

Alle Beispiele, die wir bisher zu Bobs gesehen haben, hatten immer nur ein Bob,
der sich auf dem Bildschirm bewegte. Versuchen wir jetzt, mehr Bobs zu setzen. 
Lasst uns zum Beispiel versuchen, die "falsche" Hintergrundtechnik anzuwenden: 
Lass uns eine Bitebene für den Hintergrund und 3 Ebenen wo die Bobs bewegt     
werden, benutzen.
Da sich alle Bobs auf den gleichen Bitebenen bewegen, werden wir sowieso etwas 
tun müssen. Zeichnen Sie sie mit der Bitplane-Mask-Technik.
Wir werden immer noch den Vorteil haben, den Hintergrund nicht zu speichern und
wiederherstellen zu müssen, weil die Bitebenen der Bobs anfänglich auf Null    
gesetzt sind. Es wird daher ausreichen, diese Ebenen bei jedem Frame vorher zu 
löschen, vor dem Neuzeichnen der Bobs in neuen Positionen.

Diese Technik wird im Beispiel lesson10f1.s angewendet.

Wenn Sie dieses Programm ausführen, werden Sie eine böse Überraschung haben:   
Die Bobs werden nur am unteren Rand des Bildschirms richtig gezeichnet, während
sie oben nicht korrekt gezeichnet werden. Wie kommt es?
Gibt es einen Fehler in unseren Routinen? Nein, unsere Routinen sind in 	   
Ordnung. Das Problem ist, dass sie zu langsam sind. Wie Sie wissen, während    
unser Programm ausgeführt wird, zeichnet der Elektronenstrahl das Bild auf den 
Bildschirm.
Um ein stabiles Bild erscheinen zu lassen, versuchen Sie den Bildschirm zu 	   
wechseln (d.h. Löschen, Zeichnen von Bobs, Linien usw.) während Vertical Blank,
das heißt in dem Zeitraum, in dem die Elektronenstrahl inaktiv ist.			   
Wenn wir aber viele Änderungen am Bildschirm vornehmen müssen, kann es		   
passieren, das unsere Routinen während des Vertical Blank nicht schnell genug  
sind, um ihre Arbeit zu machen. Genau das passiert in diesem Fall.
Die Anzahl der Bobs zu erhöhen, erhöht die Zeit, die benötigt wird, um sie zu  
zeichnen. Folglich ist dies während des vertical Blanks nicht mehr möglich.    
Das Ergebnis ist, dass manchmal die Bobs auf dem Bildschirm gezeichnet werden, 
nachdem der Elektronenstrahl diesen Teil des Bildschirms entwarf und dann  
werden die Bobs nicht angezeigt.
Da der Elektronenstrahl von oben nach unten geht, sind mehr Bobs erstellt und  
um so öfter passiert dies. Wenn Sie sich das Beispiel genau ansehen, sehen Sie,
dass der Bildschirmbereich in dem alle Bobs gut gezeichnet sind, wenn die 	   
Designroutinen ihre Arbeit beendet haben, dies wird angezeigt durch den 
Coppermonitor.
Die "Double-Buffering" -Technik erlaubt uns, dieses Problem zu lösen. Dies ist 
eine allgemeine Technik, die Sie mit jedem verwenden können, nicht nur mit 	   
Bobs. Insbesondere werden wir es für 3D-Routinen verwenden.
Diese Technik besteht aus zwei Bildschirmen (genauer Puffer genannt) statt nur 
einem.
Die zwei Puffer werden abwechselnd angezeigt, erst Bild eins und dann das 	   
andere Bild. Während einer der Puffer angezeigt wird, können wir frei auf dem  
Anderen zeichnen, ohne sich Gedanken um die Stabilität zu machen, da das Bild  
das angezeigt wird aus dem ersten Puffer kommt, welcher nicht geändert wird.   
Wenn das nächste Verical Blank auftritt, werden die 2 Puffer ausgetauscht. Was 
wir oben gezeichnet haben, wird angezeigt und zeigt die Änderungen, die wir    
gemacht haben, während der Puffer der vorher angezeigt war uns nun zur Ver-	   
fügung steht, um darauf zu zeichnen.
Durch Wiederholung des Austauschs bei jedem Vertical Blank haben wir immer 	   
einen verfügbar Puffer der nicht angezeigt wird, auf dem gezeichnet werden 	   
soll, ohne sich um den Elektronenstrahl zu kümmern. 
Dank dieser Technik ist, die einzige Zeitbegrenzung, das unsere Zeichen-	   
Routinen enden müssen, bevor der Elektronenstrahl das Ende des Bildschirms     
erreicht. Dies gibt uns eine Zeit gleich 1/50 Sekunde (in Pal, 1/60 in NTSC).  


               <>+<>                 //////      __v__        __\/__
   `\|||/      /---\     """""""    | _ - |     (_____)   .  / ^  _ \  .
    (q p)     | o o |   <^-@-@-^>  (| o O |)    .(O O),   |\| (o)(o) |/|(
_ooO_<_>_Ooo_ooO_U_Ooo_ooO__v__Ooo_ooO_u_Ooo_ooO__(_)__Ooa__oOO_()_OOo___
[_____}_____!____.}_____{_____|_____}_____i____.}_____!_____{_____}_____]
__.}____.|_____{_____!____.}_____|_____{.____}_____|_____}_____|_____!__
[_____{_____}_____|_____}_____i_____}_____|_____}_____i_____{_____}_____]
*******************************************************************************
*		VERWENDUNG VON BLITTERKANÄLEN NICHT AKTIVIERT			      *
*******************************************************************************

Es gibt Fälle, in denen es sinnvoll ist, auch an aktiven Blittata-Kanälen 	   
teilzunehmen. Um zu verstehen, was es bedeutet, müssen Sie noch etwas über den 
Blitter wissen. Wenn ein Eingangskanal (A, B oder C) aktiv ist, liest er Wörter
aus dem Speicher. Jedes Wort wird nach dem Lesen in ein spezielles Register    
kopiert, genannt Blitter-Datenregister.
Jeder Kanal hat sein eigenes Datenregister, in dessen Namen der Buchstabe 	   
erscheint, der den Kanal identifiziert: wir haben daher BLTADAT (Kanal A, 	   
$DFF074), BLTBDAT (Kanal B, $DFF072), BLTCDAT (Kanal C, $DFF070) und BLTDDAT   
(Kanal D $DFF000).
Das Wort aus dem Datenregister wird anschließend der Reihe nach mit den Wörtern
der anderen Kanäle durch Logik Operationen verknüpft und das Ergebnis in den   
Speicher durch den Kanal D geschrieben.
Nehmen wir ein Beispiel, um es gut zu verstehen. Betrachten Sie den Fall einer 
Blittata, die ein AND zwischen den Kanälen B und C durchführt.
Die folgenden Dinge passieren innerhalb des Blitters:

1 - Kanal B liest ein Wort und kopiert es in BLTBDAT
2 - Kanal C liest ein Wort und kopiert es in BLTCDAT
3 - Ein AND wird zwischen dem Inhalt von BLTBDAT und dem von BLTCDAT ausgeführt
4 - Das Ergebnis wird über Kanal D geschrieben
5 - Wiederholen Sie die Schritte 1 bis 4 für die folgenden Wörter.

In Wirklichkeit funktionieren die Dinge ein wenig anders, weil einige Opera-   
tionen parallel ausgeführt werden, um den Blitter zu beschleunigen, aber auf   
der logischen Ebene funktionieren die Dinge so, und das müssen wir wissen.	   
Was passiert, wenn ein Kanal deaktiviert ist? Natürlich wenn nichts aus dem    
Speicher geholt wird, dann wird das entsprechende BLTxDAT-Register auch nicht  
geändert.
Die Situation ist ähnlich der, wie wir sie in Lektion 7 für die Sprites gesehen
haben. Sprites haben auch DMA-Kanäle (SPRxPT-Register), die Daten kopieren und 
Einlesen von den Datenregistern (SPRxDAT). 
In einigen Anwendungen ist es jedoch sinnvoll, direkt in die Datenregister mit 
dem Prozessor (oder mit dem Copper) zu schreiben.
Betrachten wir nun die Nützlichkeit dieser Eigenschaft des Blitters. Betrachten
wir zum Beispiel den Fall, in dem wir eine Reihe von Speicherplätzen mit einem 
konstanten Wert füllen wollen, zum Beispiel zum Zeichnen eines nicht vollen    
Rechtecks, aber "gestreift", oder wie die Graphen sagen mit einem "Muster" auf 
den Screen. (Das ist ein Plot).
Wir können das Problem lösen, indem wir unser Rechteck in der Daten Sektion    
unseres Programms speichern und es mit dem Blitter kopieren, genau so, als ob  
es eine Figur wie die anderen wärer.
Eine bessere Lösung bietet jedoch die Möglichkeit durch Deaktivieren der 	   
Blitter-Kanäle.
Um das Problem zu lösen, können wir tatsächlich eine Kopie von Kanal A nach D  
machen, durch Halten Sie den Kanal A deaktiviert, und schreiben Sie das 	   
"Muster" in das Register BLTADAT. Auf diese Weise haben wir 2 Vorteile: Wir    
müssen nicht das Rechteck zwischen den Daten in unserem Programm speichern,    
sodass wir Speicher sparen und weil Kanal A ist deaktiviert machen wir weniger 
Speicherzugriffe, als wir tun würden in dem Fall einer normalen Kopie von A    
nach D. das gibt dem Prozessor zusätzlich die Möglichkeit auf den Speicher 
zuzugreifen.

Laden Sie lesson10g1.s, um diese Anwendung in der Praxis zu sehen.

Es ist möglich, diese Technik nicht nur für einfache Kopien eines konstanten   
Wertes anzuwenden, sondern auch in komplexeren logischen Operationen, in denen 
ein Operand konstant ist.

Finde 2 Beispiele in lesson10g2.s und lesson10g3.s.

			   .-----------.
			   |         ¬ |
			   |           |
			   |  ___      |
			  _j / __\     l_
			 /,_  /  \ __  _,\
			.\¬| /    \__¬ |¬/....
			  ¯l_\_o__/° )_|¯    :
			   /   ¯._.¯¯  \     :
			.--\_ -^---^- _/--.  :
			|   `---------'   |  :
			|   T    °    T   |  :
			|   `-.--.--.-'   | .:
			l_____|  |  l_____j
			   T  `--^--'  T
			   l___________|
			   /     _    T
			  /      T    | xCz
			 _\______|____l_
			(________X______)

*******************************************************************************
*			DAS NULL-FLAG UND KOLLISIONEN			      *
*******************************************************************************

Lasst uns das letzte Hardwarefeature des Blitters erklären!
Der Blitter hat ein Flag Namens Zero-Flag, das hat eine ähnliche Funktion wie  
das Prozessor-Null-Flag. Dieses Flag ist das Bit 13 des DMACONR-Registers. Wenn
eine Blittata ein ALLES NULL-Ergebnis produziert, wird das Null-Flag auf EIN   
gesetzt. Umgekehrt, wenn mindestens ein Bit in einem der Ergebniswörter den    
Wert 1 hat, wird das Zero-Flag auf den Wert 0 gesetzt.
Das Flag verhält sich auf diese Weise sogar in dem Fall, wenn das Ergebnis     
der Blittata NICHT in den Speicher geschrieben wird, das heißt, wenn Kanal D   
deaktiviert ist.
Diese Tatsache ist sehr nützlich, da sie uns hilft, Kollisionen zwischen einem 
Bob und einer Zeichnung auf dem Bildschirm zu erkennen. (die möglicherweise    
ein anderer Bob ist). Nehmen wir einmal an, wir arbeiten mit Einzelbitplane-   
Bildern.
Um Kollisionen zu erkennen, führen wir (mit dem Blitter) eine UND-Operation    
zwischen dem Bob und dem Teil des Bildschirms, auf dem der Bob positioniert    
werden soll durch, aber wir schreiben das Ergebnis nirgendwohin.
Dieser Test wird nur zum Testen der Kollision verwendet.
Was passiert, wenn wir ein UND ausführen? Wie Sie wissen ist das Ergebnis einer
UND-Verknüpfung zwischen 2 Bits nur 1, wenn beide Operandenbits 1 sind. In 	   
unserem Fall bedeutet dies, dass ein Bit des Ergebnisses NUR in diesem Fall den
Wert 1 sein kann wenn beim Bob ein Bit des Wertes 1 und ein Bit in der gleichen
Position des Wertbildes 1 zusammenfallen. Aber das bedeutet, dass solche Bits  
eine Kollision erzeugen.
Wenn also eine Kollision auftritt, wird mindestens ein Bit des Ergebnisses ein 
EINS Wert haben, und in Übereinstimmung damit nimmt das Zero-Flag den Wert     
NULL an. Umgekehrt, wenn keine Kollision auftritt, fallen keine Bits des Bob   
mit dem Hintergrund zusammen und und dann ist das AND IMMER NULL und daher     
nimmt das Zero Flag den Wert EINS an.
Die Zero-Flag kann uns also sagen, wenn es eine Kollision gibt und wenn nicht. 
Wenn wir mit Bildern mit mehren Bitplanes umgehen, sind die Dinge 
komplizierter, weil wie es passieren könnte, dass eine Kollision zwischen 2    
Pixeln unterschiedlicher Farben, die on der Ebenenbeziehung betrachtet werden, 
nicht übereinstimmen, auftritt.
Zum Beispiel, wenn eine Kollision auftritt zwischen einem Pixel der Farbe 1    
(Ebene 1 = 1 und alle anderen bei 0) und ein Pixel der Farbe 2 (Ebene 2 = 1 und
alle anderen bei 0) macht eine UND-Ebene eine Ebene, die immer das Ergebnis 0  
ist. In diesen Fällen ist es besser, die Maskenbitebene zu verwenden.

In der Tat haben sie ein Bit mit dem Wert 1 jedes Mal dann wenn das ent-	   
sprechende Pixel des Bobs eine andere Farbe als der Hintergrund hat. Wenn dann 
die UND-Verknüpfung zwischen der 2-Bitplane-Maske ausgeführt wird, werden alle 
Kollisionen erkannt, sowohl die Farbe der Pixel (es ist wie das Erkennen der   
Kollisionen zwischen dem "Schatten" der 2 Bobs, welches 1 Ebene sind).

Sie können ein Beispiel in lesson10h1.s sehen

			  \\ ,\\  /, ,,//
			   \\\\\X///////
			    \¬¯___  __/
			   _;=(  ©)(®_)
			  (, _ ¯T¯  \¬\
			   T /\ '   ,)/
			   |('/\_____/__
			   l_¯         ¬\
			    _T¯¯¯T¯¯¯¯¯¯¯
			 /¯¯¬l___¦¯¯¬\
			/___,  °  ,___\
			¯/¯/¯  °__T\¬\¯
			(  \___/ '\ \ \
			 \_________) \ \
			    l_____ \  \ \
			    / ___¬T¯   \ \
			   / _/ \ l_    ) \
			   \ ¬\  \  \  ())))
			  __\__\  \  )  ¯¯¯
			 (______)  \/\ xCz
			           / /
			          (_/

*******************************************************************************
*			   SINUSCROLL				      *
*******************************************************************************

Fast jeder weiß, was ein Sinus-Scroller ist.
Es ist ein Scrolltext, der, wenn er auf dem Bildschirm scrollt, steigt und     
fällt, um eine Sinuswelle zu bilden. Bevor Sie anfangen zu erklären, wie der   
Sinus-Scroller funktioniert, ist es in Ordnung, wir weisen Sie auf einige Dinge
hin.
Vor allem, Zeit. Ein Sinus-Scroller ist eine sehr langsame Routine. Ein guter  
Sinus-Scroller kann sogar mehr als ein Viertel der verfügbaren Zeit in einem   
Frame dauern. Für Systeme ohne Caches und schnellen Speicher (in der Praxis der
Amiga 500 und 600) ist es sehr nützlich, das BLITTER_NASTY-Flag auf 1 zu 	   
setzen, was dem Blitter die absolute Priorität gegenüber dem 68000 gibt um die 
die Leistung der Routine zu verbessern.
Außerdem müssen wir auch die "Qualität" des Sinus Scrollers bedenken, den wir  
bekommen wollen. Damit ist gemeint, wie viele Pixel in jeder Sinusposition dar-
gestellt werden sollen. Ein 1-Pixel-Sinus-Scroller ist der, der am Weichesten  
aussieht, aber auch mehr Zeit braucht.
Erwarten Sie keine Zeit für andere Effekte, wenn Sie einen Bildschirm nicht    
"double buffered" verwenden. Auf der anderen Seite erscheint ein 4-Pixel-Sinus-
Scroller bereits sehr "pixelloso". Aus diesem Grund werden wir zunächst 	   
erläutern, wie man einen 2-Pixel-Sinus-Scroller macht und dann die Variationen 
für die 1 und 4 Pixel-Versione gemacht werden.
Bist du ein bisschen verwirrt? Sehen wir uns ein Beispiel an, was das genau    
bedeutet als wir über die Qualität gesprochen haben.

Stellen Sie sich vor, dass die folgende Abbildung der Buchstabe A einer Bitmap-
Schriftart ist:

.**************.
****************
****************
******....******
*****......*****
****************
****************
****************
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
*****......*****
................

	Fig. 31 Buchstabe A


Ein "*" zeigt ein Bit an, das auf 1 gesetzt ist und ein "." zeigt ein Null-Bit 
an. Das Zeichen "A" wird angezeigt, wenn es horizontal gescrollt wird und      
immer mit in den Fontdaten gespeichert ist. In einem Sinus Scroller wollen wir 
das nicht. 
Wir wollen die Spalten des Pixels ändern, die den Charakter ausmachen, also    
nehmen sie unterschiedlich vertikale Positionen an, basierend auf den Werten   
einer Sinuswelle. In einem 1-Pixel-Sinus-Scroller nimmt jede Pixelspalte eine  
andere vertikale Position an. Stattdessen sind in einem 2-Pixel-Sinus-Scroller 
die Spalten der Pixel mit 2 zu 2 gekoppelt, und jedes Spaltenpaar nimmt eine   
Position die sich vertikal von anderen Paaren unterscheidet ein. Ein 1-Pixel-  
Sinus-Scroller deformiert das Zeichen A in der folgenden Art und Weise. Wie	   
dargestellt in der folgenden Abbildung.

 .
 **
 ***
 ****
 *****
 ******
 *******
 ********
 *********
 *****..***
 ******..***
 *******..***
 ********..***
 *****.***.****
 *****..***.****
 .****...*******.
  .***....*******
   .**.....******
    .*......*****
     .......*****
      ......*****
       .....*****
        ....*****
         ...*****
          ..*****
           .*****
            .****
             .***
              .**
 	       .*
 	        .


	Fig. 31 Buchstabe A durch einen 1-Pixel-Sinus-Scroller deformiert

Wie Sie sehen können, befindet sich jede Pixelspalte in einer anderen 		   
vertikalen Position von den anderen. Ein 2-Pixel-Sinus-Scroller führt dagegen  
zu folgendem Ergebnis:

 .*
 **
 ****
 ****
 ******
 ******
 ********
 ********
 *****.****
 ******..**
 ******..****
 ********..**
 *****.**..****
 *****.********
 *****...**.****.
 ..***...********
   ***.....******
   ..*.....******
     *......*****
     .......*****
       .....*****
       .....*****
         ...*****
         ...*****
           .*****
           ..****
             ****
             ..**
               **
 	       ..

	Fig. 32 Buchstabe A durch einen 2-Pixel-Sinus-Scroller deformiert

Wie Sie sehen können, haben Paare benachbarter Spalten dieselbe vertikale      
Position. In einem 4-Pixel-Sinus-Scroller, wie Sie vielleicht vermutet haben,  
sind die Pixelspalten in 4 zu 4 gruppiert und jede Gruppe nimmt eine andere    
Position ein.
Jetzt solltest du verstanden haben, was mit Sinus-Scroll von '1 Pixel' oder    
von '...' '2 Pixel' gemeint ist. Die Methode zum Erstellen eines Sinus 		   
Scrollers ist sehr einfach. Wir beginnen mit einer normalen Textscrollroutine, 
wie wir sie vorher gesehen haben.
Anstatt unseren Text auf dem sichtbaren Bildschirm zu zeichnen und zu scrollen,
machen wir es in einem Datenpuffer, der irgendwo im Speicher zugewiesen ist.   
Dieser Bildlaufpuffer ist niemals sichtbar.
Von diesem Puffer nehmen wir vertikale "Scheiben" von Scroller und wir kopieren
auf den sichtbaren Bildschirm. Jedes "Stück" wird an eine andere vertikale     
Position in der Basis zu den Werten der Sinuskurve kopiert.
Die Dicke der "Slices" bestimmt die Qualität des Sinus Scrollers. Wenn sie 1   
Pixel dick sind, haben wir einen 1 Pixel Sinus Scroller, wenn sie 2 Pixel dick 
sind haben wir eine 2-Pixel-Routine und so weiter.
Sehen wir uns genauer an, wie man die Kopie der "Scheiben" macht. Da die 	   
Scheiben sehr dünn sind, werden wir nur ein Wort breite Blittings machen. Um   
nur das Segment von Pixeln (d.h. nur die Spalten) innerhalb des Wortes 	       
auszuwählen, die uns interessieren, werden wir eines der Maskenregister von    
Kanal A benutzen. (Dies bedeutet, dass wir verpflichtet sind, Kanal A zum Lesen
zu verwenden) mit dem wir alle Spalten von Pixeln löschen können, die nicht    
Teil der Scheibe davon sind, die uns interessiert.
Natürlich variiert der Wert der Maske entsprechend der "Scheibe" vom Lesen.    
Schreiben, wie wir schon gesagt haben, geschieht jedesmal an einer anderen 	   
vertikalen Position. Wenn wir schreiben, reicht es nicht, eine einfache Kopie  
von A nach D zu machen. Wenn wir es so machen würden, kopieren wir eine 	   
"Scheibe" und wir würden einen Teil der zuvor kopierten "Slices" löschen, die  
dazugehören zu dem gleichen Wort wie die aktuelle "Scheibe".
In der Tat, auch wenn die anderen "Scheiben" sich nicht mit unseren über-	   
schneiden (weil sie nebeneinander sind), da unsere Blittata ein Wort breit ist,
würden wir auch mit einer einfachen Kopie die Pixelspalten auf dem Bildschirm  
kopieren die durch die Maske auf Null gesetzt sind, und neben dem aktuellen 
"Slice" liegen.
Um dieses Problem zu lösen, machen wir ein ODER zwischen unserem Wort und dem  
Hintergrund auf die wir es schreiben. Auf diese Weise werden die nullten Pixel 
des aktuellen Worts angezeigt. Sie überschreiben nicht die im Hintergrund.     
Um den Sinus-Scroller zu realisieren reicht es aus den Puffer auf den Bild-    
schirm zu kopieren. Mit diesem Verfahren scrollt der gesamte Scrolltext einen  
"Slice" nach dem Anderen. Offensichtlich muss die ganze Prozedur in jedem Frame
wiederholt werden, weil der Scrolltext verschoben wurde und jedes Mal, bevor   
es gemacht wird, ist es notwendig, den Bildschirm abzubrechen.
Beachten Sie, dass je größer die Amplitude der Sinuskurve ist, je größer ist   
die Fläche vom Bildschirm die an der Operation beteiligt ist, (und dass wir    
jedes Mal abbrechen müssen.)
Daher ist es besser, eine kleine Sinus zu verwenden, um die Leistung zu 	   
verbessern.

In Lektion 10i1.s und Lektion10i2.s finden Sie jeweils einen Sinus-Scroller    
von 2 Pixel und 1 von 1 Pixel.

		           /#\    ...
		          /   \  :   :
		         / /\  \c o o ø
		        /%/  \  (  ^  )    /)OO
		       (  u  / __\ O / \   \)(/
		       UUU_ ( /)  `-'`  \  /%/
		        /  \| /   <  :\  )/ /
		       /  . \::.   >.( \ ' /
		      /  /\   '::./|. ) \#/
		     /  /  \    ': ). )
		 __ û%,/    \   / (.  )
		(  \% /     /  /  ) .'
		 \_ò /     /  /   `:'
		  \_/     /  /
		         /\./
		        /.%
		       / %
		      (  %
		       \ ~\
		        \__)

*******************************************************************************
*				ANIMATION				      *
*******************************************************************************

Wir beenden die Lektion mit einer kurzen Erklärung, wie Sie Animationen mit dem
Blitter	erstellen können. Eine Animation besteht aus einer Reihe von Bildern  (
Frames) die in einer bestimmten Reihenfolge angezeigt werden müssen. 
Normalerweise ändert sich zwischen den einzelnen Bildern nicht das ganze Bild, 
sondern nur das Teil von einem Bild.
Zum Beispiel könnten wir eine Burg mit Fahnen haben, die sich wegen dem Wind   
bewegen. Offensichtlich ist es nur der Teil des Bildschirms, auf dem die 	   
Flaggen gezeichnet sind, die zwischen einem Frame und einem anderen Frame 	   
wechseln. 
Um Speicher zu sparen, ist es nicht praktisch, alle Bilder zu speichern.	   
Animation: merke dir einfach das erste Bild und dann die "Teile" der anderen   
Bilder, die die Unterschiede zum ersten enthalten. Auf diese Weise, um die     
Animation zu erstellen, kopiere einfach die neuen "Stücke" vom Bild auf die    
Alten.
Zu diesem Zweck ist der Blitter sehr nützlich, da wie Sie wissen, er viel      
schneller als der 68000 (Basis) beim Kopieren von Daten ist. Um eine Animation 
erstellen zu können, müssen Sie mit dem Blitter, den wir jetzt beherrschen.    
Animationen können in zwei Typen unterteilt werden, je nachdem, wie es ist     
strukturierte die Reihenfolge der Frames.
In den Animationen des ersten Typs, der sogenannten "zyklischen" Animationen,  
werden die Frames nacheinander gemäß einer vorbestimmten Reihenfolge gezeichnet
und angezeigt. Nachdem die letzte gezeichnet wurde, beginnt die Animation 	   
erneut von erster Bild.
Auch in den Animationen des zweiten Typs ("Forward-Back" -Animationen) werden  
Frames basierend auf einer Reihenfolge gezeichnet. Wie auch immer, nachdem das 
letzte Bild gezeichnet wird, fährt die Animation fort, die Bilder neu zu       
zeichnen in umgekehrter Reihenfolge, vom Vorletzten bis zum Ersten. An diesem  
Punkt läuft die Animation erneut in der direkten Reihenfolge ab und dann 	   
zuletzt, wieder in umgekehrter Reihenfolge und so weiter.
Abhängig von der Art der Animation müssen Sie eine andere Verwaltungsroutine   
für den Rahmen verwenden.

Wir präsentieren 2 Beispiele von Animationen (eine für jeden Typ) in den 	   
Lektionen lesson10l1.s und lesson10l2.s.

Es ist auch möglich, animierte Bobs zu machen. Das sind Bobs, die sich jedes   
Mal ändern, wenn sie gezeichnet werden. Natürlich haben wir auch für die Bobs  
eine Reihe von Frames zur Verfügung, welche basierend auf einer der 2 Techniken
über die wir uns vorher unterhalten haben sequentiell präsentiert werden.	   
Jedes Mal, wenn der Bob gezogen werden muss, müssen wir eine andere Figur	   
verwenden. Es ist daher sehr praktisch, eine universelle Routine zu haben, die 
fähig ist eine Figur von variabler Größe (wie ein Bob) zu zeichnen.

Im Beispiel finden Sie eine solche Routine für Bildschirme im normalen Format  
lection10m1.s und für Bildschirme im Format INTERAVED im Beispiel lesson10m2.s.

		            .
		           .¦.¦:.:¦:.:¦
		          .;/'____  `;l
		          ;/ /   ¬\  __\
		          / /    ° \/o¬\\
		         /  \______/\__//
		        / ____       \  \
		        \ \   \    ,  )  \
		        /\ \   \_________/
		       /    \   l_l_|/ /
		      /    \ \      / /
		   __/    _/\ \/\__/ /
		  / ¬`----'¯¯\______/
		 /  __      __ \
		/   /        T  \

****************************************************************************** 
*			SPEZIAL MODIS DES BLITTERS			     *
****************************************************************************** 

Zusätzlich zu allen bisher beschriebenen Funktionen hat der Blitter auch die   
Möglichkeit, Linien zu zeichnen und Bereiche zu "füllen" um alle Bits einer    
gegebenen Region einer Bitebene auf 1 zu setzen.
Diese zusätzlichen Eigenschaften werden durch spezielle Modis von Operationen  
des Blitters erzielt.

Wir fangen an, über das Ziehen von Linien zu sprechen. Wenn der Blitter in der 
der Linienverfolgung arbeitet ("Linienmodus" genannt) zeichnet er eine Linie   
von einem Punkt des Bildschirms (den wir P1 nennen) zu einem anderen (den wir  
P2 nennen). Wir bezeichnen mit X1 und Y1, jeweils die Abszisse und die Ordinate
von P1, und mit X2 und Y2 die Abszisse und die Ordinate von P2. Im "line-mode" 
arbeiten viele Register völlig anders als das, was wir bisher gesehen haben und
es ist notwendig, sie angemessen zu setzen. Einige Einstellungen hängen von der
Position von P1 und P2 ab. Vor der Beschreibung der Verwendung der Registern   
ist es notwendig Vorüberlegungen zu treffen.

Während der Verfolgung betrachtet der Blitter den in "Oktanten" unterteilten   
Bildschirm verglichen mit Punkt P1. Zum besseren Verständnis sehen Sie sich die
folgende Abbildung an:

					 |
					 |
		    \  (2)   |  (1)   /
		     \ 	     |       /
		      \   3  |  1   /
		       \     |     /
				\    |    /
		(3)      \   |   /       (0)
				  \  |  /
		    7      \ | /     6
		       	    \|/
		-------------*-------------
					/|\
		    5      / | \     4
				  /  |  \
		(4)      /   |   \       (7)
				/    |    \
		       /     |     \
		      /   2  |  0   \
		     / 	     |       \
		    /  (5)   |  (6)   \
			         |
			         |


	Fig. 1 Oktanten
	

In der Abbildung repräsentiert das Sternchen (*) den Punkt P1. Der Blitter 	   
berücksichtigt, das der Bildschirm in die 8 Regionen (Oktanten genannt) 	   
unterteilt wurde , die in der Abbildung dargestellt sind.		               
Die zu verfolgende Linie gehört zu einem der Oktanten, zu dem P2 gehört. Die   
Zahlen in Klammern dienen zur Nummerierung der Oktanten nach einer Notation,   
die normalerweise von uns "menschlich" benutzt wird (d.h. gegen den Uhrzeiger- 
sinn). Der Blitter nummeriert sie stattdessen auf eine etwas merkwürdige Weise,
die durch Zahlen ohne Klammern angezeigt wird. Dies Bildschirmaufteilung werden
wir unten berücksichtigen.

Wir müssen auch einige Mengen definieren, die wir verwenden müssen, um die	   
blittata vorzubereiten. Wir nennen DiffX die Differenz zwischen den Abszissen  
von P2 und P1, geändert Vorzeichen negativ falls es so ist, so dass es immer   
noch positiv ist. In der Formel setzen wir:

DiffX = abs (X2 - X1)

Dabei steht "abs" für die Funktion, die den absoluten Wert einer Zahl		   
berechnet. Wir machen dasselbe mit den Ordinaten, indem wir

DiffY = abs (Y2 - Y1).

An dieser Stelle definieren wir DX und DY jeweils als Maximum und Minimum 	   
zwischen DiffX und DiffY. In den Formeln:

DX = max (diffX, diffY)
DY = min (diffX, diffY).

Fangen wir an zu sehen, wie die Blitter-Register gesetzt sind, beginnend mit   
BLTCON1, mit dem Sie den Line-Modus aktivieren können. Bit 0 von BLTCON1 dient 
genau für diesen Zweck. Bei 1 ist der Linienmodus aktiviert. Bit 1 erlaubt es  
Ihnen, "spezielle" Linien zu zeichnen, die die nächsten 
Füllen von Blitterbereichen erlauben. 
Wir werden später darüber reden, denn jetzt werden wir es bei 0 (normale 	   
Linien) verlassen. In den Bits 2,3 und 4 ist die Oktantenzahl in der der Punkt 
P2 ist einzutragen. Natürlich müssen wir die Nummerierung des Blitters         
verwenden. Um die normale Nummerierung gegen den Uhrzeigersinn in die vom 	   
Blitter verwendeten zu konvertieren können Sie die folgende Tabelle verwenden: 

Wert Bit von BLTCON1	Nummer Oktant
	---------------------	 --------------
		4 3 2
		- - -
		1 1 0			0
		0 0 1			1
		0 1 1			2
		1 1 1			3
		1 0 1			4
		0 1 0			5
		0 0 0			6
		1 0 0			7

		
Bit 6 von BLTCON1 (SIGN-Bit genannt) muss auf 1 gesetzt werden, in dem Fall,   
wenn 4 * DY-2 * DX <0. Andernfalls (d.h. wenn 4 * DY-2 * DX> 0) sollte es auf 0
gesetzt werden.
Die Bits 12 bis 15 von BLTCON1 enthalten die Startposition des "Patterns" der  
Linie. In der Tat ist es möglich, nicht nur "feste" Linien, sondern auch 	   
gestrichelte Linien zu zeichnen, durch ein "Muster", das sich entlang des      
ganzen Linie wiederholt. (Wir haben bereits Beispiele für Muster in Lektion 9  
gesehen). Die Bits von 12 bis 15 von BLTCON1 geben das Pixel an, aus dem das   
Muster ist. Natürlich (wir haben nur 4 Bits) muss es eines der ersten 16 Pixel 
der Linie sein.
Alle anderen Bits von BLTCON1 müssen auf 0 belassen werden. Wir kommen jetzt zu
BLTCON0. Mit dem niederwertigen Byte dieses Registers (LF, das von minterms)   
können Sie 2 verschiedene Zeichenmodi auswählen. Beim Platzieren von LF = $4A  
wird eine OR-exklusive Operation zwischen der Zeile und dem Hintergrund auf dem
es kommt ausgeführte. In der Praxis sind die Pixel, die von der Linie gekreuzt 
werden, invertiert. Wenn Sie stattdessen LF = $CA setzen, wird eine einfache   
ODER-Operation zwischen der Zeile und dem Hintergrund ausgeführt. In der Praxis
sind die Pixel, die von der Linie gekreuzt werden, eingeschaltet.
Die für die Blittata zu aktivierenden Kanäle sind A, C und D. Dann  müsen die  
Bits 8,9 und 11 auf 1 gesetzt werden, während 10 auf 0 ist.
Die Bits 12 bis 15 von BLTCON0 müssen stattdessen die 4 niedrigstwertigen Bits 
enthalten (d.h. niedriger) als X1, die Abszisse von Punkt P1. Glücklicherweise 
sind die Einstellungen der anderen Register einfacher. Die Register BLTAFWM und
BLTALWM müssen auf den Wert $FFFF gesetzt werden (sie maskieren nichts).
Das BLTADAT-Register muss den Wert $8000 enthalten, der den Wert des Pixels zum
Zeichnen darstellt. Das BLTBDAT-Register enthält stattdessen das "Muster" der  
Linie, auf die wir bereits hingewiesen haben. Ein $FFFF-Wert zeichnet eine     
Linie weiter.
In der Linienverfolgung wird nur der untere Teil von BLTAPT verwendet, d.h. nur
das 16-Bit-BLTAPTL-Register, das auf den Wert 4 * DY-2 * DX gesetzt werden 	   
muss. Das BLTAMOD-Register muss dagegen auf den Wert 4 * DY-4 * DX gesetzt 	   
werden. Das BLTBMOD-Register muss auf den Wert 4 * DY gesetzt werden. Die 	   
BLTCPT- und BLTDPT-Register müssen die Wortadresse des Bildschirm enthalten,   
den das Pixel P1 hat.
Die Register BLTCMOD und BLTDMOD müssen die Breite des Bildschirms enthalten   
ausgedrückt in Bytes. Schließlich muss das BLTSIZE-Register gesetzt werden um  
ein 2 Wörter breiter Blitt und eine Anzahl von Zeilen, die DX + 1 entsprechen  
zu leisten. Das bedeutet, dass die Bits 0 bis 5 die Nummer 2 enthalten müssen, 
während die Bit 6 bis 15 den Wert DX + 1 enthalten. Wie es normalerweise 	   
passiert, schreibt man in das Register BLTSIZE aktiviert es den Blitter. Aus   
diesem Grund muss in dieses Register zuletzt geschrieben werden.

Zusammenfassend sind die Werte, die in die Register geladen werden sollen:
BLTADAT = $8000
BLTBDAT = Muster Linie ($FFFF für eine durchgezogene Linie)

BLTAFWM = $FFFF
BLTALWM = $FFFF

BLTAMOD = 4 * (dy - dx)
BLTBMOD = 4 * dy
BLTCMOD = Breite der Bitplane in Byte
BLTDMOD = Breite der Bitplane in Byte

BLTAPT = (4 * dy) - (2 * dx)
BLTBPT = nicht benutzt
BLTCPT = Zeiger auf das Wort, das das erste Pixel der Zeile enthält
BLTDPT = Zeiger auf das Wort, das das erste Pixel der Zeile enthält

BLTCON0 Bit 15-12 = die 4 niedrigsten Bits von X1
BLTCON0 Bit 11 (SRCA), 9 (SRCC), und 8 (SRCD) = 1
BLTCON0 Bit 10 (SRCB) = 0
BLTCON0 LF Byte  = $4A (pro Zeile in EOR)
			     = $CA (pro Zeile in OR)

BLTCON1 bit 0 = 1
BLTCON1 bit 4-2 = Oktantenzahl (aus der Tabelle)
BLTCON1 bit 15-12 = Bit Initial für Linienmuster 
BLTCON1 bit 6 = 1 wenn (4 * dy) - (2 * dx)) < 0
			  = 0 andernfalls
BLTCON1 bit 1 = 0 (für normale Linien)
			  = 1 (für spezielle Linien für die Füllung)

BLTSIZE bit 15-6 = dx + 1
BLTSIZE bit 5-0 = 2

Ein Beispiel für die Linienverfolgung ist in Lektion 10n.s. enthalten. Dies ist
höchstens eine vereinfachte Routine ohne Optimierungen um das Verständnis auf  
Kosten der Geschwindigkeit zu erleichtern.

Flächenfüllmodus

Zusätzlich zum Kopieren von Daten kann der Blitter gleichzeitig eine Füll-	   
operation während des Kopierens ausführen. Dieser Modus kann aktiviert werden  
mit jeder Standard Blittata (Copa, UND, ODER, etc.) und wird durchgeführt NACH 
all den anderen Operationen, die Sie bereits kennen (Verschiebung, Maskierung  
usw.).
Um zu verstehen, wie die Füllung funktioniert, stellen Sie sich vor, dass der  
Blitter zu einem Zeitpunkt ein Bit schreibt (ausgibt) (was falsch ist, wie du  
weißt, weil es immer ein Wort nach dem anderen schreibt) und führt eine 	   
einfache Kopieroperation durch. Solange er Bit 0 liest, kopiert er sie normal. 
An einem bestimmten Punkt habe ich ein Wert von 1 Bit, der es gleich in die    
Ausgabe kopiert, aber von diesem Moment beginnt er, anstatt die folgenden Bits 
weiter zu kopieren, senden Sie alle Bits den Wert 1 in die Ausgabe.
Wenn jedoch ein zweites Bit vom Wert 1 gelesen wird, wird das normales 		   
Verhalten fortgesetzt. Wenn er dann ein drittes Bit von Wert 1 liest, beginnt  
er erneut 1 auszusenden, bis zu der nächsten 1 in der Eingabe, und so weiter.  
Lassen Sie uns sehen in einem Beispiel ansehen, was mit den kopierten Daten    
passiert mit einer Folge von eingehenden Bits und die entsprechende Ausgabe:

Eingang 	000100010010010001000001000110010010
Ausgang		000111110011110001111111000110011110

In der Praxis werden die Bits vom Wert 1 als die Kanten des Bereichs 		   
betrachtet. Der Blitter füllt die Bits, die in den Kanten enthalten sind (d.h. 
setzt sie zu 1). Sehen wir uns nun die technischen Details des Füllmodus an.   
Wie wir bereits gesagt haben, kann es in Kombination mit einer beliebigen 	   
Blittata verwendet werden, da das Füllen nach den Daten holen aus den 3 Quellen
und ihrer logischen Verknüpfung ausgeweählt durch die minterms erfolgt.		   
Der Füllmodus kann jedoch nur mit Sperren verwendet werden, die im absteigenden
Weg sind. (descending Mode).

Es gibt zwei verschiedene Arten von Füllungen, die als inklusiv und exklusiv   
bezeichnet werden. Jeder fill-Typ hat sein eigenes Aktivierungsbit. Um den     
Füllmodus zu aktivieren, müssen Sie eines der 2 Freigabebits auf 1 setzen.	   
Es ist nicht möglich gleichzeitig die 2 verschiedenen Fill-Modes zu aktivieren.
Wir sehen die Unterschiede zwischen den 2 Arten der Füllung.
Der inklusive Füllmodus füllt zwischen den Zeilen und lässt sie intakt.		   
Der exklusive Weg füllt zwischen den Zeilen, verlässt aber immer noch die      
rechte Begrenzung der Linie, lösche die linke.
Die exklusive Füllung erzeugt also Formen, die mit einem schmaleren Pixel	   
gefüllt sind als gleiches Muster (Kontur) gefüllt mit inklusive Füllung.       

Zum Beispiel das Muster:

	00100100-00011000

gefüllt mit inklusive Füllung, produziert:

	00111100-00011000

mit exklusiver Füllung wäre das Ergebnis:

	00011100-00001000

(Natürlich werden Füllungen immer mit vollen 16-Bit-Wörtern erstellt.)

Nehmen wir ein anderes Beispiel anhand von Zeichnungen:

inklusive Füllung:

		  zuerst			  nach der inklusiven Füllung
	 _______________________     _______________________
	|						|	|						|
	|						|	|						|
	|   1   1      1   1	|	|   11111      11111	|
	|    1  1		1  1	|	|    1111		1111	|
	|     1 1	 	 1 1	|	|     111		 111	|
	|      11	 	  11	|	|      11	  	  11	|
	|     1 1	 	 1 1	|	|     111	 	 111	|
	|    1  1		1  1	|	|    1111		1111	|
	|   1   1      1   1	|	|   11111      11111	|
	|						|	|						|
	|_______________________|	|_______________________|


exklusive Füllung:

		  zuerst			  nach der exklusiven Füllung
	 _______________________	 _______________________
	|						|	|						|
	|						|	|						|
	|   1   1      1   1	|	|    1111       1111	|
	|    1  1       1  1	|	|     111	 	 111	|
	|     1 1		 1 1	|	|      11	  	  11	|
	|      11	 	  11	|	|       1	  	   1	|
	|     1 1	 	 1 1	|	|      11	 	  11	|
	|    1  1       1  1	|	|     111		 111	|
	|   1   1      1   1	|	|    1111       1111	|
	|						|	|						|
	|_______________________|	|_______________________|


Wie Sie sehen können, wurden die Linien mit der exklusiven Füllung links von   
der Figur gelöscht. Auf diese Weise werden wir Figuren mit mehr scharfen Kanten
erhalten. Das Freigabebit für die inklusive Füllung ist Bit 3 von BLTCON1,     
während es für die exklusiven Füllung das Bit 4 ist, wiederum von BLTCON1.     
Es gibt ein weiteres Bit, das zur Steuerung der Füllung dient. Dies ist Bit 2  
von BLTCON1 (FILL_CARRYIN genannt), das, wenn es gesetzt ist, erzwingen Sie die
Füllung der Bereiche außerhalb der Linien, anstatt die der Inneren. Gehen wir  
zurück zum ersten Beispiel, das wir gemacht haben und sehen, was passiert wenn 
das Bit FILL_CARRYIN auf 1 gesetzt ist.
Die Startlinie war:

	00100100-00011000


mit inklusiven füllen und FILL_CARRYIN = 1 wäre die Ausgabe:

	11100111-11111111

Bei äußerer Füllung und FILL_CARRYIN = 1 würde die Ausgabe wie folgt lauten:

	11100011-11110111

Mal sehen, was im Fall des zweiten Beispiels mit inclusive fill und
FILL_CARRYIN = 1 passiert.


		  prima				  dopo
	 _______________________ 	 _______________________
	|						|	|						|
	|						|	|						|
	|   1   1      1   1	|	| 111   1111111   11	|
	|    1  1		1  1	|	| 1111  11111111  11	|
	|     1 1	 	 1 1	|	| 11111 111111111 11	|
	|      11	  	  11	|	| 111111111111111111	|
	|     1 1		 1 1	|	| 11111 111111111 11	|
	|    1  1		1  1	|	| 1111  11111111  11	|
	|   1   1      1   1	|	| 111   1111111   11	|
	|						|	|						|
	|_______________________|	|_______________________|

			fill inclusive mit Bit FCI = 1
			
Der Füllmodus wird hauptsächlich zum Füllen von Polygonen verwendet. Die Kanten
der Polygone werden mit dem Blitter-Line-Modus geplottet. Ein sehr einfaches   
erstes Beispiel wird in der Lektion10o.s gezeigt, in der die verschiedenen     
Arten der Füllung illustriert sind.
Wenn der zu füllende Bereich von Linien begrenzt wird, die eine Neigung von    
weniger als 45 Grad aufweisen, entsteht ein Problem. In diesem Fall passiert   
tatsächlich, dass eine Linie die aus Pixeln besteht, welche in derselben Zeile 
des Bildschirms horizontal nebeneinander liegen können. 
Die Situation wird durch die folgende Abbildung in denen die Sternchen (*) 	   
Pixel mit Wert 1 darstellen gezeigt.


 		  *
 		  *
		 *		Linie mit einem Gefälle von> 45 Grad
		*
		*


 		    *
 		  **
		**		Linie mit einer Neigung <von 45 Grad
	       *
	     **

Wie Sie sehen können, wenn eine Linie eine Neigung von mehr als 45 Grad hat,   
passiert es nie, dass 2 seiner Pixel nebeneinander in der gleichen Zeile des   
Bildschirms platziert sind. Im Gegensatz dazu geschieht dies, wenn die Steigung
der Linie weniger als 45 Grad beträgt. Diese Tatsache schafft das Problem in   
der Füllung. In der Tat, wenn der Blitter während des Füllens auf 2 Pixel 	   
auf derselben Zeile nebeneinander trifft, betrachtet er sie als 2 
unterschiedliche Kanten und füllt daher nicht die Pixel, die auf der rechten   
Seite der Linie gefunden werden. 
Im Listing lektion10p.s finden Sie ein Beispiel für dieses Problem.			   
Um dieses Problem zu überwinden, haben die Designer des Blitters uns einen 	   
speziellen Linienverfolgungsmodus gegeben (den wir vorher erwähnten), der 	   
Linien erzeugt, die nur ein Pixel für jede horizontale Reihe haben.			   
Klar, wenn Sie eine Linie in dieser Art zeichnen dann die Füllung zu machen, es
wird dir "fragmentiert" gehören.

Im Listing lektion10q.s finden Sie die Lösung für das Problem von lektion10p.s.

In der Beispiel Lektion 10r.s versuchen wir ein geschlossenes Polygon welches  
durch viele Linien gebildet ist, zu zeichnen und zu füllen. Wir stellen fest,  
dass es auch hier ein kleines Problem gibt. Das Problem rührt von der Tatsache 
her, dass die Ecken des Polygons ein Linien Paar sind. Wenn wir Linien im 	   
EOR-Modus zeichnen, invertieren wir die Pixel des Hintergrunds. Die Ecken 	   
werden zweimal invertiert und dann am Ende auf Null gesetzt.
Also gibt es ein "Loch" in der Kante des Polygons, womit die Füllung schlecht  
ausgeführt wird. Wenn wir stattdessen die Linien im OR-Modus zeichnen, bleiben 
die Scheitelpunkte auf dem Wert 1. Dies schafft Probleme mit Vertices auf und  
ab, wie sie von der Linie zu der sie gehören isoliert sind und deshalb beginnt 
die Füllung von ihnen aber sie endet nie. 

Beachten Sie zum besseren Verständnis die folgende Abbildung niedriger Gipfel:

	*        *		
	 *     *		Vor dem FÜLLEN
	  *  *
	   *

	   ^
	   +---- Scheitelpunkt am unteren Rand


	**********		
	 *******		Nach dem FILL
	  ****
************

	   ^
	   +---- Scheitelpunkt am unteren Rand
	   
	   

Wie Sie auf der Linie sehen können, wo der letzte Eckpunkt liegt, endet die      
Füllung nicht, weil kein weiterer Pixel auf 1 gesetzt ist, der als Kante links   
fungiert. Bei Linien im EOR-Modus tritt dieses Problem nicht auf, weil der 	     
Scheitelpunkt auf Null gesetzt ist (d.h. aufgrund des Phänomens, das uns Probleme
für die Zwischengipfel verursacht).
Kurz, in jedem Fall gibt es immer einen Gipfel, der uns die Füllung kaputt macht!
Lasst uns sehen, wie wir aus den Schwierigkeiten herauskommen. Zeichnen Sie die  
Linien im EOR-Modus, um das Problem der hohen und niedrigen Ecken zu beseitigen. 
Wir machen es auch in der Art, das wir die Linien immer von oben nach unten und  
zeichnen und vorher das erste Pixel (mit einem BCHG) invertieren und zeichnen. 	 

Auf diese Weise wird dieses Pixel 2 Mal invertiert (durch das BCHG und dann durch
die Blittata) und wird daher unverändert resultieren. Auf diese Weise ist das    
Problem gelöst. In der Tat (seit wir die Punkte geordnet haben) wird jeder 		 
Zwischenknoten einmal als letztes Pixel einer Zeile (und wird daher auf 1        
gesetzt) gezeichnet und einmal als erstes Pixel der anderen Zeile (und bleibt 	 
daher unverändert, dann bei 1).

Diese Technik wird im Beispiel lesson10s.s vorgestellt

Gehen wir nun zurück zur Behandlung von Linien, um eine Besonderheit zu zeigen.  
Es ist möglich, Linien 2 Pixel breit zu zeichnen, einfach durch das Ändern des   
Initialisierungswerts von BLTBDAT. Die Technik wird veranschaulicht im Beispiel  
Lektion10t1.s. In der Beispiel-Lektion 10t2.s wird stattdessen eine Linienver-   
folgungsroutine dargestellt, die besser ist als die bisher verwendete. 		     
Tatsächlich nutzt die Routine viele optimierte  Funktionen des 68000 Assemblers  
für die Berechnung und das Laden der Blitter-Register.
	   
                    /\\    ____  ,^-o,
        _a' /(   <.    `-,'    `-';~~
     ~~ _}\ \(  _  )     ',-'~`../     ,         \         .'"v"'.
           \(._(.)'      `^^    `^^  .:/          \ /\     = 'm' =
          ._> _>.   |\__/|        ,,///;,   ,;/   ( )      " \|/ "--_o
      @..@          /     \      o:::::::;;///  .( o ).   /m"..."m\
     (\--/)        /_.~ ~,_\    >::::::::;;\\\       _,/
    (.>__<.)          \@/        ''\\\\\'" ';\      <__ \_.---.
    ^^^  ^^^    A___A               ';\     _          \_  /   \
          ____ / o o \      O\   /O      .-/ )-""".      \)\ /\.\
       _/~____   =^= /       O>!<O     oP __/_)_(  )*      //   \\
      <______>__m_m_>        o   o      "(__/ (___/      ,/'     `\_,
       _____                                              _____
    oo/><><>\    ()-()                       ((((     ~..~     \9
   ( -)><><><>   (o o)      AMIGA RULEZ     ( )(:[    (oo)_____/
     L|_|L|_|'   /\o/\                      ((((        WW  WW
          _                   ,--,      ___
        ('v')           _ ___/ /\|    {~._.~}      __    __  
        (,_,)       ,;'( )__,  ) ~     ( Y )    o-''))_____\\
      .,;;;;;,.    //  //   '--;      ()~*~()   "--__/ * * * )
     .;;'|/';;;;'  '   \     | ^      (_)-(_)   c_c__/-c____/
	 
Zum Abschluss der Lektion stellen wir einige Effekte vor, die durch Linien und 
Füllungen in den Listings lessing10u1.s, lesson10u2.s, Lektion 10v.s, 		   
Lektion10x.s. Insbesondere in der letzten werden Sie eine der Haupttechniken   
der legendären "State of the Art" Demo sehen !!
	                     ^    ^