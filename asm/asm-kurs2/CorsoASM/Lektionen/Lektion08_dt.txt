              _
   _|_        / \.ММ/\_/\М._
    |        /   Џ\/     \/ \                   _
    |       Y _____Џ\/Џ_____ Y           ___   /Џ\   ___              .--.
.---------  |/ЏЏЏЏЏ\  /ЏЏЏЏЏ\|  -----  .YЏЏЏYОY   Y:YЏЏЏY. ___  ------.\/.--.
|        Ќ  f   |   YY   |   Y      Ќ.ООl___jОl___jОl___jОYЏЏЏY     Ќ  \/ Ќ |
|.          l  -М-  jl  -М-  j     /Џ/\Мf _ YМf _ YМf _ YОl___j             |
|Ё          |\  | _/ЏЏ\_ |  /|    ( <  >l/ \jМl/ \jМl/ \j./__ /            .|
|:          j \__/ /ЏЏ\ \__/ l     \_\/ `\ /МММ\ /МММ\ /Мl/ /j             :|
|.         (   ЏЏ /    \ ЏЏ   )           V `МММVМММММVМ' \/               .|
|           \__   \_/\_/   __/               .:::::::'                      |
|.            Џ\          /Џ    ЋЋ=--   DISK 2 - LESSON 8    --=ЛЛ         .|
|   /\          Y : .  . Y                З .  .  .                      tS |
`--'/\`-------  (_| | :| )  ----------           З  .       ----------------'
   `--'         \\j_j_ll//              .  З     .
                 ~:Џ:Џ::~                            .

ASSEMBLER-KURS - LEKTION 8

Autor: Fabio Ciucci 


In dieser Lektion wird das Wissen über den 68000 vertieft und es wird
einige Klarstellungen zu verschiedenen bereits behandelten Themen geben.
Eine Anmerkung für diejenigen, die den Kurs auf der Festplatte installieren: 
Ich schlage vor, dass Sie einige Verzeichnise mit dem Namen der zugehörigen 
Kursdisketten erstellen:

Assembler1
Assembler2
Assembler3
...

Wohin die gesamten Disketten kopiert werden sollen. Dann fügen sie zu s:startup-sequence hinzu:

assign Assembler1: dh0:Assembler1
assign Assembler2: dh0:Assembler2
assign Assembler3: dh0:Assembler3
...

(dh0: ist nur ein Beispiel ... Sie müssen natürlich das richtige Laufwerk bestimmen!).
Dann würde ich Ihnen raten, alle Quellen und Daten, die sich im Powerpacker-Format befinden,
auszupacken. Kopieren Sie dazu die c: PP-Datei auf die Festplatte und
prüfen Sie, ob Sie LIBS haben: die PowerPacker.library, andernfalls kopieren Sie sie
von der Diskette. Führen Sie nun die "PP"-Shell aus, um das automatisches Auspacken
zu aktivieren. Erstellen Sie sich jetzt ein "temporäres" Verzeichnis, z.B. nennen Sie es
"Puffer". Wenn Sie ALLE Dateien aus dem Verzeichnis Assembler1 ins Puffer-Verzeichnis kopieren
werden alle Dateien tatsächlich entpackt.
Jetzt können Sie sie alle in Assembler1 kopieren (vielleicht mit einem MOVE des DiskMasters 
oder des DirOpus, der sie auch auf dem Speicher neu abbildet).

Auf die gleiche Weise können Sie alle Assembler2 in den Speicher kopieren und dann 
in Assembler2 kopieren. Um diesen schnellen Vorgang zu speichern, können Sie das PP
vor dem Kopieren von Dateien von der Diskette in Verzeichnisse auf die Festplatte laden, 
so dass die Dateien in AssemblerX entpackt werden.

Die 3 Zuweisungsbefehle werden stattdessen dazu verwendet, die Festplatte mit dem 
Namen "AssemblerX:" zu suchen. Sie suchen das Verzeichnis "dh0: AssemblerX".
In einigen der kommenden Listings suchen wir tatsächlich nach "Assembler2:" und so
wird es auch für "Assembler3:" sein.

PS: Ich beabsichtige, den gesamten Kurs ins Englische zu übersetzen. Aber das würde
    mich für ganze MONATE zwingen, nicht mehr neue Lektionen zu schreiben ...
    Wenn ich also jemanden finden würde, der bereits Diskette 1 gelesen hat, und dann
    genial anständig eine Lektion übersetzen will, das würde mich sehr freuen. 	 
	Wer würde mir bei der Arbeit helfen?
    Die Übersetzung hätte natürlich einen sehr hohen Prozentsatz am Gewinn aus dem 
	Ausland (was ist mit 30%? Vielleicht ist es zu viel ..)
    Wer kann mir helfen? (Ich spreche von einem Übersetzungsjob bei BEL)
    Kontaktieren Sie mich so schnell wie möglich.

P.S2: Ich empfehle, ALLEN Freunden (und Nicht-Freunden) die Diskette1 des Kurses zu kopieren,
      um es den Ladenbesitzern Ihrer Stadt zu geben.
      Machen Sie Werbung auf Schwarzen Brettern oder in Zeitungen, um zu sehen, 
	  ob Sie jemandem finden der interessiert ist und neue Kontakte plant. Insbesondere
      könnten Sie die CyberAssembler-Philosophie der Szene verbreiten.
      Darüber finden Sie eine Zusammenfassung in der SCENA.TXT-Datei.
      Selbst der Papst muss, wenn er vom Balkon aus schaut, die Disktte 1 des Kurses haben
      (frei kopierbar).
  	  
	  Die Disk 2 ist jedoch nicht frei kopierbar, sonst würde ich auch nicht 
      (nicht viel) Geld von denen nehmen, die nur die Diskette 1 hatten. Stellen wir uns 
	  vor, ob beide Disketten gelitten haben!
      Wann (und wenn) mache ich jedoch wahrscheinlich Disketten 3, 4 usw.
      Ich werde auch Diskette 2 frei kopierbar machen (obwohl Shareware),
      damit die neuen sofort die Disketten 1 + 2 haben können, dann werde ich
      ein paar Änderungen mit den Disketten 3, 4 ... machen.
	 
Wir setzen die Lektion fort, unabhängig davon, ob sich die Datei auf einer Festplatte oder auf einer Diskette befindet.
Zunächst ist es notwendig, die Lektion auf dem 68000 zu absolvieren.
Eine vereinfachte Verwendung wurde vorgenommen. Schon aus der vorherigen Lektion hast du
gesehen, dass es sehr oft notwendig ist, an den einzelnen Bits der 
Zahlen oder Register zu arbeiten. Umsomehr "Sie weiter machen mit der Programmierung"
umsomehr werden sie Anweisungen wie AND, OR, NOT, ROL, ASL ... usw. einzufügen
die Booleschen Operationen und Scrolling Operationen für Bits.
Ah! Im LESSONS-Verzeichnis befindet sich ein Text, der die AMIGA-SZENE beschreibt. 
Nun, da Sie Codierer werden, ist es ratsam, zu wissen, wem sie für die Geburt der Programmierkultur der
Demo, auf diese "illegale" Weise, die aber, wie Sie gesehen haben, sehr gut funktioniert danken sollen.
Der Text ist SCENA.TXT. Lesen Sie ihn, wenn Sie nicht ihr Gehirn mit den ASM-Klassen rauchen lassen möchten!
Bevor Sie mit dem Kurs fortfahren, ist es nowendig eine Liste der Startups zu erstellen.
Das heißt, das System copper zu sichern und zurückzusetzen, effizienter als bisher.
Darüber hinaus muss dieses Startup in allen zukünftigen Listings enthalten sein,
so wird es sicherlich nützlich sein es über die "INCLUDE" -Direktive einzubinden,
wie wir es bereits beim Laden der Musik-Routine gesehen haben.
"Wir bauen" dieses Startup in der Lektion Schritt für Schritt auf, als 
Ergebnis der verschiedenen Klarstellungen.
Analysieren wir den Startvorgang, der in den vorherigen Lektionen verwendet wurde:


Start:
	move.l	4.w,a6				; Execbase
	jsr	-$78(a6)				; deaktivieren
	lea	GfxName(PC),a1			; Name lib
	jsr	-$198(a6)				; OpenLibrary
	move.l	d0,GfxBase
	move.l	d0,a6
	move.l	$26(a6),OldCop		; alte COP speichern

; Hier ist unser Copperstart und es gibt Routinen

	move.l	OldCop(PC),$dff080	; wir zeigen auf die Copperliste
	move.w	d0,$dff088			; Copper starten
	move.l	4.w,a6
	jsr	-$7e(a6)				; Enable
	move.l	gfxbase(PC),a1
	jsr	-$19e(a6)				; Closelibrary
	rts

In der Praxis unterbrechen wir Multitasking und Systeminterrupts durch (Disable)
das Deaktivieren, dann öffnen wir die Grafikbibliothek, durch die wir die Adresse 
der alten Copperliste finden können, da wir wissen, dass sie sich 26 Byte 
nach der GfxBase-Adresse befindet. Da wir Wissen, wie man die alte Copperliste ersetzt
und wie man die WorkBench wieder mobilisiert, handeln wir direkt auf den
Custom Chips ohne Angst vor Inkompatibilität. Am Ende der Routinen wird es notwendig
sein, das Enable auszuführen, um das Multitasking zu reaktivieren und auf die 
alte copperliste zu zeigen, um die Fenster des Betriebssystems erneut anzuzeigen.
Diese Operationen sind das Minimum, das zum Arbeiten notwendig ist, aber natürlich
könnten Sie den Code verbessern, zum Beispiel Grafikbibliotheksroutinen ausführen, 
die den Videomodus zurücksetzen, um auch die Videomodi für VGA / Multisync /
Multiscan-Monitore zurückzusetzen oder andere. 
Es gibt eine spezielle Funktion, die LoadView heißt.

; Wir haben die GfxBase im A6-Register

	MOVE.L	$22(A6),WBVIEW	; Speichern Sie das aktuelle System WBView
	SUBA.L	A1,A1			; Nullansicht, um den Videomodus zurückzusetzen
	JSR	-$DE(A6)			; Zurücksetzen des LoadView-Nullvideomodus

Für die LoadView-Funktion muss die Strukturadresse (der Ansicht) in a1 angegeben werden,
aber in diesem Fall ist A1 RESET, da wir a1 zu xxx hinzufügen
gleich, a1 = 0 erhalten. Wenn A1 NULL ist, setzt die Funktion den Videomodus zurück
meldet es an ein nicht verschachteltes LOWRES und ohne spezielle Frequenzen für
die Monitore. An diesem Punkt sind wir sicherer, die Situation der
Copperliste unter Kontrolle haben wir auch den alten Zeiger auf die WBVIEW-Struktur 
in einem Label gespeichert, mit dem wir die Liste beenden können
Wiederherstellen und damit spezielle Frequenzen für Monitore:

	MOVE.L	WBVIEW(PC),A1	; alte WBVIEW in A1
	MOVE.L	GFXBASE(PC),A6	; GFXBASE in A6
	JSR	-$DE(A6)			; loadview - Lege den alten View wieder auf


Um sicher zu sein, dass der Interlaced-Modus auch richtig zurückgesetzt wird, können 
sie zwei Frames warten, indem Sie die WaitOF-Routine der graphics.library erneut aufrufen:

	MOVE.L	WBVIEW(PC),A1	; alte WBVIEW in A1
	MOVE.L	GFXBASE(PC),A6	; GFXBASE in A6
	JSR	-$DE(A6)			; loadview - Lege den alten View wieder auf
	JSR	-$10E(A6)			; WaitOf (eventuell interlace zurücksetzen )
	JSR	-$10E(A6)			; WaitOf


Um Ihre Gedanken in Ruhe zu bringen, lassen Sie uns auch nach dem ersten loadwiew ein paar
WaitOFs setzen, die den Videomodus zurücksetzen, und schon prüfen wir, ob 
das Zurücksetzen  wirklich geschehen ist, indem getestet wird, ob das WBVIEW wie erwartet 
zurückgesetzt wurde:

; Wir haben die GfxBase im A6-Register

	MOVE.L	$22(A6),WBVIEW	; Speichern Sie das aktuelle System WBView
	SUBA.L	A1,A1			; View null, um den Videomodus zurückzusetzen
	JSR	-$DE(A6)			; LoadView Null - Videomodus zurücksetzen
	JSR	-$10E(A6)			; WaitOf (Diese beiden Aufrufe von WaitOf)
	JSR	-$10E(A6)			; WaitOf (werden verwendet, um das Interlace zurückzusetzen )

Da wir Betriebssystemroutinen verwendet haben, sind wir zuversichtlich, dass auch in den Maschinen 
in der Zukunft der Videomodus noch zurückgesetzt wird.
Um die Kompatibilität zu "übertreiben", können wir uns am Ende des Listings mit dem Aufruf der
intuition.library-Funktionen, die die Bildschirme und die Fenster "neu zeichnen".

	move.l	4.w,a6			; ExecBase in A6
	LEA	IntuiName(PC),A1	; Bibliotheksname zum Öffnen (Intuition)
	JSR	-$198(A6)			; OldOpenLibrary - Öffnen Sie die Bibliothek
	TST.L	D0				; Fehler?
	BEQ.s	EXIT			; Wenn ja, beenden Sie den Code, ohne den Code auszuführen
	MOVE.L	D0,A6			; IntuiBase in a6
	jsr	-$186(A6)			; ReThinkDisplay - Ordnen Sie die Konnotationen der
							; Bildschirm ...


Dieser Vorgang ähnelt dem Vorgang, der mit WBView durchgeführt wird.
Bis jetzt haben wir den Blitter noch nicht benutzt, aber in den nächsten Lektionen 
werden wir den Blitter verwenden, und da wir dieses Startup verwenden werden, wird es nützlich sein
uns für diesen Zweck vorzubereiten. Stellen Sie nur sicher, dass der Blitter nicht
vom Betriebssystem verwendet wird, während wir es verwenden, und es gibt eine Funktion
von GfxLib die in der Lage ist, die Verwendung des Blitters durch die Workbench zu verhindern:

	jsr	-$1c8(a6)	; OwnBlitter, gibt uns den exklusive Zugang auf den Blitter
					; verhindert, dass er vom Betriebssystem verwendet wird.

Am Ende des Listings reicht es aus, die Funktion aufzurufen, die das Gegenteil tut.
Aktivieren Sie die Verwendung des Blitters durch die graphics.library erneut:

	jsr	-$1ce(a6)	; DisOwnBlitter, das Betriebssystem 
					; kann den Blitter jetzt wieder verwenden

Diese beiden Funktionen ähneln dem Disable und dem Enable, die wir gesehen haben
beim Abschalten und Wiederherstellen von Multitasking und Systemunterbrechungen.
Tatsächlich gibt es auch eine weniger drastische Funktion der Deaktivierung, das ist
FORBID. Es verbietet das Multitasking lässt aber die Systeminterrupts zu. Niemand 
verbietet vielleicht, Forbid und Disable zusammen zu verwenden. Das System stürzt abrupt ab, 
versuchen wir es zusammen:

	move.l	4.w,a6		; ExecBase in A6
	JSR	-$84(a6)		; FORBID - Deaktivieren Sie das Multitasking
	JSR	-$78(A6)		; DISABLE - Es deaktiviert auch die Interrupts
						; des Betriebssystems
; routines

	MOVE.L	4.w,A6		; ExecBase in a6
	JSR	-$7E(A6)		; ENABLE - ermöglicht System Interrupts
	JSR	-$8A(A6)		; PERMIT - ermöglicht Multitasking


Jetzt kann der Amiga nicht mit einer Guru-Meditation oder einem SoftWare-Fehler protestieren
und sagen, wir hätten sie nicht gewarnt, da wir die Hardware programmieren!

	                / \  //\
	  |\___/|      /   \//  .\
	  /O  O  \__  /    //  | \ \
	 /     /  \/_/    //   |  \  \
	 @___@'    \/_   //    |   \   \
	    |       \/_ //     |    \    \
	    |        \///      |     \     \
	   _|_ /   )  //       |      \     _\
	  '/,_ _ _/  ( ; -.    |    _ _\.-~        .-~~~^-.
	  ,-{        _      `-.|.-~-.           .~         `.
	   '/\      /                 ~-. _ .-~      .-~^-.  \
	      `.   {            }                   /      \  \ 
	    .----~-.\        \-'                 .~         \  `. \^-. 
	   ///.----..>        \             _ -~             `.  ^-`  ~^-_
	     ///-._ _ _ _ _ _ _}^ - - - - ~                     ~--,   .-~ 
	                                                           |_/~ 


Da wir den Status von allem speichern, warum speichern Sie nicht die Werte von
Daten- und Adressregistern? 

Es gibt eine Anweisung, die hauptsächlich für diesen Zweck verwendet wird
und das ist das MOVEM. Die Register werden auf dem STACK gespeichert, das ist das 
A7-Register, auch SR genannt, das wir bis jetzt vermieden haben zu verwenden. 
Mal sehen, was der Stack ist: Ich denke es ist ein Register 
ähnlich wie ein Adressregister, es ist nicht umsonst das Register A7.
Daher ist der Wert, den das Register enthält, eine Adresse oder Zeiger an eine Adresse.
Tatsache ist, dass wir, wenn wir die Adresse in A7 (oder SP) ändern, den Amiga ändern
Es ist total verrückt. Aber wer setzt die Adresse in den Stack Pointer?

Da der Guru / Software-Fehler geändert wird, können Sie raten das ist das 
Betriebssystem, das diese Zahl bei jedem Reset bestimmt, und es ist er.
Ändern Sie es bei Bedarf. 

Zu wissen, wie man es benutzt, kann aber sehr nützlich sein.
Wir haben im Kurs gesehen, wie man einen Speicherbereich mit indirekte Adressierung
angeben kann, zB durch Schreiben von:

	lea	bitplane,a0
	move.l	#$123,(a0)+
	move.l	#$456,(a0)+

	
Wir haben die Werte $123 und $456 über das Register a0 in die Bitebene eingetragen,
da haben wir a0 auf die Bitplane gesetzt haben. Aus diesem Listing sehen wir
auch wie es möglich ist, mit indirekter Adressierung mit Post-Inkrement,
die Daten nacheinander in den Speicherbereich einzugeben.
Was würde passieren, wenn wir nach diesen Anweisungen schreiben würden:

	move.l	-(a0),d0
	move.l	-(a0),d1

Es würde passieren, dass in d0 der letzte eingegebene Wert, dh $456, kopiert wird
während in d1 der erste $123 und a0 wieder auf die Bitebene zeigen würden.
In der Praxis sind wir "zurück".
Nun, stellen Sie sich die entgegengesetzte Operation vor: In dem Fall den
wir gesehen haben, dass es einen Speicherbereich gibt, den wir BITPLANE genannt haben
und wir schreiben von dieser Adresse aus mit move.l #xxx,(a0)+ vorwärts.

	Bitplane
	   o------------>

Nach einer bestimmten Anzahl von Anweisungen zeigt a0 auf Bitplane+x, das ist viel
später im Speicher.
Wir können die Werte mit move.l -(a0),xxx "wieder zurücknehmen", die wir in diesem Feld 
mit Werten "gefüllt" haben und zurückkehren bis wir die BITPLANE-Startadresse wieder erreichen. 
Aber sei vorsichtig!
Wir haben die Daten in umgekehrter Reihenfolge im Vergleich zur eingegebenen eingesammelt.
Tatsächlich ist der zuletzt eingegebene, der erste der wieder aufgenommen wird. Der Stack zeigt 
auf eine Adresse im Speicher, das als "Feld" dient, in dem gesät werden soll, d.h. einem Bereich 
in dem Daten gespeichert und wieder aufgenommen werden sollen.
Wir müssen jedoch aufpassen, dass es "rückwärts" verwendet wird, im Gegenteil
zum Bitplane-Beispiels. Die Notwendigkeit für den Stack kommt mit den ersten CPUs.
Es ist so organisiert: Der Speicher eines Computers wird normalerweise
von der niedrigsten zur höchsten Adresse gefüllt, zum Beispiel wenn
wir haben einen Computer mit 512 KB Speicher haben und wird müssen eine 256k lange Datei laden.
Bei 256k werden die ersten 256k gefüllt, und die Kb von 257 bis 512 bleiben frei.
Sie möchten einen STACK-Platz reservieren, um generische Daten zu speichern. Dabei ist es am 
Besten diesen Raum vom Ende des Speichers zu beginnen, und von dort die Daten "rückwärts" bis 
zum ersten Speicherplatz zu speichern, um damit den Speicher besser zu nutzen:

	Null ---------------------------------------Ende Speicher
	     Programm ----->>		<<-----STACK

Auf diese Weise wird der Stack nicht überschrieben, wenn der Speicher vorhanden ist
und sowieso vermeiden die Programme die unter dem Betriebssystem laufen diese
Kollision! Wir müssen Demos oder Spiele erstellen, die vom Betriebssystem ausgeführt werden können.
Daher müssen wir den Stack auf eine Standardmethode verwenden, um keine Konflikte mit
Überschreiben zu erzeugen.
Wenn wir ein Programm im Autoboot gemacht haben und nicht exit gehen müssen,
könnten wir unseren eigenen Bereich für den Stack definieren, aber das kann
Kompatibilitätsprobleme generieren und ich empfehle Ihnen vorerst, dies nicht zu tun.
Lassen Sie uns abschließend sehen, wie man Daten vom STACK aus eingibt und sammelt
mit einem sehr einfachen Beispiel: Speichern Sie den Inhalt des Registers D0 und
stellen Sie es anschließend wieder her.

	MOVE.L	d0,-(SP)	; lass uns d0 im Stapel speichern. HINWEIS: wenn wir 
						; nur ein Register speichern müssen, verwenden wir MOVE
						; MOVEM, wird für mehrere Register verwendet.

						; Routinen, die D0 verändern

	MOVE.L	(SP)+,d0	; wir stellen den alten Wert von d0 wieder her
						; es vom Stapel nehmen

Beachten Sie, dass das Schreiben von MOVE.L d0,-(SP) oder MOVE.L d0,-(A7) gleichwertig ist.
Wir stellen fest, dass der Inhalt von d0 an die Adresse kopiert wird, auf die der SP zeigt, 
und der SP selbst kommt einen Länge weiter weg. Dann wird d0 durch verschiedene Routinen geändert
und wenn wir den alten Wert wieder erhalten möchten, holen wir ihn vom SP zurück.
Beachten Sie, dass mit (SP)+ wir dem SP melden, auf die Adresse zu zeigen
auf die er zielte, bevor er d0 rettete, das heißt, wir gehen weiter nach vorne zurück,
und holen den Wert.

Versuchen wir nun, den Wert mehrerer Register zu speichern:

	Move.l d0,-(SP)	; lass uns d0 im Stapel speichern
	Move.l d1,-(SP)	; lass uns d1 im Stack speichern
	Move.l d2,-(SP)	; lass uns d2 im Stack speichern
	Move.l d3,-(SP)	; Lassen Sie uns d3 im Stapel speichern

					; Routinen, die d0, d1, d2, d3 modifizieren

	Move.l (SP)+,d3	; wir stellen den alten Wert von d3 wieder her
	Move.l (SP)+,d2	; wir stellen den alten Wert von d2 wieder her
	Move.l (SP)+,D1	; wir stellen den alten Wert von d1 wieder her
	Move.l (SP)+,d0	; wir stellen den alten Wert von d0 wieder her
					; sie vom Stapel nehmen

Beachten Sie, dass der zuletzt gespeicherte Wert der erste ist, der wiederherausgeholt werden kann.
Nur für den Fall, dass wenn wir zurückgehen dann gehen wir zurück und lesen
vom zuletzt eingegebenen Wert von oben nach unten bis zum Ersten:

						Adresse Beginn STACK
	Shreiben:	-(SP)	<--------------o	- zurück -


						Adresse Beginn STACK
	Lesen:	(SP)+	--------->     o	- vorwärts -


	
Es ist eine "Stapel" -Struktur. Man kann sich das in folgender Weise vorstellen: 
Ich denke, Sie haben eine Sammlung von Comics und möchten von 
Nummer eins bis Nummer 50 sortieren. Nummer 1 gefunden, auf einen Tisch legen.
Gefundenen Nummer 2 auf die Nummer 1. Dann die 3 auf die 2 und allmählich
machen Sie einen "Stapel" von Comics, bis Sie die Zahl 50 oben auf den Haufen 
gelegt haben. Nun, wenn Sie die Comics wieder sehen möchten, ist die erste, die Sie
sehen die '50, dann unten sind 49, 48 usw. und zuletzt
finde sie die 1. Tatsächlich ist der Stapel vom Typ "first in, last out", dh "das 
zuerst reinlegen und das letzte herausgezogen".
Sie werden verstehen, dass das unangemessene Ändern der Stack-Werte in 
zufälliger Speicher übernommen wird und nicht als zuvor gespeicherte Werte betrachtet.
Seien Sie also vorsichtig, wenn Sie Folgendes ausgeführt haben:

	MOVE.L	xxxx,-(SP)	; wir speichern xxxx im stack

Wenn Sie das nächste Mal mit (SP)+ aus dem Stapel lesen, erhalten Sie xxxx.

Im Stack können Sie alle Daten speichern und wiedergewinnen.
Ein offensichtlicher Nutzen besteht darin, den Status der Register zu speichern.
Dies ist möglich, durch das einfache MOVE.L falls nur ein Register gerettet werden soll
oder durch das MOVEM (MOVE Multiple) für mehrere Register.
Mal sehen, wie das MOVEM funktioniert: um alle Register zu speichern (außer a7,
dies ist offensichtlich der SP), also d0, d1, d2, d3, d4,5, d6, d7, a0, a1, a2, a3, a4, a5, a6),
müssen Sie dies nur MOVEM statt mit 15 x MOVE zu tun:

	MOVEM.L	d0-d7/a0-a6,-(SP)	; speichert alle Register im STACK

Und um sie alle wiederherzustellen, nur ein:

	MOVEM.L	(SP)+,d0-d7/a0-a6	; Führt alle Register vom STACK wieder aus

Praktisch verschiebt das MOVEM eine Liste von Registern an das Ziel. In dem
Fall von "MOVEM.L d0-d7/a0-a6,Ziel", oder kopieren Sie eine Quelle in die verschiedenen
Register, im Fall von "MOVEM.L -Quelle,d0-d7/a0-a6".
Quelle und Ziel liegen im "Standard"-Format vor, sodass sie eine 
Kopie von und an LABEL/ADRESSEN oder indirekte Adressierung vornehmen können:

	MOVEM.L	d0-d7/a0-a6,-(SP)
	MOVEM.L	d0-d7/a0-a6,LABEL
	MOVEM.L	d0-d7/a0-a6,$53000

	MOVEM.L	$53000,d0-d7/a0-a6
	MOVEM.L	LABEL(PC),d0-d7/a0-a6
	MOVEM.L	(SP)+,d0-d7/a0-a6

Die Liste folgt diesem Standard: Die Register können separat angegeben werden.
Alle getrennt mit dem "/" - Schrägstrich, so dass wir sagen können:

	MOVEM.L	d0-d7/a0-a6,-(SP)

Es ist äquivalent zu:

	MOVEM.L	d0/d1/d2/d3/d4/d5/d6/d7/a0/a1/a2/a3/a4/a5/a6,-(SP)

Eine aufeinanderfolgende Reihe von Register kann durch Anzeigen des ersten Registers 
und des letzten Registers getrennt durch ein "-" mitgeteilt werden. 
In Wirklichkeit akzeptiert das Asmone auch:

	MOVEM.L	d0-a6,-(SP)

Es betrachtet es als die sehr lange vorhergehende Anweisung, aber da nicht
alle Assembler dieses Darstellung akzeptieren, ist es besser, das "/" zwischen 
die Sätze von Datenregistern und die der Adressregister zu setzen.
Nehmen wir einige Beispiele: Wir wollen die Register d0, d1, d2, d5 und a3 speichern:

	MOVEM.L	d0-d2/d5/a3,-(SP)
		
Wir haben d0/d1/d2 durch d0-d2 vereinfacht.
Versuchen wir jetzt d2,d4,d5,d6,a3,a4,a5,a6 zu speichern:

	MOVEM.L	d2/d4-d6/a3-a6,-(SP)

Um diese Register wiederherzustellen, schreiben wir natürlich:

	MOVEM.L	(SP)+,d2/d4-d6/a3-a6

Ich glaube, dass die Syntax von MOVEM klar ist. Durch diese Anweisung ist es möglich
Multitasking zu verwalten. Haben Sie sich jemals gefragt, wie sie zwei
Programme zusammen mit den gleichen Daten- und Adressrregistern ausführen können, 
ohne das sie sich gegenseitig stören? Die Antwort ist einfach!
Zu Beginn jeder Routine gibt es ein MOVEM, das den Status der Register speichert.
Die Routine wird ausgeführt und am Ausgang kehren die Register in ihren Originalzustand 
zurück, als ob diese Routine noch nie durchgeführt worden wäre.
Tatsächlich sind viele Routinen so strukturiert:

Routine:
	MOVEM.L	d0-d7/a0-a6,-(SP)
	....
	....
	MOVEM.L	(SP)+,d0-d7/a0-a6
	rts

Auf diese Weise bewirkt eine "BSR.W ROUTINE" keine Änderung der Register.
Wenn in a5 $dff000 und in a6 ExecBase steht, sind wir uns sicher, dass nachdem
die Routine ausgeführt wurde es immer noch diese Werte sind.
Bei der Verwendung von zu häufigen MOVEM kommt es vor, dass durch "FILO" Daten
verloren gehen. Wie durch movem so etwas passieren kann:

Routine:
	MOVEM.L	d0-d7/a0-a6,-(SP)
	....
	....
	MOVEM.L	(SP)+,d0-d7/a0-a6
	....
	....
	MOVEM.L	(SP)+,d0-d7/a0-a6
	rts

In diesem Fall liegt ein OFFENSICHTLICHER ERROR vor, da zuerst der Stack zu weit 
gegangen ist, so dass alle Daten, die später vom Stapel genommen werden falsch sind.
Als zweites werden die Register bereits andere Werte haben als die ankommenden. 
Um alles zurückzubekommen, können Sie Folgendes tun:

Routine:
	MOVEM.L	d0-d7/a0-a6,-(SP)
	....
	....
	....
	MOVEM.L	d0-d7/a0-a6,-(SP)
	....
	....
	MOVEM.L	(SP)+,d0-d7/a0-a6
	....
	....
	MOVEM.L	(SP)+,d0-d7/a0-a6
	rts

Auf diese Weise haben die Register am Ausgang der Routine den Eingabewert
und der Stack kehrte zur Eingangsadresse zurück. (Eintritt in die Routine!)

An dieser Stelle können wir unser Startup mit einer anfänglichen Speicherung 
und endgültigen Restaurierung der Register ausführen, ähnlich dem letzten Beispiel.
So sieht unser Startup jetzt aus:

MAINCODE:
	movem.l	d0-d7/a0-a6,-(SP)	; Speichern der Register auf dem Stack
	move.l	4.w,a6				; ExecBase in a6
	LEA	GfxName(PC),A1			; Name der zu öffnenden Bibliothek
	JSR	-$198(A6)				; OldOpenLibrary - öffne die Bibliothek
	MOVE.L	d0,GFXBASE			; Speichern Sie die GfxBase in einem Label
	BEQ.w	EXIT2				; Wenn ja, beenden Sie den Code, ohne den Code auszuführen
	LEA	IntuiName(PC),A1		; Intuition.lib
	JSR	-$198(A6)				; Openlib
	MOVE.L	D0,IntuiBase
	BEQ.w	EXIT1				; Wenn Null, geh raus! Fehler!
	MOVE.L	IntuiBase(PC),A0
	CMP.W	#39,$14(A0)			; Versione 39 oder größer? (kick3.0+)
	BLT.s	VecchiaIntui		; alte Intui
	BSR.w	ResettaSpritesV39

VecchiaIntui:
	MOVE.L	GfxBase(PC),A6
	MOVE.L	$22(A6),WBVIEW		; Speichern Sie das aktuelle System WBView
	SUBA.L	A1,A1				; Nullansicht, um den Videomodus zurückzusetzen
	JSR	-$DE(A6)				; LoadView Null - Videomodus zurücksetzen
	SUBA.L	A1,A1				; View null
	JSR	-$DE(A6)				; LoadView (zweimal für die Sicherheit...)
	JSR	-$10E(A6)				; WaitOf (Diese beiden Aufrufe von WaitOf)
	JSR	-$10E(A6)				; WaitOf (Sie werden verwendet, um das Interlace zurückzusetzen)
	JSR	-$10E(A6)				; Noch zwei, okay!
	JSR	-$10E(A6)

	MOVEA.L	4.w,A6
	SUBA.L	A1,A1				; NULL task - finden Sie diese Aufgabe
	JSR	-$126(A6)				; findtask (d0=task, FindTask(name) in a1)
	MOVEA.L	D0,A1				; Task in a1
	MOVEQ	#127,D0				; Priorität in d0 (-128, +127) - MAXIMAL!
	JSR	-$12C(A6)				;_LVOSetTaskPri (d0 = Priorität, a1 = Aufgabe)

	MOVE.L	GfxBase(PC),A6
	jsr	-$1c8(a6)				; OwnBlitter, das gibt uns den exklusiven Zugang auf den Blitter
								; verhindern, dass es im Betriebssystem verwendet wird.
	jsr	-$E4(A6)				; WaitBlit - Wartet auf das Ende des Blitters
	JSR	-$E4(A6)				; WaitBlit

	move.l	4.w,a6				; ExecBase in A6
	JSR	-$84(a6)				; FORBID - Deaktivieren Sie das Multitasking
	JSR	-$78(A6)				; DISABLE - Deaktiviere auch die interrupts
								; des Betriebssystems
**************
	bsr.w	HEAVYINIT			; Jetzt können Sie die Rolle spielen die funktioniert
**************					; auf den Hardware-Registern

	move.l	4.w,a6				; ExecBase in A6
	JSR	-$7E(A6)				; ENABLE - ermöglichen System Interrupts
	JSR	-$8A(A6)				; PERMIT - ermöglichen Multitasking

	SUBA.L	A1,A1				; NULL task - finde diese Aufgabe
	JSR	-$126(A6)				; findtask (d0=task, FindTask(name) in a1)
	MOVEA.L	D0,A1				; Task in a1
	MOVEQ	#0,D0				; Priorität in d0 (-128, +127) - MAXIMAL!
	JSR	-$12C(A6)				; _LVOSetTaskPri (d0 = Priorität, a1 = Aufgabe)

	MOVE.W	#$8040,$DFF096		; ermöglichen Blitter
	BTST.b	#6,$dff002			; WaitBlit...
Wblittez:
	BTST.b	#6,$dff002
	BNE.S	Wblittez

	MOVE.L	GFXBASE(PC),A6		; GFXBASE in A6
	jsr	-$E4(A6)				; Warten Sie, bis alle Blittings beendet sind
	JSR	-$E4(A6)				; WaitBlit
	jsr	-$1ce(a6)				; DisOwnBlitter, das Betriebssystem jetzt
								; kann den Blitter wieder verwenden
	MOVE.L	IntuiBase(PC),A0
	CMP.W	#39,$14(A0)			; V39+?
	BLT.s	Vecchissima
	BSR.w	RimettiSprites

Vecchissima:
	MOVE.L	GFXBASE(PC),A6		; GFXBASE in A6
	MOVE.L	$26(a6),$dff080		; COP1LC - Zeigen Sie auf das alte System "Copper1"
	MOVE.L	$32(a6),$dff084		; COP2LC - Zeigen Sie auf das alte System "Copper2"
	JSR	-$10E(A6)				; WaitOf ( Setzen Sie Interlace zurück)
	JSR	-$10E(A6)				; WaitOf
	MOVE.L	WBVIEW(PC),A1		; Alte WBVIEW in A1
	JSR	-$DE(A6)				; loadview - setzt die alte Ansicht zurück
	JSR	-$10E(A6)				; WaitOf ( Setzen Sie Interlace zurück)
	JSR	-$10E(A6)				; WaitOf
	MOVE.W	#$11,$DFF10C		; Questo non lo ripristina da solo..!
	MOVE.L	$26(a6),$dff080		; COP1LC - Zeigen Sie auf das alte System "Copper1"
	MOVE.L	$32(a6),$dff084		; COP2LC - Zeigen Sie auf das alte System "Copper2"
	moveq	#100,d7
RipuntLoop:
	MOVE.L	$26(a6),$dff080		; COP1LC - Zeigen Sie auf das alte System "Copper1"
	move.w	d0,$dff088
	dbra	d7,RipuntLoop		; Für die Sicherheit...

	MOVEA.L	IntuiBase(PC),A6
	JSR	-$186(A6)				;_LVORethinkDisplay - Alle neu gestalten
								; Anzeige, einschließlich ViewPorts und beliebiger
								; Interlace- oder Multisync-Modi.
	MOVE.L	a6,A1				; IntuiBase in a1 um die Bibliothek zu schließen
	move.l	4.w,a6				; ExecBase in A6
	jsr	-$19E(a6)				; CloseLibrary - intuition.library geschlossen
Exit1:
	MOVE.L	GfxBase(PC),A1		; GfxBase in a1 um die Bibliothek zu schließen
	jsr	-$19E(a6)				; CloseLibrary - graphics.library geschlossen
Exit2:
	movem.l	(SP)+,d0-d7/a0-a6	; Stellen Sie die alten Registerwerte wieder her
	RTS							; Kehren Sie zu ASMONE oder Dos / WorkBench zurück
	
Es wurden nur vier Details hinzugefügt: Eines ist die Überprüfung nach dem Öffnen 
der Graphics.library, wenn es aus irgendeinem Grund nicht geöffnet werden konnte, würden 
wir in dem Fall in d0 anstelle der Adresse der GfxBase eine NULL finden.
Alles, was dafür getan wird, ist ein Pseudo "TST.L D0" einzufügen und ein Sprung zum 
EXIT-Label für den Fall wenn nicht erfolgreich geöffnet werden konnte.
Sie werden mit dem Studium der Zustandscodes feststellen, das es ausreicht ein "beq"
nach einem move zu machen, ohne "tst" zu verwenden, um zu wissen, ob d0 zurückgesetzt wird.
Ein weiteres Detail ist das Auftreten des Systems COPPER2 (GfxBase + $32).
Das ist nichts anderes als der vom System eingegebene Wert in $dff084 (COP2LC).
Bisher haben wir die Copperliste 2 noch nichtverwendet, aber in den späteren Lektionen
werden wir das Zeigen der Anwendungsfälle nicht versäumen.
Eine weitere "Finesse" besteht darin, die Sprites zurückzusetzen, aber nur, wenn wir 
Kickstart 3.0 oder höher, eingeschaltet haben, da die Sprite-Reset-Funktion 
ab dieser Version verfügbar ist. Die SubRoutine, die die Sprites zurücksetzt ist ein
klassisches Beispiel für die "legale" Programmierung mit Aufrufen des Betriebssystems.
Wie Sie sehen können, ist es komplizierter das Betriebssystem (das Programm) über 
die Hardware zu bedienen (nicht wahr?).

Schließlich gibt es die Einstellung der Taskpriorität. Wie sie wissen hat jedes Programm
was in Multitasking ausgeführt wird, im Vergleich zu den anderen eine eigene "Priorität".
Nun, lassen Sie uns das Maximum einstellen! Das ist 127. In Wirklichkeit würde das nichts nützen
nachdem wir Multitasking komplett deaktiviert haben. Wir werden später sehen, dass es trotzdem 
nützlich ist, die Priorität auf das Maximum zu setzen und das Multitasking wiederherzustellen
beim Laden von Datendateien von Diskette, Festplatte oder CD-ROM.

Mit diesem Startup geben wir unser Bestes, um sicherzustellen, dass das Betriebssystem 
ohne Probleme "umgangen" werden kann. Mal sehen, was wir noch tun können um mehr Kontrolle 
über die Amiga Hardware zu übernehmen.
Zunächst müssen die Register DMACON, INTENA, ADKCON und INTREQ eingeführt werden
sie sind für das "Schließen" oder "Öffnen" der DMA-KANÄLE, sowie das
Aktivieren von Interrupts und anderen Dingen.  In den Listings, gehen wir davon aus
dass COPPER, BITPLANES und SPRITE tatsächlich aktiviert sind.
Wir können sowohl die Texte als auch die Menüs des ASMONE (BITPLANE) und den Pfeil sehen
Mauszeiger (SPRITE). Dies bedeutet, dass diese Kanäle aktiviert sind.

Es ist jedoch besser, den Status dieser Register persönlich zu ändern.
Vergewissern Sie sich, dass die Kanäle, die uns interessieren, aktiviert sind und die 
für die wir uns nicht interessieren deaktiviert sind.
Wie bei der Copperliste wird es genug sein den Status der Register am Anfang zu speichern
und dann unseren Programm auszuführen (aktiviert und deaktiviert nach Belieben), um 
schließlich die Register wieder in den Anfangszustand zu bringen, als wäre nichts passiert.
Aber zuerst wollen wir sehen, was diese DMA-Kanäle sind.

DMA bedeutet "Direct Memory Access" (direkter Speicherzugriff), was "direkter Zugriff auf
den Speicher" bedeutet.
Tatsächlich ist der Zugriff auf den Speicher im Amiga sehr komplex. Denn Zugriff auf
den Speicher hat nicht nur der Prozessor, sondern auch der Copper, um Bilder anzuzeigen,
den Blitter zum Kopieren und Verschieben von Daten, Audio um den Ton abzuspielen.
Um zu verhindern das "Unfälle" passieren, wenn all diese Prozessoren gleichzeitig, den Speicher,
in die Hände bekommen möchten (zumindest den CHIP-Speicher) wurde ein System von "Ampeln"
und Viadukten, wir können über Stadtplanung sprechen, gesetzt. 
Tatsächlich befindet sich im AGNUS-Chip ein DMA-Channel-Manager, der
die Operationen koordiniert und auf benutzerdefinierte Chips und 68000 zugreift.
wenn der Kanal frei ist. 
Dieser Zugang kann entweder Lesen oder Schreiben sein (Copper liest Copperlist, 
Audio-Datei liest Musik, der Blitter jedoch "WRITE images, und so" weiter).
Es gibt mehrere DMA-Kanäle, bei denen jeder einem bestimmten Zweck hat.

1) DMA-COPPER: Durch diesen Kanal liest das Copper die COPPERLISTE.
	Wenn es deaktiviert ist, wird die Copperliste nicht mehr gelesen
	folglich verschwinden sowohl die Bitebene als auch die Sprites und auch alle
	alle Farbtöne die durch Ändern der Hintergrundfarbe mehrmals durch setzen von WAIT in 
	der Copperliste gemacht werden.
	In der Praxis bleibt der Bildschirm einfarbig mit der Farbe COLOR0. In diesem Fall 
	können Sie die Farbe des Bildschirm nur mit dem Prozessor, mit "MOVE.W #xxx,$dff180" ändern.

2) DMA SPRITE: Dieser Kanal überträgt die Sprite-Strukturen.
	Diese Werte werden in den SPRxPT-Copperlistregistern eingesetzt.
	Wir haben jedoch bereits gesehen, wie man Sprites durch direktes Schreiben in die 
	SPRxDAT-Register visualisieren und damit manuell die Arbeit der DMA machen kann.
	Nur den DMA-Kanal Sprite deaktivieren bewirkt, dass die Sprites verschwinden, als ob sie auf Null 
	zielen würden und die Bitebene und Farbverläufe die mit WAIT und MOVE der Copperliste auf dem 
	Bildschirm gemacht werden bleiben erhalten. Es bleibt zu bemerken, das wenn das DMA-BITPLANE 
	deaktiviert ist, auch durch aktiv Halten des DMA-Kanal die Sprites verschwinden.

3) DMA-BITPLANE: Bei Deaktivieren dieses Kanals werden die Bitebenen, auf die die BPLxPT zeigen
	nicht mehr angezeigt. Andererseits werden jedoch die Farbtöne bei aktiven DMA-Kanal Copper
	mit COLOR0 angezeigt. Ausschalten des Kanals würde das gleiche wie das Einfügen von Null-Bitebenen 
	in den BPLCON0 entsprechen. Das heißt, "dc.w $100,$200" in der Copperliste.
	Beachten Sie, dass bei deaktiviertem BITPLANE-DMA auch die Sprites zusammen mit der Bitebene verschwinden,
	auch wenn der DMA-Kanal SPRITE aktiv ist. Dies geschieht auch, wenn wir Nullbitebenen in der BPLCON0 setzen.
	
4) DMA DISC: Zum Übertragen von Daten vom Laufwerk in den CHIP-Speicher durch lesen oder schreiben.

5) DMA AUDIO1 Dies sind 4 separate Kanäle, die die 4 Stimmen steuern.
   DMA AUDIO2 Stereo des Amiga. Zum Beispiel, um einen Ton von zu emittieren
   DMA AUDIO3 Punkt 1, müssen Sie den Kanal DMA AUDIO1 öffnen und machen
   DMA AUDIO4 ändert dieses Element, indem der DMA-Kanal wieder geschlossen wird. 
   Offensichtlich sind die 4 Kanäle immer geschlossen, wenn der Amiga  still ist,
   zum Beispiel wenn Sie die WorkBench ohne Hintergrundmusik verwenden.

6) DMA BLITTER: Dieser DMA behandelt Lese- und Schreibzugriffe vom Blitter. Wir werden die DMA-Kanäle 
	des Blitters in dem Kappitel der diesem Prozessor gewidmet ist analysieren.
	
Aber wie ist der Zeitpunkt des Zugriffs auf den Speicher zwischen dem Prozessor und den Custom Chips?
Das hängt sehr stark von der Videoauflösung und den aktivierten Kanälen ab. In der Praxis werden weniger 
Kanäle eingeschaltet ist der 68000er schneller, als die anderen in Betrieb befindlichen CHIPs.
Sehen wir uns die Beziehung zwischen Videoauflösung und DMA an: Das Videobild wird 
durch Rasterlinien erstellt, das heißt von Linien, die durch den elektronischen Rasterstrahl gezeichnet werden.
Wir wissen bereits, wie man auf eine bestimmte vertikale Linie durch Lesen des $dff006 (VHPOSR) 
oder in der Copperliste über eine WAIT wartet.
Nun, in jeder Rasterzeile gibt es 227.5 Zugriffe auf den Speicher und die
DMA verwendet nur 225. Ein Zyklus des Zugriffs auf den Speicher, wenn Sie das interessiert,
hat eine Dauer von 0,00000028131 Sekunden in einem 320x256-PAL-Bildschirm bei 50 Hz.

Da der 68000 keine Zeit hätte, in jeden Buszyklus auf den Speicher zuzugreifen
wird der Zugriff nur während der geraden Zyklen gewährt, also 113 Mal pro
Rasterzeile. Das Problem ist, dass der Blitter und der Copper auch in den gerade Zyklen
Zugriff auf den Bus haben können, und somit dem armen 68000 Zyklen stehlen können.
Ungerade Buszyklen werden stattdessen vom DMA-Manager für AUDIO-Zugriffe, DISC und SPRITE verwendet.

Zusammenfassend gibt es 227/228 Zyklen pro Rasterzeile, unterteilt in gerade und ungerade Zyklen.
In den 113 ungeraden Zyklen kann nur auf den CHIP-Speicher durch AUDIO, DISC und SPRITE zugegriffen werden.
Auf die 113 geraden Zyklen können der BLITTER, COPPER und der 68000 auf den CHIP-Speicher zugreifen,
wo wiederum der arme 68000 eine niedrigere Priorität hat.

Sie werden verstehen, dass bei Deaktivierung des DMA-Blitters der 68000 häufiger auf den 
Speicher zugreifen kann, da er mehr freie gerade Zyklen hat.
Bedenken Sie, dass DMA-COPPER Vorrang vor dem DMA-BLITTER hat, welcher eine höhere
Priorität über den 68000 hat, was besser für arbeiten im FAST RAM ist.

In der Tat, wenn sich der Code, den der 68000 ausführt, sich im FAST-RAM-Speicher anstatt im 
CHIP-RAM befindet leidet der Prozessor nicht daran. Es ist daher besser
den Code mit dem SECTION CODE in den Fast RAM zu setzen.

Nehmen wir ein Beispiel: Wenn der Copper den Bus besetzt hat, seien Sie der Blitter
dass der 68000 auf den nächsten geraden Zyklus warten soll. Das Problem ist
das, mit einer Auflösung von 320x256 LOWRES mit 6 Bitplanes der 68000 muss gleich
die Hälfte der Zyklen dem Copper gewähren, um die 6 Bitplanes anzuzeigen,
insgesamt 56 pro Zeile. Im Falle eines 640x256 HIRES mit 16 Farben oder
4 Bitebenen "stiehlt" der Copper fast alle Zyklen dem 68000.
Folglich verlangsamt sich das Programm (wenn auf dem Computer kein FAST RAM vorhanden ist).

Die DMA-Zugriffe während der Rasterzeile folgen einem genauen Muster: Wir haben
die geraden Zyklen zwischen dem COPPER, dem BLITTER und dem 68000 aufgeteilt.
Bei ungeraden Zyklen erfolgt der Zugriff auf DISC, AUDIO, SPRITE und BITPLANE in
dieser Reihenfolge: Von der horizontalen Linie $7 bis $c finden die Zugriffe 
der DMA-DISC, von der $D-Linie bis zu $​​14 AUDIO, von $15 bis $34 SPRITE, schließlich 
von $35 bis $e0 die für BITPLANES statt.
Wir fassen zusammen:

- KARTE DES DMA-ZUGRIFFS IN JEDER RASTERLINIE -

EINZELZYKLEN: Es gibt 113 und die sind zwischen Copper, Blitter und 68000 aufgeteilt, wobei
der Copper die höchste Priorität hat. Wenn wir also eine hohe Auflösung, z.B. 640x256 bis 4 Bitebenen haben, 
kann der 68000 fast nie auf den Speicher zugreifen, was sehr offensichtlich zu einer Verlangsamung führt.
Die einzige Abhilfe ist, den Code in den FAST RAM zu setzen, wo es keine Verlangsamung des Prozessors gibt.
Unter anderem im 68020-Prozessoren und höher ist der Code im Fast-RAM immer
viel schneller als der im CHIP-RAM.

Ungerade Zyklen: Es sind 113 und werden in Audio, Disc und Sprite aufgeteilt
Ordnung: horizontale Linie:

			$07 - $0C	Zugriff durch DMA DISC
			$0d - $14	Zugriff durch 4 Kanäle DMA AUDIO
			$15 - $34	Zugriff durch 8 Kanäle DMA SPRITE
			$35 - $e0	Zugriff durch Bitplane in Speicher

In der Realität ist es für die Zwecke der Programmierung nicht erforderlich, diese technischen Details zu kennen,
aber sie können deutlich machen, wie wichtig es ist, die DMA-Kanäle für eine maximale Betriebsgeschwindigkeit 
wirtschaftlich zu machen.

Wenn Sie in Ihrer Programm beispielsweise einen Bildschirm in HAM oder HIRES 
am oberen Rand des Bildschirms haben, während Sie darunter andere Dinge drehen
in niedriger Auflsöung. Für den Zeitraum von der ersten Zeile bis zum Ende von
"Herausfordernder" Bildschirm wie DMA (z.B. 16-Farben-Einstellungen) werden auch der Prozessor
und der Blitter langsamer und können es in der verbleibenden Zeit nicht unter der Figur schaffen.
Um Geschwindigkeit zu kaufen, können Sie zunächst die 16 Farben nur dort aktivieren,
wo sie tatsächlich benötigt werden, Beispiel:


----------- Bildschirmstart, BPLCON0 für 16 Farben HIRES eingestellt 
\ schwarzer Raum
/
 *** ###***  ##***##  ##**  ##* #* # # # *#*#       ### * ***#*##
 *** ###***  ##***##  ##**  ##* #* # # # *#*#       ### * ***#*## > Bild
 *** ###***  ##***##  ##**  ##* #* # # # *#*#       ### * ***#*##
\ Schwarzer Raum
/
----- bplcon0 für kleinere Auflösung eingestellt

 **
				**	> 3D ROTIERENDE KUGELN UND WÜRFEL
		**
----- Schwarzer Raum


----- Ende Bildschirm, dc.w $ffff,$fffe

In diesem Fall sehen Sie den Ablauf einer Copperliste. Nehmen wir an, dass alle
3D-Routinen unter der Bild nur wenig brauchen, um rechtzeitig ausgeführt zu werden
zum jedem Fünfzigstel. Ändern Sie einfach die Copperliste und die Routine leicht
könnte es kann mit einem Frame pro Sekunde drehen, mal sehen, was zu tun ist:

COPPERLIST
	dc.w	$100,$200	; 0 Bitplanes im Anfangsbereich "SCHWARZ"
	dc.w	$3507,$fffe	; Warten Sie auf die Zeile, in der die Figur beginnt
	dc.w	$100,$c200	; Aktiviere 16 Farben
	dc.w	$a007,$ffe	; Warten Sie auf die Zeile, in der die Figur endet
	dc.w	$100,$200	; 0 Bitplanes im Bereich unter dem Bild
	dc.w	$b007,$fffe	; warte auf das Ende der schwarzen Zone
	dc.w	$100,$3200	; 3 Bitplanes lowres für Vektor-Routine
	dc.w	$e007,$fffe	; Die Zahlen kommen nicht unterhalb dieser Linie an
	dc.w	$100,$200	; Schalten Sie das DMA BITPLANE für immer aus
						; und vielleicht machen wir eine Nuance mit COLOR0 und WAIT,
						; um die Unterseite des Monitors zu füllen, ohne einzugreifen
						; auf die DMA
	dc.w	$ffff,$fffe

Um zu übertreiben, könnten wir auch das Videofenster einschränken, in dem sich die Figuren befinden.
Sie füllen den gesamten Bildschirm nicht horizontal aus. Lass uns diesen Fall machen:
Wir haben einen 3D-Körper, der sich in der Mitte des Bildschirms dreht, und wir haben  
die DMA-Bitplane darüber und darunter bereits geschlossen:

---------- Startbildschirm, dc.w $100,$200



----------------   /\   --- fester Start, dc.w $100,$3200
				  / |\
				 /  | \
				/   |  \
				\___|__/
--------------------------- festes Ende, dc.w $100,$200

------------- Ende Bildschirm, dc.w $ffff,$fffe

Wie Sie sehen, dreht sich der Körper in der Mitte des Bildschirms und nimmt niemals Platz 
die Bereiche ganz rechts und ganz links auf dem Bildschirm ein. An diesem Punkt
könnten wir auch auf DIWStrt und DIWStop reagieren, um den Bildschirm ein wenig zu "schließen",
wenn wir nur die notwendige Breite machen, können wir so oft wie nötig 
für größere Designs darüber oder darunter "vergrößern":

	dc.w	$8E,$2c81	; DiwStrt Größe normal für große Figuren
	dc.w	$90,$2cc1	; DiwStop Größe normal

	WAIT

	dc.w	$8E,$2c91	; DiwStrt im festen Bereich eingeschränkt
	dc.w	$90,$2cb1	; DiwStop

Durch die Beschränkung des Videofensters sparen wir tatsächlich DMA-Zeit ein, da
die Übertragung der Bitplane nur in dem Bereich innerhalb des definierten Videofensters erfolgt.

Wir schließen diese Klammer und sehen, wie diese Kanäle geöffnet und geschlossen werden.
Im Amiga gibt es ein Hardwareregister ($dff096) namens DMACON (= DMA-Controller), der jeden
einzelnen DMA-Kanal steuert.
Die DMAConW ($dff096) dient nur zum Schreiben von Änderungen, während das
DMAConR ($dff002) nur zum Lesen der verschiedenen Bits dient.
Hier ist die Karte der 2 Register $dff096 und $dff002: (die gleiche aber eine zum Lesen und
eine für das Schreiben). Das Register ist BITMAPPED wie $dff100 (BPLCON0) was bedeutet, das 
entscheidend ist, welche Bits einzeln ein- oder ausgeschaltet werden:

 (HINWEIS: Die Bits 13 und 14 sind schreibgeschützt (R), 15 sind lesegeschützt (W).)

 DMACON ($dff096/$dff002)

bit- 15 DMA Set/Clear				(W)	(man kann nur schreiben $dff096)
     14 BlitBusy (oder BlitDone)	(R)	(Sie können nur auslesen $dff002)
     13 Blit Zero					(R)	(man kann nur lesen)
     12 X								(nicht benutzt)
     11 X								(nicht benutzt)
     10	BlitterNasty (BlitPri)		(R/W)	(R/W = Sowohl lesbar als auch beschreibbar)
      9	Master (DmaEnable)			(R/W) - "allgemeiner Schalter"
      8	DMA BitPlane (RASTER)		(R/W) - auch genannt BPLEN
      7 DMA Copper					(R/W) - auch genannt COPEN
      6 DMA Blitter					(R/W) - auch genannt BLTEN
      5 DMA Sprite					(R/W) - auch genannt SPREN
      4 DMA DISK					(R/W) - auch genannt DSKEN
      3 DMA Audio3 (Stimme 4)		(R/W) - nämlich AUD3EN
      2 DMA Audio2 (Stimme 3)		(R/W) - nämlich AUD2EN
      1 DMA Audio1 (Stimme 2)		(R/W) - nämlich AUD1EN
      0 DMA Audio0 (Stimme 1)		(R/W) - nämlich AUD0EN

* SET / CLR
- Bit 15 ist sehr wichtig: Wenn es eingeschaltet ist, werden die Bits auf 1 in gesetzt
 Das Schreiben in $96 wird verwendet, um den zugehörigen DMA einzuschalten, wenn Bit 15 0 ist.
 dann werden die anderen 1-Bit-Bits im Register zum Ausschalten der entsprechenden Kanäle verwendet.

 Lassen Sie es mich erklären: Einen oder mehrere Kanäle trotzdem ein- oder ausschalten
 Die relativen Bits müssen auf 1 gesetzt werden, was entscheidet ob die
 Kanäle ausgeschaltet oder eingeschaltet werden sollen und Bit 15: Wenn es 1 ist, schalten sie ein.
 Bei 0 schalten sie aus immer unabhängig von ihrem vorherigen Zustand.
 Nehmen wir an, Sie wählen die zu bearbeitenden aus und entscheiden dann, ob Sie ausschalten (0) oder
 Einschalten (1) wollen gemäß Bit 15.
 Nehmen wir ein Beispiel:

			;5432109876543210
	move.w #%1000000111000000,$dff096	; die Bits 6, 7 und 8 sind eingeschaltet
			;5432109876543210
	move.w #%0000000100100000,$dff096	; Bits 5 und 8 sind AUS.

N. B .: DIE BITS 14-10 IN BEZUG AUF DEN BLITTER UND DIE CHIP-CLOCK-ZYKLEN,
      wird im Folgenden ausführlich diskutiert.
      In dieser Lektion werden sie nicht verwendet.

* BlitBusy
- Bit 14 ist schreibgeschützt (Sie können es NUR aus $dff002 lesen) und dient dazu zu
 wissen, ob der Blitter zu diesem Zeitpunkt "blitting" ist (d.h. arbeitet).
 Dieses Bit wird verwendet, um zu wissen, ob der Blitter arbeitet oder nicht.
 Tatsächlich ist es, wie wir später sagen werden, nicht möglich,
 während  der Blitter er noch blittet ... in der Tat ist es aber möglich
 eine Katastrophe würde passieren! Sie müssen also warten, bis dieses Bit bei 0 ist
 Vor der Wiederverwendung des Blitters.

* Blit Zero
- Bit 13 wird nur gesetzt, wenn das Ergebnis einer Blittata 0 ist, das heißt
 wenn der modifizierte RAM mit irgendwelchen Blittata komplett war wird das Bit
 auf 0 gesetzt. Es kann in vielen Situationen vorkommen.
 Lesen Sie dieses Bit nur in seltenen Fällen auf die Wahrheit (zB: check
 ob zwei Bob-Objekte kollidieren, ohne den RAM zu ändern. Darauf gehen wir 
 später tiefer ein.

-Die Bits 12-11 werden im Moment von der Maschine nicht verwendet.

* BlitPri
- Wenn Bit 10 gesetzt ist, verwendet der Blitter alle Buszyklen von den verfügbaren
 Chips. Er "stiehlt" sogar die wenigen, die für den armen 68000 verfügbar sind.
 Der Zugriff auf Fast oder ROM wird nicht verlangsamt,
 andernfalls wird sogar beim Zugriff auf den Chip gestoppt.
 In der Praxis, wenn dieses Bit auf 1 steht, hat der Blitter einen vollen Wert oder
 die komplette Priorität gegenüber der 680x0.

* DmaEn / Master
- Bit 9 ist der allgemeine Schalter: Es muss auf 1 gesetzt werden um
 die DMAs der verschiedenen Geräte zum Laufen bringen. Sie können es beispielsweise durch Ausschalten
 vorübergehend alle Kanäle deaktivieren, ohne einen Reset des ganzen Registers durchzuführen.

-Die 8-0-Bits werden zum Ein- und Ausschalten der DMA-Kanäle der verschiedenen Geräte verwendet.

Grundsätzlich sind nur die 10-0 Bits mit Bit 15 umschaltbar (austauschbar).
Versuchen wir zum Beispiel, nur die DMAs der Bitplanes, des Coppers und das Blitter DMA einzuschalten.
Dazu müssen Sie zunächst die Register zurücksetzen.
Schalten Sie alle Kanäle aus und deaktivieren Sie damit unerwünschte DMA und
dann werden die gewünschten DMAs eingestellt:

	move.w	#$7fff,$dff096			
						; $7fff = %0111111111111111
						; das heißt: alles aus: die
						; Bit 15 ist daher NULL
						; alle 1 bedeuten
						; in diesem Fall AUSSCHALTEN.
			; 5432109876543210
	move.w	#%1000001111000000,$dff096	; 
						; Bits 6,7,8,9 gesetzt, das heißt
						; Blitter, Kupfer, bitplane
						; und allgemeiner Schalter
						; Bit 15 bis 1, also alle
						; 1 bedeutet EINSCHALTEN


Der Wert $7fff ist %0111111111111111, daher werden alle DMA-Bits zurückgesetzt.
Dann werden die DMAs des Coppers, der Bitplanes und des Blitters und der Master eingestellt
und dank Bit 15 auf 1 gesetzt!

DIE FUNKTION DIESES WICHTIGEN REGISTERS IST ANALOG ZU DEM REGISTER 'INTENA' UND 'INTREQ'
-, DARUM NICHT WEITERMACHEN, bis sie keine Zweifel haben über die Bit-Funktion 15 BIT EIN- / AUSSCHALTEN.

In den Listings, die wir bisher gesehen haben, wurden die Register 
$dff096 (DMACON) und $dff002 (DMACONR) niemals verwendet, weil wir davon ausgegangen sind
das die DMA-Kanäle von Copper, Bitplane und Sprites aktiviert wurden.

In der Tat, zum Zeitpunkt der Ausführung des Programms können Sie es am 
Bildschirm des ASMone sehen, dass sowohl COPPER als auch BITPLANE DMA aktiviert sind. 
Der Zeigerpfeil zeigt an, dass er angezeigt wird mit dem DMA SPRITE.

Bei einer Programmierung auf Hardwareebene könenn wir keine Kompromisse machen. Wir dürfen 
nicht "hoffen", dass alles so ist, wie wir wollen. Wir haben schon gesehen, wie wichtig es 
ist, alle Copperlistenregister wie BPL1MOD, DIWSTART / STOP usw. zu setzen, um das Auffinden 
von "falschen" Werten zu vermeiden.
 
Das Gleiche tun wir mit den DMA-Kanälen: Wir speichern den Status am Anfang
dann werden wir sie alle ausgeschalten und nur die gewünschten eingeschaltet.
Am Ende des Programms werden wir die DMA-Kanäle genauso wieder in den ursprünglichen Zustand bringen.
Lass uns dies für die Copperliste tun.
Wir haben gesagt, dass zum Lesen des DMACON-Status das Lesen von DMACONR erforderlich ist,
Das ist der $dff002. Eine "Speichern" -Routine könnte sein:

	move.w	$dff002,OLDDMA	; DMACONR - mit Ausnahme des Status der DMA

Jetzt können wir es nach Belieben ändern, indem wir auf das Register $dff096 schreiben:

	move.w	#$7fff,$dff096	; DMACON - Alle Kanäle zurücksetzen

			; 5432109876543210
	move.w	#%1000001110100000,$dff096 ; einschalten Copper,Bitplane und Sprite

Nichts könnte einfacher sein. Nun müssen wir zuerst den alten Wert in den Ausgang zurücklegen.
Aber 'ACHTUNG! Wir können OLDDMA nicht direkt in DMACON ($dff096) schreiben, so
wie wir es von DMACONR ($dff002) lesen, weil Bit 15, das SET / CLR,  schreibgeschützt 
und beim Lesen immer Null ist.

Dadurch wird der Wert mit Bit 15 zurückgesetzt, und die Bits werden nicht gesetzt.
Das Einschalten der DMA-Kanäle würde sie schließlich ausschalten.

Deshalb setzen Sie den Wert mit dem Zurücksetzen des Bits 15 zurück und statt die Bits 
zu setzen um die DMA-Kanäle einzuschalten, werden dies schließlich ausgeschaltet. So 
dient Bit 15 zuerst den in OLDDMA gespeicherten Wertes zu setzen. Auf diese Weise werden 
die Bits gesetzt. Aber wie kann man Bit 15 in einem Wort auf eins setzen?

Es gibt unendlich viele Möglichkeiten. Eine wäre, die BSET-Anweisung zu verwenden.
zum Beispiel:

	move.w $dff002,d0				; Mit Ausnahme der DMACONR in d0
	bset.l #15,d0					; Bit 15 (SET / CLR)
	move.w d0,OLDDMA				; und speichern Sie den Wert in OLDDMA
	...
	bsr.w Routinen
	...
	move.w #$7FFF,$dff096			; Alle Kanäle zurücksetzen
	move.w OLDDMA(PC),$dff096		; reaktiviere nur diejenigen, die 
	rts								; am Anfang aktiv waren.

Ansonsten kann die ODER-Anweisung verwendet werden. Erinnern wir uns an seinen Wirkungsweise:

 0 ODER 0 = 0
 0 ODER 1 = 1
 1 ODER 0 = 1
 1 ODER 1 = 1
  
Das erste Beispiel würde werden:

	or.w	#$8000,OLDDMA			; $8000 = %1000000000000000, das heißt, Bit 15 auf 1

Wie Sie der obigen Tabelle entnehmen können, verlassen die genullten Bits das
Ziel. In diesem Fall werden die ersten 14 Bits zurückgesetzt. Also die ersten 14 Bits
Bits von OLDDMA bleiben nach diesem ODER unverändert (0 ODER 0 = 0, 0 ODER 1 = 1).
Da das Bit 15 gesetzt ist, haben wir 1 ODER 0 = 1, also setzen wir das
Bit 15 und die anderen 14 Bits bleiben unverändert. Das gleiche wie bei BTST #15,d0.
Bei der Inbetriebnahme ist es besser, das ODER zu verwenden, da auch andere Register 
zusätzlich zu DMACON gespeichert werden. Dies ist INTENA ($dff09a Schreiben und $dff01c 
Lesen), INTREQ ($dff09c Schreiben und $dff01e Lesen) und ADKCON ($dff09e Schreiben
und $dff010 Lesen). Für den Moment kann ich Ihnen nur das vorwegnehmen, das die
Register wie DMACON bitmaskiert werden und funktionieren analog mit dem Bit 15, das als
SET / CLR dient. INTENA und INTREQ werden für Interrupts verwendet, während ADKCON für
verschiedene Aufgaben für DISK DRIVE und AUDIO dient. Wir werden sehen, wie man diese 
Register benutzt, wenn Interrupts und Audio behandelt werden. Speichern sie jetzt
den Status vom DMACON. Nun wollen wir sehen, wie man diese 4 Register speichert:

	LEA	$DFF000,A5				; Basis der CUSTOM-Register für Offsets
	MOVE.W	$2(A5),OLDDMA		; DMACONR - Speichern Sie den Status der DMA
	MOVE.W	$1C(A5),OLDINTENA	; Speichern Sie den alten Status von INTENA
	MOVE.W	$10(A5),OLDADKCON	; Speichern Sie den alten Status von ADKCON
	MOVE.W	$1E(A5),OLDINTREQ	; Speichern Sie den alten Status von INTREQ

Jetzt müssen wir Bit 15 von allen 4 Wörtern OLDDMA, OLDINTENA, OLDADKCON, OLDINTREQ
setzen, um den Ausgangswert wiederherzustellen.
Beachten Sie, dass die 4 Marken nacheinander eingefügt werden:

OLDDMA:			; alter Status DMACON
	dc.w	0
OLDINTENA:		; alter Status INTENA
	dc.w	0
OLDADKCON:		; alter Status ADKCON
	DC.W	0
OLDINTREQ:		; alter Status INTREQ
	DC.W	0

Also kommt das OR ins Spiel. Für ein Wort machen wir ein OR.w #$8000,dest.
Damit können wir mit nur einem ODER ein Wort arrangieren. 
Mit einem OR.l #$80008000,dest !!! können wir für 2 Wörter ein ODER erreichen.

	MOVE.L	#$80008000,d0		; Bereiten Sie die High-Bit-Maske vor
								; zum Setzen in den Worten, wo
								; die Bits gespeichert wurden 
	OR.L	d0,OLDDMA			; Stellen Sie das 15-Bit aller gespeicherten Werte ein
	OR.L	d0,OLDADKCON		; der Hardware-Register, unverzichtbar für
								; Setzen Sie diese Werte wieder in die Register.

Hier haben wir mit ein paar Anweisungen alle 4 Register gespeichert und "gesetzt"
dass wir danach sofort zurücksetzen werden:

	MOVE.L	#$7FFF7FFF,$9A(a5)	; Deaktivieren Sie INTERRUPTS & INTREQS
	MOVE.L	#0,$144(A5)			; SPR0DAT - töte den Zeiger!
	MOVE.W	#$7FFF,$96(a5)		; Deaktivieren Sie den DMA

An dieser Stelle können wir nur die DMA-Kanäle aktivieren, die wir benötigen.
Am Ausgang genügt es, alle Register zurückzusetzen und wiederherzustellen:

	MOVE.W	#$7FFF,$96(A5)			; Deaktivieren Sie alle DMAs
	MOVE.L	#$7FFF7FFF,$9A(A5)		; DEAKTIVIERT DIE INTERRUPTS & INTREQS
	MOVE.W	#$7fff,$9E(a5)			; Deaktivieren Sie die ADKCON-Bits
	MOVE.W	OLDADKCON(PC),$9E(A5)	; ADKCON 
	MOVE.W	OLDDMA(PC),$96(A5)		; Gib den alten DMA-Status zurück
	MOVE.W	OLDINTENA(PC),$9A(A5)	; INTENA STATUS
	MOVE.W	OLDINTREQ(PC),$9C(A5)	; INTREQ

Nichts könnte einfacher sein! Wir haben jetzt die vollständige Kontrolle über die DMA-Kanäle und
wir sind sicher, dass wir sie aktivieren und deaktivieren können. Am Ausgang werden sie wiederhergestellt.

Um unseren Start abzuschließen, könnten wir einen EQUATE definieren. Erinnere dich, was die EQUATES sind?
Die Assembler-Direktiven EQU oder = definieren die Gleichheit zwischen beliebig erfassten Wörtern und Zahlen, zB:

CANE	EQU	10
GATTO	EQU	20

	MOVE.L	#CANE,d0	; wird assembliert als MOVE.L #10,d0
	MOVE.L	#GATTO,d1	; assembliert als MOVE.L #20,d1
	ADD.L	d0,d1		; Ergebnis = 30
	rts

Equates sind ähnlich wie Labels, enden jedoch nicht mit i:. Anstelle von EQU können
Sie auch das Gleichheitszeichen (=): verwenden

CANE	=	10

Wir könnten einen EQU für die einzustellenden DMA-Kanäle definieren:

		;5432109876543210
DMASET	EQU	%1000001110000000	; copper- und DMA-Bitplane aktiviert
;		 -----a-bcdefghij

;	a: Blitter Nasty   (Im Moment ist es uns egal, lassen wir es auf Null
;	b: Bitplane DMA	   (Wenn es nicht gesetzt ist, verschwinden auch die Sprites)
;	c: Copper DMA	   (Sogar die copperliste wird nicht auf Null zurückgesetzt)
;	d: Blitter DMA	   (Für jetzt sind wir nicht interessiert)
;	e: Sprite DMA	   (beim Zurücksetzen verschwinden die 8 sprites)
;	f: Disk DMA		   (Im Moment sind wir nicht interessiert)
;	g-j: Audio 3-0 DMA (Wir setzen den Amiga auf Null zurück)

Wie Sie sehen können, müssen die Bits 15 und 9 IMMER EINGESTELLT sein, da eines davon das 
SET / CLR und der andere der Master, der Generalschalter ist.
In der Liste können Sie Folgendes eingeben:

	MOVE.W	#DMASET,$96(a5)		; DMACON - aktivieren bitplane und copper

Auf diese Weise können wir zu Beginn des Listings den EQU haben, mit dem geändert werden soll
Nachfolgend finden Sie eine kurze Zusammenfassung der Bedeutung der Bits.

Aber sehen wir uns den Start an, laden Sie Lezione8a.s in einen Textpuffer und studieren Sie es.
Im letzten Kommentar gibt es einige Anmerkungen zu einigen geringfügigen Änderungen.

 З                                                                З
   І                          . .__                                 :
   :                          З^ЗЏЏ\                              __Ё__
_ _|__  _______ ____________  /\    \______________ _________ ____\  //____ _
Џ Џ|ЏЏ  ЏЏЏЏЏЏЏ ЏЏЏЏЏЏЏЏЏЏЏЏ\/  \    ЏЏЏЏЏЏЏЏЏЏЏЏЏЏ ЏЏЏЏЏЏЏЏЏ ЏЏЏЏЏ\//ЏЏЏЏЏ Џ
   :                  _ј ,       \__. .                             І
   І                 //\/         ЏЏЗ^З   /\__. .                   :
   З                '/\                  /  ЏЏЗ^З                   :
_ _|___ ____________/ /_____ _________  /     /\________ ______ ____|______ _
Џ Џ|ЏЏЏ ЏЏЏЏЏЏЏЏЏЏЏЏЏ ЏЏЏЏЏЏ ЏЏЏЏЏЏЏЏЏ\/     /  ЏЏЏЏЏЏЏЏ ЏЏЏЏЏЏ ЏЏЏЏ|ЏЏЏЏЏЏ Џ
   І                            .    . .__  /                       З
   :                   "COi! аe$ІgN" З^ЗЏЏ\/                        :
   .                                                                З
   З                                                                .
   .                                                                .

Nun, da wir das "universelle" Startup haben, können wir es auch in eine Datei einordnen
und fügen es zu Beginn der nächsten Listings in mit der INCLUDE - Direktive ein,
die wir bereits verwendet haben, um die musikalische Routine einzubeziehen.
Es reicht aus, jedes Listing mit einem:

	Section	UsoLaStartUp,CODE

*****************************************************************************
	include	"startup1.s"	; mit diesem include ersparen wir es uns,
							; es immer neu zu schreiben!
*****************************************************************************

Beachten Sie, das der Start des Startup1.s ohne SECTION ist, also müssen wir
vor jedem include den SECTION-Direktivennamen, CODE oder CODE_C eingeben.
Das Startup führt ein "BSR.S START" aus. Wir starten die Auflistung mit:

START:
	MOVE.W	#DMASET,$96(a5)		; DMACON - aktivieren Bitplane, copper
								; und Sprites.

	move.l	#COPPERLIST,$80(a5)	; Zeiger auf COP
	move.w	d0,$88(a5)			; Start COP
	move.w	#0,$1fc(a5)			; Deaktivieren Sie AGA
	move.w	#$c00,$106(a5)		; Deaktivieren Sie AGA
	move.w	#$11,$10c(a5)		; Deaktivieren Sie AGA

Bedenken Sie, dass $dff000 in a5 steht. In diesem Fall habe ich es genutzt.

Es sieht nach einem perfekten Start aus, aber es fehlt ihm noch das Sahnehäubchen.
Dieses Sahnehäubchen ist die Möglichkeit, das Programm mit einem Symbol ohne Probleme 
von der WorkBench zu starten. In der Tat, solange wir es vom cli / shell starten
brauchen unsere Programme nur diesen Start, aber wenn Sie ein Icon designen wollen
um das Programm mit einem Doppelklick von der WorkBench aus zu starten, fügen Sie 
einige Anweisungen hinzu. Es ist nur eine bürokratische Formalität, aber wenn es nicht 
bei großen Programmen gemacht wird, die auch Speicher zuweisen, kann es passieren
das am Ende nicht der gesamte Speicher wieder freigegeben wird.
Folgendes müssen Sie am Anfang hinzufügen:

ICONSTARTUP:
	MOVEM.L	D0/A0-A1/A4/A6,-(SP)	; speichern Sie die Register auf dem stack
	SUBA.L	A1,A1
	MOVEA.L	4.w,A6
	JSR	-$126(A6)					; _LVOFindTask(a6)
	MOVEA.L	D0,A4
	TST.L	$AC(A4)					; pr_CLI(a4) wir laufen davon CLI?
	BNE.S	FROMCLI					; Wenn ja, überspringen Sie die Formel
	LEA	$5C(A4),A0					; pr_MsgPort
	MOVEA.L	4.W,A6					; Execbase in a6
	JSR	-$180(A6)					; _LVOWaitPort
	LEA	$5C(A4),A0					; pr_MsgPort
	JSR	-$174(A6)					; _LVOGetMsg
	LEA	RETURNMSG(PC),A0
	MOVE.L	D0,(A0)
FROMCLI:
	MOVEM.L	(SP)+,D0/A0-A1/A4/A6	; Register wiederherstellen vom stack
	BSR.w	MAINCODE				; Führen Sie unser Programm aus
	MOVEM.L	D0/A6,-(SP)
	LEA	RETURNMSG(PC),A6
	TST.L	(A6)					; Wir fingen von CLI an?
	BEQ.S	ExitToDos				; Wenn ja, überspringen Sie die Formel
	MOVEA.L	4.w,A6
	JSR	-$84(A6)					; _LVOForbid - Achtung! Es ist keine Genehmigung erforderlich
	MOVEA.L	RETURNMSG(PC),A1
	JSR	-$17A(A6)					; _LVOReplyMsg
ExitToDos:
	MOVEM.L	(SP)+,D0/A6				; exit code
	MOVEQ	#0,d0
	RTS

RETURNMSG:
	dc.l	0

Ich werde nicht ausführlich auf die Aufrufe der Systembibliotheken eingehen.
Es genügt zu sagen, dass dies die Formalitäten sind, über die ich gesprochen habe.
Wenn Sie ein Workbench-Programm ausführen, das diesen Code nicht am Anfang hat,
ist das größte Problem, das beim Beenden dieses Programms, der belegte Speicher 
nicht wieder freigegeben wird!!!
Wie Sie sehen, wird zu Beginn geprüft, ob das Programm von der CLI oder von der WorkBench aus 
ausgeführt wurde, wobei ein spezielles Systemflag geprüft wird.
Wenn das Programm von der CLI gestartet wurde, werden die Formalitäten die bei der Ausführung von 
der WB folgen übersprungen, ansonsten werden diese Formalitäten ausgeführt.
Anstatt diesen Teil mit dem anderen Startup zu verbinden, sollten Sie es 
daher auswählen, ob Sie es aufnehmen möchten oder nicht, da einige Assembler
die modifizierte ASMONE-Version des Kurses enthalten, zum Zeitpunkt der Ausführung, verursacht
es eine Endlosschleife, da wie es "scheint" von der WorkBench geladen wurde.
Der Zeitpunkt der Ausführung der "Formalitäten" scheint das Gegenteil zu sein. Mehr
Versionen von Asmone oder anderen Assemblern dagegen führen diesen Code sicher aus, aber
aus Gründen der Kompatibilität mit jedem Assembler schlagen wir es vor
Teil:

;	Include	"DaWorkBench.s"	; entferne das; vor dem Speichern mit "WO"

Auf diese Weise schließen wir es bei den Assemblieren und Testen mit "J" nicht ein.
Vor dem Speichern der endgültigen ausführbaren Datei mit "WO" fügen wir es hinzu.

Laden Sie die Lektion 8b, das erste Listing, das den universellen Startvorgang,
durch einbinden der INCLUDE-Datei verwendet. Es umfasst die Verwendung sowohl von Bitplanes als 
auch von Sprites, für die Sie Tests durchführen können, um das Verhalten der DMA-Kanäle zu 
überprüfen.
__   __            __            __     __            __            __   __
 /\_/_/\__   __   / /\__   __   / /\   /\ \   __   __/\ \   __   __/\_\_/\
/ / \_\/_/\_/_/\_/_/ / /\_/_/\_/_/  \_/  \_\_/\_\_/\ \ \_\_/\_\_/\_\/_/ \ \_
\/     \_\/ \_\/ \_\/_/ / \_\/ \ \  / \  / / \/_/ \ \_\/_/ \/_/ \/_/     \/_
-:-----:------------\_\/--------\_\/---\/_/--------\/_/---------------------

Haben Sie Angst, wenn Sie die NEUE Routine sehen, die auf die vertikale Zeile wartet?
Nun, es ist nichts Monströses, aber sie ist viel besser.
Analysieren wir die alte "Routine":

	cmp.b	#$xx,$dff006	; VHPOSR

Nun, überprüfen wir einfach das Byte $dff006, das die vertikale Position 
des elektronischen Rasterstrahls in den Bits von 0 bis 7, das heißt von $00 bis $ff enthält.
Aber wie Sie vom WAIT-Management in der Copperliste wissen, überschreitet der elektronische Rasterstrahl
die $FF-Zeile, was in Wirklichkeit nicht die 200 in einem normalen Bildschirm ist.
Um die Positionen hinter dem $FF mit dem COPPER WAIT zu erreichen, haben wir gesehen
dass wir auf das Ende dieser Zone warten müssen:

	dc.w	$FFDF,$FFFE	; Warten Sie auf das NTSC-Zonenlimit

Danach startet der Zähler ab $00

	dc.w	$0007,$FFFE	; Warte auf Zeile $100
	dc.w	$0107,$FFFE	; Warte auf Zeile $FF+$01=$101

Nun zu $38. Nun, selbst das Byte in $dff006 verhält sich so: 
Sobald die Position $ff erreicht ist, beginnt sie mit $00, jedoch mit $100 und
geht bis zu $​​138 (mit $38), wonach es bei $00 beginnt, der wahren NULL, 
dann wieder zurück zu $ff, um die anderen $38 zu bekommen usw.
Aus diesem Grund wird in den Listings immer die $FF-Zeile oder die $80-Zeile erwartet, weil
das Warten auf die $00-Zeile oder die $20-Zeile mit dem $dff006 bedeuten würde, das
die Routine 2 Mal pro Frame erfolgt, da $00 an der $00-Zeile 
und bei der $100-Zeile auftritt.
Aber wie können wir sicher auf die ersten 38 Zeilen und die Zeilen nach dem $ff warten? 
Kurz gesagt, Sie brauchen eine Routine, mit der Sie ohne einen Fehler 
auf eine der 312 Abtastzeilen warten könnnen.
Es ist nicht schwierig, da das HIGH-Bit, das achte, welches sehr nahe an $dff006 ist, 
genau genommen ist es das erste Byte im $dff005. Wir müssen das gleiche machen, wie wir
es mit der vertikalen Sprite-Position getan haben. In der Tat haben wir das hohe Bit 
einzeln. In diesem Fall handelt es sich jedoch nicht um den Speicher, sondern um
das betreffende Byte. Lassen Sie uns die Situation analysieren:

$dff004 Byte, das uns jetzt nicht interessiert, enthält das LOF-Bit für das Interlace
$dff005 wir sind interessiert Bit 0 ist V8, dh das High-Bit von der vertikalen Position
$dff006 jetzt wissen wir es! die Bits V7-V0, die niedrigen 8 Bits der vertikalen Position
$dff007 enthält die horizontale Position (H8-H1). Die Auflösung beträgt 1/160
		des Bildschirms. Jetzt interessiert uns das nicht wirklich !!!

Das $dff004/$dff005 ist das VPOSR-Register, während das $dff006/$dff007 das VHPOSR ist.
Jedes Register ist tatsächlich ein WORD lang. Wir können jedoch in einigen Fällen auf die 
Einzelbytes zugreifen. Um auf die $100-Zeile zu warten, können wir Folgendes tun:

WaitVbl:
	btst.b	#0,$dff005
	beq.s	WaitVbl

Diese Routine wartet auf das Setzen des High-Bits V8. Wenn es gesetzt ist
bedeutet das, dass wir an der $100-Linie sind oder zumindest danach.
Um eine UNIVERSAL-Routine auszuführen, können wir Folgendes tun: (a5 = $dff000)

Waity1:
	MOVE.L	4(A5),D0	; $dff004 und $dff006, nämlich VPOSR und VHPOSR
	LSR.L	#8,D0		; verschiebt die Bits um 8 Positionen nach rechts
	AND.W	#%111111111,D0	; Wählen Sie nur die Bits des Pos. vertikal
	CMP.W	#300,D0		; Zeile 300? ($12c)
	bne.s	Waity1

In diesem Fall haben wir $dff004/5/6/7 nach d0 kopiert, dann verschieben wir das Ganze
um 8 Bits nach rechts. Da die ersten 8 Bits von rechts mit der horizontale Position des 
$dff007 belegt sind, die uns nicht interessiert, bringt die Position nach ganz rechts. 
An dieser Stelle wählen wir mit einem AND nur die ersten 8 Bits, dh die des $dff006 plus 
das High des $dff005 aus.
Auf diese Weise haben wir in d0 die reelle Zeilennummer von 0 bis 312!
Ich erinnere Sie daran, dass der AND-Befehl diesen Effekt hat:

 0 AND 0 = 0
 0 AND 1 = 0
 1 AND 0 = 0
 1 AND 1 = 1
Tatsächlich ergibt AND nur dann 1, wenn das Bit des ersten Operanden und des
zweiten Operanden auf 1 steht. Der Befehl könnte übersetzt werden mit
"SIND DAS ERSTE UND DAS ZWEITE BIT 1?", WENN JA, ANTWORTEN SIE MIT 1, WENN NEIN
ANTWORTEN SIE MIT EINER NULL". Ein UND ist tatsächlich nützlich, um bestimmte Bits 
einer Zahl zurückzusetzen. In unserem Fall haben wir die hohen Bits zurückgesetzt:

	AND.W	#%00000000000000000000000111111111,d0

Vielleicht erscheint es hexadezimal klarer:

	AND.W	#$000001FF,D0	; nur das low byte plus bit 8.


Der einzige Nachteil besteht darin, dass Sie 4 Anweisungen benötigen. Versuchen wir, 
eine Routine zu schreiben die nur 3 Anweisungen verwendet:

WBLANNY:
	MOVE.L	4(A5),D0		; VPOSR und VHPOSR - $dff004/$dff006
	AND.L	#$0001FF00,D0	; Wählen Sie nur die Bits des vertikalen Position
	CMP.L	#$00013000,D0	; warten auf Zeile $130 (304)
	BNE.S	WBLANNY

In diesem Fall arbeiten wir das Ganze long, ohne die Bits zu verschieben (shifting).
Denken Sie daran, dass die zu wartende Zeilennummer auf der linken Seite um 
2 Ziffern verschoben ist. Um beispielsweise auf die $FF-Zeile zu warten:

	CMP.L	#$0000ff00,D0	; warten auf Zeile $FF (255)

Es ist definitiv besser und schneller. Ich empfehle, dass Sie immer diese Routine verwenden.
Ansonsten, wenn es Ihnen nichts ausmacht, ein paar Register einzuspielen.
Außerdem würde es eine problematische Version geben, die in Lezione8b.s vorhanden ist:

	MOVE.L	#$1ff00,d1	; Bit zur Auswahl durch AND
	MOVE.L	#$13000,d2	; zu wartende Zeile = $ 130 oder 304
Waity1:
	MOVE.L	4(A5),D0	; VPOSR und VHPOSR - $dff004/$dff006
	ANDI.L	D1,D0		; Wählen Sie nur die Bits des vertikalen Position 
	CMPI.L	D2,D0		; warten auf Zeile $130 (304)
	BNE.S	Waity1

Wie Sie im Wesentlichen sehen, ändert sich nichts, nur dass die Operationen nun zwischen 
Registern anstelle von Konstanten ausgeführt werden und dies ist schneller.
Die Geschwindigkeit ist wichtig, denn wenn Sie zum Beispiel auf die Zeile 50 warten müssen
haben wir mit der ersten Routine gesehen, dass auch der LSR, wenn der Prozessor
alle Tests beendet und feststellt, dass wir jetzt in Zeile 50 sind bereits
in der Mitte von Zeile 50 sind!!

Ich muss dir nur raten, auf a5 oder a6 zu achten, das Register, dass Sie als Basis verwenden, 
das dort immer $dff000 ist, was nicht von einigen Unterprogrammen überschrieben werden darf.
Um dies zu vermeiden, können Sie die Register mit MOVEM wie oben beschrieben speichern, oder 
Sie können einen LEA $dff000,a5 unter das "MOVE.L #$1ff00,d1" eingeben. 
Gleiches gilt für die Register d0, d1 und d2.
Stellen Sie sicher, dass sie nicht von anderen Programmen verwendet werden, da Sie sie ändern.

Warten Sie schließlich niemals über die $138-Linie hinaus, da es die letzte ist.
oder die Routine wird in einer Endlosschleife blockiert.

Wenn das Video auf die NTSC-Frequenz (Nullabgleich $dff1dc) eingestellt ist, wird der Grenzwert 
maximal auf die $106-Zeile festgelegt.

		 ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии
         ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии
         ииии                                                   Эииии
         ииии          ___                                      Эииии
         ииии      __ји@**#__                      ____цццц_    [ииии
         ииии     gиАЏ     А4ц_                __ји@ЄАЈЏЏЏЏЖ&   Ьииии
         ииии   ,иP          Ќ0ўИ           ,gиЄАЏ          0Q  [ииии
         ииии   и~  _______    Аи_         _иА   ___цциии,      Ьииии
         ииии       ииииииииm_   Аи_  _ ,_/иД _цииииииииД      Ьииии
         ииии       ААЄиииииииQ__  А#_и Iио _Циииииии@А         Эииии
         ииии      _    `ииииииииц_ ЌЂВ    dииибииииГ           ]ииии
         ииии     `ицИ   иии1 "ЂиииQ__    ЦиииД ЖиииИ           Ьииии
         ииии      Vи#_  #ииђ (ц Аииииј  иииА ц) Жии#    ,Ў     ]ииии
         ииии       и#и_ ЌиииQ___ииииии  Ћиииц__ Jиии   ИиF     Эииии
         ииии       Ќи_`N_ ЂиииииииВААЏ___ЌА0ииииииии  _иА      [ииии
         ииии        АиЕиб&_ ЈААА~   Ииииии, Џ~АААА"_.јиЙ       ]ииии
         ииии          #и ЌиQ_       Ќи' ЌЄА  ___цциЄАиP        Iииии
         ииии           `W_иP4MјцццццццццццциииЄА"и _иА         ]ииии
         ииии            Ќии_ 0FЏЏ7#ЏЏЏЌиЏЏЏЏTи   ии@Д          Ьииии
         ииии             Ќ#иииц._рW___jи____jи_цјиГ            [ииии
         ииии               Ђ#иFЈАЖи^^Є4иЄЄААЂиии^              [ииии
         ииии                АЋN__IN_   и___циЛА                [ииии
         ииии                   А^Є*#ииии@ЄА"            xCz    Iииии
         ииии                                                   Эииии
         ииииL__________________________________________________Iииии
         ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии
         ииииииииииииииииииииииииииииииииииииииииииииииииииииииииииии

Nun, da wir die Nützlichkeit von AND / OR / LSR-Anweisungen zum Speichern der DMA und 
zur besseren Kontrolle der VBLANK-Linie gesehen haben, kommen wir zu neuen Anwendungen
solcher logischen Anweisungen. Es besteht kein Zweifel, zu analysieren, wie
eine Fade-Routine oder ein Fading einer Figur von Schwarz allmählich in Richtung
der vollen und glänzenden Farbe (und umgekehrt) geht.
Zuerst wollen wir sehen, wo wir operieren müssen:

CopColors:
	dc.w $180,0,$182,0,$184,0,$186,0
	dc.w $188,0,$18a,0,$18c,0,$18e,0
	....

In der copperliste sind die Farbregister. Was wir tun müssen, ist
anstelle dieser Nullen die richtigen RGB-Werte (genau das Wort: $0RGB) zu setzen
und "zu sie erhöhen", so dass wir mit verschiedenen Passagen, einer pro Frame,
die Farben unserer Figur zu erreichen:

CopColors:
	dc.w $180,$000,$182,$fff,$184,$200,$186,$310
	dc.w $188,$410,$18a,$620,$18c,$841,$18e,$a73
	...

Zuerst müssen wir die Liste der Farben der Figur in einer Tabelle haben
"konsultieren", ansonsten würden wir nicht wissen, wann wir "angekommen" sind:

TabColoriPic:
	dc.w $fff,$200,$310,$410,$620,$841,$a73,...
	...

(HINWEIS: Farbe 0, $dff180, ist in dieser Tabelle nicht eingefügt,  es ist schwarz, $000.
Es bleibt immer schwarz und wir verstehen es in der Routine nicht.
Stattdessen beginnen wir mit Farbe 1, $dff182, was in diesem Fall $FFF ist.)

Um diese Tabelle zu erstellen, kopieren sie die copperliste mit dem Editor und 
entfernen Sie einfach "$180, $182, $184 von Hand". Natürlich bleiben die Farben erhalten.

Nun da wir die Tabelle mit den "Zielfarben" haben, wie kann man eine Routine machen, welche
"die richtigen Farben" in der Tabelle "erhöht"?
Sicherlich müssen wir auf jede der 3 RGB-Komponenten separat arbeiten.
Um sie zu trennen, können wir das AND verwenden, das, wie wir gesehen haben, nur 
ein Teil von Bits "auswählt" und die anderen beseitigt. Die Adresse der Tabelle mit 
den Farben haben wir in a0. Lassen Sie uns am Beispiel sehen, wie nur die blaue Komponente 
getrennt wird:

	MOVE.W	(A0),D4		; Setzen Sie die Farbe aus der Farbtabelle in d4
	AND.W	#$00f,D4	; Nur die blaue Komponente auswählen ($RGB -> $00B)

Jetzt haben wir in d4 nur den Wert der Farbe BLAU... wenn die Farbe $0123 war haben 
wir in d4 später den Wert $0003. Durch das AND.w #%000000001111,d4 werden nur die 4
Bits oder das Nibble des Wertes ausgewählt. Also haben wir das Unternehmen erfolgreich 
abgeschlossen. 
Mal sehen, wie man die grüne Komponente auswählt:

	AND.W	#$0f0,D4	; Wählen. nur die grüne Komponente ($RGB -> $0G0)

und rot:

	AND.W	#$f00,D4	; Wählen. nur die rote Komponente ($RGB -> $R00)

Soweit sollte es klar sein.
Nun konnten wir bereits die "FAKE" -Routine, die "FALSE", durchführen, die auf diese
Weise arbeitet. Jedes Mal, wenn Sie #1 zu der einzelnen Komponente hinzufügen und 
mit der Farbe in der Tabelle auf 1 vergleichen, müssen Sie das Hinzufügen auf
diese Komponente beenden. Wenn wir zum Beispiel die Farbe von $0235 haben,
werden wir diese Schritte in jedem Frame haben:

1)	$111	; +$111, alle 3
2)	$222	; +$111, alle 3
3)	$233	; +$011, die ROTE Komponente ist in Ordnung, ich füge nur Grün und Blau hinzu
4)	$234	; +$001, Die ROTE und GRÜNE Komponente ist in Ordnung, +1 nur Blau
5)	$235	; +$001, wie oben +1 nur blau

Jedes Mal sollten wir die ROT-Komponente der Farbe mit einem CMP mit dem Tabellenwert vergleichen. 
Wenn wir es nicht erreicht haben addieren wie 1 hinzu. Wenn wir es erreicht haben addieren wir
nicht. Dann mache dasselbe mit GRÜN und BLAU. Schließlich kombinieren Sie die 3 "resultierenden" 
Komponenten mit einem oder mehreren ODER-Anweisungen, um das resultierende Farbwort in die
Copperlist zu schreiben. Und dies für jede der 16, 32 Farben oder wieviele es sind.
Die Menge ist für den Prozessor kein Problem, mit DBRA-Zyklen kann er alles machen.
Das einzige Besondere ist, dass das von mir beschriebene System nicht sehr genau ist,
und besonders in der AGA sehen wir, dass die Farben den Tatsachen entsprechen.
Daher bleibt die Struktur der Routine gleich, aber wir müssen den Berechnungsmodus ändern.
Zuerst müssen wir eines beachten: Wie viele Frames und dann wie oft sollten wir die Routine
aufrufen, um eine vollständige Überblendung durchzuführen?
Wenn wir die Farbe $0F3 haben, kann zum Beispiel ein schönes Grün mit $000e beginnen
Wenn Sie jedes Mal 1 hinzufügen, würde dies bei der ersten Routine für die grüne Komponente, 
da sie den Wert $f (15) erreichen muss 15 add.w #$010 erfordern.
Betrachten wir also eine "parametrische" Routine, die das kann.
Berechnen Sie die Farben auf eine der 16 möglichen PHASES des Fades, wobei die Phase 0 
das komplette SCHWARZ ist und die Phase 16 ist die volle Farbe. Nehmen wir an, wir halten 
"den Wert "der zu erledigenden Phase in einem Label "FaseDelFade" fest. Jedes Mal müssen wir 
Folgendes tun:

	addq.w	#1,FaseDelFade	; System für die nächste Phase zu tun

Daher werden wir beim ersten Frame ein "BSR.s Fade" mit "FaseDelFade" -Anzeige 1 erstellen.
und die Farben werden sehr dunkel sein. Das nächste Frame ruft die Routine neu auf,
aber mit "FaseDelFade" bei 2, und die Farben werden gelöscht (2/16 der vollen Farbe).
Schließlich wenn wir es mit "FaseDelFade" um 3 ausführen, werden die Farben 
gleich denen in der Tabelle sein. Zuerst bezog sich die Fraktion auf 2 Sechzehntel
der Farbe. Ich erwartete die zu verwendende Technik! In der Tat eine Fade-Routine,
einer der routinemäßigen Horror-Effekte, der einfach jedes Mal 1 addiert
sind nicht genau, was wir tun werden, ist akzeptabel.
Wir kommen auf den Punkt: Mit der Fake-Routine müssten wir diese Schritte erreichen
für $084:

 $011
 $022
 $033
 $044
 $054
 $064
 $074
 $084

Wenn wir in die Mitte kommen, haben wir ein GRAU! $044 !! statt hellgrün.
In der Realität hätte es in der Mitte $042 oder dunkelgrün sein sollen.
Was aussieht wie 1/2 von $084. Nun kommt die Lösung: mit dem Wert "FaseDelFade",
dass wir MULTIPLIER nennen können. Wir haben das, wenn es 0 ist, müssen wir
0/16 (null sechzehntel) der Farben berechnen, das ist alles NULL.
Auf der anderen Seite müssen wir bei einem Wert von 1/16 der Farben berechnen.
Also bis 16/16, wo die Farbe gleich bleibt.
Wie implementiere ich diese Formel in Anweisungen? Easy! Wenn ich eine RGB-Komponente,
zum Beispiel BLAU isoliert habe: (wir haben den MULTIPLIER in d0)

	MOVE.W	(A0),D4		; Setzen Sie die Farbe aus der Farbtabelle in d4
	AND.W	#$00f,D4	; Nur die blaue Komponente auswählen ($ RGB -> $ 00B)
	MULU.W	D0,D4		; Multipliziere mit der Fade-Phase (0-16)
	ASR.W	#4,D4		; 4 BITS nach rechts verschieben, dh durch 16 teilen
	AND.W	#$00f,D4	; Wählen Sie nur die BLAUE Komponente aus
	MOVE.W	D4,D5		; Speichern Sie die BLAU-Komponente in d5

In der Praxis multiplizieren wir die Komponente für den MULTIPLIER und teilen sie dann durch
16. Eine Division durch 16 entspricht einem ASR.W #4,Dx, wie wir in der 
8x8-Zeichen-Druckroutine bereits gesehen haben. Die MULU.W #8,Dx kann
durch eine LSL.w #3,Dx ersetzt werden. Betrachten Sie es als DIVU.w #16,D4 und alle
zurück. Wiederholen wir diesen Vorgang 3 mal für die 3 RGB-Komponenten.
Wir haben die FADE-Routine von SCHWARZ in Farbe, und wenn wir bei 16 mit dem Multiplikator beginnen,
Wenn Sie #1 jedes Mal von Null abziehen, haben wir den umgekehrten Farbverlauf
zu schwarz. Letzteres heißt FADE OUT, während das erste FADE IN ist.

Wir können die Funktionsweise der in den beiden beschriebenen Routine in den Listings
Lesson8c.s und Lesson8d.s in der Praxis sehen. Der Unterschied zwischen diesen beiden Listings ist
nur die Reihenfolge, in der die 3-Divisionsoperationen der RGB-Komponenten ausgeführt werden,
aber das Multiplikationsprinzip für Multiplikator und Division durch 16 ist gleich. 
Das deutlichste ist vielleicht das von Lezione8d.s.

Das Design ist ein Logo der RAM JAM-Gruppe von FLENDER, das aus Italien stammt.
Ich habe diesen Entwurf verwendet, weil ich mich dieser Gruppe gerade angeschlossen habe,
als ich diese Lektion schrieb. Also der Kurs von hier an
ist eine RAM JAM Produktion !!!

Wir fahren mit einer Variation des Themas fort und laden Lesson8e.s. Das ist
die selbe Routine, mit einer geringfügigen Änderung, die Sie in Betracht ziehen sollten, wenn 
sie eine zusätzliche dominante Komponente hinzuzufügen wollen, die dem Design einen Schatten gibt. 
Es kann nützlich sein, dem Ganzen eine karnevalistische Note zu verleihen.

Abschließend möchte ich Ihnen eine Routine vorstellen, mit der Sie von einer beliebigen Farbe aus 
zu irgendeiner anderen Farbe wechseln können! 

In der Praxis werden zwei Tabellen benötigt, eine mit den Anfangsfarben, zum Beispiel,
wenn Sie mit Schwarz angefangen haben, einer Tabelle mit vielen Nullen und einer anderen
mit den endgültigen Farben. Es stellt sich heraus, dass die erste Überblendung, die aus Schwarz 
zu normalen Farben müssen Sie als erste Tabelle eine Null setzen und
als zweites mit Farben, um von Farben auf Schwarz umzuschalten (FADE OUT),
Als erste Tabelle muss die mit den normalen Farben und als zweite Tabelle die mit alles
Nullen angegeben werden.

An dieser Stelle sind hier die Neuerungen: Zum Beispiel können wir eine Überblendung von 
WEISS mit normalen Farben, als erste Tabelle alle $FFF und die zweite mit normalen Farben machen.
Wir übertreiben: Wir können von einer Farbe zur nächsten wechseln! Stelle einfach
in die erste Tabelle die Farben die wir am Anfang haben wollen und in die zweite Tabelle, die  
Farben die wir am Ende haben wollen. Auf diese Weise können wir von einem grünen zu einem 
bläulichen Schatten usw. gehen

Laden Sie Lesson8s hoch und probieren Sie die Routine aus, die die Beispiele dafür zeigt.
Was das Funktionieren der Routine betrifft, so ist es eher ziemlich kompliziert, und ich will sie nicht 
wiedersehen. Wenn Sie versuchen wollen, sie zu verstehen, lesen Sie meine (wenigen) alten Kommentare. 
Lerne es jedoch zumindest für deine Zwecke zu benutzen!


               ,јиииииm                              И____
               иVД   ЌиQ                             иўЄ4и,
            _јци#__  .иF       ________              и   и#цииц_
           .и^Ј~АЂиа  `и_ __gјииииииииии#јц___       и&  VоА~ЏАиL
           `иј_   __   ЌииииииЛ^^ААААААЄ*0иииииј__ _Ци~   _____Jи
            ЌЂиц_јииј__иииГ"               Ќ~^ЋиииииP   _јииииииА
               ААА  А#ии/    Иgццц___           ЌА#ииц_јиА
                     ииP     #иииииииц_       ___  А4иииИ
       _____________ ииЬ      А _FАииии_    _Ц**иЎ_  "0и#_ _____________
       \___          ии#        и   АЂииL  Ци  _ `иь   Жии_         ___/
         T           Жии       0и  (ј Ќииb иЭ (и) иf    Жии,         T
         |            #и#И     (и&____јиЄА А#И   _иД     ииQ         |
         |             0ии__    А^ЄЄЄА" __  Ќ^***ГД      ииV         |
         |              Аиииц______    ,ии             _ции'         |
         |                АЋиииииии   ииии   ________циии@~          |
         |                 _ии~ЈииP  `ААЄ*  јиииииииииоАЏ            |
         |        _цииN___ииА  _ии  _       0_ЏЏЏЌ4и_                |
         |      ,ииАЏЏ"0ииА  Ијии" _и .     `и_    Аиц_   _          |
         |      lи      ^  __иииЙ ,и" Ц  иQ  Ќи,     Аииииии_        |
         |      Ќиц__g#   јиЄ~иД  иА ,и  ии   #ии__    АЏЏ Ќи,  xCz  |
     _ __І_______ЌА^Єии   Жи Ии__Ци__иP  ии   ЖииЂи_    ____иf ______І__ _
         :           иђ___ии #иииииииииијииццции' Ќ4#   ииЄЄА        :
         .           "Ђиии@   ~~Џ ЏЌ"А^^ЄЄЋ**ииГ   lи   Юи           .
                         Џ                          иL__Ци
                                                    А**ЄА

Jetzt möchte ich Ihnen drei Listings anbieten, die die Arbeit vieler "Studenten" ausmachen
die von Null anfingen mit meinem Kurs, genau wie Sie, ermutigend?

LEZIONE8g.s	- Parallaxe 10 Ebenen (von Federico Stango)

LEZIONE8h.s	- Bedienfeld mit Gadgets (von Michele Giannelli)

LEZIONE8h2.s	- Scrolltext 8X8 (von Lorenzo Di Gaetano)

Diese drei Listings verwenden nur die Kenntnisse der Diskette 1 des Kurses.
Ich habe nur den Start geändert und statt der alten Methode zum Initialisieren 
der Diskette 1 das startup1.s eingefügt. Ich hoffe du machst auch "eigene" Tests, 
ansonsten lesen Sie alles als Roman? Wake up !!!
Und wenn Sie etwas Schönes gemacht haben, versuchen Sie es mir zu schicken, zumindest 
werde ich es n die nächsten Lektionen hineinstecken und sie werden berühmt als Fiorello.

Lassen Sie uns nun mit einer häufig gestellten Frage fortfahren: "Wie Equalizer funktionieren
vorhanden in dem kleinen Demo AMIGAET.EXE auf der Diskette 1 des Kurses? ".
Nun, ich habe dieses Stück des Listings "ausgeschnitten". Sie können
alles in Lektion 8i.s sehen.

Achtung: Die "music.s" -Routine von Diskette 2 ist nicht dieselbe wie die von
Diskette 1. Die 2 Änderungen betreffen die Entfernung eines BUG, ​​der manchmal
einen Guru am Ende des Programms verursachte und die Tatsache, dass mt_data ein Zeiger 
auf die Musik, auf keine Musik zeigt. Dies ermöglicht es Ihnen, die Musik einfacher 
zu ändern, um Musikdisketten zu erstellen, wie in lesson8i2.s zu sehen.

Wir sind gekommen, um Equalizer zu machen, aber wir haben noch nicht gesehen, wie
sie einen Punkt, d.h. "Zeichnen Sie einen Punkt" machen. Machen wir es mit Lezione8l.s

(dann Plotten verschiedener Ebenen mit 3d_stars.s)

Ok, jetzt, da wir wissen, wie man die Punkte druckt, lassen Sie uns so viele nebeneinander 
drucken um "Linien" in Lesson8m.s und Lesson8m2.s zu machen.

Nun, wenn Sie Linien machen können, können Sie auch parabolische Kurven machen,
multiplizieren Sie einfach X * X in Lesson8m3.s, Lesson8m4.s, Lesson8m5.s

Nun wollen wir sehen, wie die Stichdruckroutine "optimiert" wird. Wie du 
gesehen hast, hat es eine Multiplikation, die sehr schlecht ist, weil sie langsam ist. 
Wir müssen mit 40 multiplizieren. Wir führen einfach alle möglichen Multiplikationen
aus, das sind die ersten 256 Vielfache von 40, und schreiben die Ergebnisse in eine Tabelle. 
Nun haben wir in dieser Tabelle alle "Ergebnisse" der betreffenden Multiplikation nach dem
verschiedenen Fällen. Stellen Sie einfach sicher, dass jedes Mal das richtige Ergebnis aus 
der Tabelle "genommen" wird, so wie wir das richtige X oder Y aus den Tabellen für die
Koordinaten für Sprites genommen haben. Lassen Sie es uns in der Praxis in Lezione8n.s sehen

Lassen Sie uns überprüfen, ob die neue Routine tatsächlich schneller ist als die
alte beim Schreiben und Löschen des gesamten Bildschirms in Lesson8n2.s

Da wir gesehen haben, wie man einen Punkt löscht (einfach einen BCLR anstatt von BSET  
setzen) versuchen wir, einen Punkt zu "animieren", wie wir es für Sprites beim
Schreiben und Löschen in jedem Frame an verschiedenen Positionen in Lektion 8n3.s getan 
haben.

Versuchen Sie, die modifizierte Versionen mit mehreren Bitplanes mit mehr als einem Punkt 
zu einer Zeit zu erstellen, etc. Sie können auf 2 Bitebenen oder 4 Farben drucken.
Tun Sie dies: color0 ist der Hintergrund, während wir 3 verschiedene Farben zum Plotten haben.
Betrachtet man die 2 Bitebenen mit den Namen "Bitplane1" und "Bitplane2",
könnten sie 3 Routinen ausführen. Eine, die in Bitplane1 plottet, eine, die in Bitplane2 
plottet und eine, die in beide Bitebenen plottet, und springe zu einer von
diesen 3 Routinen um in einer von 3 Farben zu zeichnen.

- Unglaublich! Lorenzo di Gaetano schrieb seine Listing im Handumdrehen! siehe es: Lesson8n4.s

Ich stelle mir vor, Sie haben ein Programm erstellt, das megakomplexe Funktionen untersucht.
Das  Wellen wie das Quark-Symbol zeichnet. Dann können Sie eine kurze Werbepause
für copper waits machen, die nicht für Punkt Routinen verwendet werden.
Schauen Sie sich in Lezione8o.s an, was mit wait und color0 ohne die Hilfe einer Bitplane
alles möglich ist. 
Es gibt keine Tricks, nur, dass die copperlist auch modifiziert "gebaut" ist.
Hier ist die Routine, die das herausragende Stück der copperlist "erzeugt":

; INITCOPPER erstellt den Kupferlisten-Teil mit viel WAIT und COLOR0 unten

INITCOPPER:
	lea	barcopper,a0		; Adresse, an der die copperlist erstellt werden soll 
	move.l	#$3001fffe,d1	; erstes wait: Zeile $30 - WAIT in d1
	move.l	#$01800000,d2	; COLOR0 in d2
	move.w  #coplines-1,d0	; Anzahl der copper Zeilen
initloop:
	move.l	d1,(a0)+		; leg das WAIT
	move.l	d2,(a0)+		; leg das COLOR0
	add.l	#$02000000,d1	; nächstes Mal warten, 2 Zeilen tiefer warten
	dbra	d0,initloop
	rts

Wie Sie sehen können, ist das Ergebnis dieser Routine zu erstellen:

barcopper:
	dc.l	$3001fffe	; wait Zeile $30
	dc.l	$01800000	; color 0
	dc.l	$3201fffe	; wait Zeile $32
	dc.l	$01800000	; color 0
	dc.l	$3401fffe	; wait Zeile $34
	dc.l	$01800000	; color 0
	....

Überlegen Sie, wie viel Platz und wie viel Zeit wir auf diese Weise sparen.

	                             ________
	                      ___---'--------`--..____
	,-------------------.============================
	(__________________<|_)   `--.._______..--'
	      |   |   ___,--' - _  /
	      |   |  |            |
	   ,--'   `--'            |
	   ~~~~~~~`-._            |  _
	              `-.______,-'  (і)
	                           '(_)`
	                            Џ Џ


Um die Lektion zu beenden, halte ich es für angebracht, ein Merkmal des Prozessors zu 
behandeln, der obwohl sehr wichtig, bis jetzt nicht diskutiert wurde.
In der Tat CREDEVARE genug über 68000 wissen, aber in Wirklichkeit wurde es bisher 
"mit Rosenwasser" untersucht, das absolute Minimum für
Routinen. In der Tat wurden die Bedingungscodes nicht benannt,
und mit ihnen die GFS, die Teil des SR (Status Register) sind.
Hier sind die 16 Bits, aus denen sich das Register zusammensetzt:

SR:
								___
	15	T - TRACE					\
	14	- nicht benutzt 68000		 |
	13	S - SUPERVISOR				 |
	12	- nicht benutzt 68000		 |- SYSTEM BYTE
	11	-							 |
	10	I2 \						 |
	9	I1  > INTERRUPT MASK		 |
	8	I0 /					  ___/
	7	-							\
	6	-							 |
	5	-							 |
	4	X - EXTENSION				 |- USER BYTE (Condition Code Register)
	3	N - NEGATIVE				 |  (enthält die arithmetischen Flags)
	2	Z - ZERO					 |
	1	V - OVERFLOW (Überlauf)		 |
	0	C - CARRY	 (Übertrag)  ___/

Nun, dieses mysteriöse Register enthält Informationen über die FLAGs von
Bedingungen, genau genommen sein niedriges Byte, genannt CCR (Condition Code Register) 
enthält diese FLAGs. Wir werden das High-Byte des SR behandeln, wenn wir über INTERRUPT 
und SUPERVISOR MODE sprechen.
Im Moment kann ich nur davon ausgehen, dass der Prozessor auf zwei Arten arbeiten kann:
im USER- und im SUPERVISOR-Modus. Normalerweise werden die Programme die wir schreiben
im USER-Modus ausgeführt. Wenn wir Unterbrechungen brauchen, werden wir sehen, wie wir
vom Supervisor-Modus in den User-Modus wechseln können und umgekehrt. Aber einige
Anweisungen können nur im SUPERVISOR-Modus ausgeführt werden, wenn Sie versuchen
sie im USER-Mode auszuführen, geht alles in ein tiefes Koma. Diese Anweisungen sind
wir sagen PRIVILEGIERT, also pass auf!

Vorerst wird es ausreichen, das Low-Byte des SR, den CCR, zu verstehen.
Jeder ausgeführte Befehl, kann die Flags beeinflussen, zum Beispiel bei einer
Subtraktion mit einem negativen Ergebnis wird das N-Flag gesetzt. Wenn das Ergebnis Null 
ist, wird das Z-Flag gesetzt. Bei einer Addition zu einer größeren Zahl führt, zum
Beispiel: Von dem in D0.l enthaltenen setzen wir das V-Bit, overflow, welches
uns anzeigt, dass das Ergebnis nicht im Ziel gespeichert werden kann. Dies
gilt auch für den Carry, also die Übertragung, die im Falle einer Übertragung gesetzt wird.
Sie können die Flags selbst überprüfen, indem Sie das CCR-Byte testen.
Der 68000 ist der beste Prozessor der Welt, es gibt Anweisungen genug, um den Status der 
Flags zu kennen: Es ist das Bcc, wobei cc für Condition Codes (Bedingungscode) steht
und es kann durch CS, EQ, GE, GT, HI, LE, LS, LT, MI, PL ... ersetzt werden.
Denken Sie daran, wenn Sie über die Funktionsweise von CMP-Anweisungen sprechen
gefolgt von BEQ und BNE haben wir die Tatsache begründet, dass das BEQ / BNE wusste, wie es war
ging an die CMP, weil das CMP-Ergebnis auf einem "Blatt" geschrieben wurde?
Nun, das "Blatt", auf dem der CMP das Ergebnis für das BEQ / BNE schreibt, ist
der CCR, das Low-Byte von SR !! Eigentlich besteht diese Packungsbeilage aus
4 Bits plus ein Fünftel, eXtend genannt, das bestimmten Zwecken dient.
Durch diese 4 Bits können nicht nur viele "Situationen" erzeugt werden.
BEQ und BNE, aber wir können wissen, ob eine Zahl größer oder kleiner als
eine andere ist. Wenn zwei Zahlen gleich sind, wenn eine Übertrag in einer Operation 
auftritt, wenn das Ergebnis negativ ist, etc. Hier sind alle Bccs:

	bhi.s	label	; > für vorzeichenlose Zahlen
	bgt.w	label	; > für alle Zahlen mit Vorzeichen
	bcc.s	label	; > auch angerufen BHS, Carry = 0 (ohne Zeichen)
	bge.s	label	; >= für alle Zahlen mit Vorzeichen
	beq.s	label	; = für alle Zahlen
	bne.w	label	; >< für alle Zahlen
	bls.w	label	; <= für alle Zahlen ohne Vorzeichen
	ble.w	label	; <= für alle Zahlen mit Vorzeichen
	bcs.w	label	; < für vorzeichenlose Zahlen; auch BLO genannt, BLO,
					; bedeutet, dass der Carry = 1 ist
	blt.w	label	; < für Zahl mit Vorzeichen
	bpl.w	label	; Negative = 0 (PLus)
	bmi.s	label	; Negative = 1, (Minus) Zahlen mit Vorzeichen
	bvc.w	label	; V=0, kein OVERFLOW (einschränkendes Ergebnis)
	bvs.s	label	; V=1 OVERFLOW (Ergebnis zu groß um
					; im Ziel enthalten sein)

Nun wollen wir sehen, wie die Bccs nach CMP.x OP1, OP2 verwendet werden

	beq.s	label	; OP2 =  OP1 - für alle Zahlen
	bne.w	label	; OP2 >< OP1 - für alle Zahlen
	bhi.s	label	; OP2 >  OP1 - ohne Vorzeichen
	bgt.w	label	; OP2 >  OP1 - mit Vorzeichen
	bcc.s	label	; OP2 >= OP1 - ohne Vorzeichen, auch *"BHS"*
	bge.s	label	; OP2 >= OP1 - mit Vorzeichen
	bls.w	label	; OP2 <= OP1 - ohne Vorzeichen
	ble.w	label	; OP2 <= OP1 - mit Vorzeichen
	bcs.w	label	; OP2 <  OP1 - ohne Vorzeichen, auch *"BLO"*
	blt.w	label	; OP2 <  OP1 - mit Vorzeichen

Und jetzt, wie man sie nach einem TST.x OP1 benutzt

	beq.s	label	; OP1 =  0 - für alle Zahlen
	bne.w	label	; OP1 >< 0 - für alle Zahlen
	bgt.w	label	; OP1 >  0 - mit Vorzeichen
	bpl.s	label	; OP1 >= 0 - mit Vorzeichen (oder BGE)
	ble.w	label	; OP1 <= 0 - mit Vorzeichen
	bmi.w	label	; OP1 <  0 - mit Vorzeichen (oder BLT)

Wie Sie sehen können, können Sie nach einem CMP eine Menge wissen! Ja, sie können
die Zeichen > (größer), >= (größer oder gleich), =, >< (verschieden), <= (weniger oder gleich),
<(weniger) und darüber hinaus gibt es ein Bcc von diesen für Vergleiche für normale Zahlen 
und eins für vorzeichenbehaftete Zahlen (mit Vorzeichen).

Bezüglich der negativen Zahlen haben wir bisher nur erwähnt, dass
zum Beispiel: -1 = $FFFFFFFF, -5 ='$FFFFFFFB ist, wodurch mehr oder weniger das jeweilige
high bit, das ist Bit 31, wenn wir im Langwort, Bit 15, wenn in .w und Bit 7, wenn wir in .b 
sind, ausschlaggebend ist.

Das heißt für das Vorzeichen, wenn es auf 1 ist, ist die Zahl negativ und es geht weiter 
zurück von $FFFF mit dem Wert -1 zu $​​FFFE mit dem Wert -2, für -3 wird $FFFD verwendet usw., 
bis zu (in .w Feld) bei $8001, das ist -32767, gefolgt von $8000, das ist -32768, was die 
negativste Zahl in einem Wort mit Vorzeichen ist und entspricht %1000000000000000, d.h. 
dem High-Bit des gesetzten Vorzeichens und die vorherigen Stellen sind alle gelöscht:
Wir begannen mit -1, das ist %111111111111111.

Dieses System mit negativen Binärzahlen wird als Zweierkomplement bezeichnet.
Wir wissen bereits, dass das höchstwertige Bit, d.h. das Bit das am weitesten links steht 
für das Vorzeichen steht: wenn es 0 ist die Zahl positiv, wenn es 1 ist, ist die Zahl negativ.
Dieses System ist sowohl für Byte-Nummern (das Bit ist 7) ​​als auch .word (das Bit ist 15) 
und für diese .longword (das Bit ist 31) gültig.

Nun wollen wir im Detail sehen, wie das Zweierkomplement der beiden funktioniert: Wir haben 
bemerkt, dass es nicht ausreicht, das höchstwertige Bit zu ändern, um von positiv zu 
negativ zu übergehen. Nehmen wir das Beispiel von +26 und -26 im Feld .word:

		;5432109876543210
	+26	%0000000000011010	($001A)
	-26	%1111111111100110	($FFE6)

Bit 15 in +26 wird zurückgesetzt und in -26 gesetzt, aber offensichtlich ist es nicht
die einzige Änderung, die gemacht werden muss, um von -26 auf -26 zu kommen !!!
Es ist erforderlich, das Zweierkomplement von %0000000000011010 zu erstellen, das aus 
der REVERSE alle Bits und ADD 1 zum Ergebnis besteht.
Lassen Sie uns versuchen, ob es wahr ist: Indem wir alle Bits invertieren, die wir erhalten:

	%1111111111100101

wir fügen 1 hinzu:

	%1111111111100101 +
			1 =
	-----------------
	%1111111111100110

Wenn Sie die Zeile mit Einsen verwirrt, isolieren Sie die 6 niedrigen Bits: %100101 (25) und
addiert 1 = %100110, also 26, mit Bits von 7 bis 15 alle zu 1, also -26.
Wenn wir -26 in einem Byte haben wollen, reichen nur %11100110 oder $E6 aus.
Wenn wir -26 in einem langen Word haben wollen: %11111111111111111111111100110 = $FFFFFFE6
Sie können wählen, ob Sie unsere Bytes (Wort oder Long) mit Vorzeichen oder ohne 
Vorzeichen verwenden möchten. Die Verwendung hängt von den Anweisungen in unserem Programm ab.
Zur Verdeutlichung kann Folgendes enthalten sein: a .b, a .w oder a .l, abhängig vom
System verwendet, wenn "normal" oder "Komplement 2":

	BYTE mit Vorzeichen	 .8 bit	 - von -128 ($80) a +127 ($7f)
	BYTE ohne Vorzeichen .8 bit	 - von 0 ($00) a 255 ($ff)
	WORD mit Vorzeichen	 .16 bit - von -32768 ($8000) a +32767 ($7fff)
	WORD ohne Vorzeichen .16 bit - von 0 ($0000) a 65535 ($ffff)
	LONG mit Vorzeichen	 .32 bit - von -2147483648 ($80000000) a +2147483648 ($7fffffff)
	LONG ohne Vorzeichen .32 bit - von 0 ($00000000) a 4294967299 ($ffffffff)

Wie Sie sehen, liegen die Zahlen im SIGNED BYTE-Feld zwischen 128 und 255
betrachtet als die Werte von -128 und -1. Im SIGNED WORD Feld werden die Werte
zwischen 32768 und 65535 bzw. als Werte zwischen -32768 und -1 betrachtet.
Derselbe Wert für die .longword-Notation.
Zusammenfassend gibt es zwei Möglichkeiten, aus dem Positiven eine negative Zahl zu erhalten:

System 1:

Wenn die Zahl N = %00110 (6 Dezimalstellen) gegeben ist. Um -N zu finden, wird die Negation 
Bit für Bit von N durchgeführt, N = %11001 (-7 Dezimalstellen) und dann 1 zum Ergebnis addiert:

N = %11001 + %00001 = %11010 (-6 Dezimalstellen)

System 2:

Die Zahl N = %00110 (6 Dezimal) ergibt -N
Bit Bits von N bis zu 1 niederwertiger N = %11010 (-6 dezimal).

Wenn es in unserer Routine nie unter Null geht, ist es gut ein Byte mit seinen 255 Werte 
zu benutzen. Wenn wir stattdessen von -50 auf +50 gehen wollten,
müssen Sie Anweisungen wie BGT, BLE, BLT verwenden, die vorzeichenbehaftete Zahlen vergleichen.
Anstelle von zum Beispiel BHI und BLS, wenn sie vorzeichenlose Zahlen vergleichen.
Addition und Subtraktion funktionieren mit vorzeichenbehafteten und vorzeichenlosen Zahlen
während Multiplikationen und Divisionen dies nicht tun. Es gibt tatsächlich zwei Arten
für Zahlen mit oder ohne Vorzeichen: MULU und DIVU für Zahlen ohne Vorzeichen und
MULS und DIVS für vorzeichenbehaftete Zahlen.

Sobald die negativen Zahlen gelöscht sind, sehen wir die CCR-Bits, dh die Flags, nacheinander:

* Bit 0 - Carry (C): Wird auf 1 gesetzt, wenn das Ergebnis einer Addition einen Übertrag 
erzeugt Carry ('Carry'), oder wenn ein Subtrahend größer als das Minuend ist, dh
wenn eine Subtraktion ein "Darlehen" erforderte. Das Carry-Bit enthält außerdem das  
mehr oder weniger signifikant Bit für einen Operanden, der einem unterworfen ist
Verschiebung oder eine Umdrehung. Es wird beim letzten Vorgang auf Null gesetzt
Es gibt keine Berichte, keine "Kredite". Zum Beispiel ein Weg zum
Setzen des CARRY-Flags ist wie folgt:

	move.l	#$FFFFFFFF,d0
	ADDQ.L	#1,d0

Das Ergebnis ist d0 = 00000000, wobei die Flags CARRY und ZERO gesetzt sind, weil wir
das in .l enthaltene Maximum überschritten haben, und das Ergebnis auch NULL ist!

* Bit 1 - oVerflow (V): Wird gesetzt, wenn das Ergebnis der letzten Operation vorliegt
Bei Zahlen mit Vorzeichen ist das Ergebnis zu groß, um im Zieloperanden enthalten zu sein,
zB wenn dieses Ergebnis größer ist als die Grenzen von -128 .. + 127 im Byte-Feld.
Beispielsweise erzeugt die Summe.b 80 + 80 einen Überlauf, nachdem +127 überschritten wurde. 

Im Feld .w sind die Grenzwerte -32768 .. + 32767, und auf dem Gebiet .l sind es - / + 2 Milliarden. 
Beachten Sie, dass die Summe 80 + 80 im Byte-Feld nicht die Carry und eXtend-Flags setzt,
sondern nur das gegebene Overflow-Flag, da 160 255 nicht überschreitet, das Maximum, das in einem Byte
für normale Zahlen enthalten sein kann.

* Bit 2 - Null (Z): Wird gesetzt, wenn die Operation das Ergebnis Null erzeugt. Dies ist nützlich
um die Dekrementierung eines Zählers zu überprüfen, sowie zum Vergleich von zwei gleichen Operanden.

* Bit 3 - Negativ (N): Es wird auf 1 gesetzt, wenn in einer Operation das hohe Bit der Zahl
(welche im Zweierkomplement-Format festgelegt ist) gesetzt ist. In der Praxis, wenn das Ergebnis
eine negative Zahl ist, wird dieses Bit gesetzt, andernfalls zurückgesetzt.
Das Zweierkomplement erhält man durch das Komplementieren eines Operanden
(d.h. alle Bits umkehren) und dann 1 addieren. Zum Beispiel +26 ist in binär %000110010 - 
sein Komplement dazu ist %11100101 (Bitumkehrung Bit 0 in Bit 1 und umgekehrt). Wenn Sie 1 addieren, 
erhalten Sie %11100110.
Bit 7 wird als Vorzeichenbit bezeichnet und wird in Bit 3 des Statusregisters kopiert.
Im Fall von -26 wird N gesetzt, was eine negative Zahl anzeigt.

* Bit 4 - Extend (X): ist eine Wiederholung des Carry-Bits und wird in Operationen mit BCD - Notation 
(Binary Coded Decimal) verwendet. Die Zahl Dezimal 20 wird beispielsweise nicht mit 00010100 dargestellt, 
sondern in der Form zwei Zehner, Null-Einheiten 0010 0000) und bei binären 'erweiterten' Operationen 
wie ADDX und SUBX, spezielle Versionen von ADD und SUB.

				  _____
				 /\___/\
				/_/__/  \
				\    \  /
				 \____\/
				      Y
				      :
				      .

In Anbetracht dieser neuen Erkenntnisse wird auf den Referenztext 68000-2.TXT, die Anweisungen des 
Verarbeiters mit ihren Auswirkungen auf die GFS - FLAG, verwiesen, welche eine "Weiterentwicklung" 
des alten 68000.TXT der ersten Diskette ist. Sollte mittlerweile Baby-Zeug für dich sein oder nicht?.

Bevor Sie LESSON9.TXT starten, ist es gut, wenn Sie den Text 68000-2.TXT lesen, zumindest sind Sie
dann mit den CPU-Anweisungen  bestens vertraut!
Betrachten Sie es als LESSON8b,TXT, "FATEVELO", , nehmen Sie die Essenz.
Ich gebe zu, dass Sie Angst haben können (wenn Sie Halbpatronen sind), lesen Sie alles, aber wenn
sie einmal vertraut mit dem sind, was in diesem schönen 100K-Text geschrieben steht
können sie endlich feststellen, dass Sie wissen, wie man den 68000 programmiert.
Übrigens, wenn Sie später Anweisungen finden, die Sie nicht kennen, können Sie sich nicht
beschwere, denn sie werden in 68000-2.TXT erklärt !!

Sehen Sie sich zunächst die CMP- und Bcc-Anweisungen an, in denen die verschiedenen Bcc-Typen 
ausführlicher erklärt werden, dann fängt man von vorne an und erreicht das Ende. 
Vielleicht immer wieder lesen und zwischendurch Pausen einlegen und ein Sandwich essen.
Dieser 68000-2.TXT ist der zweite Brocken den du überwinden musst. Der erste war LESSON2.TXT, wo Sie 
das erste gelernt haben die Grundlagen und Richtlinien. Viele hielten an diesem Hügel an. Jetzt da
ein Berg sich vor einen stellt, und so viele werden nicht den Mut haben, ihn zu überwinden.
Aber wer es überschreitet, kann versuchen, den Gipfel zu erreichen!

Hast du es mindestens einmal gelesen? Verstehen Sie die Bedingungscodes?
Hier sind einige Beispiele, die überprüfen, ob sie sie verstehen. Sie sind freundlicherweise
geschrieben von Luca Forlizzi (The Dark Coder) und Antonello Pardi (Deathbringer),
So kann ich das Schreiben von Lektionen zur AGA und zu 3D beschleunigen.

Lezione8p1a.s	-> CC Bildung MOVE
Lezione8p1b.s	-> CC in MULU/MULS
Lezione8p1c.s	-> CC in DIVU/DIVS
Lezione8p2a.s	-> CC und Adressregister Ax
Lezione8p2b.s	-> Erweiterung des Zeichens in den Adressregistern Ax
Lezione8p3.s	-> CC in TST
Lezione8p4.s	-> CC in AND,NOT,OR,EOR
Lezione8p5.s	-> CC in NEG
Lezione8p6.s	-> CC in ADD
Lezione8p7.s	-> CC in CMP
Lezione8p8.s	-> CC in ADDX
Lezione8p9.s	-> CC in lsr,asr,lsl,asl

Laden Sie zum Schluss meine Lezione8p9b.s hoch, die auch eine "Abfrage" enthält.

		   ____________________
		   \                  /
		    \________________/
		   _( o..       ..o  )_
		  /  )(\__     __/) (  \
		 (  /  \/ /   \ \/   \  )
		 /\(     (    _)      )/\
		 \_/\ __  \___/    __/\_/
		     \\\_________ ( /
		      \\_|_|_|_|7  /
		       \\|_|_|_|/ /
		        \________/

Bevor wir zur nächsten Lektion übergehen, gibt es ein paar Dinge, die ich dir
gerne sagen möchte. Mein Freund, der das Abenteuer plant. Michele, fragte mich
einiges, als er mich das letzte Mal besuchte und ich nehme an, dass es 
auch für viele von euch interessant ist. Er baute ein Bedienfeld unten ein,
ähnlich wie Lezione8h.s, und zeigt im oberen Teil die verschiedenen Figuren an,
beim Hochladen von Diskette an. (später erfahren Sie, wie Sie Dateien mit der Bibliothek 
des Systems dos.library hochladen). Das Problem ist, dass er die .raw der Figuren hatte, 
aber die Paletten für jede Figur mussten im Hauptprogramm in Tabellen vorgehalten
werden. Eine für jede Figur, und eine Routine zum Kopieren der Farben der
rechte Tabelle in Copperlist entsprechend der geladenen Figur. Dieser allerdings
der Code hat sich verheddert, da die Zahlen Dutzende sind. Dann habe ich
daran erinnert, dass Sie mit dem iffconverter, einschließlich des KefCon, AUCH DIE PALETTE
am unteren Rand der .RAW speichern können! Ändern Sie einfach die Option CMAP OFF in BEHIND
und am unteren Rand der .raw-Datei wird die Palette von color0 bis zum letzten Wort danach 
angehängt. Sie können auch BEFORE auswählen, wodurch die Palette vor dem pic angehängt wird,
aber in diesem Fall müsste man auf "after the palette" zeigen.
Festgestellt, dass es besser ist, mit dem CMAP HINTER (am Ende), wollen wir 
die Änderungen an der gespeicherten .raw-Datei mal sehen.

Die Datei ist dieselbe, aber länger, im Fall des Logos dieser Lektion ist es länger 
als 16 Wörtern. In der Tat hat es 16 colors.w am unteren Rand mehr, wie in diesem Beispiel
(um zu verstehen):

inizio_pic:
	incbin	'logo320*84*16c.raw'	; bitplanes.raw normal
	dc.w $000,$fff,$200,$310		; palette
	dc.w $410,$620,$841,$a73
	dc.w $b95,$db6,$dc7,$111
	dc.w $222,$334,$99b,$446
fine_pic:

Ich habe das Logo in diesem Format entsprechend nachgezeichnet. Lasst uns sehen mit 
welcher einfachen Routine Sie die Palette in die copperliste von Lesson8q.s kopieren können.
Beachten Sie, dass das Bild, wenn es normal ist, normalerweise auch im vorherigen Listing
funktioniert. Tatsächlich haben wir nur "mehr" Wörter, die nicht angezeigt werden "nach" 
dem Ende der letzten Bitebene.

Eine andere Sache, die ich gefragt wurde, ist: Woher weißt du, welcher Prozessor
und welches Kickstart auf der Maschine ist? In Lezione8r.s wird dieses Rätsel
offenbart ... konsultieren Sie einfach die entsprechenden Bits, die dem Zweck gewidmet sind!

Wenn Sie also überzeugt sind, dass Sie bis hierher alles verstanden haben, können Sie
das LESSON 9.TXT laden, das Ihnen ENDLICH den Blitter vorstellt.
Bis zu diesem Punkt haben Sie sich sicherlich gefragt, ob es ihn wirklich gibt.

Eine Anmerkung: Wenn Sie Englisch lesen können, ist es sicherlich nützlich, diese 
grundlegenden Bücher zu haben:

Die zweite Ausgabe des Amiga-Hardware-Handbuchs:

"Amiga Hardware Reference Manual" ISBN: 0-201-18157-6

PER QUANTO RIGUARDA IL 680x0:

Motorola, "MC68020 32-bit Microprocessor User Manual, fourth edition",
Prentice Hall ISBN 0-13541657-4

Motorola, "MC68030 Enhanced 32-bit Microprocessor User Manual, second edition"
Prentice Hall ISBN 0-13-566951-0,  Motorola ISBN 0-13-566969-3.

Motorola, "MC68040 32-bit Microprocessor User Manual"

Vielleicht sollten Sie nicht die 68000 Bedienungsanleitung, sondern die von 68040,
weil die 68000 in der 68000-2.txt ganz gut erklärt wird (hoffe ich), und die
68040 ist vorerst den wenigen Glücklichen vorbehalten. Also Demos oder Speiele die
nur auf dem 68040 laufen würden wenig Verbreitung haben. Auch die großen Unterschiede
gibt es zwischen dem 68000 und 68020, während zwischen 68020 und 68030 die Unterschiede
gering sind. Gleiches gilt für den 68030 im Vergleich zum 68040. Die wesentlichen 
Unterschiede sind der MMU und in der CACHE Steueranweisung, aber für die Programmierung
von Demos und NICHT des Betriebssystems, interessieren die uns nicht sonderlich.

                                 _/\  /\  /\_
      _                          \ (_/  \_) /                          _
     _)\__________________________)  _/\_  (__________________________/(_
    (______________\_\__\___\________)  (________/___/__/_/______________)
        (_  ________________\_\__\___ \/ ___/__/_/_________________  _)
          \/                         \  /                          \/
                                    \/