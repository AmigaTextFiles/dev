showpen
	cmp.b	#1,dosmenu
	beq	.noshow
	
	;show the pen colours
	lea	dopen1,a1
	lea	colours,a0
	clr.l	d0
	move.b	pencol1,d0
	rol.w	#1,d0
	add.l	d0,a0		;found the colour

	move.w	(a0),2(a1)	;copy colour into clist
	
	lea	colours,a0
	clr.l	d0
	move.b	pencol2,d0
	rol.w	#1,d0
	add.l	d0,a0		;found the colour
	
	move.w	(a0),6(a1)	;copy colour into clist

	clr.l	d0
	move.w	2(a1),d0
	bsr	rgb_num
.noshow
	rts
rgb_num
;re-write this a bit.

	
	;convert a colour then printtext into buffer
	;clear buffer

	bsr	waitblit
	lea	buffer,a1	;dst
	move.l	#$ffffffff,$dff044	;lwm
	move.w	#0,$dff066	;mod D
	move.l	#$01000000,$dff040
	move.l	a1,$dff054	;dst D	screen
	move.w	#(24*64)+1,$dff058
	bsr	waitblit

	;make it a column for ease of printing on screen
	;also need to write and blit to remove existing numbers!
	move.w	d0,tempd0

	;d0 has got the colour (XRGB)
	move.w	#0,$dff062	;modb
	move.w	#0,$dff066	;modd
	clr.l	d1
	move.w	tempd0,d1
	and.w	#$0f00,d1	;kill all but red
	ror.w	#8,d1	;get down to normal
	lea	hexchars,a0
	clr.l	d2
	move.b	(a0,d1.w),coltext	;got char equiv
	lea	buffer,a0	;dst
	lea	coltext,a5
	bsr	printtext_skip
	
	clr.l	d1
	move.w	tempd0,d1
	and.w	#$00f0,d1	;kill all but gre
	ror.w	#4,d1	;get down to normal
	lea	hexchars,a0
	clr.l	d2
	move.b	(a0,d1.w),coltext	;got char equiv
	lea	buffer+(8*2),a0	;dst
	lea	coltext,a5
	bsr	printtext_skip

	clr.l	d1
	move.w	tempd0,d1
	and.w	#$000f,d1	;kill all but blu
	lea	hexchars,a0
	clr.l	d2
	move.b	(a0,d1.w),coltext	;got char equiv
	lea	buffer+(16*2),a0	;dst
	lea	coltext,a5
	bsr	printtext_skip
	
	;Thats blitted em into the buffer. now blit them on the screen
	;then blit em in.
	
	;a = screen (mask ed)
	;and C = screen
	;or  B = gfk
	;=d
	
	move.l	#$f00ff00f,$dff044
	move.w	#$4000,$dff042
	move.w	#(44*5)-2,$dff064	;mod A
	move.w	#0,$dff062		;mod B
	move.w	#(44*5)-2,$dff060	;mod C
	move.w	#(44*5)-2,$dff066	;mod D
	lea	buffer,a0	;src
	move.l	gfkmem,a1
	add.l	#30+((200-56)*(5*44)),a1	;dst
	move.w	#%0000111111101100,$dff040
		;10100000	;A & C
		;11001100	;or B
	move.l	a1,$dff050		;a
	move.l	a0,$dff04c		;b
	move.l	a1,$dff048		;c
	move.l	a1,$dff054		;d
	move.w	#(24*64)+1,$dff058	;bltsize

	rts

hexchars	dc.b	"0123456789ABCDEF",0

coltext	dc.b	"0",0
	even
tempd0	dc.w	0	
buffer	dcb.b	3*(10*2)
	even
	cnop	0,4
	
showcopcol1
	lea	colours,a0	;pointer to colours
	lea	copcol1,a1	;pointer to clist
	lea	copcol2,a2	;pointer to clist
	lea	copcol3,a3	;pointer to clist
	move.l	#32-1,d7	;no of colours to copy
showcop1
	move.w	(a0),2(a3)
	move.w	(a0),2(a2)
	move.w	(a0)+,2(a1)	;copy colour
	add.l	#$4,a1		;next colour
	add.l	#$4,a2		;next colour
	add.l	#$4,a3		;next colour
	dbra	d7,showcop1
	rts

showrgb
	cmp.b	#1,dosmenu
	beq	bye
	bsr	restrgb
	clr.l	d0
	clr.l	d1
	clr.l	d3
	move.b	pencol1,d0
	lea	colours,a0
	rol.w	#1,d0	
	move.w	(a0,d0),d1	;got the colour
	move.w	d1,d3		;save it for later

	and.w	#$0f00,d1	;kill all but red
	ror.w	#8,d1		;move to edge
	clr.l	d0		;pos on screen
	bra	hik2
showg2	sub.w	#1,d1
	add.l	#8,d0		;xpos
hik2	cmp.w	#0,d1
	bgt	showg2
	add.w	#96,d0		;add offset X
	move.w	#145,d1		;setup Y
	bsr	dobox

	move.l	d3,d1
	and.w	#$00f0,d1	;kill all but green
	ror.w	#4,d1		;move to edge
	clr.l	d0		;pos on screen
	bra	hik3
showg3	sub.w	#1,d1
	add.l	#8,d0		;xpos
hik3	cmp.w	#0,d1
	bgt	showg3
	add.w	#96,d0		;add offset X
	move.w	#145+8,d1		;setup Y
	bsr	dobox

	move.l	d3,d1
	and.w	#$000f,d1	;kill all but blue
	clr.l	d0		;pos on screen
	bra	hik
showg1	sub.w	#1,d1
	add.l	#8,d0		;xpos
hik	cmp.w	#0,d1
	bgt	showg1
	add.w	#96,d0		;add offset X
	move.w	#145+8+8,d1		;setup Y
	bsr	dobox

	bsr	showpen
bye
	rts
dobox
	lea	boxes+(2*32),a5	;bob data
	move.l	gfkmem,a4
	add.l	#2,a4

	bsr	calcxy

	add.l	d1,a4
	or.w	#$0dfc,d2

	
	move.w	#$ffff,$dff044	;fwm
	move.w	#$0000,$dff046	;lwm
	bsr	waitblit
	move.w	#80-4,$dff064	;mod A .gfx map = 6 bytes. ball = 4
	move.w	#44-4,$dff062	;mod b
	move.w	#44-4,$dff066	;mod D

	move.w	d2,$dff040
	move.w	#$00,$dff042
	move.l	a5,$dff050	;get mask A
	move.l	a4,$dff04c	;src B	bob
	move.l	a4,$dff054	;dst D	screen
	move.w	#(9*64*5)+2,$dff058
	rts



clearsqr
	lea	boxes+(2*32),a5	;bob data
	move.l	gfkmem,a4
	add.l	#2,a4


	bsr	calcxy

	add.l	d1,a4
	or.w	#%0000110100001100,d2

	bsr	waitblit
	
	move.w	#$ffff,$dff044	;fwm
	move.w	#$0000,$dff046	;lwm
	move.w	#80-4,$dff064	;mod A .gfx map = 6 bytes. ball = 4
	move.w	#44-4,$dff062	;mod b
	move.w	#44-4,$dff066	;mod D

	move.w	d2,$dff040
	move.w	#$00,$dff042
	move.l	a5,$dff050	;get mask A
	move.l	a4,$dff04c	;src B	bob
	move.l	a4,$dff054	;dst D	screen
	move.w	#(9*64*5)+2,$dff058
	rts
calcxy
	;y is in d1
	;x is in d0	
	and.w	#$fff8,d1	;kill all but smooth scroll
	mulu	#5*44,d1
	move.w	d0,d2
	and.w	#$fff0,d0	;kill smooth scroll
	ror.l	#4,d0
	rol.l	#1,d0
	add.l	d0,d1

	and.w	#$0008,d2	;kill all but smooth scroll
	move.w	d2,d0
	rol.w	#8,d2
	rol.w	#4,d2	

	rts

gorgb
	clr.l	d0
	clr.l	d1
	clr.l	d2
	clr.l	d3
	clr.l	d4
	move.w	xpos,d0
	sub.w	#96,d0
	and.w	#$fff8,d0
	ror.w	#3,d0		;x

	rol.w	#8,d0

	move.w	ypos,d1
	sub.w	#144,d1
	and.w	#$fff8,d1
	ror.w	#3,d1		;y

	move.l	#$f00,d2

	lea	colours,a0
	move.b	pencol1,d4
	rol.w	#1,d4
	add.l	d4,a0
	move.w	(a0),d3
	bra	sklip
	
gorgb1	ror.l	#4,d0
	ror.l	#4,d2
	sub.w	#1,d1
sklip	cmp.w	#0,d1
	bne	gorgb1

	eor	#$ffff,d2
	and.w	d2,d3
	or	d0,d3
	move.w	d3,(a0)
	rts
