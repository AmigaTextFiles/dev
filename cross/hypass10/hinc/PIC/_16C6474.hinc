@DATABASE
@NODE MAIN 16C6474
* 16C6474 HyperSource© include file for 16C6474
* © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
*
* source: Microchip databook 1994
*

    @{" 16C64/74 CPU-CORE      " link "16C6474_CPU-CORE"}
    @{" 16C64/74 INTERRUPTS    " link "16C6474_INTERRUPTS"}

    @{" 16C64/74 IO-PORTS      " link "16C6474_IO-PORTS"}
    @{" 16C64/74 SPI-INTERFACE " link "16C6474_SPI-INTERFACE"}
    @{" 16C74    SCI-INTERFACE " link "16C74_SCI-INTERFACE"}
    @{" 16C74    ADCs          " link "16C74_ADCs"}

    @{" 16C64/74 TIMERS        " link "16C6474_TIMERS"}

* Values with a '*' in front of them show the defaults after a RESET.

@ENDNODE
@NODE 16C6474_INTERRUPTS
****************************
*    INTERRUPT VECTORS     *
****************************

  ; THESE ARE NO VECTORS BUT PROGRAM MEMORY LOCATIONS THE CPU JUMPS TO
  ; MUST CONTAIN OBJECT CODE TO JUMP TO YOUR RELATING ROUTINES !

  C_RESET   = $0000    ;
  C_IRQ     = $0004    ;


*******************************
* INTERRUPT CONTROL REGISTERS *
*******************************

  INTCON    = REGS+$0B ;  INTERRUPT CONTROL REGISTER

        GIE       = 7           ; GLOBAL INTERRUPT ENABLE
                                ; *0= DISABLE
                                ;  1= ENABLE

        PEIE      = 6           ; PERIPHERAL INTERRUPT ENABLE BIT
                                ; *0= DISABLE ALL PERIPHERAL INTERRRUPTS
                                ;  1= ENABLE ALL UNMASKED PER. INTERRRUPTS

        T0IE      = 5           ; TMR0 INTERRUPT ENABLE BIT
                                ; *0= DISABLE T0IF INTERRRUPT
                                ;  1= ENABLE T0IF INTERRRUPT

        INTE      = 4           ; INT INTERRUPT ENABLE BIT
                                ; *0= DISABLE INTF INTERRRUPT
                                ;  1= ENABLE INTF INTERRRUPT

        RBIE      = 3           ; RBIF INTERRUPT ENABLE BIT
                                ; *0= DISABLE RBIF INTERRRUPT
                                ;  1= ENABLE RBIF INTERRRUPT

        T0IF      = 2           ; TIMER 0 OVERFLOW INTERRUPT FLAG
                                ;  1= TMR0 OVERFLOWS
                                ; *0= RESET IN SOFTWARE !

        INTF      = 1           ; INT INTERRUPT FLAG
                                ;  1= INT INTERRUPT OCCURES
                                ; *0= RESET IN SOFTWARE !

        RBIF      = 0           ; RB PORT CHANGE INTERRUPT
                                ;  1= PORT B[7:5] CHANGED
                                ;  0= RESET IN SOFTWARE !
                                ;  (*UNDEFINED AFTER RESET)

  PIE1     = REG1+$0C ;  PERIPHERAL INTERRUPT CONTROL REGISTER 1

        PSPIE     = 7           ; PARRALEL SLAVE PORT INTERRUPT ENABLE BIT
                                ; *0= DISABLE PSPIF INTERRUPT
                                ;  1= ENABLE PSPIF INTERRUPT

 .IFD HAS_ADC          ; 16C74 ONLY

        ADIE      = 6           ; A/D CONVERTER INTERRUPT ENABLE BIT
                                ; *0= DISABLE ADIF INTERRRUPTS
                                ;  1= ENABLE ADIF INTERRRUPTS

 .ENDIF
 .IFD HAS_SCI          ; 16C74 ONLY

        RCIE      = 5           ; SCI RECEIVE INTERRUPT ENABLE BIT
                                ; *0= DISABLE RCIF INTERRRUPT
                                ;  1= ENABLE RCIF INTERRRUPT

        TXIE      = 4           ; SCI TRANSMIT INTERRUPT ENABLE BIT
                                ; *0= DISABLE TXIF INTERRRUPT
                                ;  1= ENABLE TXIF INTERRRUPT

 .ENDIF

        SSPIE     = 3           ; SPI INTERRUPT ENABLE BIT
                                ; *0= DISABLE SSPIF INTERRRUPT
                                ;  1= ENABLE SSPIF INTERRRUPT

        CCP1IE    = 2           ; CCP1 INTERRUPT ENABLE BIT
                                ; *0= DISABLE CCP1IF INTERRRUPT
                                ;  1= ENABLE CCP1IF INTERRRUPT

        TMR2IE    = 1           ; TIMER2 INTERRUPT ENABLE BIT
                                ; *0= DISABLE TMR2IF INTERRRUPT
                                ;  1= ENABLE TMR2IF INTERRRUPT

        TMR1IE    = 0           ; TIMER1 INTERRUPT ENABLE BIT
                                ; *0= DISABLE TMR1IF INTERRRUPT
                                ;  1= ENABLE TMR1IF INTERRRUPT

  PIR1     = REG0+$0C ;  PERIPHERAL INTERRUPT FLAG REGISTER 1

        PSPIF     = 7           ; PARRALEL SLAVE PORT INTERRUPT FLAG
                                ;  1= PSPIF INTERRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

 .IFD HAS_ADC          ; 16C74 ONLY

        ADIF      = 6           ; A/D CONVERTER INTERRUPT FLAG
                                ;  1= ADIF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

 .ENDIF
 .IFD HAS_SCI          ; 16C74 ONLY

        RCIF      = 5           ; SCI RECEIVE INTERRUPT FLAG
                                ;  1= RCIF INTERRRUPT OCCURED
                                ; *0= RESET RXREG IS LOADED

        TXIF      = 4           ; SCI TRANSMIT INTERRUPT FLAG
                                ;  1= TXIF INTERRRUPT OCCURED
                                ; *0= RESET IF TXREG LOADED

 .ENDIF

        SSPIF     = 3           ; SPI INTERRUPT FLAG
                                ;  1= SSPIF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

        CCP1IF    = 2           ; CCP1 INTERRUPT FLAG
                                ;  1= CCP1IF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

        TMR2IF    = 1           ; TIMER2 INTERRUPT FLAG
                                ;  1= TMR2IF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

        TMR1IF    = 0           ; TIMER1 INTERRUPT FLAG
                                ;  1= TMR1IF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

 .IFD HAS_CCP2         ; 16C74 ONLY

  PIE2     = REG1+$0C ;  PERIPHERAL INTERRUPT CONTROL REGISTER 2

        CCP2IE    = 0           ; CCP2 INTERRUPT ENABLE BIT
                                ; *0= DISABLE CCP2IF INTERRRUPT
                                ;  1= ENABLE CCP2IF INTERRRUPT

  PIR2     = REG0+$0C ;  PERIPHERAL INTERRUPT FLAG REGISTER 2

        CCP2IF    = 0           ; CCP2 INTERRUPT FLAG
                                ;  1= CCP2IF INTERRRUPT OCCURED
                                ; *0= RESET IN SOFTWARE !

 .ENDIF

@ENDNODE
@NODE 16C6474_CPU-CORE
************************
*       CPU CORE       *
************************

  IND       = REGS+$00 ;  USE CONTENTS OF FSR TO ADDRESS DATA MEMORY
                       ;  (NO PHYSICAL REGISTER)

  PCL       = REGS+$02 ;  LOW ORDER 8 BITS OF PC
                       ;  (*0 AFTER RESET)

  FSR       = REGS+$04 ;  INDIRECT DATA MEMORY ADDRESS POINTER 0
                       ;  LOW ORDER 8 BITS, 9TH BIT = IRP IN STATUS
                       ;  (*UNDEFINED AFTER RESET)

  PCLATH    = REGS+$0A ;  HOLDING REGISTER FOR HIGH BYTE OF PC
                       ;  (*0 AFTER RESET)

  STATUS    = REGS+$03 ;  STATUS REGISTER

        RP0       = 5           ; REGISTER PAGE SELECT BITS
                                ; FOR DIRECT ADDRESSING
                                ;  RP0
                                ;  *0    PAGE 0  $000 - $07F
                                ;   1    PAGE 1  $080 - $0FF

        TO        = 4           ; TIMEOUT BIT, ACTIVE LOW !
                                ;  0= WATCHDOG TIMEOUT OCCURED
                                ; *1= SET BY CLRWDT, SLEEP, POWER UP

        PD        = 3           ; POWER DOWN BIT, ACTIVE LOW
                                ;  0= POWER DOWN OCCURED
                                ;     OR SLEEP WAS EXECUTED
                                ; *1= SET BY CLRWDT OR POWER UP

        Z         = 2           ; ZERO BIT
                                ;  1= LAST ARITHMETIC OPERATION RESULTS 0
                                ;  MOVF ALSO AFFECT ZERO BIT !
                                ;  (*UNDEFINED AFTER RESET)

        DC        = 1           ; DIGIT CARRY / -BORROW BIT
                                ;  1= ADDWF,ADDLW OVERFLOWED  BIT 3
                                ;     SUBWF,SUBLW UNDERFLOWED BIT 3
                                ;  (*UNDEFINED AFTER RESET)

        C         = 0           ; CARRY / -BORROW BIT
                                ;  1= ADDWF,ADDLW OVERFLOWED  BIT 7
                                ;     SUBWF,SUBLW UNDERFLOWED BIT 7
                                ;  RRF AND RLF ALSO AFFECT C !
                                ;  (*UNDEFINED AFTER RESET)

  PCON     = REG1+$0E ;  POWER CONTROL/STATUS REGISTER

        POR       = 1           ; POWER ON RESET
                                ; *0= POWER ON RESET OCCURED LAST
                                ;  1= NO POWER ON RESET

                                ; STATUS BITS AND THEIR SIGNIFICANCE
                                ;  -POR -TO -PD     EVENT
                                ;    0   1   1    POWER ON RESET
                                ;    0   0   x    ILLEGAL, -TO IS SET ON POR
                                ;    0   x   0    ILLEGAL, -PD IS SET ON POR
                                ;    1   0   1    WDT RESET DUR. NORM. OP.
                                ;    1   0   0    WDT WAKEUP FROM SLEEP
                                ;    1   1   1    -MCLR DUR. NORMAL OPERATION
                                ;    1   1   0    -MCLR RESET DURING SLEEP
                                ;                OR INTERR. WAKEUP FROM SLEEP


@ENDNODE
@NODE 16C6474_IO-PORTS
****************************
*   INPUT/ OUTPUT PORTS    *
****************************

  TRISA     = REG1+$05 ;  DATA DIRECTION REGISTER FOR PORT A

        TRISA5    = 5           ; (0=OUT, *1=IN)
        TRISA4    = 4           ; (0=OUT, *1=IN)
        TRISA3    = 3           ; (0=OUT, *1=IN)
        TRISA2    = 2           ; (0=OUT, *1=IN)
        TRISA1    = 1           ; (0=OUT, *1=IN)
        TRISA0    = 0           ; (0=OUT, *1=IN)

  PORTA     = REG0+$05 ;  PORT A DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RA5       = 5           ; I/O OR AN4
        RA4       = 4           ; I/O (SCHMITT TRIGGER/OPEN DRAIN) USE PULLUP
        RA3       = 3           ; I/O OR AN3
        RA2       = 2           ; I/O OR AN2
        RA1       = 1           ; I/O OR AN1
        RA0       = 0           ; I/O OR AN0

        SS        = 5           ; SLAVE SELECT INPUT FOR SPI
        T0CKI     = 4           ; T0CKI EXTERNAL INTERRUPT INPUT
                                ;  ALSO EXTERNAL CLOCK IN FOR TMR0

  TRISB     = REG1+$06 ;  DATA DIRECTION REGISTER FOR PORT B

        TRISB7    = 7           ; (0=OUT, *1=IN)
        TRISB6    = 6           ; (0=OUT, *1=IN)
        TRISB5    = 5           ; (0=OUT, *1=IN)
        TRISB4    = 4           ; (0=OUT, *1=IN)
        TRISB3    = 3           ; (0=OUT, *1=IN)
        TRISB2    = 2           ; (0=OUT, *1=IN)
        TRISB1    = 1           ; (0=OUT, *1=IN)
        TRISB0    = 0           ; (0=OUT, *1=IN)

  PORTB     = REG0+$06 ;  PORT B DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RB7       = 7           ; I/O
        RB6       = 6           ; I/O
        RB5       = 5           ; I/O
        RB4       = 4           ; I/O
        RB3       = 3           ; I/O
        RB2       = 2           ; I/O
        RB1       = 1           ; I/O
        RB0       = 0           ; I/O

        INT       = 0           ; INT EXTERNAL INTERRUPT INPUT

  TRISC     = REG1+$07 ;  DATA DIRECTION REGISTER FOR PORT C

        TRISC7    = 7           ; (0=OUT, *1=IN)
        TRISC6    = 6           ; (0=OUT, *1=IN)
        TRISC5    = 5           ; (0=OUT, *1=IN)
        TRISC4    = 4           ; (0=OUT, *1=IN)
        TRISC3    = 3           ; (0=OUT, *1=IN)
        TRISC2    = 2           ; (0=OUT, *1=IN)
        TRISC1    = 1           ; (0=OUT, *1=IN)
        TRISC0    = 0           ; (0=OUT, *1=IN)

  PORTC     = REG0+$07 ;  PORT C DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RC7       = 7           ; I/O (SCHMITT TRIGGER IN)
        RC6       = 6           ; I/O (SCHMITT TRIGGER IN)
        RC5       = 5           ; I/O (SCHMITT TRIGGER IN)
        RC4       = 4           ; I/O (SCHMITT TRIGGER IN)
        RC3       = 3           ; I/O (SCHMITT TRIGGER IN)
        RC2       = 2           ; I/O (SCHMITT TRIGGER IN)
        RC1       = 1           ; I/O (SCHMITT TRIGGER IN)
        RC0       = 0           ; I/O (SCHMITT TRIGGER IN)

 .IFD HAS_SCI           ; 16C74 ONLY

        DT        = 7           ; SYNC SERIAL I/O       (IF SPEN=1,SYNC=1)
        RX        = 7           ; ASYNC SERIAL IN       (IF SPEN=1,SYNC=0)
        CK        = 6           ; SYNC SERIAL CLOCK I/O (IF SPEN=1,SYNC=1)
        TX        = 6           ; ASYNC SERIAL OUT      (IF SPEN=1,SYNC=0)

 .ENDIF

        SDO       = 5           ; SPI SERIAL PORT DATA OUT
        SDI       = 4           ; SPI SERIAL PORT DATA IN
        SDA       = 4           ; I2C SERIAL PORT DATA I/O
        SCK       = 3           ; SPI SERIAL PORT CLOCK I/O
        SCL       = 3           ; I2C SERIAL PORT CLOCK I/O
        CCP1      = 2           ; CAPTURE1 IN/CAPTURE1 OUT/PWM1 OUT
        T1CKO     = 1           ; TIMER1 OSCILLATOR OUT

 .IFD HAS_CCP2          ; 16C74 ONLY

        CCP2      = 1           ; CAPTURE2 IN/CAPTURE2 OUT/PWM2 OUT
        T1OSO     = 0           ; TIMER1 OSCILLATOR OUT

 .ENDIF

        T1CKI     = 0           ; TIMER1 CLOCK IN

  TRISD     = REG1+$08 ;  DATA DIRECTION REGISTER FOR PORT D

        TRISD7    = 7           ; (0=OUT, *1=IN)
        TRISD6    = 6           ; (0=OUT, *1=IN)
        TRISD5    = 5           ; (0=OUT, *1=IN)
        TRISD4    = 4           ; (0=OUT, *1=IN)
        TRISD3    = 3           ; (0=OUT, *1=IN)
        TRISD2    = 2           ; (0=OUT, *1=IN)
        TRISD1    = 1           ; (0=OUT, *1=IN)
        TRISD0    = 0           ; (0=OUT, *1=IN)

  PORTD     = REG0+$08 ;  PORT D DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RD7       = 7           ; I/O (SCHMITT TRIGGER IN)
        RD6       = 6           ; I/O (SCHMITT TRIGGER IN)
        RD5       = 5           ; I/O (SCHMITT TRIGGER IN)
        RD4       = 4           ; I/O (SCHMITT TRIGGER IN)
        RD3       = 3           ; I/O (SCHMITT TRIGGER IN)
        RD2       = 2           ; I/O (SCHMITT TRIGGER IN)
        RD1       = 1           ; I/O (SCHMITT TRIGGER IN)
        RD0       = 0           ; I/O (SCHMITT TRIGGER IN)

        PSP7      = 7           ; PARALLEL SLAVE PORT
        PSP6      = 6           ; PARALLEL SLAVE PORT
        PSP5      = 5           ; PARALLEL SLAVE PORT
        PSP4      = 4           ; PARALLEL SLAVE PORT
        PSP3      = 3           ; PARALLEL SLAVE PORT
        PSP2      = 2           ; PARALLEL SLAVE PORT
        PSP1      = 1           ; PARALLEL SLAVE PORT
        PSP0      = 0           ; PARALLEL SLAVE PORT

  TRISE     = REG1+$09 ;  DATA DIRECTION REGISTER FOR PORT E

        IBF       = 7           ; INPUT BUFFER FULL
                                ;  0= NO WORD HAS BEEN RECEIVED
                                ;  1= A WORD HAS BEEN RECEIVED AND WAITING
                                ;     TO BE READ BY THE CPU

        OBF       = 6           ; OUTPUT BUFFER FULL
                                ;  0= OUTPUT BUFFER HAS BEEN READ
                                ;  1= THE OUTPUT BUFFER STILL HOLDS A
                                ;     PREVIOUSLY WRITTEN WORD

        IBOV      = 5           ; INPUT BUFFER OVERFLOW IN CPU MODE
                                ;  0= NO OVERFLOW HAS OCCURED
                                ;  1= A WRITE OCCURED WHEN A PREVIOUS INPUT
                                ;     HAS NOT BEEN READ
                                ;  MUST BE CLEARED BY SOFTWARE

        PSPMODE   = 4           ; SELECTS PARALLEL SLAVE MODE FOR PORTS D+E
                                ;  0= GENERAL PURPOSE I/O
                                ;  1= PARALLEL SLAVE PORT MODE

        TRISE2    = 2           ; (0=OUT, *1=IN)
        TRISE1    = 1           ; (0=OUT, *1=IN)
        TRISE0    = 0           ; (0=OUT, *1=IN)


  PORTE     = REG0+$09 ;  PORT E DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RE2       = 2           ; I/O (SCHMITT TRIGGER IN) OR AN7
        RE1       = 1           ; I/O (SCHMITT TRIGGER IN) OR AN6
        RE0       = 0           ; I/O (SCHMITT TRIGGER IN) OR AN5

        CS        = 2           ; CHIP SELECT CONTROL IN (PAR. SLAVE MODE)
                                ;  0= DEVICE IS SELECTED
                                ;  1= DEVICE IS NOT SELECTED
        WR        = 1           ; WRITE CONTROL INPUT (PAR. SLAVE MODE)
                                ;  0= WRITE OPERATION
                                ;  1= NOT A WRITE OPERATION
        RD        = 0           ; READ CONTROL INPUT (PAR. SLAVE MODE)
                                ;  0= READ OPERATION
                                ;  1= NOT A READ OPERATION

@ENDNODE
@NODE 16C6474_TIMERS
****************************
*     TIMER REGISTERS      *
****************************

  TMR0      = REG0+$01 ;  TIMER 0 COUNTER REGISTER
                       ;  (*UNDEFINED AFTER RESET)
  RTCC      = REG0+$01 ;  JUST FOR COMPATIBLITY

OPTION      = REG1+$01 ;  OPTION REGISTER (must be column 0 because of opc.)

        RBPU      = 7           ; PORTB PULL-UP ENABLE, ACTIVE LOW
                                ;  0= PULL-UPS ARE ENABLED BY INDIVIDUAL
                                ;     PORT-LATCH VALUES
                                ; *1= PULL-UPS ARE DISABLED OVERRIDING
                                ;     ANY PORT-LATCH VALUE

        INTEDG    = 6           ; INT INTERRUPT EDGE SELECT
                                ;  0= INTERRUPT ON FALLING EDGE
                                ; *1= INTERRUPT ON RISING EDGE

        RTS       = 5           ; TIMER 0 SIGNAL SOURCE
                                ;  0= INTERNAL INSTRUCTION CYCLE CLOCK
                                ; *1= TRANSITION ON RA4/T0CKI PIN

        RTE       = 4           ; TIMER 0 SIGNAL EDGE
                                ;  0= INCREMENT ON RISING EDGE ON RA4/T0CKI
                                ; *1= INCREMENT ON FALLING EDGE ON RA4/T0CKI

        PSA       = 3           ; PRESCALER ASSIGNMENT
                                ;  0= TMR0
                                ; *1= WDT

        PS2       = 2           ; PRESCALER VALUE
        PS1       = 1           ;  PS2 PS1 PS0  TMR0 RATE  WDT RATE
        PS0       = 0           ;   0   0   0     1:2        1:1
                                ;   0   0   1     1:4        1:2
                                ;   0   1   0     1:8        1:4
                                ;   0   1   1     1:16       1:8
                                ;   1   0   0     1:32       1:16
                                ;   1   0   1     1:64       1:32
                                ;   1   1   0     1:128      1:64
                                ;  *1  *1  *1     1:256      1:128

  TMR1L     = REG0+$0E ;  TIMER 1 COUNTER REGISTER LSB
  TMR1H     = REG0+$0F ;  TIMER 1 COUNTER REGISTER MSB
                       ;  (*UNDEFINED AFTER RESET)

  T1CON     = REG0+$10 ;  TIMER 1 CONTROL REGISTER

        T1CKPS1   = 5           ; TIMER 1 CLOCK PRESCALE SELECT
        T1CKPS0   = 4           ;  T1CKPS1 T1CKPS0  PRESCALE VALUE
                                ;    *0      *0           1
                                ;     0       1           2
                                ;     1       0           4
                                ;     1       1           8

        T1OSCEN   = 3           ; TIMER 1 OSCILLATOR ENABLE
                                ; *0= OSCILLATOR ENABLED
                                ;  1= OSCILLATOR SHUT OFF
                                ;     THE OSC INVERTER AND FEEDBACK
                                ;     RESISTOR ARE TURNED OFF TO ELIMINATE
                                ;     POWER DRAIN

       T1INSYNC   = 2           ; TIMER 1 EXTERNAL CLOCK INPUT SYNC CONTROL
                                ; BIT IS IGNORED WHEN TMR1CS=0, ELSE
                                ; *0= SYNCHRONIZE EXTERNAL CLOCK INPUT
                                ;  1= DON'T SYNCHRONIZE

        TMR1CS    = 1           ; TIMER 1 CLOCK SELECT
                                ; *0= INTERNAL CLOCK (OSC/4)
                                ;  1= EXTERNAL CLOCK (RC0/TCKI)

        TMR1ON    = 0           ; TIMER 1 ON BIT
                                ; *0= STOP TIMER 1
                                ;  1= ENABLE TIMER 1

  TMR2      = REG0+$11 ;  TIMER 2 COUNTER REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  PR2       = REG1+$12 ;  TIMER 2 PERIOD REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  T2CON     = REG0+$12 ;  TIMER 2 CONTROL REGISTER

       T2OUTPS3   = 6           ; TIMER 1 OUTPUT POSTSCALE SELECT
       T2OUTPS2   = 5           ;  OUTPS3 OUTPS2 OUTPS1 OUTPS0 POSTSCALE VAL
       T2OUTPS1   = 4           ;   *0     *0     *0     *0         1
       T2OUTPS0   = 3           ;    0      0      0      1         2
                                ;    0      0      1      0         3
                                ;    0      0      1      1         4
                                ;    0      1      0      0         5
                                ;    0      1      0      1         6
                                ;    0      1      1      0         7
                                ;    0      1      1      1         8
                                ;    1      0      0      0         9
                                ;    1      0      0      1        10
                                ;    1      0      1      0        11
                                ;    1      0      1      1        12
                                ;    1      1      0      0        13
                                ;    1      1      0      1        14
                                ;    1      1      1      0        15
                                ;    1      1      1      1        16

        TMR2ON    = 2           ; TIMER 2 ON BIT
                                ; *0= STOP TIMER 2
                                ;  1= ENABLE TIMER 2

        T2CKPS1   = 1           ; TIMER 2 CLOCK PRESCALE SELECT
        T2CKPS0   = 0           ;  T2CKPS1 T2CKPS0  PRESCALE VALUE
                                ;    *0      *0           1
                                ;     0       1           4
                                ;     1       x          16

  CCPR1L    = REG0+$15 ;  TIMER 1 CAPTURE / COMPARE / PWM REGISTER LSB
  CCPR1H    = REG0+$16 ;  TIMER 1 CAPTURE / COMPARE / PWM REGISTER MSB
                       ;  (*UNDEFINED AFTER RESET)

  CCP1CON   = REG0+$17 ;  TIMER 1 CAPTURE / COMPARE / PWM CONTROL REGISTER

        CCP1X     = 5           ; TWO LOW ORDER BITS
        CCP1Y     = 4           ;  PWM MODE: WRITE TWO LOW ORDER BITS IN
                                ;  HIGH RESOLUTION (10BIT) MODE. MAY BE KEPT
                                ;  CONSTANT (AT 0) OF ONLY 8 BIT RESOLUTION
                                ;  IS DESIRED.
                                ;  (*0 AFTER RESET)

        CCP1M3    = 3           ; CCP1 MODE SELECT
        CCP1M2    = 2           ;  CCPM3 CCPM2 CCPM1 CCPM0  CCP1 MODE
        CCP1M1    = 1           ;   *0    *0    *0    *0      OFF
        CCP1M0    = 0           ;    0     1     0     0  CAPTURE EVERY
                                ;                           FALLING EDGE
                                ;    0     1     0     1  CAPTURE EVERY
                                ;                           RISING EDGE
                                ;    0     1     1     0  CAPTURE EVERY
                                ;                           4TH RISING EDGE
                                ;    0     1     1     1  CAPTURE EVERY
                                ;                           16TH RISING EDGE
                                ;    1     0     0     0  COMPARE MODE
                                ;                           SET OUT IF MATCH
                                ;                           (CCP1IF BIT SET)
                                ;    1     0     0     1  COMPARE MODE
                                ;                           CLR OUT IF MATCH
                                ;                           (CCP1IF BIT SET)
                                ;    1     0     1     0  COMPARE MODE
                                ;                           SW IRQ IF MATCH
                                ;                           (CCP1IF BIT SET)
                                ;                           (NO CCP1 FLG)
                                ;    1     0     1     1  COMPARE MODE
                                ;                           TRG SPEC. EVENT
                                ;                           CCP1 RESETS TMR1
                                ;    1     1     x     x  PWM MODE

  CCPR2L    = REG0+$1B ;  TIMER 1/2 CAPTURE / COMPARE / PWM REGISTER LSB
  CCPR2H    = REG0+$1C ;  TIMER 1/2 CAPTURE / COMPARE / PWM REGISTER MSB
                       ;  (*UNDEFINED AFTER RESET)

  CCP2CON   = REG0+$1D ;  TIMER 1/2 CAPTURE / COMPARE / PWM CONTROL REGISTER

        CCP2X     = 5           ; TWO LOW ORDER BITS
        CCP2Y     = 4           ;  PWM MODE: WRITE TWO LOW ORDER BITS IN
                                ;  HIGH RESOLUTION (10BIT) MODE. MAY BE KEPT
                                ;  CONSTANT (AT 0) OF ONLY 8 BIT RESOLUTION
                                ;  IS DESIRED.
                                ;  (*0 AFTER RESET)

        CCP2M3    = 3           ; CCP2 MODE SELECT
        CCP2M2    = 2           ;  CCPM3 CCPM2 CCPM1 CCPM0  CCP2 MODE
        CCP2M1    = 1           ;   *0    *0    *0    *0      OFF
        CCP2M0    = 0           ;    0     1     0     0  CAPTURE EVERY
                                ;                           FALLING EDGE
                                ;    0     1     0     1  CAPTURE EVERY
                                ;                           RISING EDGE
                                ;    0     1     1     0  CAPTURE EVERY
                                ;                           4TH RISING EDGE
                                ;    0     1     1     1  CAPTURE EVERY
                                ;                           16TH RISING EDGE
                                ;    1     0     0     0  COMPARE MODE
                                ;                           SET OUT IF MATCH
                                ;                           (CCP2IF BIT SET)
                                ;    1     0     0     1  COMPARE MODE
                                ;                           CLR OUT IF MATCH
                                ;                           (CCP2IF BIT SET)
                                ;    1     0     1     0  COMPARE MODE
                                ;                           SW IRQ IF MATCH
                                ;                           (CCP2IF BIT SET)
                                ;                           (NO CCP1 FLG)
                                ;    1     0     1     1  COMPARE MODE
                                ;                           TRG SPEC. EVENT
                                ;                           CCP2 RESETS TMR1
                                ;                           +STARTS A/D CONV.
                                ;                           IF ENABLED
                                ;    1     1     x     x  PWM MODE

@ENDNODE
@NODE 16C6474_SPI-INTERFACE
*****************************************
* SERIAL PERIPHERAL INTERFACE REGISTERS *
*****************************************

  SSPBUF    = REG0+$13 ;  SYNC SERIAL PORT RECEIVE BUFFER/TRANSMIT REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  SSPADD    = REG1+$13 ;  SYNC SERIAL PORT ADDRESS REGISTER (I2C ONLY)
                       ;  (*0 AFTER RESET)

  SSPSTAT   = REG1+$14 ;  SYNC SERIAL PORT STATUS REGISTER

        DA        = 5           ; DATA / -ADDRESS BIT (I2C ONLY)
                                ; *0= LAST RECEIVED BYTE WAS ADDRESS
                                ;  1= LAST RECEIVED BYTE WAS DATA

        P         = 4           ; STOP BIT (I2C ONLY)
                                ; *0= STOP BIT WAS NOT DETECTED LAST
                                ;  1= STOP BIT HAS BEEN DETECTED LAST
                                ; (IS CLEARED WHEN SSP IS DISABLED)

        S         = 3           ; START BIT (I2C ONLY)
                                ; *0= START BIT WAS NOT DETECTED LAST
                                ;  1= START BIT HAS BEEN DETECTED LAST
                                ; (IS CLEARED WHEN SSP IS DISABLED)

        RW        = 2           ; READ / -WRITE BIT (I2C ONLY)
                                ;  HOLDS THE R/-W BIT INFORMATION RECEIVED
                                ;  FOLLOWING THE LAST ADDRESS MATCH
                                ; *0= WRITE
                                ;  1= READ
                                ; (IS ONLY VALID DURING TRANSITION)

        UA        = 1           ; UPDATE ADDRESS (10 BIT I2C ONLY)
                                ; *0= ADDRESS DOES NOT NEED TO BE UPDATED
                                ;  1= USER NEEDS TO UPDATE THE ADDRESS
                                ;     IN SSPADD REGISTER.

        BF        = 0           ; BUFFER FULL
                                ; (SPI AND I2C MODES)
                                ; *0= RECEIVE NOT COMPLETE, SSPBUF EMPTY
                                ;  1= RECEIVE COMPLETE,     SSPBUF FULL
                                ; (I2C ONLY)
                                ; *0= TRANSMIT COMPLETE,    SSPBUF EMPTY
                                ;  1= TRANSMIT IN PROGRESS, SSPBUF FULL

  SSPCON    = REG0+$14 ;  SYNC SERIAL PORT CONTROL REGISTER

        WCOL      = 7           ; WRITE COLLISION DETECT
                                ; *0= NO COLLISION
                                ;  1= THE SSPBUF REGISTER IS WRITTEN WHILE
                                ;     IT IS STILL TRANSMITTING

        SSPOV     = 6           ; RECEIVE OVERFLOW FLAG
                                ; (SPI ONLY)
                                ;  1= A NEW BYTE IS RECEIVED WHILE SSPBUF
                                ;     IS STILL HOLDING THE PREVIOUS DATA.
                                ;     IN THIS CASE DATA IN SSPSR IS LOST.
                                ;     (CAN ONLY OCCUR IN SLAVE MODE)
                                ;     THE USER MUST READ THE SSPBUF EVEN IF
                                ;     ONLY TRANSMITTING DATA, TO AVOID SSPOV.
                                ; (I2C ONLY)
                                ;  1= A NEW BYTE IS RECEIVED WHILE SSPBUF
                                ;     IS STILL HOLDING THE PREVIOUS DATA.
                                ;     (CAN ONLY OCCUR IN RECEIVE MODE)
                                ;  (*0 AFTER RESET)

        SSPEN     = 5           ; SYNC SERIAL PORT ENABLE
                                ; (SPI ONLY)
                                ; *0= DISABLES SERIAL PORT AND CONFIGS SCK,
                                ;     SDO AND SDI AS I/O PORT PINS.
                                ;  1= ENABLES SERIAL PORT AND CONFIGS SCK,
                                ;     SDO AND SDI AS SERIAL PORT PINS.
                                ; (I2C ONLY)
                                ; *0= DISABLES SERIAL PORT AND CONFIGURES
                                ;     SDA AND SCL AS I/O PORT PINS.
                                ;  1= ENABLES SERIAL PORT AND CONFIGURES
                                ;     SDA AND SCL AS SERIAL PORT PINS.

        CKP       = 4           ; CLOCK POLARITY SELECT
                                ; (SPI ONLY)
                                ; *0= TRANSMIT HAPPENS ON RISING EDGE,
                                ;     RECEIVE HAPPENS ON FALLING EDGE,
                                ;     IDLE STATE FOR CLOCK IS A LOW LEVEL.
                                ;  1= TRANSMIT HAPPENS ON FALLING EDGE,
                                ;     RECEIVE HAPPENS ON RISING EDGE,
                                ;     IDLE STATE FOR CLOCK IS A HIGH LEVEL.
                                ; (I2C ONLY)
                                ; SCK RELEASE CONTROL
                                ; *0= HOLDS CLOCK LOW (CLOCK STRETCH)
                                ;  1= ENABLE CLOCK
                                ;  NOTE: USED TO ENSURE DATA SETUP TIME

        SSPM3     = 3           ; SYNC SERIAL PORT MODE SELECT
        SSPM2     = 2           ;  SSPM3 SSPM2 SSPM1 SSPM0  SSP MODE
        SSPM1     = 1           ;   *0    *0    *0    *0  SPI MASTER
        SSPM0     = 0           ;                           CLOCK=OSC/4
                                ;    0     0     0     1  SPI MASTER
                                ;                           CLOCK=OSC/16
                                ;    0     0     1     0  SPI MASTER
                                ;                           CLOCK=OSC/64
                                ;    0     0     1     1  SPI MASTER
                                ;                           CLOCK=TMR2/2
                                ;    0     1     0     0  SPI SLAVE CLK=SCK
                                ;                           -SS PIN ENABLED
                                ;    0     1     0     1  SPI SLAVE CLK=SCK
                                ;                           -SS PIN DISABLED
                                ;    0     1     1     0  I2C SLAVE
                                ;                           7 BIT ADDRESS
                                ;    0     1     1     1  I2C SLAVE
                                ;                           10 BIT ADDRESS
                                ;    1     0     1     1  I2C MASTER SUPPORT
                                ;                           (SLAVE IDLE)
                                ;    1     1     1     0  I2C SLAVE
                                ;                           7 BIT ADDRESS
                                ;                           MASTER SUPPORT
                                ;    1     1     1     1  I2C SLAVE
                                ;                           10 BIT ADDRESS
                                ;                           MASTER SUPPORT

@ENDNODE
@NODE 16C74_SCI-INTERFACE
*********************************************
* SERIAL COMMUNICATIONS INTERFACE REGISTERS *
*********************************************

 .IFD HAS_SCI          ; 16C74 ONLY

  TXREG     = REG0+$19 ;  SCI TRANSMIT REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  RCREG     = REG0+$1A ;  SCI RECEIVE BUFFER
                       ;  (*UNDEFINED AFTER RESET)

  SPBRG     = REG1+$19 ;  SERIAL PORT BAUD RATE GENERATOR
                       ;               BAUD RATE FORMULA:
                       ;              BRGH=0          BRGH=1
                       ;  SYNC=0  OSC/64(SPBRG+1) OSC/16(SPBRG+1)
                       ;  SYNC=1  OSC/4(SPBRG+1)       NA
                       ;  (*UNDEFINED AFTER RESET)

  TXSTA     = REG1+$18 ;  TRANSMIT STATUS AND CONTROL REGISTER

        CSRC      = 7           ; CLOCK SOURCE SELECT BIT
                                ; *0= SLAVE MODE (EXTERNAL CLOCK)
                                ;  1= MASTER MODE (INT. CLOCK FROM BRG)
                                ; (IGNORED IN ASYNCHRONOUS MODE)

        TX89      = 6           ; TRANSMIT DATA LENGHT BIT
                                ; *0= 8 BIT TRANSMISSION
                                ;  1= 9 BIT TRANSMISSION

        TXEN      = 5           ; TRANSMIT ENABLE BIT
                                ; *0= TRANSMIT DISABLED
                                ;  1= TRANSMIT ENABLED

        SYNC      = 4           ; SCI MODE SELECT BIT
                                ; *0= ASYNCHRONOUS
                                ;  1= SYNCHRONOUS

        BRGH      = 2           ; HIGH BAUD RATE SELECT BIT
                                ; *0=
                                ;  1=
                                ; (ONLY USED IN ASYNC MODE)

        TRMT      = 1           ; TRANSMIT SHIFT REGISTER (TSR) EMPTY BIT
                                ; *0= TSR FULL
                                ;  1= TSR EMPTY

        TXD8      = 0           ; 9TH BIT OF TRANSMIT DATA
                                ; CAN BE THE CALCULATED PARITY
                                ;  (*0 AFTER RESET)

  RCSTA     = REG0+$18 ;  RECEIVE STATUS AND CONTROL REGISTER

        SPEN      = 7           ; SERIAL PORT ENABLE BIT
                                ; *0= SERIAL PORT DISABLED
                                ;  1= CONFIGS RA4/RX/DT AND RA5/TX/CK
                                ;     AS SERIAL PORT PINS

        RC89      = 6           ; RECEIVE DATA LENGHT BIT
                                ; *0= 8 BIT RECEPTION
                                ;  1= 9 BIT RECEPTION

        SREN      = 5           ; SINGLE RECEIVE ENABLE BIT
                                ; *0= DISABLE RECEPTION ?
                                ;  1= ENABLE RECEPTION
                                ; IS CLERED AFTER RECEPTION IS COMPLETE
                                ; (IGNORED IN SLAVE SYNC MODE)
                                ; (IGNORED IN ASYNC MODE)

        CREN      = 4           ; CONTINOUS RECEIVE ENABLE
                                ; (ASYNC ONLY)
                                ; *0= DISABLE RECEPTION
                                ;  1= ENABLE RECEPTION
                                ; (SYNC ONLY)
                                ; *0= DISABLE CONTINOUOS RECEPTION ?
                                ;  1= ENABLE CONTINOUOS RECEPTION UNTIL
                                ;     CREN IS CLEARED.
                                ;     CREN OVERRIDES SREN.

        FERR      = 2           ; FRAMING ERROR BIT
                                ; *0= NO FRAMING ERROR
                                ;  1= FRAMING ERROR

        OERR      = 1           ; OVERRUN ERROR
                                ; *0= NO OVERRUN
                                ;  1= OVERRUN, RESET BY CLEARING CREN

        RCD8      = 0           ; 9TH BIT OF RECEIVE DATA
                                ; CAN BE THE CALCULATED PARITY
                                ;  (*0 AFTER RESET)

 .ENDIF

@ENDNODE
@NODE 16C74_ADCs
******************************************
* ANALOG -> DIGITAL CONVERSION REGISTERS *
******************************************

 .IFD HAS_ADC          ; 16C74 ONLY

  ADRES     = REG0+$1E ;  A/D RESULT REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  ADCON0    = REG0+$1F ;  A/D CONTROL REGISTER 0

        ADCS1     = 7           ; A/D CONVERSION CLOCK SELECT
        ADCS0     = 6           ;   ADCS1   ADCS1    CLOCK RATE
                                ;    *0      *0        OSC/2
                                ;     0       1        OSC/8
                                ;     1       0        OSC/32
                                ;     1       0         F_RC (RC-OSCILLATOR)

        CHS2      = 5           ; A/D CHANNEL SELECT
        CHS1      = 4           ;  CS2 CS1 CS0   CHANNEL
        CHS0      = 3           ;  *0  *0  *0    RA0/AIN0
                                ;   0   0   1    RA1/AIN1
                                ;   0   1   0    RA2/AIN2
                                ;   0   1   1    RA3/AIN3
                                ;   1   0   0    RA4/AIN4
                                ;   1   0   1    RA5/AIN5
                                ;   1   1   0    RA6/AIN6
                                ;   1   1   1    RA7/AIN7


        GODONE    = 2           ; A/D CONVERSION STATUS BIT
                                ; *0= A/D CONVERSION NOT ON PROGRESS
                                ;       OR COMPLETED.
                                ;  1= CONVERSION IN PROGRESS
                                ;       SET THIS BIT TO START CONVERSION

        ADON      = 0           ; A/D ON BIT
                                ; *0= A/D MODULE SHUT OFF, NO POWER DRAIN
                                ;  1= A/D MODULE IS OPERATING

  ADCON1    = REG1+$1F ;  A/D CONTROL REGISTER 1

        PCFG2     = 2           ; A/D PORT CONFIGURATION BITS
        PCFG1     = 1           ;  PC2 PC1 PC0  A0 A1 A2 A5 A3 E0 E1 E2  REF
        PCFG0     = 0           ;  *0  *0  *0    A  A  A  A  A  A  A  A  VDD
                                ;   0   0   1    A  A  A  A REF A  A  A  RA3
                                ;   0   1   0    A  A  A  A  A  D  D  D  VDD
                                ;   0   1   1    A  A  A  A REF D  D  D  RA3
                                ;   1   0   0    A  A  D  D  A  D  D  D  VDD
                                ;   1   0   1    A  A  D  D REF D  D  D  RA3
                                ;   1   1   x    D  D  D  D  D  D  D  D  ---

 .ENDIF

@ENDNODE


