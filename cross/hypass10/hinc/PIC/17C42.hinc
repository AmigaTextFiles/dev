@DATABASE
@NODE MAIN 17C42
* 17C42 HyperSource© include file for 17C42
* © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
*
* source: Microchip databook 1994
*

    @{" 17C42_MEMORY        " link "17C42_MEMORY"}
    @{" 17C42_CPU-CORE      " link "17C42_CPU-CORE"}
    @{" 17C42_INTERRUPTS    " link "17C42_INTERRUPTS"}

    @{" 17C42_IO-PORTS      " link "17C42_IO-PORTS"}
    @{" 17C42_SCI-INTERFACE " link "17C42_SCI-INTERFACE"}

    @{" 17C42_TIMERS        " link "17C42_TIMERS"}

* Values with a '*' in front of them show the defaults after a RESET.

*  NOTE: ALL REGISTER AND BIT NAMES WERE TAKEN OUT THE MANUAL,
*        EXCEPT THE 16/9 BIT IN TCON1, NOW NAMED TMR16E.

@ENDNODE
@NODE 17C42_MEMORY
****************************
*        MEMORY MAP        *
****************************

; 33 port lines, 40 pins

  REGS      = $0000    ;    8 BYTES REGS   (UNPAGED) $00-0F
  REG0      = $0000    ;   32 BYTES REGS   (4 PAGES) $10-17 EACH
  REG1      = $0000    ;
  REG2      = $0000    ;
  REG3      = $0000    ;

  RAM_BOT   = $0018    ;
  RAM_PBOT  = $0018    ;
  RAM_SIZE  = $00E8    ;  232 BYTES RAM    (UNPAGED)
  RAM_TOP   = $0100    ;
  RAM_PAGES =     1    ;
  RAM_BITS  =     8    ;

  ROM_BOT   = $0000    ;
  ROM_SIZE  = $0800    ; 2048 WORDS ROM_16 (UNPAGED)
  ROM_TOP   = $0800    ;
  ROM_PAGES =     1    ;
  ROM_BITS  =    16    ;


@ENDNODE
@NODE 17C42_INTERRUPTS
****************************
*    INTERRUPT VECTORS     *
****************************

  ; THESE ARE NO VECTORS BUT PROGRAM MEMORY LOCATIONS THE CPU JUMPS TO
  ; MUST CONTAIN OBJECT CODE TO JUMP TO YOUR RELATING ROUTINES !

  C_RESET   = $0000    ;
  C_INTIRQ  = $0008    ; HIGHEST INTERRUPT PRIORITY
  C_T0IRQ   = $0010    ;
  C_RTXIRQ  = $0018    ;
  C_PEIRQ   = $0020    ; LOWEST  INTERRUPT PRIORITY


*******************************
* INTERRUPT CONTROL REGISTERS *
*******************************

  INTSTA    = REGS+$07 ;  INTERRUPT CONTROL REGISTER

        PEIR      = 7           ; PERIPHERAL INTERRUPT FLAG
                                ;  1= PERIPHERAL INTERRUPT
                                ; *0= CLEARED BY HARDWARE
                                ;  IT IS READ ONLY !

        RTXIR     = 6           ; RA1/T0CKI PIN INTERRUPT FLAG
                                ;  1= RISING OR FALLING EDGE OF T0CKI PIN
                                ; *0= RESET AUTOMATICALLY BY HARDWARE !

        T0IR      = 5           ; TIMER 0 OVERFLOW INTERRUPT FLAG
                                ;  1= TMR0 OVERFLOW
                                ; *0= RESET AUTOMATICALLY BY HARDWARE !

        INTIR     = 4           ; INT INTERRUPT FLAG
                                ;  1= RISING OR FALLING EDGE OF INT PIN
                                ; *0= RESET AUTOMATICALLY BY HARDWARE !

        PEIE      = 3           ; PERIPHERAL INTERRUPT ENABLE BIT
                                ; *0= DISABLE ALL PERIPHERAL INTERRRUPT
                                ;  1= ENABLE ALL PERIPHERAL INTERRRUPT

        RTXIE     = 2           ; RA1/T0CKI PIN INTERRUPT ENABLE BIT
                                ; *0= DISABLE RTXIR INTERRRUPT
                                ;  1= ENABLE RTXIR INTERRRUPT

        T0IE      = 1           ; TMR0 INTERRUPT ENABLE BIT
                                ; *0= DISABLE T0IR INTERRRUPT
                                ;  1= ENABLE T0IR INTERRRUPT

        INTIE     = 0           ; INT INTERRUPT ENABLE BIT
                                ; *0= DISABLE INTIR INTERRRUPT
                                ;  1= ENABLE INTIR INTERRRUPT

  PIR     = REG1+$16 ;  PERIPHERAL INTERRUPT REQUEST REGISTER

        IRB       = 7           ; PORTB CHANGE INTERRUPT
                                ;  1= PORTB INPUT CHANGED
                                ; *0= RESET IN SOFTWARE !

        TM3IR     = 6           ; TIMER3 INTERRUPT FLAG
                                ;  1= TIMER 3 OVERFLOWS (CA1/-PRA3=1),
                                ;     TIMER 3 REACHES PERIOD VALUE
                                ;     AND RESETS (CA1/-PRA3=0)
                                ; *0= RESET IN SOFTWARE !

        TM2IR     = 5           ; TIMER2 INTERRUPT FLAG
                                ;  1= TIMER2 REACHES PERIOD VALUE AND RESETS
                                ; *0= RESET IN SOFTWARE !

        TM1IR     = 4           ; TIMER1 INTERRUPT FLAG
                                ;  1= TIMER1 REACHES PERIOD VALUE AND RESETS
                                ; *0= RESET IN SOFTWARE !

        CA2IR     = 3           ; CAPTURE2 INTERRUPT FLAG
                                ;  1= CAPTURE EVENT  OCCURS
                                ; *0= RESET IN SOFTWARE !

        CA1IR     = 2           ; CAPTURE1 INTERRUPT FLAG
                                ;  1= CAPTURE EVENT  OCCURS
                                ; *0= RESET IN SOFTWARE !

        TBMT      = 1           ; SCI TRANSMIT INTERRUPT FLAG
                                ; *1= TRANSMIT BUFFER IS EMPTY
                                ;  0= TRANSMIT BUFFER IS FULL
                                ;  IT IS READ ONLY !

        RBFL      = 0           ; SCI RECEIVE INTERRUPT FLAG
                                ;  1= RECEIVE BUFFER IS FULL
                                ; *0= RECEIVE BUFFER IS EMPTY
                                ;  IT IS READ ONLY !

  PIE1     = REG1+$17 ;  PERIPHERAL INTERRUPT ENABLE REGISTER

        IEB       = 7           ; PORTB CHANGE INTERRUPT ENABLE
                                ; *0= DISABLE IRB INTERRUPT
                                ;  1= ENABLE IRB INTERRUPT

        TM3IE     = 6           ; TIMER3 INTERRUPT ENABLE
                                ; *0= DISABLE TM3IR INTERRRUPTS
                                ;  1= ENABLE TM3IR INTERRRUPTS

        TM2IE     = 5           ; TIMER2 INTERRUPT ENABLE
                                ; *0= DISABLE TM2IR INTERRRUPT
                                ;  1= ENABLE TM2IR INTERRRUPT

        TM1IE     = 4           ; TIMER1 INTERRUPT ENABLE
                                ; *0= DISABLE TM1IR INTERRRUPT
                                ;  1= ENABLE TM1IR INTERRRUPT

        CA2IE     = 3           ; CAPTURE2 INTERRUPT ENABLE
                                ; *0= DISABLE CA2IR INTERRRUPT
                                ;  1= ENABLE CA2IR INTERRRUPT

        CA1IE     = 2           ; CAPTURE1 INTERRUPT ENABLE
                                ; *0= DISABLE CA1IR INTERRRUPT
                                ;  1= ENABLE CA1IR INTERRRUPT

        TXIE      = 1           ; SCI TRANSMIT INTERRUPT ENABLE
                                ; *0= DISABLE TBMT INTERRRUPT
                                ;  1= ENABLE TBMT INTERRRUPT

        RCIE      = 0           ; SCI RECEIVE INTERRUPT ENABLE
                                ; *0= DISABLE RBFL INTERRRUPT
                                ;  1= ENABLE RBFL INTERRRUPT

@ENDNODE
@NODE 17C42_CPU-CORE
************************
*       CPU CORE       *
************************

  INDF0     = REGS+$00 ;  USE CONTENTS OF FSR0 TO ADDRESS DATA MEMORY
                       ;  (NO PHYSICAL REGISTER)
                       ;  (*0 AFTER RESET)


  FSR0      = REGS+$01 ;  INDIRECT DATA MEMORY ADDRESS POINTER 0
                       ;  (*UNDEFINED AFTER RESET)

  INDF1     = REGS+$08 ;  USE CONTENTS OF FSR1 TO ADDRESS DATA MEMORY
                       ;  (NO PHYSICAL REGISTER)
                       ;  (*0 AFTER RESET)

  FSR1      = REGS+$09 ;  INDIRECT DATA MEMORY ADDRESS POINTER 1
                       ;  (*UNDEFINED AFTER RESET)

  PCL       = REGS+$02 ;  LOW ORDER 8 BITS OF PC
                       ;  (*0 AFTER RESET)

  PCLATH    = REGS+$03 ;  HOLDING REGISTER FOR HIGH BYTE OF PC
                       ;  (*UNDEFINED AFTER RESET)

  W         = REGS+$0A ;  ALU W REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  TBLPTRL   = REGS+$0D ;  LOW  BYTE OF PROGRAM MEMORY TABLE POINTER
  TBLPTRH   = REGS+$0E ;  HIGH BYTE OF PROGRAM MEMORY TABLE POINTER
                       ;  (*UNDEFINED AFTER RESET)

  BSR       = REGS+$0F ;  BANK SELECT REGISTER
                       ;  (*0 AFTER RESET)

  ALUSTA    = REGS+$04 ;  ALU STATUS REGISTER

        FS3       = 7           ; FSR1 MODE SELECT
        FS2       = 6           ;  FS1 FS0
                                ;   0   0   POST AUTO DECREMENT
                                ;   0   1   POST AUTO INCREMENT
                                ;   1   0   RESERVED
                                ;  *1  *1   NO CHANGE (DEFAULT)

        FS1       = 5           ; FSR0 MODE SELECT
        FS0       = 4           ;  FS1 FS0
                                ;   0   0   POST AUTO DECREMENT
                                ;   0   1   POST AUTO INCREMENT
                                ;   1   0   RESERVED
                                ;  *1  *1   NO CHANGE (DEFAULT)

        OV        = 3           ; OVERFLOW FLAG
                                ;  SET WHEN AN OVERFLOW (FROM MAGNITUDE
                                ;  TO SIGN BIT) OCCURS IN AN ARITHMETIC
                                ;  OPERATION. IT IS THE XOR OF CARRY IN
                                ;  AND CARRY OUT OF THE MSB BIT.
                                ;  (*UNDEFINED AFTER RESET)

        Z         = 2           ; ZERO FLAG
                                ;  LAST ARITHMETIC OR LOGIC OPERATION
                                ;  RESULTS IN ZERO
                                ;  (*UNDEFINED AFTER RESET)

        DC        = 1           ; DIGIT CARRY FLAG
                                ;  SET BY ARITHMETIC INSTRUCTIONS WHEN A
                                ;  CARRY FROM LOWER TO UPPER NIBBLE OCCURS
                                ;  (*UNDEFINED AFTER RESET)

        C         = 0           ; CARRY FLAG
                                ;  SET BY ARITHMETIC INSTRUCTIONS WHEN A
                                ;  CARRY OUT FROM MSB OCCURS
                                ;  ALSO AFFECTED BY ROTATE THROUGH CARRY
                                ;  (*UNDEFINED AFTER RESET)

  CPUSTA    = REGS+$06 ;  CPU STATUS REGISTER

        STKAV     = 5           ; STACK AVAILABLE BIT
                                ; *1= STACK IS AVAILABLE
                                ;  0= STACK FULL OR STACK ERROR

        GLINTD    = 4           ; GLOBAL INTERRUPT DISABLE BIT
                                ; *1= DISABLE ALL INTERRRUPTS
                                ;  0= ENABLE ALL INTERRRUPTS

        TO        = 3           ; TIMEOUT BIT, ACTIVE LOW !
                                ;  0= WATCHDOG TIMEOUT OCCURED
                                ; *1= SET BY CLRWDT, SLEEP, POWER UP

        PD        = 2           ; POWER DOWN BIT, ACTIVE LOW !
                                ;  0= POWER DOWN OCCURED
                                ;     OR SLEEP WAS EXECUTED
                                ; *1= SET BY CLRWDT OR POWER UP

@ENDNODE
@NODE 17C42_IO-PORTS
****************************
*   INPUT/ OUTPUT PORTS    *
****************************

  PORTA     = REG0+$10 ;  PORT A DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET, EXCEPT PUEB)

        RA5       = 5           ; INPUT ONLY (SCHMITT TRIGGER)
        RA4       = 4           ; INPUT ONLY (SCHMITT TRIGGER)
        RA3       = 3           ; I/O (SCHMITT TRIGGER/OPEN DRAIN) USE PULLUP
        RA2       = 2           ; I/O (SCHMITT TRIGGER/OPEN DRAIN) USE PULLUP
        RA1       = 1           ; INPUT ONLY (SCHMITT TRIGGER)
        RA0       = 0           ; INPUT ONLY (SCHMITT TRIGGER)

        PUEB      = 7           ; PORTB WEAK PULLUP DISABLE BIT
                                ; *0=ENABLE 1=DISABLE WEAK PULLUP

        CK        = 5           ; SYNC SERIAL CLOCK I/O (IF SPEN=1,SYNC=1)
        TX        = 5           ; ASYNC SERIAL OUT      (IF SPEN=1,SYNC=0)
        DT        = 4           ; SYNC SERIAL I/O       (IF SPEN=1,SYNC=1)
        RX        = 4           ; ASYNC SERIAL IN       (IF SPEN=1,SYNC=0)
        T0CKI     = 1           ; T0CKI EXTERNAL INTERRUPT INPUT
                                ;  ALSO EXTERNAL CLOCK IN FOR TMR0
        INT       = 0           ; INT EXTERNAL INTERRUPT INPUT

  DDRB      = REG0+$11 ;  DATA DIRECTION REGISTER FOR PORT B

        DDRB7     = 7           ; (0=OUT, *1=IN)
        DDRB6     = 6           ; (0=OUT, *1=IN)
        DDRB5     = 5           ; (0=OUT, *1=IN)
        DDRB4     = 4           ; (0=OUT, *1=IN)
        DDRB3     = 3           ; (0=OUT, *1=IN)
        DDRB2     = 2           ; (0=OUT, *1=IN)
        DDRB1     = 1           ; (0=OUT, *1=IN)
        DDRB0     = 0           ; (0=OUT, *1=IN)

  PORTB     = REG0+$12 ;  PORT B DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RB7       = 7           ; I/O (SCHMITT TRIGGER IN)
        RB6       = 6           ; I/O (SCHMITT TRIGGER IN)
        RB5       = 5           ; I/O (SCHMITT TRIGGER IN)
        RB4       = 4           ; I/O (SCHMITT TRIGGER IN)
        RB3       = 3           ; I/O (SCHMITT TRIGGER IN)
        RB2       = 2           ; I/O (SCHMITT TRIGGER IN)
        RB1       = 1           ; I/O (SCHMITT TRIGGER IN)
        RB0       = 0           ; I/O (SCHMITT TRIGGER IN)

        TCLK3     = 5           ; TIMER3   CLOCK INPUT (SCHMITT TRIGGER)
        TCLK12    = 4           ; TIMER1/2 CLOCK INPUT (SCHMITT TRIGGER)
        PWM2      = 3           ; PWM2 OUTPUT (IF PWM2ON=1)
        PWM1      = 2           ; PWM1 OUTPUT (IF PWM1ON=1)
        CAP2      = 1           ; CAPTURE2 INPUT (SCHMITT TRIGGER)
        CAP1      = 0           ; CAPTURE1 INPUT (SCHMITT TRIGGER)

  DDRC      = REG1+$10 ;  DATA DIRECTION REGISTER FOR PORT C

        DDRC7     = 7           ; (0=OUT, *1=IN)
        DDRC6     = 6           ; (0=OUT, *1=IN)
        DDRC5     = 5           ; (0=OUT, *1=IN)
        DDRC4     = 4           ; (0=OUT, *1=IN)
        DDRC3     = 3           ; (0=OUT, *1=IN)
        DDRC2     = 2           ; (0=OUT, *1=IN)
        DDRC1     = 1           ; (0=OUT, *1=IN)
        DDRC0     = 0           ; (0=OUT, *1=IN)

  PORTC     = REG1+$11 ;  PORT C DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RC7       = 7           ; I/O
        RC6       = 6           ; I/O
        RC5       = 5           ; I/O
        RC4       = 4           ; I/O
        RC3       = 3           ; I/O
        RC2       = 2           ; I/O
        RC1       = 1           ; I/O
        RC0       = 0           ; I/O

  DDRD      = REG1+$12 ;  DATA DIRECTION REGISTER FOR PORT D

        DDRD7     = 7           ; (0=OUT, *1=IN)
        DDRD6     = 6           ; (0=OUT, *1=IN)
        DDRD5     = 5           ; (0=OUT, *1=IN)
        DDRD4     = 4           ; (0=OUT, *1=IN)
        DDRD3     = 3           ; (0=OUT, *1=IN)
        DDRD2     = 2           ; (0=OUT, *1=IN)
        DDRD1     = 1           ; (0=OUT, *1=IN)
        DDRD0     = 0           ; (0=OUT, *1=IN)

  PORTD     = REG1+$13 ;  PORT D DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RD7       = 7           ; I/O
        RD6       = 6           ; I/O
        RD5       = 5           ; I/O
        RD4       = 4           ; I/O
        RD3       = 3           ; I/O
        RD2       = 2           ; I/O
        RD1       = 1           ; I/O
        RD0       = 0           ; I/O

  DDRE      = REG1+$14 ;  DATA DIRECTION REGISTER FOR PORT E

        DDRE2     = 2           ; (0=OUT, *1=IN)
        DDRE1     = 1           ; (0=OUT, *1=IN)
        DDRE0     = 0           ; (0=OUT, *1=IN)

  PORTE     = REG1+$15 ;  PORT E DATA REGISTER
                       ;  (*UNDEFINED AFTER RESET)

        RE2       = 2           ; I/O
        RE1       = 1           ; I/O
        RE0       = 0           ; I/O


@ENDNODE
@NODE 17C42_TIMERS
****************************
*     TIMER REGISTERS      *
****************************

  TMR0L     = REGS+$0B ;  TIMER 0 COUNTER REGISTER LOW  BYTE
  TMR0H     = REGS+$0C ;  TIMER 0 COUNTER REGISTER HIGH BYTE
                       ;  (*UNDEFINED AFTER RESET)

  TMR1      = REG2+$10 ;  TIMER1 COUNTER REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  TMR2      = REG2+$11 ;  TIMER2 COUNTER REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  TMR3L     = REG2+$12 ;  TIMER3 COUNTER REGISTER  LOW BYTE
  TMR3H     = REG2+$13 ;  TIMER3 COUNTER REGISTER HIGH BYTE
                       ;  (*UNDEFINED AFTER RESET)

  PR1       = REG2+$14 ;  TIMER1 PERIOD REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  PR2       = REG2+$15 ;  TIMER2 PERIOD REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  PR3L      = REG2+$16 ;  TIMER3 PERIOD REGISTER  LOW BYTE = CA1L
  PR3H      = REG2+$17 ;  TIMER3 PERIOD REGISTER HIGH BYTE = CA1H
                       ;  (*UNDEFINED AFTER RESET)

  CA1L      = REG2+$16 ;  CAPTURE1 REGISTER  LOW BYTE      = PR3L
  CA1H      = REG2+$17 ;  CAPTURE1 REGISTER HIGH BYTE      = PR3H
                       ;  (*UNDEFINED AFTER RESET)

  CA2L      = REG3+$14 ;  CAPTURE2 REGISTER  LOW BYTE
  CA2H      = REG3+$15 ;  CAPTURE2 REGISTER HIGH BYTE
                       ;  (*UNDEFINED AFTER RESET)

  PW1DCL    = REG3+$10 ;  PWM1 DUTY CYCLE, LOWER 2 BITS (BIT7/6)
  PW1DCH    = REG3+$12 ;  PWM1 DUTY CYCLE, UPPER 8 BITS
                       ;  (*UNDEFINED AFTER RESET)

  PW2DCL    = REG3+$11 ;  PWM2 DUTY CYCLE, LOWER 2 BITS (BIT7/6) BIT5=TM2PW2
  PW2DCH    = REG3+$13 ;  PWM2 DUTY CYCLE, UPPER 8 BITS
                       ;  (*UNDEFINED AFTER RESET,EXCEPT TM2PW2)

        TM2PW2    = 5           ; PWM2 CONTROL BIT
                                ; *0= PWM2 OUTPUT DETERMINED BY TIMER1
                                ;  1= PWM2 OUTPUT DETERMINED BY TIMER2

  RTCSTA    = REGS+$05 ;  TIMER 0 STATUS REGISTER

        INTEDG    = 7           ; INT INTERRUPT EDGE SELECT
                                ; *0= INTERRUPT ON FALLING EDGE
                                ;  1= INTERRUPT ON RISING EDGE

        RTEDG     = 6           ; TIMER0 RA1/T0CKI CLOCK EDGE SELECT
                                ; *0= INCREMENTS AND/OR RA1/T0CKI INTERRUPT
                                ;     GENERATED ON FALLING EDGE OF RA1/T0CKI
                                ;  1= INCREMENTS AND/OR RA1/T0CKI INTERRUPT
                                ;     GENERATED ON RISING EDGE OF RA1/T0CKI

        TC        = 5           ; TIMER0 MODE SELECT
                                ; *0= COUNTER MODE,
                                ;     I.E. CLOCK SOURCE IS EXTERNAL (RT PIN)
                                ;  1= TIMER MODE,
                                ;     I.E. CLOCK SOURCE IS INTERNAL (OSC/4)


       RTPS3      = 4           ; TIMER0 PRESCALE SELECT
       RTPS2      = 3           ;  RTPS3  RTPS2  RTPS1 RTPS0 PRESCALE VAL
       RTPS1      = 2           ;   *0     *0     *0     *0        1:1
       RTPS0      = 1           ;    0      0      0      1        1:2
                                ;    0      0      1      0        1:4
                                ;    0      0      1      1        1:8
                                ;    0      1      0      0        1:16
                                ;    0      1      0      1        1:32
                                ;    0      1      1      0        1:64
                                ;    0      1      1      1        1:128
                                ;    1      X      X      X        1:256

  TCON1     = REG3+$16 ;  TIMER/CAPTURE/PWM CONTROL REGISTER 1

        CA2ED1    = 7           ; CAPTURE2 MODE SELECT
        CA2ED0    = 6           ;   CA2ED1  CA2ED0  CAPTURE ON:
                                ;    *0      *0     EVERY FALLING EDGE
                                ;     0       1     EVERY RISING EDGE
                                ;     1       0     EVERY 4TH RISING EDGE
                                ;     1       1     EVERY 16TH RISING EDGE

        CA1ED1    = 5           ; CAPTURE1 MODE SELECT
        CA1ED0    = 4           ;   CA1ED1  CA1ED0  CAPTURE ON:
                                ;    *0      *0     EVERY FALLING EDGE
                                ;     0       1     EVERY RISING EDGE
                                ;     1       0     EVERY 4TH RISING EDGE
                                ;     1       1     EVERY 16TH RISING EDGE

        TMR16E    = 3           ; TMR1/TMR2 CONNECTION SELECT
                                ; *0= TWO SEPARATE 8-BIT TIMERS
                                ;  1= ONE 16-BIT TIMER/COUNTER
                                ;  THIS NAME IS NOT ORIGINAL! (ORG: 16/8)

        TMR3C     = 2           ; TIMER3 CLOCK SELECT
                                ; *0= INTERNAL CLOCK (TIMER MODE)
                                ;  1= FALLING EDGE OF TCLK3 (COUNTER MODE)

        TMR2C     = 1           ; TIMER2 CLOCK SELECT
                                ; *0= INTERNAL CLOCK (TIMER MODE)
                                ;  1= FALLING EDGE OF TCLK12 (COUNTER MODE)
                                ;   (IGNORED IN 16BIT MODE)

        TMR1C     = 0           ; TIMER1 CLOCK SELECT
                                ; *0= INTERNAL CLOCK (TIMER MODE)
                                ;  1= FALLING EDGE OF TCLK12 (COUNTER MODE)

  TCON2     = REG3+$16 ;  TIMER/CAPTURE/PWM CONTROL REGISTER 2

        CA2OVF    = 7           ; CAPTURE2 OVERFLOW FLAG
                                ;  1= SET (OR RESET) WHEN BOTH BYTES OF THE
                                ;     CAPTURE REGISTER ARE READ AND AN
                                ;     OVERFLOW HAS OCCURED (OR NOT)
                                ; *0= NO OVERFLOW

        CA1OVF    = 6           ; CAPTURE1 OVERFLOW FLAG
                                ;  1= SET (OR RESET) WHEN BOTH BYTES OF THE
                                ;     CAPTURE REGISTER ARE READ AND AN
                                ;     OVERFLOW HAS OCCURED (OR NOT)
                                ; *0= NO OVERFLOW

        PWM2ON    = 5           ; RB3/PWM2 PIN CONFIGURATION
                                ; *0= PORT PIN, DIRECTION BY DDR BIT
                                ;  1= PWM2 OUTPUT, FORCED TO OUTPUT

        PWM1ON    = 4           ; RB2/PWM1 PIN CONFIGURATION
                                ; *0= PORT PIN, DIRECTION BY DDR BIT
                                ;  1= PWM1 OUTPUT, FORCED TO OUTPUT

        CA1PR3    = 3           ; CA1/PR3 MODE SELECT
                                ; *0= PERIOD REGISTERS FOR TIMER3 (PR3L/PR3H)
                                ;  1= CAPTURE1 REGISTERS          (CA1L/CA1H)
                                ;     (TIMER3 RUNS WITHOUT PERIOD REGISTER)

        TMR3ON    = 2           ; TIMER3 ENABLE BIT
                                ; *0= TMR3 IS STOPPED
                                ;  1= TMR3 IS RUNNING

        TMR2ON    = 1           ; TIMER2 ENABLE BIT
                                ; *0= TMR2 IS STOPPED
                                ;  1= TMR2 IS RUNNING
                                ;  (MUST BE 1 IN 16BIT MODE)

        TMR1ON    = 0           ; TIMER1 ENABLE BIT
                                ; *0= TMR1 IS STOPPED
                                ;  1= TMR1 IS RUNNING


@ENDNODE
@NODE 17C42_SCI-INTERFACE
*********************************************
* SERIAL COMMUNICATIONS INTERFACE REGISTERS *
*********************************************

  RCREG     = REG0+$14 ;  SERIAL PORT RECEIVE TEGISTER
                       ;  (*UNDEFINED AFTER RESET)

  TXREG     = REG0+$16 ;  SERIAL PORT TRANSMIT REGISTER
                       ;  (*UNDEFINED AFTER RESET)

  RCSTA     = REG0+$13 ;  RECEIVE STATUS & CONTROL REGISTER

        SPEN      = 7           ; SERIAL PORT ENABLE
                                ; *0= DISABLES SERIAL PORT AND CONFIGS
                                ;     RA4/RX/DT AND RA5/TX/CK AS I/O PINS.
                                ;  1= ENABLES SERIAL PORT AND CONFIGS
                                ;     RA4/RX/DT AND RA5/TX/CK AS SIO PINS.

        RC89      = 6           ; RECEPTION LENGHT SELECT
                                ; *0= 8 BITS
                                ;  1= 9 BITS

        SREN      = 5           ; SINGLE RECEIVE ENABLE (SYNC MODE ONLY)
                                ; *0= DISABLE SINGLE RECEPTION
                                ;  1= ENABLE RECEPTION
                                ;  IS CLEARED AFTER RECEPTION IS COMPLETE
                                ;  (IGNORED IN ASYNC MODE)

        CREN      = 4           ; CONTINOUS RECEIVE ENABLE
                                ; ASYNC MODE:
                                ; *0= DISABLE RECEPTION
                                ;  1= ENABLE RECEPTION
                                ; SYNC MODE:
                                ; *0= DISABLE CONTINOUS RECEPTION
                                ;  1= ENABLE CONTINOUS RECEPTION
                                ; CREN OVERRIDES SREN

        FERR      = 2           ; FRAMING ERROR BIT
                                ; *0= NO FRAMING ERROR
                                ;  1= FRAMING ERROR

        OERR      = 1           ; OVERRUN ERROR
                                ; *0= NO OVERRUN
                                ;  1= OVERRUN, RESET BY CLEARING CREN

        RCD8      = 0           ; 9TH BIT OF RECEIVE DATA
                                ;  (*UNDEFINED AFTER RESET)


  TXSTA     = REG0+$15 ;  TRANSMIT STATUS & CONTROL REGISTER

        CSRC      = 7           ; CLOCK SOURCE SELECT BIT
                                ; *0= EXTERNAL CLOCK
                                ;  1= INTERNAL CLOCK FROM BRG
                                ; (IGNORED IN ASYNCHRONOUS MODE)

        TX89      = 6           ; TRANSMIT DATA LENGHT BIT
                                ; *0= 8 BIT TRANSMISSION
                                ;  1= 9 BIT TRANSMISSION

        TXEN      = 5           ; TRANSMIT ENABLE BIT
                                ; *0= TRANSMIT DISABLED
                                ;  1= TRANSMIT ENABLED
                                ; SREN/RCEN OVERRIDES TXEN

        SYNC      = 4           ; SCI MODE SELECT BIT
                                ; *0= ASYNCHRONOUS
                                ;  1= SYNCHRONOUS

        TRMT      = 1           ; TRANSMIT SHIFT REGISTER (TSR) EMPTY BIT
                                ;  0= TSR FULL
                                ; *1= TSR EMPTY

        TXD8      = 0           ; 9TH BIT OF TRANSMIT DATA
                                ;  (*UNDEFINED AFTER RESET)


  SPBRG     = REG0+$19 ;  SERIAL PORT BAUD RATE GENERATOR
                       ;    BAUD RATE FORMULA:
                       ;  SYNC=0  OSC/64(SPBRG+1)
                       ;  SYNC=1  OSC/4(SPBRG+1)
                       ;  (*UNDEFINED AFTER RESET)


@ENDNODE
