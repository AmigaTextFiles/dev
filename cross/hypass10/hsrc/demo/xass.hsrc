@DATABASE
@NODE MAIN
*$VER: XASS lib test V1.0 (19.7.96)
*©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED



  @{" XASS  PC control  " LINK XASS_PCCONTROL   }
  @{" XASS  mem alloc   " LINK XASS_MEMALLOC    }
  @{" XASS  assignments " LINK XASS_ASSIGNMENTS   }
  @{" XASS  conditional " LINK XASS_CONDITIONAL }
  @{" XASS  including   " LINK XASS_INCLUDING   }
  @{" XASS  macros      " LINK XASS_MACROS      }
  @{" XASS  case test   " LINK XASS_CASE        }
  @{" XASS  dummies     " LINK XASS_DUMMIES     }
  @{" XASS  formatting  " LINK XASS_FORMATTING  }

  /*

    This may be very usefull to write long
    docs into source files

  */


@ENDNODE
* pseudos -----------------------------------------------------------------
@NODE XASS_PCCONTROL
  * XASS PC control

    .BASE $8000 ; defines code segment
    .WORD 12

    .DATA
    .BASE $1000 ; defines data segment
    .WORD 12

    .RAM
     *=   $2000 ; defines ram segment
    .WORD 12

    .AUTO
        *=$3000 ; defines auto segment
    .WORD 12

    .RAM
    .WORD 12

    .DATA
    .WORD 12

    .AUTO
    .WORD 12

    .CODE
    .WORD 12

@ENDNODE
@NODE XASS_MEMALLOC
  * XASS memory allocation

    .BYTE  $89,"abc",0 ; bytes

    .BYTE  $89         ; byte
    .WORD  $1234       ; word
    .TRIP  $123456     ; triple
    .LONG  $12345678   ; long word

    .DBYT  $1234       ; rev. word as6502
    .RWORD $1234       ; rev. word
    .RTRIP $123456     ; rev. triple
    .RLONG $12345678   ; rev. long word

    .ASCII "abcdefg"   ; string
    .ASCII 'abcdefg'   ; string
    .ASCII /abcdefg/   ; string

    .VERS              ; version string

    .BLOCK 16, 'a      ; block of bytes
    .BLOCK 16          ; block of bytes
    .WBLOCK 8, 'a      ; block of words
    .WBLOCK 8          ; block of words
    .LBLOCK 4, 'a      ; block of long words
    .LBLOCK 4          ; block of long words

    .ZERO  16          ; zero block
    .ZERO  7           ; zero block

    .RMB   16          ; reserve memory bytes
    .RMW   8           ; reserve memory words
    .RML   4           ; reserve memory long words


    .ALIGN 4           ; long word alignment
    .ALIGN 256, 0      ; page alignment

    NOP                ; 1  NOP
    NOP 32             ; 32 NOPs
    .NOP               ; 1  NOP
    .NOP 32            ; 32 NOPs

    .ASCII "\abla"         ; $07 BEL Bell, alert
    .ASCII "\bbla"         ; $08 BS  Backspace
    .ASCII "\fbla"         ; $0C FF  Form feed
    .ASCII "\nbla"         ; $0A LF  Line feed
    .ASCII "\rbla"         ; $0D CR  Carriage return
    .ASCII "\tbla"         ; $09 HT  Horizontal tabulator
    .ASCII "\vbla"         ; $0B VT  Vertical tabulator
    .ASCII "\\bla"         ; $5C \   Backslash
    .ASCII "\?bla"         ; $3F ?   Question mark
    .ASCII "\'bla"         ; $27 '   Single quote, apostrophe
    .ASCII "\"bla"         ; $22 "   Double quote
    .ASCII "\017bla"       ; Octal number, leading zero, 2 octal digits
    .ASCII "\x1Fbla"       ; Hex.  number, leading x,    2 hex.  digits

    .BYTE "\abla"         ; $07 BEL Bell, alert
    .BYTE "\bbla"         ; $08 BS  Backspace
    .BYTE "\fbla"         ; $0C FF  Form feed
    .BYTE "\nbla"         ; $0A LF  Line feed
    .BYTE "\rbla"         ; $0D CR  Carriage return
    .BYTE "\tbla"         ; $09 HT  Horizontal tabulator
    .BYTE "\vbla"         ; $0B VT  Vertical tabulator
    .BYTE "\\bla"         ; $5C \   Backslash
    .BYTE "\?bla"         ; $3F ?   Question mark
    .BYTE "\'bla"         ; $27 '   Single quote, apostrophe
    .BYTE "\"bla"         ; $22 "   Double quote
    .BYTE "\017bla"       ; Octal number, leading zero, 2 octal digits
    .BYTE "\x1Fbla"       ; Hex.  number, leading x,    2 hex.  digits

@ENDNODE
@NODE XASS_ASSIGNMENTS
  * XASS assignments

    * XASS normal symbols

lb1 .EQU $ff
    t@ =  lb1
_aa = 1
    t@ =  _aa
.aa = 2
    t@ =  .aa
a$a .EQU 22
    t@ =  a$a
a@a .EQU 22
    t@ =  a@a

    * XASS redefinable symbols

lb2 .SET $fe
    t@ =  lb2
lb2 .SET $ff
    t@ =  lb2

l3@ .EQU $ff
    t@ =  l3@
l3@ .EQU $ee
    t@ =  l3@

    * XASS redefinable labels

tt@ .LONG tt@
tt@ .LONG tt@

    * XASS unset symbols

    sym8 .SET $00

    .IFD sym8
      .ASCII "defd"
    .ELSE
      .ASCII "undefd"
    .ENDIF

    .UNSET sym8

    .IFD sym8
      .ASCII "defd"
    .ELSE
      .ASCII "undefd"
    .ENDIF

    * XASS special symbols

    t@ =   *          ; program counter
    t@ =   $          ; program counter

    t@ =   TRUE       ; -1
    t@ =   FALSE      ; 0

    * XASS labels and symbols in structures

   .STRUCT MYSTRUCT,$2000

     ; labels
     STRUCBOT:
     .ALIGN                 ; modulo 2
     NO_SPACE1   .NULL      ; 0 bytes
     BYTE_SPACE1 .BYTE      ; 1 byte
     WORD_SPACE1 .WORD      ; 2 bytes
     TRIP_SPACE1 .TRIP      ; 3 bytes
     LONG_SPACE1 .LONG      ; 4 bytes
     DLONGSPACE1 .RMB  8    ; any size

     ; symbols
     .ALIGN $4000           ; modulo
     .NULL NO_SPACE         ; 0 byte
     .BYTE BYTE_SPACE       ; 1 bytes
     .WORD WORD_SPACE       ; 2 bytes
     .TRIP TRIP_SPACE       ; 3 bytes
     .LONG LONG_SPACE       ; 4 bytes
     .RMB  DLONG_SPACE,8    ; any size

     .ALIGN  256
     STRUCTOP:

   .ENDSTRUCT
    ;

    * XASS linker support

    .EXPORT NO_SPACE,BYTE_SPACE,WORD_SPACE,TRIP_SPACE,LONG_SPACE,DLONG_SPACE



    a@ =  "\abla"         ; $07 BEL Bell, alert
    a@ =  "\bbla"         ; $08 BS  Backspace
    a@ =  "\fbla"         ; $0C FF  Form feed
    a@ =  "\nbla"         ; $0A LF  Line feed
    a@ =  "\rbla"         ; $0D CR  Carriage return
    a@ =  "\tbla"         ; $09 HT  Horizontal tabulator
    a@ =  "\vbla"         ; $0B VT  Vertical tabulator
    a@ =  "\\bla"         ; $5C \   Backslash
    a@ =  "\?bla"         ; $3F ?   Question mark
    a@ =  "\'bla"         ; $27 '   Single quote, apostrophe
    a@ =  "\"bla"         ; $22 "   Double quote
    a@ =  "\017bla"       ; Octal number, leading zero, 2 octal digits
    a@ =  "\x1Fbla"       ; Hex.  number, leading x,    2 hex.  digits

@ENDNODE
@NODE XASS_CONDITIONAL
  * XASS conditional assembling

    * by label/symbol definition check

    sym1 .EQU $00
    .IFD sym1
      .ASCII "defd"
    .ELSE
      .ASCII "undefd"
    .ENDIF
    .IFND sym1
      .ASCII "undefd"
    .ELSE
      .ASCII "defd"
    .ENDIF

    .IFD sym3
      .ASCII "defd"
    .ELSE
      .ASCII "undefd"
    .ENDIF
    .IFND sym3
      .ASCII "undefd"
    .ELSE
      .ASCII "defd"
    .ENDIF

    * XAss64: by checking if term can be calculated

    .IF =,22/0
      .ASCII "works"
    .ELSE
      .ASCII "fails"
    .ENDIF
    .IF !,22/0
      .ASCII "fails"
    .ELSE
      .ASCII "works"
    .ENDIF

    .IF =,22/2
      .ASCII "works"
    .ELSE
      .ASCII "fails"
    .ENDIF
    .IF !,22/2
      .ASCII "fails"
    .ELSE
      .ASCII "works"
    .ENDIF

    * XAss64: by comparison

    .IF =,22,22
      .ASCII "equals"
    .ELSE
      .ASCII "diffs"
    .ENDIF
    .IF !,22,22
      .ASCII "diffs"
    .ELSE
      .ASCII "equals"
    .ENDIF

    .IF =,22,11
      .ASCII "equals"
    .ELSE
      .ASCII "diffs"
    .ENDIF
    .IF !,22,11
      .ASCII "diffs"
    .ELSE
      .ASCII "equals"
    .ENDIF

    .IF <,11,22
      .ASCII "smaller"
    .ELSE
      .ASCII "greater"
    .ENDIF
    .IF >,11,22
      .ASCII "greater"
    .ELSE
      .ASCII "smaller"
    .ENDIF

    .IF <,22,11
      .ASCII "smaller"
    .ELSE
      .ASCII "greater"
    .ENDIF
    .IF >,22,11
      .ASCII "greater"
    .ELSE
      .ASCII "smaller"
    .ENDIF


@ENDNODE
@NODE XASS_MACROS
  * XASS macros

    sym2  .EQU $ff     ; def global symbol
    sym22 .EQU $ff     ; def global symbol
    .MACRO test
      .byte NARG
      sym2 .EQU *      ; def local  symbol
      .WORD sym2       ; use local  symbol
      .WORD sym22      ; use global  symbol
    .ENDMACRO

    test
    test
    test

    .MACRO test2
      .byte NARG
      beq rst
  rst .WORD $12
      .WORD rst
    .ENDMACRO

    test2
    test2
    test2

    .MACRO test3,1
      .byte NARG
      beq rst
      rst .BYTE ?0
    .ENDMACRO

    test3 0
    test3 1
    test3 2


    .MACRO test4,2
      .byte NARG
      beq rst
      rst .BYTE ?0
      .ascii "?1?a"
    .ENDMACRO

    test4 0,hallo
    test4 1,du,1
    test4 2,da,1,1

@ENDNODE
@NODE XASS_CASE
  * XASS case test

    .MACRO testm
      .LONG $11111111
    .ENDMACRO
    .MACRO TESTM
      .LONG $22222222
    .ENDMACRO

    symb .EQU $11
    SYMB .EQU $22

    testm
    TESTM

    .LONG symb
    .LONG SYMB

    .CASE mac,off

    testm
    TESTM

    .LONG symb
    .LONG SYMB

    .CASE sym,off,mac,on

    testm
    TESTM

    .LONG symb
    .LONG SYMB

    .CASE sym,on,mac,on

@ENDNODE
@NODE XASS_DUMMIES
  * XASS ignored dummies

    .PAGE     ; dummy    -> as6502
    .OPT      ; dummy    -> ProfiAss64
    .STM      ; dummy    -> ProfiAss64
    .LST      ; dummy    -> ProfiAss64
    .SST      ; dummy    -> ProfiAss64
    .FIL      ; dummy    -> ProfiAss64
    .SYS      ; dummy    -> ProfiAss64
    .GOT      ; dummy    -> ProfiAss64


@ENDNODE
@NODE XASS_FORMATTING
  * XASS list formatting

    .LIST OFF ; disable
    ; this doesn't get listed
    .LIST ON  ; enable

    .NLST     ; disable  -> as6502
    ; this doesn't get listed
    .LIST     ; enable   -> as6502

    .LIST OFF ; disable
      ; this doesn't get listed
        .LIST OFF ; disable
          ; this doesn't get listed
        .LIST ON  ; enable
      ; this doesn't get listed
    .LIST ON  ; enable

    test
    .MLIST OFF      ; disable
      test
      .MLIST OFF    ; disable
        test
      .MLIST ON     ; enable
      test
    .MLIST ON       ; enable
    test

    .IFD info

      .INFO "Range: $\h - $\h ",*,*+2
      .INFO "Range: \d - \d ",*,*+2
      .INFO "Main char:  \c",'a

    .ENDIF

    .IFD error

      .ERROR "Range: $\h - $\h ",*,*+2
      .ERROR "Range: \d - \d ",*,*+2
      .ERROR "Main char:  \c",'a

    .ENDIF

    .IFD fail

      .FAIL  "You pressed:  \c",'a

    .ENDIF


@ENDNODE
@NODE XASS_INCLUDING
  * XASS including

    .INCLUDE hsrc:demo/_test.inc
    .INCLUDE "hsrc:demo/_test.inc"
    .INCLUDE <hsrc:demo/_test.inc>

    .APPEND hsrc:demo/_test.happ

    ;this does not get assembled any more !

@ENDNODE

