@DATABASE $VER: HypAss 1.0 HyperSource.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
@NODE MAIN "The HyperSource® format idea"
@TOC hass:HypAss.guide/main
  HyperSource© format  @{" General HyperSource© info " link General_HyperSource_info}  *** READ THIS FIRST ***
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED

      @{" Assembler syntax elements  " link "HyperSource_Assembler_Syntax"      }
          @{" Label field     " link "HyperSource_Labelfield"           }
            @{" Label name    " link "HyperSource_Labelname"            }  Name of a label to be defined
            @{" Symbol name   " link "HyperSource_Symbolname"           }  Name of a symbol to be assigned
            @{" Macro name    " link "HyperSource_Macroname"            }  Name of a macro to be defined
          @{" Operation field " link "HyperSource_Operationfield"          }
            @{" Macro         " link "HyperSource_Macro"                }  An already defined macro to invocate
            @{" Mnemonic      " link "HyperSource_Mnemonic"             }  A CPU instruction mnemonic
            @{" Pseudo        " link "HyperSource_Pseudo"               }  An assembler directive
          @{" Operand field   " link "HyperSource_Operandfield"         }
            @{" Macro parms   " link "HyperSource_MacroParameters"      }  Macro pass parameter(s)
            @{" Mnem.operands " link "HyperSource_MnemonicsOperands"    }  Mnemonic's operand(s)
            @{" Pseu.operands " link "HyperSource_PseudosOperands"      }  Pseudo's operand(s)
          @{" Comment field   " link "HyperSource_Commentfield"         }

      @{" Different kinds of comment " link "HyperSource_kinds_of_comment"      }
          @{" * header        " link "HyperSource_Headers"              }  Header containing brief description
          @{" ; comment       " link "HyperSource_Comments"             }  Comments within source code
          @{" /*  doc  */     " link "HyperSource_Documentation"        }  Detailled documentation block

      @{" Legal Amigaguide® commands " link "HyperSource_Amigaguide_Sequences"  }
          @{" @DATABASE       " link "HyperSource_@DATABASE"            }  AmigaGuide database identification
          @{" @REMARK         " link "HyperSource_@REMARK"              }  Comments for the programmer only
          @{" @NODE           " link "HyperSource_@NODE"                }  Specify the beginning of a node
            @{" @PREV         " link "HyperSource_@PREV"                }    Specify previous node for Browse <
            @{" @NEXT         " link "HyperSource_@NEXT"                }    Specify next node for Browse >
            @{" @{LINK}       " link "HyperSource_@{LINK}"              }    Hypertext link to another document
            @{" @{SYSTEM}     " link "HyperSource_@{SYSTEM}"            }    Run AmigaDos executable/batch
          @{" @ENDNODE        " link "HyperSource_@ENDNODE"             }  Specify the end of a node


@ENDNODE
----------------------------------------------------------------------------
@NODE General_HyperSource_info
  General HyperSource© info


        @{" Background           " link "HyperSource_BACKGROUND"       }  What is HyperSource©?

        @{" Filename conventions " link "HyperSource_Filenames"        }  How to name which file?

        @{" Style Guide          " link "HyperSource_STYLE_GUIDE"      }  Authoring HyperSource© programs.

        @{" Future               " link "HyperSource_FUTURE"           }  Echoes from tomorrow `morrow `morrow...







    Not so important:

        @{" HyperSourceHistory " link "HyperSource_HISTORY"          }  How the idea was born...


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_BACKGROUND
  The HyperSource© format idea
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED

  HyperSource© BACKGROUND:

    We are living in the age of HyperText documents which may link directly
    to the author's homepage, but we still use boaring plain source code for
    any kind of programs we write. I wanted to change this fact, and for
    this HyperSource© was born.

    The source code gets formatted as if it was a HyperText database, and
    it gets squeezed through the assembler (HypAss) like that. This one adds
    some more HyperText features while it creates the listing file. The
    listing is somehow a GUI for the source code and the assembler again,
    and may assemble itself from within itself. The whole programming is
    node oriented, and I plan to be able to include nodes selectively out of
    another project's HyperSource database. The current version of HypAss
    just supports AmigaGuide® formatted source code, but may even create
    databases of old plain source code. Future versions of HypAss will also
    support other HyperText systems through plugins, this here is just the
    beginning. It is not finished yet, but I started from the beginning
    looking forward at a future HOOPSY assembler system.
    (Hypersource Object Oriented Programming SYstem), the complete sections
    of the assembler are kept modular in polomorphic way, to end in a class
    objects tree defining an assembler. The root class is for this HypAss.
    Classes with *** exist, the others are not realized yet.

                                 |
                                ***
                               HypAss
                                 |
            +----------+---------+---------+---------+
            |          |         |         |         |
          make      syntax      CPU      object   process
           ...        ***       ***       ***        |
                       |                   |         |
               +-------+-------+       +---+---+     +---+---+
               |       |       |       |       |     |   |   |
             pseudo   hyper   math   load     save  EMU ICE PROM
              ***      |      ...      |      ***
               |      ...              |       |
     +----+----+----+          +---+---+       +---+---+
     |    |    |    |          |   |   |       |   |   |
   XASS MOTF  MPIC CAZ        bin hex link    bin hex link
    ***  ***  ***  ***                        *** ***
     |    |    |    |
    ...  ...  ...  ...


    Both, HypAss and HypMake contain the same shell argument processor OOP
    object, being able to analyze or synthesize shell arguments, this object
    will end in the make class. It was designed to run HypAss iterative
    through a tree just by calling it one time. These features are in experi-
    mental phase, and are disabled yet. (It lookes nice when HypMake clones
    itself multiple times creating arrays of public screens, but they made
    the mistake not to organise public screens in a tree structure within a
    filesystem.)


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Filenames
  Filenames and Tree conventions in the HyperSource directories:

    For future enhancements it is *VERY* important, that you follow some
    filename and directory structure conventions. The directories which are
    reserved for this conventions are both, 'HSRC:' and 'HINC:' The root
    directories of both assigns are reserved for directories ONLY and must
    not contain any file, except drawer icons, if any! Put all your proggies
    in new subdirectories!

  CONTENTS:

    HSRC:

      Contains all parts of your projects, except hardware includes. All
      makefiles are stored here, and for this there's no other files without
      file extensions allowed in hsrc: except these make files. IMPORTANT!
      Make files will be collected recursively by a future META tool one
      day, so keep your HyperSource directory tree clean! Keep track of the
      name conventions, so you will avoid to loose data, because I plan a
      garbage collector function which will recusively clean the tree of
      unused listings, symtables and objects, and then re-assemble the tree
      again to be able to have global upgrading abilities.

      The files YOU create in HSRC: (example: project CRYPT, routine INIT)

         hsrc:crypt/init       ; the makefile, created by hand or by HypMake
         hsrc:crypt/init.hsrc  ; the source file of this routine
         hsrc:crypt/main.hsrc  ; The home page of your project crypt!!!
        [hsrc:crypt/init.src]  ; Alternative if you don't like HyperSource?
        [hsrc:crypt/main.src]  ; Alternative if you don't like HyperSource?

      Note that there must be at least one (and not more) 'MAIN' document in
      each project subdirectory, to be compatible to future utilities. The
      file extensions used above are the onliest ones which are protected
      from deletion in future. Keep track of this!

      The files HypAss creates un HSRC:

                    *.hlst        ; HyperSource listing file
                    *.lst         ; normal listing file

                    *.1.hlst      ; HyperSource listing file of pass 1
                    *.1.lst       ; normal listing file of pass 1
                                  ; any other number reserved for future

                    Additionally any object format specific extensions,
                    read more about in the @{" OBJECT libraries " link "hass:doc/-OBJ.guide/main"} docs.


    HINC:

      Contains none-binary-creating hardware definition include files, pure
      assignments only. This will be the home of any kind of CPU or micro-
      controller includes which will be pre-processed to fast modules some
      day. Use this as you are used to handle includes, but no macro defi-
      nitions which result in code are permitted here! Keep the scope of CPU
      family sorting intact, so it will stay compatible to future utilities.
      All files here should have the extension '.hinc' and should be managed
      as HyperSource© databases which may be included as trees.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_STYLE_GUIDE
  Short HyperSource© STYLE GUIDE:

    I would like to say a few words how programs should be styled to have
    most of future features availlable. As said before, is the current
    framework of a HyperSource file an AmigaGuide® database. But just a few
    @{" Legal Amigaguide® commands " link "HyperSource_Amigaguide_Sequences"  } are permitted, keep track of this. I could
    imagine that everyone today knows how AmigaGuide databases are written,
    so this should be no problem to manage. Another very important, but in
    the moment unfinished feature are the @{" Different kinds of comment " link "HyperSource_kinds_of_comment"}.
    Have a look at the documentation and you will not have to rewrite any-
    thing in future.

    Now what is very important: You should try to encapsulate any routine
    blocks in your program by nodes, having exactly the same name as the
    main routine entry point of this section. If you write gereral purpose
    macro files you should try to encapsulate them also by their name's node.
    This will be very important when having Hypertext include links, to be
    able to selectively include sections of other programs. Whenever you
    create buttons linking to another file, use the full path including
    either the assign hsrc: or hinc: to avoid conflicts in future.

    When you use HyperSource includes, you should encapsulate the calls of
    them by @{" .LIST OFF " link hass:doc/-syn.guide/HYPASS_PSEUDO_LIST} / @{" .LIST ON " link hass:doc/-syn.guide/HYPASS_PSEUDO_LIST} pseudos, because AmigaGuide can't
    handle nested nodes yet, and the adaption of this by HypAss is not
    finished yet! Multiview can read damaged databases, but other versions
    (and maybe also future versions) of AmigaGuide can't! If you are used to
    double the escape backslash (\\), let it be in HyperSource, HypAss trans-
    lates it context sensitive.

    Here's just a little example how a framework may look like, have a look
    at the demo files, they show more. Note that some demo files are not
    properly programmed, for testing purposes. (E.g. using 10 different syn-
    tax settings in one source is no good idea...) Most of them were just
    test cases.


  EXAMPLE SOURCE:

                imagine the following arrow points to line 0, column 0:
      cut here->\@DATABASE
                \@NODE main
                ******************************
                * here should be your header *
                ******************************

                   .syn motf ; define the syntax in every file!

                   \@{" RESET " link RESET }    ; here should be a button
                   \@{" ENDOF " link ENDOF }    ;  for each program part

                   .list off
                   .include 6805/hc05c4   ; if you include simething
                   .list on               ; then do it here.

                \@ENDNODE
                ; this you can't read later.
                \@NODE RESET
                * RESET   make a small header here and start it with the
                *         routine name.

                RESET  lda #$00 ; the node must have the same name as the
                       pha      ; main routine start entry point inside
                       pla      ; this node. No other args are allowed!
                       rts


                \@ENDNODE
                \@NODE ENDOF
                * ENDOF   make a small header here and start it with the
                *         routine name.

                ENDOF  lda #$00 ; the node must have the same name as the
                       pha      ; main routine start entry point inside
                       pla      ; this node. No other args are allowed!
                       rts


                \@ENDNODE

                <- cut here

        to be continued...

@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Assembler_Syntax
  HyperSource© Assembler Syntax

    Each HyperSource© line can be divided into four parts:

        @{" Label field     " link "HyperSource_Labelfield"    }  e.g. RESET:              TABLE
        @{" Operation field " link "HyperSource_Operationfield"}  e.g. LDA                 .BYTE
        @{" Operand field   " link "HyperSource_Operandfield"  }  e.g. #$FF                $FF
        @{" Comment field   " link "HyperSource_Commentfield"  }  e.g. ;this is silly      ;this is silly too

    These parts may appear in the following order:

        [@{"Label" link "HyperSource_Labelfield"}[:]][ @{"Operation" link "HyperSource_Operationfield"}[ @{"Operand" link "HyperSource_Operandfield"}[,@{"Operand" link "HyperSource_Operandfield"}]]][;@{"Comment" link "HyperSource_Commentfield"}]

      The brackets [] do not appear in source, they should just show what is
      optional and in which relation to each other. Required delimiters:

      Between @{"Label    " link "HyperSource_Labelfield"    } and @{"Operation" link "HyperSource_Operationfield" } there must be at least one white space.
      Between @{"Operation" link "HyperSource_Operationfield"} and @{"Operand  " link "HyperSource_Operandfield"} there must be at least one white space.
      Between @{"Operand  " link "HyperSource_Operandfield"  } and @{"Operand  " link "HyperSource_Operandfield"} there must be a comma.

      A white space can be space ($20) or a horizontal tabulator HT ($09).
      Lines may be either terminated by an Amiga typical linefeed LF ($0A)
      or by PC-typical carriage return line feed CRLF ($0D,$0A).  If the
      @{" MAC/S shell argument " link hass:doc/-args.guide/SHELL_ARG_MAC} is set then lines may also be terminated by a
      single carriage return CR ($0D), as it is used with C64 / Macintosh®.

      Note that some syntax sets (e.g. MOTF) use white space to introduce
      comments in the operand field. Avoid white space there, or some of
      your operands may be ignored as comments! If in these syntax sets the
      mnemonic has surely no operand (e.g. NOP), then the complete operand
      field may be used for comments (introduced by 1 white space).


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Labelfield
  The label field in HyperSource©

    Depending on the conext, the labelfield may or must contain a name for
    the element we want to define. HypAss knows three kinds of definitions
    which use the label field:

      Label  definitions expect a @{" Labelname  " link "HyperSource_Labelname" }.
      Symbol assignments expect a @{" Symbolname " link "HyperSource_Symbolname"}.
      Macro  definitions expect a @{" Macroname  " link "HyperSource_Macroname" }.

    All these names have to follow a global convention for definition names:

      Currently the maximum size is 32 characters. The first character must
      be non numerical and may be one of the following characters:

        abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.

      From the second to the last character you may *additionally* use
      numerical characters. So you may use these characters there:

        abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_.0123456789$@


    NOTE: / MERKE: / NOTEZ BIEN:

      Some assemblers are proud of permitting german "umlauts" in definition
      names (labels/symbols/macros). HypAss does *NOT* support this, and I'm
      not sure if it ever will. If you speak german, read more about this in
      @{" HypAss10.liessmi " link hass:doc/HypAss10.liessmi/main}. If you already own source code which contains one
      or more of the following strange 7 signs in definition names

                        ä, Ä, ö, Ö, ü, Ü, ß,

      then you may use a CVT text filter supplied with this package in the
      catalogs/empty directory for stripping off this german sickness out of
      label/symbol/macro names. The filter is called @{" StripUmlauts.cvt " link hass:catalogs/empty/StripUmlauts.cvt/main}.
      Sorry, but I have never seen for example french special characters in
      any definitions, although I have seen a lot of french source code! If
      you have similar problems in your country, please write a text filter
      to be included in the next release.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Labelname
  Label names in the label field

    Each @{" Mnemonic " link "HyperSource_Mnemonic"} or @{" Macro " link "HyperSource_Macro"} and most @{" Pseudos " link "HyperSource_Pseudo"} accept a label name to
    their left, which gets assigned to the actual value of the program
    counter *before* the operation to the right gets assembled. Label names
    may optionally end in a colon (:). The colon gets stripped off before
    the label gets defined and must not be appended when you refer to the
    label later. Label definitions may appear in lines for themselves.
    Label names needn't start in the first column of a line, but if you want
    to force something being a label it should. This allows for example to
    define a label having a mnemonic's name. HypAss treats labelnames by
    default case sensitive. This may be changed using the @{" .CASE pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_CASE}
    or the @{" CASE/K shell argument " link hass:doc/-args.guide/SHELL_ARG_CASE}. Some pseudos forbid labels left to them!
    (You will get an error.) In most syntax sets you may define redefinable
    labels if their name ends up in an '@' (e.g. help@). Note that these
    labels get defined both, in pass1 and pass2, and will not be checked for
    phasing errors. Because the label table gets created at the end of pass2,
    the most recent value of a redefinable label will be displayed there.

    NOTE: Some CPUs count the PC word aligned (e.g. PICs), and do not accept
          label definitions between this alignment boundary. You will get an
          alignment error if you try to define labels 'between' addresses.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Symbolname
  Symbol names in the label field

    During any kind of @{" assignments " link hass:doc/-math.guide/ASSIGNMENT_DIRECTIVES}, the label field must contain the name
    of the symbol to be assigned. Note that assignments allow a slightly
    different syntax. HypAss knows two groups symbols for assignments:
    Normal symbols and redefinable symbols (variables). Normal symbols get
    usually assigned to constants, and can't be altered after this any more,
    whereas redefinable symbols may be altered whenever it is required. Note
    that redefinable symbols get defined both, in pass1 and pass2, and will
    not be checked for phasing errors. Because the symbol table gets created
    at the end of pass2, the most recent value of a redefinable symbol will
    be displayed there. HypAss treats symbol names by default case sensitive.
    This may be changed by the @{" .CASE pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_CASE} or the @{" CASE/K shell arg " link hass:doc/-args.guide/SHELL_ARG_CASE}.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Macroname
  Macro names in the label field

    In the header line of a macro definition the label field may contain the
    macro name. Read more about this in the @{" .MACRO pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_MACRO} description.
    HypAss treats macro names by default case sensitive. This may be changed
    using the @{" .CASE pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_CASE} or the @{" CASE/K shell arg " link hass:doc/-args.guide/SHELL_ARG_CASE}.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Operationfield
  The operation field in HyperSource©

    Each line may contain *exactly* one of the following operations:

      @{" Macro    " link "HyperSource_Macro"   }  An already defined macro to invocate
      @{" Mnemonic " link "HyperSource_Mnemonic"}  A CPU instruction mnemonic
      @{" Pseudo   " link "HyperSource_Pseudo"  }  An assembler directive

    The names of these operations may collide, and override each others then.
    They are listed above by their detection priority, where macros have the
    highest priority. This means, that you may substitute any operations by
    macros. Operations must never start in the first column, or they will be
    interpreted as a label name.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Macro
  A macro in the operation field

    The operation field may contain an *already* defined macro, so it will
    be invocated. This means, that the textual macro preprocessor of HypAss
    will insert the contents of the previous defined macro body at this line,
    using the @{" operand field " link "HyperSource_Operandfield"  } to define the macro pass parameters. HypAss
    treats macro names by default case sensitive. This may be changed using
    the @{" .CASE pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_CASE} or the @{" CASE/K shell argument " link hass:doc/-args.guide/SHELL_ARG_CASE}.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Mnemonic
  A mnemonic in the operation field

    Mnemonics are keywords for processor instructions or groups of them.
    They always belong to a @{" CPU library " link "hass:doc/-CPU.guide/main"} which has been specified either
    by the @{" .CPU pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_CPU} or the @{" CPU/K shell argument " link hass:doc/-args.guide/SHELL_ARG_CPU}. HypAss treats
    mnemonics always case insensitive. By default no mnemonics are known.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Pseudo
  A pseudo in the operation field

    Pseudos are keywords for assembler instructions, and are normally called
    pseudo mmemonics, directives or pseudo instructions, because they mostly
    get used as if they were processor instructions. But they do not have
    anything to do with the processor, they just share a similar syntax.
    They always belong to a @{" Syntax library " link "hass:doc/-SYN.guide/main"} which has been specified
    either by the @{" .SYN pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_SYN} or the @{" SYN/K shell argument " link hass:doc/-args.guide/SHELL_ARG_SYN}. HypAss
    treats pseudos always case insensitive. By default the resident syntax
    library 'XASS' is enabled.

  NOTE:

    I have often used 'pseudo opcodes' within this documents, what is wrong,
    because an opcode is the resulting binary a mnemonic produces, depending
    on the actual required addressing mode. This documents have been written
    spread over halve a year, with steady growing vocabulary, and I will
    change this silly errors when I'm really boared. Maybe never!


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Operandfield
  The operand field in HyperSource©

    Most operations require operands, for this we have the operand field :)
    HypAss supports up to 32 operands each operation, each one up to 255
    characters long. This should usually be enough, if not, then tell me!
    These operands get treaten in very different way, depending on the
    operation they belong to, so I will describe them separately:

      @{" Macro pass parameters " link HyperSource_MacroParameters  }
      @{" Mnemonic's operands   " link HyperSource_MnemonicsOperands}
      @{" Pseudo's operands     " link HyperSource_PseudosOperands  }



@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_MacroParameters
  Macro pass parameters in the operand field

    @{" Macro " link "HyperSource_Macro"}'s operands:

      Macros may receive currently up to 10 pass parameters, applied to them
      in the operand field. These parameters get passed to the textual macro
      preprocessor of HypAss. This one inserts one of the operands during
      macro invocation, whenever the symbol for a macro parameter appears
      within the macro's body. There's no restriction about the contents of
      a macro pass parameter. Whenever you want to pass a reserved syntax
      element, such as comma, semicolon or white space you may embed it in
      double quotes ("). Other ways are not supported yet. This will change
      one day.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_MnemonicsOperands
  Mnemonic's operands in the operand field

    @{" Mnemonic " link "HyperSource_Mnemonic"}'s operands:

      This is the hot spot of an assembler. The operand(s) of a mnemonic
      control in many ways the created opcode. The engine which does this
      job is the code generator. HypAss has a modular code generator concept,
      where parts of this generator reside within the main program, and CPU
      specific plugins get inserted by the @{" CPU libraries " link "hass:doc/-CPU.guide/main"}. This generator
      was designed to do addressing mode decision for you, so you should
      never need to force an addressing mode, unless later implemented CPUs
      require this.


    ADDRESSING MODE QUALIFIERS:

      The operand(s) get parsed for syntax elements which may represent
      addressing mode qualifiers or register names. This gets always parsed
      case insensitive. These qualifiers get stripped off, and the resulting
      rest gets evaluated as an @{" Expression " link hass:doc/-math.guide/main} (If any).


    ADDRESSING MODE DECISION:

      After the value of an operand is known (mostly in pass2), HypAss will
      ask the CPU lib for possible addressing modes for the actual mnemonic
      using this value. The CPU lib will climb up the table of availlable
      code sizes, and if the value is out of the availlable maximum range,
      it will fail. In opposite to many other assemblers does HypAss NEVER
      cut operands to make them fit. If a mnemonic does not support multiple
      addressing modes, then just the operand's value will be checked if it
      is within the valid range. If an addressing mode does not exist in a
      'small code model', then HypAss will automatically switch to the next
      higher availlable codesize, until it finds an existing one. The value
      range check depends on the kind of operand and gets checked both for
      positive and negative maximum:

                           min:               max:         16-bit example:

        Adresses:    zero               unsigned positive    $0000-$FFFF
        Offsets:     signed negative    signed positive     -$7FFF-$7FFF
        Immediate:   signed negative    unsigned positive   -$7FFF-$FFFF


      Branches are special kind of offset, they include the opcode length
      and the program counter before they calculate their validity. (What do
      I tell you here?) Note that full 32-bit operands do not get checked!
      (currently unused)


    FORWARD REFERENCES:

      HypAss has in the moment a very prelimary way to allow forward refs
      within mnemonic's operands: Any forward reference gets detected during
      pass 1 and the addressing mode gets forced to the largest availlable
      one, both in path 1 and path 2. This means that you should not forward
      reference if you want to access the zero page/direct page addressing
      modes. This will change in future. Some CPU libraries are not forward
      reference proof yet!


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_PseudosOperands
  Pseudo's operands in the operand field

    @{" Pseudo " link "HyperSource_Pseudo"}'s operands:

      The operand(s) of a pseudo differ in many points from each others,
      depending on the pseudo they get applied to. Nearly any pseudo accepts
      @{" Expressions " link hass:doc/-math.guide/main} within its operand field, some on them even accept
      strings, and some accept both. Read more about this in the specific
      description of each pseudo in the @{" Syntax library " link hass:doc/-syn.guide/main} documentation.


    FORWARD REFERENCES:

      Any binary creating (memory allocating) pseudos, which do not have a
      size argument (not .BLOCK) allow forward references, because their
      size is known by the number of operands. But if you forward reference
      within the operands of conditionals or variable-size memory allocation
      pseudos, you will surely create phasing errors. This is not dangerous,
      you just get an error then. This may be allowed in future.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Commentfield
  The comment field in HyperSource©

    Any line, it does not matter what it contains (except AmigaGuide® lines)
    allows a comment field, introduced by a semicolon (;). The semicolon may
    be attached at any place without the need of a leading space. This is
    one of 3 possible @{" kinds of comment " link "HyperSource_kinds_of_comment"} allowed by HypAss, and it is the
    onliest one which may be mixed up with source code.

    Some @{" Syntax sets " link hass:doc/-syn.guide/HYPASS_SYNTAX_INFO} (e.g. MOTF) allow white space to introduce comments
    in the operand field, but forbid white space within operands for this.
    If in these syntax sets a mnemonic has surely no operand, as NOP, then
    the complete operand field may be used for comments (introduced by one
    white space).

@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_kinds_of_comment
  Different kinds of HyperSource© Comment

    Anybody who has ever programmed for more than halve a year knows what a
    *very* important thing it is to comment source files. Even if you never
    want to give away your sources you will need comments to find yourself
    through the jungle of your own work! You will forget very fast!

    For compatiblity does HypAss support most common kinds of command. What
    you are used to from another assembler should also work with HypAss. But
    HypAss offers more. In opposite to other assemblers does HypAss classify
    comments, to handle them in different ways when the listing is created.

          @{" * header    " link "HyperSource_Headers"              }  Header containing brief description
          @{" ; comment   " link "HyperSource_Comments"             }  Comments within source code
          @{" /*  doc  */ " link "HyperSource_Documentation"        }  Detailled documentation block

    This feature will be configurable in future (context sensitive), to be
    able to select the attributes (color...) which will be inserted in the
    listing by HypAss for any kind of comment (and for error messages).

    A preview how this preferences program may look like can be accessed
    @{" here " system "sys:utilities/multiview screen hass:doc/-hypprefs.gui"}.  <- stay away of this!


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Headers
  HyperSource© headers

    Headers are always full line comments, and are standard in any Motorola®
    syntax flavours. They are introduced by an asterisk (*), which must be
    the first none white space character of the line. The rest of the line
    past this asterisk gets ignored, and may contain any kind of ASCII char.

  EXAMPLES:

    * This is a header which should give a brief
    * description of the following routine.

    LDA #$FF
    STA nirvana
    RTS


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Comments
  HyperSource© comments

    A comment, introduced by a semicolon (;), is the most basic type, known
    by nearly any assembler, and may appear anywhere in a source file. It is
    generally not necessary to introduce the semicolon by a white space, but
    it should be done for better readability. The rest of the line past this
    semicolon gets ignored, and may contain any kind of ASCII characters.
    This kind of comment may also be used to introduce full comment lines.

  EXAMPLES:

    ; This is a full comment line
    LDA #$FF
    STA nirvana ; here for example
    RTS; or here
    ; End of examples


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Documentation
  HyperSource© documentation

    To be able to insert large documentation areas in source files without
    the need to introduce each line by a semicolon (;) or an asterisk (*),
    we have a *modified* version of high-level-language comment style. Each
    documentation block gets introduced by '/*' and ends in '*/', what does
    not differ from HLL style. But!!! within HyperSource© these two syntax-
    elements must be the first non white space characters in the line.
    Between these lines you may put anything you want, even your grandma.
    Try to use this feature as shown in the example, and try to avoid the
    '/*' and '*/' within your documentation, because this feature may change
    to usual C-style usage one day. Be prepared, so there will be no need to
    rework all your sources in future.

  EXAMPLES:

    /*
    This is a large bla bla bla
    This is a large bla bla bla
    This is a large bla bla bla
    This is a large bla bla bla
    */


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_Amigaguide_Sequences
  Legal Amigaguide sequences within HyperSource© code.

    A HyperSource© source file may contain a reduced set of 8 AmigaGuide®
    command sequences. They must always appear in lines for themselves.
    They must not be mixed up with source code or comments in one line.
    Any command sequences which do not result in buttons must always start
    in the first column of a line, whereas action button creating commands
    should never begin in the first column. HypAss checks which AmigaGuide
    command sequences you try to pass to it. You will get an error whenever
    you use commands which are not permitted within HyperSource©, but only
    within the pass that creates a listing. In general, these commands do
    not affect assembly in any way. It starts to be an error, when the
    listing file gets created.

    The reduction of the Amigaguide commands was choosen for many reasons:

      -The choosen commands exist in any known Amigaguide version, so both,
       the source and the listing file may be displayed by any Amigaguide
       viewer. To be the most flexible, the source should not contain any
       attributes, because they don't work with all Amigaguide versions.
      -Later releases of HypAss will have a Preferences program, where you
       may globally choose the attributes for any source code element, so
       they will be added during assembly. This is the most flexible system,
       because HypAss will do this context sensitive.
      -The ARexx port of the actual AmigaGuide viewer is reserved for HypAss,
       waiting for the day when AmigaGuide/Multiview may be closed in remote
       again ;-)

  NOTE:

    This part of the document does *not* describe how to author AmigaGuide®
    documents, but it should show how to write HyperSource® source files!


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@DATABASE
  '\@DATABASE' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@DATABASE [<name>]@{UB}    V34+


  FUNCTION:

    Indicates that this is an AmigaGuide® compatible database. Must appear
    in each HyperSource© file in the very first line and the very first
    column. You may specify a name, but it will not appear in the listing
    file. This command may only be used within the global section of the
    database (line1,column1).


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@REMARK
  '\@REMARK' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@REMARK <remark>@{UB}  V34+


  FUNCTION:

    This could be used to place remarks in the database, which get copied
    to the listing file by HypAss, but will neither be displayed by Amiga-
    Guide® nor by Multiview. May be useful to place comments, which just
    are interesting for the editor (person) of a database. This command must
    start in the first column of a line.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@NODE
  '\@NODE' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@NODE <nodename> [<title>]@{UB}   V34+


  FUNCTION:

    Specify the beginning of a node. You may also specify the title to be
    displayed, but it will not appear in the listing file, because the
    space is needed to display the navigation information. Use the headers
    (* bla) to display titles within nodes. This command must start in the
    first column of a line.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@PREV
  '\@PREV' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@PREV <nodename>@{UB}  V34+


  FUNCTION:

    The node to display if you select "Browse <", and if the node is not
    physically preceding the actual one.  This *must* be a database
    internal node! You may use this command to define the beginning of
    a browsable block if the nodename is exactly the name of the node we
    are in. This will result in a ghosted "Browse <" button here. This
    command must start in the first column of a line, and may only be used
    within nodes.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@NEXT
  '\@NEXT' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@NEXT <nodename>@{UB}  V34+


  FUNCTION:

    The node to display if you select "Browse >", and if the node is not
    physically located next to the actual one. This *must* be a database
    internal node! You may use this command to define the end of a
    browsable block if the nodename is exactly the name of the node we
    are in. This will result in a ghosted "Browse >" button here. This
    command must start in the first column of a line, and may only be used
    within nodes.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@{LINK}
  '\@{"" LINK ""}' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@{"button text" LINK "<path/nodename>"}@{UB}  V34+


  FUNCTION:

    A hypertext link to the specified node. Use this to make the table
    of contents for all nodes within the actual database. For internal
    nodes you needn't specify the path, of course. But if you add links
    to an external node they *must* have full path, including device or
    assign name within HyperSource. We don't start from shell any more one
    day. Keep track of this fact. We will not have a clear current dir any
    more. If you run OSV39+ you may link to any kind of data which is
    supported by an *installed* datatype. Nodename should be 'main' then.
    This command must *NOT* start in the first column of a line, and may
    *only* be used within the node 'main'.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@{SYSTEM}
  '\@{"" SYSTEM ""}' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@{"button text" SYSTEM "<path/amigados-command>"}@{UB}  V34+


  FUNCTION:

    Execute an amigados executable, or a scriptfile having the script flag
    set. You must specify the full path to the executable or script, same
    reason as above. Use this function also to launch ARexx scripts via
    the 'RX' command, so ARexx crashes stay external to AmigaGuide/Multi-
    view. You need of course a running ARexx environment to do this, so
    this is V36+. Within HyperSource©, you are not allowed to remote the
    actual AmigaGuide/Multiview you're currently in! This command must
    *NOT* start in the first column of a line, and may *only* be used
    within the node 'main'.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_@ENDNODE
  '\@ENDNODE' AmigaGuide® command sequence

  SYNOPSIS:

    @{B}\@ENDNODE [<nodename>]@{UB}   V34+


  FUNCTION:

    Specify the end of a node. You may also specify which node ends here,
    but this information may only be useful for better structuring of the
    source file, and will neither be used by HypAss nor by AmigaGuide®.
    This command must start in the first column of a line.


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_FUTURE
  HyperSource© future

    I have not documented all features of HypAss yet, so I have no time
    in the moment to write down all ideas I have to extend the interactive
    source code principle. You may read about lots of ideas in many corners
    of this database, and there may still be old information around, which
    is maybe already realized or cancelled for some reasons.
    Await the next release and be happy with the toys you get now.

    If you have future ideas, or if you want to fill a corner in the classes
    tree, then feel free to contact me. (An assembler is a super method of
    a syntax set...) Amiga is a professional system, and we have many things,
    that no other system has, and I want to do my part to help increase the
    difference to 'customer computers', which you can find under many
    christmas trees. (And later in the garbage can)

    Again: This project would not have been possible without the genious
    work of Wouter van Oortmerssen:

        AmigaE - The answer to a very old question.

            Thanks, Wouter!


@ENDNODE
----------------------------------------------------------------------------
@NODE HyperSource_HISTORY
  The HyperSource© format idea
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED

  HISTORY:

  This is one of the basic reasons why I wrote HypAss:

    Have you ever written very large assembler programs, made out of 50 or
    more include files, being able to work modular by different make-files,
    each one creating another kernal for another hardware.....

    This was what I was doing when I decided to start this project:
    I was writing a 32KB Multitasking Kernal for a self-made 6502 single-
    board computer (4MHz => 500ns++ instruction cycle) with the following
    realtime features (WITH NO HARDWARE HELP except current drivers):

    -32 channel simultane telephone controller + pulse dial decoder,
      8 languages simultaneously availlable via dialling (CMOS switches).
    -Simultaneous asynchronous 250 KBaud DMX 512 transmitter,
     64 channels 8 bit, 50 frames per second refresh. (no USART)
    -Local synchronous 250 KBaud transmitter, including clock and
     data valid signals, async to DMX 512.
    -Universal realtime infrared transmitter, configurable for any
     code format used in customer world. (ring buffered)
    -Realtime basic interpreter (4000 tokens/second) with controlling
     commands for all named hardware elements. Can run multiple programs
     and skip between different program parts via external realtime control.
     Program may contain infrared transmit sequences and light control.
    -Realtime infrared receiver, configurable for any known customer
     code format, controlling the basic interpreter like a CD-Player
     (play,stop,pause,skip fwrd,skip back,fast forward, rewind, program...)
    -Realtime infrared cross conversion processor, allowing to convert
     any code format of any manufacturer to be converted to any other one
     in realtime, while all the functions named before still keep running!
    -64 channel light effect processor, 50 frames per second, 8 bit bright-
     ness data each channel, 32 independend realtime blending algorithms
     blending from any value to any value in precise selectable time from
     1/50th second to many hours. Asynchronous flashing algorithms, with
     independent envelope shapes each channel, definable light curve...
    -Up to 19200 Baud RS232 transceiver (this one breaks the basic inter-
     preter), totally configurable like a usual serial device.(no USART)
    -And last but not least: A safe keyboard matrix scanner, doing the
     same realtime control to the basic interpreter as the ir-receiver.

    Now that are the current features of my universal multimedia controller,
    and you will not beleive it: THERE'S NO PERIPHERAL CHIP USED AT ALL,
    NO SERIAL, NO TIMER! AND NOTHING ELSE. I just used 74HCXX latches and
    input drivers. But how did I get a good timing?

    The whole kernal consists of vectorized routines without any loop
    inside, each element optimized for branch independend execution time,
    emulating 1600 independent 9600Hz timers (or subsequents) at all.
    The timing is just made by the overall looptime of all routines !!!
    My "by hand optimization" was quite successfull, I just have one page
    crossing in the complete kernal. But the output signals just have a
    precision of +-1% and I think this must be 0, while the 6502 is a
    synchronous processor.

    Now the kernal consists of 9566 lines of source code in 47, up to
    3 levels deep nested includes, 232113 bytes at all, and I don't want
    to count the cycles of this monster again. Here's the HypAss status:
                                               (A4000/EC030/25 16MB FAST)
    Source:   hsrc:old/SIM1.hsrc
      Code:          8000 -> 10000    =     32768 bytes
      Source:      232118    Syntax:    XASS    Includes:    45
      Lines:         9610    Math:       HYP    Labels:     705
      Passes:           2    Cpu:       6502    Symbols:    508
      Memory:      666232    Object:     CBM    Macros:      20
      Time:       00:20.6    Dummies:      0    FwrdRefs:   414
    No errors.

    It would be the more fast way to write an assembler doing this job.
    But how should an assembler know where my routine fragment starts and
    where it ends? So I decided to make a formatting that will encapsulate
    every routine by nodes. Nodes? @NODE/@ENDNODE? AmigaGuide®!

    ...

    The current version of Hypass does'n support the runtime optimization
    features I wrote it for yet, but everything else. ??!!??


@ENDNODE
----------------------------------------------------------------------------
