@DATABASE $VER: HypAss 1.0 Actions.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
@NODE MAIN "HypAss shell arguments  '*'= Not in HypMake  '#'= Not in makefiles"
@TOC hass:HypAss.guide/main
  HypAss  shell arguments  @{" General SHELLARGS info " link General_SHELL_ARGS_info}  *** READ THIS FIRST ***
  HypMake makefile creator @{" General  HypMake  info " link General_HYPMAKE_info   }  *** READ THIS FIRST ***

          Source file:
           @{" SRCFILE/A " link SHELL_ARG_SRCFILE}  Specify the source file

          File creation:
            @{"  LST1/S  " link SHELL_ARG_LST1   }  Create pass1 listing file
            @{"  LST/S   " link SHELL_ARG_LST    }  Create pass2 listing file
            @{"  SYM/S   " link SHELL_ARG_SYM    }  Create label+symbol table
            @{"  INC/S   " link SHELL_ARG_INC    }  Create an include table
            @{"  NOBJ/S  " link SHELL_ARG_NOBJ   }  Don't create an object file
            @{"  TEST/S  " link SHELL_ARG_TEST   }  # Disable any file creation

          Library control:
            @{"  SYN/K   " link SHELL_ARG_SYN    }  Select syntax library
            @{"  CPU/K   " link SHELL_ARG_CPU    }  Select processor library
            @{"  OBJ/K   " link SHELL_ARG_OBJ    }  Select object library

          Listing control:
            @{"  HSRC/S  " link SHELL_ARG_HSRC   }  Force HyperSource© mode
            @{"  INL/S   " link SHELL_ARG_INL    }  Ignore nolist pseudos
            @{"  LLC/S   " link SHELL_ARG_LLC    }  List list control pseudos
            @{"  FWL/S   " link SHELL_ARG_FWL    }  List forward references
            @{"  DL/S    " link SHELL_ARG_DL     }  List dummy directives
            @{"  LOC/S   " link SHELL_ARG_LOC    }  # List local labels+symbols
            @{" V=VIEW/S " link SHELL_ARG_VIEW   }  # View created listing file
           *@{"  VE/S    " link SHELL_ARG_VE     }  # View listing on error

          Assembler control:
            @{"  MAC/S   " link SHELL_ARG_MAC    }  Allow C64/MAC line termination
            @{"  LM/S    " link SHELL_ARG_LM     }  Enable low memory mode
            @{"  CASE/K  " link SHELL_ARG_CASE   }  Choose case sensitivity
            @{"  NAX/S   " link SHELL_ARG_NAX    }  No auto include extensions
            @{"  DEF/K   " link SHELL_ARG_DEF    }  Define symbols

          Script control:
           *@{"  SKP/S   " link SHELL_ARG_SKP    }  # Fall through HypAss
           *@{"  BRK/S   " link SHELL_ARG_BRK    }  # Break script after assembly
           *@{" QUIET/S  " link SHELL_ARG_QUIET  } (#) Don't prompt to console

          HypMake only:
            @{"  ICO/S   " link SHELL_ARG_ICO    }  Open in iconified state
            @{"  SCR/S   " link SHELL_ARG_SCR    }  Open on an own PublicScreen
            @{"  PUB/K   " link SHELL_ARG_PUB    }  Name of the PublicScreen

     RETURN CODES:             CONDITION:

       OK       =  0             All went fine
       WARN     =  5             Warnings appeared   (currently not needed)
       ERROR    = 10             Errors appeared
       FAIL     = 20             Fatal errors or CtrlC appeared

@ENDNODE
----------------------------------------------------------------------------
@NODE General_SHELL_ARGS_info
  General information about HypAss Shell arguments:

    This section is written for people who hate GUIs for assemblers and who
    prefer to have a shell executable. The others should read the @{" HypMake " link General_HYPMAKE_info}
    description, because HypMake does the same as written here, but allows
    easier intuition driven handling.

    HypAss supports lots of shell arguments, but they are not meant to be
    typed in your shell whenever you call HypAss. Instead of this you should
    create a 'make file' whenever you start a new project (even if it's just
    a small one). This is a usual AmiagDos® batch file having the script flag
    set, so it can be invocated as if it was an executable. In this batch
    file you should fix all options which HypAss has to know to process your
    sources. The name of this file should be your source file's name without
    any file extension. E.g. 'testfile' for 'testfile.hsrc'.

    Each make file should have an option slot itself, so you may add new
    options or override existing ones when invocating your make file.

    Example make file:  (hsrc:news/test)

      <------cut here
      .key options/F
      HAss hsrc:news/test.hsrc cpu=6800 obj=S19,cr syn=MOTF lst <options>
      <------cut here

    You see we fix the source filename, the CPU we use, the object format,
    the syntax set and tell HypAss to create a listing file. To assemble,
    you now just type 'hsrc:news/test' in your shell. If you now want to
    view the created listing file, you type 'hsrc:news/test v' and the
    option 'v' will be passed to HypAss through the option slot.

    This is very comfortable during development, cause you surely have fixed
    all options to process this later, but you needn't modify anything if
    you want for example to test another CPU or create another object format.

    Syntax selections should normally always be fixed in your source, cause
    they will never change. Fix them in the make file just for old sources
    which already exist, so you needn't modify any byte of them.

    The '.key' directive has some specials you need to know:
    You will have a hard job if you try to pass a 'obj=s19' option through
    this option slot, because the '.key directive' strips off the '='.
    For this HypAss accepts options in both ways: Either 'obj=S19' what only
    works when calling HypAss directly, or 'obj,S19' what may also be passed
    through the option slot. This is no bug, but a feature of OS2.0+  ;-)
    Note that the option slot as described before requires OS2.0+!

  Advanced make file usage:

    Make files may be nested, but should always have an option slot!

    When you create a huge project, you should create a new directory in
    hsrc:, having your projects name. Then you create a makefile in the root
    directory of hass:, having your projects name. Imagine your project is
    named 'hyper', so the makefile 'hyper' looks like this:

      <------cut here
      .key file/A,options/F
      hsrc:hyper/<file> <options>
      <------cut here

    Note that this makefile calls another makefile, with nested option
    passing! You have now a much easier way to call any part of you project.

    Imagine the first part is called 'init' and has its own makefile in
    hsrc:hyper/init which launches HypAss to assemble the source file
    hsrc:hyper/init.hsrc.

    To assemble you now only need to type 'hyper init' and the first part
    of your project gets created. I don't need to tell you what a helpfull
    feature this is when your main makefile can pass options to arrays of
    project parts later!


  State of the art make file usage:

    You should start from the beginning to have a makefile called 'makeall'
    in the root dir of hass:, and add any main make file call to this global
    makefile. This will be the executable to upgrade your HyperSource® data-
    base tree. New releases of HypAss may feature anything, you just need to
    install, and call 'makeall' and you will have upgraded anything.

    The second file you should start from the beginning is 'Projects.guide',
    which should contain nothing but buttons linking to each main LISTING
    file of any project you made. You will have only one more entry point
    for the whole database tree. (maybe create a hotkey in some utility)

    I will write a utility which should parse the hsrc: tree and create a
    Projects.guide from any file having the script flag set, which can be
    parsed by a second utility to create a temporary batch file in t: and
    start it. (because AmigaDos® currently doesn't support HyperBatches©)

    Hyper, Hyper!

@ENDNODE
----------------------------------------------------------------------------
@NODE General_HYPMAKE_info
  General information about HypMake:        !!needs v2.04/v37 of the OS!!

  INTRODUCTION:

    HypMake is an intuition driven makefile creator/editor including remote
    control to the HypAss executable and various other features. It has a
    localized font sensitive resizable publicscreenable GUI, with online
    help features and templates for frequently needed settings.

    HypMake and HypAss share exactly the same shell argument syntax, that's
    why they are both described in one document. There are some rare options
    which are ignored by the assembler executable, because it has no GUI.
    HypMake's interface has a lot of gadgets, what may confuse the beginner.
    But relax, most functions are optional. The GUI interface consists of
    three sections, divided by two bars:   source - settings - action.

    Source section:

      When you start a project, you create a source file by your favourite
      editor and load it by the 'Src' button. After this, the large string
      field will show the name of your source file without extension, what
      will be the name of the make file. The little string field to the
      right will show the file extension. You may now save a makefile using
      the relating item in the 'Project' menu. If you want to load this make
      file in future, you select it by the 'make' button. Both, the 'Src'
      and the 'Make' button have relating items in the 'Project' menu.

    Settings section:

      Here you may modify all settings of the assembler executable, which
      are described exactly in the main page of this document. Most of these
      settings, and the name of the source file selected above get fixed in
      the make file, which is an executable batch file having the script
      flag set. So you may also start it from shell, just by calling it's
      name. Read more about this in the @{" General SHELLARGS info " link General_SHELL_ARGS_info}.

    Action section:

      This one consists of the status display and a row of action buttons.
      The large field of the status display shows any kind of reports or
      errors. The small field to the right may display one of three makefile
      status levels:

          '---' = empty, nothing important
          'OLD' = existing one, already saved
          'MOD' = modified one, not saved yet

      The action buttons below are the hot spot of HypMake:

          'Assemble' launches the HypAss executable with the actual settings,
                     not with the stored ones, so you can make experiments
                     before you store the results.

          'View'     launches your favourite AmigaGuide viewer which you may
                     config via the amigaguide library context sensitive
                     @{" HyperSource viewer slot " link hass:doc/-acts.guide/HyperSource_Viewer_Slot}. This one is fed with the
                     actually created listing file.

          'Edit'     launches your favourite Editor which you may config via
                     the OS context sensitive @{" Editor slot " link hass:doc/-acts.guide/ACT_EDIT}. This one is fed
                     with the source file you are processing in the moment.

          'Help'     Opens a requester where you can easily access any block
                     of the HypAss documentation tree.

          '-'        This minus sign represents the iconify button, changing
                     HypMake to a small GUI just containing the status row
                     and the action buttons. Usefull when the settings are
                     done and you program, assemble, ...

          '^'        This is the 'forward' button to jump to the next public
                     screen, together with your shell. You have some more
                     PubScreen functions in the tools menu, where you can
                     for example create you own public screen...

          'Quit'     This is the most boaring function of the complete
                     package. Just quit. May also be found in project menu.


  KNOWN BUGS:


  TECHNICAL INFORMATION:

    HypMake is an EasyGui driven OOP transparent shell argument analyzer and
    synthesizer, it converts a shell argument string to an object 'arginfo'
    and may recreate arguments of it again. Transparent means, that HypMake
    may call itself with its own shell args. I plan to detach this object in
    a multi library system, to be able to import makefiles of projects from
    other assemblers. Maybe both, loaders and savers, I don't know yet.

    HypMake is just an early start, and currently can only create make files
    for single root file projects. I plan to be able to create nested make
    file trees by HypMeta....


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_SRCFILE
  SRCFILE/A shell argument  (specify source file)

  FUNCTION:

    The filename of the source file to assemble, must be a valid amigados
    filename. This is the onliest argument you *must* apply, if you don't an
    error will occur. If the sourcefile's extension is '.hsrc' then HypAss
    will enable its HyperSource© mode. This will force the listing file to
    be a valid AmigaGuide® hypertext document (if enabled by LST switch).


  EXAMPLE:

    HAss hsrc:test.hsrc


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_LST1
  LST1/S shell argument  (create pass1 listing)

  FUNCTION:

    Create a pass1 listing file of the actually assembled source file. The
    name of the listing file will be the sourcefile's name, with the file
    extension changed to '.1.lst' in normal mode or '.1.hlst' in HyperSource
    mode. (myprog.src -> myprog.1.lst, myprog.hsrc -> myprog.1.hlst).  If
    Hypass works in HyperSource© mode the created listing file will be a
    valid AmigaGuide® document. Note that many operand values may not be
    resolved yet in pass1 and may for this appear filled up with zeroes or
    with wrong values. Any memory allocating pseudos just reserve the space
    for speed reasons and don't try to evaluate the operands in pass1. This
    all may change in future!

    SEE ALSO:  @{" HyperSource© format " link "hass:doc/-HSRC.guide/main"}


  EXAMPLE:  (creates the file hsrc:test.1.hlst)

    HAss hsrc:test.hsrc lst1


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_LST
  LST/S shell argument  (create listing)

  FUNCTION:

    Create a pass2 listing file of the actually assembled source file. The
    name of the listing file will be the sourcefile's name, with the file
    extension changed to '.lst' in normal mode or '.hlst' in HyperSource©
    mode. (myprog.src -> myprog.lst, myprog.hsrc -> myprog.hlst). If Hypass
    works in HyperSource© mode the created file will be a valid AmigaGuide®
    document. Note that this switch will be the 'last pass listing' switch
    in future, even if just one pass will be necessary.

    SEE ALSO:  @{" HyperSource© format " link "hass:doc/-HSRC.guide/main"}


  EXAMPLE:  (creates the file hsrc:test.hlst)

    HAss hsrc:test.hsrc lst


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_SYM
  SYM/S shell argument  (create symtable)

  FUNCTION:

    Create a label/symbol table file. The name of this file will be the
    sourcefile's name, with the extension changed to '.sym'. (myprog.src or
    myprog.hsrc -> myprog.sym) The created file may be included by HypAss
    again. This file normally contains two tables, which may be disabled
    during reinclusion separately:

      -A table of all symbols assigned by .EQUAL / .SET. Assembly of this
       table may be disabled by defining NO_SYM before reinclusion.
      -A table all labels defined by their location in source code. Assembly
       of this table may be disabled by defining NO_LAB before reinclusion.
      -Optionally you will get a third table of all labels and symbols which
       are local to macros if the @{" LOC " link SHELL_ARG_LOC} switch is set.


  EXAMPLES:  (both create the file hsrc:test.sym)

    HAss hsrc:test.hsrc sym
    HAss hsrc:test.src sym


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_INC
  INC/S shell argument  (create include table)

  FUNCTION:

    Create an include file table. The name of the include table file will be
    the name of the sourcefile, with the file extension changed to '.inc'.
    (myprog.src or myprog.hsrc -> myprog.inc) The file may be included by
    HypAss again. This table contains all referred includes, but only the
    files which were directly included by the main source file (nest level 1)
    will be assembled if you reinclude this file into another project. Files
    included in any other nesting level will also be listed, but disabled
    by a leading ';'. This shell argument is normally of rare use, because
    each listing file contains an include table overview anyway.


  EXAMPLES:  (both create the file hsrc:test.inc)

    HAss hsrc:test.hsrc inc
    HAss hsrc:test.src inc


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_NOBJ
  NOBJ/S shell argument  (no object)

  FUNCTION:

    Disable the creation of an object file. By default Hypass creates an
    object file. This switch disables it, but does not affect assembly in
    any way. Just the object gets thrown away.


  EXAMPLE:  (assemble to NIL)

    HAss hsrc:test.hsrc nobj


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_TEST
  TEST/S shell argument  (test mode)

  FUNCTION:

    Disable any file creation, just simulate assembly 100%. This switch over-
    rides all given @{" LST " link SHELL_ARG_LST}, @{" SYM " link SHELL_ARG_SYM}, @{" INC " link SHELL_ARG_INC}, switches and forces the @{" NOBJ " link SHELL_ARG_NOBJ}
    switch. You may pass this switch through the option slot to verify the
    validity of your project sources without the need to destroy the objects.
    Note that all switches override each others sequentially, so you may set
    another of the switches named above to reenable creation again. THIS IS
    A RUNTIME OPTION AND MUST NOT BE FIXED IN MAKEFILES!


  EXAMPLE:  (test is last arg and overrides the others)

    HAss hsrc:test.hsrc lst sym inc test


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_SYN
  SYN/K shell argument  (select syntax lib)

  FUNCTION:

    Choose the default syntax set getting activated at the beginning of each
    pass. By default the XASS syntax set gets activated (SYN=xass). Use this
    key to select the syntax as you are used to by the @{" .SYN pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_SYN"}. Even
    library options may be passed to the selected library as usual. There's
    just one difference: Spaces are not permitted within the complete syntax
    selection shell argument, because they are used as delimiter to another
    argument.

    SEE ALSO:   @{" SYNTAX libraries " link "hass:doc/-SYN.guide/main"}


  EXAMPLE:

    HAss hsrc:test.hsrc SYN=motf,mdos


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_CPU
  CPU/K shell argument  (select CPU lib)

  FUNCTION:

    Choose the default CPU library getting activated at the beginning of
    each pass. By default no CPU gets activated (CPU=none). Use this key to
    select the processor model as you are used to by the @{" .CPU pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_CPU"}.
    Even library options may be passed to the selected library as usual.
    There's just one difference: Spaces are not permitted within the CPU
    selection shell argument, because they are used as delimiter to another
    argument.

    SEE ALSO:   @{" PROCESSOR libraries " link "hass:doc/-CPU.guide/main"}


  EXAMPLE:

    HAss hsrc:test.hsrc cpu=6805,cmos


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_OBJ
  OBJ/K shell argument  (select object lib)

  FUNCTION:

    Choose the default object library getting activated at the beginning of
    pass2. By default the CBM object format gets activated (OBJ=cbm). Use
    this key to select the required object format as you are used to by the
    @{" .OBJ pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_OBJ"}. Even library options may be passed to the selected lib
    as usual. There's just one difference: Spaces are not permitted within
    the object format selection shell argument, because they are used as
    delimiter to another argument. This key will override the @{" NOBJ " link SHELL_ARG_NOBJ} switch.

    SEE ALSO:   @{" OBJECT libraries " link "HASS:doc/-OBJ.guide/main"}


  EXAMPLE:

    HAss hsrc:test.hsrc OBJ=s19,cr


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_HSRC
  HSRC/S shell argument  (force HyperSource© mode)

  FUNCTION:

    Forces HypAss to enable its HyperSource© mode, even for normal source
    files. Usually the HyperSource© mode will be enabled by HypAss if the
    source file extension is '.hsrc'. In this case HypAss expects a properly
    formatted HyperSource© document. To have all interactive features also
    with normal (old) source code, you may force this mode by setting this
    switch. Currently this switch just has an effect to the created listing
    file. The extension will be '.hlst' and the listing will be a valid
    AmigaGuide© document. The document will contain @{" ACTION  buttons " link "hass:doc/-ACTS.guide/main"},
    linking to each file that has been created in this moment, and to all
    informal pages of the listing file (macros-,include-,object-tables).

    SEE ALSO:  @{" HyperSource© format " link "hass:doc/-HSRC.guide/main"}


  EXAMPLE:

    HAss hsrc:test.asm lst hsrc


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_INL
  INL/S shell argument  (ignore no list)

  FUNCTION:

    Disable the source file's internal listing control. The listing will be
    enabled at any line of the source file, if the @{" LST/S " link SHELL_ARG_LST} switch told so,
    independent of the appearance of @{" .LIST pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_LIST} and @{" .MLIST pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_MLIST} in
    your source code.


  EXAMPLE:

    HAss hsrc:test.hsrc lst inl


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_LLC
  LLC/S shell argument  (list list control)

  FUNCTION:

    Enable the listing of all list controlling pseudo opcodes. By default
    the listing controlling @{" .LIST pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_LIST} and @{" .MLIST pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_MLIST} don't appear
    in the listing file. Because you may nest listing enabling and disabling
    it may be a problem to 'debug' list control, if they are hidden. For
    this we have the LLC switch, so you can see where something is folded.
    This pseudo does not activate the listing output.


  EXAMPLE:

    HAss hsrc:test.hsrc lst llc


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_FWL
  FWL/S shell argument  (forward reference list)

  FUNCTION:

    Enables the listing of all detected forward references. HypAss detects
    forward references in pass 1 and remembers them for pass 2 to avoid
    phasing errors. But nothing can be perfect. There are still some special
    mnemonics or addressing modes that will create phasing errors or illegal
    addressing mode errors if you forward reference in their operand field.
    The same can occure by programming mistakes within conditional assembly.
    To have a good debugging tool I added multi-pass listing support, but
    sometimes it's difficult to find the position where the phasing error
    occured, especially if you have large areas in your source without label
    or symbol definitions. Enable this switch then, it may help you.


  EXAMPLE:

    HAss hsrc:test.hsrc lst fwl


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_DL
  DL/S shell argument  (dummy list)

  FUNCTION:

    Enables the listing of all detected @{" dummy pseudos " link hass:doc/-syn.guide/HYPASS_PSEUDO_DUMMIES}. Each syntax library
    knows some old pseudo opcodes, which get detected not to create an error,
    but which do not affect assembly in any way. It may happen, that one of
    these dummies 'eat' away symbols used in a source file, which have the
    same name. For this all detected dummies get counted, and the result may
    be checked in the status information of HypAss. So if this counter isn't
    zero and strange things happen to a source file, which is known to be ok
    you may enable a dummy listing. Detected dummies will then create a
    'detected dummy' error in each pass. You will have no problems to see
    what HypAss has eaten away...


  EXAMPLE:

    HAss hsrc:test.hsrc lst dl


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_LOC
  LOC/S shell argument  (locals list)

  FUNCTION:

    Enables the listing of all local labels and symbols local to macros
    within the symbol table if the @{" SYM " link SHELL_ARG_SYM} is set. Depending on the selected
    syntax system, all labels and symbols defined within macros may be local,
    so they they are unique not to collide during repetitive calls of these
    macros or to other global definitions having the same name. These labels
    and symbols normally never appear in a symbol table. This is not very
    helpfull when debugging macros, so we may enable their listing by using
    the LOC switch. All labels, symbols and locals are listed in sequential
    order, to allow an easier access to the right macro invocation period
    and nesting level. THIS IS A RUNTIME OPTION AND MUST NOT BE FIXED IN
    MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc sym loc


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_VIEW
  V=VIEW/S shell argument  (view listing[s])

  FUNCTION:

    Display ALL created listings e.g. by MultiView(s) when assembly is
    finished and no fatal error ocurred. Note that this switch will only
    work if you really have created a listing by using the @{" LST " link SHELL_ARG_LST} switch.
    The viewer invoked is configurable via the AmigaGuide® library context
    sensitive @{" HyperSource viewer slot " link hass:doc/-acts.guide/HyperSource_Viewer_Slot}. THIS IS A RUNTIME OPTION AND MUST
    NOT BE FIXED IN MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc lst v


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_VE
  VE/S shell argument  (view on error)

  FUNCTION:

    Display the object listing e.g. by MultiView when assembly is finished
    only if non-fatal errors occured. Note that fatal errors will break
    HypAss anyway (That's what they should). This switch automatically sets
    the @{" LST " link SHELL_ARG_LST} switch, if it isn't already set. The viewer which will be
    invoked then, is configurable via the AmigaGuide® library context sensi-
    tive @{" HyperSource viewer slot " link hass:doc/-acts.guide/HyperSource_Viewer_Slot}. THIS IS A RUNTIME OPTION AND MUST NOT
    BE FIXED IN MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc ve


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_MAC
  MAC/S shell argument  (Macintosh® source mode)

  FUNCTION:

    Forces HypAss to enable its C64/Macintosh® source compatible mode, which
    may be used to assemble any sources containing $0D line termination.
    We have 3 general kinds of line terminating systems in computer world:

                    Amigas    use "\\n"   = $0A,
                    PCs       use "\\r\\n" = $0D0A
                    C64s/Macs use "\\r"   = $0D

    Now HypAss can't be compatible to them all in general. So I have choosen
    the Amiga :) and PC terminators to work by default, and optionally the
    C64/MAC terminators if the 'MAC' switch is set. A good indicator for MAC
    or C64 sources is that you will get tons of 'line too long' errors. Try
    this switch then. While nearly any newer computer system supports the
    7-bit ASCII standard (except the differences in line termination), you
    don't even need a text filter to assemble MAC sources, if the author of
    the sources wasn't silly and used for example german 'umlauts' in label
    and symbol names! The listing created by HypAss will of course contain
    Amiga line termination, in any of the three cases shown above.


  EXAMPLE:

    HAss hsrc:test.asm mac


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_LM
  LM/S shell argument  (low memory)

  FUNCTION:

    Forces HypAss to enable its low memory mode. This will limit the memory
    consumption of HypAss to less than 500KB. The size of the files you read
    and write does not affect the memory requirements in this mode. Note that
    this value increases with your usage of labels, symbols, macros and for-
    ward references, and will surely grow with HypAss! The lowmem mode will
    be forced automatically during startup of HypAss, if the availlable
    memory is less then about 1MB. This switch is the global force low mem
    indicator, and in future each part of the system will keep track of this
    switch, when constructing itself. This can be very usefull for people
    using small Amigas, not having enough memory to store all used source
    and include files, or for multiuser-systems, assembling in shared host
    resources, using resident HypAss'. By making HypAss resident you may
    save another 100K for each (reentrant) call. This mode will of course
    slow down HypAss, depending on the speed of your storage medium.


  EXAMPLE:

    HAss hsrc:test.hsrc lm


  SPEED COMPARISON:

    An example to compare speed and memory consumption: I assembled a 250K
    source defining 1300 labels and symbols, 20 macros and 414 forward refs
    on a 25MHz 68EC030, FASTRAM. The storage medium was a 1.8MB/s hard disk.
    If you use floppy based systems the difference will increase horribly.

          Mode:     Memory:       Time:
         -----------------------------------------------------------
         lowmem      450K    +12% 18.7  object only    (no includes)
          fast       630K         16.7  object only    (no includes)
         lowmem      470K    +16% 33.0  object+listing (no includes)
          fast      1200K         28.3  object+listing (no includes)
         lowmem      450K    +33% 27.2  object only    (47 includes)
          fast       680K         20.4  object only    (47 includes)
         lowmem      470K    +34% 44.9  object+listing (47 includes)
          fast      1300K         33.6  object+listing (47 includes)


  DETAILLED DESCRIPTION:

    FAST MODE:

      Buffers for source and include files get allocated dynamically during
      pass1, keeping them whole in memory for pass 2. This requires the full
      memory space of your allover source+includes filesize.
      The listing buffer will be static allocated lowmem type during pass1,
      because it can't imagine the full project size yet. In pass 2 the size
      is known, the old buffer gets thrown away and a new buffer with the
      excpected full listing size will be allocated. The listing routine
      requests about 2.5 times the allover source+includes size from the
      system. If this was not successfully the usual lowmem buffering will
      be used instead.
      The object buffer gets allocated at the beginning of pass2. The object
      library gets opened and HypAss asks for the object type. If it is of
      binary type, the full binary image size buffer will be allocated, if
      it is hex type the buffer will explode to the aproxximated hexfile
      size. This is usually between 2.5 and 3.0 times the raw binary image
      size. This overhead relates to the actually selected object type and
      gets calculated object library specific.


    LOWMEM MODE:

      HypAss will use only one shared static allocated buffer for source and
      include files, keeping a limited size of ONE source or includefile in
      memory. You may e.g. assemble 5MB projects, just needing 1K of source
      buffer. This will of course slow down HypAss, because all files have
      to get loaded in each pass, piece by piece.
      The object and listing buffers will be limited size static allocated.


  STRESS TEST:

    I set the pure flag and made HypAss resident. After this I stripped down
    my memory to exactly 3 MB and launched an array of 6 HypAss' asynchro-
    nously in low memory mode, each one assembling the same 250K database of
    47 includes, just each one creating another object type not to collide
    with their output locks. Each HypAss opened the same syntax and cpu libs.
    The HypAss' didn't loose any memory or leave behind any lock or opened
    library, and I guess it is safe to run HypAss pure reentrant. (Thanks to
    AmigaE!) The same tests have been processed sucessfully in fast mode.
    If no lowmem was forced, as many HypAss' started as there was enough
    memory. Then one more HypAss started in lowmem mode and the rest of
    HypAss' failed safely in an 'not enough memory' error.

    Next I made the hardcore output collision crash test with the example
    tree described before, running 6 resident HypAss', assembling absolutely
    the same project, each one tried to open the same object and listing
    files! The first HypAss opens both files and writes them successfully,
    all the others report a listing and object collision, safely disable the
    file creation and continue assembly till the end. No memory lost.

    To be absolutely sure I tried the last example with an array of 18 resi-
    dent HypAss' requiring my full 18MB of RAM runnung asynchronously the
    same project in total collision. No problems occured, no memory fragmen-
    tation IF NO OTHER TASK REQUIRED NEW MEMORY. HypAss may run in heavily
    fragmented memory when it was made resident and the lowmem mode is enab-
    led. It just needs a 32K block for macros then, and 2 16K blocks for the
    listing and object buffers. Any other memory consumption is in pieces
    smaller than 1K. The low mem restrictions will be configurable some day.

        NOTE: If you use HypAss in multi-user-systems you should
              reboot whenever the memory is fragmented too much.
              (This is nothing new about MU-systems)
              While HypAss may be interrupted by CtrlC it would be
              no problem to break them all and wait until they dis-
              appeared from the process list to be sure that no more
              write-locks are active. Please tell me your experience
              if you do things like that.


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_CASE
  CASE/K shell argument  (choose case dependency)

  FUNCTION:

    By default labels, symbols and macros are case sensitive. This could be
    changed using the CASE shell argument. You need at least 2 more args,
    the first one selects if you want to specifiy the macro or symbol case
    dependency (MAC | SYM), the second one selects if you want dependency
    or not (ON | OFF). You may also apply 4 arguments, then the procedure
    above gets repeated twice. Note that your selection overrides the
    default 'case dependency' at the beginning of each pass. So this changes
    are only valid until the first @{" .CASE pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_CASE"} appears within your source.

  EXAMPLE:

    HAss hsrc:test.hsrc CASE=mac,on,sym,off


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_NAX
  NAX/K shell argument  (no auto include extensions)

  FUNCTION:

    By default filenames applied to the @{" .INCLUDE pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_INCLUDE"} get automatically
    extended by the path 'HINC:' if they don't specify a path themselves,
    and by the extension '.hinc' if they have no file extension. This may be
    surpressed by the 'NAX' switch, for example to assemble sources written
    for another assembler.


  EXAMPLE:

    HAss src:test.asm NAX


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_DEF
  DEF/K shell argument  (define symbol[s])

  FUNCTION:

    Define one or more redefinable symbol(s). This switch was implemented to
    remote features within your source which are embedded in conditional
    assembly. You may apply one or more symbol names to this shell argument,
    the symbols will be assigned to the value -1 (TRUE), so they may be
    checked by the @{" .IFD pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_IFD"} or the @{" .IF pseudo " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_IF"}. The named symbols get
    initialized at the beginning of each pass as REDEFINABLES.


  EXAMPLE:

    HAss hsrc:test.hsrc def=SYMBOL1,SYMBOL2


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_SKP
  SKP/S shell argument  (skip assembly)

  FUNCTION:

    Forces HypAss to set return code OK=0 and directly terminate assembly.
    This may be useful in batch files calling other executables that process
    data created by HypAss while debugging. If the file created by HypAss is
    ok and you want to continue e.g. by configuring other programs, which
    maybe send the object file to a single board computer, EPROM simulator
    or a PROMmer, then this switch will be a good help. THIS IS A RUNTIME
    OPTION AND MUST NOT BE FIXED IN MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc skp


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_BRK
  BRK/S shell argument  (break on exit)

  FUNCTION:

    Forces HypAss to set return code FAIL=20 when assembly is finished. This
    may be useful to break batch files calling other executables to process
    data created by HypAss while debugging. I set my finished batch files to
    'failat 20', so this switch will break them. While developing I use the
    default (=failat 10), so HypAss will break the script if any error
    occured. THIS IS A RUNTIME OPTION AND MUST NOT BE FIXED IN MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc brk


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_QUIET
  QUIET/S shell argument  (be quiet)

  FUNCTION:

    Disable any informative shell output of Hypass. This switch may be help-
    full in batch files, but does not affect errors. Errors get displayed as
    usual. THIS IS A RUNTIME OPTION AND MUST NOT BE FIXED IN MAKEFILES!


  EXAMPLE:

    HAss hsrc:test.hsrc quiet


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_ICO
  ICO/S shell argument  (iconified state)

  FUNCTION:

    Forces HypMake to open in the iconified state. This switch may be use-
    full if you specify the project within the shell arguments, and know,
    that the settings are ok, so you can directly start assembly or whatever
    with a GUI which does not hide a lot of your screen. This option only
    affects HypMake and gets ignored by HypAss.


  EXAMPLE:

    HMake hsrc:test.hsrc ico


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_SCR
  SCR/S shell argument  (own Screen)

  FUNCTION:

    Forces HypMake to open on an own Public Screen. By default this screen
    will have the public name 'HyperPub', which may be overridden using the
    @{" PUB/K " link SHELL_ARG_PUB} key additionally. Normally HypMake opens its interface on the
    actual default public screen, what is usually the Workbench. Using this
    switch, HypMake will clone your Workbench screen and open a full screen
    console on it. This option only affects HypMake and gets ignored by
    HypAss.


  EXAMPLE:

    HMake hsrc:test.hsrc scr
    HMake hsrc:test.hsrc scr pub=MyOwnHyperSourceScreen


@ENDNODE
----------------------------------------------------------------------------
@NODE SHELL_ARG_PUB
  PUB/S shell argument  (PublicScreen name)

  FUNCTION:

    Specify the name of a Public Screen. This key has 2 different meanings.
    If it is used for itself, it forces HypMake to open on the named,already
    existing Public Screen. If the @{" SCR/S " link SHELL_ARG_SCR} is given additionally, then this
    key will specify the public name of the new screen to be created. This
    option only affects HypMake and gets ignored by HypAss.


  EXAMPLE:

    HMake hsrc:test.hsrc pub=DOPUS.1
    HMake hsrc:test.hsrc scr pub=MyOwnHyperSourceScreen


@ENDNODE
----------------------------------------------------------------------------
