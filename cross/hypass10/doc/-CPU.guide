@DATABASE $VER: HypAss 1.0 CPU.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
----------------------------------------------------------------------------
@NODE MAIN "HypAss CPU libraries"
@NEXT MAIN "HypAss CPU libraries"
@TOC hass:HypAss.guide/main
  HypAss CPU library overview  @{" General CPU info " link General_CPU_info}  *** READ THIS FIRST ***
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED

     68xx: @{"  6800    " LINK CPU_6800   } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/6800.hlst/main  }   6800, 6802, 6808
           @{"  6801    " LINK CPU_6801   } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/6801.hlst/main  }   6801, 6803
           @{"  6804    " LINK CPU_6804   } @{"INC" LINK HASS:doc/-hinc.guide/HINC_6804 } @{"LST" LINK HSRC:cpu/6804.hlst/main  }   6804
           @{"  6805    " LINK CPU_6805   } @{"INC" LINK HASS:doc/-hinc.guide/HINC_6805 } @{"LST" LINK HSRC:cpu/6805.hlst/main  }   6805, 68HC05, 68HC705, 68HC805
           @{"  6809    " LINK CPU_6809   } @{"INC" LINK HASS:doc/-hinc.guide/HINC_6809 } @{"LST" LINK HSRC:cpu/6809.hlst/main  }   6809
           @{"  6811    " LINK CPU_6811   } @{"INC" LINK HASS:doc/-hinc.guide/HINC_6811 } @{"LST" LINK HSRC:cpu/6811.hlst/main  }   68HC11, 68HC711, 68HC811
           @{"  6816    " LINK CPU_6816   } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/6816.hlst/main  }   68HC16

     63xx: @{"  6303    " LINK CPU_6303   } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/6303.hlst/main  }   6303
           @{"  6309    " LINK CPU_6309   } @{"INC" LINK HASS:doc/-hinc.guide/HINC_6809 } @{"LST" LINK HSRC:cpu/6309.hlst/main  }   6309

     PIC:  @{"  16C5x   " LINK CPU_16C5x  } @{"INC" LINK HASS:doc/-hinc.guide/HINC_pic  } @{"LST" LINK HSRC:cpu/16C5x.hlst/main }   16C54 - 16C58
           @{"  16Cxx   " LINK CPU_16Cxx  } @{"INC" LINK HASS:doc/-hinc.guide/HINC_pic  } @{"LST" LINK HSRC:cpu/16Cxx.hlst/main }   16C64, 16C71, 16C74, 16C84
           @{"  17Cxx   " LINK CPU_17Cxx  } @{"INC" LINK HASS:doc/-hinc.guide/HINC_pic  } @{"LST" LINK HSRC:cpu/17Cxx.hlst/main }   17C42

     65xx: @{"  6502    " LINK CPU_6502   } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/6502.hlst/main  }   6500 - 6507, 6510 - 6515, 8510
           @{"  65SC02  " LINK CPU_65SC02 } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/65SC02.hlst/main}   65SC02-07, 65SC12-15, 65SC102-107, 65SC112, 65SC115
           @{"  65C00   " LINK CPU_65C00  } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/65C00.hlst/main }   65C00, 65C02, 65C10
           @{"  65C02   " LINK CPU_65C02  } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/65C02.hlst/main }   65C02, 65C102, 65C112
           @{"  658xx   " LINK CPU_658xx  } @{"   " LINK -                              } @{"LST" LINK HSRC:cpu/658xx.hlst/main }   65SC802, 65SC816

    empty: @{"  NONE    " LINK CPU_NONE   } @{"   " LINK -                              } @{"   " LINK -                        }   ---

@ENDNODE
----------------------------------------------------------------------------
@NODE General_CPU_info
@PREV General_CPU_info
@NEXT General_CPU_info
  HypAss general CPU information

  INTRODUCTION:

    HypAss has a flexible library system to switch between various CPUs in
    your program as often and whenever you want. Because HypAss is designed
    to support lots of CPUs there is by default no CPU activated. This may
    sound silly, but which one should it be? So you have to specify the CPU
    you want to work with. For this we have the @{" .CPU pseudo opcode " link "hass:doc/-SYN.guide/HYPASS_PSEUDO_CPU"}, which
    *MAY* introduce each source file you write. But a much better way is to
    specify the relating CPU within the shell arguments. For this we have
    the @{" Shell argument CPU/K " link hass:doc/-args.guide/SHELL_ARG_CPU}. What's the difference? Now if you specify
    the CPU within your source file it is somehow 'hardcoded' and may just
    be changed by editing your source, but if you use the shell argument you
    have an external control of the destination CPU you want to use. There
    are many CPUs which are compatible to each others, and you can assemble
    your source for any compatible CPU later, without the need to change your
    source file! This does not mean that you have to specify the CPU during
    each call of HypAss, you should start from the first minute to create a
    'make file' for your project. This is a usual AmigaDos® batch file and
    should fix all these shell options. Read more about make files in the
    @{" Shell arguments " link "hass:doc/-args.guide/main"} description.

    HypAss has a CPU name hashtable, which allows you to use various aliases
    for one and the same CPU library name. This document shows in the 'usage'
    section of each CPU library description first the real library name and
    then all possible aliases connected by the OR '|' sign. This means, that
    you may specify *one* of these aliases. This was made for future enhance-
    ment, because I want to make more CPU specific deep error check. HypAss
    will then adapt your selection to all it knows in that moment, so start
    from the beginning to select your CPU precise.  This gets more important
    when HypAss will be able to emulate these CPUs. To be able to know
    exactly which CPU you programm for, you should also specify the last
    indentification characters, so a future emulator can know what peri-
    pherals are on chip. For example: It does not say a lot if you specify
    '.cpu 68HC11', because there exist various flavours of this CPU. It's
    more precise if you say '.CPU 68HC11-F1' so HypAss may know exactly
    what you mean. Everything past the '-' currently gets ignored, the rest
    is used to map to one of the CPU libraries. Please do this from the
    very beginning, so you will not have compatiblity problems in future.
    I have choosen the CPU library names to have a short key which clearly
    identifies the CPU family. This may be nonsense in some cases (e.g.
    there exists no 6811), but it keeps the identifiers short. You will
    notice which cpu library HypAss has mapped for your selection with one
    look at the status display. If you know more members of a family please
    let me know, and give a short description of the address room and any
    other specifics of that CPU.

    Important: Forcing of addressing modes is currently only implemented in
    a few CPUs, and I want to disable this feature in general! I plan to get
    CPU independant, and forced addressing modes will report errors if these
    modes are not availlable on another CPU. This will reduce compatiblity!
    You should normally let HypAss do the decision of the code optimization,
    that will be the most future compatible way. Imagine to run 6502 code on
    an 68HC11 or a PIC, what do you want to force? The code optimization is
    very unfinished yet, but I need bug reports from you! I may update very
    frequently via Aminet®, but I need your problems to fix them. Send me
    critical material, I will make it work, if possible. Send me the sources,
    I can't progam for so many CPUs to test them all entirely! They all had
    their test suites and reference assemblers, but real life is different.

    If somebody is interested to make a support BBS or whatever, contact me!
    If somebody has a lot of money, please pay me a steady internet access,
    and I can update every day I change something! I will not pay any more
    cent to work for you all. It's expensive enough to feed my Amiga and buy
    enough tobacco to make Amiga yellow. (it's ugly, the monitor sucks the
    smoke) .


  FUTURE PLANS:

    -4-level meta instruction set classification system within the libraries
     to allow cross CPU assembly to same or higher level CPUs.
    -Instruction cycle count optimization, for writing program loops with
     precise loop period, what may reduce the need of timers for pure CPUs.
    -Reassembler / disassembler support for each CPU.
    -Far away: Emulating CPUs. I'm not sure if this makes sense. I would
    prefer in circuit emulation controlled by Amiga HyperSource© debugger.

    If you want to see another processor be implemented, please send me the
    original manuals, because it's impossible to organize any manuals that
    exist. I have tons of manuals, and I haven't implemented them all yet.
    Please tell me if someone is interested to see Z80 and the Z8 micro-
    controller family be implemented here. Same for ST62 family.
    I am personally *not* interested in implementing 80xx / 80xxx CPUs and
    MCUs. If someone really can't live without, learn AmigaE, read the
    developer info and program it yourself. There exists a 6502 compatible
    microcontroller with some additional features and an incompatible
    mnemonic extension, I ordered the manuals, but I lost them in summer
    somewhere in the sun. So this one is not implemented yet. Do we need
    68xxx support in a cross assembler? I guess yes, because of 683xx series.
    I will let your resonance decide what are the precedences in this area.
    (Unless I need a new micro myself. :) Please understand that this is no
    guarantee to have your wishes implemented in your registered version.
    If you are AmigaE programmer yourself, maybe help me and read the
    developers corner in the license file.


  NOTES:

    All information stored within these CPU libraries is taken out the
    original manuals of *ONE* manufactorer for each CPU. There are a lot
    of CPU's where there also exist third party manufactorers, which maybe
    have differences in their documentation. If you know about something
    like that, let me know, and I'll implement it for compatiblity.
    Although I have taken all information carefully out of original manuals,
    is there no guarantee that I did't make mistakes. The named assemblers
    where a good help to verify my object code, but they were not used to
    "extract" data out of them. I'm a programmer, and no pirate.

    All PC reference tests were of course made on Amiga without the need of
    Bill, of MS (what is *not* a short form for Multiple Sclerose) and of
    I*tel, using IBeM_105 and DR-DOS© 6.0! All C64 reference tests were of
    course made on Amiga although I still own C64's. I ran A64 3.01 DEMO
    although I bought a CD which made great talks about containing the full
    version of A64 3.01. A review about the CD can be found @{" here " link hass:doc/C64Sensations.txt/main}.

    SEE ALSO: @{" Thoughts about CPUs " link THOUGHTS_ABOUT_CPUS} <- DON'T READ THIS!


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6800
@PREV CPU_6800
  HypAss 6800 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6800.hlst/main}

  USAGE:

    .CPU 6800 | 6802 | 6808


  FEATURES:

    Supports all basic 6800 addressing modes and opcodes.
    Use this library for 6800, 6802, 6808.


  COMPATIBLITY:

    The alternatives BHS, BLO, LSL, LSLA, LSLB are included.
    For old M6800RES MICBUG software, all accu A or B instructions
    may also have a register name applied to the base of the mnemonic:
      LSRA = LSR A,  STAA $FF = STA A $FF, CMPA = CMP A ........
    Do not use this feature for new source code !
    The indexed addressing mode may also be forced to a zero offset if
    you apply ',x' without any offset value to the relating mnemonic.



  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6800"}  @{" HypAss " LINK HSRC:cpu/6800.hsrc/main}  @{" AS0 " LINK HSRC:cpu/6800.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS0 TER_2.0 V2.09


  STRESS TEST:

    This library was tested by assembling about 130 files of the
    @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}, all files assembled without
    any mnemonic syntax incompatiblities.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6801
  HypAss 6801 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6801.hlst/main}

  USAGE:

    .CPU 6801 | 6803


  FEATURES:

    Supports all 6801 addressing modes and opcodes.
    Is upward source/object code compatible to @{"6800" LINK CPU_6800}.
    Use this library for 6801, 6803.
    Additional opcodes to 6801:

        abx,  addd, subd,
        brn,
        asld, lsrd, lsld
        mul,
        ldd,  std,
        pshx, pulx,


  COMPATIBLITY:

    The alternatives BHS, BLO, LSL, LSLA, LSLB are included.
    For old M6800RES MICBUG software, all accu A or B instructions
    may also have a register name applied to the base of the mnemonic:
    LSR A = LSRA,  STA A $FF = STAA $FF... Don't use for new source code !
    Supports the aliases  LDAD=LDD STAD=STD.
    The indexed addressing mode may also be forced to a zero offset if
    you apply ',x' without any offset value to the relating mnemonic.


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6801"}  @{" HypAss " LINK HSRC:cpu/6801.hsrc/main}  @{" AS1 " LINK HSRC:cpu/6801.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS1 TER_2.0 V2.09


  STRESS TEST:

    This library was tested by assembling about 130 files of the
    @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}, all files assembled without
    any mnemonic syntax incompatiblities.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6303
  HypAss 6303 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6303.hlst/main}

  USAGE:

    .CPU 6303


  FEATURES:

    Supports all HD6303 addressing modes and opcodes.
    Is upward source/object code compatible to @{"6800" LINK CPU_6800} and @{"6801" LINK CPU_6801}.
    Additional opcodes to 6801:

        xgdx
        aim $xx / $xx,x
        eim $xx / $xx,x
        oim $xx / $xx,x
        tim $xx / tim $xx,x
        slp


  COMPATIBLITY:

    The alternatives BHS, BLO, LSL, LSLA, LSLB are included.
    For old M6800RES MICBUG software, all accu A or B instructions
    may also have a register name applied to the base of the mnemonic:
    LSR A = LSRA,  STA A $FF = STAA $FF... Don't use for new source code !
    Supports the aliases  LDAD=LDD STAD=STD.
    The indexed addressing mode may also be forced to a zero offset if
    you apply ',x' without any offset value to the relating mnemonic.
    Keyword for DAsm/SAsm friends: HD6303


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6303"}  @{" HypAss " LINK HSRC:cpu/6303.hsrc/main}  @{" DAsm " LINK HSRC:cpu/6303.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    DASM V2.12, (c) Matthew Dillon


  STRESS TEST:

    This library was tested by assembling about 130 files of the
    @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}, all files assembled without
    any mnemonic syntax incompatiblities.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6804
  HypAss 6804 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6804.hlst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_6804}

  USAGE:

    .CPU 6804 [,PLUS]


  FEATURES:

    Supports all 6804 addressing modes and opcodes. The registers of 6804
    are memory locations: (a=$FF x=$80 y=$81 v=$82 w=$83). The 'v' and 'w'
    registers have been added by me for easier access to the short direct
    addressing mode, supported by INC/DEC/LDA/STA with the operand x/y/v/w.
    You may also apply the memory location instead of using the register
    names. There will be no difference in the created object code.
    Wherever an address may be applied to an opcode you can use the
    register names a/x/y/v/w. The created opcode gets optimized if there
    exists a short direct addressing opcode that does the same.

    When I added the register name 'v' and 'w' I also added the relating
    instructions for code symmetry . These additional instructions are:
    CRLV,CLRW,DEV,DEW,INV,INW,LDVI,LDWI,TAV,TAW,TVA,TWA,DECV,DECW,INCV,INCW.
    You enable them with the 'PLUS' switch of the 6804 library. If they are
    disabled and they appear in source you'll get a 'forbidden opcode' error.
    NOTE: These mnemonics are an idea of the author to make 6804 short direct
    addressing easier, and are not compatible to any other 6804 assembler.
    If you want to write source code compatible to other assemblers you
    should not use the PLUS switch. The symbols  v and w for the memory
    locations $82 and $83 should be defined in your program then.


  COMPATIBLITY:

    Supported aliases are: ADDA=ADD   ANDA=AND   CMPA=CMP   SUBA= SUB
    BHS=BCC  BLO=BCS       DEX=DEC X  DEY=DEC Y  INX=INC X  INY=INC Y
    There are various different ways to describe one and the same opcode:
    LDA x = LDA $81 = TXA ....       While I havn't any 6804 program yet
    I can not make big talks about compatiblity. Maybe anyone of you has
    a hopefully large collection of 6804 source code for testing purposes?
    I have just a little datasheet, and no manual of 6804 yet.  :(


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6804"}  @{" HypAss " LINK HSRC:cpu/6804.hsrc/main}  @{" AS4 " LINK HSRC:cpu/6804.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS4 TER_2.0 V2.09


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6805
  HypAss 6805 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6805.hlst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_6805}

  USAGE:

    .CPU 6805 | 68705 | 68HC05 | 68HC705 | 68HC805 [,CMOS] [,MUL]


  FEATURES:

    Supports all 6805 addressing modes and opcodes. The 'CMOS' switch
    enables the instructions 'STOP' and 'WAIT', which can only be found
    in CMOS versions of the 6805. The 'MUL' switch enables the 'MUL'
    instruction, not present in every 6805 family processor. If one of
    these instructions appears in source and the relating switch is not
    enabled you will get a 'forbidden opcode' error.
    Use this library for 6805, 68705.


  COMPATIBLITY:

    Keyword for HitAsm friends: HC05


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6805"}  @{" HypAss " LINK HSRC:cpu/6805.hsrc/main}  @{" AS5 " LINK HSRC:cpu/6805.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS5 TER_2.0 V2.09


  STRESS TEST:

    I have not a lot of 6805 source to test. Tested files were:
    6805_DST(ONCE), math16b, mbug05c8, mcm2814
    ONCE contains 2 header lines that have to get removed. Will assemble
    properly anyway. No mnemonic confusion detected.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6809
  HypAss 6809 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6809.hlst/main}   @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_6809}

  USAGE:

    .CPU 6809 [,PCA] [,PCR]


  FEATURES:

    Supports all 6809 addressing modes and opcodes. Is upward source code
    compatible to @{"6800" LINK CPU_6800} and @{"6801" LINK CPU_6801} when using the emulation includes.
    Direct page optimization is enabled by default. (For what should it be
    disabled?) Use '.DIR' pseudo to set the direct page origin. Note that
    the dp address will get reset to 0 whenever you change a cpu lib option.
    The PCA switch disables the creation of PC-relative addresses, PCR
    enables it again, when using one of the following addressing modes:
      LDA $11,PC   LDA $1111,PC   LDA [$11,PC]   LDA [$1111,PC]
    By default the generated opcodes will be PC-relative and therefore
    will contain $11-pc-3 or $1111-pc-4, as AS09 [1.04] does. When PCA
    is enabled they will contain $11 or $1111, like AS9 TER_2.0 V2.09
    of the Motorola freeware assemblers does.
    This library supports the 6809 typical way to force the addressing modes:
    The character '<' preceding an operand indicates the direct addressing
    mode or an 8-bit offset in indexed mode, the character '>' preceding
    an operand indicates the extended addressing mode or a 16-bit offset in
    indexed mode. Additionally to usual Motorola® standard you may force the
    5-bit offset indexed mode by a '<<' preceding the operand. In opposite
    to other assemblers this switches do not cut off the operand if it is
    too large! It is not professional to work like that. How to find a bug
    then? HypAss will display an error wherever an addressing mode gets
    forced that doesn't exist, and wherever an operand would be cutted off
    to fit in the choosen forced addressing mode. This is the most safe way
    to programm.  Example: If you cut off -128 ($80) to fit in 5bits, the
    result will be 0!?! For what should this be good?


  COMPATIBLITY:

    Supports alternative register names:  CCR=CC  DPR=DP  PCR=PC SP=S
    The ccr manipulating instructions ANDCC, ORCC, CWAI are implemented in
    immediate way or directly by offering one ore more cc flag names:
      ANDCC Z,N,V
    The stack manupulating instructions support the key ALL, which will set
    all supported flags of the relating instruction:  PULU ALL
    Be careful: not source compatible to 6309! (6809: $F7,  6309: $FF)
    For As09 compatiblity you may also force the 16-bit offset indexed mode
    or the extended addressing mode by '>>' prededing the operand.


  NOTE:

    The direct page optimization used by this CPU is prelimary, and is not
    finished yet. It may still create phasing errors in forward references.
    The 6809 has a very complex unusual instruction set, so it does't fully
    run within the main optimizer routines. For this it is not 100% forward
    reference proof yet. This will not be dangerous, because you will get a
    phasing error reported then. If someone works intensive with this CPU,
    may you please report me which are the problems, and send me examples
    which contain the problematic stuff. I have no time to test all possible
    errors and forwards for this CPU. (It's so complex that the 16bit addr.
    room is not able to 'eat' all mnemonics in all addressing modes at once)


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6809"}  @{" HypAss " LINK HSRC:cpu/6809.hsrc/main}  @{" AS9 " LINK HSRC:cpu/6809.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS9 TER_2.0 V2.09


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6309
  HypAss 6309 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6309.hlst/main}   @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_6809}

  USAGE:

    .CPU 6309 [,PCA] [,PCR]


  FEATURES:

    Supports all HD6309 addressing modes and opcodes. Is upward source code
    compatible to @{"6800" LINK CPU_6800} and @{"6801" LINK CPU_6801} when using the emulation includes.
    Direct page optimization is enabled by default. (For what should it be
    disabled?) Use '.DIR' pseudo to set the direct page origin. Note that
    the dp address will get reset to 0 whenever you change a cpu lib option.
    The PCA switch disables the creation of PC-relative addresses, PCR
    enables it again, when using one of the following addressing modes:
      LDA $11,PC   LDA $1111,PC   LDA [$11,PC]   LDA [$1111,PC]
    By default the generated opcodes will be PC-relative and therefore
    will contain $11-pc-3 or $1111-pc-4, as AS09 [1.04] does. When PCA
    is enabled they will contain $11 or $1111, like AS9 TER_2.0 V2.09
    of the Motorola freeware assemblers does.
    This library supports the 6809 typical way to force the addressing modes:
    The character '<' preceding an operand indicates the direct addressing
    mode or an 8-bit offset in indexed mode, the character '>' preceding
    an operand indicates the extended addressing mode or a 16-bit offset in
    indexed mode. Additionally to usual Motorola® standard you may force the
    5-bit offset indexed mode by a '<<' preceding the operand. In opposite
    to other assemblers this switches do not cut off the operand if it is
    too large! It is not professional to work like that. How to find a bug
    then? HypAss will display an error wherever an addressing mode gets
    forced that doesn't exist, and wherever an operand would be cutted off
    to fit in the choosen forced addressing mode. This is the most safe way
    to programm.  Example: If you cut off -128 ($80) to fit in 5bits, the
    result will be 0!?! For what should this be good?


  COMPATIBLITY:

    Supports alternative register names:  CCR=CC  DPR=DP  PCR=PC SP=S
    The ccr manipulating instructions ANDCC, ORCC, CWAI are implemented in
    immediate way or directly by offering one ore more cc flag names:
      ANDCC Z,N,V
    The stack manupulating instructions support the key ALL, which will set
    all supported flags of the relating instruction:  PULU ALL
    Be careful: not source compatible to 6309! (6809: $F7,  6309: $FF)


  NOTE:

    The direct page optimization used by this CPU is prelimary, and is not
    finished yet. It may still create phasing errors in forward references.
    The 6309 has a very complex unusual instruction set, so it does't fully
    run within the main optimizer routines. For this it is not 100% forward
    reference proof yet. This will not be dangerous, because you will get a
    phasing error reported then. If someone works intensive with this CPU,
    may you please report me which are the problems, and send me examples
    which contain the problematic stuff. I have no time to test all possible
    errors and forwards for this CPU. (It's so complex that the 16bit addr.
    room is not able to 'eat' all mnemonics in all addressing modes at once)


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6309"}  @{" HypAss " LINK HSRC:cpu/6309.hsrc/main}  @{" AS09 " LINK HSRC:cpu/6309.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    AS09 [1.04] (C) Frank A. Vorstenbosch

    Both, the optimizing and the normal mode have been tested.
    While AS09 supports branch/jump/call optimization, this CPU library
    currently doesn't support this feature. This may change in future.


  WHO HAS THE BUG?:

    While comparing the object codes of both assemblers I found out one
    special thing:

        AS09:               : 62088f               aim     #$FF,,w
        HypAss:  420     82A4 62FF8F               aim     #$FF,,w

        AS09:               : 65ff8f               eim     #8,,w
        HypAss:  522     83BA 65088F               eim     #8,,w

    Another bug:
    cpx alias missing, tfr pcr,v/w/z missing
    illegal opcodes crash AS09!

    --

    The 6809 compatible object code section in this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS9 TER_2.0 V2.09


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6811
  HypAss 6811 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6811.hlst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_6811}

  USAGE:

    .CPU 6811 | 68HC11 | 68HC711 | 68HC811 [,TEST]


  FEATURES:

    Supports all 6811 addressing modes and opcodes.
    Is upward source/object code compatible to @{"6800" LINK CPU_6800} and @{"6801" LINK CPU_6801}.
    Use this library for 68HC11, 68HC711, 68HC811. The 'TEST' option enables
    the 'TEST' mnemonic ($00), which I have found in various assemblers
    except MotorolaFreeware. This mnemonic isn't documented in any HC11
    manual. So I guess this is nonstandard and should not be permitted for
    good. If this instruction appears in source code and the TEST switch is
    not activated you will get a 'forbidden opcode' error.


  COMPATIBLITY:

    The alternatives BHS, BLO, LSL, LSLA, LSLB are included.
    For old M6800RES MICBUG software, all accu A or B instructions
    may also have a register name applied to the base of the mnemonic:
    LSR A = LSRA,  STA A $FF = STAA $FF... Don't use for new source code !
    Supports the aliases  LDAD=LDD  STAD=STD  CMPD=CPD.
    The indexed addressing modes may also be forced to a zero offset if
    you apply e.g. ',x' without any offset value to the relating mnemonic.
    The bit manipulation operands may be separated by blanks OR by commas,
    the bit mask operands may be applied with a leading '#'.
    Supports the aliases  LDA=LDAA  STA=STAA.
    Keyword for HitAsm friends: HC11


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6811"}  @{" HypAss " LINK HSRC:cpu/6811.hsrc/main}  @{" AS11 " LINK HSRC:cpu/6811.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    Motorola freeware assembler AS11 TER_2.0 V2.09


  STRESS TEST:

    This library was tested by assembling about 130 files of the
    @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}, all files assembled without
    any mnemonic syntax incompatiblities. Other tested files were:
    mcx11,scixirq,talkers,buf32,div48,eeprogix,ffthc11,float,gmath,minibug.
    Of course I didn't change any bit to test, no text filtering used before.
    There were also no mnemonic problems. Because HypAss doesn't make such
    silly things like truncating operands if they don't fit, you will get an
    error if you assemble MCX11. MCX11 contains one signed negative
    calculation (line 866), that does not evaluate to a number that fits in
    an 8-bit operator. Put a '<' in front of the term and it works.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6816
  HypAss 6816 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6816.hlst/main}

  USAGE:

    .CPU 6816 | 68HC16


  FEATURES:

    Supports all 6816 addressing modes and opcodes.
    Use this library for 68HC16.


  COMPATIBLITY:

    This is a very early implementation yet, taken out a short description
    of this CPU. I have neither a full 1000-page manual of this CPU yet,
    nor huge examples to make compatiblity checks. Maybe time ore somebody
    will help.


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6816"}  @{" HypAss " LINK HSRC:cpu/6816.hsrc/main}  @{" SAsm " LINK HSRC:cpu/6816.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    SAsm R2.1V1.5 (c) Stan Burton

  WHO HAS THE BUG ?

    While I have compared the output of HypAss 6816's cpu lib to SAsm,
    I found  out that the brclr / brset instruction's relative offset
    is valid from $(FF)7F = -129 to $(00)7E = +126 , but usual branches
    support offsets from $(FF)80 = -128 to $(00)7F = +127.
    Is this a bug of SAsm, or is it a special thing with this CPU ?

    Another question is that these opcodes have a 16bit field for the offset,
    but they work just for 8bit offsets. Who can tell me ?

@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_16C5x
  HypAss 16C5x CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/16C5x.hlst/main}  @{"REF" LINK HSRC:cpu/16C5x.lst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_PIC}

  USAGE:

    .CPU 16C5x | 16C54 | 16C55 | 16C56 | 16C57 | 16C58 [,DEFW]


  FEATURES:

    Supports the complete PIC 16C5x family's 12 bit instruction set,
    as defined by Microchip®.


  COMPATIBLITY:

    The DEFW switch allows the assembly of source code written for picasm09,
    expecting the w register to be the default destination. By default the
    f register is the destination register. (as recommended by Microchip®)
    This is just support of a buggy assembler, don't use for new source code!


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/16C5X"}  @{" HypAss " LINK HSRC:cpu/16C5x.hsrc/main}  @{" MPASM " LINK HSRC:cpu/16C5x.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    MPASM 1.01 © Byte Craft Limited / Microchip technologies  (PC.exe)


    And somehow successfully by comparing it to:

    PICASM V 0.9ß (C) Tomas Beyer (beta buggy brogram) (in .p54 mode)

    While verifying the code I found out some bugs of PicAsm:

        The 'tris' instruction produces wrong opcodes:

        003Dh: (000Fh)            tris       0x7 ; should be $0007
        0042h: (000Fh)            tris       0x5 ; should be $0005

        All instructions that allow the selection of the destination
        register work wrong if no register name is applied to them (w/f):
        By default the w register is the default destination in picasm,
        while Microchip® recommends the f register to be the default
        destination register. If you want to assemble wrong sourcecode
        written for picasm you should use the DEFW switch to create ok code.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_16Cxx
  HypAss 16Cxx CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/16Cxx.hlst/main}  @{"REF" LINK HSRC:cpu/16Cxx.lst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_PIC}

  USAGE:

    .CPU 16Cxx | 16C64 | 16C71 | 16C74 | 16C84 [,DEFW]


  FEATURES:

    Supports the complete PIC 16Cxx family's 14 bit instruction set,
    as defined by Microchip®. Is upward source code compatible to @{"16C5x" LINK CPU_16C5x}.


  COMPATIBLITY:

    The DEFW switch allows the assembly of source code written for picasm09,
    expecting the w register to be the default destination. By default the
    f register is the destination register. (as recommended by Microchip®)
    This is just support of a buggy assembler, don't use for new source code!


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/16CXX"}  @{" HypAss " LINK HSRC:cpu/16Cxx.hsrc/main}  @{" MPASM " LINK HSRC:cpu/16Cxx.asm/main}

    The object code generated by this library was verified
    somehow successfully by comparing it to the output code of:

    MPASM 1.01 © Byte Craft Limited / Microchip technologies  (PC.exe)

    While verifying the code I found out a bug of MPASM (in p=16CXX mode):

        The 'call' and 'goto' instructions cut the MSB of the address.


    And somehow successfully by comparing it to:

    PICASM V 0.9ß (C) Tomas Beyer (beta buggy brogram) (in .p84 mode)

    While verifying the code I found out some bugs of PicAsm:

        The 'sublw' instruction can't be assembled and fails.
        The 'call' and 'goto' instructions fail if the address
        is greater than $FF.
        (No bug: The CLRW instruction creates $010C, Hypass $0100)

        All instructions that allow the selection of the destination
        register work wrong if no register name is applied to them (w/f):
        By default the w register is the default destination in picasm,
        while Microchip® recommends the f register to be the default
        destination register. If you want to assemble wrong sourcecode
        written for picasm you should use the DEFW switch to create ok code.

        In opposite to MPASM, picasm stores the words in reversal word
        ordering into the INHX file. I'm not sure if anything else than
        picpgm can use this.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_17Cxx
  HypAss 17Cxx CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/17Cxx.hlst/main}  @{"REF" LINK HSRC:cpu/17Cxx.lst/main}  @{" INCLUDES " LINK HASS:doc/-hinc.guide/HINC_PIC}

  USAGE:

    .CPU 17Cxx | 17C42 [,DEFW]


  FEATURES:

    Supports the complete PIC 17Cxx family's 16 bit instruction set, as
    defined by Microchip®. Is upward source code compatible to @{"16C5x" LINK CPU_16C5x} and
    @{"16Cxx" LINK CPU_16Cxx}, but the instructions 'CLRW', 'MOVF', 'RLF' and 'RRF' need to get
    emulated by the macro include file @{"pic/emu16" LINK HASS:pic/emu16.hinc/main}. Note that the emulation
    of the 'MOVF f,f' requires 2 words and 2 cycles. The 17Cxx CPU doesn't
    support the PIC16C5x instructions 'OPTION' and 'TRIS' any more. If you
    refer to any of these pseudos you will get a 'forbidden opcode' error.
    Microchip® warned of the usage of these instructions for future
    compatiblity. Now we have future, so we have to rewrite our sources.
    In opposite to 16Cxx the 17Cxx instruction 'CLRF' also supports the
    selection of the destination. For 16Cxx compatiblity the 'CLRF' default
    destination will be f even if the DEFW switch is used.


  COMPATIBLITY:

    The DEFW switch allows the assembly of source code written for picasm09,
    expecting the w register to be the default destination. By default the
    f register is the destination register. (as recommended by Microchip®)
    This is just support of a buggy assembler, don't use for new source code!


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/17CXX"}  @{" HypAss " LINK HSRC:cpu/17Cxx.hsrc/main}  @{" MPASM " LINK HSRC:cpu/17Cxx.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    MPASM 1.01 © Byte Craft Limited / Microchip technologies  (PC.exe)

    While verifying the code I found out a mistake in the 17Cxx manual:

        Document DS30073D-page 61 / CLRWDT:
            The 'Encoding' binary is wrong.
            Should be '0000 0000 0000 0100'


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_6502
  HypAss 6502 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/6502.hlst/main}  @{"REF" LINK HSRC:cpu/6502.lst/main}

  USAGE:

    .CPU 6502 | 6500 - 6507 | 6510 - 6515 | 8510


  FEATURES:

    Supports the complete standard NMOS R6500 instruction set,
    as defined by Rockwell®.


  COMPATIBLITY:

    Supports various aliases for instructions: BLT=BCC  BGE=BCS
    LSR A=LSR  ASL A=ASL  ROR A=ROR  ROL A=ROL  BRK #$XX
    Also implemented: CMA=CMP (WD®)  CPA=CMP (GTE®)  (don't use for new code)
    The immediate addressing mode may also be forced by a leading '=', not
    only by a '#'. (UN*X As6502 compatiblity, don't use for new code)
    Keywords for AS65 friends: R_STD | R6500 | R6501 | R6502 | R6511


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/6502"}  @{" HypAss " LINK HSRC:cpu/6502.hsrc/main}  @{" AS65 " LINK HSRC:cpu/6502.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    AS65 V2.3d © Thomas Lehmann  (pro R6502)

    XAss64 V1.0 © MagnaMedia, but written by Christian Krenner


  STRESS TEST:

    I successfully assembled a 250KB HyperSource database containing pure
    6502 code and verified the object output, seems 100% 6502 compatible.


  NOTE:

    I know there's a lot of "still C64 freaks" outside there.
    And as I can see there's still people programming raster interrupts,
    demos and stuff like that. If anybody wants to see support for illegal
    opcodes in an own 6510 library, then contact me, send me an example
    source containing all illegal mnemonics and a remark what should be the
    desired illegal opcode output! If you know aliases include them. If
    you know about differences in illegals between 6510 and 8510, tell me.

    I have written any kind of applications for C64. For example a multi-
    media BASIC and controlled 160,000 WATTS of light, 8bit resolution,
    additionally 16 slide projectors, insync to music, with a single C64,
    serially transmitting in interrupt, having still enough CPU performance
    to run my BASIC for realtime control.

    Another tricky stuff I have written was 8-channel software dimmer,
    NMI-locked to 100Hz powersupply zerocross, then I used CIA2 and wrote
    something like the timer.device today, sharing 1 timer to 16 different
    periodic events with an extreme fast sorting algorithm. This interrupt
    (22K) was controlled by a custom BASIC again and synced to a multitrack
    recorder (tascam 133-AV) and is today still running in a commercial
    audio-visual superlearning scool. They just need to buy 2nd hand C64's
    each year and 'fill them up'.

    The synchronous concept of the 65xx bus architecture and the interrupt-
    driven duo- or trio-tasking made things possible you could not realise
    in that way on other machines any more.

    But for this we have relocator,memory pools,ports,semaphores...........!
    I don't want to miss all these goodies any more.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_65SC02
  HypAss 65SC02 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/65SC02.hlst/main}  @{"REF" LINK HSRC:cpu/65SC02.lst/main}

  USAGE:

    .CPU 65SC02 - 65SC07 | 65SC12 - 65SC15 | 65SC102-65SC107 | 65SC112 |
                                                               65SC115

  FEATURES:

    Supports the complete 65SC02 instruction set.
    Is upward source/object code compatible to @{"6502" LINK CPU_6502}.
    Use this library for CMOS G65SCxx, G65SC1xx.
    Additional opcodes to @{"6502" LINK CPU_6502}:

        yyy ($xx)     yyy= adc, and, cmp, eor, lda, ora, sbc, sta.
        bra *+-xx
        bit #$xx  bit $xx,x  bit $xxxx,x
        inc  dec
        jmp ($xxxx,x)
        phx  phy  plx  ply
        stz $xx  stz $xx,x  stz $xxxx  stz $xxxx,x
        trb $xx  trb $xxxx
        tsb $xx  tsb $xxxx


  COMPATIBLITY:

    Supports various aliases for instructions: BLT=BCC  BGE=BCS  LSR A=LSR
    ASL A=ASL  ROR A=ROR  ROL A=ROL  BRK #$XX  DEC A=DEC  INC A=INC
    Also implemented: CMA=CMP (WD®)  CPA=CMP (GTE®) and INA=INC A, DEA=DEC A
    The immediate addressing mode may also be forced by a leading '=', not
    only by a '#'. (UN*X As6502 compatiblity, don't use for new code)


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/65SC02"}  @{" HypAss " LINK HSRC:cpu/65SC02.hsrc/main}  @{" AS65 " LINK HSRC:cpu/65SC02.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    AS65 V2.3d (C) Thomas Lehmann  (pro R65C02)


  STRESS TEST:

    I successfully assembled a 250KB HyperSource database containing pure
    6502 code and verified the object output, seems 100% 6502 compatible.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_65C00
  HypAss 65C00 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/65C00.hlst/main}  @{"REF" LINK HSRC:cpu/65C00.lst/main}

  USAGE:

    .CPU 65C00 | 65C01 | 65C10


  FEATURES:

    Supports the complete CMOS 65C00/21 instruction set,
    as defined by Rockwell®.
    Is upward source/object code compatible to @{"6502" LINK CPU_6502}.
    Additional opcodes to @{"6502" LINK CPU_6502}:

      also in @{"65SC02" LINK CPU_65SC02}:
        bra *+-xx
        phx  phy  plx  ply
      also in @{"65C02" LINK CPU_65C02}:
        bbr x,$xx,*
        bbs x,$xx,*
        rmb x,$xx
        smb x,$xx
      65C00 only:
        mul

  COMPATIBLITY:

    Supports various aliases for instructions: BLT=BCC  BGE=BCS  LSR A=LSR
    ASL A=ASL  ROR A=ROR  ROL A=ROL  BRK #$XX  DEC A=DEC  INC A=INC
    Also implemented: CMA=CMP (WD®)  CPA=CMP (GTE®)  (don't use for new code)
    The immediate addressing mode may also be forced by a leading '=', not
    only by a '#'. (UN*X As6502 compatiblity, don't use for new code)
    The bit addressing  instructions BBR, BBS, RMB, SMB may also apply the
    bit number within the mnemonic:  BBR 0,$xx,* = BBR0 $xx,* ....
    Don't use this feature for new source code.
    Keywords for AS65 friends: R65C00 | R65C01 | R65C10


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/65C00"}  @{" HypAss " LINK HSRC:cpu/65C00.hsrc/main}  @{" AS65 " LINK HSRC:cpu/65C00.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    AS65 V2.3d (C) Thomas Lehmann  (pro R65C00)

    While verifying the code I found out that AS65 allowes the opcodes
    named before in any processor selection, even for raw @{"6502" LINK CPU_6502} !?

    Another very hidden thing I found out, is that in every opcode line the
    special symbol '*' represents the program counter at the beginning of
    a line (before opcode), except for the bit relative addressing mode.
    This one uses the beginning of a line +2 !?, so branches get calculated
    wrong if they refer to '*'. This will nearly never appear, but it is
    an inconsequent assignment of '*' (only affects bbs and bbr):

        here's an example creating the largest possible offset ($80-$7F)

        bbs 7,$ff,*-127   ; is wrong, should be -125 for max neg offset !!!
        bbs 7,$ff,*+128   ; is wrong, should be +130 for max pos offset !!!
    aa  bbs 7,$ff,aa-125  ; ok
    bb  bbs 7,$ff,bb+130  ; ok
        bcc *-126         ; ok
        bcc *+129         ; ok
    cc  bcc cc-126        ; ok
    dd  bcc dd+129        ; ok


  STRESS TEST:

    I successfully assembled a 250KB HyperSource database containing pure
    6502 code and verified the object output, seems 100% 6502 compatible.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_65C02
  HypAss 65C02 CPU library  @{" OPCODE-LISTING " LINK HSRC:cpu/65C02.hlst/main}  @{"REF" LINK HSRC:cpu/65C02.lst/main}

  USAGE:

    .CPU 65C02 | 65C102 | 65C112


  FEATURES:

    Supports the complete CMOS R65C02 instruction set,
    as defined by Rockwell®.
    Is upward source/object code compatible to @{"6502" LINK CPU_6502}, @{"65SC02" LINK CPU_65SC02} and @{"65C00" LINK CPU_65C00}.
    Use this library for the original CMOS 65C02.
    Additional opcodes to @{"65SC02" LINK CPU_65SC02}:

        bbr x,$xx,*
        bbs x,$xx,*
        rmb x,$xx
        smb x,$xx


  COMPATIBLITY:

    Supports various aliases for instructions: BLT=BCC  BGE=BCS  LSR A=LSR
    ASL A=ASL  ROR A=ROR  ROL A=ROL  BRK #$XX  DEC A=DEC  INC A=INC
    Also implemented: CMA=CMP (WD®)  CPA=CMP (GTE®) and INA=INC A, DEA=DEC A
    The immediate addressing mode may also be forced by a leading '=', not
    only by a '#'. (UN*X As6502 compatiblity, don't use for new code)
    The bit addressing  instructions BBR, BBS, RMB, SMB may also apply the
    bit number within the mnemonic:  BBR 0,$xx,* = BBR0 $xx,* ....
    Don't use this feature for new source code.
    Keywords for AS65 friends: R65C02 | R65C102 | R65C112


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/65C02"}  @{" HypAss " LINK HSRC:cpu/65C02.hsrc/main}  @{" AS65 " LINK HSRC:cpu/65C02.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    AS65 V2.3d (C) Thomas Lehmann  (pro R65C02)

    While verifying the code I found out that AS65 allowes the opcodes
    named before in any processor selection, even for raw @{"6502" LINK CPU_6502} !?

    Another very hidden thing I found out, is that in every opcode line the
    special symbol '*' represents the program counter at the beginning of
    a line (before opcode), except for the bit relative addressing mode.
    This one uses the beginning of a line +2 !?, so branches get calculated
    wrong if they refer to '*'. This will nearly never appear, but it is
    an inconsequent assignment of '*' (only affects bbs and bbr):

        here's an example creating the largest possible offset ($80-$7F)

        bbs 7,$ff,*-127   ; is wrong, should be -125 for max neg offset !!!
        bbs 7,$ff,*+128   ; is wrong, should be +130 for max pos offset !!!
    aa  bbs 7,$ff,aa-125  ; ok
    bb  bbs 7,$ff,bb+130  ; ok
        bcc *-126         ; ok
        bcc *+129         ; ok
    cc  bcc cc-126        ; ok
    dd  bcc dd+129        ; ok


  STRESS TEST:

    I successfully assembled a 250KB HyperSource database containing pure
    6502 code and verified the object output, seems 100% 6502 compatible.


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_658xx
  HypAss 658xx CPU library   @{" OPCODE-LISTING " LINK HSRC:cpu/658xx.hlst/main}

  USAGE:

    .CPU 658xx | 65SC802 | 65SC816 [,A16] [,R16]


  FEATURES:

    Supports the complete 65SC802/65SC816 instruction set.
    Is upward source/object code compatible to @{"6502" LINK CPU_6502} and @{"65SC02" LINK CPU_65SC02}.
    Use this library for CMOS G65SC802, G65SC816, WD65C816.
    Direct page optimization is enabled by default. (For what should it be
    disabled?) Use '.PAGE' pseudo to set the direct page origin.

    The A16 switch sets accumulator size to 16-bit (8-bit by default).
    (affects adc, and, bit, cmp, eor, lda, ora, sbc in immediate mode).
    The R16 switch sets register size to 16-bit (8-bit by default).
    (affects ldx, ldy, cpx, cpy in immediate mode).
    The sep/rep instructions do not affect the code size yet, maybe I'll
    implement for compatiblity. (todo: library option)
    Set codesize by A16/R16 switch instead.

    Additional opcodes to @{"65SC02" LINK CPU_65SC02}:

            yyy= adc, and, cmp, eor, lda, ora, sbc, sta.
        yyy $xx,s  ($xx,s),y  [$xx]  [$xx],y  $xxxxxx  $xxxxxx,x
        brl *+-xxxx
        jsr ($xxxx,x)
        jsl $xxxxxx  jml $xxxxxx  jml ($xxxx)
        per *+-xxxx  pei ($xx)    pea $xxxx
        phd  phb  phk  pld  plb
        rtl
        tcs  tsc  tcd  tdc  txy  tyx
        wai  stp
        xba  xce
        rep #$xx       sep #$xx
        mvp #$xx,#$xx  mvn #$xx,#$xx


  COMPATIBLITY:

    Supports various aliases for instructions: BLT=BCC  BGE=BCS
    LSR A=LSR  ASL A=ASL  ROR A=ROR  ROL A=ROL  BRK #$XX  DEC A=DEC
    INC A=INC  TAS=TCS  TSA=TSC  TAD=TCD  TDA=TDC  SWA=XBA
    Also implemented: CMA=CMP (WD®)  CPA=CMP (GTE®) and INA=INC A, DEA=DEC A
    The immediate addressing mode may also be forced by a leading '=', not
    only by a '#'. (UN*X As6502 compatiblity, don't use for new code)
    The bit addressing  instructions BBR, BBS, RMB, SMB may also apply the
    bit number within the mnemonic:  BBR 0,$xx,* = BBR0 $xx,* ....
    Don't use this feature for new source code.


  NOTE:

    The direct page optimization used by this CPU is prelimary, and is not
    finished yet. It may still create phasing errors in forward references.
    If somebody makes extensive use of this library, please report me what
    are the problems and send me example material so I can fix it. Because
    I started my assembler programmer's life on R6502 CPU's this is also an
    important CPU for me, so I want to have this library be the same stable
    as for example the 68xx family. All predecessors libraries of this CPU
    work fine. Hopefully this one will do the same one day.


  REFERENCE:  @{" DOIT " SYSTEM " newshell from hsrc:cpu/658xx"}  @{" HypAss " LINK HSRC:cpu/658xx.hsrc/main}  @{" SNASM " LINK HSRC:cpu/658xx.asm/main}

    The object code generated by this library was verified
    successfully by comparing it to the output code of:

    SNASM v1.4 (C) 1993 by Infernal Byte Systems, INC.
          (renamed from SASM to SNASM, while there
           allready exists SASM by Stan Burton, sorry).

    While verifying the code I found out some bugs/missing features of SnAsm:

      todo:
       -8-bit operands applied to JMP/JSR instructions fail if not forced to
        absolute addressing mode by '!'. Automatical selection of absolute
        addressing mode, if direct mode doesn't exist would be a good thing.
       -Instructions ASL, LSR, ROL, ROR, DEC, INC only work in accumulator
        addressing mode if the operand is 'a'. For compatiblity it would be
        better if also the 'naked' instruction would force the accumulator
        addressing mode.
       -JSR, JMP don't force JSL, JML if the operand size requires 24bit,
        as recommended by GTE®. Should be implemented for compatiblity.
       -There's no symbol for the current PC in calculations (eg. '*')
       -BRK only supports immediate addressing mode and doesn't accept
        6502-typical inherent mode. Both versions should be allowed for
        compatiblity. ('BRK'=>$00 and 'BRK #$xx'=>$00xx)
       -CPA (alias for CMP) should be supported, as recommended by GTE®.
       -Are you sure that the missing instruction alias is called 'CMA'?
        I have GTE® 65SC8xx documentation saying 'CPA' = 'CMP a'.
        Maybe that's the onliest difference between the WesternDigital® and
        GTE® versions of the 658xx. Hihihi.
        I've implemented both 100% equal to 'CMP' instruction.
       -May you please change the name of your assembler to SnAsm ?
      bugs:
       -CPY $xx (direct addressing mode) creates wrong opcode!
        Creates $E4 (=CPX direct), but should be $C4.
       -TCS (inherent) creates wrong opcode!
        Creates $AB (=PLB inherent), but should be $1B.
       -TAS (inherent) =TCS creates wrong opcode!
        Creates $AB (=PLB inherent), but should be $1B.

  STRESS TEST:

    I successfully assembled a 250KB HyperSource database containing pure
    6502 code and verified the object output, seems 100% 6502 compatible.

    I need large 658xx example sources for testing puposes!


@ENDNODE
----------------------------------------------------------------------------
@NODE CPU_NONE
@NEXT CPU_NONE
  HypAss NONE CPU library

  USAGE:

    .CPU NONE


  FEATURES:

    Empty dummy library that supports neither any addressing modes nor
    any opcodes. This library was designed to avoid collisions between
    label/synbolnames and opcodes, e.g. in include files.
    This is the default CPU library loaded at the beginning of each pass!


  COMPATIBLITY:

    While this CPU library doesn't support neither instructions nor
    addressing modes it can't be compatible to anything.   ;)


  EXAMPLE:

    The PIC's 16C64, 16C71, 16C74, 16C84 support an opcode called 'OPTION',
    but they also have a register called 'OPTION'.
    Usually we would define the register location like this:

        OPTION = $01

    If we would have seleted the PIC CPU before we define the OPTION
    register, the assembler will detect the OPTION instruction, having
    one operand applied to it. While the option instruction doesn't allow
    an operand, you will get the error: 'Wrong number of operands'.

    Now the way it works:

        .CPU NONE
        OPTION = $01
        .CPU 16Cxx


@ENDNODE
----------------------------------------------------------------------------
@NODE THOUGHTS_ABOUT_CPUS
@PREV THOUGHTS_ABOUT_CPUS

    Thoughts about CPUs - a hightech good night story

        Note that I'm writing here in a foreign language, so try to
        read 'between' the mistakes. It should be no problem I guess.


        The best what COMMODORE ever could do was to buy AMIGA!
        The marketing was maybe not their goal, but I think this is just
        because of the fact that each scool and university depends somehow
        on In*el, without any precedence of quality or performance. Go in
        university's libraries and search for an 68040 manual. You will
        find 100 80x86 manuals before you find 1 68xxx manual. This is
        really strong classical conditioning of the customers of tomorrow.
        But if you open a laser printer, which needs performance to process
        P*stScript you will find 68xxx! Before PPC was born this was also
        common sense in RIP's (raster image processors), found in nearly
        any repro studio. I wonder why nobody ever thought of the reason why
        Ad*be, the inventor of P*stScript and the creator of Ph*toshop,
        started developing all their graphic processing algorithms on
        Mototola® based platforms. Something went wrong with human mind.

        I know there's systems you don't here any commercials about,
        (like Silic*nGraphics) but which have 250MHz CPU's since a century,
        but they don't even need to talk about. You just see them where
        it's necessary. (There's of course more, this is just an example)

        Has anybody ever compared the performance of a 100.- german marks
        CD player's DSP to the actual price for microprocessors?
        You get sick when you do it.

        I think the risc PPC is the right way. But maybe too expensive.
        The idea of the hardware manufactorers is to let the people pay the
        development of 'trying to crash the border of light speed', which
        will never work in material based systems (like our universe).

        As some people know, xtal went being accepted as real life.
        (It reproduces itself, it 'eats', and it heals istelf)
        While our hardware technology is horribly based on christal (silicon)
        there are really strong problems with the fact that christal lives.
        To route microchips in minimum size is no problem for our hightech-
        world (imagine they write bits with 3 atoms) but one problem is
        that the structure is *healing* again. (It's good that this doesn't
        happen to our lovely Amiga structures :) There are various ways
        they know to make christal synthetically old (e.g our CPU gets
        clocked by christal which was made synthetically old to keep it
        stable over long time.) I believe that christal is the same
        intelligent as human brain. We just don't have an information
        channel to communicate. We can see in nature, that symbiosis is
        a very stable form of life. So why not try to "talk" to christal
        and ask it if it may please be a CPU? This sounds maybe silly, but
        imagine what the DNS does! I have yet to see any reason why this
        happens. Our scientific way to describe this can be compared to
        describing how to program Amiga by knowing electricity got '+'
        and '-'. More we don't know yet. Russian scientists made very
        interesting experiments with peas. They built a very sensitive
        camera, which is able to resolute 1 photon per second. They moved
        in a totally dark place (I guess within a rock) and pointed this
        camera at a pea. Oh, it's emitting light! Now they made spectrum
        analyzes of the pea's emitted light, and found out that there was
        three resonance peaks within this spectrum. Two of them exactly with
        the frequency factor 3.14... (PI) to each other. This they knew
        from somewhere else: from cylindrical resonators, like for example
        organ pipes. So they tried to recalculate the size of that 'pipe',
        and they exacly got the size of the cylindrical helix of the DNS!!!
        This knowledge was totally based upon scientific experiments, but
        was not accepted in western world??? Next they killed the pea by
        poison, (poor pea) and the same light they could measure before
        (with the same spectrum) was emitted, but the intensity increased
        by the factor 20. This made them guess that DNS is able to memorize
        photons, and communicate by them. This *may* be an answer to the
        very old question how living cells communicate to each others. By
        light! We know from many examples what an important fact it is that
        we have light, not only to heat our planet, or to allow photo-
        synthesis. Why is light the border of our knowledge? RF-technicians
        know that modulation requires a higher carrier frequency than the
        information we want to modulate has. Fourrier found out it works
        with the factor 2. Electrons in electrical environment have about
        halve of light's speed. We could not 'modulate' at a higher
        frequency as relates of half of light's speed. This is the absolute
        border of our system. (And surely there exists other systems with
        other facts and new borders,although many people don't beleave that.)
        Could you imagine that a listnode knows what is outside Amiga? A
        programmer *may* know what happens inside Amiga, but never can Amiga
        know what happens inside the programmer. This has again something to
        do with modulation. Small things may modulate big things, but they
        NEVER can know that they do so.


        I beleave, that the future computers (if they would still be called
        like that) will run in 3-dimensional atomic configurable xtal.
        This configuration will not have anything to do with *logic*.
        I guess, that something similar to fuzzy, or more like the config
        of our parallel processing mind will be the 'instruction set'.
        We don't have caches or burst mode or memory any more, there will
        just be intelligent synaptical ports to the outside world, mostly
        by light. 'Cyber' is in my oppinion something that is good to be
        sold with PCs, but no serious interface technique. I guess that we
        will find out, that we just need 1 piece of xtal, no monitor, no
        mouse, no keyboard. The interface will just be our eyes looking at
        this xtal, due to the fact that our eyes are made of living cells,
        and for this they also emit light!
        And when I ask my personal intuition which xtal this may be, I get
        the answer: diamond. Has anybody ever thought why the egypts built
        tons of xtal within their pyramids,directly above the king's chamber?
        I am technician, electronic experienced, and I beleave in technique,
        but I also like to make scientific experiments at the border of our
        knowledge. I made lots of physical experiments with pyramids. And
        what I *know* is that they were built to catch gravicy. This can
        be checked by anybody, and can also be calculated by macros we know
        from RF-technique. But one thing I could not understand yet: They
        only do this if they are exactly 'parallel' to the north-south axis
        of our planet. It's shit I don't have access to moon, to verify if
        this phenomen relates to the gravicy of the object earth or to any
        object in general.


        The step we now do from CISC to RISC is somehow emulating instructs
        by atomic parts (68xxx also uses micro and nano code), why shouldn't
        it be possible to continue this principle until we reach atomic size.
        When I think of the fact that they write their names in atoms
        (although the electricity is still too expensive and the machinary
        too sizey to do it at home), I just think that it is at the moment
        a matter of money, not of knowledge.

        And if your name is Bill and you own the money, then you can buy
        away any knowledge.


            This text was written running WorkBench 96.    :)


@ENDNODE
