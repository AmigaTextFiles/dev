@DATABASE $VER: HypAss 1.0 Syntax.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
@NODE MAIN "HypAss Syntax overview"
@TOC hass:HypAss.guide/main
  HypAss syntax overview  @{" General Syntax info " link "HYPASS_SYNTAX_INFO"} *** READ THIS FIRST ***
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
                           (XASS: x=XAss64 2=As6502 6=ProfiAss64 t=TurboAss)
                           (MOTF: f=MotorolaFree 9=As09 h=HitAsm )
                           (MPIC: m=MpAsm p=PicAsm               )
               PC-control:
 .pm h9f 62xt  @{" .ORG                    " link "HYPASS_PSEUDO_ORG"             }  Define program counter
 ... h9f ....  @{" .CODE .DATA .RAM .AUTO  " link "HYPASS_PSEUDO_CODE"            }  Select 1 of 4 segments
 ... .9. ....  @{" .DIR                    " link "HYPASS_PSEUDO_DIR"             }  Set direct page address

               Assignments:
 .pm h9f 62xt  @{" .EQU                    " link "HYPASS_PSEUDO_EQU"             }  Define a symbol
 ..m h9. ....  @{" .SET                    " link "HYPASS_PSEUDO_SET"             }  Redefine a symbol
 ... ... ....  @{" .UNSET                  " link "HYPASS_PSEUDO_UNSET"           }  Unset redefinable label or symbol
 ... .9. ....  @{" .STRUCT .ENDSTRUCT      " link "HYPASS_PSEUDO_STRUCT"          }  Define symbols in structures

               Memory allocation:
 ..m h9f 62xt  @{" .BYTE                   " link "HYPASS_PSEUDO_BYTE"            }  Insert  8bit data
 ..m h9f 62xt  @{" .WORD                   " link "HYPASS_PSEUDO_WORD"            }  Insert 16bit data
 ... ... ....  @{" .TRIP                   " link "HYPASS_PSEUDO_TRIP"            }  Insert 24bit data
 ... .9. ....  @{" .LONG                   " link "HYPASS_PSEUDO_LONG"            }  Insert 32bit data
 ... ... .2..  @{" .RWORD                  " link "HYPASS_PSEUDO_RWORD"           }  Insert 16bit data reversal
 ... ... ....  @{" .RTRIP                  " link "HYPASS_PSEUDO_RTRIP"           }  Insert 24bit data reversal
 ... ... ....  @{" .RLONG                  " link "HYPASS_PSEUDO_RLONG"           }  Insert 32bit data reversal
 ... h9f 6.xt  @{" .ASCII                  " link "HYPASS_PSEUDO_ASCII"           }  Insert ASCII data
 ... ... ....  @{" .VERS                   " link "HYPASS_PSEUDO_VERS"            }  Insert ASCII version string
 ... h.f ..x.  @{" .BLOCK                  " link "HYPASS_PSEUDO_BLOCK"           }  Insert byte filled block
 ... h.. ..x.  @{" .WBLOCK                 " link "HYPASS_PSEUDO_WBLOCK"          }  Insert word filled block
 ... ... ....  @{" .LBLOCK                 " link "HYPASS_PSEUDO_LBLOCK"          }  Insert long word filled block
 ... h.f ....  @{" .ZERO                   " link "HYPASS_PSEUDO_ZERO"            }  Insert zero   block
 ... .9. ....  @{" .ALIGN                  " link "HYPASS_PSEUDO_ALIGN"           }  Insert modulo block
 ... .9. ....  @{" .NOP                    " link "HYPASS_PSEUDO_NOP"             }  Insert NOP    block
 ..m h9f ....  @{" .RMB                    " link "HYPASS_PSEUDO_RMB"             }  Reserve memory bytes
 ... h.. ....  @{" .RMW                    " link "HYPASS_PSEUDO_RMW"             }  Reserve memory words
 ... ... ....  @{" .RML                    " link "HYPASS_PSEUDO_RML"             }  Reserve memory long words

               Including:
 .pm .9f ..x.  @{" .INCLUDE                " link "HYPASS_PSEUDO_INCLUDE"         }  Include a source file
 ... ... ..x.  @{" .APPEND                 " link "HYPASS_PSEUDO_APPEND"          }  Append a source file
 ..m .9f ....  @{" .END                    " link "HYPASS_PSEUDO_END"             }  Terminate actual source file

               Conditional Assembly:
 ..m h9. 6.x.  @{" .IF   .ELSE .ENDIF      " link "HYPASS_PSEUDO_IF"              }  Assemble if defined and not zero
 ..m h.f ....  @{" .IFD  .IFND             " link "HYPASS_PSEUDO_IFD"             }  Assemble if label/symbol is defined
 ... h.. ....  @{" .IFEQ .IFNE .....       " link "HYPASS_PSEUDO_IFEQ"            }  Assemble if result meets condition
 ... ... ....  @{" .IFC  .IFNC             " link "HYPASS_PSEUDO_IFC"             }  Assemble if strings compare

               Macros:
 ..m ... ..x.  @{" .MACRO .ENDMACRO .MEXIT " link "HYPASS_PSEUDO_MACRO"           }  Define a macro

               Assembler control:
 ... ... ....  @{" .MODE                   " link "HYPASS_PSEUDO_MODE"            }  Choose HypAss assembly mode
 ... ... ....  @{" .CASE                   " link "HYPASS_PSEUDO_CASE"            }  Choose label+macro case
 ... ... ....  @{" .CONV                   " link "HYPASS_PSEUDO_CONV"            }  Create ASCII conversion table
 ..m ... ....  @{" .RADIX                  " link "HYPASS_PSEUDO_RADIX"           }  Set default numerical base
 ..m ... ....  @{" .FILLVALUE              " link "HYPASS_PSEUDO_FILLVALUE"       }  Set default fillvalue

               Library control:
 ... ... ....  @{" .SYN                    " link "HYPASS_PSEUDO_SYN"             }  Select assembler syntax
 ... ... ....  @{" .MATH                   " link "HYPASS_PSEUDO_MATH"            }  Select expression evaluator
 ..m h.. ....  @{" .CPU                    " link "HYPASS_PSEUDO_CPU"             }  Select processor type
 ... ... ....  @{" .OBJ                    " link "HYPASS_PSEUDO_OBJ"             }  Select object code format

               Listing control:
 .pm .9f .2..  @{" .LIST                   " link "HYPASS_PSEUDO_LIST"            }  Local listing control
 ..m ... ....  @{" .MLIST                  " link "HYPASS_PSEUDO_MLIST"           }  Macro listing control
 ..m .9f .2..    @{" .PAGE                 " link "HYPASS_PSEUDO_PAGE"            }  (Formfeed to listing)
 ..m ... ....    @{" .SPC                  " link "HYPASS_PSEUDO_SPC"             }  (Blank lines to listing)
 ..m ... ....    @{" .TITLE                " link "HYPASS_PSEUDO_TITLE"           }  (Specify listing page title)
 ..m ... ....    @{" .SUBTTL               " link "HYPASS_PSEUDO_SUBTTL"          }  (Specify listing sub title)
 ..m ... ....  @{" .INFO                   " link "HYPASS_PSEUDO_INFO"            }  Echo information text and data
 ..m ... ....  @{" .ERROR                  " link "HYPASS_PSEUDO_ERROR"           }  Create a custom error
 ... ... ....  @{" .FAIL                   " link "HYPASS_PSEUDO_FAIL"            }  Create a fatal  error

               Linker support:
 ... ... ....  @{" .IDENT                  " link "HYPASS_PSEUDO_IDENT"           }  Specify module name
 ... ... ....  @{" .IMPORT                 " link "HYPASS_PSEUDO_IMPORT"          }  Import label/symbol
 ... ... ....  @{" .EXPORT                 " link "HYPASS_PSEUDO_EXPORT"          }  Export label/symbol
 ... ... ....  @{" .INIT                   " link "HYPASS_PSEUDO_INIT"            }  Predefine label/symbol

               Dummies:
 ..m .9f 6a..  @{" IGNORED PSEUDOS         " link "HYPASS_PSEUDO_DUMMIES"         }  Dummy pseudos getting ignored


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_ORG
 .ORG  pseudo opcode

 .ORG <PC-value>

   Sets the actual program counter (PC) to the value of <PC-value>.
   It is illegal to place a labelname left to this pseudo.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLES:

   .ORG $c000
   .ORG 12*4096+256


 LIBRARY SPECIFICS:

   GENERAL:

      *= <PC-value>
      *=<PC-value>

        The '*=' pseudo is an alias for .ORG and doesn't require a white
        space as delimiter to the operand, what is against the usual global
        syntax conventions, but it is necessary for AS6502 and ProfiAss64
        compatiblity.


   XASS:

      .ORG  <PC-value>
      .BASE <PC-value> [,<new object filename>]

        XAss64 was able to create multiple object files, by offering a file-
        name as second argument to '.BASE', what is not possible with HypAss
        yet. I don't see a reason now. Use batch files to do things like
        that. If there are many people who really nead this feature I'll
        implement it one day. Currenty the object name gets ignored!

   MOTF:

      ORG <PC-value>

   MPIC:

      ORG <PC-value>

        A label applied to ORG will here be set to <PC-value> !!
        (currently not imlemented)

@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_CODE
 .CODE .DATA .RAM .AUTO  pseudo opcodes

 .CODE
 .DATA
 .RAM
 .AUTO

   Switch the assembler between four different program counters which each
   may have their own '.ORG' statements. These pseudos save and restore the
   actual program counter value, offering you flexible access to up to four
   different physical portions of memory space. Although the four segments
   get treated 100% identical in the current version of Hypass, you should
   use them for the physical areas they are intended to describe:
   (for future compatiblity)

        .CODE:     ROM program section
        .DATA:     ROM data section
        .RAM:      RAM data section
        .AUTO:     universal scratch PC

   For the highest flexibility of your source code you should define all
   used program counters of all used segments in the global data file or
   at the very beginning of your main source file. (See example)
   After all needed segments are defined you can swap between them whenever
   it is required, the buffer for each PC will store the last program
   counter position of the actual segment and restore the position of the
   activated one. At the beginning of each pass  the code segment gets
   activated. Note that all four PC's are uninitialised then, and if you
   try to create object bytes you will get an error then. Define your PC's
   before you acces them. Use the auto segment as a scratch PC that may be
   defined in every routine.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLES:

   .CODE
   .ORG $E000  ; set start of ROM program section
   .DATA
   .ORG $F800  ; set start of ROM data section
   .RAM
   .ORG $0000  ; set start of RAM


 LIBRARY SPECIFICS:

   XASS:

      .CODE
      .DATA
      .RAM
      .AUTO


   MOTF:

      CODE
      DATA
      BSS   ; (block storage segment)
      RAM   ; alias for BSS
      AUTO

      PSCT  ; program section       = CODE
      DSCT  ; data section          = DATA    TELL ME IF THESE ARE WRONG  !!!
      BSCT  ; block storage section = BSS


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_DIR
 .DIR  pseudo opcode

 .DIR <page-address>
 .DIR <page-number>

   Set address origin for direct page addressing (if supported by CPU).

   Some CPUs support direct page addressing (like 6309).
   This feature can speed up your code a lot, because the CPU just
   has to fetch the lowermost bits of an address.
   HypAss can handle direct page addressing, but you have to define what
   page you want to be the direct page. For this you have the '.DIR'
   pseudo opcode. You may either specify the <page-number>, then the value
   must be smaller than one page's size, or you may also specify the
   <page-address>, which must be a multiple of one page's size then.
   IF the <page-address> is not page aligned an error will occur.
   The size of one page depends on the selected CPU (defined in CPU libs,
   usually 256 bytes). If you use this pseudo for CPUs which don't support
   direct page optimization you will get warned. It is your job to set the
   direct page register of the relating CPU. '.DIR' will not output any
   code, it will just affect the addresses and the addressing mode of the
   generated opcodes following its call. The direct page address is reset
   to 0 at the beginning of each pass and whenever a new CPU gets loaded.


 EXAMPLES:

   .CPU 6309         ; 6309 page size = 256
   .DIR $FF00        ; .DIR $FF does the same
   ldbt cc.1,$FF22.6 ; $FF22 will just create address $22 in object file.


 LIBRARY SPECIFICS:

   MOTF:

      DIRECT <page-address>
      DIRECT <page-number>
      SETDP  <page-address>
      SETDP  <page-number>


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_EQU
 .EQU  pseudo opcode

 <symbolname> .EQU <symbol-value>

   Assigns the symbol <symbolname> to the value <symbol-value>.

   Every non-redefinable symbol can just be defined once. If you try it a
   second time an error will occur. <symbolname> is an alphanumerical name,
   up to 32 chars long. A symbolname must begin with a non numerical char.
   ( abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_. )
   From second to last char of the symbolname you may additionally use
   numerical characters. ( 0123456789$@ ) By default labelnames are case
   sensitive. (use .CASE pseudo to change)
   Symbols that end up in an '@' may be redefined! Note that redefinable
   symbols get defined both, in pass1 and pass2. While the symbol table gets
   created at the end of pass2, the most recent value of a redefinable
   symbol will be displayed. There's no phasing check for redefinables!
   NOTE: If you define a symbol referring to the value of another symbol
   make sure that the other symbol was defined before you refer to it !
   HypAss does not support forward references *here* (yet).
   You may also assign a 4-character string to a symbol. Just put the
   characters in double quotes and a 32 bit value will be the result.
   You don't need to use 4 chars, but if you use more than 4, the rest of
   them just gets shifted out of the 32 bit value. These characters also
   may contain ANSI C escape sequences and get converted if a translation
   table is active!


 EXAMPLES:

   mysymbol   .EQU $1000
   yoursymbol .EQU 32*12+mysymbol
   thissymbol .EQU 32
   ascsymbol  .EQU "ABCD"   ; 32 bit value


 LIBRARY SPECIFICS:

   XASS:

      <symbolname> .EQUAL <symbol-value>
      <symbolname> = <symbol-value>
      <symbolname> =<symbol-value>

        The '=' pseudo is an alias for .EQU and doesn't require a white
        space as delimiter to the operand, what is against the usual global
        syntax conventions, but it is necessary for AS6502 and ProfiAss64
        compatiblity.

   MOTF:

      <symbolname> EQU <symbol-value>
      <symbolname> =   <symbol-value>
      <symbolname> =  #<symbol-value>

   MPIC:

      <symbolname> EQU <symbol-value>


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_SET
 .SET pseudo opcode

 <symbolname> .SET <symbol-value>

   Sets the redefinable symbol <symbolname> to the value <symbol-value>.

   '.SET' defines/redefines the value of a redefinable symbol. If the symbol
   doesn't exist, it will be defined. You can only redefine symbols defined
   by '.SET'. If you try to redefine a label defined by its position in
   source code or a symbol defined by '.EQU' an error will occur.
   A symbolname must begin with a non numerical character.
   ( abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_. )
   From second to last char of the symbolname you may additionally use
   numerical characters. ( 0123456789$@ ) By default labelnames are case
   sensitive. (use .CASE pseudo to change)
   Redefinable symbols get defined both, in pass1 and pass2. While the
   symbol table gets created at the end of pass2, the most recent value of
   a redefinable symbol will be displayed. There's no phasing check for
   redefinable symbols! (impossible mission)
   NOTE: If you define a symbol referring to the value of another symbol
   make sure that the other symbol was defined before you refer to it !
   HypAss does not support forward references *here* (yet).
   You may also assign a 4-character string to a symbol. Just put the
   characters in double quotes and a 32 bit value will be the result.
   You don't need to use 4 chars, but if you use more than 4, the rest of
   them just gets shifted out of the 32 bit value. These characters also
   may contain ANSI C escape sequences and get converted if a translation
   table is active!


 EXAMPLES:

   mysymbol   .SET $1000    ; define
   mysymbol   .SET $33      ; redifine
   yoursymbol .SET $fffffff ; define, cause doesn't exist.
   ascsymbol  .SET "ABCD"   ; 32 bit value


 LIBRARY SPECIFICS:

   MOTF:

      <symbolname> SET  <symbol-value>
      <symbolname> SET #<symbol-value>

   MPIC:

      <symbolname> SET <symbol-value>


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_UNSET
 .UNSET pseudo opcode

 .UNSET <label/symbolname>

   Unsets a redefinable label or symbol.

   The '.UNSET' pseudo opcode makes an existing redefinable label or symbol
   undefined. This happens both, in pass1 and pass2, so it is safe to use
   it as often as you want. Normal labels and symbols (non-redefinables)
   would create phasing errors, so only redefinables are permitted here.
   A label or symbol that you have unset will also appear in the symtable
   file, but will be deactivated by a leading ';'. It will appear once each
   pass in the table and will show the most recent value in the moment you
   have unset it.

 EXAMPLE:

   mylab .SET $ff
   mylab .SET $60
   .UNSET mylab   ;
   .IFD mylab
     .ASC "This will not get assembled"
   .ENDIF


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_STRUCT
 .STRUCT pseudo opcode

 .STRUCT <structurename> [,<start-address>]
   [<labelname>[:]]
   [<labelname>[:]] .NULL [<symbolname>]
   [<labelname>[:]] .BYTE [<symbolname>]
   [<labelname>[:]] .WORD [<symbolname>]
   [<labelname>[:]] .TRIP [<symbolname>]
   [<labelname>[:]] .LONG [<symbolname>]
   [<labelname>[:]] .RMB  [<symbolname>],<bytes>
   [<labelname>[:]] .RMW  [<symbolname>],<words>
   [<labelname>[:]] .RML  [<symbolname>],<longwords>
   [<labelname>[:]] .RMB  <bytes>
   [<labelname>[:]] .RMW  <words>
   [<labelname>[:]] .RML  <longwords>
   [<labelname>[:]] .ALIGN <modulo>
 .ENDSTRUCT

   Define labels and/or symbols by their location within a structure.

   THIS SECTION IS PRELIMARY, AND IS SUBJECT TO CHANGE!.

   This is a powerful tool to define labels and symbols relative to their
   location within a structure, based upon the choosen <start-address> or
   to zero. Within a structure you may define symbols by using the pseudos
   named above to declare the size of each member of the structure.
   The symbol named in <symbolname> gets defined to the absolute address
   within the structure, before the element size gets added. The funny thing
   is that you may also define labels if you apply their name left to the
   entry size specifiers. At the end of a structure block a redefinable
   symbol with the name given in <structurename> will be defined or altered
   to the abolute SIZE OF the structure. This symbol was choosen redefinable,
   so you may declare structures repetitively e.g. within macros, without
   the need of unique <structurenames> for the structure SIZEOF.


 EXAMPLE:

   .STRUCT MYSTRUCT,$2000

     ; labels
     STRUCBOT:
     .ALIGN                 ; modulo 2
     NO_SPACE1   .NULL      ; 0 bytes
     BYTE_SPACE1 .BYTE      ; 1 byte
     WORD_SPACE1 .WORD      ; 2 bytes
     TRIP_SPACE1 .TRIP      ; 3 bytes
     LONG_SPACE1 .LONG      ; 4 bytes
     DLONGSPACE1 .RMB  8    ; any size

     ; symbols
     .ALIGN $4000           ; modulo
     .NULL NO_SPACE         ; 0 byte
     .BYTE BYTE_SPACE       ; 1 bytes
     .WORD WORD_SPACE       ; 2 bytes
     .TRIP TRIP_SPACE       ; 3 bytes
     .LONG LONG_SPACE       ; 4 bytes
     .RMB  DLONG_SPACE,8    ; any size

     .ALIGN  256

   .ENDSTRUCT


 LIBRARY SPECIFICS:

   MOTF:

      struct <structurename> [,<start-address>]
        label <symbolname>       ; 0 bytes
        db <symbolname>          ; 1 byte
        dw <symbolname>          ; 2 bytes
        dd <symbolname>          ; 4 bytes
        ds <symbolname>,<size>   ; any size
        ds <size>                ; any size
        align <modulo>           ; modulo
      end struct

      FCB,FDB... permitted


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_BYTE
 .BYTE  pseudo opcode

 .BYTE <byte-value> [,"<string>"] [,<byte-value>]....

   Inserts 8-bit <byte-values> in the object file

   This pseudo opcode allowes you to insert 8-bit <byte-values>,
   mixed up with ASCII character strings in the object code, up to 32
   elements at once. Each <byte-value> gets checked if is within a range
   from -$80 to +$FF. The length of the strings is only limited by the
   maximum size of one source line, which  can't be more than 256 chars.
   The strings may contain @{" ANSI C escape sequences " link hass:doc/-math.guide/ANSI_C_ESCAPE_SEQUENCES} and get converted if
   character conversion is enabled.

   NOTE: In some conversion tables there are two destination characters for
   one source ASCII char. (eg: PC's CR will create $0D,$0A)

   NOTE: While some CPUs require (long) word aligned opcodes (eg PIC's)
   you may disturb this by inserting byte aligned data. An error will
   occur if you try to define a label "between two adresses".


 EXAMPLES:

   .BYTE $10

   .BYTE 8*12,a-33,"What a nice feature\\n",0,22


 LIBRARY SPECIFICS:

   XASS:

      .BYTE <byte-value> [,"<string>"]....
      .BYT  <byte-value> [,"<string>"]....

   MOTF:

      FCB  <byte-value> [,"<string>"]....       ; (form constant bytes)
      DB   <byte-value> [,"<string>"]....       ; (declare bytes)
      DC   <byte-value> [,"<string>"]....       ; (declare constant)
      DC.B <byte-value> [,"<string>"]....       ; (declare constant bytes)
    [ FCC  <byte-value> [,"<string>"]....       ; (form constant characters) ]

        HitAsm handles FCB and FCC as if they are aliases for each others.
        It also accepts "'" as delimiter for strings, not only for a single
        character, what is none standard and currently not supported by me.
        Hopefully this will change in a future release of HitAsm.
        Use FCC if you want to have free selection of the delimiter
        surrounding your string, otherwise use double quotes (") !

   MPIC:

      DB  <byte-value> [,<byte-value>]....     ; (declare bytes)

        Will get aligned to modulo 2 if number of bytes is odd.
        (currently not implemented)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_WORD
 .WORD  pseudo opcode

 .WORD <word-value> [,<word-value>] [,<word-value>]....

   Inserts up to 32  16-bit <word-values> in the object file

   NOTE: While some CPUs require long word aligned opcodes (currently none)
   you may disturb this by inserting words. An error will occur then.

   The word ordering of the created
   object code depends on the activated CPU:

        65xx:  LSB,MSB
        68xx:  MSB,LSB
        63xx:  MSB,LSB
        PIC:   MSB,LSB


 EXAMPLES:

   .WORD $10FF

   .WORD 32*12,a-33,12*4096


 LIBRARY SPECIFICS:

   XASS:

      .WORD <word-value> [,<word-value>]....
      .WOR  <word-value> [,<word-value>]....

   MOTF:

      FDB  <word-value> [,<word-value>]....     ; (form double bytes)
      FCW  <word-value> [,<word-value>]....     ; (form constant words)
      DW   <word-value> [,<word-value>]....     ; (declare words)
      DC.W <word-value> [,<word-value>]....     ; (declare constant words)

   MPIC:

      data <word-value>,[,"<text_string>",...]
      DW   <word-value>,[,"<text_string>",...] ; (declare words)

        Will get aligned to modulo 2 if number of bytes is odd (string).
        (currently not implemented)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_TRIP
 .TRIP  pseudo opcode

 .TRIP <triple-value> [,<triple-value>] [,<triple-value>]....

   Inserts up to 32  24-bit <triple-values> in the object file

   NOTE: While some CPUs require (long) word aligned opcodes
   you may disturb this by inserting triples. An error will occur then.

   The word ordering of the created
   object code depends on the activated CPU:

        65xx:  LSB, ,MSB
        68xx:  MSB, ,LSB
        63xx:  MSB, ,LSB
        PIC:   MSB, ,LSB


 EXAMPLES:

   .TRIP $10FFDD

   .TRIP 32*12,a-33,12*4096


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_LONG
 .LONG  pseudo opcode

 .LONG <long-value> [,<long-value>] [,<long-value>]....

   Inserts up to 32  32-bit <long-values> in the object file

   The word ordering of the created
   object code depends on the activated CPU:

        65xx:  LSB, , ,MSB
        68xx:  MSB, , ,LSB
        63xx:  MSB, , ,LSB
        PIC:   MSB, , ,LSB


 EXAMPLES:

   .LONG $10FF756

   .LONG 32*12,a-33,4096*4096


 LIBRARY SPECIFICS:

   MOTF:

      DD  <long-value> [,<long-value>]....     ; (declare double words)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RWORD
 .RWORD  pseudo opcode

 .RWORD <word-value> [,<word-value>] [,<word-value>]....

   Inserts up to 32 16-bit <word-values> in the object file,
   ***IN REVERSAL WORD ORDER**.

   NOTE: While some CPUs require long word aligned opcodes
   you may disturb this by inserting words. An error will occur then.

   The REVERSAL word ordering of the created
   object code depends on the activated CPU:

        65xx: MSB,LSB  (usually: LSB,MSB)
        68xx: LSB,MSB  (usually: MSB,LSB)
        63xx: LSB,MSB  (usually: MSB,LSB)
        PIC:  LSB,MSB  (usually: MSB,LSB)


 EXAMPLES:

   .RWORD $10FF

   .RWORD 32*12,a-33,12*4096


 LIBRARY SPECIFICS:

   XASS:

      .DBYT <word-value> [,<word-value>]....


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RTRIP
 .RTRIP  pseudo opcode

 .RTRIP <triple-value> [,<triple-value>] [,<triple-value>]....

   Inserts up to 32  24-bit <triple-values> in the object file,
   ***IN REVERSAL WORD ORDER**.

   NOTE: While some CPUs require (long) word aligned opcodes
   you may disturb this by inserting triples. An error will occur then.

   The REVERSAL word ordering of the created
   object code depends on the activated CPU:

        65xx: MSB, ,LSB  (usually: LSB, ,MSB)
        68xx: LSB, ,MSB  (usually: MSB, ,LSB)
        63xx: LSB, ,MSB  (usually: MSB, ,LSB)
        PIC:  LSB, ,MSB  (usually: MSB, ,LSB)


 EXAMPLES:

   .RTRIP $10FFDD

   .RTRIP 32*12,a-33,12*4096


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RLONG
 .RLONG  pseudo opcode

 .RLONG <long-value> [,<long-value>] [,<long-value>]....

   Inserts up to 32  32-bit <long-values> in the object file.
   ***IN REVERSAL WORD ORDER**.

   The REVERSAL word ordering of the created
   object code depends on the activated CPU:

        65xx: MSB, , ,LSB  (usually: LSB, , ,MSB)
        68xx: LSB, , ,MSB  (usually: MSB, , ,LSB)
        63xx: LSB, , ,MSB  (usually: MSB, , ,LSB)
        PIC:  LSB, , ,MSB  (usually: MSB, , ,LSB)


 EXAMPLES:

   .RLONG $10FF756

   .RLONG 32*12,a-33,4096*4096


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_ASCII
 .ASCII  pseudo opcode

 .ASCII <delimiter><string><delimiter>

   Inserts ASCII <string> in the object file

   Your <string> may be as long as one source code line can stand it.
   The <delimiters> may be any ASCII char, but must not be used somewhere
   else in the string, otherwise the string will be cut off.
   Between the TWO <delimiters> there may appear any ASCII char except
   a zero byte. If character translation is enabled the whole string will
   be converted. The complete @{" ANSI C escape sequences " link hass:doc/-math.guide/ANSI_C_ESCAPE_SEQUENCES} may be used within
   an ASCII string, they will get converted too.

   NOTE: In some conversion tables there may be two destination characters
   for one source ASCII char. (eg: PC's "\\n" will create $0D,$0A)


 EXAMPLES:

   .ASCII "Hallo \\n"

   .ASCII "How are you ?\\n\\000"


 LIBRARY SPECIFICS:

   XASS:

     .ASCII "<string>"
     .ASC   "<string>"
     .TEXT  "<string>" ; turboasm

   MOTF:

     FCC <delimiter><string><delimiter>       ; (form constant characters)
     DB  "<string>"                           ; (declare bytes)
     FCB "<string>"                           ; (form constant bytes)

        Read more about in @{" .BYTE " link HYPASS_PSEUDO_BYTE}


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_VERS
 .VERS  pseudo opcode

 .VERS

   Inserts ASCII AmigaDOS® version string in the object file.

   The version string you have specified in the source file will be copied
   to the object file and terminated by a zero byte. If you didn't specify
   a version string, WHAT YOU SHOULD NEVER DO, then no byte will be inserted.
   Version strings never get converted, because their destination system is
   always Amiga! In the listing file there will appear an additional line
   showing the ASCII contents of the version string within brackets '[]',
   because the hex listing does not say a lot about the contents.The leading
   '$' sign will be stripped off not to confuse the Version command.

   You should have specified the version string in the first header line of
   the main node in your source like this:

*$VER: HypAss Syntax library doc V1.0 (19.7.96)

   (This is also the version string of this document) Note that the version
   string definition *must* start at the very beginning of the line, the
   'VER' must always be uppercase, otherwise the AmigaDos Version command
   will not find the string.

 EXAMPLE:

   .VERS ; inserts the string above, zero terminated, without leading '*'


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_BLOCK
 .BLOCK  pseudo opcode

 .BLOCK <byte-number> [,<fill-byte>]

   Inserts <byte-number> times <fill-byte> in the object file

   The maximum size of <byte-number> just depends on the address space
   of your destination CPU, be carefull. The <fill-byte> must be an 8-bit
   value. If no <fill-byte> is specified, the least significant byte of the
   default @{" FILLVALUE " link HYPASS_PSEUDO_FILLVALUE} will be used to fill the defined space.

   NOTE: While some CPUs require (long) word aligned opcodes you may disturb
   this by inserting bytes. An error will occur then?.


 EXAMPLES:

   .BLOCK 32768,$00  ; waste a 27512

   .BLOCK 256-<*,$FF ; for page alignment


 LIBRARY SPECIFICS:

   XASS:

      .BLOCK <block-size>, <fill-byte>

   MOTF:

      DCB   <block-size>, <fill-byte>      ; (declare constant block)
      DCB.B <block-size>, <fill-byte>      ; (declare constant block bytes)
      BLK   <block-size>, <fill-byte>      ; (block)
      BLK.B <block-size>, <fill-byte>      ; (block bytes)
      FILL  <fill-byte>,<block-size>

        IMPORTANT: FILL uses the operands vice versa!


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_WBLOCK
 .WBLOCK  pseudo opcode  (words block)

 .WBLOCK <word-number> [,<fill-word>]

   Inserts <word-number> times <fill-words> in the object file

   The maximum size of <word-number> just depends on the address space
   of your destination CPU, be carefull. The <fill-words> must be a 16-bit
   value. If no <fill-word> is specified, the least significant word of the
   default @{" FILLVALUE " link HYPASS_PSEUDO_FILLVALUE} will be used to fill the defined space.

   NOTE: While some CPUs require long word aligned opcodes you may disturb
   this by inserting words. An error will occur then?.

   The word ordering of the created
   object code depends on the activated CPU:

        65xx:  LSB,MSB
        68xx:  MSB,LSB
        63xx:  MSB,LSB
        PIC:   MSB,LSB


 EXAMPLES:

   .WBLOCK 16384,$FED2  ; waste an EPROM


 LIBRARY SPECIFICS:

   MOTF:

      DCB.W <word-number>, <fill-word>      ; (declare constant block words)
      BLK.W <word-number>, <fill-word>      ; (block words)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_LBLOCK
 .LBLOCK  pseudo opcode  (long words block)

 .LBLOCK <longword-number> [,<fill-longword>]

   Inserts <longword-number> times <fill-longword> in the object file

   The maximum size of <longword-number> just depends on the address space
   of your destination CPU, be carefull. If no <fill-longword> is specified,
   the default @{" FILLVALUE " link HYPASS_PSEUDO_FILLVALUE} will be used to fill the defined space.

   The word ordering of the created
   object code depends on the activated CPU:

        65xx:  LSB,,,MSB
        68xx:  MSB,,,LSB
        63xx:  MSB,,,LSB
        PIC:   MSB,,,LSB


 EXAMPLES:

   .WBLOCK 16384,$DD39FED2  ; waste an EPROM


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_ZERO
 .ZERO pseudo opcode

 .ZERO <byte-number>

   Inserts <byte-number> times a zero byte in the object file

   The maximum size of <byte-number> just depends on the address space of
   your destination CPU, be carefull.

   NOTE: While some CPUs require (long) word aligned opcodes you may disturb
   this by inserting bytes. An error will occur then?.


 EXAMPLES:

   .ZERO 32768

   .ZERO 256-<* ; for page alignment


 LIBRARY SPECIFICS:

   MOTF:

      ZMB <block-size>            ; (zero memory bytes)
      BSZ <block-size>            ; (block strore zeros)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_ALIGN
 .ALIGN pseudo opcode

 .ALIGN [<modulo>] [,<fillbyte>]

   Advances actual PC until it matches choosen <modulo>, and fills space
   with $FF by default, optionally with value specified by <fillbyte>.
   IF no operand is given, the PC will be expanded to word alignment, what
   means that zero or one byte with the value $ff will be inserted in the
   object file.


 EXAMPLES:

   .ALIGN        ; word alignment
   .ALIGN 4      ; long word alignment
   .ALIGN 256    ; page alignment


 LIBRARY SPECIFICS:

   MOTF:

      ALIGN [<modulo>]


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_NOP
 .NOP  pseudo opcode

 .NOP [<nop-number>]

   Inserts one or <nop-number> times NOP opcodes in the object file

   The maximum size of <nop-number> just depends on the address space
   of your destination CPU, be careful. Note that some CPUs have 16-bit
   NOP opcodes. The opcode for the NOP instruction and the number of bytes
   each NOP requires depends on the actually selected CPU library.
   You may also enable the direct substitution of any NOP mnemonic by this
   pseudo if you apply the NOP switch to your actual syntax library.


 EXAMPLES:

   .CPU 6502
   .NOP            ; insert $EA
   .NOP 8          ; insert $EA,$EA,$EA,$EA,$EA,$EA,$EA,$EA
   .CPU 6816
   .NOP 2          ; insert $274C,$274C

   .SYN motf,nop   ; enable nop substitution
   .CPU 6502
   NOP             ; insert $EA
   NOP 8           ; insert $EA,$EA,$EA,$EA,$EA,$EA,$EA,$EA


 LIBRARY SPECIFICS:

   MOTF:

     NOP [<amount>]  ; only if AS09 or NOP switch is set!

        Note that this is not compatible to original Motorola code, because
        inherent instructions may directly introduce comments, and comments
        are no good operands. That's the reason why this feature is not
        enabled by default.


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RMB
 .RMB pseudo opcode  (reserve memory bytes)

 .RMB <byte-number>

   Advances actual PC by <byte-number> BYTES without the need to store any
   byte in the object file. (Binary object formats require this anyway).

   The maximum size of <byte-number> just depends on the address space of
   your destination CPU, be carefull. This pseudo is useful to mark RAM
   locations as being the beginning of buffers, temporary tables, variables
   etc. If you create any kind of Hex object output, this pseudo causes the
   actual line to terminate, and begin a new line. If you create any kind of
   binary object file the reserved area will be padded by the least signifi-
   cant byte of the fillvalue, which may be changed by @{" .FILLVALUE " link HYPASS_PSEUDO_FILLVALUE}.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLES:

   .RMB 32768

   .RMB 256-<* ; for page alignment


 LIBRARY SPECIFICS:

   MOTF:

      RMB  <byte-number>            ; (reserve memory bytes)
      DS   <byte-number>            ; (declare space)
      DS.B <byte-number>            ; (declare space bytes)

   MPIC:

      RES  <byte-number>            ; (reserve memory)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RMW
 .RMW pseudo opcode  (reserve memory words)

 .RMW <word-number>

   Advances actual PC by <word-number> WORDS without the need to store any
   byte in the object file. (Binary object formats require this anyway).

   The maximum size of <word-number> just depends on the address space of
   your destination CPU, be carefull. This pseudo is useful to mark RAM
   locations as being the beginning of buffers, temporary tables, variables
   etc. If you create any kind of Hex object output, this pseudo causes the
   actual line to terminate, and begin a new line. If you create any kind of
   binary object file the reserved area will be padded by the least signifi-
   cant word of the fillvalue, which may be changed by @{" .FILLVALUE " link HYPASS_PSEUDO_FILLVALUE}.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLE:

   .RMW 16     ; advance PC by 32


 LIBRARY SPECIFICS:

   MOTF:

      DS.W  <word-number>           ; (declare space words)
      RMB.W <word-number>           ; (reserve memory bytes.words??)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RML
 .RML pseudo opcode  (reserve memory long words)

 .RML <longword-number>

   Advances actual PC by <longword-number> LONGWORDS without the need to
   store any byte in the object file. (Binary objects require this anyway).

   The maximum size of <longword-number> just depends on the address space
   of your destination CPU, be carefull. This pseudo is useful to mark RAM
   locations as being the beginning of buffers, temporary tables, variables
   etc. If you create any kind of Hex object output, this pseudo causes the
   actual line to terminate, and begin a new line. If you create any kind of
   binary object file the reserved area will be padded by the default fill-
   value, which may be changed by @{" .FILLVALUE " link HYPASS_PSEUDO_FILLVALUE}.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLE:

   .RML 16     ; advance PC by 64



 LIBRARY SPECIFICS:

   MOTF:

      DS.L  <word-number>           ; (declare space longwords)
      RMB.L <word-number>           ; (reserve memory bytes.longwords??)


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_INCLUDE
 .INCLUDE  pseudo opcode

 .INCLUDE ["]<include-filename>["]

   Assembles source code in <include-file> and returns then.

   Included files may contain symbol/label/macro definitions, macro calls,
   normal source code or character translation table definitions (Just as
   normal source code). <include-filename> must be a valid amigados filename,
   and may be surrounded by double quotes (") or, if it does't contain
   spaces, by nothing. Avoid spaces in amigados filenames! This is no mac,
   we have a shell! If no device name is specified the path 'hinc:' will be
   added, if no extension is given '.hinc' will be added automatically.
   This may be disabled using the @{" NAX/S shell argument " link hass:doc/-args.guide/SHELL_ARG_NAX}. Includes may be
   nested. (includes which include includes) The maximum nesting level is
   defined by your system memory only! Be careful.

   It is illegal to place a labelname left to '.INCLUDE'.

   NOTE:

    Include filenames should have the extension '.inc' and '.hinc',
    indicating weather they contain HyperSource© code or not.
    Put all your includes containing symbol definitions in subdirs of HINC:
    Put all your includes containing macros/source code in subdirs of HSRC:


 EXAMPLES:

   .INCLUDE "HINC:pic/17c42.hinc"

   .INCLUDE pic/17c42             ; does the same

   .INCLUDE 6811/HC11F1


 LIBRARY SPECIFICS:

   XASS:

      .INCLUDE "<include-filename>"
      .INCLUDE  <include-filename>

   MOTF:

      INCLUDE "<include-filename>"
      INCLUDE <<include-filename>>
      INCLUDE '<include-filename>'
      INCL    "<include-filename>"
      INCL    <<include-filename>>
      INCL    '<include-filename>'

   MPIC:

      INCLUDE "<include-filename>"
      INCLUDE <<include-filename>>


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_APPEND
 .APPEND  pseudo opcode

 .APPEND ["]<source-filename>["]

   Continues assembling source code in <source-file> and never returns

   This pseudo opcode could be very useful if you want to write header
   files for source code you don't want to modify for any reason.
   In the header file you may for example define external labels/symbols
   and syntax/cpu options. The file should end in and .APPEND pseudo,
   linking to the original source file to assemble. Header files should
   be HyperSource© files, having the extension '.hsrc' and should link
   to the original source file '.src'.

   <source-filename> must be a valid amigados filename, and may be
   surrounded by " " or, if it does't contain spaces by nothing.
   The path of the filename relates to the current directory of the
   process that calls HypAss. Avoid spaces in amigados filenames!

   It is illegal to place a labelname left to '.APPEND'.


 EXAMPLES:

   .APPEND "HSRC:test/test2.hsrc"

   .APPEND HSRC:test/part2.src


 LIBRARY SPECIFICS:

   XASS:

      .APPEND "HINC:pic/17c42.hinc"
      .APPEND HINC:pic/17c42.hinc


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_END
 .END  pseudo opcode

 .END [<start-adress>]

   Terminates actual source file.

   Wherever this pseudo appears, the actual source will be terminated, and
   if it is the main source, the whole assembly will be finished for this
   pass. If this pseudo appears in an include file, the include will be left,
   and assembly will continue in the line after the call of that include.
   You may specify a <start-adress>, which will be written in the S7/S8/S9
   record of your object file if you use a Motorola® S-Record format. For
   any other format this address will be ignored.

   '.END' may also be useful if you keep large documentations in your source
   file. You put your documentation at the end of your source and terminate
   assembler's part clean by using '.END' before. Everything past '.END' gets
   ignored. You don't need to introduce your comments by ';' there.


 EXAMPLES:

   .END myroutine
   this line will not be assembled any more.


 LIBRARY SPECIFICS:

   MOTF:

      END [<start-adress>]


   MPIC:

      END


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IF
 .IF - .ELSE - .ENDIF  pseudo opcodes  @{" XAss64 specific .IF " link XASS64_SPECIFIC_IF}

 .IF <expression>
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

   Assembles <source-code1> if result of <expression> is not zero,
   otherwise <source-code2> gets assembled. <source-code> can be any
   opcode or pseudo-opcode construnct. .IF-.ELSE-.ENDIF constructs may
   be nested, even with other conditionals. While <expression> does not
   fail on errors, you can also use it to check if symbols are defined
   or if terms can be calculated. An error within <expression> will result
   in zero.

   It is illegal to place a labelname left to .IF,.ELSE or .ENDIF.


 EXAMPLES:

   .IF mylabel      ; IF mylabel is defined and is not zero
     ....           ; then this gets assembled
   .ELSE
     ....           ; else this gets assembled
   .ENDIF


 LIBRARY SPECIFICS:

   XASS:

      ONLY IF XASS SWITCH SET !  SEE: @{" XAss64 specific .IF " link XASS64_SPECIFIC_IF}

      .IF <comparison-operator>, <first-expression>, <second-expression>
      .IF <boolean-operator>, <expression>
      .ELSE
      .ENDIF

      ONLY IF PASS SWITCH SET !

      .IF <expression>:<source-code>

        Assembles <source-code> if <expression> is not zero.
        The '.IF' pseudo is the onliest one which is not compatible to
        ProfiAss64, while ProfiAss may just forbid or permit the rest
        of the line after the '.IF' pseudo. New assemblers do not support
        multiple instructions in one single line any more, so I will not
        support this crazy way of conditionals.

   MOTF:

      IF <expression>
      ELSE
      ENDIF
      ENDC

   MPIC:

      IF <expression>
      ELSE
      ENDIF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IFD
 .IFD - .IFND  pseudo opcodes

 .IFD  <label/sybol-name>
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

   Assembles <source-code1> if <label/symbol> was defined before, otherwise
   <source-code2> gets assembled. '.IFND' works opposite. <source-code> can
   be any opcode or pseudo-opcode construnct. IF[N]D-ELSE-ENDIF constructs
   may be nested, even with other conditionals. The value of th named label
   or symbol doesn't get checked and will not affect the condition defined.

   It is illegal to place a labelname left to '.IF[N]D','.ELSE','.ENDIF'.


 EXAMPLES:

   .IFND mylabel    ; IF mylabel is NOT defined
     ....           ; then this gets assembled
   .ENDIF

   .IFD mylabel     ; IF mylabel is defined
     ....           ; then this gets assembled
   .ELSE
     ....           ; else this gets assembled
   .ENDIF


 LIBRARY SPECIFICS:

   MOTF:

     IFD  <label/symbolname>
     IFND <label/symbolname>
     ELSE
     ENDIF
     ENDC

   MPIC:

     IFDEF  <label/symbolname>
     IFNDEF <label/symbolname>
     ELSE
     ENDIF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IFEQ
 .IFEQ - .IFNE  pseudo opcodes
 .IFGT - .IFLT  pseudo opcodes
 .IFGE - .IFLE  pseudo opcodes

 .IFEQ  <expression>  ; if <expression> equals to zero
 .IFNE  <expression>  ; if <expression> is not equal to zero
 .IFGT  <expression>  ; if <expression> is greater than zero
 .IFLT  <expression>  ; if <expression> is less than zero
 .IFGE  <expression>  ; if <expression> is greater than or equal to zero
 .IFLE  <expression>  ; if <expression> is less than or equal to zero
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

   Assembles <source-code1> if condition is met, otherwise <source-code2>
   gets assembled. <source-code> can be any opcode or pseudo-opcode
   construnct. .IF**-.ELSE-.ENDIF constructs may be nested, even with other
   conditionals. While <expression> does not fail on errors, you can
   also use it to check if symbols are defined or if terms can be calculated.
   An error within <expression> will result in zero.

   It is illegal to place a labelname left to .IF**,.ELSE,.ENDIF.


 EXAMPLES:

   .IFEQ mylabel+1  ; IF mylabel+1 equals zero or is not defined
     ....           ; then this gets assembled
   .ENDIF

   .IFNE mylabel    ; IF mylabel is not zero and is defined
     ....           ; then this gets assembled
   .ELSE
     ....           ; else this gets assembled
   .ENDIF


 LIBRARY SPECIFICS:

   MOTF:

      IFEQ  <expression>
      IFNE  <expression>
      IFGT  <expression>
      IFLT  <expression>
      IFGE  <expression>
      IFLE  <expression>
      ELSE
      ENDIF
      ENDC


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IFC
 .IFC - .IFNC  pseudo opcodes

 .IFC  <string1>,<string2>
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

   Assembles <source-code1> if <string1> and <string2> do not differ,
   neither their lenght nor their characters (case sensitive), otherwise
   <source-code2> gets assembled. '.IFNC' works opposite. <string1> and
   <string2> may be surrounded by double quotes ("), other delimiters are
   currently forbidden. <source-code> can be any opcode or pseudo-opcode
   construnct. IF[N]C-ELSE-ENDIF constructs may be nested, even with other
   conditionals.

   It is illegal to place a labelname left to '.IF[N]C','.ELSE','.ENDIF'.


 EXAMPLES:

   .IFC hallo,hallo     ; strings are the same
     ....               ; this gets assembled.
   .ENDIF

   .IFNC hallo,hallo    ; strings are the same
     ....               ; this gets ignored.
   .ENDIF


 LIBRARY SPECIFICS:

   MOTF:

      IFC  <string1>,<string2>
      IFNC <string1>,<string2>
      ELSE
      ENDIF
      ENDC


@ENDNODE
----------------------------------------------------------------------------
@NODE XASS64_SPECIFIC_IF
* XAss64 SPECIFIC PSEUDO only enabled if XASS switch applied to XASS library!
 .IF  -  .ELSE  -  .ENDIF  pseudo opcodes

 These pseudos support the complete strange XAss64/Crossass64 conditional
 assembly syntax. Do not use for new code!

 1.Conditional assembly by comparison:
 -------------------------------------

 .IF <comparison-operator>, <first-expression>, <second-expression>
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

     Assembles <source-code1> if <first-expression> and <second-expression>
       relate to each other by <comparison-operator>,
       otherwise <source-code2> gets assembled.

   <source-code> can be any opcode or pseudo-opcode construnct.
   <comparison-operator> can be ONE of: (no combination)

           =  equal
           !  not equal
           >  greater than
           <  smaller than


 2.Conditional assembly by checking if expression can be calculated:
 -------------------------------------------------------------------

 .IF <boolean-operator>, <expression>
   <source-code1>
 .ELSE
   <source-code2>
 .ENDIF

   Assembles <source-code1> if <expression> can be calculated or not,
   depending on <boolean-operator>, otherwise <source-code2> gets
   assembled.

   <source-code> can be any opcode or pseudo-opcode construct.
   <boolean-operator> can be ONE of: (no combination)

           =  can be calculated
           !  can't be calculated


 EXAMPLES:

   .IF    !,label   ; => IF label is NOT defined
     ....
   .ENDIF

   .IF    =,32/0    ; => NEVER, because 32/0 can't be calculated
     ....
   .ENDIF

   .IF    <,a,32    ; => IF a < 32
     ....
   .ENDIF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_MACRO
 .MACRO  -  .ENDMACRO  -  .MEXIT  pseudo opcodes

 [<macro-name>] .MACRO [<macro-name>]
                  <source-code>
                  .MEXIT [<condition>]
                  <source-code>
                .ENDMACRO

   Defines the macro <macro-name> for later usage.

   <macro-name> may be specified either in the label field or as the first
   operand of the macro definition. You must specify a <macro-name>, other-
   wise an error will occur. The name in the label field overrides the name
   in the operand slot. Between '.MACRO' and '.ENDMACRO' you may use any
   mnemonic, pseudo opcode, macro call or another macro DEFINITION.
   You may even call yourself within a macro (recursion). Includes are
   permitted in macros, macros are permitted in includes!
   Macros MUST be defined before their first invocation, forward references
   to macros are not permitted. HypAss supports textual macro parameter
   substitution, what means that you may substitute any character, string,
   mnemonic, pseudo opcode or whatever may appear in a source line by macro
   parameters. After you have defined a macro you may invocate it in any
   macro nesting level by calling it as if it was a mnemonic. The operands
   applied to it get passed to the macro's textual substitution system, and
   will be inserted in your macro definition source lines.
   Within each macro we have the LOCAL symbol 'NARG', which represents the
   number of operands applied to the actual macro call. This number is
   independent of the size of each parameter. The macro parameters even get
   counted if they are of zero lenght. Example: Imagine you call the macro
   'test' like this: 'test ,,,' => NARG will count 4 empty operands here!
   A very powerfull directive is '.MEXIT', which only may be used within
   macros. It terminates the actually processed macro and returns to the
   point in source where this macro was called. Because this directive is
   mostly used in combination with conditional assembly, I thought it would
   be a good help to directly implememt an optional conditional operand.
   Whitout this operand '.MEXIT' works always, if you apply one, it will
   only work if the term doesn't evaluate to zero.
   Something important about recursion: HypAss has no limits for macro
   nesting depth, so be careful with recursive calls. HypAss will not crash,
   but you may easily run out of system memory, because the macrostack can
   explode to any size that fits in 32bit! I made hardcore tests with 5000
   (five thousand) levels deep nested infinite loop macro calls, which
   required 800,000 bytes of macrostack! (and another 16 bytes for the macro)
   To prevent HypAss from ending in an i-loop, the program may be aborted at
   any line by Ctrl-C, although this slows down a little.

   The way how macro parameters get used are syntax library specific. Each
   library has its own way to treat macros! So I'll describe this separately
   for each syntax library:

    .syn XASS [,*]

        The character introducing a macro parameter is a question mark (?),
        followed by ONE digit (0-9) choosing which parameter you want to
        insert here. The digit representing the first parameter is 0!
        Within macros, lables and symbols are local, so each macro can be
        called repetitively without any care of unique names. You may refer
        to global labels or symbols as well as to locals, but you may not
        define globals within a macro. HypAss will search for locals first,
        and if this was not successfully, it will watch out for globals.
        If you have name collisions between locals and globals, HypAss
        will not fail, just you can't reach the global ones then.

    .syn MOTF [,*] ; NOT IN MDOS!

        The character introducing a macro parameter is a backslash (\\),
        followed by ONE digit (1-9) choosing which parameter you want to
        insert here. The digit representing the first parameter is 1, the
        ninth parameter is accessed by '\\9'! The parameter '\\0' is
        reserved for the size tag availlable one day. Within macros, lables
        and symbols are global, so macros cannot be called repetitively
        without any care of unique names. For this we have the special
        pass parameter '\\@' which gets substituted by a string, unique
        for your actual macro call and invocation period. The substitution
        string contains 5 characters, for example: '_0101'. The first char
        is always an underscore, the next two characters represent the
        number of your macro definition, the last two characters represent
        an invocation counter for this macro. The signs are HEX, what is
        unusual. I have choosen this method to be able to identify pseudo-
        'local' labels and symbols easily by their macro name number and
        invocation period counter. This is a good help while debugging,
        because you can easyly identify your "locals" in the symbol table.
        The second reason to use this system is that the created strings
        always belong to one macro, even if you use conditionally nested
        macros and access to pseudo-local symbols after you return from
        another macro nesting level. (puhh..) Another special pass parameter
        is '\\#', which represents the same as '\\@' without a leading
        underscore. This may also be used to access your macro invocation
        counter, because this one is represented by the low byte in the hex
        number. Access your invocation counter by '<$\\#', what means 'the
        low byte of your hex unique macro index number'.

    .syn MOTF,MDOS

        This is a prehistorical macrosystem I have found in old sources
        from the @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}. These sources
        are more than 20 years old, but they still run for example on 68HC11
        micros. I don't know which assembler used this syntax, so I called
        it MDOS. This may be totally wrong, but it should just be a synonym
        to identify the syntax set. If anybody of the authors of the UG
        examples reads this, please tell me the name and revision number of
        the assemblers which required this kinda macro flavour. This syntax
        set has a macro pass parameter numbering system which differs
        totally from other Motorola® flavoured assemblers:
        The character introducing a macro parameter is a backslash (\\),
        followed by ONE digit (0-9) choosing which parameter you want to
        insert here. The digit representing the first parameter is 0, the
        tenth parameter is accessed by '\\9'!  Within macros, lables
        and symbols are global, so macros cannot be called repetitively
        without any care of unique names. For this we have the special
        pass parameter '\\.' which gets substituted by a string, unique
        for your actual macro call and invocation period. The substitution
        string contains 5 characters, for example: '_0101'. The first char
        is always an underscore, the next two characters represent the
        number of your macro definition, the last two characters represent
        an invocation counter for this macro. The signs are HEX, what is
        unusual. I have choosen this method to be able to identify pseudo-
        'local' labels and symbols easily by their macro name number and
        invocation period counter. This is a good help while debugging,
        because you can easyly identify your "locals" in the symbol table.
        The second reason to use this system is that the created strings
        always belong to one macro, even if you use conditionally nested
        macros and access to pseudo-local symbols after you return from
        another macro nesting level. (puhh..)


 LIBRARY SPECIFICS:

   XASS:                    (internal: macrosystem=1)

     .MACRO <macro-name> [,<macro-parms>]
       <source-code>
     .ENDMACRO

     A very special thing here is that you may declare the <macro-parms>,
     which you MUST apply at least to your macro. By default the number is 0.
     If the number of operands applied to your macro when invocating it is
     less than specified in the macro definition, you will get a 'missing
     macro parameter' error. Use ?0 to ?9 to access up to ten macro params.
     If you refer to an undefined macro parameter when invocating you will
     get a 'undefined macro parameter' error. Check NARG before you refer to
     optional macro parameters. Note that all labels and symbols within a
     macro are local here. Currently you can't define globals within a macro
     using this system.

   MOTF:                    (internal: macrosystem=2)

     <name> MACRO  [.......]           ; args get defined as strings
              <source-code>            ; refer to them by \\1 to \\9
            ENDM

   MPIC:                     CURRENTLY NOT IMPLEMENTED!

     <name> MACRO  [<arg>, ..., <arg>] ; args get defined as local symbols
              <source-code>            ; refer to them by name
              EXITM                    ; exit macro here
              <source-code>
            ENDM


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_MODE
 .MODE  pseudo opcode

 .MODE <keyword> [,<keyword>]

   This pseudo is reserved for future extension. Currently there's just
   only two assembly modes invented: NORM and SYMTAB.
   The SYMTAB switch is already implemented in every symtable file, but
   currently just gets ignored. In future this key will switch HypAss in
   a fast symbol table parser mode. Maybe subswitches will specify the
   symtable format to read.



@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_CASE
 .CASE  pseudo opcode

 .CASE <keyword>,<case> [,<keyword>,<flag>]

   By default labels, symbols and macros are case sensitive.
   This could be changed using the '.CASE' pseudo. '.CASE' can be used
   as often as you need it. You have to specify whoose case dependency
   you want to change by <keyword>, which can be one of: 'MAC' for macros
   and 'SYM' for labels and symbols. <case>=off says that the selected
   elements are case insensitive, <case>=on says they are case sensitive.
   (default at the beginning of each pass). Use this pseudo opcode to
   assemble dirty old source code, but don't use it for labels and symbols
   if you are writing new programs! This pseudo may be interesting for
   use with macros if you simulate opcodes by macros and if you want them
   to be the same case insensitive as originally implemented mnemonics.
   Be careful with the usage of this directive within your program! Whatever
   you define when case is insensitive will be forced to UpperCase by
   HypAss. Keep track of this if you refer to them when you switch back to
   case sensitive modes.

   SEE ALSO:  @{" CASE/K shell argument " link hass:doc/-args.guide/SHELL_ARG_CASE}


 EXAMPLES:

   .CASE MAC,OFF  ; switch macros case insensitive
   .CASE sym,on   ; switch labels + symbols case sensitive  (default)


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_CONV
 .CONV  pseudo opcode

 .CONV <first-char>, <last-char>, <new-value>
 .CONV <amiga-char>, <new-value>

   By default HypAss creates Amiga ASCII characters from strings (.ASCII)
   and chars in expressions (bla='a'). This character set isn't always
   supported by the destination system you programm for. For this HypAss
   has a character conversion table, which gets initialized to Amiga
   characters at the beginning of each pass. The table may be modified
   either char by char or whole arrays of chars with one call of '.CONV'

   If you want to modify a single <amiga-char>, you just have to give it
   a <new-value>. If you like to modify an array of chars, just define the
   <first-char> and the <last-char>, and give the <first-char> a <new-value>.
   The chars from <first-char> to <last-char> will be set by a counter
   starting with <new-value> and counting up by 1 each new char.

   If you apply a negative value to <new-value> the character will get
   disabled. If you refer to a disabled character an error will occur.

   <first-char> and <last-char> are 8 bit values ($00-$FF) where the second
   value needs to be the same or higher than the first one.
   <new-value> can be a 16bit integer (-1 to $FFFF) to allow the creation
   of two destination chars by one amiga char. (Usefull for \\n->\\r\\n)

   NOTE: You may use ASCII characters like 'A in all terms of this pseudo,
   but keep track of the fact that they get converted. It may be difficult
   in some case, because there's no way to reach unconverted ASCII chars!

   SEE ALSO:  @{" CONVERSION tables " link hass:doc/-hinc.guide/HINC_CONV}


 EXAMPLES:

   .CONV $0A,$0D0A   ; amiga LF to PC CRLF
   .CONV $20,-1      ; forbid space
   .CONV 'a','z','A' ; toupper()
   .CONV $00,$FF,$00 ; reset to default


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_RADIX
 .RADIX  pseudo opcode

 .RADIX     [ <value>  |  BIN | OCT | DEC | HEX ]

   Defines the default numerical base.
   By default the numerical base is set to the syntax library specific
   default value, which is mostly 10, at the beginning of each pass, what
   means that every number which doesn't have a prefix or suffix to identify
   its numerical base gets decoded as a decimal one (if default radix is 10).
   You may change this as often as you want by using the .RADIX pseudo. The
   operand can either be one of the four keywords named above, or a numerical
   value from 2 to 36 which must start with a digit. Note that a default
   radix greater then 10 disables some suffix base identifiers, a radix
   greater than 16 disables all suffix base id's. If you choose a radix
   greater than 16, "numbers" must have a leading digit to avoid misinter-
   preting it as a label/symbol name if the first char isaplha().

   NOTE: <value> gets interpreted with the radix that was specified before
   you called this pseudo. I will not permit recursive radix[radix[radix[]]]


 EXAMPLES:

   .RADIX 16
   .RADIX HEX


 LIBRARY SPECIFICS:

   MPIC:

     RADIX <HEX | DEC | OCT>


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_FILLVALUE
 .FILLVALUE  pseudo opcode

 .FILLVALUE     [ <value> ]

   Defines the default fillvalue.

   This value gets placed in unused locations in binary object files, mostly
   created by .RMB, .RMW or .ORG directives. Defaults to $FFFFFFFF, and is
   reset to this default at the beginning of each pass. This may be a 32bit
   value to allow long word aligned CPUs having their specific value. Most
   of the currently supported CPUs just use the lower byte of this value.
   You may use this directive as often as you want. The value specified here
   is also the default for all flavour of fill/block directives.

   SEE ALSO:  @{" About binary objects " link  hass:doc/-obj.guide/About_binary_objects}


 EXAMPLE:

   .FILLVALUE $FF


 LIBRARY SPECIFICS:

   MPIC:

     FILL <value>

     HypAss, in opposite to MPIC, does currently never fill unused spaces
     when creating hex object files!


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_SYN
 .SYN  pseudo opcode

 .SYN <syntax-class> [,<syntax-subset>] [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

   Defines the syntax set the pseudo opcodes relate to. Closes the current
   syntax library and opens the relating 'hass:libs/syn/syn_<class>.library'.
   '.SYN' can be used as often as you need it. If you use this pseudo within
   already existing source code, you should specify the <syntax-subset>, so
   HypAss can know which assembler you used. For new programs, you should
   only specify the <syntax-class>. Sometimes it may be necessary to change
   some syntax settings, what can be done by @{"<global synopts>" link HYPASS_SYN_OPTIONS}. All arguments
   of this pseudo opcode are case insensitive. By default the XASS syntax
   class is activated at the beginning of each pass, which is the resident
   one. In opposite to usual libraries HypAss just accepts syntax libs with
   exactly the required library version. This gets checked safely.

   SEE ALSO:  @{" general SYNTAX info " link "HYPASS_SYNTAX_INFO"}  @{" Shell argument SYN/K " link hass:doc/-args.guide/SHELL_ARG_SYN}

   IMPORTANT: Although HypAss is able to switch in realtime between syntax
   sets, [expression evaluators], and processor libraries, whenever you want,
   is it recommended not to change syntax between macro definition and macro
   invocation, because syntax selection influences the macro preprocessor.
   (It's also a little bit silly anyway). If you for some reason need to do
   syntax acrobatics like that, you should only use resident XASS class
   pseudos within the macro body, so they will be detected in any case.
   (Or should I also throw the pseudo hashtable on the macro stack?)


 EXAMPLES:

   .SYN MOTF,MOTF  ; enables the syntax of the motorola freeware assemblers.
   .SYN XASS,XASS  ; enables the syntax of XASS64 1.0


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_MATH
 .MATH  pseudo opcode

 .MATH <evaluator-name> [,<option>] [,<option>] ...

   THIS IS JUST RESERVED FOR FUTURE EXTENSION AND WITHOUT ANY EFFECT NOW!
   IN THE MOMENT WE JUST HAVE THE 'HYP' EVALUATOR, WHICH WAS DESIGNED TO
   'EAT' ANY NON FLOATING POINT TERMS.

   Defines the expression evaluator where the complete arithmetics and
   operand fetch is based on. Closes the current expression evaluator and
   opens the relating 'hass:libs/math/hyp_<name>.library'.
   The '.MATH' pseudo was implemeted for future compatiblity and currently
   gets ignored! There will also be a shell option math=*** in future.
   Don't ask me when. I don't guarantee for anything!
   Some math libraries support <options>. Both, <evaluator-name> and
   <options> are case insensitive. By default the 'HYP' math library is
   activated at the beginning of each pass. In opposite to usual libraries
   HypAss just accepts math libraries with exactly the required library
   version number. This gets checked safely.

   SEE ALSO:  @{" MATH libraries " link "HASS:doc/-MATH.guide/main"}  @{" Shell argument MATH/K " link hass:doc/-args.guide/SHELL_ARG_MATH}


 EXAMPLES:

   .MATH FFP,double ; double precision fast floating point support
   .MATH ANSI       ; ANSI C expression evaluator
   .MATH HYP        ; activates the builtin HypAss expression evaluator


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_CPU
 .CPU  pseudo opcode

 .CPU <cpu-name> [,<option>] [,<option>] ...

   Defines the CPU the mnemonics relate to. Closes the current CPU library
   and opens the relating 'hass:libs/cpu/cpu_<name>.library'. '.CPU' can be
   used as often as you need it. Some CPU libraries support <options>
   (eg. 6805 CMOS switch). Both, <object-name> and <options> are case
   insensitive. By default the 'none' CPU is activated at the beginning of
   each pass, giving you the chance to define labels or symbols with the
   same names as mnemonics of a cpu you will activate later. (A good example
   is the OPTION register / instruction of all PIC 16cxx family CPUs. )
   The easiest way is to define such labels or symbols beginning in column 0.
   In opposite to usual libraries HypAss just accepts cpu libs with
   exactly the required library version. This gets checked safely.
   Read the general information in the processor libraries description!!!

   SEE ALSO:  @{" PROCESSOR libraries " link "hass:doc/-CPU.guide/main"}  @{" Shell argument CPU/K " link hass:doc/-args.guide/SHELL_ARG_CPU}


 EXAMPLES:

   .CPU 6502
   .CPU 6805-J1,CMOS,MUL


 LIBRARY SPECIFICS:

   MOTF:

      PROCESSOR <cpu-name>
      PROC      <cpu-name>

   MPIC:

      PROCESSOR <cpu-name>

      LIST    p=<cpu-name> ; THIS DOES NOT WORK YET, USE 'PROCESSOR' !!!


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_OBJ
 .OBJ  pseudo opcode

 .OBJ <object-name> [,<option>] [,<option>] ...

   DEVELOPERS AREA, DISABLED YET! MAYBE IN FUTURE MULTIPLE OBJECT SUPPORT!

   Defines the object code format that will be created. Closes the current
   object library and opens the new 'hass:libs/obj/obj_<name>_wr.library'.
   The '.OBJ' pseudo was implemeted for developement and is not intended
   to be used in source code!  Use shell option obj=*** instead!
   Some object libraries support <options>. Both, <object-name> and <options>
   are case insensitive. By default the CBM object library is activated
   during startup. In opposite to usual libraries HypAss just accepts object
   libraries with exactly the required library version number. This gets
   checked safely.

   SEE ALSO:  @{" OBJECT libraries " link "HASS:doc/-OBJ.guide/main"}  @{" Shell argument OBJ/K " link hass:doc/-args.guide/SHELL_ARG_OBJ}


 EXAMPLES:

   .OBJ S19 ; Motorola® S-Record S19   16-bit-addr output format
   .OBJ HX8 ; Intel®-Hex INHX8M        16-bit-addr output format


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_LIST
 .LIST  pseudo opcode

 .LIST [ ON | OFF ]

   Local control to the object listing, if any.

   Sometimes it is not usefull to see any included file appear in the
   listing output, especially if your includes are tested well and will
   not change any more. (e.g. hardware includes ...) For this you have the
   .LIST pseudo, offering local control to enable or disable the listing
   output. You may apply the keywords 'ON' and 'OFF' to the .LIST pseudo,
   both are case insensitive. Note that this pseudo does not enable the
   output listing if you didn't do this by the 'LST' commandline option.
   I think it's not professional to put external options into a source
   file, for this you should use shell arguments and fix them in a make file
   if necessary. Listing control may be nested, so if you disabled the
   listing twice you also must reenable it twice to continue the listing.
   This feature is very useful e.g. in nested include files.  The listing
   enabling and disabling pseudo opcodes are not listed unless you specify
   the 'LLC' commandline switch (list list control).


 EXAMPLES:

   .LIST OFF ; disable
   ; this doesn't get listed
   .LIST ON  ; enable


 LIBRARY SPECIFICS:

   XASS:

      .LIST   ; enable
      .NLST   ; disable

   MOTF:

      OPT l     ; enable
      OPT nol   ; disable
      LIST      ; enable
      NOLIST    ; disable

   MPIC:

      LIST      ; enable
      NOLIST    ; disable


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_MLIST
 .MLIST  pseudo opcode

 .MLIST [ ON | OFF ]

   Local control to the macro expansion listing.

   Sometimes it is not usefull to see any used macro's whole body in the
   listing output, whenever it gets expanded, especially if your macros are
   tested well and will not change any more. (e.g. mnemonic emulation ...)
   For this you have the .MLIST pseudo, offering local control to enable or
   disable the listing of macro bodies while invocating. You may apply the
   keywords 'ON' and 'OFF' to the .MLIST pseudo, both are case insensitive.
   Note that this pseudo does not enable the output listing if you didn't do
   this by the 'LST' commandline option. I think it's not professional to
   put external options into a source file, for this you should use shell
   arguments and fix them in a make file if necessary.   Macro expansion
   listing control may be nested, so if you disabled the listing twice you
   also must reenable it twice to continue the listing. This feature is very
   useful e.g. in nested macros. The listing enabling and disabling pseudo
   opcodes are not listed unless you specify the 'LLC' commandline switch
   (list list control).


 EXAMPLES:

   .MLIST OFF ; disable
     bla      ; only the name of our macro 'bla' gets listed, not the body.
   .MLIST ON  ; enable
     bla      ; now the whole contents of macro 'bla' get listed


 LIBRARY SPECIFICS:

   MPIC:

      EXPAND    ; enable
      NOEXPAND  ; disable


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_PAGE
 .PAGE  pseudo opcode

 .PAGE ["<title>"]

   Insert form feed in listing file

   THIS PSEUDO CURRENTLY GETS IGNORED, BUT IS A RESERVED KEYWORD ANYWAY!

   The '.PAGE' pseudo was originally intended to insert a form feed in the
   listing file. While AmigaGuide® cannot handle form feeds (?!?), this
   pseudo currently just gets ignored. A title name, applied as an argument
   to .PAGE also gets ignored. This is a very old pseudo opcode and should
   not be used any more. I have implemented this pseudo opcode, because I
   plan an intelligent normal source to HyperSource© conversion feature,
   which should be able to know what are the old listing formatting pseudos.

   I also have to think about a good system to make the listings created by
   HypAss printable. I'm an assembler programmer now since the first day the
   Commodore® VC20 appeared in europe.germany.trier->konz, exactly since
   1.8.1983. But I think that printing out source code or listings is a
   total waste of material and hardware, so I'm really not sure if I should
   support this. Please give me a sign if you think opposite or if you have
   an idea how to solute this!


 EXAMPLES:

   .PAGE                       as6502
   .PAGE "blabla"              as6502


 LIBRARY SPECIFICS:

   XASS:

      .PAGE ["<title>"]

   MOTF:

      PAGE          ; just insert formfeed, no operand accepted
      PAGE <lines>  ; insert formfeed if <lines> don't fit in current page
                    ; operand ignored!

   MPIC:

      PAGE          ; just insert formfeed, no operand accepted


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_SPC
 .SPC  pseudo opcode

 .SPC [<expression>]

   Insert blank lines in the listing file

   The '.SPC' pseudo is intended to insert blank lines in the listing file.
   The number of lines may be specified by <expression>. This is a very old
   pseudo opcode and should not be used any more, because your source code
   is more readable if you insert blank lines there. Anyway, to make old
   proggies appear more readable in the listing file I have implemented this
   pseudo opcode. The second reason is, that I plan an intelligent normal
   source to HyperSource© conversion feature, which should be able to know
   what are the listing formatting pseudos.


 EXAMPLES:

   .SPC 10
   .SPC pagelen-lines


 LIBRARY SPECIFICS:

   MOTF:

      SPC [<expression>] ; gets ignored by original assemblers!

   MPIC:

      SPACE [<expression>]


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_TITLE
 .TITLE  pseudo opcode

 .TITLE ["<string>"]

   Specify title to be displayed on top of each listing file page

   THIS PSEUDO CURRENTLY GETS IGNORED, BUT IS A RESERVED KEYWORD ANYWAY!

   The .TITLE pseudo originally was intended to specify the program title
   <string> to be displayed on top of each listing page.
   This is a very old pseudo opcode and should not be used any more.
   I have implemented this pseudo opcode, because I plan an intelligent
   normal source to HyperSource© conversion feature, which should be able
   to know what are the old listing formatting pseudos.


 EXAMPLES:

   .TITLE "This is my first proggy"
   .TITLE "A new powerfull assembler"


 LIBRARY SPECIFICS:

   MOTF:

      TITLE "<string>" ; as09

   MPIC:

      TITLE "<string>"


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_SUBTTL
 .SUBTTL  pseudo opcode

 .SUBTTL ["<string>"]

   Specify subtitle to be displayed on top of each listing file page

   THIS PSEUDO CURRENTLY GETS IGNORED, BUT IS A RESERVED KEYWORD ANYWAY!

   The .SUBTTL pseudo originally was intended to specify the program sub
   title <string> to be displayed in an additional line on top of each
   listing file page.

   This is a very old pseudo opcode and should not be used any more.
   I have implemented this pseudo opcode, because I plan an intelligent
   normal source to HyperSource© conversion feature, which should be able
   to know what are the old listing formatting pseudos.


 EXAMPLES:

   .SUBTTL "(an old idea of Brian)"


 LIBRARY SPECIFICS:

   MPIC:

      SUBTITLE "<string>"


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_INFO
 .INFO  pseudo opcode

 .INFO "<string>" [,<expression>] [,<expression>]

   Echo an information text to the error channel without creating an error.

   You may echo an information text as if it was an error to the listing
   and/or the console, without creating any error. The <string> you apply
   to this pseudo may contain formatting sequences for up to 2 numerical
   <expressions>, that get inserted in your string. Currently the following
   formatting sequences are supported here:

        \\d      dec number     of 32-bit signed expression
        \\h      hex number     of 32-bit signed expression
        \\c      character      of 8-bit unsigned expression

   Additionally the full C-language-like formatting sequences are permitted
   here, I guess you know why.


 EXAMPLES:

   .INFO "Program lenght: $\\h bytes",*-start
   .INFO "OK, you get it"


 LIBRARY SPECIFICS:

   MPIC:

      MESSG "<string>"


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_ERROR
 .ERROR  pseudo opcode

 .ERROR "<string>" [,<expression>] [,<expression>]

   Throw an error text to the error channel and create an error.

   You may create a custom error to the listing and/or the console, creating
   a normal error, resulting in return code ERROR=10. The error will not
   break HypAss, but it will increment the error counter. The <string>
   you apply to this pseudo may contain formatting sequences for up to 2
   numerical <expressions>, which get inserted in your string. Currently
   the following formatting sequences are supported here:

        \\d      dec number     of 32-bit signed expression
        \\h      hex number     of 32-bit signed expression
        \\c      character      of 8-bit unsigned expression

   Additionally the full C-language-like formatting sequences are permitted
   here, I guess you know why.


 EXAMPLES:

   .ERROR "Illegal addressing mode"
   .ERROR "Wrong value \\c location $\\h",'A-1,*


 LIBRARY SPECIFICS:

 LIBRARY SPECIFICS:

    MPIC:

      ERROR "<string>"


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_FAIL
 .FAIL  pseudo opcode

 .FAIL "<string>" [,<expression>] [,<expression>]

   Throw one last error text to the error channel and break HypAss!.

   THIS PSEUDO SHOULD ONLY BE USED FOR UNUSUAL TESTING PURPOSES!

   You may create a custom fatal error that will directly break Hypass,
   resulting in return code FAIL=20. The <string> you apply to this pseudo
   may contain formatting sequences for up to 2 numerical <expressions>,
   which get inserted in your string. Currently the following formatting
   sequences are supported here:

        \\d      dec number     of 32-bit signed expression
        \\h      hex number     of 32-bit signed expression
        \\c      character      of 8-bit unsigned expression

   Additionally the full C-language-like formatting sequences are permitted
   here, I guess you know why.


 EXAMPLES:

   .FAIL "No chance to assemble !"
   .FAIL "Wrong value \\c location $\\h",'A-1,*


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IDENT
 .IDENT  pseudo opcode

 .IDENT ["]<module-name>["]

   Specify the module name for the linker.

   This directive is intended to specify the module name for relocatible,
   linkable object formats. If the destination format is S-Record instead,
   the <module-name> will be stored in the S0 record, if enabled. By default
   <module-name> will be the source filename without file extension.
   NOTE: HYPASS DOES NOT SUPPORT LINKABLE OBJECTS YET!


 EXAMPLES:

   .IDENT "Packer_core"
   .IDENT MAINPROG


 LIBRARY SPECIFICS:

   MOTF:

      IDNT  <module-name>
      TTL   <module-name>  ; not intended for relo?

      NAM   <module-name>  ; not intended for relo, but mapped to S-Record
      NAME  <module-name>  ; not intended for relo, but mapped to S-Record


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_IMPORT
 .IMPORT  pseudo opcode

 .IMPORT <label> [,<symbol>] [,<label>]

   Import labels and/or symbols for subsequent usage.

   This directive is intended for usage with linkable object formats. It
   imports label and/or symbol definitions from the linker at link time.
   This means that all specified labels and sybols do not have a defined
   value during assembly, but appear in the (linkable) object as relocatib-
   les, which get their values when the linker processes the object to an
   executable code. NOTE: HYPASS DOES NOT SUPPORT LINKABLE OBJECTS YET!


 EXAMPLES:

   .IMPORT mysymbol,yourlabel,hissymbol,herlabel
   .IMPORT ourlabel


 LIBRARY SPECIFICS:

   MOTF:

      XREF <label> [,<symbol>] [,<label>]


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_EXPORT
 .EXPORT  pseudo opcode

 .EXPORT <label> [,<symbol>] [,<label>]

   Export labels and/or symbols to the linker.

   This directive is intended for usage with linkable object formats. It
   exports already defined label and/or symbol definitions to be referred
   by the linker, when it processes the object to an executable code. The
   labels and symbols specified here get checked for their validity indepen-
   dent of the fact if you really create a linkable object or not.
   NOTE: Because HypAss does not support any linkable object format yet,
   these definitions currently get exported to NIL.  :)


 EXAMPLES:

   .EXPORT mysymbol,yourlabel,hissymbol,herlabel
   .EXPORT ourlabel


 LIBRARY SPECIFICS:

   MOTF:

      XDEF <label> [,<symbol>] [,<label>]


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_INIT
 .INIT  pseudo opcode

 <symbol> .INIT <value>

   Define symbol if object is no linkable format.

   With the help of this directive you may write source code which may be
   assembled both, to a linkable module or to a binary/hex type executable.
   How to use this? First you define the external labels and/or symbols by
   the @{" .IMPORT pseudo " link HYPASS_PSEUDO_IMPORT}, then you initialize them by this directive. If you
   now create an object of linkable type, the .INIT pseudo ops will just be
   ignored, but if your object is not linkable, all definitions will default
   to the values specified here. The syntax of this directive is same as the
   syntax of the @{" .EQU pseudo " link HYPASS_PSEUDO_EQU}.
   NOTE: HYPASS DOES NOT SUPPORT LINKABLE OBJECT FORMATS YET!


 EXAMPLES:

   .IMPORT mysymbol,yourlabel,hissymbol,herlabel
   mysymbol  .INIT $0100
   yourlabel .INIT $0103
   hissymbol .INIT $0105
   herlabel  .INIT $0106


 LIBRARY SPECIFICS:


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_PSEUDO_DUMMIES
@NEXT HYPASS_PSEUDO_DUMMIES
  IGNORED DUMMY PSEUDOS

  The following pseudo opcodes may appear in source code, but do not affect
  the created object code in any way. They will just get counted and
  the result can be read in the status information display of Hypass.
  Why count dummies? It may be that you get a foreign piece of source code,
  which contains label names that collide with dummy pseudo names, and
  therefore just get ignored. You can see with one look at the dummy counter
  that things like that didn't happen. Now if the number is not zero you may
  force a pass1 and pass2 error display of each detected dummy by setting
  the @{" DL/S shell argument " link hass:doc/-args.guide/SHELL_ARG_DL} (dummy list). You will then get an overview of
  all dummies in the "errors in pass1" section of the created listing file.


 LIBRARY SPECIFICS:

   XASS:

      .OPT           ; ProfiAss64  assembler options
      .STM           ; ProfiAss64
      .LST           ; ProfiAss64
      .SST           ; ProfiAss64
      .FIL           ; ProfiAss64
      .SYS <adr>     ; ProfiAss64  start 6502 prog
      .GOT <line>    ; ProfiAss64  basic goto line :)

   MOTF:

      NOOPT          ; As09  disable optimization
      OPT            ; As09  enable optimization

   MPIC:

      CBANK          ; MpAsm reserved future extension

    todo:
      CBLOCK    [<expr>]
      ENDC
      LOCAL     <label>[,<local>]
      CONSTANT  <label>[=<expr>,...,<label>[=<expr>] ]
      VARIABLE  <label>[=<expr>,...,<label>[=<expr>] ]
      WHILE <expr>
      ENDW
      #DEFINE <name> [<string>]
      #UNDEFINE <label>

@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYNTAX_INFO
@PREV HYPASS_SYNTAX_INFO
@NEXT HYPASS_SYNTAX_INFO
  HypAss syntax libraries *** READ INTRODUCTION BELOW THIS LIST FIRST ***.
    In the moment you may choose between these syntax sets:

        @{" .SYN XASS       " link HYPASS_SYN_XASS      }                       @{" Global syntax options " link HYPASS_SYN_OPTIONS}
        @{" .SYN XASSN      " link HYPASS_SYN_XASSN     }
        @{" .SYN XASS,XASS  " link HYPASS_SYN_XASS_XASS }  XAss64 1.0
        @{" .SYN XASS,AS02  " link HYPASS_SYN_XASS_AS02 }  As6502 5.0
        @{" .SYN XASS,PASS  " link HYPASS_SYN_XASS_PASS }  ProfiAss 64
        @{" .SYN XASS,TASS  " link HYPASS_SYN_XASS_TASS }  TurboAss 5.0

        @{" .SYN MOTF       " link HYPASS_SYN_MOTF      }
        @{" .SYN MOTF,MOTF  " link HYPASS_SYN_MOTF_MOTF }  Motorola freeware assemblers
        @{" .SYN MOTF,AS09  " link HYPASS_SYN_MOTF_AS09 }  As09   1.04
        @{" .SYN MOTF,HIT   " link HYPASS_SYN_MOTF_HIT  }  HitAsm 0.21
        @{" .SYN MOTF,MDOS  " link HYPASS_SYN_MOTF_MDOS }  Unknown old motorola macro assembler.

        @{" .SYN MPIC       " link HYPASS_SYN_MPIC      }
        @{" .SYN MPIC,MPASM " link HYPASS_SYN_MPIC_MPASM}  MpAsm  1.01  UNFINISHED!
        @{" .SYN MPIC,PICAS " link HYPASS_SYN_MPIC_PICAS}  PicAsm 0.9

        @{" .SYN CAZ        " link HYPASS_SYN_CAZ       }
        @{" .SYN CAZ,CAZ    " link HYPASS_SYN_CAZ_CAZ   }  CAZ    1.26ß


  INTRODUCTION:

    HypAss tries to be backward compatible to a lot of assemblers in Amiga,
    C64 and PC scene, and for this I decided to create a flexible library
    system, which offers access to different assembler specific syntax sets.
    The term 'syntax set' within this document represents a set of pseudo
    mnemonics or directives supported by an assembler, and the way to use it.
    There are lots of differences between assemblers, the most important one
    is the implemented, cpu-independant set of instructions for e.g. memory
    allocation, assembler control, including external files and so on.
    Another very specific thing is the way how an assembler handles macros.
    There exist various ways to define macros, to insert pass parameters and
    to invocate macros within different assemblers. Another point that
    differs significantly between assemblers is the way how mathematical
    terms get evaluated. All these things named now get represented by an
    assembler specific syntax set. You have to choose the syntax set you
    want to work with. For this we have the @{" .SYN pseudo opcode " link "HYPASS_PSEUDO_SYN"},
    which should introduce each source file you write.  I have grouped the
    supported assemblers in classes, implemented in currently four libraries,
    (to be continued), where each library may receive options to specify the
    assembler which should be emulated. If you don't specify syntax library
    options (what you should do in general) you will have all features of
    HypAss enabled there. Options should usually only be used for compatib-
    lity to already existing sources. Any new software should just specify
    the syntax class. Syntax classes are in the moment XASS,MOTF,MPIC,CAZ,
    which should (when they are finished) represent the manufactorers-styled
    sets of Rockwell®/Motorola®/Microchip®/Zilog® and any derivates which
    fit in there. (to be continued).

    This document describes all pseudo opcodes IN GENERAL using the XASS
    class as examples (because it is the resident one), and in a special
    corner of each pseudo description you find the library specific way to
    invocate the relating pseudo. I started making separate dox for each
    syntax set, but when the third assembler was implemented I stopped it.
    (imagine it would be 1.2MB syntax description now)

    The main idea of the HypAss syntax system is not to *adapt* any already
    existing sources because of incompatible syntax sets, but switch to the
    relating syntax set and start *programming* in an 100% unmodified error
    free program. (I made the experience that adapting source code is often
    making buggy programs out of 100% ok sources, then correct, correct...
    and after a long, unnecessary time maybe the programming may start.)
    Today nearly any hardware manufacturer has "freeware" support mail boxes,
    where one can suck tons of example sources for each CPU. Why invent the
    wheel twice, if there is 'common sense algorithm' support? (Although I
    did not make any use of this while programming yet:)
    While developing the 68xx support of HypAss I made for example extensive
    use of the Motorola® MUCBBS support box in Munich, mirrored to many other
    channels. Here I found megabytes of test sources. For this the 68xx
    support of HypAss is the most finfished one. So is the 65xx part, cause
    I have written megabytes of example sources myself in C64/Amiga times.


  FUTURE PLANS:

    I want you to give signs for more syntax classes and assemblers to be
    implemented. When the number of supported assemblers is big enough, I
    *maybe* make the syntax library structures official. (In the moment
    they still change too often), so everybody who is able to count, may
    help to increase the compatiblity. The math system will be disconnected
    one day, to be a slave library system to the syntax libraries. This
    will make the selection of your favourite needs very flexible, and will
    be one more step to an easy standard for an assembler description
    system.


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_OPTIONS
@PREV HYPASS_SYN_OPTIONS
@NEXT HYPASS_SYN_OPTIONS
  Global syntax library options

    Each syntax library may receive one or more of the following options.
    These options all represent features which are not compatible to every
    assembler, and for this are not enabled for good. It is important, that
    you first specify the syntax class (e.g.XASS), then the subset if any
    (e.g. AS02), and then the required option(s).

    Example: .syn XASS, AS02, NOP, Z2O


  AVAILLABLE OPTIONS:

    'NOP'  (map NOP to .NOP)

      Map all 'NOP' mnemonics in the source file to the @{" .NOP pseudo " link "HYPASS_PSEUDO_NOP"}, so it
      will be possible to insert mutiple nops with one 'NOP <number>' call.
      If not required for compatiblity (AS09) this option defaults to off.

    'S2C'  (space to introduce comments)

      Allow a white space to introduce comments in the operand slot. This
      switch enables the Motorola® typical way to introduce comments. It is
      always set in the MOTF syntax class. Wherever it is clear that no more
      operand may appear you may directly put comments, you just need one
      white space as delimiter. Be careful, this also cuts off anything past
      white space! For example: '.byte $ff, $ff, $ff'  will just insert the
      first byte then!

    'Z2O'  (zero to introduce octals)

      Allow octal numbers to be specified by a zero prefix. E.g. 0177.
      If not required for compatiblity (*) this option defaults to off.

    'X2H'  (x to introduce hex)  (funny option :-)  (eggs to introduce hacks)

      Allow hex numbers to be specified by a 'x' prefix.    E.g. x7ff.
      If not required for compatiblity (CAZ) this option defaults to off.

    'C2H'  (cross to introduce hex)

      Allow hex numbers to be specified by a '#' prefix.    E.g. #7ff.
      If not required for compatiblity (CAZ) this option defaults to off.



@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASS
@PREV HYPASS_SYN_XASS
  The XASS syntax class

  USAGE:

    .syn XASS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    This is the general XASS syntax class library. It will collect any
    Rockwell®-like syntax set derivates. I will include further assemblers
    which fit in here. If you find something, let me know, and send me the
    dox (no pirated material). Currently this is the default selection at
    the beginning of each pass of HypAss. It has its own stactic hashtable,
    getting constructed during startup of HypAss, whereas any other syntax
    classes own dynamic hashtables which get destructed and reconstructed
    whenever the .SYN directive is called in another than the XASS class.
    This system was used to fill 'holes' in the pseudo opcode sets of
    another class, because XASS has pseudos for any feature that exists in
    HypAss. This means, that you may even access pseudos from this class, if
    you are for example using the MPIC syntax class. Note that many settings
    within the syntax classes exclude each others. A good example is the
    default radix in constants. (we just have 1 radix :)

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASSN
  The XASSN syntax class

  USAGE:

    .syn XASSN [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    This syntax class has the same features as the @{" XASS " link HYPASS_SYN_XASS } syntax class, with
    the difference, that you need **NOT** specify a leading dot in front of
    each pseudo opcode. This one I made for all of you who don't like the
    'dotty' directive set, but would like to have access to all features of
    HypAss. Take this one. The name XASSN is a short form for 'XASS naked'
    or 'XASS nodot', you can choose what you prefer. This syntax class does
    not have any subsets within. It's pure without any assembler supported.
    It offers all directives which are listed in main page of the syntax
    library document, just nodot. One thing I had to disable: The 'NOP'
    directive will not be mapped by default. For this you may set the global
    'NOP' syntax option of this library, and the mnemonic will be mapped to
    the pseudo opcode.

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASS_XASS
  The XASS subset of the XASS syntax class

  USAGE:

    .syn XASS,XASS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with XAss64/CrossAss64
    V1.0 ©MagnaMedia®, written by Christian Krenner. The original can be
    found on @{"aminet/misc/amag/AM9411_6.lha." system "set1d:tools/Inspect set1d:aminet/misc/amag/AM9411_6.lha"}

    The original assembler has a very specific way to handle conditional
    assembly, the .IF pseudo will emulate this 'crazy' way of XAss64 to
    compare or to check if labels were defined. All other conditionals will
    react normal anyway. This library was tested entirely with halve a meg
    of source code that I have written for the original assembler. It seems
    to work perfect. I have tested a database of 47 include files,containing
    nested include files and macros, building a 32K kernal and compared the
    output to the original file successfully. I spent a lot of time in
    getting compatible, because this was my favourite assembler for 3 years
    now. Thanks, Christian!

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ XASS64
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ ON

  KNOWN PROBLEMS:

    For speed reasons I have not implemented the feature of XAss64, which
    allows you to shorten every pseudo opcodes (e.g. '.ascii' could by
    shortened to '.a'. Because HypAss has lots of pseudos, and every release
    there will be more, this would not safely represent the required pseudo
    in future. I've implemeted the short 3-char version of each original
    XAss64 pseudo, this should work. Additionally '.eq', cause I've used
    this myself. If some short pseudos are missing for your sources, use
    macros to simulate. If you are lucky, I will extend the preprocessor
    and include a '#define' directive next time, but no guarantee.


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASS_AS02
  The AS02 subset of the XASS syntax class

  USAGE:

    .syn XASS,AS02 [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with the portable UN*X
    cross assembler AS6502 5.0, written by J. H. Van Ornum, JHS, AT&T® Bell
    Laboratories, ported to the Amiga by Joel Swank. The original can be
    found on @{"aminet/dev/cross/As6502.lha." system "set1a:tools/inspect set1a:aminet/dev/cross/As6502.lha"}. The test source file supplied
    with this archive assembled proper.

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ ON
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ OFF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASS_PASS
  The PASS subset of the XASS syntax class

  USAGE:

    .syn XASS,PASS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with good old ProfiAss64
    © 1983 by Data Becker®. This was a commercial program in good old C64
    days and I programmed a hell of a lot of source with it. It can't be
    found anywhere officially now, as I know. (If this is not true, tell me
    the source one can get it!)

    Before Amiga was my favourite development tool, I used C64 to write
    operating systems for single board micros. I ported my sources to Amiga,
    using XAss64, because it has a very similar syntax. The main difference
    to C64 source was the line numbering used in BASIC, so I decided to make
    HypAss resistant against C64 typical line numbers in this configuration
    (1 to 5 digits, followed by one space). If you have used label names
    which collide with directives, you just need to delete this one space,
    and the label will get forced. Anyway, you have to list your sources to
    ASCII before, because HypAss doesn't convert old C64 BASIC tokens (yet?).

    How I didit in XAss64 times:

      For this I  successfully used bList 0.24 © by Daniel Kahlin, which can
      be found on @{"aminet/misc/emu/Over5_0_463.lha" system "set2b:tools/Inspect set2b:aminet/misc/emu/Over5_0_463.lha"}. The archive was replaced
      by a new version of Over5, containing bList 0.38 which ouputs '* ' in
      front of each line, so the created file could not be assembled without
      changes any more. :-(  The updated replaced archive is availlable on
      @{"aminet/misc/emu/Over5_0_711.lha." system "Set3a:tools/Inspect set3a:aminet/misc/emu/Over5_0_711.lha"}. Maybe the author will add a shell
      option to switch this feature.

    The easiest way I use now:

      Imagine you want to port old ProfiAss sourcefile "SYSTEM" to HypAss.
      (In these times file extensions were unusual) Run A64 emulator 3.xx
      demo (should be ok, you have 10 minutes).
      TYPE:                       don't type this:

        LOAD "SYSTEM",8           ; our C64 tokened source file
        OPEN 1,8,1,"SYSTEM.SRC"   ; our output filhandle
        CMD 1                     ; patch stdout there
        LIST                      ; list to stdout
        CLOSE 1                   ; close our filehandle

      That's all. Now you have a normal C64 ASCII listing on your harddisk,
      containing C64-typical $0D line termination and the C64 typical line
      numbering. We should not forget the prompt 'READY.' at the beginning
      and at the end of the file. But HypAss can nearly eat anything (I
      pumped DOpus through HypAss for stress test) so we can directly
      assemble the created file!

        Hass c64hd:system.src syn=xass,pass cpu=6502 obj=cbm mac

      The 'mac' switch we need to make HypAss know $0D termination. To be
      resistant against old C64 'READY.' prompt I made any labels ending in
      a dot '.' redefinable within this syntax set! So we will have a dummy
      label called 'READY.'!  :-O

      HypAss will report an error for the typical "SYS9*4096" call to enter
      ProfiAss, but these errors do not affect the object file. Just one
      thing you have to edit by hand: LDA #" " is currently just an error,
      cause HypAss uses ' as delimiter for chars. If there's a lot of reso-
      nance in this area I will implement automatical conversion in this
      syntax set.

      And if you modify this strange file you may mix up amiga lines with
      C64 bulbs of source! (Normally it's better to use a text filter to see
      what you modify, unless hypersource is finished)

      The listing file will anyway be a proper AmigaGuide file without line
      numbering, and without the need to change any single char.

      HISTORY: Befory I had HypAss I used the same trick with A64 to convert
      my sources to XASS64, but this one can't eat line nums, so I patched
      the C64 basic ROM running within the emulator not to call the $A613
      list-line-num routine :-)  In C64 times patching was usual programming
      technique, in Amiga times its incompetence (or MCP ;-).

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '.'
      Line numbering resistance_______ C64
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ ON

  KNOWN PROBLEMS:

    ProfiAss was able to 'eat' multiple statements in one line, as it was
    usual in C64 basic. Today all assembler don't accept stuff like that any
    more. This means that you have to modify any ':' which connected two
    elements in a line to a carriage return. A second thing is the very very
    special IF syntax, which I don't implement. It just was able to switch
    of anything in the same (multi-statement) line, what was usually a
    '.goto <line>' directive. I don't want to implement C64 Basic in HypAss,
    so you have to modify by hand!


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_XASS_TASS
  The TASS subset of the XASS syntax class

  USAGE:

    .syn XASS,TASS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with the unmodified C64
    TurboAssembler 5.0, by Wolfram Roemhild ???, just saw modified ripped
    versions yet, and a C64 doc about it. I own 2 programs written for this
    assembler and I read in the dox that it has 4 directives: *= $xxxx,
    .BYTE, .WORD and .TEXT. These are all imlemented ;-) The example code I
    own assembles fine. Contained line numbering, but modified versions of
    this assembler I have seen yet have a buitin editor, and save unreadable
    stuff. DEAR HACKERS! Send me docs (Amiga format) and tons of uncryptic
    ascii example source code if you want to see later macro versions of
    this assembler be implemented in HypAss! And send me the original
    working versions of this assembler and its flavours. I own 2 versions
    containing these prompts:

      xass v3.1+         TURBO ASS BY WOLFRAM ROEMHILD,
                         XMEM/LINK-ASS ROUTS BY TRON/FLT
                         IMPROVED BY FLT'ERS

      macro ass. v3.0    THIS VERSION OF TURBOASS MAC++
                         WAS MULTI DRIVE FIXED BY DOMIX /CLI
                         BASED`ON`THE`RSI VERSION BY ZC  OF`X-RATED
                         MACRO-ASS+++ MODIFIED BY DOMIX /CLI

    Both versions contain illegal opcodes and crash both, A64 and Frodo.
    I found these assemblers on the 'C64 sensations CD V1.0', the document
    about the original 5.0 version was written by a swedish hacking group.

  SYNTAX PROFILE:  (unfinished)

    GENERAL:
      Redefinables end in_____________ '.'
      Line numbering resistance_______ C64
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '?0'
     !Tenth macro parameter___________ '?9
      Unique label parameter__________ '?@'
      Unique number parameter_________ '?#'
      Local symbols in macros_________ ON
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MOTF
  The MOTF syntax class

  USAGE:

    .syn MOTF [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    This is the general MOTF syntax class library. It will collect any
    Motorola®-style syntax set derivates. I will include further assemblers
    which fit in here. If you find something, let me know, and send me the
    dox (no pirated material).

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ '\\0'
      First macro parameter___________ '\\1'
      Nineth macro parameter__________ '\\9
      Unique label parameter__________ '\\@'
      Unique number parameter_________ '\\#'
      Local symbols in macros_________ OFF
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MOTF_MOTF
  The MOTF subset of the MOTF syntax class

  USAGE:

    .syn MOTF,MOTF [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with the Motorola Free
    Ware Cross Assemblers release TER_2.0 V2.09 ©Motorola®, written by E.J.
    Rupp, modified by Terry E. Rogers. The originals are availlable on
    @{"aminet/dev/cross/MotFreeware.lha." system "set2c:tools/Inspect set2c:aminet/dev/cross/MotFreeware.lha"}. I have tested this library entirely
    with all 6800 assembler files of the @{" Motorola® Users Group Library " link hass:doc/ug.guide/main},
    120 files assembled without any errors.

    A lot of files there contain line numbering, so I have implemented an
    automatical detection of numericals in the label field. They get ignored
    up to column 8, where labels get detected properly, even if they have
    mnemonics' names. Another thing I found quite often was the old syntax
    'ASL A' or 'LDA A #$FF'. This works proper now with all 6800 compatible
    libraries, but for this the symbols 'A' and 'B' and 'X' are reserved now!

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ MOTO
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ '\\0'
      First macro parameter___________ '\\1'
      Nineth macro parameter__________ '\\9
      Unique label parameter__________ '\\@'
      Unique number parameter_________ '\\#'
      Local symbols in macros_________ OFF
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ OFF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MOTF_AS09
  The AS09 subset of the MOTF syntax class

  USAGE:

    .syn MOTF,AS09 [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with AS09, assembler
    for M6809/H6309 [1.04].Copyright Frank A. Vorstenbosch, Kingswood
    Software. Original is availlable on @{"aminet/dev/cross/as09_1_04.lha." system "set1a:tools/inspect set1a:aminet/dev/cross/as09_1_04.lha"}

    The test case supplied with As09 assembled fine, but I still have
    problems with forward references of forced addressing modes when
    direct page optimization is enabled in the 6809 and 6309 libraries.

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ ON
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ '\\0'
      First macro parameter___________ '\\1'
      Nineth macro parameter__________ '\\9
      Unique label parameter__________ '\\@'
      Unique number parameter_________ '\\#'
      Local symbols in macros_________ OFF
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MOTF_HIT
  The HIT subset of the MOTF syntax class

  USAGE:

    .syn MOTF,HIT [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with HitAsm Version 0.21,
    Hc11&Hc05 assembler, Copyright Richard Karlsson. The original can be
    found on @{"aminet/dev/cross/Hc11Dev1.lha" system "set1a:tools/inspect set1a:aminet/dev/cross/Hc11Dev1.lha"}

    In the moment it's not possible to introduce strings by single quotes,
    because this is none standard in Motorola-world. Gets implemented in
    future. Macro system implemented, but no local symbols availlable yet.

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ '\\0'
      First macro parameter___________ '\\1'
      Nineth macro parameter__________ '\\9
      Unique label parameter__________ '\\@'
      Unique number parameter_________ '\\#'
      Local symbols in macros_________ OFF
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ OFF


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MOTF_MDOS
  The MDOS subset of the MOTF syntax class

  USAGE:

    .syn MOTF,MDOS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with some old source code
    found in the @{" Motorola® Users Group Library " link hass:doc/ug.guide/main}. I don't know the name of
    the assembler which has this strange syntax. (Especially for macros).
    Maybe somebody can tell me. And may anybody tell me what is this:
    '\\0!.%01111111', '\\0!<%01111111', found in old MDOS user group files?

    A lot of files there contain line numbering, so I have implemented an
    automatical detection of numericals in the label field. They get ignored
    up to column 8, where labels get detected properly, even if they have
    mnemonics' names. Another thing I found quite often was the old syntax
    'ASL A' or 'LDA A #$FF'. This works proper now with all 6800 compatible
    libraries, but for this the symbols 'A' and 'B' and 'X' are reserved now!

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ MOTO
      Introduce comments by space_____ ON
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ '\\0'
      Nineth macro parameter__________ '\\9
      Unique label parameter__________ '\\.'
      Unique number parameter_________ '\\#'
      Local symbols in macros_________ OFF
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ < >
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MPIC
  The MPIC syntax class

  USAGE:

    .syn MPIC [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    This is the general MPIC syntax class library. It will collect any
    Microchip®-style syntax set derivates. I will include further assemblers
    which fit in here. If you find something, let me know, and send me the
    dox (no pirated material). The default radix was choosen 10 in the main
    class selection, although MPASM itself uses HEX default radix. If this
    would be the same with any further MPIC-style assembler, this would also
    change here. Use the .radix pseudo in any program until this is clear,
    so you are future compatible! You have been warned!

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ NONE
      Nineth macro parameter__________ NONE      UNFINISHED SECTION,
      Unique label parameter__________ NONE          DISABLED :-(
      Unique number parameter_________ NONE
      Local symbols in macros_________ NONE
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MPIC_MPASM
  The MPASM subset of the MPIC syntax class

  USAGE:

    .syn MPIC,MPASM [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be "backward" source code compatible with Microchip®'s MpAsm
    V1.01 © Byte Craft Ltd. & Microchip Technologies Inc. Note that this is
    just a very early start: No macros, not all directives, not tested yet!
    This assembler is mostly based on C-style syntax and has a preprocessor
    that seems to be C-compatible (not implemented yet) This is the most
    complex 8-bit assembler I've ever used, and I'm very far away from
    getting compatible to this monster, but I try my best. The expression
    evaluation is nearly finished, just 2 keywords are missing. If anybody
    has huge test sources for me please send them! (No pirated material!)

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ NONE
      Nineth macro parameter__________ NONE      UNFINISHED SECTION,
      Unique label parameter__________ NONE          DISABLED :-(
      Unique number parameter_________ NONE
      Local symbols in macros_________ NONE
    MATH:
      Default radix___________________ 16
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_MPIC_PICAS
  The PICAS subset of the MPIC syntax class

  USAGE:

    .syn MPIC,PICAS [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with PicAsm 0.9,
    © Tomas Beyer. This program has only few directives, but the archive
    includes a pretty nice PIC 16C84 programmer with a beautiful Gui.
    The original can be found on @{"aminet/dev/cross/pickit09.lha" system "set3d:tools/Inspect set3d:aminet/dev/cross/pickit09.lha"}.

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ NONE
      Nineth macro parameter__________ NONE      UNFINISHED SECTION,
      Unique label parameter__________ NONE          DISABLED :-(
      Unique number parameter_________ NONE
      Local symbols in macros_________ NONE
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ ON
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_CAZ
  The CAZ syntax class

  USAGE:

    .syn CAZ [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    This is the general CAZ syntax class library. It will collect any
    Zilog®-style syntax set derivates. I will include further assemblers
    which fit in here. If you find something, let me know, and send me the
    dox (no pirated material). In the moment there are no macros availlable
    in this syntax class, because I don't have any example how this may look
    like. I don't know any Zilog®-style macro assembler. Make me know some!

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ NONE
      Nineth macro parameter__________ NONE      UNKNOWN SECTION,
      Unique label parameter__________ NONE          DISABLED :-(
      Unique number parameter_________ NONE
      Local symbols in macros_________ NONE
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ OFF
      Introduce hex by #______________ OFF
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------
@NODE HYPASS_SYN_CAZ_CAZ
  The CAZ subset of the CAZ syntax class

  USAGE:

    .syn CAZ,CAZ [,@{"<global synopt>" link HYPASS_SYN_OPTIONS}]...

  FEATURES:

    Attempts to be backward source code compatible with CAZ 1.26ß, a Z80
    cross assembler written and © by Carsten Rose. The original can be found
    on @{"aminet/dev/cross/caz.lha" system "set1a:tools/inspect set1a:aminet/dev/cross/caz.lha"}. Although I didn't write a Z80 library yet,
    (in work?), did I include the syntax set for future compatiblity. There's
    no macro system yet, because I don't know how this would look like.
    Please contact me if you have an idea, and send me example sources to
    check if it works. (Only for testing purposes, will not be spread!)

  SYNTAX PROFILE:

    GENERAL:
      Redefinables end in_____________ '@'
      Line numbering resistance_______ OFF
      Introduce comments by space_____ OFF
      Map NOP to .NOP_________________ OFF
      Has special IF syntax___________ OFF
    MACROS:
      Name tag macro parameter________ NONE
      First macro parameter___________ NONE
      Nineth macro parameter__________ NONE      UNKNOWN SECTION,
      Unique label parameter__________ NONE          DISABLED :-(
      Unique number parameter_________ NONE
      Local symbols in macros_________ NONE
    MATH:
      Default radix___________________ 10
      Introduce octal by 0____________ OFF
      Introduce hex by x______________ ON
      Introduce hex by #______________ ON
      Shift operators_________________ << >>
      Math precedences________________ ON


@ENDNODE
----------------------------------------------------------------------------

