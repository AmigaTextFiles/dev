@DATABASE $VER: HypAss 1.0 Object.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
@NODE MAIN "HypAss Object libraries"
@TOC hass:HypAss.guide/main
  HypAss OBJ library overview  @{" General Object info " link "General_object_info"} *** READ THIS FIRST ***
  © 1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED

  BIN:  @{"   RAW   " LINK OBJ_RAW    }  raw binary image        <4GB
        @{"   CBM   " LINK OBJ_CBM    }  Commodore® load file    <64KB
        @{"   BOO   " LINK OBJ_BOO    }  68HC11 boot file        >=257

  HEX:  @{"   HX8   " LINK OBJ_HX8    }  Intel® Hex Format HX8M  <64KB
        @{"   H32   " LINK OBJ_H32    }  Intel® Hex Format HX32  <4GB

        @{"   MOS   " LINK OBJ_MOS    }  MOS® Hex Format         <64KB

        @{"   S19   " LINK OBJ_S19    }  Motorola® S-Record S19  <64KB
        @{"   S28   " LINK OBJ_S28    }  Motorola® S-Record S28  <16MB
        @{"   S37   " LINK OBJ_S37    }  Motorola® S-Record S37  <4GB

        @{"   TEK   " LINK OBJ_TEK    }  Tektronix® Hex Format   <64KB


@ENDNODE
----------------------------------------------------------------------------
@NODE General_object_info
@PREV General_object_info
@NEXT General_object_info
  HypAss General Object info

  INTRODUCTION:

    The job of an assembler is not only to eat sources and understand the
    contents, no, it should also create something we can use, what we call
    object ;-)  As in any sections described now, there exist also here many
    differences between the object outputs of assemblers. Nearly any CPU
    manufactorer defined its own object format, and the PROMMER industry
    follows these definitions. Professional programmers mostly accept any
    object format, but there exist also lots of prommers which just accept
    one single format. For this HypAss supports various object formats to
    allow access to a large scale of programmers, or even be able to manage
    the data with low cost methods.

    SEE ALSO:  @{" Amiga hardware programming projects " link AMIGA_HARDWARE_PROGRAMMING_PROJECTS}


  IMPORTANT:

    The object libraries are very beta. Some object libraries are not tested
    well yet. They all seem to work, but don't expect them to be resistant
    against stupid experiments or mistakes.(maybe they are, but no guarantee)
    Some described object formats or options have not been implemented yet.
    The next release will contain some news in this area. It would be very
    nice to hear some positive on negative statements about any of the hex
    type object formats, because for most of them I have not the chance to
    test them. If you know a software, which works well and can read many
    formats, please send me, so I can make better tests.


  FUTURE PLANS:

    -more object formats.
    -linkable object formats: Dear authors of already existing linkers for
    any CPU, please send me dox about the object format, even AmigaDos!
    -Prommer library system a la xpr, to directly feed the object where it
    was made for. Contact all constructors of any Amiga PROMmer project to
    develop together one standard programmer to burn anything that exists.
    I would route a professional PCB, if there's resonance, to have just one
    single hardware connected for ever, with directly feeding the printer if
    hardware disabled. Protected (sensitive!) parallel port is a 'must'.
    There's a lot of Amiga hardware projects running, to program some chips
    by Amiga. But currently only EPROMS, 68HC11 and PIC16C84. All these
    projects reside near each others and it seems as if they don't know
    anything of each others. Last is a waste of manpower.


@ENDNODE
----------------------------------------------------------------------------
@NODE About_binary_objects
@PREV About_binary_objects
@NEXT About_binary_objects
  About binary objects

    If you choose a binary object format you have to care of some things,
    which are different to hex-type formats:

    A binary object is nearly always an image having a start address and an
    end address, and necessarily all addresses between. This means, that all
    addresses between are present, If we use them or not.

    HypAss supports some features from assemblers which only create hex
    objects. A hex object is 'random access', what means that it may contain
    any mixture of data hunks which fit in its supported address space.
    Unused spaces between do not exist in the object file, but get filled by
    e.g. the prommer using this data. But if you choose a binary object
    format the unused spaces between these hunks get filled before the file
    gets created.

    This fact needs some care within programs:

        The ORG directive should only be used to raise the program counter,
        because it will then fill the unused space between with the default
        fillbyte. Descending program counter modifications are not permitted
        when creating a binary image! (You get an error)

        You should only use ONE (initialized) segment to create data within!
        Switching between multiple initialized segments would only be per-
        mitted if this would never decrease the program counter, what is
        silly, because there are better ways to reserve the space then.

        The RMB and RMW directives do not reserve but waste (fill) memory
        within initialized segments when creating a binary object. Take care
        of this fact.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_OPTIONS
@PREV OBJ_OPTIONS
@NEXT OBJ_OPTIONS
  Global object options

    NOTE: OBJECT SPLITTING IS NOT IMPLEMENTED YET!

    Each object library may receive options to split the created data into
    parts to use multiple EPROMS. For example: You build a computer having
    a full 32-bit bus architecture (e.g.68020). Now it is very difficult or
    impossible to get 32-bit EPROMs. So you may use 2 sparate 16-bit EPROMs,
    each one containing halve of your data. For this you need two separate
    object files, representing the lower and upper word of the 32-bit bus.
    HypAss object libraries offer four different ways to split the object:

  AVAILLABLE OPTIONS:

    'S2B'  (split in 2 bytes)

      This switch should be used if your destination system has a 16-bit
      wide databus and you want to use 2 8-bit EPROMs.

    'S3B'  (split in 3 bytes)

      This switch should be used if your destination system has a 24-bit
      wide databus and you want to use 3 8-bit EPROMs.

    'S4B'  (split in 4 bytes)

      This switch should be used if your destination system has a 32-bit
      wide databus and you want to use 4 8-bit EPROMs.

    'S2W'  (split in 2 words)

      This switch should be used if your destination system has a 32-bit
      wide databus and you want to use 2 16-bit EPROMs.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_RAW
@PREV OBJ_RAW
  HypAss RAW OBJ library

  USAGE:

    .OBJ RAW [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a raw binary image file, up to 4GB. The name of the object file
    will be the name of your source with the extension changed to '.raw'.

    SEE ALSO:  @{" About binary objects " link  About_binary_objects}


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_CBM
  HypAss CBM OBJ library

  USAGE:

    .OBJ CBM [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:  .cbm

    Creates a binary load file with a 16bit, LSB first header of the start
    address of the following raw binary data. Because this object format just
    specifies a 16-bit start adress, the address space is limited to 64KB.
    For this the maximum filesize is 65536+2 = 65538 bytes. The name of the
    object file will be the name of your source with the extension changed
    to '.cbm'. This format was used in good old 6502 machines by Commodore®,
    as PET, VC20, C16, Plus4, C64 and C128 (we should never forget them).

    SEE ALSO:  @{" About binary objects " link  About_binary_objects}


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_BOO
  HypAss BOO OBJ library

  USAGE:

    .OBJ BOO


  FEATURES:

    Creates a binary load file with a leading $FF byte to be loaded into
    a 68HC11 in bootstrap mode. Usually the 68HC11 expects 257 bytes, one
    page plus the $FF introduction, but there exists HC11s which require a
    16-bit byte count after the opening $FF, so the filesize will be 259 for
    one page. To be independant this object library increases the size of
    the object until it is at least 257 bytes long. It's your job to check
    if this is enough for the relating destination MCU. The fillbyte getting
    used is always $00, independant of your global fillvalue selection. The
    name of the object file will be the name of your source with the file
    extension changed to '.boo'.

    SEE ALSO:  @{" About binary objects " link  About_binary_objects}


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_HX8
  HypAss HX8 OBJ library

  USAGE:

    .OBJ HX8 [,CR] [,D8] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex object file in Intel®-Hex INHX8M Format, with a 16-bit
    address each line, and up to 64KB of data. The name of the object file
    will be the name of your source with the extension changed to '.hx8'.
    If the 'CR' switch is used the output will contain PC CRLF's ($0D0A),
    and the object filename including extension will be forced to uppercase.
    The 'D8' switch was made to create 100% MPASM compatible output, where
    lines just contain 8 databytes in opposite to 16 usual ones.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_H32
  HypAss H32 OBJ library

  USAGE:

    .OBJ H32 [,CR] [,D8] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in Intel® Hex INHX32 Format, with a 16-bit address
    each record, a 16 bit segment address each segment record, and up to
    4GB of data. The name of the object file will be the name of your source
    file with the extension changed to '.h32'. If the 'CR' switch is used,
    the output will contain PC CRLF's ($0D0A), and both, the object filename
    and the extension will be forced to uppercase. The 'D8' switch was made
    to create 100% MPASM compatible output, where lines just contain 8 data-
    bytes in opposite to 16 usual ones.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_MOS
  HypAss MOS OBJ library

  USAGE:

    .OBJ MOS [,CR] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in MOS® Hex Format, with a 16-bit address each record,
    and up to 64KB of data. The name of the object file will be the name of
    your source with the extension changed to '.mos'. If the 'CR' switch is
    used the output will contain PC CRLF's ($0D0A), and the object filename
    including extension will be forced to uppercase.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_S19
  HypAss S19 OBJ library

  USAGE:

    .OBJ S19 [,S0] [,S5] [,CR] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in Motorola® S19 S-Record Format, with a 16-bit
    address each S1 record and up to 64KB of data. The name of the object
    file will be the name of your source file with the extension changed to
    '.s19'. The file will end in an S9 record, containing the 16-bit start
    address you specified by the @{" .END pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_END} or zero. If you have set
    the 'CR' switch, the output will contain PC CRLF's ($0D0A), and the
    object filename including extension will be forced to uppercase. By
    setting the 'S5' switch you may enable the creation of an S5 record,
    containing the absolute number of data records in this object file.
    The 'S0' switch enables the creation of an S0 record at the beginning
    of your object, which will contain the module name which you have either
    specified by the @{" .IDENT pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_IDENT} or which defaults to the project name
    (the filename without path and extension). For safety :) this name will
    also be forced to uppercase if the 'CR' switch is set.



@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_S28
  HypAss S28 OBJ library

  USAGE:

    .OBJ S28 [,S0] [,S5] [,CR] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in Motorola® S28 S-Record Format, with a 24-bit
    address each S2 record and up to 16MB of data. The name of the object
    file will be the name of your source file with the extension changed to
    '.s28'. The file will end in an S8 record, containing the 24-bit start
    address you specified by the @{" .END pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_END} or zero. If you have set
    the 'CR' switch, the output will contain PC CRLF's ($0D0A), and the
    object filename including extension will be forced to uppercase. By
    setting the 'S5' switch you may enable the creation of an S5 record,
    containing the absolute number of data records in this object file.
    The 'S0' switch enables the creation of an S0 record at the beginning
    of your object, which will contain the module name which you have either
    specified by the @{" .IDENT pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_IDENT} or which defaults to the project name
    (the filename without path and extension). For safety :) this name will
    also be forced to uppercase if the 'CR' switch is set.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_S37
  HypAss S37 OBJ library

  USAGE:

    .OBJ S37 [,S0] [,S5] [,CR] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in Motorola® S37 S-Record Format, with a 16-bit
    address each S3 record and up to 4GB of data. The name of the object
    file will be the name of your source file with the extension changed to
    '.s37'. The file will end in an S7 record, containing the 32-bit start
    address you specified by the @{" .END pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_END} or zero. If you have set
    the 'CR' switch, the output will contain PC CRLF's ($0D0A), and the
    object filename including extension will be forced to uppercase. By
    setting the 'S5' switch you may enable the creation of an S5 record,
    containing the absolute number of data records in this object file.
    The 'S0' switch enables the creation of an S0 record at the beginning
    of your object, which will contain the module name which you have either
    specified by the @{" .IDENT pseudo " link hass:doc/-syn.guide/HYPASS_PSEUDO_IDENT} or which defaults to the project name
    (the filename without path and extension). For safety :) this name will
    also be forced to uppercase if the 'CR' switch is set.


@ENDNODE
----------------------------------------------------------------------------
@NODE OBJ_TEK
@NEXT OBJ_TEK
  HypAss TEK OBJ library

  USAGE:

    .OBJ TEK [,CR] [,@{"<global objopt>" link OBJ_OPTIONS}]


  FEATURES:

    Creates a hex file in Tektronix® Hex Format, with a 16-bit address each
    record, and up to 64KB of data. The name of the object file will be the
    name of your source file with the extension changed to '.tek'. If the
    'CR' switch is used the output will contain PC CRLF's ($0D0A), and the
    object filename including extension will be forced to uppercase.


@ENDNODE
----------------------------------------------------------------------------
@NODE AMIGA_HARDWARE_PROGRAMMING_PROJECTS
@PREV AMIGA_HARDWARE_PROGRAMMING_PROJECTS
  Amiga hardware programming projects

    Now let's introduce some low-cost methods to process object files.
    There reside many hardware programming projects on Aminet® as there are:


        @{" SAPEP2      " link SAPEP2      }  EPROM    programmer
        @{" EPROMmer    " link EPROMMER    }  EPROM    programmer
        @{" EPIC        " link EPIC        }  PIC16C84 programmer
        @{" PICKIT      " link PICKIT      }  PIC16C84 programmer
        @{" 68HCProgram " link 68HCProgram }  68HC811  programmer
        @{" HCLoad      " link HCLoad      }  68HC*11  programmer
        @{" HitMon      " link HitMon      }  68HC*11  programmer + monitor


@ENDNODE
----------------------------------------------------------------------------
@NODE SAPEP2
  SAPEP V2   (aminet/hard/hack/sapep2.lha)

    Simple Amiga Parallel Eprom Programmer   (SHAREWARE $15)
    (c)1992  Silicon Synapse Electronics & John Kamchen

    This describes a quite professional constructed hardware project
    to program most popular eproms in the 4k x8 to 1024k x8 range
    with Amiga! Includes a reqtools-based "gui" and is configurable
    via ASCII-EPROM description files. Connects to parallel port.

    Can only read/write binary object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE EPROMMER
  EPROMMER 3.2d  (aminet/hard/misc/EPROMmer.lha)

    Amiga Eprommer V3.2d                   (no copy status)
    Hardware and Software © by Bob Blick and Udi Finkelstein.

    This describes a hardware project to build a 2716 to 27512
    EPROM programmer. Contains PCB layout and a GUI based programmer.
    Just the switching between EPROM types is made a little unusual
    by "personality modules". Connects to parallel port.

    Can read/write binary or Intel©-Hex object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE EPIC
  EPIC 1.0  (aminet/hard/hack/Epic1_0.lha)

    Epic V1.0  PIC16C84 programmer   (MAILWARE)
    Copyright © 1996 Stephen Marsden

    This describes a hardware project to build a PIC16C84 programmer.
    Contains schematic and a GUI based programmer written in AmigaE!!!
    Connects to parallel port (to serially program the PIC ;-)

    Can read/write Intel©-Hex INHX8M and INHX16 object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE PICKIT
  PICKIT 0.9  (aminet/dev/cross/pickit09.lha)

    PIC Developer's kit v 0.9 beta.   (MAILWARE?)
    Copyright © Tomas Beyer

    This describes a hardware project to build a PIC16C84 programmer.
    Contains schematic, a GUI based programmer and a cross assembler.
    Connects to parallel port to program the PIC either serial or parallel.

    Can read/write Intel©-Hex INHX16 object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE 68HCProgram
  68HCProgram 0.9  (aminet/dev/cross/68HC11.lha)

    68HC00 Programmer V1.0    (MAILWARE?)
    ©1992 R. Vreeland Jr..

    This describes a hardware project to build a 68HC811 programmer.
    Contains schematic, a Kickstart 1.3 GUI based programmer and some
    archives I was not able to unpack.
    Connects to serial port to program the MCU in bootstrap mode.

    Can read/write Motorola® S19 object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE HCLoad
  HCload R2.1V1.2b  (aminet/dev/cross/ADev11.lha)

    MC68HC11 EEPROM Programmer    (ADev11 package is PUBLIC DOMAIN)
    Program written by Ron Eirich

    This is an AmigaDos® executable out of the great ADev11 package of
    Stan Burton. This executable can load up an S19 file to an external
    connected HC11 by either a buitin bootloader (hc711k4, hc811e2, hc11f1)
    or by an external specified one. The need of any HC11 programmer!
    Connects to serial port to program the MCU in bootstrap mode.

    Can read Motorola® S19 object code.


@ENDNODE
----------------------------------------------------------------------------
@NODE HitMon
  HitMon11 v0.24 (aminet/dev/cross/Hc11Dev1.lha)

    HitMon11 v0.24           (FREEWARE)
    Copyright ©1992-1994, Richard Karlsson.

    This is a S-Record downloader and monitor for the Motorola® HC11 line
    of processors. The archive also contains a cross assembler.
    This executable can load up an S19 file to an external connected HC11
    by any of the freeware talkers supplied by Motorola (also present in
    the archive). It contains a powerfull monitor with all you expect to
    find there. It can start code in HC11 memory, disassemble memory,
    display regiters, just look in an HC11. The need of any HC11 programmer!
    Connects to serial port to program the MCU in bootstrap mode.

    Can read/write Motorola® S19 object code.


@ENDNODE
----------------------------------------------------------------------------
