@DATABASE $VER: HypAss 1.0 Math.guide (19.7.96) ©1998 RST Ralf Steines Trier, ALL RIGHTS RESERVED
@NODE main "HypAss expression evaluation"
@NEXT main "HypAss expression evaluation"
@TOC hass:HypAss.guide/main
  HypAss expression evaluation  @{" General math info " link General_math_info}  *** READ THIS FIRST ***

    Labels and symbols within expressions:

      @{" Labels and symbols   " link "LABELS_AND_SYMBOLS"             }  * $ . PC TRUE FALSE NARG

    Constants in different numerical systems:

      @{" Binary               " link "BINARY_CONSTANTS"               }  b'10'  %10      10b  0b10   2#10
      @{" Octal                " link "OCTAL_CONSTANTS"                }  o'10'  @10 &10  10o   010   8#10
      @{" Decimal              " link "DECIMAL_CONSTANTS"              }  d'10'   10      10d 10t    10#10
      @{" Hexadecimal          " link "HEXADECIMAL_CONSTANTS"          }  h'10'  $10 x10  10h  0x10  16#10
      @{" User radix           " link "USER_RADIX_CONSTANTS"           }                             **#10
      @{" Character            " link "CHARACTER_CONSTANTS"            }  a'O'   'O  'O'
      @{" String               " link "STRING_CONSTANTS"               }  "b" - "blub"
      @{" Boolean              " link "BOOLEAN_CONSTANTS"              }  TRUE FALSE

    Operators grouped by their precedence (top down)

      @{" Primary              " link "PRIMARY_OPERATORS"              }  () []
      @{" Unary                " link "UNARY_OPERATORS"                }  + - ! ~ ^^ ^ < >
      @{" Multiplicative       " link "MULTIPLICATIVE_OPERATORS"       }  * / % //
      @{" Additive             " link "ADDITIVE_OPERATORS"             }  + -
      @{" Bitwise shift        " link "BITWISE_SHIFT_OPERATORS"        }  << >>
      @{" Relational           " link "RELATIONAL_OPERATORS"           }  < > <= >=
      @{" Equality             " link "EQUALITY_OPERATORS"             }  == = != <>
      @{" Bitwise logical AND  " link "BITWISE_AND_OPERATOR"           }  &
      @{" Bitwise exclusive OR " link "BITWISE_EOR_OPERATOR"           }  ^
      @{" Bitwise inclusive OR " link "BITWISE_OR_OPERATOR"            }  | !
      @{" Logical AND          " link "LOGICAL_AND_OPERATOR"           }  &&
      @{" Logical OR           " link "LOGICAL_OR_OPERATOR"            }  ||
      @{" Conditional          " link "CONDITIONAL_OPERATOR"           }  ?
      @{" Assignment           " link "ASSIGNMENT_DIRECTIVES"          }  = := += -= *= /= %= &= |= ^= >>= <<=


@ENDNODE
----------------------------------------------------------------------------
@NODE General_math_info
@NEXT General_math_info
@PREV General_math_info
  General math library information

    The expression evaluation of HypAss is PRELIMARY and subject to change!

  INTRODUCTION:

    As we have plugins through libraries in every corner of HypAss, this
    should also be the same with arithmetical evaluation systems.
    Currently we have just one expression evaluator system integrated in
    HypAss, what will surely change. This evaluator was designed to eat
    anything you feed it, what I have found in any of the named assemblers.
    Any calculations made within this evaluator compute a 32 bit signed
    integer. Signed does not mean that you can't access address $FFFFFFFF,
    thats also possible. The maximum range is -$80000000 to +$FFFFFFFF.
    This evaluator is far away from being what it is intended to be, but it
    is on a good way to reach it one day. The standard configuration offers
    lots of different systems to describe numerical values. The operands
    supported are a subset of the ANSI-C expression evaluation, with some
    additionals which were necessary for compatiblity reasons, and will
    one day reach full compatiblity here. The precedences of the evaluator
    adapt to the syntax specific need, because some assemblers (even good
    ones) just calculate straight left to right. To be compatible, each
    syntax library controls the evaluator within HypAss.


  FUTURE PLANS:

    -Support of single/double precision math libraries.
    -High precision floating point support, to be used with DSPs.
    -Necessarily function support, best would be definables.
    -Maybe other mathematical systems, as RPN, if needed.

    In future, a .MATH directive will be built in, (already reserved) to
    switch between different expression evaluators, arithmetical systems
    and precisions. These math libraries will transparently be called by
    the syntax libraries, so there will not be any differences in usage
    necessary, but possible.


@ENDNODE
----------------------------------------------------------------------------
@NODE LABELS_AND_SYMBOLS
@PREV LABELS_AND_SYMBOLS
@NEXT LABELS_AND_SYMBOLS
  LABELS AND SYMBOLS WITHIN EXPRESSIONS

    Labels and symbols within expressions represent their numerical value.
    Both may *not* be referred before they have been defined by the user.
    There exist special symbols, which HypAss knows without prior definition.
    Static reserved symbols are the @{" Boolean constants " link "BOOLEAN_CONSTANTS"              } 'TRUE' and 'FALSE'.
    The actual value of the programm counter at the beginning of the actual
    line may be referred by one of these special, reserved symbols:
    '*', '$', '.' or 'PC'. Currently the reserved symbol 'PC' is detected
    according to the actual symbol case sensitivity, but should always be
    referred uppercase, because this may change!
    Within macros we have another reserved symbol, 'NARG', which represents
    the number of arguments passed to the actually processed macro. It is
    just readable within a macro, globally you may define a label, symbol or
    macro having this name. 'NARG' always gets detetcted case sensitive!

        Reserved symbols:

            *           ; actual PC
            $           ; actual PC
            .           ; actual PC
            PC          ; actual PC

            TRUE        ; boolean TRUE
            FALSE       ; boolean FALSE

            NARG        ; Number of ARGuments, local to macros!


@ENDNODE
----------------------------------------------------------------------------
@NODE BINARY_CONSTANTS
@PREV BINARY_CONSTANTS
  BINARY CONSTANTS

            %10101010
             10101010b   only if radix<=10
             10101010B   only if radix<=10
           0b10101010
           0B10101010
           b'10101010'
           B'10101010'
           2#10101010
            .radix bin
             10101010
            .radix 2
             10101010


@ENDNODE
----------------------------------------------------------------------------
@NODE OCTAL_CONSTANTS
  OCTAL CONSTANTS

            &1234567
            @1234567
            01234567     *** read text below
             1234567o    only if radix<=16
             1234567O    only if radix<=16
           o'1234567'
           O'1234567'
           8#1234567
            .radix oct
             1234567
            .radix 8
             1234567


    There are some numerical systems which may in some cases result in being
    interpreted wrong, so they may partly be switched off. The best example
    is to introduce an octal number by a zero prefix: e.g. 0177. There are
    assemblers which use by default hex radix (as MPASM), and to have a clear
    view at the operand size in bytes, many programmers fill the leading
    unused hex digits with zeros, what will surely be misinterpreted as an
    octal number. To avoid this conflict, the 0-prefixed-octal detection is
    not active in many syntax sets, but may be enabled using the global 'Z2O'
    (zero to introduce octal) syntax library option.


@ENDNODE
----------------------------------------------------------------------------
@NODE DECIMAL_CONSTANTS
  DECIMAL CONSTANTS

            2147483647
            2147483647d   only if radix<=10
            2147483647D   only if radix<=10
            2147483647t   only if radix<=16
            2147483647T   only if radix<=16
          d'2147483647'
          D'2147483647'
         10#2147483647


@ENDNODE
----------------------------------------------------------------------------
@NODE HEXADECIMAL_CONSTANTS
  HEXADECIMAL CONSTANTS

             $12345678
              12345678h   only if radix<=16
              12345678H   only if radix<=16
             x12345678    second char must be digit *** read text below
             X12345678    second char must be digit *** read text below
             #12345678    *** read text below
            0x12345678
            0X12345678
            h'12345678'
            H'12345678'
           16#12345678
            .radix hex
              12345678
            .radix 16
              12345678


    There are some numerical systems which may collide with label / symbol
    conventions of other syntax sets, so they may partly be switched off.The
    best example is to introduce a hex number by an x. X is a variable used
    very often by programmers who have programmed in BASIC ;-) and because
    there's not enough x's it's the easiest to enumerate them x0, ... x22,
    what will surely be misinterpreted as a number, not a symbol. For this
    reason the leading-X feature is only active where it's necessary (CAZ).
    I have squeezed 7MB of example sourcecode through this evaluator, and I
    got one collision with a X012 label within a source file from the MUCBBS
    from around 1970. Another very critical numerical system is to introduce
    a hex number by a '#', as CAZ does. This may affect the address mode
    detection for many CPUs, so this feature is just active within the CAZ
    syntax class.


@ENDNODE
----------------------------------------------------------------------------
@NODE USER_RADIX_CONSTANTS
  USER RADIX CONSTANTS

            <base>#<number>

    If neither of all these numerical systems fit, you may specify numbers
    by a user definable radix. For this, the number must have a '<base>#'
    prefix where <base> is a 1 or 2 digit decimal number to specify the
    radix. As it is usual, the radix may reach from 2 to 36, what means,
    that the maximum legal digit of a number may reach from "1" (base 2)
    to "z" (base 36). ASCII characters in numbers of any base are case
    insensitive.

    If you need a special radix frequently, you should better change the
    default radix. For this we have the @{" .RADIX pseudo opcode " link hass:doc/-syn.guide/HYPASS_PSEUDO_RADIX}.


@ENDNODE
----------------------------------------------------------------------------
@NODE CHARACTER_CONSTANTS
  SINGLE CHARACTER CONSTANTS

           a'A'
           A'A'
            'A'
            'A

    Character constants may contain any non-zero-byte ASCII character, even
    those which are usually reserved for other purposes (see examples below).
    ASCII chars in single character constants get converted if enabled.
    As in any string, you may also use here @{" ANSI C escape sequences " link ANSI_C_ESCAPE_SEQUENCES}.
    They get converted too.

    SEE ALSO:  @{" .CONV pseudo opcode " link hass:doc/-syn.guide/HYPASS_PSEUDO_CONV}   @{" CONVERSION tables " link "hass:doc/-CONV.guide/main"  }

    Examples for "difficult" characters:

            '"          ; quote $22
            ''          ; apost.$27
            ';          ; semic.$3B
            ',          ; comma $2C
            '           ; space $20
            '
            ' +1

    A space ($20) is usually ignored by HypAss, but if it is single
    quoted, it will clearly result in $20, even at the and of a line.


@ENDNODE
----------------------------------------------------------------------------
@NODE STRING_CONSTANTS
  STRING CONSTANTS

            "a"
            "ab"
            "abc"
            "abcd"

    Within assignments (and currently only there) you may additionally
    specify a 32-bit value by a string. The first character is always
    the most significant byte. If your string is longer than 4 characters
    there will be no overflow error, just the left characters get shiftet
    out of the result. Character conversion also affects these charaters.
    As in any string, you may also use here @{" ANSI C escape sequences " link ANSI_C_ESCAPE_SEQUENCES}.
    They get converted too.

    SEE ALSO:  @{" .CONV pseudo opcode " link hass:doc/-syn.guide/HYPASS_PSEUDO_CONV}   @{" CONVERSION tables " link "hass:doc/-CONV.guide/main"  }


@ENDNODE
----------------------------------------------------------------------------
@NODE BOOLEAN_CONSTANTS
@NEXT BOOLEAN_CONSTANTS
  BOOLEAN CONSTANTS

        TRUE          ; =-1 ($FFFFFFFF)
        FALSE         ; =0

    You may refer these boolean constants in any expression, they are
    reserved symbols and always get detected case sensitive. TRUE within
    HypAss differs from ANSI C, be carefully! The easiest way to be sure
    not to make silly mistakes because of this difference is to ALWAYS
    refer to these constants. If you are used from C to refer TRUE by
    checking for 1, then just use the boolean constant TRUE instead always!


@ENDNODE
----------------------------------------------------------------------------
@NODE ANSI_C_ESCAPE_SEQUENCES
@PREV ANSI_C_ESCAPE_SEQUENCES
@NEXT ANSI_C_ESCAPE_SEQUENCES
  The ANSI C escape sequences


     \\a         ; $07 BEL Bell, alert
     \\b         ; $08 BS  Backspace
     \\f         ; $0C FF  Form feed
     \\n         ; $0A LF  Line feed
     \\r         ; $0D CR  Carriage return
     \\t         ; $09 HT  Horizontal tabulator
     \\v         ; $0B VT  Vertical tabulator
     \\\\         ; $5C \\   Backslash
     \\?         ; $3F ?   Question mark
     \\'         ; $27 '   Single quote, apostrophe
     \\"         ; $22 "   Double quote
     \\017       ; Octal number, leading zero, 2 octal digits
     \\x1F       ; Hex.  number, leading x,    2 hex.  digits


@ENDNODE
----------------------------------------------------------------------------
@NODE PRIMARY_OPERATORS
@PREV PRIMARY_OPERATORS
  PRIMARY OPERATORS

  EXPRESSION GROUPING OPERATORS:

    ( [ begin expression group
    ) ] end expression group

  Some CPU mnemonic syntax sets expect the operand to be enclosed by
  brackets [] (68xx) to identify the indirect addressing mode whereas
  others expect parentheses () for this (65xx). To be flexible in that
  point, I have choosen to handle both kinds of parenthesizing 100%
  equal to each others, to be able to use the opposite type, not to
  confuse the addressing mode detection. Do not mix them up, so your
  code clearly shows what is parethesizing and what is addressing mode!


@ENDNODE
----------------------------------------------------------------------------
@NODE UNARY_OPERATORS
  UNARY OPERATORS

        ^^ $12345678   Most significant byte of a 32-bit value
        ------------
                 $12

         ^ $12345678   Most significant byte of a 24-bit value
         -----------
                 $34

         > $12345678   Most significant byte of a 16-bit value
         -----------
                 $56

         < $12345678   Least significant byte
         -----------
                 $78

         ~ $00000000   Bitwise negation, one's complement, (toggle bits)
         -----------
           $FFFFFFFF

         - $00000001   Unary minus, two's complement, negate
         -----------
           $FFFFFFFF

         + $00000001   Unary plus, sign as positive, (do nothing)
         -----------
           $00000001

         ! $00000022   Logical negation, logical NOT  (FALSE if not zero)
         -----------   Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!
           $00000000

        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE MULTIPLICATIVE_OPERATORS
  MULTIPLICATIVE OPERATORS

           $00000022
         * $00000002   Multiplication
         -----------
           $00000044

           $00000025
         / $00000002   Division                      (not by 0!)
         -----------
           $00000011

           $00000025
         % $00000002   Remainder after division      (not by 0!)
         -----------
           $00000003

           $00000025
        // $00000002   Same as before, for compatiblity.
         -----------
           $00000003

        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE ADDITIVE_OPERATORS
  ADDITIVE OPERATORS

           $00000022
         + $00000010   Addition      (the sum of the operators)
         -----------
           $00000032

           $00000022
         - $00000010   Substraction  (the difference of the operators)
         -----------
           $00000012

        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE BITWISE_SHIFT_OPERATORS
  BITWISE SHIFT OPERATORS

           $00000011
        << $00000008   Bitwise shift left
         -----------
           $00002200

           $00002200
        >> $00000008   Bitwise shift right
         -----------
           $00000022

        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE RELATIONAL_OPERATORS
  RELATIONAL OPERATORS

    op1 < op2     Results in TRUE if the value of op1 is less
                  than the value of op2, else FALSE.
                  Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!

    op1 > op2     Results in TRUE if the value of op1 is greater
                  than the value of op2, else FALSE.
                  Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!

    op1 <= op2    Results in TRUE if the value of op1 is less than
                  or equal to the value of op2, else FALSE.
                  Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!

    op1 >= op2    Results in TRUE if the value of op1 is greater than
                  or equal to the value of op2, else FALSE.
                  Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!


@ENDNODE
----------------------------------------------------------------------------
@NODE EQUALITY_OPERATORS
  EQUALITY OPERATORS

    op1 == op2    Results in TRUE if the value of op1 is equal to
                  the value of op2, else FALSE. Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!

    op1 = op2     Same as before, for compatiblity.


    op1 != op2    Results in TRUE if the value of op1 is not equal to
                  the value of op2, else FALSE. Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!

    op1 <> op2    Same as before, for compatiblity.


@ENDNODE
----------------------------------------------------------------------------
@NODE BITWISE_AND_OPERATOR
  BITWISE AND OPERATOR

           %00100101
         & %00010101   Bitwise AND, result bit is set wherever
         -----------   both relating operand bits are set
           %00000101


        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE BITWISE_EOR_OPERATOR
  BITWISE EXCUSIVE OR OPERATOR

           %00100101
         ^ %00010101   Bitwise EOR, result bit is set wherever
         -----------   both relating operand bits differ.
           %00110000


        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE BITWISE_OR_OPERATOR
  BITWISE INCUSIVE OR OPERATOR

           %00100101
         | %00010101   Bitwise OR, result bit is set wherever
         -----------   any of both relating operand bits is set.
           %00110101

           %00100101
         ! %00010101   Same as before, for compatiblity
         -----------
           %00110101


        Note that this is just an informal notation,
        and is *NOT* meant to be used in source!


@ENDNODE
----------------------------------------------------------------------------
@NODE LOGICAL_AND_OPERATOR
  LOGICAL AND OPERATOR

    op1 && op2    Results in TRUE if the value of op1 AND the value
                  of op2 are not zero, else FALSE. Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!


@ENDNODE
----------------------------------------------------------------------------
@NODE LOGICAL_OR_OPERATOR
  LOGICAL OR OPERATOR

    op1 || op2    Results in TRUE if the value of op1 OR the value
                  of op2 are not zero, else FALSE. Result is @{" BOOLEAN " link "BOOLEAN_CONSTANTS"}!


@ENDNODE
----------------------------------------------------------------------------
@NODE CONDITIONAL_OPERATOR
  CONDITIONAL OPERATOR

    op1 ? op2    Results in op2 if the value of op1 is not zero, ELSE zero


        This syntax differs totally from ANSI-C and was found in
        SAsm R2.1V1.5 (c) Stan Burton (ADEV11 package) and in
        DASM V2.12    (c) Matthew Dillon, so I inluded it for later usage.

        When I find time to work in this corner again, I will implement
        both, this syntax and the original ANSI-C syntax in a compatible
        way by checking for the ':'. So use it as it is, it will also work
        in future.

        I wanted to include the assemblers named above, but they both have
        a very specific syntax, and are currently too complex to be imple-
        mented.


@ENDNODE
----------------------------------------------------------------------------
@NODE ASSIGNMENT_DIRECTIVES
@NEXT ASSIGNMENT_DIRECTIVES
  ASSIGNMENT *DIRECTIVES*

    Constant symbol assignment:

        mysymbol .equ $1234  ; SEE ALSO: @{" .EQU pseudo opcode " link hass:doc/-syn.guide/HYPASS_PSEUDO_EQU}
        mysymbol    = $1234

    Redefinable symbol assignment:

        mysymbol .set $1234  ; SEE ALSO: @{" .SET pseudo opcode " link hass:doc/-syn.guide/HYPASS_PSEUDO_SET}
        mysymbol   := $1234

        mysymbol   += $1234  ; add, set equal
        mysymbol   -= $1234  ; subtract, set equal
        mysymbol   *= $1234  ; multiply, set equal
        mysymbol   /= $1234  ; divide, set equal
        mysymbol   %= $1234  ; modulus, set equal
        mysymbol   &= $1234  ; bitwise logical AND, set equal
        mysymbol   |= $1234  ; bitwise inclusive OR, set equal
        mysymbol   ^= $1234  ; bitwise exclusive OR, set equal
        mysymbol  >>= 8      ; bitwise shift right, set equal
        mysymbol  <<= 16     ; bitwise shift left, set equal

    Between the symbolname and the operator there is at least one white
    space required, whereas there must be no space between the operand and
    the operator. So 'mysymbol =22' is legal.

    Note that all these assignment operators are *currently* implemented
    as directives, so assignments within terms are not permitted, as you may
    be used to in C expressions. The result must be a symbol to the left of
    a term in the moment. (Do I write a C interpreter in E?)


@ENDNODE
----------------------------------------------------------------------------
