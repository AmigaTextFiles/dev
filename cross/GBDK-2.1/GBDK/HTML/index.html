<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>

<TITLE>GameBoy Developer's Kit</TITLE>

<!--
Created:	13-Apr-97
By:			Pascal Felber
-->

</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<CENTER>
<H1>GameBoy Developer's Kit</H1>

<H3>Version 2.1.0 (DOS and Unix)</H3>
<H5>Last updated: 21-Apr-1999</H5>
<H3>Pascal Felber and Michael Hope</H3>
</CENTER>

<!-- ############################################################ -->
<HR>

<H2>News</H2>

<P>
The new versions of GBDK use a new directory structure. The GBDK can target pure Z80 systems (and not only the Z80 variant found in the GameBoy). The new directory structure is: <CODE>/SDK/XX-XX/Y.Y.Y</CODE> (<CODE>Y-Y-Y</CODE> on DOS), where <CODE>XX-XX</CODE> is the target and <CODE>Y.Y.Y</CODE> is the version number. An additional benefit is that it is possible to install new GBDK versions without removing the older ones.
</P>

<P>
A <B>preliminary</B> version of the libraries documentation is available <A HREF="http://lsewww.epfl.ch/~felber/GBDK/html/book01.html">online</A>. For technical informations about the GameBoy hardware, see <A HREF="http://www.fh-karlsruhe.de/fbnw/html/Gameboy/Docs/Gb3.htm">there</A>.
</P>

<P>
<B>New:</B> Have a look at the <A HREF="http://gbdev.webjump.com/GBDoK.txt">GBDoK</A> documentation page maintained by Jason.
</P>

<!-- ############################################################ -->
<HR>

<P>
A japanese translation of this page is available <A HREF="http://www.geocities.co.jp/playtown/2004/gbdk_j.htm">here</A>.
</P>

<UL>
	<LI><A HREF="#Highlights">Highlights</A>
	<LI><A HREF="#Status">Status</A>
	<LI><A HREF="#Changes">Changes</A>
	<LI><A HREF="#Downloading">Downloading and Installing</A>
	<LI><A HREF="#Compiler">The Compiler</A>
	<LI><A HREF="#Assembler">The Assembler</A>
	<LI><A HREF="#Linker">The Linker</A>
	<LI><A HREF="#Libraries">The Include Files and Libraries</A>
	<LI><A HREF="#Examples">The Example Programs</A>
	<LI><A HREF="#Guidelines">GBDK Programming Guidelines</A>
	<LI><A HREF="#Porting">Porting Code from GBDK 1.1 to GBDK 2.0</A>
	<LI><A HREF="#Mixing">Mixing C and Assembly</A>
	<LI><A HREF="#Multiple">Multiple Bank Images</A>
	<LI><A HREF="#RAM">Copying Functions to RAM and HIRAM</A>
	<LI><A HREF="#Interrupt">IRQ Handlers</A>
	<LI><A HREF="#Initialization">Initialization Routine</A>
	<LI><A HREF="#Changing">Changing Important Addresses</A>
	<LI><A HREF="#Troubleshooting">Troubleshooting</A>
	<LI><A HREF="#Problems">Known Problems</A>
	<LI><A HREF="#Links">Links</A>
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Highlights"></A>Highlights</H2>

<P>
The GameBoy Developer's Kit (GBDK), is a set of tools that enable to develop programs for the Nintendo GameBoy system, either in C or in assembly. GBDK includes a set of libraries for the most common requirements and generates image files for use with a real GameBoy or with an emulator like <A HREF="http://www.komkon.org/fms/VGB/">VGB</A> or <A HREF="http://www.work.de/nocash/">no$gmb</A>.
</P>

<P>
GBDK is available for UNIX and DOS. The UNIX version of GBDK has been tested on Solaris 2.6. The DOS version requires a 386 DX processor (or higher), with a DOS Protected Mode Interface (DPMI).
</P>

<P>
GBDK is currently being used in several projects. The first commercial project that used GBDK is <A HREF="ProAR2.html">Pro Action Replay II</A>. GBDK also got used for a japanese RPG game (Monster Race from KOEI Co., Ltd.).
</P>

<P>
GBDK features:
</P>

<UL>
	<LI>An ANSI C compiler.
	<LI>An assembler that generates relocatable code.
	<LI>A peephole optimizer.
	<LI>A linker that produces GameBoy image files.
	<LI>Support for multiple-bank images.
	<LI>Smart linking.
	<LI>A set of libraries, with source code.
	<LI>Example programs in assembly and in C.
</UL>

<P>
<A HREF="http://www.aracnet.com/~pfelber/GBsed/">GBsed</A>, a companion sprite editor written in Java, enables to create images and sprites to be included in GameBoy programs. Alternatively, you can use the Win 95/NT BMP2GB program by <A HREF="mailto:Ian@resourcekt.co.uk">Ian James</A> that convert BMP files to C code, or the Win 95/NT <A HREF="http://www.casema.net/~hpmulder/">GameBoy Tile Designer and Map Builder</A> programs that lets you create images and maps for GBDK.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Status"></A>Status</H2>

<P>
GBDK is freeware for non-commercial developments. If you use it, just send me an e-mail to keep me informed of your work. If you really find it great, you can send me something typical from your country...
</P>

<P>
If GBDK is used for developing a commercial program, I ask you to mention that the program has been made using GBDK (in the credits), and to send me a copy of the finished product. If you feel generous, you can also send me a copy of any other products that your company has produced for the GameBoy...
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Changes"></A>Changes </H2>

<H3>Changes in GBDK 2.1.0 (<A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-gbz80-gb-2.1.0.zip">DOS</A>, <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-gbz80-gb-2.1.0.tar.gz">Linux</A>, and <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-2.1.0.tar.gz">Unix</A>) - 21 Apr 99</H3>

<UL>
	<LI>Added Michael's <CODE>maccer</CODE> macro preprocessor.
	<LI>Fixed the problems in the Color GB and sound examples.
	<LI>Fixed some minor bugs.
	<LI>Cleaned up the source distribution.
</UL>

<H3>Changes in GBDK 2.0.18 (<A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-gbz80-gb-2.0.18.zip">DOS</A>, <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-gbz80-gb-2.0.18.tar.gz">Linux</A>, and <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-2.0.18.tar.gz">Unix</A>) - 26 Mar 99</H3>

<UL>
	<LI>Many bug fixes
	<LI>Greatly improved APA graphics library by Jon Fuge (thanks Jon!)
	<UL>
		<LI>Circle, rectangle, and line functions
		<LI>Ability to draw text on a graphics screen
		<LI>Pixel get/set functions
		<LI>Demo: examples/filltest.c
	</UL>
	<LI>New text output routines
	<UL>
		<LI>Able to have more than one font on the screen
		<LI>Able to allocate a range of tiles for background
		graphics
		<LI>ibm, clean (spectrum), italic, and minimal (36) tile
		fonts included
		<LI>Backwards compatible (hopefully)
		<LI>Demo: examples/fonts.c
	</UL>
	<LI>Improved CGB support (thanks Lars!)
	<LI>Library for playing samples (thanks Lars and Jeff!)
	<LI>Reworked malloc routines
	<LI>Removed the <CODE>__REG_XXXX</CODE> special variables. The optimizer automatically transforms <CODE>LD</CODE> into <CODE>LDH</CODE> when necessary.
</UL>

<H3>Changes in GBDK 2.0.17 (<A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-gb-gb-2.0.17.zip">DOS</A> and <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK-2.0.17.tar.gz">Unix</A>) - 26 Nov 98</H3>

<UL>
	<LI>Fixed a bug in the code generator (reported by John Panettiere).
	<LI>Added two examples for the Color GB: colorbar and a color version of the dscan game (contributed by Mr. N.U. of TeamKNOx). Some functions for the Color GB have been defind in the <CODE>cgb.s</CODE> library.
</UL>

<H3>Changes in GBDK 2.0.16 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/SDK-gb-gb-2.0.16.zip">DOS</A> and <A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/SDK-2.0.16.tar.gz">Unix</A>) - 30 Oct 98</H3>

<UL>
	<LI>Fixed a bug in <CODE>get_sprite_tile()</CODE> and <CODE>get_sprite_prop()</CODE>.
	<LI>Added a DOS script (by Mark Rawer) for automating GBDK's installation on DOS machines.
	<LI>Added support for MBC5 (up to 512 ROM banks, and 16 RAM banks). Changed the way banks are switched. See the <CODE>banks.c</CODE> example.
	<LI>Started a SuperGB library. At the moment, one can only check if the game is running on a SuperGB or not. Be sure to put 0x03 at address 0x146 of the header if the game has to use SuperGB capabilities. This can be done using the <CODE>-Wl-yp0x146=0x03</CODE> flag.
	<LI>Many bug fixes and improvements in the libraries.
</UL>

<H3>Changes in GBDK 2.0.15 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/SDK-gb-gb-2.0.15.zip">DOS</A> and <A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/SDK-2.0.15.tar.gz">Unix</A>) - 5 Oct 98</H3>

<UL>
	<LI>The new sources are based on lcc 4.1 (final version).
	<LI>Updated most examples and libraries so that they synchronize with vblank instead of using delays.
	<LI>The linker now generates symbol files for the no$gmb emulator natively.
	<LI>The sources of the latest GBDK version have been released.
</UL>

<H3>Changes in GBDK 2.0.14 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/SDK-gb-gb-2.0.14.zip">DOS</A> binary only) - 28 Sep 98</H3>

<UL>
	<LI>A preliminary version of the new GBDK documentation is available online.
	<LI>The new versions of GBDK use a new directory structure.
	<LI>Fixed a bug in the generation of the <CODE>STOP</CODE> instruction.
	<LI>Fixed a potential problem in the <CODE>wait_vbl()</CODE> function.
	<LI>Fixed a bug in the joypad libraries functions that prevented joypad interrupts to occur (reported by Helmut Schoettner).
	<LI>Updated the graphics functions so that they take into account the addresses specified in LCDC.
	<LI>The tile data transfer routines now allow to copy 256 tiles at once (instead of 255).
	<LI>Added random number generator (written by Luc Van den Borre).
	<LI>Added operations to get tile data, to scroll sprites, to move the background and the window, etc.
	<LI>Modified the semantics of the <CODE>set_win_data()</CODE> function so that it is consistent with other functions. This change requires adding <CODE>0x80</CODE> to the first parameter of this function call in existing programs.
	<LI>Exported the <CODE>cls()</CODE> function to the standard output library (reported by Helmut Schoettner).
	<LI>Added two flags (<CODE>-int8</CODE> and <CODE>-int16</CODE>) to specify the size of the integer type (default is 8 bits, which produces shorter and faster code).
</UL>

<H3>Changes in GBDK 2.0b13 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/gbdk-2.0-b13_gb-gb.zip">DOS</A> and <A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/gbdk-2.0-b13_gb-gb_linux_glibc2.tar.gz">Linux</A> binaries) - 17 Aug 98</H3>

<UL>
	<LI>Fixed another bug in the assembler, that caused problems in code generation if no listing was output.
	<LI>Added a linker flag to modify the resulting output file upon ROM generation (for instance, to put 0x80 at address 0x143, use: <CODE>-Wl-yp0x143=0x80</CODE>).
	<LI>Added a <CODE>reset()</CODE> function to reset the GB (restart the program's execution).
	<LI>Added a variable <CODE>_cpu</CODE> that indicated the CPU of the machine on which the code is running (GB, Pocket GB, Color GB).
	<LI>Updated the linker (patch by Michael Hope). Linking is now much faster on slow systems.
	<LI>Added several libraries from Michael Hope (in particular, <CODE>memset</CODE>, <CODE>malloc</CODE>, <CODE>calloc</CODE>, and <CODE>free</CODE> are implemented).
	<LI>Sound is turned off by default (thanks Jeff).
	<LI>Float and long support is better but still far from complete.
	<LI>The linker map format is different, and should make writing a debugger
simpler.
</UL>

<H3>Changes in GBDK 2.0b12 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b12.zip">DOS</A> binary only) - 16 Apr 98</H3>

<UL>
	<LI>Fixed a bug in <CODE>set_bkg_tiles</CODE>.
	<LI>Modified assembler to conform to gcc error standard (patch by Michael Hope).
	<LI>Corrected a bug that sometimes made the assembler and linker crash (patch by Michael Hope).
	<LI>Removed the linker problem that prevented to take the high/low byte of a relocatable address.
	<LI>New drawing library allowing full-screen drawing (based on GBAPA).
	<LI>New example program (<CODE>paint.c</CODE>) illustrating this library.
	<LI>Added primitive floating point support (but there is not support yet for reading and printing floating point values).
	<LI>Added primitive long long (32 bits) support (but there is not support yet for reading and printing floating point values).
	<LI>Changed interrupt handling. It is now possible to chain up to 8 interrupt handlers for each interrupt.
	<LI>Several changes in the names of assembly functions.
	<LI>Changed some compiler flags.
	<LI>Added support in the assembler for "official" mnemonics:
<PRE>
    LD (HLI),A
    LD (HLD),A
    LD A,(HLI)
    LD A,(HLD)
    ADD SP,offset
    LDHL SP,offset
</PRE>
</UL>

<H3>Changes in GBDK 2.0b11 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b11.zip">DOS</A> binary only) - 24 Nov 97</H3>

<UL>
	<LI>Fixed another bug in code generation, that could happen when performing logical operations on 1-byte variables.
</UL>

<H3>Changes in GBDK 2.0b10 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b10.zip">DOS</A> binary only) - 6 Nov 97</H3>

<UL>
	<LI>Fixed a nasty bug in code generation, that could happen when performing arithmetic operations on 1-byte variables.
	<LI>Changed the name of same files of the <CODE>gb-dtmf</CODE> example so that it compiles on DOS.
</UL>

<H3>Changes in GBDK 2.0b9 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b9.zip">DOS</A> binary only)</H3>

<UL>
	<LI>Several bug fixes in the compiler and in the libraries.
</UL>

<H3>Changes in GBDK 2.0b8 (DOS binary only)</H3>

<UL>
	<LI>Limited all file names to 8 characters to solve problems on DOS.
	<LI>Added communication routines that enable to send data through the link port of the GameBoy. Unfortunately, these routines do not always work; so use them with care until the next GBDK release.
	<LI>Added the <CODE>comm.c</CODE> example which illustrates how to use communication routines.
	<LI>It is possible to specify the name of the program (to be written in the image header) at link time using the <CODE>-Wl-yn="XXX"</CODE> flag (where <CODE>X</CODE> is the name of the program, which can contain up to 16 characters in quotes, including spaces; on Unix, depending on your shell, you must add backslashes before quotes and spaces like in <CODE>-Wl-yn=\"My\ Game\"</CODE>).
	<LI>Several bug fixes in the compiler.
</UL>

<H3>Changes in GBDK 2.0b7 (DOS binary only)</H3>

<UL>
	<LI>GBDK now uses a pre-release of lcc 4.1 (DOS binary only), that fixes a couple of problems in code generation.
	<LI>A couple of important points have been documented in the <A HREF="#Guidelines">GBDK Programming Guidelines</A> and <A HREF="#Problems">Known Problems</A> sections.
	<LI>Several improvements and optimizations to the code generator.
</UL>

<H3>Changes in GBDK 2.0b6 (<A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b6.zip">DOS</A> and <A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/gb/GBDK-2.0b6.tar.gz">Unix</A>)</H3>

<UL>
	<LI>Added a peephole optimizer (with few rules at the moment).
	<LI>Changed the name of the hardware registers to match the "official" names.
	<LI>Added support for copying complete functions to RAM or HIRAM (<CODE>memcpy()</CODE> and <CODE>hiramcpy()</CODE> functions). The compiler now automatically generates two symbol for the start and the end of each function, named <CODE>start_X</CODE> and <CODE>end_X</CODE> (where <CODE>X</CODE> is the name of the function). This enables to calculate the length of a function when copying it to RAM.
	<LI>Added the <CODE>ram_fn.c</CODE> example which illustrates how to copy functions to RAM and HIRAM.
	<LI>Added support for installing interrupt handlers.
	<LI>Added the <CODE>irq.c</CODE> example which illustrates how to install interrupt handlers.
	<LI>Added RAM banks support (<CODE>switch_ram_bank()</CODE> function). The <CODE>switch_bank()</CODE> function has been renamed to <CODE>switch_rom_bank()</CODE>. The <CODE>banks.c</CODE> example has been updated. The flags for generating multiple bank images have been modified.
	<LI>It is possible to set the sprite ram location at link time using the <CODE>-Wl-g.OAM=#</CODE> flag (where <CODE>#</CODE> is the address of the sprite ram). The sprite ram address must begin at an address multiple of 0x100, and is 0xA0 bytes long.
</UL>

<H3>Changes in GBDK 2.0b5</H3>

<UL>
	<LI>New documentation (not finished yet).
	<LI>Fixed a bug that could generate wrong code in switch statements.
	<LI>Fixed a bug in <CODE>int</CODE> comparison.
	<LI>Added a DTMF program written by Osamu Ohashi.
	<LI>Added a game (Deep Scan) written by a friend of Osamu.
	<LI>Modified the <CODE>delay()</CODE> function so that it takes a long parameter. It can be used to wait between 1 and 65536 milliseconds (0 = 65536). The <CODE>pause()</CODE> function has been removed.
</UL>

<H3>Changes in GBDK 2.0b4</H3>

<UL>
	<LI>Fixed a bug that could generate wrong code when using hexadecimal constants.
	<LI>A new example (<CODE>galaxy.c</CODE>) has been added. It is the C version of the <CODE>space.s</CODE> example. <CODE>sprite.c</CODE> has been removed.
	<LI>Most of the libraries have been split into small modules for reducing final code size.
</UL>

<H3>Changes in GBDK 2.0b3</H3>

<UL>
	<LI>GBDK can generate multiple-banks images, i.e. images greater than 32kB (see the <CODE>banks</CODE> example).
	<LI>It is possible to set the stack pointer at link time using the <CODE>-Wl-g.STACK=#</CODE> flag (where <CODE>#</CODE> is the address of the stack pointer).
	<LI>Several functions (e.g. <CODE>show_bkg()</CODE>) have been changed into macros (e.g. <CODE>SHOW_BKG</CODE>).
	<LI>The <CODE>delay()</CODE> function waits exactly 1 millisecond, and the <CODE>pause()</CODE> waits 256 milliseconds.
	<LI>Linking with the standard libraries is no more required. The <CODE>lib/gb.lib</CODE> (<CODE>lib\gb.lib</CODE> on DOS) text file contains a list of modules in which to look for undefined symbols. The linker will parse this file, and link your code with the required modules only. The <CODE>stdio</CODE> library has been split in several object files, and only necessary modules will be added to your code, thus reducing its size.
	<LI>The GBDK distribution can be located anywhere in your system if you use the <CODE>-Wo-lccdir=GBDK-DIR</CODE> flag when invoking lcc.
	<LI>Bug fixes.
</UL>

<H3>Changes in GBDK 2.0b2</H3>

<UL>
	<LI>Lots of bug fixes.
	<LI>GBDK has to be in the <CODE>\GBDK-2.0</CODE> directory on DOS machines.
</UL>

<H3>Changes in GBDK 2.0b1</H3>

<UL>
	<LI>The code generator has been completely rewritten with the new version of lcc. It produces much smaller and more efficient code. The size of the code is generally between 20 and 50% smaller. A number of small optimizations are still to be done.
	<LI><B>The size of basic types has been changed:</B>
	<UL>
		<LI>An <CODE>int</CODE> is 8 bits.
		<LI>A <CODE>long</CODE> is 16 bits.
	</UL>
	This change was required for the code generator to produce better code, because the Z80 is actually an 8-bit processor.
	<LI>The linker generates the complement checksum correctly now.
	<LI>The libraries and example programs have been modified for the new code generator.
</UL>

<H3>Changes in GBDK 1.1</H3>

<UL>
	<LI>Removed Xloadimage from the GBDK distribution. It is now available as a separate archive.
	<LI>A compiled DOS version is now available (cross-compiled on my Sun Workstation!).
	<LI>The libraries and the example programs have been improved.
	<LI>The make script has been improved. Compiling on UNIX should be easier.
	<LI>Many bugfixes.
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Downloading"></A>Downloading and Installing</H2>

<P>
Installing GBDK requires the following steps:
</P>

<H3>On UNIX</H3>

<P>
You must have gcc, gnu make and /bin/csh for building GBDK.
</P>

<UL>
	<LI>Get the latest <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/SDK.tar.gz">SDK</A> source  distribution.
	<LI>Uncompress it:
<PRE>
    % gzip -cd SDK.tar.gz | tar xf -
</PRE>
	<LI>Go into the SDK-2.0 (the name may change depending on the version number) directory:
<PRE>
    % cd SDK-2.0
</PRE>
	<LI>At that point, you can modify the makefile to change the installation directory.
	<LI>Compile and install GBDK:
<PRE>
    % make
    % make install
</PRE>
	This will create a directory (<CODE>$HOME/SDK/XX-XX/Y.Y.Y</CODE> by default, where <CODE>XX-XX</CODE> is the target and <CODE>Y.Y.Y</CODE> is the version number) with all the files you need in it.
	<LI>You <B>must</B> compile the libraries before using GBDK. Compile the libraries and the examples:
<PRE>
    % cd $HOME/SDK/XX-XX/Y.Y.Y/lib
    % make
    % cd $HOME/SDK/XX-XX/Y.Y.Y/examples
    % make
</PRE>
	At that point, you don't need the sources anymore and you can delete them.
	<LI>Run the examples with an emulator.
</UL>

<H3>On DOS</H3>

<P>
You must have at least a 386 DX processor, and a DOS Protected Mode Interface (DPMI). For instance, Windows 95 provides a DPMI. You can also get one from <A HREF="ftp://ftp-lse.epfl.ch/pub/felber/emulation/csdpmi3b.zip">here</A>.
</P>

<P>
The GBDK distribution includes a batch file (<CODE>gbdk.bat</CODE>, by Mark Rawer) that automates many of the steps below, and that enables to install the GBDK distribution in any directory. You'll have to edit and modify the first lines of this batch file before executing it.
</P>

<UL>
	<LI>Get the latest <A HREF="http://www.aracnet.com/~pfelber/GBDK/bin/GBDK.zip">GBDK</A> distribution.
	<LI>Uncompress it <B>in the root</B> of one of your drives (you must keep the directory structure when unzipping the archive; this is generally achieved using the <CODE>-d</CODE> flag when invoking <CODE>unzip</CODE>):
<PRE>
    C:&gt; unzip -d GBDK.zip
</PRE>
	This will create a directory (<CODE>\SDK\XX-XX\Y-Y-Y</CODE>, where <CODE>XX-XX</CODE> is the target and <CODE>Y-Y-Y</CODE> is the version number) with all the files you need in it. <B>GBDK must be installed in the root of one of your drives (e.g., <CODE>C:\SDK</CODE>).</B>
	<LI>Make sure that you have a <CODE>TMP</CODE> or <CODE>TEMP</CODE> environment variable that points to a temporary directory.
	<LI>You <B>must</B> compile the libraries before using GBDK. Compile the libraries and the examples:
<PRE>
    C:&gt; cd \SDK\XX-XX\Y-Y-Y\lib
    C:&gt; make
    C:&gt; cd \SDK\XX-XX\Y-Y-Y\examples
    C:&gt; make
</PRE>
	<LI>Run the examples with an emulator.
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Compiler"></A>The Compiler</H2>

<P>
The compiler is based on <A HREF="http://www.cs.princeton.edu/software/lcc/">lcc</A>, a free of charge retargetable compiler for ANSI/ISO C. GBDK includes a code generator for lcc that generates code for the GameBoy custom Z80. For an ehaustive description, read the <A HREF="http://www.cs.princeton.edu/software/lcc/cgi-bin/man2html.cgi?lcc+1">man page</A> included with the lcc distribution.
</P>

<P>
The compiler defines the following sizes for basic types:
</P>

<TABLE BORDER="1">
<TR><TD><B>type</B></TD>
<TD><B>size</B></TD>
<TD><B>min</B></TD>
<TD><B>max</B></TD></TR>

<TR><TD>char</TD>
<TD>1 byte</TD>
<TD>-128</TD>
<TD>127</TD></TR>

<TR><TD>unsigned char</TD>
<TD>1 byte</TD>
<TD>0</TD>
<TD>255</TD></TR>

<TR><TD>int</TD>
<TD>1 byte</TD>
<TD>-128</TD>
<TD>127</TD></TR>

<TR><TD>unsigned int</TD>
<TD>1 byte</TD>
<TD>0</TD>
<TD>255</TD></TR>

<TR><TD>long</TD>
<TD>2 byte</TD>
<TD>-32768</TD>
<TD>32767</TD></TR>

<TR><TD>unsigned long</TD>
<TD>2 byte</TD>
<TD>0</TD>
<TD>65535</TD></TR>

<TR><TD>long long</TD>
<TD>4 byte</TD>
<TD>-2147483648</TD>
<TD>2147483647</TD></TR>

<TR><TD>unsigned long long</TD>
<TD>4 byte</TD>
<TD>0</TD>
<TD>4294967296</TD></TR>

<TR><TD>float</TD>
<TD>4 byte</TD>
<TD>n/a</TD>
<TD>n/a</TD></TR>

<TR><TD>double</TD>
<TD>4 byte</TD>
<TD>n/a</TD>
<TD>n/a</TD></TR>

<TR><TD>pointer</TD>
<TD>2 byte</TD>
<TD>n/a</TD>
<TD>n/a</TD></TR>
</TABLE>

<P>
Since the CPU is an 8-bit processor, working with <CODE>int</CODE> values is much more efficient than working with <CODE>long</CODE> values. But you have to be careful with overflows.
</P>

<P>
When generating a GameBoy image, the linker will look for undefined symbols in each of the object files listed in the <CODE>lib/gb.lib</CODE> text file. If one of these object files contains the symbol, it will be linked with the main program. If none of these object files contain the symbol, the linker will generate an error. Therefore, there is no need to explicitely link the main program with the standard libraries.
</P>

<P>
Here are some examples of lcc usage:
</P>

<UL>
	<LI>Compile a C source file (<CODE>source.c</CODE>) and generate a GameBoy image (<CODE>image.gb</CODE>):
</UL>
<PRE>
    lcc -o image.gb source.c
</PRE>

<UL>
	<LI>Assemble an assembly source file (<CODE>source.s</CODE>) and generate a GameBoy image (<CODE>image.gb</CODE>):
</UL>
<PRE>
    lcc -o image.gb source.s
</PRE>

<UL>
	<LI>Compile a C source file (<CODE>source.c</CODE>) and generate an object file (<CODE>object.o</CODE>):
</UL>
<PRE>
    lcc -c -o object.o source.c
</PRE>

<UL>
	<LI>Assemble an assembly source file (<CODE>source.s</CODE>) and generate an object file (<CODE>object.o</CODE>):
</UL>
<PRE>
    lcc -c -o object.o source.s
</PRE>

<UL>
	<LI>Link two object files (<CODE>object1.o</CODE> and <CODE>object2.o</CODE>) and generate a GameBoy image (<CODE>image.gb</CODE>):
</UL>
<PRE>
    lcc -o image.gb object1.o object2.o
</PRE>

<UL>
	<LI>Generate a GameBoy image (<CODE>image.gb</CODE>) from an assembly source file (<CODE>source.s</CODE>), a C source file (<CODE>source.c</CODE>), and an object file (<CODE>object.o</CODE>):
</UL>
<PRE>
    lcc -o image.gb source.s source.c object.o
</PRE>

<P>
The following flags allow to pass options to the preprocessor, the compiler, the assembler, and the linker:
</P>
<PRE>
    -Wp
    -Wf
    -Wa
    -Wl
</PRE>

<P>
A typical useage of these flags is for generating listing and map files:
</P>

<UL>
	<LI>A listing file is produced by the assembler if you use the <CODE>-Wa-l</CODE> flag. The name of this file is the same as the object file, with the <CODE>.lst</CODE> extension. It contains the assembly code and source. If the assembler generates error messages, listing files are necessary for locating these errors.
	<LI>A map file is produced by the linker if you use the <CODE>-Wl-m</CODE> flag. The name of this file is the same as the image file, with the <CODE>.map</CODE> extension. It contains informations about where functions and variables are located in ROM. If the linker generates error messages, map files are useful for locating these errors.
	<LI>A symbol file for the no$gmb emulator is produced by the linker if you use the <CODE>-Wl-j</CODE> flag. The name of this file is the same as the image file, with the <CODE>.sym</CODE> extension. It contains informations that can be used by the no$gmb built-in debugger.
</UL>

<P>
It is generally a good habit to generate listing and map files.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Assembler"></A>The Assembler</H2>

<P>
The assembler is based on <A HREF="http://shop-pdp.kent.edu/ashtml/asxxxx.htm">ASxxxx Cross Assemblers</A>.
</P>

<P>
The GameBoy processor is very similar to the Z80, although some of the instructions are missing and some ther have been added. Also, she second set of registers (BC', DE', HL', AF') and the index registers (IX, IY) are missing and, consequently, there are no DD and FD opcode tables. Finally, I/O ports are gone and so are all IN/OUT opcodes. For a descriptions of the changed instructions, read the <A HREF="http://www.komkon.org/fms/GameBoy/">GameBoy FAQ</A>.
</P>

<P>
I have modified the name of some of the GB-specific opcodes:
</P>
<PRE>
    LD (HLI),A      -&gt; LD (HL+),A
    LD (HLD),A      -&gt; LD (HL-),A
    LD A,(HLI)      -&gt; LD A,(HL+)
    LD A,(HLD)      -&gt; LD A,(HL-)
    ADD SP,offset   -&gt; LDA SP,offset(SP)
    LDHL SP,offset  -&gt; LDA HL,offset(SP)
</PRE>

<P>
The <CODE>LDA</CODE> opcode means &quot;load address&quot;, like in 68x00 assembly. I've called these instructions like this because both are orthogonal (they do the same thing on two different registers).
</P>

<P>
The assembler accepts the following flags:
</P>
<PRE>
ASxxxx Assembler V01.75  (GameBoy Z80-like CPU)
 
Usage: [-dqxgalopsf] outfile file1 [file2 file3 ...]
  d    decimal listing
  q    octal   listing
  x    hex     listing (default)
  g    undefined symbols made global
  a    all user symbols made global
  l    create list   output outfile[LST]
  o    create object output outfile[o]
  s    create symbol output outfile[SYM]
  p    disable listing pagination
  f    flag relocatable references by  `   in listing file
 ff    flag relocatable references by mode in listing file
</PRE>

<P>
For an ehaustive description, read the <CODE>asmlnk.doc</CODE> file in the <CODE>doc</CODE>
directory, or <A HREF="http://shop-pdp.kent.edu/ashtml/asxdoc.htm">this html-ized document</A>.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Linker"></A>The Linker</H2>

<P>
The linker is based on <A HREF="http://shop-pdp.kent.edu/ashtml/asxxxx.htm">ASxxxx Cross Assemblers</A>. It has been extended in particular to support generation of GameBoy images.
</P>

<P>
The linker accepts the following flags:
</P>
<PRE>
ASxxxx Linker V01.75
 
Startup:
  --   [Commands]              Non-interactive command line input
  -c                           Command line input
  -f   file[LNK]               File input
  -p   Prompt and echo of file[LNK] to stdout (default)
  -n   No echo of file[LNK] to stdout
Usage: [-Options] outfile file [file ...]
Libraries:
  -k    Library path specification, one per -k
  -l    Library file specification, one per -l
Relocation:
  -b   area base address = expression
  -g   global symbol = expression
  -yo  Number of rom banks (default: 2)
  -ya  Number of ram banks (default: 0)
  -yt  MBC type (default: no MBC)
  -yn  Name of program (default: name of output file)
  -yp# Patch one byte in the output GB file (# is: addr=byte)
Map format:
  -m   Map output generated as file[MAP]
  -j   no$gmb symbol file generated as file[SYM]
  -x   Hexidecimal (default)
  -d   Decimal
  -q   Octal
Output:
  -i   Intel Hex as file[IHX]
  -s   Motorola S19 as file[S19]
  -z   Gameboy image as file[GB]
List:
  -u    Update listing file(s) with link data as file(s)[.RST]
End:
  -e   or null line terminates input
</PRE>

<P>
For an ehaustive description, read the <CODE>asmlnk.doc</CODE> file in the <CODE>doc</CODE>
directory, or <A HREF="http://shop-pdp.kent.edu/ashtml/asxdoc.htm">this html-ized document</A>.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Libraries"></A>The Include Files and Libraries</H2>

<P>
Several include files are part of GBDK. Some of them only define useful macros (with no code associated), while others define functions implemented in separate object modules. The libraries are split in several small object files in order to reduce the size of the final image file (only the required modules are linked with the main program). The include files and libraries are divided in the following groups:
</P>

<H3>Runtime support</H3>

<P>
The <CODE>crt0.o</CODE> object module contains the basic C runtime library, with GameBoy initialization routines, C support and other essential things. This library is required and automatically linked with every program.
</P>

<P>
The <CODE>gb.h</CODE> include file defines basic GameBoy-related macros and functions. It also includes the <CODE>hardware.h</CODE> file that defines GameBoy hardware registers.
</P>

<H3>Standard C libraries</H3>

<P>
The <CODE>ctype.h</CODE>, <CODE>stdarg.h</CODE>, <CODE>stdlib.h</CODE>, <CODE>string.h</CODE>, and <CODE>types.h</CODE> include files define some functions found in the standard C libraries.
</P>

<H3>Console Input/Output</H3>

<P>
Basic console I/O is provided through a set of functions defined in the <CODE>console.h</CODE> and <CODE>stdio.h</CODE> include files. Note that console I/O uses most of the tiles and sprites of the GameBoy, and thus is not easily mixable with graphics programs.
</P>

<H3>Simple Graphic Library</H3>

<P>
Simple graphic functions for drawing points and images on the screen are defined in the <CODE>drawing.h</CODE> include file. Note that the graphic library uses most of the tiles and sprites of the GameBoy.
</P>

<H3>Misc Libraries</H3>

<P>
The <CODE>rand.h</CODE> include file defines functions for using the GBDK random generator.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Examples"></A>The Example Programs</H2>

<P>
GBDK includes several example programs both in C and in assembly. They are located in the <CODE>examples</CODE> directory, and in its subdirectories. They can be build by typing <CODE>make</CODE> in the correnponding directory.
</P>

<H3><CODE>space.s</CODE></H3>

<CENTER>
<P>
<IMG ALT="[galaxy/space]" SRC="galaxy.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>space.s</CODE> example is an assembly program that demonstrates the use of sprites, window, background, fixed-point values and more. The following keys are used:
</P>
<PRE>
    Arrow keys     : Change the speed (and direction) of the sprite
    Arrow keys + A : Change the speed (and direction) of the window
    Arrow keys + B : Change the speed (and direction) of the background
    START          : Open/close the door
    SELECT         : Basic fading effect
</PRE>

<H3><CODE>galaxy.c</CODE></H3>

<P>
The <CODE>galaxy.c</CODE> example is a C translation of the <CODE>space.s</CODE> assembly program.
</P>

<H3><CODE>paint.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[paint]" SRC="paint.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>paint.c</CODE> example is a painting program. It supports different painting tools, drawing modes, and colors. At the moment, it only paints individual pixels. This program illustrates the use of the full-screen drawing library. It also illustrates the use of generic structures and big sprites. It is definitely worth having a look at its source. The following keys are used:
</P>

<PRE>
    Arrow keys : Move the cursor
    SELECT     : Display/hide the tools palette
    A          : Select tool
</PRE>

<H3><CODE>sound.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[sound]" SRC="sound.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>sound.c</CODE> example is meant for experimenting with the soung generator of the GameBoy (to use on a real GameBoy). The four different sound modes of the GameBoy are available. It also demonstrates the use of bit fields in C (it's a quick hack, so don't expect too much from the code). The following keys are used:
</P>

<PRE>
    UP/DOWN      : Move the cursor
    RIGHT/LEFT   : Increment/decrement the value
    RIGHT/LEFT+A : Increment/decrement the value by 10
    RIGHT/LEFT+B : Set the value to maximum/minimum
    START        : Play the current mode's sound (or all modes if in control screen)
    START+A      : Play a little music with the current mode's sound
    SELECT       : Change the sound mode (1, 2, 3, 4 and control)
    SELECT+A     : Dump the sound registers to the screen
</PRE>

<H3><CODE>rpn.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[rpn]" SRC="rpn.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>rpn.c</CODE> example is a basic RPN calculator. Try entering expressions like <CODE>12 134*</CODE> and then <CODE>1789+</CODE>.
</P>

<H3><CODE>banks.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[banks]" SRC="banks.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>banks.c</CODE> example illustrates how to make multiple-banks programs.
</P>

<H3><CODE>ram_fn.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[ram_fn]" SRC="ram_fn.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>ram_fn.c</CODE> example illustrates how to copy functions to RAM or HIRAM, and how to call them from C.
</P>

<H3><CODE>irq.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[irq]" SRC="irq.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>irq.c</CODE> example illustrates how to install interrupt handlers.
</P>

<H3><CODE>comm.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[comm]" SRC="comm.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>comm.c</CODE> example illustrates how to use communication routines.
</P>

<H3><CODE>gb-dtmf/gb-dtmf.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[gb-dtmf]" SRC="gb-dtmf.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>gb-dtmf/gb-dtmf.c</CODE> program, written by <A HREF="mailto:ooo@tky0.attnet.or.jp">Osamu Ohashi</A>, is a Dual Tone Multi-Frequency (DTMF) generator.
</P>

<H3><CODE>colorbar/colorbar.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[colorbar]" SRC="colorbar.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>colorbar/colorbar.c</CODE> program, written by Mr. N.U. of TeamKNOx, illustrates the use of colors on a Color GameBoy.
</P>

<H3><CODE>dscan/dscan.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[dscan]" SRC="dscan.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
Deep Scan (<CODE>dscan/dscan.c</CODE>) is a game written by Mr. N.U. of TeamKNOx that supports the Color GameBoy. Your aim is to destroy the submarines from your boat, and to avoid the projectiles that they send to you. The game should be self-explanatory. The following keys are used:
</P>
<PRE>
    RIGHT/LEFT   : Move your boat
    A/B          : Send a bomb from one side of your boat
    START        : Start game or pause game

    When game is paused:

    SELECT       : Invert A and B buttons
    RIGHT/LEFT   : Change speed
    UP/DOWN      : Change level
</PRE>

<H3><CODE>rand.c</CODE></H3>

<CENTER>
<P>
<IMG ALT="[rand]" SRC="rand.gif" WIDTH="172" HEIGHT="180" BORDER="1">
</P>
</CENTER>

<P>
The <CODE>rand.c</CODE> program, written by <A HREF="mailto:lucv@criterion.canon.co.uk">Luc Van den Borre</A>, illustrates the use of the GBDK random generator.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Guidelines"></A>GBDK Programming Guidelines</H2>

<UL>
	<LI>Use 8-bit values as much as possible.
	<LI><B>Prefer unsigned variables to signed ones.</B> The code generated will be generally more efficient, espacially when comparing two values.
	<LI>Using global variables is generally more efficient that using local variables. In particular, <B>avoid big local variables</B> (such as arrays or structures). The code could be inefficient if you have more than 127 bytes of local variables.
	<LI>The lcc compiler does not fold every possible constant expression. For instance, in the following code:
<PRE>
    foo(i + 2 - 1);
</PRE>
	lcc will add 2 and substract 1, instead of just adding 1. In this situation, you should parenthesize then constant expression:
<PRE>
    foo(i + (2 - 1));
</PRE>

	<LI>Try to use only the following type definitions for integer variables (defined in <CODE>type.h</CODE>):
<PRE>
    BYTE
    UBYTE
    WORD
    UWORD
    LWORD
    ULWORD
</PRE>
	or
<PRE>
    INT8
    UINT8
    INT16
    UINT16
    INT32
    UINT32
</PRE>
	That way, you will always know the size of your variables.
	<LI>When using constants, use the <CODE>U</CODE>, <CODE>L</CODE> and <CODE>UL</CODE> postfixes when necessary. <CODE>U</CODE> specifies that the constant is unsigned, while <CODE>L</CODE> specifies that the constant is long. Consider the following example:
<PRE>
    UBYTE i, j = 0;
    i = j+0x80;
</PRE>
	The compiler will think that <CODE>0x80</CODE> is a signed value, and since it is bigger than the biggest signed 8-bit value (0x79), the compiler will treat it as a long constant. Following the C specification, <CODE>j</CODE> will be extended to a long, and added to <CODE>0x80</CODE> using a long addition (which is costly on an 8-bit processor), before beeing truncated to an 8-bit value and assigned to <CODE>i</CODE>. This example should be written:
<PRE>
    UBYTE i, j = 0;
    i = j+0x80U;
</PRE>
	<LI>Avoid using multiplications, divisions and modulos as much as possible. These operations have no corresponding CPU instructions (software functions), and hence are time costly.
	<LI>Do not declare initialized variables at the file level, except when they are read-only, because they will be located in ROM, e.g. 
<PRE>
    int i1;          /* OK    : will be located in RAM */
    char *s1;        /* OK    : will be located in RAM */
    int i2 = 0;      /* Error : will be located in ROM */
    char *s2 = &quot;Hi&quot;; /* Error : will be located in ROM */

    void main() { ... }
</PRE>
	<LI>Prefer the <CODE>==</CODE> and <CODE>!=</CODE> comparison operators to <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, <CODE>&gt;</CODE>, and <CODE>&gt;=</CODE>. The code will be shorter and quicker. For instance:
<PRE>
    for(i = 0; i &lt; 10; i++)
</PRE>
   is less efficient than
<PRE>
    for(i = 0; i != 10; i++)
</PRE>
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Porting"></A>Porting Code from GBDK 1.1 to GBDK 2.0</H2>

<UL>
	<LI>Change your <CODE>int</CODE> variables to <CODE>long</CODE> if they have to be bigger than 255. If they should only contain values between 0 and 255, use an <CODE>unsigned int</CODE>.
	<LI>If your application uses the <CODE>delay</CODE> function, you'll have to adapt your delay values.
	<LI>Several functions have new names. In particular some of them have been changed to macros (e.g. <CODE>show_bkg()</CODE> is now <CODE>SHOW_BKG</CODE>).
	<LI>You will probably have to change the name of the header files that you include.
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Mixing"></A>Mixing C and Assembly</H2>

<P>
For mixing C and assembly, you must use one file per language (you cannot embed C code with assembly) and link both files together. Here are the things to know:
</P>

<UL>
	<LI>A C identifier <CODE>i</CODE> will be called <CODE>_i</CODE> in assembly.
	<LI>Results are always returned into the <CODE>DE</CODE> register.
	<LI>Parameters are always passed on the stack (starting at <CODE>SP+2</CODE> because the return address is also saved on the stack).
	<LI>Assembly identifier are exported using the <CODE>.globl</CODE> directive.
	<LI>You can access GameBoy hardware registers using <CODE>_reg_0xXX</CODE> where <CODE>XX</CODE> is the register number (see <CODE>sound.c</CODE> for an example).
	<LI>Registers must be preserved across function calls (you must store them at function begin, and restore them at the end), except <CODE>HL</CODE> (and <CODE>DE</CODE> when the function returns a result).
</UL>

<P>
Here is an example of how to mix assembly with C:
</P>

<H3><CODE>main.c</CODE></H3>

<PRE>
    main()
    {
      WORD i;
      WORD add(WORD, WORD);

      i = add(1, 3);
    }
</PRE>

<H3><CODE>add.s</CODE></H3>

<PRE>
    .globl _add
    _add:         ; WORD add(WORD a, WORD b)
                  ; There is no register to save:
                  ;  BC is not used
                  ;  DE is the return register
                  ;  HL needs never to be saved
    LDA  HL,2(SP)
    LD   E,(HL)   ; Get a in DE
    INC  HL
    LD   D,(HL)
    INC  HL
    LD   A,(HL)   ; Get b in HL
    INC  HL
    LD   H,(HL)
    LD   L,A
    ADD  HL,DE    ; Add DE to HL
    LD   D,H
    LD   E,L
                  ; There is no register to restore
    RET           ; Return result in DE
</PRE>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Multiple"></A>Multiple Bank Images</H2>

<P>
GBDK can generate multiple bank images (with both multible ROM and RAM banks) for MBC1 and MBC2 memory bank controllers. Multiple RAM banks are only supported by MBC 1.
</P>

<P>
With multiple ROM banks, addresses 0x0000 to 0x3FFF are reserved for the fixed ROM bank, while addresses 0x4000 to 0x7FFF are switchable, i.e. can be used for any bank. Switchable ROM banks are called <CODE>_CODE_1</CODE>, <CODE>_CODE_2</CODE>,... and the fixed ROM bank is called <CODE>_CODE</CODE> (note that there is no <CODE>_CODE_0</CODE>). The maximum number of ROM banks is 32.
</P>

<P>
Addresses 0xC000 to 0xDFFF are always reserved for the internal RAM. Addresses 0xA000 to 0xBFFF are reserved for (switchable) external RAM. External RAM banks are called <CODE>_BSS_0</CODE>, <CODE>_BSS_1</CODE>, <CODE>_BSS_2</CODE>,... and internal RAM is called <CODE>_BSS</CODE>. The maximum number of external RAM banks is 4.
</P>

<P>
When deciding how to populate your RAM banks, remember that local variables are always allocated on the stack, and initialized global variables are located in ROM. Only uninitialized global or static variables are allocated into RAM.
</P>

<P>
For generating multiple bank images, you have to:
</P>

<UL>
	<LI>Place the code for your ROM bank in one or several source files. All the code of the source file(s) will be in the same ROM bank.
	<LI>Compile the source file into an object file, and specify in which ROM bank to locate the code using the <CODE>-Wf-bo#</CODE> flag (where <CODE>#</CODE> is the number of the bank, greater than 0). If you do not use this flag, the code will be located in the fixed ROM bank.
	<LI>Place the code for your RAM bank in one or several source files. All the data of the source file(s) will be in the same RAM bank.
	<LI>Compile the source file into an object file, and specify in which RAM bank to locate the code using the <CODE>-Wf-ba#</CODE> flag (where <CODE>#</CODE> is the number of the bank, greater or equal to 0). If you do not use this flag, the data will be located in the internal RAM.
	<LI>Repeat this for all your banks. You can also use both flags on the same file to locate code and data in different ROM and RAM banks.
	<LI>Link the object files, and specify the number of banks using the <CODE>-Wl-yo#</CODE> (for ROM) and <CODE>-Wl-ya#</CODE> (for RAM) flags (where <CODE>#</CODE> is the number of banks), and the type of MBC used in the cartridge using the <CODE>-Wl-yt#</CODE> flag (where <CODE>#</CODE> is the cartridge type code to be located at address 0x147 of the image).<BR>
	Standard supported ROM sizes are:
<PRE>
  256Kbit =  32KByte =   2 banks
  512Kbit =  64KByte =   4 banks
    1Mbit = 128KByte =   8 banks
    2Mbit = 256KByte =  16 banks
    4Mbit = 512KByte =  32 banks
</PRE>
	Standard supported RAM sizes are:	
<PRE>
     None
   64kBit =  8kB = 1 bank
  256kBit = 32kB = 4 banks
</PRE>
	Standard supported cartridge types are:
<PRE>
  0 : ROM ONLY
  1 : ROM+MBC1
  2 : ROM+MBC1+RAM
  3 : ROM+MBC1+RAM+BATTERY
  5 : ROM+MBC2
  6 : ROM+MBC2+BATTERY
</PRE>
</UL>

<P>
Bank switching is not automatic in programs. You have to explicitely call the <CODE>switch_rom_bank()</CODE> and <CODE>switch_ram_bank()</CODE> functions. See <CODE>banks.c</CODE> for a complete example.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="RAM"></A>Copying Functions to RAM and HIRAM</H2>

<P>
It is possible to copy functions to RAM and HIRAM (using the <CODE>memcpy()</CODE> and <CODE>hiramcpy()</CODE> functions), and execute them from C. The compiler automatically generates two symbol for the start and the end of each function, named <CODE>start_X</CODE> and <CODE>end_X</CODE> (where <CODE>X</CODE> is the name of the function). This enables to calculate the length of a function when copying it to RAM. Ensure you have enough free space in RAM or HIRAM for copying a function.
</P>

<P>
There are basically two ways for calling a function located in RAM, HIRAM, or ROM:
</P>

<UL>
	<LI>Declare a pointer-to-function variable, and affect it the address of the function to call.
	<LI>Declare the function as <CODE>extern</CODE>, and set its address at link time using the <CODE>-Wl-gXXX=#</CODE> flag (where <CODE>XXX</CODE> is the name of the function, and <CODE>#</CODE> is its address).
</UL>

<P>
The second approach is slightly more efficient. Both approaches are illustrated in the <CODE>ram_fn.c</CODE> example.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Interrupt"></A>Interrupt Handlers</H2>

<P>
The GameBoy hardware can generate 5 types of interrupts:
</P>
<PRE>
  VBL : V-blank
  LCD : LCDC status
  TIM : Timer overflow
  SIO : Serial I/O transfer end
  JOY : Transition from high to low of joypad
</PRE>

<P>
It is possible to install your own interrupt handlers (in C or in assembly) for any of these interrupts. Up to 7 interrupt handlers can be installed for each interrupt. Interrupt handlers are called in sequence. To install a new interrupt handler, do the following:
</P>

<UL>
	<LI>Write a function (say <CODE>foo()</CODE>) that takes no parameter, and that returns nothing. Remember that the code executed in an interrupt handler must be short.
	<LI>Install you interrupt handling routines using the <CODE>add_XXX()</CODE> function, where <CODE>XXX</CODE> is the interrupt that you want to handle.
	<LI>Enable interrupts for the IRQ you want to handle, using the <CODE>set_interrupts()</CODE> function. Note that the VBL interrupt is already enabled before the <CODE>main()</CODE> function is called. If you want to set the interrupts before <CODE>main()</CODE> is called, you must install an initialization routine.
</UL>

<P>
See <CODE>irq.c</CODE> for a complete example.
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Initialization"></A>Initialization Routine</H2>

<P>
You can install a routine that will be executed before the <CODE>main()</CODE> function is called, and just before the interrupts are enabled. For instance, you can use an initialization routine to modify the interrupt flags and avoid that a VBL IRQ is handled before <CODE>main()</CODE> is executed. For installing an initialization routine, you have to:
</P>

<UL>
	<LI>Write a function (say <CODE>foo()</CODE>) that takes no parameter, and that returns nothing.
	<LI>At link time, specify the name of the initialization routine using the <CODE>-Wl-g.init=XXX</CODE> flag (where <CODE>XXX</CODE> is the name of your function). Remember that your function will have an initial underscore in assembly. In our example, it will be <CODE>-Wl-g.init=_foo</CODE>.
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Changing"></A>Changing Important Addresses</H2>

<P>
It is possible to change the addresses of some important data at link time using the <CODE>-Wl-gXXX=YYY</CODE> flag (where <CODE>XXX</CODE> is the name of the data, and <CODE>YYY</CODE> is the new address). The addresses that can be changed are:
</P>
<PRE>
  .OAM         : Location of sprite ram (requires 0xA0 bytes)
  .STACK       : Initial stack address
  .refresh_OAM : Address to which the routine for refreshing OAM will be copied (must be in HIRAM)
  .init        : Initialization routine
</PRE>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Troubleshooting"></A>Troubleshooting</H2>

<H3>Assembly Errors</H3>

<P>
Messages of the type:
</P>
<PRE>
    u 0226
    a 0329
    u 0333
</PRE>

<P>
are error messages from the assembler. To see where these errors occur, you should produce an assembly listing using the <CODE>-Wa-l</CODE> flag of lcc and have a look at this file. If such an error occurs with a file generated by the compiler, send me the C source along with the listing.
</P>

<H3>Link Errors</H3>

<P>
Messages of the type:
</P>
<PRE>
    ?ASlink-W-Undefined Global     .count referenced by module Demo
</PRE>

<P>
are error messages from the linker. An image file is generated, but sould be corrupted. Detailed information about errors can be found in map files (generated using the <CODE>-Wl-m</CODE> flag of lcc).
</P>

<H3>DOS Shell Errors</H3>

<P>
The DOS shell truncates commmand lines to something like 128 characters. If you have to use a longer line due to the number of flags you pass to the compiler, I strongly encourage you to get <CODE>bash</CODE>, a DOS port of Unix Bourne-Again SHell. It is much more powerful than DOS shell, and does not truncate command lines. A better alternative is to get <CODE>make</CODE>, a DOS port of the Unix make utility, and use makefiles instead of DOS batch files. Of course, you can get both. They are available as part of <A HREF="http://www.delorie.com/djgpp/">DJGPP</A> (DOS port of GNU C).
</P>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Problems"></A>Known Problems</H2>

<H3>Known problems in GBDK 2.0</H3>

<UL>
	<LI>The maximum number of indexes for an array is 127. This is due to the fact that lcc uses integer values for array indexes. This does not affect statically-initialized arrays like:
<PRE>
    UBYTE tiles[] = { 0x00, 0x01, ..., 0xFF };
</PRE>
	But declaring the following arrays cause a compiler error:
<PRE>
    UBYTE tiles[128];
</PRE>
	Here is the answer sent to me by Dave Hanson, one of the authors of lcc:
<P>
<CITE>
This is actually the most serious problem. ANSI C stipulates 32Kb as the maximum size of any object. lcc does indeed assume that an int can hold 16-bit values, because it uses ints to hold sizes (e.g., in type structures). Accepting long array sizes would be no problem, and it would work OK as long as the machine on which lcc runs has 16-bit ints. But changing "int" to "long" for every variable/field that holds a size would be painful and would involve touching every module.
</CITE>
</P>
	A workaround for this problem is to declare multiple-dimensions arrays, and to use them as single-dimension arrays:
<PRE>
	UBYTE tiles[64][8]; /* This declares an array of 64*8 = 512 unsigned bytes */

	void foo() {
	  UWORD l;
	  ((UBYTE *)tiles)[500] = 0;
	  l = 500;
	  ((UBYTE *)tiles)[l] = 0;
	}
</PRE>
	<LI>The code generator might crash when working with programs that contains very complex expressions.
</UL>

<!-- ############################################################ -->
<HR>

<H2><A NAME="Links"></A>Links</H2>

<H3>GBDK Documentation and Support Files</H3>

<UL>
	<LI><A HREF="http://www.pcmedia.co.nz/~michaelh/">Michael Hope's Web Page</A> 
	<LI><A HREF="http://freespace.virgin.net/stephen.blanksby/">Grooves Development Site</A> 
</UL>

<H3>GBDK Ports</H3>

<UL>
	<LI><A HREF="http://www.df.lth.se/~glue/AmigaProjects.html">GBDK for Amiga</A> 
</UL>

<H3>Technical informations on the GameBoy</H3>

<UL>
	<LI><A HREF="http://www.komkon.org/fms/GameBoy/">Nintendo GameBoy Homepage</A>
	<LI><A HREF="http://home.hiwaay.net/~jfrohwei/gameboy/home.html">Jeff Frohwein's Technical Information Page</A>
</UL>

<!-- ############################################################ -->

<P>
<A HREF="../emul.html">Back</A>
</P>

<!-- #include "PF footer.incl" -->
<HR>
Last Updated 21-Apr-99, <A HREF="mailto:pfelber@aracnet.com">Pascal Felber</A>
<!-- end include -->

</BODY>
</HTML>
