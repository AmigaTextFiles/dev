				Asm05

	   Fast Assembly Tool for the MC68HC05 series microcontrollers

Asm05 is an assembler set up to turn an ascii text file into an 8192 byte
binary image ready for chip programming.

 usage: Asm05 <source file name> [flag] [flag] [flag] [flag]

The source file name would normally have a ".asm" extension. If no errors are
found during assembly an image file is created with a ".img" extension.

The first optional flag signifies the target processor. The default is the
MC68HC705C8.
 flag "a" MC68HC805C4 -  4k of flash memory (EEPROM)        -  8K image.
      "b" MC68HC705C8 -  7k of EPROM memory (window or OTP) -  8k image.
      "c" MC68HC705C9 - 15k of EPROM memory (window or OTP) - 16k image.
The main purpose of this flag is to sort out the size of the binary image
that will be generated. Also the MC68HC705C8 has an unusual binary image that
needs to be padded with $00 bytes rather than the normal $FF. There is a
wide range of processors in the 6805 family but they all conform to one
of the three variations above as far as assembling binary images.

The optional flag "s" instructs the assembler to generate a symbol list.
This symbol list is a text file with a .sym extension. This file lists the
address in hex of each lable. This may be necessary for debug purposes.

The optional flag "d" instructs the assembler to generate a debug file. The
debug file is used by various realtime debug commands to find out the address
of variables. This binary file is stored in the temporary directory (usually
on the RAM disk) as T:DebugV.bin. This file must be present and up to date
before any realtime debug commands can be used.

The optional flag "v" instructs the assembler to generate a variable list
The variable list is useful for checking what memory locations have been
allocated to variable by the auto allocator

The optional flag "p" instructs the assembler to assemble a "project". A
project is simply a list of assembler files. So insted of putting all your
code into one file you can split it up into modules. Make a list of
the files in your project. Assemble this list with the "p" option. The
project list must have each file name (and path if necessary) on a seperate
line with no comments.


As an example to assemble say three source modules into a binay image ready
for programming a MC68HC705C9 chip. And generate a symbol list. And generate
an error text file. At the CLI ..
 join file1.asm file2.asm file3.asm as file.asm
 Asm05 >errors file.asm c s
If all is successful this will generate file.img, file.sym and errors a
text file with status information.

This is a non standard assembler that uses a mix of 6805 6502 and Intel
assembly syntax. All opcodes are 3 bytes long. This approach simplifies
reassembly on different processors with other FAST assemblers. Don't
panic the assembly syntax closely follows factory 6805 syntax so it is easy
to convert if necessary (see convert.doc).

Instruction Format

 .uses typical assembler format

label field	op code field	address field	comment field

loop		LDA		$51		;A = value at loc $51
		ADC		#$01		;A = A + 1
		BBS		$6C.2 loop	;if bit 2 at $6C set 
						;  goto loop

Rom Labels

for nameing locations in ROM for subroutine calls branching etc.
 .Romlabels MUST begin at the first character on a line
 .rom labels can be of any length but only the first 8 characters are
  distinguished
 .upper and lower case characters ARE distinguished
 .rom labels MUST begin with a lower case letter a..z
 .rom lables must not begin with an upper case letter
  this is reserved for declaring variables (see below)
 .rom lables must not begin with a numeric character
  they is reserved for branch lables (see below)
 .you can use rom labels with branch instructions
 .all rom labels are global ie they can be accessed from any module

example
	JSR doit
	...

doit	LDA #$00
        ...

table   $00,$01,$02


Branch Labels

this type of lable is reserved for branch instructions (relative addressing)
and is useful for making code more modular ie you don't have to dream up
lots of different label names.
 .branch labels consist of a single numeric char 1..8
 .branch labels are referenced foward or back with arrow operators
 .be careful the assembler picks up the first lable it finds foward
  or back ie don't try & branch over a label with the same name 

example

1	LDA table,X	;
	STA buffer,X	;
	DEC X		;
	BNE 1<-		;
	BRA ->2		;
	NOP		;
2	NOP		;
	

Op Code Field

 .all codes consist of 3 characters followed by whitespace (space,tab,rtn)
 .upper and lower case IS NOT distinguished
 .op code field must not start at the begining of the line 
 .Motorola 4 char & 5 char codes have been converted to 3 character  format

  substitute 3 character codes

  Motorola	FAST6805	Function
   BHCC		 BFC		Branch if half carry Flag Clear
   BHCS		 BFS		Branch if half carry Flag Set

   BRSET	 BBS		Branch if Bit Set
   BRCLR	 BBC		Branch if Bit Clear
   BSET		 SMB		Set Memory Bit
   BCLR		 CMB		Clear Memory Bit

   STOP		 STP		stop
   WAIT		 WAI		wait

   INCX		 INC X		note the address field is seperated
   DECX		 DEC X
   RORX		 ROR X

  additional codes allowed (but not recomended)

   INX			Increment X register short for INC X
   DEX			Decrement X register short for DEC X

Pseudo Ops

Pseudo Ops direct the assembler during assembly, they place no code in the
map file. This assembler has only two. 

  psop		example			comment

  ORG		ORG $0100		set origin of code in memory map
					default is $0100
					more than one ORG may appear in file
					code overlapping is not checked 
  END		END			denotes end of processing 
					end is compulsory

Data Tables

Data tables are used to load bytes directly into memory. For the sake
of portability to other assemblers it is recomended you use the "," as
a seperator.

 .unlike other assemblers db pseudo op is not used
 .data tables must start in op code field
 .only hex format recognised
 .valid separators are comma blank or tab

  example
  $8C,8c,$ff,$FF,$CC,$CC,$CC
  $8C 8c $ff $FF $CC $CC $CC 	;comment 


Ascii Text
To load text directly into ROM just enclose the text in inverted
commas on a seperate line in the opcode field. 

  example
	ORG $2000
	"this text will go into ROM @ loc $2000"

Vector Addresses 

It is sometimes required to place the value of a label (an address) directly
into memory. An address table is required for the interupt and reset vectors
for example.

  .use the # symbol to tell the assembler to place a label value 
  .vector addresses appear in the op code field
  .only one entry is allowed per line

  example
		ORG $1FF4		;vectors are here in the HC05C8
  		#spi_int		;spi inteface interupt vector
  		#sci_int		;sci inteface interupt vector
  		#timer_int		;timer interupt vector
  		#irq_int		;interrupt request vector
  		#sw_int			;software interupt vector
		$01 $40			;reset fixed at loc $0140 

Address Field

 .must be separated by white space from op code field
 .12 addressing modes supported

    name		example		comment

    Inherent		INC		A register is implied
			INX		X register is specified in op code
			MUL		A & X register implied
  			RTS		control instruction		
    Register A		INC A		same code generated as inherent
    Register X		ROR X		"X" must appear in address field
    Immediate		LDA #$00	only hex supported
			LDA BUFFSIZE	predefined constant - no # like C
    Direct		STA $51		write directly into page zero
			STA Variable	write directly to a predefined variable
    Extended		LDA $0100	
			LDX label	
    Indexed		ADD ,X		"," compatable with motorola syntax
			ADD @X  	"@" is easier to spot
    Indexed Page Zero	ADC $58,X	no lables allowed with RAM addressing
    Indexed Extended	JSR $0F00,X	
			EOR table,X	
    Relative		BRA loop	lables only with relative
			BSR doit	
			BEQ ->1		local branch foward
			BNE 8<-		local branch back
    Bit set clear	SMB $8C.0	set least significant bit at loc $8C
			CMB $8C.7	clear most significant bit at loc $8C
			CMD MyFLAG	yes you can define names for each bit
    Bit tst & br	BBS $5F.3 lbl	branch to label lbl if bit 3 at loc
					$5F is set
  			BBC $5F.0 lbl	branch to label lbl if bit 3 at loc
					$5F is clear
			BBC MyFLAG lbl	branch on a bit field variable
			BBC MyFLAG ->1	branch fwd on a bit field variable

Comment Field

 .denoted by ";" or "*" character
 .everything to the right of the comment character is ignored
 .comments can begin at the first character on the line


Variables

 .variables are names given to locations in RAM memory
 .variable must be declared before they are used
 .variable MUST begin with an uppercase letter A...Z
 .variable are declared by placing their name at the first charater position
  on the line (the label field)

 examples

Index	$50		; this variable declaration names RAM loc $50 as Index
RcvBuff	$0100		; this variable is in extended memory
	LDX Index	; set index reg to value at loc $50
	STA RcvBuff,X	; write A reg to a buffer at $0100 + index 

Bit Field Variables

  .all rules for the variable above apply
  .the assembler does not care what name is given as long as
   the first letter is uppercase.
  .it is recomended you use the naming convention used in the examples
   to avoid confusion with normal variables (ie bit name in uppercase
   byte name like above).

 examples

TcrIEDG   $12.1  ; this names the timer control register input edge bit
TcrTOIE   $12.5  ; and timer control timer oveflow interupt enable
                 ; note these 2 use the Motorola names exactly 
MyFLGA    $60.0  ; this names an A flag in a byte
MyFLGB    $60.5  ; this names a B flag in the same byte

Constants

  .all rules for the variable declarations (above) apply
  .the assembler does not care what name is given as long as
   the first letter is uppercase.
  .it is recomended you use the nameing convention used in the examples
   to avoid confusion with variables (ie all uppercase).
  .NOTE when using the constant you don't need the # symbol like other
   assemblers. Assembles normally don't have constants & variables but
   use a text substitution using the EQU pseudo op. Fast is more like
   C in this regard. 

 examples

SIZE   #$10       ; declare a constant (before you use it)
       LDA SIZE   ; use it
       STA Index  ;


Auto Allocation of Variables

to allow code to be more modular this assembler will allocate variables
on your behalf. there are three types of variables that can be declared
for auto allocation, Page Zero, Extended and Bitfield.
 .you must declare one page zero variable and one extended variable
  to tell the assembler where to start.
 .bitfield variables will be allocated to the last Page Zero variable
  declared. after 8 bits you must declare another Page Zero variable.
  ie always declare a Page Zero parent variable before declaring Bit
  Field variables
 .you can reserve more than one byte by placing a HEX value inside
  brackets when declaring Page Zero or Extended variables.
 .you can always see what the assembler has allocated buy assembling
  with the "v" flag

examples
				; allocated to
ExtMem		$0100		; $0100
Spare		$50		; $50
Count		PgZ		; $51
Flags		PgZ		; $52
FlgBITA		BtF		; $52.0
FlgBITB		BtF		; $52.1
FlgBITC		BtF		; $52.2
Buffer		PgZ[0A]		; $53 ... $5D
Varible		PgZ		; $5E
ExtBuffer	Ext[10]		; $0101 ... $0111
ExtVar		Ext		; $0112

Traps for young players...As the autoallocator uses the last declared
"fixed" variable as the starting point you must declare all your fixed
variables (eg hardware ports) in your first main assembler module.



Error Messages

  message				cause
		
  invalid op code			op code field syntax error
  invalid address field			address field syntax error
					or wrong addressing mode 
  undefined label			label in address field not matched
  duplicate label			label declared more than once 
  address out of range			relative address out of range
  data table format			syntax error in data table
  unexpected end of file  FATAL		no END psuedo op found
  too many errors  FATAL		more than 128 errors
  output map overflow  FATAL		writing to loc outside ROM
  too many labels max 512  FATAL	exceeding limit on labels

  FATAL errors cause termination of processing


