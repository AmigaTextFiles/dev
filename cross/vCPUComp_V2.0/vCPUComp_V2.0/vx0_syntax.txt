 v5 - standard ROMv5 instruction
 +  - instruction tested and working
 ;  -  instruction not tested
 ?  - instruction propably working bad

v5      #$11 ; LDWI    imm16           ; vAC = imm16
 +      #$14 ; DEC     var             ; BYTE [var]--
 +      #$16 ; MOVQB   imm8, var8      ; BYTE [var] = imm8
 +      #$18 ; LSRB    var             ; BYTE [var] >> 1
v5      #$1a ; LD      var             ; vAC = BYTE [var]
 +      #$1c ; ADDBI   src, dst, imm8  ; BYTE [dst] = imm8 + BYTE [src]
unused  0x1f ; SPARE0                  ; unused
v5      #$21 ; LDW     var             ; WORD vAC = [var]
 +      #$23 ; PEEKV+  var             ; BYTE vAC = [WORD [var]], WORD [var]++
 +      #$25 ; POKEI   imm8            ; [vAC] = imm8
 +      #$27 ; LSLV    var             ; WORD [var] << 1
 +      #$29 ; ADDVB   dst, src0, src1 ; BYTE [dst] = BYTE [src] + BYTE [src1]
v5      #$2b ; STW     var             ; WORD [var] = vAC
 +      #$2d ; CNVXY   dst, src1, src0 ; BYTE [dst] = BYTE [src0] | (BYTE [src1] + 8) <<8)
prefix  0x2f ; PREFIX2                 ; internal prefix
 +      #$32 ; MOVWA   dst, src        ; WORD [dst] = WORD [src], vAC = WORD [dst]
 +      #$38 ; SUBBI   imm8, dst, src  ; BYTE [dst] = BYTE [src] - imm8
 +      #$3b ; DEEKV   var             ; vAC = [WORD [var]]
 +      #$3d ; ARRVW   idx, imm16      ; vAC = WORD[idx]*2 + imm16
 +      #$3f ; LDARRW  idx, imm16      ; vAC = deek [imm16 + idx*2]
 +      #$42 ; ADDVI   imm8, dst, src  ; WORD [dst] = imm8 + WORD [src], vAC = WORD [dst]
 +      #$44 ; SUBVI   imm8, dst, src  ; WORD [dst] = WORD [src] - imm8, vAC = WORD [dst]
 +      #$46 ; DEEKV+  var             ; vAC = [WORD [var]], [var] += 2
 +      #$48 ; SUBVB   dst, src1, src0 ; BYTE [dst] = BYTE [src0] - BYTE [src1]
 +      #$4a ; DJGE    var, imm16      ; Decrement word var and branch if >= 0 to imm16
 +      #$4d ; MOVQW   imm8, var       ; WORD [var] = imm8
 +      #$4f ; STWM    imm16           ; [imm16] = vAC
 +      #$51 ; STARRW  idx, imm16      ; doke [imm16 + idx*2] with vAC
 +      #$53 ; LDARRB  idx, imm16      ; vAC = peek [imm16 + idx]
 +      #$55 ; STARRB  idx, imm16      ; poke [imm16 + idx] with vAC.lo
 +      #$57 ; STARRI idx, imm16, imm8 ; poke [imm16 + idx] with 8bit imm
v5      #$59 ; LDI     imm8            ; vAC = imm8
 +      #$5b ; PEEKV   var             ; vAC = [WORD [var]]
v5      #$5e ; ST      var             ; BYTE [var] = vAC
 +      #$60 ; DOKEV+  var             ; [WORD [var]] = vAC, WORD [var] += 2
v5      #$63 ; POP                     ; (vLR,vSP==[vSP]+256*[vSP+1],vSP+2)
 +      #$65 ; MOVB    dst, src        ; BYTE [dst] = BYTE [src]
 +      #$67 ; PEEKA   var             ; BYTE [var] = [vAC]
 +      #$69 ; POKEA   var             ; [vAC] = BYTE [var]
 +      #$6b ; TEQ     var             ; WORD [var] = 0x0000 if vAC!=0 or 0xFFFF if vAC==0
 +      #$6d ; TNE     var             ; WORD [var] = 0x0000 if vAC==0 or 0xFFFF if vAC!=0
 +      #$6f ; DEEKA   var             ; WORD [var] = [vAC]
 +      #$72 ; LDWM    imm16           ; vAC = [imm16]
v5      #$75 ; PUSH                    ; ([vSP-2],v[vSP-1],vSP=vLR&255,vLR>>8,vLR-2)
 +?     #$77 ; DOKEI   imm16           ; [vAC] = imm16 ; bad endian
 +      #$79 ; ARRW    imm16           ; vAC = imm16 + vAC*2

;SCRLHR  #$7b ; horizontal scroll video rectangle

 +      #$7d ; DOKEA   var             ; [vAC] = WORD [var]
v5      #$7f ; LUP     imm8            ; vAC = ROM[vAC + imm8]
v5      #$82 ; ANDI    imm8            ; vAC &= imm8
v5      #$85 ; CALLI   imm16           ; (vLR,vPC=vPC+3,$HHLL-2)
v5      #$88 ; ORI     imm8            ; vAC |= imm8
 +      #$8a ; PEEKA+  var             ; BYTE [var] = [vAC], WORD vAC++
v5      #$8c ; XORI    imm8            ; vAC ^= imm8
 +      #$8e ; DBGE jump imm8, var     ; Decrement byte var and branch if >= 0
v5      #$90 ; BRA     BYTE jump       ; Branch unconditionally (vPC=(vPC&0xff00)+jump)
v5      #$93 ; INC     var             ; BYTE [var]++
 +      #$95 ; INCWA   var             ; WORD [var]++, vAC = WORD [var]
unused  0x97 ; SPARE1                  ; unused
v5      #$99 ; ADDW    var             ; vAC += WORD [var]
 +      #$9c ; LDNI    imm8            ; WORD vAC = -imm8
 +      #$9e ; DBNE jump imm8, var     ; Decrement byte var and branch if != 0
 +      #$a0 ; DEEKR   idx             ; vAC = DEEK[vAC + idx*2]
 +      #$a2 ; PACKAW  src1, src0      ; vAC = BYTE(src0) | (BYTE(src1) <<8)
 +      #$a4 ; DJNE    var, imm16      ; Decrement word var and branch if != 0 to imm16
 +      #$a7 ; CMPI    imm8, var       ; if(imm8 == BYTE[var]) vAC = 0; else vAC != 0
 +      #$a9 ; ADDVW  dst, src1, src0 ; WORD [dst] = WORD [src0] + WORD [src1], vAC = WORD [dst]
 +      #$ab ; SUBVW  dst, src1, src0 ; WORD [dst] = WORD [src0] - WORD [src1], vAC = WORD [dst]
v5      #$ad ; PEEK                    ; BYTE vAC = [vAC]
prefix  0xb1 ; PREFIX1                 ; internal prefix
v5      #$b4 ; SYS     ticks           ; Native call, <=256 cycles (<=128 ticks, in reality less)
v5      #$b8 ; SUBW    var             ; vAC -= WORD [var]
 +      #$bb ; JEQ     imm16           ; jump to 16bit address if vAC=0
 +      #$bd ; JNE     imm16           ; jump to 16bit address if vAC!=0
 +      #$bf ; JLT     imm16           ; jump to 16bit address if vAC<0
 +      #$c1 ; JGT     imm16           ; jump to 16bit address if vAC>0
 +      #$c3 ; JLE     imm16           ; jump to 16bit address if vAC<=0
 +      #$c5 ; JGE     imm16           ; jump to 16bit address if vAC>=0
prefix  0xc7 ; PREFIX3                 ; internal prefix
v5      #$cd ; DEF     imm8            ; (vAC,vPC=vPC+2,(vPC&0xff00)+var)
v5      #$cf ; CALL    var             ; WORD [var], (vLR,vPC=vPC+2,[var]+256*[var+1]-2)
 +      #$d1 ; POKEV+  var             ; [WORD [var]] = vAC, [var]++
 +?     #$d3 ; DOKEI+  imm16           ; [vAC] = imm16, vAV += 2 ; bad endian
 +      #$d5 ; TGE     var             ; Test for GE, returns 0x0000 or 0xFFFF in zero page var
 +      #$d7 ; TLT     var             ; Test for LT, returns 0x0000 or 0xFFFF in zero page var
 +      #$d9 ; TGT     var             ; Test for GT, returns 0x0000 or 0xFFFF in zero page var
 +      #$db ; TLE     var             ; Test for LE, returns 0x0000 or 0xFFFF in zero page var
 +      #$dd ; DECWA   var             ; WORD [var]--, vAC = var
v5      #$df ; ALLOC   imm8            ; vSP += imm8
 +      #$e1 ; PACKVW dst, src1, src0  ; WORD [dst] = BYTE [src0] | (BYTE [src1] <<8)
v5      #$e3 ; ADDI    imm8            ; vAC += imm8
v5      #$e6 ; SUBI    imm8            ; vAC -= imm8
v5      #$e9 ; LSLW                    ; vAC <<= 1
v5      #$ec ; STLW    imm8            ; ([vSP+imm8],[vSP+imm8+1]=vAC&255,vAC>>8)
v5      #$ee ; LDLW    imm8            ; (vAC=[vSP+imm8]+256*[vSP+imm8+1])
v5      #$f0 ; POKE    var             ; [WORD [var]] = BYTE vAC
v5      #$f3 ; DOKE    var             ; [WORD [var]] = WORD vAC
v5      #$f6 ; DEEK                    ; WORD vAC = [vAC]
v5      #$f8 ; ANDW    var             ; vAC &= WORD [var]
v5      #$fa ; ORW     var             ; vAC |= WORD [var]
v5      #$fc ; XORW    var             ; vAC ^= WORD [var]
v5      #$ff ; RET                     ; Function return (vPC=vLR-2)

v5      #$3F35 ; BEQ     jump imm8     ; Branch if zero     if(vAC==0)
v5      #$4D35 ; BGT     jump imm8     ; Branch if positive if(vAC>0)
v5      #$5035 ; BLT     jump imm8     ; Branch if negative if(vAC<0)
v5      #$5335 ; BGE     jump imm8     ; Branch if positive or zero if(vAC>=0)
v5      #$5635 ; BLE     jump imm8     ; Branch if negative or zero if(vAC<=0)
v5      #$7235 ; BNE     jump imm8     ; Branch if not zero if(vAC!=0)

;-----------------------------------------------------------------------
;       PREFX1 instruction page, 0xb1 (0x2400), PREFIX OPCODE
;-----------------------------------------------------------------------

 + NOTE    #$11b1 ; vAC = ROM:[NotesTable + vAC.lo*2]
 + MIDI    #$14b1 ; vAC = ROM:[NotesTable + (vAC.lo - 11)*2]
 + XLA     #$17b1 ; Exchange vLR with vAC
 + ADDLP   #$1ab1 ; vLAC += [vAC]
 + SUBLP   #$1db1 ; vLAC -= [vAC]
 + ANDLP   #$20b1 ; vLAC &= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
 + ORLP    #$23b1 ; vLAC |= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
 + XORLP   #$26b1 ; vLAC ^= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
 + CMPLPU  #$29b1 ; compare vLAC and [vAC] unsigned. On return vAC>0 (resp =0, <0) 
 + CMPLPS  #$2cb1 ; compare vLAC and [vAC] signed. On return vAC>0 (resp =0, <0) 
 + RANDW   #$2fb1 ; vAC = rand(65535), uses Marcel's algorithm from SYS_Random_34
 + LDPX    #$31b1 ; vAC = [vAC.xy], scanline table y taken into account
 + ABSW    #$33b1 ; vAC = abs(vAC)
 + SGNW    #$36b1 ; vAC = sgn(vAC)
 + MULB3   #$39b1 ; vAC = vAC.lo * 3
 + MULB5   #$3bb1 ; vAC = vAC.lo * 5
 + MULB6   #$3db1 ; vAC = vAC.lo * 6
 + MULB7   #$3fb1 ; vAC = vAC.lo * 7
 + MULB8   #$41b1 ; vAC = vAC.lo * 8
 + MULB9   #$43b1 ; vAC = vAC.lo * 9
 + MULB10  #$45b1 ; vAC = vAC.lo * 10
 + WAITVB  #$47b1 ; wait for VBlank
 + MULW3   #$49b1 ; vAC = vAC * 3
 + MULW5   #$4bb1 ; vAC = vAC * 5
 + MULW6   #$4db1 ; vAC = vAC * 6
 + MULW7   #$4fb1 ; vAC = vAC * 7
 + MULW8   #$51b1 ; vAC = vAC * 8
 + MULW9   #$53b1 ; vAC = vAC * 9
 + MULW10  #$55b1 ; vAC = vAC * 10

;-----------------------------------------------------------------------
;      PREFX2 instruction page, 0x2f, (0x2300), PREFIX ARG0 OPCODE
;-----------------------------------------------------------------------

;LSLN    #$112f  ; Logical shift left vAC, (16bit), n times
;SEXT    #$132f  ; Sign extend vAC based on a variable mask
;NOTW    #$152f  ; Boolean invert var
;NEGW    #$172f  ; Arithmetic negate var
;ANDBA   #$192f  ; vAC &= var.lo
;ORBA    #$1c2f  ; vAC |= var.lo
;XORBA   #$1f2f  ; vAC ^= var.lo
;FREQM   #$222f  ; [(((chan & 3) + 1) <<8) | 0x00FC] = vAC, chan var = [0..3]
;FREQA   #$242f  ; [((((chan - 1) & 3) + 1) <<8) | 0x00FC] = vAC, chan var = [1..4]
;FREQI   #$272f  ; [(((imm & 3) + 1) <<8) | 0x00FC] = vAC, chan imm = [0..3]
;VOLM    #$292f  ; [(((chan & 3) + 1) <<8) | 0x00FA] = vAC.low, chan var = [0..3]
;VOLA    #$2c2f  ; [((((chan - 1) & 3) + 1) <<8) | 0x00FA] = 63 - vAC.low + 64, chan var = [1..4]
;MODA    #$2f2f  ; [((((chan - 1) & 3) + 1) <<8) | 0x00FB] = vAC.low, chan var = [1..4]
;MODI    #$322f  ; [(((imm & 3) + 1) <<8) | 0x00FA] = (vAC.lo <<8) | 0, chan imm = [0..3]
;SMPCPY  #$342f  ; 
;CMPHS   #$372f  ; Adjust high byte for signed compare (vACH=XXX)
;CMPHU   #$3a2f  ; Adjust high byte for unsigned compare (vACH=XXX)
;LEEKA   #$3d2f  ; 
;LOKEA   #$3f2f  ;
;FEEKA   #$412f  ;
;FOKEA   #$432f  ;
;MEEKA   #$452f  ; Peek 8 bytes from [vAC] to [var]
;MOKEA   #$472f  ; Poke 8 bytes from [var] to [vAC]
;LSRVL   #$492f  ; Logical shift right var long
;LSLVL   #$4c2f  ; Logical shift left var long
;INCL    #$4f2f  ; Increment var long
;DECL    #$522f  ; Decrement var long
;STPX    #$542f  ; [vAC.xy] = var, scanline table y taken into account
;PRN4X6  #$572f  ; print 4x6 font char to screen from var
                 ; sysArgs01 = FG/BG COLOUR, sysArgs2 = 3, (LUP count), var = textFont address, vAC = dest addr
;VTBL    #$592f  ; var = VTBL(vAC)
;OSCZ    #$5c2f  ; [(((imm & 3) + 1) <<8) | 0x00FE] = 0, chan imm = [0..3]
;LSL8    #$5e2f  ; vAC.hi = var.lo, vAC.lo = 0
;ADDBA   #$602f  ; vAC += var.lo
;SUBBA   #$622f  ; vAC -= var.lo
;NOTB    #$642f  ; var.lo = ~var.lo
;ABSVW   #$672f  ; var = abs(var)
;INCW    #$6a2f  ; Increment word var
;DECW    #$6c2f  ; Decrement word var
;WAITVV  #$6e2f  ; more robust WAITVB
;POKEA+  #$712f  ; Poke a byte from var to [vAC], incw vAC
;LSRV    #$732f  ; Logical shift right word var
;DEEKRI  #$752f  ; vAC = DEEK[vAC + imm*2]
;SCRLH   #$772f  ; poke 0x0101 with peek(0x0101) + scroll
;MULB    #$7a2f  ; vAC.lo = vAC.lo * src.lo, vAC.hi = 0
;NCOPY   #$cd2f  ; copy n bytes from [vAC] to [vDST]. vAC+=n. vDST+=n
;STLU    #$d02f  ; store zero extended vAC into long var
;STLS    #$d32f  ; store sign extended vAC into long var
;NOTL    #$d52f  ; complement long var
;NEGL    #$d82f  ; negate long var

;-----------------------------------------------------------------------
;    PREFX3 instruction page, 0xc7 (0x2200), PREFIX ARG1 OPCODE ARG0
;-----------------------------------------------------------------------

;STB@    #$11c7  ; STB2    imm16         ; [imm16] = BYTE(vAC)
;STW2    #$14c7  ; Store vAC into 16bit immediate address
;XCHGB   #$17c7  ; Exchange two zero byte variables
;MOVW    #$19c7  ; Move 16bits from src zero page var to dst zero page var
;ADDWI   #$1bc7  ; vAC += imm16
;SUBWI   #$1dc7  ; vAC -= imm16
;ANDWI   #$1fc7  ; vAC &= imm16
;ORWI    #$21c7  ; vAC |= imm16
;XORWI   #$23c7  ; vAC ^= imm16
;FNT6X8  #$25c7  ; fontTable = FNT6X8(char), vAC = index(char)
;FNT4X6  #$28c7  ; fontTable = FNT4X6(char), vAC = index(char)
;CONDII  #$2ac7  ; chooses immediate operand based on condition, (vAC == 0)
;CONDBB  #$2cc7  ; chooses zero page byte var based on condition, (vAC == 0)
;CONDIB  #$2fc7  ; chooses between imm and zero page byte var based on condition, (vAC == 0)
;CONDBI  #$32c7  ; chooses between zero page byte var and imm based on condition, (vAC == 0)
;XCHGW   #$34c7  ; Exchange two zero word variables
;OSCPX   #$37c7  ; 
;SWAPB   #$39c7  ; Swap two bytes in memory
;SWAPW   #$3cc7  ; Swap two words in memory
;NEEKA   #$3fc7  ; Peek <n> bytes from [vAC] into [var]
;NOKEA   #$42c7  ; Poke <n> bytes from [var] into [vAC]
;ADDVL   #$45c7  ; Add two 32bit zero page vars, dst += src
;SUBVL   #$48c7  ; Subtract two 32bit zero page vars, dst -= src
;ANDVL   #$4cc7  ; And two 32bit zero page vars, dst &= src
;ORVL    #$4ec7  ; Or two 32bit zero page vars, dst |= src
;XORVL   #$51c7  ; Xor two 32bit zero page vars, dst ^= src
;JEQL    #$54c7  ;
;JNEL    #$57c7  ; 
;JLTL    #$5ac7  ; 
;JGTL    #$5dc7  ; 
;JLEL    #$60c7  ; 
;JGEL    #$63c7  ; 
;ANDBI   #$66c7  ; And immediate byte with byte var, result in byte var
;ORBI    #$69c7  ; OR immediate byte with byte var, result in byte var
;XORBI   #$6cc7  ; var.lo ^= imm, 22 + 20 cycles
;ANDBK   #$6fc7  ; vAC.hi = 0, vAC.lo = var.lo & imm
;ORBK    #$72c7  ; vAC.lo = var.lo | imm
;XORBK   #$75c7  ; vAC.lo = var.lo ^ imm
;JMPI    #$78c7  ; Jump to 16bit address, preserve vLR
;SUBIW   #$7bc7  ; vAC = imm16 - vAC
;VADDBW  #$7dc7  ; dst.0 += src.0, dst.1 += src.1
;VSUBBW  #$80c7  ; dst.0 -= src.0, dst.1 -= src.1
;VADDBL  #$83c7  ; dst.0 += src.0, dst.1 += src.1, dst.2 += src.2, dst.3 += src.3
;VSUBBL  #$86c7  ; dst.0 -= src.0, dst.1 -= src.1, dst.2 -= src.2, dst.3 -= src.3
;CMPII   #$89c7  ; if vAC < imm0 vAC=-1, if vAC >= imm1 vAC=1, else vAC=0
;IMIDI   #$8bc7  ; init midi, var midiStream, var midiDelay
;PMIDI   #$8ec7  ; play midi without volume, var midiStream, var midiDelay
;PMIDIV  #$91c7  ; play midi with volume, var midiStream, var midiDelay
;MERGE4  #$94c7  ; merge four arrays into one
;MOVL    #$cdc7  ; Move long variable
;MOVF    #$d0c7  ; Move float variable
;NROL    #$d3c7  ; Left rotate n bytes
;NROR    #$d6c7  ; Right rotate n bytes Shift vACsign->bit(8n-1)->...->bit(0)->vACsign. Destroys vAC

; pc = 0x3f3f, Opcode = 0x3f
; Conditional EQ: Branch if zero (if(vACL==0)vPCL=D)

; pc = 0x3f4d, Opcode = 0x4d
; Conditional GT: Branch if positive (if(vACL>0)vPCL=D)

; pc = 0x3f50, Opcode = 0x50
; Conditional LT: Branch if negative (if(vACL<0)vPCL=D)

; pc = 0x3f53, Opcode = 0x53
; Conditional GE: Branch if positive or zero (if(vACL>=0)vPCL=D)

; pc = 0x3f56, Opcode = 0x56
; Conditional LE: Branch if negative or zero (if(vACL<=0)vPCL=D)

; pc = 0x3f72, Opcode = 0x72
; Conditional NE: Branch if not zero (if(vACL!=0)vPCL=D)

