; Please don't any changes it your self!
; Ver: 23.08.2024

; ---------------------
; Predefinied variables
; ---------------------

@vPC    #$0016 ; Program Couter   (16 bits)
@vAC    #$0018 ; ACcumulator      (16 bits)
@vLR    #$001A ; Link Register    (16 bits)
@vSP    #$001C ; Stack Pointer    ( 8 bits)
@vIRQ   #$01F6 ; Interrupt Vector (16 bits)

; x  - byte, constact
; b  - byte, address on Zero Page (0x0000 - 0x00FF)
; HL - word, constant
; Lx - byte, name of label for jump instructions

; ---------------------------
; vCPU 5 mnemonics definition
; ---------------------------

ST      #$5E   #1 #0    ; ST    b  - Store byte:            [b] = vACL
STW     #$2B   #1 #0    ; STW   b  - Store word:            [b] = vACL, [b+1] = vACH
STLW    #$EC   #5 #0    ; STLW  x  - Store word on stack:   [vSP+b] = vACL, [vSP+b+1] = vACH
LD      #$1A   #1 #0    ; LD    b  - Load byte:             vAC = [b]
LDI     #$59   #5 #0    ; LDI   x  - Load immediate byte:   vAC = x
LDWI    #$11   #6 #0    ; LDWI  HL - Load immediate word:   vAC = HL
LDW     #$21   #1 #0    ; LDW   b  - Load word:             vACL = [b], vACH = [b+1]
LDLW    #$EE   #5 #0    ; LDLW  x  - Load word form stack:  vACL = [vSP+b], vACH = [vSP+b+1]
ADDW    #$99   #1 #0    ; ADDW  b  - Word additopn to vAC:  vAC += [b] + 256*[b+1] 
SUBW    #$B8   #1 #0    ; SUBW  b  - Word substract:        vAC -= [b] + 256*[b+1]     
ADDI    #$E3   #5 #0    ; ADDI  x  - Addition x to vAC:     vAC += x     
SUBI    #$E6   #5 #0    ; SUBI  x  - Substract x with vAC:  vAC -= x
LSLW    #$E9   #0 #0    ; LSLW     - Shift left:            vAC <<= 1
INC     #$93   #1 #0    ; INC   b  - Increment b:           [b]++
ANDI    #$82   #5 #0    ; ANDI  x  - Logical AND with x:    vAC &= x
ANDW    #$F8   #1 #0    ; ANDW  b  - Word logical AND:      vAC &= [b] + 256*[b+1]
ORI     #$88   #5 #0    ; ORI   x  - Logical OR:            vAC |= x
ORW     #$FA   #1 #0    ; ORW   b  - Word logical OR:       vAC |= [b] + 256*[b+1]
XORI    #$8C   #5 #0    ; XORI  x  - Logical XOR with x:    vAC ^= x
XORW    #$FC   #1 #0    ; ORW   b  - Word logical XOR:      vAC ^= [b] + 256*[b+1]
PEEK    #$AD   #0 #0    ; PEEK     - Read byte from memory: vAC = [vAC] 
DEEK    #$F6   #0 #0    ; DEEK     - Read word from memory: vAC = [vAC] + 256*[vAC+1]
POKE    #$F0   #1 #0    ; POKE  b  - Write byte in memory:  [[b+1],[b]] = vAC & 255
DOKE    #$F3   #1 #0    ; DOKE  b  - Write word in memory:  [[b+1],[b]] = vAC
LUP     #$7F   #5 #0    ; LUP   x  - ROM lookup:            vAC = ROM[vAC + x]
BRA     #$90   #1 #0    ; BRA   Lx - Branch unconditionally
BEQ     #$3F35 #1 #0    ; BEQ   Lx - Branch if vAC == 0
BNE     #$7235 #1 #0    ; BNE   Lx - Branch if vAC != 0
BLT     #$5035 #1 #0    ; BLT   Lx - Branch if vAC <  0
BGT     #$4D35 #1 #0    ; BGT   Lx - Branch if vAC >  0
BLE     #$5635 #1 #0    ; BLE   Lx - Branch if vAC <= 0
BGE     #$5335 #1 #0    ; BGE   Lx - Branch if vAC >= 0
CALL    #$CF   #1 #0    ; CALL  b  - Goto address and remember vPC on vLR
RET     #$FF   #0 #0    ; RET      - Leaf return from CALL/CALLI
PUSH    #$75   #0 #0    ; PUSH     - Push vLR on stack
POP     #$63   #0 #0    ; POP      - Pop  vLR from stack
ALLOC   #$DF   #5 #0    ; ALLOC x  - Create or destroy stack frame: vSP += x
SYS     #$B4   #6 #0    ; SYS   x  - Native function call, for x check extsysv*.def files
HALT    #$80B4 #0 #0    ; HALT     - SYS #$80 - Halt vCPU execution
DEF     #$CD   #5 #0    ; DEF   x  - Define data or code: (vAC, vPC = vPC + 2, (vPC & 0xFF00) + x)

; ------------------------
; Additional in DevROM too
; ------------------------

CALLI   #$85   #6 #0    ; CALLI HL - Goto immediate address HL and remember vPC
CMPHS   #$1F   #1 #0    ; CMPHS x  - Adjust high byte for   signed compare
CMPHU   #$97   #1 #0    ; CMPHU x  - Adjust high byte for unsigned compare

RTI     #00    #1 #0    ; RTI x    - Return from interrupt. OpCode is dummy.

; RTI is a special sequence code:
;
; LDWI #$0400
; LUP  x
;
; RTI: #$11 #$00 #$04 #$7F x
;
; x - argument for LUP instruction

