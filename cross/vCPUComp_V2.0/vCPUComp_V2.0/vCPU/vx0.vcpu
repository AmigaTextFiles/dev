; Please don't any changes it your self!
; Ver: 23.11.2024

; ---------------------
; Predefinied variables
; ---------------------

@vPC    #$0016 ; Program Couter   (16 bits)
@vAC    #$0018 ; ACcumulator      (16 bits)
@vLR    #$001A ; Link Register    (16 bits)
@vSP    #$001C ; Stack Pointer    ( 8 bits)
@vIRQ   #$01F6 ; Interrupt Vector (16 bits)

LDWI    #$11    #6 #0 ; Load immediate word constant (vAC=D)
DEC     #$14    #1 #0 ; Decrement byte var ([D]--), 22 cycles
MOVQB   #$16    #5 #1 ; <imm>,<var> Load a byte var with a small constant 0..255
LSRB    #$18    #1 #0 ; Logical shift right byte var
LD      #$1a    #1 #0 ; Load byte from zero page (vAC=[D])
ADDBI   #$1c    #1 #1 ; dst.lo = imm + src.lo
;SPARE0  0x1f
LDW     #$21    #1 #0 ; Load word from zero page (vAC=[D]+256*[D+1])
PEEKV+  #$23    #1 #0 ; Peek byte at address contained in var, inc var
POKEI   #$25    #5 #0 ; Poke immediate byte into address contained in [vAC]
LSLV    #$27    #1 #0 ; Logical shift left word var
ADDVB   #$29    #1 #1 ; dst.lo = src0.lo + src1.lo
STW     #$2b    #1 #0 ; Store word in zero page ([D],[D+1]=vAC&255,vAC>>8)
CNVXY   #$2d    #1 #1 ; var = src0.lo | ((src1.lo + 8) <<8)
;PREFX2  0x2f
MOVWA   #$32    #1 #1 ; Move 16bits from src zero page var to dst zero page var, vAC=dst
SUBBI   #$38    #5 #1 ; dst.lo = src.lo - imm
DEEKV   #$3b    #1 #0 ; read word from address contained in var
ARRVW   #$3d    #1 #6; vAC = imm16 + idx*2
LDARRW  #$3f    #1 #6; vAC = deek [imm16 + idx*2]
ADDVI   #$42    #5 #1 ; dst = src + imm8, vAC = dst
SUBVI   #$44    #5 #1 ; dst = src - imm8, vAC = dst
DEEKV+  #$46    #1 #0 ; Deek word at address contained in var, var += 2
SUBVB   #$48    #1 #1 ; dst.lo = src0.lo - src1.lo
DJGE    #$4a    #1 #6 ; Decrement word var and branch if >= 0 to imm16
MOVQW   #$4d    #5 #1 ; <imm>,<var> Load a word var with a small constant 0..255
STWM    #$4f    #6 #0 ; store [vAC] into [imm16]
STARRW  #$51    #1 #6 ; doke [imm16 + idx*2] with vAC
LDARRB  #$53    #1 #6 ; vAC = peek [imm16 + idx]
STARRB  #$55    #1 #6 ; poke [imm16 + idx] with vAC.lo
STARRI  #$57    #1 #6 ; poke [imm16 + idx] with 8bit imm
LDI     #$59    #5 #0 ; Load immediate small positive constant (vAC=D)
PEEKV   #$5b    #1 #0 ; Read byte from address contained in var
ST      #$5e    #1 #0 ; Store byte in zero page ([D]=vAC&255)
DOKEV+  #$60    #1 #0 ; doke word in vAC to address contained in var, var += 2
POP     #$63    #0 #0 ; Pop address from stack (vLR,vSP==[vSP]+256*[vSP+1],vSP+2)
MOVB    #$65    #1 #1 ; <dst>,<src> Moves a byte from src var to dst var
PEEKA   #$67    #1 #0 ; Peek a byte from [vAC] to var
POKEA   #$69    #1 #0 ; Poke a byte from var to [vAC]
TEQ     #$6b    #1 #0 ; Test for EQ, returns 0x0000 or 0xFFFF in zero page var
TNE     #$6d    #1 #0 ; Test for NE, returns 0x0000 or 0xFFFF in zero page var
DEEKA   #$6f    #1 #0 ; Deek a word from [vAC] to var
LDWM    #$72    #6 #0 ; LDWI + DEEK, vAC = [imm16]
PUSH    #$75    #0 #0 ; Push vLR on stack ([vSP-2],v[vSP-1],vSP=vLR&255,vLR>>8,vLR-2)
DOKEI   #$77    #6 #0 ; doke immediate word into address contained in [vAC]
ARRW    #$79    #6 #0 ; vAC = imm16 + vAC*2
;SCRLHR  #$7b ; horizontal scroll video rectangle
DOKEA   #$7d    #1 #0 ; Doke a word from var to [vAC]
LUP     #$7f    #1 #0 ; ROM lookup (vAC=ROM[vAC+D])
ANDI    #$82    #5 #0 ; Logical-AND with small constant (vAC&=D)
CALLI   #$85    #6 #0 ; Goto immediate address and remember vPC (vLR,vPC=vPC+3,$HHLL-2)
ORI     #$88    #5 #0 ; Logical-OR with small constant (vAC|=D)
PEEKA+  #$8a    #1 #0 ; Peek a byte from [vAC] to var, incw vAC
XORI    #$8c    #5 #0 ; Logical-XOR with small constant (vAC^=D)
DBGE    #$8e    #1 #1 ; Decrement byte var and branch if >= 0
BRA     #$90    #1 #0 ; Branch unconditionally (vPC=(vPC&0xff00)+D)
INC     #$93    #1 #0 ; Increment zero page byte ([D]++)
INCWA   #$95    #1 #0 ; Increment word var, vAC=var
;SPARE1  0x97
ADDW    #$99    #1 #0 ; Word addition with zero page (vAC+=[D]+256*[D+1])
LDNI    #$9c    #5 #0 ; Load an 8bit immediate as a negative 16bit immediate into vAC
DBNE    #$9e    #1 #1 ; Decrement byte var and branch if != 0
DEEKR   #$a0    #1 #0 ; vAC = DEEK[vAC + idx*2]
PACKAW  #$a2    #1 #1 ; vAC = src0.lo | (src1.lo <<8)
DJNE    #$a4    #1 #6 ; Decrement word var and branch if != 0 to imm16
CMPI    #$a7    #5 #1 ; Compare byte variable to 8bit immediate
ADDVW   #$a9    #1 #1 ; Add two 16bit zero page vars, dst = src0 + src1, vAC = dst
SUBVW   #$ab    #1 #1 ; Subtract two 16bit zero page vars, dst = src0 - src1, vAC = dst
PEEK    #$ad    #0 #0 ; Read byte from memory (vAC=[vAC])
;PREFX1  0xb1
SYS     #$b4    #1 #0 ; Native call, <=256 cycles (<=128 ticks, in reality less)
SUBW    #$b8    #1 #0 ; Word subtract with zero page (AC-=[D]+256*[D+1])
JEQ     #$bb   #10 #0 ; jump to 16bit address if vAC=0
JNE     #$bd   #10 #0 ; jump to 16bit address if vAC!=0
JLT     #$bf   #10 #0 ; jump to 16bit address if vAC<0
JGT     #$c1   #10 #0 ; jump to 16bit address if vAC>0
JLE     #$c3   #10 #0 ; jump to 16bit address if vAC<=0
JGE     #$c5   #10 #0 ; jump to 16bit address if vAC>=0
;PREFX3  0xc7
DEF     #$cd    #1 #0 ; Define data or code (vAC,vPC=vPC+2,(vPC&0xff00)+D)
CALL    #$cf    #1 #0 ; Goto address and remember vPC (vLR,vPC=vPC+2,[D]+256*[D+1]-2)
POKEV+  #$d1    #1 #0 ; Poke byte in vAC to address contained in var, inc var
DOKEI+  #$d3    #6 #0 ; doke immediate word into [vAC], vAC += 2
TGE     #$d5    #1 #0 ; Test for GE, returns 0x0000 or 0xFFFF in zero page var
TLT     #$d7    #1 #0 ; Test for LT, returns 0x0000 or 0xFFFF in zero page var
TGT     #$d9    #1 #0 ; Test for GT, returns 0x0000 or 0xFFFF in zero page var
TLE     #$db    #1 #0 ; Test for LE, returns 0x0000 or 0xFFFF in zero page var
DECWA   #$dd    #1 #0 ; Decrement word var, vAC=var
ALLOC   #$df    #1 #0 ; Create or destroy stack frame (vSP+=D)
PACKVW  #$e1    #1 #1 ; var = src0.lo | (src1.lo <<8)
ADDI    #$e3    #5 #0 ; Add small positive constant (vAC+=D)
SUBI    #$e6    #5 #0 ; Subtract small positive constant (vAC+=D)
LSLW    #$e9    #0 #0 ; Logical shift left (vAC<<=1)
STLW    #$ec    #1 #0 ; Store word in stack frame ([vSP+D],[vSP+D+1]=vAC&255,vAC>>8)
LDLW    #$ee    #1 #0 ; Load word from stack frame (vAC=[vSP+D]+256*[vSP+D+1])
POKE    #$f0    #1 #0 ; Write byte in memory ([[D+1],[D]]=vAC&255)
DOKE    #$f3    #1 #0 ; Write word in memory ([[D+1],[D]],[[D+1],[D]+1]=vAC&255,vAC>>8)
DEEK    #$f6    #0 #0 ; Read word from memory (vAC=[vAC]+256*[vAC+1])
ANDW    #$f8    #1 #0 ; Word logical-AND with zero page (vAC&=[D]+256*[D+1])
ORW     #$fa    #1 #0 ; Word logical-OR with zero page (vAC|=[D]+256*[D+1])
XORW    #$fc    #1 #0 ; Word logical-XOR with zero page (vAC^=[D]+256*[D+1])
RET     #$ff    #0 #0 ; Function return (vPC=vLR-2)

BEQ     #$3F35  #1 #0 ; Branch if zero     if(vAC==0)
BGT     #$4D35  #1 #0 ; Branch if positive if(vAC>0)
BLT     #$5035  #1 #0 ; Branch if negative if(vAC<0)
BGE     #$5335  #1 #0 ; Branch if positive or zero if(vAC>=0)
BLE     #$5635  #1 #0 ; Branch if negative or zero if(vAC<=0)
BNE     #$7235  #1 #0 ; Branch if not zero if(vAC!=0)

HALT    #$80B4  #0 #0 ; Stop vCPU execution
RTI     #00     #1 #0 ; Return from interrupt. OpCode is dummy

;-----------------------------------------------------------------------
;       PREFX1 instruction page, 0xb1 (0x2400), PREFIX OPCODE
;-----------------------------------------------------------------------

NOTE    #$11b1  #0 #0 ; vAC = ROM:[NotesTable + vAC.lo*2]
MIDI    #$14b1  #0 #0 ; vAC = ROM:[NotesTable + (vAC.lo - 11)*2]
XLA     #$17b1  #0 #0 ; Exchange vLR with vAC
ADDLP   #$1ab1  #0 #0 ; vLAC += [vAC]
SUBLP   #$1db1  #0 #0 ; vLAC -= [vAC]
ANDLP   #$20b1  #0 #0 ; vLAC &= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
ORLP    #$23b1  #0 #0 ; vLAC |= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
XORLP   #$26b1  #0 #0 ; vLAC ^= [vAC]. On return vAC>0 (resp =0, <0) iff LAC>0 (resp =0, <0)
CMPLPU  #$29b1  #0 #0 ; compare vLAC and [vAC] unsigned. On return vAC>0 (resp =0, <0) 
CMPLPS  #$2cb1  #0 #0 ; compare vLAC and [vAC] signed. On return vAC>0 (resp =0, <0) 
RANDW   #$2fb1  #0 #0 ; vAC = rand(65535), uses Marcel's algorithm from SYS_Random_34
LDPX    #$31b1  #0 #0 ; vAC = [vAC.xy], scanline table y taken into account
ABSW    #$33b1  #0 #0 ; vAC = abs(vAC)
SGNW    #$36b1  #0 #0 ; vAC = sgn(vAC)
MULB3   #$39b1  #0 #0 ; vAC = vAC.lo * 3
MULB5   #$3bb1  #0 #0 ; vAC = vAC.lo * 5
MULB6   #$3db1  #0 #0 ; vAC = vAC.lo * 6
MULB7   #$3fb1  #0 #0 ; vAC = vAC.lo * 7
MULB8   #$41b1  #0 #0 ; vAC = vAC.lo * 8
MULB9   #$43b1  #0 #0 ; vAC = vAC.lo * 9
MULB10  #$45b1  #0 #0 ; vAC = vAC.lo * 10
WAITVB  #$47b1  #0 #0 ; wait for VBlank
MULW3   #$49b1  #0 #0 ; vAC = vAC * 3
MULW5   #$4bb1  #0 #0 ; vAC = vAC * 5
MULW6   #$4db1  #0 #0 ; vAC = vAC * 6
MULW7   #$4fb1  #0 #0 ; vAC = vAC * 7
MULW8   #$51b1  #0 #0 ; vAC = vAC * 8
MULW9   #$53b1  #0 #0 ; vAC = vAC * 9
MULW10  #$55b1  #0 #0 ; vAC = vAC * 10

;-----------------------------------------------------------------------
;      PREFX2 instruction page, 0x2f, (0x2300), PREFIX ARG0 OPCODE
;-----------------------------------------------------------------------

;LSLN    #$112f  #1 #0 ; Logical shift left vAC, (16bit), n times
;SEXT    #$132f ; Sign extend vAC based on a variable mask
;NOTW    #$152f  #1 #0 ; Boolean invert var
;NEGW    #$172f  #1 #0 ; Arithmetic negate var
;ANDBA   #$192f  #1 #0 ; vAC &= var.lo
;ORBA    #$1c2f  #1 #0 ; vAC |= var.lo
;XORBA   #$1f2f  #1 #0 ; vAC ^= var.lo
;FREQM   #$222f  #1 #0 ; [(((chan & 3) + 1) <<8) | 0x00FC] = vAC, chan var = [0..3]
;FREQA   #$242f  #1 #0 ; [((((chan - 1) & 3) + 1) <<8) | 0x00FC] = vAC, chan var = [1..4]
;FREQI   #$272f  #1 #0 ; [(((imm & 3) + 1) <<8) | 0x00FC] = vAC, chan imm = [0..3]
;VOLM    #$292f  #1 #0 ; [(((chan & 3) + 1) <<8) | 0x00FA] = vAC.low, chan var = [0..3]
;VOLA    #$2c2f  #1 #0 ; [((((chan - 1) & 3) + 1) <<8) | 0x00FA] = 63 - vAC.low + 64, chan var = [1..4]
;MODA    #$2f2f  #1 #0 ; [((((chan - 1) & 3) + 1) <<8) | 0x00FB] = vAC.low, chan var = [1..4]
;MODI    #$322f  #1 #0 ; [(((imm & 3) + 1) <<8) | 0x00FA] = (vAC.lo <<8) | 0, chan imm = [0..3]
;SMPCPY  #$342f ; 
;CMPHS   #$372f  #1 #0 ; Adjust high byte for signed compare (vACH=XXX)
;CMPHU   #$3a2f  #1 #0 ; Adjust high byte for unsigned compare (vACH=XXX)
;LEEKA   #$3d2f ; 
;LOKEA   #$3f2f ;
;FEEKA   #$412f ;
;FOKEA   #$432f ;
;MEEKA   #$452f  #1 #0 ; Peek 8 bytes from [vAC] to [var]
;MOKEA   #$472f  #1 #0 ; Poke 8 bytes from [var] to [vAC]
;LSRVL   #$492f  #1 #0 ; Logical shift right var long
;LSLVL   #$4c2f  #1 #0 ; Logical shift left var long
;INCL    #$4f2f  #1 #0 ; Increment var long
;DECL    #$522f  #1 #0 ; Decrement var long
;STPX    #$542f ; [vAC.xy] = var, scanline table y taken into account
;PRN4X6  #$572f ; print 4x6 font char to screen from var
             ; sysArgs01 = FG/BG COLOUR, sysArgs2 = 3, (LUP count), var = textFont address, vAC = dest addr
;VTBL    #$592f  #1 #0 ; var = VTBL(vAC)
;OSCZ    #$5c2f  #5 #0 ; [(((imm & 3) + 1) <<8) | 0x00FE] = 0, chan imm = [0..3]
;LSL8    #$5e2f  #1 #0 ; vAC.hi = var.lo, vAC.lo = 0
;ADDBA   #$602f  #1 #0 ; vAC += var.lo
;SUBBA   #$622f  #1 #0 ; vAC -= var.lo
;NOTB    #$642f  #1 #0 ; var.lo = ~var.lo
;ABSVW   #$672f  #1 #0 ; var = abs(var)
;INCW    #$6a2f  #1 #0 ; Increment word var
;DECW    #$6c2f  #1 #0 ; Decrement word var
;WAITVV  #$6e2f  #1 #0 ; more robust WAITVB
;POKEA+  #$712f  #1 #0 ; Poke a byte from var to [vAC], incw vAC
;LSRV    #$732f  #1 #0 ; Logical shift right word var
;DEEKRI  #$752f  #5 #0 ; vAC = DEEK[vAC + imm*2]
;SCRLH   #$772f ; poke 0x0101 with peek(0x0101) + scroll
;MULB    #$7a2f  #1 #0 ; vAC.lo = vAC.lo * src.lo, vAC.hi = 0
;NCOPY   #$cd2f ; copy n bytes from [vAC] to [vDST]. vAC+=n. vDST+=n
;STLU    #$d02f  #1 #0 ; store zero extended vAC into long var
;STLS    #$d32f  #1 #0 ; store sign extended vAC into long var
;NOTL    #$d52f  #1 #0 ; complement long var
;NEGL    #$d82f  #1 #0 ; negate long var

;-----------------------------------------------------------------------
;    PREFX3 instruction page, 0xc7 (0x2200), PREFIX ARG1 OPCODE ARG0
;-----------------------------------------------------------------------

;STB2    #$11c7  #6 #0 ; Store vAC.lo into 16bit immediate address
;STW2    #$14c7  #6 #0 ; Store vAC into 16bit immediate address
;XCHGB   #$17c7  #1 #1 ; Exchange two zero byte variables
;MOVW    #$19c7  #1 #1 ; Move 16bits from src zero page var to dst zero page var
;ADDWI   #$1bc7  #6 #0 ; vAC += imm16
;SUBWI   #$1dc7  #6 #0 ; vAC -= imm16
;ANDWI   #$1fc7  #6 #0 ; vAC &= imm16
;ORWI    #$21c7  #6 #0 ; vAC |= imm16
;XORWI   #$23c7  #6 #0 ; vAC ^= imm16
;FNT6X8  #$25c7 ; fontTable = FNT6X8(char), vAC = index(char)
;FNT4X6  #$28c7 ; fontTable = FNT4X6(char), vAC = index(char)
;CONDII  #$2ac7 ; chooses immediate operand based on condition, (vAC == 0)
;CONDBB  #$2cc7 ; chooses zero page byte var based on condition, (vAC == 0)
;CONDIB  #$2fc7  #5 #1 ; chooses between imm and zero page byte var based on condition, (vAC == 0)
;CONDBI  #$32c7  #5 #1 ; chooses between zero page byte var and imm based on condition, (vAC == 0)
;XCHGW   #$34c7  #1 #1 ; Exchange two zero word variables
;OSCPX   #$37c7 ; 
;SWAPB   #$39c7  #6 #6 ; Swap two bytes in memory
;SWAPW   #$3cc7  #6 #6 ; Swap two words in memory
;NEEKA   #$3fc7  #5 #1 ; Peek <n> bytes from [vAC] into [var]
;NOKEA   #$42c7 ; Poke <n> bytes from [var] into [vAC]
;ADDVL   #$45c7  #1 #1 ; Add two 32bit zero page vars, dst += src
;SUBVL   #$48c7  #1 #1 ; Subtract two 32bit zero page vars, dst -= src
;ANDVL   #$4cc7  #1 #1 ; And two 32bit zero page vars, dst &= src
;ORVL    #$4ec7  #1 #1 ; Or two 32bit zero page vars, dst |= src
;XORVL   #$51c7  #1 #1 ; Xor two 32bit zero page vars, dst ^= src
;JEQL    #$54c7 ; 
;JNEL    #$57c7 ; 
;JLTL    #$5ac7 ; 
;JGTL    #$5dc7 ; 
;JLEL    #$60c7 ; 
;JGEL    #$63c7 ; 
;ANDBI   #$66c7  #5 #1 ; And immediate byte with byte var, result in byte var
;ORBI    #$69c7  #5 #1 ; OR immediate byte with byte var, result in byte var
;XORBI   #$6cc7  #5 #1 ; var.lo ^= imm, 22 + 20 cycles
;ANDBK   #$6fc7  #5 #1 ; vAC.hi = 0, vAC.lo = var.lo & imm
;ORBK    #$72c7  #5 #1 ; vAC.lo = var.lo | imm
;XORBK   #$75c7  #5 #1 ; vAC.lo = var.lo ^ imm
;JMPI    #$78c7  #6 #0 ; Jump to 16bit address, preserve vLR
;SUBIW   #$7bc7  #6 #0 ; vAC = imm16 - vAC
;VADDBW  #$7dc7 ; dst.0 += src.0, dst.1 += src.1
;VSUBBW  #$80c7 ; dst.0 -= src.0, dst.1 -= src.1
;VADDBL  #$83c7 ; dst.0 += src.0, dst.1 += src.1, dst.2 += src.2, dst.3 += src.3
;VSUBBL  #$86c7 ; dst.0 -= src.0, dst.1 -= src.1, dst.2 -= src.2, dst.3 -= src.3
;CMPII   #$89c7  ; if vAC < imm0 vAC=-1, if vAC >= imm1 vAC=1, else vAC=0
;IMIDI   #$8bc7  #1 #1 ; init midi, var midiStream, var midiDelay
;PMIDI   #$8ec7  #1 #1 ; play midi without volume, var midiStream, var midiDelay
;PMIDIV  #$91c7  #1 #1 ; play midi with volume, var midiStream, var midiDelay
;MERGE4  #$94c7 ; merge four arrays into one
;MOVL    #$cdc7 ; Move long variable
;MOVF    #$d0c7 ; Move float variable
;NROL    #$d3c7 ; Left rotate n bytes
;NROR    #$d6c7 ; Right rotate n bytes Shift vACsign->bit(8n-1)->...->bit(0)->vACsign. Destroys vAC

; pc = 0x3f3f, Opcode = 0x3f
; Conditional EQ: Branch if zero (if(vACL==0)vPCL=D)

; pc = 0x3f4d, Opcode = 0x4d
; Conditional GT: Branch if positive (if(vACL>0)vPCL=D)

; pc = 0x3f50, Opcode = 0x50
; Conditional LT: Branch if negative (if(vACL<0)vPCL=D)

; pc = 0x3f53, Opcode = 0x53
; Conditional GE: Branch if positive or zero (if(vACL>=0)vPCL=D)

; pc = 0x3f56, Opcode = 0x56
; Conditional LE: Branch if negative or zero (if(vACL<=0)vPCL=D)

; pc = 0x3f72, Opcode = 0x72
; Conditional NE: Branch if not zero (if(vACL!=0)vPCL=D)

