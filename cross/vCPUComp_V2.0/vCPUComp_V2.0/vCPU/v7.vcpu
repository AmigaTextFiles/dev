; Please don't any changes it your self!
; Ver: 16.11.2024

; ---------------------
; Predefinied variables
; ---------------------

@vPC   #$0016 ; Program Couter   (16 bits)
@vAC   #$0018 ; ACcumulator      (16 bits)
@vLR   #$001A ; Link Register    (16 bits)
@vSP   #$001C ; Stack Pointer    ( 8 bits)
@vIRQ  #$01F6 ; Interrupt Vector (16 bits)

@vSPL  #$001C ; Low  byte of 16 bit stack pointer
@vSPH  #$001D ; High byte of 16 bit stack pointer
@vFAS  #$0081 ; Floating point accumulator sign byte
@vFAE  #$0082 ; Floating point exponent
@vLAX  #$0083 ; Extended accumulator (40 bits)
@vLAC  #$0084 ; Long Accumulator     (32 bits)
@vT2   #$0088 ; Destination register (16 bits)
@vT3   #$008A ; Source register      (16 bits)

; x, y - byte, constact
; b    - byte, address on Zero Page (0x0000 - 0x00FF)
; HL   - word, constant

; ---------------------------------
; Standard vCPU ROMv5a instructions
; See: v5.vcpu
; ---------------------------------

LDWI    #$11   #6 #0
LD      #$1A   #1 #0
CMPHS   #$1F   #1 #0
LDW     #$21   #1 #0
STW     #$2B   #1 #0
LDI     #$59   #5 #0
ST      #$5E   #1 #0
POP     #$63   #0 #0
PUSH    #$75   #0 #0
LUP     #$7F   #5 #0

ANDI    #$82   #5 #0
CALLI   #$85   #6 #0
ORI     #$88   #5 #0
XORI    #$8C   #5 #0
BRA     #$90   #1 #0
INC     #$93   #1 #0
CMPHU   #$97   #1 #0
ADDW    #$99   #1 #0
PEEK    #$AD   #0 #0
SYS     #$B4   #6 #0

SUBW    #$B8   #1 #0
DEF     #$CD   #5 #0
CALL    #$CF   #1 #0
ALLOC   #$DF   #5 #0
ADDI    #$E3   #5 #0
SUBI    #$E6   #5 #0
LSLW    #$E9   #0 #0
STLW    #$EC   #5 #0
LDLW    #$EE   #5 #0
POKE    #$F0   #1 #0

DOKE    #$F3   #1 #0
DEEK    #$F6   #0 #0
ANDW    #$F8   #1 #0
ORW     #$FA   #1 #0
XORW    #$FC   #1 #0
RET     #$FF   #0 #0

; Gigatron vCPU branch instructions

BEQ     #$3F35   #1 #0
BGT     #$4D35   #1 #0
BLT     #$5035   #1 #0
BGE     #$5335   #1 #0
BLE     #$5635   #1 #0
BNE     #$7235   #1 #0

; Pseudo vCPU instructions

HALT    #$80B4   #0 #0
RTI     #00      #1 #0

; ---------------------------
; vCPU 7 mnemonics definition
; ---------------------------

; Long conditional branches

; HL - target address: (H*256)+(L+2)&255)

JEQ     #$3F   #10 #0    ; JEQ HL - Jump to HL if vACC == 0
JNE     #$72   #10 #0    ; JNE HL - Jump to HL if vACC != 0
JLT     #$50   #10 #0    ; JLT HL - Jump to HL if vACC <  0
JGT     #$4D   #10 #0    ; JGT HL - Jump to HL if vACC >  0
JLE     #$56   #10 #0    ; JLE HL - Jump to HL if vACC <= 0
JGE     #$53   #10 #0    ; JGE HL - Jump to HL if vACC >= 0

; PEEK and POKE alternatives

DOKEA   #$3B   #1 #0    ; DOKEA b  - Store word [b..bb+1] at address: [vAC] = [b]
DOKEQ   #$44   #5 #0    ; DOKEQ x  - Store immediate x:               [vAC] = (WORD)(x)
DOKEI   #$6235 #6 #0    ; DOKEI HL - Store immediate HL:              [vAC] = HL
DEEKA   #$3D   #1 #0    ; DEEKA b  - Load word at address:              [b] = [vAC]
DEEKV   #$41   #1 #0    ; DEEKV b  - Load word at address:              vAC = [b]
POKEA   #$39   #1 #0    ; POKEA b  - Store byte:                      [vAC] = [b]
POKEQ   #$46   #5 #0    ; POKEQ x  - Store immediate x:               [vAC] = (BYTE)(x)
PEEKA   #$E1   #1 #0    ; PEEKA b  - Load byte at address:              [b] = [vAC] 
PEEKV   #$DD   #1 #0    ; PEEKV b  - Load byte at address:            [vAC] = [b]

; Additional instriction provide indexed access

LDXW    #$6A   #1 #6    ; LDXW b, HL - Load word at address:  vAC = [b] + HL
STXW    #$6C   #1 #6    ; STXW b, HL - Store word at address: [b] + HL = vAC

; Moving data without changing vAC

MOVQB   #$48   #1 #5    ; MOVQB b, x  - Store immediate into byte:  [b] = x
MOVQW   #$4A   #1 #5    ; MOVQW b, x  - Store immediate into word:  [b] = x
MOVIW   #$B1   #1 #6    ; MOVIW b, HL - Store immediate into word:  [b] = HL
MOVW    #$BC   #1 #1    ; COPY  y, x  - Copy word var:              [y] = [x]
INCV    #$70   #1 #0    ; INCV  b     - Add 1 to word:              [b]++
ADDV    #$66   #1 #0    ; ADDV  b     - Add vAC contents to word:   [b] += vAC
SUBV    #$68   #1 #0    ; SUBV  b     - Sub vAC contents from word: [b] -= vAC
ADDIV   #$7D35 #5 #1    ; ADDIV x, b  - Add immediate to word     : [b] += x
SUBIV   #$9C35 #5 #1    ; SUBIV x, b  - Sub immediate from word   : [b] -= x
NEGV    #$18   #1 #0    ; NEGV        - Negates word:               ~[b]    

; Comparsion instructions

CMPWS   #$D3   #1 #0    ; CMPWS b -   Signed comparsion of vAC and word [b]
CMPWU   #$D6   #1 #0    ; CMPWU b - Unisgned comparsion of vAC and word [b]
CMPIS   #$d9   #5 #0    ; CMPIS x -   Signed comparsion of vAC and immediate x
CMPIU   #$DB   #5 #0    ; CMPIU x - Unsigned comparsion of vAC and immediate x

; Signed byte manipulations

LDNI    #$78   #5 #0    ; LDNI  x  - Load negative immediate:        vAC   = 0xFFxx
LDSB    #$6E   #1 #0    ; LDSB  b  - Load signed extended byte:      vAC   = [b]
ADDIH   #$33   #5 #0    ; ADDHI x  - Add byte to high acc byte vACH: vACH += x 

; Multiplication and division

MULW    #$3D35 #1 #0    ; MULW  b - Multiply vAC by word:             vAC *= [b]
MULQ    #$7D   #5 #0    ; MULQ  x - Multiply vAC by small immediate:  vAC *= x
RDIVU   #$3B35 #1 #0    ; RDIVU b - Unsigned division of word by vAC: [b] /= vAC
RDIVS   #$3935 #1 #0    ; RDIVS b -   Signed division of word by vAC: [b] /= vAC

; Copy instructions

COPY    #$CB35 #0 #0    ; COPY       - Copy vACL bytes from vT3 to vT2
COPYN   #$CF7D #5 #0    ; COPYN x    - Copy  x   bytes from vT3 to vT2
COPYS   #$0235 #1 #5    ; COPYS b, x - Copy x&127 bytes from [vSP] to b (x<128)
                        ;              or back (x>128)
                                       
; Long arithmetic

LDLAC   #$1E35 #0 #0    ; LDLAC      - Load long vAC into vLAC:  vLAC = (LONG)(vAC)
STLAC   #$2035 #0 #0    ; STLAC      - Store vLAC into long vAC: (LONG)(vAC) = vLAC
MOVL    #$DB35 #1 #1    ; MOVL  y, x - Copy long:                y..y+3 = x..x+3 (trashes sysArgs[0..7])
LEEKA   #$3235 #1 #0    ; LEEKA b    - Copy long from [vAC]..[vAC]+3 to b..b+3 (trashes sysArgs[2..7])
LOKEA   #$3435 #1 #0    ; LOKEA b    - Copy long from b..b+3 to [vAC]..[vAC]+3 (trashes sysArgs[2..7])
ADDL    #$0035 #0 #0    ; ADDL      - Add long [vAC..vAC+3] to long Acc vLAC (trashes sysArgs[5,6,7])
SUBL    #$0435 #0 #0    ; SUBL      - Substract long [vAC]..[vAC]+3 from long Acc vLAC (trashes sysArgs[5,6,7])
ANDL    #$0635 #0 #0    ; ANDL      - Bitwise and of [vAC]..[vAC]+3 with long Acc vLAC (trashes sysArgs[7])
ORL     #$0835 #0 #0    ; ORL       - Bitwise or  of [vAC]..[vAC]+3 with long Acc vLAC (trashes sysArgs[7])
XORL    #$0A35 #0 #0    ; XORL      - Bitwise xor of [vAC]..[vAC]+3 with long Acc vLAC (trashes sysArgs[7])
CMPLS   #$1435 #0 #0    ; CMPLS     - Signed compare long Acc vLAC with [vAC]..[vAC]+3 (trashes sysArgs[7])
CMPLU   #$1635 #0 #0    ; CMPLU     - Unsigned compare long Acc vLAC with [vAC]..[vAC]+3 (trashes sysArgs[7])

INCVL   #$2335 #1 #0    ; INCVL b   - Increment long:   [b]++
NEGVL   #$0C35 #1 #0    ; NEGVL b   - Negates long:    ~[b]
LSLVL   #$1035 #1 #0    ; LSLVL b   - Left shift long:  [b] <<= 1

; Extended arithmetic, shifts, and floating points

MOVF    #$DD35 #1 #1    ; MOVF y, x - Copy fp number from [x..x+4] to [y..y+4] (trashes sysArgs[0..7])
LDFAC   #$2735 #0 #0    ; LDFAC     - Load fp number [vAC..vAC+4] into float Acc (trashes vAC, vT3, sysArgs[5,6,7]
STFAC   #$2535 #0 #0    ; STFAC     - Store float Acc into fp var [vAC]..[vAC]+4 (trashes vAC, sysArgs[5,6,7]

LSRXA   #$1835 #0 #0    ; LSRXA     - Right shift  vLAX by 'vAC & 0x3F' positions
LSLXA   #$1235 #0 #0    ; LSLXA     - Left  shift  vLAX by 'vAC & 0x3F' positions
RORX    #$1A35 #0 #0    ; RORX      - Right rotate vLAX from/into bit 0 of vAC

LDFARG  #$2935 #0 #0    ; LDFARG    - Load floating point argument [vAC]..[vAC]+4
NEGX    #$0E35 #0 #0    ; NEGX      - Negate extended acc vLAX
MACX    #$1C35 #0 #0    ; MACX      - Adds the product of vACL (8 bits) by sysArgs[0..4] (32 bits] to vLAX (40 bits)

; Context and interrupts

VSAVE    #$2B35 #0 #0   ; VASVE     - Save full vCPU context into xxE0-xxFF, xx=vACL
VRESTORE #$2D35 #0 #0   ; VRESTORE  - Restore vCPU context saved in xxE0-xxFF, xx=vACL
EXCH     #$2F35 #0 #0   ; EXCH      - automatically exchange bytes vACL ant [vT2]

; Reset function

RESET   #$5C35 #0 #0    ; RESET - Soft reset
