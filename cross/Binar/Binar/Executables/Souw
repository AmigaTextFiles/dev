/*
$VER: Souw 1.0 (15.06.2002)
*/

/* 

   Souw 1.0

   Copyright © 2002 Janne Peräaho.
   All Rights Reserved.

*/

/* Get arguments */
parse arg binname defname
defname=strip(defname)

/* Show help */
if binname='?' then do
 say 'Usage: Souw <file> <deflector>'
 say ''
 say '<file>         Name of the binary file to be disassembled'
 say '<deflector>    Name of the deflector file to be utilized'
 say ''
 exit
end

/*****************************************************************************/
/* MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAIN MAI */
/*****************************************************************************/

/* VARIABLES */
tool='Binar'         /* Disassembler tool */
errcode=0            /* CLI error code: 0=ok */
mode=0               /* Disassembler's mode: 0=data, 1=code */

/* Souw's inline commands:

   DATA    Instruct Souw to view next block as a data block
   CODE    Instruct Souw to view next block as a code block
   NOTE    Allows user to add note into a source code: #NOTE <text>
   ;       Comment line which Souw will ignore: ; <text>
*/
inline_data='#DATA' /* Switch to data mode */
inline_code='#CODE' /* Switch to code mode */
inline_note='#NOTE' /* User note */
inline_comment=';'  /* Comment line */

/* No Binar! */
if ~exists(tool) then do
 say "can't find "tool
 errcode=20
end

/* Open binary file */
if ~open(sourcehandle,binname,'r') then do
 say "can't open binary file"
 errcode=20
end

/* Open deflector file */
if (errcode=0) & (~open(defhandle,defname,'r')) then do
 say "can't open deflector file"
 errcode=20
end

/* Start conversion */
if errcode=0 then do

 /* Write header */
 say ';' binname
 say ';'
 say '; DATE: 'date()

 /* Read deflector file */
 do until eof(defhandle)=1
  line=readln(defhandle)

  /* Go to next mode */
  mode=mode+1
  if mode>2 then mode=1

  /* Parse line */
  select
   /* Next block type is DATA */
   when upper(line)=inline_data then do
    mode=0
   end
   /* Next block type is CODE */
   when upper(line)=inline_code then do
    mode=1
   end
   /* Comment line */
   when left(upper(line),length(inline_comment))=inline_comment then do
    /* Do nothing */

    mode=mode-1 /* No mode swithing */
   end
   /* User note */
   when left(upper(line),length(inline_note))=inline_note then do
    parse var line dummy unote
    say ';'unote

    mode=mode-1 /* No mode switching */
   end
   /* Parse addresses */
   otherwise do
    parse var line startaddress endaddress
    endaddress=strip(endaddress)

    if (startaddress~='') & (endaddress~='') then do
     blocksize=x2d(endaddress)-x2d(startaddress)+1 /* Calculate block size */
     select
      /* Create data block */
      when mode=(0+1) then do
       say ''
       say ';--------------------------------------------------------------------------'
       say '; Data block $'startaddress'-$'endaddress' ('blocksize' B)'
       say ';--------------------------------------------------------------------------'
       address command tool binname 'START' startaddress 'END' endaddress 'NOSUMMARY NOPREFIX NOINVERSE NOCAPITALS' 'HEXDUMP'
      end
      /* Create code block */
      when mode=(1+1) then do
       say ''
       say ';--------------------------------------------------------------------------'
       say '; Code block $'startaddress'-$'endaddress' ('blocksize' B)'
       say ';--------------------------------------------------------------------------'
       address command tool binname 'START' startaddress 'END' endaddress 'NOSUMMARY NOPREFIX NOINVERSE NOCAPITALS' 'NOUNDOCUMENTED'
      end
      otherwise do
       say 'INTERNAL ERROR'
      end
     end /* select */
    end /* if */
    /* Empty line */
    else do
     mode=mode-1 /* No mode switching */
    end /* else */
   end /* otherwise */
  end /* select */
 end /* until */
end

/* Close files */
close(sourcehandle)
close(defhandle)

exit errcode

