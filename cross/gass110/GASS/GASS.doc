************************************************************************/
/*  Copyright © 1993 Kajetan Hinner, ParSec 1993                        */
/*                                                                      */
/*         Kajetan Hinner                    IRC: Shadow_I              */
/*         St.Augustinus-Str.10                                         */
/*         D-8000 München 82                 FAX: +49 89 409839         */
/*                                                                      */
/*            BBS: Sportbox München +49 89 9031461 (FLORESTAN)          */
/*                                                                      */
/*  Internet: uf341ea@sunmail.lrz-muenchen.de                           */
/*            Kajetan.Hinner@Soziologie.LMU-MUENCHEN.DBP.DE             */
/*                                                                      */
/************************************************************************/
/*

1) What is GASS?

GASS is a 6510 assembler for the Commodore Amiga. You can assemble 6510
sources, i.e. for the commodore c64, on your Amiga.

----------------------------------------------------------

2) What GASS doesn`t do?

GASS is not an 6510 emulator. You cannot run any 6510-programs on the Amiga.

----------------------------------------------------------

3) How much does GASS cost?

GASS is Shareware. If you want to use GASS and would like
to see it improved, please send 15 DM or transfer it to my bank account.

Address:

                Kajetan Hinner
                St.Augustinus-Str. 10

up to  1.7.93:   D-8000 Munich 82
after  1.7.93:   D-81825 Munich     (new postalcode)

    Bankaccount

    Kajetan Hinner, Acc-No.: 232617-804, PGiroAmt München, BLZ 70010080

for ideas and improvements or bug reports contact E-Mail:

        uf341ea@sunmail.lrz-muenchen.de

 or

        Kajetan.Hinner@Soziologie.LMU-MUENCHEN.DBP.DE

GASS is part of the Amiga-C64 Varus Network (c) ParSec. Varus links up to
nine C64 with an Amiga. They can access to the Amiga-HD and can communicate
with each other. Hardware consisting of a chip board for the Amiga and one
for each C64 and the network software is needed. Anyone interested in the
Varus network should contact the following address:

                Mathias Ketter
                Jäcklinstr. 7

up to 1.7.93:   D-8000 Munich 83
after 1.7.93:   D-81735 Munich     (new Postalcode)

                FAX +49 89 409839

----------------------------------------------------------

4) Guide

You can run GASS either fro the CLI or from the Workbench.

I)  CLI:

  The standard call is

       GASS source.gass

  That assembles the program source.gass. The objectfile is by default
  source.gass.obj.

  These options are available (starting with "-", i.e. -n):

       GASS source.gass -w -l -a -e -s -o -k -n -c5 -dEDDIEVH=$2601

   -w       Object-Code will not be saved (otherwise sourcename.obj)
   -w name  Save Object-Code as name
   -l name  Save labels (either as sourcename.labels or name)
   -a       Don´t put the start address of the object code into the first
            two bytes (otherwise like C64)
   -e       prints no errors
   -s       prints Source-Code (in an extra window)
   -o       prints Object-Code (in the CLI)
   -k       GASS is not case sensitive
   -n       GASS doesn´t output into the CLI window
   -cn      ocoffset=n: one figured number n will be added to the '='-operator
   -dlabel=1234 To pre-define labels (possible: $, %, normally decimal)

II) Workbench:

  With double-selection (clicking the GASS-icon, pressing SHIFT and
  simultaneously pressing the sourcecode-icon) the GASS starts assembling.
  If you select GASS as default-tool (in the WB menue), a double-click
  is all you need to start assembling.
  You can define your GASS options in the ToolTypes menu.

  There are the these Tools Types:

    WINDOW=CON:0/50/640/150/GASS-Output
        defines the output-window

    SOURCE=source.gass
        selects the name of the source-code file

    OBJECT=source.obj
        object-code filename

    LABELS=source.labels
        store labels in "source.labels"

    ERRORS=source.errors
        save error-log

    OCOFFSET=n
        adds n to the ObjectCounter-Operator "="

    DELAY=n
        sets up the time to keep the window after GASS has done its job

    DEFINE=LABEL1=31;LABEL2=26;LABEL3=6
        pre-define labels

  These options are available under the FLAGS item

   The items marked with "*" are enabled by default

   The items are seperated by a "|", i.e.:


    FLAGS=LABELS|NOSTARTADR

        NOERRORS:       suppress error output
       *ERRORS:         print errors
        OBJEKT:         print object-code
       *NOOBJEKT:       don´t print object-code
        SOURCE:         print SOURCE-Code
       *NOSOURCE:       don´t print Source-code
        NOWRITE:        don´t save object-code
       *OBJWRITE:       object-code will be saved
        LABELS:         create label-file
       *NOLABELS:       don´t create label-file
        NOSTARTADR:     do not add the load address (at pos. 0 & 1)
       *STARTADR:       the first two bytes of the objectcode are the
                        start-PC-address (L/H), derived from the first .BA
        NOLABTEST:      don´t check new labels for being already defined (saves time)
       *LABTEST:        check labels if already existant
        NOCASE:         case insensitive, ALEX is the same as AlEx
       *CASE:           only capital letters are accepted (for Opcodes)


-----------

Here the defined assembler-Mnemonics. If you don´t know the single instructions,
please look it up in a book...

Example for a line:

  LABEL   STA $FFFF        ; store A in $FFFF


   -  the line can begin with a label (at the very beginning, no space)
        The first character of the label has to be a letter, no figures.

   -  after white spaces follows the mnemonic (i.e. STA CLC, or .BA)

   -  later there´s the operand (i.e. $FFFF, #L,$6502)

   -  all following a ";" will be ignored (for comments)


In alphabetic order there are the following mnemonics

        ADC #$00
        ADC *$00        ; for zeropage-addressing, i.e. ADC *15
        ADC $00,X
        ADC $0000
        ADC $0000,X
        ADC $0000,Y
        ADC ($00),Y
        ADC ($00,X)
        AND #$00
        AND $00
        AND $00,X
        AND $0000
        AND $0000,X
        AND $0000,Y
        AND ($00),Y
        AND ($00,X)
        ASL
        ASL $00
        ASL $00,X
        ASL $0000
        ASL $0000,X
        BCC Label
        BCS Label
        BEQ Label
        BIT Label
        BIT Label
        BMI Label
        BNE Label
        BPL Label
        BRK
        BVC Label
        BVS Label
        CLC
        CLD
        CLI
        CLV
        CMP #$00
        CMP $00
        CMP $00,X
        CMP $0000
        CMP $0000,X
        CMP $0000,Y
        CMP ($00),Y
        CMP ($00,X)
        CPX #$00
        CPX $00
        CPX $0000
        CPY #$00
        CPY $00
        CPY $0000
        DEC $00
        DEC $00,X
        DEC $0000
        DEC $0000,X
        DEX
        DEY
        EOR #$00
        EOR $00
        EOR $00,X
        EOR $0000
        EOR $0000,X
        EOR $0000,Y
        EOR ($00),Y
        EOR ($00,X)
        INC $00
        INC $00,X
        INC $0000
        INC $0000,X
        INX
        INY
        JMP $0000
        JMP ($0000)
        JSR $0000
        LDA #$00
        LDA $00
        LDA $00,X
        LDA $0000
        LDA $0000,X
        LDA $0000,Y
        LDA ($00),Y
        LDA ($00,X)
        LDX #$00
        LDX $00
        LDX $00,Y
        LDX $0000
        LDX $0000,Y
        LDY #$00
        LDY $00
        LDY $00,X
        LDY $0000
        LDY $0000,X
        LSR
        LSR $00
        LSR $00,X
        LSR $0000
        LSR $0000,X
        NOP
        ORA #$00
        ORA $00
        ORA $00,X
        ORA $0000
        ORA $0000,X
        ORA $0000,Y
        ORA ($00),Y
        ORA ($00,X)
        PHA
        PHP
        PLA
        PLP
        ROL
        ROL $00
        ROL $00,X
        ROL $0000
        ROL $0000,X
        ROR
        ROR $00
        ROR $00,X
        ROR $0000
        ROR $0000,X
        RTI
        RTS
        SBC #$00
        SBC $00
        SBC $00,X
        SBC $0000
        SBC $0000,X
        SBC $0000,Y
        SBC ($00),Y
        SBC ($00,X)
        SEC
        SED
        SEI
        STA $00
        STA $00,X
        STA $0000
        STA $0000,X
        STA $0000,Y
        STA ($00),Y
        STA ($00,X)
        STX $00
        STX $00,Y
        STX $0000
        STY $00
        STY $00,X
        STY $0000
        TAX
        TAY
        TSX
        TXA
        TXS
        TYA

  [ I couldn´t build in undefined opcodes, because I wanted to take over
    already existing standards. If you know some, please inform me on E-Mail ]

 These are the following modes in GASS

        LDA #L,$3103    ; results in $03
        
        LDA #H,$1797    ; results in $17

        LDA #<$3103     ; results in $03 (the same as #L,)

        LDA #>$1797     ; results in $17 (like #H,)

        LDA *$15        ; for zero-page (two-byte machine code)

        LDA $15         ; three byte length (machine code)

        BNE =-3         ; takes PC -3
-----------

There are some special assembler-commands (starting with ".")

Example:

STARTADRESS     .BA $4000       ; Program starts at $4000

These commands are possible:    [following the MAE]

      .BA n             ; begin assembly at n (start address for PC)
          ; n mustn´t be computed from later defined parameters!
          ; i.e. .BA ParSec  ; and ParSec is defined after 10 lines
      .BY expr expr     ; store bytes (i.e. $, <, >, %, ''), space seperates
      .SE lab           ; store label Low-High
      .DE n             ; define label (HUGO .DE 12)
      .OS               ; prints object
      .OC               ; halts printing object-code (ends .OS)
      .IFE n            ; IfEqual; Assembles the following only if n = NULL
      .ENDIF            ; defines the end of an .IF block
      .IFN a            ; IfNotEqual: assembles only if n is not NULL
      .IFP a            ; IfPlus ...  nesting possible for .IF! (> null)
      .IFM a            ; IfMinus ... (< null)
      .HL a             ; stores a as long H3 H2 H1 L
      .HW a             ; stores a as word H L
      .BT a             ; stores a as byte
      .LI 'labelsdef'   ; LabelFile-Include, filemame "labelsdef"
      .BF n             ; stores n bytes
      .FILL a           ; defines value for .BF - command
      .PRINTT '!Super!'       ; prints text "Super!" into the amiga-window
      .PRINTV a         ; prints expression a directly in the GASS-window


Example-Code:

         .BA $4000       ; Programm begins at $4000

START    .DE $5000       ; defines: START = $5000
BERECH2  .DE %01010101   ; binary
BERECH3  .DE 10000       ; decimal

        .BY $20 <START >START %00001111 'TEXT' START

; stores in memory: $20 $00 $50 $0F $54 $45 $58 $54 $00 $50

        .SE START
; stores: $00 $50

        .OS             ; print the object code from now on
        LDA #$FF
        .OC             ; quits printing the object code

        .IFE 1
        LDX #$FF        ; will be skipped
        .ENDIF          ; end of .IFE block

        .IFN 5          ; IfNotEqual:
        LDY #%11100111  ; will be handled
        .ENDIF          ; end of .IFN block
                ; $A0 $E7 is coming out...

        .IFP 12
        NOP             ; will be handled
        .ENDIF
                ; store $EA

        .IFM 12         ; IfMinus ... (< null: assembles)
        CLI
        .ENDIF
                ; nothing happens

        .HL 31011797    ; stores a as long H3 H2 H1 L
                ; $01 $D9 $33 $D5 is the effect

        .HW 2601        ; stores a as word H L
                ; $0A $29 is stored 

        .BT 69          ; stores a as one Byte
                ; $45 is stored 

        .LI 'GOS.labels' ; LabelFile-include, filename "GOS.labels"
                ; load the label-file GOS.labels with its values

        .FILL 10        ; value for .BF is 10
        .BF BERECH3-9990
                ; stores 10 Bytes with $0A

        .PRINTT 'Fehlercode:' ; print text in the amiga-window
        .PRINTV 20-5/5        ; result is 3!
        

-----------

for terms there are the following types of calculation

i.e.
                .BT 10*10       ; store 100



        PLUS    +       ; i.e. 5+20 makes 25
        MINUS   -       ; i.e. 20-10 makes 10
        MAL     *       ; i.e. 100*2 makes 200
        DURCH   /       ; i.e. 200/5 makes 40
        MODULO  %       ; i.e. 200/6 makes 2
        AND     &       ; i.e. %01010101 & %10111010 makes 32
        OR      |       ; i.e. %00001111 | $40 makes 79

--------------------------------

Status message when leaving:

i.e. Source 550, Objekt 6 (von $4000-$4004), Labels 96, Ticks: 12)

The length of the source-file is 550 Bytes, of the object-code 6 Byte.
It´s in the memory from $4000 upto $4004 (excluded)
The labels take 96 bytes of memory, you´ve needed 12 time-ticks.

Error-messages:


  2     bracket error
  3     comma error
  4     only reverse references with this command
  5     idiotic/wrong  number combination
  7     repeat of '*', '$', '#', '<', '>'
  8     syntax error
  9     unknown command
 10     no more memory for labels available
 11     invalid label
 13     label not found
 14     wrong adress
 15     branch out of range
 16     area overflow
 17     no more memory for second pass labels available
 18     number system invalid
 19     division by zero
 20     .BY-Field longer than 256 bytes
 26     output problems in label data
 27     invalid name at .LI
 28     warning: .ENDIF without specific .IF

 30     label already defined
 31     label not yet defined

numbers from 35 upwards interupt immediately

 35     memory required from objectcode too large (OBJEKTMEM ?)
 36     write error in data output
 37     no more memory for second pass labels available
 38     no more memory for labels available (LABELMEM ?)
 39     assembly interupted

  The ammount of memory reserved for the objekt code and labels depends on
  source code length.

  If this area is to small, there´ll be error  #35 or #38. With the ToolType
  OBJEKTMEM=10000 or LABELMEM=50000 (menu Information... in WB Icons
  Menue) you can reserve more space. If you are in the CLI, you just
  can increase the sourcecode length artificially.

This software package GASS also contains the program ar.gass, which is
normally part of the varus network. This program does not run without this
operating system and is for demonstration purposes only.

                        hope you have fun with GASS

                            Kajetan Hinner
