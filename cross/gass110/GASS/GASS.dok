/************************************************************************/
/*  Copyright © 1993 Kajetan Hinner, ParSec 1993                        */
/*                                                                      */
/*         Kajetan Hinner                    IRC: Shadow_I              */
/*         St.Augustinus-Str.10                                         */
/*         D-8000 München 82                 FAX: +49 89 409839         */
/*                                                                      */
/*            BBS: Sportbox München +49 89 9031461 (FLORESTAN)          */
/*                                                                      */
/*  Internet: uf341ea@sunmail.lrz-muenchen.de                           */
/*            Kajetan.Hinner@Soziologie.LMU-MUENCHEN.DBP.DE             */
/*                                                                      */
/************************************************************************/
/*
	
1) Was ist GASS?

GASS ist ein 6510 Assembler für den Amiga. Sie können 6510-Assembler
Programme, z.B. für den C64, auf einem Amiga assemblieren.

----------------------------------------------------------

2) Was ist GASS nicht?

GASS ist kein 6510-Emulator. Sie können keine 6510-Programme auf dem Amiga
laufen lassen.

----------------------------------------------------------

3) Was kostet es, GASS zu benutzen?

GASS ist Shareware. Wenn Sie GASS verwenden und wollen, daß er
weiterentwickelt wird, schicken Sie bitte 15 DM in einem Brief an mich oder
überweisen Sie das Geld auf mein Konto.

Meine Adresse:

                Kajetan Hinner
                St.Augustinus-Str. 10

  bis 1.7.93:   D-8000 München 82
 nach 1.7.93:   D-81825 München     (neue Postleitzahlen)

    oder meine Bankverbindung

    Kajetan Hinner, Kto-No.: 232617-804, PGiroAmt München, BLZ 70010080

für Vorschläge oder Fehlermeldungen meine E-Mail:

uf341ea@sunmail.lrz-muenchen.de

oder

Kajetan.Hinner@Soziologie.LMU-MUENCHEN.DBP.DE

GASS ist Bestandteil des Amiga-C64 Netzwerks Varus (c) ParSec.
Mit Varus können bis zu neun C64 mit einem Amiga verbunden werden und
dann von der Amiga-HD laden, sich gegenseitig Nachrichten schicken, usw.
Zur Verbindung wird sowohl Hardware, bestehend aus einer Platine für den
Amiga und je einer für jeden C64, als auch die Netzwerk-Software benötigt.
Für Interessenten am Varus-Netzwerk, hier die Bezugs- und Informationsadresse

                Mathias Ketter
                Jäcklinstr. 7

  bis 1.7.93:   D-8000 München 83
 nach 1.7.93:   D-81735 München     (neue Postleitzahlen)

                FAX +49 89 409839

----------------------------------------------------------

4) Anleitung

Der GASS kann entweder aus einem CLI (Shell) oder von der Workbench gestartet
werden.

I)  CLI:

  Am einfachsten ist folgender Befehl:

       GASS source.gass

  Damit wird das Programm source.gass assembliert. Das Objektfile wird
  unter source.gass.obj abgelegt.

  Es gibt die folgenden Optionen (eingeleitet mit "-", also z.B. -n):

       GASS source.gass -w -l -a -e -s -o -k -n -c5 -dEDDIEVH=$2601

   -w       Objekt-Code nicht abspeichern (sonst unter sourcename.obj)
   -w name  Objekt-Code unter name abspeichern
   -l name  Labelfeld erzeugen (entweder unter sourcename.labels oder name)
   -a       Startadresse nicht als erste zwei Bytes erzeugen (sonst wie für C64)
   -e       Errors nicht ausgeben
   -s       Source-Code ausgeben (in einem eigenen Fenster)
   -o       Objekt-Code ausgeben (im CLI-Fenster)
   -k       Kleinbuchstaben werden wie Großbuchstaben behandelt
   -n       Keine Ausgaben des GASS ins CLI-Fenster
   -cn      ocoffset=n: Einstelliges n wird zum '='-Operator addiert
   -dlabel=1234 Label-Zuweisung (möglich: $, %, normal dezimal)

II) Workbench:

  Durch Doppelselektion (Anklicken des GASS-Icons, dann  SHIFT drücken und
  gleichzeitig das SourceCode-Icon anklicken) assembliert der GASS.
  Falls Sie bei dem SourceCode-Icon unter "Standardprogramm" GASS einstellen
  (im Menue der Workbench unter "Einstellungen..."), genügt ein Doppelklick auf
  dieses Icon zum Assemblieren.
  Weiter können Sie unter "Merkmale" ("Neu" zum Hinzufügen auswählen) die
  Einstellungen zum Assemblieren bestimmen.

  Es gibt folgende "Merkmale":

    WINDOW=CON:0/50/640/150/GASS-Ausgabe
        definiert das Ausgabefenster

    SOURCE=source.gass
        Angabe des Source-Files/Quellcode

    OBJECT=source.obj
        Filename des assemblierten Files (Objekt-Code)

    LABELS=source.labels
        Die Labels unter "source.labels" abspeichern

    ERRORS=source.errors
        Alle Fehler in das File schreiben

    OCOFFSET=n
        n wird zum ObjektCounter-Operator "=" hinzugezählt

    DELAY=n
        Die Zeit, die das GASS-Fenster nach Ende des Assemblierens noch steht

    DEFINE=LABEL1=31;LABEL2=26;LABEL3=6
        Die einzelnen Labels werden vorab definiert

  Zusammengefaßt unter FLAGS sind folgende Funktionen:

   Die mit "*" gekennzeichneten Einstellungen sind als Voreinstellung
   eingestellt.

   Die Flags werden mit "|" getrennt, also z.B.:

    FLAGS=LABELS|NOSTARTADR

   Alle mit * markierten Einstellungen sind ungefragt eingeschaltet

        NOERRORS:       Fehler werden nicht ausgegeben
       *ERRORS:         Fehler werden ausgegeben
        OBJEKT:         Objekt-Code ausgeben
       *NOOBJEKT:       Objekt-Code nicht ausgeben
        SOURCE:         SOURCE-Code ausgeben
       *NOSOURCE:       Source-Code wird nicht ausgegeben
        NOWRITE:        Objekt-Code nicht abspeichern
       *OBJWRITE:       Object-Code wird abgespeichert
        LABELS:         Label-Feld wird erzeugt
       *NOLABELS:       Kein Label-Feld erzeugen
        NOSTARTADR:     Keine Startadresse erzeugen
       *STARTADR:       Vor den Objektcode kommen zwei Bytes
                        Startadresse (L/H), die aus dem ersten .BA kommen
        NOLABTEST:      Die Labels werden nicht geprüft
       *LABTEST:        Die Labels werden auf wiederholte Definition geprüft
        NOCASE:          Groß/Kleinschreibung gleichwertig, ALEX gleich AlEx
       *CASE:           Nur Großschreibung erlaubt (bei Opcodes)


-----------

Jetzt zum eigentlichen Assembler. Die Befehle einer 6502-CPU erkläre ich hier
nicht, da gibt es genügend gute Bücher.

Eine Programmzeile könnte etwa so aussehen:

  LABEL   STA $FFFF        ; Akku nach $FFFF


   -  direkt am Anfang der Zeile kann ein Label stehen;
        Er muß mit einem Buchstaben anfangen, danach sind Ziffern erlaubt

   -  durch Leerzeichen getrennt kommt der Mnemonic (z.B. STA CLC, oder .BA)

   -  dahinter kommt der Operand (z.B. $FFFF, #L,$6502)

   -  hinter einem ";" wird der Rest der Zeile als Kommentar betrachtet


Tabellarisch geordnet versteht der GASS folgende Assembler-Befehle:

        ADC #$00
        ADC *$00        ; Zeropage mit z.B. ADC *15
        ADC $00,X
        ADC $0000
        ADC $0000,X
        ADC $0000,Y
        ADC ($00),Y
        ADC ($00,X)
        AND #$00
        AND $00
        AND $00,X
        AND $0000
        AND $0000,X
        AND $0000,Y
        AND ($00),Y
        AND ($00,X)
        ASL
        ASL $00
        ASL $00,X
        ASL $0000
        ASL $0000,X
        BCC Label
        BCS Label
        BEQ Label
        BIT Label
        BIT Label
        BMI Label
        BNE Label
        BPL Label
        BRK
        BVC Label
        BVS Label
        CLC
        CLD
        CLI
        CLV
        CMP #$00
        CMP $00
        CMP $00,X
        CMP $0000
        CMP $0000,X
        CMP $0000,Y
        CMP ($00),Y
        CMP ($00,X)
        CPX #$00
        CPX $00
        CPX $0000
        CPY #$00
        CPY $00
        CPY $0000
        DEC $00
        DEC $00,X
        DEC $0000
        DEC $0000,X
        DEX
        DEY
        EOR #$00
        EOR $00
        EOR $00,X
        EOR $0000
        EOR $0000,X
        EOR $0000,Y
        EOR ($00),Y
        EOR ($00,X)
        INC $00
        INC $00,X
        INC $0000
        INC $0000,X
        INX
        INY
        JMP $0000
        JMP ($0000)
        JSR $0000
        LDA #$00
        LDA $00
        LDA $00,X
        LDA $0000
        LDA $0000,X
        LDA $0000,Y
        LDA ($00),Y
        LDA ($00,X)
        LDX #$00
        LDX $00
        LDX $00,Y
        LDX $0000
        LDX $0000,Y
        LDY #$00
        LDY $00
        LDY $00,X
        LDY $0000
        LDY $0000,X
        LSR
        LSR $00
        LSR $00,X
        LSR $0000
        LSR $0000,X
        NOP
        ORA #$00
        ORA $00
        ORA $00,X
        ORA $0000
        ORA $0000,X
        ORA $0000,Y
        ORA ($00),Y
        ORA ($00,X)
        PHA
        PHP
        PLA
        PLP
        ROL
        ROL $00
        ROL $00,X
        ROL $0000
        ROL $0000,X
        ROR
        ROR $00
        ROR $00,X
        ROR $0000
        ROR $0000,X
        RTI
        RTS
        SBC #$00
        SBC $00
        SBC $00,X
        SBC $0000
        SBC $0000,X
        SBC $0000,Y
        SBC ($00),Y
        SBC ($00,X)
        SEC
        SED
        SEI
        STA $00
        STA $00,X
        STA $0000
        STA $0000,X
        STA $0000,Y
        STA ($00),Y
        STA ($00,X)
        STX $00
        STX $00,Y
        STX $0000
        STY $00
        STY $00,X
        STY $0000
        TAX
        TAY
        TSX
        TXA
        TXS
        TYA

  [Undefinierte Opcodes konnte ich nicht einbauen, weil ich die "Standard"-
   Mnemonics verwenden möchte. Wer solche Standards kennt, schicke mir bitte
   eine Mail]

 Im GASS sind folgende Adressierungsarten möglich:

        LDA #L,$3103    ; gibt $03

        LDA #H,$1797    ; gibt $17

        LDA #<$3103     ; gibt $03 (gleichwertig wie #L,)

        LDA #>$1797     ; gibt $17 (wie #H,)

        LDA *$15        ; Zero-Page-Adressierung (zwei-Byte Maschinenbefehl)

        LDA $15         ; Drei-Byte Befehl

        BNE =-3         ; PC -3 als Zieladresse
-----------

Dazu kommen noch die Assembler-Anweisungen, die sämtlich mit einem "."
anfangen.

Beispiel:

STARTADRESSE    .BA $4000       ; Programmstart ist $4000

Es gibt folgende Anweisungen:    [der MAE gab das Vorbild ab]

      .BA n             ; Startadresse des folgenden Codes; BeginneAssemblieren
          ; n darf nicht von erst später definierten Werten abhängen!
          ; z.B. .BA ParSec  ; und ParSec wird erst 10 Zeilen später definiert
      .BY expr expr     ; Bytes ablegen (z.B. $, <, >, %, ''), SPACE trennt
      .SE lab           ; Label Low-High ablegen
      .DE n             ; Label definieren (HUGO .DE 12)
      .OS               ; Objekt-Code ausgeben
      .OC               ; Objekt-Code nicht mehr ausgeben (siehe .OS)
      .IFE n            ; IfEqual; Nur assemblieren, wenn n = NULL
      .ENDIF            ; Bedingtes Assemblieren wird aufgehoben
      .IFN a            ; IfNotEqual: Nur bei gesetztem Ausdruck a assemblieren
      .IFP a            ; IfPlus ...  Verschachtelung möglich! (größer null)
      .IFM a            ; IfMinus ... (kleiner null)
      .HL a             ; Legt a im Format H3 H2 H1 L (long) ab
      .HW a             ; Legt a im Format H L (word) ab
      .BT a             ; Legt a als Byte ab
      .LI 'labelsdef'   ; LabelFile-Include mit FileNamen "labelsdef"
      .BF n             ; Legt n Bytes im Objekt-Code ab
      .FILL a           ; für .BF - Befehl Definition des Füll-Bytes
      .PRINTT '!Super!'       ; Text "Super!" direkt im Amiga-Fenster ausgeben
      .PRINTV a         ; Ausdruck a direkt im Amiga-GASS-Fenster ausgeben


(Sinnloses) Programm als Beispiel für deren Verwendung:

         .BA $4000       ; Programm soll ab $4000 liegen

START    .DE $5000       ; legt fest: START = $5000
BERECH2  .DE %01010101   ; binär
BERECH3  .DE 10000       ; dezimal

        .BY $20 <START >START %00001111 'TEXT' START
; Achtung: das Zeichen ' kommt beim Amiga mit ALT-Ä (gleichzeitig)!!!
; legt im Speicher ab: $20 $00 $50 $0F $54 $45 $58 $54 $00 $50

        .SE START
; legt im Speicher ab: $00 $50

        .OS             ; Objekt-Code ab jetzt ausgeben
        LDA #$FF
        .OC             ; Objekt-Code nicht mehr ausgeben

        .IFE 1
        LDX #$FF        ; wird nicht assembliert
        .ENDIF          ; Bedingtes Assemblieren wird aufgehoben
                ; nichts passiert

        .IFN 5          ; IfNotEqual: Nur bei gesetztem Ausdruck assemblieren
        LDY #%11100111  ; wird assembliert...
        .ENDIF          ; Bedingtes Assemblieren wird aufgehoben
                ; $A0 $E7 wird übersetzt

        .IFP 12
        NOP             ; wird assembliert
        .ENDIF
                ; $EA eintragen

        .IFM 12         ; IfMinus ... (kleiner null: es wird assembliert)
        CLI
        .ENDIF
                ; nichts passiert

        .HL 31011797    ; Legt a im Format H3 H2 H1 L (long) ab
                ; $01 $D9 $33 $D5 eintragen

        .HW 2601        ; Legt a im Format H L (word) ab
                ; $0A $29 eintragen

        .BT 69          ; Legt a als Byte ab
                ; $45 eintragen

        .LI 'GOS.labels' ; LabelFile-Include mit FileNamen "GOS.labels"
                ; lädt das Label-File GOS.labels und übernimmt die Werte

        .FILL 10        ; Füll-Byte ist jetzt 10
        .BF BERECH3-9990
                ; Legt 10 Bytes mit $0A im Objekt-Code ab

        .PRINTT 'Fehlercode:' ; Text im Amiga-Fenster ausgeben...
        .PRINTV 20-5/5        ; Ausdruck gibt 3, kein Punkt vor Strich!
        

-----------

Für Terme gibt es folgende Rechenarten:

z.B.
                .BT 10*10       ; legt das Byte 100 ab



        PLUS    +       ; z.B. 5+20 gibt 25
        MINUS   -       ; z.B. 20-10 gibt 10
        MAL     *       ; z.B. 100*2 gibt 200
        DURCH   /       ; z.B. 200/5 gibt 40
        MODULO  %       ; z.B. 200/6 gibt 2
        AND     &       ; z.B. %01010101 & %10111010 gibt 32
        OR      |       ; z.B. %00001111 | $40 gibt 79

--------------------------------

Statusmeldung nach dem Assemblieren:

z.B. Source 550, Objekt 6 (von $4000-$4004), Labels 96, Ticks: 12)

Der Sourcecode hatte eine Länge von 550 Byte, der Objektcode 6 Byte.
Er belegt den Speicherbereich von $4000 bis $4004 (ausschließlich).
Die Labels benötigen 96 Byte Platz, 12 Zeiteinheiten wurden benötigt.

Fehlermeldungen:


  2     Klammerfehler
  3     Kommafehler
  4     Nur Rückwärtsreferenzen bei diesem Befehl
  5     Unsinniger Zahlenwert
  7     Wiederholung von '*', '$', '#', '<', '>'
  8     Syntax Fehler
  9     unbekannter Befehl
 10     Kein Platz mehr für Labels
 11     Ungültiger Label
 13     Label nicht gefunden
 14     fehlerhafte Adressierung
 15     Branch zu weit
 16     Bereichsüberlauf
 17     Kein Platz mehr für ZweitPassLabels!
 18     Zahlensystem ungültig
 19     Division durch Null!
 20     .BY-Feld länger als 256 Bytes
 26     Probleme beim Schreiben in die Label-Datei
 27     Ungültiger Name bei .LI
 28     Warnung: .ENDIF ohne entsprechendes .IF

 30     Label bereits definiert
 31     Label noch nicht definiert

 Nummern ab 35 brechen sofort ab

 35     Speicherbedarf von ObjektCode zu groß (OBJEKTMEM ?)
 36     Fehler beim Schreiben in die Ausgabedatei
 37     Kein Platz mehr für ZweitPassLabels
 38     Kein Platz mehr für Labels (LABELMEM ?)
 39     Assemblierung abgebrochen

  Die Länge des Speicherbereichs, den der GASS für den Objektcode und
  die Labels reserviert, ist abhängig von der Länge des Sourcecodes.

  Ist dieser Bereich zu klein, kommen die Fehler 35 oder 38. Mit dem
  Merkmal OBJEKTMEM=10000 oder LABELMEM=50000 (unter Informationen... im
  WB-Piktogramm-Menue) wird mehr Speicher angefordert. Vom CLI aus bleibt
  nur, den SourceCode durch künstliche Kommentarzeilen zu vergrößern...



Mit dem GASS lege ich ein Programm ar.gass bei, das normalerweise zum
Varus Netzwerk gehört. Es ist ohne dieses Betriebssystem nicht lauffähig
und soll nur zur Demonstration dienen.

                        Viel Spaß mit dem GASS!

                            Kajetan Hinner
