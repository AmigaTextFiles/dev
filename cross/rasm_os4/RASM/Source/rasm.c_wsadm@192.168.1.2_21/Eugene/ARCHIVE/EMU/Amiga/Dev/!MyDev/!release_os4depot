#define PROGRAM_NAME      "RASM"
#define PROGRAM_VERSION   "1.3"
#define PROGRAM_DATE      "xx/11/2020"
#define PROGRAM_COPYRIGHT "© 2017 BERGE Edouard / roudoudou from Resistance"

#define RASM_VERSION PROGRAM_NAME" v"PROGRAM_VERSION" (build "PROGRAM_DATE")"
#define RASM_SNAP_VERSION PROGRAM_NAME" v"PROGRAM_VERSION

#define TRACE_GENERALE 0
#define TRACE_PREPRO 0
#define TRACE_ASSEMBLE 0
#define TRACE_COMPUTE_EXPRESSION 0
#define TRACE_HEXBIN 0
#define TRACE_MAKEAMSDOSREAL 0
#define TRACE_STRUCT 0
#define TRACE_EDSK 0
#define TRACE_LABEL 0

#ifdef __amigaos4__
volatile const char *verstag = "\0$VER: RASM Assembler v1.3 (30.11.2020)";
#else
const char *verstag = "\0$VER: RASM Assembler v1.3 (30.11.2020)";
#endif

/***
Rasm (roudoudou assembler) Z80 assembler

doc & latest official release at: https://github.com/EdouardBERGE/rasm

You may send requests/bugs in the same topic

-----------------------------------------------------------------------------------------------------
This software is using MIT "expat" license

« Copyright © BERGE Edouard (roudoudou)

Permission  is  hereby  granted,  free  of charge,to any person obtaining a copy  of  this  software
and  associated  documentation/source   files   of RASM, to deal in the Software without restriction,
including without limitation the  rights  to  use, copy,   modify,   merge,   publish,    distribute,
sublicense,  and/or  sell  copies of the Software, and  to  permit  persons  to  whom the Software is
furnished  to  do  so,  subject  to  the following conditions:

The above copyright  notice  and  this  permission notice   shall   be  included  in  all  copies  or
substantial portions of the Software.
The   Software   is   provided  "as is",   without warranty   of   any   kind,  express  or  implied,
including  but  not  limited  to the warranties of merchantability,   fitness   for   a    particular
purpose  and  noninfringement.  In  no event shall the  authors  or  copyright  holders be liable for
any  claim, damages  or other  liability,  whether in  an  action  of  contract, tort  or  otherwise,
arising from,  out of  or in connection  with  the software  or  the  use  or  other  dealings in the
Software. »
-----------------------------------------------------------------------------------------------------
Linux compilation with GCC or Clang:
cc rasm.c -O2 -lm -lrt -march=native -o rasm
strip rasm

Windows compilation with Visual studio:
cl.exe rasm.c -O2 -Ob3

pure MS-DOS 32 bits compilation with Watcom without native support of AP-Ultra:
wcl386 rasm.c -6r -6s -fp6 -d0 -k4000000 -ox /bt=DOS /l=dos4g -DOS_WIN=1 -DNOAPLIB=1

MorphOS compilation (ixemul):
gcc -noixemul -O2 -c -o rasm rasm.c
strip rasm

MacOS compilation:
cc rasm.c -O2 -lm -march=native -o rasm

*/

#ifdef __WATCOMC__
#define OS_WIN 1
#endif

#ifdef _WIN32
#define OS_WIN 1
#endif

#ifdef _WIN64
#define OS_WIN 1
#endif

#ifndef RDD
	/* public lib */
	#include"minilib.h"
#else
	/* private dev lib wont be published */
	#include"../tools/library.h"
	#define TxtSplitWithChar _internal_TxtSplitWithChar
#endif

#ifndef NO_3RD_PARTIES
#define __FILENAME__ "3rd parties"
/* 3rd parties compression */
#include"zx7.h"
#include"lz4.h"
#include"exomizer.h"
#endif

#ifdef __MORPHOS__
/* Add standard version string to executable */
const char __attribute__((section(".text"))) ver_version[]={ "\0$VER: "PROGRAM_NAME" "PROGRAM_VERSION" ("PROGRAM_DATE") "PROGRAM_COPYRIGHT"" };
/* Expand the default stack to match rasm requirements (about 64KiB) */
unsigned long __stack = 128 * 1024;
#endif

#undef __FILENAME__
#define __FILENAME__ "rasm.c"

#ifndef OS_WIN
#define KNORMAL  "\x1B[0m"
#define KERROR   "\x1B[31m"
#define KAYGREEN "\x1B[32m"
#define KWARNING "\x1B[33m"
#define KBLUE    "\x1B[34m"
#define KVERBOSE "\x1B[36m"
#define KIO      "\x1B[97m"
#else
#define KNORMAL  ""
#define KERROR   "Error: "
#define KAYGREEN ""
#define KWARNING "Warning: "
#define KBLUE    ""
#define KVERBOSE ""
#define KIO      ""
#endif

/*******************************************************************
         c o m m a n d    l i n e    p a r a m e t e r s 
*******************************************************************/
enum e_dependencies_type {
E_DEPENDENCIES_NO=0,
E_DEPENDENCIES_LIST,
E_DEPENDENCIES_MAKE
};

struct s_parameter {
	char **labelfilename;
	char *filename;
	char *outputfilename;
	int automatic_radix;
	int export_local;
	int export_var;
	int export_equ;
	int export_sym;
	int export_multisym;
	int export_tape;
	char *flexible_export;
	int export_sna;
	int export_snabrk;
	int export_brk;
	int nowarning;
	int erronwarn;
	int checkmode;
	int dependencies;
	int maxerr;
	int macrovoid;
	int extended_error;
	int display_stats;
	int edskoverwrite;
	int xpr;
	float rough;
	int as80,dams,pasmo;
	int v2;
	int warn_unused;
	char *symbol_name;
	char *binary_name;
	char *cartridge_name;
	char *snapshot_name;
	char *rom_name;
	char *tape_name;
	char *breakpoint_name;
	char **symboldef;
	int nsymb,msymb;
	char **pathdef;
	int npath,mpath;
	int noampersand;
	char module_separator;
};



/*******************************************************************
 c o m p u t e   o p e r a t i o n s   f o r   c a l c u l a t o r
*******************************************************************/

enum e_compute_operation_type {
E_COMPUTE_OPERATION_PUSH_DATASTC=0,
E_COMPUTE_OPERATION_OPEN=1,
E_COMPUTE_OPERATION_CLOSE=2,
E_COMPUTE_OPERATION_ADD=3,
E_COMPUTE_OPERATION_SUB=4,
E_COMPUTE_OPERATION_DIV=5,
E_COMPUTE_OPERATION_MUL=6,
E_COMPUTE_OPERATION_ZAND=7,
E_COMPUTE_OPERATION_OR=8,
E_COMPUTE_OPERATION_MOD=9,
E_COMPUTE_OPERATION_XOR=10,
E_COMPUTE_OPERATION_NOT=11,
E_COMPUTE_OPERATION_SHL=12,
E_COMPUTE_OPERATION_SHR=13,
E_COMPUTE_OPERATION_BAND=14,
E_COMPUTE_OPERATION_BOR=15,
E_COMPUTE_OPERATION_LOWER=16,
E_COMPUTE_OPERATION_GREATER=17,
E_COMPUTE_OPERATION_EQUAL=18,
E_COMPUTE_OPERATION_NOTEQUAL=19,
E_COMPUTE_OPERATION_LOWEREQ=20,
E_COMPUTE_OPERATION_GREATEREQ=21,
/* math functions */
E_COMPUTE_OPERATION_SIN=22,
E_COMPUTE_OPERATION_COS=23,
E_COMPUTE_OPERATION_INT=24,
E_COMPUTE_OPERATION_FLOOR=25,
E_COMPUTE_OPERATION_ABS=26,
E_COMPUTE_OPERATION_LN=27,
E_COMPUTE_OPERATION_LOG10=28,
E_COMPUTE_OPERATION_SQRT=29,
E_COMPUTE_OPERATION_ASIN=30,
E_COMPUTE_OPERATION_ACOS=31,
E_COMPUTE_OPERATION_ATAN=32,
E_COMPUTE_OPERATION_EXP=33,
E_COMPUTE_OPERATION_LOW=34,
E_COMPUTE_OPERATION_HIGH=35,
E_COMPUTE_OPERATION_PSG=36,
E_COMPUTE_OPERATION_RND=37,
E_COMPUTE_OPERATION_FRAC=38,
E_COMPUTE_OPERATION_CEIL=39,
E_COMPUTE_OPERATION_GET_R=40,
E_COMPUTE_OPERATION_GET_V=41,
E_COMPUTE_OPERATION_GET_B=42,
E_COMPUTE_OPERATION_SET_R=43,
E_COMPUTE_OPERATION_SET_V=44,
E_COMPUTE_OPERATION_SET_B=45,
E_COMPUTE_OPERATION_SOFT2HARD=46,
E_COMPUTE_OPERATION_HARD2SOFT=47,
/* string functions */
E_COMPUTE_OPERATION_GETNOP=48,
E_COMPUTE_OPERATION_GETTICK=49,
E_COMPUTE_OPERATION_DURATION=50,
E_COMPUTE_OPERATION_END=51
};

struct s_compute_element {
enum e_compute_operation_type operator;
double value;
int priority;
char *string;
};

struct s_compute_core_data {
	/* evaluator v3 may be recursive */
	char *varbuffer;
	int maxivar;
	struct s_compute_element *tokenstack;
	int maxtokenstack;
	struct s_compute_element *operatorstack;
	int maxoperatorstack;
};

/***********************************************************
  w a v   h e a d e r    f o r    a u d i o    i m p o r t
***********************************************************/
struct s_wav_header {
char ChunkID[4];
unsigned char ChunkSize[4];
char Format[4];
char SubChunk1ID[4];
unsigned char SubChunk1Size[4];
unsigned char AudioFormat[2];
unsigned char NumChannels[2];
unsigned char SampleRate[4];
unsigned char ByteRate[4];
unsigned char BlockAlign[2];
unsigned char BitsPerSample[2];
unsigned char SubChunk2ID[4];
unsigned char SubChunk2Size[4];
};

enum e_audio_sample_type {
AUDIOSAMPLE_SMP,
AUDIOSAMPLE_SM2,
AUDIOSAMPLE_SM4,
AUDIOSAMPLE_DMAA,
AUDIOSAMPLE_DMAB,
AUDIOSAMPLE_DMAC,
AUDIOSAMPLE_END
};

/***********************************************************************
  e x p r e s s i o n   t y p e s   f o r   d e l a y e d   w r i t e
***********************************************************************/
enum e_expression {
	E_EXPRESSION_J8,     /* relative 8bits jump */
	E_EXPRESSION_0V8,    /* 8 bits value to current adress */
	E_EXPRESSION_V8,     /* 8 bits value to current adress+1 */
	E_EXPRESSION_V16,    /* 16 bits value to current adress+1 */
	E_EXPRESSION_V16C,   /* 16 bits value to current adress+1 */
	E_EXPRESSION_0V16,   /* 16 bits value to current adress */
	E_EXPRESSION_0V32,   /* 32 bits value to current adress */
	E_EXPRESSION_0VR,    /* AMSDOS real value (5 bytes) to current adress */
	E_EXPRESSION_0VRMike,/* Microsoft IEEE-754 real value (5 bytes) to current adress */
	E_EXPRESSION_IV8,    /* 8 bits value to current adress+2 */
	E_EXPRESSION_IV81,   /* 8 bits value+1 to current adress+2 */
	E_EXPRESSION_3V8,    /* 8 bits value to current adress+3 used with LD (IX+n),n */
	E_EXPRESSION_IV16,   /* 16 bits value to current adress+2 */
	E_EXPRESSION_RST,    /* the offset of RST is translated to the opcode */
	E_EXPRESSION_IM,     /* the interrupt mode is translated to the opcode */
	E_EXPRESSION_RUN,    /* delayed RUN value */
	E_EXPRESSION_ZXRUN,  /* delayed RUN value for ZX snapshot */
	E_EXPRESSION_ZXSTACK,/* delayed STACK value for ZX snapshot */
	E_EXPRESSION_BRS     /* delayed shifting for BIT, RES, SET */
};

struct s_expression {	
	char *reference;          /* backup when used inside loop (or macro?) */
	int iw;                   /* word index in the main wordlist */
	int o;                    /* offset de depart 0, 1 ou 3 selon l'opcode */
	int ptr;                  /* offset courant pour calculs relatifs */
	int wptr;                 /* where to write the result  */
	enum e_expression zetype; /* type of delayed write */
	int lz;                   /* lz zone */
	int ibank;                /* ibank of expression */
	int iorgzone;             /* org of expression */
	char *module;
};

struct s_expr_dico {
	char *name;
	int crc;
	int autorise_export;
	double v;
	int used;
	int iw;
};

struct s_label {
	char *name;   /* is alloced for local repeat or struct OR generated global -> in this case iw=-1 */
	int iw;       /* index of the word of label name */
	int crc;      /* crc of the label name */
	int ptr;      /* "physical" adress */
	int lz;       /* is the label in a crunched section (or after)? */
	int iorgzone; /* org of label */
	int ibank;    /* current CPR bank / always zero in classic mode */
	int local;
	/* errmsg */
	int fileidx;
	int fileline;
	int autorise_export,backidx;
	int used;
};

struct s_alias {
	char *alias;
	char *translation;
	int crc,len,autorise_export;
	int iw;
	int used;
};

struct s_ticker {
	char *varname;
	int crc;
	long nopstart;
	long tickerstart;
};

/***********************************************************************
   m e r k e l    t r e e s    f o r    l a b e l,  v a r,  a l i a s
***********************************************************************/
struct s_crclabel_tree {
	struct s_crclabel_tree *radix[256];
	struct s_label *label;
	int nlabel,mlabel;
};
struct s_crcdico_tree {
	struct s_crcdico_tree *radix[256];
	struct s_expr_dico *dico;
	int ndico,mdico;
};
struct s_crcused_tree {
	struct s_crcused_tree *radix[256];
	char **used;
	int nused,mused;
};
struct s_crcstring_tree {
	struct s_crcstring_tree *radix[256];
	char **text;
	int ntext,mtext;
	char **replace;
	int nreplace,mreplace;
};
/*************************************************
          m e m o r y    s e c t i o n
*************************************************/
struct s_lz_section {
	int iw;
	int memstart,memend;
	int lzversion; /* 0 -> NO CRUNCH but must be delayed / 4 -> LZ4 / 7 -> ZX7 / 48 -> LZ48 / 49 -> LZ49 / 8 -> Exomizer */
	int version,minmatch; /* LZSA */
	int iorgzone;
	int ibank;
	/* idx backup */
	int iexpr;
	int ilabel;
};

struct s_orgzone {
	int ibank,protect;
	int memstart,memend;
	int ifile,iline;
	int nocode;
	int inplace;
};

/**************************************************
         i n c b i n     s t o r a g e
**************************************************/
struct s_hexbin {
	unsigned char *data;
	int datalen,rawlen;
	char *filename;
	int crunch;
	int version,minmatch;
};

/**************************************************
          e d s k    m a n a g e m e n t        
**************************************************/
struct s_edsk_sector_global_struct {
unsigned char track;
unsigned char side;
unsigned char id;
unsigned char size;
unsigned char st1;
unsigned char st2;
unsigned short int length;
unsigned char *data;
};

struct s_edsk_track_global_struct  {
int sectornumber;
/* information purpose */
int sectorsize;
int gap3length;
int fillerbyte;
int datarate;
int recordingmode;
struct s_edsk_sector_global_struct *sector;
};

struct s_edsk_global_struct {
int tracknumber;
int sidenumber;
int tracksize; /* DSK legacy */
struct s_edsk_track_global_struct *track;
};

struct s_edsk_wrapper_entry {
unsigned char user;
unsigned char filename[11];
unsigned char subcpt;
unsigned char extendcounter;
unsigned char reserved;
unsigned char rc;
unsigned char blocks[16];
};

struct s_edsk_wrapper {
char *edsk_filename;
struct s_edsk_wrapper_entry entry[64];
int nbentry;
unsigned char blocks[178][1024]; /* DATA format */
int face;
};

struct s_save {
	int ibank;
	int ioffset;
	int isize;
	int iw,irun;
	int amsdos,hobeta;
	int tape,dsk,face,iwdskname;
};


/********************
      L O O P S
********************/

enum e_loop_style {
E_LOOPSTYLE_REPEATN,
E_LOOPSTYLE_REPEATUNTIL,
E_LOOPSTYLE_WHILE
};

struct s_repeat {
	int start;
	int cpt;
	int value;
	int maxim;
	int repeat_counter;
	char *repeatvar;
	int repeatcrc;
};

struct s_whilewend {
	int start;
	int cpt;
	int value;
	int maxim;
	int while_counter;
};

struct s_switchcase {
	int refval;
	int execute;
	int casematch;
};

struct s_repeat_index {
	int ifile;
	int ol,oidx;
	int cl,cidx;
};


enum e_ifthen_type {
E_IFTHEN_TYPE_IF=0,
E_IFTHEN_TYPE_IFNOT=1,
E_IFTHEN_TYPE_IFDEF=2,
E_IFTHEN_TYPE_IFNDEF=3,
E_IFTHEN_TYPE_ELSE=4,
E_IFTHEN_TYPE_ELSEIF=5,
E_IFTHEN_TYPE_IFUSED=6,
E_IFTHEN_TYPE_IFNUSED=7,
E_IFTHEN_TYPE_END
};

struct s_ifthen {
	char *filename;
	int line,v;
	enum e_ifthen_type type;
};

/**************************************************
          w o r d    p r o c e s s i n g
**************************************************/
struct s_wordlist {
	char *w;
	int l,t,e; /* e=1 si egalite dans le mot */
	int ifile;
};

struct s_macro {
	char *mnemo;
	int crc;
	/* une macro concatene des chaines et des parametres */
	struct s_wordlist *wc;
	int nbword,maxword;
	/**/
	char **param;
	int nbparam;
};

struct s_macro_position {
	int start,end,value,level,pushed;
	//char *lastlocal;
	//int lastlocalen,lastlocalalloc;
};

/* preprocessing only */
struct s_macro_fast {
	char *mnemo;
	int crc;
};

struct s_math_keyword {
	char *mnemo;
	int crc;
	enum e_compute_operation_type operation;
};

struct s_expr_word {
	char *w;
	int aw;
	int op;
	int comma;
	int fct;
	double v;
};

struct s_listing {
	char *listing;
	int ifile;
	int iline;
};

enum e_tagtranslateoption {
E_TAGOPTION_NONE=0,
E_TAGOPTION_REMOVESPACE=1,
E_TAGOPTION_PRESERVE=2
};

#ifdef RASM_THREAD
struct s_rasm_thread {
	pthread_t thread;
	int lz;
	unsigned char *datain;
	int datalen;
	unsigned char *dataout;
	int lenout;
	int status;
};
#endif


/*********************************************************
            S N A P S H O T     E X P O R T
*********************************************************/
/* extension 4Mo = 256 slots + 4 slots 64K de RAM par défaut => 260 */

#define BANK_MAX_NUMBER 260

struct s_snapshot_symbol {
	unsigned char size;
	unsigned char name[256];
	unsigned char reserved[6];
	unsigned char bigendian_adress[2];
};


struct s_zxsnapshot {
	
	unsigned int run;
	unsigned int stack;
};

struct s_snapshot {
	char idmark[8];
	char unused1[8];
	unsigned char version; /* 3 */
	struct {
		struct {
			unsigned char F;
			unsigned char A;
			unsigned char C;
			unsigned char B;
			unsigned char E;
			unsigned char D;
			unsigned char L;
			unsigned char H;
		}general;
		unsigned char R;
		unsigned char regI; /* I incompatible with tgmath.h */
		unsigned char IFF0;
		unsigned char IFF1;
		unsigned char LX;
		unsigned char HX;
		unsigned char LY;
		unsigned char HY;
		unsigned char LSP;
		unsigned char HSP;
		unsigned char LPC;
		unsigned char HPC;
		unsigned char IM; /* 0,1,2 */
		struct {
			unsigned char F;
			unsigned char A;
			unsigned char C;
			unsigned char B;
			unsigned char E;
			unsigned char D;
			unsigned char L;
			unsigned char H;
		}alternate;
	}registers;
		
	struct {
		unsigned char selectedpen;
		unsigned char palette[17];
		unsigned char multiconfiguration;
	}gatearray;
	unsigned char ramconfiguration;
	struct {
		unsigned char selectedregister;
		unsigned char registervalue[18];
	}crtc;
	unsigned char romselect;
	struct {
		unsigned char portA;
		unsigned char portB;
		unsigned char portC;
		unsigned char control;
	}ppi;
	struct {
		unsigned char selectedregister;
		unsigned char registervalue[16];
	}psg;
	unsigned char dumpsize[2]; /* 64 then use extended memory chunks */
	
	unsigned char CPCType; /* 0=464 / 1=664 / 2=6128 / 4=6128+ / 5=464+ / 6=GX4000 */
	unsigned char interruptnumber;
	unsigned char multimodebytes[6];
	unsigned char unused2[0x9C-0x75];
	
	/* offset #9C */
	struct {
		unsigned char motorstate;
		unsigned char physicaltrack;
	}fdd;
	unsigned char unused3[3];
	unsigned char printerstrobe;
	unsigned char unused4[2];
	struct {
		unsigned char model; /* 0->4 */
		unsigned char unused5[4];
		unsigned char HCC;
		unsigned char unused;
		unsigned char CLC;
		unsigned char RLC;
		unsigned char VTC;
		unsigned char HSC;
		unsigned char VSC;
		unsigned short int flags;
	}crtcstate;
	unsigned char vsyncdelay;
	unsigned char interruptscanlinecounter;
	unsigned char interruptrequestflag;
	unsigned char unused6[0xFF-0xB5+1];
};

struct s_snapshot_chunks {
	unsigned char chunkname[4]; /* MEM1 -> MEM8 */
	unsigned int chunksize;
};

struct s_breakpoint {
	int address;
	int bank;
};


/*********************************
        S T R U C T U R E S
*********************************/
enum e_rasmstructfieldtype {
E_RASMSTRUCTFIELD_BYTE,
E_RASMSTRUCTFIELD_WORD,
E_RASMSTRUCTFIELD_LONG,
E_RASMSTRUCTFIELD_REAL,
E_RASMSTRUCTFIELD_END
};
struct s_rasmstructfield {
	char *fullname;
	char *name;
	int offset;
	int size;
	int crc;
	/* filler */
	unsigned char *data;
	int idata,mdata;
	enum e_rasmstructfieldtype zetype;
};

struct s_rasmstruct {
	char *name;
	int crc;
	int size;
	int ptr;
	int nbelem;
	/* fields */
	struct s_rasmstructfield *rasmstructfield;
	int irasmstructfield,mrasmstructfield;
};

/*********************************
           D E B U G        
*********************************/
struct s_debug_error {
        char *filename;
        int line;
        char *msg;
        int lenmsg,lenfilename;
};
struct s_debug_symbol {
        char *name;
        int v;
};
struct s_rasm_info {
        struct s_debug_error *error;
        int nberror,maxerror;
        struct s_debug_symbol *symbol;
        int nbsymbol,maxsymbol;
};

/*******************************************
              P O K E R               
*******************************************/
enum e_poker {
E_POKER_XOR8=0,
E_POKER_SUM8=1,
E_POKER_END
};

struct s_poker {
	enum e_poker method;
	int istart,iend;
	int outputadr;
	int ibank;
};

/*******************************************
        G L O B A L     S T R U C T
*******************************************/
struct s_assenv {
	/* current memory */
	int maxptr;
	/* CPR memory */
	unsigned char **mem;
	int iwnamebank[BANK_MAX_NUMBER];
	int nbbank,maxbank;
	int forcetape,forcezx,forcecpr,forceROM,bankmode,activebank,amsdos,forcesnapshot,packedbank,extendedCPR,xpr;
	struct s_snapshot snapshot;
	struct s_zxsnapshot zxsnapshot;
	int bankset[BANK_MAX_NUMBER>>2];   /* 64K selected flag */
	int bankused[BANK_MAX_NUMBER]; /* 16K selected flag */
	int bankgate[BANK_MAX_NUMBER+1];
	int setgate[BANK_MAX_NUMBER+1];
	int rundefined;
	/* parsing */
	struct s_wordlist *wl;
	int nbword;
	int idx,stage;
	char *label_filename;
	int label_line;
	char **filename;
	int ifile,maxfile;
	int nberr,flux;
	int fastmatch[256];
	unsigned char charset[256];
	int maxerr,extended_error,nowarning,erronwarn;
	/* ORG tracking */
	int codeadr,outputadr,nocode;
	int codeadrbackup,outputadrbackup;
	int minadr,maxadr;
	struct s_orgzone *orgzone;
	int io,mo;
	/* Struct */
	struct s_rasmstruct *rasmstruct;
	int irasmstruct,mrasmstruct;
	int getstruct;
	int backup_outputadr,backup_codeadr;
	char *backup_filename;
	int backup_line;
	struct s_rasmstruct *rasmstructalias;
	int irasmstructalias,mrasmstructalias;
	/* expressions */
	struct s_expression *expression;
	int ie,me;
	int maxam,as80,dams,pasmo;
	float rough;
	struct s_compute_core_data *computectx,ctx1,ctx2;
	struct s_crcstring_tree stringtree;
	/* label */
	struct s_label *label;
	int il,ml;
	struct s_crclabel_tree labeltree; /* fast label access */
	char *module;
	int modulen;
	char module_separator[2];
	struct s_breakpoint *breakpoint;
	int ibreakpoint,maxbreakpoint;
	char *lastgloballabel;
	//char *lastsuperglobal;
	int lastgloballabellen, lastglobalalloc;
	char **globalstack; /* retrieve back global from previous scope */
	int igs,mgs;
	/* repeat */
	struct s_repeat *repeat;
	int ir,mr;
	/* while/wend */
	struct s_whilewend *whilewend;
	int iw,mw;
	/* if/then/else */
	//int *ifthen;
	struct s_ifthen *ifthen;
	int ii,mi;
	/* switch/case */
	struct s_switchcase *switchcase;
	int isw,msw;
	/* expression dictionnary */
	struct s_expr_dico *dico;
	int idic,mdic;
	struct s_crcdico_tree dicotree; /* fast dico access */
	struct s_crcused_tree usedtree; /* fast used access */
	/* ticker */
	struct s_ticker *ticker;
	int iticker,mticker;
	long tick,nop;
	/* crunch section flag */
	struct s_lz_section *lzsection;
	int ilz,mlz;
	int lz,curlz;
	/* poker */
	struct s_poker *poker;
	int nbpoker,maxpoker;
	/* macro */
	struct s_macro *macro;
	int imacro,mmacro;
	int macrovoid;
	/* labels locaux */
	int repeatcounter,whilecounter,macrocounter;
	struct s_macro_position *macropos;
	int imacropos,mmacropos;
	/* alias */
	struct s_alias *alias;
	int ialias,malias;
	/* hexbin */
	struct s_rasm_thread **rasm_thread;
	int irt,mrt;
	struct s_hexbin *hexbin;
	int ih,mh;
	char **includepath;
	int ipath,mpath;
	/* automates */
	char AutomateExpressionValidCharExtended[256];
	char AutomateExpressionValidCharFirst[256];
	char AutomateExpressionValidChar[256];
	char AutomateExpressionDecision[256];
	char AutomateValidLabelFirst[256];
	char AutomateValidLabel[256];
	char AutomateDigit[256];
	char AutomateHexa[256];
	struct s_compute_element AutomateElement[256];
	unsigned char psgtab[256];
	unsigned char psgfine[256];
	int noampersand;
	/* output */
	char *outputfilename;
	int export_sym,export_local,export_multisym;
	int export_var,export_equ;
	int export_sna,export_snabrk;
	int export_brk,export_tape;
	int autorise_export;
	char *flexible_export;
	char *breakpoint_name;
	char *symbol_name;
	char *binary_name;
	char *cartridge_name;
	char *snapshot_name;
	char *rom_name;
	struct s_save *save;
	int nbsave,maxsave;
	int current_run_idx;
	struct s_edsk_wrapper *edsk_wrapper;
	int nbedskwrapper,maxedskwrapper;
	int edskoverwrite;
	int checkmode,dependencies;
	int stop;
	int warn_unused;
	int display_stats;
	/* debug */
	struct s_rasm_info debug;
	struct s_rasm_info **retdebug;
	int debug_total_len;
};

/*************************************
         D I R E C T I V E S
*************************************/
struct s_asm_keyword {
	char *mnemo;
	int crc;
	void (*makemnemo)(struct s_assenv *ae);
};

struct s_math_keyword math_keyword[]={
{"SIN",0,E_COMPUTE_OPERATION_SIN},
{"COS",0,E_COMPUTE_OPERATION_COS},
{"INT",0,E_COMPUTE_OPERATION_INT},
{"ABS",0,E_COMPUTE_OPERATION_ABS},
{"LN",0,E_COMPUTE_OPERATION_LN},
{"LOG10",0,E_COMPUTE_OPERATION_LOG10},
{"SQRT",0,E_COMPUTE_OPERATION_SQRT},
{"FLOOR",0,E_COMPUTE_OPERATION_FLOOR},
{"ASIN",0,E_COMPUTE_OPERATION_ASIN},
{"ACOS",0,E_COMPUTE_OPERATION_ACOS},
{"ATAN",0,E_COMPUTE_OPERATION_ATAN},
{"EXP",0,E_COMPUTE_OPERATION_EXP},
{"LO",0,E_COMPUTE_OPERATION_LOW},
{"HI",0,E_COMPUTE_OPERATION_HIGH},
{"PSGVALUE",0,E_COMPUTE_OPERATION_PSG},
{"RND",0,E_COMPUTE_OPERATION_RND},
{"FRAC",0,E_COMPUTE_OPERATION_FRAC},
{"CEIL",0,E_COMPUTE_OPERATION_CEIL},
{"GETR",0,E_COMPUTE_OPERATION_GET_R},
{"GETV",0,E_COMPUTE_OPERATION_GET_V},
{"GETG",0,E_COMPUTE_OPERATION_GET_V},
{"GETB",0,E_COMPUTE_OPERATION_GET_B},
{"SETR",0,E_COMPUTE_OPERATION_SET_R},
{"SETV",0,E_COMPUTE_OPERATION_SET_V},
{"SETG",0,E_COMPUTE_OPERATION_SET_V},
{"SETB",0,E_COMPUTE_OPERATION_SET_B},
{"SOFT2HARD_INK",0,E_COMPUTE_OPERATION_SOFT2HARD},
{"S2H_INK",0,E_COMPUTE_OPERATION_SOFT2HARD},
{"HARD2SOFT_INK",0,E_COMPUTE_OPERATION_HARD2SOFT},
{"H2S_INK",0,E_COMPUTE_OPERATION_HARD2SOFT},
{"GETNOP",0,E_COMPUTE_OPERATION_GETNOP},
{"GETTICK",0,E_COMPUTE_OPERATION_GETTICK},
{"DURATION",0,E_COMPUTE_OPERATION_DURATION},
{"",0,-1}
};

#define CRC_SWITCH    0x01AEDE4A
#define CRC_CASE      0x0826B794
#define CRC_DEFAULT   0x9A0DAC7D
#define CRC_BREAK     0xCD364DDD
#define CRC_ENDSWITCH 0x18E9FB21

#define CRC_ELSEIF 0xE175E230
#define CRC_ELSE   0x3FF177A1
#define CRC_ENDIF  0xCD5265DE
#define CRC_IF     0x4BD52507
#define CRC_IFDEF  0x4CB29DD6
#define CRC_UNDEF  0xCCD2FDEA
#define CRC_IFNDEF 0xD9AD0824
#define CRC_IFNOT  0x4CCAC9F8
#define CRC_WHILE  0xBC268FF1
#define CRC_UNTIL  0xCC12A604
#define CRC_MEND   0xFFFD899C
#define CRC_ENDM   0x3FF9559C
#define CRC_MACRO  0x64AA85EA
#define CRC_IFUSED 0x91752638
#define CRC_IFNUSED 0x1B39A886

#define CRC_SIN 0xE1B71962
#define CRC_COS 0xE077C55D

#define CRC_0    0x7A98A6A8
#define CRC_1    0x7A98A6A9
#define CRC_2    0x7A98A6AA


#define CRC_NC   0x4BD52B09
#define CRC_Z    0x7A98A6D2
#define CRC_NZ   0x4BD52B20
#define CRC_P    0x7A98A6C8
#define CRC_PO   0x4BD53717
#define CRC_PE   0x4BD5370D
#define CRC_M    0x7A98A6C5

/* cut registers */
#define CRC_HL_LOW	0xF9FDE22C
#define CRC_HL_HIGH	0x2261E25A
#define CRC_DE_LOW	0x3A3CE221
#define CRC_DE_HIGH	0x23D0E04F
#define CRC_BC_LOW	0xFDFF1E1D
#define CRC_BC_HIGH	0x222BE44B
#define CRC_IX_LOW	0xB9FD0439
#define CRC_IX_HIGH	0xA3FD0667
#define CRC_IY_LOW	0xD9ED6C3A
#define CRC_IY_HIGH	0x23DD5068
#define CRC_AF_LOW	0xDDCF141F
#define CRC_AF_HIGH	0x223FEA4D

/* 8 bits registers */
#define CRC_F    0x7A98A6BE
#define CRC_I    0x7A98A6C1
#define CRC_R    0x7A98A6CA
#define CRC_A    0x7A98A6B9
#define CRC_B    0x7A98A6BA
#define CRC_C    0x7A98A6BB
#define CRC_D    0x7A98A6BC
#define CRC_E    0x7A98A6BD
#define CRC_H    0x7A98A6C0
#define CRC_L    0x7A98A6C4
/* dual naming */
#define CRC_XH   0x4BD50718
#define CRC_XL   0x4BD5071C
#define CRC_YH   0x4BD50519
#define CRC_YL   0x4BD5051D
#define CRC_HX   0x4BD52718
#define CRC_LX   0x4BD52F1C
#define CRC_HY   0x4BD52719
#define CRC_LY   0x4BD52F1D
#define CRC_IXL  0xE19F1765
#define CRC_IXH  0xE19F1761
#define CRC_IYL  0xE19F1166
#define CRC_IYH  0xE19F1162

/* 16 bits registers */
#define CRC_BC   0x4BD5D2FD
#define CRC_DE   0x4BD5DF01
#define CRC_HL   0x4BD5270C
#define CRC_IX   0x4BD52519
#define CRC_IY   0x4BD5251A
#define CRC_SP   0x4BD5311B
#define CRC_AF   0x4BD5D4FF
/* memory convention */
#define CRC_MHL  0xD0765F5D
#define CRC_MDE  0xD0467D52
#define CRC_MBC  0xD05E694E
#define CRC_MIX  0xD072B76A
#define CRC_MIY  0xD072B16B
#define CRC_MSP  0xD01A876C
#define CRC_MC   0xE018210C
/* struct parsing */
#define CRC_DEFB	0x37D15389
#define CRC_DB		0x4BD5DEFE
#define CRC_DEFW	0x37D1539E
#define CRC_DW		0x4BD5DF13
#define CRC_DEFI	0x37D15390
#define CRC_DEFS	0x37D1539A
#define CRC_DS		0x4BD5DF0F
#define CRC_DEFR	0x37D15399
#define CRC_DR		0x4BD5DF0E
#define CRC_DEFF	0x37D1538D
#define CRC_DF	        0x4BD5DF02

/* struct declaration use special instructions for defines */
int ICRC_DEFB,ICRC_DEFW,ICRC_DEFI,ICRC_DEFR,ICRC_DEFF,ICRC_DF,ICRC_DEFS,ICRC_DB,ICRC_DW,ICRC_DR,ICRC_DS;
/* need to pre-declare var */
extern struct s_asm_keyword instruction[];

/*
# base=16
% base=2
0-9 base=10
A-Z variable ou fonction (cos, sin, tan, sqr, pow, mod, and, xor, mod, ...)
+*-/&^m| operateur
*/

#define AutomateExpressionValidCharExtendedDefinition "0123456789.ABCDEFGHIJKLMNOPQRSTUVWXYZ_{}@+-*/~^$#%<=>|&" /* § */
#define AutomateExpressionValidCharFirstDefinition "#%0123456789.ABCDEFGHIJKLMNOPQRSTUVWXYZ_@${"
#define AutomateExpressionValidCharDefinition "0123456789.ABCDEFGHIJKLMNOPQRSTUVWXYZ_{}@$"
#define AutomateValidLabelFirstDefinition ".ABCDEFGHIJKLMNOPQRSTUVWXYZ_@"
#define AutomateValidLabelDefinition "0123456789.ABCDEFGHIJKLMNOPQRSTUVWXYZ_@{}"
#define AutomateDigitDefinition ".0123456789"
#define AutomateHexaDefinition "0123456789ABCDEF"

#ifndef NO_3RD_PARTIES
unsigned char *LZ4_crunch(unsigned char *data, int zelen, int *retlen){
	unsigned char *lzdest=NULL;
	lzdest=MemMalloc(65536);
	*retlen=LZ4_compress_HC((char*)data,(char*)lzdest,zelen,65536,9);
	return lzdest;
}
#ifndef NOAPULTRA
size_t apultra_compress(const unsigned char *pInputData, unsigned char *pOutBuffer, size_t nInputSize, size_t nMaxOutBufferSize,
      const unsigned int nFlags, size_t nMaxWindowSize, size_t nDictionarySize, void(*progress)(long long nOriginalSize, long long nCompressedSize), void *pStats);
size_t apultra_get_max_compressed_size(size_t nInputSize);

int do_apultra(unsigned char *datain, int lenin, unsigned char **dataout, int *lenout) {
   size_t nCompressedSize = 0L, nMaxCompressedSize;
   int nFlags = 0;
   //apultra_stats stats;
   unsigned char *pCompressedData;

   /* Allocate max compressed size */

   nMaxCompressedSize = apultra_get_max_compressed_size(lenin);
   pCompressedData = (unsigned char*)MemMalloc(nMaxCompressedSize);
   memset(pCompressedData, 0, nMaxCompressedSize);

   nCompressedSize = apultra_compress(datain, pCompressedData, lenin, nMaxCompressedSize, nFlags, 65536, 0 /* dico */, NULL /*compression_progress*/, NULL /*&stats*/);

   if (nCompressedSize == -1) {
      fprintf(stderr, "APULTRA compression error\n");
      *lenout=0;
      *dataout=NULL;
      return 100;
   }

   *lenout=nCompressedSize;
   *dataout=pCompressedData;
   return 0;
}
int APULTRA_crunch(unsigned char *data, int len, unsigned char **dataout, int *lenout) {
   return do_apultra(data, len, dataout, lenout);
}


size_t lzsa_compress_inmem(unsigned char *pInputData, unsigned char *pOutBuffer, size_t nInputSize, size_t nMaxOutBufferSize,
                             const unsigned int nFlags, const int nMinMatchSize, const int nFormatVersion);

int LZSA_crunch(unsigned char *datain, int lenin, unsigned char **dataout, int *lenout, int version, int matchsize) {
   size_t nCompressedSize = 0L, nMaxCompressedSize;
   int nFlags = 0;
   unsigned char *pCompressedData;

pCompressedData=(unsigned char *)MemMalloc(65536);
nMaxCompressedSize=65536;

/* RAW */
nFlags=1<<1; // nFlags=LZSA_FLAG_RAW_BLOCK;
/* par défaut du LZSA1-Fast */
if (version<1 || version>2) {
	version=1;
}
if (matchsize<2 || matchsize>5) {
	switch (version) {
		case 1:matchsize=5;break;
		case 2:matchsize=2;break;
		default:break;
	}
}

nCompressedSize=lzsa_compress_inmem(datain, pCompressedData, lenin, nMaxCompressedSize, nFlags, matchsize, version);

   if (nCompressedSize == -1) {
      fprintf(stderr, "LZSA compression error\n");
      *lenout=0;
      *dataout=NULL;
      return 100;
   }

   *lenout=nCompressedSize;
   *dataout=pCompressedData;
   return 0;
}

#endif
#endif

unsigned char *LZ48_encode_legacy(unsigned char *data, int length, int *retlength);
#define LZ48_crunch LZ48_encode_legacy
unsigned char *LZ49_encode_legacy(unsigned char *data, int length, int *retlength);
#define LZ49_crunch LZ49_encode_legacy


/*
 * optimised reading of text file in one shot
 */
unsigned char *_internal_readbinaryfile(char *filename, int *filelength)
{
        #undef FUNC
        #define FUNC "_internal_readbinaryfile"

        unsigned char *binary_data=NULL;

        *filelength=FileGetSize(filename);
        binary_data=MemMalloc((*filelength)+1);
        /* we try to read one byte more to close the file just after the read func */
        if (FileReadBinary(filename,(char*)binary_data,(*filelength)+1)!=*filelength) {
                logerr("Cannot fully read %s",filename);
                exit(INTERNAL_ERROR);
        }
        return binary_data;
}
char **_internal_readtextfile(char *filename, char replacechar)
{
        #undef FUNC
        #define FUNC "_internal_readtextfile"

        char **lines_buffer=NULL;
        unsigned char *bigbuffer;
        int nb_lines=0,max_lines=0,i=0,e=0;
        int file_size;

        bigbuffer=_internal_readbinaryfile(filename,&file_size);

        while (i<file_size) {
                while (e<file_size && bigbuffer[e]!=0x0A) {
                        /* Windows de meeeeeeeerrrdde... */
                        if (bigbuffer[e]==0x0D) bigbuffer[e]=replacechar;
                        e++;
                }
                if (e<file_size) e++;
                if (nb_lines>=max_lines) {
                        max_lines=max_lines*2+10;
                        lines_buffer=MemRealloc(lines_buffer,(max_lines+1)*sizeof(char **));
                }
                lines_buffer[nb_lines]=MemMalloc(e-i+1);
                memcpy(lines_buffer[nb_lines],bigbuffer+i,e-i);
                lines_buffer[nb_lines][e-i]=0;
                if (0)
                {
                        int yy;
                        for (yy=0;lines_buffer[nb_lines][yy];yy++) {
                                if (lines_buffer[nb_lines][yy]>31) printf("%c",lines_buffer[nb_lines][yy]); else printf("(0x%X)",lines_buffer[nb_lines][yy]);
                        }
                        printf("\n");
                }
                nb_lines++;
                i=e;
        }
        if (!max_lines) {
                lines_buffer=MemMalloc(sizeof(char**));
                lines_buffer[0]=NULL;
        } else {
                lines_buffer[nb_lines]=NULL;
        }
        MemFree(bigbuffer);
        return lines_buffer;
}

#define FileReadLines(filename) _internal_readtextfile(filename,':')
#define FileReadLinesRAW(filename) _internal_readtextfile(filename,0x0D)
#define FileReadContent(filename,filesize) _internal_readbinaryfile(filename,filesize)


/***
	TxtReplace
	
	input:
	in_str:     string where replace will occur
	in_substr:  substring to look for
	out_substr: replace substring
	recurse:    loop until no in_substr is found
	
	note: in_str MUST BE previously mallocated if out_substr is bigger than in_substr
*/
#ifndef RDD
char *TxtReplace(char *in_str, char *in_substr, char *out_substr, int recurse)
{
	#undef FUNC
	#define FUNC "TxtReplace"
	
	char *str_look,*m1,*m2;
	char *out_str;
	int sl,l1,l2,dif,cpt;

	if (in_str==NULL)
		return NULL;
		
	sl=strlen(in_str);
	l1=strlen(in_substr);
	/* empty string, nothing to do except return empty string */
	if (!sl || !l1)
		return in_str;
		
	l2=strlen(out_substr);
	dif=l2-l1;
		
	/* replace string is small or equal in size, we dont realloc */
	if (dif<=0)
	{
		/* we loop while there is a replace to do */
		str_look=strstr(in_str,in_substr);
		while (str_look!=NULL)
		{
			/* we copy the new string if his len is not null */
			if (l2)
				memcpy(str_look,out_substr,l2);
			/* only if len are different */
			if (l1!=l2)
			{
				/* we move the end of the string byte per byte
				   because memory locations overlap. This is
				   faster than memmove */
				m1=str_look+l1;
				m2=str_look+l2;
				while (*m1!=0)
				{
					*m2=*m1;
					m1++;m2++;
				}
				/* we must copy the EOL */
				*m2=*m1;
			}
			/* look for next replace */
			if (!recurse)
				str_look=strstr(str_look+l2,in_substr);
			else
				str_look=strstr(in_str,in_substr);
		}
		out_str=in_str;
	}
	else
	{
		/* we need to count each replace */
		cpt=0;
		str_look=strstr(in_str,in_substr);
		while (str_look!=NULL)
		{
			cpt++;
			str_look=strstr(str_look+l1,in_substr);
		}
		/* is there anything to do? */
		if (cpt)
		{
			/* we realloc to a size that will fit all replaces */
			out_str=MemRealloc(in_str,sl+1+dif*cpt);
			str_look=strstr(out_str,in_substr);
			while (str_look!=NULL && cpt)
			{
				/* as the replace string is bigger we
				   have to move memory first from the end */
				m1=out_str+sl;
				m2=m1+dif;
				sl+=dif;
				while (m1!=str_look+l1-dif)
				{
					*m2=*m1;
					m1--;m2--;
				}
				/* then we copy the replace string (can't be NULL in this case) */
				memcpy(str_look,out_substr,l2);
				
				/* look for next replace */
				if (!recurse)
					str_look=strstr(str_look+l2,in_substr);
				else
					str_look=strstr(in_str,in_substr);
					
				/* to prevent from naughty overlap */
				cpt--;
			}
			if (str_look!=NULL)
			{
				printf("INTERNAL ERROR - overlapping replace string (%s/%s), you can't use this one!\n",in_substr,out_substr);
				exit(ABORT_ERROR);
			}
		}
		else
			out_str=in_str;
	}
	return out_str;
}
#endif

#ifndef min
#define min(a,b) \
   ({ __typeof__ (a) _a = (a); \
       __typeof__ (b) _b = (b); \
     _a < _b ? _a : _b; })
#endif

/* Levenshtein implementation by TheRayTracer https://gist.github.com/TheRayTracer/2644387 */
int _internal_LevenshteinDistance(char *s,  char *t)
{
	int i,j,n,m,*d;
	int im,jn;
	int r;
	
   n=strlen(s)+1;
   m=strlen(t)+1;
   d=malloc(n*m*sizeof(int));
   memset(d, 0, sizeof(int) * n * m);

   for (i = 1, im = 0; i < m; i++, im++)
   {
      for (j = 1, jn = 0; j < n; j++, jn++)
      {
         if (s[jn] == t[im])
         {
            d[(i * n) + j] = d[((i - 1) * n) + (j - 1)];
         }
         else
         {
            d[(i * n) + j] = min(d[(i - 1) * n + j] + 1, /* A deletion. */
                                 min(d[i * n + (j - 1)] + 1, /* An insertion. */
                                     d[(i - 1) * n + (j - 1)] + 1)); /* A substitution. */
         }
      }
   }
   r = d[n * m - 1];
   free(d);
   return r;
}

unsigned int FastRand()
{
        #undef FUNC
        #define FUNC "FastRand"
	static unsigned int zeseed=0x12345678;
        zeseed=214013*zeseed+2531011;
        return (zeseed>>16)&0x7FFF;
}


#ifdef RASM_THREAD
/*
 threads used for crunching
*/
void _internal_ExecuteThreads(struct s_assenv *ae,struct s_rasm_thread *rasm_thread, void *(*fct)(void *))
{
	#undef FUNC
	#define FUNC "_internal_ExecuteThreads"

	pthread_attr_t attr;
	void *status;
	int rc;
	/* launch threads */
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr,PTHREAD_CREATE_JOINABLE);
	pthread_attr_setstacksize(&attr,65536);

	if ((rc=pthread_create(&image_threads[i].thread,&attr,fct,(void *)rasm_thread))) {
		rasm_printf(ae,"FATAL ERROR - Cannot create thread!\n");
		exit(INTERNAL_ERROR);
	}
}
void _internal_WaitForThreads(struct s_assenv *ae,struct s_rasm_thread *rasm_thread)
{
	#undef FUNC
	#define FUNC "_internal_WaitForThreads"
	int rc;
	
	if ((rc=pthread_join(rasm_thread->thread,&status))) {
		rasm_printf(ae,"FATAL ERROR - Cannot wait for thread\n");
		exit(INTERNAL_ERROR);
	}
}
void PushCrunchedFile(struct s_assenv *ae, unsigned char *datain, int datalen, int lz)
{
	#undef FUNC
	#define FUNC "PushCrunchedFile"
	
	struct s_rasm_thread *rasm_thread;
	
	rasm_thread=MemMalloc(sizeof(struct s_rasm_thread));
	memset(rasm_thread,0,sizeof(struct s_rasm_thread));
	rasm_thread->datain=datain;
	rasm_thread->datalen=datalen;
	rasm_thread->lz=lz;
	_internal_ExecuteThreads(ae,rasm_thread, void *(*fct)(void *));
	ObjectArrayAddDynamicValueConcat((void**)&ae->rasm_thread,&ae->irt,&ae->mrt,&rasm_thread,sizeof(struct s_rasm_thread *));
}
void PopAllCrunchedFiles(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "PopAllCrunchedFiles"
	
	int i;
	for (i=0;i<ae->irt;i++) {
		_internal_WaitForThreads(ae,ae->rasm_thread[i]);
	}
}
#endif

void MaxError(struct s_assenv *ae);

void rasm_printf(struct s_assenv *ae, ...) {
	#undef FUNC
	#define FUNC "(internal) rasm_printf"
	
	char *format;
	va_list argptr;

	if (!ae->flux && !ae->dependencies) {
		va_start(argptr,ae);
		format=va_arg(argptr,char *);
		vfprintf(stdout,format,argptr);	
		va_end(argptr);
		fprintf(stdout,KNORMAL);
	}
}
/***
	build the string of current line for error messages
*/
char *rasm_getline(struct s_assenv *ae, int offset) {
	#undef FUNC
	#define FUNC "rasm_getline"
	
	static char myline[40]={0};
	int idx=0,icopy,first=1;

	while (!ae->wl[ae->idx+offset].t && idx<32) {
		for (icopy=0;idx<32 && ae->wl[ae->idx+offset].w[icopy];icopy++) {
			myline[idx++]=ae->wl[ae->idx+offset].w[icopy];
		}
		if (!first) myline[idx++]=','; else first=0;
		offset++;
	}
	if (idx>=32) {
		strcpy(myline+29,"...");
	} else {
		myline[idx++]=0;
	}
	
	return myline;
}

char *SimplifyPath(char *filename) {
	#undef FUNC
	#define FUNC "SimplifyPath"

	return filename;
#if 0	
	char *pos,*repos;
	int i,len;

	char *rpath;

	rpath=realpath(filename,NULL);
	if (!rpath) {
		printf("rpath error!\n");
		switch (errno) {
			case EACCES:printf("read permission failure\n");break;
			case EINVAL:printf("wrong argument\n");break;
			case EIO:printf("I/O error\n");break;
			case ELOOP:printf("too many symbolic links\n");break;
			case ENAMETOOLONG:printf("names too long\n");break;
			case ENOENT:printf("names does not exists\n");break;
			case ENOMEM:printf("out of memory\n");break;
			case ENOTDIR:printf("a component of the path is not a directory\n");break;
			default:printf("unknown error\n");break;
		}
		exit(1);
	}
	if (strlen(rpath)<strlen(filename)) {
		strcpy(filename,rpath);
	}
	free(rpath);
	return filename;
	
#ifdef OS_WIN
	while ((pos=strstr(filename,"\\..\\"))!=NULL) {
		repos=pos-1;
		/* sequence found, looking back for '\' */
		while (repos>=filename) {
			if (*repos=='\\') {
				break;
			}
			repos--;
		}
		repos++;
		if (repos>=filename && repos!=pos) {
			len=strlen(pos)-4+1;
			pos+=4;
			for (i=0;i<len;i++) {
				*repos=*pos;
				repos++;
				pos++;
			}
		}
		if (strncmp(filename,".\\..\\",5)==0) {
			repos=filename;
			pos=repos+2;
			for (;*repos;pos++,repos++) {
				*repos=*pos;
			}
			*repos=0;
		}
	}
#else
printf("*************\nfilename=[%s]\n",filename);
	while ((pos=strstr(filename,"/../"))!=NULL) {
		repos=pos-1;
		while (repos>=filename) {
			if (*repos=='/') {
				break;
			}
			repos--;
		}
		repos++;
		if (repos>=filename && repos!=pos) {
			len=strlen(pos)-4+1;
			pos+=4;
			for (i=0;i<len;i++) {
				*repos=*pos;
				repos++;
				pos++;
			}
		}
printf("filename=[%s]\n",filename);
		if (strncmp(filename,"./../",5)==0) {
			repos=filename;
			pos=repos+2;
			for (;*repos;pos++,repos++) {
				*repos=*pos;
			}
			*repos=0;
		}
printf("filename=[%s]\n",filename);
	}
#endif
	return NULL;
#endif

}

char *rasm_GetPath(char *filename) {
	#undef FUNC
	#define FUNC "rasm_GetPath"

	static char curpath[PATH_MAX];
	int zelen,idx;

	zelen=strlen(filename);

#ifdef OS_WIN
	#define CURRENT_DIR ".\\"

	TxtReplace(filename,"/","\\",1);
	idx=zelen-1;
	while (idx>=0 && filename[idx]!='\\') idx--;
	if (idx<0) {
		/* pas de chemin */
		strcpy(curpath,".\\");
	} else {
		/* chemin trouve */
		strcpy(curpath,filename);
		curpath[idx+1]=0;
	}
#else
#ifdef __MORPHOS__
	#define CURRENT_DIR ""
#else
	#define CURRENT_DIR "./"
#endif
	idx=zelen-1;
	while (idx>=0 && filename[idx]!='/') idx--;
	if (idx<0) {
		/* pas de chemin */
		strcpy(curpath,CURRENT_DIR);
	} else {
		/* chemin trouve */
		strcpy(curpath,filename);
		curpath[idx+1]=0;
	}
#endif

	return curpath;
}
char *MergePath(struct s_assenv *ae,char *dadfilename, char *filename) {
	#undef FUNC
	#define FUNC "MergePath"

	static char curpath[PATH_MAX];


#ifdef OS_WIN
	TxtReplace(filename,"/","\\",1);

	if (filename[0] && filename[1]==':' && filename[2]=='\\') {
		/* chemin absolu */
		strcpy(curpath,filename);
	} else if (filename[0] && filename[1]==':') {
		rasm_printf(ae,KERROR"unsupported path style [%s]\n",filename);
		exit(-111);
	} else {
		if (filename[0]=='.' && filename[1]=='\\') {
			strcpy(curpath,rasm_GetPath(dadfilename));
			strcat(curpath,filename+2);
		} else {
			strcpy(curpath,rasm_GetPath(dadfilename));
			strcat(curpath,filename);
		}
	}
#else
	if (filename[0]=='/') {
		/* chemin absolu */
		strcpy(curpath,filename);
	} else if (filename[0]=='.' && filename[1]=='/') {
		strcpy(curpath,rasm_GetPath(dadfilename));
		strcat(curpath,filename+2);
	} else {
		strcpy(curpath,rasm_GetPath(dadfilename));
		strcat(curpath,filename);
	}
#endif

	return curpath;
}


void InitAutomate(char *autotab, const unsigned char *def)
{
	#undef FUNC
	#define FUNC "InitAutomate"

	int i;

	memset(autotab,0,256);
	for (i=0;def[i];i++) {
		autotab[(unsigned int)def[i]]=1;
	}
}
void StateMachineResizeBuffer(char **ABuf, int idx, int *ASize) {
	#undef FUNC
	#define FUNC "StateMachineResizeBuffer"

	if (idx>=*ASize) {
		if (*ASize<16384) {
			*ASize=(*ASize)*2;
		} else {
			*ASize=(*ASize)+16384;
		}
		*ABuf=MemRealloc(*ABuf,(*ASize)+2);
	}
}

int GetCRC(char *label)
{
	#undef FUNC
	#define FUNC "GetCRC"
	int crc=0x12345678;
	int i=0;

	while (label[i]!=0) {
		crc=(crc<<9)^(crc+label[i++]);
	}
	return crc;
}

int IsDirective(char *expr);

int IsRegister(char *zeexpression)
{
	#undef FUNC
	#define FUNC "IsRegister"

	switch (GetCRC(zeexpression)) {
		case CRC_F:if (strcmp(zeexpression,"F")==0) return 1; else return 0;
		case CRC_I:if (strcmp(zeexpression,"I")==0) return 1; else return 0;
		case CRC_R:if (strcmp(zeexpression,"R")==0) return 1; else return 0;
		case CRC_A:if (strcmp(zeexpression,"A")==0) return 1; else return 0;
		case CRC_B:if (strcmp(zeexpression,"B")==0) return 1; else return 0;
		case CRC_C:if (strcmp(zeexpression,"C")==0) return 1; else return 0;
		case CRC_D:if (strcmp(zeexpression,"D")==0) return 1; else return 0;
		case CRC_E:if (strcmp(zeexpression,"E")==0) return 1; else return 0;
		case CRC_H:if (strcmp(zeexpression,"H")==0) return 1; else return 0;
		case CRC_L:if (strcmp(zeexpression,"L")==0) return 1; else return 0;
		case CRC_BC:if (strcmp(zeexpression,"BC")==0) return 1; else return 0;
		case CRC_DE:if (strcmp(zeexpression,"DE")==0) return 1; else return 0;
		case CRC_HL:if (strcmp(zeexpression,"HL")==0) return 1; else return 0;
		case CRC_IX:if (strcmp(zeexpression,"IX")==0) return 1; else return 0;
		case CRC_IY:if (strcmp(zeexpression,"IY")==0) return 1; else return 0;
		case CRC_SP:if (strcmp(zeexpression,"SP")==0) return 1; else return 0;
		case CRC_AF:if (strcmp(zeexpression,"AF")==0) return 1; else return 0;
		case CRC_XH:if (strcmp(zeexpression,"XH")==0) return 1; else return 0;
		case CRC_XL:if (strcmp(zeexpression,"XL")==0) return 1; else return 0;
		case CRC_YH:if (strcmp(zeexpression,"YH")==0) return 1; else return 0;
		case CRC_YL:if (strcmp(zeexpression,"YL")==0) return 1; else return 0;
		case CRC_HX:if (strcmp(zeexpression,"HX")==0) return 1; else return 0;
		case CRC_LX:if (strcmp(zeexpression,"LX")==0) return 1; else return 0;
		case CRC_HY:if (strcmp(zeexpression,"HY")==0) return 1; else return 0;
		case CRC_LY:if (strcmp(zeexpression,"LY")==0) return 1; else return 0;
		case CRC_IXL:if (strcmp(zeexpression,"IXL")==0) return 1; else return 0;
		case CRC_IXH:if (strcmp(zeexpression,"IXH")==0) return 1; else return 0;
		case CRC_IYL:if (strcmp(zeexpression,"IYL")==0) return 1; else return 0;
		case CRC_IYH:if (strcmp(zeexpression,"IYH")==0) return 1; else return 0;
		default:break;
	}
	return 0;
}

int StringIsMem(char *w)
{
	#undef FUNC
	#define FUNC "StringIsMem"

	int p=1,idx=1;

	if (w[0]=='(') {
		while (w[idx]) {
			switch (w[idx]) {
				case '\\':if (w[idx+1]) idx++;
					break;
				case '\'':if (w[idx+1] && w[idx+1]!='\\') idx++;
					break;
				case '(':p++;break;
				case ')':p--;
					/* si on sort de la première parenthèse */
					if (!p && w[idx+1]) return 0;
					break;
				default:break;
			}
			idx++;
		}
		/* si on ne termine pas par une parenthèse */
		if (w[idx-1]!=')') return 0;
	} else {
		return 0;
	}
	return 1;

}


int StringIsQuote(char *w)
{
	#undef FUNC
	#define FUNC "StringIsQuote"

	int i,tquote,lens;

	if (w[0]=='\'' || w[0]=='"') {
		tquote=w[0];
		lens=strlen(w);
		
		/* est-ce bien une chaine et uniquement une chaine? */
		i=1;
		while (w[i] && w[i]!=tquote) {
			if (w[i]=='\\') i++;
			i++;
		}
		if (i==lens-1) {
			return tquote;
		}
	}
	return 0;
}
char *StringLooksLikeDicoRecurse(struct s_crcdico_tree *lt, int *score, char *str)
{
	#undef FUNC
	#define FUNC "StringLooksLikeDicoRecurse"

	char *retstr=NULL,*tmpstr;
	int i,curs;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			tmpstr=StringLooksLikeDicoRecurse(lt->radix[i],score,str);
			if (tmpstr!=NULL) retstr=tmpstr;
		}
	}
	if (lt->mdico) {
		for (i=0;i<lt->ndico;i++) {
			if (strlen(lt->dico[i].name)>4) {
				curs=_internal_LevenshteinDistance(str,lt->dico[i].name);
				if (curs<*score) {
					*score=curs;
					retstr=lt->dico[i].name;
				}
			}
		}
	}
	return retstr;
}
char *StringLooksLikeDico(struct s_assenv *ae, int *score, char *str)
{
	#undef FUNC
	#define FUNC "StringLooksLikeDico"

	char *retstr=NULL,*tmpstr;
	int i;

	for (i=0;i<256;i++) {
		if (ae->dicotree.radix[i]) {
			tmpstr=StringLooksLikeDicoRecurse(ae->dicotree.radix[i],score,str);
			if (tmpstr!=NULL) retstr=tmpstr;
		}
	}
	return retstr;
}
char *StringLooksLikeMacro(struct s_assenv *ae, char *str, int *retscore)
{
	#undef FUNC
	#define FUNC "StringLooksLikeMacro"
	
	char *ret=NULL;
	int i,curs,score=3;
	/* search in macros */
	for (i=0;i<ae->imacro;i++) {
		curs=_internal_LevenshteinDistance(ae->macro[i].mnemo,str);
		if (curs<score) {
			score=curs;
			ret=ae->macro[i].mnemo;
		}
	}
	if (retscore) *retscore=score;
	return ret;
}	

char *StringLooksLike(struct s_assenv *ae, char *str)
{
	#undef FUNC
	#define FUNC "StringLooksLike"

	char *ret=NULL,*tmpret;
	int i,curs,score=4;

	/* search in variables */
	ret=StringLooksLikeDico(ae,&score,str);

	/* search in labels */
	for (i=0;i<ae->il;i++) {
		if (!ae->label[i].name && strlen(ae->wl[ae->label[i].iw].w)>4) {
			curs=_internal_LevenshteinDistance(ae->wl[ae->label[i].iw].w,str);
			if (curs<score) {
				score=curs;
				ret=ae->wl[ae->label[i].iw].w;
			}
		}
	}
	
	/* search in alias */
	for (i=0;i<ae->ialias;i++) {
		if (strlen(ae->alias[i].alias)>4) {
			curs=_internal_LevenshteinDistance(ae->alias[i].alias,str);
			if (curs<score) {
				score=curs;
				ret=ae->alias[i].alias;
			}
		}
	}
	
	tmpret=StringLooksLikeMacro(ae,str,&curs);
	if (curs<score) {
		score=curs;
		ret=tmpret;
	}
	return ret;
}

int RoundComputeExpression(struct s_assenv *ae,char *expr, int ptr, int didx, int expression_expected);
int RoundComputeExpressionCore(struct s_assenv *ae,char *zeexpression,int ptr,int didx);
double ComputeExpressionCore(struct s_assenv *ae,char *original_zeexpression,int ptr, int didx);
char *GetExpFile(struct s_assenv *ae,int didx);
void __STOP(struct s_assenv *ae);


void MakeError(struct s_assenv *ae, char *filename, int line, char *format, ...)
{
	#undef FUNC
	#define FUNC "MakeError"

	va_list argptr;

	MaxError(ae);
	if (ae->flux) {
		/* in embedded Rasm all errors are stored in a debug struct */
		struct s_debug_error curerror;
		char toosmalltotakeitall[2]={0};
		int myalloc;
		char *errstr;
		
		va_start(argptr,format);
		myalloc=vsnprintf(toosmalltotakeitall,1,format,argptr);
		va_end(argptr);

		#if defined(_MSC_VER) && _MSC_VER < 1900
		/* visual studio before 2015 does not fully support C99 */
		if (myalloc<1 && strlen(format)) {
			va_start(argptr,format);
			myalloc=_vscprintf(format,argptr);
			va_end(argptr);
		}
		#endif
		if (myalloc<1) {
			/* does not crash */
			return;
		}

		va_start(argptr,format);
		errstr=MemMalloc(myalloc+1);
		vsnprintf(errstr,myalloc,format,argptr);
		curerror.msg=errstr;
		curerror.lenmsg=myalloc;
		curerror.line=line;
		if (filename) curerror.filename=TxtStrDupLen(filename,&curerror.lenfilename); else curerror.filename=TxtStrDupLen("<internal>",&curerror.lenfilename);
		ObjectArrayAddDynamicValueConcat((void **)&ae->debug.error,&ae->debug.nberror,&ae->debug.maxerror,&curerror,sizeof(struct s_debug_error));
		va_end(argptr);
	} else {
		fprintf(stdout,KERROR);
		if (filename && line) {
			printf("[%s:%d] ",filename,line);
		} else if (filename) {
			printf("[%s] ",filename);
		}
		va_start(argptr,format);
		vfprintf(stdout,format,argptr);	
		va_end(argptr);
		fprintf(stdout,KNORMAL);
	}
}

/* convert v double value to Microsoft REAL 
 *
 * https://en.wikipedia.org/wiki/Microsoft_Binary_Format
 *
 * exponent:8
 * sign:1
 * mantiss:23
 *
 * */
unsigned char *__internal_MakeRosoftREAL(struct s_assenv *ae, double v, int iexpression)
{
	#undef FUNC
	#define FUNC "__internal_MakeRosoftREAL"
	
	static unsigned char orc[5]={0};
	unsigned char rc[5]={0};
	
	int j,ib,ibb,exp=0;
	unsigned int deci;
	int fracmax=0;
	double frac;
	int mesbits[32];
	int ibit=0;
	unsigned int mask;

	memset(rc,0,sizeof(rc));

	deci=fabs(floor(v));
	frac=fabs(v)-deci;

	if (deci) {
		mask=0x80000000;
		while (!(deci & mask)) mask=mask>>1;
		while (mask) {
			mesbits[ibit]=!!(deci & mask);
#if TRACE_MAKEAMSDOSREAL
printf("%d",mesbits[ibit]);
#endif
			ibit++;
			mask=mask/2;
		}
#if TRACE_MAKEAMSDOSREAL
printf("\nexposant positif: %d\n",ibit);
#endif
		exp=ibit;
#if TRACE_MAKEAMSDOSREAL
printf(".");
#endif
		while (ibit<32 && frac!=0) {
			frac=frac*2.0;
			if (frac>=1.0) {
				mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
				frac-=1.0;
			} else {
				mesbits[ibit++]=0;
#if TRACE_MAKEAMSDOSREAL
printf("0");
#endif
			}
			fracmax++;
		}
	} else {
#if TRACE_MAKEAMSDOSREAL
printf("\nexposant negatif a definir:\n");
printf("x.");
#endif
		
		/* handling zero */
		if (frac==0.0) {
#if TRACE_MAKEAMSDOSREAL
printf("\ncas special ZERO:\n");
#endif
			exp=0;
			ibit=0;
		} else {
			/* looking for first significant bit */
			while (1) {
				frac=frac*2.0;
				if (frac>=1.0) {
					mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
					frac-=1.0;
					break; /* first significant bit found, now looking for limit */
				} else {
#if TRACE_MAKEAMSDOSREAL
printf("o");
#endif
				}
				fracmax++;
				exp--;
			}
			while (ibit<32 && frac!=0) {
				frac=frac*2.0;
				if (frac>=1.0) {
					mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
					frac-=1.0;
				} else {
					mesbits[ibit++]=0;
#if TRACE_MAKEAMSDOSREAL
printf("0");
#endif
				}
				fracmax++;
			}
		}
	}

#if TRACE_MAKEAMSDOSREAL
printf("\n%d bits utilises en mantisse\n",ibit);
#endif
	/* pack bits */
	ib=3;ibb=0x80;
	for (j=0;j<ibit;j++) {
		if (mesbits[j])	rc[ib]|=ibb;
		ibb>>=1;
		if (ibb==0) {
			ibb=0x80;
			ib--;
		}
	}
	/* exponent */
	if (exp==0 && ibit==0) {
		/* special zero */
	} else {
		exp+=128;
		if (exp<0 || exp>255) {
			if (iexpression) MakeError(ae,GetExpFile(ae,iexpression),ae->wl[ae->expression[iexpression].iw].l,"Exponent overflow\n");
			else MakeError(ae,GetExpFile(ae,0),ae->wl[ae->idx].l,"Exponent overflow\n");
			exp=128;
		}
	}
	rc[4]=exp;

	/* Microsoft REAL sign */
	if (v>=0) {
		rc[3]&=0x7F;
	} else {
		rc[3]|=0x80;
	}

#if TRACE_MAKEAMSDOSREAL
	for (j=0;j<5;j++) printf("%02X ",rc[j]);
	printf("\n");
#endif

	/* switch byte order */
	orc[0]=rc[4];
	orc[1]=rc[3];
	orc[2]=rc[2];
	orc[3]=rc[1];
	orc[4]=rc[0];

	return orc;
}


/* convert v double value to Amstrad REAL 
 *
 * http://www.cpcwiki.eu/index.php?title=Technical_information_about_Locomotive_BASIC&mobileaction=toggle_view_desktop#Floating_Point_data_definition
 *
 * exponent:8
 * sign:1
 * mantiss:23
 *
 * */
unsigned char *__internal_MakeAmsdosREAL(struct s_assenv *ae, double v, int iexpression)
{
	#undef FUNC
	#define FUNC "__internal_MakeAmsdosREAL"
	
	static unsigned char rc[5];

	
	int j,ib,ibb,exp=0;
	unsigned int deci;
	int fracmax=0;
	double frac;
	int mesbits[32];
	int ibit=0;
	unsigned int mask;

	memset(rc,0,sizeof(rc));

	deci=fabs(floor(v));
	frac=fabs(v)-deci;

	if (deci) {
		mask=0x80000000;
		while (!(deci & mask)) mask=mask/2;
		while (mask) {
			mesbits[ibit]=!!(deci & mask);
#if TRACE_MAKEAMSDOSREAL
printf("%d",mesbits[ibit]);
#endif
			ibit++;
			mask=mask/2;
		}
#if TRACE_MAKEAMSDOSREAL
printf("\nexposant positif: %d\n",ibit);
#endif
		exp=ibit;
#if TRACE_MAKEAMSDOSREAL
printf(".");
#endif
		while (ibit<32 && frac!=0) {
			frac=frac*2;
			if (frac>=1.0) {
				mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
				frac-=1.0;
			} else {
				mesbits[ibit++]=0;
#if TRACE_MAKEAMSDOSREAL
printf("0");
#endif
			}
			fracmax++;
		}
	} else {
#if TRACE_MAKEAMSDOSREAL
printf("\nexposant negatif a definir:\n");
printf("x.");
#endif
		
		/* handling zero */
		if (frac==0.0) {
			exp=0;
			ibit=0;
		} else {
			/* looking for first significant bit */
			while (1) {
				frac=frac*2;
				if (frac>=1.0) {
					mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
					frac-=1.0;
					break; /* first significant bit found, now looking for limit */
				} else {
#if TRACE_MAKEAMSDOSREAL
printf("o");
#endif
				}
				fracmax++;
				exp--;
			}
			while (ibit<32 && frac!=0) {
				frac=frac*2;
				if (frac>=1.0) {
					mesbits[ibit++]=1;
#if TRACE_MAKEAMSDOSREAL
printf("1");
#endif
					frac-=1.0;
				} else {
					mesbits[ibit++]=0;
#if TRACE_MAKEAMSDOSREAL
printf("0");
#endif
				}
				fracmax++;
			}
		}
	}

#if TRACE_MAKEAMSDOSREAL
printf("\n%d bits utilises en mantisse\n",ibit);
#endif
	/* pack bits */
	ib=3;ibb=0x80;
	for (j=0;j<ibit;j++) {
		if (mesbits[j])	rc[ib]|=ibb;
		ibb/=2;
		if (ibb==0) {
			ibb=0x80;
			ib--;
		}
	}
	/* exponent */
	exp+=128;
	if (exp<0 || exp>255) {
		if (iexpression) MakeError(ae,GetExpFile(ae,iexpression),ae->wl[ae->expression[iexpression].iw].l,"Exponent overflow\n");
		else MakeError(ae,GetExpFile(ae,0),ae->wl[ae->idx].l,"Exponent overflow\n");
		exp=128;
	}
	rc[4]=exp;

	/* REAL sign */
	if (v>=0) {
		rc[3]&=0x7F;
	} else {
		rc[3]|=0x80;
	}

#if TRACE_MAKEAMSDOSREAL
	for (j=0;j<5;j++) printf("%02X ",rc[j]);
	printf("\n");
#endif

	return rc;
}




struct s_label *SearchLabel(struct s_assenv *ae, char *label, int crc);
char *GetExpFile(struct s_assenv *ae,int didx){
	#undef FUNC
	#define FUNC "GetExpFile"
	
	if (ae->label_filename) {
		return ae->label_filename;
	}
	if (didx<0) {
		return ae->filename[ae->wl[-didx].ifile];
	} else if (!didx) {
		return ae->filename[ae->wl[ae->idx].ifile];
	} else if (ae->expression && didx<ae->ie) {
			return ae->filename[ae->wl[ae->expression[didx].iw].ifile];
	} else {
		//return ae->filename[ae->wl[ae->idx].ifile];
		return 0;
	}
}

int GetExpLine(struct s_assenv *ae,int didx){
	#undef FUNC
	#define FUNC "GetExpLine"

	if (ae->label_line) return ae->label_line;

	if (didx<0) {
		return ae->wl[-didx].l;
	} else if (!didx) {
		return ae->wl[ae->idx].l;
	} else if (didx<ae->ie) {
		return ae->wl[ae->expression[didx].iw].l;
	} else return 0;
}

char *GetCurrentFile(struct s_assenv *ae)
{
	return GetExpFile(ae,0);
}


/*******************************************************************************************
			    M E M O R Y       C L E A N U P 
*******************************************************************************************/
void FreeLabelTree(struct s_assenv *ae);
void FreeDicoTree(struct s_assenv *ae);
void FreeUsedTree(struct s_assenv *ae);
void ExpressionFastTranslate(struct s_assenv *ae, char **ptr_expr, int fullreplace);
char *TradExpression(char *zexp);


void _internal_RasmFreeInfoStruct(struct s_rasm_info *debug)
{
	#undef FUNC
	#define FUNC "RasmFreeInfoStruct"

	int i;
	if (debug->maxerror) {
		for (i=0;i<debug->nberror;i++) {
			MemFree(debug->error[i].filename);
			MemFree(debug->error[i].msg);
		}
		MemFree(debug->error);
	}
	if (debug->maxsymbol) {
		for (i=0;i<debug->nbsymbol;i++) {
			MemFree(debug->symbol[i].name);
		}
		MemFree(debug->symbol);
	}
}

void RasmFreeInfoStruct(struct s_rasm_info *debug)
{
	_internal_RasmFreeInfoStruct(debug);
	MemFree(debug);
}

void FreeAssenv(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "FreeAssenv"
	int i,j;

#ifndef RDD
	/* let the system free the memory in command line except when debug/dev */
	#ifndef __MORPHOS__
	/* MorphOS does not like when memory is not freed before exit */
	if (!ae->flux) return;
	#endif
#endif
	/*** debug info ***/	
	if (!ae->retdebug) {
		_internal_RasmFreeInfoStruct(&ae->debug);
	} else {
		/* symbols */
		struct s_debug_symbol debug_symbol={0};

		for (i=0;i<ae->il;i++) {
			/* on exporte tout */
			if (!ae->label[i].name) {
				/* les labels entiers */
				debug_symbol.name=TxtStrDup(ae->wl[ae->label[i].iw].w);
				debug_symbol.v=ae->label[i].ptr;
				ObjectArrayAddDynamicValueConcat((void**)&ae->debug.symbol,&ae->debug.nbsymbol,&ae->debug.maxsymbol,&debug_symbol,sizeof(struct s_debug_symbol));
			} else {
				/* les labels locaux et générés */
				debug_symbol.name=TxtStrDup(ae->label[i].name);
				debug_symbol.v=ae->label[i].ptr;
				ObjectArrayAddDynamicValueConcat((void**)&ae->debug.symbol,&ae->debug.nbsymbol,&ae->debug.maxsymbol,&debug_symbol,sizeof(struct s_debug_symbol));
			}
		}
		for (i=0;i<ae->ialias;i++) {
			if (strcmp(ae->alias[i].alias,"IX") && strcmp(ae->alias[i].alias,"IY")) {
				debug_symbol.name=TxtStrDup(ae->alias[i].alias);
				debug_symbol.v=RoundComputeExpression(ae,ae->alias[i].translation,0,0,0);
				ObjectArrayAddDynamicValueConcat((void**)&ae->debug.symbol,&ae->debug.nbsymbol,&ae->debug.maxsymbol,&debug_symbol,sizeof(struct s_debug_symbol));
			}
		}

		/* export struct */
		*ae->retdebug=MemMalloc(sizeof(struct s_rasm_info));
		memcpy(*ae->retdebug,&ae->debug,sizeof(struct s_rasm_info));
	}
	/*** end debug ***/

	for (i=0;i<ae->nbbank;i++) {
		MemFree(ae->mem[i]);
	}
	MemFree(ae->mem);
	
	/* expression core buffer free */
	ComputeExpressionCore(NULL,NULL,0,0);
	ExpressionFastTranslate(NULL,NULL,0);
	/* free labels, expression, orgzone, repeat, ... */
	if (ae->mo) MemFree(ae->orgzone);
	if (ae->me) {
		for (i=0;i<ae->ie;i++) {
			if (ae->expression[i].reference) MemFree(ae->expression[i].reference);
			if (ae->expression[i].module) MemFree(ae->expression[i].module);
		}
		MemFree(ae->expression);
	}
	if (ae->mh) {
		for (i=0;i<ae->ih;i++) {
			//MemFree(ae->hexbin[i].data);
			MemFree(ae->hexbin[i].filename);
		}
		MemFree(ae->hexbin);
	}
	for (i=0;i<ae->il;i++) {
		if (ae->label[i].name && ae->label[i].iw==-1) MemFree(ae->label[i].name);
	}
	/* structures */
	for (i=0;i<ae->irasmstructalias;i++) {
		MemFree(ae->rasmstructalias[i].name);
	}
	if (ae->mrasmstructalias) MemFree(ae->rasmstructalias);
	
	for (i=0;i<ae->irasmstruct;i++) {
		for (j=0;j<ae->rasmstruct[i].irasmstructfield;j++) {
			MemFree(ae->rasmstruct[i].rasmstructfield[j].fullname);
			MemFree(ae->rasmstruct[i].rasmstructfield[j].name);
			if (ae->rasmstruct[i].rasmstructfield[j].mdata) MemFree(ae->rasmstruct[i].rasmstructfield[j].data);
		}
		if (ae->rasmstruct[i].mrasmstructfield) MemFree(ae->rasmstruct[i].rasmstructfield);
		MemFree(ae->rasmstruct[i].name);
	}
	if (ae->mrasmstruct) MemFree(ae->rasmstruct);
	
	/* other */
	if (ae->maxbreakpoint) MemFree(ae->breakpoint);
	if (ae->ml) MemFree(ae->label);
	if (ae->mr) MemFree(ae->repeat);
	if (ae->mi) MemFree(ae->ifthen);
	if (ae->msw) MemFree(ae->switchcase);
	if (ae->mw) MemFree(ae->whilewend);
	if (ae->modulen || ae->module) {
		MemFree(ae->module);
	}
	/* deprecated
	for (i=0;i<ae->idic;i++) {
		MemFree(ae->dico[i].name);
	}
	if (ae->mdic) MemFree(ae->dico);
	*/
	if (ae->mlz) MemFree(ae->lzsection);

	for (i=0;i<ae->ifile;i++) {
		MemFree(ae->filename[i]);
	}
	MemFree(ae->filename);

	for (i=0;i<ae->imacro;i++) {
		if (ae->macro[i].maxword) MemFree(ae->macro[i].wc);
		for (j=0;j<ae->macro[i].nbparam;j++) MemFree(ae->macro[i].param[j]);
		if (ae->macro[i].nbparam) MemFree(ae->macro[i].param);
	}

	
	if (ae->mmacro) MemFree(ae->macro);

	for (i=0;i<ae->igs;i++) {
		if (ae->globalstack[i]) MemFree(ae->globalstack[i]);
	}
	if (ae->mgs) MemFree(ae->globalstack);
	if (ae->lastglobalalloc) {
		MemFree(ae->lastgloballabel);
		ae->lastglobalalloc=0;
		ae->lastgloballabel=NULL;
	}

	for (i=0;i<ae->ialias;i++) {
		MemFree(ae->alias[i].alias);
		MemFree(ae->alias[i].translation);
	}
	if (ae->malias) MemFree(ae->alias);

	for (i=0;ae->wl[i].t!=2;i++) {
		MemFree(ae->wl[i].w);
	}
	MemFree(ae->wl);

	if (ae->ctx1.varbuffer) {
		MemFree(ae->ctx1.varbuffer);
	}
	if (ae->ctx1.maxtokenstack) {
		MemFree(ae->ctx1.tokenstack);
	}
	if (ae->ctx1.maxoperatorstack) {
		MemFree(ae->ctx1.operatorstack);
	}
	if (ae->ctx2.varbuffer) {
		MemFree(ae->ctx2.varbuffer);
	}
	if (ae->ctx2.maxtokenstack) {
		MemFree(ae->ctx2.tokenstack);
	}
	if (ae->ctx2.maxoperatorstack) {
		MemFree(ae->ctx2.operatorstack);
	}

	for (i=0;i<ae->iticker;i++) {
		MemFree(ae->ticker[i].varname);
	}
	if (ae->mticker) MemFree(ae->ticker);

	MemFree(ae->outputfilename);
	FreeLabelTree(ae);
	FreeDicoTree(ae);
	FreeUsedTree(ae);
	if (ae->mmacropos) MemFree(ae->macropos);
	TradExpression(NULL);
	MemFree(ae);
}



void MaxError(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "MaxError"

	char **source_lines=NULL;
	int zeline;


	/* extended error is useful with generated code we do not want to edit */
	if (ae->extended_error && ae->wl) {
		/* super dupper slow but anyway, there is an error... */
		if (ae->wl[ae->idx].l) {
			source_lines=FileReadLinesRAW(GetCurrentFile(ae));
			zeline=0;
			while (zeline<ae->wl[ae->idx].l-1 && source_lines[zeline]) zeline++;
			if (zeline==ae->wl[ae->idx].l-1 && source_lines[zeline]) {
				rasm_printf(ae,KAYGREEN"-> %s",source_lines[zeline]);
			} else {
				rasm_printf(ae,KERROR"cannot read line %d of file [%s]\n",ae->wl[ae->idx].l,GetCurrentFile(ae));
			}
			FreeArrayDynamicValue(&source_lines);
		}
	}

	ae->nberr++;
	if (ae->nberr==ae->maxerr) {
		rasm_printf(ae,KERROR"Too many errors!\n");
		FreeAssenv(ae);
		exit(ae->nberr);
	}
}

void (*___output)(struct s_assenv *ae, unsigned char v);

void ___internal_output_disabled(struct s_assenv *ae,unsigned char v)
{
	#undef FUNC
	#define FUNC "fake ___output"
}
void ___internal_output(struct s_assenv *ae,unsigned char v)
{
	#undef FUNC
	#define FUNC "___output"
	
	if (ae->outputadr<ae->maxptr) {
		ae->mem[ae->activebank][ae->outputadr++]=v;
		ae->codeadr++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"output exceed limit %d\n",ae->maxptr);
		ae->stop=1;
		___output=___internal_output_disabled;
	}
}
void ___internal_output_nocode(struct s_assenv *ae,unsigned char v)
{
	#undef FUNC
	#define FUNC "___output (nocode)"
	
	if (ae->outputadr<ae->maxptr) {
		/* struct definition always in NOCODE */
		if (ae->getstruct) {
			int irs,irsf;
			irs=ae->irasmstruct-1;
			irsf=ae->rasmstruct[irs].irasmstructfield-1;
			
			/* ajouter les data du flux au champ de la structure */			
			ObjectArrayAddDynamicValueConcat((void**)&ae->rasmstruct[irs].rasmstructfield[irsf].data,
				&ae->rasmstruct[irs].rasmstructfield[irsf].idata,
				&ae->rasmstruct[irs].rasmstructfield[irsf].mdata,
				&v,sizeof(unsigned char));
		}
		
		ae->outputadr++;
		ae->codeadr++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"output exceed limit %d\n",ae->maxptr);
		ae->stop=1;
		___output=___internal_output_disabled;
	}
}


void ___output_set_limit(struct s_assenv *ae,int zelimit)
{
	#undef FUNC
	#define FUNC "___output_set_limit"

	int limit=65536;
	
	if (zelimit<=limit) {
		/* apply limit */
		limit=zelimit;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"limit exceed hardware limitation!");
		ae->stop=1;
	}
	if (ae->outputadr>=0 && ae->outputadr>=limit) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"limit too high for current output!");
		ae->stop=1;
	}
	ae->maxptr=limit;
}

unsigned char *MakeAMSDOSHeader(int run, int minmem, int maxmem, char *amsdos_name) {
	#undef FUNC
	#define FUNC "MakeAMSDOSHeader"
	
	static unsigned char AmsdosHeader[128];
	int checksum,i=0;
	/***  cpcwiki			
	Byte 00: User number
	Byte 01 to 08: filename
	Byte 09 bis 11: Extension
	Byte 18: type-byte
	Byte 21 and 22: loading address
	Byte 24 and 25: file length
	Byte 26 and 27: execution address for machine code programs
	Byte 64 and 65: (file length)
	Byte 67 and 68: checksum for byte 00 to byte 66
	To calculate the checksum, just add byte 00 to byte 66 to each other.
	*/
	memset(AmsdosHeader,0,sizeof(AmsdosHeader));
	AmsdosHeader[0]=0;
	memcpy(AmsdosHeader+1,amsdos_name,11);

	AmsdosHeader[18]=2; /* 0 basic 1 basic protege 2 binaire */
	AmsdosHeader[19]=(maxmem-minmem)&0xFF;
	AmsdosHeader[20]=(maxmem-minmem)>>8;
	AmsdosHeader[21]=minmem&0xFF;
	AmsdosHeader[22]=minmem>>8;
	AmsdosHeader[24]=AmsdosHeader[19];
	AmsdosHeader[25]=AmsdosHeader[20];
	AmsdosHeader[26]=run&0xFF;
	AmsdosHeader[27]=run>>8;
	AmsdosHeader[64]=AmsdosHeader[19];
	AmsdosHeader[65]=AmsdosHeader[20];
	AmsdosHeader[66]=0;
	
	for (i=checksum=0;i<=66;i++) {
		checksum+=AmsdosHeader[i];
	}
	AmsdosHeader[67]=checksum&0xFF;
	AmsdosHeader[68]=checksum>>8;

	/* garbage / shadow values from sector buffer? */
	memcpy(AmsdosHeader+0x47,amsdos_name,8);
	AmsdosHeader[0x4F]=0x24;
	AmsdosHeader[0x50]=0x24;
	AmsdosHeader[0x51]=0x24;
	AmsdosHeader[0x52]=0xFF;
	AmsdosHeader[0x54]=0xFF;
	AmsdosHeader[0x57]=0x02;
	AmsdosHeader[0x5A]=AmsdosHeader[21];
	AmsdosHeader[0x5B]=AmsdosHeader[22];
	AmsdosHeader[0x5D]=AmsdosHeader[24];
	AmsdosHeader[0x5E]=AmsdosHeader[25];

	sprintf((char *)AmsdosHeader+0x47+17," created by %-9.9s ",RASM_SNAP_VERSION);

	return AmsdosHeader;
}

unsigned char *MakeHobetaHeader(int minmem, int maxmem, char *trdos_name) {
	#undef FUNC
	#define FUNC "MakeHobetaHeader"
	
	static unsigned char HobetaHeader[17];
	int i,checksum=0;
	/***  http://rk.nvg.ntnu.no/sinclair/faq/fileform.html#HOBETA			
   0x00     FileName     0x08      TR-DOS file name
   0x08     FileType     0x01      TR-DOS file type
   0x09     StartAdr     0x02      start address of file
   0x0A     FlLength     0x02      length of file (in bytes)  -> /!\ wrong offset!!!
   0x0C     FileSize     0x02      size of file (in sectors) 
   0x0E     HdrCRC16     0x02      Control checksum of the 15 byte
                                   header (not sector data!)
   */
	memset(HobetaHeader,0,sizeof(HobetaHeader));

	strncpy((char*)&HobetaHeader[0],trdos_name,8);
	HobetaHeader[8]='C';
	HobetaHeader[0x9]=(maxmem-minmem)&0xFF;
	HobetaHeader[0xA]=(maxmem-minmem)>>8;
	
	HobetaHeader[0xB]=(maxmem-minmem)&0xFF;
	HobetaHeader[0xC]=(maxmem-minmem)>>8;
	
	HobetaHeader[0xD]=((maxmem-minmem)+255)>>8;
	HobetaHeader[0xE]=0;
	
	for (i=0;i<0xF;i++) checksum+=HobetaHeader[i]*257+i;
	
	HobetaHeader[0xF]=checksum&0xFF;
	HobetaHeader[0x10]=(checksum>>8)&0xFF;

	return HobetaHeader;
}


int cmpAmsdosentry(const void * a, const void * b)
{
	return memcmp(a,b,32);
}

int cmpmacros(const void * a, const void * b)
{
	struct s_macro *sa,*sb;
	sa=(struct s_macro *)a;
	sb=(struct s_macro *)b;
	if (sa->crc<sb->crc) return -1; else return 1;
}
int SearchAlias(struct s_assenv *ae, int crc, char *zemot)
{
    int dw,dm,du,i;
//printf("SearchAlias [%s] ",zemot);
	/* inutile de tourner autour du pot pour un si petit nombre */
	if (ae->ialias<5) {
		for (i=0;i<ae->ialias;i++) {
			if (ae->alias[i].crc==crc && strcmp(ae->alias[i].alias,zemot)==0) {
				ae->alias[i].used=1;
//printf("found\n");
				return i;
			}
		}
//printf("not found\n");
		return -1;
	}
	
	dw=0;
	du=ae->ialias-1;
	while (dw<=du) {
		dm=(dw+du)/2;
		if (ae->alias[dm].crc==crc) {
			/* chercher le premier de la liste */
			while (dm>0 && ae->alias[dm-1].crc==crc) dm--;
			/* controle sur le texte entier */
			while (ae->alias[dm].crc==crc && strcmp(ae->alias[dm].alias,zemot)) dm++;
			if (ae->alias[dm].crc==crc && strcmp(ae->alias[dm].alias,zemot)==0) {
				ae->alias[dm].used=1;
//printf("[%s] found => [%s]\n",zemot,ae->alias[dm].translation);
				return dm;
			} else return -1;
		} else if (ae->alias[dm].crc>crc) {
			du=dm-1;
		} else if (ae->alias[dm].crc<crc) {
			dw=dm+1;
		}
	}
//printf("not found\n");
	return -1;
}
int SearchMacro(struct s_assenv *ae, int crc, char *zemot)
{
	int dw,dm,du,i;

	/* inutile de tourner autour du pot pour un si petit nombre */
	if (ae->imacro<5) {
			for (i=0;i<ae->imacro;i++) {
					if (ae->macro[i].crc==crc && strcmp(ae->macro[i].mnemo,zemot)==0) {
							return i;
					}
			}
			return -1;
	}
	
	dw=0;
	du=ae->imacro-1;
	while (dw<=du) {
		dm=(dw+du)/2;
		if (ae->macro[dm].crc==crc) {
			/* chercher le premier de la liste */
			while (dm>0 && ae->macro[dm-1].crc==crc) dm--;
			/* controle sur le texte entier */
			while (ae->macro[dm].crc==crc && strcmp(ae->macro[dm].mnemo,zemot)) dm++;
			if (ae->macro[dm].crc==crc && strcmp(ae->macro[dm].mnemo,zemot)==0) return dm; else return -1;
		} else if (ae->macro[dm].crc>crc) {
			du=dm-1;
		} else if (ae->macro[dm].crc<crc) {
			dw=dm+1;
		}
	}
	return -1;
}

void CheckAndSortAliases(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "CheckAndSortAliases"

	struct s_alias tmpalias;
	int i,dw,dm=0,du,crc;
	for (i=0;i<ae->ialias-1;i++) {
		/* is there previous aliases in the new alias? */
		if (strstr(ae->alias[ae->ialias-1].translation,ae->alias[i].alias)) {
			/* there is a match, apply alias translation */
			ExpressionFastTranslate(ae,&ae->alias[ae->ialias-1].translation,2);
			/* need to compute again len */
			ae->alias[ae->ialias-1].len=strlen(ae->alias[ae->ialias-1].translation);
			break;
		}
	}
	
	/* cas particuliers pour insertion en début ou fin de liste */
	if (ae->ialias-1) {
		if (ae->alias[ae->ialias-1].crc>ae->alias[ae->ialias-2].crc) {
			/* pas de tri il est déjà au bon endroit */
		} else if (ae->alias[ae->ialias-1].crc<ae->alias[0].crc) {
			/* insertion tout en bas de liste */
			tmpalias=ae->alias[ae->ialias-1];
			MemMove(&ae->alias[1],&ae->alias[0],sizeof(struct s_alias)*(ae->ialias-1));
			ae->alias[0]=tmpalias;
		} else {
			/* on cherche ou inserer */
			crc=ae->alias[ae->ialias-1].crc;
			dw=0;
			du=ae->ialias-1;
			while (dw<=du) {
				dm=(dw+du)/2;
				if (ae->alias[dm].crc==crc) {
					break;
				} else if (ae->alias[dm].crc>crc) {
					du=dm-1;
				} else if (ae->alias[dm].crc<crc) {
					dw=dm+1;
				}
			}
			/* ajustement */
			if (ae->alias[dm].crc<crc) dm++;
			/* insertion */
			tmpalias=ae->alias[ae->ialias-1];
			MemMove(&ae->alias[dm+1],&ae->alias[dm],sizeof(struct s_alias)*(ae->ialias-1-dm));
			ae->alias[dm]=tmpalias;
		}
	} else {
		/* one alias need no sort */
	}
}

void InsertDicoToTree(struct s_assenv *ae, struct s_expr_dico *dico)
{
	#undef FUNC
	#define FUNC "InsertDicoToTree"

	struct s_crcdico_tree *curdicotree;
	int radix,dek=32;

	curdicotree=&ae->dicotree;
	while (dek) {
		dek=dek-8;
		radix=(dico->crc>>dek)&0xFF;
		if (curdicotree->radix[radix]) {
			curdicotree=curdicotree->radix[radix];
		} else {
			curdicotree->radix[radix]=MemMalloc(sizeof(struct s_crcdico_tree));
			curdicotree=curdicotree->radix[radix];
			memset(curdicotree,0,sizeof(struct s_crcdico_tree));
		}
	}
	ObjectArrayAddDynamicValueConcat((void**)&curdicotree->dico,&curdicotree->ndico,&curdicotree->mdico,dico,sizeof(struct s_expr_dico));
}

unsigned char *SnapshotDicoInsert(char *symbol_name, int ptr, int *retidx)
{
	static unsigned char *subchunk=NULL;
	static int subchunksize=0;
	static int idx=0;
	int symbol_len;
	
	if (retidx) {
		if (symbol_name && strcmp(symbol_name,"FREE")==0) {
			subchunksize=0;
			idx=0;
			MemFree(subchunk);
			subchunk=NULL;
		}
		*retidx=idx;
		return subchunk;
	}
	
	if (idx+65536>subchunksize) {
		subchunksize=subchunksize+65536;
		subchunk=MemRealloc(subchunk,subchunksize);
	}
	
	symbol_len=strlen(symbol_name);
	if (symbol_len>255) symbol_len=255;
	subchunk[idx++]=symbol_len;
	memcpy(subchunk+idx,symbol_name,symbol_len);
	idx+=symbol_len;
	memset(subchunk+idx,0,6);
	idx+=6;
	subchunk[idx++]=(ptr&0xFF00)/256;
	subchunk[idx++]=ptr&0xFF;
	return NULL;
}

void SnapshotDicoTreeRecurse(struct s_crcdico_tree *lt)
{
	#undef FUNC
	#define FUNC "SnapshottDicoTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			SnapshotDicoTreeRecurse(lt->radix[i]);
		}
	}
	if (lt->mdico) {
		for (i=0;i<lt->ndico;i++) {
			if (strcmp(lt->dico[i].name,"IX") && strcmp(lt->dico[i].name,"IY") && strcmp(lt->dico[i].name,"PI") && strcmp(lt->dico[i].name,"ASSEMBLER_RASM")) {
				SnapshotDicoInsert(lt->dico[i].name,(int)floor(lt->dico[i].v+0.5),NULL);
			}
		}
	}
}
unsigned char *SnapshotDicoTree(struct s_assenv *ae, int *retidx)
{
	#undef FUNC
	#define FUNC "SnapshotDicoTree"

	unsigned char *sc;
	int idx;
	int i;

	for (i=0;i<256;i++) {
		if (ae->dicotree.radix[i]) {
			SnapshotDicoTreeRecurse(ae->dicotree.radix[i]);
		}
	}
	
	sc=SnapshotDicoInsert(NULL,0,&idx);
	*retidx=idx;
	return sc;
}

void WarnLabelTreeRecurse(struct s_assenv *ae, struct s_crclabel_tree *lt)
{
	#undef FUNC
	#define FUNC "WarnLabelTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			WarnLabelTreeRecurse(ae,lt->radix[i]);
		}
	}
	for (i=0;i<lt->nlabel;i++) {
		if (!lt->label[i].used) {
			if (!lt->label[i].name) {
				rasm_printf(ae,KWARNING"[%s:%d] Warning: label %s declared but not used\n",ae->filename[lt->label[i].fileidx],lt->label[i].fileline,ae->wl[lt->label[i].iw].w);
				if (ae->erronwarn) MaxError(ae);
			} else {
				rasm_printf(ae,KWARNING"[%s:%d] Warning: label %s declared but not used\n",ae->filename[lt->label[i].fileidx],lt->label[i].fileline,lt->label[i].name);
				if (ae->erronwarn) MaxError(ae);
			}
		}
	}
}
void WarnLabelTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "WarnLabelTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->labeltree.radix[i]) {
			WarnLabelTreeRecurse(ae,ae->labeltree.radix[i]);
		}
	}
}
void WarnDicoTreeRecurse(struct s_assenv *ae, struct s_crcdico_tree *lt)
{
	#undef FUNC
	#define FUNC "WarnDicoTreeRecurse"

	int i;


	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			WarnDicoTreeRecurse(ae,lt->radix[i]);
		}
	}
	for (i=0;i<lt->ndico;i++) {
		if (strcmp(lt->dico[i].name,"IX") && strcmp(lt->dico[i].name,"IY") && strcmp(lt->dico[i].name,"PI") && strcmp(lt->dico[i].name,"ASSEMBLER_RASM") && lt->dico[i].autorise_export) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: variable %s declared but not used\n",ae->filename[ae->wl[lt->dico[i].iw].ifile],ae->wl[lt->dico[i].iw].l,lt->dico[i].name);
				if (ae->erronwarn) MaxError(ae);
		}
	}
}
void WarnDicoTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "ExportDicoTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->dicotree.radix[i]) {
			WarnDicoTreeRecurse(ae,ae->dicotree.radix[i]);
		}
	}
}
void ExportDicoTreeRecurse(struct s_crcdico_tree *lt, char *zefile, char *zeformat)
{
	#undef FUNC
	#define FUNC "ExportDicoTreeRecurse"

	char symbol_line[1024];
	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			ExportDicoTreeRecurse(lt->radix[i],zefile,zeformat);
		}
	}
	if (lt->mdico) {
		for (i=0;i<lt->ndico;i++) {
			if (strcmp(lt->dico[i].name,"IX") && strcmp(lt->dico[i].name,"IY") && strcmp(lt->dico[i].name,"PI") && strcmp(lt->dico[i].name,"ASSEMBLER_RASM") && lt->dico[i].autorise_export) {
				snprintf(symbol_line,sizeof(symbol_line)-1,zeformat,lt->dico[i].name,(int)floor(lt->dico[i].v+0.5));
				symbol_line[sizeof(symbol_line)-1]=0xD;
				FileWriteLine(zefile,symbol_line);
			}
		}
	}
}
void ExportDicoTree(struct s_assenv *ae, char *zefile, char *zeformat)
{
	#undef FUNC
	#define FUNC "ExportDicoTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->dicotree.radix[i]) {
			ExportDicoTreeRecurse(ae->dicotree.radix[i],zefile,zeformat);
		}
	}
}
void FreeDicoTreeRecurse(struct s_crcdico_tree *lt)
{
	#undef FUNC
	#define FUNC "FreeDicoTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			FreeDicoTreeRecurse(lt->radix[i]);
		}
	}
	if (lt->mdico) {
		for (i=0;i<lt->ndico;i++) {
			MemFree(lt->dico[i].name);
		}
		MemFree(lt->dico);
	}
	MemFree(lt);
}
void FreeDicoTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "FreeDicoTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->dicotree.radix[i]) {
			FreeDicoTreeRecurse(ae->dicotree.radix[i]);
		}
	}
	if (ae->dicotree.mdico) {
		for (i=0;i<ae->dicotree.ndico;i++) MemFree(ae->dicotree.dico[i].name);
		MemFree(ae->dicotree.dico);
	}
}
struct s_expr_dico *SearchDico(struct s_assenv *ae, char *dico, int crc)
{
	#undef FUNC
	#define FUNC "SearchDico"

	struct s_crcdico_tree *curdicotree;
	int i,radix,dek=32;


	curdicotree=&ae->dicotree;

	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curdicotree->radix[radix]) {
			curdicotree=curdicotree->radix[radix];
		} else {
			/* radix not found, dico is not in index */
			return NULL;
		}
	}
	for (i=0;i<curdicotree->ndico;i++) {
		if (strcmp(curdicotree->dico[i].name,dico)==0) {
			curdicotree->dico[i].used=1;
			return &curdicotree->dico[i];
		}
	}
	return NULL;
}
int DelDico(struct s_assenv *ae, char *dico, int crc)
{
	#undef FUNC
	#define FUNC "DelDico"

	struct s_crcdico_tree *curdicotree;
	int i,radix,dek=32;

	curdicotree=&ae->dicotree;

	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curdicotree->radix[radix]) {
			curdicotree=curdicotree->radix[radix];
		} else {
			/* radix not found, dico is not in index */
			return 0;
		}
	}
	for (i=0;i<curdicotree->ndico;i++) {
		if (strcmp(curdicotree->dico[i].name,dico)==0) {
			/* must free memory */
			MemFree(curdicotree->dico[i].name);
			if (i<curdicotree->ndico-1) {
				MemMove(&curdicotree->dico[i],&curdicotree->dico[i+1],(curdicotree->ndico-i-1)*sizeof(struct s_expr_dico));
			}
			curdicotree->ndico--;
			return 1;
		}
	}
	return 0;
}


void InsertUsedToTree(struct s_assenv *ae, char *used, int crc)
{
	#undef FUNC
	#define FUNC "InsertUsedToTree"

	struct s_crcused_tree *curusedtree;
	int radix,dek=32,i;
	
	curusedtree=&ae->usedtree;
	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curusedtree->radix[radix]) {
			curusedtree=curusedtree->radix[radix];
		} else {
			curusedtree->radix[radix]=MemMalloc(sizeof(struct s_crcused_tree));
			curusedtree=curusedtree->radix[radix];
			memset(curusedtree,0,sizeof(struct s_crcused_tree));
		}
	}
	for (i=0;i<curusedtree->nused;i++) if (strcmp(used,curusedtree->used[i])==0) break;
	/* no double */
	if (i==curusedtree->nused) {
		FieldArrayAddDynamicValueConcat(&curusedtree->used,&curusedtree->nused,&curusedtree->mused,used);
	}
}

void FreeUsedTreeRecurse(struct s_crcused_tree *lt)
{
	#undef FUNC
	#define FUNC "FreeUsedTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			FreeUsedTreeRecurse(lt->radix[i]);
		}
	}
	if (lt->mused) {
		for (i=0;i<lt->nused;i++) MemFree(lt->used[i]);
		MemFree(lt->used);
	}
	MemFree(lt);
}
void FreeUsedTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "FreeUsedTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->usedtree.radix[i]) {
			FreeUsedTreeRecurse(ae->usedtree.radix[i]);
		}
	}
}
int SearchUsed(struct s_assenv *ae, char *used, int crc)
{
	#undef FUNC
	#define FUNC "SearchUsed"

	struct s_crcused_tree *curusedtree;
	int i,radix,dek=32;

	curusedtree=&ae->usedtree;
	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curusedtree->radix[radix]) {
			curusedtree=curusedtree->radix[radix];
		} else {
			/* radix not found, used is not in index */
			return 0;
		}
	}
	for (i=0;i<curusedtree->nused;i++) {
		if (strcmp(curusedtree->used[i],used)==0) {
			return 1;
		}
	}
	return 0;
}



void InsertTextToTree(struct s_assenv *ae, char *text, char *replace, int crc)
{
	#undef FUNC
	#define FUNC "InsertTextToTree"

	struct s_crcstring_tree *curstringtree;
	int radix,dek=32,i;
	
	curstringtree=&ae->stringtree;
	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curstringtree->radix[radix]) {
			curstringtree=curstringtree->radix[radix];
		} else {
			curstringtree->radix[radix]=MemMalloc(sizeof(struct s_crcused_tree));
			curstringtree=curstringtree->radix[radix];
			memset(curstringtree,0,sizeof(struct s_crcused_tree));
		}
	}
	for (i=0;i<curstringtree->ntext;i++) if (strcmp(text,curstringtree->text[i])==0) break;
	/* no double */
	if (i==curstringtree->ntext) {
		text=TxtStrDup(text);
		replace=TxtStrDup(replace);
		FieldArrayAddDynamicValueConcat(&curstringtree->text,&curstringtree->ntext,&curstringtree->mtext,text);
		FieldArrayAddDynamicValueConcat(&curstringtree->replace,&curstringtree->nreplace,&curstringtree->mreplace,replace);
	}
}

void FreeTextTreeRecurse(struct s_crcstring_tree *lt)
{
	#undef FUNC
	#define FUNC "FreeTextTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			FreeTextTreeRecurse(lt->radix[i]);
		}
	}
	if (lt->mtext) {
		for (i=0;i<lt->ntext;i++) MemFree(lt->text[i]);
		MemFree(lt->text);
	}
	MemFree(lt);
}
void FreeTextTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "FreeTextTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->stringtree.radix[i]) {
			FreeTextTreeRecurse(ae->stringtree.radix[i]);
		}
	}
	if (ae->stringtree.mtext) MemFree(ae->stringtree.text);
}
int SearchText(struct s_assenv *ae, char *text, int crc)
{
	#undef FUNC
	#define FUNC "SearchText"

	struct s_crcstring_tree *curstringtree;
	int i,radix,dek=32;

	curstringtree=&ae->stringtree;
	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curstringtree->radix[radix]) {
			curstringtree=curstringtree->radix[radix];
		} else {
			/* radix not found, used is not in index */
			return 0;
		}
	}
	for (i=0;i<curstringtree->ntext;i++) {
		if (strcmp(curstringtree->text[i],text)==0) {
			return 1;
		}
	}
	return 0;
}







/*
struct s_crclabel_tree {





struct s_crclabel_tree {
	struct s_crclabel_tree *radix[256];
	struct s_label *label;
	int nlabel,mlabel;
};
*/
void FreeLabelTreeRecurse(struct s_crclabel_tree *lt)
{
	#undef FUNC
	#define FUNC "FreeLabelTreeRecurse"

	int i;

	for (i=0;i<256;i++) {
		if (lt->radix[i]) {
			FreeLabelTreeRecurse(lt->radix[i]);
		}
	}
	/* label.name already freed elsewhere as this one is a copy */
	if (lt->mlabel) MemFree(lt->label);
	MemFree(lt);
}
void FreeLabelTree(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "FreeLabelTree"

	int i;

	for (i=0;i<256;i++) {
		if (ae->labeltree.radix[i]) {
			FreeLabelTreeRecurse(ae->labeltree.radix[i]);
		}
	}
	if (ae->labeltree.mlabel) MemFree(ae->labeltree.label);
}

struct s_label *SearchLabel(struct s_assenv *ae, char *label, int crc)
{
	#undef FUNC
	#define FUNC "SearchLabel"

	struct s_crclabel_tree *curlabeltree;
	int i,radix,dek=32;

//printf("searchLabel [%s]",label);
	curlabeltree=&ae->labeltree;
	while (dek) {
		dek=dek-8;
		radix=(crc>>dek)&0xFF;
		if (curlabeltree->radix[radix]) {
			curlabeltree=curlabeltree->radix[radix];
		} else {
			/* radix not found, label is not in index */
//printf(" not found\n");
			return NULL;
		}
	}
	for (i=0;i<curlabeltree->nlabel;i++) {
		if (!curlabeltree->label[i].name && strcmp(ae->wl[curlabeltree->label[i].iw].w,label)==0) {
			curlabeltree->label[i].used=1;
//printf(" found (global)\n");
			return &curlabeltree->label[i];
		} else if (curlabeltree->label[i].name && strcmp(curlabeltree->label[i].name,label)==0) {
			curlabeltree->label[i].used=1;
//printf(" found (local or proximity)\n");
			return &curlabeltree->label[i];
		}
	}
	return NULL;
}

char *MakeLocalLabel(struct s_assenv *ae,char *varbuffer, int *retdek)
{
	#undef FUNC
	#define FUNC "MakeLocalLabel"
	
	char *locallabel;
	char hexdigit[32];
	int lenbuf=0,dek,i,im;
	char *zepoint;

	lenbuf=strlen(varbuffer);
	
	/* not so local labels */
	if (varbuffer[0]=='.') {
		/* create reference */
		if (ae->lastgloballabel) {
			locallabel=MemMalloc(strlen(varbuffer)+1+ae->lastgloballabellen);
			sprintf(locallabel,"%s%s",ae->lastgloballabel,varbuffer);
			if (retdek) *retdek=0;
			return locallabel;
		} else {
			if (retdek) *retdek=0;
			return TxtStrDup(varbuffer);
		}
	}

	/***************************************************
	without retdek -> build a local label
	with    retdek -> build the hash string
	***************************************************/	
	if (!retdek) {
		locallabel=MemMalloc(lenbuf+(ae->ir+ae->iw+3)*8+8);
		zepoint=strchr(varbuffer,'.');
		if (zepoint) {
			*zepoint=0;
		}
		strcpy(locallabel,varbuffer);
	} else {
		locallabel=MemMalloc((ae->ir+ae->iw+3)*8+4);
		locallabel[0]=0;
	}	
//printf("locallabel=[%s] (draft)\n",locallabel);

	dek=0;
	dek+=strappend(locallabel,"R");
	for (i=0;i<ae->ir;i++) {
		sprintf(hexdigit,"%04X",ae->repeat[i].cpt);
		dek+=strappend(locallabel,hexdigit);
	}
	if (ae->ir) {
		sprintf(hexdigit,"%04X",ae->repeat[ae->ir-1].value);
		dek+=strappend(locallabel+dek,hexdigit);
	}
	
	dek+=strappend(locallabel,"W");
	for (i=0;i<ae->iw;i++) {
		sprintf(hexdigit,"%04X",ae->whilewend[i].cpt);
		dek+=strappend(locallabel+dek,hexdigit);
	}
	if (ae->iw) {
		sprintf(hexdigit,"%04X",ae->whilewend[ae->iw-1].value);
		dek+=strappend(locallabel+dek,hexdigit);
	}
	/* where are we? */
	if (ae->imacropos) {
		for (im=ae->imacropos-1;im>=0;im--) {
			if (ae->idx>=ae->macropos[im].start && ae->idx<ae->macropos[im].end) break;
		}
		if (im>=0) {
			/* si on n'est pas dans une macro, on n'indique rien */
			sprintf(hexdigit,"M%04X",ae->macropos[im].value);
			dek+=strappend(locallabel+dek,hexdigit);
		}
	}
	if (!retdek) {
		if (zepoint) {
			*zepoint='.';
			strcat(locallabel+dek,zepoint);
		}
	} else {
		*retdek=dek;
	}
//printf("locallabel=[%s] (end)\n",locallabel);
	return locallabel;
}

char *TradExpression(char *zexp)
{
	#undef FUNC
	#define FUNC "TradExpression"
	
	static char *last_expression=NULL;
	char *wstr;
	
	if (last_expression) {MemFree(last_expression);last_expression=NULL;}
	if (!zexp) return NULL;
	
	wstr=TxtStrDup(zexp);
	wstr=TxtReplace(wstr,"[","<<",0);
	wstr=TxtReplace(wstr,"]",">>",0);
	wstr=TxtReplace(wstr,"m","%",0);

	last_expression=wstr;
	return wstr;
}

int TrimFloatingPointString(char *fps) {
	int i=0,pflag,zflag=0;
	
	while (fps[i]) {
		if (fps[i]=='.') {
			pflag=i;
			zflag=1;
		} else if (fps[i]!='0') {
			zflag=0;
		}
		i++;
	}
	/* truncate floating fract */
	if (zflag) {
		fps[pflag]=0;
	} else {
		pflag=i;
	}
	return pflag;
}



/*
	translate tag or formula between curly brackets
	used in label declaration
	used in print directive
*/
char *TranslateTag(struct s_assenv *ae, char *varbuffer, int *touched, int enablefast, int tagoption) {
	/*******************************************************
	       v a r i a b l e s     i n    s t r i n g s
	*******************************************************/
	char *starttag,*endtag,*tagcheck,*expr;
	int newlen,lenw,taglen,tagidx,tagcount,validx;
	char curvalstr[256]={0};


//printf("TranslateTag [%s]\n",varbuffer);

	if (tagoption & E_TAGOPTION_PRESERVE) {
		if (ae->iw || ae->ir) {
			/* inside a loop we must care about variables */
//printf("TranslateTag [%s] with PRESERVE inside a loop!\n",varbuffer);
			return varbuffer;
		}
	}

	*touched=0;
	while ((starttag=strchr(varbuffer+1,'{'))!=NULL) {
		if ((endtag=strchr(starttag,'}'))==NULL) {
			MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"invalid tag in string [%s]\n",varbuffer);
			return NULL;
		}
		/* allow inception */
		tagcount=1;
		tagcheck=starttag+1;
		while (*tagcheck && tagcount) {
			if (*tagcheck=='}') tagcount--; else if (*tagcheck=='{') tagcount++;
			tagcheck++;			
		}
		if (tagcount) {
			MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"invalid brackets combination in string [%s]\n",varbuffer);
			return NULL;
		} else {
			endtag=tagcheck-1;
		}
		*touched=1;
		taglen=endtag-starttag+1;
		tagidx=starttag-varbuffer;
		lenw=strlen(varbuffer); // before the EOF write
		*endtag=0;
		/*** c o m p u t e    e x p r e s s i o n ***/
		expr=TxtStrDup(starttag+1);
		if (tagoption & E_TAGOPTION_REMOVESPACE) expr=TxtReplace(expr," ","",0);
		if (enablefast) ExpressionFastTranslate(ae,&expr,0);
		validx=(int)RoundComputeExpressionCore(ae,expr,ae->codeadr,0);
		if (validx<0) {
			strcpy(curvalstr,"");
			MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"indexed tag must NOT be a negative value [%s]\n",varbuffer);
			MemFree(expr);
			return NULL;
		} else {
			#ifdef OS_WIN
			snprintf(curvalstr,sizeof(curvalstr)-1,"%d",validx);
			newlen=strlen(curvalstr);
			#else
			newlen=snprintf(curvalstr,sizeof(curvalstr)-1,"%d",validx);
			#endif
		}
		MemFree(expr);
		if (newlen>taglen) {
			/* realloc */
			varbuffer=MemRealloc(varbuffer,lenw+newlen-taglen+1);
		}
		if (newlen!=taglen ) {
			MemMove(varbuffer+tagidx+newlen,varbuffer+tagidx+taglen,lenw-taglen-tagidx+1);
		}
		strncpy(varbuffer+tagidx,curvalstr,newlen); /* copy without zero terminator */
	}

	return varbuffer;
}


#define CRC_JR		0x4BD52314
#define CRC_JP		0x4BD52312
#define CRC_DJNZ	0x37CD7BAE
#define CRC_RET		0xE1B32D63

#define CRC_JPHL	0xA3D34817
#define CRC_JPIX	0xA3D76424
#define CRC_JPIY	0xA3D76A25

/*
	count NOP of one or more instructions
*/
int __GETNOP(struct s_assenv *ae,char *oplist, int didx)
{
	#undef FUNC
	#define FUNC "__GETNOP"

	int idx=0,crc,tick=0;
	char **opcode=NULL;
	char *opref;

	/* upper case */
	while (oplist[idx]) {
		oplist[idx]=toupper(oplist[idx]);
		idx++;
	}
	/* duplicata */
	opref=TxtStrDup(oplist);
	/* count opcodes */
	opcode=TxtSplitWithChar(oplist,':');

	idx=0;
	while (opcode[idx]) {
		crc=GetCRC(opcode[idx]);

		/* partial support for DEC,DJNZ,RET,JR */
		switch (crc) {
			case CRC_JPHL:
				tick+=1;
				break;
			case CRC_JPIX:
			case CRC_JPIY:
				tick+=2;
				break;
			/**************************/
			case CRC_JP:
			case CRC_DJNZ:
			case CRC_JR:
			case CRC_RET:tick+=3;break;
			default: 
				MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"unsupported opcode [%s] for GETNOP, see documentation about this directive",opcode[idx]);
		}
		idx++;
	}
	MemFree(opref);
	if (opcode) MemFree(opcode);
	return tick;
}
int __GETTICK(struct s_assenv *ae,char *oplist, int didx)
{
	#undef FUNC
	#define FUNC "__GETTICK"

	int idx=0,crc,tick=0;
	char **opcode=NULL;
	char *opref;

	/* upper case */
	while (oplist[idx]) {
		oplist[idx]=toupper(oplist[idx]);
		idx++;
	}
	/* duplicata */
	opref=TxtStrDup(oplist);
	/* count opcodes */
	opcode=TxtSplitWithChar(oplist,':');

	idx=0;
	while (opcode[idx]) {
		crc=GetCRC(opcode[idx]);

		/* partial support for DEC,DJNZ,RET,JR */
		switch (crc) {
			case CRC_JPHL:
				tick+=4;
				break;
			case CRC_JPIX:
			case CRC_JPIY:
				tick+=8;
				break;
			/**************************/
			case CRC_JP:tick+=10;break;
			case CRC_DJNZ:tick+=13;break;
			case CRC_JR:tick+=12;break;
			case CRC_RET:tick+=10;break;
			default: 
				MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"unsupported opcode [%s] for GETNOP, see documentation about this directive",opcode[idx]);
		}
		idx++;
	}
	MemFree(opref);
	if (opcode) MemFree(opcode);
	return tick;
}
/*
	default returned value of Duration is NOP
	but BUILDZX usage change this to ticks!
*/
int __DURATION(struct s_assenv *ae,char *opcode, int didx)
{
	#undef FUNC
	#define FUNC "__DURATION"

	if (!ae->forcezx) return __GETNOP(ae,opcode,didx);
	return __GETTICK(ae,opcode,didx);
}

int __Soft2HardInk(struct s_assenv *ae,int soft, int didx) {
	switch (soft) {
		case 0:return 64+20;break;
		case 1:return 64+4 ;break;
		case 2:return 64+21 ;break;
		case 3:return 64+28 ;break;
		case 4:return 64+24 ;break;
		case 5:return 64+29 ;break;
		case 6:return 64+12 ;break;
		case 7:return 64+5 ;break;
		case 8:return 64+13 ;break;
		case 9:return 64+22 ;break;
		case 10:return 64+6 ;break;
		case 11:return 64+23 ;break;
		case 12:return 64+30 ;break;
		case 13:return 64+0 ;break;
		case 14:return 64+31 ;break;
		case 15:return 64+14 ;break;
		case 16:return 64+7 ;break;
		case 17:return 64+15 ;break;
		case 18:return 64+18 ;break;
		case 19:return 64+2 ;break;
		case 20:return 64+19 ;break;
		case 21:return 64+26 ;break;
		case 22:return 64+25 ;break;
		case 23:return 64+27 ;break;
		case 24:return 64+10 ;break;
		case 25:return 64+3 ;break;
		case 26:return 64+11 ;break;
		default:
			MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"SOFT2HARD_INK needs 0-26 color index");
	}
	return 0;
}
int __Hard2SoftInk(struct s_assenv *ae,int hard, int didx) {
	hard&=31;
	switch (hard) {
		case 0:return 13;break;
		case 1:return 13;break;
		case 2:return 19;break;
		case 3:return 25;break;
		case 4:return 1;break;
		case 5:return 7;break;
		case 6:return 10;break;
		case 7:return 16;break;
		case 8:return 7;break;
		case 9:return 25;break;
		case 10:return 24;break;
		case 11:return 26;break;
		case 12:return 6;break;
		case 13:return 8;break;
		case 14:return 15;break;
		case 15:return 17;break;
		case 16:return 1;break;
		case 17:return 19;break;
		case 18:return 18;break;
		case 19:return 20;break;
		case 20:return 0;break;
		case 21:return 2;break;
		case 22:return 9;break;
		case 23:return 11;break;
		case 24:return 4;break;
		case 25:return 22;break;
		case 26:return 21;break;
		case 27:return 23;break;
		case 28:return 3;break;
		case 29:return 5;break;
		case 30:return 12;break;
		case 31:return 14;break;
		default:/*warning remover*/
			MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"SOFT2HARD_INK warning remover");
	}
	return 0;
}

double ComputeExpressionCore(struct s_assenv *ae,char *original_zeexpression,int ptr, int didx)
{
	#undef FUNC
	#define FUNC "ComputeExpressionCore"

	/* static execution buffers */
	static double *accu=NULL;
	static int maccu=0;
	static struct s_compute_element *computestack=NULL;
	static int maxcomputestack=0;
	int i,j,paccu=0;
	int nbtokenstack=0;
	int nbcomputestack=0;
	int nboperatorstack=0;

	struct s_compute_element stackelement;
	int o2,okclose,itoken;
	
	int idx=0,crc,icheck,is_binary,ivar=0;
	char asciivalue[11];
	unsigned char c;
	int accu_err=0;
	/* backup alias replace */
	char *zeexpression,*expr;
	int original=1;
	int ialias,startvar=0;
	int newlen,lenw;
	/* dictionnary */
	struct s_expr_dico *curdic;
	struct s_label *curlabel;
	int minusptr,imkey,bank,page,getslot=0;
	double curval;
	int is_string=0;
	/* negative value */
	int allow_minus_as_sign=0;
	/* extended replace in labels */
	int curly=0,curlyflag=0;
	char *Automate;
	double dummint;

	/* memory cleanup */
	if (!ae) {
		if (maccu) MemFree(accu);
		accu=NULL;maccu=0;
		if (maxcomputestack) MemFree(computestack);
		computestack=NULL;maxcomputestack=0;
		return 0.0;
	}

	/* be sure to have at least some bytes allocated */
	StateMachineResizeBuffer(&ae->computectx->varbuffer,128,&ae->computectx->maxivar);


#if TRACE_COMPUTE_EXPRESSION
	printf("expression=[%s]\n",zeexpression);
#endif
	zeexpression=original_zeexpression;
	if (!zeexpression[0]) {
		return 0;
	}
	/* double hack if the first value is negative */
	if (zeexpression[0]=='-') {
		if (ae->AutomateExpressionValidCharFirst[(int)zeexpression[1]&0xFF]) {
			allow_minus_as_sign=1;
		} else {
			memset(&stackelement,0,sizeof(stackelement));
			ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->tokenstack,&nbtokenstack,&ae->computectx->maxtokenstack,&stackelement,sizeof(stackelement));
		}
	}

	/* is there ascii char? */
	while ((c=zeexpression[idx])!=0) {
		if (c=='\'' || c=='"') {
			/* echappement */
			if (zeexpression[idx+1]=='\\') {
				if (zeexpression[idx+2] && zeexpression[idx+3]==c) {
					sprintf(asciivalue,"#%03X",zeexpression[idx+2]);
					memcpy(zeexpression+idx,asciivalue,4);
					idx+=3;
				} else {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Only single escaped char may be quoted [%s]\n",TradExpression(zeexpression));
					zeexpression[0]=0;
					return 0;
				}
			} else if (zeexpression[idx+1] && zeexpression[idx+2]==c) {
					sprintf(asciivalue,"#%02X",zeexpression[idx+1]);
					memcpy(zeexpression+idx,asciivalue,3);
					idx+=2;
			} else {
				//printf("Expression with => moar than one char in quotes\n");
				//MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Only single char may be quoted [%s]\n",TradExpression(zeexpression));
				//zeexpression[0]=0;
				//return 0;
				idx++;
				while (zeexpression[idx] && zeexpression[idx]!=c) idx++; // no escape code management

			}
		}
		
		idx++;
	}
#if TRACE_COMPUTE_EXPRESSION
	printf("apres conversion des chars [%s]\n",zeexpression);
#endif
	/***********************************************************
	    P A T C H    F O R    P O S I T I V E     V A L U E    
	***********************************************************/
	if (zeexpression[0]=='+') idx=1; else idx=0;
	/***********************************************************
	  C O M P U T E   E X P R E S S I O N   M A I N    L O O P
	***********************************************************/
	while ((c=zeexpression[idx])!=0) {
		switch (c) {
			case '"':
			case '\'':
				//printf("COMPUTE => string detected!\n");
				ivar=0;
				idx++;
				while (zeexpression[idx] && zeexpression[idx]!=c) {
					ae->computectx->varbuffer[ivar++]=zeexpression[idx];
					StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
					idx++;
				}
				if (zeexpression[idx]) idx++; else MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"ComputeExpression [%s] quote bug!\n",TradExpression(zeexpression));
				ae->computectx->varbuffer[ivar]=0;
				is_string=1; // donc on ira jamais utiliser startvar derriere
				break;

			/* parenthesis */
			case ')':
				/* next to a closing parenthesis, a minus is an operator */
				allow_minus_as_sign=0;
				break;
			case '(':
			/* operator detection */
			case '*':
			case '/':
			case '^':
			case '[':
			case 'm':
			case '+':
			case ']':
				allow_minus_as_sign=1;
				break;
			case '&':
				allow_minus_as_sign=1;
				if (c=='&' && zeexpression[idx+1]=='&') {
					idx++;
					c='a'; // boolean AND
				}
				break;
			case '|':
				allow_minus_as_sign=1;
				if (c=='|' && zeexpression[idx+1]=='|') {
					idx++;
					c='o'; // boolean OR
				}
				break;
			/* testing */
			case '<':
				allow_minus_as_sign=1;
				if (zeexpression[idx+1]=='=') {
					idx++;
					c='k'; // boolean LOWEREQ
				} else if (zeexpression[idx+1]=='>') {
					idx++;
					c='n'; // boolean NOTEQUAL
				} else {
					c='l';
				}
				break;
			case '>':
				allow_minus_as_sign=1;
				if (zeexpression[idx+1]=='=') {
					idx++;
					c='h'; // boolean GREATEREQ
				} else {
					c='g';
				}
				break;
			case '!':
				allow_minus_as_sign=1;
				if (zeexpression[idx+1]=='=') {
					idx++;
					c='n'; // boolean NOTEQUAL
				} else {
					c='b';
				}
				break;
			case '=':
				allow_minus_as_sign=1;
				/* expecting == */
				if (zeexpression[idx+1]=='=') {
					idx++;
					c='e'; // boolean EQUAL
				/* except in maxam mode with a single = */
				} else if (ae->maxam) {
					c='e'; // boolean EQUAL
				/* cannot affect data inside an expression */
				} else {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot set variable inside an expression\n",TradExpression(zeexpression));
					return 0;
				}
				break;
			case '-':
				if (allow_minus_as_sign) {
					/* previous char was an opening parenthesis or an operator */
					ivar=0;
					ae->computectx->varbuffer[ivar++]='-';
					StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
					c=zeexpression[++idx];
					if (ae->AutomateExpressionValidCharFirst[(int)c&0xFF]) {
						ae->computectx->varbuffer[ivar++]=c;
						StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
						c=zeexpression[++idx];
						while (ae->AutomateExpressionValidChar[(int)c&0xFF]) {
							ae->computectx->varbuffer[ivar++]=c;
							StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
							c=zeexpression[++idx];
						}
					}
					ae->computectx->varbuffer[ivar]=0;
					if (ivar<2) {
						MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] invalid minus sign\n",TradExpression(zeexpression));
						if (!original) {
							MemFree(zeexpression);
						}
						return 0;
					}
					break;
				}
				allow_minus_as_sign=1;
				break;
				
			/* operator OR binary value */
			case '%':
				/* % symbol may be a modulo or a binary literal value */
				is_binary=0;
				for (icheck=1;zeexpression[idx+icheck];icheck++) {
					switch (zeexpression[idx+icheck]) {
						case '1':
						case '0':/* still binary */
							is_binary=1;
							break;
						case '+':
						case '-':
						case '/':
						case '*':
						case '|':
						case 'm':
						case '%':
						case '^':
						case '&':
						case '(':
						case ')':
						case '=':
						case '<':
						case '>':
						case '!':
						case '[':
						case ']':
							if (is_binary) is_binary=2; else is_binary=-1;
							break;
						default:
							is_binary=-1;
					}
					if (is_binary==2) {
						break;
					}
					if (is_binary==-1) {
						is_binary=0;
						break;
					}
				}
				if (!is_binary) {
					allow_minus_as_sign=1;
					c='m';
					break;
				}
			default:
				allow_minus_as_sign=0;
				/* semantic analysis */
				startvar=idx;
				ivar=0;
				/* first char does not allow same chars as next chars */
				if (ae->AutomateExpressionValidCharFirst[((int)c)&0xFF]) {
					ae->computectx->varbuffer[ivar++]=c;
					if (c=='{') {
						/* not a formula but only a prefix tag */
						curly++;
					}
					StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
					idx++;
					c=zeexpression[idx];
					Automate=ae->AutomateExpressionValidChar;
					while (Automate[((int)c)&0xFF]) {
						if (c=='{') {
							curly++;
							curlyflag=1;
							Automate=ae->AutomateExpressionValidCharExtended;
						} else if (c=='}') {
							curly--;
							if (!curly) {
								Automate=ae->AutomateExpressionValidChar;
							}
						}
						ae->computectx->varbuffer[ivar++]=c;
						StateMachineResizeBuffer(&ae->computectx->varbuffer,ivar,&ae->computectx->maxivar);
						idx++;
						c=zeexpression[idx];
					}
				}
				ae->computectx->varbuffer[ivar]=0;
				if (!ivar) {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"ComputeExpression invalid char (%d=%c) expression [%s]\n",c,c>31?c:' ',TradExpression(zeexpression));
					if (!original) {
						MemFree(zeexpression);
					}
					return 0;
				} else if (curly) {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"ComputeExpression wrong curly brackets in expression [%s]\n",TradExpression(zeexpression));
					if (!original) {
						MemFree(zeexpression);
					}
					return 0;
				}
		}
		if (c && !ivar) idx++;
	
		/************************************
		   S T A C K   D I S P A T C H E R
		************************************/
		/* push operator or stack value */
		if (!ivar) {
			/************************************
			          O P E R A T O R 
			************************************/
			stackelement=ae->AutomateElement[c];
			if (stackelement.operator>E_COMPUTE_OPERATION_GREATEREQ) {
				MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] has unknown operator %c (%d)\n",TradExpression(zeexpression),c>31?c:'.',c);
			}
			/* stackelement.value isn't used */
			stackelement.string=NULL;
		} else if (is_string) {
			stackelement.operator=E_COMPUTE_OPERATION_PUSH_DATASTC;
			/* priority & value isn't used */
			stackelement.string=TxtStrDup(ae->computectx->varbuffer);
			allow_minus_as_sign=0;
			ivar=is_string=0;
		} else {
			/************************************
			              V A L U E
			************************************/
#if TRACE_COMPUTE_EXPRESSION
	printf("value [%s]\n",ae->computectx->varbuffer);
#endif
			if (ae->computectx->varbuffer[0]=='-') minusptr=1; else minusptr=0;
			/* constantes ou variables/labels */
			switch (ae->computectx->varbuffer[minusptr]) {
				case '0':
					/* 0x hexa value hack */
					if (ae->computectx->varbuffer[minusptr+1]=='X' && ae->AutomateHexa[(int)ae->computectx->varbuffer[minusptr+2]&0xFF]) {
						for (icheck=minusptr+3;ae->computectx->varbuffer[icheck];icheck++) {
							if (ae->AutomateHexa[(int)ae->computectx->varbuffer[icheck]&0xFF]) continue;
							MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid hex number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
							break;
						}
						curval=strtol(ae->computectx->varbuffer+minusptr+2,NULL,16);
						break;
					} else
					/* 0b binary value hack */
					if (ae->computectx->varbuffer[minusptr+1]=='B' && (ae->computectx->varbuffer[minusptr+2]>='0' && ae->computectx->varbuffer[minusptr+2]<='1')) {
						for (icheck=minusptr+3;ae->computectx->varbuffer[icheck];icheck++) {
							if (ae->computectx->varbuffer[icheck]>='0' && ae->computectx->varbuffer[icheck]<='1') continue;
							MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid binary number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
							break;
						}
						curval=strtol(ae->computectx->varbuffer+minusptr+2,NULL,2);
						break;
					}
					/* 0o octal value hack */
					if (ae->computectx->varbuffer[minusptr+1]=='O' && (ae->computectx->varbuffer[minusptr+2]>='0' && ae->computectx->varbuffer[minusptr+2]<='5')) {
						for (icheck=minusptr+3;ae->computectx->varbuffer[icheck];icheck++) {
							if (ae->computectx->varbuffer[icheck]>='0' && ae->computectx->varbuffer[icheck]<='5') continue;
							MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid octal number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
							break;
						}
						curval=strtol(ae->computectx->varbuffer+minusptr+2,NULL,2);
						break;
					}
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
					/* check number */
					for (icheck=minusptr;ae->computectx->varbuffer[icheck];icheck++) {
						if (ae->AutomateDigit[(int)ae->computectx->varbuffer[icheck]&0xFF]) continue;
						/* Intel hexa & binary style */
						switch (ae->computectx->varbuffer[strlen(ae->computectx->varbuffer)-1]) {
							case 'H':
								for (icheck=minusptr;ae->computectx->varbuffer[icheck+1];icheck++) {
									if (ae->AutomateHexa[(int)ae->computectx->varbuffer[icheck]&0xFF]) continue;
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid hex number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
								}
								curval=strtol(ae->computectx->varbuffer+minusptr,NULL,16);
								break;
							case 'B':
								for (icheck=minusptr;ae->computectx->varbuffer[icheck+1];icheck++) {
									if (ae->computectx->varbuffer[icheck]=='0' || ae->computectx->varbuffer[icheck]=='1') continue;
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid binary number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
								}
								curval=strtol(ae->computectx->varbuffer+minusptr,NULL,2);
								break;
							default:
								MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
						}
						icheck=0;
						break;
					}
					if (!ae->computectx->varbuffer[icheck]) curval=atof(ae->computectx->varbuffer+minusptr);
					break;
				case '%':
					/* check number */
					if (!ae->computectx->varbuffer[minusptr+1]) {
						MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is an empty binary number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
					}
					for (icheck=minusptr+1;ae->computectx->varbuffer[icheck];icheck++) {
						if (ae->computectx->varbuffer[icheck]=='0' || ae->computectx->varbuffer[icheck]=='1') continue;
						MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid binary number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
						break;
					}
					curval=strtol(ae->computectx->varbuffer+minusptr+1,NULL,2);
					break;
				case '#':
					/* check number */
					if (!ae->computectx->varbuffer[minusptr+1]) {
						MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is an empty hex number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
					}
					for (icheck=minusptr+1;ae->computectx->varbuffer[icheck];icheck++) {
						if (ae->AutomateHexa[(int)ae->computectx->varbuffer[icheck]&0xFF]) continue;
						MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid hex number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
						break;
					}
					curval=strtol(ae->computectx->varbuffer+minusptr+1,NULL,16);
					break;
				default:
					if (1 || !curlyflag) {
						/* $ hex value hack */
						if (ae->computectx->varbuffer[minusptr+0]=='$' && ae->AutomateHexa[(int)ae->computectx->varbuffer[minusptr+1]&0xFF]) {
							for (icheck=minusptr+2;ae->computectx->varbuffer[icheck];icheck++) {
								if (ae->AutomateHexa[(int)ae->computectx->varbuffer[icheck]&0xFF]) continue;
								MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid hex number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
								break;
							}
							curval=strtol(ae->computectx->varbuffer+minusptr+1,NULL,16);
							break;
						}
						/* @ octal value hack */
						if (ae->computectx->varbuffer[minusptr+0]=='@' &&  ((ae->computectx->varbuffer[minusptr+1]>='0' && ae->computectx->varbuffer[minusptr+1]<='7'))) {
							for (icheck=minusptr+2;ae->computectx->varbuffer[icheck];icheck++) {
								if (ae->computectx->varbuffer[icheck]>='0' && ae->computectx->varbuffer[icheck]<='7') continue;
								MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is not a valid octal number\n",TradExpression(zeexpression),ae->computectx->varbuffer);
								break;
							}
							curval=strtol(ae->computectx->varbuffer+minusptr+1,NULL,8);
							break;
						}
						/* Intel hexa value hack */
						if (ae->AutomateHexa[(int)ae->computectx->varbuffer[minusptr+0]&0xFF]) {
							if (ae->computectx->varbuffer[strlen(ae->computectx->varbuffer)-1]=='H') {
								for (icheck=minusptr;ae->computectx->varbuffer[icheck+1];icheck++) {
									if (!ae->AutomateHexa[(int)ae->computectx->varbuffer[icheck]&0xFF]) break;
								}
								if (!ae->computectx->varbuffer[icheck+1]) {
									curval=strtol(ae->computectx->varbuffer+minusptr,NULL,16);
									break;
								}
							}
						}
					}
					
					
					if (curlyflag) {
						char *minivarbuffer;
						int touched;

						/* besoin d'un sous-contexte */
						minivarbuffer=TxtStrDup(ae->computectx->varbuffer+minusptr);
						ae->computectx=&ae->ctx2;
#if TRACE_COMPUTE_EXPRESSION
	printf("curly [%s]\n",minivarbuffer);
#endif
						minivarbuffer=TranslateTag(ae,minivarbuffer, &touched,0,E_TAGOPTION_NONE);
#if TRACE_COMPUTE_EXPRESSION
	printf("après curly [%s]\n",minivarbuffer);
#endif
						ae->computectx=&ae->ctx1;
						if (!touched) {
							strcpy(ae->computectx->varbuffer+minusptr,minivarbuffer);
						} else {
							StateMachineResizeBuffer(&ae->computectx->varbuffer,strlen(minivarbuffer)+2,&ae->computectx->maxivar);
							strcpy(ae->computectx->varbuffer+minusptr,minivarbuffer);
						}
						MemFree(minivarbuffer);
						curlyflag=0;
					}

					crc=GetCRC(ae->computectx->varbuffer+minusptr);
					/***************************************************
					     L O O K I N G   F O R   A   F U N C T I O N
					***************************************************/
					for (imkey=0;math_keyword[imkey].mnemo[0];imkey++) {
						if (crc==math_keyword[imkey].crc && strcmp(ae->computectx->varbuffer+minusptr,math_keyword[imkey].mnemo)==0) {
							if (c=='(') {
								/* push function as operator! */
								stackelement.operator=math_keyword[imkey].operation;
								stackelement.string=NULL;
								/************************************************
								      C R E A T E    E X T R A     T O K E N
								************************************************/
								ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->tokenstack,&nbtokenstack,&ae->computectx->maxtokenstack,&stackelement,sizeof(stackelement));
								stackelement.operator=E_COMPUTE_OPERATION_OPEN;
								ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->tokenstack,&nbtokenstack,&ae->computectx->maxtokenstack,&stackelement,sizeof(stackelement));
								allow_minus_as_sign=1;
								idx++;
							} else {
								MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is a reserved keyword!\n",TradExpression(zeexpression),math_keyword[imkey].mnemo);
								curval=0;
								idx++;
							}
							ivar=0;
							break;
						}
					}
					if (math_keyword[imkey].mnemo[0]) continue;
					
					if (ae->computectx->varbuffer[minusptr+0]=='$' && ae->computectx->varbuffer[minusptr+1]==0) {
						curval=ptr;
					} else {
#if TRACE_COMPUTE_EXPRESSION
	printf("search dico [%s]\n",ae->computectx->varbuffer+minusptr);
#endif
						curdic=SearchDico(ae,ae->computectx->varbuffer+minusptr,crc);
						if (curdic) {
#if TRACE_COMPUTE_EXPRESSION
	printf("trouvé valeur=%.2lf\n",curdic->v);
#endif
							curval=curdic->v;
							break;
						} else {
							/* getbank hack */
							if (ae->computectx->varbuffer[minusptr]!='{') {
								bank=0;
								page=0;
							} else if (strncmp(ae->computectx->varbuffer+minusptr,"{SLOT}",6)==0) {
								bank=6;
								page=0;
								getslot=1;
								/* obligé de recalculer le CRC */
								crc=GetCRC(ae->computectx->varbuffer+minusptr+bank);
							} else if (strncmp(ae->computectx->varbuffer+minusptr,"{BANK}",6)==0) {
								bank=6;
								page=0;
								getslot=0;
								/* obligé de recalculer le CRC */
								crc=GetCRC(ae->computectx->varbuffer+minusptr+bank);
							} else if (strncmp(ae->computectx->varbuffer+minusptr,"{PAGE}",6)==0) {
								bank=6;
								page=1;
								/* obligé de recalculer le CRC */
								crc=GetCRC(ae->computectx->varbuffer+minusptr+bank);
							} else if (strncmp(ae->computectx->varbuffer+minusptr,"{PAGESET}",9)==0) {
								bank=9;
								page=2;
								/* obligé de recalculer le CRC */
								crc=GetCRC(ae->computectx->varbuffer+minusptr+bank);
							} else if (strncmp(ae->computectx->varbuffer+minusptr,"{SIZEOF}",8)==0) {
								bank=8;
								page=3;
								/* obligé de recalculer le CRC */
								crc=GetCRC(ae->computectx->varbuffer+minusptr+bank);
								/* search in structures prototypes and subfields */
								for (i=0;i<ae->irasmstruct;i++) {
									if (ae->rasmstruct[i].crc==crc && strcmp(ae->rasmstruct[i].name,ae->computectx->varbuffer+minusptr+bank)==0) {
										curval=ae->rasmstruct[i].size;
										break;
									}

									for (j=0;j<ae->rasmstruct[i].irasmstructfield;j++) {
										if (ae->rasmstruct[i].rasmstructfield[j].crc==crc && strcmp(ae->rasmstruct[i].rasmstructfield[j].fullname,ae->computectx->varbuffer+minusptr+bank)==0) {
											curval=ae->rasmstruct[i].rasmstructfield[j].size;
											i=ae->irasmstruct+1;
											break;
										}
									}
								}

								if (i==ae->irasmstruct) {
									/* search in structures aliases */
									for (i=0;i<ae->irasmstructalias;i++) {
										if (ae->rasmstructalias[i].crc==crc && strcmp(ae->rasmstructalias[i].name,ae->computectx->varbuffer+minusptr+bank)==0) {
											curval=ae->rasmstructalias[i].size+ae->rasmstructalias[i].ptr;
											break;
										}
									}
									if (i==ae->irasmstructalias) {
										MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"cannot SIZEOF unknown structure [%s]!\n",ae->computectx->varbuffer+minusptr+bank);
										curval=0;
									}
								}
							} else {
								MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] - %s is an unknown prefix!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
								bank=0; // on pourrait sauter le tag pour eviter la merde a suivre
								page=0;
							}
							/* limited label translation while processing crunched blocks
							   ae->curlz == current crunched block processed
							   expression->crunch_block=0 -> oui
							   expression->crunch_block=1 -> oui si même block
							   expression->crunch_block=2 -> non car sera relogée
							*/
							if (page!=3) {



if (didx>0 && didx<ae->ie) {
	if (ae->expression[didx].module) {
		char *dblvarbuffer;
#if TRACE_LABEL || TRACE_COMPUTE_EXPRESSION
		printf("search label [%s] in an expression / module=[%s]\n",ae->computectx->varbuffer+minusptr+bank,ae->expression[didx].module);
#endif
		dblvarbuffer=MemMalloc(strlen(ae->computectx->varbuffer)+strlen(ae->expression[didx].module)+2);

		strcpy(dblvarbuffer,ae->expression[didx].module);
		strcat(dblvarbuffer,ae->module_separator);
		strcat(dblvarbuffer,ae->computectx->varbuffer+minusptr+bank);

		/* on essaie toujours de trouver le label du module courant */	
		curlabel=SearchLabel(ae,dblvarbuffer,GetCRC(dblvarbuffer));
		MemFree(dblvarbuffer);
	} else {
#if TRACE_LABEL || TRACE_COMPUTE_EXPRESSION
		printf("search label [%s] in an expression without module\n",ae->computectx->varbuffer+minusptr+bank);
#endif
		curlabel=NULL;
	}

	/* pas trouvé on cherche LEGACY */
	if (!curlabel) curlabel=SearchLabel(ae,ae->computectx->varbuffer+minusptr+bank,crc);
#if TRACE_LABEL || TRACE_COMPUTE_EXPRESSION
	else printf("label trouve via ajout du MODULE\n");
#endif

} else {
#if TRACE_LABEL || TRACE_COMPUTE_EXPRESSION
	printf("search label [%s] outside an expression taking current module!\n",ae->computectx->varbuffer+minusptr+bank);
#endif
	if (ae->module) {
		char *dblvarbuffer;
		dblvarbuffer=MemMalloc(strlen(ae->computectx->varbuffer)+strlen(ae->module)+2);
		strcpy(dblvarbuffer,ae->module);
		strcat(dblvarbuffer,ae->module_separator);
		strcat(dblvarbuffer,ae->computectx->varbuffer+minusptr+bank);

		/* on essaie toujours de trouver le label du module courant */	
		curlabel=SearchLabel(ae,dblvarbuffer,GetCRC(dblvarbuffer));
		/* pas trouvé on cherche LEGACY */
		if (!curlabel) curlabel=SearchLabel(ae,ae->computectx->varbuffer+minusptr+bank,crc);
#if TRACE_LABEL || TRACE_COMPUTE_EXPRESSION
		else printf("label trouve via ajout du MODULE\n");
#endif

		MemFree(dblvarbuffer);
	} else {
		curlabel=SearchLabel(ae,ae->computectx->varbuffer+minusptr+bank,crc);
	}
}



								if (curlabel) {
									if (ae->stage<2) {
										if (curlabel->lz==-1) {
											if (!bank) {
												curval=curlabel->ptr;
											} else {
#if TRACE_COMPUTE_EXPRESSION
printf("page=%d | ptr=%X ibank=%d\n",page,curlabel->ptr,curlabel->ibank);
#endif
												switch (page) {
													case 2: /* PAGESET */
														if (curlabel->ibank<BANK_MAX_NUMBER) {
															curval=ae->setgate[curlabel->ibank];
														} else {
															MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGESET - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
															curval=curlabel->ibank;
														}
														break;
													case 1:/* PAGE */
														if (curlabel->ibank<BANK_MAX_NUMBER) {
															/* 4M expansion compliant */
															if (ae->bankset[curlabel->ibank>>2]) {
																curval=ae->bankgate[(curlabel->ibank&0x1FC)+(curlabel->ptr>>14)];
															} else {
																curval=ae->bankgate[curlabel->ibank];
															}
														} else {
															MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGE - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
															curval=curlabel->ibank;
														}
														break;
													case 0:
														if (!getslot) {
															if (ae->extendedCPR) {
																curval=curlabel->ibank&31;
															} else {
																curval=curlabel->ibank;
															}
														} else {
															curval=curlabel->ibank>>5;
														}
														break;
													default:MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INTERNAL ERROR (unknown paging)\n",GetExpFile(ae,didx),GetExpLine(ae,didx));FreeAssenv(ae);exit(-664);
												}
											}
										} else {
											/* label MUST be intermediate OR in the crunched block */
											if (ae->lzsection[curlabel->lz].lzversion==0 || (curlabel->iorgzone==ae->expression[didx].iorgzone && curlabel->ibank==ae->expression[didx].ibank && curlabel->lz<=ae->expression[didx].lz)) {
												if (!bank) {
													curval=curlabel->ptr;
												} else {
													if (page) {
														switch (page) {
															case 2:  /* PAGESET */
																if (curlabel->ibank<BANK_MAX_NUMBER) {
																	/* 4M expansion compliant */
																	curval=ae->setgate[curlabel->ibank];
																} else {
																	MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGESET - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
																	curval=curlabel->ibank;
																}
																break;
															case 1: /* PAGE */
																if (curlabel->ibank<BANK_MAX_NUMBER) {
																	/* 4M expansion compliant */
																	if (ae->bankset[curlabel->ibank>>2]) {
																		curval=ae->bankgate[(curlabel->ibank&0x1FC)+(curlabel->ptr>>14)];
																	} else {																		
																		curval=ae->bankgate[curlabel->ibank];
																	}
																} else {
																	MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGE - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
																	curval=curlabel->ibank;
																}
																break;
															case 0:curval=curlabel->ibank;break;
															default:MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INTERNAL ERROR (unknown paging)\n");FreeAssenv(ae);exit(-664);
														}
													}
												}
											} else {
												MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Label [%s](%d) cannot be computed because it is located after the crunched zone %d\n",ae->computectx->varbuffer,curlabel->lz,ae->expression[didx].lz);
												curval=0;
											}
										}
									} else {
#if TRACE_COMPUTE_EXPRESSION
printf("stage 2 | page=%d | ptr=%X ibank=%d\n",page,curlabel->ptr,curlabel->ibank);
#endif
										if (bank) {
											//curval=curlabel->ibank;
											switch (page) {
												case 2: /* PAGESET */
													if (curlabel->ibank<BANK_MAX_NUMBER) {
														curval=ae->setgate[curlabel->ibank];
													} else {
														MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGESET - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
														curval=curlabel->ibank;
													}
													break;
												case 1:/* PAGE */
													if (curlabel->ibank<BANK_MAX_NUMBER) {
														/* 4M expansion compliant */
														if (ae->bankset[curlabel->ibank>>2]) {
															curval=ae->bankgate[(curlabel->ibank&0x1FC)+(curlabel->ptr>>14)];
														} else {
															curval=ae->bankgate[curlabel->ibank];
														}
													} else {
														MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] cannot use PAGE - label [%s] is in a temporary space!\n",TradExpression(zeexpression),ae->computectx->varbuffer);
														curval=curlabel->ibank;
													}
													break;
												case 0:
													curval=curlabel->ibank;
													break;
												default:MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INTERNAL ERROR (unknown paging)\n",GetExpFile(ae,didx),GetExpLine(ae,didx));FreeAssenv(ae);exit(-664);
											}
										} else {
											curval=curlabel->ptr;
										}
									}
								} else {
									/***********
										to allow aliases declared after use
									***********/
									if ((ialias=SearchAlias(ae,crc,ae->computectx->varbuffer+minusptr))>=0) {
										newlen=ae->alias[ialias].len;
										lenw=strlen(zeexpression);
										if (newlen>ivar) {
											/* realloc bigger */
											if (original) {
												expr=MemMalloc(lenw+newlen-ivar+1);
												memcpy(expr,zeexpression,lenw+1);
												zeexpression=expr;
												original=0;
											} else {
												zeexpression=MemRealloc(zeexpression,lenw+newlen-ivar+1);
											}
										}
										/* startvar? */
										if (newlen!=ivar) {
											MemMove(zeexpression+startvar+newlen,zeexpression+startvar+ivar,lenw-startvar-ivar+1);
										}
										strncpy(zeexpression+startvar,ae->alias[ialias].translation,newlen); /* copy without zero terminator */
										idx=startvar;
										ivar=0;
										continue;
									} else {
										/* index possible sur une struct? */
										int reverse_idx,validx=-1;
										char *structlabel;

										reverse_idx=strlen(ae->computectx->varbuffer)-1;
										if (ae->computectx->varbuffer[reverse_idx]>='0' && ae->computectx->varbuffer[reverse_idx]<='9') {
											/* vu que ça ne PEUT PAS être une valeur litérale, on ne fait pas de test de débordement */
											reverse_idx--;
											while (ae->computectx->varbuffer[reverse_idx]>='0' && ae->computectx->varbuffer[reverse_idx]<='9') {
												reverse_idx--;
											}
											reverse_idx++;
											validx=atoi(ae->computectx->varbuffer+reverse_idx);
											structlabel=TxtStrDup(ae->computectx->varbuffer+minusptr);
											structlabel[reverse_idx-minusptr]=0;
#if TRACE_STRUCT
			printf("EVOL 119 -> looking for struct %s IDX=%d\n",structlabel,validx);
#endif
											/* unoptimized search in structures aliases */
											crc=GetCRC(structlabel);
											for (i=0;i<ae->irasmstructalias;i++) {
												if (ae->rasmstructalias[i].crc==crc && strcmp(ae->rasmstructalias[i].name,structlabel)==0) {
#if TRACE_STRUCT
							printf("EVOL 119 -> found! ptr=%d size=%d\n",ae->rasmstructalias[i].ptr,ae->rasmstructalias[i].size);
#endif
													curval=ae->rasmstructalias[i].size*validx+ae->rasmstructalias[i].ptr;
													if (validx>=ae->rasmstructalias[i].nbelem) {
														if (!ae->nowarning) {
															rasm_printf(ae,KWARNING"[%s:%d] Warning: index out of array size!\n",GetExpFile(ae,didx),GetExpLine(ae,didx));
															if (ae->erronwarn) MaxError(ae);
														}
													}
													break;
												}
											}
											if (i==ae->irasmstructalias) {
												/* not found */
												validx=-1;
											}
											MemFree(structlabel);
										}
										if (validx<0) {
											/* last chance to get a keyword */
											if (strcmp(ae->computectx->varbuffer+minusptr,"REPEAT_COUNTER")==0) {
												if (ae->ir) {
													curval=ae->repeat[ae->ir-1].repeat_counter;
												} else {
													MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"cannot use REPEAT_COUNTER keyword outside a repeat loop\n");
													curval=0;
												}
											} else if (strcmp(ae->computectx->varbuffer+minusptr,"WHILE_COUNTER")==0) {
												if (ae->iw) {
													curval=ae->whilewend[ae->iw-1].while_counter;
												} else {
													MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"cannot use WHILE_COUNTER keyword outside a while loop\n");
													curval=0;
												}
											} else {
												/* in case the expression is a register */
												if (IsRegister(ae->computectx->varbuffer+minusptr)) {
													MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"cannot use register %s in this context\n",TradExpression(zeexpression));
												} else {
													if (IsDirective(ae->computectx->varbuffer+minusptr)) {
														MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"cannot use directive %s in this context\n",TradExpression(zeexpression));
													} else {

														MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"expression [%s] keyword [%s] not found in variables, labels or aliases\n",TradExpression(zeexpression),ae->computectx->varbuffer+minusptr);
														if (ae->extended_error) {
															char *lookstr;
															lookstr=StringLooksLike(ae,ae->computectx->varbuffer+minusptr);
															if (lookstr) {
																rasm_printf(ae,KERROR" did you mean [%s] ?\n",lookstr);
															}
														}
													}
												}
												
												curval=0;
											}
										}
									}
								}
							}
						}
					}
			}
			if (minusptr) curval=-curval;
			stackelement.operator=E_COMPUTE_OPERATION_PUSH_DATASTC;
			stackelement.value=curval;
			/* priority isn't used */
			stackelement.string=NULL;
			
			allow_minus_as_sign=0;
			ivar=0;
		}
		/************************************
		      C R E A T E    T O K E N
		************************************/
		ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->tokenstack,&nbtokenstack,&ae->computectx->maxtokenstack,&stackelement,sizeof(stackelement));
	}
	/*******************************************************
	      C R E A T E    E X E C U T I O N    S T A C K
	*******************************************************/
#define DEBUG_STACK 0
#if DEBUG_STACK
	for (itoken=0;itoken<nbtokenstack;itoken++) {
		switch (ae->computectx->tokenstack[itoken].operator) {
			case E_COMPUTE_OPERATION_PUSH_DATASTC:printf("%lf %s",ae->computectx->tokenstack[itoken].value,ae->computectx->tokenstack[itoken].string?ae->computectx->tokenstack[itoken].string:"(null)");break;
			case E_COMPUTE_OPERATION_OPEN:printf("(");break;
			case E_COMPUTE_OPERATION_CLOSE:printf(")");break;
			case E_COMPUTE_OPERATION_ADD:printf("+ ");break;
			case E_COMPUTE_OPERATION_SUB:printf("- ");break;
			case E_COMPUTE_OPERATION_DIV:printf("/ ");break;
			case E_COMPUTE_OPERATION_MUL:printf("* ");break;
			case E_COMPUTE_OPERATION_ZAND:printf("and ");break;
			case E_COMPUTE_OPERATION_OR:printf("or ");break;
			case E_COMPUTE_OPERATION_MOD:printf("mod ");break;
			case E_COMPUTE_OPERATION_XOR:printf("xor ");break;
			case E_COMPUTE_OPERATION_NOT:printf("! ");break;
			case E_COMPUTE_OPERATION_SHL:printf("<< ");break;
			case E_COMPUTE_OPERATION_SHR:printf(">> ");break;
			case E_COMPUTE_OPERATION_BAND:printf("&& ");break;
			case E_COMPUTE_OPERATION_BOR:printf("|| ");break;
			case E_COMPUTE_OPERATION_LOWER:printf("< ");break;
			case E_COMPUTE_OPERATION_GREATER:printf("> ");break;
			case E_COMPUTE_OPERATION_EQUAL:printf("== ");break;
			case E_COMPUTE_OPERATION_NOTEQUAL:printf("!= ");break;
			case E_COMPUTE_OPERATION_LOWEREQ:printf("<= ");break;
			case E_COMPUTE_OPERATION_GREATEREQ:printf(">= ");break;
			case E_COMPUTE_OPERATION_SIN:printf("sin ");break;
			case E_COMPUTE_OPERATION_COS:printf("cos ");break;
			case E_COMPUTE_OPERATION_INT:printf("int ");break;
			case E_COMPUTE_OPERATION_FLOOR:printf("floor ");break;
			case E_COMPUTE_OPERATION_ABS:printf("abs ");break;
			case E_COMPUTE_OPERATION_LN:printf("ln ");break;
			case E_COMPUTE_OPERATION_LOG10:printf("log10 ");break;
			case E_COMPUTE_OPERATION_SQRT:printf("sqrt ");break;
			case E_COMPUTE_OPERATION_ASIN:printf("asin ");break;
			case E_COMPUTE_OPERATION_ACOS:printf("acos ");break;
			case E_COMPUTE_OPERATION_ATAN:printf("atan ");break;
			case E_COMPUTE_OPERATION_EXP:printf("exp ");break;
			case E_COMPUTE_OPERATION_LOW:printf("low ");break;
			case E_COMPUTE_OPERATION_HIGH:printf("high ");break;
			case E_COMPUTE_OPERATION_PSG:printf("psg ");break;
			case E_COMPUTE_OPERATION_RND:printf("rnd ");break;
			case E_COMPUTE_OPERATION_FRAC:printf("frac ");break;
			case E_COMPUTE_OPERATION_CEIL:printf("ceil ");break;
			case E_COMPUTE_OPERATION_GET_R:printf("get_r ");break;
			case E_COMPUTE_OPERATION_GET_V:printf("get_v ");break;
			case E_COMPUTE_OPERATION_GET_B:printf("get_b ");break;
			case E_COMPUTE_OPERATION_SET_R:printf("set_r ");break;
			case E_COMPUTE_OPERATION_SET_V:printf("set_v ");break;
			case E_COMPUTE_OPERATION_SET_B:printf("set_b ");break;
			case E_COMPUTE_OPERATION_SOFT2HARD:printf("soft2hard ");break;
			case E_COMPUTE_OPERATION_HARD2SOFT:printf("hard2soft ");break;
			case E_COMPUTE_OPERATION_GETNOP:printf("getnop ");break;
			case E_COMPUTE_OPERATION_GETTICK:printf("gettick ");break;
			case E_COMPUTE_OPERATION_DURATION:printf("duration ");break;
			default:printf("bug\n");break;
		}
		
	}
	printf("\n");
#endif

	for (itoken=0;itoken<nbtokenstack;itoken++) {
		switch (ae->computectx->tokenstack[itoken].operator) {
			case E_COMPUTE_OPERATION_PUSH_DATASTC:
#if DEBUG_STACK
printf("data string=%X\n",ae->computectx->tokenstack[itoken].string);
#endif
				ObjectArrayAddDynamicValueConcat((void **)&computestack,&nbcomputestack,&maxcomputestack,&ae->computectx->tokenstack[itoken],sizeof(stackelement));
				break;
			case E_COMPUTE_OPERATION_OPEN:
				ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->operatorstack,&nboperatorstack,&ae->computectx->maxoperatorstack,&ae->computectx->tokenstack[itoken],sizeof(stackelement));
#if DEBUG_STACK
printf("ajout ( string=%X\n",ae->computectx->tokenstack[itoken].string);
#endif
				break;
			case E_COMPUTE_OPERATION_CLOSE:
#if DEBUG_STACK
printf("close\n");
#endif
				/* pop out token until the opened parenthesis is reached */
				o2=nboperatorstack-1;
				okclose=0;
				while (o2>=0) {
					if (ae->computectx->operatorstack[o2].operator!=E_COMPUTE_OPERATION_OPEN) {
						ObjectArrayAddDynamicValueConcat((void **)&computestack,&nbcomputestack,&maxcomputestack,&ae->computectx->operatorstack[o2],sizeof(stackelement));
						nboperatorstack--;
#if DEBUG_STACK
printf("op-- string=%X\n",ae->computectx->operatorstack[o2].string);
#endif
						o2--;
					} else {
						/* discard opening parenthesis as operator */
#if DEBUG_STACK
printf("discard )\n");
#endif
						nboperatorstack--;
						okclose=1;
						o2--;
						break;
					}
				}
				if (!okclose) {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"missing parenthesis [%s]\n",TradExpression(zeexpression));
					if (!original) {
						MemFree(zeexpression);
					}
					return 0;
				}
				/* if upper token is a function then pop from the stack */
				if (o2>=0 && ae->computectx->operatorstack[o2].operator>=E_COMPUTE_OPERATION_SIN) {
					ObjectArrayAddDynamicValueConcat((void **)&computestack,&nbcomputestack,&maxcomputestack,&ae->computectx->operatorstack[o2],sizeof(stackelement));
					nboperatorstack--;
#if DEBUG_STACK
printf("pop function string=%X\n",ae->computectx->operatorstack[o2].string);
#endif
				}
				break;
			case E_COMPUTE_OPERATION_ADD:
			case E_COMPUTE_OPERATION_SUB:
			case E_COMPUTE_OPERATION_DIV:
			case E_COMPUTE_OPERATION_MUL:
			case E_COMPUTE_OPERATION_ZAND:
			case E_COMPUTE_OPERATION_OR:
			case E_COMPUTE_OPERATION_MOD:
			case E_COMPUTE_OPERATION_XOR:
			case E_COMPUTE_OPERATION_NOT:
			case E_COMPUTE_OPERATION_SHL:
			case E_COMPUTE_OPERATION_SHR:
			case E_COMPUTE_OPERATION_BAND:
			case E_COMPUTE_OPERATION_BOR:
			case E_COMPUTE_OPERATION_LOWER:
			case E_COMPUTE_OPERATION_GREATER:
			case E_COMPUTE_OPERATION_EQUAL:
			case E_COMPUTE_OPERATION_NOTEQUAL:
			case E_COMPUTE_OPERATION_LOWEREQ:
			case E_COMPUTE_OPERATION_GREATEREQ:
				o2=nboperatorstack-1;
				while (o2>=0 && ae->computectx->operatorstack[o2].operator!=E_COMPUTE_OPERATION_OPEN) {
					if (ae->computectx->tokenstack[itoken].priority>=ae->computectx->operatorstack[o2].priority || ae->computectx->operatorstack[o2].operator>=E_COMPUTE_OPERATION_SIN) {
						ObjectArrayAddDynamicValueConcat((void **)&computestack,&nbcomputestack,&maxcomputestack,&ae->computectx->operatorstack[o2],sizeof(stackelement));
#if DEBUG_STACK
printf("operator string=%X\n",ae->computectx->operatorstack[o2].string);
#endif
						nboperatorstack--;
						o2--;
					} else {
						break;
					}
				}
				ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->operatorstack,&nboperatorstack,&ae->computectx->maxoperatorstack,&ae->computectx->tokenstack[itoken],sizeof(stackelement));
				break;
			case E_COMPUTE_OPERATION_SIN:
			case E_COMPUTE_OPERATION_COS:
			case E_COMPUTE_OPERATION_INT:
			case E_COMPUTE_OPERATION_FLOOR:
			case E_COMPUTE_OPERATION_ABS:
			case E_COMPUTE_OPERATION_LN:
			case E_COMPUTE_OPERATION_LOG10:
			case E_COMPUTE_OPERATION_SQRT:
			case E_COMPUTE_OPERATION_ASIN:
			case E_COMPUTE_OPERATION_ACOS:
			case E_COMPUTE_OPERATION_ATAN:
			case E_COMPUTE_OPERATION_EXP:
			case E_COMPUTE_OPERATION_LOW:
			case E_COMPUTE_OPERATION_HIGH:
			case E_COMPUTE_OPERATION_PSG:
			case E_COMPUTE_OPERATION_RND:
			case E_COMPUTE_OPERATION_FRAC:
			case E_COMPUTE_OPERATION_CEIL:
			case E_COMPUTE_OPERATION_GET_R:
			case E_COMPUTE_OPERATION_GET_V:
			case E_COMPUTE_OPERATION_GET_B:
			case E_COMPUTE_OPERATION_SET_R:
			case E_COMPUTE_OPERATION_SET_V:
			case E_COMPUTE_OPERATION_SET_B:
			case E_COMPUTE_OPERATION_SOFT2HARD:
			case E_COMPUTE_OPERATION_HARD2SOFT:
			case E_COMPUTE_OPERATION_GETNOP:
			case E_COMPUTE_OPERATION_GETTICK:
			case E_COMPUTE_OPERATION_DURATION:
#if DEBUG_STACK
printf("ajout de la fonction\n");
#endif
				ObjectArrayAddDynamicValueConcat((void **)&ae->computectx->operatorstack,&nboperatorstack,&ae->computectx->maxoperatorstack,&ae->computectx->tokenstack[itoken],sizeof(stackelement));
				break;
			default:break;
		}
	}
	/* pop remaining operators */
	while (nboperatorstack>0) {
		ObjectArrayAddDynamicValueConcat((void **)&computestack,&nbcomputestack,&maxcomputestack,&ae->computectx->operatorstack[--nboperatorstack],sizeof(stackelement));
#if DEBUG_STACK
printf("final POP string=%X\n",ae->computectx->operatorstack[nboperatorstack+1].string);
#endif
	}
	
	/********************************************
	        E X E C U T E        S T A C K
	********************************************/
	if (ae->maxam || ae->as80) {
		int workinterval;
		if (ae->as80) workinterval=0xFFFFFFFF; else workinterval=0xFFFF;
		for (i=0;i<nbcomputestack;i++) {
			switch (computestack[i].operator) {
				/************************************************
				  c a s e s   s h o u l d    b e    s o r t e d
				************************************************/
				case E_COMPUTE_OPERATION_PUSH_DATASTC:
					if (maccu<=paccu) {
						maccu=16+paccu;
						accu=MemRealloc(accu,sizeof(double)*maccu);
					}
					if (computestack[i].string) {
						/* string hack */
						accu[paccu]=i+0.1;
					} else {
						accu[paccu]=computestack[i].value;
					}
					paccu++;
					break;
				case E_COMPUTE_OPERATION_OPEN:
				case E_COMPUTE_OPERATION_CLOSE:/* cannot happend */ break;
				case E_COMPUTE_OPERATION_ADD:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]+(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_SUB:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]-(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_MUL:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]*(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_DIV:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]/(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_ZAND:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_OR:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]|(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_XOR:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]^(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_MOD:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]%(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_SHL:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2])<<((int)accu[paccu-1]);
								if (((int)accu[paccu-1])>31 || ((int)accu[paccu-1])<-31) {
									if (!ae->nowarning) {
										rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)accu[paccu-1]);
															if (ae->erronwarn) MaxError(ae);
									}
									accu[paccu-2]=0;
								}
								paccu--;break;
				case E_COMPUTE_OPERATION_SHR:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2])>>((int)accu[paccu-1]);
								if (((int)accu[paccu-1])>31 || ((int)accu[paccu-1])<-31) {
									if (!ae->nowarning) {
										rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)accu[paccu-1]);
															if (ae->erronwarn) MaxError(ae);
									}
									accu[paccu-2]=0;
								}
								paccu--;break;
				case E_COMPUTE_OPERATION_BAND:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&&(int)accu[paccu-1])&workinterval;paccu--;break;
				case E_COMPUTE_OPERATION_BOR:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]||(int)accu[paccu-1])&workinterval;paccu--;break;
				/* comparison */
				case E_COMPUTE_OPERATION_LOWER:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)<((int)accu[paccu-1]&workinterval);paccu--;break;
				case E_COMPUTE_OPERATION_LOWEREQ:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)<=((int)accu[paccu-1]&workinterval);paccu--;break;
				case E_COMPUTE_OPERATION_EQUAL:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)==((int)accu[paccu-1]&workinterval);paccu--;break;
				case E_COMPUTE_OPERATION_NOTEQUAL:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)!=((int)accu[paccu-1]&workinterval);paccu--;break;
				case E_COMPUTE_OPERATION_GREATER:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)>((int)accu[paccu-1]&workinterval);paccu--;break;
				case E_COMPUTE_OPERATION_GREATEREQ:if (paccu>1) accu[paccu-2]=((int)accu[paccu-2]&workinterval)>=((int)accu[paccu-1]&workinterval);paccu--;break;
				/* functions */
				case E_COMPUTE_OPERATION_SIN:if (paccu>0) accu[paccu-1]=(int)sin(accu[paccu-1]*3.1415926545/180.0);break;
				case E_COMPUTE_OPERATION_COS:if (paccu>0) accu[paccu-1]=(int)cos(accu[paccu-1]*3.1415926545/180.0);break;
				case E_COMPUTE_OPERATION_ASIN:if (paccu>0) accu[paccu-1]=(int)asin(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_ACOS:if (paccu>0) accu[paccu-1]=(int)acos(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_ATAN:if (paccu>0) accu[paccu-1]=(int)atan(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_INT:break;
				case E_COMPUTE_OPERATION_FLOOR:if (paccu>0) accu[paccu-1]=(int)floor(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_ABS:if (paccu>0) accu[paccu-1]=(int)fabs(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_EXP:if (paccu>0) accu[paccu-1]=(int)exp(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_LN:if (paccu>0) accu[paccu-1]=(int)log(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_LOG10:if (paccu>0) accu[paccu-1]=(int)log10(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_SQRT:if (paccu>0) accu[paccu-1]=(int)sqrt(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_LOW:if (paccu>0) accu[paccu-1]=((int)accu[paccu-1])&0xFF;break;
				case E_COMPUTE_OPERATION_HIGH:if (paccu>0) accu[paccu-1]=(((int)accu[paccu-1])&0xFF00)>>8;break;
				case E_COMPUTE_OPERATION_PSG:if (paccu>0) accu[paccu-1]=ae->psgfine[((int)accu[paccu-1])&0xFF];break;
				case E_COMPUTE_OPERATION_RND:if (paccu>0) {
								     int zemod;
								     zemod=(int)floor(accu[paccu-1]+0.5);
								     if (zemod>0) {
									     accu[paccu-1]=FastRand()%zemod;
								     } else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"RND function needs a value greater than zero to perform a random value\n");
								        accu[paccu-1]=0;
								     }
							     }
							     break;
				case E_COMPUTE_OPERATION_FRAC:if (paccu>0) accu[paccu-1]=((int)(accu[paccu-1]-(int)accu[paccu-1]));break;
				case E_COMPUTE_OPERATION_CEIL:if (paccu>0) accu[paccu-1]=(int)ceil(accu[paccu-1])&workinterval;break;
				case E_COMPUTE_OPERATION_GET_R:if (paccu>0) accu[paccu-1]=((((int)accu[paccu-1])&0xF0)>>4);break;
				case E_COMPUTE_OPERATION_GET_V:if (paccu>0) accu[paccu-1]=((((int)accu[paccu-1])&0xF00)>>8);break;
				case E_COMPUTE_OPERATION_GET_B:if (paccu>0) accu[paccu-1]=(((int)accu[paccu-1])&0xF);break;
				case E_COMPUTE_OPERATION_SET_R:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15)<<4;break;
				case E_COMPUTE_OPERATION_SET_V:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15)<<8;break;
				case E_COMPUTE_OPERATION_SET_B:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15);break;
				case E_COMPUTE_OPERATION_SOFT2HARD:if (paccu>0) accu[paccu-1]=__Soft2HardInk(ae,accu[paccu-1],didx);break;
				case E_COMPUTE_OPERATION_HARD2SOFT:if (paccu>0) accu[paccu-1]=__Hard2SoftInk(ae,accu[paccu-1],didx);break;
				/* functions with strings */
				case E_COMPUTE_OPERATION_GETNOP:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__GETNOP(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP is empty\n");
								}
							       break;
							       /* CC GETNOP */
				case E_COMPUTE_OPERATION_GETTICK:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__GETTICK(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK is empty\n");
								}
							       break;
							       /* CC GETNOP */
				case E_COMPUTE_OPERATION_DURATION:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__DURATION(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION is empty\n");
								}
							       break;
				default:MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"invalid computing state! (%d)\n",computestack[i].operator);paccu=0;
			}
			if (!paccu) {
				if (zeexpression[0]=='&') {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operand for calculation [%s] Did you use & for an hexadecimal value?\n",TradExpression(zeexpression));
				} else {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operand for calculation [%s]\n",TradExpression(zeexpression));
				}
				accu_err=1;
				break;
			}
		}
	} else {
		for (i=0;i<nbcomputestack;i++) {
#if 0
			int kk;
			for (kk=0;kk<paccu;kk++) printf("stack[%d]=%lf\n",kk,accu[kk]);
			if (computestack[i].operator==E_COMPUTE_OPERATION_PUSH_DATASTC) {
				printf("pacc=%d push %.1lf or %s\n",paccu,computestack[i].value,computestack[i].string?computestack[i].string:"null");
			} else {
				printf("pacc=%d operation %s p=%d\n",paccu,computestack[i].operator==E_COMPUTE_OPERATION_MUL?"*":
								computestack[i].operator==E_COMPUTE_OPERATION_ADD?"+":
								computestack[i].operator==E_COMPUTE_OPERATION_DIV?"/":
								computestack[i].operator==E_COMPUTE_OPERATION_SUB?"-":
								computestack[i].operator==E_COMPUTE_OPERATION_BAND?"&&":
								computestack[i].operator==E_COMPUTE_OPERATION_BOR?"||":
								computestack[i].operator==E_COMPUTE_OPERATION_SHL?"<<":
								computestack[i].operator==E_COMPUTE_OPERATION_SHR?">>":
								computestack[i].operator==E_COMPUTE_OPERATION_LOWER?"<":
								computestack[i].operator==E_COMPUTE_OPERATION_GREATER?">":
								computestack[i].operator==E_COMPUTE_OPERATION_EQUAL?"==":
								computestack[i].operator==E_COMPUTE_OPERATION_INT?"INT":
								computestack[i].operator==E_COMPUTE_OPERATION_LOWEREQ?"<=":
								computestack[i].operator==E_COMPUTE_OPERATION_GREATEREQ?">=":
								computestack[i].operator==E_COMPUTE_OPERATION_OPEN?"(":
								computestack[i].operator==E_COMPUTE_OPERATION_CLOSE?")":
								computestack[i].operator==E_COMPUTE_OPERATION_GETNOP?"getnpo":
								"<autre>",computestack[i].priority);
			}
#endif
			switch (computestack[i].operator) {
				case E_COMPUTE_OPERATION_PUSH_DATASTC:
					if (maccu<=paccu) {
						maccu=16+paccu;
						accu=MemRealloc(accu,sizeof(double)*maccu);
					}
					if (computestack[i].string) {
						/* string hack */
						accu[paccu]=i+0.1;
					} else {
						accu[paccu]=computestack[i].value;
					}
					paccu++;
					break;
				case E_COMPUTE_OPERATION_OPEN:
				case E_COMPUTE_OPERATION_CLOSE: /* cannot happend */ break;
				case E_COMPUTE_OPERATION_ADD:if (paccu>1) accu[paccu-2]+=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_SUB:if (paccu>1) accu[paccu-2]-=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_MUL:if (paccu>1) accu[paccu-2]*=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_DIV:if (paccu>1) accu[paccu-2]/=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_ZAND:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))&((int)floor(accu[paccu-1]+0.5));paccu--;break;
				case E_COMPUTE_OPERATION_OR:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))|((int)floor(accu[paccu-1]+0.5));paccu--;break;
				case E_COMPUTE_OPERATION_XOR:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))^((int)floor(accu[paccu-1]+0.5));paccu--;break;
				case E_COMPUTE_OPERATION_NOT:/* half operator, half function */ if (paccu>0) accu[paccu-1]=!((int)floor(accu[paccu-1]+0.5));break;
				case E_COMPUTE_OPERATION_MOD:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))%((int)floor(accu[paccu-1]+0.5));paccu--;break;
				case E_COMPUTE_OPERATION_SHL:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))<<((int)floor(accu[paccu-1]+0.5));
								if (((int)accu[paccu-1])>31 || ((int)accu[paccu-1])<-31) {
									if (!ae->nowarning) {
										rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)accu[paccu-1]);
															if (ae->erronwarn) MaxError(ae);
									}
									accu[paccu-2]=0;
								}
								paccu--;break;
				case E_COMPUTE_OPERATION_SHR:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))>>((int)floor(accu[paccu-1]+0.5));
								if (((int)accu[paccu-1])>31 || ((int)accu[paccu-1])<-31) {
									if (!ae->nowarning) {
										rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)accu[paccu-1]);
															if (ae->erronwarn) MaxError(ae);
									}
									accu[paccu-2]=0;
								}
								paccu--;break;
				case E_COMPUTE_OPERATION_BAND:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))&&((int)floor(accu[paccu-1]+0.5));paccu--;break;
				case E_COMPUTE_OPERATION_BOR:if (paccu>1) accu[paccu-2]=((int)floor(accu[paccu-2]+0.5))||((int)floor(accu[paccu-1]+0.5));paccu--;break;
				/* comparison */
				case E_COMPUTE_OPERATION_LOWER:if (paccu>1) accu[paccu-2]=accu[paccu-2]<accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_LOWEREQ:if (paccu>1) accu[paccu-2]=accu[paccu-2]<=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_EQUAL:if (paccu>1) accu[paccu-2]=fabs(accu[paccu-2]-accu[paccu-1])<0.000001;paccu--;break;
				case E_COMPUTE_OPERATION_NOTEQUAL:if (paccu>1) accu[paccu-2]=accu[paccu-2]!=accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_GREATER:if (paccu>1) accu[paccu-2]=accu[paccu-2]>accu[paccu-1];paccu--;break;
				case E_COMPUTE_OPERATION_GREATEREQ:if (paccu>1) accu[paccu-2]=accu[paccu-2]>=accu[paccu-1];paccu--;break;
				/* functions */
				case E_COMPUTE_OPERATION_SIN:if (paccu>0) accu[paccu-1]=sin(accu[paccu-1]*3.1415926545/180.0);break;
				case E_COMPUTE_OPERATION_COS:if (paccu>0) accu[paccu-1]=cos(accu[paccu-1]*3.1415926545/180.0);break;
				case E_COMPUTE_OPERATION_ASIN:if (paccu>0) accu[paccu-1]=asin(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_ACOS:if (paccu>0) accu[paccu-1]=acos(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_ATAN:if (paccu>0) accu[paccu-1]=atan(accu[paccu-1])*180.0/3.1415926545;break;
				case E_COMPUTE_OPERATION_INT:if (paccu>0) accu[paccu-1]=floor(accu[paccu-1]+0.5);break;
				case E_COMPUTE_OPERATION_FLOOR:if (paccu>0) accu[paccu-1]=floor(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_ABS:if (paccu>0) accu[paccu-1]=fabs(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_EXP:if (paccu>0) accu[paccu-1]=exp(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_LN:if (paccu>0) accu[paccu-1]=log(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_LOG10:if (paccu>0) accu[paccu-1]=log10(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_SQRT:if (paccu>0) accu[paccu-1]=sqrt(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_LOW:if (paccu>0) accu[paccu-1]=((int)floor(accu[paccu-1]+0.5))&0xFF;break;
				case E_COMPUTE_OPERATION_HIGH:if (paccu>0) accu[paccu-1]=(((int)floor(accu[paccu-1]+0.5))&0xFF00)>>8;break;
				case E_COMPUTE_OPERATION_PSG:if (paccu>0) accu[paccu-1]=ae->psgfine[((int)floor(accu[paccu-1]+0.5))&0xFF];break;
				case E_COMPUTE_OPERATION_RND:if (paccu>0) {
								     int zemod;
								     zemod=(int)floor(accu[paccu-1]+0.5);
								     if (zemod>0) {
									     accu[paccu-1]=FastRand()%zemod;
								     } else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"RND function needs a value greater than zero to perform a random value\n");
								        accu[paccu-1]=0;
								     }
							     }
							     break;
				case E_COMPUTE_OPERATION_FRAC:if (paccu>0) accu[paccu-1]=modf(accu[paccu-1],&dummint);break;
				case E_COMPUTE_OPERATION_CEIL:if (paccu>0) accu[paccu-1]=ceil(accu[paccu-1]);break;
				case E_COMPUTE_OPERATION_GET_R:if (paccu>0) accu[paccu-1]=((((int)accu[paccu-1])&0xF0)>>4);break;
				case E_COMPUTE_OPERATION_GET_V:if (paccu>0) accu[paccu-1]=((((int)accu[paccu-1])&0xF00)>>8);break;
				case E_COMPUTE_OPERATION_GET_B:if (paccu>0) accu[paccu-1]=(((int)accu[paccu-1])&0xF);break;
				case E_COMPUTE_OPERATION_SET_R:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15)<<4;break;
				case E_COMPUTE_OPERATION_SET_V:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15)<<8;break;
				case E_COMPUTE_OPERATION_SET_B:if (paccu>0) accu[paccu-1]=MinMaxInt(accu[paccu-1],0,15);break;
				case E_COMPUTE_OPERATION_SOFT2HARD:if (paccu>0) accu[paccu-1]=__Soft2HardInk(ae,accu[paccu-1],didx);break;
				case E_COMPUTE_OPERATION_HARD2SOFT:if (paccu>0) accu[paccu-1]=__Hard2SoftInk(ae,accu[paccu-1],didx);break;
				/* functions with strings */
				case E_COMPUTE_OPERATION_GETNOP:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__GETNOP(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETNOP is empty\n");
								}
							       break;
							       /* CC GETNOP */
				case E_COMPUTE_OPERATION_GETTICK:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__GETTICK(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"GETTICK is empty\n");
								}
							       break;
							       /* CC GETNOP */
				case E_COMPUTE_OPERATION_DURATION:if (paccu>0) {
								      int integeridx;
								      integeridx=floor(accu[paccu-1]);

								      if (integeridx>=0 && integeridx<nbcomputestack && computestack[integeridx].string) {
									      accu[paccu-1]=__DURATION(ae,computestack[integeridx].string,didx);
									      MemFree(computestack[integeridx].string);
									      computestack[integeridx].string=NULL;
								      } else {
									      if (integeridx>=0 && integeridx<nbcomputestack) {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION function needs a proper string\n");
										} else {
											MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION internal error (wrong string index)\n");
										}
									}
								} else {
									MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"DURATION is empty\n");
								}
							       break;

				default:MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"invalid computing state! (%d)\n",computestack[i].operator);paccu=0;
			}
			if (!paccu) {
				if (zeexpression[0]=='&') {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operand for calculation [%s] Did you use & for an hexadecimal value?\n",TradExpression(zeexpression));
				} else {
					MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operand for calculation [%s]\n",TradExpression(zeexpression));
				}
				accu_err=1;
				break;
			}
		}
	}
	if (!original) {
		MemFree(zeexpression);
	}
	if (paccu==1) {
		return accu[0];
	} else if (!accu_err) {
		if (paccu) {
			MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operator\n");
		} else {
			MakeError(ae,GetExpFile(ae,didx),GetExpLine(ae,didx),"Missing operand for calculation\n");
		}
		return 0;
	} else {
		return 0;
	}
}
int RoundComputeExpressionCore(struct s_assenv *ae,char *zeexpression,int ptr,int didx) {
	return floor(ComputeExpressionCore(ae,zeexpression,ptr,didx)+ae->rough);
}

void ExpressionSetDicoVar(struct s_assenv *ae,char *name, double v)
{
	#undef FUNC
	#define FUNC "ExpressionSetDicoVar"

	struct s_expr_dico curdic;
	curdic.name=TxtStrDup(name);
	curdic.crc=GetCRC(name);
	curdic.v=v;
	curdic.iw=ae->idx;
	curdic.autorise_export=ae->autorise_export;
	//ObjectArrayAddDynamicValueConcat((void**)&ae->dico,&ae->idic,&ae->mdic,&curdic,sizeof(curdic));
	if (SearchLabel(ae,curdic.name,curdic.crc)) {
		MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"cannot create variable [%s] as there is already a label with the same name\n",name);
		MemFree(curdic.name);
		return;
	}
	InsertDicoToTree(ae,&curdic);
}

double ComputeExpression(struct s_assenv *ae,char *expr, int ptr, int didx, int expected_eval)
{
	#undef FUNC
	#define FUNC "ComputeExpression"

	char *ptr_exp,*ptr_exp2;
	int crc,idx=0,ialias,touched;
	double v;
	struct s_alias curalias;
	struct s_expr_dico *curdic;


	while (!ae->AutomateExpressionDecision[((int)expr[idx])&0xFF]) idx++;

	switch (ae->AutomateExpressionDecision[((int)expr[idx])&0xFF]) {
		/*****************************************
		          M A K E     A L I A S
		*****************************************/
		case '~':
			memset(&curalias,0,sizeof(curalias));
			ptr_exp=expr+idx;
			*ptr_exp=0; // on scinde l'alias de son texte
			ptr_exp2=ptr_exp+1;
#if TRACE_COMPUTE_EXPRESSION
printf("MakeAlias (1) EXPR=[%s EQU %s]\n",expr,ptr_exp2);
#endif
			
			/* alias locaux ou de proximité */
			if (strchr("@.",expr[0])) {
#if TRACE_COMPUTE_EXPRESSION
printf("WARNING! alias is local! [%s]\n",expr);
#endif
				/* local label creation does not handle formula in tags */
				curalias.alias=TranslateTag(ae,TxtStrDup(expr),&touched,0,E_TAGOPTION_NONE);
				curalias.alias=MakeLocalLabel(ae,curalias.alias,NULL);
			} else if (strchr(expr,'{')) {
#if TRACE_COMPUTE_EXPRESSION
printf("WARNING! alias has tag! [%s]\n",expr);
#endif
				/* alias name contains formula */
				curalias.alias=TranslateTag(ae,TxtStrDup(expr),&touched,0,E_TAGOPTION_NONE);
#if TRACE_COMPUTE_EXPRESSION
printf("MakeAlias (2) EXPR=[%s EQU %s]\n",expr,ptr_exp2);
#endif
			} else {
				curalias.alias=TxtStrDup(expr);
			}
			curalias.crc=GetCRC(curalias.alias);
			if ((ialias=SearchAlias(ae,curalias.crc,curalias.alias))>=0) {
				MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Duplicate alias [%s]\n",expr);
				MemFree(curalias.alias);
			} else if (SearchDico(ae,curalias.alias,curalias.crc)) {
				MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Alias cannot override existing variable [%s]\n",expr);
				MemFree(curalias.alias);
			} else {
				curalias.translation=MemMalloc(strlen(ptr_exp2)+1+2);
				sprintf(curalias.translation,"(%s)",ptr_exp2);
#if TRACE_COMPUTE_EXPRESSION
printf("MakeAlias (3) EXPR=[%s EQU %s]\n",expr,ptr_exp2);
printf("alias translation [%s] -> ",curalias.translation);fflush(stdout);
#endif
				ExpressionFastTranslate(ae,&curalias.translation,2); // FAST type 2
#if TRACE_COMPUTE_EXPRESSION
printf("%s\n",curalias.translation);
#endif
				curalias.len=strlen(curalias.translation);
				curalias.autorise_export=ae->autorise_export;
				curalias.iw=ae->idx;
				ObjectArrayAddDynamicValueConcat((void**)&ae->alias,&ae->ialias,&ae->malias,&curalias,sizeof(curalias));
				CheckAndSortAliases(ae);
			}
			*ptr_exp='~'; // on remet l'alias en place
#if TRACE_COMPUTE_EXPRESSION
printf("MakeAlias end with alias=[%s]=[%s]\n",curalias.alias,curalias.translation);
printf("***********\n");
#endif
			return 0;
		/*****************************************
		               S E T     V A R
		*****************************************/
		case '=':
			/* patch NOT 
			 this is a variable assign if there is no other comparison operator after '='
			 BUT we may have ! which stand for NOT but is also a comparison operator...
			*/
			if (ae->AutomateExpressionDecision[((int)expr[idx+1])&0xFF]==0 || expr[idx+1]=='!') {
				if (expected_eval) {
					if (ae->maxam) {
						/* maxam mode AND expected a value -> force comparison */
					} else {
						/* use of a single '=' but expected a comparison anyway */
						MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"meaningless use of an expression [%s]\n",expr);
						return 0;
					}
				} else {
					/* ASSIGN */
					if ((expr[0]<'A' || expr[0]>'Z') && expr[0]!='_') {
						MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"variable name must begin by a letter or '_' [%s]\n",expr);
						return 0;
					} else {
						char operatorassignment;

						ptr_exp=expr+idx;
						v=ComputeExpressionCore(ae,ptr_exp+1,ptr,didx);
						*ptr_exp=0;
						/* patch operator+assign value */
						switch (ptr_exp[-1]) {
							case '+':
							case '-':
							case '*':
							case '/':
							case '^':
							case '&':
							case '|':
							case '%':
							case ']':
							case '[':
								operatorassignment=ptr_exp[-1];ptr_exp[-1]=0;break;
							default:operatorassignment=0;break;
						}

						crc=GetCRC(expr);
						if ((ialias=SearchAlias(ae,crc,expr))>=0) {
							MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Variable cannot override existing alias [%s]\n",expr);
							return 0;
						}
#if TRACE_ASSEMBLE
	printf("try to set [%s] with %lf operatorassignment=%c\n",expr,v,operatorassignment);
#endif
						curdic=SearchDico(ae,expr,crc);
						if (curdic) {
							switch (operatorassignment) {
								default:printf("warning remover\n");break;
								case 0:curdic->v=v;break;
								case '+':curdic->v+=v;ptr_exp[-1]='+';break;
								case '-':curdic->v-=v;ptr_exp[-1]='-';break;
								case '*':curdic->v*=v;ptr_exp[-1]='*';break;
								case '/':curdic->v/=v;ptr_exp[-1]='/';break;
								/* bit operations */
								case '|':curdic->v=((int)curdic->v)|((int)v);ptr_exp[-1]='|';break;
								case '&':curdic->v=((int)curdic->v)&((int)v);ptr_exp[-1]='&';break;
								case '^':curdic->v=((int)curdic->v)^((int)v);ptr_exp[-1]='^';break;
								case '%':curdic->v=((int)curdic->v)%((int)v);ptr_exp[-1]='%';break;
								case ']':curdic->v=((int)curdic->v)>>((int)v);ptr_exp[-1]=']';
									 if (v>31 || v<-31) {
										if (!ae->nowarning) {
                                                                			rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)v);
															if (ae->erronwarn) MaxError(ae);
										}
										curdic->v=0;
									 }
									 break;
								case '[':curdic->v=((int)curdic->v)<<((int)v);ptr_exp[-1]='[';
									 if (v>31 || v<-31) {
										if (!ae->nowarning) {
                                                                			rasm_printf(ae,KWARNING"Warning - shifting %d is architecture dependant, result forced to ZERO\n",(int)v);
															if (ae->erronwarn) MaxError(ae);
										}
										curdic->v=0;
									 }
									 break;
							}
						} else {
							switch (operatorassignment) {
								default: /* cannot do operator on non existing variable */
									MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Cannot do an operator assignment on non existing variable [%s]\n",expr);
									return 0;
								case 0: /* assign a new variable */
									ExpressionSetDicoVar(ae,expr,v);
									break;
							}
						}
						*ptr_exp='=';
						return v;
					}
				}
			}
			break;
		/*****************************************
		     P U R E    E X P R E S S I O N
		*****************************************/
		default:break;
	}
#if TRACE_ASSEMBLE
printf("pure expression to compute [%s]\n",expr);
#endif
	return ComputeExpressionCore(ae,expr,ptr,didx);
}
int RoundComputeExpression(struct s_assenv *ae,char *expr, int ptr, int didx, int expression_expected) {
	return floor(ComputeExpression(ae,expr,ptr,didx,expression_expected)+ae->rough);
}

/*
	ExpressionFastTranslate
	
	purpose: translate all known symbols in an expression (especially variables acting like counters)

0:
1:
2: (equ declaration)
*/
void ExpressionFastTranslate(struct s_assenv *ae, char **ptr_expr, int fullreplace)
{
	#undef FUNC
	#define FUNC "ExpressionFastTranslate"

	struct s_label *curlabel;
	struct s_expr_dico *curdic;
	static char *varbuffer=NULL;
	static int ivar,maxivar=1;
	char curval[256]={0};
	int c,lenw=0,idx=0,crc,startvar=0,newlen,ialias,found_replace,yves,dek,reidx,lenbuf,rlen,tagoffset;
	double v;
	char tmpuchar[16];
	char *expr,*locallabel;
	int curly=0,curlyflag=0;
	char *Automate;
	int recurse=-1,recursecount=0;
	
	if (!ae || !ptr_expr) {
		if (varbuffer) MemFree(varbuffer);
		varbuffer=NULL;
		maxivar=1;
		ivar=0;
		return;
	}
	/* be sure to have at least some bytes allocated */
	StateMachineResizeBuffer(&varbuffer,128,&maxivar);
	expr=*ptr_expr;

	ivar=0;

//printf("fast [%s]\n",expr);

	while (!ae->AutomateExpressionDecision[((int)expr[idx])&0xFF]) idx++;

	switch (ae->maxam) {
		default:
		case 0: /* full check */
			if (expr[idx]=='~' || (expr[idx]=='=' && expr[idx+1]!='=')) {reidx=idx+1;break;}
			reidx=0;
			break;
		case 1: /* partial check with maxam */
			if (expr[idx]=='~') {reidx=idx+1;break;}
			reidx=0;
			break;
	}

	idx=0;
	/* is there ascii char? */
	while ((c=expr[idx])!=0) {
		if (c=='\'' || c=='"') {
			/* one char escape code */
			if (expr[idx+1]=='\\') {
				if (expr[idx+2] && expr[idx+3]==c) {
					/* no charset conversion for escaped chars */
					c=expr[idx+2];
					switch (c) {
						case 'b':c='\b';break;
						case 'v':c='\v';break;
						case 'f':c='\f';break;
						case '0':c='\0';break;
						case 'r':c='\r';break;
						case 'n':c='\n';break;
						case 't':c='\t';break;
						default:break;
					}
					sprintf(tmpuchar,"#%03X",c);
					memcpy(expr+idx,tmpuchar,4);
					idx+=3;
				} else {
					MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] - Only single escaped char may be quoted\n",expr);
					expr[0]=0;
					return;
				}
			} else if (expr[idx+1] && expr[idx+2]==c) {
					sprintf(tmpuchar,"#%02X",ae->charset[(int)expr[idx+1]]);
					memcpy(expr+idx,tmpuchar,3);
					idx+=2;
			} else {
				//printf("FAST => moar than one quoted char\n");
				//MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] - Only single char may be quoted\n",expr);
				//expr[0]=0;
				//return;
				idx++;
				while (expr[idx] && expr[idx]!=c) idx++;
			}
		}
		idx++;
	}
	
	idx=reidx;
	while ((c=expr[idx])!=0) {
		switch (c) {
			/* string in expression */
			case '"':
			case '\'':
				//printf("FAST => skip string [%s]\n",expr);
				idx++;
				while (expr[idx] && expr[idx]!=c) idx++;
				if (expr[idx]) idx++;
				ivar=0;
				break;
			/* operator / parenthesis */
			case '!':
			case '=':
			case '>':
			case '<':
			case '(':
			case ')':
			case ']':
			case '[':
			case '*':
			case '/':
			case '+':
			case '~':
			case '-':
			case '^':
			case 'm':
			case '|':
			case '&':
				idx++;
				break;
			default:
				startvar=idx;
				if (ae->AutomateExpressionValidCharFirst[((int)c)&0xFF]) {
					varbuffer[ivar++]=c;
					if (c=='{') {
						/* this is only tag and not a formula */
						curly++;
					}
					StateMachineResizeBuffer(&varbuffer,ivar,&maxivar);
					idx++;
					c=expr[idx];

					Automate=ae->AutomateExpressionValidChar;
					while (Automate[((int)c)&0xFF]) {
						if (c=='{') {
							curly++;
							curlyflag=1;					
							Automate=ae->AutomateExpressionValidCharExtended;
						} else if (c=='}') {
							curly--;
							if (!curly) {
								Automate=ae->AutomateExpressionValidChar;
							}
						}
						varbuffer[ivar++]=c;
						StateMachineResizeBuffer(&varbuffer,ivar,&maxivar);
						idx++;
						c=expr[idx];
					}
				}
				varbuffer[ivar]=0;
				if (!ivar) {
					MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"invalid expression [%s] c=[%c] idx=%d\n",expr,c,idx);
					return;
				} else if (curly) {
					MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"wrong curly brackets in expression [%s]\n",expr);
					return;
				}
		}
		if (ivar && (varbuffer[0]<'0' || varbuffer[0]>'9')) {
			/* numbering var or label */
			if (curlyflag) {
				char *minivarbuffer;
				int touched;
//printf("ExpressionFastTranslate curly\n");
				minivarbuffer=TranslateTag(ae,TxtStrDup(varbuffer), &touched,0,E_TAGOPTION_NONE|(fullreplace?0:E_TAGOPTION_PRESERVE));
				StateMachineResizeBuffer(&varbuffer,strlen(minivarbuffer)+1,&maxivar);
				strcpy(varbuffer,minivarbuffer);
				newlen=strlen(varbuffer);
				lenw=strlen(expr);
				/* must update source */
				if (newlen>ivar) {
					/* realloc bigger */
					expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
				}
				if (newlen!=ivar ) {
					lenw=strlen(expr);
					MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
				}
				strncpy(expr+startvar,minivarbuffer,newlen); /* copy without zero terminator */
				idx=startvar+newlen;
				/***/
				MemFree(minivarbuffer);
				curlyflag=0;
				/******* ivar must be updated in case of label or alias following ***********/
				ivar=newlen;
			}
			
			/* recherche dans dictionnaire et remplacement */
			crc=GetCRC(varbuffer);
			found_replace=0;
			/* pour les affectations ou les tests conditionnels on ne remplace pas le dico (pour le Push oui par contre!) */
			if (fullreplace) {
//printf("ExpressionFastTranslate (full) => varbuffer=[%s] lz=%d\n",varbuffer,ae->lz);
				if (varbuffer[0]=='$' && !varbuffer[1]) {
					if (ae->lz==-1) {
						#ifdef OS_WIN
						snprintf(curval,sizeof(curval)-1,"%d",ae->codeadr);
						newlen=strlen(curval);
						#else
						newlen=snprintf(curval,sizeof(curval)-1,"%d",ae->codeadr);
						#endif
						lenw=strlen(expr);
						if (newlen>ivar) {
							/* realloc bigger */
							expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
						}
						if (newlen!=ivar ) {
							MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
							found_replace=1;
						}
						strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
						idx=startvar+newlen;
						ivar=0;
					}
					/* qu'on le remplace ou pas on passe a la suite */
					found_replace=1;
				} else {
					curdic=SearchDico(ae,varbuffer,crc);
					if (curdic) {
						v=curdic->v;
//printf("ExpressionFastTranslate (full) -> replace var (%s=%0.1lf)\n",varbuffer,v);

						#ifdef OS_WIN
						snprintf(curval,sizeof(curval)-1,"%lf",v);
						newlen=TrimFloatingPointString(curval);
						#else
						snprintf(curval,sizeof(curval)-1,"%lf",v);
						newlen=TrimFloatingPointString(curval);
						#endif
						lenw=strlen(expr);
						if (newlen>ivar) {
							/* realloc bigger */
							expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
						}
						if (newlen!=ivar ) {
							MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
						}
						strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
						idx=startvar+newlen;
						ivar=0;
						found_replace=1;
					}
				}
			}
			/* on cherche aussi dans les labels existants => priorité aux modules!!! */   // modulmodif => pas utile?
			if (!found_replace) {
				curlabel=SearchLabel(ae,varbuffer,crc);
				if (curlabel) {
					if (!curlabel->lz || ae->stage>1) {
						yves=curlabel->ptr;

						#ifdef OS_WIN
						snprintf(curval,sizeof(curval)-1,"%d",yves);
						newlen=strlen(curval);
						#else
						newlen=snprintf(curval,sizeof(curval)-1,"%d",yves);
						#endif
						lenw=strlen(expr);
						if (newlen>ivar) {
							/* realloc bigger */
							expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
						}
						if (newlen!=ivar ) {
							MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
						}
						strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
						found_replace=1;
						idx=startvar+newlen;
						ivar=0;
					}
				}		
			}
			/* non trouve on cherche dans les alias */
			if (!found_replace) {
				if ((ialias=SearchAlias(ae,crc,varbuffer))>=0) {
					newlen=ae->alias[ialias].len;
					lenw=strlen(expr);
					/* infinite replacement check */
					if (recurse<=startvar) {
						/* recurse maximum count is a mix of alias len and alias number */
						if (recursecount>ae->ialias+ae->alias[ialias].len) {
							if (strchr(expr,'~')!=NULL) *strchr(expr,'~')=0;
							MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"alias definition of %s has infinite recursivity\n",expr);
							expr[0]=0; /* avoid some errors due to shitty definition */
							return;
						} else {
							recursecount++;
						}
					}
					if (newlen>ivar) {
						/* realloc bigger */
						expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
					}
					if (newlen!=ivar) {
						MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
					}
					strncpy(expr+startvar,ae->alias[ialias].translation,newlen); /* copy without zero terminator */
					found_replace=1;
					/* need to parse again alias because of delayed declarations */
					recurse=startvar;
					idx=startvar;
					ivar=0;
				} else {
				}
			}
			if (!found_replace) {
				//printf("fasttranslate test local label\n");
				/* non trouve c'est peut-etre un label local - mais pas de l'octal */
				if (varbuffer[0]=='@' && (varbuffer[1]<'0' || varbuffer[1]>'9')) {
					char *zepoint;
					lenbuf=strlen(varbuffer);
//printf("MakeLocalLabel(ae,varbuffer,&dek); (1)\n");
					locallabel=MakeLocalLabel(ae,varbuffer,&dek);
//printf("exprin =[%s]   rlen=%d dek-lenbuf=%d\n",expr,rlen,dek-lenbuf);
					/*** le grand remplacement ***/
					/* local to macro or loop */
					rlen=strlen(expr+startvar+lenbuf)+1;
					expr=*ptr_expr=MemRealloc(expr,strlen(expr)+dek+1);
					/* move end of expression in order to insert local ID */
					zepoint=strchr(varbuffer,'.');
					if (zepoint) {
						/* far proximity access */
						int suffixlen,dotpos;
						dotpos=(zepoint-varbuffer);
						suffixlen=lenbuf-dotpos;

						MemMove(expr+startvar+dotpos+dek,expr+startvar+dotpos,rlen+suffixlen);
						strncpy(expr+startvar+dotpos,locallabel,dek);
					} else {
						/* legacy */
						MemMove(expr+startvar+lenbuf+dek,expr+startvar+lenbuf,rlen);
						strncpy(expr+startvar+lenbuf,locallabel,dek);
					}
					idx+=dek;
					MemFree(locallabel);
					found_replace=1;
//printf("exprout=[%s]\n",expr);
				} else if (varbuffer[0]=='.' && (varbuffer[1]<'0' || varbuffer[1]>'9')) {
					/* proximity label */
					lenbuf=strlen(varbuffer);
//printf("MakeLocalLabel(ae,varbuffer,&dek); (2)\n");
					locallabel=MakeLocalLabel(ae,varbuffer,&dek);
					/*** le grand remplacement ***/
					rlen=strlen(expr+startvar+lenbuf)+1;
					dek=strlen(locallabel);
//printf("exprin =[%s]   rlen=%d dek-lenbuf=%d\n",expr,rlen,dek-lenbuf);
					expr=*ptr_expr=MemRealloc(expr,strlen(expr)+dek-lenbuf+1);
					MemMove(expr+startvar+dek,expr+startvar+lenbuf,rlen);
					strncpy(expr+startvar,locallabel,dek);
					idx+=dek-lenbuf;
					MemFree(locallabel);
//printf("exprout=[%s]\n",expr);

//@@TODO ajouter une recherche d'alias?

				} else if (varbuffer[0]=='{') {
					if (strncmp(varbuffer,"{BANK}",6)==0 || strncmp(varbuffer,"{PAGE}",6)==0 || strncmp(varbuffer,"{SLOT}",6)==0) tagoffset=6; else
					if (strncmp(varbuffer,"{PAGESET}",9)==0) tagoffset=9; else
					if (strncmp(varbuffer,"{SIZEOF}",8)==0) tagoffset=8; else
					{
						tagoffset=0;
						MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Unknown prefix tag\n");
					}
					
					if (varbuffer[tagoffset]=='@') {
						char *zepoint;
						startvar+=tagoffset;
						lenbuf=strlen(varbuffer+tagoffset);
//printf("MakeLocalLabel(ae,varbuffer,&dek); (3)\n");
						locallabel=MakeLocalLabel(ae,varbuffer+tagoffset,&dek);
						/*** le grand remplacement ***/
						rlen=strlen(expr+startvar+lenbuf)+1;
						expr=*ptr_expr=MemRealloc(expr,strlen(expr)+dek+1);
						/* move end of expression in order to insert local ID */
						zepoint=strchr(varbuffer,'.');
						if (zepoint) {
							/* far proximity access */
							int suffixlen,dotpos;
							dotpos=(zepoint-varbuffer);
							suffixlen=lenbuf-dotpos;

							MemMove(expr+startvar+dotpos+dek,expr+startvar+dotpos,rlen+suffixlen);
							strncpy(expr+startvar+dotpos,locallabel,dek);
						} else {
							/* legacy */
							MemMove(expr+startvar+lenbuf+dek,expr+startvar+lenbuf,rlen);
							strncpy(expr+startvar+lenbuf,locallabel,dek);
						}
						idx+=dek;
						MemFree(locallabel);
						found_replace=1;
					} else if (varbuffer[tagoffset]=='$') {
						int tagvalue=-1;
						/*
						 * There is no {SLOT}$ support...
						 */
						if (strcmp(varbuffer,"{BANK}$")==0) {
							if (ae->forcecpr) {
								if (ae->activebank<32) {
									tagvalue=ae->activebank;
								} else {
									MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] cannot use BANK $ in a temporary space!\n",TradExpression(expr));
									tagvalue=0;
								}
							} else if (ae->forcesnapshot) {
								if (ae->activebank<BANK_MAX_NUMBER) {
									/* on autorise le préfixe BANK en snapshot avec une subtilité */
								if (ae->bankset[ae->activebank>>2]) {
									tagvalue=ae->activebank+(ae->codeadr>>14); /* dans un bankset on tient compte de l'adresse */
								} else {
									tagvalue=ae->activebank;
								}
									
								} else {
									MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] cannot use BANK $ in a temporary space!\n",TradExpression(expr));
									tagvalue=0;
								}
							}
						} else if (strcmp(varbuffer,"{PAGE}$")==0) {
							if (ae->activebank<BANK_MAX_NUMBER) {
								if (ae->bankset[ae->activebank>>2]) {
									tagvalue=ae->bankgate[(ae->activebank&0x1FC)+(ae->codeadr>>14)];
								} else {
									tagvalue=ae->bankgate[ae->activebank];
								}
							} else {
								MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] cannot use PAGE $ in a temporary space!\n",TradExpression(expr));
								tagvalue=ae->activebank;
							}
						} else if (strcmp(varbuffer,"{PAGESET}$")==0) {
							if (ae->activebank<BANK_MAX_NUMBER) {
								tagvalue=ae->setgate[ae->activebank];
								//if (ae->activebank>3) tagvalue=((ae->activebank>>2)-1)*8+0xC2; else tagvalue=0xC0;
							} else {
								MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"expression [%s] cannot use PAGESET $ in a temporary space!\n",TradExpression(expr));
								tagvalue=ae->activebank;
							}
						}
						/* replace */
						#ifdef OS_WIN
						snprintf(curval,sizeof(curval)-1,"%d",tagvalue);
						newlen=strlen(curval);
						#else
						newlen=snprintf(curval,sizeof(curval)-1,"%d",tagvalue);
						#endif
						lenw=strlen(expr);
						if (newlen>ivar) {
							/* realloc bigger */
							expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
						}
						if (newlen!=ivar ) {
							MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
							found_replace=1;
						}
						strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
						idx=startvar+newlen;
						ivar=0;
						found_replace=1;
					}
				}
			}
			
			
			
			
			
			
			if (!found_replace && strcmp(varbuffer,"REPEAT_COUNTER")==0) {
				if (ae->ir) {
					yves=ae->repeat[ae->ir-1].repeat_counter;
					#ifdef OS_WIN
					snprintf(curval,sizeof(curval)-1,"%d",yves);
					newlen=strlen(curval);
					#else
					newlen=snprintf(curval,sizeof(curval)-1,"%d",yves);
					#endif
					lenw=strlen(expr);
					if (newlen>ivar) {
						/* realloc bigger */
						expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
					}
					if (newlen!=ivar ) {
						MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
						found_replace=1;
					}
					strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
					found_replace=1;
					idx=startvar+newlen;
					ivar=0;
				} else {
					MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"cannot use REPEAT_COUNTER outside repeat loop\n");
				}
			}
			if (!found_replace && strcmp(varbuffer,"WHILE_COUNTER")==0) {
				if (ae->iw) {
					yves=ae->whilewend[ae->iw-1].while_counter;
					#ifdef OS_WIN
					snprintf(curval,sizeof(curval)-1,"%d",yves);
					newlen=strlen(curval);
					#else
					newlen=snprintf(curval,sizeof(curval)-1,"%d",yves);
					#endif
					lenw=strlen(expr);
					if (newlen>ivar) {
						/* realloc bigger */
						expr=*ptr_expr=MemRealloc(expr,lenw+newlen-ivar+1);
					}
					if (newlen!=ivar ) {
						MemMove(expr+startvar+newlen,expr+startvar+ivar,lenw-startvar-ivar+1);
						found_replace=1;
					}
					strncpy(expr+startvar,curval,newlen); /* copy without zero terminator */
					found_replace=1;
					idx=startvar+newlen;
					ivar=0;
				} else {
					MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"cannot use WHILE_COUNTER outside repeat loop\n");
				}
			}
			/* unknown symbol -> add to used symbol pool */
			if (!found_replace) {
				InsertUsedToTree(ae,varbuffer,crc);
			}
		}
		ivar=0;
	}
}

void PushExpression(struct s_assenv *ae,int iw,enum e_expression zetype)
{
	#undef FUNC
	#define FUNC "PushExpression"
	
	struct s_expression curexp={0};
	int startptr=0;

	if (!ae->nocode) {
		curexp.iw=iw;
		curexp.wptr=ae->outputadr;
		curexp.zetype=zetype;
		curexp.ibank=ae->activebank;
		curexp.iorgzone=ae->io-1;
		curexp.lz=ae->lz;
		/* need the module to know where we are */
		if (ae->module) curexp.module=TxtStrDup(ae->module); else curexp.module=NULL;
		/* on traduit de suite les variables du dictionnaire pour les boucles et increments
			SAUF si c'est une affectation 
		*/
		if (!ae->wl[iw].e) {
			switch (zetype) {
				case E_EXPRESSION_V16C:
 					/* check non register usage */
					switch (GetCRC(ae->wl[iw].w)) {
						case CRC_IX:
						case CRC_IY:
						case CRC_MIX:
						case CRC_MIY:
							MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"invalid register usage\n",ae->maxptr);
						default:break;
					}
				case E_EXPRESSION_J8:
				case E_EXPRESSION_V8:
				case E_EXPRESSION_V16:
				case E_EXPRESSION_IM:startptr=-1;
							break;
				case E_EXPRESSION_IV8:
				case E_EXPRESSION_IV81:
				case E_EXPRESSION_IV16:startptr=-2;
							break;
				case E_EXPRESSION_3V8:startptr=-3;
							break;
				case E_EXPRESSION_RUN:
				case E_EXPRESSION_ZXRUN:
				case E_EXPRESSION_ZXSTACK:
				case E_EXPRESSION_BRS:break;
				default:break;
			}
			/* hack pourri pour gérer le $ */
			ae->codeadr+=startptr;
			/* ok mais les labels locaux des macros? */
			if (ae->ir || ae->iw || ae->imacro) {
				curexp.reference=TxtStrDup(ae->wl[iw].w);
				ExpressionFastTranslate(ae,&curexp.reference,1);
			} else {
				ExpressionFastTranslate(ae,&ae->wl[iw].w,1);
			}
			ae->codeadr-=startptr;
		}
		/* calcul adresse de reference et post-incrementation pour sauter les data */
		switch (zetype) {
			case E_EXPRESSION_J8:curexp.ptr=ae->codeadr-1;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_0V8:curexp.ptr=ae->codeadr;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_V8:curexp.ptr=ae->codeadr-1;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_0V16:curexp.ptr=ae->codeadr;ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_0V32:curexp.ptr=ae->codeadr;ae->outputadr+=4;ae->codeadr+=4;break;
			case E_EXPRESSION_0VR:curexp.ptr=ae->codeadr;ae->outputadr+=5;ae->codeadr+=5;break;
			case E_EXPRESSION_0VRMike:curexp.ptr=ae->codeadr;ae->outputadr+=5;ae->codeadr+=5;break;
			case E_EXPRESSION_V16C:
			case E_EXPRESSION_V16:curexp.ptr=ae->codeadr-1;ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_IV81:curexp.ptr=ae->codeadr-2;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IV8:curexp.ptr=ae->codeadr-2;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_3V8:curexp.ptr=ae->codeadr-3;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IV16:curexp.ptr=ae->codeadr-2;ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_RST:curexp.ptr=ae->codeadr;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IM:curexp.ptr=ae->codeadr-1;ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_RUN:break;
			case E_EXPRESSION_ZXRUN:break;
			case E_EXPRESSION_ZXSTACK:break;
			case E_EXPRESSION_BRS:curexp.ptr=ae->codeadr;break; // minimum syndical
			default:break;
		}
		/* le contrôle n'est pas bon avec les DEFB, DEFW, ...  -> @@TODO */
		if (ae->outputadr<=ae->maxptr) {
			ObjectArrayAddDynamicValueConcat((void **)&ae->expression,&ae->ie,&ae->me,&curexp,sizeof(curexp));
		} else {
			/* to avoid double error message */
			if (!ae->stop) MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"output exceed limit %d\n",ae->maxptr); else MaxError(ae);
			ae->stop=1;
			return;
		}
	} else {
		switch (zetype) {
			case E_EXPRESSION_J8:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_0V8:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_V8:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_0V16:ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_0V32:ae->outputadr+=4;ae->codeadr+=4;break;
			case E_EXPRESSION_0VR:ae->outputadr+=5;ae->codeadr+=5;break;
			case E_EXPRESSION_0VRMike:ae->outputadr+=5;ae->codeadr+=5;break;
			case E_EXPRESSION_V16C:
			case E_EXPRESSION_V16:ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_IV81:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IV8:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_3V8:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IV16:ae->outputadr+=2;ae->codeadr+=2;break;
			case E_EXPRESSION_RST:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_IM:ae->outputadr++;ae->codeadr++;break;
			case E_EXPRESSION_RUN:break;
			case E_EXPRESSION_ZXRUN:break;
			case E_EXPRESSION_ZXSTACK:break;
			case E_EXPRESSION_BRS:break;
		}
		if (ae->outputadr<=ae->maxptr) {
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NOCODE output exceed limit %d\n",ae->maxptr);
			FreeAssenv(ae);exit(3);
		}
	}
}

/*
The CP/M 2.2 directory has only one type of entry:

UU F1 F2 F3 F4 F5 F6 F7 F8 T1 T2 T3 EX S1 S2 RC   .FILENAMETYP....
AL AL AL AL AL AL AL AL AL AL AL AL AL AL AL AL   ................

UU = User number. 0-15 (on some systems, 0-31). The user number allows multiple
    files of the same name to coexist on the disc. 
     User number = 0E5h => File deleted
Fn - filename
Tn - filetype. The characters used for these are 7-bit ASCII.
       The top bit of T1 (often referred to as T1') is set if the file is 
     read-only.
       T2' is set if the file is a system file (this corresponds to "hidden" on 
     other systems). 
EX = Extent counter, low byte - takes values from 0-31
S2 = Extent counter, high byte.

      An extent is the portion of a file controlled by one directory entry.
    If a file takes up more blocks than can be listed in one directory entry,
    it is given multiple entries, distinguished by their EX and S2 bytes. The
    formula is: Entry number = ((32*S2)+EX) / (exm+1) where exm is the 
    extent mask value from the Disc Parameter Block.

S1 - reserved, set to 0.
RC - Number of records (1 record=128 bytes) used in this extent, low byte.
    The total number of records used in this extent is

    (EX & exm) * 128 + RC

    If RC is 80h, this extent is full and there may be another one on the disc.
    File lengths are only saved to the nearest 128 bytes.

AL - Allocation. Each AL is the number of a block on the disc. If an AL
    number is zero, that section of the file has no storage allocated to it
    (ie it does not exist). For example, a 3k file might have allocation 
    5,6,8,0,0.... - the first 1k is in block 5, the second in block 6, the 
    third in block 8.
     AL numbers can either be 8-bit (if there are fewer than 256 blocks on the
    disc) or 16-bit (stored low byte first). 
*/
int EDSK_getblockid(int *fb) {
	#undef FUNC
	#define FUNC "EDSK_getblockid"
	
	int i;
	for (i=0;i<180;i++) {
		if (fb[i]) {
			return i;
		}
	}
	return -1;
}
int EDSK_getdirid(struct s_edsk_wrapper *curwrap) {
	#undef FUNC
	#define FUNC "EDSK_getdirid"
	
	int ie;
	for (ie=0;ie<64;ie++) {
		if (curwrap->entry[ie].user==0xE5) {
#if TRACE_EDSK
	printf("getdirid returns %d\n",ie);
#endif
			return ie;
		}
	}
	return -1;
}
char *MakeAMSDOS_name(struct s_assenv *ae, char *reference_filename)
{
	#undef FUNC
	#define FUNC "MakeAMSDOS_name"

	static char amsdos_name[12];
	char *filename,*jo;
	int i,ia;
	char *pp;

	/* remove path */
	filename=reference_filename;
	while ((jo=strchr(filename,'/'))!=NULL) filename=jo+1;
	while ((jo=strchr(filename,'\\'))!=NULL) filename=jo+1;

	/* warning */
	if (strlen(filename)>12) {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"Warning - filename [%s] too long for AMSDOS, will be truncated\n",filename);
			if (ae->erronwarn) MaxError(ae);
		}
	} else if ((pp=strchr(filename,'.'))!=NULL) {
		if (pp-filename>8) {
			if (!ae->nowarning) {
				rasm_printf(ae,KWARNING"Warning - filename [%s] too long for AMSDOS, will be truncated\n",filename);
			if (ae->erronwarn) MaxError(ae);
			}
		}
	}
	/* copy filename */
	for (i=0;filename[i]!=0 && filename[i]!='.' && i<8;i++) {
		amsdos_name[i]=toupper(filename[i]);
	}
	/* fill with spaces */
	for (ia=i;ia<8;ia++) {
		amsdos_name[ia]=0x20;
	}
	/* looking for extension */
	for (;filename[i]!=0 && filename[i]!='.';i++);
	/* then copy it if any */
	if (filename[i]=='.') {
		i++;
		for (ia=0;filename[i]!=0 && ia<3;ia++) {
			amsdos_name[8+ia]=toupper(filename[i++]);
		}
	}
	amsdos_name[11]=0;
#if TRACE_EDSK
	printf("MakeAMSDOS_name [%s] -> [%s]\n",filename,amsdos_name);
#endif
	return amsdos_name;
}


void EDSK_load(struct s_assenv *ae,struct s_edsk_wrapper *curwrap, char *edskfilename, int face)
{
	#undef FUNC
	#define FUNC "EDSK_load"

	unsigned char header[256];
	unsigned char *data;
	int tracknumber,sidenumber,tracksize,disksize;
	int i,b,s,f,t,curtrack,sectornumber,sectorsize,sectorid,reallength;
	int currenttrackposition=0,currentsectorposition,tmpcurrentsectorposition;
	unsigned char checksectorid[9];
	int curblock=0,curoffset=0;
#if TRACE_EDSK
	printf("EDSK_Load('%s',%d);",edskfilename,face);
#endif
	if (FileReadBinary(edskfilename,(char*)&header,0x100)!=0x100) {
		rasm_printf(ae,KERROR"Cannot read EDSK header of [%s]!\n",edskfilename);
		FreeAssenv(ae);exit(ABORT_ERROR);
	}
	if (strncmp((char *)header,"MV - CPC",8)==0) {
		rasm_printf(ae,KAYGREEN"updating DSK to EDSK [%s] / creator: %s",edskfilename,header+34);
		
		tracknumber=header[34+14];
		sidenumber=header[34+14+1];
		tracksize=header[34+14+1+1]+header[34+14+1+1+1]*256;
		rasm_printf(ae,"tracks: %d  sides:%d   track size:%d",tracknumber,sidenumber,tracksize);
		if (tracknumber>40 || sidenumber>2) {
			rasm_printf(ae,KERROR"[%s] DSK format is not supported in update mode (ntrack=%d nside=%d)\n",edskfilename,tracknumber,sidenumber);
			FreeAssenv(ae);exit(ABORT_ERROR);
		}
		if (face>=sidenumber) {
			rasm_printf(ae,KWARNING"[%s] Warning - DSK has no face %d - DSK updated\n",edskfilename,face);
			if (ae->erronwarn) MaxError(ae);
			return;
		}

		data=MemMalloc(tracksize*tracknumber*sidenumber);
		memset(data,0,tracksize*tracknumber*sidenumber);
		if (FileReadBinary(edskfilename,(char *)data,tracksize*tracknumber*sidenumber)!=tracksize*tracknumber*sidenumber) {
			rasm_printf(ae,"Cannot read DSK tracks!");
			FreeAssenv(ae);exit(ABORT_ERROR);
		}
		//loginfo("track data read (%dkb)",tracksize*tracknumber*sidenumber/1024);
		f=face;
		for (t=0;t<tracknumber;t++) {
			curtrack=t*sidenumber+f;

			i=(t*sidenumber+f)*tracksize;
			if (strncmp((char *)data+i,"Track-Info\r\n",12)) {
				rasm_printf(ae,"Invalid track information block side %d track %d",f,t);
				FreeAssenv(ae);exit(ABORT_ERROR);
			}
			sectornumber=data[i+21];
			sectorsize=data[i+20];
			if (sectornumber!=9 || sectorsize!=2) {
				rasm_printf(ae,"Cannot read [%s] Invalid DATA format",edskfilename);
				FreeAssenv(ae);exit(ABORT_ERROR);
			}
			memset(checksectorid,0,sizeof(checksectorid));			
			/* we want DATA format */
			for (s=0;s<sectornumber;s++) {
				if (t!=data[i+24+8*s]) {
					rasm_printf(ae,"Invalid track number in sector %02X track %d",data[i+24+8*s+2],t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
				if (f!=data[i+24+8*s+1]) {
					rasm_printf(ae,"Invalid side number in sector %02X track %d",data[i+24+8*s+2],t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
				if (data[i+24+8*s+2]<0xC1 || data[i+24+8*s+2]>0xC9) {
					rasm_printf(ae,"Invalid sector ID in sector %02X track %d",data[i+24+8*s+2],t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				} else {
					checksectorid[data[i+24+8*s+2]-0xC1]=1;
				}				
				if (data[i+24+8*s+3]!=2) {
					rasm_printf(ae,"Invalid sector size in sector %02X track %d",data[i+24+8*s+2],t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
			}
			for (s=0;s<sectornumber;s++) {
				if (!checksectorid[s]) {
					rasm_printf(ae,"Missing sector %02X track %d",s+0xC1,t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
			}
			/* piste à piste on lit les blocs DANS L'ORDRE LOGIQUE!!! */
			for (b=0xC1;b<=0xC9;b++)
			for (s=0;s<sectornumber;s++) {
				if (data[i+24+8*s+2]==b) {
					memcpy(&curwrap->blocks[curblock][curoffset],&data[i+0x100+s*512],512);
					curoffset+=512;
					if (curoffset>=1024) {
						curoffset=0;
						curblock++;
					}
				}
			}
		}
	} else if (strncmp((char *)header,"EXTENDED",8)==0) {
		rasm_printf(ae,KAYGREEN"updating EDSK [%s] / creator: %-14.14s\n",edskfilename,header+34);
		tracknumber=header[34+14];
		sidenumber=header[34+14+1];
		// not in EDSK tracksize=header[34+14+1+1]+header[34+14+1+1+1]*256;
#if TRACE_EDSK
		loginfo("tracks: %d  sides:%d",tracknumber,sidenumber);
#endif

		if (sidenumber>2) {
			rasm_printf(ae,KERROR"[%s] EDSK format is not supported in update mode (ntrack=%d nside=%d)\n",edskfilename,tracknumber,sidenumber);
			FreeAssenv(ae);exit(ABORT_ERROR);
		}
		if (face>=sidenumber) {
			rasm_printf(ae,KWARNING"[%s] EDSK has no face %d - DSK updated\n",edskfilename,face);
			if (ae->erronwarn) MaxError(ae);
			return;
		}

		for (i=disksize=0;i<tracknumber*sidenumber;i++) disksize+=header[0x34+i]*256;
#if TRACE_EDSK
	loginfo("total track size: %dkb",disksize/1024);
#endif

		data=MemMalloc(disksize);
		memset(data,0,disksize);
		if (FileReadBinary(edskfilename,(char *)data,disksize)!=disksize) {
			rasm_printf(ae,KERROR"Cannot read DSK tracks!\n");
			FreeAssenv(ae);exit(ABORT_ERROR);
		}

		f=face;
		for (t=0;t<tracknumber && t<40;t++) {
			int track_sectorsize;

			curtrack=t*sidenumber+f;
			i=currenttrackposition;
			currentsectorposition=i+0x100;

			if (!header[0x34+curtrack] && t<40) {
				rasm_printf(ae,KERROR"Unexpected unformated track Side %d Track %02d\n",f,t);
			} else {
				currenttrackposition+=header[0x34+curtrack]*256;

				if (strncmp((char *)data+i,"Track-Info\r\n",12)) {
					rasm_printf(ae,KERROR"Invalid track information block side %d track %d\n",f,t);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
				sectornumber=data[i+21];
				track_sectorsize=data[i+20];
				if (sectornumber!=9) {
					rasm_printf(ae,KERROR"Unsupported track %d (sectornumber=%d sectorsize=%d)\n",t,sectornumber,sectorsize);
					FreeAssenv(ae);exit(ABORT_ERROR);
				}
				memset(checksectorid,0,sizeof(checksectorid));			
				/* we want DATA format */
				for (s=0;s<sectornumber;s++) {
					sectorid=data[i+24+8*s+2];
					if (sectorid>=0xC1 && sectorid<=0xC9) checksectorid[sectorid-0xC1]=1; else {
						rasm_printf(ae,KERROR"invalid sector id %02X for DATA track %d\n",sectorid,t);
						return;
					}
					sectorsize=data[i+24+8*s+3];
					if (sectorsize!=2) {
						rasm_printf(ae,KERROR"invalid sector size track %d\n",t);
						return;
					}
					reallength=data[i+24+8*s+6]+data[i+24+8*s+7]*256; /* real length stored */
					if (reallength!=512) {
						rasm_printf(ae,KERROR"invalid sector length %d for track %d\n",reallength,t);
						return;
					}
#if TRACE_EDSK
	printf("%02X ",sectorid);
#endif
				}
				if (track_sectorsize!=2) {
					rasm_printf(ae,KWARNING"track %02d has invalid sector size but sectors are OK\n",t);
			if (ae->erronwarn) MaxError(ae);
				}
#if TRACE_EDSK
	printf("\n");
#endif

				/* piste à piste on lit les blocs DANS L'ORDRE LOGIQUE!!! */
				for (b=0xC1;b<=0xC9;b++) {
					tmpcurrentsectorposition=currentsectorposition;
					for (s=0;s<sectornumber;s++) {
						if (b==data[i+24+8*s+2]) {
							memcpy(&curwrap->blocks[curblock][curoffset],&data[tmpcurrentsectorposition],512);
							curoffset+=512;
							if (curoffset>=1024) {
								curoffset=0;
								curblock++;
							}
						}
						reallength=data[i+24+8*s+6]+data[i+24+8*s+7]*256;
						tmpcurrentsectorposition+=reallength;
					}
				}
			}
		}
		
		
	} else {
		rasm_printf(ae,KERROR"file [%s] is not a valid (E)DSK floppy image\n",edskfilename);
		FreeAssenv(ae);exit(-923);
	}
	FileReadBinaryClose(edskfilename);
	
	/* Rasm management of (e)DSK files is AMSDOS compatible, just need to copy CATalog blocks but sort them... */
	memcpy(&curwrap->entry[0],curwrap->blocks[0],1024);
	memcpy(&curwrap->entry[32],curwrap->blocks[1],1024);
	/* tri des entrées selon le user */
	qsort(curwrap->entry,64,sizeof(struct s_edsk_wrapper_entry),cmpAmsdosentry);
	curwrap->nbentry=64;
	for (i=0;i<64;i++) {
		if (curwrap->entry[i].user==0xE5) {
			curwrap->nbentry=i;
			break;
		}
	}
#if TRACE_EDSK
	printf("%d entr%s found\n",curwrap->nbentry,curwrap->nbentry>1?"ies":"y");
	for (i=0;i<curwrap->nbentry;i++) {
		printf("[%02d] - ",i);
		if (curwrap->entry[i].user<16) {
			printf("U%02d [%-8.8s.%c%c%c] %c%c subcpt=#%02X rc=#%02X blocks=",curwrap->entry[i].user,curwrap->entry[i].filename,
			curwrap->entry[i].filename[8]&0x7F,curwrap->entry[i].filename[9]&0x7F,curwrap->entry[i].filename[10],
			curwrap->entry[i].filename[8]&0x80?'P':'-',curwrap->entry[i].filename[9]&0x80?'H':'-',
			curwrap->entry[i].subcpt,curwrap->entry[i].rc);
			for (b=0;b<16;b++) if (curwrap->entry[i].blocks[b]) printf("%s%02X",b>0?" ":"",curwrap->entry[i].blocks[b]); else printf("%s  ",b>0?" ":"");
			if (i&1) printf("\n"); else printf(" | ");
		} else {
			printf("free entry                  =    rc=    blocks=                                               ");
			if (i&1) printf("\n"); else printf(" | ");
		}
	}
	if (i&1) printf("\n");
#endif
}

struct s_edsk_wrapper *EDSK_select(struct s_assenv *ae,char *edskfilename, int facenumber)
{
	#undef FUNC
	#define FUNC "EDSK_select"
	
	struct s_edsk_wrapper newwrap={0},*curwrap=NULL;
	int i;
#if TRACE_EDSK
	printf("EDSK_select('%s',%d);\n",edskfilename,facenumber);
#endif
	/* check if there is a DSK in memory */
	for (i=0;i<ae->nbedskwrapper;i++) {
		if (!strcmp(ae->edsk_wrapper[i].edsk_filename,edskfilename)) {
#if TRACE_EDSK
	printf("Found! return %d\n",i);
#endif
			return &ae->edsk_wrapper[i];
		}
	}
	/* not in memory, create an empty struct */
	newwrap.edsk_filename=TxtStrDup(edskfilename);
	memset(newwrap.entry,0xE5,sizeof(struct s_edsk_wrapper_entry)*64);
	memset(newwrap.blocks[0],0xE5,1024);
	memset(newwrap.blocks[1],0xE5,1024);
#if TRACE_EDSK
	printf("Not found! create empty struct\n");
#endif
	newwrap.face=facenumber;
	ObjectArrayAddDynamicValueConcat((void**)&ae->edsk_wrapper,&ae->nbedskwrapper,&ae->maxedskwrapper,&newwrap,sizeof(struct s_edsk_wrapper));
	/* and load files if the DSK exists on disk */
	curwrap=&ae->edsk_wrapper[ae->nbedskwrapper-1];
	if (FileExists(edskfilename)) {
		EDSK_load(ae,curwrap,edskfilename,facenumber);
	}
	return curwrap;
}

int EDSK_addfile(struct s_assenv *ae,char *edskfilename,int facenumber, char *filename,unsigned char *indata,int insize, int offset, int run)
{
	#undef FUNC
	#define FUNC "EDSK_addfile"

	struct s_edsk_wrapper *curwrap=NULL;
	char amsdos_name[12]={0};
	int j,i,ia,ib,ie,filesize,idxdata;
	int fb[180],rc,idxb;
	unsigned char *data=NULL;
	int size=0;
	int firstblock;

	curwrap=EDSK_select(ae,edskfilename,facenumber);
	/* update struct */
	size=insize+128;
	data=MemMalloc(size);
	strcpy(amsdos_name,MakeAMSDOS_name(ae,filename));
	memcpy(data,MakeAMSDOSHeader(run,offset,offset+insize,amsdos_name),128);
	memcpy(data+128,indata,insize);
	/* overwrite check */
#if TRACE_EDSK
	printf("EDSK_addfile will checks %d entr%s for [%s]\n",curwrap->nbentry,curwrap->nbentry>1?"ies":"y",amsdos_name);
#endif
	for (i=0;i<curwrap->nbentry;i++) {
		if (!strncmp((char *)curwrap->entry[i].filename,amsdos_name,11)) {
			if (!ae->edskoverwrite) {
				MakeError(ae,NULL,0,"Error - Cannot save [%s] in edsk [%s] with overwrite disabled as the file already exists\n",amsdos_name,edskfilename);
				MemFree(data);
				return 0;
			} else {
				/* overwriting previous file */
#if TRACE_EDSK
	printf(" -> reset previous entry %d with 0xE5\n",i);
#endif
				memset(&curwrap->entry[i],0xE5,sizeof(struct s_edsk_wrapper_entry));
			}
		}
	}
	/* find free blocks */
#if TRACE_EDSK
	printf("EDSK_addfile find free blocks\n");
#endif
	fb[0]=fb[1]=0;
	for (i=2;i<180;i++) fb[i]=1;
	for (i=0;i<curwrap->nbentry;i++) {
		if (curwrap->entry[i].rc!=0xE5 && curwrap->entry[i].rc!=0) {
			/* entry found, compute number of blocks to read */
			rc=curwrap->entry[i].rc/8;
			if (curwrap->entry[i].rc%8) rc++; /* adjust value */
			/* mark as used */
			for (j=0;j<rc;j++) {
				fb[curwrap->entry[i].blocks[j]]=0;
			}
		}
	}
	/* set directory, blocks and data in blocks */
	firstblock=-1;
	filesize=size;
	idxdata=0;
	ia=0;

#if TRACE_EDSK
	printf("Writing [%s] size=%d\n",amsdos_name,size);
#endif

	while (filesize>0) {
		if (filesize>16384) {
			/* extended entry */
#if TRACE_EDSK
	printf("extended entry for file (filesize=%d)\nblocklist: ",filesize);
#endif
			if ((ie=EDSK_getdirid(curwrap))==-1)  {
				MakeError(ae,NULL,0,"Error - edsk [%s] DIRECTORY FULL\n",edskfilename);
				MemFree(data);
				return 0;
			}
			if (curwrap->nbentry<=ie) curwrap->nbentry=ie+1;
			idxb=0;
			for (i=0;i<16;i++) {
				if ((ib=EDSK_getblockid(fb))==-1) {
					MakeError(ae,NULL,0,"Error - edsk [%s] DISK FULL\n",edskfilename);
					MemFree(data);
					return 0;
				} else {
					if (firstblock==-1) firstblock=ib;

#if TRACE_EDSK
	printf("%02X ",ib);
#endif
					memcpy(curwrap->blocks[ib],data+idxdata,1024);
					idxdata+=1024;
					filesize-=1024;
					fb[ib]=0;
					curwrap->entry[ie].blocks[idxb++]=ib;
				}
			}
#if TRACE_EDSK
	printf("\n");
#endif
			memcpy(curwrap->entry[ie].filename,amsdos_name,11);
			curwrap->entry[ie].subcpt=ia;
			curwrap->entry[ie].rc=0x80;
			curwrap->entry[ie].user=0;
			ia++;
			idxb=0;
		} else {
			/* last entry */
#if TRACE_EDSK
	printf("last entry for file (filesize=%d)\nblocklist: ",filesize);
#endif
			if ((ie=EDSK_getdirid(curwrap))==-1)  {
				MakeError(ae,NULL,0,"Error - edsk [%s] DIRECTORY FULL\n",edskfilename);
				MemFree(data);
				return 0;
			}
			if (curwrap->nbentry<=ie) curwrap->nbentry=ie+1;
			/* calcul du nombre de sous blocs de 128 octets */
			curwrap->entry[ie].rc=filesize/128;
			if (filesize%128) {
				curwrap->entry[ie].rc+=1;
			}
			idxb=0;
			for (i=0;i<16 && filesize>0;i++) {
				if ((ib=EDSK_getblockid(fb))==-1) {
					MakeError(ae,NULL,0,"Error - edsk [%s] DISK FULL\n",edskfilename);
					MemFree(data);
					return 0;
				} else {
					if (firstblock==-1) firstblock=ib;
#if TRACE_EDSK
	printf("%02X ",ib);
#endif

					memcpy(curwrap->blocks[ib],&data[idxdata],filesize>1024?1024:filesize);
					idxdata+=1024;
					filesize-=1024;
					fb[ib]=0;
					curwrap->entry[ie].blocks[idxb++]=ib;
				}
			}
#if TRACE_EDSK
	printf("\n");
#endif
			filesize=0;
			memcpy(curwrap->entry[ie].filename,amsdos_name,11);
			curwrap->entry[ie].subcpt=ia;
			curwrap->entry[ie].user=0;
		}
	}

	MemFree(data);
	return 1;
}

void EDSK_build_amsdos_directory(struct s_edsk_wrapper *face)
{
	#undef FUNC
	#define FUNC "EDSK_build_amsdos_directory"
	
	unsigned char amsdosdir[2048]={0};
	int i,idx=0,b;

	if (!face) return;
	
#if TRACE_EDSK	
printf("build amsdos dir with %d entries\n",face->nbentry);	
#endif
	for (i=0;i<face->nbentry;i++) {
		if (face->entry[i].rc && face->entry[i].rc!=0xE5) {
			amsdosdir[idx]=face->entry[i].user;
			memcpy(amsdosdir+idx+1,face->entry[i].filename,11);
			amsdosdir[idx+12]=face->entry[i].subcpt;
			amsdosdir[idx+13]=0;
			amsdosdir[idx+14]=0;
			amsdosdir[idx+15]=face->entry[i].rc;
#if TRACE_EDSK	
printf("%-11.11s [%02X.%02X] blocks:",amsdosdir+idx+1,amsdosdir[idx+12],amsdosdir[idx+15]);
#endif
			for (b=0;b<16;b++) {
				if (face->entry[i].blocks[b]!=0xE5) {
					amsdosdir[idx+16+b]=face->entry[i].blocks[b];
#if TRACE_EDSK	
					printf("%s%02X",b>0?".":"",amsdosdir[idx+16+b]);
#endif
				} else {
					amsdosdir[idx+16+b]=0;
				}
			}
#if TRACE_EDSK	
printf("\n");
#endif
		}
		idx+=32;
	}
#if TRACE_EDSK	
printf("filling amsdos remaining entries (%d) with #E5\n",64-face->nbentry);
#endif
	memset(amsdosdir+idx,0xE5,32*(64-face->nbentry));

	/* AMSDOS directory copy to blocks! */
	memcpy(face->blocks[0],amsdosdir,1024);
	memcpy(face->blocks[1],amsdosdir+1024,1024);
}
void EDSK_write_file(struct s_assenv *ae,struct s_edsk_wrapper *faceA,struct s_edsk_wrapper *faceB)
{
	#undef FUNC
	#define FUNC "EDSK_write_file"

	struct s_edsk_wrapper emptyface={0};
	unsigned char header[256]={0};
	unsigned char trackblock[256]={0};
	unsigned char headertag[25];
	int idblock,blockoffset;
	int i,t;
	
	if (!faceA && !faceB) return;
	
	/* création des deux blocs du directory par face */
	EDSK_build_amsdos_directory(faceA);
	EDSK_build_amsdos_directory(faceB);
	/* écriture header */
	strcpy((char *)header,"EXTENDED CPC DSK File\r\nDisk-Info\r\n");
	sprintf(headertag,"%-9.9s",RASM_SNAP_VERSION);
	strcpy((char *)header+0x22,headertag);
	header[0x30]=40;
	if (!faceA) {
		faceA=&emptyface;
		faceA->edsk_filename=TxtStrDup(faceB->edsk_filename);
	}
#if TRACE_EDSK
	printf("deleting [%s]\n",faceA->edsk_filename);
#endif
	FileRemoveIfExists(faceA->edsk_filename);

	if (faceB!=NULL) header[0x31]=2; else header[0x31]=1;
	for (i=0;i<header[0x30]*header[0x31];i++) header[0x34+i]=19; /* tracksize=(9*512+256)/256 */
#if TRACE_EDSK
	printf("writing EDSK header (256b)\n");
#endif
	FileWriteBinary(faceA->edsk_filename,(char *)header,256);
	
	/* écriture des pistes */
	for (t=0;t<40;t++) {
		strcpy((char *)trackblock,"Track-Info\r\n");
		trackblock[0x10]=t;
		trackblock[0x11]=0;
		trackblock[0x14]=2;
		trackblock[0x15]=9;
		trackblock[0x16]=0x4E;
		trackblock[0x17]=0xE5;
		i=0;
		while (1) {
			trackblock[0x18+i*8+0]=trackblock[0x10];
			trackblock[0x18+i*8+1]=trackblock[0x11];
			trackblock[0x18+i*8+2]=(i>>1)+0xC1;
#if TRACE_EDSK
	if (t<3) printf("%02X ",trackblock[0x18+i*8+2]);
#endif
			trackblock[0x18+i*8+3]=2;
			trackblock[0x18+i*8+4]=0;
			trackblock[0x18+i*8+5]=0;
			trackblock[0x18+i*8+6]=0;
			trackblock[0x18+i*8+7]=2;
			i++;
			if (i==9) break;
			/* interleave */
			trackblock[0x18+i*8+0]=trackblock[0x10];
			trackblock[0x18+i*8+1]=trackblock[0x11];
			trackblock[0x18+i*8+2]=(i>>1)+0xC6; /* start at C6 */
#if TRACE_EDSK
	if (t<3) printf("%02X ",trackblock[0x18+i*8+2]);
#endif
			trackblock[0x18+i*8+3]=2;
			trackblock[0x18+i*8+4]=0;
			trackblock[0x18+i*8+5]=0;
			trackblock[0x18+i*8+6]=0;
			trackblock[0x18+i*8+7]=2;
			i++;
		}
#if TRACE_EDSK
	if (t<3) printf("\n"); else if (t==3) printf("...\n");
#endif
		/* écriture du track info */
		FileWriteBinary(faceA->edsk_filename,(char *)trackblock,256);


		/* il faut convertir les blocs logiques en secteurs physiques ET entrelacés */
		idblock=t*9/2;
		blockoffset=((t*9)%2)*512;

		/* le premier secteur de la piste est à cheval sur le bloc logique une fois sur deux */
		FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock][0]+blockoffset,512); /* C1 */
		if (!blockoffset) {
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+2][0]+512,512); /* C6 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+0][0]+512,512); /* C2 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+3][0]+0,512);   /* C7 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+1][0]+0,512);   /* C3 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+3][0]+512,512); /* C8 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+1][0]+512,512); /* C4 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+4][0]+0,512);   /* C9 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+2][0]+0,512);   /* C5 */
		} else {
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+3][0]+0,512);   /* C6 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+1][0]+0,512);   /* C2 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+3][0]+512,512); /* C7 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+1][0]+512,512); /* C3 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+4][0]+0,512);   /* C8 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+2][0]+0,512);   /* C4 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+4][0]+512,512); /* C9 */
			FileWriteBinary(faceA->edsk_filename,(char *)&faceA->blocks[idblock+2][0]+512,512); /* C5 */
		}

		/* @@TODO ça semble un peu foireux comme procédé */	
		if (faceB) {
#if TRACE_EDSK
	printf("writing EDSK face B /!\\  probably NOT WORKING !!!\n");
#endif
			trackblock[0x11]=1;
			for (i=0;i<9;i++) {
				trackblock[0x18+i*8+0]=trackblock[0x10];
				trackblock[0x18+i*8+1]=trackblock[0x11];
			}
			/* écriture du track info */
			FileWriteBinary(faceB->edsk_filename,(char *)trackblock,256);
			/* écriture des secteurs */
			idblock=t*9/2;
			blockoffset=((t*9)%2)*512;
			FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock][0]+blockoffset,512);
			if (!blockoffset) {
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+2][0]+512,512); /* C6 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+0][0]+512,512); /* C2 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+3][0]+0,512);   /* C7 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+1][0]+0,512);   /* C3 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+3][0]+512,512); /* C8 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+1][0]+512,512); /* C4 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+4][0]+0,512);   /* C9 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+2][0]+0,512);   /* C5 */
			} else {
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+3][0]+0,512);   /* C6 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+1][0]+0,512);   /* C2 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+3][0]+512,512); /* C7 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+1][0]+512,512); /* C3 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+4][0]+0,512);   /* C8 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+2][0]+0,512);   /* C4 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+4][0]+512,512); /* C9 */
				FileWriteBinary(faceB->edsk_filename,(char *)&faceB->blocks[idblock+2][0]+512,512); /* C5 */
			}
		}
	}
	FileWriteBinaryClose(faceA->edsk_filename);
	rasm_printf(ae,KIO"Write edsk file %s\n",faceA->edsk_filename);
}
void EDSK_write(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "EDSK_write"

	struct s_edsk_wrapper *faceA,*faceB;
	int i,j;

	
	/* on passe en revue toutes les structs */
	for (i=0;i<ae->nbedskwrapper;i++) {
		/* already done */
		if (ae->edsk_wrapper[i].face==-1) continue;
		
		switch (ae->edsk_wrapper[i].face) {
			default:
			case 0:faceA=&ae->edsk_wrapper[i];faceB=NULL;break;
			case 1:faceA=NULL;faceB=&ae->edsk_wrapper[i];break;
		}
		/* doit-on fusionner avec une autre face? */
		for (j=i+1;j<ae->nbedskwrapper;j++) {
			if (!strcmp(ae->edsk_wrapper[i].edsk_filename,ae->edsk_wrapper[j].edsk_filename)) {
				/* found another face for the floppy */
				switch (ae->edsk_wrapper[j].face) {
					default:
					case 0:faceA=&ae->edsk_wrapper[j];break;
					case 1:faceB=&ae->edsk_wrapper[j];break;
				}
			}
		}
		EDSK_write_file(ae,faceA,faceB);
	}
}

/* CDT output code / courtesy of CNG */
void update11(unsigned char *head,int n,int is1st,int islast,int l, int fileload)
{
        head[0x10]=n;
        head[0x11]=islast?-1:0;
        head[0x13]=l;
        head[0x14]=l>>8;
        head[0x15]=fileload;
        head[0x16]=fileload>>8;
        head[0x17]=is1st?-1:0;
}
#define fputcc(x,y) { fputc((x),y); fputc((x)>>8,y); }
#define fputccc(x,y) { fputc((x),y); fputc((x)>>8,y); fputc((x)>>16,y); }
void record11(char *filename,unsigned char *t,int first,int l,int p, int flag_bb, int flag_b)
{
	FILE *fo;
	#ifdef OS_WIN
	fo=FileOpen(filename,"w");
	#else
	fo=FileOpen(filename,"a+");
	#endif

	/* almost legacy */
        fputc(0x11,fo);
        fputcc(flag_bb,fo);
        fputcc(flag_b,fo);
        fputcc(flag_b,fo);
        fputcc(flag_b,fo);
        fputcc(flag_bb,fo);
        //fputcc(flag_o,fo);
        fputcc(4096,fo); // 4K block
        fputc(8,fo);
        fputcc(p,fo);
        p=1+(((l+255)/256)*258)+4; //flag_z;
        fputccc(p,fo);
        fputc(first,fo);
        p=0;
        while (l>0)
        {
		int crc16=0xFFFF;
                fwrite(t+p,1,256,fo);
                first=256;
		while (first--) {
			// early CRC-16-CCITT as used by Amstrad
                        int xor8=(t[p++]<<8)+1;
                        while (xor8&0xFF)
                        {
                                if ((xor8^crc16)&0x8000)
                                        crc16=((crc16^0x0810)<<1)+1;
                                else
                                        crc16<<=1;
                                xor8<<=1;
                        }
                }
                crc16=~crc16;
                fputc(crc16>>8,fo); // HI FIRST,
                fputc(crc16,fo); // AND LO NEXT!
                l-=256;
        }
        l=4; //flag_z;
        while (l--)
                fputc(255,fo);
}


void PopAllSave(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "PopAllSave"
	
	unsigned char *AmsdosHeader;
	char *dskfilename;
	char *filename;
	int offset,size,run;
	int i,is,erreur=0,touched;
	
	for (is=0;is<ae->nbsave;is++) {
		/* avoid quotes */
		filename=ae->wl[ae->save[is].iw].w;
		filename[strlen(filename)-1]=0;
		filename=TxtStrDup(filename+1);
		/* translate tags! */
		filename=TranslateTag(ae,filename,&touched,1,E_TAGOPTION_REMOVESPACE);

#if TRACE_EDSK
	printf("woff=[%s](%d) wsize=[%s](%d)\n",ae->wl[ae->save[is].ioffset].w,ae->save[is].ioffset,ae->wl[ae->save[is].isize].w,ae->save[is].isize);
#endif

		ae->idx=ae->save[is].ioffset; /* exp hack */
		ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
		offset=RoundComputeExpression(ae,ae->wl[ae->idx].w,0,0,0);

		ae->idx=ae->save[is].isize; /* exp hack */
		ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
		size=RoundComputeExpression(ae,ae->wl[ae->idx].w,0,0,0);

		ae->idx=ae->save[is].irun; /* exp hack */
		if (ae->idx) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			run=RoundComputeExpression(ae,ae->wl[ae->idx].w,0,0,0);
		} else {
			run=offset;
		}

		if (size<1 || size>65536) {
			MakeError(ae,NULL,0,"cannot save [%s] as the size is invalid!\n",filename);
			MemFree(filename);
			continue;
		}
		if (offset<0 || offset>65535) {
			MakeError(ae,NULL,0,"cannot save [%s] as the offset is invalid!\n",filename);
			MemFree(filename);
			continue;
		}
		if (offset+size>65536) {
			MakeError(ae,NULL,0,"cannot save [%s] as the offset+size will be out of bounds!\n",filename);
			MemFree(filename);
			continue;
		}
		/* DSK management */
		if (ae->save[is].dsk) {
			if (ae->save[is].iwdskname!=-1) {
				/* obligé de dupliquer à cause du reuse */
				dskfilename=TxtStrDup(ae->wl[ae->save[is].iwdskname].w);
				dskfilename[strlen(dskfilename)-1]=0;
				if (!EDSK_addfile(ae,dskfilename+1,ae->save[is].face,filename,ae->mem[ae->save[is].ibank]+offset,size,offset,run)) {
					erreur++;
					//break;
				}
				MemFree(dskfilename);
			}
		} else if (ae->save[is].tape) {
			char *tapefilename;
			unsigned char head[256];
			char TZX_header[14];
			int wrksize,fileload,nbblock=0;
			unsigned char body[65536+128];
			int flag_h=2560, flag_p=10240, flag_bb, flag_b=1000,j,k;

			/* output file on filesystem */
			FileRemoveIfExists(filename);

			memcpy(TZX_header,"ZXTape!\032\001\000\040\000\012",13);

			if (ae->save[is].iwdskname>0) {
				tapefilename=ae->wl[ae->save[is].iwdskname].w;
				tapefilename[strlen(tapefilename)-1]=0;
				tapefilename=TxtStrDup(tapefilename+1);
			} else {
				tapefilename=TxtStrDup("rasmoutput.cdt");
			}

			FileRemoveIfExists(tapefilename); // pas de append pour le moment
			FileWriteBinary(tapefilename,(char *)TZX_header,13);

			AmsdosHeader=MakeAMSDOSHeader(run,offset,offset+size,MakeAMSDOS_name(ae,filename));
			memcpy(body,AmsdosHeader,128);
			wrksize=size;

			memset(head,0,16);
			strcpy(head,MakeAMSDOS_name(ae,filename));
			head[0x12]=body[0x12];
			head[0x18]=body[0x40];
			head[0x19]=body[0x41];
			head[0x1A]=body[0x1A];
			head[0x1B]=body[0x1B];
			fileload=body[0x15]+body[0x16]*256;
			flag_b=(3500000/3+flag_b/2)/flag_b;
			flag_bb=flag_b*2;
			memcpy(body,(char*)ae->mem[ae->save[is].ibank]+offset,size);

			if (wrksize>0x800) {
				update11(head,j=1,1,0,0x800,fileload); // FIRST BLOCK
				record11(tapefilename,head,44,28,16,flag_bb,flag_b);
				record11(tapefilename,body,22,0x800,flag_h,flag_bb,flag_b);
				k=wrksize-0x800;
				i=0x800;
				nbblock=1;
				while (k>0x800) {
					fileload+=0x800;
					update11(head,++j,0,0,0x800,fileload); // MID BLOCK
					record11(tapefilename,head,44,28,16,flag_bb,flag_b);
					record11(tapefilename,body+i,22,0x800,flag_h,flag_bb,flag_b);
					k-=0x800;
					i+=0x800;
					nbblock++;
				}
				nbblock++;
				fileload+=0x800;
				update11(head,++j,0,1,k,fileload); // LAST BLOCK
				record11(tapefilename,head,44,28,16,flag_bb,flag_b);
				record11(tapefilename,body+i,22,k,flag_p,flag_bb,flag_b);
			} else {
				update11(head,1,1,1,wrksize,fileload); // SINGLE BLOCK
				record11(tapefilename,head,44,28,16,flag_bb,flag_b);
				record11(tapefilename,body,22,wrksize,flag_p,flag_bb,flag_b);
				nbblock=1;
			}

			FileWriteBinaryClose(tapefilename);
			rasm_printf(ae,KIO"Write tape file %s (%d block%s)\n",tapefilename,nbblock,nbblock>1?"s":"");
		} else {
			/* output file on filesystem */
			rasm_printf(ae,KIO"Write binary file %s (%d byte%s)\n",filename,size,size>1?"s":"");
			FileRemoveIfExists(filename);
			if (ae->save[is].amsdos) {
				AmsdosHeader=MakeAMSDOSHeader(run,offset,offset+size,MakeAMSDOS_name(ae,filename));
				FileWriteBinary(filename,(char *)AmsdosHeader,128);
			}		
			FileWriteBinary(filename,(char*)ae->mem[ae->save[is].ibank]+offset,size);
			FileWriteBinaryClose(filename);
		}
		MemFree(filename);
	}
	if (!erreur) EDSK_write(ae);
	
	for (i=0;i<ae->nbedskwrapper;i++) {
		MemFree(ae->edsk_wrapper[i].edsk_filename);
	}
	if (ae->maxedskwrapper) MemFree(ae->edsk_wrapper);

	if (ae->nbsave) {
		MemFree(ae->save);
	}
}

void PopAllExpression(struct s_assenv *ae, int crunched_zone)
{
	#undef FUNC
	#define FUNC "PopAllExpression"
	
	static int first=1;
	double v;
	long r;
	int i;
	unsigned char *mem;
	char *expr;
	
	/* pop all expressions BUT thoses who where already computed (in crunched blocks) */

	/* calcul des labels et expressions en zone crunch (et locale?)
	   les labels doivent pointer:
	   - une valeur absolue (numerique ou variable calculee) -> completement transparent
	   - un label dans la meme zone de crunch -> label->lz=1 && verif de la zone crunch
	   - un label hors zone crunch MAIS avant toute zone de crunch de la bank destination (!label->lz)

	   idealement on doit tolerer les adresses situees apres le crunch dans une autre ORG zone!

	   on utilise ae->stage pour créer un état intermédiaire dans le ComputeExpressionCore
	*/
	if (crunched_zone>=0) {
		ae->stage=1;
	} else {
		/* on rescanne tout pour combler les trous */
		ae->stage=2;
		first=1;
	}
	
	for (i=first;i<ae->ie;i++) {
		/* first compute only crunched expression (0,1,2,3,...) then intermediates and (-1) at the end */
		if (crunched_zone>=0) {
			/* jump over previous crunched or non-crunched zones */
			if (ae->expression[i].lz<crunched_zone) continue;
			/* OPTIM: keep index and stop when we are after the current crunched zone */
			if (ae->expression[i].lz>crunched_zone) {
				first=i;
				break;
			}
		} else {
			if (ae->expression[i].lz>=0) continue;
		}

		mem=ae->mem[ae->expression[i].ibank];
		
		if (ae->expression[i].reference) {
			expr=ae->expression[i].reference;
		} else {
			expr=ae->wl[ae->expression[i].iw].w;
		}
		v=ComputeExpressionCore(ae,expr,ae->expression[i].ptr,i);
		r=(long)floor(v+ae->rough);
		switch (ae->expression[i].zetype) {
			case E_EXPRESSION_J8:
				r=r-ae->expression[i].ptr-2;
				if (r<-128 || r>127) {
					MakeError(ae,GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,"relative offset %d too far [%s]\n",r,ae->wl[ae->expression[i].iw].w);
				}
				mem[ae->expression[i].wptr]=(unsigned char)r;
				break;
			case E_EXPRESSION_IV81:
				/* for enhanced 16bits instructions */
				r++;
			case E_EXPRESSION_0V8:
			case E_EXPRESSION_IV8:
			case E_EXPRESSION_3V8:
			case E_EXPRESSION_V8:
				if (r>255 || r<-128) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: truncating value #%X to #%X\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,r,r&0xFF);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				mem[ae->expression[i].wptr]=(unsigned char)r;
				break;
			case E_EXPRESSION_IV16:
			case E_EXPRESSION_V16:
			case E_EXPRESSION_V16C:
			case E_EXPRESSION_0V16:
				if (r>65535 || r<-32768) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: truncating value #%X to #%X\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,r,r&0xFFFF);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				mem[ae->expression[i].wptr]=(unsigned char)r&0xFF;
				mem[ae->expression[i].wptr+1]=(unsigned char)((r&0xFF00)>>8);
				break;
			case E_EXPRESSION_0V32:
				/* meaningless in 32 bits architecture... */
				if (v>4294967295 || v<-2147483648) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: truncating value\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				mem[ae->expression[i].wptr]=(unsigned char)r&0xFF;
				mem[ae->expression[i].wptr+1]=(unsigned char)((r>>8)&0xFF);
				mem[ae->expression[i].wptr+2]=(unsigned char)((r>>16)&0xFF);
				mem[ae->expression[i].wptr+3]=(unsigned char)((r>>24)&0xFF);
				break;
			case E_EXPRESSION_0VR:
				/* convert v double value to Amstrad REAL */
				memcpy(&mem[ae->expression[i].wptr],__internal_MakeAmsdosREAL(ae,v,i),5);
				break;
			case E_EXPRESSION_0VRMike:
				/* convert v double value to Microsoft 40bits REAL */
				memcpy(&mem[ae->expression[i].wptr],__internal_MakeRosoftREAL(ae,v,i),5);
				break;
			case E_EXPRESSION_IM:
				switch (r) {
					case 0x00:mem[ae->expression[i].wptr]=0x46;break;
					case 0x01:mem[ae->expression[i].wptr]=0x56;break;
					case 0x02:mem[ae->expression[i].wptr]=0x5E;break;
					default:
						MakeError(ae,GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,"IM 0,1 or 2 only\n");
						mem[ae->expression[i].wptr]=0;
				}
				break;
			case E_EXPRESSION_RST:
				switch (r) {
					case 0x00:mem[ae->expression[i].wptr]=0xC7;break;
					case 0x08:mem[ae->expression[i].wptr]=0xCF;break;
					case 0x10:mem[ae->expression[i].wptr]=0xD7;break;
					case 0x18:mem[ae->expression[i].wptr]=0xDF;break;
					case 0x20:mem[ae->expression[i].wptr]=0xE7;break;
					case 0x28:mem[ae->expression[i].wptr]=0xEF;break;
					case 0x30:mem[ae->expression[i].wptr]=0xF7;break;
					case 0x38:mem[ae->expression[i].wptr]=0xFF;break;
					default:
						MakeError(ae,GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,"RST #0,#8,#10,#18,#20,#28,#30,#38 only\n");
						mem[ae->expression[i].wptr]=0;
				}
				break;
			case E_EXPRESSION_RUN:
				if (r<0 || r>65535) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: run adress truncated from %X to %X\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,r,r&0xFFFF);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				ae->snapshot.registers.LPC=r&0xFF;
				ae->snapshot.registers.HPC=(r>>8)&0xFF;
				break;			
			case E_EXPRESSION_ZXRUN:
				if (r<0 || r>65535) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: run adress truncated from %X to %X\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,r,r&0xFFFF);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				ae->zxsnapshot.run=r&0xFFFF;
				break;			
			case E_EXPRESSION_ZXSTACK:
				if (r<0 || r>65535) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: stack adress truncated from %X to %X\n",GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,r,r&0xFFFF);
						if (ae->erronwarn) MaxError(ae);
					}
				}
				ae->zxsnapshot.stack=r&0xFFFF;
				break;
			case E_EXPRESSION_BRS:
				if (r>=0 && r<8) {
					mem[ae->expression[i].wptr]+=r*8;
				} else {
					MakeError(ae,GetExpFile(ae,i),ae->wl[ae->expression[i].iw].l,"SET,RES,BIT shift value from 0 to 7 only\n");
				}
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - unknown expression type\n");
				FreeAssenv(ae);exit(-8);
		}	
	}
}

void InsertLabelToTree(struct s_assenv *ae, struct s_label *label)
{
	#undef FUNC
	#define FUNC "InsertLabelToTree"

	struct s_crclabel_tree *curlabeltree;
	int radix,dek=32;

	curlabeltree=&ae->labeltree;
	while (dek) {
		dek=dek-8;
		radix=(label->crc>>dek)&0xFF;
		if (curlabeltree->radix[radix]) {
			curlabeltree=curlabeltree->radix[radix];
		} else {
			curlabeltree->radix[radix]=MemMalloc(sizeof(struct s_crclabel_tree));
			curlabeltree=curlabeltree->radix[radix];
			memset(curlabeltree,0,sizeof(struct s_crclabel_tree));
		}
	}
	ObjectArrayAddDynamicValueConcat((void**)&curlabeltree->label,&curlabeltree->nlabel,&curlabeltree->mlabel,&label[0],sizeof(struct s_label));
}

/* use by structure mechanism and label import to add fake labels */
void PushLabelLight(struct s_assenv *ae, struct s_label *curlabel) {
	#undef FUNC
	#define FUNC "PushLabelLight"
	
	struct s_label *searched_label;
	
	/* PushLabel light */
	if ((searched_label=SearchLabel(ae,curlabel->name,curlabel->crc))!=NULL) {
		MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"%s caused duplicate label [%s]\n",ae->idx?"Structure insertion":"Label import",curlabel->name);
		MemFree(curlabel->name);
	} else {
		curlabel->backidx=ae->il;
		curlabel->autorise_export=ae->autorise_export&(!ae->getstruct);
		ObjectArrayAddDynamicValueConcat((void **)&ae->label,&ae->il,&ae->ml,curlabel,sizeof(struct s_label));
		InsertLabelToTree(ae,curlabel);
	}				
}
void PushLabel(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "PushLabel"
	
	struct s_label curlabel={0},*searched_label;
	int i;
	/* label with counters */
	char *varbuffer;
	int tagcount=0;
	int touched;

#if TRACE_LABEL
	printf("check label [%s]\n",ae->wl[ae->idx].w);
#endif
	if (ae->AutomateValidLabelFirst[(int)ae->wl[ae->idx].w[0]&0xFF]) {
		for (i=1;ae->wl[ae->idx].w[i];i++) {
			if (ae->wl[ae->idx].w[i]=='{') tagcount++; else if (ae->wl[ae->idx].w[i]=='}') tagcount--;
			if (!tagcount) {
				if (!ae->AutomateValidLabel[(int)ae->wl[ae->idx].w[i]&0xFF]) {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid char in label declaration (%c)\n",ae->wl[ae->idx].w[i]);
					return;
				}
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid first char in label declaration (%c)\n",ae->wl[ae->idx].w[0]);
		return;
	}
	
	switch (i) {
		case 1:
			switch (ae->wl[ae->idx].w[0]) {
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'H':
				case 'L':
				case 'I':
				case 'R':
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use reserved word [%s] for label\n",ae->wl[ae->idx].w);
					return;
				default:break;
			}
			break;
		case 2:
			if (strcmp(ae->wl[ae->idx].w,"AF")==0 || strcmp(ae->wl[ae->idx].w,"BC")==0 || strcmp(ae->wl[ae->idx].w,"DE")==0 || strcmp(ae->wl[ae->idx].w,"HL")==0 || 
				strcmp(ae->wl[ae->idx].w,"IX")==0 || strcmp(ae->wl[ae->idx].w,"IY")==0 || strcmp(ae->wl[ae->idx].w,"SP")==0 ||
				strcmp(ae->wl[ae->idx].w,"LX")==0 || strcmp(ae->wl[ae->idx].w,"HX")==0 || strcmp(ae->wl[ae->idx].w,"XL")==0 || strcmp(ae->wl[ae->idx].w,"XH")==0 ||
				strcmp(ae->wl[ae->idx].w,"LY")==0 || strcmp(ae->wl[ae->idx].w,"HY")==0 || strcmp(ae->wl[ae->idx].w,"YL")==0 || strcmp(ae->wl[ae->idx].w,"YH")==0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use reserved word [%s] for label\n",ae->wl[ae->idx].w);
				return;
			}
			break;
		case 3:
			if (strcmp(ae->wl[ae->idx].w,"IXL")==0 || strcmp(ae->wl[ae->idx].w,"IYL")==0 || strcmp(ae->wl[ae->idx].w,"IXH")==0 || strcmp(ae->wl[ae->idx].w,"IYH")==0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use reserved word [%s] for label\n",ae->wl[ae->idx].w);
				return;
			}			
			break;
		case 4:
			if (strcmp(ae->wl[ae->idx].w,"VOID")==0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use reserved word [%s] for label\n",ae->wl[ae->idx].w);
				return;
			}
		default:break;
	}

	/*******************************************************
	   v a r i a b l e s     i n    l a b e l    n a m e

	           -- varbuffer is always allocated --
	*******************************************************/
	varbuffer=TranslateTag(ae,TxtStrDup(ae->wl[ae->idx].w),&touched,1,E_TAGOPTION_NONE); // on se moque du touched ici => varbuffer toujours "new"
#if TRACE_LABEL
	printf("label after translation [%s]\n",varbuffer);
#endif
	/**************************************************
	   s t r u c t u r e     d e c l a r a t i o n
	**************************************************/
	if (ae->getstruct) {
		struct s_rasmstructfield rasmstructfield={0};
#if TRACE_LABEL
	printf("label used for structs! [%s]\n",varbuffer);
#endif
		if (varbuffer[0]=='@') {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Please no local label in a struct [%s]\n",ae->wl[ae->idx].w);
			MemFree(varbuffer);
			return;
		}
		/* copy label+offset in the structure */
		rasmstructfield.name=varbuffer;
		rasmstructfield.offset=ae->codeadr;
		ObjectArrayAddDynamicValueConcat((void **)&ae->rasmstruct[ae->irasmstruct-1].rasmstructfield,
				&ae->rasmstruct[ae->irasmstruct-1].irasmstructfield,&ae->rasmstruct[ae->irasmstruct-1].mrasmstructfield,
				&rasmstructfield,sizeof(rasmstructfield));
		/* label is structname+field */
		curlabel.name=MemMalloc(strlen(ae->rasmstruct[ae->irasmstruct-1].name)+strlen(varbuffer)+2);
		sprintf(curlabel.name,"%s.%s",ae->rasmstruct[ae->irasmstruct-1].name,varbuffer);
		curlabel.iw=-1;
		/* legacy */
		curlabel.crc=GetCRC(curlabel.name);
		curlabel.ptr=ae->codeadr;
#if TRACE_STRUCT
	printf("pushLabel (struct) [%X] [%s]\n",curlabel.ptr,curlabel.name);
#endif
	} else {
		/**************************************************
		   l a b e l s
		**************************************************/
		/* labels locaux */
		if (varbuffer[0]=='@' && (ae->ir || ae->iw || ae->imacro)) {
#if TRACE_LABEL
	printf("PUSH LOCAL\n");
#endif
			curlabel.iw=-1;
			curlabel.local=1;
			curlabel.name=MakeLocalLabel(ae,varbuffer,NULL);  MemFree(varbuffer);
			curlabel.crc=GetCRC(curlabel.name);

			/* local labels ALSO set new reference */
			if (ae->lastglobalalloc) {
//printf("push LOCAL is freeing lastgloballabel\n");
				MemFree(ae->lastgloballabel);
			}
			ae->lastgloballabel=TxtStrDup(curlabel.name);
			ae->lastgloballabellen=strlen(ae->lastgloballabel);
			ae->lastglobalalloc=1;
//printf("push LOCAL as reference [%d] for proximity label -> [%s]\n",im, ae->lastgloballabel);

		} else {
#if TRACE_LABEL
	printf("PUSH GLOBAL or PROXIMITY\n");
#endif
			switch (varbuffer[0]) {
				case '.':
					if (ae->dams) {
						/* old Dams style declaration (remove the dot) */
						i=0;
						do {
							varbuffer[i]=varbuffer[i+1];
							i++;
						} while (varbuffer[i]!=0);

						curlabel.iw=-1;
						curlabel.name=varbuffer;
						curlabel.crc=GetCRC(curlabel.name);
					} else {
						/* proximity labels */
						if (ae->lastgloballabel) {
							curlabel.name=MemMalloc(strlen(varbuffer)+1+ae->lastgloballabellen);
							sprintf(curlabel.name,"%s%s",ae->lastgloballabel,varbuffer);
							MemFree(varbuffer);
							curlabel.iw=-1;
							curlabel.crc=GetCRC(curlabel.name);
#if TRACE_LABEL
printf("PUSH PROXIMITY label that may be exported [%s]->[%s]\n",ae->wl[ae->idx].w,curlabel.name);
#endif
						} else {
#if TRACE_LABEL
printf("PUSH Orphan PROXIMITY label that cannot be exported [%s]->[%s]\n",ae->wl[ae->idx].w,curlabel.name);
#endif

							curlabel.iw=-1;
							curlabel.name=varbuffer;
							curlabel.crc=GetCRC(varbuffer);
						}
					}
					break;
				default:
#if TRACE_LABEL
	printf("PUSH => GLOBAL [%s]\n",varbuffer);
#endif
					curlabel.iw=-1;
					curlabel.name=varbuffer; 
					curlabel.crc=GetCRC(varbuffer);

					/* global labels set new reference */
					if (ae->lastglobalalloc) MemFree(ae->lastgloballabel);
					ae->lastgloballabel=TxtStrDup(curlabel.name);
					ae->lastgloballabellen=strlen(curlabel.name);
					ae->lastglobalalloc=1;
					break;
			}


			/* this stage varbuffer maybe already freed or used */
			if (curlabel.name[0]!='@' && ae->module && ae->modulen) {
				char *newlabelname;

				newlabelname=MemMalloc(strlen(curlabel.name)+ae->modulen+2);
				strcpy(newlabelname,ae->module);
				strcat(newlabelname,ae->module_separator);
				strcat(newlabelname,curlabel.name);
				MemFree(curlabel.name);
				curlabel.name=newlabelname;
				curlabel.crc=GetCRC(curlabel.name);
				//curlabel.iw=-1; => deja mis depuis longtemps
			}
#if TRACE_LABEL
	if (curlabel.name[0]!='@') printf("PUSH => ADD MODULE [%s] => [%s]\n",ae->module?ae->module:"(null)",curlabel.name);
	else printf("PUSH => NO MODULE for local label\n");
#endif

			/* contrôle dico uniquement avec des labels non locaux */
			if (SearchDico(ae,curlabel.name,curlabel.crc)) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"cannot create label [%s] as there is already a variable with the same name\n",curlabel.name);
				return;
			}
			if(SearchAlias(ae,curlabel.crc,curlabel.name)!=-1) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"cannot create label [%s] as there is already an alias with the same name\n",curlabel.name);
				return;
			}
		}
		curlabel.ptr=ae->codeadr;
		curlabel.ibank=ae->activebank;
		curlabel.iorgzone=ae->io-1;
		curlabel.lz=ae->lz;
	}

	if ((searched_label=SearchLabel(ae,curlabel.name,curlabel.crc))!=NULL) {
		MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Duplicate label [%s] - previously defined in [%s:%d]\n",curlabel.name,ae->filename[searched_label->fileidx],searched_label->fileline);
		MemFree(curlabel.name);
	} else {
//printf("PushLabel(%s) name=%s crc=%X lz=%d\n",curlabel.name,curlabel.name?curlabel.name:"null",curlabel.crc,curlabel.lz);
		curlabel.fileidx=ae->wl[ae->idx].ifile;
		curlabel.fileline=ae->wl[ae->idx].l;
		curlabel.autorise_export=ae->autorise_export&(!ae->getstruct);
		curlabel.backidx=ae->il;
		ObjectArrayAddDynamicValueConcat((void **)&ae->label,&ae->il,&ae->ml,&curlabel,sizeof(curlabel));
		InsertLabelToTree(ae,&curlabel);
	}

}


unsigned char *EncodeSnapshotRLE(unsigned char *memin, int *lenout) {
	#undef FUNC
	#define FUNC "EncodeSnapshotRLE"
	
	int i,cpt,idx=0;
	unsigned char *memout;
	
	memout=MemMalloc(65536*2);
	
	for (i=0;i<65536;) {

		for (cpt=1;cpt<255 && i+cpt<65536;cpt++) if (memin[i]!=memin[i+cpt]) break;

		if (cpt>=3 || memin[i]==0xE5) {
			memout[idx++]=0xE5;
			memout[idx++]=cpt;
			memout[idx++]=memin[i];
			i+=cpt;
		} else {
			memout[idx++]=memin[i++];
		}
	}
	if (lenout) *lenout=idx;
	if (idx<65536) return memout;
	
	MemFree(memout);
	return NULL;
}



#undef FUNC
#define FUNC "Instruction CORE"

void _IN(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		if (strcmp(ae->wl[ae->idx+2].w,"(C)")==0) {
			switch (GetCRC(ae->wl[ae->idx+1].w)) {
				case CRC_0:
				case CRC_F:___output(ae,0xED);___output(ae,0x70);ae->nop+=4;break;
				case CRC_A:___output(ae,0xED);___output(ae,0x78);ae->nop+=3;break;
				case CRC_B:___output(ae,0xED);___output(ae,0x40);ae->nop+=4;break;
				case CRC_C:___output(ae,0xED);___output(ae,0x48);ae->nop+=4;break;
				case CRC_D:___output(ae,0xED);___output(ae,0x50);ae->nop+=4;break;
				case CRC_E:___output(ae,0xED);___output(ae,0x58);ae->nop+=4;break;
				case CRC_H:___output(ae,0xED);___output(ae,0x60);ae->nop+=4;break;
				case CRC_L:___output(ae,0xED);___output(ae,0x68);ae->nop+=4;break;
				default:
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is IN [0,F,A,B,C,D,E,H,L],(C)\n");
			}
		} else if (strcmp(ae->wl[ae->idx+1].w,"A")==0 && StringIsMem(ae->wl[ae->idx+2].w)) {
			___output(ae,0xDB);
			PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
			ae->nop+=3;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IN [0,F,A,B,C,D,E,H,L],(C) or IN A,(n) only\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IN [0,F,A,B,C,D,E,H,L],(C) or IN A,(n) only\n");
	}
}

void _OUT(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		if (strcmp(ae->wl[ae->idx+1].w,"(C)")==0) {
			switch (GetCRC(ae->wl[ae->idx+2].w)) {
				case CRC_0:___output(ae,0xED);___output(ae,0x71);ae->nop+=4;break;
				case CRC_A:___output(ae,0xED);___output(ae,0x79);ae->nop+=4;break;
				case CRC_B:___output(ae,0xED);___output(ae,0x41);ae->nop+=4;break;
				case CRC_C:___output(ae,0xED);___output(ae,0x49);ae->nop+=4;break;
				case CRC_D:___output(ae,0xED);___output(ae,0x51);ae->nop+=4;break;
				case CRC_E:___output(ae,0xED);___output(ae,0x59);ae->nop+=4;break;
				case CRC_H:___output(ae,0xED);___output(ae,0x61);ae->nop+=4;break;
				case CRC_L:___output(ae,0xED);___output(ae,0x69);ae->nop+=4;break;
				default:
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is OUT (C),[0,A,B,C,D,E,H,L]\n");
			}
		} else if (strcmp(ae->wl[ae->idx+2].w,"A")==0 && StringIsMem(ae->wl[ae->idx+1].w)) {
			___output(ae,0xD3);
			PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
			ae->nop+=3;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OUT (C),[0,A,B,C,D,E,H,L] or OUT (n),A only\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OUT (C),[0,A,B,C,D,E,H,L] or OUT (n),A only\n");
	}
}

void _EX(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_HL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_DE:___output(ae,0xEB);ae->nop+=1;break;
					case CRC_MSP:___output(ae,0xE3);ae->nop+=6;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX HL,[(SP),DE]\n");
				}
				break;
			case CRC_AF:
				if (strcmp(ae->wl[ae->idx+2].w,"AF'")==0) {
					___output(ae,0x08);ae->nop+=1;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX AF,AF'\n");
				}
				break;
			case CRC_MSP:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_HL:___output(ae,0xE3);ae->nop+=6;break;
					case CRC_IX:___output(ae,0xDD);___output(ae,0xE3);ae->nop+=7;break;
					case CRC_IY:___output(ae,0xFD);___output(ae,0xE3);ae->nop+=7;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX (SP),[HL,IX,IY]\n");
				}
				break;
			case CRC_DE:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_HL:___output(ae,0xEB);ae->nop+=1;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX DE,HL\n");
				}
				break;
			case CRC_IX:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_MSP:___output(ae,0xDD);___output(ae,0xE3);ae->nop+=7;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX IX,(SP)\n");
				}
				break;
			case CRC_IY:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_MSP:___output(ae,0xFD);___output(ae,0xE3);ae->nop+=7;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX IY,(SP)\n");
				}
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is EX [AF,DE,HL,(SP),IX,IY],reg16\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use EX reg16,reg16\n");
	}
}

void _SBC(struct s_assenv *ae) {
	if ((!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) || ((!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) && strcmp(ae->wl[ae->idx+1].w,"A")==0)) {
		if (!ae->wl[ae->idx+1].t) ae->idx++;
		/* do implicit A */
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,0x9F);ae->nop+=1;break;
			case CRC_MHL:___output(ae,0x9E);ae->nop+=2;break;
			case CRC_B:___output(ae,0x98);ae->nop+=1;break;
			case CRC_C:___output(ae,0x99);ae->nop+=1;break;
			case CRC_D:___output(ae,0x9A);ae->nop+=1;break;
			case CRC_E:___output(ae,0x9B);ae->nop+=1;break;
			case CRC_H:___output(ae,0x9C);ae->nop+=1;break;
			case CRC_L:___output(ae,0x9D);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x9C);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x9D);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x9C);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x9D);ae->nop+=2;break;
			case CRC_IX:case CRC_IY:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use SBC with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
				ae->idx++;
				return;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0x9E);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=3;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0x9E);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=3;
				} else {
					___output(ae,0xDE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_HL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0xED);___output(ae,0x42);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xED);___output(ae,0x52);ae->nop+=4;break;
					case CRC_HL:___output(ae,0xED);___output(ae,0x62);ae->nop+=4;break;
					case CRC_SP:___output(ae,0xED);___output(ae,0x72);ae->nop+=4;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SBC HL,[BC,DE,HL,SP]\n");
				}
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SBC HL,[BC,DE,HL,SP]\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid syntax for SBC\n");
	}
}

void _ADC(struct s_assenv *ae) {
	if ((!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) || ((!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) && strcmp(ae->wl[ae->idx+1].w,"A")==0)) {
		if (!ae->wl[ae->idx+1].t) ae->idx++;
		/* also implicit A */
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,0x8F);ae->nop+=1;break;
			case CRC_MHL:___output(ae,0x8E);ae->nop+=2;break;
			case CRC_B:___output(ae,0x88);ae->nop+=1;break;
			case CRC_C:___output(ae,0x89);ae->nop+=1;break;
			case CRC_D:___output(ae,0x8A);ae->nop+=1;break;
			case CRC_E:___output(ae,0x8B);ae->nop+=1;break;
			case CRC_H:___output(ae,0x8C);ae->nop+=1;break;
			case CRC_L:___output(ae,0x8D);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x8C);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x8D);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x8C);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x8D);ae->nop+=2;break;
			case CRC_IX:case CRC_IY:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use ADC with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
				ae->idx++;
				return;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0x8E);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=3;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0x8E);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=3;
				} else {
					___output(ae,0xCE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_HL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0xED);___output(ae,0x4A);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xED);___output(ae,0x5A);ae->nop+=4;break;
					case CRC_HL:___output(ae,0xED);___output(ae,0x6A);ae->nop+=4;break;
					case CRC_SP:___output(ae,0xED);___output(ae,0x7A);ae->nop+=4;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADC HL,[BC,DE,HL,SP]\n");
				}
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADC HL,[BC,DE,HL,SP]\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid syntax for ADC\n");
	}
}

void _ADD(struct s_assenv *ae) {
	if ((!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) || ((!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) && strcmp(ae->wl[ae->idx+1].w,"A")==0)) {
		if (!ae->wl[ae->idx+1].t) ae->idx++;
		/* also implicit A */
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,0x87);ae->nop+=1;break;
			case CRC_MHL:___output(ae,0x86);ae->nop+=2;break;
			case CRC_B:___output(ae,0x80);ae->nop+=1;break;
			case CRC_C:___output(ae,0x81);ae->nop+=1;break;
			case CRC_D:___output(ae,0x82);ae->nop+=1;break;
			case CRC_E:___output(ae,0x83);ae->nop+=1;break;
			case CRC_H:___output(ae,0x84);ae->nop+=1;break;
			case CRC_L:___output(ae,0x85);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x84);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x85);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x84);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x85);ae->nop+=2;break;
			case CRC_IX:case CRC_IY:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use ADD with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
				ae->idx++;
				return;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0x86);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0x86);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xC6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_HL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0x09);ae->nop+=3;break;
					case CRC_DE:___output(ae,0x19);ae->nop+=3;break;
					case CRC_HL:___output(ae,0x29);ae->nop+=3;break;
					case CRC_SP:___output(ae,0x39);ae->nop+=3;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADD HL,[BC,DE,HL,SP]\n");
				}
				break;
			case CRC_IX:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0xDD);___output(ae,0x09);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xDD);___output(ae,0x19);ae->nop+=4;break;
					case CRC_IX:___output(ae,0xDD);___output(ae,0x29);ae->nop+=4;break;
					case CRC_SP:___output(ae,0xDD);___output(ae,0x39);ae->nop+=4;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADD IX,[BC,DE,IX,SP]\n");
				}
				break;
			case CRC_IY:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0xFD);___output(ae,0x09);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xFD);___output(ae,0x19);ae->nop+=4;break;
					case CRC_IY:___output(ae,0xFD);___output(ae,0x29);ae->nop+=4;break;
					case CRC_SP:___output(ae,0xFD);___output(ae,0x39);ae->nop+=4;break;
					default:
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADD IY,[BC,DE,IY,SP]\n");
				}
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is ADD [HL,IX,IY],reg16\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid syntax for ADD\n");
	}
}

void _CP(struct s_assenv *ae) {
	if ((!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) || ((!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) && strcmp(ae->wl[ae->idx+1].w,"A")==0)) {
		if (!ae->wl[ae->idx+1].t) ae->idx++;
		/* also implicit A */
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,0xBF);ae->nop+=1;break;
			case CRC_MHL:___output(ae,0xBE);ae->nop+=2;break;
			case CRC_B:___output(ae,0xB8);ae->nop+=1;break;
			case CRC_C:___output(ae,0xB9);ae->nop+=1;break;
			case CRC_D:___output(ae,0xBA);ae->nop+=1;break;
			case CRC_E:___output(ae,0xBB);ae->nop+=1;break;
			case CRC_H:___output(ae,0xBC);ae->nop+=1;break;
			case CRC_L:___output(ae,0xBD);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0xBC);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0xBD);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0xBC);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0xBD);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xBE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xBE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xFE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Syntax is CP reg8/(reg16)\n");
	}
}

void _RET(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_NZ:___output(ae,0xC0);ae->nop+=2;break;
			case CRC_Z:___output(ae,0xC8);ae->nop+=2;break;
			case CRC_C:___output(ae,0xD8);ae->nop+=2;break;
			case CRC_NC:___output(ae,0xD0);ae->nop+=2;break;
			case CRC_PE:___output(ae,0xE8);ae->nop+=2;break;
			case CRC_PO:___output(ae,0xE0);ae->nop+=2;break;
			case CRC_P:___output(ae,0xF0);ae->nop+=2;break;
			case CRC_M:___output(ae,0xF8);ae->nop+=2;break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Available flags for RET are C,NC,Z,NZ,PE,PO,P,M\n");
		}
		ae->idx++;
	} else if (ae->wl[ae->idx].t==1) {
		___output(ae,0xC9);
		ae->nop+=3;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid RET syntax\n");
	}
}

void _CALL(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_C:___output(ae,0xDC);ae->nop+=3;break;
			case CRC_Z:___output(ae,0xCC);ae->nop+=3;break;
			case CRC_NZ:___output(ae,0xC4);ae->nop+=3;break;
			case CRC_NC:___output(ae,0xD4);ae->nop+=3;break;
			case CRC_PE:___output(ae,0xEC);ae->nop+=3;break;
			case CRC_PO:___output(ae,0xE4);ae->nop+=3;break;
			case CRC_P:___output(ae,0xF4);ae->nop+=3;break;
			case CRC_M:___output(ae,0xFC);ae->nop+=3;break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Available flags for CALL are C,NC,Z,NZ,PE,PO,P,M\n");
		}
		PushExpression(ae,ae->idx+2,E_EXPRESSION_V16C);
		ae->idx+=2;
	} else if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		___output(ae,0xCD);
		PushExpression(ae,ae->idx+1,E_EXPRESSION_V16C);
		ae->idx++;
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid CALL syntax\n");
	}
}

void _JR(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_NZ:___output(ae,0x20);ae->nop+=2;break;
			case CRC_C:___output(ae,0x38);ae->nop+=2;break;
			case CRC_Z:___output(ae,0x28);ae->nop+=2;break;
			case CRC_NC:___output(ae,0x30);ae->nop+=2;break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Available flags for JR are C,NC,Z,NZ\n");
		}
		PushExpression(ae,ae->idx+2,E_EXPRESSION_J8);
		ae->idx+=2;
	} else if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		___output(ae,0x18);
		PushExpression(ae,ae->idx+1,E_EXPRESSION_J8);
		ae->idx++;
		ae->nop+=3;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid JR syntax\n");
	}
}

void _JP(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_C:___output(ae,0xDA);ae->nop+=3;break;
			case CRC_Z:___output(ae,0xCA);ae->nop+=3;break;
			case CRC_NZ:___output(ae,0xC2);ae->nop+=3;break;
			case CRC_NC:___output(ae,0xD2);ae->nop+=3;break;
			case CRC_PE:___output(ae,0xEA);ae->nop+=3;break;
			case CRC_PO:___output(ae,0xE2);ae->nop+=3;break;
			case CRC_P:___output(ae,0xF2);ae->nop+=3;break;
			case CRC_M:___output(ae,0xFA);ae->nop+=3;break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Available flags for JP are C,NC,Z,NZ,PE,PO,P,M\n");
		}
		if (!strcmp(ae->wl[ae->idx+2].w,"(IX)") || !strcmp(ae->wl[ae->idx+2].w,"(IY)")) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"conditionnal JP cannot use register adressing\n");
		} else {
			PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
		}
		ae->idx+=2;
	} else if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_HL:case CRC_MHL:___output(ae,0xE9);ae->nop+=1;break;
			case CRC_IX:case CRC_MIX:___output(ae,0xDD);___output(ae,0xE9);ae->nop+=2;break;
			case CRC_IY:case CRC_MIY:___output(ae,0xFD);___output(ae,0xE9);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0 || strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"JP (IX) or JP (IY) only\n");
				} else {
					___output(ae,0xC3);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V16);
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid JP syntax\n");
	}
}


void _DEC(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			switch (GetCRC(ae->wl[ae->idx+1].w)) {
				case CRC_A:___output(ae,0x3D);ae->nop+=1;break;
				case CRC_B:___output(ae,0x05);ae->nop+=1;break;
				case CRC_C:___output(ae,0x0D);ae->nop+=1;break;
				case CRC_D:___output(ae,0x15);ae->nop+=1;break;
				case CRC_E:___output(ae,0x1D);ae->nop+=1;break;
				case CRC_H:___output(ae,0x25);ae->nop+=1;break;
				case CRC_L:___output(ae,0x2D);ae->nop+=1;break;
				case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x25);ae->nop+=2;break;
				case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x2D);ae->nop+=2;break;
				case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x25);ae->nop+=2;break;
				case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x2D);ae->nop+=2;break;
				case CRC_BC:___output(ae,0x0B);ae->nop+=2;break;
				case CRC_DE:___output(ae,0x1B);ae->nop+=2;break;
				case CRC_HL:___output(ae,0x2B);ae->nop+=2;break;
				case CRC_IX:___output(ae,0xDD);___output(ae,0x2B);ae->nop+=3;break;
				case CRC_IY:___output(ae,0xFD);___output(ae,0x2B);ae->nop+=3;break;
				case CRC_SP:___output(ae,0x3B);ae->nop+=2;break;
				case CRC_MHL:___output(ae,0x35);ae->nop+=3;break;
				default:
					if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x35);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
						ae->nop+=6;
					} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x35);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
						ae->nop+=6;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use DEC with A,B,C,D,E,H,L,XH,XL,YH,YL,BC,DE,HL,SP,(HL),(IX),(IY)\n");
					}
			}
			ae->idx++;
		} while (ae->wl[ae->idx].t==0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use DEC with A,B,C,D,E,H,L,XH,XL,YH,YL,BC,DE,HL,SP,(HL),(IX),(IY)\n");
	}
}
void _INC(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			switch (GetCRC(ae->wl[ae->idx+1].w)) {
				case CRC_A:___output(ae,0x3C);ae->nop+=1;break;
				case CRC_B:___output(ae,0x04);ae->nop+=1;break;
				case CRC_C:___output(ae,0x0C);ae->nop+=1;break;
				case CRC_D:___output(ae,0x14);ae->nop+=1;break;
				case CRC_E:___output(ae,0x1C);ae->nop+=1;break;
				case CRC_H:___output(ae,0x24);ae->nop+=1;break;
				case CRC_L:___output(ae,0x2C);ae->nop+=1;break;
				case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x24);ae->nop+=2;break;
				case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x2C);ae->nop+=2;break;
				case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x24);ae->nop+=2;break;
				case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x2C);ae->nop+=2;break;
				case CRC_BC:___output(ae,0x03);ae->nop+=2;break;
				case CRC_DE:___output(ae,0x13);ae->nop+=2;break;
				case CRC_HL:___output(ae,0x23);ae->nop+=2;break;
				case CRC_IX:___output(ae,0xDD);___output(ae,0x23);ae->nop+=3;break;
				case CRC_IY:___output(ae,0xFD);___output(ae,0x23);ae->nop+=3;break;
				case CRC_SP:___output(ae,0x33);ae->nop+=2;break;
				case CRC_MHL:___output(ae,0x34);ae->nop+=3;break;
				default:
					if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x34);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
						ae->nop+=6;
					} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x34);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
						ae->nop+=6;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use INC with A,B,C,D,E,H,L,XH,XL,YH,YL,BC,DE,HL,SP,(HL),(IX),(IY)\n");
					}
			}
			ae->idx++;
		} while (ae->wl[ae->idx].t==0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use INC with A,B,C,D,E,H,L,XH,XL,YH,YL,BC,DE,HL,SP,(HL),(IX),(IY)\n");
	}
}

void _SUB(struct s_assenv *ae) {
	#ifdef OPCODE
	#undef OPCODE
	#endif
	#define OPCODE 0x90
	
	if ((!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1)  || ((!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) && strcmp(ae->wl[ae->idx+1].w,"A")==0)) {
		if (!ae->wl[ae->idx+1].t) ae->idx++;
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,OPCODE+7);ae->nop+=1;break;
			case CRC_MHL:___output(ae,OPCODE+6);ae->nop+=2;break;
			case CRC_B:___output(ae,OPCODE);ae->nop+=1;break;
			case CRC_C:___output(ae,OPCODE+1);ae->nop+=1;break;
			case CRC_D:___output(ae,OPCODE+2);ae->nop+=1;break;
			case CRC_E:___output(ae,OPCODE+3);ae->nop+=1;break;
			case CRC_H:___output(ae,OPCODE+4);ae->nop+=1;break;
			case CRC_L:___output(ae,OPCODE+5);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,OPCODE+5);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,OPCODE+5);ae->nop+=2;break;
			case CRC_IX:case CRC_IY:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use SUB with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
				ae->idx++;
				return;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xD6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use SUB with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
	}
}
void _ZAND(struct s_assenv *ae) {
	#ifdef OPCODE
	#undef OPCODE
	#endif
	#define OPCODE 0xA0
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,OPCODE+7);ae->nop+=1;break;
			case CRC_MHL:___output(ae,OPCODE+6);ae->nop+=2;break;
			case CRC_B:___output(ae,OPCODE);ae->nop+=1;break;
			case CRC_C:___output(ae,OPCODE+1);ae->nop+=1;break;
			case CRC_D:___output(ae,OPCODE+2);ae->nop+=1;break;
			case CRC_E:___output(ae,OPCODE+3);ae->nop+=1;break;
			case CRC_H:___output(ae,OPCODE+4);ae->nop+=1;break;
			case CRC_L:___output(ae,OPCODE+5);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,OPCODE+5);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,OPCODE+5);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xE6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use AND with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
	}
}
void _OR(struct s_assenv *ae) {
	#ifdef OPCODE
	#undef OPCODE
	#endif
	#define OPCODE 0xB0
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,OPCODE+7);ae->nop+=1;break;
			case CRC_MHL:___output(ae,OPCODE+6);ae->nop+=2;break;
			case CRC_B:___output(ae,OPCODE);ae->nop+=1;break;
			case CRC_C:___output(ae,OPCODE+1);ae->nop+=1;break;
			case CRC_D:___output(ae,OPCODE+2);ae->nop+=1;break;
			case CRC_E:___output(ae,OPCODE+3);ae->nop+=1;break;
			case CRC_H:___output(ae,OPCODE+4);ae->nop+=1;break;
			case CRC_L:___output(ae,OPCODE+5);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,OPCODE+5);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,OPCODE+5);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xF6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use OR with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
	}
}
void _XOR(struct s_assenv *ae) {
	#ifdef OPCODE
	#undef OPCODE
	#endif
	#define OPCODE 0xA8
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:___output(ae,OPCODE+7);ae->nop+=1;break;
			case CRC_MHL:___output(ae,OPCODE+6);ae->nop+=2;break;
			case CRC_B:___output(ae,OPCODE);ae->nop+=1;break;
			case CRC_C:___output(ae,OPCODE+1);ae->nop+=1;break;
			case CRC_D:___output(ae,OPCODE+2);ae->nop+=1;break;
			case CRC_E:___output(ae,OPCODE+3);ae->nop+=1;break;
			case CRC_H:___output(ae,OPCODE+4);ae->nop+=1;break;
			case CRC_L:___output(ae,OPCODE+5);ae->nop+=1;break;
			case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,OPCODE+5);ae->nop+=2;break;
			case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,OPCODE+4);ae->nop+=2;break;
			case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,OPCODE+5);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,OPCODE+6);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					ae->nop+=5;
				} else {
					___output(ae,0xEE);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_V8);
					ae->nop+=2;
				}
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use XOR with A,B,C,D,E,H,L,XH,XL,YH,YL,(HL),(IX),(IY)\n");
	}
}


void _POP(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			switch (GetCRC(ae->wl[ae->idx].w)) {
				case CRC_AF:___output(ae,0xF1);ae->nop+=3;break;
				case CRC_BC:___output(ae,0xC1);ae->nop+=3;break;
				case CRC_DE:___output(ae,0xD1);ae->nop+=3;break;
				case CRC_HL:___output(ae,0xE1);ae->nop+=3;break;
				case CRC_IX:___output(ae,0xDD);___output(ae,0xE1);ae->nop+=4;break;
				case CRC_IY:___output(ae,0xFD);___output(ae,0xE1);ae->nop+=4;break;
				default:
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use POP with AF,BC,DE,HL,IX,IY\n");
			}
		} while (ae->wl[ae->idx].t!=1);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"POP need at least one parameter\n");
	}
}
void _PUSH(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			switch (GetCRC(ae->wl[ae->idx].w)) {
				case CRC_AF:___output(ae,0xF5);ae->nop+=4;break;
				case CRC_BC:___output(ae,0xC5);ae->nop+=4;break;
				case CRC_DE:___output(ae,0xD5);ae->nop+=4;break;
				case CRC_HL:___output(ae,0xE5);ae->nop+=4;break;
				case CRC_IX:___output(ae,0xDD);___output(ae,0xE5);ae->nop+=5;break;
				case CRC_IY:___output(ae,0xFD);___output(ae,0xE5);ae->nop+=5;break;
				default:
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use PUSH with AF,BC,DE,HL,IX,IY\n");
			}
		} while (ae->wl[ae->idx].t!=1);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"PUSH need at least one parameter\n");
	}
}

void _IM(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		/* la valeur du parametre va definir l'opcode du IM */
		___output(ae,0xED);
		PushExpression(ae,ae->idx+1,E_EXPRESSION_IM);
		ae->idx++;
		ae->nop+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IM need one parameter\n");
	}
}

void _RLCA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0x7);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RLCA does not need parameter\n");
	}
}
void _RRCA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xF);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RRCA does not need parameter\n");
	}
}
void _NEG(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0x44);
		ae->nop+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NEG does not need parameter\n");
	}
}
void _DAA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0x27);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DAA does not need parameter\n");
	}
}
void _CPL(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0x2F);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CPL does not need parameter\n");
	}
}
void _RETI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0x4D);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RETI does not need parameter\n");
	}
}
void _SCF(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0x37);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SCF does not need parameter\n");
	}
}
void _LDD(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA8);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LDD does not need parameter\n");
	}
}
void _LDDR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xB8);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LDDR does not need parameter\n");
	}
}
void _LDI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA0);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LDI does not need parameter\n");
	}
}
void _LDIR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xB0);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LDIR does not need parameter\n");
	}
}
void _CCF(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0x3F);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CCF does not need parameter\n");
	}
}
void _CPD(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA9);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CPD does not need parameter\n");
	}
}
void _CPDR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xB9);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CPDR does not need parameter\n");
	}
}
void _CPI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA1);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CPI does not need parameter\n");
	}
}
void _CPIR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xB1);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CPIR does not need parameter\n");
	}
}
void _OUTD(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xAB);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OUTD does not need parameter\n");
	}
}
void _OTDR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xBB);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OTDR does not need parameter\n");
	}
}
void _OUTI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA3);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OUTI does not need parameter\n");
	}
}
void _OTIR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xB3);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"OTIR does not need parameter\n");
	}
}
void _RETN(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0x45);
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RETN does not need parameter\n");
	}
}
void _IND(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xAA);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IND does not need parameter\n");
	}
}
void _INDR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xBA);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INDR does not need parameter\n");
	}
}
void _INI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xED);
		___output(ae,0xA2);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INI does not need parameter\n");
	}
}
void _INIR(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0xED);
		___output(ae,0xB2);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INIR does not need parameter\n");
	}
}
void _EXX(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0xD9);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"EXX does not need parameter\n");
	}
}
void _HALT(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0x76);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"HALT does not need parameter\n");
	}
}

void _RLA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0x17);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RLA does not need parameter\n");
	}
}
void _RRA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0x1F);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RRA does not need parameter\n");
	}
}
void _RLD(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0xED);
		___output(ae,0x6F);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RLD does not need parameter\n");
	}
}
void _RRD(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0xED);
		___output(ae,0x67);
		ae->nop+=5;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RRD does not need parameter\n");
	}
}


void _EXA(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___output(ae,0x08);ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"EXA alias does not need parameter\n");
	}
}

void _NOP(struct s_assenv *ae) {
	int o;

	if (ae->wl[ae->idx].t) {
		___output(ae,0x00);
		ae->nop+=1;
	} else if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		o=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0);
		if (o>=0) {
			while (o>0) {
				___output(ae,0x00);
				ae->nop+=1;
				o--;
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NOP is supposed to be used without parameter or with one optional parameter\n");
	}
}
void _DI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
	___output(ae,0xF3);
	ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DI does not need parameter\n");
	}
}
void _EI(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___output(ae,0xFB);
		ae->nop+=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"EI does not need parameter\n");
	}
}

void _RST(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t!=2) {
		if (!strcmp(ae->wl[ae->idx+1].w,"(IY)") || !strcmp(ae->wl[ae->idx+1].w,"(IX)")) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RST cannot use IX or IY\n");
		} else {
			/* la valeur du parametre va definir l'opcode du RST */
			PushExpression(ae,ae->idx+1,E_EXPRESSION_RST);
		}
		ae->idx++;
		ae->nop+=4;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"RST need one parameter\n");
	}
}

void _DJNZ(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		if (IsRegister(ae->wl[ae->idx+1].w)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DJNZ cannot use register\n");
		} else if (strcmp("(IX)",ae->wl[ae->idx+1].w)==0 || strcmp("(IY)",ae->wl[ae->idx+1].w)==0) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DJNZ cannot use register\n");
		} else {
			___output(ae,0x10);
			PushExpression(ae,ae->idx+1,E_EXPRESSION_J8);
			ae->nop+=3;
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DJNZ need one parameter\n");
	}
}

void _LD(struct s_assenv *ae) {
	/* on check qu'il y a au moins deux parametres */
	if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_A:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_I:___output(ae,0xED);___output(ae,0x57);ae->nop+=3;break;
					case CRC_R:___output(ae,0xED);___output(ae,0x5F);ae->nop+=3;break;
					case CRC_B:___output(ae,0x78);ae->nop+=1;break;
					case CRC_C:___output(ae,0x79);ae->nop+=1;break;
					case CRC_D:___output(ae,0x7A);ae->nop+=1;break;
					case CRC_E:___output(ae,0x7B);ae->nop+=1;break;
					case CRC_H:___output(ae,0x7C);ae->nop+=1;break;
					case CRC_L:___output(ae,0x7D);ae->nop+=1;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x7C);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x7D);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x7C);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x7D);ae->nop+=2;break;
					case CRC_MHL:___output(ae,0x7E);ae->nop+=2;break;
					case CRC_A:___output(ae,0x7F);ae->nop+=1;break;
					case CRC_MBC:___output(ae,0x0A);ae->nop+=2;break;
					case CRC_MDE:___output(ae,0x1A);ae->nop+=2;break;
					default:
					/* (ix+expression) (iy+expression) (expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x7E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x7E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (StringIsMem(ae->wl[ae->idx+2].w)) {
						___output(ae,0x3A);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
						ae->nop+=4;
					} else {
						___output(ae,0x3E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_I:
				if (GetCRC(ae->wl[ae->idx+2].w)==CRC_A) {
					___output(ae,0xED);___output(ae,0x47);
					ae->nop+=3;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD I,A only\n");
				}
				break;
			case CRC_R:
				if (GetCRC(ae->wl[ae->idx+2].w)==CRC_A) {
					___output(ae,0xED);___output(ae,0x4F);
					ae->nop+=3;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD R,A only\n");
				}
				break;
			case CRC_B:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x40);ae->nop+=1;break;
					case CRC_C:___output(ae,0x41);ae->nop+=1;break;
					case CRC_D:___output(ae,0x42);ae->nop+=1;break;
					case CRC_E:___output(ae,0x43);ae->nop+=1;break;
					case CRC_H:___output(ae,0x44);ae->nop+=1;break;
					case CRC_L:___output(ae,0x45);ae->nop+=1;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x44);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x45);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x44);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x45);ae->nop+=2;break;
					case CRC_MHL:___output(ae,0x46);ae->nop+=2;break;
					case CRC_A:___output(ae,0x47);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x46);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x46);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x06);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_C:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x48);ae->nop+=1;break;
					case CRC_C:___output(ae,0x49);ae->nop+=1;break;
					case CRC_D:___output(ae,0x4A);ae->nop+=1;break;
					case CRC_E:___output(ae,0x4B);ae->nop+=1;break;
					case CRC_H:___output(ae,0x4C);ae->nop+=1;break;
					case CRC_L:___output(ae,0x4D);ae->nop+=1;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x4C);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x4D);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x4C);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x4D);ae->nop+=2;break;
					case CRC_MHL:___output(ae,0x4E);ae->nop+=2;break;
					case CRC_A:___output(ae,0x4F);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x4E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x4E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x0E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_D:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x50);ae->nop+=1;break;
					case CRC_C:___output(ae,0x51);ae->nop+=1;break;
					case CRC_D:___output(ae,0x52);ae->nop+=1;break;
					case CRC_E:___output(ae,0x53);ae->nop+=1;break;
					case CRC_H:___output(ae,0x54);ae->nop+=1;break;
					case CRC_L:___output(ae,0x55);ae->nop+=1;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x54);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x55);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x54);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x55);ae->nop+=2;break;
					case CRC_MHL:___output(ae,0x56);ae->nop+=2;break;
					case CRC_A:___output(ae,0x57);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x56);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x56);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x16);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_E:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x58);ae->nop+=1;break;
					case CRC_C:___output(ae,0x59);ae->nop+=1;break;
					case CRC_D:___output(ae,0x5A);ae->nop+=1;break;
					case CRC_E:___output(ae,0x5B);ae->nop+=1;break;
					case CRC_H:___output(ae,0x5C);ae->nop+=1;break;
					case CRC_L:___output(ae,0x5D);ae->nop+=1;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x5C);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x5D);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x5C);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x5D);ae->nop+=2;break;
					case CRC_MHL:___output(ae,0x5E);ae->nop+=2;break;
					case CRC_A:___output(ae,0x5F);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x5E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x5E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x1E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_IYH:case CRC_HY:case CRC_YH:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0xFD);___output(ae,0x60);ae->nop+=2;break;
					case CRC_C:___output(ae,0xFD);___output(ae,0x61);ae->nop+=2;break;
					case CRC_D:___output(ae,0xFD);___output(ae,0x62);ae->nop+=2;break;
					case CRC_E:___output(ae,0xFD);___output(ae,0x63);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x64);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x65);ae->nop+=2;break;
					case CRC_A:___output(ae,0xFD);___output(ae,0x67);ae->nop+=2;break;
					default:
						___output(ae,0xFD);___output(ae,0x26);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=3;
				}
				break;
			case CRC_IYL:case CRC_LY:case CRC_YL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0xFD);___output(ae,0x68);ae->nop+=2;break;
					case CRC_C:___output(ae,0xFD);___output(ae,0x69);ae->nop+=2;break;
					case CRC_D:___output(ae,0xFD);___output(ae,0x6A);ae->nop+=2;break;
					case CRC_E:___output(ae,0xFD);___output(ae,0x6B);ae->nop+=2;break;
					case CRC_IYH:case CRC_HY:case CRC_YH:___output(ae,0xFD);___output(ae,0x6C);ae->nop+=2;break;
					case CRC_IYL:case CRC_LY:case CRC_YL:___output(ae,0xFD);___output(ae,0x6D);ae->nop+=2;break;
					case CRC_A:___output(ae,0xFD);___output(ae,0x6F);ae->nop+=2;break;
					default:
						___output(ae,0xFD);___output(ae,0x2E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=3;
				}
				break;
			case CRC_IXH:case CRC_HX:case CRC_XH:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0xDD);___output(ae,0x60);ae->nop+=2;break;
					case CRC_C:___output(ae,0xDD);___output(ae,0x61);ae->nop+=2;break;
					case CRC_D:___output(ae,0xDD);___output(ae,0x62);ae->nop+=2;break;
					case CRC_E:___output(ae,0xDD);___output(ae,0x63);ae->nop+=2;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x64);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x65);ae->nop+=2;break;
					case CRC_A:___output(ae,0xDD);___output(ae,0x67);ae->nop+=2;break;
					default:
						___output(ae,0xDD);___output(ae,0x26);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=3;
				}
				break;
			case CRC_IXL:case CRC_LX:case CRC_XL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0xDD);___output(ae,0x68);ae->nop+=2;break;
					case CRC_C:___output(ae,0xDD);___output(ae,0x69);ae->nop+=2;break;
					case CRC_D:___output(ae,0xDD);___output(ae,0x6A);ae->nop+=2;break;
					case CRC_E:___output(ae,0xDD);___output(ae,0x6B);ae->nop+=2;break;
					case CRC_IXH:case CRC_HX:case CRC_XH:___output(ae,0xDD);___output(ae,0x6C);ae->nop+=2;break;
					case CRC_IXL:case CRC_LX:case CRC_XL:___output(ae,0xDD);___output(ae,0x6D);ae->nop+=2;break;
					case CRC_A:___output(ae,0xDD);___output(ae,0x6F);ae->nop+=2;break;
					default:
						___output(ae,0xDD);___output(ae,0x2E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=3;
				}
				break;
			case CRC_H:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x60);ae->nop+=1;break;
					case CRC_C:___output(ae,0x61);ae->nop+=1;break;
					case CRC_D:___output(ae,0x62);ae->nop+=1;break;
					case CRC_E:___output(ae,0x63);ae->nop+=1;break;
					case CRC_H:___output(ae,0x64);ae->nop+=1;break;
					case CRC_L:___output(ae,0x65);ae->nop+=1;break;
					case CRC_MHL:___output(ae,0x66);ae->nop+=2;break;
					case CRC_A:___output(ae,0x67);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x66);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x66);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x26);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_L:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x68);ae->nop+=1;break;
					case CRC_C:___output(ae,0x69);ae->nop+=1;break;
					case CRC_D:___output(ae,0x6A);ae->nop+=1;break;
					case CRC_E:___output(ae,0x6B);ae->nop+=1;break;
					case CRC_H:___output(ae,0x6C);ae->nop+=1;break;
					case CRC_L:___output(ae,0x6D);ae->nop+=1;break;
					case CRC_MHL:___output(ae,0x6E);ae->nop+=2;break;
					case CRC_A:___output(ae,0x6F);ae->nop+=1;break;
					default:
					/* (ix+expression) (iy+expression) expression */
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0x6E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0x6E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=5;
					} else {
						___output(ae,0x2E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
						ae->nop+=2;
					}
				}
				break;
			case CRC_MHL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_B:___output(ae,0x70);ae->nop+=2;break;
					case CRC_C:___output(ae,0x71);ae->nop+=2;break;
					case CRC_D:___output(ae,0x72);ae->nop+=2;break;
					case CRC_E:___output(ae,0x73);ae->nop+=2;break;
					case CRC_H:___output(ae,0x74);ae->nop+=2;break;
					case CRC_L:___output(ae,0x75);ae->nop+=2;break;
					case CRC_A:___output(ae,0x77);ae->nop+=2;break;
					default:
					/* expression */
					___output(ae,0x36);
					PushExpression(ae,ae->idx+2,E_EXPRESSION_V8);
					ae->nop+=3;
				}
				break;
			case CRC_MBC:
				if (GetCRC(ae->wl[ae->idx+2].w)==CRC_A)  {
					___output(ae,0x02);
					ae->nop+=2;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD (BC),A only\n");
				}
				break;
			case CRC_MDE:
				if (GetCRC(ae->wl[ae->idx+2].w)==CRC_A)  {
					___output(ae,0x12);
					ae->nop+=2;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD (DE),A only\n");
				}
				break;
			case CRC_HL:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0x60);___output(ae,0x69);ae->nop+=2;break;
					case CRC_DE:___output(ae,0x62);___output(ae,0x6B);ae->nop+=2;break;
					case CRC_HL:___output(ae,0x64);___output(ae,0x6D);ae->nop+=2;break;
					default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX+",4)==0) {
						/* enhanced LD HL,(IX+nn) */
						___output(ae,0xDD);___output(ae,0x66);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xDD);___output(ae,0x6E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY+",4)==0) {
						/* enhanced LD HL,(IY+nn) */
						___output(ae,0xFD);___output(ae,0x66);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xFD);___output(ae,0x6E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (StringIsMem(ae->wl[ae->idx+2].w)) {
						___output(ae,0x2A);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
						ae->nop+=5;
					} else {
						___output(ae,0x21);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
						ae->nop+=3;
					}
				}
				break;
			case CRC_BC:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0x40);___output(ae,0x49);ae->nop+=2;break;
					case CRC_DE:___output(ae,0x42);___output(ae,0x4B);ae->nop+=2;break;
					case CRC_HL:___output(ae,0x44);___output(ae,0x4D);ae->nop+=2;break;
					/* enhanced LD BC,IX / LD BC,IY */
					case CRC_IX:___output(ae,0xDD);___output(ae,0x44);ae->nop+=4;
						    ___output(ae,0xDD);___output(ae,0x4D);break;
					case CRC_IY:___output(ae,0xFD);___output(ae,0x44);ae->nop+=4;
						    ___output(ae,0xFD);___output(ae,0x4D);break;
					default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX+",4)==0) {
						/* enhanced LD BC,(IX+nn) */
						___output(ae,0xDD);___output(ae,0x46);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xDD);___output(ae,0x4E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY+",4)==0) {
						/* enhanced LD BC,(IY+nn) */
						___output(ae,0xFD);___output(ae,0x46);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xFD);___output(ae,0x4E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (StringIsMem(ae->wl[ae->idx+2].w)) {
						___output(ae,0xED);___output(ae,0x4B);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
						ae->nop+=6;
					} else {
						___output(ae,0x01);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
						ae->nop+=3;
					}
				}
				break;
			case CRC_DE:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_BC:___output(ae,0x50);___output(ae,0x59);ae->nop+=2;break;
					case CRC_DE:___output(ae,0x52);___output(ae,0x5B);ae->nop+=2;break;
					case CRC_HL:___output(ae,0x54);___output(ae,0x5D);ae->nop+=2;break;
					/* enhanced LD DE,IX / LD DE,IY */
					case CRC_IX:___output(ae,0xDD);___output(ae,0x54);ae->nop+=4;
						    ___output(ae,0xDD);___output(ae,0x5D);break;
					case CRC_IY:___output(ae,0xFD);___output(ae,0x54);ae->nop+=4;
						    ___output(ae,0xFD);___output(ae,0x5D);break;
					default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX+",4)==0) {
						/* enhanced LD DE,(IX+nn) */
						___output(ae,0xDD);___output(ae,0x56);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xDD);___output(ae,0x5E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY+",4)==0) {
						/* enhanced LD DE,(IY+nn) */
						___output(ae,0xFD);___output(ae,0x56);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV81);
						___output(ae,0xFD);___output(ae,0x5E);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						ae->nop+=10;
					} else if (StringIsMem(ae->wl[ae->idx+2].w)) {
						___output(ae,0xED);___output(ae,0x5B);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
						ae->nop+=6;
					} else {
						___output(ae,0x11);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
						ae->nop+=3;
					}
				}
				break;
			case CRC_IX:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					/* enhanced LD IX,BC / LD IX,DE */
					case CRC_BC:___output(ae,0xDD);___output(ae,0x60);
						    ___output(ae,0xDD);___output(ae,0x69);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xDD);___output(ae,0x62);
						    ___output(ae,0xDD);___output(ae,0x6B);ae->nop+=4;break;
					default:
				if (StringIsMem(ae->wl[ae->idx+2].w)) {
					___output(ae,0xDD);___output(ae,0x2A);
					PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
					ae->nop+=6;
				} else {
					___output(ae,0xDD);___output(ae,0x21);
					PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
					ae->nop+=4;
				}
				}
				break;
			case CRC_IY:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					/* enhanced LD IY,BC / LD IY,DE */
					case CRC_BC:___output(ae,0xFD);___output(ae,0x60);
						    ___output(ae,0xFD);___output(ae,0x69);ae->nop+=4;break;
					case CRC_DE:___output(ae,0xFD);___output(ae,0x62);
						    ___output(ae,0xFD);___output(ae,0x6B);ae->nop+=4;break;
					default:
				if (StringIsMem(ae->wl[ae->idx+2].w)) {
					___output(ae,0xFD);___output(ae,0x2A);
					PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
					ae->nop+=6;
				} else {
					___output(ae,0xFD);___output(ae,0x21);
					PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
					ae->nop+=4;
				}
				}
				break;
			case CRC_SP:
				switch (GetCRC(ae->wl[ae->idx+2].w)) {
					case CRC_HL:___output(ae,0xF9);ae->nop+=2;break;
					case CRC_IX:___output(ae,0xDD);___output(ae,0xF9);ae->nop+=3;break;
					case CRC_IY:___output(ae,0xFD);___output(ae,0xF9);ae->nop+=3;break;
					default:
						if (StringIsMem(ae->wl[ae->idx+2].w)) {
							___output(ae,0xED);___output(ae,0x7B);
							PushExpression(ae,ae->idx+2,E_EXPRESSION_IV16);
							ae->nop+=6;
						} else {
							___output(ae,0x31);
							PushExpression(ae,ae->idx+2,E_EXPRESSION_V16);
							ae->nop+=3;
						}
				}
				break;
			default:
				/* (ix+expression) (iy+expression) (expression) expression */
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					switch (GetCRC(ae->wl[ae->idx+2].w)) {
						case CRC_B:___output(ae,0xDD);___output(ae,0x70);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_C:___output(ae,0xDD);___output(ae,0x71);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_D:___output(ae,0xDD);___output(ae,0x72);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_E:___output(ae,0xDD);___output(ae,0x73);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_H:___output(ae,0xDD);___output(ae,0x74);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_L:___output(ae,0xDD);___output(ae,0x75);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_A:___output(ae,0xDD);___output(ae,0x77);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_HL:___output(ae,0xDD);___output(ae,0x74);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xDD);___output(ae,0x75);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						case CRC_DE:___output(ae,0xDD);___output(ae,0x72);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xDD);___output(ae,0x73);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						case CRC_BC:___output(ae,0xDD);___output(ae,0x70);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xDD);___output(ae,0x71);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						default:___output(ae,0xDD);___output(ae,0x36);
							PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
							PushExpression(ae,ae->idx+2,E_EXPRESSION_3V8);
							ae->nop+=6;
					}
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					switch (GetCRC(ae->wl[ae->idx+2].w)) {
						case CRC_B:___output(ae,0xFD);___output(ae,0x70);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_C:___output(ae,0xFD);___output(ae,0x71);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_D:___output(ae,0xFD);___output(ae,0x72);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_E:___output(ae,0xFD);___output(ae,0x73);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_H:___output(ae,0xFD);___output(ae,0x74);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_L:___output(ae,0xFD);___output(ae,0x75);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_A:___output(ae,0xFD);___output(ae,0x77);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=5;break;
						case CRC_HL:___output(ae,0xFD);___output(ae,0x74);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xFD);___output(ae,0x75);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						case CRC_DE:___output(ae,0xFD);___output(ae,0x72);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xFD);___output(ae,0x73);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						case CRC_BC:___output(ae,0xFD);___output(ae,0x70);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV81);___output(ae,0xFD);___output(ae,0x71);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);ae->nop+=10;break;
						default:___output(ae,0xFD);___output(ae,0x36);
							PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
							PushExpression(ae,ae->idx+2,E_EXPRESSION_3V8);
							ae->nop+=6;
					}
				} else if (StringIsMem(ae->wl[ae->idx+1].w)) {
					switch (GetCRC(ae->wl[ae->idx+2].w)) {
						case CRC_A:___output(ae,0x32);PushExpression(ae,ae->idx+1,E_EXPRESSION_V16);ae->nop+=4;break;
						case CRC_BC:___output(ae,0xED);___output(ae,0x43);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV16);ae->nop+=6;break;
						case CRC_DE:___output(ae,0xED);___output(ae,0x53);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV16);ae->nop+=6;break;
						case CRC_HL:___output(ae,0x22);PushExpression(ae,ae->idx+1,E_EXPRESSION_V16);ae->nop+=5;break;
						case CRC_IX:___output(ae,0xDD);___output(ae,0x22);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV16);ae->nop+=6;break;
						case CRC_IY:___output(ae,0xFD);___output(ae,0x22);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV16);ae->nop+=6;break;
						case CRC_SP:___output(ae,0xED);___output(ae,0x73);PushExpression(ae,ae->idx+1,E_EXPRESSION_IV16);ae->nop+=6;break;
						default:
							MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD (#nnnn),[A,BC,DE,HL,SP,IX,IY] only\n");
					}
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Unknown LD format\n");
				}
				break;
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LD needs two parameters\n");
	}
}


void _RLC(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_B:___output(ae,0xCB);___output(ae,0x0);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x1);ae->nop+=2;break;
			case CRC_D:___output(ae,0xCB);___output(ae,0x2);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x3);ae->nop+=2;break;
			case CRC_H:___output(ae,0xCB);___output(ae,0x4);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x5);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x6);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x7);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x6);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x6);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RLC reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RLC (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x0);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x4);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x5);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x7);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RLC (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	}
}

void _RRC(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_B:___output(ae,0xCB);___output(ae,0x8);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x9);ae->nop+=2;break;
			case CRC_D:___output(ae,0xCB);___output(ae,0xA);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0xB);ae->nop+=2;break;
			case CRC_H:___output(ae,0xCB);___output(ae,0xC);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0xD);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0xE);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0xF);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0xE);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0xE);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RRC reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RRC (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x8);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x9);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0xA);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0xB);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0xC);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0xD);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0xF);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RRC (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	}
}


void _RL(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x10);___output(ae,0xCB);___output(ae,0x11);ae->nop+=4;break;
			case CRC_B:___output(ae,0xCB);___output(ae,0x10);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x11);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x12);___output(ae,0xCB);___output(ae,0x13);ae->nop+=4;break;
			case CRC_D:___output(ae,0xCB);___output(ae,0x12);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x13);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x14);___output(ae,0xCB);___output(ae,0x15);ae->nop+=4;break;
			case CRC_H:___output(ae,0xCB);___output(ae,0x14);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x15);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x16);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x17);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x16);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x16);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RL reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RL (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x10);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x11);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x12);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x13);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x14);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x15);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x17);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RL (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RL (IX+n),reg8 or RL reg8/(HL)/(IX+n)/(IY+n)\n");
	}
}

void _RR(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x18);___output(ae,0xCB);___output(ae,0x19);ae->nop+=4;break;
			case CRC_B:___output(ae,0xCB);___output(ae,0x18);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x19);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x1A);___output(ae,0xCB);___output(ae,0x1B);ae->nop+=4;break;
			case CRC_D:___output(ae,0xCB);___output(ae,0x1A);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x1B);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x1C);___output(ae,0xCB);___output(ae,0x1D);ae->nop+=4;break;
			case CRC_H:___output(ae,0xCB);___output(ae,0x1C);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x1D);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x1E);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x1F);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x1E);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x1E);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RR reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RR (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x18);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x19);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1A);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1B);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1C);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1D);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x1F);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RR (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RR (IX+n),reg8 or RR reg8/(HL)/(IX+n)/(IY+n)\n");
	}
}





void _SLA(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x21);___output(ae,0xCB);___output(ae,0x10);ae->nop+=4;break; /* SLA C : RL B */
			case CRC_B:___output(ae,0xCB);___output(ae,0x20);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x21);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x23);___output(ae,0xCB);___output(ae,0x12);ae->nop+=4;break; /* SLA E : RL D */
			case CRC_D:___output(ae,0xCB);___output(ae,0x22);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x23);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x25);___output(ae,0xCB);___output(ae,0x14);ae->nop+=4;break; /* SLA L : RL H */
			case CRC_H:___output(ae,0xCB);___output(ae,0x24);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x25);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x26);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x27);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x26);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x26);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLA reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLL (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x20);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x21);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x22);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x23);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x24);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x25);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x27);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLA (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLA reg8/(HL)/(IX+n)/(IY+n) or SLA (IX+n),reg8\n");
	}
}

void _SRA(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x28);___output(ae,0xCB);___output(ae,0x19);ae->nop+=4;break; /* SRA B : RR C */
			case CRC_B:___output(ae,0xCB);___output(ae,0x28);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x29);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x2A);___output(ae,0xCB);___output(ae,0x1B);ae->nop+=4;break; /* SRA D : RR E */
			case CRC_D:___output(ae,0xCB);___output(ae,0x2A);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x2B);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x2C);___output(ae,0xCB);___output(ae,0x1D);ae->nop+=4;break; /* SRA H : RR L */
			case CRC_H:___output(ae,0xCB);___output(ae,0x2C);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x2D);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x2E);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x2F);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x2E);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x2E);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRA reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRA (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x28);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x29);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2A);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2B);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2C);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2D);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x2F);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRA (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRA reg8/(HL)/(IX+n)/(IY+n) or SRA (IX+n),reg8\n");
	}
}


void _SLL(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x31);___output(ae,0xCB);___output(ae,0x10);ae->nop+=4;break; /* SLL C : RL B */
			case CRC_B:___output(ae,0xCB);___output(ae,0x30);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x31);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x33);___output(ae,0xCB);___output(ae,0x12);ae->nop+=4;break; /* SLL E : RL D */
			case CRC_D:___output(ae,0xCB);___output(ae,0x32);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x33);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x35);___output(ae,0xCB);___output(ae,0x14);ae->nop+=4;break; /* SLL L : RL H */
			case CRC_H:___output(ae,0xCB);___output(ae,0x34);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x35);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x36);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x37);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x36);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x36);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLL reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLL (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x30);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x31);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x32);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x33);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x34);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x35);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x37);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLL (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SLL reg8/(HL)/(IX+n)/(IY+n) or SLL (IX+n),reg8\n");
	}
}

void _SRL(struct s_assenv *ae) {
	/* on check qu'il y a un ou deux parametres */
	if (ae->wl[ae->idx+1].t==1) {
		switch (GetCRC(ae->wl[ae->idx+1].w)) {
			case CRC_BC:___output(ae,0xCB);___output(ae,0x38);___output(ae,0xCB);___output(ae,0x11);ae->nop+=4;break; /* SRL B : RL C */
			case CRC_B:___output(ae,0xCB);___output(ae,0x38);ae->nop+=2;break;
			case CRC_C:___output(ae,0xCB);___output(ae,0x39);ae->nop+=2;break;
			case CRC_DE:___output(ae,0xCB);___output(ae,0x3A);___output(ae,0xCB);___output(ae,0x13);ae->nop+=4;break; /* SRL D : RL E */
			case CRC_D:___output(ae,0xCB);___output(ae,0x3A);ae->nop+=2;break;
			case CRC_E:___output(ae,0xCB);___output(ae,0x3B);ae->nop+=2;break;
			case CRC_HL:___output(ae,0xCB);___output(ae,0x3C);___output(ae,0xCB);___output(ae,0x15);ae->nop+=4;break; /* SRL H : RL L */
			case CRC_H:___output(ae,0xCB);___output(ae,0x3C);ae->nop+=2;break;
			case CRC_L:___output(ae,0xCB);___output(ae,0x3D);ae->nop+=2;break;
			case CRC_MHL:___output(ae,0xCB);___output(ae,0x3E);ae->nop+=4;break;
			case CRC_A:___output(ae,0xCB);___output(ae,0x3F);ae->nop+=2;break;
			default:
				if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
					___output(ae,0xDD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x3E);
					ae->nop+=7;
				} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
					___output(ae,0xFD);___output(ae,0xCB);
					PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);
					___output(ae,0x3E);
					ae->nop+=7;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRL reg8/(HL)/(IX+n)/(IY+n)\n");
				}
		}
		ae->idx++;
	} else if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
		if (strncmp(ae->wl[ae->idx+1].w,"(IX",3)==0) {
			___output(ae,0xDD);
		} else if (strncmp(ae->wl[ae->idx+1].w,"(IY",3)==0) {
			___output(ae,0xFD);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRL (IX+n),reg8\n");
		}
		___output(ae,0xCB);
		switch (GetCRC(ae->wl[ae->idx+2].w)) {
			case CRC_B:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x38);ae->nop+=7;break;
			case CRC_C:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x39);ae->nop+=7;break;
			case CRC_D:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3A);ae->nop+=7;break;
			case CRC_E:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3B);ae->nop+=7;break;
			case CRC_H:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3C);ae->nop+=7;break;
			case CRC_L:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3D);ae->nop+=7;break;
			case CRC_A:PushExpression(ae,ae->idx+1,E_EXPRESSION_IV8);___output(ae,0x3F);ae->nop+=7;break;
			default:			
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRL (IX+n),reg8\n");
		}
		ae->idx++;
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SRL reg8/(HL)/(IX+n)/(IY+n) or SRL (IX+n),reg8\n");
	}
}


void _BIT(struct s_assenv *ae) {
	int o;
	/* on check qu'il y a deux ou trois parametres 
	ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
	o=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0);*/

	o=0;
	if (o<0 || o>7) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BIT <value from 0 to 7>,... (%d)\n",o);
	} else {
		o=0x40+o*8;
		if (ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
			switch (GetCRC(ae->wl[ae->idx+2].w)) {
				case CRC_B:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=2;break;
				case CRC_C:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=2;break;
				case CRC_D:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=2;break;
				case CRC_E:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=2;break;
				case CRC_H:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=2;break;
				case CRC_L:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=2;break;
				case CRC_MHL:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);ae->nop+=3;break;
				case CRC_A:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=2;break;
				default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=6;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=6;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BIT n,reg8/(HL)/(IX+n)/(IY+n)\n");
					}
			}
			ae->idx+=2;
		} else if (!ae->wl[ae->idx+1].t && !ae->wl[ae->idx+2].t && ae->wl[ae->idx+3].t==1) {
			if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
				___output(ae,0xDD);
			} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
				___output(ae,0xFD);
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BIT (IX+n),reg8\n");
			}
			___output(ae,0xCB);
			switch (GetCRC(ae->wl[ae->idx+3].w)) {
				case CRC_B:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=6;break;
				case CRC_C:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=6;break;
				case CRC_D:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=6;break;
				case CRC_E:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=6;break;
				case CRC_H:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=6;break;
				case CRC_L:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=6;break;
				case CRC_A:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=6;break;
				default:			
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BIT n,(IX+n),reg8\n");
			}
			ae->idx+=3;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BIT n,reg8/(HL)/(IX+n)[,reg8]/(IY+n)[,reg8]\n");
		}
	}
}

void _RES(struct s_assenv *ae) {
	int o;
	/* on check qu'il y a deux ou trois parametres 
	ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
	o=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0); */
	o=0;
	if (o<0 || o>7) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RES <value from 0 to 7>,... (%d)\n",o);
	} else {
		o=0x80+o*8;
		if (ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
			switch (GetCRC(ae->wl[ae->idx+2].w)) {
				case CRC_B:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=2;break;
				case CRC_C:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=2;break;
				case CRC_D:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=2;break;
				case CRC_E:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=2;break;
				case CRC_H:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=2;break;
				case CRC_L:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=2;break;
				case CRC_MHL:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);ae->nop+=4;break;
				case CRC_A:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=2;break;
				default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=7;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=7;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RES n,reg8/(HL)/(IX+n)/(IY+n)\n");
					}
			}
			ae->idx+=2;
		} else if (!ae->wl[ae->idx+1].t && !ae->wl[ae->idx+2].t && ae->wl[ae->idx+3].t==1) {
			if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
				___output(ae,0xDD);
			} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
				___output(ae,0xFD);
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RES n,(IX+n),reg8\n");
			}
			___output(ae,0xCB);
			switch (GetCRC(ae->wl[ae->idx+3].w)) {
				case CRC_B:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=7;break;
				case CRC_C:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=7;break;
				case CRC_D:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=7;break;
				case CRC_E:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=7;break;
				case CRC_H:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=7;break;
				case CRC_L:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=7;break;
				case CRC_A:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=7;break;
				default:			
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RES n,(IX+n),reg8\n");
			}
			ae->idx+=3;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is RES n,reg8/(HL)/(IX+n)[,reg8]/(IY+n)[,reg8]\n");
		}
	}
}

void _SET(struct s_assenv *ae) {
	int o;
	/* on check qu'il y a deux ou trois parametres 
	ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
	o=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0); */
	o=0;
	if (o<0 || o>7) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SET <value from 0 to 7>,... (%d)\n",o);
	} else {
		o=0xC0+o*8;
		if (ae->wl[ae->idx+1].t==0 && ae->wl[ae->idx+2].t==1) {
			switch (GetCRC(ae->wl[ae->idx+2].w)) {
				case CRC_B:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=2;break;
				case CRC_C:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=2;break;
				case CRC_D:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=2;break;
				case CRC_E:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=2;break;
				case CRC_H:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=2;break;
				case CRC_L:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=2;break;
				case CRC_MHL:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);ae->nop+=4;break;
				case CRC_A:___output(ae,0xCB);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=2;break;
				default:
					if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
						___output(ae,0xDD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=7;
					} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
						___output(ae,0xFD);___output(ae,0xCB);
						PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);
						PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x6+o);
						ae->nop+=7;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SET n,reg8/(HL)/(IX+n)/(IY+n)\n");
					}
			}
			ae->idx+=2;
		} else if (!ae->wl[ae->idx+1].t && !ae->wl[ae->idx+2].t && ae->wl[ae->idx+3].t==1) {
			if (strncmp(ae->wl[ae->idx+2].w,"(IX",3)==0) {
				___output(ae,0xDD);
			} else if (strncmp(ae->wl[ae->idx+2].w,"(IY",3)==0) {
				___output(ae,0xFD);
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SET n,(IX+n),reg8\n");
			}
			___output(ae,0xCB);
			switch (GetCRC(ae->wl[ae->idx+3].w)) {
				case CRC_B:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x0+o);ae->nop+=7;break;
				case CRC_C:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x1+o);ae->nop+=7;break;
				case CRC_D:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x2+o);ae->nop+=7;break;
				case CRC_E:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x3+o);ae->nop+=7;break;
				case CRC_H:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x4+o);ae->nop+=7;break;
				case CRC_L:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x5+o);ae->nop+=7;break;
				case CRC_A:PushExpression(ae,ae->idx+2,E_EXPRESSION_IV8);PushExpression(ae,ae->idx+1,E_EXPRESSION_BRS);___output(ae,0x7+o);ae->nop+=7;break;
				default:			
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SET n,(IX+n),reg8\n");
			}
			ae->idx+=3;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is SET n,reg8/(HL)/(IX+n)[,reg8]/(IY+n)[,reg8]\n");
		}
	}
}

void _DEFS(struct s_assenv *ae) {
	int i,r,v;
	if (ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Syntax is DEFS repeat,value or DEFS repeat\n");
	} else do {
		ae->idx++;
		if (!ae->wl[ae->idx].t) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0); /* doing FastTranslate but not a complete evaluation */
			r=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->codeadr,0);
			if (r<0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFS size must be greater or equal to zero\n");
			}
			for (i=0;i<r;i++) {
				/* keep flexibility */
				PushExpression(ae,ae->idx+1,E_EXPRESSION_0V8);
				ae->nop+=1;
			}
			ae->idx++;
		} else if (ae->wl[ae->idx].t==1) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			r=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->codeadr,0);
			v=0;
			if (r<0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFS size must be greater or equal to zero\n");
			}
			for (i=0;i<r;i++) {
				___output(ae,v);
				ae->nop+=1;
			}
		}
	} while (!ae->wl[ae->idx].t);
}

void _DEFS_struct(struct s_assenv *ae) {
	int i,r,v;
	if (ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Syntax is DEFS repeat,value or DEFS repeat\n");
	} else do {
		ae->idx++;
		if (!ae->wl[ae->idx].t) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			r=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->codeadr,0);
			v=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0);
			if (r<0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFS size must be greater or equal to zero\n");
			}
			for (i=0;i<r;i++) {
				___output(ae,v);
				ae->nop+=1;
			}
			ae->idx++;
		} else if (ae->wl[ae->idx].t==1) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			r=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->codeadr,0);
			v=0;
			if (r<0) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFS size must be greater or equal to zero\n");
			}
			for (i=0;i<r;i++) {
				___output(ae,v);
				ae->nop+=1;
			}
		}
	} while (!ae->wl[ae->idx].t);
}

void _STR(struct s_assenv *ae) {
	unsigned char c;
	int i,tquote;

	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			if ((tquote=StringIsQuote(ae->wl[ae->idx].w))!=0) {
				i=1;
				while (ae->wl[ae->idx].w[i] && ae->wl[ae->idx].w[i]!=tquote) {
					if (ae->wl[ae->idx].w[i]=='\\') {
						i++;
						/* no conversion on escaped chars */
						c=ae->wl[ae->idx].w[i];
						switch (c) {
							case 'b':c='\b';break;
							case 'v':c='\v';break;
							case 'f':c='\f';break;
							case '0':c='\0';break;
							case 'r':c='\r';break;
							case 'n':c='\n';break;
							case 't':c='\t';break;
							default:break;
						}						
						if (ae->wl[ae->idx].w[i+1]!=tquote) {
							___output(ae,c);
						} else {
							___output(ae,c|0x80);
						}
					} else {
						/* charset conversion on the fly */
						if (ae->wl[ae->idx].w[i+1]!=tquote) {
							___output(ae,ae->charset[(unsigned int)ae->wl[ae->idx].w[i]]);
						} else {
							___output(ae,ae->charset[(unsigned int)ae->wl[ae->idx].w[i]]|0x80);
						}
					}

					i++;
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"STR handle only quoted strings!\n");
			}
		} while (ae->wl[ae->idx].t==0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"STR needs one or more quotes parameters\n");
	}
}

/* Microsoft IEEE-754 40bits float value */
void _DEFF(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0VRMike);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFF needs one or more parameters\n");
		}
	}
}
void _DEFF_struct(struct s_assenv *ae) {
	unsigned char *rc;
	double v;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			/* conversion des symboles connus */
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			/* calcul de la valeur définitive de l'expression */
			v=ComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->outputadr,0);
			/* conversion en réel Amsdos */
			rc=__internal_MakeRosoftREAL(ae,v,0);
			___output(ae,rc[0]);___output(ae,rc[1]);___output(ae,rc[2]);___output(ae,rc[3]);___output(ae,rc[4]);			
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFF needs one or more parameters\n");
		}
	}
}


void _DEFR(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0VR);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFR needs one or more parameters\n");
		}
	}
}
void _DEFR_struct(struct s_assenv *ae) {
	unsigned char *rc;
	double v;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			/* conversion des symboles connus */
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			/* calcul de la valeur définitive de l'expression */
			v=ComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->outputadr,0);
			/* conversion en réel Amsdos */
			rc=__internal_MakeAmsdosREAL(ae,v,0);
			___output(ae,rc[0]);___output(ae,rc[1]);___output(ae,rc[2]);___output(ae,rc[3]);___output(ae,rc[4]);			
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFR needs one or more parameters\n");
		}
	}
}

void _DEFB(struct s_assenv *ae) {
	int i,tquote;
	unsigned char c;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			if ((tquote=StringIsQuote(ae->wl[ae->idx].w))!=0) {
				i=1;
				while (ae->wl[ae->idx].w[i] && ae->wl[ae->idx].w[i]!=tquote) {
					if (ae->wl[ae->idx].w[i]=='\\') {
						i++;
						/* no conversion on escaped chars */
						c=ae->wl[ae->idx].w[i];
						switch (c) {
							case 'e':___output(ae,0x1B);break;
							case 'a':___output(ae,0x07);break; // alarm
							case 'b':___output(ae,'\b');break;
							case 'v':___output(ae,'\v');break; // v-tab
							case 'f':___output(ae,'\f');break; // feed
							case '0':___output(ae,'\0');break;
							case 'r':___output(ae,'\r');break; // return
							case 'n':___output(ae,'\n');break; // carriage-return
							case 't':___output(ae,'\t');break; // tab
							default:
							___output(ae,c);
						}						
						ae->nop+=1;
					} else {
						/* charset conversion on the fly */
						___output(ae,ae->charset[(unsigned int)ae->wl[ae->idx].w[i]]);
						ae->nop+=1;
					}
					i++;
				}
			} else {
				PushExpression(ae,ae->idx,E_EXPRESSION_0V8);
				ae->nop+=1;
			}
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFB needs one or more parameters\n");
		}
	}
}
void _DEFB_struct(struct s_assenv *ae) {
	int i,tquote;
	unsigned char c;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			if ((tquote=StringIsQuote(ae->wl[ae->idx].w))!=0) {
				i=1;
				while (ae->wl[ae->idx].w[i] && ae->wl[ae->idx].w[i]!=tquote) {
					if (ae->wl[ae->idx].w[i]=='\\') {
						i++;
						/* no conversion on escaped chars */
						c=ae->wl[ae->idx].w[i];
						switch (c) {
							case 'b':___output(ae,'\b');break;
							case 'v':___output(ae,'\v');break;
							case 'f':___output(ae,'\f');break;
							case '0':___output(ae,'\0');break;
							case 'r':___output(ae,'\r');break;
							case 'n':___output(ae,'\n');break;
							case 't':___output(ae,'\t');break;
							default:
							___output(ae,c);
							ae->nop+=1;
						}						
					} else {
						/* charset conversion on the fly */
						___output(ae,ae->charset[(int)ae->wl[ae->idx].w[i]]);
						ae->nop+=1;
					}
					i++;
				}
			} else {
				int v;
				ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
				v=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->outputadr,0);
				___output(ae,v);
				ae->nop+=1;
			}
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFB needs one or more parameters\n");
		}
	}
}

void _DEFW(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0V16);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFW needs one or more parameters\n");
		}
	}
}

void _DEFW_struct(struct s_assenv *ae) {
	int v;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			v=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->outputadr,0);
			___output(ae,v&0xFF);___output(ae,(v>>8)&0xFF);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFW needs one or more parameters\n");
		}
	}
}

void _DEFI(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0V32);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFI needs one or more parameters\n");
		}
	}
}

void _DEFI_struct(struct s_assenv *ae) {
	int v;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
			v=RoundComputeExpressionCore(ae,ae->wl[ae->idx].w,ae->outputadr,0);
			___output(ae,v&0xFF);___output(ae,(v>>8)&0xFF);___output(ae,(v>>16)&0xFF);___output(ae,(v>>24)&0xFF);
		} while (ae->wl[ae->idx].t==0);
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFI needs one or more parameters\n");
		}
	}
}

void _DEFB_as80(struct s_assenv *ae) {
	int i,tquote;
	int modadr=0;

	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			if ((tquote=StringIsQuote(ae->wl[ae->idx].w))!=0) {
				i=1;
				while (ae->wl[ae->idx].w[i] && ae->wl[ae->idx].w[i]!=tquote) {
					if (ae->wl[ae->idx].w[i]=='\\') i++;
					/* charset conversion on the fly */
					___output(ae,ae->charset[(int)ae->wl[ae->idx].w[i]]);
					ae->nop+=1;
					ae->codeadr--;modadr++;
					i++;
				}
			} else {
				PushExpression(ae,ae->idx,E_EXPRESSION_0V8);
				ae->codeadr--;modadr++;
				ae->nop+=1;
			}
		} while (ae->wl[ae->idx].t==0);
		ae->codeadr+=modadr;
	} else {
		if (ae->getstruct) {
			___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFB needs one or more parameters\n");
		}
	}
}

void _DEFW_as80(struct s_assenv *ae) {
	int modadr=0;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0V16);
			ae->codeadr-=2;modadr+=2;
		} while (ae->wl[ae->idx].t==0);
		ae->codeadr+=modadr;
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFW needs one or more parameters\n");
		}
	}
}

void _DEFI_as80(struct s_assenv *ae) {
	int modadr=0;
	if (!ae->wl[ae->idx].t) {
		do {
			ae->idx++;
			PushExpression(ae,ae->idx,E_EXPRESSION_0V32);
			ae->codeadr-=4;modadr+=4;
		} while (ae->wl[ae->idx].t==0);
		ae->codeadr+=modadr;
	} else {
		if (ae->getstruct) {
			___output(ae,0);___output(ae,0);___output(ae,0);___output(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFI needs one or more parameters\n");
		}
	}
}
#if 0
void _DEFSTR(struct s_assenv *ae) {
	int i,tquote;
	unsigned char c;
	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		if (StringIsQuote(ae->wl[ae->idx+1].w) && StringIsQuote(ae->wl[ae->idx+2].w)) {
				i=1;
				while (ae->wl[ae->idx].w[i] && ae->wl[ae->idx].w[i]!=tquote) {
					if (ae->wl[ae->idx].w[i]=='\\') {
						i++;
						/* no conversion on escaped chars */
						c=ae->wl[ae->idx].w[i];
						switch (c) {
							case 'b':___output(ae,'\b');break;
							case 'v':___output(ae,'\v');break;
							case 'f':___output(ae,'\f');break;
							case '0':___output(ae,'\0');break;
							case 'r':___output(ae,'\r');break;
							case 'n':___output(ae,'\n');break;
							case 't':___output(ae,'\t');break;
							default:
							___output(ae,c);
						}						
					} else {
						/* charset conversion on the fly */
						___output(ae,ae->charset[(int)ae->wl[ae->idx].w[i]]);
					}
					i++;
				}
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFSTR needs two parameters\n");
	}
}
#endif

#undef FUNC
#define FUNC "Directive CORE"

void __internal_UpdateLZBlockIfAny(struct s_assenv *ae) {
	/* there was a crunched block opened in the previous bank */
	if (ae->lz>=0) {
		//ae->lzsection[ae->ilz-1].iorgzone=ae->io-1;
		//ae->lzsection[ae->ilz-1].ibank=ae->activebank;
	}
	ae->lz=-1;
}


void __AMSDOS(struct s_assenv *ae) {
	ae->amsdos=1;
}

void __internal_EXPORT(struct s_assenv *ae, int exportval) {
	struct s_label *curlabel;
	struct s_expr_dico *curdic;
	int ialias,crc,freeflag;
	char *localname;

	if (ae->wl[ae->idx].t) {
		/* without parameter enable/disable export */
		ae->autorise_export=exportval;
	} else while (!ae->wl[ae->idx].t) {
		ae->idx++;
		freeflag=0;
	
		/* local label */	
		if (ae->wl[ae->idx].w[0]=='.' && ae->lastgloballabel) {
			localname=MemMalloc(strlen(ae->wl[ae->idx].w)+1+ae->lastgloballabellen);
			sprintf(localname,"%s%s",ae->lastgloballabel,ae->wl[ae->idx].w);
			freeflag=1;
		} else {
			localname=ae->wl[ae->idx].w;
		}
		crc=GetCRC(localname);

		if ((curlabel=SearchLabel(ae,localname,crc))!=NULL) {
			curlabel->autorise_export=exportval;
			ae->label[curlabel->backidx].autorise_export=exportval;
		} else {
			if ((curdic=SearchDico(ae,ae->wl[ae->idx].w,crc))!=NULL) {
				curdic->autorise_export=exportval;
			} else {
				if ((ialias=SearchAlias(ae,crc,ae->wl[ae->idx].w))!=-1) {
					ae->alias[ialias].autorise_export=exportval;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"(E)NOEXPORT did not found [%s] in variables, labels or aliases\n",ae->wl[ae->idx].w);
				}
			}
		}
		if (freeflag) MemFree(localname);
	}
}
void __NOEXPORT(struct s_assenv *ae) {
	__internal_EXPORT(ae,0);
}
void __ENOEXPORT(struct s_assenv *ae) {
	__internal_EXPORT(ae,1);
}

void __BUILDZX(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BUILDZX does not need a parameter\n");
	}
	if (!ae->forcesnapshot && !ae->forcetape && !ae->forcecpr && !ae->forceROM) {
		ae->forcezx=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot select ZX output when already in Amstrad ROM/cartridge/snapshot/tape output\n");
	}
}
void __BUILDCPR(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1 && strcmp(ae->wl[ae->idx+1].w,"EXTENDED")==0) {
		ae->extendedCPR=1;
	} else if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BUILDCPR unknown parameter\n");
	}
	if (!ae->forcesnapshot && !ae->forcetape && !ae->forcezx && !ae->forceROM) {
		ae->forcecpr=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot select Amstrad cartridge output when already in ZX/ROM/snapshot/tape output\n");
	}
}
void __BUILDROM(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BUILDROM does not need a parameter\n");
	}
	if (!ae->forcesnapshot && !ae->forcetape && !ae->forcezx && !ae->forcecpr) {
		ae->forceROM=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot select ROM output when already in ZX/cartridge/snapshot/tape output\n");
	}
}
void __BUILDSNA(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		if (strcmp(ae->wl[ae->idx+1].w,"V2")==0) {
		ae->snapshot.version=2;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BUILDSNA unrecognized option\n");
		}
	}
	if (!ae->forcecpr && !ae->forcetape && !ae->forcezx && !ae->forceROM) {
		ae->forcesnapshot=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot select snapshot output when already in ZX/ROM/cartridge/tape output\n");
	}
}
void __BUILDTAPE(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BUILDTAPE does not need a parameter\n");
	}
	if (!ae->forcesnapshot && !ae->forcecpr && !ae->forcezx && !ae->forceROM) {
		ae->forcetape=1;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot select tape output when already in ZX/ROM/snapshot/cartridge output\n");
	}
}
	

void __LZSA1(struct s_assenv *ae) {
	struct s_lz_section curlz={0};
	
	if (!ae->wl[ae->idx].t) {
		ae->idx++;
		curlz.minmatch=atoi(ae->wl[ae->idx].w);
		if (!ae->wl[ae->idx].t) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZSA1 directive may only have 1 parameter\n");
		}
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.version=1;
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=18;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZSA2(struct s_assenv *ae) {
	struct s_lz_section curlz={0};
	
	if (!ae->wl[ae->idx].t) {
		ae->idx++;
		curlz.minmatch=atoi(ae->wl[ae->idx].w);
		if (!ae->wl[ae->idx].t) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZSA2 directive may only have 1 parameter\n");
		}
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.version=2;
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=18;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZAPU(struct s_assenv *ae) {
	struct s_lz_section curlz;
	
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=17;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZ4(struct s_assenv *ae) {
	struct s_lz_section curlz;
	
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=4;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZX7(struct s_assenv *ae) {
	struct s_lz_section curlz;
	
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=7;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZEXO(struct s_assenv *ae) {
	struct s_lz_section curlz;
	
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	#ifdef NO_3RD_PARTIES
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot use 3rd parties cruncher with this version of RASM\n");
		FreeAssenv(ae);
		exit(-5);
	#endif
	
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=8;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZ48(struct s_assenv *ae) {
	struct s_lz_section curlz;

	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=48;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZ49(struct s_assenv *ae) {
	struct s_lz_section curlz;
	
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LZ directive does not need any parameter\n");
		return;
	}
	if (ae->lz>=0 && ae->lz<ae->ilz && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot start a new LZ section inside another one (%d)\n",ae->lz);
		FreeAssenv(ae);
		exit(-5);
	}
	
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=49;
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));
}
void __LZCLOSE(struct s_assenv *ae) {
	struct s_lz_section curlz;

	if (!ae->ilz || ae->lz==-1) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot close LZ section as it wasn't opened\n");
		return;
	}
	
	ae->lzsection[ae->ilz-1].memend=ae->outputadr;
	ae->lzsection[ae->ilz-1].ilabel=ae->il;
	ae->lzsection[ae->ilz-1].iexpr=ae->ie;
	// commentaire
	curlz.iw=ae->idx;
	curlz.iorgzone=ae->io-1;
	curlz.ibank=ae->activebank;
	curlz.memstart=ae->outputadr;
	curlz.memend=-1;
	curlz.lzversion=0; // intermediate zone
	ae->lz=ae->ilz;
	ObjectArrayAddDynamicValueConcat((void**)&ae->lzsection,&ae->ilz,&ae->mlz,&curlz,sizeof(curlz));

	//ae->lz=-1;
}

void __LIMIT(struct s_assenv *ae) {
	if (ae->wl[ae->idx+1].t!=2) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		___output_set_limit(ae,RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->outputadr,0,0));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LIMIT directive need one integer parameter\n");
	}
}
void OverWriteCheck(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "OverWriteCheck"
	
	int i,j;
	
	/* overwrite checking */
	i=ae->io-1; {
		if (ae->orgzone[i].memstart!=ae->orgzone[i].memend) {
			for (j=0;j<ae->io-1;j++) {
				if (ae->orgzone[j].memstart!=ae->orgzone[j].memend && !ae->orgzone[j].nocode) {
					if (ae->orgzone[i].ibank==ae->orgzone[j].ibank) {
						if ((ae->orgzone[i].memstart>=ae->orgzone[j].memstart && ae->orgzone[i].memstart<ae->orgzone[j].memend)
							|| (ae->orgzone[i].memend>ae->orgzone[j].memstart && ae->orgzone[i].memend<ae->orgzone[j].memend)
							|| (ae->orgzone[i].memstart<=ae->orgzone[j].memstart && ae->orgzone[i].memend>=ae->orgzone[j].memend)) {
							ae->idx--;
							if (ae->orgzone[j].protect) {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"PROTECTED section error [%s] L%d [#%04X-#%04X-B%d] with [%s] L%d [#%04X/#%04X]\n",ae->filename[ae->orgzone[j].ifile],ae->orgzone[j].iline,ae->orgzone[j].memstart,ae->orgzone[j].memend,ae->orgzone[j].ibank<32?ae->orgzone[j].ibank:0,ae->filename[ae->orgzone[i].ifile],ae->orgzone[i].iline,ae->orgzone[i].memstart,ae->orgzone[i].memend);
							} else {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Assembling overwrite [%s] L%d [#%04X-#%04X-B%d] with [%s] L%d [#%04X/#%04X]\n",ae->filename[ae->orgzone[j].ifile],ae->orgzone[j].iline,ae->orgzone[j].memstart,ae->orgzone[j].memend,ae->orgzone[j].ibank<32?ae->orgzone[j].ibank:0,ae->filename[ae->orgzone[i].ifile],ae->orgzone[i].iline,ae->orgzone[i].memstart,ae->orgzone[i].memend);
							}
							i=j=ae->io;
							break;
						}
					}
				}
			}
		}
	}	
}

void ___new_memory_space(struct s_assenv *ae)
{
	#undef FUNC
	#define FUNC "___new_memory_space"
	
	unsigned char *mem;
	struct s_orgzone orgzone={0};

	__internal_UpdateLZBlockIfAny(ae);
	if (ae->io) {
		ae->orgzone[ae->io-1].memend=ae->outputadr;
	}
	if (ae->lz>=0) {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: LZ section wasn't closed before a new memory space directive\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
		__LZCLOSE(ae);
	}
	ae->activebank=ae->nbbank;
	mem=MemMalloc(65536);
	memset(mem,0,65536);
	ObjectArrayAddDynamicValueConcat((void**)&ae->mem,&ae->nbbank,&ae->maxbank,&mem,sizeof(mem));

	ae->outputadr=0;
	ae->codeadr=0;
	orgzone.memstart=0;
	orgzone.ibank=ae->activebank;
	orgzone.nocode=ae->nocode=0;
	orgzone.inplace=1;
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));

	OverWriteCheck(ae);
}

void __BANK(struct s_assenv *ae) {
	struct s_orgzone orgzone={0};
	int oldcode=0,oldoutput=0;
	int i;
	__internal_UpdateLZBlockIfAny(ae);

	if (ae->io) {
		ae->orgzone[ae->io-1].memend=ae->outputadr;
	}
	/* without parameter, create a new empty space */
	if (ae->wl[ae->idx].t==1) {
		___new_memory_space(ae);
		return;
	}
	
	ae->bankmode=1;
	/* using BANK without build mode will select cartridge output as default */
	if (!ae->forceROM && !ae->forcecpr && !ae->forcesnapshot && !ae->forcezx) ae->forcecpr=1;

	if (ae->wl[ae->idx+1].t!=2) {
		if (strcmp(ae->wl[ae->idx+1].w,"NEXT")==0) {
			/* are we in a temporary space or in the very last bank? */
			if (ae->activebank>=260-1) {
				___new_memory_space(ae);
				return;
			}
			/* switch to next bank! */
			ae->activebank++;
		} else {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			ae->activebank=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		}
		if (ae->forcecpr && (ae->activebank<0 || ae->activebank>31) && !ae->extendedCPR) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank selection must be from 0 to 31 in cartridge mode\n");
			FreeAssenv(ae);
			exit(2);
		} else if (ae->extendedCPR && (ae->activebank<0 || ae->activebank>256) && !ae->extendedCPR) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank selection must be from 0 to 256 in extended cartridge mode\n");
			FreeAssenv(ae);
			exit(2);
		} else if (ae->forcezx && (ae->activebank<0 || ae->activebank>7)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank selection must be from 0 to 7 in ZX Spectrum mode\n");
			FreeAssenv(ae);
			exit(2);
		} else if (ae->forceROM && (ae->activebank<0 || ae->activebank>=256)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank selection must be from 0 to 255 in ROM mode\n");
			FreeAssenv(ae);
			exit(2);
		} else if (ae->forcesnapshot && (ae->activebank<0 || ae->activebank>=260)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank selection must be from 0 to 259 in snapshot mode\n");
			FreeAssenv(ae);
			exit(2);
		}
		/* bankset control */
		if (ae->forcesnapshot && ae->bankset[ae->activebank/4]) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot BANK %d was already select by a previous BANKSET %d\n",ae->activebank,(int)ae->activebank/4);
			ae->idx++;
			return;
		} else {
			ae->bankused[ae->activebank]=1;
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BANK directive need one integer parameter\n");
		return;
	}
	if (ae->lz>=0) {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: LZ section wasn't closed before a new BANK directive\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
		__LZCLOSE(ae);
	}

	/* try to get an old ORG settings backward */
	for (i=ae->io-1;i>=0;i--) {
		if (ae->orgzone[i].ibank==ae->activebank) {
			oldcode=ae->orgzone[i].memend;
			oldoutput=ae->orgzone[i].memend;
			break;
		}
	}
	ae->outputadr=oldoutput;
	ae->codeadr=oldcode;
	orgzone.memstart=ae->outputadr;
	/* legacy */
	orgzone.ibank=ae->activebank;
	orgzone.nocode=ae->nocode=0;
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));

	OverWriteCheck(ae);
}

void __BANKSET(struct s_assenv *ae) {
	struct s_orgzone orgzone={0};
	int ibank;

	__internal_UpdateLZBlockIfAny(ae);

	if (!ae->forcesnapshot && !ae->forcecpr && !ae->forcezx && !ae->forceROM) ae->forcesnapshot=1;
	if (!ae->forcesnapshot) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BANKSET directive is specific to snapshot output\n");
		return;
	}
	
	if (ae->io) {
		ae->orgzone[ae->io-1].memend=ae->outputadr;
	}
	ae->bankmode=1;
	
	if (ae->wl[ae->idx+1].t!=2) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		ae->activebank=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		ae->activebank*=4;
		if (ae->forcesnapshot && (ae->activebank<0 || ae->activebank>=260)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"FATAL - Bank set selection must be from 0 to 64 in snapshot mode\n");
			FreeAssenv(ae);
			exit(2);
		}
		/* control */
		ibank=ae->activebank;
		if (ae->bankused[ibank] || ae->bankused[ibank+1]|| ae->bankused[ibank+2]|| ae->bankused[ibank+3]) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot BANKSET because bank %d was already selected in single page mode\n",ibank);
			ae->idx++;
			return;
		} else {	
			ae->bankset[ae->activebank/4]=1; /* pas très heureux mais bon... */
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BANKSET directive need one integer parameter\n");
		return;
	}
	if (ae->lz>=0) {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: LZ section wasn't closed before a new BANKSET directive\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
		__LZCLOSE(ae);
	}

	ae->outputadr=0;
	ae->codeadr=0;
	orgzone.memstart=0;
	orgzone.ibank=ae->activebank;
	orgzone.nocode=ae->nocode=0;
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));

	OverWriteCheck(ae);
}


void __NameBANK(struct s_assenv *ae) {
	int ibank;

	ae->bankmode=1;
	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		if (!StringIsQuote(ae->wl[ae->idx+2].w)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Syntax is NAMEBANK <bank number>,'<string>'\n");
		} else {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			ibank=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
			if (ibank<0 || ibank>=BANK_MAX_NUMBER) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NAMEBANK selection must be from 0 to %d\n",BANK_MAX_NUMBER);
			} else {
				ae->iwnamebank[ibank]=ae->idx+2;
			}
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NAMEBANK directive need one integer parameter and a string\n");
	}
}

/***
	Winape little compatibility for CPR writing!
*/
void __WRITE(struct s_assenv *ae) {
	int ok=0;
	int lower=-1,upper=-1,bank=-1;

	if (!ae->wl[ae->idx].t && strcmp(ae->wl[ae->idx+1].w,"DIRECT")==0 && !ae->wl[ae->idx+1].t) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
		lower=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,ae->codeadr,0,0);
		if (!ae->wl[ae->idx+2].t) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,0);
			upper=RoundComputeExpression(ae,ae->wl[ae->idx+3].w,ae->codeadr,0,0);
		}
		if (!ae->wl[ae->idx+3].t) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+4].w,0);
			bank=RoundComputeExpression(ae,ae->wl[ae->idx+4].w,ae->codeadr,0,0);
		}

		if (ae->maxam) {
			if (lower==65535) lower=-1;
			if (upper==65535) upper=-1;
			if (bank==65535) bank=-1;
		}

		if (lower!=-1) {
			if (lower>=0 && lower<8) {
				ae->idx+=1;
				__BANK(ae);	
				ok=1;
			} else {
				if (!ae->nowarning) {
					rasm_printf(ae,KWARNING"[%s:%d] Warning: WRITE DIRECT lower ROM ignored (value %d out of bounds 0-7)\n",GetCurrentFile(ae),ae->wl[ae->idx].l,lower);
					if (ae->erronwarn) MaxError(ae);
				}
			}
		} else if (upper!=-1) {
			if (upper>=0 && ((ae->forcecpr && upper<32) || (ae->forcesnapshot && upper<BANK_MAX_NUMBER))) {
				ae->idx+=2;
				__BANK(ae);	
				ok=1;
			} else {
				if (!ae->forcecpr && !ae->forcesnapshot) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: WRITE DIRECT select a ROM without cartridge output\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
						if (ae->erronwarn) MaxError(ae);
					}
				} else {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: WRITE DIRECT upper ROM ignored (value %d out of bounds 0-31)\n",GetCurrentFile(ae),ae->wl[ae->idx].l,upper);
						if (ae->erronwarn) MaxError(ae);
					}
				}
			}
		} else if (bank!=-1) {
			/* selection de bank on ouvre un nouvel espace */
		} else {
			if (!ae->nowarning) {
				rasm_printf(ae,KWARNING"[%s:%d] Warning: meaningless WRITE DIRECT\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
				if (ae->erronwarn) MaxError(ae);
			}
		}
	}
	while (!ae->wl[ae->idx].t) ae->idx++;
	if (!ok) {
		___new_memory_space(ae);
	}
}
void __CHARSET(struct s_assenv *ae) {
	int i,s,e,v,tquote;

	if (ae->wl[ae->idx].t==1) {
		/* reinit charset */
		for (i=0;i<256;i++)
			ae->charset[i]=i;
	} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		/* string,value | byte,value */
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
		v=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,ae->codeadr,0,0);
		if (ae->wl[ae->idx+1].w[0]=='\'' || ae->wl[ae->idx+1].w[0]=='"') {
			tquote=ae->wl[ae->idx+1].w[0];
			if (ae->wl[ae->idx+1].w[strlen(ae->wl[ae->idx+1].w)-1]==tquote) {
				i=1;
				while (ae->wl[ae->idx+1].w[i] && ae->wl[ae->idx+1].w[i]!=tquote) {
					if (ae->wl[ae->idx+1].w[i]=='\\') i++;
					ae->charset[(int)ae->wl[ae->idx+1].w[i]]=(unsigned char)v++;
					i++;
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CHARSET string,value has invalid quote!\n");
			}
		} else {
			i=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
			if (i>=0 && i<256) {
				ae->charset[i]=(unsigned char)v;
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CHARSET byte value must be 0-255\n");
			}
		}
		ae->idx+=2;
	} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && !ae->wl[ae->idx+2].t && ae->wl[ae->idx+3].t==1) {
		/* start,end,value */
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,0);
		s=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		e=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,ae->codeadr,0,0);
		v=RoundComputeExpression(ae,ae->wl[ae->idx+3].w,ae->codeadr,0,0);
		ae->idx+=3;
		if (s<=e && s>=0 && e<256) {
			for (i=s;i<=e;i++) {
				ae->charset[i]=(unsigned char)v++;
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CHARSET Winape directive wrong interval value\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CHARSET Winape directive wrong parameter count\n");
	}
}

void PushGlobal(struct s_assenv *ae) {
	char *zelast;
	if (ae->lastgloballabel) zelast=TxtStrDup(ae->lastgloballabel); else zelast=NULL;
	ObjectArrayAddDynamicValueConcat((void **)&ae->globalstack,&ae->igs,&ae->mgs,&zelast,sizeof(char *));

#if TRACE_LABEL
printf("==> PushGlobal on Stack [%s] igs=%d\n",zelast,ae->igs);
#endif
}

void PopGlobal(struct s_assenv *ae) {
	if (ae->igs) {
		ae->igs--;
#if TRACE_LABEL
printf("<== PopGlobal on Stack [%s] igs=%d\n",ae->globalstack[ae->igs],ae->igs+1);
#endif
		if (ae->lastglobalalloc) MemFree(ae->lastgloballabel);

		if (ae->globalstack[ae->igs]) {
			ae->lastgloballabel=TxtStrDup(ae->globalstack[ae->igs]);
			ae->lastgloballabellen=strlen(ae->lastgloballabel);
			ae->lastglobalalloc=1;
		} else {
			ae->lastgloballabel=NULL;
			ae->lastgloballabellen=0;
			ae->lastglobalalloc=0;
		}

		if (ae->globalstack[ae->igs]) MemFree(ae->globalstack[ae->igs]);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"PopGlobal INTERNAL ERROR / Please report\n");
	}
}


void __MACRO(struct s_assenv *ae) {
	struct s_macro curmacro={0};
	char *referentfilename,*zeparam;
	int refidx,idx,getparam=1;
	struct s_wordlist curwl;
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t!=2) {
		/* get the name */
		curmacro.mnemo=ae->wl[ae->idx+1].w;
		curmacro.crc=GetCRC(curmacro.mnemo);
		if (ae->wl[ae->idx+1].t) {
			getparam=0;
		}
		/* overload forbidden */
		/* macro, keywords and directives forbidden */
		if (SearchMacro(ae,curmacro.crc,curmacro.mnemo)>=0) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro already defined with this name\n");
		} else {
			if ((SearchDico(ae,ae->wl[ae->idx+1].w,curmacro.crc))!=NULL) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro definition: There is already a variable with this name\n");
			} else {
				if ((SearchLabel(ae,ae->wl[ae->idx+1].w,curmacro.crc))!=NULL) {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro definition: There is already a label with this name\n");
				} else {
					if ((SearchAlias(ae,curmacro.crc,ae->wl[ae->idx+1].w))!=-1) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro definition: There is already an alias with this name\n");
					} else {
						if (IsRegister(curmacro.mnemo)) {
							MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro definition: Cannot choose a register as macro name\n");
						}
					}
				}
			}
		}

		idx=ae->idx+2;
		while (ae->wl[idx].t!=2 && (GetCRC(ae->wl[idx].w)!=CRC_MEND || strcmp(ae->wl[idx].w,"MEND")!=0) && (GetCRC(ae->wl[idx].w)!=CRC_ENDM || strcmp(ae->wl[idx].w,"ENDM")!=0)) {
			if (GetCRC(ae->wl[idx].w)==CRC_MACRO || strcmp(ae->wl[idx].w,"MACRO")==0) {
				/* inception interdite */
				referentfilename=GetCurrentFile(ae);
				refidx=ae->idx;
				ae->idx=idx;
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"You cannot define a macro inside another one (MACRO %s in [%s] L%d)\n",ae->wl[refidx+1].w,referentfilename,ae->wl[refidx].l);
				__STOP(ae);
			}
			if (getparam) {
				/* on prepare les parametres au remplacement */
				zeparam=MemMalloc(strlen(ae->wl[idx].w)+3);
				if (ae->as80) {
					sprintf(zeparam,"%s",ae->wl[idx].w);
				} else {
					sprintf(zeparam,"{%s}",ae->wl[idx].w);
				}
				curmacro.nbparam++;
				curmacro.param=MemRealloc(curmacro.param,curmacro.nbparam*sizeof(char **));
				curmacro.param[curmacro.nbparam-1]=zeparam;
				if (ae->wl[idx].t) {
					/* duplicate parameters without brackets MUST be an OPTION */
					getparam=0;
				}
			} else {
				/* copie la liste de mots */	
				curwl=ae->wl[idx];
				ObjectArrayAddDynamicValueConcat((void **)&curmacro.wc,&curmacro.nbword,&curmacro.maxword,&curwl,sizeof(struct s_wordlist));
			}
			idx++;
		}
		if (ae->wl[idx].t==2) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Macro was not closed\n");
		}
		ObjectArrayAddDynamicValueConcat((void**)&ae->macro,&ae->imacro,&ae->mmacro,&curmacro,sizeof(curmacro));
		/* le quicksort n'est pas optimal mais on n'est pas supposé en créer des milliers */
		qsort(ae->macro,ae->imacro,sizeof(struct s_macro),cmpmacros);

		/* ajustement des mots lus */
		if (ae->wl[idx].t==2) idx--;
		ae->idx=idx;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"MACRO definition need at least one parameter for the name of the macro\n");
	}
}

struct s_wordlist *__MACRO_EXECUTE(struct s_assenv *ae, int imacro) {
	struct s_wordlist *cpybackup;
	int nbparam=0,idx,i,j,idad;
	int ifile,iline,iu,lenparam;
	double v;
	struct s_macro_position curmacropos={0};
	char *zeparam=NULL,*txtparamlist;
	int reload=0;
	
	idx=ae->idx;
	while (!ae->wl[idx].t) {
		nbparam++;
		idx++;
	}

	/* hack to secure macro without parameters with void argument */
	if (!ae->macro[imacro].nbparam) {
		if (nbparam) {
			if (nbparam==1 && strcmp(ae->wl[ae->idx+1].w,"(VOID)")==0) {
				nbparam=0;
				reload=1;
			}
		} else {
			if (ae->macrovoid) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"MACRO [%s] used without (void) and option -void used!\n",ae->macro[imacro].mnemo);
			}
		}
	}
	/* macro must avoid extra params! */
	
	/* cannot VOID a macro with parameters! */
	if (ae->macro[imacro].nbparam && strcmp(ae->wl[ae->idx+1].w,"(VOID)")==0) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"MACRO [%s] has %d parameter%s\n",ae->macro[imacro].mnemo,ae->macro[imacro].nbparam,ae->macro[imacro].nbparam>1?"s":"");
		while (!ae->wl[ae->idx].t) {
			ae->idx++;
		}
		ae->idx++;
	} else {
		if (nbparam!=ae->macro[imacro].nbparam) {
			lenparam=1; // macro without parameters!
			for (i=0;i<ae->macro[imacro].nbparam;i++) {
				lenparam+=strlen(ae->macro[imacro].param[i])+3;
			}
			txtparamlist=MemMalloc(lenparam);
			txtparamlist[0]=0;
			for (i=0;i<ae->macro[imacro].nbparam;i++) {
				strcat(txtparamlist,ae->macro[imacro].param[i]);
				strcat(txtparamlist," ");
			}

			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"MACRO [%s] was defined with %d parameter%s %s\n",ae->macro[imacro].mnemo,ae->macro[imacro].nbparam,ae->macro[imacro].nbparam>1?"s":"",txtparamlist);
			while (!ae->wl[ae->idx].t) {
				ae->idx++;
			}
			ae->idx++;
		} else {
			/* free macro call as we will overwrite it */
			MemFree(ae->wl[ae->idx].w);
			/* is there a void to free? */
			if (reload) {
				MemFree(ae->wl[ae->idx+1].w);
			}
			/* eval parameters? */
			for (i=0;i<nbparam;i++) {
				if (strncmp(ae->wl[ae->idx+1+i].w,"{EVAL}",6)==0) {
					/* parametre entre chevrons, il faut l'interpreter d'abord */
					zeparam=TxtStrDup(ae->wl[ae->idx+1+i].w+6);
					ExpressionFastTranslate(ae,&zeparam,1);
					v=ComputeExpressionCore(ae,zeparam,ae->codeadr,0);
					MemFree(zeparam);
					zeparam=MemMalloc(32);
					snprintf(zeparam,31,"%lf",v);
					zeparam[31]=0;
					MemFree(ae->wl[ae->idx+1+i].w);
					ae->wl[ae->idx+1+i].w=zeparam;
				}
			}
			/* backup parameters */
			cpybackup=MemMalloc((nbparam+1)*sizeof(struct s_wordlist));
			for (i=0;i<nbparam;i++) {
				cpybackup[i]=ae->wl[ae->idx+1+i];
			}
			/************************
			  insert macro position
			*************************/
			curmacropos.start=ae->idx;
			curmacropos.end=ae->idx+ae->macro[imacro].nbword;
			curmacropos.value=ae->macrocounter;
			/* which level? */
			curmacropos.pushed=0;
			if (!ae->imacropos) {
				curmacropos.level=1;
			} else {
				if (ae->macropos[ae->imacropos-1].end<=curmacropos.start) {
					/* same level */
					curmacropos.level=ae->macropos[ae->imacropos-1].level;
				} else {
					/* inception */
					curmacropos.level=ae->macropos[ae->imacropos-1].level+1;
				}
			}

			ObjectArrayAddDynamicValueConcat((void**)&ae->macropos,&ae->imacropos,&ae->mmacropos,&curmacropos,sizeof(curmacropos));
			
			/* are we in a repeat/while block? */
			for (iu=0;iu<ae->ir;iu++) if (ae->repeat[iu].maxim<ae->imacropos) ae->repeat[iu].maxim=ae->imacropos;
			for (iu=0;iu<ae->iw;iu++) if (ae->whilewend[iu].maxim<ae->imacropos) ae->whilewend[iu].maxim=ae->imacropos;
			
			/* update daddy macropos */
			for (idad=0;idad<ae->imacropos-1;idad++) {
				if (ae->macropos[idad].end>curmacropos.start) {
					ae->macropos[idad].end+=ae->macro[imacro].nbword-1-nbparam-reload; /* coz la macro compte un mot! */
				}
			}
			
	#if 0
			for (idad=0;idad<ae->imacropos;idad++) {
				printf("macropos[%d]=%d -> %d\n",idad,ae->macropos[idad].start,ae->macropos[idad].end);
			}
	#endif		
			/* insert at macro position and replace macro+parameters */
			if (ae->macro[imacro].nbword>1+nbparam+reload) {
				ae->nbword+=ae->macro[imacro].nbword-1-nbparam-reload;
				ae->wl=MemRealloc(ae->wl,ae->nbword*sizeof(struct s_wordlist));
			} else {
				/* si on réduit pas de realloc pour ne pas perdre de donnees */
				ae->nbword+=ae->macro[imacro].nbword-1-nbparam-reload;
			}
			iline=ae->wl[ae->idx].l;
			ifile=ae->wl[ae->idx].ifile;
			MemMove(&ae->wl[ae->idx+ae->macro[imacro].nbword],&ae->wl[ae->idx+reload+nbparam+1],(ae->nbword-ae->idx-ae->macro[imacro].nbword)*sizeof(struct s_wordlist));

			for (i=0;i<ae->macro[imacro].nbword;i++) {
				ae->wl[i+ae->idx].w=TxtStrDup(ae->macro[imacro].wc[i].w);
				ae->wl[i+ae->idx].l=iline;
				ae->wl[i+ae->idx].ifile=ifile;
				/* @@@sujet a evolution, ou double controle */
				ae->wl[i+ae->idx].t=ae->macro[imacro].wc[i].t;
				ae->wl[i+ae->idx].e=ae->macro[imacro].wc[i].e;
			}
			/* replace */
			idx=ae->idx;
			for (i=0;i<nbparam;i++) {
				for (j=idx;j<idx+ae->macro[imacro].nbword;j++) {
					/* tags in upper case for replacement in quotes */
					if (StringIsQuote(ae->wl[j].w)) {
						int lm,touched;
						for (lm=touched=0;ae->wl[j].w[lm];lm++) {
							if (ae->wl[j].w[lm]=='{') touched++; else if (ae->wl[j].w[lm]=='}') touched--; else if (touched) ae->wl[j].w[lm]=toupper(ae->wl[j].w[lm]);
						}
					}
//printf("MACRO_EXECUTE word[%d]=[%s] param[%d]=[%s] cpybackup[%d]=[%s]\n",j,ae->wl[j].w,i,ae->macro[imacro].param[i],i,cpybackup[i].w);
					ae->wl[j].w=TxtReplace(ae->wl[j].w,ae->macro[imacro].param[i],cpybackup[i].w,0);
				}
				MemFree(cpybackup[i].w);
			}
			MemFree(cpybackup);

			/* look for specific tags */
			for (j=idx;j<idx+ae->macro[imacro].nbword;j++) {
				switch (GetCRC(ae->wl[j].w)) {
					case CRC_AF_HIGH:if (strcmp(ae->wl[j].w,"AF.HIGH")==0) strcpy(ae->wl[j].w,"A");break;
					case CRC_AF_LOW: if (strcmp(ae->wl[j].w,"AF.LOW")==0) strcpy(ae->wl[j].w,"F");break;
					case CRC_BC_HIGH:if (strcmp(ae->wl[j].w,"BC.HIGH")==0) strcpy(ae->wl[j].w,"B");break;
					case CRC_BC_LOW: if (strcmp(ae->wl[j].w,"BC.LOW")==0) strcpy(ae->wl[j].w,"C");break;
					case CRC_DE_HIGH:if (strcmp(ae->wl[j].w,"DE.HIGH")==0) strcpy(ae->wl[j].w,"D");break;
					case CRC_DE_LOW: if (strcmp(ae->wl[j].w,"DE.LOW")==0) strcpy(ae->wl[j].w,"E");break;
					case CRC_HL_HIGH:if (strcmp(ae->wl[j].w,"HL.HIGH")==0) strcpy(ae->wl[j].w,"H");break;
					case CRC_HL_LOW: if (strcmp(ae->wl[j].w,"HL.LOW")==0) strcpy(ae->wl[j].w,"L");break;
					case CRC_IX_HIGH:if (strcmp(ae->wl[j].w,"IX.HIGH")==0) strcpy(ae->wl[j].w,"XH");break;
					case CRC_IX_LOW: if (strcmp(ae->wl[j].w,"IX.LOW")==0) strcpy(ae->wl[j].w,"XL");break;
					case CRC_IY_HIGH:if (strcmp(ae->wl[j].w,"IY.HIGH")==0) strcpy(ae->wl[j].w,"YH");break;
					case CRC_IY_LOW: if (strcmp(ae->wl[j].w,"IY.LOW")==0) strcpy(ae->wl[j].w,"YL");break;
					default:break;
				}
			}

			/* macro replaced, need to rollback index */
			//ae->idx--;
		}
	}
	/* a chaque appel de macro on incremente le compteur pour les labels locaux */
	ae->macrocounter++;

	return ae->wl;
}

/*
	ticker start, <var>
	ticker stop, <var>
*/
void __TICKER(struct s_assenv *ae) {
	struct s_expr_dico *tvar;
	struct s_ticker ticker;
	int crc,i;

	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		crc=GetCRC(ae->wl[ae->idx+2].w);

		if (strcmp(ae->wl[ae->idx+1].w,"START")==0) {
			/* is there already a counter?  */
			for (i=0;i<ae->iticker;i++) {
				if (ae->ticker[i].crc==crc && strcmp(ae->wl[ae->idx+2].w,ae->ticker[i].varname)==0) {
					break;
				}
			}
			if (i==ae->iticker) {
				ticker.varname=TxtStrDup(ae->wl[ae->idx+2].w);
				ticker.crc=crc;
				ObjectArrayAddDynamicValueConcat((void **)&ae->ticker,&ae->iticker,&ae->mticker,&ticker,sizeof(struct s_ticker));
			}
			ae->ticker[i].nopstart=ae->nop;
		} else if (strcmp(ae->wl[ae->idx+1].w,"STOP")==0) {
			for (i=0;i<ae->iticker;i++) {
				if (ae->ticker[i].crc==crc && strcmp(ae->wl[ae->idx+2].w,ae->ticker[i].varname)==0) {
					break;
				}
			}
			if (i<ae->iticker) {
				/* set var */
				if ((tvar=SearchDico(ae,ae->wl[ae->idx+2].w,crc))!=NULL) {
					/* compute nop count */
					tvar->v=ae->nop-ae->ticker[i].nopstart;
				} else {
					/* create var with nop count */
					ExpressionSetDicoVar(ae,ae->wl[ae->idx+2].w,ae->nop-ae->ticker[i].nopstart);
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"TICKER not found\n");
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is TICKER start/stop,<variable>\n");
		}
		ae->idx+=2;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is TICKER start/stop,<variable>\n");
	}
}

void __LET(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ae->idx++;
		ExpressionFastTranslate(ae,&ae->wl[ae->idx].w,0);
		RoundComputeExpression(ae,ae->wl[ae->idx].w,ae->codeadr,0,0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LET useless Winape directive need one expression\n");
	}
}

void __RUN(struct s_assenv *ae) {
	int ramconf=0xC0;
	
	if (!ae->wl[ae->idx].t) {
		ae->current_run_idx=ae->idx+1;
		if (ae->forcezx) {
			if (!ae->wl[ae->idx].t) {
				PushExpression(ae,ae->idx+1,E_EXPRESSION_ZXRUN); // delayed RUN value
				PushExpression(ae,ae->idx+2,E_EXPRESSION_ZXSTACK); // delayed STACK value
				ae->idx+=2;
			} else {
				ae->idx++;
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is RUN <adress>,<stack> (ZX mode)\n");
			}
		} else {
			PushExpression(ae,ae->idx+1,E_EXPRESSION_RUN); // delayed RUN value
			ae->idx++;
			if (!ae->wl[ae->idx].t) {
				ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
				ramconf=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
				ae->idx++;
				if (ramconf<0xC0 || ramconf>0xFF) {
					if (!ae->nowarning) {
						rasm_printf(ae,KWARNING"[%s:%d] Warning: ram configuration out of bound %X forced to #C0\n",GetCurrentFile(ae),ae->wl[ae->idx].l,ramconf);
						if (ae->erronwarn) MaxError(ae);
					}
					ramconf=0xC0;
				}
				ae->snapshot.ramconfiguration=ramconf;
			}
		}
	} else {
		if (ae->forcezx) MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is RUN <adress>,<stack> (ZX mode)\n");
		else MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is RUN <adress>[,<ppi>]\n");
	}
	if (ae->rundefined && !ae->nowarning) {
		rasm_printf(ae,KWARNING"[%s:%d] Warning: run adress redefinition\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
		if (ae->erronwarn) MaxError(ae);
	}
	ae->rundefined=1;
}
void __BREAKPOINT(struct s_assenv *ae) {
	struct s_breakpoint breakpoint={0};
	
	if (ae->activebank>3) breakpoint.bank=1;
	if (ae->wl[ae->idx].t) {
		breakpoint.address=ae->codeadr;
		ObjectArrayAddDynamicValueConcat((void **)&ae->breakpoint,&ae->ibreakpoint,&ae->maxbreakpoint,&breakpoint,sizeof(struct s_breakpoint));
	} else 	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		breakpoint.address=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		ObjectArrayAddDynamicValueConcat((void **)&ae->breakpoint,&ae->ibreakpoint,&ae->maxbreakpoint,&breakpoint,sizeof(struct s_breakpoint));
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is BREAKPOINT [adress]\n");
	}
}

void __SNASET(struct s_assenv *ae) {
	int myvalue,idx;

	if (!ae->forcecpr && !ae->forcetape && !ae->forcezx && !ae->forceROM) {
		ae->forcesnapshot=1;
	} else {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: Cannot SNASET when already in ZX/ROM/cartridge/tape output\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
	}

	if (!ae->wl[ae->idx].t) {
		ae->idx++;
		/* TWO parameters */
		if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
			/* parameter value */
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			myvalue=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);

			/* Z80 register/value */
			if (strcmp(ae->wl[ae->idx].w,"Z80_AF")==0) {
				ae->snapshot.registers.general.F=myvalue&0xFF;
				ae->snapshot.registers.general.A=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_F")==0) {
				ae->snapshot.registers.general.F=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_A")==0) {
				ae->snapshot.registers.general.A=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_BC")==0) {
				ae->snapshot.registers.general.C=myvalue&0xFF;
				ae->snapshot.registers.general.B=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_C")==0) {
				ae->snapshot.registers.general.C=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_B")==0) {
				ae->snapshot.registers.general.B=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_DE")==0) {
				ae->snapshot.registers.general.E=myvalue&0xFF;
				ae->snapshot.registers.general.D=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_E")==0) {
				ae->snapshot.registers.general.E=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_D")==0) {
				ae->snapshot.registers.general.D=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_HL")==0) {
				ae->snapshot.registers.general.L=myvalue&0xFF;
				ae->snapshot.registers.general.H=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_L")==0) {
				ae->snapshot.registers.general.L=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_H")==0) {
				ae->snapshot.registers.general.H=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_I")==0) {
				ae->snapshot.registers.regI=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_R")==0) {
				ae->snapshot.registers.R=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IFF0")==0) {
				ae->snapshot.registers.IFF0=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IFF1")==0) {
				ae->snapshot.registers.IFF1=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IX")==0) {
				ae->snapshot.registers.LX=myvalue&0xFF;
				ae->snapshot.registers.HX=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IXL")==0) {
				ae->snapshot.registers.LX=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IXH")==0) {
				ae->snapshot.registers.HX=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IY")==0) {
				ae->snapshot.registers.LY=myvalue&0xFF;
				ae->snapshot.registers.HY=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IYL")==0) {
				ae->snapshot.registers.LY=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IYH")==0) {
				ae->snapshot.registers.HY=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_SP")==0) {
				ae->snapshot.registers.LSP=myvalue&0xFF;
				ae->snapshot.registers.HSP=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_PC")==0) {
				ae->snapshot.registers.LPC=myvalue&0xFF;
				ae->snapshot.registers.HPC=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_IM")==0) {
				ae->snapshot.registers.IM=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_AFX")==0) {
				ae->snapshot.registers.alternate.F=myvalue&0xFF;
				ae->snapshot.registers.alternate.A=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_AX")==0) {
				ae->snapshot.registers.alternate.A=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_FX")==0) {
				ae->snapshot.registers.alternate.F=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_BCX")==0) {
				ae->snapshot.registers.alternate.C=myvalue&0xFF;
				ae->snapshot.registers.alternate.B=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_CX")==0) {
				ae->snapshot.registers.alternate.C=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_BX")==0) {
				ae->snapshot.registers.alternate.B=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_DEX")==0) {
				ae->snapshot.registers.alternate.E=myvalue&0xFF;
				ae->snapshot.registers.alternate.D=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_EX")==0) {
				ae->snapshot.registers.alternate.E=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_DX")==0) {
				ae->snapshot.registers.alternate.D=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_HLX")==0) {
				ae->snapshot.registers.alternate.L=myvalue&0xFF;
				ae->snapshot.registers.alternate.H=(myvalue>>8)&0xFF;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_LX")==0) {
				ae->snapshot.registers.alternate.L=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"Z80_HX")==0) {
				ae->snapshot.registers.alternate.H=myvalue;
				/* Gate Array / CRTC / PPI / FDD */
			} else if (strcmp(ae->wl[ae->idx].w,"GA_PEN")==0) {
				ae->snapshot.gatearray.selectedpen=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"GA_ROMCFG")==0) {
				ae->snapshot.gatearray.multiconfiguration=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"GA_RAMCFG")==0) {
				ae->snapshot.ramconfiguration=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_SEL")==0) {
				ae->snapshot.crtc.selectedregister=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"ROM_UP")==0) {
				ae->snapshot.romselect=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PPI_A")==0) {
				ae->snapshot.ppi.portA=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PPI_B")==0) {
				ae->snapshot.ppi.portB=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PPI_C")==0) {
				ae->snapshot.ppi.portC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PPI_CTL")==0) {
				ae->snapshot.ppi.control=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PSG_SEL")==0) {
				ae->snapshot.psg.selectedregister=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CPC_TYPE")==0) {
				ae->snapshot.CPCType=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"INT_NUM")==0) {
				ae->snapshot.interruptnumber=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"FDD_MOTOR")==0) {
				ae->snapshot.fdd.motorstate=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"FDD_TRACK")==0) {
				ae->snapshot.fdd.physicaltrack=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"PRNT_DATA")==0) {
				ae->snapshot.printerstrobe=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_TYPE")==0) {
				ae->snapshot.crtcstate.model=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_HCC")==0) {
				ae->snapshot.crtcstate.HCC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_CLC")==0) {
				ae->snapshot.crtcstate.CLC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_RLC")==0) {
				ae->snapshot.crtcstate.RLC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_VAC")==0) { // Vertical Total Adjust Counter
				ae->snapshot.crtcstate.VTC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_HSWC")==0) {
				ae->snapshot.crtcstate.HSC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_VSWC")==0) {
				ae->snapshot.crtcstate.VSC=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_STATE")==0) {
				ae->snapshot.crtcstate.flags=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"GA_VSC")==0) {
				ae->snapshot.vsyncdelay=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"GA_ISC")==0) {
				ae->snapshot.interruptscanlinecounter=myvalue;
			} else if (strcmp(ae->wl[ae->idx].w,"INT_REQ")==0) {
				ae->snapshot.interruptrequestflag=myvalue;
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive unknown non array settings\n");
			}
		} else if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
			/* index value */
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			idx=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);

			/* parameter value */
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
			myvalue=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,ae->codeadr,0,0);

			if (strcmp(ae->wl[ae->idx].w,"GA_PAL")==0) {
				if (idx>=0 && idx<17) {
					ae->snapshot.gatearray.palette[idx]=myvalue;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive needs [0-16] index for GA_PAL\n");
				}
			} else if (strcmp(ae->wl[ae->idx].w,"CRTC_REG")==0) {
				if (idx>=0 && idx<18) {
					ae->snapshot.crtc.registervalue[idx]=myvalue;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive needs [0-17] index for CRTC_REG\n");
				}
			} else if (strcmp(ae->wl[ae->idx].w,"PSG_REG")==0) {
				if (idx>=0 && idx<16) {
					ae->snapshot.psg.registervalue[idx]=myvalue;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive needs [0-15] index for PSG_REG\n");
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive unknown array settings\n");
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SNASET directive need 2 or 3 parameters (see documentation for more informations)\n");
		}
	}


}


void __SETCPC(struct s_assenv *ae) {
	int mycpc;

	rasm_printf(ae,KWARNING"[%s:%d] Warning: SETCPC is deprecated, use SNASET CPC_TYPE,<type> instead\n",GetCurrentFile(ae),ae->wl[ae->idx].l);

	if (!ae->forcecpr && !ae->forceROM && !ae->forcezx) {
		ae->forcesnapshot=1;
	} else {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: Cannot SETCPC when already in ZX/ROM/cartridge output\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
	}

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		mycpc=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		ae->idx++;
		switch (mycpc) {
			case 0:
			case 1:
			case 2:
			case 4:
			case 5:
			case 6:
				ae->snapshot.CPCType=mycpc;
				break;
			default:
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SETCPC directive has wrong value (0,1,2,4,5,6 only)\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SETCPC directive need one integer parameter\n");
	}
}
void __SETCRTC(struct s_assenv *ae) {
	int mycrtc;

	rasm_printf(ae,KWARNING"[%s:%d] Warning: SETCRTC is deprecated, use SNASET CRTC_TYPE,<type> instead\n",GetCurrentFile(ae),ae->wl[ae->idx].l);

	if (!ae->forcecpr && !ae->forcezx && !ae->forceROM) {
		ae->forcesnapshot=1;
	} else {
		if (!ae->nowarning) {
			rasm_printf(ae,KWARNING"[%s:%d] Warning: Cannot SETCRTC when already in ZX/ROM/cartridge output\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
			if (ae->erronwarn) MaxError(ae);
		}
	}

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		mycrtc=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SETCRTC directive need one integer parameter\n");
		mycrtc=0;
	}
	switch (mycrtc) {
		case 0:
		case 1:
		case 2:
		case 3:
		case 4:
			ae->snapshot.crtcstate.model=mycrtc;
			break;
		default:
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SETCRTC directive has wrong value (0,1,2,3,4 only)\n");
	}
}


void __LIST(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"LIST Winape directive does not need parameter\n");
	}
}
void __NOLIST(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NOLIST Winape directive does not need parameter\n");
	}
}

void __BRK(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BRK Winape directive does not need parameter\n");
	} else {
		___output(ae,0xED);
		___output(ae,0xFF);
	}
}

void __STOP(struct s_assenv *ae) {
	rasm_printf(ae,"[%s:%d] STOP assembling requested\n",GetCurrentFile(ae),ae->wl[ae->idx].l);
	while (ae->wl[ae->idx].t!=2) ae->idx++;
	ae->idx--;
	ae->stop=1;
}

void __PRINT(struct s_assenv *ae) {
	while (ae->wl[ae->idx].t!=1) {
		if (!StringIsQuote(ae->wl[ae->idx+1].w)) {
			char *string2print=NULL;
			int hex=0,bin=0,entier=0;
			
			if (strncmp(ae->wl[ae->idx+1].w,"{HEX}",5)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+5);
				hex=1;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{HEX2}",6)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+6);
				hex=2;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{HEX4}",6)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+6);
				hex=4;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{HEX8}",6)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+6);
				hex=8;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{BIN}",5)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+5);
				bin=1;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{BIN8}",6)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+6);
				bin=8;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{BIN16}",7)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+7);
				bin=16;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{BIN32}",7)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+7);
				bin=32;
			} else if (strncmp(ae->wl[ae->idx+1].w,"{INT}",5)==0) {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w+5);
				entier=1;
			} else {
				string2print=TxtStrDup(ae->wl[ae->idx+1].w);
			}

			ExpressionFastTranslate(ae,&string2print,1);
			if (hex) {
				int zv;
				zv=RoundComputeExpressionCore(ae,string2print,ae->codeadr,0);
				switch (hex) {
					case 1:
						if (zv&0xFFFFFF00) {
							if (zv&0xFFFF0000) {
								rasm_printf(ae,"#%-8.08X ",zv);
							} else {
								rasm_printf(ae,"#%-4.04X ",zv);
							}
						} else {
							rasm_printf(ae,"#%-2.02X ",zv);
						}
						break;
					case 2:rasm_printf(ae,"#%-2.02X ",zv);break;
					case 4:rasm_printf(ae,"#%-4.04X ",zv);break;
					case 8:rasm_printf(ae,"#%-8.08X ",zv);break;
				}
			} else if (bin) {
				int zv,d;
				zv=RoundComputeExpressionCore(ae,string2print,ae->codeadr,0);
				/* remove useless sign bits */
				if (bin<32 && (zv&0xFFFF0000)==0xFFFF0000) {
					zv&=0xFFFF;
				}
				switch (bin) {
					case 1:if (zv&0xFF00) d=15; else d=7;break;
					case 8:d=7;break;
					case 16:d=15;break;
					case 32:d=31;break;
				}
				rasm_printf(ae,"%%");
				for (;d>=0;d--) {
					if ((zv>>d)&1) rasm_printf(ae,"1"); else rasm_printf(ae,"0");
				}
				rasm_printf(ae," ");
			} else if (entier) {
				rasm_printf(ae,"%d ",(int)RoundComputeExpressionCore(ae,string2print,ae->codeadr,0));
			} else {
				rasm_printf(ae,"%.2lf ",ComputeExpressionCore(ae,string2print,ae->codeadr,0));
			}
			MemFree(string2print);
		} else {
			char *varbuffer;
			int lm,touched;
			lm=strlen(ae->wl[ae->idx+1].w)-2;
			if (lm) {
				varbuffer=MemMalloc(lm+2);
				sprintf(varbuffer,"%-*.*s ",lm,lm,ae->wl[ae->idx+1].w+1);
				/* need to upper case tags */
				for (lm=touched=0;varbuffer[lm];lm++) {
					if (varbuffer[lm]=='{') touched++; else if (varbuffer[lm]=='}') touched--; else if (touched) varbuffer[lm]=toupper(varbuffer[lm]);
				}
				/* translate tag will check tag consistency */
				varbuffer=TranslateTag(ae,varbuffer,&touched,1,E_TAGOPTION_REMOVESPACE);
				varbuffer=TxtReplace(varbuffer,"\\b","\b",0);
				varbuffer=TxtReplace(varbuffer,"\\v","\v",0);
				varbuffer=TxtReplace(varbuffer,"\\f","\f",0);
				varbuffer=TxtReplace(varbuffer,"\\r","\r",0);
				varbuffer=TxtReplace(varbuffer,"\\n","\n",0);
				varbuffer=TxtReplace(varbuffer,"\\t","\t",0);
				rasm_printf(ae,"%s ",varbuffer);
				MemFree(varbuffer);
			}
		}
		ae->idx++;
	}
	rasm_printf(ae,"\n");
}

void __FAIL(struct s_assenv *ae) {
	__PRINT(ae);
	__STOP(ae);
	MaxError(ae);
}

void __ALIGN(struct s_assenv *ae) {
	int aval,ifill=-1;
	
	if (ae->io) {
		ae->orgzone[ae->io-1].memend=ae->outputadr;
	}
	if (!ae->wl[ae->idx].t) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		aval=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
		ae->idx++;
		/* align with fill ? */
		if (!ae->wl[ae->idx].t) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			ifill=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,0);
			ae->idx++;
			if (ifill<0 || ifill>255) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ALIGN fill value must be 0 to 255\n");
				ifill=0;
			}
		}

		if (aval<1 || aval>65535) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ALIGN boundary must be greater than zero and lower than 65536\n");
			aval=1;
		}

		/* touch codeadr only if adress is misaligned */
		if (ae->codeadr%aval) {
			if (ifill==-1) {
				/* virtual ALIGN is moving outputadr the same value as codeadr move */
				ae->outputadr=ae->outputadr-(ae->codeadr%aval)+aval;
				ae->codeadr=ae->codeadr-(ae->codeadr%aval)+aval;
			} else {
				/* physical ALIGN fill bytes */
				while (ae->codeadr%aval) {
					___output(ae,ifill);
					ae->nop+=1;
				}
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ALIGN <boundary>[,fill] directive need one or two integers parameters\n");
	}
}

void ___internal_skip_loop_block(struct s_assenv *ae, int eloopstyle) {
	int *loopstyle=NULL;
	int iloop=0,mloop=0;
	int cidx;

	cidx=ae->idx+2;

	IntArrayAddDynamicValueConcat(&loopstyle,&iloop,&mloop,eloopstyle);
	/* look for WEND */
	while (iloop) {
		if (strcmp(ae->wl[cidx].w,"REPEAT")==0) {
			if (ae->wl[cidx].t) {
				IntArrayAddDynamicValueConcat(&loopstyle,&iloop,&mloop,E_LOOPSTYLE_REPEATUNTIL);
			} else if (ae->wl[cidx+1].t) {
				IntArrayAddDynamicValueConcat(&loopstyle,&iloop,&mloop,E_LOOPSTYLE_REPEATN);
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid REPEAT syntax\n");
			}
		} else if (strcmp(ae->wl[cidx].w,"WHILE")==0) {
			if (!ae->wl[cidx].t && ae->wl[cidx+1].t) {
				IntArrayAddDynamicValueConcat(&loopstyle,&iloop,&mloop,E_LOOPSTYLE_WHILE);
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Invalid WHILE syntax\n");
			}
		} else if (strcmp(ae->wl[cidx].w,"WEND")==0) {
			iloop--;
			if (iloop<0) {
				iloop=0;
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WEND encountered that was not expected\n");
			} else if (loopstyle[iloop]!=E_LOOPSTYLE_WHILE) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WEND encountered but expecting %s\n",loopstyle[iloop]==E_LOOPSTYLE_REPEATN?"REND":"UNTIL");
			}
		} else if (strcmp(ae->wl[cidx].w,"REND")==0) {
			iloop--;
			if (iloop<0) {
				iloop=0;
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"REND encountered that was not expected\n");
			} else if (loopstyle[iloop]!=E_LOOPSTYLE_REPEATN) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"REND encountered but expecting %s\n",loopstyle[iloop]==E_LOOPSTYLE_REPEATUNTIL?"UNTIL":"WEND");
			}
		} else if (strcmp(ae->wl[cidx].w,"UNTIL")==0) {
			iloop--;
			if (iloop<0) {
				iloop=0;
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"UNTIL encountered that was not expected\n");
			} else if (loopstyle[iloop]!=E_LOOPSTYLE_REPEATUNTIL) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"UNTIL encountered but expecting %s\n",loopstyle[iloop]==E_LOOPSTYLE_REPEATN?"REND":"WEND");
			}
		}
		while (!ae->wl[cidx].t) cidx++;
		cidx++;
	}
	MemFree(loopstyle);
	ae->idx=cidx-1;
}

void __WHILE(struct s_assenv *ae) {
	struct s_whilewend whilewend={0};
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		if (!ComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,2)) {
				/* skip while block */
				___internal_skip_loop_block(ae,E_LOOPSTYLE_WHILE);
				return;
		} else {

			/*************************************************/
			/********* PUSH Global on Stack ******************/
			/*************************************************/
			PushGlobal(ae);

			ae->idx++;
			whilewend.start=ae->idx;
			whilewend.cpt=0;
			whilewend.value=ae->whilecounter;
			whilewend.maxim=ae->imacropos;
			whilewend.while_counter=1;
			ae->whilecounter++;
			/* pour gérer les macros situés dans le while précedent après un repeat/while courant */
			if (ae->iw) whilewend.maxim=ae->whilewend[ae->iw-1].maxim;
			if (ae->ir && ae->repeat[ae->ir-1].maxim>whilewend.maxim) whilewend.maxim=ae->repeat[ae->ir-1].maxim;
			ObjectArrayAddDynamicValueConcat((void**)&ae->whilewend,&ae->iw,&ae->mw,&whilewend,sizeof(whilewend));
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is WHILE <expression>\n");
	}
}
void __WEND(struct s_assenv *ae) {
	if (ae->iw>0) {
		if (ae->wl[ae->idx].t==1) {
			if (ComputeExpression(ae,ae->wl[ae->whilewend[ae->iw-1].start].w,ae->codeadr,0,2)) {
				if (ae->whilewend[ae->iw-1].while_counter>65536) {

					/*************************************************/
					/********* POP Global on Stack *******************/
					/*************************************************/
					PopGlobal(ae);

					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Bypass infinite WHILE loop\n");
					ae->iw--;
					/* refresh macro check index */
					if (ae->iw) ae->imacropos=ae->whilewend[ae->iw-1].maxim;
				} else {
					ae->whilewend[ae->iw-1].cpt++; /* for local label */
					ae->whilewend[ae->iw-1].while_counter++;
					ae->idx=ae->whilewend[ae->iw-1].start;
					/* refresh macro check index */
					ae->imacropos=ae->whilewend[ae->iw-1].maxim;
				}
			} else {

				/*************************************************/
				/********* POP Global on Stack *******************/
				/*************************************************/
				PopGlobal(ae);

				ae->iw--;
				/* refresh macro check index */
				if (ae->iw) ae->imacropos=ae->whilewend[ae->iw-1].maxim;
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WEND does not need any parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WEND encounter whereas there is no referent WHILE\n");
	}
}

void __REPEAT(struct s_assenv *ae) {
	struct s_repeat currepeat={0};
	struct s_expr_dico *rvar;
	int crc;


	
	if (ae->wl[ae->idx+1].t!=2) {
		if (ae->wl[ae->idx].t==0) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			currepeat.cpt=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,0,0,0);
			if (!currepeat.cpt) {
				/* skip repeat block */
				___internal_skip_loop_block(ae,E_LOOPSTYLE_REPEATN);
				return;
			} else if (currepeat.cpt<1 || currepeat.cpt>65536) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Repeat value (%d) must be from 1 to 65535. Skipping block\n",currepeat.cpt);
				___internal_skip_loop_block(ae,E_LOOPSTYLE_REPEATN);
				return;
			}
			ae->idx++;
			currepeat.start=ae->idx;
			if (ae->wl[ae->idx].t==0) {
				ae->idx++;
				if (ae->wl[ae->idx].t==1) {
					/* la variable peut exister -> OK */
					crc=GetCRC(ae->wl[ae->idx].w);
					if ((rvar=SearchDico(ae,ae->wl[ae->idx].w,crc))!=NULL) {
						rvar->v=1;
					} else {
						/* mais ne peut être un label ou un alias */
						ExpressionSetDicoVar(ae,ae->wl[ae->idx].w, 1);
					}
					currepeat.repeatvar=ae->wl[ae->idx].w;
					currepeat.repeatcrc=crc;
				} else {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"extended syntax is REPEAT <n>,<var>\n");
				}
			}
		} else {
			currepeat.start=ae->idx;
			currepeat.cpt=-1;
		}

		/*************************************************/
		/********* PUSH Global on Stack ******************/
		/*************************************************/
		PushGlobal(ae);

		currepeat.value=ae->repeatcounter;
		currepeat.repeat_counter=1;
		ae->repeatcounter++;
		/* pour gérer les macros situés dans le repeat précedent après le repeat courant */
		if (ae->ir) currepeat.maxim=ae->repeat[ae->ir-1].maxim;
		if (ae->iw && ae->whilewend[ae->iw-1].maxim>currepeat.maxim) currepeat.maxim=ae->whilewend[ae->iw-1].maxim;
		if (ae->imacropos>currepeat.maxim) currepeat.maxim=ae->imacropos;
		ObjectArrayAddDynamicValueConcat((void**)&ae->repeat,&ae->ir,&ae->mr,&currepeat,sizeof(currepeat));
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"wrong REPEAT usage\n");
	}
}

void __REND(struct s_assenv *ae) {
	struct s_expr_dico *rvar;
	if (ae->ir>0) {
		if (ae->repeat[ae->ir-1].cpt==-1) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"REND encounter whereas referent REPEAT was waiting for UNTIL\n");
		} else {
			ae->repeat[ae->ir-1].cpt--;
			ae->repeat[ae->ir-1].repeat_counter++;
			if ((rvar=SearchDico(ae,ae->repeat[ae->ir-1].repeatvar,ae->repeat[ae->ir-1].repeatcrc))!=NULL) {
				rvar->v=ae->repeat[ae->ir-1].repeat_counter;
			}
			if (ae->repeat[ae->ir-1].cpt) {
				ae->idx=ae->repeat[ae->ir-1].start;
				/* refresh macro check index */
				ae->imacropos=ae->repeat[ae->ir-1].maxim;
			} else {
				ae->ir--;
				/* refresh macro check index */
				if (ae->ir) ae->imacropos=ae->repeat[ae->ir-1].maxim;

				/*************************************************/
				/********* POP Global on Stack *******************/
				/*************************************************/
				PopGlobal(ae);

			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"REND encounter whereas there is no referent REPEAT\n");
	}
}

void __UNTIL(struct s_assenv *ae) {
	if (ae->ir>0) {
		if (ae->repeat[ae->ir-1].cpt>=0) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"[%s:%d] UNTIL encounter whereas referent REPEAT n was waiting for REND\n");
		} else {
			if (ae->wl[ae->idx].t==0 && ae->wl[ae->idx+1].t==1) {
				ae->repeat[ae->ir-1].repeat_counter++;
				ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
				if (!ComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,2)) {
					if (ae->repeat[ae->ir-1].repeat_counter>65536) {

						/*************************************************/
						/********* POP Global on Stack *******************/
						/*************************************************/
						PopGlobal(ae);

						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Bypass infinite REPEAT loop\n");
						ae->ir--;
						/* refresh macro check index */
						if (ae->ir) ae->imacropos=ae->repeat[ae->ir-1].maxim;
					} else {
						ae->idx=ae->repeat[ae->ir-1].start;
						ae->repeat[ae->ir-1].cpt--; /* for local label */
						/* refresh macro check index */
						ae->imacropos=ae->repeat[ae->ir-1].maxim;
					}
				} else {

					/*************************************************/
					/********* POP Global on Stack *******************/
					/*************************************************/
					PopGlobal(ae);

					ae->ir--;
					/* refresh macro check index */
					if (ae->ir) ae->imacropos=ae->repeat[ae->ir-1].maxim;
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"UNTIL need one expression/evaluation as parameter\n");
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"UNTIL encounter whereas there is no referent REPEAT\n");
	}
}

void __ASSERT(struct s_assenv *ae) {
	char Dot3[4];
	int rexpr;

	if (!ae->wl[ae->idx].t) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		if (strlen(ae->wl[ae->idx+1].w)>29) strcpy(Dot3,"..."); else strcpy(Dot3,"");
		rexpr=!!RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
		if (!rexpr) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx+1].l,"ASSERT %.29s%s failed with ",ae->wl[ae->idx+1].w,Dot3);
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,1);
			rasm_printf(ae,"%s\n",ae->wl[ae->idx+1].w);
 			if (!ae->wl[ae->idx+1].t) {
				ae->idx++;
				rasm_printf(ae,"-> ");
				__PRINT(ae);
			}
			__STOP(ae);
		} else {
			while (!ae->wl[ae->idx].t) ae->idx++;
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ASSERT need one expression\n");
	}
}

void __IF(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	int rexpr;

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		rexpr=!!RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
		ifthen.v=rexpr;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IF need one expression\n");
	}
}

void __IF_light(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		/* does not need to compute the value in shadow execution */
		ifthen.v=0;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IF need one expression\n");
	}
}

/* test if a label or a variable where used before */
void __IFUSED(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	int rexpr,crc;
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		crc=GetCRC(ae->wl[ae->idx+1].w);
		if ((SearchDico(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
			rexpr=1;
		} else {
			if ((SearchLabel(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
				rexpr=1;
			} else {
				if ((SearchAlias(ae,crc,ae->wl[ae->idx+1].w))!=-1) {
					rexpr=1;
				} else {
					rexpr=SearchUsed(ae,ae->wl[ae->idx+1].w,crc);
				}
			}
		}
		ifthen.v=rexpr;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFUSED;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFUSED need one variable or label\n");
	}
}
void __IFNUSED(struct s_assenv *ae) {
	__IFUSED(ae);
	ae->ifthen[ae->ii-1].v=1-ae->ifthen[ae->ii-1].v;
	ae->ifthen[ae->ii-1].type=E_IFTHEN_TYPE_IFNUSED;
}
void __IFUSED_light(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ifthen.v=0;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFUSED;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFUSED need one variable or label\n");
	}
}
void __IFNUSED_light(struct s_assenv *ae) {
	__IFUSED_light(ae);
	ae->ifthen[ae->ii-1].type=E_IFTHEN_TYPE_IFNUSED;
}

/* test if a label or a variable exists */
void __IFDEF(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	int rexpr,crc;
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		crc=GetCRC(ae->wl[ae->idx+1].w);
		if ((SearchDico(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
			rexpr=1;
		} else {
			if ((SearchLabel(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
				rexpr=1;
			} else {
				if ((SearchAlias(ae,crc,ae->wl[ae->idx+1].w))!=-1) {
					rexpr=1;
				} else {
					if (SearchMacro(ae,crc,ae->wl[ae->idx+1].w)>=0) {
						rexpr=1;
					} else {
						rexpr=0;
					}
				}
			}
		}
		ifthen.v=rexpr;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFDEF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFDEF need one variable or label\n");
	}
}
void __IFDEF_light(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ifthen.v=0;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFDEF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFDEF need one variable or label\n");
	}
}
void __IFNDEF(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	int rexpr,crc;


	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		crc=GetCRC(ae->wl[ae->idx+1].w);
		if ((SearchDico(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
			rexpr=0;
		} else {
			if ((SearchLabel(ae,ae->wl[ae->idx+1].w,crc))!=NULL) {
				rexpr=0;
			} else {
				if ((SearchAlias(ae,crc,ae->wl[ae->idx+1].w))!=-1) {
					rexpr=0;
				} else {
					if (SearchMacro(ae,crc,ae->wl[ae->idx+1].w)>=0) {
						rexpr=0;
					} else {
						rexpr=1;
					}
				}
			}
		}
		ifthen.v=rexpr;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFNDEF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFNDEF need one variable or label\n");
	}
}
void __IFNDEF_light(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};

	
	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ifthen.v=0;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFNDEF;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFNDEF need one variable or label\n");
	}
}

void __UNDEF(struct s_assenv *ae) {

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		/* no error when the variable to UNDEF does not exist */
		DelDico(ae,ae->wl[ae->idx+1].w,GetCRC(ae->wl[ae->idx+1].w));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"syntax is UNDEF <variable>\n");
	}

}


void __SWITCH(struct s_assenv *ae) {
	struct s_switchcase curswitch={0};

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		/* switch store the value */
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		curswitch.refval=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
		ObjectArrayAddDynamicValueConcat((void**)&ae->switchcase,&ae->isw,&ae->msw,&curswitch,sizeof(curswitch));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SWITCH need one expression\n");
	}
}
void __CASE(struct s_assenv *ae) {
	int rexpr;
	
	if (ae->isw) {
		if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			rexpr=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
			
			if (ae->switchcase[ae->isw-1].refval==rexpr) {
				ae->switchcase[ae->isw-1].execute=1;
				ae->switchcase[ae->isw-1].casematch=1;
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CASE not need one parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CASE encounter whereas there is no referent SWITCH\n");
	}
}
void __DEFAULT(struct s_assenv *ae) {
	
	if (ae->isw) {
		if (ae->wl[ae->idx].t==1) {
			/* aucun match avant, on active, sinon on laisse tel quel */
			if (!ae->switchcase[ae->isw-1].casematch) {
				ae->switchcase[ae->isw-1].execute=1;
			}
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFAULT does not need parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFAULT encounter whereas there is no referent SWITCH\n");
	}
}
void __BREAK(struct s_assenv *ae) {
	
	if (ae->isw) {
		if (ae->wl[ae->idx].t==1) {
			ae->switchcase[ae->isw-1].execute=0;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BREAK does not need parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BREAK encounter whereas there is no referent SWITCH\n");
	}
}
void __SWITCH_light(struct s_assenv *ae) {
	struct s_switchcase curswitch={0};

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		/* shadow execution */
		curswitch.refval=0;
		curswitch.execute=0;
		ObjectArrayAddDynamicValueConcat((void**)&ae->switchcase,&ae->isw,&ae->msw,&curswitch,sizeof(curswitch));
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SWITCH need one expression\n");
	}
}
void __CASE_light(struct s_assenv *ae) {
	if (ae->isw) {
		/* shadowed execution */
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CASE encounter whereas there is no referent SWITCH\n");
	}
}
void __DEFAULT_light(struct s_assenv *ae) {
	
	if (ae->isw) {
		/* shadowed execution */
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DEFAULT encounter whereas there is no referent SWITCH\n");
	}
}
void __BREAK_light(struct s_assenv *ae) {
	if (ae->isw) {
		/* shadowed execution */
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"BREAK encounter whereas there is no referent SWITCH\n");
	}
}
void __ENDSWITCH(struct s_assenv *ae) {
	if (ae->isw) {
		if (ae->wl[ae->idx].t==1) {
			ae->isw--;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDSWITCH does not need any parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDSWITCH encounter whereas there is no referent SWITCH\n");
	}
}

void __IFNOT(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};
	int rexpr;

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		rexpr=!RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
		ifthen.v=rexpr;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFNOT;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		//IntArrayAddDynamicValueConcat(&ae->ifthen,&ae->ii,&ae->mi,rexpr);
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFNOT need one expression\n");
	}
}
void __IFNOT_light(struct s_assenv *ae) {
	struct s_ifthen ifthen={0};

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ifthen.v=0;
		ifthen.filename=GetCurrentFile(ae);
		ifthen.line=ae->wl[ae->idx].l;
		ifthen.type=E_IFTHEN_TYPE_IFNOT;
		ObjectArrayAddDynamicValueConcat((void **)&ae->ifthen,&ae->ii,&ae->mi,&ifthen,sizeof(ifthen));
		//IntArrayAddDynamicValueConcat(&ae->ifthen,&ae->ii,&ae->mi,rexpr);
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"IFNOT need one expression\n");
	}
}

void __ELSE(struct s_assenv *ae) {
	if (ae->ii) {
		if (ae->wl[ae->idx].t==1) {
			/* ELSE a executer seulement si celui d'avant est a zero */
			switch (ae->ifthen[ae->ii-1].v) {
				case -1:break;
				case 0:ae->ifthen[ae->ii-1].v=1;break;
				case 1:ae->ifthen[ae->ii-1].v=0;break;
			}
			ae->ifthen[ae->ii-1].type=E_IFTHEN_TYPE_ELSE;
			ae->ifthen[ae->ii-1].line=ae->wl[ae->idx].l;
			ae->ifthen[ae->ii-1].filename=GetCurrentFile(ae);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ELSE does not need any parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ELSE encounter whereas there is no referent IF\n");
	}
}
void __ELSEIF(struct s_assenv *ae) {

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ae->ifthen[ae->ii-1].type=E_IFTHEN_TYPE_ELSEIF;
		ae->ifthen[ae->ii-1].line=ae->wl[ae->idx].l;
		ae->ifthen[ae->ii-1].filename=GetCurrentFile(ae);
		if (ae->ifthen[ae->ii-1].v) {
			/* il faut signifier aux suivants qu'on va jusqu'au ENDIF */
			ae->ifthen[ae->ii-1].v=-1;
		} else {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
			ae->ifthen[ae->ii-1].v=!!RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->codeadr,0,1);
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ELSEIF need one expression\n");
	}
}
void __ELSEIF_light(struct s_assenv *ae) {

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		ae->ifthen[ae->ii-1].type=E_IFTHEN_TYPE_ELSEIF;
		ae->ifthen[ae->ii-1].line=ae->wl[ae->idx].l;
		ae->ifthen[ae->ii-1].filename=GetCurrentFile(ae);
		if (ae->ifthen[ae->ii-1].v) {
			/* il faut signifier aux suivants qu'on va jusqu'au ENDIF */
			ae->ifthen[ae->ii-1].v=-1;
		} else {
			ae->ifthen[ae->ii-1].v=0;
		}
		ae->idx++;
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ELSEIF need one expression\n");
	}
}
void __ENDIF(struct s_assenv *ae) {
	if (ae->ii) {
		if (ae->wl[ae->idx].t==1) {
			ae->ii--;
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDIF does not need any parameter\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDIF encounter whereas there is no referent IF\n");
	}
}

void __internal_PROTECT(struct s_assenv *ae, int memstart, int memend) {
	struct s_orgzone orgzone={0};

	/* add a fake ORG zone */
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));
	/* then switch it with the current ORG */
	orgzone=ae->orgzone[ae->io-2];
	ae->orgzone[ae->io-2].memstart=memstart;
	ae->orgzone[ae->io-2].memend=memend;
	ae->orgzone[ae->io-2].ibank=ae->activebank;
	ae->orgzone[ae->io-2].protect=1;
	ae->orgzone[ae->io-1]=orgzone;
}

void __PROTECT(struct s_assenv *ae) {
	int memstart,memend;

	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
		memstart=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,0,0,0);
		memend=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,0,0,0);
		__internal_PROTECT(ae,memstart,memend);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"PROTECT need two parameters: startadr,endadr\n");
	}
}

void ___org_close(struct s_assenv *ae) {
	__internal_UpdateLZBlockIfAny(ae);
	if (ae->lz>=0 && ae->lzsection[ae->ilz-1].lzversion) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Cannot ORG inside a LZ section\n");
		return;
	}
	/* close current ORG */
	if (ae->io) {
		ae->orgzone[ae->io-1].memend=ae->outputadr;
	}
}

void ___org_new(struct s_assenv *ae, int nocode) {
	struct s_orgzone orgzone={0};
	int i;
	
	/* check current ORG request */
	for (i=0;i<ae->io;i++) {
		/* aucun contrôle sur les ORG non écrits ou en NOCODE */
		if (ae->orgzone[i].memstart!=ae->orgzone[i].memend && !ae->orgzone[i].nocode) {
			if (ae->orgzone[i].ibank==ae->activebank) {
				if (ae->outputadr<ae->orgzone[i].memend && ae->outputadr>=ae->orgzone[i].memstart) {
					if (ae->orgzone[i].protect) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ORG located a PROTECTED section [#%04X-#%04X-B%d] file [%s] line %d\n",ae->orgzone[i].memstart,ae->orgzone[i].memend,ae->orgzone[i].ibank<32?ae->orgzone[i].ibank:0,ae->filename[ae->orgzone[i].ifile],ae->orgzone[i].iline);
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ORG (output at #%04X) located in a previous ORG section [#%04X-#%04X-B%d] file [%s] line %d\n",ae->outputadr,ae->orgzone[i].memstart,ae->orgzone[i].memend,ae->orgzone[i].ibank<32?ae->orgzone[i].ibank:0,ae->filename[ae->orgzone[i].ifile],ae->orgzone[i].iline);
					}
				}
			}
		}
	}
	
	OverWriteCheck(ae);
	/* if there was a crunch block before, now closed */
	if (ae->lz>=0) {
		ae->lz=-1;
	}	
	orgzone.memstart=ae->outputadr;
	orgzone.ibank=ae->activebank;
	orgzone.ifile=ae->wl[ae->idx].ifile;
	orgzone.iline=ae->wl[ae->idx].l;
	orgzone.nocode=ae->nocode=nocode;

	if (nocode) {
		___output=___internal_output_nocode;
	} else {
		___output=___internal_output;
	}
	
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));
}

void __ORG(struct s_assenv *ae) {
	___org_close(ae);
	
	if (ae->wl[ae->idx+1].t!=2) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,0);
		ae->codeadr=RoundComputeExpression(ae,ae->wl[ae->idx+1].w,ae->outputadr,0,0);
		if (!ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t!=2) {
			ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,0);
			ae->outputadr=RoundComputeExpression(ae,ae->wl[ae->idx+2].w,ae->outputadr,0,0);
			ae->idx+=2;
		} else {
			ae->outputadr=ae->codeadr;
			ae->idx++;
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"[%s:%d] ORG code location[,output location]\n");
		return;
	}
	
	___org_new(ae,ae->nocode);

	if (ae->outputadr==ae->codeadr) ae->orgzone[ae->io-1].inplace=1;
}
void __NOCODE(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t==1) {
		___org_close(ae);
		ae->codeadrbackup=ae->codeadr;
		ae->outputadrbackup=ae->outputadr;
		___org_new(ae,1);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"NOCODE directive does not need parameter\n");
	}
}
void __CODE(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		if (strcmp(ae->wl[ae->idx+1].w,"SKIP")==0) {
			___org_close(ae);
			ae->codeadr=ae->codeadrbackup;
			ae->outputadr=ae->outputadrbackup;
			___org_new(ae,1);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"unknown parameter for CODE directive\n");
		}
		ae->idx++;
	} else if (ae->wl[ae->idx].t==1) {
		___org_close(ae);
		___org_new(ae,0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"CODE directive does not need parameter\n");
	}
}
void __STRUCT(struct s_assenv *ae) {
	#undef FUNC
	#define FUNC "__STRUCT"
	struct s_rasmstructfield rasmstructfield={0};
	struct s_rasmstruct rasmstruct={0};
	struct s_rasmstruct rasmstructalias={0};
	struct s_label curlabel={0};
	int crc,i,j,irs;
	/* filler */
	int localsize,cursize;

	if (!ae->wl[ae->idx].t) {
		if (ae->wl[ae->idx+1].t) {
			/**************************************************
			    s t r u c t u r e     d e c l a r a t i o n
			**************************************************/
			if (!ae->getstruct) {
				/* cannot be an existing label or EQU (but variable ok) */
				crc=GetCRC(ae->wl[ae->idx+1].w);
				if ((SearchLabel(ae,ae->wl[ae->idx+1].w,crc))!=NULL || (SearchAlias(ae,crc,ae->wl[ae->idx+1].w))!=-1) {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"STRUCT name must be different from existing labels ou aliases\n");
				} else {
					ae->backup_filename=GetCurrentFile(ae);
					ae->backup_line=ae->wl[ae->idx].l;
					ae->backup_outputadr=ae->outputadr;
					ae->backup_codeadr=ae->codeadr;
					ae->getstruct=1;
					/* STRUCT = NOCODE + ORG 0 */
					___org_close(ae);
					ae->codeadr=0;
					___org_new(ae,1);
					/* create struct */
					rasmstruct.name=TxtStrDup(ae->wl[ae->idx+1].w);
					rasmstruct.crc=GetCRC(rasmstruct.name);
					ObjectArrayAddDynamicValueConcat((void **)&ae->rasmstruct,&ae->irasmstruct,&ae->mrasmstruct,&rasmstruct,sizeof(rasmstruct));
					ae->idx++;
					
					/* wrapper for data capture */
					instruction[ICRC_DEFB].makemnemo=_DEFB_struct;instruction[ICRC_DB].makemnemo=_DEFB_struct;
					instruction[ICRC_DEFW].makemnemo=_DEFW_struct;instruction[ICRC_DW].makemnemo=_DEFW_struct;
					instruction[ICRC_DEFI].makemnemo=_DEFI_struct;
					instruction[ICRC_DEFF].makemnemo=_DEFF_struct;instruction[ICRC_DF].makemnemo=_DEFF_struct;
					instruction[ICRC_DEFR].makemnemo=_DEFR_struct;instruction[ICRC_DR].makemnemo=_DEFR_struct;
					instruction[ICRC_DEFS].makemnemo=_DEFS_struct;instruction[ICRC_DS].makemnemo=_DEFS_struct;
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"STRUCT cannot be declared inside previous opened STRUCT [%s] Line %d\n",ae->backup_filename,ae->backup_line);
			}
		} else {
			/**************************************************
				s t r u c t u r e     i n s e r t i o n
			**************************************************/
			int nbelem=1;
#if TRACE_STRUCT
printf("structure insertion\n");
#endif
			/* insert struct param1 in memory with name param2 */
			crc=GetCRC(ae->wl[ae->idx+1].w);
			/* look for existing struct */
			for (irs=0;irs<ae->irasmstruct;irs++) {
				if (ae->rasmstruct[irs].crc==crc && strcmp(ae->rasmstruct[irs].name,ae->wl[ae->idx+1].w)==0) break;
			}
			if (irs==ae->irasmstruct) {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Unknown STRUCT %s\n",ae->wl[ae->idx+1].w);
			} else {
				/* create alias for sizeof */
				if (!ae->getstruct) {
					if (ae->wl[ae->idx+2].w[0]=='@') {
						rasmstructalias.name=MakeLocalLabel(ae,ae->wl[ae->idx+2].w,NULL);
					} else {
						rasmstructalias.name=TxtStrDup(ae->wl[ae->idx+2].w);
					}
				} else {
#if TRACE_STRUCT
printf("struct [%s] inside struct\n",ae->wl[ae->idx+2].w);
#endif
					/* struct inside struct */
					rasmstructalias.name=MemMalloc(strlen(ae->rasmstruct[ae->irasmstruct-1].name)+2+strlen(ae->wl[ae->idx+2].w));
					sprintf(rasmstructalias.name,"%s.%s",ae->rasmstruct[ae->irasmstruct-1].name,ae->wl[ae->idx+2].w);
				}
				rasmstructalias.crc=GetCRC(rasmstructalias.name);
				rasmstructalias.size=ae->rasmstruct[irs].size;
				rasmstructalias.ptr=ae->codeadr;
#if TRACE_STRUCT
printf("structalias [%s] ptr=%d size=%d\n",rasmstructalias.name,rasmstructalias.ptr,rasmstructalias.size);
#endif
				/* extra parameter to declare an array? */
				if (!ae->wl[ae->idx+2].t && !StringIsQuote(ae->wl[ae->idx+3].w)) {
					ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,0);
					nbelem=RoundComputeExpression(ae,ae->wl[ae->idx+3].w,ae->outputadr,0,0);
					if (nbelem<1) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Struct array need a positive number of elements!\n");
						nbelem=1;
					}
					ae->idx++;
				}
				rasmstructalias.nbelem=nbelem;
#if TRACE_STRUCT
printf("EVOL 119 - tableau! %d elem(s)\n",nbelem);
#endif
				ObjectArrayAddDynamicValueConcat((void **)&ae->rasmstructalias,&ae->irasmstructalias,&ae->mrasmstructalias,&rasmstructalias,sizeof(rasmstructalias));
				
				/* create label for global struct ptr */
				curlabel.iw=-1;
				curlabel.ptr=ae->codeadr;
				if (!ae->getstruct) {
					if (ae->wl[ae->idx+2].w[0]=='@') curlabel.name=MakeLocalLabel(ae,ae->wl[ae->idx+2].w,NULL); else curlabel.name=TxtStrDup(ae->wl[ae->idx+2].w);
					curlabel.crc=GetCRC(curlabel.name);
					PushLabelLight(ae,&curlabel);
				} else {
					/* or check for non-local name in struct declaration */
					if (ae->wl[ae->idx+2].w[0]=='@') {
						MakeError(ae,GetCurrentFile(ae),GetExpLine(ae,0),"Meaningless use of local label in a STRUCT definition\n");
					} else {
						curlabel.name=TxtStrDup(rasmstructalias.name);
						curlabel.crc=GetCRC(curlabel.name);
						PushLabelLight(ae,&curlabel);
					}
				}

				/* first field is in fact the very beginning of the structure */
				if (ae->getstruct) {
					rasmstructfield.name=TxtStrDup(ae->wl[ae->idx+2].w);
					rasmstructfield.offset=ae->codeadr;
					ObjectArrayAddDynamicValueConcat((void **)&ae->rasmstruct[ae->irasmstruct-1].rasmstructfield,
							&ae->rasmstruct[ae->irasmstruct-1].irasmstructfield,&ae->rasmstruct[ae->irasmstruct-1].mrasmstructfield,
							&rasmstructfield,sizeof(rasmstructfield));
				}				
				
				/* create subfields */
#if TRACE_STRUCT
printf("create subfields\n");
#endif
				curlabel.iw=-1;
				curlabel.ptr=ae->codeadr;
				curlabel.ibank=ae->activebank<BANK_MAX_NUMBER?ae->activebank:0;
				for (i=0;i<ae->rasmstruct[irs].irasmstructfield;i++) {
					curlabel.ptr=ae->codeadr+ae->rasmstruct[irs].rasmstructfield[i].offset;
					if (!ae->getstruct) {
						curlabel.name=MemMalloc(strlen(ae->wl[ae->idx+2].w)+strlen(ae->rasmstruct[irs].rasmstructfield[i].name)+2);
						sprintf(curlabel.name,"%s.%s",ae->wl[ae->idx+2].w,ae->rasmstruct[irs].rasmstructfield[i].name);
						if (ae->wl[ae->idx+2].w[0]=='@') {
							char *newlabel;
							newlabel=MakeLocalLabel(ae,curlabel.name,NULL);
							MemFree(curlabel.name);
							curlabel.name=newlabel;
						}
						curlabel.crc=GetCRC(curlabel.name);
						PushLabelLight(ae,&curlabel);
					/* are we using a struct in a struct definition? */
					} else {
						/* copy structname+label+offset in the structure */
						rasmstructfield.name=MemMalloc(strlen(ae->wl[ae->idx+2].w)+strlen(ae->rasmstruct[irs].rasmstructfield[i].name)+2);
						sprintf(rasmstructfield.name,"%s.%s",ae->wl[ae->idx+2].w,ae->rasmstruct[irs].rasmstructfield[i].name);
						rasmstructfield.offset=curlabel.ptr;
						ObjectArrayAddDynamicValueConcat((void **)&ae->rasmstruct[ae->irasmstruct-1].rasmstructfield,
								&ae->rasmstruct[ae->irasmstruct-1].irasmstructfield,&ae->rasmstruct[ae->irasmstruct-1].mrasmstructfield,
								&rasmstructfield,sizeof(rasmstructfield));
								
						/* need to push also generic label */
						curlabel.name=MemMalloc(strlen(ae->rasmstruct[ae->irasmstruct-1].name)+strlen(rasmstructfield.name)+2); /* overwrite PTR */
						sprintf(curlabel.name,"%s.%s",ae->rasmstruct[ae->irasmstruct-1].name,rasmstructfield.name);
						curlabel.crc=GetCRC(curlabel.name);
						PushLabelLight(ae,&curlabel);
					}					
#if TRACE_STRUCT
printf("pushLight [%s] %d:%X\n",curlabel.name,curlabel.ibank,curlabel.ptr);
#endif
				}

				/* is there any filler in the declaration? */
				localsize=0;

				/* déterminer si on est en remplissage par défaut ou remplissage surchargé */





#if TRACE_STRUCT
printf("struct new behaviour (scan for %d fields)\n",ae->rasmstruct[irs].irasmstructfield);
#endif
#if 0
				for (i=0;i<ae->rasmstruct[irs].irasmstructfield;i++) {

					if (!ae->wl[ae->idx+2+i].t || i+1>=ae->rasmstruct[irs].irasmstructfield) {
						/* si le champ est sur le même offset que le précédent, on le saute */
						if (i && ae->rasmstruct[irs].rasmstructfield[i].offset>ae->rasmstruct[irs].rasmstructfield[i-1].offset) continue;

#if TRACE_STRUCT
printf("get field? (%d)\n",irs);
#endif
						if (!StringIsQuote(ae->wl[ae->idx+i].w)) {
							ExpressionFastTranslate(ae,&ae->wl[ae->idx+i].w,1);
							zeval=RoundComputeExpressionCore(ae,ae->wl[ae->idx+i].w,ae->codeadr,0);
						} else {
							// push string
						}

						localsize+=ae->rasmstruct[irs].rasmstructfield[i].size;

						/* pour du single shot ?
						pushbyte(s) at ae->codeadr+ae->rasmstruct[irs].rasmstructfield[i].offset
						*/

						//ae->rasmstruct[irs].size;

					} else {
#if TRACE_STRUCT
printf("*break*\n");
#endif
						break;
					}
				}
#endif

				/* (LEGACY)  filler, on balance des zéros */
#if TRACE_STRUCT
printf("struct (almost) legacy filler from %d to %d-1\n",localsize,ae->rasmstruct[irs].size);
#endif
				while (nbelem) {
					for (i=cursize=0;i<ae->rasmstruct[irs].irasmstructfield && cursize<localsize;i++) {
						cursize+=ae->rasmstruct[irs].rasmstructfield[i].size;
					}
					for (;i<ae->rasmstruct[irs].irasmstructfield;i++) {
						for (j=0;j<ae->rasmstruct[irs].rasmstructfield[i].idata;j++) {
							___output(ae,ae->rasmstruct[irs].rasmstructfield[i].data[j]);
						}
					}
					nbelem--;
				}

#if 0
				for (i=localsize;i<ae->rasmstruct[irs].size;i++) ___output(ae,0);
#endif
				ae->idx+=2; // probablement à revoir dans le cas d'une init!!!
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"STRUCT directive needs one or two parameters\n");
	}
}
void __ENDSTRUCT(struct s_assenv *ae) {
	#undef FUNC
	#define FUNC "__ENDSTRUCT"
	struct s_label curlabel={0};
	int i,newlen;
#if TRACE_STRUCT
	printf("endstruct\n");
#endif

	if (!ae->wl[ae->idx].t) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDSTRUCT directive does not need parameter\n");
	} else {
		if (ae->getstruct) {
			ae->rasmstruct[ae->irasmstruct-1].size=ae->codeadr;
			ae->getstruct=0;

			/* SIZEOF like Vasm with struct name */
			curlabel.name=TxtStrDup(ae->rasmstruct[ae->irasmstruct-1].name);
			curlabel.crc=ae->rasmstruct[ae->irasmstruct-1].crc;
			curlabel.iw=-1;
			curlabel.ptr=ae->rasmstruct[ae->irasmstruct-1].size;
			PushLabelLight(ae,&curlabel);
			
			/* compute size for each field */
#if TRACE_STRUCT
	printf("compute field size\n");
#endif
			newlen=strlen(ae->rasmstruct[ae->irasmstruct-1].name)+2;
			if (ae->rasmstruct[ae->irasmstruct-1].irasmstructfield) {
				for (i=0;i<ae->rasmstruct[ae->irasmstruct-1].irasmstructfield-1;i++) {
					ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].size=ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i+1].offset-ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].offset;
					ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname=MemMalloc(newlen+strlen(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].name));
					sprintf(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname,"%s.%s",ae->rasmstruct[ae->irasmstruct-1].name,ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].name);
					ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].crc=GetCRC(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname);
				}
				ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].size=ae->rasmstruct[ae->irasmstruct-1].size-ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].offset;
				ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname=MemMalloc(newlen+strlen(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].name));
				sprintf(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname,"%s.%s",ae->rasmstruct[ae->irasmstruct-1].name,ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].name);
				ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].crc=GetCRC(ae->rasmstruct[ae->irasmstruct-1].rasmstructfield[i].fullname);
			} else {
				rasm_printf(ae,KWARNING"[%s:%d] Warning: empty structure [%s]\n",GetCurrentFile(ae),ae->wl[ae->idx].l,curlabel.name);
				if (ae->erronwarn) MaxError(ae);
			}

			/* unwrap data capture */
#if TRACE_STRUCT
	printf("unwrap data capture\n");
#endif
			if (ae->as80==1 || ae->pasmo) {/* not for UZ80 */
				instruction[ICRC_DEFB].makemnemo=_DEFB_as80;instruction[ICRC_DB].makemnemo=_DEFB_as80;
				instruction[ICRC_DEFW].makemnemo=_DEFW_as80;instruction[ICRC_DW].makemnemo=_DEFW_as80;
				instruction[ICRC_DEFI].makemnemo=_DEFI_as80;
			} else {
				instruction[ICRC_DEFB].makemnemo=_DEFB;instruction[ICRC_DB].makemnemo=_DEFB;
				instruction[ICRC_DEFW].makemnemo=_DEFW;instruction[ICRC_DW].makemnemo=_DEFW;
				instruction[ICRC_DEFI].makemnemo=_DEFI;
			}
			instruction[ICRC_DEFF].makemnemo=_DEFF;instruction[ICRC_DF].makemnemo=_DEFF;
			instruction[ICRC_DEFR].makemnemo=_DEFR;instruction[ICRC_DR].makemnemo=_DEFR;
			instruction[ICRC_DEFS].makemnemo=_DEFS;instruction[ICRC_DS].makemnemo=_DEFS;

			/* like there was no byte */
			ae->outputadr=ae->backup_outputadr;
			ae->codeadr=ae->backup_codeadr;

			___org_close(ae);
			___org_new(ae,0);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"ENDSTRUCT encountered outside STRUCT declaration\n");
		}
	}
}

void __MEMSPACE(struct s_assenv *ae) {
	if (ae->wl[ae->idx].t) {
		___new_memory_space(ae);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"MEMSPACE directive does not need parameter\n");
	}
}

int (*_internal_getsample)(unsigned char *data, int *idx);
#undef FUNC
#define FUNC "_internal_AudioGetSampleValue"

int __internal_getsample8(unsigned char *data, int *idx) {
	int v;
	v=data[*idx]-128;*idx=*idx+1;return v;
}
int __internal_getsample16little(unsigned char *data, int *idx) {
	int cursample;
	char *sdata=(char *)data;
	cursample=sdata[*idx+1];*idx=*idx+2;
	return cursample;
}
int __internal_getsample24little(unsigned char *data, int *idx) {
	int cursample;
	char *sdata=(char *)data;
	cursample=sdata[*idx+2];*idx=*idx+3;
	return cursample;
}
/* big-endian */
int __internal_getsample16big(unsigned char *data, int *idx) {
	int cursample;
	char *sdata=(char *)data;
	cursample=sdata[*idx];*idx=*idx+2;
	return cursample;
}
int __internal_getsample24big(unsigned char *data, int *idx) {
	int cursample;
	char *sdata=(char *)data;
	cursample=sdata[*idx];*idx=*idx+3;
	return cursample;
}
/* float & endian shit */
int _isLittleEndian() /* from lz4.h */
{
    const union { U32 u; unsigned char c[4]; } one = { 1 };
    return one.c[0];
}

unsigned char * __internal_floatinversion(unsigned char *data) {
	static unsigned char bswap[4];
	bswap[0]=data[3];
	bswap[1]=data[2];
	bswap[2]=data[1];
	bswap[3]=data[0];
	return bswap;
}

int __internal_getsample32bigbig(unsigned char *data, int *idx) {
	float fsample;
	int cursample;
	fsample=*((float*)(data+*idx));
	*idx=*idx+4;
	cursample=(floor)((fsample+1.0)*127.5+0.5);
	return cursample;
}
int __internal_getsample32biglittle(unsigned char *data, int *idx) {
	float fsample;
	int cursample;
	fsample=*((float*)(__internal_floatinversion(data+*idx)));
	*idx=*idx+4;
	cursample=(floor)((fsample+1.0)*127.5+0.5);
	return cursample;
}

#define __internal_getsample32littlelittle __internal_getsample32bigbig
#define __internal_getsample32littlebig __internal_getsample32biglittle


void _AudioLoadSample(struct s_assenv *ae, unsigned char *data, unsigned int filesize, enum e_audio_sample_type sample_type, float normalize)
{
	#undef FUNC
	#define FUNC "AudioLoadSample"

	struct s_wav_header *wav_header;
	int i,j,n,idx,controlsize;
	int nbchannel,bitspersample,nbsample;
	int bigendian=0,cursample,wFormat;
	double frequency;
	double accumulator;
	unsigned char samplevalue=0, sampleprevious=0;
	int samplerepeat=0,ipause,mypsgreg;

	unsigned char *subchunk;
	int subchunksize;

	if (filesize<sizeof(struct s_wav_header)) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - this file is too small to be a valid WAV!\n");
		return;
	}

	wav_header=(struct s_wav_header *)data;

#if TRACE_HEXBIN
printf("AudioLoadSample filesize=%d st=%d normalize=%.2lf\n",filesize,sample_type,normalize);
#endif
	if (strncmp(wav_header->ChunkID,"RIFF",4)) {
		if (strncmp(wav_header->ChunkID,"RIFX",4)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - unsupported audio sample type (chunkid must be 'RIFF' or 'RIFX')\n");
			return;
		} else {
			bigendian=1;
		}
	}
	if (strncmp(wav_header->Format,"WAVE",4)) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"[%s:%d] WAV import - unsupported audio sample type (format must be 'WAVE')\n");
		return;
	}
	controlsize=wav_header->SubChunk1Size[0]+wav_header->SubChunk1Size[1]*256+wav_header->SubChunk1Size[2]*65536+wav_header->SubChunk1Size[3]*256*65536;
	if (controlsize!=16) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - invalid wav chunk size (subchunk1 control)\n");
		return;
	}
	if (strncmp(wav_header->SubChunk1ID,"fmt",3)) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - unsupported audio sample type (subchunk1id must be 'fmt')\n");
		return;
	}

#if TRACE_HEXBIN
printf("AudioLoadSample getsubchunk\n");
#endif
	subchunk=(unsigned char *)&wav_header->SubChunk2ID;
	while (strncmp((char *)subchunk,"data",4)) {
		subchunksize=8+subchunk[4]+subchunk[5]*256+subchunk[6]*65536+subchunk[7]*256*65536;
		if (subchunksize>=filesize) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - data subchunk not found\n");
			return;
		}
		subchunk+=subchunksize;
	}
	subchunksize=subchunk[4]+subchunk[5]*256+subchunk[6]*65536+subchunk[7]*256*65536;
	controlsize=subchunksize;

	nbchannel=wav_header->NumChannels[0]+wav_header->NumChannels[1]*256;
	if (nbchannel<1) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - invalid number of audio channel\n");
		return;
	}

	wFormat=wav_header->AudioFormat[0]+wav_header->AudioFormat[1]*256;
	if (wFormat!=1 && wFormat!=3) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - invalid or unsupported wFormatTag (%04X)\n",wFormat);
		return;
	}

	frequency=wav_header->SampleRate[0]+wav_header->SampleRate[1]*256+wav_header->SampleRate[2]*65536+wav_header->SampleRate[3]*256*65536;
	switch (sample_type) {
		case AUDIOSAMPLE_DMAA:
		case AUDIOSAMPLE_DMAB:
		case AUDIOSAMPLE_DMAC:
			if (fabs(frequency/15125.0-1.0)>0.2) {
				if (!ae->nowarning) {
					rasm_printf(ae,KWARNING"[%s:%d] Warning: WAV sample frequency (%dHz) is very different from 15KHz DMA frequency\n",GetCurrentFile(ae),ae->wl[ae->idx].l,(int)frequency);
					if (ae->erronwarn) MaxError(ae);
				}
			}
		default:break;
	}

	bitspersample=wav_header->BitsPerSample[0]+wav_header->BitsPerSample[1]*256;
#if TRACE_HEXBIN
printf("AudioLoadSample bitpersample=%d | Format=%s\n",bitspersample,wFormat==1?"PCM":"IEEE Float");
#endif
	switch (bitspersample) {
		case 8:_internal_getsample=__internal_getsample8;break;
		case 16:if (!bigendian) _internal_getsample=__internal_getsample16little; else _internal_getsample=__internal_getsample16big;break;
		case 24:if (!bigendian) _internal_getsample=__internal_getsample24little; else _internal_getsample=__internal_getsample24big;break;
		case 32:if (wFormat==3) {
				if (!bigendian) {
						if (_isLittleEndian()) {
							_internal_getsample=__internal_getsample32littlelittle;
						} else {
							_internal_getsample=__internal_getsample32littlebig;
						}
					} else {
						if (_isLittleEndian()) {
							_internal_getsample=__internal_getsample32biglittle;
						} else {
							_internal_getsample=__internal_getsample32bigbig;
						}
					}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - unsupported 32bits PCM\n",wFormat);
				return;
			}
			break;
		default:
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - unsupported bits per sample (%d)\n",bitspersample);
			return;
	}

	nbsample=controlsize/nbchannel/(bitspersample/8);
	if (controlsize+sizeof(struct s_wav_header)>filesize) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"WAV import - cannot read %d byte%s of audio whereas the file is %d bytes big!\n",controlsize,controlsize>1?"s":"",filesize);
		return;
	}

#if TRACE_HEXBIN
printf("nbsample=%d (sze=%d,chn=%d,bps=%d) st=%d\n",nbsample,controlsize,nbchannel,bitspersample,sample_type);
#endif
	
	idx=subchunk-data;
	switch (sample_type) {
		default:
		case AUDIOSAMPLE_SMP:
			for (i=0;i<nbsample;i++) {
				/* downmixing */
				accumulator=0.0;
				for (n=0;n<nbchannel;n++) {
					accumulator+=_internal_getsample(data,&idx);
				}
				/* normalize */
				cursample=MinMaxInt(floor(((accumulator/nbchannel)*normalize)+0.5)+128,0,255);
				
				/* PSG levels */
				samplevalue=ae->psgfine[cursample];
				
				/* output */
				___output(ae,samplevalue);
			}
			break;
		case AUDIOSAMPLE_SM2:
			/* +1 pour éviter le segfault */
			for (i=0;i<nbsample+1;i+=2) {
				for (j=0;j<2;j++) {
					/* downmixing */
					accumulator=0.0;
					for (n=0;n<nbchannel;n++) {
						accumulator+=_internal_getsample(data,&idx);
					}
					/* normalize */
					cursample=MinMaxInt(floor(((accumulator/nbchannel)*normalize)+0.5)+128,0,255);
					/* PSG levels & packing */
					samplevalue=(samplevalue<<4)+(ae->psgfine[cursample]);
				}
				
				/* output */
				___output(ae,samplevalue);
			}
			break;
		case AUDIOSAMPLE_SM4:
			/***
				SM4 format has two bits
				bits -> PSG value
				  00 ->  0
				  01 -> 13
				  10 -> 14
				  11 -> 15				
			***/
			/* +3 pour éviter le segfault */
			for (i=0;i<nbsample+3;i+=4) {
				for (j=0;j<4;j++) {
					/* downmixing */
					accumulator=0.0;
					for (n=0;n<nbchannel;n++) {
						accumulator+=_internal_getsample(data,&idx);
					}
					/* normalize */
					cursample=MinMaxInt(floor(((accumulator/nbchannel)*normalize)+0.5)+128,0,255);
					/* PSG levels & packing */
					samplevalue=(samplevalue<<2)+(ae->psgtab[cursample]>>2);
				}
				/* output */
				___output(ae,samplevalue);
			}
			break;
		case AUDIOSAMPLE_DMAA:
		case AUDIOSAMPLE_DMAB:
		case AUDIOSAMPLE_DMAC:
			switch (sample_type) {
				case AUDIOSAMPLE_DMAA:mypsgreg=0x8;break;
				case AUDIOSAMPLE_DMAB:mypsgreg=0x9;break;
				case AUDIOSAMPLE_DMAC:mypsgreg=0xA;break;
				default:printf("warning remover\n");
			}
			/* downmixing */
			accumulator=0.0;
			for (n=0;n<nbchannel;n++) {
				accumulator+=_internal_getsample(data,&idx);
			}
			/* normalize */
			cursample=MinMaxInt(floor(((accumulator/nbchannel)*normalize)+0.5)+128,0,255);
			/* PSG levels */
			sampleprevious=ae->psgtab[cursample];
			for (i=1;i<nbsample;i++) {
				/* downmixing */
				accumulator=0.0;
				for (n=0;n<nbchannel;n++) {
					accumulator+=_internal_getsample(data,&idx);
				}
				/* normalize */
				cursample=MinMaxInt(floor(((accumulator/nbchannel)*normalize)+0.5)+128,0,255);
				
				/* PSG levels */
				samplevalue=ae->psgtab[cursample];
				
				if (samplevalue==sampleprevious && i+1<nbsample) {
					samplerepeat++;
				} else {
					if (!samplerepeat) {
						/* DMA output */
						___output(ae,sampleprevious);
						___output(ae,mypsgreg); /* volume canal A/B/C */
					} else {
						/* DMA pause */
						___output(ae,sampleprevious);
						___output(ae,mypsgreg); /* volume canal A/B/C */
						while (samplerepeat) {
							ipause=samplerepeat<4096?samplerepeat:4095;
							___output(ae,ipause&0xFF);
							___output(ae,0x10 | ((ipause>>8) &0xF)); /* pause */
							
							samplerepeat-=4096;
							if (samplerepeat<0) samplerepeat=0;
						}
					}
					sampleprevious=samplevalue;
				}
			}
			/* if last sample is alone */
			if (!samplerepeat) {
				___output(ae,sampleprevious);
				___output(ae,mypsgreg); /* volume canal A/B/C */
			}
			break;
	}
}


#ifdef NOAPULTRA
  int LZSA_crunch(unsigned char *input_data,int input_size,unsigned char **lzdata,int *lzlen) {
	  lzdata=MemMalloc(4);
	  *lzlen=0;

printf("no LZSA support in this version!\n");
fprintf(stderr,"no LZSA support in this version!\n");

	  return 0;
  }
  int APULTRA_crunch(unsigned char *input_data,int input_size,unsigned char **lzdata,int *lzlen) {
	  lzdata=MemMalloc(4);
	  *lzlen=0;

printf("no AP-Ultra support in this version!\n");
fprintf(stderr,"no AP-Ultra support in this version!\n");

	  return 0;
  }
#endif

/*
	meta fonction qui gère le INCBIN standard plus les variantes SMP et DMA
*/
void __READ(struct s_assenv *ae) {
	if (!ae->wl[ae->idx].t) {
		int idx;

		idx=atoi(ae->wl[ae->idx+1].w);
		ae->idx++;

		if (idx>=0 && idx<ae->ih) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"File to include was not found [%s]\n",ae->hexbin[idx].filename);
		} else {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"internal error with text file import (index out of bounds)\n");
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"READ directive need a proper filename as argument\n");
	}
}

void __HEXBIN(struct s_assenv *ae) {
	#undef FUNC
	#define FUNC "__HEXBIN"

	int hbinidx,overwritecheck=1,crc;
	struct s_expr_dico *rvar;
	unsigned int idx;
	int size=0,offset=0;
	float amplification=1.0;
	int deload=0;
	int vtiles=0,remap=0,revert=0;
	int itiles=0,tilex=0;
	struct s_hexbin *curhexbin;
	unsigned char *newdata=NULL;
	int fileok=0,incwav=0;
	
	if (!ae->wl[ae->idx].t) {
		ExpressionFastTranslate(ae,&ae->wl[ae->idx+1].w,1);
		hbinidx=RoundComputeExpressionCore(ae,ae->wl[ae->idx+1].w,ae->codeadr,0);
		if (hbinidx>=ae->ih) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"internal error with binary file import (index out of bounds)\n");
			return;
		}
#if TRACE_HEXBIN
printf("Hexbin idx=[%s] filename=[%s]\n",ae->wl[ae->idx+1].w,ae->hexbin[hbinidx].filename);
#endif
		
		if (!ae->wl[ae->idx+1].t) {
			if (strcmp("DSK",ae->wl[ae->idx+2].w)==0) {
				/* import binary from DSK */
			} else if (strchr("SD",ae->wl[ae->idx+2].w[0]) && ae->wl[ae->idx+2].w[1]=='M' && strchr("P24A",ae->wl[ae->idx+2].w[2]) && !ae->wl[ae->idx+2].w[3]) {
				/* SMP,SM2,SM4,DMA */
#if TRACE_HEXBIN
printf("Hexbin for WAV-> %s (no operation until delayed load)\n",ae->wl[ae->idx+2].w);
#endif
				incwav=1;
			} else {
				/* legacy binary file */
#if TRACE_HEXBIN
printf("Hexbin legacy datalen=%d\n",ae->hexbin[hbinidx].datalen);
#endif
				if (strcmp("REVERT",ae->wl[ae->idx+2].w)==0) {
					/* revert data */
					if (!ae->wl[ae->idx+2].t) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN REVERT does not need extra parameters\n");
					}
#if TRACE_HEXBIN
printf(" -> REVERT loading\n");
#endif
					revert=1;
					offset=size=0; // full file
					ae->idx++;

				} else if (strcmp("REMAP",ae->wl[ae->idx+2].w)==0) {
					/* reorder tiles data */
					if (!ae->wl[ae->idx+2].t) {
						ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,1);
						remap=RoundComputeExpressionCore(ae,ae->wl[ae->idx+3].w,ae->codeadr,0);
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN REMAP need a number of columns for reordering\n");
					}
#if TRACE_HEXBIN
printf(" -> REMAP loading\n");
#endif
					offset=size=0; // full file
					ae->idx+=2;

				} else if (strcmp("ITILES",ae->wl[ae->idx+2].w)==0) {
					/*** entrelace les tiles, besoin de hauteur et largeur de la tile ***/
					if (!ae->wl[ae->idx+2].t) {
						ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,1);
						tilex=RoundComputeExpressionCore(ae,ae->wl[ae->idx+3].w,ae->codeadr,0);
						itiles=1;
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is INCBIN'file',ITILES,width\n");
						tilex=0;
					}
#if TRACE_HEXBIN
printf(" -> ITILES loading\n");
#endif
					offset=size=0; // full file
					ae->idx+=2;
				} else if (strcmp("VTILES",ae->wl[ae->idx+2].w)==0) {
					/* import and reorder tiles */
					if (!ae->wl[ae->idx+2].t) {
						ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,1);
						vtiles=RoundComputeExpressionCore(ae,ae->wl[ae->idx+3].w,ae->codeadr,0);
					} else {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN VTILES need a number of lines for reordering\n");
					}
#if TRACE_HEXBIN
printf(" -> VTILES loading\n");
#endif
					offset=size=0; // full file
					ae->idx+=2;
				} else {
					char *expwrk;
					
					expwrk=TxtStrDup(ae->wl[ae->idx+2].w);
					ExpressionFastTranslate(ae,&expwrk,1);
					offset=RoundComputeExpressionCore(ae,expwrk,ae->codeadr,0);
					MemFree(expwrk);
#if TRACE_HEXBIN
	printf("offset=%d\n",offset);
#endif
					if (!ae->wl[ae->idx+2].t) {
						if (ae->wl[ae->idx+3].w[0]) {
							expwrk=TxtStrDup(ae->wl[ae->idx+3].w);
							ExpressionFastTranslate(ae,&expwrk,1);
							size=RoundComputeExpressionCore(ae,expwrk,ae->codeadr,0);
							MemFree(expwrk);
						} else {
							size=0;
						}
#if TRACE_HEXBIN
	printf("size=%d\n",size);
#endif
						if (size<-65535 || size>65536) {
							MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN invalid size\n");
						}
						if (!ae->wl[ae->idx+3].t) {
							if (ae->wl[ae->idx+4].w[0]) {
								expwrk=TxtStrDup(ae->wl[ae->idx+4].w);
								ExpressionFastTranslate(ae,&expwrk,1);
								offset+=65536*RoundComputeExpressionCore(ae,expwrk,ae->codeadr,0);
								MemFree(expwrk);
							}
							if (!ae->wl[ae->idx+4].t) {
								if (strcmp(ae->wl[ae->idx+5].w,"OFF")==0) {
									overwritecheck=0;
								} else if (strcmp(ae->wl[ae->idx+5].w,"ON")==0) {
									overwritecheck=1;
#if TRACE_HEXBIN
	printf("mode OVERWRITE\n");
#endif
								} else if (ae->wl[ae->idx+5].w[0]) {
									MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN invalid overwrite value. Must be 'OFF' or 'ON'\n");
								}
								if (!ae->wl[ae->idx+5].t) {
									/* copy raw len to a (new) variable */
									crc=GetCRC(ae->wl[ae->idx+6].w);
									if ((rvar=SearchDico(ae,ae->wl[ae->idx+6].w,crc))!=NULL) {
										rvar->v=ae->hexbin[hbinidx].rawlen;
									} else {
										/* mais ne peut être un label ou un alias */
										ExpressionSetDicoVar(ae,ae->wl[ae->idx+6].w,ae->hexbin[hbinidx].rawlen);
									}
									ae->idx+=6;
								} else {
									ae->idx+=5;
								}
							} else {
								ae->idx+=4;
							}
						} else {
							ae->idx+=3;
						}
					} else {
						ae->idx+=2;
					}
				}
			}
		} else {
			ae->idx++;
		}

		curhexbin=&ae->hexbin[hbinidx];

		/* preprocessor cannot manage variables so here is the delayed load */
		if (ae->hexbin[hbinidx].datalen<0) {
			char *newfilename;
			int lm,touched;
			
#if TRACE_HEXBIN
printf("Hexbin -> as only the assembler know how to deal with var,\n");
printf("we look for tags in the name of a file which were not found\n");
#endif
			
			newfilename=TxtStrDup(curhexbin->filename);

			/* need to upper case tags */
			for (lm=touched=0;newfilename[lm];lm++) {
				if (newfilename[lm]=='{') touched++; else if (newfilename[lm]=='}') touched--; else if (touched) newfilename[lm]=toupper(newfilename[lm]);
			}
			/* on essaie d'interpréter le nom du fichier en dynamique */
			newfilename=TranslateTag(ae,newfilename,&touched,1,E_TAGOPTION_REMOVESPACE);

			/* Where is the file to load? */
			if (!FileExists(newfilename)) {
				int ilookfile;
				char *filename_toread;

				/* on cherche dans les include */
				for (ilookfile=0;ilookfile<ae->ipath && !fileok;ilookfile++) {
					filename_toread=MergePath(ae,ae->includepath[ilookfile],newfilename);
					if (FileExists(filename_toread)) {
						fileok=1;
						MemFree(newfilename);
						newfilename=TxtStrDup(filename_toread); // Merge renvoie un static
					}
				}
			} else {
				fileok=1;
			}

			if (fileok) {
#if TRACE_HEXBIN
printf("Hexbin -> surprise! we found the file!\n");
#endif
				curhexbin->rawlen=curhexbin->datalen=FileGetSize(newfilename);
				curhexbin->data=MemMalloc(curhexbin->datalen*1.3+10);
				if (FileReadBinary(newfilename,(char*)curhexbin->data,curhexbin->datalen)!=curhexbin->datalen) {
					MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"read error on file [%s]\n",newfilename);
					MemFree(newfilename);
					return;
				}
				FileReadBinaryClose(newfilename);
				deload=1;
			} else {
				/* still not found */
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"file not found [%s]\n",newfilename);
				MemFree(newfilename);
				return;
			}
			MemFree(newfilename);
		} 

		if (incwav) {
			/* SMP,SM2,SM4,DMA */
			int dma_args=3;
			int dma_channel=AUDIOSAMPLE_DMAC;
			int dma_int=0,dma_repeat=0;
			int mypsgreg=0xA;
#if TRACE_HEXBIN
printf("Hexbin -> %s\n",ae->wl[ae->idx+2].w);
#endif
			if (!ae->wl[ae->idx+2].t) {
				amplification=ComputeExpressionCore(ae,ae->wl[ae->idx+3].w,ae->codeadr,0);
#if TRACE_HEXBIN
printf("sample amplification=%.2lf\n",amplification);
#endif
			}

			switch (ae->wl[ae->idx+2].w[2]) {
				case 'P':_AudioLoadSample(ae,ae->hexbin[hbinidx].data,ae->hexbin[hbinidx].datalen, AUDIOSAMPLE_SMP,amplification);break;
				case '2':_AudioLoadSample(ae,ae->hexbin[hbinidx].data,ae->hexbin[hbinidx].datalen, AUDIOSAMPLE_SM2,amplification);break;
				case '4':_AudioLoadSample(ae,ae->hexbin[hbinidx].data,ae->hexbin[hbinidx].datalen, AUDIOSAMPLE_SM4,amplification);break;
				case 'A':/* DMA options */
					if (!ae->wl[ae->idx+2].t) {
						while (!ae->wl[ae->idx+dma_args].t) {
							dma_args++;
							if (strcmp(ae->wl[ae->idx+dma_args].w,"DMA_INT")==0) {
								dma_int=1;
							} else if (strcmp(ae->wl[ae->idx+dma_args].w,"DMA_REPEAT")==0) {
								if (!ae->wl[ae->idx+dma_args].t) {
									dma_args++;
									dma_repeat=ComputeExpressionCore(ae,ae->wl[ae->idx+dma_args].w,ae->codeadr,0);
									if (dma_repeat<1 || dma_repeat>4095) {
										MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DMA_REPEAT value out of bounds (1-4095)\n");
										dma_repeat=0;
									}
								} else {
									MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"DMA_REPEAT must be followed by another parameter\n");
								}
							} else if (strcmp(ae->wl[ae->idx+dma_args].w,"DMA_CHANNEL_A")==0) {
								dma_channel=AUDIOSAMPLE_DMAA;
								mypsgreg=0x8;
							} else if (strcmp(ae->wl[ae->idx+dma_args].w,"DMA_CHANNEL_B")==0) {
								dma_channel=AUDIOSAMPLE_DMAB;
								mypsgreg=0x9;
							} else if (strcmp(ae->wl[ae->idx+dma_args].w,"DMA_CHANNEL_C")==0) {
								dma_channel=AUDIOSAMPLE_DMAC;
								mypsgreg=0xA;
							} else {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Unrecognized DMA option [%s]\n",ae->wl[ae->idx+dma_args].w);
							}
						}
					}
					if (dma_repeat) {
						___output(ae,dma_repeat&0xFF);
						___output(ae,0x20|((dma_repeat>>8)&0xF));
					}
					_AudioLoadSample(ae,ae->hexbin[hbinidx].data,ae->hexbin[hbinidx].datalen, dma_channel,amplification);
					if (dma_repeat) {
						___output(ae,0x01);
						___output(ae,0x40); /* LOOP */
					}
					___output(ae,0);
					___output(ae,mypsgreg); /* volume to zero */
					if (dma_int) {
						___output(ae,0x10);
						___output(ae,0x40); /* INT */
					}
					___output(ae,0x20);
					___output(ae,0x40); /* Mandatory STOP */
					break;

				default:printf("warning remover\n");break;
			}
			ae->idx+=2;
			return;
		}
		
		if (ae->hexbin[hbinidx].datalen>0) {
			if (hbinidx<ae->ih && hbinidx>=0) {
				/* pre-parametres OK (longueur+IDX struct) */
				if (size<0) {
#if TRACE_HEXBIN
printf("taille négative %d -> conversion en %d\n",size,ae->hexbin[hbinidx].datalen+size);
#endif
					size=ae->hexbin[hbinidx].datalen+size;
					if (size<1) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN negative size is greater or equal to filesize\n");
					}
				}
				/* negative offset conversion */
				if (offset<0) {
#if TRACE_HEXBIN
printf("offset négatif %d -> conversion en %d\n",offset,ae->hexbin[hbinidx].datalen+offset);
#endif
					offset=ae->hexbin[hbinidx].datalen+offset;
				}
				if (!size) {
					if (!offset) {
						size=ae->hexbin[hbinidx].datalen;
					} else {
						size=ae->hexbin[hbinidx].datalen-offset;
					}
#if TRACE_HEXBIN
printf("taille nulle et offset=%d -> conversion en %d\n",offset,size);
#endif
				}
				if (size>ae->hexbin[hbinidx].datalen) {
					rasm_printf(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN size is greater than filesize\n");
				} else {
					if (size+offset>ae->hexbin[hbinidx].datalen) {
						MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN size+offset is greater than filesize\n");
					} else {
						/* OUTPUT DATA */
						unsigned char *outputdata;
						int outputidx=0;
						outputdata=MemMalloc(ae->hexbin[hbinidx].datalen);
#if TRACE_HEXBIN
printf("output fictif pour réorganiser les données\n");
#endif

						if (revert) {
							int p;
							p=size-1;
							while (p>=0) {
								outputdata[outputidx++]=ae->hexbin[hbinidx].data[p--];
							}
						} else if (itiles) {
							/* tiles data reordering */
							int tx,it;

							if (size % (tilex*8)) {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN ITILES cannot reorder tiles %d bytewidth with file of size %d\n",tilex,size);
							} else {
								it=0;
								while (it<size) {
									for (tx=0;tx<tilex;tx++)    outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+0*tilex];
									for (tx=tilex-1;tx>=0;tx--) outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+1*tilex];
									for (tx=0;tx<tilex;tx++)    outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+3*tilex];
									for (tx=tilex-1;tx>=0;tx--) outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+2*tilex];
									for (tx=0;tx<tilex;tx++)    outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+6*tilex];
									for (tx=tilex-1;tx>=0;tx--) outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+7*tilex];
									for (tx=0;tx<tilex;tx++)    outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+5*tilex];
									for (tx=tilex-1;tx>=0;tx--) outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx+4*tilex];
									it+=tilex*8;
								}
							}
						} else if (remap) {
							/* tiles data reordering */
							int tx,it,width;

							width=size/remap;

							if ((size % remap) || (remap*width>size)) {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN REMAP cannot reorder %d columns%s with file of size %d\n",remap,remap>1?"s":"",size);
							} else {
								for (it=0;it<remap;it++) {
									for (tx=0;tx<width;tx++) {
										outputdata[outputidx++]=ae->hexbin[hbinidx].data[it+tx*remap];
									}
								}
							}
							
						} else if (vtiles) {
							/* tiles map reordering */
							int width,tilex,tiley;

							width=size/vtiles;

							if ((size % vtiles) || (vtiles*width>size)) {
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INCBIN VTILES cannot reorder %d line%s with file of size %d\n",vtiles,vtiles>1?"s":"",size);
							} else {
#if TRACE_HEXBIN
printf("Hexbin -> re-tiling MAP! width=%d\n",width);
#endif
								for (idx=tilex=tiley=0;idx<size;idx++) {
									outputdata[outputidx++]=ae->hexbin[hbinidx].data[tilex+tiley*width];
									tiley++;
									if (tiley>=vtiles) {
										tiley=0;
										tilex++;
									}
								}
							}
						} else {
#if TRACE_HEXBIN
printf("Hexbin -> Legacy output from %d to %d\n",offset,size+offset);
if (curhexbin->crunch) printf("CRUNCHED! (%d)\n",curhexbin->crunch);
#endif
							/* only from offset to size+offset */
							for (idx=offset;idx<size+offset;idx++) {
								outputdata[outputidx++]=ae->hexbin[hbinidx].data[idx];
							}

							switch (curhexbin->crunch) {
								#ifndef NO_3RD_PARTIES
								case 4:
									newdata=LZ4_crunch(outputdata,outputidx,&outputidx);
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with LZ4 into %d byte(s)\n",outputidx);
									#endif
									break;
								case 7:
									{
									size_t slzlen;
									newdata=ZX7_compress(optimize(outputdata, outputidx), outputdata, outputidx, &slzlen);
									outputidx=slzlen;
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with ZX7 into %d byte(s)\n",outputidx);
									#endif
									}
									break;
								case 8:
									if (outputidx>=1024) rasm_printf(ae,KWARNING"Exomizer is crunching %.1fkb this may take a while, be patient...\n",outputidx/1024.0);
									newdata=Exomizer_crunch(outputdata,outputidx,&outputidx);
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with Exomizer into %d byte(s)\n",outputidx);
									#endif
									break;
								case 17:
									if (outputidx>=1024) rasm_printf(ae,KWARNING"AP-Ultra is crunching %.1fkb this may take a while, be patient...\n",outputidx/1024.0);
									{
									int nnewlen;
									APULTRA_crunch(outputdata,outputidx,&newdata,&nnewlen);
									outputidx=nnewlen;
									}
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with AP-Ultra into %d byte(s)\n",outputidx);
									#endif
									break;
								case 18:
									if (outputidx>=16384 && curhexbin->version==2) rasm_printf(ae,KWARNING"LZSA2 is crunching %.1fkb this may take a while, be patient...\n",outputidx/1024.0);
									{
									int nnewlen;
									LZSA_crunch(outputdata,outputidx,&newdata,&nnewlen,curhexbin->version,curhexbin->minmatch);
									outputidx=nnewlen;
									}
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with LZSA%d into %d byte(s)\n",curhexbin->version,outputidx);
									#endif
									break;
								#endif
								case 48:
									newdata=LZ48_crunch(outputdata,outputidx,&outputidx);
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with LZ48 into %d byte(s)\n",outputidx);
									#endif
									break;
								case 49:
									newdata=LZ49_crunch(outputdata,outputidx,&outputidx);
									MemFree(outputdata);
									outputdata=newdata;
									#if TRACE_PREPRO
									rasm_printf(ae,KVERBOSE"crunched with LZ49 into %d byte(s)\n",outputidx);
									#endif
									break;
								default:break;
							}


							if (!overwritecheck) {
								rasm_printf(ae,KWARNING"INCBIN without overwrite check still not working...\n");
								if (ae->erronwarn) MaxError(ae);
							}
						}

						if (overwritecheck) {
							for (idx=0;idx<outputidx;idx++) {
								___output(ae,outputdata[idx]);
							}
						} else {
							___org_close(ae);
							___org_new(ae,0);
							/* hack to disable overwrite check */
							for (idx=0;idx<outputidx;idx++) {
								___output(ae,outputdata[idx]);
							}
							ae->orgzone[ae->io-1].nocode=2;
							___org_close(ae);
							___org_new(ae,0);
						}

						MemFree(outputdata);
					}
				}
			} else {
				MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INTERNAL - HEXBIN refer to unknown structure\n");
				FreeAssenv(ae);
				exit(2);
			}
		}
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"INTERNAL - HEXBIN need one HEX parameter\n");
		FreeAssenv(ae);
		exit(2);
	}
	
	/* generated names must be reloaded! */
	if (deload) {
		ae->hexbin[hbinidx].datalen=-1;
		MemFree(ae->hexbin[hbinidx].data);
	}
}

/*
save "nom",start,size -> save binary
save "nom",start,size,TAPE,"cdtname" -> save tape file
save "nom",start,size,AMSDOS -> save binary with Amsdos header
save "nom",start,size,DSK,"dskname" -> save binary on DSK data format
save "nom",start,size,DSK,"dskname",B -> select face
save "nom",start,size,DSK,B -> current DSK, choose face
save "nom",start,size,DSK -> current DSK, current face
*/
void __SAVE(struct s_assenv *ae) {
	#undef FUNC
	#define FUNC "__SAVE"

	struct s_save cursave={0};
	int ko=1;




	if (!ae->wl[ae->idx].t) {
		/* nom de fichier entre quotes ou bien mot clef DSK */
		if (!StringIsQuote(ae->wl[ae->idx+1].w)) {
			MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SAVE invalid filename quote\n");
			ko=0;
		} else {
			if (!ae->wl[ae->idx+1].t) {
				if (!ae->wl[ae->idx+2].t && ae->wl[ae->idx+3].t!=2) {
					cursave.ibank=ae->activebank;
					cursave.ioffset=ae->idx+2;
					ExpressionFastTranslate(ae,&ae->wl[ae->idx+2].w,1); // si on utilise des variables ça évite la grouille post traitement...
					cursave.isize=ae->idx+3;
					ExpressionFastTranslate(ae,&ae->wl[ae->idx+3].w,1); // idem
					cursave.iw=ae->idx+1;
					cursave.irun=ae->current_run_idx;
					if (!ae->wl[ae->idx+3].t) {
						if (strcmp(ae->wl[ae->idx+4].w,"TAPE")==0) {
							cursave.tape=1;
							if (!ae->wl[ae->idx+4].t) {
								cursave.iwdskname=ae->idx+5;
							} else {
								cursave.iwdskname=-1;
								MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"cannot autoselect TAPE, please specify a filename after TAPE arg\n");
							}
						} else if (strcmp(ae->wl[ae->idx+4].w,"AMSDOS")==0) {
							cursave.amsdos=1;
						} else if (strcmp(ae->wl[ae->idx+4].w,"HOBETA")==0) {
							cursave.hobeta=1;
						} else if (strcmp(ae->wl[ae->idx+4].w,"DSK")==0) {
#if TRACE_EDSK
	printf("DSK SAVE order [bnk: %d ioff: %d isiz: %d iw=%d [%s] [%s]\n",cursave.ibank,cursave.ioffset,cursave.isize,cursave.iw,ae->wl[ae->idx+2].w,ae->wl[ae->idx+3].w);
#endif
							cursave.dsk=1;
							if (!ae->wl[ae->idx+4].t) {
								cursave.iwdskname=ae->idx+5;
								if (!ae->wl[ae->idx+5].t) {
									/* face selection - 0 as default */
									switch (ae->wl[ae->idx+6].w[0]) {
										case '1':
										case 'B':
											cursave.face=1;
											break;
										case '0':
										case 'A':
										default:
											cursave.face=0;
											break;
									}
								}
							} else {
								if (ae->nbsave && ae->save[ae->nbsave-1].iwdskname!=-1) {
									cursave.iwdskname=ae->save[ae->nbsave-1].iwdskname; /* previous DSK */
									cursave.face=ae->save[ae->nbsave-1].face; /* previous face */
								} else {
									cursave.iwdskname=-1;
									MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"cannot autoselect DSK as there was not a previous selection\n");
								}
							}
						} else {
							MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"SAVE 4th parameter must be empty or AMSDOS or DSK\n");
							ko=0;
						}
					}
					ObjectArrayAddDynamicValueConcat((void**)&ae->save,&ae->nbsave,&ae->maxsave,&cursave,sizeof(cursave));
					ko=0;
				}
			}
		}
	}
	if (ko) {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"Use SAVE 'filename',offset,size[,AMSDOS|DSK[,A|B|'dskname'[,A|B]]]\n");
	}
	while (!ae->wl[ae->idx].t) ae->idx++;
}


void __MODULE(struct s_assenv *ae) {
	#undef FUNC
	#define FUNC "__MODULE"

	if (!ae->wl[ae->idx].t && ae->wl[ae->idx+1].t==1) {
		if (strcmp(ae->wl[ae->idx+1].w,"OFF")==0) {
			if (ae->module || ae->modulen) MemFree(ae->module);
			ae->module=NULL;
			ae->modulen=0;
		} else {
			if (ae->modulen || ae->module) {
				MemFree(ae->module);
			}
			ae->modulen=strlen(ae->wl[ae->idx+1].w);
			ae->module=TxtStrDup(ae->wl[ae->idx+1].w);
		}
		ae->idx++;
	} else {
		if (ae->module || ae->modulen) MemFree(ae->module);
		ae->module=NULL;
		ae->modulen=0;
	}
}

void __SUMMEM(struct s_assenv *ae) {
	struct s_poker poker={0};

	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		/* no poke in a NOCODE section */
		if (!ae->nocode) {
			poker.method=E_POKER_SUM8;
			poker.istart=ae->idx+1;
			poker.iend=ae->idx+2;
			poker.outputadr=ae->outputadr;
			poker.ibank=ae->activebank;
			ObjectArrayAddDynamicValueConcat((void**)&ae->poker,&ae->nbpoker,&ae->maxpoker,&poker,sizeof(poker));
		}
		___output(ae,0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is SUMMEM start,end\n");
	}
}

void __XORMEM(struct s_assenv *ae) {
	struct s_poker poker={0};

	if (!ae->wl[ae->idx].t && !ae->wl[ae->idx+1].t && ae->wl[ae->idx+2].t==1) {
		/* no poke in a NOCODE section */
		if (!ae->nocode) {
			poker.method=E_POKER_XOR8;
			poker.istart=ae->idx+1;
			poker.iend=ae->idx+2;
			poker.outputadr=ae->outputadr;
			poker.ibank=ae->activebank;
			ObjectArrayAddDynamicValueConcat((void**)&ae->poker,&ae->nbpoker,&ae->maxpoker,&poker,sizeof(poker));
		}
		___output(ae,0);
	} else {
		MakeError(ae,GetCurrentFile(ae),ae->wl[ae->idx].l,"usage is XORMEM start,end\n");
	}
}

void __TIMESTAMP(struct s_assenv *ae) {
	char Ltimestamp[32];
	char LTMP[64];
	struct tm *local;
	char *timestr;
	time_t now;
	int idx=0;
	int cpt;

	time(&now);
	local=localtime(&now);

	if (!ae->wl[ae->idx].t) {
		ae->idx++;
		timestr=ae->wl[ae->idx].w+1;
	} else {
		timestr=Ltimestamp;
		strcpy(timestr,"[Y-M-D h:m]");
	}

	while (timestr[idx]) {
		switch (timestr[idx]) {
			case 'Y':
				cpt=0;
				while (timestr[idx]=='Y') {idx++;cpt++;}
				sprintf(LTMP,"%04d",local->tm_year+1900);
				switch (cpt) {
					case 2:	___output(ae,LTMP[2]);
						___output(ae,LTMP[3]);
						break;
					case 1:
					case 4:	___output(ae,LTMP[0]);
						___output(ae,LTMP[1]);
						___output(ae,LTMP[2]);
						___output(ae,LTMP[3]);
						break;
				}
				break;
			case 'M':
				while (timestr[idx]=='M') idx++;
				sprintf(LTMP,"%02d",local->tm_mon+1);
				___output(ae,LTMP[0]);
				___output(ae,LTMP[1]);
				break;
			case 'D':
				while (timestr[idx]=='D') idx++;
				sprintf(LTMP,"%02d",local->tm_mday);
				___output(ae,LTMP[0]);
				___output(ae,LTMP[1]);
				break;
			case 'h':
				while (timestr[idx]=='h') idx++;
				sprintf(LTMP,"%02d",local->tm_hour);
				___output(ae,LTMP[0]);
				___output(ae,LTMP[1]);
				break;
			case 'm':
				while (timestr[idx]=='m') idx++;
				sprintf(LTMP,"%02d",local->tm_min);
				___output(ae,LTMP[0]);
				___output(ae,LTMP[1]);
				break;
			case 's':
				while (timestr[idx]=='s') idx++;
				sprintf(LTMP,"%02d",local->tm_sec);
				___output(ae,LTMP[0]);
				___output(ae,LTMP[1]);
				break;
			default:
				if ((timestr[idx]=='\'' || timestr[idx]=='"') && !timestr[idx+1]) {} else ___output(ae,timestr[idx]);
				idx++;
				break;

		}
	}
}

struct s_asm_keyword instruction[]={
{"LD",0,_LD},
{"DEC",0,_DEC},
{"INC",0,_INC},
{"ADD",0,_ADD},
{"SUB",0,_SUB},
{"OR",0,_OR},
{"AND",0,_ZAND},
{"XOR",0,_XOR},
{"POP",0,_POP},
{"PUSH",0,_PUSH},
{"DJNZ",0,_DJNZ},
{"JR",0,_JR},
{"JP",0,_JP},
{"CALL",0,_CALL},
{"RET",0,_RET},
{"EX",0,_EX},
{"ADC",0,_ADC},
{"SBC",0,_SBC},
{"EXA",0,_EXA},
{"EXX",0,_EXX},
{"CP",0,_CP},
{"BIT",0,_BIT},
{"RES",0,_RES},
{"SET",0,_SET},
{"IN",0,_IN},
{"OUT",0,_OUT},
{"RLC",0,_RLC},
{"RRC",0,_RRC},
{"RL",0,_RL},
{"RR",0,_RR},
{"SLA",0,_SLA},
{"SRA",0,_SRA},
{"SLL",0,_SLL},
{"SL1",0,_SLL},
{"SRL",0,_SRL},
{"RST",0,_RST},
{"HALT",0,_HALT},
{"DI",0,_DI},
{"EI",0,_EI},
{"NOP",0,_NOP},
{"DEFF",0,_DEFF},
{"DEFR",0,_DEFR},
{"DEFB",0,_DEFB},
{"DEFM",0,_DEFB},
{"DF",0,_DEFF},
{"DR",0,_DEFR},
{"DM",0,_DEFB},
{"DB",0,_DEFB},
{"DEFW",0,_DEFW},
{"DW",0,_DEFW},
{"DEFS",0,_DEFS},
{"DS",0,_DEFS},
{"STR",0,_STR},
{"LDI",0,_LDI},
{"LDIR",0,_LDIR},
{"OUTI",0,_OUTI},
{"INI",0,_INI},
{"RLCA",0,_RLCA},
{"RRCA",0,_RRCA},
{"NEG",0,_NEG},
{"RLA",0,_RLA},
{"RRA",0,_RRA},
{"RLD",0,_RLD},
{"RRD",0,_RRD},
{"DAA",0,_DAA},
{"CPL",0,_CPL},
{"SCF",0,_SCF},
{"LDD",0,_LDD},
{"LDDR",0,_LDDR},
{"CCF",0,_CCF},
{"OUTD",0,_OUTD},
{"IND",0,_IND},
{"RETI",0,_RETI},
{"RETN",0,_RETN},
{"IM",0,_IM},
{"DEFI",0,_DEFI},
{"CPD",0,_CPD},
{"CPI",0,_CPI},
{"CPDR",0,_CPDR},
{"CPIR",0,_CPIR},
{"OTDR",0,_OTDR},
{"OTIR",0,_OTIR},
{"INDR",0,_INDR},
{"INIR",0,_INIR},
{"REPEAT",0,__REPEAT},
{"REND",0,__REND},
{"ENDREPEAT",0,__REND},
{"ENDREP",0,__REND},
{"UNTIL",0,__UNTIL},
{"ORG",0,__ORG},
{"PROTECT",0,__PROTECT},
{"WHILE",0,__WHILE},
{"WEND",0,__WEND},
{"READ",0,__READ},
{"INCLUDE",0,__READ}, // anti-label
{"HEXBIN",0,__HEXBIN},
{"ALIGN",0,__ALIGN},
{"ELSEIF",0,__ELSEIF},
{"ELSE",0,__ELSE},
{"IF",0,__IF},
{"ENDIF",0,__ENDIF},
{"IFNOT",0,__IFNOT},
{"IFDEF",0,__IFDEF},
{"IFNDEF",0,__IFNDEF},
{"IFUSED",0,__IFUSED},
{"IFNUSED",0,__IFNUSED},
{"UNDEF",0,__UNDEF},
{"CASE",0,__CASE},
{"BREAK",0,__BREAK},
{"DEFAULT",0,__DEFAULT},
{"SWITCH",0,__SWITCH},
{"ENDSWITCH",0,__ENDSWITCH},
{"WRITE",0,__WRITE},
{"CODE",0,__CODE},
{"NOCODE",0,__NOCODE},
{"MEMSPACE",0,__MEMSPACE},
{"MACRO",0,__MACRO},
{"TICKER",0,__TICKER},
{"LET",0,__LET},
{"ASSERT",0,__ASSERT},
{"CHARSET",0,__CHARSET},
{"RUN",0,__RUN},
{"SAVE",0,__SAVE},
{"BRK",0,__BRK},
{"NOLIST",0,__NOLIST},
{"LIST",0,__LIST},
{"STOP",0,__STOP},
{"PRINT",0,__PRINT},
{"FAIL",0,__FAIL},
{"BREAKPOINT",0,__BREAKPOINT},
{"BANK",0,__BANK},
{"BANKSET",0,__BANKSET},
{"NAMEBANK",0,__NameBANK},
{"LIMIT",0,__LIMIT},
{"LZEXO",0,__LZEXO},
{"LZX7",0,__LZX7},
{"LZAPU",0,__LZAPU},
{"LZSA1",0,__LZSA1},
{"LZSA2",0,__LZSA2},
{"LZ4",0,__LZ4},
{"LZ48",0,__LZ48},
{"LZ49",0,__LZ49},
{"LZCLOSE",0,__LZCLOSE},
{"SNASET",0,__SNASET},
{"BUILDZX",0,__BUILDZX},
{"BUILDCPR",0,__BUILDCPR},
{"BUILDSNA",0,__BUILDSNA},
{"BUILDROM",0,__BUILDROM},
{"BUILDTAPE",0,__BUILDTAPE},
{"SETCPC",0,__SETCPC},
{"SETCRTC",0,__SETCRTC},
{"AMSDOS",0,__AMSDOS},
{"OTD",0,_OUTD},
{"OTI",0,_OUTI},
{"SHL",0,_SLA},
{"SHR",0,_SRL},
{"STRUCT",0,__STRUCT},
{"ENDSTRUCT",0,__ENDSTRUCT},
{"ENDS",0,__ENDSTRUCT},
{"NOEXPORT",0,__NOEXPORT},
{"ENOEXPORT",0,__ENOEXPORT},
{"MODULE",0,__MODULE},
{"TIMESTAMP",0,__TIMESTAMP},
{"SUMMEM",0,__SUMMEM},
{"XORMEM",0,__XORMEM},
{"",0,NULL}
};

int IsDirective(char *zeexpression)
{
	int i,crc;

	crc=GetCRC(zeexpression);

	for (i=0;instruction[i].mnemo[0];i++) if (instruction[i].crc==crc && !strcmp(instruction[i].mnemo,zeexpression)) return 1;

	return 0;
}


int Assemble(struct s_assenv *ae, unsigned char **dataout, int *lenout, struct s_rasm_info **debug)
{
	#undef FUNC
	#define FUNC "Assemble"

	unsigned char *AmsdosHeader;
	struct s_expression curexp={0};
	struct s_wordlist *wordlist;
	struct s_label *curlabel;
	int icrc,curcrc,i,j,k;
	unsigned char *lzdata=NULL;
	int lzlen,lzshift,input_size;
	size_t slzlen;
	unsigned char *input_data;
	struct s_orgzone orgzone={0};
	int iorgzone,ibank,offset,endoffset,morgzone,saveorgzone;
	int il,maxrom;
	char *TMP_filename=NULL;
	int minmem=65536,maxmem=0,lzmove;
	char symbol_line[1024];
	int ifast,executed;
	/* debug */
	int curii,inhibe;
	int ok;




	rasm_printf(ae,KAYGREEN"Assembling\n");
#if TRACE_ASSEMBLE
printf("assembling (nberr=%d)\n",ae->nberr);
#endif
#if TRACE_GENERALE
printf("*** assembling ***\n");
#endif

	ae->retdebug=debug;

	srand((unsigned)time(0));
	
	wordlist=ae->wl;
	ae->wl=wordlist;
	/* start outside crunched section */
	ae->lz=-1;
	
	/* default orgzone */
	orgzone.ibank=BANK_MAX_NUMBER;
	orgzone.inplace=1;
	ObjectArrayAddDynamicValueConcat((void**)&ae->orgzone,&ae->io,&ae->mo,&orgzone,sizeof(orgzone));
	___output=___internal_output;
	/* init des automates */
	InitAutomate(ae->AutomateHexa,(unsigned char *)AutomateHexaDefinition);
	InitAutomate(ae->AutomateDigit,(unsigned char *)AutomateDigitDefinition);
	InitAutomate(ae->AutomateValidLabel,(unsigned char *)AutomateValidLabelDefinition);
	InitAutomate(ae->AutomateValidLabelFirst,(unsigned char *)AutomateValidLabelFirstDefinition);
	InitAutomate(ae->AutomateExpressionValidCharExtended,(unsigned char *)AutomateExpressionValidCharExtendedDefinition);
	InitAutomate(ae->AutomateExpressionValidCharFirst,(unsigned char *)AutomateExpressionValidCharFirstDefinition);
	InitAutomate(ae->AutomateExpressionValidChar,(unsigned char *)AutomateExpressionValidCharDefinition);
	ae->AutomateExpressionDecision['<']='<';
	ae->AutomateExpressionDecision['>']='>';
	ae->AutomateExpressionDecision['=']='=';
	ae->AutomateExpressionDecision['!']='!';
	ae->AutomateExpressionDecision[0]='E';
	/* gestion d'alias */
	ae->AutomateExpressionDecision['~']='~';
	/* set operator precedence */
	if (!ae->maxam) {
		for (i=0;i<256;i++) {
			ae->AutomateElement[i].string=NULL;
			switch (i) {
				/* priority 0 */
				case '(':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_OPEN;ae->AutomateElement[i].priority=0;break;
				case ')':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_CLOSE;ae->AutomateElement[i].priority=0;break;
				/* priority 1 */
				case 'b':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_NOT;ae->AutomateElement[i].priority=1;break;
				/* priority 2 */
				case '*':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_MUL;ae->AutomateElement[i].priority=2;break;
				case '/':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_DIV;ae->AutomateElement[i].priority=2;break;
				case 'm':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_MOD;ae->AutomateElement[i].priority=2;break;
				/* priority 3 */
				case '+':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_ADD;ae->AutomateElement[i].priority=3;break;
				case '-':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SUB;ae->AutomateElement[i].priority=3;break;
				/* priority 4 */
				case '[':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SHL;ae->AutomateElement[i].priority=4;break;
				case ']':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SHR;ae->AutomateElement[i].priority=4;break;
				/* priority 5 */
				case 'l':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_LOWER;ae->AutomateElement[i].priority=5;break;
				case 'g':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_GREATER;ae->AutomateElement[i].priority=5;break;
				case 'e':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_EQUAL;ae->AutomateElement[i].priority=5;break;
				case 'n':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_NOTEQUAL;ae->AutomateElement[i].priority=5;break;
				case 'k':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_LOWEREQ;ae->AutomateElement[i].priority=5;break;
				case 'h':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_GREATEREQ;ae->AutomateElement[i].priority=5;break;
				/* priority 6 */
				case '&':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_ZAND;ae->AutomateElement[i].priority=6;break;
				/* priority 7 */
				case '^':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_XOR;ae->AutomateElement[i].priority=7;break;
				/* priority 8 */
				case '|':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_OR;ae->AutomateElement[i].priority=8;break;
				/* priority 9 */
				case 'a':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_BAND;ae->AutomateElement[i].priority=9;break;
				/* priority 10 */
				case 'o':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_BOR;ae->AutomateElement[i].priority=10;break;
				default:ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_END;
			}
		}
	} else {
		for (i=0;i<256;i++) {
			ae->AutomateElement[i].string=NULL;
			switch (i) {
				/* priority 0 */
				case '(':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_OPEN;ae->AutomateElement[i].priority=0;break;
				case ')':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_CLOSE;ae->AutomateElement[i].priority=0;break;
				/* priority 0.5 */
				case 'b':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_NOT;ae->AutomateElement[i].priority=128;break;
				/* priority 1 */
				case '*':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_MUL;ae->AutomateElement[i].priority=464;break;
				case '/':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_DIV;ae->AutomateElement[i].priority=464;break;
				case 'm':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_MOD;ae->AutomateElement[i].priority=464;break;
				case '+':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_ADD;ae->AutomateElement[i].priority=464;break;
				case '-':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SUB;ae->AutomateElement[i].priority=464;break;
				case '[':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SHL;ae->AutomateElement[i].priority=464;break;
				case ']':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_SHR;ae->AutomateElement[i].priority=464;break;
				case '&':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_ZAND;ae->AutomateElement[i].priority=464;break;
				case '^':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_XOR;ae->AutomateElement[i].priority=464;break;
				case '|':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_OR;ae->AutomateElement[i].priority=464;break;
				/* priority 2 */
				case 'l':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_LOWER;ae->AutomateElement[i].priority=664;break;
				case 'g':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_GREATER;ae->AutomateElement[i].priority=664;break;
				case 'e':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_EQUAL;ae->AutomateElement[i].priority=664;break;
				case 'n':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_NOTEQUAL;ae->AutomateElement[i].priority=664;break;
				case 'k':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_LOWEREQ;ae->AutomateElement[i].priority=664;break;
				case 'h':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_GREATEREQ;ae->AutomateElement[i].priority=664;break;
				/* priority 3 */
				case 'a':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_BAND;ae->AutomateElement[i].priority=6128;break;
				case 'o':ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_BOR;ae->AutomateElement[i].priority=6128;break;
				default:ae->AutomateElement[i].operator=E_COMPUTE_OPERATION_END;
			}
		}
	}

	/* psg conversion */
	for (i=j=0;i<100;i++) ae->psgtab[j++]=0;
	for (i=0;i<49;i++) ae->psgtab[j++]=13;
	for (i=0;i<35;i++) ae->psgtab[j++]=14;
	for (i=0;i<72;i++) ae->psgtab[j++]=15;
	if (j!=256) {
		rasm_printf(ae,"Internal error with PSG conversion table\n");
		exit(-44);
	}
	for (i=j=0;i<1;i++) ae->psgfine[j++]=0;
	for (i=0;i<1;i++) ae->psgfine[j++]=1;
	for (i=0;i<1;i++) ae->psgfine[j++]=2;
	for (i=0;i<2;i++) ae->psgfine[j++]=3;
	for (i=0;i<2;i++) ae->psgfine[j++]=4;
	for (i=0;i<2;i++) ae->psgfine[j++]=5;
	for (i=0;i<3;i++) ae->psgfine[j++]=6;
	for (i=0;i<4;i++) ae->psgfine[j++]=7;
	for (i=0;i<7;i++) ae->psgfine[j++]=8;
	for (i=0;i<9;i++) ae->psgfine[j++]=9;
	for (i=0;i<13;i++) ae->psgfine[j++]=10;
	for (i=0;i<19;i++) ae->psgfine[j++]=11;
	for (i=0;i<27;i++) ae->psgfine[j++]=12;
	for (i=0;i<37;i++) ae->psgfine[j++]=13;
	for (i=0;i<53;i++) ae->psgfine[j++]=14;
	for (i=0;i<75;i++) ae->psgfine[j++]=15;
	if (j!=256) {
		rasm_printf(ae,"Internal error with PSG conversion table\n");
		exit(-44);
	}
	/* default var */
	ae->autorise_export=1;
	ExpressionSetDicoVar(ae,"PI",3.1415926545);
	ExpressionSetDicoVar(ae,"ASSEMBLER_RASM",1);
	
	/* add a fictive expression to simplify test when parsing expressions */
	ObjectArrayAddDynamicValueConcat((void **)&ae->expression,&ae->ie,&ae->me,&curexp,sizeof(curexp));
	
	/* compute CRC for keywords and directives */
	for (icrc=0;instruction[icrc].mnemo[0];icrc++) instruction[icrc].crc=GetCRC(instruction[icrc].mnemo);
	for (icrc=0;math_keyword[icrc].mnemo[0];icrc++) math_keyword[icrc].crc=GetCRC(math_keyword[icrc].mnemo);

	if (ae->as80==1 || ae->pasmo) { /* not for UZ80 */
		for (icrc=0;instruction[icrc].mnemo[0];icrc++) {
			if (strcmp(instruction[icrc].mnemo,"DEFB")==0 || strcmp(instruction[icrc].mnemo,"DB")==0) {
				instruction[icrc].makemnemo=_DEFB_as80;
			} else if (strcmp(instruction[icrc].mnemo,"DEFW")==0 || strcmp(instruction[icrc].mnemo,"DW")==0) {
				instruction[icrc].makemnemo=_DEFW_as80;
			} else if (strcmp(instruction[icrc].mnemo,"DEFI")==0) {
				instruction[icrc].makemnemo=_DEFI_as80;
			}
		}
	} else {
		/* for multiple configurations with rasm embedded */
		for (icrc=0;instruction[icrc].mnemo[0];icrc++) {
			if (strcmp(instruction[icrc].mnemo,"DEFB")==0 || strcmp(instruction[icrc].mnemo,"DB")==0) {
				instruction[icrc].makemnemo=_DEFB;
			} else if (strcmp(instruction[icrc].mnemo,"DEFW")==0 || strcmp(instruction[icrc].mnemo,"DW")==0) {
				instruction[icrc].makemnemo=_DEFW;
			} else if (strcmp(instruction[icrc].mnemo,"DEFI")==0) {
				instruction[icrc].makemnemo=_DEFI;
			}
		}
	}
	
	for (icrc=0;instruction[icrc].mnemo[0];icrc++) {
		/* get indexes for DEF instructions */
		if (strcmp(instruction[icrc].mnemo,"DEFB")==0) {
			ICRC_DEFB=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DB")==0) {
			ICRC_DB=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DEFW")==0) {
			ICRC_DEFW=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DW")==0) {
			ICRC_DW=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DEFF")==0) {
			ICRC_DEFF=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DF")==0) {
			ICRC_DF=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DEFR")==0) {
			ICRC_DEFR=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DR")==0) {
			ICRC_DR=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DEFS")==0) {
			ICRC_DEFS=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DS")==0) {
			ICRC_DS=icrc;
		} else if (strcmp(instruction[icrc].mnemo,"DEFI")==0) {
			ICRC_DEFI=icrc;
		}
	}
	
	/* Execution des mots clefs */
	/**********************************************************
	       A S S E M B L I N G    M A I N    L O O P
	**********************************************************/
#if TRACE_ASSEMBLE
printf("init ok\n");
#endif
#if TRACE_GENERALE
printf("-loop\n");
#endif
	
	ae->idx=1;
	while (wordlist[ae->idx].t!=2) {
		curcrc=GetCRC(wordlist[ae->idx].w);
		/*********************
		 d e b u g   i n f o
		*********************/
		#if TRACE_ASSEMBLE
		{
			int iiii=0;
			printf(KVERBOSE"%d [%s] L%d [%s]e=%d ",ae->idx,ae->filename[wordlist[ae->idx].ifile],wordlist[ae->idx].l,wordlist[ae->idx].w,wordlist[ae->idx].e);
			while (!wordlist[ae->idx+iiii++].t) rasm_printf(ae," [%s]e=%d ",wordlist[ae->idx+iiii].w,wordlist[ae->idx+iiii].e);
			
			for (iiii=0;iiii<ae->imacropos;iiii++) {
				printf("M[%d] s=%d e=%d ",iiii,ae->macropos[iiii].start,ae->macropos[iiii].end);
			}
			printf("\n");
		}
		#endif

		/********************************************************************
		  c o n d i t i o n n a l    a s s e m b l y    m a n a g e m e n t
		********************************************************************/
		if (ae->ii || ae->isw) {
			/* inhibition of if/endif */
			for (inhibe=curii=0;curii<ae->ii;curii++) {
				if (!ae->ifthen[curii].v || ae->ifthen[curii].v==-1) {
					inhibe=1;
					break;
				}
			}
			/* when inhibited we are looking only for a IF/IFDEF/IFNOT/IFNDEF/ELSE/ELSEIF/ENDIF or SWITCH/CASE/DEFAULT/ENDSWITCH */
			if (inhibe) {
				/* this section does NOT need to be agressively optimized !!! */
				if (curcrc==CRC_ELSEIF && strcmp(wordlist[ae->idx].w,"ELSEIF")==0) {
					/* true IF needs to be done ONLY on the active level */
					if (curii==ae->ii-1) __ELSEIF(ae); else __ELSEIF_light(ae);
				} else if (curcrc==CRC_ELSE && strcmp(wordlist[ae->idx].w,"ELSE")==0) {
					__ELSE(ae);
				} else if (curcrc==CRC_ENDIF && strcmp(wordlist[ae->idx].w,"ENDIF")==0) {
					__ENDIF(ae);
				} else if (curcrc==CRC_IF && strcmp(wordlist[ae->idx].w,"IF")==0) {
					/* as we are inhibited we do not have to truly compute IF */
					__IF_light(ae);
				} else if (curcrc==CRC_IFDEF && strcmp(wordlist[ae->idx].w,"IFDEF")==0) {
					__IFDEF_light(ae);
				} else if (curcrc==CRC_IFNOT && strcmp(wordlist[ae->idx].w,"IFNOT")==0) {
					__IFNOT_light(ae);
				} else if (curcrc==CRC_IFUSED && strcmp(wordlist[ae->idx].w,"IFUSED")==0) {
					__IFUSED_light(ae);
				} else if (curcrc==CRC_IFNUSED && strcmp(wordlist[ae->idx].w,"IFNUSED")==0) {
					__IFNUSED_light(ae);
				} else if (curcrc==CRC_IFNDEF && strcmp(wordlist[ae->idx].w,"IFNDEF")==0) {
					__IFNDEF_light(ae);
				} else if (curcrc==CRC_SWITCH && strcmp(wordlist[ae->idx].w,"SWITCH")==0) {
					__SWITCH_light(ae);
				} else if (curcrc==CRC_CASE && strcmp(wordlist[ae->idx].w,"CASE")==0) {
					__CASE_light(ae);
				} else if (curcrc==CRC_ENDSWITCH && strcmp(wordlist[ae->idx].w,"ENDSWITCH")==0) {
					__ENDSWITCH(ae);
				} else if (curcrc==CRC_BREAK && strcmp(wordlist[ae->idx].w,"BREAK")==0) {
					__BREAK_light(ae);
				} else if (curcrc=