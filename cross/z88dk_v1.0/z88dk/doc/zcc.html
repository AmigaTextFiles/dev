<HTML>
<HEAD>
<TITLE>Z88 Development Kit v1.0 sccz80v1.10b0.52 - 22/3/99</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" FGCOLOR="#000000">
<A NAME="top"></A>
<H1><CENTER>Z88 Development Kit</CENTER></H1>
<P>

<P><H2>WARNING!!!</H2>

<P>Even though the compiler has been under development for several months
now, it goes without saying that (im)proper use
of the output code could very easily wipe or corrupt the memory of your Z88
- you have been warned! - Back up all data before doing anything!</P>


<P>
<UL>
        <LI><A HREF="#new">What's New?</A>
        <LI><A HREF="#intro">Introduction</A>
        <LI><A HREF="#status">Status</A>
        <LI><A HREF="#acknowledge">Acknowledgements</A>
        <LI><A HREF="#install">Installation</A>
        <LI><A HREF="#frontend">The Frontend</A>
        <LI><A HREF="#compiler">Compiler</A>
        <LI><A HREF="#linker">Assembler and Linker</A>
        <LI><A HREF="#copt">z80 Code Optimizer</A>
        <LI><A HREF="#diss">The Disassemblers</A>
        <LI><A HREF="#libraries">Libraries and Includes</A>
        <LI><A HREF="#examples">Example Programs</A>
        <LI><A HREF="history.html">Package History</A>
        <LI><A HREF="#problems">Known feechurs</A>
        <LI><A HREF="#future">Future Directions</A>
        <LI><A HREf="#machine">The Machine and Development Process</A>
</UL>
</P>
<HR>

<H2><A NAME="new"></A>What's New?</A></H2>

<P>New for v0.52 of the compiler are the following features:</P>

<UL>
        <LI> Assembler <A HREF="#macros">Macros</A> using the asm() construct
        <LI> String concatenation (for string constants)
        <LI> Ability to initialise global (*func)() types
        <LI> Sizeof now works on all variables
        <LI> Even more correct prototypes!
        <LI> Correct initialisation of intialised local statics
        <LI> Fixed long constant loading (I broke it last time!)
        <LI> Added new library functions for unsigned >> ops
        <LI> Lots of little things changed, code tidied up etc
        <LI> Yup, more rules, and fixed a bug in them which could crash copt if it was feeling awkward
        <LI> -lmz flag for zcc to automagically use Z88math
        <LI> WarpUp binaries for sccz80, copt, zcpp
</UL>

<P>New for v0.49 of the compiler are the following features:</P>

<UL>
        <LI>Proper function prototyping
        <LI>ANSI style function definitios
        <LI>Type checking on function calls (if prototyped) and promotion
as necessary
        <LI>More rigorous type conversion in general
        <LI>Initialisation of local statics (except for doubles)
        <LI>Correct initialisation of char arrays in structs
        <LI>Use of the literal queue for char *ptr="[text]"; (previously
initialisation was achieved via a ASMPC+2 style construct)
        <LI>Ability to do sizeof() of const char string eg sizeof("fish")
        <LI>Type specifiers LUS for numeric constants
        <LI>Redirectable stdin, stdout, stderr
        <LI>Fixed feof(),getc(), added ftell(),getpos(),gets(),putc()
        <LI>More optimization rules (including a speed(!) one!)
        <LI>Rejigged front end allowing easy retargetting of the compiler
for other Z80 machines
        <LI>Hopefully memory leak free WinSucks version
        <LI>Z80asm v1.0.5
</UL>
<HR>

<H2><A NAME="intro"></A>Introduction</A></H2>

<P>
The Z88 Development Kit justifies it name because it is a set of tools which enable the development of programs for the Cambridge Computers Z88
Computer in either C or assembly language.</P>

<P>
The kit is built around the Z80 Module Assembler (hereafter known as z80asm)
from Interlogic and a Small C+ compiler, it is supplied with a set of
standard libraries for most common functions which may used from either
machine code or from C.</P>

<P>
The code output by the compiler is of a form suitable for use from the BBC
BASIC application, though in the <A HREF="#future">future</A>, development of ROMable Z88 applications will be feasible.</P>

<P>
Even though this project is entitled the Z88 Development Kit, it should really be titled the Z80 Development Kit for it is quite suitable for
generating code for other Z80 based computers, though the implementation of
the various libraries required to achieve this is "left as a an exercise
for the reader".
</P>


<HR>
<H2><A NAME="status"></A>Status</H2>

<P>
When finally released, the entire package will be freeware, though copyright
will be reserved on the Z80 Module Assembler and the library files, however
any software produced using it will be royalty free - just send myself and
Gunther a copy!
</P>

<P>I hope that this will be last pre-release (really!), I would really like
to get
this thing out into the open by the middle of March (by then it will have
had a gestation period of 7 months!) - this doesn't mean that development
will have stopped - it just gives me a time to stand back, and see what
other people make of it



<HR>
<H2><A NAME="acknowledge"></A>Acknowledgements</H2>

<P>
I've barely started and already I have a list of acknowledgments!</P>

<UL>
       <LI> Gunther Strube - For modifying z80asm to make my life that bit easier.
       <LI> Garry Lancaster - For being as fanatical about Forth as I am
about C (or should that be: for fanatical as being Forth about I as about C am?!? &ltgrin&gt)
       <LI> Dennis Groning - For being one of the best testers I could hope
for and slogging away at the PC compilations.
       <LI> David Earlam - For the many constructive comments and contributions.
       <LI> Joe Mackay - For further Amiga testing
       <LI> Andy Davis - For lending me a Z88 so I can play with this amazing machine.
       <LI> Oriel - For putting up with me in general and tolerating my
computer farm.
       <LI> Mogwai and Red House Painters for their amazing music.
</UL>
<P>Special thanks must go to <A HREF="http://www.norweb.co.uk">Norweb</a>
and the <A HREF="http://www.man.ac.uk">University of Manchester</A> for
providing me with the opportunity to rewrite and hence improve code due
to powercuts/trip switch tripping. Cheers, guys, really appreciate it!</P>


<P>The Z88 Development Kit was, and always will be, "Made with <A HREF="http://www.amiga.de">Amiga</A>."</P>

<HR>
<H2><A NAME="install"></A>Installation</H2>

<P>
Once you have unarchived the package (I assume you must have been able to
do this since you are reading this document) you will find the following
directory structure:</P>

<PRE>
        
        bin/        Executable directory
        doc/        Place for doc files
        examples/   A couple of little example programs
        include/    Header files for the C compiler
        lib/        Where the runtime libraries and startup code live
        libsrc/     Source for the runtime libraries
        src/
        src/z80asm  Source for the z80asm Module Assembler
        src/copt    Source for the z80 code optimiser
        src/cpp     Source for the DECUS cpp
        src/dz80    Source for the dz80 disassembler
        src/dzasm   Source for the dzasm disassembler (not provided)
        src/sccz80  Source for the C compiler
        src/zcc     Source for the front end</PRE>


<P>Obviously you will need to compile the source code (if you use an Amiga 
you'll find some precompiled binaries in the bin directory), to do this, 
go to the root of the tree and enter the key:

<PRE>
        makefile.sh</PRE>

And with a bit of luck everything will be built for you and placed in the 
bin/ directory. Of course before you do this you may need to tweak  it
slightly for your compiler.</P>

<P>This script also builds the libraries for you and places them in the lib/ directory.</P>

<P>NB. All include files for z80asm are now kept in {zcc}/lib - this
simplifies installation very considerable, and creates a unified
package.</P>

<H4>Amiga Notes</H4>

<P>I include the script <B>startzcc</B> which will set up the various
assigns and paths that are needed for everything to work out of the box -
you will have to change the definition of ZCC: so that it matches your hard
drive set up though.</P>


<HR>
<H2><A NAME="frontend"></A>The Frontend</A></H2>

<P>As of v0.44 of the kit, the frontend has changed considerably, with
a bit of luck it will be more stable than ever and is certainly more
flexible, so read on and find out how it has changed!</P>

<P>I've supplied a pre-processor (based on the Decus one ), however it's
not particularly capable, so I would recommend that you get hold of the GNU
one since it doesn't baulk at non-standard # directives.</P>

<P>The frontend now behaves much like a normal frontend to a compiler e.g.
much as gcc,cc,dcc, even (help me please!) bcc etc etc, the concept of
project files has be thrown out of the window, they were an early kludge
which served their role for a while.</P>

<P>In order for the source code to be as machine independent as possible,
zcc reads the location and names of executables from a config file. The
location of the config file is given by the
environmental variable ZCCFILE.</P>

<P>To invoke the frontend use the command:</P>

<PRE>
        zcc [flags]  [files to be compiled/linked]</PRE>

<P>The files can be either C files (.c) , preprocessed C files(.i),
compiled C files (.asm), optimised compiled file (.opt) or assembled files
(.obj), any combination of them can be mixed together and the relevant
processed done on them.</P>

<P>Processing of a file list is done on each file in turn (i.e. preprocess,
compile, optimise, assemble) at the end all files may be linked into a
single executable if desired.</P>

The various flags are:</P>

<PRE>
        +[file]    Name of config file (including full path and                    suffix). This option overrides the file give by ZCCFILE.
                   You shouldn't need this option unless you are compiling
                   for other Z80 machines.
        -a         Produce .asm file only
        -c         Do not link object files
        -E         Preprocess files only, leave output in .i file
        -o[file]   Specify output file for binary (default is a.out)
                   NB There's not a space between -o and the filename.
        -On        <A HREF="#copt">Optimize</A> compiler output (to .opt file)
        -v         Verbose - echo commands as they are executed
        -vn        Don't be verbose
        -l[name]   Link in a library - supply the full path, if you want
                   to link in Gunther's standard.lib (which is needed for
                   graphics, use -ls
        -lm        Link in the generic Z80 maths library
        -lmz       Link in and generate code for OZ's maths routines
        -s         Generate .sym files when assembling/linking
        -m         Generate .map files when assembling/linking
        -make-lib  Shortcut to generate .obj files from library .c files
        -z80-verb  Allow z80asm to be verbose, this tends to generate a lot
                   of output to the screen so may not be desired.
        -cleanup   Remove all the files that the compiler has produced (
                   except for the output one) -no-cleanup stops cleanup
        -show-errs Show any linking errors at the end.
</PRE>

<P>The flags, -D, -I, -U are passed through to the preprocessor 
(see the manual page for your choice of precompiler for the significence
of these.</P>

<P>I have added a couple of shortcuts to the library linking, if the
-math-z88 flag is specified then the z88 maths library is automatically
linked in. Similarly vice-versa, if you specify the flag -lmz, then the -math-z88 flag is supplied to the compiler. Should you wish to use the 
generic math library simply supply the flag -lm<P>


<P>Naturally, zcc allows the <A HREF="#compiler">compiler</A> options to
be passed through.</P>

<HR>


<H2><A NAME="compiler"></A>The Compiler</A></H2>

<UL>
        <LI><A HREF="#compintro">Introduction to the Compiler</A>
        <LI><A HREF="#compdatat">Datatypes supported</A>+
        <LI><A HREF="#comprun">Running the compiler</A>
        <LI><A HREF="#compcode">Some notes on the compiler</A>
</UL>


<H3><A NAME="compintro"></A>Introduction to the Compiler</H2>


<P>
The Compiler is based upon the Small C/Plus compiler which has long history
but can be basically be attributed to in chronological order: Cain, Van
Zandt, Hendrix and Ronald Yorston. This last person in particular developed
the compiler very considerably beyond the original specification for Small
C set down by Ron Cain. James R. Van Zandt modified it to include floating
point using floating routines originally written by Neil Colvin.</P>

<P>I too have further extended the compiler and hopefully made it into a
true cross compiler which can produce z80 code from any machine.</P>

<P>The compiler accepts a subset of Standard C, for more details about C
see the ubiquitous K&R - "The C Programming Language", if you want details
about the compiler try and find the now out of print "The Small-C Handbook"
by James E Hendrix. Information on the original incarnation of the
compiler is available on a <A HREF="http://www.ddj.com">Dr Dobbs</A> CDROM, though at $50 it could be considered overpriced.</P>

<H3><A NAME="compdatat"></A>Datatypes Supported by the Compiler</H3>

<P>Small C+ supports a wide variety of datatypes which are similar to those
in ANSI C, however it should be noted that the <I>float</I> type does not 
exist, it is represented instead by <I>double</I>.</P>

<P>Characters, ints and longs may be either signed or unsigned. Their
maximum and minimum values are detailed in the table below.  Pointers
contain the addresses of data elements and are treated as unsigned ints
when compared. NB. The size of pointers is likely to be userdefinable in
the future:</P>

<CENTER>
<TABLE BORDER=2>
<TR><TD><B>Type</B></TD>
<TD><B>Size</B></TD>
<TD><B>Min</B></TD>
<TD><B>Max</B></TD></TR>
 
 
<TR><TD>char</TD><TD>1 byte</TD><TD>-128</TD><TD>127</TD></TR>
<TR><TD>unsigned char</TD><TD>1 byte</TD><TD>0</TD><TD>255</TD></TR>
 
<TR><TD>int</TD><TD>2 bytes</TD><TD>-32768</TD><TD>32767</TD></TR>
<TR><TD>unsigned int</TD><TD>1 bytes</TD><TD>0</TD><TD>65535</TD></TR>
 
<TR><TD>long</TD><TD>4 bytes</TD><TD>-2147483648</TD><TD>2147483647</TD></TR>
<TR><TD>unsigned long</TD><TD>4 bytes</TD><TD>0</TD><TD>4294967296</TD></TR>
 
</TABLE></CENTER>
 
 
<P>The supported datatypes are detailed below:</P>

<PRE>
char c;           character 
char *c;          pointer to character
char **c;         pointer to pointer to character
char c();         function returning character
char *c();        function returning pointer to character
char c[3];        character array 
char *c[3];       array of pointers to character

int i;            16 bit integer 
int *i;           pointer to integer 
int **i;          pointer to pointer to integer
int i();          function returning integer 
int *i();         function returning pointer to integer
int i[4];         integer array 
int *i[4];        array of pointers to integer
int (*i)();       pointer to function returning integer

long i;           32 bit integer 
long *i;          pointer to long
long **i;         pointer to pointer to long
long i();         function returning long
long *i();        function returning pointer to long
long i[4];        long array 
long *i[4];       array of pointers to long

double d;         48 bit floating point
double *d;        pointer to double
double **d;       pointer to pointer to double
double d();       function returning double
double *d();      function returning pointer to double
double d[5];      array of doubles
double *d[5];     array of pointers to double

struct st s;      structure with tag st
struct st *s;     pointer to structure with tag st
struct st **s;    pointer to pointer to structure
struct st *s();   function returning pointer to structure
struct st s[5];   array of structures with tag st
struct st *s[5];  array of pointers to structure

union un u;       union with tag un
union un *u;      pointer to union with tag un
union un **u;     pointer to pointer to union with tag un
union un *u();    function returning pointer to union
union un u[5];    array of union with tag un
union un *u[5];   array of pointers to union with tag un
</PRE>


<P>Hopefully longs will now be correctly handled - including all arithmetic
routines. One area which I haven't addressed is the conversion to and
from doubles - they might work if they are smaller than 32767/65535 (signed/unsigned), however they will work if the -math-z88 flag is
supplied.</P>
 
<P>Extern and global static (as well as auto of course!) storage classes
are supported.
Also unsupported are multidimensional arrays and more complex types - if
you can name one and provide a good portable example that cannot be
represented using other (supported) types I'll think about giving you
prize!</P>

<P>Structures are declared in the usual way but may not contain instances
of themselves, but may contain pointers to instances of themselves. Passing
structures to a function is not permitted i.e. the only legal way a
structure can occur in a function argument is as a pointer.</P>

<P><A HREF="far.html">Far</A> pointers are now supported, although there is
no library code which will support them, so any attempted compilation will
fail.</P>


<H2><A NAME="comprun"></A>Running the Compiler</H2>

<P>You <B>should</B> run the compiler via the <A HREF="#frontend">frontend
</A> however, even so, it's essential to know which flags zcc passed through to the compiler:</P> 

<PRE>
        -unsigned       Implicitly define all ints/longs/chars as unsigned
        -stop-error     Pause on an error
        -//             Accept C++ style // (Though these are usually
                        taken out by the preprocessor)
        -math-z88       Use Z88 Maths routines</PRE>

<P>The following flags are accepted though they are effectively ignored
at the moment.</P>

<PRE>
        -make-app       Make Z88 Application
        -far-pointers   Enable far pointers passing in functions</PRE>

<P>This last option does in actual fact work and generate working code,
however if specified at the moment the program will break due to the
libraries being unaware of far pointers!</P>


<H2><A NAME="compcode"></A>Writing Code</H2>

<P>In this section I'll just raise a few of the more obscure aspects of the
compiler</P>

<P>Rather pardoxically if the code hasn't been run through the 
<A HREF="#copt">optimizer</A> the following code snippet:</P>

<PRE>
        function()
        {
                int     j;
                j++;
        }

</PRE>
Generates more code than:</P>
<PRE>
        function()
        {
                int     j;
                j=j+1;
        }

</PRE>
However when run through the optimizer both pieces of C result in the same 
machine code being produced. One thing to note is that in no circumstances
use:</P>
<PRE>
        function()
        {
               int     j;
                j=j++;
        }

</PRE>
Not that you would anyway, because that generates an awful lot more assembler 
code.</P>

<P>Other tips include define arrays and chars first of all in a function and 
ints later. Loop counting ints which are defined last of all will (when the code is optimized) generate much faster and smaller code.</P>

<P>If you do define a global (static) variable (as opposed to just declaring 
its presence) please note that the variable is embedded within the code and 
could not be changed if the program were to be blown onto an EPROM. Also 
important to note is that global doubles can not be initialised.</P>

<P>It is possible to mix C and assembly in a single source file, simple 
enclose the assembler language with #asm/#endasm, from v0.40 the use of
#pragma asm and #pragma endasm is also supported. However it isn't advised
that you mix assembler and C
unless you know very well what you are doing.</P>

<P>Possibly the most useful use of the #asm/#endasm would be to initialize 
global variables (though this can be done automatically), this could be used 
to easily define udg graphics for example:</P>



<PRE>
extern char udg[8];

main()
{
/* Put some code here! */
}

#asm
; A very boring graphic! 
.smc_udg    defb 185,170,185,170,185,170,185,170
#endasm</PRE>

<P>Note the use of the smc_ prefix - this has been added to avoid label
clashes with the library.</P>

<H3><A NAME="macros">Macros</H3>

<P>There is another method to call machine code from within C - the
"asm function" this is an incredibly useful way of getting macros into
z80asm, an example of how to do it is in the example/ directory, it's
easier to read the example than to read me try to describe it(!)</P>

<P>As well as providing macros, asm() can be used to call machine code
routines embedded with C expressions (caution!!). An example of using it
this way follows:</P>

<PRE>
main()
{
        int j;
        j=asm("call\tfish");
}

#asm
.fish
        ld      hl,1
        ret
#endasm</PRE>

<P>Not perhaps the best example ever, but it illustrates its use - you can
also return longs (kept in dehl) and chars (same as for ints)</P>



<P>There is another feature of this version of Small C which could potentially 
be of much use if you were combining an existing assembler and a C program. 
This is the so called external pointer data type, and I shall illustrate it's 
use with a few C examples and the hypothetical assembler code produced, let 
us assume that hl is the integer j.</P>

<PRE>
extern int data(address);       address=16 bit Z80 address

function()
{
        int j;
        j=data          ld  hl,(address)
        j=&data         ld  hl,address
}</PRE>

<P>You can similarly do the same trick with chars and doubles. I believe 
this to be slightly "non-standard" but could prove invaluable for finding out system variables etc.</P>

<HR>
<H2><A NAME="copt"></A>z80 Code Optimizer</A></H2>

<P>The optimizer supplied with the package is of the peephole variety -
i.e. if it spots a a group of lines which it knows can be better
represented in another way it will - it isn't (and never will) be a
true optimizer and keep track of register usage and avoid repeated loading
of a register with the same value.</P>

<P>From v0.46 of the compiler there are now two levels of optimization,
for the best (smallest and fastest) code it is recommended that you
compile with the -O2 option from zcc. On large source files it will take
its time, but it is worth it - savings of over 10% in program size are
common place, and execution time can decrease quite considerable. One
program that I'm working on at the moment was 11984 bytes before
optimization and 10131 bytes afterwards which is just a smidgen over
15%. The execution time decreased dramatically as a result.</P>

<P>Hopefully the rules supplied will not cause any software to fail (I
haven't come across anything yet - and I have used them a lot), however
if they do, then just <A HREF="mailto:djm@jb.man.ac.uk">mail</A> me with
the C source and the assembler output (raw and optimized) and I'll see
what I can do to remedy the situation.</P>

<HR>
<H2><A NAME="diss"></A>The Disassemblers</A></H2>

<P>Included with in the package are two Z80 disassemblers, both have their 
uses at various times, though at the moment only one comes with documentation!

<P><H4><B>DZasm</B></H4></P>

<P>This is dzasm disassembler from Interlogic which is perfect for 
disassembling Z88 ROM images due to its full support of the Z80 module 
assembler in producing disassembly files with CALL_OZ pseudo opcodes. 
It's not so much a command line disassembly as a sort of disassembler 
environment. It's very powerful, but sadly at the moment comes without 
instructions or documentation. I only include in the Amiga binary, for
other platforms grab the source code from 
<A HREF="http://www.menaxus.demon.co.uk/z88/z88home.htm">Z88 Forever</A> and compile it.</P>

<P><H4><B>DZ80</B></H4></P>

<P>DZ80 is a very good disassembler originally written for M$DOG, but I 
successfully ported it over to the Amiga last August. I've modified it 
slightly to produce disassembly files which can be recompiled using z80asm (with the small addition of a MODULE xxx line). Details of the changes can
be found in the <A HREF="dz80.readme">dz80.readme</A> file in the doc/ 
directory</P>

<P>Should you require the generic sources for dz80 then go to the 
<A HREF="http://www.inkland.demon.co.uk">Inkland</A> website.</P>

<HR>
<H2><A NAME="linker"></A>Assembler and Linker</A></H2>

<P>As previously noted the assembler and linker are combined in the z80asm Module Assembler from Interlogic. Using this program has numerous
advantages over the traditional method of using a separate linker and
assembler, briefly these are:
</P>

<UL>
        <LI>Compact object file format (no more bulky Intel Hex object files)
        <LI>Fast, small and cross-compilable
        <LI>Extensive built in support for the Z88..
        <LI>..whilst not sacrificing generic z80 compatibility
        <LI>A good general purpose assembler for assembly projects
        <LI>Most of the Z88 community is familar with the syntax
        <LI>Still being actively developed...
        <LI>...but not by me(!)

</UL>

<P>I could go on, but I won't - even I, a happy user of a generic,
blindingly fast cross-assembler for the Amiga (za80) was converted once I
saw what it could do. In my mind, it should become <B>the</B> standard
cross-assembler for z80 developers.</P>

<HR>
<H2><A NAME="libraries"></A>Libraries and Includes</H2>

<P>I have endeavoured to put together a fairly comprehensive library of 
functions which cover most of the things that smallish C programs would want to do. There are of course many omissions and undoubtedly many
mistakes, so if you find one, could you either endeavour to fix it and send
me the corrected version or alternatively let me know and I'll find the
time to repair it.</P>

<P>The listing of all of the functions in the header files is getting quite
long so I shall only list the interesting ones. Those functions without a
type return an int.</P>


<P><B>graphics.h</B></P>

<PRE>
extern window(struct *window);
extern plot(struct *pixels);
extern unplot(struct *pixels);
extern draw(struct *pixels);
extern undraw(struct *pixels);
extern drawr(struct *draw);
extern undrawr(struct *draw);
extern drawb(struct *pixels);
extern undrawb(struct *pixels);
extern lscroll(struct *pixels);
extern rscroll(struct *pixels);
extern clg(void);
extern clga(struct *pixels);
extern closegfx(struct *window)
extern circle(struct pixels);
extern uncircle(struct pixels);

</PRE>
These function provide "stubs" for Gunther's standard.lib, for the meanings
of the structures look at the actual header file.</P>

<B>stdlib.h</B></P>

<PRE>

extern csleep(int time
extern char *getcwd(char *buffer, int len))</PRE>

<P>csleep will pause time centiseconds, this uses the Z88 OZ function os_dly.</P>

<P>getcwd will load the current directory into buffer up to a maximum
len bytes.</P>

<B>malloc.h</B></P>

<PRE>
extern void *calloc(int number, int size_of_datatype);
extern void *malloc(int bytes);
extern free(char *);
extern getfree(void);
extern getlarge(void);
extern initmem(int size);

</PRE>
I've kludged around and come up with an extremely rudimentary malloc/free
scheme for Small C. All memory is allocated out of character array! The
routines actually come from a file I spotted on an MSX website a year or
so ago, here's an example of how to use these routines.</P>

<PRE>

#include <malloc.h>

/*
 * Define the size of the pool, HEAPSIZE is a macro for unsigned char [ ]
 */
#define HPSIZE 8192
HEAPSIZE(HPSIZE)


main()
{
        char *s;
        int size;
        initmem(HPSIZE);        /* Initialise the heap - has to be done! */
        s=malloc(100);
        if (s == 0 ) exit(0);
        free(s);
        size=getfree();         /* Get total free memory */
        size=getlarge();        /* Get size of largest block */
}
</PRE>

<P>Don't forget to link with -l{zcc/lib}/malloc</P>

<P><B>strings.h, ctype.h</B></P>

<P>From v0.46 I've added an enormous amount of new routines to these
header files, best solution is if you just have a peep at them! Most of
the new string.h functions are in C so they can be easily recompiled for
long pointers.</P>

<P><B>WARNING!</B> I've only tested a few of these functions (and corrected
a few bugs!) so I can't guarantee their correct function, you may well have
to delve into the libsrc/ directory to see whats up. Please let me know
which ones you've used and whether they work or not!</P>

<HR>
<H2><A NAME="examples"></A>Example Programs</H2>

<P>Included within the package are a few C example programs, they're quite 
simple, but prove that the package does actually work!</P>

<P><B><H4>world.c</H4></B></P>

<P>Go on, take a guess, yup, the Z88DK version of the infamous Hello World 
program!</P>

<P><B><H4>filetest.c</H4></B></P>

<P>Pretty much as it suggest really, it just test a few of the library 
functions and displays the first 5 lines of a file on screen - make sure you 
change the filename to one on your Z88 though! If you don't you can test out 
the error checking!</P>

<P><B><H4>gfx.c</H4></B></P>

<P>A little test of the new graphics library - compile using <A
HREF="#frontend">zcc</A> with the -ls option.</P>

<P>It's quite boring, but demonstrates the speed of the circle routine
very well in addition to being a demonstration as to how to use some of
the other graphics functions.</P>

<P><B><H4>opt_test.c</H4></B></P>

<P>Hmmm, this doesn't actually do anything useful! I wrote it to test out the 
code optimizer, as you can see it does a pretty good job, though obviously it 
doesn't say "This code is complete nonsense why are you bothering with it"!

<P><B><H4>gfx.c</H4></B></P>

<P>A short example of using the map area from Small C+ - now..who's going
to do a 3D wireframe game!</P>

<P><B><H4>enigma.c</H4></B></P>

<P>The original "big" program! This is a simple emulation of the German Enigma Machine 
used during WWII, the BASIC equivalent (enigma.bas) was the first program I 
wrote for the Z88 back in April!</P>

<P>This version is not quite as polished, but it works a lot quicker! What 
you type is translated into Enigma Code (yes it does work, it's not 
faking it!) instead of being echoed in English/German/Danish/Swedish/French 
etc. It only takes the standard 26 letters of the Roman Alphabet and 
automatically converts them to capitals. To stop it simply enter a full stop 
i.e. a "."</P>

<P>I have to admit I was quite astonished when this worked the first time
after being compiled - it calls on quite a few library functions which hadn't 
been tested previously, but it does, so enjoy!</P>

<P><B><H4>cube.c</H4></B></P>

<P>Thanks to Dennis for forwarding this one to me - after a few tweaks
for speed and accurate compilation we have the first vector graphic on
the Z88! There appear to be a few problems when compiling this on a PC -
 I can't quite track them down, so a precompiled binary is supplied.</P>

<P>Unfortunately(!) if you compile this example for the Z88 math routines
it appears to produce strange results, if anyone can track down this
problem I'd be immensely grateful - I think I'm generating fp constants
correctly, however I could be wrong!</P>

<P><B><H4>dstar.c</H4></B></P>

<P>A new demonstration program from v0.43 onwards. DStar is a conversion of
a small TI86 game I found with assembler source, I converted it over to
C and we have a new demo program, it's a very nice game and good fun to
play as well - for instructions look at the source - there's a couple
of pages of comments in there about it!</P>

<P><B><H4>define.c</H4></B></P>

<P>Not so much a demonstration, but an example of how to declare static
strings for the best possible performance - I used this to debug the
initialisation routines.</P>

<P><B><H4>sorter.c</H4></B></P>

<P>A short insertion sort routine from Joe Mackay - he took some code
home from his course made a couple of minor adjustments and came up with
this! - Thanks Joe!</P>

<P><B><H4>rpn.c</H4></B></P>

<P>This one's for you Garry! A reverse polish notation calculator. This
was originally written for the GBDK, but a couple of minor changes
later (documented) and it works on the Z88.</P>


<P><B><H4>???/*.c</H4></B></P>

<P>It's going to come soon, and it <I>will</I> blow your socks off - you've
been warned! - This has been delayed due to work on the compiler!</P>

<HR>

<H2><A NAME="problems"></A>Known Feechures aka bugs!</H2>


<P>Hopefully this list will first grow(!) and then shrink as I sort them 
out.</P>

<P><B>22.3.99</B></P>

<P><B>---></B>And still it bugs me, the floating point constants, I've now
had it working on 4 operating systems on 4 different processors with 3
different compilers: AmigaOS (m68k; DICE,gcc,vbcc) , WarpOS (PPC; vbcc),
Solaris 2.5 ([Whatever Sparc chip is in an Ultra]; gcc), Linux (i486; gcc) and I will be damned if I can get it barf and spit rubbish out at me on any
of them, well certainly not of the kind of rubbish that some people are
getting out, I am completely flumoxxed to say the least...</P>

<P><B>8.3.99</B></P>

<P><B>---></B>The supplied preprocessor is ANSI C and doesn't strip //
style comments - solution don't use them or use the -// flag.</P>

<P>So, I guess you're here cos your code doesn't work? Have you checked it
- I mean have you really checked it? Does it make sense, there are no
wild pointers are there? Ah, where does it go wrong then? In a library
function? Good, delve into the libsrc directory pull out the relevant
file and look at it. Spotted a bug? Tell me about it and I'll put it right.</P>

<P>Oh, not there then, hmmm, if all else fails it sounds like a compiler
shortfall then. First step is to look back at the C code, have you got any
lines looking like: <PRE>[long]=[int]+[constant]L</PRE> - the L on the end
is important - remove the L it should work - the integer expression is
automagically converted to a long type.</P>

<P>Whats's this Compiler Error Bug thing? <B>-></B> well, it's a nice
way of stopping a SEGV for a start! I'm afraid it's a bit of shortcoming
in the compiler itself, you've tried to be clever and produce a bit of
code along the lines of:</P>

<PRE>
struct mystruct {
   [type] data[n];
};

void myfunc(struct mystruct *ptr);
{
        [type] *ptr2;

        ptr2=&ptr->data[m];
}
</PRE>

<P>Which causes the compiler to report back with a null pointer - not
good, so I trap it, put the warning up and you can get on with life, I'll
fix it when I sort far code out. I haven't come across a case where the
code generated is bad, it's just there to warn you. You can get round it by using <PRE>ptr2=(&ptr->data)+m</PRE>>/P>
        

<HR>

<H2><A NAME="history"></A>Some Past History</A></H2>

<P>The development history of the Z88DK is now found in the separate file <A HREF="history.html">history.html</A>.</P>

<HR>


<H2><A NAME="future"></A>The Future</A></H2>

<P>v0.49 saw a large number of goals diminish - prototyping brought
about ANSI function definitions and hence rigorous type checking. This then
brought about the setting up of stdin/out/err in the startup code due to
pointer mismatching(!)

<UL>
        <LI> Support the creation of proper Z88 applications - I've been thinking about this, and I think I will go as far as creating code which
is ROMable. The DORs etc can be constructed using Garry Lancasters'
semi-infamous CamelForth application.
        <LI> Casting and enums

</UL>

<P>Future developments can of course be found of the private Small C+ 
<A HREF="http://www.jb.man.ac.uk/~djm/smallc/">website</A> where I will 
upload the latest distributions on a fairly regular basis.</P>

<HR>

<H2><A NAME="#machine"></A>The Machine and Development Process</A></H2>

<I>aka a little bit of spouting off</I>

<P>Development of the compiler was started on an Amiga A1200 with
a 28MHz '020 processor and 6 meg of RAM (not exactly a speed machine). The
beast has now been upgraded to a dual processor (PPC603e 160MHz and '040/25MHz) box with 34meg. If there's any demand for it then I can
produce executables which will run on the PPC under either PowerUP or
WarpOS (depending on which compiler I find). All development was done
using DICE (v3.15/v3.16). Obscure SEGV bugs were tracked
down using gdb on a Linux box (sadly not Amiga) - someone please send
me a CD containing APUS!</P>

<HR>
<A HREF="mailto:djm@jb.man.ac.uk">Dominic Morris</A> (djm@jb.man.ac.uk)
22/3/99<P>Back to <A HREF="#top">top</A></P>

</BODY>
</HTML>
