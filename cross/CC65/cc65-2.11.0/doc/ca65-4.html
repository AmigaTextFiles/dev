<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.20">
 <TITLE>ca65 Users Guide: Expressions</TITLE>
 <LINK HREF="ca65-5.html" REL=next>
 <LINK HREF="ca65-3.html" REL=previous>
 <LINK HREF="ca65.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="ca65-5.html">Next</A>
<A HREF="ca65-3.html">Previous</A>
<A HREF="ca65.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4.</A> <A HREF="ca65.html#toc4">Expressions</A></H2>




<H2><A NAME="ss4.1">4.1</A> <A HREF="ca65.html#toc4.1">Expression evaluation</A>
</H2>


<P>All expressions are evaluated with (at least) 32 bit precision. An
expression may contain constant values and any combination of internal and
external symbols. Expressions that cannot be evaluated at assembly time
are stored inside the object file for evaluation by the linker.
Expressions referencing imported symbols must always be evaluated by the
linker.</P>


<H2><A NAME="ss4.2">4.2</A> <A HREF="ca65.html#toc4.2">Size of an expression result</A>
</H2>


<P>Sometimes, the assembler must know about the size of the value that is the
result of an expression. This is usually the case, if a decision has to be
made, to generate a zero page or an absolute memory references. In this
case, the assembler has to make some assumptions about the result of an
expression:</P>
<P>
<UL>
<LI>    If the result of an expression is constant, the actual value is
checked to see if it's a byte sized expression or not.</LI>
<LI>    If the expression is explicitly casted to a byte sized expression by
one of the '&gt;', '&lt;' or '^' operators, it is a byte expression.</LI>
<LI>    If this is not the case, and the expression contains a symbol,
explicitly declared as zero page symbol (by one of the .importzp or
.exportzp instructions), then the whole expression is assumed to be
byte sized.</LI>
<LI>    If the expression contains symbols that are not defined, and these
symbols are local symbols, the enclosing scopes are searched for a
symbol with the same name. If one exists and this symbol is defined,
it's attributes are used to determine the result size.</LI>
<LI>    In all other cases the expression is assumed to be word sized.</LI>
</UL>
</P>
<P>Note: If the assembler is not able to evaluate the expression at assembly
time, the linker will evaluate it and check for range errors as soon as
the result is known.</P>


<H2><A NAME="ss4.3">4.3</A> <A HREF="ca65.html#toc4.3">Boolean expressions</A>
</H2>


<P>In the context of a boolean expression, any non zero value is evaluated as
true, any other value to false. The result of a boolean expression is 1 if
it's true, and zero if it's false. There are boolean operators with extreme
low precedence with version 2.x (where x &gt; 0). The <CODE>.AND</CODE> and <CODE>.OR</CODE>
operators are shortcut operators. That is, if the result of the expression is
already known, after evaluating the left hand side, the right hand side is
not evaluated.</P>


<H2><A NAME="ss4.4">4.4</A> <A HREF="ca65.html#toc4.4">Constant expressions</A>
</H2>


<P>Sometimes an expression must evaluate to a constant without looking at any
further input. One such example is the <CODE>
<A HREF="ca65-10.html#.IF">.IF</A></CODE> command
that decides if parts of the code are assembled or not. An expression used in
the <CODE>.IF</CODE> command cannot reference a symbol defined later, because the
decision about the <CODE>.IF</CODE> must be made at the point when it is read. If the
expression used in such a context contains only constant numerical values,
there is no problem. When unresolvable symbols are involved it may get harder
for the assembler to determine if the expression is actually constant, and it
is even possible to create expressions that aren't recognized as constant.
Simplifying the expressions will often help.</P>
<P>In cases where the result of the expression is not needed immediately, the
assembler will delay evaluation until all input is read, at which point all
symbols are known. So using arbitrary complex constant expressions is no
problem in most cases.</P>



<H2><A NAME="operators"></A> <A NAME="ss4.5">4.5</A> <A HREF="ca65.html#toc4.5">Available operators</A>
</H2>


<P>Available operators sorted by precedence:</P>
<P>
<BR><CENTER>
<TABLE BORDER><TR><TD>
Op</TD><TD>Description</TD><TD>Precedence</TD></TR><TR><TD>
&nbsp;</TD><TD>Builtin string functions</TD><TD>0</TD></TR><TR><TD>
&nbsp;</TD><TD>Builtin pseudo variables</TD><TD>1</TD></TR><TR><TD>
&nbsp;</TD><TD>Builtin pseudo functions</TD><TD>1</TD></TR><TR><TD>
+</TD><TD>Unary plus</TD><TD>1</TD></TR><TR><TD>
-</TD><TD>Unary minus</TD><TD>1</TD></TR><TR><TD>
~</TD><TD>Unary bitwise not</TD><TD>1</TD></TR><TR><TD>
.BITNOT</TD><TD>Unary bitwise not</TD><TD>1</TD></TR><TR><TD>
&lt;</TD><TD>Low byte operator</TD><TD>1</TD></TR><TR><TD>
&gt;</TD><TD>High byte operator</TD><TD>1</TD></TR><TR><TD>
^</TD><TD>Bank byte operator</TD><TD>1</TD></TR><TR><TD>
*</TD><TD>Multiplication</TD><TD>2</TD></TR><TR><TD>
/</TD><TD>Division</TD><TD>2</TD></TR><TR><TD>
.MOD</TD><TD>Modulo operation</TD><TD>2</TD></TR><TR><TD>
&amp;</TD><TD>Bitwise and</TD><TD>2</TD></TR><TR><TD>
.BITAND</TD><TD>Bitwise and</TD><TD>2</TD></TR><TR><TD>
^</TD><TD>Bitwise xor</TD><TD>2</TD></TR><TR><TD>
.BITXOR</TD><TD>Bitwise xor</TD><TD>2</TD></TR><TR><TD>
&lt;&lt;</TD><TD>Shift left operator</TD><TD>2</TD></TR><TR><TD>
.SHL</TD><TD>Shift left operator</TD><TD>2</TD></TR><TR><TD>
&gt;&gt;</TD><TD>Shift right operato</TD><TD>r</TD></TR><TR><TD>
.SHR</TD><TD>Shift right operator</TD><TD>2</TD></TR><TR><TD>
+</TD><TD>Binary plus</TD><TD>3</TD></TR><TR><TD>
-</TD><TD>Binary minus</TD><TD>3</TD></TR><TR><TD>
|</TD><TD>Binary or</TD><TD>3</TD></TR><TR><TD>
.BITOR</TD><TD>Binary or</TD><TD>3</TD></TR><TR><TD>
=</TD><TD>Compare operation (equal)</TD><TD>4</TD></TR><TR><TD>
&lt;&gt;</TD><TD>Compare operation (not equal)</TD><TD>4</TD></TR><TR><TD>
&lt;</TD><TD>Compare operation (less)</TD><TD>4</TD></TR><TR><TD>
&gt;</TD><TD>Compare operation (greater)</TD><TD>4</TD></TR><TR><TD>
&lt;=</TD><TD>Compare operation (less or equal)</TD><TD>4</TD></TR><TR><TD>
&gt;=</TD><TD>Compare operation (greater or equal)</TD><TD>4</TD></TR><TR><TD>
&amp;&amp;</TD><TD>Boolean and</TD><TD>5</TD></TR><TR><TD>
.AND</TD><TD>Boolean and</TD><TD>5</TD></TR><TR><TD>
.XOR</TD><TD>Boolean xor</TD><TD>5</TD></TR><TR><TD>
||</TD><TD>Boolean or</TD><TD>6</TD></TR><TR><TD>
.OR</TD><TD>Boolean or</TD><TD>6</TD></TR><TR><TD>
!</TD><TD>Boolean not</TD><TD>7</TD></TR><TR><TD>
.NOT</TD><TD>Boolean not</TD><TD>7</TD></TR><TR><TD>
</TD></TR></TABLE>
<CAPTION>Available operators sorted by precedence</CAPTION>
</CENTER><BR>
</P>
<P>To force a specific order of evaluation, braces may be used as usual.</P>




<HR>
<A HREF="ca65-5.html">Next</A>
<A HREF="ca65-3.html">Previous</A>
<A HREF="ca65.html#toc4">Contents</A>
</BODY>
</HTML>
