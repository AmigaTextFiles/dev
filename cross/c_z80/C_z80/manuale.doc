1. USO COMPILATORE :

Per usare il compilatore occorre generare un file ASCII contenente le 
istruzioni dello Z80 (scritte in maiuscolo), e/o le pseudoistruzioni 
(sempre in maiuscolo) accettate da questo compilatore.

Una volta realizzato il file sorgente usare il comando :

  > C_Z80 nomefile [-d,-l,-c,-t nnnn,-v nnnn,-e nnnn,-p nnnn,-r nnnn]

LEGENDA :
nomefile: indica nome del file sorgente ,se il programma non trova un 
	  file con tale nome ne cerca uno con estensione .ASM .
   -d   : attiva la generazione di messaggi di debug (Default=off).
   -l   : disattiva la generazione delle linee listate (Default=on).
   -c   : inibisce l'inserimento dei codici per CONDENSED FINE sul file 
	  nomefile.lst (Default=inserimento abilitato).
   -t   : definisce di nnnn bytes la lunghezza dell'area temporanea. 
	  (Default=il doppio del file sorgente, esclusi eventuali 
	   include file).
   -v   : definisce di nnnn bytes la lunghezza dell'area label. 
	  (Default=3000 bytes).
   -e   : definisce di nnnn bytes la lunghezza dell'area label esterne. 
	  (Default=2000 bytes).
   -p   : definisce di nnnn bytes la lunghezza dell'area label pubbliche. 
	  (Default=1000 bytes).
   -r   : definisce di nnnn bytes la lunghezza dell'area label rilocabili 
	  (Non utilizzata).

Quel comando realizza la compilazione di nomefile.ASM e genera inoltre 
altri 2 files, uno con estensione .MOD (l'oggetto) e uno con estensione 
.LST (il listato).

Il file oggetto ottenuto dalla compilazione è di formato .OBJ esteso 
rispetto alle precedenti versioni , questo per poter permettere un suo 
successivo linkaggio con altri moduli i(.MOD) sviluppati separatamente 
con il medesimo compilatore.

Quindi per poter ottenere il file oggetto come prima, occore ora eseguire 
il linkaggio con l'apposito comando (vedi capitolo 5 :USO DEL LINKER ),
dei moduli (file .MOD) ottenuti.

Per implementare questa possibilità sono state aggiunte appositamente 
altre due pseudoistruzioni per la gestione delle label esterne al sorgente 
compilato .
In quest'ultima versione e' stata inpoltre aggiunta una direttiva che 
permette di definire delle label rilocabili all'interno dello stesso 
modulo(vedi capitolo 2).

IMPORTANTE: i due files di uscita vengono sempre realizzati entrambi 
nella stessa directory del sorgente, quindi per ottenere la massima 
efficenza e velocita' di compilazione è bene mettere tale file sulla 
RAM DISK: dato che i dischetti dell'AMIGA sono piuttosto lenti.

Altra nota importante, il compilatore quando viene lanciato riserva un
area di memoria pari al doppio delle dimensioni del file sorgente (a meno 
di non usare al lancio l'opzione -t che definisce tale dimensione a priori),
rilasciata poi al termine della compilazione. 

Attenzione, se nel file fossero presenti molti file include lunghi, può 
allora capitare che la memoria così riservata non sia sufficente, in tal 
caso conviene usare subito l'opzione di compilazione -t seguita dal 
numero di bytes che si vogliono riservare, così si evita l'errore di 
compilazione e il conseguente aborto della stessa.

E'sempre possibile interrompere l'esecuzione della compilazione in qualsiasi
momento con la sequenza di tasti CTRL+C senza per questo perdere nessuna 
area di memoria riservata dal programma stesso.

Durante la compilazione vengono generati dei messaggi diagnostici su 
standard output. Tali messaggi servono da indicazione su eventuali errori 
incontrati durante la compilazione, infatti restituiscono linea e codice   
dell'errore rilevato. Se la compilazione è andata bene e non si è scelta 
l'opzione -d allora si deve ottenere la seguente schermata in uscita:

CROSS COMPILATORE PER ASSEMBLER Z80 Version:2.01
Copyright (C) 1990,1991,1992,1995 by BIANCA SOFT

  FILE SORGENTE: nomefile. ASM

FIRST PASS
ASSEMBLE ERROR:0  nn:LINE ASSEMBLE
SECOND PASS
ASSEMBLE ERROR:0  nn:LINE ASSEMBLE ll:BYTES TOT.
ASSEMBLE OK

Dove 'nomefile' è il file compilato, 'nn' sono le linee compilate (deve 
essere il medesimo valore in entrambi i casi e conciderà col numero di 
linee del sorgente solo se non vi sono include file), 'll' indica il numero 
di bytes totali occupati dall'oggetto ottenuto.

IMPORTANTE! il sorgente non deve contenere alcun carattere non stampabile, 
eccetto il carattere LF ($0A) usato come terminatore delle linee e il 
carattere TAB ($09) tabulatore orizzontale.

----------------------------------------------------------------------------

2. FORMATO FILE SORGENTE :

Le linee del sorgente possono contenere al massimo una sola istruzione, 
devono essere suddivise nei seguenti campi :
<LABEL>,<ISTRUZIONE>,<OPERANDI>,<COMMENTO> 
non hanno limiti di lunghezza ma sono considerati solo i primi 300 
caratteri. 
I campi devono essere separati tra loro da spazi($20) o TAB($09), non è 
obbligatorio che siano tutti presenti contemporaneamente sulla stessa linea, 
ma devono essere sistemati in quell'ordine perché siano correttamente 
interpretati.
I suddetti campi saranno così organizzati:

LABEL: è un etichetta da usare poi come riferimento per quella posizione 
       nel resto del programma, rappresenta quell'indirizzo. Può essere 
       composta solo da caratteri alfanumerici e dal carattere '_'
       (sottolineato), il primo carattere deve essere sempre una lettera 
       e deve essere nella prima colonna della riga (ovvero non devono 
       esserci spazi o TAB prima, altrimenti verrà considerata 
       un'istruzione).
       Puo' anche cominciare col carattere "_" (punto) ma in questo caso 
       diventa rilocabile, ovvero se adesso all'interno dello stesso modulo 
       si fa un riferimento assoluto a questa label, successivamente il 
       linker sara in grado di riconoscerla come rilocabile e potra' 
       sistemare correttamente il codice. Questo si e' ottenuto ingannando 
       il linker che si ritrovera' ad avere una label che e' sia EXTERN 
       che PUBBLIC contemporaneamente,quindi attenzione a non usare gli 
       stessi nomi in altri moduli,cio' darebbe errore sul linker essendo 
       tale nome pubblico e definito piu' volte. 
       Non può essere uguale alle parole riservate, ovvero pseudoistruzioni, 
       istruzioni e registri (vedi APPENDICE A per elenco). 
       Infine questo campo può essere lungo quanto si vuole ma verrano 
       considerati solo i primi 10 caratteri. Può non esserci.

ISTRUZIONE: è il campo dove va inserita o un istruzione (del set legale Z80)
       o una pseudoistruzione, va digitato con caratteri maiuscoli. 
       Deve essere preceduto da almeno uno spazio o TAB, non ha limiti di 
       lunghezza ma verranno poi considerati solo i primi 10 caratteri, 
       con gli attuali set non è possibile superare tale limitazione. 
       Può non esserci.

OPERANDI: è il campo dove vanno inseriti gli argomenti relativi al campo 
       ISTRUZIONE che occorre sia presente per una corretta interpretazione 
       di questo. 
       Deve essere separato dal precedente da almeno uno spazio o TAB e 
       al suo interno i vari campi vanno separati tra loro da caratteri 
       ',' (virgola). 
       Non esistono limiti di lunghezza ma vengono considerati solo i 
       primi 50 caratteri per ogni argomento per un massimo di 10 
       argomenti totali. Può non esserci.

COMMENTO: è il campo dove possono essere inserite delle note dal 
       programmatore poi ignorate dal compilatore. 
       Deve essere l'ultimo campo della linea, deve essere presente il 
       campo ISTRUZIONE nella stessa riga. 
       Se è preceduto dal carattere ';' o dal carattere '*' può essere 
       inserito in un qualuncque punto della linea, anche all'inizio. 
       Non esistono limiti di lunghezza ma sono considerati solo i primi 
       80 caratteri.Può non esserci ma e' molto utile per una successiva 
       modifica o rilettura del modulo che questo campo sia presente 
       in modo molto copioso.

Una linea può anche essere vuota, cioè non contenere nessuno dei campi 
precedenti. In ogni caso lo spazio e il TAB vengono usati come separatori, 
quindi non possono essere inclusi all'interno di un campo, fanno eccezione 
il campo COMMENTO e le stringhe nel campo operandi, vedi capitolo su 
pseudoistruzioni.

Ecco alcune linee come esempio, con evidenziati i vari campi:

<LABEL><ISTRU.><OPERANDO>
TAsto   CALL    $1f54

<LABEL><ISTRU.><OPERANDO><COMMENTO>
_RILOC  JP      RILOC     USo label rilocabili da linker

<COMMENTO> 
;testo Di prova

<COMMENTO> 
*testo di PROVA

<ISTRU.><OPERANDI><COMMENTO>
   LD     A, C      prVA 2

<LABEL><ISTRU.><OPERANDO><COMMENTO> 
PIPPO   JR      PIPPO     LOOP senza FINE

<LABEL><ISTRU.><COMMENTO> 
FINE    RET     RITORNO DA SUBROUTIN

NOTA: Il file sorgente deve essere assolutamente composto solo da caratteri 
ASCII stampabili, ovvero dallo spazio al DEL (escluso), uniche eccezioni 
il carattere LF ($0A hex. 10 dec.) usato come terminatore della linea, 
il carattere TAB ($09 hex. 9 dec.) usato come separatore insieme allo spazio.

----------------------------------------------------------------------------

3. FORMATO FILES D'USCITA :

Files prodotti da c_z80 ,il compilatore .

A-Formato file oggetto '.MOD':

Nel file oggetto vengono messi i codici macchina ottenuti nella compilazione 
del sorgente aggiungendo una testata (header) e una coda per ogni blocco 
di codici. 
La testata è composta da 4 bytes, dove i primi 2 sono l'indirizzo di 
partenza del blocco, espresso come byte alto+byte basso, i secondi 2 
indicano la lunghezza del blocco stesso (da tale valore sono esclusi 
i 4 bytes della testata e i 2 della coda) espressa sempre come byte 
alto+byte basso. 
Quindi viene il blocco dei codici veri e propi, infine vengono aggiunti 
2 byte di coda, che sono il cecksum (calcolato su 2 bytes appunto, partendo 
dal valore 00) di tutti i bytes precedenti, ovvero dei 4 della testata + 
quelli del blocco.

Ovviamente in un file oggetto ci possono essere più di un blocco di dati, 
organizzati tutti come descritto, quindi per capire quando si è raggiunta 
la fine, occorre aggiungere un blocco con testata che abbia indirizzo=00, 
lunghezza=00, cecksum=00 (tale blocco sarà composto da soli 6 bytes tutti 
uguali a 00) posizionato dopo l'ultimo blocco, cosa fatta dal compilatore 
in modo completamente automatico.

Ci sono altri due blocchi di dati dopo i blocchi con i codici.  
Il primo contiene l'elenco delle locazioni pubbliche incontrate nel 
sorgente con il loro indirizzo. 
Il secondo contiene l'elenco di tutti i richiami a locazioni esterne 
incontrate nel sorgente, con elencati anche tutti gli indirizzi dove si 
fa tale richiamo. 
Entrambi i blocchi sono preceduti da due byte indicanti la lunghezza del 
blocco seguente (byte alto +byte basso), e sono uguali a 00 se tale blocco 
è assente, in tale valore i due bytes non sono inclusi. 
Il blocco delle variabili pubbliche è così composto: 
NOME_VAR 00 INDIRIZZO_VARIABILE_IN_2_BYTES...

Il blocco delle variabili esterne è invece così composto: 
NOME_VAR 00 NUMERO_RICHIAMI_IN_2_BYTES INDIRIZZO_PRIMO_RICHIAMO_IN_2_BYTES..

B-Formato file listato '.LST'

Il file listato riporta in chiaro, ovvero riga per riga il codice sorgente 
piu' i codici compilati e l'indirizzo di compilazione, alla fine del 
programma sono riportati in una tabella riassuntiva i valori delle label 
apparse nel programma, cinque alla volta e nello stesso ordine con cui 
sono apparse, il valore viene espresso sia notazione decimale (senza 
prefisso) che in notazione esadecimale (con prefisso '$'). 
Se è stata usata l'opzione di compilazione [-l] a meno ché non siano 
presenti delle pseudoistr. LIST 1 (vedi prossimo capitolo), si otterra'
nel file .LST il solo elenco delle variabili.

Ogni riga è così composta : Numero di linea (4 caratteri) in notazione 
decimale (corrisponde al n# di linea sul sorgente), indirizzo del primo 
byte dei codici relativi alla linea (4 caratteri) in notazione esadecimale, 
codici risultanti dalla compilazione della linea, rappresentati da coppie 
di caratteri in notazione esadecimale separati da uno spazio, possono 
essere al massimo 4 (se più lungo il cod. risultante allora verranno 
distribuiti su più linee con però lo stesso numero di linea). 
Infine sono riportati pari pari i campi della linea del file sorgente, 
ma formattate in modo sempre uguale , in modo da avere i campi delle 
varie linee sempre incolonnati tra loro cosi' si puo' anche verificare
che non si sia scritto male qualche riga visto che la riga sara' ricomposta
nell'ordine 'label','istruzione','operando/i','commento'.

Attenzione, così facendo le linee sono spesso più lunghe di 80 colonne, 
quindi se si dispone di una stampante con solo 80 colonne per linea, 
conviene settare prima il modo CONDENSED FINE se si vuole evitare di 
spezzare le righe. Questa operazione è peraltro fatta automaticamente dal 
compilatore (a meno che non si compili con l'opzione -c che disabilita 
tale inserimento) il quale mette in testa al file i codici di escape 
necessari per resettare la stampante e settarla in condensed fine(i codici 
inseriti seguono però lo standard ANSI X3.64, quindi attenzione!!).


File prodotto da l_z80, il linker .

A-Formato file '.OBJ' 
E' il file con i codici eseguibili direttamente dalla cpu Z80, ha formato
identico al file '.MOD' prodotto dal compilatore pero' in questo sono
del tutto assenti i due blocchi con rispettivamente, l'elenco delle 
variabili pubbliche e l'elenco dei richiami e a variabili esterne e loro
posizione nel sorgente.
Ovviamente nei blocchi con i dati tutti i riferimenti a indirizzi trattati
dal linker avranno gia' il giusto valore.

----------------------------------------------------------------------------

4. PSEUDOISTRUZIONI E FORMATO OPERANDI :

A-PSEUDO ISTRUZIONI :

Le pseudoistruzioni sono istruzioni interpretate dal compilatore per 
eseguire alcune cose altrimenti irrealizzabili con solo i codici standard 
dello Z80 (es. Riservare un blocco di bytes), ne sono disponibili 10.
Ecco l'elenco completo con una descrizione della funzione svolta:

END - serve per indicare al compilatore la fine del sorgente, non necessita 
     di alcun operando, è non e assolutamente necessaria la sua presenza 
     poiché se non presente viene automaticamente inserito dal compilatore 
     al termine del file. Comunque e sempre preferibile metterlo.

ORG - serve ad indicare l'indirizzo d'inzio di compilazione , necessita di 
     un solo operando di tipo numerico (compreso tra 0 e 65535) che indichi 
     tale valore. 
     Se non si mette questa istruzione il compilatore inizierà a partire 
     dall'indirizzo 0, se ne vengono inseriti più di uno, il file oggetto 
     sarà suddiviso in tanti blocchi quanti sono gli ORG presenti, tutti 
     avranno come indirizzo iniziale quello presente nell'ORG corrispondente.

EQU - serve ad assegnare un valore arbitrario ad un label, necessita 
     obbligatoriamente di una LABEL (a cui assegna il valore) e di un 
     OPERANDO di tipo numerico (di valore compreso tra 0 e 65535) che 
     indichi il valore desiderato.

FCB - serve ad assegnare un valore specifico ad un byte, necessita di uno 
     o più operandi di tipo numerico (valore compreso tra 0 e 255) che 
     indicheranno il valore da assegnare al/ai byte, ovviamente se più 
     di uno saranno assegnati con lo stesso ordine con cui appaiano sulla 
     linea, cioè a partire da sinistra, prima il primo poi il secondo e 
     così via.

FCW - funziona come FCB, assegna però valori a due bytes, (quindi vuole 
     valori tra 0 e 65535), ogni valore sarà inserito in memoria come byte 
     basso seguito dal byte alto, ovvero nel formato voluto dalla CPU Z80.

FCC - funziona esattamente come FCB solo che in più permette di assegnare 
     anche delle stringhe come sequenze di byte ACII.

DBS - permette di riservare un blocco di bytes, necessita quindi di uno o 
     più argomenti numerici (di valori compresi tra 0 e 65535), ovviamente 
     riserverà tanti blocchi quanti sono gli argomenti incontrati e li 
     mette nel solito ordine. 
     Importante, i blocchi saranno riempiti col valore 00.

LIST - vuole un argomento numerico di valore compreso tra 0 e 1, abilita 
     (1) o disabilita (0) la scrittura nel file .LST delle linee listate a 
     partire dalla successiva fino al prossimo LIST o alla fine del testo. 
     La condizione di default è list attivato a meno di non compilare con 
     l'opzione [-l] che lo mette disattivato. 
     Attenzione l'elenco delle label assegnate nel modulo sara comunque 
     inserito.

INCLUDE - vuole come argomento il nome di un file scritto per esteso 
     seguendo le regole dell'AmigaDos. 
     Inserisce dal punto in cui si trova l'istruzione il contenuto del file 
     indicato , il cui contenuto dovrà ovviamente essere realizzato e 
     formattato secondo le regole dei file sorgenti, visto che sarà trattato 
     come tale dal compilatore. 
     Attenzione se ne possono nidificare al massimo 2. 
     Attenzione tale file non sara' incluso nel calcolo dell'area temporanea 
     di memoria usata dal compilatore, che pertanto potra'risultare 
     insufficente, in tal caso usare l'opzione -t di compilazione (vedi 
     capitolo 1).

PUBBLIC - vuole come argomento una o più label separate da un carattere 
     virgola  ",". Tali label devono riferirsi a label con lo stesso nome 
     definite nello stesso sorgente, queste potranno poi essere viste anche 
     esternamente al file, da altri sorgenti tramite il successivo linkaggio.
     Attenzione da questa versione se si mette il carattere "_" all'inizio 
     della label equivale ha definire tale label come PUBBLIC.

EXTERN - vuole gli stessi argomenti di PUBBLIC. 
     In questo caso però le label si dovranno riferire a label non presenti 
     nel sorgente stesso, quindi esterne. 
     Esse saranno poi cercate dal linker tra appunto tutte le label 
     pubbliche messe a disposizione dai vari moduli linkati. 
     Attenzione da questa versione se si mette il carattere "_" all'inizio 
     della label equivale ha definire tale label come EXTERN.

Ogni pseudo istruzione può essere preceduta ovviamente da una LABEL, 
eccetto la EQU la quale DEVE essere preceduta da una label.

----------------------------------------------------------------------------

B-FORMATO OPERANDI:

Gli operandi possono essere di 4 tipi:


1 - REGISTRI , ovvero i registri ammessi dallo Z80 cioè : 
    A, B, C, D, E, H, L, I, R, AF, BC, DE, HL, IX, IY, SP, AF(per AF'). 
    Vanno inseriti così come sono messi nell'elenco (cioè maiuscoli)senza 
    altre aggiunte, apparte i registri indice (IX,IY), ma per maggiori 
    informazioni cerca su un manuale per lo Z80 assembler.

2 - TEST , ovvero i test sui flag ammessi dallo Z80 cioè : 
    Z, NZ, C, NC, P, PO, PE, M . 
    Per l'inserimento valgono le stesse modalità dei registri.

3 - NUMERICI , ovvero valori interi compresi tra 0 e 65535 o fino a 255, 
    se così vuole l'istruzione a cui è collegato l'argomento. 
    Possono essere composti da un espressione che comprenda numeri in base 
    10 (senza alcun prefisso), in base 2 (con prefisso '%'), in base 16 (con 
    prefisso '$') e LABEL, inoltre accettano le quattro operazioni 
    fondamentali e cioè: somma(+), differenza(-), moltiplicazione(*), 
    divisione(/), ovviamente il risultato sara' troncato alla parte intera. 
    Ma attenzione, le operazioni disponibili hanno tutte la stessa priorità 
    e l'espressione verrà valutata da sinistra verso destra. 
    Inoltre in tali espressioni non si accettano valori di stringa, non 
    sono presenti poi altre limitazioni se non quella della lunghezza 
    massima di 50 caratteri.

4 - STRINGHE , ovvero sequenze di caratteri ASCII standard, compresi tra due     caratteri virgolette(") che quindi non potranno MAI far parte della 
    stringa. Quindi sono accettati anche gli spazzi, le virgole e i TAB che 
    in questo caso non saranno considerati dei separatori, ma dei semplici 
    caratteri.
    La max. lunghezza utile sarà ovviamente di 48 caratteri poiché le due 
    virgolette delimitatrici non vengono considerate nella stringa. 
    Attenzione se si usa un operando di stringa la dove ne è richiesto uno 
    numerico (ovvero se l'istruzione collegata non è FCC)verrà usato come 
    valore il codice del carattere che segue le prime virgolette, cosa 
    utile ad es. per assegnare il codice ASCII di un carattere in modo da 
    risultare anche chiaro ad una successiva lettura del programma.

----------------------------------------------------------------------------

5. USO LINKER :

Per poter usare il linker occorre avere uno o più file oggetto (.MOD), 
realizzati col compiler in versione 2.00 o superiori. 
Una volta ottenuti i file necessari basta usare il comando :

 > L_Z80 [nomefile_parametri]

LEGENDA :
nomefile_parametri : indica il nome del file dove sono elencati tutti i 
                     parametri di linkaggio, come specificato piu' oltre.

Appena lanciato , se non e' stato indicato alcun nomefile_parametri , il 
linker richiedera prima il nome del modulo da linkare, (dovra' essere il 
nome per esteso del file oggetto ottenuto dalla compilazione) poi 
l'indirizzo da cui dovrà partire tale modulo. 
Per terminare l'inserimento dei moduli basta rispondere col carattere meno 
("-") alla richiesta del nome, a questo punto verrà richiesto il nome del 
file d'uscita a cui si dovra rispondere col nome per esteso del file su cui 
si vuole che vada il codice ottenuto dal linkaggio dei vari moduli separati.
In pratica dopo il lancio del comando si dovrà ottenere la seguente 
schermata:

LINKER PER C_Z80 ASSEMBLER Ver:1.01
By BiancaSoft (c) 1992,1995


 Nome modulo:nomefile_oggetto
Origine:indirizzo_iniziale_modulo 
.  \ 
.  | Coppia nome modulo, origine ripetuta tante volte quanti sono i moduli.
.  | da compilare. 
.  / 
Nome modulo:-
Nome file d'uscita:nomefile_uscita


 ***** ELENCO INDIRIZZI MODULI LINKATI *****

 MODULO :nomefile_oggetto 
 START:iiiii,$iiii  LEN:lllll,$llll 
.  \ 
.  | Coppia modulo, start-len ripetuta tante volte quanti sono i moduli da 
.  | compilare. 
.  | 
.  /

**** FILE D'USCITA :nomefile_uscita ,eeee :LINKER ERROR ****

NOTA: i caratteri i grassetto sono quelli effettivamente stampati sullo 
schermo, quelli in corsivo rappresentano i valori che andranno immessi dalla 
tastiera (ovviameente al termine della riga di input andrà premuto il tasto 
ENTER), infine i caratteri in tondo sono dei semplici commenti.

LEGGENDA:
nomefile_oggetto       : nome file modulo da linkare, scritto per esteso.
indirizzo_inizio_modulo: indirizzo iniziale da dove far partire il modulo 
			linkato, valore decimale compreso tra 0 e 65533 o 
			uno di questi caratteri,"-","+".
nomefile_uscita        : nome file dove mettere i codici ottenuti dal 
			linkaggio dei vari moduli indicati.
iiiii                  : indirizzo iniziale del primo blocco del modulo 
			indicato espresso in notazione decimale a 5 cifre.
$iiii                  : come sompra ma in notazione esadecimale a 4 cifre.
lllll                  : lunghezza in bytes del primo blocco del modulo 
			indicato espressa in notazione decimale a 5 cifre.
$llll                  : come sopra ma in notazione esadecimale a 4 cifre.
eeee                   : numero di errori incontrati durante il linkaggio 
			effettivo dei vari numeri. 
			E' espresso in notazione decimale a 4 cifre.

Nota: i caratteri "+" e "-" per il campo indirizzo_inizio_modulo hanno il 
     seguente significato:
     "+"    = mantenere l'origine indicata durante la compilazione del 
              modulo, quindi non rilocare tale modulo (si ottiene lo stesso 
              risultato dando come indirizzo il valore 65534).
     "-"    = Iniziare il modulo subito dopo il modulo precedente, ovvero 
              mette il modulo di seguito al precedente. 
              Se si riferisce al primo partirà da 0000 (si ottiene lo stesso 
              risultato dando come indirizzo il valore 65535).

I vari parametri di input richiesti dal programma, poiché attesi da 
standard-input possono essere passati anche tramite un file preparato in 
precedenza , redirigendo quindi l'input del linker su tale file, in questo 
modo:

 > L_Z80 <file_input

E' comuncque preferibile usare il seg. formato messo a disposizione 
dall'attuale versione:

 > L_Z80 file_input

Come si puo' notare facilmente l'unica modifica e' l'assenza del comando di 
redirezione dell'input, utile questo se si vuol redirigere l'output del 
programma su di un file all'interno di un file script, dato che altrimenti 
l'AmigaDos segnalerebbe un errore. 
Per il resto i due formati del comando sono perfettamente equivalenti, 
anche in cio' che deve essere messo e come in nome_file.

Ovviamente tale file dovrà essere un file ascii con le linnee chiuse dal 
caratere LF (Linefeed $0A), e i vari parametri dovranno essere uno per 
linea nello stesso ordine seguito nel caso di input normale da tastiera. 
Altra nota importate, se si redirige l'input su di un file nell'output su 
video appariranno sempre le richieste di input, ma in questo caso non si 
dovra' rispondere alcunche (peraltro non sarà neanche possibile vista la 
velocità e l'assenza del cursore) e sarà il Sistema Operativo ad estrarre 
le risposte opportune dal file di input, senza però visualizzarle sullo 
schermo.

Un esempio di tale file può essere il seguente:

pippo.mod     ->primo modulo dal nome : pippo.mod 
1000          ->indirizzo iniziale : 1000 
cicca.mod     ->secondo modulo dal nome : cicca.mod 
-             ->indirizzo iniziale : subito dopo la fine del prec. modulo 
-             ->termine inserimento moduli 
result.obj    ->nome file con codici ottenuti : result.obj

LEGGENDA :  I caratteri dopo '->' sono commenti di spiegazione e non vanno
	  messi, i caratteri prima sono quelli effettivamente presenti .
	  Ricordarsi che le linee devono essere terminate da un LineFeed 
	  ($0A).

Nota :E'sempre possibile interrompere l'esecuzione della compilazione in 
qualsiasi momento con la sequenza di tasti CTRL+C senza per questo perdere 
nessuna area di memoria riservata dal programma stesso come per il 
compilatore.

----------------------------------------------------------------------------

6. LIMITI DEL LINKER:

Poiche' per rilocare le variabili all'interno di uno stesso modulo il 
compilatore inganna il linker con il carattere '_' prima di una label ,
in modo da definirla contemporaneamente esetrna e pubblica, questa sara'
gia' usata (come nome) anche per gli altri moduli, quindi per evitarne
una eccessiva proliferazione , con connseguenti errori del tipo 'Label gia'
definita' conviene seguire le precauzioni descritte di seguito.

All'interno di un modulo è sempre bene evitare l'uso di istruzioni tipo 
salti ad indirizzi assoluti (JP), chiamate a subroutin (CALL) e tutte le 
istruzioni con riferimenti ad indirizzi assoluti (es. LD HL,$1000 o 
LD A,(10000)) riferiti all'interno dello, stesso modulo. 
Ovviamente ciò non vale per riferimenti assoluti a indirizzi esterni.

Il sistema migliore sarebbe quello di mettere le subroutin in moduli a se 
stanti, usare solo salti di tipo relativo all'interno di uno stesso modulo. 
Per le variabili del programma cercare di usare o una tabella fissa esterna 
ai vari moduli o comucque in posizione costante, oppure usare i riferimenti 
indicizzati tramite i registri indice IX o IY, o tramite displacement 
rispetto ad un registro a 2 bytes tipo HL.

Tutto questo tra l'altro rendera l'intero sorgente piu' ordinato e chiaro 
per il debug e successive modifiche eventuali.

----------------------------------------------------------------------------

APPENDICE - A


Elenco pseudoistruzioni :

END     - fine programma (non essenziale). 
ORG     - indirizzo d'inizio compilazione. 
EQU     - assegna un valore ad una LABEL. 
FCB     - assegna un valore ad un byte di memoria. 
FCW     - assegna un valore a due byte di memoria, seguendo il formato Z80.
FCC     - assegna sequenze di caratteri (stringhe) alla memoria. 
DBS     - riserva dei blocchi di bytes in memoria. 
LIST    - abilita (1) o disabilita(0) il list delle linee di programma.
INCLUDE - inserisce il file sorgente specificato in quello attuale a partire 
	  dalla stessa linea. 
PUBBLIC - definisce quali label del file possono essere viste anche 
	  esternamente agli altri file, tramite il linker. 
EXTERN  - definisce quali label non sono nel file ma esterne ad esso, 
	  saranno poi cercate dal linker fra quelle pubbliche disponibili.

Elenco istruzioni :

Vedi un manuale per l'assembler dello Z80, accetta tutte quelle legali 
purché scritte in caratteri maiuscoli. 
Unica eccezione è EX  AF,AF' che va scritta cosi: EX  AF,AF .


 Elenco tipo operandi :

1 REGISTRI  : A, B, C, D, E, H, L, I, R (registri ad 8 bit). 
	      AF, BC, DE, HL, IX, IY, SP, AF(per AF')(registri a 16 bit).

2 TEST FLAG : NZ, Z, NC, C, PO, PE, P, M.

3 NUMERICI  : espressioni il cui valore non può superare 65535 ovvero un 
	      numero a due bytes.

4 STRINGHE  : secquenza di qualunque carattere ASCII standard (eccetto '"') 
	      compresa tra i caratteri (") virgolette.

----------------------------------------------------------------------------

APPENDICE - B

Elenco errori riconosciuti :


A) SENZA CODICE

Si possono avere solo errore in lettura o scrittura dei file, la causa sarà 
da ricercare quasi sicuramente, o nell'aver levato il dischetto su cui si 
lavora troppo presto oppure nell'assenza del file richiesto. 
I messaggi sono autoesplicativi sul rimedio da usare, se non si riferiscono 
a dei file.
In ogni caso dopo aver rimosso la causa occorre ripetere la compilazione.


B) CON CODICE

Si hanno per errori nella stesura del file sorgente. 
Dopo aver eliminato la causa occorre ovviamente ripetere la compilazione. 
Ecco l'elenco completo:

01 ISRUZIONE ILLEGALE - nella riga indicata il compilatore ha trovato una 
   istruzione non compresa ne nel set legale dello Z80, ne nel set delle 
   pseudoistruzioni. 
   Controllare che non ci siano caratteri in minuscolo nel campo istruzione,    oppure non siano presenti caratteri ASCII non stampabili diversi sia da 
   LF che da TAB.

02 LABEL NON DEFINITA - in una espressione numerica si è trovata una LABEL 
   mai definita prima. 
   Attenzione, questo errore può essere causato dall'aver esaurito lo 
   spazio in memoria riservato dal compilatore per le variabili, quindi 
   sapendo che tale spazio è di 3000 bytes di default, che le variabili 
   occupano al max.13 bytes(n# caratteri nome +3) verificare.

03 LABEL GIA' DEFINITA - si è tentato di definire una LABEL già definita in 
   precedenza nel programma.

04 OPERANDO ILLEGALE - si è cercato di eseguire un espressione non permessa 
   oppure si è cercato di assegnare un operando errato per l'istruzione di 
   quella riga.

05 NUMERO TROPPO GRANDE - si è cercato di fare un salto relativo non compreso   nel range tra -128/+127 , di dare un displacement  ad un registro indice 
   non compreso nel range tra -128/+127, oppure si è dato un valore a 2 
   bytes(>255) la dove ne occorreva uno ad 1 byte.

06 TROPPE LABEL - il numero di LABEL che si sono definite supera la capacita 
   di memorizzazione del compilatore, provare a ridurle o a ridurre la 
   lunghezza dei loro nomi. Oppure prova ad aumentare l'area a loro riservata
   lanciado la compilazione con l'opzione [-v nnnn] dove nnnn dovrà essere 
   un numero maggiore di 3000 bytes. 
   In generale dovrà essere di almeno 3000+14*(n# di errori 06 rilevati).
   Vedi anche nota sul cod. errore n#02.

07 SALTO TROPPO LUNGO - si è cercato di fare un salto relativo fuori dal 
   range di -128/+127.

08 TROPPE LABEL ESTERNE - si sono definite tramite la pseudoistr. EXTERN 
   troppe label e si è superata la capacita del buffer ad esse riservato. 
   Ridurle oppure ricompilare usando l'opzione [-e nnnn] dove nnnn sara la 
   nuova dimensione in bytes di tale buffer, tenere presente che di default 
   è di 2000 bytes.

09 TROPPE LABEL PUBBLICHE - si sono definite tramite la pseudoistr. PUBBLIC 
   troppe label e si è superata la capacita del buffer ad esse riservato. 
   Ridurle oppure ricompilare usando l'opzione [-p nnnn] dove nnnn sarà la 
   nuova dimensione in bytes di tale buffer, tenere presente che di default 
   e' di 1000 bytes.

10 USO LABEL ESTERNA O RILOC.ILLEGALE - si e tentato di usare una label 
   esterna su una istruzione di salto relativo o comuncque la dove ci si 
   aspetta un displacement compreso nel range di -128/+127. 
   Questa operazione non è permessa dal compilatore, che non potendo 
   conoscere a priori il valore effettivo della label esterna, assume che 
   sia sempre maggiore di quel range quindi si avra' anche per le variabili
   rilocabili cioe' quelle il cui nome e' preceduto da '_'.

NOTA : Il numero di linea si riferisce sempre alla linea dove è stato 
rilevato l'errore, se si sono inseriti uno o più Include file tale valore 
sarà riferito al file ottenuto dall'inserimento anche di tali file, quindi 
non coinciderà più col n# di linea del file sorgente originale.
Attenzione la prima linea per il compilatore è la n#1.

----------------------------------------------------------------------------

APPENDICE - C

Richieste di sistema :

Essendo stato compilato con lo gnu C necessita di ixemul.library versione
dalla 41.4 in poi e di uno stack di dimensioni adeguate, io ne uso uno di
200000 bytes, ma probabilmente e' sufficente anche piu' piccolo.
Pero' ricompilando con altro compilatore C o con ixemul precedenti va bene
lo stesso, visto che i sorgenti dei due programmi usano solo funzioni delle
librerie standard ANSI C, senza alcuna chiamata a funzioni particolari di
Amiga OS , tant' e' che per trasportarlo su altre piattaforme hardware
dovrebbe essere necessaria solo una ricompilazione, senza toccare i sorgenti
(apparte forse per il formato dei nomi dei file).

La versione di c_z80 e l_z80 eseguibile puo' girare su tutte le CPU dal
68000 in su e su tutti gli OS da 1.3 in su.
In particolare sono stati verificati su:
Amiga 500
Amiga 4000/30
Amiga 4000/40

----------------------------------------------------------------------------

APPENDICE - D
 
Storia programma :

1990,1991 - Release di c_z80 1.00 ,1.25 ancora non permetteva l'uso di
	    moduli separati, versioni beta mai rilasciate al pubblico. 
1992      - Release di c_z80 2.00 e Release di l_z80 1.00 implementato 
	    l'uso di moduli separati.
	    Versioni beta , mai rilasciate al pubblico.
1995      - Release di c_z80 2.01 e release di l_z80 1.01 eliminano
	    alcuni bug delle precedenti versioni.
	    Rilasciate al pubblico nel 1997, per mancanza di collegamento
	    su internet.

L'autore ringrazia in anticipo ogni nota, critica o segnalazione di problemi.

L'autore :
	Patrizio Biancalani
	Prato(PO) ITALY
	E-Mail : P.Biancalani@agora.stm.it

----------------------------------------------------------------------------

NOTE DI COPYRIGHT

L'AUTORE AUTORIZZA L'USO E LA DISTRIBUZIONE LIBERA DEL COMPILATORE E DEL
LINKER.
LA LORO DISTRIBUZIONE E' AMMESSA SOLO SE INCLUDE TUTTI I FILE DELL'ORIGINALE
SU AMINET, ED INOLTRE NON NE' AMMESSA LA VENDITA AD ALCUNO.
DECLINO INOLTRE OGNI RESPONSABILITA PRESENTE O FUTUTRA SU DANNI DERIVATI
DALL'USO DEI DUE PROGRAMMI DEI LORO SORGENTI E DEI FILE PRODOTTI DAI DUE 
PROGRAMMI.
E' AMMESSO L'USO DEI SORGENTI ALLEGATI PER IL PORTING SU ALTRI SISTEMI 
OPERATIVI O PIATTAFORME HARDWARE MA NON LA LORO VENDITA, E SI DECLINA IN
ANTICIPO OGNI RESPONSABILITA' DA DANNI DERIVANTI DALL'USO DI TALI PORTING.

----------------------------------------------------------------------------
 

----------------------------------------------------------------------------

         I N D I C E

  CAPITOLO                                                PAGINA

1. USO COMPILATORE                ------------------------ 

2. FORMATO FILE SORGENTE          ------------------------

3. FORMATO FILE D'USCITA          ------------------------ 

4. PSEUDOISTR. E FORMATO OPERANDI ------------------------

5. USO LINKER                     ------------------------ 

6. LIMITI DEL LINKER              ------------------------

APPENDICE A                       ------------------------ 

APPENDICE B                       ------------------------ 

APPENDICE C			  ------------------------

APPENDICE D                       ------------------------ 

