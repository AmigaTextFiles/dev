@database "cpu.resource.guide"
@remark $Id: cpu.resource.guide,v 3.0 1997/02/15 21:53:17 wjm Rel $

@font courier.font 13

@remark-----------------------------------------------------------------------

@node Main "Programmer's Guide To cpu.resource"
@font courier.font 18



        @{b}----------------------------------
        PROGRAMMER'S GUIDE TO CPU.RESOURCE
        ----------------------------------@{ub}










        Copyright © 1997 by W. John Malone,
               DYNACHROME Software.
               All rights reserved.
@endnode


@remark------------------------------------------------------------------------

@node Contents "Programmer's Guide To cpu.resource"


   @{b}1. INTRODUCTION@{ub}

      1.0 @{" Introduction " link Introduction}........................................module purpose


   @{b}2. FUNCTION@{ub}

      2.0 @{" Hardware Ownership " link Ownership}...........................low-level arbitration
      2.1 @{" Target Independence" link Independence}..................................basic services
      2.2 @{" Extensions " link Extensions}....................................extending the basics


   @{b}3. IMPLEMENTATION@{ub}

      3.0 @{" Basics " link Basics}..........................................writing the basics
      3.1 @{" Extensions " link ImpExtensions}......................................writing extensions
      

   @{b}4. USAGE@{ub}

      4.0 @{" Usage " link Usage}...............................access and use of the resource
   

   @{b}5. REFERENCE@{ub}

      5.0 @{" Resource Procedures " link cpu.resource.ag/Main}..........................cpu.resource AutoDocs


   @{b}6. SEE ALSO@{ub}

      @{" AmiExec.guide " link AmiExec.guide/Contents}
      @{" exec.library.guide " link exec.library.guide/Contents}
      @{" timer.device.guide " link timer.device.guide/Contents}
      @{" serial.device.guide " link serial.device.guide/Contents}
      @{" debug.library.guide " link debug.library.guide/Contents}
      
@endnode   


@remark--------------------------------------------------------------------------

@node Introduction "Programmer's Guide To cpu.resource | Introduction"
@toc  Contents
@{u}@{b}Introduction@{ub}@{uu}

A @{b}cpu.resource@{ub} is a hardware dependent module of an AmiExec system. This
document, in conjunction with the AutoDoc, specifies the interface and
functionality a cpu.resource implementation must provide.

@endnode


@remark--------------------------------------------------------------------------
@node Ownership "Programmer's Guide To cpu.resource | Hardware Ownership"
@toc  Contents
@{u}@{b}Hardware Ownership@{ub}@{uu}

The CPU resource is responsible for arbitration of access to the hardware
features on the CPU board.  This arbitration is low-level, below that
provided by devices.  For instance a timer device would call
CPU_AllocResource to gain ownership of the hardware it needs to offer timing
services to the rest of the system.  The CPU resource does @{b}not@{ub}
isolate devices from hardware, it just provides a bookkeeping mechanism for
tracking who's using what.

See: @{" CPU_AllocResource " link cpu.resource.ag/CPU_AllocResource}
     @{" CPU_FreeResource " link cpu.resource.ag/CPU_FreeResource}

@endnode


@remark--------------------------------------------------------------------------
@node Independence "Programmer's Guide To cpu.resource | Target Independence"
@toc  Contents
@{u}@{b}Target Independence@{ub}@{uu}

The CPU resource offers a small number of services to the rest of the system
such that cpu board dependent code is isolated in the resource.  In particular,
there are a number of procedures for manipulation of on-board serial ports,
the assumption being that any CPU board has at least one.  These are
low-level procedures which came into existence primarily to allow
debug.library to be a concrete, target independent module.

Also, the VMEbus address space locations are stored in CPU resource.  This is
obviously not relevant for non-VME systems.

See: @{" CPU_SetSerialSettings " link cpu.resource.ag/CPU_SetSerialSettings}
     @{" CPU_GetSerialSettings " link cpu.resource.ag/CPU_GetSerialSettings}
     @{" CPU_PutChar " link cpu.resource.ag/CPU_PutChar}
     @{" CPU_ReadChar " link cpu.resource.ag/CPU_ReadChar}
     @{" CPU_GetChar " link cpu.resource.ag/CPU_GetChar}

@endnode
     
     
@remark--------------------------------------------------------------------------
@node Extensions "Programmer's Guide To cpu.resource | Extensions"
@toc  Contents
@{u}@{b}Extensions@{ub}@{uu}
     
A CPU board may include features for which it is expedient to provide
procedures to manipulate.  In such a case the vanilla CPU resource,
procedures and/or data structure, should be extended.  For example, one board
AmiExec has been ported to had a number of registers for configuring bus
access.  The implementation of cpu.resource for that board was extended with
procedures for manipulation of those registers.

@endnode


@remark--------------------------------------------------------------------------
@node Basics "Programmer's Guide To cpu.resource | Implementing Basics"
@toc  Contents
@{u}@{b}Implementing Basics@{ub}@{uu}

Write a resource which implements the procedures described in the CPU
resource AutoDocs.

@endnode


@remark--------------------------------------------------------------------------
@node ImpExtensions "Programmer's Guide To Exec.library | Implementing Extensions"
@toc  Contents
@{u}@{b}Implementing Extensions@{ub}@{uu}

By convention the new procedures would be prefixed with MyBoardName_ rather
than the generic CPU_ prefix.  Ensure that vector offsets of your
implementation of the generic CPU resource procedures remain congruent with
the generic CPU resource includes.

@endnode


@remark--------------------------------------------------------------------------
@node Usage "Programmer's Guide To Exec.library | Usage"
@toc  Contents
@{u}@{b}Usage@{ub}@{uu}

CPU resource clients access the resource in one of two ways, either as a
generic CPU resource, or as specific CPU board resource.  In the former case
the client simply opens the resource and accesses it via the CPUResource
structure and CPU_#?  calls.  As an example of generic cpu.resource access,
debug.library which simply uses the basic serial port procedures just opens
cpu.resource and uses CPU_ calls.

In the case of accessing a specific CPU board resource, after opening the
resource the client must verify that CPUResource->CPUName is indeed the
specific board desired.  The client can then reference the extended
CPUResource structure and make extended CPUResource calls.  As an example of
the latter, the timer device which has knowledge of hardware would open the
CPU resource, check the CPUName, and then AllocResource the hardware it
needs.

@endnode
