@database "AmiExec.guide"
@remark $Id: AmiExec.guide,v 3.1 1997/02/15 08:15:16 wjm Exp $

@font courier.font 13

@remark-----------------------------------------------------------------------

@node Main "AmiExec Programmer's Guide"
@font courier.font 18



            @{b}--------------------------@{ub}
            @{b}AMIEXEC PROGRAMMER'S GUIDE@{ub}
            @{b}--------------------------@{ub}









     Copyright © 1995-1997 by W. John Malone,
               DYNACHROME Software.
               All rights reserved.
@endnode


@remark------------------------------------------------------------------------

@node Contents "AmiExec Programmer's Guide"

   @{b}1. INTRODUCTION@{ub}

      1.0 @{" Introduction " link Introduction}......................................what AmiExec is
      1.1 @{" Features " link Features}.......................................capability summary
      1.2 @{" System Requirements " link Requirements}....development and target system requirements


   @{b}2. ARCHITECTURE@{ub}

      2.0 @{" Overview " link Overview}..............................how the pieces fit together 
      2.1 @{" exec.library "  link exec.library.guide/Contents}.................................kernel of the kernel
      2.2 @{" cpu.resource "  link cpu.resource.guide/Contents}................................CPU board abstraction
      2.3 @{" debug.library "  link Debug}......................................system monitor
      2.4 @{" timer.device "  link Timer}......................................timing services
      2.5 @{" serial.device "  link Serial}................................serial port services


   @{b}3. SYSTEM CONSTRUCTION@{ub}

      3.0 @{" Porting " link Porting}...........................porting AmiExec to a new target
      3.1 @{" Building Modules " link Modules}...............................load file creation
      3.2 @{" Building Systems " link Sysgen}................................system generation


   @{b}4. REFERENCE@{ub}

      4.0 @{" Tools " link Tools.ag/Main}............................................scripts and such

@endnode   
   

@remark--------------------------------------------------------------------------

@node Introduction "AmiExec Programmer's Guide | Introduction"
@toc  Contents
@{u}@{b}Introduction@{ub}@{uu}

AmiExec is a real-time, multitasking microkernel.  It consists of a number of
software modules and utilities.  Some of the modules are concrete
ready-to-run binaries.  Other modules because of their hardware dependent
nature are "virtual" - a specification which must be implemented for the
target hardware.  However, the core of AmiExec is a concrete look-a-like
implementation of the real-time kernel at the heart of the Amiga® operating
system.

AmiExec allows construction of 680x0 real-time computer systems using the
same system of libraries, devices and tasks as employed by the Amiga OS.  For
example, AmiExec can be used for an embedded machine or process control
system based on a 680x0 single board computer.  Because AmiExec shares the
fundamental Amiga software architecture, it makes the numerous benefits of
that architecture available to embedded systems designers.

The software development platform for AmiExec is the Amiga, using native
Amiga development tools.  This is economical, allows synergy with the target,
and brings the benefits of the Workbench environment to embedded systems
development.

This document describes and discusses the features and services provided by
each of the software modules, concentrating primarily on exec.library.  It
also discusses how to build and download or embed an AmiExec based system.
The tools, many of which are equally useful for native development, are also
discussed.

@endnode


@remark-----------------------------------------------------------------------

@node Features "AmiExec Programmer's Guide | Introduction | Features"
@toc  Contents
@{u}@{b}Features@{ub}@{uu}

   ·  Support for all but the most esoteric @{"Amiga Exec functions" link ExecFunctions}. You can
      create and use tasks, libraries, devices, semaphores, messages and 
      message ports, interrupts (including software interrupts), manage 
      flavoured memory etc, all using the "Industry Standard Amiga" API.

   ·  @{"Portable" link Porting} to any 68K based computer.

   ·  @{"Low cost" link Pricing}.

   ·  @{"High performance" link Benchmarks}.

   ·  An extensible @{"debugging facility" link debug.library.guide/Main} allowing easy inspection of the 
      execution state of a system. 

   ·  @{"Tools and scripts" link Tools.ag/Main} to support development of AmiExec systems.


@endnode


@remark-----------------------------------------------------------------------

@node ExecFunctions "AmiExec Programmer's Guide | Introduction | Features | Exec Functions Supported"
@toc  Contents
@{u}@{b}Exec Functions Supported@{ub}@{uu}

   AbortIO           - attempt to abort an in-progress I/O request              
   AddDevice         - add a device to the system                            
   AddHead           - insert node at the head of a list                       
   AddIntServer      - add an interrupt server to the system              
   AddLibrary        - add a library to the system                          
   AddMemList        - add memory to the system free pool                   
   AddPort           - add a public message port to the system               
   AddResource       - add a resource to the system                         
   AddSemaphore      - add a signal semaphore to the system               
   AddTail           - append node to tail of list                             
   AddTask           - add a task to the system                                
   AllocAbs          - allocate at a given location                           
   Allocate          - allocate a block of memory                             
   AllocEntry        - allocate many regions of memory                      
   AllocMem          - allocate memory given certain requirements             
   AllocSignal       - allocate a signal bit                                
   AllocVec          - allocate memory and keep track of the size             
   AttemptSemaphore  - try to obtain without blocking                 
   AvailMem          - memory available given certain requirements             
   CacheClearU       - user callable simple cache clearing                 
   Cause             - cause a software interrupt                                
   CheckIO           - get the status of an IORequest                           
   CloseDevice       - conclude access to a device                          
   CloseLibrary      - conclude access to a library                       
   CopyMem           - general purpose memory copy routine                      
   CopyMemQuick      - optimized memory copy routine                       
   CreateIORequest   - create an IORequest structure.                  
   CreateMsgPort     - allocate and initialize a new message port.       
   Deallocate        - deallocate a block of memory                         
   DeleteIORequest   - free a request made by CreateIORequest()        
   DeleteMsgPort     - free a message port created by CreateMsgPort      
   DoIO              - perform an I/O command and wait for completion              
   Enqueue           - insert or append node to a system queue                 
   FindName          - find a system list node with a given name               
   FindPort          - find a given system message port                     
   FindResident      - find a resident module by name                    
   FindSemaphore     - find a given system signal semaphore              
   FindTask          - find a task with the given name or find oneself        
   Forbid            - forbid task rescheduling.                                  
   FreeEntry         - free many regions of memory                           
   FreeMem           - deallocate with knowledge of block size                   
   FreeSignal        - free a signal bit                                  
   FreeVec           - return AllocVec() memory to the system                  
   GetMsg            - get next message from a message port                   
   InitCode          - initializes resident code modules                     
   InitResident      - initializes resident module                       
   InitSemaphore     - initializes a signal semaphore                    
   Insert            - insert a node into a list                                 
   MakeFunctions     - construct a function jump table                    
   MakeLibrary       - construct a library                                  
   ObtainSemaphore   - gain exclusive access to a semaphore             
   OpenDevice        - gain access to a device                                
   OpenLibrary       - gain access to a library                             
   OpenResource      - gain access to a resource                          
   Permit            - permit task rescheduling.                             
   Procure           - bid for a message lock (semaphore)                      
   PutMsg            - put a message to a message port                        
   ReleaseSemaphore  - make signal semaphore available to others      
   RemDevice         - remove a device from the system                       
   RemHead           - remove the head node from a list                        
   RemIntServer      - remove an interrupt server from a server chain     
   RemLibrary        - remove a library from the system                     
   Remove            - remove a node from a list                                
   RemPort           - remove a message port from the system                 
   RemResource       - remove a resource from the system                   
   RemTail           - remove the tail node from a list                        
   RemTask           - remove a task from the system                           
   ReplyMsg          - put a message to its reply port                      
   SendIO            - initiate an I/O command                                   
   SetFunction       - change a function vector in a library               
   SetIntVector      - set a system interrupt vector                      
   SetSignal         - define the state of this task's signals             
   SetTaskPri        - get and set the priority of a task                   
   Signal            - signal a task                                          
   TypeOfMem         - determine attributes of a given memory address        
   Vacate            - release a message lock (semaphore)                       
   Wait              - wait for one or more signals                             
   WaitIO            - wait for completion of an I/O request                    
   WaitPort          - wait for a given port to be non-empty                  
@endnode


@remark-----------------------------------------------------------------------

@node Requirements "AmiExec Programmer's Guide | Introduction | Features | System Requirments"
@toc  Contents
@{u}@{b}System Requirements@{ub}@{uu}

Minimum development system requirements are a WB2.04, 68020 Amiga equipped
adequately for the compiler package you choose to use.  The compiler and
other tools you use are your choice.  One of the benefits of the Workbench
environment is it provides the IDE, not each software package.  However,
depending on what you choose some tinkering with include files and scripts
may be required.  If you use SAS/C and WShell such tinkering will be kept to
a minimum.

Target system requirements are of course application dependent.  However you
will need a 68K family based computer with at least 64K of nonvolatile memory
(ROM/battery-backed SRAM/Flash), 16K of RAM, a timer chip, and a serial port.
AmiExec currently supports the 68K family up to the 68030, including 683xx
microcontrollers.  The 68040 and 68060 are not yet supported.

@endnode


@remark-----------------------------------------------------------------------

@node Overview "AmiExec Programmer's Guide | Architecture | Overview"
@toc  Contents
@{u}@{b}Overview@{ub}@{uu}

AmiExec uses a microkernel architecture.  That means it is not a single
monolithic software module but rather a group of cooperating modules each
with specific responsibilities.  A microkernel brings with it a number of
advantages but the most important is it makes the system extensible.  New
modules such as device drivers can be added at a later date without having to
recompile or relink existing modules.  For more on the advantages of
microkernels refer to @{"Libraries" link exec.library.guide/Libraries}, which are the fundamental building block of
AmiExec systems.

The @{"AmiExec System Diagram" system "SYS:Utilities/Multiview AmiExec.iff"} illustrates the relationships among the modules
which make up AmiExec, and the relationship of AmiExec to applications.

@endnode


@remark-----------------------------------------------------------------------

@node Porting "AmiExec Programmer's Guide | System Construction | Porting"
@toc  Contents
@{u}@{b}Porting@{ub}@{uu}

To port AmiExec to a specific 68K board, the hardware dependent modules must
be written for the hardware on that board.  That means an implementation of
the "virtual" cpu.resource, timer.device and serial.device modules must
written.  See the documentation for the individual modules for a definition
of the interface they must support.

Contact DYNACHROME Software for up-to-date information on board and CPU
support as well as porting services.

@endnode


@remark-----------------------------------------------------------------------

@node Modules "AmiExec Programmer's Guide | System Construction | Building Modules"
@toc  Contents
@{u}@{b}Building Modules@{ub}@{uu}

In the context of system construction a module is an AmigaDOS load file
containing a library or device or task or whatever.  Modules are created
using native Amiga development tools such as the SAS/C compiler.

One of the goals of AmiExec has been compatibility with the Amiga.  For
instance, the native Amiga Exec includes supplied with your compiler can be
used.  An AmiExec module, if it differs at all from a native Amiga module,
differs in @{"compiler options" link Compiler}, @{"startup code" link Startup}, and @{"linker libraries" link Linker}.

Resident modules (and all AmiExec modules are resident modules) are
initialized in order of their ROMTag priority.  Order matters because it
affects what resources are available during the module's Init procedure.  It
is recommended that Init procedures restrict themselves to making use of
low-level, high priority, system resources such as memory and the timer
device.  Use of higher level resources should be deferred until the module's
first Open.

The following shows the ROMTag priorities of the AmiExec modules and provides
guidelines for ROMTag priority assignment.
   
   @{u}Priority    Module@{uu}

   127:        Data Sections
   120:        exec.library
   110:        Memory Regions
   105:        cpu.resource
   100:        debug.library      
     5:        low level libraries and devices
    -5:        high level libraries and devices
   -10:        tasks and processes

@endnode


@remark-----------------------------------------------------------------------

@node Compiler "AmiExec Programmer's Guide | System Construction | Compiler Options"
@toc  Contents
@{b}Compiler Options@{ub}

The AmiExec distribution comes with the SAS/C compiler options to be employed
during compilation.  These options are in the SCOPTIONS.nb file in the
EXEC:admin directory.  The file is text so it can be read even if a different
compiler or language is being used.  The important points are to compile so
that code and data references are 32 bit, software math is used, and
references to Exec are via SysBase and not AbsSysBase.

@endnode


@remark-----------------------------------------------------------------------

@node Startup "AmiExec Programmer's Guide | System Construction | Startup Code"
@toc  Contents
@{b}Startup Code@{ub}

All modules in an AmiExec system are resident modules so they must have a
ROMTag as the first object file passed to the linker.  Do not link with
native Amiga startup code as modules are not being launched from AmigaDOS.
Instead, tasks and processes must pull in LIB:c_task.o, and libraries,
devices and resources must pull in LIB:c_lib.o.

@endnode


@remark-----------------------------------------------------------------------

@node Linker "AmiExec Programmer's Guide | System Construction | Linker Libraries"
@toc  Contents
@{b}Linker Libraries@{ub}

Pull in the far data versions of the compiler's linker libraries and if
floating point math is used, the software math libaries.  If using SAS/C that
means scmnb.lib and scnb.lib.  However, pull in vmenb.lib and extnb.lib first
as they replace some procedures in the Amiga libaries.

@endnode


@remark-----------------------------------------------------------------------

@node Sysgen "AmiExec Programmer's Guide | System Construction | Sysgen"
@toc  Contents
@{u}@{b}Sysgen@{ub}@{uu}

Building a system consists of locating the component modules at memory
locations appropriate to the target hardware and downloading the located
modules to the target.  The AmiExec distribution includes an ARexx script
to perform this function called @{"Sysgen.rexx" link Tools.ag/Sysgen.rexx}.

Sysgen.rexx accepts an input file which is essentially a list of modules that
make up the system and produces and/or downloads an S-record file
corresponding to each located module.

Be careful with the LOCATION specifications in the Sysgen.rexx input file.
The LOCATION specifications and the memory ROMTags present in the system must
agree about where data sections are.

@endnode
