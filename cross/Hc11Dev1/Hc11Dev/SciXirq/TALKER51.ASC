************************ TALKER51.ASC 10/6/88 ****************************
*   Written by R.Soja, Motorola, East Kilbride                           *
*   Motorola Copyright 1988                                              *
*   MCU resident, Interrupt driven Communication routines for HC11JC     *
*   monitor. Provides low level memory and stack read/write operations.  *
*   Works with Host user interface program PCBUG11.EXE and 65C51 ACIA.   *
*
* CONSTANTS
MEMOFFSET equ $0000
TALKBASE  equ $FF00-MEMOFFSET
TALKVECT  equ $FFF4-MEMOFFSET
ACIA      equ $8000
uS500     equ 5000/35     500uS delay with DEY/BNE loop
BRKCODE   equ $4A         Break point signal code to host.
BRKACK    equ $B5         Break point acknowledge code from host.
*
* ACIA MASKS
TDRE      equ $10
RDRF      equ $08
*
* PROGRAM
          org TALKBASE
*
TALKSTART EQU *
          LDS #$1FF
          LDD #$C91E    Init ACIA to 9600 baud, 8 bit, no parity, Rx intr.
          STD ACIA+2    Note: Control reg set up for 1.843MHz xtal.
*
USERSTART EQU *         This is entry point of user defined reset.
          TPA           XIRQ must be enabled (Clear X bit in CCR)
          ANDA #$BF
          TAP
IDLE      JMP IDLE+MEMOFFSET   Now hang around for interruption from host.
* A RESET from host changes above jump destination to start of user code.
*
XIRQSRV   EQU *
          LDAA ACIA+1   If ACIA has generated interrupt, then
          BMI TXIRQ     Talker code processes received data
          JMP >TXIRQEX+MEMOFFSET
* Above 3 bytes are replaced by JMP USERXIRQ instruction from host monitor, if
* user specified XIRQ vector is detected during download of user code.
*
XIRQUJMP  EQU *-2       Label equates to JMP operand.
*
TXIRQ     EQU *
          LDAA ACIA     Read command byte, & echo it as acknowledge
          BSR OUTACIA   to host.
          BMI INH1      If command bit 7 set, then process inherent command
          BSR INACIA    else read byte count from host into ACCB.(0=256)
          XGDX          Save command and byte count.
          BSR INACIA    Read high address byte
          TBA           into ACCA
          BSR INACIA    then low address byte into ACCB
          XGDX          Restore command in ACCA,count in ACCB,address in X
          CMPA #$01
          BNE TXIRQ1    If command is memory read, then
*
TREADMEM  EQU *         REPEAT
          LDAA ,X       read required address
          BSR OUTACIA   send it to host
          TBA           (save byte count)
          BSR INACIA    and wait for acknowledge
          TAB           (restore byte count)
          INX           Increment address
          DECB          Decrement byte count
          BNE TREADMEM  UNTIL all done
          RTI           and return to idle loop or user code.
*
TXIRQ1    EQU *
          CMPA #$41
          BNE TXIRQEX   If command is memory write then
*
          TBA           move byte count to ACCA
TWRITMEM  EQU *         REPEAT
          BSR INACIA    Read next byte from host into ACCB,
          STAB ,X       and store at required address.
          LDY #$0001    Set up wait loop to allow for 28C64 prog time, where
WAITPOLL  DEY           Y operand must be manually set to $0359 (3mS)
          BNE WAITPOLL
          LDAB ,X       Read stored byte and
          STAB ACIA     echo it back to host,
          INX
          DECA          Decrement byte count
          BNE TWRITMEM  UNTIL all done
TXIRQEX   RTI           and return
*
INACIA    EQU *
          LDAB ACIA+1   Wait for RDRF=1
          ANDB #RDRF
          BEQ INACIA
          LDAB ACIA     then read data received from host
          RTS           and return with data in ACCB
*
OUTACIA   EQU *         Only register Y modified.
          XGDY          Enter with data to send in ACCA.
OUTACIA1  LDAA ACIA+1
          ANDA #TDRE
          BEQ OUTACIA1
          XGDY
          STAA ACIA     Important - Updates CCR!
          RTS
*
INH1      EQU *
          CMPA #$81     If command is read MCU registers then
          BNE INH2
*
INH1A     TSX           Move stack pointer to X
          XGDX          then to ACCD
          BSR OUTACIA   send stack pointer to host (high byte first)
          TBA
          BSR OUTACIA   then low byte
          TSX           Restore X (=stack pointer)
          LDAB #9       then return 9 bytes on stack
          BRA TREADMEM  i.e. CCR,ACCB,ACCA,IXH,IXL,IYH,IYL,PCH,PCL
*
INH2      EQU *
          CMPA #$C1     If command is write MCU registers then
          BNE SWISRV1
*
          BSR INACIA    get stack pointer from host (High byte first)
          TBA
          BSR INACIA
          XGDX          Move to X reg
          TXS           and copy to stack pointer
          LDAA #9       Then put next 9 bytes from host on to stack
          BRA TWRITMEM
*
SWISRV    EQU *         Breakpoints generated by host-placed SWI instruction.
          LDAA #BRKCODE Force host to process breakpoints
          BSR OUTACIA   by sending it the break signal
SWIIDLE   BRA SWIIDLE   then wait for response from host. (Ibit=1,Xbit=0)
*
SWISRV1   EQU *
          CMPA #BRKACK  If host has acknowledged breakpoint state then
          BNE TXIRQEX
          TSX           move stack pointer to SWI stack frame and
          LDAB #9
          ABX
          TXS
          LDD 7,X       Send user code breakpoint return address to host
          BSR OUTACIA   (high byte first)
          TBA
          BSR OUTACIA   (low byte next)
          LDD #IDLE+MEMOFFSET force idle loop on return from breakpoint processing
          STD 7,X
          BRA INH1A     but first return all MCU registers to host
*
ILLOPSRV  equ *
          STOP
          BRA ILLOPSRV
*
          org TALKVECT
          FDB XIRQSRV+MEMOFFSET
          FDB TXIRQEX+MEMOFFSET   SWI (Changed by Break and Trace monitor cmds)
          FDB ILLOPSRV+MEMOFFSET
          FDB TXIRQEX+MEMOFFSET   COP Software fail (Unused)
          FDB TXIRQEX+MEMOFFSET   COP Clock Monitor fail (Reassigned by PCBUG11 Reset)
          FDB TALKSTART+MEMOFFSET
          END