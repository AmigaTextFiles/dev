*************************** TALKEEA2.ASC 29/7/88 *************************
*   Written by R.Soja, Motorola, East Kilbride                           *
*   Motorola Copyright 1988                                              *
*   MCU resident, Interrupt driven Communication routines for 68HC11     *
*   monitor. Provides low level memory and stack read/write operations.  *
*                                                                        *
*   This talker uses XIRQ (connected to SCI RX)                          *
*   --------------------------------------------                         *
*                                                                        *
* N.B. TALKEEA2.ASC is designed to work with the 68HC811A2 MCU,          *
*      executing from internal EEPROM addresses $FF00-$FFFF.             *
*      TALKEEA2 must have been previously downloaded in some manner, for *
*      instance using PCBUG11 BOOTA2 option, and EEPROM & LOADS commands.*
*      TALKEEA2 is designed to run with the 68HC811A2 in normal single   *
*      chip or expanded mode.                                            *
*      On startup PCBUG11 reads the file TALKEEA2.MAP.                   *
*
* CONSTANTS
TALKBASE  equ $FF00
TALKVECT  equ $FFD6       Start of normal vector jump table.
STACK     equ $00FF
REGBASE   equ $1000
*
JSCI      equ $00C4
JXIRQ     equ $00F1
JSWI      equ $00F4
JILLOP    equ $00F7
JCOP      equ $00FA
JMPEXT    equ $7E         Mnemonic for jump extended instruction
BRKCODE   equ $4A         Break point signal code to host.
BRKACK    equ $B5         Break point acknowledge code from host.
*
* REGISTERS
BAUD      equ $2B
SCCR1     equ $2C
SCCR2     equ $2D
SCSR      equ $2E
SCDR      equ $2F
*
RDRF      equ $20
TDRE      equ $80
*
* PROGRAM
          org TALKBASE
TALKSTART EQU *
          LDS #STACK
          LDX #REGBASE
          CLR SCCR1,X
          LDD #$300C
          STAA BAUD,X   Initialise SCI to 9600 baud, no parity
          STAB SCCR2,X  and enable SCI tx & rx.
          LDAA #$10     Enable STOP, and XIRQ, disables I bit interrupts.
          TAP
*
IDLE      JMP IDLE      Now hang around for SCI interrupt from host.
* A RESET from host changes above jump destination to start of user code.
*
SCISRV    EQU *             On detecting XIRQ interrupt,
          LDAA SCSR+REGBASE assume receiver caused it.
          ANDA #RDRF
          BEQ SCISRV        otherwise program will hang up
*
RXSRV     EQU *             Talker code processes received data.
          LDAA SCDR+REGBASE Read command byte, & echo it as acknowledge
          BSR OUTSCI        to host.
          BMI INH1      If command bit 7 set, then process inherent command
          BSR INSCI     else read byte count from host into ACCB.(0=256)
          XGDX          Save command and byte count.
          BSR INSCI     Read high address byte
          TBA           into ACCA
          BSR INSCI     then low address byte into ACCB
          XGDX          Restore command in ACCA,count in ACCB,address in X
          CMPA #$01
          BNE RXSRV1    If command is memory read, then
*
TREADMEM  EQU *         REPEAT
          LDAA ,X       read required address
          BSR OUTSCI    send it to host
          TBA           (save byte count)
          BSR INSCI     and wait for acknowledge
          TAB           (restore byte count)
          INX           Increment address
          DECB          Decrement byte count
          BNE TREADMEM  UNTIL all done
          RTI           and return to idle loop or user code.
*
RXSRV1    EQU *
          CMPA #$41
          BNE RXSRVEX    If command is memory write then
*
          TBA           move byte count to ACCA
TWRITMEM  EQU *         REPEAT
          BSR INSCI     Read next byte from host into ACCB,
          STAB ,X       and store at required address.
          LDY #$0001    Set up wait loop to allow for 28C64 prog time, where
WAITPOLL  DEY           Y operand must be manually set to $0359 (3mS)
          BNE WAITPOLL
          LDAB ,X       Read stored byte and
          STAB SCDR+REGBASE   echo it back to host,
          INX
          DECA          Decrement byte count
          BNE TWRITMEM  UNTIL all done
RXSRVEX   EQU *         and return
NULLSRV   RTI
*
INSCI     EQU *
          LDAB SCSR+REGBASE   Wait for RDRF=1
          BITB #$A            IF break detected then
          BNE TALKSTART       restart
          ANDB #RDRF
          BEQ INSCI
          LDAB SCDR+REGBASE   then read data received from host
          RTS                 and return with data in ACCB
*
OUTSCI    EQU *               Only register Y modified.
          XGDY                Enter with data to send in ACCA.
OUTSCI1   LDAA SCSR+REGBASE
          BPL OUTSCI1         MS bit is TDRE flag
          XGDY
          STAA SCDR+REGBASE   Important - Updates CCR!
          RTS
*
INH1      EQU *
          CMPA #$81     If command is read MCU registers then
          BNE INH2
*
INH1A     TSX           Move stack pointer to X
          XGDX          then to ACCD
          BSR OUTSCI    send stack pointer to host (high byte first)
          TBA
          BSR OUTSCI    then low byte
          TSX           Restore X (=stack pointer)
          LDAB #9       then return 9 bytes on stack
          BRA TREADMEM  i.e. CCR,ACCB,ACCA,IXH,IXL,IYH,IYL,PCH,PCL
*
INH2      EQU *
          CMPA #$C1     If command is write MCU registers then
          BNE SWISRV1
*
          BSR INSCI     get stack pointer from host (High byte first)
          TBA
          BSR INSCI
          XGDX          Move to X reg
          TXS           and copy to stack pointer
          LDAA #9       Then put next 9 bytes from host on to stack
          BRA TWRITMEM
*
SWISRV    EQU *         Breakpoints generated by host-placed SWI instruction.
          LDAA #BRKCODE Force host to process breakpoints
          BSR OUTSCI    by sending it the break signal
SWIIDLE   BRA SWIIDLE   then wait for response from host. (Ibit=1,Xbit=0)
*
SWISRV1   EQU *
          CMPA #BRKACK  If host has acknowledged breakpoint state then
          BNE RXSRVEX
          TSX           move stack pointer to SWI stack frame and
          LDAB #9
          ABX
          TXS
          LDD 7,X       Send user code breakpoint return address to host
          BSR OUTSCI    (high byte first)
          TBA
          BSR OUTSCI    (low byte next)
          LDD #IDLE     force idle loop on return from breakpoint processing
          STD 7,X
          BRA INH1A     but first return all MCU registers to host
*
          org TALKVECT
          FDB SCISRV    SCI RX interrupt
          FDB NULLSRV   SPI
          FDB NULLSRV   Pulse Acc Input Edge
          FDB NULLSRV   Pulse Acc Overflow
          FDB NULLSRV   Timer Overflow
          FDB NULLSRV   TOC5
          FDB NULLSRV   TOC4
          FDB NULLSRV   TOC3
          FDB NULLSRV   TOC2
          FDB NULLSRV   TOC1
          FDB NULLSRV   TIC3
          FDB NULLSRV   TIC2
          FDB NULLSRV   TIC1
          FDB NULLSRV   Real Time Interrupt
          FDB NULLSRV   IRQ
          FDB SCISRV    XIRQ - connected to SCI RX pin.
          FDB NULLSRV   SWI (Changed by Break and Trace monitor cmds)
          FDB TALKSTART Illegal opcode trap
          FDB NULLSRV   COP Software fail (Unused)
          FDB NULLSRV   COP Clock Monitor fail (Reassigned by PCBUG11 RESET)
          FDB TALKSTART Reset
          END
 