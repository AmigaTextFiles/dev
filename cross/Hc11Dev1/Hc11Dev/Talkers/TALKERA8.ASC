*************************** TALKERA8.ASC 9/2/89 **************************
*   Written by R.Soja, Motorola, East Kilbride                           *
*   Motorola Copyright 1988                                              *
*   MCU resident, Interrupt driven Communication routines for 68HC11     *
*   monitor. Provides low level memory and stack read/write operations.  *
*                                                                        *
*   This talker DOES NOT use XIRQ
*   -----------------------------
*                                                                        *
*   Works with Host user interface program PCBUG11.EXE.                  *
* N.B. TALKERA8.ASC is designed to be downloaded through 68HC11A8 type   *
*      bootloader, and communicate with host through SCI.                *
*      This bootloader loads 256 bytes of user code before terminating.  *
*
* CONSTANTS
TALKBASE  equ $0000
BOOTVECT  equ $00C4       Start of bootstrap vector jump table.
STACK     equ $00EB
REGBASE   equ $1000
*
JSCI      equ $00C4
JXIRQ     equ $00F1
JSWI      equ $00F4
JILLOP    equ $00F7
JCOP      equ $00FA
uS500     equ 5000/35     500uS delay with DEY/BNE loop
JMPEXT    equ $7E         Mnemonic for jump extended instruction
BRKCODE   equ $4A         Break point signal code to host.
BRKACK    equ $B5         Break point acknowledge code from host.
*
* REGISTERS
BAUD      equ $2B
SCCR1     equ $2C
SCCR2     equ $2D
SCSR      equ $2E
SCDR      equ $2F
*
RDRF      equ $20
TDRE      equ $80
*
* PROGRAM
          org TALKBASE
TLKRSTART EQU *
          LDS #STACK
          LDX #REGBASE
          CLR SCCR1,X
          LDD #$302C
          STAA BAUD,X   Initialise SCI to 9600 baud, no parity
          STAB SCCR2,X  and enable SCI tx & rx.
          LDAA #$40     Enable STOP, and I bit interrupts, disable XIRQ.
          TAP
*
IDLE      JMP IDLE      Now hang around for SCI interrupt from host.
* A RESET from host changes above jump destination to start of user code.
*
SCISRV    EQU *             On detecting interrupt,
          LDAA SCSR+REGBASE assume receiver caused it.
          ANDA #RDRF
          BEQ SCISRV        otherwise program will hang up
*
RXSRV     EQU *             Talker code processes received data.
          LDAA SCDR+REGBASE Read command byte, & echo it as acknowledge
          BSR OUTSCI        to host.
          BMI INH1      If command bit 7 set, then process inherent command
          BSR INSCI     else read byte count from host into ACCB.(0=256)
          XGDX          Save command and byte count.
          BSR INSCI     Read high address byte
          TBA           into ACCA
          BSR INSCI     then low address byte into ACCB
          XGDX          Restore command in ACCA,count in ACCB,address in X
          CMPA #$01
          BNE RXSRV1    If command is memory read, then
*
TREADMEM  EQU *         REPEAT
          LDAA ,X       read required address
          BSR OUTSCI    send it to host
          TBA           (save byte count)
          BSR INSCI     and wait for acknowledge
          TAB           (restore byte count)
          INX           Increment address
          DECB          Decrement byte count
          BNE TREADMEM  UNTIL all done
          RTI           and return to idle loop or user code.
*
RXSRV1    EQU *
          CMPA #$41
          BNE RXSRVEX    If command is memory write then
*
          TBA           move byte count to ACCA
TWRITMEM  EQU *         REPEAT
          BSR INSCI     Read next byte from host into ACCB,
          STAB ,X       and store at required address.
          LDY #$0001    Set up wait loop to allow for 28C64 prog time, where
WAITPOLL  DEY           Y operand must be manually set to $0359 (3mS)
          BNE WAITPOLL
          LDAB ,X       Read stored byte and
          STAB SCDR+REGBASE   echo it back to host,
          INX
          DECA          Decrement byte count
          BNE TWRITMEM  UNTIL all done
RXSRVEX   EQU *         and return
NULLSRV   RTI
*
INSCI     EQU *
          LDAB SCSR+REGBASE   Wait for RDRF=1
          BITB #$0A           If break detected then
          BNE TLKRSTART       restart talker
          ANDB #RDRF
          BEQ INSCI
          LDAB SCDR+REGBASE   then read data received from host
          RTS                 and return with data in ACCB
*
OUTSCI    EQU *               Only register Y modified.
          XGDY                Enter with data to send in ACCA.
OUTSCI1   LDAA SCSR+REGBASE
          BPL OUTSCI1         MS bit is TDRE flag
          XGDY
          STAA SCDR+REGBASE   Important - Updates CCR!
          RTS
*
INH1      EQU *
          CMPA #$81     If command is read MCU registers then
          BNE INH2
*
INH1A     TSX           Move stack pointer to X
          XGDX          then to ACCD
          BSR OUTSCI    send stack pointer to host (high byte first)
          TBA
          BSR OUTSCI    then low byte
          TSX           Restore X (=stack pointer)
          LDAB #9       then return 9 bytes on stack
          BRA TREADMEM  i.e. CCR,ACCB,ACCA,IXH,IXL,IYH,IYL,PCH,PCL
*
INH2      EQU *
          CMPA #$C1     If command is write MCU registers then
          BNE SWISRV1
*
          BSR INSCI     get stack pointer from host (High byte first)
          TBA
          BSR INSCI
          XGDX          Move to X reg
          TXS           and copy to stack pointer
          LDAA #9       Then put next 9 bytes from host on to stack
          BRA TWRITMEM
*
SWISRV    EQU *         Breakpoints generated by host-placed SWI instruction.
          LDAA #BRKCODE Force host to process breakpoints
          BSR OUTSCI    by sending it the break signal
SWIIDLE   CLI
          BRA SWIIDLE   Wait for response from host. (Ibit=0,Xbit=1)
*
SWISRV1   EQU *
          CMPA #BRKACK  If host has acknowledged breakpoint state then
          BNE RXSRVEX
          TSX           move stack pointer to SWI stack frame and
          LDAB #9
          ABX
          TXS
          LDD 7,X       Send user code breakpoint return address to host
          BSR OUTSCI    (high byte first)
          TBA
          BSR OUTSCI    (low byte next)
          LDD #IDLE     force idle loop on return from breakpoint processing
          STD 7,X
          BRA INH1A     but first return all MCU registers to host
*
          ORG BOOTVECT  Boot vector jump table set up only during bootstrap.
          FCB JMPEXT    SCI
          FDB SCISRV
          FCB JMPEXT    SPI  (Unused vectors point to RTI)
          FDB NULLSRV
          FCB JMPEXT    Pulse acc. Input Edge
          FDB NULLSRV
          FCB JMPEXT    Pulse acc. Overflow
          FDB NULLSRV
          FCB JMPEXT    Timer Overflow
          FDB NULLSRV
          FCB JMPEXT    OC5
          FDB NULLSRV
          FCB JMPEXT    OC4
          FDB NULLSRV
          FCB JMPEXT    OC3
          FDB NULLSRV
          FCB JMPEXT    OC2
          FDB NULLSRV
          FCB JMPEXT    OC1
          FDB NULLSRV
          FCB JMPEXT    IC3
          FDB NULLSRV
          FCB JMPEXT    IC2
          FDB NULLSRV
          FCB JMPEXT    IC1
          FDB NULLSRV
          FCB JMPEXT    Real Time Intr
          FDB NULLSRV
          FCB JMPEXT    IRQ
          FDB NULLSRV
          FCB JMPEXT    XIRQ   SCI RX line must be connected to XIRQ input.
          FDB NULLSRV
          FCB JMPEXT    SWI    N.B. Changed by monitor Break point and Trace !
          FDB NULLSRV
          FCB JMPEXT    ILLOP
          FDB TLKRSTART
          FCB JMPEXT    COP Fail
          FDB NULLSRV
          FCB JMPEXT    Clock Monitor N.B. Changed by monitor Reset operation !
          FDB NULLSRV
*
          END
 