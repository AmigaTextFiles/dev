/****h* Z80SimGTGUI.c/main() [2.5] ****************************
* 
*  NAME
*    Z80Simulator - a program to simulate the Z80 processor.
*                   This program is a GadTools-based GUI for
*                   the Z80.  This program can be run from 
*                   either the CLI or its WorkBench icon.
*
*  SYNOPSIS
*    Z80Simulator [Z80.cfg]
*
*  FUNCTION
*    Simulates a Z80 processor with a state machine and 
*    graphical display.
*
*  INPUTS
*    z80.cfg - a configuration file that contains initial register
*              values, memory values & breakpoints.
*
*  RETURN VALUE
*    RETURN_OK for success, various other error values to 
*    indicate various failures.
*
*  OTHER VISIBLE FUNCTIONS:
*
*    VISIBLE void FreeupData( void );
*    VISIBLE void Update_Regs( UWORD program_counter );
*    VISIBLE void CloseDownScreen( void );
*    VISIBLE int  Z80SimCloseWindow( void );
*    VISIBLE void CloseLibs( void );
*
*
*  TOOLTYPES
*    ConfigFile - the name of the configuration file to 
*                 initialize the program with (default: Z80.cfg).
*    Editor     - The name of the text editor to use on Z80-
*                 source code (default: SC:C/SE).
*    Translator - The name of the Intel to configuration 
*                 file translator (default: Z80XLate).
*    Assembler  - The name of the Source to Intel-format 
*                 Z80 assembler (default: Z80Asm).
*    Macro      - The name of the Macro expander (in case 
*                 the assembler doesn't do macros, default: Macro).
*
*  HISTORY
*    17-Apr-2001 - Added version string & vanilla key support to
*                  all requesters.
*
*    04/17/98 - Modified entire project to use
*               GadTools library for the GUI.
*    02/08/95 - Added Editor, Translator, Macro, 
*               Assembler & ConfigFile string variables.
*    02/08/95 - Added ProcessToolTypes() for
*               WorkBench support.
*    03/03/94 - added assign_all() to main().
*               12/25/90
*
*  NOTES
*    Source machine generated by GadToolsBox V2.0b
*    which is (c) Copyright 1991-1993 Jaba Development
*
*    GUI Designed by : Jim Steichen
*
*    $VER: Z80SimGTGUI.c 2.5 (17-Apr-2001) by J.T. Steichen
***************************************************************
*/

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#include <exec/types.h>
#include <exec/memory.h>

#include <MyFunctions.h>
#include <AmigaDOSErrs.h>

#include <intuition/intuitionbase.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>

#include <workbench/workbench.h>
#include <workbench/startup.h>
#include <workbench/icon.h>

#include <dos/dos.h>
#include <dos/dosextens.h>

#include <libraries/gadtools.h>
#include <libraries/asl.h>

#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <clib/asl_protos.h>

#include "CPGM:GlobalObjects/CommonFuncs.h"


#include "Z80Sim.h"
#include "Z80SimGTGUI.h"
#include "Z80GUIFuncProtos.h"

#define   ALLOCATE    1
# include "Z80Vars.h"
# include "FileReqTags.h"
#undef    ALLOCATE 

#include "Z80FuncProtos.h"

IMPORT struct WBStartup *_WBenchMsg; // From LIB:c.o

/* ------------------- Console stuff: ------------------------------- */

//IMPORT struct MsgPort  *CreatePort();
//IMPORT struct IOStdReq *CreateStdIO();

IMPORT struct Console  *AttachConsole( struct Window *window, char *name );


/* GGGGGGGGGGGGGGGGGGGG Global Variables: GGGGGGGGGGGGGGGGGGGGGGGGGGG */

VISIBLE struct IntuitionBase *IntuitionBase;
VISIBLE struct GfxBase       *GfxBase;
VISIBLE struct Library       *GadToolsBase = NULL;
VISIBLE struct Library       *IconBase     = NULL;

VISIBLE struct TextAttr topaz8 = { (STRPTR) "topaz.font", 8, 0x00, 0x01 };

VISIBLE struct Screen  *Scr  = NULL;

VISIBLE APTR   VisualInfo    = NULL;
VISIBLE UBYTE *PubScreenName = "Workbench";
VISIBLE UBYTE *ScrTitle      = "Z80Simulator ©1998-2001 by J.T. Steichen";

VISIBLE UBYTE *version       = "2.5";

/* For PrintListing, Load, SaveAs & Translation Requesters: */

VISIBLE char            InFileName[256], OutFileName[256];

VISIBLE UBYTE PathName[256]    = "RAM:";
VISIBLE UBYTE ProgramName[256] = "";

/* ---- For all Requesters that need to return an address range:   */

VISIBLE unsigned short FromAddress = 0;
VISIBLE unsigned short ToAddress   = 0;

/* ------------------- For the FillMem Requester: ----------------- */

VISIBLE char           PS[256], *PatternStr = &PS[0];

/* ---------------------- Z80 memory space: ----------------------- */

VISIBLE UBYTE             *mem = NULL;

VISIBLE UWORD temp_PC = 0;   /* Used only by Execute_Instruction,
                             ** decode_mach & Misc_Inst() 
                             */

/* ---- Objects used by OutputCode.c file: ------------------------ */

VISIBLE struct Window *Z80SimWnd   = NULL;
VISIBLE struct Gadget *Z80SimGadgets[ 27 ];

VISIBLE struct List    SCList;
VISIBLE struct Node    SCListItems[ SCMAXITEM ];
VISIBLE char          *SCItemBuffer = NULL;

VISIBLE char           CurrentConfigFileName[256];

/* GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG */

PRIVATE char v[] = "\0$VER: Z80Simulator 2.5 (21-Apr-2001) by J.T. Steichen\0";

/* TTTTTTTTT ToolType support Added on 02/08/95: TTTTTTTTTTTTTTTTTT */

PRIVATE char tt1[256], tt2[256], tt3[256], tt4[256], tt5[256];

VISIBLE char *Editor     = &tt1[0], *Translator = &tt2[0];
VISIBLE char *ConfigFile = &tt4[0];

PRIVATE char *Assembler  = &tt3[0];
PRIVATE char *Macro      = &tt5[0];

/* TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT */

PRIVATE struct DiskObject  *diskobj;
PRIVATE char               DEFAULT_FILE[] = "Z80.cfg";

PRIVATE struct Gadget       *Z80SimGList = NULL;
PRIVATE struct Menu         *Z80SimMenus = NULL;
PRIVATE struct IntuiMessage  Z80SimMsg;

PRIVATE UWORD  Z80SimLeft   = 95;
PRIVATE UWORD  Z80SimTop    = 16;
PRIVATE UWORD  Z80SimWidth  = 450;
PRIVATE UWORD  Z80SimHeight = 408;
PRIVATE UBYTE *Z80SimWdt    = (UBYTE *) "Z80Simulator ©1998-2001 by J.T. Steichen";


PRIVATE struct IntuiText Z80SimIText[] = {

   2, 0, JAM1, 116, 2,  &topaz8, (UBYTE *) "Z80 Register Contents:", 
      &Z80SimIText[1],

   2, 0, JAM1, 117, 17, &topaz8, (UBYTE *) "SZ-H -PNC", &Z80SimIText[2],
   2, 0, JAM1, 332, 17, &topaz8, (UBYTE *) "SZ-H -PNC", NULL
};

/* --------------------------------------------------------------- */

IMPORT int Z80SimEditFileMI( void );

PRIVATE struct NewMenu Z80SimNewMenu[] = {

   /* --------------------------------------------------------------- */
   NM_TITLE, (STRPTR) "PROJECT",   NULL,      0, NULL, NULL,
    NM_ITEM, (STRPTR) "Load..",    (STRPTR) "L", 0, 0L, 
             (APTR) Z80SimLoadMI,
    
    NM_ITEM, (STRPTR) "Save",      (STRPTR) "S", 0, 0L, 
             (APTR) Z80SimSaveMI,
    
    NM_ITEM, (STRPTR) "Save As..", (STRPTR) "A", 0, 0L, 
             (APTR) Z80SimSaveAsMI,

    NM_ITEM, (STRPTR) NM_BARLABEL,         NULL, 0, 0L, NULL,
    NM_ITEM, (STRPTR) "About..",           NULL, 0, 0L, 
             (APTR) Z80SimAboutMI,
    
    NM_ITEM, (STRPTR) "Quit",      (STRPTR) "Q", 0, 0L, 
             (APTR) Z80SimQuitMI,
   
   /* --------------------------------------------------------------- */
   NM_TITLE, (STRPTR) "COMMANDS",                   NULL, 0, NULL, NULL,
    NM_ITEM, (STRPTR) "Translate..",                NULL, 0, 0L, 
             (APTR) Z80SimTranslateMI,
    
    NM_ITEM, (STRPTR) "Edit...",            (STRPTR) "E", 0, 0L, 
             (APTR) Z80SimEditFileMI,
    
    NM_ITEM, (STRPTR) "Macro..",                    NULL, 0, 0L, 
             (APTR) Z80SimMacroMI,
    
    NM_ITEM, (STRPTR) "Assemble..",                 NULL, 0, 0L, 
             (APTR) Z80SimAssembleMI,
    
    NM_ITEM, (STRPTR) "Print Listing..",    (STRPTR) "W", 0, 0L, 
             (APTR) Z80SimPrtListMI,
    
    NM_ITEM, (STRPTR) "Find Current Inst'",         NULL, 0, 0L, 
             (APTR) Z80SimFindCurrentMI,
   
    NM_ITEM, (STRPTR) "Set Register Value..",       NULL, 0, 0L, 
             (APTR) Z80SimSetRegisterMI,
   
   /* --------------------------------------------------------------- */
   NM_TITLE, (STRPTR) "MEMORY",        NULL, 0, NULL, NULL,
    NM_ITEM, (STRPTR) "Dump",  (STRPTR) "D", 0, 0L, (APTR) Z80SimDumpMI,
    NM_ITEM, (STRPTR) "Fill",  (STRPTR) "F", 0, 0L, (APTR) Z80SimFillMI,
    NM_ITEM, (STRPTR) "Stack", (STRPTR) "K", 0, 0L, (APTR) Z80SimStackMI,
   
   /* --------------------------------------------------------------- */
   NM_TITLE, (STRPTR) "RUN",              NULL, 0, NULL, NULL,
    NM_ITEM, (STRPTR) "Step",     (STRPTR) "T", 0, 0L, (APTR) Z80SimStepMI,
    NM_ITEM, (STRPTR) "Restart",  (STRPTR) "R", 0, 0L, 
             (APTR) Z80SimRestartMI,
    
    NM_ITEM, (STRPTR) "NMI'",     (STRPTR) "N", 0, 0L, (APTR) Z80SimNMI_MI,
    NM_ITEM, (STRPTR) "INT'",     (STRPTR) "I", 0, 0L, (APTR) Z80SimInt_MI,
    NM_ITEM, (STRPTR) "Go!..",    (STRPTR) "G", 0, 0L, (APTR) Z80SimGoMI,
    NM_ITEM, (STRPTR) "Set PC..", (STRPTR) "P", 0, 0L, 
             (APTR) Z80SimSetPC_MI,
   
   /* --------------------------------------------------------------- */
   NM_TITLE, (STRPTR) "BREAKS",                NULL, 0, NULL, NULL,
    NM_ITEM, (STRPTR) "Set BreakPt..", (STRPTR) "B", 0, 0L, 
             (APTR) Z80SimSetBreakMI,
    
    NM_ITEM, (STRPTR) "Clear BreakPt", (STRPTR) "C", 0, 0L, 
             (APTR) Z80SimClearBreakMI,
    
    NM_ITEM, (STRPTR) "Show BreakPts..",       NULL, 0, 0L, 
             (APTR) Z80SimShowBreaksMI,
   
   NM_END, NULL, NULL, 0, 0L, NULL
};

/* --------------------------------------------------------------- */

PRIVATE UWORD Z80SimGTypes[] = {

   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, TEXT_KIND,     TEXT_KIND, TEXT_KIND,
   TEXT_KIND, LISTVIEW_KIND, TEXT_KIND
};

/* --------------------------------------------------------------- */

PRIVATE struct NewGadget Z80SimNGad[] = {

   26,  28,   81, 14, (UBYTE *) "A",  NULL, A, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   244, 28,   81, 14, (UBYTE *) "A'", NULL, A + 1, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   26,  46,   81, 14, (UBYTE *) "B",  NULL, B, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   244, 46,   81, 14, (UBYTE *) "B'", NULL, B + 1, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   113, 46,   81, 14, (UBYTE *) "C",  NULL, C, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   328, 46,   81, 14, (UBYTE *) "C'", NULL, C + 1, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   26,  64,   81, 14, (UBYTE *) "D",  NULL, D, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   244, 64,   81, 14, (UBYTE *) "D'", NULL, D + 1, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   113, 64,   81, 14, (UBYTE *) "E",  NULL, E, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   328, 64,   81, 14, (UBYTE *) "E'", NULL, E + 1, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   26,  82,   81, 14, (UBYTE *) "H",  NULL, H, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   244, 82,   81, 14, (UBYTE *) "H'", NULL, H + 1, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   113, 82,   81, 14, (UBYTE *) "L",  NULL, L, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   328, 82,   81, 14, (UBYTE *) "L'", NULL, L + 1, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   113, 28,   81, 14, (UBYTE *) "F",  NULL, F, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   328, 28,   81, 14, (UBYTE *) "F'", NULL, F + 1, 
   PLACETEXT_RIGHT, NULL, NULL,
   
   244, 100,  81, 14, (UBYTE *)  "I", NULL, I,    
   PLACETEXT_LEFT,  NULL, NULL,
   
   328, 100,  81, 14, (UBYTE *)  "R", NULL, R,    
   PLACETEXT_RIGHT, NULL, NULL,
   
   33, 129,  161, 14, (UBYTE *) "PC", NULL, R + 1,   
   PLACETEXT_LEFT,  NULL, NULL,

   33, 111,  161, 14, (UBYTE *) "SP", NULL, R + 2,   
   PLACETEXT_LEFT,  NULL, NULL,
   
   248, 118, 161, 14, (UBYTE *) "IX", NULL, R + 3,   
   PLACETEXT_LEFT,  NULL, NULL,
   
   248, 135, 161, 14, (UBYTE *) "IY", NULL, R + 4,   
   PLACETEXT_LEFT,  NULL, NULL,

   281, 153,  21, 14, (UBYTE *) "IFF1", NULL, R + 5, 
   PLACETEXT_LEFT,  NULL, NULL,
   
   308, 153,  21, 14, (UBYTE *) "IFF2", NULL, R + 6, 
   PLACETEXT_RIGHT, NULL, NULL,

   73, 149,   71, 14, (UBYTE *) "STATUS:", NULL, R + 7, 
   PLACETEXT_LEFT,  NULL, NULL,

   4, 190,  430, 190, (UBYTE *) "Source Code:",   NULL, 
   R + 8, PLACETEXT_ABOVE | NG_HIGHLABEL, NULL, 
   (APTR) SrcCodeListViewClicked,
   
   126, 385, 310,  14, (UBYTE *) "Current Inst':", NULL, 
   R + 9, PLACETEXT_LEFT, NULL, NULL
};

/* --------------------------------------------------------------- */

PRIVATE ULONG Z80SimGTags[] = {

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE, 
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE, 
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE, 
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,
   
   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,
   
   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000", GTTX_Border,   TRUE,
                                   GTTX_FrontPen,    2, TAG_DONE,
   
   GTTX_Text, (ULONG) "0000 0000 0000 0000", 
   GTTX_FrontPen, 2,
   GTTX_Border,   TRUE, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000 0000 0000", 
   GTTX_FrontPen, 2,
   GTTX_Border,   TRUE, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000 0000 0000", 
   GTTX_FrontPen, 2,
   GTTX_Border,   TRUE, TAG_DONE,

   GTTX_Text, (ULONG) "0000 0000 0000 0000", 
   GTTX_FrontPen, 2,
   GTTX_Border,   TRUE, TAG_DONE,

   GTTX_Text, (ULONG) "1", GTTX_Border, TRUE, TAG_DONE,
   GTTX_Text, (ULONG) "0", GTTX_Border, TRUE, TAG_DONE,

   GTTX_Text, (ULONG) "WAITING", GTTX_Border, TRUE, 
   GTTX_FrontPen, 1, TAG_DONE,

   LAYOUTA_Spacing, 2, //GTLV_ReadOnly, TRUE,
   GTLV_ItemHeight,   12,   GTLV_Selected, 0, GTLV_ShowSelected, NULL,
   TAG_DONE,

   GTTX_Border, TRUE, GTTX_FrontPen, 3, TAG_DONE
};

// ------------ Functions: ---------------------------------------------

/****h* PathValid() ****************************************************
*
* NAME
*    PathValid()
*
* DESCRIPTION
*    Try & obtain a lock on a path to see if it exists.  Return results.
************************************************************************
*
*/

PUBLIC BOOL PathValid( UBYTE *path )
{
   BOOL rval = FALSE;

   BPTR lock = Lock( path, ACCESS_READ );

   if (lock == NULL)
      return( rval );
   else
      {
      rval = TRUE;
      UnLock( lock );
      }      

   return( rval );
}

/****i* Z80SimGTGUI.c/IntFlags() [2.0] ***************************** 
*
* NAME 
*   IntFlags - Update the Graphical representation of the Z80
*              Interrupt flag registers 'IFF1' & 'IFF2'.
*
* SYNOPSIS
*   void IntFlags( void )
*
* FUNCTION
*   Determine from IFF1_2 which Interrupt flags need to be asserted
*   or unasserted, then update the Text Gadgets.
*
********************************************************************
*/

PRIVATE void IntFlags( void )
{
   if ((IFF1_2 & IFF1) == IFF1)  
      GT_SetGadgetAttrs( Z80SimGadgets[ IFF1Reg ], Z80SimWnd, NULL,
                         GTTX_FrontPen, 3,
                         GTTX_Text,     (STRPTR) "1",
                         TAG_END
                       );
   else                          
      GT_SetGadgetAttrs( Z80SimGadgets[ IFF1Reg ], Z80SimWnd, NULL,
                         GTTX_Text, (STRPTR) "0",
                         TAG_END
                       );

   if ((IFF1_2 & IFF2) == IFF2)  
      GT_SetGadgetAttrs( Z80SimGadgets[ IFF2Reg ], Z80SimWnd, NULL,
                         GTTX_FrontPen, 3,
                         GTTX_Text,     (STRPTR) "1",
                         TAG_END
                       );
   else                          
      GT_SetGadgetAttrs( Z80SimGadgets[ IFF2Reg ], Z80SimWnd, NULL,
                         GTTX_Text, (STRPTR) "0",
                         TAG_END
                       );
   return;
}

/****i* Z80SimGTGUI.c/Display_Status() [2.0] ************************ 
*
* NAME 
*   Display_Status - Update the Graphical representation of the Z80
*                    Status Text Gadget.
*
* SYNOPSIS
*   void Display_Status( void )
*
* FUNCTION
*   take the current integer value of status & convert it into the
*   correct status string to display.
*
*********************************************************************
*/

VISIBLE void  Display_Status( void )
{
   switch( status )  
      {
      case RUNNING:  
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 2,
                            GTTX_Text, (STRPTR) "RUNNING",
                            TAG_END
                          );
         break;
      case HALT:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 3,
                            GTTX_Text, (STRPTR) "HALT",
                            TAG_END
                          );
         break;
      case RESET:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_Text, (STRPTR) "RESET",
                            TAG_END
                          );
         break;
      case NMI:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_Text, (STRPTR) "NMI",
                            TAG_END
                          );
         break;
      case INT:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_Text, (STRPTR) "INT",
                            TAG_END
                          );
         break;
      case ILLGL:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 3,
                            GTTX_BackPen,  1,
                            GTTX_Text, (STRPTR) "ILLEGAL",
                            TAG_END
                          );
         break;
      default:
         GT_SetGadgetAttrs( Z80SimGadgets[ ProcStatus ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 2,
                            GTTX_Text, (STRPTR) "RUNNING",
                            TAG_END
                          );
         break;
      }
   return;
}

/****i* Z80SimGTGUI.c/Misc_Regs() [2.0] ***************************** 
*
* NAME 
*   Misc_Regs - Update the Graphical representation of the Z80
*               'I' & 'R' registers.
*
* SYNOPSIS
*   void Misc_Regs( void )
*
* FUNCTION
*   take the current values of reg[] & convert them to
*   binary strings.  Next, send them to the correct GUI Text
*   gadgets.
*
*********************************************************************
*/

PRIVATE void  Misc_Regs( void )
{
   int  i;
   char *sglstr;

   for (i = 0; i < 2; i++)  
      {
      sglstr = &strreg[i + I][0];
      to_binstr( reg[i + I], sglstr, 8 );
      (void) insert_string( sglstr, " ", 4 );

      if (sregchanged[ i + I] == TRUE)
         GT_SetGadgetAttrs( Z80SimGadgets[ I + i ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 3,
                            GTTX_Text, (STRPTR) sglstr,
                            TAG_END
                          );
      else 
         GT_SetGadgetAttrs( Z80SimGadgets[ I + i ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 1,
                            GTTX_Text, (STRPTR) sglstr,
                            TAG_END
                          );
      }

   return;
}

/****i* Z80SimGTGUI.c/Update_Regs() [2.0] *************************** 
*
* NAME 
*   Update_Regs - Update the Graphical representation of the Z80
*                 registers.
*
* SYNOPSIS
*   void Update_Regs( UWORD program_counter )
*
* FUNCTION
*   take the current values of reg[] & dreg[] & convert them to
*   binary strings.  Next, send them to the correct GUI Text
*   gadgets.  Finally, update the status Text Gadget.
*
* INPUTS
*   'program_counter' - the current program counter value of the 
*                       Z80 simulated processor.
*
*********************************************************************
*/

VISIBLE void  Update_Regs( UWORD program_counter )
{
   int  i;
   char *sglstr, *dblstr;

                             // single registers:
   for (i = 0; i < I; i++)  
      {
      sglstr = &strreg[i][0];
      to_binstr( reg[i], sglstr, 8 );
      (void) insert_string( sglstr, " ", 4 );

      if (sregchanged[i] == TRUE)
         GT_SetGadgetAttrs( Z80SimGadgets[ i ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 3,
                            GTTX_Text, (STRPTR) sglstr,
                            TAG_END
                          );
      else
         GT_SetGadgetAttrs( Z80SimGadgets[ i ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 1,
                            GTTX_Text, (STRPTR) sglstr,
                            TAG_END
                          );
      }
                             // take care of Program Counter:
   dblstr = &strdreg[0][0];
   to_binstr( program_counter, dblstr, 16 );
   (void) insert_string( dblstr, " ", 4 );
   (void) insert_string( dblstr, " ", 9 );
   (void) insert_string( dblstr, " ", 14 );

   if (dregchanged[PC] == TRUE)
      GT_SetGadgetAttrs( Z80SimGadgets[ PCReg ], Z80SimWnd, NULL,
                         GTTX_FrontPen, 3,
                         GTTX_Text,     (STRPTR) dblstr,
                         TAG_END
                       );
   else
      GT_SetGadgetAttrs( Z80SimGadgets[ PCReg ], Z80SimWnd, NULL,
                         GTTX_FrontPen, 1,
                         GTTX_Text,     (STRPTR) dblstr,
                         TAG_END
                       );
                             // rest of double registers:
   for (i = SP; i <= IY; i++)  
      {
      dblstr = &strdreg[ i ][0];
      to_binstr( dreg[ i ], dblstr, 16 );

      (void) insert_string( dblstr, " ", 4 );
      (void) insert_string( dblstr, " ", 9 );
      (void) insert_string( dblstr, " ", 14 );

      if (dregchanged[i + PCReg] == TRUE)
         GT_SetGadgetAttrs( Z80SimGadgets[ i + PCReg ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 3,
                            GTTX_Text, (STRPTR) dblstr,
                            TAG_END
                          );
      else
         GT_SetGadgetAttrs( Z80SimGadgets[ i + PCReg ], Z80SimWnd, NULL,
                            GTTX_FrontPen, 1,
                            GTTX_Text, (STRPTR) dblstr,
                            TAG_END
                          );
      }

   Misc_Regs();      /* Update the I & R registers.         */
   IntFlags();       /* Update the IFF flag registers.      */
   Display_Status(); /* Update the processor status string. */

   return;
}

/****i* Z80SimGTGUI.c/get_byte() [1.0] ****************************** 
*
* NAME 
*   get_byte - is part of the configuration file reader.
*
* SYNOPSIS
*   ByteValue = get_byte( char *buffer )
*
* FUNCTION
*   convert the first two characters in buffer to an 8-bit (UBYTE)
*   value.
*
* INPUTS
*   'str' - the character string read in from the configuration file.
*
* RESULT
*   the 8-bit equivalent value of the first two characters.
*
* NOTES
*   str will be shortened by two char's: 
*********************************************************************
*/

PRIVATE UBYTE get_byte( char *str )
{
   UBYTE    temp;
   char     *nxt;

   nxt = str;

   if (Is_Digit( *nxt ))
      temp = (*nxt - '0') * 16;
   else if (Is_Hex( *nxt ))
      temp = (*nxt - 'A' + 10) * 16;

   nxt++;

   if (Is_Digit( *nxt ))
      temp = temp + (*nxt - '0');
   else if (Is_Hex( *nxt ))
      temp = temp + (*nxt - 'A' + 10);

   (void) remove_substring( str, 0, 2 );

   return( temp );
}

/****i* Z80SimGTGUI.c/assign_reg() [1.0] ****************************** 
*
* NAME 
*   assign_reg - is part of the configuration file reader.
*
* SYNOPSIS
*   void assign_reg( char *buffer, int register_number )
*
* FUNCTION
*   Remove the Register designator string from the buffer, then
*   convert the next two characters in the buffer to an 8-bit (UBYTE)
*   value, using get_byte().
*
* INPUTS
*   'buffer' - the character string read in from the configuration file.
*   'regnum' - the reg[] array index equivalent to the
*              Z80 register number 
*
* NOTES
*   'buffer' will be shortened by two char's for the 8-bit value for
*   the register as well as the Register designator string 
*   (ex: 'A: ') 
***********************************************************************
*/

PRIVATE void  assign_reg( char *buffer, int regnum )
{
   int i = char_index( buffer, ':' );

   (void) remove_substring( buffer, 0, i + 1 );

   reg[ regnum ] = get_byte( buffer );

   return;
}

/****i* Z80SimGTGUI.c/assign_dreg() [1.0] ****************************** 
*
* NAME 
*   assign_dreg - is part of the configuration file reader.
*
* SYNOPSIS
*   void assign_dreg( char *buffer, int Dregister_number )
*
* FUNCTION
*   Remove the Register designator string from the buffer, then
*   convert the next four characters in the buffer to a 16-bit (UWORD)
*   value, using get_byte().
*
* INPUTS
*   'buffer'  - the character string read in from the configuration file.
*   'dregnum' - the reg[] array index equivalent to the
*               16-bit Z80 register number. 
*
* NOTES
*   'buffer' will be shortened by four char's for the 16-bit value for
*   the register as well as the Register designator string 
*   (ex: 'SP: ')
************************************************************************
*/

PRIVATE void  assign_dreg( char *buffer, UWORD dregnum )
{
   int i = char_index( buffer, ':' );

   (void) remove_substring( buffer, 0, i + 1 );

   dreg[ dregnum ] = 256 * (UWORD) get_byte( buffer );

   dreg[ dregnum ] = dreg[ dregnum ] + (UWORD) get_byte( buffer );

   return;
}

/****i* Z80SimGTGUI.c/assign_all() [1.0] **************************** 
*
* NAME 
*   assign_all - is part of the configuration file reader.
*
* SYNOPSIS
*   void assign_all( char *buffer )
*
* FUNCTION
*   Convert the configuration information in buffer to Z80 register
*   binary strings.
*
* INPUTS
*   'buffer'  - the character string read in from the config file.
*
* NOTES
*   assign_all() calls assign_reg() & assign_dreg().
*********************************************************************
*/

PRIVATE void assign_all( char *buffer )
{
   assign_reg( buffer, A );    assign_reg( buffer, F );
   assign_reg( buffer, A+1 );  assign_reg( buffer, F+1 );
   assign_reg( buffer, B );    assign_reg( buffer, C );
   assign_reg( buffer, B+1 );  assign_reg( buffer, C+1 );
   assign_reg( buffer, D );    assign_reg( buffer, E );
   assign_reg( buffer, D+1 );  assign_reg( buffer, E+1 );
   assign_reg( buffer, H );    assign_reg( buffer, L );
   assign_reg( buffer, H+1 );  assign_reg( buffer, L+1 );
   assign_reg( buffer, I );    assign_reg( buffer, R );

   assign_dreg( buffer, PC );  assign_dreg( buffer, SP );
   assign_dreg( buffer, IX );  assign_dreg( buffer, IY );

   return;
}


/****i* Z80SimGTGUI.c/Make_Byte() [1.0] ***************************** 
*
* NAME 
*   Make_Byte - is part of the configuration file reader.
*
* SYNOPSIS
*   Z80Address = Make_Byte( char *buffer, UWORD address )
*
* FUNCTION
*   Get a byte from the buffer & place it at the address.
*
* INPUTS
*   'buffer'  - the character string read in from the config file.
*   'address' - starting address of the Z80 memory space. 
*
* NOTES
*   see get_byte() note.
*********************************************************************
*/

PRIVATE UWORD Make_Byte( char *bytestr, UWORD addr )
{
   static UWORD address;
   
   address        = addr;
   mem[ address ] = get_byte( bytestr );

   numbytes++;  
   address++;

   return( address );
}

/****i* Z80SimGTGUI.c/Init_Mem() [1.0] ****************************** 
*
* NAME 
*   Init_Mem - Place 0x76 (HALT) opcode into all Z80 memory spaces.
*
* SYNOPSIS
*   void Init_Mem( void )
*
* FUNCTION
*   Initialize all Z80 memory locations to 0x76 (HALT) opcode.
*
*********************************************************************
*/

PRIVATE void Init_Mem( void )
{
   int      i;
   UBYTE    z80byte = 0x76;     /* HALT opcode!! */

   for (i = 0; i < MAXADDR; i++)
      mem[ i ] = z80byte;

   return;
}

/****i* Z80SimGTGUI.c/CloseDownScreen() [2.0] *********************** 
*
* NAME 
*   CloseDownScreen - Get rid of screen-related data.
*
* SYNOPSIS
*   void CloseDownScreen( void )
*
* FUNCTION
*   Free the VisualInfo (for GadTools) & Unlock the Public Screen
*   (Workbench).
*
* NOTES
*   This function is also called by cleanup() in Z80Loader.c,
*   this is why this function is NOT PRIVATE.
*
*********************************************************************
*/

VISIBLE void CloseDownScreen( void )
{
   if (VisualInfo != NULL)
      {
      FreeVisualInfo( VisualInfo );
      VisualInfo = NULL;
      }

   if (Scr != NULL)
      {
      UnlockPubScreen( NULL, Scr );
      Scr = NULL;
      }

   return;
}

/****i* Z80SimGTGUI.c/Z80SimRender() [2.0] ************************** 
*
* NAME 
*   Z80SimRender - Draw bevel boxes & draw IText.
*
* SYNOPSIS
*   void Z80SimRender( void )
*
* FUNCTION
*   Draw bevel boxes around the Z80 registers & add the 
*   Flag register IText & display info IText.
*
*********************************************************************
*/

PRIVATE void Z80SimRender( void )
{
   UWORD offx, offy;

   offx = Z80SimWnd->BorderLeft;
   offy = Z80SimWnd->BorderTop;


   DrawBevelBox( Z80SimWnd->RPort, offx + 217, offy + 12, 
                 218, 160, GT_VisualInfo, VisualInfo, TAG_DONE 
               );

   DrawBevelBox( Z80SimWnd->RPort, offx + 2, offy + 12, 
                 213, 160, GT_VisualInfo, VisualInfo, TAG_DONE 
               );

   PrintIText( Z80SimWnd->RPort, Z80SimIText, offx, offy );

   return;
}

/****i* Z80SimGTGUI.c/SrcCodeListViewClicked() [2.0] **************** 
*
* NAME 
*   SrcCodeListViewClicked -
*
* SYNOPSIS
*   continue = SrcCodeListViewClicked( void )
*
* FUNCTION
*   This function should only highlight whatever line the user
*   clicked on.
*
* RETURN VALUE
*   TRUE
*
*********************************************************************
*/

PRIVATE int SrcCodeListViewClicked( void )
{
   /* routine when gadget "Source Code:" is clicked. */
   return( (int) TRUE );
}


/****i* Z80SimGTGUI.c/CloseZ80SimWindow() [2.0] ********************* 
*
* NAME 
*   CloseZ80SimWindow - Close the main GUI window.
*
* SYNOPSIS
*   void CloseZ80SimWindow( void )
*
* FUNCTION
*   Clear & Free the MenuStrip, close the Z80SimWindow, then
*   Free the Gadgets (Z80SimGList).
*
* SEE ALSO 
*   Z80SimCloseWindow()
*********************************************************************
*/

PRIVATE void CloseZ80SimWindow( void )
{
   if (Z80SimMenus != NULL)
      {
      ClearMenuStrip( Z80SimWnd );
      FreeMenus( Z80SimMenus );
      Z80SimMenus = NULL;
      }

   if (Z80SimWnd != NULL)
      {
      CloseWindow( Z80SimWnd );
      Z80SimWnd = NULL;
      }

   if (Z80SimGList != NULL)
      {
      FreeGadgets( Z80SimGList );
      Z80SimGList = NULL;
      }

   return;
}

/****i* Z80SimGTGUI.c/Z80SimCloseWindow() [2.0] ********************* 
*
* NAME 
*   Z80SimCloseWindow - Close the main GUI window.
*
* SYNOPSIS
*   continue = Z80SimCloseWindow( void )
*
* FUNCTION
*   Check user sanity first, then Call closeZ80SimWindow().
*
* RETURN VALUE
*   Exit the program value of 'FALSE' to the IDCMP loop.
*
* NOTES
*   This function is also called by cleanup() in Z80Loader.c
*   This function is part of the IDCMP loop.
*
* SEE ALSO 
*   CloseZ80SimWindow(), Z80SimSaveMI()
*********************************************************************
*/

VISIBLE int Z80SimCloseWindow( void )
{
   return( Z80SimQuitMI() );
}

/* --------------------------------------------------------------- */

/****i* Z80SimGTGUI.c/HandleZ80SimIDCMP() [2.0] ********************* 
*
* NAME 
*   HandleZ80SimIDCMP - Interface with the user's mouse input.
*
* SYNOPSIS
*   continue = HandleZ80SimIDCMP( void )
*
* FUNCTION
*   Process menu & Gadget selections made by the user.
*
* RETURN VALUE
*   Exit the program value of 'FALSE' to the main() function.
*
*********************************************************************
*/

PRIVATE int HandleZ80SimIDCMP( void )
{
   struct IntuiMessage *m;
   struct MenuItem     *mi;
   int                 dummy = 0, (*func)();
   BOOL                running = TRUE;

   while (running == TRUE)
      {
      if ((m = GT_GetIMsg( Z80SimWnd->UserPort )) == NULL) 
         {
         (void) Wait( 1L << Z80SimWnd->UserPort->mp_SigBit );
         continue;
         }

      CopyMem( (char *) m, (char *) &Z80SimMsg, 
               (long) sizeof( struct IntuiMessage ) 
             );

      GT_ReplyIMsg( m );

      switch (Z80SimMsg.Class)
         {

         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( Z80SimWnd );

               Z80SimRender();

               Update_Regs( dreg[ PC ] );

            GT_EndRefresh( Z80SimWnd, TRUE );
            break;

         case IDCMP_CLOSEWINDOW:
            running = Z80SimCloseWindow();
            break;

         case IDCMP_GADGETUP:
            /* Currently, the ListView Gadget is the only Gadget that
            ** can be clicked on (& even that does nothing special): 
            */
            func = (void *) ((struct Gadget *) 
                            Z80SimMsg.IAddress)->UserData;

            if (func != NULL)
               running = func();
   
            break;

         case IDCMP_MENUPICK:

            if (Z80SimMsg.Code != MENUNULL)
               {
               mi = ItemAddress( Z80SimMenus, Z80SimMsg.Code );
               if (mi == NULL)
                  break;

               func = (void *) (GTMENUITEM_USERDATA( mi ));
               if (func == NULL)
                  break;

               running = func();
               }

            /* There is something wrong with this code.  I'd rather
            ** NOT support multiple menu item selection anyway:

            while (Z80SimMsg.Code != MENUNULL)
               {
               mi = ItemAddress( Z80SimMenus, Z80SimMsg.Code );
               if (mi == NULL)
                  break;

               func = (void *) (GTMENUITEM_USERDATA( mi ));
               if (func == NULL)
                  break;

               running        = func();
               Z80SimMsg.Code = mi->NextSelect;
               }
            */
            break;

         default:
            break;
         }
         
      dummy++;    // There's some sort of compiler error at the 
                  // end of the while loop!
      }

   return( running );
}

/****i* Z80SimGTGUI.c/SetupScreen() [2.0] *************************** 
*
* NAME 
*   SetupScreen - Get ready for GadTools window.
*
* SYNOPSIS
*   error = SetupScreen( void )
*
* FUNCTION
*   This function locks the Public Screen, & Gets the
*   VisualInfo that GadTools needs.
*
* RETURN VALUE
*   0 for success, a negative number for failure.
*
*********************************************************************
*/

PRIVATE int SetupScreen( void )
{
   if ((Scr = LockPubScreen( PubScreenName )) == NULL)
      return( -1 );

   if ((VisualInfo = GetVisualInfo( Scr, TAG_DONE )) == NULL)
      return( -2 );

   return( 0L );
}

/****i* Z80SimGTGUI.c/OpenZ80SimWindow() [2.0] ********************** 
*
* NAME 
*   OpenZ80SimWindow - Open the Z80SimWnd.
*
* SYNOPSIS
*   error = OpenZ80SimWindow( void )
*
* FUNCTION
*   This function Sets up the GadTools, & opens the main GUI
*   window.
*
* RETURN VALUE
*   0 for success, a negative number for failure.
*
*********************************************************************
*/

PRIVATE int OpenZ80SimWindow( void )
{
   struct NewGadget ng;
   struct Gadget    *g;
   UWORD            lc, tc;
   UWORD            offx = Scr->WBorLeft, 
                    offy = Scr->WBorTop + Scr->RastPort.TxHeight + 1;

   if ((g = CreateContext( &Z80SimGList )) == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < Z80Sim_CNT; lc++)
      {
      CopyMem( (char *) &Z80SimNGad[lc], (char *) &ng, 
               (long) sizeof( struct NewGadget ) 
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = &topaz8;
      ng.ng_LeftEdge  += offx;
      ng.ng_TopEdge   += offy;

      Z80SimGadgets[lc] = g = CreateGadgetA( (ULONG) Z80SimGTypes[lc], g, 
                                &ng, 
                                (struct TagItem *) &Z80SimGTags[tc] );

      while (Z80SimGTags[tc] != TAG_DONE)
         tc += 2;

      tc++;

      if (g == NULL)
         return( -2 );
      }

   if ((Z80SimMenus = CreateMenus( Z80SimNewMenu, GTMN_FrontPen, 
                                   0L, TAG_DONE )) == NULL)
      return( -3 );

   LayoutMenus( Z80SimMenus, VisualInfo, 
                             GTMN_TextAttr, &topaz8, TAG_DONE );

   if ((Z80SimWnd = OpenWindowTags( NULL,
                                      
                       WA_Left,        Z80SimLeft,
                       WA_Top,         Z80SimTop,
                       WA_Width,       Z80SimWidth,
                       WA_Height,      Z80SimHeight + offy,
                       WA_IDCMP,       TEXTIDCMP | LISTVIEWIDCMP 
                         | IDCMP_MENUPICK | IDCMP_CLOSEWINDOW 
                         | IDCMP_REFRESHWINDOW,
                       
                       WA_Flags,       WFLG_DRAGBAR | WFLG_DEPTHGADGET 
                         | WFLG_CLOSEGADGET | WFLG_SMART_REFRESH 
                         | WFLG_ACTIVATE,
                       
                       WA_Gadgets,     Z80SimGList,
                       WA_Title,       Z80SimWdt,
                       WA_ScreenTitle, ScrTitle,
                       TAG_DONE )
      ) == NULL)
      return( -4 );

   SetMenuStrip(     Z80SimWnd, Z80SimMenus );
   GT_RefreshWindow( Z80SimWnd, NULL );

   Z80SimRender();

   return( 0 );
}

/****i* Z80SimGTGUI.c/FreeupData() [2.0] **************************** 
*
* NAME 
*   FreeupData - De-allocate memory for data structures.
*
* SYNOPSIS
*   void FreeupData( void )
*
* FUNCTION
*   De-allocate memory for mem, BrkStrs, & SCItemBuffer.
*
*********************************************************************
*/

VISIBLE void FreeupData( void )
{
   IMPORT char *BrkStrs; // [ MAXBKPT * BREALINE_LENGTH ]

   if (BrkStrs != NULL)
      {
      FreeVec( BrkStrs );
      BrkStrs = NULL;
      }

   if (SCItemBuffer != NULL)
      {
      FreeVec( SCItemBuffer );
      SCItemBuffer = NULL;
      }

   if (mem != NULL)
      {
      FreeVec( mem );
      mem = NULL;
      }

   return;
}

/****i* Z80SimGTGUI.c/AllocateData() [2.0] ************************** 
*
* NAME 
*   AllocateData - Allocate memory for data structures.
*
* SYNOPSIS
*   error = AllocateData( void )
*
* FUNCTION
*   Allocate memory for mem, BrkStrs, & SCItemBuffer.
*
*********************************************************************
*/

PRIVATE int AllocateData( void )
{
   IMPORT char *BrkStrs; // [ MAXBKPT * BREAKLINE_LENGTH ]

   if ((mem = (UBYTE *) AllocVec( MAXADDR, 
                                  MEMF_CLEAR | MEMF_FAST )) == NULL)
      {
      return( -1 );
      }

   if ((SCItemBuffer = (char *) AllocVec( sizeof( char ) * SCMAXITEM 
                                          * SCITEMLENGTH, 
                                          MEMF_CLEAR | MEMF_ANY 
                                        )) == NULL)
      {
      FreeVec( mem );

      return( -2 );
      }

   if ((BrkStrs = (char *) AllocVec( sizeof( char ) * MAXBKPT 
                                     * BREAKLINE_LENGTH, 
                                     MEMF_CLEAR | MEMF_ANY )) == NULL)
      {
      FreeVec( SCItemBuffer );
      FreeVec( mem );

      return( -3 );
      }

   return( 0 );
}
                    
                    
/****i* Z80SimGTGUI.c/processToolTypes() [1.0] ********************** 
*
* NAME 
*   processToolTypes - Get the tooltypes from the program icon &
*                      set the Tool strings accordingly.
*
* SYNOPSIS
*   void processToolTypes( void )
*
* FUNCTION
*   Examine the program Icon for any ToolTypes that the user
*   might have placed there.
*
*   The Current ToolTypes recognized by the Z80Siumlator are:
*       "CONFIGFILE" (Default:  Z80.cfg)
*       "EDITOR"     (Default:  SC:C/SE)
*       "TRANSLATOR" (Default:  Z80XLate)
*       "ASSEMBLER"  (Default:  Z80Asm)
*       "MACRO"      (Default:  Macro)
*
*********************************************************************
*/

PRIVATE void *processToolTypes( char **toolptr )
{
   if (toolptr == NULL)
      return( NULL );

   /* See if they gave us real tools for the Simulator:         */

   ConfigFile = GetToolStr( toolptr, "CONFIGFILE", &DEFAULT_FILE[0] );
   Editor     = GetToolStr( toolptr, "EDITOR",     "SC:C/SE"        );
   Translator = GetToolStr( toolptr, "TRANSLATOR", "Z80XLate"       );
   Assembler  = GetToolStr( toolptr, "ASSEMBLER",  "Z80Asm"         );
   Macro      = GetToolStr( toolptr, "MACRO",      "Macro"          );

   return( (void *) toolptr );
}

PRIVATE void ShutdownProgram( void )
{
   CloseZ80SimWindow(); // Just in case. 

   FreeupData();
   CloseDownScreen();

   CloseLibs();

   if (IconBase != NULL)
      {
      CloseLibrary( IconBase );
      IconBase = NULL;
      }

   return;
}

PRIVATE int SetupProgram( void )
{
   if (AllocateData() < 0)
      return( ERROR_NO_FREE_STORE );
            

   if (OpenLibs() < 0)
      {
      FreeupData();
      fprintf( stderr, "\nCouldn't open libraries!\n" );
      return( ERROR_INVALID_RESIDENT_LIBRARY );
      }

   if ((IconBase = OpenLibrary( "icon.library", 37L )) == NULL)
      {
      CloseLibs();
      FreeupData();
      fprintf( stderr, "\nCouldn't open icon.library V37!\n" );
      return( ERROR_INVALID_RESIDENT_LIBRARY );
      }

   if (SetupScreen() < 0)
      {
      FreeupData();
      CloseLibs();
      CloseLibrary( IconBase );
      return( ERROR_ON_OPENING_SCREEN );
      }

   if (OpenZ80SimWindow() < 0)
      {
      ShutdownProgram();
      return( ERROR_ON_OPENING_WINDOW );
      }

   return( RETURN_OK );
}

/****h* Z80SimGTGUI.c/ShutDown() [2.0] ****************************** 
*
* NAME 
*   ShutDown
*
* DESCRIPTION
*   Free up system resources & allocated Z80 data spaces.  This 
*   function is visible to external source code.
*
* SYNOPSIS
*   void ShutDown( void )
*
* FUNCTION
*   Close the main GUI (register) window.
*   Free the allocated Z80 memory space (mem), BrkStrs & SCItemBuffer.
*   Call CloseDownScreen(), then CloseLibs().
*
*********************************************************************
*/

VISIBLE void ShutDown( void )
{
   ShutdownProgram();
   return;
}

/****h* Z80SimGTGUI.c/main() [2.5] ********************************** 
*
* NAME 
*   main - the primary entry point of the program.
*
* SYNOPSIS
*   error = main( int argc, char **argv )
*
* FUNCTION
*   Setup the environment, then wait for user input via 
*   HandleZ80SimIDCMP();
*
*********************************************************************
*
*/

VISIBLE int main( int argc, char **argv )
{
   IMPORT int     LastBkpt;
   IMPORT char    regbytes[];  // in Z80Loader.c & Z80Loader.defn

    
   struct WBArg  *wbarg;
   char         **toolptr = NULL;
   int            rval    = RETURN_OK;

   BPTR           plock   = NULL, parent = NULL;

   struct ListViewMem lvm;
    
   if ((rval = SetupProgram()) != 0)
      {
      return( rval );
      }
      
   SetNotifyWindow( Z80SimWnd );

   lvm.lvm_NodeStrs   = SCItemBuffer; // After SetupProgram() please!
   lvm.lvm_Nodes      = SCListItems;
   lvm.lvm_NumItems   = SCMAXITEM;
   lvm.lvm_NodeLength = SCITEMLENGTH;

   SetupList( &SCList, &lvm ); // From CommonFuncs.o

   GT_SetGadgetAttrs( Z80SimGadgets[ SrcCodeListView ], Z80SimWnd, NULL,
                      GTLV_Labels,       &SCList,
                      GTLV_ShowSelected, NULL, // Z80SimGadgets[CurrentInst]
                      GTLV_Selected,     0,
                      TAG_DONE
                    );

   Init_Mem();
   InitBKPTS();

   // In case a ToolType is missing:

   (void) strcpy( ConfigFile, &DEFAULT_FILE[0] );
   (void) strcpy( Editor,     "SC:C/SE"        );
   (void) strcpy( Translator, "Z80XLate"       );
   (void) strcpy( Assembler,  "Z80Asm"         );
   (void) strcpy( Macro,      "Macro"          );

   if (argc == 0) // From Workbench:
      {
      wbarg   = &(_WBenchMsg->sm_ArgList[ _WBenchMsg->sm_NumArgs - 1 ]);
      toolptr = FindTools( diskobj, wbarg->wa_Name, wbarg->wa_Lock );

      strcpy( ProgramName, wbarg->wa_Name );

      (void) processToolTypes( toolptr );

      (void) File_Loader( ConfigFile, NULL );
      }
   else if (argc == 1) // No arguments in CLI.
      {
      strcpy( ProgramName, argv[0] );

      // We prefer to use the ToolTypes: 
      (void) FindIcon( &processToolTypes, diskobj, argv[0] );

      (void) File_Loader( ConfigFile, NULL );
      (void) strncpy( &CurrentConfigFileName[0], ConfigFile, 255 );
      }
   else if (argc == 2)
      {
      strcpy( ProgramName, argv[0] );

      // We prefer to use the ToolTypes: 
      (void) FindIcon( &processToolTypes, diskobj, argv[0] );

      (void) File_Loader( argv[1], NULL ); // User gave a *.cfg file.

      (void) strncpy( &CurrentConfigFileName[0], argv[1], 255 );
      }
   else if (argc > 2)   // User is brain-damaged!
      {
      strcpy( ProgramName, argv[0] );

      goto Wait_4_User;
      }

   /* place regbytes[] array into reg[] & dreg[]
   ** so that Update_Regs() can display the configuration data: 
   */
   assign_all( &regbytes[0] );
   

Wait_4_User: /* <<<<<<<<----------------------------------- */

   plock  = Lock( ProgramName, ACCESS_READ );
   parent = ParentDir( plock );
   
   NameFromLock( parent, PathName, 255 );
   
/* DEBUG stmt
   fprintf( stderr, "Path = %s\nProgramName = %s\n", 
                    PathName, ProgramName 
          );
*/
   SetTagItem( &LoadTags[0], ASLFR_InitialDrawer, (ULONG) &PathName[0] );
   SetTagItem( &SaveTags[0], ASLFR_InitialDrawer, (ULONG) &PathName[0] );
   SetTagItem( &DefaultTags[0], ASLFR_InitialDrawer, (ULONG) &PathName[0]);

   Z80SimRender(); // Draw graphics for the window.

   // place the contents inside the text gadgets:

   Update_Regs( dreg[PC] );

   rval = HandleZ80SimIDCMP(); // Wait for User to kill us here.

   FreeDiskObject( diskobj );

   UnLock( parent ); // Is this necessary??????
   UnLock( plock  );

   ShutdownProgram();          // Weesa be done now! 
   
   return( RETURN_OK );
}

/* --------------------- END of Z80SimGTGUI.c file ------------------ */
