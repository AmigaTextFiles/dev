/********************************************************************
** Z80LexLoader.c - A lexical scanner generated by flex
**
** FUNCTION:
**
**    This scanner is for reading in Z80Simulator configuration
**    files.
*********************************************************************/


#define FLEX_SCANNER

#include <stdio.h>

#ifdef __STDC__

# include <stdlib.h>

# define YY_USE_PROTOS
# define YY_USE_CONST

#endif


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
# ifndef __cplusplus
#  define __cplusplus
# endif
#endif


#ifdef __cplusplus

# ifndef __STDC__
#  include <stdlib.h>
# endif

# include <osfcn.h>


# define YY_USE_PROTOS   /* use prototypes in function declarations */
# define YY_USE_CONST    /* the "const" storage-class-modifier is valid */

#endif


#ifndef YY_USE_CONST
# define const
#endif


#ifdef YY_USE_PROTOS
# define YY_PROTO(proto) proto
#else
# define YY_PROTO(proto) ()

/* there's no standard place to get these definitions */
char *malloc();
int free();
int read();

#endif


/* amount of stuff to slurp up with each read */
#ifndef  YY_READ_BUF_SIZE
# define YY_READ_BUF_SIZE 8192
#endif

/* returned upon end-of-file */
#define YY_END_TOK 0

/* copy whatever the last rule matched to the standard output */

/* Cast to (char *) is because for 8-bit chars,
** yytext is (unsigned char *).
** This used to be an fputs(), but since the string might contain NUL's,
** we now use fwrite()
*/
#define ECHO (void) fwrite( (char *) yytext, yyleng, 1, yyout )

/* gets input and stuffs it into "buf".  Number of characters read, 
** or YY_NULL, is returned in "result".
*/

#define YY_INPUT(buf,result,max_size) \
   if ((result = read( fileno(yyin), (char *) buf, max_size )) < 0) \
      YY_FATAL_ERROR( "read() in flex scanner failed" );

#define YY_NULL 0

/* no semi-colon after return; correct usage is to write "yyterminate();" -
** we don't want an extra ';' after the "return" because that will cause
** some compilers to complain about unreachable statements.
*/
#define yyterminate() return( YY_NULL )

/* report a fatal error */

/* The funky do-while is used to turn this macro definition into
 * a single C statement (which needs a semi-colon terminator).
 * This avoids problems with code like:
 *
 *  if ( something_happens )
 *     YY_FATAL_ERROR( "oops, the something happened" );
 *  else
 *     everything_okay();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the YY_FATAL_ERROR() call.
 */

#define YY_FATAL_ERROR(msg) \
   do \
      { \
      (void) fputs( msg, stderr ); \
      (void) fputc( '\n', stderr ); \
      exit( 1 ); \
      } \
   while ( 0 )


/* default yywrap function - always treat EOF as an EOF */
#define yywrap() 1

/* enter a start condition.  This macro really ought to take a parameter,
** but we do it the disgusting crufty way forced on us by the ()-less
** definition of BEGIN
*/

#define BEGIN yy_start = 1 + 2 *

/* action number for EOF rule of a given start state */

#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* special action meaning "start processing a new file" */

#define YY_NEW_FILE \
   do \
      { \
      yy_init_buffer( yy_current_buffer, yyin ); \
      yy_load_buffer_state(); \
      } \
   while ( 0 )

/* default declaration of generated scanner - a define so the user can
** easily add parameters
*/

#define YY_DECL int yylex( void ) 

/* code executed at the end of each rule */

#define YY_BREAK              break;

#define YY_END_OF_BUFFER_CHAR 0

#ifndef  YY_BUF_SIZE
# define YY_BUF_SIZE (YY_READ_BUF_SIZE * 2) /* size of default input buf */
#endif

typedef struct yy_buffer_state *BUF_STATE_PTR;

#define YY_CHAR char
#define INITIAL 0

/************************************************************************
** Z80LexLoader.flex    The FLeX source for Z80LexLoader.c
**                      Used with Z80Loader.c
**
*************************************************************************/
   
#include <exec/types.h>
#include <string.h>
#include <ctype.h>

#define   MAXLINE        255

#define   UNALLOWED      0
#define   WHITE          1
#define   REG            2
#define   ALPHA          3
#define   COLON          4
#define   BYTE           5
#define   BREAK          6
#define   LOAD           7
#define   ENDMARK        8
#define   ENDLINE        9
#define   DELIM          10

char  nil1[ MAXLINE ], *loadfile_buff = &nil1[0];


#ifdef   LOADFILE_DEBUG    /* TestLexLoader is the target!! */

extern char  *yytext;
extern FILE  *yyin;

void  main( int argc, char **argv )
{
   char  *infile = "Z80.cfg";
   int   tokval  = 0;

   if ((yyin = fopen( infile, "r" )) == NULL)  
      {
      fprintf( stderr, "Couldn't open %s for input!!\n", infile );
      exit( -1 );
      }
   tokval  = yylex();
   while (tokval >= 0)    
      {
      switch( tokval )  
         {
         case  UNALLOWED:  fprintf( stderr, "Not allowed: %s\n",
                                            loadfile_buff );
                           break;
         case  COLON:      fprintf( stderr, "-:-" );
                           break;
         case  BYTE:       fprintf( stderr, "#%s#", yytext );
                           break;
         case  WHITE:      fprintf( stderr, "\nWhite Space!\n" );
                           break;
         case  ENDLINE:    fprintf( stderr, "\n" );
                           break;
         case  REG:        fprintf( stderr, "REG" ); break;
         case  ALPHA:      fprintf( stderr, "<%s>", loadfile_buff );
                           break;
         case  BREAK:      fprintf( stderr, "BREAK" );  break;
         case  LOAD:       fprintf( stderr, "LOAD" );   break;
         case  DELIM:      fprintf( stderr, "@" );      break;
         case  ENDMARK:    fprintf( stderr, "END\n\n" );
                           break;
         default:          fprintf( stderr, "\ntokval = %d\n", tokval );
                           break;
         }
      tokval = yylex();
      }
   fclose( yyin );
   return;
}

#endif      /* LOADFILE_DEBUG */


/* done after the current pattern has been matched and before the
 * corresponding action - sets up yytext
 */
#define YY_DO_BEFORE_ACTION \
   yytext       = yy_bp; \
   yyleng       = yy_cp - yy_bp;\
   yy_hold_char = *yy_cp; \
   *yy_cp       = '\0'; \
   yy_c_buf_p   = yy_cp;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE   1
#define EOB_ACT_LAST_MATCH    2

/* return all but the first 'n' matched char's back to the input stream */
#define yyless(n) \
   do \
      { \
      /* undo effects of setting up yytext */ \
      *yy_cp     = yy_hold_char; \
      yy_c_buf_p = yy_cp = yy_bp + n; \
      YY_DO_BEFORE_ACTION; /* set up yytext again */ \
      } \
   while ( 0 )


#define unput(c) yyunput( c, yytext )

struct yy_buffer_state    {

    FILE    *yy_input_file;
    YY_CHAR *yy_ch_buf;    /* input buffer */
    YY_CHAR *yy_buf_pos;   /* current position in input buffer */

    /* size of input buffer in bytes, not including room
    ** for EOB characters
    */
    int     yy_buf_size; 

    /* number of char's read into yy_ch_buf, not including 
    ** EOB characters 
    */
    int     yy_n_chars;

    int     yy_eof_status;  /* whether we've seen an EOF on this buffer
                            ** (see #defines below: 
                            */
};

#define EOF_NOT_SEEN 0
/* "pending" happens when the EOF has been seen but there's still
** some text to process
*/
#define EOF_PENDING  1
#define EOF_DONE     2


/* BUF_STATE_PTR is a typedef for struct yy_buffer_state: */

static BUF_STATE_PTR yy_current_buffer = NULL;

#define CBfptr yy_current_buffer  // shorter name for this variable.

/* we provide macros for accessing buffer states in case in the
** future we want to put the buffer states in a more general
** "scanner state"
*/

#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed */

static YY_CHAR yy_hold_char;

static int     yy_n_chars;  /* number of char's read into yy_ch_buf */



#ifndef  YY_USER_ACTION
# define YY_USER_ACTION
#endif

#ifndef  YY_USER_INIT
# define YY_USER_INIT
#endif


YY_CHAR *yytext;
int     yyleng;

FILE    *yyin = (FILE *) NULL, *yyout = (FILE *) NULL;

#define YY_END_OF_BUFFER 13

typedef int yy_state_type;

static const short int yy_accept[38] =  {   
    
    0, 11,   11,   13,   11,    2,    1,   12,   12,    3,    8,
    9,  9,    9,    9,    9,    9,    9,    9,    9,   12,   11,
    2,  1,   10,    9,    0,    0,    0,    0,    0,    7,    0,
    6,  0,    4,    5,    0
};

static const YY_CHAR yy_ec[128] =    {
    
    0,  1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
    4,  4,    4,    1,    1,    1,    1,    1,    1,    1,    1,
    1,  1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
    1,  1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,  1,    1,    1,    5,    5,    5,    5,    5,    5,    5,
    5,  5,    5,    6,    1,    1,    1,    1,    1,    7,    8,
    9, 10,   11,   12,   13,   14,   15,   16,    1,   17,   18,
    1, 19,   20,   21,    1,   22,   23,    1,    1,    1,    1,
   24, 24,    1,    1,    1,    1,    1,    1,    1,    5,    5,
    5,  5,    5,    5,    1,    4,    4,    1,    1,    4,    1,
    1,  1,    4,    1,    4,    4,    1,    1,    1,    1,    4,
    4,  1,    1,    1,    1,    1,    1
};

static const YY_CHAR yy_meta[25] = {
    
    0,  1,    2,    2,    2,    3,    2,    2,    3,    3,    3,
    3,  3,    3,    1,    2,    2,    1,    2,    1,    1,    2,
    2,  2,    2
};

static const short int yy_base[40] =  {
    
    0,  0,    0,   50,    0,   47,   45,   51,    0,   51,   51,
   26,  4,   25,    8,   24,   20,   10,   51,   31,   21,    0,
   39, 37,   51,   51,   27,   27,   29,   22,   27,   51,   23,
   51, 16,   51,   51,   51,   31,   25
};

static const short int yy_def[40] = {
    
    0, 37,    1,   37,   38,   37,   37,   37,   39,   37,   37,
   39, 39,   39,   39,   37,   37,   37,   37,   37,   37,   38,
   37, 37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
   37, 37,   37,   37,    0,   37,   37
};

static const short int yy_nxt[76] = {
    
    0,  4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
   11, 14,   11,    4,   15,   16,    4,   17,    4,    4,   18,
   19, 20,    7,   25,   26,   27,   24,   25,   28,   25,   21,
   36, 35,   34,   33,   32,   31,   30,   23,   22,   25,   29,
   25, 25,   25,   25,   23,   22,   37,    3,   37,   37,   37,
   37, 37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
   37, 37,   37,   37,   37,   37,   37,   37,   37,   37
};

static const short int yy_chk[76] =  {
    
    0,  1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,  1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,  1,    1,   12,   12,   14,   39,   14,   17,   17,   38,
   34, 32,   30,   29,   28,   27,   26,   23,   22,   20,   19,
   16, 15,   13,   11,    6,    5,    3,   37,   37,   37,   37,
   37, 37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
   37, 37,   37,   37,   37,   37,   37,   37,   37,   37
};

static yy_state_type  yy_last_accepting_state;
static YY_CHAR       *yy_last_accepting_cpos;

/* the intent behind this definition is that it'll catch
** any uses of REJECT which flex missed
*/

#define REJECT      reject_used_but_not_detected

#define yymore()    yymore_used_but_not_detected

#define YY_MORE_ADJ 0

/* these variables are all declared out here so that section 3 code can
** manipulate them
*/

/* points to current character in buffer */
static YY_CHAR *yy_c_buf_p = (YY_CHAR *) 0;

static int      yy_start   = 0;   /* start state number */


/* flag which is used to allow yywrap()'s to do buffer switches
** instead of setting up a fresh yyin.  A bit of a hack ...
*/

static int           yy_did_buffer_switch_on_eof;

static yy_state_type yy_get_previous_state( void );

static yy_state_type yy_try_NUL_trans( register yy_state_type current_state );

static int           yy_get_next_buffer( void );

static void yyunput( YY_CHAR c, register YY_CHAR *buf_ptr );

void yyrestart( FILE *input_file );

void yy_switch_to_buffer( BUF_STATE_PTR new_buffer );

void yy_load_buffer_state( void );

BUF_STATE_PTR yy_create_buffer( FILE *file, int size );

void yy_delete_buffer( BUF_STATE_PTR b );


int yy_init = 1;   /* whether we need to initialize */

/* ------------------------------------------------------------------- */

void yy_init_buffer( BUF_STATE_PTR b, FILE *file )
{
   b->yy_input_file = file;

   /* we put in the '\n' and start reading from [1] so that an
   ** initial match-at-newline will be true.
   */

   b->yy_ch_buf[0] = '\n';
   b->yy_n_chars   = 1;

   /* we always need two end-of-buffer characters.  The first causes
   ** a transition to the end-of-buffer state.  The second causes
   ** a jam in that state.
   */
   b->yy_ch_buf[1]  = YY_END_OF_BUFFER_CHAR;
   b->yy_ch_buf[2]  = YY_END_OF_BUFFER_CHAR;

   b->yy_buf_pos    = &b->yy_ch_buf[1];
   b->yy_eof_status = EOF_NOT_SEEN;
   return;
}

static int input()
{
   int     c;
   YY_CHAR *yy_cp = yy_c_buf_p;

   *yy_cp = yy_hold_char;

   if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR)
      {
      /* yy_c_buf_p now points to the character we want to return.
      ** If this occurs *before* the EOB characters, then it's a
      ** valid NUL; if not, then we've hit the end of the buffer.
      */
      if ( yy_c_buf_p < &CBfptr->yy_ch_buf[ yy_n_chars ] )
         *yy_c_buf_p = '\0';  /* this was really a NUL */
      else
         {
         /* End of the buffer, we need more input */
         yytext = yy_c_buf_p;
         ++yy_c_buf_p;

         switch (yy_get_next_buffer())
            {
            case EOB_ACT_END_OF_FILE:
               {
               if (yywrap())
                  {
                  yy_c_buf_p = yytext + YY_MORE_ADJ;
                  return ( EOF );
                  }

               YY_NEW_FILE;
               return( input() );
               }
               break;

            case EOB_ACT_CONTINUE_SCAN:
               yy_c_buf_p = yytext + YY_MORE_ADJ;
               break;

            case EOB_ACT_LAST_MATCH:
               YY_FATAL_ERROR( "unexpected last match in input()" );
            }
         }
      }

   c            = *yy_c_buf_p;
   yy_hold_char = *++yy_c_buf_p;

   return( c );
}


/* YY_DECL expands to yylex(), the main entry point for the scanner: */

YY_DECL
{
   register yy_state_type  yy_current_state;
   register YY_CHAR       *yy_cp, *yy_bp;
   register int            yy_act;

   if (yy_init != 0) // The calling state machine will take care of yy_init
      {
      YY_USER_INIT;
/*
      if (CBfptr != NULL) // Added 5/3/98.  Is it necessary???
         {
         free( CBfptr );
         CBfptr = NULL;
         }
*/
      if (yy_start == 0)
         yy_start = 1;        /* first start state */

      if (yyin == NULL)
         yyin = stdin;

      if (yyout == NULL)
         yyout = stdout;

      if (CBfptr == NULL)
         CBfptr = yy_create_buffer( yyin, YY_BUF_SIZE );
      else
         yy_init_buffer( CBfptr, yyin );

      yy_load_buffer_state();
      yy_init = 0;
      }

   while ( 1 )      /* loops until end-of-file is reached */
      {
      yy_cp  = yy_c_buf_p;

      /* support of yytext */
      *yy_cp = yy_hold_char;

      /* yy_bp points to the position in yy_ch_buf of the start of the
      ** current run.
      */
      yy_bp            = yy_cp;

      yy_current_state = yy_start;

yy_match:

      do
         {
         register YY_CHAR yy_c = yy_ec[ *yy_cp ];
       
         if (yy_accept[ yy_current_state ] != 0)
            {
            yy_last_accepting_state = yy_current_state;
            yy_last_accepting_cpos  = yy_cp;
            }

         while (yy_chk[ yy_base[ yy_current_state ] + yy_c ] 
                 != yy_current_state )
            {
            yy_current_state = yy_def[ yy_current_state ];
            if ( yy_current_state >= 38 )
               yy_c = yy_meta[ yy_c ];
            }

         yy_current_state = yy_nxt[ yy_base[ yy_current_state ] + yy_c ];
         ++yy_cp;

         }  while ( yy_current_state != 37 );

      yy_cp            = yy_last_accepting_cpos;
      yy_current_state = yy_last_accepting_state;

yy_find_action:

      yy_act = yy_accept[ yy_current_state ];

      YY_DO_BEFORE_ACTION;
      
      YY_USER_ACTION;

do_action:  /* this label is used only to access EOF actions */


      switch (yy_act)
         {
         case 0: /* must backtrack */
            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp           = yy_hold_char;
            yy_cp            = yy_last_accepting_cpos;
            yy_current_state = yy_last_accepting_state;
            goto yy_find_action;

         case 1:
            { return ENDLINE; }
            YY_BREAK

         case 2:
            { return WHITE;   }
            YY_BREAK

         case 3:
            { return COLON;   }
            YY_BREAK

         case 4:
            { return LOAD;    }
            YY_BREAK

         case 5:
            { return BREAK;   }
            YY_BREAK

         case 6:
            { return REG;     }
            YY_BREAK

         case 7:
            { return ENDMARK; }
            YY_BREAK

         case 8:
            { return DELIM;   }
            YY_BREAK

         case 9:
            { (void) strcpy( loadfile_buff, yytext );
              return ALPHA;
            }
            YY_BREAK

         case 10:
            { strcpy( loadfile_buff, yytext );
              return( BYTE ); 
            } 
            YY_BREAK

         case 11:
            { (void) strcpy( loadfile_buff, yytext );
              return( UNALLOWED ); 
            }
            YY_BREAK

         case 12:
            YY_FATAL_ERROR( "flex scanner jammed" );
            YY_BREAK

         case YY_STATE_EOF( INITIAL ):
            yyterminate();

         case YY_END_OF_BUFFER:
            {
            /* amount of text matched not including the EOB char */
            int yy_amount_of_matched_text = yy_cp - yytext - 1;

            /* undo the effects of YY_DO_BEFORE_ACTION */
            *yy_cp = yy_hold_char;

            /* note that here we test for yy_c_buf_p "<=" to the position
            ** of the first EOB in the buffer, since yy_c_buf_p will
            ** already have been incremented past the NUL character
            ** (since all states make transitions on EOB to the end-
            ** of-buffer state).  Contrast this with the test in yyinput().
            */
      
            if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
            /* this was really a NUL */
               {
               yy_state_type yy_next_state;

               yy_c_buf_p       = yytext + yy_amount_of_matched_text;
               yy_current_state = yy_get_previous_state(); 

               /* okay, we're now positioned to make the
               ** NUL transition.  We couldn't have
               ** yy_get_previous_state() go ahead and do it
               ** for us because it doesn't know how to deal
               ** with the possibility of jamming (and we
               ** don't want to build jamming into it because
               ** then it will run more slowly)
               */

               yy_next_state = yy_try_NUL_trans( yy_current_state );
               yy_bp         = yytext + YY_MORE_ADJ;

               if ( yy_next_state )
                  {
                  /* consume the NUL */
                  yy_cp            = ++yy_c_buf_p;
                  yy_current_state = yy_next_state;
                  goto yy_match;
                  }
               else
                  {
                  yy_cp            = yy_last_accepting_cpos;
                  yy_current_state = yy_last_accepting_state;
                  goto yy_find_action;
                  }
               }
            else 
               switch (yy_get_next_buffer())
                  {
                  case EOB_ACT_END_OF_FILE:
                     {
                     yy_did_buffer_switch_on_eof = 0;

                     if ( yywrap() )
                        {
                        /* note: because we've taken care in
                        ** yy_get_next_buffer() to have set up yytext,
                        ** we can now set up yy_c_buf_p so that if some
                        ** total hoser (like flex itself) wants
                        ** to call the scanner after we return the
                        ** YY_NULL, it'll still work - another YY_NULL
                        ** will get returned.
                        */
                        yy_c_buf_p = yytext + YY_MORE_ADJ;
                        yy_act     = YY_STATE_EOF((yy_start - 1) / 2);
                        goto do_action;
                        }
                     else
                        {
                        if ( ! yy_did_buffer_switch_on_eof )
                           YY_NEW_FILE;
                        }
                     }
                     break;

                  case EOB_ACT_CONTINUE_SCAN:
                     yy_c_buf_p       = yytext + yy_amount_of_matched_text;
                     yy_current_state = yy_get_previous_state();
                     yy_cp            = yy_c_buf_p;
                     yy_bp            = yytext + YY_MORE_ADJ;
                     goto yy_match;

                  case EOB_ACT_LAST_MATCH:
                     yy_c_buf_p = &yy_current_buffer->yy_ch_buf[yy_n_chars];

                     yy_current_state = yy_get_previous_state();
                     yy_cp            = yy_c_buf_p;
                     yy_bp            = yytext + YY_MORE_ADJ;
                     goto yy_find_action;
                  }
                  break;

            } // case YY_END_OF_BUFFER

         default:

#ifdef FLEX_DEBUG
            printf( "action # %d\n", yy_act );
#endif
            YY_FATAL_ERROR(
               "fatal flex scanner internal error--no action found" );

         } // switch (yy_act)

      }  // while (1)
}


/* ----------------------------------------------------------------
** yy_get_next_buffer - try to read in a new buffer
**
** SYNOPSIS
**
**     int yy_get_next_buffer( void );
**     
** RETURNS:  a code representing an action:
**
**     EOB_ACT_LAST_MATCH    - 
**     EOB_ACT_CONTINUE_SCAN - continue scanning from current position
**     EOB_ACT_END_OF_FILE   - end of file
** ---------------------------------------------------------------- */

static int yy_get_next_buffer()
{
   register YY_CHAR *dest   = CBfptr->yy_ch_buf;
   register YY_CHAR *source = yytext - 1; /* copy prev. char, too */
   register int     number_to_move, i;
   int              ret_val;

   if (yy_c_buf_p > &CBfptr->yy_ch_buf[ yy_n_chars + 1 ])
      YY_FATAL_ERROR(
         "fatal flex scanner internal error--end of buffer missed" );

   /* try to read more data */

   /* MMMMMMMMMM first move last chars to start of buffer */
   number_to_move = yy_c_buf_p - yytext;

   for ( i = 0; i < number_to_move; ++i )
      *(dest++) = *(source++);
   /* MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM */

   if ( CBfptr->yy_eof_status != EOF_NOT_SEEN )
      /* don't do the read, it's not guaranteed to return an EOF,
      ** just force an EOF
      */
      yy_n_chars = 0;

   else
      {
      int num_to_read = CBfptr->yy_buf_size - number_to_move - 1;

      if (num_to_read > YY_READ_BUF_SIZE)
         num_to_read = YY_READ_BUF_SIZE;
      else if ( num_to_read <= 0 )
         YY_FATAL_ERROR( "fatal error - scanner input buffer overflow" );

      /* read in more data */
      YY_INPUT( (&CBfptr->yy_ch_buf[ number_to_move ]),
                yy_n_chars, num_to_read );
      }

   if (yy_n_chars == 0)
      {
      if (number_to_move == 1)
         {
         ret_val               = EOB_ACT_END_OF_FILE;
         CBfptr->yy_eof_status = EOF_DONE;
         }
      else
         {
         ret_val               = EOB_ACT_LAST_MATCH;
         CBfptr->yy_eof_status = EOF_PENDING;
         }
      }
   else
      ret_val = EOB_ACT_CONTINUE_SCAN;

   yy_n_chars                       += number_to_move;
   CBfptr->yy_ch_buf[yy_n_chars]     = YY_END_OF_BUFFER_CHAR;
   CBfptr->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

   /* yytext begins at the second character in yy_ch_buf; the first
   ** character is the one which preceded it before reading in the latest
   ** buffer; it needs to be kept around in case it's a newline, so
   ** yy_get_previous_state() will have with '^' rules active
   */

   yytext = &CBfptr->yy_ch_buf[1];
   return ( ret_val );
}


/* ---------------------------------------------------------------
** yy_get_previous_state - get the state just before the EOB 
**                         char was reached
**
** SYNOPSIS
**
**   yy_state_type yy_get_previous_state( void );
** --------------------------------------------------------------- */

static yy_state_type yy_get_previous_state()
{
   register yy_state_type yy_current_state;
   register YY_CHAR       *yy_cp;

   yy_current_state = yy_start;

   for (yy_cp = yytext + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp)
      {
      register YY_CHAR yy_c = (*yy_cp ? yy_ec[ *yy_cp ] : 4);
   
      if ( yy_accept[yy_current_state] )
         {
         yy_last_accepting_state = yy_current_state;
         yy_last_accepting_cpos  = yy_cp;
         }

      while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
         {
         yy_current_state = yy_def[yy_current_state];
         if ( yy_current_state >= 38 )
            yy_c = yy_meta[yy_c];
         }

      yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
      }

   return ( yy_current_state );
}


/* -------------------------------------------------------------------
**  yy_try_NUL_trans - try to make a transition on the NUL character
**
** SYNOPSIS
**    next_state = yy_try_NUL_trans( current_state );
** ------------------------------------------------------------------- */

static yy_state_type yy_try_NUL_trans( register yy_state_type 
                                       yy_current_state 
                                     )
{
   register int     yy_is_jam;
   register YY_CHAR *yy_cp = yy_c_buf_p;
   register YY_CHAR yy_c = 4;

   if ( yy_accept[yy_current_state] )
      {
      yy_last_accepting_state = yy_current_state;
      yy_last_accepting_cpos  = yy_cp;
      }

   while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
      {
      yy_current_state = yy_def[yy_current_state];
      if ( yy_current_state >= 38 )
         yy_c = yy_meta[yy_c];
      }

   yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
   yy_is_jam        = (yy_current_state == 37);

   return( yy_is_jam ? 0 : yy_current_state );
}

static void yyunput( YY_CHAR c, register YY_CHAR *yy_bp )
{
   register YY_CHAR *yy_cp = yy_c_buf_p;

   /* undo effects of setting up yytext */
   *yy_cp = yy_hold_char;

   if ( yy_cp < CBfptr->yy_ch_buf + 2 )
      { /* need to shift things up to make room */
      register int     number_to_move = yy_n_chars + 2; // +2 for EOB chars
      register YY_CHAR *dest = &CBfptr->yy_ch_buf[CBfptr->yy_buf_size + 2];

      register YY_CHAR *source = &CBfptr->yy_ch_buf[number_to_move];

      while ( source > yy_current_buffer->yy_ch_buf )
         *--dest = *--source;

      yy_cp     += dest - source;
      yy_bp     += dest - source;
      yy_n_chars = CBfptr->yy_buf_size;

      if ( yy_cp < CBfptr->yy_ch_buf + 2 )
         YY_FATAL_ERROR( "flex scanner push-back overflow" );
      }

   if ( yy_cp > yy_bp && yy_cp[-1] == '\n' )
      yy_cp[-2] = '\n';

   *--yy_cp = c;

   /* note: the formal parameter *must* be called "yy_bp" for this
   **       macro to now work correctly
   */

   YY_DO_BEFORE_ACTION; /* set up yytext again */
   return;
}


/* ------------------------------------------------------------
** Setup Global variables to the contents of yy_current_buffer
** ------------------------------------------------------------ */

void yy_load_buffer_state( void )
{
   yy_n_chars   = CBfptr->yy_n_chars;
   yytext       = yy_c_buf_p = CBfptr->yy_buf_pos;

   yyin         = CBfptr->yy_input_file;
   yy_hold_char = *yy_c_buf_p;
}


void yy_switch_to_buffer( BUF_STATE_PTR new_buffer )
{
   if (CBfptr == new_buffer)
      return;

   if (CBfptr != NULL)
      {
      /* flush out information for old buffer */
      *yy_c_buf_p        = yy_hold_char;
      CBfptr->yy_buf_pos = yy_c_buf_p;
      CBfptr->yy_n_chars = yy_n_chars;
      }

   CBfptr = new_buffer;
   yy_load_buffer_state();

   /* we don't actually know whether we did this switch during
   ** EOF (yywrap()) processing, but the only time this flag
   ** is looked at is after yywrap() is called, so it's safe
   ** to go ahead and always set it.
   */

   yy_did_buffer_switch_on_eof = 1;
   return;
}


/* yy_current_buffer evaluated to NULL in order for this function
** to be called:
*/

BUF_STATE_PTR yy_create_buffer( FILE *file, int size )
{
   BUF_STATE_PTR b;

   b = (BUF_STATE_PTR) calloc( sizeof( struct yy_buffer_state ), 1 );

   if (!b)
      YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

   b->yy_buf_size = size;

   /* yy_ch_buf has to be 2 characters longer than the size given because
   ** we need to put in 2 end-of-buffer characters.
   */
   b->yy_ch_buf = (YY_CHAR *) calloc( (unsigned) (b->yy_buf_size + 2), 1 );

   if ( !b->yy_ch_buf )
      YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

   yy_init_buffer( b, file );

   return( b );
}


void yy_delete_buffer( BUF_STATE_PTR b )
{
   if (b == CBfptr)
      CBfptr = (BUF_STATE_PTR) NULL;

   free( (char *) b->yy_ch_buf );
   free( (char *) b ); 
   return;
}


void yyrestart( FILE *input_file )
{
   yy_init_buffer( CBfptr, input_file );
   yy_load_buffer_state();
   return;
}

/* -------------------- END of Z80LexLoader.c file ------------------- */
