* W23_6c.bin - Code from C000-DFFF

include global.nfo

*option nohex
*option noasc

* data areas
data c28c-c36f
word c49a-c4a3   * jump table
data c5c2-c5dd
data c5e2-c5ff
data c77c-c78f
data c7fc-c7ff
data d0cc-d0ff
data d1ba-d1ff
data d57d-d58c
data d608-d67f
data d6db-d6ff
word d7ad-d7c4
data db4b-dbff
*ata dbfb-dbff
*data dce8-dfff
data dc94-dfff

* Code labels

comment c000 ===========================================================
comment c000 Entry point table
comment c000 ===========================================================
comment c000
insert c000 \        IFND NoOrg
lcomment c000 do one-time initialization
lcomment c006 enter main loop

insert c009 \        ELSE
insert c009 \EStart  EQU     \*
insert c009 \        ENDIF
comment c009
comment c009 ===========================================================
comment c009 FtInit - first-time initialization code
comment c009 ===========================================================
comment c009
label c009 FtInit
lcomment c009 disable interrupts
lcomment c00b initialize system stack to $0200
lcomment c010 initialize direct page register to $00
lcomment c012 initialize VCA and RES to $00
lcomment c01a initialize VCF to $FF
label c022 FtIni0
lcomment c022 initialize OF4 area to $FF
comment c027
lcomment c027 save current Tuning
lcomment c029 save current Wave Mode
lcomment c02b fill area between $0000 and $03ff with $00
word c02c-c02d
label c02e FtIni1
const c031
lcomment c035 fill area between $3000 and $4000 with $00
const c036
label c038 FtIni2
const c03b
lcomment c03f restore Tuning
lcomment c041 restore Wave Mode
comment c043
lcomment c046 initialize all Sequencer Channels to 3
label c04a FtIni3
lcomment c04f store $03 in $3C3A
comment c052
lcomment c052 look whether we're in Wave 2.2 mode
lcomment c058 if NOT, default to Wave 2.2 mode
lcomment c05c then look whether this is a 2.3
lcomment c05f (has $40 set in capabilities byte)
lcomment c066 if so, set to 2.3 mode
lcomment c06a set Combiprogram to 0, modified
lcomment c06c (this forces reload in PGCHG!)
comment c06e
label c06e FtIni4
lcomment c06e default to 8-bit PROZ board handling
lcomment c071 get device capabilities
lcomment c074 look whether bit 2 set
lcomment c078 if so, use 12-bit PROZ board handling
label c07b FtIni5
comment c07e
lcomment c07e do SDRAM / EPROM check
lcomment c081 initialize peripheral devices
lcomment c084 set VIA Port A Data to 11010000
bin c085
lcomment c086 i.e., turn on LED A, all other things off
lcomment c08e set currently changed bank # to $FF
lcomment c091 start with maximal total volume
lcomment c093 initialize SEQM to 99
+dec c094
lcomment c097 initialize MIDI channel to 01
comment c09b
dec c09c
lcomment c09b get initial settings
lcomment c09d for all 28 possible
lcomment c09f ANALOG PANEL knobs and wheels
label c09f FtIni6
comment c0a8
lcomment c0a8 if not in Wave 2.3 mode
lcomment c0ad initialize to Wavetable 30 (modified)
lcomment c0af this forces Upper WT initialization
label c0b1 FtIni7
lcomment c0b1 set current key split number to 1
lcomment c0b5 look whether TRIG IN set to High
lcomment c0bc if so, set Inverse Polarity

comment c0bf
comment c0bf ===========================================================
comment c0bf MLoop - Main Loop
comment c0bf ===========================================================
comment c0bf
label c0bf MLoop 
lcomment c0bf allow interrupts
lcomment c0c1 reset "Commands Pending" flag
lcomment c0c3 process eventual Cass. Operation
lcomment c0c6 get keyboard state
lcomment c0c9 receive comm.bus command
lcomment c0cc (re-)allow interrupts
label c0ce MLoop0
label c0d1 MLoop2
used c0d1
lcomment c0d4 (re-)allow interrupts
lcomment c0d6 reset "command pending" flag
lcomment c0db recalculate Envelope Generator settings
lcomment c0e0 if RunMode <> 0,
lcomment c0e2 disallow interrupts
lcomment c0e4 look whether keyboard PIA IRQA flag set
lcomment c0e7 if so, restart loop
lcomment c0ec if 6840 Timer 1 interrupt flag set,
lcomment c0ee restart loop
lcomment c0f0 (re-)allow interrupts
label c0f2 MLoop1
lcomment c0f5 (re-)allow interrupts
lcomment c0f7 if MIDI Note On received,
lcomment c0f9 restart from MLoop0
lcomment c0fb otherwise from MLoop

comment c0fd
comment c0fd ===========================================================
comment c0fd IniPer - initialize peripheral devices
comment c0fd ===========================================================
comment c0fd
label c0fd IniPer
lcomment c0fd $EFF8 contains $C519 (IRQ code address) for all 3 platforms
lcomment c100 save IRQ to Dev. System IRQ Latch
comment c103 the above 2 lines are initialization for the "Development version"
comment c103 of the Wave.
comment c103 According to Wolfgang Palm, it was a specially built development
comment c103 system that shared memory/processor with a Wave.
comment c103
lcomment c103 make all PIA A Lines input
lcomment c109 make all PIA B Lines input
lcomment c111 access PIA A I/O register
lcomment c114 access PIA B I/O register
lcomment c117 set 6840 Timer 2: output enabled, interrupt disabled,
+bin c118
lcomment c119 \    op.mode 000, 16bit, ext.clock, CR0=Timer 1
lcomment c11c set 6840 Timer 1: output enabled, interrupt enabled,
+bin c11d
lcomment c11e \    op.mode 010, 16bit, ext.clock, all timers allowed
lcomment c121 select 6840 Timer 3 into CR0
+bin c122
lcomment c126 set 6840 Timer 3: output enabled, interrupt disabled,
+bin c127
lcomment c128 \    op.mode 010, 16bit, Enable Clock, Clock not prescaled
lcomment c12b ENABLE VIA Interrupt for T2
+bin c12c
lcomment c130 set data direction for VIA port B to 01110001 (0=in,1=out)
bin c131
lcomment c135 then initialize port B data to 10000000
+bin c136
lcomment c13a Master Reset ACIA
lcomment c13f init ACIA to RI enabled, /RTS=high, TI disabled,
lcomment c13f \    8 Bit, 1 Stop, 31250 baud
lcomment c144 check current ACIA flags
lcomment c147 if TDRE set, ACIA is considered OK
lcomment c14b so set OK flag
lcomment c14e and set up MIDI data pointers
label c157 IniPe0
lcomment c15c save current TAS PIA A State
lcomment c160 access TAS PIA A+B direction registers
+dec c161
+dec c163
lcomment c164 make all TAS PIA A data lines output
lcomment c168 set data direction for VIA port A to Output
lcomment c16b make low 4 TAS PIA B lines output, upper 4 input
+dec c16e
lcomment c16f access TAS PIA A+B data registers
+dec c172
+dec c174
lcomment c177 restore TAS PIA A lines to previous state
lcomment c17a initialize VIA Timer 2 to $8000
lcomment c17c (fires after approx. 21ms)
lcomment c17f fill area between $0310 and $0317 with $40
label c184 IniPe1
lcomment c18b set Panel Update flag
lcomment c18d access Kbd PIA A+B direction registers
+dec c191
+dec c193
lcomment c194 make Kbd PIA B lines input
+dec c195
lcomment c196 make Kbd PIA A lines output
+dec c19d
+dec c19f
lcomment c1a3 initialize to use Wave 2.3 Bank Panel
lcomment c1a6 if in 2.2 Mode,
lcomment c1ab use DPatPrg as start panel
rel c1ad de10
label c1af IniPe2
lcomment c1af set current panel

comment c1b5
comment c1b5 ===========================================================
comment c1b5 IniMAr - initialize memory areas
comment c1b5 ===========================================================
comment c1b5
label c1b5 IniMAr
lcomment c1b6 reset area at $03D8 (???)
lcomment c1bb reset Voice Pitch Values
lcomment c1c0 reset Envelope-On-Waveform Velocities
lcomment c1c7 reset Envelope-On-Filter Velocities
lcomment c1cc reset Filter Cutoff values
lcomment c1d1 reset Envelope-On-Volume Velocities
lcomment c1d8 reset Attack Filter Envelope,
lcomment c1d8 \      Attack Volume Envelope,
lcomment c1d8 \      Decay Filter Envelope,
lcomment c1d8 \      Mono Channel Voice Banks
label c1db IniMA0

comment c1e3
comment c1e3 ===========================================================
comment c1e3 Fill8B - fill 8 bytes starting at X with the content of A
comment c1e3 ===========================================================
comment c1e3
label c1e3 Fill8B
label c1e7 Fill80

comment c1ef
comment c1ef ===========================================================
comment c1ef SlfTst - init display and do memory / EPROM selftest
comment c1ef ===========================================================
comment c1ef
label c1ef SlfTst
lcomment c1f2 clear LCD screen
const c1f8
label c1fa SlfTs0
lcomment c1fa check SDRAM by writing & checking $00 and $FF
lcomment c1fc in each cell between $0000 and $3fff
label c20f SlfTs1
lcomment c20f if RAM check failed
const c210
lcomment c214 write out '9' on LCD
char c215
label c21a SlfTs2
lcomment c21a else write out 'R' on LCD
char c21b
label c21e SlfTs3
const c21f
lcomment c224 write out '/' on LCD
char c225
comment c228
lcomment c22c print out 'T' if 9000-9FFF OK
char c22d
const c22f
lcomment c233 print out 'A' if A000-AFF7 OK
char c234
lcomment c237 print out 'C' if C000-CFFF OK
char c238
lcomment c23e print out 'D' if D000-DFFF OK
char c23f
lcomment c242 print out 'E' if E000-EFFF OK
char c243
lcomment c246 then wait a little bit
const c247
*label c249 SlfTs4
const c24c
+dec c24c

comment c24e
comment c24e ===========================================================
comment c24e RChkSm - generates checksum over a 4K block
comment c24e ===========================================================
comment c24e
label c24e RChkSm
lcomment c259 print ',' on LCD
+char c25a
label c25d RChkS0
label c26e RChkS1
+dec c26f
lcomment c277 strange... WRITE to EPROM?
lcomment c279 write out '9' on LCD
char c27a
label c27f RChkS2
label c281 RChkS3
comment c283 the above could be removed and RChks4 could be renamed to RChks3
label c283 RChkS4
lcomment c286 wait a little bit
+dec c287
lcomment c288 (2 + 32 \* (2 + 3)) = 162 cycles = 108µs
const c28a
+dec c28a


* unused c28c-c29f  * for production code
* for binary compatibility, use the following 8 lines
const c28c-c29f
comment c28c
lcomment c28c this is code area in Wave 2.2 code
comment c28e
insert  c28e \        IFND NoDead
comment c28e DEAD:C0DE from here on (?)
insert c2a0 \        ENDIF

comment c2a0
insert c2a0 \        IFND NoOrg
insert c2a0 \        ORG     $C2A0
insert c2a0 \        ENDIF
comment c2a0
comment c2a0 ===========================================================
comment c2a0 CGrBit - compressed program bits and multiplicators
comment c2a0 ===========================================================
comment c2a0 arrays of 4-byte structures
comment c2a0 1st two bytes are the address of a byte
comment c2a0 3rd byte is a bit mask
comment c2a0 4th byte is a multiplicator
comment c2a0
unlcomment c2a0
break c2a0-c36f
word c2a0
lcomment c2a0 LFO Rate
word c2a4
lcomment c2a4 Waves OSC
const c2a6-c2a7
word c2a8
lcomment c2a8 Filter Cutoff
const c2aa-c2ab
word c2ac
lcomment c2ac Env 1 -> VCF
const c2ae-c2af
word c2b0
lcomment c2b0 Env 1 -> Waves
word c2b4
lcomment c2b4 VCF Emphasis
word c2b8
lcomment c2b8 Env 2 -> Loudness
word c2bc
lcomment c2bc Env 1 Attack
word c2c0
lcomment c2c0 Env 2 Attack
word c2c4
lcomment c2c4 Env 1 Decay
word c2c8
lcomment c2c8 Env 2 Decay
word c2cc
lcomment c2cc Env 1 Sustain
const c2ce-c2cf
word c2d0
lcomment c2d0 Env 2 Sustain
const c2d2-c2d3
word c2d4
lcomment c2d4 Env 1 Release
word c2d8
lcomment c2d8 Env 2 Release
word c2dc
lcomment c2dc LFO Delay
word c2e0
lcomment c2e0 Env 3 Attack
word c2e4
lcomment c2e4 LFO Waveshape
const c2e6-c2e7
word c2e8
lcomment c2e8 Env 3 Release
word c2ec
lcomment c2ec Mod. Wheel
word c2f0
lcomment c2f0 Env 3 Att
word c2f4
lcomment c2f4 Waves Sub
const c2f6-c2f7
word c2f8
lcomment c2f8 Digital Data 1 (VL,VF,TF,MW,TW,UW,??,MS)
word c2fc
lcomment c2fc Digital Data 2 (MO,MF,ML,??,TL,TM,EO,ES)
word c300
lcomment c300 Keyfollow Filter
word c304
lcomment c304 Keyfollow Loudness
word c308
lcomment c308 Keyfollow Wavetable
word c30c
lcomment c30c Oscillator Detune
word c310
lcomment c310 Suboscillator Waveform Control
word c314
lcomment c314 Bender To Destination
word c318
lcomment c318 Bender Interval
word c31c
lcomment c31c Semitone Ch1 (TUNING Panel)
const c31e-c31f
word c320
lcomment c320 Semitone Ch2
const c322-c323
word c324
lcomment c324 Semitone Ch3
const c326-c327
word c328
lcomment c328 Semitone Ch4
const c32a-c32b
word c32c
lcomment c32c Semitone Ch5
const c32e-c32f
word c330
lcomment c330 Semitone Ch6
const c332-c333
word c334
lcomment c334 Semitone Ch7
const c336-c337
word c338
lcomment c338 Semitone Ch8
const c33a-c33b

comment c33c
comment c33c ===========================================================
comment c33c CGlBit - compressed program bits and multiplicators
comment c33c ===========================================================
comment c33c same layout as the above structure
comment c33c
unlcomment c33c
word c33c
lcomment c33c Current Wavetable
word c340
lcomment c340 Keyboard Mode
word c344
lcomment c344 Keyboard Split Point
const c346-c347

comment c348
insert c348 \        IFND NoDead
comment c348 it is doubtful whether the following data have any real value
comment c348 looks like they're dead code since their start address is
comment c348 used as END OF TABLE indicator at EEC1
comment c348
label c348 EndCG
word c348
lcomment c348 Env 3 Release
word c34c
lcomment c34c Mod. Wheel
word c350
lcomment c350 Env 3 Att
word c354
lcomment c354 Waves Sub
const c356-c357
word c358
lcomment c358 Digital Data 1 (VL,VF,TF,MW,TW,UW,??,MS)
word c35c
lcomment c35c Digital Data 2 (MO,MF,ML,??,TL,TM,EO,ES)
word c360
lcomment c360 Keyfollow Filter
word c364
lcomment c364 Keyfollow Loudness
word c368
lcomment c368 Keyfollow Wavetable
word c36c
lcomment c36c Oscillator Detune
insert c370 \        ELSE
insert c370 EndCG   EQU \*
insert c370 \        ENDIF

comment c370
insert c370 \        IFND NoOrg
insert c370 \        ORG     $C370
insert c370 \        ENDIF
comment c370
comment c370 ===========================================================
comment c370 GKNBPS - Get knob positions
comment c370 ===========================================================
comment c370 Called from initialization and from interrupt routine.
comment c370 Every invocation checks 4 consecutive ANALOG PANEL knob
comment c370 and wheel positions.
comment c370
label c370 GKNBPS
lcomment c370 check whether parameter changes possible
lcomment c373 if not (EVU code)
lcomment c375 return without action
comment c376 if the above check was commented out,
comment c376 and if the ZN427 and 10K trim pot was added to the I/O board,
comment c376 it would be possible to attach a Wave 2.2/2.3 Analog Board
comment c376 to an EVU!
comment c376
label c376 GKNBP0
lcomment c376 do this 4 times:
comment c37c
label c37c GKNBP1
lcomment c37c reset "A+B" flag
lcomment c381 get current bank base address
lcomment c386 get displayed group (0=A,1=B,2=A+B)
lcomment c388 if A+B displayed
lcomment c38c set "A+B" flag
lcomment c38e and skip Wave 2.2 test
label c390 GKNBP2
lcomment c390 if in Wave 2.2 mode
lcomment c395 look whether Group B selected
lcomment c398 if so, adjust bank base address
label c39b GKNBP3
lcomment c39b advance to next knob on Analog Panel
lcomment c39e get currently selected knob ID
lcomment c3a1 mask out the LED settings
lcomment c3a3 look whether arrived at 25
lcomment c3a7 if so, switch back to knob ID 0
label c3b0 GKNBP4
lcomment c3b0 now get the ADC output for that knob
lcomment c3b3 initiate ADC conversion
lcomment c3b6 look whether it is very close to the previous value (+-4)
dec c3b7
dec c3bd
label c3c2 GKNBP5
lcomment c3c2 if very close, return
label c3c3 GKNBP6
dec c3c4
label c3c7 GKNBP7
dec c3c8
label c3c9 GKNBP8
lcomment c3c9 save current setting
lcomment c3d5 look whether #24 has been changed
dec c3d6
lcomment c3d7 if not, jump on... but if so,
lcomment c3dd send Pitch Wheel MIDI message
lcomment c3e2 with low 7 bits zero
lcomment c3e8 convert position into MIDI range
label c3ef GKNBP9
label c3fd GKNBPa
label c405 GKNBPb
label c40d GKNBPc
label c415 GKNBPd
label c423 GKNBPe
label c425 GKNBPf
lcomment c428 convert position into MIDI range
lcomment c429 send out Pitch Wheel high position
comment c433
label c433 GKNBPg
lcomment c433 look whether #21 has been changed
lcomment c435 if not, jump on... but if so,
lcomment c439 send MOD WHEEL Controller Message
lcomment c445 shift position into MIDI range
comment c44d
comment c44d come here for every changed analog value
comment c44d
label c44d GKNBPh
comment c44e
lcomment c44e if SECOND PANEL processing
lcomment c452 and LFO Rate (?)
comment c45e come here for Knob #9..16
lcomment c45e effectively position onto $00E0 (#$00D7 + $09)
*rel c460 0009
*+const c460
*+dec c460
label c462 GKNBPj
comment c469 come here for Knob #1 (LFO Rate?)
label c469 GKNBPk
lcomment c469 effectively position onto SeqSpd
comment c46f come here if (not SECOND PANEL processing) or (knob < 9) or (knob >= 17)
label c46f GKNBPl

comment c47f
comment c47f ===========================================================
comment c47f LFOPrc - LFO processing (done in interrupt routine!)
comment c47f ===========================================================
comment c47f On entry, A contains a bank number between 0 and 7
comment c47f
label c47f LFOPrc
lcomment c47f get bank base address into X
lcomment c485 get LFO Waveshape for that bank
rel c487 0110
lcomment c488 convert to range 0..3
lcomment c490 get current LFO value for that bank
rel c492 0110
lcomment c498 and jump according to LFO Shape
comment c49a
comment c49a ===========================================================
comment c49a Jump Address Table for LFO Shapes
comment c49a ===========================================================
comment c49a
label c49a JLFOShp
break c49a-c4a3
lcomment c49a Waveshape 0: Triangle
lcomment c49c Waveshape 1: Sawtooth 1
lcomment c49e Waveshape 2: Sawtooth 2
lcomment c4a0 Waveshape 3: Rectangle
lcomment c4a2 this entry can't be reached!

comment c4a4
comment c4a4 come here for LFO Waveshape 0 (Triangle)
label c4a4 LFOPr0
label c4a9 LFOPr1

comment c4ac
comment c4ac come here for LFO Waveshape 2 (Sawtooth 2)
label c4ac LFOPr2

comment c4af
comment c4af come here for LFO Waveshape 3 (Rectangle)
label c4af LFOPr3
label c4b7 LFOPr4

comment c4b9
comment c4b9 come here for LFO Waveshape 1 (Sawtooth 1)
label c4b9 LFOPr5
rel c4c0 0110
rel c4c8 0110
dec c4ca
rel c4d8 0110

label c4ce LFOPr6

comment c4db
comment c4db ===========================================================
comment c4db LFOAPr - called from LFO Processing
comment c4db ===========================================================
comment c4db ... and ONLY from LFO Processing.
comment c4db A quick analysis shows that this routine could be embedded 
comment c4db in LFOPrc, resulting in slightly faster interrupt processing.
comment c4db
label c4db LFOAPr
lcomment c4db get CDPFlg for current bank
rel c4dd 0110
lcomment c4df look whether TM:1 set
lcomment c4e1 if so,
lcomment c4e3 get current pressure
label c4ea LFOAP0
comment c4f4 come here if (and only if) TM:0 is set
label c4f4 LFOAP1
lcomment c4f4 A=((128-LFODelay)/8)+1
rel c4f8 0110
lcomment c4fd A+=[$0055,$0075,...]
rel c4ff 0110
label c503 LFOAP2
label c505 LFOAP3
rel c507 0110
rel c50c 0110

comment c519
comment c519 ===========================================================
comment c519 ZIRQ - IRQ interrupt routine
comment c519 ===========================================================
comment c519
lcomment c519 first get eventual MIDI data
lcomment c51c then look whether there's a pending VIA interrupt
lcomment c521 if not, EOI
label c522 ZIRQ0
lcomment c522 set VIA Timer 2 to $1E00
const c523
lcomment c525 (5.12ms)
lcomment c528 read 6840 Timer 2
const c531
lcomment c530 6840 Timer 2 = $FFFF
lcomment c533 (10922,5 µs, 10mS ?)
lcomment c539 reallow interrupts (in IRQ???)
lcomment c53b if Bus Command pending,
lcomment c53f return from interrupt
comment c540 the following areas are decremented now:
comment c540 \  Ev1Cnt, Ev2Cnt, Ev3Cnt
label c540 ZIRQ1
label c545 ZIRQ2
lcomment c545 get eventual MIDI data
label c54f ZIRQ3
lcomment c554 decrement current bank (?)
lcomment c558 assure it's in range 0-7
lcomment c55a save on stack for further use
lcomment c55c get eventual MIDI data
lcomment c561 get bank base address ($0110,$0130,...)
lcomment c566 A = LFO Rate for current bank (range 00..124)
lcomment c568 Y = [$0058,$0078,...]
rel c56b 0110
lcomment c56d add LFO Rate + 1 to that
rel c574 0110
lcomment c576 restore current bank into A
lcomment c578 process LFO
lcomment c57b get eventual MIDI data
lcomment c57d and get 4 knob positions
lcomment c580 then return from interrupt
comment c581
comment c581 ===========================================================
comment c581 CMDITH - check for MIDI Input IRQ if ACIA there
comment c581 ===========================================================
comment c581
label c581 CMDITH
label c58b CMDIT0
label c58c CMDIT1

comment c592
comment c592 ===========================================================
comment c592 CKMDIN - check for MIDI Input IRQ
comment c592 ===========================================================
comment c592
label c592 CKMDIN
lcomment c592 look whether MIDI activated
lcomment c594 if not, just fetch an eventual MIDI char and return
lcomment c596 look whether a character arrived
lcomment c599 if not, just get out of here
lcomment c59b waste some time here...
lcomment c59f set up pointer into MIDI buffer
lcomment c5a2 set flag that MIDI data came in
label c5a7 JSysX1
used c5a7
lcomment c5a7 now get the MIDI character
lcomment c5aa ignore realtime MIDI messages
lcomment c5ae store the character and advance the buffer pointer
label c5b0 CKMDI0
lcomment c5b0 if beyond MIDI data buffer end
lcomment c5b5 reset to MIDI buffer start
label c5b8 CKMDI1
lcomment c5b8 remember new buffer pointer
label c5bd CKMDI2
label c5be CKMDI3
lcomment c5be ignore eventual MIDI data

* -----------------------------------------------
* this whole block can presumably be replaced by
* unused c5c2-c5ff
* -----------------------------------------------
comment c5c2 
insert  c5c2 \        IFND NoDead
comment c5c2 DEAD:C0DE from here
const c5c2-c5dd
insert  c5de \        ENDIF
comment c5de 
comment c5de highly questionable whether this is used anywhere
label c5de JSysX2
used c5de
comment c5e2
insert  c5e2 \        IFND NoDead
comment c5e2 DEAD:C0DE from here
const c5e2-c5ff
insert  c600 \        ENDIF
comment c600
insert c600 \        IFND NoOrg
insert c600 \        ORG     $C600
insert c600 \        ENDIF

comment c600
comment c600 ===========================================================
comment c600 Entry Point Table
comment c600 ===========================================================
comment c600

comment c60c
comment c60c ===========================================================
comment c60c CDacCL - calculates new VCA DAC value
comment c60c ===========================================================
comment c60c
label c60c CDacCL
rel c60e 0310

comment c611
comment c611 ===========================================================
comment c611 CDacPL - calculates previous VCA DAC value
comment c611 ===========================================================
comment c611
label c611 CDacPL
rel c613 0310
rel c61d 0310
rel c626 0310
comment c628 and fall thru to...

comment c628
comment c628 ===========================================================
comment c628 ClcLdn - calculates new Loudness value (0..255)
comment c628 ===========================================================
comment c628
label c628 ClcLdn
rel c62c 0110
rel c633 0310
rel c63b 0110
rel c643 0110
comment c645 the following seems to be a goofed Wave/EVU device check...
comment c645 on a Wave, bit 7 of PIATADA is always forced to low,
comment c645 on an EVU, it isn't... BUT on an EVU it reflects the
comment c645 setting of the Group B LED (off when LED is lit), so 
comment c645 the following "BMI" branches only when the Group
comment c645 B LED on the EVU is not lit, i.e., the EVU uses Group A.
comment c645 I can't imagine that this was the original intention.
label c650 ClcLd0
label c651 ClcLd1
rel c653 0110
dec c65c
comment c65d the same comment as above applies here.
dec c663
label c664 ClcLd2
label c66b ClcLd3
rel c66d 0110
dec c672
label c67c ClcLd4
rel c67e 0310
rel c683 0310
rel c68c 0310
label c68f ClcLd5
rel c691 0110
rel c699 0310
label c6a4 RtsC6A4
label c6a5 ClcLd6

comment c6a7
comment c6a7 ===========================================================
comment c6a7 CDacCF - calculates current value for filter DAC
comment c6a7 ===========================================================
comment c6a7
label c6a7 CDacCF
rel c6a9 0310

comment c6ac
comment c6ac ===========================================================
comment c6ac CDacPF - calculates previous value for filter DAC
comment c6ac ===========================================================
comment c6ac
label c6ac CDacPF
rel c6ae 0310
rel c6b7 0310
*const c6c0
rel c6c0 0310
comment c6c2 and fall thru to...

comment c6c2
comment c6c2 ===========================================================
comment c6c2 ClcFlt - calculates new Filter value (0..255)
comment c6c2 ===========================================================
comment c6c2
label c6c2 ClcFlt
lcomment c6c2 generate scaled Env1->VCF
rel c6c5 0110
rel c6c8 0310
lcomment c6cf scale with that
lcomment c6d0 add scaled VCF Cutoff
rel c6d3 0110
rel c6d6 0310
lcomment c6df if KF:1..7 > 0,
rel c6e1 0110
lcomment c6e9 make it 36,72,108,144,180,216,252
lcomment c6ec get current note number in Wave range
rel c6ee 0310
label c6f5 ClcFl0
lcomment c6f5 scale with keyfollow
lcomment c6fc and add that
label c6fe ClcFl1
lcomment c6fe look whether MF:1 set
rel c700 0110
lcomment c706 if so, add/subtract LFO value
rel c708 0110
label c70e ClcFl2
lcomment c70e look whether TF:1 set
rel c710 0110
lcomment c716 if so, add channel pressure
label c71b ClcFl3
lcomment c71b look whether VF:1 set
rel c71d 0110
lcomment c723 if so, add velosity value
rel c725 0310
label c729 ClcFl4
lcomment c729 if BD: affects filter
rel c72b 0110
label c739 ClcFl5
lcomment c739 add/subtract pitch wheel
rel c73d 0110
label c749 RtsC749

comment c74a
comment c74a ===========================================================
comment c74a AddMxFF - adds A and B into A, returns $FF if >= $0100
comment c74a ===========================================================
comment c74a
label c74a AddMxFF
label c752 RtsC752

comment c753
comment c753 ===========================================================
comment c753 AdsMxFF - adds SIGNED A/B into A, confines to $00-$FF range
comment c753 ===========================================================
comment c753
label c753 AdsMxFF
comment c759 come here if (A < 0) and (B >= 0)
label c762 AdsMx0
comment c765 come here if (A >= 0) and (B < 0)
comment c76d come here if (A < 0) and (B < 0)
label c76d AdsMx1
label c771 RtsC771

comment c772
comment c772 ===========================================================
comment c772 AdsM2FF - adds SIGNED A/B into A, confines to $00-$FF range
comment c772 \           the incoming A is in range 0..127
comment c772 \           the incoming B is in range -64..+63
comment c772 \           output range is 0..255
comment c772 ===========================================================
comment c772
label c772 AdsM2FF
label c77b AdsM20

* unused c77c-c78f    * production code;
* for binary compatible output, use the following 5 lines
comment c77c
insert  c77c \        IFND NoDead
comment c77c DEAD:C0DE from here on (?)
const c77c-c78f
insert c790 \        ENDIF
comment c790
insert c790 \        IFND NoOrg
insert c790 \        ORG     $C790
insert c790 \        ENDIF

comment c790
comment c790 ===========================================================
comment c790 SMiSta - send MIDI status byte
comment c790 ===========================================================
comment c790 This routine should be expanded a bit.
comment c790 Currently, the Wave sends the MIDI Status Byte for EVERY MIDI
comment c790 message. The Running Status should be remembered and only sent
comment c790 to Midi Out if changed.
comment c790
label c790 SMiSta
lcomment c790 if MIDI 0 set, get out at once
lcomment c794 set interrupt flag
lcomment c79a look whether MIDI 17 selected
comment c79e I think that there's an error in here and that it should be "BHS"...
comment c79e but that remains to be verified
lcomment c79e if not, decrement A
lcomment c79f save it
lcomment c7a1 retrieve the byte to be sent
dec c7a2
lcomment c7a3 mask out the channel
lcomment c7a5 then save it back on stack
dec c7a6
lcomment c7a7 retrieve MIDI channel from stack
lcomment c7a9 combine MIDI channel with Status
comment c7ab now fall thru to...

comment c7ab
comment c7ab ===========================================================
comment c7ab SMidCB - sends a MIDI Byte if MIDI <> 0
comment c7ab ===========================================================
comment c7ab
label c7ab SMidCB
label c7af SMidC0

comment c7b0
label c7b0 SMidC1
lcomment c7b0 if MIDI 17, just take the channel that came in

comment c7b4
comment c7b4 ===========================================================
comment c7b4 SMidiB - sends a MIDI byte to the ACIA
comment c7b4 ===========================================================
comment c7b4
label c7b4 SMidiB
label c7b6 SMidi0
lcomment c7b6 disallow interrupts
lcomment c7b8 wait until transmit register empty
lcomment c7bf then blow out the character
lcomment c7c2 reallow interrupts

comment c7c6
comment c7c6 ===========================================================
comment c7c6 GMidiB - gets next MIDI byte from MIDI data area
comment c7c6 ===========================================================
comment c7c6
label c7c6 GMidiB
label c7d2 GMidB0

comment c7d7
comment c7d7 ===========================================================
comment c7d7 GLMidB - go to LAST stored MIDI byte in MIDI data area
comment c7d7 ===========================================================
comment c7d7
label c7d7 GLMidB
label c7e1 GLMiB0

comment c7e4
comment c7e4 ===========================================================
comment c7e4 GMIDAB - gets 2 MIDI data bytes
comment c7e4 ===========================================================
comment c7e4
label c7e4 GMIDAB
lcomment c7e4 look whether read<>write pointer
lcomment c7ea if so, get out with carry set
label c7ec GMIDA0
lcomment c7ec then retrieve MIDI byte into B
lcomment c7ee if it was the last byte,
lcomment c7f0 reset position onto last byte and
label c7f2 GMIDA1
lcomment c7f2 return with carry set
label c7f5 GMIDA2
lcomment c7f5 save 1st data byte in A register
lcomment c7f7 and get 2nd data byte in B
lcomment c7f9 then clear carry (i.e., set YUP!)
lcomment c7fb and return

* unused c7fc-c7ff  * for production environment
* for binary compatibility, use these 5 lines
comment c7fc 
insert  c7fc \        IFND NoDead
comment c7fc DEAD:C0DE from here (?)
const c7fc-c7ff
insert c800 \        ENDIF
comment c800
insert c800 \        IFND NoOrg
insert c800 \        ORG     $C800
insert c800 \        ENDIF

comment c800
comment c800 ===========================================================
comment c800 Entry point table
comment c800 ===========================================================
comment c800
used c80c

comment c80f
comment c80f ===========================================================
comment c80f PgChAp - afterprocessing after Program Change and WT Load
comment c80f ===========================================================
comment c80f
label c80f PgChAp
lcomment c812 look whether keyboard PIA IRQA flag set
lcomment c815 (i.e., another beat has passed)
lcomment c815 (or is that 2 beats?)
lcomment c817 if so, load data (reset flag)
const c82c
label c830 PgChA0
const c831
+dec c831
label c833 PgChA1
comment c836 keyboard PIA has been checked
label c836 PgChA2
lcomment c83c if RUN:1
lcomment c842 get 6840 Status register
lcomment c845 look for 6840 Timer 1 interrupt in that
lcomment c848 or in Tm1Stat
lcomment c84a if Timer 1 Interrupt set or remembered,
comment c84e Timer 1 Interrupt has been detected
lcomment c84e clear save place for timer 1 status
label c851 PgChA3
lcomment c867 send MIDI NOTE ON status byte
lcomment c872 if SEQM < 10
dec c873
label c879 PgChA4
dec c87a
rel c87c 0310
dec c888
label c899 PgChA5
label c8a0 PgChA6
lcomment c8a5 send MIDI NOTE OFF status byte
rel c8ab 0310
lcomment c8ac shift note into MIDI range
lcomment c8ae send MIDI note number
rel c8b3 0310
rel c8b8 0310
rel c8ba 0310
lcomment c8bf for NOTE OFF, velocity=0
label c8c0 PgChA7
lcomment c8c0 send out MIDI velocity
rel c8c8 0310
bin c8ca
rel c8cd 0310
lcomment c8d1 if RECM:1,
comment c8d5 come here if 6840 Timer 1 interrupt NOT set
label c8d5 PgChA8
lcomment c8d5 re-allow interrupts

lcomment c8e7 read 6840 Timer 1
const c8ec
+dec c8ec

comment c900 fall thru to...

comment c900
comment c900 ===========================================================
comment c900 G64BCB - receive 64 bytes from comm. bus
comment c900 ===========================================================
comment c900
label c900 G64BCB
used c900
lcomment c900 set up for reception of 64 bytes
lcomment c903 from comm.bus
label c905 G64BC0
lcomment c905 repeat up to 2000 times
const c906
+dec c906
label c908 G64BC1
const c90c
+dec c90c
lcomment c910 look whether data arrived on Comm.Port A
comment c918 the above should not be optimized as it might affect timing
lcomment c915 if so, wait a little bit
lcomment c918 then retrieve new data from Comm.Port A
lcomment c91b store it in buffer
lcomment c91d and add it to checksum
lcomment c924 loop until 64 bytes received
lcomment c926 save new comm.buffer read pointer
comment c929
comment c929 continuation from PgChAp
comment c935 the 2 statements above can cause an endless loop if the Waveterm
comment c935 doesn't send a checksum (dead or programming error)...
const c934
+dec c934
comment c938 the above should not be optimized as it might affect timing
label c940 PgChA9
lcomment c940 something went wrong in transfer, so
lcomment c942 set RUN: 0, modified
lcomment c944 and reset recording channels
label c947 PgChAA
lcomment c947 make all PIA A Lines input
lcomment c94f access PIA A I/O register
label c954 RtsC954

comment c955
label c955 PgChAB
label c965 PgChAC
lcomment c965 copy $2F60-$2FFF to $1F60-$1FFF
label c96e PgChAD
label c97b PgChAE
label c982 PgChAF

comment c993
comment c993 all execution paths in PgChAp come together here
label c993 PgChAG
lcomment c993 reallow interrupts
lcomment c995 reset "command pending" flag
lcomment c99f if Trigger Polarity needs inversion
lcomment c9a4 invert data
label c9a5 PgChAH
lcomment c9a5 save Trigger flag

comment c9a8
comment c9a8 ===========================================================
comment c9a8 PPRKTr - postprocess turned-off keys and trigger signals
comment c9a8 ===========================================================
comment c9a8
label c9a8 PPRKTr
lcomment c9ac if Trigger signal detected,
label c9b1 PPRKT0
rel c9b3 0310
rel c9c0 0310
rel c9c5 0310
label c9c6 PPRKT1
label c9cd PPRKT2
lcomment c9d0 if Edit Mode > 0
lcomment c9d5 and no events buffered yet
lcomment c9db set up event buffer pointer
label c9df PPRKT3
label c9e4 PPRKT4
dec c9e8
label c9eb PPRKT5
dec c9ec
dec c9f0
label c9f4 PPRKT6
label c9f7 PPRKT7
dec ca07
lcomment ca0a send NOTE OFF MIDI message
lcomment ca1a reallow interrupts
lcomment ca23 if Edit Mode > 0
lcomment ca27 add NOTE OFF event to the list
lcomment ca33 append list terminator
lcomment ca37 and set "Yubb, yubb, Event send!" flag
label ca3c PPRKT8
dec ca41
lcomment ca4d turn note off (start release phase)
label ca5b PPRKT9

comment ca5f
comment ca5f ===========================================================
comment ca5f GNtVce - looks up the voice for a note
comment ca5f ===========================================================
comment ca5f on entry, B register contains the note number (PRK range)
comment ca5f and X register contains the voice address
comment ca5f ($0310 <= X <= $0317) to start from
comment ca5f on exit, X points to voice (or $0318 if none)
comment ca5f
label ca5f GNtVce
label ca61 GNtVc0
rel ca63 0310
label ca71 GNtVc1

comment ca74
comment ca74 ===========================================================
comment ca74 PPrkEv - process received PRK Keyboard Events
comment ca74 ===========================================================
comment ca74
label ca74 PPrkEv
lcomment ca74 reallow interrupts
lcomment ca76 reset "Command Pending" flag
lcomment ca7d get SEQM without Modified flag
dec ca82
lcomment ca83 if SEQM = 98
comment ca87 come here if SEQM:98
label ca96 PPrkE0
label ca99 PPrkE1
label ca9d PPrkE2
dec caa0
lcomment caa7 trigger works different for
dec caa8
lcomment caa9 keyboard modes < 4
lcomment caad and >= 4

comment cab0 come here if SEQM <> 98
label cab0 PPrkE3
lcomment cab0 look whether Event reception allowed
lcomment cab3 if it's < 0 (i.e., bit 7 set)
lcomment cab5 reset bit 7 (do this only ONCE)
lcomment caba initialize some memory areas
lcomment cabd do for all 8 voices:
label cac0 PPrkE4
lcomment cac0 turn voice off (start release phase)
lcomment caca then clear Event Received flag
label cacd PPrkE5
lcomment cacd now process all buffered MIDI In bytes
lcomment cad0 if Event Processing allowed,
lcomment cad7 look whether PRK Events came in
lcomment cada if so,
lcomment cadc position on buffer start
lcomment cae0 make sure it's terminated correctly
label cae5 PPrkE6
lcomment cae5 get current note event
lcomment cae9 if it's not the $FF terminator,
lcomment caeb check for Mod Wheel event
dec caec
lcomment caef check for Pitch Wheel event
dec caf0
lcomment caf3 process normal PRK Note event
lcomment caf5 and go on processing
label caf7 PPrkE7
lcomment caf7 if all events processed,
lcomment cafa do other nice things :-)
comment cafd come here if Pitch Wheel Position event received
label cafd PPrkE8
lcomment cafd store new pitch wheel position
lcomment cb00 and go on processing
comment cb02 come here if Mod Wheel Position event received
label cb02 PPrkE9
lcomment cb02 store new Mod Wheel position
comment cb05 OUCH, OUCH! Mod Wheel position always goes to Bank 0!!
lcomment cb05 and go on processing

comment cb07
comment cb07 ===========================================================
comment cb07 PPrkNt - processes a note event coming from the PRK
comment cb07 ===========================================================
comment cb07
label cb07 PPrkNt
lcomment cb07 look whether it's a NOTE OFF event
lcomment cb08 if not,
lcomment cb0a save velocity information
lcomment cb0f and process NOTE ON event
label cb14 PPrkN0
comment cb15 come here for NOTE OFF events
label cb15 PPrkN1
lcomment cb15 find channel for that note
lcomment cb1b if it is not played on a channel,
lcomment cb1e just return
lcomment cb20 turn that channel off
lcomment cb22 and continue walking thru the channels
label cb18 PPrkN2

comment cb26
comment cb26 ===========================================================
comment cb26 TnVOff - turns a voice off
comment cb26 ===========================================================
comment cb26
label cb26 TnVOff
lcomment cb26 get byte at ($328+voice#)
rel cb28 0310
lcomment cb29 examine bit 1 in there
lcomment cb2b if set, return (release phase?)
lcomment cb2f set bit 6 in ($310+voice#)
lcomment cb33 set bits 5&6 in ($330+voice#)
rel cb35 0310
rel cb3a 0310
lcomment cb3b set bit 7 in ($328+voice#)
rel cb3d 0310
rel cb42 0310
lcomment cb45 if RUN:1
lcomment cb47 and RECM:0
lcomment cb4b and $00C0 <> 0
lcomment cb4f and bit 2 is set in ($330+voice#)
rel cb51 0310
comment cb56 come here if RUN:1, RECM:0, $00C0<>0, and bit 2 set in ($330+voice#)
lcomment cb56 save a bunch of registers
lcomment cb5a B contains Voice# now
lcomment cb5e A = [$00C0] (sequencer bit mask?)
label cb61 TnVOf0
lcomment cb61 shift bit corresponding to voice 
lcomment cb62 into carry bit
lcomment cb65 restore voice#
lcomment cb67 if seq.bit(?) is set for this voice
lcomment cb69 do this... whatever this is :-)
label cb6c TnVOf1
lcomment cb6c restore registers
label cb6e TnVOf2

comment cb6f
comment cb6f ===========================================================
comment cb6f ChkTrg - checks TRIG IN for changes
comment cb6f ===========================================================
comment cb6f On Exit, Carry flag is set upon Transition from TRIG 1 to 0
comment cb6f
label cb6f ChkTrg
lcomment cb73 look whether TRIG IN set
comment cb77 come here if TRIG IN clear
comment cb7a the above instruction can be safely removed
comment cb7a (result of a TAB convenience instruction)
lcomment cb7a mask out bit 2
+bin cb7b
lcomment cb7c and save new flag set (?)
lcomment cb80 if bit 2 was set before,
lcomment cb82 set carry
label cb84 RtsChkT
comment cb85 come here if TRIG IN set
label cb85 ChkTr0
lcomment cb85 set bit 2 in flag set (?)
label cb89 ChkTr1
lcomment cb89 reset carry

comment cb8c
comment cb8c ===========================================================
comment cb8c TTNtOn - turn on note if trigger signal set
comment cb8c ===========================================================
comment cb8c
label cb8c TTNtOn

lcomment cb8e if Trigger detected,
lcomment cb90 get note to start
lcomment cb92 and turn it on

comment cb95
comment cb95 ===========================================================
comment cb95 PPPKTr - postprocess newly pressed keys & Trigger ON
comment cb95 ===========================================================
comment cb95
label cb95 PPPKTr
lcomment cb97 if Trigger detected,
lcomment cb99 get note to start
lcomment cb9b and turn it on
label cb9e PPPKT0
lcomment cb9e reset $0024 (???)
comment cba0 and fall thru to...

comment cba0
comment cba0 ===========================================================
comment cba0 PPPK - postprocess newly pressed keys
comment cba0 ===========================================================
comment cba0
label cba0 PPPK

lcomment cba0 reset # checked keys
lcomment cba1 clear lowest bit in $0012 (?)
lcomment cba7 position on keyboard status
label cbab PPPK0
lcomment cbab load 8 bits from KbdSSav (previous state)
+dec cbac
lcomment cbad invert previous state
lcomment cbae and AND with current state
lcomment cbae (giving mask of all new turned on keys)
lcomment cbb0 if new keys pressed, jump
label cbb2 PPPK1
lcomment cbb2 otherwise add 8 to # processed keys
+dec cbb3
lcomment cbb4 position on next 8-key byte
lcomment cbb6 if not yet behind the keyboard boundary,
+dec cbb7
lcomment cbb8 continue scan for new keys
comment cbba come here if no new keys have been pressed
lcomment cbba if there are events buffered
lcomment cbc1 make sure list terminator is in place
lcomment cbc9 now set up a little loop...
+dec cbca
label cbcb PPPK2
lcomment cbcb try up to 200 times to tell that bloody 
lcomment cbcd Master that we've got something to send
lcomment cbd3 if we're ignored, forget events
label cbda PPPK3
lcomment cbda reset "Events buffered" flag
label cbdf RtsPPPK

comment cbe0
comment cbe0 come here if one or more keys have just been pressed
label cbe0 PPPK4
lcomment cbe0 WkByt0 = # already tested keys before this bit mask
lcomment cbe2 reset #processed bits in this key mask
label cbe3 PPPK5
lcomment cbe3 process another bit
+dec cbe5
lcomment cbe6 if not yet all 8 bits checked,
lcomment cbe8 shift highest bit into carry
lcomment cbe9 if carry clear, continue loop
lcomment cbe9 otherwise (if key pressed):
lcomment cbeb save bit# in this byte
lcomment cbed make it a real key number
lcomment cbef in the PRK range
+dec ebf0
lcomment cbf1 save bit mask (might contain other new keys!)
lcomment cbf3 blow out a NOTE ON MIDI status
lcomment cbfa shift note into MIDI range
lcomment cbff and give it medium velocity
lcomment cc04 reallow interrupts
lcomemnt cc06 reset "Command Pending" flag (?)
lcomment cc08 store 7/8 max. as current velocity
lcomment cc12 if Edit Mode > 0,
lcomment cc14 append a NOTE ON event
lcomment cc18 with velocity 224
lcomment cc22 append event list terminator
lcomment cc28 set "Events to transmit" flag
dec cc27
label cc2b PPPK6
lcomment cc2b now turn internal note on
lcomment cc2e restore pointer into keys
lcomment cc30 \  and current key mask
lcomment cc32 \  and #processed keys in this byte
lcomment cc34 and continue scanning for new keys
comment cc36 come here when all 8 bits have been processed
label cc36 PPPK7
lcomment cc36 restore #keys processed
lcomment cc38 and continue with next key byte

comment cc3b
comment cc3b ===========================================================
comment cc3b PMDINX - terminates PMIDIN processing
comment cc3b ===========================================================
comment cc3b called from 842F
comment cc3b
label cc3b PMDINX
lcomment cc3b store MIDI read pointer
lcomment cc3f reallow interrupts
lcomment cc44 if NOTE ON has been received,
lcomment cc49 set the carry flag
label cc4d PMDIXE
lcomment cc4d otherwise clear it

comment cc51
comment cc51 ===========================================================
comment cc51 PMIDIN - process all buffered MIDI In bytes
comment cc51 ===========================================================
comment cc51 Upon return, the Carry flag is set if NOTE ON messages 
comment cc51 have been received
comment cc51
label cc51 PMIDIN
lcomment cc51 reset some flag(???)
lcomment cc54 look whether MIDI processing activated
lcomment cc58 if not, clear carry and return
label cc5d PMDIN0
lcomment cc5d save a bunch of registers
lcomment cc63 look whether ACIA looks OK
lcomment cc68 if not, stop MIDI processing
lcomment cc6a and terminate
label cc6c PMDIN1
lcomment cc6c assure high bit of MIDI channel is reset
lcomment cc6e (whatever that's good for...)
comment cc72 and fall thru to...
comment cc72
comment cc72 ===========================================================
comment cc72 PNMIDB - process next incoming MIDI byte, if there's any
comment cc72 ===========================================================
comment cc72 this is no separate function, but jumped to from various locations
comment cc72 throughout the code.
comment cc72
label cc72 PNMIDB
lcomment cc72 look whether there are new MIDI bytes
lcomment cc76 if not, terminate
lcomment cc78 retrieve first unprocessed MIDI byte
lcomment cc7d if it was the last one, reset to it
lcomment cc80 and return
comment cc82
comment cc82 process MIDI control characters (bit 7 set) here
comment cc82 if MIDI 18 selected on MAIN display
label cc82 PNMID0
lcomment cc84 subtract 8 from MIDI channel
lcomment cc88 process if result >= 0 (i.e., if it was 8-15)
comment cc8d
label cc8d PNMID1
lcomment cc8d if bit 7 of MIDI byte NOT set
comment cc92 process MIDI control characters (bit 7 set) here
lcomment cc92 get MIDI Channel selected on MAIN display
lcomment cc94 shift into MIDI range (00..0F)
lcomment cc95 process MIDI 18 special case
lcomment cc99 process MIDI 17 special case
comment cc9d process MIDI control characters (bit 7 set) here
comment cc9d if MIDI 17 selected on MAIN display
lcomment cc9f look whether MIDI channel is in 0-7
comment cca5
label cca5 PNMID2
lcomment cca5 invalid channel - reset stack and current status
comment ccaa
comment ccaa come here when MIDI 17/18 and channel validated
comment ccaa and put into range 0-7
label ccaa PNMID3
lcomment ccaa assure channel is in range 0-7

comment ccb3
comment ccb3 process MIDI Status characters here
comment ccb3 when MIDI is between 01 and 16 on MAIN display
label ccb3 PNMID4
lcomment ccba restore MIDI status byte
lcomment ccbc compare incoming to selected MIDI channel
lcomment ccc6 only process if right channel!
label ccca PNMID5
lcomment ccca eventually branch to SysEx Start processing
lcomment ccd0 eventually branch to SysEx End processing
lcomment ccd6 OK, correct channel, clear it, since...
label ccd8 PNMID6
used ccd8
lcomment ccd8 we need to convert status byte into table entry
lcomment cce0 now jump to the code corresponding
lcomment cce3 to this MIDI status
comment cce5
comment cce5 come here for MIDI data bytes (not Status)
label cce5 PNMID7
lcomment cce5 look whether currently in a MIDI message
lcomment ccea if not, process next byte
lcomment ccf4 position on last processed byte
lcomment ccf9 now jump to the code corresponding
lcomment ccfc to the current MIDI status

comment ccfe
insert  ccfe \        IFND NoDead
comment ccfe DEAD:C0DE from here
data ccfe-ccff
insert cd00 \        ENDIF
comment cd00
insert cd00 \        IFND NoOrg
insert cd00 \        ORG     $CD00
insert cd00 \        ENDIF

comment cd00
comment cd00 ===========================================================
comment cd00 Entry point table
comment cd00 ===========================================================
comment cd00

comment cd09
comment cd09 ===========================================================
comment cd09 FVttOn - finds a voice to turn on
comment cd09 ===========================================================
comment cd09 on entry:
comment cd09 \  A ... bit mask; 1 marks a voice NOT to use
comment cd09 \  B ... a note number to be turned on
comment cd09 on exit:
comment cd09 \  B ... a note number to be turned on
comment cd09 \  X ... pointer to found voice
comment cd09 \  Carry is set if nothing found, else clear
comment cd09
label cd09 FVttOn
lcomment cd09 walk thru $0310-$0317 (voices?)
lcomment cd0e A |= ~[$0229]
label cd17 FVttO0
lcomment cd17 shift bit corresponding to voice# into carry flag
lcomment cd18 if that bit is clear, goto processing
lcomment cd1f if all 8 voices checked,
lcomment cd21 reset to $0310
lcomment cd24 restore the note number
lcomment cd26 set carry
lcomment cd28 and return
label cd29 FVttO1
comment cd29 come here if a clear bit found
lcomment cd29 get [$0310+offset]
rel cd2a 0310
label cd2e FVttO2
label cd39 FVttO3

comment cd47
comment cd47 ===========================================================
comment cd47 TnNtOn - turns a note on
comment cd47 ===========================================================
comment cd47 on entry, B contains the note number (PRK range) to be turned on
comment cd47
label cd47 TnNtOn
lcomment cd52 if Keyboard Split <> 0
lcomment cd54 and Component not 2 or 3
lcomment cd5f add 8 to keyboard split point (???)
label cd61 TnNtO0
lcomment cd63 compare note to split point
comment cd67 come here if note < splitpoint
lcomment cd67 get current keyboard mode
lcomment cd6b if KbdMode < 4 (both groups on one key),
dec cd6c
lcomment cd6f re-get note to turn on
lcomment cd71 note = note - 9
dec cd72
lcomment cd73 make sure it doesn't go below 0
label cd76 TnNtO1
lcomment cd76 store as seq.transpos. and return
comment cd7a come here if (note < splitpoint) and (KbdMode >= 4)
comment cd7a i.e., Note is for Group B, which plays on lower part
label cd7a TnNtO2
lcomment cd7a if KbdMode >= 10,
dec cd7b
lcomment cd7c return
lcomment cd7e convert keyboard mode into table entry
comment cd84 come here if note >= splitpoint
comment cd84 i.e., Note is for Group A, which plays on upper part
label cd84 TnNtO3
lcomment cd84 get current keyboard mode
dec cd89
lcomment cd8a if it's <= 4,
lcomment cd8c add Ext CV Note to key number
label cd8e TnNtO4
lcomment cd8e if KbdMode >= 10,
dec cd8f
lcomment cd90 return
lcomment cd92 convert keyboard mode into table entry
lcomment cd96 and jump according to KBM

comment cd98
comment cd98 come here for note < split point and 0 <= KBM <= 5
label cd98 TnNtO5
lcomment cd98 add Ext CV Note to key number
bin cd9b

comment cd9e
comment cd9e come here for note < split point and KBM = 6
label cd9e TnNtO6
lcomment cd9e add Ext CV Note to key number
binary cda1
label cda2 TnNtO7

comment cda8
comment cda8 come here for note < split point and KBM = 7
label cda8 TnNtO8
dec cdae

comment cdaf
label cdaf TnNtO9
*dec cdb2
rel cdb2 0310

label cdb8 RTnNtOn  * called quite often...

comment cdb9
comment cdb9 come here for note < split point and KBM = 8
label cdb9 TnNtOA
label cdbe TnNtOB

comment cdca
comment cdca come here for KBM = 9, regardless of split point
label cdca TnNtOC
label cde8 TnNtOD
comment cded
label cded TnNtOE
rel cdee 0310

comment cdf9
comment cdf9 come here for note >= split point and KBM = 0
label cdf9 TnNtOF
label ce10 TnNtOG

comment ce1c
label ce1c LFVttOn

comment ce1f
label ce1f TnNtOH

comment ce24
label ce24 TnNtOI
rel ce25 0310

comment ce2c
comment ce2c come here for note >= split point and KBM = 1
label ce2c TnNtOJ
binary ce2d

comment ce3b
comment ce3b come here for note >= split point and KBM = 2
label ce3b TnNtOK
binary ce3c

comment ce43
comment ce43 come here for note >= split point and KBM = 3
label ce43 TnNtOL

comment ce4a
label ce4a TnNtOM

comment ce58
comment ce58 come here for note >= split point and KBM = 4
label ce58 TnNtOO
binary ce59

comment ce60
comment ce60 come here for note >= split point and KBM = 5/8
label ce60 TnNtOP
label ce63 TnNtOQ
label ce6e RTnNt0

comment ce6f
comment ce6f come here for note >= split point and KBM = 6
label ce6f TnNtOR

comment ce7a
comment ce7a come here for note >= split point and KBM = 7
label ce7a TnNtOS
binary ce7b

comment ce80
label ce80 TnNtOT
rel ce83 0310

comment ce89
label ce89 TnNtOU
rel ce8c 0310

comment ce92
comment ce92 ===========================================================
comment ce92 TOnVGB - turn on a voice with Group B settings
comment ce92 ===========================================================
comment ce92
label ce92 TOnVGB
rel ce94 0310
bin ce99
bin ce9b

comment cea0
comment cea0 ===========================================================
comment cea0 TOnVGA - turn on a voice with Group A settings
comment cea0 ===========================================================
comment cea0
label cea0 TOnVGA
rel cea2 0310
bin cea7
bin cea9
comment ceac and fall thru to...

comment ceac
comment ceac ===========================================================
comment ceac TOnVG0 - used from the above 2 entry points
comment ceac ===========================================================
comment ceac
label ceac TOnVG0
rel ceae 0310
lcomment ceb1 store at V2BAsg[voice]
rel ceb3 0310
label ceba TOnVG1
rel cebb 0310
comment ceb5
comment ceb5 the following looks like a LRU algorithm setup...
lcomment ceb7 do for X = $0310..$0317
lcomment ceba A = M0310[voice]
lcomment cebc B = A & 0x3f
lcomment cec3 if B != 63,
lcomment cec5 M0310[voice]++
label cec8 TOnVG2
comment cebf obviously a "TAB" convenience mnemonic; the "TSTA" can be safely removed
comment ced1 come out with B = ([$0317] & 0x3f)
comment ced1
rel cee4 0310
dec ced5
lcomment ced8 A = (MIDI Velocity / 2) + 160
dec cedd
lcomment cede if that's above 255 (unlikely),
lcomment cee0 use 253
dec cee1
label cee2 TOnVG3
comment cee6
label cee6 TOnVG4
lcomment cee9 if receiving events from other components,
comment ceed 
comment ceed in the following pseudocode statements, the hypothetical function
comment ceed SnsCalc has the prototype
comment ceed \  unsigned char SnsCalc(unsigned char nVel, int SensIndex);
comment ceed where nVel is the current Velocity (range 0..FF) and SensIndex is an index into
comment ceed the possible Sensitivity values (0=Volume, 1=Bank Select,...,7=Pitch Bend)
comment ceed 
comment ceed EOFVal[voice] = ((~SnsCalc(127,3)) & 0x3f) + SnsCalc(velocity,3)
comment ceed Exemplary result values:
comment ceed \  EOFSensitivity: |   0   1   2   3   4   5   6   7
comment ceed \  ----------------+--------------------------------
comment ceed \  Velocity:    1  |  63  52  41  31  22  14   7   0
comment ceed \  Velocity:   64  |  63  58  52  47  43  39  35  31
comment ceed \  Velocity:  128  |  63  64  64  64  64  64  64  63
comment ceed \  Velocity:  192  |  63  70  75  80  85  89  92  95
comment ceed \  Velocity:  255  |  63  75  86  96 105 113 120 126
comment ceed This spreads the values based on the center value.
comment ceed 
lcomment ceed Y = & EOFVal[voice]
rel ceef 0310
lcomment cef1 Envelope-On-Filter Sensitivity (0-7)
lcomment cef9 A = (~A) & 0x3f
lcomment cefa \  results in $(3F,34,29,1F,16,0E,07,00)
lcomment cefc save that for later
lcomment cefe scale MIDI Velocity according to EOF Sens.
lcomment cf01 add that to saved value
lcomment cf03 and save the result in EOFVal[voice]
comment cf05
comment cf05 VelVal[voice] = ((~SnsCalc(255,0)) & 0x7f) + SnsCalc(velocity,0)
comment cf05 Exemplary result values:
comment cf05 \  VOLSensitivity: |   0   1   2   3   4   5   6   7
comment cf05 \  ----------------+--------------------------------
comment cf05 \  Velocity:    1  | 127 104  82  62  44  28  14   1
comment cf05 \  Velocity:   64  | 127 110  93  78  65  53  42  32
comment cf05 \  Velocity:  128  | 127 116 105  95  86  78  71  64
comment cf05 \  Velocity:  192  | 127 122 116 111 107 103  99  96
comment cf05 \  Velocity:  255  | 127 127 127 127 127 127 127 127
comment cf05
lcomment cf05 Y = & VelVal[voice]
rel cf07 0310
lcomment cf09 Volume Sensitivity (0-7)
lcomment cf11 A = (~A) & 0x7f
lcomment cf12 \  results in $(7F,68,52,3E,2C,1C,0E,01)
lcomment cf14 save that for later
lcomment cf16 scale MIDI Velocity according to Vol Sens.
lcomment cf19 add that to saved value
lcomment cf1b and save the result in VelVal[voice]
comment cf1d
comment cf1d WVSVal[voice] = SnsCalc(velocity,2)
comment cf1d Exemplary result values:
comment cf1d \  WVSSensitivity: |   0   1   2   3   4   5   6   7
comment cf1d \  ----------------+--------------------------------
comment cf1d \  Velocity:    1  |   0   0   0   0   0   0   0   0
comment cf1d \  Velocity:   64  |   0   6  11  16  21  25  28  31
comment cf1d \  Velocity:  128  |   0  12  23  33  42  50  57  63
comment cf1d \  Velocity:  192  |   0  18  34  49  63  75  85  95
comment cf1d \  Velocity:  255  |   0  23  45  65  83  99 113 126
comment cf1d
lcomment cf1d Y = & WVSVal[voice]
rel cf1f 0310
lcomment cf21 Waveform Select Sensitivity (0-7)
lcomment cf24 calculate and store based on Velocity
comment cf27
comment cf27 AVEVal[voice] = SnsCalc(max(255-velocity-40,0),4)
comment cf27 Exemplary result values:
comment cf27 \  AVESensitivity: |   0   1   2   3   4   5   6   7
comment cf27 \  ----------------+--------------------------------
comment cf27 \  Velocity:    1  |   0  20  38  55  70  83  95 106
comment cf27 \  Velocity:   64  |   0  14  27  38  49  58  67  74
comment cf27 \  Velocity:  128  |   0   8  15  22  28  33  38  43
comment cf27 \  Velocity:  192  |   0   2   4   5   7   8  10  11
comment cf27 \  Velocity:  255  |   0   0   0   0   0   0   0   0
comment cf27
lcomment cf27 Y = & AVEVal[voice]
rel cf29 0310
lcomment cf2b Attack Volume Envelope Sensitivity (0-7)
lcomment cf2e A = $FF - Velocity
lcomment cf33 calc sens with max(A-40, 0)
comment cf36
comment cf36 AFEVal[voice] = SnsCalc(max(255-velocity-40,0),5)
comment cf36 Results in the same exemplary values as above
comment cf36
lcomment cf36 Y = & AFEVal[voice]
rel cf38 0310
lcomment cf3a Attack Filter Envelope Sensitivity (0-7)
lcomment cf3d A = $FF - Velocity
lcomment cf42 calc sens with max(A-40, 0)
comment cf45
comment cf45 DFEVal[voice] = SnsCalc(max(velocity-40,0),6)
comment cf45 DFESensitivity: |   0   1   2   3   4   5   6   7
comment cf45 ----------------+--------------------------------
comment cf45 Velocity:    1  |   0   0   0   0   0   0   0   0
comment cf45 Velocity:   64  |   0   2   4   6   7   9  10  11
comment cf45 Velocity:  128  |   0   8  15  22  28  34  39  43
comment cf45 Velocity:  192  |   0  14  27  39  49  59  67  75
comment cf45 Velocity:  255  |   0  20  38  55  70  83  95 106
comment cf45
lcomment cf45 Y = & DFEVal[voice]
rel cf47 0310
lcomment cf49 Decay Filter Envelope Sensitivity (0-7)
lcomment cf4f calc sens with max(A-40, 0)

comment cf52
comment cf52 an interesting omission ... in V4, the following code was here:
comment cf52 ----------------------------------------------------
comment cf52 \        LEAY    PBEVal-VceLRU,X
comment cf52 \        LDB     VelParm+7
comment cf52 \        LDA     MIVelo
comment cf52 \        SUBA    #$40
comment cf52 \        BCC     TOnVGx
comment cf52 \        CLRA
comment cf52 TOnVGx  JSR     SnsCalc
comment cf52 ----------------------------------------------------
comment cf52
comment cf52 come here if not receiving events or calculation done
label cf52 TOnVG5
comment cf5c the above instruction plus the one below at $CF98 can be safely removed
rel cf64 0310
rel cf6a 01a5
label cf72 TOnVG6
label cf77 TOnVG7
label cf7e TOnVG8
label cf87 TOnVG9
label cf94 TOVG10
comment cf9a the above instruction plus the one above at $CF5A can be safely removed
label cf9a TOVG11
rel cf9c 0310
rel cfa0 0310
comment cfa2
lcomment cfa7 Bank Select Sensitivity (0-7)
comment cfac the next 3 instructions are really MEAN code...
comment cfac the called subroutine STORES to ,Y, which does nothing for the Sax Sound...
comment cfac only the result in A is used.
comment cfac Since this is the ONLY use of the subroutine as far as I can tell,
comment cfac the Y setup/storing could be removed. Some old code?
label cfc0 TOVG12
rel cfc2 0310
comment cfc4
label cfc4 TOVG13
comment cfc9 B can be used here as it's not used until reload at $D021

rel cfca 0310
rel cfd2 0310
rel cfd6 0310
label cfda TOVG14
rel cfdc 0310
label cfe1 TOVG15
label cfeb TOVG16
rel cff6 0310
rel cffd 0110
rel d000 0310
rel d004 0310
label d008 TOVG17
rel d00a 0310
label d00c TOVG18
lcomment d00c examine device capabilities
lcomment d00f if in 2.2 mode,
lcomment d011 use Bank 0 in any case
label d012 TOVG19
label d01a TOVG20
lcomment d01a create PRZOPA value for this voice
lcomment d01b \  (bank << 5) + voice#
lcomment d027 save that
rel d029 0310
dec d02c
rel d02f 0310
rel d032 0310
rel d037 0310
rel d039 0310
rel d03c 0310
rel d03f 0110
rel d048 0310
label d049 TOVG21
rel d04d 0310
rel d04f 0110
rel d058 0310
label d059 TOVG22
lcomment d059 position on Env2 settings
*rel d05a 0310
dec d05a

comment d062
comment d062 ===========================================================
comment d062 M40Calc - calculates Sensitivity for max(value-40,0)
comment d062 ===========================================================
comment d062
label d062 M40Calc
lcomment d062 A -= 40
dec d063
lcomment d064 if below 0,
lcomment d066 make it 0
lcomment d067 in any case, calculate sensitivity value

comment d069
comment d069 ===========================================================
comment d069 MVSCalc - calculates MIDI Velocity Sensitivity
comment d069 ===========================================================
comment d069
label d069 MVSCalc
comment d06c and fall thru to...

comment d06c
comment d06c ===========================================================
comment d06c SnsCalc - calculates a sensitivity value
comment d06c ===========================================================
comment d06c calculates a sensitivity value according to the following formula:
comment d06c \  A = (A \* SnsMul[B & 0x07]) >> 8
comment d06c Entry:
comment d06c \  A ... value to be quantized
comment d06c \  B ... quantization index
comment d06c \  Y ... pointer to target (A is stored there)
comment d06c Exit:
comment d06c \  A ... high value of multiplication
comment d06c
label d06c SnsCalc

comment d07b
comment d07b ===========================================================
comment d07b Scale8 - scales incoming value 0..7 into 00,0F,1F,2F,3F..6F
comment d07b ===========================================================
comment d07b
label d07b Scale8
label d082 Scal80
label d08a Scal81

comment d090
comment d090 ===========================================================
comment d090 CEGStV - calculates an EG's start value
comment d090 ===========================================================
comment d090 upon entry:
comment d090 \  X ... $0310..$310/$0318..$031F
comment d090 \  Y ... Bank Base Address / Bank Base Address + 1
comment d090
label d090 CEGStV
lcomment d090 reset EG counter
rel d092 0310
lcomment d093 set EG mode to "Attack" and set bit 7
lcomment d095 (whatever that's good for; it's never reset)
rel d097 0310
lcomment d098 get current EG output value / 2
rel d09a 0310
lcomment d09c reset Lag index
rel d09e 0310
lcomment d09f calculate new lag index
rel d0a0 0110
rel d0a3 0310
lcomment d0a7 but only if resulting Attack is <= 1F
lcomment d0ad in this case, use (Attack >> 3) as index
lcomment d0b0 table holding the values 3,1,2,0
rel d0b7 0310
lcomment d0b8 and use FF as start value
label d0ba CEGSt0
lcomment d0ba save new EG value
rel d0bc 0310

comment d0be
comment d0be ===========================================================
comment d0be IniVcS - initializes a voice state
comment d0be ===========================================================
comment d0be upon entry:
comment d0be \  B ... old content of VcFlg1[voice]
comment d0be side effects:
comment d0be \  A is destroyed
comment d0be
label d0be IniVcS
lcomment d0be mask out bits 2,4
+bin d0bf
lcomment d0c0 if (TrgChg & 0x01)
lcomment d0c6 mask in bit 1
+bin d0c7
label d0c9 IniVc0
lcomment d0c9 else mask out bit 1
+bin d0ca

* unused d0cc-d0ff   * for production code
* for binary compatibility, use the following 5 lines
comment d0cc
insert  d0cc \        IFND NoDead
comment d0cc DEAD:C0DE from here on (?)
const d0cc-d0ff
insert d100 \        ENDIF
comment d100
insert d100 \        IFND NoOrg
insert d100 \        ORG     $D100
insert d100 \        ENDIF

comment d100
comment d100 ===========================================================
comment d100 ClcKFL - calculates Keyfollow->Loudness
comment d100 ===========================================================
*comment d100 On Entry:
*comment d100 \  A ... Key
*comment d100 \  B ... Keyfollow Loudness value
*comment d100 \  U ... current voice
comment d100
label d100 ClcKFL
*lcomment d104 can be safely removed
*lcomment d108 can be safely removed
dec d107
rel d110 0310
dec d114
label d115 ClKFL0
label d11a ClKFL1
rel d11d 0310
dec d11f
dec d123
label d124 ClKFL2
label d127 ClKFL3
label d129 ClKFL4

comment d12d
comment d12d ===========================================================
comment d12d SetOT12 - sets a 12-bit oscillator for a transient sound
comment d12d ===========================================================
comment d12d this is used for Wave 2.3 / EVU instead of the code at $D596
label d12d SetOT12
rel d12f 0110
dec d131
dec d135
comment d13a come here if bank holds a Transient Sound
label d13a StOT10
rel d13c 0310
label d141 StOT11
used d141
rel d143 0110
lcomment d146 if Double-bank sound,
lcomment d14b mask out lowest bit of bank#
+bin d14c
label d150 StOT12
lcomment d155 maybe something with transient sound flag (?)
lcomment d15e wait a little bit
lcomment d165 turn OFF Transient Sound flag
lcomment d170 wait a little bit
lcomment d176 turn ON Transient Sound Flag
comment d180
insert  d180 \        IFND NoDead
comment d180 the next 3 instructions look like DEAD:C0DE 
data d180-d186
const d180-d186
rel d182 0310
insert d187 \        ENDIF
comment d187
label d187 StOT13
lcomment d187 get Env1->Waves for current bank
rel d188 0110
+dec d18a
label d191 StOT14
lcomment d191 turn ON Transient Sound Flag
rel d196 0110
lcomment d199 if double-bank sound,
lcomment d19e mask in lowest bit of bank#
comment d1a5 come here if single-bank sound
label d1a5 StOT15
rel d1a7 0310
label d1ad StOT16
label d1af StOT17

label d1b9 RtsD1B9

comment d1ba
insert  d1ba \        IFND NoDead
comment d1ba DEAD:C0DE from here on (?)
const d1ba-d1ff
insert d200 \        ENDIF
comment d200
insert d200 \        IFND NoOrg
insert d200 \        ORG     $D200
insert d200 \        ENDIF

comment d200
comment d200 ===========================================================
comment d200 Entry point table
comment d200 ===========================================================
comment d200
used d203
lcomment d203 seems to be an unused entry point

comment d206
comment d206 ===========================================================
comment d206 SetVcs - sets up all 8 voices
comment d206 ===========================================================
comment d206
label d206 SetVcs
lcomment d206 initialize bDoFresh to $20
const d20e
lcomment d210 SVcPrc[0..7] = $20
comment d21b
comment d21b outer loop; is run twice, the first time with bDoFresh set to $20,
comment d21b the second time with bDoFresh set to $DF (i.e., ~$20)
label d21b SetVc0
lcomment d21b X is OF4 #1 Base Address now
lcomment d21e U is base pointer to voice-specific data
lcomment d221 save that in WkPtr1
comment d223
comment d223 inner loop over the 8 voices (loop end at $D4DD)
comment d223 this loop is run twice; in the first iteration, all voices that
comment d223 have just been turned on are processed; in the second iteration,
comment d223 all voices that have already been running are processed.
label d223 SetVc1
lcomment d223 A = VcFlg1[voice] ^ bDoFresh
rel d225 0310
lcomment d22a if (!(A & 0x20)),
lcomment d22e A = SVcPrc[voice]
rel d230 0310
lcomment d231 if SVcPrc[voice] is not empty,
comment d235
lcomment d235 Y = Group A base address
lcomment d239 A = V2BAsg[voice]
rel d23b 0310
lcomment d23f if (V2BAsg[voice] & 1),
lcomment d241 Y = Group B base address
rel d243 0110
label d244 SetVc2
lcomment d244 save base address
comment d247 --- until here ----------------
comment d247
lcomment d247 Y = BnkBsAd[V2BAsg[voice]]
comment d24f
insert  d24f \        IFND NoDead
comment d24f --- DEAD:C0DE from here on ----
rel d25c 0310
rel d263 0110
comment d267 --- until here ----------------
insert d267 \        ENDIF
comment d267
label d267 SetVc3
lcomment d268 turn off OF4 1 Voice Latches
lcomment d26b turn off OF4 2 Voice Latches

lcomment d272 if RUN:1,
lcomment d274 set "Command Pending" flag
lcomment d276 initialize to return "1"
dec d277
lcomment d278 if keyboard interrupt,
lcomment d280 or 6840 Timer 1 interrupt,
lcomment d282 return with A=1
lcomment d284 if neither, reallow interrupts
lcomment d286 and clear "Command Pending" flag
label d28a LbVc33
lcomment d28a effectively "INS"/"RTS"

comment d28d come here if RUN:0
label d28d SetVc4
lcomment d28d initialize to return "2"
dec d28e
lcomment d28f get Comm.Bus Port B
lcomment d292 look whether it contains
lcomment d294 a command for us
lcomment d297 if so, return with A=2
lcomment d299 now look whether MIDI data came in
lcomment d29e if so, process them
lcomment d2a3 if a NOTE ON came in,
dec d2a4
lcomment d2a5 return with A=3

comment d2a7
label d2a7 SetVc5
lcomment d2a7 save X for later
lcomment d2a9 X = KbdStat
lcomment d2ac walk thru keyboard areas
dec d2ad
label d2ae SetVc6
lcomment d2ae set Keyboard PIA Port A
lcomment d2b1 get KbdStat[current 8 keys]
lcomment d2b3 A = ~A (invert bits)
lcomment d2b4 A &= Keyboard PIA Port B
lcomment d2b7 if changes, get out with RC 4
lcomment d2bb otherwise advance to next area
lcomment d2bd \  of 8 keys
lcomment d2c0 restore X

comment d2c2
+dec d2c7
lcomment d2c8 if SEQM = 98 (Ext CV/Trig Control),
lcomment d2ca A = VIA Port B
lcomment d2cf A = A ^ old VIA Port B contents
lcomment d2cf \  (i.e., set each changed bit to 1)
lcomment d2d2 save current VIA Port B contents
lcomment d2d8 if trigger isn't inverse polarity,
lcomment d2da invert VIA Port B contents
lcomment d2da \  (i.e., set bit if triggered)
label d2db SetVc7
lcomment d2db look whether new trigger
lcomment d2e1 if no new trigger signal,
comment d2e5
label d2e5 SetVc8
comment d2f0 it's doubtful whether the next 3 instructions have any meaning
lcomment d2f3 check 6840 Timer 1 interrupt flag
label d2f8 SetVc9

lcomment d314 check 6840 Timer 1 interrupt flag
label d321 L2Vc33
label d324 StVc10

rel d33c 0110
lcomment d348 check whether fresh voice
rel d343 0110
lcomment d346 if Long Loop Transient Sound,
rel d34a 0310
comment d34f come here if Long Loop Transient Sound and NOT a fresh voice
comment d355 come here if NOT Long Loop Transient Sound or a fresh voice
label d355 StVc11
label d359 StVc12
lcomment d35c get new PRZOPA value
rel d35e 0310
lcomment d360 keep "Bank4-7 load" flag
lcomment d363 \  from old PRZOPA
label d369 StVc13
lcomment d36f save CurOPA without "Bank4-7" flag
lcomment d371 \  on stack for now
lcomment d376 set "Generator Enable"
lcomment d378 \  for current voice
lcomment d37e set "Generator Enable"
lcomment d380 \  for current voice again
rel d385 0110
rel d392 0310
label d399 StVc14
rel d3a3 0110
dec d3aa
dec d3ae
label d3b1 StVc15
label d3b7 StVc16
rel d3b9 0110
label d3bd StVc17
rel d3bf 0110
rel d3c2 0310
rel d3c6 0110
label d3c8 StVc18
rel d3cc 0110
lcomment d3cf if Long Loop Transient Sound,
rel d3d3 0310
label d3de StVc19
label d3e2 StVc20
lcomment d3e5 get PRZOPA value from stack
lcomment d3e7 mask in "subosc"
lcomment d3e9 keep "Bank4-7 load" flag
lcomment d3ec \  from old PRZOPA
dec d3e6
label d3f2 StVc21
rel d400 0310
comment d405 come here if voice not sounding (?)
lcomment d40a reset "Generator Enable"
lcomment d40c \  for current voice
dec d40b
rel d416 0110
label d41d StVc22
lcomment d419 if Double-Bank sound,
lcomment d422 turn ON Transient Sound Flag (and set offset to $3E)
label d42c StVc23
label d431 StVc24
lcomment d437 ???
rel d439 0310
rel d441 b030
rel d44f 0310

comment d453
comment d453 ===========================================================
comment d453 CUVMsk - calculates the upper voice byte mask
comment d453 ===========================================================
comment d453
label d453 CUVMsk

rel d45b 0311 ???
comment d45d the above should read "VcCLag-1-VceLRU" (disasm limitation)

comment d462
comment d462 continuation from above...
comment d462
label d462 StVc25
rel d468 b030
rel d476 0310
label d478 StVc26
comment d47f TAB convenience macro - "TSTA" can be safely removed
lcomment d481 A = (1,2,4,8,1,2,4,8)[A]
dec d489
label d491 StVc27
label d494 StVc28
lcomment d494 mask out VcFlg1[voice] bit 4
rel d496 0310
rel d49b 0310
rel d4b9 b030
rel d4bc 0310
comment d4bd
label d4bd StVc29
rel d4bf 0310
rel d4c4 0310
rel d4c7 0310
rel d4cc 0310
dec d4d0
lcomment d4d1 if currently on voice 1,3,5,7
lcomment d4d3 advance to next OF4 voice
dec d4d4
label d4d5 StVc30
lcomment d4d5 advance to next voice
lcomment d4e1 complement bDoFresh
lcomment d4e5 if $20 is not set in bDoFresh, restart
lcomment d4e7 (do a 2nd run)
comment d4eb
label d4eb StVc31
lcomment d4ed return with 0
comment d4ef
label d4ef StVc32
dec d4f4

comment d4f6
label d4f6 StVc33

comment d4f9
comment d4f9 ===========================================================
comment d4f9 ClcWvN - calculates Wave number for current oscillator (?)
comment d4f9 ===========================================================
comment d4f9
label d4f9 ClcWvN
rel d4fb 0110
label d501 ClcWv0
rel d503 0310
rel d506 0110
label d509 ClcWv1
rel d50a 0110
rel d50d 0110
rel d51c 0310
dec d51e
dec d522
label d523 ClcWv2
rel d52e 0110
lcomment d532 if MW:1,
rel d536 0110
label d538 ClcWv3
rel d53a 0110
lcomment d53e if TW:1,
dec d543
label d54b ClcWv4
rel d54d 0310
rel d551 0110
lcomment d555 if UW:1,
label d559 ClcWv5
rel d55b 0110
dec d55e
dec d562
dec d566
label d569 ClcWv6
rel d56d 0110
label d57c RtsD57C

comment d57d
comment d57d ===========================================================
comment d57d KFWStb - Keyfollow Waves Scaling Table
comment d57d ===========================================================
comment d57d
label d57d KFWStb 
const d57d-d584
break d57d-d584

comment d585
comment d585 ===========================================================
comment d585 OF4Vlt - OF4 Voice Latch table - a bit for each voice
comment d585 ===========================================================
comment d585
label d585 OF4VLt
lcomment d585 Latches for OF4 1 Voice 1,2,3,4
break d589
lcomment d589 Latches for OF4 2 Voice 1,2,3,4

comment d58d
comment d58d ===========================================================
comment d58d SetOWT - sets an oscillator for Wavetable or Transient sound
comment d58d ===========================================================
comment d58d
label d58d SetOWT
lcomment d58d get device capabilities bits 0&1
lcomment d592 if both are 0 (i.e., this is a Wave 2.2):
rel d598 0110
dec d59a
dec d59e
label d5a3 StOWT0
rel d5a5 0310
label d5aa StOWT1
dec d5ab
lcomment d5af maybe something with transient sound flag (?)
comment d5b8 the above should not be optimized as it might affect timing
comment d5c3 the above should not be optimized as it might affect timing
lcomment d5c8 turn ON Transient Sound Flag and set offset

comment d5cf
comment d5cf ===========================================================
comment d5cf SOscWv - sets an oscillator to a specific wave
comment d5cf ===========================================================
comment d5cf
label d5cf SOscWv
lcomment d5d1 turn ON Transient Sound Flag
dec d5d5

comment d5e2 the above should not be optimized as it might affect timing

comment d5e6
comment d5e6 -----------------------------------------------------------
comment d5e6 continuation of SetOWT
comment d5e6 -----------------------------------------------------------
comment d5e6
label d5e6 StOWT2
rel d5e7 0110
dec d5e9
lcomment d5ea maybe something with transient sound flag (?)
label d5f3 RtsD5F3
label d5f4 StOWT3
rel d5f6 0310
rel d5fd 0310

* unused d608-d67f   * for production code
* for binary compatibility, use the following 5 lines
comment d608
insert  d608 \        IFND NoDead
comment d608 DEAD:C0DE from here on (?)
const d608-d67f
insert d680 \        ENDIF
comment d680
insert d680 \        IFND NoOrg
insert d680 \        ORG     $D680
insert d680 \        ENDIF

comment d680
comment d680 ===========================================================
comment d680 WOENCH - write out entered numeric character to LCD display
comment d680 ===========================================================
comment d680 On entry:
comment d680 X contains the base address of the current bank
comment d680 A contains the offset into the current bank
comment d680 B contains the entered character
comment d680 Y contains current address of field character
comment d680 On exit:
comment d680 X points to the byte to write to (X+A)
comment d680 A contains the new computed value if field complete
comment d680 B contains the currently entered value in range $00..$09
comment d680 Side effects:
comment d680 If processing the first character of a 2-byte field, this
comment d680 function immediately terminates processing of its PARENT.
comment d680
label d680 WOENCH
lcomment d680 write character in B to LCD
lcomment d683 convert from ASCII to number
lcomment d685 add offset to X (?)
lcomment d687 look whether last field character
lcomment d689 if so,
lcomment d68b look whether this is a 2-char field
+dec d68c
lcomment d68d if only 1 byte,
lcomment d68f put resulting value into A and return
comment d692 come here for 2nd char of a 2-char field
label d692 WOENC0
lcomment d692 convert 1st digit to 10,20,30...
label d693 WOENC1
+dec d694
lcomment d699 add the 2nd digit to it and return the result
comment d69e come here for 1st char of a 2-char field
label d69e WOENC2
lcomment d69e remember the currently entered value
lcomment d6a0 return to calling function's parent!
+dec d6a1

comment d6a3
comment d6a3 come here for characters >=$E0 and <$E8 (semitone detune for the 8 oscillators)
label d6a3 PrcPnN
lcomment d6a3 shift into range $40..$47
lcomment d6aa get (BankBase - $110)
lcomment d6ad U = Bank Base + $20
lcomment d6b5 if in 2.2 mode
lcomment d6b9 and using Group B
lcomment d6bb position on Group B data
lcomment d6bf get SemitA (or B, 2,...) for that oscillator
lcomment d6c1 shift into display range (/4)
label d6bd PrcPnO

comment d6c6
comment d6c6 ===========================================================
comment d6c6 Num2Asc - converts a number in range $00-$63 to ASCII " 0"-"99"
comment d6c6 ===========================================================
comment d6c6 On entry, A holds the number to be converted
comment d6c6 On exit, B holds the high part, A holds the low part
comment d6c6 of the ASCII representation
comment d6c6
label d6c6 Num2Asc
label d6c7 Num2A0
+dec d6c8
+dec d6cc
label d6d0 Num2A1
+char d6d1
+char d6d3
+char d6d5
* +char d6d9  * no, that looks rubbish
label d6da Num2A2

comment d6db
insert  d6db \        IFND NoDead
comment d6db DEAD:C0DE from here on (?)
const d6db-d6ff
insert d700 \        ENDIF
comment d700
insert d700 \        IFND NoOrg
insert d700 \        ORG     $D700
insert d700 \        ENDIF

*comment d6db
*lcomment d6db clear LCD display
*lcomment d6e0 wait a little bit
*const d6e4
*comment d6e5 maybe this wait should be repeated for replacement displays...
*lcomment d6e5 set Character Entry Mode Decrement, Display Shift Off
*comment d6eb

comment d700
comment d700 ===========================================================
comment d700 Table of globally known entry points
comment d700 ===========================================================
comment d700

comment d70c
comment d70c ===========================================================
comment d70c TAS Keyboard Processing starts here - entry point comes later
comment d70c ===========================================================
comment d70c
label d70c PrcTk1
+dec d725
dec d729
label d72a PrcTk2
label d73d PrcTk3
comment d743
label d743 PrcTk4
dec d751
label d754 PrcTk5
lcomment d754 look whether panel needs update
lcomment d756 if not, skip...
lcomment d758 reset Panel Update flag
dec d75b
lcomment d75c and do the update.
label d75e PrcTk6
dec d772
const d774
+dec d774
label d783 PrcTk7

comment d784
comment d784 ===========================================================
comment d784 PrcTKy - processes eventually pressed TAS Keys
comment d784 ===========================================================
comment d784
label d784 PrcTKy
dec d799
comment d7a1 TBA convenience mnemonic - "TSTA" can be safely removed
dec d7a2
dec d7a9

comment d7ad
label d7ad JTkFky
break d7ad-d7c4

comment d7c5
comment d7c5 do this 256 times to assure the contact is stable
label d7c5 PrcTk0

comment d7cc
insert  d7cc \        IFND NoDead
comment d7cc --- DEAD:C0DE from here on ----
insert d7d1 \        ENDIF
comment d7d1
comment d7d1 ===========================================================
comment d7d1 AcAnal - activates the ANALOG display
comment d7d1 ===========================================================
comment d7d1
comment d7d1 this function activates the ANALOG display:
comment d7d1 "P:xx xx xx xx  xx xx xx xx  xx  xx xx xx"
comment d7d1 "GR:x xx xx xx  xx xx xx xx  **  xx xx xx"
comment d7d1
label d7d1 AcAnal

comment d7dd
comment d7dd ===========================================================
comment d7dd AcDigi - activates the DIGITAL display
comment d7dd ===========================================================
comment d7dd
comment d7dd this function activates the DIGITAL display:
comment d7dd "PROG:xx  UWx SWx KWx KFx KLx MWx MFx MLx"
comment d7dd "GROUP:x  BDx BIx TWx TFx TLx TMx VFx VLx"
comment d7dd
label d7dd AcDigi

comment d7e9
comment d7e9 ===========================================================
comment d7e9 CHGGRP - change between GROUP A, B, A+B
comment d7e9 ===========================================================
comment d7e9
label d7e9 CHGGRP
dec d7ec
label d7f1 CHGGR0
lcomment d7f1 advance to next Group
lcomment d7f4 0-2 -> 1-3
lcomment d7f5 shift into LED range
lcomment d7fa invert (LED is turned ON when its bit is OFF)
lcomment d7fd turn off both LEDs
lcomment d803 then turn on the LEDs corresponding to the
lcomment d806 new current group
dec d80a
label d814 CHGGR1
dec d813

comment d81a
comment d81a ===========================================================
comment d81a PENCHR - process entered numeric character
comment d81a ===========================================================
comment d81a
label d81a PENCHR
char d81b
label d83c PENCH0
label d83d PENCH1
+dec d842
lcomment d843 if SEQM = 99
comment d845 come here if SEQM:99, i.e., normal operation
*const d848
label d84c PENCH2
label d852 PENCH3

comment d858
comment d858 ===========================================================
comment d858 AcProg - activates the PROGRAM display
comment d858 ===========================================================
comment d858
comment d858 this function activates the PROGRAM display:
comment d858 either
comment d858 "PROG:xx WAVETB:xx MIDI:xx DTF:x SPLIT:xx"
comment d858 "KEYB:x TTUNE:4xx CASS:x  PPG-WAVE 2.x V6"
comment d858 or
comment d858 "CP:xx BK: xx  xx  xx  xx  xx  xx  xx  xx"
comment d858 "GR:x=BK:x DET:x KBM:x SPL#x KEY:xx DTF:x"
comment d858
label d858 AcProg
comment d85b
comment d85b To increase usability in W23 mode, the following could be 
comment d85b inserted here to toggle between the two PROGRAM displays:
comment d85b .      LDY     CurDpn    (safe, since it's changed in SCURDP)
comment d85b .      CMPY    #DPatBnk
comment d85b .      BEQ     AcPro0
comment d85b
label d863 AcPro0

comment d869
comment d869 ===========================================================
comment d869 AcTuni - activates the TUNING display
comment d869 ===========================================================
comment d869
comment d869 this function activates the TUNING display:
comment d869 "PROG:xx  DETU:x MO:x MS:x EO:x ES:x BI:x"
comment d869 "GROUP:x  SEMIT:  xx xx xx xx xx xx xx xx"
comment d869
label d869 AcTuni

comment d875
comment d875 =========================================================== 
comment d875 CRight - CURSOR RIGHT key has been pressed
comment d875 =========================================================== 
comment d875
label d875 CRight

comment d87a
comment d87a =========================================================== 
comment d87a CLeft - CURSOR LEFT key has been pressed
comment d87a =========================================================== 
comment d87a
label d87a CLeft
label d87d CLeft0
label d894 CLeft1
dec d89a
label d89e CLeft2
label d8a1 CLeft3

comment d8ac
comment d8ac ===========================================================
comment d8ac SSNDPN - SECOND PANEL has been pressed
comment d8ac ===========================================================
comment d8ac
label d8ac SSNDPN
label d8b4 SSNDP0
lcomment d8bf turn off LED SECOND PANEL
lcomment d8c7 set LED SECOND PANEL to new state

comment d8de
comment d8de ===========================================================
comment d8de AcDtaT - activates the DATA TRANSFER field
comment d8de ===========================================================
comment d8de
label d8de AcDtaT
dec d8df
label d8e7 AcDta0

comment d8ec
comment d8ec ===========================================================
comment d8ec AcKeyb - activates the KBM / KEYB field
comment d8ec ===========================================================
comment d8ec
label d8ec AcKeyb
dec d8ed

comment d8f7
comment d8f7 ===========================================================
comment d8f7 AcRnSt - activates Run/Stop on the SEQUENCE display
comment d8f7 ===========================================================
comment d8f7
comment d8f7 this activates the SEQUENCE display:
comment d8f7 "PR:xx SEQ:xx LOOPS:xx RECM:x TMC:x SP:xx"
comment d8f7 "RUN:x CH 1:x 2:x 3:x 4:x 5:x 6:x 7:x 8:x"
comment d8f7
label d8f7 AcRnSt
dec d8fd
label d900 AcRnS0

comment d90c
comment d90c ===========================================================
comment d90c AcSequ - activates the SEQUENCE display
comment d90c ===========================================================
comment d90c
comment d90c this activates the SEQUENCE display:
comment d90c "PR:xx SEQ:xx LOOPS:xx RECM:x TMC:x SP:xx"
comment d90c "RUN:x CH 1:x 2:x 3:x 4:x 5:x 6:x 7:x 8:x"
comment d90c
label d90c AcSequ

comment d917
comment d917 ===========================================================
comment d917 LdProg - loads the BANK or PROGRAM display
comment d917 ===========================================================
comment d917
label d917 LdProg
label d924 LdPro0
label d926 LdPro1

comment d930
comment d930 ===========================================================
comment d930 SCURDP - sets current display panel to X
comment d930 ===========================================================
comment d930
label d930 SCURDP
lcomment d930 prepare for PPG Bus?
comment d935 come here for PPG Bus data preparation
lcomment d935 if so, set up transfer area pointer
lcomment d93f do as if current group was A
lcomment d945 save panel pointer
lcomment d948 prepare data for group A
lcomment d94a restore panel pointer
lcomment d94c if MAIN or SEQUENCER panel, we're finished
lcomment d956 otherwise switch to group B
lcomment d95b and prepare data for group B
label d95d SCURD0
lcomment d95d now reset PPG Bus flag
lcomment d960 restore selected group
lcomment d964 and return
comment d965 come here for LCD display
label d965 SCURD1
lcomment d965 remember as current display panel
lcomment d969 reset currently displayed field

comment d979
comment d979 ===========================================================
comment d979 UpdDPn - update the display panel
comment d979 ===========================================================
comment d979
label d979 UpdDPn
label d983 UpdDP0
label d98a UpdDP1
lcomment d992 wait a little
+dec d993
comment d994 I think this should be set a little higher for
comment d994 replacement displays!
lcomment d994 \  = 2 + 224 \* (2 + 3) = 1122 cycles
lcomment d995 \  = 748µs
const d996

lcomment d98d set LCD Display & Cursor Home
comment d99a and fall thru to...

comment d99a
comment d99a ===========================================================
comment d99a PrcPnl - processes the currently set panel
comment d99a ===========================================================
comment d99a
label d99a PrcPnl
label d9ad PrcPn0
lcomment d9af if >=$E8 goto DA31
lcomment d9b3 if >=$E0 and <$E8 goto D6A3
lcomment d9b9 if >=$D0 and <$E0 goto DA10
lcomment d9bd if =$AE goto D9E2
lcomment d9c1 if >=$80 and <$D0 and <>$AE goto DA54
lcomment d9c7 if >=$20 and <$80 goto DA09
lcomment d9cb if =$04 goto D9FC

comment d9cf come here for characters $10-$1D (some DIGITAL PANEL data)

label d9d8 PrcPn1

label d9de PrcPn2

comment d9e2
comment d9e2 come here for character $AE (GROUP)
label d9e2 PrcPn3
lcomment d9e2 initialize to 'a'
lcomment d9e4 if displaying group (A+)B
lcomment d9e8 make it a 'b'

comment d9e9
comment d9e9 come here for output of a single character
label d9e9 PrcPn4
lcomment d9e9 look whether for TAS or PPG Bus
lcomment d9ee if for PPG Bus,
lcomment d9f0 add it to buffer

comment d9fc
comment d9fc come here for character $04 (i.e., End of String)
label d9fc PrcPn5
lcomment d9fc if displaying on TAS
lcomment d9ff jump a field to the left
lcomment da03 otherwise return. finished.

comment da04
comment da04 come here to print the current character
label da04 PrcPn6
lcomment da04 now print current character
lcomment da07 and continue with next one

comment da09
comment da09 come here for characters >=$20 and <$80
label da09 PrcPn7
lcomment da09 if displaying on TAS
lcomment da0c just print it out
lcomment da0e otherwise ignore it

comment da10
comment da10 come here for characters >=$D0 and <$E0
label da10 PrcPn8
const da13
+dec da13

label da29 PrcPn9

comment da31
comment da31 come here for characters >=$E8
label da31 PrcPnA

label da4c PrcPnB

comment da54
comment da54 come here for fields >=$80 and <$D0 and <>$AE
label da54 PrcPnC
lcomment da54 look whether 2 digits wanted
lcomment da58 if not, re-get control character
dec da59

comment da64
comment da64 come here for single character $88 or $C5
comment da64 $88=current group, $C5=Detuning(???)
label da64 PrcPnD
lcomment da64 if currently using group B
lcomment da68 add 1 to the field number

comment da69 come here for single characters >=$80 and <$D0 and <>$AE
label da69 PrcPnE
lcomment da69 now get the value to display
lcomment da6b make sure it's in range (high bit some flag?)
lcomment da6d convert to ASCII
lcomment da70 and send to output.

comment da73
comment da73 come here for character $BF (KEY:?? after SPL#?)
label da73 PrcPnF

comment da7e
comment da7e come here for 2-byte fields >=$80 and <$D0 and <>$AE
label da7e PrcPnG

comment da88
comment da88 come here for 2-byte fields >=80 and <$88
comment da88 i.e., the soundprogram banks on 2.3 MAIN Panel
+char da89

lcomment da8a senseless operation
lcomment da8c senseless operation
comment da8e it looks like there was something group-dependent planned here,
comment da8e but never correctly implemented...
comment da8e
label da8e PrcPnH

comment da91 come here if >=$88 and <$D0 and <>$AE and <> $BF
label da91 PrcPnI
label da95 PrcPnJ
label daad PrcPnK
label daaf PrcPnM

comment dab6
comment dab6 =========================================================== 
comment dab6 DspChr - sends the character in A onto the LCD display
comment dab6 =========================================================== 
comment dab6
label dab6 DspChr
lcomment dab9 wait a little bit
const dabd
+dec dabd

comment dabf
comment dabf =========================================================== 
comment dabf FldRgt - positions cursor one field to the right (?)
comment dabf =========================================================== 
comment dabf
label dabf FldRgt
label dad9 FldRg0
label dae4 FldRg1
lcomment dae6 if it's the GROUP field
dec daee
dec daf2
dec daf6
label daf9 FldRg2
label dafe FldRg3
label db04 FldRg4
label db06 FldRg5
dec db09
dec db0d
label db10 FldRg6
lcomment db10 set LCD Display Address to ($40 OR address)
lcomment db13 wait a little bit
dec db14
const db17
+dec db17
label db19 FldRg7

comment db1d
comment db1d =========================================================== 
comment db1d FldLft - positions cursor one field to the left (?)
comment db1d =========================================================== 
comment db1d
label db1d FldLft
label db1f FldLf0
lcomment db21 if on GROUP position
dec db29
dec db2d
dec db31
label db34 FldLf1
label db37 FldLf2
label db41 FldLf3
+dec db45
label db4a FldLf4

comment db4b
insert  db4b \        IFND NoDead
comment db4b DEAD:C0DE from here on (?)
const db4b-dbff
insert dc00 \        ENDIF
comment dc00
insert dc00 \        IFND NoOrg
insert dc00 \        ORG     $DC00
insert dc00 \        ENDIF

* ** superseded by the above **
*comment db7c
*data db7e-db80
*comment db7e interesting address conflict here - calls ZD95C, which seems to
*comment db7e be an invalid address - I guess this code here isn't valid, but
*comment db7e this remains to be confirmed
*comment db7e ###   JSR     ZD95C
*data dbf6-dbf8
*comment dbf6 interesting address conflict here - calls ZD95C, which seems to
*comment dbf6 be an invalid address - I guess this code here isn't valid, but
*comment dbf6 this remains to be confirmed
*comment dbf6 ###   JSR     ZD95C

comment dc00
comment dc00 ===========================================================
comment dc00 Entry point table
comment dc00 ===========================================================
comment dc00

comment dc03
comment dc03 ===========================================================
comment dc03 IniTAS - initialize TAS board (preliminary conclusion :-)
comment dc03 ===========================================================
comment dc03
label dc03 IniTAS
word dc05-dc06
dec dc0d
label dc0e IniTA0
lcomment dc12 initialize TAS PIA A+B to no interrupt,
lcomment dc15 use data direction register
lcomment dc18 clear yet unknown byte
lcomment dc1a set TAS PIA B to all input
lcomment dc1d set TAS PIA A to all output
lcomment dc22 set TAS PIA A+B to no interrupt, use output register
lcomment dc2a set TAS PIA A data to %10111110
+bin dc2b
lcomment dc2f set up some data areas
lcomment dc4d set TAS PIA A data to %11111111
lcomment dc52 look whether bit 6 stays high
lcomment dc57 if so, skip LCD initialization (?)
dec dc5f
label dc60 IniTA1
label dc67 IniTA2
label dc69 IniTA3

comment dc6d
comment dc6d ===========================================================
comment dc6d GTasKy - gets key from TAS keyboard
comment dc6d ===========================================================
comment dc6d On Exit, B holds key #
comment dc6d The keys have the following numbers:
comment dc6d $00-$09 ... Keys '0' - '9'
comment dc6d $0A ....... Cursor Left
comment dc6d $0B ....... Cursor Right
comment dc6d $0C ....... PROGRAM
comment dc6d $0D ....... DIGITAL
comment dc6d $0E ....... TUNING
comment dc6d $0F ....... ANALOG
comment dc6d $10 ....... SEQUENCER
comment dc6d $11 ....... GROUP
comment dc6d $12 ....... DATAT.
comment dc6d $13 ....... KEYB.
comment dc6d $14 ....... PANEL
comment dc6d $15 ....... RUN/STOP
comment dc6d $16 ....... unused
comment dc6d $17 ....... unused
comment dc6d
label dc6d GTasKy
label dc77 GTasK0
label dc7c GTasK1
label dc83 GTasK2
dec dc88
label dc91 GTasK3

lcomment dc59 init LCD to 8-bit, 2-line, 5x7 dot
lcomment dc5e then wait a bit
lcomment dc63 turn Display On, Cursor Underline On, Cursor Blink Off
lcomment dc67 set Character Entry Mode Decrement, Display Shift Off

* unused dc94-ddff   * for production code
* for binary compatibility, use the following 4 lines
comment dc94
insert  dc94 \        IFND NoDead
comment dc94 DEAD:C0DE from here on (?)
const dc94-ddff

* these 2 are only necessary to align the Wave 2.3 and EVU code
break dcb0
insert dcb0 \        ENDIF
comment dcb0
insert  dcb0 \        IFND NoDead
comment dcb0 DEAD:C0DE from here on
insert de00 \        ENDIF
comment de00
insert de00 \        IFND NoOrg
insert de00 \        ORG     $DE00
insert de00 \        ENDIF

comment de00
comment de00 ==================================================================
comment de00 TBMDVal - table of bitmasks for digital panel data $10-$1D
comment de00 ==================================================================
comment de00
label de00 TBMDVal
binary de00-de0f
break de00-de0f

comment de10
comment de10 Special characters for the following display patterns:
comment de10 $10 : VL?
comment de10 $11 : VF?
comment de10 $12 : TF?
comment de10 $13 : MW?
comment de10 $14 : TW?
comment de10 $15 : UW?
comment de10 $19 : MF?
comment de10 $1A : ML?
comment de10 $1C : TL?
comment de10 $1D : TM?
comment de10 $80..$87: programs selected into bank 0..7  (stored in $0000-$0007)
comment de10 $88 : bank selected into current group      (stored in $0008/$0009)
comment de10 ($89 : bank selected into group B - set internally if on B)
comment de10 $8a : Multi flag; not on any panel          (stored in $000A)
comment de10 $8b : TMC                                   (stored in $000B)
comment de10 $8c : CASSette mode                         (stored in $000C)
comment de10 $8d : TTUNE 4xx                             (stored in $000D)
comment de10 $94 : SEQ number                            (stored in $0014)
comment de10 $95 : Run (0/1)                             (stored in $0015)
comment de10 $98 : keyboard split point                  (stored in $0018)
comment de10 $9C-$A3 : sequencer channels                (stored in $001C-$0023)
comment de10 $AD : keyboard mode                         (stored in $002D)
comment de10 $AE : currently selected group
comment de10 $AF : data transfer mode                    (stored in $002F)
comment de10 $B0 : # loops                               (stored in $0030)
comment de10 $BE : SPL#?                                 (stored in $003E)
comment de10 $BF : KEY:?? (following SPL#?)              (stored in $003F)
comment de10 $C0 : SP: (Seq. Speed)                      (stored in $0040)
comment de10 $C1 : current combiprogram                  (stored in $0041)
comment de10 $C2 : current wavetable                     (stored in $0042)
comment de10 $C3 : current program                       (stored in $0043)
comment de10 $C4 : MIDI channel                          (stored in $0044)
comment de10 $C5 : Detuning                              (stored in $0045-$0046)
comment de10 ($C6 : Detuning for group B - set internally)
comment de10 $C7 : current Wave mode (2 or 3)            (stored in $0047)
comment de10 $CA : record mode                           (stored in $004A)
comment de10 $D0 : BD?
comment de10 $D1 : BI?
comment de10 $D2 : KF?
comment de10 $D6 : SW?
comment de10 $D7 : detune
comment de10 $DC : KL?
comment de10 $DD : KW?
comment de10 $E0-$E7 : semitone detune for the 8 oscillators
comment de10 $E8 : LFO Rate
comment de10 $EA : Waves OSC
comment de10 $EB : VCF Cutoff
comment de10 $EC : Env 1 -> VCF
comment de10 $ED : Env 1 -> Waves
comment de10 $EE : VCF Emphasis
comment de10 $EF : Env 2 -> Loudness
comment de10 $F0 : ADSR 1 Attack
comment de10 $F1 : ADSR 2 Attack
comment de10 $F2 : ADSR 1 Decay
comment de10 $F3 : ADSR 2 Decay
comment de10 $F4 : ADSR 1 Sustain
comment de10 $F5 : ADSR 2 Sustain
comment de10 $F6 : ADSR 1 Release
comment de10 $F7 : ADSR 2 Release
comment de10 $F8 : LFO Delay
comment de10 $F9 : Env 3 Attack
comment de10 $FA : LFO Waveshape
comment de10 $FB : Env 3 Decay
comment de10 $FC : Mod Wheel (only used in V8.1 and above)
comment de10 $FD : Env 3 ATT
comment de10 $FE : Waves SUB
comment de10

comment de10
label de10 DPatBnk
label de15 DPatBnk+5
label de5e DPatBnk+78
break de60

comment de61
label de61 DPatTun
break deb1

comment deb2
label deb2 DPatAna
break df02

comment df03
label df03 DPatDig
break df53

comment df54
label df54 DPatPrg
break dfa4

comment dfa5
label dfa5 DPatSeq
label dfb5 DPatSeq+16
label dfc3 DPatSeq+30
label dfd8 DPatSeq+51
break dff5

* unused dff6-dfff   * for production code
* for binary compatibility, use the following 3 lines
comment dff6
insert dff6 \        IFD     NoDead,2
comment dff6 DEAD:C0DE from here on
const dff6-dfff
