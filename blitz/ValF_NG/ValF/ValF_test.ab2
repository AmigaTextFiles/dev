
; "ValF_inc.bb2" test program

; (C) 2012-2013  Lorence Lombardo

; 26-Aug-2012 to 22-May-2013


#FPU=0   ; <- FPU compiler constant should be 1 OR 0


CNIF #FPU=1 : optimize 7 : CEND


INCLUDE "ValF_inc.bb2"


; The following are FPU support functions from "StrD.ab2" from the
; archive "num2str.lha" from the Aminet.

CNIF #FPU=1

; converts double IEEE floating point to integer floating point

Statement intD{num.d, addy.l}
   SHARED ieee2.l ; <- PutReg vars need to be shared when in non global
   ieee1.l=IEEEDPFloor_( Peek.l(&num), Peek.l(&num+4)  )
   PutReg d1, ieee2.l : Poke.l addy, ieee1 : Poke.l addy+4, ieee2
End Statement


; Decimal Float to Multi Base float string signed

Function.s MBStrDd{num.d, base.b, fdig.b}
   v$="" : nmax.b=base-1
   If base<>2 AND base<>10 AND base<>16 AND base<>8
      Function Return v$
   EndIf
   ngtv.b=0 : If num<0 Then ngtv=1 : num*-1
   intD{num, &numA.d} : numB.d=num-numA
   If numA>0
      Repeat
         rem.l=numA MOD base : If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=Chr$(rem+55)+v$ Else v$=Chr$(rem+48)+v$
         numA=(numA-rem)/base
      Until numA<=0
   EndIf
   If numB>0 AND fdig>0
      v$=v$+"." : fc.b=0
      Repeat
         ans.d=numB*base : intD{ans, &numB} : rem.l=numB
         If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=v$+Chr$(rem+55) Else v$=v$+Chr$(rem+48)
         numB=ans-rem : fc+1
      Until numB<=0 OR fc=>fdig
      v$=StripTrail$(v$,48) : v$=StripTrail$(v$,46)
   EndIf
   If ngtv=1 Then v$="-"+v$
   If v$="" OR v$="-" Then v$="0"
   Function Return v$
End Function


; Str$() like wrapper

Function.s StrD{num.d}
   fdig.b=16 : base.b=10
   Function Return MBStrDd{num, base, fdig}
End Function

CEND


py$="3.14159226417541"

NPrint py$
NPrint ValF {py$}

FloatMode -1

NPrint ValF {".0033333333"}

NPrint ValF {"1.000222222"}

NPrint ValF {"4.0000999999999999"}

NPrint ValF {"3.0000088888"}

NPrint ValF {"1.999999999999999999999"}

NPrint ValF {"1.3333333333"}

NPrint ValF {"2.66666666666666"}

NPrint ValF {"0.66666"}

NPrint ValF {"bla.75"}

NPrint ValF {"$7A.C"}

NPrint ValF {"%101.11"}

NPrint ValF{"#172.6"}

NPrint ValF {"    $6A.5"}

NPrint ValF {"-13.5"}

NPrint ValF {"4 300 000 000"}

NPrint ValF {"20,000,000,000"}


NPrint ""

NPrint " Big binary test:-"

bla$=String$("1",48)
NPrint bla$
NPrint ValF {"%"+bla$}

NPrint " Big HEX test:-"
bla$=String$("F",12)
NPrint bla$
NPrint ValF {"$"+bla$}


NPrint "" : NPrint " Big num test:-"

bla$ = "990,000,000,000,000,000"


bla2$= "997,809,470,675,333,239"

NPrint bla$


CNIF #FPU=1

bla.d=ValF {bla$} : NPrint StrD{bla}
NPrint bla2$
bla.d=ValF {bla2$} : NPrint StrD{bla}


CELSE


NPrint ValF {bla$}
NPrint bla2$
NPrint ValF {bla2$}

CEND


NPrint ValF {"1234dddd.567jjj890"}

NPrint "" : NPrint ValF {"-$7a.c"} : NPrint ValF {"$-7a.c"} : NPrint "" : End


; Thats flocking it......!!!!!!!  ;)



