
;*****************************************************************************
;   Huffman Encoding File Compression Technique
;   From Book: Algorithms in C, by R. Sedgwick  , MA: Addison-Wesley.
;   Converted to Pure Basic by PAMKKKKK
;   taken from a Power Basic Code by M. Rosenberg CI$: [73707,2545]
;   PB 3.94

; Amiga Blitz conversion by Lorence Lombardo  27-Apr-2012

; Obtained from here:-

; http://forums.purebasic.com/english/viewtopic.php?p=139318


InText.s ="A SIMPLE STRING TO BE ENCODED USING A MINIMAL NUMBER OF BITS" ;The Input "File"


Dim Count.l(1023), Heap.l(1023), Dad.l(1023), Code.l(255), Leng.l(255)


Statement PqDownheap{K.l}
  ;Build and maintain an indirect heap on the frequency values
  ;    reversing the inequalities since we want the smallest values first.
  SHARED Count(), Heap(), N.l
  J.l = 0
  V = Heap(K)
  While (K <= N/2)
    J = K+K
    If J<N AND Count(Heap(J)) > Count(Heap(J+1))
      J = J +1
    EndIf
    If Count(V)<=Count(Heap(J))
      Heap(K) = V
      Statement Return
    EndIf
    Heap(K) = Heap(J)
    Heap(J) = V
    K = J
  Wend
End Statement


Statement Huffman{InText.s}
  SHARED Count(), Heap(), Dad(), Code(), Leng(), N.l, OOutText.s, NewText.s
  ;Count the frequency of each character in the message to be encoded
  For i = 1 To Len(InText)
    Count(Asc(Mid$(InText, i , 1))) = Count(Asc(Mid$(InText, i, 1))) +1
  Next i
  ; Initialize the heap array to point to non-zero frequency counts
  N = 0
  For i = 0 To 255
    If Count(i) <> 0
      Heap(N) = i
      N = N +1
    EndIf
  Next i

  ;Construct an indirect heap on the frequency values
  For K = N To 1 Step -1
    PqDownheap{K}
  Next K
  ; Construct the Huffman tree
  Repeat
    T=Heap(1)
    NPrint N
    Heap(1) = Heap (N)
    N = N -1
    PqDownheap{1}
    Count( 255 + N) = Count(Heap(1)) + Count(T)
    Dad(T) = 255 + N
    Dad (Heap (1)) = -255 - N
    Heap(1) = 255 + N
    PqDownheap{1}
  Until N <= 0

  Dad(255 + N) = 0
  ;Reconstruct the information from the representation of the coding tree
  ;    computed during the shifting process.

  For K = 0 To 255
    If Count(K) = 0
      Code(K) = 0
      Leng(K) = 0
    Else
      i = 0
      J = 1
      T = Dad(K)
      X = 0
      Repeat
        If T < 0
          X=X+J
          T = 0-T
        EndIf
        T =Dad(T)
        J =J +J
        i = i +1
      Until T = 0
      Code(K) = X
      Leng(K) = i
    EndIf
  Next K

  ; Use the computed representations of the code to encode the string
  J= 0
  Repeat
    J = J + 1
    char = Asc(Mid$(InText,J,1))
    Compr.s = StripLead$(Bin$(Code(char)),48)
    While Len(Compr.s) < Leng(char)
      Compr = "0" + Compr.s
    Wend
    ;NPrint chr$(char) + " = " + Compr
    Hold.s = Hold.s + Compr.s
    If Len(Hold.s) > 8
      OOutText.s = OOutText.s + Chr$(Vallong("%"+Left$(Hold.s,8)))
      Hold.s = Right$(Hold.s,Len(Hold.s) - 8)
    EndIf
  Until J = Len(InText)
  ; Add a byte at the End that contains any left-over bits
  If Len(Hold.s) > 0
    While Len(Hold) < 8
      Hold.s = Hold.s + "0"
    Wend
    OOutText.s = OOutText.s + Chr$( Vallong( "%"+Left$(Hold,8) ) )
  EndIf

  ;*****************************************************************************
  ; Unpack compressed string into character representation of binary
  J = 0
  Repeat
    J = J + 1
    Hold.s= Mid$(OOutText.s,J,1)
    Hold.s= StripLead$(Bin$(Asc(Hold)),48)
    While Len(Hold) < 8
      Hold.s = "0" + Hold.s
    Wend
    UnCompr.s = UnCompr.s + Hold.s
  Until J = Len(OOutText.s)
  ;Decode compressed string
  Repeat
    For  K = 0 To 255
      If K = 255 Then Statement Return
      If  Leng(K) > 0
        If Vallong("%"+Left$(UnCompr.s,Leng(K))) = Code(K)
          UnCompr.s = Right$(UnCompr.s,Len(UnCompr.s) - Leng(K))
          NewText.s= NewText.s + Chr$(K)
          K=255
        EndIf
      EndIf
    Next K
  Until Len(UnCompr.s) = 0
End Statement


; ********************************************************
Huffman{InText}
NPrint "Input: ", Len(InText), " "+InText
NPrint "Packed length: ", Len(OOutText)
NPrint "UnPacked: ", Len(NewText), " "+NewText
End



