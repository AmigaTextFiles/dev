;
; MUI Class.c (C)opyright Stefan Stuntz.
; A very simple custom class, made very hard with blitz :(
; Converted to Blitz2 by Robert Hutchinson with some C
; conversion help from David McMinn.
;
; Demonstrates how to create private custom classes with
; MUI and blitz. Public custom classes though are a different
; matter all together. Probably imposible in blitz.
;
; Requires MUI2.RES, and updated EFMUILib. From:
; http://www.satanicdreams.com.  EMAIL: rob@satanicdreams.com
; Program also requires MUIMaster.library1 in BlitzLibs:AmigaLibs,
; and BB2MethodLibrary Installed. This can be found on aminet
; and is a blitz library.
;

  FindScreen 0

  ;
  ; CUSTOM CLASS MACROS NOT DEFINED IN MUI2.RES (YET :))
  ; Must have a variable struct .__dummyXFC2__ for these..
  ;
  Macro _app `1\mnd\mnd_GlobalInfo\mgi_ApplicationObject End Macro
  Macro _win `1\mad\mad_RenderInfo\mri_WindowObject End Macro
  Macro _dri `1\mad\mad_RenderInfo\mri_DrawInfo End Macro
  Macro _screen `1\mad\mad_RenderInfo\mri_Screen End Macro
  Macro _pens `1\mad\mad_RenderInfo\mri_Pens End Macro
  Macro _window `1\mad\mad_RenderInfo\mri_Window End Macro
  Macro _rp `1\mad\mad_RenderInfo\mri_RastPort End Macro
  Macro _left `1\mad\mad_Box\Left End Macro
  Macro _top `1\mad\mad_Box\Top End Macro
  Macro _width `1\mad\mad_Box\Width End Macro
  Macro _height `1\mad\mad_Box\Height End Macro
  Macro _right (!_left{`1}+!_width{`1}-1) End Macro
  Macro _bottom (!_top{`1}+!_height{`1}-1) End Macro
  Macro _addleft `1\mad\mad_addleft End Macro
  Macro _addtop `1\mad\mad_addtop End Macro
  Macro _subwidth `1\mad\mad_subwidth End Macro
  Macro _subheight `1\mad\mad_subheight End Macro
  Macro _mleft (!_left{`1}+!_addleft{`1}) End Macro
  Macro _mtop (!_top{`1}+!_addtop{`1}) End Macro
  Macro _mwidth (!_width{`1}-!_subwidth{`1}) End Macro
  Macro _mheight (!_height{`1}-!_subheight{`1}) End Macro
  Macro _mright (!_mleft{`1}+!_mwidth{`1}-1) End Macro
  Macro _mbottom (!_mtop{`1}+!_mheight{`1}-1) End Macro
  Macro _font `1\mad\mad_Font End Macro
  Macro _minwidth `1\mad\mad_MinMax\MinWidth End Macro
  Macro _minheight `1\mad\mad_MinMax\MinHeight End Macro
  Macro _maxwidth `1\mad\mad_MinMax\MaxWidth End Macro
  Macro _maxheight `1\mad\mad_MinMax\MaxHeight End Macro
  Macro _defwidth `1\mad\mad_MinMax\DefWidth End Macro
  Macro _defheight `1\mad\mad_MinMax\DefHeight End Macro
  Macro _flags `1\mad\mad_Flags End Macro

  ;
  ; Some dummy data-space for our object. Have any information
  ; you require here.
  ;
  NEWTYPE.MyData
    dummy.l                   ; Some dummy class data space.
  End NEWTYPE



  MOVE.l a5,globalbase     ; Store Blitzs global variable base
                           ; This is needed for hooking.

  Runerrsoff

  ;
  ; Set up the minimum and maximum sizes for our class.
  ; So that you can layout the object correctly, restricting
  ; its stretchability where needed.
  ;
  Function.l mAskMinMax{*cl.IClass,*obj,*msg.MUIP_AskMinMax}

    DoSuperMethodA *cl,*obj,*msg

    *msg\MinMaxInfo\MinWidth  + 100
    *msg\MinMaxInfo\DefWidth  + 120
    *msg\MinMaxInfo\MaxWidth  + 500

    *msg\MinMaxInfo\MinHeight + 40
    *msg\MinMaxInfo\DefHeight + 90
    *msg\MinMaxInfo\MaxHeight + 300

    Function Return 0
  End Function
  ;
  ;########################################################################
  ;
  ; Function called when object needs redrawing.
  ;
  Function.l mDraw{*cl.IClass,*obj,*msg.MUIP_Draw}

    DEFTYPE.l i
    DoSuperMethodA *cl,*obj,*msg

    If (*msg\flags AND #MADF_DRAWOBJECT)=False
      Function Return 0
    EndIf

    *tmp.__dummyXFC2__ = *obj
    *dri.DrawInfo      = !_dri{*tmp}
    SetAPen_ !_rp{*tmp},1 ;(*dri\dri_Pens+(#TEXTPEN*2))

    ;
    ; Draw lines.
    ;
    For i=!_mleft{*tmp} To !_mright{*tmp} Step 5
      Move_ !_rp{*tmp},!_mleft{*tmp},!_mbottom{*tmp}
      Draw_ !_rp{*tmp},i,!_mtop{*tmp}
      Move_ !_rp{*tmp},!_mright{*tmp},!_mbottom{*tmp}
      Draw_ !_rp{*tmp},i,!_mtop{*tmp}
    Next i

    Function Return 0
  End Function

  Runerrson


  ;#######################################################################
  ;
  ; Right, we need to create our custom class now. :)
  ;
  MUIArea$="Area.mui"
  *mcc.MUI_CustomClass=MUI_CreateCustomClass_(0,&MUIArea$,0,SizeOf.MyData,?dshook)
  If *mcc=False
    DefaultOutput
    NPrint "Could not create custom class."
    End
  EndIf

  ;
  ; Original author. :)
  ;
  MUIApplicationTitle       "Class1"
  MUIApplicationVersion     "$VER: Class1 19.5 (12.02.97)"
  MUIApplicationCopyright   "1993, Stefan Stuntz"
  MUIApplicationAuthor      "Stefan Stuntz"
  MUIApplicationDescription "Demonstrate the use of custom classes."
  MUIApplicationBase        "CLASS1"
  ;
  ; Application tree.
  ;
  #OUR_Window                 = 0
    #OUR_MainGroup            = 1

  #OUR_APP                    = 2
  ;
  ; Notifies.
  ;
  #OUR_CloseRequest           = -1
  ;
  ; Setup our custom class.
  ;
  Dim NewTags.TagItem(3)
    NewTags(0)\ti_Tag = #MUIA_Frame,#MUIV_Frame_Text      ; Initialisation
    NewTags(1)\ti_Tag = #MUIA_Background,#MUII_BACKGROUND ; tags for this class.
    NewTags(2)\ti_Tag = #TAG_DONE,#TAG_DONE               ;
  *MyObj=NewObjectA_(*mcc\mcc_Class,0,&NewTags(0))

  ;
  ; Now we have to hack the git into a group! Ouch!
  ;
  MUIAddTags   #OUR_MainGroup,#Child,*MyObj
  MUINewObject #OUR_MainGroup,"Group.mui",0

  MUICreateWindow #OUR_Window,"A Simple Custom Class","CLS1",#OUR_MainGroup
  MUIAddSubWindow #OUR_Window

  If MUICreateApplication=False
    NPrint "Failed to create application."
    End
  EndIf

  MUIApplicationObj #OUR_APP
  ;
  ; Close window notify
  ;
  MUINotifyApp #OUR_Window,#MUIA_Window_CloseRequest,1,#OUR_CloseRequest


  If MUIOpenWindow(#OUR_Window)=False
    BeepScreen 0
    JMP EndBadly
  EndIf

  Repeat
    Mev.l=MUIEvent
    Delay_ 1
  Until Mev.l=#OUR_CloseRequest

  ;
  ; End of program...
  ; Programs with custom classes must be terminated this way!!!!!!
  ; Free the application first, then the custom classes. In reverse order.
  ;
  EndBadly:
;  MUICloseWindow         #OUR_Window
;  MUIFreeObject          #OUR_APP   ; Free application and all objects.
;  DisposeObject_(*MyObj)
;  MUI_DeleteCustomClass_ *mcc       ; Free our custom class.
  End


  ;#######################################################################
  ;
  ; Custom Class dispatcher code... This will deal with incoming
  ; methods. You can add new methods here to expand the system.
  ;

  Runerrsoff

  DispH:
  Function.l MyDispatcher{*cl.IClass,*obj,*msg}

    Select Peek.l(*msg) ;\MethodID
      ;
      ; When finding out its size..
      ;
      Case #MUIM_AskMinMax
        Function Return mAskMinMax{*cl,*obj,*msg}

      ;
      ; When called to draw itself..
      ;
      Case #MUIM_Draw
        Function Return mDraw{*cl,*obj,*msg}

    End Select

    ;
    ; When not called with any of the above.
    ;
    Function Return DoSuperMethodA(*cl,*obj,*msg)
  End Function

  ;# HOOKING #############################################################

  globalbase:   Dc.l 0

  dshook: MOVEM.l d1-d7/a0-a6,-(a7)   ; Save registers to stack (NOT D0!!!)

          MOVE.l  a0,d0               ;
          MOVE.l  a2,d1               ; Setup registers. For Class hooking.
          MOVE.l  a1,d2               ;

          MOVEA.l globalbase(pc),a5
          LEA     DispH,a3            ; More hooks would be required for
          JSR     6(a3)               ; multiple classes.

          MOVEM.l (a7)+,d1-d7/a0-a6   ; Put regs back.
          RTS



