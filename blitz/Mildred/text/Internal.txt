 ._Data
;000
GeneralCPUmode: Dc.b 0 ; 0=000-030, 1=040-060 max cpu allowed to use with regards 040+ instructions such as move16
SpecificCPUmode:Dc.b 0 ; 0=000, 1=010, 2=020, 3=030, 4=040, 6=060 minimum cpu that is available
;002
Autoc2pWindowsUse: Dc.b 1 ; Automatically use new c2pWindows? 0=No, <>0=Yes
c2pCPUmode:     Dc.b 1 ; 0=000-030, 1=040-060 c2p routine to use
;004
LongwordStore:  Dc.l 0 ; Temporary storage place to put a longword (any, ie if not enough regs)
;008
c2p_Rows:       Dc.w 0 ; Temporary
c2p_RowsStore:  Dc.w 0 ; Temporary
c2p_Pmod:       Dc.w 0 ; Temporary
c2p_Cmod:       Dc.w 0 ; Temporary
c2p_Pixels:     Dc.l 0 ; Temporary
;020
c2pWindowsMem:  Dc.l 0 ; Pointer to mem reserved for c2pWindow structures
c2pWindowsTotal:Dc.w 0 ; Total number of c2p windows (do -1 for highest)
;026
Currentc2pWindows:
Currentc2pWindow1: Dc.w -1 ; Number of current c2pWindow
Currentc2pWindow2: Dc.w -1 ; Number of second current c2pWindow
Currentc2pWindow3: Dc.w -1 ; Number of third current c2pWindow
;032
;c2pWindow structure, 8 bytes
c2pWindows
c2p0_Pixels:    Dc.w 0 ;0 Number of pixels per row, or total number of pixels.l if no modulo
c2p0_RowsStore: Dc.w 0 ;2 Row counter. Pixels and RowStore need to make a longword (Pixels.l) and thus are consequtive
c2p0_Pmod:      Dc.w 0 ;4 Planar line modulo
c2p0_Cmod:      Dc.w 0 ;6 Chunky line modulo
;040
  Dc.l 0 ; Spare
;044
  Dc.l 0 ; Spare
;048
CShape_AutoCookie:   Dc.b 0 ; AutoCookie status for shapes. 0=None, <>0 =ByteForByte
CBitmap_AutoStencil: Dc.b 0 ; AutoStencil status for bitmaps. 0=None, <>0 =ByteForByte
CShape_AutoClip:     Dc.b 0 ; AutoClip status for shapes. 0=Off, <>0=On
CBitmap_AutoClip:    Dc.b 0 ; AutoClip status for bitmaps. 0=Off, <>0=On
;052
CShape_AutoWrap:  Dc.b 0 ; AutoWrap status for shapes. 0=Off, <>0=On automatic handle wrapping
CBitmap_AutoWrap: Dc.b 0 ; AutoWrap status for bitmaps. 0=Off, <>0=On automatic handle wrapping
;054
CCookie_AutoXFlip:  Dc.b -1 ; Automatic flipping of cookies when flipping shapes horizontally
CCookie_AutoYFlip:  Dc.b -1 ; Automatic flipping of cookies when flipping shapes vertically
CStencil_AutoXFlip: Dc.b -1 ; Automatic flipping of stencils when flipping bitmaps horizontally
CStencil_AutoYFlip: Dc.b -1 ; Automatic flipping of stencils when flipping bitmaps vertically
;058
CurrentCShapes:
CurrentChunkyShape1: Dc.w -1 ; Number of current ChunkyShape
CurrentChunkyShape2: Dc.w -1 ; Number of second current ChunkyShape
CurrentChunkyShape3: Dc.w -1 ; Number of third current ChunkyShape
;064
CurrentCBitmaps:
CurrentChunkyBitmap1:Dc.w -1 ; Number of current ChunkyBitmap
CurrentChunkyBitmap2:Dc.w -1 ; Number of second current ChunkyBitmap
CurrentChunkyBitmap3:Dc.w -1 ; Number of thid current ChunkyBitmap
;070
ChunkyShapesTotal: Dc.w 0 ; Total number of ChunkyShapes (do -1 for highest)
ChunkyShapesMem:   Dc.l 0 ; Pointer to mem reserved for ChunkyShape structures
ChunkyBitmapsMem:  Dc.l 0 ; Pointer to mem reserved for ChunkyBitmap structures
ChunkyBitmapsTotal:Dc.w 0 ; Total number of ChunkyBitmaps (do -1 for highest)
;082
CurrentChunkyShapeBank: Dc.w 0 ; Current Shape bank, 0 as default
;084
AutoChunkyShapesUse:  Dc.b 1 ; Automatically use new ChunkyShapes? 0=No, <>0=Yes
AutoChunkyBitmapsUse: Dc.b 1 ; Automatically use new ChunkyBitmaps? 0=No, <>0=Yes
;086
_DoubleQBlitModeType:Dc.w 0 ; Type of blit that DoubleQBlit does. 0=Cookie,1=Erase,2=Inv,3=Solid,4=MColourMode,5=MReMapMode,6
_DoubleBlitModeType: Dc.w 0 ; Type of blit that DoubleBlit does. 0=Cookie,1=Erase,2=Inv,3=Solid,4=MColourMode,5=MReMapMode,6
_QBlitModeType:    Dc.w 0 ; Type of blit that QBlit does. 0=Cookie,1=Erase,2=Inv,3=Solid,4=MColourMode,5=MReMapMode,6
_BlitModeType:     Dc.w 0 ; Type of blit that Blit does. 0=Cookie,1=Erase,2=Inv,3=Solid,4=MColourMode,5=MReMapMode,6
_ParticleModeType: Dc.w 4 ; Type of blit that particle routines plot/draw do. 4=MColourMode,5=MReMapMode,6=MSimpleReMapMode
SScrollModeType:   Dc.w 0 ; Type of blit that SScroll and CScroll do. 0=Cookie,1=Erase,2=InvMode,3=SolidMode,4=MColourMode
SMaskScrollModeType: Dc.w 0 ; Type of blit that MSMaskScrolls do. 0=Cookie,1=Erase,2=InvMode,3=SolidMode,4=MColourMode,5,6
DoubleScrollMode:  Dc.b 0 ; Mode that DoubleScrolls use. 0=Paste, <>0=Cut.
DoubleBlitMode:    Dc.b 0 ; Mode that DoubleBlits use. 0=Paste, <>0=Cut.
DoubleQBlitMode:   Dc.b 0 ; Mode that DoubleQBlits use. 0=Paste, <>0=Cut.
_ParticleFormat:   Dc.b 0 ; Format of particle lists and operation to perform. 0=word, <0=quick, >0=address
;104
;ChunkyResource structure, 64 bytes (bitmaps and shapes)
ChunkyResources
CRsrc_Width:    Dc.w 0 ;0  Width of the chunky resource in pixels (=bytes)
CRsrc_Height:   Dc.w 0 ;2  Height of the chunky resource in pixels (=lines) Must be positioned directly after Width
CRsrc_LineMod:  Dc.w 0 ;4  Horizontal line modulo - bytes to add at end of line to get to start of next line (usually zero)
CRsrc_Clipping: Dc.b 0 ;6 Clip window active/deactive. 0=Off, <>0=On
CRsrc_Wrapping: Dc.b 0 ;7 X&Y Handle-wrapping active/deactive. 0=Normal, <>0=MemoryWrap (add WrapBytes to base address)
CRsrc_Data:     Dc.l 0 ;8  Pointer to move16-aligned memory containing resource's graphic
CRsrc_Stencil:  Dc.l 0 ;12 Pointer to move16-aligned memory containing resource's stencil/mask/cookie
CRsrc_XHandle:  Dc.w 0 ;16 X-Handle coordinate horizontal offset
CRsrc_YHandle:  Dc.w 0 ;18 Y-Handle coordinate verticle offset
CRsrc_DMem:     Dc.l 0 ;20 Actual base pointer of memory reserved for data (before move16-alignment)
CRsrc_DBytes:   Dc.l 0 ;24 Total number of bytes in the resource's graphic mem (before align)
CRsrc_SMem:     Dc.l 0 ;28 Actual base pointer of memory reserved for stencil (before move16-alignment)
CRsrc_SBytes:   Dc.l 0 ;32 Total number of bytes in the resource's stencil/mask/cookie (before align)
CRsrc_DHere:    Dc.b 0 ;36 Graphic data here. 0=Cludged, <>0=CRsrc_DMem is base address
CRsrc_SHere:    Dc.b 0 ;37 Stencil data here. 0=Cludged, <>0=CRsrc_SMem is base address
CRsrc_ClipLMod: Dc.w 0 ;38 Clip window horizontal line modulo in bytes compared with bitmap width (additional to LineMod)
CRsrc_ClipLeft: Dc.w 0 ;40 Clip window's left-edge X coordinate offset
CRsrc_ClipTop:  Dc.w 0 ;42 Clip window's top-edge Y coordinate offset
CRsrc_ClipWidth:Dc.w 0 ;44 Clip window's width in pixels
CRsrc_ClipHight:Dc.w 0 ;46 Clip window's height in pixels
CRsrc_ClipBytes:Dc.l 0 ;48 Clip window bytes to add to addresses to find topleft corner of clip window
CRsrc_WrapBytes:Dc.l 0 ;52 Handle bytes to add to base addresses to find topleft XHandle,Yhandle offset
CRsrc_TotWidth: Dc.w 0 ;56 Width+LineMod, for faster reading of total byte width
CRsrc_Pad1:     Dc.w 0 ;58
CRsrc_Pad2:     Dc.l 0 ;60
;168
ChunkyQueuesMem:   Dc.l 0 ; Pointer to where the ChunkyQueue structures are held
ChunkyQueuesTotal: Dc.w 0 ; Number of ChunkyQueue structures
AutoChunkyQueuesUse:  Dc.b 1 ; Automatically use new ChunkyQueues? 0=No, <>0=Yes
;175
CurrentInks:
CurrentInk1: Dc.b 1 ; Current ink to use in graphics routines, default colour
CurrentInk2: Dc.b 1 ; Second current ink to use
CurrentInk3: Dc.b 1 ; Third current ink to use
;178
CurrentChunkyQueues:
CurrentChunkyQueue1: Dc.w -1 ; Number of current ChunkyQueue
CurrentChunkyQueue2: Dc.w -1 ; Number of second current ChunkyQueue
CurrentChunkyQueue3: Dc.w -1 ; Number of third current ChunkyQueue
;184
;ChunkyQueue structure, 16 bytes
ChunkyQueues
CQueue_LMem:    Dc.l 0 ;0  Pointer to memory used to store the list. 0=Queue doesn't exist
CQueue_LBytes:  Dc.l 0 ;4  Bytes of mem reserved
CQueue_MaxItems:Dc.w 0 ;8  Maximum number of items in the queue
CQueue_Items:   Dc.w 0 ;10 Actual number of items in the queue
CQueue_ItemAddr:Dc.l 0 ;12 Memory address of the current item
;200
LineLastXpos: Dc.w 0 ;0 X coordinate of the end of the previously drawn line
LineLastYpos: Dc.w 0 ;2 Y coordinate of the end of the previously drawn line
;204
ChunkyTablesMem:   Dc.l 0 ; Pointer to where the ChunkyTable structures are held
ChunkyTablesTotal: Dc.w 0 ; Number of ChunkyTable structures
AutoChunkyTablesUse:  Dc.b 1 ; Automatically use new ChunkyTables? 0=No, <>0=Yes
  Dc.b 0 ; Spare
;212
CurrentChunkyTables:
CurrentChunkyTable1: Dc.w -1 ; Number of current ChunkyTable
CurrentChunkyTable2: Dc.w -1 ; Number of second current ChunkyTable
CurrentChunkyTable3: Dc.w -1 ; Number of third current ChunkyTable
;218
_DrawingModeType:  Dc.w 4 ; Type of operation that drawing ops do. 2=InvMode,4=MColourMode,5=MReMapMode,6=MSimpleReMapMode
;220
;ChunkyTable structure, 16 bytes
ChunkyTables
CTable_LMem:    Dc.l 0 ;0  Pointer to memory used to store the list. 0=Table doesn't exist
CTable_LBytes:  Dc.l 0 ;4  Bytes of mem reserved.Also maximum number of items
CTable_Items:   Dc.l 0 ;8  Actual number of items in the table
CTable_ItemAddr:Dc.l 0 ;12 Memory address of the current item
;236
ChunkyShapeBanks
;ChunkyShapesMem0:  Dc.l 0 ; ChunkyShapesMem bank 0
;ChunkyShapesTotal0:Dc.w 0 ; ChunkyShapesTotal bank 0
;ChunkyShapesPad0:  Dc.w 0 ;
                    Ds.w #NumberOfShapeBanks*8
;Next is at 492, with 32 shape banks
