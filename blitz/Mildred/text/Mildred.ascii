.Mildred ; Mistress of chunky magic

;**********************************************************************
;
;$VER:Mildred V1.51 (21/10/1998)-(22/05/1999)&(27/02/2000)-(03/03/2000)
;
;Copyright (c) 1998-2000, Paul Jonathan West.
;
;**********************************************************************

;History
;v1.1  - First public release
;v1.11 - Fixed bug in MUseShapeBank and altered ShapesTotal size to word as it was incorrectly a longword
;      - Fixed bug in the errorchecking of Mc2pCPUmode that was checking d3 instead of d0
;v1.12 - Fixed bug in MUnQueue that would only do two lines of code if wrapping was active, but should have been done always
;v1.13 - MBoxF, MBoxFShape, MBoxFStencil and MBoxFCookie added
;      - MBox, MBoxShape, MBoxStencil and MBoxCookie added
;v1.14 - MPlanar16ToBitmap, MPlanar16ToShape added
;v1.15 - Planar-to-chunky converter optimised further using addx and reverse bitplane order, twice as fast as roxr.b #n,dn
;      - MGenericPtr added
;      - A shape's handle is unconditionally added (actually subtracted) to Xpos,Ypos in shape-to-bitmap type blits (MBlit etc)
;v1.16 - Fixed small bug in !PerformPoint macro, d6.l should have been d6.w.
;      - Fixed small but ineffective bug in MPlotCookie, d6.l should have been d6.w
;v1.17 - Added MCludgeCookie and MCludgeStencil, also needed to add two macros
;      - Fixed bug in macro used by MCludgeCookie and MCludgeStencil, as it was not setting `SHere' to 0 to indicate cludge.
;v1.18 - Added MUnQueueRange for unqueuing a range of items and without flushing the queue
;v1.19 - Fixed bug in data for shape banks, was using structures of 8 bytes but only were 6 bytes in mem
;      - Fixed bug in MReserveShapes, was shifting bank number 8 places instead of 3
;v1.2  - Added MReMap and MReMapShape
;v1.21 - Fixed bug in macro DeallocStencil, was killing the whole object
;v1.22 - Commented-out line in MShapeClip and MBitmapClip to make X leftedge unaligned (width is still multiple of 4)
;      - Commented-out line in Macro CludgeResourceWindow to make X leftedge unaligned (width of window is still multiple of 4)
;v1.23 - Added mode to MBlit so that if a cookie is not present it will just blit the graphic in `replace'-mode (unmasked)
;      - Minor pipeline improvement in macros !PerformPlot and !PerformPoint
;      - Added code to the init routine to reserve default amounts of all objects at runtime (doesn't need much mem)
;      - Added `BankToUse' parameter to MReserveShapes so that you don't have to do a seperate MUseShapeBank
;      - Changed BoxF and Box routines to use X2,Y2 instead of Width,Height and had to add macro CCheckWindowFits4
;v1.24 - Made the colour parameter in MPlot,MPlotShape,MPlotStencil and MPlotCookie optional, assuming 0 if not specified
;      - *Partially* Added MLine, MLineShape, MLineStencil and MLineCookie
;      - Modified shapebank-related routines to provide 32 shape banks numbered 0..31, instead of 0..9.
;      - Fixed bugs in macros ShuffleRegs1, ShuffleRegs2 and ShuffleRegs3
;v1.25 - Added MReMapUsingShape and MReMapShapeUsingShape
;v1.26 - Optimised routine PerformReMapUsing for slight speed gain
;      - Optimised routine PerformReMap for 25% speed gain in table mode
;      - Fixed bug in macro CCheckWindowFits4, which affected runtime errorchecking of MBox/MBoxF and related routines
;v1.27 - Added MInk for setting a currently-used pen colour. Defaults to 1 which is a bit more logical than 0
;      - Added MColourMode function to accompany CookieMode/SolidMode etc, but for `colour' drawing mode in blits
;      - Added `colour' mode to MBlit, MQBlit, MSBlit, MQSBlit and MMaskScroll routines
;      - Removed redundant instruction in routine PerformBlit3's loop, for cookie-mode stencil-blits (slight speedup)
;      - Adjusted graphics routines to use the ink colour if assuming which colour to use, rather than 0
;      - Further optimised routine PerformReMapUsing for slight speedup (about 1-2fps)
;      - Changed order of tables being used for MReMap[Shape]UsingShape, for consistency with `MReMapMode' blit mode
;      - Added support for new Table objects
;      - Added MReserveTables, MFreeTables, MFreeTable, MAddrTable, MTable
;      - Added MFlushTable, MAutoUseTables, MUseTables, MUseTable, MUsedTable
;      - Added MTablePtr, MReMapMode
;      - Added new blit mode `ReMap' to the MBlit, MQBlit, MSBlit, MQSBlit and MMaskScroll routines for table-based remapping
;v1.28 - Optimised MPictureDissolveIn for speed gain (a good few fps)
;      - Added MSimpleReMapMode
;      - Added new blit mode `SimpleReMap' to the MBlit, MQBlit, MSBlit, MQSBlit and MMaskScroll routines for 1-dim remapping
;      - Fixed bug in definitions, MPointStencil and MPointCookie were defined as statements, but should have been functions
;      - Changed the !PerformPoint macro to initialise d0 before grabbing the byte, in case it causes corrupt return value
;v1.29 - Optimised non-cut routine used by MSMaskScrolls (PerformGenericBlit6[b])
;      - Slight optimisation to non-cut plain copy routine used by M[Q]SBlits (PerformBlit2)
;      - Finished MLine, MLineShape, MLineStencil and MLineCookie
;v1.30 - Redirected routine PerformGenericBlit3[b] to use PerformBlit1[b], to save code redundancy, and made gen3b into 1b
;      - Added MSMaskScrollMode to support blit modes for MSMaskScrolls (previously only MMaskScrolls)
;      - Redirected routine PerformGenericBlit6[b] to use PerformBlit2[b], to prepare for shared sblit blit-mode code
;      - Redirected routine PerformGenericBlit9[b] to use PerformBlit3[b], to prepare for shared sblit cut blit-mode code
;      - Completed support for MSMaskScrolls in `copy' mode with blit modes, by adding PerformBlit2b (2 backwards)
;      - Completed support for MSMaskScrolls in `cut' mode with blit modes, by adding PerformBlit3b (3 backwards)
;      - Modified runtime errorchecking routines for MSMaskScrolls to check that tables are available in M[Simple]ReMapMode
;v1.31 - Modified MScroll routines to support any width (non multiple, as low as 1).
;      - Modified MSScroll routines to support any width (non multiple, as low as 1) in both `paste' and `cut' modes.
;v1.32 - Fixed bugs in routine PerformBlit2[b] for non-cut output to stencil. Some OR's should have been AND's, and vice versa.
;v1.33 - Fixed bug in routine PerformLine, sometimes d5 was plotted rather than d6
;v1.34 - Added MPlotParticles for plotting list of pixels to a colour. List items are X.w,Y.w
;      - Added MGrabParticles for grabbing list of pixels to a buffer. List items are X.w,Y.w. Buffer is Pixel.b's
;      - Added MDrawParticles for drawing grabbed list of pixels from a buffer. List items are X.w,Y.w. Buffer is Pixel.b's
;      - Added MGrabParticlesAndPlot for grabbing and plotting pixels to a colour. List items are X.w,Y.w. Buffer is Pixel.b's
;      - Fixed bug in initialisation, auto-clip for bitmaps and shapes shouldn't have been automatically On!
;      - Added MPlotParticlesA, MGrabParticlesA, MDrawParticlesA, MGrabParticlesAndPlotA, for actual-address list items
;      - Added MPlotParticlesQ, MGrabParticlesQ, MDrawParticlesQ, MGrabParticlesAndPlotQ, for X.q,Y.q items [*16*.16][*16*.16]
;      - Added MAddToParticles, MAddToParticlesA, MAddToParticlesQ, for adding values to particle list items
;      - Added MAdd2ToParticles, MAdd2ToParticlesA, MAdd2ToParticlesQ, for more efficient multiple adds to list items
;v1.35 - Added MWrapParticles, MWrapParticlesA, MWrapParticlesQ, to wrap coords around edges of bitmap/clip (within reason)
;      - Fixed bugs in clip routine of MAddToParticlesQ and MAdd2ToParticlesQ, offsets and adders and adding were wrong
;      - Fixed bugs in clip routine of MWrapParticles and MWrapParticlesQ, 2 conditional branches to loop missing
;v1.36 - Added MReboundParticles and MReboundParticlesQ, for bouncing particless off the edges. No `A' version, not possible
;      - Fixed bugs in MLine, MLineShape, MLineStencil, MLineCookie, short version used wrong colour
;      - Added MProcessor function, to replace blitz's `Processor' instruction and support 060
;      - Modified various cpu-related routines (c2p and 040 choices) to support possible 060 cpu number
;      - Modified init routine to check for cpu availability and set MCPU, Mc2pCPUmode and M040c2pUsage to appropriate defaults
;v1.37 - Added MAddXYToParticles and MAddXYToParticlesQ for adding X and Y constants to X and Y components in a particle list
;      - Added MAddXYToParticlesA to add constant value to list of Ptr.l particles
;      - Added MAddXToParticles, MAddYToParticles, MAddXToParticlesQ and MAddYToParticlesQ for further adding to particle lists
;v1.38 - Removed unnecessary code from MPlotParticlesA, MGrabParticlesA, MDrawParticlesA and MGrabParticlesAndPlotA
;      - Added MParticleMode to choose MColourMode, MReMapMode or MSimpleReMapMode for particle plot/draw
;      - Added MSimpleReMapMode and MReMapMode support to MPlotParticles, MPlotParticlesA and MPlotParticlesQ (clipping also!)
;      - Added MSimpleReMapMode and MReMapMode support to MDrawParticles, MDrawParticlesA and MDrawParticlesQ (clipping also!)
;      - Added MSimpleReMapMode and MReMapMode support to MGrabParticlesAndPlot[A/Q] for remap plot and normal grab (and clip!)
;      - Merged MAdd2ToParticles[A/Q] into extension of MAddToParticles[A/Q] to make friendlier interface & cut down on tokens
;      - Token order has been compromised due to removal of MAdd2ToParticles, MAdd2ToParticlesA and MAdd2ToParticlesQ !!!
;      - Fixed errornumber bugs in errorchecking routines of MShapePtr and MCookiePtr. Was Error28, should have been Error27
;      - Added support to MBitmapPtr, MStencilPtr, MShapePtr and MCookiePtr to assume currently used objects if no params
;      - Merged MAddXToParticles[Q] into special-case routine of MAddXYToParticles[Q] (called if Y is 0)
;      - Merged MAddYToParticles[Q] into special-case routine of MAddXYToParticles[Q] (called if X is 0)
;      - Token order has been compromised due to removal of MAddXToParticles[Q] and MAddYToParticles[Q] !!!
;v1.39 - Optimised routine PerformLine for speedup and less instructions
;      - Expanded MInk to allow specification of second and third inks to use
;      - Slightly rearranged internal data area and ensured alignment without Even4's, ready for extensions to access
;      - Added MMildredBase to return the base address of Mildred's internal data area
;      - Added lib support for returning base of Mildred's internal data area to other libraries, at the end of Initialise
;v1.40 - Added CRsrc_TotWidth to resource structure, for shapes and bitmaps, and added support code in necessary routines
;      - Modified many routines to read CRsrc_TotWidth rather than move.w mem->reg, add.w mem->reg. Slight general speedups
;      - Rearranged part of Mc2pWindow to check and set auto-use at the start as it was possibly trashed by the CacheClearU_()
;v1.41 - Made MParticleMode, MBlitMode, MQBlitMode, MSBlitMode, MQSBlitMode, MMaskScrollMode and MSMaskScrollMode into commands
;      - Slightly modified MUnQueue, negligible speedup, but better pipelining
;      - Added MDrawingMode to change mode used for drawing operations such as MPlot, MLine, MBoxF etc
;      - Added MDrawingMode support to MCls family for InvMode, MColourMode, MReMapMode and MSimpleReMapMode (no stencil remap!)
;      - Added MDrawingMode support to MPlot family for InvMode, MColourMode, MReMapMode and MSimpleReMapMode (no stencil remap)
;      - Added MDrawingMode support to MBoxF family for InvMode, MColourMode, MReMapMode and MSimpleReMapMode (no stencil remap)
;      - Added MDrawingMode support to MBox family for InvMode, MColourMode, MReMapMode and MSimpleReMapMode (no stencil remap!)
;      - Added MDrawingMode support to MLine family for InvMode, MColourMode, MReMapMode and MSimpleReMapMode (no stencil remap)
;v1.42 - Moved _DrawingModeType in data area and made it into a word, as it was mistakenly defined as a byte so was trashing
;      - Fixed bugs in MSTile32x32 and MSTile32x32Store, wrapping was not implemented for the dest stencil
;      - Slightly optimised routine PerformRemap and fixed bug in PerformRemapUsingShape as top half of d4 needed to be cleared
;      - Slightly optimised MUnQueue (bitmap form), speedup of about 0.1fps!
;      - Fixed major bug in routine PerformBlit1, ReMap mode routine was doing stencil cut but should have been a straight blit
;      - Added optimisation as routines PerformBlit1[b]_16, to do groups of 16 pixels instead of 4 if the width is a multiple
;      - Made M[c2pWindow][Shape][Bitmap]Width and M[c2pWindow][Shape][Bitmap]Height work without specified object number
;      - Made MAddr[c2pWindow][Shape][Bitmap][Queue][Table] work without specified object number
;      - Optimised macro RemakeStencil, used for generating a stencil or cookie from a bitmap or shape
;      - Added optimisation as routines PerformBlit2[b]_16, to do groups of 16 pixels instead of 4 if the width is a multiple
;      - Fixed major bug in routines PerformBlit2[b][_16] and PerformBlit3[b] in SolidMode write to mask was or instead of and
;      - Recoded all tile blits in 030 mode from movem.l's to move.l's and done modulos different. 2-3fps faster, on 040.
;      - Added optimisation as routines PerformBlit3[b]_16, to do groups of 16 pixels instead of 4 if the width is a multiple
;      - Optimised GenericBlit (scroll) routines, optimised for when width is multiple of 16 or multilpes of 64 for blockscroll
;      - Fixed bug in all tokens that add items to a queue. Upper word of d7 was corrupt due to unusual longword usage
;v1.43 - Added MParticleFormat to select mode for particle tokens, between 0=word, <0=quick and >0=actual memory addresses
;      - Merged Word/Quick/Address versions of particle commands into single commands, using MParticleFormat to choose
;      - Removed MReMap[Shape]UsingShape commands as they have been superceded by MDrawingMode functionality
;      - Removed Mc2pToggleSingle, Mc2pToggleDouble and Mc2pToggleTriple, as you might as well just use Mc2pToggle.
;      - Removed the MInitShape token and just kept with MShape for making new shapes
;      - Renamed MUse[c2pWindows][Shapes][Bitmaps][Queues][Tables] to the singular versions and removed the plurals
;      - Removed MMidHandle, MMidOrigin, MCopyHandle and MCopyOrigin completely
;      - Removed the unused MFlushTable completely
;      - Removed M040c2pUsage and any other tokens associated with its status.
;      - Merged MMakeCookies into MMakeCookie and removed MMakeCookies token
;      - Merged MMakeStencils into MMakeStencil and removed MMakeStencils token
;      - Merged MFree[c2pWindows][Shapes][Bitmaps][Cookies][Stencils][Queues][Tables] to the singular and removed the plurals
;      - Tokenisation has been severly compromised due to changes, deletions and additions.!!
;v1.44 - Moved MPictureDissolveIn token to the end of the library and renamed the old one to MNothing as the 128th token fails
;v1.45 - Killed Mc2pRowLacing, Mc2pColumnLacing, Mc2pRowToggle, Mc2pColumnToggle and Mc2pToggle. Tokens 1-5 free for use!
;      - Removed all code relating to interlaced c2p conversion, especially from Mc2pWindow, Mc2p and data area
;      - Changed c2pWindow structure to 8 bytes instead of 16 and allowed c2p0_Pixels to be .w or .l depending on modulos>0
;      - Modified Mc2pWindow and Mc2p to support non-modulo c2p routine, and implemented non-modulo c2p (040 and 030) into Mc2p
;      - Added MPictureDissolveOut to wipe image to a colour, bit faster than cross-wiping to blank image in MPictureDissolveIn
;      - Modified MCludge[Shape][Bitmap][Cookie][Stencil] to take the `-16' away from the programmer making base address actual
;      - Merged MUnQueueRange into extra syntax option of MUnQueue, still able to unqueue range without flush or all with flush
;      - Added MBlockUnQueue in place of MUnQueueRange for unqueing items with width and X coord multiple of 16 (doesn't check)
;      - Modified clearscreen mode of MUnQueue and MBlockUnQueue to use current ink instead of just 0's
;      - Tried to add stencil-unqueue (cut behind stencil) but failed, not enough regs, so removed
;      - Slightly optimised clearscreen mode of M[Block]UnQueue to do forwards operation and (an)+ (removes need for mulu)
;      - Slightly optimised routine PerformCls in all relevant blit modes
;v1.46 - Added MWrapXParticles and MWrapYParticles to do wrapping of only sides or top/bottom. No X-wrap for Ptr.l, however.
;      - Added MAddToXParticles and MAddToYParticles to add list(s) to particles but only one of the two components (Not Ptr.l)
;      - Fixed small bug in errorchecking routine of MAddToParticles, check for zero address occured when address was negative
;      - Fixed bug in clipping version of .q 2-adder routine in MAddToParticles, a3 needed to have a skip value added
;v1.47 - Fixed bugs in routine PerformGenericBlit2[b], optimised routines were copying stencil also but should be data only
;      - Added CustomOffsets.l to MScroll family, for using list of custom Width.w,X1Offset.w,X2Offset.w,SourceModulo.w values
;      - Added CustomOffsets.l to MSScroll family, for using list of custom Width.w,X1Offset.w,X2Offset.w,SourceModulo.w values
;      - Fixed bugs in generic blit routines, beq should have been blt for skipping if byte loopcounter was empty (-1 not 0)
;      - Optimised remainder-byte checking in PerformGenericBlit2[b]/5[b], was no need to test for zero bytes
;      - Small optimisation, changing bsr to bra if the jump is the last instruction of a routine, as there is no need to stack
;      - Added LongwordStore.l to data area for temporary storage of longwords, like when stacking it would not be possible
;      - Fixed bugs in errorchecking routines of MPointShape and MPointCookie, was jumping to Error28 instead of Error27
;      - Added [,Source.w] parameter to MPoint[Shape][Stencil][Cookie] to specify a source bitmap/shape for the operation
;      - Added MZoom, MZoomShape, MZoomBitmapToShape and MZoomShapeToBitmap, for zoomed unmasked scrolls (+CustomOffsets list!)
;      - Added macros CCheckXYFits2 and CCheckXYFits3 for use by errorchecking routines of MZoom[Shape][To][Bitmap]
;v1.48 - Fixed bug in routine PerformBlit1_16, indirect offsets in SimpleRemap were 0..3,0..3,0..3,0..3 should have been 0..15
;      - Optimised (1fps+) some scrolls that copy the stencil/cookie, as interleaving the moves is faster than as bursts
;      - Optimised some blit modes in PerformBlit1/2/3[b][_16] using phase-shift, pipelining and interleaved mem accesses
;      - Optimised the 030 tile routines a bit when doing an STile, by interleaving the moves
;      - Optimised the SimpleReMap modes in PerformBlit1[b]_16/2[b]_16/3[b]_16 when width is multiple of 16 (gains up to 2fps)
;      - Optimised zoom routines. Zooms with non-integer x factor are about 4fps faster
;      - Optimised all zoom routines using addx method instead of swap/swap/add, gains of about 3-4fps
;      - Added DeRes?.w as last compulsory param of zoom tokens, and added de-res routines to zooms
;      - Optimised zoom routines for when x factor is 1.0 to do extra-fast y-zoom, many fps faster
;      - Attempted to rewrite routine PerformLine using .q loop with addx, but it performed slower due to need to use divu.w
;      - Optimised CustomZoom[DeRes] that uses CustomOffsets.l to do groups of 4 pixels if width is multiple, gain up to 2fps+
;v1.49 - Added MAddMode which returns mode number 7 for use with various graphics routines to choose `Add' operations
;      - Added full support throughout the lib for MAddMode routines, byte values of source and dest are simply added together
;      - Updated the descriptions of numerous tokens to better represent recent changes
;      - Fixed bug in single-colour section of routine PerformReMap, loopcounter was screwy
;v1.50 - Fixed bugs in MWrapXParticles and MWrapYParticles, loops were BGE and should have been BGT, causing 1 illegal loop
;      - Fixed bugs in check routines of MBox[F] family, as tables were being checked for in MAddMode (where not necessary)
;v1.51 - Work resumed 27/02/2000 for the first time since 22/05/1999, copyright ownership has been reclaimed
;      - Bug identified in PerformBlit1/2/3_16[b] MSimpleReMapMode. Masking isn't working right, shape's cookie is blocks of 4!
;      - Macro RemakeStencil optimised by changing SNE.b to SEQ.b and removing the NOT.l, slight speedup making cookie/stencil
;      - Fixed bug in PerformBlit1/2/3_16[b] MSimpleReMapMode. Replaced TST.l with CMP.l #-1, as it was skipping 4 instead of 1
;      - Design flaw: Programmers should beware that cludged cookies/stencils must share the same linemodulo as the main data
;      - Optimised macro PerformYFlip for improved speed Yflipping if width is multiple of 16
;      - Optimised/recoded macro PerformXFlip for improved speed Xflipping if width is multiple of 4 or 16. ScrollDemo is 1fps+

#MildredLibNum=15

#PlaneSize=4 ; Dummy c2p SMC value
#LVOCacheClearU=-$27C
#LVOAvailMem=-$D8
#BlitzAllocmem=$c002
#BlitzFreemem=$c003
#ClearPublicMem=1|65536
#AttnFlags=$128 ; ExecBase\AttnFlags offset
#NumberOfShapeBanks=32
#_MOVE16_a0_a1=$F6209000 ; Opcode for MOVE16 (a0)+,(a1)+
#_MOVE16_a2_a3=$F622B000 ; Opcode for MOVE16 (a2)+,(a3)+
#_MOVE16_a4_a5=$F624D000 ; Opcode for MOVE16 (a4)+,(a5)+
#_MOVE16_a2_a0=$F6228000 ; Opcode for MOVE16 (a2)+,(a0)+

#c2pWindowStructSize=3 ; LSL for 8 bytes
#ChunkyResourceStructSize=6 ; LSL for 64 bytes
#ChunkyQueueStructSize=4 ; LSL for 16 bytes
#ChunkyQueueListStructBytes=16 ; 16 bytes without LSL
#ChunkyQueueListStructSize=4 ; LSL for 16 bytes
#ChunkyTableStructSize=4 ; LSL for 16 bytes

#_CookieMode=$FCA
#_EraseMode=$B0A
#_InvMode=$B5A
#_SolidMode=$BFA

!libheader {#MildredLibNum,Init,1,Finish,RunErrors}

;Definitions

!astatement
!args      {#long,#long}
!libs
!subs      {_MWrapXParticles,_MWrapXParticlesCheck,0}
!name      {"MWrapXParticles","CoordinateList.l,NumPoints.l ; Bring particles in from left/right edges (Not Ptr.l)"}

!astatement
!args      {#long,#long}
!libs
!subs      {_MWrapYParticles,_MWrapYParticlesCheck,0}
!name      {"MWrapYParticles","CoordinateList.l,NumPoints.l ; Bring particles in from top/bottom edges"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MAddToXParticlesShort,_MAddToXParticlesShortCheck,0}
!args      {#long,#long,#long,#long}
!libs
!subs      {_MAddToXParticles,_MAddToXParticlesCheck,0}
!name      {"MAddToXParticles","CoordinateList.l,NumPoints.l,IncA.l[,IncB.l] ; Add X components of [two sets of] increments"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MAddToYParticlesShort,_MAddToYParticlesShortCheck,0}
!args      {#long,#long,#long,#long}
!libs
!subs      {_MAddToYParticles,_MAddToYParticlesCheck,0}
!name      {"MAddToYParticles","CoordinateList.l,NumPoints.l,IncA.l[,IncB.l] ; Add Y components of [two sets of] increments"}

!afunction {#long}
!args
!libs
!subs      {_MAddMode,0,0}
!name      {"MAddMode","; Returns value 7 which represents `add' mode in the blit modes"}

!astatement
!args      {#byte}
!libs
!subs      {_Mc2pCPUmode,_Mc2pCPUmodeCheck,0}
!name      {"Mc2pCPUmode","CPU.b ; Set cpu c2p uses. Use `MProcessor' or `Processor'. <4=030-, >3=040+"}

!astatement
!args      {#word,#word,#word}
!libs
!subs      {_Mc2pWindowBriefShort,_Mc2pWindowBriefShortCheck,0}
!args      {#word,#word,#word,#byte}
!libs
!subs      {_Mc2pWindowBrief,_Mc2pWindowBriefCheck,0}
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_Mc2pWindowShort,_Mc2pWindowShortCheck,0}
!args      {#word,#word,#word,#word,#byte,#word,#word}
!libs
!subs      {_Mc2pWindow,_Mc2pWindowCheck,0}
!name      {"Mc2pWindow","c2pWindow#.w,OpWidth.w,OpHeight.w[,SourceBWidth.w[,Processor.b],PlanarWidth.w,PlanarHeight.w]"}

!afunction {#word}
!args
!libs
!subs      {_Mc2pWindowWidthShort,_Mc2pWindowWidthShortCheck,0}
!args      {#word}
!libs
!subs      {_Mc2pWindowWidth,_Mc2pWindowWidthCheck,0}
!name      {"Mc2pWindowWidth","[(c2pWindowNumber.w)] ; Returns width of c2pWindow"}

!afunction {#word}
!args
!libs
!subs      {_Mc2pWindowHeightShort,_Mc2pWindowHeightShortCheck,0}
!args      {#word}
!libs
!subs      {_Mc2pWindowHeight,_Mc2pWindowHeightCheck,0}
!name      {"Mc2pWindowHeight","[(c2pWindowNumber.w)] ; Returns height of c2pWindow"}

!astatement
!args      {#word,#word}
!libs
!subs      {_Mc2pWindowNewHeight,_Mc2pWindowNewHeightCheck,0}
!name      {"Mc2pWindowNewHeight","c2pWindow#.w,NewHeight.w ; Change height of already defined c2p object"}

!astatement
!args      {#long}
!libs
!subs      {_Mc2pShortest,_Mc2pShortestCheck,0}
!args      {#long,#long}
!libs
!subs      {_Mc2pShort,_Mc2pShortCheck,0}
!args      {#word,#long,#long}
!libs
!subs      {_Mc2p,_Mc2pCheck,0}
!name      {"Mc2p","[[c2pWindow#.w],Chunky.l],Planar.l ; Convert chunky to planar (Use Mc2pWindow first)"}

!acommand  {#long}
!args      {#word}
!libs
!subs      {_MReservec2pWindows,_MReservec2pWindowsCheck,0}
!name      {"MReservec2pWindows","[(]NumberOfWindows.w[)] ; Reserve structure-memory for c2pWindows"}

!acommand  {#long}
!args      {#word}
!libs
!subs      {_MReserveChunkyShapesShort,_MReserveChunkyShapesShortCheck,0}
!args      {#word,#word}
!libs
!subs      {_MReserveChunkyShapes,_MReserveChunkyShapesCheck,0}
!name      {"MReserveShapes","[(]NumberOfShapes.w[,ShapeBankToUse.w][)] ; Reserve structure-memory for Shapes"}

!acommand  {#long}
!args      {#word}
!libs
!subs      {_MReserveChunkyBitmaps,_MReserveChunkyBitmapsCheck,0}
!name      {"MReserveBitmaps","[(]NumberOfBitmaps.w[)] ; Reserve structure-memory for Bitmaps"}

!acommand  {#long}
!args      {#word,#word,#word}
!libs
!subs      {_MChunkyShape,_MChunkyShapeCheck,0}
!name      {"MShape","[(]ShapeNumber.w,Width.w,Height.w[)] ; Allocmem for shape data"}

!acommand  {#long}
!args      {#word,#word,#word}
!libs
!subs      {_MChunkyBitmap,_MChunkyBitmapCheck,0}
!name      {"MBitmap","[(]BitmapNumber.w,Width.w,Height.w[)] ; Allocmem for bitmap data"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyShapeCookie,0,0}
!name      {"MAutoCookie","On/Off ; Autocreation of ByteForByte cookies"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyBitmapStencil,0,0}
!name      {"MAutoStencil","On/Off ; Autocreation of ByteForByte stencils"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MFreec2pWindowsRange,_MFreec2pWindowsRangeCheck,0}
!args
!libs
!subs      {_MFreec2pWindows,_MFreec2pWindowsCheck,0}
!args      {#word}
!libs
!subs      {_MFreec2pWindow,_MFreec2pWindowCheck,0}
!name      {"MFreec2pWindow","[Firstc2pWindow.w[,Lastc2pWindow.w]] ; Free a c2pWindow, range of c2pWindows or all c2pWindows"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyShapesRange,_MFreeChunkyShapesRangeCheck,0}
!args
!libs
!subs      {_MFreeChunkyShapes,_MFreeChunkyShapesCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyShape,_MFreeChunkyShapeCheck,0}
!name      {"MFreeShape","[FirstShape.w[,LastShape.w]] ; Free a Shape, range of shapes, or all shapes"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyBitmapsRange,_MFreeChunkyBitmapsRangeCheck,0}
!args
!libs
!subs      {_MFreeChunkyBitmaps,_MFreeChunkyBitmapsCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyBitmap,_MFreeChunkyBitmapCheck,0}
!name      {"MFreeBitmap","[FirstBitmap.w[,LastBitmap.w]] ; Free a Bitmap, range of bitmaps, or all bitmaps"}

!afunction {#word}
!args
!libs
!subs      {_MChunkyShapeWidthShort,_MChunkyShapeWidthShortCheck,0}
!args      {#word}
!libs
!subs      {_MChunkyShapeWidth,_MChunkyShapeWidthCheck,0}
!name      {"MShapeWidth","[(ShapeNumber.w)] ; Returns width of Shape"}

!afunction {#word}
!args
!libs
!subs      {_MChunkyBitmapWidthShort,_MChunkyBitmapWidthShortCheck,0}
!args      {#word}
!libs
!subs      {_MChunkyBitmapWidth,_MChunkyBitmapWidthCheck,0}
!name      {"MBitmapWidth","[(BitmapNumber.w)] ; Returns width of Bitmap"}

!afunction {#word}
!args
!libs
!subs      {_MChunkyShapeHeightShort,_MChunkyShapeHeightShortCheck,0}
!args      {#word}
!libs
!subs      {_MChunkyShapeHeight,_MChunkyShapeHeightCheck,0}
!name      {"MShapeHeight","[(ShapeNumber.w)] ; Returns height of Shape"}

!afunction {#word}
!args
!libs
!subs      {_MChunkyBitmapHeightShort,_MChunkyBitmapHeightShortCheck,0}
!args      {#word}
!libs
!subs      {_MChunkyBitmapHeight,_MChunkyBitmapHeightCheck,0}
!name      {"MBitmapHeight","[(BitmapNumber.w)] ; Returns height of Bitmap"}

!afunction {#long}
!args
!libs
!subs      {_MAddrc2pWindowShort,_MAddrc2pWindowShortCheck,0}
!args      {#word}
!libs
!subs      {_MAddrc2pWindow,_MAddrc2pWindowCheck,0}
!name      {"MAddrc2pWindow","[(c2pWindowNumer.w)] ; Returns address of c2pWindow structure"}

!afunction {#long}
!args
!libs
!subs      {_MAddrChunkyShapeShort,_MAddrChunkyShapeShortCheck,0}
!args      {#word}
!libs
!subs      {_MAddrChunkyShape,_MAddrChunkyShapeCheck,0}
!name      {"MAddrShape","[(ShapeNumber.w)] ; Returns address of Shape structure"}

!afunction {#long}
!args
!libs
!subs      {_MAddrChunkyBitmapShort,_MAddrChunkyBitmapShortCheck,0}
!args      {#word}
!libs
!subs      {_MAddrChunkyBitmap,_MAddrChunkyBitmapCheck,0}
!name      {"MAddrBitmap","[(BitmapNumber.w)] ; Returns address of Bitmap structure"}

!astatement
!args      {#word,#word,#word}
!libs
!subs      {_MChunkyShapeHandle,_MChunkyShapeHandleCheck,0}
!name      {"MHandle","ShapeNumber.w,XOffset.w,YOffset.w ; Set handle of Shape"}

!astatement
!args      {#word,#word,#word}
!libs
!subs      {_MChunkyBitmapOrigin,_MChunkyBitmapOriginCheck,0}
!name      {"MBitmapOrigin","BitmapNumber.w,XOffset.w,YOffset.w ; Set origin of Bitmap"}

!astatement
!args      {#word}
!libs
!subs      {_MUsec2pWindowShortest,_MUsec2pWindowShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUsec2pWindowShort,_MUsec2pWindowShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUsec2pWindow,_MUsec2pWindowCheck,0}
!name      {"MUsec2pWindow","Mainc2pWindowNum.w[,Secondc2pWindowNum.w[,Thirdc2pWindowNum.w]] ; Current to use"}

!astatement
!args      {#word}
!libs
!subs      {_MUseChunkyShapeShortest,_MUseChunkyShapeShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUseChunkyShapeShort,_MUseChunkyShapeShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUseChunkyShape,_MUseChunkyShapeCheck,0}
!name      {"MUseShape","MainShapeNum.w[,SecondShapeNum.w[,ThirdShapeNum.w]] ; Current Shape(s) to use"}

!astatement
!args      {#word}
!libs
!subs      {_MUseChunkyBitmapShortest,_MUseChunkyBitmapShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUseChunkyBitmapShort,_MUseChunkyBitmapShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUseChunkyBitmap,_MUseChunkyBitmapCheck,0}
!name      {"MUseBitmap","MainBitmapNum.w[,SecondBitmapNum.w[,ThirdBitmapNum.w]] ; Current Bitmap(s) to use"}

!afunction {#word}
!args
!libs
!subs      {_MUsedc2pWindow,_MUsedc2pWindowCheck,0}
!name      {"MUsedc2pWindow"," ; Returns currently used c2pWindow"}

!afunction {#word}
!args
!libs
!subs      {_MUsedChunkyShape,_MUsedChunkyShapeCheck,0}
!name      {"MUsedShape"," ; Returns currently used Shape"}

!afunction {#word}
!args
!libs
!subs      {_MUsedChunkyBitmap,_MUsedChunkyBitmapCheck,0}
!name      {"MUsedBitmap"," ; Returns currently used Bitmap"}

!acommand  {#long}
!args      {#word,#word,#word,#long}
!libs
!subs      {_MCludgeChunkyShape,_MCludgeChunkyShapeCheck,0}
!name      {"MCludgeShape","ShapeNumber.w,Width.w,Height.w,Memory.l ; Cludge shape from existing mem"}

!acommand  {#long}
!args      {#word,#word,#word,#long}
!libs
!subs      {_MCludgeChunkyBitmap,_MCludgeChunkyBitmapCheck,0}
!name      {"MCludgeBitmap","BitmapNumber.w,Width.w,Height.w,Memory.l ; Cludge bitmap from existing mem"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoUsec2pWindows,0,0}
!name      {"MAutoUsec2pWindows","True/False ; Automatically `use' new c2pWindows. <>0=True"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoUseChunkyShapes,0,0}
!name      {"MAutoUseShapes","True/False ; Automatically `use' new shapes. <>0=True"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoUseChunkyBitmaps,0,0}
!name      {"MAutoUseBitmaps","True/False ; Automatically `use' new bitmaps. <>0=True"}

!astatement
!args
!libs
!subs      {_MMakeChunkyShapeCookiesShort,_MMakeChunkyShapeCookiesShortCheck,0}
!args      {#word,#word}
!libs
!subs      {_MMakeChunkyShapeCookies,_MMakeChunkyShapeCookiesCheck,0}
!args      {#word}
!libs
!subs      {_MMakeChunkyShapeCookie,_MMakeChunkyShapeCookieCheck,0}
!name      {"MMakeCookie","[FirstShape.w[,LastShape.w]] ; Make a cookie for a shape, range of shapes, or all shapes"}

!astatement
!args
!libs
!subs      {_MMakeChunkyBitmapStencilsShort,_MMakeChunkyBitmapStencilsShortCheck,0}
!args      {#word,#word}
!libs
!subs      {_MMakeChunkyBitmapStencils,_MMakeChunkyBitmapStencilsCheck,0}
!args      {#word}
!libs
!subs      {_MMakeChunkyBitmapStencil,_MMakeChunkyBitmapStencilCheck,0}
!name      {"MMakeStencil","[FirstBitmap.w[,LastBitmap.w]] ; Make a stencil for a bitmap, range of bitmaps, or all bitmaps"}

!astatement
!args
!libs
!subs      {_MFreeChunkyShapeCookies,_MFreeChunkyShapeCookiesCheck,0}
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyShapeCookiesRange,_MFreeChunkyShapeCookiesRangeCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyShapeCookie,_MFreeChunkyShapeCookieCheck,0}
!name      {"MFreeCookie","[FirstShape.w[,LastShape.w]] ; Free a Shape's cookie, a range of Shape's cookies, or all cookies"}

!astatement
!args
!libs
!subs      {_MFreeChunkyBitmapStencils,_MFreeChunkyBitmapStencilsCheck,0}
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyBitmapStencilsRange,_MFreeChunkyBitmapStencilsRangeCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyBitmapStencil,_MFreeChunkyBitmapStencilCheck,0}
!name      {"MFreeStencil","[FirstBitmap.w[,LastBitmap.w]] ; Free's a Bitmap's stencil, a range of stencils or all stencils"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyShapeWrapping,0,0}
!name      {"MAutoShapeWrap","On/Off ; Auto X&Y Handle-wrapping for Shapes"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyBitmapWrapping,0,0}
!name      {"MAutoBitmapWrap","On/Off ; Auto X&Y Handle-Wrapingp for Bitmaps"}

!astatement
!args      {#word,#byte}
!libs
!subs      {_MChunkyShapeWrapping,_MChunkyShapeWrappingCheck,0}
!name      {"MShapeWrap","ShapeNumber.w,On/Off ; De/Activate X&Y Handle-Wrap for Shape"}

!astatement
!args      {#word,#byte}
!libs
!subs      {_MChunkyBitmapWrapping,_MChunkyBitmapWrappingCheck,0}
!name      {"MBitmapWrap","BitmapNumber.w,On/Off ; De/Activate X&Y Handle-Wrap for Bitmap"}

!acommand  {#long}
!args      {#word,#word}
!libs
!subs      {_MCludgeChunkyShapeStruct,_MCludgeChunkyShapeStructCheck,0}
!name      {"MCludgeShapeStruct","[(]SourceShape.w,DestShape.w[)] ; Copy definition-data only"}

!acommand  {#long}
!args      {#word,#word}
!libs
!subs      {_MCludgeChunkyBitmapStruct,_MCludgeChunkyBitmapStructCheck,0}
!name      {"MCludgeBitmapStruct","[(]SourceBitmap.w,DestBitmap.w[)] ; Copy definition-data only"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MCopyc2pWindowStruct,_MCopyc2pWindowStructCheck,0}
!name      {"MCopyc2pWindow","Sourcec2pWindow.w,Destc2pWindow.w ; Copy definition-data only"}

!acommand  {#long}
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MChunkyShapeWindow,_MChunkyShapeWindowCheck,0}
!name      {"MShapeWindow","[(]SourceShape.w,DestShape.w,X.w,Y.w,Width.w,Height.w[)] ; Cludge Shape within a Shape"}

!acommand  {#long}
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MChunkyBitmapWindow,_MChunkyBitmapWindowCheck,0}
!name      {"MBitmapWindow","[(]SourceBitmap.w,DestBitmap.w,X.w,Y.w,Width.w,Height.w[)] ; Cludge Bitmap within a Bitmap"}

!acommand  {#long}
!args      {#word,#word}
!libs
!subs      {_MChunkyBitmapShape,_MChunkyBitmapShapeCheck,0}
!name      {"MBitmapShape","[(]SourceBitmap.w,DestShape.w[)] ; Copy definition-data only"}

!acommand  {#long}
!args      {#word,#word}
!libs
!subs      {_MChunkyShapesBitmap,_MChunkyShapesBitmapCheck,0}
!name      {"MShapesBitmap","[(]SourceShape.w,DestBitmap.w[)] ; Copy definition-data only"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyCookieXFlip,0,0}
!name      {"MAutoCookieXFlip","On/Off ; Auto X-Flip for Shape's cookie"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyCookieYFlip,0,0}
!name      {"MAutoCookieYFlip","On/Off ; Auto Y-Flip for Shape's cookie"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyStencilXFlip,0,0}
!name      {"MAutoStencilXFlip","On/Off ; Auto X-Flip for Bitmap's stencil"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyStencilYFlip,0,0}
!name      {"MAutoStencilYFlip","On/Off ; Auto Y-Flip for Bitmap's stencil"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyCookieFlipping,0,0}
!name      {"MAutoCookieFlip","On/Off ; Auto X&Y Cookie-Flip for Shapes"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyStencilFlipping,0,0}
!name      {"MAutoStencilFlip","On/Off ; Auto X&Y Stencil-Flip for Bitmaps"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyShapeXFlip,_MChunkyShapeXFlipCheck,0}
!name      {"MShapeXFlip","ShapeNumber.w ; Horizontally flip a Shape (see MAutoCookieFlip)"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyShapeYFlip,_MChunkyShapeYFlipCheck,0}
!name      {"MShapeYFlip","ShapeNumber.w ; Vertically flip a Shape (see MAutoCookieFlip)"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyBitmapXFlip,_MChunkyBitmapXFlipCheck,0}
!name      {"MBitmapXFlip","BitmapNumber.w ; Horizontally flip a Bitmap (see MAutoStencilFlip)"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyBitmapYFlip,_MChunkyBitmapYFlipCheck,0}
!name      {"MBitmapYFlip","BitmapNumber.w ; Vertically flip a Bitmap (see MAutoStencilFlip)"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyCookieXFlip,_MChunkyCookieXFlipCheck,0}
!name      {"MCookieXFlip","ShapeNumber.w ; Horizontally flip a Shape's cookie"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyCookieYFlip,_MChunkyCookieYFlipCheck,0}
!name      {"MCookieYFlip","ShapeNumber.w ; Vertically flip a Shape's cookie"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyStencilXFlip,_MChunkyStencilXFlipCheck,0}
!name      {"MStencilXFlip","BitmapNumber.w ; Horizontally flip a Bitmap's stencil"}

!astatement
!args      {#word}
!libs
!subs      {_MChunkyStencilYFlip,_MChunkyStencilYFlipCheck,0}
!name      {"MStencilYFlip","BitmapNumber.w ; Vertically flip a Bitmap's stencil"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyShapeClipping,0,0}
!name      {"MAutoShapeClip","Status.b ; Auto-clip new Shapes. On/Off"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoChunkyBitmapClipping,0,0}
!name      {"MAutoBitmapClip","Status.b ; Auto-clip new Bitmaps. On/Off"}

!astatement
!args      {#word,#byte}
!libs
!subs      {_MChunkyShapeClipSwitch,_MChunkyShapeClipSwitchCheck,0}
!args      {#word,#word,#word,#word,#word}
!libs
!subs      {_MChunkyShapeClipShort,_MChunkyShapeClipShortCheck,0}
!args      {#word,#word,#word,#word,#word,#byte}
!libs
!subs      {_MChunkyShapeClip,_MChunkyShapeClipCheck,0}
!name      {"MShapeClip","ShapeNumber.w[,X.w,Y.w,Width.w,Height.w][,Active] ; Active=On/Off. Define Shape's clip window"}

!astatement
!args      {#word,#byte}
!libs
!subs      {_MChunkyBitmapClipSwitch,_MChunkyBitmapClipSwitchCheck,0}
!args      {#word,#word,#word,#word,#word}
!libs
!subs      {_MChunkyBitmapClipShort,_MChunkyBitmapClipShortCheck,0}
!args      {#word,#word,#word,#word,#word,#byte}
!libs
!subs      {_MChunkyBitmapClip,_MChunkyBitmapClipCheck,0}
!name      {"MBitmapClip","BitmapNumber.w[,X.w,Y.w,Width.w,Height.w][,Active] ; Active=On/Off. Define Bitmap's clip window"}

!acommand  {#long}
!args      {#word,#word,#word,#word,#word}
!libs
!subs      {_MGetaChunkyShapeShort,_MGetaChunkyShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#byte,#byte}
!libs
!subs      {_MGetaChunkyShape,_MGetaChunkyShapeCheck,0}
!name      {"MGetaShape","ShapeNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,StencilIsCookie?] ; Grab shape from bitmap"}

!acommand  {#long}
!args      {#word,#word,#word,#word,#word}
!libs
!subs      {_MGetaChunkyBitmapShort,_MGetaChunkyBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#byte,#byte}
!libs
!subs      {_MGetaChunkyBitmap,_MGetaChunkyBitmapCheck,0}
!name      {"MGetaBitmap","BitmapNumber.w,X.w,Y.w,Width.w,Height.w[,Block?,CookieIsStencil?] ; Grab bitmap from shape"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollShort,_MScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScroll,_MScrollCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollCustom,_MScrollCustomCheck,0}
!name      {"MScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]] ; Copy graphic"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollShapeShort,_MScrollShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollShape,_MScrollShapeCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollShapeCustom,_MScrollShapeCustomCheck,0}
!name      {"MScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]] ; Copy graphic"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollStencilShort,_MScrollStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollStencil,_MScrollStencilCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollStencilCustom,_MScrollStencilCustomCheck,0}
!name      {"MScrollStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]] ; Copy sten to sten"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollCookieShort,_MScrollCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollCookie,_MScrollCookieCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollCookieCustom,_MScrollCookieCustomCheck,0}
!name      {"MScrollCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]] ;Copy cook to cook"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollShort,_MStencilScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScroll,_MStencilScrollCheck,0}
!name      {"MMaskScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; Copy bitmap graphic with stencil-cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollShort,_MCookieScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScroll,_MCookieScrollCheck,0}
!name      {"MMaskScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Copy shape graphic with cookie-cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollStencilShort,_MStencilScrollStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollStencil,_MStencilScrollStencilCheck,0}
!name      {"MMaskScrollStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w];Copy stencil2stencil & stencil-cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollCookieShort,_MCookieScrollCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollCookie,_MCookieScrollCookieCheck,0}
!name      {"MMaskScrollCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Copy cookie to cookie & cookie-cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollBitmapToShapeShort,_MScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollBitmapToShape,_MScrollBitmapToShapeCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollBitmapToShapeCustom,_MScrollBitmapToShapeCustomCheck,0}
!name      {"MScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]];bitmap 2 shape"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollShapeToBitmapShort,_MScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollShapeToBitmap,_MScrollShapeToBitmapCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollShapeToBitmapCustom,_MScrollShapeToBitmapCustomCheck,0}
!name      {"MScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]] ;shape 2 bitmap"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollStencilToCookieShort,_MScrollStencilToCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollStencilToCookie,_MScrollStencilToCookieCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollStencilToCookieCustom,_MScrollStencilToCookieCustomCheck,0}
!name      {"MScrollStencilToCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]]; sten2cookie"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollCookieToStencilShort,_MScrollCookieToStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MScrollCookieToStencil,_MScrollCookieToStencilCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MScrollCookieToStencilCustom,_MScrollCookieToStencilCustomCheck,0}
!name      {"MScrollCookieToStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]] ; cookie2sten"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollBitmapToShapeShort,_MStencilScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollBitmapToShape,_MStencilScrollBitmapToShapeCheck,0}
!name      {"MMaskScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; Copy bitmap to shape & cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollShapeToBitmapShort,_MCookieScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollShapeToBitmap,_MCookieScrollShapeToBitmapCheck,0}
!name      {"MMaskScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Copy shape to bitmap & cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollStencilToCookieShort,_MStencilScrollStencilToCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MStencilScrollStencilToCookie,_MStencilScrollStencilToCookieCheck,0}
!name      {"MMaskScrollStencilToCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ;Copy stencil2cookie & cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollCookieToStencilShort,_MCookieScrollCookieToStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MCookieScrollCookieToStencil,_MCookieScrollCookieToStencilCheck,0}
!name      {"MMaskScrollCookieToStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Copy cookie2stencil & cut"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollShort,_MBlockScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScroll,_MBlockScrollCheck,0}
!name      {"MBlockScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; BlockCopy graphic"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollShapeShort,_MBlockScrollShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollShape,_MBlockScrollShapeCheck,0}
!name      {"MBlockScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; BlockCopy graphic"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollStencilShort,_MBlockScrollStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollStencil,_MBlockScrollStencilCheck,0}
!name      {"MBlockScrollStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; BlockCopy stencil to stencil"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollCookieShort,_MBlockScrollCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollCookie,_MBlockScrollCookieCheck,0}
!name      {"MBlockScrollCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; BlockCopy cookie to cookie"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollBitmapToShapeShort,_MBlockScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollBitmapToShape,_MBlockScrollBitmapToShapeCheck,0}
!name      {"MBlockScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; BlockCopy bitmap to shape"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollShapeToBitmapShort,_MBlockScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollShapeToBitmap,_MBlockScrollShapeToBitmapCheck,0}
!name      {"MBlockScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; BlockCopy shape to bitmap"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollStencilToCookieShort,_MBlockScrollStencilToCookieShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollStencilToCookie,_MBlockScrollStencilToCookieCheck,0}
!name      {"MBlockScrollStencilToCookie","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w];BlockCopy stencil2cookie"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollCookieToStencilShort,_MBlockScrollCookieToStencilShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MBlockScrollCookieToStencil,_MBlockScrollCookieToStencilCheck,0}
!name      {"MBlockScrollCookieToStencil","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; BlockCopy cookie2stencil"}

!astatement
!args      {#byte}
!libs
!subs      {_MCPU,_MCPUCheck,0}
!name      {"MCPU","Processor.b ; Set cpu routines allowed to use. CAREFUL!! Try using `MProcessor' or `Processor'"}

!astatement
!args
!libs
!subs      {_MClsShort,_MClsShortCheck,0}
!args      {#byte}
!libs
!subs      {_MCls,_MClsCheck,0}
!name      {"MCls","[Colour] Clear a bitmap to colour 0 or the specified colour (in DrawingMode)"}

!astatement
!args
!libs
!subs      {_MClsShapeShort,_MClsShapeShortCheck,0}
!args      {#byte}
!libs
!subs      {_MClsShape,_MClsShapeCheck,0}
!name      {"MClsShape","[Colour] Clear a shape to colour 0 or the specified colour (in DrawingMode)"}

!astatement
!args
!libs
!subs      {_MClsStencilShort,_MClsStencilShortCheck,0}
!args      {#byte}
!libs
!subs      {_MClsStencil,_MClsStencilCheck,0}
!name      {"MClsStencil","[Colour] Clear a stencil to colour 0 or the specified colour (in DrawingMode)"}

!astatement
!args
!libs
!subs      {_MClsCookieShort,_MClsCookieShortCheck,0}
!args      {#byte}
!libs
!subs      {_MClsCookie,_MClsCookieCheck,0}
!name      {"MClsCookie","[Colour] Clear a cookie to colour 0 or the specified colour (in DrawingMode)"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MPlotShort,_MPlotShortCheck,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MPlot,_MPlotCheck,0}
!name      {"MPlot","Xpos.w,Ypos.w[,Colour] ; Plot a single pixel in the bitmap in DrawingMode "}

!astatement
!args      {#word,#word}
!libs
!subs      {_MPlotShapeShort,_MPlotShapeShortCheck,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MPlotShape,_MPlotShapeCheck,0}
!name      {"MPlotShape","Xpos.w,Ypos.w[,Colour] ; Plot a single pixel in the shape in DrawingMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MPlotStencilShort,_MPlotStencilShortCheck,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MPlotStencil,_MPlotStencilCheck,0}
!name      {"MPlotStencil","Xpos.w,Ypos.w[,Colour] ;Plot a single pixel in the stencil to *represent* DrawingMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MPlotCookieShort,_MPlotCookieShortCheck,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MPlotCookie,_MPlotCookieCheck,0}
!name      {"MPlotCookie","Xpos.w,Ypos.w[,Colour] ; Plot a single pixel in the cookie to *represent* DrawingMode"}

!afunction {#byte}
!args      {#word,#word}
!libs
!subs      {_MPointShort,_MPointShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MPoint,_MPointCheck,0}
!name      {"MPoint","(Xpos.w,Ypos.w[,BitmapToRead.w]) ; Return the colour of a single pixel in a bitmap"}

!afunction {#byte}
!args      {#word,#word}
!libs
!subs      {_MPointShapeShort,_MPointShapeShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MPointShape,_MPointShapeCheck,0}
!name      {"MPointShape","(Xpos.w,Ypos.w[,ShapeToRead.w]) ; Return the colour of a single pixel in a shape"}

!afunction {#byte}
!args      {#word,#word}
!libs
!subs      {_MPointStencilShort,_MPointStencilShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MPointStencil,_MPointStencilCheck,0}
!name      {"MPointStencil","(Xpos.w,Ypos.w[,BitmapToRead.w]) ;Return the status of a pixel in stencil. -1=Data, 0=Background"}

!afunction {#byte}
!args      {#word,#word}
!libs
!subs      {_MPointCookieShort,_MPointCookieShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MPointCookie,_MPointCookieCheck,0}
!name      {"MPointCookie","(Xpos.w,Ypos.w[,ShapeToRead.w]) ; Return the status of a pixel in cookie. -1=Data, 0=Background"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollShort,_MDoubleScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScroll,_MDoubleScrollCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MDoubleScrollCustom,_MDoubleScrollCustomCheck,0}
!name      {"MSScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]] ; Copy bm 2 bm and st 2 st"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollShapeShort,_MDoubleScrollShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollShape,_MDoubleScrollShapeCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MDoubleScrollShapeCustom,_MDoubleScrollShapeCustomCheck,0}
!name      {"MSScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]] ; Copy sh2sh and ck2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollBitmapToShapeShort,_MDoubleScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollBitmapToShape,_MDoubleScrollBitmapToShapeCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MDoubleScrollBitmapToShapeCustom,_MDoubleScrollBitmapToShapeCustomCheck,0}
!name      {"MSScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w[,CustomOffsets.l]];bm2shandst2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollShapeToBitmapShort,_MDoubleScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleScrollShapeToBitmap,_MDoubleScrollShapeToBitmapCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MDoubleScrollShapeToBitmapCustom,_MDoubleScrollShapeToBitmapCustomCheck,0}
!name      {"MSScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w[,CustomOffsets.l]]; sh2bmandck2st"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleStencilScrollShort,_MDoubleStencilScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleStencilScroll,_MDoubleStencilScrollCheck,0}
!name      {"MSMaskScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; Stencil-Copy bm 2 bm and st 2 st"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleCookieScrollShort,_MDoubleCookieScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleCookieScroll,_MDoubleCookieScrollCheck,0}
!name      {"MSMaskScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Cookie-Copy sh2sh and ck2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleStencilScrollBitmapToShapeShort,_MDoubleStencilScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleStencilScrollBitmapToShape,_MDoubleStencilScrollBitmapToShapeCheck,0}
!name      {"MSMaskScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ;Sten-Copy bm2sh&st2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleCookieScrollShapeToBitmapShort,_MDoubleCookieScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleCookieScrollShapeToBitmap,_MDoubleCookieScrollShapeToBitmapCheck,0}
!name      {"MSMaskScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Cook-Copy sh2bm&ck2st"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollShort,_MDoubleBlockScrollShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScroll,_MDoubleBlockScrollCheck,0}
!name      {"MSBlockScroll","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w] ; Block-Copy bm 2 bm and st 2 st"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollShapeShort,_MDoubleBlockScrollShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollShape,_MDoubleBlockScrollShapeCheck,0}
!name      {"MSBlockScrollShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w] ; Block-Copy sh2sh and ck2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollBitmapToShapeShort,_MDoubleBlockScrollBitmapToShapeShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollBitmapToShape,_MDoubleBlockScrollBitmapToShapeCheck,0}
!name      {"MSBlockScrollBitmapToShape","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceBitmapNum.w];BlockCopy bm2sh&st2ck"}

!astatement
!args      {#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollShapeToBitmapShort,_MDoubleBlockScrollShapeToBitmapShortCheck,0}
!args      {#word,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MDoubleBlockScrollShapeToBitmap,_MDoubleBlockScrollShapeToBitmapCheck,0}
!name      {"MSBlockScrollShapeToBitmap","X1.w,Y1.w,Width.w,Height.w,X2.w,Y2.w[,SourceShapeNum.w];BlockCopy sh2bm&ck2st"}

!astatement
!args      {#byte}
!libs
!subs      {_MDoubleScrollCut,0,0}
!name      {"MSScrollCut","On/Off ; 0=Paste stencil/cookie, <>0=Cut using stencil/cookie"}

!astatement
!args      {#word}
!libs
!subs      {_MUseChunkyShapeBank,_MUseChunkyShapeBankCheck,0}
!name      {"MUseShapeBank","BankNumber.w ; Current shape bank, 0..31"}

!astatement
!args
!libs
!subs      {_MNothing,0,0}
!name      {"MNothing","; This is the 128th token and it doesn't work so is a dummy"}

!acommand  {#word}
!args
!libs
!subs      {_MSScrollModeShort,0,0}
!args      {#word}
!libs
!subs      {_MSScrollMode,_MSScrollModeCheck,0}
!name {"MMaskScrollMode","[([]Mode.w[])];CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMo"}

!acommand  {#word}
!args
!libs
!subs      {_MBlitModeShort,0,0}
!args      {#word}
!libs
!subs      {_MBlitMode,_MBlitModeCheck,0}
!name  {"MBlitMode","[([]Mode.w[])] ; CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MBlitShort,_MBlitShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MBlit,_MBlitCheck,0}
!name      {"MBlit","[ShapeNumber.w,]Xpos.w,Ypos,w ; Blit shape to bitmap, any coords"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MBlockShort,_MBlockShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MBlock,_MBlockCheck,0}
!name      {"MBlock","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit shape to bitmap, align Xpos and width in multiples of 16!"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTile16x16Short,_MTile16x16ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTile16x16,_MTile16x16Check,0}
!name      {"MTile16x16","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 16x16 shape to bitmap, size must be 16x16, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTile32x32Short,_MTile32x32ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTile32x32,_MTile32x32Check,0}
!name      {"MTile32x32","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 32x32 shape to bitmap, size must be 32x32, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleTile16x16Short,_MDoubleTile16x16ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleTile16x16,_MDoubleTile16x16Check,0}
!name      {"MSTile16x16","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 16x16 shape&cook 2 bitmap, size 16x16, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleTile32x32Short,_MDoubleTile32x32ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleTile32x32,_MDoubleTile32x32Check,0}
!name      {"MSTile32x32","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 32x32 shape&cook 2 bitmap, size 32x32, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTripleTile16x16Short,_MTripleTile16x16ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTripleTile16x16,_MTripleTile16x16Check,0}
!name      {"MSTile16x16Store","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 16x16 shape&cook 2 bitmaps, size 16x16, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTripleTile32x32Short,_MTripleTile32x32ShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTripleTile32x32,_MTripleTile32x32Check,0}
!name      {"MSTile32x32Store","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 32x32 shape&cook 2 bitmaps, size 32x32, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTile16x16TwiceShort,_MTile16x16TwiceShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTile16x16Twice,_MTile16x16TwiceCheck,0}
!name      {"MTile16x16Store","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 16x16 shape to 2 bitmaps, size 16x16, align x/y"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MTile32x32TwiceShort,_MTile32x32TwiceShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MTile32x32Twice,_MTile32x32TwiceCheck,0}
!name      {"MTile32x32Store","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit 32x32 shape to 2 bitmaps, size 32x32, align x/y"}

!acommand  {#long}
!args      {#word}
!libs
!subs      {_MReserveChunkyQueues,_MReserveChunkyQueuesCheck,0}
!name      {"MReserveQueues","[(]NumberOfQueues.w[)] ; Reserve structure-memory for Queues"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyQueuesRange,_MFreeChunkyQueuesRangeCheck,0}
!args
!libs
!subs      {_MFreeChunkyQueues,_MFreeChunkyQueuesCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyQueue,_MFreeChunkyQueueCheck,0}
!name      {"MFreeQueue","[FirstQueue.w[,LastQueue.w]] ; Free a Queue, a range of queues, or all queues"}

!afunction {#long}
!args
!libs
!subs      {_MAddrChunkyQueueShort,_MAddrChunkyQueueShortCheck,0}
!args      {#word}
!libs
!subs      {_MAddrChunkyQueue,_MAddrChunkyQueueCheck,0}
!name      {"MAddrQueue","[(QueueNumber.w)] ; Returns address of Queue structure"}

!acommand  {#long}
!args      {#word,#word}
!libs
!subs      {_MChunkyQueue,_MChunkyQueueCheck,0}
!name      {"MQueue","[(]QueueNumber.w,NumberOfItems.w[)] ; Allocmem for Queue list items"}

!astatement
!args      {#word}
!libs
!subs      {_MFlushChunkyQueue,_MFlushChunkyQueueCheck,0}
!name      {"MFlushQueue","QueueNumber.w ; Empties the queue to contain no items"}

!acommand  {#word}
!args
!libs
!subs      {_MQBlitModeShort,0,0}
!args      {#word}
!libs
!subs      {_MQBlitMode,_MQBlitModeCheck,0}
!name {"MQBlitMode","[([]Mode.w[])] ; CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoUseChunkyQueues,0,0}
!name      {"MAutoUseQueues","True/False ; Automatically `use' new Queues. <>0=True"}

!astatement
!args      {#word}
!libs
!subs      {_MUseChunkyQueueShortest,_MUseChunkyQueueShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUseChunkyQueueShort,_MUseChunkyQueueShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUseChunkyQueue,_MUseChunkyQueueCheck,0}
!name      {"MUseQueue","MainQueueNum.w[,SecondQueueNum.w[,ThirdQueueNum.w]] ; Current queue(s) to use"}

!afunction {#word}
!args
!libs
!subs      {_MUsedChunkyQueue,_MUsedChunkyQueueCheck,0}
!name      {"MUsedQueue"," ; Returns currently used Queue"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MQBlitShortest,_MQBlitShortestCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MQBlitShort,_MQBlitShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MQBlit,_MQBlitCheck,0}
!name      {"MQBlit","[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w ; QBlit shape to bitmap, any coords"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MQBlockShortest,_MQBlockShortestCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MQBlockShort,_MQBlockShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MQBlock,_MQBlockCheck,0}
!name      {"MQBlock","[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w ; QBlock-blit shape 2 bitmap, align Xpos & width in mult of 16"}

!astatement
!args      {#word}
!libs
!subs      {_MUnQueueShort,_MUnQueueShortCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUnQueue,_MUnQueueCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUnQueueRangeShort,_MUnQueueRangeShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MUnQueueRange,_MUnQueueRangeCheck,0}
!name      {"MUnQueue","QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w] ; UnQueue [range of] queued objects [&flush]"}

!afunction {#long}
!args
!libs
!subs      {_MBitmapPtrAssume,_MBitmapPtrAssumeCheck,0}
!args      {#word}
!libs
!subs      {_MBitmapPtrShortest,_MBitmapPtrShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MBitmapPtrShort,_MBitmapPtrShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MBitmapPtr,_MBitmapPtrCheck,0}
!name      {"MBitmapPtr","[Xpos.w,Ypos.w][,BitmapNumber.w] ; Return data address calculated using bitmap [and coords]"}

!afunction {#long}
!args
!libs
!subs      {_MShapePtrAssume,_MShapePtrAssumeCheck,0}
!args      {#word}
!libs
!subs      {_MShapePtrShortest,_MShapePtrShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MShapePtrShort,_MShapePtrShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MShapePtr,_MShapePtrCheck,0}
!name      {"MShapePtr","[Xpos.w,Ypos.w][,ShapeNumber.w] ; Return data address calculated using shape [and coords]"}

!afunction {#long}
!args
!libs
!subs      {_MStencilPtrAssume,_MStencilPtrAssumeCheck,0}
!args      {#word}
!libs
!subs      {_MStencilPtrShortest,_MStencilPtrShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MStencilPtrShort,_MStencilPtrShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MStencilPtr,_MStencilPtrCheck,0}
!name      {"MStencilPtr","[Xpos.w,Ypos.w][,BitmapNumber.w] ; Return address calculated using stencil [and coords]"}

!afunction {#long}
!args
!libs
!subs      {_MCookiePtrAssume,_MCookiePtrAssumeCheck,0}
!args      {#word}
!libs
!subs      {_MCookiePtrShortest,_MCookiePtrShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MCookiePtrShort,_MCookiePtrShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MCookiePtr,_MCookiePtrCheck,0}
!name      {"MCookiePtr","[Xpos.w,Ypos.w][,ShapeNumber.w] ; Return address calculated using cookie [and coords]"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MQDummyShort,_MQDummyShortCheck,0}
!args      {#word,#word,#word,#word,#word}
!libs
!subs      {_MQDummy,_MQDummyCheck,0}
!name      {"MQDummy","[Queue.w,]Xpos.w,Ypos.w,Width.w,Height.w ; Add an item to a queue without having to do a blit"}

!acommand  {#word}
!args
!libs
!subs      {_MDoubleBlitModeShort,0,0}
!args      {#word}
!libs
!subs      {_MDoubleBlitMode,_MDoubleBlitModeCheck,0}
!name {"MSBlitMode","[([]Mode.w[])] ; CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleBlitShort,_MDoubleBlitShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleBlit,_MDoubleBlitCheck,0}
!name      {"MSBlit","[ShapeNumber.w,]Xpos.w,Ypos,w ; Blit shape to bitmap and cookie to stencil, any coords"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleBlockShort,_MDoubleBlockShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleBlock,_MDoubleBlockCheck,0}
!name      {"MSBlock","[ShapeNumber.w,]Xpos.w,Ypos.w ; Block-blit shape to bitmap & cookie 2 stencil, Xpos&Width in 16's"}

!astatement
!args      {#byte}
!libs
!subs      {_MDoubleBlitCut,0,0}
!name      {"MSBlitCut","On/Off ; 0=Paste stencil/cookie, <>0=Cut using stencil/cookie"}

!acommand  {#word}
!args
!libs
!subs      {_MDoubleQBlitModeShort,0,0}
!args      {#word}
!libs
!subs      {_MDoubleQBlitMode,_MDoubleQBlitModeCheck,0}
!name {"MQSBlitMode","[([]Mode.w[])] ;CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleQBlitShortest,_MDoubleQBlitShortestCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleQBlitShort,_MDoubleQBlitShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MDoubleQBlit,_MDoubleQBlitCheck,0}
!name      {"MQSBlit","[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos,w ; QBlit shape to bitmap and cookie to stencil, any coords"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MDoubleQBlockShortest,_MDoubleQBlockShortestCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MDoubleQBlockShort,_MDoubleQBlockShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MDoubleQBlock,_MQBlockCheck,0}
!name      {"MQSBlock","[[Queue.w,]ShapeNumber.w,]Xpos.w,Ypos.w ; QBlock-blit shape 2 bitmap, Xpos&width mult of 16"}

!astatement
!args      {#byte}
!libs
!subs      {_MDoubleQBlitCut,0,0}
!name      {"MQSBlitCut","On/Off ; 0=Paste stencil/cookie, <>0=Cut using stencil/cookie. Adds entry to queue"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxFShort,_MBoxFShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxF,_MBoxFCheck,0}
!name      {"MBoxF","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a bitmap in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxFShapeShort,_MBoxFShapeShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxFShape,_MBoxFShapeCheck,0}
!name      {"MBoxFShape","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a shape in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxFStencilShort,_MBoxFStencilShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxFStencil,_MBoxFStencilCheck,0}
!name      {"MBoxFStencil","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a stencil in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxFCookieShort,_MBoxFCookieShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxFCookie,_MBoxFCookieCheck,0}
!name      {"MBoxFCookie","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw a filled box in a cookie in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxShort,_MBoxShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBox,_MBoxCheck,0}
!name      {"MBox","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a bitmap in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxShapeShort,_MBoxShapeShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxShape,_MBoxShapeCheck,0}
!name      {"MBoxShape","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a shape in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxStencilShort,_MBoxStencilShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxStencil,_MBoxStencilCheck,0}
!name      {"MBoxStencil","Xpos.w,Ypos.w,Xpos2.w,Ypos2.w[,Colour] Draw an unfilled box in a stencil in DrawingMode"}

!astatement
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBoxCookieShort,_MBoxCookieShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MBoxCookie,_MBoxCookieCheck,0}
!name      {"MBoxCookie","Xpos.w,Ypos.w,Width.w,Height.w[,Colour] Draw an unfilled box in a cookie in DrawingMode"}

!astatement
!args      {#word,#long}
!libs
!subs      {_MPlanar16ToBitmapShort,_MPlanar16ToBitmapShortCheck,0}
!args      {#word,#long,#word,#word,#word,#word}
!libs
!subs      {_MPlanar16ToBitmap,_MPlanar16ToBitmapCheck,0}
!name      {"MPlanar16ToBitmap","BitmapNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w] ; Convert p2c"}

!astatement
!args      {#word,#long}
!libs
!subs      {_MPlanar16ToShapeShort,_MPlanar16ToShapeShortCheck,0}
!args      {#word,#long,#word,#word,#word,#word}
!libs
!subs      {_MPlanar16ToShape,_MPlanar16ToShapeCheck,0}
!name      {"MPlanar16ToShape","ShapeNum.w,PlanarAddr.l[,OpWidth.w,OpHeight.w,PlanarWidth.w,PlanarHeight.w] ; Convert p2c"}

!afunction {#long}
!args      {#word,#word,#long,#word}
!libs
!subs      {_MGenericPtr,_MGenericPtrCheck,0}
!name      {"MGenericPtr","Xpos.w,Ypos.w,BaseAddress.l,RowWidth.w ; Calculate and return address based on inputs"}

!acommand  {#long}
!args      {#word,#long}
!libs
!subs      {_MCludgeCookie,_MCludgeCookieCheck,0}
!name      {"MCludgeCookie","ShapeNumber.w,Memory.l ; Cludge shape's cookie from existing mem"}

!acommand  {#long}
!args      {#word,#long}
!libs
!subs      {_MCludgeStencil,_MCludgeStencilCheck,0}
!name      {"MCludgeStencil","BitmapNumber.w,Memory.l ; Cludge bitmap's stencil from existing mem"}

!astatement
!args      {#word}
!libs
!subs      {_MBlockUnQueueShort,_MBlockUnQueueShortCheck,0}
!args      {#word,#word}
!libs
!subs      {_MBlockUnQueue,_MBlockUnQueueCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MBlockUnQueueRangeShort,_MBlockUnQueueRangeShortCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MBlockUnQueueRange,_MBlockUnQueueRangeCheck,0}
!name      {"MBlockUnQueue","QueueNumber.w[,FirstItem.w,LastItem.w][,BitmapNumber.w];Block-UnQueue [range of] objects[&flush]"}

!astatement
!args      {#long}
!libs
!subs      {_MReMapShortest,_MReMapShortestCheck,0}
!args      {#long,#word}
!libs
!subs      {_MReMapShort,_MReMapShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MReMap,_MReMapCheck,0}
!name      {"MReMap","[Colour#0.b,Colour#1.b,BitmapNum.w] *or* [RemapTable.l[,BitmapNum.w]] ; Remap #0 to #1 or with table"}

!astatement
!args      {#long}
!libs
!subs      {_MReMapShapeShortest,_MReMapShapeShortestCheck,0}
!args      {#long,#word}
!libs
!subs      {_MReMapShapeShort,_MReMapShapeShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MReMapShape,_MReMapShapeCheck,0}
!name      {"MReMapShape","[Colour#0.b,Colour#1.b,ShapeNum.w] *or* [RemapTable.l[,ShapeNum.w]] ; Remap #0 to #1 or with table"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MLineShortest2,_MLineShortest2Check,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MLineShortest,_MLineShortestCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MLineShort,_MLineShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MLine,_MLineCheck,0}
!name      {"MLine","[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b] ;Draw a line from X1,Y1 to X2,Y2 in a Bitmap in DrawingMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MLineShapeShortest2,_MLineShapeShortest2Check,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MLineShapeShortest,_MLineShapeShortestCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MLineShapeShort,_MLineShapeShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MLineShape,_MLineShapeCheck,0}
!name   {"MLineShape","[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b] ;Draw a line from X1,Y1 to X2,Y2 in a Shape in DrawingMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MLineStencilShortest2,_MLineStencilShortest2Check,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MLineStencilShortest,_MLineStencilShortestCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MLineStencilShort,_MLineStencilShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MLineStencil,_MLineStencilCheck,0}
!name {"MLineStencil","[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b];Draw a line from X1,Y1 to X2,Y2 in a stencil in DrawingMode"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MLineCookieShortest2,_MLineCookieShortest2Check,0}
!args      {#word,#word,#byte}
!libs
!subs      {_MLineCookieShortest,_MLineCookieShortestCheck,0}
!args      {#word,#word,#word,#word}
!libs
!subs      {_MLineCookieShort,_MLineCookieShortCheck,0}
!args      {#word,#word,#word,#word,#byte}
!libs
!subs      {_MLineCookie,_MLineCheck,0}
!name  {"MLineCookie","[Xpos.w,Ypos.w,]Xpos2.w,Ypos2.w[,Colour.b] ;Draw a line from X1,Y1 to X2,Y2 in a cookie in DrawingMode"}

!astatement
!args      {#word}
!libs
!subs      {_MInkShortest,_MInkShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MInkShort,_MInkShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MInk,_MInkCheck,0}
!name      {"MInk","MainColour.b[,SecondColour.b[,ThirdColour.b]] ; Set what colour to assume as currently used. 0..255"}

!afunction {#long}
!args
!libs
!subs      {_MColourMode,0,0}
!name      {"MColourMode",";Returns value 4 which represents `colour' mode in the blit modes"}

!acommand  {#long}
!args      {#word}
!libs
!subs      {_MReserveChunkyTables,_MReserveChunkyTablesCheck,0}
!name      {"MReserveTables","[(]NumberOfTables.w[)] ; Reserve structure-memory for Tables"}

!astatement
!args      {#word,#word}
!libs
!subs      {_MFreeChunkyTablesRange,_MFreeChunkyTablesRangeCheck,0}
!args
!libs
!subs      {_MFreeChunkyTables,_MFreeChunkyTablesCheck,0}
!args      {#word}
!libs
!subs      {_MFreeChunkyTable,_MFreeChunkyTableCheck,0}
!name      {"MFreeTable","[FirstTable.w[,LastTable.w]] TableNumber.w ; Free a Table, a range of tables or all tables"}

!afunction {#long}
!args
!libs
!subs      {_MAddrChunkyTableShort,_MAddrChunkyTableShortCheck,0}
!args      {#word}
!libs
!subs      {_MAddrChunkyTable,_MAddrChunkyTableCheck,0}
!name      {"MAddrTable","[(TableNumber.w)] ; Returns address of Table structure"}

!acommand  {#long}
!args      {#word,#long}
!libs
!subs      {_MChunkyTable,_MChunkyTableCheck,0}
!name      {"MTable","[(]TableNumber.w,SizeInBytes.l[)] ; Allocmem for Table list items"}

!astatement
!args      {#byte}
!libs
!subs      {_MAutoUseChunkyTables,0,0}
!name      {"MAutoUseTables","True/False ; Automatically `use' new Tables. <>0=True"}

!astatement
!args      {#word}
!libs
!subs      {_MUseChunkyTableShortest,_MUseChunkyTableShortestCheck,0}
!args      {#word,#word}
!libs
!subs      {_MUseChunkyTableShort,_MUseChunkyTableShortCheck,0}
!args      {#word,#word,#word}
!libs
!subs      {_MUseChunkyTable,_MUseChunkyTableCheck,0}
!name      {"MUseTable","MainTableNum.w[,SecondTableNum.w[,ThirdTableNum.w]] ; Current table(s) to use"}

!afunction {#word}
!args
!libs
!subs      {_MUsedChunkyTable,_MUsedChunkyTableCheck,0}
!name      {"MUsedTable"," ; Returns currently used Table"}

!afunction {#long}
!args
!libs
!subs      {_MTablePtrShort,_MTablePtrShortCheck,0}
!args      {#word}
!libs
!subs      {_MTablePtr,_MTablePtrCheck,0}
!name      {"MTablePtr","[TableNum.w] ; Returns pointer to base of the table itself"}

!afunction {#long}
!args
!libs
!subs      {_MReMapMode,0,0}
!name      {"MReMapMode",";Returns value 5 which represents `ReMap' mode in the blit modes (uses current 2-dimensional table)"}

!afunction {#long}
!args
!libs
!subs      {_MSimpleReMapMode,0,0}
!name      {"MSimpleReMapMode",";Returns value 6 which is `SimpleReMap' mode in blit modes (uses current 1-dimensional table)"}

!acommand  {#word}
!args
!libs
!subs      {_MSMaskScrollModeShort,0,0}
!args      {#word}
!libs
!subs      {_MSMaskScrollMode,_MSMaskScrollModeCheck,0}
!name {"MSMaskScrollMode","[([]Mode.w[])];CookieMode/EraseMode/InvMode/SolidMode/MColourMode/MReMapMode/MSimpleReMapMode/MAdd"}

!astatement
!args      {#long,#long}
!libs
!subs      {_MPlotParticlesShort,_MPlotParticlesCheck,0}
!args      {#long,#long,#word}
!libs
!subs      {_MPlotParticles,_MPlotParticlesCheck,0}
!name      {"MPlotParticles","CoordinateList.l,NumPoints.l[,Colour.b] ; Plot lots of points from a table of positions"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MGrabParticles,_MGrabParticlesCheck,0}
!name      {"MGrabParticles","CoordinateList.l,NumPoints.l,Buffer.l ; Grab lots of points from a table into buffer mem"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MDrawParticles,_MDrawParticlesCheck,0}
!name      {"MDrawParticles","CoordinateList.l,NumPoints.l,Buffer.l ; Draw lots of previously grabbed points using a table"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MGrabParticlesAndPlotShort,_MGrabParticlesAndPlotCheck,0}
!args      {#long,#long,#long,#word}
!libs
!subs      {_MGrabParticlesAndPlot,_MGrabParticlesAndPlotCheck,0}
!name      {"MGrabParticlesAndPlot","CoordinateList.l,NumPoints.l,Buffer.l[,Colour.b]; Grabs points to buffer & plots table"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MAddToParticlesShort,_MAddToParticlesShortCheck,0}
!args      {#long,#long,#long,#long}
!libs
!subs      {_MAddToParticles,_MAddToParticlesCheck,0}
!name      {"MAddToParticles","CoordinateList.l,NumPoints.l,IncA.l[,IncB.l] ; Add [two sets of] increments to particle list"}

!astatement
!args      {#long,#long}
!libs
!subs      {_MWrapParticles,_MWrapParticlesCheck,0}
!name      {"MWrapParticles","CoordinateList.l,NumPoints.l ; Bring particles in from opposite edge to which they left"}

!astatement
!args      {#long,#long,#long,#word}
!libs
!subs      {_MReboundParticles,_MReboundParticlesCheck,0}
!name      {"MReboundParticles","CoordinateList.l,NumPoints.l,DirectionList.l,DetectSize.w ; Bounce off edges (NOT Ptr.l!!!)"}

!afunction {#word}
!args
!libs
!subs      {_MProcessor,0,0}
!name      {"MProcessor","; Returns value 0..6 representing MC68000..MC68060 cpu according to exec\AttnFlags"}

!astatement
!args      {#long,#long,#word,#word}
!libs
!subs      {_MAddXYToParticles,_MAddXYToParticlesCheck,0}
!name      {"MAddXYToParticles","CoordinateList.l,NumPoints.l,XToAdd.w,YToAdd.w ; Add constants to all particles"}

!astatement
!args      {#long,#long,#long}
!libs
!subs      {_MAddXYToParticlesA,_MAddXYToParticlesACheck,0}
!name      {"MAddXYToParticlesA","CoordinateList.l,NumPoints.l,ValueToAdd.l ; Add constant to all particle pointers"}

!astatement
!args      {#long,#long,#quick,#quick}
!libs
!subs      {_MAddXYToParticlesQ,_MAddXYToParticlesQCheck,0}
!name      {"MAddXYToParticlesQ","CoordinateList.l,NumPoints.l,XToAdd.q,YToAdd.q ; Add constants to all particles"}

!acommand  {#word}
!args
!libs
!subs      {_MParticleModeShort,0,0}
!args      {#word}
!libs
!subs      {_MParticleMode,_MParticleModeCheck,0}
!name {"MParticleMode","Mode.w or () ; MColourMode, MSimpleReMapMode, MReMapMode or MAddMode - to use in particle plot/draw"}

!afunction {#long}
!args
!libs
!subs      {_MMildredBase,0,0}
!name      {"MMildredBase"," ; Returns long address of the base of Mildred's internal data area"}

!acommand  {#word}
!args
!libs
!subs      {_MDrawingModeShort,0,0}
!args      {#word}
!libs
!subs      {_MDrawingMode,_MDrawingModeCheck,0}
!name {"MDrawingMode","[(]Mode.w[)] ; InvMode/MColourMode/MReMapMode/MSimpleReMapMode/MAddMode to use for drawing (MPlot etc)"}

!acommand  {#byte}
!args
!libs
!subs      {_MParticleFormat,0,0}
!args      {#byte}
!libs
!subs      {_MParticleFormat,0,0}
!name      {"MParticleFormat","[(]Format.b[)] ; Set particle lists/operation format. 0 = X.w,Y.w, <0 = X.q,Y.q, >0 = Ptr.l"}

!astatement
!args      {#word,#byte}
!libs
!subs      {_MPictureDissolveIn,_MPictureDissolveInCheck,0}
!name      {"MPictureDissolveIn","PictureBitmapNum.w,Colour.b ; Do a picture-based colour-number dissolve-in of a bitmap"}

!astatement
!args      {#word,#byte,#byte}
!libs
!subs      {_MPictureDissolveOut,_MPictureDissolveOutCheck,0}
!name      {"MPictureDissolveOut","PictureBitmapNum.w,Colour.b,WipeToColour.b ;Do picture-based colour dissolve-out of bitmap"}

!astatement
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomShort,_MZoomShortCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoom,_MZoomCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MZoomCustom,_MZoomCustomCheck,0}
!name      {"MZoom","SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustomOffsets.l]]"}

!astatement
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomShapeShort,_MZoomShapeShortCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomShape,_MZoomShapeCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MZoomShapeCustom,_MZoomShapeCustomCheck,0}
!name      {"MZoomShape","SrcX.q,SrcY.q,XAdd.q,YAdd.q,DestX.w,DestY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]"}

!astatement
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomBitmapToShapeShort,_MZoomBitmapToShapeShortCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomBitmapToShape,_MZoomBitmapToShapeCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MZoomBitmapToShapeCustom,_MZoomBitmapToShapeCustomCheck,0}
!name  {"MZoomBitmapToShape","SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWid.w,OpHeight.w,DeRes?.w[,SrcBmap.w[,CustOffs.l]]"}

!astatement
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomShapeToBitmapShort,_MZoomShapeToBitmapShortCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word}
!libs
!subs      {_MZoomShapeToBitmap,_MZoomShapeToBitmapCheck,0}
!args      {#quick,#quick,#quick,#quick,#word,#word,#word,#word,#word,#word,#long}
!libs
!subs      {_MZoomShapeToBitmapCustom,_MZoomShapeToBitmapCustomCheck,0}
!name {"MZoomShapeToBitmap","SrcX.q,SrcY.q,XAdd.q,YAdd.q,DstX.w,DstY.w,OpWidth.w,OpHeight.w,DeRes?.w[,SrcShap.w[,CustOffs.l]]"}

Init
!nullsub{Initialise,0,0}
Finish
!nullsub{FinishUp,0,0}
!libfin

;**-Macros-***************************************************************************
.Macros

Macro SetupScroll
;Initialise scroll routines
;`1=ShuffleRegs routine number
;`2=Current object labelname
;`3=Setup routine keyword
;`4=InitialiseRegs routine number
;`5=Blit routine labelname
;`6=Label counter
  !ShuffleRegs`1{001`6}
  MOVE.w  Current`2,d0 ; Dest resource
  !_M`3Setup
  MOVEM.l a2-a6,-(a7) ; Store
  MOVE.w  d6,-(a7) ; Store seperately
  MOVEM.w d0/d7,-(a7) ; Store seperately
  MOVEM.w d2-d5,-(a7) ; Store seperately
  !InitData3 ; Shared setup
  BSR     InitialiseRegs`4 ; Init blit
  BRA     `5Routine ; Jump to routine
End Macro

Macro SetupScroll2
;Initialise scroll routines
;`1=ShuffleRegs routine number
;`2=Current object labelname
;`3=Setup routine keyword
;`4=InitialiseRegs routine number
;`5=Blit routine labelname
;`6=Label counter
  MOVE.w  -(a2),d6 ; Get source bitmap number
  MOVE.l  -(a2),LongwordStore ; Grab OffsetsList.l
  !ShuffleRegs`1{002`6`6}
  MOVE.w  Current`2,d0 ; Dest resource
  !_M`3Setup
  MOVEM.l a2-a6,-(a7) ; Store
  MOVE.w  d6,-(a7) ; Store seperately
  MOVEM.w d0/d7,-(a7) ; Store seperately
  MOVEM.w d2-d5,-(a7) ; Store seperately
  !InitData3 ; Shared setup
  BSR     InitialiseRegs`4 ; Init blit
  BRA     `5Routine2 ; Jump to routine
End Macro

Macro ChooseScrollMethod
;Choose direction and blit type for scroll
;`1=Number of the scroll routine
;`2=Label counter
  MOVEM.w (a7)+,d2-d5 ; Restore
  !InitData2 ; Shared setup
  MOVEM.w (a7)+,d0/d7 ; Restore
  CMP.w   d0,d7
  BEQ     _MScrollSDSame`2 ; Source and dest are same object
  MOVE.w  (a7)+,d0 ; Restore (was d6)
_MScrollSDDiff`2
  MOVE.l  a6,d7 ; Replace
  BSR     PerformGenericBlit`1 ; Blit forwards
  BRA     _MScrollSkip2`2
_MScrollSDSame`2
  MOVE.w  (a7)+,d0 ; Restore (was d6)
  CMP.w   d5,d1 ; X1>X2?
  BGE     _MScrollTest2`2
  CMP.w   d0,d2 ; Y1>Y2?
  BGT     _MScrollSDDiff`2
  BRA     _MScrollDescend`2
_MScrollTest2`2
  CMP.w   d0,d2 ; Y1>Y2?
  BLT     _MScrollDescend`2
  BRA     _MScrollSDDiff`2
_MScrollDescend`2
  MOVE.l  a6,d7 ; Replace
  BSR     PerformGenericBlit`1b ; Blit backwards
_MScrollSkip2`2
  MOVEM.l (a7)+,a2-a6 ; Restore
  RTS
End Macro

Macro ChooseScrollMethod2
;Choose direction and blit type for scroll
;`1=Number of the scroll routine
;`2=Label counter
  MOVEM.w (a7)+,d2-d5 ; Restore
  !InitData2 ; Shared setup
  MOVEM.w (a7)+,d0/d7 ; Restore
  CMP.w   d0,d7
  BEQ     _MScrollSDSame`2`2 ; Source and dest are same object
  MOVE.w  (a7)+,d0 ; Restore (was d6)
_MScrollSDDiff`2`2
  MOVE.l  a6,d7 ; Replace
  BSR     PerformGenericBlit`1Custom ; Blit forwards using OffsetList
  BRA     _MScrollSkip2`2`2
_MScrollSDSame`2`2
  MOVE.w  (a7)+,d0 ; Restore (was d6)
  CMP.w   d5,d1 ; X1>X2?
  BGE     _MScrollTest2`2`2
  CMP.w   d0,d2 ; Y1>Y2?
  BGT     _MScrollSDDiff`2`2
  BRA     _MScrollDescend`2`2
_MScrollTest2`2`2
  CMP.w   d0,d2 ; Y1>Y2?
  BLT     _MScrollDescend`2`2
  BRA     _MScrollSDDiff`2`2
_MScrollDescend`2`2
  MOVE.l  a6,d7 ; Replace
  BSR     PerformGenericBlit`1bCustom ; Blit backwards using OffsetList
_MScrollSkip2`2`2
  MOVEM.l (a7)+,a2-a6 ; Restore
  RTS
End Macro

Macro ChooseDoubleScrollMethod
;Choose direction and blit type for doublescroll
;`1=Number of the normal scroll routine
;`2=Number of the cut scroll routine
;`3=Label counter
  MOVEM.w (a7)+,d2-d5 ; Restore
  !InitData2 ; Shared setup
  MOVEM.w (a7)+,d0/d7 ; Restore
  CMP.w   d0,d7
  BEQ     _MDoubleScrollSDSame`3 ; Source and dest are same object
  MOVE.w  (a7)+,d0 ; Restore (was d6)
_MDoubleScrollSDDiff`3
  MOVE.l  a6,d7 ; Replace
  TST.b   DoubleScrollMode ; What type of blit?
  BNE     _MDoubleScrollSDDiffB`3
_MDoubleScrollSDDiffA`3
  BSR     PerformGenericBlit`1 ; Blit data and stencil-blit
  BRA     _MDoubleScrollSkip2`3
_MDoubleScrollSDDiffB`3
  BSR     PerformGenericBlit`2 ; Blit data and cut
  BRA     _MDoubleScrollSkip2`3
_MDoubleScrollSDSame`3
  MOVE.w  (a7)+,d0 ; Restore (was d6)
  CMP.w   d5,d1 ; X1>X2?
  BGE     _MDoubleScrollTest2`3
  CMP.w   d0,d2 ; Y1>Y2?
  BGT     _MDoubleScrollSDDiff`3
  BRA     _MDoubleScrollDescend`3
_MDoubleScrollTest2`3
  CMP.w   d0,d2 ; Y1>Y2?
  BLT     _MDoubleScrollDescend`3
  BRA     _MDoubleScrollSDDiff`3
_MDoubleScrollDescend`3
  MOVE.l  a6,d7 ; Replace
  TST.b   DoubleScrollMode ; What type of blit?
  BNE     _MDoubleScrollDescendB`3
_MDoubleScrollDescendA`3
  BSR     PerformGenericBlit`1b ; Blit data and stencil-blit
  BRA     _MDoubleScrollSkip2`3
_MDoubleScrollDescendB`3
  BSR     PerformGenericBlit`2b ; Blit data and cut
_MDoubleScrollSkip2`3
  MOVEM.l (a7)+,a2-a6 ; Restore
  RTS
End Macro

Macro ChooseDoubleScrollMethod2
;Choose direction and blit type for doublescroll
;`1=Number of the normal scroll routine
;`2=Number of the cut scroll routine
;`3=Label counter
  MOVEM.w (a7)+,d2-d5 ; Restore
  !InitData2 ; Shared setup
  MOVEM.w (a7)+,d0/d7 ; Restore
  CMP.w   d0,d7
  BEQ     _MDoubleScrollSDSame`3`3 ; Source and dest are same object
  MOVE.w  (a7)+,d0 ; Restore (was d6)
_MDoubleScrollSDDiff`3`3
  MOVE.l  a6,d7 ; Replace
  TST.b   DoubleScrollMode ; What type of blit?
  BNE     _MDoubleScrollSDDiffB`3`3
_MDoubleScrollSDDiffA`3`3
  BSR     PerformGenericBlit`1Custom ; Blit data and stencil-blit using OffsetList
  BRA     _MDoubleScrollSkip2`3`3
_MDoubleScrollSDDiffB`3`3
  BSR     PerformGenericBlit`2Custom ; Blit data and cut using OffsetList
  BRA     _MDoubleScrollSkip2`3`3
_MDoubleScrollSDSame`3`3
  MOVE.w  (a7)+,d0 ; Restore (was d6)
  CMP.w   d5,d1 ; X1>X2?
  BGE     _MDoubleScrollTest2`3`3
  CMP.w   d0,d2 ; Y1>Y2?
  BGT     _MDoubleScrollSDDiff`3`3
  BRA     _MDoubleScrollDescend`3`3
_MDoubleScrollTest2`3`3
  CMP.w   d0,d2 ; Y1>Y2?
  BLT     _MDoubleScrollDescend`3`3
  BRA     _MDoubleScrollSDDiff`3`3
_MDoubleScrollDescend`3`3
  MOVE.l  a6,d7 ; Replace
  TST.b   DoubleScrollMode ; What type of blit?
  BNE     _MDoubleScrollDescendB`3`3
_MDoubleScrollDescendA`3`3
  BSR     PerformGenericBlit`1bCustom ; Blit data and stencil-blit using OffsetList
  BRA     _MDoubleScrollSkip2`3`3
_MDoubleScrollDescendB`3`3
  BSR     PerformGenericBlit`2bCustom ; Blit data and cut using OffsetList
_MDoubleScrollSkip2`3`3
  MOVEM.l (a7)+,a2-a6 ; Restore
  RTS
End Macro

Macro ReserveChunkyResourceStructs
;Reserve new structure memory for Chunky Resource structures
;`1=Label counter
;d7=Number of objects required
;d6=Memory address of existing structure
;d5=Number of existing objects
  AND.l   #$FFFF,d7
  TST.l   d6 ; Check for existing mem allocated
  BEQ     ReserveChunkyResourceSkip`1 ; If exists, deallocate
  MOVE.l  d5,d4 ; d4=loopcounter
  SUBQ.l  #1,d4
ReserveCRSloop`1
  MOVE.l  d6,a0 ; Mem base
  MOVE.l  d4,d3 ; Current object
  LSL.l   #ChunkyResourceStructSize,d3 ; offset
  ADD.l   d3,a0 ; Point
  !DeallocResourceObject{001`1}
  DBRA    d4,ReserveCRSloop`1
  MOVE.l  d5,d0 ; Number of resources
  LSL.l   #ChunkyResourceStructSize,d0
  MOVE.l  d6,a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free memory
  MOVE.l  d7,d0
ReserveChunkyResourceSkip`1
  MOVE.l  d7,d0 ; Requested number of resources
  LSL.l   #ChunkyResourceStructSize,d0
  MOVE.l  #ClearPublicMem,d1 ; MemType (public and clear)
  !CheckAvailMem{001`1}
  TST.b   d2 ; Likely?
  BEQ     ReserveChunkyResourceFailed`1
  ALibJsr #BlitzAllocmem ; Allocate memory
  TST.l   d0
  BEQ     ReserveChunkyResourceFailed`1
  BRA     ReserveChunkyResourceSkip2`1 ; Return memory address in d0.l
ReserveChunkyResourceFailed`1
  MOVEQ.l #0,d0 ; Mem Empty - also errorcode
  MOVEQ.l #0,d7 ; Total Empty
ReserveChunkyResourceSkip2`1
End Macro

Macro DeallocResourceObject
;Deallocate a single Chunky Resource, a0=address of single Resource struct
;`1=Label counter
  MOVE.l  d0,-(a7) ; Store
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Width and Height exist?
  BEQ     DeallocROSkip`1
  TST.l   CRsrc_DMem-ChunkyResources(a0) ; Mem?
  BEQ     DeallocNoBitmap`1
  TST.b   CRsrc_DHere-ChunkyResources(a0) ; Bitmap data here?
  BEQ     DeallocNoBitmap`1
  MOVE.l  CRsrc_DBytes-ChunkyResources(a0),d0 ; Size
  MOVE.l  CRsrc_DMem-ChunkyResources(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free data memory
DeallocNoBitmap`1
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Mem?
  BEQ     DeallocNoStencil`1
  TST.b   CRsrc_SHere-ChunkyResources(a0) ; Stencil data here?
  BEQ     DeallocNoStencil`1
  MOVE.l  CRsrc_SBytes-ChunkyResources(a0),d0 ; Size
  MOVE.l  CRsrc_SMem-ChunkyResources(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free stencil memory
DeallocNoStencil`1
  MOVE.l  #0,CRsrc_Width-ChunkyResources(a0) ; Wipe width and height to indicate dead structure
DeallocROSkip`1
  MOVE.l  (a7)+,d0 ; Restore
End Macro

Macro DeallocStencil
;Deallocate a single Chunky Resource's stencil/cookie, a0=address of single Resource struct
;`1=Label counter
  MOVE.l  d0,-(a7) ; Store
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Mem?
  BEQ     DeallocSNoStencil`1
  TST.b   CRsrc_SHere-ChunkyResources(a0) ; Stencil data here?
  BEQ     DeallocSNoStencil`1
  MOVE.l  CRsrc_SBytes-ChunkyResources(a0),d0 ; Size
  MOVE.l  CRsrc_SMem-ChunkyResources(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free stencil memory
DeallocSNoStencil`1
DeallocSROSkip`1
  MOVE.l  (a7)+,d0 ; Restore
End Macro

Macro InitData
;Shared setup use in shape/bitmap generating
  MOVE.w  d0,d5 ; Store object number
  MOVE.w  d1,d6 ; Store width
  MOVE.w  d2,d7 ; Store height
  EXT.l   d5
  EXT.l   d6
  EXT.l   d7
  MULU    d2,d1 ; Total bytes wanted
  ADD.l   #16,d1 ; For move16-align safety
  MOVE.l  d1,d4 ; Store total bytes
  MOVE.l  d1,d0 ; Pass param
End Macro

Macro InitData2
;Shared routine used in Scroll
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0
  SUB.w   d3,d0
  ADD.w   d0,d6 ; Add width difference to source linemod
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d0
  SUB.w   d3,d0
  ADD.w   d0,d7 ; Add width difference to dest linemod
  MOVE.l  d7,a6 ; Copy
End Macro

Macro InitData3
;Shared routine used in Scroll
  MOVE.l  d2,d3 ; Y1
  MOVE.l  d1,d2 ; X1
  MOVE.l  d5,d4 ; X2
  MOVE.l  d6,d5 ; Y2
End Macro

Macro CheckAvailMem
;Having set up parameters ready to Allocmem, check it's available
;Returns success in d2
;`1=Label counter
;d0=Amount required
  MOVEM.l d0/d1/a6,-(a7) ; Store
  MOVE.l  $4,a6        ; Execbase
  AND.l   #$FFFEFFFF,d1 ; Memtype without `clear'
  JSR     LVOAvailMem(a6)
  MOVE.l  d0,d2
  MOVEM.l (a7)+,d0/d1/a6 ; Restore
  CMP.l   d0,d2
  BLT     CheckAvMFailed`1
  MOVEM.l d0/d1/a6,-(a7) ; Store
  MOVE.l  $4,a6
  AND.l   #$FFFEFFFF,d1 ; Memtype without `clear'
  OR.l    #$20000,d1 ; Largest
  JSR     LVOAvailMem(a6)
  MOVE.l  d0,d2
  MOVEM.l (a7)+,d0/d1/a6 ; Restore
  CMP.l   d0,d2
  BLT     CheckAvMFailed`1
  MOVEQ.l #1,d2 ; Success
  BRA     CheckAvMSkip`1
CheckAvMFailed`1
  MOVEQ.l #0,d2 ; Error
CheckAvMSkip`1
End Macro

Macro NewChunkyMem
;Allocate some new memory. d0=Amount
;Returns success in d2
;Returns mem pointer in d0
;`1=Label counter
;Corrupts a0 without telling you!
  MOVE.l  d1,-(a7) ; Store
  MOVE.l  #ClearPublicMem,d1 ; MemType
  !CheckAvailMem{002`1} ; Likely?
  TST.b   d2
  BEQ     NewCMemFailed`1 ; Nope
  ALibJsr #BlitzAllocmem ; Allocate memory
  TST.l   d0  ; Success?
  BEQ     NewCMemFailed`1 ; Nope
  MOVEQ.l #1,d2 ; Success
  MOVE.l  (a7)+,d1 ; Restore
  BRA     NewCMemSkip`1
NewCMemFailed`1
  MOVEQ.l #0,d2
  MOVE.l  (a7)+,d1 ; Restore
NewCMemSkip`1
End Macro

Macro StoreResourceDataMemInfo
;Store data into structure from recently reserved data mem
;d0=Memory base address
;d4=Bytes reserved
;a0=Structure base of object
  MOVE.l  d0,CRsrc_DMem-ChunkyResources(a0) ; Store mem pointer
  MOVE.l  d4,CRsrc_DBytes-ChunkyResources(a0) ; Store bytes of mem allocated
  MOVE.b  #1,CRsrc_DHere-ChunkyResources(a0) ; Data here = True
  ADD.l   #16,d0 ; Base+16
  AND.l   #$FFFFFFF0,d0 ; To nearest 16-bytes in mem (for move16)
  MOVE.l  d0,CRsrc_Data-ChunkyResources(a0) ; Store aligned mem pointer
End Macro

Macro StoreResourceDataMemInfo2
;Store data into structure from cludged data mem
;d0=Memory base address
;d4=Bytes reserved
;a0=Structure base of object
  MOVE.l  d0,CRsrc_DMem-ChunkyResources(a0) ; Store mem pointer
  MOVE.l  d4,CRsrc_DBytes-ChunkyResources(a0) ; Store bytes of mem cludged (unaligned)
  MOVE.b  #0,CRsrc_DHere-ChunkyResources(a0) ; Data here = False
  ADD.l   #16,d0 ; Base+16
  AND.l   #$FFFFFFF0,d0 ; To nearest 16-bytes in mem (for move16)
  MOVE.l  d0,CRsrc_Data-ChunkyResources(a0) ; Store aligned mem pointer
End Macro

Macro StoreResourceStencilMemInfo
;Store data into structure from recently reserved stencil mem
;d0=Memory base address
;d4=Bytes reserved
;a0=Structure base of object
;Affects d0
  MOVE.l  d0,CRsrc_SMem-ChunkyResources(a0) ; Store mem pointer
  MOVE.l  d4,CRsrc_SBytes-ChunkyResources(a0) ; Store bytes of mem allocated
  MOVE.b  #1,CRsrc_SHere-ChunkyResources(a0) ; Data here = True
  ADD.l   #16,d0 ; Base+16
  AND.l   #$FFFFFFF0,d0 ; To nearest 16-bytes in mem (for move16)
  MOVE.l  d0,CRsrc_Stencil-ChunkyResources(a0) ; Store aligned mem pointer
End Macro

Macro StoreResourceStencilMemInfo2
;Store data into structure from recently cludged stencil mem
;d3=Memory base address
;a0=Structure base of object
;Trashes d3
  MOVE.l  d3,CRsrc_SMem-ChunkyResources(a0) ; Store mem pointer
  ADD.l   #16,d3 ; Base+16
  AND.l   #$FFFFFFF0,d3 ; To nearest 16-bytes in mem (for move16)
  MOVE.l  d3,CRsrc_Stencil-ChunkyResources(a0) ; Store aligned mem pointer
  MOVE.l  CRsrc_DBytes-ChunkyResources(a0),d3 ; Get databytes
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0) ; Data here = False
  SUB.l   #16,d3 ; -16 for actual bytes of cludge data
  MOVE.l  d3,CRsrc_SBytes-ChunkyResources(a0) ; Store stencilbytes
End Macro

Macro Getc2pWindowObjectPtr
;Get address of c2pWindow structure of specified c2pWindow
;d0=c2pWindow number
;Returns address in a0
  AND.l   #$FFFF,d0 ; Only words are valid
  LSL.l   #c2pWindowStructSize,d0
  MOVE.l  c2pWindowsMem,a0
  ADD.l   d0,a0
  LSR.l   #c2pWindowStructSize,d0 ; keep d0 intact
End Macro ; Return with a0=structure address

Macro GetBitmapObjectPtr
;Get address of Resource structure of specific bitmap.
;d0=Resource number
;Returns address in a0
  AND.l   #$FFFF,d0 ; Only words are valid
  LSL.l   #ChunkyResourceStructSize,d0
  MOVE.l  ChunkyBitmapsMem,a0
  ADD.l   d0,a0
  LSR.l   #ChunkyResourceStructSize,d0 ; keep d0 intact
End Macro ; Return with a0=structure address

Macro GetShapeObjectPtr
;Get address of Resource structure of specific shape.
;d0=Resource number
;Returns address in a0
  AND.l   #$FFFF,d0 ; Only words are valid
  LSL.l   #ChunkyResourceStructSize,d0
  MOVE.l  ChunkyShapesMem,a0
  ADD.l   d0,a0
  LSR.l   #ChunkyResourceStructSize,d0 ; keep d0 intact
End Macro ; Return with a0=structure address

Macro GetQueueObjectPtr
;Get address of ChunkyQueue structure of specified ChunkyQueue
;d0=ChunkyQueue number
;Returns address in a0
  AND.l   #$FFFF,d0 ; Only words are valid
  LSL.l   #ChunkyQueueStructSize,d0
  MOVE.l  ChunkyQueuesMem,a0
  ADD.l   d0,a0
  LSR.l   #ChunkyQueueStructSize,d0 ; keep d0 intact
End Macro ; Return with a0=structure address

Macro GetTableObjectPtr
;Get address of ChunkyTable structure of specified ChunkyTable
;d0=ChunkyTable number
;Returns address in a0
  AND.l   #$FFFF,d0 ; Only words are valid
  LSL.l   #ChunkyTableStructSize,d0
  MOVE.l  ChunkyTablesMem,a0
  ADD.l   d0,a0
  LSR.l   #ChunkyTableStructSize,d0 ; keep d0 intact
End Macro ; Return with a0=structure address

Macro FinishResourceInit
;Routine to finish loading in data parameters to a new Resource structure
;a0=address of struct
  MOVE.w  #0,CRsrc_XHandle-ChunkyResources(a0)
  MOVE.w  #0,CRsrc_YHandle-ChunkyResources(a0)
  MOVE.w  d6,CRsrc_Width-ChunkyResources(a0)
  MOVE.w  d7,CRsrc_Height-ChunkyResources(a0)
  MOVE.w  #0,CRsrc_LineMod-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_WrapBytes-ChunkyResources(a0)
  MOVE.w  d6,CRsrc_TotWidth-ChunkyResources(a0)
End Macro

Macro SetResourceMidHandle
;Routine to set the handle of a resource to the middle. a0=Base of struct
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d7 ; Get Width
  LSR.w   #1,d7 ; /2
  MOVE.w  d7,CRsrc_XHandle-ChunkyResources(a0) ; Store X Handle/origin
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d7 ; Get Height
  LSR.w   #1,d7 ; /2
  MOVE.w  d7,CRsrc_YHandle-ChunkyResources(a0) ; Store Y Handle/origin
End Macro

Macro PrepareStencilMemory
;Routine to get new resource stencil mem if none suitable already defined
;`1=Label counter
;a0=Resource structure base
;Puts mem address in d0
;Puts bytes total size in d4
;Puts height in d7
;Returns d2 as success
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Stencil mem already present?
  BNE     PrepSMGotMem`1
  ;New stencil memory needed
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d0 ; TotalWidth
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d7 ; Height
  MULU    d7,d0 ; Total
  ADD.l   #16,d0
  MOVE.l  d0,d4
  MOVE.l  a0,a2 ;store
  !NewChunkyMem{007`1}
  MOVE.l  a2,a0 ;restore
  TST.b   d2 ; Got it?
  BEQ     PrepSMNotEnough`1
  !StoreResourceStencilMemInfo
PrepSMGotMem`1
  MOVEQ.l #1,d2 ; Success Result
  BRA     PrepSMDone`1
PrepSMNotEnough`1
  ;Memory alloc failed
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_Stencil-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_SMem-ChunkyResources(a0)
  MOVEQ.l #0,d2 ; Error
PrepSMDone`1
End Macro

Macro RoundUpWidth
;Used when creating new resource to ensure width is multiple of 4 (round up)
;Trashes d7
;`1=Lable counter
;d1=Width.w
  MOVE.w  d1,d7 ; Temp
  AND.b   #$FC,d1 ; Round down width to nearest 4
  AND.b   #$03,d7 ; Mask off remainder bits
  BEQ     RoundUWskip`1
  ADDQ.w  #4,d1
  TST.w   d1 ; Has it accidentally become >signed word limit?
  BGT     RoundUWskip`1
  SUBQ.w  #4,d1 ; Can't have it rounded up, crop
RoundUWskip`1
End Macro

Macro RemakeStencil
;Make/Remake stencil data from graphic data
;`1=Label counter
;a0=structure base. stencil memory already reserved.
;Regs d0..d2/d4/d6/d7/a1/a2 preserved
  MOVEM.l d0-d2/d4/d6/d7/a1/a2,-(a7) ; Store
  JSR     InitialiseRegs
  LSR.w   #2,d0 ; Width/4 for longwords
  SUBQ.w  #1,d1 ; Height-1 for loop
  SUBQ.w  #1,d0 ; loopcounter
StencilLoop1`1
    MOVE.w  d0,d6 ; XLoop
StencilLoop2`1
      MOVE.b  (a1)+,d4 ; Get source byte1
      SEQ.b   d4
      LSL.w   #8,d4
      MOVE.b  (a1)+,d4 ; Get source byte2
      SEQ.b   d4
      SWAP    d4
      MOVE.b  (a1)+,d4 ; Get source byte3
      SEQ.b   d4
      LSL.w   #8,d4
      MOVE.b  (a1)+,d4 ; Get source byte4
      SEQ.b   d4
      MOVE.l  d4,(a2)+ ; Write mask longword
      DBRA    d6,StencilLoop2`1 ;XLoop
    ADD.w   d7,a1 ; Source data modulo
    ADD.w   d7,a2 ; Dest stencil modulo
    DBRA    d1,StencilLoop1`1 ;YLoop
  MOVEM.l (a7)+,d0-d2/d4/d6/d7/a1/a2
End Macro

Macro FreeStencilMem
;Free's stencil memory.
;`1=Label counter
;a0=struct
;trashes d0/a1
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Stencil mem already present?
  BEQ     FreeSMskip2`1
  TST.b   CRsrc_SHere-ChunkyResources(a0) ; Freeable?
  BEQ     FreeSMskip`1 ; No, skip dealloc
  ;Stencil needs freeing
  MOVE.l  CRsrc_SBytes-ChunkyResources(a0),d0 ; Size
  MOVE.l  CRsrc_SMem-ChunkyResources(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free stencil memory
FreeSMskip`1
  !WriteDefaultStencilInfo{001}
FreeSMskip2`1
End Macro

Macro WriteDefaultStencilInfo
;Init Stencil info
  MOVE.l  #0,CRsrc_Stencil-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_SMem-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_SBytes-ChunkyResources(a0)
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0)
End Macro

Macro DuplicateResourceStruct
;Duplicate without alteration all fields of a Resource
;a0=Source struct
;a1=Dest struct
  MOVE.w  CRsrc_Width-ChunkyResources(a0),CRsrc_Width-ChunkyResources(a1)
  MOVE.w  CRsrc_Height-ChunkyResources(a0),CRsrc_Height-ChunkyResources(a1)
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),CRsrc_LineMod-ChunkyResources(a1)
  MOVE.l  CRsrc_Data-ChunkyResources(a0),CRsrc_Data-ChunkyResources(a1)
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),CRsrc_Stencil-ChunkyResources(a1)
  MOVE.w  CRsrc_XHandle-ChunkyResources(a0),CRsrc_XHandle-ChunkyResources(a1)
  MOVE.w  CRsrc_YHandle-ChunkyResources(a0),CRsrc_YHandle-ChunkyResources(a1)
  MOVE.l  CRsrc_DMem-ChunkyResources(a0),CRsrc_DMem-ChunkyResources(a1)
  MOVE.l  CRsrc_DBytes-ChunkyResources(a0),CRsrc_DBytes-ChunkyResources(a1)
  MOVE.l  CRsrc_SMem-ChunkyResources(a0),CRsrc_SMem-ChunkyResources(a1)
  MOVE.l  CRsrc_SBytes-ChunkyResources(a0),CRsrc_SBytes-ChunkyResources(a1)
  MOVE.b  CRsrc_DHere-ChunkyResources(a0),CRsrc_DHere-ChunkyResources(a1)
  MOVE.b  CRsrc_SHere-ChunkyResources(a0),CRsrc_SHere-ChunkyResources(a1)
  MOVE.b  CRsrc_Clipping-ChunkyResources(a0),CRsrc_Clipping-ChunkyResources(a1)
  MOVE.b  CRsrc_Wrapping-ChunkyResources(a0),CRsrc_Wrapping-ChunkyResources(a1)
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),CRsrc_ClipLeft-ChunkyResources(a1)
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),CRsrc_ClipTop-ChunkyResources(a1)
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),CRsrc_ClipWidth-ChunkyResources(a1)
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),CRsrc_ClipHight-ChunkyResources(a1)
  MOVE.w  CRsrc_ClipLMod-ChunkyResources(a0),CRsrc_ClipLMod-ChunkyResources(a1)
  MOVE.l  CRsrc_ClipBytes-ChunkyResources(a0),CRsrc_ClipBytes-ChunkyResources(a1)
  MOVE.l  CRsrc_WrapBytes-ChunkyResources(a0),CRsrc_WrapBytes-ChunkyResources(a1)
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),CRsrc_TotWidth-ChunkyResources(a1)
End Macro

Macro CopyCShapeDat
;Copy source shape struct to dest shape struct
;`1=Label counter
;d0=Source shape number
;d1=Dest shape number
;Returns shape structs in a0 and a1
  EXG.l   d0,d1
  !GetShapeObjectPtr ; Base in a0
  !DeallocResourceObject{014`1} ; Free destination if pre-existing
  EXG.l   d0,d1
  MOVE.l  a0,a1 ; Dest
  !GetShapeObjectPtr ; Base in a0 - Source
  !DuplicateResourceStruct
  MOVE.b  #0,CRsrc_DHere-ChunkyResources(a1) ; Cludged data
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a1) ; Cludged stencil
End Macro

Macro CopyCBitmapDat
;Copy source bitmap struct to dest bitmap struct
;`1=Label counter
;d0=Source bitmap number
;d1=Dest bitmap number
;Returns bitmap structs in a0 and a1
  EXG.l   d0,d1
  !GetBitmapObjectPtr ; Base in a0
  !DeallocResourceObject{015`1} ; Free destination if pre-existing
  EXG.l   d0,d1
  MOVE.l  a0,a1 ; Dest
  !GetBitmapObjectPtr ; Base in a0 - Source
  !DuplicateResourceStruct
  MOVE.b  #0,CRsrc_DHere-ChunkyResources(a1) ; Cludged data
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a1) ; Cludged stencil
End Macro

Macro CopyCBitmapDatToCShape
;Copy source bitmap struct to dest shape struct
;`1=Label counter
;d0=Source bitmap number
;d1=Dest shape number
;Returns bitmap struct in a0, shape struct in a1
  EXG.l   d0,d1
  !GetShapeObjectPtr ; Base in a0
  !DeallocResourceObject{016`1} ; Free destination if pre-existing
  EXG.l   d0,d1
  MOVE.l  a0,a1 ; Dest
  !GetBitmapObjectPtr ; Base in a0 - Source
  !DuplicateResourceStruct
  MOVE.b  #0,CRsrc_DHere-ChunkyResources(a1) ; Cludged data
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a1) ; Cludged stencil
End Macro

Macro CopyCShapeDatToCBitmap
;Copy source shape struct to dest bitmap struct
;`1=Label counter
;d0=Source shape number
;d1=Dest shape number
;Returns shape struct in a0, bitmap structs in a1
  EXG.l   d0,d1
  !GetBitmapObjectPtr ; Base in a0
  !DeallocResourceObject{017`1} ; Free destination if pre-existing
  EXG.l   d0,d1
  MOVE.l  a0,a1 ; Dest
  !GetShapeObjectPtr ; Base in a0 - Source
  !DuplicateResourceStruct
  MOVE.b  #0,CRsrc_DHere-ChunkyResources(a1) ; Cludged data
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a1) ; Cludged stencil
End Macro

Macro WriteClipWindowData
;Write new clip-window info to a resource struct
;a0=struct base
;d1=Rounded X
;d2=Y
;d3=Rounded Width
;d4=Height
;d5=Use status
;Trashes d7
  MOVE.w  d1,CRsrc_ClipLeft-ChunkyResources(a0)
  MOVE.w  d2,CRsrc_ClipTop-ChunkyResources(a0)
  MOVE.w  d3,CRsrc_ClipWidth-ChunkyResources(a0)
  MOVE.w  d4,CRsrc_ClipHight-ChunkyResources(a0)
  MOVE.b  d5,CRsrc_Clipping-ChunkyResources(a0)
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d7
  SUB.w   d3,d7 ; Find clipping linemodulo
  MOVE.w  d7,CRsrc_ClipLMod-ChunkyResources(a0)
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Get total width
  MULU    d2,d7 ; Find byte offset top left clip corner
  EXT.l   d1
  ADD.l   d1,d7
  MOVE.l  d7,CRsrc_ClipBytes-ChunkyResources(a0)
End Macro

Macro WriteDefaultClipData
;Write data for default clipping, taken from dimensions of resource
;a0=resource struct
  MOVE.w  #0,CRsrc_ClipLeft-ChunkyResources(a0)
  MOVE.w  #0,CRsrc_ClipTop-ChunkyResources(a0)
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MOVE.w  d7,d5 ; Store
  MOVE.w  d7,CRsrc_ClipWidth-ChunkyResources(a0)
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6
  MOVE.w  d6,CRsrc_ClipHight-ChunkyResources(a0)
  MOVE.w  #0,CRsrc_ClipLMod-ChunkyResources(a0)
  MOVE.l  #0,CRsrc_ClipBytes-ChunkyResources(a0)
End Macro

Macro ShuffleRegs1
;Register rearrangement and param rounding used in Scroll routines
;`1=Label counter
  MOVE.l  d6,d7
  MOVE.l  d5,d6
  MOVE.l  d4,d5
  MOVE.l  d3,d4
  MOVE.l  d2,d3
  MOVE.l  d1,d2
  MOVE.l  d0,d1
  AND.b   #$FC,d3 ; Width down to nearest 4
  TST.w   d3
  BGT     ShuffleSkip`1
  MOVEQ.l #4,d3 ; Make sure width at least 4
ShuffleSkip`1
End Macro

Macro ShuffleRegs2
;Register rearrangement used in GetaShape/GetaBitmap
  MOVE.l  d1,d0 ; X1
  MOVE.l  d2,d1 ; Y1
  MOVE.l  d3,d2 ; Width
  MOVE.l  d4,d3 ; Height
  MOVEQ.l #0,d4 ; X2
  MOVEQ.l #0,d5 ; Y2
End Macro

Macro ShuffleRegs3
;Register rearrangement and param rounding used in BlockScroll routines
  MOVE.l  d6,d7
  MOVE.l  d5,d6
  MOVE.l  d4,d5
  MOVE.l  d3,d4
  MOVE.l  d2,d3
  MOVE.l  d1,d2
  MOVE.l  d0,d1
  AND.b   #$F0,d3 ; Width down to nearest 16
  TST.w   d3
  BGT     Shuffle3Skip`1
  MOVEQ.l #16,d3 ; Make sure width at least 16
Shuffle3Skip`1
  AND.b   #$F0,d1 ; X1 down to nearest 16
  AND.b   #$F0,d5 ; X2 down to nearest 16
End Macro

Macro ShuffleRegs4
;Register rearrangement and NO param rounding used in Scroll routines
;`1=Label counter
  MOVE.l  d6,d7
  MOVE.l  d5,d6
  MOVE.l  d4,d5
  MOVE.l  d3,d4
  MOVE.l  d2,d3
  MOVE.l  d1,d2
  MOVE.l  d0,d1
  TST.w   d3
  BGT     Shuffle4Skip`1
  MOVEQ.l #1,d3 ; Make sure width at least 1
Shuffle4Skip`1
End Macro

Macro _MScrollBitmapSetup
;Routines shared in the scrolling
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest
  EXG.l   d7,d0
  !GetBitmapObjectPtr ; base in a0 - source
  EXG.l   d7,d0
End Macro

Macro _MScrollShapeSetup
  !GetShapeObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest
  EXG.l   d7,d0
  !GetShapeObjectPtr ; base in a0 - source
  EXG.l   d7,d0
End Macro

Macro _MStenScrollSetup
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest
  EXG.l   d7,d0
  !GetBitmapObjectPtr ; base in a0 - source
  EXG.l   d7,d0
End Macro

Macro _MCookScrollSetup
  !GetShapeObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest
  EXG.l   d7,d0
  !GetShapeObjectPtr ; base in a0 - source
  EXG.l   d7,d0
End Macro

Macro _MScrollBitmapToShapeSetup
  !GetShapeObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest shape
  EXG.l   d7,d0
  !GetBitmapObjectPtr ; base in a0 - source bitmap
  EXG.l   d7,d0
End Macro

Macro _MScrollShapeToBitmapSetup
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  EXG.l   d7,d0
  !GetShapeObjectPtr ; base in a0 - source shape
  EXG.l   d7,d0
End Macro

Macro _MStenScrollBitmapToShapeSetup
  !GetShapeObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest shape
  EXG.l   d7,d0
  !GetBitmapObjectPtr ; base in a0 - source bitmap
  EXG.l   d7,d0
End Macro

Macro _MCookScrollShapeToBitmapSetup
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  EXG.l   d7,d0
  !GetShapeObjectPtr ; base in a0 - source shape
  EXG.l   d7,d0
End Macro

Macro PerformPoint
;Return pixel value
;`1=Label counter
;a0=Struct
;a1=Data or Stencil/Cookie address
;d1=Ypos
;d2=Xpos
;Trashes d7/a1
;Returns d0=Pixel value
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     PerfPointSkip`1
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
PerfPointSkip`1
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  ADD.w   d2,a1 ; x
  MULU    d1,d7
  ADD.l   d7,a1 ; y
  MOVEQ.l #0,d0 ; Init
  MOVE.b  (a1),d0 ; Get pixel
End Macro

Macro CludgeResourceWindow
;Cludge a window within an existing resource's data
;`1=Label counter
;d0=Source resource number
;d1=Dest resource number
;d2=X left-edge coordinate in source
;d3=Y top-edge coordinate in source
;d4=Width of new window (smaller than source)
;d5=Height of new window (smaller than source)
;Trashes d0-d7
;Returns address in d0 if success, or 0 if error
  EXT.l   d2 ;X
  EXT.l   d3 ;Y
  EXT.l   d4 ;Width
  EXT.l   d5 ;Height
  MOVE.l  d4,d1
  !RoundUpWidth{005`1} ; Make Width multiple of 4
  MOVE.l  d1,d4
  MOVE.l  d2,d1
;  !RoundUpWidth{006`1} ; Make X multiple of 4
  MOVE.l  d1,d2
  MOVE.l  d4,d6 ; Store Width
  MOVE.l  d5,d7 ; Store Height
  TST.w   d2 ; Left-edge too far left?
  BLT     MakeRWindowSkip2`1
  CMP.w   CRsrc_Width-ChunkyResources(a1),d2 ; Left-edge too far right?
  BGE     MakeRWindowSkip2`1
  TST.w   d3 ; Top-edge too far up?
  BLT     MakeRWindowSkip2`1
  CMP.w   CRsrc_Height-ChunkyResources(a1),d3 ; Top edge too far down?
  BGE     MakeRWindowSkip2`1
  TST.w   d4 ; Width too small?
  BLE     MakeRWindowSkip2`1
  ADD.l   d2,d4
  CMP.w   CRsrc_Width-ChunkyResources(a1),d4 ; Window wider than source?
  BGT     MakeRWindowSkip2`1
  TST.w   d5 ; Height too small?
  BLE     MakeRWindowSkip2`1
  ADD.l   d3,d5
  CMP.w   CRsrc_Height-ChunkyResources(a1),d5 ; Window taller than source?
  BGT     MakeRWindowSkip2`1
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a1),d1 ; Get existing total width
  EXT.l   d1
  MOVE.w  d6,CRsrc_Width-ChunkyResources(a1) ; New width
  MOVE.w  d7,CRsrc_Height-ChunkyResources(a1) ; New height
  MOVE.l  d1,d4 ; Store original width
  MOVE.w  d1,CRsrc_TotWidth-ChunkyResources(a1) ; New TotWidth (original width)
  SUB.l   d6,d1 ; Work out new line modulo
  MOVE.w  d1,CRsrc_LineMod-ChunkyResources(a1) ; New line modulo
  MOVE.l  d3,d1 ; Store
  MULU    d4,d3 ; TotalWidth*Y for YOffset in bytes
  ADD.l   d2,d3 ; +X, d3=Byte offset of top left corner
  MOVE.l  CRsrc_Data-ChunkyResources(a1),d5 ; Get old data pointer
  ADD.l   d3,d5 ; New data pointer
  MOVE.l  d5,CRsrc_Data-ChunkyResources(a1)
  TST.l   CRsrc_SMem-ChunkyResources(a1)
  BEQ     MakeRWindowSkip1`1
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),d6 ; Get old stencil pointer
  ADD.l   d3,d6 ; New stencil pointer
  MOVE.l  d6,CRsrc_Stencil-ChunkyResources(a1)
MakeRWindowSkip1`1
  MOVE.l  d5,d0 ; Return success as data address
  ;Crop the clip window
  MOVE.w  d2,d5 ; Copy leftedge
  ADD.w   CRsrc_Width-ChunkyResources(a1),d5 ; Find window rightedge
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a1),d6 ; Copy leftedge
  ADD.w   CRsrc_ClipWidth-ChunkyResources(a1),d6 ; Find clip rightedge
  CMP.w   d6,d5
  BGT     MakeRWindowSkip6`1
  MOVE.w  d5,d6 ; New clip rightedge
MakeRWindowSkip6`1
  SUB.w   d2,d6 ; Find rightedge within window
  MOVE.w  d1,d5 ; Copy topedge
  ADD.w   CRsrc_Height-ChunkyResources(a1),d5 ; Find window bottomedge
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a1),d4 ; Copy topedge
  ADD.w   CRsrc_ClipHight-ChunkyResources(a1),d4 ; Find clip bottomedge
  CMP.w   d4,d5
  BGT     MakeRWindowSkip7`1
  MOVE.w  d5,d4 ; New clip bottomedge
MakeRWindowSkip7`1
  SUB.w   d1,d4 ; Find rightedge within window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a1),d3 ; Get clipleft
  CMP.w   d2,d3
  BGE     MakeRWindowSkip4`1
  MOVE.w  d2,d3 ; New clip leftedge
MakeRWindowSkip4`1
  SUB.w   d2,d3 ; Find leftedge within window
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a1),d7 ; Get cliptop
  CMP.w   d1,d7
  BGE     MakeRWindowSkip5`1
  MOVE.w  d1,d7 ; New clip topedge
MakeRWindowSkip5`1
  SUB.w   d1,d7 ; Find topedge within window
  SUB.w   d3,d6 ; Find clip width
  SUB.w   d7,d4 ; Find clip height
  MOVE.w  d3,CRsrc_ClipLeft-ChunkyResources(a1)
  MOVE.w  d7,CRsrc_ClipTop-ChunkyResources(a1)
  MOVE.w  d6,CRsrc_ClipWidth-ChunkyResources(a1)
  MOVE.w  d4,CRsrc_ClipHight-ChunkyResources(a1)
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d2
  SUB.w   d6,d2 ; Find linemod
  MOVE.w  d2,CRsrc_ClipLMod-ChunkyResources(a1)
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d6 ; Get total width
  MULU    d7,d6 ; Find bytes
  EXT.l   d3
  ADD.l   d3,d6 ; Total bytes for top left clip corner
  MOVE.l  d6,CRsrc_ClipBytes-ChunkyResources(a1)
  BRA     MakeRWindowDone`1
MakeRWindowSkip2`1
  MOVE.l  #0,CRsrc_Width-ChunkyResources(a1) ; Wipe width and height to indicate dead structure
  MOVEQ.l #0,d0 ; Return error
MakeRWindowDone`1
End Macro

Macro PerformYFlip
;Vertically flip an image
;`1=Label counter
;a1=address of topleft corner
;d7=line modulo
;d0=width
;d1=height
;Trashes many
  MOVE.w  d7,d5 ; Store linemod
  ADD.w   d0,d7 ; Total bytes in a line
  MOVE.w  d1,d2 ; Copy Height
  LSR.w   #1,d2 ; Height/2
  SUBQ.w  #1,d2 ; Y loopcounter
  SUBQ.w  #1,d1 ; -BottomLine
  MULU    d7,d1 ; Find start of last line
  ADD.l   a1,d1 ; Add base
  MOVE.l  d1,a2 ; Make address
  MOVE.w  d0,d6 ; Copy op width
  LSR.w   #2,d0 ; Width/4 for longwords
  MOVE.w  d0,d4 ; Copy Width/4
  AND.w   #$0003,d4 ; Find if Width/16
  BEQ     PerfYFlip_16`1 ; If a multiple of 16, do faster loop
  SUBQ.w  #1,d0 ; X loopcounter
PerfYFlipYLoop`1
    MOVE.w  d0,d3 ; XLoop
PerfYFlipXLoop`1
      MOVE.l  (a2),d4 ; Get bottom line
      MOVE.l  (a1),(a2)+ ; Copy top line
      MOVE.l  d4,(a1)+ ; Copy bottom line
      DBRA    d3,PerfYFlipXLoop`1
    ADD.w   d5,a1 ; Next top line
    SUB.w   d6,a2 ; Start of this bottom line
    SUB.w   d7,a2 ; Next bottom line
    DBRA    d2,PerfYFlipYLoop`1
  BRA   PerfYFlipDone`1
PerfYFlip_16`1
  LSR.w   #2,d0 ; Width/16
  SUBQ.w  #1,d0 ; X loopcounter
PerfYFlip_16YLoop`1
    MOVE.w  d0,d3 ; XLoop
PerfYFlip_16XLoop`1
      MOVE.l  (a2),d4 ; Get bottom line
      MOVE.l  (a1),(a2)+ ; Copy top line
      MOVE.l  d4,(a1)+ ; Copy bottom line
      MOVE.l  (a2),d4 ; Get bottom line
      MOVE.l  (a1),(a2)+ ; Copy top line
      MOVE.l  d4,(a1)+ ; Copy bottom line
      MOVE.l  (a2),d4 ; Get bottom line
      MOVE.l  (a1),(a2)+ ; Copy top line
      MOVE.l  d4,(a1)+ ; Copy bottom line
      MOVE.l  (a2),d4 ; Get bottom line
      MOVE.l  (a1),(a2)+ ; Copy top line
      MOVE.l  d4,(a1)+ ; Copy bottom line
      DBRA    d3,PerfYFlip_16XLoop`1
    ADD.w   d5,a1 ; Next top line
    SUB.w   d6,a2 ; Start of this bottom line
    SUB.w   d7,a2 ; Next bottom line
    DBRA    d2,PerfYFlip_16YLoop`1
PerfYFlipDone`1
End Macro

Macro PerformXFlip
;Horizontally flip an image
;`1=Label counter
;a1=address of topleft corner
;d7=line modulo
;d0=width
;d1=height
;Trashes many
  ADD.w   d0,d7 ; Total bytes in a line
  MOVE.w  d0,d2 ; Copy Width
  MOVE.w  d2,d6 ; Copy Width
  LSR.w   #1,d2 ; Width/2 for bytes to do
  MOVE.w  d2,d5 ; Copy Width/2
  MOVE.l  a1,a2 ; Copy base
  ADD.w   d0,a2 ; Find end of line
  SUBQ.w  #1,d1 ; Y loopcounter
  AND.w   #$000F,d6 ; Width multiple of 16?
  BEQ     PerfXFlip_16`1
PerfXFlip_4`1
  LSR.w   #1,d2 ; Width/4 for 2bytes to do
  SUBQ.w  #1,d2 ; X loopcounter
PerfXFlip_4YLoop`1
    MOVE.w  d2,d3 ; XLoop
PerfXFlip_4XLoop`1
      MOVE.w  -(a2),d4
      ROL.w   #8,d4      ; swap 2 bytes for 2 bytes = 4
      MOVE.w  (a1),d6
      MOVE.w  d4,(a2)
      ROL.w   #8,d6
      MOVE.w  d6,(a1)+
      DBRA    d3,PerfXFlip_4XLoop`1
    SUB.w   d5,a1 ; Start of this line
    ADD.w   d7,a1 ; Start of next line
    ADD.w   d5,a2 ; End of this line
    ADD.w   d7,a2 ; End of next line
    DBRA    d1,PerfXFlip_4YLoop`1
  BRA   PerfXFlipDone`1
PerfXFlip_16`1
  LSR.w   #3,d2 ; Width/16 for 8bytes to do
  SUBQ.w  #1,d2 ; X loopcounter
PerfXFlip_16YLoop`1
    MOVE.w  d2,d3 ; XLoop
PerfXFlip_16XLoop`1
      MOVE.l  -(a2),d4
      ROL.w   #8,d4
      MOVE.l  (a1),d6
      SWAP    d4
      ROL.w   #8,d6
      ROL.w   #8,d4
      SWAP    d6
      MOVE.l  d4,(a2)
      ROL.w   #8,d6
      MOVE.l  d6,(a1)+   ; swap 8 bytes for 8 bytes = 16
      MOVE.l  -(a2),d4
      ROL.w   #8,d4
      MOVE.l  (a1),d6
      SWAP    d4
      ROL.w   #8,d6
      ROL.w   #8,d4
      SWAP    d6
      MOVE.l  d4,(a2)
      ROL.w   #8,d6
      MOVE.l  d6,(a1)+
      DBRA    d3,PerfXFlip_16XLoop`1
    SUB.w   d5,a1 ; Start of this line
    ADD.w   d7,a1 ; Start of next line
    ADD.w   d5,a2 ; End of this line
    ADD.w   d7,a2 ; End of next line
    DBRA    d1,PerfXFlip_16YLoop`1
PerfXFlipDone`1
End Macro

Macro PrepareCoords
;Prepare coords so that X2,Y2 are always greater than X1,Y1
;`1=Label counter
;d0=X1
;d1=Y1
;d2=X2
;d3=Y2
;Outputs: d0=Smallest X, d1=SmallestY, d2=LargestX, d3=LargestY
  CMP.w   d0,d2 ; X2 smaller?
  BGE     PrepCoordsSkip1`1 ; no
  EXG.l   d0,d2 ; yes
PrepCoordsSkip1`1
  CMP.w   d1,d3 ; Y2 smaller?
  BGE     PrepCoordsSkip2`1 ; no
  EXG.l   d1,d3 ; yes
PrepCoordsSkip2`1
End Macro

Macro PrepareXCoords
;Prepare coords so that X2 is always greater X1
;`1=Label counter
;d0=X1
;d2=X2
;Outputs: d0=Smallest X, d2=LargestX
  CMP.w   d0,d2 ; X2 smaller?
  BGE     PrepXCoordsSkip1`1 ; no
  EXG.l   d0,d2 ; yes
PrepXCoordsSkip1`1
End Macro

Macro PrepareYCoords
;Prepare coords so that Y2 is always greater Y1
;`1=Label counter
;d1=Y1
;d3=Y2
;Outputs: d1=Smallest Y, d3=LargestY
  CMP.w   d1,d3 ; Y2 smaller?
  BGE     PrepYCoordsSkip1`1 ; no
  EXG.l   d1,d3 ; yes
PrepYCoordsSkip1`1
End Macro

;**-Common-Check-Macros-**************************************************************
.CommonCheckMacros

Macro CCheckXYFits
;Checks shared by Plot routines
  TST.w   d0
  BLT     Error39 ; X too small
  CMP.w   CRsrc_Width-ChunkyResources(a0),d0
  BGE     Error39 ; X too large
  TST.w   d1
  BLT     Error40 ; Y too small
  CMP.w   CRsrc_Height-ChunkyResources(a0),d1
  BGE     Error40 ; Y too large
End Macro

Macro CCheckXYFits2
;Checks shared by Plot routines
  TST.w   d6
  BLT     Error39 ; X too small
  CMP.w   CRsrc_Width-ChunkyResources(a0),d6
  BGE     Error39 ; X too large
  TST.w   d7
  BLT     Error40 ; Y too small
  CMP.w   CRsrc_Height-ChunkyResources(a0),d7
  BGE     Error40 ; Y too large
End Macro

Macro CCheckXYFits3
;Checks shared by Plot routines
  TST.w   d4
  BLT     Error39 ; X too small
  CMP.w   CRsrc_Width-ChunkyResources(a0),d4
  BGE     Error39 ; X too large
  TST.w   d5
  BLT     Error40 ; Y too small
  CMP.w   CRsrc_Height-ChunkyResources(a0),d5
  BGE     Error40 ; Y too large
End Macro

Macro CCheckSharedScroll
;Scroll-related partial check shared by a few tokens
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  !CCheckWindowFits3
  MOVE.l  a1,d6 ; Restore
  MOVE.l  d0,a1 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0
  BLT     Error28
  !CThreeBitmapChecks
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  MOVEM.l d0/d1,-(a7) ; Store
  MOVE.l  d4,d0 ; X2
  MOVE.l  d5,d1 ; Y2
  !CCheckWindowFits3
  MOVEM.l (a7)+,d0/d1 ; Restore
  MOVE.l  a1,d6 ; Restore
End Macro

Macro CCheckSharedScrollShape
;Scroll-related shape-oriented partial check shared by a few tokens
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  !CCheckWindowFits3
  MOVE.l  a1,d6 ; Restore
  MOVE.l  d0,a1 ; Store
  MOVE.w  CurrentChunkyShape1,d0
  BLT     Error27
  !CThreeShapeChecks
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  MOVEM.l d0/d1,-(a7) ; Store
  MOVE.l  d4,d0 ; X2
  MOVE.l  d5,d1 ; Y2
  !CCheckWindowFits3
  MOVEM.l (a7)+,d0/d1 ; Restore
  MOVE.l  a1,d6 ; Restore
End Macro

Macro CCheckSharedStenScroll
;Scroll-related stencil-based check shared by a few tokens
  MOVE.l  d0,a1 ; Store
  MOVE.l  d6,d0
  !CThreeBitmapChecks
  !GetBitmapObjectPtr ; Base in a0
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Source has stencil?
  BEQ     Error33
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  !CCheckWindowFits3
  MOVE.l  a1,d6 ; Restore
  MOVE.l  d0,a1 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0
  BLT     Error28
  !CThreeBitmapChecks
  !GetBitmapObjectPtr ; Base in a0
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Dest has stencil?
  BEQ     Error34
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  MOVEM.l d0/d1,-(a7) ; Store
  MOVE.l  d4,d0 ; X2
  MOVE.l  d5,d1 ; Y2
  !CCheckWindowFits3
  MOVEM.l (a7)+,d0/d1 ; Restore
  MOVE.l  a1,d6 ; Restore
End Macro

Macro CCheckSharedCookScroll
;Scroll-related cookie-based check shared by a few tokens
  MOVE.l  d0,a1 ; Store
  MOVE.l  d6,d0
  !CThreeShapeChecks
  !GetShapeObjectPtr ; Base in a0
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Source has cookie?
  BEQ     Error31
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  !CCheckWindowFits3
  MOVE.l  a1,d6 ; Restore
  MOVE.l  d0,a1 ; Store
  MOVE.w  CurrentChunkyShape1,d0
  BLT     Error27
  !CThreeShapeChecks
  !GetShapeObjectPtr ; Base in a0
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Dest has cookie?
  BEQ     Error32
  MOVE.l  a1,d0 ; Restore
  MOVE.l  d6,a1 ; Store
  MOVEM.l d0/d1,-(a7) ; Store
  MOVE.l  d4,d0 ; X2
  MOVE.l  d5,d1 ; Y2
  !CCheckWindowFits3
  MOVEM.l (a7)+,d0/d1 ; Restore
  MOVE.l  a1,d6 ; Restore
End Macro

Macro CCheckWindowFits
;Check requested window size fits within existing size
;Trashes d6/d7/a0
;X/Y/Width/Height are d2/d3/d4/d5
  MOVE.w  d4,d6 ; Copy Width
  MOVE.w  d5,d7 ; Copy Height
  TST.w   d2 ; Left-edge too far left?
  BLT     Error39
  CMP.w   CRsrc_Width-ChunkyResources(a0),d2 ; Left-edge too far right?
  BGE     Error39
  TST.w   d3 ; Top-edge too far up?
  BLT     Error40
  CMP.w   CRsrc_Height-ChunkyResources(a0),d3 ; Top edge too far down?
  BGE     Error40
  TST.w   d4 ; Width too small?
  BLE     Error41
  ADD.w   d2,d6
  CMP.w   CRsrc_Width-ChunkyResources(a0),d6 ; Window wider than source?
  BGT     Error42
  TST.w   d5 ; Height too small?
  BLE     Error43
  ADD.w   d3,d7
  CMP.w   CRsrc_Height-ChunkyResources(a0),d7 ; Window taller than source?
  BGT     Error44
End Macro

Macro CCheckWindowFits2
;Check requested window size fits within existing size
;Trashes d6/d7/a0
;X/Y/Width/Height are d1/d2/d3/d4
  MOVE.w  d3,d6 ; Copy Width
  MOVE.w  d4,d7 ; Copy Height
  TST.w   d1 ; Left-edge too far left?
  BLT     Error39
  CMP.w   CRsrc_Width-ChunkyResources(a0),d1 ; Left-edge too far right?
  BGE     Error39
  TST.w   d2 ; Top-edge too far up?
  BLT     Error40
  CMP.w   CRsrc_Height-ChunkyResources(a0),d2 ; Top edge too far down?
  BGE     Error40
  TST.w   d3 ; Width too small?
  BLE     Error41
  ADD.w   d1,d6
  CMP.w   CRsrc_Width-ChunkyResources(a0),d6 ; Window wider than source?
  BGT     Error42
  TST.w   d4 ; Height too small?
  BLE     Error43
  ADD.w   d2,d7
  CMP.w   CRsrc_Height-ChunkyResources(a0),d7 ; Window taller than source?
  BGT     Error44
End Macro

Macro CCheckWindowFits3
;Check requested window size fits within existing size
;Trashes d6/d7/a0
;X/Y/Width/Height are d0/d1/d2/d3
  MOVE.w  d2,d6 ; Copy Width
  MOVE.w  d3,d7 ; Copy Height
  TST.w   d0 ; Left-edge too far left?
  BLT     Error39
  CMP.w   CRsrc_Width-ChunkyResources(a0),d0 ; Left-edge too far right?
  BGE     Error39
  TST.w   d1 ; Top-edge too far up?
  BLT     Error40
  CMP.w   CRsrc_Height-ChunkyResources(a0),d1 ; Top edge too far down?
  BGE     Error40
  TST.w   d2 ; Width too small?
  BLE     Error41
  ADD.w   d0,d6
  CMP.w   CRsrc_Width-ChunkyResources(a0),d6 ; Window wider than source?
  BGT     Error42
  TST.w   d3 ; Height too small?
  BLE     Error43
  ADD.w   d1,d7
  CMP.w   CRsrc_Height-ChunkyResources(a0),d7 ; Window taller than source?
  BGT     Error44
End Macro

Macro CCheckWindowFits4
;Check requested coords fit within existing dimensions
;X1/Y1/X2/Y2 are d0/d1/d2/d3 (uses X2,Y2 instead of width,height)
  TST.w   d0 ; X1 too far left?
  BLT     Error67
  CMP.w   CRsrc_Width-ChunkyResources(a0),d0 ; X1 too far right?
  BGE     Error67
  TST.w   d1 ; Y1 too far up?
  BLT     Error68
  CMP.w   CRsrc_Height-ChunkyResources(a0),d1 ; Y1 too far down?
  BGE     Error68
  TST.w   d2 ; X2 too far left?
  BLT     Error69
  CMP.w   CRsrc_Width-ChunkyResources(a0),d2 ; X2 too far right?
  BGT     Error69
  TST.w   d3 ; Y2 too far up?
  BLT     Error70
  CMP.w   CRsrc_Height-ChunkyResources(a0),d3 ; Y2 too far down?
  BGT     Error70
End Macro

Macro CThreec2pWindowChecks
;Three commonly used checks for c2pWindow commands
  !CCheckc2pWindowsExist
  !CCheckc2pWindowNum
  !CCheckc2pWindowNumExists
End Macro

Macro CThreeShapeChecks
;Three commonly used checks for shape commands
  !CCheckChunkyShapesExist
  !CCheckChunkyShapeNum
  !CCheckChunkyShapeNumExists
End Macro

Macro CThreeBitmapChecks
;Three commonly used checks for bitmaps commands
  !CCheckChunkyBitmapsExist
  !CCheckChunkyBitmapNum
  !CCheckChunkyBitmapNumExists
End Macro

Macro CThreeQueueChecks
;Three commonly used checks for queue commands
  !CCheckChunkyQueuesExist
  !CCheckChunkyQueueNum
  !CCheckChunkyQueueNumExists
End Macro

Macro CThreeTableChecks
;Three commonly used checks for table commands
  !CCheckChunkyTablesExist
  !CCheckChunkyTableNum
  !CCheckChunkyTableNumExists
End Macro

Macro CCheckc2pWindowNum
;Check that c2pWindow number is in valid range
  TST.w   d0
  BLT     Error0 ; Too small
  CMP.w   c2pWindowsTotal,d0
  BGE     Error0 ; Too large
End Macro

Macro CCheckc2pWindowsExist
;Check that memory has been allocated for c2pWindow objects
  TST.l   c2pWindowsMem ; Exist?
  BEQ     Error16 ; No, error
End Macro

Macro CCheckc2pWindowNumExists
;Check that a given c2pWindow object exists
  !Getc2pWindowObjectPtr ; Base into a0
  TST.l   c2p0_Pixels-c2pWindows(a0) ; Test Pixels and RowsStore
  BEQ     Error17 ; Doesn't exist
End Macro

Macro CCheckWordParam
;Check that d0 word parameter is valid (not negative)
  TST.w   d0
  BLT     Error18
End Macro

Macro CCheckWordParam2
;Check that d0 word parameter is valid (not negative, and also greater than 0)
  TST.w   d0
  BLE     Error25
End Macro

Macro CCheckChunkyBitmapsExist
;Check that memory has been allocated for ChunkyBitmap objects
  TST.l   ChunkyBitmapsMem ; Exist?
  BEQ     Error19 ; No, error
End Macro

Macro CCheckChunkyBitmapNum
;Check that ChunkyWindow number is in valid range
  TST.w   d0
  BLT     Error20 ; Too small
  CMP.w   ChunkyBitmapsTotal,d0
  BGE     Error20 ; Too large
End Macro

Macro CCheckChunkyBitmapNumExists
;Check that given ChunkyBitmap object exists
  MOVE.w  d0,d7
  EXT.l   d7
  LSL.l   #ChunkyResourceStructSize,d7
  MOVE.l  ChunkyBitmapsMem,a0
  ADD.l   d7,a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Test Width and Height
  BEQ     Error21 ; Doesn't exist
End Macro

Macro CCheckChunkyShapesExist
;Check that memory has been allocated for ChunkyShape objects
  TST.l   ChunkyShapesMem ; Exist?
  BEQ     Error22 ; No, error
End Macro

Macro CCheckChunkyShapeNum
;Check that ChunkyShape number is in valid range
  TST.w   d0
  BLT     Error23 ; Too small
  CMP.w   ChunkyShapesTotal,d0
  BGE     Error23 ; Too large
End Macro

Macro CCheckChunkyShapeNumExists
;Check that given ChunkyShape object exists
  MOVE.w  d0,d7
  EXT.l   d7
  LSL.l   #ChunkyResourceStructSize,d7
  MOVE.l  ChunkyShapesMem,a0
  ADD.l   d7,a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Test Width and Height
  BEQ     Error24 ; Doesn't exist
End Macro

Macro CCheckChunkyQueuesExist
;Check that memory has been allocated for ChunkyQueue objects
  TST.l   ChunkyQueuesMem ; Exist?
  BEQ     Error57 ; No, error
End Macro

Macro CCheckChunkyQueueNum
;Check that ChunkyQueue number is in valid range
  TST.w   d0
  BLT     Error58 ; Too small
  CMP.w   ChunkyQueuesTotal,d0
  BGE     Error58 ; Too large
End Macro

Macro CCheckChunkyQueueNumExists
;Check that given ChunkyQueue object exists
  MOVE.w  d0,d7
  EXT.l   d7
  LSL.l   #ChunkyQueueStructSize,d7
  MOVE.l  ChunkyQueuesMem,a0
  ADD.l   d7,a0
  TST.l   CQueue_LMem-ChunkyQueues(a0) ; Test list memory
  BEQ     Error59 ; Doesn't exist
End Macro

Macro CCheckChunkyTablesExist
;Check that memory has been allocated for ChunkyTable objects
  TST.l   ChunkyTablesMem ; Exist?
  BEQ     Error73 ; No, error
End Macro

Macro CCheckChunkyTableNum
;Check that ChunkyTable number is in valid range
  TST.w   d0
  BLT     Error74 ; Too small
  CMP.w   ChunkyTablesTotal,d0
  BGE     Error74 ; Too large
End Macro

Macro CCheckChunkyTableNumExists
;Check that given ChunkyTable object exists
  MOVE.w  d0,d7
  EXT.l   d7
  LSL.l   #ChunkyTableStructSize,d7
  MOVE.l  ChunkyTablesMem,a0
  ADD.l   d7,a0
  TST.l   CTable_LMem-ChunkyTables(a0) ; Test list memory
  BEQ     Error75 ; Doesn't exist
End Macro

;**-Routines-*************************************************************************

.Initialise
;Prepare included data that may have been modified in previous runs
  JSR     _MProcessor ; Find cpu
  BSR     _MCPU ; Set default general cpu
  BSR     _Mc2pCPUmode ; Set default cpu for c2p
  MOVE.l  #0,c2pWindowsMem
  MOVE.l  #0,ChunkyShapesMem
  MOVE.l  #0,ChunkyBitmapsMem
  MOVE.l  #0,ChunkyQueuesMem
  LEA     ChunkyShapeBanks,a0
  MOVEQ.l #NumberOfShapeBanks-1,d0
  MOVEQ.l #0,d1
InitClrLoop
  MOVE.l  d1,(a0)+
  MOVE.l  d1,(a0)+
  DBRA    d0,InitClrLoop
  MOVE.b  #-1,CShape_AutoCookie
  MOVE.b  #0,CBitmap_AutoStencil
  MOVE.b  #0,CShape_AutoClip
  MOVE.b  #0,CBitmap_AutoClip
  MOVE.b  #0,CShape_AutoWrap
  MOVE.b  #0,CBitmap_AutoWrap
  MOVE.b  #-1,CCookie_AutoXFlip
  MOVE.b  #-1,CCookie_AutoYFlip
  MOVE.b  #-1,CStencil_AutoXFlip
  MOVE.b  #-1,CStencil_AutoYFlip
  MOVE.w  #-1,Currentc2pWindow1
  MOVE.w  #-1,Currentc2pWindow2
  MOVE.w  #-1,Currentc2pWindow3
  MOVE.w  #-1,CurrentChunkyShape1
  MOVE.w  #-1,CurrentChunkyShape2
  MOVE.w  #-1,CurrentChunkyShape3
  MOVE.w  #-1,CurrentChunkyBitmap1
  MOVE.w  #-1,CurrentChunkyBitmap2
  MOVE.w  #-1,CurrentChunkyBitmap3
  MOVE.w  #-1,CurrentChunkyQueue1
  MOVE.w  #-1,CurrentChunkyQueue2
  MOVE.w  #-1,CurrentChunkyQueue3
  MOVE.w  #-1,CurrentChunkyTable1
  MOVE.w  #-1,CurrentChunkyTable2
  MOVE.w  #-1,CurrentChunkyTable3
  MOVE.b  #-1,Autoc2pWindowsUse
  MOVE.b  #-1,AutoChunkyShapesUse
  MOVE.b  #-1,AutoChunkyBitmapsUse
  MOVE.b  #-1,AutoChunkyQueuesUse
  MOVE.b  #-1,AutoChunkyTablesUse
  MOVE.b  #0,DoubleScrollMode
  MOVE.b  #0,DoubleQBlitMode
  MOVE.b  #0,DoubleBlitMode
  MOVE.w  #0,SScrollModeType
  MOVE.w  #0,SMaskScrollModeType
  MOVE.w  #0,_DoubleQBlitModeType
  MOVE.w  #0,_DoubleBlitModeType
  MOVE.w  #0,_BlitModeType
  MOVE.w  #4,_ParticleModeType
  MOVE.w  #4,_DrawingModeType
;Make default amounts of objects
  MOVEQ.l #20,d0 ; 20 c2p Windows
  BSR     _MReservec2pWindows
  MOVEQ.l #20,d0 ; 20 Bitmaps
  BSR     _MReserveBitmaps
  MOVEQ.l #100,d0 ; 100 Shapes
  BSR     _MReserveShapes
  MOVEQ.l #20,d0 ; 20 Queues
  BSR     _MReserveQueues
  MOVEQ.l #20,d0 ; 20 Tables
  BSR     _MReserveTables
;Return value for other libs to access
  LEA     _Data,a0
  MOVE.l  a0,d0 ; Return internal data area address
  RTS

;*************************************************************************************

.FinishUp
  RTS

;*************************************************************************************

_MNothing
  ; This is the 128th token. Do nothing, as it doesn't work.
  ; Also used for temporary tokens 1-5.
  RTS

;*************************************************************************************

_Mc2pCPUmode
;Set the cpu that the c2p is going to use, as there are 030- and 040+ routines
;Note that this setting is overridden by M040c2p's setting
  CMP.b   #4,d0 ; Check for 040
  BLT     _Mc2pCPUmode030
  MOVE.b  #1,c2pCPUmode
  RTS
_Mc2pCPUmode030
  MOVE.b  #0,c2pCPUmode
  RTS

;*************************************************************************************

_Mc2pWindowBriefShort
  MOVE.l  d1,d3
  MOVE.l  d1,d5
  MOVE.l  d2,d6
  MOVE.b  c2pCPUmode,d4
  LSL.b   #2,d4 ; Reverse engineeer cpu number
  BRA     _Mc2pWindow
_Mc2pWindowBrief
  MOVE.l  d3,d4
  MOVE.l  d1,d3
  MOVE.l  d1,d5
  MOVE.l  d2,d6
  BRA     _Mc2pWindow
_Mc2pWindowShort
  MOVE.l  d5,d6
  MOVE.l  d4,d5
  MOVE.b  c2pCPUmode,d4
  LSL.b   #2,d4 ; Reverse engineer cpu number
_Mc2pWindow
;Initialises Chunky-To-planar, also self-modifies code To alter #planesize
;Note that Planar YOffset has been removed.
;d0.w=c2pWindow number
;d1.w=Chunky operation width (window width)
;d2.w=Chunky operation height (window height)
;d3.w=Source width (length of a line in the whole chunky buffer, not a window)
;d4.b=Processor (blitz instruction, will be 0/1/2/3/4)
;d5.w=Planar width (full width of bitmap)
;d6.w=Planar height (full height of bitmap)
  CMP.b   #4,d4 ; 040+?
  BLT     _Mc2pWindowlowCPU2
  MOVE.b  #1,c2pCPUmode
  BRA     _Mc2pWindowskip2
_Mc2pWindowlowCPU2
  MOVE.b  #0,c2pCPUmode
_Mc2pWindowskip2
  AND.l   #$FFFF,d0
  !Getc2pWindowObjectPtr ; Get base into a0
  AND.l   #$FFFF,d1
  AND.l   #$FFFF,d2
  TST.b   Autoc2pWindowsUse ; Use it?
  BEQ     _Mc2pWindowDontUse ; No
  MOVE.w  d0,Currentc2pWindow1 ; Yes, store c2pWindow number in current
_Mc2pWindowDontUse
  AND.l   #$FFFF,d3
  AND.l   #$FFFF,d5
  AND.l   #$FFFF,d6
  MOVE.l  d3,d7 ;temp
  SUB.l   d1,d3
  MOVE.l  d5,d7 ; store
  SUB.l   d1,d5
  LSR.l   #3,d5
  MOVE.w  d5,c2p0_Pmod-c2pWindows(a0) ; Horizontal Planar modulo in bytes
  BEQ     _Mc2pWindowskip3
  MOVE.w  d3,c2p0_Cmod-c2pWindows(a0) ; Source chunky modulo in bytes and pixels (same)
  MOVE.w  d1,c2p0_Pixels-c2pWindows(a0) ; Pixels per row chunky
  SUBQ.l  #1,d2 ; loopcounter
  MOVE.w  d2,c2p0_RowsStore-c2pWindows(a0) ; Chunky rows (loopcounter)
  BRA     _Mc2pWindowskip5
_Mc2pWindowskip3
  MOVE.w  d3,c2p0_Cmod-c2pWindows(a0) ; Source chunky modulo in bytes and pixels (same)
  BEQ     _Mc2pWindowskip4
  MOVE.w  d1,c2p0_Pixels-c2pWindows(a0) ; Pixels per row chunky
  SUBQ.l  #1,d2 ; loopcounter
  MOVE.w  d2,c2p0_RowsStore-c2pWindows(a0) ; Chunky rows (loopcounter)
  BRA     _Mc2pWindowskip5
_Mc2pWindowskip4
  MULU    d2,d1 ; Height*Width for longword Pixels.l for use with no linemodulo
  MOVE.l  d1,c2p0_Pixels-c2pWindows(a0) ; Pixels in total chunky (overwrites c2p0_RowsStore)
_Mc2pWindowskip5
  ;SMC, #PlaneSize
  MULU    d6,d7
  LSR.l   #3,d7 ; PlaneSize
  MOVE.l  d7,_Mc2pSMC001-4 ;-)                    SELF MODIFYING CODE! ;-)
  MOVE.l  d7,_Mc2pSMC011-4
  MOVE.l  d7,_Mc2pSMC012-4
  MOVE.l  d7,_Mc2pSMC013-4
  MOVE.l  d7,_Mc2pSMC014-4
  MOVE.l  d7,_Mc2pSMC019-4
  MOVE.l  d7,_Mc2pSMC020-4
  MOVE.l  d7,_Mc2pSMC021-4
  MOVE.l  d7,_Mc2pSMC026-4
  MOVE.l  d7,_Mc2pSMC027-4
  MOVE.l  d7,_Mc2pSMC031-4
  MOVE.l  d7,_Mc2pSMC032-4
  MOVE.l  d7,_Mc2pSMC037-4
  MOVE.l  d7,_Mc2pSMC038-4
  MOVE.l  d7,_Mc2pNMSMC001-4 ;-)                  SELF MODIFYING CODE! ;-)
  MOVE.l  d7,_Mc2pNMSMC011-4
  MOVE.l  d7,_Mc2pNMSMC012-4
  MOVE.l  d7,_Mc2pNMSMC013-4
  MOVE.l  d7,_Mc2pNMSMC014-4
  MOVE.l  d7,_Mc2pNMSMC019-4
  MOVE.l  d7,_Mc2pNMSMC020-4
  MOVE.l  d7,_Mc2pNMSMC021-4
  MOVE.l  d7,_Mc2pNMSMC026-4
  MOVE.l  d7,_Mc2pNMSMC027-4
  MOVE.l  d7,_Mc2pNMSMC031-4
  MOVE.l  d7,_Mc2pNMSMC032-4
  MOVE.l  d7,_Mc2pNMSMC037-4
  MOVE.l  d7,_Mc2pNMSMC038-4
  ;SMC, #-PlaneSize
  MOVEQ.l #0,d6
  SUB.l   d7,d6 ; d6=-PlaneSize
  MOVE.l  d6,_Mc2pSMC003-4
  MOVE.l  d6,_Mc2pSMC004-4
  MOVE.l  d6,_Mc2pSMC005-4
  MOVE.l  d6,_Mc2pSMC006-4
  MOVE.l  d6,_Mc2pSMC015-4
  MOVE.l  d6,_Mc2pSMC016-4
  MOVE.l  d6,_Mc2pSMC017-4
  MOVE.l  d6,_Mc2pSMC018-4
  MOVE.l  d6,_Mc2pNMSMC003-4
  MOVE.l  d6,_Mc2pNMSMC004-4
  MOVE.l  d6,_Mc2pNMSMC005-4
  MOVE.l  d6,_Mc2pNMSMC006-4
  MOVE.l  d6,_Mc2pNMSMC015-4
  MOVE.l  d6,_Mc2pNMSMC016-4
  MOVE.l  d6,_Mc2pNMSMC017-4
  MOVE.l  d6,_Mc2pNMSMC018-4
  ;SMC, #-PlaneSize-4
  SUBQ.l  #4,d6
  MOVE.l  d6,_Mc2pSMC022-4
  MOVE.l  d6,_Mc2pSMC023-4
  MOVE.l  d6,_Mc2pSMC028-4
  MOVE.l  d6,_Mc2pSMC029-4
  MOVE.l  d6,_Mc2pSMC033-4
  MOVE.l  d6,_Mc2pSMC034-4
  MOVE.l  d6,_Mc2pSMC039-4
  MOVE.l  d6,_Mc2pSMC040-4
  MOVE.l  d6,_Mc2pNMSMC022-4
  MOVE.l  d6,_Mc2pNMSMC023-4
  MOVE.l  d6,_Mc2pNMSMC028-4
  MOVE.l  d6,_Mc2pNMSMC029-4
  MOVE.l  d6,_Mc2pNMSMC033-4
  MOVE.l  d6,_Mc2pNMSMC034-4
  MOVE.l  d6,_Mc2pNMSMC039-4
  MOVE.l  d6,_Mc2pNMSMC040-4
  ;SMC, #PlaneSize*2
  ADD.l   d7,d7
  MOVE.l  d7,_Mc2pSMC007-4
  MOVE.l  d7,_Mc2pSMC008-4
  MOVE.l  d7,_Mc2pSMC009-4
  MOVE.l  d7,_Mc2pSMC010-4
  MOVE.l  d7,_Mc2pSMC024-4
  MOVE.l  d7,_Mc2pSMC025-4
  MOVE.l  d7,_Mc2pSMC035-4
  MOVE.l  d7,_Mc2pSMC036-4
  MOVE.l  d7,_Mc2pNMSMC007-4
  MOVE.l  d7,_Mc2pNMSMC008-4
  MOVE.l  d7,_Mc2pNMSMC009-4
  MOVE.l  d7,_Mc2pNMSMC010-4
  MOVE.l  d7,_Mc2pNMSMC024-4
  MOVE.l  d7,_Mc2pNMSMC025-4
  MOVE.l  d7,_Mc2pNMSMC035-4
  MOVE.l  d7,_Mc2pNMSMC036-4
  ;SMC, #PlaneSize*4
  ADD.l   d7,d7
  MOVE.l  d7,_Mc2pSMC002-4
  MOVE.l  d7,_Mc2pSMC030-4
  MOVE.l  d7,_Mc2pNMSMC002-4
  MOVE.l  d7,_Mc2pNMSMC030-4
;Flush the cache!
  MOVEM.l  a3-a6,-(a7) ; Just in case
  MOVE.l  $4,a6
  JSR     LVOCacheClearU(a6)
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_Mc2pWindowWidthShort
  MOVE.w  Currentc2pWindow1,d0
_Mc2pWindowWidth
;Return the width of an existing c2pWindow object
  !Getc2pWindowObjectPtr ; Base in a0
  MOVE.w  c2p0_Pixels-c2pWindows(a0),d0
  RTS

;*************************************************************************************

_Mc2pWindowHeightShort
  MOVE.w  Currentc2pWindow1,d0
_Mc2pWindowHeight
;Return the height of an existing c2pWindow object
  !Getc2pWindowObjectPtr ; Base in a0
  MOVE.w  c2p0_RowsStore-c2pWindows(a0),d0
  RTS

;*************************************************************************************

_Mc2pWindowNewHeight
;Having already initialised a c2pWindow object, change its height
  !Getc2pWindowObjectPtr ; Base in a0
  SUBQ.w  #1,d1 ; Loopcounter
  MOVE.w  d1,c2p0_RowsStore-c2pWindows(a0) ; Store new row counter
  RTS

;*************************************************************************************

_Mc2pShortest
  MOVE.l  d0,d1
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Chunky base address
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _Mc2pSkip4
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d0 ; Add wrap bytes
_Mc2pSkip4
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip offset?
  BEQ     _Mc2pShort
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),d0 ; Add clip bytes
_Mc2pShort
  MOVE.l  d1,d2
  MOVE.l  d0,d1
  MOVE.w  Currentc2pWindow1,d0
_Mc2p
;AGA ChunkyToPlanar conversion.
;Different routines for 000-030 and 040-060.

  ;Handle c2pWindows
  !Getc2pWindowObjectPtr ; Base into a0
  MOVE.l  a0,a2
  MOVE.w  c2p0_Pmod-c2pWindows(a2),c2p_Pmod
  BEQ     _Mc2pModuloCheck
  MOVE.w  c2p0_Cmod-c2pWindows(a2),c2p_Cmod
  BRA     _Mc2pModulo
_Mc2pModuloCheck
  MOVE.w  c2p0_Cmod-c2pWindows(a2),c2p_Cmod ; modulo>0?
  BEQ     _Mc2pNoModulo ; zero, so do a non-modulo c2p

_Mc2pModulo
  MOVE.w  c2p0_Pixels-c2pWindows(a2),c2p_Pixels ; Word sized
  MOVE.w  c2p0_RowsStore-c2pWindows(a2),c2p_RowsStore ; Number of rows

  MOVE.l  d1,a0 ; Chunky
  MOVE.l  d2,a1 ; Planar

  MOVE.w  c2p_RowsStore,c2p_Rows ; Also halfway through _Mc2p030

  MOVEM.l a3-a6,-(a7)

  TST.b   c2pCPUmode ; 030 routine?
  BEQ     _Mc2p030

;Routine for 68040 and 68060.
;Used to be c2p040only.
_Mc2p040

  MOVE.w  c2p_Pixels,a3
  ADD.l   a0,a3

  ADD.l   #PlaneSize,a1
_Mc2pSMC001
  MOVE.l  a1,a2
  ADD.l   #PlaneSize*4,a2
_Mc2pSMC002

_Mc2p040loop
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d4
  MOVE.l  (a0)+,d5

  MOVE.l  d4,d7     ; Swap 16x4, part 1
  MOVE.w  d0,d4
  SWAP    d4
  MOVE.w  d4,d0
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d1,d5
  SWAP    d5
  MOVE.w  d5,d1
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 1
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  (a0)+,a5
  MOVE.l  (a0)+,a6

  EXG     d4,a5
  EXG     d5,a6

  MOVE.l  d4,d7     ; Swap 16x4, part 2
  MOVE.w  d2,d4
  SWAP    d4
  MOVE.w  d4,d2
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d3,d5
  SWAP    d5
  MOVE.w  d5,d3
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 2
  LSR.l   #2,d7
  EOR.l   d2,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d2
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d3,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d3
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  d1,d7     ; Swap 4x1
  LSR.l   #4,d7
  EOR.l   d0,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d0
  LSL.l   #4,d7
  EOR.l   d7,d1
  MOVE.l  d3,d7
  LSR.l   #4,d7
  EOR.l   d2,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d2
  LSL.l   #4,d7
  EOR.l   d7,d3

  BRA     _Mc2pStart040a
_Mc2pX040a

ADD.l #-PlaneSize,a1
_Mc2pSMC003

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d4
  MOVE.l  (a0)+,d5

;  MOVE.l  a6,-PlaneSize(a1)
MOVE.l a6,(a1)

  MOVE.l  d4,d7     ; Swap 16x4, part 1
  MOVE.w  d0,d4
  SWAP    d4
  MOVE.w  d4,d0
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d1,d5
  SWAP    d5
  MOVE.w  d5,d1
  MOVE.w  d7,d5

SUB.l #-PlaneSize,a1
_Mc2pSMC004

  MOVE.l  d4,d7     ; Swap 2x4, part 1
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d5

ADD.l #-PlaneSize,a2
_Mc2pSMC005

  MOVE.l  (a0)+,d7
  MOVE.l  (a0)+,a6

;  MOVE.l  a5,-PlaneSize(a2)
MOVE.l a5,(a2)

  MOVE.l  d7,a5
  EXG     d4,a5
  EXG     d5,a6

SUB.l #-PlaneSize,a2
_Mc2pSMC006

  MOVE.l  d4,d7     ; Swap 16x4, part 2
  MOVE.w  d2,d4
  SWAP    d4
  MOVE.w  d4,d2
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d3,d5
  SWAP    d5
  MOVE.w  d5,d3
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 2
  MOVE.l  d6,(a2)+

  LSR.l   #2,d7
  EOR.l   d2,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d2
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d3,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d3
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  d1,d7     ; Swap 4x1
  LSR.l   #4,d7
  EOR.l   d0,d7
  MOVE.l  a4,(a1)+

  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d0
  LSL.l   #4,d7
  EOR.l   d7,d1
  MOVE.l  d3,d7
  LSR.l   #4,d7
  EOR.l   d2,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d2
  LSL.l   #4,d7
  EOR.l   d7,d3

_Mc2pStart040a

ADD.l #PlaneSize*2,a2
_Mc2pSMC007

  MOVE.l  d2,d7     ; Swap 8x2, part 1
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d2
  MOVE.l  d2,d7
  LSR.l   #1,d7     ; Swap 1x2, part 1
  EOR.l   d0,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a2)
MOVE.l d0,(a2)
  ADD.l   d7,d7
  EOR.l   d7,d2
  MOVE.l  d3,d7     ; Swap 8x2, part 2
  LSR.l   #8,d7
  EOR.l   d1,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d1
  LSL.l   #8,d7
  EOR.l   d7,d3
SUB.l #PlaneSize*2,a2
_Mc2pSMC008
  MOVE.l  d3,d7
  LSR.l   #1,d7     ; Swap 1x2, part 2
  EOR.l   d1,d7
ADD.l #PlaneSize*2,a1
_Mc2pSMC009
  AND.l   #$55555555,d7
  EOR.l   d7,d1
;  MOVE.l  d1,PlaneSize*2(a1)
MOVE.l d1,(a1)
  ADD.l   d7,d7
  EOR.l   d7,d3

  MOVE.l  d5,d7
  LSR.l   #4,d7
  EOR.l   d4,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d4
  LSL.l   #4,d7
  EOR.l   d7,d5

SUB.l #PlaneSize*2,a1
_Mc2pSMC010

  EXG     d4,a5
  EXG     d5,a6

ADD.l #PlaneSize,a2
_Mc2pSMC011

  MOVE.l  d5,d7
  LSR.l   #4,d7
  EOR.l   d4,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d4
  LSL.l   #4,d7
  EOR.l   d7,d5

  MOVE.l  a5,d0
  MOVE.l  a6,d1
;  MOVE.l  d2,PlaneSize(a2)
MOVE.l d2,(a2)

  MOVE.l  d0,d7     ; Swap 8x2, part 3
  LSR.l   #8,d7
  EOR.l   d4,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d4
  LSL.l   #8,d7
  EOR.l   d7,d0
SUB.l #PlaneSize,a2
_Mc2pSMC012
  MOVE.l  d0,d7
  LSR.l   #1,d7     ; Swap 1x2, part 3
  EOR.l   d4,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d4
  ADD.l   d7,d7
ADD.l #PlaneSize,a1
_Mc2pSMC013
  EOR.l   d7,d0
  MOVE.l  d1,d7     ; Swap 8x2, part 4
  LSR.l   #8,d7
;  MOVE.l  d3,PlaneSize(a1)
MOVE.l d3,(a1)
  EOR.l   d5,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d5
  LSL.l   #8,d7
  EOR.l   d7,d1
  MOVE.l  d1,d7
  LSR.l   #1,d7     ; Swap 1x2, part 4
  EOR.l   d5,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d5
  ADD.l   d7,d7
  EOR.l   d7,d1

SUB.l #PlaneSize,a1
_Mc2pSMC014

  MOVE.l  d0,a5
  MOVE.l  d1,a6

  MOVE.l  d4,d6
  MOVE.l  d5,a4

  CMP.l   a0,a3
  BGT     _Mc2pX040a

;  MOVE.l  a6,-PlaneSize(a1)
ADD.l #-PlaneSize,a1
_Mc2pSMC015
MOVE.l a6,(a1)
;  MOVE.l  a5,-PlaneSize(a2)
ADD.l #-PlaneSize,a2
_Mc2pSMC017
MOVE.l a5,(a2)
SUB.l #-PlaneSize,a1
_Mc2pSMC016
  MOVE.l  a4,(a1)+
SUB.l #-PlaneSize,a2
_Mc2pSMC018
  MOVE.l  d6,(a2)+

;YLoop
  SUB.w   #1,c2p_Rows
  BLT     _Mc2p040skip
_Mc2p040nextrow
  ADD.w   c2p_Pixels,a3 ; end of next chunky line
  ADD.w   c2p_Pmod,a1 ; planar dest modulo
  ADD.w   c2p_Pmod,a2 ; planar dest modulo
  ADD.w   c2p_Cmod,a0 ; chunky source modulo
  ADD.w   c2p_Cmod,a3 ; end of next line plus source modulo, because a0 and a3 are compared
  BRA     _Mc2p040loop
_Mc2p040skip

  MOVEM.l (a7)+,a3-a6
  RTS ; Finish

;Routine for 68000, 68010, 68020 and 68030.
;Used to be c2p68030only.
_Mc2p030

  MOVE.l  #$33333333,d5
  MOVE.l  #$55555555,d6
  MOVE.l  #$00ff00ff,a6

  ADD.l   #PlaneSize,a1
_Mc2pSMC019

  MOVE.w  c2p_Pixels,a2
  ADD.l   a0,a2
  CMP.l   a0,a2
  BEQ     _Mc2pNone030a

  MOVEM.l a0-a1,-(a7)

_Mc2p030loop
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSL.l   #4,d0
  OR.l    d2,d0

  AND.l   d4,d1
  AND.l   d4,d3
  LSL.l   #4,d1
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSL.l   #4,d2
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSL.l   #4,d3
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA     _Mc2pStart030a
_Mc2pX030a

ADD.l #PlaneSize,a1
_Mc2pSMC020

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

;  MOVE.l  d7,PlaneSize(a1)
MOVE.l d7,(a1)

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSL.l   #4,d0
  OR.l    d2,d0

SUB.l #PlaneSize,a1
_Mc2pSMC021

  AND.l   d4,d1
  AND.l   d4,d3
  LSL.l   #4,d1
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  MOVE.l  a4,(a1)+

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSL.l   #4,d2
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSL.l   #4,d3
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

ADD.l #-PlaneSize-4,a1
_Mc2pSMC022

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

;  MOVE.l  a5,-PlaneSize-4(a1)
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pSMC023

_Mc2pStart030a
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   d5,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d2

  MOVE.l  d3,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   d5,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d3

ADD.l #PlaneSize*2,a1
_Mc2pSMC024

  MOVE.l  d1,d7
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   d4,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d1

  MOVE.l  d1,d7
  LSR.l   #1,d7
  EOR.l   d0,d7
  AND.l   d6,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a1)
MOVE.l d0,(a1)
  ADD.l   d7,d7
  EOR.l   d1,d7

  MOVE.l  d3,d1
  LSR.l   #8,d1
  EOR.l   d2,d1
  AND.l   d4,d1
  EOR.l   d1,d2
  LSL.l   #8,d1
  EOR.l   d1,d3

SUB.l #PlaneSize*2,a1
_Mc2pSMC025

  MOVE.l  d3,d1
  LSR.l   #1,d1
  EOR.l   d2,d1
  AND.l   d6,d1
  EOR.l   d1,d2
  ADD.l   d1,d1
  EOR.l   d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BGT     _Mc2pX030a

;  MOVE.l  d7,PlaneSize(a1)
ADD.l #PlaneSize,a1
_Mc2pSMC026
MOVE.l d7,(a1)
SUB.l #PlaneSize,a1
_Mc2pSMC027
  MOVE.l  a4,(a1)+
;  MOVE.l  a5,-PlaneSize-4(a1)
ADD.l #-PlaneSize-4,a1
_Mc2pSMC028
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pSMC029

;YLoop
  SUB.w   #1,c2p_Rows
  BLT     _Mc2p030skip
_Mc2p030nextrow
  ADD.w   c2p_Pixels,a2 ; End of next chunky line
  ADD.w   c2p_Pmod,a1 ; Planar dest modulo
  ADD.w   c2p_Cmod,a0 ; Chunky source modulo
  ADD.w   c2p_Cmod,a2 ; End of next chunky line + Chunky source modulo
  BRA     _Mc2p030loop
_Mc2p030skip

  MOVEM.l (a7)+,a0-a1

  MOVE.w  c2p_RowsStore,c2p_Rows ; Has to be reset. Also see start of statement
  MOVE.w  c2p_Pixels,a2 ; Has to be reset!
  ADD.l   a0,a2

  ADD.l   #PlaneSize*4,a1
_Mc2pSMC030

_Mc2p030loop2
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSR.l   #4,d2
  OR.l    d2,d0

  AND.l   d4,d1
  AND.l   d4,d3
  LSR.l   #4,d3
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSR.l   #4,d1
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSR.l   #4,d7
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA     _Mc2pStart030b
_Mc2pX030b

ADD.l #PlaneSize,a1
_Mc2pSMC031

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

;  MOVE.l  d7,PlaneSize(a1)
MOVE.l d7,(a1)

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSR.l   #4,d2
  OR.l    d2,d0

SUB.l #PlaneSize,a1
_Mc2pSMC032

  AND.l   d4,d1
  AND.l   d4,d3
  LSR.l   #4,d3
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  MOVE.l  a4,(a1)+

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSR.l   #4,d1
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSR.l   #4,d7
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

ADD.l #-PlaneSize-4,a1
_Mc2pSMC033

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

;  MOVE.l  a5,-PlaneSize-4(a1)
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pSMC034

_Mc2pStart030b
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   d5,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d2

  MOVE.l  d3,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   d5,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d3

ADD.l #PlaneSize*2,a1
_Mc2pSMC035

  MOVE.l  d1,d7
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   d4,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d1

  MOVE.l  d1,d7
  LSR.l   #1,d7
  EOR.l   d0,d7
  AND.l   d6,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a1)
MOVE.l d0,(a1)
  ADD.l   d7,d7
  EOR.l   d1,d7

  MOVE.l  d3,d1
  LSR.l   #8,d1
  EOR.l   d2,d1
  AND.l   d4,d1
  EOR.l   d1,d2
  LSL.l   #8,d1
  EOR.l   d1,d3

SUB.l #PlaneSize*2,a1
_Mc2pSMC036

  MOVE.l  d3,d1
  LSR.l   #1,d1
  EOR.l   d2,d1
  AND.l   d6,d1
  EOR.l   d1,d2
  ADD.l   d1,d1
  EOR.l   d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BGT     _Mc2pX030b

;  MOVE.l  d7,PlaneSize(a1)
ADD.l #PlaneSize,a1
_Mc2pSMC037
MOVE.l d7,(a1)
SUB.l #PlaneSize,a1
_Mc2pSMC038
  MOVE.l  a4,(a1)+
;  MOVE.l  a5,-PlaneSize-4(a1)
ADD.l #-PlaneSize-4,a1
_Mc2pSMC039
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pSMC040

;YLoop
  SUB.w   #1,c2p_Rows
  BLT     _Mc2p030skip2
_Mc2p030nextrow2
  ADD.w   c2p_Pixels,a2 ; End of next chunky line
  ADD.w   c2p_Pmod,a1 ; Planar dest modulo
  ADD.w   c2p_Cmod,a0 ; Chunky source modulo
  ADD.w   c2p_Cmod,a2 ; End of next chunky line + Chunky source modulo
  BRA     _Mc2p030loop2
_Mc2p030skip2

_Mc2pNone030a
  MOVEM.l (a7)+,a3-a6
  RTS ; Finish

_Mc2pNoModulo ; Non-modulo c2p
  MOVE.l  c2p0_Pixels-c2pWindows(a2),c2p_Pixels ; Longword sized

  MOVE.l  d1,a0 ; Chunky
  MOVE.l  d2,a1 ; Planar

  MOVEM.l a3-a6,-(a7)

  TST.b   c2pCPUmode ; 030 routine?
  BEQ     _Mc2pNM030

;Routine for 68040 and 68060.
;Used to be c2p040only.
_Mc2pNM040

  MOVE.l  c2p_Pixels,a3
  ADD.l   a0,a3

  ADD.l   #PlaneSize,a1
_Mc2pNMSMC001
  MOVE.l  a1,a2
  ADD.l   #PlaneSize*4,a2
_Mc2pNMSMC002

_Mc2pNM040loop
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d4
  MOVE.l  (a0)+,d5

  MOVE.l  d4,d7     ; Swap 16x4, part 1
  MOVE.w  d0,d4
  SWAP    d4
  MOVE.w  d4,d0
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d1,d5
  SWAP    d5
  MOVE.w  d5,d1
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 1
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  (a0)+,a5
  MOVE.l  (a0)+,a6

  EXG     d4,a5
  EXG     d5,a6

  MOVE.l  d4,d7     ; Swap 16x4, part 2
  MOVE.w  d2,d4
  SWAP    d4
  MOVE.w  d4,d2
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d3,d5
  SWAP    d5
  MOVE.w  d5,d3
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 2
  LSR.l   #2,d7
  EOR.l   d2,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d2
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d3,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d3
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  d1,d7     ; Swap 4x1
  LSR.l   #4,d7
  EOR.l   d0,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d0
  LSL.l   #4,d7
  EOR.l   d7,d1
  MOVE.l  d3,d7
  LSR.l   #4,d7
  EOR.l   d2,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d2
  LSL.l   #4,d7
  EOR.l   d7,d3

  BRA     _Mc2pNMStart040a
_Mc2pNMX040a

ADD.l #-PlaneSize,a1
_Mc2pNMSMC003

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d4
  MOVE.l  (a0)+,d5

;  MOVE.l  a6,-PlaneSize(a1)
MOVE.l a6,(a1)

  MOVE.l  d4,d7     ; Swap 16x4, part 1
  MOVE.w  d0,d4
  SWAP    d4
  MOVE.w  d4,d0
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d1,d5
  SWAP    d5
  MOVE.w  d5,d1
  MOVE.w  d7,d5

SUB.l #-PlaneSize,a1
_Mc2pNMSMC004

  MOVE.l  d4,d7     ; Swap 2x4, part 1
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d5

ADD.l #-PlaneSize,a2
_Mc2pNMSMC005

  MOVE.l  (a0)+,d7
  MOVE.l  (a0)+,a6

;  MOVE.l  a5,-PlaneSize(a2)
MOVE.l a5,(a2)

  MOVE.l  d7,a5
  EXG     d4,a5
  EXG     d5,a6

SUB.l #-PlaneSize,a2
_Mc2pNMSMC006

  MOVE.l  d4,d7     ; Swap 16x4, part 2
  MOVE.w  d2,d4
  SWAP    d4
  MOVE.w  d4,d2
  MOVE.w  d7,d4
  MOVE.l  d5,d7
  MOVE.w  d3,d5
  SWAP    d5
  MOVE.w  d5,d3
  MOVE.w  d7,d5

  MOVE.l  d4,d7     ; Swap 2x4, part 2
  MOVE.l  d6,(a2)+

  LSR.l   #2,d7
  EOR.l   d2,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d2
  LSL.l   #2,d7
  EOR.l   d7,d4
  MOVE.l  d5,d7
  LSR.l   #2,d7
  EOR.l   d3,d7
  AND.l   #$33333333,d7
  EOR.l   d7,d3
  LSL.l   #2,d7
  EOR.l   d7,d5

  MOVE.l  d1,d7     ; Swap 4x1
  LSR.l   #4,d7
  EOR.l   d0,d7
  MOVE.l  a4,(a1)+

  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d0
  LSL.l   #4,d7
  EOR.l   d7,d1
  MOVE.l  d3,d7
  LSR.l   #4,d7
  EOR.l   d2,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d2
  LSL.l   #4,d7
  EOR.l   d7,d3

_Mc2pNMStart040a

ADD.l #PlaneSize*2,a2
_Mc2pNMSMC007

  MOVE.l  d2,d7     ; Swap 8x2, part 1
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d2
  MOVE.l  d2,d7
  LSR.l   #1,d7     ; Swap 1x2, part 1
  EOR.l   d0,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a2)
MOVE.l d0,(a2)
  ADD.l   d7,d7
  EOR.l   d7,d2
  MOVE.l  d3,d7     ; Swap 8x2, part 2
  LSR.l   #8,d7
  EOR.l   d1,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d1
  LSL.l   #8,d7
  EOR.l   d7,d3
SUB.l #PlaneSize*2,a2
_Mc2pNMSMC008
  MOVE.l  d3,d7
  LSR.l   #1,d7     ; Swap 1x2, part 2
  EOR.l   d1,d7
ADD.l #PlaneSize*2,a1
_Mc2pNMSMC009
  AND.l   #$55555555,d7
  EOR.l   d7,d1
;  MOVE.l  d1,PlaneSize*2(a1)
MOVE.l d1,(a1)
  ADD.l   d7,d7
  EOR.l   d7,d3

  MOVE.l  d5,d7
  LSR.l   #4,d7
  EOR.l   d4,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d4
  LSL.l   #4,d7
  EOR.l   d7,d5

SUB.l #PlaneSize*2,a1
_Mc2pNMSMC010

  EXG     d4,a5
  EXG     d5,a6

ADD.l #PlaneSize,a2
_Mc2pNMSMC011

  MOVE.l  d5,d7
  LSR.l   #4,d7
  EOR.l   d4,d7
  AND.l   #$0f0f0f0f,d7
  EOR.l   d7,d4
  LSL.l   #4,d7
  EOR.l   d7,d5

  MOVE.l  a5,d0
  MOVE.l  a6,d1
;  MOVE.l  d2,PlaneSize(a2)
MOVE.l d2,(a2)

  MOVE.l  d0,d7     ; Swap 8x2, part 3
  LSR.l   #8,d7
  EOR.l   d4,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d4
  LSL.l   #8,d7
  EOR.l   d7,d0
SUB.l #PlaneSize,a2
_Mc2pNMSMC012
  MOVE.l  d0,d7
  LSR.l   #1,d7     ; Swap 1x2, part 3
  EOR.l   d4,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d4
  ADD.l   d7,d7
ADD.l #PlaneSize,a1
_Mc2pNMSMC013
  EOR.l   d7,d0
  MOVE.l  d1,d7     ; Swap 8x2, part 4
  LSR.l   #8,d7
;  MOVE.l  d3,PlaneSize(a1)
MOVE.l d3,(a1)
  EOR.l   d5,d7
  AND.l   #$00ff00ff,d7
  EOR.l   d7,d5
  LSL.l   #8,d7
  EOR.l   d7,d1
  MOVE.l  d1,d7
  LSR.l   #1,d7     ; Swap 1x2, part 4
  EOR.l   d5,d7
  AND.l   #$55555555,d7
  EOR.l   d7,d5
  ADD.l   d7,d7
  EOR.l   d7,d1

SUB.l #PlaneSize,a1
_Mc2pNMSMC014

  MOVE.l  d0,a5
  MOVE.l  d1,a6

  MOVE.l  d4,d6
  MOVE.l  d5,a4

  CMP.l   a0,a3
  BGT     _Mc2pNMX040a

;  MOVE.l  a6,-PlaneSize(a1)
ADD.l #-PlaneSize,a1
_Mc2pNMSMC015
MOVE.l a6,(a1)
;  MOVE.l  a5,-PlaneSize(a2)
ADD.l #-PlaneSize,a2
_Mc2pNMSMC017
MOVE.l a5,(a2)
SUB.l #-PlaneSize,a1
_Mc2pNMSMC016
  MOVE.l  a4,(a1)+
SUB.l #-PlaneSize,a2
_Mc2pNMSMC018
  MOVE.l  d6,(a2)+

  MOVEM.l (a7)+,a3-a6
  RTS ; Finish

;Routine for 68000, 68010, 68020 and 68030.
;Used to be c2p68030only.
_Mc2pNM030

  MOVE.l  #$33333333,d5
  MOVE.l  #$55555555,d6
  MOVE.l  #$00ff00ff,a6

  ADD.l   #PlaneSize,a1
_Mc2pNMSMC019

  MOVE.l  c2p_Pixels,a2
  ADD.l   a0,a2
  CMP.l   a0,a2
  BEQ     _Mc2pNMNone030a

  MOVEM.l a0-a1,-(a7)

_Mc2pNM030loop
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSL.l   #4,d0
  OR.l    d2,d0

  AND.l   d4,d1
  AND.l   d4,d3
  LSL.l   #4,d1
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSL.l   #4,d2
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSL.l   #4,d3
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA     _Mc2pNMStart030a
_Mc2pNMX030a

ADD.l #PlaneSize,a1
_Mc2pNMSMC020

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

;  MOVE.l  d7,PlaneSize(a1)
MOVE.l d7,(a1)

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSL.l   #4,d0
  OR.l    d2,d0

SUB.l #PlaneSize,a1
_Mc2pNMSMC021

  AND.l   d4,d1
  AND.l   d4,d3
  LSL.l   #4,d1
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  MOVE.l  a4,(a1)+

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSL.l   #4,d2
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSL.l   #4,d3
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

ADD.l #-PlaneSize-4,a1
_Mc2pNMSMC022

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

;  MOVE.l  a5,-PlaneSize-4(a1)
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pNMSMC023

_Mc2pNMStart030a
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   d5,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d2

  MOVE.l  d3,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   d5,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d3

ADD.l #PlaneSize*2,a1
_Mc2pNMSMC024

  MOVE.l  d1,d7
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   d4,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d1

  MOVE.l  d1,d7
  LSR.l   #1,d7
  EOR.l   d0,d7
  AND.l   d6,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a1)
MOVE.l d0,(a1)
  ADD.l   d7,d7
  EOR.l   d1,d7

  MOVE.l  d3,d1
  LSR.l   #8,d1
  EOR.l   d2,d1
  AND.l   d4,d1
  EOR.l   d1,d2
  LSL.l   #8,d1
  EOR.l   d1,d3

SUB.l #PlaneSize*2,a1
_Mc2pNMSMC025

  MOVE.l  d3,d1
  LSR.l   #1,d1
  EOR.l   d2,d1
  AND.l   d6,d1
  EOR.l   d1,d2
  ADD.l   d1,d1
  EOR.l   d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BGT     _Mc2pNMX030a

;  MOVE.l  d7,PlaneSize(a1)
ADD.l #PlaneSize,a1
_Mc2pNMSMC026
MOVE.l d7,(a1)
SUB.l #PlaneSize,a1
_Mc2pNMSMC027
  MOVE.l  a4,(a1)+
;  MOVE.l  a5,-PlaneSize-4(a1)
ADD.l #-PlaneSize-4,a1
_Mc2pNMSMC028
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pNMSMC029

  MOVEM.l (a7)+,a0-a1

  MOVE.l  c2p_Pixels,a2 ; Has to be reset!
  ADD.l   a0,a2

  ADD.l   #PlaneSize*4,a1
_Mc2pNMSMC030

_Mc2pNM030loop2
  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSR.l   #4,d2
  OR.l    d2,d0

  AND.l   d4,d1
  AND.l   d4,d3
  LSR.l   #4,d3
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSR.l   #4,d1
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSR.l   #4,d7
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA     _Mc2pNMStart030b
_Mc2pNMX030b

ADD.l #PlaneSize,a1
_Mc2pNMSMC031

  MOVE.l  (a0)+,d0
  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3

;  MOVE.l  d7,PlaneSize(a1)
MOVE.l d7,(a1)

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l   d4,d0
  AND.l   d4,d2
  LSR.l   #4,d2
  OR.l    d2,d0

SUB.l #PlaneSize,a1
_Mc2pNMSMC032

  AND.l   d4,d1
  AND.l   d4,d3
  LSR.l   #4,d3
  OR.l    d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0)+,d2
  MOVE.l  (a0)+,d1
  MOVE.l  (a0)+,d3
  MOVE.l  (a0)+,d7

  MOVE.l  a4,(a1)+

  AND.l   d4,d2     ; Merge 4x1, part 2
  AND.l   d4,d1
  LSR.l   #4,d1
  OR.l    d1,d2

  AND.l   d4,d3
  AND.l   d4,d7
  LSR.l   #4,d7
  OR.l    d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP    d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

ADD.l #-PlaneSize-4,a1
_Mc2pNMSMC033

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP    d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

;  MOVE.l  a5,-PlaneSize-4(a1)
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pNMSMC034

_Mc2pNMStart030b
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l   #2,d7
  EOR.l   d0,d7
  AND.l   d5,d7
  EOR.l   d7,d0
  LSL.l   #2,d7
  EOR.l   d7,d2

  MOVE.l  d3,d7
  LSR.l   #2,d7
  EOR.l   d1,d7
  AND.l   d5,d7
  EOR.l   d7,d1
  LSL.l   #2,d7
  EOR.l   d7,d3

ADD.l #PlaneSize*2,a1
_Mc2pNMSMC035

  MOVE.l  d1,d7
  LSR.l   #8,d7
  EOR.l   d0,d7
  AND.l   d4,d7
  EOR.l   d7,d0
  LSL.l   #8,d7
  EOR.l   d7,d1

  MOVE.l  d1,d7
  LSR.l   #1,d7
  EOR.l   d0,d7
  AND.l   d6,d7
  EOR.l   d7,d0
;  MOVE.l  d0,PlaneSize*2(a1)
MOVE.l d0,(a1)
  ADD.l   d7,d7
  EOR.l   d1,d7

  MOVE.l  d3,d1
  LSR.l   #8,d1
  EOR.l   d2,d1
  AND.l   d4,d1
  EOR.l   d1,d2
  LSL.l   #8,d1
  EOR.l   d1,d3

SUB.l #PlaneSize*2,a1
_Mc2pNMSMC036

  MOVE.l  d3,d1
  LSR.l   #1,d1
  EOR.l   d2,d1
  AND.l   d6,d1
  EOR.l   d1,d2
  ADD.l   d1,d1
  EOR.l   d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BGT     _Mc2pNMX030b

;  MOVE.l  d7,PlaneSize(a1)
ADD.l #PlaneSize,a1
_Mc2pNMSMC037
MOVE.l d7,(a1)
SUB.l #PlaneSize,a1
_Mc2pNMSMC038
  MOVE.l  a4,(a1)+
;  MOVE.l  a5,-PlaneSize-4(a1)
ADD.l #-PlaneSize-4,a1
_Mc2pNMSMC039
MOVE.l a5,(a1)
SUB.l #-PlaneSize-4,a1
_Mc2pNMSMC040

_Mc2pNMNone030a
  MOVEM.l (a7)+,a3-a6
  RTS ; Finish

;*************************************************************************************

_MReservec2pWindows
;Reserve memory for c2pWindow structures
  MOVE.l  d0,d7
  TST.l   c2pWindowsMem ; Check for existing mem allocated
  BEQ     _MReservec2pWindowsskip ; If exists, deallocate
  MOVE.w  c2pWindowsTotal,d0
  EXT.l   d0
  LSL.l   #c2pWindowStructSize,d0
  MOVE.l  c2pWindowsMem,a1
  ALibJsr #BlitzFreemem ; Free memory
  MOVE.l  d7,d0
  MOVE.w  #0,c2pWindowsTotal
  MOVE.l  #0,c2pWindowsMem
_MReservec2pWindowsskip
  AND.l   #$FFFF,d0
  MOVE.w  d0,d7
  LSL.l   #c2pWindowStructSize,d0
  MOVE.l  #ClearPublicMem,d1 ; MemType (public and clear)
  !CheckAvailMem{003}
  TST.b   d2 ; Likely?
  BEQ     _MReservec2pWindowsfailed
  ALibJsr #BlitzAllocmem ; Allocate memory
  TST.l   d0
  BEQ     _MReservec2pWindowsfailed
  MOVE.l  d0,c2pWindowsMem
  MOVE.w  d7,c2pWindowsTotal
  RTS     ; Return memory address in d0.l
_MReservec2pWindowsfailed
  MOVEQ.l #0,d0 ; Errorcode
  RTS

;*************************************************************************************

_MReserveChunkyShapesShort
  MOVE.w  CurrentChunkyShapeBank,d1
_MReserveShapes
_MReserveChunkyShapes
;Reserve memory for ChunkyShape structures
  MOVE.w  d1,-(a7) ; Store bank number
  TST.l   ChunkyShapesMem ; Needs freeing?
  BEQ     ReserveCSSkip
  MOVE.w  d0,d6 ; Store
  BSR     _MFreeChunkyShapes
  MOVE.w  d6,d0 ; Restore
ReserveCSSkip
  MOVE.w  d0,d7
  MOVE.l  ChunkyShapesMem,d6
  MOVE.w  ChunkyShapesTotal,d5
  EXT.l   d5
  !ReserveChunkyResourceStructs{001}
  MOVE.w  d7,ChunkyShapesTotal
  MOVE.l  d0,ChunkyShapesMem
  LEA     ChunkyShapeBanks,a0
  MOVE.w  (a7)+,d1 ; Restore bank number
  EXT.l   d1
  MOVE.l  d1,d4 ; Store
  LSL.l   #3,d1 ; *8 for offset
  ADD.l   d1,a0
  MOVE.l  d0,(a0)+ ; Store ChunkyShapesMem
  MOVE.w  d7,(a0) ; Store ChunkyShapesTotal
  MOVE.l  d4,d0 ; Prepare
  BRA     _MUseShapeBank ; Use this bank
  RTS     ; Precaution. Return memory address in d0.l

;*************************************************************************************
_MReserveBitmaps
_MReserveChunkyBitmaps
;Reserve memory for ChunkyBitmap structures
  TST.l   ChunkyBitmapsMem ; Needs freeing?
  BEQ     ReserveCBSkip
  MOVE.w  d0,d6 ; Store
  BSR     _MFreeChunkyBitmaps
  MOVE.w  d6,d0 ; Restore
ReserveCBSkip
  MOVE.w  d0,d7
  MOVE.l  ChunkyBitmapsMem,d6
  MOVE.w  ChunkyBitmapsTotal,d5
  EXT.l   d5
  !ReserveChunkyResourceStructs{002}
  MOVE.w  d7,ChunkyBitmapsTotal
  MOVE.l  d0,ChunkyBitmapsMem
  RTS     ; Return memory address in d0.l

;*************************************************************************************
_MShape
_MChunkyShape
;Initialise a new ChunkyShape object
  !RoundUpWidth{001} ; Make width multiple of 4
  !GetShapeObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  !DeallocResourceObject{002} ; Deallocate existing data
  !InitData ; Shared setup
  !NewChunkyMem{001} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     InitCSFailed
  MOVE.l  a2,a0 ; Get base in a0
  !StoreResourceDataMemInfo
  TST.b   CShape_AutoCookie ; Automatically make a cookie?
  BEQ     InitCSNoCookie
  MOVE.l  d4,d0 ; Get total bytes
  !NewChunkyMem{002} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     InitCSFailed2
  !StoreResourceStencilMemInfo
  BRA     InitCSSkip
InitCSNoCookie
  !WriteDefaultStencilInfo{002}
InitCSSkip
  !FinishResourceInit
  TST.b   AutoChunkyShapesUse ; Use it?
  BEQ     InitCSDontUse ; No
  MOVE.w  d5,CurrentChunkyShape1 ; Yes, store shape number in current
InitCSDontUse
  MOVE.l  a2,a0 ; Base in a0
  MOVE.b  CShape_AutoClip,CRsrc_Clipping-ChunkyResources(a0)
  MOVE.b  CShape_AutoWrap,CRsrc_Wrapping-ChunkyResources(a0)
  !WriteDefaultClipData
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Success return value as data address (aligned)
  RTS     ; Successful, return

InitCSFailed
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0
InitCSFailed2
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  #-1,(a0) ; Dummy value so that it will deallocate data mem
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0) ; In case stencil data previously exists, prevent attempted deallocation
  !DeallocResourceObject{003} ; Deallocate existing data
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0

;*************************************************************************************
_MBitmap
_MChunkyBitmap
;Initialise a new ChunkyBitmap object
  !RoundUpWidth{002} ; Make width multiple of 4
  !GetBitmapObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  !DeallocResourceObject{004} ; Deallocate existing data
  !InitData ; Shared setup
  !NewChunkyMem{003} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     InitCBFailed
  MOVE.l  a2,a0 ; Get base in a0
  !StoreResourceDataMemInfo
  TST.b   CBitmap_AutoStencil ; Automatically make a stencil?
  BEQ     InitCBNoStencil
  MOVE.l  d4,d0 ; Get total bytes
  !NewChunkyMem{004} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     InitCBFailed2
  !StoreResourceStencilMemInfo
  BRA     InitCBSkip
InitCBNoStencil
  !WriteDefaultStencilInfo{003}
InitCBSkip
  !FinishResourceInit
  TST.b   AutoChunkyBitmapsUse ; Use it?
  BEQ     InitCBDontUse ; No
  MOVE.w  d5,CurrentChunkyBitmap1 ; Yes, store bitmap number in current
InitCBDontUse
  MOVE.l  a2,a0 ; Base in a0
  MOVE.b  CBitmap_AutoClip,CRsrc_Clipping-ChunkyResources(a0)
  MOVE.b  CBitmap_AutoWrap,CRsrc_Wrapping-ChunkyResources(a0)
  !WriteDefaultClipData
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Success return value as data address (aligned)
  RTS     ; Successful, return

InitCBFailed
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0
InitCBFailed2
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  #-1,CRsrc_Width-ChunkyResources(a0) ; Dummy value so that it will deallocate data mem
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0) ; In case stencil data previously exists, prevent attempted deallocation
  !DeallocResourceObject{005} ; Deallocate existing data
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0

;*************************************************************************************
_MAutoCookie
_MAutoChunkyShapeCookie
;Switch on/off ChunkyShape Auto-Cookie creation feature
  MOVE.b  d0,CShape_AutoCookie
  RTS

;*************************************************************************************
_MAutoStencil
_MAutoChunkyBitmapStencil
;Switch on/off ChunkyBitmap Auto-Stencil creation feature
  MOVE.b  d0,CBitmap_AutoStencil
  RTS

;*************************************************************************************

_MFreec2pWindowsRange
;Free a range of c2pWindow objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d3 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
_MFreec2pWindowsRangeloop
  MOVE.w  d3,d0
  ADD.w   d4,d0
  BSR     _MFreec2pWindow
  DBRA    d3,_MFreec2pWindowsRangeloop
  RTS
_MFreec2pWindows
;Free all c2pWindow objects
  MOVE.w  c2pWindowsTotal,d3
  SUBQ.w  #1,d3 ; loopcounter
_MFreec2pWindowsloop
  MOVE.w  d3,d0
  BSR     _MFreec2pWindow ; Free it
  DBRA    d3,_MFreec2pWindowsloop
  RTS
_MFreec2pWindow
;Free a single c2pWindow object. No actual memory to free so just make inactive
  !Getc2pWindowObjectPtr ; Base into a0
  TST.l   c2p0_Pixels-c2pWindows(a0) ; Test Pixels and RowsStore
  BEQ     _MFreec2pWindowSkip
  MOVE.l  #0,c2p0_Pixels-c2pWindows(a0) ; Make it dead
_MFreec2pWindowSkip
  RTS

;*************************************************************************************

_MFreeChunkyShapesRange
;Free a range of ChunkyShape objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCSRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyShape ; Free it
  DBRA    d7,FreeCSRloop
  RTS
_MFreeShapes
_MFreeChunkyShapes
;Free all ChunkyShape objects
  MOVE.w  ChunkyShapesTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCSloop
  MOVE.w  d7,d0
  BSR     _MFreeChunkyShape ; Free it
  DBRA    d7,FreeCSloop
FreeCSsSkip
  RTS
_MFreeShape
_MFreeChunkyShape
;Free a single ChunkyShape objects
  !GetShapeObjectPtr ; Get base of struct in a0
  !DeallocResourceObject{006} ; Deallocate existing data & make the object dead
  RTS

;*************************************************************************************

_MFreeChunkyBitmapsRange
;Free a range of ChunkyBitmap objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCBRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyBitmap ; Free it
  DBRA    d7,FreeCBRloop
  RTS
_MFreeBitmaps
_MFreeChunkyBitmaps
;Free all ChunkyBitmap objects
  MOVE.w  ChunkyBitmapsTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCBloop
  MOVE.w  d7,d0
  BSR     _MFreeChunkyBitmap ; Free it
  DBRA    d7,FreeCBloop
  RTS
_MFreeBitmap
_MFreeChunkyBitmap
;Free a single ChunkyBitmap object
  !GetBitmapObjectPtr ; Get base of struct in a0
  !DeallocResourceObject{007} ; Deallocate existing data and make the object dead
  RTS

;*************************************************************************************
_MChunkyShapeWidthShort
  MOVE.w  CurrentChunkyShape1,d0
_MShapeWidth
_MChunkyShapeWidth
;Returns the width of the specified ChunkyShape
  !GetShapeObjectPtr ; In a0
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0
  RTS

;*************************************************************************************
_MChunkyBitmapWidthShort
  MOVE.w  CurrentChunkyBitmap1,d0
_MBitmapWidth
_MChunkyBitmapWidth
;Returns the width of the specified ChunkyBitmap
  !GetBitmapObjectPtr ; In a0
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0
  RTS

;*************************************************************************************
_MChunkyShapeHeightShort
  MOVE.w  CurrentChunkyShape1,d0
_MShapeHeight
_MChunkyShapeHeight
;Returns the height of the specified ChunkyShape
  !GetShapeObjectPtr ; In a0
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d0
  RTS

;*************************************************************************************
_MChunkyBitmapHeightShort
  MOVE.w  CurrentChunkyBitmap1,d0
_MBitmapHeight
_MChunkyBitmapHeight
;Returns the height of the specified ChunkyBitmap
  !GetBitmapObjectPtr ; In a0
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d0
  RTS

;*************************************************************************************

_MAddrc2pWindowShort
  MOVE.w  Currentc2pWindow1,d0
_MAddrc2pWindow
;Returns the address of the specified c2pWindow structure
  !Getc2pWindowObjectPtr ; In a0
  MOVE.l  a0,d0 ; Return address
  RTS

;*************************************************************************************
_MAddrChunkyShapeShort
  MOVE.w  CurrentChunkyShape1,d0
_MAddrShape
_MAddrChunkyShape
;Returns the address of the specified ChunkyShape structure
  !GetShapeObjectPtr ; In a0
  MOVE.l  a0,d0 ; Return address
  RTS

;*************************************************************************************
_MAddrChunkyBitmapShort
  MOVE.w  CurrentChunkyBitmap1,d0
_MAddrBitmap
_MAddrChunkyBitmap
;Returns the address of the specified ChunkyBitmap structure
  !GetBitmapObjectPtr ; In a0
  MOVE.l  a0,d0 ; Return address
  RTS

;*************************************************************************************
_MHandle
_MChunkyShapeHandle
;Set a new handle/origin for a ChunkyShape
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d1,CRsrc_XHandle-ChunkyResources(a0) ; Store X Handle/origin
  MOVE.w  d2,CRsrc_YHandle-ChunkyResources(a0) ; Store Y Handle/origin
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d2,d7
  EXT.l   d1
  ADD.l   d1,d7 ; Wrap bytes
  MOVE.l  d7,CRsrc_WrapBytes-ChunkyResources(a0) ; Store WrapBytes
  RTS

;*************************************************************************************
_MBitmapOrigin
_MChunkyBitmapOrigin
;Set a new handle/origin for a ChunkyBitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d1,CRsrc_XHandle-ChunkyResources(a0) ; Store X Handle/origin
  MOVE.w  d2,CRsrc_YHandle-ChunkyResources(a0) ; Store Y Handle/origin
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d2,d7
  EXT.l   d1
  ADD.l   d1,d7 ; Wrap bytes
  MOVE.l  d7,CRsrc_WrapBytes-ChunkyResources(a0) ; Store WrapBytes
  RTS

;*************************************************************************************

_MUsec2pWindow
;Set the currently used c2pWindows
  MOVE.w  d2,Currentc2pWindow3
_MUsec2pWindowShort
  MOVE.w  d1,Currentc2pWindow2
_MUsec2pWindowShortest
  MOVE.w  d0,Currentc2pWindow1
  RTS

;*************************************************************************************
_MUseShape
_MUseChunkyShape
;Set the currently used ChunkyShapes
  MOVE.w  d2,CurrentChunkyShape3
_MUseChunkyShapeShort
  MOVE.w  d1,CurrentChunkyShape2
_MUseChunkyShapeShortest
  MOVE.w  d0,CurrentChunkyShape1
  RTS

;*************************************************************************************
_MUseBitmap
_MUseChunkyBitmap
;Set the currently used ChunkyBitmaps
  MOVE.w  d2,CurrentChunkyBitmap3
_MUseChunkyBitmapShort
  MOVE.w  d1,CurrentChunkyBitmap2
_MUseChunkyBitmapShortest
  MOVE.w  d0,CurrentChunkyBitmap1
  RTS

;*************************************************************************************

_MUsedc2pWindow
;Returns number of main currently used c2pWindow, or likely -1 if not defined
  MOVE.w  Currentc2pWindow1,d0
  RTS

;*************************************************************************************
_MUsedShape
_MUsedChunkyShape
;Returns number of main currently used ChunkyShape, or likely -1 if not defined
  MOVE.w  CurrentChunkyShape1,d0
  RTS

;*************************************************************************************
_MUsedBitmap
_MUsedChunkyBitmap
;Returns number of main currently used ChunkyBitmap, or likely -1 if not defined
  MOVE.w  CurrentChunkyBitmap1,d0
  RTS

;*************************************************************************************
_MCludgeShape
_MCludgeChunkyShape
;Cludge a new ChunkyShape object from existing memory
  SUB.l   #16,d3 ; Prepare for alignment
  !RoundUpWidth{003} ; Make width multilpe of 4
  !GetShapeObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  !DeallocResourceObject{008} ; Deallocate existing data
  !InitData ; Shared setup
  MOVE.l  d3,d0 ; Put address in d0
  MOVE.l  a2,a0 ; Get base in a0
  !StoreResourceDataMemInfo2
  TST.b   CShape_AutoCookie ; Automatically make a cookie?
  BEQ     CludgeCSNoCookie
  MOVE.l  d4,d0 ; Get total bytes
  !NewChunkyMem{005} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     CludgeCSFailed2
  !StoreResourceStencilMemInfo
  ;Make cookie
  !FinishResourceInit ; Have to do this before making stencil data
  !RemakeStencil{001}
  BRA     CludgeCSSkip
CludgeCSNoCookie
  !FinishResourceInit
  !WriteDefaultStencilInfo{004}
CludgeCSSkip
  TST.b   AutoChunkyShapesUse ; Use it?
  BEQ     CludgeCSDontUse ; No
  MOVE.w  d5,CurrentChunkyShape1 ; Yes, store shape number in current
CludgeCSDontUse
  MOVE.l  a2,a0 ; Base in a0
  MOVE.b  CShape_AutoClip,CRsrc_Clipping-ChunkyResources(a0)
  MOVE.b  CShape_AutoWrap,CRsrc_Wrapping-ChunkyResources(a0)
  !WriteDefaultClipData
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Success return value as data address (aligned)
  RTS     ; Successful, return

CludgeCSFailed
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0
CludgeCSFailed2
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  #-1,(a0) ; Dummy value so that it will deallocate data mem
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0) ; In case stencil data previously exists, prevent attempted deallocation
  !DeallocResourceObject{009} ; Deallocate existing data
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0

;*************************************************************************************
_MCludgeBitmap
_MCludgeChunkyBitmap
;Cludge a new ChunkyBitmap object from existing memory
  SUB.l   #16,d3 ; Prepare for alignment
  !RoundUpWidth{004} ; Make width multiple of 4
  !GetBitmapObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  !DeallocResourceObject{010} ; Deallocate existing data
  !InitData ; Shared setup
  MOVE.l  d3,d0 ; Put address in d0
  MOVE.l  a2,a0 ; Get base in a0
  !StoreResourceDataMemInfo2
  TST.b   CBitmap_AutoStencil ; Automatically make a stencil?
  BEQ     CludgeCBNoStencil
  MOVE.l  d4,d0 ; Get total bytes
  !NewChunkyMem{006} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     CludgeCBFailed2
  !StoreResourceStencilMemInfo
  ;Make stencil
  !FinishResourceInit ; Have to do this before making stencil data
  !RemakeStencil{002}
  BRA     CludgeCBSkip
CludgeCBNoStencil
  !FinishResourceInit
  !WriteDefaultStencilInfo{005}
CludgeCBSkip
  TST.b   AutoChunkyBitmapsUse ; Use it?
  BEQ     InitCBDontUse ; No
  MOVE.w  d5,CurrentChunkyBitmap1 ; Yes, store shape number in current
CludgeCBDontUse
  MOVE.l  a2,a0 ; Base in a0
  MOVE.b  CBitmap_AutoClip,CRsrc_Clipping-ChunkyResources(a0)
  MOVE.b  CBitmap_AutoWrap,CRsrc_Wrapping-ChunkyResources(a0)
  !WriteDefaultClipData
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Success return value as data address (aligned)
  RTS     ; Successful, return

CludgeCBFailed
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0
CludgeCBFailed2
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  #-1,CRsrc_Width-ChunkyResources(a0) ; Dummy value so that it will deallocate data mem
  MOVE.b  #0,CRsrc_SHere-ChunkyResources(a0) ; In case stencil data previously exists, prevent attempted deallocation
  !DeallocResourceObject{011} ; Deallocate existing data
  MOVEQ.l #0,d0
  RTS     ; Return errorcode in d0

;*************************************************************************************

_MAutoUsec2pWindows
  MOVE.b  d0,Autoc2pWindowsUse
  RTS

;*************************************************************************************
_MAutoUseShapes
_MAutoUseChunkyShapes
  MOVE.b  d0,AutoChunkyShapesUse
  RTS

;*************************************************************************************
_MAutoUseBitmaps
_MAutoUseChunkyBitmaps
  MOVE.b  d0,AutoChunkyBitmapsUse
  RTS

;*************************************************************************************

_MMakeChunkyShapeCookiesShort
  MOVEQ.l #0,d0 ; First
  MOVE.w  ChunkyShapesTotal,d1
  SUBQ.w  #1,d1 ; Last
_MMakeCookies
_MMakeChunkyShapeCookies
;Make cookies for all or a range of ChunkyShape objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d3 ; Loopcounter, no need for -1
  MOVE.w  d0,d5 ; Start offset
MMCSCsloop
  MOVE.w  d3,d0 ; Current
  ADD.w   d5,d0 ; StartOffset+Current
  BSR     _MMakeChunkyShapeCookie ; Make cookie
  DBRA    d3,MMCSCsloop
MMCSCsSskip
  RTS
_MMakeCookie
_MMakeChunkyShapeCookie
;Make a new cookie for a ChunkyShape
  !GetShapeObjectPtr ; Base in a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Active shape?
  BEQ     MMCSCookSkip
  !PrepareStencilMemory{001} ; Get suitable mem
  TST.b   d2 ; Success?
  BEQ     MMCSCSfailed
  ;Got mem, now make data
  !RemakeStencil{003}
MMCSCSfailed
MMCSCookSkip
  RTS

;*************************************************************************************

_MMakeChunkyBitmapStencilsShort
  MOVEQ.l #0,d0 ; First
  MOVE.w  ChunkyBitmapsTotal,d1
  SUBQ.w  #1,d1 ; Last
_MMakeStencils
_MMakeChunkyBitmapStencils
;Make stencils for all or a range of ChunkyBitmap objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d3 ; Loopcounter, no need for -1
  MOVE.w  d0,d5 ; Start offset
MMCBSsloop
  MOVE.w  d3,d0 ; Current
  ADD.w   d5,d0 ; StartOffset+Current
  BSR     _MMakeChunkyBitmapStencil ; Make stencil
  DBRA    d3,MMCBSsloop
MMCBSsSskip
  RTS
_MMakeStencil
_MMakeChunkyBitmapStencil
;Make a new stencil for a ChunkyBitmap
  !GetBitmapObjectPtr ; Base in a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Active bitmap?
  BEQ     MMCBStenSkip
  !PrepareStencilMemory{002} ; Get suitable mem
  TST.b   d2 ; Success?
  BEQ     MMCBSSfailed
  ;Got mem, now make data
  !RemakeStencil{004}
MMCBSSfailed
MMCBStenSkip
  RTS

;*************************************************************************************

_MFreeChunkyShapeCookiesRange
;Free a range of ChunkyShape object's cookies
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCSCsRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyShapeCookie ; Free it
  DBRA    d7,FreeCSCsRloop
  RTS
_MFreeCookies
_MFreeChunkyShapeCookies
;Free all ChunkyShape object's cookies
  MOVE.w  ChunkyShapesTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCSCsloop
  MOVE.w  d7,d0
  BSR     _MFreeChunkyShapeCookie ; Free it
  DBRA    d7,FreeCSCsloop
  RTS
_MFreeCookie
_MFreeChunkyShapeCookie
;Free any memory reserved for a stencil and clear info
  !GetShapeObjectPtr ; Base in a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Active shape?
  BEQ     MFreeCSCskip
  !FreeStencilMem{001}
MFreeCSCskip
  RTS

;*************************************************************************************

_MFreeChunkyBitmapStencilsRange
;Free a range of ChunkyBitmap object's stencils
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCBSsRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyBitmapStencil ; Free it
  DBRA    d7,FreeCBSsRloop
  RTS
_MFreeStencils
_MFreeChunkyBitmapStencils
;Free all ChunkyBitmap object's stencils
  MOVE.w  ChunkyBitmapsTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCBSsloop
  MOVE.l  d7,d0
  BSR     _MFreeChunkyBitmapStencil ; Free it
  DBRA    d7,FreeCBSsloop
  RTS
_MFreeStencil
_MFreeChunkyBitmapStencil
;Free any memory reserved for a stencil and clear info
  !GetBitmapObjectPtr ; Base in a0
  TST.l   CRsrc_Width-ChunkyResources(a0) ; Active bitmap?
  BEQ     MFreeCBSskip
  !FreeStencilMem{002}
MFreeCBSskip
  RTS

;*************************************************************************************
_MAutoShapeWrap
_MAutoChunkyShapeWrapping
;Switch on/off ChunkyShape Auto X&Y handle-wrapping feature
  MOVE.b  d0,CShape_AutoWrap
  RTS

;*************************************************************************************
_MAutoBitmapWrap
_MAutoChunkyBitmapWrapping
;Switch on/off ChunkyBitmap Auto X&Y handle-wrapping feature
  MOVE.b  d0,CBitmap_AutoWrap
  RTS

;*************************************************************************************
_MShapeWrap
_MChunkyShapeWrapping
;Switch on/off X&Y handle-wrapping for a ChunkyShape
  !GetShapeObjectPtr ; Base in a0
  MOVE.b  d1,CRsrc_Wrapping-ChunkyResources(a0)
  RTS

;*************************************************************************************
_MBitmapWrap
_MChunkyBitmapWrapping
;Switch on/off X&Y handle-wrapping for a ChunkyBitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.b  d1,CRsrc_Wrapping-ChunkyResources(a0)
  RTS

;*************************************************************************************
_MCludgeShapeStruct
_MCludgeChunkyShapeStruct
;Cludge a new ChunkyShape from an existing one but don't copy any graphic/stencil data
  MOVE.w  d1,-(a7) ; Store dest Shape#
  !CopyCShapeDat{001}
  MOVE.w  (a7)+,d1 ; Restore dest Shape#
  TST.b   AutoChunkyShapesUse ; Use it?
  BEQ     MCCSStructDontUse ; No
  MOVE.w  d1,CurrentChunkyShape1 ; Yes, store shape number in current
MCCSStructDontUse
  MOVE.l  CRsrc_Data-ChunkyResources(a1),d0 ; Return start of useable data
  RTS

;*************************************************************************************
_MCludgeBitmapStruct
_MCludgeChunkyBitmapStruct
;Cludge a new ChunkyBitmap from an existing one but don't copy any graphic/stencil data
  MOVE.w  d1,-(a7) ; Store dest Bitmap#
  !CopyCBitmapDat{001}
  MOVE.w  (a7)+,d1 ; Restore dest Bitmap#
  TST.b   AutoChunkyBitmapsUse ; Use it?
  BEQ     MCCBStructDontUse ; No
  MOVE.w  d1,CurrentChunkyBitmap1 ; Yes, store bitmap number in current
MCCBStructDontUse
  MOVE.l  CRsrc_Data-ChunkyResources(a1),d0 ; Return start of useable data
  RTS

;*************************************************************************************
_MCopyc2pWindow
_MCopyc2pWindowStruct
;Creat a new c2pWindow from an existing one, copying only definition data
  EXG.l   d0,d1
  !Getc2pWindowObjectPtr ; Base in a0
  EXG.l   d0,d1
  MOVE.l  a0,a1 ; Dest
  !Getc2pWindowObjectPtr ; Base in a0 - Source
  MOVE.w  c2p0_Pixels-c2pWindows(a0),c2p0_Pixels-c2pWindows(a1)
  MOVE.w  c2p0_RowsStore-c2pWindows(a0),c2p0_RowsStore-c2pWindows(a1)
  MOVE.w  c2p0_Cmod-c2pWindows(a0),c2p0_Cmod-c2pWindows(a1)
  MOVE.w  c2p0_Pmod-c2pWindows(a0),c2p0_Pmod-c2pWindows(a1)
  TST.b   Autoc2pWindowsUse ; Use it?
  BEQ     _MCopyc2pWindowStructDontUse ; No
  MOVE.w  d1,Currentc2pWindow1 ; Yes, store c2pWindow number in current
_MCopyc2pWindowStructDontUse
  RTS

;*************************************************************************************
_MShapeWindow
_MChunkyShapeWindow
;Cludge a new ChunkyShape window inside an existing one (not larger)
  MOVE.w  d1,-(a7) ; Store dest Shape#
  !CopyCShapeDat{002}
  !CludgeResourceWindow{001}
  MOVE.w  (a7)+,d1 ; Restore dest Shape#
  TST.l   d0 ; Errorskip?
  BEQ     MCCSWindowDontUse
  TST.b   AutoChunkyShapesUse ; Use it?
  BEQ     MCCSWindowDontUse ; No
  MOVE.w  d1,CurrentChunkyShape1 ; Yes, store shape number in current
MCCSWindowDontUse
  RTS     ; Returns address or error in d0

;*************************************************************************************
_MBitmapWindow
_MChunkyBitmapWindow
;Cludge a new ChunkyBitmap window inside an existing one (not larger)
  MOVE.w  d1,-(a7) ; Store dest Bitmap#
  !CopyCBitmapDat{002}
  !CludgeResourceWindow{002}
  MOVE.w  (a7)+,d1 ; Restore dest Bitmap#
  TST.l   d0 ; Errorskip?
  BEQ     MCCBWindowDontUse
  TST.b   AutoChunkyBitmapsUse ; Use it?
  BEQ     MCCBWindowDontUse ; No
  MOVE.w  d1,CurrentChunkyBitmap1 ; Yes, store bitmap number in current
MCCBWindowDontUse
  RTS     ; Returns address or error in d0

;*************************************************************************************
_MBitmapShape
_MChunkyBitmapShape
;Cludge a new ChunkyShape from an existing ChunkyBitmap but don't copy graphic/stencil data
  MOVE.w  d1,-(a7) ; Store dest Shape#
  !CopyCBitmapDatToCShape{001}
  MOVE.w  (a7)+,d1 ; Restore dest Shape#
  TST.b   AutoChunkyShapesUse ; Use it?
  BEQ     MCBShapeDontUse ; No
  MOVE.w  d1,CurrentChunkyShape1 ; Yes, store shape number in current
MCBShapeDontUse
  MOVE.l  CRsrc_Data-ChunkyResources(a1),d0 ; Return start of useable data
  RTS

;*************************************************************************************
_MShapesBitmap
_MChunkyShapesBitmap
;Cludge a new ChunkyBitmap from an existing ChunkyShape but don't copy graphic/stencil data
  MOVE.w  d1,-(a7) ; Store dest Bitmap#
  !CopyCShapeDatToCBitmap{001}
  MOVE.w  (a7)+,d1 ; Restore dest Bitmap#
  TST.b   AutoChunkyBitmapsUse ; Use it?
  BEQ     MCSBitmapDontUse ; No
  MOVE.w  d1,CurrentChunkyBitmap1 ; Yes, store bitmap number in current
MCSBitmapDontUse
  MOVE.l  CRsrc_Data-ChunkyResources(a1),d0 ; Return start of useable data
  RTS

;*************************************************************************************
_MAutoCookieXFlip
_MAutoChunkyCookieXFlip
;Switch on/off ChunkyShape's cookie Auto X-flipping feature
  MOVE.b  d0,CCookie_AutoXFlip
  RTS

;*************************************************************************************
_MAutoCookieYFlip
_MAutoChunkyCookieYFlip
;Switch on/off ChunkyShape's cookie Auto Y-flipping feature
  MOVE.b  d0,CCookie_AutoYFlip
  RTS

;*************************************************************************************
_MAutoStencilXFlip
_MAutoChunkyStencilXFlip
;Switch on/off ChunkyBitmap's stencil Auto X-flipping feature
  MOVE.b  d0,CStencil_AutoXFlip
  RTS

;*************************************************************************************
_MAutoStencilYFlip
_MAutoChunkyStencilYFlip
;Switch on/off ChunkyBitmap's stencil Auto Y-flipping feature
  MOVE.b  d0,CStencil_AutoYFlip
  RTS

;*************************************************************************************
_MAutoCookieFlip
_MAutoChunkyCookieFlipping
;Switch on/off ChunkyShape's cookie Auto X&Y flipping feature
  MOVE.b  d0,CCookie_AutoXFlip
  MOVE.b  d0,CCookie_AutoYFlip
  RTS

;*************************************************************************************
_MAutoStencilFlip
_MAutoChunkyStencilFlipping
;Switch on/off ChunkyBitmap's stencil Auto X&Y flipping feature
  MOVE.b  d0,CStencil_AutoXFlip
  MOVE.b  d0,CStencil_AutoYFlip
  RTS

;*************************************************************************************
_MShapeXFlip
_MChunkyShapeXFlip
;Flip a ChunkyShape horizontally and also possibly it's cookie
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformXFlip{001}
  TST.b   CCookie_AutoXFlip
  BEQ     MCSXFlipSkip
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Has cookie?
  BEQ     MCSXFlipSkip
  BRA     _MChunkyCookieXFlipEntry ; ignore rts
MCSXFlipSkip
  RTS

;*************************************************************************************
_MShapeYFlip
_MChunkyShapeYFlip
;Flip a ChunkyShape vertically and also possibly it's cookie
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformYFlip{001}
  TST.b   CCookie_AutoYFlip
  BEQ     MCSYFlipSkip
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Has cookie?
  BEQ     MCSYFlipSkip
  BRA     _MChunkyCookieYFlipEntry ; ignore rts
MCSYFlipSkip
  RTS

;*************************************************************************************
_MBitmapXFlip
_MChunkyBitmapXFlip
;Flip a ChunkyBitmap horizonally and also possibly it's stencil
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformXFlip{002}
  TST.b   CStencil_AutoXFlip
  BEQ     MCBXFlipSkip
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Has stencil?
  BEQ     MCBXFlipSkip
  BRA     _MChunkyBitmapXFlipEntry ; ignore rts
MCBXFlipSkip
  RTS

;*************************************************************************************
_MBitmapYFlip
_MChunkyBitmapYFlip
;Flip a ChunkyBitmap vertically and also possibly it's stencil
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformYFlip{002}
  TST.b   CStencil_AutoYFlip
  BEQ     MCBYFlipSkip
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Has stencil?
  BEQ     MCBYFlipSkip
  BRA     _MChunkyBitmapYFlipEntry ; ignore rts
MCBYFlipSkip
  RTS

;*************************************************************************************
_MCookieXFlip
_MChunkyCookieXFlip
;Flip a ChunkyShape's cookie horizontally
  !GetShapeObjectPtr ; Base in a0
_MChunkyCookieXFlipEntry ; Entry point for _MChunkyShapeXFlip
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformXFlip{003}
  RTS

;*************************************************************************************
_MCookieYFlip
_MChunkyCookieYFlip
;Flip a ChunkyShape's cookie vertically
  !GetShapeObjectPtr ; Base in a0
_MChunkyCookieYFlipEntry ; Entry point for _MChunkyShapeYFlip
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformYFlip{003}
  RTS

;*************************************************************************************
_MStencilXFlip
_MChunkyStencilXFlip
;Flip a ChunkyBitmap's stencil horizontally
  !GetBitmapObjectPtr ; Base in a0
_MChunkyBitmapXFlipEntry ; Entry point for _MChunkyBitmapXFlip
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformXFlip{004}
  RTS

;*************************************************************************************
_MStencilYFlip
_MChunkyStencilYFlip
;Flip a ChunkyBitmap's stencil vertically
  !GetBitmapObjectPtr ; Base in a0
_MChunkyBitmapYFlipEntry ; Entry point for _MChunkyBitmapYFlip
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1
  BSR     InitialiseRegs2
  !PerformYFlip{004}
  RTS

;*************************************************************************************
_MAutoShapeClip
_MAutoChunkyShapeClipping
;Switch on/off ChunkyShape Auto-Clip feature
  MOVE.b  d0,CShape_AutoClip
  RTS

;*************************************************************************************
_MAutoBitmapClip
_MAutoChunkyBitmapClipping
;Switch on/off ChunkyBitmap Auto-Clip feature
  MOVE.b  d0,CBitmap_AutoClip
  RTS

;*************************************************************************************

_MChunkyShapeClipSwitch
  !GetShapeObjectPtr ; Base in a0
  MOVE.b  d1,CRsrc_Clipping-ChunkyResources(a0)
  RTS
_MChunkyShapeClipShort
  MOVE.b  CShape_AutoClip,d5
_MShapeClip
_MChunkyShapeClip
;Define the clip window of an existing ChunkyShape, within its limits
  !GetShapeObjectPtr ; Base in a0
  EXG.l   d3,d1
  !RoundUpWidth{007} ; Make Width multiple of 4
  EXG.l   d3,d1
;  !RoundUpWidth{008} ; Make X multiple of 4
  !WriteClipWindowData
  RTS

;*************************************************************************************

_MChunkyBitmapClipSwitch
  !GetBitmapObjectPtr ; Base in a0
  MOVE.b  d1,CRsrc_Clipping-ChunkyResources(a0)
  RTS
_MChunkyBitmapClipShort
  MOVE.b  CBitmap_AutoClip,d5
_MBitmapClip
_MChunkyBitmapClip
;Define the clip window of an existing ChunkyBitmap, within its limits
  !GetBitmapObjectPtr ; Base in a0
  EXG.l   d3,d1
  !RoundUpWidth{009} ; Make Width multiple of 4
  EXG.l   d3,d1
;  !RoundUpWidth{010} ; Make X multiple of 4
  !WriteClipWindowData
  RTS

;*************************************************************************************

_MGetaChunkyShapeShort
  MOVEQ.l #0,d5 ; Init Block On/Off param, default to off
  MOVEQ.l #0,d6 ; Init StencilIsCookie On/Off param, default to off
_MGetaShape
_MGetaChunkyShape
;Create a new ChunkyShape from an existing ChunkyBitmap and copy graphic/stencil data, maybe with block routines
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCSSkip
  AND.b   #$F0,d1 ; Crop X down to nearest 16
  AND.b   #$F0,d3 ; Copy Width down to nearest 16
  BGT     _MGetaCSSkip
  MOVEQ.l #16,d3 ; Make sure width at least 16
_MGetaCSSkip
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.w  d3,d1 ; Prepare width
  MOVE.w  d4,d2 ; Prepare height
  BSR     _MChunkyShape
  MOVE.l  d0,d7 ; Store result
  MOVEM.w (a7)+,d0-d6 ; Restore
  TST.l   d7 ; Error?
  BEQ     MGetaCSError
  MOVE.w  CurrentChunkyShape1,d7 ; Store
  MOVE.w  d0,CurrentChunkyShape1
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.l  d7,-(a7) ; Store
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCSNotBlock
_MGetaCSBlock
  !ShuffleRegs2
  BSR     _MBlockScrollBitmapToShapeShort
  BRA     _MGetaCSSkip2
_MGetaCSNotBlock
  !ShuffleRegs2
  BSR     _MScrollBitmapToShapeShort
_MGetaCSSkip2
  MOVE.l  (a7)+,d7 ; Restore
  MOVEM.w (a7)+,d0-d6 ; Restore
  MOVE.w  d7,CurrentChunkyShape1 ; Restore
  TST.b   CShape_AutoCookie
  BEQ     MGetaCSDone
  TST.b   d6 ; Try and grab existing stencil?
  BEQ     _MGetaCSTryMaking
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Source has stencil?
  BEQ     _MGetaCSTryMaking ; Doesn't have one, so try and make one
  TST.l   CRsrc_SMem-ChunkyResources(a1) ; Dest has cookie?
  BEQ     MGetaCSError2 ; Doesn't have one so can't complete operation
  MOVE.w  CurrentChunkyShape1,d7 ; Store
  MOVE.w  d0,CurrentChunkyShape1
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.l  d7,-(a7) ; Store
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCSNotBlock2
_MGetaCSBlock2
  !ShuffleRegs2
  BSR     _MBlockScrollStencilToCookieShort
  BRA     _MGetaCSSkip3
_MGetaCSNotBlock2
  !ShuffleRegs2
  BSR     _MScrollStencilToCookieShort
_MGetaCSSkip3
  MOVE.l  (a7)+,d7 ; Restore
  MOVEM.w (a7)+,d0-d6 ; Restore
  MOVE.w  d7,CurrentChunkyShape1 ; Restore
  BRA     MGetaCSDone
_MGetaCSTryMaking
  MOVE.w  d0,-(a7) ; Store
  BSR     _MMakeChunkyShapeCookie
  MOVE.w  (a7)+,d0 ; Restore
MGetaCSDone
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Return address of data as success
_MGetaCSSkip4
  RTS
MGetaCSError
  MOVEQ.l #0,d0 ; Error
  RTS
MGetaCSError2
  !GetShapeObjectPtr ; Base in a0
  !DeallocResourceObject{012} ; Kill
  RTS

;*************************************************************************************

_MGetaChunkyBitmapShort
  MOVEQ.l #0,d5 ; Init Block On/Off param, default to off
  MOVEQ.l #0,d6 ; Init CookieIsStencil On/Off param, default to off
_MGetaBitmap
_MGetaChunkyBitmap
;Create a new ChunkyBitmap from an existing ChunkyShape and copy graphic/stencil data, maybe with block routines
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCBSkip
  AND.b   #$F0,d1 ; Crop X down to nearest 16
  AND.b   #$F0,d3 ; Copy Width down to nearest 16
  BGT     _MGetaCBSkip
  MOVEQ.l #16,d3 ; Make sure width at least 16
_MGetaCBSkip
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.w  d3,d1 ; Prepare width
  MOVE.w  d4,d2 ; Prepare height
  BSR     _MChunkyBitmap
  MOVE.l  d0,d7 ; Store result
  MOVEM.w (a7)+,d0-d6 ; Restore
  TST.l   d7 ; Error?
  BEQ     MGetaCBError
  MOVE.w  CurrentChunkyBitmap1,d7 ; Store
  MOVE.w  d0,CurrentChunkyBitmap1
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.l  d7,-(a7) ; Store
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCBNotBlock
_MGetaCBBlock
  !ShuffleRegs2
  BSR     _MBlockScrollShapeToBitmapShort
  BRA     _MGetaCBSkip2
_MGetaCBNotBlock
  !ShuffleRegs2
  BSR     _MScrollShapeToBitmapShort
_MGetaCBSkip2
  MOVE.l  (a7)+,d7 ; Restore
  MOVEM.w (a7)+,d0-d6 ; Restore
  MOVE.w  d7,CurrentChunkyBitmap1 ; Restore
  TST.b   CBitmap_AutoStencil
  BEQ     MGetaCBDone
  TST.b   d6 ; Try and grab existing cookie?
  BEQ     _MGetaCBTryMaking
  TST.l   CRsrc_SMem-ChunkyResources(a0) ; Source has cookie?
  BEQ     _MGetaCBTryMaking ; Doesn't have one, so try and make one
  TST.l   CRsrc_SMem-ChunkyResources(a1) ; Dest has stencil?
  BEQ     MGetaCBError2 ; Doesn't have one so can't complete operation
  MOVE.w  CurrentChunkyBitmap1,d7 ; Store
  MOVE.w  d0,CurrentChunkyBitmap1
  MOVEM.w d0-d6,-(a7) ; Store
  MOVE.l  d7,-(a7) ; Store
  TST.b   d5 ; Block routines?
  BEQ     _MGetaCBNotBlock2
_MGetaCBBlock2
  !ShuffleRegs2
  BSR     _MBlockScrollCookieToStencilShort
  BRA     _MGetaCBSkip3
_MGetaCBNotBlock2
  !ShuffleRegs2
  BSR     _MScrollCookieToStencilShort
_MGetaCBSkip3
  MOVE.l  (a7)+,d7 ; Restore
  MOVEM.w (a7)+,d0-d6 ; Restore
  MOVE.w  d7,CurrentChunkyBitmap1 ; Restore
  BRA     MGetaCBDone
_MGetaCBTryMaking
  MOVE.w  d0,-(a7) ; Store
  BSR     _MMakeChunkyBitmapStencil
  MOVE.w  (a7)+,d0 ; Restore
MGetaCBDone
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Return address of data as success
_MGetaCBSkip4
  RTS
MGetaCBError
  MOVEQ.l #0,d0 ; Error
  RTS
MGetaCBError2
  !GetBitmapObjectPtr ; Base in a0
  !DeallocResourceObject{013} ; Kill
  RTS

;*************************************************************************************

_MScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MScroll
;Scroll an area of the bitmap from one place to another, possibly different source bitmap
  !SetupScroll{4,ChunkyBitmap1,ScrollBitmap,5,_MScroll,001}
_MScrollCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollBitmap,5,_MScroll,001}

_MScrollShapeShort
  MOVE.w  CurrentChunkyShape1,d6
_MScrollShape
;Scroll an area of the shape from one place to another, possibly different source shape
  !SetupScroll{4,ChunkyShape1,ScrollShape,5,_MScroll,002}
_MScrollShapeCustom
  !SetupScroll2{4,ChunkyShape1,ScrollShape,5,_MScroll,002}

_MScrollStencilShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MScrollStencil
;Scroll an area of the stencil from one place to another, possibly different source stencil
  !SetupScroll{4,ChunkyBitmap1,ScrollBitmap,6,_MScroll,003}
_MScrollStencilCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollBitmap,6,_MScroll,003}

_MScrollCookieShort
  MOVE.w  CurrentChunkyShape1,d6
_MScrollCookie
;Scroll an area of the cookie from one place to another, possibly different source cookie
  !SetupScroll{4,ChunkyShape1,ScrollShape,6,_MScroll,004}
_MScrollCookieCustom
  !SetupScroll2{4,ChunkyShape1,ScrollShape,6,_MScroll,004}

_MScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MScrollBitmapToShape
;Scroll an area of the bitmap from one place to an area in shape
  !SetupScroll{4,ChunkyShape1,ScrollBitmapToShape,5,_MScroll,005}
_MScrollBitmapToShapeCustom
  !SetupScroll2{4,ChunkyShape1,ScrollBitmapToShape,5,_MScroll,005}

_MScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MScrollShapeToBitmap
;Scroll an area of the shape from one place to an area in a bitmap
  !SetupScroll{4,ChunkyBitmap1,ScrollShapeToBitmap,5,_MScroll,006}
_MScrollShapeToBitmapCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollShapeToBitmap,5,_MScroll,006}

_MScrollStencilToCookieShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MScrollStencilToCookie
;Scroll an area of the stencil from one place to an area in cookie
  !SetupScroll{4,ChunkyShape1,ScrollBitmapToShape,6,_MScroll,007}
_MScrollStencilToCookieCustom
  !SetupScroll2{4,ChunkyShape1,ScrollBitmapToShape,6,_MScroll,007}

_MScrollCookieToStencilShort
  MOVE.w  CurrentChunkyShape1,d6
_MScrollCookieToStencil
;Scroll an area of the cookie from one place to an area in a stencil
  !SetupScroll{4,ChunkyBitmap1,ScrollShapeToBitmap,6,_MScroll,008}
_MScrollCookieToStencilCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollShapeToBitmap,6,_MScroll,008}

_MScrollRoutine
  !ChooseScrollMethod{2,001}
_MScrollRoutine2
  !ChooseScrollMethod2{2,001}

;*************************************************************************************

_MStencilScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MMaskScroll
_MStencilScroll
;Scroll an area of the bitmap from one place to another with stencilling, possibly different source bitmap
  !SetupScroll{1,ChunkyBitmap1,StenScroll,3,_MStenScroll,009}

_MCookieScrollShort
  MOVE.w  CurrentChunkyShape1,d6
_MMaskScrollShape
_MCookieScroll
;Scroll an area of the Shape from one place to another with cookie-cut, possibly different source Shape
  !SetupScroll{1,ChunkyShape1,CookScroll,3,_MStenScroll,010}

_MStencilScrollStencilShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MMaskScrollStencil
_MStencilScrollStencil
;Scroll an area of the stencil from one place to another with stencilling, possibly different source stencil
  !SetupScroll{1,ChunkyBitmap1,StenScroll,4,_MStenScroll,011}

_MCookieScrollCookieShort
  MOVE.w  CurrentChunkyShape1,d6
_MMaskScrollCookie
_MCookieScrollCookie
;Scroll an area of the Shape from one place to another with cookie-cut, possibly different source Shape
  !SetupScroll{1,ChunkyShape1,CookScroll,4,_MStenScroll,012}

_MStencilScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MMaskScrollBitmapToShape
_MStencilScrollBitmapToShape
;Scroll an area of the bitmap from one place to an area in a shape with stencilling
  !SetupScroll{1,ChunkyShape1,StenScrollBitmapToShape,3,_MStenScroll,013}

_MCookieScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MMaskScrollShapeToBitmap
_MCookieScrollShapeToBitmap
;Scroll an area of the Shape from one place to another with cookie-cut, possibly different source Shape
  !SetupScroll{1,ChunkyBitmap1,CookScrollShapeToBitmap,3,_MStenScroll,014}

_MStencilScrollStencilToCookieShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MMaskScrollStencilToCookie
_MStencilScrollStencilToCookie
;Scroll an area of the stencil from one place to an area in a cookie with stencilling
  !SetupScroll{1,ChunkyShape1,StenScrollBitmapToShape,4,_MStenScroll,015}

_MCookieScrollCookieToStencilShort
  MOVE.w  CurrentChunkyShape1,d6
_MMaskScrollCookieToStencil
_MCookieScrollCookieToStencil
;Scroll an area of the Cookie from one place to an area in a stencil with cookie-cut
  !SetupScroll{1,ChunkyBitmap1,CookScrollShapeToBitmap,4,_MStenScroll,016}

_MStenScrollRoutine
  !ChooseScrollMethod{3,002}

;*************************************************************************************

_MBlockScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MBlockScroll
;BlockScroll an area of the bitmap from one place to another, possibly different source bitmap
  !SetupScroll{3,ChunkyBitmap1,ScrollBitmap,5,_MBlockScroll,017}

_MBlockScrollShapeShort
  MOVE.w  CurrentChunkyShape1,d6
_MBlockScrollShape
;BlockScroll an area of the shape from one place to another, possibly different source shape
  !SetupScroll{3,ChunkyShape1,ScrollShape,5,_MBlockScroll,018}

_MBlockScrollStencilShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MBlockScrollStencil
;BlockScroll an area of the stencil from one place to another, possibly different source stencil
  !SetupScroll{3,ChunkyBitmap1,ScrollBitmap,6,_MBlockScroll,019}

_MBlockScrollCookieShort
  MOVE.w  CurrentChunkyShape1,d6
_MBlockScrollCookie
;BlockScroll an area of the cookie from one place to another, possibly different source cookie
  !SetupScroll{3,ChunkyShape1,ScrollShape,6,_MBlockScroll,020}

_MBlockScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MBlockScrollBitmapToShape
;BlockScroll an area of the bitmap from one place to an area in shape
  !SetupScroll{3,ChunkyShape1,ScrollBitmapToShape,5,_MBlockScroll,021}

_MBlockScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MBlockScrollShapeToBitmap
;Scroll an area of the shape from one place to an area in a bitmap
  !SetupScroll{3,ChunkyBitmap1,ScrollShapeToBitmap,5,_MBlockScroll,022}

_MBlockScrollStencilToCookieShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MBlockScrollStencilToCookie
;BlockScroll an area of the stencil from one place to an area in cookie
  !SetupScroll{3,ChunkyShape1,ScrollBitmapToShape,6,_MBlockScroll,023}

_MBlockScrollCookieToStencilShort
  MOVE.w  CurrentChunkyShape1,d6
_MBlockScrollCookieToStencil
;Scroll an area of the cookie from one place to an area in a stencil
  !SetupScroll{3,ChunkyBitmap1,ScrollShapeToBitmap,6,_MBlockScroll,024}

_MBlockScrollRoutine
  !ChooseScrollMethod{4,003}

;*************************************************************************************

_MCPU
;Set the general maximum CPU allowed to use. 0..3=000..030+,4=040+, 6=060. Do not to use a specific cpu if it is not available!
  MOVE.b  d0,SpecificCPUmode ; Store specifics of the cpu
  CMP.b   #4,d0 ; 040+?
  BLT     _MCPUlowCPU2
  MOVE.b  #-1,GeneralCPUmode ; Store general cpu level for 040 toggle on
  RTS
_MCPUlowCPU2
  MOVE.b  #0,GeneralCPUmode ; Store general cpu level for 040 toggle off
  RTS

;*************************************************************************************

_MClsShort
  MOVEQ.l #0,d0
_MCls
;Clearscreen a bitmap to 0 or specified colour
  MOVE.b  d0,d1 ; d1=Colour
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to clear
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JSR     PerformCls
  RTS

;*************************************************************************************

_MClsShapeShort
  MOVEQ.l #0,d0
_MClsShape
;Clearscreen a shape to 0 or specified colour
  MOVE.b  d0,d1 ; d1=Colour
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to clear
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JSR     PerformCls
  RTS

;*************************************************************************************

_MClsStencilShort
  MOVEQ.l #0,d0
_MClsStencil
;Clearscreen a stencil to 0 or specified colour
  MOVE.b  d0,d1 ; d1=Colour
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap that has stencil to clear
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of stencil
  TST.b   d1
  SEQ     d1 ; Make stencil byte value
  MOVE.w  _DrawingModeType,d7
  CMP.w   #4,d7
  BLE     _MClsStencilSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Force MColourMode instead of remapping
  JSR     PerformCls
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MClsStencilSkip
  JSR     PerformCls
  RTS

;*************************************************************************************

_MClsCookieShort
  MOVEQ.l #0,d0
_MClsCookie
;Clearscreen a cookie to 0 or specified colour
  MOVE.b  d0,d1 ; d1=Colour
  MOVE.w  CurrentChunkyShape1,d0 ; Shape that has cookie to clear
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of cookie
  TST.b   d1
  SEQ     d1 ; Make cookie byte value
  MOVE.w  _DrawingModeType,d7
  CMP.w   #4,d7
  BLE     _MClsCookieSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Force MColourMode instead of remapping
  JSR     PerformCls
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MClsCookieSkip
  JSR     PerformCls
  RTS

;*************************************************************************************

_MPlotShort
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MPlot
;Plot a coloured pixel in a bitmap
  MOVE.w  d0,d6 ; Store Xpos
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d1,d7
  ADD.w   d6,a1 ; x
  MOVE.w  _DrawingModeType,d5 ; Get mode
  ADD.l   d7,a1 ; y
  CMP.b   #4,d5 ; What mode?
  BLT     _MPlotInv
  BGT     _MPlotNextMode
_MPlotColour
  MOVE.b  d2,(a1) ; Plot MColourMode
  RTS
_MPlotInv
  NOT.b   (a1) ; Plot InvMode
  RTS
_MPlotNextMode
  CMP.b   #6,d5 ; What mode?
  BLT     _MPlotReMap
  BGT     _MPlotAdd
_MPlotSimpleReMap
  MOVE.w  CurrentChunkyTable1,d0
  !GetTableObjectPtr ; Base in a0
  MOVEQ.l #0,d0 ; init
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; Base of table
  MOVE.b  (a1),d0 ; Get point
  MOVE.b  0(a0,d0.w),(a1) ; Plot SimpleReMap
  RTS
_MPlotReMap
  LSL.w   #8,d2
  MOVE.w  CurrentChunkyTable1,d0
  AND.l   #$0000FF00,d2
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; Base of table
  MOVE.b  (a1),d2 ; Get point
  MOVE.b  0(a0,d2.l),(a1) ; Plot ReMap
  RTS
_MPlotAdd
  ADD.b   d2,(a1) ; Plot Add
  RTS

;*************************************************************************************

_MPlotShapeShort
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MPlotShape
;Plot a coloured pixel in a shape
  MOVE.w  d0,d6 ; Store Xpos
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to plot in
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotShapeSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotShapeSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d1,d7
  ADD.w   d6,a1 ; x
  MOVE.w  _DrawingModeType,d5 ; Get mode
  ADD.l   d7,a1 ; y
  CMP.b   #4,d5 ; What mode?
  BLT     _MPlotShapeInv
  BGT     _MPlotShapeNextMode
_MPlotShapeColour
  MOVE.b  d2,(a1) ; Plot MColourMode
  RTS
_MPlotShapeInv
  NOT.b   (a1) ; Plot InvMode
  RTS
_MPlotShapeNextMode
  CMP.b   #6,d5 ; What mode?
  BLT     _MPlotShapeReMap
  BGT     _MPlotShapeAdd
_MPlotShapeSimpleReMap
  MOVE.w  CurrentChunkyTable1,d0
  !GetTableObjectPtr ; Base in a0
  MOVEQ.l #0,d0 ; init
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; Base of table
  MOVE.b  (a1),d0 ; Get point
  MOVE.b  0(a0,d0.w),(a1) ; Plot SimpleReMap
  RTS
_MPlotShapeReMap
  LSL.w   #8,d2
  MOVE.w  CurrentChunkyTable1,d0
  AND.l   #$0000FF00,d2
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; Base of table
  MOVE.b  (a1),d2 ; Get point
  MOVE.b  0(a0,d2.l),(a1) ; Plot ReMap
  RTS
_MPlotShapeAdd
  ADD.b   d2,(a1) ; Plot Add
  RTS

;*************************************************************************************

_MPlotStencilShort
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MPlotStencil
;Plot a stencil-pixel ($00/$FF) in a stencil
  MOVE.w  d0,d6 ; Copy Xpos
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap that has stencil to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Stencil mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotStencilSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotStencilSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d1,d7
  ADD.w   d6,a1 ; x
  MOVE.w  _DrawingModeType,d5 ; Get mode
  ADD.l   d7,a1 ; y
  CMP.b   #4,d5 ; What mode?
  BLT     _MPlotStencilInv
  ;BGT     _MPlotStencilNextCheck
_MPlotStencilColour
  TST.b   d2
  SEQ.b   d2 ; Prepare stencil byte
  MOVE.b  d2,(a1) ; Plot MColourMode
  RTS
_MPlotStencilInv
  NOT.b   (a1) ; Plot InvMode
  RTS
_MPlotStencilNextCheck
  ; More here, MSimpleReMap, MReMap and MAdd ignored
  RTS

;*************************************************************************************

_MPlotCookieShort
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MPlotCookie
;Plot a cookie-pixel ($00/$FF) in a cookie
  MOVE.l  d0,d6 ; Copy Xpos
  MOVE.w  CurrentChunkyShape1,d0 ; Shape that has cookie to plot in
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Cookie mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotCookieSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotCookieSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7
  MULU    d1,d7
  ADD.w   d6,a1 ; x
  MOVE.w  _DrawingModeType,d5 ; Get mode
  ADD.l   d7,a1 ; y
  CMP.b   #4,d5 ; What mode?
  BLT     _MPlotCookieInv
  ;BGT     _MPlotCookieNextMode
_MPlotCookieColour
  TST.b   d2
  SEQ.b   d2 ; Prepare stencil byte
  MOVE.b  d2,(a1) ; Plot MColourMode
  RTS
_MPlotCookieInv
  NOT.b   (a1) ; Plot InvMode
  RTS
_MPlotCookieNextMode
  ; More modes here. MReMap, MSimpleReMap and MAdd ignored
  RTS

;*************************************************************************************

_MPointShort
  MOVE.w  CurrentChunkyBitmap1,d2 ; Bitmap to read from
_MPoint
;Return the colour of a pixel in a bitmap
  EXG.l   d0,d2 ; Store Xpos
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  !PerformPoint{001}
  RTS

;*************************************************************************************

_MPointShapeShort
  MOVE.w  CurrentChunkyShape1,d2 ; Shape to read from
_MPointShape
;Return the colour of a pixel in a shape
  EXG.l   d0,d2 ; Store Xpos
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  !PerformPoint{002}
  RTS

;*************************************************************************************

_MPointStencilShort
  MOVE.w  CurrentChunkyBitmap1,d2 ; Bitmap that has stencil to read from
_MPointStencil
;Return status of a pixel in a stencil. $FF (-1) = Data, $00 = Background
  EXG.l   d0,d2 ; Copy Xpos
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Stencil mem
  !PerformPoint{003}
  TST.b   d0
  SEQ     d0 ; Prepare stencil byte
  RTS

;*************************************************************************************

_MPointCookieShort
  MOVE.w  CurrentChunkyShape1,d2 ; Shape that has cookie to read from
_MPointCookie
;Return status of a pixel in a cookie. $FF (-1) = Data, $00 = Background
  EXG.l   d0,d2 ; Copy Xpos
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Cookie mem
  !PerformPoint{004}
  TST.b   d0
  SEQ     d0 ; Prepare cookie byte
  RTS

;*************************************************************************************

_MDoubleScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSScroll
_MDoubleScroll
;Scroll an area of the bitmap from one place to an area in another and COPY (overwrite) the stencil from the stencil
  !SetupScroll{4,ChunkyBitmap1,ScrollBitmap,3,_MDoubleScroll,025}
_MDoubleScrollCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollBitmap,3,_MDoubleScroll,025}

_MDoubleScrollShapeShort
  MOVE.w  CurrentChunkyShape1,d6
_MSScrollShape
_MDoubleScrollShape
;Scroll an area of the Shape from one place to an area in another and COPY (overwrite) the cookie from the cookie
  !SetupScroll{4,ChunkyShape1,ScrollShape,3,_MDoubleScroll,026}
_MDoubleScrollShapeCustom
  !SetupScroll2{4,ChunkyShape1,ScrollShape,3,_MDoubleScroll,026}

_MDoubleScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSScrollBitmapToShape
_MDoubleScrollBitmapToShape
;Scroll an area of the bitmap from one place to an area in a shape and COPY (overwrite) the stencil to the cookie
  !SetupScroll{4,ChunkyShape1,ScrollBitmapToShape,3,_MDoubleScroll,027}
_MDoubleScrollBitmapToShapeCustom
  !SetupScroll2{4,ChunkyShape1,ScrollBitmapToShape,3,_MDoubleScroll,027}

_MDoubleScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MSScrollShapeToBitmap
_MDoubleScrollShapeToBitmap
;Scroll an area of the Shape from one place to an area in a bitmap and COPY (overwrite) the cookie to the stencil
  !SetupScroll{4,ChunkyBitmap1,ScrollShapeToBitmap,3,_MDoubleScroll,028}
_MDoubleScrollShapeToBitmapCustom
  !SetupScroll2{4,ChunkyBitmap1,ScrollShapeToBitmap,3,_MDoubleScroll,028}

_MDoubleScrollRoutine
  !ChooseDoubleScrollMethod{5,8,001}
_MDoubleScrollRoutine2
  !ChooseDoubleScrollMethod2{5,8,001}

;*************************************************************************************

_MDoubleStencilScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSMaskScroll
_MDoubleStencilScroll
;Stencil-Scroll an area of the bitmap from one place to an area in another and stencil-copy the stencil from the stencil
  !SetupScroll{1,ChunkyBitmap1,ScrollBitmap,3,_MDoubleStenScroll,029}

_MDoubleCookieScrollShort
  MOVE.w  CurrentChunkyShape1,d6
_MSMaskScrollShape
_MDoubleCookieScroll
;Cookie-Scroll an area of the Shape from one place to an area in another and cookie-copy the cookie from the cookie
  !SetupScroll{1,ChunkyShape1,ScrollShape,3,_MDoubleStenScroll,030}

_MDoubleStencilScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSMaskScrollBitmapToShape
_MDoubleStencilScrollBitmapToShape
;Stencil-Scroll an area of the bitmap from one place to an area in a shape and stencil-copy the stencil to the cookie
  !SetupScroll{1,ChunkyShape1,ScrollBitmapToShape,3,_MDoubleStenScroll,031}

_MDoubleCookieScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MSMaskScrollShapeToBitmap
_MDoubleCookieScrollShapeToBitmap
;Cookie-Scroll an area of the Shape from one place to an area in a bitmap and cookie-copy the cookie to the stencil
  !SetupScroll{1,ChunkyBitmap1,ScrollShapeToBitmap,3,_MDoubleStenScroll,032}

_MDoubleStenScrollRoutine
  !ChooseDoubleScrollMethod{6,9,002}

;*************************************************************************************

_MDoubleBlockScrollShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSBlockScroll
_MDoubleBlockScroll
;BlockScroll an area of the bitmap from one place to an area in another and COPY (overwrite) the stencil from the stencil
  !SetupScroll{3,ChunkyBitmap1,ScrollBitmap,3,_MDoubleBlockScroll,033}

_MDoubleBlockScrollShapeShort
  MOVE.w  CurrentChunkyShape1,d6
_MSBlockScrollShape
_MDoubleBlockScrollShape
;BlockScroll an area of the Shape from one place to an area in another and COPY (overwrite) the cookie from the cookie
  !SetupScroll{3,ChunkyShape1,ScrollShape,3,_MDoubleBlockScroll,034}

_MDoubleBlockScrollBitmapToShapeShort
  MOVE.w  CurrentChunkyBitmap1,d6
_MSBlockScrollBitmapToShape
_MDoubleBlockScrollBitmapToShape
;BlockScroll an area of the bitmap from one place to an area in a shape and COPY (overwrite) the stencil to the cookie
  !SetupScroll{3,ChunkyShape1,ScrollBitmapToShape,3,_MDoubleBlockScroll,035}

_MDoubleBlockScrollShapeToBitmapShort
  MOVE.w  CurrentChunkyShape1,d6
_MSBlockScrollShapeToBitmap
_MDoubleBlockScrollShapeToBitmap
;BlockScroll an area of the Shape from one place to an area in a bitmap and COPY (overwrite) the cookie to the stencil
  !SetupScroll{3,ChunkyBitmap1,ScrollShapeToBitmap,3,_MDoubleBlockScroll,036}

_MDoubleBlockScrollRoutine
  !ChooseDoubleScrollMethod{7,10,003}

;*************************************************************************************
_MSScrollCut
_MDoubleScrollCut
;Set the type of blit to be used in the Double Scroll commands
  MOVE.b  d0,DoubleScrollMode ; Set status
  RTS

;*************************************************************************************
_MUseShapeBank
_MUseChunkyShapeBank
;Set the current bank of ChunkyShapes to use
  MOVE.w  d0,CurrentChunkyShapeBank ; Store
  EXT.l   d0
  LSL.l   #3,d0 ; *8 for offset
  LEA     ChunkyShapeBanks,a0
  ADD.l   d0,a0
  MOVE.l  (a0)+,ChunkyShapesMem ; Copy bank's mem to current
  MOVE.w  (a0),ChunkyShapesTotal ; Copy bank's total to current
  RTS

;*************************************************************************************

_MPictureDissolveIn
;Bring in the second-used bitmap into the first-used bitmap using bitmap design d0, currently colour d1
  MOVE.b  d1,d2 ; Store colour
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a2 ; Picture bitmap
  MOVE.w  CurrentChunkyBitmap2,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  CurrentChunkyBitmap1,d0 ; Source bitmap
  !GetBitmapObjectPtr ; Base in a0 - source
  MOVEM.l a3-a5,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  MOVE.l  CRsrc_Data-ChunkyResources(a2),a5 ; Picture design data
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Source wraps?
  BEQ     _MPictureDINoWrap1
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a3
_MPictureDINoWrap1
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wraps?
  BEQ     _MPictureDINoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a4
_MPictureDINoWrap2
  TST.b   CRsrc_Wrapping-ChunkyResources(a2) ; Picture wraps?
  BEQ     _MPictureDINoWrap3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a2),a5
_MPictureDINoWrap3
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d5 ; Source linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d6 ; Dest linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a2),d7 ; Picture linemod
  TST.b   CRsrc_Clipping-ChunkyResources(a1) ; Clip?
  BEQ     _MPictureDINoClip
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),a3
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a0),d5
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a1),a4
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a1),d6
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a2),a5
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a2),d7
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a1),d0 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a1),d1 ; Height
  BRA     _MPictureDissolveInSkip2
_MPictureDINoClip
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d0 ; Width
  MOVE.w  CRsrc_Height-ChunkyResources(a1),d1 ; Height
_MPictureDissolveInSkip2
  LSR.w   #2,d0 ; Width/4 for longwords
  SUBQ.w  #1,d0 ; XLoopcounter
  MOVE.w  d0,d3 ; Copy XLoop
  SUBQ.w  #1,d1 ; YLoopcounter
  MOVEQ.l #4,d4 ; Temp skip value
_MPictureDIYLoop
    MOVE.w  d3,d0 ; Copy XLoop
_MPictureDIXLoop
      CMP.b   (a5)+,d2
      BNE     _MPictureDIJump1
      MOVE.b  (a3),(a4)
_MPictureDIJump1
      CMP.b   (a5)+,d2
      BNE     _MPictureDIJump2
      MOVE.b  1(a3),1(a4)
_MPictureDIJump2
      CMP.b   (a5)+,d2
      BNE     _MPictureDIJump3
      MOVE.b  2(a3),2(a4)
_MPictureDIJump3
      CMP.b   (a5)+,d2
      BNE     _MPictureDIJump4
      MOVE.b  3(a3),3(a4)
_MPictureDIJump4
      ADD.w   d4,a3
      ADD.w   d4,a4
      DBRA    d0,_MPictureDIXLoop
    ADD.w   d5,a3 ; Source linemod
    ADD.w   d6,a4 ; Dest linemod
    ADD.w   d7,a5 ; Picture linemod
    DBRA    d1,_MPictureDIYLoop
  MOVEM.l (a7)+,a3-a5 ; Restore
_MPictureDissolveInSkip
  RTS

;*************************************************************************************

_MSScrollModeShort
  MOVE.w  SScrollModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MMaskScrollMode
_MSScrollMode
;Set blit mode type for StencilScroll and CcookieScroll
  CMP.w   #8,d0 ; Direct?
  BGE     _MSScrollModeJump
  MOVE.w  d0,SScrollModeType ; Directly copy type number
  RTS
_MSScrollModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MSScrollModeSkip
  MOVE.w  #0,SScrollModeType ; Store type for CookieMode
  RTS
_MSScrollModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MSScrollModeSkip2
  MOVE.w  #1,SScrollModeType ; Store type for EraseMode
  RTS
_MSScrollModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MSScrollModeSkip3
  MOVE.w  #2,SScrollModeType ; Store type for InvMode
  RTS
_MSScrollModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MSScrollModeSkip4
  MOVE.w  #3,SScrollModeType ; Store type for SolidMode
  RTS
_MSScrollModeSkip4
  RTS

;*************************************************************************************

_MBlitModeShort
  MOVE.w  _BlitModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MBlitMode
;Set blit mode type for `MBlit'
  CMP.w   #8,d0 ; Direct?
  BGE     _MBlitModeJump
  MOVE.w  d0,_BlitModeType ; Directly copy type number
  RTS
_MBlitModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MBlitModeSkip
  MOVE.w  #0,_BlitModeType ; Store type for CookieMode
  RTS
_MBlitModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MBlitModeSkip2
  MOVE.w  #1,_BlitModeType ; Store type for EraseMode
  RTS
_MBlitModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MBlitModeSkip3
  MOVE.w  #2,_BlitModeType ; Store type for InvMode
  RTS
_MBlitModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MBlitModeSkip4
  MOVE.w  #3,_BlitModeType ; Store type for SolidMode
  RTS
_MBlitModeSkip4
  RTS

;*************************************************************************************

_MBlitShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MBlit
;Scroll a whole Shape to a Bitmap
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVEM.l a3/a4,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MBlitNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MBlitNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  MOVE.w  _BlitModeType,d0
  BSR     PerformBlit1 ; Blit forwards
  MOVEM.l (a7)+,a3/a4 ; Restore
  RTS

;*************************************************************************************

_MBlockShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MBlock
;Block-Scroll a whole Shape to a Bitmap
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MBlockNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MBlockNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  AND.b   #$F0,d1 ; Align X
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  BSR     PerformGenericBlit4 ; Block-Blit forwards
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MTile16x16Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MTile16x16
  AND.b   #$F0,d1 ; Align X
  AND.b   #$F0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTile16x16NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MTile16x16NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  SUB.w   #16,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVEQ.l #16-1,d4 ; OpHeight-1 for y loop on 030
  JSR     PerformTile16x16 ; Block-Blit forwards
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MTile32x32Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MTile32x32
  AND.b   #$E0,d1 ; Align X
  AND.b   #$E0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTile32x32NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MTile32x32NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  SUB.w   #32,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVEQ.l #32-1,d4 ; OpHeight for y loop on 030
  JSR     PerformTile32x32 ; Block-Blit forwards
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MDoubleTile16x16Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSTile16x16
_MDoubleTile16x16
  AND.b   #$F0,d1 ; Align X
  AND.b   #$F0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVEM.l a3-a5,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source cookie
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleTile16x16NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleTile16x16NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  SUB.w   #16,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  JSR     PerformDoubleTile16x16 ; Block-Blit forwards
  MOVEM.l  (a7)+,a3-a5 ; Restore
  RTS

;*************************************************************************************

_MDoubleTile32x32Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSTile32x32
_MDoubleTile32x32
  AND.b   #$E0,d1 ; Align X
  AND.b   #$E0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVEM.l a3-a5,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source cookie
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleTile32x32NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleTile32x32NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  SUB.w   #32,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  JSR     PerformDoubleTile32x32 ; Block-Blit forwards
  MOVEM.l (a7)+,a3-a5 ; Restore
  RTS

;*************************************************************************************

_MTripleTile16x16Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSTile16x16Store
_MTripleTile16x16
  AND.b   #$F0,d1 ; Align X
  AND.b   #$F0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  CurrentChunkyBitmap2,d0 ; Store resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a6 ; Store bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source cookie
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTripleTile16x16NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MTripleTile16x16NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d4
  ADD.w   d4,d0
  MOVE.w  d2,d5 ; Store for later
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  SUB.w   #16,d4 ; extra linemod
  ADD.w   d4,d7 ; dest
  MOVE.l  CRsrc_Data-ChunkyResources(a6),a0 ; Store's data
  MOVE.w  CRsrc_Width-ChunkyResources(a6),d3
  MOVE.w  CRsrc_LineMod-ChunkyResources(a6),d0
  ADD.w   d3,d0
  MULU    d0,d5
  ADD.w   d1,a0 ; Store's coordinate offset
  ADD.l   d5,a0 ; X2,Y2 in store data
  SUB.w   #16,d3 ; extra linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a6),d5 ; Store's linemod
  ADD.w   d3,d5 ; dest
  TST.b   CRsrc_Wrapping-ChunkyResources(a6) ; Store wraps?
  BEQ     _MTripleTile16x16NoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a6),a0
_MTripleTile16x16NoWrap2
  JSR     PerformTripleTile16x16 ; Block-Blit forwards
  MOVEM.l  (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MTripleTile32x32Short
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSTile32x32Store
_MTripleTile32x32
  AND.b   #$E0,d1 ; Align X
  AND.b   #$E0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  CurrentChunkyBitmap2,d0 ; Store resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a6 ; Store bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source cookie
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTripleTile32x32NoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MTripleTile32x32NoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d4
  ADD.w   d4,d0
  MOVE.w  d2,d5 ; Store for later
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  SUB.w   #32,d4 ; extra linemod
  ADD.w   d4,d7 ; dest
  MOVE.l  CRsrc_Data-ChunkyResources(a6),a0 ; Store's data
  MOVE.w  CRsrc_Width-ChunkyResources(a6),d3
  MOVE.w  CRsrc_LineMod-ChunkyResources(a6),d0
  ADD.w   d3,d0
  MULU    d0,d5
  ADD.w   d1,a0 ; Store's coordinate offset
  ADD.l   d5,a0 ; X2,Y2 in store data
  SUB.w   #32,d3 ; extra linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a6),d5 ; Store's linemod
  ADD.w   d3,d5 ; dest
  TST.b   CRsrc_Wrapping-ChunkyResources(a6) ; Store wraps?
  BEQ     _MTripleTile32x32NoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a6),a0
_MTripleTile32x32NoWrap2
  JSR     PerformTripleTile32x32 ; Block-Blit forwards
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MTile16x16TwiceShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MTile16x16Store
_MTile16x16Twice
  AND.b   #$F0,d1 ; Align X
  AND.b   #$F0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVEM.l a3/a4,-(a7) ; Store
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  CurrentChunkyBitmap2,d0 ; Store resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a4 ; Store bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTile16x16TwiceNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MTile16x16TwiceNoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d4
  ADD.w   d4,d0
  MOVE.w  d2,d5 ; Store for later
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  SUB.w   #16,d4 ; extra linemod
  ADD.w   d4,d7 ; dest
  MOVE.l  CRsrc_Data-ChunkyResources(a4),a0 ; Store's data
  MOVE.w  CRsrc_Width-ChunkyResources(a4),d3
  MOVE.w  CRsrc_LineMod-ChunkyResources(a4),d0
  ADD.w   d3,d0
  MULU    d0,d5
  ADD.w   d1,a0 ; Store's coordinate offset
  ADD.l   d5,a0 ; X2,Y2 in store data
  SUB.w   #16,d3 ; extra linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a4),d5 ; Store's linemod
  ADD.w   d3,d5 ; dest
  TST.b   CRsrc_Wrapping-ChunkyResources(a4) ; Store wraps?
  BEQ     _MTile16x16TwiceNoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a4),a0
_MTile16x16TwiceNoWrap2
  JSR     PerformTile16x16Twice ; Block-Blit forwards
  MOVEM.l (a7)+,a3/a4 ; Restore
  RTS

;*************************************************************************************

_MTile32x32TwiceShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MTile32x32Store
_MTile32x32Twice
  AND.b   #$E0,d1 ; Align X
  AND.b   #$E0,d2 ; Align Y
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVEM.l a3-a4,-(a7) ; Store
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  CurrentChunkyBitmap2,d0 ; Store resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a4 ; Store bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MTile32x32TwiceNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MTile32x32TwiceNoWrap
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d4
  ADD.w   d4,d0
  MOVE.w  d2,d5 ; Store for later
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  SUB.w   #32,d4 ; extra linemod
  ADD.w   d4,d7 ; dest
  MOVE.l  CRsrc_Data-ChunkyResources(a4),a0 ; Store's data
  MOVE.w  CRsrc_Width-ChunkyResources(a4),d3
  MOVE.w  CRsrc_LineMod-ChunkyResources(a4),d0
  ADD.w   d3,d0
  MULU    d0,d5
  ADD.w   d1,a0 ; Store's coordinate offset
  ADD.l   d5,a0 ; X2,Y2 in store data
  SUB.w   #32,d3 ; extra linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a4),d5 ; Store's linemod
  ADD.w   d3,d5 ; dest
  TST.b   CRsrc_Wrapping-ChunkyResources(a4) ; Store wraps?
  BEQ     _MTile32x32TwiceNoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a4),a0
_MTile32x32TwiceNoWrap2
  JSR     PerformTile32x32Twice ; Block-Blit forwards
  MOVEM.l (a7)+,a3-a4 ; Restore
  RTS

;*************************************************************************************
_MReserveQueues
_MReserveChunkyQueues
;Reserve memory for ChunkyQueue structures
  MOVE.l  d0,d7
  TST.l   ChunkyQueuesMem ; Check for existing mem allocated
  BEQ     ReserveChunkyQskip ; If exists, deallocate
  MOVE.w  ChunkyQueuesTotal,d0
  EXT.l   d0
  LSL.l   #ChunkyQueueStructSize,d0
  MOVE.l  ChunkyQueuesMem,a1
  ALibJsr #BlitzFreemem ; Free memory
  MOVE.l  d7,d0
  MOVE.w  #0,ChunkyQueuesTotal
  MOVE.l  #0,ChunkyQueuesMem
ReserveChunkyQskip
  AND.l   #$FFFF,d0
  MOVE.w  d0,d7
  LSL.l   #ChunkyQueueStructSize,d0
  MOVE.l  #ClearPublicMem,d1 ; MemType (public and clear)
  !CheckAvailMem{004}
  TST.b   d2 ; Likely?
  BEQ     ReserveChunkyQfailed
  ALibJsr #BlitzAllocmem ; Allocate memory
  TST.l   d0
  BEQ     ReserveChunkyQfailed
  MOVE.l  d0,ChunkyQueuesMem
  MOVE.w  d7,ChunkyQueuesTotal
  RTS     ; Return memory address in d0.l
ReserveChunkyQfailed
  MOVEQ.l #0,d0 ; Errorcode
  RTS

;*************************************************************************************

_MFreeChunkyQueuesRange
;Free a range of ChunkyQueue objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCQRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyQueue ; Free it
  DBRA    d7,FreeCQRloop
  RTS
_MFreeQueues
_MFreeChunkyQueues
;Free all ChunkyQueue objects
  MOVE.w  ChunkyQueuesTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCQloop
  MOVE.w  d7,d0
  BSR     _MFreeChunkyQueue ; Free it
  DBRA    d7,FreeCQloop
FreeCQsSkip
  RTS
_MFreeQueue
_MFreeChunkyQueue
;Free a single ChunkyQueue object
  !GetQueueObjectPtr ; Get base of struct in a0
_MFreeChunkyQueueEntry
  MOVE.l  d0,-(a7) ; Store
  TST.l   CQueue_LMem-ChunkyResources(a0) ; List memory exist?
  BEQ     FreeQNoList
  MOVE.l  CQueue_LBytes-ChunkyQueues(a0),d0 ; Size
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free data memory
FreeQNoList
  MOVE.l  #0,CQueue_LMem-ChunkyQueues(a0) ; Wipe LMem to indicate dead structure
  MOVE.l  (a7)+,d0 ; Restore
  RTS

;*************************************************************************************
_MAddrChunkyQueueShort
  MOVE.w  CurrentChunkyQueue1,d0
_MAddrQueue
_MAddrChunkyQueue
;Returns the address of the specified ChunkyQueue structure
  !GetQueueObjectPtr ; In a0
  MOVE.l  a0,d0 ; Return address
  RTS

;*************************************************************************************
_MQueue
_MChunkyQueue
;Initialise a new ChunkyQueue object
  !GetQueueObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  MOVE.w  d0,d7 ; Store
  EXT.l   d1
  MOVE.w  d1,d0
  TST.l   CQueue_LMem-ChunkyQueues(a0) ; Has mem?
  BEQ     _MChunkyQSkip
  BSR     _MFreeChunkyQueueEntry ; Deallocate existing data
_MChunkyQSkip
  MOVE.w  d0,CQueue_MaxItems-ChunkyQueues(a0) ; Total number of items allowed
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; Number of actual items
  LSL.l   #ChunkyQueueListStructSize,d0
  MOVE.l  d0,CQueue_LBytes-ChunkyQueues(a0)
  !NewChunkyMem{007} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     _MChunkyQFailed
  MOVE.l  d0,CQueue_LMem-ChunkyQueues(a0)
  MOVE.l  d0,CQueue_ItemAddr-ChunkyQueues(a0) ; Address of current item
  TST.b   AutoChunkyQueuesUse ; Use it?
  BEQ     _MChunkyQDontUse ; No
  MOVE.w  d7,CurrentChunkyQueue1 ; Yes, store queue number in current
_MChunkyQDontUse
  RTS     ; Successful, return

_MChunkyQFailed
  MOVEQ.l #0,d0
  MOVE.l  #0,CQueue_LMem-ChunkyQueues(a0)
  RTS     ; Return errorcode in d0

;*************************************************************************************
_MFlushQueue
_MFlushChunkyQueue
;Empty the contents of a queue as if ignoring its contents
  !GetQueueObjectPtr ; base in a0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),CQueue_ItemAddr-ChunkyQueues(a0) ; Init queue
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; No items
  RTS

;*************************************************************************************

_MQBlitModeShort
  MOVE.w  _QBlitModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MQBlitMode
;Set blit mode type for `MQBlit'
  CMP.w   #8,d0 ; Direct?
  BGE     _MQBlitModeJump
  MOVE.w  d0,_QBlitModeType ; Directly copy type number
  RTS
_MQBlitModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MQBlitModeSkip
  MOVE.w  #0,_QBlitModeType ; Store type for CookieMode
  RTS
_MQBlitModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MQBlitModeSkip2
  MOVE.w  #1,_QBlitModeType ; Store type for EraseMode
  RTS
_MQBlitModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MQBlitModeSkip3
  MOVE.w  #2,_QBlitModeType ; Store type for InvMode
  RTS
_MQBlitModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MQBlitModeSkip4
  MOVE.w  #3,_QBlitModeType ; Store type for SolidMode
  RTS
_MQBlitModeSkip4
  RTS

;*************************************************************************************
_MAutoUseQueues
_MAutoUseChunkyQueues
  MOVE.b  d0,AutoChunkyQueuesUse
  RTS

;*************************************************************************************
_MUseQueue
_MUseChunkyQueue
;Set the currently used ChunkyQueues
  MOVE.w  d2,CurrentChunkyQueue3
_MUseChunkyQueueShort
  MOVE.w  d1,CurrentChunkyQueue2
_MUseChunkyQueueShortest
  MOVE.w  d0,CurrentChunkyQueue1
  RTS

;*************************************************************************************
_MUsedQueue
_MUsedChunkyQueue
;Returns number of main currently used ChunkyQueue, or likely -1 if not defined
  MOVE.w  CurrentChunkyQueue1,d0
  RTS

;*************************************************************************************

_MQBlitShortest
  MOVE.w  d1,d3
  MOVE.w  d0,d2
  MOVE.w  CurrentChunkyShape1,d1
  MOVE.w  CurrentChunkyQueue1,d0
  BRA     _MQBlit
_MQBlitShort
  MOVE.w  d2,d3
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyQueue1,d0
_MQBlit
;Scroll a whole Shape to a Bitmap and add entry to a queue
  !GetQueueObjectPtr ; base in a0
  MOVEM.l a3/a4/a6,-(a7) ; Store
  MOVE.l  CQueue_ItemAddr-ChunkyQueues(a0),a6 ; New item position
  ADD.w   #1,CQueue_Items-ChunkyQueues(a0) ; Items+1
  ADD.l   #ChunkyQueueListStructBytes,CQueue_ItemAddr-ChunkyQueues(a0) ; Incrememt address
  MOVE.w  d1,d7 ; Store shape
  MOVE.w  d2,d1
  MOVE.w  d3,d2
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0 ; shape
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MQBlitNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MQBlitNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  MOVE.w  d7,d0 ; Temp modulo
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  EXT.l   d1
  ADD.l   d1,d2
  EXT.l   d7
  MOVE.l  a3,(a6)+ ; Store queue list entry - Dest address
  MOVE.w  d3,(a6)+ ; Store queue list entry - OpWidth
  MOVE.w  d4,(a6)+ ; Store queue list entry - OpHeight
  MOVE.l  d7,(a6)+ ; Store queue list entry - Dest linemod
  MOVE.l  d2,(a6)  ; Store queue list entry - XYbytes not including wrap
  MOVE.w  _QBlitModeType,d0
  BSR     PerformBlit1 ; Blit forwards
  MOVEM.l (a7)+,a3/a4/a6 ; Restore
  RTS

;*************************************************************************************

_MQBlockShortest
  MOVE.w  d1,d3
  MOVE.w  d0,d2
  MOVE.w  CurrentChunkyShape1,d1
  MOVE.w  CurrentChunkyQueue1,d0
  BRA     _MQBlock
_MQBlockShort
  MOVE.w  d2,d3
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyQueue1,d0
_MQBlock
;Block-Scroll a whole Shape to a Bitmap and add entry to a queue
  !GetQueueObjectPtr ; base in a0
  MOVEM.l a3/a6,-(a7) ; Store
  MOVE.l  CQueue_ItemAddr-ChunkyQueues(a0),a6 ; New item position
  ADD.w   #1,CQueue_Items-ChunkyQueues(a0) ; Items+1
  ADD.l   #ChunkyQueueListStructBytes,CQueue_ItemAddr-ChunkyQueues(a0) ; Increment address
  MOVE.w  d1,d7 ; Store shape
  MOVE.w  d2,d1
  MOVE.w  d3,d2
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0 ; shape
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MQBlockNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MQBlockNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  AND.b   #$F0,d1 ; Align X
  MOVE.w  d7,d0 ; Temp modulo
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  EXT.l   d1
  ADD.l   d1,d2
  EXT.l   d7
  MOVE.l  a3,(a6)+ ; Store queue list entry - Dest address
  MOVE.w  d3,(a6)+ ; Store queue list entry - OpWidth
  MOVE.w  d4,(a6)+ ; Store queue list entry - OpHeight
  MOVE.l  d7,(a6)+ ; Store queue list entry - Dest linemod
  MOVE.l  d2,(a6)  ; Store queue list entry - XYbytes not including wrap
  BSR     PerformGenericBlit4 ; Block-Blit forwards
  MOVEM.l (a7)+,a3/a6 ; Restore
  RTS

;*************************************************************************************

_MUnQueueRangeShort
;UnQueue a range of the queued objects to the dest bitmap by way of a clearscreen
  !GetQueueObjectPtr ; Base in a0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  SUB.w   d1,d2 ; Find loopcounter
  EXT.l   d1
  LSL.l   #ChunkyQueueListStructSize,d1 ; Offset
  ADD.l   d1,a1 ; Find list item in queue
  MOVE.w  d2,d1 ; Position
  BRA     _MUnQueueShortEntry
_MUnQueueShort
;UnQueue the queued objects to the dest bitmap by way of a clearscreen
  !GetQueueObjectPtr ; Base in a0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  MOVE.w  CQueue_Items-ChunkyQueues(a0),d1 ; Number of items
  SUBQ.w  #1,d1 ; QueueItemLoopcounter
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; Empty
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),CQueue_ItemAddr-ChunkyQueues(a0) ; Empty
_MUnQueueShortEntry
  MOVE.b  CurrentInk1,d4
  MOVE.b  d4,d6
  LSL.w   #8,d6
  MOVE.b  d4,d6
  SWAP    d6
  MOVE.b  d4,d6
  LSL.w   #8,d6
  MOVE.b  d4,d6 ; Colour to draw to (repeated 4 times)
_MUnQueueClsLoop
    MOVE.l  (a1)+,a0 ; Dest address
    MOVE.w  (a1)+,d2 ; Width
    MOVE.w  (a1)+,d3 ; Height
    MOVE.w  d2,d4 ; Copy width
    MOVE.w  d3,d5 ; Copy height
    MOVE.l  (a1)+,d7 ; LineModulo
    LSR.w   #2,d4 ; /4 for longwords
    SUBQ.w  #1,d5 ; YLoopcounter
    ADD.w   #ChunkyQueueListStructBytes-12,a1 ; Skip to next item
    SUBQ.w  #1,d4 ; XLoopcounter
_MUnQueueClsYLoop
      MOVE.w  d4,d2 ; XLoop
_MUnQueueClsXLoop
        MOVE.l  d6,(a0)+
        DBRA    d2,_MUnQueueClsXLoop
      ADD.w d7,a0
      DBRA    d5,_MUnQueueClsYLoop
    DBRA    d1,_MUnQueueClsLoop
  RTS

_MUnQueueRange
;UnQueue a range of queued objects to the dest bitmap by way of a bitmap rubthrough
  !GetQueueObjectPtr ; Base in a0
  MOVE.w  d3,d0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  SUB.w   d1,d2 ; Find loopcounter
  EXT.l   d1
  LSL.l   #ChunkyQueueListStructSize,d1 ; Offset
  ADD.l   d1,a1 ; Find list item in queue
  MOVE.w  d2,d1 ; Position
  BRA     _MUnQueueEntry
_MUnQueue
;UnQueue the queued objects to the dest bitmap by way of a bitmap rubthrough
  !GetQueueObjectPtr ; Base in a0
  MOVE.w  d1,d0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  MOVE.w  CQueue_Items-ChunkyQueues(a0),d1 ; Number of items
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; Empty
  SUBQ.w  #1,d1 ; QueueItemLoopcounter
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),CQueue_ItemAddr-ChunkyQueues(a0) ; Empty
_MUnQueueEntry
  !GetBitmapObjectPtr ; Base in a0 - bitmap to use
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d5 ; Source Data
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MUnQueueNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d5
_MUnQueueNoWrap
  MOVE.l  a3,-(a7) ; Store
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),a3
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d4
_MUnQueueBitmapLoop
    MOVE.l  (a1)+,a0 ; Dest address
    MOVE.w  d4,d6 ; Copy source width
    MOVE.w  (a1)+,d2 ; Width
    MOVE.l  d5,a2 ; Source base
    MOVE.b  d2,d7 ; Copy Width
    MOVE.w  (a1)+,d3 ; Height
    AND.b   #$0F,d7 ; Mask Width for multiple of 16
    BEQ     _MUnQueueBitmap16
    SUB.w   d2,d6 ; Modulo
    MOVE.l  (a1)+,d7 ; Dest LineModulo
    SUBQ.w  #1,d3 ; YLoopcounter
    LSR.w   #2,d2 ; Width/4 for longwords
    ADD.l   (a1)+,a2 ; Position source
    SUBQ.w  #1,d2 ; XLoopcounter
    ADD.w   a3,d6 ; Total modulo
_MUnQueueBitmapYLoop
      MOVE.w  d2,d0 ; XLoop
_MUnQueueBitmapXLoop
        MOVE.l  (a2)+,(a0)+ ; Copy data
        DBRA  d0,_MUnQueueBitmapXLoop
      ADD.w d6,a2 ; Source linemod to data
      ADD.w d7,a0 ; Dest linemod to data
      DBRA  d3,_MUnQueueBitmapYLoop
    DBRA  d1,_MUnQueueBitmapLoop
  MOVE.l (a7)+,a3 ; Restore
  RTS;pop
_MUnQueueBitmap16
    SUB.w   d2,d6 ; Modulo
    MOVE.l  (a1)+,d7 ; Dest LineModulo
    SUBQ.w  #1,d3 ; YLoopcounter
    LSR.w   #4,d2 ; Width/16 for groups of 4 longwords
    ADD.l   (a1)+,a2 ; Position source
    SUBQ.w  #1,d2 ; XLoopcounter
    ADD.w   a3,d6 ; Total modulo
_MUnQueueBitmap16YLoop
      MOVE.w  d2,d0 ; XLoop
_MUnQueueBitmap16XLoop
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data
        DBRA  d0,_MUnQueueBitmap16XLoop
      ADD.w d6,a2 ; Source linemod to data
      ADD.w d7,a0 ; Dest linemod to data
      DBRA  d3,_MUnQueueBitmap16YLoop
    DBRA  d1,_MUnQueueBitmapLoop
  MOVE.l (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MBitmapPtrAssume
  MOVE.w  CurrentChunkyBitmap1,d0
_MBitmapPtrShortest
  !GetBitmapObjectPtr ; Base in a0
_MBitmapPtrShortestEntry
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Chunky base address
_MBitmapPtrShortestEntry2
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MBitmapPtrSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d0 ; Add wrap bytes
_MBitmapPtrSkip
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip offset?
  BEQ     _MBitmapPtrSkip2
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),d0 ; Add clip bytes
_MBitmapPtrSkip2
  RTS     ; Return address in d0.l
_MBitmapPtrShort
  MOVE.w  CurrentChunkyBitmap1,d2
_MBitmapPtr
;Return a pointer based on a bitmap, for use as the Chunky.l source of c2p() operation
  EXG.l   d0,d2 ; d2=xpos
  !GetBitmapObjectPtr ; Base in a0
_MBitmapPtrEntry
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d0 ; Chunky base address
_MBitmapPtrEntry2
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MBitmapPtrSkip3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d0 ; Add wrap bytes
_MBitmapPtrSkip3
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip offset?
  BEQ     _MBitmapPtrSkip4
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),d0 ; Add clip bytes
_MBitmapPtrSkip4
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d3
  MULU    d3,d1
  EXT.l   d2
  ADD.l   d2,d0
  ADD.l   d1,d0
  RTS     ; Return address in d0.l

;*************************************************************************************

_MShapePtrAssume
  MOVE.w  CurrentChunkyShape1,d0
_MShapePtrShortest
  !GetShapeObjectPtr ; Base in a0
  BRA     _MBitmapPtrShortestEntry

_MShapePtrShort
  MOVE.w  CurrentChunkyShape1,d2
_MShapePtr
  EXG.l   d0,d2 ; d2=xpos
  !GetShapeObjectPtr ; Base in a0
  BRA     _MBitmapPtrEntry

  RTS ; Precauton, but wont be taken

;*************************************************************************************

_MStencilPtrAssume
  MOVE.w  CurrentChunkyBitmap1,d0
_MStencilPtrShortest
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),d0 ; Stencil base address
  BRA     _MBitmapPtrShortestEntry2

_MStencilPtrShort
  MOVE.w  CurrentChunkyBitmap1,d2
_MStencilPtr
  EXG.l   d0,d2 ; d2=xpos
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),d0 ; Stencil base address
  BRA     _MBitmapPtrEntry2

  RTS ; Precauton, but wont be taken

;*************************************************************************************

_MCookiePtrAssume
  MOVE.w  CurrentChunkyShape1,d0
_MCookiePtrShortest
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),d0 ; Stencil base address
  BRA     _MBitmapPtrShortestEntry2

_MCookiePtrShort
  MOVE.w  CurrentChunkyShape1,d2
_MCookiePtr
  EXG.l   d0,d2 ; d2=xpos
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),d0 ; Stencil base address
  BRA     _MBitmapPtrEntry2

  RTS ; Precauton, but wont be taken

;*************************************************************************************

_MQDummyShort
  MOVE.w  d3,d4
  MOVE.w  d2,d3
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyQueue1,d0
_MQDummy
;Add an entry to a queue without doing a blit
  EXG.l   d3,d1
  !RoundUpWidth{011}
  EXG.l   d3,d1
  MOVE.l  a3,-(a7) ; Store
  !GetQueueObjectPtr ; base in a0
  MOVE.l  CQueue_ItemAddr-ChunkyQueues(a0),a2 ; New item position
  ADD.w   #1,CQueue_Items-ChunkyQueues(a0) ; Items+1
  ADD.l   #ChunkyQueueListStructBytes,CQueue_ItemAddr-ChunkyQueues(a0) ; Incrememt address
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; dest data
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Dest wrap?
  BEQ     _MQDummyNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a3
_MQDummyNoWrap
  MOVE.w  d7,d0 ; Temp modulo
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  EXT.l   d1
  ADD.l   d1,d2
  EXT.l   d7
  MOVE.l  a3,(a2)+ ; Store queue list entry - Dest address
  MOVE.w  d3,(a2)+ ; Store queue list entry - OpWidth
  MOVE.w  d4,(a2)+ ; Store queue list entry - OpHeight
  MOVE.l  d7,(a2)+ ; Store queue list entry - Dest linemod
  MOVE.l  d2,(a2)  ; Store queue list entry - XYbytes not including wrap
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MDoubleBlitModeShort
  MOVE.w  _DoubleBlitModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MSBlitMode
_MDoubleBlitMode
;Set blit mode type for `MDoubleBlit'
  CMP.w   #8,d0 ; Direct?
  BGE     _MDoubleBlitModeJump
  MOVE.w  d0,_DoubleBlitModeType ; Directly copy type number
  RTS
_MDoubleBlitModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MDoubleBlitModeSkip
  MOVE.w  #0,_DoubleBlitModeType ; Store type for CookieMode
  RTS
_MDoubleBlitModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MDoubleBlitModeSkip2
  MOVE.w  #1,_DoubleBlitModeType ; Store type for EraseMode
  RTS
_MDoubleBlitModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MDoubleBlitModeSkip3
  MOVE.w  #2,_DoubleBlitModeType ; Store type for InvMode
  RTS
_MDoubleBlitModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MDoubleBlitModeSkip4
  MOVE.w  #3,_DoubleBlitModeType ; Store type for SolidMode
  RTS
_MDoubleBlitModeSkip4
  RTS

;*************************************************************************************

_MDoubleBlitShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSBlit
_MDoubleBlit
;Scroll a whole Shape to a Bitmap and copy the cookie to the stencil
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVEM.l a3-a5,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleBlitNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleBlitNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  MOVE.w  _DoubleBlitModeType,d0
  TST.b   DoubleBlitMode ; What type of blit?
  BNE     _MDoubleBlitSkip
  BSR     PerformBlit2 ; Blit forwards, paste cookie to stencil
  BRA     _MDoubleBlitSkip2
_MDoubleBlitSkip
  BSR     PerformBlit3 ; Blit forwards, cut using cookie and stencil
_MDoubleBlitSkip2
  MOVEM.l (a7)+,a3-a5 ; Restore
  RTS

;*************************************************************************************

_MDoubleBlockShort
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyShape1,d0
_MSBlock
_MDoubleBlock
;Block-Scroll a whole Shape to a Bitmap and copy the cookie to the stencil
  MOVE.w  d0,d7 ; Store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVEM.l a3-a5,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleBlockNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleBlockNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  AND.b   #$F0,d1 ; Align X
  MOVE.w  d7,d0 ; Temp
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a5 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  TST.b   DoubleBlitMode
  BNE     _MDoubleBlockSkip
  BSR     PerformGenericBlit7 ; Block-Blit forwards, paste cookie to stencil
  BRA     _MDoubleBlockSkip2
_MDoubleBlockSkip
  BSR     PerformGenericBlit10 ; Block-Blit forwards, cut using cookie and stencil
_MDoubleBlockSkip2
  MOVEM.l (a7)+,a3-a5 ; Restore
  RTS

;*************************************************************************************
_MSBlitCut
_MDoubleBlitCut
;Set the type of blit to be used in the Double Blit commands
  MOVE.b  d0,DoubleBlitMode ; Set status
  RTS

;*************************************************************************************

_MDoubleQBlitModeShort
  MOVE.w  _DoubleQBlitModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MQSBlitMode
_MDoubleQBlitMode
;Set blit mode type for `MDoubleQBlit'
  CMP.w   #8,d0 ; Direct?
  BGE     _MDoubleQBlitModeJump
  MOVE.w  d0,_DoubleQBlitModeType ; Directly copy type number
  RTS
_MDoubleQBlitModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MDoubleQBlitModeSkip
  MOVE.w  #0,_DoubleQBlitModeType ; Store type for CookieMode
  RTS
_MDoubleQBlitModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MDoubleQBlitModeSkip2
  MOVE.w  #1,_DoubleQBlitModeType ; Store type for EraseMode
  RTS
_MDoubleQBlitModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MDoubleQBlitModeSkip3
  MOVE.w  #2,_DoubleQBlitModeType ; Store type for InvMode
  RTS
_MDoubleQBlitModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MDoubleQBlitModeSkip4
  MOVE.w  #3,_DoubleQBlitModeType ; Store type for SolidMode
  RTS
_MDoubleQBlitModeSkip4
  RTS

;*************************************************************************************

_MDoubleQBlitShortest
  MOVE.w  d1,d3
  MOVE.w  d0,d2
  MOVE.w  CurrentChunkyShape1,d1
  MOVE.w  CurrentChunkyQueue1,d0
  BRA     _MDoubleQBlit
_MDoubleQBlitShort
  MOVE.w  d2,d3
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyQueue1,d0
_MQSBlit
_MDoubleQBlit
;Scroll a whole Shape to a Bitmap, cookie to stencil, and add entry to a queue
  !GetQueueObjectPtr ; base in a0
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  CQueue_ItemAddr-ChunkyQueues(a0),a6 ; New item position
  ADD.w   #1,CQueue_Items-ChunkyQueues(a0) ; Items+1
  ADD.l   #ChunkyQueueListStructBytes,CQueue_ItemAddr-ChunkyQueues(a0) ; Incrememt address
  MOVE.w  d1,d7 ; Store shape
  MOVE.w  d2,d1
  MOVE.w  d3,d2
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0 ; shape
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleQBlitNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleQBlitNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  MOVE.w  d7,d0 ; Temp modulo
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a5 ; X2,Y2 in dest stencil
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  EXT.l   d1
  ADD.l   d1,d2
  EXT.l   d7
  MOVE.l  a3,(a6)+ ; Store queue list entry - Dest address
  MOVE.w  d3,(a6)+ ; Store queue list entry - OpWidth
  MOVE.w  d4,(a6)+ ; Store queue list entry - OpHeight
  MOVE.l  d7,(a6)+ ; Store queue list entry - Dest linemod
  MOVE.l  d2,(a6)  ; Store queue list entry - XYbytes not including wrap
  MOVE.w  _DoubleQBlitModeType,d0
  TST.b   DoubleQBlitMode
  BNE     _MDoubleQBlitSkip
  BSR     PerformBlit2 ; Blit forwards, paste cookie to stencil
  BRA     _MDoubleQBlitSkip2
_MDoubleQBlitSkip
  BSR     PerformBlit3 ; Blit forwards, cut using cookie and stencil
_MDoubleQBlitSkip2
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MDoubleQBlockShortest
  MOVE.w  d1,d3
  MOVE.w  d0,d2
  MOVE.w  CurrentChunkyShape1,d1
  MOVE.w  CurrentChunkyQueue1,d0
  BRA     _MDoubleQBlock
_MDoubleQBlockShort
  MOVE.w  d2,d3
  MOVE.w  d1,d2
  MOVE.w  d0,d1
  MOVE.w  CurrentChunkyQueue1,d0
_MQSBlock
_MDoubleQBlock
;Block-Scroll a whole Shape to a Bitmap, cookie to stencil, and add entry to a queue
  !GetQueueObjectPtr ; base in a0
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  CQueue_ItemAddr-ChunkyQueues(a0),a6 ; New item position
  ADD.w   #1,CQueue_Items-ChunkyQueues(a0) ; Items+1
  ADD.l   #ChunkyQueueListStructBytes,CQueue_ItemAddr-ChunkyQueues(a0) ; Increment address
  MOVE.w  d1,d7 ; Store shape
  MOVE.w  d2,d1
  MOVE.w  d3,d2
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest resource
  !GetBitmapObjectPtr ; base in a0
  MOVE.l  a0,a1 ; Dest bitmap
  MOVE.w  d7,d0 ; shape
  !GetShapeObjectPtr ; base in a0 - Source shape
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     _MDoubleQBlockNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a5
_MDoubleQBlockNoWrap
  SUB.w   CRsrc_XHandle-ChunkyResources(a0),d1 ; Adjust Xpos
  SUB.w   CRsrc_YHandle-ChunkyResources(a0),d2 ; Adjust Ypos
  AND.b   #$F0,d1 ; Align X
  MOVE.w  d7,d0 ; Temp modulo
  MOVE.w  CRsrc_Width-ChunkyResources(a1),d5
  ADD.w   d5,d0
  MULU    d0,d2
  ADD.w   d1,a3 ; Dest coordinate offset
  ADD.l   d2,a3 ; X2,Y2 in dest data
  ADD.w   d1,a5 ; Dest stencil coordinate offset
  ADD.l   d2,a5 ; X2,Y2 in dest data
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d3 ; OpWidth
  SUB.w   d3,d5 ; extra linemod
  ADD.w   d5,d7 ; dest
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d4 ; OpHeight
  EXT.l   d1
  ADD.l   d1,d2
  EXT.l   d7
  MOVE.l  a3,(a6)+ ; Store queue list entry - Dest address
  MOVE.w  d3,(a6)+ ; Store queue list entry - OpWidth
  MOVE.w  d4,(a6)+ ; Store queue list entry - OpHeight
  MOVE.l  d7,(a6)+ ; Store queue list entry - Dest linemod
  MOVE.l  d2,(a6)  ; Store queue list entry - XYbytes not including wrap
  TST.b   DoubleQBlitMode
  BNE     _MDoubleQBlockSkip
  BSR     PerformGenericBlit7 ; Block-Blit forwards, paste cookie to stencil
  BRA     _MDoubleQBlockSkip2
_MDoubleQBlockSkip
  BSR     PerformGenericBlit10 ; Block-Blit forwards, cut using cookie and stencil
_MDoubleQBlockSkip2
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************
_MQSBlitCut
_MDoubleQBlitCut
;Set the type of blit to be used in the Double QBlit commands
  MOVE.b  d0,DoubleQBlitMode ; Set status
  RTS

;*************************************************************************************

_MBoxFShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxF
;Draw a filled box to a bitmap in the specified colour or 0
  !PrepareCoords{001}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformBoxF ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxFShapeShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxFShape
;Draw a filled box to a bitmap in the specified colour or 0
  !PrepareCoords{002}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformBoxF ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxFStencilShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxFStencil
;Draw a filled box to a stencil to represent the specified colour or 0
  !PrepareCoords{003}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap that has stencil to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of stencil
  TST.b   d4
  SEQ     d4 ; Make stencil byte value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MBoxFStencilSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformBoxF
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MBoxFStencilSkip
  JMP     PerformBoxF ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxFCookieShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxFCookie
;Draw a filled box to a cookie to represent the specified colour or 0
  !PrepareCoords{004}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape that has cookie to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of cookie
  TST.b   d4
  SEQ     d4 ; Make cookie byte value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MBoxFCookieSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformBoxF
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MBoxFCookieSkip
  JMP     PerformBoxF ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBox
;Draw an unfilled box to a bitmap in the specified colour or 0
  !PrepareCoords{005}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformBox ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxShapeShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxShape
;Draw an unfilled box to a bitmap in the specified colour or 0
  !PrepareCoords{006}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformBox ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxStencilShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxStencil
;Draw an unfilled box to a stencil to represent the specified colour or 0
  !PrepareCoords{007}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap that has stencil to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of stencil
  TST.b   d4
  SEQ     d4 ; Make stencil byte value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MBoxStencilSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformBox
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MBoxStencilSkip
  JMP     PerformBox ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MBoxCookieShort
  MOVEQ.l #0,d4
  MOVE.b  CurrentInk1,d4
_MBoxCookie
;Draw an unfilled box to a cookie to represent the specified colour or 0
  !PrepareCoords{008}
  SUB.w   d0,d2 ; Make Width
  SUB.w   d1,d3 ; Make Height
  ADDQ.w  #1,d2
  ADDQ.w  #1,d3
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape that has cookie to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of cookie
  TST.b   d4
  SEQ     d4 ; Make cookie byte value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MBoxCookieSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformBox
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MBoxCookieSkip
  JMP     PerformBox  ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MPlanar16ToBitmapShort
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d2 ; OpWidth
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d3 ; OpHeight
  MOVE.w  d2,d4 ; PlanarWidth
  MOVE.w  d3,d5 ; PlanarHeight
_MPlanar16ToBitmap
;Convert 256-colour planar data to a chunky Bitmap object, width multiple of 16
  !GetBitmapObjectPtr ; Base in a0
  AND.b   #$F0,d2 ; OpWidth down to 16
  AND.b   #$F0,d4 ; PlanarWidth down to 16
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d7 ; Dest linemod
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Chunky
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Dest wrap?
  BEQ     _MPlanar16ToBitmapNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlanar16ToBitmapNoWrap
  JMP     PerformPlanar16ToChunky ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MPlanar16ToShapeShort
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d2 ; OpWidth
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d3 ; OpHeight
  MOVE.w  d2,d4 ; PlanarWidth
  MOVE.w  d3,d5 ; PlanarHeight
_MPlanar16ToShape
;Convert 256-colour planar data to a chunky Shape object, width multiple of 16
  !GetShapeObjectPtr ; Base in a0
  AND.b   #$F0,d2 ; OpWidth down to 16
  AND.b   #$F0,d4 ; PlanarWidth down to 16
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d7 ; Dest linemod
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Chunky
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Dest wrap?
  BEQ     _MPlanar16ToShapeNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlanar16ToShapeNoWrap
  JMP     PerformPlanar16ToChunky ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MGenericPtr
;Given a base address, xpos, ypos, and width, work out an address and return it
  MULU    d3,d1 ; Width*Ypos
  EXT.l   d0
  ADD.l   d0,d1 ; Add Xpos
  ADD.l   d2,d1 ; Add base address
  MOVE.l  d1,d0 ; Return longword in d0.l
  RTS

;*************************************************************************************

_MCludgeCookie
;Cludge a new ChunkyShape's cookie from existing memory
  SUB.l   #16,d1 ; Prepare for alignment
  !GetShapeObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  MOVE.l  d1,d3 ; Mem
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d1 ; Width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d2 ; Height
  !DeallocStencil{001} ; Deallocate existing cookie
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  d3,d0 ; Store for return
  !StoreResourceStencilMemInfo2
  RTS     ; Return errorcode in d0

;*************************************************************************************

_MCludgeStencil
;Cludge a new ChunkyBitmap's stencil from existing memory
  SUB.l   #16,d1 ; Prepare for alignment
  !GetBitmapObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  MOVE.l  d1,d3 ; Mem
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d1 ; Width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d2 ; Height
  !DeallocStencil{002} ; Deallocate existing stencil
  MOVE.l  a2,a0 ; Get base in a0
  MOVE.l  d3,d0 ; Store for return
  !StoreResourceStencilMemInfo2
  RTS     ; Return errorcode in d0

;*************************************************************************************

_MReMapShortest
  MOVEQ.l #-1,d2 ; Use table
  MOVE.w  CurrentChunkyBitmap1,d1 ; Current bitmap
_MReMapShort
  MOVEQ.l #-1,d2 ; Use table
  MOVE.l  d0,a2 ; a2=Table address
  MOVE.w  d1,d0 ; d0=BitmapNum
  BRA     _MReMapJump
_MReMap
;Remap d0colour to d1colour, or using a table, for a whole bitmap
  MOVE.w  d0,d5 ; d5=Colour0
  MOVE.w  d1,d6 ; d6=Colour1
  MOVE.w  d2,d0
_MReMapJump
  !GetBitmapObjectPtr ; Base in a0
  JMP     PerformReMap ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MReMapShapeShortest
  MOVEQ.l #-1,d2 ; Use table
  MOVE.w  CurrentChunkyShape1,d1 ; Current shape
_MReMapShapeShort
  MOVEQ.l #-1,d2 ; Use table
  MOVE.l  d0,a2 ; a2=Table address
  MOVE.w  d1,d0 ; d0=ShapeNum
  BRA     _MReMapShapeJump
_MReMapShape
;Remap d0colour to d1colour, or using a table, for a whole shape
  MOVE.w  d0,d5 ; d5=Colour0
  MOVE.w  d1,d6 ; d6=Colour1
  MOVE.w  d2,d0
_MReMapShapeJump
  !GetShapeObjectPtr ; Base in a0
  JMP     PerformReMap ; ingnore rts
  RTS     ; Precaution

;*************************************************************************************

_MLineShortest2
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MLineShortest
  MOVE.w  d2,d4
  MOVE.w  d1,d3 ; Xpos2
  MOVE.w  d0,d2 ; Ypos2
  MOVE.w  LineLastXpos,d0
  MOVE.w  LineLastYpos,d1
  BRA     _MLine
_MLineShort
  MOVEQ.l #0,d4 ; Init
  MOVE.b  CurrentInk1,d4 ; Colour to use
_MLine
;Draw a line to a Bitmap from X1,Y1 to X2,Y2 in the specified colour or ink
  MOVE.w  d2,LineLastXpos
  MOVE.w  d3,LineLastYpos
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformLine ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MLineShapeShortest2
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MLineShapeShortest
  MOVE.w  d2,d4
  MOVE.w  d1,d3 ; Xpos2
  MOVE.w  d0,d2 ; Ypos2
  MOVE.w  LineLastXpos,d0
  MOVE.w  LineLastYpos,d1
  BRA     _MLine
_MLineShapeShort
  MOVEQ.l #0,d4 ; Init
  MOVE.b  CurrentInk1,d4 ; Colour to use
_MLineShape
;Draw a line to a Shape from X1,Y1 to X2,Y2 in the specified colour or ink
  MOVE.w  d2,LineLastXpos
  MOVE.w  d3,LineLastYpos
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Base of data
  JMP     PerformLine ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MLineStencilShortest2
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MLineStencilShortest
  MOVE.w  d2,d4
  MOVE.w  d1,d3 ; Xpos2
  MOVE.w  d0,d2 ; Ypos2
  MOVE.w  LineLastXpos,d0
  MOVE.w  LineLastYpos,d1
  BRA     _MLine
_MLineStencilShort
  MOVEQ.l #0,d4 ; Init
  MOVE.b  CurrentInk1,d4 ; Colour to use
_MLineStencil
;Draw a line to a Bitmap's stencil from X1,Y1 to X2,Y2 in the specified colour or ink
  MOVE.w  d2,LineLastXpos
  MOVE.w  d3,LineLastYpos
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to draw to
  !GetBitmapObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of stencil data
  TST.b   d4
  SEQ     d4 ; Make mask colour value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MLineStencilSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformLine
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MLineStencilSkip
  JMP     PerformLine ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MLineCookieShortest2
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MLineCookieShortest
  MOVE.w  d2,d4
  MOVE.w  d1,d3 ; Xpos2
  MOVE.w  d0,d2 ; Ypos2
  MOVE.w  LineLastXpos,d0
  MOVE.w  LineLastYpos,d1
  BRA     _MLine
_MLineCookieShort
  MOVEQ.l #0,d4 ; Init
  MOVE.b  CurrentInk1,d4 ; Colour to use
_MLineCookie
;Draw a line to a Shape's cookie from X1,Y1 to X2,Y2 in the specified colour or ink
  MOVE.w  d2,LineLastXpos
  MOVE.w  d3,LineLastYpos
  MOVE.w  d0,d5 ; X1 store
  MOVE.w  CurrentChunkyShape1,d0 ; Shape to draw to
  !GetShapeObjectPtr ; Base in a0
  MOVE.w  d5,d0 ; X1 restore
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a1 ; Base of cookie data
  TST.b   d4
  SEQ     d4 ; Make mask colour value
  MOVE.w  _DrawingModeType,d7
  CMP.b   #4,d7
  BLE     _MLineCookieSkip
  MOVE.w  d7,-(a7) ; Store
  MOVE.w  #4,_DrawingModeType ; Default to MColourMode instead of remapping
  JSR     PerformLine
  MOVE.w  (a7)+,_DrawingModeType ; Restore
  RTS
_MLineCookieSkip
  JMP     PerformLine ; ignore rts
  RTS     ; Precaution

;*************************************************************************************

_MInkShortest
  MOVE.b  d2,CurrentInk3 ; set third colour
_MInkShort
  MOVE.b  d1,CurrentInk2 ; set second colour
_MInk
;Sets a colour that can be assumed as the currently-used colour by various grapics routines when a colour is not specified
  MOVE.b  d0,CurrentInk1 ; set main colour
  RTS

;*************************************************************************************

_MColourMode
;Return value 4 to represent `colour' mode for blits
  MOVEQ.l #4,d0
  RTS

;*************************************************************************************

_MReserveTables
_MReserveChunkyTables
;Reserve memory for ChunkyTable structures
  MOVE.l  d0,d7
  TST.l   ChunkyTablesMem ; Check for existing mem allocated
  BEQ     ReserveChunkyTskip ; If exists, deallocate
  MOVE.w  ChunkyTablesTotal,d0
  EXT.l   d0
  LSL.l   #ChunkyTableStructSize,d0
  MOVE.l  ChunkyTablesMem,a1
  ALibJsr #BlitzFreemem ; Free memory
  MOVE.l  d7,d0
  MOVE.w  #0,ChunkyTablesTotal
  MOVE.l  #0,ChunkyTablesMem
ReserveChunkyTskip
  AND.l   #$FFFF,d0
  MOVE.w  d0,d7
  LSL.l   #ChunkyTableStructSize,d0
  MOVE.l  #ClearPublicMem,d1 ; MemType (public and clear)
  !CheckAvailMem{005}
  TST.b   d2 ; Likely?
  BEQ     ReserveChunkyTfailed
  ALibJsr #BlitzAllocmem ; Allocate memory
  TST.l   d0
  BEQ     ReserveChunkyTfailed
  MOVE.l  d0,ChunkyTablesMem
  MOVE.w  d7,ChunkyTablesTotal
  RTS     ; Return memory address in d0.l
ReserveChunkyTfailed
  MOVEQ.l #0,d0 ; Errorcode
  RTS

;*************************************************************************************

_MFreeChunkyTablesRange
;Free a range of ChunkyTable objects
  SUB.w   d0,d1 ; Total
  MOVE.w  d1,d7 ; Loopcounter, no need for -1
  MOVE.w  d0,d4 ; Start offset
FreeCTRloop
  MOVE.w  d7,d0
  ADD.w   d4,d0
  BSR     _MFreeChunkyTable ; Free it
  DBRA    d7,FreeCTRloop
  RTS
_MFreeTables
_MFreeChunkyTables
;Free all ChunkyTable objects
  MOVE.w  ChunkyTablesTotal,d7
  SUBQ.w  #1,d7 ; loopcounter
FreeCTloop
  MOVE.w  d7,d0
  BSR     _MFreeChunkyTable ; Free it
  DBRA    d7,FreeCTloop
FreeCTsSkip
  RTS
_MFreeTable
_MFreeChunkyTable
;Free a single ChunkyTable object
  !GetTableObjectPtr ; Get base of struct in a0
_MFreeChunkyTableEntry
  MOVE.l  d0,-(a7) ; Store
  TST.l   CTable_LMem-ChunkyResources(a0) ; List memory exist?
  BEQ     FreeTNoList
  MOVE.l  CTable_LBytes-ChunkyTables(a0),d0 ; Size
  MOVE.l  CTable_LMem-ChunkyTables(a0),a1 ; Mem address
  ALibJsr #BlitzFreemem ; Free data memory
FreeTNoList
  MOVE.l  #0,CTable_LMem-ChunkyTables(a0) ; Wipe LMem to indicate dead structure
  MOVE.l  (a7)+,d0 ; Restore
  RTS

;*************************************************************************************

_MAddrChunkyTableShort
  MOVE.w  CurrentChunkyTable1,d0
_MAddrTable
_MAddrChunkyTable
;Returns the address of the specified ChunkyTable structure
  !GetTableObjectPtr ; In a0
  MOVE.l  a0,d0 ; Return address
  RTS

;*************************************************************************************

_MTable
_MChunkyTable
;Initialise a new ChunkyTable object
  !GetTableObjectPtr ; Get base of struct
  MOVE.l  a0,a2 ; Store base pointer
  MOVE.w  d0,d7 ; Store
  MOVE.l  d1,d0
  TST.l   CTable_LMem-ChunkyQueues(a0) ; Has mem?
  BEQ     _MChunkyTSkip
  BSR     _MFreeChunkyTableEntry ; Deallocate existing data
_MChunkyTSkip
  MOVE.l  #0,CTable_Items-ChunkyTables(a0) ; Number of actual items
  MOVE.l  d0,CTable_LBytes-ChunkyTables(a0) ; Total number of byte items
  !NewChunkyMem{008} ; Returns address in d0
  MOVE.l  a2,a0
  TST.b   d2
  BEQ     _MChunkyTFailed
  MOVE.l  d0,CTable_LMem-ChunkyTables(a0)
  MOVE.l  d0,CTable_ItemAddr-ChunkyTables(a0) ; Address of current item
  TST.b   AutoChunkyTablesUse ; Use it?
  BEQ     _MChunkyTDontUse ; No
  MOVE.w  d7,CurrentChunkyTable1 ; Yes, store queue number in current
_MChunkyTDontUse
  RTS     ; Successful, return

_MChunkyTFailed
  MOVEQ.l #0,d0
  MOVE.l  #0,CTable_LMem-ChunkyTables(a0)
  RTS     ; Return errorcode in d0

;*************************************************************************************

_MAutoUseTables
_MAutoUseChunkyTables
  MOVE.b  d0,AutoChunkyTablesUse
  RTS

;*************************************************************************************

_MUseTable
_MUseChunkyTable
;Set the currently used ChunkyTables
  MOVE.w  d2,CurrentChunkyTable3
_MUseChunkyTableShort
  MOVE.w  d1,CurrentChunkyTable2
_MUseChunkyTableShortest
  MOVE.w  d0,CurrentChunkyTable1
  RTS

;*************************************************************************************

_MUsedTable
_MUsedChunkyTable
;Returns number of main currently used ChunkyTable, or likely -1 if not defined
  MOVE.w  CurrentChunkyTable1,d0
  RTS

;*************************************************************************************

_MTablePtrShort
  MOVE.w  CurrentChunkyTable1,d0 ; current object
_MTablePtr
;Return the address of the base of the table data
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),d0 ; Return base address
  RTS

;*************************************************************************************

_MReMapMode
;Return value 5 to represent `ReMap' mode for blits (to use current 2-dimensional 8-bit table)
  MOVEQ.l #5,d0
  RTS

;*************************************************************************************

_MSimpleReMapMode
;Return value 6 to represent `SimpleReMap' mode for blits (to use current 1-dimensional 8-bit table)
  MOVEQ.l #6,d0
  RTS

;*************************************************************************************

_MSMaskScrollModeShort
  MOVE.w  SMaskScrollModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MSMaskScrollMode
;Set blit mode type for MSMaskScrolls
  CMP.w   #8,d0 ; Direct?
  BGE     _MSMaskScrollModeJump
  MOVE.w  d0,SMaskScrollModeType ; Directly copy type number
  RTS
_MSMaskScrollModeJump
  CMP.w   #_CookieMode,d0 ; CookieMode?
  BNE     _MSMaskScrollModeSkip
  MOVE.w  #0,SMaskScrollModeType ; Store type for CookieMode
  RTS
_MSMaskScrollModeSkip
  CMP.w   #_EraseMode,d0 ; EraseMode?
  BNE     _MSMaskScrollModeSkip2
  MOVE.w  #1,SMaskScrollModeType ; Store type for EraseMode
  RTS
_MSMaskScrollModeSkip2
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MSMaskScrollModeSkip3
  MOVE.w  #2,SMaskScrollModeType ; Store type for InvMode
  RTS
_MSMaskScrollModeSkip3
  CMP.w   #_SolidMode,d0 ; SolidMode?
  BNE     _MSMaskScrollModeSkip4
  MOVE.w  #3,SMaskScrollModeType ; Store type for SolidMode
  RTS
_MSMaskScrollModeSkip4
  RTS

;*************************************************************************************

_MPlotParticlesShort
  MOVEQ.l #0,d2 ; Init
  MOVE.b  CurrentInk1,d2 ; Colour to use
_MPlotParticles
;Plot a list of pixels in a bitmap to specified or ink colour. List contains X.w,Y.w pairs
  TST.b   _ParticleFormat ; What format?
  BLT     _MPlotParticlesQ ; Data is in X.q,Y.q format
  BGT     _MPlotParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  CMP.w   #5,_ParticleModeType
  BEQ     _MPlotParticlesReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MPlotParticlesReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotParticlesSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotParticlesSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MPlotParticlesClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MPlotParticlesAddLoop
_MPlotParticlesLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  d2,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesLoop
  RTS;pop
_MPlotParticlesAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.b   d2,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAddLoop
  RTS;pop
_MPlotParticlesClip
;Only plot the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  a1,a3 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MPlotParticlesAddClipLoop
_MPlotParticlesClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  d2,(a1) ; Plot point
_MPlotParticlesClipSkip2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesClipSkip
    ADD.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesAddClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesAddClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesAddClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesAddClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesAddClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.b   d2,(a1) ; Plot Add
_MPlotParticlesAddClipSkip2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAddClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesAddClipSkip
    ADD.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAddClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesReMap
;Remap a list of X.w,Y.w particles in a bitmap, perhaps combining with specified colour. List contains X.w,Y.w pairs
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotParticlesReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotParticlesReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MPlotParticlesReMapClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MPlotParticlesReMapComplex
  MOVEQ.l #0,d2 ; Init
_MPlotParticlesReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MPlotParticlesReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MPlotParticlesReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MPlotParticlesReMapClip
;Only remap the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a4,-(a7) ; Store
  MOVE.l  a1,a4 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MPlotParticlesReMapClipComplex
  MOVEQ.l #0,d2 ; Init
_MPlotParticlesReMapClipLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesReMapClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesReMapClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesReMapClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesReMapClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
_MPlotParticlesReMapClipSkip2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesReMapClipSkip
    ADD.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesReMapClipComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MPlotParticlesReMapClipComplexLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesReMapClipComplexSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesReMapClipComplexSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesReMapClipComplexSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesReMapClipComplexSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
_MPlotParticlesReMapClipComplexSkip2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesReMapClipComplexSkip
    ADD.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS

_MPlotParticlesA
;Plot a list of pixels in a bitmap to specified or ink colour. List contains Ptr.l actual addresses (not coords or clipping)
  CMP.w   #5,_ParticleModeType
  BEQ     _MPlotParticlesAReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MPlotParticlesAReMap
  MOVE.l  d0,a2 ; a2=List memory
  CMP.w   #7,_ParticleModeType
  BEQ     _MPlotParticlesAAddLoop
_MPlotParticlesALoop
    MOVE.l  (a2)+,a1 ; Get address
    MOVE.b  d2,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesALoop
  RTS;pop
_MPlotParticlesAAddLoop
    MOVE.l  (a2)+,a1 ; Get address
    ADD.b   d2,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAAddLoop
  RTS;pop
_MPlotParticlesAReMap
;Remap a list of Ptr.l particles in a bitmap, perhaps combining with specified colour. List contains Ptr.l actual addresses
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; a0=Table base
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MPlotParticlesAReMapComplex
  MOVEQ.l #0,d2 ; Init
_MPlotParticlesAReMapLoop
    MOVE.l  (a2)+,a1 ; Get Ptr.l
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a0,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAReMapLoop
  RTS;pop
_MPlotParticlesAReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MPlotParticlesAReMapComplexLoop
    MOVE.l  (a2)+,a1 ; Get Ptr.l
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a0,d2.l),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesAReMapComplexLoop
  RTS

_MPlotParticlesQ
;Plot a list of pixels in a bitmap to specified or ink colour. List contains X.q,Y.q pairs
  CMP.w   #5,_ParticleModeType
  BEQ     _MPlotParticlesQReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MPlotParticlesQReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotParticlesQSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotParticlesQSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MPlotParticlesQClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MPlotParticlesQAddLoop
_MPlotParticlesQLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    MULU    d7,d0 ; Find y bytes
    ADD.w   (a2),a1 ; Get x from top word of .q
    ADD.l   d0,a1
    ADD.w   #8,a2 ; Next pair of .q items
    MOVE.b  d2,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQLoop
  RTS;pop
_MPlotParticlesQAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    MULU    d7,d0 ; Find y bytes
    ADD.w   (a2),a1 ; Get x from top word of .q
    ADD.l   d0,a1
    ADD.w   #8,a2 ; Next pair of .q items
    ADD.b   d2,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQAddLoop
  RTS;pop
_MPlotParticlesQClip
;Only plot the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  a1,a3 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MPlotParticlesQAddClipLoop
_MPlotParticlesQClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x from top word of .q
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesQClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesQClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesQClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  d2,(a1) ; Plot point
_MPlotParticlesQClipSkip
    ADD.w   #8,a2 ; Next pair of .q items
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesQAddClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x from top word of .q
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesQAddClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesQAddClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesQAddClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesQAddClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.b   d2,(a1) ; Plot Add
_MPlotParticlesQAddClipSkip
    ADD.w   #8,a2 ; Next pair of .q items
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQAddClipLoop
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesQReMap
;Remap a list of X.q,Y.q particles in a bitmap, perhaps combining with specified colour. List contains X.q,Y.q pairs
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MPlotParticlesQReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MPlotParticlesQReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MPlotParticlesQReMapClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MPlotParticlesQReMapComplex
  MOVEQ.l #0,d2 ; Init
_MPlotParticlesQReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x from upper word of X.q
    MOVE.w  4(a2),d0 ; Get y from upper word of Y.q
    MULU    d7,d0 ; Find y bytes
    ADD.w   #8,a2 ; Next
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MPlotParticlesQReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MPlotParticlesQReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x from upper word of X.q
    MOVE.w  4(a2),d0 ; Get y from upper word of Y.q
    MULU    d7,d0 ; Find y bytes
    ADD.w   #8,a2 ; next
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MPlotParticlesQReMapClip
;Only remap the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a4,-(a7) ; Store
  MOVE.l  a1,a4 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MPlotParticlesQReMapClipComplex
  MOVEQ.l #0,d2 ; Init
_MPlotParticlesQReMapClipLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x from upper word of X.q
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesQReMapClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesQReMapClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y from upper word of Y.q
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesQReMapClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesQReMapClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
_MPlotParticlesQReMapClipSkip2
    ADD.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesQReMapClipSkip
    ADD.w   #8,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesQReMapClipComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MPlotParticlesQReMapClipComplexLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x from upper word of X.q
    CMP.w   d3,d0 ; X<X1?
    BLT     _MPlotParticlesQReMapClipComplexSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MPlotParticlesQReMapClipComplexSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y from upper word of Y.q
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MPlotParticlesQReMapClipComplexSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MPlotParticlesQReMapClipComplexSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
_MPlotParticlesQReMapClipComplexSkip2
    ADD.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS;pop
_MPlotParticlesQReMapClipComplexSkip
    ADD.w   #8,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MPlotParticlesQReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  RTS

;*************************************************************************************

_MGrabParticles
;Grab a buffer of pixels from a bitmap using a list. List contains X.w,Y.w pairs, Buffer contains byte per pixel
  TST.b   _ParticleFormat ; What format?
  BLT     _MGrabParticlesQ ; Operation uses X.q,Y.q data
  BGT     _MGrabParticlesA ; Operation uses Ptr.l data
  ;Use X.w,Y.w data
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
_MGrabParticlesLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a0)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesLoop
  RTS;pop
_MGrabParticlesClip
;Only update the grabs of particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
_MGrabParticlesClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a0)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesClipLoop
  RTS;pop
_MGrabParticlesClipSkip
    ADD.w   #1,a0 ; Mimic write
    ADD.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesClipLoop
  RTS;pop
_MGrabParticlesClipSkip2
    ADD.w   #1,a0 ; Minic write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesClipLoop
  RTS

_MGrabParticlesA
;Grab a buffer of pixels from a bitmap using a list. List contains Ptr.l actual addresses, Buffer contains byte per pixel
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  d2,a0 ; Buffer mem
_MGrabParticlesALoop
    MOVE.l  (a2)+,a1 ; Get address
    MOVE.b  (a1),(a0)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesALoop
  RTS

_MGrabParticlesQ
;Grab a buffer of pixels from a bitmap using a list. List contains X.q,Y.q pairs, Buffer contains byte per pixel
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesQSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesQSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesQClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
_MGrabParticlesQLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    MULU    d7,d0 ; Find y bytes
    ADD.w   (a2),a1 ; Get x from top word of .q
    ADD.l   d0,a1
    ADD.w   #8,a2 ; Next pair of .q items
    MOVE.b  (a1),(a0)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesQLoop
  RTS;pop
_MGrabParticlesQClip
;Only update the grabs of particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
_MGrabParticlesQClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x from top word of .q
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesQClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y from top word of .q
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesQClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesQClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.w   #8,a2 ; Next pair of .q items
    ADD.l   d0,a1
    MOVE.b  (a1),(a0)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesQClipLoop
  RTS;pop
_MGrabParticlesQClipSkip
    ADD.w   #1,a0 ; Mimic write
    ADD.w   #8,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesQClipLoop
  RTS

;*************************************************************************************

_MDrawParticles
;Draw a buffer of pixels to a bitmap using a list. List contains X.w,Y.w pairs, Buffer contains byte per pixel
;Drawing is done backwards to facilitate a stack for proper background restore
  TST.b   _ParticleFormat ; What format?
  BLT     _MDrawParticlesQ ; Data is in X.q,Y.q format
  BGT     _MDrawParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MDrawParticlesReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MDrawParticlesSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MDrawParticlesSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MDrawParticlesClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset - number of pixels should be no higher than 2 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  CMP.w   #7,_ParticleModeType
  BEQ     _MDrawParticlesAddLoop
_MDrawParticlesLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   -(a2),a1 ; Get x
    MOVE.b  -(a0),(a1) ; Draw point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesLoop
  RTS;pop
_MDrawParticlesAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    MOVE.b  -(a0),d2 ; Get point
    ADD.l   d0,a1
    ADD.w   -(a2),a1 ; Get x
    ADD.b   d2,(a1) ; Draw Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAddLoop
  RTS;pop
_MDrawParticlesClip
;Only draw the grabbed particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  CMP.w   #7,_ParticleModeType
  BEQ     _MDrawParticlesAddClipLoop
_MDrawParticlesClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  -(a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesClipSkip2
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesClipSkip2
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),(a1) ; Draw point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesClipLoop
  RTS;pop
_MDrawParticlesClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesClipLoop
  RTS;pop
_MDrawParticlesClipSkip2
    SUB.w   #1,a0 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesClipLoop
  RTS
_MDrawParticlesAddClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesAddClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesAddClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  -(a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesAddClipSkip2
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesAddClipSkip2
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d0 ; Get point
    ADD.b   d0,(a1) ; Draw Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAddClipLoop
  RTS;pop
_MDrawParticlesAddClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAddClipLoop
  RTS;pop
_MDrawParticlesAddClipSkip2
    SUB.w   #1,a0 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAddClipLoop
  RTS
_MDrawParticlesReMap
;Draw with remap a buffer of pixels to a bitmap using a list. List contains X.w,Y.w pairs, Buffer contains byte per pixel
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  a3,-(a7) ; Store
  MOVE.w  CurrentChunkyTable1,d0
  !GetTableObjectPtr ; Base in a0
  MOVE.l  a0,a3 ; a3=table struct
  MOVE.l  CTable_LMem-ChunkyTables(a3),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MDrawParticlesReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MDrawParticlesReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MDrawParticlesReMapClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset - number of pixels should be no higher than 2 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  MOVEQ.l #0,d2 ; init
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesReMapComplexLoop
_MDrawParticlesReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   -(a2),a1 ; Get x
    MOVE.b  -(a0),d2 ; Get point from buffer
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MDrawParticlesReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   -(a2),a1 ; Get x
    MOVE.b  -(a0),d2 ; Get point from buffer
    LSL.w   #8,d2
    MOVE.b  (a1),d2 ; Get dest point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MDrawParticlesReMapClip
;Only remap-draw the grabbed particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  MOVEQ.l #0,d2 ; Init
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesReMapComplexClipLoop
_MDrawParticlesReMapClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesReMapClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesReMapClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  -(a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesReMapClipSkip2
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesReMapClipSkip2
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d2 ; Get point from buffer
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapClipLoop
  RTS;pop
_MDrawParticlesReMapClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapClipLoop
  RTS;pop
_MDrawParticlesReMapClipSkip2
    SUB.w   #1,a0 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapClipLoop
  RTS
_MDrawParticlesReMapComplexClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  -(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesReMapComplexClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesReMapComplexClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  -(a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesReMapComplexClipSkip2
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesReMapComplexClipSkip2
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d2 ; Get point from buffer
    LSL.w   #8,d2
    MOVE.b  (a1),d2 ; Get dest point
    MOVE.b  0(a3,d2.w),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapComplexClipLoop
  RTS;pop
_MDrawParticlesReMapComplexClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #2,a2 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapComplexClipLoop
  RTS;pop
_MDrawParticlesReMapComplexClipSkip2
    SUB.w   #1,a0 ; Mimic read
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesReMapComplexClipLoop
  RTS

_MDrawParticlesA
;Draw a buffer of pixels to a bitmap using a list. List contains Ptr.l actual addresses, Buffer contains byte per pixel
;Drawing is done backwards to facilitate a stack for proper background restore
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesAReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MDrawParticlesAReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset - number of pixels should be no higher than 2 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  CMP.w   #7,_ParticleModeType
  BEQ     _MDrawParticlesAAddLoop
_MDrawParticlesALoop
    MOVE.l  -(a2),a1 ; Get address
    MOVE.b  -(a0),(a1) ; Draw point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesALoop
  RTS
_MDrawParticlesAAddLoop
    MOVE.l  -(a2),a1 ; Get address
    MOVE.b  -(a0),d0 ; Get point
    ADD.b   d0,(a1) ; Draw Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAAddLoop
  RTS
_MDrawParticlesAReMap
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  a0,a3 ; a3=Table base
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #2,d0 ; *4 for offset - number of pixels should be no higher than 2 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  MOVE.l  CTable_LMem-ChunkyTables(a3),a3 ; a3=Table base
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MDrawParticlesAReMapComplex
  MOVEQ.l #0,d2 ; Init
_MDrawParticlesAReMapLoop
    MOVE.l  -(a2),a1 ; Get Ptr.l
    MOVE.b  -(a0),d2 ; Get point from buffer
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MDrawParticlesAReMapComplex
  MOVEQ.l #0,d2 ; Init
_MDrawParticlesAReMapComplexLoop
    MOVE.l  -(a2),a1 ; Get Ptr.l
    MOVE.b  -(a0),d2 ; Get buffer
    LSL.w   #8,d2
    MOVE.b  (a1),d2 ; Get dest point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesAReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MDrawParticlesQ
;Draw a buffer of pixels to a bitmap using a list. List contains X.q,Y.q pairs, Buffer contains byte per pixel
;Drawing is done backwards to facilitate a stack for proper background restore
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesQReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MDrawParticlesQReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MDrawParticlesQSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MDrawParticlesQSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MDrawParticlesQClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #3,d0 ; *8 for offset - number of pixels should be no higher than 3 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  SUB.w   #8,a2 ; Start of last pair
  MOVEQ.l #0,d2 ; Init
  CMP.w   #7,_ParticleModeType
  BEQ     _MDrawParticlesQAddLoop
_MDrawParticlesQLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   (a2),a1 ; Get x
    MOVE.b  -(a0),(a1) ; Draw point
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQLoop
  RTS;pop
_MDrawParticlesQAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    MOVE.b  -(a0),d2 ; Get point
    ADD.l   d0,a1
    ADD.w   (a2),a1 ; Get x
    ADD.b   d2,(a1) ; Draw Add
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQAddLoop
  RTS;pop
_MDrawParticlesQClip
;Only draw the grabbed particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #3,d0 ; *8 for offset
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  SUB.w   #8,a2 ; Start of last pair
  MOVEQ.l #0,d2 ; Init
  CMP.w   #7,_ParticleModeType
  BEQ     _MDrawParticlesQAddClipLoop
_MDrawParticlesQClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesQClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesQClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesQClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),(a1) ; Draw point
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQClipLoop
  RTS;pop
_MDrawParticlesQClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQClipLoop
  RTS;pop
_MDrawParticlesQAddClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesQAddClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesQAddClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesQAddClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesQAddClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d0 ; Get point
    ADD.b   d0,(a1) ; Draw Add
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQAddClipLoop
  RTS;pop
_MDrawParticlesQAddClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQAddClipLoop
  RTS;pop
_MDrawParticlesQReMap
;Draw with remap a buffer of pixels to a bitmap using a list. List contains X.w,Y.w pairs, Buffer contains byte per pixel
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  a3,-(a7) ; Store
  MOVE.w  CurrentChunkyTable1,d0
  !GetTableObjectPtr ; Base in a0
  MOVE.l  a0,a3 ; a3=table struct
  MOVE.l  CTable_LMem-ChunkyTables(a3),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MDrawParticlesQReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MDrawParticlesQReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MDrawParticlesQReMapClip
  MOVE.l  a1,d5 ; Store data mem
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #3,d0 ; *8 for offset - number of pixels should be no higher than 3 bits less than signed longword max
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  SUB.w   #8,a2 ; Find last pair
  MOVEQ.l #0,d2 ; init
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesQReMapComplexLoop
_MDrawParticlesQReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   (a2),a1 ; Get x
    MOVE.b  -(a0),d2 ; Get point from buffer
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MDrawParticlesQReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    ADD.w   (a2),a1 ; Get x
    MOVE.b  -(a0),d2 ; Get point from buffer
    LSL.w   #8,d2
    MOVE.b  (a1),d2 ; Get dest point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MDrawParticlesQReMapClip
;Only remap-draw the grabbed particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a0 ; Buffer mem
  MOVE.l  a1,d2 ; Store data mem
  MOVE.l  d1,d0 ; Copy number of pixels
  LSL.l   #3,d0 ; *8 for offset
  ADD.l   d0,a2 ; Find end of table
  ADD.l   d1,a0 ; Find end of buffer
  SUB.w   #8,a2 ; Find last pair
  MOVEQ.l #0,d2 ; Init
  CMP.w   #5,_ParticleModeType
  BEQ     _MDrawParticlesQReMapComplexClipLoop
_MDrawParticlesQReMapClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesQReMapClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesQReMapClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesQReMapClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesQReMapClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d2 ; Get point from buffer
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapClipLoop
  RTS;pop
_MDrawParticlesQReMapClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapClipLoop
  RTS;pop
_MDrawParticlesQReMapComplexClipLoop
    MOVE.l  d2,a1 ; Reset base address of dest
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MDrawParticlesQReMapComplexClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MDrawParticlesQReMapComplexClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MDrawParticlesQReMapComplexClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MDrawParticlesQReMapComplexClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.b  -(a0),d2 ; Get point from buffer
    LSL.w   #8,d2
    MOVE.b  (a1),d2 ; Get dest point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapComplexClipLoop
  RTS;pop
_MDrawParticlesQReMapComplexClipSkip
    SUB.w   #1,a0 ; Mimic read
    SUB.w   #8,a2 ; Next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MDrawParticlesQReMapComplexClipLoop
  RTS

;*************************************************************************************

_MGrabParticlesAndPlotShort
  MOVEQ.l #0,d3 ; Init
  MOVE.b  CurrentInk1,d3 ; Colour to use
_MGrabParticlesAndPlot
;Grab and Plot a list of pixels in a bitmap to specified or ink colour. List contains X.w,Y.w pairs, Buffer contains bytes
  TST.b   _ParticleFormat ; What format?
  BLT     _MGrabParticlesAndPlotQ ; Data is in X.q,Y.q format
  BGT     _MGrabParticlesAndPlotA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  CMP.w   #5,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  a5,-(a7) ; Store
  MOVE.l  d2,a5 ; a5=Buffer mem
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesAndPlotSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesAndPlotSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesAndPlotClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotAddLoop
_MGrabParticlesAndPlotLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    MOVE.b  d3,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotLoop
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    ADD.b   d3,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotLoop
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotClip
;Only do the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d2 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d2,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  a1,a3 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotAddClipLoop
_MGrabParticlesAndPlotClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d2,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    MOVE.b  d3,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotClipSkip
    ADD.w   #2,a2 ; Mimic read
_MGrabParticlesAndPlotClipSkip2
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotAddClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d2,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotAddClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotAddClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotAddClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotAddClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    ADD.b   d3,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotAddClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotAddClipSkip
    ADD.w   #2,a2 ; Mimic read
_MGrabParticlesAndPlotAddClipSkip2
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotAddClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotReMap
;Remap a list of X.w,Y.w particles in a bitmap, perhaps combining with specified colour. List contains X.w,Y.w pairs
  MOVE.l  a5,-(a7) ; Store
  MOVE.l  d2,a5 ; a5=Buffer mem
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesAndPlotReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesAndPlotReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesAndPlotReMapClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MGrabParticlesAndPlotReMapComplex
  MOVEQ.l #0,d2 ; Init
_MGrabParticlesAndPlotReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    MOVE.b  d2,(a5)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MGrabParticlesAndPlotReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2)+,a1 ; Get x
    MOVE.w  (a2)+,d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    MOVE.b  d2,(a5)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotReMapClip
;Only remap the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a4,-(a7) ; Store
  MOVE.l  a1,a4 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MGrabParticlesAndPlotReMapClipComplex
  MOVEQ.l #0,d2 ; Init
_MGrabParticlesAndPlotReMapClipLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotReMapClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotReMapClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotReMapClipSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotReMapClipSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    MOVE.b  d2,(a5)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotReMapClipSkip
    ADD.w   #2,a2 ; Mimic read
_MGrabParticlesAndPlotReMapClipSkip2
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotReMapClipComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MGrabParticlesAndPlotReMapClipComplexLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2)+,d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotReMapClipComplexSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotReMapClipComplexSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  (a2)+,d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotReMapClipComplexSkip2
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotReMapClipComplexSkip2
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    MOVE.b  d2,(a5)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotReMapClipComplexSkip
    ADD.w   #2,a2 ; Mimic read
_MGrabParticlesAndPlotReMapClipComplexSkip2
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS

_MGrabParticlesAndPlotA
;Grab a list of pixels from a bitmap and plot same pixels to specified or ink colour. List contains Ptr.l actual addresses
  CMP.w   #5,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotAReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotAReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  d2,a0 ; a0=Stack memory
  CMP.w   #7,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotAAddLoop
_MGrabParticlesAndPlotALoop
    MOVE.l  (a2)+,a1 ; Get address
    MOVE.b  (a1),(a0)+ ; Grab point
    MOVE.b  d3,(a1) ; Plot point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotALoop
  RTS;pop
_MGrabParticlesAndPlotAAddLoop
    MOVE.l  (a2)+,a1 ; Get address
    MOVE.b  (a1),(a0)+ ; Grab point
    ADD.b   d3,(a1) ; Plot Add
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotAAddLoop
  RTS;pop
_MGrabParticlesAndPlotAReMap
;Grab and Remap a list of Ptr.l particles in a bitmap, perhaps combining with specified colour. List contains Ptr.l addresses
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  d2,a3 ; a3=Stack memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a0 ; a0=Table base
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MGrabParticlesAndPlotAReMapComplex
  MOVEQ.l #0,d2 ; Init
_MGrabParticlesAndPlotAReMapLoop
    MOVE.l  (a2)+,a1 ; Get Ptr.l
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a0,d2.w),(a1) ; Plot SimpleReMap
    MOVE.b  d2,(a3)+ ; Grab particle
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotAReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MGrabParticlesAndPlotAReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MGrabParticlesAndPlotAReMapComplexLoop
    MOVE.l  (a2)+,a1 ; Get Ptr.l
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a0,d2.l),(a1) ; Plot ReMap
    MOVE.b  d2,(a3)+ ; Grab point
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotAReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MGrabParticlesAndPlotQ
;Grab and Plot a list of pixels in a bitmap to specified or ink colour. List contains X.q,Y.q pairs, Buffer contains bytes
  CMP.w   #5,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotQReMap
  CMP.w   #6,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotQReMap
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.l  a5,-(a7) ; Store
  MOVE.l  d2,a5 ; a5=Buffer mem
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesAndPlotQSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesAndPlotQSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesAndPlotQClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotQAddLoop
_MGrabParticlesAndPlotQLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    MOVE.b  d3,(a1) ; Plot point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQLoop
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotQAddLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    ADD.b   d3,(a1) ; Plot Add
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQAddLoop
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotQClip
;Only do the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d2 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  a1,a3 ; Store data mem
  CMP.w   #7,_ParticleModeType
  BEQ     _MGrabParticlesAndPlotQAddClipLoop
_MGrabParticlesAndPlotQClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d2,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotQClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotQClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotQClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    MOVE.b  d3,(a1) ; Plot point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQClipSkip
    ADD.w   #8,a2 ; Mimic read
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQAddClipLoop
    MOVE.l  a3,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d2,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotQAddClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotQAddClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotQAddClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotQAddClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),(a5)+ ; Grab point
    ADD.b   d3,(a1) ; Plot Add
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQAddClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQAddClipSkip
    ADD.w   #8,a2 ; Mimic read
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQAddClipLoop
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQReMap
;Remap a list of X.w,Y.w particles in a bitmap, perhaps combining with specified colour. List contains X.w,Y.w pairs
  MOVE.l  a5,-(a7) ; Store
  MOVE.l  d2,a5 ; a5=Buffer mem
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d0,a2 ; a2=List memory
  MOVE.w  CurrentChunkyTable1,d0 ; Table to use
  !GetTableObjectPtr ; Base in a0
  MOVE.l  CTable_LMem-ChunkyTables(a0),a3 ; a3=Table base
  MOVE.w  CurrentChunkyBitmap1,d0 ; Bitmap to plot in
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; Data mem
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MGrabParticlesAndPlotQReMapSkip
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a1
_MGrabParticlesAndPlotQReMapSkip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d7 ; Total bytes width
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MGrabParticlesAndPlotQReMapClip
  MOVE.l  a1,d5 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MGrabParticlesAndPlotQReMapComplex
  MOVEQ.l #0,d2 ; Init
_MGrabParticlesAndPlotQReMapLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    MOVE.b  d2,(a5)+ ; Grab point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapLoop
  MOVE.l  (a7)+,a3 ; Restore
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotQReMapComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MGrabParticlesAndPlotQReMapComplexLoop
    MOVE.l  d5,a1 ; Reset base address of dest
    ADD.w   (a2),a1 ; Get x
    MOVE.w  4(a2),d0 ; Get y
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    MOVE.b  d2,(a5)+ ; Grab point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapComplexLoop
  MOVE.l  (a7)+,a3 ; Restore
  MOVE.l  (a7)+,a5 ; Restore
  RTS;pop
_MGrabParticlesAndPlotQReMapClip
;Only remap the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  a4,-(a7) ; Store
  MOVE.l  a1,a4 ; Store data mem
  CMP.w   #5,_ParticleModeType ; Simple or complex?
  BEQ     _MGrabParticlesAndPlotQReMapClipComplex
  MOVEQ.l #0,d2 ; Init
_MGrabParticlesAndPlotQReMapClipLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotQReMapClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotQReMapClipSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotQReMapClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotQReMapClipSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.w),(a1) ; Plot SimpleReMap
    MOVE.b  d2,(a5)+ ; Grab point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQReMapClipSkip
    ADD.w   #8,a2 ; Mimic read
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapClipLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQReMapClipComplex
  LSL.w   #8,d2 ; Make upper portion of offset
  AND.l   #$0000FF00,d2
_MGrabParticlesAndPlotQReMapClipComplexLoop
    MOVE.l  a4,a1 ; Reset base address of dest
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MGrabParticlesAndPlotQReMapClipComplexSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MGrabParticlesAndPlotQReMapClipComplexSkip
    ADD.w   d0,a1 ; Find x
    MOVE.w  4(a2),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MGrabParticlesAndPlotQReMapClipComplexSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MGrabParticlesAndPlotQReMapClipComplexSkip
    MULU    d7,d0 ; Find y bytes
    ADD.l   d0,a1
    MOVE.b  (a1),d2 ; Get point
    MOVE.b  0(a3,d2.l),(a1) ; Plot ReMap
    MOVE.b  d2,(a5)+ ; Grab point
    ADD.w   #8,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS;pop
_MGrabParticlesAndPlotQReMapClipComplexSkip
    ADD.w   #8,a2 ; Mimic read
    ADD.w   #1,a5 ; Mimic grab
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MGrabParticlesAndPlotQReMapClipComplexLoop
  MOVE.l  (a7)+,a4
  MOVE.l  (a7)+,a3
  MOVE.l  (a7)+,a5
  RTS

;*************************************************************************************

_MAddToParticlesShort
  MOVEQ.l #0,d3 ; No second list
_MAddToParticles
;Add X.w increments to X.w coords, and Y.w increments to Y.w coords, in particle list
  TST.b   _ParticleFormat ; What format?
  BLT     _MAddToParticlesQ ; Data is in X.q,Y.q format
  BGT     _MAddToParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list A
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToParticlesClip
  TST.l   d3 ; Two adds?
  BNE     _MAddToParticles2
_MAddToParticlesLoop
    MOVE.w  (a1)+,d3 ; Read
    MOVE.w  (a1)+,d4 ; Read
    ADD.w   d3,(a2)+ ; X.w+XAdder.w
    ADD.w   d4,(a2)+ ; Y.w+YAdder.w
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesLoop
  RTS
_MAddToParticles2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
_MAddToParticles2Loop
    MOVE.w  (a2),d3 ; Read list
    MOVE.w  2(a2),d4 ; Read list
    ADD.w   (a1)+,d3 ; X.w+XAdderA.w
    ADD.w   (a1)+,d4 ; Y.w+YAdderA.w
    ADD.w   (a3)+,d3 ; X.w+XAdderB.w
    ADD.w   (a3)+,d4 ; Y.w+YAdderB.w
    MOVE.w  d3,(a2)+ ; Write
    MOVE.w  d4,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticles2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToParticlesClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two adds?
  BNE     _MAddToParticlesClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #4,d7 ; Skip value
_MAddToParticlesClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToParticlesClipSkip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToParticlesClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToParticlesClipSkip
    ADD.w   (a1)+,d0 ; X.w+XAdder.w
    ADD.w   (a1)+,d2 ; Y.w+YAdder.w
    MOVE.w  d0,(a2)+ ; Write
    MOVE.w  d2,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesClipLoop
  RTS;pop
_MAddToParticlesClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesClipLoop
  RTS;pop
_MAddToParticlesClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #4,d7 ; Skip value
_MAddToParticlesClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToParticlesClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToParticlesClip2Skip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToParticlesClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToParticlesClip2Skip
    ADD.w   (a1)+,d0 ; X.w+XAdderA.w
    ADD.w   (a1)+,d2 ; Y.w+YAdderA.w
    ADD.w   (a3)+,d0 ; X.w+XAdderB.w
    ADD.w   (a3)+,d2 ; Y.w+YAdderB.w
    MOVE.w  d0,(a2)+ ; Write
    MOVE.w  d2,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToParticlesClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a3
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MAddToParticlesA
;Add Ptr.l increment to Ptr.l position in particle list. No clipping!
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list
  MOVE.l  d1,d7 ; Copy counter
  TST.l   d3 ; Second list?
  BNE     _MAddToParticlesA2
  AND.b   #$FC,d7 ; Multiples of 4
  BEQ     _MAddToParticlesASkip
_MAddToParticlesA4Loop
    MOVE.l  (a1)+,d3
    MOVE.l  (a1)+,d4
    MOVE.l  (a1)+,d5
    MOVE.l  (a1)+,d6
    ADD.l   d3,(a2)+ ; Ptr.l+PtrAdder.l
    ADD.l   d4,(a2)+ ; Ptr.l+PtrAdder.l
    ADD.l   d5,(a2)+ ; Ptr.l+PtrAdder.l
    ADD.l   d6,(a2)+ ; Ptr.l+PtrAdder.l
    SUBQ.l  #4,d7 ; Next pixels
    BGT     _MAddToParticlesA4Loop
_MAddToParticlesASkip
  AND.l   #$00000003,d1 ; Counter leftover entries
  BEQ     _MAddToParticlesASkip2
_MAddToParticlesA1Loop
    MOVE.l  (a1)+,d3
    ADD.l   d3,(a2)+ ; Ptr.l+PtrAdder.l
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesA1Loop
_MAddToParticlesASkip2
  RTS
_MAddToParticlesA2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; Increment list B
  AND.b   #$FC,d7 ; Multiples of 4
  BEQ     _MAddToParticlesA2Skip
_MAddToParticlesA24Loop
    MOVE.l  (a2),d3  ; Read
    MOVE.l  4(a2),d4 ; Read
    MOVE.l  8(a2),d5 ; Read
    MOVE.l  12(a2),d6; Read
    ADD.l   (a1)+,d3 ; Ptr.l+PtrAdderA.l
    ADD.l   (a1)+,d4 ; Ptr.l+PtrAdderA.l
    ADD.l   (a1)+,d5 ; Ptr.l+PtrAdderA.l
    ADD.l   (a1)+,d6 ; Ptr.l+PtrAdderA.l
    ADD.l   (a3)+,d3 ; Ptr.l+PtrAdderB.l
    ADD.l   (a3)+,d4 ; Ptr.l+PtrAdderB.l
    ADD.l   (a3)+,d5 ; Ptr.l+PtrAdderB.l
    ADD.l   (a3)+,d6 ; Ptr.l+PtrAdderB.l
    MOVE.l  d3,(a2)+ ; Write
    MOVE.l  d4,(a2)+ ; Write
    MOVE.l  d5,(a2)+ ; Write
    MOVE.l  d6,(a2)+ ; Write
    SUBQ.l  #4,d7 ; Next pixels
    BGT     _MAddToParticlesA24Loop
_MAddToParticlesA2Skip
  AND.l   #$00000003,d1 ; Counter leftover entries
  BEQ     _MAddToParticlesA2Skip2
_MAddToParticlesA21Loop
    MOVE.l  (a2),d3  ; Read
    ADD.l   (a1)+,d3 ; Ptr.l+PtrAdderA.l
    ADD.l   (a3)+,d3 ; Ptr.l+PtrAdderB.l
    MOVE.l  d3,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesA21Loop
_MAddToParticlesA2Skip2
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MAddToParticlesQ
;Add X.q increments to X.q coords, and Y.q increments to Y.q coords, in particle list
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToParticlesQClip
  TST.l   d3 ; Second list?
  BNE     _MAddToParticlesQ2
_MAddToParticlesQLoop
    MOVE.l  (a1)+,d3 ; Read
    MOVE.l  (a1)+,d4 ; Read
    ADD.l   d3,(a2)+ ; X.q+XAdder.q
    ADD.l   d4,(a2)+ ; Y.q+YAdder.q
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQLoop
  RTS
_MAddToParticlesQ2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
_MAddToParticlesQ2Loop
    MOVE.l  (a2),d3  ; Read
    MOVE.l  4(a2),d4 ; Read
    ADD.l   (a1)+,d3 ; X.q+XAdderA.q
    ADD.l   (a1)+,d4 ; Y.q+YAdderA.q
    ADD.l   (a3)+,d3 ; X.q+XAdderA.q
    ADD.l   (a3)+,d4 ; Y.q+YAdderB.q
    MOVE.l  d3,(a2)+ ; Write
    MOVE.l  d4,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQ2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToParticlesQClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two lists?
  BNE     _MAddToParticlesQClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #8,d7 ; Skip value
_MAddToParticlesQClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToParticlesQClipSkip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToParticlesQClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToParticlesQClipSkip
    SWAP    d0 ; Make integer portion of x
    SWAP    d2 ; Make integer portion of y
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    MOVE.w  6(a2),d2 ; Get decimal portion of y
    ADD.l   (a1)+,d0 ; X.q=XAdder.q
    ADD.l   (a1)+,d2 ; Y.q+YAdder.q
    MOVE.l  d0,(a2)+ ; Write
    MOVE.l  d2,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQClipLoop
  RTS;pop
_MAddToParticlesQClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQClipLoop
  RTS
_MAddToParticlesQClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #8,d7 ; Skip value
_MAddToParticlesQClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToParticlesQClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToParticlesQClip2Skip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToParticlesQClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToParticlesQClip2Skip
    SWAP    d0 ; Make integer portion of x
    SWAP    d2 ; Make integer portion of y
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    MOVE.w  6(a2),d0 ; Get decimal portion of y
    ADD.l   (a1)+,d0 ; X.q+XAdderA.q
    ADD.l   (a1)+,d2 ; Y.q+YAdderA.q
    ADD.l   (a3)+,d0 ; X.q+XAdderB.q
    ADD.l   (a3)+,d2 ; Y.q+YAdderB.q
    MOVE.l  d0,(a2)+ ; Write
    MOVE.l  d2,(a2)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToParticlesQClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a2
    ADD.w   d7,a3
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MWrapParticles
;Wrap X.w,Y.w particles around the edges of the bitmap. Particles reappear at opposite edge to which they left
  TST.b   _ParticleFormat ; What format?
  BLT     _MWrapParticlesQ ; Data is in X.q,Y.q format
  BGT     _MWrapParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapParticlesClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
_MWrapParticlesLoop
    MOVE.w  (a1),d3 ; Read, X<0?
    BGE     _MWrapParticlesSkip1
    ADD.w   d5,d3 ; X+Width
    MOVE.w  2(a1),d4 ; Read, Y<0?
    BGE     _MWrapParticlesSkip3
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d3,(a1)+ ; Write X
    MOVE.w  d4,(a1)+ ; Write Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesLoop
  RTS
_MWrapParticlesSkip1
    CMP.w   d5,d3 ; X>=X2?
    BLT     _MWrapParticlesSkip2
    SUB.w   d5,d3 ; X-Width
_MWrapParticlesSkip2
    MOVE.w  2(a1),d4 ; Read, Y<0?
    BGE     _MWrapParticlesSkip3
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d3,(a1)+ ; Write X
    MOVE.w  d4,(a1)+ ; Write Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesLoop
  RTS
_MWrapParticlesSkip3
    CMP.w   d6,d4 ; Y>=Y2?
    BLT     _MWrapParticlesSkip4
    SUB.w   d6,d4 ; Y-Height
    MOVE.w  d3,(a1)+ ; Write X
    MOVE.w  d4,(a1)+ ; Write Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesLoop
  RTS
_MWrapParticlesSkip4
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #4,a1 ; Skip Ywrite
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesLoop
  RTS
_MWrapParticlesClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  MOVE.w  d5,d0 ; Store width
  MOVE.w  d6,d2 ; Store height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
_MWrapParticlesClipLoop
    MOVE.w  (a1),d7 ; Get x
    CMP.w   d3,d7 ; X<X1?
    BLT     _MWrapParticlesClipSkip1
    CMP.w   d5,d7 ; X>=X2?
    BGE     _MWrapParticlesClipSkip2
    MOVE.w  2(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesClipSkip4
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesClipLoop
  RTS
_MWrapParticlesClipSkip1
    ADD.w   d0,d7 ; X+Width
    MOVE.w  d7,(a1) ; Write X
    MOVE.w  2(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesClipSkip4
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesClipLoop
  RTS
_MWrapParticlesClipSkip2
    SUB.w   d0,d7 ; X-Width
    MOVE.w  d7,(a1) ; Write X
    MOVE.w  2(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesClipSkip4
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesClipLoop
  RTS
_MWrapParticlesClipSkip3
    ADD.w   d2,d7 ; Y+Height
    MOVE.w  d7,2(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesClipLoop
  RTS
_MWrapParticlesClipSkip4
    SUB.w   d2,d7 ; Y-Height
    MOVE.w  d7,2(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesClipLoop
  RTS

_MWrapParticlesA
;Wrap Ptr.l particles around the higher and lower bounds of the bitmap. Particles reappear at opposite side to which they left
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d5 ; Base
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MWrapParticlesANoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d5
_MWrapParticlesANoWrap
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapParticlesAClip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d6 ; Get total width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d3 ; Get height
  MULU    d3,d6 ; Total bytes
  MOVE.l  d6,d4 ; Store
  ADD.l   d5,d6 ; d6=Highest address (1 past)
_MWrapParticlesALoop
    MOVE.l  (a1),d3 ; Get long
    CMP.l   d5,d3 ; Lower?
    BLT     _MWrapParticlesASkip1
    CMP.l   d6,d3 ; Higher or equal?
    BGE     _MWrapParticlesASkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesALoop
  RTS
_MWrapParticlesASkip1
    ADD.l   d4,d3 ; Address+Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesALoop
  RTS
_MWrapParticlesASkip2
    SUB.l   d4,d3 ; Address-Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesALoop
  RTS
_MWrapParticlesAClip
;Only wrap the particles that are within clip window bounds
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d2 ; temp
  MOVE.w  d2,d6 ; Get width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d3 ; Get height
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d4 ; temp
  ADD.w   d4,d6 ; Total width
  MULU    d3,d6 ; Total bytes
  EXT.l   d4
  SUB.l   d4,d6 ; For end
  MOVE.w  CRsrc_ClipLMod-ChunkyResources(a0),d4
  EXT.l   d4
  SUB.l   d4,d6 ; For end
  MOVE.l  d6,d4 ; Store
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),d5 ; Lowest address
  ADD.l   d5,d6 ; Highest address (1 past)
_MWrapParticlesAClipLoop
    MOVE.l  (a1),d3 ; Get long
    CMP.l   d5,d3 ; Lower?
    BLT     _MWrapParticlesAClipSkip1
    CMP.l   d6,d3 ; Higher or equal?
    BGE     _MWrapParticlesAClipSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesAClipLoop
  RTS
_MWrapParticlesAClipSkip1
    ADD.l   d4,d3 ; Address+Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesAClipLoop
  RTS
_MWrapParticlesAClipSkip2
    SUB.l   d4,d3 ; Address-Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesAClipLoop
  RTS

_MWrapParticlesQ
;Wrap X.q,Y.q particles around the edges of the bitmap. Particles reappear at opposite edge to which they left
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapParticlesQClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
_MWrapParticlesQLoop
    MOVE.w  (a1),d3 ; Read, X<0?
    BGE     _MWrapParticlesQSkip1
    ADD.w   d5,d3 ; X+Width
    MOVE.w  4(a1),d4 ; Read, Y<0?
    BGE     _MWrapParticlesQSkip3
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d3,(a1) ; Write X
    MOVE.w  d4,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesQLoop
  RTS
_MWrapParticlesQSkip1
    CMP.w   d5,d3 ; X>=X2?
    BLT     _MWrapParticlesQSkip2
    SUB.w   d5,d3 ; X-Width
_MWrapParticlesQSkip2
    MOVE.w  4(a1),d4 ; Read, Y<0?
    BGE     _MWrapParticlesQSkip3
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d3,(a1) ; Write X
    MOVE.w  d4,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesQLoop
  RTS
_MWrapParticlesQSkip3
    CMP.w   d6,d4 ; Y>=Y2?
    BLT     _MWrapParticlesQSkip4
    SUB.w   d6,d4 ; Y-Height
    MOVE.w  d3,(a1) ; Write X
    MOVE.w  d4,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesQLoop
  RTS
_MWrapParticlesQSkip4
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #8,a1 ; Skip Ywrite
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesQLoop
  RTS
_MWrapParticlesQClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  MOVE.w  d5,d0 ; Store width
  MOVE.w  d6,d2 ; Store height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
_MWrapParticlesQClipLoop
    MOVE.w  (a1),d7 ; Get x
    CMP.w   d3,d7 ; X<X1?
    BLT     _MWrapParticlesQClipSkip1
    CMP.w   d5,d7 ; X>=X2?
    BGE     _MWrapParticlesQClipSkip2
    MOVE.w  4(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesQClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesQClipSkip4
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapParticlesQClipLoop
  RTS
_MWrapParticlesQClipSkip1
    ADD.w   d0,d7 ; X+Width
    MOVE.w  d7,(a1) ; Write X
    MOVE.w  4(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesQClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesQClipSkip4
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesQClipLoop
  RTS
_MWrapParticlesQClipSkip2
    SUB.w   d0,d7 ; X-Width
    MOVE.w  d7,(a1) ; Write X
    MOVE.w  4(a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapParticlesQClipSkip3
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapParticlesQClipSkip4
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesQClipLoop
  RTS
_MWrapParticlesQClipSkip3
    ADD.w   d2,d7 ; Y+Height
    MOVE.w  d7,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesQClipLoop
  RTS
_MWrapParticlesQClipSkip4
    SUB.w   d2,d7 ; Y-Height
    MOVE.w  d7,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGE     _MWrapParticlesQClipLoop
  RTS

;*************************************************************************************

_MReboundParticles
;Rebound X.w,Y.w particles off the edges of the bitmap. Particle directions X.w,Y.w change if within detection zone
  TST.b   _ParticleFormat ; What format?
  BLT     _MReboundParticlesQ ; Data is in X.q,Y.q format
  BGT     _MReboundParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.l  d2,a2 ; Direction list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MReboundParticlesClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
  SUB.w   d3,d5 ; X2-zone
  SUB.w   d3,d6 ; Y2-zone
  MOVEQ.l #4,d0 ; Adder
_MReboundParticlesLoop
    MOVE.w  (a1),d4 ; Read X
    CMP.w   d3,d4 ; X<X1?
    BLT     _MReboundParticlesSkip1
    CMP.w   d5,d4 ; X>=X2?
    BGE     _MReboundParticlesSkip1
    MOVE.w  2(a1),d4 ; Read y
    CMP.w   d3,d4 ; Y<Y1?
    BLT     _MReboundParticlesSkip2
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MReboundParticlesSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesLoop
  RTS
_MReboundParticlesSkip1
    NEG.w   (a2) ; Change x direction
    MOVE.w  2(a1),d4 ; Read y
    CMP.w   d3,d4 ; Y<Y1?
    BLT     _MReboundParticlesSkip2
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MReboundParticlesSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesLoop
  RTS
_MReboundParticlesSkip2
    NEG.w   2(a2) ; Change y direction
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesLoop
  RTS
_MReboundParticlesClip
;Only bounce the particles that are inside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d7,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  SUB.w   d3,d5 ; X2-zone
  SUB.w   d3,d6 ; Y2-zone
  ADD.w   d3,d7 ; X1+zone
  ADD.w   d3,d4 ; Y1+zone
  MOVEQ.l #4,d0 ; adder
_MReboundParticlesClipLoop
    MOVE.w  (a1),d3 ; Read X
    CMP.w   d7,d3 ; X<X1?
    BLT     _MReboundParticlesClipSkip1
    CMP.w   d5,d3 ; X>=X2?
    BGE     _MReboundParticlesClipSkip1
    MOVE.w  2(a1),d3 ; Read y
    CMP.w   d4,d3 ; Y<Y1?
    BLT     _MReboundParticlesClipSkip2
    CMP.w   d6,d3 ; Y>=Y2?
    BGE     _MReboundParticlesClipSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesClipLoop
  RTS
_MReboundParticlesClipSkip1
    NEG.w   (a2) ; Change x direction
    MOVE.w  2(a1),d3 ; Read y
    CMP.w   d4,d3 ; Y<Y1?
    BLT     _MReboundParticlesClipSkip2
    CMP.w   d6,d3 ; Y>=Y2?
    BGE     _MReboundParticlesClipSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesClipLoop
  RTS
_MReboundParticlesClipSkip2
    NEG.w   2(a2) ; Change y direction
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesClipLoop
  RTS

_MReboundParticlesA
  ; Not possible to rebound addresses
  RTS

_MReboundParticlesQ
;Rebound X.q,Y.q particles off the edges of the bitmap. Particle directions X.q,Y.q change if within detection zone
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.l  d2,a2 ; Direction list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MReboundParticlesQClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
  SUB.w   d3,d5 ; X2-zone
  SUB.w   d3,d6 ; Y2-zone
  MOVEQ.l #8,d0 ; Adder
_MReboundParticlesQLoop
    MOVE.w  (a1),d4 ; Read X
    CMP.w   d3,d4 ; X<X1?
    BLT     _MReboundParticlesQSkip1
    CMP.w   d5,d4 ; X>=X2?
    BGE     _MReboundParticlesQSkip1
    MOVE.w  4(a1),d4 ; Read y
    CMP.w   d3,d4 ; Y<Y1?
    BLT     _MReboundParticlesQSkip2
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MReboundParticlesQSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQLoop
  RTS
_MReboundParticlesQSkip1
    NEG.l   (a2) ; Change x direction
    MOVE.w  4(a1),d4 ; Read y
    CMP.w   d3,d4 ; Y<Y1?
    BLT     _MReboundParticlesQSkip2
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MReboundParticlesQSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQLoop
  RTS
_MReboundParticlesQSkip2
    NEG.l   4(a2) ; Change y direction
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQLoop
  RTS
_MReboundParticlesQClip
;Only bounce the particles that are inside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d7,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  SUB.w   d3,d5 ; X2-zone
  SUB.w   d3,d6 ; Y2-zone
  ADD.w   d3,d7 ; X1+zone
  ADD.w   d3,d4 ; Y1+zone
  MOVEQ.l #8,d0 ; adder
_MReboundParticlesQClipLoop
    MOVE.w  (a1),d3 ; Read X
    CMP.w   d7,d3 ; X<X1?
    BLT     _MReboundParticlesQClipSkip1
    CMP.w   d5,d3 ; X>=X2?
    BGE     _MReboundParticlesQClipSkip1
    MOVE.w  4(a1),d3 ; Read y
    CMP.w   d4,d3 ; Y<Y1?
    BLT     _MReboundParticlesQClipSkip2
    CMP.w   d6,d3 ; Y>=Y2?
    BGE     _MReboundParticlesQClipSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQClipLoop
  RTS
_MReboundParticlesQClipSkip1
    NEG.l   (a2) ; Change x direction
    MOVE.w  4(a1),d3 ; Read y
    CMP.w   d4,d3 ; Y<Y1?
    BLT     _MReboundParticlesQClipSkip2
    CMP.w   d6,d3 ; Y>=Y2?
    BGE     _MReboundParticlesQClipSkip2
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQClipLoop
  RTS
_MReboundParticlesQClipSkip2
    NEG.l   4(a2) ; Change y direction
    ADD.w   d0,a1
    ADD.w   d0,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MReboundParticlesQClipLoop
  RTS

;*************************************************************************************

_MProcessor
;Return cpu that is currently available as number from 0 to 6
  MOVE.l  $4,a0 ; ExecBase
  ADD.l   #AttnFlags,a0 ; ExecBase->AttnFlags
  MOVE.w  (a0),d1 ; Get flags
  MOVEQ.l #6,d0
  BTST    #7,d1 ; 060?
  BNE     _MProcessorDone
  MOVEQ.l #4,d0
  BTST    #3,d1 ; 040?
  BNE     _MProcessorDone
  MOVEQ.l #3,d0
  BTST    #2,d1 ; 030?
  BNE     _MProcessorDone
  MOVEQ.l #2,d0
  BTST    #1,d1 ; 020?
  BNE     _MProcessorDone
  MOVEQ.l #1,d0
  BTST    #0,d1 ; 010?
  BNE     _MProcessorDone
  MOVEQ.l #0,d0
_MProcessorDone
  RTS

;*************************************************************************************

_MAddXYToParticles
;Add X.w constant to X.w coords, and Y.w constant to Y.w coords, in particle list
  TST.w   d2 ; Add X?
  BEQ     _MAddXYToParticlesYOnly
  TST.w   d3 ; Add X and Y?
  BEQ     _MAddXYToParticlesXOnly
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesClip
_MAddXYToParticlesLoop
    ADD.w   d2,(a1)+ ; X.w+XAdder.w
    ADD.w   d3,(a1)+ ; Y.w+YAdder.w
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesLoop
  RTS
_MAddXYToParticlesClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d7,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a2
_MAddXYToParticlesClipLoop
    MOVE.w  (a1),d0 ; Get x
    CMP.w   d7,d0 ; X<X1?
    BLT     _MAddXYToParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddXYToParticlesClipSkip
    MOVE.w  2(a1),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddXYToParticlesClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddXYToParticlesClipSkip
    ADD.w   a2,d0 ; X.w+XAdder.w
    MOVE.w  d0,(a1)+ ; Write
    ADD.w   d3,d2 ; Y.w+YAdder.w
    MOVE.w  d2,(a1)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesClipLoop
  RTS;pop
_MAddXYToParticlesClipSkip
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesClipLoop
  RTS
_MAddXYToParticlesXOnly
;Add X.w constant to X.w coords in particle list
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesXOnlyClip
  MOVEQ.l #4,d3 ; Skip value
_MAddXYToParticlesXOnlyLoop
    ADD.w   d2,(a1) ; X.w+XAdder.w
    ADD.w   d3,a1 ; skip Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesXOnlyLoop
  RTS
_MAddXYToParticlesXOnlyClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  ADD.w   d7,d5 ; X2 outside of window
  MOVEQ.l #4,d3 ; Skip value
_MAddXYToParticlesXOnlyClipLoop
    MOVE.w  (a1),d0 ; Get x
    CMP.w   d7,d0 ; X<X1?
    BLT     _MAddXYToParticlesXOnlyClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddXYToParticlesXOnlyClipSkip
    ADD.w   d2,d0 ; X.w+XAdder.w
    MOVE.w  d0,(a1) ; Write
    ADD.w   d3,a1 ; skip Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesXOnlyClipLoop
  RTS;pop
_MAddXYToParticlesXOnlyClipSkip
    ADD.w   d3,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesXOnlyClipLoop
  RTS
_MAddXYToParticlesYOnly
;Add Y.w constant to Y.w coords in particle list
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesYOnlyClip
  MOVEQ.l #4,d3 ; Skip value
  ADD.w   #2,a1 ; Skip X
_MAddXYToParticlesYOnlyLoop
    ADD.w   d2,(a1) ; Y.w+YAdder.w
    ADD.w   d3,a1 ; next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesYOnlyLoop
  RTS
_MAddXYToParticlesYOnlyClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #4,d3 ; Skip value
  ADD.w   #2,a1 ; Skip X
_MAddXYToParticlesYOnlyClipLoop
    MOVE.w  (a1),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MAddXYToParticlesYOnlyClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MAddXYToParticlesYOnlyClipSkip
    ADD.w   d2,d0 ; Y.w+YAdder.w
    MOVE.w  d0,(a1) ; Write
    ADD.w   d3,a1 ; next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesYOnlyClipLoop
  RTS;pop
_MAddXYToParticlesYOnlyClipSkip
    ADD.w   d3,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesYOnlyClipLoop
  RTS

;*************************************************************************************

_MAddXYToParticlesA
;Add Ptr.l constant to Ptr.l entries in particle list. No clipping!
  MOVE.l  d0,a1 ; Particle list
  MOVE.l  d1,d7 ; Copy counter
  AND.b   #$F0,d7 ; Multiples of 16
  BEQ     _MAddXYToParticlesASkip
_MAddXYToParticlesA4Loop
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    ADD.l   d2,(a1)+ ; Ptr.l+PtrAdder.l
    SUB.l   #16,d7 ; Next pixels
    BGT     _MAddXYToParticlesA4Loop
_MAddXYToParticlesASkip
  AND.l   #$0000000F,d1 ; Counter leftover entries
  BEQ     _MAddXYToParticlesASkip2
_MAddXYToParticlesA1Loop
    ADD.l   d2,(a2)+ ; Ptr.l+PtrAdder.l
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesA1Loop
_MAddXYToParticlesASkip2
  RTS

;*************************************************************************************

_MAddXYToParticlesQ
;Add X.q constant to X.q coords, and Y.q constant to Y.q coords, in particle list
  TST.l   d2 ; Add X?
  BEQ     _MAddXYToParticlesQYOnly
  TST.l   d3 ; Add X and Y?
  BEQ     _MAddXYToParticlesQXOnly
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesQClip
_MAddXYToParticlesQLoop
    ADD.l   d2,(a1)+ ; X.q+XAdder.q
    ADD.l   d3,(a1)+ ; Y.q+YAdder.q
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQLoop
  RTS
_MAddXYToParticlesQClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d7,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVE.l  d2,a2
_MAddXYToParticlesQClipLoop
    MOVE.w  (a1),d0 ; Get x
    CMP.w   d7,d0 ; X<X1?
    BLT     _MAddXYToParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddXYToParticlesQClipSkip
    MOVE.w  4(a1),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddXYToParticlesQClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddXYToParticlesQClipSkip
    ADD.l   a2,d0 ; X.q+XAdder.q
    MOVE.l  d0,(a1)+ ; Write
    ADD.l   d3,d2 ; Y.q+YAdder.q
    MOVE.l  d2,(a1)+ ; Write
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQClipLoop
  RTS;pop
_MAddXYToParticlesQClipSkip
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQClipLoop
  RTS
_MAddXYToParticlesQXOnly
;Add X.q constant to X.q coords in particle list
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesQXOnlyClip
  MOVEQ.l #8,d3 ; Skip value
_MAddXYToParticlesQXOnlyLoop
    ADD.l   d2,(a1) ; X.q+XAdder.q
    ADD.w   d3,a1 ; skip Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQXOnlyLoop
  RTS
_MAddXYToParticlesQXOnlyClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d7 ; X1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  ADD.w   d7,d5 ; X2 outside of window
  MOVEQ.l #8,d3 ; Skip value
_MAddXYToParticlesQXOnlyClipLoop
    MOVE.w  (a1),d0 ; Get x
    CMP.w   d7,d0 ; X<X1?
    BLT     _MAddXYToParticlesQXOnlyClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddXYToParticlesQXOnlyClipSkip
    ADD.l   d2,(a1) ; X.w+XAdder.w
    ADD.w   d3,a1 ; skip Y
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQXOnlyClipLoop
  RTS;pop
_MAddXYToParticlesQXOnlyClipSkip
    ADD.w   d3,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQXOnlyClipLoop
  RTS
_MAddXYToParticlesQYOnly
;Add Y.q constant to Y.q coords in particle list
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddXYToParticlesQYOnlyClip
  MOVEQ.l #8,d3 ; Skip value
  ADD.w   #4,a1 ; Skip X
_MAddXYToParticlesQYOnlyLoop
    ADD.l   d2,(a1) ; Y.q+YAdder.q
    ADD.w   d3,a1 ; next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQYOnlyLoop
  RTS
_MAddXYToParticlesQYOnlyClip
;Only move the particles that are within the clip window
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #8,d3 ; Skip value
  ADD.w   #4,a1 ; Skip X
_MAddXYToParticlesQYOnlyClipLoop
    MOVE.w  (a1),d0 ; Get y
    CMP.w   d4,d0 ; Y<Y1?
    BLT     _MAddXYToParticlesQYOnlyClipSkip
    CMP.w   d6,d0 ; Y>=Y2?
    BGE     _MAddXYToParticlesQYOnlyClipSkip
    ADD.l   d2,(a1) ; Y.q+YAdder.q
    ADD.w   d3,a1 ; next
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQYOnlyClipLoop
  RTS;pop
_MAddXYToParticlesQYOnlyClipSkip
    ADD.w   d3,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddXYToParticlesQYOnlyClipLoop
  RTS

;*************************************************************************************

_MParticleModeShort
  MOVE.w  _ParticleModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MParticleMode
;Set blit mode type for particle plot/draw. 4=MColourMode, 5=MReMapMode, 6=MSimpleReMapMode, 7=MAddMode
  CMP.w   #7,d0 ; Too high?
  BGT     _MParticleModeJump
  CMP.w   #4,d0 ; Too low?
  BLT     _MParticleModeJump
  MOVE.w  d0,_ParticleModeType ; Directly copy type number
  RTS
_MParticleModeJump
  MOVE.w  #4,_ParticleModeType ; Default to MColourMode
  RTS

;*************************************************************************************

_MMildredBase
;Return base of Mildred's internal data area
  LEA     _Data(pc),a0
  MOVE.l  a0,d0 ; Return base in d0
  RTS

;*************************************************************************************

_MDrawingModeShort
  MOVE.w  _DrawingModeType,d0
  EXT.l   d0 ; Return current mode in d0
  RTS
_MDrawingMode
;Set drawing mode type for drawing operations
  CMP.w   #8,d0 ; Direct?
  BGE     _MDrawingModeJump
  MOVE.w  d0,_DrawingModeType ; Directly copy type number
  RTS
_MDrawingModeJump
  CMP.w   #_InvMode,d0 ; InvMode?
  BNE     _MDrawingModeSkip
  MOVE.w  #2,_DrawingModeType ; Store type for InvMode
  RTS
_MDrawingModeSkip
  MOVE.w  #4,_DrawingModeType ; Default others to MColourMode
  RTS

;*************************************************************************************

_MParticleFormatShort
  MOVE.b  _ParticleFormat,d0
  EXT.w   d0
  EXT.l   d0 ; Return current format in d0
  RTS
_MParticleFormat
;Set format to use for particle operations. 0=word, <0=quick, >0=address
  MOVE.b  d0,_ParticleFormat ; Directly copy type number
  RTS

;*************************************************************************************

_MPictureDissolveOut
;Wipe out the first-used bitmap using bitmap design d0, currently colour d1, and wipe it to colour in d2
  MOVE.b  d2,d7 ; Wipe-to this colour
  MOVE.b  d1,d2 ; Store colour
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Picture bitmap
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; Dest data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; Picture design data
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Dest wraps?
  BEQ     _MPictureDONoWrap1
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a2
_MPictureDONoWrap1
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Pic wraps?
  BEQ     _MPictureDONoWrap2
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3
_MPictureDONoWrap2
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d5 ; Dest linemod
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d6 ; Picture linemod
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BEQ     _MPictureDONoClip
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),a2
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a0),d5
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a1),a3
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a1),d6
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d0 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d1 ; Height
  BRA     _MPictureDissolveOutSkip2
_MPictureDONoClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0 ; Width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d1 ; Height
_MPictureDissolveOutSkip2
  LSR.w   #2,d0 ; Width/4 for longwords
  SUBQ.w  #1,d0 ; XLoopcounter
  MOVE.w  d0,d3 ; Copy XLoop
  SUBQ.w  #1,d1 ; YLoopcounter
  MOVEQ.l #4,d4 ; Temp skip value
_MPictureDOYLoop
    MOVE.w  d3,d0 ; Copy XLoop
_MPictureDOXLoop
      CMP.b   (a3)+,d2
      BNE     _MPictureDOJump1
      MOVE.b  d7,(a2)
_MPictureDOJump1
      CMP.b   (a3)+,d2
      BNE     _MPictureDOJump2
      MOVE.b  d7,1(a2)
_MPictureDOJump2
      CMP.b   (a3)+,d2
      BNE     _MPictureDOJump3
      MOVE.b  d7,2(a2)
_MPictureDOJump3
      CMP.b   (a3)+,d2
      BNE     _MPictureDOJump4
      MOVE.b  d7,3(a2)
_MPictureDOJump4
      ADD.w   d4,a2
      DBRA    d0,_MPictureDOXLoop
    ADD.w   d5,a2 ; Source linemod
    ADD.w   d6,a3 ; Dest linemod
    DBRA    d1,_MPictureDOYLoop
  MOVE.l  (a7)+,a3 ; Restore
_MPictureDissolveOutSkip
  RTS

;*************************************************************************************

_MBlockUnQueueRangeShort
;Block-UnQueue a range of the queued objects to the dest bitmap by way of a clearscreen. Width and coords should be multiple 16
  !GetQueueObjectPtr ; Base in a0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  SUB.w   d1,d2 ; Find loopcounter
  EXT.l   d1
  LSL.l   #ChunkyQueueListStructSize,d1 ; Offset
  ADD.l   d1,a1 ; Find list item in queue
  MOVE.w  d2,d1 ; Position
  BRA     _MBlockUnQueueShortEntry
_MBlockUnQueueShort
;Block-UnQueue the queued objects to the dest bitmap by way of a clearscreen. Width and coords should be multiple of 16.
  !GetQueueObjectPtr ; Base in a0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  MOVE.w  CQueue_Items-ChunkyQueues(a0),d1 ; Number of items
  SUBQ.w  #1,d1 ; QueueItemLoopcounter
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; Empty
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),CQueue_ItemAddr-ChunkyQueues(a0) ; Empty
_MBlockUnQueueShortEntry
  MOVE.b  CurrentInk1,d4
  MOVE.b  d4,d6
  LSL.w   #8,d6
  MOVE.b  d4,d6
  SWAP    d6
  MOVE.b  d4,d6
  LSL.w   #8,d6
  MOVE.b  d4,d6 ; Colour to draw to (repeated 4 times)
_MBlockUnQueueClsLoop
    MOVE.l  (a1)+,a0 ; Dest address
    MOVE.w  (a1)+,d2 ; Width
    MOVE.w  (a1)+,d3 ; Height
    MOVE.w  d2,d4 ; Copy width
    MOVE.w  d3,d5 ; Copy height
    MOVE.l  (a1)+,d7 ; LineModulo
    LSR.w   #4,d4 ; /16 for groups of 4 longwords
    SUBQ.w  #1,d5 ; YLoopcounter
    ADD.w   #ChunkyQueueListStructBytes-12,a1 ; Skip to next item
    SUBQ.w  #1,d4 ; XLoopcounter
_MBlockUnQueueClsYLoop
      MOVE.w  d4,d2 ; XLoop
_MBlockUnQueueClsXLoop
        MOVE.l  d6,(a0)+ ; Write longword
        MOVE.l  d6,(a0)+ ; Write longword
        MOVE.l  d6,(a0)+ ; Write longword
        MOVE.l  d6,(a0)+ ; Write longword
        DBRA    d2,_MBlockUnQueueClsXLoop
      ADD.w   d7,a0 ; Modulo
      DBRA    d5,_MBlockUnQueueClsYLoop
    DBRA    d1,_MBlockUnQueueClsLoop
  RTS

_MBlockUnQueueRange
;Block-UnQueue a range of queued objects to the dest bitmap by way of a bitmap rubthrough. Width and coords should multiple 16
  !GetQueueObjectPtr ; Base in a0
  MOVE.w  d3,d0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  SUB.w   d1,d2 ; Find loopcounter
  EXT.l   d1
  LSL.l   #ChunkyQueueListStructSize,d1 ; Offset
  ADD.l   d1,a1 ; Find list item in queue
  MOVE.w  d2,d1 ; Position
  BRA     _MBlockUnQueueEntry
_MBlockUnQueue
;Block-UnQueue the queued objects to the dest bitmap by way of a bitmap rubthrough, width and coords should be multiple of 16!
  !GetQueueObjectPtr ; Base in a0
  MOVE.w  d1,d0
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),a1 ; Base of queue
  MOVE.w  CQueue_Items-ChunkyQueues(a0),d1 ; Number of items
  MOVE.w  #0,CQueue_Items-ChunkyQueues(a0) ; Empty
  SUBQ.w  #1,d1 ; QueueItemLoopcounter
  MOVE.l  CQueue_LMem-ChunkyQueues(a0),CQueue_ItemAddr-ChunkyQueues(a0) ; Empty
_MBlockUnQueueEntry
  !GetBitmapObjectPtr ; Base in a0 - bitmap to use
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d5 ; Source Data
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MBlockUnQueueNoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d5
_MBlockUnQueueNoWrap
  MOVE.l  a3,-(a7) ; Store
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),a3
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d4
  TST.b   GeneralCPUmode ; 040?
  BEQ     _MBlockUnQueueBitmap030Loop
_MBlockUnQueueBitmap040Loop
    MOVE.l  (a1)+,a0 ; Dest address
    MOVE.w  d4,d6 ; Copy source width
    MOVE.w  (a1)+,d2 ; Width
    MOVE.l  d5,a2 ; Source base
    MOVE.w  (a1)+,d3 ; Height
    SUB.w   d2,d6 ; Modulo
    MOVE.l  (a1)+,d7 ; Dest LineModulo
    SUBQ.w  #1,d3 ; YLoopcounter
    LSR.w   #4,d2 ; Width/16 for groups of 4 longwords
    ADD.l   (a1)+,a2 ; Position source
    SUBQ.w  #1,d2 ; XLoopcounter
    ADD.w   a3,d6 ; Total modulo
_MBlockUnQueueBitmap040YLoop
      MOVE.w  d2,d0 ; XLoop
_MBlockUnQueueBitmap040XLoop
        Dc.l    #_MOVE16_a2_a0 ; Copy data 16 bytes
        DBRA  d0,_MBlockUnQueueBitmap040XLoop
      ADD.w d6,a2 ; Source linemod to data
      ADD.w d7,a0 ; Dest linemod to data
      DBRA  d3,_MBlockUnQueueBitmap040YLoop
    DBRA  d1,_MBlockUnQueueBitmap040Loop
  MOVE.l (a7)+,a3 ; Restore
  RTS;pop
_MBlockUnQueueBitmap030Loop
    MOVE.l  (a1)+,a0 ; Dest address
    MOVE.w  d4,d6 ; Copy source width
    MOVE.w  (a1)+,d2 ; Width
    MOVE.l  d5,a2 ; Source base
    MOVE.w  (a1)+,d3 ; Height
    SUB.w   d2,d6 ; Modulo
    MOVE.l  (a1)+,d7 ; Dest LineModulo
    SUBQ.w  #1,d3 ; YLoopcounter
    LSR.w   #4,d2 ; Width/16 for groups of 4 longwords
    ADD.l   (a1)+,a2 ; Position source
    SUBQ.w  #1,d2 ; XLoopcounter
    ADD.w   a3,d6 ; Total modulo
_MBlockUnQueueBitmap030YLoop
      MOVE.w  d2,d0 ; XLoop
_MBlockUnQueueBitmap030XLoop
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data
        MOVE.l  (a2)+,(a0)+ ; Copy data ; 16 bytes
        DBRA  d0,_MBlockUnQueueBitmap030XLoop
      ADD.w d6,a2 ; Source linemod to data
      ADD.w d7,a0 ; Dest linemod to data
      DBRA  d3,_MBlockUnQueueBitmap030YLoop
    DBRA  d1,_MBlockUnQueueBitmap030Loop
  MOVE.l (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MWrapXParticles
;Wrap X.w component of X.w,Y.w particles around the left and right of the bitmap. Particles reappear on opposite side
  TST.b   _ParticleFormat ; What format?
  BLT     _MWrapXParticlesQ ; Data is in X.q,Y.q format
  BGT     _MWrapXParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapXParticlesClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
_MWrapXParticlesLoop
    MOVE.w  (a1),d3 ; Read, X<0?
    BLT     _MWrapXParticlesSkip1
    CMP.w   d5,d3 ; X>=X2?
    BGE     _MWrapXParticlesSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesLoop
  RTS
_MWrapXParticlesSkip1
    ADD.w   d5,d3 ; X+Width
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesLoop
  RTS
_MWrapXParticlesSkip2
    SUB.w   d5,d3 ; X-Width
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesLoop
  RTS
_MWrapXParticlesClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  d5,d0 ; Store width
  ADD.w   d3,d5 ; X2 outside of window
_MWrapXParticlesClipLoop
    MOVE.w  (a1),d7 ; Get x
    CMP.w   d3,d7 ; X<X1?
    BLT     _MWrapXParticlesClipSkip1
    CMP.w   d5,d7 ; X>=X2?
    BGE     _MWrapXParticlesClipSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesClipLoop
  RTS
_MWrapXParticlesClipSkip1
    ADD.w   d0,d7 ; X+Width
    MOVE.w  d7,(a1) ; Write X
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesClipLoop
  RTS
_MWrapXParticlesClipSkip2
    SUB.w   d0,d7 ; X-Width
    MOVE.w  d7,(a1) ; Write X
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesClipLoop
  RTS

_MWrapXParticlesA
  ;No X wrap for Ptr.l
  RTS

_MWrapXParticlesQ
;Wrap X.q component of X.q,Y.q particles around left and right sides of the bitmap. Particles reappear on opposite sides
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapXParticlesQClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
_MWrapXParticlesQLoop
    MOVE.w  (a1),d3 ; Read, X<0?
    BLT     _MWrapXParticlesQSkip1
    CMP.w   d5,d3 ; X>=X2?
    BGE     _MWrapXParticlesQSkip2
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQLoop
  RTS
_MWrapXParticlesQSkip1
    ADD.w   d5,d3 ; X+Width
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQLoop
  RTS
_MWrapXParticlesQSkip2
    SUB.w   d5,d3 ; X-Width
    MOVE.w  d3,(a1) ; Write X
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQLoop
  RTS
_MWrapXParticlesQClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  d5,d0 ; Store width
  ADD.w   d3,d5 ; X2 outside of window
_MWrapXParticlesQClipLoop
    MOVE.w  (a1),d7 ; Get x
    CMP.w   d3,d7 ; X<X1?
    BLT     _MWrapXParticlesQClipSkip1
    CMP.w   d5,d7 ; X>=X2?
    BGE     _MWrapXParticlesQClipSkip2
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQClipLoop
  RTS
_MWrapXParticlesQClipSkip1
    ADD.w   d0,d7 ; X+Width
    MOVE.w  d7,(a1) ; Write X
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQClipLoop
  RTS
_MWrapXParticlesQClipSkip2
    SUB.w   d0,d7 ; X-Width
    MOVE.w  d7,(a1) ; Write X
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapXParticlesQClipLoop
  RTS

;*************************************************************************************

_MWrapYParticles
;Wrap Y.w component of X.w,Y.w particles around the top and bottom of the bitmap. Particles reappear at opposite edge
  TST.b   _ParticleFormat ; What format?
  BLT     _MWrapYParticlesQ ; Data is in X.q,Y.q format
  BGT     _MWrapYParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapYParticlesClip
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
  ADD.w   #2,a1 ; Skip first X
_MWrapYParticlesLoop
    MOVE.w  (a1),d4 ; Read, Y<0?
    BLT     _MWrapYParticlesSkip1
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MWrapYParticlesSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesLoop
  RTS
_MWrapYParticlesSkip1
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d4,(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesLoop
  RTS
_MWrapYParticlesSkip2
    SUB.w   d6,d4 ; Y-Height
    MOVE.w  d4,(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesLoop
  RTS
_MWrapYParticlesClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  MOVE.w  d6,d2 ; Store height
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #2,a1 ; Skip first X
_MWrapYParticlesClipLoop
    MOVE.w  (a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapYParticlesClipSkip1
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapYParticlesClipSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesClipLoop
  RTS
_MWrapYParticlesClipSkip1
    ADD.w   d2,d7 ; Y+Height
    MOVE.w  d7,(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesClipLoop
  RTS
_MWrapYParticlesClipSkip2
    SUB.w   d2,d7 ; Y-Height
    MOVE.w  d7,(a1) ; Write Y
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesClipLoop
  RTS

_MWrapYParticlesA
;Wrap Ptr.l particles around the higher and lower bounds of the bitmap. Particles reappear at opposite side to which they left
  MOVE.l  d0,a1 ; Particle list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  CRsrc_Data-ChunkyResources(a0),d5 ; Base
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     _MWrapYParticlesANoWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),d5
_MWrapYParticlesANoWrap
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapYParticlesAClip
  MOVE.w  CRsrc_TotWidth-ChunkyResources(a0),d6 ; Get total width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d3 ; Get height
  MULU    d3,d6 ; Total bytes
  MOVE.l  d6,d4 ; Store
  ADD.l   d5,d6 ; d6=Highest address (1 past)
_MWrapYParticlesALoop
    MOVE.l  (a1),d3 ; Get long
    CMP.l   d5,d3 ; Lower?
    BLT     _MWrapYParticlesASkip1
    CMP.l   d6,d3 ; Higher or equal?
    BGE     _MWrapYParticlesASkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesALoop
  RTS
_MWrapYParticlesASkip1
    ADD.l   d4,d3 ; Address+Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesALoop
  RTS
_MWrapYParticlesASkip2
    SUB.l   d4,d3 ; Address-Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesALoop
  RTS
_MWrapYParticlesAClip
;Only wrap the particles that are within clip window bounds
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d2 ; temp
  MOVE.w  d2,d6 ; Get width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d3 ; Get height
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d4 ; temp
  ADD.w   d4,d6 ; Total width
  MULU    d3,d6 ; Total bytes
  EXT.l   d4
  SUB.l   d4,d6 ; For end
  MOVE.w  CRsrc_ClipLMod-ChunkyResources(a0),d4
  EXT.l   d4
  SUB.l   d4,d6 ; For end
  MOVE.l  d6,d4 ; Store
  ADD.l   CRsrc_ClipBytes-ChunkyResources(a0),d5 ; Lowest address
  ADD.l   d5,d6 ; Highest address (1 past)
_MWrapYParticlesAClipLoop
    MOVE.l  (a1),d3 ; Get long
    CMP.l   d5,d3 ; Lower?
    BLT     _MWrapYParticlesAClipSkip1
    CMP.l   d6,d3 ; Higher or equal?
    BGE     _MWrapYParticlesAClipSkip2
    ADD.w   #4,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesAClipLoop
  RTS
_MWrapYParticlesAClipSkip1
    ADD.l   d4,d3 ; Address+Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesAClipLoop
  RTS
_MWrapYParticlesAClipSkip2
    SUB.l   d4,d3 ; Address-Bytes
    MOVE.l  d3,(a1)+ ; Write address
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesAClipLoop
  RTS

_MWrapYParticlesQ
;Wrap Y.q component of X.q,Y.q particles around the top and bottom of the bitmap. Particles reappear at opposite edge
  MOVE.l  d0,a1 ; Coordinate list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MWrapYParticlesQClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d5 ; Width X2
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d6 ; Height Y2
  ADD.w   #4,a1 ; Skip first X
_MWrapYParticlesQLoop
    MOVE.w  (a1),d4 ; Read, Y<0?
    BLT     _MWrapYParticlesQSkip1
    CMP.w   d6,d4 ; Y>=Y2?
    BGE     _MWrapYParticlesQSkip2
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQLoop
  RTS
_MWrapYParticlesQSkip1
    ADD.w   d6,d4 ; Y+Height
    MOVE.w  d4,(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQLoop
  RTS
_MWrapYParticlesQSkip2
    SUB.w   d6,d4 ; Y-Height
    MOVE.w  d4,(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQLoop
  RTS
_MWrapYParticlesQClip
;Only wrap the particles that are outside of the clip window
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  MOVE.w  d6,d2 ; Store height
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #4,a1 ; Skip first X
_MWrapYParticlesQClipLoop
    MOVE.w  (a1),d7 ; Get y
    CMP.w   d4,d7 ; Y<Y1?
    BLT     _MWrapYParticlesQClipSkip1
    CMP.w   d6,d7 ; Y>=Y2?
    BGE     _MWrapYParticlesQClipSkip2
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQClipLoop
  RTS
_MWrapYParticlesQClipSkip1
    ADD.w   d2,d7 ; Y+Height
    MOVE.w  d7,(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQClipLoop
  RTS
_MWrapYParticlesQClipSkip2
    SUB.w   d2,d7 ; Y-Height
    MOVE.w  d7,4(a1) ; Write Y
    ADD.w   #8,a1
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MWrapYParticlesQClipLoop
  RTS

;*************************************************************************************

_MAddToXParticlesShort
  MOVEQ.l #0,d3 ; No second list
_MAddToXParticles
;Add X.w increments to X.w coords and ignore Y increments/coords, in particle list
  TST.b   _ParticleFormat ; What format?
  BLT     _MAddToXParticlesQ ; Data is in X.q,Y.q format
  BGT     _MAddToXParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list A
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToXParticlesClip
  TST.l   d3 ; Two adds?
  BNE     _MAddToXParticles2
  MOVEQ.l #4,d7 ; Skip value
_MAddToXParticlesLoop
    MOVE.w  (a1),d3 ; Read
    ADD.w   d7,a1
    ADD.w   d3,(a2) ; X.w+XAdder.w
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesLoop
  RTS
_MAddToXParticles2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
  MOVEQ.l #4,d7 ; Skip value
_MAddToXParticles2Loop
    MOVE.w  (a2),d3 ; Read list
    ADD.w   (a1),d3 ; X.w+XAdderA.w
    ADD.w   d7,a1
    ADD.w   (a3),d3 ; X.w+XAdderB.w
    ADD.w   d7,a3
    MOVE.w  d3,(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticles2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToXParticlesClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two adds?
  BNE     _MAddToXParticlesClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #4,d7 ; Skip value
_MAddToXParticlesClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToXParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToXParticlesClipSkip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToXParticlesClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToXParticlesClipSkip
    ADD.w   (a1),d0 ; X.w+XAdder.w
    ADD.w   d7,a1
    MOVE.w  d0,(a2) ; Write X
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesClipLoop
  RTS;pop
_MAddToXParticlesClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesClipLoop
  RTS;pop
_MAddToXParticlesClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #4,d7 ; Skip value
_MAddToXParticlesClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToXParticlesClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToXParticlesClip2Skip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToXParticlesClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToXParticlesClip2Skip
    ADD.w   (a1),d0 ; X.w+XAdderA.w
    ADD.w   d7,a1
    ADD.w   (a3),d0 ; X.w+XAdderB.w
    ADD.w   d7,a3
    MOVE.w  d0,(a2) ; Write X
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToXParticlesClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a3
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MAddToXParticlesA
  ; Can't add X to Ptr.l (use MAddToParticles with MParticleFormat 1 )
  RTS

_MAddToXParticlesQ
;Add X.q increments to X.q coords, and ignore Y.q increments/coords, in particle list
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToXParticlesQClip
  TST.l   d3 ; Second list?
  BNE     _MAddToXParticlesQ2
  MOVEQ.l #8,d7 ; Skip value
_MAddToXParticlesQLoop
    MOVE.l  (a1),d3 ; Read
    ADD.w   d7,a1
    ADD.l   d3,(a2) ; X.q+XAdder.q
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQLoop
  RTS
_MAddToXParticlesQ2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
  MOVEQ.l #8,d7
_MAddToXParticlesQ2Loop
    MOVE.l  (a2),d3  ; Read
    ADD.w   d7,a2
    ADD.l   (a1),d3 ; X.q+XAdderA.q
    ADD.w   d7,a1
    ADD.l   (a3),d3 ; X.q+XAdderA.q
    ADD.w   d7,a3
    MOVE.l  d3,(a2) ; Write X
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQ2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToXParticlesQClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two lists?
  BNE     _MAddToXParticlesQClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #8,d7 ; Skip value
_MAddToXParticlesQClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToXParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToXParticlesQClipSkip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToXParticlesQClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToXParticlesQClipSkip
    SWAP    d0 ; Make integer portion of x
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    ADD.l   (a1),d0 ; X.q=XAdder.q
    ADD.w   d7,a1
    MOVE.l  d0,(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQClipLoop
  RTS;pop
_MAddToXParticlesQClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQClipLoop
  RTS
_MAddToXParticlesQClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  MOVEQ.l #8,d7 ; Skip value
_MAddToXParticlesQClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToXParticlesQClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToXParticlesQClip2Skip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToXParticlesQClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToXParticlesQClip2Skip
    SWAP    d0 ; Make integer portion of x
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    ADD.l   (a1),d0 ; X.q+XAdderA.q
    ADD.w   d7,a1
    ADD.l   (a3)+,d0 ; X.q+XAdderB.q
    ADD.w   d7,a3
    MOVE.l  d0,(a2) ; Write X
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToXParticlesQClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a2
    ADD.w   d7,a3
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToXParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MAddToYParticlesShort
  MOVEQ.l #0,d3 ; No second list
_MAddToYParticles
;Add Y.w increments to Y.w coords, and ignore X.w increments/ coords, in particle list
  TST.b   _ParticleFormat ; What format?
  BLT     _MAddToYParticlesQ ; Data is in X.q,Y.q format
  BGT     _MAddToYParticlesA ; Data is in Ptr.l format
  ;Data is in X.w,Y.w format
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list A
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToYParticlesClip
  TST.l   d3 ; Two adds?
  BNE     _MAddToYParticles2
  ADD.w   #2,a1 ; Skip first X
  ADD.w   #2,a2 ; Skip first X
  MOVEQ.l #4,d7 ; Skip value
_MAddToYParticlesLoop
    MOVE.w  (a1),d4 ; Read
    ADD.w   d7,a1
    ADD.w   d4,(a2) ; Y.w+YAdder.w
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesLoop
  RTS
_MAddToYParticles2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
  ADD.w   #2,a1 ; Skip first X
  ADD.w   #2,a2 ; Skip first X
  ADD.w   #2,a3 ; Skip first X
  MOVEQ.l #4,d7 ; Skip value
_MAddToYParticles2Loop
    MOVE.w  (a2),d4 ; Read list
    ADD.w   (a1),d4 ; Y.w+YAdderA.w
    ADD.w   d7,a1
    ADD.w   (a3),d4 ; Y.w+YAdderB.w
    ADD.w   d7,a3
    MOVE.w  d4,(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticles2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToYParticlesClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two adds?
  BNE     _MAddToParticlesClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #2,a1 ; Skip first X
  MOVEQ.l #4,d7 ; Skip value
_MAddToYParticlesClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToYParticlesClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToYParticlesClipSkip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToYParticlesClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToYParticlesClipSkip
    ADD.w   (a1),d2 ; Y.w+YAdder.w
    ADD.w   d7,a1
    MOVE.w  d2,2(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesClipLoop
  RTS;pop
_MAddToYParticlesClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesClipLoop
  RTS;pop
_MAddToYParticlesClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Increment list B
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #2,a1 ; Skip first X
  ADD.w   #2,a3 ; Skip first X
  MOVEQ.l #4,d7 ; Skip value
_MAddToYParticlesClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToYParticlesClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToYParticlesClip2Skip
    MOVE.w  2(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToYParticlesClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToYParticlesClip2Skip
    ADD.w   (a1),d2 ; Y.w+YAdderA.w
    ADD.w   d7,a1
    ADD.w   (a3),d2 ; Y.w+YAdderB.w
    ADD.w   d7,a3
    MOVE.w  d2,2(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToYParticlesClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a3
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

_MAddToYParticlesA
  ; Can't add Y to Ptr.l (use MAddToParticles and MParticleFormat 1 )
  RTS

_MAddToYParticlesQ
;Add Y.q increments to Y.q coords, and ignore X.q increments/coords, in particle list
  MOVE.l  d0,a2 ; Particle list
  MOVE.l  d2,a1 ; Increment list
  MOVE.w  CurrentChunkyBitmap1,d0
  !GetBitmapObjectPtr ; Base in a0
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BNE     _MAddToYParticlesQClip
  TST.l   d3 ; Second list?
  BNE     _MAddToYParticlesQ2
  ADD.w   #4,a1 ; Skip first X
  ADD.w   #4,a2 ; Skip first X
  MOVEQ.l #8,d7 ; Skip value
_MAddToYParticlesQLoop
    MOVE.l  (a1),d4 ; Read
    ADD.w   d7,a1
    ADD.l   d4,(a2) ; Y.q+YAdder.q
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQLoop
  RTS
_MAddToYParticlesQ2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
  ADD.w   #4,a1 ; Skip first X
  ADD.w   #4,a2 ; Skip first X
  ADD.w   #4,a3 ; Skip first X
  MOVEQ.l #8,d7 ; Skip value
_MAddToYParticlesQ2Loop
    MOVE.l  (a2),d4 ; Read
    ADD.l   (a1),d4 ; Y.q+YAdderA.q
    ADD.w   d7,a1
    ADD.l   (a3),d4 ; Y.q+YAdderB.q
    ADD.w   d7,a3
    MOVE.l  d4,(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQ2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS
_MAddToYParticlesQClip
;Only move the particles that are within the clip window
  TST.l   d3 ; Two lists?
  BNE     _MAddToYParticlesQClip2
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #4,a1 ; Skip first X
  MOVEQ.l #8,d7 ; Skip value
_MAddToYParticlesQClipLoop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToYParticlesQClipSkip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToYParticlesQClipSkip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToYParticlesQClipSkip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToYParticlesQClipSkip
    SWAP    d0 ; Make integer portion of x
    SWAP    d2 ; Make integer portion of y
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    MOVE.w  6(a2),d2 ; Get decimal portion of y
    ADD.l   (a1),d2 ; Y.q+YAdder.q
    ADD.w   d7,a1
    MOVE.l  d2,(a2) ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQClipLoop
  RTS;pop
_MAddToYParticlesQClipSkip
    ADD.w   d7,a1
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQClipLoop
  RTS
_MAddToYParticlesQClip2
  MOVE.l  a3,-(a7) ; Store
  MOVE.l  d3,a3 ; a3=Second list
  MOVE.w  CRsrc_ClipLeft-ChunkyResources(a0),d3 ; X1
  MOVE.w  CRsrc_ClipTop-ChunkyResources(a0),d4 ; Y1
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d5 ; Width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d6 ; Height
  ADD.w   d3,d5 ; X2 outside of window
  ADD.w   d4,d6 ; Y2 outside of window
  ADD.w   #4,a1 ; Skip first X
  ADD.w   #4,a3 ; Skip first X
  MOVEQ.l #8,d7 ; Skip value
_MAddToYParticlesQClip2Loop
    MOVE.w  (a2),d0 ; Get x
    CMP.w   d3,d0 ; X<X1?
    BLT     _MAddToYParticlesQClip2Skip
    CMP.w   d5,d0 ; X>=X2?
    BGE     _MAddToYParticlesQClip2Skip
    MOVE.w  4(a2),d2 ; Get y
    CMP.w   d4,d2 ; Y<Y1?
    BLT     _MAddToYParticlesQClip2Skip
    CMP.w   d6,d2 ; Y>=Y2?
    BGE     _MAddToYParticlesQClip2Skip
    SWAP    d0 ; Make integer portion of x
    SWAP    d2 ; Make integer portion of y
    MOVE.w  2(a2),d0 ; Get decimal portion of x
    MOVE.w  6(a2),d0 ; Get decimal portion of y
    ADD.l   (a1),d2 ; Y.q+YAdderA.q
    ADD.w   d7,a1
    ADD.l   (a3),d2 ; Y.q+YAdderB.q
    ADD.w   d7,a3
    MOVE.l  d2,(a2)+ ; Write
    ADD.w   d7,a2
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS;pop
_MAddToYParticlesQClip2Skip
    ADD.w   d7,a1
    ADD.w   d7,a2
    ADD.w   d7,a3
    SUBQ.l  #1,d1 ; Next pixel
    BGT     _MAddToYParticlesQClip2Loop
  MOVE.l  (a7)+,a3 ; Restore
  RTS

;*************************************************************************************

_MZoomShort
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0 - source
  MOVE.l  a0,a1 ; Dest
  BRA     _MZoomJump
_MZoom
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source bitmap
  !GetBitmapObjectPtr; Base in a0 - source
_MZoomJump
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS
_MZoomCustom
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source bitmap
  !GetBitmapObjectPtr; Base in a0 - source
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformCustomZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MZoomShapeShort
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shap
  !GetShapeObjectPtr ; Base in a0 - source
  MOVE.l  a0,a1 ; Dest
  BRA     _MZoomShapeJump
_MZoomShape
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shape
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source shape
  !GetShapeObjectPtr; Base in a0 - source
_MZoomShapeJump
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS
_MZoomShapeCustom
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shape
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source shape
  !GetShapeObjectPtr; Base in a0 - source
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformCustomZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MZoomBitmapToShapeShort
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shape
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  CurrentChunkyBitmap1,d0 ; Source bitmap
  !GetBitmapObjectPtr ; Base in a0 - source
  BRA     _MZoomBitmapToShapeJump
_MZoomBitmapToShape
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shape
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source bitmap
  !GetBitmapObjectPtr; Base in a0 - source
_MZoomBitmapToShapeJump
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS
_MZoomBitmapToShapeCustom
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyShape1,d0 ; Dest shape
  !GetShapeObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source bitmap
  !GetBitmapObjectPtr; Base in a0 - source
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformCustomZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

_MZoomShapeToBitmapShort
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  CurrentChunkyShape1,d0 ; Source shape
  !GetShapeObjectPtr ; Base in a0 - source
  BRA     _MZoomShapeToBitmapJump
_MZoomShapeToBitmap
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source shape
  !GetShapeObjectPtr; Base in a0 - source
_MZoomShapeToBitmapJump
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS
_MZoomShapeToBitmapCustom
  MOVEM.l a3-a6,-(a7) ; Store
  MOVE.l  d0,a5 ; a5=SrcX.q
  MOVE.l  d1,a6 ; a6=SrcY.q
  MOVE.w  CurrentChunkyBitmap1,d0 ; Dest bitmap
  !GetBitmapObjectPtr ; Base in a0
  MOVE.l  a0,a1 ; Dest
  MOVE.w  -8(a2),d0 ; Source shape
  !GetShapeObjectPtr; Base in a0 - source
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a3 ; Source data
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a4 ; Dest data
  BSR     PerformCustomZoom
  MOVEM.l (a7)+,a3-a6 ; Restore
  RTS

;*************************************************************************************

._MAddMode
;Return value 7 to represent `Add' mode for blits
  MOVEQ.l #7,d0
  RTS

;*************************************************************************************

.Subroutines

InitialiseRegs
;Initialise registers for a graphic operation
;OperationSource=Data, OperationDest=Stencil, same resource
;Trashes d6
;a0=Source struct
;Returns d0=Width
;Returns d1=Height
;Returns a1=SourceAddress
;Returns a2=DestAddress
;Returns d7=LineModulo (LineMod+ClipLMod)
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a1 ; source
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a2 ; dest
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d7 ; modulo
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BEQ     InitRegsNoClip
  MOVE.l  CRsrc_ClipBytes-ChunkyResources(a0),d6 ; Temp
  ADD.l   d6,a1 ; Point to clip topleft in data
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a0),d7 ; TotalModulo
  ADD.l   d6,a2 ; Point to clip topleft in stencil
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d0 ; width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d1 ; height
  BRA     InitRegsSkip
InitRegsNoClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0 ; width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d1 ; height
InitRegsSkip
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     InitRegsNoWrap
  MOVE.l  CRsrc_WrapBytes-ChunkyResources(a0),d6 ; Temp
  ADD.l   d6,a1 ; Point to handle topleft in data
  ADD.l   d6,a2 ; Point to handle topleft in stencil
InitRegsNoWrap
  EXT.l   d7
  RTS

InitialiseRegs2
;Initialise registers for a graphic operation
;OperationSource&Dest=Data/Stencil preloaded in a1
;Trashes d6
;a0=Source struct
;a1=Data/Stencil base-pointer
;Returns d0=Width
;Returns d1=Height
;Returns a1=Address
;Returns d7=LineModulo (LineMod+ClipLMod)
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d7 ; modulo
  TST.b   CRsrc_Clipping-ChunkyResources(a0) ; Clip?
  BEQ     InitRegs2NoClip
  MOVE.l  CRsrc_ClipBytes-ChunkyResources(a0),d6 ; Temp
  ADD.w   CRsrc_ClipLMod-ChunkyResources(a0),d7 ; TotalModulo
  ADD.l   d6,a1 ; Point to clip topleft in data
  MOVE.w  CRsrc_ClipWidth-ChunkyResources(a0),d0 ; width
  MOVE.w  CRsrc_ClipHight-ChunkyResources(a0),d1 ; height
  BRA     InitRegs2Skip
InitRegs2NoClip
  MOVE.w  CRsrc_Width-ChunkyResources(a0),d0 ; width
  MOVE.w  CRsrc_Height-ChunkyResources(a0),d1 ; height
InitRegs2Skip
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Wrap?
  BEQ     InitRegs2NoWrap
  MOVE.l  CRsrc_WrapBytes-ChunkyResources(a0),d6 ; Temp
  ADD.l   d6,a1 ; Point to handle topleft in data
InitRegs2NoWrap
  EXT.l   d7
  RTS

InitialiseRegs3
;Initialise registers for a graphic operation (ignores clip) (assumes `safe' parameters)
;OperationSource=Data/Stencil, OperationDest=Data/Stencil, different resources
;a0=Source struct
;a1=Dest struct
;d2=X1 source
;d3=Y1 source
;d4=X2 dest
;d5=Y2 dest
;Returns a2=Source DataAddress
;Returns a3=Dest DataAddress (make sure you preserve/restore)
;Returns a4=Source StencilAddress (make sure you preserve/restore)
;Returns a5=Dest StencilAddress (make sure you preserve/restore)
;Returns d6=Source LineModulo (LineMod+ClipLMod)
;Returns d7=Dest LineModulo (LineMod+ClipMod)
;Trashes d0-d7/a2-a5
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a4 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest data
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a5 ; dest stencil
InitialiseRegs3Entry ; Entry point for InitRegs4
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  EXT.l   d6
  EXT.l   d7
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Source wrap?
  BEQ     InitRegs3NoSWrap
  MOVE.l  CRsrc_WrapBytes-ChunkyResources(a0),d0 ; Temp
  ADD.l   d0,a2 ; Point to handle topleft in source data
  ADD.l   d0,a4 ; Point to handle topleft in source stencil
InitRegs3NoSWrap
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     InitRegs3NoDWrap
  MOVE.l  CRsrc_WrapBytes-ChunkyResources(a1),d0 ; Temp
  ADD.l   d0,a3 ; Point to handle topleft in dest data
  ADD.l   d0,a5 ; Point to handle topleft in dest stencil
InitRegs3NoDWrap
  MOVE.w  d6,d0 ; Temp
  ADD.w   CRsrc_Width-ChunkyResources(a0),d0
  MULU    d0,d3
  EXT.l   d2
  ADD.l   d2,d3 ; Source coordinate offset
  ADD.l   d3,a2 ; X1,Y1 in source data
  ADD.l   d3,a4 ; X1,Y1 in source stencil
  MOVE.w  d7,d0 ; Temp
  ADD.w   CRsrc_Width-ChunkyResources(a1),d0
  MULU    d0,d5
  EXT.l   d4
  ADD.l   d4,d5 ; Dest coordinate offset
  ADD.l   d5,a3 ; X2,Y2 in dest data
  ADD.l   d5,a5 ; X2,Y2 in dest stencil
  RTS

InitialiseRegs4
;Initialise registers for a graphic operation (ignores clip) (assumes `safe' parameters)
;OperationSource=Stencil, OperationDest=Stencil, different resources
;a0=Source struct
;a1=Dest struct
;d2=X1 source
;d3=Y1 source
;d4=X2 dest
;d5=Y2 dest
;Returns a2=Source DataAddress
;Returns a3=Dest DataAddress (make sure you preserve/restore)
;Returns a4=Source StencilAddress (make sure you preserve/restore)
;Returns a5=Dest StencilAddress (make sure you preserve/restore)
;Returns d6=Source LineModulo (LineMod+ClipLMod)
;Returns d7=Dest LineModulo (LineMod+ClipMod)
;Trashes d0-d7/a2-a5
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a2 ; source data is stencil
  MOVE.l  a2,a4 ; source stencil
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a3 ; dest data is stencil
  MOVE.l  a3,a5 ; dest stencil
  BRA     InitialiseRegs3Entry
  RTS;Wont be taken

InitialiseRegs5
;Initialise registers for a graphic operation (ignores clip) (assumes `safe' parameters)
;OperationSource=Data, OperationDest=Data, different resources no stencil
;a0=Source struct
;a1=Dest struct
;d2=X1 source
;d3=Y1 source
;d4=X2 dest
;d5=Y2 dest
;Returns a2=Source DataAddress
;Returns a3=Dest DataAddress (make sure you preserve/restore)
;Returns d6=Source LineModulo (LineMod+ClipLMod)
;Returns d7=Dest LineModulo (LineMod+ClipMod)
;Trashes d0/d3/d5
  MOVE.l  CRsrc_Data-ChunkyResources(a0),a2 ; source stencil
  MOVE.l  CRsrc_Data-ChunkyResources(a1),a3 ; dest stencil
InitialiseRegs5Entry ; Entrypoint from InitRegs5
  MOVE.w  CRsrc_LineMod-ChunkyResources(a0),d6 ; source modulo
  MOVE.w  CRsrc_LineMod-ChunkyResources(a1),d7 ; dest modulo
  EXT.l   d6
  EXT.l   d7
  TST.b   CRsrc_Wrapping-ChunkyResources(a0) ; Source wrap?
  BEQ     InitRegs5NoSWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a0),a2 ; Point to handle topleft in source data
InitRegs5NoSWrap
  TST.b   CRsrc_Wrapping-ChunkyResources(a1) ; Dest wrap?
  BEQ     InitRegs5NoDWrap
  ADD.l   CRsrc_WrapBytes-ChunkyResources(a1),a3 ; Point to handle topleft in dest data
InitRegs5NoDWrap
  MOVE.w  d6,d0 ; Temp
  ADD.w   CRsrc_Width-ChunkyResources(a0),d0
  MULU.w  d0,d3
  EXT.l   d2
  ADD.l   d2,d3 ; Source coordinate offset
  ADD.l   d3,a2 ; X1,Y1 in source data
  MOVE.w  d7,d0 ; Temp
  ADD.w   CRsrc_Width-ChunkyResources(a1),d0
  MULU    d0,d5
  EXT.l   d4
  ADD.l   d4,d5 ; Dest coordinate offset
  ADD.l   d5,a3 ; X2,Y2 in dest data
  RTS

InitialiseRegs6
;Initialise registers for a graphic operation (ignores clip) (assumes `safe' parameters)
;OperationSource=Stencil, OperationDest=Stencil, different resources no stencil
;a0=Source struct
;a1=Dest struct
;d2=X1 source
;d3=Y1 source
;d4=X2 dest
;d5=Y2 dest
;Returns a2=Source StencilAddress
;Returns a3=Dest StencilAddress (make sure you preserve/restore)
;Returns d6=Source LineModulo (LineMod+ClipLMod)
;Returns d7=Dest LineModulo (LineMod+ClipMod)
;Trashes d0/d3/d5
  MOVE.l  CRsrc_Stencil-ChunkyResources(a0),a2 ; source stencil
  MOVE.l  CRsrc_Stencil-ChunkyResources(a1),a3 ; dest stencil
  BRA     InitialiseRegs5Entry
  RTS;Wont be taken

PerformGenericBlit
;Do a general blit, width should be multiple of 4
;Copies data and stencil
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.b  d3,d5 ; Copy width
  AND.b   #$0F,d5 ; Multiple of 16?
  BEQ     PerfGenBlit_16 ; yep
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlitYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlitXLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA  d0,PerfGenBlitXLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlitYLoop
  RTS;pop
PerfGenBlit_16
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit_16YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit_16XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA  d0,PerfGenBlit_16XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit_16YLoop
  RTS

PerformGenericBlit2
;Do a general blit, width does not have to be multiple
;Copies data only
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  BLT     PerfGenBlit2Normal ; No extraneous bytes to check for
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit2NoLongwords
PerfGenBlit2YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      DBRA  d0,PerfGenBlit2XLoop
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit2XLoop2
      MOVE.b  (a2)+,(a3)+ ; Copy data
      DBRA    d0,PerfGenBlit2XLoop2
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2YLoop
  RTS ; pop
PerfGenBlit2NoLongwords
PerfGenBlit2YLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit2XLoop3
      MOVE.b  (a2)+,(a3)+ ; Copy data
      DBRA    d0,PerfGenBlit2XLoop3
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2YLoop2
  RTS
PerfGenBlit2Normal
  MOVE.b  d3,d5 ; Copy width
  AND.b   #$0F,d5 ; Multiple of 16?
  BEQ     PerfGenBlit2Norm_16 ; yep
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit2NormYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2NormXLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      DBRA  d0,PerfGenBlit2NormXLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2NormYLoop
  RTS;pop
PerfGenBlit2Norm_16
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit2Norm_16YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2Norm_16XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a2)+,(a3)+ ; Copy data
      DBRA  d0,PerfGenBlit2Norm_16XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2Norm_16YLoop
  RTS

PerformGenericBlit2b
;Do a general blit, width does not have to be multiple
;Copies data only
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  BLT     PerfGenBlit2bNormal
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit2bNoLongwords
PerfGenBlit2bYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2bXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      DBRA  d0,PerfGenBlit2bXLoop
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit2bXLoop2
      MOVE.b  -(a2),-(a3) ; Copy data
      DBRA    d0,PerfGenBlit2bXLoop2
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2bYLoop
  RTS ; pop
PerfGenBlit2bNoLongwords
PerfGenBlit2bYLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit2bXLoop3
      MOVE.b  -(a2),-(a3) ; Copy data
      DBRA    d0,PerfGenBlit2bXLoop3
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2bYLoop2
  RTS
PerfGenBlit2bNormal
  MOVE.b  d3,d5 ; Copy width
  AND.b   #$0F,d5 ; Multiple of 16?
  BEQ     PerfGenBlit2bNorm_16 ; yep
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit2bNormYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2bNormXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      DBRA  d0,PerfGenBlit2bNormXLoop
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2bNormYLoop
  RTS;pop
PerfGenBlit2bNorm_16
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit2bNorm_16YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit2bNorm_16XLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a2),-(a3) ; Copy data
      DBRA  d0,PerfGenBlit2bNorm_16XLoop
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit2bNorm_16YLoop
  RTS

PerformGenericBlit2Custom
;Do a general blit, width does not have to be multiple
;Copies data only, offsets each line using OffsetList
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a4 ; Store specified width
PerfGenBlit2CustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.w  a4,d1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    SUB.w   d3,d1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    ADD.w   (a6)+,a2 ; Source X1 offset, relative to previous line
    SUBQ.w  #1,d5 ; ByteLoop
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a3 ; Dest X2 offset, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit2CustomNoLongwords
PerfGenBlit2CustomXLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      DBRA  d3,PerfGenBlit2CustomXLoop
PerfGenBlit2CustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit2CustomNoBytes
PerfGenBlit2CustomXLoop2
        MOVE.b  (a2)+,(a3)+ ; Copy data
        DBRA    d5,PerfGenBlit2CustomXLoop2
PerfGenBlit2CustomNoBytes
    ADD.w d1,a2 ; Extra linemod caused by width change
    ADD.w d1,a3 ; Extra linemod caused by width change
    ADD.w (a6)+,a2 ; Absolute extra source linemodulo
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d6,a2 ; Source linemod to data
    DBRA  d4,PerfGenBlit2CustomYLoop
  RTS ; pop

PerformGenericBlit2bCustom
;Do a general blit, width does not have to be multiple
;Copies data only, offsets each line using OffsetList, as GenBlit2Custom but backwards
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a4 ; Store specified width
PerfGenBlit2bCustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.w  a4,d1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    SUB.w   d3,d1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    ADD.w   (a6)+,a2 ; Source X1 offset, relative to previous line
    SUBQ.w  #1,d5 ; ByteLoop
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a3 ; Dest X2 offset, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit2bCustomNoLongwords
PerfGenBlit2bCustomXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      DBRA  d3,PerfGenBlit2bCustomXLoop
PerfGenBlit2bCustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit2bCustomNoBytes
PerfGenBlit2bCustomXLoop2
        MOVE.b  -(a2),-(a3) ; Copy data
        DBRA    d5,PerfGenBlit2bCustomXLoop2
PerfGenBlit2bCustomNoBytes
    SUB.w d1,a2 ; Extra linemod caused by width change
    SUB.w d1,a3 ; Extra linemod caused by width change
    ADD.w (a6)+,a2 ; Absolute extra source linemodulo
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d6,a2 ; Source linemod to data
    DBRA  d4,PerfGenBlit2bCustomYLoop
  RTS ; pop

PerformGenericBlit3
;Do a general stencilled-blit, width should be multiple of 4
;Copies data using stencil for cookie-cut
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;Trashes many
  MOVE.w  SScrollModeType,d0
  BRA     PerformBlit1
  RTS     ; Precaution

PerformGenericBlit3b ; Same as GenericBlit3 but in reverse
;Do a general stencilled-blit, width should be multiple of 4
;Copies data using stencil for cookie-cut
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;Trashes many
  MOVE.w  SScrollModeType,d0
  BRA     PerformBlit1b
  RTS     ; Precaution

PerformGenericBlit4
;Do a general block-blit, width should be multiple of 16 and lie on 16-byte aligned addresses
;Copies data only
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.w  d3,d5 ; Copy width
  AND.b   #$3F,d5 ; Multiple of 64?
  BEQ     PerfGenBlit4_64
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit4_030
PerfGenBlit4_040
PerfGenBlit4_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      DBRA  d0,PerfGenBlit4_040XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit4_040YLoop
  RTS;pop
PerfGenBlit4_030
PerfGenBlit4_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4_030XLoop
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      DBRA  d0,PerfGenBlit4_030XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit4_030YLoop
  RTS
PerfGenBlit4_64
  LSR.w   #6,d3 ; Width/64 for groups of 16 longwords (64 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit4_64_030
PerfGenBlit4_64_040
PerfGenBlit4_64_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4_64_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+ ; Copy 64 bytes
      DBRA  d0,PerfGenBlit4_64_040XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit4_64_040YLoop
  RTS;pop
PerfGenBlit4_64_030
PerfGenBlit4_64_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4_64_030XLoop
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+
      MOVE.l  (a2)+,(a3)+ ; Copy 64 bytes
      DBRA  d0,PerfGenBlit4_64_030XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    DBRA  d4,PerfGenBlit4_64_030YLoop
  RTS

PerformGenericBlit4b ; As GenericBlit2 but in reverse
;Do a general block-blit, width should be multiple of 16 and lie on 16-byte aligned addresses
;Copies data only
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;Trashes many
  MOVE.w  d3,d5 ; Copy width
  AND.b   #$3F,d5 ; Multilpe of 64?
  BEQ     PerfGenBlit4b_64
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit4b_030
PerfGenBlit4b_040
  SUB.w   #16,a2 ; Prepare first move16
  SUB.w   #16,a3 ; Prepare first move16
  MOVEQ.l #16*2,d1 ; Init temp
PerfGenBlit4b_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4b_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      SUB.w d1,a2 ; Backpeddle
      SUB.w d1,a3 ; Backpeddle
      DBRA  d0,PerfGenBlit4b_040XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d7,a3 ; Dest linemod from data
    DBRA  d4,PerfGenBlit4b_040YLoop
  RTS;pop
PerfGenBlit4b_030
PerfGenBlit4b_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4b_030XLoop
      MOVE.l  -(a2),-(a3) ; Copy 4 bytes
      MOVE.l  -(a2),-(a3) ; Copy 8 bytes
      MOVE.l  -(a2),-(a3) ; Copy 12 bytes
      MOVE.l  -(a2),-(a3) ; Copy 16 bytes
      DBRA  d0,PerfGenBlit4b_030XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d7,a3 ; Dest linemod from data
    DBRA  d4,PerfGenBlit4b_030YLoop
  RTS
PerfGenBlit4b_64
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #6,d3 ; Width/64 for groups of 16 longwords (64 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit4b_64_030
PerfGenBlit4b_64_040
  SUB.w   #64,a2 ; Prepare first group of move16's
  SUB.w   #64,a3 ; Prepare first group of move16's
  MOVE.l  #64*2,d1 ; Init temp
PerfGenBlit4b_64_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4b_64_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+ ; 64 bytes
      SUB.w d1,a2 ; Backpeddle
      SUB.w d1,a3 ; Backpeddle
      DBRA  d0,PerfGenBlit4b_64_040XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d7,a3 ; Dest linemod from data
    DBRA  d4,PerfGenBlit4b_64_040YLoop
  RTS;pop
PerfGenBlit4b_64_030
PerfGenBlit4b_64_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit4b_64_030XLoop
      MOVE.l  -(a2),-(a3) ; 4 bytes
      MOVE.l  -(a2),-(a3) ; 8 bytes
      MOVE.l  -(a2),-(a3) ; 12 bytes
      MOVE.l  -(a2),-(a3) ; 16 bytes
      MOVE.l  -(a2),-(a3) ; 20 bytes
      MOVE.l  -(a2),-(a3) ; 24 bytes
      MOVE.l  -(a2),-(a3) ; 28 bytes
      MOVE.l  -(a2),-(a3) ; 32 bytes
      MOVE.l  -(a2),-(a3) ; 36 bytes
      MOVE.l  -(a2),-(a3) ; 40 bytes
      MOVE.l  -(a2),-(a3) ; 44 bytes
      MOVE.l  -(a2),-(a3) ; 48 bytes
      MOVE.l  -(a2),-(a3) ; 52 bytes
      MOVE.l  -(a2),-(a3) ; 56 bytes
      MOVE.l  -(a2),-(a3) ; 60 bytes
      MOVE.l  -(a2),-(a3) ; 64 bytes
      DBRA  d0,PerfGenBlit4b_64_030XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d7,a3 ; Dest linemod from data
    DBRA  d4,PerfGenBlit4b_64_030YLoop
  RTS

PerformGenericBlit5
;Do a general blit, width doesn't need to be multiple
;Copies data solid and copies stencil/cookie to dest stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  BLT     PerfGenBlit5Normal ; No need to check for extraneous bytes
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit5NoLongwords
PerfGenBlit5YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA    d0,PerfGenBlit5XLoop
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit5XLoop2
      MOVE.b  (a2)+,(a3)+ ; Copy data
      MOVE.b  (a4)+,(a5)+ ; Copy stencil
      DBRA    d0,PerfGenBlit5XLoop2
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5YLoop
  RTS ; pop
PerfGenBlit5NoLongwords
PerfGenBlit5YLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit5XLoop3
      MOVE.b  (a2)+,(a3)+ ; Copy data
      MOVE.b  (a4)+,(a5)+ ; Copy stencil
      DBRA    d0,PerfGenBlit5XLoop3
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5YLoop2
  RTS
PerfGenBlit5Normal
  MOVE.b  d3,d5 ; Copy width
  AND.b   #$0F,d5 ; Multiple of 16?
  BEQ     PerfGenBlit5Norm_16 ; yep
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit5NormYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5NormXLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA  d0,PerfGenBlit5NormXLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5NormYLoop
  RTS;pop
PerfGenBlit5Norm_16
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit5Norm_16YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5Norm_16XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA  d0,PerfGenBlit5Norm_16XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5Norm_16YLoop
  RTS

PerformGenericBlit5b ; Same as GenericBlit5 but in reverse
;Do a general blit, width doesn't need to be multiple
;Copies data solid and copies stencil/cookie to dest stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  BLT     PerfGenBlit5bNormal ; No need to check for extraneous bytes
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  ADD.l   d0,a4 ; Add to source stencil address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  ADD.l   d0,a5 ; Add to dest stencil address
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit5bNoLongwords
PerfGenBlit5bYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5bXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      DBRA    d0,PerfGenBlit5bXLoop
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit5bXLoop2
      MOVE.b  -(a2),-(a3) ; Copy data
      MOVE.b  -(a4),-(a5) ; Copy stencil
      DBRA    d0,PerfGenBlit5bXLoop2
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d6,a4 ; Source linemod to stencil
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5bYLoop
  RTS ; pop
PerfGenBlit5bNoLongwords
PerfGenBlit5bYLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit5bXLoop3
      MOVE.b  -(a2),-(a3) ; Copy data
      MOVE.b  -(a4),-(a5) ; Copy stencil
      DBRA    d0,PerfGenBlit5bXLoop3
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d6,a4 ; Source linemod to stencil
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5bYLoop2
  RTS
PerfGenBlit5bNormal
  MOVE.b  d3,d5 ; Copy width
  AND.b   #$0F,d5 ; Multiple of 16?
  BEQ     PerfGenBlit5bNorm_16 ; yep
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit5bNormYLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5bNormXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      DBRA  d0,PerfGenBlit5bNormXLoop
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d6,a4 ; Source linemod to stencil
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5bNormYLoop
  RTS;pop
PerfGenBlit5bNorm_16
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
PerfGenBlit5bNorm_16YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit5bNorm_16XLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      DBRA  d0,PerfGenBlit5bNorm_16XLoop
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d6,a4 ; Source linemod to stencil
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit5bNorm_16YLoop
  RTS

PerformGenericBlit5Custom
;Do a general blit, width does not have to be multiple
;Copies data and stencil, offsets each line using OffsetList
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a0 ; Store specified width
PerfGenBlit5CustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.w  a0,d1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    ADD.w   (a6),a2 ; Source X1 offset in data, relative to previous line
    SUB.w   d3,d1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    ADD.w   (a6)+,a4 ; Source X1 offset in stencil, relative to previous line
    SUBQ.w  #1,d5 ; ByteLoop
    ADD.w   (a6),a3 ; Dest X2 offset in data, relative to previous line
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a5 ; Dest X2 offset in stencil, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit5CustomNoLongwords
PerfGenBlit5CustomXLoop
      MOVE.l  (a2)+,(a3)+ ; Copy data
      MOVE.l  (a4)+,(a5)+ ; Copy stencil
      DBRA  d3,PerfGenBlit5CustomXLoop
PerfGenBlit5CustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit5CustomNoBytes
PerfGenBlit5CustomXLoop2
        MOVE.b  (a2)+,(a3)+ ; Copy data
        MOVE.b  (a4)+,(a5)+ ; Copy stencil
        DBRA    d5,PerfGenBlit5CustomXLoop2
PerfGenBlit5CustomNoBytes
    ADD.w d1,a2 ; Extra linemod in data caused by width change
    ADD.w d1,a3 ; Extra linemod in data caused by width change
    ADD.w (a6),a2 ; Absolute extra source data linemodulo
    ADD.w d1,a4 ; Extra linemod in stencil caused by width change
    ADD.w d1,a5 ; Extra linemod in stencil caused by width change
    ADD.w (a6)+,a4 ; Absolute extra source stencil linemodulo
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    ADD.w d6,a4 ; Source linemod to stencil
    DBRA  d4,PerfGenBlit5CustomYLoop
  RTS ; pop

PerformGenericBlit5bCustom
;Do a general blit, width does not have to be multiple
;Copies data and stencil, offsets each line using OffsetList, as GenBlit5Custom but backwards
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a0 ; Store specified width
PerfGenBlit5bCustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.w  a0,d1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    ADD.w   (a6),a2 ; Source X1 offset in data, relative to previous line
    SUB.w   d3,d1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    ADD.w   (a6)+,a4 ; Source X1 offset in stencil, relative to previous line
    SUBQ.w  #1,d5 ; ByteLoop
    ADD.w   (a6),a3 ; Dest X2 offset in data, relative to previous line
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a5 ; Dest X2 offset in stencil, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit5bCustomNoLongwords
PerfGenBlit5bCustomXLoop
      MOVE.l  -(a2),-(a3) ; Copy data
      MOVE.l  -(a4),-(a5) ; Copy stencil
      DBRA  d3,PerfGenBlit5bCustomXLoop
PerfGenBlit5bCustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit5bCustomNoBytes
PerfGenBlit5bCustomXLoop2
        MOVE.b  -(a2),-(a3) ; Copy data
        MOVE.b  -(a4),-(a5) ; Copy stencil
        DBRA    d5,PerfGenBlit5bCustomXLoop2
PerfGenBlit5bCustomNoBytes
    SUB.w d1,a2 ; Extra linemod in data caused by width change
    SUB.w d1,a3 ; Extra linemod in data caused by width change
    ADD.w (a6),a2 ; Absolute extra source data linemodulo
    SUB.w d1,a4 ; Extra linemod in stencil caused by width change
    SUB.w d1,a5 ; Extra linemod in stencil caused by width chanage
    ADD.w (a6)+,a4 ; Absolute extra source stencil linemodulo
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    SUB.w d6,a4 ; Source linemod to stencil
    DBRA  d4,PerfGenBlit5bCustomYLoop
  RTS ; pop

PerformGenericBlit6
;Do a general stencil-blit, width should be multiple of 4
;Stencil-copies both data and stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  SMaskScrollModeType,d0
  BRA     PerformBlit2
  RTS     ; Precaution

PerformGenericBlit6b ; Same as GenericBlit6 but in reverse
;Do a general blit, width should be multiple of 4
;Stencil-Copies both data and stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  SMaskScrollModeType,d0
  BRA     PerformBlit2b
  RTS     ; Precaution

PerformGenericBlit7
;Do a general block-blit, width should be multiple of 16 and lie on 16-byte aligned addresses
;Block-Copies data to data and stencil to stencil
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy width
  AND.b   #$3F,d5 ; Multiple of 64?
  BEQ     PerfGenBlit7_64
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit7_030
PerfGenBlit7_040
PerfGenBlit7_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      DBRA  d0,PerfGenBlit7_040XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit7_040YLoop
  RTS;pop
PerfGenBlit7_030
PerfGenBlit7_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7_030XLoop
      MOVE.l  (a2)+,(a3)+ ; Copy 4 bytes data
      MOVE.l  (a4)+,(a5)+ ; Copy 4 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; Copy 8 bytes data
      MOVE.l  (a4)+,(a5)+ ; Copy 8 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; Copy 12 bytes data
      MOVE.l  (a4)+,(a5)+ ; Copy 12 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; Copy 16 bytes data
      MOVE.l  (a4)+,(a5)+ ; Copy 16 bytes stencil
      DBRA  d0,PerfGenBlit7_030XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit7_030YLoop
  RTS
PerfGenBlit7_64
  LSR.w   #6,d3 ; Width/64 for groups of 16 longwords (64 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit7_64_030
PerfGenBlit7_64_040
PerfGenBlit7_64_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7_64_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+ ; 64 bytes
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+ ; 64 bytes
      DBRA  d0,PerfGenBlit7_64_040XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit7_64_040YLoop
  RTS;pop
PerfGenBlit7_64_030
PerfGenBlit7_64_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7_64_030XLoop
      MOVE.l  (a2)+,(a3)+ ; 4 bytes data
      MOVE.l  (a4)+,(a5)+ ; 4 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 8 bytes data
      MOVE.l  (a4)+,(a5)+ ; 8 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 12 bytes data
      MOVE.l  (a4)+,(a5)+ ; 12 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 16 bytes data
      MOVE.l  (a4)+,(a5)+ ; 16 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 20 bytes data
      MOVE.l  (a4)+,(a5)+ ; 20 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 24 bytes data
      MOVE.l  (a4)+,(a5)+ ; 24 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 28 bytes data
      MOVE.l  (a4)+,(a5)+ ; 28 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 32 bytes data
      MOVE.l  (a4)+,(a5)+ ; 32 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 36 bytes data
      MOVE.l  (a4)+,(a5)+ ; 36 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 40 bytes data
      MOVE.l  (a4)+,(a5)+ ; 40 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 44 bytes data
      MOVE.l  (a4)+,(a5)+ ; 44 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 48 bytes data
      MOVE.l  (a4)+,(a5)+ ; 48 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 52 bytes data
      MOVE.l  (a4)+,(a5)+ ; 52 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 56 bytes data
      MOVE.l  (a4)+,(a5)+ ; 56 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 60 bytes data
      MOVE.l  (a4)+,(a5)+ ; 60 bytes stencil
      MOVE.l  (a2)+,(a3)+ ; 64 bytes data
      MOVE.l  (a4)+,(a5)+ ; 64 bytes stencil
      DBRA  d0,PerfGenBlit7_64_030XLoop
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d6,a4 ; Source linemod to stencil
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit7_64_030YLoop
  RTS

PerformGenericBlit7b ; As GenericBlit7 but in reverse
;Do a general block-blit, width should be multiple of 16 and lie on 16-byte aligned addresses
;Block-Copies data to data and stencil to stencil
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy width
  AND.b   #$3F,d5 ; Multiple of 64?
  BEQ     PerfGenBlit7b_64
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  ADD.l   d0,a4 ; Add to source stencil address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  ADD.l   d0,a5 ; Add to dest stencil address
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit7b_030
PerfGenBlit7b_040
  SUB.w   #16,a2 ; Prepare first move16
  SUB.w   #16,a3 ; Prepare first move16
  SUB.w   #16,a4 ; Prepare first move16
  SUB.w   #16,a5 ; Prepare first move16
  MOVEQ.l #16*2,d1 ; Init temp
PerfGenBlit7b_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7b_040XLoop
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      SUB.w d1,a2 ; Backpeddle
      SUB.w d1,a3 ; Backpeddle
      SUB.w d1,a4 ; Backpeddle
      SUB.w d1,a5 ; Backpeddle
      DBRA  d0,PerfGenBlit7b_040XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d6,a4 ; Source linemod from stencil
    SUB.w d7,a3 ; Dest linemod from data
    SUB.w d7,a5 ; Dest linemod from stencil
    DBRA  d4,PerfGenBlit7b_040YLoop
  RTS;pop
PerfGenBlit7b_030
PerfGenBlit7b_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7b_030XLoop
      MOVE.l  -(a2),-(a3) ; Copy 4 bytes data
      MOVE.l  -(a4),-(a5) ; Copy 4 bytes stencil
      MOVE.l  -(a2),-(a3) ; Copy 8 bytes data
      MOVE.l  -(a4),-(a5) ; Copy 8 bytes stencil
      MOVE.l  -(a2),-(a3) ; Copy 12 bytes data
      MOVE.l  -(a4),-(a5) ; Copy 12 bytes stencil
      MOVE.l  -(a2),-(a3) ; Copy 16 bytes data
      MOVE.l  -(a4),-(a5) ; Copy 16 bytes stencil
      DBRA  d0,PerfGenBlit7b_030XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d6,a4 ; Source linemod from stencil
    SUB.w d7,a3 ; Dest linemod from data
    SUB.w d7,a5 ; Dest linemod from stencil
    DBRA  d4,PerfGenBlit7b_030YLoop
  RTS
PerfGenBlit7b_64
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  ADD.l   d0,a4 ; Add to source stencil address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  ADD.l   d0,a5 ; Add to dest stencil address
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
  TST.b   GeneralCPUmode
  BEQ     PerfGenBlit7b_64_030
PerfGenBlit7b_64_040
  SUB.w   #64,a2 ; Prepare first move16
  SUB.w   #64,a3 ; Prepare first move16
  ADD.w   #64,a4 ; Prepare first move16
  ADD.w   #64,a5 ; Prepare first move16
  MOVE.l  #64*2,d1 ; Init temp
PerfGenBlit7b_64_040YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7b_64_040XLoop
      SUB.w d1,a4 ; Backpeddle
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      SUB.w d1,a5 ; Backpeddle
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+
      Dc.l  #_MOVE16_a2_a3 ; move16 copy 16 bytes (a2)+,(a3)+ ; 64 bytes
      Dc.l  #_MOVE16_a4_a5 ; move16 copy 16 bytes (a4)+,(a5)+ ; 64 bytes
      SUB.w d1,a2 ; Backpeddle
      SUB.w d1,a3 ; Backpeddle
      DBRA  d0,PerfGenBlit7b_64_040XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d6,a4 ; Source linemod from stencil
    SUB.w d7,a3 ; Dest linemod from data
    SUB.w d7,a5 ; Dest linemod from stencil
    DBRA  d4,PerfGenBlit7b_64_040YLoop
  RTS;pop
PerfGenBlit7b_64_030
PerfGenBlit7b_64_030YLoop
    MOVE.w  d3,d0 ; XLoop
PerfGenBlit7b_64_030XLoop
      MOVE.l  -(a2),-(a3) ; 4 bytes data
      MOVE.l  -(a4),-(a5) ; 4 bytes stencil
      MOVE.l  -(a2),-(a3) ; 8 bytes data
      MOVE.l  -(a4),-(a5) ; 8 bytes stencil
      MOVE.l  -(a2),-(a3) ; 12 bytes data
      MOVE.l  -(a4),-(a5) ; 12 bytes stencil
      MOVE.l  -(a2),-(a3) ; 16 bytes data
      MOVE.l  -(a4),-(a5) ; 16 bytes stencil
      MOVE.l  -(a2),-(a3) ; 20 bytes data
      MOVE.l  -(a4),-(a5) ; 20 bytes stencil
      MOVE.l  -(a2),-(a3) ; 24 bytes data
      MOVE.l  -(a4),-(a5) ; 24 bytes stencil
      MOVE.l  -(a2),-(a3) ; 28 bytes data
      MOVE.l  -(a4),-(a5) ; 28 bytes stencil
      MOVE.l  -(a2),-(a3) ; 32 bytes data
      MOVE.l  -(a4),-(a5) ; 32 bytes stencil
      MOVE.l  -(a2),-(a3) ; 36 bytes data
      MOVE.l  -(a4),-(a5) ; 36 bytes stencil
      MOVE.l  -(a2),-(a3) ; 40 bytes data
      MOVE.l  -(a4),-(a5) ; 40 bytes stencil
      MOVE.l  -(a2),-(a3) ; 44 bytes data
      MOVE.l  -(a4),-(a5) ; 44 bytes stencil
      MOVE.l  -(a2),-(a3) ; 48 bytes data
      MOVE.l  -(a4),-(a5) ; 48 bytes stencil
      MOVE.l  -(a2),-(a3) ; 52 bytes data
      MOVE.l  -(a4),-(a5) ; 52 bytes stencil
      MOVE.l  -(a2),-(a3) ; 56 bytes data
      MOVE.l  -(a4),-(a5) ; 56 bytes stencil
      MOVE.l  -(a2),-(a3) ; 60 bytes data
      MOVE.l  -(a4),-(a5) ; 60 bytes stencil
      MOVE.l  -(a2),-(a3) ; 64 bytes data
      MOVE.l  -(a4),-(a5) ; 64 bytes stencil
      DBRA  d0,PerfGenBlit7b_64_030XLoop
    SUB.w d6,a2 ; Source linemod from data
    SUB.w d6,a4 ; Source linemod from stencil
    SUB.w d7,a3 ; Dest linemod from data
    SUB.w d7,a5 ; Dest linemod from stencil
    DBRA  d4,PerfGenBlit7b_64_030YLoop
  RTS

PerformGenericBlit8
;Do a general blit, width doesn't need to be multiple
;Copies data with cut using destination stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit8NoLongwords
  MOVE.l  a6,-(a7) ; Store
  MOVE.w  d3,a6
PerfGenBlit8YLoop
    MOVE.w  a6,d0 ; XLoop
PerfGenBlit8XLoop
      MOVE.l  (a5)+,d2 ; Get dest stencil
      MOVE.l  (a2)+,d1 ; Get source data
      AND.l   d2,d1 ; Mask source
      MOVE.l  (a3),d3 ; Get dest data
      NOT.l   d2 ; Invert mask
      AND.l   d2,d3 ; Mask dest
      OR.l    d1,d3 ; Combine
      MOVE.l  d3,(a3)+ ; Write
      DBRA    d0,PerfGenBlit8XLoop
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit8NoBytes
      MOVE.w  d5,d0 ; XLoop
PerfGenBlit8XLoop2
        MOVE.b  (a5)+,d2 ; Get dest stencil
        MOVE.b  (a2)+,d1 ; Get source data
        AND.b   d2,d1 ; Mask source
        MOVE.b  (a3),d3 ; Get dest data
        NOT.b   d2 ; Invert mask
        AND.b   d2,d3 ; Mask dest
        OR.b    d1,d3 ; Combine
        MOVE.b  d3,(a3)+ ; Write
        DBRA    d0,PerfGenBlit8XLoop2
PerfGenBlit8NoBytes
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit8YLoop
  MOVE.l  (a7)+,a6 ; Restore
  RTS ; pop
PerfGenBlit8NoLongwords
  TST.w   d5 ; Any bytes?
  BLT     PerfGenBlit8NoBytes2
PerfGenBlit8YLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit8XLoop3
      MOVE.b  (a5)+,d2 ; Get dest stencil
      MOVE.b  (a2)+,d1 ; Get source data
      AND.b   d2,d1 ; Mask source
      MOVE.b  (a3),d3 ; Get dest data
      NOT.b   d2 ; Invert mask
      AND.b   d2,d3 ; Mask dest
      OR.b    d1,d3 ; Combine
      MOVE.b  d3,(a3)+ ; Write
      DBRA    d0,PerfGenBlit8XLoop3
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit8YLoop2
PerfGenBlit8NoBytes2
  RTS

PerformGenericBlit8b ; Same as GenericBlit8 but in reverse
;Do a general blit, width should be multiple of 4
;Copies data with cut using destination stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a5=Dest stencil address
;Trashes many
  MOVE.w  d3,d5 ; Copy Width
  AND.w   #$03,d5 ; Only extra bytes
  SUBQ.w  #1,d5 ; ByteLoop
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  ADD.l   d0,a5 ; Add to dest stencil address
  LSR.w   #2,d3 ; Width/4 for longwords
  SUBQ.w  #1,d4 ; YLoopcounter
  SUBQ.w  #1,d3 ; XLoopcounter
  BLT     PerfGenBlit8bNoLongwords
  MOVE.l  a6,-(a7) ; Store
  MOVE.w  d3,a6
PerfGenBlit8bYLoop
    MOVE.w  a6,d0 ; XLoop
PerfGenBlit8bXLoop
      MOVE.l  -(a5),d2 ; Get dest stencil
      MOVE.l  -(a2),d1 ; Get source data
      AND.l   d2,d1 ; Mask source
      MOVE.l  -(a3),d3 ; Get dest data
      NOT.l   d2 ; Invert mask
      AND.l   d2,d3 ; Mask dest
      OR.l    d1,d3 ; Combine
      MOVE.l  d3,(a3) ; Write
      DBRA    d0,PerfGenBlit8bXLoop
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit8bNoBytes
      MOVE.w  d5,d0 ; XLoop
PerfGenBlit8bXLoop2
        MOVE.b  -(a5),d2 ; Get dest stencil
        MOVE.b  -(a2),d1 ; Get source data
        AND.b   d2,d1 ; Mask source
        MOVE.b  -(a3),d3 ; Get dest data
        NOT.b   d2 ; Invert mask
        AND.b   d2,d3 ; Mask dest
        OR.b    d1,d3 ; Combine
        MOVE.b  d3,(a3) ; Write
        DBRA    d0,PerfGenBlit8bXLoop2
PerfGenBlit8bNoBytes
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit8bYLoop
  MOVE.l  (a7)+,a6 ; Restore
  RTS ; pop
PerfGenBlit8bNoLongwords
  TST.w   d5 ; Any bytes?
  BLT     PerfGenBlit8bNoBytes2
PerfGenBlit8bYLoop2
    MOVE.w  d5,d0 ; XLoop
PerfGenBlit8bXLoop3
      MOVE.b  -(a5),d2 ; Get dest stencil
      MOVE.b  -(a2),d1 ; Get source data
      AND.b   d2,d1 ; Mask source
      MOVE.b  -(a3),d3 ; Get dest data
      NOT.b   d2 ; Invert mask
      AND.b   d2,d3 ; Mask dest
      OR.b    d1,d3 ; Combine
      MOVE.b  d3,(a3) ; Write
      DBRA    d0,PerfGenBlit8bXLoop3
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit8bYLoop2
PerfGenBlit8bNoBytes2
  RTS

PerformGenericBlit8Custom
;Do a general blit, width does not have to be multiple
;Copies data with stencil cut, offsets each line using OffsetList
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a5=Dest stencil address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a0 ; Store specified width
PerfGenBlit8CustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.l  a0,a1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    ADD.w   (a6)+,a2 ; Source X1 offset in data, relative to previous line
    SUB.w   d3,a1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    SUBQ.w  #1,d5 ; ByteLoop
    ADD.w   (a6),a3 ; Dest X2 offset in data, relative to previous line
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a5 ; Dest X2 offset in stencil, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit8CustomNoLongwords
PerfGenBlit8CustomXLoop
      MOVE.l  (a5)+,d2 ; Get dest stencil
      MOVE.l  (a2)+,d1 ; Get source data
      AND.l   d2,d1 ; Mask source
      MOVE.l  (a3),d0 ; Get dest data
      NOT.l   d2 ; Invert mask
      AND.l   d2,d0 ; Mask dest
      OR.l    d1,d0 ; Combine
      MOVE.l  d0,(a3)+ ; Write
      DBRA  d3,PerfGenBlit8CustomXLoop
PerfGenBlit8CustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit8CustomNoBytes
PerfGenBlit8CustomXLoop2
        MOVE.b  (a5)+,d2 ; Get dest stencil
        MOVE.b  (a2)+,d1 ; Get source data
        AND.b   d2,d1 ; Mask source
        MOVE.b  (a3),d3 ; Get dest data
        NOT.b   d2 ; Invert mask
        AND.b   d2,d3 ; Mask dest
        OR.b    d1,d3 ; Combine
        MOVE.b  d3,(a3)+ ; Write
        DBRA    d5,PerfGenBlit8CustomXLoop2
PerfGenBlit8CustomNoBytes
    ADD.l a1,a2 ; Extra linemod in data caused by width change
    ADD.l a1,a3 ; Extra linemod in data caused by width change
    ADD.w (a6)+,a2 ; Absolute extra source data linemodulo
    ADD.l a1,a5 ; Extra linemod in stencil caused by width change
    ADD.w d7,a3 ; Dest linemod to data
    ADD.w d6,a2 ; Source linemod to data
    ADD.w d7,a5 ; Dest linemod to stencil
    DBRA  d4,PerfGenBlit8CustomYLoop
  RTS ; pop

PerformGenericBlit8bCustom
;Do a general blit, width does not have to be multiple
;Copies data with stencil cut, offsets each line using OffsetList, as GenBlit8Custom but backwards
;d3=Operation width (on which initial modulos are based)
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a5=Dest stencil address
;Trashes many
  MOVE.l  LongwordStore,a6 ; Get OffsetList.l
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d6,d0 ; Add source linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d6,d0 ; -Linemod of last line
  ADD.l   d0,a2 ; Add to source address
  MOVE.w  d3,d0 ; Get Width
  ADD.w   d7,d0 ; Add dest linemod
  MULU    d4,d0 ; Total bytes
  SUB.l   d7,d0 ; -Linemod of last line
  ADD.l   d0,a3 ; Add to dest address
  SUBQ.w  #1,d4 ; YLoopcounter
  MOVE.w  d3,a0 ; Store specified width
PerfGenBlit8bCustomYLoop
    MOVE.w  (a6)+,d3 ; Absolute width of line
    MOVE.l  a0,a1 ; Get specified width
    MOVE.w  d3,d5 ; Copy Width
    ADD.w   (a6),a2 ; Source X1 offset in data, relative to previous line
    SUB.w   d3,a1 ; Extra linemodulo to handle width change
    AND.w   #$03,d5 ; Only extra bytes
    ADD.w   (a6)+,a4 ; Source X1 offset in stencil, relative to previous line
    SUBQ.w  #1,d5 ; ByteLoop
    ADD.w   (a6),a3 ; Dest X2 offset in data, relative to previous line
    LSR.w   #2,d3 ; Width/4 for longwords
    ADD.w   (a6)+,a5 ; Dest X2 offset in stencil, relative to previous line
    SUBQ.w  #1,d3 ; XLoopcounter
    BLT     PerfGenBlit8bCustomNoLongwords
PerfGenBlit8bCustomXLoop
      MOVE.l  -(a5),d2 ; Get dest stencil
      MOVE.l  -(a2),d1 ; Get source data
      AND.l   d2,d1 ; Mask source
      MOVE.l  -(a3),d0 ; Get dest data
      NOT.l   d2 ; Invert mask
      AND.l   d2,d0 ; Mask dest
      OR.l    d1,d0 ; Combine
      MOVE.l  d0,(a3) ; Write
      DBRA  d3,PerfGenBlit8bCustomXLoop
PerfGenBlit8bCustomNoLongwords
    TST.w   d5 ; bytes?
    BLT     PerfGenBlit8bCustomNoBytes
PerfGenBlit8bCustomXLoop2
        MOVE.b  -(a5),d2 ; Get dest stencil
        MOVE.b  -(a2),d1 ; Get source data
        AND.b   d2,d1 ; Mask source
        MOVE.b  -(a3),d3 ; Get dest data
        NOT.b   d2 ; Invert mask
        AND.b   d2,d3 ; Mask dest
        OR.b    d1,d3 ; Combine
        MOVE.b  d3,(a3) ; Write
        DBRA    d5,PerfGenBlit8bCustomXLoop2
PerfGenBlit8bCustomNoBytes
    SUB.l a1,a2 ; Extra linemod in data caused by width change
    SUB.l a1,a3 ; Extra linemod in data caused by width change
    ADD.w (a6),a2 ; Absolute extra source data linemodulo
    SUB.l a1,a4 ; Extra linemod in stencil caused by width change
    SUB.l a1,a5 ; Extra linemod in stencil caused by width chanage
    ADD.w (a6)+,a4 ; Absolute extra source stencil linemodulo
    SUB.w d7,a3 ; Dest linemod to data
    SUB.w d6,a2 ; Source linemod to data
    SUB.w d7,a5 ; Dest linemod to stencil
    SUB.w d6,a4 ; Source linemod to stencil
    DBRA  d4,PerfGenBlit8bCustomYLoop
  RTS ; pop

PerformGenericBlit9
;Do a general stencil-blit, width should be multiple of 4
;Stencil-copies data and additionally cuts using destination stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many, particularly a1
  MOVE.w  SMaskScrollModeType,d0
  BRA     PerformBlit3
  RTS     ; Precaution

PerformGenericBlit9b ; Same as GenericBlit9 but in reverse
;Do a general blit, width should be multiple of 4
;Stencil-copies data and additionally cuts using destination stencil/cookie
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a4=Source stencil address
;a5=Dest stencil address
;Trashes many
  MOVE.w  SMaskScrollModeType,d0
  BRA     PerformBlit3b
  RTS     ; Precaution

PerformGenericBlit10
;Do a general block-blit, width should be multiple of 16 and lie on 16-byte aligned addresses
;BlockCopies data with cut using dest's stencil/cookie. Ignores CPU type as move16 isn't useable
;d3=Operation width
;d4=Operation height
;d6=Source linemodulo
;d7=Dest linemodulo
;a2=Source data address
;a3=Dest data address
;a5=Dest stencil address
;Trashes many
  LSR.w   #4,d3 ; Width/16 for groups of 4 longwords (16 bytes)
  SUBQ.w  #1,d3 ; XLoopcounter
  SUBQ.w  #1,d4 ; YLoopcounter
PerfGenBlit10
  MOVE.w  d3,a0
PerfGenBlit10YLoop
    MOVE.w  a0,d0 ; XLoop
PerfGenBlit10XLoop
      MOVE.l  (a5)+,d2 ; Get dest stencil
      