
#c2pWindowStructSize=4 ; LSL for 16 bytes
#ChunkyResourceStructSize=6 ; LSL for 64 bytes
#ChunkyQueueStructSize=4 ; LSL for 16 bytes
#ChunkyQueueListStructSize=4 ; LSL for 16 bytes
#ChunkyTableStructSize=4 ; LSL for 16 bytes

;c2pWindow structure, 16 bytes
c2p0_Pixels:    Dc.w 0 ;0 Number of pixels per row
c2p0_RowsStore: Dc.w 0 ;2 Row counter
c2p0LaceOffsetA:Dc.w 0 ;4 Interlace bytes to add to source pointer in odd frames
c2p0LaceOffsetB:Dc.w 0 ;6 Interlace bytes to add to dest pointer in odd frames
c2p0_Pmod:      Dc.w 0 ;8 Planar line modulo
c2p0_Cmod:      Dc.w 0 ;10 Chunky line modulo
c2p0Lace:       Dc.b 0 ;12 Same as Row-Lacing yes/no. Tells if rowlace was on when object was created
c2p0Pad0:       Dc.b 0 ;13
c2p0Pad1:       Dc.w 0 ;14

;ChunkyResource structure, 64 bytes (bitmaps and shapes)
CRsrc_Width:    Dc.w 0 ;0  Width of the chunky resource in pixels (=bytes)
CRsrc_Height:   Dc.w 0 ;2  Height of the chunky resource in pixels (=lines) Must be positioned directly after Width
CRsrc_LineMod:  Dc.w 0 ;4  Horizontal line modulo - bytes to add at end of line to get to start of next line (usually zero)
CRsrc_Clipping: Dc.b 0 ;6  Clip window active/deactive. 0=Off, <>0=On
CRsrc_Wrapping: Dc.b 0 ;7  X&Y Handle-wrapping active/deactive. 0=Normal, <>0=MemoryWrap (add WrapBytes to base address)
CRsrc_Data:     Dc.l 0 ;8  Pointer to move16-aligned memory containing resource's graphic
CRsrc_Stencil:  Dc.l 0 ;12 Pointer to move16-aligned memory containing resource's stencil/mask/cookie
CRsrc_XHandle:  Dc.w 0 ;16 X-Handle coordinate horizontal offset
CRsrc_YHandle:  Dc.w 0 ;18 Y-Handle coordinate verticle offset
CRsrc_DMem:     Dc.l 0 ;20 Actual base pointer of memory reserved for data (before move16-alignment)
CRsrc_DBytes:   Dc.l 0 ;24 Total number of bytes in the resource's graphic mem (before align)
CRsrc_SMem:     Dc.l 0 ;28 Actual base pointer of memory reserved for stencil (before move16-alignment)
CRsrc_SBytes:   Dc.l 0 ;32 Total number of bytes in the resource's stencil/mask/cookie (before align)
CRsrc_DHere:    Dc.b 0 ;36 Graphic data here. 0=Cludged, <>0=CRsrc_DMem is base address
CRsrc_SHere:    Dc.b 0 ;37 Stencil data here. 0=Cludged, <>0=CRsrc_SMem is base address
CRsrc_ClipLMod: Dc.w 0 ;38 Clip window horizontal line modulo in bytes compared with bitmap width (additional to LineMod)
CRsrc_ClipLeft: Dc.w 0 ;40 Clip window's left-edge X coordinate offset
CRsrc_ClipTop:  Dc.w 0 ;42 Clip window's top-edge Y coordinate offset
CRsrc_ClipWidth:Dc.w 0 ;44 Clip window's width in pixels
CRsrc_ClipHight:Dc.w 0 ;46 Clip window's height in pixels
CRsrc_ClipBytes:Dc.l 0 ;48 Clip window bytes to add to addresses to find topleft corner of clip window
CRsrc_WrapBytes:Dc.l 0 ;52 Handle bytes to add to base addresses to find topleft XHandle,Yhandle offset
CRsrc_TotWidth: Dc.w 0 ;56 Width+LineMod, for faster reading of total byte width
CRsrc_Pad1:     Dc.w 0 ;58
CRsrc_Pad2:     Dc.l 0 ;60

;ChunkyQueue structure, 16 bytes
CQueue_LMem:    Dc.l 0 ;0  Pointer to memory used to store the list. 0=Queue doesn't exist
CQueue_LBytes:  Dc.l 0 ;4  Bytes of mem reserved
CQueue_MaxItems:Dc.w 0 ;8  Maximum number of items in the queue
CQueue_Items:   Dc.w 0 ;10 Actual number of items in the queue
CQueue_ItemAddr:Dc.l 0 ;12 Memory address of the current item

;ChunkyQueueListItem structure, 16 bytes
CQList_DestAddr:Dc.l 0 ;0  Address of top-left corner of destination
CQList_OpWidth: Dc.w 0 ;4  Width of the operation in pixels or bytes
CQList_OpHeight:Dc.w 0 ;6  Height of the operation in pixels, lines or rows
CQList_DestLMod:Dc.l 0 ;8  Destination linemodulo to support object width
CQList_XYBytes: Dc.l 0 ;12 Bytes needed to be added to base address to point to coordinates, not including wrapped origin

;ChunkyTable structure, 16 bytes
ChunkyTables
CTable_LMem:    Dc.l 0 ;0  Pointer to memory used to store the list. 0=Table doesn't exist
CTable_LBytes:  Dc.l 0 ;4  Bytes of mem reserved.Also maximum number of items
CTable_Items:   Dc.l 0 ;8  Actual number of items in the table
CTable_ItemAddr:Dc.l 0 ;12 Memory address of the current item

