
; extra.include.bb2 generated by pragma2inc.


DEFTYPE .Library *_extraBase

Macro extra_BAMCheckSum ; {ret,Block}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -42(a6) : PutReg d0,`1
End Macro

Macro extra_BootBlockSum ; {ret,Block}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -48(a6) : PutReg d0,`1
End Macro

Macro extra_DiskBlockSum ; {ret,Block}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -54(a6) : PutReg d0,`1
End Macro

Macro extra_OpenBuf ; {ret}
   GetReg a6,*_extraBase : JSR -60(a6) : PutReg d0,`1
End Macro

Macro extra_CloseBuf ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -66(a6) : PutReg d0,`1
End Macro

Macro extra_FileToBuf ; {ret,FileName}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -72(a6) : PutReg d0,`1
End Macro

Macro extra_BufToFile ; {ret,BufHandle,FileName}
   GetReg a0,`2 : GetReg a1,`3
   GetReg a6,*_extraBase : JSR -78(a6) : PutReg d0,`1
End Macro

Macro extra_ClearBuf ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -84(a6) : PutReg d0,`1
End Macro

Macro extra_DuplicateBuf ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -90(a6) : PutReg d0,`1
End Macro

Macro extra_BufInfo ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -96(a6) : PutReg d0,`1
End Macro

Macro extra_SeekBuf ; {ret,BufHandle,Position,Mode}
   GetReg a0,`2 : GetReg d0,`3 : GetReg d1,`4
   GetReg a6,*_extraBase : JSR -102(a6) : PutReg d0,`1
End Macro

Macro extra_Store ; {ret,BufHandle,Data,Size}
   GetReg a0,`2 : GetReg a1,`3 : GetReg d0,`4
   GetReg a6,*_extraBase : JSR -108(a6) : PutReg d0,`1
End Macro

Macro extra_InsertBuf ; {ret,BufHandle1,BufHandle2}
   GetReg a0,`2 : GetReg a1,`3
   GetReg a6,*_extraBase : JSR -114(a6) : PutReg d0,`1
End Macro

Macro extra_InsertFile ; {ret,BufHandle,FileName}
   GetReg a0,`2 : GetReg a1,`3
   GetReg a6,*_extraBase : JSR -120(a6) : PutReg d0,`1
End Macro

Macro extra_Replace ; {ret,BufHandle,Data,Size,OldSize}
   GetReg a0,`2 : GetReg a1,`3 : GetReg d0,`4 : GetReg d1,`5
   GetReg a6,*_extraBase : JSR -126(a6) : PutReg d0,`1
End Macro

Macro extra_Get ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -132(a6) : PutReg d0,`1
End Macro

Macro extra_Clear ; {ret,BufHandle,Size}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -138(a6) : PutReg d0,`1
End Macro

Macro extra_FindData ; {ret,BufHandle,Key,Data,Size}
   GetReg a0,`2 : GetReg d0,`3 : GetReg a1,`4 : GetReg d1,`5
   GetReg a6,*_extraBase : JSR -144(a6) : PutReg d0,`1
End Macro

Macro extra_FindNext ; {ret,BufHandle,Key}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -150(a6) : PutReg d0,`1
End Macro

Macro extra_FindPrev ; {ret,BufHandle,Key}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -156(a6) : PutReg d0,`1
End Macro

Macro extra_FreeFinds ; {ret,BufHandle}
   GetReg a0,`2
   GetReg a6,*_extraBase : JSR -162(a6) : PutReg d0,`1
End Macro

Macro extra_SetBookmark ; {ret,BufHandle,Key}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -168(a6) : PutReg d0,`1
End Macro

Macro extra_GotoBookmark ; {ret,BufHandle,Key}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -174(a6) : PutReg d0,`1
End Macro

Macro extra_FindString ; {ret,Source,SourceLen,Find,FindLen}
   GetReg a0,`2 : GetReg d0,`3 : GetReg a1,`4 : GetReg d1,`5
   GetReg a6,*_extraBase : JSR -180(a6) : PutReg d0,`1
End Macro

Macro extra_GetLength ; {ret,Start,EndByte,MaxBytes}
   GetReg a0,`2 : GetReg d0,`3 : GetReg d1,`4
   GetReg a6,*_extraBase : JSR -186(a6) : PutReg d0,`1
End Macro

Macro extra_LastError ; {ret}
   GetReg a6,*_extraBase : JSR -192(a6) : PutReg d0,`1
End Macro

Macro extra_LongToString ; {ret,Value,Flag}
   GetReg d0,`2 : GetReg d1,`3
   GetReg a6,*_extraBase : JSR -198(a6) : PutReg d0,`1
End Macro

Macro extra_StringToLong ; {ret,DezString,Len}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -204(a6) : PutReg d0,`1
End Macro

Macro extra_PackByteRun1 ; {ret,InBuf,InLen,OutBuf,OutLen}
   GetReg a0,`2 : GetReg d0,`3 : GetReg a1,`4 : GetReg d1,`5
   GetReg a6,*_extraBase : JSR -210(a6) : PutReg d0,`1
End Macro

Macro extra_UnpackByteRun1 ; {ret,InParam,OutBuf,OutLen}
   GetReg a0,`2 : GetReg a1,`3 : GetReg d0,`4
   GetReg a6,*_extraBase : JSR -216(a6) : PutReg d0,`1
End Macro

Macro extra_PrintIoError ; {ret,DOSErrNum}
   GetReg d0,`2
   GetReg a6,*_extraBase : JSR -222(a6) : PutReg d0,`1
End Macro

Macro extra_FlipCase ; {String,Len,Flag}
   GetReg a0,`1 : GetReg d0,`2 : GetReg d1,`3
   GetReg a6,*_extraBase : JSR -228(a6)
End Macro

Macro extra_CmpMem ; {ret,BlockA,BlockB,Size}
   GetReg a0,`2 : GetReg a1,`3 : GetReg d0,`4
   GetReg a6,*_extraBase : JSR -234(a6) : PutReg d0,`1
End Macro

Macro extra_CopyMemI ; {Source,Dest,Size}
   GetReg a0,`1 : GetReg a1,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -240(a6)
End Macro

Macro extra_FillMem ; {ret,Start,Size,Value}
   GetReg a0,`2 : GetReg d0,`3 : GetReg d1,`4
   GetReg a6,*_extraBase : JSR -246(a6) : PutReg d0,`1
End Macro

Macro extra_GetMem ; {ret,Size,Requirements}
   GetReg d0,`2 : GetReg d1,`3
   GetReg a6,*_extraBase : JSR -252(a6) : PutReg d0,`1
End Macro

Macro extra_UnGetMem ; {Block}
   GetReg a0,`1
   GetReg a6,*_extraBase : JSR -258(a6)
End Macro

Macro extra_OutlineOff ; {RP}
   GetReg a0,`1
   GetReg a6,*_extraBase : JSR -264(a6)
End Macro

Macro extra_OutlineOn ; {RP}
   GetReg a0,`1
   GetReg a6,*_extraBase : JSR -270(a6)
End Macro

Macro extra_SetOPen ; {RP,Pen}
   GetReg a0,`1 : GetReg d0,`2
   GetReg a6,*_extraBase : JSR -276(a6)
End Macro

Macro extra_SpecText ; {ret,RP,String,xPos,yPos}
   GetReg a0,`2 : GetReg a1,`3 : GetReg d0,`4 : GetReg d1,`5
   GetReg a6,*_extraBase : JSR -282(a6) : PutReg d0,`1
End Macro

Macro extra_SpecTextPrefs ; {MPen,TLPen,BRPen,Style,Mask,Flags}
   GetReg d0,`1 : GetReg d1,`2 : GetReg d2,`3 : GetReg d3,`4 : GetReg d4,`5
   GetReg d5,`6
   GetReg a6,*_extraBase : JSR -288(a6)
End Macro

Macro extra_ShowMsg ; {ret,Param,Type,Height,ColorTab}
   GetReg a0,`2 : GetReg d0,`3 : GetReg d1,`4 : GetReg d2,`5
   GetReg a6,*_extraBase : JSR -294(a6) : PutReg d0,`1
End Macro

Macro extra_v2_OpenBuf ; {ret,MemType}
   GetReg d0,`2
   GetReg a6,*_extraBase : JSR -300(a6) : PutReg d0,`1
End Macro

Macro extra_v2_FileToBuf ; {ret,FileName,MemType}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -306(a6) : PutReg d0,`1
End Macro

Macro extra_v2_DuplicateBuf ; {ret,BufHandle,MemType}
   GetReg a0,`2 : GetReg d0,`3
   GetReg a6,*_extraBase : JSR -312(a6) : PutReg d0,`1
End Macro

Macro extra_VSPrintF ; {ret,FormString,Args}
   GetReg a0,`2 : GetReg a1,`3
   GetReg a6,*_extraBase : JSR -318(a6) : PutReg d0,`1
End Macro

Macro extra_GetMem16 ; {ret,Size,Requirements}
   GetReg d0,`2 : GetReg d1,`3
   GetReg a6,*_extraBase : JSR -324(a6) : PutReg d0,`1
End Macro

Macro extra_DiscardString ; {MathString}
   GetReg a0,`1
   GetReg a6,*_extraBase : JSR -330(a6)
End Macro

Macro extra_Int32ToString ; {ret,Value32Bit,XTRA_CONVFLAG,XTRA_CONVBASE}
   GetReg d0,`2 : GetReg d2,`3 : GetReg d3,`4
   GetReg a6,*_extraBase : JSR -336(a6) : PutReg d0,`1
End Macro

Macro extra_Int64ToString ; {ret,Lower32Bit,Upper32Bit,Flag,Base}
   GetReg d0,`2 : GetReg d1,`3 : GetReg d2,`4 : GetReg d3,`5
   GetReg a6,*_extraBase : JSR -342(a6) : PutReg d0,`1
End Macro

Macro extra_FFPToString ; {ret,FFPValue,XTRA_CONVDIGITS}
   GetReg d0,`2 : GetReg d3,`3
   GetReg a6,*_extraBase : JSR -348(a6) : PutReg d0,`1
End Macro

Macro extra_SGLToString ; {ret,SGLValue,XTRA_CONVDIGITS}
   GetReg d0,`2 : GetReg d3,`3
   GetReg a6,*_extraBase : JSR -354(a6) : PutReg d0,`1
End Macro

Macro extra_DBLToString ; {ret,Upper32Bit,Lower32Bit,Digits}
   GetReg d0,`2 : GetReg d1,`3 : GetReg d3,`4
   GetReg a6,*_extraBase : JSR -360(a6) : PutReg d0,`1
End Macro

Macro extra_StringToInt32 ; {ret,Int32String,XTRA_CONVFLAG,XTRA_CONVBASE}
   GetReg a0,`2 : GetReg d2,`3 : GetReg d3,`4
   GetReg a6,*_extraBase : JSR -366(a6) : PutReg d0,`1
End Macro


Function.l extra_InitLib {minVersion.l}
   SHARED *_extraBase
   If *_extraBase Then Function Return *_extraBase
   If minVersion<0 Then minVersion = 0
   *_extraBase = OpenLibrary_ ("extra.library",minVersion)
   Function Return *_extraBase
End Function


Statement extra_FreeLib {}
   SHARED *_extraBase
   If *_extraBase Then CloseLibrary_ *_extraBase : *_extraBase = 0
End Statement


;***************************************************************************************
;***************************************************************************************
;***************************************************************************************


; HB to Blitz constants conversion done by h2b.

; ___________________________________________________________________________
; |*************************************************************************|
; |*|//////////////////////////////////////////////|*|////////////////////|*|
; |*| Set TAB to 4 for best readable file layout.  |*|  Maxon Basic 3.00  |*|
; |*|______________________________________________|*|____________________|*|
; |*************************************************************************|
; |*|///////////////|*|///////////////////////////////////////////////////|*|
; |*|               |*|  $Id: settings.bc (26.11.05)                      |*|
; |*| ###### ###### |*|  RhoSigma Source based on NDK 3.1 Includes 40.15  |*|
; |*| ##  ## ##   # |*| _________________________________________________ |*|
; |*| ##  ##  ##    |*|                                                   |*|
; |*| ######   ##   |*|  Useful defines and extensions for NDK includes   |*|
; |*| ##      ##    |*|                                                   |*|
; |*| ##     ##   # |*| ///////////////////////////////////////////////// |*|
; |*| ##     ###### |*|  Copyright ) 1998-2005 RhoSigma, Roland Heyder    |*|
; |*|               |*|  All Rights Reserved.                             |*|
; |*|_______________|*|___________________________________________________|*|
; |*************************************************************************|
; ///////////////////////////////////////////////////////////////////////////


         ;** enhanced booleans **

#UPPER   = 1         ;Signum- und Wahrheitswerte zur
#EQUAL   = 0         ;Verwendung in Variablen des
#LOWER   = -1     ;Typs BOOL

         ;** for DisplayAlert() **

#DATPOS_C   = -1     ;Text zentrieren
#DATPOS_L   = -2     ;Text linksb|ndig
#DATPOS_R   = -3     ;Text rechtsb|ndig

;*** rhosigma / DATEXT() ***
;============================================================================
; Diese Routine erstellt einen Teilstring des Parameterstrings der Intuition-
; Routine ;DisplayAlert()+. Wahlweise kann der Text automatisch zentriert,
; oder links- bzw. rechsb|ndig ausgerichtet werden.
;----------------------------------------------------------------------------
; Definiert:   settings.bc  (Copyright ) 1998-2005 RhoSigma, Roland Heyder)
;
; Schablone:   xPos/A/N, yPos/A/N, Text$/A, EndFlag/N/S
;
; Parameter:   xPos   --> x-Position des Textes,
;                       oder einer der oben definierten DATPOS-Werte
;
;           yPos   --> y-Position des Textes,
;                       Ausrichtung nach BaseLine des Fonts (topaz/8)
;
;           Text$  --> der Text selbst als Variable oder Konstante
;
;           EndFlag --> - TRUE , dann endet hier der Parameterstring
;                     - FALSE, dann MUSS noch ein weiterer Teilstring
;                             (SUB-Aufruf) folgen.
;
; Bemerkung:   Nach Aufruf der Routine f|r alle einzelnen Teilstrings finden
;           Sie den fertigen Parameterstring in der Variable ;daAlert$+,
;           welche Sie an ;DisplayAlert()+ mittels ;SADD(daAlert$)+ |ber-
;           geben m|ssen.
;
;           Ein Beispiel f|r die Benutzung dieser Routine finden Sie in der
;           Datei ;demo/AlertDemo.BAS+.
;
;   ACHTUNG:   Sie d|rfen in Ih; Programm keine eigene Stringvariable mit
;   ////////   dem Namen ;daAlert$+ verwenden, da diese unweigerlich durch
;           dieses Unterprogramm |berschrieben werden w|rde.
;
;           Au_erdem m|ssen Sie den Parameterstring immer unmittelbar vor
;           dem ;DisplayAlert()+-Aufruf definieren, da die Variable ;daAlert$+
;          jedesmal wieder |berschrieben wird, und daher immer nur den zu-
;           letzt erstellten Parameterstring enthdlt.
;============================================================================

lFlag1.b=0

Statement DATEXT {xPos.l, yPos.l, Text$, EndFlag.b}
   SHARED daAlert$, lFlag1

   If lFlag1<>0    ; wird ein neuer ParamString angefangen,
      lFlag1=0     ; dann ;daAlert$+ erst zur|cksetzen
      daAlert$=""
   Else
      lFlag1=EndFlag
   EndIf

   If xPos=#DATPOS_C           ; gew|nschte Ausrichtung,
      xPos=(640-(Len(Text$)*8))/2   ; falls angegeben
   Else
      If xPos=#DATPOS_L
         xPos=12
      Else
         If xPos=#DATPOS_R Then xPos=(640-(Len(Text$)*8))-12
      EndIf
   EndIf
   If Len(Text$)/2=Int(Len(Text$)/2) Then Text$=Text$+Chr$(32) ;f|r OS 1.3

   daAlert$=daAlert$+Mki$(xPos)+Chr$(yPos)+Text$+Chr$(0) ; alles erstellen

   If EndFlag=0       ; wenn kein END-Flag, dann Continue-Byte
      daAlert$=daAlert$+Chr$(1)  ; setzen, ansonsten 0-Byte und Adresse
   Else                    ; auf gerade setzen
      daAlert$=daAlert$+Chr$(0)
      While &daAlert$ AND 1
         daAlert$=daAlert$+Chr$(0)
      Wend
   EndIf
End Statement


;***************************************************************************************
;***************************************************************************************
;***************************************************************************************


; HB to Blitz constants conversion done by h2b.

; ___________________________________________________________________________
; |*************************************************************************|
; |*|//////////////////////////////////////////////|*|////////////////////|*|
; |*| Set TAB to 4 for best readable file layout.  |*|  Maxon Basic 3.00  |*|
; |*|______________________________________________|*|____________________|*|
; |*************************************************************************|
; |*|///////////////|*|///////////////////////////////////////////////////|*|
; |*|               |*|  $Id: extra.bc (04.06.06)                         |*|
; |*| ###### ###### |*|  RhoSigma Source based on NDK 3.1 Includes 40.15  |*|
; |*| ##  ## ##   # |*| _________________________________________________ |*|
; |*| ##  ##  ##    |*|                                                   |*|
; |*| ######   ##   |*|  The public BASIC definitions for extra.library   |*|
; |*| ##      ##    |*|                                                   |*|
; |*| ##     ##   # |*| ///////////////////////////////////////////////// |*|
; |*| ##     ###### |*|  Copyright ) 1998-2006 RhoSigma, Roland Heyder    |*|
; |*|               |*|  All Rights Reserved.                             |*|
; |*|_______________|*|___________________________________________________|*|
; |*************************************************************************|
; ///////////////////////////////////////////////////////////////////////////

;$UNDERLINES

;---------- die BufInfoBlock-Struktur von ;BufInfo()+ -----------------------

#bib_OwnerID      = 0   ;(APTR)  Task (TCB), der diesen Puffer vffnete
#bib_MaxSize      = 4   ;(ULONG) momentane Grv_e des Datenbereichs in Byte
#bib_FreeSize     = 8   ;(ULONG) davon momentan noch unbenutzt
#bib_DataStart    = 12  ;(APTR)  Adresse des gegenwdrtigen Datenbereichs
#bib_CurPos       = 16  ;(ULONG) aktuelle Cursorposition (Zdhlbeginn=0 !!)
#bib_EndPos       = 20  ;(ULONG) aktuelle Anf|geposition
#bib_LastFind     = 24  ;(APTR)  Zeiger auf zuletzt gesuchte Daten od. 0-PTR
#bib_FindSize     = 28  ;(ULONG) die Ldnge obiger Such-Daten oder null
#bib_KeyNum       = 32  ;(ULONG) der Schl|ssel der o.g. Such-Daten oder -1
;------------------------------------- neu ab v2.062
#bib_DataMemType  = 36  ;(ULONG) Speicherflags (MEMF_...) des Datenbereichs
;---------------------------------------------------
#bib_SizeOf    = 40

;---------- Modes f|r ;SeekBuf()+ -------------------------------------------

#SKM_Current   = 0      ;Positionierung relativ zur gegenwdrtigen CurPos
#SKM_Start     = 1      ;Positionierung relativ zum Pufferanfang
#SKM_End       = 2      ;Positionierung relativ zum Pufferende
#SKM_Bookmark  = 3      ;;Position+ = Nummer der gew|nschten Bookmark

;---------- die Parameter-Struktur f|r ;UnpackByteRun1()+ -------------------

#up_InBuf      = 0      ;(APTR)  Zeiger auf die gepackten Daten
#up_InLen      = 4      ;(ULONG) die Grv_e des gepackten Bereichs in Byte
#up_Private    = 8      ;(ULONG) beim ersten Aufruf unbedingt auf 0 setzen
#up_SizeOf     = 12

;---------- Styles, Masken u. Flags f|r ;SpecTextPrefs()+ -------------------

;** Styles **
#STS_Plain     = 0  ;normaler Text      \
#STS_Underline = 1   ;unterstrichener Text |  kvnnen durch Addition oder
#STS_Bold      = 2  ;fettgedruckter Text  |  log. ODER kombiniert werden
#STS_Italic    = 4  ;kursiver Text      /

;** Masken **
#STM_Normal  = $0  ;keine Umrandung, d.h. normale Textausgabe
#STM_Outline = $ff ;volle Umrandung
#STM_Shadow  = $1c ;Schatten unten/rechts sichtbar
#STM_Ghost   = $c1 ;dies wirkt am besten, wenn Sie als ;MPen+
;die selbe Farbe verwenden, wie der Hinter-grund hat

;** Flags **
#STF_FJAM2  = 1    ;Normalerweise benutzt ;SpecText()+ den DrawMode JAM1,
                   ;mit diesem Flag wird jedoch JAM2 erzwungen.
#STF_AP2MP  = 2    ;immer der gerade eingestellte ;APen+ des RastPorts
                   ;soll als ;MainPen+ (MPen) verwendet werden
#STF_BP2TL  = 4    ;immer der gerade eingestellte ;BPen+ des RastPorts
                   ;soll als ;TopLeftPen+ (TLPen) verwendet werden
#STF_OP2BR  = 8    ;immer der gerade eingestellte ;OPen+ des RastPorts
                   ;soll als ;BottomRightPen+ (BRPen) verwendet werden
#STF_PSWAP  = 16   ;vertauscht ;TLPen+ u. ;BRPen+, d.h. ;TLPen+ wird f|r
                   ;un./re. und ;BRPen+ f|r ob./li. verwendet

; Die folgenden Flags haben keinen Einflu_ auf die Arbeitsweise der Funk-
; tion ;SpecText()+. Sie dienen nur dazu, ;SpecTextPrefs()+ mitzuteilen,
; welche Parameter neu eingestellt werden sollen. Damit soll |berfl|ssiges
; Register-retten verhindert werden, da Sie nicht jedem Register, welches
; von ;SpecTextPrefs()+ erwartet wird, zwangsldufig einen sinnvollen Wert
; zuweisen m|ssen. Wenn Sie z.B. mit D0-D5 irgendwelche Berechnungen machen,
; oder sie als Schleifenzdhler benutzen, und wollen dann den ;MPen+ ver-
; dndern, dann brauchen Sie nur D0 mit diesem zu initialisieren und D5 das
; entsprechende Flag (STF_CMPEN) zuweisen, wdhrend Sie sich um D1-D4 nicht
; sorgen m|ssen, da diese bei jenem Aufruf vollkommen unber|hrt und unver-
; dndert bleiben, d.h. sie m|ssen weder gerettet noch initialisiert werden.
;
; ACHTUNG: Wenn keines der folgenden Flags angegeben wird, dann hei_t das
; //////// nicht, da_ KEIN Wert gedndert werden soll, sondern da_ ALLE Werte
;          zu dndern sind !! (In diesem Falle m|ssen dann logischer Weise
;                      auch alle Register initialisiert werden.)

#STF_CMPEN  = 1024   ;Nur den ;MPen+ auf den angegebenen Wert dndern.
#STF_TLPEN  = 2048   ;Nur den ;TLPen+ auf den angegebenen Wert dndern.
#STF_BRPEN  = 4096   ;Nur den ;BRPen+ auf den angegebenen Wert dndern.
#STF_STYLE  = 8192   ;Nur den SoftStyle auf den angegebenen Wert dndern.
#STF_CMASK  = 16384  ;Nur die Maske auf den angegebenen Wert dndern.
#STF_FLAGS  = 32768  ;Nur die Flags auf den angegebenen Wert dndern.

; Es kvnnen auch alle Kombinationen der obigen Flags angegeben werden. Die
; Funktion ;SpecTextPrefs()+ wird dann alles das, was Sie w|nschen, dndern.

;---------- Fehlernummern von ;LastError()+ ---------------------------------

#NoError    =  0  ;bis jetzt ist kein Fehler aufgetreten

;** DBS-Funktionen **
#BufInvalid    =  10 ;die angegebene Adresse war kein BufHandle
#NotOwner      =  11 ;nur der Task, der den Puffer vffnete, darf ihn auch wieder schlie_en
#NoBufMemory   =  12 ;nicht mehr gen|gend Speicher frei (MEMF_... s.a. bib_DataMemType)
#NoDOSProcess  =  13 ;die aufrufende Anwendung war kein DOS-Prozess
#IoErrRequired =  14  ;ein DOS-Error ist aufgetreten (;IoErr()+ der dos.library aufrufen)
#SeekBadMode   =  15 ;der angegebene ;SeekMode+ ist unbekannt
#SeekOffsetErr =  16  ;gew|nschte ;Position+ unter-/|berschreitet den Pufferanfang bzw. das Pufferende
#NoFindMem     =  17 ;kein Speicher f|r Zwischenspeicherung der zu suchenden Daten (MEMF_PUBLIC)
#FindTooLong   =  18 ;von CurPos bis EndPos bzw. Pufferanfang sind nur noch weniger Daten, als gesucht werden sollen
#NoFindAvail   =  19 ;f|r ;FindNext()/FindPrev()+ ist mindestens ein ;FindData()+ erforderlich (gilt f|r jeden mvglichen Schl|ssel)
#InvalidKey    =  20 ;ein angegebener Schl|ssel liegt au_erhalb des g|ltigen Bereichs (bei Find-Funktionen max. 8 (0-7) / bei Bookmarks max. 16 (0-15))
#MarkNotSet    =  21 ;die angegebene Bookmark ist noch nicht gesetzt
#MarkCleared   =  22 ;die Daten an der angegebenen Bookmark wurden durch ;Clear()+ gelvscht

;** StringToLong() **
#ResultValid   =  30 ;alles in Ordnung (das Ergebnis ist g|ltig)
#InvalidChar   =  31 ;im String wurde ein illegales Zeichen gefunden
#Overflow      =  32 ;reprdsentierte Zahl wdre grv_er als 32 Bit (LONG)

;** FillMem() **
#OddAddress =  35 ;ungerade Startadresse bei WORD- oder LONG-Modus
#NotFilled  =  36 ;keine F|llung wegen Abrundung (Bereich zu klein, um wenigstens 1 Wert aufzunehmen)

;** ShowMsg() **
#BadHeight    =  40 ;angegebene Hvhe war grv_er als 200 Videozeilen
#NoStructMem  =  41 ;kein Speicher f|r benvtigte Gfx-Strukturen (MEMF_PUBLIC)
#NoChipMemory =  42 ;nicht gen|gend Speicher f|r die BitPlanes (MEMF_CHIP)
#SpecTextErr  =  43 ;die Funktion ;SpecText()+ hat einen Fehler gemeldet

;---------- die Basis-Struktur der extra.library ----------------------------

#xb_Copyright  = 34  ;(APTR) ein einzeiliger Copyrightvermerk(+0)
#xb_Private    = 38  ;ab hier 54 Bytes privater Datenbereich der Library
#xb_SizeOf     = 92

;---------- von der extra.library erzeugte Alert;s --------------------------

#EL_AlertD   = $B5000000
#EL_AlertR   = $35000000
;Typen-Kennungen der extra.library ($B5000000=DeadEnd/$35000000=Recovery)

#EL_NoDfo       = $B503800B
;konnte diskfont.library V33+ (bzw. V36+ f|r CGX-Version) nicht vffnen

#EL_NoDOS       = $B5038007
;konnte dos.library V33+ (bzw. V36+ f|r CGX-Version) nicht vffnen

#EL_NoGfx       = $B5038002
;konnte graphics.library V33+ (bzw. V36+ f|r CGX-Version) nicht vffnen

#EL_NoInt       = $B5038004
;konnte intuition.library V33+ (bzw. V36+ f|r CGX-Version) nicht vffnen

#EL_NoMath   = $B5038005
;konnte mathtrans.library       V33+ oder
;konnte mathieeesingbas.library V33+ oder
;konnte mathieeedoubbas.library V33+ nicht vffnen ($B5038005)

#EL_Trespassed =  $B5068035
;Task hat Library benutzt, ohne sie vorher zu vffnen

;---------- mit extra.library verwendbare SUB-Routinen ----------------------

#SMTPOS_C   = -1  ;Text zentrieren
#SMTPOS_L   = -2  ;Text linksb|ndig
#SMTPOS_R   = -3  ;Text rechtsb|ndig

;*** extra.library / SMCOLOR() ***
;============================================================================
; Diese Routine erstellt einen Farbeintrag f|r die optional anzugebende Farb-
; tabelle f|r die Funktion ;ShowMsg()+.
;----------------------------------------------------------------------------
; Definiert:   extra.bc  (Copyright ) 1998-2006 RhoSigma, Roland Heyder)
;
; Schablone:   Pen/A/N, Red/A/N, Green/A/N, Blue/A/N, EndFlag/K/S
;
; Parameter:   Pen    --> Nr. des zu dndernden Farbstiftes (3-15)
;                       (0-2 sind reserviert u. werden ignoriert)
;
;           Red    --> Rot-Anteil der neuen Farbe (0-15)
;           Green  --> Gr|n-Anteil der neuen Farbe (0-15)
;           Blue   --> Blau-Anteil der neuen Farbe (0-15)
;
;           EndFlag --> - TRUE , dann endet hier die Farbtabelle
;                     - FALSE, dann MUSS noch ein weiterer Farbeintrag
;                             (SUB-Aufruf) folgen.
;
; Bemerkung:   Nach Aufruf der Routine f|r alle einzelnen Farbeintrdge finden
;           Sie die fertige Farbtabelle in der Variable ;smFarb$+, welche
;           Sie an ;ShowMsg()+ mittels ;SADD(smFarb$)+ |bergeben m|ssen.
;
;           Ein Beispiel f|r die Benutzung dieser Routine finden Sie in der
;           Datei ;demo/ShowMsgDemo.BAS+.
;
;   ACHTUNG:   Sie d|rfen in Ih; Programm keine eigene Stringvariable mit
;   ////////   dem Namen ;smFarb$+ verwenden, da diese unweigerlich durch
;           dieses Unterprogramm |berschrieben werden w|rde.
;
;           Au_erdem m|ssen Sie die Farbtabelle immer unmittelbar vor
;           dem ;ShowMsg()+-Aufruf definieren, da die Variable ;smFarb$+
;          jedesmal wieder |berschrieben wird, und daher immer nur die
;           zuletzt erstellte Farbtabelle enthdlt.
;
; Siehe auch:  ;SMTEXTP()+, ;SMTEXT()+, ;ShowMsg()+
;============================================================================

lFlag2.b=0

Statement SMCOLOR {Pen.w, RRed.w, GGreen.w, BBlue.w, EndFlag.b}
   SHARED smFarb$, lFlag2

   If lFlag2<>0    ; wird eine neue Farbtabelle angefangen,
      lFlag2=0     ; dann ;smFarb$+ erst zur|cksetzen
      smFarb$=""
   Else
      lFlag2=EndFlag
   EndIf

   smFarb$=smFarb$+Chr$(Pen)+Mki$(RRed*256+GGreen*16+BBlue)

   If EndFlag=0        ; wenn kein END-Flag, dann Continue-Byte
      smFarb$=smFarb$+Chr$(1) ; setzen, ansonsten 0-Byte
   Else
      smFarb$=smFarb$+Chr$(0)
   EndIf
End Statement

;*** extra.library / SMTEXTP() ***
;============================================================================
; Diese Routine erstellt einen Teilstring des Parameterstrings der Funktion
; ;ShowMsg()+ inclusive der gew|nschten Einstellungen f|r die Textausgabe.
; Wahlweise kann der Text automatisch zentriert, oder links- bzw. rechtsb|ndig
; ausgerichtet werden.
;----------------------------------------------------------------------------
; Definiert:   extra.bc  (Copyright ) 1998-2006 RhoSigma, Roland Heyder)
;
; Schablone:   xPos/A/N, yPos/A/N, MPen/A/N, TLPen/A/N, BRPen/A/N,
;           Style/A/N, Mask/A/N, Text$/A, EndFlag/K/S
;
; Parameter:   xPos   --> x-Position des Textes,
;                       oder einer der oben definierten SMTPOS-Werte
;
;           yPos   --> y-Position des Textes,
;                       Ausrichtung an der Oberkante des Fonts
;
;           MPen   --> gew|nschter MainPen        \
;           TLPen  --> gew|nschter TopLeftPen     |
;           BRPen  --> gew|nschter BottomRightPen | (s. ;SpecTextPrefs()+)
;           Style  --> gew|nschter SoftStyle      |
;           Mask   --> gew|nschte  Randmaske      /
;
;           Text$  --> der Text selbst als Variable oder Konstante
;
;           EndFlag --> - TRUE , dann endet hier der Parameterstring
;                     - FALSE, dann MUSS noch ein weiterer Teilstring
;                             (SUB-Aufruf) folgen.
;
; Bemerkung:   Nach Aufruf der Routine f|r alle einzelnen Teilstrings finden
;           Sie den fertigen Parameterstring in der Variable ;smAlert$+,
;           welche Sie an ;ShowMsg()+ mittels ;SADD(smAlert$)+ |bergeben
;           m|ssen.
;
;           Diese Routine sollten Sie nur dann verwenden, wenn Sie f|r
;           diesen Teilstring neue Einstellungen f|r Farben etc. machen
;           wollen. Wenn dieser Teilstring jedoch mit den gleichen Ein-
;           stellungen ausgegeben werden soll, wie der vorhergehende bzw.
;           Sie die Default-Einstellungen verwenden wollen, dann m|ssen
;           Sie stattdessen die Routine ;SMTEXT()+ verwenden.
;
;           Ein Beispiel f|r die Benutzung dieser Routine finden Sie in
;           der Datei ;demo/ShowMsgDemo.BAS+.
;
;   ACHTUNG:   Sie d|rfen in Ih; Programm keine eigene Stringvariable mit
;   ////////   dem Namen ;smAlert$+ verwenden, da diese unweigerlich durch
;           dieses Unterprogramm |berschrieben werden w|rde. Au_erdem
;           d|rfen Sie auch nicht ;smlFlag+ benutzen, da |ber dieses
;           wichtige Daten zwischen den beiden Routinen ;SMTEXTP()+ und
;           ;SMTEXT()+ ausgetauscht werden !!
;
;           Au_erdem m|ssen Sie den Parameterstring immer unmittelbar vor
;           dem ;ShowMsg()+-Aufruf definieren, da die Variable ;smAlert$+
;            jedesmal wieder |berschrieben wird, und daher immer nur den
;           zuletzt erstellten Parameterstring enthdlt.
;
; Siehe auch:  ;SMCOLOR()+, ;SMTEXT()+, ;ShowMsg()+
;============================================================================

smlFlag.b=0

Macro SMTEXTP ; {xPos,yPos,MPen,TLPen,BRPen,Style,Mask,Text$,EndFlag}

   xPos.w=`1 : yPos.w=`2 : MPen.w=`3 : TLPen=`4 : BRPen.w=`5
   Style.w=`6 : Mask.w=`7 : Text$=`8 : EndFlag.b=`9

   If smlFlag<>0           ; wird ein neuer ParamString angefangen,
      smlFlag=0            ; dann ;smAlert$+ erst zur|cksetzen
      smAlert$=""
   Else
      smlFlag=EndFlag
   EndIf

   If xPos=#SMTPOS_C            ; gew|nschte Ausrichtung,
      xPos=(640-(Len(Text$)*8))/2   ; falls angegeben
   Else
      If xPos=#SMTPOS_L
         xPos=12
      Else
         If xPos=#SMTPOS_R
            xPos=(640-(Len(Text$)*8))-12
         EndIf
      EndIf
   EndIf

   smAlert$=smAlert$+Mki$(xPos)+Chr$(yPos)+Chr$(1)+Chr$(MPen)+Chr$(TLPen)
   smAlert$=smAlert$+Chr$(BRPen)+Chr$(Style)+Chr$(Mask)+Text$+Chr$(0)

   If EndFlag=0                       ; wenn kein END-Flag, dann Continue-Byte
      smAlert$=smAlert$+Chr$(1)  ; setzen, ansonsten 0-Byte
   Else
      smAlert$=smAlert$+Chr$(0)
   EndIf

End Macro

;*** extra.library / SMTEXT() ***
;============================================================================
; Diese Routine erstellt einen Teilstring des Parameterstrings der Funktion
; ;ShowMsg()+. Wahlweise kann der Text automatisch zentriert, oder links- bzw.
; rechtsb|ndig ausgerichtet werden.
;----------------------------------------------------------------------------
; Definiert:   extra.bc  (Copyright ) 1998-2006 RhoSigma, Roland Heyder)
;
; Schablone:   xPos/A/N, yPos/A/N, Text$/A, EndFlag/K/S
;
; Parameter:   xPos   --> x-Position des Textes,
;                       oder einer der oben definierten SMTPOS-Werte
;
;           yPos   --> y-Position des Textes,
;                       Ausrichtung an der Oberkante des Fonts
;
;           Text$  --> der Text selbst als Variable oder Konstante
;
;           EndFlag --> - TRUE , dann endet hier der Parameterstring
;                     - FALSE, dann MUSS noch ein weiterer Teilstring
;                             (SUB-Aufruf) folgen.
;
; Bemerkung:   Nach Aufruf der Routine f|r alle einzelnen Teilstrings finden
;           Sie den fertigen Parameterstring in der Variable ;smAlert$+,
;           welche Sie an ;ShowMsg()+ mittels ;SADD(smAlert$)+ |bergeben
;           m|ssen.
;
;           Dieses Macro sollten Sie nur dann verwenden, wenn Sie f|r
;           diesen Teilstring die gleichen Einstellungen wie f|r den vor-
;           hergehenden Teilstring verwenden wollen. Wenn dieser Teil-
;           string jedoch neue Einstellungen f|r Farben etc. erhalten
;           soll, dann m|ssen Sie stattdessen das Macro ;SMTEXTP()+ ver-
;           wenden.
;
;           Ein Beispiel f|r die Benutzung dieser Routine finden Sie in
;           der Datei ;demo/ShowMsgDemo.BAS+.
;
;   ACHTUNG:   Sie d|rfen in Ih; Programm keine eigene Stringvariable mit
;   ////////   dem Namen ;smAlert$+ verwenden, da diese unweigerlich durch
;           dieses Unterprogramm |berschrieben werden w|rde. Au_erdem
;           d|rfen Sie auch nicht ;smlFlag+ benutzen, da |ber dieses
;           wichtige Daten zwischen den beiden Routinen ;SMTEXTP()+ und
;           ;SMTEXT()+ ausgetauscht werden !!
;
;           Au_erdem m|ssen Sie den Parameterstring immer unmittelbar vor
;           dem ;ShowMsg()+-Aufruf definieren, da die Variable ;smAlert$+
;            jedesmal wieder |berschrieben wird, und daher immer nur den
;           zuletzt erstellten Parameterstring enthdlt.
;
; Siehe auch:  ;SMCOLOR()+, ;SMTEXTP()+, ;ShowMsg()+
;============================================================================

smlFlag.b=0

Statement SMTEXT{xPos.w, yPos.w, Text$, EndFlag.b}
   SHARED smAlert$, smlFlag

   If smlFlag<>0           ; wird ein neuer ParamString angefangen,
      smlFlag=0            ; dann ;smAlert$+ erst zur|cksetzen
      smAlert$=""
   Else
      smlFlag=EndFlag
   EndIf

   If xPos=#SMTPOS_C                 ; gew|nschte Ausrichtung,
      xPos=(640-(Len(Text$)*8))/2    ; falls angegeben
   Else
      If xPos=#SMTPOS_L
         xPos=12
      Else
         If xPos=#SMTPOS_R Then xPos=(640-(Len(Text$)*8))-12
      EndIf
   EndIf

   smAlert$=smAlert$+Mki$(xPos)+Chr$(yPos)+Chr$(0)+Text$+Chr$(0)

   If EndFlag=0                  ; wenn kein END-Flag, dann Continue-Byte
      smAlert$=smAlert$+Chr$(1)  ; setzen, ansonsten 0-Byte
   Else
      smAlert$=smAlert$+Chr$(0)
   EndIf
End Statement


; re-wrote getstring

Function.s GetString{addy.l}
   slen.l=Peek.l(addy-4) : ret$=""
   If slen>0 Then ret$=String$(" ",slen) : CopyMem_ addy, &ret$, slen
   Function Return ret$
End Function


