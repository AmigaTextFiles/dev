
; OS friendly file I/O functions by Lorence Lombardo.
; Version 1.2  (C) 2007   4/6/07

;  #R=read, #W=write, #RW=read/write,  eoff = End of File flag

; Both readline and readchunk have an inbuilt "eoff" return which will
; return the file handle when the condition is true. ie. eoff = file_handle
; "eoff" will be reset to zero on the next read which takes place.
; Using the inbuilt "eoff" return is not so good or easy if your needing to
; check multiple EOF's at the same time. In this case consider using the
; "eoff{}" function instead.

; When reading from pipes the "eoff{}" function does not work. In this case
; use "eoff" rather than "eoff{}". If using readchunk a return of an empty
; string can also be used. If your really impatient when using readchunk
; you can also check weather the return size of your last chunk was less
; than what you specified. :)

; fyl = file handle,  lench = length of chunk,  tex$ = text to write

#R=1005: #W=1006: #RW=1004


; readline = rnl    like Edit$()
Function.s rln{fyl.l}
   SHARED eoff.l: eoff=0
   intt$="": l$=Chr$(10): cr$=Chr$(13): in1$=l$
   Repeat
      ln.l=Read_(fyl, &in1$, 1)
      If in1$<>l$ AND in1$<>cr$ AND ln>0 Then intt$=intt$+in1$
   Until in1$=l$ OR ln<1 OR Len(intt$)>999  ; Sets maximum line to 1000 characters.
   If ln<1 Then eoff=fyl
   Function Return intt$
End Function


; readchunk = rch    like Inkey$()
Function.s rch{fyl.l, lench.l}
   SHARED eoff.l: eoff=0
   intt$=String$(" ", lench)  ; allocate string space .
   ln.l=Read_(fyl, &intt$, lench): If ln<1 Then intt$="": eoff=fyl
   If ln<lench AND ln>0 Then intt$=Left$(intt$,ln)
   Function Return intt$
End Function


; End of File flag     like Eof()
Function.b eoff{fyl.l}
   sz1.l=0: sz2.l=0: eofret.b=0
   If ExamineFH_ (fyl, fib.FileInfoBlock) Then sz1=fib\fib_Size
   sz2 = Seek_ (fyl, 0, #OFFSET_CURRENT)
   If sz1=sz2 Then eofret=-1
   Function Return eofret
End Function


; filesize handle = fsz  ; use this for opened files only, supplying a handle
Function.l fsz{fyl.l}
   sz.l=0: If ExamineFH_ (fyl, fib.FileInfoBlock) Then sz=fib\fib_Size
   Function Return sz
End Function


; filesize name = fszs  ; use this for un-opened files, supplying a string
Function.l fszs{fyl$}
   fyl.l=Open_(&fyl$, #R): sz.l=0
   If fyl
      If ExamineFH_ (fyl, fib.FileInfoBlock) Then sz=fib\fib_Size
      Close_ (fyl)
   EndIf
   Function Return sz
End Function


; writeline  = wln     like NPrint
Statement wln{fyl.l, tex$}
   tex$=tex$+Chr$(10): Write_ fyl, &tex$, Len(tex$)
End Statement


; writechunk = wch     like Print
Statement wch{fyl.l, tex$}
   Write_ fyl, &tex$, Len(tex$)
End Statement

; end of file I/O functions.



; Start of file I/O functions example demo
; Use from CLI
; PutStr_ is the OS's equivalent to Blitz's Print
; Use a Chr$(10) on the end to make it an NPrint :)

l$=Chr$(10): f$="s:user-startup"

fsz1.l=fszs{f$}
PutStr_ l$+"The "+f$+" file size before opening is "+Str$(fsz1)+l$+l$

infile.l=Open_(&f$, #R)
If infile

   fsz2.l=fsz{infile}
   PutStr_ "The "+f$+" file size after opening is still "+Str$(fsz2)+l$+l$

   PutStr_ "Reading "+f$+"..."+l$+l$

   Repeat

      in$=rln{infile}  ; readline
      If eoff<>infile Then PutStr_ in$+l$
      br=CtrlC

   Until eoff{infile} OR br<>0

   ; "eoff{infile}" can also be replaced with "eoff=infile"
   ; or "eoff<>0" in this case.

   Close_ (infile): If br<>0 Then PutStr_ l$+" User abort...!!!"+l$

Else

   PutStr_ l$+" Unable to read "+f$+l$

EndIf

PutStr_ l$

