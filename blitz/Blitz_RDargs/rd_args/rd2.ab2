
; This is basically a much lighter version of Thilo Koehler's arg routine
; by me. ;) It is slightly less automated and requires slightly more effort
; from the programer but should produce slightly smaller exe sizes.
; Not a big deal for big progs, but it is for little CLI commands.

; But if you dont have too many args then good ol Par$() should suffice. ;)


; can do up to 127 args
; beyond that will be a failure to initialize.


NEWTYPE .rdargs : arghandle.l : strings.l : End NEWTYPE

args.rdargs\arghandle = 0


Function.l InitArgs{}  ; <- This must be done 1st. A 0 return means u should quit. ;)
   a$="all/M" : SHARED args
   args\arghandle = ReadArgs_ (&a$, &args\strings,0)
   Function Return args\arghandle
End Function


Function.w NumArgs{}  ; <- like NumPars
   c.w=0 : SHARED args
   Repeat
      sptr.l=Peek.l(args\strings+c)
      If sptr<>0 Then c+4
   Until sptr=0
   Function Return c/4
End Function


Function.s ArgN{n.w}  ; <- like Par$()
   SHARED args : arg$=""
   sptr.l=Peek.l(args\strings+((n-1)*4))
   If sptr<>0 Then arg$=Peek$(sptr)
   Function Return arg$
End Function


Statement FreeArgs{}  ; <- This must be done when u r finished with the above funs
   SHARED args : If args\arghandle<>0 Then FreeArgs_ args\arghandle
End Statement


;-----------------------------------------------------------------------------------


If InitArgs{}=0 Then End Else np.w=NumArgs{}

NPrint np

For x.w=1 To np
   NPrint x," - "+ArgN{x}
Next x

FreeArgs{} : End



