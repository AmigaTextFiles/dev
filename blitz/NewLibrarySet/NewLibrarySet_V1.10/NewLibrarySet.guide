@DATABASE New Screen Library.Guide
$VER: New Libray Set.guide V1.00 (14.07.1998) by Laboureur -> AlphaSOUND <- Frédéric
@NODE MAIN "New Screen Library.guide"

*************************************************************************

                          New Commands Set V1.00

                   All coding done by -> AlphaSOUND <-
                      © 1998 - Fantaisie Software -

*************************************************************************


  @{"      Introduction       " LINK INTRO}  Why you should use the libraries.
  @{"       Copyrights        " LINK COPYR}  Legal stuffs.
  @{"      Installation       " LINK INSTA}  How install this package

  @{"  Libraries description  " LINK DESCR}  All commands descriptions.
  @{"    Speed comparaison    " LINK SPEED}  Some speed tests.

  @{"      Future plans       " LINK FUTUR}  What it could be done.
  @{"       The author        " LINK AUTHO}  Contact me !

  @{"         History         " LINK HISTO}  What's new...



                       © 1998 - Fantaisie Software

@ENDNODE


@NODE INTRO "Introduction"

    @{b}Introduction:@{ub}

  This new library set for the Blitz  Basic  II  has  been  designed  to
  replace the old Blitz2 functions in an much more efficient way.

  The 2 first libraries to  be  replaced  are  the  Screen  and  Windows
  libraries.  Why ? Simply because these libraries was the most bad done
  in Blitz 2.


    @{b}Advantages of the new library set:@{ub}

  + ALL the functions can be tested if they success. It's very important
  to  know  if  a  screen  or  a window has been really opened before to
  operate on it ! Old commands don't allow that and the program crashed.

  + The tiny size of the executable compiled with the new  library  set.
  You can expect under 1 Kb program which open a screen and some windows
  ! Try it with the original commmands and you will have an huge  30  kb
  program, even if you only have 2 code line.

  +  You  manipulate  directly the real object pointer (Intuition Window
  and Screen pointer). Very useful for advanced window or screen control
  for experienced coders.

  + Could be have more commmands that original libraries

  + No more MAXIMUM OBJECT Limitation. No Limits :)

  + Totally system friendly !

  + Easy to use and to install

  + Supported and under developpement !

  + All functions are fully tested and bug free ! If a bug exist it will
  be removed as soon as possible !

@ENDNODE


@NODE COPYR "Copyrights"

    @{b}Copyrights:@{ub}

  This package is freely distribuable. Spread it and  use  it  like  you
  want.  May  be you should name me in the credits of your software :-).
  Enough for now, it's freeware.

@ENDNODE


@NODE INSTA "Installation"

    @{b}Installation:@{ub}

  1 - Automatic solution (Recommended)

    Click on the Install icon and follow the instructions.

@ENDNODE


@NODE DESCR "Libraries description"

    @{b}Libraries description:@{ub}

  Actually, the new set support 6 libraries :

    @{"  Window  " LINK WINDOW} (LibNum = #35 : 20 commands)
    @{"  Screen  " LINK SCREEN} (LibNum = #36 : 11 commands)
    @{"  String  " LINK STRING} (LibNum = #37 :  2 commands)
    @{"  Memory  " LINK MEMORY} (LibNum = #38 :  6 commands)
    @{"  Chunky  " LINK CHUNKY} (LibNum = #39 :  3 commands)
    @{"   Misc   " LINK MISC  } (LibNum = #40 :  6 commands)


  Now, a little table to see the size difference between use of new  set
  commands  and  old  Blitz  2 commands. All theses executables has been
  produced with debugger OFF. The result is given  in  bytes,  it's  the
  final executable size.


                        | Old Blitz 2 Commands | New libary set commands |
                        |----------------------+-------------------------|
  Windows only commands |    14 000 bytes      |            600 bytes    |
  Screen  only commands |     7 700 bytes      |            500 bytes    |
  String  only commands |     1 960 bytes      |            876 bytes    |
  Memory  only commands |       448 bytes      |            344 bytes    |
  Misc    only commands |     1 924 bytes      |            404 bytes    |
  Chunky  only commands |    Not Available     |            680 bytes    |

@ENDNODE


@NODE SCREEN "The screen commands"

    @{b}The screen commands descriptions:@{ub}

 
  For all the commands which return an ScreenID, you must  use  an  long
  typed  variable  (.l) to store this value. It's an standard pointer to
  an Intuition  Screen  so  you  can  use  it  directely  (for  advanced
  programmers).  If  ScreenID  = 0 then the command has failed. Easy for
  testing.


  There is 11 screen specifics commands:

  @{" NFindScreen    " LINK NFindScreen} Function (ScreenID)
  @{" NWbToScreen    " LINK NWbToScreen} Function (ScreenID)
  @{" NScreen        " LINK NScreen} Function (ScreenID)
  @{" NSMouseX       " LINK NSMouseX} Function (Word)
  @{" NSMouseY       " LINK NSMouseY} Function (Word)
  @{" NScreenWidth   " LINK NScreenWidth} Function (Word)
  @{" NScreenHeight  " LINK NScreenHeight} Function (Word)
  @{" NShowScreen    " LINK NShowScreen} Statement
  @{" NHideScreen    " LINK NHideScreen} Statement
  @{" NUseScreen     " LINK NUseScreen} Statement
  @{" NCloseScreen   " LINK NCloseScreen} Statement

@ENDNODE

@NODE NFindScreen

    @{b}NAME@{ub}
  NFindScreen

    @{b}SYNOPSIS@{ub}
  ScreenID.l = NFindScreen

    @{b}FUNCTION@{ub}
  Find the front most screen  and  return  its  ScreenID  pointer.  This
  pointer  is a fully legal intuition pointer so advanced programmer can
  used it to get more information by the screen structure.

    @{b}RESULTS@{ub}
  A ScreenID pointer. If NULL, the command has failed.

@ENDNODE

@NODE poNFindScreen

    @{b}NAME@{ub}

    @{b}SYNOPSIS@{ub}

    @{b}FUNCTION@{ub}

    @{b}RESULTS@{ub}

@ENDNODE


@NODE NWbToScreen

    @{b}NAME@{ub}
  NWbToScreen

    @{b}SYNOPSIS@{ub}
  ScreenID.l = NWbToScreen

    @{b}FUNCTION@{ub}
  Find the Workbench screen and return its ScreenID.

    @{b}RESULTS@{ub}
  A ScreenID pointer. If NULL, the Workbench screen is not found.

@ENDNODE


@NODE NScreen

    @{b}NAME@{ub}
  NScreen

    @{b}SYNOPSIS@{ub}
  ScreenID.l = NScreen(TagList)

    @{b}FUNCTION@{ub}
  Open a new screen specified by the TagList and return its ScreenID.

  Here is a quick list of all valid screentags (for more details, consult the
  commodore autodocs):

  #SA_Left      ; Traditional screen positions and dimensions
  #SA_Top       ;
  #SA_Width     ;
  #SA_Height    ;

  #SA_Depth     ; Screen BitMap Depth
  #SA_DetailPen ; serves as Default For windows, too
  #SA_BlockPen  ;
  #SA_Title     ; Default Screen title

  #SA_Colors    ;

  #SA_ErrorCode ; ti_Data points To LONG error code (values below)
  #SA_Font      ;
  #SA_SysFont   ; Selects one of the preferences system fonts:
                ;  0 - old DefaultFont, fixed-width
                ;  1 - WB Screen preferred font
  #SA_Type      ;
  #SA_BitMap    ;
  #SA_PubName   ;

  #SA_PubSig    ; Task ID AND signal For being notified that
  #SA_PubTask   ; the last Window has closed On a public Screen.

  #SA_DisplayID ;
  #SA_DClip     ;
  #SA_Overscan  ; Set To one of the OSCAN_

;
; *** booleans ***
;

  #SA_ShowTitle  =$80000036 ; boolean equivalent To flag SHOWTITLE
  #SA_Behind     =$80000037 ; boolean equivalent To flag SCREENBEHIND
  #SA_Quiet      =$80000038 ; boolean equivalent To flag SCREENQUIET
  #SA_AutoScroll =$80000039 ; boolean equivalent To flag AUTOSCROLL
  #SA_Pens       =$8000003A ; Pointer To ~0 terminated UWORD array, as
                          ; found in struct DrawInfo

  #SA_FullPalette ;

; For V39+ (Rom 3.0+)
  #SA_ColorMapEntries ;
  #SA_Parent          ;
  #SA_Draggable       ;

  #SA_Exclusive       ;
  #SA_SharePens       ;
  #SA_BackFill        ;
  #SA_Interleaved     ;
  #SA_Colors32        ;
  #SA_VideoContro     ;
  #SA_FrontChild      ;
  #SA_BackChild       ;
  #SA_LikeWorkbench   ;
  #SA_MinimizeISG     ;


  @{b}NOTE: the amigalibs.res file must be entered in the compiler/option window.@{ub}

    @{b}RESULTS@{ub}
  A ScreenID pointer. If NULL, the screen can't opened.

@ENDNODE


@NODE NSMouseX

    @{b}NAME@{ub}
  NSMouseX

    @{b}SYNOPSIS@{ub}
  x.w = NSMouseX

    @{b}FUNCTION@{ub}
  Return the actual mouse position in pixel relative to the left of the used screen.

@ENDNODE


@NODE NSMouseY

    @{b}NAME@{ub}
  NSMouseX

    @{b}SYNOPSIS@{ub}
  y.w = NSMouseY

    @{b}FUNCTION@{ub}
  Return the mouse position in pixel relative to the top of the used screen.

@ENDNODE

@NODE NScreenWidth

    @{b}NAME@{ub}
  NScreenWidth

    @{b}SYNOPSIS@{ub}
  width.w = NScreenWidth

    @{b}FUNCTION@{ub}
  Return the width in pixel of the used screen.

@ENDNODE


@NODE NScreenHeight

    @{b}NAME@{ub}
  NScreenHeight

    @{b}SYNOPSIS@{ub}
  height.w = NScreenHeight

    @{b}FUNCTION@{ub}
  Return the height in pixel of the used screen.

@ENDNODE


@NODE NShowScreen

    @{b}NAME@{ub}
  NShowScreen

    @{b}SYNOPSIS@{ub}
  NShowScreen

    @{b}STATEMENT@{ub}
  Put the used screen to the front of the display.

@ENDNODE


@NODE NHideScreen

    @{b}NAME@{ub}
  NHideScreen

    @{b}SYNOPSIS@{ub}
  NHideScreen

    @{b}STATEMENT@{ub}
  Put the used screen to the back of the display.

@ENDNODE


@NODE poNFindScreen

    @{b}NAME@{ub}

    @{b}SYNOPSIS@{ub}

    @{b}FUNCTION@{ub}

    @{b}RESULTS@{ub}

@ENDNODE


@NODE NUseScreen

    @{b}NAME@{ub}
  NUseScreen

    @{b}SYNOPSIS@{ub}
  NUseScreen ScreenID

    @{b}STATEMENT@{ub}
  Change the used screen to the given ScreenID.

@ENDNODE


@NODE NCloseScreen

    @{b}NAME@{ub}
  NCloseScreen

    @{b}SYNOPSIS@{ub}
  NCloseScreen

    @{b}STATEMENT@{ub}
  Close the used screen.

@ENDNODE


@NODE WINDOW "The Window commands"

    @{b}Window commands description:@{ub}

  For all the commands which return an WindowID, you must  use  an  long
  typed  variable  (.l) to store this value. It's an standard pointer to
  an Intuition  Window  so  you  can  use  it  directely  (for  advanced
  programmers).  If  WindowID  = 0 then the command has failed. Easy for
  testing.

  There is 20 windows specifics commands:

  @{" NWindow          " LINK NWindow} Function (WindowID)
  @{" NWMouseX         " LINK NWMouseX} Function (Word)
  @{" NWMouseY         " LINK NWMouseY} Function (Word)
  @{" NWindowWidth     " LINK NWindowWidth}
  @{" NWindowHeight    " LINK NWindowHeight}
  @{" NWindowX         " LINK NWindowX}
  @{" NWindowY         " LINK NWindowY}
  @{" NRastPort        " LINK NRastPort}
  @{" NWColour         " LINK NWColour}
  @{" NWLocate         " LINK NWLocate}
  @{" NWPrint          " LINK NWPrint}
  @{" NWindowTextStyle " LINK NWindowTextStyle}
  @{" NWMove           " LINK NWMove}
  @{" NWSize           " LINK NWSize}
  @{" NWindowFont      " LINK NWindowFont}
  @{" NWPlot           " LINK NWPlot}
  @{" NWBox            " LINK NWBox}
  @{" NActivate        " LINK NWActivate}
  @{" UseWindow        " LINK NUseWindow}
  @{" CloseWindow      " LINK NCloseWindow}

@ENDNODE

@NODE

    @{b}NAME@{ub}

    @{b}SYNOPSIS@{ub}

    @{b}FUNCTION@{ub}

    @{b}RESULTS@{ub}

@ENDNODE


@NODE NWindow

    @{b}NAME@{ub}
  NWindow

    @{b}SYNOPSIS@{ub}
  WindowID.l = NWindow(TagList)

    @{b}FUNCTION@{ub}
  Open a new window according  to  the  specified  taglist.  The  window
  opened  become  the  used window. You don't need to use the NUseWindow
  command to set it.

  Here is a quick list of all valid windowtags (for more details, consult the
  commodore autodocs):

  #WA_Left
  #WA_Top
  #WA_Width
  #WA_Height
  #WA_DetailPen
  #WA_BlockPen
  #WA_IDCMP

  #WA_Flags
  #WA_Gadgets
  #WA_Checkmark
  #WA_Title

  #WA_ScreenTitle
  #WA_CustomScreen
  #WA_SuperBitMap

  #WA_MinWidth
  #WA_MinHeight
  #WA_MaxWidth
  #WA_MaxHeight

  #WA_InnerWidth
  #WA_InnerHeight

  #WA_PubScreenName
  #WA_PubScreen
  #WA_PubScreenFallBack
  #WA_WindowName

  #WA_Colors

  #WA_Zoom
  #WA_MouseQueue
  #WA_BackFill
  #WA_RptQueue

  ; Booleans..

  #WA_SizeGadget
  #WA_DragBar
  #WA_DepthGadget
  #WA_CloseGadget
  #WA_Backdrop
  #WA_ReportMouse
  #WA_NoCareRefresh
  #WA_Borderless
  #WA_Activate
  #WA_RMBTrap
  #WA_WBenchWindow
  #WA_SimpleRefresh
  #WA_SmartRefresh

  #WA_SizeBRight
  #WA_SizeBBottom

  ; V39+

  #WA_AutoAdjust
  #WA_GimmeZeroZero
  #WA_MenuHelp
  #WA_NewLookMenus
  #WA_AmigaKey
  #WA_NotifyDepth
  #WA_Pointer
  #WA_BusyPointer
  #WA_PointerDelay
  #WA_TabletMessages
  #WA_HelpGroup
  #WA_HelpGroupWindow


    @{b}RESULTS@{ub}
  A WindowID pointer. If NULL, the window has failed its opening

@ENDNODE


@NODE NWMouseX

    @{b}NAME@{ub}
  NWMouseX

    @{b}SYNOPSIS@{ub}
  x.w = NWMouseX

    @{b}FUNCTION@{ub}
  Return the actual mouse position from the left of the used window.

@ENDNODE


@NODE NWMouseY

    @{b}NAME@{ub}
  NWMouseY

    @{b}SYNOPSIS@{ub}
  y.w = NWMouseY

    @{b}FUNCTION@{ub}
  Return the actual mouse position from the  top  of  the  used  window.
  Values can be positive or negative.

@ENDNODE


@NODE NWindowWidth

    @{b}NAME@{ub}
  NWindowWidth

    @{b}SYNOPSIS@{ub}
  width.w = NWindowWidth

    @{b}FUNCTION@{ub}
  Return the width in pixel of the used window.

@ENDNODE


@NODE NWindowHeight

    @{b}NAME@{ub}
  NWindowHeight

    @{b}SYNOPSIS@{ub}
  height.w = NWindowHeight

    @{b}FUNCTION@{ub}
  Return the height in pixel of the used window.

@ENDNODE


@NODE NWindowX

    @{b}NAME@{ub}
  NWindowX

    @{b}SYNOPSIS@{ub}
  x.w = NWindowX

    @{b}FUNCTION@{ub}
  Return the left position in pixel of the used window.

@ENDNODE


@NODE NWindowY

    @{b}NAME@{ub}
  NWindowY

    @{b}SYNOPSIS@{ub}
  y.w = NWindowY

    @{b}FUNCTION@{ub}
  Return the top position in pixel of the used window.

@ENDNODE


@NODE NRastPort

    @{b}NAME@{ub}
  NRastPort

    @{b}SYNOPSIS@{ub}
  rastport.l = NRastPort

    @{b}FUNCTION@{ub}
  Return the rastport of the used window. RastPort is  very  useful  for
  advanced  coder  to  use  the  AmigaOS external graphic function under
  Blitz 2.

@ENDNODE


@NODE NWColour

    @{b}NAME@{ub}
  NWColour

    @{b}SYNOPSIS@{ub}
  NWColour(FrontColour, BackColour)

    @{b}STATEMENT@{ub}
  Set the default back and front colour for graphic function and text display.

  Functions affected by NWColour:

  NWBox, NWPrintFast, NWPlot.

@ENDNODE


@NODE NWLocate

    @{b}NAME@{ub}
  NWLocate

    @{b}SYNOPSIS@{ub}
  NWLocate(x,y)

    @{b}FUNCTION@{ub}
  Set the text cursor to given position (for NWPrintFast).

@ENDNODE


@NODE NWPrint

    @{b}NAME@{ub}
  NWPrint

    @{b}SYNOPSIS@{ub}
  NWPrint(String$)

    @{b}STATEMENT@{ub}
  Display the given string  on  the  used  window  at  position  set  by
  NWLocate and with the colours set by NWColour. You can use NWTextStyle
  to change the output style (bold, italic, underline).

@ENDNODE


@NODE NWTextStyle

    @{b}NAME@{ub}
  NWTextStyle

    @{b}SYNOPSIS@{ub}
  NWTextStyle(Style)

    @{b}STATEMENT@{ub}
  Set the style for futur window textoutput (NWPrintFast).

  The legal Style values are:

    0 = Nothing
    1 = Underline
    2 = Bold
    4 = Italic

  You can mix it if needed (Bold+Italic will be 2+4 = 6)

@ENDNODE


@NODE NWMove

    @{b}NAME@{ub}
  NWMove

    @{b}SYNOPSIS@{ub}
  NWMove(x,y)

    @{b}STATEMENT@{ub}
  Move the window to the specified coordinates.

@ENDNODE


@NODE NWSize

    @{b}NAME@{ub}
  NWSize

    @{b}SYNOPSIS@{ub}
  NWSize(width, height)

    @{b}STATEMENT@{ub}
  Resize the window to given dimensions.

@ENDNODE


@NODE NWindowFont

    @{b}NAME@{ub}
  NWindowFont

    @{b}SYNOPSIS@{ub}
  NWindowFont(FontID)

    @{b}STATEMENT@{ub}
  Set the window current font to given FontID.

  FontID MUST be an legal IntuiFont Pointer.  New  Font  library  coming
  soon.

@ENDNODE


@NODE NWPlot

    @{b}NAME@{ub}
  NWPlot

    @{b}SYNOPSIS@{ub}
  NWPlot(x,y)

    @{b}STATEMENT@{ub}
  Draw a plot of the active color (set by NWColour) on the used window.

@ENDNODE


@NODE NWBox

    @{b}NAME@{ub}
  NWBox

    @{b}SYNOPSIS@{ub}
  NWBox(x1, y1, x2, y2)

    @{b}STATEMENT@{ub}
  Draw a filled box of the active color (set by NWColour) on the used window.

  NOTE: coordinates must be given in the right order (x1 < x2 and y1 < y2)

@ENDNODE


@NODE NWActivate

    @{b}NAME@{ub}
  NWActivate

    @{b}SYNOPSIS@{ub}
  NWActivate(WindowID)

    @{b}STATEMENT@{ub}
  Activate the given window and set it like used window.

@ENDNODE


@NODE NUseWindow

    @{b}NAME@{ub}
  NUseWindow

    @{b}SYNOPSIS@{ub}
  NUseWindow(WindowID)

    @{b}STATEMENT@{ub}
  Change the used window to given window.

@ENDNODE


@NODE NCloseWindow

    @{b}NAME@{ub}
  NCloseWindow

    @{b}SYNOPSIS@{ub}
  NCloseWindow(WindowID)

    @{b}STATEMENT@{ub}
  Close the given window.

@ENDNODE


@NODE STRING "The string commands"

    @{b}The string commands descriptions:@{ub}

  There is 2 commands:

  @{" NAsc         " LINK NAsc} Function (Long)
  @{" NLen         " LINK NLen} Function (Long)

@ENDNODE


@NODE NAsc

    @{b}NAME@{ub}
  NAsc

    @{b}SYNOPSIS@{ub}
  asc.l = NAsc(String$)

    @{b}FUNCTION@{ub}
  Return the ascii value of the first string letter.

@ENDNODE


@NODE NLen

    @{b}NAME@{ub}
  NLen

    @{b}SYNOPSIS@{ub}
  length.l = NLen(String$)

    @{b}FUNCTION@{ub}
  Return the caracter length of the string.

@ENDNODE


@NODE MEMORY "The memory commands"

    @{b}The memory commands descriptions:@{ub}

  There is 2 commands:

  @{" NPokeB, NPokeW, NPokeL " LINK NPOKE} Statement
  @{" NPeekB, NPeekW, NPeekL " LINK NPEEK} Function

@ENDNODE


@NODE NPoke

    @{b}NAME@{ub}
  NPokeB, NPokeW, NPokeL

    @{b}SYNOPSIS@{ub}
  NPokeX(Address, Data)

    @{b}FUNCTION@{ub}
  Poke the specified data to the specified address.

  NPokeB will poke 1 byte  (NPokeByte)
  NPokeW will poke 2 bytes (NPokeWord)
  NPokeL will poke 4 bytes (NPokeLong)

@ENDNODE


@NODE NPeek

    @{b}NAME@{ub}
  NPeekB, NPeekW, NPeekL

    @{b}SYNOPSIS@{ub}
  value = NPeekX(Address)

    @{b}FUNCTION@{ub}
  Peek the data to the specified address.

  NPeekB will peek 1 byte  (NPeekByte)
  NPeekW will peek 2 bytes (NPeekWord)
  NPeekL will peek 4 bytes (NPeekLong)

@ENDNODE


@NODE CHUNKY "The chunky commands"

  !!!! IMPORTANT !!!!

  This library is under devellopement and its  not  finished.  You  must
  handle yourself the chunky buffer and the chunky shapes. More commands
  like NChunkyBuffer,  LoadChunkyShape  and  more  will  come  later  if
  needed...

  !!!!!!!!!!!!!!!!!!!

    @{b}The chunky commands descriptions:@{ub}

  There is 3 commands:

  @{" NChunkyBlit   " LINK NChunkyBlit} Statement
  @{" NChunkyBlock2 " LINK NChunkyBlock2} Statement
  @{" NChunkyBlock4 " LINK NChunkyBlock4} Statement

@ENDNODE


@NODE NChunkyBlit

    @{b}NAME@{ub}
  NChunkyBlit

    @{b}SYNOPSIS@{ub}
  NChunkyBlit(Shape Address, ChunkyBuffer Address, Shape Width, Shape Height, Bitmap width)

    @{b}FUNCTION@{ub}
  Blit the specified chunky shape  to  the  given  Chunky  buffer.  This
  function  use  the 0 colour like transparent. It's an highly optimized
  function. The shape can be of any size. This function  isn't  clipped,
  so  be  sur  to  be  INSIDE  the  chunky  buffer when you perform your
  blitting.

@ENDNODE


@NODE NChunkyBlock2

    @{b}NAME@{ub}
  NChunkyBlock2

    @{b}SYNOPSIS@{ub}
  NChunkyBlock2(Shape Address, ChunkyBuffer Address, Shape Width, Shape Height, Bitmap width)

    @{b}FUNCTION@{ub}
  This function is 2.5 time faster than the NChunkyBlit function but has
  some limitations:

  * The shape width must be a multiple of 2.
  * There is no transparent colors.

  This function isn't clipped so be sur to Blit INSIDE the buffer.

@ENDNODE


@NODE NChunkyBlock4

    @{b}NAME@{ub}
  NChunkyBlock4

    @{b}SYNOPSIS@{ub}
  NChunkyBlock4(Shape Address, ChunkyBuffer Address, Shape Width, Shape Height, Bitmap width)

    @{b}FUNCTION@{ub}
  This function is 5 time faster than the NChunkyBlit function but has
  some limitations:

  * The shape width must be a multiple of 4.
  * There is no transparent colors.

  This function isn't clipped so be sure to Blit INSIDE the buffer.

  NOTE: This is the fastest way to Blit a shape inside a chunky  buffer.
  This function has been especially optimized for speed.

@ENDNODE


@NODE MISC "The misc commands"

    @{b}The misc commands descriptions:@{ub}

  There is 3 commands:

  @{" Boolean Values  " LINK Booleans} Functions
  @{" NMouseWait      " LINK NMouseWait} Statement
  @{" NVWait          " LINK NVWait} Statement

@ENDNODE


@NODE Booleans

    @{b}NAME@{ub}
  NTrue, NFalse, NOn, NOff

    @{b}SYNOPSIS@{ub}
  a = NTrue
  b = NOff...

    @{b}FUNCTION@{ub}
  There are used to do the code more readable.

  In Blitz 2:

  * True/On   = -1
  * False/Off =  0

  If you can, DON'T use them ! Just replace them by -1 or 0.  It's  much
  more faster and your code will be smaller.

@ENDNODE


@NODE NMouseWait

    @{b}NAME@{ub}
  NMouseWait

    @{b}SYNOPSIS@{ub}
  NMouseWait

    @{b}FUNCTION@{ub}
  This function wait for a  mouse  button  click.  It's  totally  system
  friendly so you can use it safely in any program.

@ENDNODE


@NODE NVWait

    @{b}NAME@{ub}
  NVWait

    @{b}SYNOPSIS@{ub}
  NVWait

    @{b}FUNCTION@{ub}
  Wait until the next frame begin. It's also know as Vertical Wait. Used
  to synchronize animation with the display.

@ENDNODE

@NODE SPEED "Speed results"

    @{b}Speed results:@{ub}

  All the replacement functions are, for now, at least as fast than orignal Acid ones. And better,
  some of the new functions are faster !

  Here is a little list of functions faster on a 1230/50 Amiga.

  NPoke   : +20 %
  NPeek   : +30 %

  NWPlot  : +20 %
  NWBox   : +20 %

  NWPrint : +10 %

@ENDNODE


@NODE FUTUR "Future plans"

    @{b}Future plans:@{ub}

  For now, a new font library  is  under  developpement.  A  gadget/menu
  library will follow, so you could create real applications with lot of
  speed and compactness. 

  May be some PPC specific libraries will come out too. I will buy a PPC
  card soon, so :).

  I  search for coder (ASM) which could help me to create new libraries.
  Say me if you're interressed..

      Fred.

@ENDNODE


@NODE AUTHO "Informations about the author"
    
  Contact me at : alphasnd@hol.fr

  or by snail mail at:

      Laboureur Frédéric
      15, rue du bosquet
      67640 FEGERSHEIM
      France

          Have fun !

  PS: We're world champioooooooons !!! GOOOOOAAAAL :)

@ENDNODE


@NODE HISTO "New Set Library history"

    @{b}History:@{ub}

  V1.10: Aminet release

  * Chunky library added (experimental)
  * String library added
  * Memory library added
  * Guide revised and updated


  V1.00: Blitz mailing list release

@ENDNODE
