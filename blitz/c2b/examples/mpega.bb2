
; C to Blitz conversion done by c2b.

;------------------------------------------------------------------------------
; 
; File    :   MPEGA.h
; 
; Author  :   Stéphane TAVENARD
; 
; $VER:   MPEGA.h  2.0  (21/06/1998)
; 
; (C) Copyright 1997-1998 Stéphane TAVENARD
; All Rights Reserved
; 
; #Rev|   Date   |                      Comment
; ----|----------|--------------------------------------------------------
; 0   |25/10/1997| Initial revision                                     ST
; 1   |21/06/1998| Added MPEGA_scale                                    ST
; 
; ------------------------------------------------------------------------
; 
; MPEGA decoder library definitions
; 
; ------------------------------------------------------------------------------

; #ifndef LIBRARIES_MPEGA_H 
; #LIBRARIES_MPEGA_H

#MPEGA_VERSION                 = 2 ; #1 

; #ifndef EXEC_TYPES_H 
; #include <exec/types.h> 
; #endif 

; #ifndef UTILITY_HOOKS_H 
; #include <utility/hooks.h> 
; #endif 

; Controls for decoding 

; Qualities 
#MPEGA_QUALITY_LOW             = 0 
#MPEGA_QUALITY_MEDIUM          = 1 
#MPEGA_QUALITY_HIGH            = 2 

;
; Bitstream Hook function is called like (SAS/C syntax):
; 
; 
; ULONG __saveds __asm HookFunc( register __a0 struct Hook  *hook,
; register __a2 APTR          handle,
;
; register __a1 MPEGA_ACCESS *access )

; 
; MPEGA_ACCESS struct specify bitstream access function & parameters
; 
; access->func == MPEGA_BSFUNC_OPEN
; open the bitstream
; access->data.open.buffer_size is the i/o block size your read function can use
; access->data.open.stream_size is the total size of the current stream
; (in bytes, set it to 0 if unknown)
; return your file handle (or NULL if failed)
; access->func == MPEGA_BSFUNC_CLOSE
; close the bitstream
; return 0 if ok
; access->func == MPEGA_BSFUNC_READ
; read bytes from bitstream.
; access->data.read.buffer is the destination buffer.
; access->data.read.num_bytes is the number of bytes requested for read.
; return # of bytes read or 0 if EOF.
; access->func == MPEGA_BSFUNC_SEEK
; seek into the bitstream
; access->data.seek.abs_byte_seek_pos is the absolute byte position to reach.
; return 0 if ok
; 

#MPEGA_BSFUNC_OPEN             = 0 
#MPEGA_BSFUNC_CLOSE            = 1 
#MPEGA_BSFUNC_READ             = 2 
#MPEGA_BSFUNC_SEEK             = 3 

NEWTYPE .struct_#? 

   func.l                                ; LONG    ; MPEGA_BSFUNC_xxx 
   NEWTYPE .union_#?1 
      NEWTYPE .struct_#?2 
         *stream_name.b                  ; CHAR    ; in 
         buffer_size.l                   ; LONG    ; in 
         stream_size.l                   ; LONG    ; out 
      End NEWTYPE  open  
      NEWTYPE .struct_#?2 
         *buffer.l                       ; VOID    ; in/out 
         num_bytes.l                     ; LONG    ; in 
      End NEWTYPE  read  
      NEWTYPE .struct_#?2 
         abs_byte_seek_pos.l             ; LONG    ; out 
      End NEWTYPE  seek  
   End NEWTYPE  data  

End NEWTYPE  MPEGA_ACCESS  

; Decoding output settings 

NEWTYPE .struct_#? 
   freq_div.w                            ; WORD    ; 1, 2 or 4 
   quality.w                             ; WORD    ; 0 (low) .. 2 (high) 
   freq_max.l                            ; LONG    ; for automatic freq_div (if mono_freq_div == 0) 
End NEWTYPE  MPEGA_OUTPUT  

; Decoding layer settings 
NEWTYPE .struct_#? 
   force_mono.w                          ; WORD    ; 1 to decode stereo stream in mono, 0 otherwise 
   mono.MPEGA_OUTPUT                     ; mono settings 
   stereo.MPEGA_OUTPUT                   ; stereo settings 
End NEWTYPE  MPEGA_LAYER  

; Full control structure of MPEG Audio decoding 
NEWTYPE .struct_#? 
   *bs_access.Hook                       ; STRUCT  ; NULL for default access (file I/O) or give your own bitstream access 
   layer_1_2.MPEGA_LAYER                 ; Layer I & II settings 
   layer_3.MPEGA_LAYER                   ; Layer III settings 
   check_mpeg.w                          ; WORD    ; 1 to check for mpeg audio validity at start of stream, 0 otherwise 
   stream_buffer_size.l                  ; LONG    ; size of bitstream buffer in bytes (0 -> default size) 
   ; NOTE: stream_buffer_size must be multiple of 4 bytes 
End NEWTYPE  MPEGA_CTRL  

; MPEG Audio modes 

#MPEGA_MODE_STEREO             = 0 
#MPEGA_MODE_J_STEREO           = 1 
#MPEGA_MODE_DUAL               = 2 
#MPEGA_MODE_MONO               = 3 

NEWTYPE .struct_#? 
   ; Public data (read only) 
   ; Stream info 
   norm.w                                ; WORD    ; 1 or 2 
   layer.w                               ; WORD    ; 1..3 
   mode.w                                ; WORD    ; 0..3  (MPEGA_MODE_xxx) 
   bitrate.w                             ; WORD    ; in kbps 
   frequency.l                           ; LONG    ; in Hz 
   channels.w                            ; WORD    ; 1 or 2 
   ms_duration.l                         ; ULONG   ; stream duration in ms 
   private_bit.w                         ; WORD    ; 0 or 1 
   copyright.w                           ; WORD    ; 0 or 1 
   original.w                            ; WORD    ; 0 or 1 
   ; Decoding info according to MPEG control 
   dec_channels.w                        ; WORD    ; decoded channels 1 or 2 
   dec_quality.w                         ; WORD    ; decoding quality 0..2 
   dec_frequency.l                       ; LONG    ; decoding frequency in Hz 

   ; Private data 
   *handle.l                             ; VOID    
End NEWTYPE  MPEGA_STREAM  

#MPEGA_MAX_CHANNELS            = 2 ; Max channels
#MPEGA_PCM_SIZE                = 1152 ; Max samples per frame

; Error codes 

#MPEGA_ERR_NONE                = 0 
#MPEGA_ERR_BASE                = 0 
#MPEGA_ERR_EOF                 = (#MPEGA_ERR_BASE-1) 
#MPEGA_ERR_BADFRAME            = (#MPEGA_ERR_BASE-2) 
#MPEGA_ERR_MEM                 = (#MPEGA_ERR_BASE-3) 
#MPEGA_ERR_NO_SYNC             = (#MPEGA_ERR_BASE-4) 
#MPEGA_ERR_BADVALUE            = (#MPEGA_ERR_BASE-5) ; #1 

; #endif ; LIBRARIES_MPEGA_H 
