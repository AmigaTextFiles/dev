
; C to Blitz conversion done by c2b.

;
; **      $VER: bzlib.h 1.0 (11.12.2003)
; **
; **      main include file for bzlib.library
; 

; #ifndef LIBRARIES_BZLIB_H 
; #LIBRARIES_BZLIB_H

; #ifndef EXEC_LIBRARIES_H 
; #include <exec/libraries.h> 
; #endif 

; #include <amiga-align.h> 

NEWTYPE .bzlibBase 

   bzb_LibNode.Library                   ; STRUCT  
   bzb_Unused.w                          ; UWORD   
End NEWTYPE   



;-------------------------------------------------------------
;--- Public header file for the library.                   ---
;---                                               bzlib.h ---
;-------------------------------------------------------------

;--
; This file is a part of bzip2 and/or libbzip2, a program and
; library for lossless, block-sorting data compression.
; 
; Copyright (C) 1996-2002 Julian R Seward.  All rights reserved.
; 
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions
; are met:
; 
; 1. Redistributions of source code must retain the above copyright
; notice, this list of conditions and the following disclaimer.
; 
;
; 2. The origin of this software must not be misrepresented
; you must

; not claim that you wrote the original software.  If you use this
; software in a product, an acknowledgment in the product
; documentation would be appreciated but is not required.
; 
; 3. Altered source versions must be plainly marked as such, and must
; not be misrepresented as being the original software.
; 
; 4. The name of the author may not be used to endorse or promote
; products derived from this software without specific prior written
; permission.
; 
; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
; OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
; ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
; DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
;
; GOODS OR SERVICES
; LOSS OF USE, DATA, OR PROFITS
; OR BUSINESS

; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
; WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
; 
; Julian Seward, Cambridge, UK.
; jseward@acm.org
; bzip2/libbzip2 version 1.0 of 21 March 2000
; 
; This program is based on (at least) the work of:
; Mike Burrows
; David Wheeler
; Peter Fenwick
; Alistair Moffat
; Radford Neal
; Ian H. Witten
; Robert Sedgewick
; Jon L. Bentley
; 
; For more information on these sources, see the manual.
; --


#BZ_RUN                        = 0 
#BZ_FLUSH                      = 1 
#BZ_FINISH                     = 2 

#BZ_OK                         = 0 
#BZ_RUN_OK                     = 1 
#BZ_FLUSH_OK                   = 2 
#BZ_FINISH_OK                  = 3 
#BZ_STREAM_END                 = 4 
#BZ_SEQUENCE_ERROR             = (-1) 
#BZ_PARAM_ERROR                = (-2) 
#BZ_MEM_ERROR                  = (-3) 
#BZ_DATA_ERROR                 = (-4) 
#BZ_DATA_ERROR_MAGIC           = (-5) 
#BZ_IO_ERROR                   = (-6) 
#BZ_UNEXPECTED_EOF             = (-7) 
#BZ_OUTBUFF_FULL               = (-8) 
#BZ_CONFIG_ERROR               = (-9) 

BZ_VERSION$                    = "1.0.2, 30-Dec-2001" 

DEFTYPE .b Char ; CHAR 
DEFTYPE .b Bool ; UCHAR 
DEFTYPE .b UChar ; UCHAR 
DEFTYPE .l Int32 ; INT 
DEFTYPE .l UInt32 ; UINT 
DEFTYPE .w Int16 ; SHORT 
DEFTYPE .w UInt16 ; USHORT 

#True                          = ((#Bool)1) 
#False                         = ((#Bool)0) 

typedef
NEWTYPE .{ 
   *next_in.b                            ; CHAR    
   avail_in.l                            ; UINT    
   total_in_lo32.l                       ; UINT    
   total_in_hi32.l                       ; UINT    

   *next_out.b                           ; CHAR    
   avail_out.l                           ; UINT    
   total_out_lo32.l                      ; UINT    
   total_out_hi32.l                      ; UINT    

   *state.l                              ; VOID    

   **bzallocvoid.l                       ; VOID    
   *int.l                                ; VOID    
   *int.l                                ; VOID    

   *bzfreevoid.l                         ; VOID    
   *void.l                               ; VOID    

   *opaque.l                             ; VOID    
End NEWTYPE  
bz_stream



;-- Header bytes. --

#BZ_HDR_B                      = $42 ; 'B' 
#BZ_HDR_Z                      = $5a ; 'Z' 
#BZ_HDR_h                      = $68 ; 'h' 
#BZ_HDR_0                      = $30 ; '0' 

;-- Constants for the back end. --

#BZ_MAX_ALPHA_SIZE             = 258 
#BZ_MAX_CODE_LEN               = 23 

#BZ_RUNA                       = 0 
#BZ_RUNB                       = 1 

#BZ_N_GROUPS                   = 6 
#BZ_G_SIZE                     = 50 
#BZ_N_ITERS                    = 4 

#BZ_MAX_SELECTORS              = (2 + (900000 / #BZ_G_SIZE)) 


;-- States and modes for compression. --

#BZ_M_IDLE                     = 1 
#BZ_M_RUNNING                  = 2 
#BZ_M_FLUSHING                 = 3 
#BZ_M_FINISHING                = 4 

#BZ_S_OUTPUT                   = 1 
#BZ_S_INPUT                    = 2 

#BZ_N_RADIX                    = 2 
#BZ_N_QSORT                    = 12 
#BZ_N_SHELL                    = 18 
#BZ_N_OVERSHOOT                = (#BZ_N_RADIX + #BZ_N_QSORT + #BZ_N_SHELL + 2) 

#BZ_RAND_DECLS                 = #\ 
DEFTYPE .l rNToGo, \ ; INT32 
DEFTYPE .l rTPos, \ ; INT32 

;-- Structure holding all the compression-side stuff. --

typedef
NEWTYPE .{ 
   ; pointer back to the struct bz_stream 
   *strm.bz_stream                       

   ; mode this stream is in, and whether inputting 
   ; or outputting data 
   mode.l                                ; INT32   
   state.l                               ; INT32   

   ; remembers avail_in when flush/finish requested 
   avail_in_expect.l                     ; UINT32  

   ; for doing the block sorting 
   *arr1.l                               ; UINT32  
   *arr2.l                               ; UINT32  
   *ftab.l                               ; UINT32  
   origPtr.l                             ; INT32   

   ; aliases for arr1 and arr2 
   *ptr.l                                ; UINT32  
   *block.b                              ; UCHAR   
   *mtfv.w                               ; UINT16  
   *zbits.b                              ; UCHAR   

   ; for deciding when to use the fallback sorting algorithm 
   workFactor.l                          ; INT32   

   ; run-length-encoding of the input 
   state_in_ch.l                         ; UINT32  
   state_in_len.l                        ; INT32   
   BZ_RAND_DECLS 

   ; input and output limits and current posns 
   nblock.l                              ; INT32   
   nblockMAX.l                           ; INT32   
   numZ.l                                ; INT32   
   state_out_pos.l                       ; INT32   

   ; map of bytes used in block 
   nInUse.l                              ; INT32   
   *inUse.w[256]                         ; BOOL    
   unseqToSeq.b[256]                     ; UCHAR   

   ; the buffer for bit stream creation 
   bsBuff.l                              ; UINT32  
   bsLive.l                              ; INT32   

   ; block and combined CRCs 
   blockCRC.l                            ; UINT32  
   combinedCRC.l                         ; UINT32  

   ; misc administratium 
   verbosity.l                           ; INT32   
   blockNo.l                             ; INT32   
   blockSize100k.l                       ; INT32   

   ; stuff for coding the MTF values 
   nMTF.l                                ; INT32   
   mtfFreq.l[#BZ_MAX_ALPHA_SIZE]         ; INT32   
   selector.b[#BZ_MAX_SELECTORS]         ; UCHAR   
   selectorMtf.b[#BZ_MAX_SELECTORS]      ; UCHAR   

   len.b[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; UCHAR   
   code.l[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; INT32   
   rfreq.l[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; INT32   
   ; second dimension: only 3 needed 4 makes index calculations faster 
   len_pack.l[#BZ_MAX_ALPHA_SIZE][4]     ; UINT32  

End NEWTYPE  
EState





;-- states for decompression. --

#BZ_X_IDLE                     = 1 
#BZ_X_OUTPUT                   = 2 

#BZ_X_MAGIC_1                  = 10 
#BZ_X_MAGIC_2                  = 11 
#BZ_X_MAGIC_3                  = 12 
#BZ_X_MAGIC_4                  = 13 
#BZ_X_BLKHDR_1                 = 14 
#BZ_X_BLKHDR_2                 = 15 
#BZ_X_BLKHDR_3                 = 16 
#BZ_X_BLKHDR_4                 = 17 
#BZ_X_BLKHDR_5                 = 18 
#BZ_X_BLKHDR_6                 = 19 
#BZ_X_BCRC_1                   = 20 
#BZ_X_BCRC_2                   = 21 
#BZ_X_BCRC_3                   = 22 
#BZ_X_BCRC_4                   = 23 
#BZ_X_RANDBIT                  = 24 
#BZ_X_ORIGPTR_1                = 25 
#BZ_X_ORIGPTR_2                = 26 
#BZ_X_ORIGPTR_3                = 27 
#BZ_X_MAPPING_1                = 28 
#BZ_X_MAPPING_2                = 29 
#BZ_X_SELECTOR_1               = 30 
#BZ_X_SELECTOR_2               = 31 
#BZ_X_SELECTOR_3               = 32 
#BZ_X_CODING_1                 = 33 
#BZ_X_CODING_2                 = 34 
#BZ_X_CODING_3                 = 35 
#BZ_X_MTF_1                    = 36 
#BZ_X_MTF_2                    = 37 
#BZ_X_MTF_3                    = 38 
#BZ_X_MTF_4                    = 39 
#BZ_X_MTF_5                    = 40 
#BZ_X_MTF_6                    = 41 
#BZ_X_ENDHDR_2                 = 42 
#BZ_X_ENDHDR_3                 = 43 
#BZ_X_ENDHDR_4                 = 44 
#BZ_X_ENDHDR_5                 = 45 
#BZ_X_ENDHDR_6                 = 46 
#BZ_X_CCRC_1                   = 47 
#BZ_X_CCRC_2                   = 48 
#BZ_X_CCRC_3                   = 49 
#BZ_X_CCRC_4                   = 50 



;-- Constants for the fast MTF decoder. --

#MTFA_SIZE                     = 4096 
#MTFL_SIZE                     = 16 



;-- Structure holding all the decompression-side stuff. --

typedef
NEWTYPE .{ 
   ; pointer back to the struct bz_stream 
   *strm.bz_stream                       

   ; state indicator for this stream 
   state.l                               ; INT32   

   ; for doing the final run-length decoding 
   state_out_ch.b                        ; UCHAR   
   state_out_len.l                       ; INT32   
   *blockRandomised.w                    ; BOOL    
   BZ_RAND_DECLS 

   ; the buffer for bit stream reading 
   bsBuff.l                              ; UINT32  
   bsLive.l                              ; INT32   

   ; misc administratium 
   blockSize100k.l                       ; INT32   
   *smallDecompress.w                    ; BOOL    
   currBlockNo.l                         ; INT32   
   verbosity.l                           ; INT32   

   ; for undoing the Burrows-Wheeler transform 
   origPtr.l                             ; INT32   
   tPos.l                                ; UINT32  
   k0.l                                  ; INT32   
   unzftab.l[256]                        ; INT32   
   nblock_used.l                         ; INT32   
   cftab.l[257]                          ; INT32   
   cftabCopy.l[257]                      ; INT32   

   ; for undoing the Burrows-Wheeler transform (FAST) 
   *tt.l                                 ; UINT32  

   ; for undoing the Burrows-Wheeler transform (SMALL) 
   *ll16.w                               ; UINT16  
   *ll4.b                                ; UCHAR   

   ; stored and calculated CRCs 
   storedBlockCRC.l                      ; UINT32  
   storedCombinedCRC.l                   ; UINT32  
   calculatedBlockCRC.l                  ; UINT32  
   calculatedCombinedCRC.l               ; UINT32  

   ; map of bytes used in block 
   nInUse.l                              ; INT32   
   *inUse.w[256]                         ; BOOL    
   *inUse16.w[16]                        ; BOOL    
   seqToUnseq.b[256]                     ; UCHAR   

   ; for decoding the MTF values 
   mtfa.b[#MTFA_SIZE]                    ; UCHAR   
   mtfbase.l[256/#MTFL_SIZE]             ; INT32   
   selector.b[#BZ_MAX_SELECTORS]         ; UCHAR   
   selectorMtf.b[#BZ_MAX_SELECTORS]      ; UCHAR   
   len.b[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; UCHAR   

   limit.l[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; INT32   
   base.l[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; INT32   
   perm.l[#BZ_N_GROUPS][#BZ_MAX_ALPHA_SIZE] ; INT32   
   minLens.l[#BZ_N_GROUPS]               ; INT32   

   ; save area for scalars in the main decompress code 
   save_i.l                              ; INT32   
   save_j.l                              ; INT32   
   save_t.l                              ; INT32   
   save_alphaSize.l                      ; INT32   
   save_nGroups.l                        ; INT32   
   save_nSelectors.l                     ; INT32   
   save_EOB.l                            ; INT32   
   save_groupNo.l                        ; INT32   
   save_groupPos.l                       ; INT32   
   save_nextSym.l                        ; INT32   
   save_nblockMAX.l                      ; INT32   
   save_nblock.l                         ; INT32   
   save_es.l                             ; INT32   
   save_N.l                              ; INT32   
   save_curr.l                           ; INT32   
   save_zt.l                             ; INT32   
   save_zn.l                             ; INT32   
   save_zvec.l                           ; INT32   
   save_zj.l                             ; INT32   
   save_gSel.l                           ; INT32   
   save_gMinlen.l                        ; INT32   
   *save_gLimit.l                        ; INT32   
   *save_gBase.l                         ; INT32   
   *save_gPerm.l                         ; INT32   

End NEWTYPE  
DState


; #include <default-align.h> 

; #endif ; LIBRARIES_BZLIB_H 
