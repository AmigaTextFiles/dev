
; C to Blitz conversion done by c2b.

;
; **      $VER: avilib.h 1.0 (12.12.2003)
; **
; **      main include file for avilib.library
; 

; #ifndef LIBRARIES_AVILIB_H 
; #LIBRARIES_AVILIB_H

; #ifndef EXEC_LIBRARIES_H 
; #include <exec/libraries.h> 
; #endif 

NEWTYPE .AvilibBase 
   LibNode.Library                       ; STRUCT  
End NEWTYPE   

; #include <sys/types.h> 
; #include <sys/stat.h> 
; #include <stdio.h> 
; #include <fcntl.h> 
; #include <unistd.h> 
; #include <inttypes.h> 
; #include <limits.h> 
; #include <stdlib.h> 
; #include <string.h> 
; #include <errno.h> 


#AVI_MAX_TRACKS                = 8 

NEWTYPE .struct_#? 

   key.l                                 ; OFF_T   
   pos.l                                 ; OFF_T   
   len.l                                 ; OFF_T   
End NEWTYPE  video_index_entry  

NEWTYPE .struct_#? 

   pos.l                                 ; OFF_T   
   len.l                                 ; OFF_T   
   tot.l                                 ; OFF_T   
End NEWTYPE  audio_index_entry  


; Index types


#AVI_INDEX_OF_INDEXES          = $00 ; when each entry in aIndex
; array points to an index chunk
#AVI_INDEX_OF_CHUNKS           = $01 ; when each entry in aIndex
; array points to a chunk in the file
#AVI_INDEX_IS_DATA             = $80 ; when each entry is aIndex is
; really the data
; bIndexSubtype codes for INDEX_OF_CHUNKS
;
#AVI_INDEX_2FIELD              = $01 ; when fields within frames
; are also indexed



NEWTYPE ._avisuperindex_entry 
   qwOffset.d                            ; UINT64  ; absolute file offset
   dwSize.l                              ; ULONG   ; size of index chunk at this offset
   dwDuration.l                          ; ULONG   ; time span in stream ticks
End NEWTYPE  avisuperindex_entry  

NEWTYPE ._avistdindex_entry 
   dwOffset.l                            ; ULONG   ; qwBaseOffset + this is absolute file offset
   dwSize.l                              ; ULONG   ; bit 31 is set if this is NOT a keyframe
End NEWTYPE  avistdindex_entry  


; Base Index Form 'indx'
NEWTYPE ._avisuperindex_chunk 
   fcc.b[4]                              ; CHAR    
   dwSize.l                              ; ULONG   ; size of this chunk
   wLongsPerEntry.w                      ; USHORT  ; size of each entry in aIndex array (must be 8 for us)
   bIndexSubType.b                       ; UCHAR   ; future use. must be 0
   bIndexType.b                          ; UCHAR   ; one of AVI_INDEX_* codes
   nEntriesInUse.l                       ; ULONG   ; index of first unused member in aIndex array
   dwChunkId.b[4]                        ; CHAR    ; fcc of what is indexed
   dwReserved.l[3]                       ; ULONG   ; meaning differs for each index type/subtype.
   ; 0 if unused
   *aIndex.avisuperindex_entry           
End NEWTYPE  avisuperindex_chunk  

; Standard index
NEWTYPE ._avistdindex_chunk 
   fcc.b[4]                              ; CHAR    ; ix##
   dwSize.l                              ; ULONG   ; size of this chunk
   wLongsPerEntry.w                      ; USHORT  ; must be sizeof(aIndex[0])/sizeof(DWORD)
   bIndexSubType.b                       ; UCHAR   ; must be 0
   bIndexType.b                          ; UCHAR   ; must be AVI_INDEX_OF_CHUNKS
   nEntriesInUse.l                       ; ULONG   ;
   dwChunkId.b[4]                        ; CHAR    ; '##dc' or '##db' or '##wb' etc..
   qwBaseOffset.d                        ; UINT64  ; all dwOffsets in aIndex array are relative to this
   dwReserved3.l                         ; ULONG   ; must be 0
   *aIndex.avistdindex_entry             
End NEWTYPE  avistdindex_chunk  




NEWTYPE .track_s 



   a_fmt.l                               ; LONG    ; Audio format, see #defines below 
   a_chans.l                             ; LONG    ; Audio channels, 0 for no audio 
   a_rate.l                              ; LONG    ; Rate in Hz 
   a_bits.l                              ; LONG    ; bits per audio sample 
   mp3rate.l                             ; LONG    ; mp3 bitrate kbs
   a_vbr.l                               ; LONG    ; 0 == no Variable BitRate 

   audio_strn.l                          ; LONG    ; Audio stream number 
   audio_bytes.l                         ; OFF_T   ; Total number of bytes of audio data 
   audio_chunks.l                        ; LONG    ; Chunks of audio data in the file 

   audio_tag.b[4]                        ; CHAR    ; Tag of audio data 
   audio_posc.l                          ; LONG    ; Audio position: chunk 
   audio_posb.l                          ; LONG    ; Audio position: byte within chunk 

   a_codech_off.l                        ; OFF_T   ; absolut offset of audio codec information 
   a_codecf_off.l                        ; OFF_T   ; absolut offset of audio codec information 

   *audio_index.audio_index_entry        
   *audio_superindex.avisuperindex_chunk 

End NEWTYPE  track_t  

NEWTYPE .struct_#? 


   fdes.l                                ; LONG    ; File descriptor of AVI file 
   mode.l                                ; LONG    ; 0 for reading, 1 for writing 

   width.l                               ; LONG    ; Width  of a video frame 
   height.l                              ; LONG    ; Height of a video frame 
   fps.d                                 ; DOUBLE  ; Frames per second 
   compressor.b[8]                       ; CHAR    ; Type of compressor, 4 bytes + padding for 0 byte 
   compressor2.b[8]                      ; CHAR    ; Type of compressor, 4 bytes + padding for 0 byte 
   video_strn.l                          ; LONG    ; Video stream number 
   video_frames.l                        ; LONG    ; Number of video frames 
   video_tag.b[4]                        ; CHAR    ; Tag of video data 
   video_pos.l                           ; LONG    ; Number of next frame to be read
   ; (if index present) 

   max_len.l                             ; ULONG   ; maximum video chunk present 

   track.track_t[#AVI_MAX_TRACKS]        ; up to AVI_MAX_TRACKS audio tracks supported

   pos.l                                 ; OFF_T   ; position in file 
   n_idx.l                               ; LONG    ; number of index entries actually filled 
   max_idx.l                             ; LONG    ; number of index entries actually allocated 

   v_codech_off.l                        ; OFF_T   ; absolut offset of video codec (strh) info 
   v_codecf_off.l                        ; OFF_T   ; absolut offset of video codec (strf) info 

   *idx.b[16]                            ; UCHAR   ; index entries (AVI idx1 tag) 

   *video_index.video_index_entry        
   *video_superindex.avisuperindex_chunk ; index of indices 
   is_opendml.l                          ; INT     ; set to 1 if this is an odml file with multiple index chunks 

   last_pos.l                            ; OFF_T   ; Position of last frame written 
   last_len.l                            ; ULONG   ; Length of last frame written 
   must_use_index.l                      ; INT     ; Flag if frames are duplicated 
   movi_start.l                          ; OFF_T   

   anum.l                                ; INT     ; total number of audio tracks
   aptr.l                                ; INT     ; current audio working track
   comment_fd.l                          ; INT     ; Read avi header comments from this fd
   *index_file.b                         ; CHAR    ; read the avi index from this file

End NEWTYPE  avi_t  

#AVI_MODE_WRITE                = 0 
#AVI_MODE_READ                 = 1 

; The error codes delivered by avi_open_input_file 

#AVI_ERR_SIZELIM               = 1 ; The write of the data would exceed
; the maximum size of the AVI file.
; This is more a warning than an error
; since the file may be closed safely 

#AVI_ERR_OPEN                  = 2 ; Error opening the AVI file - wrong path
; name or file nor readable/writable 

#AVI_ERR_READ                  = 3 ; Error reading from AVI File 

#AVI_ERR_WRITE                 = 4 ; Error writing to AVI File,
; disk full ??? 

#AVI_ERR_WRITE_INDEX           = 5 ; Could not write index to AVI file
; during close, file may still be
; usable 

#AVI_ERR_CLOSE                 = 6 ; Could not write header to AVI file
; or not truncate the file during close,
; file is most probably corrupted 

#AVI_ERR_NOT_PERM              = 7 ; Operation not permitted:
; trying to read from a file open
; for writing or vice versa 

#AVI_ERR_NO_MEM                = 8 ; malloc failed 

#AVI_ERR_NO_AVI                = 9 ; Not an AVI file 

#AVI_ERR_NO_HDRL               = 10 ; AVI file has no has no header list,
; corrupted ??? 

#AVI_ERR_NO_MOVI               = 11 ; AVI file has no has no MOVI list,
; corrupted ??? 

#AVI_ERR_NO_VIDS               = 12 ; AVI file contains no video data 

#AVI_ERR_NO_IDX                = 13 ; The file has been opened with
; getIndex==0, but an operation has been
; performed that needs an index 

; Possible Audio formats 

; #ifndef WAVE_FORMAT_PCM 
#WAVE_FORMAT_UNKNOWN           = ($0000) 
#WAVE_FORMAT_PCM               = ($0001) 
#WAVE_FORMAT_ADPCM             = ($0002) 
#WAVE_FORMAT_IBM_CVSD          = ($0005) 
#WAVE_FORMAT_ALAW              = ($0006) 
#WAVE_FORMAT_MULAW             = ($0007) 
#WAVE_FORMAT_OKI_ADPCM         = ($0010) 
#WAVE_FORMAT_DVI_ADPCM         = ($0011) 
#WAVE_FORMAT_DIGISTD           = ($0015) 
#WAVE_FORMAT_DIGIFIX           = ($0016) 
#WAVE_FORMAT_YAMAHA_ADPCM      = ($0020) 
#WAVE_FORMAT_DSP_TRUESPEECH    = ($0022) 
#WAVE_FORMAT_GSM610            = ($0031) 
#IBM_FORMAT_MULAW              = ($0101) 
#IBM_FORMAT_ALAW               = ($0102) 
#IBM_FORMAT_ADPCM              = ($0103) 
; #endif 

NEWTYPE .riff_struct 

   id.b[4]                               ; UCHAR   ; RIFF 
   len.l                                 ; ULONG   
   wave_id.b[4]                          ; UCHAR   ; WAVE 
End NEWTYPE   


NEWTYPE .chunk_struct 

   id.b[4]                               ; UCHAR   
   len.l                                 ; ULONG   
End NEWTYPE   

NEWTYPE .common_struct 

   wFormatTag.w                          ; USHORT  
   wChannels.w                           ; USHORT  
   dwSamplesPerSec.l                     ; ULONG   
   dwAvgBytesPerSec.l                    ; ULONG   
   wBlockAlign.w                         ; USHORT  
   wBitsPerSample.w                      ; USHORT  ; Only for PCM 
End NEWTYPE   

NEWTYPE .wave_header 

   riff.riff_struct                      ; STRUCT  
   format.chunk_struct                   ; STRUCT  
   common.common_struct                  ; STRUCT  
   data.chunk_struct                     ; STRUCT  
End NEWTYPE   

NEWTYPE .AVIStreamHeader 
   fccType.l                             ; LONG    
   fccHandler.l                          ; LONG    
   dwFlags.l                             ; LONG    
   dwPriority.l                          ; LONG    
   dwInitialFrames.l                     ; LONG    
   dwScale.l                             ; LONG    
   dwRate.l                              ; LONG    
   dwStart.l                             ; LONG    
   dwLength.l                            ; LONG    
   dwSuggestedBufferSize.l               ; LONG    
   dwQuality.l                           ; LONG    
   dwSampleSize.l                        ; LONG    
End NEWTYPE   

; #endif ; LIBRARIES_AVILIB_H 
