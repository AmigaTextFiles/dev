
; C to Blitz conversion done by c2b.

; #ifndef DEVICES_AHI_H 
; #DEVICES_AHI_H

;
; ** $VER: ahi.h 6.0 (02.02.2005)
; **
; ** ahi.device definitions
; **
; ** (C) Copyright 1994-2005 Martin Blom
; ** All Rights Reserved.
; **
; ** (TAB SIZE: 8)
; 

;***************************************************************************

; #ifndef EXEC_TYPES_H 
; #include <exec/types.h> 
; #endif 

; #ifndef EXEC_IO_H 
; #include <exec/io.h> 
; #endif 

; #ifndef UTILITY_TAGITEM_H 
; #include <utility/tagitem.h> 
; #endif 

; #ifndef LIBRARIES_IFFPARSE_H 
; #include <libraries/iffparse.h> 
; #endif 

;***************************************************************************

; #ifndef EIGHTSVX_H ; Do not define Fixed twice 

DEFTYPE .l Fixed ; LONG ; A fixed-point value, 16 bits
; to the left of the point and
; 16 bits to the right 
; #endif 
typedef Fixed sposition

;** STRUCTURES 

; AHIAudioCtrl 
NEWTYPE .AHIAudioCtrl 

   *ahiac_UserData.l                     ; APTR    
   ; Lots of private data follows! 
End NEWTYPE   

; AHISoundMessage 
NEWTYPE .AHISoundMessage 

   ahism_Channel.w                       ; UWORD   
End NEWTYPE   

; AHIRecordMessage 
NEWTYPE .AHIRecordMessage 

   ahirm_Type.l                          ; ULONG   ; Format of buffer (object) 
   *ahirm_Buffer.l                       ; APTR    ; Pointer to the sample array 
   ahirm_Length.l                        ; ULONG   ; Number of sample frames in buffer 
End NEWTYPE   

; AHISampleInfo 
NEWTYPE .AHISampleInfo 

   ahisi_Type.l                          ; ULONG   ; Format of samples 
   *ahisi_Address.l                      ; APTR    ; Address to array of samples 
   ahisi_Length.l                        ; ULONG   ; Number of samples in array 
End NEWTYPE   


; AHIAudioModeRequester 
NEWTYPE .AHIAudioModeRequester 

   ahiam_AudioID.l                       ; ULONG   ; Selected audio mode 
   ahiam_MixFreq.l                       ; ULONG   ; Selected mixing/sampling frequency 

   ahiam_LeftEdge.w                      ; WORD    ; Coordinates of requester on exit 
   ahiam_TopEdge.w                       ; WORD    
   ahiam_Width.w                         ; WORD    
   ahiam_Height.w                        ; WORD    

   *ahiam_InfoOpened.w                   ; BOOL    ; Info window opened on exit? 
   ahiam_InfoLeftEdge.w                  ; WORD    ; Last coordinates of Info window 
   ahiam_InfoTopEdge.w                   ; WORD    
   ahiam_InfoWidth.w                     ; WORD    
   ahiam_InfoHeight.w                    ; WORD    

   ahiam_ObsoleteUserData.w[2]           ; UWORD   
   ahiam_Pad.w                           ; UWORD   
   *ahiam_UserData.l                     ; APTR    ; You can store your own data here (V6) 
   ; Lots of private data follows! 
End NEWTYPE   

; AHIEffMasterVolume 
NEWTYPE .AHIEffMasterVolume 

   ahie_Effect.l                         ; ULONG   ; Set to AHIET_MASTERVOLUME 
   ahiemv_Volume.Fixed                   ; See autodocs for range! 
End NEWTYPE   

; AHIEffOutputBuffer 
NEWTYPE .AHIEffOutputBuffer 

   ahie_Effect.l                         ; ULONG   ; Set to AHIET_OUTPUTBUFFER 
   *ahieob_Func.Hook                     ; STRUCT  
   ; These fields are filled by AHI 
   ahieob_Type.l                         ; ULONG   ; Format of buffer 
   *ahieob_Buffer.l                      ; APTR    ; Pointer to the sample array 
   ahieob_Length.l                       ; ULONG   ; Number of sample frames in buffer 
End NEWTYPE   

; AHIEffDSPMask (V4) 
NEWTYPE .AHIEffDSPMask 

   ahie_Effect.l                         ; ULONG   ; Set to AHIET_DSPMASK 
   ahiedm_Channels.w                     ; UWORD   ; Number of elements in array 
   ahiedm_Mask.b[0]                      ; UBYTE   ; Here follows the array 
End NEWTYPE   

#AHIEDM_WET                    = (0) 
#AHIEDM_DRY                    = (1) 

; AHIEffDSPEcho (V4) 
NEWTYPE .AHIEffDSPEcho 

   ahie_Effect.l                         ; ULONG   ; Set to AHIET_DSPECHO 
   ahiede_Delay.l                        ; ULONG   ; In samples 
   ahiede_Feedback.Fixed                 
   ahiede_Mix.Fixed                      
   ahiede_Cross.Fixed                    
End NEWTYPE   

#AHIDSPEcho                    = #AHIEffDSPEcho ; Fix for error in V4 includes 

; AHIEffChannelInfo (V4) 

NEWTYPE .AHIEffChannelInfo 

   ahie_Effect.l                         ; ULONG   ; Set to AHIET_CHANNELINFO 
   *ahieci_Func.Hook                     ; STRUCT  
   ahieci_Channels.w                     ; UWORD   
   ahieci_Pad.w                          ; UWORD   
   ; The rest is filled by AHI 
   ahieci_Offset.l[0]                    ; ULONG   ; The array follows 
End NEWTYPE   

;** TAGS 

#AHI_TagBase                   = (#TAG_USER) 
#AHI_TagBaseR                  = (#AHI_TagBase|$8000) 

; AHI_AllocAudioA tags 
#AHIA_AudioID                  = (#AHI_TagBase+1) ; Desired audio mode 
#AHIA_MixFreq                  = (#AHI_TagBase+2) ; Suggested mixing frequency 
#AHIA_Channels                 = (#AHI_TagBase+3) ; Suggested number of channels 
#AHIA_Sounds                   = (#AHI_TagBase+4) ; Number of sounds to use 
#AHIA_SoundFunc                = (#AHI_TagBase+5) ; End-of-Sound Hook 
#AHIA_PlayerFunc               = (#AHI_TagBase+6) ; Player Hook 
#AHIA_PlayerFreq               = (#AHI_TagBase+7) ; Frequency for player Hook (Fixed)
#AHIA_MinPlayerFreq            = (#AHI_TagBase+8) ; Minimum Frequency for player Hook 
#AHIA_MaxPlayerFreq            = (#AHI_TagBase+9) ; Maximum Frequency for player Hook 
#AHIA_RecordFunc               = (#AHI_TagBase+10) ; Sample recording Hook 
#AHIA_UserData                 = (#AHI_TagBase+11) ; What to put in ahiac_UserData 
#AHIA_AntiClickSamples         = (#AHI_TagBase+13) ; # of samples to smooth (V6) 

; AHI_PlayA tags (V4) 
#AHIP_BeginChannel             = (#AHI_TagBase+40) ; All command tags should be... 
#AHIP_EndChannel               = (#AHI_TagBase+41) ; ... enclosed by these tags. 
#AHIP_Freq                     = (#AHI_TagBase+50) 
#AHIP_Vol                      = (#AHI_TagBase+51) 
#AHIP_Pan                      = (#AHI_TagBase+52) 
#AHIP_Sound                    = (#AHI_TagBase+53) 
#AHIP_Offset                   = (#AHI_TagBase+54) 
#AHIP_Length                   = (#AHI_TagBase+55) 
#AHIP_LoopFreq                 = (#AHI_TagBase+60) 
#AHIP_LoopVol                  = (#AHI_TagBase+61) 
#AHIP_LoopPan                  = (#AHI_TagBase+62) 
#AHIP_LoopSound                = (#AHI_TagBase+63) 
#AHIP_LoopOffset               = (#AHI_TagBase+64) 
#AHIP_LoopLength               = (#AHI_TagBase+65) 

; AHI_ControlAudioA tags 
#AHIC_Play                     = (#AHI_TagBase+80) ; Boolean 
#AHIC_Record                   = (#AHI_TagBase+81) ; Boolean 
#AHIC_MonitorVolume            = (#AHI_TagBase+82) 
#AHIC_MonitorVolume_Query      = (#AHI_TagBase+83) ; ti_Data is pointer to Fixed (LONG) 
#AHIC_MixFreq_Query            = (#AHI_TagBase+84) ; ti_Data is pointer to ULONG 
; --- New for V2, they will be ignored by V1 --- 
#AHIC_InputGain                = (#AHI_TagBase+85) 
#AHIC_InputGain_Query          = (#AHI_TagBase+86) ; ti_Data is pointer to Fixed (LONG) 
#AHIC_OutputVolume             = (#AHI_TagBase+87) 
#AHIC_OutputVolume_Query       = (#AHI_TagBase+88) ; ti_Data is pointer to Fixed (LONG) 
#AHIC_Input                    = (#AHI_TagBase+89) 
#AHIC_Input_Query              = (#AHI_TagBase+90) ; ti_Data is pointer to ULONG 
#AHIC_Output                   = (#AHI_TagBase+91) 
#AHIC_Output_Query             = (#AHI_TagBase+92) ; ti_Data is pointer to ULONG 

; AHI_GetAudioAttrsA tags 
#AHIDB_AudioID                 = (#AHI_TagBase+100) 
#AHIDB_Driver                  = (#AHI_TagBaseR+101) ; Pointer to name of driver 
#AHIDB_Flags                   = (#AHI_TagBase+102) ; Private! 
#AHIDB_Volume                  = (#AHI_TagBase+103) ; Boolean 
#AHIDB_Panning                 = (#AHI_TagBase+104) ; Boolean 
#AHIDB_Stereo                  = (#AHI_TagBase+105) ; Boolean 
#AHIDB_HiFi                    = (#AHI_TagBase+106) ; Boolean 
#AHIDB_PingPong                = (#AHI_TagBase+107) ; Boolean 
#AHIDB_MultTable               = (#AHI_TagBase+108) ; Private! 
#AHIDB_Name                    = (#AHI_TagBaseR+109) ; Pointer to name of this mode 
#AHIDB_Bits                    = (#AHI_TagBase+110) ; Output bits 
#AHIDB_MaxChannels             = (#AHI_TagBase+111) ; Max supported channels 
#AHIDB_MinMixFreq              = (#AHI_TagBase+112) ; Min mixing freq. supported 
#AHIDB_MaxMixFreq              = (#AHI_TagBase+113) ; Max mixing freq. supported 
#AHIDB_Record                  = (#AHI_TagBase+114) ; Boolean 
#AHIDB_Frequencies             = (#AHI_TagBase+115) 
#AHIDB_FrequencyArg            = (#AHI_TagBase+116) ; ti_Data is frequency index 
#AHIDB_Frequency               = (#AHI_TagBase+117) 
#AHIDB_Author                  = (#AHI_TagBase+118) ; Pointer to driver author name 
#AHIDB_Copyright               = (#AHI_TagBase+119) ; Pointer to driver copyright notice 
#AHIDB_Version                 = (#AHI_TagBase+120) ; Pointer to driver version string 
#AHIDB_Annotation              = (#AHI_TagBase+121) ; Pointer to driver annotation text 
#AHIDB_BufferLen               = (#AHI_TagBase+122) ; Specifies the string buffer size 
#AHIDB_IndexArg                = (#AHI_TagBase+123) ; ti_Data is frequency! 
#AHIDB_Index                   = (#AHI_TagBase+124) 
#AHIDB_Realtime                = (#AHI_TagBase+125) ; Boolean 
#AHIDB_MaxPlaySamples          = (#AHI_TagBase+126) ; It's sample *frames* 
#AHIDB_MaxRecordSamples        = (#AHI_TagBase+127) ; It's sample *frames* 
#AHIDB_FullDuplex              = (#AHI_TagBase+129) ; Boolean 
; --- New for V2, they will be ignored by V1 --- 
#AHIDB_MinMonitorVolume        = (#AHI_TagBase+130) 
#AHIDB_MaxMonitorVolume        = (#AHI_TagBase+131) 
#AHIDB_MinInputGain            = (#AHI_TagBase+132) 
#AHIDB_MaxInputGain            = (#AHI_TagBase+133) 
#AHIDB_MinOutputVolume         = (#AHI_TagBase+134) 
#AHIDB_MaxOutputVolume         = (#AHI_TagBase+135) 
#AHIDB_Inputs                  = (#AHI_TagBase+136) 
#AHIDB_InputArg                = (#AHI_TagBase+137) ; ti_Data is input index 
#AHIDB_Input                   = (#AHI_TagBase+138) 
#AHIDB_Outputs                 = (#AHI_TagBase+139) 
#AHIDB_OutputArg               = (#AHI_TagBase+140) ; ti_Data is input index 
#AHIDB_Output                  = (#AHI_TagBase+141) 
; --- New for V4, they will be ignored by V2 and earlier --- 
#AHIDB_Data                    = (#AHI_TagBaseR+142) ; Private! 
#AHIDB_DriverBaseName          = (#AHI_TagBaseR+143) ; Private! 
; --- New for V6, they will be ignored by V4 and earlier --- 
#AHIDB_MultiChannel            = (#AHI_TagBase+144) ; Boolean 

; AHI_BestAudioIDA tags 
; --- New for V4, they will be ignored by V2 and earlier --- 
#AHIB_Dizzy                    = (#AHI_TagBase+190) 

; AHI_AudioRequestA tags 
; Window control 
#AHIR_Window                   = (#AHI_TagBase+200) ; Parent window 
#AHIR_Screen                   = (#AHI_TagBase+201) ; Screen to open on if no window 
#AHIR_PubScreenName            = (#AHI_TagBase+202) ; Name of public screen 
#AHIR_PrivateIDCMP             = (#AHI_TagBase+203) ; Allocate private IDCMP? 
#AHIR_IntuiMsgFunc             = (#AHI_TagBase+204) ; Function to handle IntuiMessages 
#AHIR_SleepWindow              = (#AHI_TagBase+205) ; Block input in AHIR_Window? 
#AHIR_ObsoleteUserData         = (#AHI_TagBase+206) ; V4 UserData 
#AHIR_UserData                 = (#AHI_TagBase+207) ; What to put in ahiam_UserData (V6) 
; Text display 
#AHIR_TextAttr                 = (#AHI_TagBase+220) ; Text font to use for gadget text 
#AHIR_Locale                   = (#AHI_TagBase+221) ; Locale to use for text 
#AHIR_TitleText                = (#AHI_TagBase+222) ; Title of requester 
#AHIR_PositiveText             = (#AHI_TagBase+223) ; Positive gadget text 
#AHIR_NegativeText             = (#AHI_TagBase+224) ; Negative gadget text 
; Initial settings 
#AHIR_InitialLeftEdge          = (#AHI_TagBase+240) ; Initial requester coordinates 
#AHIR_InitialTopEdge           = (#AHI_TagBase+241) 
#AHIR_InitialWidth             = (#AHI_TagBase+242) ; Initial requester dimensions 
#AHIR_InitialHeight            = (#AHI_TagBase+243) 
#AHIR_InitialAudioID           = (#AHI_TagBase+244) ; Initial audio mode id 
#AHIR_InitialMixFreq           = (#AHI_TagBase+245) ; Initial mixing/sampling frequency 
#AHIR_InitialInfoOpened        = (#AHI_TagBase+246) ; Info window initially opened? 
#AHIR_InitialInfoLeftEdge      = (#AHI_TagBase+247) ; Initial Info window coords. 
#AHIR_InitialInfoTopEdge       = (#AHI_TagBase+248) 
#AHIR_InitialInfoWidth         = (#AHI_TagBase+249) ; Not used! 
#AHIR_InitialInfoHeight        = (#AHI_TagBase+250) ; Not used! 
; Options 
#AHIR_DoMixFreq                = (#AHI_TagBase+260) ; Allow selection of mixing frequency? 
#AHIR_DoDefaultMode            = (#AHI_TagBase+261) ; Allow selection of default mode? (V4) 
; Filtering 
#AHIR_FilterTags               = (#AHI_TagBase+270) ; Pointer to filter taglist 
#AHIR_FilterFunc               = (#AHI_TagBase+271) ; Function to filter mode id's 

;** DEFS 

AHINAME$                       = "ahi.device" 
#AHI_INVALID_ID                = (NOT 0) ; Invalid Audio ID 
#AHI_DEFAULT_ID                = ($00000000) ; Only for AHI_AllocAudioA()! 
#AHI_LOOPBACK_ID               = ($00000001) ; Special sample render Audio ID 
#AHI_DEFAULT_FREQ              = (0) ; Only for AHI_AllocAudioA()! 
#AHI_MIXFREQ                   = (NOT 0) ; Special frequency for AHI_SetFreq() 
#AHI_NOSOUND                   = ($ffff) ; Turns a channel off 

; Set#? Flags 
#AHISF_IMM                     = (1 LSL 0) ; Trigger action immediately 
#AHISF_NODELAY                 = (1 LSL 1) ; Don't wait for zero-crossing 

#AHISF_NONE                    = (0) ; No flags (V6)  

#AHISB_IMM                     = (0) 
#AHISB_NODELAY                 = (1) 

; Effect Types 
#AHIET_CANCEL                  = (1 LSL 31) ; OR with effect to disable 
#AHIET_MASTERVOLUME            = (1) 
#AHIET_OUTPUTBUFFER            = (2) 
; --- New for V4 --- 
#AHIET_DSPMASK                 = (3) 
#AHIET_DSPECHO                 = (4) 
#AHIET_CHANNELINFO             = (5) 

; Sound Types 
#AHIST_NOTYPE                  = (NOT 0) ; Private 
#AHIST_SAMPLE                  = (0) ; 8 or 16 bit sample 
#AHIST_DYNAMICSAMPLE           = (1) ; Dynamic sample 
#AHIST_INPUT                   = (1 LSL 29) ; The input from your sampler 
#AHIST_BW                      = (1 LSL 30) ; Private 

; Sample types 
; Note that only AHIST_M8S, AHIST_S8S, AHIST_M16S and AHIST_S16S
; (plus AHIST_M32S, AHIST_S32S and AHIST_L7_1 in V6)
; are supported by AHI_LoadSound(). 
#AHIST_M8S                     = (0) ; Mono, 8 bit signed (BYTE) 
#AHIST_M16S                    = (1) ; Mono, 16 bit signed (WORD) 
#AHIST_S8S                     = (2) ; Stereo, 8 bit signed (2×BYTE) 
#AHIST_S16S                    = (3) ; Stereo, 16 bit signed (2×WORD) 
#AHIST_M32S                    = (8) ; Mono, 32 bit signed (LONG) 
#AHIST_S32S                    = (10) ; Stereo, 32 bit signed (2×LONG) 

#AHIST_M8U                     = (4) ; OBSOLETE! 
#AHIST_L7_1                    = ($00c3000a) ; 7.1, 32 bit signed (8×LONG) 

; Error codes 
#AHIE_OK                       = (0) ; No error 
#AHIE_NOMEM                    = (1) ; Out of memory 
#AHIE_BADSOUNDTYPE             = (2) ; Unknown sound type 
#AHIE_BADSAMPLETYPE            = (3) ; Unknown/unsupported sample type 
#AHIE_ABORTED                  = (4) ; User-triggered abortion 
#AHIE_UNKNOWN                  = (5) ; Error, but unknown 
#AHIE_HALFDUPLEX               = (6) ; CMD_WRITE/CMD_READ failure 



; DEVICE INTERFACE DEFINITIONS FOLLOWS ***********************************

; Device units 

#AHI_DEFAULT_UNIT              = (0) 
#AHI_NO_UNIT                   = (255) 


; The preference file 

#ID_AHIU                       = Cvl ("AHIU") 
#ID_AHIG                       = Cvl ("AHIG") 

NEWTYPE .AHIUnitPrefs 

   ahiup_Unit.b                          ; UBYTE   
   ahiup_Obsolete.b                      ; UBYTE   ; Was ahiup_ScaleMode 
   ahiup_Channels.w                      ; UWORD   
   ahiup_AudioMode.l                     ; ULONG   
   ahiup_Frequency.l                     ; ULONG   
   ahiup_MonitorVolume.Fixed             
   ahiup_InputGain.Fixed                 
   ahiup_OutputVolume.Fixed              
   ahiup_Input.l                         ; ULONG   
   ahiup_Output.l                        ; ULONG   
End NEWTYPE   

NEWTYPE .AHIGlobalPrefs 

   ahigp_DebugLevel.w                    ; UWORD   ; Range: 0-3 (for None, Low,
   ; High and All) 
   *ahigp_DisableSurround.w              ; BOOL    
   *ahigp_DisableEcho.w                  ; BOOL    
   *ahigp_FastEcho.w                     ; BOOL    
   ahigp_MaxCPU.Fixed                    
   *ahigp_ClipMasterVolume.w             ; BOOL    
   ahigp_Pad.w                           ; UWORD   
   ahigp_AntiClickTime.Fixed             ; In seconds (V6) 
   ahigp_ScaleMode.w                     ; UWORD   ; See below (V6) 
End NEWTYPE   

; Debug levels 
#AHI_DEBUG_NONE                = (0) 
#AHI_DEBUG_LOW                 = (1) 
#AHI_DEBUG_HIGH                = (2) 
#AHI_DEBUG_ALL                 = (3) 

; Scale modes 
#AHI_SCALE_FIXED_SAFE          = (0) ; x=y*1/max(ch) 
#AHI_SCALE_DYNAMIC_SAFE        = (1) ; x=y*1/ch  
#AHI_SCALE_FIXED_0_DB          = (2) ; x=y   
#AHI_SCALE_FIXED_3_DB          = (3) ; x=y*1/sqrt(2) 
#AHI_SCALE_FIXED_6_DB          = (4) ; x=y*1/2  

; AHIRequest 

NEWTYPE .AHIRequest 

   ahir_Std.IOStdReq                     ; STRUCT  ; Standard IO request 
   ahir_Version.w                        ; UWORD   ; Needed version 
   ; --- New for V4, they will be ignored by V2 and earlier --- 
   ahir_Pad1.w                           ; UWORD   
   ahir_Private.l[2]                     ; ULONG   ; Hands off! 
   ahir_Type.l                           ; ULONG   ; Sample format 
   ahir_Frequency.l                      ; ULONG   ; Sample/Record frequency 
   ahir_Volume.Fixed                     ; Sample volume 
   ahir_Position.Fixed                   ; Stereo position 
   *ahir_Link.AHIRequest                 ; STRUCT  ; For double buffering 
End NEWTYPE   

; Flags for OpenDevice() 

#AHIDF_NOMODESCAN              = (1 LSL 0) 
#AHIDB_NOMODESCAN              = (0) 

; #endif ; DEVICES_AHI_H 
