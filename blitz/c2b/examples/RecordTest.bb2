
; C to Blitz conversion done by c2b.

;
; ** This program uses the device interface to sample sound data.
; ** The output is written to THE DEFAULT OUTPUT, make sure you
; ** start it with "RecordTest > mysample.raw" !
; 

; #include <devices/ahi.h> 
; #include <dos/dosasl.h> 
; #include <proto/exec.h> 
; #include <proto/dos.h> 
; #include <proto/ahi.h> 
; #include <stdlib.h> 

#FREQUENCY                     = 8000 
#TYPE                          = #AHIST_M8S 
#BUFFERSIZE                    = 20000 

DEFTYPE .Library *AHIBase 
*AHImp.MsgPort = 0 
*AHIio.AHIRequest = 0 
AHIDevice.b = -1 ; BYTE 

DEFTYPE .b buffer1[BUFFERSIZE] ; BYTE 
DEFTYPE .b buffer2[BUFFERSIZE] ; BYTE 

Statement cleanup {rc.l}  
   
   if(NOT AHIDevice) 
      CloseDevice((struct IORequest *)AHIio) 
   EndIf
   DeleteIORequest((struct IORequest *)AHIio) 

   DeleteMsgPort(AHImp) 
   exit(rc) 
End Statement 

Statement main {argc.l, *argv[].b}  
   
   *p1.b = buffer1 ; BYTE  
   *p2.b = buffer2 ; BYTE  
   DEFTYPE .b *tmp ; BYTE  

   DEFTYPE .l signals ; ULONG  
   
   if(AHImp=CreateMsgPort())  
      if(AHIio=(struct AHIRequest *)CreateIORequest(AHImp,sizeof(struct AHIRequest)))  
         AHIio\ahir_Version = 4 
         AHIDevice=OpenDevice(AHINAME,0,(struct IORequest *)AHIio,NULL) 
      EndIf 
   EndIf 

   if(AHIDevice)  
      Printf("Unable to open %s/0 version 4\n",AHINAME) 
      cleanup(RETURN_FAIL) 
   EndIf 

   ; Initialize the first read
   AHIio\ahir_Std\io_Command=CMD_READ 
   AHIio\ahir_Std\io_Data=&buffer1 
   AHIio\ahir_Std\io_Length=BUFFERSIZE 
   AHIio\ahir_Std\io_Offset=0 
   AHIio\ahir_Frequency=FREQUENCY 
   AHIio\ahir_Type=TYPE 
   if(NOT DoIO((struct IORequest *) AHIio))  
      
      ; The first buffer is now filled
      SetIoErr(NULL) 
      
      for()  
         DEFTYPE .l length ; ULONG  
         
         length=AHIio\ahir_Std\io_Actual 
         
         ; Initialize the second read (note that io_Offset is not cleared!)
         AHIio\ahir_Std\io_Data=p2 
         AHIio\ahir_Std\io_Length=BUFFERSIZE 
         AHIio\ahir_Frequency=FREQUENCY 
         AHIio\ahir_Type=TYPE 
         SendIO((struct IORequest *) AHIio) 
         
         ; While the second read is in progress, save the first buffer to stdout
         if(Write(Output(),p1,length) <> length)  
            End  
         EndIf 

         signals=Wait(SIGBREAKF_CTRL_C | (1  LSL  AHImp\mp_SigBit)) 
         
         if(signals & SIGBREAKF_CTRL_C)  
            SetIoErr(ERROR_BREAK) 
            End  
         EndIf 

         ; Remove the reply
         if(WaitIO((struct IORequest *) AHIio))  
            SetIoErr(ERROR_READ_PROTECTED) 
            End  
         EndIf 

         ; Swap buffer pointers and repeat
         tmp=p1 
         p1=p2 
         p2=tmp 
      Next 
      
      ; Abort any pending iorequests
      AbortIO((struct IORequest *) AHIio) 
      WaitIO((struct IORequest *) AHIio) 
   EndIf 

   if(IoErr()) 
      
      PrintFault(IoErr(), argv[0] ) ; Oh, common! It's not MY fault that this
      ; routine prints to stdout instead of stderr!
      cleanup(RETURN_ERROR) 
   EndIf 

   cleanup(RETURN_OK) 
End Statement 
