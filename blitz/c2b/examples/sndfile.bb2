
; C to Blitz conversion done by c2b.

;
; ** Copyright (C) 1999-2000 Erik de Castro Lopo <erikd@zip.com.au>
; **
;
; ** This program is free software
; you can redistribute it and/or modify

; ** it under the terms of the GNU Lesser General Public License as published by
;
; ** the Free Software Foundation
; either version 2.1 of the License, or

; ** (at your option) any later version.
; **
; ** This program is distributed in the hope that it will be useful,
;
; ** but WITHOUT ANY WARRANTY
; without even the implied warranty of

; ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; ** GNU Lesser General Public License for more details.
; **
; ** You should have received a copy of the GNU Lesser General Public License
;
; ** along with this program
; if not, write to the Free Software

; ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
; 

; sndfile.h -- system-wide definitions 

; #ifndef SNDFILE_H 
; #SNDFILE_H

; #include <stdio.h> 
; #include <stdlib.h> 

; For the Metrowerks CodeWarrior Pro Compiler (mainly MacOS) 

; #if (defined (__MWERKS__)) 
; #include <unix.h> 
; #else 
; #include <sys/types.h> 
; #endif 

; #ifdef _WIN32 
; #pragma pack(push,1) 
; #endif 

; #ifdef __cplusplus 
extern "C" {
; #endif ; __cplusplus 

; The following file types can be read and written.
; ** A file type would consist of a major type (ie SF_FORMAT_WAV) bitwise
; ** ORed with a minor type (ie SF_FORMAT_PCM). SF_FORMAT_TYPEMASK and
; ** SF_FORMAT_SUBMASK can be used to separate the major and minor file
; ** types.
; 

; enum  
#SF_FORMAT_WAV                 = $10000 ; Microsoft WAV format (big endian). 
#SF_FORMAT_AIFF                = $20000 ; Apple/SGI AIFF format (little endian). 
#SF_FORMAT_AU                  = $30000 ; Sun/NeXT AU format (big endian). 
#SF_FORMAT_AULE                = $40000 ; DEC AU format (little endian). 
#SF_FORMAT_RAW                 = $50000 ; RAW PCM data. 
#SF_FORMAT_PAF                 = $60000 ; Ensoniq PARIS file format. 
#SF_FORMAT_SVX                 = $70000 ; Amiga IFF / SVX8 / SV16 format. 
#SF_FORMAT_NIST                = $80000 ; Sphere NIST format. 

#SF_FORMAT_PCM                 = $0001 ; PCM data in 8, 16, 24 or 32 bits. 
#SF_FORMAT_FLOAT               = $0002 ; 32 bit floats. 
#SF_FORMAT_ULAW                = $0003 ; U-Law encoded. 
#SF_FORMAT_ALAW                = $0004 ; A-Law encoded. 
#SF_FORMAT_IMA_ADPCM           = $0005 ; IMA ADPCM. 
#SF_FORMAT_MS_ADPCM            = $0006 ; Microsoft ADPCM. 

#SF_FORMAT_PCM_BE              = $0007 ; Big endian PCM data. 
#SF_FORMAT_PCM_LE              = $0008 ; Little endian PCM data. 
#SF_FORMAT_PCM_S8              = $0009 ; Signed 8 bit PCM. 
#SF_FORMAT_PCM_U8              = $000A ; Unsigned 8 bit PCM. 

#SF_FORMAT_SVX_FIB             = $000B ; SVX Fibonacci Delta encoding. 
#SF_FORMAT_SVX_EXP             = $000C ; SVX Exponential Delta encoding. 

#SF_FORMAT_GSM610              = $000D ; GSM 6.10 encoding. 

#SF_FORMAT_G721_32             = $000E ; 32kbs G721 ADPCM encoding. 
#SF_FORMAT_G723_24             = $000F ; 24kbs G723 ADPCM encoding. 

#SF_FORMAT_SUBMASK             = $FFFF 
#SF_FORMAT_TYPEMASK            = $7FFF0000 
; end of enum 

; Th following SF_FORMAT_RAW_* identifiers are deprecated. Use the
; ** SF_FORMAT_PCM_* idetifiers instead.
; 
#SF_FORMAT_RAW_BE              = #SF_FORMAT_PCM_BE 
#SF_FORMAT_RAW_LE              = #SF_FORMAT_PCM_LE 
#SF_FORMAT_RAW_S8              = #SF_FORMAT_PCM_S8 
#SF_FORMAT_RAW_U8              = #SF_FORMAT_PCM_U8 

; A SNDFILE* pointer can be passed around much like stdio.h's FILE* pointer. 

DEFTYPE .l *SNDFILE ; VOID 

; A pointer to a SF_INFO structure is passed to sf_open_read () and filled in.
; ** On write, the SF_INFO structure is filled in by the user and passed into
; ** sf_open_write ().
; 

NEWTYPE .struct_#? 
   samplerate.l                          ; UINT    
   samples.l                             ; UINT    
   channels.l                            ; UINT    
   pcmbitwidth.l                         ; UINT    ; pcmbitwidth is deprecated. 
   format.l                              ; UINT    
   sections.l                            ; UINT    
   seekable.l                            ; UINT    
End NEWTYPE  SF_INFO   


; Open the specified file for read or write. On error, this will return
; ** a NULL pointer. To find the error number, pass a NULL SNDFILE to
; ** sf_perror () or sf_error_str ().
; 

SNDFILE*  sf_open_read (const char *path, SF_INFO *wfinfo) 
SNDFILE*  sf_open_write (const char *path, const SF_INFO *wfinfo) 

; sf_perror () prints out the current error state.
; ** sf_error_str () returns the current error message to the caller in the
; ** string buffer provided.
; 

Function.l sf_perror {}  
End Function
Function.l sf_error_str {len.l}  
End Function

Function.l sf_error_number {errnum.l, *str.b, maxlen.l}  
End Function


Function.l sf_get_header_info {bufferlen.l, offset.l}  
End Function

; Get the library version string. 

Function.l sf_get_lib_version {bufferlen.l}  
End Function

; Return TRUE if fields of the SF_INFO struct are a valid combination of values. 

Function.l sf_format_check {}  
End Function

; Return the maximum absolute sample value in the SNDFILE. 

Function.d sf_signal_max {}  
End Function

; Seek within the waveform data chunk of the SNDFILE. sf_seek () uses
; ** the same values for whence (SEEK_SET, SEEK_CUR and SEEK_END) as
; ** stdio.h functions lseek () and fseek ().
; ** An offset of zero with whence set to SEEK_SET will position the
; ** read / write pointer to the first data sample.
; ** On success sf_seek returns the current position in (multi-channel)
; ** samples from the start of the file.
; ** On error sf_seek returns -1.
; 

Function.l sf_seek {frames.l, whence.l}  
End Function

; Functions for reading/writing the waveform data of a sound file.
; 

Function.l sf_read_raw {*ptr.l, bytes.l}  
End Function
Function.l sf_write_raw {*ptr.l, bytes.l}  
End Function

; Functions for reading and writing the data chunk in terms of frames.
; ** The number of items actually read/written = frames * number of channels.
; **     sf_xxxx_raw  read/writes the raw data bytes from/to the file
; **     sf_xxxx_uchar passes data in the unsigned char format
; **     sf_xxxx_char  passes data in the signed char format
; **     sf_xxxx_short passes data in the native short format
; **     sf_xxxx_int  passes data in the native int format
; **     sf_xxxx_float passes data in the native float format
; **     sf_xxxx_double passes data in the native double format
; ** For the double format, if the normalize flag is TRUE, the read/write
; ** operations will use floats/doubles in the rangs [-1.0 .. 1.0] to
; ** represent the minimum and maximum values of the waveform irrespective
; ** of the bitwidth of the input/output file.
; ** All of these read/write function return number of frames read/written.
; 

Function.l sf_readf_short {*ptr.w, frames.l}  
End Function
Function.l sf_writef_short {*ptr.w, frames.l}  
End Function

Function.l sf_readf_int {*ptr.l, frames.l}  
End Function
Function.l sf_writef_int {*ptr.l, frames.l}  
End Function

Function.l sf_readf_double {*ptr.d, frames.l, normalize.l}  
End Function
Function.l sf_writef_double {*ptr.d, frames.l, normalize.l}  
End Function

; Functions for reading and writing the data chunk in terms of items.
; ** Otherwise similar to above.
; ** All of these read/write function return number of items read/written.
; 

Function.l sf_read_short {*ptr.w, items.l}  
End Function
Function.l sf_write_short {*ptr.w, items.l}  
End Function

Function.l sf_read_int {*ptr.l, items.l}  
End Function
Function.l sf_write_int {*ptr.l, items.l}  
End Function

Function.l sf_read_double {*ptr.d, items.l, normalize.l}  
End Function
Function.l sf_write_double {*ptr.d, items.l, normalize.l}  
End Function

; Close the SNDFILE. Returns 0 on success, or an error number. 

Function.l sf_close {}  
End Function

; #ifdef __cplusplus 
}
; #endif ; __cplusplus 

; #ifdef _WIN32 
; #pragma pack(pop,1) 
; #endif 

; #endif ; SNDFILE_H 




