                  Cia Interrupts in Blitz      13.06.1999
                  -----------------------
Converted from the CIA_Interval.c in the resources examples dir, on the developer CD, by Anton Reinauer <anton@ww.co.nz>.

  The Amiga has two CIA (complex interface adaptor) chips- CIA-A, and CIA-B. These provide many system timers for the computer. What we're interested in are the general purpose timers on the chips
- there's two on each chip, Timer A and Timer B- confusing huh! These timers will execute a section of code a set number of times a second (you can change how many times a second they fire). The CIA resource is a system legal way of allocating the timers, so your program can check if a timer is being used by another task, if it isn't then it can allocate it for itself.

  The Amiga interrupt system has a priority system, so if one interrupt is firing, and another more important interrupt is firing, the second will override the first. The timers on the CIA-A chip have an interrupt level of 2. That means any system interrupt with a higher number can override it. The ones on the CIA-B have a level of 6, so the only interrupt that can override it is a hardware interrupt (level 7) like an Action-Replay cartridge. Maybe the MMU or a Trap could override it (I don't know), but that wouldn't be OS legal programming. You can use the Timers on CIA-A, as long as your timing doesn't have to be very accurate. For more info check out the Developer docs (cia.doc, the devices docs- under resources, the hardware manual and the assembler doc on Aminet dev/asm/Exceptions.lha . 

   On my system the Timer Device seems to take Timer B on the CIA-A chip, and Timer B on CIA-B. It seems to dynamically allocate the one on CIA-B, so if you want to use both timers on CIA-B, it will re-allocate it's timer to Timer A, on CIA-A (only if it's available of course). The one on CIA-A always stays where it is- this makes sense, as it's only the Timers on CIA-B which people might have a preference for. 

  These timers are only accurate for short periods of time; for accurate long term timers, you would have to use either the Vertical Blank timer, or the E-Clock timer (see dev docs). When a CIA-A timer was set to fire at around 50 times a second (updating a timer by one each execution) and let to run for ten minutes (the main program put to sleep with Delay_), with no CPU load on, it fired 29,700 times, and with 100% load (a program with a mousewait statement) it fired 29,737 times. That's only a difference of 0.1% !  Strangely enough the CIA-B timer fired 29,751 times under load (it was identical as the A one with no load on) :-s . Note: that the CIA-A timer could be affected by other system tasks as well- I haven't tested this .
   
   To change the speed at which the interrupt fires- change the #LOCOUNT and #HICOUNT bytes at the top of the code. The slowest is $FF on both (around 5 times a second). I've had it firing around 20,000 times a second with a #LOCOUNT of $1C and $00 for #HICOUNT! Note that that the faster you have it firing the less accurate it becomes. Also the PreferCIA_A variable at the top of the code sets wether your program tries to allocate a CIA-A or CIA-B timer first. If PreferCIA_A=True then it will try to allocate one of CIA-A timers first, if both are taken then it will attempt to allocate a Timer on CIA-B, if it can't allocate either of them also, then the program will exit. 

   Note: this is from the hardware docs- (.715909 Mhz NTSC; .709379 Mhz PAL)- I assume this is how fast the timer would fire if #LOCOUNT is set to 1, and #HICOUNT to $00 (if your Interrupt code fires fast enough of course- I wouldn't try it! :). So I assume that the timers will fire at different speeds depending on wether you were running in PAL or NTSC- you'd have to check which mode you where in first.

  There are three programs- Cia.asc is the one you want to use in your code, it starts the timer by hitting the hardware direct. Cia-OS_Start.asc starts the timers OS legally using the CIA resource- but it only fires once- you'd have to hit the hardware anyway to put it in continuous mode, so there's no point in doing it OS legal :-(  The third one, if it can't allocate the timer you want, it prints out the name of the Task that owns the timer, for testing purposes. The original example sets up a Signal, and puts the main task to sleep, until a set time is reached in the Interrupt code, which then sends a signal to your main task to wake it up. I haven't put this in, as I didn't need it, but it shouldn't be hard to put- check out the CIA_Interval.c example for details.    

  There are three variables set in the beginning of .Main . The name of the Task that owns the Timer, the data to be put in register A1 each time the Timer fires (usually a pointer to our variable, or data structure), and pointer to the Interrupt code itself. The code executed by the timer each time it fires is down the bottom of the program (in .Timer)- this should be as small and quick as possible to stop hogging system resources, and preferably written in assembler- it didn't seem to work with a Blitz variable.

  If you have any questions/comments e-mail me at:
  anton@ww.co.nz    - Anton  :-)


                     
