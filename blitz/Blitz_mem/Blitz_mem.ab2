
; Extended Memory functions for Blitz
; (C) 2010-2013  Lorence Lombardo.
; Works on all Blitz flavours on Amiga.

; Date commenced:-   2-May-2010
; Last modified:-   19-May-2013

; Functions List:-

; copyMemL
; copyMemW
; copyMemB
; MemClr
; memset
; leek24
; Upeek24
; loke24
; UBpeek
; UWpeek
; FLpeek
; FWpeek
; Fpeek24
; UFWpeek
; UFpeek24
; PeekStr


; CopyMem long aligned

Statement copyMemL {addy1.l, addy2.l, sz.l}
   For x.l=0 To sz-4 Step 4
      lng.l=Peek.l(addy1+x) : Poke.l(addy2+x),lng
   Next x
End Statement


; CopyMem word aligned

Statement copyMemW {addy1.l, addy2.l, sz.l}
   For x.l=0 To sz-2 Step 2
      wrd.w=Peek.w(addy1+x) : Poke.w(addy2+x),wrd
   Next x
End Statement


; CopyMem byte aligned

Statement copyMemB {addy1.l, addy2.l, sz.l}
   For x.l=0 To sz-1
      byte.b=Peek.b(addy1+x) : Poke.b(addy2+x),byte
   Next x
End Statement


; Clears memory

Statement MemClr {addy.l, sz.l}
   For x.l=0 To sz-1 : Poke.b(addy+x),0 : Next x
End Statement


; sets memory with a specified byte  ; similar to the C version

Statement memset{addy.l, char.b, sz.l}
   For x.l=0 To sz-1 : Poke.b addy+x, char : Next x
End Statement


; signed 24bit peek

Function.l leek24{addy.l}
   Function Return (Peek.w(addy) LSL 8) + (Peek.b(addy+2) AND $FF)
End Function


; unsigned 24bit peek

Function.l Upeek24{addy.l}
   ret.l=0 : CopyMem_ addy, &ret+1, 3
   Function Return ret
End Function


; 24bit poke

Statement loke24{addy.l, num.l}
   CopyMem_ &num+1, addy, 3
End Statement


; unsigned byte peek

Function.w UBpeek{addy.l}
   Function Return Peek.b(addy) AND $FF
End Function


; unsigned word peek

Function.l UWpeek{addy.l}
   Function Return Peek.w(addy) AND $FFFF
End Function


; peek a long with an endian flip

Function.l FLpeek{addy.l}
   b1.b=Peek.b(addy) : b2.b=Peek.b(addy+1) : b3.b=Peek.b(addy+2)
   ret.l=Peek.b(addy+3) LSL 24 : Poke.b &ret+1,b3
   Poke.b &ret+2,b2 : Poke.b &ret+3,b1
   Function Return ret
End Function


; peek a signed word with an endian flip

Function.w FWpeek{addy.l}
   Function Return (Peek.b(addy+1) LSL 8) + (Peek.b(addy) AND $FF)
End Function


; signed 24bit peek with an endian flip

Function.l Fpeek24{addy.l}
   b1.b=Peek.b(addy) : b2.b=Peek.b(addy+1) : ret.l=Peek.b(addy+2) LSL 16
   Poke.b (&ret+2),b2 : Poke.b (&ret+3),b1
   Function Return ret
End Function


; peek an unsigned word with an endian flip

Function.l UFWpeek{addy.l}
   ret.l=0 : b1.b=Peek.b(addy) : b2.b=Peek.b(addy+1)
   Poke.b &ret+2,b2 : Poke.b &ret+3,b1
   Function Return ret
End Function


; unsigned 24bit peek with an endian flip

Function.l UFpeek24{addy.l}
   ret.l=0 : b1.b=Peek.b(addy) : b2.b=Peek.b(addy+1) : b3.b=Peek.b(addy+2)
   Poke.b (&ret+1),b3 : Poke.b (&ret+2),b2 : Poke.b (&ret+3),b1
   Function Return ret
End Function


; peeks a string of specified length

Function.s PeekStr{addy.l, sz.w}
   buf$=String$(Chr$(0), sz) : CopyMem_ addy, &buf$, sz
   Function Return buf$
End Function


; End of functions

; -----------------------------------------------------------------------------

; Functions demo begins here.



buf1$="123456789012"      ; <- source buffer evenly divisible by 4 with no remainder.

buf2$=String$(Chr$(0),12) ; <- destination buffer of zero's allocated.

buf3$=buf2$               ; <- back up of our destination buffer of zero's.


NPrint "" : NPrint " copyMemX:-" : NPrint ""

copyMemL {&buf1$, &buf2$, Len(buf1$)}

NPrint buf2$

buf2$=buf3$ ;  <- zero buf2$ again ready for next test.

copyMemW {&buf1$, &buf2$, Len(buf1$)}

NPrint buf2$

buf2$=buf3$ ;  <- zero buf2$ again ready for next test.

copyMemB {&buf1$, &buf2$, Len(buf1$)}

NPrint buf2$

NPrint "" : NPrint " MemClr:-" : NPrint ""

MemClr{&buf1$, Len(buf1$)}

NPrint buf1$, " Len = ", Len(buf1$)

NPrint "" : NPrint " FLpeek:-" : NPrint ""

a$="ABCD"

bla.l=FLpeek{&a$}

NPrint PeekStr{&bla, 4}

bla2.w=FWpeek{&a$}

NPrint PeekStr{&bla2, 2}

bla.l=Fpeek24{&a$}

NPrint PeekStr{&bla+1, 3}

NPrint "" : NPrint " MemSet:-" : NPrint ""

memset{&buf1$, Asc("I"), Len(buf1$)}

NPrint buf1$

NPrint "" : NPrint " More peeks & a loke:-" : NPrint ""

bla$=Mki$(-1)+Chr$(255)

NPrint leek24{&bla$}
NPrint Upeek24{&bla$}

NPrint Peek.b(&bla$)
NPrint UBpeek{&bla$}

NPrint Peek.w(&bla$)
NPrint UWpeek{&bla$}

NPrint Upeek24{&buf1$}
loke24{&buf1$, 16777215}  ; <- loke works for signed & unsigned
NPrint Upeek24{&buf1$}

NPrint buf1$
NPrint Chr$(255)
NPrint bla$

bla2.w=40000 ; <- too much for a signed word
NPrint bla2
bla2.w=FWpeek{&bla2}  ; <- here make it intel
NPrint UFWpeek{&bla2}  ; <- here we retrieve it as a motorola unsigned word


bla.l=9388607            ; <- that would be too much for a signed 24 bit
NPrint leek24{&bla+1}    ; <- +1 coz we r in a 32 bit long
bla.l=Fpeek24{&bla+1}    ; <- here make it intel
NPrint UFpeek24{&bla+1}  ; <- here we retrieve it as a motorola unsigned 24 bit

NPrint ""


