
All registers are saved before these functions do anything out of the
ordinary, but in the event of the CIA replayers, anything could happen.

-----------------------------------------------------------------------------

Function:        Begin
Syntax:          string$=Begin {NameOfFile$}

NameOfFile$ = full path of file to be loaded

This routine loads your file, recognises it if possible, does appropriate
relocation and initialization and returns string$, which will contain an
error message if something went wrong, or "" if everything is A.O.K..

-----------------------------------------------------------------------------

Function:        CreatorID
Syntax:          string$=CreatorID {}

This function returns a small ID for the type of module loaded in string$.

_ALL_ modules will return something in string$.

-----------------------------------------------------------------------------

Function:        InitMusic
Syntax:          string$=InitMusic {}

This routine performs various initializations on the module.

If everything went OK, then "" will be returned in string$, otherwise an
error string will be returned.

-----------------------------------------------------------------------------

Function:        StartMusic
Syntax:          string$=StartMusic {SongNumber.l}

SongNumber.l = Number of SubSong you want to play

This routine jumps to the MODs' startmusic routine.

Note that before this routine is called, you should use GetNumSongs{} and
SetSongNum{} to play anything bar song #1.

If everything is OK, "" is returned in string$, else an error will be given.

-----------------------------------------------------------------------------

Statement:       StopMusic
Syntax:          StopMusic {}

This routine, yep, you guessed it, jumps to the MODs' stopmusic routine.

-----------------------------------------------------------------------------

Function:        ContinueMusic
Syntax:          byte.b=ContinueMusic {}

This function will attempt to continue playing the module where StopMusic
left off and returns True in byte.b for success, False for failure.

If the module can't be continued, the routine will call StartMusic{} instead.

-----------------------------------------------------------------------------

Statement:       EndMusic
Syntax:          EndMusic {}

This routine jumps to the MODs' endmusic routine.

My brain is straining from RSI.  :)

-----------------------------------------------------------------------------

Statement:       Finish
Syntax:          Finish {}

This routine cleans up all the allocated memory and resets various counters.

-----------------------------------------------------------------------------

Function:        TimerModes
Syntax:          byte.b=TimerModes {}

This routine checks which timing routines are present.

It can return byte.b as:
0 - No timing systems present (Don't ever expect that to happen)
1 - PAL timing (VBlank50) present
2 - NTSC timing (VBlank60) present
4 - TimerTick timing present
If more than one timing system is found the values will be added together.
(seperable with a `byte AND 2' or `byte AND 1' or whatever)

-----------------------------------------------------------------------------

Function:       Vblank50
Syntax:         byte.b=Vblank50 {}

This jumps to the MODs' vblank50 routine and returns True in byte.b.

-----------------------------------------------------------------------------

Function:       Vblank60
Syntax:         byte.b=Vblank60 {}

This jumps to the MODs' vblank60 routine and returns True in byte.b.

-----------------------------------------------------------------------------

Function:       Channel0
Syntax:         byte.b=Channel0 {}

This is for use with GMOD's only, don't ask me _what_ it does :)

Returns True for success, False for failure, in byte.b.

-----------------------------------------------------------------------------

Function:       Channel1
Syntax:         byte.b=Channel1 {}

This is for use with GMOD's only, don't ask me _what_ it does :)

Returns True for success, False for failure, in byte.b.

-----------------------------------------------------------------------------

Function:       Channel2
Syntax:         byte.b=Channel2 {}

This is for use with GMOD's only, don't ask me _what_ it does :)

Returns True for success, False for failure, in byte.b.

-----------------------------------------------------------------------------

Function:       Channel3
Syntax:         byte.b=Channel3 {}

This is for use with GMOD's only, don't ask me _what_ it does :)

Returns True for success, False for failure, in byte.b.

-----------------------------------------------------------------------------

Function:       GetNumSongs
Syntax:         longword.l=GetNumSongs {}

Will return the number of songs this module contains in longword.l.

-----------------------------------------------------------------------------

Statement:      SetSongNum
Syntax:         SetSongNum {SongNumber.l}

This routine should be called just before StartMusic{}.

Use GetNumSongs{} first to check how many songs there actually are, most
modules will crash if you set a bad number.

-----------------------------------------------------------------------------
Function:       GetSongName
Syntax:         string$=GetSongName {}

This returns "" in string$ for failure, or the name of the song for success.

-----------------------------------------------------------------------------

Function:       GetSongAuthor
Syntax:         string$=GetSongAuthor {}

This returns "" in string$ for failure, or the name of the author for
success.

-----------------------------------------------------------------------------

Function:       GetMakerName
Syntax:         string$=GetMakerName {}

This returns "" in string$ for failure, or the name of the program that
created the module.

-----------------------------------------------------------------------------

Function:       GetFrequency
Syntax:         byte.b=GetFrequency {}

The value returned is for use with TimerTick, it determines some sort of
value to use to call TimerTick every so often.  To hell with it.  Stick to
CIA and VBlank timing :)

-----------------------------------------------------------------------------

Function:       TimerTick
Syntax:         byte.b=TimerTick {}

Reserved for very weird timing methods, use GetFrequency{} to determine how
often to call this routine.  Better still, stay clear of this altogether :)

-----------------------------------------------------------------------------

Function:       Hook
Syntax:         longword.l=Hook {HookFlags.l,HookStructureAddress.l}

HookFlags.l = Flags for the, erm, hook :)
HookStructureAddress.l = Where the hook is stored in mem

Erm, only for use with GMODs I would think, read the GMOD documentation
for more details.

-----------------------------------------------------------------------------

Function:       Jump
Syntax:         byte.b=Jump {Position.l}

Position.l = Position in the module to `jump' to

Useful for storing several modules inside the one file, also an alternative
way to use subsongs, mainly in Protracker and MED modules, Jump{} will start
playing the module from the specified Position.l, in the playlist.

Returns True for success.

-----------------------------------------------------------------------------

Function:       SetVolume
Syntax:         byte.b=SetVolume {Left.l,Right.l}

Left.l & Right.l = Range should be between 0-255

Sets the balance for the left and right channels.  Range from 0-255 for
modules with extremely finetuning (GMODs only so far:)

If the moduleplayer routine only handles a mainvolume, the two numbers will
be AVERAGED.

Returns True for success.

----------------------------------------------------------------------------

Function:       GetScroll
Syntax:         string$=GetScroll {}

If the module contains some sort of large info-text, GetScroll{} will return
it in string$.

----------------------------------------------------------------------------
