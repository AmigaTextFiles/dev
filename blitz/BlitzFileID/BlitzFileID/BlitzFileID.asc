; ASCII source version.

; The tokenised version is in the dev/basic/BlitzFileID.lha
; archive on Aminet.

; IMPORTANT : This needs Blitzlibs:amigalibs.res
; specified in the Compiler Options "Resident" box.

XINCLUDE "BlitzFileIDIncs.bb2" ; This is supplied in
                               ; the archive, along with
                               ; an ASCII version.

.TOP
.
; BlitzFileID :

; A set of functions & statements for using FileID.library
; By James L Boyd - jamesboyd@all-hail.freeserve.co.uk

; FileID.library is (C) 1993-1998 by Oliver "Bloodrock" Lange

; $VER: BlitzFileID v1.2 (27.12.1998) James L Boyd

;----------------------------------------------------------------

; Functions and statements included
;----------------------------------
; ( F = function ; S = statement )
;----------------------------------

; CheckLib {}        F  - Checks availability of any library.

; RecTypes {}        F  - Number of file types known by the
;                         fileid.library.

; AllocFileInfo {}   F  - Allocates FI_FileInfo structure, ie.
;                         set library up to examine file(s).

;                         MUST be freed by calling FreeFileInfo {}
;                         before quitting.

; ExamineFile {}     F  - Examines file (duh)...will return
;                         an error code if something's wrong.

; GetError {}        F  - Returns FileID's built-in error string,
;                         using the value from ExamineFile {}.

; GetCustomError {}  F  - Returns programmer's own error string,
;                         using the value from ExamineFile {}.

; FileTypeNumber {}  F  - File type ID number, eg. #FID_LHA,
;                         which is 71 - an LHA archive. The values
;                         are listed in BlitzFileIDIncs.bb2.

; FileTypeName {}    F  - File type name, eg. "ZIP archive".

; TypeFromNumber {}  F  - Returns file type string from number.
;                         You supply a valid fileid.library
;                         ID number, and it'll return the file
;                         type string.

; FreeFileInfo {}    S  - Free FI_FileInfo structure allocated
;                         by AllocFileInfo {}. MUST be called
;                         before program ends!

; Most functions have built-in "debugging" - they tell you
; if you haven't allocated a FI_FileInfo structure (ie called
; AllocFileInfo {} ) and put up a requester. This can only
; appear while your program's in development, so it won't
; ever appear to your user if it doesn't appear to you!

.USAGE
;-----

; Simple usage of this set of functions :

; 1) Check for the FileID.library on user's system,
;    by calling CheckLib {}. Quit if it's not there.

; 2) Set up the library for use by calling AllocFileInfo {}.

; 3) Use the library to examine the file, by calling
;    ExamineFile {}.

; 4) Find out what the file is by calling FileTypeNumber {}
;    or FileTypeName {}.

; 5) Repeat steps 3) and 4) for as many files as you like.

; 6) Tell the program you've finished with the library
;    by calling FreeFileInfo {} - this is important!

; See the demos for practical examples.

.
.STATEMENTS
;----------
.

.FreeFileInfo

; Frees the FI_FileInfo structure if it's been set up
; by the AllocFileInfo {} function.

; Example usage :

; FreeFileInfo {}

  Statement FreeFileInfo {}
    SHARED *FileInfo.FI_FileInfo
    If *FileInfo
      FIFreeFileInfo_ *FileInfo
    Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
    EndIf
  End Statement

.
.FUNCTIONS
;---------
.

.CheckLib

; Returns pointer to library if successful (not useful!)
; or False (0) if library/version not available.

; This is NOT dependant on FileID.library - you
; can use it in any program, for any library!

; libv can only be an integer - no sub-versions!
; (OS choice, not mine!).

; Example usage :

; If CheckLib {"reqtools.library",38} = False Then End

  Function.l CheckLib {lib$,libv.w}
  *lib.l=OpenLibrary_(&lib$,libv)
    If *lib
      CloseLibrary_ *lib
    EndIf
  Function Return *lib
  End Function

.AllocFileInfo

; Returns pointer to FI_FileInfo structure if successful,
; or False (0) if failed. Must be freed before program ends
; by calling FreeFileInfo {}.

; Example usage :

; If AllocFileInfo {} = False Then End

  Function.l AllocFileInfo {}
    SHARED *FileInfo.FI_FileInfo
    *FileInfo=FIAllocFileInfo_
    Function Return *FileInfo
  End Function

.ExamineFile

; Reads start of file to try and determine type.

; If you get any value returned which is NOT zero,
; an error has occurred - supply the value to GetError {}
; to find out what's wrong.

; REMEMBER - you want it to return a false (0) value !!!

; Example usage :

; If ExamineFile {"C:Copy"} <> False Then Print "Error"

Function.l ExamineFile {fil$}
  SHARED *FileInfo.FI_FileInfo
  If *FileInfo
  error.l=FIIdentifyFromName_ (*FileInfo,&fil$)
  Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
  EndIf
Function Return error
End Function

.FileTypeNumber

; Returns the file type's number (from the FileID includes).
; the result is of a word value.

; Good if you don't need the string, if you just wanted
; to check a file was an IFF before loading, for example.
; ( eg. #FID_ILBM = 19 )

; The constants (file type numbers) are listed in the
; BlitzFileIDIncs.bb2 file.

; Example usage :

; If FileTypeNumber {} = #FID_LHA           ; #FID_LHA = 71
;   Execute_ "lha x example.lha RAM:",0,0
; Else Request "","Not an lha file!","OK"
; EndIf

Function.w FileTypeNumber {}

  SHARED *FileInfo.FI_FileInfo
  If *FileInfo
    Function Return *FileInfo\FI_ID
  Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
  EndIf

End Function

.FileTypeName

; Returns string containing file type according to
; the result of ExamineFile {}.

; DO NOT CALL THIS IF YOU GET AN
; ERROR CODE FROM ExamineFile {} !
; ExamineFile {} MUST return 0 before this is called!

; YOU must check it! See the demo!

; Example usage :

; If ExamineFile {fil$}=0 Then Print FileTypeName {}

Function.s FileTypeName {}
  SHARED *FileInfo.FI_FileInfo
  If *FileInfo
    Function Return Peek$(FIGetIDString_(*FileInfo\FI_ID))
  Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
  EndIf
End Function

.TypeFromNumber

; Returns a string when given a file type number/constant,
; as listed in BlitzFileIDIncs.bb2.

; Using RecTypes {} will give you the highest number
; available - use numbers from 0 to RecTypes {}.

; See DEMO2 for a working example.

; Example usage :

; Print TypeFromNumber {#FID_LHA}
; (above line will print "LhA/Lharc archive")

Function.s TypeFromNumber {no.l}
  SHARED *FileInfo.FI_FileInfo
  If *FileInfo
    Function Return Peek$(FIGetIDString_(no))
  Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
  EndIf
End Function

.GetError

; Returns the fileID.library's built-in error string for
; the error which has occurred (a non-zero number returned
; by ExamineFile {} ).

; Only call if you get a non-zero value returned
; from ExamineFile {} !

; Example usage :

; If error <> False Then Print GetError {}

Function.s GetError{}
  SHARED *FileInfo.FI_FileInfo
  If *FileInfo
    error$=Peek$(*FileInfo\FI_Description)
  Else Request "Programmer Error!","Programmer Error!||You haven't called AllocFileInfo {} !","Doh!"
  EndIf
Function Return error$
End Function

.GetCustomError

; Allows you to set your own error strings to be returned
; ONLY if ExamineFile{} returns a non-zero value.

; Example usage :

; If ExamineFile {"T:xx"} <> False Then Print GetCustomError {error}

Function.s GetCustomError {error.l}

If error = False
  Request "Programmer Error!","Programmer Error!||You've called GetCustomError {} with no error code!","Abort!"
EndIf

Select error

; these are the values returned : just go through the
; Case sections changing the strings to suit your tastes...

; From BlitzFileIDIncs.bb2 :

; #ERR_FILOCKFAILED    = -1  ; couldn't get entry lock.
; #ERR_FIEXAMINEFAILED = -2  ; couldn't examine entry.
; #ERR_FIOPENFAILED    = -3  ; couldn't open file.
; #ERR_FIOUTOFMEM      = -4  ; out of memory.
; #ERR_FIREADERROR     = -5  ; file read error.
; #ERR_EMPTYFILE       = -6  ; filesize is ZERO.
; #ERR_NONAME          = -7  ; the passed filename is empty.

  Case -1
    error$="Couldn't get DOS lock on file!"
  Case -2
    error$="Couldn't examine file!"
  Case -3
    error$="Couldn't open file!"
  Case -4
    error$="Not enough memory for operation!"
  Case -5
    error$="Error reading file!"
  Case -6
    error$="The file is 0 bytes in size!"
  Case -7
    error$="No filename supplied!"
  Default
    error$="Unknown error!" ; just in case ;)
End Select

Function Return error$
End Function

.RecTypes

; Returns number of files current library version recognises.

; Example usage :

; Print "Number of types FileID knows : ",RecTypes {}

  Function.l RecTypes {}
    notypes.l=FIGetHighID_
  Function Return notypes
  End Function

;----------------------------------------------------------------

; FreeFileInfo{}:End
; Uncomment the above line to see the built-in "debugging" !

; Goto DEMO2
; Uncomment the above line to try the second demo.

.
.DEMO
;----
.

; To use this set of functions, follow the four easy steps :

; 1) Check for FileID.library's availability on user's system,
;    using CheckLib {} function - see CheckForLib label,

; 2) Allocate a FI_FileInfo structure, using
;    AllocFileInfo {} function - see AllocStruct label,

; 3) Examine the file(s) required, using ExamineFile {}
;    function (see .IDFile label), then use either
;    FileTypeNumber {} or FileTypeName {} functions to
;    get type of file.

; 4) Free the FI_FileInfo structure before ending program,
;    using FreeStruct {} statement - see FreeStruct label.

;----------------------------------------------------------------

; Set up demo :

WBStartup

FindScreen 0

MaxLen p$=192 : MaxLen f$=192 : p$="SYS:" ; for file requester

;----------------------------------------------------------------

; First, we check for the FileID.library, at least v2 :

.CheckForLib

If CheckLib {"FileID.library",2} = False
  Request "Information","You need FileID.library v2+ !","Abort"
  End
EndIf

; We got this far, so we can allocate a FI_FileInfo structure :

.AllocStruct

If AllocFileInfo {} = False
  Request "Information","Can't allocate FI_FileInfo structure!","Abort"
  End
EndIf

;----------------------------------------------------------------

loop

fil$=ASLFileRequest$("Select file to identify",p$,f$)

  If fil$="" OR f$="" Then Goto quit

.IDFile

  If ExamineFile {fil$} <> False ; non-zero value returned?
    Request "","Error : "+GetError{},"OK"            ; error!
  Else Request "","File type : "+FileTypeName{},"OK" ; success!
  EndIf

Goto loop

;----------------------------------------------------------------

quit

; Finally, we MUST free the structure :

.FreeStruct

FreeFileInfo {}

End

.
.DEMO2
;-----

; only works from compiler or CLI!!!

; list all recognised file types :

  If FromCLI=0 Then Request "","Only to be run from CLI!","OK":End

  #SIGBREAKF_CTRL_C=1 ASL 12 ; Ctrl-C signal

If AllocFileInfo{} ; get a FI_FileInfo structure

  NPrint ""
  NPrint "BlitzFileID - Listing all known file formats :"
  NPrint ""

  Delay_ 50

;----------------------------------------------------------------

  For a=0 To RecTypes{}

    NPrint "",Str$(a)+" : "+TypeFromNumber{a}

    ; quit on Ctrl-C, remembering to free FI_FileInfo structure!

    If (SetSignal_(0,#SIGBREAKF_CTRL_C) & #SIGBREAKF_CTRL_C)
      NPrint "":NPrint "***Break - Click mouse!"
      Pop For:FreeFileInfo{}:MouseWait:End
    EndIf

  Next a

;----------------------------------------------------------------

  NPrint "":NPrint "Click mouse!":MouseWait

FreeFileInfo{} ; free FI_FileInfo structure

Else Request "","Failed to allocate FI_FileInfo structure!","END"
EndIf

End
.
.BOTTOM

