
; Floating point to string functions for Blitz

; FFP or IEEE single float

; (c) 2012-2013  Lorence Lombardo.   18-Aug-2012 to 14-May-2013

; These functions can also be used with classic Blitz.


#FPU=0  ; <- FPU compiler constant should be 1 OR 0


CNIF #FPU=1  ; <- dont touch ;)


optimize 7

; converts single IEEE floating point to integer floating point

Function.f intF{num.f}
   ieee.l=IEEESPFloor_( Peek.l(&num)  )
   Function Return Peek.f(&ieee)
End Function


CELSE


; converts FFP floating point to integer floating point

Function.f intF{num.f}
   ffp.l=SPFloor_( Peek.l(&num)  )
   Function Return Peek.f(&ffp)
End Function


CEND


INCLUDE "ValF_inc.bb2"  ; <- here for testing purposes only


; Decimal Float to Multi Base float string signed

Function.s MBStrFd{num.f, base.b, fdig.b}
   v$="" : nmax.b=base-1
   If base<>2 AND base<>10 AND base<>16 AND base<>8
      Function Return v$
   EndIf
   ngtv.b=0 : If num<0 Then ngtv=1 : num*-1
   numA.f=intF{num} : numB.f=num-numA
   If numA>0
      Repeat
         rem.l=numA MOD base : If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=Chr$(rem+55)+v$ Else v$=Chr$(rem+48)+v$
         numA=(numA-rem)/base
      Until numA<=0
   EndIf
   If numB>0 AND fdig>0
      v$=v$+"." : fc.b=0
      Repeat
         ans.f=numB*base : rem.l=intF{ans}
         If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=v$+Chr$(rem+55) Else v$=v$+Chr$(rem+48)
         numB=ans-rem : fc+1
      Until numB<=0 OR fc=>fdig
      v$=StripTrail$(v$,48) : v$=StripTrail$(v$,46)
   EndIf
   If ngtv=1 Then v$="-"+v$
   If v$="" OR v$="-" Then v$="0"
   Function Return v$
End Function


; MBStrFd{} wrapper with suggested fraction digit defaults for each base.
; Simply alter the defaults to your liking & use MBStrFd{} directly
; when you want to specify the maximum fraction digits.

Function.s MBStrF{num.f, base.b}
   If base=10 Then fdig.b=7
   If base=16 Then fdig.b=6
   If base=8 Then fdig.b=8
   If base=2 Then fdig.b=23
   Function Return MBStrFd{num, base, fdig}
End Function


; Str$() like wrapper

Function.s StrF{num.f}
   fdig.b=7 : base.b=10
   Function Return MBStrFd{num, base, fdig}
End Function


; Hex wrapper

Function.s HexStrF{num.f}
   fdig.b=6 : base.b=16
   Function Return MBStrFd{num, base, fdig}
End Function


; Binary wrapper

Function.s BinStrF{num.f}
   fdig.b=23 : base.b=2
   Function Return MBStrFd{num, base, fdig}
End Function


; Octal wrapper

Function.s OctStrF{num.f}
   fdig.b=8 : base.b=8
   Function Return MBStrFd{num, base, fdig}
End Function



;-------------------------------------------------------------------------------


FloatMode -1

bla.f=2^52
NPrint bla
NPrint "4503599627370496"
NPrint StrF{bla}

bla.f=Pi
NPrint bla
NPrint StrF{bla}
NPrint MBStrFd{bla, 10, 20}

bla.f=ValF{"$7A.C"}
NPrint HexStrF{bla}

bla.f=ValF{"%101.11"}
NPrint BinStrF{bla}

bla.f=ValF{"#172.6"}
NPrint OctStrF{bla}

NPrint "" : NPrint " MBStrF test:-"

bla.f=2^52
NPrint MBStrF{bla, 10}

bla.f=Pi
NPrint MBStrF{bla, 10}

bla.f=ValF{"$7A.C"}
NPrint MBStrF{bla, 16}

bla.f=ValF{"%101.11"}
NPrint MBStrF{bla, 2}

bla.f=ValF{"#172.6"}
NPrint MBStrF{bla, 8}

bla.f=1/3
NPrint bla
NPrint MBStrF{bla, 10}


NPrint "" : End

