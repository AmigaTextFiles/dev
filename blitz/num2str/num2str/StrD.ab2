
; Floating point to string functions for Blitz

; IEEE double float, requires FPU

; (c) 2012-2013  Lorence Lombardo.   18-Aug-2012 to 14-May-2013


optimize 7

#FPU=1

INCLUDE "ValF_inc.bb2"  ; <- here for testing purposes only


; converts double IEEE floating point to integer floating point

Statement intD{num.d, addy.l}
   SHARED ieee2.l ; <- PutReg vars need to be shared when in non global
   ieee1.l=IEEEDPFloor_( Peek.l(&num), Peek.l(&num+4)  )
   PutReg d1, ieee2.l : Poke.l addy, ieee1 : Poke.l addy+4, ieee2
End Statement


; Decimal Float to Multi Base float string signed

Function.s MBStrDd{num.d, base.b, fdig.b}
   v$="" : nmax.b=base-1
   If base<>2 AND base<>10 AND base<>16 AND base<>8
      Function Return v$
   EndIf
   ngtv.b=0 : If num<0 Then ngtv=1 : num*-1
   intD{num, &numA.d} : numB.d=num-numA
   If numA>0
      Repeat
         rem.l=numA MOD base : If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=Chr$(rem+55)+v$ Else v$=Chr$(rem+48)+v$
         numA=(numA-rem)/base
      Until numA<=0
   EndIf
   If numB>0 AND fdig>0
      v$=v$+"." : fc.b=0
      Repeat
         ans.d=numB*base : intD{ans, &numB} : rem.l=numB
         If rem<0 OR rem>nmax Then rem=0
         If rem>9 Then v$=v$+Chr$(rem+55) Else v$=v$+Chr$(rem+48)
         numB=ans-rem : fc+1
      Until numB<=0 OR fc=>fdig
      v$=StripTrail$(v$,48) : v$=StripTrail$(v$,46)
   EndIf
   If ngtv=1 Then v$="-"+v$
   If v$="" OR v$="-" Then v$="0"
   Function Return v$
End Function


; MBStrDd{} wrapper with suggested fraction digit defaults for each base.
; Simply alter the defaults to your liking & use MBStrDd{} directly
; when you want to specify the maximum fraction digits.

Function.s MBStrD{num.d, base.b}
   If base=10 Then fdig.b=16
   If base=16 Then fdig.b=14
   If base=8 Then fdig.b=18
   If base=2 Then fdig.b=50
   Function Return MBStrDd{num, base, fdig}
End Function


; Str$() like wrapper

Function.s StrD{num.d}
   fdig.b=16 : base.b=10
   Function Return MBStrDd{num, base, fdig}
End Function


; Hex wrapper

Function.s HexStrD{num.d}
   fdig.b=14 : base.b=16
   Function Return MBStrDd{num, base, fdig}
End Function


; Binary wrapper

Function.s BinStrD{num.d}
   fdig.b=50 : base.b=2
   Function Return MBStrDd{num, base, fdig}
End Function


; Octal wrapper

Function.s OctStrD{num.d}
   fdig.b=18 : base.b=8
   Function Return MBStrDd{num, base, fdig}
End Function


;-------------------------------------------------------------------------------


bla.d=2^52
NPrint bla  ; <- although correctly stored its 1 digit too much for NPrint & Str$()
NPrint "4503599627370496"
NPrint StrD{bla}

bla.d=Pi
NPrint bla
NPrint StrD{bla}
NPrint MBStrDd{bla, 10, 40} ; <- only gets about 24 on amithlon

bla.d=ValF{"$7A.C"}
NPrint HexStrD{bla}

bla.d=ValF{"%101.11"}
NPrint BinStrD{bla}

bla.d=ValF{"#172.6"}
NPrint OctStrD{bla}

NPrint "" : NPrint " MBStrD test:-"

bla.d=2^52
NPrint MBStrD{bla, 10}

bla.d=Pi
NPrint MBStrD{bla, 10}

bla.d=ValF{"$7A.C"}
NPrint MBStrD{bla, 16}

bla.d=ValF{"%101.11"}
NPrint MBStrD{bla, 2}

bla.d=ValF{"#172.6"}
NPrint MBStrD{bla, 8}

bla.d=1/3
NPrint bla
NPrint MBStrD{bla, 10}
NPrint MBStrDd{bla, 10, 40}

NPrint "" : End


