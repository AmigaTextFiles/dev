
; ValF{}  (C) 2008-2012  Lorence Lombardo.  num2str version

; This is a new modified version of ValF{} for the puropse of
; testing num2str with support functions.

; But this new version of ValF{} should be useful in its own right.

; The original ValF{} can be found from "ValF.ab2" in the archive
; "SANE.lha" on the Aminet.

; ValLM{} could be tweaked specifiaclly to serve ValF{}, but on the
; other hand a complete ValLM{} may also be useful in its own right.

; 18-Aug-2012


; I'm from "ValL.ab2" from "SANE.lha" .

Function.l ValLM {a$}
   a$=Replace$(a$,",","") : a$=Replace$(a$," ","")
   c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   ntype$=Left$(a$,1) : base.b=10 : nmax.b=58
   If ntype$<>"%" AND ntype$<>"$" AND ntype$<>"#" Then ntype$=""
   If ntype$<>"" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : If s$="-" Then sign=-1
   If ntype$="%" Then base=2 : nmax=50
   If ntype$="$" Then base=16 : a$=UCase$(a$)
   If ntype$="#" Then base=8 : nmax=56
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v>47 AND v<nmax
         vl=vl*base+v-48
      Else
         If base=16 AND v>64 AND v<71
            vl=vl*16+v-55
         Else
            c=slen
         EndIf
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; I'm from here originally. ;)

Function.s OctStr{num.l}
   v$="" : ngtv.b=0 : If num<0 Then ngtv=1 : num*-1
   ov.b=0 : If num<0 Then ov=1 : num+1 : num*-1
   Repeat
      ans.l=num/8 : rem.l=num-(ans*8) : If ov=1 Then rem=0
      v$=Chr$(rem+48)+v$ : num=ans
   Until num=0
   If ngtv=1 Then v$="-"+v$ : If ov=1 Then Poke.b &v$+1,50
   Function Return v$
End Function


CNIF #FPU=1
Function.d ValF {valf$}
   fract.d=0 : fl.d=0 : valt.d=0
CELSE
Function.f ValF {valf$}
   fract.f=0 : fl.f=0 : valt.f=0
CEND
   chlen.l=9 : c.l=0 : base.l=10 : sign.l=1
   valf$=Replace$(valf$,",","") : valf$=Replace$(valf$," ","")
   sign$=Left$(valf$,1) : If sign$="-" Then sign= -1
   If sign$="-" OR sign$="+" Then valf$=Mid$(valf$,2)
   xp.l=Instr(valf$,".") : ntype$=Left$(valf$,1) : intlen.l=Len(valf$)
   If ntype$<>"%" AND ntype$<>"$" AND ntype$<>"#" Then ntype$=""
   If ntype$="%" Then chlen.l=31 : base=2
   If ntype$="$" Then chlen.l=8 : base=16
   If ntype$="#" Then chlen.l=10 : base=8
   If xp>0
      fraclen.l=chlen : If ntype$<>"" Then fraclen=chlen-1
      fract$=Mid$(valf$,xp+1,fraclen) : v$=ntype$+fract$
      frac1.l=ValLM{ v$ }
      If ntype$="" Then fract2$=Str$(frac1)
      If ntype$="$" Then fract2$=StripLead$( Hex$(frac1),48 )
      If ntype$="%" Then fract2$=StripLead$( Bin$(frac1),48 )
      If ntype$="#" Then fract2$=OctStr{frac1}
      fraclen = Len(fract2$) + Instr(fract$,fract2$) - 1
      v$=ntype$+"1"+String$("0",fraclen) : frac2.l=ValLM{v$}
      fract = frac1 / frac2
      intlen=xp-1 : valf$=Left$(valf$, intlen)
   EndIf
   If intlen>chlen
      If ntype$<>"" Then valf$=Mid$(valf$,2) : chlen-1
      Repeat
         v$ = ntype$+Right$(valf$, chlen) : v.l=ValLM{v$}
         fl = v * ((base^chlen)^c) + fl
         valf$ = Left$( valf$, Len(valf$)-chlen ) : c+1
      Until valf$=""
      valt=(fl+fract)*sign
   Else
      v.l=ValLM{valf$} : valt=(v+fract)*sign
   EndIf
   Function Return valt
End Function
 

