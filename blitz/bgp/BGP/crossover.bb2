; /--- CROSSOVER ---/


;#########################
;#      BLITZ-GP         #
;#                       #
;# Copyright (C) 1998 by #
;# Christos Dimitrakakis #
;#                       #
;#########################


.cross_inds
  special_crossovers.l=0
  avw_adj.f=0
  m.w=0


  ;          BREEDING
  ;         ==========

  neigh.w=neighbourhood/2
  While ((m<pop_size)AND(break=False))
;    If (roulette=False) OR (Rnd<ind(m)\adj_fitness)
      winner.w=-1
      winner2.w=m
      loser.w=-1
      tour_bst.f=0
      tour_wrs.f=1
      For n.w=0 To tour_size
        If demes=True
          cr.w=QLimit(m+rand{neighbourhood}-neigh,0,pop_size)
        Else
          cr.w=rand{pop_size}
        EndIf
        If winner=-1 Then winner=cr:loser=cr

        If tour_bst<ind(cr)\adj_fitness
          winner2=winner
          winner=cr
          tour_bst=ind(cr)\adj_fitness
        EndIf

      Next n

        avw_adj.f+ind(winner)\adj_fitness
        cr2=m
        cr=winner

      For tree.w=0 To nof_trees-1

        If marked_crossover.w=False
          Gosub normal_cross
        Else
          Gosub marked_cross
        EndIf

        l$=Left$(x$,x)
        r$=Mid$(y$,y+1)

        brd(cr2)\tr[tree]=l$+r$

        l$=Left$(y$,y)
        r$=Mid$(x$,x+1)

 ;        brd(cr)\tr[tree]=l$+r$  ;change father

      Next tree

;    EndIf
    Gosub break_test2
    m+1
  Wend

  ;         COPY NEW POPULATION
  ;        =====================

  For m.w=0 To pop_size-1
    For tree.w=0 To nof_trees-1
      ind(m)\tr[tree]=brd(m)\tr[tree]
    Next tree
  Next m

  avw_adj/pop_size
  Return



.normal_cross
  x$=ind(cr2)\tr[tree]

  x=rand{Len(x$)-1}             ;randomly select the
  x2ycorr.b=Asc(Mid$(x$,x,1))   ;first cross point


  y$=ind(cr)\tr[tree]
  y=rand{Len(y$)-1}


  Return


.marked_cross

  x$=ind(cr2)\tr[tree]
  attempts.b=10


  ; /-----  FIND FIRST CROSSOVER POINT -----/
  ;  make attempts.b number of attempts to
  ;  find a crossover point with a >>MARK<<

  foundmark1=False
  foundmark2=False
  Repeat
    x=rand{Len(x$)-1}
    x2ycorr.b=Asc(Mid$(x$,x,1))
    attempts-1
  Until (x2ycorr=#MARK)OR(attempts=0)
  If attempts>0 Then foundmark1=True
  y$=ind(cr)\tr[tree]
  attempts.b=10


  ; /---- FIND SECOND CROSSOVER POINT ----/ ;

  Repeat
    y=rand{Len(y$)-1}
    attempts-1
  Until (Asc(Mid$(x$,y,1))=x2ycorr)OR(attempts=0)

  If attempts=0
    special_crossovers+1
  Else
    foundmark2=True
  EndIf

  If foundmark1 AND foundmark2
    cross_marks_succ+1
  EndIf
  Return





