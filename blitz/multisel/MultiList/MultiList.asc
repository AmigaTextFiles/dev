; Description:  Conversion of multilist.c (from Aminet in dev/c), an example
;               showing how to use the GTListview callback hook for cuastom
;               rendering of list items. In this case, the custom rendering
;               (and Newtype for list entries) allows multiple selection of
;               items within the list.
;
;               m goes down the list -\  As should be done (according to
;               M goes up the list   -/  Style Guide)
;               Space selects the current (marked with star) item
;
;               NOTE - THE LISTVIEW CAN NOT BE DRAWN AS DISBALED!!!
;
;               Author of C example - mark@topic.demon.co.uk
;                                   - mpaddock@cix.compulink.co.uk
;
;               Blitz conversion - dmcminn@house-of-mojo.freeserve.co.uk
;
; Requirements: OS3.1 amigalibs.res (from NewCommandSet.lha)
;               OS3+
;
; Type:         INTUITION
;
; Comments:     For further information about hooks, see dev/basic/hookfunc.lha
;               which explains how to use hooks with ASL screenmode filtering.


; Type for holding text and selected information about listview items
; The first newtype is for when we are using the Blitz List arrays, as they will
; already have the Node fields in them.
NEWTYPE.ENNoNode
    ln_Type.b
    ln_Pri.b
    ln_Name.s
    Selected.w
    Current.w
End NEWTYPE

; The second newtype is used when we are in the hook, as it is passed the pointer
; to the list item, which must include the Node fields.
NEWTYPE.ENWithNode
    sysnode.MinNode
    item.ENNoNode
End NEWTYPE

; Standard gubbins
WBStartup
WbToScreen 0
WBenchToFront_


; Get pointer to the screen we opened on, and load the screen's font, just
; To prove that the alignment works within the gadget, For any font (including
; proportional fonts)
*s.Screen = Peek.l(Addr Screen(0))
LoadFont 0,Peek$(*s\Font\ta_Name),*s\Font\ta_YSize,*s\Font\ta_Style


; Since listview callback hooks only work on OS3+, we won't let the user continue
; with this example if they have less than OS3. Obviously, in a full program,
; you may want to do something else (i.e. just not have a multiselect listview)
If ExecVersion<39
    DisplayBeep_ *s
    End
End If


; Some things to display in listview
Dim List MList0.ENNoNode(10)
i.w = 0
While AddItem(MList0())
    ; Set text for all items and unselected and no current item
    MList0()\ln_Type = 0,0,"Entry"+UStr$(i),False,False
    i = i + 1
Wend
SizeList = i                ; SizeList is required for looping the current item when m or M is pressed
FirstItem MList0()          ; Set the current item
MList0()\Current = True     ; If you don't set this flag for one of the items, then the * won't be drawn
CurEntry.l = 0              ; until you press m or M or select item with mouse. You should also set the
                            ; CurEntry variable to something sensible, but it won't crash burn and die
                            ; if you don't


; Set up the hook variable to be used with the listview tag. This should be the minimum
; you do when using hooks - you may not need to set the SubEntry, if you don't want to
; call another function from the hook code (you'd do your hook processing in the hook
; in that case). You need to save the global variable base, or your program may crash
; (at least it has with other hook stuff I've done)
DEFTYPE.Hook    ListHook
ListHook\h_Entry = ?hook            ; This is the code called by the OS (see later)
ListHook\h_SubEntry = ?ListHookFunc ; Address of a label DIRECTLY before the Blitz function to use as hook function
PutReg a5,ListHook\h_Data           ; Store the global variable base


; Set up the listview gadget - set the hook using the GTTags directly before
; setting up the gadget using the normal Blitz2 GTListview command
GTTags #GTLV_CallBack,&ListHook
GTListView 0,0,3,15,167,60,"_Multi Select List",#PLACETEXT_ABOVE,MList0()


; Set up the IDCMP flags we will require for processing the information in
; this program, open the window and attach the GT gadget list to it
DefaultIDCMP #LISTVIEWIDCMP|#IDCMP_CLOSEWINDOW|#IDCMP_REFRESHWINDOW|#IDCMP_VANILLAKEY
Window 0,0,0,320,200,#WFLG_ACTIVATE|#WFLG_DRAGBAR|#WFLG_DEPTHGADGET|#WFLG_CLOSEGADGET|#WFLG_SMART_REFRESH,"Test window",-1,-1
AttachGTList 0,0


; The main loop repeats while the close gadget of the window has not been clicked
While ev.l <> #IDCMP_CLOSEWINDOW
    ; Wait for an event, then process it depending on what it is
    ev = WaitEvent
    Select ev
        Case #IDCMP_REFRESHWINDOW
            ; You should provide this as the minimum for refresh IDCMP messages when
            ; using GadTools gadgets - I don't know if Blitz does this anyway.
            ; If you wan't to do custom refreshing of a window, you do it between
            ; these two calls, but read the autodocs for intuition/BeginRefresh
            ; and EndRefresh as there are complexities to this.
            GT_BeginRefresh_  Peek.l(Addr Window(0))
            GT_EndRefresh_  Peek.l(Addr Window(0)),True

        Case #IDCMP_GADGETUP
            ; As there is only one gadget in this example, we take it as an item
            ; in the list view being clicked on. Initially we remove the list
            ; from the gadget and find the old current item, so we can clear the
            ; Current item flag.
            GTChangeList 0,0
            ResetList MList0()
            For i.w=0 To CurEntry
                NextItem MList0()
            Next
            MList0()\Current = False

            ; Now get the position in the list that has been clicked on, so we can
            ; set that item as the Current one and select it. Finally we re-attach
            ; the list to the gadget (also cause redraw, which uses our hook)
            CurEntry = EventCode
            ResetList MList0()
            For i.w=0 To CurEntry
                NextItem MList0()
            Next
            MList0()\Current = True
            MList0()\Selected = -1 - MList0()\Selected
            GTChangeList 0,0,MList0()

        Case #IDCMP_VANILLAKEY
            ; Key has been pressed, and because it is vanilla key type, all character
            ; type keys (i.e. A, a, 1, h, " ") will return their ASCII code, so we
            ; must check that. In this example, only m (move down list), M (move up
            ; list) and Space (toggle item selection) are the keys used.
            Select EventCode
                Case Asc("m")
                    ; m - Move down the list
                    ; Again, we first remove the list from the listview, and find the
                    ; old current item in the list and clear its current flag.
                    GTChangeList 0,0
                    ResetList MList0()
                    For i.w=0 To CurEntry
                        NextItem MList0()
                    Next
                    MList0()\Current = False

                    ; Then we increase the value of the current entry (looping back to
                    ; the first item if necessary), and then scan the list so we can
                    ; set its current item flag
                    CurEntry = CurEntry + 1
                    If CurEntry = SizeList Then CurEntry=0
                    ResetList MList0()
                    For i.w=0 To CurEntry
                        NextItem MList0()
                    Next
                    MList0()\Current = True

                    ; Finally we re-attach the list to the listview (and force a redraw
                    ; using our hook function) and then also set other tags to show
                    ; the current item (in case it is not actually being shown in the
                    ; listview).
                    GTChangeList 0,0,MList0()
                    GTSetAttrs 0,0,#GTLV_Selected,CurEntry,#GTLV_MakeVisible,CurEntry

                Case Asc("M")
                    ; M - Move up the list
                    ; Again, we first remove the list from the listview, and find the
                    ; old current item in the list and clear its current flag.
                    GTChangeList 0,0
                    ResetList MList0()
                    For i.w=0 To CurEntry
                        NextItem MList0()
                    Next
                    MList0()\Current = False

                    ; Then we decrease the value of the current entry (looping back to
                    ; the last item if necessary), and then scan the list so we can
                    ; set its current item flag
                    CurEntry = CurEntry - 1
                    If CurEntry < 0 Then CurEntry=SizeList-1
                    ResetList MList0()
                    For i.w=0 To CurEntry
                        NextItem MList0()
                    Next
                    MList0()\Current = True

                    ; Finally we re-attach the list to the listview (and force a redraw
                    ; using our hook function) and then also set other tags to show
                    ; the current item (in case it is not actually being shown in the
                    ; listview).
                    GTChangeList 0,0,MList0()
                    GTSetAttrs 0,0,#GTLV_Selected,CurEntry,#GTLV_MakeVisible,CurEntry

                Case Asc(" ")
                    ; Space - toggle selection of current item
                    ; Again, we first remove the list from the listview, and find the
                    ; current item in the list and toggle its selected flag
                    GTChangeList 0,0
                    ResetList MList0()
                    For i.w=0 To CurEntry
                        NextItem MList0()
                    Next
                    MList0()\Selected = -1 - MList0()\Selected

                    ; Finally we re-attach the list to the listview (and force a redraw
                    ; using our hook function) and then also set other tags to show
                    ; the current item (in case it is not actually being shown in the
                    ; listview).
                    GTChangeList 0,0,MList0()
                    GTSetAttrs 0,0,#GTLV_Selected,CurEntry,#GTLV_MakeVisible,CurEntry
            End Select
    End Select
Wend

; Once main loop is exited, we are going to exit program, so remove GT gadgets from window then end.
DetachGTList 0
End


; The hook called by the OS. In this case, the hook is used to call a higher level
; Blitz2 function, the address of a label DIRECTLY before it is specified in
; the SubEntry field of the hook. This hook code can be used for all hooks which call
; a higher level Blitz2 function or statement, as the function or statement is
; specified in the hook variable's SubEntry field. This code also allows the
; value returned by the function to be returned to the OS in data register 0.
;
; Using the Autodocs for the hook function you are trying to use, match the
; parameters in your function or statement so that:
;           first parameter contains what is passed in a0
;           second parameter contains what is passed in a1
;           third parameter contains what is passed in a2
;
; Thats why this code is used, to move the parameters, so a normal Blitz
; function or statement can use them.
hook:   MOVEM.l d1-d7/a0-a6,-(a7)   ; Save registers to stack (NOT D0!!!)

        MOVE.l a0,d0                ; These three moves put the hook parameters
        MOVE.l a1,d1                ; (which are in A0-A2) into the data registers,
        MOVE.l a2,d2                ; so that the Blitz function can access them

        MOVEA.l 16(a0),a5           ; Restore the global variable base
        MOVEA.l 12(a0),a3           ; Get the address pointed to by the h_SubEntry field of the Hook structure
        LEA.l   6(a3),a3            ; Get the address to jump to (adress of high level function)
        JSR     (a3)                ; Go do it!!

        ; The value is returned in d0 from the function. As this is where
        ; we want it, nothing is done, and the hook returns.
        MOVEM.l (a7)+,d1-d7/a0-a6   ; Restore registers from stack (NOT D0, we want to keep the return value)
        RTS


; Runerrsoff is required, or GURUs should be expected. Note that it is only required
; around the function or statement used as the hook function, with a Runerrson afterwards.
Runerrsoff

; The reason I have used the main rendering code in a macro, is that it is used
; four time in the function, within a Select...End Select, and its easier to
; maintain one piece of code, rather than four (supposedly) identical.
Macro lvdrawcode
            ; Calculate the length in pixels of "*", so that we can align all items
            len_gth = TextLength_(*rp, "*", 1)
            ; Also work out the number of characters from the items text (*en\item\ln_Name)
            ; that we can display in the remaining number of pixels in the listview
            ; (Listview width + 1 - length of "*" => *rec\MaxX-*rec\MinX+1-len_gth)
            *ttemp.b = *en\item\ln_Name
            l_en=TextFit_(*rp,*ttemp,Len(*en\item\ln_Name),&te,0,1,*rec\MaxX-*rec\MinX+1-len_gth,32767)

            ; Set first drawing co-ordinate to the left edge of the listview, and
            ; the bottom of where the line of text will be drawn.
            Move_ *rp, *rec\MinX, *rec\MinY + *rp\TxBaseline

            ; Set what will be displayed before item - either a * for current item
            ; or a " " for all other items
            If *en\item\Current
                charbuf = "*"
            Else
                charbuf = " "
            End If

            ; If the item is to be drawn selected, then set the drawing pens for the
            ; graphics.library functions to have a filled background and the appropriate
            ; colour for drawing on that background. If the item is not selected, then
            ; draw it with the normal background and text colours.
            ; Also set drawing mode To draw both colours.
            If(*en\item\Selected)
                SetABPenDrMd_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#FILLTEXTPEN),Peek.w(*di\dri_Pens+SizeOf.w*#FILLPEN),#JAM2
            Else
                SetABPenDrMd_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#TEXTPEN),Peek.w(*di\dri_Pens+SizeOf.w*#BACKGROUNDPEN),#JAM2
            End If

            ; Draw either the "*" or " "
            Text_ *rp, &charbuf, 1

            ; If the current pen position is less than the width of a "*", then we need
            ; to draw the difference.
            If *rp\cp_x < *rec\MinX + len_gth
                ; If the item is selected, then set the foreground pen to be a
                ; highlighted background colour, otherwise set it to a normal
                ; background colour.
                If *en\item\Selected
                    SetAPen_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#FILLPEN)
                Else
                    SetAPen_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#BACKGROUNDPEN)
                End If
                ; Draw a rectangle to make up the difference between the current
                ; pen position and the length of "*"
                RectFill_ *rp,*rp\cp_x,*rec\MinY,*rec\MinX-1+len_gth,*rec\MaxY
            End If

            ; Move pen position to the start of where the item's actual text will be drawn.
            Move_ *rp,*rec\MinX+len_gth,*rec\MinY+*rp\TxBaseline

            ; If the item is to be drawn selected, then set the drawing pens for the
            ; graphics.library functions to have a filled background and the appropriate
            ; colour for drawing on that background. If the item is not selected, then
            ; draw it with the normal background and text colours.
            ; Also set drawing mode To draw both colours.
            If(*en\item\Selected)
                SetABPenDrMd_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#FILLTEXTPEN),Peek.w(*di\dri_Pens+SizeOf.w*#FILLPEN),#JAM2
            Else
                SetABPenDrMd_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#TEXTPEN),Peek.w(*di\dri_Pens+SizeOf.w*#BACKGROUNDPEN),#JAM2
            End If
            ; Draw the item's text
            *ttemp = *en\item\ln_Name
            Text_ *rp,*ttemp,l_en

            ; If the item is selected, then set the foreground pen to be a
            ; highlighted background colour, otherwise set it to a normal
            ; background colour.
            If *en\item\Selected
                SetAPen_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#FILLPEN)
            Else
                SetAPen_ *rp,Peek.w(*di\dri_Pens+SizeOf.w*#BACKGROUNDPEN)
            End If
            ; Fill iin the space after the item's text, up to the end of the
            ; listview.
            RectFill_ *rp,*rp\cp_x,*rec\MinY,*rec\MaxX,*rec\MaxY
End Macro



; The Blitz2 function to be used in the hook. Note the label before the function.
; This function is called for every item in the listview.
ListHookFunc:
Function.l  CustomLVDraw{*myhook.Hook, *msg.LVDrawMsg, *en.ENWithNode}
    DEFTYPE.s           charbuf ; Holds either "*" or " ", depending on whther the item is the current one or not
    DEFTYPE.l           l_en    ; The number of characters that will be displayable (the items text)
    DEFTYPE.w           len_gth ; The length of "*", so that all items are aligned
    DEFTYPE.TextExtent  te      ; Needed in calls to TextFit_ (an OS graphics.library function)

    ; Define some shortcut variables, as *msg\lvdm_...... sometimes causes lines to be
    ; too long for the editor
    *rp.RastPort = *msg\lvdm_RastPort
    *rec.Rectangle = &*msg\lvdm_Bounds
    *di.DrawInfo = *msg\lvdm_DrawInfo

    ; Autodocs state that this must be done - return an unknown command if
    ; we are not told to draw the listview.
    If(*msg\lvdm_MethodID <> #LV_DRAW) Then Function Return #LVCB_UNKNOWN


    ; This represents the state of the listview. Pretty
    ; simple to see what they are. Each one of them needs the code from the macro
    ; so I used a macro to have only one copy of the code rather than 4 identical.
    Select *msg\lvdm_State
        Case #LVR_NORMAL
            !lvdrawcode

        Case #LVR_NORMALDISABLED
            !lvdrawcode

        Case #LVR_SELECTED
            !lvdrawcode

        Case #LVR_SELECTEDDISABLED
            !lvdrawcode
    End Select

    ; The value that must be returned to show the OS that this item was drawn properly.
    Function Return #LVCB_OK
End Function
Runerrson


