;-----------------------------------------------------------------

; Function : ReceiveCtrlC {}

; Author : James L Boyd - jamesboyd@all-hail.freeserve.co.uk

; Update : Thanks to David McMinn for pointing out that the
; CtrlC {} statement used to set this up previously was
; totally pointless!

; Captures Ctrl-C messages sent to the program from either
; the CLI it's run from, or other programs, such as XOpa,
; or Executive's Commander.

; Put it into all loops you want to break.

Function ReceiveCtrlC {}
  If (SetSignal_(0,#SIGBREAKF_CTRL_C) & #SIGBREAKF_CTRL_C)
	Function Return -1
  Else Function Return 0
  EndIf
End Function

; demo :

; FindScreen 0
; Window 0,0,0,640,100,$140f,"Hit close gadget or send a Ctrl-C to quit...",1,2

; Repeat
;   If ReceiveCtrlC {} Then Request "","Ctrl-C received!","END":End
;   VWait
; Until Event=$200

; End

;-----------------------------------------------------------------

; Function : SignalTask { taskname, signal }

; Author : James L Boyd - jamesboyd@all-hail.freeserve.co.uk

; Sends a command (eg. CTRL-C) to a program, returning -1 (True)
; if it sent the signal (NOTE that this doesn't necessarily mean
; the program did as it was told - not all programs support
; Ctrl-C messages, etc). Returns 0 (False) if it couldn't find
; the program.

; You should note that the taskname is CASE-SENSITIVE (not my
; choice ;) and that it can change depending on whether it
; was run from the shell or from Workbench...and stuff...

; Possible signals you can send :

; #SIGBREAKF_CTRL_C (4096)  - quit    program
; #SIGBREAKF_CTRL_D (8192)  - disable program (sleep)
; #SIGBREAKF_CTRL_E (16384) - enable  program  (wake up)
; #SIGBREAKF_CTRL_F (32768) - um...can't remember...

; NOTE : Signals have different effects depending on the
; receiving program's interpretation, but these are the general
; conventions.

Function.b SignalTask {task$,sig.l}

  *task.Task=FindTask_(&task$)

  If *task
	Signal_ *task,sig
	Function Return -1
  Else Function Return 0
  EndIf

End Function

; demo :

;; NOTE : depending on your setup, your copy may have
;; "MultiView" in different casing, eg "multiview" - adjust
;; accordingly!

; t$="MultiView"

; If SignalTask{t$,#SIGBREAKF_CTRL_C}
;   Request "","Signalled "+t$+"!","OK"
; Else Request "","Can't find "+t$+"!","OK"
; EndIf

; End

;-----------------------------------------------------------------

; Statement : WaitForSignal { signal }

; Author : James L Boyd - jamesboyd@all-hail.freeserve.co.uk

; Puts your program to sleep, using 0% CPU time, until the user
; sends the message you've asked for (eg Ctrl C).

; NOTE that this can leave your user unable to continue
; your program if they don't have a tool to send the
; command, so best used from CLI (eg. Print "Press Ctrl-C" or
; whatever before calling the statement), but may be useful
; in other situations.

; Run the demo and press Ctrl and C together, or send a
; Ctrl C (BREAK) signal from a program like XOpa, ARTM,
; Commander, etc...

; Possible signals are listed below :

; #SIGBREAKF_CTRL_C
; #SIGBREAKF_CTRL_D
; #SIGBREAKF_CTRL_E
; #SIGBREAKF_CTRL_F

Statement WaitForSignal {sig.l}
  SetSignal_ 0,sig  ; clear previous occurrences (sp?!)
  Wait_ sig
End Statement

; demo

; WaitForSignal {#SIGBREAKF_CTRL_C}
; End

;-----------------------------------------------------------------
