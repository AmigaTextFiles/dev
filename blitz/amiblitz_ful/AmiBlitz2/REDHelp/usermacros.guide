@database 108c2738-0
@master HeddleyCreation
@$VER: 1.0
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" "Includes and Macros"
                                     @{"Library Index" link "Blitz2:REDHelp/REDBlitzLibs/REDBlitzLibs.GUIDE/LIBRARYLIST"}
 @{"ahi_device_easy.include" link "ahi_includelib" 0}

 @{"dbl_display.include" link "dbl_includelib" 0}

 @{"image_include" link "image_includelib" 0}

 @{"!screen" link "!screen" 0}

 @{"Plugin/library Macros" link "plugmacs" 0}

@endnode
;  image_include lib start -------------------------------------------------------------------------------

@node "image_includelib" "Image_include from Thilo Köhler"

 @{"image_2shape" link "image_2shape" 0}
 
 @{"image_blit" link "image_blit" 0}                    @{"image_load" link "image_load" 0}
 @{"image_blitarea" link "image_blitarea" 0}                @{"image_loadshape" link "image_loadshape" 0} 
 @{"image_blitblock" link "image_blitblock" 0}                 
 @{"image_blitmask" link "image_blitmask" 0}                @{"image_makecookie" link "image_makecookie" 0}
 @{"image_blitpattern" link "image_blitpattern" 0}             @{"image_masktst" link "image_masktst" 0}
 @{"image_blockcookie" link "image_blockcookie" 0}             
                                @{"image_methode" link "image_methode" 0}
 @{"image_draw" link "image_draw" 0}                    @{"image_midhandle" link "image_midhandle" 0}
 @{"image_draw_scaled" link "image_draw_scaled" 0}             @{"image_mix2image" link "image_mix2image" 0}
 @{"image_draw2image" link "image_draw2image" 0}
                                @{"image_pens_init" link "image_pens_init" 0}
 @{"image_free" link "image_free" 0}                    @{"image_pens_free" link "image_pens_free" 0}
 @{"image_free_all" link "image_free_all" 0}                @{"image_prepare_all" link "image_prepare_all" 0}       
 @{"image_free_data" link "image_free_data" 0}               
                                @{"image_release" link "image_release" 0}
 @{"image_getrgb" link "image_getrgb" 0}                  @{"image_releasa_all" link "image_release_all" 0}
 @{"image_getrgb_rp" link "image_getrgb_rp" 0}               @{"image_read" link "image_read" 0}
                                
 @{"image_handle" link "image_handle" 0}                  @{"image_setdithermode" link "image_setdithermode" 0}
 @{"image_height" link "image_height" 0}                   
                                @{"image_texture2image" link "image_texture2image" 0}
 @{"image_initbmap" link "image_initbmap" 0}                
 @{"image_initmask" link "image_initmask" 0}                @{"image_width" link "image_width" 0}
 @{"image_isused" link "image_isused" 0}
@endnode

@node "image_blitblock"
                                    @{"Lib Content" link "image_includelib" 0}
 image_blitblock{x.l,y.l,x2.l,y2.l,w.l,h.l}                                                            
                                                                                                                
 Bernds wired blitblock command :-) 
@endnode

@node "image_getrgb_rp"
                                    @{"Lib Content" link "image_includelib" 0}
 image_getrgb_rp {rp.l,x.l,y.l,@scr.l}                                                                      
                                                                                                                     
 extracts the RGB value at the given coordinates from any rastport                         
                                                                                                                     
 Inputs:                                                                                                           
 - rp.l          : Rastport                                                                                      
 - x.l           : x coordinate                                                                                
 - y.l           : y coordinate                                                                               
 - scr.l         : optional screen from where to fetch the colormap
                                                                                                                    
 Result:                                                                                                          
 - rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green 
@endnode

@node "image_getrgb"
                                   @{"Lib Content" link "image_includelib" 0}
 image_getrgb {image.l,x.l,y.l}                                                                                
                                                                                                                       
 extracts the RGB value at the given coordinates                                                   
                                                                                                                       
 Inputs:                                                                                                            
 - image.l    : Number of the image "Object"                                                      
 - x.l           : x coordinate                                                                                 
 - y.l           : y coordinate                                                                                
                                                                                                                     
 Result:                                                                                                          
 - rgbvalue.l    : rgbvalue at the x/y position, e.g. $00ff00 for green 
@endnode

@node "image_masktst"
                                  @{"Lib Content" link "image_includelib" 0}
 image_masktst {image.l,x.l,y.l}                                                                             
                                                                                                                     
 Test if the given coordinated hit the transparency mask or not
                             
 NOTE: this function can be used to detect collision with the foreground                
           if you have fore and background in two different images                               
                                                                                                                    
 Inputs:                                                                                                          
 - image.l       : Number of the image "Object"                                                    
 - x.l           : x coordinate                                                                               
 - y.l           : y coordinate                                                                              
                                                                                                                   
 Result:                                                                                                         
 - succ.l        : True if the mask is set, False if it is transparent 
@endnode

@node "image_draw_scaled"
                                 @{"Lib Content" link "image_includelib" 0}
 image_draw_scaled {image.l,x.l,y.l,xs.l,ys.l,rp.l}                                                    
                                                                                                                      
 same like image_draw, but scaled to the given size xs/ys 
@endnode

@node "image_texture2image"
                                @{"Lib Content" link "image_includelib" 0}
image_texture2image {image.l,simage.l,x1.w,y1.w,x2.w,y2.w,x3.w,y3.w,x4.w,y4.wl}
                                                                                                                
 Draws simage.l into image.l to the given coordinates, textured                         
                                                                                                               
 Inputs:                                                                                                     
 - image.l : Number of the image "Object"                                                     
 - x1-x4     : x coordinates                                                                         
 - y1-y4     : y coordinates  
@endnode

@node "image_mix2image"
                             @{"Lib Content" link "image_includelib" 0} 
image_mix2image {image.l,simage.l,x.l,y.l,@xs.l,@ys.l,@sourcex.l,@sourcey.l}                   
                                                                                                                         
 Draws simage into an image at position x/y                                                            
 NOTE: there seems to be a bug, dont use this yet!                                                  
                                                                                                                         
 Inputs:                                                                                                               
 - image.l : Number of the image "Object"                                                               
 - x.l     : x Coordinate                                                                                          
 - y.l     : y Coordinate   
@endnode

@node "image_draw2image"
                                 @{"Lib Content" link "image_includelib" 0}  
 image_draw2image {image.l,simage.l,x.l,y.l,@xs.l,@ys.l,@sourcex.l,@sourcey.l}           
                                                                                                                        
 Draws simage into an image at position x/y                                                           
 NOTE: there seems to be a bug, dont use this yet!                                                 
                                                                                                                        
 Inputs:                                                                                                              
 - image.l : Number of the image "Object"                                                              
 - x.l     : x Coordinate                                                                                        
 - y.l    : y Coordinate 
@endnode

@node "image_draw"
                                 @{"Lib Content" link "image_includelib" 0}  
 image_draw {image.l,x.l,y.l,@rp.l}                                                                          
                                                                                                                         
 Same like image_blit{}, less memory is needed but it is slower.                                
 Draws an image to a specific window or rastport at coords x/y.                               
 NOTE: it is save to draw outside the window borders  
                                           
 NOTE: this command has big overhead, use image_blit{} instead 
           if you want to blit an image several times              
                                                                                                                     
 Inputs:                                                                                                           
 - image.l : Number of the image "Object"                                                           
 - x.l     : x Coordinate                                                                                     
 - y.l     : y Coordinate                                                                                    
 - rp.l    : optional a ratport where to draw, otherwise it is drawn to the used window  
@endnode

@node "image_blitarea"
                                
 image_blitarea {image.l,x.l,y.l,xs.l,ys.l,sourcex.l,sourcey.l,@rp.l}                                             
                                                                                                                         
 Blits an area of an image non-transparent using blitbitmaprastport_                           
 NOTE: Use this to restore backgounds with image.l being your background image       
 
 Inputs:                                                                                                                
 - image.l  : Number of the source image "Object"                                                    
 - x.l      : Destinaton x coordinate                                                                          
 - y.l      : Destination y coordinate                                                                         
 - xs.l     : Width of the clipped area                                                                        
 - ys.l     : Height of the clipped area                                                                      
 - sourcex.l: Source x coordinate                                                                           
 - sourcey.l: Source y coordinate                                                                          
 - rp.l     : optional a ratport where to blit, otherwise it is blitted to the used window 
@endnode

@node "image_read"
                                @{"Lib Content" link "image_includelib" 0}
 success.l = image_read {image.l,rp.l,@trgb.l,@x.l,@y.l,@xs.l,@ys.l}                                                  
                                                                                                                         
 creates an image object out of (a part of) the given Rastport                                     
                                                                                                                         
 Inputs:                                                                                                               
 - image.l    : Number of the image "Object"                                                                           
 - rp.l       : Rastport where to fetch the data from                                                                    
 - trgb.l     : rgbvalue for the desired transparent color, e.g. $ff0000 for red                                 
                set it to -1 for no transparency                                                                         
 - x.l,y.l    : optional: position from where to fetch                                                                
 - xs.l,ys.l  : optional: width and height of the area to fetch                                                   
                                                                                                                         
 Result:                                                                                                               
 - succ.l     : True if everything went well, False if it failed 
@endnode

@node "image_pens_free"
                                @{"Lib Content" link "image_includelib" 0}
 image_pens_free {}                                                                                                                                                                                                                                     
 Free the colour manager of guigfx.                                                                                  
                                                                                                                              
 NOTE: For private use only ! NEVER CALL THIS BY YOUR OWN                                 
                                                                                                                              
 Inputs:  
@endnode

@node "image_pens_init"
                                @{"Lib Content" link "image_includelib" 0}
 image_pens_init {}                                                                                         
                                                                                                                 
 Init the colour manager of guigfx.                                                                  
                                                                                                                
 NOTE: For private use only !                                                                       
                                                                                                                
 Inputs: none   
@endnode

@node "image_methode"
                                @{"Lib Content" link "image_includelib" 0}

 result.l = image_method {}                                                                                                
                                                                                                           
 see docu of guigfx (from Aminet) for methods and more features 
@endnode

@node  "image_free"
                                @{"Lib Content" link "image_includelib" 0}
 image_free {image.l}                                                                                       
                                                                                                                    
 frees a loaded image and its colour allocations on the screen                             
                                                                                                                   
 Inputs:                                                                                                         
 - image.l : Number of the image "Object" (valid range is from 0 to #max_images-1 
                look on top for the maximum    
@endnode

@node "image_free_data"
                                  @{"Lib Content" link "image_includelib" 0}
 image_free_data {image.l}                                                                                    
                                                                                                                        
 frees the image data of a loaded image but the color allocations are still present 

 NOTE: after you have called this you can not blit the image anymore   
                    
 NOTE: use this if you blit yourimage once and you want to free the memory of 
             the image but it should stay visible in the correct colours
  
 Inputs:                                                                                                       
 - image.l : Number of the image "Object" (valid range is from 0 to #max_images-1
                 look on top for the maximum           
@endnode

@node "image_free_all"
                                   @{"Lib Content" link "image_includelib" 0}

 image_free_all {}                                                                                         
                                                                                                                 
 frees all loaded images and its colour allocations on the screen                       
 it is save to call this if no image was loaded                                                  
                                                                                                                
 NOTE: you should use this when you exit your program                                 
@endnode

@node "image_load"
                                   @{"Lib Content" link "image_includelib" 0}
 success.w = image_load {image.l,filename.s}                                                                                                                            
 loads an image into RAM                                                     
 all fileformats that have a datatype installed are supported (I think) 
                                                                                              
 Inputs:                                                                                    
 - image.l    : Number of the image "Object"                                 
 - filename.s : Complete dos filename including path                     
                                                                                              
 Result:                                                                                    
 - succ.w     : True if everything went well, False if it failed            
@endnode

@node "image_initmask"
                                   @{"Lib Content" link "image_includelib" 0}
 image_initmask {image.l,trgb.l}                                                              
                                                                                                        
 Creates an 1 bit mask makeing the given rgb value transparent for use 
 with image_blitmask {}          
                                                                                                        
 Inputs:                                                                                              
 - image.l : Number of the image "Object"                                              
 - trgb.l  : rgbvalue for the desired transparent color, e.g. $ff0000 for red    
@endnode

@node "image_initbmap"
                                   @{"Lib Content" link "image_includelib" 0}
 image_initbmap {image.l}                                                                             
                                                                                                                
 Creates an OS friendly bitmap out of the given image                                    
 NOTE: for private use only !!!                                                                     
                                                                                                              
 Inputs:                                                                                                    
 - image.l : Number of the image "Object"                                                    
                                                                                                                         
@endnode

@node "image_blitmask"
                                   @{"Lib Content" link "image_includelib" 0}
 image_blitmask {image.l,x.l,y.l}                                                                                                                                                                                         
 Blits an image with a mask on the current window. The mask has to 
 be initialisized with image_initmask{} before
                                                                                             
 Inputs:                                                                                   
 - image.l : Number of the image "Object"                                   
 - x.l     : x Coordinate                                                             
 - y.l     : y Coordinate                                                            
                                                                                                                      
@endnode

@node "image_blitos"
                                   @{"Lib Content" link "image_includelib" 0}
 image_blitos {image.l,x.l,y.l}                                                       
                                                                                              
 Blits an image non-transparent using blitbitmaprastport_               
                                                                                              
 Inputs:                                                                                    
 - image.l : Number of the image "Object"                                    
 - x.l     : x Coordinate                                                              
 - y.l     : y Coordinate                                                             
@endnode

@node "image_blit"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blit {image.l,x.l,y.l}                                                                               
                                                                                                                   
  "blits" an image to a specific window at coords x/y. It is save to blit 
   outside the window borders  

 NOTE: you have to specify the used screen first with image_setscreen{} !

 NOTE: this command has big overhead, use image_burst{} instead if you 
          want to blit an image several times  
                                                            
 Inputs:                                                                                  
 - image.l : Number of the image "Object"                                  
 - x.l     : x Coordinate                                                            
 - y.l     : y Coordinate                                                            
                                                                                                                         
@endnode

@node "image_blit_rp"
                                   @{"Lib Content" link "image_includelib" 0}
 image_blit_rp {image.l,x.l,y.l,rp.l}                                                             
                                                                                                           
 same like image_blit, but uses any Rasport instead of a window                  
@endnode

@node "image_blit_scaled"
                                   @{"Lib Content" link "image_includelib" 0}
 image_blit_scaled {image.l,x.l,y.l,xs.l,ys.l}                                                     
                                                                                                               
 same like image_blit, but scaled to the given size xs/ys                                 
@endnode

@node "image_initburst"
                                   @{"Lib Content" link "image_includelib" 0}
 image_initburst {image.l}                                                                                 
                                                                                                                   
 defines window and screen and optimizes the image for blitting 
 (no need to call image_optimize{} before)
                                                                                                                   
 NOTE: this make only sense if you want to blit the image more then once
                                                  
 NOTE: this is necessary if you want to use image_burst{}                                                                                                                           
 Inputs:                                                                            
 - image.l : Number of the image "Object"                            
@endnode

@node "image_burst"
                                   @{"Lib Content" link "image_includelib" 0}
 image_burst {image.l,x.l,y.l}                                                                           
                                                                                                    
 "blits" an image to a window at coords x/y. It is save to blit outside the 
  window borders                         
                                                                                                    
 NOTE: this make only sense if you want to blit the image more then once

 NOTE: you have to call image_initburst{} or image_blit{} first !                
                                                                                                      
 Inputs:                                                                                            
 - image.l : Number of the image "Object"                                            
 - x.l     : x Coordinate                                                                      
 - y.l     : y Coordinate                                                                     
@endnode

@node "image_release"
                                   @{"Lib Content" link "image_includelib" 0}
 image_release {image.l}                                                                          
                                                                                                            
 releases the colormap allocations on the screen - use this only if your image
 is not visible any more 
 NOTE: after you have called this you have no guarrantee that your image is 
           displayed with the right colors 
 
 NOTE: on 16/24bit screens this has no visual effect, because the image allocates 
           no pens from the screens colormap      

 NOTE: before you close a screen where did some blitting you MUST call this 
           function or free the images before                                                                                                                                       
 Inputs:                                                                                                  
 - image.l : Number of the image "Object"                                                                                  
@endnode

@node "image_release_all"
                                   @{"Lib Content" link "image_includelib" 0}
 image_release_all {}                                                                                     
                                                                                                                  
 same like image_release{} but releases all blitted images                                          
@endnode

@node "image_width"
                                   @{"Lib Content" link "image_includelib" 0}
 width.l = image_width {image.l}                                                           
                                                                                                      
 gives you back the width of the specified image  

 NOTE: Never use imgaedat() variables directly as they may change in the future
                                                                                                                 
 Inputs:                                                                                                       
 - image.l : Number of the image "Object"                                                       
                                                                                                                 
 Result:                                                                                                       
 - img_width : width of the image                                                                   
@endnode

@node "image_height"
                                   @{"Lib Content" link "image_includelib" 0}
 height.l = image_height {image.l}                                                             
                                                                                                           
 gives you back the height of the specified image      
                             
 NOTE: Never use imgaedat() variables directly as they may change in the future                                                                                                                          
 Inputs:                                                                                                   
 - image.l : Number of the image "Object"                                                   
                                                                                                             
 Result:                                                                                                   
 - img_height : height of the image                                                               
@endnode

@node "image_isused"
                                   @{"Lib Content" link "image_includelib" 0}
 success.l = image_isused {image.l}                                           
                                                                                          
 gives you back if the image is loaded or not                            
                                                                                          
 Inputs:                                                                                
 - image.l : Number of the image "Object"                                
                                                                                          
 Result:                                                                               
 - True if image is loaded, otherwise False                                                              
@endnode

@node "image_setdithermode"
                                   @{"Lib Content" link "image_includelib" 0}
 image_setdithermode {image.l,dithermode.l}                                                        
                                                                                                                     
 defines the dithermode 
                                                                                          
 NOTE: this has only effect on 8bit or lower screens                                                 
                                                                                                                         
 Inputs:                                                                                                               
 - image.l       : Number of the image "Object"                                                         
 - dithermode.l  : use                                                                                           
                   - #DITHERMODE_NONE    ; no dithering (recommanded for GUI elements)
                   - #DITHERMODE_FS      ; floyd dithering                                            
                   - #DITHERMODE_RANDOM  ; slow dithering                                      
                   - #DITHERMODE_EDD     ; fast dithering                                            
@endnode

@node "image_handle"
                                   @{"Lib Content" link "image_includelib" 0}
 image_handle {image.l,x.l,y.l}                                                                         
                                                                                                                  
 Defines the handle of the image. Default is the left-top edge                             
                                                                                                                 
 Inputs:                                                                                                       
 - image.l       : Number of the image "Object"                                                 
 - x.l           : x-handle                                                                                
 - y.l           : y-handle                                                                               
@endnode

@node "image_midhandle"
                                   @{"Lib Content" link "image_includelib" 0}
 image_midhandle {image.l}                                                                            
                                                                                                                  
 Defines the handle of the image as the middle                                                 
                                                                                                                  
 Inputs:                                                                                                        
 - image.l       : Number of the image "Object"                                                  
@endnode

@node "image_blockcookie"
                                   @{"Lib Content" link "image_includelib" 0}
 image_blockcookie {shapenumber.l}                                                             
                                                                                                                
 Creates a cookie for the given shape that has no transparency                       
                                                                                                               
 Inputs:                                                                                                              
 - shapenumber.l       : Number of the shape object                                                
@endnode

@node "image_makecookie"
                                   @{"Lib Content" link "image_includelib" 0}
 image_makecookie {image.l,bshape.l,trgb.l}                                                      
                                                                                                                   
 Creates a cookie for the given shape with trgb as transparent color                     
                                                                                                                   
 Inputs:                                                                                                         
 - image.l         : Number if the image object                                                     
 - bshape.l        : Number of the shape object                                                   
 - trgb.l          : Transparent color value, e.g. $00ff00 for green                            
@endnode

@node "image_2shape"
                                   @{"Lib Content" link "image_includelib" 0}
 image_2shape {image.l,bshape.l}                                                                    
                                                                                                                   
 converts any image into a blitz2 shape object                                                  
                         *
 NOTE: don't free the image until the shape is visible somewhere on 
           the screen to keep the colours allocated       

 NOTE: the shape will be freed on exit automatically, the image NOT - 
           use always image_freeall{} at the end of your code 
                                                                                  
 Inputs:                                                                                        
 - image.l  : Number of the image "object"                                        
 - bshape.l : Number of the Blitz shape object                       
@endnode

@node "image_loadshape"
                                   @{"Lib Content" link "image_includelib" 0}
 image_loadshape {bshape.l,filename.s}                                       
                                                                                              
 replaces LoadShape with possibility to load 24bit images but looses transparency 
                                   
 NOTE: make sure to have a used screen before you call this
                                                         
 NOTE: if you cange the screen you have to load the shape again 

 NOTE: the image and the shape object share the same obj number

 NOTE: the shape will be freed on exit automatically, the image NOT - 
           use always image_freeall{} at the end of your code 
                                                                                   
 Inputs:                                                                         
 - bshape.l   : Number of the image/shape "object"            
 - filename.s : filename of the image file (can be gif, jpg, iff, bmp usw.) 
                                                                                                  
 Result:                                                                                        
 - succ.w     : True if everything went well, False if it failed                
@endnode

@node "image_blitpattern"
                                  @{"Lib Content" link "image_includelib" 0}
 image_blitpattern {image.l,x1.l,y1.l,x2.l,y2.l,@xoffset.l,@yoffset.l,@rp.l}
 
 Blits an area of an image non-transparent using blitbitmaprastport_  
 NOTE: Use this to restore backgounds with image.l being your background image

 Inputs:                                                                                        
 - image.l  : Number of the source image "Object"                        
 - x1.l     : Destination x1 coordinate                                                                 
 - y1.l     : Destination y1 coordinate                                                                
 - x2.l     : Destination x2 coordinate                                                                
 - y2.l     : Destination y2 coordinate                                                               
 - xoffset.l: x offset within the pattern                                                                
 - yoffset.l: y offset within the pattern                                                               
 - rp.l     : optional a ratport where to blit, otherwise it is blitted to the used window
@endnode 

@node "image_prepare_all"
                                @{"Lib Content" link "image_includelib" 0}
 image_prepare_all {}                                                                   

 Prepares all loaded images for fastest blitting                                 
 This is done automatically by the blit commands but takes some time 
@endnode

; image_include end -----------------------------------------------------------------------------------------------------
@node "plugmacs" "Pluginmacros"


 @{"!initasm" link "!initasm" 0}   @{"!basic" link "!basic" 0}  @{"!asm" link "!asm" 0}  @{"!exitasm" link "!exitasm" 0}
           Plugin Bsp Source

!initasm

!basic

   Basic Code

!asm

!exitasm
@endnode

@node "!screen" "!screen_"
!screen_ Screennum,title,prefsfile,mode[,Tags]
1. Opens a screenmoderequester if no prefsfile is found
2. Store the screenmode to prefsfile
3. Open a screen with screennum and Title

mode=1 (bit 0 set)       it open always the Screenmoderequester
mode=2 (bit 1 set)       it open no screen

If !screen_ called you can get info with following macros
!screen_width          return visible width
!screen_height         return visible height
!screen_depth          return depth
!screen_id             return screenmodeid
!screen_realwidth      return virtuel screenwidth
!screen_realheight     return virtuel screenheight
@endnode

@node "!initasm" "!initasm"
!initasm  Load registers d1-d7/a0-a6 from programm start
          dont use Basic Instructions.
          Must call before !basic !asm.
@endnode

@node "!basic" "!basic"
!basic    Switches to basic without look of stack Dont use interrupts.
          Can use in Statement and Reentrant Code
@endnode

@node "!basica7" "!basica7"
!basica7 Switches to basic Can call from Interrupts but Stackpos must
          be the same when you call !asma7.
          Dont use in Statements !!!!
@endnode

@node "!asm" "!asm"
!asm   Switches to asm and reloads reg d1-d7/a0-a6
       wich stored with !basic
@endnode

@node  "!asma7" "!asma7"
!asma7    switches to asm and reloads reg d1-d7/a0-a6 from stack
          wich stored with !basica7
@endnode

@node "!exitasm" "!exitasm"
!exitasm stores d0-d7/a0-a6 so on Programm Return all Regs are correct

                    Plugin Bsp Source

!initasm

!basic

   Basic Code

!asm

!exitasm

end noa7    ;stack must same position as on start so dont use it in
               for while or case instructions:end Instruction doesnt work

!newidcmp   makes a new idcmp for current WZwindow so reentrant
                  code is possible

!freenewidcmp must call before wzclosewindow to release !newidcmp Port

@endnode

;  ahi_device_easy.include lib start -------------------------------------------------------------------------------

@node "ahi_includelib" "ahi_device_easy.include from Thilo Köhler"

                    @{"Audiotest example " system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/audiotest.bb2"}

@{"ahi_bytes2samps" link "ahi_bytes2samps" 0}
@{"ahi_close" link "ahi_close" 0}
@{"ahi_createsound" link "ahi_createsound" 0}
@{"ahi_freesound" link "ahi_freesound" 0}
@{"ahi_freesound_all" link "ahi_freesound_all" 0}
@{"ahi_getsampleform" link "ahi_getsampleform" 0}

@{"ahi_loadsound" link "ahi_loadsound" 0}

@{"ahi_open" link "ahi_open" 0}

@{"ahi_playsound" link "ahi_playsound" 0}

@{"ahi_stop" link "ahi_stop" 0}

@{"ahi_setfreq" link "ahi_setfreq" 0}
@{"ahi_setpan" link "ahi_setpan" 0}
@{"ahi_setvolume" link "ahi_setvolume" 0}
@{"ahi_stream_check" link "ahi_stream_check" 0}
@{"ahi_stream_init" link "ahi_stream_init" 0}
@{"ahi_stream_isquiet" link "ahi_stream_isquiet" 0}
@{"ahi_stream_next_buffer" link "ahi_stream_next_buffer" 0}
@{"ahi_stream_next_fsize" link "ahi_stream_next_fsize" 0}
@{"ahi_stream_next_ptr" link "ahi_stream_next_ptr" 0}
@{"ahi_stream_next_size" link "ahi_stream_next_size" 0}
@{"ahi_stream_timeindex" link "ahi_stream_timeindex" 0}
@{"ahi_stream_settimeindex" link "ahi_stream_settimeindex" 0}
@{"ahi_stream_wait" link "ahi_stream_wait" 0}
@{"ahi_stream_wait_finish" link "ahi_stream_wait_finish" 0}
@{"ahi_stream_write" link "ahi_stream_write" 0}

@endnode
@node "ahi_bytes2samps"
                                    @{"Lib Content" link "ahi_includelib" 0}

 samps.l = ahi_bytes2samps {bytes.l}                                          
                                                                             
 Gives you back the number of sampleframes for the given number of bytes 
@endnode

@node "ahi_close"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_close {}                                                             
                                                               
 Closes AHI device and cleans up. It is safe to call this if AHI is not open
@endnode

@node "ahi_createsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_createsound ;(PRIVATE){snd.l,blength.l,samplerate.l,channels.l,bits.l}
 
@endnode

@node "ahi_getsampleform"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_ST.l = ahi_getsampleform {channels.w,bits.w,signed.w}     
                                                                               
 Returns the AHI sampleformat code for the given audio specs 
@endnode

@node "ahi_stream_next_buffer"
                                    @{"Lib Content" link "ahi_includelib" 0}

 nextbuffer.l = ahi_stream_next_buffer {}                  
                                                                         
 Returns the number of the audio double buffer that has to be filled next 
@endnode

@node "ahi_stream_next_ptr"
                                    @{"Lib Content" link "ahi_includelib" 0}

 nextbuffer.l = ahi_stream_next_ptr {}                            
                                                                               
 Returns the mempointer to the audio double buffer that has to be filled next
@endnode

@node "ahi_stream_next_size"
                                    @{"Lib Content" link "ahi_includelib" 0}

 bsize.l = ahi_stream_next_size {}                            

 Returns the size in bytes of the audio double buffer that has to be filled 
 next  
@endnode

@node "ahi_stream_next_fsize"
                                    @{"Lib Content" link "ahi_includelib" 0}

 bsize.l = ahi_next_fsize {}                                    

 Returns the size in sampleframes of the audio double buffer that has to be  
 filled next                              
@endnode

@node "ahi_stream_timeindex"
                                    @{"Lib Content" link "ahi_includelib" 0}

 timeindex.l = ahi_stream_timeindex {}                             
                                                                               
 Returns the number of samples that have been played yet in double buffering
 (It is not very accurate but better than nothing) 
@endnode

@node "ahi_stream_settimeindex"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_settimeindex {timeindex.l}
                                                                       
 Sets the timeindex for doublebuffering to the given value 
 This can also be done during playback                 
@endnode

@node "ahi_stream_wait"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_wait  {}       
                                  
 Waits till there is an audio double buffer ready to fill 
@endnode

@node "ahi_stream_check"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_check {}                          
                                                                     
 Only checks if there is an audio double buffer to fill and retruns "True"
 if successful                                                           
@endnode

@node "ahi_stream_wait_finish"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_wait_finish {}                        

 Waits till all running double buffers are finished 
@endnode

@node "ahi_stream_isquiet"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_isquiet {}                          
                                                                     
 Checks if something is playing or not          
@endnode

@node "ahi_stream_write"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_write {blength.l}                              
                                                                               
 Starts the next buffer to play. If there is already another buffer playing 
 this one will be queued.                                                     
 blength determines the number of bytes that should be played. Set it to -1
 if the whole buffer should be played                        
@endnode

@node "ahi_stop"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stop  {}                                                
                                                                 
 Stops all playback immediately                  
@endnode

@node "ahi_close"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_close {}                                                          
                                                                            
 Closes AHI device and cleans up. It is safe to call this if AHI is not open
@endnode

@node "ahi_open"
                                    @{"Lib Content" link "ahi_includelib" 0}

succ.w = ahi_open  {unit.l}                                          
                                                                               
 Opens the AHI device and returns "True" if successful 
@endnode

@node "ahi_stream_init"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_init {buffersize.l,channels.l,bits.l,samplerate.l} 
                                                                               
 Init the system for double buffered output stream          
 Buffersize is the size for each buffer in bytes (doublebuffering)        
 Set it zero if you dont want to use doublebuffering and only one-shot samples
 Samplerate is the samplerarte you want to use for doublebuffering playback   
 and not the samplerate the audio hardware is allocated with. 
@endnode

@node "ahi_playsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_playsound {snd.l}

 play the given soundfile
@endnode

@node "ahi_setfreq"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setfreq {snd.l,samplerate.l}
 
 set the samplerate of the given soundfile
@endnode

@node "ahi_setvolume"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setvolume {snd.l,gain.q} ; gain: 0 = mute, 1=full gain

 set the volume of the given soundfile
@endnode

@node "ahi_setpan"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setpan {snd.l,pan.q} ; pan: 0 = left, .5 = middle, 1 = right

 set the pan of the given soundfile
@endnode

@node "ahi_loadsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_loadsound {snd.l,filename.s}

 load a soundfile
@endnode

@node "ahi_freesound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_freesound {snd.l}

 free the given soundfile
@endnode

@node "ahi_freesound_all"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_freesound_all {}

 give all sounds free
@endnode

;ahi_include lib end -------------------------------------------------------------

@node "dbl_includelib" "dbl_display.include from Thilo Köhler"

                        @{" dbl_Benchmark " system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/dbl_benchmark.ab2"}

 @{"dbl_hidepointer" link "dbl_hidepointer" 0}
 @{"dbl_showpointer" link "dbl_showpointer" 0}
 @{"dbl_getpen" link "dbl_getpen" 0}
 @{"dbl_setpen" link "dbl_setpen" 0}
 @{"dbl_collision_free" link "dbl_collision_free" 0}
 @{"dbl_free" link "dbl_free" 0}
 @{"dbl_flip" link "dbl_flip" 0}
 @{"dbl_init" link "dbl_init" 0}
 @{"dbl_qblit" link "dbl_qblit"}
 @{"dbl_qprint" link "dbl_qprint"}
 @{"dbl_qrefresh" link "dbl_qrefresh"0}
 @{"dbl_bgblit" link "dbl_bgblit" 0}
 @{"dbl_bgblitpattern" link "dbl_bgblitpattern" 0}
 @{"dbl_bgscroll" link "dbl_bgscroll" 0}
 @{"dbl_bgprint" link "dbl_bgprint" 0}
 @{"dbl_unqueue" link "dbl_unqueue" 0}
 @{"dbl_collision_init" link "dbl_collision_init" 0}
 @{"dbl_hit" link "dbl_hit" 0}
 @{"dbl_2imghit" link "dbl_2imghit" 0}
 @{"dbl_imgmaskhit" link "dbl_imgmaskhit" 0}
 @{"dbl_reset" link "dbl_reset" 0}
 
@endnode

@node "dbl_hidepointer"
 @{fg shine} Funktion: dbl_hidepointer {}@{fg text}

 Syntax : dbl_hidepointer {}
                                                                                                                   
             Hide the mouse pointer on the doublebuffer display, useful for games with no mouse
                                                                                       
 NOTE :  The pointer is hidden by default.                               
                                                                                       
 Inputs : none                                                            
                                                                                  
 Result : none                                                                                                                                              
@endnode

@node "dbl_showpointer"
 @{fg shine} Funktion: dbl_showpointer {[shapenum]}@{fg text}

 Syntax : dbl_showpointer {}                                                                 
                                                                                       
             Show the mousepointer again after use of dbl_hidepointer{}    
                                                                                       
 Inputs : a shapenum if you dont want Standard pointer
                                                                                      
 Result : none                                                                      
@endnode

@node "dbl_getpen"
  @{fg shine} Funktion: dbl_getpen {}@{fg text}

Syntax : pen.l = dbl_getpen {r.l,g.l,b.l}

            Get the pen number best approximating the given rgb color for use with    
            e.g. Wline or other pen oriented commands                                           
                                                                                       
 Inputs :                                                                             
    - r.l : red component, 0..255                                      
    - g.l : green component, 0..255                                  
    - b.l : blue component, 0..255                                    
                                                                                     
 Result :                                                                             
    - pen.l : Number of the pen representing the desired color 
@endnode

@node "dbl_setpen"
  @{fg shine} Funktion: dbl_setpen {}@{fg text}

 Syntax : dbl_setpen {n.l,r.l,g.l,b.l}   
              
             Set a pen to the given rgb values  
                                                  
 Note : You should only use this if you know what you are doing because        
           it may change the color of images that are already draw on the screen           
                                                                                       
 Note : Use dbl_getpen{} as it creates new pens to get the color exactly            
           if there are free pens left.                                                    
                                                                        
 Inputs :                                                                             
   - n.l : index number pen to change
   - r.l : red component, 0..255                                                
   - g.l : green component, 0..255                                             
   - b.l : blue component, 0..255                                              
                                                                                       
 Result : none                                                    
@endnode
  
@node "dbl_collision_free"
  @{fg shine} Funktion: dbl_collision_free {}@{fg text}

 Syntax : dbl_collision_free {}                                                               
                                                                                       
             Free all resources associated with the collision bitmap.         
                                                                                     
 NOTE : For internal use only!                                                        
                                                                                       
 Inputs : none                                                                    
                                                                                      
 Result : none                                  
@endnode
  
@node "dbl_free"
 @{fg shine} Funktion: dbl_free {}@{fg text}

 Syntax : dbl_free {}                                                                         
                                                                                      
             Close the screen and free all resources assiciated with the dbl_display.include  
  
 NOTE : You MUST call this before you exit your program!       
                                                                          
 Inputs : none                                                                  
                                                                                       
 Result : none                                                    
@endnode

@node "dbl_flip"
 @{fg shine} Funktion: dbl_flip {}@{fg text}

Syntax : dbl_flip {}                                                                        
                                                                                      
            Switch the double buffer. This function is called when you have finished drawing 
            your objects.                                                                       
                                                                                      
 Inputs : none                                                                   
                                                                                      
 Result : none          
@endnode

@node "dbl_init"
  @{fg shine} Funktion: dbl_init {} @{fg text}

 Syntax : succ.l = dbl_init {screenname.s,modeid.l,scr_width.l,scr_height.l,scr_depth.l} 

             Init the double buffered display (screen). All parameters are mandatory.              
                                                                                       
 Inputs:                                                                             
 - screenname.s  : name of the screen                                                   
 - modeid.l          : 32Bit screenmode identifier                                        
 - scr_width.l       : width of screen                                                      
 - scr_height.l     : height of screen                                                     
 - scr_depth.l      : depth of screen (HiColor is depth=16, TrueColor is depth=24    
                                                                                       
 Result :                                                                            
 - succ.l : True if everthing went well, False if it fails 
@endnode

@node "dbl_qblit"
  @{fg shine} Funktion:  dbl_qblit {}@{fg text}

 Syntax : dbl_qblit {image.l,x.l,y.l}                                                           
                                                                                       
             Blit an image to the foreground and remember its position the be able                 
             to remove it again with dbl_unqueue{}.                                                
                                                                                       
 NOTE : After you blitted the image it will cause collision until it is removed         
            with dbl_unqueue{}. If you dont want it to cause collision you have            
            to check with dbl_tst{} AFTER dbl_unqueue{} and BEFORE dbl_qblit{}.       
                                                                                       
 Inputs :                                                                             
 - image.l  : image you want to blit                                                
 - x.l         : x coordinate                                                          
 - y.l         : y coordinate                                                         
                                                                                       
 Result : none                                
@endnode

@node "dbl_qrefresh"
 @{fg shine} Funktion: dbl_qrefresh {}@{fg text}

 Syntax : dbl_qrefresh {x.l,y.l,xs.l,ys.l,@db.l}                                                
                                                                                       
             Clear the given region with the background image                                      
                                                                                      
 NOTE : Use this if you made the display "dirty" with some other commands than       
            dbl_qblit{}, e.g. with WBox and tell the queue to clean it.                     
                                                                                       
 Inputs :                                                                             
 - x.l         : x coordinate                                                          
 - y.l         : y coordinate                                                         
 - xs.l        : width of the region that should be cleared                            
 - ys.l        : height of the region that should be cleared                          
 - db.l        : optional: force the buffer, can be 0 or 1                             
                                                                                       
 Result : none 
@endnode
 
@node "dbl_qprint"
 @{fg shine} Funktion: dbl_qprint {}@{fg text}
 
 dbl_qprint {text.s,x.l,y.l}                                                   
                                                                                    
 Blit an text to the foreground and remember its position the be able  
 to remove it again with dbl_unqueue{}.                                         
                                                                                       
 NOTE: After you blitted the text it will cause collision until it is removed 
       with dbl_unqueue{}. If you dont want it to cause collision you have 
       to check with dbl_hit{} AFTER dbl_unqueue{} and BEFORE dbl_qprint{}
                                                                                       
 Inputs:                                                                             
 - text.s      : text you want to blit                                         
 - x.l         : x coordinate                                                    
 - y.l         : y coordinate                                                   
 - fgpen       : (optional) foreground pen                                  
 - bgpen       : (optional) background pen, transparent if left out 
                                                                                       
 Result:     none                                                   
@endnode

@node "dbl_bgblit"
 @{fg shine} Funktion: dbl_bgblit {}@{fg text}

 dbl_bgblit {image.l,x.l,y.l,@collision.l}                                  
                                                                                      
 Blit an image permanent to the background so that it does not disappear 
 after unqueue 
 This object will cause collision if collision is True and the collision is
 initialisized.                                                                        

 Inputs:                                                                               
 - image.l     : image you want to blit                                      
 - x.l         : x coordinate                                                      
 - y.l         : y coordinate                                                     
 - collsision.l: optional, cause collision when set True or left out
                                                                                       
 Result:     none                                                     
@endnode

@node "dbl_bgblitpattern"
 @{fg shine} Funktion: dbl_bgblitpattern {}@{fg text}

 dbl_bgblitpattern {image.l,x1.l,y1.l,x2.l,y2.l,@xoffset.l,@yoffset.l,@collision.l}
                                                                                       
 Blit an image permanent to the background so that it does not disappear 
 after unqueue
 This object will cause collision if collision is True and the collision is      
 initialisized.                                                                        

 Inputs:                                                                               
 - image.l     : image you want to blit                                      
 - x.l         : x coordinate                                                      
 - y.l         : y coordinate                                                     
 - collsision.l: optional, cause collision when set True or left out
                                                                                       
 Result:     none                              
@endnode

@node "dbl_bgscroll"
 @{fg shine} Funktion: dbl_bgscroll {}@{fg text}

 dbl_bgscroll {dx.l,dy.l}                                   
                                                                   
 scroll the background                                    
                                                                   
 Inputs:                                                         
 - dx.l         : amount of pixels in x direction      
 - dy.l         : amount of pixels in y direction     
                                                                  
 Result:     none                             
@endnode

@node "dbl_bgprint"
 @{fg shine} Funktion: dbl_bgprint {}@{fg text}

 dbl_bgprint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@collision.l}
@endnode
@node "dbl_unqueue"
 @{fg shine} Funktion: dbl_unqueue {}@{fg text}

 Syntax : dbl_unqueue {}                                                                        
                                                                                       
             Remove all objects draw with dbl_qblit{}                                              
            Call this function before you are going to draw the objects on the new calculated     
            positions to remove the objects on the old positions.                                 
                                                                                       
 Inputs : none                                                                      
                                                                                       
 Result : none                                  
@endnode

@node "dbl_collision_init"
 @{fg shine} Funktion: dbl_collision_init {}@{fg text}

 Syntax : succ.l = dbl_collision_init {}                                                        
                                                                                       
             Creates a bitmap with data that should not cause collision for                        
             use with dbl_tst{} later. Usually you do it like this:                                
             Draw the objects that should NOT cause collision, then call dbl_collision_init{},    
             and then draw objects (like walls) that should cause collision.                       
                                                                                
 Inputs : none                                                                      
                                                                                       
 Result :                                                                             
 - succ.l : True if collision bitmap was successfully created 
@endnode

@node "dbl_imgmaskhit"
 @{fg shine} Funktion: dbl_imgmaskhit {}@{fg text}

 succ.l = dbl_imgmaskhit {image.l,x.l,y.l,tstx.l,tsty.l}             
                                                                                  
 Test if the image mask would hit at tstx/tsty                      
                                                                                  
 Inputs:                                                                        
 - image.l    : image object number                                 
 - x.l        : x coordinate of image                                   
 - y.l        : y coordinate of image                                  
 - tstx.l     : x coordinate of test point                              
 - tsty.l     : y coordinate of test point                             
                                                                                
 Result:                                                                      
 - succ.l    : True if collide, False if not                  
@endnode

@node "dbl_2imghit"
 @{fg shine} Funktion: dbl_2imghit {}@{fg text}

  succ.l = dbl_2imghit {image1.l,x1.l,y1.l,image2.l,x2.l,y2.l}      
                                                                                      
 Test if image1 and image2 would hit (=do a collision) at the given coos
                                                                                       
 Inputs:                                                                             
 - image1.l   : image object number                                      
 - x1.l       : x coordinate of image1                                      
 - y1.l       : y coordinate of image1                                     
 - image2.l   : image object number                                     
 - x2.l       : x coordinate of image2                                     
 - y2.l       : y coordinate of image2                                    
                                                                                      
 Result:                                                                            
 - succ.l    : True if they collide, False if not           
@endnode

@node "dbl_reset"
 @{fg shine} Funktion: dbl_reset {}@{fg text}

 Syntax :  dbl_reset {}                                                                          
                                                                                       
              Reset the double buffer display. It is a good idea to call this                       
              before you enter the gameplay loop to clear everything up.                            
                                                                                      
 Inputs : none                                                                        
                                                                                       
 Result : none                                                 
@endnode

@node "dbl_hit"
 @{fg shine} Funktion: dbl_hit {}@{fg text}
 
 succ.l = dbl_hit {x.l,y.l}                                                     
                                                                                     
 Test if there the color at the given x/y coos has changed compared to the time  
 when dbl_collision_init{}  was called (which is usualy after you have created    
 your non-collision background).                                                       
 You go like this:                                                                     
 1. Create your non-colision background with dbl_blit_bg() and dbl_setbg()
 2. Call dbl_collision_init{}                                                          
 3. Blit your walls that cause collision with dbl_blit_bg()                 
 4. Ask with dbl_hit{x,y} in the gameplay loop for collision              
                                                                                       
 If you have no walls, simply dont call dbl_collision_init()  to   
 save some memory.                                                          
                                                                                      
 Inputs:                                                                            
 - x.l       : x coordinate To check                                       
 - y.l       : y coordinate to check                                       
                                                                                     
 Result:                                                                           
 - succ.l    : True if the color has changed, False if not  
@endnode
;end dbl_display.include-------------------

