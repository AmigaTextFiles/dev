; PUPit! - PowerUnPack it! ;)

; unpacking of a PowerPacked file by James L Boyd...
; ohmygolly@hotmail.com

; FINALLY! Enforcer-hit free!

; this program will take a powerpacked file and write out an
; unpacked version of the file...

; if you've got this source on its own,you'll need
; dev/basic/PUPit.lha to make use of the function...

; (test it on the PowerPacked "BoingSpecs.asc" file provided
; in this directory)

; cut from "start" to "end" and paste near the top of your
; source code (ie before calling the function!)

; to call the function,just supply the name of your powerpacked
; file as infile$,and the name of the file you want to output
; as outfile$ :

; EXAMPLE USAGE : ( NOTE Pup{} is case-sensitive! ) :

;   byteswritten.l=Pup {"ram:text_file.pp","ram:unpacked.txt"}

; ^ this takes the file "ram:text_file.pp",attempts to unpack it,
;   then writes out the unpacked data as "ram:unpacked.txt",
;   returning the number of bytes written...

; compile and run to test the demo...

; NOTE : ppLoadData () will work on non-PowerPacked files,
;        too : it just writes the file to memory as it is...

;--start of section----------------------------------------------

; YOU MUST INCLUDE THIS SECTION BEFORE THE FUNCTION!
;     ----

; constants
; ---------

; decrunch effects

#DECR_COL0    =  0
#DECR_COL1    =  1
#DECR_POINTER =  2
#DECR_SCROLL  =  3
#DECR_NONE    =  4

; error codes

#PP_OPENERR    = -1
#PP_READERR    = -2
#PP_NOMEMORY   = -3
#PP_CRYPTED    = -4
#PP_PASSERR    = -5
#PP_UNKNOWNPP  = -6
#PP_EMPTYFILE  = -7

; file opening modes

#MODE_OLDFILE   = 1005   ;
#MODE_NEWFILE   = 1006   ; see "Blitz2:Developers/amigaincludes/dos/dos.bb2"
#MODE_READWRITE = 1004   ;

; public memory flag :

#MEMF_PUBLIC=(1LSL0) ; want to unpack to public memory (ie Fast if available)

DEFTYPE.b *bufp
DEFTYPE.l *lenp

;--end of section------------------------------------------------

Function Pup{infile$,outfile$}

ret.b=ppLoadData_(&infile$,#DECR_NONE,#MEMF_PUBLIC,&*bufp,&*lenp,-1)

; ppLoadData parameters:

;&fname$        - pointer to file name string
;#DECR_NONE     - decrunch effect
;#MEMF_PUBLIC   - type of memory to unpack into
;&*bufp         - address of pointer to unpacked data buffer
;&*lenp         - address of pointer to length of unpacked data buffer
;-1             - no custom password "hook"

;ret.b is the error code (IMPORTANT : a NEGATIVE number!)
;                                       --------

If ret=0 ; 0 means NO ERROR,ie it worked...

  *retopen.l=Open_(&outfile$,#MODE_NEWFILE) ; open a file

  If *retopen ; if file is opened OK

    retlen.l=Write_ (*retopen,*bufp,*lenp) ; write data to file

      If retlen
      Else Request "","Failed to write file","Huh?!"
      EndIf

    retclosed.l=Close_(*retopen) ; close the file

    If retclosed=False Then Request "","Error closing output file!","Weird..."
    ; note - we should really use this to make a foolproof check on whether
    ; the file was fully written...

  Else Request "","Error opening file!","Abort!"

  EndIf ; from "If *retopen"

FreeMem_ *bufp,*lenp ; free allocated memory

Else ; if error code is less than zero :

; get an error string :
Restore errors:For a.b=0 To ret Step -1:Read error$:Next a
errors:
Data$ "Success unpacking file!","Error opening requested file!"
Data$ "Error reading file!","Not enough memory!","This file's encrypted!"
Data$ "Wrong password!","Packed with unknown version of PowerPacker!"
Data$ "Empty file!"

Request "",error$,"Oh..." ; tell 'em what's wrong

EndIf ; from "If Ret=0"

Function Return retlen ; return number of bytes written to file
                       ; note this is NOT the same as the file length!
End Function

;--now for a demo------------------------------------------------

.demo

WBStartup

FindScreen 0 ; for ASLRequestFile$

MaxLen openp$=192:MaxLen openf$=192:MaxLen savep$=192:MaxLen savef$=192
openp$="RAM:":openf$="":savep$="RAM:":savef$="Unpackedfile.txt"

; hit Cancel to quit!

getafile

pp$=ASLFileRequest$("Select a PowerPacked file :",openp$,openf$)

If pp$="" Then End

up$=ASLFileRequest$("Save unpacked file as :",savep$,savef$)

If up$="" Then End

If Pup{pp$,up$}
  flen.l=Exists(up$)
  Request "","Saved "+up$+"|"+Str$(flen)+" bytes.","OK"
EndIf

Goto getafile
