;  Blitz Library Investigator3
;  By:  Tony Rolfe
;  edgewater@shoalhaven.net.au
;  Last Compiled 11 August 2000
;
;  Based almostr entirely on:

;Blitz Library Investigator2
;by Curt Esser
;camge@ix.netcom.com
;last modified MAR 25 1999

;ReqTools is required!

;NOTE!  If you compile & run this from the Blitz Editor,
;the DataList will be saved into one of your Blitz
;library drawers!  This is because if the program
;is run from Blitz it can't get it's path.
;the solution is to create an exec first and run that!

;  Tony Rolfe's modifications:
;  1.  descend into included files
;  2.  produce a cross reference of tokens to included library line numbers


WBStartup     ;let's not be crashing, now   ;)
NoCli

; for Version command:

v$="$VER: Investigator v3.00 (11-08-00) by Tony Rolfe"

; for About requester:

vs$="v3.00"+Chr$(10)+"11 August 2000"

#ScanSource = 51   ; >50 for OS 2.xx compatability
#LibsFree   = 52
#ScanAll    = 53
#SelectLibs = 54
#Panic      = 55

#InFile  = 0       ; for disk file reads
#ConWin  = 1       ; output to console window
#OutFile = 4       ; output to a disk file
#CR_File = 5       ; Chain file for cross reference
#Includes_File = 6 ; List of included files
#IncFile = 7       ; Where Included files start
IncDirectory$ = "" ; Until an INCDIR token is found

patchem.b=1   ;set to 0 to disable the number-skipping patch

Statement StringCopy{Dest.l, Source.l}
.StringCopy
;
;  Copies a null-terminated string from one address to another
;  Destination address comes first to simplify converting:
;     xxx_Name$ = yyy_Name$
;  to
;     StringCopy{&xxx\Name, &yyy_Name$}
;
      MOVEA.l  d0,a1       ; put Destination address into address register
      MOVEA.l  d1,a0       ; put Source address into address register
'lab:
      MOVE.b   (a0)+,(a1)+ ; Move one byte
      BNE      'lab        ; Repeat until null byte found
      AsmExit

End Statement
Statement MemFill{address.l, bytesize.l, value.b}
.memfill
      MOVEA.l  d0,a0       ; put address into address register
'_for1:
      MOVE.b   d2,(a0)+    ; store value at address and increase add
      SUBQ.l   #1,d1       ; decrease size of area to fill
      BNE      '_for1      ; if not zero, do next byte
      AsmExit
End Statement
Statement MemClear{address.l, longsize.l}
.memclear
      MOVEA.l  d0,a0       ; put address into address register
'_for1:
      MOVE.l   #0,(a0)+    ; store value at address and increase add
      SUBQ.l   #1,d1       ; decrease size of area to fill
      BNE      '_for1      ; if not zero, do next byte
      AsmExit
End Statement
Function.b COMPARE_STRINGS{str1.l,str2.l}
;  Case and length insensitive compare.
;  two strings are equal if they are different lengths and the
;  only difference is trailing spaces.

.compare_strings
         MOVEA.l  d0,a0
         MOVEA.l  d1,a1

         MOVE.b   #96,d2
         MOVE.b   #123,d3
         MOVE.b   #$DF,d4
         MOVE.b   #$20,d5

'fetch:  MOVE.b   (a1)+,d1   ; get second string character
         BEQ      'test1     ; second string is ended
         MOVE.b   (a0)+,d0   ; get first string character
         BEQ      'test2     ; first string is ended

         CMP.b    d0,d1      ; Check if characters are equal
         BEQ      'fetch     ; ... if so, go get the next pair

         CMP.b    d2,d0
         BLE      'noup1
         CMP.b    d3,d0
         BGE      'noup1
         AND.b    d4,d0

'noup1:  CMP.b    d2,d1
         BLE      'noup2
         CMP.b    d3,d1
         BGE      'noup2
         AND.b    d4,d1

'noup2:  CMP.b    d0,d1       ; check if letters are same
         BEQ      'fetch      ; if they are, move onto next letter
         BRA      'exit       ; if not, exit

'test1:  MOVE.b   (a0)+,d0
         BEQ      'exit       ; second string is ended
         CMP.b    d0,d5       ; Trailing space?
         BEQ      'test1      ; yes, keep going
         BRA      'exit

'test2:  CMP.b    d1,d5       ; Trailing space?
         BNE      'exit       ; yes, keep going
         MOVE.b   (a1)+,d1
         BNE      'test2

'exit:   ANDI.w   #$00FF,d0   ; make sure that top byte of word is clear
         ANDI.w   #$00FF,d1   ; make sure that top byte of word is clear
         SUB.w    d1,d0       ; get return result
         AsmExit
End Function


NEWTYPE .Chain
FirstRec.l
LastRec.l
Count.l
End NEWTYPE

NEWTYPE .IncRec
 Name.b
 Pad.b[255]
End NEWTYPE

DEFTYPE .IncRec IncRecord

NEWTYPE.ChainRec
NextRec.l
IncNo.l
LineNo.l
End NEWTYPE

DEFTYPE.ChainRec CR

Statement Get_CR{RecNo.l, RecAddr.l}

FileSeek #CR_File, RecNo * SizeOf .ChainRec
ReadMem  #CR_File, RecAddr, SizeOf .ChainRec

End Statement

Statement Put_CR{RecNo.l, RecAddr.l}

FileSeek #CR_File, RecNo * SizeOf .ChainRec
WriteMem #CR_File, RecAddr, SizeOf .ChainRec

End Statement

Statement Get_Include{RecNo.l, RecAddr.l}

FileSeek #Includes_File, RecNo * SizeOf .IncRec
ReadMem  #Includes_File, RecAddr, SizeOf .IncRec

End Statement

Statement Put_Include{RecNo.l, RecAddr.l}

FileSeek #Includes_File, RecNo * SizeOf .IncRec
WriteMem #Includes_File, RecAddr, SizeOf .IncRec

End Statement


Statement Extend_Chain{*Base.Chain, IncNo.l, LineNo.l}

SHARED Next_CR.l, CR, tok2, cmd2

If *Base\Count = 0           ; Is there a chain yet?
   *Base\FirstRec = Next_CR  ; No - Initialise Block
   *Base\LastRec  = Next_CR  ;
   *Base\Count    = 1
Else
   Get_CR{*Base\LastRec, &CR} ; Yes - read the last record
   CR\NextRec = Next_CR       ; Point at the next record
   Put_CR{*Base\LastRec, &CR} ; Rewrite last in the chain
   *Base\LastRec = Next_CR    ; Update Block pointer
   *Base\Count + 1            ; ... and count
EndIf

CR\NextRec = 0
CR\IncNo   = IncNo
CR\LineNo  = LineNo
Put_CR{Next_CR, &CR}      ; Write new last in chain
Next_CR + 1

End Statement

Dim CMDChain.Chain(255,255) ;should be plenty (255*255)
Dim CMDName$(255,255)      ; for names

Dim names$(256)

Dim inuse.w(255)  ;1 if the lib # is used

;---------------------------------------------------------------

Function.s ProgsDir{}
                        ;NOTE returns SYS: if run from Blitz!
  MaxLen path$=200
  NameFromLock_ GetProgramDir_(),&path$,200
  path$=Peek.s(&path$)

Function Return path$
End Function

;---------------------------------------------------------------

Function.s ProgsName{}
If FromCLI=-1
  *stringbuffer = AllocMem_(255, 0)
  suc.l=GetProgramName_(*stringbuffer,255)
  If suc
    pname$=Peek.s(*stringbuffer)

  EndIf
  FreeMem_ *stringbuffer,255
Else
  pname$=Peek.s(Peek.l(FindTask_(0)+$B0)+4)
EndIf
If pname$="" Then pname$="Investigator >Blitz"
Function Return pname$
End Function

;---------------------------------------------------------------

Function.b ExamineFile{FileNo.b, FileName$}
.exfile

SHARED bstep.w, blu$, lyne$, CMDChain(), IncDirectory$, nextstep.l
SHARED pbx1.w, pbx2.w, pby1.w, pbs1.w, pby2.w, totalread.l, totalbytes.l
SHARED tempdir$, Next_Include.l, IncRecord, td$

Used_Already.b = False
If td$ <> ""
   For i.l = 0 To Next_Include - 1
      Get_Include{i, &IncRecord}
      If COMPARE_STRINGS{&FileName$, &IncRecord\Name} = 0
         Used_Already = True
         i = Next_Include
      EndIf
   Next
   MemFill{&IncRecord, SizeOf .IncRec, 0}
   StringCopy{&IncRecord\Name, &FileName$}
   Put_Include{Next_Include, &IncRecord}
   ThisRecord.l = Next_Include
   Next_Include + 1
   LineNo.l    = 1
EndIf

If NOT Used_Already
   If ReadFile(FileNo, FileName$)
      FileInput FileNo
      While NOT Eof(FileNo)
         FileInput FileNo
         Repeat
            aa.w=Asc(Inkey$(1))AND $FF   ;read the next byte
            If aa = 0 Then LineNo + 1
         Until (aa > 127) OR Eof(FileNo)
         If NOT Eof(FileNo)
            bytesread.l = Loc(#IncFile)    ;update the progress bar
            If bytesread>nextstep.l
               x.f = (pbx2 - pbx1)
               x * bytesread / totalbytes
               pbs1 = pbx1 + x
               If pbs1>pbx2 Then pbs1=pbx2
               WBox pbx1,pby1,pbs1,pby2,3
               nextstep.l + bstep.w
            EndIf
            If Ticks>100
               GTToggle 0,#Panic
               Redraw 0,#Panic
               ResetTimer
            EndIf
            tok.w=aa                      ;so read the next byte too
            cmd.w=Asc(Inkey$(1))AND $FF
            If tok = $80                              ; Library zero?
               If cmd = $bf OR cmd = $12 OR cmd = $13 ; Include stuff?
                  Repeat
                     byte$ = Inkey$(1)
                  Until byte$ <> " "   ; strip out blanks
                  If byte$ = Chr$($22)  ; is it a quote?
                     a$ = ""
                     byte$ = Inkey$(1)
                     While byte$ <> Chr$($22)
                        a$ + byte$
                        byte$ = Inkey$(1)
                     Wend
                  Else
                     a$ = ""
                     Repeat
                        a$ + byte$
                        byte$ = Inkey$(1)
                     Until byte$ = " " OR byte$ = ";" OR byte$ = Chr$(0)
                     If byte$ = Chr$(0)
                        LineNo + 1
                     EndIf
                  EndIf
                  If cmd = $bf
                     IncDirectory$ = a$
                  Else
                     If ExamineFile{FileNo + 1, IncDirectory$ + a$} = False
                        CloseFile FileNo
                        Function Return False
                     EndIf
                  EndIf
               EndIf
            EndIf
            If cmd            ;and decode into a lib# and command#

               tok2.w=(tok AND 127)*2-(cmd>127)
               cmd2.w=(cmd AND 127)

   ;   -- now add the information to the list  --
               If td$ = ""
                  CMDChain(tok2,cmd2)\Count + 1
               Else
                  Extend_Chain{&CMDChain(tok2,cmd2), ThisRecord, LineNo}
               EndIf
            EndIf

   ;   -- check to see if we're cancelled  --

            WindowInput 0
            Repeat
               ev.l = Event        ;read the events que
               If ev = $40 AND GadgetHit = #Panic
                  dumpit.b=1
               EndIf
            Until ev=0
            If dumpit=1             ;user cancelled Investigation
               Pop While
               CloseFile FileNo
               WindowInput 0
               NPrint blu$," Investigation Cancelled!"
               NPrint lyne$
               If td$ <> ""
                  CloseFile #CR_File
                  CloseFile #Includes_File
               EndIf
               MemClear{&CMDChain(0,0), 256 * 256 * SizeOf .Chain / 4}
               Function Return False
            EndIf
         EndIf
      Wend

      CloseFile FileNo
   EndIf
EndIf

Function Return True

End Function

FindScreen 0  ;I think we'll need one of these  ;)

*SCR.Screen=Peek.l(Addr Screen(0))

datapath$=ProgsDir{}
ourname$=" "+ProgsName{}

If datapath$="SYS:"
  datapath$="DataList"
Else
  If Right$(datapath$,1)<>":"
    datapath$+"/"
  EndIf
  datapath$+"DataList"
EndIf


;---------------------------------------------------------------

;SetErr           ;of course, this will never be executed  ;)
;  If err
;    dummy.b=EZRequest(ourname$,"Can't Continue...","End")
;  EndIf
;  End
;End SetErr

;---------------------------------------------------------------

DecodeShapes 0,2,?gadpics     ;unpac the included gadget images

ShapesBitMap 2,0              ;LightsOut logo needs a bitmap
                              ;so we can use 3 gadget images  ;)

pastew.w=44                   ;Logo/gadget positions
pastehi.w=29

z$=Chr$(10)                   ;line break in ReqTools requesters
bpat$="(#?.bb|#?.bb2|#?.src)" ;pattern for load requester

;prlyne$="_______________________________________________"





MaxLen pa$=255    ;strings for the ASL file requesters
MaxLen fi$=255
MaxLen tpa$=255
MaxLen tfi$=255
MaxLen td$=255
MaxLen tempdir$=255

pa$="Blitz2:"     ;the default load path

                         ;for CON: window printing
clear$=Chr$(12)          ;clear the window
black$=Chr$(27)+"[31m"   ;print in black
white$=Chr$(27)+"[32m"   ;print in white
blu$=Chr$(27)+"[33m"     ;print in blue
lyne$=white$+" --------------------------------"+black$


;-- set some defaults -----------------------------------------

from$="Blitz2:"
saveto$="RAM:"
savepath$="T:"

dsrc$="Blitz2:"

err=1
tofile.b=1

; -- test strings for examining the libraries ------------------

ok$=Chr$(0)+Chr$(0)+Chr$(3)+Chr$(243)  ;$000003F3 at 1st or 4th byte
ok1$=Chr$(0)+Chr$(0)+Chr$(3)+Chr$(233) ;$000003E9 after next 20 bytes
ok2$=Chr$(0)+"Nu"+Chr$(0)              ;find next lib in acidlibs

; -- control panel window's gadgetlist -------------------------


GTButton  0,#ScanSource,  2, 22,113,21,"Investigate",#PLACETEXT_IN
GTButton  0,#LibsFree,    2, 43,113,21,"Lib #'s",#PLACETEXT_IN
GTButton  0,#ScanAll,    174,22,113,21,"Scan Libs",#PLACETEXT_IN
GTButton  0,#SelectLibs ,174,43,113,21,"Future",#PLACETEXT_IN
GTShape   0,#Panic,      122,28,$80,0,1

; -- read the screen's info to set our window positions -------

; We'll center the 2 windows horizontally and vertically

offy.b = *SCR\WBorTop + *SCR\RastPort\TxHeight +1
windx.w=(*SCR\Width-300)/2
cony.w=89+offy
conhi.w=*SCR\Height-89-offy-20

; --  open a console window for the output ---------------------

DosBuffLen 0      ;use no buffers for CON: for immediate output!

Windo$="CON:"     ;set up parameters for the console window

Windo$+Str$(windx)+"/"+Str$(cony)+"/300/"+Str$(conhi)
Windo$+"/ Confidential Report"    ;/SCREEN"+ScrName$

wind.l=OpenFile (#ConWin,Windo$)
If wind = 0
  dummy.b=EZRequest("ERROR!","Can't open console window","AAAARRRGGGGHHHH!")
  End
EndIf

; -- open the control panel as a normal window -----------------

DefaultIDCMP $40|$200
Window 0,windx,20,300,69+offy,$1000|14,"Investigator",1,2

aslx.w=windx      ;set sizes for the asl filerequesters
asly.w=20
aslw.w=300
aslh.w=conhi+69+offy

CatchDosErrs      ;show requesters on this screen

offx.b = WLeftOff ;determine locations for logo gadget
pastex.w=122+offx
pastey.w=28+offy

AttachGTList 0,0  ;add the buttons

                  ;draw the progress bar outline:

GTBevelBox 0,16+offx,5+offy,257,12,1

pbx1.w=17+offx    ;drawing locations for the progress bar
pby1.w=6+offy
pbx2.w=254+pbx1
pby2.w=9+pby1


Gosub LightsOut   ;show the "at rest" button

DosBuffLen 2048   ;we do want buffers for the disk files...

Format "000"      ;always use 3 characters for alignment


FileOutput #ConWin

Gosub readData    ;read the DataList if it's there...


;================ main program loop =================================
.mainline
Repeat
  ev.l = WaitEvent
  If EventWindow=0
    If ev = #IDCMP_GADGETUP
      Select GadgetHit
        Case #ScanSource     ;scan a tokenized source
          Gosub scanSource
          Gosub LightsOut

        Case #LibsFree       ;show free library numbers
          Gosub showNums

        Case #ScanAll        ;make a new data list
          Gosub LightsOn
          Gosub scanAll
          Gosub LightsOut
          Gosub readData

        Case #SelectLibs     ;does nothing yet
          Gosub FaceLeft
          Gosub notyet
          Gosub LightsOut

        Case #Panic          ;the Logo was hit!
          Gosub About
      End Select
    EndIf
  EndIf
Until ev=$200 AND EventWindow = 0

End

;===================== sub routines ============================

.scanSource       ;read a tokenized source

dumpit.b=0               ;reset the abort flag

Gosub FaceLeft           ;turn the abort button on

If CMDListAvailable.b  ;only if data is available!

;   -- first we need a file to investigate --

   titl$="Tokenized Source to Investigate:"
   bsource$=ASLFileRequest$ (titl$,pa$,fi$,bpat$,aslx,asly,aslw,aslh)

   totalbytes.l=Exists(bsource$)   ; How big is the file?
   If totalbytes > 0               ; If it exists
      If totalbytes < 255 Then totalbytes=255
      Gosub setBar                    ;reset the progress bar
      filename$ = bsource$
      bsource$=fi$


;   -- now, where do we save the report?   --

      tpa$=pa$             ;default is in the same directory
      tfi$=fi$+".RPT"          ;with ".RPT" tacked on

      titl$="Save report as:"
      saveto$=ASLFileRequest$(titl$,tpa$,tfi$,"#?.RPT",aslx,asly,aslw,aslh)

      rpt2disk.b=0         ;if they hit cancel, just report to window

      If saveto$<>""
         If WriteFile(#OutFile,saveto$)
            rpt2disk=1
         EndIf
      EndIf

;   -- and, where do we put temporary files?   --

      If rpt2disk = 0   ; If no report to disk,
         td$ = ""       ; ... no pint in asking for temp dir
      Else
         tempdir$ = "T:"          ;default is in the "T:" directory
         td$ = tempdir$

         titl$="Temporary file location:"
         td$=ASLPathRequest$(titl$,tempdir$,aslx,asly,aslw,aslh)
         If td$ <> ""
            CR_FileName$= tempdir$+"Investigator3.Chain"
            Includes_FileName$= tempdir$+"Investigator3.Includes"
            If OpenFile(#CR_File, CR_FileName$)
               MemFill{&CR, SizeOf .ChainRec, 0}
               Put_CR{0, &CR} ; write dummy record
               Next_CR.l = 1
               If OpenFile(#Includes_File, Includes_FileName$)
                  Next_Include.l = 0
               Else
                  dummy.b = EZRequest(ourname$,"Can't open Includes File","OK",2,0,4)
               EndIf
            Else
               dummy.b = EZRequest(ourname$,"Can't open Chain file","OK",2,0,4)
            EndIf
         EndIf
      EndIf
;   -- let 'em know we're working on it

      NPrint clear$
      NPrint blu$," Investigating:"
      NPrint white$," ",bsource$
      NPrint black$

;   -- OK, now we read the file   --
      If ExamineFile{#IncFile, filename$}
         WindowInput 0
         Gosub report   ;OK, now tell 'em what we found
      EndIf

      If td$ <> ""
         CloseFile #Includes_File
         DeleteFile_ Includes_FileName$
         CloseFile #CR_File
         DeleteFile_ CR_FileName$
      EndIf
      MemClear{&CMDChain(0,0), 256 * 256 * SizeOf .Chain / 4}
   EndIf

Else               ;NO DATALIST AVAILABLE!!!!

  rq$="No Command Data Available!"+z$
  rq$+"You must Scan Libs first..."
  dummy.b=EZRequest(ourname$,rq$,"OK",2,0,4)
EndIf

Return

;---------------------------------------------------------------

.report            ;show the results

;ResetList CMDList()   ;we just go through the whole command list
;                      ;and print out any commands that have
;                      ;been marked as being used
NPrint ""
currlib.w=0
;While NextItem(CMDList())
;  If CMDList()\timesused>0 AND CMDList()\library>1
For i = 2 To 255
   For j = 0 To 255
      If CMDChain(i,j)\Count > 0
         Format "000"

; -- if this is the first used command from a library
; -- we need to print the library name & number first

         If i <> currlib
            currlib = i
;            If currlib>1
               NPrint ""
               pr$=" -- "+names$(currlib)+" #"+Str$(currlib)
               NPrint white$,pr$,black$
               If rpt2disk
                  FileOutput #OutFile
                  NPrint pr$
                  FileOutput #ConWin
               EndIf
;            EndIf
            WBox pbx2-currlib+1,pby1,pbx2,pby2,0
         EndIf

; -- and here we print the command information

         pr$=" "+Str$(CMDChain(i,j)\Count)+" x "+CMDName$(i,j)+ " ("+UStr$(j)+")"
         NPrint blu$,pr$
         If rpt2disk
            FileOutput #OutFile
            NPrint pr$
            FileOutput #ConWin
         EndIf

; -- and the cross recerence information
         If td$ <> ""
            CR\NextRec = CMDChain(i,j)\FirstRec
            LastIncNo.l = -1
            Format "########0"
            While CR\NextRec <> 0
               Get_CR{CR\NextRec, &CR}
               If CR\IncNo <> LastIncNo
                  If LastIncNo <> -1
                     Gosub print_line_nos
                  EndIf
                  Get_Include{CR\IncNo, &IncRecord}
                  pr$ = "   "+Peek.s(&IncRecord\Name)
                  If rpt2disk
                     FileOutput #OutFile
                     NPrint pr$
                     FileOutput #ConWin
                  EndIf
                  pr$ = ""
                  Count = 0
                  LastIncNo = CR\IncNo
               EndIf
               pr$ + Str$(CR\LineNo)
               Count + 1
               If Count > 6
                  Gosub print_line_nos
               EndIf
            Wend
            If Count <> 0
               Gosub print_line_nos
            EndIf
         EndIf
      EndIf
   Next
Next
CloseFile #OutFile
NPrint lyne$
Return

.print_line_nos

If rpt2disk
   FileOutput #OutFile
   NPrint pr$
   FileOutput #ConWin
EndIf
pr$ = ""
Count = 0

Return
;---------------------------------------------------------------

.showNums            ;show all free library numbers
  If dataread.b
    tpa$="Blitz2:"
    tfi$="FreeLibNumbers.txt"
    titl$="Save Free Libs list as:"
    saveto$=ASLFileRequest$(titl$,tpa$,tfi$,"#?.txt",aslx,asly,aslw,aslh)
    If saveto$<>""
      If WriteFile(#OutFile,saveto$)
        FileOutput #OutFile
        For i=1 To 255
          If inuse(i)=0
            NPrint i
          EndIf
        Next
        CloseFile #OutFile
        FileOutput #ConWin
      EndIf
    EndIf
    NPrint clear$," "
    NPrint white$," Free library numbers:",black$
    NPrint " "
    across.b=1
    For i = 1 To 255
      If inuse(i)=0
        If across <6
          Print " ",Str$(i)," "
          across+1
        Else
          NPrint " ",Str$(i)
          across=1
        EndIf
      EndIf
    Next
    NPrint " "
    NPrint lyne$
  Else
    NPrint blu$,"You must Scan Libs first!"
    Gosub HeadShake
    Gosub LightsOut
    NPrint lyne$
  EndIf
Return
;---------------------------------------------------------------

LightsOut       ;paste the "inactive" image over the gadget

BitMaptoWindow 0,0,0,0,pastex,pastey,pastew,pastehi
Gosub BlankBar
Return

;---------------------------------------------------------------

LightsOn            ;light up the Panic button
  GTToggle 0,#Panic,Off
  Redraw 0,#Panic
Return

;---------------------------------------------------------------

FaceLeft            ;face head to left - ie, gadget pressed
  GTToggle 0,#Panic,On
  Redraw 0,#Panic
Return

;---------------------------------------------------------------

.HeadShake          ;shake head for "no"  (an error!)
  For i = 1 To 3
    Gosub FaceLeft
    VWait 15
    Gosub LightsOn
    VWait 15
  Next
Return

;---------------------------------------------------------------

.dumpCheck          ;see if the Panic button was hit
Repeat
  ev.l=Event        ;read the events que
  If ev=$40 AND GadgetHit=#Panic
    dumpit.b=1
  EndIf
Until ev=0
Return

;---------------------------------------------------------------

.setBar             ;reset the progress bar
dumpit.b=0
bstep.w = totalbytes/255  ;for the progress bar
pbs1=pbx1+1
bytesread.l=0
totalread.l=0

Return

;---------------------------------------------------------------

.FixBar             ;update the progress bar
 Repeat
   WBox pbx1,pby1,pbs1,pby2,3
   pbs1+1
   If pbs1>pbx2 Then pbs1=pbx2
   nextstep.l+bstep.w
 Until (bytesread.l+totalread.l)<nextstep.l
 If Ticks>100
   GTToggle 0,#Panic
   Redraw 0,#Panic
   ResetTimer
 EndIf

Return

;---------------------------------------------------------------
                    ;clear the progress bar
BlankBar
  WBox pbx1,pby1,pbx2,pby2,0
  nextstep=0
Return

;---------------------------------------------------------------
                    ;reverse the progress bar
BackBar
  Wline pbs1,pby1,pbs1,pby2,0
  pbs1-1
Return

;---------------------------------------------------------------

About

Gosub FaceLeft

rq$="Blitz Investigator"+z$
rq$+"by Curt Esser"+z$+z$
rq$+vs$+z$+z$
rq$+"Use this button to abort"+z$
rq$+"an operation when it is lit"

dummy.b=EZRequest(ourname$,rq$,"Got it!",2,0,4)
Gosub LightsOut
Return

;---------------------------------------------------------------

notyet

rq$="Sorry, this button"+z$
rq$+"doesn't do anything yet"

dummy.b=EZRequest(ourname$,rq$,"Got it!",2,0,4)
Return

;---------------------------------------------------------------

.scanAll                   ;read all "Blitzlibs:" files
                           ;and AcidLibs too
For i = 0 To 256
  names$(i)=""
  DeleteFile_ "T:BLIB."+UStr$(i)
Next

Dim bdir$(50)

names$(1)="Blitz2:acidlibs"
totalbytes.l = 0
sels.w=2
bdir.w=1
NPrint clear$
NPrint blu$," "
NPrint " To be read:"
NPrint white$," Acidlibs"
;ret.l = CHDir("Blitzlibs:")
;While MoreEntries
;  If EntryDir
;    bdir$(bdir)="Blitzlibs:"+EntryName$+"/"
;    NPrint bdir$(bdir)
;    bdir+1
;  EndIf
;Wend

DEFTYPE.FileInfoBlock   myfib

drawer$ = "BlitzLibs:"
lock.l = Lock_(&drawer$, #ACCESS_READ)
If lock <> 0
   If Examine_(lock,&myfib) <> 0
      While ExNext_(lock, &myfib)
         If myfib\fib_DirEntryType>=0
            bdir$(bdir)="Blitzlibs:"+Peek$(&myfib\fib_FileName)+"/"
            NPrint " "+bdir$(bdir)
            bdir+1
         EndIf
      Wend
   End If
   UnLock_ lock
End If

For i = 1 To bdir-1
   lock.l = Lock_(&bdir$(i), #ACCESS_READ)
   If lock <> 0
      If Examine_(lock,&myfib) <> 0
         While ExNext_(lock, &myfib)
            If myfib\fib_DirEntryType<0
               names$(sels)=bdir$(i)+Peek$(&myfib\fib_FileName)
               totalbytes.l+myfib\fib_Size
               sels+1
            EndIf
         Wend
      End If
      UnLock_ lock
   End If
;   CHDir bdir$(i)
;   While MoreEntries
;      names$(sels)=bdir$(i)+EntryName$
;      totalbytes.l+Exists(names$(sels))
;      sels+1
;   Wend
Next

totalbytes+Exists(names$(1))   ;acidlibs
VWait 60
Gosub ScanLibs
Gosub masterlist
CHDir "Blitz2:"
Return

;---------------------------------------------------------------

.readData         ;read the DataList file from our directory
                  ;into the command list
For i = 1 To 256
  names$(i)=""
Next
error$="Ready for an Investigation!"
temp$=datapath$
totalbytes=Exists(temp$)
dataread.b=0
If totalbytes
   CMDListAvailable = 1
   If ReadFile(#InFile,temp$)
;     ClearList CMDList()
;     ResetList CMDList()
;     For i = 2 To 255
;       inuse(i)=0               ;clear the lib in use array
;     Next
      MemClear{&inuse(0), 256 * 2 / 4}
      inuse(0)=1        ;0 & 1 are the compiler's libs
      inuse(1)=1        ;so they are always in use!
      FileInput #InFile
      While NOT Eof(#InFile)
         temp$=Edit$(255)
         If Left$(temp$,1)=";"    ;it's the lib # and name
            num$=Mid$(temp$,3,3)   ;read the number
            If Left$(num$,2)="00"Then num$=Right$(num$,1)
            If Left$(num$,1)="0" Then num$=Right$(num$,2)
            currnumb.w=Val(num$)
            inuse(currnumb)=1
            temp$=Mid$(temp$,7)    ;the lib name
            names$(currnumb)=temp$
            curcmd.w=1
         Else
            If Left$(temp$,1)="!"  ; It's a patch line
               CMDChain(currnumb,curcmd)\Count=0
               curcmd + 1
            Else                   ; Add command data
;        If AddItem (CMDList())
;          CMDList()\library=currnumb
;          CMDList()\command=curcmd
               CMDChain(currnumb,curcmd)\Count=0
               CMDName$(currnumb,curcmd)=temp$
               curcmd+1
;        EndIf
            EndIf
         EndIf
      Wend
      CloseFile #InFile
      PopInput
      dataread.b=1
   Else
      error$="Can't access Data File!"
   EndIf
Else
   error$="No Data Available"
EndIf

NPrint lyne$
NPrint blu$," ",error$
NPrint lyne$
NPrint ""
fi$=""
Return

;---------------------------------------------------------------

.masterlist      ;create a new DataList

If dumpit.b=0
  BitMaptoWindow 0,0,0,0,pastex,pastey,pastew,pastehi
  If WriteFile (#OutFile,datapath$)
    NPrint lyne$
    NPrint blu$," Creating Data List",black$
    FileOutput #OutFile
    For i = 2 To 255
     fil$="T:Blib."+UStr$(i)
     If Exists (fil$)
       If OpenFile (#InFile,fil$)
         FileInput #InFile
         temp$="; "+Str$(i)+" "+Edit$(255)
         NPrint temp$
         While NOT Eof(#InFile)
           temp$=Edit$(255)
           NPrint temp$
         Wend
         CloseFile #InFile
         KillFile fil$
       EndIf
     EndIf
     Gosub BackBar
    Next
    CloseFile #OutFile
    FileOutput #ConWin
  Else
    NPrint lyne$
    NPrint blu$,"ERROR!  Can't create data file!"
    NPrint lyne$
  EndIf
Else
  NPrint lyne$
  NPrint blu$," ---      SCAN  ABORTED     --- "
  NPrint " -- Can't create Data List! ---"
  NPrint lyne$
EndIf
FlushEvents
Return

;---------------------------------------------------------------

.ScanLibs

Gosub setBar
sels=1
lib$=names$(sels)
While lib$<>"" AND dumpit=0      ;OK, read 'em all...
  totalread.l+bytesread.l
  For i = Len(lib$) To 1 Step-1  ;pull out the file name
    check$=Mid$(lib$,i,1)
    If check$="/" OR check$=":"
      source$=Mid$(lib$,i+1)
      path$=Left$(lib$,i)
      i=1
    EndIf
  Next
  ;EndIf
  source$=UCase$(source$)
  If source$="DEFLIBS" OR source$="ACIDLIBS" Then biglib=1

  If ReadFile(0,lib$)   ;make sure it's a Blitz library!
    FileInput 0
    check$=Inkey$(4)
    If check$=ok$
       notBlitz=0
    Else
      check$=Inkey$(4)
      If check$= ok$ Then notBlitz=0
    EndIf
    If notBlitz=0
      check$=Inkey$(20)
      check$=Inkey$(4)
      If check$<>ok1$ Then notBlitz=1
    EndIf

    If notBlitz
      NPrint lyne$
      NPrint white$,source$,z$,blu$,"is not a Blitz library!"
      NPrint lyne$
      Gosub HeadShake
      totalread.l+Exists(lib$)
      Gosub FixBar
    Else
      check$=Inkey$(4)   ;throw away the next 4 bytes
      a$=Inkey$(1)
      If a$="p"          ;ah, a standard Blitz lib
        syslib.b=0
      Else               ;no, must be an Amigalib
        syslib=1
      EndIf
    ; -- ok, now get the library number ------------------------

      Select syslib       ;system libraries are a bit different...

        Case 0            ;a Blitz style library (maybe deflibs or acidlibs)
          FileSeek 0,28
          While NOT Eof(0) AND dumpit=0
              a.b=Asc(Inkey$(1))
              bytesread.l=Loc(0)
              If bytesread+totalread.l>nextstep.l Then Gosub FixBar
              If a=$70
                a$=(Inkey$(4))
                If a$=ok2$
                  a=Asc(Inkey$(1))
                  If a<>0
                    libnum.w=a AND $FF
                    If libnum>1
                      If source$="ACIDLIBS"

                        ;acidlibs patch

                        If libnum=39 Then libnum=114
                        If libnum=40 Then libnum=158
                      EndIf
                      Gosub ReadEm
                    EndIf
                  EndIf
                EndIf
              EndIf
            If dumpit=0
              Gosub dumpCheck
              If dumpit=1
                Pop While:Pop Select
                Goto dumped
              EndIf
            EndIf
          Wend

        Case 1            ;for system libs
          FileSeek 0,37
          a.b=Asc(Inkey$(1))
          libnum.w= a AND $FF
          NPrint blu$," #",libnum," ",black$,source$
          Gosub SysRead
      End Select

    EndIf
    dumped
    CloseFile 0
    PopInput
  EndIf
  If dumpit=0
    Gosub dumpCheck
  EndIf
  If dumpit
    lib$=""
  Else
    sels+1
    lib$=names$(sels)
  EndIf

  ;If lib$<>"" AND printer=0 Then VWait 100
Wend

Return

;---------------------------------------------------------------

.hiddencheck   ;look for a non-command tokenizing $
               ;must be printable chars, ending with chr$(0)
temp$=""
If (b.w>64 AND b<91)  ;first letter will be uppercase
  c.w=b
  Repeat
    temp$+Chr$(c)
    c=Asc(Inkey$(1))
  Until c<32 OR c>122
  If c=0
    Repeat        ;chuck the "help" stuff
      b.w=Asc(Inkey$(1))
    Until b<32 OR b>122
    If b=255
      FileSeek #InFile,(Loc(#InFile)-1)
    EndIf
  EndIf
  If c<>0 OR Len(temp$)<3
    temp$=""
    If c=255
      FileSeek #InFile,(Loc(#InFile)-1)
    EndIf
  EndIf
EndIf
Return

;---------------------------------------------------------------

.firstcheck
If firstcmd.b=0      ;first command found!
  NPrint blu$," #",libnum,black$," ",source$
  ;NPrint " "
  If tofile        ;this bit saves to disk file
    Format ""
    outpath$=savepath$+"Blib."+Str$(libnum)
    Format "000"
    If Exists(outpath$)
       ret = ReadFile(#OutFile,outpath$)
       FileInput #OutFile      ; Yes, I know it sounds stupid
       NPrint white$, "#",libnum," already used for ", Edit$(255)
       CloseFile #OutFile
       FileInput 0
    EndIf

    If OpenFile(#OutFile,outpath$)=0
      tofile=0
      dummy.b= EZRequest (ourname$,"can't open output file!","OK")
    Else
      FileOutput #OutFile
      NPrint source$
      FileOutput #ConWin
    EndIf
  EndIf
  firstcmd=1
EndIf
Return

;---------------------------------------------------------------

.ReadEm        ;read the command names
               ;look for $FFFF0000 000000 00


done.b=0
firstcmd.b=0
cmdnum.w=0
Repeat
  b.w=Asc(Inkey$(1))
  bytesread.l=Loc(0)
  If bytesread+totalread.l>nextstep.l Then Gosub FixBar
  If b=255
    b.w=Asc(Inkey$(1))
    If b=255                 ;aha, two $FF's !
      For i = 1 To 6         ;now the 6 $00's ?
        b=Asc(Inkey$(1))
        If b<>0 Then done=1  ;nope, must be the end of the command list!
      Next
      If done = 0
        gotall.b=0
        cmd$=""
        a$=Inkey$(1)
        If a$ = Chr$(0) OR a$="3"   ;another $00?
          done=1
        Else
          Gosub firstcheck
          If a$>Chr$(35)
            cmd$+a$
          EndIf
        EndIf
        If done=0       ;here we read the actual command string
          cmdnum+1
          Repeat
            a$=Inkey$(1)
            If a$>Chr$(35) AND a$<Chr$(126)
              cmd$+a$
            Else
              gotall=1
            EndIf
          Until gotall
          If patchem
            temp$=cmd$
            Gosub patchcheck
            cmd$=temp$
          EndIf
          Gosub printcmd
          Repeat        ;chuck the "help" stuff
            b.w=Asc(Inkey$(1))
          Until b=0 OR b=255
          If b=255
            FileSeek #InFile,(Loc(#InFile)-1)
          EndIf
        EndIf
      EndIf
    EndIf
  Else
    Gosub hiddencheck
    If temp$<>""  ;hidden token found!
      cmd$=temp$
      Gosub firstcheck
      Gosub printcmd
    EndIf
  EndIf
Until done
CloseFile 4

Return

;---------------------------------------------------------------

.patchcheck   ;patches to correct wrong command number bug
              ;simply pads the DataList where needed

Select libnum
  Case 47     ;RIMisc skips # 1~3
    If cmdnum=1
      For ptch.b=1 To 3
        Gosub printpatch
      Next
    EndIf

  Case 60
    If cmdnum=38
      ptch=38
      Gosub printpatch
    EndIf

  Case 73
    If cmdnum=2
      ptch = 2
      Gosub printpatch
    EndIf

  Case 75
    If cmdnum=24
      ptch = 24
      Gosub printpatch
    EndIf
  Case 100
    If cmdnum=2
      ptch = 2
      Gosub printpatch
    EndIf

  Case 104
    If cmdnum=1
      For ptch = 1 To 2
        Gosub printpatch
      Next
    EndIf

  Case 124
    If cmdnum=9
      ptch = 9
      Gosub printpatch
    EndIf
    If cmdnum=15
      ptch=15
      Gosub printpatch
    EndIf

  Case 132
    If cmdnum=16
      ptch = 16
      Gosub printpatch
    EndIf

  Case 136
    If cmdnum=9
      ptch = 9
      Gosub printpatch
    EndIf

  Case 140
    If cmdnum=12
      For ptch = 12 To 13
        Gosub printpatch
      Next
    EndIf
    If cmdnum=15
      ptch = 15
      Gosub printpatch
    EndIf

  Case 142
    If cmdnum=8
      ptch = 8
      Gosub printpatch
    EndIf

  Case 150
    If cmdnum=7
      ptch = 7
      Gosub printpatch
    EndIf

  Case 154
    If cmdnum=14
      ptch = 14
      Gosub printpatch
    EndIf

  Case 160
    If cmdnum =4
      ptch=4
      Gosub printpatch
    EndIf

  Case 161
    If cmdnum=1
      For ptch = 1 To 3
        Gosub printpatch
      Next
    EndIf

  Case 164
    If cmdnum=3
      For ptch = 3 To 9
        Gosub printpatch
      Next
    EndIf

  Case 192
    If cmdnum=1
      ptch = 1
      Gosub printpatch
    EndIf

End Select
Return

;---------------------------------------------------------------

.printpatch
cmd$="! (Patch "+Str$(ptch)+")"
Gosub printcmd
cmdnum+1
Return

;---------------------------------------------------------------

SysRead     ;read a system library

; look for  $FF0000 000000 00
;     or    $FF0000 000000 0000  in amigalibs!

cmdnum=0
done=0
If tofile        ;save to disk
  Format ""
  If OpenFile(#OutFile,savepath$+"Blib."+Str$(libnum))=0
    tofile=0
    dummy.b= EZRequest (ourname$,"can't open output file!","OK")
  Else
    FileOutput #OutFile
    NPrint source$
    FileOutput #ConWin
  EndIf
  Format "000"
EndIf

Repeat
  b.w=Asc(Inkey$(1))
  bytesread.l=Loc(0)
  If bytesread+totalread.l>nextstep.l Then Gosub FixBar
  If b=255              ;now look for 6 or 7 0's
    b.w=Asc(Inkey$(1))
    If b=255            ;in system libs, $FFFF means end of command list
      b=Asc(Inkey$(1))
      If b=0
        done=1
      EndIf
    Else
      If b=0            ;OK, now check for at least 6 $00's
        gonext.b=0
        For i = 1 To 5
          b=Asc(Inkey$(1))
          If b<>0 Then gonext.b=1
        Next
        If gonext=0
          gotall.b=0
          cmdnum+1
          cmd$=""
          a$=Inkey$(1)
          If a$ = Chr$(0)  ;sometimes there is one more $00
            a$=Inkey$(1)
          EndIf
          cmd$+a$          ;now we read the command string
          Repeat
            a$=Inkey$(1)
            If a$>Chr$(35) AND a$<Chr$(126) ;alphabetic character?
              cmd$+a$
            Else
              gotall=1
            EndIf
          Until gotall
          If tofile
            FileOutput #OutFile   ;to the disk file
            NPrint cmd$
            FileOutput #ConWin   ;back to the console
          Else
            NPrint " ",Str$(cmdnum)," ",cmd$
          EndIf
        EndIf
      EndIf
    EndIf
  EndIf
Until done
CloseFile #OutFile
Return

;---------------------------------------------------------------
.printcmd    ;  prints the coomand string To the File

If tofile
  If cmd$<>""
    FileOutput #OutFile
    NPrint cmd$
    FileOutput #ConWin
  EndIf
Else
  NPrint " ",Str$(cmdnum.w),"  ",cmd$
EndIf

Return

;------------- Here is where the gadget images are attached ----

Even
gadpics
IncBin "gad.shps"


