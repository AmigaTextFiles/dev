@database Usermacros_ger.guide
@$VER: Usermacros.guide deutsch 1.1
@Author Thilo Köhler (englisch)
@Remark Übersetzt und ergänzt von Marco Möring (Blackbird) July 2004 

@node "Main" "Includes und Macros"
                                     @{"Library Index" link "Blitz2:REDHelp/REDBlitzLibs/REDBlitzLibs.GUIDE/LIBRARYLIST"}

 @{"ahi_device_easy.include" link "ahi_includelib" 0}  Befehle für AHI. Abspielen und Streaming

 @{"dbl_display.include" link "dbl_includelib" 0}   Befehle für DoppelPufferBildschirm

 @{"eclock.include" link "eclock.includelib" 0}   Ersetzt die alten Timer-Befehle

 @{"image_include" link "image_includelib" 0}   Befehle für Bilder, anzeigen, scalieren usw...

 @{"vvblank_include" link "vvblank_includelib" 0}  Ersetzt das alte VWait-Kommando

 @{"rawkey_include" link "rawkey_include" 0}  Befehle für Tastaturabfrage

 @{"!screen_" link "!screen_" 0}   Screenmoderequester und Bildschirm

 @{"!version" link "!version" 0}  Fügt einen Versionsstring hinzu (Beachten sie die OS3.9 Anmerkung ! )

 @{"Plugin/library Macros" link "plugmacs" 0} ASM

 @{"Optimize" link "optimize" 0}

 @{"Syntax" link "Syntax" 0}

@endnode

@node "Optimize"

optimize 0 ist aus

optimize 1 optimimiert Integer  Bit0

optimize 2 nutzt die FPU        Bit1

optimize 3 Integer+fpu

optimize 4 New syntax Mode (wird immer gebraucht für Thilos Includes) Bit2

Im newsyntax Mode gibts variable Parameter : bei asm labels kann man
weglassen,genauso {} bei Macros
@endnode

@node "Syntax"

Syntax 0 alte Syntax ohne declare Prüfung

Syntax 1 alle vars müssen vorher mit deftype definiert werden (wie bei C)

Syntax 2 man kann variablen auch mit a.typ= definieren

Syntax 4 Es wird Typprüfung durchgeführt.Wenn ein longwort in ein Word
         geladen werden soll gibts Fehlermeldung.
         Ist man sicher das man keinen Fehler gemacht hat kann man ein @
         davor setzen,dann wird keine Fehlermeldung ausgegeben.

         a.w=b.l bringt Fehler

         @a.w=b.l ist ok

         Ist dann wie der CAST bei C

         a=(short)b

@endnode



;  eclock.include lib start -------------------------------------------------------------------------------

@node "eclock.includelib" "eclock.include von Thilo Köhler"

                            @{"Timerfunktion Beispiel" system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/eclock_test.ab2"}

 eclock sollte benutzt werden um die alten Befehle "Timer" und "ResetTimer" 
 zu ersetzen die auf MOS/OS4 oder auf 68 Amigas die FACTS oder sonst ein 
 derartiges Uhrentool benutzen nicht funktionieren.

 @{"eclock_start" link "eclock_start" 0}

 @{"eclock_stop" link "eclock_stop" 0}
@endnode

@node "eclock_start"
                                    @{"Lib Content" link "eclock.includelib" 0}

 eclock_start {[@scaler]}

 Setzt den E-Clock-Zähler auf 0. Der optionale scaler Parameter gibt an
 wieviele Einheiten der Zähler pro Sekunde hochzählt. Wenn ticks nicht
 angegeben ist, wird 10000 ticks pro Sekunde gezählt.
@endnode

@node "eclock_stop"
                                    @{"Lib Content" link "eclock.includelib" 0}

 val.l=eclock_stop{}

 Liest den E-Clock-Zähler aus, es muss allerdings zuvor eclock_start
 ausgeführt worden sein.

 Beispiel1:
 eclock_start{1000}
 delay_(50)    ; 1 Sekunde warten
 val.l=eclock_stop{}

 ************ val hat nun den Wert 1000

 delay_(50)   ; 1 Sekunde warten
 val.l=eclock_stop{}

 ************val hat nun den Wert 2000

 Beispiel2:
 eclock_start(50)
 delay_(50)    ;1 Sekunde warten
 val.l=eclock_stop{}

 ************val hat nun den Wert 50p[8]
@endnode

;  image_include lib start -------------------------------------------------------------------------------

@node "image_includelib" "Image_include von Thilo Köhler"
                                                 
                            @{"Bildertest Beispiel" system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/imageexample.ab2"}

 @{"image_2shape" link "image_2shape" 0}
 
 @{"image_blit" link "image_blit" 0}                    @{"image_load" link "image_load" 0}
 @{"image_blitarea" link "image_blitarea" 0}                @{"image_loadshape" link "image_loadshape" 0} 
 @{"image_blitblock" link "image_blitblock" 0}                 
 @{"image_blitmask" link "image_blitmask" 0}                @{"image_makecookie" link "image_makecookie" 0}
 @{"image_blitmask_scaled" link "image_blitmask_scaled" 0}
 @{"image_blitpattern" link "image_blitpattern" 0}             @{"image_masktst" link "image_masktst" 0}
 @{"image_blockcookie" link "image_blockcookie" 0}             
                                @{"image_method" link "image_method" 0}
 @{"image_draw" link "image_draw" 0}                    @{"image_midhandle" link "image_midhandle" 0}
 @{"image_draw_scaled" link "image_draw_scaled" 0}             @{"image_mix2image" link "image_mix2image" 0}
 @{"image_draw2image" link "image_draw2image" 0}
                                @{"image_pens_init" link "image_pens_init" 0}
 @{"image_find" link "image_find" 0}
 @{"image_free" link "image_free" 0}                    @{"image_pens_free" link "image_pens_free" 0}
 @{"image_free_all" link "image_free_all" 0}                @{"image_prepare_all" link "image_prepare_all" 0}       
 @{"image_free_data" link "image_free_data" 0}               
                        
 @{"image_get" link "image_get" 0}                     @{"image_release" link "image_release" 0}
 @{"image_get_rp" link "image_get_rp" 0}
 @{"image_getrgb" link "image_getrgb" 0}                  @{"image_releasa_all" link "image_release_all" 0}
 @{"image_getrgb_rp" link "image_getrgb_rp" 0}        
                                
 @{"image_handle" link "image_handle" 0}                  @{"image_setdithermode" link "image_setdithermode" 0}
 @{"image_height" link "image_height" 0}                   
                                @{"image_texture2image" link "image_texture2image" 0}
 @{"image_initbmap" link "image_initbmap" 0}                
 @{"image_initmask" link "image_initmask" 0}                @{"image_width" link "image_width" 0}
 @{"image_isused" link "image_isused" 0}
@endnode

@node "image_blitblock"
                                    @{"Lib Content" link "image_includelib" 0}

 image_blitblock{x.l,y.l,x2.l,y2.l,w.l,h.l}                                                            
                                                                                                                
 Kopiert Daten vom benutzten (used window) Fenster von Position x2/y2
 und Grösse w.l/h.l auf den aktuellen (used Screen) Bildschirm auf Position x /y

 Eingaben:
 -x.l       : 
 -y.l       :
 -x2.l     :
 -y2.l     :
 -w.l      :
 -h.l      :

 Ergebnis:
 -keine
@endnode

@node "image_blitmask_scaled"
                                    @{"Lib Content" link "image_includelib" 0}

 image_blitmask_scaled {image.l,x.l,y.l,xs.l,ys.l,@rp.l}
  
 Gleicher Befehl wie image_blitmask, skaliert aber zu der angegebenen Größe xs/ys 

 Anmerkung:
 Dieses Statement ist nicht sehr schnell !

 Eingaben:
 -image.l   : Nummer des Bildobjektes
 -x.l          : x Koordinate
 -y.l          : y Koordinate
 -xs.l        : xs Koordinate
 -ys.l        : ys Koordinate
 -rp.l        : (optional) ein Rastport in den geblittet wird.

Ergebnis:
 -keine
@endnode

@node "image_find"
                                    @{"Lib Content" link "image_includelib" 0}

 image.l = image_find {}
                                    
 Findet eine freie Objektummer

 Anmerkung:
 Wenn sie Bilder dynamisch laden und anzeigen ist dieser Befehl sehr nützlich,
 soll bedeuten das nicht vorhersehbar ist wieviele Bilder verwendet werden sollen.
                                                                                                          
 Eingaben:
 -keine                                                                                             
                                                                                                                        
 Ergebnis:                                                                                                            
 - image.l  : Objektnumber eines freien Bildes, fertig zum laden durch image data 
@endnode

@node "image_get"
                                    @{"Lib Content" link "image_includelib" 0}

 success.l = image_get {image.l,src_image.l,@x.l,@y.l,@xs.l,@ys.l,@trgb.l,@tolerance}

 erzeugt ein Bildobjekt aus einem anderen Bild (oder aus einem Teil davon).
                           
 Eingaben:                                                                         
 - image.l        : Nummer des neuen Bildobjekts     
 - src_image.l : Nummer des source Bildobjekts
 - x.l,y.l           : optional: Position an anderer Stelle übernehmen                                                
 - xs.l,ys.l        : optional: Breite und Höhe des Bereiches übernehmen                                  
 - trgb.l           : RGBwert für die gewünschte Transparenzfarbe, z.B. $ff0000 für Rot.     
                         -1 für keine Tranzparenz setzen.                                                             
 - tolerance.l  : für das finden der Transparenz, Vorgabe ist 1  
               
 Ergebnis:                                                                                                             
 - succ.l          : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn es fehlschlägt.
@endnode

@node "image_get_rp"
                                    @{"Lib Content" link "image_includelib" 0}

 success.l = image_get_rp {image.l,rp.l,@x.l,@y.l,@xs.l,@ys.l,@trgb.l}
                                                                                                            
 erstellt ein Bildobjekt aus einem (oder einem Teil) des angegebenen Rastport        
                                                                                                           
 Eingaben:                                                                                                                
 - image.l    : Nummer des Bildobjektes                                                        
 - rp.l       : Rastport aus dem die Daten geholt werden sollen                                            
 - trgb.l           : RGBwert für die gewünschte Transparenzfarbe, z.B. $ff0000 für Rot.     
                         -1 für keine Tranzparenz setzen.                                                                                                                 
 - x.l,y.l    : optional: Position von der Daten geholt werden sollen                                               
 - xs.l,ys.l  : optional: Breite und Höhe des Bereiches                                
                                                                                                            
 Ergebnis:                                                                                                
 - succ.l     : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn es fehlschlägt.

@endnode

@node "image_getrgb_rp"
                                    @{"Lib Content" link "image_includelib" 0}

 image_getrgb_rp {rp.l,x.l,y.l,@scr.l}                                                                      
                                                                                                                     
 extrahiert die RGBwerte aus den angegebenen Koordinaten von jedem 
 gewünschten Rastport.                         
                                                                                                                     
 Eingaben:                                                                                                           
 - rp.l    : Rastport                                                                                      
 - x.l      : x Koordinate                                                                                
 - y.l      : y Koordinate                                                                               
 - scr.l   : (optional) ein Bildschirm von dem die Colormap geholt wird.
                                                                                                                    
 Ergebnis:                                                                                                          
 - rgbvalue.l    : RGBwert aus der x/y Position, z.B. $00ff00 für Grün. 
@endnode

@node "image_getrgb"
                                   @{"Lib Content" link "image_includelib" 0}

 image_getrgb {image.l,x.l,y.l}                                                                                
                                                                                                                       
 extrahiert die RGBwerte aus den angegebenen Koordinaten                                              
                                                                                                                       
 Eingaben:                                                                                                            
 - image.l    : Nummer des Bildobjektes.                                                      
 - x.l           : x Koordinate                                                                                 
 - y.l           : y Koordinate                                                                                
                                                                                                                     
 Ergebnis:                                                                                                          
 - rgbvalue.l    : RGBwert aus der x/y Position, z.B. $00ff00 für Grün.
@endnode

@node "image_masktst"
                                  @{"Lib Content" link "image_includelib" 0}

 image_masktst {image.l,x.l,y.l}                                                                             
                                                                                                                     
 Testet ob die angegebenen Koordinaten mit der Tranzparenzmaske kollidieren oder nicht.
                             
 Anmerkung: 
 Diese Funktion kann benutzt werden um zu prüfen ob eine Kollision mit dem Vordergrund entstanden ist,                
 wenn sie Vorder-und Hintergrund in zwei verschiedenen Bildern verwenden.                               
                                                                                                                    
 Eingaben:                                                                                                          
 - image.l   : Nummer des Bildobjektes.                                                    
 - x.l           : x Koordinate                                                                               
 - y.l           : y Koordinate                                                                              
                                                                                                                   
 Ergebnis:                                                                                                         
 - succ.l     : "Wahr" (True) wenn die Maske berührt wird , "Falsch" (False) wenn transparent 
@endnode

@node "image_draw_scaled"
                                 @{"Lib Content" link "image_includelib" 0}

 image_draw_scaled {image.l,x.l,y.l,xs.l,ys.l,rp.l}                                                    
                                                                                                                      
 Gleicher Befehl wie image_draw, skaliert aber zu der angegebenen Größe xs/ys 
@endnode

@node "image_texture2image"
                                @{"Lib Content" link "image_includelib" 0}

image_texture2image {image.l,simage.l,x1.w,y1.w,x2.w,y2.w,x3.w,y3.w,x4.w,y4.wl}
                                                                                                                
 Zeichnet simage.l zu image.l texturiert an den angegebenen Koordinaten.                         
                                                                                                               
 Eingaben:                                                                                                     
 - image.l    : Nummer des Bildobjektes.                                                     
 - x1-x4     : x Koordinate                                                                         
 - y1-y4     : y Koordinate  
@endnode

@node "image_mix2image"
                             @{"Lib Content" link "image_includelib" 0} 

image_mix2image {image.l,simage.l,x.l,y.l,@xs.l,@ys.l,@sourcex.l,@sourcey.l}                   
                                                                                                                         
 Zeichnet simage.l in ein Bild an die gegebenen Position x/y  
                                                          
 Anmerkung: 
 hier ist scheinbar noch ein Fehler enthalten, bitte noch nicht benutzen!                                                  
                                                                                                                         
 Eingaben:                                                                                                               
 - image.l  : Nummer des Bildobjekts                                                               
 - x.l         : x Koordinate                                                                                          
 - y.l         : y Koordinate   
@endnode

@node "image_draw2image"
                                 @{"Lib Content" link "image_includelib" 0} 
 
 image_draw2image {image.l,simage.l,x.l,y.l,@xs.l,@ys.l,@sourcex.l,@sourcey.l}           
                                                                                                                        
 Zeichnet simage.l in ein Bild an die gegebenen Position x/y 
                                                           
 Anmerkung: 
 hier ist scheinbar noch ein Fehler enthalten, bitte noch nicht benutzen!                                                  
                                                                                                                         
 Eingaben:                                                                                                               
 - image.l  : Nummer des Bildobjekts                                                               
 - x.l         : x Koordinate                                                                                          
 - y.l         : y Koordinate                                              
@endnode

@node "image_draw"
                                 @{"Lib Content" link "image_includelib" 0} 
 
 image_draw {image.l,x.l,y.l,@rp.l}                                                                          
                                                                                                                         
 Gleicher Befehl wie image_blit{}, weniger Speicherbedarf wenn nötig, aber langsamer.                                
 Zeichnet ein Bild in ein ausgewähltes Fenster oder Rastport  an den Koordinaten x/y.
                               
 Anmerkung: 
 es ist sicher auch ausserhalb des Fensters zu zeichnen.  
                                           
 Anmerkung2: 
 Dieses Kommando erzeugt viel overhead, benutzen sie stattdesen image_blit{}
 wenn sie ein Bild  zu verschiedenen Zeiten blitten wollen.              
                                                                                                                     
 Eingaben:                                                                                                           
 - x.l     : x Koordinate                                                                                     
 - y.l     : y Koordinate                                                                                    
@endnode

@node "image_blitarea"
                                
 image_blitarea {image.l,x.l,y.l,xs.l,ys.l,sourcex.l,sourcey.l,@rp.l}                                             
                                                                                                                         
 Blittet einen Bereich eines Bildes nicht-transparent, nutzt blitbitmaprastport_
                           
 Anmerkung:
 Benutzen sie diesen Befehl zum wiederherstellen des Hintergrundes mit image.l       
 
 Eingaben:                                                                                                                
 - image.l     : Nummer des Bildobjektes                                                     
 - x.l            : Zielkoordinate x                                                                           
 - y.l            : Zielkoordinate y                                                                          
 - xs.l           : Breite des Ausschnittes                                                                        
 - ys.l           : Höhe des Aussschnittes                                                                      
 - sourcex.l : Grundkoordinate x                                                                            
 - sourcey.l : Grundkoordinate y                                                                         
 - rp.l            : (optional) ein Rastport zum zeichnen, oder es wird in das benutzte Fenster gezeichnet. 
@endnode

@node "image_read"
                                @{"Lib Content" link "image_includelib" 0}

 success.l = image_read {image.l,rp.l,@trgb.l,@x.l,@y.l,@xs.l,@ys.l}                                                  
                                                                                                                         
 Erstellt ein Bildobjekt aus dem gewählten Rastport (oder ein Teil davon)                                     
                                                                                                                         
  Eingaben:                                                                                                                
 - image.l  : Nummer des Bildobjektes                                                                                                                
 -rp.l         : Rastport von dem die Daten geholt werden                                                                    
 - trgb.l    : RGBwert für die gewünschte Transparenzfarbe, z.B. $ff0000 für Rot.     
                   -1 für keine Tranzparenz setzen.                                                                                                                                   
 - x.l,y.l     : (optional) Position an anderer Stelle übernehmen                                                
 - xs.l,ys.l  : (optional) Breite und Höhe des Bereiches übernehmen                                                   
                                                                                                                         
 Ergebnis:                                                                                                               
  - succ.l   : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn etwas schief ging. 
@endnode

@node "image_pens_free"
                                @{"Lib Content" link "image_includelib" 0}
 image_pens_free {} 
                                                                                                                                                                                                                                    
 Leert den Farbmanger der GuiGfx.                                                                                  
                                                                                                                              
 Anmerkung: 
 nur zur privaten Nutzung ! NIE SELBST AUFRUFEN                                  
@endnode

@node "image_pens_init"
                                @{"Lib Content" link "image_includelib" 0}

 image_pens_init {}                                                                                         
                                                                                                                 
 Initiiert den Farbmanger der GuiGfx.                                                                  
                                                                                                                
 Anmerkung: 
 nur zur privaten Nutzung !                                                                       
                                                                                                                
 Eingaben: 
 -keine   
@endnode

@node "image_methode"
                                @{"Lib Content" link "image_includelib" 0}

 result.l = image_method {}                                                                                                
                                                                                                           
 siehe hierzu die Dokumentation der guigfx (aus dem Aminet) für Methoden und mehr
 Möglichkeiten. 
@endnode

@node  "image_free"
                                @{"Lib Content" link "image_includelib" 0}

 image_free {image.l}                                                                                       
                                                                                                                    
 löscht ein geladenes Bild und die Farbzuteilung auf dem Bildschirm.                             
                                                                                                                   
 Eingaben:                                                                                                         
 - image.l : Nummer des Bildobjektes (gültige Bereiche sind von 0 to #max_images-1 
@endnode

@node "image_free_data"
                                  @{"Lib Content" link "image_includelib" 0}

 image_free_data {image.l}                                                                                    
                                                                                                                        
 löscht die Bilderdaten eines geladenen Bildes aber die Farbzuteilung bleibt erhalten 

 Anmerkung: 
 Nach diesem Aufruf  kann das Bild nicht mehr geblittet werden.   
                    
 Anmerkung2: 
 benutzen sie diesen Befehl wenn sie ihr Bild einmal blitten möchten und ihren Speicherbedarf  
 wieder herstellen möchten, das Bild aber in den korrekten Farben dargestellt bleiben soll.
  
 Eingaben:                                                                                                       
 - image.l : Nummer des Bildobjektes (gültige Bereiche sind von 0 to #max_images-1            
@endnode

@node "image_free_all"
                                   @{"Lib Content" link "image_includelib" 0}

 image_free_all {}                                                                                         
                                                                                                                 
 löscht alle geladenen Bilder und die Farbzuteilung auf dem Bildschirm.                       
 es ist sicherer diesen Befehl aufzurufen wenn kein Bild geladen wurde.                                                 
                                                                                                                
 Anmerkung: 
 Sie sollten diesen Befehl benutzen wenn sie ihr Programm verlassen                                 
@endnode

@node "image_load"
                                   @{"Lib Content" link "image_includelib" 0}

 success.w = image_load {image.l,filename.s}  
                                                                                                                          
 Läd ein Bild ins Ram. Es werden alle Dateiformate die durch einen Datatype 
 zur Verfügung stehen unterstützt.
                                                                                          
 Eingaben:                                                                                    
 - image.l      : Nummer des Bildobjektes                                 
 - filename.s : Kompleter Dos-Dateiname inclusive Pfad                     
                                                                                              
  Ergebnis:                                                                                                               
  - succ.l       : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn etwas schief ging. 
@endnode

@node "image_initmask"
                                   @{"Lib Content" link "image_includelib" 0}

 image_initmask {image.l,trgb.l}                                                              
                                                                                                        
 Erstellt eine 1 bit Maske und macht den RGBwert transparent zur benutzung 
 mit image_blitmask {}          
                                                                                                        
 Eingaben:                                                                                              
 - image.l : Nummer des Bildobjektes                                              
 - trgb.l   : RGBwert für die gewünschte Transparenzfarbe, z.B. $ff0000 für Rot.     
@endnode

@node "image_initbmap"
                                   @{"Lib Content" link "image_includelib" 0}

 image_initbmap {image.l}                                                                             
                                                                                                                
 Erstellt eine OS-konforme Bitmap aus dem angegebenen Bild.
                                    
 Anmerkung: 
 nur zur privaten Nutzung !!!                                                                     
                                                                                                              
 Eingaben:                                                                                                    
 - image.l : Nummer des Bildobjektes                                                    
@endnode

@node "image_blitmask"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blitmask {image.l,x.l,y.l}  
                                                                                                                                                                                       
 Blittet ein Bild mit einer Maske auf das ausgewählten Fenster. Die Maske ist  
 zuerst mit image_initmask{} zu initzialisieren.
                                                                                             
 Eingaben:                                                                                   
 - image.l : Nummer des Bildobjektes                                   
 - x.l        : x Koordinate                                                             
 - y.l        : y Koordinate                                                            
@endnode

@node "image_blitos"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blitos {image.l,x.l,y.l}                                                       
                                                                                              
 Blittet ein Bild ohne Transparenz durch blitbitmaprastport_               
                                                                                              
 Eingaben:                                                                                    
 - image.l : Nummer des Bildobjektes                                    
 - x.l        : x Koordinate                                                              
 - y.l        : y Koordinate                                                             
@endnode

@node "image_blit"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blit {image.l,x.l,y.l}                                                                               
                                                                                                                   
 Blittet ein Bild zu den angegebenen Koordinaten x/y in das Fenster. 
 Es ist sicher um auch ausserhalb des Fensters zu blitten.  

 Anmerkung: 
 Bitte zuerst den Bildschirm spezifizieren mit image_setscreen{} !

 Anmerkung2: 
 Dieses Kommando hat viel overhead, benutzen sie stattdesen 
 image_burst{} wenn sie ihr Bild öfter blitten wollen.  
                                                            
 Eingaben:                                                                                  
 - image.l : Nummer des Bildobjektes                                  
 - x.l        : x Koordinate                                                            
 - y.l        : y Koordinate                                                            
                                                                                                                         
@endnode

@node "image_blit_rp"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blit_rp {image.l,x.l,y.l,rp.l}                                                             
                                                                                                           
 Gleicher Befehl wie image_blit, benutzt aber den Rasport statt eines Fensters.                  
@endnode

@node "image_blit_scaled"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blit_scaled {image.l,x.l,y.l,xs.l,ys.l}                                                     
                                                                                                               
 Gleicher Befehl wie image_blit, skaliert aber zu der angegebenen xs/ys Größe                                
@endnode

@node "image_initburst"
                                   @{"Lib Content" link "image_includelib" 0}

 image_initburst {image.l}                                                                                 
                                                                                                                   
 Definiert Fenster und Bildschirm und optimiert das Bild zum blitten 
 (sie brauchen image_optimize{} davor nicht aufrufen)
                                                                                                                   
 Anmerkung: 
 Dies macht nur Sinn wenn sie das Bild öfter blitten wollen.
                                                  
 Anmerkung2: 
 dies ist notwendig wenn sie image_burst{} verwenden wollen.
                                                                                                                           
 Eingaben:                                                                            
 - image.l : Nummer des Bildobjektes                            
@endnode

@node "image_burst"
                                   @{"Lib Content" link "image_includelib" 0}

 image_burst {image.l,x.l,y.l}                                                                           
                                                                                                    
 Blittet ein Bild zu den angegebenen Koordinaten  x/y in das Fenster. 
 Es ist sicher um auch ausserhalb des Fensters zu blitten   
                                                                                                    
 Anmerkung: 
 Dies macht nur Sinn wenn sie das Bild öfter blitten wollen.

 Anmerkung2: 
 Bitte image_initburst{} oder image_blit{} zuerst aufrufen !                
                                                                                                      
 Eingaben:                                                                                            
 - image.l : Nummer des Bildobjektes                                            
 - x.l        : x Koordinate                                                                      
 - y.l        : y Koordinate                                                                     
@endnode

@node "image_release"
                                   @{"Lib Content" link "image_includelib" 0}

 image_release {image.l}                                                                          
                                                                                                            
 Löscht die Farbzuteilung auf dem Bildschirm.  
 Benutzen sie diese Funktion nur wenn ihr Bild nicht mehr sichtbar ist. 

 Anmerkung: 
 Nachdem sie diesen Befehl aufgerufen haben, haben sie keine Garantie
 das ihr Bild in der richtigen Farbe dargestellt wird.
 
 Anmerkung2: 
 Auf einem 16/24bit Bildschirm hat das keinen Effekt,weil das Bild keine Stifte
 aus der Farbzuteilung des Bildschirms benutzt.
 
 Anmerkung3: 
 Bevor sie den Bildschirm schließen auf dem sie blitten, müßen sie diese
 Funktion aufrufen oder die Bilder davor löschen.  
                                                                                                                                     
 Eingaben:                                                                                                  
 - image.l : Nummer des Bildobjektes                                                                                 
@endnode

@node "image_release_all"
                                   @{"Lib Content" link "image_includelib" 0}

 image_release_all {}                                                                                     
                                                                                                                  
 Gleicher Befehl wie image_release{} löscht aber alle geblitteten Bilder.                                          
@endnode

@node "image_width"
                                   @{"Lib Content" link "image_includelib" 0}

 width.l = image_width {image.l}                                                           
                                                                                                      
 Gibt die Breite eines ausgewählten Bildes aus.  

 Anmerkung: 
 Bitte nie imagedat() variablen direkt verwenden, das wird in zukunft vieleicht geändert.
                                                                                                                 
 Eingaben:                                                                                                  
 - image.l : Nummer des Bildobjektes                                                                                                         
                                                                                                            
 Ergebnis:                                                                                                       
 - img_width : Breite des Bildes                                                                   
@endnode

@node "image_height"
                                   @{"Lib Content" link "image_includelib" 0}

 height.l = image_height {image.l}                                                             
                                                                                                           
 Gibt die Höhe eines ausgewählten Bildes aus.  

 Anmerkung: 
 Bitte nie imagedat() variablen direkt verwenden, das wird in zukunft vieleicht geändert.
                                                                                                                 
 Eingaben:                                                                                                  
 - image.l : Nummer des Bildobjektes                                                                                                         
                                                                                                            
 Ergebnis:                                                                                                       
 - img_width : Höhe des Bildes                                                                   
@endnode

@node "image_isused"
                                   @{"Lib Content" link "image_includelib" 0}

 success.l = image_isused {image.l}                                           
                                                                                          
 Gibt zurück ob das Bild geladen worden ist oder nicht.                           
                                                                                          
 Eingaben:                                                                                
 - image.l : Nummer des Bildobjektes                               
                                                                                          
 Ergebnis:                                                                               
 - "Wahr" (True) wenn das Bild geladen wurde, ansonsten "Falsch" (False)                                                              
@endnode

@node "image_setdithermode"
                                   @{"Lib Content" link "image_includelib" 0}

 image_setdithermode {image.l,dithermode.l}                                                        
                                                                                                                     
 Definiert den Dithermode. 
                                                                                          
 Anmerkung: 
 Dieser Befehl hat nur auf einem 8bit (oder geringer) Bildschirm Sinn.                                                 
                                                                                                                         
 Eingaben:                                                                                                               
 - image.l       : Nummer des Bildobjektes                                                         
 - dithermode.l  : benutzt                                                                                           
                   - #DITHERMODE_NONE      ; kein Dithering (für GUI elemente)
                   - #DITHERMODE_FS           ; Floyd-Steinberg Dithering                                            
                   - #DITHERMODE_RANDOM ; langsames Dithering (genaues)                                     
                   - #DITHERMODE_EDD         ; schnelles Dithering (ungenau)                                           
@endnode

@node "image_handle"
                                   @{"Lib Content" link "image_includelib" 0}

 image_handle {image.l,x.l,y.l}                                                                         
                                                                                                                  
 Definiert den Umgang (handle) des Bildes. Vorgabe ist die linke-obere-Ecke.                             
                                                                                                                 
 Inputs:                                                                                                       
 - image.l    : Nummer des Bildobjektes                                                 
 - x.l           : x-handle                                                                                
 - y.l           : y-handle                                                                               
@endnode

@node "image_midhandle"
                                   @{"Lib Content" link "image_includelib" 0}

 image_midhandle {image.l}                                                                            
                                                                                                                  
 Definiert den Umgang (handle) des Bildes von der Mitte.                                                 
                                                                                                                  
 Eingaben:                                                                                                        
 - image.l       : Nummer des Bildobjektes                                                  
@endnode

@node "image_blockcookie"
                                   @{"Lib Content" link "image_includelib" 0}

 image_blockcookie {shapenumber.l}                                                             
                                                                                                                
 Erstellt ein cookie für das angegebene Shape das keine Transparenz hat.                      
                                                                                                               
 Eingaben:                                                                                                              
 - shapenumber.l  : Nummer des Shapeobjektes                                                
@endnode

@node "image_makecookie"
                                   @{"Lib Content" link "image_includelib" 0}

 image_makecookie {image.l,bshape.l,trgb.l}                                                      
                                                                                                                   
 Erstellt ein cookie für das angegebene Shape mit der angegebenen Farbtranzparenz.                     
                                                                                                                   
 Eingaben:                                                                                                         
 - image.l    : Nummer des Bildobjektes                                                     
 - bshape.l  : Nummer des Shapeobjektes                                                   
 - trgb.l       : Transparenzfarbe,z.B. $00ff00 für grün                            
@endnode

@node "image_2shape"
                                   @{"Lib Content" link "image_includelib" 0}

 image_2shape {image.l,bshape.l}                                                                    
                                                                                                                   
 Konvertiert jedes Bild in ein Blitz2 Shapeobjekt.                                                  
                         
 Anmerkung:
 löschen sie nicht das Bild bevor das Shape sichtbar auf dem Bildschirm ist 
 damit die Farben übergeben werden können.       

 Anmerkung2: 
 Das Shape wird automatisch freigegeben, das Bild nicht - 
 benutzen sie immer image_freeall{} beim beenden ihres Programmes. 
                                                                                  
 Eingaben:                                                                                        
 - image.l   : Nummerdes Bildobjektes                                        
 - bshape.l : Nummer des  Blitz2 Shapeobjektes                       
@endnode

@node "image_loadshape"
                                   @{"Lib Content" link "image_includelib" 0}

 image_loadshape {bshape.l,filename.s}                                       
                                                                                              
 Erstezt den Befehl LoadShape mit der Erweiterung nun auch 24bit Bilder zu laden,
 das Bild verliert dabei aber die Transparenz. 
                                   
 Anmerkung: 
 Stellen sie sicher das sie einen aktiven Bildschirm haben bevor sie diesen Befehl ausführen.
                                                         
 Anmerkung2: 
 Wenn sie den Bildschirm wechseln, müßen sie das Shape erneut laden. 

 Anmerkung3: 
 Das Bild und das Shapeobjekt teilen sich die gleiche Objektnummer.

 Anmerkung4:
 Das Shape wird automatisch freigegeben, das Bild nicht - 
 benutzen sie immer image_freeall{} beim beenden ihres Programmes. 
                                                                                    
 Eingaben:                                                                         
 - bshape.l    : Nummer des Bild und Shapeobjektes            
 - filename.s : Dateiname des Bildes (Format kann sein: gif, jpg, iff, bmp usw.) 
                                                                                                  
 Ergebnis:                                                                                                               
  - succ.l       : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn etwas schief ging.               
@endnode

@node "image_blitpattern"
                                  @{"Lib Content" link "image_includelib" 0}

 image_blitpattern {image.l,x1.l,y1.l,x2.l,y2.l,@xoffset.l,@yoffset.l,@rp.l}
 
 Blittet einen Bereich eines nicht-tranzparenten Bildes unter verwendung von blitbitmaprastport_
  
 Anmerkung: 
 benutzen sie diesen Befehl zum wiederherstellen des Hintergrundes mit image.l 

 Eingaben:                                                                                        
 - image.l     : Nummer des source Bildobjektes                        
 - x1.l          : Ziel x1 Koordinate                                                                 
 - y1.l          : Ziel y1 Koordinate                                                                
 - x2.l          : Ziel x2 Koordinate                                                                
 - y2.l          : Ziel y2 Koordinate                                                               
 - xoffset.l  : x offset innerhalb des pattern                                                                
 - yoffset.l  : y offset innerhalb des pattern                                                               
 - rp.l          : (optional) ein Rastport zum blitten, ansonsten wird in das benutzte Fenster geblittet
@endnode 

@node "image_prepare_all"
                                @{"Lib Content" link "image_includelib" 0}

 image_prepare_all {}                                                                   

 Bereitet alle geladenen Bilden für schnellstes blitten vor.                                 
 Dies geschieht automatisch mit den Blitkommandos, benötigt aber etwas Zeit.
@endnode

; image_include end -----------------------------------------------------------------------------------------------------
@node "plugmacs" "Pluginmacros"


 @{"!initasm" link "!initasm" 0}   @{"!basic" link "!basic" 0}  @{"!asm" link "!asm" 0}  @{"!exitasm" link "!exitasm" 0}
           Plugin Bsp Source

!initasm

!basic

   Basic Code

!asm

!exitasm
@endnode

@node "!initasm" "!initasm"
!initasm  Läd die Register d1-d7/a0-a6 vom Programmstart
          benutzen sie keine Basicinstruktionen.
          diesen Befehl müßen sie vor !basic und !asm aufrufen.
@endnode

@node "!basic" "!basic"
!basic    Schaltet zurück zu basic ohne auf den Stack zu  schauen. 
             benutzen sie keine Interrupts.

             Kann in Statement und Reentrant Code benutzt werden
@endnode

@node "!basica7" "!basica7"
!basica7  Schaltet zurück zu basic. Kann aufgerufen werden aus Interrupts,
               aber die Stackpos muß die selbe sein wenn sie !asma7 aufrufen.

               Nicht in Statements benutzen!!!!
@endnode

@node "!asm" "!asm"
!asm   Schaltet zu asm zurück, und läd die Register d1-d7/a0-a6
          wieder wo sie mit !basic gespeichert wurden.
@endnode

@node  "!asma7" "!asma7"
!asma7    Schaltet zu asm zurück, und läd die Register d1-d7/a0-a6 wieder 
               vom stack wo sie mit !basica7 gespeichert wurden.
@endnode

@node "!exitasm" "!exitasm"
!exitasm  speichert die register d0-d7/a0-a6 so im Programm, und gibt alle
               Register wieder korrekt wieder

                    Plugin Beispiel Source

!initasm

!basic

   Basic Code

!asm

!exitasm

!basica7    ;stack muß die gleiche Position haben wie beim start.
                  Nicht benutzen für while oder case Instruktionen :end Instruktionen arbeiten nicht

!newidcmp   Macht ein neues idcmp für das aktuelle WZFenster.  reentrant
                    code ist möglich

!freenewidcmp muß vor wzclosewindow aufgerufen werden um !newidcmp Port freizugeben

@endnode

;  ahi_device_easy.include lib start -------------------------------------------------------------------------------

@node "ahi_includelib" "ahi_device_easy.include von Thilo Köhler"

                    @{"Audiotest Beispiel" system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/audiotest.bb2"}

                    @{"TKPlayer Beispiel" system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/TKPlayer009.bb2"}

@{"ahi_bytes2samps" link "ahi_bytes2samps" 0}
@{"ahi_close" link "ahi_close" 0}
@{"ahi_createsound" link "ahi_createsound" 0}
@{"ahi_freesound" link "ahi_freesound" 0}
@{"ahi_freesound_all" link "ahi_freesound_all" 0}
@{"ahi_getsampleform" link "ahi_getsampleform" 0}

@{"ahi_loadsound" link "ahi_loadsound" 0}

@{"ahi_open" link "ahi_open" 0}

@{"ahi_playsound" link "ahi_playsound" 0}

@{"ahi_stop" link "ahi_stop" 0}

@{"ahi_setfreq" link "ahi_setfreq" 0}
@{"ahi_setpan" link "ahi_setpan" 0}
@{"ahi_setvolume" link "ahi_setvolume" 0}
@{"ahi_stream_check" link "ahi_stream_check" 0}
@{"ahi_stream_init" link "ahi_stream_init" 0}
@{"ahi_stream_isquiet" link "ahi_stream_isquiet" 0}
@{"ahi_stream_next_buffer" link "ahi_stream_next_buffer" 0}
@{"ahi_stream_next_fsize" link "ahi_stream_next_fsize" 0}
@{"ahi_stream_next_ptr" link "ahi_stream_next_ptr" 0}
@{"ahi_stream_next_size" link "ahi_stream_next_size" 0}
@{"ahi_stream_timeindex" link "ahi_stream_timeindex" 0}
@{"ahi_stream_settimeindex" link "ahi_stream_settimeindex" 0}
@{"ahi_stream_wait" link "ahi_stream_wait" 0}
@{"ahi_stream_wait_finish" link "ahi_stream_wait_finish" 0}
@{"ahi_stream_write" link "ahi_stream_write" 0}

@endnode
@node "ahi_bytes2samps"
                                    @{"Lib Content" link "ahi_includelib" 0}

 samps.l = ahi_bytes2samps {bytes.l}                                          
                                                                             
 Gibt die Nummer des Sampleframes für die angegebene Nummer der Bytes zurück. 
@endnode

@node "ahi_createsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_createsound ;(PRIVATE){snd.l,blength.l,samplerate.l,channels.l,bits.l}
 
@endnode

@node "ahi_getsampleform"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_ST.l = ahi_getsampleform {channels.w,bits.w,signed.w}     
                                                                               
 Gibt den AHI sampleformat code für die angegebenen Audiospecs zurück. 
@endnode

@node "ahi_stream_next_buffer"
                                    @{"Lib Content" link "ahi_includelib" 0}

 nextbuffer.l = ahi_stream_next_buffer {}                  
                                                                         
 Gibt die Nummer des Audio Doppelpuffer zurück, das als nächstes gefüllt werden soll. 
@endnode

@node "ahi_stream_next_ptr"
                                    @{"Lib Content" link "ahi_includelib" 0}

 nextbuffer.l = ahi_stream_next_ptr {}                            
                                                                               
 Gibt den Speicherzeiger zum Audio Doppelpuffer zurück, das als nächstes gefüllt werden soll.
@endnode

@node "ahi_stream_next_size"
                                    @{"Lib Content" link "ahi_includelib" 0}

 bsize.l = ahi_stream_next_size {}                            

 Gibt die Größe in Bytes des Audio Doppelpuffer zurück, das als nächstes gefüllt werden soll. 
@endnode

@node "ahi_stream_next_fsize"
                                    @{"Lib Content" link "ahi_includelib" 0}

 bsize.l = ahi_next_fsize {}                                    

 Gibt die Größe in Sampleframes des Audio Doppelpuffer zurück, das als nächstes gefüllt werden soll.                              
@endnode

@node "ahi_stream_timeindex"
                                    @{"Lib Content" link "ahi_includelib" 0}

 timeindex.l = ahi_stream_timeindex {}                             
                                                                               
 Gibt die Nummer der Samples zurück die gerade im Doppelpuffer gespielt wurden.
 (Das ist nicht sehr akurat, aber besser als nichts) 
@endnode

@node "ahi_stream_settimeindex"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_settimeindex {timeindex.l}
                                                                       
 Setzt den Zeitindex für Doppelpuffering zu dem angegebenen Wert 
 das kann auch während des abspielens getan werden.                 
@endnode

@node "ahi_stream_wait"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_wait  {}       
                                  
 Wartet bis ein Audio Doppelpuffer frei zum füllen ist.
@endnode

@node "ahi_stream_check"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_check {}                          
                                                                     
 Checkt nur ob ein Audio Doppelpuffer zu füllen ist, und gibt "Wahr" (True) zurück
 wenn erfolgreich                                                           
@endnode

@node "ahi_stream_wait_finish"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stream_wait_finish {}                        

 Wartet bis alle laufenden Doppelpuffer fertig sind.
@endnode

@node "ahi_stream_isquiet"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_isquiet {}                          
                                                                     
 Checkt ob etwas gespielt wird oder nicht          
@endnode

@node "ahi_stream_write"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_write {blength.l}                              
                                                                               
 Startet den nächsten Puffer zum abspielen. Spielt bereits ein anderer Puffer 
 wird auf diesen gewartet.
                                                     
 blenght bestimmt die Nummer der Bytes die abgespielt werden sollen. 
 Setzen sie -1 wenn der gewählte Puffer abgespielt werden soll.                       
@endnode

@node "ahi_stop"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_stop  {}                                                
                                                                 
 Stopt das Abspielen.                  
@endnode

@node "ahi_close"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_close {}                                                          
                                                                            
 Schließt das AHI device. Sie können diesen befehl auch verwenden 
 wenn AHI nicht geöffnet wurde.
@endnode

@node "ahi_open"
                                    @{"Lib Content" link "ahi_includelib" 0}

succ.w = ahi_open  {unit.l}                                          
                                                                               
 Öffnet das AHI device und gibt "Wahr" (True) aus wenn erfolgreich. 
@endnode

@node "ahi_stream_init"
                                    @{"Lib Content" link "ahi_includelib" 0}

 succ.w = ahi_stream_init {buffersize.l,channels.l,bits.l,samplerate.l} 
                                                                               
 Initiert das System für Doppelgepufferten Ausgabestream.          
 Puffergröße ist die Größe für jden Puffer in Bytes (doublebuffering)
        
 Setzen sie "0"  wenn sie Doppelpuffer nicht wünschen und nur ein Samples haben.

 Samplerate ist die Samplerart die sie verwenden wollen für das doppelgepufferte Abspielen   
 und nicht die Samplerart die der Audiohardware zugeteilt wurde. 
@endnode

@node "ahi_playsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_playsound {snd.l}

 spielt die angegebene Sounddaten ab.
@endnode

@node "ahi_setfreq"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setfreq {snd.l,samplerate.l}
 
 setzt die Samplerate der angegebenen Sounddatei.
@endnode

@node "ahi_setvolume"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setvolume {snd.l,gain.q} ; gain: 0 = mute, 1=full gain

 setzt die Lautstärke der angegebenen Sounddatei.
@endnode

@node "ahi_setpan"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_setpan {snd.l,pan.q} ; pan: 0 = links, .5 = mittig, 1 = rechts

 setzt den pan der angegebenen Sounddatei.
@endnode

@node "ahi_loadsound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_loadsound {snd.l,filename.s}

 läd eine Sounddatei.
@endnode

@node "ahi_freesound"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_freesound {snd.l}

 Gibt die angegebene Sounddatei frei
@endnode

@node "ahi_freesound_all"
                                    @{"Lib Content" link "ahi_includelib" 0}

 ahi_freesound_all {}

 Gibt alle Sounddateien frei.
@endnode

;ahi_include lib end -------------------------------------------------------------

; dbl_include lib start ----------------------------------------------------------
@node "dbl_includelib" "dbl_display.include von Thilo Köhler"

                        @{" dbl_Benchmark " system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/dbl_benchmark.ab2"}

 @{"dbl_hidepointer" link "dbl_hidepointer" 0}
 @{"dbl_showpointer" link "dbl_showpointer" 0}
 @{"dbl_getpen" link "dbl_getpen" 0}
 @{"dbl_setpen" link "dbl_setpen" 0}
 @{"dbl_collision_free" link "dbl_collision_free" 0}
 @{"dbl_free" link "dbl_free" 0}
 @{"dbl_flip" link "dbl_flip" 0}
 @{"dbl_init" link "dbl_init" 0}
 @{"dbl_qblit" link "dbl_qblit"}
 @{"dbl_qprint" link "dbl_qprint"}
 @{"dbl_qrefresh" link "dbl_qrefresh"0}
 @{"dbl_bgblit" link "dbl_bgblit" 0}
 @{"dbl_bgblitpattern" link "dbl_bgblitpattern" 0}
 @{"dbl_bgscroll" link "dbl_bgscroll" 0}
 @{"dbl_bgprint" link "dbl_bgprint" 0}
 @{"dbl_unqueue" link "dbl_unqueue" 0}
 @{"dbl_collision_init" link "dbl_collision_init" 0}
 @{"dbl_hit" link "dbl_hit" 0}
 @{"dbl_2imghit" link "dbl_2imghit" 0}
 @{"dbl_imgmaskhit" link "dbl_imgmaskhit" 0}
 @{"dbl_reset" link "dbl_reset" 0}
@endnode

@node "dbl_hidepointer"
 @{fg shine} Funktion: dbl_hidepointer {}@{fg text}

 Syntax : dbl_hidepointer {}
                                                                                                                   
             versteckt den Mauspfeil auf dem doppelgepufferten Bildschirm.
             Dies ist nützlich für Spiele die die Maus nicht benutzen.
                                                                                       
 Anmerkung :  
 Der Mauspfeil ist standartmäßig ausgeblendet.                               
 
 Anmerkung2:
 Wenn sie den Mauspfeil sichtbar haben wollen, verwenden sie 
 dbl_showpointer{}
                                                                                      
 Eingaben: 
 -keine                                                            
                                                                                  
 Ergebnis: 
 -keine                                                                                                                                              
@endnode

@node "dbl_showpointer"
 @{fg shine} Funktion: dbl_showpointer {[shapenum]}@{fg text}

 Syntax : dbl_showpointer {}                                                                 
                                                                                       
             zeigt den Mauspfeil wieder an nachdem dbl_hidepointer{}
             aufgerufen wurde.    
                                                                                       
 Eingaben: 
 Eine Shapenummer wenn sie den Standardmauspfeil nicht verwenden wollen.
                                                                                      
 Ergebnis: 
 -keine                                                                      
@endnode

@node "dbl_getpen"
  @{fg shine} Funktion: dbl_getpen {}@{fg text}

Syntax : pen.l = dbl_getpen {r.l,g.l,b.l}

            pen.l ergibt die Stiftnummer mit den bestmöglichen Ergebnis aus 
            den RGBwerten,für z.B. Wline oder andere Stift-orientierte Kommandos                                           
                                                                                       
 Eingaben:                                                                             
 - r.l : rot Komponente, 0..255                                      
 - g.l : grün Komponente, 0..255                                  
 - b.l : blau Komponente, 0..255                                    
                                                                                     
 Ergebnis:                                                                             
 - pen.l : Nummer des Stiftes der gewünschten Farbe
@endnode

@node "dbl_setpen"
  @{fg shine} Funktion: dbl_setpen {}@{fg text}

 Syntax : dbl_setpen {n.l,r.l,g.l,b.l}   
              
             Setzt einen Stift zu den angegebenen RGBwerten.  
                                                  
 Anmerkung: 
 Sie sollten diese Funktion nur benutzen wenn sie sicher sind was sie tun, weil es die 
 Farben des Bildes verändert die auf dem Bildschirm gezeichnet wurden.          
                                                                                       
 Anmerkung2: 
 Benutzen sie dbl_getpen{} , dieser Befehl erzeugt neue Stifte mit den bestmöglichen 
 Ergebnissen wenn freie Stifte vorhanden sind.                                                    
                                                                        
 Eingaben:                                                                             
 - n.l : index nummer des Stiftes den sie ändern möchten
 - r.l : rot Komponente, 0..255                                                
 - g.l : grün Komponente, 0..255                                             
 - b.l : blau Komponente, 0..255                                              
                                                                                       
 Ergebnis: 
 -keine                                                    
@endnode
  
@node "dbl_collision_free"
  @{fg shine} Funktion: dbl_collision_free {}@{fg text}

 Syntax : dbl_collision_free {}                                                               
                                                                                       
             Entfernt alle Resourcen  die verbunden sind mit der collision bitmap.         
                                                                                     
 Anmerkung: 
 Nur zur internen Nutzung !!!                                                        
                                                                                       
 Eingaben: 
 -keine                                                                    
                                                                                      
 Ergebnis: 
 -keine                                  
@endnode
  
@node "dbl_free"
 @{fg shine} Funktion: dbl_free {}@{fg text}

 Syntax : dbl_free {}                                                                         
                                                                                      
             Schließt den Bildschirm und entfernt alle Resourcen die verbunden sind 
             mit der dbl_display.include  
  
 Anmerkung: 
 Sie müßen diesen Befehl aufrufen bevor sie ihr Programm beenden!       
                                                                          
 Eingaben: 
 -keine                                                                  
                                                                                       
 Ergebnis: 
 -keine                                                    
@endnode

@node "dbl_flip"
 @{fg shine} Funktion: dbl_flip {}@{fg text}

Syntax : dbl_flip {}                                                                        
                                                                                      
            Wechselt den Doppelpuffer. Diese Funktion wird aufgerufen wenn sie alle 
            Zeichenoperationen mit ihren Objekten abgeschlossen haben.                                                                       
                                                                                      
 Eingaben: 
 -keine                                                                   
                                                                                      
 Ergebnis:
 -keine        
@endnode

@node "dbl_init"
  @{fg shine} Funktion: dbl_init {} @{fg text}

 Syntax : succ.l = dbl_init {screenname.s,modeid.l,scr_width.l,scr_height.l,scr_depth.l} 

             Initiiert das Doppelpufferdisplay (Bildschirm). Alle Parameter sind nötig.              
                                                                                       
 Eingaben:                                                                             
 - screenname.s  : Name des Bildschirms                                                   
 - modeid.l            : 32Bit Bildschirmmodus ID                                        
 - scr_width.l       : Breite des Bildschirms                                                      
 - scr_height.l      : Höhe des Bildschirms                                                     
 - scr_depth.l       : Tiefe des Bildschirms (HiColor ist =16bit, TrueColor ist =24bit Farbtiefe.    
                                                                                       
 Ergebnis:                                                                            
 - succ.l : "Wahr" (True) wenn alles i.o ging, "Falsch" (False) wenn es fehlschlägt. 
@endnode

@node "dbl_qblit"
  @{fg shine} Funktion:  dbl_qblit {}@{fg text}

 Syntax : dbl_qblit {image.l,x.l,y.l}                                                           
                                                                                       
             Blittet ein Bild in den Vordergrund und merkt sich die Position,so das es mit                 
             dbl_unqueue{} wieder entfernt werden kann..                                                
                                                                                       
 Anmerkung: 
 Nachdem sie das Bild geblittet haben, können sie prüfen ob es mit andern Objekten 
 kollidieren kann bis es mit dbl_unqueue{} wieder entfernt wird. 

 Wenn sie die Kollision nicht wünschen, können sie selbst mittels dbl_hit{} prüfen und 
 zwar nach dbl_unqueue{} und bevor sie dbl_qblit{} aufrufen.       
                                                                                       
 Eingaben :                                                                             
 - image.l  : Bild das sie blitten möchten                                                
 - x.l         : x Koordinate                                                          
 - y.l         : y Koordinate                                                         
                                                                                       
 Ergebnis:
 -keine                              
@endnode

@node "dbl_qrefresh"
 @{fg shine} Funktion: dbl_qrefresh {}@{fg text}

 Syntax : dbl_qrefresh {x.l,y.l,xs.l,ys.l,@db.l}                                                
                                                                                       
             Ersetzt die angegebene Region mit dem Hintergrundbild.                                      
                                                                                      
 Anmerkung: 
 Benutzen sie diesen Befehl wenn sie das Display mit anderen Komandos als dbl_qblit{}  
 im Bildschirm gezeichnet haben, z.B. mit WBox und teilen sie der queue mit das sie ihre 
 Zeichenoperationen wieder entfernen soll.                     
                                                                                       
 Eingaben:                                                                             
 - x.l         : x Koordinate                                                          
 - y.l         : y Koordinate                                                         
 - xs.l        : breite der region die entfernt werden soll.                           
 - ys.l        : höhe der region die entfernt werden soll.                         
 - db.l        : (optional) zwingt den Puffer, kann  0 oder 1 sein                             
                                                                                       
 Ergebnis: 
 -keine 
@endnode
 
@node "dbl_qprint"
 @{fg shine} Funktion: dbl_qprint {}@{fg text}
 
 Syntax : dbl_qprint {text.s,x.l,y.l}                                                   
                                                            
            Blittet einen Text in den Vordergrund und merkt sich die Position, so das es mit   
            dbl_unqueue{} wieder entfernt werden kann.. 
                                                                
 Anmerkung: 
 Nachdem sie den Text geblittet haben können sie prüfen ob es mit andern Objekten 
 kollidieren kann bis es mit dbl_unqueue{} wieder entfernt wird.
 
 Wenn sie die Kollision nicht wünschen, können sie selbst mittels dbl_hit{} prüfen und zwar
 nach dbl_unqueue{} und bevor sie dbl_qprint{} aufrufen.       
                                                                                        
 Inputs:                                                                             
 - text.s   : Text den sie blitten wollen.                                         
 - x.l         : x Koordinate                                                    
 - y.l         : y Koordinate                                                   
 - fgpen   : (optional) Vordergrundstift                                  
 - bgpen  : (optional) Hintergrundstift, transparent wenn der Eintrag weggelassen wird. 
                                                                                       
 Ergebnis:
 -keine                                                   
@endnode

@node "dbl_bgblit"
 @{fg shine} Funktion: dbl_bgblit {}@{fg text}

 dbl_bgblit {image.l,x.l,y.l,@collision.l}                                  
                                                                                      
 Blittet ein Bild immer zum Hintergrundbild, so das es beim aufruf von dbl_unqueue{} nicht 
 verschwindet.

 Dieses Objekt kann auch Kollidieren. Kollision ist "Wahr" (True) dann ist die Kollision 
 initialisiert.                                                                        

 Eingaben:                                                                               
 - image.l      : Blid das sie blitten wollen.                                      
 - x.l             : x Koordinate                                                      
 - y.l             : y Koordinate                                                     
 - collsision.l : (optional) Kollision wenn "Wahr"(True) gesetzt ist, oder leer lassen.
                                                                                       
 Ergebnis: 
 -keine                                                     
@endnode

@node "dbl_bgblitpattern"
 @{fg shine} Funktion: dbl_bgblitpattern {}@{fg text}

 dbl_bgblitpattern {image.l,x1.l,y1.l,x2.l,y2.l,@xoffset.l,@yoffset.l,@collision.l}
                                                                                       
 Blittet ein Bild permanent auf den Hintergrund, so das er durch dbl_unqueue{}
 nicht wieder entfernt wird.

 Dieses Objekt kann auch Kollidieren. Kollision ist "Wahr" (True) dann ist die Kollision 
 initialisiert.                                                                                                                                                

 Eingaben:                                                                               
 - image.l      : Blid das sie blitten wollen.                                      
 - x.l             : x Koordinate                                                      
 - y.l             : y Koordinate                                                     
 - collsision.l : (optional) Kollision wenn "Wahr"(True) gesetzt ist, oder leer lassen.
                                                                                       
 Ergebnis: 
 -keine                                                                                 
@endnode

@node "dbl_bgscroll"
 @{fg shine} Funktion: dbl_bgscroll {}@{fg text}

 dbl_bgscroll {dx.l,dy.l}                                   
                                                                   
 scrollt den Hintergrund.                                   
                                                                   
 Eingaben:                                                         
 - dx.l         : Anzahl der Pixel in x-Richtung      
 - dy.l         : Anzahl der Pixel in y-Richtung    
                                                                  
 Ergebnis:
 -keine                             
@endnode

@node "dbl_bgprint"
 @{fg shine} Funktion: dbl_bgprint {}@{fg text}

 dbl_bgprint {text.s,x.l,y.l,@fgpen.l,@bgpen.l,@collision.l}

 Blittet einen Text permanent auf den Hintergrund, so das er durch dbl_unqueue{}
 nicht wieder entfernt wird.

Dieses Objekt kann auch Kollidieren. Kollision ist "Wahr" (True) dann ist die Kollision 
 initialisiert.                                                                                                                    

 Eingaben:
 -text.s         : Text den sie blitten möchten.
 -x.l              : x Koordinate
 -y.l              : y Koordinate
 - fgpen       : (optional) Vordergrundstift                                  
 - bgpen      : (optional) Hintergrundstift, transparent wenn der Eintrag weggelassen wird. 
 - collsision.l : (optional) Kollision wenn "Wahr"(True) gesetzt ist, oder leer lassen.

 Ergebnis: 
 -keine      
@endnode

@node "dbl_unqueue"
 @{fg shine} Funktion: dbl_unqueue {}@{fg text}

 Syntax : dbl_unqueue {}                                                                        
                                                                                       
            Entfernt alle Objekte die mit dbl_qblit{} gezeichnet wurden. 
                                             
            Rufen sie diesen Befehl auf bevor sie ihre Objekte auf die neuen 
            Positionen zeichnen um die alten Objekte an ihrer alten Position 
            zu entfernen.                                 
                                                                                       
 Eingaben: 
 -keine                                                                    
                                                                                       
 Ergebnis: 
 -keine                                  
@endnode

@node "dbl_collision_init"
 @{fg shine} Funktion: dbl_collision_init {}@{fg text}

 Syntax : succ.l = dbl_collision_init {}                                                        
                                                                                       
             Erzeugt eine Bitmap mit den Daten die keine Kollision haben sollen zur
             späteren Verwendung mit dbl_hit{}. 
           
             Sie sollten so vorgehen:
                                 
             Zeichnen sie ihre Objekte die keine Kollision erzeugen sollen, danach 
             sollten sie dbl_collision_init{} aufrufen, und anschließend ihre Objekte
             (z.B. Wände) zeichnen die eine Kollision haben sollen.                       
                                                                                
 Eingaben: 
 -keine                                                                    
                                                                                       
 Ergebnis:                                                                             
 - succ.l  : "Wahr" (True) wenn die Kollisionsbitmap erfolgreich angelegt wurde.
@endnode

@node "dbl_imgmaskhit"
 @{fg shine} Funktion: dbl_imgmaskhit {}@{fg text}

 succ.l = dbl_imgmaskhit {image.l,x.l,y.l,tstx.l,tsty.l}             
                                                                                  
 Testet ob die Bildmaske an den angegebenen tstx/tsty einen Treffer hatte.                      
                                                                                  
 Inputs:                                                                        
 - image.l    : Bildobjektnummer                                 
 - x.l           : x Koordinate des Bildes                                  
 - y.l           : y Koordinate des Bildes                                 
 - tstx.l      : x Koordinate des Testpunktes                             
 - tsty.l      : y Koordinate des Testpunktes                             
                                                                                
 Ergebnis:                                                                      
 - succ.l    : "Wahr" (True) wenn eine Kollision vorliegt, "Falsch" (False) wenn nicht.                  
@endnode

@node "dbl_2imghit"
 @{fg shine} Funktion: dbl_2imghit {}@{fg text}

  succ.l = dbl_2imghit {image1.l,x1.l,y1.l,image2.l,x2.l,y2.l}      
                                                                                      
 Testet Bild1 und Bild2 ob an den angegebenen Koordinaten eine Kollision vorliegt. 
                                                                                       
 Eingaben:                                                                             
 - image1.l   : Bildobjektnummer des ersten Bildes                                     
 - x1.l          : x Koordinate des ersten Bildes                                      
 - y1.l          : y Koordinate des zweiten Bildes                                     
 - image2.l   : Bildobjektnummer des zweiten Bildes                                    
 - x2.l          : x Koordinate des zeiten Bildes                                     
 - y2.l          : y Koordinate des zweiten Bildes                                   
                                                                                      
 Ergebnis:                                                                      
 - succ.l      : "Wahr" (True) wenn eine Kollision vorliegt, "Falsch" (False) wenn nicht.                                                                            
@endnode

@node "dbl_reset"
 @{fg shine} Funktion: dbl_reset {}@{fg text}

 Syntax :  dbl_reset {}                                                                          
                                                                                       
              Resetet das Doppelpufferdisplay. Sie sollten diesen Befehl aufrufen bevor                       
              sie in ihre Hauptschleife zurückkehren um alles zu entfernen.                            
                                                                                      
 Eingaben:
 -keine                                                                       
                                                                                       
 Ergebnis: 
 -keine                                                
@endnode

@node "dbl_hit"
 @{fg shine} Funktion: dbl_hit {}@{fg text}
 
 succ.l = dbl_hit {x.l,y.l}                                                     
                                                                                     
 Testet ob die Farbe der angegebenen x/y Koordinaten verändert wurden in der Zeit 
 wenn dbl_collision_init{}  aufgerufen wurde (Nachdem sie ihren nicht-Kollisionfähigen 
 Hintergrund erzeugt haben. 
                                                      
 Sie sollten so vorgehen:                                    
                                 
 1. Erzeugen sie ihren nicht-Kollisionsfähigen Hintergrund mit dbl_bgblit{} und dbl_bgblitpattern{}
 2. Rufen sie nun dbl_collision_init{} auf                                                          
 3. Blitten sie ihre "Wände" die kollidieren sollen mit dbl_bgblit{}                 
 4. Prüfen sie mit dbl_hit{x,y} in der Hauptschleife ob eine Kollision vorliegt.              
                                                                                       
 Wenn sie keine "Wände" verwenden, sollten sie dbl_collision_init() nicht benutzen,
 um Speicher zu sparen. 
                                                                                      
 Eingaben:                                                                            
 - x.l         : x Koordinate zum prüfen                                       
 - y.l         : y Koordinate zum prüfen                                       
                                                                                     
 Ergebnis:                                                                           
 - succ.l   : "Wahr" (True) wenn sich die Farbe verändert hat, "Falsch" (False) wenn nicht. 
@endnode

;end dbl_display.include----------------------------------------------------------

@node "!screen_"  " !screen_ Macro von Bernd Rösch"

 Macro : !screen_ {Screennum,title,prefsfile,mode[,Tags]}

 1. Öffnet einen Bildschirmmodus-requester wenn kein Prefsfile gefunden wurde.

 2. Speichert den Bildschirmmodus in ein Prefsfile.

 3. Öffnet einen Bildschirm mit Bildschirmnummer und Titel

 mode=1 (bit 0 set)   öffnet immer den Bildschirmmodus-requester
 mode=2 (bit 1 set)   öffnet keinen Bildschirm

 Wenn sie !screen_ aufrufen erlangen sie einige Informationen mit folgenden Macros:

 !screen_width        gibt die Visuelle Breite zurück
 !screen_height       gibt die Visuelle höhe zurück
 !screen_depth        gibt die Tiefe zurück
 !screen_id           gibt die BildschirmID zurück
 !screen_realwidth    gibt die Visuelle Bildschirmbreite zurück
 !screen_realheight   gibt die Visuelle Bildschirmhöhe zurück

 Anmerkung:
 Es können alle Tags vom ASL-Screenmoderequester verwendet werden.
 
 Beispiele:

 #ASLSM_TitleText,"Text"
 #ASLSM_InitialDisplayWidth,Breite des Bildschirms (z.b: 640)
 #ASLSM_InitialDisplayHeight,Höhe des Bildschirms (z.b:480)
 #ASLSM_InitialDisplayDepth,Tiefe des Bildschirms (z.b: 16 für 16bit)
 #ASLSM_DoAutoScroll,0 (0 für unsichtbar, 1 für sichtbar)
 #ASLSM_DoOverscanType,0 (0 für unsichtbar,1 für sichtbar) 
@endnode

@node "!version" "!version Macro von Bernd Rösch"
 
 Macro:  !version {"Myprog V1.0"}

 Stellen sie sicher das sie einen Namen vergeben haben bevor sie die Versionsnummer 
 durch Trennung eines Leerzeichen angeben. Das OS3.9 Kommando Version zeigt sonst 
 nicht korrekt an.
@endnode

;  vvblank_include lib start ----------------------------------------------------------
@node "vvblank_includelib" "vvblank_include von Thilo Köhler"

 Diese Include ersetzt den alten VWait-Befehl mit einem "virtual vertical blank"
 Dieser ist konfigurierbar über die Frequenz (z.B 100Hz). 
 Der Hauptverwendungszweck ist zum "timen" des grafischen Output's bei 
 Spielen auf der Grafikkarte.

 @{"vvblank_free" link "vvblank_free" 0}
 @{"vvblank_reset_sync" link "vvblank_reset_sync" 0}
 @{"vvblank_set" link "vvblank_set" 0}
 @{"vvblank_wait" link "vvblank_wait" 0}
 @{"vvblank_wait_sync" link "vvblank_wait_sync" 0}                                
@endnode

@node "vvblank_free"
 @{fg shine} Funktion: vvblank_free {}@{fg text}

 vvblank_free {}

 Entfernt alle verbundenen Resourcen der vvblank_include. 

 Sie müßen diese Funktion beim beenden ihres Programmes aufrufen !!!    
@endnode

@node "vvblank_reset_sync"
 @{fg shine} Funktion: vvblank_reset_sync {}@{fg text}

 vvblank_reset_sync {}

 Teilt dem vvblank_wait_sync{} Kommando mit wann das zählen angefangen 
 werden soll. 
@endnode

@node "vvblank_set"
 @{fg shine} Funktion: vvblank_set {}@{fg text}

 succ.l = vvblank_set {hz.l}  

 Setzt die Frequenz. Gültiger Bereich ist von 25 bis 200 Hz, Vorgabe ist 50Hz 
@endnode

@node "vvblank_wait"
 @{fg shine} Funktion: vvblank_wait {}@{fg text}

 vvblank_wait {vcycles.l}

 Dieser Befehl funktioniert exakt wie das alte VWait Kommando.
 
 Es wartet auf den nächsten VBlank tick.
  
 Eine Änderung gibt es zu VWait: 
 Wenn ihr Programm zu lansam ist, wird diese Funktion immer keine Zeit verlieren als nötig. 
 Anders als die vvblank_wait_sync{} Funktion, diese tut das nur einmal.

 Eingaben:
 - vcycles : Nummer von VBlanks die gewartet werden sollen, normal sollte 
                   dies 1 sein  
@endnode

@node "vvblank_wait_sync"
 @{fg shine} Funktion: vvblank_wait_sync {}@{fg text}

 vvblank_wait_sync {vcycles.l} 

 Gleicher Befehl wie vvblank_wait{}, aber es zählt die vblank ticks. Wenn sie eine tick
 vermissen  (wenn ihr Programm zu langsam ist) wird diese Funktion immer zurückgeben 
 ob sie wieder im sync sind.  
 
 Zum Mitteilen wenn sie starten wollen müßen sie vvblank_reset{}
 aufrufen, oder wenn sie ihre Sequence anhalten wollen.
@endnode
; vvblank_include end----------------------------------------------------------------

 ;rawkey_include-----------------------------------
@node "rawkey_include" "rawkey_include by Thilo Köhler"

    rawkey.include

         @{"Rawkeycode-Beispiel" system "run >NIL: BLITZ2:REDHelp/ShowExample File=Blitz2:thilo_includes/examples/rawkeycode_test.ab2"}

 Diese Include kann jede Taste OS-freundlich auf der Tastatur überprüfen 
 ob eine Taste niedergedrückt wurde oder nicht.
 Ihr Programm benötigt kein offenes aktives Fenster.
 Diese Include ist ein Ersatz für den orginal RawStatus-befehl,
 der nicht mehr auf allen Systemen arbeitet.   
                                               
 @{"rawkey_free" link "rawkey_free" 0}
 @{"rawkey_init" link "rawkey_init" 0}
 @{"!rawkey_tst" link "!rawkey_tst" 0}
 @{"!rawkey_get" link "!rawkey_get" 0}
@endnode

@node "rawkey_free"
 @{fg shine} Funktion: rawkey_free {}@{fg text}

 rawkey_free {}   

 Diesen Befehl müßen sie aufrufen bevor sie ihr Programm verlassen.
 Sie können diesen Befehl auch aufrufen wenn die Include schoneinmal 
 frei gemacht wurde. 
@endnode

@node "rawkey_init"
 @{fg shine} Funktion: rawkey_init {}@{fg text}
 
 succ.w = rawkey_init {}               

 Sie müßen diesen Befehl zuerst aufrufen bevor sie irgendeinen anderen 
 Befehl aus dieser Include benutzen möchten.
@ endnode

@node "!rawkey_tst"
 @{fg shine} Macro: !rawkey_free {}@{fg text}

 !rawkey_tst {rawkeycode}      

 Eingaben:
 - rawkeycode Tastencode der abgefragt werden soll.
 
 Gibt "Wahr" (True) wieder wenn die angegebene Taste gedrückt wurde wenn zuvor mit 
 !rawkey_get überprüft wurde, anderenfalls "Falsch"" (False) 

@endnode

@node "!rawkey_get"
 @{fg shine} Macro: !rawkey_get {}@{fg text}

 !rawkey_get   

 Fragt die Information über gedrückte Tasten ab, damit sie später per 
 !rawkey_tst überprüft werden können.
@endnode
