; Description:      Shows how to get the various border sizes of a window *before* it
;                   is opened
;
; Type:             Intuition
;
; Last updated:     27th May 1999
;
; Author:           David McMinn, from example by Massimo Tantignone
;
; Requires:         amigalibs.res
;

WBStartup
WbToScreen 0
*scr.Screen = Peek.l(Addr Screen(0))


; You pass the address of the variables you want to store the result in, they must be
; longword variables (.l type). If you do not want one of the sizes returned, then you
; can pass 0 as the parameter, and it will be ignored.
; NB: You MUST have a currently used screen before calling this statement
;
Statement SizeGadBorders{*right.l,*bottom.l}
    DEFTYPE.Screen      *scr    ; Pointer to a screen
    DEFTYPE.DrawInfo    *dri    ; The drawing information of that screen
    DEFTYPE.Image       *img    ; An image which represents the size gadget
    DEFTYPE.l           sis     ; Size of image for either medium res or lo res screens
    DEFTYPE.l           rightborderthickness  ; The thickness the borders would be if
    DEFTYPE.l           bottomborderthickness ; a size gadget is on the window
    Dim                 tags.TagItem(4) ; Tags for getting the size gadget image

    ; Initial fallback values
    rightborderthickness = 18
    bottomborderthickness = 10

    ; Get address of currently used screen and then the drawing information for it
    *scr = Peek.l(Addr Screen(Used Screen))
    *dri = GetScreenDrawInfo_(*scr)

    If *dri
        ; If we got a pointer to the drawing information, check what size of image
        ; the size gadget will be.
        If (*scr\Flags & #SCREENHIRES) Then sis=#SYSISIZE_MEDRES Else sis=#SYSISIZE_LOWRES

        ; Create tags for getting size gadget image and then get the image (using BOOPSI)
        tags(0)\ti_Tag = #SYSIA_DrawInfo,*dri
        tags(1)\ti_Tag = #SYSIA_Which,#SIZEIMAGE
        tags(2)\ti_Tag = #SYSIA_Size,sis
        tags(3)\ti_Tag = #TAG_DONE
        *img = NewObjectA_(0,"sysiclass",&tags(0))
        If *img
            ; If we got the image, then we get the width and height of the image, which
            ; turn out to be the width and height of the right and bottom borders.
            ; We don't need the image after this, so get rid of it as well
            rightborderthickness = *img\Width
            bottomborderthickness = *img\Height
            DisposeObject_ *img
        End If

        ; Free the drawing information for the screen
        FreeScreenDrawInfo_ *scr,*dri
    End If

    ; Store the values, only if the parameter passed was not 0. Poke is used here
    ; (even though I think it looks untidy) because of the way Blitz handles
    ; pointers (i.e. poorly) to the basic types, in this case a .l
    If *right Then Poke.l *right,rightborderthickness
    If *bottom Then Poke.l *bottom,bottomborderthickness
End Statement


; Print values of window borders to default output *before* opening a window
NPrint "Values calculated before opening window"
NPrint "Left border = ",*scr\WBorLeft
NPrint "Top border = ",*scr\WBorTop
NPrint "Right border = ",*scr\WBorRight
NPrint "Bottom border =",*scr\WBorBottom

NPrint ""

NPrint "Title bar height = ",*scr\WBorTop + *scr\Font\ta_YSize + 1
DEFTYPE.l r,b
SizeGadBorders{&r,&b}
NPrint "Right border width (with size gadget) = ",r
NPrint "Bottom border height (with size gadget) = ",b

NPrint ""

; You can check the different styles of border by using ONLY ONE of these lines
;Window 0,0,0,200,200,$100f,"Test",-1,-1                                     ; Size gadget, right border
;Window 0,0,0,200,200,$100f|#WFLG_SIZEBBOTTOM,"Test",-1,-1                   ; Size gadget, bottom border
Window 0,0,0,200,200,$100f|#WFLG_SIZEBBOTTOM|#WFLG_SIZEBRIGHT,"Test",-1,-1  ; Size gadget, right border


*win.Window = Peek.l(Addr Window(0))
DefaultOutput

NPrint "Values found after opening window"
NPrint "Left border = ",*win\BorderLeft
NPrint "Top border = ",*win\BorderTop
NPrint "Right border = ",*win\BorderRight
NPrint "Bottom border = ",*win\BorderBottom

While ev.l<>#IDCMP_CLOSEWINDOW
    ev=WaitEvent
Wend
End

