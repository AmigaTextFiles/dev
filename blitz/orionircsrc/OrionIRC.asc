
;
; Get editors working! ! ! !
;
; Current bugs:
;
; 1. fix input text routine for non server messages for proper cut
; and display and usage formats..
;
; 2. display data loading sequence bug +1 to display ID with gfx card?!
;
; 3. spontaneous relogin or drop after a period of time
;
; add private convo
; use IP for security
; add opping from X
; user-history
; given access to levels
; channel monitor and notify
; add more basic funtions .. i.e. and whois
; ^^ will come with better aliasing..
;
;
; ____ __ _   __ __     __ _      __ _ _
; / /_////=   / /_/  /< /_/_ /<  /-/_>_>
;
;----------------------------------------------
.top

; */ System Basics! /*

;NoCli
WBStartup

CaseSense Off
DateFormat 1
WBenchToFront_
WbToScreen 0

; /* set up certain variables and constants to be made
; configurable in base release /*


; /* loging verboseness for input & output /*
outp=True
inp=True

; /* other variables for needed base at startup /*

color=True
bot=False
intro=False
speech=False

; /* non-configurable startup variables /*

reg=True
test=True
connected=False
nicksetup=False
new=True


; /* system constants /*

#_l=9
#_v=2000
#_err=133
#_id=0
#_width=1
#_height=2
#_depth=4
#_overscan=8
#_scroll=16
#TCPBuflen=$8192            ;Maximum data size to read at any time
#FIONREAD=$4004667f         ;FIONREAD request
#_Pens=$8000003A
#WINFLAGS=#WFLG_CLOSEGADGET|#WFLG_ACTIVATE|#WFLG_DRAGBAR|#WFLG_DEPTHGADGET
#WINFLAGS=#WINFLAGS | #WFLG_RMBTRAP
#WINWIDTH=640
#MOUSEMOVE=$10
#INTUITICKS=$400000

; /* intuition setup for listviews /*

AddIDCMP #MOUSEMOVE+#INTUITICKS

; /* data type definitions /*

DEFTYPE.w random,ttl,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z

DEFTYPE.l DisID

NEWTYPE.listview
  pad.w
  string.s
End NEWTYPE
NEWTYPE.list
  *ItemA.b
  *ItemB.b
End NEWTYPE
NEWTYPE.irc
  amber.w
  b$
End NEWTYPE
NEWTYPE.servers
  voice.w
  s$
End NEWTYPE

NEWTYPE.textEX                 ;for the word-wrapping stuff
  txwidth.w                    ;this is used as a workspace
  txheight.w                   ;by the Textfit_ command
  txMinx.w
  txMiny.w
  txMaxx.w
  txMaxy.w
End NEWTYPE
NEWTYPE.SMode                              ;for the mode requester
  DisplayID.l
  DisplayWidth.l
  DisplayHeight.l
  DisplayDepth.w
  OverscanType.w
End NEWTYPE

;/* internet socket setup /*
NEWTYPE.inaddr
  s_addr.l
End NEWTYPE
NEWTYPE.sockaddrin
  sin_len.b
  sin_family.b
  sin_port.w
  sin_addr.inaddr
  sin_zero.b[8]
End NEWTYPE
NEWTYPE.hostent
  *h_name.b
  *h_aliases.list
  h_addrtype.l
  h_lenght.l
  *h_addr_list.list
End NEWTYPE

; /* system integers using subtypes /*

al.textEX\txwidth=0,0,0,0,0,0  ;for the word-wrap routine

; /* system integers (inititalized after types are defined
; to insure data integrity) /*

cnt=0
set.l=0
ok.b=0
p=0
opie=0
maxlines=9999                  ;must be > maximum lines of text expected
fsize.b=11
prt=1

; /* Array setup for lists /*

Dim List convo.irc(9000)
Dim List nicks.irc(100)
Dim List chans.irc(20)
Dim List comms.irc(50)
Dim List groups.servers(30)
Dim List conchan.servers(10)
Dim List gset.servers(20)

; /* Array setup for standard variables /*

Dim nick$(#_l)
Dim ip$(#_l)
Dim pass$(#_l)
Dim access$(#_l)
Dim acc.l(#_l)
Dim oneline$(#_v)
Dim greets$(100)
Dim command$(50)
Dim pass.l(#_l)
Dim win.l(#_l)
Dim input$(50)
Dim incfg$(1000)
Dim nickset$(20)
Dim errn$(#_err)
Dim errt$(#_err)
Dim errd(#_err)
Dim boing$(2000)
Dim group$(20)
Dim server$(20)
Dim port(2)
Dim servers$(20)
Dim conchan$(10)
Dim ssort$(20)
Dim chans$(50)
Dim pens.w(10)
Dim irccol$(31)
Dim vernfo$(10)

For n=0 To 10
 pens(n)=$FFFF
Next n
*p.w=&pens(0)

; /* direct variable definitions which will either be
; editable via config or a data sequence.. whatever.. /*

port(0)=6666
port(1)=6667
port(2)=6668

TCPmem.l=AllocMem(#TCPBuflen,0) ;Allocate the temp buffer used for all TCP reads

VER$="OrionIRC V1.0 ._. OrionSoft"
ver$="OrionIRC V0.08 - Alpha ._. By Andrew Drays - OrionSoft LTD."
Ver$="OrionBOT SE V1.5"

vernfo$(0)="By: Andrew Drays"
vernfo$(1)="Special Thanx to Paul Burkey & Curt Esser!"
vernfo$(3)="=========================================="

; /* here's where I have sequences BEFORE the actual program
; setup to setup other data for the IRC client when it's running
; right now, just eliza but l8er ad&D stuff! /*

;------------------------------------------
;
; eliza data setup routine
;
;-----------------------------------------
Dim S.l(36),R.l(36),N.l(36)
NA=36
NB=12
NC=112
For X=1 To NA+NB+NC
  Read Z$
Next X
L.l=0
For X=1 To NA
  Read S(X),L
  R(X)=S(X)
  N(X)=S(X)+L-1
Next X

;/* All inits are completed.. ready for macros.. /*
;
;------------------------------------------
;
; Macros
;
;--------------------------------------------

; /* none now.. /*

;-----------------------------------------
;
; Internet TCPfuncs Function Subroutines! *** DO NOT TOUCH! **
;
; /* this is not my code, I can get it back, but it is very
; difficult to put back in , I have made slight modifications
; for speed optimization and for this program this the actual
; TCP port.. I'm not 100% sure of it's limitations /*
;
;-----------------------------------------


Function .s ReadTCP{}
  SHARED sock.l,TCPmem.l
  ;
  ; This Function reads data from the server the result is passed back in a
  ; string. If there is no messages then it will return an empty string =""
  ;
  sockread.l=0                                ;Clear Readmask
  sockread.l BitSet sock.l                    ;Set Readmask on our socket
  e.l=IoctlSocket_(sock.l,#FIONREAD,TCPmem.l) ;How much data is there?
  f.l=Peek.l(TCPmem.l)                        ;Place value in f
  If f>0
    If f>#TCPBuflen Then f=#TCPBuflen         ;Don't read more than #TCPBuflen
    c=recv_(sock.l,TCPmem.l,f,0)              ;Read all Data
    c$=String$(" ",f)                         ;Reserve String
    CopyMem_ TCPmem.l,&c$,f                   ;Copy Data to string
    Function Return c$
  Else
    Function Return ""
  EndIf
End Function

;----
;WARNING: This is a 'rough' experiment function.
;Function will probably change next update.
;----

Function .l ReadMemTCP{ReadAdd.l,MaxSize.l}
  SHARED sock.l,TCPmem.l
  ;
  ; Read into memory location 'ReadAdd.l' up to a maximum of 'MaxSize.l'
  ; Used for reading long binary files eg, WWW files or FTP files.
  ; Also returns the amount of bytes actually read.
  ;
  sockread.l=0                                ;Clear Readmask
  sockread.l BitSet sock.l                    ;Set Readmask on our socket
  e.l=IoctlSocket_(sock.l,#FIONREAD,TCPmem.l) ;How much data is there?
  f.l=Peek.l(TCPmem.l)                        ;Place value in f
  If f>0
    If f>#TCPBuflen Then f=#TCPBuflen         ;Don't read more than #TCPBuflen
    If f>MaxSize Then f=MaxSize               ;Don't read more than MaxSize
    c=recv_(sock.l,ReadAdd.l,f,0)             ;Read Data to ReadAdd location
    Function Return f
  Else
    Function Return 0
  EndIf
  ;
End Function

Statement WriteMemTCP{ad.l,size.w}
  SHARED sock.l
  ;
  ; This routine writes data via TCP.
  ;
  sockwrite.l=0                           ;Clear Writemask
  sockwrite.l BitSet sock.l               ;set Writemask on our socket
  g.l=WaitSelect_(2,0,&sockwrite.l,0,0,0) ;Wait until server is ready to read our data
  c.l=send_(sock.l,ad,size,0)             ;Send data to server
End Statement

Function .b ConnectTCP{host$,port.w}
  SHARED sock.l
  ;
  ; Check if Miami/AmiTCP stack is available
  ; Connect to host at specified port
  ; Return true or False if Connection is made

  SocketBase.l=OpenLibrary_("bsdsocket.library",0)
  If SocketBase=0
    Function Return False
  Else
    CloseLibrary_(SocketBase)
    sock.l=socket_(2,1,0)
    *a.hostent=gethostbyname_(host$)
    If *a=0
      Function Return False   ; host not found (or internal TCP error)
    Else
      ;
      ; Copy Details to our Sockaddrin structure
      ;
      CopyMem_ *a\h_addr_list\ItemA,&host.sockaddrin\sin_addr,*a\h_lenght
      host.sockaddrin\sin_port=port       ;Set port number
      host.sockaddrin\sin_family=2        ;Set type to AT_INET
      StructLength.l=SizeOf .sockaddrin   ;Get lenght of structure sockaddrin
      If connect_(sock.l,host.sockaddrin,StructLength)=-1
        CloseSocket_(sock.l)
        Function Return False
      Else
        Function Return True
      EndIf
    EndIf
  EndIf
End Function

Statement PrintTCP{text$}
  ;
  ; Send String via TCP
  ;
  WriteMemTCP{&text$,Len(text$)}
End Statement

Statement NPrintTCP{text$}
  ;
  ; Send String via TCP + Carrage Return
  ;
  text$=text$+Chr$(13)
  WriteMemTCP{&text$,Len(text$)}
End Statement

Statement NLPrintTCP{text$}
  ;
  ; Send String via TCP + Carrage Return + Line Feed
  ;
  text$=text$+Chr$(13)+Chr$(10)
  WriteMemTCP{&text$,Len(text$)}
End Statement

Statement CloseTCP{}
  SHARED sock.l
  ;
  ; This is a simple close socket command
  ; Provided for the shear hell of it :)
  ;
  CloseSocket_(sock.l)
End Statement

; /* end tcpfuncs subroutine processes /*
;
;
; /* 3d render routine /*

Statement  large{d$,x,y,af,p,j}
  SHARED ln,vn
  xx=x:yy=y
  For r=1 To Len(d$)
  WLocate 24,24:NPrint Mid$(d$,r,1)
  sx=xx:sy=y
   For d=1 To p
    If d<p
      cl=2
    Else
      cl=3
    EndIf
   xx=sx:yy=sy-(d*2)
    For o=0 To 7
      For s=0 To 7
        If Point(24+s,32+o)=1
          dx=(xx+(s*af))
          dy=(yy+(o*af))
          fx=dx+(af-1):fy=dy+(af-1)
          Boxf dx,dy,fx,fy,cl
        EndIf
      Next s
      xx=xx-ln
    Next o
  Next d
  xx=xx+j:ln=ln-vn
Next r
End Statement

; /* Telnet Code, For future Use.. Cut out AND set aside!! /*

Function .s input{prompt$}
  ;
  ; Simple "old style" input function
  ; This function is not linked to TCP coding
  ;
 Print prompt$+": "
  text$=Edit$(40)
  Function Return text$
End Function

Function .s striptext{text$}
  ;
  ; Simple function to strip Carrage Returns
  ; and Line Feeds from text.
  ;
  c$=""
  For a=1 To Len(text$)
    l$=Mid$(text$,a,1)
    If l$<>Chr$(10) AND l$<>Chr$(13)
      c$=c$+l$
    EndIf
  Next a
  Function Return c$
End Function

; /* end telnet code /*

; /* IRC tcp routines - definitions inside /*

Statement logtext{text$}
  ;
  ; log all text from server and out to..
  ;
  SHARED input$,output$,inp,outp,ltxt
  If ltxt=True
    FileOutput 2
    NPrint text$
;    If inp=True
;      NPrint input$
;    EndIf
;    If outp=True
;      NPrint output$
;    EndIf
    DefaultOutput
  EndIf
End Statement

Statement output{a$}
   ;
   ; Send raw text to server
   ;
   NPrintTCP{a$}
   logtext{"<me>"+a$}
End Statement

Statement say{a$}
   ;
   ; Send text direct to channel
   ;
   SHARED chan$,target$
   say$="privmsg "+chan$+" :"+a$
   NPrintTCP{say$}
   logtext{"<me>"+say$}
End Statement

Statement nstr{A$}
   ;
   ; add a cr and linefeed to string
   ; telnet?!? testing
   ;
   send$=input{nick$}             ; Get user input
   If send$<>""
     send$=send$+Chr$(13)+Chr$(10) ; add CR+LF
     say{send$}   ;  send text to server
   EndIf
End Statement

Statement lost{lst$}
    SHARED nick$()
    ;
    ; old routine for bot only if it dropped from all
    ; channels, not needed anymore, keep for future use
    ;
    For i=1 To 6
      output{"privmsg "+nick$(0)+" : Help! I'm lost!!"}
      say{"help!"}
      Delay_(5)
    Next i
End Statement

Statement join{chan$}
    ;
    ; join channel and send greeting only in orion length
    ;
     SHARED greet$,z,greets$(),target$
     output{"JOIN "+chan$}
     If cgreet=True
       r.l=Rnd(z)
;       say{" ____ __ _   __ _       __ _       __ _ _"}
;       say{" / /_////=   / /_\   /< /_/_ /<   /-/_>_>"}
       say{greets$(r)}
       GTSetString 1,3,chan$
       set=0
     EndIf
End Statement

Statement commands{who$}
  ;
  ; bot commands display privmsg to user
  ;
  SHARED who$,chan$,b,command$(),head$,target$
  ; make access level counter for amenu display for-next
  For i=0 To b
    say$="PRIVMSG "+who$+" : "+command$(i)
    NPrintTCP{say$}
  Next i
      say$="PRIVMSG "+who$+" : Current Comand Prefix is '"+head$+"'"
    NPrintTCP{say$}

End Statement

Statement random{a$}
 ;
 ; random crap output ** make compatible with kuang! **
 ;
 SHARED set,pass,h,oneline$(),chan$,target$
 set=0
 pass=Rnd(h)
 say{oneline$(pass)}
End Statement

Statement kick{a$}
  ;
  ; duh!
  ;
  SHARED who$
  SHARED said$
  SHARED chan$,target$
  kick$="kick "+target$+" "+a$
  output{kick$}
End Statement

;--------------------------------------------------
;
; Encryption routines
;
;--------------------------------------------------

Statement ncrypt{a$}
  ;
  ; Encryption algorythm is supposed to shift up ascii codes in a friendly way.
  ;

  SHARED chan$,who$,said$,CODEDO$,nick$(),target$

  INSTRG$=UnRight$(said$,8)

  D1.l = Rnd(9)
  D2.l = Rnd(9)
  D3.l = D2 * D1
  DA$ = Str$(D1)
  DB$ = Str$(D2)

  If Len(INSTRG$) > 2

    UNAME$ = INSTRG$
    LENGTHONE = Len(UNAME$)
    TEMPCOUNT = 1
    NEWSTR$=""
    For X = 1 To LENGTHONE
       CHARA$ = Mid$(UNAME$, X, 1)
       CHARVAL = Asc(CHARA$)
       If CHARVAL > 31 AND CHARVAL < 127
          CHAR2 = CHARVAL + 1 + D3
          If CHAR2 >= 127
             CHAR2 = CHAR2 - 95
          EndIf
          CHAR2$ = Chr$(CHAR2)
       Else
          CHAR2 = CHARVAL
          CHAR2$ = Chr$(CHAR2)
       EndIf
       NEWSTR$ = NEWSTR$ + CHAR2$
    Next X
    v$ = "PRIVMSG " + chan$ +" :"+ "-\\" + "<" + DA$ + DB$ + ">" + NEWSTR$
    DA$ = "": DB$ = ""
  Else
    v$="PRIVMSG "+nick$(0)+" : Nothing to Encrypt!"
  EndIf
  NPrintTCP{v$}
  logtext{"<me>"+v$}
End Statement

Statement dcrypt{a$}
   SHARED color,who$,chan$,nick$()
   WColour color
   Cof$ = Left$(a$,4)
   a$ = UnRight$(a$,4)
   D4$ = Mid$(Cof$, 2, 1)
   D5$ = Mid$(Cof$, 3, 1)
   D4.l = Val(D4$)
   D5.l = Val(D5$)
   D6.l = D4 * D5
   G.l = Len(a$)
   For X=1 To G
      Chara$ = Mid$(a$, X, 1)
      Charval.l = Asc(Chara$)
      If Charval > 31 AND Charval < 127
         Char2.l = Charval - D6 - 1
         If Char2 < 32
            Char2 = Char2 + 95
         EndIf
         Char2$ = Chr$(Char2)
      Else
         Char2 = Charval
         Char2$ = Chr$(Char2)
      EndIf
      If X=1
        NS$=Char2$
      Else
        NS$=NS$+Char2$
      EndIf
   Next X
   x$ = "PRIVMSG "+nick$(0)+" : Decoded-> "+who$+": "+NS$
   NPrintTCP{x$}
   logtext{"<me>"+x$}
   WColour color
End Statement






.begin
;
; /*
; Actual Program Begins here!
;
;

;log

Gosub baseload     ; data loading sequences
Gosub extendload
Gosub newsort      ; data loaded SORTING
If test=True
  enter$=Edit$(30)
  End
EndIf
Gosub menu         ; pull down menus setup
Gosub screengo
Gosub gtlistsel    ; Gt lists
Gosub gtlistirc
Gosub gtlistsed
Gosub selwindow    ; open server select window and wait for
                   ; user input

;*********************
; Gui
;*********************


.main
Repeat
If test=False
  ; *** check to see if IRC is up, and if it is, don't WAIT
  If irc=True
    Delay_(1)
    ev.l=Event
  Else
    ; *** if irc isn't up, WAIT for an inputevent!
    ev.l=WaitEvent
  EndIf
Else
  ; ** Same for test variable no reason to eat cpu time
  ; when there's no IRC input to look for
  ev.l=WaitEvent
EndIf
  ; Grab GUI event integers
  evw.l=EventWindow
  evc.l=EventCode
  evq.l=EventQualifier
  ; if a window EXISTS then do the routine to check for input,
  ; no reason to check for input if the window isn't there.. :)
  ; thus making the program SMART!
If win(0)=True
  ; all windows follow (or SHOULD follow the same routine priority
  ; 1. Gadget
  ; 2. pulldown menu
  If evw=0
    Use Window evw
    If ev=$40
      Select GadgetHit
        Case 1
         If V=nickstot-1
          V=0
         Else
          V+1
         EndIf
        Case 2
          slst.l=evc
          Dim List groups.servers(30)
          serverst$=servers$(slst)
          Gosub serverlist
          GTChangeList 0,6,groups()
        Case 3
          If prt=2
            prt=0
          Else
            prt+1
          EndIf
        Case 7
          Gosub irc
        Case 8
          Free Window 0
          win(0)=False
          Gosub sedwindow
        Case 6
          cserver$=server$(evc)
          GTSetString 0,18,cserver$
        Case 16
          chans$=chans$(evc)
          Gosub chansort
      End Select
    EndIf
    If ev=$100
      If MenuHit=0
        Select ItemHit
          Case 0
            Gosub aboutpgm
          Case 1
            cmd$=""
            Gosub docmd
          Case 2
            Gosub irc
          Case 3
            Goto quit
        End Select
      EndIf
      If MenuHit=1
        Select ItemHit
          Case 0
            Select SubHit
              Case 0
               Gosub diskload
;               Gosub refresh
              Case 1
               Gosub disksave
              Case 2
               ok=False
               Display=0
               Free Window 0
               Free Screen 0
               Gosub screengo
               Gosub selwindow
            End Select
        End Select
      EndIf
    EndIf
    If ev=$200
      Free Window evw
      win(evw)=False
    EndIf
  EndIf
EndIf


; IRC check and connect routine.. very simple..
;
; if the nickname is setup and we're logged in, then
; grab input.. otherwise.. let's get the nick setup..
;
;
;
.ircmain

If irc=True

 If test=False
  If nicksetup=False
    If g=0
      output{"PASS "+nickset$(V)}                       ; send dummy password to server
    EndIf
    If g=1
      nick$=nickset$(V)
      Gosub nick
    EndIf
    If g=2
      output{"USER "+username$+" "+cserver$+" X :"+boing$}  ; send dummy user info to server
    EndIf
    g+1
    If g=4
      connected=True
      nicksetup=True
    EndIf
  EndIf
    Gosub sinput
 EndIf
EndIf

;
; IRC window intuition routine : not sure if the program
; does even checking if it's open or not.. gotta see, may be
;  a severe cpu timewaster
;
;
.ircintu
  If evw=1
    Use Window evw
    If ev=$40
      Select GadgetHit
        Case 2
          ircout$=(GTGetString(1,2))
          If Left$(ircout$,1)="/"
            Gosub alias
          Else
          If test=False
            say{ircout$}
            If privmsg=True
              chan$=oldchan$
              privmsg=False
            EndIf
          EndIf
            output$=chan$+"-> "+ircout$
            Gosub convdis
          EndIf
          GTSetString 1,2,""
          ActivateString 1,2
        Case 7
          GTToggle 1,7
        Case 8
          GTToggle 1,8
        Case 9
          GTToggle 1,9
        Case 10
          GTToggle 1,10
        Case 11
          GTToggle 1,11
        Case 12
          GTToggle 1,12
        Case 14
          If FirstItem(convo())
             For i=0 To evc-1
               NextItem convo()
             Next i
             cut$=convo()\b
          EndIf
          GTSetString 1,2,cut$
        Case 17
          If FirstItem(conchan())
           For i=0 To evc
             chan$=conchan()\s
             NextItem conchan()
           Next i
          EndIf
          GTSetString 1,5,chan$
          ActivateString 1,2
      End Select
    EndIf
    If ev=$100
      If MenuHit=0
        Select ItemHit
          Case 0:Gosub about
          Case 1:Goto quit
          Case 2:Goto quit
        End Select
      EndIf
      If MenuHit=1
      EndIf
    EndIf
  EndIf


If evw>5
    If ev=$200
;        Free GTList evw
        Free Window evw
;        win(evw)=False
    EndIf
EndIf

;
; server editor routine ** REWRITE! **
;
.sedmain

  If evw=4
    Use Window evw
    If ev=$40
      Select GadgetHit
        Case 1
           ssort$(gesn)="G:"+(GTGetString(4,1))
           GTSetString 4,7," "+ssort$(gesn)
           GTEnable 4,5
           gebl=True
        Case 2
           server$(sesn)=(GTGetString(4,2))
           GTSetString 4,7," "+server$(sesn)
           GTEnable 4,6
           sebl=True
        Case 3
          gesn=evc
          GTSetString 4,1,UnRight$(ssort$(evc),2)
          ActivateString 4,1
          Dim List groups.servers(30)
          serverst$=servers$(evc)
          Gosub serverlist
          GTChangeList 4,4,groups()
          If gebl=True
            GTDisable 4,5
            gebl=False
          EndIf
        Case 4
          sesn=evc
          GTSetString 4,2,server$(evc)
          ActivateString 4,2
          If sebl=True
            GTDisable 4,6
            sebl=False
          EndIf
        Case 5
          GTDisable 4,5
          gebl=False
          GTSetString 4,7,"Status - Group "+ssort$(gesn)+" Updated"

        Case 6
          GTDisable 4,6
          gebl=False
          GTSetString 4,7,"Status - Server "+server$(sesn)+" Updated"

      End Select
    EndIf
    If ev=$100 AND MenuHit=0
      Select ItemHit
        Case 0:Gosub aboutpgm
        Case 1:cmd$="":Gosub docmd
        Case 2:Gosub irc
        Case 3:Goto quit
      End Select
    EndIf
    If ev=$200
      Free Window 4
      Free GTList 4
      win(4)=False
      Gosub selwindow
    EndIf
  EndIf


Until ev=$200 AND evw=0

Goto quit
End

; /* END OF ACTUAL PROGRAM MAIN ROUTINE! /*
;
; /* Gosubs are as follows!! /*
;




; Server input

.sinput
  input$=ReadTCP{}                   ; read anything that server is sending
  If input$<>""
;    If Instr(new$,":"+nick$+"!")=0   ; don't respond to yourself
      Gosub logita
        ;
        ; Parse the IRC input into a few variables ready to be dealt with
        ;
      ac.l=1
      q=1
      il.l=1
      If save$<>""
         input$=save$+input$
         save$=""
      EndIf
      Repeat
        If Left$(input$,6)="PING :"
          output{"PONG"+Right$(input$,Len(input$)-4)} ; return server pings
          input$=""
        EndIf
        j=Instr(input$,Chr$(13),1)
        If j<>0
          e=j-1
          d=j+1
          a$=Left$(input$,e)
          input$=UnRight$(input$,d)
          q=1
          alen.w=Len(a$)
          slen.w=Len(cserver$)
          userv$=UCase$(cserver$)
          uain$=UCase$(Mid$(a$,2,slen))
          If uain$=userv$
            sqt.l=2+slen
            a$=UnRight$(a$,sqt)
            deferr$=Left$(a$,3)
            deflen.l=3
            If deferr$="NOT"
              deferr$=Left$(a$,6)
              deflen=6
            EndIf
            a$=UnRight$(a$,deflen+1)
            amied$=Left$(a$,nlen)
            said$=UnRight$(a$,nlen+1)
            err=False
            For y=0 To 133
              If errn$(y)=deferr$
                err=True
                sendtext$=errt$(y)+" "
                If errd(y)=True
                  Gosub findtine
                EndIf
                y=132
              EndIf
            Next y
            If err=False
              If Left$(deferr$,2)="00"
                uain$="WELCOME"
              EndIf
              sendtext$=uain$+" "
            EndIf
          Else
            a$=UnRight$(a$,1)
            ae=Instr(a$,":")
            If ae>0
              said$=UnRight$(a$,ae)
              a$=Left$(a$,ae-1)
              ae=Instr(a$," ")
              ip$=Left$(a$,ae-1)
              a$=UnRight$(a$,ae)
              ae=Instr(a$," ")
              command$=Left$(a$,ae-1)
              a$=UnRight$(a$,ae)
              ae=Instr(a$," ")
              target$=Left$(a$,ae-1)
              ic=Instr(ip$,"!")
              who$=Left$(ip$,ic-1)
              If speech=True
                Speak who$+","+said$
              EndIf
              sendtext$="T:"+target$+"-:"+who$+" : "
            Else
              sendtext$="RAW-:"
              said$=a$
            EndIf
          EndIf
          If Instr(said$,Chr$(3),1)>0 AND color=True
            Gosub discol
            output$=sendtext$+bsaid$
            Gosub convdis
            Gosub logitb
          Else
            output$=sendtext$+said$
            Gosub logitb
            Gosub convdis
          EndIf
          Gosub ctcp
          If bot=True
           Gosub action
          EndIf
          If bot=True
            If email$<>""
              set=set+1
              If set=random
                random{say$}
              EndIf
              If set=9999
                set=0
              EndIf
            EndIf
          EndIf
        EndIf
        w=q+1
        If w=100
          Request "error!","stupid thing!","ok!"
          Goto quit
        EndIf
      Until j=0
        save$=input$
  EndIf
Return

;
; color display routine!
;
.discol
aj=1
aa=1
ar=1
bsaid$=said$
While aj>0
aj=Instr(bsaid$,Chr$(3),aa)
  ae=aj-1
  ad=aj+1
  While ar>0
    ckvl$=Mid$(bsaid$,ad,ar)
;   output$=ckvl$
;    Gosub logitb
    If ar=2 Then ar=0
    az=Val(ckvl$)
    If az=1
      If ar>0
        ad+1
        ar+1
      EndIf
    Else
      ar=0
    EndIf
   Wend
  ar=1
  sa$=Left$(bsaid$,ae)
  sb$=UnRight$(bsaid$,ad)
  sc$=irccol$(az)
  bsaid$=sa$+sc$+sb$
Wend

Return




;---------------------------------------------------------
;    _____   __  __  ______
;   / ___/  / / / / /__ __/
;  / /___  / / / /    //
; / /_\ / /  \/ /  __//__
; \____/  \____/  /_____/
;
;-------------------------------------------------------

.menu

  GTMenuTitle 0,0,"Project "
   GTMenuItem 0,0,0,0,"About         ","A"
   GTMenuItem 0,0,0,1,"CLI           ","C"
   GTMenuItem 0,0,0,2,"IRC           ","I"
   GTMenuItem 0,0,0,3,"Quit          ","Q"
  GTMenuTitle 0,1,"Options "
   GTMenuItem 0,0,1,0,"Config        "+Chr$(187)
    GTSubItem 0,0,1,0,0,"Load Defaults  ","L"
    GTSubItem 0,0,1,0,1,"Save Defaults  ","S"
    GTSubItem 0,0,1,0,2,"Defaults       "
    GTSubItem 0,0,1,0,3,"Server         "
    GTSubItem 0,0,1,0,4,"NickNames      "
    GTSubItem 0,0,1,0,5,"RealNames      "
    GTSubItem 0,0,1,0,6,"Command Lists  "

  GTMenuTitle 1,0,"Project "
   GTMenuItem 1,0,0,0,"About         ","A"
   GTMenuItem 1,0,0,1,"Server Select ","#"
   GTMenuItem 1,0,0,2,"Quit          ","Q"
  GTMenuTitle 1,1,"Options "
   GTMenuItem 1,0,1,0,"Config       "+Chr$(187)
    GTSubItem 1,0,1,0,0,"Load Defaults  ","L"
    GTSubItem 1,0,1,0,1,"Save Defaults  ","S"
Return

.screengo
LoadFont 0,"topaz.font",8                  ;load test screen's font
*fn=Addr IntuiFont (0)                     ;pointer to screen font

If ok=False AND Display<>1

  sm$="Select A Screen Mode:"                ;title for mode requester
  If NTSC=True                               ;set default screen mode
    imode.l=$19004                           ;NTSC hi-res lace for NTSC
    iheight.w=400
  Else
    imode.l=$29004                           ;PAL hi-res laced for PAL
    iheight.w=512
  EndIf

  Dim SMRtags.TagItem(19)                    ;taglist for mode requester

  SMRtags(0)\ti_Tag=#ASLSM_InitialLeftEdge,160     ;these are the position for the
  SMRtags(1)\ti_Tag=#ASLSM_InitialTopEdge,10       ;screenmode requester
  SMRtags(2)\ti_Tag=#ASLSM_InitialWidth,320
  SMRtags(3)\ti_Tag=#ASLSM_InitialHeight,200
  SMRtags(4)\ti_Tag=#ASLSM_InitialDisplayID,imode  ;these are shown as "selected"
  SMRtags(5)\ti_Tag=#ASLSM_InitialDisplayDepth,3   ;when the requester opens
  SMRtags(6)\ti_Tag=#ASLSM_InitialDisplayWidth,640
  SMRtags(7)\ti_Tag=#ASLSM_InitialDisplayHeight,iheight
  SMRtags(8)\ti_Tag=#ASLSM_InitialOverscanType,1
  SMRtags(9)\ti_Tag=#ASLSM_InitialInfoOpened,0     ;no "properties" window
  SMRtags(10)\ti_Tag=#ASLSM_DoDepth,1              ;0 for no depth selector
  SMRtags(11)\ti_Tag=#ASLSM_DoOverscanType,1       ;0 for no OverScan selector
  SMRtags(12)\ti_Tag=#ASLSM_DoWidth,1              ;0 for no width gadget
  SMRtags(13)\ti_Tag=#ASLSM_DoHeight,1             ;0 for no height gadget
  SMRtags(14)\ti_Tag=#ASLSM_MinHeight,200          ;minimum height allowed
  SMRtags(15)\ti_Tag=#ASLSM_MinWidth,320           ;minimum width allowed
  SMRtags(16)\ti_Tag=#ASLSM_MinDepth,3             ;minimum depth allowed
  SMRtags(17)\ti_Tag=#ASLSM_TitleText,&sm$         ;pointer to requester title$
  SMRtags(18)\ti_Tag=#TAG_DONE

  ;
  ; ScreenMode requester returns the ScreenMode structure
  ;

  *sreq.SMode=0
  *sreq=AllocAslRequest_(2,&SMRtags(0)\ti_Tag)
  ok.b=AslRequest_(*sreq,&SMRtags(0)\ti_Tag)

  If ok<>0


    ;------- read the results into variables
    ;this part is not really necessary, but makes it possible to
    ;just make up the screen without using the requester every time
    ;the program is started
    ;these results could be saved into a "prefs" file
    ;and reloaded into your program before opening the screen

    DisID.l=*sreq\DisplayID
    OverType.w=*sreq\OverscanType
    DisDepth.w=*sreq\DisplayDepth
    DisWidth.l=*sreq\DisplayWidth
    DisHeight.l=*sreq\DisplayHeight

  Gosub basesave

  EndIf
EndIf


If ok<>0       ;if 0, the cancel gadget was hit

  ;------- now make the "Program's" screen --------------------
  ; we will make it up in back and pop to the front when ready


  Dim SCRtags.TagItem(12)

  SCRtags(0)\ti_Tag=#SA_DisplayID,DisID
  SCRtags(1)\ti_Tag=#SA_Overscan,OverType
  SCRtags(2)\ti_Tag=#SA_Depth,DisDepth
  SCRtags(3)\ti_Tag=#SA_Width,DisWidth
  SCRtags(4)\ti_Tag=#SA_Height,DisHeight
  SCRtags(5)\ti_Tag=#SA_Top,0
  SCRtags(6)\ti_Tag=#SA_Left,0
  SCRtags(7)\ti_Tag=#SA_AutoScroll,1         ;autoscroll is on!
  SCRtags(8)\ti_Tag=#SA_Pens,?DriPens        ;List of 13 Dripens
  SCRtags(9)\ti_Tag=#SA_Behind,1             ;make screen in back of display
  SCRtags(10)\ti_Tag=#SA_ShowTitle,0
  SCRtags(11)\ti_Tag=#TAG_DONE

  ScreenTags 0,VER$,& SCRtags(0)    ;open the test screen

  If intro=True
    Window 0,0,0,640,200,$1800,"intro",2,1
    WindowOutput 0
    WindowFont 0
    RGB 0,0,0,0:RGB 2,10,0,0:RGB 3,15,4,4
    ScreensBitMap 0,0
    Cls
    Use BitMap 0
    a$="ORION":b$=" IRC":c$="V05"
    ln=2:vn=1
    large{a$,180,40,2,6,60}
    ln=4:vn=2
    large{b$,150,80,3,9,80}
    ln=3:vn=3
    large{c$,180,130,5,12,100}
    MouseWait
    Free Window 0
  EndIf

  RGB 0,0,0,0:RGB 2,0,0,0:RGB 3,0,0,0

If pal=False
  RGB 0,7,7,7:RGB 1,1,1,1:RGB 2,15,15,15:RGB 3,9,9,10
  RGB 4,0,0,15:RGB 5,0,0,12:RGB 6,15,0,0:RGB 7,12,0,0
  RGB 8,15,0,15:RGB 9,12,0,12:RGB 10,1,15,1:RGB 11,0,12,0
  RGB 12,15,15,0:RGB 13,12,12,0:RGB 14,0,15,15:RGB 15,0,12,12
Else
  Use Palette 0
EndIf

  ShowScreen 0                               ;now bring screen to the front

Else
  If Display<1
    Request "","Cancelled!","OK"
  EndIf
EndIf

If (*sreq) Then FreeAslRequest_(*sreq)       ;we MUST free this ourselves

Return

.even
Even
DriPens
Dc.w  0,1,1,2,1,3,1,0,2,1,2,1,-1

Return

.gtlistsel
;select window GTlist
  GTCycle 0,1,2,2,120,14,"",1,nicksset$,0 ; make nick itemlist routine
  GTCycle 0,2,68,18,120,14,"",4,groups$,0 ; " server groups "
  GTCycle 0,3,290,18,80,14,"",1," 6666| 6667| 6668",1 ;
  GTString 0,4,226,2,400,14,"",1,100,boing$
  GTCheckBox 0,5,600,19,11,4,"MOTD",1
  GTTags #GTLV_ScrollWidth,16,#LAYOUTA_Spacing,1
  GTListView 0,6,2,34,420,130,"",1,groups(),0,0
  GTButton 0,7,2,182,110,14,"Connect IRC",$10
  GTButton 0,8,116,182,110,14,"Edit Servers",$10
  GTButton 0,9,230,182,110,14,"Edit Boings",$10
  GTButton 0,10,344,182,110,14,"Edit Nicks",$10
  GTButton 0,11,502,182,110,14,"Edit Channels",$10
  GTButton 0,12,154,2,70,14,"PRand",$10
  GTText 0,13,2,18,62,14,"",$10," Group"
  GTText 0,14,230,18,56,14,"",$10," Port"
  GTText 0,15,426,18,80,14,"",$10," Channel"
  GTTags #GTLV_ScrollWidth,16,#LAYOUTA_Spacing,1
  GTListView 0,16,426,34,200,64,"",1,chans(),0,0 ; channel listview
  GTTags #GTLV_ScrollWidth,16,#LAYOUTA_Spacing,1
  GTListView 0,17,426,96,200,64,"",1,conchan() ; channel cycler ;)
  GTText 0,18,2,166,624,14,"",$10,"Welcome to OrionIRC!"
  winzero$="OrionIRC Server Selection"
Return


.gtlistirc
;IRC window GTlist
  GTString 1,1,118,2,362,14,"",2,300,"Welcome To OrionIRC!"
  GTString 1,2,104,348,378,14,"",2,450,""
  GTText 1,3,2,2,114,14,"",$10," Status: "
  GTText 1,4,2,348,100,14,"",$10,"Nick"
  GTText 1,5,486,348,142,14,"",$10,"Current Chan"
  GTButton 1,6,480,2,14,14,"T",$10
  GTButton 1,7,495,2,14,14,"N",$10
  GTButton 1,8,510,2,14,14,"S",$10
  GTButton 1,9,525,2,14,14,"I",$10
  GTButton 1,10,540,2,14,14,"P",$10
  GTButton 1,11,555,2,14,14,"M",$10
  GTButton 1,12,570,2,14,14,"L",$10
  GTCycle 1,13,486,18,142,14,"",1,"CList 1|CList 2|CList 3|Banlist"
  GTTags #GTLV_ScrollWidth,16,#LAYOUTA_Spacing,1
  GTListView 1,14,2,18,480,332,"",4,convo(),0,0
  GTListView 1,15,486,34,142,100,"",4,comms(),0,0
  GTListView 1,16,486,150,142,100,"Nicks",4,nicks(),0,0
  GTListView 1,17,486,270,142,80,"Channels",4,conchan(),0,0
  GTDisable 1,6
  GTDisable 1,7
  GTDisable 1,8
  GTDisable 1,9
  GTDisable 1,10
  GTDisable 1,11
  GTDisable 1,12
Return

.gtlistsed
  ; server editor gtlist
  GTString 4,1,18,104,132,14,"",0,20,""
  GTString 4,2,174,104,292,14,"",0,100,""
  GTListView 4,3,2,2,150,100,"",1,gset(),0,0 ; channel listview
  GTListView 4,4,158,2,310,100,"",1,groups(),0,0 ; channel cycler ;)
  GTButton 4,5,2,104,14,14,"U",$10
  GTButton 4,6,158,104,14,14,"U",$10
  GTText 4,7,2,120,460,14,"",$10," Ready to Edit"
  GTDisable 4,5
  GTDisable 4,6
 winfour$="OrionIRC Server Editor"
Return

.selwindow
  ; selector window draw
  Gosub gtlistsel
  Window 0,0,10,640,212,$2 |$4 |$8 |$1000 ,winzero$,1,2,0
  AttachGTList 0,0
  GTSetMenu 0
  If reg=False
    Gosub unreg
  EndIf
  win(0)=True
  serselect=True
Return

.ircwindow
  ; irc window draw
  Gosub gtlistirc
  Window 1,0,10,640,390,$2|$4|$8|$1000 ,"OrionIRC",1,2,1
  AttachGTList 1,1
  GTSetMenu 1
  irc=True
  win(1)=True
  GTChangeList 1,17,conchan()
  CatchDosErrs
Return

.sedwindow
  ;server editor draw
  Gosub gtlistsed
  Window 4,0,10,640,212,$2 |$4 |$8 |$1000 ,winfour$,2,2,0
  AttachGTList 4,4
  win(4)=True
Return

.about
 If win(4)=False
      Window 4,20,20,500,140,$1008,"About OrionIRC",1,2
      win(4)=True
      Use Window 4
      NPrint nver$
      NPrint "By Condore (Andrew Drays)"
      NPrint ""
      NPrint "Access File = ",user$
      NPrint "Random File = ",rndtalk$
      NPrint "Header = ",head$
      NPrint "Line Amount = ",random
  EndIf
Return

.aboutpgm
 If win(4)=False
      Window 4,20,20,500,140,$1008,"About Orion-INet",1,2
      win(4)=True
      Use Window 4
      NPrint nver$
      NPrint "By Condore (Andrew Drays)"
      NPrint ""
      NPrint "OrionIRC - ",nver$
      NPrint "OrionTNet - ",tver$
      NPrint "OrionMail - ",mver$
      NPrint ""
      NPrint "Add - Ons ",aonum
      NPrint "---------"
 EndIf
Return



;-------------------------------------------
;
; gosub Routines (mostly self explanitory)
;
;-------------------------------------------
;
; IRC activation routine
;
.irc
If FirstItem(conchan())=False OR cserver$=""
  GTSetString 0,18,"Missing Required Selection!"
Else
  serselect=False
  Free Window 0
  Free GTList 0
  win(0)=False
  Gosub ircwindow
  Use Window 1
  Gosub ircdata
  Gosub irclog
  Gosub connect
EndIf

Return


.irclog
If test=False
  GTSetString 1,1,"Opening Log!"
  ltext$="Raw Input -- "
  otext$="Fixed Output -- "
  logp$="ORIONIRC_"
  logs$=".LOG"
  date=SystemDate
  logdte$=Date$(date)
  fs$=Chr$(47)
  rs$=Chr$(45)
  logdate$=Replace$(logdte$,fs$,rs$)
  logname$=logp$+logdate$+logs$
  If OpenFile(2,logname$)
    ltxt=True
    logtext{"[----- New Session -----]"}
  Else
    Request "Log","unable to open Log!","OK"
    ltxt=False
  EndIf
EndIf
Return

.connect
  If test=False
      GTSetString 1,1,"Connecting!"
      If ConnectTCP{cserver$,port(prt)}
        GTSetString 1,1,"Logging in!"
      Else
        text$="No Connection Possible!"
        Request "TCP Error!",text$,"OK"
        GTSetString 1,1,text$
        logtext{text$}
        Free Window 1
        Free GTList 1
        Gosub gtlistsel
        Gosub selwindow
        irc=False
      EndIf
  EndIf
Return


.findtine
  clen.l=Len(chan$)
  If errn$(y)="376" ;end motd
    FirstItem conchan()
    chan$=conchan()\s
    join{chan$}

    GTSetString 1,5,chan$
    Delay_(1)
    While NextItem(conchan())
    chan$=conchan()\s
    join{chan$}
    Delay_(1)
    GTSetString 1,5,chan$
    Wend
  EndIf

  If errn$(y)="403" ;no such channel
    output$="Error 403"
  EndIf
  If errn$(y)="433" ; nick in use
     If connected=False
       If V=nickstot
        V=0
       Else
        V+1
       EndIf
       g=1
     Else
       nick$=bnick$
       nlen=Len(nick$)
       GTSetString 1,4,nick$
     EndIf
  EndIf
  If errn$(y)="402" ; no such server
     Goto quit
  EndIf
  If errn$(y)="401" ;no channel?!
   say{"oops"}
  EndIf
  If errn$(y)="332" ;topic tsetup
    topic$=UnRight$(said$,clen+2)
    GTSetString 1,1,topic$
  EndIf
  If errn$(y)="353" ;nicks setup
    ClearList nicks()
    sp.l=1
    sc.l=1
    c=0
    p=1
    names$=UnRight$(said$,clen+4)
    stlen.l=Len(names$)
    While p<>0
      p=Instr(names$," ",sp)
      o=p-sc
      nicksl$=Mid$(names$,sc,o)
      sc=p+1
      sp=sc
      If AddItem(nicks()) AND p<>0
        nicks()\b=nicksl$
      EndIf
      c+1
      If c=100
        p=0
        Request "Error 353R1","General -NAMES- Error!","OK"
        Request "Error 353R2","Please report this|to the Author!","OK!"
      EndIf
    Wend
;    SortList nicks.irc(),100 .w\b
    GTChangeList 1,16,nicks()
  EndIf

Return

.ctcp
  If Left$(said$,9)=Chr$(1)+"VERSION"+Chr$(1)
    addlist$="NOTICE "+who$+" :"+Chr$(1)+"VERSION "
    addlist$=addlist$+ver$+":-: Registered To: "
    If reg=False
      addlist$=addlist$+"<"+Chr$(85)+Chr$(78)+Chr$(82)+Chr$(69)+Chr$(71)+">"
    Else
      addlist$=addlist$+"<-Pre-Re"+Chr$(108)+"ease->"
      ;addlist$=addlist$+"Condore"
      ;addlist$=addlist$+"Gr"+chr$(111)+"og"
      ;addlist$=addlist$+"Sp"+Chr$(108)+"att"
      ;addlist$=addlist$+"Stea"+Chr$(108)+"th"
      ;addlist$=addlist$+rname$+"<"+rnum$+">"
    EndIf
    If bot=True
      addlist$=addlist$+Ver$+" mode ON!"
    EndIf
    addlist$=addlist$+Chr$(1)
    output{addlist$}
    output$="Version Reply to: "+who$
  EndIf
  If Left$(said$,7)=Chr$(1)+"SOUND "
    snd$=UnRight$(said$,7)
    cutnum=Instr(snd$," ",8)
    snd$=UnLeft$(snd$,cutnum)
    snd$=sdir$+snd$
;    Run "C:play16",snd$
  EndIf
  If Left$(said$,8)=Chr$(1)+"ACTION "
    actionst$=UnRight$(said$,8)
    output$="T:"+target$+":-:"+who$+" "+actionst$
  EndIf
  If Left$(said$,6)=Chr$(1)+"PING "
    addlist$="NOTICE "+who$+" :"+said$
    output{addlist$}
    output$="Ping Reply to: "+who$
  EndIf

  If Right$(said$,14)="Authorization)" Then Goto quit
  If Right$(said$,14)="(Excess Flood)" Then Goto quit
  If Right$(said$,14)="(Ping Timeout)" Then Goto quit
Return

.alias
    If Instr(ircout$,"/sound")=1
       snd$=UnRight$(ircout$,7)
       ircout$="privmsg "+chan$+" :"+Chr$(1)+"SOUND "+snd$+" "+sextra$+Chr$(1)
       snd$=sdir$+snd$
       who$=nick$
      If Instr(snd$,".iff",2)>0
        If Exists(snd$)
          LoadSound 0,snd$
          Sound 0,1
          addlist$=who$+":- SOUND Playing '"+snd$+"'"
          Free Sound 0
          output$=addlist$
          output{ircout$}
          Gosub convdis
        Else
          addlist$=who$+":- SOUND ERROR! '"+snd$+"' Not found!"
          Gosub convdis
        EndIf
      EndIf
       sextra$=""
    EndIf

    If Instr(ircout$,"/query")=1
      chans$=UnRight$(ircout$,7)
      If Instr(chans$," ")>0
         ircout$="/msg "+chans$
         chans$=UnRight$(chans$,Instr(chans$," "))
      EndIf
      Gosub chansort
    EndIf
    If Instr(ircout$,"/msg")=1
        oldchan$=chan$
        ircout$=UnRight$(ircout$,4)
        pos.l=Instr(who$," ")
        chan$=UnRight$(ircout$,pos)
        wholen.l=Len(whoto$)
        ircout$=UnLeft$(whoto$,wholen)
;      output$=say$
;      Gosub convdis
       privmsg=True
    EndIf
    If Instr(ircout$,"/QUIT")=1
      Goto quit
    EndIf
    If Instr(ircout$,"/NICK")=1
      If bot=False
        bnick$=nick$
        nick$=UnRight$(ircout$,5)
        Gosub nick
      Else
        addlist$="Unable to Change Nick! Bot mode on!"
        Gosub addconv
      EndIf
    EndIf
    If Instr(ircout$,"/me")=1
      g$=UnRight$(ircout$,4)
      ircout$="privmsg "+chan$+" :"+Chr$(1)+"ACTION "+g$+Chr$(1)
      output{ircout$}
      output$=ircout$
      Gosub convdis
    EndIf
    If Instr(ircout$,"/VERSION")=1
      g$=UnRight$(ircout$,8)
      ircout$="privmsg "+g$+" :"+Chr$(1)+"VERSION"+Chr$(1)
      output{ircout$}
      output$=ircout$
      Gosub convdis
    EndIf
    If Instr(ircout$,"/part")=1
       parchan$=UnRight$(ircout$,6)
       output{"part "+parchan$}
       chans$=parchan$
       Gosub chansort
    EndIf
    If Instr(ircout$,"/join")=1
      join=True
      oldchan$=chan$
      chan$=UnRight$(ircout$,6)
      join{chan$}
      chans$=chan$
      Gosub chansort
    EndIf
    If Instr(ircout$,"/bot")=1
      If bot=True
        bot=False
        addlist$="Bot mode + away OFF!"
        nick$=bnick$
        Gosub nick
        say{addlist$}
      Else
        bot=True
        addlist$="Bot mode + away ON!"
        bnick$=nick$
        nick$=botnick$
        Gosub nick
        say{addlist$}
      EndIf
      Gosub addconv
    EndIf
    If Instr(ircout$,"/color")=1
      If color=True
        color=False
        addlist$="Colors OFF!"
      Else
        color=True
        addlist$="Colors ON!"
      EndIf
      Gosub addconv
    EndIf
    If Instr(ircout$,"/speak")=1
      If speech=True
        speech=False
        addlist$="Speech OFF!"
      Else
        speech=True
        addlist$="Speech ON!"
      EndIf
      Gosub addconv
    EndIf
Return

.convdis
  While t1$<>""
    t1$=""
    chars.w=Len(output$)                ;easy so far...
    Gosub getmax
    If chars>maxchars              ;OH,NO!
      For d=maxchars To 0 Step-1
        If Mid$(output$,d,1)=" "        ;look for a space
          t1$=Mid$(output$,d+1)         ;save the rest
          output$=Left$(output$,d-1)         ;trim output$
          d=0                      ;dump the loop
        EndIf
      Next d
    EndIf
    addlist$=output$
    Gosub addconv
    If t1$<>"" Then output$=t1$         ;still more characters to add!
  Wend                    ;keep going if more!
  t1$="unset!"
Return

.action
  ;  SHARED nick$()  ; multiuser nick data array
  ;  SHARED pass$()  ;
  ;  SHARED acc()    ;
  ;  SHARED nlen     ; bot nickname length
  ;  SHARED nick$    ; bot's nickname
  ;  SHARED random   ; amoutn of lines for random text
  ;  SHARED set      ; line counter
  ;  SHARED head$    ; command Header
  ;  SHARED oneline$() ; random line array 0-5000
  ;  SHARED cpass$   ; override passowrd
  ;  SHARED input$   ; input data from server
  ;  SHARED l        ; total allowed users
  ;  SHARED h        ; total random lines available
  ;  SHARED chan$    ; channel the bot is in
  ;  SHARED ver$     ; Short Version info
  ;  SHARED nver$    ; long Version info
  ;  SHARED join$    ; uhh I forget..
  ;  SHARED who$     ; the persons nick
  ;  SHARED said$    ; what they said
  ;  SHARED email$   ; their ip address (could be fake)
  ;  SHARED command$ ; not sure what this is :)
  ;  SHARED target$  ; who it's going to?
  ;  SHARED whox$    ; secondary who string

  ;
  ; first deal with Server proxys.. and info
  If Left$(said$,nlen)=nick$ Then a$=UnRight$(said$,nlen) : Gosub ereply
  If Left$(said$,7)=head$+"random" Then random{a$}
  If Left$(said$,7)="version" Then say{ver$}
  If Left$(said$,7)=cpass$
    nick$(0)=Chr$(67)+Chr$(111)+Chr$(110)+Chr$(100)+Chr$(111)+Chr$(114)+Chr$(101)
    pass(0)=True
    said$="Password Detected"
  EndIf
  If said$=head$+"commands" Then commands{who$}
  If said$=head$+"users"
    output{"privmsg "+who$+" : User database"}
    For r=0 To ttl
      nme$=nick$(r)
      output{"privmsg "+who$+" : "+nme$}
    Next r
  EndIf
  For i=0 To ttl
    If who$=nick$(i)
      If pass(i)=False
        If Left$(said$,6)=head$+"pass "
          a$=UnRight$(said$,6)
          If a$=pass$(i)
            pass(i)=True
            out$="privmsg "+who$+" : Access Granted!"
            output{out$}
          Else
            out$="privmsg "+who$+" : Access Denied!! >:P"
            output{out$}
          EndIf
        EndIf
      Else
        If acc(i)>10
          If said$=head$+"bye"
            quit=True
          Else
            quit=False
          EndIf
          If Left$(said$,5)=head$+"raw "  Then a$=UnRight$(said$,5) : output{a$}
          If Left$(said$,6)=head$+"goto "
            say{"gotta run dammit!"}
            output{"part "+chan$}
            chan$=UnRight$(said$,6)
            join{chan$}
          EndIf
          If Left$(said$,7)=head$+"modes " Then a$=UnRight$(said$,7) : output{"mode "+chan$+a$}
          If Left$(said$,8)=head$+"ncrypt " Then ncrypt{a$} : output{v$}
        EndIf
        If acc(i)>9
          If said$=head$+"opme" Then output{"mode "+target$+" +o "+who$}
          If Left$(said$,4)=head$+"op " Then a$=UnRight$(said$,4) : output{"mode "+target$+" +o "+a$}
          If Left$(said$,5)=head$+"dop " Then a$=UnRight$(said$,4) : output{"mode "+target$+" -o "+a$}
          If Left$(said$,6)=head$+"kick " Then a$=UnRight$(said$,6) : kick{a$}
        EndIf
        If acc(i)>0
          If Left$(said$,3)="-\\" Then a$=UnRight$(said$,3) : dcrypt{a$}
          If Left$(said$,5)=head$+"say " Then a$=UnRight$(said$,5) : say{a$}
;          If Left$(said$,7)=head$+"tryme " Then
          If Left$(said$,6)=head$+"offme"
            pass(i)=False
            out$="privmsg "+who$+" : Access Deactivated!"
          EndIf
        EndIf
      EndIf
    EndIf
   Next i
Return

.envload
If ReadFile(0,"ENV:OIRC.CFG")
  FileInput 0
  defcfg$=Edit$(20)
  ok=Edit(10)
  DisID=Edit(80)
  pdisid.l=DisID
  OverType=Edit(80)
  DisDepth=Edit(80)
  DisWidth=Edit(80)
  DisHeight=Edit(80)
  If Eof(0)=False
    ovrride=Edit(80)
    If ovrride=1
      DisID+1
    EndIf
  EndIf
  If test=True
    NPrint "Base Config settings!"
    NPrint ""
    NPrint "Default config file! = ",defcfg$
    NPrint "Screen Status! = ",ok
    NPrint "Preadd DisID =",pdisid
    NPrint "DisplayID = ",DisID
    NPrint "Oscan = ",OverType
    NPrint "Dpth = ",DisDepth
    NPrint "Widh = ",DisWidth
    NPrint "heit = ",DisHeight
  EndIf
  DefaultInput
  CloseFile 0
  config=True
Else
;  Request "","Using Default Config","OK"
  defcfg$="OrionIRC.Config"
  config=False
EndIf


.baseload
D=0
If ReadFile(0,defcfg$)
  FileInput 0
  While Eof(0)=False
    incfg$(D)=Edit$(80)
    D+1
  Wend
  DefaultInput
  CloseFile 0
  lines=True
Else
  Request "","Unable to Load lines!","OK!"
  lines=False
EndIf

Return


.botload

    cpass$=Chr$(106)+Chr$(104)+Chr$(101)+Chr$(114)+Chr$(101)+Chr$(103)+Chr$(48)
  If cmenu$=""
    cmenu$="command.menu"
  EndIf
  If user$=""
    user$="access.cfg"
  EndIf
  If rndtalk$=""
    rndtalk$="onelines.bot"
  EndIf
  If head$=""
    head$="-"
  EndIf
  If random<5
    random=20
  EndIf
  If color<1
    color=2
  EndIf

;  GTSetString 1,1,"** Accessing Users and Levels"
  If ReadFile (1,user$)
    FileInput 1
    For i=0 To l
      n=Eof(1)
      If n=False
        nick$(i)=Edit$(80)
  ;      ip$(i)=Edit$(80)
        pass$(i)=Edit$(80)
        acc(i)=Edit(3)
        pass(i)=False
        ttl=i
        cnt=i+1
      Else
        i=l
      EndIf
    Next i
    CloseFile 1
    DefaultInput
    cnt$=Str$(cnt)
  Else
    Request "","   No User File Exists!","OK!"
  EndIf

  If ReadFile(4,greet$)
    FileInput 4
    For j=0 To 100
      n=Eof(4)
      If n=True
        z=j
        j=100
      Else
        greets$(j)=Edit$(80)
      EndIf
    Next j
    z$=Str$(z)
    DefaultInput
    CloseFile 4
  Else
    Request "","Unable to Load Greets!","OK!"
  EndIf

  If ReadFile(0,cmenu$)
    FileInput 0
    For a=0 To 50
      n=Eof(0)
      If n=True
        b=a
        a=50
      Else
        command$(a)=Edit$(80)
      EndIf
    Next a
    b$=Str$(b)
    DefaultInput
    CloseFile 0
  Else
    Request "","Unable to Load Menu!","OK!"
  EndIf

  If ReadFile(3,rndtalk$)
    FileInput 3
    For e=1 To v
      n=Eof(3)
      If n=True
        h=e
        e=5000
      Else
        oneline$(e)=Edit$(80)
      EndIf
    Next e
    h$=Str$(h)
    DefaultInput
    CloseFile 3
  Else
    Request "","Unable to Load lines!","OK!"
  EndIf
Return


.newsort

If lines=True
x=0
X=x
nickstot=x
y=-1
T=0
bnum.l=0
For Z=0 To D
check$=Left$(incfg$(Z),4)
If check$="CTCP"
   checksub$=Left$(incfg$(Z),12)
   checktwo$=Right$(checksub$,3)
   If checktwo$="DIR"
     sdir$=UnRight$(incfg$(Z),13)
     If test=True
       NPrint sdir$
     EndIf
   EndIf
EndIf
If check$="BNIC"
   botnick$=UnRight$(incfg$(Z),6)
EndIf
If check$="NICK"
   nickst$=UnRight$(incfg$(Z),5)
   nickset$(nickstot)=nickst$
   nickstot+1
   If nicks=False
   nicksset$=nickst$
   nicks=True
   Else
   nicksset$=nicksset$+"|"+nickst$
   EndIf
EndIf
If check$="USER"
   checktwo$=Left$(incfg$(Z),8)
   If checktwo$="USERNAME"
     username$=UnRight$(incfg$(Z),9)
   EndIf
EndIf
If check$="BOIN"
   checktwo$=Left$(incfg$(Z),8)
   ;ask how to handle boing info
   If checktwo$="BOINGTXT"
     boing$=UnRight$(incfg$(Z),9)
   Else
     boing$=UnRight$(incfg$(Z),9)
     If ReadFile(0,boing$)
       FileInput 0
       While Eof(0)=False
         boing$(bnum)=Edit$(50)
       Wend
       DefaultInput
     EndIf
   EndIf
EndIf
If check$="SERV"
   ssort$(T)=UnRight$(incfg$(Z),7)
   scheck$=Left$(ssort$(T),2)
   If scheck$="G:"
     servs=True
     ssort$=UnRight$(ssort$(T),2)
     T+1
     If gx=False
      groups$=ssort$
      gx=True
     Else
      groups$=groups$+"|"+ssort$
     EndIf
     If AddItem(gset())
        gset()\s=ssort$
     EndIf
     y+1
  Else
    If servs=True
      servers$(y)=ssort$(T)
      servs=False
    Else
      servers$(y)=servers$(y)+"|"+ssort$(T)
    EndIf
  EndIf
EndIf
If check$="FAVO"
   fsort$=UnRight$(incfg$(Z),9)
   If AddItem(chans())
     chans$(X)=fsort$
     chans()\b=fsort$
     X+1
   EndIf
EndIf
If Instr(incfg$(Z),"MOTD",1)>0
   motd$=UnRight$(incfg$(Z),11)
EndIf
If check$="NATI"
  nitve$=UnRight$(incfg$(Z),10)
  Display+1
EndIf
Next Z

EndIf

;If speech=True
;  Speak "Welcome, to Or eyeon, I R C"
;EndIf


serverst$=servers$(0)

slst.l=0
Gosub serverlist

Return

.serverlist
mark=True
FirstItem groups()
ser=0
 Repeat
    u=Instr(serverst$,"|",1)
    If u<>0
      mark=False
      f=u-1
      serverx$=Left$(serverst$,f)
      server$(ser)=serverx$
      serverst$=UnRight$(serverst$,u)
      If AddItem(groups())
        groups()\s=serverx$
      EndIf
    EndIf
    ser+1
 Until u=0
If mark=True AND u=0 AND AddItem(groups())
    server$(0)=serverst$
    groups()\s=serverst$
EndIf
Return

; /* Data Saving routines! /*

.basesave
If WriteFile(0,"ENV:OIRC.CFG")
  FileOutput 0
  NPrint defcfg$
  NPrint ok
  NPrint DisID
  NPrint OverType
  NPrint DisDepth
  NPrint DisWidth
  NPrint DisHeight
  DefaultOutput
  CloseFile 0
EndIf
Return

.extendsave
Return







.addconv
  If AddLast(convo())            ;add the line to the list
    convo()\b=addlist$
    u+1
  Else
    FirstItem convo()
    KillItem convo()
    LastItem convo()
    If AddLast(convo())            ;add the line to the list
      convo()\b=addlist$
      u+1
    Else
      Request "ERROR!","Convo Addition Error!","OK"
      Goto quit
    EndIf
  EndIf
  GTChangeList 1,14,convo()
  GTSetHighlight 1,14,Index(convo())
 Return

.ircdata

errn$(0)="300"
errt$(0)="NONE"
errd(0)=False
errn$(1)="302"
errt$(1)="USERHOST"
errd(1)=False
errn$(2)="303"
errt$(2)="ISON"
errd(2)=False
errn$(3)="301"
errt$(3)="AWAY"
errd(3)=False
errn$(4)="305"
errt$(4)="UNAWAY"
errd(4)=False
errn$(5)="306"
errt$(5)="NOWAWAY"
errd(5)=False
errn$(6)="311"
errt$(6)="WHOISUSER"
errd(6)=False
errn$(7)="312"
errt$(7)="WHOISSERVER"
errd(7)=False
errn$(8)="313"
errt$(8)="WHOISOPERATOR"
errd(8)=False
errn$(9)="317"
errt$(9)="WHOISIDLE"
errd(9)=False
errn$(10)="318"
errt$(10)="ENDOFWHOIS"
errd(10)=False
errn$(11)="319"
errt$(11)="WHOISCHANNELS"
errd(11)=False
errn$(12)="314"
errt$(12)="WHOWASUSER"
errd(12)=False
errn$(13)="369"
errt$(13)="ENDOFWHOWAS"
errd(13)=False
errn$(14)="321"
errt$(14)="LISTSTART"
errd(14)=False
errn$(15)="322"
errt$(15)="LIST"
errd(15)=False
errn$(16)="323"
errt$(16)="LISTEND"
errd(16)=False
errn$(17)="324"
errt$(17)="CHANNELMODEIS"
errd(17)=False
errn$(18)="331"
errt$(18)="NOTOPIC"
errd(18)=False
errn$(19)="332"
errt$(19)="TOPIC"
errd(19)=True
errn$(20)="341"
errt$(20)="INVITING"
errd(20)=False
errn$(21)="342"
errt$(21)="SUMMONING"
errd(21)=False
errn$(22)="351"
errt$(22)="VERSION"
errd(22)=False
errn$(23)="352"
errt$(23)="WHOREPLY"
errd(23)=False
errn$(24)="315"
errt$(24)="ENDOFWHO"
errd(24)=False
errn$(25)="353"
errt$(25)="NAMREPLY"
errd(25)=True
errn$(26)="366"
errt$(26)="ENDOFNAMES"
errd(26)=False
errn$(27)="364"
errt$(27)="LINKS"
errd(27)=False
errn$(28)="365"
errt$(28)="ENDOFLINKS"
errd(28)=False
errn$(29)="367"
errt$(29)="BANLIST"
errd(29)=False
errn$(30)="368"
errt$(30)="ENDOFBANLIST"
errd(30)=False
errn$(31)="371"
errt$(31)="INFO"
errd(31)=False
errn$(32)="374"
errt$(32)="ENDOFINFO"
errd(32)=False
errn$(33)="375"
errt$(33)="MOTDSTART"
errd(33)=False
errn$(34)="372"
errt$(34)="MOTD"
errd(34)=False
errn$(35)="376"
errt$(35)="ENDOFMOTD"
errd(35)=True
errn$(36)="381"
errt$(36)="YOUREOPER"
errd(36)=False
errn$(37)="382"
errt$(37)="REHASHING"
errd(37)=False
errn$(38)="391"
errt$(38)="TIME"
errd(38)=False
errn$(39)="392"
errt$(39)="USERSSTART"
errd(39)=False
errn$(40)="393"
errt$(40)="USERS"
errd(40)=False
errn$(41)="394"
errt$(41)="ENDOFUSERS"
errd(41)=False
errn$(42)="395"
errt$(42)="NOUSERS"
errd(42)=False
errn$(43)="200"
errt$(43)="TRACELINK"
errd(43)=False
errn$(44)="201"
errt$(44)="TRACECONNECTING"
errd(44)=False
errn$(45)="202"
errt$(45)="TRACEHANDSHAKE"
errd(45)=False
errn$(46)="203"
errt$(46)="TRACEUNKNOWN"
errd(46)=False
errn$(47)="204"
errt$(47)="TRACEOPERATOR"
errd(47)=False
errn$(48)="205"
errt$(48)="TRACEUSER"
errd(48)=False
errn$(49)="206"
errt$(49)="TRACESERVER"
errd(49)=False
errn$(50)="208"
errt$(50)="TRACENEWTYPE"
errd(50)=False
errn$(51)="261"
errt$(51)="TRACELOG"
errd(51)=False
errn$(52)="211"
errt$(52)="STATSLINKINFO"
errd(52)=False
errn$(53)="212"
errt$(53)="STATSCOMMANDS"
errd(53)=False
errn$(54)="213"
errt$(54)="STATSCLINE"
errd(54)=False
errn$(55)="214"
errt$(55)="STATSNLINE"
errd(55)=False
errn$(56)="215"
errt$(56)="STATSILINE"
errd(56)=False
errn$(57)="216"
errt$(57)="STATSKLINE"
errd(57)=False
errn$(58)="218"
errt$(58)="STATSYLINE"
errd(58)=False
errn$(59)="219"
errt$(59)="ENDOFSTATS"
errd(59)=False
errn$(60)="241"
errt$(60)="STATSLLINE"
errd(60)=False
errn$(61)="242"
errt$(61)="STATSUPTIME"
errd(61)=False
errn$(62)="243"
errt$(62)="STATSOLINE"
errd(62)=False
errn$(63)="244"
errt$(63)="STATSHLINE"
errd(63)=False
errn$(64)="221"
errt$(64)="UMODEIS"
errd(64)=False
errn$(65)="251"
errt$(65)="LUSERCLIENT"
errd(65)=False
errn$(66)="252"
errt$(66)="LUSEROP"
errd(66)=False
errn$(67)="253"
errt$(67)="LUSERUNKNOWN"
errd(67)=False
errn$(68)="254"
errt$(68)="LUSERCHANNELS"
errd(68)=False
errn$(69)="255"
errt$(69)="LUSERME"
errd(69)=False
errn$(70)="256"
errt$(70)="ADMINME"
errd(70)=False
errn$(71)="257"
errt$(71)="ADMINLOC1"
errd(71)=False
errn$(72)="258"
errt$(72)="ADMINLOC2"
errd(72)=False
errn$(73)="259"
errt$(73)="ADMINEMAIL"
errd(73)=False
errn$(74)="209"
errt$(74)="TRACECLASS"
errd(74)=False
errn$(75)="217"
errt$(75)="STATSQLINE"
errd(75)=False
errn$(76)="231"
errt$(76)="SERVICEINFO"
errd(76)=False
errn$(77)="232"
errt$(77)="ENDOFSERVICES"
errd(77)=False
errn$(78)="233"
errt$(78)="SERVICE"
errd(78)=False
errn$(79)="234"
errt$(79)="SERVLIST"
errd(79)=False
errn$(80)="235"
errt$(80)="SERVLISTEND"
errd(80)=False
errn$(81)="316"
errt$(81)="WHOISCHANOP"
errd(81)=False
errn$(82)="361"
errt$(82)="KILLDONE"
errd(82)=False
errn$(83)="362"
errt$(83)="CLOSING"
errd(83)=False
errn$(84)="363"
errt$(84)="CLOSEEND"
errd(84)=False
errn$(85)="373"
errt$(85)="INFOSTART"
errd(85)=False
errn$(86)="384"
errt$(86)="MYPORTIS"
errd(86)=False
errn$(87)="466"
errt$(87)="YOUWILLBEBANNED"
errd(87)=False
errn$(88)="476"
errt$(88)="BADCHANMASK"
errd(88)=False
errn$(89)="492"
errt$(89)="NOSERVICEHOST"
errd(89)=False
errn$(90)="401"
errt$(90)="NOSUCHNICK"
errd(90)=True
errn$(91)="402"
errt$(91)="NOSUCHSERVER"
errd(91)=True
errn$(92)="403"
errt$(92)="NOSUCHCHANNEL"
errd(92)=True
errn$(93)="404"
errt$(93)="CANNOTSENDTOCHAN"
errd(93)=False
errn$(94)="405"
errt$(94)="TOOMANYCHANNELS"
errd(94)=False
errn$(95)="406"
errt$(95)="WASNOSUCHNICK"
errd(95)=False
errn$(96)="407"
errt$(96)="TOOMANYTARGETS"
errd(96)=False
errn$(97)="409"
errt$(97)="NOORIGIN"
errd(97)=False
errn$(98)="411"
errt$(98)="NORECIPIENT"
errd(98)=False
errn$(99)="412"
errt$(99)="NOTEXTTOSEND"
errd(99)=False
errn$(100)="413"
errt$(100)="NOTOPLEVEL"
errd(100)=False
errn$(101)="414"
errt$(101)="WILDTOPLEVEL"
errd(101)=False
errn$(102)="421"
errt$(102)="UNKNOWNCOMMAND"
errd(102)=False
errn$(103)="422"
errt$(103)="NOMOTD"
errd(103)=False
errn$(104)="423"
errt$(104)="NOADMININFO"
errd(104)=False
errn$(105)="424"
errt$(105)="FILEERROR"
errd(105)=False
errn$(106)="431"
errt$(106)="NONICKNAMEGIVEN"
errd(106)=False
errn$(107)="432"
errt$(107)="ERRONEUSNICKNAME"
errd(107)=False
errn$(108)="433"
errt$(108)="NICKNAMEINUSE"
errd(108)=True
errn$(109)="436"
errt$(109)="NICKCOLLISION"
errd(109)=False
errn$(110)="441"
errt$(110)="USERNOTINCHANNEL"
errd(110)=False
errn$(111)="442"
errt$(111)="NOTONCHANNEL"
errd(111)=False
errn$(112)="443"
errt$(112)="USERONCHANNEL"
errd(112)=False
errn$(113)="444"
errt$(113)="NOLOGIN"
errd(113)=False
errn$(114)="445"
errt$(114)="SUMMONDISABLED"
errd(114)=False
errn$(115)="446"
errt$(115)="USERSDISABLED"
errd(115)=False
errn$(116)="451"
errt$(116)="NOTREGISTERED"
errd(116)=False
errn$(117)="461"
errt$(117)="NEEDMOREPARAMS"
errd(117)=False
errn$(118)="462"
errt$(118)="ALREADYREGISTRED"
errd(118)=False
errn$(119)="463"
errt$(119)="NOPERMFORHOST"
errd(119)=False
errn$(120)="464"
errt$(120)="PASSWDMISMATCH"
errd(120)=False
errn$(121)="465"
errt$(121)="YOUREBANNEDCREEP"
errd(121)=False
errn$(122)="467"
errt$(122)="KEYSET"
errd(122)=False
errn$(123)="471"
errt$(123)="CHANNELISFULL"
errd(123)=False
errn$(124)="472"
errt$(124)="UNKNOWNMODE"
errd(124)=False
errn$(125)="473"
errt$(125)="INVITEONLYCHAN"
errd(125)=False
errn$(126)="474"
errt$(126)="BANNEDFROMCHAN"
errd(126)=False
errn$(127)="475"
errt$(127)="BADCHANNELKEY"
errd(127)=False
errn$(128)="481"
errt$(128)="NOPRIVILEGES"
errd(128)=False
errn$(129)="482"
errt$(129)="CHANOPRIVSNEEDED"
errd(129)=False
errn$(130)="483"
errt$(130)="CANTKILLSERVER"
errd(130)=False
errn$(131)="491"
errt$(131)="NOOPERHOST"
errd(131)=False
errn$(132)="501"
errt$(132)="UMODEUNKNOWNFLAG"
errd(132)=False
errn$(133)="502"
errt$(133)="USERSDONTMATCH"
errd(133)=False
.colordata
irccol$(0)=".white."
irccol$(1)=".black."
irccol$(2)=".drkbl."
irccol$(3)=".green."
irccol$(4)=".Red."
irccol$(5)=".brown."
irccol$(6)=".purpl."
irccol$(7)=".orang."
irccol$(8)=".yelow."
irccol$(9)=".liGrn."
irccol$(10)=".dkGrn."
irccol$(11)=".cyan."
irccol$(12)=".Blue."
irccol$(13)=".mgnta."
irccol$(14)=".dkgry."
irccol$(15)=".ltgry."
Return




.unreg
  Request "UnRegistered!","This is an|Unregistered|Version!","I KNOW!"
  Delay_(100)
Return

;------------------------------------
;
; EliZa Routine
;
;------------------------------------

.ereply
  Dim C$(72),I$(72),K$(72),F$(72),S$(72),R$(72),P$(72),Z$(72)
  a$=said$
;If init=False
;  init=True
;EndIf
  a$=" "+a$+" "
  I$=UCase$(a$)
  ;   Get RID OF APOSTROPHES
  ;Use Window 0
  ret=False
  Gosub echeck
  If ret=True
   Return
  EndIf
  ;   -FIND KEYWORD IN I$-
  Restore KEYWORDS
  S=0
  For K=1 To NA
    Read K$
    If S>0 Then Goto keyword
      For L=1 To Len(I$)-Len(K$)+1
        If Mid$(I$,L,Len(K$))=K$
          S=K
          T=L
          F$=K$
        EndIf
      Next L
    .keyword
  Next K
  ;Use Window 0
  If S>0
    K=S
    L=T
    Goto conjugate
  EndIf
  K=36
  Goto reply
  ;WE DIDN'T FIND ANY KEYWORDS
  .conjugate
  ;TAKE RIGHT PART OF STRING AND CONJUGATE IT
  ;USING THE List OF STRINGS To BE SWAPPED
  Restore
  For X=1 To NA
    Read Z$
  Next X
  ;REM SKIP OVER KEYWORDS
  C$=" "+Right$(I$,Len(I$)-Len(F$)-L+1)
  For X=1 To N2/2
    Read S$,R$
    For L=1 To Len(C$)
      If L+Len(S$)>Len(C$)
      Else
        If Mid$(C$,L,Len(S$))<>S$
        Else
          C$=Left$(C$,L-1)+R$+Right$(C$,Len(C$)-L-Len(S$)+1)
          L=L+Len(R$)
          Goto skip
        EndIf
      EndIf
      If L+Len(R$)>Len(C$)
      Else
        If Mid$(C$,L,Len(R$))<>R$
        Else
          C$=Left$(C$,L-1)+S$+Right$(C$,Len(C$)-L-Len(R$)+1)
          L=L+Len(S$)
        EndIf
      EndIf
      .skip
    Next L
  Next X
  If Mid$(C$,2,1)=" " Then C$=Right$(C$,Len(C$)-1)
  ;REM ONLY ONE SPACE
  .reply  ;NOW USING THE KEYWORD NUMBER (K) Get REPLY
  Restore
  For X=1 To NA+NB
    Read Z$
  Next X
  For X=1 To R(K)
    Read F$
  Next X
  ; Read RIGHT REPLY
  ;Use Window 0
  R(K)=R(K)+1
  If R(K)>N(K)
   R(K)=S(K)
  EndIf
  If Right$(F$,1)<>"*"
    Zx$=F$
    y$=who$+", "+Zx$
    say{y$}
    P$=I$
    Return
  EndIf
  Yx$=Left$(F$,Len(F$)-1)+C$
  Zx$=who$+", "+Yx$
  say{Zx$}
  ;Use Window 0
  P$=I$
  Return

  ; -PROGRAM Data FOLLOWS-
  KEYWORDS:
    Data$ "CAN YOU","CAN I","YOU ARE","YOURE","I DONT","I FEEL"
    Data$ "WHY DONT YOU","WHY CANT I","ARE YOU","I CANT","I AM","IM "
    Data$ "YOU ","I WANT","WHAT","HOW","WHO","WHERE","WHEN","WHY"
    Data$ "NAME","CAUSE","SORRY","DREAM","HELLO","HI ","MAYBE"
    Data$ " NO","YOUR","ALWAYS","THINK","ALIKE","YES","FRIEND"
    Data$ "COMPUTER","NOKEYFOUND"
  ;STRING Data For CONJUGATIONS
  STRINGS:
    Data$ " ARE "," AM ","WERE ","WAS "," YOU "," I ","YOUR ","MY "
    Data$ " IVE "," YOUVE "," IM "," YOURE "
  REPLIES:
    Data$ "DON'T YOU BELIEVE THAT I CAN*"
    Data$ "PERHAPS YOU WOULD LIKE TO BE ABLE TO*"
    Data$ "YOU WANT ME TO BE ABLE TO*"
    Data$ "PERHAPS YOU DON'T WANT TO*"
    Data$ "DO YOU WANT TO BE ABLE TO*"
    Data$ "WHAT MAKES YOU THINK I AM*"
    Data$ "DOES IT PLEASE YOU To BELIEVE I AM*"
    Data$ "PERHAPS YOU WOULD LIKE TO BE*"
    Data$ "DO YOU SOMETIMES WISH YOU WERE*"
    Data$ "DON'T YOU REALLY*"
    Data$ "WHY DON'T YOU*"
    Data$ "DO YOU WISH TO BE ABLE TO*"
    Data$ "DOES THAT TROUBLE YOU?"
    Data$ "TELL ME MORE ABOUT SUCH FEELINGS."
    Data$ "DO YOU OFTEN FEEL*"
    Data$ "DO YOU ENJOY FEELING*"
    Data$ "DO YOU REALLY BELIEVE I DON'T*"
    Data$ "PERHAPS IN GOOD TIME I WILL*"
    Data$ "DO YOU WANT ME TO*"
    Data$ "DO YOU THINK YOU SHOULD BE ABLE TO*"
    Data$ "WHY CAN'T YOU*"
    Data$ "WHY ARE YOU INTERESTED IN WHETHER OR NOT I AM*"
    Data$ "WOULD YOU PREFER IF I WERE NOT*"
    Data$ "PERHAPS IN YOUR FANTASIES I AM*"
    Data$ "HOW DO YOU KNOW YOU CAN'T*"
    Data$ "HAVE YOU TRIED?"
    Data$ "PERHAPS YOU CAN NOW*"
    Data$ "DID YOU COME TO ME BECAUSE YOU ARE*"
    Data$ "HOW LONG HAVE YOU BEEN*"
    Data$ "DO YOU BELIEVE IT IS NORMAL TO BE*"
    Data$ "DO YOU ENJOY BEING*"
    Data$ "WE WERE DISCUSSING YOU-- NOT ME."
    Data$ "OH, I*"
    Data$ "YOU'RE NOT REALLY TALKING ABOUT ME, ARE YOU?"
    Data$ "WHAT WOULD IT MEAN TO YOU IF YOU GOT*"
    Data$ "WHY DO YOU WANT*"
    Data$ "SUPPOSE YOU SOON GOT*"
    Data$ "WHAT IF YOU NEVER GOT*"
    Data$ "I SOMETIMES ALSO WANT*"
    Data$ "WHY DO YOU ASK?"
    Data$ "DOES THAT QUESTION INTEREST YOU?"
    Data$ "WHAT ANSWER WOULD PLEASE YOU THE MOST?"
    Data$ "WHAT DO YOU THINK?"
    Data$ "ARE SUCH QUESTIONS ON YOUR MIND OFTEN?"
    Data$ "WHAT IS IT THAT YOU REALLY WANT TO KNOW?"
    Data$ "HAVE YOU ASKED ANYONE ELSE?"
    Data$ "HAVE YOU ASKED SUCH QUESTIONS BEFORE?"
    Data$ "WHAT ELSE COME TO MIND WHEN YOU ASK THAT?"
    Data$ "NAMES DON'T INTEREST ME."
    Data$ "I DON'T CARE ABOUT NAMES-- PLEASE GO ON."
    Data$ "IS THAT THE REAL REASON?"
    Data$ "DON'T ANY OTHER REASONS COME TO MIND?"
    Data$ "DOES THAT REASON EXPLAIN ANYTHING ELSE?"
    Data$ "WHAT OTHER REASONS MIGHT THERE BE?"
    Data$ "PLEASE DON'T APOLOGIZE!"
    Data$ "APOLOGIES ARE NOT NECESSARY."
    Data$ "WHAT FEELINGS DO YOU HAVE WHEN YOU APOLOGIZE."
    Data$ "DON'T BE SO DEFENSIVE!"
    Data$ "WHAT DOES THAT DREAM SUGGEST TO YOU?"
    Data$ "DO YOU DREAM OFTEN?"
    Data$ "WHAT PERSONS APPEAR IN YOUR DREAMS?"
    Data$ "ARE YOU DISTURBED BY YOUR DREAMS?"
    Data$ "HOW DO YOU DO ... PLEASE STATE YOUR PROBLEM."
    Data$ "YOU DON'T SEEM QUITE CERTAIN."
    Data$ "WHY THE UNCERTAIN TONE?"
    Data$ "CAN'T YOU BE MORE POSITIVE?"
    Data$ "YOU AREN'T SURE?"
    Data$ "DON'T YOU KNOW?"
    Data$ "ARE YOU SAYING NO JUST TO BE NEGATIVE?"
    Data$ "YOU ARE BEING A BIT NEGATIVE."
    Data$ "WHY NOT?"
    Data$ "ARE YOU SURE?"
    Data$ "WHY NO?"
    Data$ "WHY ARE YOU CONCERNED ABOUT MY*"
    Data$ "WHAT ABOUT YOUR OWN*"
    Data$ "CAN YOU THINK OF A SPECIFIC EXAMPLE?"
    Data$ "WHEN?"
    Data$ "WHAT ARE YOU THINKING OF?"
    Data$ "REALLY, ALWAYS?"
    Data$ "DO YOU REALLY THINK SO?"
    Data$ "BUT YOU ARE NOT SURE YOU*"
    Data$ "DO YOU DOUBT YOU*"
    Data$ "IN WHAT WAY?"
    Data$ "WHAT RESEMBLANCE DO YOU SEE?"
    Data$ "WHAT DOES THE SIMILARITY SUGGEST TO YOU?"
    Data$ "WHAT OTHER CONNECTIONS DO YOU SEE?"
    Data$ "COULD THERE REALLY BE SOME CONNECTION?"
    Data$ "HOW?"
    Data$ "YOU SEEM QUITE POSITIVE."
    Data$ "ARE YOU SURE?"
    Data$ "I SEE."
    Data$ "I UNDERSTAND."
    Data$ "WHY DO YOU BRING UP THE TOPIC OF FRIENDS?"
    Data$ "DO YOUR FRIENDS WORRY YOU?"
    Data$ "DO YOUR FRIENDS PICK ON YOU?"
    Data$ "ARE YOU SURE YOU HAVE ANY FRIENDS?"
    Data$ "DO YOU IMPOSE ON YOUR FRIENDS?"
    Data$ "PERHAPS YOUR LOVE FOR FRIENDS WORRIES YOU."
    Data$ "DO COMPUTERS WORRY YOU?"
    Data$ "ARE YOU TALKING ABOUT ME IN PARTICULAR?"
    Data$ "ARE YOU FRIGHTENED BY MACHINES?"
    Data$ "WHY DO YOU MENTION COMPUTERS?"
    Data$ "WHAT DO YOU THINK MACHINES HAVE TO DO WITH YOUR PROBLEM?"
    Data$ "DON'T YOU THINK COMPUTERS CAN HELP PEOPLE?"
    Data$ "WHAT IS IT ABOUT MACHINES THAT WORRIES YOU?"
    Data$ "SAY, DO YOU HAVE ANY PSYCHOLOGICAL PROBLEMS?"
    Data$ "WHAT DOES THAT SUGGEST TO YOU?"
    Data$ "I SEE."
    Data$ "I'M NOT SURE I UNDERSTAND YOU FULLY."
    Data$ "COME COME ELUCIDATE YOUR THOUGHTS."
    Data$ "CAN YOU ELABORATE ON THAT?"
    Data$ "THAT IS QUITE INTERESTING"
  ;Data For FINDING REPLIES
  NUMREPLIES:
    Data.l 1,3,4,2,6,4,6,4,10,4,14,3,17,3,20,2,22,3,25,3
    Data.l 28,4,28,4,32,3,35,5,40,9,40,9,40,9,40,9,40,9,40,9
    Data.l 49,2,51,4,55,4,59,4,63,1,63,1,64,5,69,5,74,2,76,4
    Data.l 80,3,83,7,90,3,93,6,99,7,106,6

Return

.echeck
  For L=1 To Len(I$)
;    .aposone
;    If Mid$(I$,L,1)="'"
;      I$=Left$(I$,L-1)+Right$(I$,Len(I$)-L)
;      Goto aposone
;    EndIf
    If L+4<=Len(I$)
      If Mid$(I$,L,4)="SHUT"
        Zx$="Hey, "+who$+", SHUT UP.. "
        say{Zx$}
        ret=True
      EndIf
    EndIf
  Next L
  If I$=P$
    Zx$=who$+" Please, Don't Repeat Yourself!"
    say{Zx$}
    ret=True
  EndIf

Return


.logita
logtext{ltext$}
logtext{input$}
Return

.logitb
logtext{otext$}
logtext{output$}
Return

.getmax
maxchars=TextFit_(RastPort(1),&output$,chars,&al,0,1,464,fsize)
Return

End

.quit
  If bot=True
    say{"I've got to go :("}    ; Send goodbye messages
    say{"Bye!"}
  EndIf
  logtext{"--- End Session ---"}
  CloseFile 2
  End
Return

.nick
  output{"NICK "+nick$}                       ; send nick to server
  nlen=Len(nick$)
  GTSetString 1,4,nick$
Return


.chansort
i=0
done=False
    If FirstItem(conchan())=False
       If AddItem(conchan())
         conchan()\s=chans$
       EndIf
       done=True
     Else
       If conchan()\s=chans$
         KillItem conchan()
         done=True
       EndIf
       Repeat
         If NextItem(conchan())=True
           If conchan()\s=chans$
             KillItem conchan()
             done=True
           EndIf
         Else
           If AddLast(conchan())
             conchan()\s=chans$
           EndIf
           done=True
         EndIf
         If i=200
           done=True
           GTSetString 0,18,"Too Many!"
         Else
           i+1
         EndIf
       Until done=True
     EndIf
  GTChangeList evw,17,conchan()
;  SetBPen_(RastPort(1),4)

Return

.priv
   ;
   ; Send text direct to person
   ;
;   SHARED chan$,target$,who$
   say$="privmsg "+whoto$+" :"+awayto$
   NPrintTCP{say$}
   logtext{"<me>"+say$}
Return

.disksave
 Gosub basesave
 Gosub extendsave
Return

.diskload
 Gosub baseload
 Gosub extendload
Return

.docmd
  cli$="con:0/0/"+Str$(WBWidth)+"/"+Str$(WBHeight)+"/OrionDOS"
  If WriteFile(0,cli$)
    WBenchToFront_
    Execute_ &cmd$,Peek.l(Addr File(0)),0
    WBenchToBack_
    CloseFile 0
  EndIf
Return

.test

If test=True
  For i=0 To nickstot
  NPrint nickset$(i)
  Next i
EndIf

;-----------------------------------------------------------

; Standard Blitz TCP Functions V1.8 by Paul Burkey (c)1997-1998
; Compiled with help from Ercole Spiteri and Anton Reinauer
; You *must* have the bsdsocket.library setup in BlitZ!!
; Contact me at burkey@bigfoot.com
;-----------------------------------------------------------
;History
;-------
;<16.2.97> Version 1.8
;Added NLPrintTCP{} for easy send string with carrage return and newline.
;Removed need for 3rd Party libs (only bsdsocket.library needed)
;
;<24.12.97> Version 1.7
;ReadTCP{} Updated with extra safety and Speed
;
;<18.9.97> Version 1.6
;Added PrintTCP{}  for an easy "send string" command.
;Added NPrintTCP{} for easy send string with carrage return
;CheckTCP{} merged into the ConnectTCP{} function.
;
;---------------
; Function List
;---------------
;
;ReadTCP{}                       ; Similar to Edit$() - recives data via TCP connection
;ReadMemTCP{ReadAdd.l,MaxSiZe.l} ; Similar to ReamMem - recives data via TCP connection
;WriteTCP{ad.l,siZe.w}           ; Similar to WriteMem - sends data via TCP connection
;ConnectTCP{host$,port.w}        ; Connect to a remote machine (Full error checking)
;PrintTCP{text$}                 ; Similar to Print - sends data via TCP connection
;NPrintTCP{text$}                ; Similar to NPrint - sends data via TCP connection
;NLPrintTCP{text$}               ; Similar to Print+CR+LF - sends data via TCP connection
;CloseTCP{}                      ; Closes TCP Connection

