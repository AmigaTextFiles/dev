;DLL EXAMPLE FILE....see dll.readme (needs DLL V3.0)
;
;Also needs AmigaLibs.res resident!
;
; Needs #DLL_TRAP_ERRORS = 0
;
XINCLUDE Fatal_Error.bb
XINCLUDE Compare_Strings.bb
XINCLUDE "dll.bb2"
;XINCLUDE "dllsort.bb2"      ;include dll quick sort routines


;first create your item, that contains a node.dll as the first variable, so
;the list works correctly

NEWTYPE .bumitem
  node.dll        ;no pointer...needs to actually be in line
  pad.w
  string.s
  number.w
  dude.s
  quick.q
  word.s
  etc.b
  pad1.b
End NEWTYPE


;next, define your current item variable...must be a pointer to your newtype

DEFTYPE .bumitem *myitem

;Stop

;next, you need to INITIALIZE your list. You need to set the return value
;as your list header, which is used to pass to all other dll routines

*mylist.dllhead=INIT_LIST{&*myitem,SizeOf .bumitem}


;check to see if the list initalized correctly

If *mylist=0 Then End


;now you MUST set all non string variables in your item pointer to -1, and all strings to ""

*myitem\pad=-1,"",-1,"",-1,"",-1,-1


;now you MUST call the set string routine, so dll will remember where your strings
;are in your item, and deallocate them correctly. (you must do this, even
;if your items do not have any strings!)

SET_STRING_POSITIONS{*mylist}


;now we have a blank list, ready for add_item

For loop=1 To 10

  If ADD_ITEM{*mylist,SizeOf .bumitem}      ;must pass the sizeof your item to add to the list

    *myitem\number=loop

  Else

    NPrint "MAJOR ERROR...NO MEM...OR NUCLEAR MELTDOWN!!!!!"

  EndIf

Next loop

RESET_LIST{*mylist}

While NEXT_ITEM{*mylist}
  NPrint *myitem\number," list item here"
Wend

;Stop

While PREV_ITEM{*mylist}
  NPrint *myitem\number," list item here ",GET_LIST_POS{*mylist}
Wend

;Stop

NPrint "number of items in list ",GET_LIST_SIZE{*mylist}

;Stop

For loop=0 To 9

  NPrint "Original List position = ",GET_LIST_POS{*mylist}:PUSH_ITEM{*mylist}
  pos.l=Rnd(20)
  If SET_LIST_POS{*mylist,pos}=True
    NPrint "Random list set position = ",pos," is item number ",*myitem\number
    PUSH_ITEM{*mylist}
  Else
    Print "Couldn't set list to position ",pos
    NPrint "  Current position = ",*myitem\number
    PUSH_ITEM{*mylist}
  EndIf
  POP_ITEM{*mylist}:POP_ITEM{*mylist}:NPrint "Restored List Position = ",GET_LIST_POS{*mylist}
  NPrint ""
  VWait 100

Next loop

;Stop

If FIRST_ITEM{*mylist} Then NPrint "Found First item = ",*myitem\number
If LAST_ITEM{*mylist} Then NPrint "Found Last item = ",*myitem\number

;Stop

CLEAR_LIST{*mylist}

NPrint "number of items in list ",GET_LIST_SIZE{*mylist}," - list cleared"

;Stop

For ploop.l=1 To 10

  If Rnd(10)>5
    If ADD_FIRST{*mylist,SizeOf .bumitem}
      *myitem\dude="ADDED FIRST - LOOP="+Str$(ploop)+" "+Str$(Rnd(100))
      *myitem\number=ploop:*myitem\etc=Rnd(50)
      *myitem\string = UStr$(ploop);                 ADDED BY DM
    Else
      NPrint "COULDN'T ADD FIRST TO LIST ",ploop
    EndIf
  Else
    If ADD_LAST{*mylist,SizeOf .bumitem}
      *myitem\dude="ADDED LAST - LOOP="+Str$(ploop)+" "+Str$(Rnd(1000))
      *myitem\number=ploop:*myitem\etc=Rnd(50)
      *myitem\string = UStr$(ploop);                 ADDED BY DM
    Else
      NPrint "COULDN'T ADD LAST TO LIST ",ploop
    EndIf
  EndIf

Next ploop

;Stop

SORT_LIST_DESCENDING{*mylist,SizeOf .bumitem\etc,#VARTYPE_BYTE}

;If QUICK_SORT_LIST_ASCENDING{*mylist,SizeOf .bumitem\etc,#VARTYPE_BYTE}
;  NPrint "okay"
;Else
;  NPrint "doh"
;EndIf

Gosub SHOW_LIST
NPrint "number of items in list ",GET_LIST_SIZE{*mylist};  ADDED BY DM

NPrint "PRESS MOUSE"

MouseWait



; DAVE MCMINN WAS HERE
; Create an empty list
NEWTYPE.nnn
    pad.w
    name$
End NEWTYPE
Dim List dummy.nnn(0)

WbToScreen 0
GTListView 0,1,20,20,200,200,"Items",2,dummy()
Window 0,0,0,640,256,$100f,"a",-1,-1
AttachGTList 0,0
GTSetAttrs 0,1,#GTLV_Labels,*mylist
While ev.l<>$200
    ev = WaitEvent
Wend
DetachGTList 0
Free GTList 0
; DAVE MCMINN ENDS HERE



;don't need to clearlist, because END would deallocate all memory anyway,
;but we will..to show it works :)

CLEAR_LIST{*mylist}


;although the list is cleared...it is still useable...ie, it's in the
;same state as when you create it...ie, ready for add_item


End         ;will finally clear our list header!


SHOW_LIST:

RESET_LIST{*mylist}

While NEXT_ITEM{*mylist}
  NPrint "Item No.=",GET_LIST_POS{*mylist}," Number=",*myitem\number," etc=",*myitem\etc
  NPrint "Dude=",*myitem\dude
Wend

Return








