.DLL ; V3.0 By David Newton (dave@nbsamiga.demon.co.uk)
;           Modified by Tony Rolfe (edgewater@shoalhaven.net.au)
;
;Dynamic Linked Lists (with variable sized items)
;
;See DLL.readme for more information!
;
;Feel free to use this include in any of your programs anyway you require.
;Also make any changes you like, and if you improve anything (mostly the
;sort routines...) let me know, so other people can benefit. I require no
;renumeration for the use of this source code, and I accept no
;responsibility for any harm to hardware/software caused directly or
;indirectly from the use of this source code and/or extracts of this source
;code compiled. But a credit for these routines in your software/manual would
;be nice :).  Dave.....
;
; Set the following flag to zero to maintain the original
; method with each function returning a true/false condition
; Or... set to 1 to have each routine trap its own fatal errors and
; invoke the Fatal_Error{Message$} statement (to be supplied by the user).
;
#DLL_TRAP_ERRORS = 1 ;
;
Goto END_OF_DLL

;DLL CONSTANTS
#STRING_HOLDER=$FF            ;used as a string type holder in the list head data
#DEFAULT_ITEM_STACK_SIZE=8    ;default maximum number of pushes for a list (ie, list stack size)

#DLL_True  = -1               ; Faster replacenemt for True
#DLL_False = 0                ; ... and for False

#VARTYPE_BYTE=1               ;used by the sort routine to determine variable type
#VARTYPE_WORD=2
#VARTYPE_LONG=3
#VARTYPE_QUICK=4
#VARTYPE_FLOAT=5


;DLL NEWTYPES
;List node, the basic list newtype to add in your new type
NEWTYPE .dll
  *dll_next.dll
  *dll_prev.dll
End NEWTYPE

NEWTYPE .dllhead        ;private use, for accessing the head item
                        ;-4 from here is the current item pointer
  *dll_next.dll         ;points to the first item in list
  *dll_tail.dll         ;always 0
  *dll_tailprev.dll     ;points to last item in list
  *dll_freenext.dll     ;always points to dll_freetail -leave blitz rubbish
  *dll_freetail.dll     ;always 0
  *dll_freetailprev.dll ;always points to dll_freenext -leave blitz rubbish
  dll_blitzlist.l       ;lIsT defines this is a blitz list...DOH

                        ;my addons from here
  *dll_current.dll      ;address of the current item variable pointer (use dll_current\dll_next as the pointer to current item)
  dll_itemsinlist.l     ;number of items in list
  dll_curpos.l          ;current item number (first = 1) ;; Added by ACR
  dll_stackstart.l      ;start of item stack for this list
  dll_stackcurrent.l    ;current position of the list stack
  dll_stackend.l        ;end of item stack for this list
  dll_firststring.l     ;offset in item of first string (or 0-no strings)
                        ;list of string offsets.l until 0 is reached
End NEWTYPE


;DLL INTERNAL ROUTINES - LEAVE ALONE!
Statement DLL_LOKE{address.l,number.l}
  ;my quick replacement function for poke.l

   MOVE.l d0,a0
   MOVE.l d1,(a0)
   AsmExit
End Statement

Function.l DLL_LEEK{address.l}
  ;my quick replacement function for peek.l

  MOVE.l d0,a0:MOVE.l (a0),d0
  AsmExit
End Function

Function.b DLL_BEEK{address.l}
  ;quick replacement for peek.b

  MOVE.l d0,a0:MOVE.b (a0),d0
  AsmExit
End Function

Function.w DLL_WEEK{address.l}
  ;quick replacement for peek.w

  MOVE.l d0,a0:MOVE.w (a0),d0
  AsmExit
End Function

Function.q DLL_QEEK{address.l}
  ;quick replacement for peek.q

  MOVE.l d0,a0:MOVE.l (a0),d0
  AsmExit
End Function

Function.f DLL_FEEK{address.l}
  ;quick replacement for peek.f

  MOVE.l d0,a0:MOVE.l (a0),d0
  AsmExit
End Function

Function.b FLOAT_SGN{floatadr.l}
  ;replacement for sgn(float) assuming standard FFP long

  MOVE.l d0,a0:MOVE.l (a0),d0:BEQ FLOAT_SGN_EXIT
  BTST.b #7,d0:BNE FLOAT_SGN_MINUS:MOVEQ.l #1,d0:BRA FLOAT_SGN_EXIT
FLOAT_SGN_MINUS: MOVEQ.l #-1,d0
FLOAT_SGN_EXIT:
  AsmExit
End Function

Function.l GET_ALLOCATED_SIZE{address.l}
  ;returns the size of a blitz allocated memory buffer

  MOVE.l d0,a0:MOVE.l -4(a0),d0:SUB.l #8,d0
  AsmExit
End Function

Statement SET_CURRENT_ITEM{*listhead.dllhead,*curitem.dll}
  ;sets the two current item pointers in the list head to *curitem

  DLL_LOKE{*listhead-4,*curitem}:*listhead\dll_current\dll_next=*curitem
End Statement

Statement SEEK_STRINGS{sstart.l,datapos.l,size.l,strpos.l}
  ;Start at the end of the item's data block and search for <>$FF
  ;then record the strings position in the list head's string list block
  ;start is the start of the item, datapos is the offset to the start of the data block
  ;size is the size of the item, and strpos is the start of the string list block

  MOVE.l d0,a0:ADD.l d0,d1:ADD.l d2,a0:MOVE.l d3,a1:MOVE.b #STRING_HOLDER,d2
SEEK_STRINGS_LOOP: CMP.b -(a0),d2:BNE SEEK_STRINGS_FOUND:CMP.l d1,a0:BGT SEEK_STRINGS_LOOP:BRA SEEK_STRINGS_EXIT
SEEK_STRINGS_FOUND: SUBQ.l #3,a0:MOVE.l (a0),d3:CMP.l #$800000C1,d3:BEQ SEEK_STRINGS_SKIP
  CMP.l #$FFFF0000,d3:BEQ SEEK_STRINGS_SKIP:MOVE.l a0,d3:SUB.l d0,d3:MOVE.l d3,(a1)+
SEEK_STRINGS_SKIP: CMP.l d1,a0:BGT SEEK_STRINGS_LOOP
SEEK_STRINGS_EXIT: MOVE.l #0,(a1)
  AsmExit
End Statement

Statement DEALLOCATE_STRING{strptr.l}
  ;deallocate a blitz string

  strpos.l=DLL_LEEK{strptr}
  If strpos<>0 Then FreeMem strpos-8,GET_ALLOCATED_SIZE{strpos-8}:DLL_LOKE{strptr,0}
End Statement

Statement FREE_STRINGS{*listhead.dllhead,*curitem.dll}
  ;search head item for strings to deallocate

  strpos.l=&*listhead\dll_firststring:pos.l=DLL_LEEK{strpos}
  endsize.l=GET_ALLOCATED_SIZE{*curitem}
  While (pos<>0)&(pos<endsize)
    DEALLOCATE_STRING{*curitem+pos}:strpos=strpos+4:pos.l=DLL_LEEK{strpos}
  Wend
End Statement

Statement INSERT_ITEM{*preitem.dll,*newitem.dll}
   ;insert *new into list

   *newitem\dll_next  = *preitem\dll_next,*preitem
   *preitem\dll_next  = *newitem
   *postitem.dll      = *newitem\dll_next
   *postitem\dll_prev = *newitem
End Statement

Statement REMOVE_ITEM{*curitem.dll}
   ;removes *curitem from list

   *preitem.dll       = *curitem\dll_prev
   *preitem\dll_next  = *curitem\dll_next
   *postitem.dll      = *curitem\dll_next
   *postitem\dll_prev = *curitem\dll_prev
End Statement

Function.b COMPARE_ITEMS{*itemone.dll,*itemtwo.dll,entrypath.l,vartype.l}
   ;compare variables from the two supplied items
   ;and return -1 if the second is smaller, 0 if equal, 1 if the second is greater

   Select vartype
      Case #VARTYPE_BYTE
         Function Return Sgn(DLL_BEEK{*itemtwo+entrypath}-DLL_BEEK{*itemone+entrypath})
      Case #VARTYPE_WORD
         Function Return Sgn(DLL_WEEK{*itemtwo+entrypath}-DLL_WEEK{*itemone+entrypath})
      Case #VARTYPE_LONG
         Function Return Sgn(DLL_LEEK{*itemtwo+entrypath}-DLL_LEEK{*itemone+entrypath})
      Case #VARTYPE_QUICK
         Function Return Sgn(DLL_QEEK{*itemtwo+entrypath}-DLL_QEEK{*itemone+entrypath})
      Case #VARTYPE_FLOAT
         tmp.f = DLL_FEEK{*itemtwo+entrypath}-DLL_FEEK{*itemone+entrypath}
         Function Return FLOAT_SGN{&tmp}
;    Case #VARTYPE_STRING:result.b=Sgn(COMPARE_STRINGS{DLL_LEEK{*itemtwo+entrypath},DLL_LEEK{*itemone+entrypath}})
      Default
         Function Return 0
  End Select
End Function


.DLL_USER ; routines

Statement KILL_ITEM{*listhead.dllhead}
  ;deletes the current item in the list

  *curitem.dll=*listhead\dll_current\dll_next
  If (*curitem<>0)&((*curitem\dll_next<>0)&(*curitem\dll_prev<>0))
    If *curitem<>*listhead\dll_tailprev
      SET_CURRENT_ITEM{*listhead,*curitem\dll_prev}
    Else
      If *curitem<>*listhead\dll_next
        SET_CURRENT_ITEM{*listhead,*curitem\dll_prev}
      Else
        SET_CURRENT_ITEM{*listhead,0}
      EndIf
    EndIf
    REMOVE_ITEM{*curitem}
    *listhead\dll_itemsinlist-1
    *listhead\dll_curpos - 1
    FREE_STRINGS{*listhead,*curitem}
    FreeMem *curitem,GET_ALLOCATED_SIZE{*curitem}
  EndIf
End Statement

Function.b FIRST_ITEM{*listhead.dllhead}
  ;move to the first item in the list if possible
  ;returns true if successful and false if not, and only changes to the
  ;first item if there is actually first item in the list

  *tmpitem.dll=*listhead\dll_next
  If (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
    SET_CURRENT_ITEM{*listhead,*tmpitem}
    *listhead\dll_curpos = 1
    Function Return #DLL_True
  Else
    Function Return #DLL_False
  EndIf
End Function

Function.b LAST_ITEM{*listhead.dllhead}
  ;move to the last item in the list if possible
  ;returns true if successful and false if not, and only changes to the
  ;last item if there is actually last item in the list (ie, not when list is empty)

  *tmpitem.dll=*listhead\dll_tailprev
  If (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
    SET_CURRENT_ITEM{*listhead,*tmpitem}
    *listhead\dll_curpos = *listhead\dll_itemsinlist
    Function Return #DLL_True
  Else
    Function Return #DLL_False
  EndIf
End Function

Statement NO_MORE_ITEMS{*listhead.dllhead}
   ;  Move to the last item in the list if possible, so that a
   ;  "While NEXT_ITEM{}" loop can be terminated
   ;  Only changes to the last item if there is actually last item
   ;  in the list (ie, not when the list is empty)
   ;
   ;  Same as LAST_ITEM except that it does not return a value

  *tmpitem.dll=*listhead\dll_tailprev
  If (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
    SET_CURRENT_ITEM{*listhead,*tmpitem}
    *listhead\dll_curpos = *listhead\dll_itemsinlist
  EndIf
End Statement

Statement RESET_LIST{*listhead.dllhead}
  ;reset current list item pointer to 0

  SET_CURRENT_ITEM{*listhead,0}
  *listhead\dll_curpos = 0
End Statement

Statement CLEAR_LIST{*listhead.dllhead}
  ;empty list of items, and reset stack position

  If LAST_ITEM{*listhead}
     While *listhead\dll_curpos <> 0
       KILL_ITEM{*listhead}
     Wend
  EndIf
  *listhead\dll_stackcurrent=*listhead\dll_stackstart:SET_CURRENT_ITEM{*listhead,0}
End Statement

CNIF #DLL_TRAP_ERRORS
Statement ADD_ITEM{*listhead.dllhead,size.l}
CELSE
Function.b ADD_ITEM{*listhead.dllhead,size.l}
CEND
   ;adds an item to the list, of size
   ;and sets the list's current pointer to the newly created item if available

   *newitem.dll=AllocMem(size,$10000)
   If *newitem<>0
      *curitem.dll=*listhead\dll_current\dll_next:If *curitem=0 Then *curitem=*listhead
      INSERT_ITEM{*curitem,*newitem}
      *listhead\dll_itemsinlist + 1
      SET_CURRENT_ITEM{*listhead,*newitem}
      *listhead\dll_curpos + 1
CNIF #DLL_TRAP_ERRORS
   Else
      Fatal_Error{"Could not add a List Item"}
   EndIf
End Statement
CELSE
      Function Return #DLL_True
   Else
      Function Return #DLL_False
   EndIf
End Function
CEND

CNIF #DLL_TRAP_ERRORS
Statement ADD_FIRST{*listhead.dllhead,size.l}
CELSE
Function.b ADD_FIRST{*listhead.dllhead,size.l}
CEND
  ;same as add item, except it adds the item at the start of the list
  ;and sets the list's current pointer to the newly created item if available

  *curitem.dll=*listhead\dll_current\dll_next:SET_CURRENT_ITEM{*listhead,*listhead}
CNIF #DLL_TRAP_ERRORS
  ADD_ITEM{*listhead,size}
  *listhead\dll_curpos = 1
End Statement
CELSE
  If ADD_ITEM{*listhead,size}=#DLL_True
     *listhead\dll_curpos = 1
     Function Return #DLL_True
  Else
    SET_CURRENT_ITEM{*listhead,*curitem}
    Function Return #DLL_False
  EndIf
End Function
CEND

CNIF #DLL_TRAP_ERRORS
Statement ADD_LAST{*listhead.dllhead,size.l}
CELSE
Function.b ADD_LAST{*listhead.dllhead,size.l}
CEND
  ;same as add item, except it adds the item at the end of the list
  ;and sets the list's current pointer to the newly created item if available

  *curitem.dll=*listhead\dll_current\dll_next:SET_CURRENT_ITEM{*listhead,*listhead\dll_tailprev}
CNIF #DLL_TRAP_ERRORS
  ADD_ITEM{*listhead,size}
  *listhead\dll_curpos = *listhead\dll_itemsinlist
End Statement
CELSE
  If ADD_ITEM{*listhead,size}=#DLL_True
     *listhead\dll_curpos = *listhead\dll_itemsinlist
     Function Return #DLL_True
  Else
    SET_CURRENT_ITEM{*listhead,*curitem}
    Function Return #DLL_False
  EndIf
End Function
CEND

CNIF #DLL_TRAP_ERRORS
Statement ITEM_STACK_SIZE{*listhead.dllhead,maxpushes.l}
CELSE
Function.b ITEM_STACK_SIZE{*listhead.dllhead,maxpushes.l}
CEND
  ;set a stack for list items to be used for PUSH/POP ITEM

  stackstart.l=*listhead\dll_stackstart
  If stackstart<>0
    FreeMem stackstart,GET_ALLOCATED_SIZE{stackstart}
  EndIf
  stacksize.l=maxpushes*4:stackstart.l=AllocMem(stacksize,0)
  *listhead\dll_stackstart=stackstart,stackstart,stackstart+stacksize
  If stackstart = 0
CNIF #DLL_TRAP_ERRORS
    Fatal_Error{"Could not set DLL stack size to " + UStr$(maxpushes)}
  EndIf
End Statement
CELSE
    Function Return #DLL_False
  Else
    Function Return #DLL_True
  EndIf
End Function
CEND

Function.l INIT_LIST{*listitem.dll,size.l}
  ;the listitem is the current item holder...
  ;returns the listhead address

  If *listitem\dll_next=0
    mem.l=AllocMem((size+SizeOf .dllhead),$10000)
    If mem<>0
      *tmphead.dllhead=mem+4:DLL_LOKE{mem,0}
      *tmphead\dll_next=&*tmphead\dll_tail,0,*tmphead
      *tmphead\dll_freenext=&*tmphead\dll_freetail,0,&*tmphead\dll_freenext
      *tmphead\dll_blitzlist=$6C497354,*listitem,0,0,0,0,0
CNIF #DLL_TRAP_ERRORS
      ITEM_STACK_SIZE{*tmphead,#DEFAULT_ITEM_STACK_SIZE}
      ADD_ITEM{*tmphead,size}
      Function Return *tmphead
    Else
      Fatal_Error{"Could not Init List"}
    EndIf
  Else
    Fatal_Error{"Could not Init List"}
CELSE
      If ITEM_STACK_SIZE{*tmphead,#DEFAULT_ITEM_STACK_SIZE}=#DLL_True
        If ADD_ITEM{*tmphead,size}
          Function Return *tmphead
        Else
          stackstart.l=*tmphead\dll_stackstart:FreeMem stackstart,GET_ALLOCATED_SIZE{stackstart}
          FreeMem mem,(size+SizeOf .dllhead)
          Function Return #DLL_False
        EndIf
      Else
        FreeMem mem,(size+SizeOf .dllhead)
        Function Return #DLL_False
      EndIf
      Function Return #DLL_False
    EndIf
  Else
    Function Return #DLL_False
CEND
  EndIf

End Function

Statement SET_STRING_POSITIONS{*listhead.dllhead}
  ;must be called after first INIT of a list header, and a single
  ;item was added automatically for you by init so you must set
  ;all non string of that item in your list to -1, and all strings to ""

  *curitem.dll=*listhead\dll_current\dll_next
  If (*curitem<>0)&((*curitem\dll_next<>0)&(*curitem\dll_prev<>0))
    itemsize.l=GET_ALLOCATED_SIZE{*curitem}:strstart.l=&*listhead\dll_firststring
    SEEK_STRINGS{*curitem,SizeOf .dll,itemsize,strstart}:KILL_ITEM{*listhead}
  EndIf
End Statement

Function.b PREV_ITEM{*listhead.dllhead}
  ;move to the previous item in the list if possible
  ;returns true if successful and false if not, and only changes to
  ;the previous item if there is actually a previous item in the list

  *curitem.dll=*listhead\dll_current\dll_next:If *curitem=0 Then *curitem=*listhead\dll_next
  *preitem.dll=*curitem\dll_prev
  If (*preitem\dll_next<>0)&(*preitem\dll_prev<>0)
    SET_CURRENT_ITEM{*listhead,*preitem}
    *listhead\dll_curpos - 1
    Function Return #DLL_True
  Else
    RESET_LIST{*listhead}        ;
    Function Return #DLL_False
  EndIf
End Function

Function.b NEXT_ITEM{*listhead.dllhead}
  ;move to the next item in the list if possible
  ;returns true if successful and false if not, and only changes to the
  ;next item if there is actually next item in the list

  *curitem.dll=*listhead\dll_current\dll_next:If *curitem=0 Then *curitem=*listhead
  *postitem.dll=*curitem\dll_next
  If (*postitem\dll_next<>0)&(*postitem\dll_prev<>0)
    SET_CURRENT_ITEM{*listhead,*postitem}
    *listhead\dll_curpos + 1
    Function Return #DLL_True
  Else
    Function Return #DLL_False
  EndIf
End Function

Statement RESET_LIST_POS{*listhead.dllhead}
  ;resets the position in the list of the current item (ie, search from head)
  ;doesn't change the current item position of the list (starts at 1...)

   *curitem.dll=*listhead\dll_current\dll_next

   If *curitem<>0
      *listhead\dll_curpos=1
      *tmpitem.dll=*listhead\dll_next
      While (*curitem<>*tmpitem)&((*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0))
         *tmpitem=*tmpitem\dll_next
         *listhead\dll_curpos + 1
      Wend
      If (*curitem=*tmpitem)&((*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0))
      Else
         *listhead\dll_curpos = 0
      EndIf
   Else
      *listhead\dll_curpos = 0
   EndIf

End Statement

Function.l GET_LIST_POS{*listhead.dllhead}
  ;return the position in the list of the current item (ie, search from head)
  ;doesn't change the current item position of the list (starts at 1...)

   Function Return *listhead\dll_curpos

End Function

CNIF #DLL_TRAP_ERRORS
Statement SET_LIST_POS{*listhead.dllhead,listpos.l}
CELSE
Function.b SET_LIST_POS{*listhead.dllhead,listpos.l}
CEND
  ;set the current item to the position in the list specified
  ;doesn't change the list position (starts at 1...)

   If listpos <> *listhead\dll_curpos     ; need we go anywhere?
      If listpos < 1 OR listpos > *listhead\dll_itemsinlist
CNIF #DLL_TRAP_ERRORS
         Fatal_Error{"Could not set DLL position to " + UStr$(listpos)}
CELSE
         Function Return #DLL_False
CEND
      EndIf
      If listpos < *listhead\dll_curpos        ;
         If listpos < *listhead\dll_curpos - listpos
            *tmpitem.dll = *listhead\dll_next
            For *listhead\dll_curpos = 1 To listpos - 1
               *tmpitem=*tmpitem\dll_next
            Next
         Else
            *tmpitem.dll = *listhead\dll_current\dll_next:If *tmpitem=0 Then *tmpitem=*listhead
            For *listhead\dll_curpos = *listhead\dll_curpos To listpos + 1 Step -1
               *tmpitem=*tmpitem\dll_prev
            Next
         EndIf
      Else
         If listpos - *listhead\dll_curpos < *listhead\dll_itemsinlist - listpos
            *tmpitem.dll = *listhead\dll_current\dll_next:If *tmpitem=0 Then *tmpitem=*listhead
            For *listhead\dll_curpos = *listhead\dll_curpos To listpos - 1
               *tmpitem=*tmpitem\dll_next
            Next
         Else
            *tmpitem.dll=*listhead\dll_tailprev
            For *listhead\dll_curpos = *listhead\dll_itemsinlist To listpos+1 Step -1
               *tmpitem=*tmpitem\dll_prev
            Next
         EndIf
      EndIf
      SET_CURRENT_ITEM{*listhead,*tmpitem}
   EndIf
CNIF #DLL_TRAP_ERRORS
End Statement
CELSE
   Function Return #DLL_True
End Function
CEND

Function.l GET_LIST_SIZE{*listhead.dllhead}
  ;returns the number of entries in the list
  ;doesn't change the current item in the list either

  Function Return *listhead\dll_itemsinlist
End Function

Function.l GET_CURRENT_ITEM{*listhead.dllhead}
  ; Returns the address of the current item
  ; Useful when several lists share a common processing routine

  Function Return *listhead\dll_current\dll_next
End Function

Statement PUSH_ITEM{*listhead.dllhead}
  ;push current item position in list onto the list stack if room for the item

  *curitem.dll=*listhead\dll_current\dll_next:stackpos.l=*listhead\dll_stackcurrent
  If (stackpos<>0)&((stackpos>=*listhead\dll_stackstart)&(stackpos<*listhead\dll_stackend))
    DLL_LOKE{stackpos,*curitem}:*listhead\dll_stackcurrent=stackpos+4
  EndIf
End Statement

Statement POP_ITEM{*listhead.dllhead}
  ;pop current item position in list from the list stack if item is on the stack
  ;resets the current list position

  stackpos.l=*listhead\dll_stackcurrent
  If (stackpos<>0)&((stackpos>*listhead\dll_stackstart)&(stackpos<=*listhead\dll_stackend))
    SET_CURRENT_ITEM{*listhead,DLL_LEEK{stackpos-4}}:*listhead\dll_stackcurrent=stackpos-4
  EndIf
  RESET_LIST_POS{*listhead}
End Statement

Statement SORT_LIST_ASCENDING{*listhead.dll,entrypath.l,vartype.l}
   *tmpitem.dll=*listhead\dll_next
   While (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
      *nxtitem.dll=*tmpitem\dll_next
      *srtitem.dll=*tmpitem\dll_prev
      REMOVE_ITEM{*tmpitem}
      notdone.b=#DLL_True
      While (*srtitem<>*listhead) & notdone
         If COMPARE_ITEMS{*srtitem,*tmpitem,entrypath,vartype} = -1
            *srtitem=*srtitem\dll_prev
         Else
            notdone=#DLL_False
         EndIf
      Wend
      INSERT_ITEM{*srtitem,*tmpitem}     ;insert item *tmplist to *curlist\dll_next position
      *tmpitem=*nxtitem
   Wend
   RESET_LIST{*listhead}
End Statement

Statement SORT_LIST_DESCENDING{*listhead.dll,entrypath.l,vartype.l}
   *tmpitem.dll=*listhead\dll_next
   While (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
      *nxtitem.dll=*tmpitem\dll_next
      *srtitem.dll=*tmpitem\dll_prev
      REMOVE_ITEM{*tmpitem}
      notdone.b=#DLL_True
      While (*srtitem<>*listhead) & notdone
         If COMPARE_ITEMS{*srtitem,*tmpitem,entrypath,vartype} = 1
            *srtitem=*srtitem\dll_prev
         Else
            notdone=#DLL_False
         EndIf
      Wend
      INSERT_ITEM{*srtitem,*tmpitem}     ;insert item *tmplist to *curlist\dll_next position
      *tmpitem=*nxtitem
   Wend
   RESET_LIST{*listhead}
End Statement

Statement STRING_SORT_ASCENDING{*listhead.dll,entrypath.l}
   *tmpitem.dll=*listhead\dll_next
   While (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
      *nxtitem.dll      = *tmpitem\dll_next
      *srtitem.dll      = *tmpitem\dll_prev
      *srtitem\dll_next = *nxtitem
      *nxtitem\dll_prev = *srtitem
      notdone.b         = #DLL_True
      While (*srtitem <> *listhead) & notdone
         If COMPARE_STRINGS{DLL_LEEK{*tmpitem+entrypath},DLL_LEEK{*srtitem+entrypath}} < 0
            *srtitem=*srtitem\dll_prev
         Else
            notdone=#DLL_False
         EndIf
      Wend
      *tmpitem\dll_next  = *srtitem\dll_next,*srtitem
      *srtitem\dll_next  = *tmpitem
      *postitem.dll      = *tmpitem\dll_next
      *postitem\dll_prev = *tmpitem
      *tmpitem           = *nxtitem
   Wend
   RESET_LIST{*listhead}
End Statement

Statement STRING_SORT_DESCENDING{*listhead.dll,entrypath.l}
   *tmpitem.dll=*listhead\dll_next
   While (*tmpitem\dll_next<>0)&(*tmpitem\dll_prev<>0)
      *nxtitem.dll=*tmpitem\dll_next
      *srtitem.dll=*tmpitem\dll_prev
      REMOVE_ITEM{*tmpitem}
      notdone.b=#DLL_True
      While (*srtitem<>*listhead) & notdone
         If COMPARE_STRINGS{DLL_LEEK{*tmpitem+entrypath},DLL_LEEK{*srtitem+entrypath}} > 0
            *srtitem=*srtitem\dll_prev
         Else
            notdone=#DLL_False
         EndIf
      Wend
      INSERT_ITEM{*srtitem,*tmpitem}     ;insert item *tmplist to *curlist\dll_next position
      *tmpitem=*nxtitem
   Wend
   RESET_LIST{*listhead}
End Statement

.END_OF_DLL:
