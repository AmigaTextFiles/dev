; Description:  Calculates the CRC32 (32bit cyclic redundancy check) for
;               a buffer of a specified size
;
;               The CRC32 routines were converted from the C source
;               file from the zlib general compression library
;               which is Copyright 1995-1996 Jean-loup Gailly and
;               Mark Adler
;
; Requires:     NeilsReqToolsLib for the example, nothing special for
;               the CRC32 function.
;
; Type:         SYSTEM


WbToScreen 0
WBenchToFront_


; Set up the CRC table in an array, this makes it easier to access
Dim crc_table.l(256)
Restore CRCValues
For i.w = 0 To 255
    Read crc_table(i)
Next



; The actual routine for calculating the 32bit CRC. This needs to be passed:
;
; 0 if you want to create a new CRC32, or you can carry on from a previous
; value (I think that's what the crc.l parameter is for). You could use this
; if you needed to split the buffer into smaller sections due to lack of
; memory for example
;
; The address of the buffer you want to calculate the CRC32 for
;
; The length of the buffer in question
;
; I'm not exactly sure how it works (I just converted it, not wrote it) but
; it calculates a checksum byte by byte, each checksum being used in the
; calculation For the Next Checksum, Until all the bytes in the Buffer have
; been included. Because the checksums lead onto each other (and probably
; the carefully selected table values) will ceate a very unique checksum
; for a block of data.
Function.l crc32{crc.l, *buf.b, buflen.w}
    SHARED crc_table()

    If *buf = 0 Then Function Return 0

    crc = crc EOR $FFFFFFFF
    While buflen>0
        crc = crc_table( ((crc & $FFFF) EOR Peek.b(*buf)) & $FF) EOR (crc LSR 8)
        *buf = *buf + 1
        buflen = buflen - 1
    Wend
    crc = crc EOR $FFFFFFFF

    Function Return crc
End Function


; Small test - calculate the CRC32 for a single file.
; Ask user for filename and try to open it. If the file could be
; opened, try to allocate a buffer to hold it in (should do a proper
; memory allocation, but this is just a quick test), read the file into
; that buffer and perform the CRC32 calculation.
If ReadFile(0,RTEZLoadFile("Select file to get CRC32",""))
    FileInput 0
    Dim filebuffer.b(Lof(0))
    ReadMem 0,&filebuffer(0),Lof(0)
    dummy.w = RTEZRequest("Result!","CRC32 of file is:"+Chr$(10)+Hex$(crc32{0,&filebuffer(0),Lof(0)}),"OK")
    PopInput
    CloseFile 0
Else
    dummy.w = RTEZRequest("Error","Could not open file","OK")
End If
End


; These are the magic numbers that are used in the CRC32 algorithm.
; There's 256 of these and SHOULD NOT BE MODIFIED IN ANY WAY!!!
CRCValues:
Data.l  $00000000, $77073096, $ee0e612c, $990951ba, $076Dc419
Data.l  $706af48f, $e963a535, $9e6495a3, $0edb8832, $79Dcb8a4
Data.l  $e0d5e91e, $97d2d988, $09b64c2b, $7eb17cbd, $e7b82d07
Data.l  $90bf1d91, $1db71064, $6ab020f2, $f3b97148, $84be41de
Data.l  $1adad47d, $6ddde4eb, $f4d4b551, $83d385c7, $136c9856
Data.l  $646ba8c0, $fd62f97a, $8a65c9ec, $14015c4f, $63066cd9
Data.l  $fa0f3d63, $8d080df5, $3b6e20c8, $4c69105e, $d56041e4
Data.l  $a2677172, $3c03e4d1, $4b04d447, $d20d85fd, $a50ab56b
Data.l  $35b5a8fa, $42b2986c, $dbbbc9d6, $acbcf940, $32d86ce3
Data.l  $45df5c75, $dcd60dcf, $abd13d59, $26d930ac, $51de003a
Data.l  $c8d75180, $bfd06116, $21b4f4b5, $56b3c423, $cfba9599
Data.l  $b8bda50f, $2802b89e, $5f058808, $c60cd9b2, $b10be924
Data.l  $2f6f7c87, $58684c11, $c1611dab, $b6662d3d, $76Dc4190
Data.l  $01db7106, $98d220bc, $efd5102a, $71b18589, $06b6b51f
Data.l  $9fbfe4a5, $e8b8d433, $7807c9a2, $0f00f934, $9609a88e
Data.l  $e10e9818, $7f6a0dbb, $086d3d2d, $91646c97, $e6635c01
Data.l  $6b6b51f4, $1c6c6162, $856530d8, $f262004e, $6c0695ed
Data.l  $1b01a57b, $8208f4c1, $f50fc457, $65b0d9c6, $12b7e950
Data.l  $8bbeb8ea, $fcb9887c, $62dd1ddf, $15da2d49, $8cd37cf3
Data.l  $fbd44c65, $4db26158, $3ab551ce, $a3bc0074, $d4bb30e2
Data.l  $4adfa541, $3dd895d7, $a4d1c46d, $d3d6f4fb, $4369e96a
Data.l  $346ed9fc, $ad678846, $da60b8d0, $44042d73, $33031de5
Data.l  $aa0a4c5f, $dd0d7cc9, $5005713c, $270241aa, $be0b1010
Data.l  $c90c2086, $5768b525, $206f85b3, $b966d409, $ce61e49f
Data.l  $5edef90e, $29d9c998, $b0d09822, $c7d7a8b4, $59b33d17
Data.l  $2eb40d81, $b7bd5c3b, $c0ba6cad, $edb88320, $9abfb3b6
Data.l  $03b6e20c, $74b1d29a, $ead54739, $9dd277af, $04db2615
Data.l  $73Dc1683, $e3630b12, $94643b84, $0d6d6a3e, $7a6a5aa8
Data.l  $e40ecf0b, $9309ff9d, $0a00ae27, $7d079eb1, $f00f9344
Data.l  $8708a3d2, $1e01f268, $6906c2fe, $f762575d, $806567cb
Data.l  $196c3671, $6e6b06e7, $fed41b76, $89d32be0, $10da7a5a
Data.l  $67dd4acc, $f9b9df6f, $8ebeeff9, $17b7be43, $60b08ed5
Data.l  $d6d6a3e8, $a1d1937e, $38d8c2c4, $4fdff252, $d1bb67f1
Data.l  $a6bc5767, $3fb506dd, $48b2364b, $d80d2bda, $af0a1b4c
Data.l  $36034af6, $41047a60, $df60efc3, $a867df55, $316e8eef
Data.l  $4669be79, $cb61b38c, $bc66831a, $256fd2a0, $5268e236
Data.l  $cc0c7795, $bb0b4703, $220216b9, $5505262f, $c5ba3bbe
Data.l  $b2bd0b28, $2bb45a92, $5cb36a04, $c2d7ffa7, $b5d0cf31
Data.l  $2cd99e8b, $5bdeae1d, $9b64c2b0, $ec63f226, $756aa39c
Data.l  $026d930a, $9c0906a9, $eb0e363f, $72076785, $05005713
Data.l  $95bf4a82, $e2b87a14, $7bb12bae, $0cb61b38, $92d28e9b
Data.l  $e5d5be0d, $7cdcefb7, $0bdbdf21, $86d3d2d4, $f1d4e242
Data.l  $68ddb3f8, $1fda836e, $81be16cd, $f6b9265b, $6fb077e1
Data.l  $18b74777, $88085ae6, $ff0f6a70, $66063bca, $11010b5c
Data.l  $8f659eff, $f862ae69, $616bffd3, $166ccf45, $a00ae278
Data.l  $d70dd2ee, $4e048354, $3903b3c2, $a7672661, $d06016f7
Data.l  $4969474d, $3e6e77db, $aed16a4a, $d9d65adc, $40df0b66
Data.l  $37d83bf0, $a9bcae53, $debb9ec5, $47b2cf7f, $30b5ffe9
Data.l  $bdbdf21c, $cabac28a, $53b39330, $24b4a3a6, $bad03605
Data.l  $cdd70693, $54de5729, $23d967bf, $b3667a2e, $c4614ab8
Data.l  $5d681b02, $2a6f2b94, $b40bbe37, $c30c8ea1, $5a05df1b
Data.l  $2d02ef8d


