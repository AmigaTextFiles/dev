;by Curt Esser
;camge@ix.netcom.com
;fibonacci de-coding routine by Sami Naatanen

;last modified Aug 17 99
;all PD - use as you like

;=============================================================================

;IFF/8SVX  Header Info  -  Byte offsets are in HEX!

;0000000..03 = "FORM", identifies this as an IFF format file.
;FORM+00..03 (ULONG) = total number of bytes that follow (filesize -8)
;FORM+03..07 = "8SVX", identifies this as an 8-bit sampled voice.

;????+00..03 = "VHDR", Voice8Header, describes the parameters for the BODY.
;VHDR+00..03 (ULONG) = number of bytes to follow.
;VHDR+04..07 (ULONG) = samples in the high octave 1-shot part.
;VHDR+08..0B (ULONG) = samples in the high octave repeat part.
;VHDR+0C..0F (ULONG) = samples per cycle in high octave (if repeating), else 0
;VHDR+10..11 (UWORD) = samples per second.  (Unsigned 16-bit quantity.)
;VHDR+12     (UBYTE) = number of octaves of waveforms in sample.
;VHDR+13     (UBYTE) = data compression (0=none, 1=Fibonacci-delta encoding).
;VHDR+14..17 (FIXED) = volume.  (The number 65536 means 1.0 or full volume.)

;????+00..03 = "CHAN", (Optional chunk) channel info for stereo samples
;CHAN+00..03 (ULONG) = size of Channel chunk
;CHAN+04..07 (ULONG) = channel ID   (2=Left  4=Right   6=Stereo)

;????+00..03 = "BODY", identifies the start of the audio data.
;BODY+00..03 (ULONG) = number of bytes of sample data to follow.
;BODY+04..NNNNN      = Data, signed bytes, from -128 to +127.

;=============================================================================


;Chip memory check:

; checks for enough continous chip ram for pics, sounds, mods, etc...

;call with the total chip ram bytes needed

;returns a byte:  -1 (TRUE)  = enough memory available
;                  0 (FALSE) = not enough chip memory

Function CheckChip{bytes.l}        ;check for largest block
  safety=20000                     ;don't ever get to the bottom!
  bytes=bytes+safety
  If AvailMem_ (131074)>bytes      ;of free chip ram in one block

; if you have "amigalibs.res" in your compiler options, you can
; use "#MEMF_CHIP|#MEMF_LARGEST" in place of "131074" above

    Function Return -1             ;True
  Else
    Function Return 0              ;False
  EndIf
End Function

;=============================================================================

; --------- Load an IFF mono sample --------------------

; It will check for valid file and enough chip ram for loading a sound
; and decompress fibonacci-compressed samples if necessary
; if all is OK, the sample is loaded into "samplenumber"

; call with full path to sound file and samplenumber to be loaded into


Function.b LoadSample {soundpath$,samplenumber}

;returns a byte:

; 0 : requested file not found
; 1 : sample was successfully loaded
; 2 : sample is Stereo 8svx  (use stereo load routine)
; 3 : file is not an IFF/8svx sound sample
; 4 : not enough free chip ram to load the sample
; 5 : sample's IFF header is corrupt
; 6 : sample too large to load  (128k is the OS limit)
; 7 : sample uses unknown compression method
; 8 : couldn't create temporary file for de-compression

result.b=1                    ;1 means success!

  If ReadFile(0,soundpath$)   ;make sure it is a valid iff sound file!
    FileInput 0
    header$ = Inkey$(500)     ;this should be enough
    CloseFile 0
    PopInput

    ;IFF sound header must start with: FORM....8SVX

    If Left$(header$,4)="FORM" AND Mid$(header$,9,4)="8SVX"

      vhdr.l=Instr(header$,"VHDR")             ;start of Voice Header chunk
      If vhdr
        vhdr+4
        comp.b=Asc(Mid$(header$,vhdr+$13,1))   ;compression method
      Else
        result=5                               ;IFF header is corrupt
      EndIf

      chan.l=Instr(header$,"CHAN")             ;check for stereo sample
      If chan
        chan+8
        chassign.l=Cvl(Mid$(header$,chan,4))
        If chassign=6
          result=2                             ;can't load it into
        EndIf                                  ;one sample properly...
      EndIf

      If result=1
        DataAt.l=Instr(header$,"BODY")         ;start of data chunk
        If DataAt
          DataAt+4
          DataLen.l=Cvl(Mid$(header$,DataAt,4));length of sample data
          DataAt+4                             ;start of actual data
        Else
          result=5                             ;IFF header is corrupt
        EndIf
      EndIf

      If result=1

        ok.b=0

        If DataLen > 128000
          result=6                ;sample too large for the OS!
        Else
          ok.b=CheckChip{DataLen} ;check for enough chip memory
        EndIf

        If ok
          If comp=0               ;not compressed, just load it!

            Free Sound samplenumber
            LoadSound samplenumber,soundpath$
          Else
            If comp=1             ;fibonacci compressed sample
              ;fibonacci decompression routine by Sami Naatanen
              Dim table.b(15)
              table(0) = -34
              table(1) = -21
              table(2) = -13
              table(3) = -8
              table(4) = -5
              table(5) = -3
              table(6) = -2
              table(7) = -1
              table(8) =  0
              table(9) =  1
              table(10)=  2
              table(11)=  3
              table(12)=  5
              table(13)=  8
              table(14)=  13
              table(15)=  21

              If OpenFile (1,"T:tempsamp")   ;we make a temporary sample file
                If OpenFile (0,soundpath$)   ;and decompress the sample to it
                  FileOutput 1               ;for Blitz to load
                  FileInput 0
                  Print Left$(header$,DataAt-1)   ;first the header

                  FileSeek 0,DataAt               ;now the sample data
                  sample.b=0
                  ReadMem 0,&sample,1        ;Read first byte To "sample.b"
                  Repeat                     ;Repeat
                    ReadMem 0,&sample,1      ;  Data.b=readbyte
                    tmp.b=byte AND $F        ;  tmp.b=Data&$f
                    sample+table(tmp)        ;  sample=sample+table(tmp)
                    WriteMem 1,&sample,1     ;  output sample To Buffer
                    tmp=(byte LSR 4) AND $F  ;  tmp.b=(Data LSR 4)&$f
                    sample+table(tmp)        ;  sample=sample+table(tmp)
                    WriteMem 1,&sample,1     ;  output sample To Buffer
                  Until Eof(0)               ;Until endofdata
                  CloseFile 0
                  CloseFile 1
                  PopInput
                  PopOutput
                  Free Sound samplenumber
                  LoadSound samplenumber,"T:tempsamp"
                  KillFile "T:tempsamp"
                Else
                  result=0
                EndIf
              Else
                result=8                    ;temp file failed
              EndIf


            Else
              result=7            ;Unknown compression method!
            EndIf

          EndIf
        Else
          result=4                ;Not enough chip ram!
        EndIf
      EndIf

    Else
      result=3                    ;File is not an iff sound file!
    EndIf

  Else
    result=0                      ;File not found
  EndIf

  Function Return result

End Function

;=============================================================================

; --------- Load an IFF stereo or mono sample --------------------

; It will check for valid file and enough chip ram for loading a sound
; if all is OK, the left sample is loaded into "samplenumber1"
; and the right channel is loaded into "samplenumber2"

; If the sample is not stereo, it is simply loaded into "samplenumber1"

; call with full path to sound file and samplenumbers to be loaded into


Function.b LoadStereo {soundpath$,samplenumber1,samplenumber2}

;returns a byte:

; 0 : requested file not found
; 1 : mono sample was successfully loaded
; 2 : stereo sample was successfully loaded
; 3 : file is not an IFF/8svx sound sample
; 4 : not enough free chip ram to load the sample
; 5 : sample's IFF header is corrupt
; 6 : sample too large to load  (128k is the OS limit)
; 7 : sample is compressed
; 8 : stereo decompression failed

result.b=1                    ;1 means success!

  If ReadFile(0,soundpath$)   ;make sure it is a valid iff sound file!
    FileInput 0
    header$ = Inkey$(500)     ;this should be enough
    CloseFile 0
    PopInput

    ;IFF sound header must start with: FORM....8SVX

    If Left$(header$,4)="FORM" AND Mid$(header$,9,4)="8SVX"

      vhdr.l=Instr(header$,"VHDR")             ;start of Voice Header chunk
      If vhdr
        vhdr+4
        comp.b=Asc(Mid$(header$,vhdr+$13,1))   ;compression method
      Else
        result=5                               ;IFF header is corrupt
      EndIf
      chanassign.l=0
      chan.l=Instr(header$,"CHAN")             ;check for stereo sample
      If chan
        chan+8
        chanassign.l=Cvl(Mid$(header$,chan,4))
      EndIf

      If result=1
        DataAt.l=Instr(header$,"BODY")         ;start of data chunk
        If DataAt
          DataAt+4
          DataLen.l=Cvl(Mid$(header$,DataAt,4));length of sample data
          DataAt+4                             ;start of actual data
        Else
          result=5                             ;IFF header is corrupt
        EndIf
      EndIf

      If result=1

        ok.b=0
        maxdata.l=128000
        If chanassign=6 Then maxdata+128000
        If DataLen > maxdata
          result=6                ;sample too large for the OS!
        Else
          ok.b=CheckChip{DataLen} ;check for enough chip memory
        EndIf

        If ok
          If comp=0               ;not compressed, load it!

            If chanassign=6       ;stereo sample!
              headerlen.l=Instr(header$,"BODY")+3
              stlen.l=DataLen/2
              If OpenFile(0,soundpath$)
                FileInput 0
                If OpenFile(1,"T:tempsamp1")     ;first the left channel
                  FileSeek 0,DataAt              ;Start of sample Data
                  FileOutput 1
                  Print Left$(header$,headerlen) ;make the header
                  WriteMem 1,&stlen,4
                  thisbyte.b=0
                  For byte.l=1 To stlen          ;now store the data
                    ReadMem 0,&thisbyte,1
                    WriteMem 1,&thisbyte,1
                  Next
                  CloseFile 1
                  PopOutput
                Else
                  result=8
                EndIf
                If result<>8
                  If OpenFile(1,"T:tempsamp2")     ;now the right channel
                    FileOutput 1
                    Print Left$(header$,headerlen) ;make the header
                    WriteMem 1,&stlen,4
                    For byte.l=1 To stlen          ;now store the data
                      ReadMem 0,&thisbyte,1
                      WriteMem 1,&thisbyte,1
                    Next
                    CloseFile 1
                    PopOutput
                  Else
                    result=8
                  EndIf
                EndIf
                CloseFile 0                        ;ok, done!  Now load 'em
                PopInput
                Free Sound samplenumber1
                LoadSound samplenumber1,"T:tempsamp1"
                KillFile "T:tempsamp1"
                Free Sound samplenumber2
                LoadSound samplenumber2,"T:tempsamp2"
                KillFile "T:tempsamp2"
                result=2
              Else
                result=0
              EndIf

            Else
              Free Sound samplenumber1
              LoadSound samplenumber1,soundpath$
              result=1
            EndIf
          Else
              result=7            ;sample is compressed!
          EndIf
        Else
          result=4                ;Not enough chip ram!
        EndIf
      EndIf

    Else
      result=3                    ;File is not an iff sound file!
    EndIf

  Else
    result=0                      ;File not found
  EndIf

  Function Return result

End Function

;=============================================================================

;demo

WBenchToFront_
FindScreen 0
MaxLen pa$=255
MaxLen fi$=255

Repeat
  soundpath$=ASLFileRequest$ ("IFF sample to load:",pa$,fi$)
  If soundpath$="" Then End
  result=LoadSample{soundpath$,0}
  NPrint " "
  NPrint fi$
  Select result
    Case 1
      Sound 0,15
      NPrint "Success!"
    Case 2
      Print "Stereo sample... "
      error=LoadStereo{soundpath$,0,1}
      If error=2
        Sound 0,2
        Sound 1,1
        NPrint "success!!"
      Else
        NPrint "failed :("
      EndIf
    Default
      NPrint "Error #",result
  End Select
Forever


