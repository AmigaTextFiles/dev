<HTML>
<BODY BGCOLOR="#000000" TEXT="#ffff00" LINK="#00ff00" VLINK="#ff0000" ALINK="#0000ff">

<PRE>

 <A HREF="e-udp-funcs-in-your-game.html">Putting the UDP funcs into your game</A>  
 <A HREF="udp_send-and-udp_receive.html">UDP_Send and UDP_Receive</A>  
 <A HREF="udp-daemon.html">UDP Daemon</A>  

  Some of the UDP_Funcs are in a separate Include- these are the basic send,
receive, and Initialise UDP functions (all of the UDP_Funcs could be put
into that include). The UDP_Funcs check wether packets have arrived at their
destination and resends them if they haven't (ie: no reply after a certain
time- determined by 'max_wait.w'). After 'number_resends.w' resends they
assume the link is dead and the player is considered offline.
  You can also send Unreliable packets as well (these are just sent out
out and no checks are made if the packet has arrived or not). 
  If it is the Server, it disconnects the player and tells all the other
players that that player is offline. If it is a Client it tells the Server
and if the Server can't connect to the player, the Server then disconnects
the player as above. If the Server can connect to the player then the
Client that claimed the other player was offline, is disconnected. It is
done this way as a security thing- to stop people cheating by claiming
someone is offline (the claims are stored in the player_honesty() array for
later checking if the other player is found to be online)! This is for the
rare case that two players have a connection to a third, but only one of
those players loses connection to the third one. The connection to the
Server is the one that is important. I'm going to change this as it can be
got around with packet filtering. 
   Comms_Housekeeping does most of the work now, and returns wether
your've been connected, disconnected, or your connection attempt has been
rejected or False if nothing interesting has happened.
   Window_Events (not actually part of the UDP Funcs, just an example
interface to them) checks for input from the user and acts accordingly, it
also returns true if the program should exit- ie: if the user clicks on the
close gadget while offine.
   The Net Protocol Header defines the hex numbers that tell what each 
packet is, so you can decode the data in each packet. I haven't fully
documented the protocol on computer file yet, but it's pretty 
self-explanatory. 
   Currently you get an Enforcer hit everytime you call ReadUDP{}, I have to
check again, but I think it's caused by the IoctlSocket{} call. As I've
replaced the call by Rodger Light's asm routine, it can only be a bug in
Miami, and not in my routines.  
  
  You'll notice I've put in some security measures, ie: it checks if the 
packet has come from a logged-in host (rather than having a player number
in the packet- saves data too), so it stops people sending fake messages
to try and cheat. People could still send fake IP packets if they knew what
they were doing. 
 
</PRE>
<HEAD><TITLE>UDP-Functions</TITLE></HEAD><HR>
<I>Converted with <B>g2h</B>, &copy 24.06.1998 <A HREF="http://dept-info.labri.u-bordeaux.fr/~darnis/">N. DARNIS</A></I>
</BODY>
</HTML>
