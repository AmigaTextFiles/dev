
; These are equivalent functions to AB2/3's "Vallong" command
; and a little bit more.

; ie. Equivalent in precision but not quite as fast.

; (C) 2010  Lorence Lombardo.

; Date commenced:-  9-Feb-2010
; Last modified:-   4-Oct-2010


; These functions can also be used with classic Blitz.
; There is no need for identifying characters such as "%" or "$",
; for the number system specific Val's.

; Its probable that you wont need all of them in same program.  ;)

; Someone told me that Peek.w(&a$-2) is faster than Len(a$), but
; I have not noticed much of a difference. Perhaps my system is too
; fast to notice ? I will probably go back to Len in the future. ;)


; Converts an integer decimal string to an integer value

Function.l ValL{a$}
   a$=StripLead$(a$,32) : c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : If s$="-" Then sign=-1
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v>47 AND v<58
         vl=vl*10+v-48
      Else
         c=slen
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; Converts an integer hexadecimal string to an integer value

Function.l ValLH{a$}
   a$=StripLead$(a$,32) : c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : a$=UCase$(a$) : If s$="-" Then sign=-1
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v>47 AND v<58
         vl=vl*16+v-48
      Else
         If v>64 AND v<71
            vl=vl*16+v-55
         Else
            c=slen
         EndIf
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; Converts an integer binary string to an integer value

Function.l ValLB{a$}
   a$=StripLead$(a$,32) : c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : If s$="-" Then sign=-1
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v=48 OR v=49
         vl=vl*2+v-48
      Else
         c=slen
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; Converts an integer octal string to an integer value

Function.l ValLO{a$}
   a$=StripLead$(a$,32) : c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : If s$="-" Then sign=-1
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v>47 AND v<56
         vl=vl*8+v-48
      Else
         c=slen
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; Multi Val very compatible with Vallong including the identifying
; characters, also having the "#" character for octal as a bonus.

Function.l ValLM {a$}
   a$=Replace$(a$,",","") : a$=Replace$(a$," ","")
   c.w=0 : vl.l=0 : sign.b=1
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   ntype$=Left$(a$,1) : base.b=10 : nmax.b=58
   If ntype$<>"%" AND ntype$<>"$" AND ntype$<>"#" Then ntype$=""
   If ntype$<>"" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : If s$="-" Then sign=-1
   If ntype$="%" Then base=2 : nmax=50
   If ntype$="$" Then base=16 : a$=UCase$(a$)
   If ntype$="#" Then base=8 : nmax=56
   Repeat
      v.b=Peek.b(&a$+c) : c+1
      If v>47 AND v<nmax
         vl=vl*base+v-48
      Else
         If base=16 AND v>64 AND v<71
            vl=vl*16+v-55
         Else
            c=slen
         EndIf
      EndIf
   Until c=>slen
   Function Return vl*sign
End Function


; Converts an integer character string to an integer value
; This is unsigned until values exceed 2GB.
; Strings can be 1 to 4 characters in length.
; There is not much point to strings being greater than 4
; characters in length for a long, but this could be changed to
; a double with FPU and in that case positive values can exceed 2GB.

Function.l ValLC{a$}
   vl.l=0 : For x.w=1 To Len(a$) : vl=vl*256+Asc(Mid$(a$,x,1)) : Next x
   Function Return vl
End Function


; Signed version of the above function

Function.l ValLCS{a$}
   slen.w=Peek.w(&a$-2) : vl.l=Peek.b(&a$)
   If slen>1 Then For x.w=2 To slen : vl=vl*256+Asc(Mid$(a$,x,1)) : Next x
   Function Return vl
End Function


; Pure integer power function. ie. a^b
; This is an alternative to Blitz's "^" which rightfully so
; uses floats.

Function.l PowL{a.l, b.l}
   c.l=0 : If b=0 AND a<>0 Then c=1
   If b>0 AND a<>0 Then c=1 : For x.l=1 To b : c=c*a : Next x
   Function Return c
End Function


; Returns the MOD between a and b, with sign support.
; ie. Returns the remainder of a divided by b.
; In regards to negatives the behaviour is more like HB2's MOD
; rather than Blitz's MOD.

Function.l MODL{a.l, b.l}
   c.l=0 : If a<>0 AND b<>0 Then c=a/b
   Function Return a-(b*c)
End Function


; End of functions.

; *******************************************************************************

; Functions demo begins here.


NPrint ValL{"3333.4444"}
NPrint ValLM{"3333.4444"}

NPrint ValL{" 2000000000"}
NPrint ValLM{" 2000000000"}

NPrint ValLH{"ffff"}
NPrint ValLM{"$ffff"}

NPrint ValLB{"1001"}
NPrint ValLM{"%1001"}

NPrint ValLO{"515"}
NPrint ValLM{"#515"}

a$=String$(Chr$(255),3)

NPrint ValLC{a$}

a$=String$(Chr$(255),4)

NPrint ValLC{a$}

a$=Chr$(227)+Chr$(255)

NPrint ValLCS{a$}

a$=Chr$(127)+Chr$(255)

NPrint ValLCS{a$}

NPrint PowL{-10, 9}

bla.l = ValL{"1000000001"} + ValL{"999999999"}

NPrint bla

bla.l = ValLM{"1000000001"} + ValLM{"999999999"}

NPrint bla

NPrint MODL{110, 3}

NPrint ValLM{"$ABCD"}

NPrint ValLM{"-$ABCD"}


