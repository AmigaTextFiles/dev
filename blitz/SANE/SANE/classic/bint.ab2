
; Big integer & big floating point numeric string functions for Blitz.

; (C) 2010  Lorence Lombardo.

; Date commenced:-  27-Jan-2010
; Last modified:-   6-August-2012

; Classic version

; These functions were partially influenced by the works of
; Frank Reibold for HB2.

; See "BigNum.bas" in the archive "Basic_Utils.lha" on the aminet for
; related interest.

; The other influence is "Neo Deus Ex Machina".

; See the archive "bigint.zip" from here:-
; www.petesqbsite.com/downloads/libraries.shtml

; Tons more new stuff added. ;)

; All functions #?_int#? are integer functions.
; All functions #?_F have floating point support.

; Text book references are:-

; "Digital Fundamentals" learing unit 10, 1st edition 1986 from college,
; which I used in 1987 during the B.E.C coarse.

; Known issues:-

; Only legitimate numeric strings should be supplied for a specific
; function and where a sign is permited only one sign at the begining
; should be supplied per numeric string.

; Floating point decimal strings should be passed through the bint{}
; function before being passed into integer functions.

; Most of the functions have been limited to a string size maximum of
; up to 32767 characters for speed reasons. But this could be easily
; changed to go beyond that. You should also make sure that you have
; a sufficient string buffer size in your compiler options.

; So dont go over 32767 characters and your string buffer size if you
; dont want to crash. ;)

; All root_#? functions and the pow_F2 function should be considered
; as beta functions.


#FRAC_MAX=30  ; global constant for default maximum of fraction
              ; decimal places for floating point operations
              ; 50 is good when working with extremely small numbers


; Simple add with no sign support.

Function.s add_int0{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   of.b = 0 :  l.w = Max( Peek.w(&a$-2), Peek.w(&b$-2) )
   a$=RSet$(a$,l) : b$=RSet$(b$,l) : c$=""
   Repeat
      v1.l = Val(Right$(a$,7)) : v2.l = Val(Right$(b$,7))
      erg.l=v1+v2+of : ans$=UStr$(erg) : ansl.w=Peek.w(&ans$-2)
      If ansl<7 Then ans$=String$("0",7-ansl)+ans$
      If ansl>7 Then of=1 : ans$=Right$(ans$,7) Else of=0
      c$=ans$+c$ : l=l-7 : a$=Left$(a$,l) : b$=Left$(b$,l)
   Until l<1
   If of>0 Then c$=UStr$(of)+c$
   c$=StripLead$(c$,48) : If c$="" Then c$="0"
   Function Return c$
End Function


; Simple subtract with no sign support and, "b$" must not be greater
; than "a$". ie. a$=>b$

Function.s sub_int0{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   l.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2) : c$="0"
   If l>l2 OR ( l=l2 AND a$>b$ )
      of.b = 0 : b$=RSet$(b$,l) : c$=""
      Repeat
         v1.l = Val(Right$(a$,7)) : v2.l = Val(Right$(b$,7)) : erg.l=v1-v2-of
         If erg<0
            erg = erg + 10000000 : of=1
         Else
            of=0
         EndIf
         ans$=UStr$(erg) : ansl.w=Peek.w(&ans$-2)
         If ansl<7 Then ans$=String$("0",7-ansl)+ans$
         c$=ans$+c$ : l=l-7 : a$=Left$(a$,l) : b$=Left$(b$,l)
      Until l<1
      c$=StripLead$(c$,48) : If c$="" Then c$="0"
   EndIf
   Function Return c$
End Function


; Multiply with sign support.

Function.s mul_int{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : sign$="" : c$="0"
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If a$="" OR b$="" Then a$="0"
   If a$<>"0" AND b$<>"0"
      l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2) : If s1$<>s2$ Then sign$="-"
      If l2>l1 Then Exchange a$,b$ : Exchange l1,l2
      For x.w=l2 To 1 Step -1
         tmp$=String$("0",l2-x) : v2.b = Val(Mid$(b$, x, 1))
         a2$=a$ : l3.w=l1 : of.b=0
         Repeat
            v1.l = Val(Right$(a2$, 7)) : l3=l3-7 : a2$=Left$(a2$,l3)
            ans$ = UStr$(v1 * v2 + of) : ansl.w=Peek.w(&ans$-2)
            If ansl<7 Then ans$=String$("0",7-ansl)+ans$
            If ansl>7
               of = Val(Left$(ans$, 1)) : ans$=Right$(ans$, 7)
            Else
               of = 0
            EndIf
            tmp$ = ans$ + tmp$
         Until l3<1
         If of>0 Then tmp$ = UStr$(of) + tmp$
         c$ = add_int0{c$,tmp$}
      Next x
   EndIf
   Function Return sign$+c$
End Function


; Simple divide with sign support.  ; Not recommended for direct use.

Function.s div_int0{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : sign$="" : c$="0"
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If a$="" OR b$="" Then a$="0"
   If a$="0" OR b$="0" Then Function Return c$
   l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2)
   If l1>l2 OR ( l1=l2 AND a$=>b$ )
      If s1$<>s2$ Then sign$="-"
      If a$=b$
         c$="1"
      Else
         abbruch.b=0
         While abbruch = 0
            a$=sub_int0{a$,b$} : c$=add_int0{c$,"1"} : l1.w=Peek.w(&a$-2)
            If l1<l2 Then abbruch = 1
            If l1=l2 AND a$<b$ Then abbruch = 1
         Wend
      EndIf
   EndIf
   Function Return sign$+c$
End Function


; Divide wrapper with sign support.

Function.s div_int{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : sign$="" : c$="0"
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If a$="" OR b$="" Then a$="0"
   If a$="0" OR b$="0" Then Function Return c$
   l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2)
   If l1>l2 OR ( l1=l2 AND a$=>b$ )
      If s1$<>s2$ Then sign$="-"
      If a$=b$
         c$="1"
      Else
         tmp1$=Left$(a$,l2-1)
         For x.w = l2 To l1
            tmp1$ = tmp1$ + Mid$(a$, x, 1)  :  in$=div_int0{tmp1$, b$}
            c$ = c$ + in$  :  tmp2$ = mul_int{in$, b$}
            tmp1$ = sub_int0{tmp1$, tmp2$}  :  If tmp1$ = "0" Then tmp1$=""
         Next x
         c$=StripLead$(c$,48) : If c$="" Then c$="0"
      EndIf
   EndIf
   Function Return sign$+c$
End Function


; Add wrapper with sign support.

Function.s add_int{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : sign$=""
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If s1$=s2$
      a$=add_int0{a$,b$} : If s1$="-" Then sign$="-"
   Else
      l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2) : If a$=b$ Then a$="0" : b$=a$
      If l1>l2 OR ( l1=l2 AND a$>b$ )
         a$=sub_int0{a$,b$} : If s1$="-" Then sign$="-"
      Else
         If l1<l2 OR ( l1=l2 AND a$<b$ )
            a$=sub_int0{b$,a$} : If s2$="-" Then sign$="-"
         EndIf
      EndIf
   EndIf
   Function Return sign$+a$
End Function


; Subtract wrapper with sign support.

Function.s sub_int{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : sign$=""
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If s1$=s2$
      l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2) : If a$=b$ Then a$="0" : b$=a$
      If l1>l2 OR ( l1=l2 AND a$>b$ )
         a$=sub_int0{a$,b$} : If s1$="-" Then sign$="-"
      Else
         If l1<l2 OR ( l1=l2 AND a$<b$ )
            a$=sub_int0{b$,a$} : If s1$="+" Then sign$="-"
         EndIf
      EndIf
   Else
      a$=add_int0{a$,b$} : If s1$="-" Then sign$="-"
   EndIf
   Function Return sign$+a$
End Function


; Square root function

Function.s SQR_int{a$}
   a$=Replace$(a$," ","") : s$=Left$(a$,1)
   If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   If a$="1" Then Function Return "1"
   ans$=div_int{a$, "2"}
   Repeat
      prev$=ans$ : ans$=div_int{a$, prev$}
      ans$=add_int{ans$, prev$} : ans$=div_int{ans$, "2"}
   Until prev$=ans$
   Function Return ans$
End Function


; Returns true if an integer number is even

Function.b isEven{a$}
   a$=Replace$(a$," ","") : a$=Replace$(a$,",","") : iseven.b=-1
   v.b=Val(Right$(a$,1)) : If v AND 1 Then iseven=0
   Function Return iseven
End Function


; Returns "a$" to the power of "b$". ie. a$^b$
; "b$" must be unsigned.

Function.s pow_int{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s$=Left$(a$,1) : sign$="" : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48) : c$="0"
   If s$="-" AND isEven{b$}=0 Then sign$="-"
   If b$="" Then b$="0"
   If a$="" Then a$="0"
   If (b$="0" OR a$="1") AND a$<>"0" Then c$="1"
   If b$="1" Then c$=a$
   If b$<>"0" AND b$<>"1" AND a$<>"0" AND a$<>"1"
      c$="1"
      Repeat
         If isEven{b$}=0 Then c$ = mul_int{c$, a$} : b$ = sub_int0{b$,"1"}
         b$ = div_int{b$,"2"} : a$ = mul_int{a$, a$}
      Until b$ = "1"
      c$ = mul_int{c$, a$}
   EndIf
   If c$="0" Then sign$=""
   Function Return sign$+c$
End Function


; Returns a$ to the root of b$.
; ie. b$="2" for square root, b$="3" for cube root, etc...
; This should be considered as a beta function.

Function.s root_int{a$,b$}
   a$=Replace$(a$," ","")
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   s$=Left$(b$,1) : If s$="-" OR s$="+" Then b$=Mid$(b$,2)
   b2$=sub_int0{b$,"1"} : ans$="1"
   Repeat
      prev$=ans$ : ans$=pow_int{prev$, b$} : ans$=mul_int{ans$, b2$}
      ans$=add_int0{ans$, a$} : c$=pow_int{prev$, b2$}
      ans$=div_int{ans$, c$} : ans$=div_int{ans$, b$}
   Until prev$=ans$
   Function Return ans$
End Function


; Returns the integer component of a decimal string.

Function.s bint{a$}
   sign$="" : xp.w=Instr(a$,".") : If xp>0 Then a$=Left$(a$,xp-1)
   If Left$(a$,1)="-" Then sign$="-" : a$=Mid$(a$,2)
   a$=StripLead$(a$,48) : If a$="" Then a$="0" : sign$=""
   Function Return sign$+a$
End Function


; Returns the fractional component of a decimal string.

Function.s bfrac{a$}
   a$=Replace$(a$," ","") : xp.w=Instr(a$,".")
   sign$="" : If Left$(a$,1)="-" Then sign$="-"
   If xp>0 Then a$=Mid$(a$,xp) Else a$="0" : sign$=""
   Function Return sign$+a$
End Function


; Floating point calculator
; Calculates a$ and b$ with a specified operator.
; The default number of maximum fraction decimal places has
; been set to 30, adjust it to your liking. ie. #FRAC_MAX=30
; If this value is insufficient in the case of divide then
; some self adjustments will be made.

Function.s Calc_F {a$, b$, op$}
   frmax.w=#FRAC_MAX : frlen.w=0
   If op$<>"+" AND op$<>"-" AND op$<>"*" AND op$<>"/"
      Function Return "0"
   EndIf
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   af$=bfrac{a$} : bf$=bfrac{b$}
   bfl.w=Len(bf$)-1 : afl.w=Len(af$)-1
   If Left$(af$,1)="-" Then afl-1
   If Left$(bf$,1)="-" Then bfl-1
   a$=Replace$(a$,".","") : b$=Replace$(b$,".","")
   If op$="*"
      If (afl+bfl)>frmax
         ov.w=afl+bfl-frmax
         If bfl>afl Then Exchange a$,b$ : Exchange afl,bfl
         If afl>bfl
            aft.w=afl-bfl
            If aft=>ov
               aft=ov : bft.w=0
            Else
               ov=ov-aft : bft.w=ov/2 : aft=aft+ov-bft
            EndIf
         EndIf
         If bfl=afl Then aft.w=ov/2 : bft.w=ov-aft
         a$=Left$(a$,Len(a$)-aft) : b$=Left$(b$,Len(b$)-bft)
         afl=afl-aft : bfl=bfl-bft
      EndIf
      frlen=afl+bfl : c$=mul_int{a$,b$}
   Else
      If op$<>"/"
         If afl>frmax Then a$=Left$(a$,Len(a$)-(afl-frmax)) : afl=frmax
         If bfl>frmax Then b$=Left$(b$,Len(b$)-(bfl-frmax)) : bfl=frmax
         frlen=Max(afl,bfl)
      EndIf
      If afl>bfl Then b$=b$+String$("0",afl-bfl)
      If bfl>afl Then a$=a$+String$("0",bfl-afl)
   EndIf
   If op$="+" Then c$=add_int{a$,b$}
   If op$="-" Then c$=sub_int{a$,b$}
   If op$="/"
      frlen=frmax : aln.w=Len(a$)+frlen : bln.w=Len(b$)
      s$=Left$(a$,1) : If s$="-" OR s$="+" Then aln-1
      s$=Left$(b$,1) : If s$="-" OR s$="+" Then bln-1
      If bln=>aln Then frlen=frlen+bln-aln+20
      a$=a$+String$("0",frlen) : c$=div_int{a$,b$}
   EndIf
   f$=Right$(c$,frlen) : c$=Left$(c$,Len(c$)-frlen)
   If Left$(f$,1)="-" Then c$="-" : f$=Mid$(f$,2)
   If StripLead$(f$,48)<>""
      f$=String$("0",frlen-Len(f$))+f$
      c$=c$+"."+StripTrail$(f$,48)
   EndIf
   If c$="" Then c$="0"
   Function Return c$
End Function


; Square root function

Function.s SQR_F{a$}
   a$=StripLead$(a$,32) : s$=Left$(a$,1)
   If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   ans$=Calc_F{a$, "2", "/"}
   Repeat
      prev$=ans$ : ans$=Calc_F{a$, prev$, "/"}
      ans$=Calc_F{ans$, prev$, "+"} : ans$=Calc_F{ans$, "2", "/"}
   Until prev$=ans$
   Function Return ans$
End Function


; Returns "a$" to the power of "b$" with partial floating point support.
; b$ must be an integer.

Function.s pow_F{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : sign$="" : s2$=Left$(b$,1)
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48) : c$="0"
   If s1$="-" AND isEven{b$}=0 Then sign$="-"
   If b$="" Then b$="0"
   If a$="" Then a$="0"
   If (b$="0" OR a$="1") AND a$<>"0" Then c$="1"
   If b$="1" Then c$=a$ : If s2$="-" Then c$=Calc_F{"1", c$, "/"}
   If b$<>"0" AND b$<>"1" AND a$<>"0" AND a$<>"1"
      c$="1"
      Repeat
         If isEven{b$}=0 Then c$=Calc_F{c$, a$, "*"} : b$ = sub_int0{b$,"1"}
         b$ = div_int{b$,"2"} : a$ = Calc_F{a$, a$, "*"}
      Until b$ = "1"
      c$ = Calc_F{c$, a$, "*"} : If s2$="-" Then c$=Calc_F{"1", c$, "/"}
   EndIf
   If c$="0" Then sign$=""
   Function Return sign$+c$
End Function


; Returns "T" for true if "a$" is greater than "b$"

Function.s isGT{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   xp1.w=Instr(a$,".") : xp2.w=Instr(b$,".") : af$="" : bf$=""
   If xp1>0 Then af$=StripTrail$(Mid$(a$,xp1+1),48) : a$=Left$(a$,xp1-1)
   If xp2>0 Then bf$=StripTrail$(Mid$(b$,xp2+1),48) : b$=Left$(b$,xp2-1)
   s1$=Left$(a$,1) : s2$=Left$(b$,1) : isgt$="F"
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   If s1$<>"-" Then s1$="+"
   If s2$<>"-" Then s2$="+"
   If s1$=s2$
      l1.w=Peek.w(&a$-2) : l2.w=Peek.w(&b$-2)
      If s1$="+"
         If l1>l2 Then isgt$="T"
         If l1=l2 AND a$>b$ Then isgt$="T"
      EndIf
      If s1$="-"
         If l1<l2 Then isgt$="T"
         If l1=l2 AND a$<b$ Then isgt$="T"
      EndIf
      If a$=b$
         If af$=bf$ Then isgt$="="
         If s1$="+" AND af$>bf$ Then isgt$="T"
         If s1$="-" AND af$<bf$ Then isgt$="T"
      EndIf
   Else
      If s1$="+" Then isgt$="T"
   EndIf
   Function Return isgt$
End Function


; Returns a$ to the root of b$.
; b$ must be an integer.
; ie. b$="2" for square root, b$="3" for cube root, etc...
; This should be considered as a beta function.
; The initial number of 0's in prec$ has been set to 50% of the
; #FRAC_MAX constant, which seems to be reliable. Setting the
; 0's initially in prec$ above 50% could result in an endless loop.
; The precision can be anywhere between 50 to 100% of #FRAC_MAX.
; It was necessary to implement variable precision in order to
; prevent an endless loop. Perhaps one day I might find a better
; way of doing this.
; This function is very sound IMHO, but what is still to be
; determined is wheather the 50% starting point of prec$ is
; low enough to prevent an endless loop.

Function.s root_F{a$,b$}
   a$=StripLead$(a$,32) : c.w=#FRAC_MAX/2 : prec$="."+String$("0",c)+"1"
   s$=Left$(a$,1) : If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   s$=Left$(b$,1) : If s$="-" OR s$="+" Then b$=Mid$(b$,2)
   b2$=sub_int0{b$,"1"} : ans$="1" : res$=""
   Repeat
      prev$=ans$ : ans$=pow_F{prev$, b$} : ans$=Calc_F{ans$, b2$, "*"}
      ans$=Calc_F{ans$, a$, "+"} : c$=pow_F{prev$, b2$}
      ans$=Calc_F{ans$, c$, "/"} : ans$=Calc_F{ans$, b$, "/"}
      x$=Calc_F{prev$, ans$, "-"} : If Left$(x$,1)="-" Then x$=Mid$(x$,2)
      If isGT{prec$,x$}="T"
         res$=ans$
      Else
         If res$<>"" Then c=#FRAC_MAX  ; <- So far tests show that if we already have a result & the
      EndIf                            ;    condition is no longer true then precision cant improve.
      If res$<>"" Then c+1 : prec$="."+String$("0",c)+"1"
   Until c>#FRAC_MAX
   Function Return res$
End Function


; Returns "a$" to the power of "b$" with lots of floating point support.
; Ultra slow and should be avoided if you dont have a super computer. ;)
; Based on the information from this URL:-
; http://planetmath.org/encyclopedia/FractionalPower.html
; Testing with more than 1 fractional digit for b$ is not recomended.
; ie. 1.5 or .5 is OK, but 1.52 or .45 seems to take forever.
; This should be considered as a beta function.

Function.s pow_F2{a$,b$}
   a$=Replace$(a$," ","") : b$=Replace$(b$," ","")
   a$=Replace$(a$,",","") : b$=Replace$(b$,",","")
   s1$=Left$(a$,1) : sign$="" : s2$=Left$(b$,1)
   If s1$="-" OR s1$="+" Then a$=Mid$(a$,2)
   If s2$="-" OR s2$="+" Then b$=Mid$(b$,2)
   a$=StripLead$(a$,48) : b$=StripLead$(b$,48)
   c$="0" : bf$=bfrac{b$}
   If s1$="-" AND bf$="0" AND isEven{b$}=0 Then sign$="-"
   If b$="" Then b$="0"
   If a$="" Then a$="0"
   If (b$="0" OR a$="1") AND a$<>"0" Then c$="1"
   If b$="1" Then c$=a$ : If s2$="-" Then c$=Calc_F{"1", c$, "/"}
   If b$<>"0" AND b$<>"1" AND a$<>"0" AND a$<>"1"
      If bf$="0"
         c$=pow_F{a$,b$}
      Else
         bi$=bint{b$} : bf$=Replace$(bf$,".","")
         div$="1"+String$("0", Len(bf$) )
         m$=mul_int{div$,bi$} : m$=add_int0{m$,bf$}
         c$=pow_F{a$,m$} : c$=root_F{c$,div$}
      EndIf
      If s2$="-" Then c$=Calc_F{"1", c$, "/"}
   EndIf
   If c$="0" Then sign$=""
   Function Return sign$+c$
End Function


; Returns a$ to the root of b$ with lots of floating point support.
; Refer to pow_F2{} for more information.
; This should be considered as a beta function.

Function.s root_F2{a$,b$}
   bf$=bfrac{b$}
   If bf$="0"
      c$=root_F{a$,b$}
   Else
      b$=Calc_F{"1", b$, "/"} : c$=pow_F2{a$,b$}
   EndIf
   Function Return c$
End Function


; Returns "T" for true if "a$" is less than "b$"

Function.s isLT{a$,b$}
   Function Return isGT{b$,a$}
End Function


; Returns true if a$ is equal to b$

Function.b isEQ{a$,b$}
   iseq.b=-1 : If isGT{a$,b$}<>"=" Then iseq=0
   Function Return iseq
End Function


; Returns the maximum between "a$" and "b$"

Function.s maxis{a$,b$}
   If isGT{b$,a$}="T"
      Function Return b$
   Else
      Function Return a$
   EndIf
End Function


; Returns the minimum between "a$" and "b$"

Function.s minis{a$,b$}
   If isGT{b$,a$}="T"
      Function Return a$
   Else
      Function Return b$
   EndIf
End Function


; Returns the MOD between a$ and b$, with sign support.
; ie. Returns the remainder of a$ divided by b$
; In regards to negatives the behaviour is more like HB2's MOD
; rather than Blitz's MOD.

Function.s mod_int{a$,b$}
   c$=div_int{a$, b$} : b$=mul_int{c$, b$}
   Function Return sub_int{a$, b$}
End Function


; Converts an unsigned integer character string to a decimal string.

Function.s CVB{a$}
   v$="0"
   For x.w=1 To Len(a$)
      v$=mul_int{v$, "256"}
      v$=add_int0{v$, UStr$(Asc(Mid$(a$,x,1))) }
   Next x
   Function Return v$
End Function


; Signed version of above function.

Function.s CVBS{a$}
   slen.w=Peek.w(&a$-2) : v$=UStr$(Peek.b(&a$))
   If slen>1
      For x.w=2 To slen
         v$=mul_int{v$, "256"}
         v$=add_int{v$, UStr$(Asc(Mid$(a$,x,1))) }
      Next x
   EndIf
   Function Return v$
End Function


; Converts an unsigned decimal integer string to a character string.

Function.s I2C{a$}
   v$=""
   Repeat
      ans$=div_int{a$,"256"} : tmp$=mul_int{ans$, "256"}
      rem$=sub_int0{a$, tmp$} : v$=Chr$(Val(rem$))+v$ : a$=ans$
   Until ans$="0"
   Function Return v$
End Function


; Like the above function but allows you to fix the minimum byte width.

Function.s I2CW{v$, wid.w}
   v$=I2C{v$} : vl.w=Len(v$)
   If vl<wid Then v$=String$(Chr$(0),wid-vl)+v$
   Function Return v$
End Function


; Converts an integer character string to its complement.

Function.s CHR_COMP{a$}
   v$=""
   For x.w=1 To Len(a$)
      comp.w=255-Asc(Mid$(a$,x,1)) : v$=v$+Chr$(comp)
   Next x
   Function Return v$
End Function


; Converts a signed decimal integer string to a character string.

Function.s I2CS{v$}
   v$=Replace$(v$," ","") : s$=Left$(v$,1)
   If s$="-" OR s$="+" Then v$=Mid$(v$,2)
   v$=StripLead$(v$,48) : If v$="" Then v$="0" : s$=""
   v$=I2C{v$}
   If s$="-"
      v$=CHR_COMP{v$} : c.w=Len(v$)
      Repeat
         chrn.w=Asc(Mid$(v$,c,1))
         If chrn=255
            Poke.b &v$+c-1, 0 : c-1
         Else
            Poke.b &v$+c-1, chrn+1 : c=0
         EndIf
      Until c<1
      If Asc(Left$(v$,1))<128 Then v$=Chr$(255)+v$
   Else
      If Asc(Left$(v$,1))>127 Then v$=Chr$(0)+v$
   EndIf
   Function Return v$
End Function


; Like the above function but allows you to fix the minimum byte width.

Function.s I2CSW{v$, wid.w}
   v$=Replace$(v$," ","") : s$=Left$(v$,1)
   If s$="-" OR s$="+" Then v$=Mid$(v$,2)
   v$=StripLead$(v$,48) : If v$="" Then v$="0" : s$=""
   v$=I2C{v$} : vl.w=Len(v$)
   If s$="-"
      v$=CHR_COMP{v$} : c.w=vl
      Repeat
         chrn.w=Asc(Mid$(v$,c,1))
         If chrn=255
            Poke.b &v$+c-1, 0 : c-1
         Else
            Poke.b &v$+c-1, chrn+1 : c=0
         EndIf
      Until c<1
      If vl<wid Then v$=String$(Chr$(255),wid-vl)+v$
      If Asc(Left$(v$,1))<128 Then v$=Chr$(255)+v$
   Else
      If vl<wid Then v$=String$(Chr$(0),wid-vl)+v$
      If Asc(Left$(v$,1))>127 Then v$=Chr$(0)+v$
   EndIf
   Function Return v$
End Function


; String or endian flipper.

Function.s sflip{a$}
   v$="" : For x.w=1 To Len(a$) : v$=Mid$(a$,x,1)+v$ : Next x
   Function Return v$
End Function


; Converts a decimal integer string to a hex string.

Function.s I2H{a$}
   a$=Replace$(a$," ","") : v$="" : s$=Left$(a$,1)
   sign$="" : If s$="-" Then sign$="-"
   If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   Repeat
      ans$=div_int{a$,"16"} : tmp$=mul_int{ans$, "16"}
      rem$=sub_int0{a$, tmp$} : v.b=Val(rem$)
      If v>9 Then rem$=Chr$(v+55)
      v$=rem$+v$ : a$=ans$
   Until ans$="0"
   Function Return sign$+v$
End Function


; Converts an integer hex string to a decimal string.

Function.s H2I{a$}
   a$=Replace$(a$," ","") : s$=Left$(a$,1)
   sign$="" : If s$="-" Then sign$="-"
   If s$="-" OR s$="+" Then a$=Mid$(a$,2)
   slen.w=Peek.w(&a$-2) : c.w=0 : v$="0" : a$=UCase$(a$)
   Repeat
      c+1 : num$=Mid$(a$,c,1) : v.b=Asc(num$)
      If v>64 AND v<71
         num$=UStr$(v-55)
      Else
         If v<48 OR v>57 Then num$="" : c=slen
      EndIf
      If num$<>"" Then v$=mul_int{v$, "16"} : v$=add_int0{v$, num$}
   Until c=>slen
   Function Return sign$+v$
End Function


; converts an integer character string to a binary string

Function.s chr2bin {char$}
   bins$=""
   For x.w=1 To Len(char$)
      bins$ = bins$ + Right$(Bin$(Asc(Mid$(char$,x,1))),8)
   Next x
   Function Return bins$
End Function


; converts an integer binary string to a character string

Function.s bin2chr {bins$}
   chars$="" : bins$=StripLead$(bins$,48)
   Repeat
      chars$ = Chr$(  Val( "%"+Right$(bins$,8) )  ) + chars$
      bins$=Left$( bins$, Len(bins$)-8 )
   Until bins$=""
   Function Return chars$
End Function


; converts an integer character string to a hex string

Function.s chr2hex {char$}
   hexs$=""
   For x.w=1 To Len(char$)
      hexs$ = hexs$ + Right$(Hex$(Asc(Mid$(char$,x,1))),2)
   Next x
   Function Return hexs$
End Function


; converts an integer hex string to a character string

Function.s hex2chr {hexs$}
   chars$="" : hexs$=StripLead$(hexs$,48)
   Repeat
      chars$ = Chr$(  Val( "$"+Right$(hexs$,2) )  ) + chars$
      hexs$=Left$( hexs$, Len(hexs$)-2 )
   Until hexs$=""
   Function Return chars$
End Function


; De we need big integer octal ? See "octal.ab2" for now.



; End of functions

; ***************************************************************************

; Functions demo begins here:-


l$=Chr$(10) : qt$=Chr$(34)

a$=" 20000000000" : b$="3000000000"
NPrint l$+"add_int0{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint add_int0{a$,b$}+l$

NPrint "sub_int0{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint sub_int0{a$,b$}+l$

NPrint "mul_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint mul_int{a$,b$}+l$

a$=" 60000000000" : b$=" -20000000000"
NPrint "div_int0{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint div_int0{a$,b$}+l$

b$="3"
NPrint "div_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint div_int{a$,b$}+l$

a$="-22000000000" : b$="-3500001000"
NPrint "add_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint add_int{a$,b$}+l$

a$="24000000370" : b$="65000000000"
NPrint "sub_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint sub_int{a$,b$}+l$

NPrint "isGT{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isGT{a$,b$}+l$

NPrint "isLT{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isLT{a$,b$}+l$

NPrint "isEQ{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isEQ{a$,b$},l$

a$="444444 4444444" : b$="4,444,444,444,444"
NPrint "isGT{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isGT{a$,b$}+l$

NPrint "isEQ{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isEQ{a$,b$},l$

a$="-60000000000" : b$="20000000000"
NPrint "maxis{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint maxis{a$,b$}+l$

NPrint "minis{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint minis{a$,b$}+l$

a$="-20030400700" : b$="9"
NPrint "pow_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint pow_int{a$,b$}+l$

a$=String$(Chr$(255),8)
NPrint "a$=String$(Chr$(255),8)"+l$+"CVB{a$}"
NPrint CVB{a$}+l$

NPrint "a$=String$(Chr$(255),8)"+l$+"CVBS{a$}"
NPrint CVBS{a$}+l$

a$=Chr$(127)+String$(Chr$(255),7)
NPrint "a$=Chr$(127)+String$(Chr$(255),7)"+l$+"CVBS{a$}"
NPrint CVBS{a$}+l$

a$="18446744073709551615"
NPrint "a$="+qt$+a$+qt$+l$+"b$=I2C{a$}"+l$+"CVB{b$}"
b$=I2C{a$} : NPrint CVB{b$}+l$

a$=I2H{a$}
NPrint a$
NPrint H2I{a$}+l$


a$=I2CS{UStr$(-1519438842)}
NPrint "a$=I2CS{UStr$(-1519438842)}"+l$+"CVBS{a$}"
NPrint CVBS{a$} : NPrint "CVB{a$}" : NPrint CVB{a$}+l$

a$=I2CSW{UStr$(-1),8}
NPrint "a$=I2CSW{UStr$(-1),8}"+l$+"CVBS{a$}"
NPrint CVBS{a$} : NPrint "CVB{a$}" : NPrint CVB{a$}+l$


a$=I2CS{UStr$(128)}
NPrint "a$=I2CS{UStr$(128)}"+l$+"CVBS{a$}"
NPrint CVBS{a$} : NPrint "CVB{a$}" : NPrint CVB{a$}+l$

a$=I2CSW{UStr$(128),1}
NPrint "a$=I2CSW{UStr$(128),1}"+l$+"CVBS{a$}"
NPrint CVBS{a$} : NPrint "CVB{a$}" : NPrint CVB{a$}+l$


b$=chr2bin{a$}
NPrint b$ : NPrint Len(b$) : b$=bin2chr{b$}
NPrint CVB{b$}+l$

NPrint sflip{"HELLO"}+l$

b$=chr2hex{b$}
NPrint b$ : NPrint Len(b$) : b$=hex2chr{b$}
NPrint CVB{b$}+l$

a$="11,000,000,000" : b$="3"
NPrint "mod_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint mod_int{a$,b$}+l$

a$="4.551" : b$="-5.555" : c$="+"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

c$="-"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

a$="4.5512" : c$="*"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

b$="-5.55501"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

a$="11" : b$="3" : c$="/"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

a$="22" : b$="7"
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

a$="-1" : b$="3000000000000000000000000000000"  : NPrint Len (b$)
NPrint "Calc_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+", "+qt$+c$+qt$+"} :-"
NPrint Calc_F{a$,b$,c$}+l$

a$="2" : b$="-3"
NPrint "pow_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint pow_F{a$,b$}+l$

a$="1.3" : b$="1.29"
NPrint "isGT{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint isGT{a$,b$}+l$

NPrint "SQR_int{UStr$(20)} :-" : NPrint SQR_int{"20"}+l$

NPrint "SQR_F{UStr$(20)} :-" : NPrint SQR_F{"20"}+l$

a$="81" : b$="4"
NPrint "root_int{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint root_int{a$,b$}+l$

a$="20" : b$="3"
NPrint "root_F{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint root_F{a$,b$}+l$

a$="10" : b$=".2"
NPrint "pow_F2{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint pow_F2{a$,b$}+l$                              ; <- Slow hey ?  ;)

a$="10" : b$=".5"
NPrint "root_F2{"+qt$+a$+qt$+", "+qt$+b$+qt$+"} :-"
NPrint root_F2{a$,b$}+l$

End


