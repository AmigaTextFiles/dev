;**************************************************
;*  Date:                September 2002           *
;*  Fixing done by:      amorel (aseq@xs4all.nl)  *
;*  Original source by:  Thilo Koehler cum sui    *
;**************************************************
;
;Some (bug)fixes and cleanup done to make it easier and better to use for me and maybe others
;and when using OS-functions
;
;*  Removed underscores from OS-types
;*  Replaced False and True with NFalse and NTrue(Requires NewCommandSet, on aminet dev/basic/)
;*  Fixed typo and type in Statement error (error{test.s} became error{text$})
;*  Replaced string types .s with $ at various places(except in newtypes)
;*  Changed function image_blit to accept window and screen pointer as parameters
;*  Also changed the function`s code to reflect that and work correctly
;
;Note:  I have tested various functions in my own developments and they worked correctly,
;       but if you find any bugs let me know.

Statement error{text$}           ; enable this statement if you don't have error.include !
  n.l = Request("ERROR:",text$,"OK")
End Statement

; needs the error{} statement, all.res and bb2objtypes.res


.IMAGE_CONSTANTS

#max_images = 200  ; Same like object maximums in debugger, you can edit this line !


 ;  guigfx.library constants

#GGFX_Dummy           = 4567+#TAG_USER
#GGFX_Owner           = #GGFX_Dummy+ 0        ; strictly private */
#GGFX_HSType          = #GGFX_Dummy+ 1
#GGFX_DitherMode      = #GGFX_Dummy+ 2
#GGFX_DitherAmount    = #GGFX_Dummy+ 3
#GGFX_AutoDither      = #GGFX_Dummy+ 4
#GGFX_DitherThreshold = #GGFX_Dummy+ 5
#GGFX_AspectX         = #GGFX_Dummy+ 6
#GGFX_AspectY         = #GGFX_Dummy+ 7
#GGFX_PixelFormat     = #GGFX_Dummy+ 8
#GGFX_Palette         = #GGFX_Dummy+ 9
#GGFX_PaletteFormat   = #GGFX_Dummy+10
#GGFX_NumColors       = #GGFX_Dummy+11
#GGFX_Precision       = #GGFX_Dummy+12
#GGFX_Weight          = #GGFX_Dummy+13
#GGFX_Ratio           = #GGFX_Dummy+14
#GGFX_SourceWidth     = #GGFX_Dummy+15
#GGFX_SourceHeight    = #GGFX_Dummy+16
#GGFX_SourceX         = #GGFX_Dummy+17
#GGFX_SourceY         = #GGFX_Dummy+18
#GGFX_DestWidth       = #GGFX_Dummy+19
#GGFX_DestHeight      = #GGFX_Dummy+20
#GGFX_DestX           = #GGFX_Dummy+21
#GGFX_DestY           = #GGFX_Dummy+22
#GGFX_CallBackHook    = #GGFX_Dummy+23
#GGFX_ErrorCode       = #GGFX_Dummy+24
#GGFX_MaxAllocPens    = #GGFX_Dummy+25
#GGFX_BufferSize      = #GGFX_Dummy+26
#GGFX_AlphaPresent    = #GGFX_Dummy+27
#GGFX_Independent     = #GGFX_Dummy+28
#GGFX_ModeID          = #GGFX_Dummy+29
#GGFX_PenTable        = #GGFX_Dummy+30
#GGFX_License         = #GGFX_Dummy+31        ; obsolete */
#GGFX_BGColor         = #GGFX_Dummy+32        ; private */
#GGFX_UseMask         = #GGFX_Dummy+33
#GGFX_RastLock        = #GGFX_Dummy+34


 ;  Picture Attributes

#PICATTR_Dummy        = 123+#TAG_USER
#PICATTR_Width        = #PICATTR_Dummy+0
#PICATTR_Height       = #PICATTR_Dummy+1
#PICATTR_RawData      = #PICATTR_Dummy+2
#PICATTR_PixelFormat  = #PICATTR_Dummy+3
#PICATTR_AspectX      = #PICATTR_Dummy+4
#PICATTR_AspectY      = #PICATTR_Dummy+5
#PICATTR_AlphaPresent = #PICATTR_Dummy+6


 ;  Picture Methods

#PICMTHD_CROP            =  1
#PICMTHD_RENDER          =  2
#PICMTHD_SCALE           =  3
#PICMTHD_MIX             =  4
#PICMTHD_SETALPHA        =  5
#PICMTHD_MIXALPHA        =  6
#PICMTHD_MAPDRAWHANDLE   =  7
#PICMTHD_CREATEALPHAMASK =  8
#PICMTHD_TINT            =  9
#PICMTHD_TEXTURE         = 10
#PICMTHD_SET             = 11
#PICMTHD_TINTALPHA       = 12
#PICMTHD_INSERT          = 13
#PICMTHD_FLIPX           = 14
#PICMTHD_FLIPY           = 15
#PICMTHD_CHECKAUTODITHER = 16
#PICMTHD_NEGATIVE        = 17
#PICMTHD_AUTOCROP        = 18
#PICMTHD_CONVOLVE        = 19


 ;  hook message types

#GGFX_MSGTYPE_LINEDRAWN  =  1


 ;  picture locking

#LOCKMODE_DRAWHANDLE     = 1
#LOCKMODE_FORCE          = 1 LSL 8
#LOCKMODE_MASK           = $ff


 ;  BitMap attributes

#BMAPATTR_Width        = 0+#TAG_USER
#BMAPATTR_Height       = 1+#TAG_USER
#BMAPATTR_Depth        = 2+#TAG_USER
#BMAPATTR_CyberGFX     = 3+#TAG_USER
#BMAPATTR_BitMapFormat = 4+#TAG_USER
#BMAPATTR_PixelFormat  = 5+#TAG_USER
#BMAPATTR_Flags        = 6+#TAG_USER


#DITHERMODE_NONE       = 0   ; I guessed this values, was not in the includes
#DITHERMODE_FS         = 1   ; Floyd (nice but slow)
#DITHERMODE_RANDOM     = 2   ; Random, very slow
#DITHERMODE_EDD        = 3   ; ugly but fast


;Check if libs are installed, otherwise it makes no sense to run this program
a_lib_name$ = "guigfx.library"
guigfxbase.l  = OpenLibrary_ (&a_lib_name$,16)
If guigfxbase = NFalse Then error {"Please install guigfx.library v16 !"}:End:Else CloseLibrary_ guigfxbase
a_lib_name$ = "render.library"
renderbase.l  = OpenLibrary_ (&a_lib_name$,30)
If renderbase = NFalse Then error {"Please install render.library v30 !"}:End:Else CloseLibrary_ renderbase




.IMAGE_NEWTYPES
NEWTYPE.imagedat
filename.s
pic_ptr.l
psm_ptr.l
drawhandle.l
img_height.l
img_width.l
handle_x.w
handle_y.w
dithermode.b
pad.b
End NEWTYPE





.IMAGE_VARIABLES
Dim imagedat.imagedat(#max_images-1)
Dim imgtags.TagItem (5)




.IMAGE_FUNCTIONS
USEPATH imagedat(image)


.image_free
;*******************************************************************************************************************************
;*
;* image_free {image.l}
;*
;* frees a loaded image and its colour allocations on the screen
;*
;* Inputs:
;* - image.l : Number of the image "Object" (valid range is from 0 to #max_images-1, look on top for the maximum
;*
;**************************************************************************************************************************
Statement image_free {image.l}
SHARED imagedat()
If \pic_ptr    Then DeletePicture_     \pic_ptr      : \pic_ptr    = NFalse
If \psm_ptr    Then DeletePenShareMap_ \psm_ptr      : \psm_ptr    = NFalse
If \drawhandle Then ReleaseDrawHandle_ \drawhandle   : \drawhandle = NFalse
\filename = ""
End Statement


.image_free_data
;*******************************************************************************************************************************
;*
;* image_free_data {image.l}
;*
;* frees the image data of a loaded image but the color allocations are still present
;* NOTE: after you have called this you can not blit the image anymore
;* NOTE: use this if you blit yourimage once and you want to free the memory of the image but it should stay visible in the
;*       correct colours
;*
;* Inputs:
;* - image.l : Number of the image "Object" (valid range is from 0 to #max_images-1, look on top for the maximum
;*
;**************************************************************************************************************************
Statement image_free_data {image.l}
SHARED imagedat()
If \pic_ptr    Then DeletePicture_     \pic_ptr      : \pic_ptr    = NFalse
If \psm_ptr    Then DeletePenShareMap_ \psm_ptr      : \psm_ptr    = NFalse
End Statement


.image_freeall
;*******************************************************************************************************************************
;*
;* image_freeall {}
;*
;* frees all loaded images and its colour allocations on the screen
;* it is save to call this if no image was loaded
;*
;* NOTE: you can use this when you exit your program
;*
;**************************************************************************************************************************
Statement image_free_all {}
SHARED imagedat()
For image.l = 0 To #max_images-1
  image_free {image}
Next
End Statement



.image_load
;*******************************************************************************************************************************
;*
;* success.w = image_load {image.l,filename$}
;*
;* loads an image into RAM
;* all fileformats that have a datatype installed are supported (I think)
;*
;* Inputs:
;* - image.l    : Number of the image "Object"
;* - filename$  : Complete dos filename including path
;*
;* Result:
;* - succ.w     : True if everything went well, False if it failed
;*
;**************************************************************************************************************************
Function.w image_load {image.l,filename$}
SHARED imagedat(),imgtags()
succ.w = NFalse
image_free {image}
If IsPictureA_ (filename$,#TAG_DONE)
  \pic_ptr = LoadPictureA_ (&filename$, #TAG_DONE)
  If \pic_ptr
    \psm_ptr = CreatePenShareMapA_ (#TAG_DONE)
    If \psm_ptr
      If (AddPictureA_(\psm_ptr,\pic_ptr,#TAG_DONE))
        imgtags(0)\ti_Tag = #PICATTR_Width,&\img_width
        imgtags(1)\ti_Tag = #PICATTR_Height,&\img_height
        imgtags(2)\ti_Tag = #TAG_DONE,0
        If GetPictureAttrsA_ (\pic_ptr,&imgtags(0)\ti_Tag)
          \dithermode = #DITHERMODE_FS
          succ.w = NTrue
        Else
          error {"Can't get picture infos !"}
        End If
      Else
        error {"Unable to attach PenShareMap !"}
      End If
    Else
      error {"Unable to create PenShareMap !"}
    End If
  Else
    error {"Unable to load picture !"}
  End If
Else
  error {"Unable to read "+Chr$(34)+filename$+Chr$(34)+" !"}
End If
If succ=NFalse Then image_free {image}
Function Return succ
End Function



.image_blit
;*******************************************************************************************************************************
;*
;* image_blit {image.l,x.l,y.l}
;*
;* "blits" an image to a specific window at coords x/y. It is save to blit outside the window borders
;* NOTE: you have to specify the used screen first with image_setscreen{} !
;* NOTE: this command has big overhead, use image_burst{} instead if you want to blit an image several times
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;* - win.l   : Blitz Obj Number of the Window you want to blit the image to
;* - x.l     : x Coordinate
;* - y.l     : y Coordinate
;*
;**************************************************************************************************************************
Statement image_blit {image.l,x.l,y.l,*winpointer.Window,*screenpointer.Screen}
SHARED imagedat(),imgtags()
If \pic_ptr><NFalse AND *winpointer>=0 AND *screenpointer>=0
  If *winpointer
    If *screenpointer
      If \drawhandle Then ReleaseDrawHandle_ \drawhandle : \drawhandle = NFalse
      *vp.ViewPort = *screenpointer\ViewPort
      \drawhandle = ObtainDrawHandleA_ (\psm_ptr,*winpointer\RPort,*vp\ColorMap, #TAG_DONE)
      If \drawhandle
        imgtags(0)\ti_Tag = #GGFX_DitherMode, \dithermode
        imgtags(1)\ti_Tag = #OBP_Precision, #PRECISION_IMAGE
        imgtags(2)\ti_Tag = #TAG_DONE,0
        DrawPictureA_ \drawhandle, \pic_ptr, x-\handle_x, y-\handle_y, &imgtags(0)\ti_Tag
      End If
    Else
      error {"Tried to blit into a non-exisiting screen !"}
    End If
  Else
    error {"Tried to blit into a non-existing window !"}
  End If
Else
  error {"Uninitialisized image/window/screen !"}
End If
End Statement



.image_blit_rp
;*******************************************************************************************************************************
;*
;* image_blit_rp {image.l,x.l,y.l,rp.l}
;*
;* same like image_blit, but uses any Rasport instead of a window
;*
;**************************************************************************************************************************
Statement image_blit_rp {image.l,x.l,y.l,rp.l,*screenpointer.Screen}
SHARED imagedat(),imgtags()
If \pic_ptr><NFalse AND *screenpointer>=0
  If rp
    If *screenpointer
      If \drawhandle Then ReleaseDrawHandle_ \drawhandle : \drawhandle = NFalse
      *vp.ViewPort = *screenpointer\ViewPort
      \drawhandle = ObtainDrawHandleA_ (\psm_ptr,rp,*vp\ColorMap, #TAG_DONE)
      If \drawhandle
        imgtags(0)\ti_Tag = #GGFX_DitherMode, \dithermode
        imgtags(1)\ti_Tag = #OBP_Precision, #PRECISION_IMAGE  ; image_blit_rp is mainly for GUI-elements
        imgtags(2)\ti_Tag = #TAG_DONE,0
        DrawPictureA_ \drawhandle, \pic_ptr, x-\handle_x, y-\handle_y, &imgtags(0)\ti_Tag
      End If
    Else
      error {"Tried to blit into a non-exisiting screen !"}
    End If
  Else
    error {"Tried to blit into a non-exisitng rastport !"}
  End If
Else
  error {"Uninitialisized screen in image.include!"}
End If
End Statement



 .image_blit_scaled
;******************************************************************************************************************************
;*
;* image_blit_scaled {image.l,x.l,y.l,xs.l,ys.l}
;*
;* same like image_blit, but scaled to the given size xs/ys
;*
;**************************************************************************************************************************
Statement image_blit_scaled {image.l,x.l,y.l,xs.l,ys.l,*winpointer.Window,*screenpointer.Screen}
SHARED imagedat(),imgtags()
;*winpointer=*2pointers\winpointer
;*screenpointer=*2pointers\screenpointer
If \pic_ptr><NFalse AND *winpointer>=0 AND *screenpointer>=0
  If *winpointer
    If *screenpointer
      If \drawhandle Then ReleaseDrawHandle_ \drawhandle : \drawhandle = NFalse
      *vp.ViewPort = *screenpointer\ViewPort
      \drawhandle = ObtainDrawHandleA_ (\psm_ptr,*winpointer\RPort,*vp\ColorMap, #TAG_DONE)
      If \drawhandle
        imgtags(0)\ti_Tag = #GGFX_DitherMode, \dithermode
        imgtags(1)\ti_Tag = #GGFX_DestWidth , xs
        imgtags(2)\ti_Tag = #GGFX_DestHeight, ys
        imgtags(3)\ti_Tag = #TAG_DONE,0
        dx.l = x-\handle_x*xs/\img_width
        dy.l = y-\handle_y*ys/\img_height
        DrawPictureA_ \drawhandle, \pic_ptr, dx, dy, &imgtags(0)\ti_Tag
      End If
    Else
      error {"Tried to blit into a non-exisiting screen !"}
    End If
  Else
    error {"Tried to blit into a non-existing window !"}
  End If
Else
  error {"Uninitialisized image/window/screen !"}
End If
End Statement




.image_optimize
;******************************************************************************************************************************
;*
;* image_optimize {image.l}
;*
;* optimizes an image for fastest possible blitting for a given screen and window
;* this make only sense if you want to blit the image more then once
;* NOTE: you have to call image_setscreen{} AND image_setwindow{} first, because this function has to know
;*       where to blit the image
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;*
;**************************************************************************************************************************
Statement image_optimize {image.l,*screenpointer.Screen}
SHARED imagedat(),imgtags()
If \pic_ptr><NFalse AND *screenpointer>=0
  If *screenpointer
    *vp.ViewPort = *screenpointer\ViewPort
    drawhandle.l = ObtainDrawHandleA_ (\psm_ptr,*screenpointer\RastPort,*vp\ColorMap, #TAG_DONE)
    If drawhandle.l
      If DoPictureMethodA_ (\pic_ptr,#PICMTHD_MAPDRAWHANDLE,drawhandle)
       ;-)
      Else
        error {"Optimizing picture failed ! (DoPictureMethod() failed)"}
        succ.w = image_load {image,\filename}
      End If
    Else
      error {"Optimizing picture failed ! (no drawhandle !)"}
    End If
  End If
End If
End Statement



.image_burst
;******************************************************************************************************************************
;*
;* image_burst {image.l,x.l,y.l}
;*
;* "blits" an image to a window at coords x/y. It is save to blit outside the window borders
;*
;* NOTE: this make only sense if you want to blit the image more then once
;* NOTE: you have to call image_initburst{} or image_blit{} first !
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;* - x.l     : x Coordinate
;* - y.l     : y Coordinate
;*
;**************************************************************************************************************************
Statement image_burst {image.l,x.l,y.l}
SHARED imagedat(),imgtags()
If \drawhandle><NFalse AND \pic_ptr><NFalse
  imgtags(0)\ti_Tag = #GGFX_DitherMode, \dithermode
  imgtags(1)\ti_Tag = #TAG_DONE,0
  DrawPictureA_ \drawhandle, \pic_ptr, x-\handle_x, y-\handle_y, &imgtags(0)\ti_Tag
Else
  error {"Drawhandle/picture was not defined ! image_burst()"}
End If
End Statement




.image_initburst
;******************************************************************************************************************************
;*
;* image_initburst {image.l}
;*
;* defines window and screen and optimizes the image for blitting (no need to call image_optimize{} before)
;*
;* NOTE: this make only sense if you want to blit the image more then once
;* NOTE: this is necessary if you want to use image_burst{}
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;*
;**************************************************************************************************************************
Statement image_initburst {image.l,*screenpointer.Screen,*winpointer.Window}
SHARED imagedat()
If \pic_ptr><NFalse AND *winpointer>=0 AND *screenpointer>=0
  If *winpointer
    If *screenpointer
      If \drawhandle Then ReleaseDrawHandle_ \drawhandle : \drawhandle = NFalse
      *vp.ViewPort = *screenpointer\ViewPort
      \drawhandle = ObtainDrawHandleA_ (\psm_ptr,*winpointer\RPort,*vp\ColorMap, #TAG_DONE)
      If \drawhandle
        If DoPictureMethodA_ (\pic_ptr,#PICMTHD_MAPDRAWHANDLE,\drawhandle)
         ;-)
        Else
          error {"Optimizing picture failed ! (DoPictureMethod() failed)"}
          succ.w = image_load {image,\filename}
          If \drawhandle Then ReleaseDrawHandle_ \drawhandle : \drawhandle = NFalse
        End If
      End If
    Else
      error {"Tried to blit initburst a non-exisiting screen !"}
    End If
  Else
    error {"Tried to blit initburst a non-existing window !"}
  End If
Else
  error {"Uninitialisized image/window/screen !"}
End If
End Statement



.image_release
;*******************************************************************************************************************************
;*
;* image_release {image.l}
;*
;* releases the colormap allocations on the screen - use this only if your image is not visible any more
;* NOTE: after you have called this you have no guarrantee that your image is displayed with the right colors
;* NOTE: on 16/24bit screens this has no visual effect, because the image allocates no pens from the screens colormap
;* NOTE: before you close a screen where did some blitting you MUST call this function or free the images before
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;*
;**************************************************************************************************************************
Statement image_release {image.l}
SHARED imagedat()
If \drawhandle Then ReleaseDrawHandle_ \drawhandle   : \drawhandle = NFalse
End Statement


.image_release_all
;*******************************************************************************************************************************
;*
;* image_release_all {}
;*
;* same like image_release{} but releases all blitted images
;*
;**************************************************************************************************************************
Statement image_release_all {}
SHARED imagedat()
For image.l = 0 To #max_images-1
  If \drawhandle
    image_release {image}
  End If
Next
End Statement


.image_width
;******************************************************************************************************************************
;*
;* width.l = image_width {image.l}
;*
;* gives you back the width of the specified image
;* NOTE: Never use imgaedat() variables directly as they may change in the future
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;*
;* Result:
;* - img_width : width of the image
;*
;**************************************************************************************************************************
Function.l image_width {image.l}
SHARED imagedat()
Function Return \img_width
End Function



.image_height
;******************************************************************************************************************************
;*
;* height.l = image_height {image.l}
;*
;* gives you back the height of the specified image
;* NOTE: Never use imgaedat() variables directly as they may change in the future
;*
;* Inputs:
;* - image.l : Number of the image "Object"
;*
;* Result:
;* - img_height : height of the image
;*
;**************************************************************************************************************************
Function.l image_height {image.l}
SHARED imagedat()
Function Return \img_height
End Function



.image_setdithermode
;******************************************************************************************************************************
;*
;* image_setdithermode {image.l,dithermode.l}
;*
;* Defines the dithermode
;* NOTE: this has only effect on 8bit or lower screens
;*
;* Inputs:
;* - image.l       : Number of the image "Object"
;* - dithermode.l  : use
;*                   - #DITHERMODE_NONE    ; no dithering (recommanded for GUI elements)
;*                   - #DITHERMODE_FS      ; floyd dithering
;*                   - #DITHERMODE_RANDOM  ; slow dithering
;*                   - #DITHERMODE_EDD     ; fast dithering
;*
;**************************************************************************************************************************
Statement image_setdithermode {image.l,dithermode.l}
SHARED imagedat()
\dithermode = dithermode
End Statement



.image_handle
;******************************************************************************************************************************
;*
;* image_handle {image.l,x.l,y.l}
;*
;* Defines the handle of the image. Default is the left-top edge
;*
;* Inputs:
;* - image.l       : Number of the image "Object"
;* - x.l           : x-handle
;* - y.l           : y-handle
;*
;**************************************************************************************************************************
Statement image_handle {image.l,x.l,y.l}
SHARED imagedat()
\handle_x = x
\handle_y = y
End Statement


.image_midhandle
;******************************************************************************************************************************
;*
;* image_midhandle {image.l}
;*
;* Defines the handle of the image as the middle
;*
;* Inputs:
;* - image.l       : Number of the image "Object"
;*
;**************************************************************************************************************************
Statement image_midhandle {image.l}
SHARED imagedat()
\handle_x = \img_width/2
\handle_y = \img_height/2
End Statement


.image_blockcookie
;******************************************************************************************************************************
;*
;* image_blockcookie {shapenumber.l}
;*
;* Creates a cookie for the given shape that has no transparency
;*
;* Inputs:
;* - shapenumber.l       : Number of the shape object
;*
;**************************************************************************************************************************
Statement image_blockcookie {shapenumber.l}
cookie.l = Peek.l(Addr Shape(shapenumber) + 18)
xsize.l  = Peek.w(Addr Shape(shapenumber) +  0) - 1
ysize.l  = Peek.w(Addr Shape(shapenumber) +  2) - 1
xrand.l = xsize MOD 16
pot.l = 32768
xpokes.l = xsize / 16
For n=0 To xrand
  mask.w + pot
  pot / 2
Next
For y.l = 0 To ysize
  x.l = 0
  xcounter.l = xpokes
  While xcounter > 0
    Poke.w cookie,$FFFF
    cookie + 2
    xcounter-1
  Wend
  Poke.w cookie,mask
  cookie + 2
Next
End Statement


.image_2shape
;******************************************************************************************************************************
;*
;* image_2shape {image.l,bshape.l}
;*
;* converts any image into a blitz2 shape object
;* NOTE: don't free the image until the shape is visible somewhere on the screen to keep the colours allocated
;* NOTE: the shape will be freed on exit automatically, the image NOT - use always image_freeall{} at the end of your code
;*
;* Inputs:
;* - image.l  : Number of the image "object"
;* - bshape.l : Number of the Blitz shape object
;*
;**************************************************************************************************************************
Statement image_2shape {image.l,bshape.l,*screenpointer.Screen}
SHARED imagedat()
If \pic_ptr><NFalse AND *screenpointer>=0
  If *screenpointer
   shapedepth.l = GetBitMapAttr_(*screenpointer\RastPort\BitMap,#BMA_DEPTH)
   If shapedepth>8 Then shapedepth=8
  End If
  width.l  = image_width {image}
  height.l = image_height {image}
  *shape_ptr.shape = Addr Shape(bshape)
  DEFTYPE.RastPort rp
  DEFTYPE.BitMap bmp

  Free Shape bshape

  InitShape bshape,width,height,shapedepth
  InitRastPort_ &rp
  InitBitMap_ &bmp,shapedepth,width,height

  For i.w=0 To shapedepth-1
    bmp\Planes[i] = *shape_ptr\_data + i * height * (((width + 15) LSR 3) & $FFFE)
  Next i

  rp\BitMap = &bmp

  image_setdithermode {image,#DITHERMODE_NONE}  ; we don't want dithering in GUI elements

  image_blit_rp {image,0,0,&rp,*screenpointer}
  image_blockcookie {bshape}
Else
  error {"Tried to convert a non-exisiting image !"}
End If
End Statement



.image_loadshape
;******************************************************************************************************************************
;*
;* image_loadshape {bshape.l,filename$}
;*
;* replaces LoadShape with possibility to load 24bit images but looses transparency
;* NOTE: make sure to have a used screen before you call this
;* NOTE: if you cange the screen you have to load the shape again
;* NOTE: the image and the shape object share the same obj number
;* NOTE: the shape will be freed on exit automatically, the image NOT - use always image_freeall{} at the end of your code
;*
;* Inputs:
;* - bshape.l   : Number of the image/shape "object"
;* - filename$  : filename of the image file (can be gif, jpg, iff, bmp usw.)
;*
;* Result:
;* - succ.w     : True if everything went well, False if it failed
;*
;**************************************************************************************************************************
Function.w image_loadshape {bshape.l,filename$,*screenpointer.Screen}
succ.w = NFalse
If image_load {bshape,filename$}
  image_2shape {bshape.l,bshape.l,*ScreenPointer.Screen}
  image_free_data {bshape}
  succ.w = NTrue
End If
Function Return succ
End Function


; Example:
;WbToScreen 0 ; we need to use a screen
;Window 0,0,0,320,200,$E,"image.include test",1,2

;If image_load {0,"MyImage.jpg"}       ; replace this with your image file

;  image_blit {0,20,20}                ; just a normal blit

;  image_midhandle {0}                 ; set the handle of this image to the middle, like the Midhandle command for blitzshapes

;  image_initburst {0}                 ; if you blit it more than once you can gain speed using the image_burst{} function
;  image_burst {0,20,20}               ; and blit it 4 times ...
;  image_burst {0,20,20}
;  image_burst {0,20,20}
;  image_burst {0,20,20}

;  image_setdithermode {0,#DITHERMODE_NONE} ; blit image 0 without dithering, no effect on hi/true-color screens
;  image_burst {0,20,20}

;  newwidth.l  = image_width  {0} / 2  ; get the dimensions and shrink them to half size
;  newheight.l = image_height {0} / 2
;  image_blit_scaled {0,20,20,newwidth.l,newheight.l} ; blit it scaled !

;  image_free {0}                      ; frees explicitly image 0 - its safe to call this twice
;End If


;If image_loadshape {1,"MyImage2.gif"} ; replace this with your image file
;  WBlit 1,20,20                       ; and do what you want with the shape (e.g. WBlit or GTShape buttons)
;End If

;CloseWindow 0

;image_free_all {}     ; always call this before you exit your programm if you have not freed all images yet

;End


