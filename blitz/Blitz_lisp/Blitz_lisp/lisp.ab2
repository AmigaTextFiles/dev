
; Blitz miniature lisp interpreter by Lorence Lombardo.

; This is a miniature lisp interpreter to demonstrate Dietmar Eilert's

; "lisp.library" from the Distributed LISP package from here:-

; http://www.softwareandcircuits.com/division/amiga/products/lisp/index.html

; Usage: lisp.exe <lisp_file> [D=detached] [F=flush] [Args]

; eg1. lisp.exe args.lisp 0 0 test args

; eg2. lisp.exe args.lisp D 0 test args

; 7-Oct-2012

; Theoretically should be more robust than the previous version. ;)

; Tested on 68000+ with ROM 3.0+ only

; AB2/3 compile recommended if possible.


; This also makes a nice demonstration of the GetArg{} argument routine.


; optimize 5  ; <- good for 020+


; The following argument routine obtained from "cli_args.lha" from the
; Aminet. If you dont have "PeekS" replace it with "Peeks$".


*fh.FileHandle = Input_ * 4 : arg_ptr.l = *fh\fh_Buf * 4

l$=Chr$(10) : sc.l=0

Function.s GetArg{}
   SHARED sc, l$,  arg_ptr
   arg$="": arg.b=0: qt.b=0: qt$=Chr$(34): b$=" "
   Repeat
      a$=PeekS(arg_ptr+sc,1): sc+1
      If a$=qt$
         If qt=0
            qt=1: If arg=0 Then arg=1 Else If arg=1 Then arg=2: sc-1
         Else
            qt=0: arg=2
         EndIf
      Else
         If arg=1 AND qt=0 AND a$=" " Then arg=2
         If b$=" " AND a$<>" " AND a$<>l$ AND qt=0 AND arg=0 Then arg=1
         b$=a$: If a$=" " AND qt=0 Then a$=""
         If a$<>l$ AND arg=1 Then arg$=arg$+a$
         If a$=l$ Then sc-1: If arg$="" Then arg$=l$
      EndIf
   Until a$=l$ OR arg=2
   Function Return arg$
End Function


f$=GetArg{}


If f$=l$ OR f$="?" OR f$=""
   NPrint l$+"Usage:- lisp.exe <lisp_file> [D=detached] [F=flush] [Args]"
   NPrint l$+" eg1. lisp.exe args.lisp 0 0 test args"
   NPrint l$+" eg2. lisp.exe args.lisp D 0 test args"+l$
   End
EndIf

INCLUDE "lisp.include.bb2"

If lisp_InitLib{0}=0 Then NPrint "Can not open lisp.library!" : End

err$=String$(Chr$(0), #LISP_MAXERRORSIZE)

opt$=UCase$(GetArg{}) : a_ptr.l=0 : opt2$=""

If opt$<>l$ Then opt2$=UCase$(GetArg{})

If opt2$="F" Then !lisp_flush


If opt2$<>l$ AND opt$<>l$
   scbk.l=sc
   If GetArg{}<>l$
      Repeat
         char.b=Peek.b(arg_ptr+scbk) : If char=32 Then scbk+1
      Until char<>32
      a_ptr=arg_ptr+scbk : Poke.b arg_ptr+*fh\fh_End-1, 0
   EndIf
EndIf


load_tags.l=ArOfLong(#LISP_FILENAME, &f$, #LISP_ARGUMENTS, a_ptr, #TAG_END)


If opt$="D"
   !lisp_run {ret.l, load_tags, &err$}
   If ret=0 Then NPrint "Lisp error: "+Peek$(&err$)
   lisp_FreeLib{} : End
EndIf


create_tags.l=ArOfLong(#LISP_CONSOLE, 0, #TAG_END) : br.b=0


!lisp_create {*machine.l, create_tags, &err$}

If *machine
   !lisp_load {ret.l, *machine, load_tags, &err$}
   If ret
      While br=0
         !lisp_iterate {ret.l, *machine, &err$}
         If ret=0
            err$=Peek$(&err$) : br=1
            If err$<>"" Then NPrint "Lisp error3: "+err$
         EndIf
      Wend
   Else
      NPrint "Lisp error2: "+Peek$(&err$)
   EndIf
   !lisp_dispose{bla.l, *machine}
Else
   NPrint "Lisp error1: "+Peek$(&err$)
EndIf

lisp_FreeLib{} : End


