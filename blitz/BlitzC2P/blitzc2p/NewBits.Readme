
Additional documentation for this release of the C2P collection, by Paul West.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Hi. I decided to do a new release of the C2P routines because in my use of them I
have found a few things that I think may be important to know about and also I
have some code that you may be interested in in the Game directory, which is the
first stages of a 1 or 2 player shootemup along the lines of Datastorm and
Defender. The original BlitzC2P.Readme documentation is still perfectly valid and
this further documentation should be considered additional.

First of all, I am not sure that it is a good idea to use the clearscreening
c2p's as I had tremendous problems getting it to work reliably myself! Sometimes
there seemed to be intermittent problems, sometimes as though there was a strange
bug in blitz itself. Personally I have coded seperate clearscreen routines and
really there is not much difference in speed. I don't think it's a good idea to
use the clearscreening routines in AmigaMode.

In the game sourcecode you will find an implementation of two c2p's, c2p030only
and c2p040only. They are both in a single statement as I have merged them
together, with a small amount of additional code to handle automatic
cpu-detection. When the init() is called it will check for what cpu is present.
If you have 030 or lower or if you have 040 or higher it will set a flag
accordingly. The c2p program will detect this flag and choose the appropriate
routine to use. There are other auto-cpu-sensing routines in the game code as
well.

Despite all the other c2p's, I believe that c2p030only and c2p040only are the
routines of choice so those are the ones I am working with. Also in my game code
I have made some slight alterations. Firstly I have changed the Y modulo to a
planar offset rather than a chunky offset, so effectively making it how it was
originally (and as in the c2p routines). There seemed to be some problem with
offsets that were too large or something so you cannot use the Y modulo as a
chunky offset. The routines are all currently coded to use it as a Planar modulo
anyway. Also I have altered a few lines in the c2p's themselves to use a different
addressing modes so that the range of the c2p operation is doubled. Originally
you were not allowed to convert more than 16384 bytes per bitplane. The limit
is now 32768. This requires a few extra instructions mind you but the difference
is negligible. There are still some instructions in the c2p's which use the
`indirect addressing with 16-bit displacement' addressing mode, which I think is
a signed number. If you were to transform these also you would not have a limit
to the size of the c2p operation.

The modifications that I made to the c2p's I used in the game, to facilitate a
larger bitmap size, was simply to look for any `indirect with 16-bit
displacement' lines that in some way used #planesize*2 as the offset. This was
limiting the number of bytes maximum per bitplane to 16384. I took this out and
replaced it with three lines (two extra instructions). For example, if the
original code was: move.l d0,#planesize*2(a2) ;, I would replace it with: add.l
#planesize*2,a2 : move.l d0,(a2) : sub.l #planesize*2,a2 ;. This occurs only in a
few place in the actual c2p. This modification allows the remaining instructions
such as move.l d0,#planesize(a2) to have a planesize of up to 32768 bytes (about
640x409). If you were to alter the remaining instructions in a similar fashion
you could have any size operation you like, but you must remember that you still
currently have to pass the maximum size of the planar display as a #constant, and
this size of display will be allocated regardless of wether you select a smaller
size and resolution or not. Frankly, anything higher than 320x256 on AGA is
really too slow for just about all uses. The graphics-card code is not affected
by the #planesize constant so you should regard is as an AGA-only thing. You
could code the program to let you have much larger gfx-card displays if you want.
AGA HighGFX 512x384 is perfectly within limits, and is a favourite mode of mine,
although it's not all that fast.

One thing that I may have failed to report in the original release is that there
is a limit on the size at all. Well there is, presently. Also, if you want to
have different resolution modes/sizes in your production you have to set
#planarsize to the maximum dimensions because it still has to be a fixed amount.
In the implementation of the c2p's in the game sourcecode the limit is set to
640x409 which is just short of 32768 bytes. Presently this is the maximum amount
of pixels you are allowed, and the same amount of chipram is allocated even if
you choose a smaller dimension. Currently the game will take the horizontal size
in priority over the verticle, so specifying 1280x512 will use 1280 width but
crop the height so that no more than 32768 bytes are user per bitplane.

Incidentally, holding down either the firebutton or the mouse button immediately
after running the game program will bring up a screenmode requester. There is
code for a callback hook implemented but I haven't got it doing anything yet as
it's a bit tricky. The game code comes in 4 files. The actual game can be found
in the Rupture subdirectory, as the Game directory mainly contains the programs
and graphics that are used to make chunky graphics files and palettes.
Variables.bb2 holds most of the variables that can be defined at that point in
the program. Prefs.bb2 is the preferences bit that does the screenmode requester
and a few other minor things. This is the point where a prefs file should be read
and there are a few variables that I intended to get from the prefs file but
which are currently hardcoded. If the mouse or firebutton is not held at this point
most of the prefs section is skipped.

Display.bb2 is the real interesting bit. There is lots of custom code in there.
There are auto-cpu-sensing routines for background copy, clearscreening and land
copy. There is a full routine to open a screen according to the screenmode
requester by way of screentags() and this should be able to detect wether the
displaymode is a native AGA one or a graphics-card mode. If you choose a graphics
card display you should make sure it's only a 256-colour one. I haven't managed
to filter the truecolour modes out. Somebody also said that there was a small
problem with my attempt to center the display on graphics cards. It works fine on
AGA though. There is also a display routine which will use c2p if it is a chipram
display (AGA) or a WritePixelArray8_() if it is a graphics-card display. So
basically the game will work on graphics cards as well as AGA. The cpu-auto-sensing
c2p code is in Display.bb2 also. You could cut out the c2p routine and the init
routine and they would work happily in your program without any need for any other
bits of the code (except for the constants).

Rupture.bb2 is the game main program, which is the only file that you should try
to compile. It's easy enough to get the other files to compile but there's little
point. The game defaults to a two-player mode at the moment, in which there is a
split-screen. The split is actually adjustable during the game, I think to the
nearest 16 or 32 pixels. Presently the player 1 game area is larger and is
attatched to input from the joystick. Presently the background scrolls vertically
in either direction and the land scrolls horizontally in either direction, with
acceleration and momentum. I have supplied the routines to convert the IFF of the
background and the land into chunky and to save off the palettes. The size of
these can be altered if you wish but I think the conversion programs have
hardcoded sizes. The game should automatically do what is necessary for
wrap-around of both graphics. The original aim was to have a large control panel
with many features at the bottom of the display on top of most of the land
graphic, using the graphic as a background. I have a deluxepaint animation of
what it was going to look like but it is too large to include. I have, however,
included the executable of the game. If the game can't find a file or something
like that it will probably crash, and will also probably crash if there isn't
enough memory.

The way I have handled multitasking in the code is to have some seperate
procedures to allow there to be a `global on/off' sort of switch. If multitasking
really does have to be turned off it is allowed, unless of course it's meant to
be off permanently. Calls are to Forbid{} and Permit{} and Multitasking{On/Off}
instead of Forbid_ and Permit_. The game should run fine with multitasking on, and
is working in AmigaMode. Which reminds me, that horizontal size of the display
should be a multiple of 64 and the game will crop the size to ensure this is so.
So you cannot really have 400x300 super72 mode, as it will crop to 384x300. But
the screen should automatically center in the display, which takes into account
your Text Overscan settings as these are the default `fully viewable'
specifications.

As far as I know, at present, there are no bugs in the code. I recently added the
FreeAGA{} routine because in AGA mode the routine hacks about a little with the
bitmap object and this needs resetting before the o/s or blitz can attempt to
free the bitmaps that are being used. The whole thing seems to work every time
now without crashes or hangs so it seems to be 100% stable. I would also suggest
you don't go too mad with the scrolling speed because if the scroll increment
gets to be larger than the width of the land or the height of the backdrop I
think it might start to do something nasty. The game was going to be targetted to
work `normally' on 040/25 cpu at 320x240 PAL.

Feel free to leech any of the bits from the sourcecode to use in whatever
programs you like, including shareware and commercialware. If you use the
routines as they are, maybe you should consider at least creating your own
graphics though. The routines are currently set to do an `automatic' scroll in
both game areas, just so that it didn't bore me when I stood back in pride. I may
still use this code myself but I'm not sure yet. Note that there are 040+
enhanced clearscreen and copy routines that use `move16' instructions if you have
an 040 or higher cpu. There is also a clearscreen4() routine which is used for
covering up an unsightly scroll effect that occurs at the right hand side of each
game area. The strip of 4 pixels is not just for aesthetics! The 4 rightmost
pixels of each game area usually exhibits a wraparound effect which is not
required so this routine just covers them up. You don't really notice the slight
narrowing of the useable display width and it's a darn sight better than having
to have an extra 64 pixels width just so that scrolling will work! All scrolling
is done in software. I think there is a flag which will switch between a graphic
background and a normal clearscreen, and there are some other bits and pieces you
can adjust also.

I have not done any blit routines as such, although there is some code along
those lines in the demo programs. I suggest you look at Dave Newton's excellent
set of routines which he calls FastGfx, and for a reason. I haven't modified any
of the existing chunky to planar code and I have left the clearscreening code in
just in case you want to use it. It may be more stable in Blitz mode where there
are no system interrupts tampering with the stack pointer. Also in the game, I
have used a verticle clip buffer in the chunky buffer. In effect there is a
large area above and below the actual used buffer which was going to facilitate
being lazy and not having to vertically clip any blit routines that I was going
to do. This can be turned off. Also you can set the doublebuffering on or off by
telling it to use either 1 or 2 buffers. Doublebuffering works properly in both
AGA and graphics card displays, but really there is not much need for it because
in both cases there is practically zero flicker.

I have altered all of the C2P's slightly as I found out that there is a small
piece of code near the start that doesn't seem to be needed. The Init routine
used to place data in the `datanew' location and then in the c2p it would copy
this to a `data' location, and this was 16 longwords. I don't see any need for it
as the C2P does not write to the data locations, it only reads from them, so I
have taken this code out so the code is now slightly shorter and slightly faster.
The difference is only negligible but every little bit counts eh? All of the
c2p's that had this code have been modified as such.

There are now some additional demos in the Demos directory. Some are earlier
versions of the old demos, and some are newer versions. Mainly they have
implemented in one way or another a copy routine to display a background picture
(included). Some of the routines do it by way of a chunkycopying c2p routine,
some use seperate move.l routines, some use seperate movem.l routines, and some
use seperate move16 routines. Chunkyshape5.bb2 and Chunkyshape6.bb2 are
the most recent. It was on from there that I began working on the Game code. I
think that if the demo progs that load in the picture cannot find the picture
they will crash. I don't really do much errorchecking, and sometimes neither does
Blitz.

I think this brings this installment of documentation to a close. Again if you
have any questions or suggestions email me at paul@stationone.demon.co.uk
