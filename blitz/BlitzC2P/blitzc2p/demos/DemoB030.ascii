WBStartup
NoCli

#c2pBPLX=320 ; chunky operation width
#c2pBPLY=240 ; chunky operation height
#planeheight=240 ; planar display height, must not be smaller than c2pBPLY
#c2pBPLSIZE=(#c2pBPLX*#planeheight)/8

#scrwidth=#c2pBPLX
#scrheight=#c2pBPLY

#iterations=40 ; iterations to test the addition of each set of objects (not total)

objcount.l=10 ; number of objects (must be greater than 0) to start with
#maxobjcount=3000 ; maximum number of objects to do (must be greater than objcount!)
#targetfps=25 ; number of frames per second you want to run at
#objmasking=1 ; Nonzero=masking
#objadd=10 ; number of objects to add each time

#objwidth=16 ; minimum of 8
#objheight=16 ; minimum of 1
#objlongwidth=#objwidth/4

#clearscreento=$00000000

; c2p1x1_8_c5
;
; 132% on 040-25

Statement c2p030onlyinit{A.l,B.l}

  ;A.l=d0=Width.w
  ;B.l=d1=Height.w

; d0.w  chunkyx [chunky-pixels]
; d1.w  chunkyy [chunky-pixels]
; d2.w  (scroffsx) [screen-pixels]
; d3.w  scroffsy [screen-pixels]
; d4.w  (rowlen) [bytes] -- offset between one row and the next in a bpl
; d5.l  (c2pBPLSIZE) [bytes] -- offset between one row in one bpl and the next bpl

  MOVEQ.l #0,d2
  MOVEQ.l #0,d3
  MOVE.l  #c2pBPLX/8,d4
  MOVE.l  d4,d5
  MULU    d1,d5

  LEA c2p_datanew(pc),a0
  ANDI.l  #$ffff,d0
  MULU.w  d0,d3
  LSR.l #3,d3
  MOVE.l  d3,c2p_scroffs-c2p_data(a0)
  MULU.w  d0,d1
  MOVE.l  d1,c2p_pixels-c2p_data(a0)
AsmExit
End Statement

Statement c2p030only{A.l,B.l}

  MOVE.l  d0,a0 ; Chunky
  MOVE.l  d1,a1 ; Planar

; a0  c2pscreen
; a1  bitplanes

c2p1x1_8_c5
  MOVEM.l a2-a6,-(a7)

  MOVEM.l a0-a1,-(a7)
  LEA c2p_datanew,a0
  LEA c2p_data,a1
  MOVEQ #16-1,d0
_copy: MOVE.l  (a0)+,(a1)+
  DBF d0,_copy
  MOVEM.l (a7)+,a0-a1
  LEA c2p_data(pc),a2

  MOVE.l  #$33333333,d5
  MOVE.l  #$55555555,d6
  MOVE.l  #$00ff00ff,a6

  ADD.w #c2pBPLSIZE,a1
  ADD.l c2p_scroffs-c2p_data(a2),a1

  MOVE.l  c2p_pixels-c2p_data(a2),a2
  ADD.l a0,a2
  CMP.l a0,a2
  BEQ _none

  MOVEM.l a0-a1,-(a7)

  MOVE.l  (a0),d0
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l d4,d0
  AND.l d4,d2
  LSL.l #4,d0
  OR.l  d2,d0

  AND.l d4,d1
  AND.l d4,d3
  LSL.l #4,d1
  OR.l  d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d7
  MOVE.l  #clearscreento,(a0)+

  AND.l d4,d2     ; Merge 4x1, part 2
  AND.l d4,d1
  LSL.l #4,d2
  OR.l  d1,d2

  AND.l d4,d3
  AND.l d4,d7
  LSL.l #4,d3
  OR.l  d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP  d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP  d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA _start1
_x1
  MOVE.l  (a0),d0
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  d7,c2pBPLSIZE(a1)

  MOVE.l  #$0f0f0f0f,d4   ; Merge 4x1, part 1
  AND.l d4,d0
  AND.l d4,d2
  LSL.l #4,d0
  OR.l  d2,d0

  AND.l d4,d1
  AND.l d4,d3
  LSL.l #4,d1
  OR.l  d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d7
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  a4,(a1)+

  AND.l d4,d2     ; Merge 4x1, part 2
  AND.l d4,d1
  LSL.l #4,d2
  OR.l  d1,d2

  AND.l d4,d3
  AND.l d4,d7
  LSL.l #4,d3
  OR.l  d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP  d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP  d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  MOVE.l  a5,-c2pBPLSIZE-4(a1)
_start1
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l #2,d7
  EOR.l d0,d7
  AND.l d5,d7
  EOR.l d7,d0
  LSL.l #2,d7
  EOR.l d7,d2

  MOVE.l  d3,d7
  LSR.l #2,d7
  EOR.l d1,d7
  AND.l d5,d7
  EOR.l d7,d1
  LSL.l #2,d7
  EOR.l d7,d3

  MOVE.l  d1,d7
  LSR.l #8,d7
  EOR.l d0,d7
  AND.l d4,d7
  EOR.l d7,d0
  LSL.l #8,d7
  EOR.l d7,d1

  MOVE.l  d1,d7
  LSR.l #1,d7
  EOR.l d0,d7
  AND.l d6,d7
  EOR.l d7,d0
  MOVE.l  d0,c2pBPLSIZE*2(a1)
  ADD.l d7,d7
  EOR.l d1,d7

  MOVE.l  d3,d1
  LSR.l #8,d1
  EOR.l d2,d1
  AND.l d4,d1
  EOR.l d1,d2
  LSL.l #8,d1
  EOR.l d1,d3

  MOVE.l  d3,d1
  LSR.l #1,d1
  EOR.l d2,d1
  AND.l d6,d1
  EOR.l d1,d2
  ADD.l d1,d1
  EOR.l d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BNE _x1

  MOVE.l  d7,c2pBPLSIZE(a1)
  MOVE.l  a4,(a1)+
  MOVE.l  a5,-c2pBPLSIZE-4(a1)

  MOVEM.l (a7)+,a0-a1
  ADD.l #c2pBPLSIZE*4,a1

  MOVE.l  (a0),d0
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l d4,d0
  AND.l d4,d2
  LSR.l #4,d2
  OR.l  d2,d0

  AND.l d4,d1
  AND.l d4,d3
  LSR.l #4,d3
  OR.l  d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d7
  MOVE.l  #clearscreento,(a0)+

  AND.l d4,d2     ; Merge 4x1, part 2
  AND.l d4,d1
  LSR.l #4,d1
  OR.l  d1,d2

  AND.l d4,d3
  AND.l d4,d7
  LSR.l #4,d7
  OR.l  d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP  d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP  d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  BRA _start2
_x2
  MOVE.l  (a0),d0
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  d7,c2pBPLSIZE(a1)

  MOVE.l  #$f0f0f0f0,d4   ; Merge 4x1, part 1
  AND.l d4,d0
  AND.l d4,d2
  LSR.l #4,d2
  OR.l  d2,d0

  AND.l d4,d1
  AND.l d4,d3
  LSR.l #4,d3
  OR.l  d3,d1

  MOVE.l  d1,a3

  MOVE.l  (a0),d2
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d1
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d3
  MOVE.l  #clearscreento,(a0)+
  MOVE.l  (a0),d7
  MOVE.l  #clearscreento,(a0)+

  MOVE.l  a4,(a1)+

  AND.l d4,d2     ; Merge 4x1, part 2
  AND.l d4,d1
  LSR.l #4,d1
  OR.l  d1,d2

  AND.l d4,d3
  AND.l d4,d7
  LSR.l #4,d7
  OR.l  d7,d3

  MOVE.l  a3,d1

  MOVE.w  d2,d7     ; Swap 16x2
  MOVE.w  d0,d2
  SWAP  d2
  MOVE.w  d2,d0
  MOVE.w  d7,d2

  MOVE.w  d3,d7
  MOVE.w  d1,d3
  SWAP  d3
  MOVE.w  d3,d1
  MOVE.w  d7,d3

  MOVE.l  a5,-c2pBPLSIZE-4(a1)
_start2
  MOVE.l  a6,d4

  MOVE.l  d2,d7     ; Swap 2x2
  LSR.l #2,d7
  EOR.l d0,d7
  AND.l d5,d7
  EOR.l d7,d0
  LSL.l #2,d7
  EOR.l d7,d2

  MOVE.l  d3,d7
  LSR.l #2,d7
  EOR.l d1,d7
  AND.l d5,d7
  EOR.l d7,d1
  LSL.l #2,d7
  EOR.l d7,d3

  MOVE.l  d1,d7
  LSR.l #8,d7
  EOR.l d0,d7
  AND.l d4,d7
  EOR.l d7,d0
  LSL.l #8,d7
  EOR.l d7,d1

  MOVE.l  d1,d7
  LSR.l #1,d7
  EOR.l d0,d7
  AND.l d6,d7
  EOR.l d7,d0
  MOVE.l  d0,c2pBPLSIZE*2(a1)
  ADD.l d7,d7
  EOR.l d1,d7

  MOVE.l  d3,d1
  LSR.l #8,d1
  EOR.l d2,d1
  AND.l d4,d1
  EOR.l d1,d2
  LSL.l #8,d1
  EOR.l d1,d3

  MOVE.l  d3,d1
  LSR.l #1,d1
  EOR.l d2,d1
  AND.l d6,d1
  EOR.l d1,d2
  ADD.l d1,d1
  EOR.l d1,d3

  MOVE.l  d2,a4
  MOVE.l  d3,a5

  CMPA.l  a0,a2
  BNE _x2

  MOVE.l  d7,c2pBPLSIZE(a1)
  MOVE.l  a4,(a1)+
  MOVE.l  a5,-c2pBPLSIZE-4(a1)

_none
  MOVEM.l (a7)+,a2-a6
AsmExit

  Even4
c2p_data
c2p_scroffs: Dc.l 0
c2p_pixels: Dc.l 0
  Ds.l  16
  Even4
c2p_datanew
  Ds.l  16
End Statement

Statement chunkyshape1{A.l,B.l,C.l,D.l,E.l}
.chunkyshape1
;any position masked with mask data and movement table
  MOVEM.l a3-a6,-(a7)
  MOVE.l  d4,d7 ; object loop
  SUBQ.l  #1,d7
  MOVE.l  d3,a3 ; base of table
  MOVE.l  d0,a4 ; store
  MOVE.l  d1,a5 ; store
  MOVE.l  d2,a6 ; store
objloop

  MOVEQ.l #0,d3
  MOVE.w  (a3),d3
  MOVEQ.l #0,d5
  MOVEQ.l #0,d6
  MOVE.w  4(a3),d5
  MOVE.w  6(a3),d6
  CMP.w   #6,d3 ; x<6?
  BLE     xle
  CMP.w   #scrwidth-objwidth-6,d3
  BLT     xskip
xle
  EXG.l   d5,d6
xskip
  EXT.l   d5
  ADD.l   d5,d3
  MOVE.w  d3,(a3)
  MOVE.w  d5,4(a3)
  MOVE.w  d6,6(a3)

  MOVEQ.l #0,d4
  MOVE.w  2(a3),d4
  MOVEQ.l #0,d5
  MOVEQ.l #0,d6
  MOVE.w  8(a3),d5
  MOVE.w  10(a3),d6
  CMP.w   #6,d4 ; y<6?
  BLE     yle
  CMP.w   #scrheight-objheight-6,d4
  BLT     yskip
yle
  EXG.l   d5,d6
yskip
  EXT.l   d5
  ADD.l   d5,d4
  MOVE.w  d4,2(a3)
  MOVE.w  d5,8(a3)
  MOVE.w  d6,10(a3)

  ADD.l   #12,a3
  MULU    #scrwidth,d4
  MOVE.l  a4,a0 ; input
  ADD.l   d3,d4
  MOVE.l  a5,a2 ; mask
  MOVE.l  a6,d2
  ADD.l   d4,d2 ; output
  MOVE.l  d2,a1 ; output
  MOVE.l  #objheight-1,d2
  MOVE.l  #scrwidth-objwidth,d3
;Do masked blit
yloop
    MOVEQ.l #objlongwidth-1,d4
xloop
      MOVE.l  (a2)+,d0
      AND.l   d0,(a1)
      MOVE.l  (a0)+,d1
      OR.l    d1,(a1)+
      DBRA    d4,xloop
    ADD.l   d3,a1
    DBRA    d2,yloop
  DBRA    d7,objloop
  MOVEM.l (a7)+,a3-a6
AsmExit
End Statement

Statement chunkyshape2{A.l,B.l,C.l,D.l,E.l}
.chunkyshape2
;any position masked with mask data and movement table
;B.l is unused in this routine
  MOVEM.l a3-a6,-(a7)
  MOVE.l  d4,d7 ; object loop
  SUBQ.l  #1,d7
  MOVE.l  d3,a3 ; base of table
  MOVE.l  d0,a4 ; store
;  MOVE.l  d1,a5 ; store
  MOVE.l  d2,a6 ; store
objloop2

  MOVEQ.l #0,d3
  MOVE.w  (a3),d3
  MOVEQ.l #0,d5
  MOVEQ.l #0,d6
  MOVE.w  4(a3),d5
  MOVE.w  6(a3),d6
  CMP.w   #6,d3 ; x<6?
  BLE     xle2
  CMP.w   #scrwidth-objwidth-6,d3
  BLT     xskip2
xle2
  EXG.l   d5,d6
xskip2
  EXT.l   d5
  ADD.l   d5,d3
  MOVE.w  d3,(a3)
  MOVE.w  d5,4(a3)
  MOVE.w  d6,6(a3)

  MOVEQ.l #0,d4
  MOVE.w  2(a3),d4
  MOVEQ.l #0,d5
  MOVEQ.l #0,d6
  MOVE.w  8(a3),d5
  MOVE.w  10(a3),d6
  CMP.w   #6,d4 ; y<6?
  BLE     yle2
  CMP.w   #scrheight-objheight-6,d4
  BLT     yskip2
yle2
  EXG.l   d5,d6
yskip2
  EXT.l   d5
  ADD.l   d5,d4
  MOVE.w  d4,2(a3)
  MOVE.w  d5,8(a3)
  MOVE.w  d6,10(a3)

  ADD.l   #12,a3
  MULU    #scrwidth,d4
  MOVE.l  a4,a0 ; input
  ADD.l   d3,d4
;  MOVE.l  a5,a2 ; mask
  MOVE.l  a6,d2
  ADD.l   d4,d2 ; output
  MOVE.l  d2,a1 ; output
  MOVE.l  #objheight-1,d2
  MOVE.l  #scrwidth-objwidth,d3
;Do unmasked blit
yloop2
    MOVEQ.l #objlongwidth-1,d4
xloop2
      MOVE.l  (a0)+,(a1)+
      DBRA    d4,xloop2
    ADD.l   d3,a1
    DBRA    d2,yloop2
  DBRA    d7,objloop2
  MOVEM.l (a7)+,a3-a6
AsmExit
End Statement

.blitzprogram
; Setup
InitBank 1,#scrwidth*#scrheight,$10000 ; Fastram chunky buffer
InitPalette 0,256
For c=1 To 255
  AGAPalRGB 0,c,(c/2)+Rnd(128),(c/2)+Rnd(128),(c/2)+Rnd(128)
Next c
AGAPalRGB 0,0,0,0,0
VWait
InitBank 0,(#scrwidth*Max(#planeheight,#c2pBPLY))+1000,2|65536 ; Chipram planar buffer
CludgeBitMap 0,#scrwidth,Max(#planeheight,#c2pBPLY),8,Bank(0)
Screen 0,0,0,#scrwidth,Max(#planeheight,#c2pBPLY),8,0,"c2p test",0,0,0
Use Palette 0
VWait 50

; chunky shape
InitBank 2,#objwidth*#objheight,$10000 ; chunky shape
cstep.q=256/(#objwidth*#objheight)
c.q=0
For o.l=0 To (#objwidth*#objheight)-1
  NPokeB Bank(2)+o,255-c
  c+cstep
Next o
If #objmasking<>0
  CacheClearU_
  For o.l=0 To #objwidth*#objheight
    p3.l=Bank(2)+Rnd(#objwidth*#objheight)-1
    NPokeB p3,$00
  Next o
EndIf

; chunky mask
InitBank 3,#objwidth*#objheight,$10000 ; chunky mask
For o.l=0 To (#objwidth*#objheight)-1
  If NPeekB(Bank(2)+o)=0 Then NPokeB Bank(3)+o,$ff Else NPokeB Bank(3)+o,$0
Next o

; movement table
InitBank 5,#maxobjcount*12,$10000 ; table
For o.l=0 To (#maxobjcount-1)*12 Step 12
  p1.w=6+Rnd(#scrwidth-#objwidth-14)
  p2.w=6+Rnd(#scrheight-#objheight-14)
  NPokeW Bank(5)+o,p1
  NPokeW Bank(5)+o+2,p2
  Repeat:xmove.w=Rnd(3)-Rnd(6):Until xmove<>0
  Repeat:ymove.w=Rnd(3)-Rnd(6):Until ymove<>0
  NPokeW Bank(5)+o+4,xmove
  NPokeW Bank(5)+o+6,-xmove
  NPokeW Bank(5)+o+8,ymove
  NPokeW Bank(5)+o+10,-ymove
Next o

; Do the c2p test
c2p030onlyinit{#scrwidth,#scrheight}
CacheClearU_
Forbid_
VWait
While Joyb(0)=0
  If #objmasking<>0
    ResetTimer
    For time=1 To #iterations
      chunkyshape1{Bank(2),Bank(3),Bank(1),Bank(5),objcount}
      c2p030only{Bank(1),Bank(0)} ; Convert chunky to planar
    Next time
    t=Ticks
  Else
    ResetTimer
    For time=1 To #iterations
      chunkyshape2{Bank(2),Bank(3),Bank(1),Bank(5),objcount}
      c2p030only{Bank(1),Bank(0)} ; Convert chunky to planar
    Next time
    t=Ticks
  EndIf
  fps.q=50/(t/#iterations)
  If (fps>#targetfps) AND (objcount<=(#maxobjcount-#objadd)) Then objcount+#objadd Else Goto skipwend
Wend
skipwend:
VWait 2 : Permit_
VWait 20
FindScreen 0
Window 0,0,11,640,100,0,"Test results for c2p",0,0
WindowOutput 0
NPrint "Routine performed @",#targetfps,"(",fps,")fps, doing ",objcount," ",#objwidth,"x",#objheight," objects."
NPrint " "
NPrint "Press mousebutton..."
Free Screen 0
MouseWait
Free Window 0
End

