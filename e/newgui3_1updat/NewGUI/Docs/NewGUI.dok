

                                   NewGui 3.1 (Pre-Release)
                                  -==========-



 1. Was ist NewGUI ?

 2. Was unterscheidet NewGUI von anderen Oberflächengeneratoren?

 3. Programmierung von NewGUI

    3.1 Die Prozeduren

        3.1.1 guiinitA()
        3.1.2 guimessage()
        3.1.3 cleangui()
        3.1.4 newguiA()
        3.1.5 ng_getattrsA()
        3.1.6 ng_setattrsA()

    3.2 Alle Tags mit Erklärungen

    3.3 Die Gui-Elemente

        3.3.1 Grundlegendes zur GUI-Programmierung
        3.3.2 Gruppen
        3.3.3 Elemente

    3.4 Plugin - Programmierung

        3.4.1 Plugin - Objekt
        3.4.2 after_reply()
        3.4.3 clear_render()
        3.4.4 render()
        3.4.5 gtrender()
        3.4.6 will_resize()
        3.4.7 min_size()
        3.4.8 isgtgadget()
        3.4.9 disable()
        3.4.A message_test()
        3.4.B message_action()
        3.4.C handlednd()
        3.4.D performdnd()
        3.4.E dnd_xchange()

    3.7 Das Modulare Konzept von NewGUI

    3.6 Fehler-codes

 4. Copyright

 5. Über



 1. Was ist NewGUI?
-==================-

        NewGUI ist ein Modul für die Programmiersprache >Amiga E< welches
        es dem Programmierer erleichtern soll eine Oberfläche für ein
        Programm zu schreiben. Dabei bietet NewGUI einige Fertigkeiten
        und Zusätze (z.B. Drag 'N' Drop, ARexx-Port, Online-Hilfe...)
        welche die Oberfläche sehr Hochwertig machen, aber den Aufwand
        für die Erstellung minimal halten.
        Entstanden ist NewGUI bereits Anfang 1995, allerdings waren die
        ersten 4-5 Versionen nicht gerade akzeptabel (vom Aussehen,
        vom Programmieraufwand ect...), aber allmälich wuchs aus dieser
        Idee eine Ausgereifte GUI-Engine. Als dann Ende 1997 der Source-
        Code zu EasyGUI veröffentlicht wurde habe ich diesen benutzt
        (NICHT KOPIERT!) um meine GUI-Engine kompatibel zu Easygui zu 
        gestalten (Syntax-Kompatibel). Das Plugin-Interface von NewGUI
        wurde ebenfalls Angepasst, aber die Vorzüge von NewGUI wurden
        beibehalten (Drag 'N' Drop...).
        Einige wenige behaupten, daß NewGUI einfach nur eine billige
        Kopie von EasyGUI darstellt, aber es wurde KEIN Teil des EasyGUI
        Sources kopiert, dieser diente nur als Vorlage und als Nachschlage-
        werk für Anregungen - NewGUI ist also keine Kopie, und alles
        andere als billig aufgemacht! Ich wurde schon gefragt, warum ich
        den Source von NewGUI nicht veröffentliche um dies zu beweisen,
        aber gerade das ist nicht meine Absicht, denn sonst würde es
        ähnlich wie bei EasyGUI (und bei D**M) gehen und auf einmal
        viele Abwandlungen auftauchen, und dies führt dann zu einem
        totalen Chaos ...


 2. Was unterscheidet NewGUI von anderen Oberflächengeneratoren?
-===============================================================-

        Im Gegensatz zu den meisten anderen Oberflächen-generatoren
        (z.B. MUI, Triton, BGUI...) ist NewGUI keine Externe Library
        oder externe Klassen, dies kann man sowohl als Vor- wie auch
        als Nachteil sehen. Auf jeden Fall steht fest, daß NewGUI
        nicht so überladen ist wie (meines erachtens) MUI und andere,
        nicht jede Applikation braucht APP-Icon-Support, Commoditie-
        Eigenschaften ect... außerdem sind die meisten MUI-Elemente
        keine echten Intuition-Gadgets (Beweis: Im AmiNet gibt es
        ein Programm, ich glaube es heißt "ShowGadgets", welches alle
        Intuition-Gadgets (und BOOPSI-Klassen) eines Fensters zeigen
        kann - aber nur die Slider von MUI werden als solche gezeigt!)
        und umgehen Intuition teilweise (es werden nur die MOUSEMOVE
        und BUTTONUP/BUTTONDOWN-Messages der Maus benutzt, kein
        Intuition-Button-Message!). Dadurch kann es zu verlangsamung
        des Systems und (evtl.) zu Inkompatibilitäten mit späteren
        Betriebssystem-Versionen kommen (NewGUI benutzt GadTools-
        Gadgets, profitiert also von jeder Weiterentwicklung der
        GadTool.library!!).
        Es liegt aber in der Hand der Programmierers welche Engine
        er einsetzen will, denn der Oberflächengenerator welcher
        alles 100% so kann und 100% so tut wie es der Programmierer
        und der User wollen ist noch nicht entwickelt! (Dies sollte
        die Aufgabe der Betriebssystem-Programmierer sein und nicht
        die eines Dritt-Anbieters!)


 3. Programmierung von NewGUI
-============================-

 3.1 Prozeduren:
 ===============

        3.1.1 guiinitA()
        ----------------

        SYNTAX:

                guihandle:=guiinitA(taglist,maingh=NIL)

        PARAMETER:

                taglist = PTR auf die Tagliste zur GUI-Beschreibung
                maingh  = Nicht benutzen! (Interne Verwendung!)

        RÜCKGABE:

                guihandle = PTR auf ein Objekt des Typs >guihandle<

        FUNKTION:

                Öffnet eine Oberfläche (evtl. auch ARexx-Port, Screen,
                ect...) anhand der angegebenen Beschreibung!
                Folgende Tags müssen IMMER (!) angegeben werden:
                NG_GUI, NG_GUIID

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                newguiA() / guimessage() / cleangui()

        3.1.2 guimessage()
        ------------------

        SYNTAX:

                return:=guimessage(guihandle)

        PARAMETER:

                guihandle = PTR auf das MAIN-GUI (bei MultiWindow-Support,
                            sonst PTR auf das jeweilige guihandle!)

        RÜCKGABE:

                return = Returnwert (z.B. 0, wenn das GUI geschlossen werden
                         soll, oder der Wert der als Aktion eines GUI-
                         Elements angegeben wurde)

        FUNKTION:

                Holt evtl. Messages und bearbeitet diese, hier werden alle
                Aktionen des Guis behandelt ect...!

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                guiinitA() / cleangui()

        3.1.3 cleangui()
        ----------------

        SYNTAX:

                cleangui(guihandle,all=FALSE)

        PARAMETER:

                guihandle = PTR auf das MAIN-GUI (Bei MultiWindow-Support,
                            sonst PTR auf das jeweilige guihandle!)
                all       = Alle UnterGUIs sollen geschlossen werden (Bei
                            MultiWindow-Support!)

        RÜCKGABE:

                Keine

        FUNKTION:

                Schließt das angegebene GUI (oder alle Guis, wenn all=TRUE!)

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                guiinitA() / guimessage()

        3.1.4 newguiA()
        ---------------

        SYNTAX:

                return:=newguiA(taglist,getghproc)

        PARAMETER:

                taglist   = PTR auf die Tagliste zur GUI-Beschreibung
                getghproc = PTR auf eine Prozedur, die einige wichtige
                            holt oder NIL (wenn die Daten nicht benötigt
                            werden), Syntax der Prozedur muß sein:

                                getghproc(guihandle,screen) 

                            ACHTUNG! Keine Rückgabeparameter setzen!

        RÜCKGABE:

                return = Returnwert (z.B. 0, wenn das GUI geschlossen werden
                         soll, oder der Wert der als Aktion eines GUI-
                         Elements angegeben wurde)

        FUNKTION:

                Zusammenfassung von guiinitA(), guimessage() und cleangui().
                Übernimmt das Window-Handling und schließt ggf. das / die
                Gui(s). Falls das GUI aufgrund eines zu großen Fonts nicht
                geöffnet werden kann, wird ein Fallback auf den ROM-Font
                >Topaz< der größe 8 versucht!
                Folgende Tags müssen IMMER (!) angegeben werden:
                NG_GUI, NG_GUIID

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                guiinitA() / guimessage() / cleangui()

        3.1.5 ng_getattrsA()
        --------------------

        SYNTAX:

                return:=ng_getattrsA(taglist)

        PARAMETER:

                taglist = PTR auf die Taglist welche die Informationen
                          enthält (Angabe welche Daten geholt werden
                          sollen!)

        RÜCKGABE:

                return = Rückgabewert der Funktion (evtl. Ergebnis einer
                         Aktion, oder z.B. PTR auf eine Variable ect...)
                         siehe dazu in der Beschreibung des jeweiligen
                         Tags!

        FUNKTION:

                Mittels dieser Prozedur kann man Daten vom Gui anfordern!
                Folgenden Tags MÜSSEN (!) immer angegeben werden:
                NG_GUI, NG_GUIID

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                ng_setattrsA() / guiinitA() / newguiA()

        3.1.6 ng_setattrsA()
        --------------------

        SYNTAX:

                return:=ng_setattrsA(taglist)

        PARAMETER:

                taglist = PTR auf die Taglist, welche die Informationen
                          enthält (Angabe welche Daten gesetzt werden 
                          sollen!)

        RÜCKGABE:

                return = Rückgabewert der Funktion (evtl. Ergebnis einer
                         Aktion, oder z.B. PTR auf eine Variable ect...)
                         siehe dazu in der Beschreibung des jeweiligen
                         Tags!

        FUNKTION:

                Mittels dieser Prozedur kann man Daten zum GUI setzen/ändern,
                folgende Tagd MÜSSEN (!) immer angegeben werden:
                NG_GUI, NG_GUIID

        FEHLER:

                Keine bekannt!

        SIEHE AUCH:

                ng_getattrsA() / guiinitA() / newguiA()


 3.2 Alle Tags (mit Erklärungen)
 ===============================

        NG_WINDOWTITLE
                Gibt den Titel des Fensters an

        NG_WINDOWLEFT
                X-Offset des Fensters (wenn dieses Tag nicht angegeben wird,
                wird das Fenster auf der X-Coordinate Zentriert!)

        NG_WINDOWTOP
                Y-Offset des Fensters (wenn dieses Tag nicht angegeben wird,
                wird das Fenster auf der Y-Coordinate Zentriert!)

        NG_WINDOWMAXWIDTH
                Maximal zulässige Breite des Fensters

        NG_WINDOWMAXHEIGHT
                Maximal zulässige Höhe des Fensters

        NG_WINDOWWIDTH
                Breite des Fensters (die Berechnung solle NewGUI überlassen
                werden, da eine Falscher Wert hier zu Fehlern im GUI führen
                kann!)

        NG_WINDOWHEIGHT
                Höhe des Fensters (die Berechnung solle NewGUI überlassen
                werden, da eine Falscher Wert hier zu Fehlern im GUI führen
                kann!)

        NG_WINDOWTYPE
                Art des Fensters, folgende Arten sind möglich:
                    WTYPE_BASIC    - Nur ein Rahmen, kein Titel, keine
                                     Systemgadgets (Closegadget ect..!)
                    WTYPE_NOSIZE   - Alle Systemgadgets außer dem Size-Gadget
                    WTYPE_COMPLETE - Komplettes Fenster (Alle Systemgadgets)

        NG_SCREEN
                PTR auf eine bereits geöffneten Schirm, dieser wird dann
                für die Fenster benutzt, aber bei beendigung NICHT
                geschlossen!

        NG_CLONESCREEN
                Ein eigener Screen soll geöffnet werden, evtl. Daten
                die benötigt werden, aber NICHT angegeben sind vom
                Workbench-Screen holen (alternative: siehe NG_OPENPUBSCREEN!)

        NG_SCR_WIDTH
                Breite des Screens (wenn dieses Tag NICHT angegeben wird,
                wird die Breite anhand des Workbenchscreens ermittelt!)

        NG_SCR_HEIGHT
                Höhe des Screens (wenn dieses Tag NICHT angegeben wird,
                wird die Höhe anhand des Workbenchscreens ermittelt!)

        NG_SCR_DEPTH
                Tiefe des Screens in Bitplanes (wenn dieses Tag NICHT 
                angegeben wird, wird die Tiefe anhand des Workbenchscreens
                ermittelt!)

        NG_SCR_PENS
                Stifte des Screens (wenn dieses Tag NICHT angegeben wird,
                werden die Pens anhand des Workbenchscreens ermittelt!)

        NG_SCR_MODEID
                ModeID des Screens (wenn dieses Tag NICHT angegeben wird,
                wird die ModeID anhand des Workbenchscreens ermittelt!)

        NG_SCR_TITLE
                Titelzeile (Text) des Screens (wenn dieses Tag NICHT 
                angegeben wird, ist die Titelzeile Leer!)

        NG_SCR_PUBNAME
                Name des eigenen Pubscreens (oder Name eine Pubscreens,
                den wir benutzen sollen, siehe dazu NG_OPENPUBSCREEN)

        NG_SCR_TAGS
                Zusätzliche Tags für die Screen-Struktur (SA_xxx siehe dazu
                in den Intuition-Autodoks!)

        NG_OPENPUBSCREEN
                Wenn dieses Tag TRUE ist, dann soll das GUI auf einem
                ANDEREN (Fremden) Pubscreen geöffnet werden. Der Name
                des fremden Pubscreens muß mit NG_PUBNAME angegeben
                werden!

        NG_USEMAINSCREEN
                Nur bei MultiWindow-Support sinnvoll!
                Screen des Main-Fensters wird benutzt!

        NG_GUI
                Gui-Beschreibung (sihe dazu 3.3!!!)

        NG_DUMMY
                Nur bei Multi-Window-Support zu benutzen!!!!!
                Parameter für NG_GUI, damit wird erreicht, daß das erste
                Fenster ein Backgroundfenster ist (z.B. um Menüs auf dem
                ganzen Screen zu ermöglichen!) und keine Gadgets ect...
                enthält (aber alle anderen Sachen werden initialisiert,
                z.B. Fonts, Screen, ARexx-Port ect...!)

        NG_GUIID
                ID des Guis (ACHTUNG! das erste Gui muß (!!!!!!) unbedingt
                als ID die Konstante GUI_MAIN haben (diese ist auf 1 zu
                setzen!!!!), die folgenden _sollten_ mit ENUM durch-
                nummeriert sein!

        NG_DOUBLEGUI
                Dieses Gui kann trotz seiner GuiID doppelt offen sein!
                (z.B. Requester!)

        NG_NEXTGUI
                PTR auf eine KOMPLETTE TagListe (welche normalerweise den
                Prozeduren newguiA() oder guiinitA() übergeben werden!) die
                Angaben zu einer weiteren Oberfläche enthalten!

        NG_AUTOOPEN
                Nur bei MultiWindow-Support sinnvoll!
                Wenn dieses Tag TRUE ist, dann wird dieses Fenster sofort
                zu beginn geöffnet, sonst ist es zwar initialisiert, aber
                geschlossen, es muß dann mit NG_OPENGUI geöffnet werden!

        NG_TEXTATTR
                PTR auf ein Textattr, (Font muß geöffnet sein!), dieser
                Font wird dann für DIESES Fenster benutzt!

        NG_FONT_NAME
                Name des zu verwendenden Fonts (dieser wird ggf. geöffnet!)
                Nur in Verbindung mit NG_FONT_SIZE sinnvoll!

        NG_FONT_SIZE
                Größe (Höhe in Pixeln) des zu verwendenden Fonts (nur in
                Verbindung mit NG_FONT_NAME sinnvoll!)

        NG_USEMAINFONT
                Nur bei MultiWindow-Support sinnvoll!
                Font des Main-Fensters wird benutzt!

        NG_MENU
                Menü für das Fenster, PTR auf eine GadTools-NewMenu-
                Struktur!

        NG_HELPGUIDE
                Name des Guides für die Onlinehilfe (kann für
                jedes Fenster unterschiedlich sein und muß daher für
                jedes Fenster neu angegeben werden!)

        NG_DATA
                Daten für den Guihandle (z.B. PTR auf ein Objekt!), diese
                Daten werden jeder Prozedur die vom GUI aus geht (Aktion)
                übergeben!

        NG_ONCLOSE
                PTR auf eine Prozedur welche aufgerufen wird wenn das
                CloseGadget des zugehörigen Fensters betätigt wird (Diese
                Prozedur ist für jedes Guihandle getrennt anzugeben, kann
                aber auch immer ein PTR auf die gleiche Prozedur sein, oder
                NIL!). Diese Prozedur wird mit folgendem Syntax aufgerufen:

                        return:=onclose(guihandle)

                WICHTIG (!) ist der Returnwert, dieser darf nur folgende
                Werte haben:

                -1 = Kein Fenster schließen!
                 0 = Alle Guis schließen!
                -2 = Nur das Fenster zu diesem Guihandle schließen!

        NG_ONTICK
                PTR auf eine Prozedur, die bei jedem INTUITICK aufgerufen
                wird, folgender SYNTAX wird benutzt:

                        ontick(info,guihandle)

                info      = Wert bei NG_DATA
                guihandle = PTR auf den eigenen Guihandle (NICHT Main-GUI!)

        NG_ONHIDE
                PTR auf eine Prozedur, die NACH einem HIDE-Vorgang (mittels
                ng_setattrsA() und NG_HIDE) aufgerufen wird. Diese Prozedur
                muß später dann wieder ein NG_APPEAR aufrufen oder gleich
                nach einer KURZEN Aktion (z.B. AppIcon erzeugen) fertig
                sein (und damit wieder zu guimessage() zurückkehren)

        NG_ONAPPEAR
                PTR auf eine Prozedur, die VOR einem APPEAR-Vorgang
                (ng_setattrsA() und NG_APPEAR) aufgerufen wird, damit
                kann man z.B. ein AppIcon wieder entfernen ect...).
                Diese Prozedur sollte so kurz wie möglich sein!

        NG_REXXNAME
                Name des ARexx-Portes (dieser wird automatisch mit einer
                Laufenden Nummer versehen!)

        NG_REXXPROC
                PTR auf eine Prozedur, die ARexx-Messages analysiert (siehe
                dazu in die Dokumentation des AFC-Rexxers!)

        NG_GETRX
                Liefert einen PTR auf eine rx-Struktur des AFC-Rexxers
                zurück (gedacht zum versenden von ARexx-Messages, der
                Empfang SOLLTE (muß) NewGUI vorbehalten bleiben!!!)

        NG_FILLHOOK
                PTR auf eine Prozedur die das Füllen im NewGUI-Fenster
                übernimmt (Hintergrundfüllen und Füllen von Gruppen!),
                diese Prozedur wird mit folgender SYNTAX aufgerufen:

                        fill(rastport,x,y,width,height,type)

                rastport        = PTR auf den Rastport des Fensters
                x,y,width,heigt = Ausmaße des Füllbereichs!
                type            = NG_FILL_WINDOW = Fensterhintergrund
                                  FILLGROUP1 - FILLGROUP6 = Zu füllende
                                  Gruppe, evtl. Bitmap oder Pattern-
                                  filling (jede Gruppe ein anderes
                                  Füllmuster / andere Farbe / andere
                                  Bitmap ect...)

        NG_FILL_WINDOW
                Parameter für eine Prozedur, siehe NG_FILLHOOK!

        NG_KEYFILTER
                PTR auf eine Prozedur die Key-Events filtert (z.B. um
                ein Listview eine Zeile nach oben zu bewegen, wenn eine
                Cursortaste bewegt wurde), diese Prozedur wird wie
                folgt aufgerufen:

                        keyfilter(code,raw)

                code = Tastencode (Vanilla oder Raw)
                raw  = ist TRUE, wenn code ein Rawkey ist, ist FALSE,
                       wenn der code ein Vanillakey ist

        NG_PALETTE
                PTR auf eine Prozedur die die Palette eines Screens
                lädt/setzt, sie wird wie folgt aufgerufen:

                        setpalette(screen,depth)

                screen = PTR auf den Screen welcher die Palette gesetzt
                         bekommen soll
                depth  = Tiefe des Screens in Bitplanes

        NG_PREFSPROC
                PTR auf eine Prozedur, die aufgerufen wird, wenn die
                Einstellungen gesichert werden sollen, die Prozedur wird
                für jedes Fenster erneut aufgerufen, Syntax:

                        save(screen,id,x,y,width,height,open)

                screen = PTR auf den eigenen Screen (der zum Fenster gehört)
                id     = ID des Fensters
                x,y    = Koordinaten des Fensters (linke obere Ecke)
                width  = Breite des Fensters
                height = Höhe des Fensters
                open   = Das Fenster ist geöffnet (TRUE), oder FALSE, wenn
                         es im Moment geschlossen ist

                ACHTUNG! x,y,width,height können 0 oder -1 sein, wenn das
                Fenster bis zum Zeitpunkt des Abspeicherns noch nicht offen
                war, dies sollte berücksichtigt werden, aber in jedem Fall
                ist open dann FALSE!

        NG_GETSCREEN            (Nur für ng_getattrsA())
                Holt den PTR auf den benutzten Screen vom GUI

        NG_GETGUI               (Nur für ng_getattrsA())
                Holt einen PTR auf den zur NG_GUIID gehörenden guiihandle

        NG_CHANGEWINDOW         (Nur für ng_setattrsA())
                Ändern der Window-Daten, folgende Tags sind
                erlaubt:
                        NG_WINDOWTITLE
                        NG_WINDOWLEFT
                        NG_WINDOWTOP
                        NG_WINDOWMAXWIDTH
                        NG_WINDOWMAXHEIGHT
                        NG_WINDOWWIDTH
                        NG_WINDOWHEIGHT

        NG_CHANGEMENU           (Nur für ng_setattrsA())
                Ändert das Menü zum Fenster das zu NG_GUIID gehört

        NG_CHANGEGUI            (Nur für ng_setattrsA())
                Ändern von GUI-Daten zum GUI welches zu NG_GUIID
                gehört, erlaubte Tags sind:
                        NG_OPENGUI
                        NG_CLOSEGUI
                        NG_CLOSECHILDS
                        NG_NEWGUI
                        NG_BLOCKGUI
                        NG_UNBLOCKGUI
                        NG_RESET

        NG_CHANGEGAD            (Nur für ng_setattrsA())
                Ändert Daten zu einem Gadget (dieses muß mit
                NG_GADGET angegeben werden!, dieses muß ein PTR auf
                das GUI-Element sein.

                Erlaubte Tags sind:
                        NG_GETGADGET
                        NG_DISABLE
                        NG_ENABLE
                        NG_GADGET
                        NG_NEWDATA
                        NG_SELECTED
                        NG_VISIBLE
                        NG_LABELS
                        NG_TOP
                        NG_TOTAL

        NG_CHANGETICKER         (Nur für ng_setattrsA())
                Ändern der Ticker-Prozedur (PTR) oder TRUE, wenn KEIN
                Ticker aktiv sein soll (Eigendlich sollte hier FALSE
                hin, dieses wird aber von GetTagData nicht genommen!)

        NG_OPENGUI              (Nur für ng_setattrsA())
                Nur bei MultiWindow-Support sinnvoll!
                Öffnet ein GUI, ACHTUNG, die ID des zu öffnenden Guis muß
                mit NG_GUIID übergeben werden!

        NG_CLOSEGUI             (Nur für ng_setattrsA())
                Nur bei MultiWindow-Support sinnvoll!
                Schließt das Fenster das zu NG_GUIID gehört!

        NG_CLOSECHILDS          (Nur für ng_setattrsA())
                Nur bei MultiWindow-Support sinnvoll!
                Schließt alle Unterfenster!

        NG_NEWGUI               (Nur für ng_setattrsA())
                Ändert eine Gui-Beschreibung, die neue Gui-Beschreibung
                muß mit NG_NEWDATA übergeben werden!

        NG_BLOCKGUI             (Nur für ng_setattrsA())
                Blockiert das Fenster des GUIs (NG_GUIID)

        NG_UNBLOCKGUI           (Nur für ng_setattrsA())
                Hebt die Blockierung des Fenster zu NG_GUIID wieder auf!

        NG_RESET                (Nur für ng_setattrsA())
                Führt einen NewGUI-Reset durch (alles Schließen und
                wieder öffnen (z.B. neue Preferences!), auch der
                Screen wird geschlossen!

        NG_REFRESHGUI           (Nur für ng_setattrsA())
                Führt einen Refresh (neuaufbau) bei dem angegebenen
                GUI (NG_GUIID) durch!

        NG_GADGET               (Nur für ng_setattrsA() und ng_getattrsA())
                PTR auf ein GUI-Element, das geändert werden soll z.B.

                        button:=[BUTTON,{action},'text'....]

        NG_GETGADDATA           (Nur für ng_getattrsA())
                Gibt an, daß Daten von dem Gadget geholt werden sollen,
                erlaubte Gadgets sind STR und INTEGER, andere werden
                ignoriert! Der PTR auf das Gadget muß mit NG_GADGET
                angegeben werden!

        NG_GETGADGET            (Nur für ng_getattrsA())
                Holt anhand des bei NG_GADGET angegebenen Gui-Element-PTRs
                einen PTR auf das "Richtige" Gadget in der Gadgetliste!

        NG_DISABLE              (Nur für ng_setattrsA())
                Das bei NG_GADGET angegebenen Gui-Element (Gadget/Plugin)
                wird ausgeschaltet.

        NG_ENABLE               (Nur für ng_setattrsA())
                Aktiviert das ausgeschaltete Gadget, ein PTR auf dieses
                (GUI-Element-PTR) muß mittels NG_GADGET angegeben werden!

        NG_NEWDATA              (Nur für ng_setattrsA())
                Art der Daten die geändert werden sollen, erlaubte 
                Tags sind:

                        NG_SELECTED
                        NG_VISIBLE
                        NG_LABELS
                        NG_TOP
                        NG_TOTAL

        NG_SELECTED             (Nur für ng_setattrsA())
                Ändert das Ausgewählte Element eines ListViews (LISTV)

        NG_VISIBLE              (Nur für ng_setattrsA())
                Bei einem ListView wird das Tag GTLV_MAKEVISIBLE gesetzt,
                bei einem SCROLL(er) wird dagegen der Visible-Wert
                neu gesetzt!

        NG_LABELS               (Nur für ng_setattrsA())
                Setzt bei einem LISTView die Labels neu!

        NG_TOP                  (Nur für ng_setattrsA())
                Setzt bei einem SCROLLer den TOP-Wert neu!

        NG_TOTAL                (Nur für ng_setattrsA())
                Der Totalwert des SCROLLers wird neu gesetzt!

        NG_FINDDROPBOX          (INTERN) - Nicht benutzen, diese Werte sind
        NG_MOUSEX               (INTERN) - für eine einwandfreie Funktion des
        NG_MOUSEY               (INTERN) - DND nötig und brauchen Werte die
                                           nicht EXPORTiert sind!!!!!

        NG_SHOWGUIDE            (Nur für ng_setattrsA())
                Zeigt die MAIN-Node des Hilfetextes (Guide) an

        NG_SAVEPREFS
                Ruft die Prozedur auf, welche die Einstellungen sichern soll!

        NG_HIDE
                Versteckt alles (Screen, Fenster ect...!) nur der ARexx-Port
                bleibt offen, deshalb muß guimessage() immer aktiv sein!

        NG_APPEAR
                Öffnet die mit NG_HIDE versteckte Oberfläche wieder komplett
                im alten Zustand!

        NG_APPENDGUI            -> Alte Funktion 
                Fügt manuell ein Guihandle zum Main-Handle hinzu, dieses
                Tag VORSICHTIG benutzen!

        NG_REMOVEGUI            -> Alte Funktion 
                GUI aus der Liste entfernen (ACHTUNG!!! Nur Guis entfernen
                die mit NG_APPENDGUI hinzugefügt wurden!!!)

        NG_REMOVECHILDS         -> Alte Funktion 
                Diese Funktion NICHT benutzen, wenn Multi-Window-Support
                mittels NG_NEXTGUI benutzt wird!!!!

        NG_SENDREXX             \
        NG_RX_RETURNCODE         } Bitte NG_GETRX und AFC-Rexxer benutzen!
        NG_RX_RESULT            /

        NG_DROPPROC
                PTR auf eine Prozedur welche aufgerufen wird, wenn ein
                Drop-Down im Window aber nicht auf einer speziellen
                Drop-Box war. (-> wie WB-Appwindows, nur Programmintern!)
                Diese Prozedur wird mit den folgenden Parametern aufgerufen:

                        dropproc(gui,plug)

                gui  = PTR auf das Guihandle auf welchem der Dropdown erfolgte
                plug = PTR auf das Plugin welches den Drop-Down verursachte

 3.3 Die GUI-Elemente
 ====================

        3.3.1 Grundlegendes zur GUI-Programmierung
        ------------------------------------------

        Bei NewGUI gibt es keine Fixen Koordinaten für die Elemente der
        Oberfläche (wie z.B. bei GadTools), die Definition des gesamten
        GUI`s (=Graphics User Interface) geschiet in Gruppen.
        Es gibt verschiedene Gruppenarten, z.B. eine Gruppe in der alle
        enthaltenen Elemente Untereinander angeordnet sind, oder Gruppen
        in denen der Hintergrund gefüllt wird und evtl. kann um die
        Gruppe ein Rahmen gezeichnet werden ect...
        Im Prinzip kann jede Gruppe beliebig viele Untergruppen haben,
        mann könnte sogar soweit gehen und jedem Element (z.B. Button,
        Stringgadget ect...) eine eigene Übergruppe zuweisen (z.B. vor
        jedem Gadget eine ROWS oder COLS-Gruppe definieren...) man sollte
        aber bedenken, daß es durch eine zu komplexe Oberfläche zu einem
        Stack-Überlauf (Stapelspeicher-Überlauf) kommen kann, dies sollte
        aber eher der Ausnahmefall sein, denn eine relativ Komplexe
        Oberfläche (z.B. E-DEVeloper 3.0 oder NewGUI-Creator...) hat bei
        mir und anderen BETA-Testern noch keinen Stack-Overflow verursacht!
        Die Beschreibung der Oberfläche muß in einer E-Liste (genau ge-
        nommen in mehreren E-Listen) abgelegt sein, diese Liste muß
        folgenden Aufbau haben:

        [ELEMENT/GRUPPE,evtl. Argumente oder weitere Elemente/Gruppen]

        Besondere Beachtung sollte die Klammersetzung verdienen, da hier
        oftmals Fehler entstehen können bei welchen der Compiler meckert
        (Keine Passende Gegenklammer gefunden) oder sich die Oberfläche
        nicht so verhält wie sie sollte...


        3.3.2 Die Gruppen
        -----------------

        Es gibt die Unterscheidung in AKTIVE und PASSIVE Gruppen, Aktive
        Gruppen (ROWS, EQROWS, COLS, EQCOLS) beeinflussen direkt die
        Anordnung der GUI-Elemente, wobei Passive Gruppen nur zur optischen
        verfeinerung dienen (z.B. BEVEL, DBEVEL, FILLGROUPx...).
        WICHTIG! Nach jeder Passiven Gruppe muß (!) ein Aktives Element
        (Gruppe, z.B. ROWS, COLS) folgen!
        Hier eine Auflistung der Gruppen-Elemente mit Beschreibung:

            ROWS        - (Aktive Gruppe)

                Alle Elemente (oder Untergruppen) werden Untereinander
                angeordnet.

            EQROWS      - (Aktive Gruppe)

                Wie ROWS, nur wird versucht allen Elementen (oder Gruppen)
                die enthalten sind auf die gleiche Höhe zu bringen.

            COLS        - (Aktive Gruppe)

                Gegenstück zu ROWS, alle Elemente sollen Nebeneinander
                angeordnet werden.

            EQCOLS      - (Aktive Gruppe)

                Wie COLS, nur wird versucht allen Elementen (und Gruppen) die
                gleiche Breite zu geben.

            BEVEL       - (Passive Gruppe)

                Zeichnet einen herausragenden Rahmen um die Elemente in der
                Gruppe.

            BEVELR      - (Passive Gruppe)

                Wie BEVELR, nur daß der Rahmen eingedrückt ist!\.

            FILLGROUPx  - (Passive Gruppe)

                Der Hintergrund dieser Gruppe (für "x" sind Zahlen von
                1 bis 6 erlaubt!) soll gefüllt werden, hierzu ist es noch
                nötig, eine Prozedur zum Füllen bei den Tags anzugeben,
                siehe unter NG_FILLHOOK.

            DBEVEL      - (Passive Gruppe)

                Zeichnet einen Doppelten Rahmen (herausragend) um die Elemente
                in der Gruppe.

            DBEVELR     - (Passive Gruppe)

                Wie DBEVEL, nur daß der Rahmen vertieft erscheint


        3.3.3 Die Elemente
        ------------------

        Die folgenden Elemente sind die eigendlichen Bestandteile des GUIs,
        ihnen kann man Handlungen (Prozeduren) zuweisen, welche dann bei
        der aktivierung des Gadgets aufgerufen werden.

        Zeichen-/Begrifferklärung
        - - - - - - - - - - - - -

        * = Diese Angabe ist nicht zwingend erforderlich, mittels dieser
            Angabe wird aber ein Feature angewendet (z.B. Disabling,
            Online-Hilfe...)


        proc = Prozedur (Achtung diese Angabe muß in geschweiften Klammern
               stehen {} und ein PTR auf eine Prozedur sein!)

        ...text = Text für das Element (... kann left/right oder insidetext
                  sein)

        data = Eigene Daten die der aufgerufenen Prozedur übergeben werden

        key = Shortcut für dieses Element (Diese Angabe muß in Apostophen
              gemacht werden, z.B. 'A')

        help = Name der Node in einem AmigaGUIDE-Dokument welche für dieses
               Element zuständig ist (z.B. 'Stringgadget'), auch diese Angabe
               muß in Apostrophen gemacht werden!

        disabled = Dieser Schalter (BOOL) gibt an, ob dieses Element zu
                   beginn ausgeschaltet (ghosted) sein soll, diesen Wert
                   kann man später mittels ng_setattrsA() ändern!

        list = E-Liste, welche mit NIL abgeschlossen sein muß (z.B.:
               [element1,element2,...,NIL])

        execlist = Doppelt verkettete Exec-Liste (siehe exec/lists->lh
                   und exec/nodes->ln)

        lefttext = der Text soll nicht rechts vom Gadget erscheinen sondern
                   auf der linken Seite!

        rel = relative Größe für dieses Element (mindest-Größe)

        relx = Relative Breite (mindest-Breite)

        rely = Relative Höhe (mindes-Höhe)

        str = E-String (kein normaler Text in Apostrophen erlaubt!)

        current = Eine Zahl welche Angibt welches Element einer Liste
                  gerade aktiv ist (z.B. ListView) oder wo sich ein
                  Slider/Scroller gerade zu anfang befindet!

        Elemente:
        - - - - -

        [BUTTON,action,intext,data*,key*,help*,disabled*]

          Ein "einfacher" Knopf der die Größe NICHT verändert!


        [CHECK,action,righttext,checked,lefttext,data*,key*,help*,disabled*]

          Ein Schalter (viereckiges Feld mit oder ohne Haken)

                checked = Gibt an, ob der Schalter zu beginn aktiv sein
                          soll, mögiche Werte sind nur FALSE und TRUE


        [INTEGER,action,lefttext,num,rel,data*,key*,help*,disable+*]

          Ein Eingabefeld für Zahlen (0...9).

                num = Eine Zahl oder ein PTR auf eine Variable die eine
                      Zahl enthält, diese wird dann zu Beginn in das
                      Gadget geschrieben


        [LISTV,action,text,relx,rely,execlist,readbool,selected,current,
               data*,key*,help*,disabled*]

          Ein einfaches ListView-Gadget (eine scrollbare Liste mit einem
          Scrollbalken auf der rechten Seite)

                readbool = Gibt an, ob diese List nur lesbar ist, d. h.
                           es können keine Elemente angewählt werden,
                           möglich sind hier nur FALSE und TRUE
                selected = Das ausgewählte Element soll farbig hinterlegt
                           und dauerhaft dagestellt werden

        [MX,action,righttext,list,lefttext,current,data*,key*,*help,disabled*]

          Ein mehrfach-Schalter, mehrere Elemente sind dagestellt, aber es kann
          immer nur eines aktiv sein. (MutalExclude)

        [CYCLE,action,lefttext,elist,current,data*,key*,help*,disabled*]

          Ein mehrfach-Schalter (Funktion ähnlich von MX) in einem Gadget,
          dieses Gadget sieht in etwa wie ein Drekschalter aus und läßt sich auch
          ähnlich bedienen (es dreht sich immer nach hinten!)

        [PALETTE,action,lefttext,depth,relx,rely,current,data*,key*,help*,disable*]

          Ein Farb-Auswahl-Gadget.

                depth = Anzahl an Farben die dagestellt werden, ACHTUNG hier muß
                        nur die Tiefe in Bitplanes und nicht die korrekte Farb-
                        anzahl angegeben werden (z.B. 3 Bitplanes = 8 Farben!!)

        [SCROLL,action,vert,total,top,visible,relsize,data*,key*,help*,disable*]

          Ein Scroller-Gadget (Schiebebalken)

                vert = Gibt an, ob das Gadget Vertikal gezeichnet werden soll
                       (möglich sind hier nur TRUE und FALSE)
                top = kleinster (oberster) Wert
                total = Größer (unterer) Wert
                visible = Eingestellter Wert zu beginn

        [SLIDE,action,lefttext,vert,min,max,current,rel,format,data*,key*,
             help*,disabled*]

          Ein Slider-Gadget (ähnlich dem SCROLL-Gadget), nur hat dieses Gadget
          keine Pfeiltasten zum verstellen!

                vert = Gibt an, ob das Gadget Vertikal gezeichnet werden soll
                       (möglich sind hier nur TRUE und FALSE)
                min = kleinster Wert
                max = höchster Wert
                format = Eine Formatangabe (oder NIL) für einen Text, der
                         links vom Gadget ausgegeben wird (z.B. ' \d[3]\n'
                         Für ein dezimales ausgabeformat mit 3 Stellen!)

        [STR,action,lefttext,str,max,rel,over*,data*,key*,help,*disabled]

          Ein Text-Eingabefeld (Einzeilig!) = String-Gadget

                max = Maximale Anzahl an Zeichen die eingegeben werden dürfen
                over = Wird dieser Schalter aktiviert (TRUE) wird der
                       überschreibe-Modus eingeschaltet

        [TEXT,text,lefttext,border,rel]

          Ein Text-Ausgabefeld mit oder ohne Rahmen

                border = Ist dieses Feld auf TRUE (aktiv) wird ein Rahmen um
                         den Text gezeichnet!

        [NUM,int,lefttext,border,rel]

          Ein Ausgabefeld für Zahlen mit oder ohne Rahmen

                border = Ist dieses Feld auf TRUE (aktiv) wird ein Rahmen um
                         die Zahl (int) gezeichnet!

        [SBUTTON,action,intext,data*,key*,help*,disabled*]

          Ein Knopf wie BUTTON, nur verändert sich seine Breite, sie
          passt sich dynamisch an!

        [RBUTTON,action,intext,data*,key*,help*,disabled*]

          Ein Knopf wie BUTTON, nur verändert sich seine Höhe, sie
          passt sich dynamisch an!

        [PLUGIN,action,plugin_object,*disabled]

          Ein plugin-Objekt (z.B. Scrolltext, Gauge, Color-Wheel...)
          siehe 3.4 für nähere Beschreibungen der Plugins

        [BAR]

          Zeichnet einen Trenn-Strich, welcher sich automatisch an eine
          vertikale/horizontale Position anpasst, ACHTUNG !!! Keine 
          Argumente nötig/erlaubt!

        [BARR]

          Ein Trennstrich (wie BAR), nur das dieser herausragt (wie der
          Rahmen um ein STRING-Gadget!)


 3.4 Plugin - Programmierung
 ===========================


        3.4.1 Plugin - Objekt

        x           = gibt zusammen mit y die Koordinate der linken oberen
        y           = Ecke an ab der unser Plugin erscheinen soll
        xs          = Breite des Plugins
        ys          = Höhe des Plugins
        gh          = PTR auf das dem Plugin zugehörigen guihandle
        dis         = Gibt an, ob das Plugin disabled sein soll
        type        = Art des Plugins (nur für Drag'N'Drop nötig,
                      kann sein:
                        DND_DROPBOX     - Hier können nur Daten/Elemente
                                          abgelegt werden
                        DND_DRAGBOX     - Hier können nur Daten/Elemente
                                          "aufgehoben" werden
                        DND_DRAGDROPBOX - Hier kann man Daten ablegen und
                                          aufnehmen
        dnd_dest    = Nach einem erfolgten DROP steht hier (in dem Plugin
                      wo das Element aufgehoben wurde (DRAGBOX)) die Adresse
                      (PTR) des Destination (Ziel-) Plugins
        dnd_info    = Gibt an, welche zum Drag'N'Drop erforderlichen Daten
                      vorhanden sind, folgende Werte sind erlaubt:
                        DND_INFO_IMAGE  - Es ist ein Image vorhanden
                        DND_INFO_TEXT   - Es ist ein String/Text vorhanden
                      Diese beiden Elemente können auch miteinander kombiniert
                      werden/sein!
        dnd_text    = PTR auf einen Text (oder String) der zum Drag verwendet
                      werden soll. ACHTUNG! dnd_image hat vorrang!
        dnd_textlen = Länge des Textes (dnd_text) muß ausgefüllt werden!
        dnd_image   = PTR auf ein Image das zur darstellung benutzt werden 
                      soll, ist ein String und ein Image gegeben, wird nur
                      das Image genommen.
        dnd_selectimage = PTR auf das Image für den Drag und für die Auswahl
        dnd_data    = Eigene Daten (entweder eine Zahl ect... oder ein
                      PTR auf ein Objekt)

        3.4.2 after_reply()

        SYNTAX: after_reply()

        Diese Prozedur wird aufgerufen, nachdem eine ankommende Message
        wieder an Intuition zurückgeschickt wurde.
        Diese Prozedur vorsichtig benutzen, da sie auch aufgerufen wird,
        wenn die Message nicht für unser Plugin war, deshalb sollte man
        sich in message_test() "merken" (z.B. mittels einer Variable im
        Objekt) ob die Message für uns war.
        Man sollte in jedem Fall die Prozedur message_action() bevorzugen,
        nur ist dies nicht immer zu bewerkstelligen (siehe z.B. scrolltext-
        Plugin!)
        ACHTUNG! Keine Über- ode Rückgabeparameter

        3.4.3 clear_render()

        SYNTAX: clear_render(win)

        Der von uns benutzte Raum soll gelöscht werden (z.B. RectFill()),
        oder ein BOOPSI-Gadget kann hier entfernt werden, diese Prozedur
        wird vor jedem render() oder gtrender() aufgerufen.

        Parameter: win = PTR auf unser benutztes Fenster

        3.4.4 render()

        SYNTAX: render(ta,x,y,xs,ys,win)

        Das eigendliche "Herz" des Plugins, hier soll unser Plugin seine
        Ausgaben machen (z.B. Draw() ect...), hier kann aber auch ein
        BOOPSI-Gadget angehängt werden.

        Parameter: ta = Textattr (rastport/text), wird z.B. zum ermitteln
                        der Länge eines Textes benötigt.
                   x,y = Koordinaten der Linken oberen Ecke des Bereiches
                         in dem wir zeichnen dürfen
                   xs = Breite des Bereiches
                   ys = Höhe des bereiches
                   win = PTR auf unser benutztes Fenster (z.B. um den PTR
                         auf den rastport zu ermitteln...)

        3.4.5 gtrender()

        SYNTAX: gl=gtrender(gl,vis,ta,x,y,xs,ys,win)

        Spezialle Renderfunktion für Plugins die Gadtools-Gadgets verwenden!
        Soll diese Funktion verwendet werden, muß isgtgadget() (3.4.8) = 
        TRUE sein!

        Parameter: gl = PTR auf die Gadget-Liste unseres Fensters
                   vis = Visual-Info des Screens
                   ta = Textattr (rastport/text), wird z.B. zum ermitteln
                        der Länge eines Textes benötigt.
                   x,y = Koordinaten der Linken oberen Ecke des Bereiches
                         in dem wir zeichnen dürfen
                   xs = Breite des Bereiches
                   ys = Höhe des bereiches
                   win = PTR auf unser benutztes Fenster (z.B. um den PTR
                         auf den rastport zu ermitteln...)

        Rückgabe: gl = PTR auf die aktuelle Gadgetliste (! WICHTIG !)

        3.4.6 will_resize()

        SYNTAX: ret=will_resize()

        Gibt an, ob unser Plugin in der Lage ist sich dynamisch an Größen-
        veränerungen anzupassen (resizing).

        Rückgabe: ret = Kann sein:
                        RESIZEX = unsere Breite kann sich anpassen
                        RESIZEY = unsere Höhe kann sich anpassen
                        RESIZEXANDY = Unsere gesamte Größe ist Variabel!

        3.4.7 min_size()

        SYNTAX: x,y=min_size(ta,fh)

        Die Mindestgröße die unser Plugin braucht muß (!) hier zurückge-
        geben werden

        Parameter: ta = Textattr (rastport/text), wird z.B. zum ermitteln
                        der Länge eines Textes benötigt (-> Mindestbreite)
                   fh = Höhe des Fonts (Zeichensatzes) unseres Fensters
                        (z.B. zur Berechnung der Mindsthöhe)

        Rückgabe: x = Mindestbreite (in Pixeln) für unser Plugin
                  y = Mindesthöhe (in Pixeln) für unser Plugin

        3.4.8 isgtgadget()

        SYNTAX: ret=isgtgadget()

        Diese Prozedur hat (üblicherweise) keine große Funktion, sie muß
        nur zurückgeben, ob GadTools-Gadgets verwendet werden, in diesem
        Fall muß TRUE zurückgegeben werden, ansonsten FALSE.
        Wenn TRUE zurückgegeben wird, wird die Prozedur gtrender() an-
        statt render() benutzt!

        Rückgabe: ret = Soll die Prozedur gtrender() anstatt von render()
                        benutzt werden

        3.4.9 disable()

        SYNTAX: disable(disabled)

        Ein Plugin sollte mittels dieser Prozedur disabled/enabled
        werden. Ist der Parameter disabled = TRUE, muß (!) das
        Feld >self.dis< auf TRUE gesetzt werden, ansonsten auf
        FALSE.

        Parameter: disabled = TRUE wenn unser Plugin disabled werden
                              soll oder FALSE wenn es enabled werden soll!

        3.4.A message_test()

        SYNTAX: ret=message_test(imsg,win)

        Diese Prozedur muß prüfen, ob eine Message für unser Plugin ist, sie
        sollte so kurz und schnell wie möglich sein!
        Hier sollten keine Ausgaben gemacht werden, dazu sollte after_reply()
        (3.4.2) oder noch besser: message_action() (3.4.B) verwendet werden!
        Soll das Drag'N'Drop-Feature verwendet werden, muß die Prozedur 
        self.handlednd(imsg) aufgerufen werden (siehe 3.4.C)

        Parameter: imsg = Intuimessage (ACHTUNG hier darf NICHTS geändert
                          werden, evtl. Kopie andertigen!)
                          um z.B. die Art der Message (IDCMP_xxx) zu
                          ermitteln, diese Message darf auch nicht Replyed
                          werden, dies erledigt NewGUI automatisch!
                   win = PTR auf unser Fenster

        Rückgabe: ret = Gibt an, ob die Message für uns ist, möglich sind:
                        TRUE, wenn die Message für uns war, oder FALS, wenn
                        sie es eben nicht war...

        3.4.B message_action()

        SYNTAX: ret=message_action(class,qualifier,code,win)

        Hier kann noch eine Ausgabe ect... getätigt werden, außerdem soll hier
        entschieden werden, ob die Funktion (action) des Plugins aufgerufen
        werden soll.
        Wenn die Drag'N'Drop-Features genutzt werden sollen, muß hier noch
        die Prozedur: self.dnd_xchange() (3.4.E) aufgerufen werden!

        Parameter: class = Kopie von intuimessage.class
                   qualifier = Kopie von intuimessage.qualifier
                   code = Kopie von intuimessage.code
                   win = PTR auf unser eigenes Fenster

        Rückgabe: ret = Gibt an, ob die aktions-Prozedur (action) unseres
                        Plugins ausgeführt werden soll, möglich ist hier
                        TRUE, wenn sie ausgeführt werden soll, oder FALSE
                        wenn sie nicht ausgeführt werden soll.

        3.4.C handlednd()

        SYNTAX: ret=handlednd(imsg)

        Diese Prozedur wird von message_test() aufgerufen (siehe 3.4.A) und
        prüft, ob ein Drop stattgefunden hat, außerdem kümmert sich diese
        Prozedur um die ganzen Drag'N'Drop-Technischen Verwaltungen (z.B.
        Prüfen, ob überhaupt ein Drag stattgefunden hat ect...)

        Parameter: imsg = intuimessage
        Rückgabe: ret = ist TRUE, wenn ein Drop stattgefunden hat oder
                         FALSE, wenn kein Drop (auf einer Dropbox) statt-
                         gefunden hat!

        3.4.D performdnd()

        SYNTAX: x,y=performdnd(win)

        Diese Prozedur kümmert sich um das Handling währen eines Drag'N'Drop-
        Vorganges (Verschieben des Images/Textes ect...).
        Eine Prozedur die die grundlegenden Sachen des Drag'N'Drop`s erledigt
        ist (samt Source) in dem Modul "ng_performdnd" gespeichert, diese
        sollte ggf. den eigenen Bedürfnissen angepasst werden und dann hier
        eingebunden werden (siehe Beispielsources zum Drag'N'Drop-Plugin)

        Parameter: win = PTR auf unser eigenes Window
        Rückgabe: x,y = Letzte Mausposition beim Drop (loslassen der
                        linken Maustaste!)

        3.4.E dnd_xchange()

        SYNTAX: ret=dnd_xchange(plug,called)

        Diese Prozedur soll den Datenaustausch zwischen der Drag- und der Drop-
        box erledigen, eine Beispiellösung (samt Source) liegt bei, siehe
        ng_dnd_xchange, sie wird von message_action() (3.4.B) aufgerufen.

        Parameter: plug = PTR auf das Plugin (siehe ng_dnd_xchange())
                   called = muß auf TRUE gesetzt werden, wenn diese
                            Prozedur von einer anderen dnd_xchange()-Prozedur
                            aufgerufen wurde (siehe ng_dnd_xchange())

 3.6 Das Modulare Konzept von NewGUI
 ===================================

Seit der Version 3.1 ist NewGUI vollkommen Modular aufgebaut, es ist daher
leicht möglich eigenen Code in NewGUI einzubinden, einerseits durch die
erweiterte Plugin-Schnittstelle mit Drag'N'Drop-Support als auch durch
die vielen externen Prozeduren (z.B. ng_fillhook, oder ng_dnd_xchange...)
die sich leicht durch eigene ersetzen lassen.
NewGUI ist durch die erweiterte Plugin-Schnittstelle auch in der Lage
BOOPSI, GadTools oder eigene Gadgets einzubinden, es sind nun auch aktionen
möglich die an der unflexibilität der "alten" Schnittstelle gescheitert sind
(z.B. ScrollRaster()-Aufrufe ect...!).


 3.6 Fehler-Codes
 ================

    ERR_NG_MENU
        Das GadTools-Menü konnte nicht angelegt oder an das Fenster ange-
        hängt werden.

    ERR_NG_BIG
        Das GUI ist trotz Fallback auf topaz/8 (ROM-Font) zu groß für 
        diesen Screen, entweder wurde ein völlig abartiger Screenmode
        benutzt (z.B. 256/128) oder es liegt ein Design-Fehler vor.

    ERR_NG_VISUAL
        Das VisualInfo des Arbeitsscreens (eigener, Workbench oder das
        Info eines Pubscreens) konnte nicht geholt werden, evtl. ist der
        Screen nicht offen.

    ERR_NG_WINOPEN
        Das Fenster konnte nicht geöffnet werden (evtl. Speichermangel?!)

    ERR_NG_LIB
        Eine benötigte Library konnte nicht geöffnet werden (z.B. die
        gadtools.library, utility.library, amigaguide.library...)

    ERR_NG_SCREEN
        Der angegebene Screen ist nicht zu öffen (eigener) oder zu
        bekommen (Pubscreen/Workbench)

    ERR_NG_MSGPORT
        Der Messageport konnte nicht angelegt werden, evtl. Speichermangel
        oder keine Signal-Bits mehr frei!

    ERR_NG_CONTEXT
        Das Context konnte von GadTools nicht angelegt werden, evtl.
        Speichermangel

    ERR_NG_GUI
        Fehler in der Gui-Beschreibung vorhanden, das GUI kann nicht
        an das Fenster gehängt werden.

    ERR_NG_SYNTAX
        Es liegt ein Syntax-Fehler in de GUI-Beschreibung vor, evtl.
        ist ein Elemtent NIL oder hat unpassende Werte (z.B.
        Wurde eine Zahl für ein ELEMENT verwendet die es nicht
        gibt...)

    ERR_NG_FEWARGS
        Ein GUI-Element hat nicht alle Argumente die benötigt werden.

    ERR_NG_PLUGIN
        Das angegebene Plugin ist NIL (evtl. Speichermangel oder
        Fehler in der Übergabe des Plugin-PTRs oder aber Fehler beim
        erzeugen des Plugins INTERN!)

    ERR_NG_CREATEGAD
        Ein Element konnte von GadTools nicht erzeugt werden (evtl.
        Speichermangel oder Designfehler!)

    ERR_NG_END
        Internes Element, kommt nicht vor, kann aber dazu benutzt
        werden um seine Eigenen Fehlercodes anzupassen (doppelt
        belegung eines Fehlercodes zu vermeiden, ähnlich der
        Konstante TAG_USER der utility.library!)

 4. Copyright
-============-

NewGUI ist rechtlich geschützt von THE DARK FRONTIER Softwareentwicklungen.
Die Entwicklung (1994-1998) und verbreitung dieses Produktes wird strengstens
Kontrolliert und überwacht, trotzdem können Fehler nicht ausgeschlossen
werden, falls Sie einen solchen Fehler entdecken sollten, melden Sie diesen
bitte an die bei (5) genannte Adresse oder senden sie per EMail einen
Bug-Report, wir werden den Fehler so schnell wie möglich beseitigen.

NewGUI ist MailWare, d.h. es wird KEINE Nutzungsgebühr verlangt, doch der
Programmierer der es benutzt ist verpflichtet eine Mail (oder Postkarte)
an die bei (5) genannte Adresse zu senden. TDF verpflichtet sich hiermit
die Persönlichen Daten streng vertraulich zu behandeln und diese (falls
gewünscht) nach einer bestimmten Zeit wieder zu löschen.

Falls gewünscht, kann ein so registrierter Programmierer gebrauch vom
Update-Service machen, welcher die Programmierer über neue Versionen
unterrichtet (diese werden dann im AmiNet und auf der Homepage ver-
öffentlicht). Registrierte Programmierer haben auch zugang zu BETA-
Versionen von NewGUI.


 5. Über
-=======-

NewGUI wurde programmiert von:

                THE DARK FRONTIER Softwareentwicklungen
                Grundler Mathias
                Am Hofgraben 2
                67378 Zeiskam

                Deutschland


Fax  : ++49(0)7274-8774
EMail: frontier@starbase.inka.de  (Fragen zu TDF-Produkten)
       bugreport@starbase.inka.de (Fehler-Meldungen)
       grundler@starbase.inka.de  (Persönliches)
       register@starbase.inka.de  (Für Registrier-E-Mails...)
WWW  : Im Aufbau...
