[some major v2.5 extra language features]

DEFAULT ARGUMENTS

default arguments allows you to specify for one or more
arguments of a procedure which is the default value, if the
procedure is called with less args than parameters. for example,
a procedure like:

PROC bla(a,b=1,c=NIL)

can be called like:			is equivalent with:

bla(a,b,c)				bla(a,b,c)
bla(a,b)				bla(a,b,NIL)
bla(a)					bla(a,1,NIL)

This can be usefull and also express something about the
procedures function, i.e. that most of the time one would
call it with NIL anyway, so why not leave it out for clarity.
That's also why you should not overdo it with D.A.: do not
start specifying non-sensicall values for procedures
out of pure laziness, if you feel a certain parameter really
has no default value.

to make calls with fewer args unambiguous, D.A. declarations
can only apply to the last 0..n parameters of a PROC of n parameters.

for example, illegal is:  PROC bla(a,b=1,c)

(you should then simply reorder the parameters, of course).
arguments supplied in a call are filled in from left to right,
missing arguments are added with D.A.'s as needed.



MULTIPLE RETURN VALUES

introduction:
were you always irritated when designing a nice function in any
programming language, and you wanted to return two values, and
you just couldn't? you would end up doing the second return value
by reference, or via a global variable, but that's ugly. E
programmers always have been blessed because they could use
exceptions to return errors which don't occupy that precious 1
return value, and also because they could do things like RETURN [a,b].

In E you can simply return any number of return values! (max 3 in
Amiga E because of implementation reasons). How?

RETURN <exp>,<exp>,<exp>                 (or ENDPROC, of course)

example:

PROC sincos(rad)
  DEF sin:REAL,cos:REAL
  /* whatever computation is needed */
ENDPROC sin,cos

call with:

s,c:=sincos(3.14)
s:=sincos(1.00)

as you can see, there's a new statement of the form:

<var> , ... := <exp>

where <exp> makes mostly only sense as function call.
note two things:
- you can decide yourself howmany values you wish to receive.
  this makes sense when the first retval is the main one,
  and the second/third optional infos, which might only be
  important to some callers.
- this form is a _statement_. this means that when you would
  call sincos() as part of another expression, only the
  first (the regular) return value is used:   fun(sincos(1.0))



THE "NEW" OPERATOR

the NEW operator is a powerful operator for dynamic memory allocation.
it has various forms:

(assuming DEF p:PTR TO whateverobj, q:PTR TO INT)

NEW p

is an expression that will allocate zero-ised memory for the object-size
p points to. the resulting pointer will be put in p, and is also
the value of the expression. if NEW fails to get memory, it raises
a "NEW" exception. 'NEW p' is therefore roughly equivalent with:

IF (p:=New(SIZEOF whateverobj))=NIL THEN Raise("MEM")

with the difference that p never gets any value if an exception
is raised, and that the former is ofcourse an expression, not
a statement

but there's more: one can also allocate an array dynamically:

NEW p[10]       /* array of 10 objects */

NEW q[a+1]      /* array of INT, size is runtime computed */

And it gets better. Most E programmers know pretty well the power
of lists [] and their typed equivalents. however the big problem
in using these to build large datastructures which need to be
created at run-time is that these are static. However E now
has the dynamic equivalent to static lists:

p:=[1,2,3]:whateverobj           /* static structure */

p:=NEW [1,2,3]:whateverobj       /* dynamicly allocated! */

this works with both lists and typed-lists, and also with arrays:

NEW [1,2,3]        /* constant-list, dyn. (note: not a like a listvar!) */
NEW [1,2,3]:obj    /* object */
NEW [1,2,3]:INT    /* array of INTs */

freeing memory allocated with any variations of NEW is done
automatically at the end of the program, or by hand with Dispose(p)
(note: the only exception is NEW <list>, use <another_function>)


OBJECT INHERITANCE

were you always annoyed that you couldn't express dependencies
between OBJECTs, or reuse code that works on a particular OBJECT
with a bigger OBJECT that encapsulates the other one? with
Object Inheritance you can do that in E. when you have
an object a:

OBJECT a
  next, index, term
ENDOBJECT

you can make a new object b that has the same properties
as a (and is compatible with code for a):

OBJECT b OF a
  bla, x, burp
ENDOBJECT

is equivalent to:

OBJECT b
  next, index, term         /* from a */
  bla, x, burp
ENDOBJECT

with DEF p:b, you can directly not only access p.bla as usual,
but also p.next.

as an example, if one would have a module with an OBJECT to
implement a certain datatype (for example a doubly-linked-list),
and PROCs to support it, one could simply inherit from it, adding
own data to the object, and use the existing functions.


OWN MODULES

with v2.5, you can gather all PROCs, CONSTs, OBJECTs and to
some extend also global variables that you feel somehow belong
together in one source, write "OPT MODULE" to signal EC that
this is supposed to be a module, and then compile all to a
.m file to be used in the main program, just like you used to
do with the old modules.

by default, all elements in a module are PRIVATE, i.e. not accessable
to the code that imports the .m file. to show which elememts
you wish to be visible in the module, simply write EXPORT
before it:

EXPORT ENUM TESTING,ONE,TWO,THREE,FOUR

EXPORT DEF important_glob_var, bla:PTR TO x

EXPORT OBJECT x
  next, index, term
ENDOBJECT

EXPORT PROC burp()
  /* whatever */
ENDPROC

"EXPORT" is usefull in making a distinction between private and
public, especially when all functions of an OBJECT can be accessed
via PROCs, you may wish to keep to OBJECT private as an effective
method of data hiding.

If in a module _all_ elememts need to be exported (for example
one with only constants), a 'OPT EXPORT' will export all, without
the need for individual EXPORT keywords.

global variables require extra attention:
- try to avoid lots of global variables. having lotsa globs
  in modules makes projects messy and error-prone
- globs in a module cannot have initialisations directly
  in the DEF statement (reason for this will become clear
  below). for example:
  DEF a             not     DEF a=1
  DEF a:PTR TO x    not     DEF a[10]:ARRAY OF x
- globals in a module which are not exported function as
  local for the module, i.e. they'll never clash with globs
  in other modules. those who _are_ exported though, are
  combined with the others, i.e. if in both the main program
  and in a module a variable with the same name are used,
  this will be one and the same variable. that's why
  one can write DEF a[10]:ARRAY OF x in the main program,
  and EXPORT DEF a:PTR TO x in the module, to share the
  array. Also, if both use for example 'gadtools.m',
  only one of the two needs to initialise 'gadtoolsbase'
  for both to be able to make calls to the library.
  If you export a variable in a general purpose
  module, make sure to give it a pretty unique name.



SELECT OF

next to the old SELECT <var> which works on expressions
in the CASE statements, E has a SELECT <maxrange> OF <exp>
which works with constants and or ranges of constants
in a CASE. not only is this for many applications more
powerfull, it is also much faster. It assumes however,
that all CASEs lie within a small integer range from 0 TO n,
for example 0 TO 9, or 0 TO 255 for characters.

example:

SELECT 127 OF Fgetc(stream)
  CASE "\n","\b"
    WriteF('line ending\n')
  CASE "\t"," "
    WriteF('whitepace\n')
  CASE "0" TO "9"
    WriteF('Integer\n')
  CASE "A" TO "Z", "a" TO "z", "_"
    WriteF('Identifier\n')
  DEFAULT
    WriteF('some other character\n')
ENDSELECT

DEFAULT will be hit not only for those for which there is no CASE,
but also for the chars that fall out of the range, i.e. 128 TO 255
(and >255, and <0).
note that speed costs: because this SELECT uses a jump-table
to quickly get at the right CASE, it'll use 2*<maxrange> bytes,
256 in this case.
