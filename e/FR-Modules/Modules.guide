@database Modules
@remark $VER: Modules.guide (13.5.99) © FAR
@node main "Modules Guide"
Short:    FASTEST FGets() replacement, quick sort, hex view, ansi2text, SetFunction() modules
Uploader: fredinou@bigfoot.com (FAR)
Author:   fredinou@bigfoot.com (FAR)
Type:     dev/e
Requires: kickstart 2.0+

Here are some modules I made 2 years ago for my own programs.

summary
~~~~~~~
@{"FGets() AmigaDOS replacement" link readline} (about 5 times faster)
@{"Quick sort" link insertinorder} (for sorting arrays and make fast sort programs)
@{"Hex view" link hex} (to view better binary files)
@{"Ansi to text" link ansi} (removes escape sequences)
@{"SetFunction() AmigaDOS replacement" link setf} (SetFunction object)
@{"CON window size" link nblineswin} (How many lines of text it may contain)
@{"strtok() equivalent" link readtoken} (like the C function)
@{"Me" link me}
@{"It's freeware" link legal}
@{"Quit" quit}
@endnode

@node readline "readline()"
Synopsis:

Replaces the AmigaDOS FGets() function.
About 5 times faster.
About 30 times faster than the ReadStr E function.

readline(object)
readlinefrom(filehandle)
endrealine(object)

You don't need to know what object is. It's a pointer to something and
is just used for the endreadline() function.
You get the line read with ^o.

Example :

  DEF fh,o,buf[256]:STRING,i
  IF fh:=Open('xpke.e',OLDFILE)
    o:=readlinefrom(fh)
    WHILE readline(o)
      printF("\s\n", ^o)
    ENDWHILE
    endreadline(o)
    Close(fh)
  ENDIF
@endnode

@node insertinorder "insertinorder()"
Synopsis:

Insert an element in a sorted array using quick sort algorithm.

insertinorder(arrayptr,len,element,comparisonfunction,userdata)

arrayptr : pointer to an array
           the array may be empty but allocated.
len : length of the array
element : pointer to the element to insert in the array
comparisonfunction : pointer to your function of comparison
userdata : parameters of the comparison function

comparison function :
cmpfunction(element, newelement, userdata : PTR TO LONG)

return TRUE if element and newelement are comparable.
newelement is the element to insert which you compare with an ordinary
element of your array.
@endnode

@node hex "hex()"
Synopsis:

Display a binary string in hex view form.

hex(estring,binstring,len)

estring : returned hex view string
binstring : binary data in memory
len : length of binary data

Example of view:

464F524D 00000046 50524546 50524844    FORM...FPREFPRHD
00000006 00000000 0000494E 50540000    ..........INPT..
002C6600 61310000 00000000 00000000    .,f.a1..........
00000001 00000001 0007A120 00000000    ..........¡ ....
@endnode

@node ansi "noansi()"
Synopsis:

Removes the escape sequences from string.

noansi(string)

Example:
Strcopy(str, "\e[33mtext\e[31m")
noansi(str)
PrintF(str)

Output:
text
@endnode

@node nblineswin "nblineswin()"
Synopsis:

Returns the number of lines of text displayable on the window.

nblineswin(PTR TO window)

@endnode

@node setf "setf()"
Synopsis:

SetFunction() object in E.

setf(libbase,offset,newfunc)

Constructor.
libbase : pointer to library
offset : offset of the function to patch (See asm includes).
newfunc : pointer to the new function for replacement.

enabled()

Returns TRUE is patch is enabled.

disable()

Disables the patch.

enable()

Reenables the patch.

patched()

Returns TRUE is the function has been patched by another process.

end()

Destructor.

oldfunc()

Returns the pointer to the old function.

Example:
#define OFFSET -30 (Open)
#define BASE dosbase

MODULE 'tools/geta4'

PROC main()
  NEW setf.setf(BASE,OFFSET,{new})
  storea4()
  WHILE CtrlC()<>TRUE DO Delay(10)
  IF setf.attemptend()=FALSE THEN WriteF('Someone patched your function\n')
  WHILE setf.attemptend()=FALSE DO Delay(10)
  END setf
ENDPROC

PROC new()
  DEF name,mode,fh
  MOVE.L D1,name
  MOVE.L D2,mode
  geta4()
  WriteF('\s opened with mode \s\n',name,IF mode=NEWFILE THEN 'NEWFILE' ELSE 'OLDFILE')  MOVE.L name,D1
  MOVE.L mode,D2
  fh:=setf.oldfunc()
  WriteF('fh: \d\n',fh)
ENDPROC fh
@endnode

@node readtoken "readtoken()"
Synopsis:

strtok() equivalent.

readtokenfrom(string,separators=NIL,oneonly=FALSE)

constructor

string : a string
separators : a string of separators
oneonly : treat subsequent separators as one separator

readtoken(o)

return the next token

endreadtoken(o)

destructor

nbtoken(o)

returns the number of tokens in the string

Example:

DEF o

o := readtokenfrom("token1;token2;token3.token4", ".;")
WHILE readtoken(o)
  PrintF("%s\n", ^o)
ENDWHILE
endreadtoken(o)
@endnode

@node me "Talking about me ..."
There was 2 years I made these proggies and never take the time to spread
it. So here it is for your convenience. Hope you will use it.

You may reach me by email if u want.

fredinou@bigfoot.com
@endnode

@node legal "Legal stuff"
These modules and source are freeware. Do whatever you want with it.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
@endnode

