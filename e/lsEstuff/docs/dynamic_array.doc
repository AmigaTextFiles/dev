dynamic_array.m by Leif Salomonsson '99

/* this module contains 1464 bytes of code! */

/* ... and 41 reloc entries */

(----) OBJECT dynamic_array
         dynamic_array(a,b)
           /* the constructor. a = valuetype (DAVS_CHAR/DAVS_INT/DAVS_LONG)    */
           /*                  b = nr of values to put in one chunk of memory, */
           /*                  gets mul'ed with 4. 8-1024 should be good values   */

         end()
           /* destructor */

         set(a,b)
           /* set element. a = x, b = value */

         unset(a)
            /* unset element. sets it to NIL and frees its memory (if possible*)
            /* gets slower the bigger allocvalue ! */

         get(a)
            /* get element. a = x  */
            /* not already set element will return NIL ! */

         count()
            /* counts elements with value different from NIL ! */

         clear()
           /* free/unset all elements and the memory they use */
(----) ENDOBJECT     /* SIZEOF=14 */

CONST DAVS_INT=2,
      DAVS_LONG=4,
      DAVS_CHAR=1

/*
  code from module "xl.m" used:
  OBJECT xli [1 acc]
*/

simple testproggy
sets 50 000 elements[0-49999] to values 0-49999
results with A1200 1230/50 :

>test

dynamic ARRAY OF INT, allocval=256 (1024 bytes)
 13:59:53
getting 50 000 empty points
 13:59:54
setting 50 000 points
 13:59:57
counting points : 49999 -> the first point was set to NIL, so theres no error :)*
 13:59:58
setting the same 50 000 points again
 14:00:01
getting 50 000 points
 14:00:04
memory available now : 1976888
 14:00:04
unsetting 50 000 points
 14:00:19
memory available now : 2077672
counting values (should be 0) : 0
finnished!

