@database "Alls Guides"
@author   "NasGûl"
@(c)      "Copyright © 1994 NasGûl, Inc."
@$VER:	  Alls Guides v1.0 (24-03-94)
@font	  topaz.font 8

@node main "All Guides Documentation"

	Sorry,all docs are in french. (i speak/write a very badly english).

    AUX ASSOCIATIONS:
    -----------------
    ces programmes sont _*FREEWARE*_,c'est a dire qu'ils peuvent
    être distibués librement par n'importe qui.La seule restriction
    est que le prix demandé ne dépasse pas le prix du support et de
    l'envoi.
	@{b}Il est strictement @{fg highlight}INTERDIT@{fg text} de faire de l'argent avec
    ces programmes.@{ub}

    AUX PARTICULIERS:
    -----------------
    Le particulier se doit @{fg highlight}DONNER@{fg text} ces programmes.

	Je ne serais auncunement résponsable des dégats que peuvent faire
    ces programmes.


    @{"CDPS       " link "CDPS Documentation"} @{"3DView     " link "3DView Documentation"} @{"ClickRun   " link "ClickRun Documentation"}
    @{"DirW       " link "DirW Documentation"} @{"EUtils     " link "EUtils Documentation"} @{"Gui_CliConv" link "Gui_CliConv Documentation"}
    @{"Jpeg&Ilbm24" link "Jpeg&Ilbm24 Documentation"} @{"MappIc     " link "MappIc Documentation"} @{"MemFree    " link "MemFree Documentation"}
    @{"NasScreen  " link "NasScreen Documentation"} @{"Recall     " link "Recall Documentation"} @{"SelectS    " link "SelectS Documentation"}
    @{"Smodule    " link "Smodule Documentation"} @{"TM_AutoDock" link "TM_AutoDock Documentation"} @{"VText      " link "Vtext Documentation"}
    @{"ViewIlbm   " link "ViewIlbm Documentation"} @{"WhatView   " link "Whatview Documentation"}

    Merci a tous les programmeurs qui fournissent leurs sources (Pardon aux oubliés).

    Nico François pour l'incontournable ReqTools.library (et tous le reste).
    Sylvain Rougier et Pierre Carrette pour la WhatIs.library .
    Stefan Becker pour ToolManager et la toolManager.library.
    Jaba Develoment pour GadToolsBox.
    Opal Technology pour l'Opal.library.
    Christian A. Weber pour l'iff.library.
    Dietmar Eilert pour GoldED.
    Barry Wills pour Epp.

    Wouter Van Oortmerssen (alias $#%!) pour son Amiga_E .

    Commodore pour son Amiga.@{ub}

    Contact :

    @{b}NasGûl@{ub}

    Capus André.
    74 Rue jules Guesde.
    92240 MALAKOFF.
    FRANCE.
    Tél:46.44.35.28

@endnode
@node "CDPS Documentation"

    Change l'écran public par défaut.Si aucun paramètre n'est donné
    ce sera de nouveau le WorkBench par défaut.

@endnode
@node "3DView Documentation"

    @{"Description   " link "Description 3Dview"}
    @{"Equipements   " link "Equipements 3Dview"}
    @{"Installation  " link "Installation 3Dview"}
    @{"Fonctionnement" link "Fonctionnement 3Dview"}

@endnode
@node "Description 3Dview"

	3Dview est un "viewer" d'objets en 3 dimensions.

	Les format d'objets reconnus sont les suivants:

    -	Cyber Studio v1.0 (ATARI)
	-------------------------
	plusieurs objets dans le même fichier possible.
	Toutes les faces géneré par Cyber Studio sont dans le bon sens.

    -	Cyber Studio v2.0 (ATARI)
	-------------------------
	plusieurs objets dans le même fichier possible.
	Toutes les faces géneré par Cyber Studio sont dans le bon sens.

    -	Imagine (AMIGA)
	---------------
	plusieurs objets dans le même fichier impossible,la base de donnée
	n'auras qu'un seul objet.

    -	3Dpro v1.10 Final (AMIGA)
	-------------------------
	les fichiers objets généré par 3Dpro ne contiennent q'un objet (pas de restrictions).
	Toutes les faces géneré par 3Dpro sont dans le bon sens.
	Toutes les faces ayant plus de 3 points sont converties en plusieurs faces a 3 points.

    -	Vertex < v1.62a et Vertex > v1.73.1f (AMIGA)
	--------------------------------------------
	plusieurs objets dans le même fichier impossible,la base de donnée
	n'auras qu'un seul objet.

    -	Sculpt v2.09 (AMIGA)
	--------------------
	plusieurs objets dans le même fichier impossible,la base de donnée
	n'auras qu'un seul objet.

	MILLE EXCUSES au posseseurs de LightWave (n'as pas trouvé le monsieur....).

	3Dview peut aussi sauver les objects selectionnés dans les format suivants:

    -	VideoScape (AMIGA)
	------------------
    -	DXF (PC Beurk...)
	-----------------
	    Les objets au format .DXF sont construit avec la fonction 3DFACE d'AUTOCAD,il y a peut
	être un autre moyen car comme lenteur on ne fait pas mieux,un petit exemple juste pour rire.

	PC 486+Copro DX 50 Mhz 4 Mo Ram+AutoCad v11+Objet 5000 points 8000 faces = 20 minutes de rafraichissement.
	ATARI STE 68000 8 Mhz 2 Mo Ram+Cyber v2.0+Objet 5000 points 8000 faces = entre 2 à 4 minutes.

@endnode
@node "Equipements 3Dview"

    OS 2.XX.
    ReqTools.Library	v38. ou +

    3Dview a été crée et testé sur:

    A4000 68EC30+68882 KS 39.106 WB 39.29

@endnode
@node "Installation 3Dview"

    Copier la reqtools.library dans le dossier libs:.
    Copier 3Dview ou vous voulez.

@endnode
@node "Fonctionnement 3Dview"

    EN CLI:
    -------

	> 3Dview <fichier> DID <displayid> BLACK.

	avec:

	<fichier>	   - Le fichier source.
	DID <displayid>    - Le format de l'écran de 3Dview.
			     avec:
				<displayid>	- BR/BRE/HR/HRE/SHR/SHRE.
						  BR   = 320*256
						  BRE  = 320*512
						  HR   = 640*256
						  HRE  = 640*512
						  SHR  = 1280*256
						  SHRE = 1280*512

	BLACK		   - Si ce paramètre est présent l'écran sera noir,le dessin blanc.

    L'écran (quelque soit son type) a 4 couleurs (depth=2).


    EN WB:
    ------
	ToolTypes
		    DID=idem cli (BR/BRE/HR/HRE/SHR/SHRE).
		    PALETTE=BLACK     - Si ce tooltype est présent l'écran sera noir,le dessin blanc.


    Une fois les objets chargés les touches suivantes sont actives:

    HELP      - Montre un résumé des commandes (ce texte en plus court).

    Touches du pavé numérique (bonjour a tous les 600...):
    -----------------------------------------------------
    NUMPAD 1  - Vue en XOY.
		Les objets sont montrés en perspective orthographique suivant le plan XOY.
    NUMPAD 2  - Vue en XOZ.
		Les objets sont montrés en perspective orthographique suivant le plan XOZ.
    NUMPAD 3  - Vue en YOZ.
		Les objets sont montrés en perspective orthographique suivant le plan YOZ.
    NUMPAD 4  - Inverse les coordonnées en X.
		permet d'avoir les objets dans le bon sens.Attention,une permutation des X (5 devient -5)
		n'est pas visible en vue YOZ (logique).
    NUMPAD 5  - Inverse les coordonnées en Y.
		même remarque mais pour la vue XOZ.
    NUMPAD 6  - Inverse les coordonnées en Z.
		même remarque mais pour la vue XOY.
    NUMPAD +  - Zoom In (par pas de 0.01).
		La valeur de zoom au départ et de 0.1
    NUMPAD +  - Zoom Out (par pas de 0.01).
    NUMPAD /  - Divise le zoom par 2.
    NUMPAD *  - Multiplie le zoom par 2.

    Flèches du curseur:
    -------------------
*   HAUT      - Rotation positive de toute la base suivant l'axe horizontal (suivant le plan de vue).
*   BAS       - Rotation negative de toute la base suivant l'axe horizontal (suivant le plan de vue).
*   DROITE    - Rotation negative de toute la base suivant l'axe verticale (suivant le plan de vue).
*   GAUCHE    - Rotation positive de toute la base suivant l'axe verticale (suivant le plan de vue).

    touches clavier:
    ----------------
*   C	      - Centre la base d'objets en <0,0,0>.
    L	      - Charge un nouvel fichier_objet (la base de données est effacée).
    A	      - Ajoute un fichier_objet.
    M	      - Charge plusieurs fichier_objets.Cette commande permet de charge un scène de 3Dpro.
    S	      - Stop le dessin.
    I	      - Donne le nombres d'objets,le total des points et des faces.

    Touches de fonctions:
    ---------------------
    F8	      - Sauve les objets selectionnées au format DXF (PC).
    F9	      - Sauve les objets selectionnées au format GEO (VidéoScape).
    F10       - Ouvre la fenêtre d'informations sur les objets.
    ESC       - Quitter.

    Fenêtre d'informations sur les objets (Uniquement en HR et +):
    --------------------------------------

	Cette fenêtre affiche une liste de tous les objets présent dans la base en donnant:

	- le nombres de points de l'objet.
	- le nombres de faces de l'objet.
	- l'addresse de départ des données des points.
	- l'addresse de départ des données des faces.
	- MinX,MaxX,MinY,MaxY,MinZ,MaxZ.
	- Centre de l'objet (X,Y,Z).
	- Type d'objet (Cyber,Imagine...).

	2 autre fonctions sont possible:

	- Selected - l'objet est selectionné (en bleu).
	- Bounded  - l'objet n'est pas dessiné lors d'un rafraichissement mais sa place
		     est marqué par un boite blanche l'encadrant.

    Convertion en ASCII:
    --------------------
	Les commandes marquées d'un * changent les coordonnées des points.

@endnode
@node "ClickRun Documentation"

    @{"Description   " link "Description ClickRun"}
    @{"Equipements   " link "Equipements ClickRun"}
    @{"Installation  " link "Installation ClickRun"}
    @{"Fonctionnement" link "Fonctionnement ClickRun"}

@endnode
@node "Description ClickRun"

    ClickRun permet de lancer un commande a partir d'une liste.

@endnode
@node "Equipements ClickRun"

    OS 2.XX

    ClickRun a été crée et testé sur:

    A4000 68EC30+68882 KS 39.106 WB 39.29

@endnode
@node "Installation ClickRun"
    Ou vous voulez.
@endnode
@node "Description ClickRun"

    ClickRun permet de lancer un programme d'un simple click,le
    programme est lancé avec la commande exec Execute()
@endnode
@node "Fonctionnement ClickRun"

    le fonctionnement est intuitif,lancez le programme est cliquez.

@endnode
@node "DirW Documentation"

    Description    : DirW est une commande Dir faisant intervenir la
		     WhatIs.library.
    Equipements    : OS 2.XX+WhatIs.library.(copiez DirW ou vous voulez).
    Fonctionnement : DirW <dossier>		- Dir Normal avec le type de fichier.
		     DirW <fichier> COMP <type> - Retourne -1 si le type de fichier
						  est le même sinon 0.

@endnode
@node "EUtils Documentation"

    @{"Description   " link "Description EUtils"}
    @{"Equipements   " link "Equipements EUtils"}
    @{"Installation  " link "Installation EUtils"}
    @{"Fonctionnement" link "Fonctionnement EUtils"}

@endnode
@node "Description EUtils"

    EUtils est un aide a la programmation en E.Il fait intervenir
    les commandes cli suivantes:

    - EC	       (compilateur).
    - EPP	       (pré-proccesseur).
    - Iconvert	       (Convertisseur d'include assembleur).
    - Pragma2Module    (Convertisseur de pragma C en binaire).

    il permet de compiler,utiliser EPP avec n'importe quel editeur de
    texte.

@endnode
@node "Equipements EUtils"

    OS 2.XX.
    ReqTools.library.
    RexxSysLib.library.

@endnode
@node "Installation EUtils"

    Copiez la librarie ReqTools.library dans le dossier libs:.
    mettez EUtils ou vous voulez.
@endnode
@node "Fonctionnement EUtils"

    En cli uniquement:

    .1>EUtils source.e

	Eutils ouvre le fichier source et cherche les mots suivants,
    ils doivent être évidement dans des commentaires.

	ED	   "<vôtre editeur>"
	EC	   "<EC avec options>"
	PREPRO	   "<EPP avec ces options>"
	SOURCE	   "<fichier source>"      /* doit être le même que le fichier réel */
	EPPDEST    "<fichier de destination pour EPP>"
	EXEC	   "<nom de l'executable>"
	ISOURCE    "<nom de l'include ASM>"
	HSOURCE    "<nom de l'include C>"
	ERROREC    "<commande a executer en cas d'erreur avec EC>" /* non fonctionnel */
	ERROREPP   "<commande a executer en cas d'erreur avec EPP>" /* non fonctionnel */
	VERSION    "<numéro de version>"
	REVISION   "<numéro de révision>"
	NAMEPRG    "<nom du programme>"
	NAMEAUTHOR "<nom de l'auteur>"

    voici le bloc que j'utilise :

/********************************************************************************
 * << AUTO HEADER XDME >>
 ********************************************************************************
 ED
 EC
 PREPRO
 SOURCE
 EPPDEST
 EXEC
 ISOURCE
 HSOURCE
 ERROREC
 ERROREPP
 VERSION
 REVISION
 NAMEPRG
 NAMEAUTHOR
 ********************************************************************************
 * HISTORY :
 *******************************************************************************/

    Un fois tous les paramètres initialisés EUtils lance vôtre editeur
    en mode run,ouvre un port Arexx avec les fonctions suivantes:

    EC	      - compile le SOURCE.
    EPP       - EPP le SOURCE en EPPDEST est compile EPPDEST,si tout c'est bien
		passé Eutils renomme EPPDEST (exe) en EXEC.
    INFO      - Requester avec tous les paramètres.
    OPTEPP    - Change les options de EPP.
    OPTEC     - Change les options de EC.
    ICONV     - Converti ISOURCE.
    HCONV     - Converti HSOURCE.
    CHI       - Change (par filerequester) ISOURCE.
    CHH       - Change (par filerequester) HSOURCE.
    CHE       - Change (par filerequester) SOURCE.
    CHEPPDEST - Change (par filerequester) EPPDEST.
    NEWSHELL  - Commande newshell.
    QUIT      - Quit EUtils.

    A chaque compilation reussi EUtils crée un fichier nommé <source>.header
    ce fichier comtient en binaire les informations suivantes:

    (---) OBJECT prgheader
    (  0)   version:INT              /* version */
    (  2)   revision:INT             /* revision */
    (  4)   strdate:substructure     /* date (JJ-MM-AA) de la dernière compilation */
    ( 12)   strtime:substructure     /* heure (HH:MM:SS) de la dernière compilation */
    ( 20)   auteur:substructure      /* nom de l'auteur */
    ( 40)   nomprg:substructure      /* nom du programme */
    ( 60)   vertag:substructure      /* version string $VER: ..... */

    un module (Mheader.m) est un pmodule (PMheader.e) sont fourni pour
    pouvoir lire le fichier <source>.header.

    ce qui donnera pour le fichier exemple.e :

    /******************************/
    /* bla bla			  */
    /******************************/

    OPT ...
    ENUM ..
    MODULE  'Mheader'
    PMODULE 'Pmodules:PMHeader'

    PROC main()
	p_DoReadHeader({prg_banner})
    ENDPROC
    prg_banner:
    INCBIN 'exemple.header'

    une seule variable est globale dans le procédure p_DoReadHeader() :

    DEF title_req[80]:STRING	/* StringF(title_req,'\s v\d.\d © \s',prg_name,prg_version,prg_revision,prg_author) */

    mais vous pouvez en sortir d'autre (la date par exemple)

    ceci vous permet de ne pas avoir a changer tout vos requesters,alertes
    ou autres.
@endnode
@node "Gui_CliConv Documentation"

    @{"Description   " link "Description Gui_CC"}
    @{"Equipements   " link "Equipements Gui_CC"}
    @{"Installation  " link "Installation Gui_CC"}
    @{"Fonctionnement" link "Fonctionnement Gui_CC"}

@endnode
@node "Description Gui_CC"

    Gui_CLiConv est un "batch_processor" pour convertir des images.
    Le nombre de format supportés et en rapport avec vos commandes
    CLI de convertion (Cjpeg/Djpeg/Wasp/Convert etc....).
    La multiséléction est possible.

    Etant fait au départ pour convertir des images,les points
    d'extention sont changés automatiquement.

    Les commandes lancées par le gadget "Convert" sont des scripts
    AmigaDos.

    Ex:
	Commande :JPEG2TGA
	Dir_In	 :hd1:images/jpeg
	Dir_Out  :hd1:images/tga
	Pat_In	 :#?.jpeg
	Pat_Out  :#?.tga

    Convertiras "hd1:images/jpeg/Ionic5.jpeg" En "hd1:images/tga/ionic5.tga".

    Le format des scripts est particulier (cf. @{"Fonctionnement Gui_CC" link "Fonctionnement Gui_CC"}),
    ainsi que leurs localisation (cf. @{"Installation Gui_CC" link "Installation Gui_CC"}).

@endnode
@node "Equipements Gui_CC"

    OS 2.XX.
    Reqtools.library v37 ou +. (Version fournie : 38.1042).

    Gui_CC a été crée et testé sur:

    A4000 68EC30+68882 KS 39.106 WB 39.29

@endnode
@node "Installation Gui_CC"

    Copier la Reqtools.library dans le dossier libs:.
    Copier Gui_CC et Gui_CC.info ou vous voulez.
    Assigner Conv_Scripts: <lecteur/dossier contenant vos scripts> .

@endnode
@node "Fonctionnement Gui_CC"

    EN CLI:
    -------

	> Gui_CliConv

	ou

	> Run <nil: >nil: Gui_CliConv

    EN WB:
    ------

    Double-cliquez sur son icône.

	Si le dossier Conv_Scripts: n'est pas assigné Gui_CC quitte
    automatiquement.
	Un fois lancé,La liste des scripts disponibles est visible
    dans le gadget de liste.En cliquant sur un script,tout les gadgets
    deviennent opérationnels.
    @{b}Toutes édition d'un des gadgets entrainera un changement de la
    ligne de commande lancer par "Convert" .LE SCRIPT RESTERA INCHANGER.
    Le seul moyen de changer un script est le menu Edit.@{ub}
    Le menu Viewer lance vôtre viewer favori,le requestfile s'ouvre
    dans le 'Dir_Out' de Gui_CC.De plus le viewer étant lancé en mode
    CLI vous pouvez mettre des paramètres dans le RequestFile.

    Ex:
	le viewer étant VT (viewtek):

	- selectionnez un image en 640*512
	- cliquez Ok.

	--> L'image est affiché en 320*256 (Scroll possible).

	- selectionnez un image en 640*512
	- rajouter Hires Lace aprés le nom de l'image (comme en cli) cliquez Ok.

	--> L'image est affiché en 640*512 (Image entièrement visible).

	    Bien entendu les arguments possible sont ceux de vôtre viewer.

    @{b}IMPORTANT:@{ub}

    Les scripts sont des scripts typiquement AmigaDos,seuls quelques commentaires
    sont néssésaires.(LES 3 PREMIERES LIGNES SONT OBLIGATOIRE).

    Ex:
    Nom du fichier script :JPEG2HAM

    .key source,destin
    .bra {
    .ket }
    djpeg030 -gif "{source}" t:temp0
    wasp.030.881 -ham t:temp0 "{destin}"
    Delete >nil: t:temp0
    ;COM=JPEG2HAM
    ;DIR_IN=hd1:images/jpeg
    ;DIR_OUT=hd1:images/ham
    ;PAT_IN=#?.jpeg
    ;PAT_OUT=#?.ham

    Gui_CC se sert des lignes en commentaires pour les String_gadgets,
    donc pour la ligne de commande.

    TOUTES les commandes sont sourcées dans le dossier Conv_Scripts:,il
    est donc nésséssaire de faire un fichier script même pour une seule
    commande.

    Ex:
    Nom du fichier script :JPEG2GIF

    .key source,destin
    .bra {
    .ket }
    djpeg030 -gif "{source}" "{destin}"
    ;COM=JPEG2GIF
    ;DIR_IN=hd1:images/jpeg
    ;DIR_OUT=hd1:images/gif
    ;PAT_IN=#?.jpeg
    ;PAT_OUT=#?.gif

	Une fois vôtre script séléctionné,cliquez sur "Convert".
    un sélécteur de fichiers vous permet une multiséléction (Shift-Click).
    La longueur totale du slider gadget représente le nombres total de
    fichiers à convertir,le petit rectangle noir représente le fichier
    sur lequel Gui_CC est en train de travailler (ce rectangle se déplace
    de gauche a droite).Les autres gadgets sont désactivés lors de la convertion.
	Le nom du fichier en train d'être converti est donné en-dessous du
    "slider_gadget".

    Ajout de fichier Script:
    ------------------------

	Pour ajouter un fichier script,vous pouvez :

	- editez un fichier déjà existant.
	- faire les modifications nésséssaires.
	- le sauver sous un autre nom (ATTENTION AUX COMMENTAIRES).
	- Faire l'entrée menu NewList.

	    Vôtre script apparaitra dans la liste.

	Si vous copiez un fichier script dans le dossier Conv_Scripts:

	- Faire l'entrée menu NewList.
	- entrez son nom dans le string_gadget Commande.
	- Editez le.
	- faire les modifications nésséssaires.
	- le sauver.

	@{fg highlight}
	Même si vôtre éditeur favori fait sauter le bit de script,ce bit est remis
	lors d'un NewList sur tous les fichiers scripts.
	@{fg text}
@endnode
@node "Jpeg&Ilbm24 Documentation"

    @{"Description   " link "Description Jpeg&Ilbm24"}
    @{"Equipements   " link "Equipements Jpeg&Ilbm24"}
    @{"Installation  " link "Installation Jpeg&Ilbm24"}
    @{"Fonctionnement" link "Fonctionnement Jpeg&Ilbm24"}

@endnode
@node "Description Jpeg&Ilbm24"
    Jpeg&Ilbm24 est un convertisseur Jpeg<->Ilbm24,il peut sauver des images
    Ilbm avec le "chunk" special de la carte Opal.
@endnode
@node "Equipements Jpeg&Ilbm24"

    OS 2.XX.
    Opal.library v2.2 ou +. (Version fournie : 2.2).

    Jpeg&Ilbm24 a été testé sur:

    A4000 68EC30+68882 KS 39.106 WB 39.29

@endnode
@node "Installation Jpeg&Ilbm24"

    Copier l' Opal.library dans le dossier libs:.
    Copier Jpeg&Ilbm24 et Jpeg&Ilbm24.info ou vous voulez.

@endnode
@node "Fonctionnement Jpeg&Ilbm24"

    EN CLI:
    -------

	>Jpeg&Ilbm24

    EN WB:
    ------
	Double-cliquez sur l'icone de Jpeg&Ilbm24.


	- Choississez un sens de convertion

	    JPEG->ILBM24   - du Jpeg en Ilbm 24 bits.
	    ILBM24->JPEG   - du Ilbm 24 bits en Jpeg.
	    ILBM->ILBM24   - du Ilbm en Ilbm 24 bits.

	    - Opal Chunk   - Le fichier Ilbm resultant contiendras le chunk opal.
	    - Fast Format  - Option de sauvegarde pour la carte 16 millions de couleurs Opal.

	    IMPORTANT: Si vous n'avez pas la carte Opal ces deux options ne doivent pas être
	selectionnées.

	Ces deux options sont désactivées lors des convertions Ilbm24->Jpeg

	    - Jpeg Corrupt - défini les pertes dans le fichier Jpeg.
			     une valeur de 100 donneras aucune perte d'informations dans le fichier
			     Jpeg (mais un taux de compréssion moindre).

	    Ex:
		Jpeg Corrupt=100

	    fichier source     :874174 octets.
	    fichier destination:255343 octets.

		Jpeg Corrupt=75

	    fichier source     :874174 octets.
	    fichier destination: 91633 octets.

	Lors de la convertion le titre de la fenêtre de Jpeg&Ilbm24 indique
    le numéro de fichier traité sur le nombres total de fichiers a convertir.
    Le titre de l'écran indique le nom du fichier en cours de convertion.
    (Aucun break n'est possible lors d'une convertion).

    Le premier selecteur de fichiers vous permet de choisir les fichiers sources.
    Le deuxieme vous permet de choisir le dossier de destination.

    Les points d'extention sont rajoutés automatiquement.

    Sur des fichiers Ilbm 24 bits - .Ilbm24
    Sur des fichiers Jpeg	  - .jpeg

    Si le fichier source a déjà un point d'extention celui-ci est supprimé et est
    remplacé par l'extention correspondante.Si le fichier source n'a pas de point
    d'extention celui-ci est rajouté.

    Ex:
	Convertion Jpeg->Ilbm24

	Fichier source : Image.tagada Fichier de destination : image.Ilbm24
	Fichier source : Image	      Fichier de destination : image.Ilbm24

    INFORMATION :

	Lors de la convertion Jpeg&Ilbm24 ouvre un écran virtuel 24 bits de la taille
    de l'image,cette écran est un écran spécial (pour la carte Opal).Il est impossible
    de le voir sur un machine n'ayant pas le hardware (la mienne fait partie du lot),et
    de plus,la place que prend cet écran dépend de la taille de l'image en source.
    Donc a moins d'avoir 16 Mo de ram: il est preferable d'avoir les fichiers a traiter
    sur disque (HD) est non en ram:.

@endnode
@node "MappIc Documentation"

		@{" Description  " link "Description    MAppIc"}
		@{" Equipements  " link "Equipements    MAppIc"}
		@{" Installation " link "installation   MAppIc"}
		@{"fonctionnement" link "fonctionnement MAppIc"}

@endnode
@node "Description    MAppIc"

    @{b}MAppIc@{ub} permet d'associer une AppIcon a un programme,qui normale-
    ment n'en a pas.

@endnode
@node "Equipements    MAppIc"

    @{b}MAppIc@{ub} a été programmé en Amiga_E v2.1 (Fred Fish 810) et ce,
    sur un 4000/68E030+68882 en OS 3.0.Il devrait tourner sans prôblème en
    OS 2.xx.
    Les libraries utilisées sont celle du système.

@endnode
@node "installation   MAppIc"

    @{b}MAppIc@{ub} est une commande CLI,si jamais vous décidez de la mettre
    dans votre Startup-sequence elle doit être placée @{b}après@{ub} la comman-
    de LoadWB,sinon vous pouvez le mettre n'importe ou sur vôtre HD.

@endnode
@node "fonctionnement MAppIc"

    Syntaxe:

    MAppIc <nom icone sans .info> COM <commande associée> NAME <nom de l'icône
    du WB> [QUIT|TEST|MULTI]

    Le nom de l'icône doit être donné sans l'extention .info.
    Si plusieurs paramètres sont définis dans la commande associée il faut
    utilisé des " ".
    Si aucun nom est donné L'AppIcon n'en auras pas.

    l'option QUIT permet de lancer une seule fois la commande associée.

    l'option test permet de tester les coordonnées d'une icône.

    l'otion MULTI permet a MAppIc de se comporter comme une véritable AppIcon.

    Pour Quitter MAppIc il suffit de déplacer n'importe quelle icône sur
    l'icône a enlever (Sauf en mode MULTI).

	@{b}ASTUCES:@{ub}

    Pour placer une icône en AppIcon,faire une copie en ram: de l'icône a
    placer,la "sortir" par le WorkBench,la placer ou vous voulez sur vôtre
    WorkBench.Ensuite "Figer" cette icône (toujours par le WorkBench),il
    ne vous reste plus qu'a la tester pour avoir ses coordonnées que vous
    devez repporter dans les tooltypes de l'icône (POSX et POSY).

    @{b}Attention@{ub}

    Le Workbench est semsible à l'emplacement de vos icônes,si il ne peut
    pas la placer (POSX POSY) ou si ces tooltypes sont absent,le WorkBench
    desideras par lui même sa place.
    Même sans nom il est impossible de "coller" les icônes verticalement,
    le WorkBench tient compte de la place prise par le nom.
@endnode
@node "MemFree Documentation"

		@{" Description  " link "Description    MemFree"}
		@{" Equipements  " link "Equipements    MemFree"}
		@{" Installation " link "installation   MemFree"}
		@{"fonctionnement" link "fonctionnement MemFree"}

@endnode
@node "Description    MemFree"

	MemFree v 0.0d Documentation

    MemFree affiche la mémoire chip/fast total,le plus grand bloc et ce qui
    reste.
@endnode
@node "Equipements    MemFree"

    @{b}MemFree@{ub} a été programmé en Amiga_E v2.1 (Fred Fish 810) et ce,
    sur un 4000/68E030+68882 en OS 3.0.Il devrait tourner sans prôblème en
    OS 2.xx.
    Les libraries utilisées sont celle dy système a part la ReqTools.Library
    v 38.810 (CAM 665B).

@endnode
@node "installation   MemFree"

	Copiez MemFree ou vous voulez et le reqtools.library dans le dossier
	Libs:
@endnode
@node "fonctionnement MemFree"

    Fonctionnement:

    En CLI:

    MemFree DELAY 10 [FRONT|PS <nom_pubscreen>].

    - DELAY defini le temps de rafraichissement de la fenêtre en Tick.
    (1 tick=1/50 secondes).
    - FRONT, la fenêtre de MemFree seas toujours 'ToFront'.
    - PS , la fenêtre de MemFree tenteras de s'ouvrir sur l'écran public
      spécifé.

    EN WB:

    Une icône Tool avec comme ToolTypes possible:

    DELAY=<n>		- n en Tick.
    FRONT=[TRUE|FALSE]	- Toujours 'ToFront' (Vrai ou faux).
    PS=<nom_pubscreen>	- Nom de l'écran public.

	MemFree a aussi un port Arexx nommé MemFreePort,les commandes
    possible sont les suivantes:

    FRONT		      - met MemFree 'ToFront'.
    BACK		      - met MemFree 'ToBack'.
    YESFRONT		      - met MemFree toujours 'ToFront'.
    NOFRONT		      - inverse de YESFRONT.
    FAST		      - Affiche la mémoire FAST.
    CHIP		      - Affiche la mémoire CHIP.
    CHANGEPS <nom_pubscreen>  - MemFree change d'écran public,si l'écran
				spécifié n'existe pas MemFree seras sur le
				WB.
    NEWDELAY <delay>	      - Définie un nouveau delay (en tick toujours).
    FASTCHIP		      - Switch entre FAST et CHIP a la même fréquence
				que delay (un delay de 50 fera inverser CHIP
				et FAST toutes les secondes).
    ZIP 		      - Fonction ZipWindow.
    QUIT		      - Quitte MemFree.

	Le port AREXX peut être utilisé de la manière suivante:

    >rx "address 'MemFreePort' FRONT"  - Met MemFree 'ToFront'.

    Les mots entre '' auront les majuscules/minuscules respectées,ceci
    est très important pour les écrans public (les espaces le seront aussi).

    >rx "address 'MemFreePort' changeps 'MyPublicScreen'

    Les commandes AREXX doivent être uniquement en majuscules,pour ce faire
    il suffit de ne pas les encadrés de ''.



    Historique :

    v 0.0a - Version Initiale.
    v 0.0b - Ajout de DELAY et PUBSCREEN (en CLI comme en WB).
    v 0.0c - Ajout de FRONT (en CLI comme en WB).
    v 0.0d - Ajout d'un port AREXX.
	     Commandes : QUIT/BACK/FRONT/NOFRONT/YESFRONT/FAST/CHIP/
			 CHANGEPS <nom_pubscreen>/NEWDELAY <delay>/
			 FASTCHIP/ZIP.
    v 0.0e - Ajout des menus (GadTools.library) et des requesters de la
	     ReqTools.library.
@endnode
@node "NasScreen Documentation"

    @{"Description   " link "Description NasScreen"}
    @{"Equipements   " link "Equipements NasScreen"}
    @{"Installation  " link "Installation NasScreen"}
    @{"Fonctionnement" link "Fonctionnement NasScreen"}

@endnode
@node "Description NasScreen"

    NasScreen ouvre un écran public,qui devient l'écran par défaut.Les
    menus sont entierement configurables.

@endnode
@node "Equipements NasScreen"

    OS 2.XX

@endnode
@node "Installation NasScreen"

    Copiez NasScreen ou vous voulez.
@endnode
@node "Fonctionnement NasScreen"

    NasScreen construit ces menus a partir d'un fichier de configuration comme suis:

# Menu For NasScreen
SCREENMODE MODE "SHR" TYPE "PAL" DEPTH "2" DP "1" BP "2" FONT "Tpoaz.font/8"
PALETTE COL0 "$787" COL1 "$111" COL2 "$ABB" COL3 "$068"
# SYSTEM UTILITIES
MENU " WorkBench "
ITEM " Utilities "
SUBI " MultiView " STACK "8000" COMM "Sys:Utilities/Multiview"
SUBI "   Clock   " STACK "4000" COMM "Sys:Utilities/Clock"
SUBI "AmigaGuide " STACK "8000" COMM "Sys:utilities/amigaguide `requestfile`"

    La ligne SCREENMODE:
    MODE "BR"    320*256  TYPE "PAL"  DEPTH "number" DP "number"  BP "number" FONT "name.font/size"
	 "BRE"   320*512       "NTSC"                detail pen bock pen
	 "HR"    640*256
	 "HRE"   640*512
	 "SHR"  1280*256
	 "SHRE" 1280*512

    La ligne PALETTE COL0 "couleur" COL1 "couleur" COL2 "couleur" COL3 "couleur"

    MENU "titre du menu"
    ITEM "titre" STACK "stack" COMM "commande"
    SUBI "titre" STACK "stack" COMM "commande"

    Toutes les commandes sont lancées avec le fonction SystemTagList() en mode ASYNCH.

@endnode

@node "Recall Documentation"

    Description  : Recall popup un requester si la date courante a un rapport avec une date dans
		   le fichier s:Recall.date.
    Equipements  : ReqTools.library.
    Installation : copiez Recall ou vous voulez,copiez Recall.date dans le dossier s:
		   et ajoutez la ligne suivante dans vôtre user-startup :
		   Recall

    Le fichier recall.date est du type suivant (sans les expicatifs) :

    23-10-** Anniversaire d'Aubin.       -> tout les 23/10 de chaque année.
    **-03-** On est au mois de Mars.	 -> tout les mois de mars de chaque année.
    01-01-** Bonne Année.		 -> tout les 1 janvier.
    24-12-** Joyeux Noël.		 -> tout les noël.
    11-**-** On est le 11.		 -> tout les 11 du mois.
    **-**-94 On est en 1994.		 -> toute l'année 94.
    11-03-94 On est le 11/03/94.	 -> le 11-03-94 uniquement.

@endnode
@node "SelectS Documentation"

    Description    : SelectS permet de selectionné (tofront) un écran (public ou non).
    Equipements    : OS 2.XX + reqtools.library.
    Installation   : Copiez SelectS ou vous voulez.
    Fonctionnement : intuitif.

@endnode
@node "Smodule Documentation"

   Description :

    Smodule permet de voir les modules E.Jusqu'a 10 modules sont
    possible.

   Equipements:

    OS 2.XX

    Foctionnement:

    la seule option possible est un fichier de configuration comme suis:

    emodules:exec/execbase
    emodules:intuion/intuition
    etc...

    1.>Smodule <fichier de config>

@endnode
@node "TM_AutoDock Documentation"

    @{"Description   " link "Description TM_AutoDock"}
    @{"Equipements   " link "Equipements TM_AutoDock"}
    @{"Installation  " link "Installation TM_AutoDock"}
    @{"Fonctionnement" link "Fonctionnement TM_AutoDock"}

@endnode
@node "Description TM_AutoDock"

	TM_AutoDock Initialise un Dock de ToolManager en parcourant un
	dossier passé en paramètre.Seuls les fichiers Executables seront mis
	dans le Dock.

@endnode
@node "Equipements TM_AutoDock"

    OS 2.XX.
    ToolManager.Library v3.
    WhatIs.Library	v3.

    TM_AutoDock a été crée et testé sur:

    A4000 68EC30+68882 KS 39.106 WB 39.29

@endnode
@node "Installation TM_AutoDock"

    Copier la ToolManager.library et la WhatIs.Library dans le dossier libs:.
    Copier TM_AutoDock ou vous voulez.

@endnode
@node "Fonctionnement TM_AutoDock"

    EN CLI:
    -------

	> TM_AutoDock <dossier> COL <nbrs de colonnes> POPUP HOTKEY "alt t" ARG ICON.

	avec:

	<dossier>	   - Le dossier parcouru.
	COL <n> 	   - Le nombres de colonnes du Dock. (optionnel default n=1).
	POPUP		   - Le Dock seras ,ou ne seras pas ,enlevé après une séléction.
	HOTKEY ou HK <key> - Hotkey d'appel (cf. doc de ToolManager).
	ARG		   - Le Dock est en AppWindow.
	ICON		   - Afficheras le Dock avec les icônes au lieu de texte.
			     (ATTENTION:Il suffit d'un seul fichier sans icône pour que
			     TM_AutoDock quitte).
    EN WB:
    ------
	Y'a pas.

	Les fichiers contenus dans le dossier sont triés avec la WhatIs.library
	seuls les types de fichier suivant sont valides:

	Exe,Pure Exe,PP40 Exe,PP30 Exe,PP Exe,Script

	Les fichiers sans icônes seront lancés par ToolManager en mode CLI avec une sortie.
	Les autres (avec icônes) seront lancés en mode WB.

	Une fois le Dock affiché vous pouvez le quitter par le programme Exchange,ceci
	vous permet de lancer TM_AutoDock avec run.

@endnode
@node "VText Documentation"

@endnode
@node "ViewIlbm Documentation"

    @{"Description   " link "Description ViewIlbm"}
    @{"Equipements   " link "Equipements ViewIlbm"}
    @{"Installation  " link "Installation ViewIlbm"}
    @{"Fonctionnement" link "Fonctionnement ViewIlbm"}
@endnode
@node "Description ViewIlbm"

    ViewIlbm est un viewer ILBM.Il peut sauvez le chunk CAMP dans le
    fichier ILBM.

@endnode
@node "Equipements ViewIlbm"

    OS 3.XX   (visualisation ILBM24 (seuls les 8 premiers bitplanes sont
	       pris en compte,ce qui donne un image en 256 couleurs gris).
    iff.library.
    reqtools.libray.
@endnode
@node "Installation ViewIlbm"

    Copiez la librarie iff.library dans vôtre dossier libs:.
    mettez ViewIlbm ou vous voulez.
@endnode
@node "Fonctionnement ViewIlbm"

    En CLi uniquement:

    ViewIlbm FICHIER,HIRES/S,LACE/S,LORES/S,REQ/S,INFO/S,FILEREQ/S

    avec :
	Fichier 	  - fichier source Ilbm.
	HIRES,LACE,LORES  - Change le format.
	REQ		  - Choix du format d'écran par screenrequester.
	INFO		  - Information sur le fichier par requester.
	FILEREQ 	  - Choix du fichier source par filerequester.

    Une fois l'image visible,un click droite quitte ViewIlbm.
    si vous voulez sauvez le nouveau CAMP cliquez sur les 2 boutons
    de la souris (d'abors le gauche puis le droite),l'ecran doit flasher,
    vous pouvez maintenant quittez,le nouveau chunk sera sauvé.
@endnode
@node "WhatView Documentation"

		@{" Description  " link "Description    WhatView"}
		@{" Equipements  " link "Equipements    WhatView"}
		@{" Installation " link "installation   WhatView"}
		@{"fonctionnement" link "fonctionnement WhatView"}

		@{"Update Whatview" link "Update Whatview"}

@endnode
@node "Description    WhatView"

    @{b}WhatView@{ub} vous permet d'un simple clic de la souris de lancer
    n'importe quelle application en rapport avec le type de fichiers lui
    étant passé en paramètre.

@endnode
@node "Equipements    WhatView"

    @{b}WhatView@{ub} a été programmé en Amiga_E v2.1 (Fred Fish 810) et ce,
    sur un 4000/68E030+68882 en OS 3.0 (KS 39.106 WB 39.29).
    Il devrait tourner sans prôblème en OS 2.xx.
    Les libraries utilisées sont celle dy système a part la WhatIs.Library
    v 3.5 (Fred Fish 843) et la ReqTools.library v 38.1042 (CAM 790B).

@endnode
@node "Installation   WhatView"

    Vous pouvez mettre @{b}WhaView@{ub} ou vous voulez,mais il faut s'avoir
    que @{b}WhatView@{ub} lit les toolstypes de son icone.Du cli il faut donc
    lui mettre en paramétre son icone sans le .info.
    Ex:
    1.>Whatview Hd0:WbStartup/Whatview

    Si l'envie vous prend de le mettre dans le dossier WBstartup ne pas ou-
    blier le tooltype DONOTWAIT.

    copier les libraries WhatIs.library et reqtools.library dans le dossier
    Libs:.

@endnode
@node "fonctionnement WhatView"

    @{b}WhatView@{ub} n'utilise que les tooltypes de son icône comme fichier
    de configuration.Plusieurs tooltypes sont interne :

    DONOTWAIT	    - Si @{b}WhatView@{ub} est dans le dossier WBstartup
    DEFDIR=opt	    - Défini le dossier par défault pour les icônes prédéfi-
		      nies (WhatIs.library).Ceci permet de soulager le
		      dossier env:sys.
		      Si ce tooltypes est absent le dossier par défaut (Env:Sys) sera pris.
    POSX=position x - Détermine la position en x de l'Appicon.
    POSY=position y - Détermine la position en y de l'Appicon.


    Shift-cliquez sur les icônes des fichiers puis faire Outils->WhatView (ou déplacer les icones
    selectionnées sur l'icone de whatview) ,la fenêtre de WhatView vous permettant de choisir l'action
    voulue.
    Si aucun fichier n'est cliqué la fenêtre de Whatview apparaitra.


Quelques Exemples :

## Types de fichier	       ToolTypes corespondant
##(WhatIs.library)

TYPE "Source E"                     |
    SUBTYPE	Text		    |-->> Source E=hd1:cc/az -b -d
    ICONNAME	def_E		    |
    NAMEPATTERN "#?.e"              |
ENDTYPE

TYPE "PP Doc"                       |
    SUBTYPE "PP Data"               |-->> PP Doc=run hd1:cc/ppmore -S*
    ICONNAME def_ppdoc		    |
    NAMEPATTERN "#?.(Doc#?.pp|Doc)" |
ENDTYPE

    @{b}Remarque:@{ub}Les minuscules/majuscules sont importantes.


    La Fenêtre:

    WhatView  - Execute l'action définie dans les tooltypes.Si un type de
		fichier est reconnu,mais qu'il n'y a pas d'entrée tooltypes,
		@{b}WhatView@{ub} vous le dira.
    Info      - Donne le nom, le type de fichiers et la taille de fichier.
    AddIcon   - Ajoute une icône au fichiers sélectionnés,@{b}ATTENTION@{ub} si une
		icône existe déjà elle seras ecrasée.
    Execute   - Permet d'executer une commande sur un fichier (string request).
    Quit      - Quitte @{b}WhaView@{ub}.

			   <<<<<<<<<<<<<< >>>>>>>>>>>

    EditTT     - Edite les Tooltype de l'icône de WhatView.
    AddTT      - Ajoute un tooltype.
    RemTT      - Efface le tooltype courant.
    QuitTT     - SAUVE LES TOOLTYPES dans l'icône et quitte l'éditeur.


    Les Menus:

    Info       - Information.
    All Tpyes  - Tous les types de fichier reconnus par la whatis sont
		 affichés dans la liste.
		 ATTENTION:Cette fonction efface les les tooltypes de configuration
		 de WhatView (POSX,POSY etc...).
    Flush WI   - Flush et rcharge la whatis.library.

    Port Arexx:

    WhatView a un port arexx nommé WhatViewPort les commandes suivantes sont possible:

    - ADDARG FULL "<lecteur/dossier/fichier>" REEL "<fichier>"

      Ajoute un argument a la liste des arguments de WhatView (cf Wv.rexx).

    - WHATVIEW,INFO,ADDICON,EXECUTE,QUIT.

	Même résultat que la sélection d'un des gadets de la fenêtre.

    quelques exemples:

    1.>alias WVR rx "address 'WhatViewPort' []"

    faites WVR WHATVIEW ou INFO ou ADDICON ou EXECUTE ou QUIT  - Selection par filerequester.

    ou:

    1.>rx wv ram:* info      (script arexx la pattern est celle de la arp.library).

@endnode
@node "Update Whatview"

	La doc que vous venez de lire est valable pour les versions 0.11 et inférieur.
    A partir de la version 0.15 Whatview a été réécrit pour profiter du WBStart-Handler Port.

    Whatview se compose donc maintenant de 3 programmes:

    - Whatview.
    - WVprefs.
    - Whatis.

    Whatview a toujours besoin de son icone mais stocke désormais ses informations dans le
    fichier Env:Whatview.prefs.

    Les ToolTypes possible pour Whatview sont:

    - DONOTWAIT    -> Si vous mettez Whatview Dans le WBStartup.
    - DEFDIR	   -> Dossier des icones.
    - DEFPREFSDIR  -> Dossier contenant WVprefs.
    - POSX et POSY -> Position de l'icone.
    - MAXARG	   -> Nombres d'arguments maximun (20 args est le MAX).

	Les Commandes associées aux types de fichiers sont lancer beaucoup plus
    proprement que les versions antérieurs.
    Les arguments sont triés suivant leurs types est la commande associée n'est
    lancer qu'une seule fois contrairement au version précédentes.Vous pouvez
    donc mélanger des images,du texte,etc.. sans avoir 20 BackGround CLI.
    ATTENTION le fonction Execute de Whatview est toujours la fonction Exec Execute().

	Les modes de lancement ainsi que les fichier Whatview.prefs,est géré
    par le programme WVPrefs.

    La liste de gauche donne tous les ID de vôtre système.
    La liste de droite est la liste sauvegardé.

    Le Gadget ADD fait passer l'ID selectionné de la liste de droite dans celle de gauche,
    si l'ID s'y trouve déjà le nouvel ID n'est pas ajouté.

    Le Gadget ? ouvre un sélécteur de fichiers vous permettant de selectionné la commande
    associée.

    Le Cycle Gadget selectionne le mode de lancement.

    Les Strings Gadgets pour la pile et la priorité.

    Le gadget Sauver sauve la liste de gauche dans le fichier env:WhatView.Prefs,ce fichier
    est charger par WhatView a chaque changement de celui-ci (a la manière de ToolManager).
    Si vous copiez un nouveau fichier de configuration sur celui-ci,Whatview chargeras le
    nouveau fichier.

    EX:
	Copy Envarc:WV.prefs Env:Whatview.prefs.   Whatview chargeras WV.prefs (renommer en
										Whatview.prefs).

    Sauer S. vous permet de sauver avec un sélécteur de fichier.

    Charger vous permet de charger une nouvelle configuration.

    <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< IMPORTANT >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		 LE PORT WhatViewPort N'EST PLUS UN PORT AREXX
    >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	Ce port est maintenant un port public mais plus un port Arexx.La commande
    WhatIs vous permet de communiquer avec ce port.

    WhatIs DOSSIER,ACT/K,FLUSH/S,PREFS/S

    DOSSIER -> le nom du dossier (pattern possible Ex Ram:#?.e,Emodules:#?.m,Sources:A#?)
    ACT     -> WHATVIEW,INFO,ADDICON,EXECUTE,QUIT (idem que WhatView (WHATVIEW par défaut)).
    FLUSH/S -> Flush la Whatis.Library.
    PREFS/S -> Ouvre WVPrefs.

    (La structure du message est dans le module WVprefs.m)

@endnode





