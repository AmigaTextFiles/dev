@database "opal"
@master "Ram_Disk:opal.doc"

@Node Main "opal.doc"
    @{" ActiveScreen24()       " Link "ActiveScreen24()"} @{" AmigaPriority()        " Link "AmigaPriority()"} @{" AppendCopper24()       " Link "AppendCopper24()"}
    @{" AutoSync24()           " Link "AutoSync24()"} @{" BitPlanetoOV()         " Link "BitPlanetoOV()"} @{" ClearDisplayBottom24() " Link "ClearDisplayBottom24()"}
    @{" ClearPFStencil24()     " Link "ClearPFStencil24()"} @{" ClearPRStencil24()     " Link "ClearPRStencil24()"} @{" ClearQuick24()         " Link "ClearQuick24()"}
    @{" ClearScreen24()        " Link "ClearScreen24()"} @{" CloseScreen24()        " Link "CloseScreen24()"} @{" Config24()             " Link "Config24()"}
    @{" CreateScreen24()       " Link "CreateScreen24()"} @{" DisablePRStencil24()   " Link "DisablePRStencil24()"} @{" DisplayFrame24()       " Link "DisplayFrame24()"}
    @{" DisplayThumbnail24()   " Link "DisplayThumbnail24()"} @{" DrawEllipse24()        " Link "DrawEllipse24()"} @{" DrawLine24()           " Link "DrawLine24()"}
    @{" DualDisplay24()        " Link "DualDisplay24()"} @{" DualPlayField2()       " Link "DualPlayField2()"} @{" EnablePRStencil24()    " Link "EnablePRStencil24()"}
    @{" FadeIn24()             " Link "FadeIn24()"} @{" FadeOut24()            " Link "FadeOut24()"} @{" FreeScreen24()         " Link "FreeScreen24()"}
    @{" FreezeFrame24()        " Link "FreezeFrame24()"} @{" ILBMtoOV()             " Link "ILBMtoOV()"} @{" LatchDisplay24()       " Link "LatchDisplay24()"}
    @{" LoadImage24()          " Link "LoadImage24()"} @{" LowMemUpdate24()       " Link "LowMemUpdate24()"} @{" LowMem2Update24()      " Link "LowMem2Update24()"}
    @{" LowMemRGB24()          " Link "LowMemRGB24()"} @{" OpenScreen24()         " Link "OpenScreen24()"} @{" OVPriority()           " Link "OVPriority()"}
    @{" OVtoBitPlane()         " Link "OVtoBitPlane()"} @{" OVtoILBM()             " Link "OVtoILBM()"} @{" OVtoRGB()              " Link "OVtoRGB()"}
    @{" PaletteMap24()         " Link "PaletteMap24()"} @{" ReadPFPixel24()        " Link "ReadPFPixel24()"} @{" ReadPixel24()          " Link "ReadPixel24()"}
    @{" ReadPRPixel24()        " Link "ReadPRPixel24()"} @{" RectFill24()           " Link "RectFill24()"} @{" Refresh24()            " Link "Refresh24()"}
    @{" RegWait24()            " Link "RegWait24()"} @{" RGBtoOV()              " Link "RGBtoOV()"} @{" SaveIFF24()            " Link "SaveIFF24()"}
    @{" SaveJPEG24()           " Link "SaveJPEG24()"} @{" Scroll24()             " Link "Scroll24()"} @{" SetControlBit24()      " Link "SetControlBit24()"}
    @{" SetCoPro24()           " Link "SetCoPro24()"} @{" SetDisplayBottom24()   " Link "SetDisplayBottom24()"} @{" SetHires24()           " Link "SetHires24()"}
    @{" SetLoadAddress24()     " Link "SetLoadAddress24()"} @{" SetLores24()           " Link "SetLores24()"} @{" SetPFStencil24()       " Link "SetPFStencil24()"}
    @{" SetPRStencil24()       " Link "SetPRStencil24()"} @{" SetRGB24()             " Link "SetRGB24()"} @{" SetScreen24()          " Link "SetScreen24()"}
    @{" SetSprite24()          " Link "SetSprite24()"} @{" SingleDisplay24()      " Link "SingleDisplay24()"} @{" SinglePlayField24()    " Link "SinglePlayField24()"}
    @{" StopUpdate24()         " Link "StopUpdate24()"} @{" UpdateAll24()          " Link "UpdateAll24()"} @{" UpdateCoPro24()        " Link "UpdateCoPro24()"}
    @{" UpdateDelay24()        " Link "UpdateDelay24()"} @{" UpdatePalette24()      " Link "UpdatePalette24()"} @{" UpdatePFStencil24()    " Link "UpdatePFStencil24()"}
    @{" UpdateRegs24()()       " Link "UpdateRegs24()()"} @{" WriteFrame24()         " Link "WriteFrame24()"} @{" WritePFPixel24()       " Link "WritePFPixel24()"}
    @{" WritePixel24()         " Link "WritePixel24()"} @{" WritePRPixel24()       " Link "WritePRPixel24()"} @{" WriteThumbnail24()     " Link "WriteThumbnail24()"}
    @{" OpalRequester()        " Link "OpalRequester()"}
@EndNode

@Node "ActiveScreen24()" "opal.library/ActiveScreen24"

@{b}	NAME@{ub}
	ActiveScreen24 -- Provides a pointer to the currently displayed OpalVision screen.

@{b}	SYNOPSIS@{ub}
	OScrn = ActiveScreen24 (void);
	D0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	This function provides a pointer to the currently displayed OpalVision screen. If there is no OpalVision
	display active then a null value is returned.

	This call is useful for writing background colour cycling or coprocessor effects programs to affect the
	currently open screen.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	OScrn	-A pointer to the currently open OpalVision screen, or NULL.

@{b}	CONSIDERATIONS@{ub}

	Caution must be exercised when dealing with screens owned by another task. Bitplane access should be
	avoided unless running cooperative tasks with mutually exclusive bitplane access.

@{b}	SEE ALSO@{ub}

	@{"OpenScreen24()" Link "OpenScreen24()"}

@EndNode

@Node "AmigaPriority()" "opal.library/AmigaPriority"

@{b}	NAME@{ub}
	AmigaPriority -- Gives Amiga graphics priority over OpalVision display.

@{b}	SYNOPSIS@{ub}
	void AmigaPriority (void);

@{b}	FUNCTION@{ub}
	This function clears the OVPRI bit of all CoPro instructions which gives Amiga graphics priority over
	OpalVision graphics. If a dual display has not been set, only Amiga graphics will be visible.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Opal display bottom has been set, the coprocessor instructions will not be
	modified for that region of the display.

@{b}	SEE ALSO@{ub}
	@{"OVPriority()" Link "OVPriority()"}
	@{"DualDisplay24()" Link "DualDisplay24()"}
@EndNode

@Node "AppendCopper24()" "opal.library/AppendCopper24"

@{b}	NAME@{ub}
	AppendCopper24 -- Attaches user copper lists to existing display copper lists.

@{b}	SYNOPSIS@{ub}
	void AppendCopper24 (CopLists);
				A0

	UWORD **CopLists[12];

@{b}	FUNCTION@{ub}
	Up to 12 different Amiga copper lists are used to update the OpalVision memory. This function allows
	user copper lists to be attached to the end of each of the lists to enable split screen 24bit displays and
	other copper effects.

	Each copper list must be terminated with $FFFFFFFE followed by 30 free bytes for linkage code.

	After attaching copper lists, the LastWait field in the OpalScreen structure must be initialised with the
	last vertical position wait in the attached copper lists.

	The VStart field in the OpalScreen structure contains the scan line of the first displayed line for the
	screen. To convert a display 'y' coordinate to a vertical copper wait instruction, use VWait = y + VStart.

@{b}	INPUTS@{ub}
	CopLists	- Pointer to an array of 12 copper list pointers to be joined to the current display copper lists.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	All copper lists must reside in chip ram.

@{b}	SEE ALSO@{ub}

@EndNode

@Node "AutoSync24()" "opal.library/AutoSync24"

@{b}	NAME@{ub}
	AutoSync24 -- Enables auto horizontal synchronisation.

@{b}	SYNOPSIS@{ub}
	void  AutoSync24 (Sync);
			  D0

	BOOL Sync;

@{b}	FUNCTION@{ub}
	Enables the OpalVision's auto synchronisation mode (see "Horizontal Synchronisation").  This mode will
	be automatically disabled when frame buffer updates are occurring, and re-enabled when they cease.

@{b}	INPUTS@{ub}
	Sync =	0 = Disable auto syncing,  1 = Enable auto syncing.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}


@EndNode

@Node "BitPlanetoOV()" "opal.library/BitPlanetoOV"

@{b}	NAME@{ub}
	BitPlanetoOV -- Converts standard bitplane data to OpalVision format.

@{b}	SYNOPSIS@{ub}
	void BitPlanetoOV (OScrn, SrcPlanes, SrcWidth, Lines, TopLine, SrcDepth)
			   A0	  A1	     D0        D1     D2       D3

	struct OpalScreen *OScrn;
	UBYTE **SrcPlanes[];
	long SrcWidth;
	long Lines;
	long TopLine;
	long SrcDepth;

@{b}	FUNCTION@{ub}

	Converts bit plane data from the supplied bitplanes into OpalVision memory format and stores this in the
	OpalScreen supplied.

	The source data will be clipped if it is wider than the destination screen, or will be padded out if it is
	narrower.

@{b}	INPUTS@{ub}
	OScrn	= Destination OpalScreen.
	SrcPlanes	= A pointer to an array of pointers to source Bitplanes.
	SrcWidth	= Byte width of source planes (must be even).
	Lines	= Number of lines to convert.
	TopLine 	= Starting line to place destination data.
	SrcDepth	= The number of bitplanes in SrcPlanes.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	All bitplanes must start on a word boundary, and SrcWidth must be even.

@{b}	SEE ALSO@{ub}
	@{"OVtoBitPlane()" Link "OVtoBitPlane()"}

@EndNode

@Node "ClearDisplayBottom24()" "opal.library/ClearDisplayBottom24"

@{b}	NAME@{ub}
	ClearDisplayBottom24 -- Clears the OpalVision display bottom setting.

@{b}	SYNOPSIS@{ub}
	void ClearDisplayBottom24 (void)

@{b}	FUNCTION@{ub}
	Remove the OpalVision display bottom previously set with a call to @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}

@EndNode

@Node "ClearPFStencil24()" "opal.library/ClearPFStencil24"

@{b}	NAME@{ub}
	ClearPFStencil24 -- Clears the PlayField Stencil of the specified screen.

@{b}	SYNOPSIS@{ub}
	void ClearPFStencil24 (OScrn);
				A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	Clears the playfield stencil (least significant bit of green bank 0) of all of the pixels in the specified
	screen.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen structure.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This will only have a visible effect if Dual Playfield mode has been set up using DualPlayField24().

@{b}	SEE ALSO@{ub}
	@{"SetPFStencil24()" Link "SetPFStencil24()"}
	DualPlayField24()
	@{"SinglePlayField24()" Link "SinglePlayField24()"}

@EndNode

@Node "ClearPRStencil24()" "opal.library/ClearPRStencil24"

@{b}	NAME@{ub}
	ClearPRStencil24 -- Clears the Priority Stencil of the specified @{"Screen" Link "TEXT_INCLUDE:intuition/screens.h/Main" 97}.

@{b}	SYNOPSIS@{ub}
	void ClearPRStencil24 (OScrn);
				A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	Clears the priority stencil (least significant bit of blue bank 0) of the all of the pixels in the specified
	screen.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen structure.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This will only have a visible effect if dual OpalVision/Amiga display mode has been set up using
	@{"DualDisplay24()" Link "DualDisplay24()"}.

@{b}	SEE ALSO@{ub}
	@{"SetPRStencil24()" Link "SetPRStencil24()"}
	@{"DualDisplay24()" Link "DualDisplay24()"}
	@{"SingleDisplay24()" Link "SingleDisplay24()"}

@EndNode

@Node "ClearQuick24()" "opal.library/ClearQuick24"

@{b}	NAME@{ub}
	ClearQuick24 -- Clears OpalVision frame buffer memory.

@{b}	SYNOPSIS@{ub}
	void ClearQuick24 (void)

@{b}	FUNCTION@{ub}
	This function clears the frame buffer memory as quickly as possible by enabling a write to all banks of
	memory. This function will also zero all bitplanes in memory (see ClearScreen24()). This operation will
	take 1 frame to clear any resolution non-interlaced display, and 2 frames for an interlaced display.This
	function  acts on the current display screen and cannot be used for virtual screens.

	This function is called by OpenScreen24.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"ClearScreen24()" Link "ClearScreen24()"}

@EndNode

@Node "ClearScreen24()" "opal.library/ClearScreen24"

@{b}	NAME@{ub}
	ClearScreen24 -- Clears all bitplanes in a screen.


@{b}	SYNOPSIS@{ub}
	void ClearScreen24 (OScrn)
			    A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	Clear all bitplanes contained in the OpalScreen structure which may be a virtual screen or the display
	screen.

	This function clears the bitplane memory without updating the frame buffer (unless frame buffer updates
	are enabled).

@{b}	INPUTS@{ub}
	OScrn = Pointer to the Opal screen to be cleared.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"ClearQuick24()" Link "ClearQuick24()"}
@EndNode

@Node "CloseScreen24()" "opal.library/CloseScreen24"

@{b}	NAME@{ub}
	CloseScreen24 -- Stop current display and free resources.

@{b}	SYNOPSIS@{ub}
	void CloseScreen24 (void);

@{b}	FUNCTION@{ub}
	This function closes the current displayed screen if it was opened by the current task.

	A screen opened by another task can be closed if it was opened with the CLOSEABLE24 flag. Backdrop
	and other low priority programs should use the following procedure to open screen.

		OScrn = OpenScreen24 (CLOSEABLE24);
			.
			.
			.
			.
		if (OScrn!=NULL)
			{ @{"WaitPort" Link "exec/WaitPort()"} (OScrn->UserPort);
			   CloseScreen24();
			   Mesg = @{"GetMsg" Link "exec/GetMsg()"} (OScrn->UserPort);
			   @{"ReplyMsg" Link "exec/ReplyMsg()"} (Mesg);
			}

	The task will be sent a message when another task is trying to open a screen or close down the one
	already open. Note that the screen MUST be closed before replying to the message.

	An alternative method to create a backdrop is to update the frame buffer, latch the 24 bit display using
	@{"LatchDisplay24()" Link "LatchDisplay24()"} and then call CloseScreen24(). The contents of the frame buffer will remain visible
	until another task calls @{"OpenScreen24()" Link "OpenScreen24()"}.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}

	@{"OpenScreen24()" Link "OpenScreen24()"}
@EndNode

@Node "Config24()" "opal.library/Config24"

@{b}	NAME@{ub}
	Config24 --	Returns the OpalVision hardware configuration.

@{b}	SYNOPSIS@{ub}
	Config = Config24 (void);
	D0

	long Config;

@{b}	FUNCTION@{ub}
	Returns flags indicating the hardware configuration of the 24bit display card, future flags  will give
	details on the existence of OpalVision modules such as the Video Roaster Chip and the frame grabber
	genlock module.

	Current return flags are:

		OVCF_OPALVISION - Display board is an OpalVision card.
		OVCF_COLORBURST - Display board is a ColorBurst.

@{b}	INPUTS@{ub}


@{b}	RESULT@{ub}


@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}

@EndNode

@Node "CreateScreen24()" "opal.library/CreateScreen24"

@{b}	NAME@{ub}
	CreateScreen24 -- Creates an arbitrarily sized virtual OpalScreen.

@{b}	SYNOPSIS@{ub}
	OScrn = CreateScreen24 (ScreenModes,Width,Height)
				D0	    D1	  D2

	struct OpalScreen *OScrn;
	long Width;
	long Height;
	long ScreenModes;

@{b}	FUNCTION@{ub}
	This function can create an arbitrarily sized OpalScreen in Fast Ram. The bitplanes for the screen are
	allocated and an OpalScreen structure initialised, this is the virtual screen equivalent of @{"OpenScreen24()" Link "OpenScreen24()"}.

	Once this screen has been opened, all drawing, file and Memory conversion functions can be applied to
	this screen, however it cannot be directly displayed. This allows large super bitmap screens to be
	allocated in fast ram for manipulation, or to be partially copied to a primary OpalScreen in chip ram for
	display (to allow for scrolling).

	NOTE: Virtual screens are now  displayable using the LowMemUpdate() function, virtual screens are
	therefore recommended when doing one off frame buffer updates (such as the Show24 command) as it
	significantly reduces the chip ram requirements

@{b}	INPUTS@{ub}
	Width	      = Width in pixels of the screen to be opened.
	Height	      = Height in pixels of the screen to be opened.
	ScreenModes = ScreenModes are identical to those of @{"OpenScreen24()" Link "OpenScreen24()"}.

@{b}	RESULT@{ub}
	OScrn	= Is a pointer to the new OpalScreen structure or NULL if there is insufficient memory
		to open the screen size specified.

@{b}	CONSIDERATIONS@{ub}
	This function allocates memory with no MEMF_ bits set, the program FastMemFirst should be executed
	to force all planes to be loaded into fast ram, under AmigaDOS 1.3 or previous.

@{b}	SEE ALSO@{ub}
	@{"FreeScreen24()" Link "FreeScreen24()"}
	OpenScreeen24()

@EndNode

@Node "DisablePRStencil24()" "opal.library/DisablePRStencil24"

@{b}	NAME@{ub}
	DisablePRStencil24 -- Disables the use of the priority stencil in dual display mode.

@{b}	SYNOPSIS@{ub}
	void DisablePRStencil24 (void);

@{b}	FUNCTION@{ub}
	This function clears the PRISTENCIL bit of all CoPro instructions.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set using @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}, the CoPro instructions will not be
	modified for that part of the display.

	The priority stencil will only have an effect when a Dual Display is enabled by calling @{"DualDisplay24()" Link "DualDisplay24()"}.

@{b}	SEE ALSO@{ub}
	EnablePRStencil()
	@{"DualDisplay24()" Link "DualDisplay24()"}
	@{"SingleDisplay24()" Link "SingleDisplay24()"}

@EndNode

@Node "DisplayFrame24()" "opal.library/DisplayFrame24"

@{b}	NAME@{ub}
	DisplayFrame24 -- Sets the currently displayed frame within the frame buffer memory.

@{b}	SYNOPSIS@{ub}
	void DisplayFrame24 (Frame);
			     D0

	long Frame;

@{b}	FUNCTION@{ub}
	Depending on the resolution of the displayed OpalVision screen, a number of screens can be stored in the
	frame buffer memory. The number of frames available for the screens resolution are given in the
	MaxFrames field in the OpalScreen structure.

	DisplayFrame24() allows each individual frame to be displayed separately where Frame is in the range
	0...MaxFrames. Using a combination of WriteFrame24 and DisplayFrame24, it is possible to store
	several images in frame buffer memory and to perform simple page flip animation.

@{b}	INPUTS@{ub}
	Frame	= Frame number to display (0...MaxFrames).

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	The display frame and the write frame, must reside in the same field area in the frame buffer memory.
	(See "Memory Segment Diagram"). Due to this DisplayFrame24() has the side effect of changing the
	write frame if the new display frame is in a different field.

@{b}	SEE ALSO@{ub}
	@{"WriteFrame24()" Link "WriteFrame24()"}

@EndNode

@Node "DisplayThumbnail24()" "opal.library/DisplayThumbnail24"

@{b}	NAME@{ub}
	DisplayThumbnail24 -- Displays a file's thumbnail.

@{b}	SYNOPSIS@{ub}
	ReturnCode = DisplayThumbnail24 (OScrn, FileName, x, y);
	D0				 A0	A1	  D0 D1

	long ReturnCode;
	struct OpalScreen *OScrn;
	char *FileName;
	long x;
	long y;

@{b}	FUNCTION@{ub}
	This function displays the imbedded thumbnail in the file described by FileName if it exists.

	The x coordinate is rounded down to the nearest multiple of four in low resolution mode and to the
	nearest multiple of 8 in high resolution mode. The y coordinate is rounded down to the nearest even line
	in interlaced mode.

@{b}	INPUTS@{ub}

	OScrn	= Pointer to an OpalScreen structure.
	FileName= The file name of the picture file with the thumbnail.
	x	= The x coordinate of the  screen position to display the thumbnail.
	y	= The y coordinate of the screen position to display the thumbnail.

@{b}	RESULT@{ub}
	ReturnCode	= OL_ERR Codes described in Opallib.h.
	OL_ERR_NOTHUMBNAIL is returned if no thumbnail exists in the file.

@{b}	CONSIDERATIONS@{ub}
	Thumbnails must always be displayed in low resolution non interlaced mode. For an example of
	displaying thumbnails in a high resolution and interlaced screen, see the example program
	"DisplayDir.c"

@{b}	SEE ALSO@{ub}
	@{"WriteThumbnail24()" Link "WriteThumbnail24()"}
	@{"SaveIFF24()" Link "SaveIFF24()"}

@EndNode

@Node "DrawEllipse24()" "opal.library/DrawEllipse24"

@{b}	NAME@{ub}
	DrawEllipse24 -- Draw an ellipse of given dimensions.

@{b}	SYNOPSIS@{ub}
	void DrawEllipse24 (OScrn,  cx,  cy,  a,  b)
			    A0	    D0	 D1   D2  D3

	struct OpalScreen *OScrn;
	long cx;
	long cy;
	long a;
	long b;

@{b}	FUNCTION@{ub}
	Draws an ellipse in the supplied screen.

	NOTE: set a=b for circles.

@{b}	INPUTS@{ub}

	OScrn	= Destination OpalScreen.
	cx	= Centre x-Coordinate of ellipse.
	cy	= Centre y-Coordinate of ellipse.
	a	= horizontal radius of ellipse (must be >0).
	b	= vertical radius of ellipse (must be >0).

@{b}	RESULT@{ub}

@{b}	CONSIDERATIONS@{ub}
	The ellipse will only be rendered in the region specified by the clip region in the screen structure.

@{b}	SEE ALSO@{ub}

@EndNode

@Node "DrawLine24()" "opal.library/DrawLine24"

@{b}	NAME@{ub}
	DrawLine24 -- Draws a line into an OpalScreen.

@{b}	SYNOPSIS@{ub}
	void DrawLine24 (OScrn, x1, y1, x2, y2)
			 A0	D0  D1	D2  D3

	struct OpalScreen *OScrn;
	long x1;
	long y1;
	long x2;
	long y2;

@{b}	FUNCTION@{ub}
	Draws a line in the specified screen structure which may be a virtual or display screen.

	In 24bit mode the colour of the line is specified by the Pen_R, Pen_G and Pen_B fields in the OpalScreen
	structure. In 15bit mode, Pen_R and Pen_G specify the colour of the line, while in 8bit only Pen_R is
	used.

@{b}	INPUTS@{ub}
	OScrn	= The OpalScreen structure in which to draw.
	x1, y1	= The starting co-ordinates of the line.
	x2, y2	= The ending co-ordinates of the line.

@{b}	RESULT@{ub}


@{b}	CONSIDERATIONS@{ub}
	The line will only be rendered in the region specified by the clip region in the screen structure.

@{b}	SEE ALSO@{ub}

@EndNode

@Node "DualDisplay24()" "opal.library/DualDisplay24"

@{b}	NAME@{ub}
	DualDisplay24 -- Sets up an Amiga/OpalVision dual display.

@{b}	SYNOPSIS@{ub}
	void DualDisplay24 (void);

@{b}	FUNCTION@{ub}
	This function clears the DUALDISPLAY bit of all CoPro instructions, enabling a Dual
	Amiga/OpalVision display. The priority of the Amiga/OpalVision graphics can be set with @{"OVPriority()" Link "OVPriority()"}
	and @{"AmigaPriority()" Link "AmigaPriority()"}.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set, using the @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"} the CoPro instructions will not
	be modified for that region of the display.

@{b}	SEE ALSO@{ub}
	@{"SingleDisplay24()" Link "SingleDisplay24()"}
	@{"AmigaPriority()" Link "AmigaPriority()"}
	@{"OVPriority()" Link "OVPriority()"}

@EndNode

@Node "DualPlayField2()" "opal.library/DualPlayField2"

@{b}	NAME@{ub}
	DualPlayField24 -- Sets up an OpalVision 24bit dual playfield.

@{b}	SYNOPSIS@{ub}
	void DualPlayField (void)

@{b}	FUNCTION@{ub}
	This function sets the DUALPLAYFIELD bit of all CoPro instructions, allowing a dual 24 bit overlay
	mode. To determine which bank is displayed for each pixel, the playfield stencil needs to be set
	accordingly.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set using @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}, the coprocessor instructions will
	not be modified for that region of the display.

@{b}	SEE ALSO@{ub}
	@{"SinglePlayField24()" Link "SinglePlayField24()"}
@EndNode

@Node "EnablePRStencil24()" "opal.library/EnablePRStencil24"

@{b}	NAME@{ub}
	EnablePRStencil24 -- Enables the use of the priority stencil in dual display mode.

@{b}	SYNOPSIS@{ub}
	void EnablePRStencil24 (void);

@{b}	FUNCTION@{ub}
	This function set the PRISTENCIL bit of all CoPro instructions.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set using @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}, the CoPro instructions will not be
	modified for that part of the display.

	The priority stencil will only have an effect when a Dual Display is enabled by calling @{"DualDisplay24()" Link "DualDisplay24()"}.

@{b}	SEE ALSO@{ub}
	DisablePRStencil()
	@{"DualDisplay24()" Link "DualDisplay24()"}
	@{"SingleDisplay24()" Link "SingleDisplay24()"}

@EndNode

@Node "FadeIn24()" "opal.library/FadeIn24"

@{b}	NAME@{ub}
	FadeIn24 -- Fades display in from black.

@{b}	SYNOPSIS@{ub}
	void FadeIn24 (Time);
			D0

	long Time;

@{b}	FUNCTION@{ub}
	Fade the current display from black to true colour.

	The Time parameter specifies the amount of time in 1/100 seconds the fade should take and is
	independent of PAL or NTSC refresh rates.

@{b}	INPUTS@{ub}
	Time = Time in 1/100 seconds to complete fade.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This function cannot be used in 15bit mode.

@{b}	SEE ALSO@{ub}
	@{"FadeOut24()" Link "FadeOut24()"}
@EndNode

@Node "FadeOut24()" "opal.library/FadeOut24"

@{b}	NAME@{ub}
	FadeOut24 -- Fade display to black.

@{b}	SYNOPSIS@{ub}
	void FadeOut24 (Time)
			D0
	long Time;

@{b}	FUNCTION@{ub}
	Fade the current display from true colour to black.

	The Time parameter specifies the amount of time the fade should take and is independent of PAL or
	NTSC machines.

@{b}	INPUTS@{ub}
	Time = Number of 1/100ths seconds in which to complete the fade.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This function cannot be used in 15bit mode.

@{b}	SEE ALSO@{ub}
	@{"FadeIn24()" Link "FadeIn24()"}
@EndNode

@Node "FreeScreen24()" "opal.library/FreeScreen24"

@{b}	NAME@{ub}
	FreeScreen24 -- Frees a virtual OpalScreen.

@{b}	SYNOPSIS@{ub}
	void FreeScreen24 (OScrn);
			   A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	This function deallocates all memory associated with a virtual screen. This is the virtual screen
	equivalent of CloseScreen24.

@{b}	INPUTS@{ub}
	OScrn	= A pointer to the virtual screen to be freed

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"CreateScreen24()" Link "CreateScreen24()"}
	@{"CloseScreen24()" Link "CloseScreen24()"}

@EndNode

@Node "FreezeFrame24()" "opal.library/FreezeFrame24"

@{b}	NAME@{ub}
	FreezeFrame24 -- Freezes the currently displayed screen.

@{b}	SYNOPSIS@{ub}
	void FreezeFrame24 (Freeze);
			    D0
	BOOL Freeze

@{b}	FUNCTION@{ub}
	This function freezes the current display. If freeze is TRUE, the display is held static. The display is
	returned to normal when the value for freeze is FALSE.

	Freeze freezes everything on the display including Amiga graphics.

@{b}	INPUTS@{ub}
	Freeze	= TRUE (1) = Freeze, FALSE (0) = Unfreeze

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This functions is available only while a Scan Rate Converter is present.

@{b}	SEE ALSO@{ub}

@EndNode

@Node "ILBMtoOV()" "opal.library/ILBMtoOV"

@{b}	NAME@{ub}
	ILBMtoOV -- Converts interleaved bitmap to OpalVision format.

@{b}	SYNOPSIS@{ub}
	void ILBMtoOV (OScrn, ILBMData, SrcWidth, Lines, TopLine, SrcPlanes)
			A0    A1	D0	  D1	 D2	  D3

	struct OpalScreen *OScrn;
	UBYTE *ILBMData;
	long SrcWidth;
	long Lines;
	long TopLine;
	long SrcPlanes;

@{b}	FUNCTION@{ub}
	Converts interleaved bitmap memory into OpalVision memory format and stores this in the OpalScreen
	supplied.

	The source data will be clipped if it is wider than the destination screen, or will be padded out if it is
	narrower.

	This function is provided to simplify the task of writing a custom IFF loader.

@{b}	INPUTS@{ub}
	OScrn		= Destination OpalScreen.
	ILBMData	= interleaved planes of source data.
	SourceWidth	= Width of source ILBM data.
	Lines		= Number of lines to convert.
	TopLine 	= Starting line to place destination data.
	SrcPlanes	=The number of planes contained in the ILBM data.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"OVtoILBM()" Link "OVtoILBM()"}
@EndNode

@Node "LatchDisplay24()" "opal.library/LatchDisplay24"

@{b}	NAME@{ub}
	LatchDisplay24 -- Locks OpalVision  display

@{b}	SYNOPSIS@{ub}
	void LatchDisplay24 (Latch)

	BOOL Latch;

@{b}	FUNCTION@{ub}
	LatchDisplay24 sets or clears the Latch bit in the control line register. If this bit is set,  the OpalVision
	display will remain active regardless of whether there is a valid control line in the Amigas' output. If
	@{"CloseScreen24()" Link "CloseScreen24()"} is called after the latch bit is set, all memory and resources will be freed but the display
	will still be active, even if the Amiga is reset.

	OpalHotKey uses this technique, images are loaded and updated into the buffer, latched and then the
	screen is closed. If any register information needs to be changed, such as changing display priority a
	display screen is opened using the CONTROLONLY24 flag which enables registers to be changed
	without effecting the contents of the frame buffer.

@{b}	INPUTS@{ub}
	Latch	= 0 = Free display, 1 = Latch display.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}

@EndNode

@Node "LoadImage24()" "opal.library/LoadImage24"

@{b}	NAME@{ub}
	LoadImage24 / LoadIFF24 -- Loads an @{"Image" Link "TEXT_INCLUDE:intuition/intuition.h/Main" 621} file.

@{b}	SYNOPSIS@{ub}
	ReturnCode = LoadImage24 (OScrn,FileName,Flags)
	D0			  A0	A1	 D0

	long ReturnCode;
	struct OpalScreen *OScrn;
	long Flags;
	char *FileName;

@{b}	FUNCTION@{ub}
	Load an IFF or JPEG file.

	This is a general purpose image loading routine which will automatically detect and load IFF and JPEG
	files. As this is a general loader, the name of this function has been renamed to LoadImage24(), which is
	used as a synonym for the previous function name LoadIFF24() to maintain backward compatibility.

	The IFF portion of this loader will load IFF 24bit, Fast Format 24 bit, Palette mapped (up to 256 colours),
	Hold and Modify and Extra half brite files.

	All palette mapped files will be loaded in the 8 bit palette mapped mode unless the CONVERT24 flag is
	set, in which case they will be converted to a non palette mapped 24 bit display.

	There are several different forms in which LoadImage24 can load an image. The way in which it
	functions is dependant on the specified screen and the flags. If the screen pointer is NULL then
	LoadImage24 will open a screen itself, the screen it opens will be a display screen unless
	VIRTUALSCREEN24 is set in which case a virtual screen will be created.

	If the passed screen structure is not NULL and the image being loaded is the same resolution, then it will
	be loaded into that screen. If this is not the case then the screen will be closed and a new screen of the
	same resolution as the file will be opened. However if KEEPRES24 is set, the file will be loaded into the
	supplied screen regardless of its resolution.

	LoadImage24 returns one of two things. If the files was loaded successfully, a pointer to the screen into
	which it was loaded is returned. If an error occurred, then an error code will be returned. To determine
	which of these messages has been returned, the value can be compared to OL_ERR_MAXERR, if it is
	lower than this value then the result is an error code, if it is greater than this number then it is a screen
	pointer. If the image is not IFF or JPEG, OL_ERR_FORMATUNKOWN is returned.

	Flags:
		FORCE24 	-  Convert palette mapped files to 24 bit.
		KEEPRES24		-  Keep the same screen resolution.
		CLOSEABLE24		-  Opened screen will be closeable.
		LOADMASK24		-  Load mask plane if present (IFF only).
		VIRTUALSCREEN24 -  Load image into a virtual screen.

	The JPEG loader is a baseline loader as specified in the draft standard ISO/IEC Bis 10918-1 it supports
	only 8 bit quantization tables and Huffman entropy compression. It can load files with source colour
	space of Y Cb Cr, RGB and Grey scale. It does not support non interleaved files, progressive, hierarchical
	or lossless modes.

@{b}	INPUTS@{ub}
	FileName	= Filename of image to be display (including path).
	Flags		= see above.

@{b}	RESULT@{ub}
	ReturnCode = > OL_ERR_MAXERR Return code is a pointer to an Opal screen structure.
	ReturnCode = < OL_ERR_MAXERR, Return code indicates error.

@{b}	CONSIDERATIONS@{ub}
	This function only loads an image, it does not update the frame buffer. To do this you must call
	@{"Refresh24()" Link "Refresh24()"} or @{"LowMemUpdate24()" Link "LowMemUpdate24()"}.

@{b}	SEE ALSO@{ub}
	@{"SaveIFF24()" Link "SaveIFF24()"}
	@{"SaveJPEG24()" Link "SaveJPEG24()"}
	@{"Refresh24()" Link "Refresh24()"}
	@{"LowMemUpdate24()" Link "LowMemUpdate24()"}

@EndNode

@Node "LowMemUpdate24()" "opal.library/LowMemUpdate24"

@{b}	NAME@{ub}
	LowMemUpdate24 -- Low chip ram usage OpalVision update.

@{b}	SYNOPSIS@{ub}
	RetScrn = LowMemUpdate24 (OScrn, Frame);
	D0			  A0	 D0

	struct OpalScreen *RetScrn;
	struct OpalScreen *OScrn;
	long Frame;

@{b}	FUNCTION@{ub}
	Updates the frame buffer from a virtual screen. This function can update an entire image of any
	resolution while only using a small amount of chip ram. This routine uses an 8bit screen to update each
	memory segment separately, the CPU is used to copy the bitplane data from the virtual screen to chip
	ram. The 8bit plane display screen opened to perform the update is returned, and should be subsequently
	closed.

	The Frame input sets the first memory segment to be updated, this will normally be 0. This can be set to
	6 for example to update a lores screen to bank1  instead of bank0.

	NOTE:  OScrn must be a pointer to a virtual screen.

@{b}	INPUTS@{ub}
	OScrn	= The virtual OpalScreen to be displayed
	Frame	= Memory segment to start update (0..11).

@{b}	RESULT@{ub}
	RetScrn    >= OL_ERR_MAXERR Return code is a pointer to an Opal screen structure.
	RetScrn   < OL_ERR_MAXERR, Return code indicates error.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}
	@{"LowMem2Update24()" Link "LowMem2Update24()"}

@EndNode

@Node "LowMem2Update24()" "opal.library/LowMem2Update24"

@{b}	NAME@{ub}
	LowMem2Update24 -- Low chip ram usage OpalVision update.

@{b}	SYNOPSIS@{ub}
	RetScrn = LowMem2Update24 (OScrn, Frame);
	D0			   A0	  D0

	struct OpalScreen *RetScrn;
	struct OpalScreen *OScrn;
	long Frame;

@{b}	FUNCTION@{ub}
	Updates the frame buffer from a virtual screen. This function can update an entire image of any
	resolution while only using a small amount of chip ram. This routine uses an 8bit screen to update each
	memory segment separately, the CPU is used to copy the bitplane data from the virtual screen to chip
	ram. The 8bit plane display screen opened to perform the update is returned, and should be subsequently
	closed.

	The Frame input sets the first memory segment to be updated, this will normally be 0. This can be set to
	6 for example to update a lores screen to bank1  instead of bank0.

	This function is similar to @{"LowMemUpdate24()" Link "LowMemUpdate24()"} although it only updates the frame buffer memory, it does
	not modify the display modes,  CoPro bits or palette information. This is very useful for performing
	transitions  between two images in lores, the first image can be written into bank1 and displayed using
	LowMemUpdate24(OScrn,6), the second image is then updated transparently into bank0 using
	LowMem2Update24(OScrn,0). The dual display stencil can then be used to perform the transition
	between bank1 and bank0. Note that bank0 is written to last , as only bank0 contains the dual display
	stencil.

	NOTE:  OScrn must be a pointer to a virtual screen.

@{b}	INPUTS@{ub}
	OScrn	= The virtual OpalScreen to be displayed
	Frame	= Memory segment to start update (0..11).

@{b}	RESULT@{ub}
	RetScrn    >= OL_ERR_MAXERR Return code is a pointer to an Opal screen structure.
	RetScrn   < OL_ERR_MAXERR, Return code indicates error.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}
	@{"LowMemUpdate24()" Link "LowMemUpdate24()"}

@EndNode

@Node "LowMemRGB24()" "opal.library/LowMemRGB24"

@{b}	NAME@{ub}
	LowMemRGB24 -- Low chip ram usage OpalVision update from an RGB array.

@{b}	SYNOPSIS@{ub}
	RetScrn = LowMemRGB24 (ScreenModes, Frame, Width, Height, Modulo, RGBPlanes);
	D0			D0	    D1	   D2	  D3	  D4	  A0

	struct OpalScreen *RetScrn;
	long ScreenModes,Frame,Width,Height,Modulo;
	UBYTE *RGBPlanes[3]

@{b}	FUNCTION@{ub}

	Updates the frame buffer from RGB byte planes. This function can update an entire image of any
	resolution while only using a small amount of chip ram. This routine uses an 8bit screen to update each
	memory segment separately, the RGB data is converted into bitplane format one segment at a time and
	transferred into the framebuffer. The 8bit plane display screen opened to perform the update is returned,
	and should be subsequently closed.

	The Modulo parameter allows interleaved RGB data to be updated as well, in this case RGBPlanes would
	be initialised 'Width' bytes apart, and modulo would be set to 2*Width.

	This function is useful for image processing programs such as ADPro and Imagemaster which store
	images in byte planes.

@{b}	INPUTS@{ub}
	ScreenModes	= See OpenScreen24, these flags enable the resolution and format of the
			   displayed image to be set.
	Frame		= The memory segment to start the update, (0..1)
	Width		= Width of the RGB Array (in pixels).
	Height		= Height of the RGB Array.
	Modulo		= Modulo to be added after each line in the RGB Array.
	RGBPlanes	= Pointers to the three byte planes required (R,G,B).

@{b}	RESULT@{ub}
	RetScrn    >= OL_ERR_MAXERR Return code is a pointer to an Opal screen structure.
	RetScrn   < OL_ERR_MAXERR, Return code indicates error.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}

@EndNode

@Node "OpenScreen24()" "opal.library/OpenScreen24"

@{b}	NAME@{ub}
	OpenScreen24 -- Allocates all resources and displays an OpalVision screen.

@{b}	SYNOPSIS@{ub}
	OScrn = OpenScreen24 (ScreenModes)
	D0		      D0

	struct OpalScreen *OScrn;
	long ScreenModes;

@{b}	FUNCTION@{ub}
	This function creates a display screen and allocates all the resources required to display the screen. The
	Frame buffer memory is cleared and updates are disabled to the frame buffer memory.

	The screen is positioned according to Amiga preferences, however if the vertical starting position defined
	in preferences is too high up, preferences will be modified to set the vertical starting position to the
	highest possible, the preferences will be restored when the screen is closed.

	The screen will be opened as single playfield, single display mode with OVPriority.

	If the CONTROLONLY24 flag is set, the screen will be opened without any bitplanes,  this enables the
	copro or palette information of a 'latched on'  to be modified without losing the contents of the frame
	buffer.

	ScreenModes:
		INTERLACE24	- Open an interlaced screen.
		HIRES24 	- Open a Hires screen.
		OVERSCAN24	- Open an overscan screen.
		PLANES15	- 15 bit true colour display.
		PLANES8 	- 8 bit true colour/palette mapped display.
		CLOSEABLE24	- @{"Screen" Link "TEXT_INCLUDE:intuition/screens.h/Main" 97} can be closed by another task.
		PALMAP24	- Open a palette mapped screen.
		CONTROLONLY24	- Open a bitplaneless screen.

	@{"Screen" Link "TEXT_INCLUDE:intuition/screens.h/Main" 97} Sizes:

		Hires	Interlaced	Overscan	PAL	NTSC
		No	No		No		320x256 320x200
		Yes	No		No		640x256 640x200
		No	Yes		No		320x512 320x400
		Yes	Yes		No		640x512 640x400

	The size of the screen opened will be as specified above unless there is not enough chip ram available, in
	which case the maximum amount of lines possible will be displayed. If there is insufficient chip memory,
	to hold half of the scan lines, then @{"OpenScreen" Link "intuition/OpenScreen()"} will be aborted and NULL returned. If the PLANES8 or
	PLANES15 flag is not set, a 24 bit screen will be opened.

@{b}	INPUTS@{ub}
	ScreenModes	=  See above.

@{b}	RESULT@{ub}
	OScrn	=  A pointer to an OpalScreen structure or NULL if unsuccessful.

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"CloseScreen24()" Link "CloseScreen24()"}
	@{"LatchDisplay24()" Link "LatchDisplay24()"}

@EndNode

@Node "OVPriority()" "opal.library/OVPriority"


@{b}	NAME@{ub}
	OVPriority -- Give OpalVision graphics priority over Amiga graphics.

@{b}	SYNOPSIS@{ub}
	void OVPriority (void);

@{b}	FUNCTION@{ub}
	This function sets the OVPRI bit of all coprocessor instructions which gives OpalVision graphics priority
	over Amiga graphics. If a dual display has not been set, only OpalVision graphics will be visible.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set using @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"}, the coprocessor instructions will
	not be modified for that region of the display.

@{b}	SEE ALSO@{ub}
	AmigaPriority24()
	@{"DualDisplay24()" Link "DualDisplay24()"}

@EndNode

@Node "OVtoBitPlane()" "opal.library/OVtoBitPlane"

@{b}	NAME@{ub}
	OVtoBitPlane -- Convert OpalVision bit plane data to standard bitplanes.

@{b}	SYNOPSIS@{ub}
	void OVtoBitPlane (OScrn, BitPlanes, DestWidth, Lines, TopLine)
			   A0	  A1	     D0 	D1     D2

	struct OpalScreen *OScrn;
	UBYTE **BitPlanes[];
	long DestWidth;
	long Lines;
	long TopLine;

@{b}	FUNCTION@{ub}
	Converts OpalVision bitplane format to standard bitplane data. The destination data will be non-
	interleaved 24, 15 or 8 planes depending on the type of display OScrn is. Note that the 15bit display
	mode is actually stored internally as 16 bitplanes which in turn causes this function to return 16 planes
	instead of 15.

	DestWidth specifies the width of the destination bitplanes, if the width is less than the source planes, they
	will be clipped. If the destination width is larger, the remaining bytes on each scan line will be skipped.

	The OpalScreen can be any size, and reside in fast or chip ram.

	The array of bitplane pointers passed to this function must contain 8, 16 or 24 entries depending on the
	screen type.

@{b}	INPUTS@{ub}
	OScrn		= OpalScreen structure describing source data.
	BitPlanes	= Array of bitplane pointers to take the destination data.
	DestWidth	= Width in bytes of destination planes (must be even).
	Lines		= Total number of scan lines to convert.
	TopLine 	= Starting line for conversion within the OpalScreen.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	All bitplanes must be on a word boundary and the destination width must be even.

@{b}	SEE ALSO@{ub}
	BitplanetoOV()

@EndNode

@Node "OVtoILBM()" "opal.library/OVtoILBM"

@{b}	NAME@{ub}
	OVtoILBM -- Converts OpalVision bit planes to interleaved bitmap format.

@{b}	SYNOPSIS@{ub}
	void OVtoILBM (OScrn, ILBMData, DestWidth, Lines, TopLine)
			A0    A1	D0	   D1	  D2

	struct OpalScreen *OScrn;
	UBYTE *ILBMData;
	long DestWidth;
	long Lines;
	long TopLine;

@{b}	FUNCTION@{ub}
	Converts bitplane information from the supplied OpalScreen, starting at the scan line indicated by
	TopLine, into interleaved bitmap format.

	If the source OpalScreen is wider than the destination width, the planes will be clipped. If the OpalScreen
	is narrower, the extra bytes on each line will be skipped. The OpalScreen can be any size, and reside in
	fast or chip ram.

	The memory pointed to by ILBMData must be large enough to hold
	DestWidth * lines * (8 or 16 or 24 depending on screen type) bytes.

@{b}	INPUTS@{ub}
	OScrn		= OpalScreen structure describing source data.
	ILBMData	= Pointer to buffer to hold destination ILBM data.
	DestWidth	= Width of destination ILBM planes. (must be even)
	Lines		= Total number of scan lines to convert.
	TopLine 	= Starting line for conversion within the OpalScreen.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	ILBMData must start on a word boundary, and DestWidth must be even.

@{b}	SEE ALSO@{ub}
	@{"ILBMtoOV()" Link "ILBMtoOV()"}

@EndNode

@Node "OVtoRGB()" "opal.library/OVtoRGB"

@{b}	NAME@{ub}
	OVtoRGB -- Converts OpalVision bitplane data to three planes of RGB.

@{b}	SYNOPSIS@{ub}
	void OVtoRGB (OScrn, RGBPlanes[], Top, Left, Width, Height)
		      A0     A1 	  D0   D1    D2     D3

	struct OpalScreen *OScrn;
	UBYTE **RGBPlanes[];
	long Top;
	long Left;
	long Width;
	long Height;

@{b}	FUNCTION@{ub}
	This call converts bitplane data from the OpalScreen into three planes, one containing Red, one Blue and
	the last Green, each of these has one byte per pixel. This is useful for making 'brush' cut-outs, or for
	subsequent scaling of data.

	This function is more flexible than the other memory conversion routines in that it can convert a
	rectangular region of bitplane memory positioned anywhere within the source screen.

	The OpalScreen can be any size, and reside in fast or chip ram.

@{b}	INPUTS@{ub}
	OScrn		= OpalScreen structure containing source bitplanes.
	RGBPlanes	= Pointer to an array of 3 plane pointers.
	Top		= x coordinate of top left hand corner to start conversion.
	Left		= y coordinate of top left hand corner to start conversion.
	Width		= Width in pixels of region to cut.
	Height		= Number of lines to cut.

@{b}	RESULT@{ub}


@{b}	CONSIDERATIONS@{ub}
	The destination planes must be on a word boundary.

@{b}	SEE ALSO@{ub}
	@{"RGBtoOV()" Link "RGBtoOV()"}

@EndNode

@Node "PaletteMap24()" "opal.library/PaletteMap24"

@{b}	NAME@{ub}
	PaletteMap24 -- Enable/Disable palette mapping.

@{b}	SYNOPSIS@{ub}
	PaletteMap24 (PaletteMap)
			D0

	BOOL PaletteMap;

@{b}	FUNCTION@{ub}
	If PaletteMap = TRUE, turn on palette mapping, else turn palette mapping off. This function always
	operates on the active display screen.

@{b}	INPUTS@{ub}
	PaletteMap = True to turn palette mapping on, to turn it off.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This function cannot be used in 15bit mode.

@{b}	SEE ALSO@{ub}
	SetPalette24()

@EndNode

@Node "ReadPFPixel24()" "opal.library/ReadPFPixel24"

@{b}	NAME@{ub}
	ReadPFPixel24 -- Returns the state of a give playfield stencil pixel.

@{b}	SYNOPSIS@{ub}
	Result = ReadPFPixel24 (OScrn,  x,  y)
	D0			A0	D0  D1

	long Result;
	struct OpalScreen *OScrn;
	long x;
	long y;

@{b}	FUNCTION@{ub}
	This function returns 1 if the corresponding playfield stencil pixel is set, or 0 if it is cleared. If the
	coordinates are outside of the clip boundary then -1 is returned.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to be read.
	x	= x Coordinate of pixel to read.
	y	= y Coordinate of pixel to read.

@{b}	RESULT@{ub}
	Result = 0 if pixel clear , or 1 if pixel set, -1 if pixel is out of range.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}
	@{"WritePFPixel24()" Link "WritePFPixel24()"}
	@{"ClearPFStencil24()" Link "ClearPFStencil24()"}
	@{"SetPFStencil24()" Link "SetPFStencil24()"}

@EndNode

@Node "ReadPixel24()" "opal.library/ReadPixel24"

@{b}	NAME@{ub}
	ReadPixel24 -- Returns colour information for a given pixel.

@{b}	SYNOPSIS@{ub}
	Error = ReadPixel24 (OScrn,  x,  y)
	D0		     A0      D0  D1

	long Error;
	struct OpalScreen *OScrn;
	long x;
	long y;

@{b}	FUNCTION@{ub}
	Return the colour (bit plane) information for a given pixel. If the OpalScreen is in palette mapped mode,
	the actual bit plane data (and not the corresponding palette value) will be returned.

	The returned value is placed in Red, Green and Blue in the OpalScreen structure while in 24bit modes. In
	15bit mode, the colour is returned in Red and Green, while in 8bit mode, the colour is returned in Red.
	The GetPen macros can be used to extract the components from the returned value.

	Use the macros GetCol24(), GetCol15(), GetCol8() or GetCol8P() for 8 bit palette mapped to return the
	pixel value.

	If the coordinates are outside the screen's clipping region, Error will be -1, else Error = 0.

	This function can operate on any sized screens in chip or fast ram.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to be read.
	x	= x Coordinate of pixel to read.
	y	= y Coordinate of pixel to read.

@{b}	RESULT@{ub}
	Error	= 0 if no error occurred, or -1 if pixel was out of the clipping region.

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}

@{"WritePixel24()" Link "WritePixel24()"}

@EndNode

@Node "ReadPRPixel24()" "opal.library/ReadPRPixel24"

@{b}	NAME@{ub}
	ReadPRPixel24 -- Returns the state of a give priority stencil pixel.

@{b}	SYNOPSIS@{ub}
	Result = ReadPRPixel24 (OScrn,  x,  y)
	D0			A0	D0  D1

	long Result;
	struct OpalScreen *OScrn;
	long x;
	long y;

@{b}	FUNCTION@{ub}
	This function returns 1 if the corresponding priority stencil pixel is set, or 0 if it is cleared. If the
	coordinates are outside of the clip boundary then -1 is returned.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to be read.
	x	= x Coordinate of pixel to read.
	y	= y Coordinate of pixel to read.

@{b}	RESULT@{ub}
	Result	= 0 if pixel clear , or 1 if pixel set, -1 if pixel is out of range.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}

	@{"WritePRPixel24()" Link "WritePRPixel24()"}
	@{"ClearPRStencil24()" Link "ClearPRStencil24()"}
	@{"SetPRStencil24()" Link "SetPRStencil24()"}

@EndNode

@Node "RectFill24()" "opal.library/RectFill24"

@{b}	NAME@{ub}
	RectFill24 -- Draws a solid rectangle.

@{b}	SYNOPSIS@{ub}
	void RectFill24 (OScrn, Left, Top, Bottom, Right)
			 A0	D0    D1   D2	   D3

	struct OpalScreen *OScrn;
	long Left;
	long Top;
	long Bottom;
	long Right;

@{b}	FUNCTION@{ub}
	Draws a solid rectangle with the colour specified by Pen_R,Pen_G & Pen_B in the OpalScreen structure.

	The @{"Rectangle" Link "TEXT_INCLUDE:graphics/gfx.h/Main" 28} is clipped if all or part of it lies outside the clipping region.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to be rendered into.
	Left	= x coordinate of top left-hand corner of the rectangle.
	Top	= y coordinate of top left-hand corner of the rectangle.
	Bottom	= x coordinate of the bottom right-hand corner of rectangle.
	Right	= y coordinate of the bottom right-hand corner of rectangle.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}

@EndNode

@Node "Refresh24()" "opal.library/Refresh24"

@{b}	NAME@{ub}
	Refresh24 -- Refreshes the frame buffer.

@{b}	SYNOPSIS@{ub}
	void Refresh24 (void)

@{b}	FUNCTION@{ub}
	Initiates DMA of the currently displayed OpalScreen to the framebuffer. This function will update the
	framebuffer in the minimum number of frames required, stop DMA (updates) and return.

	This function should be called after any drawing routine, and other routines such as LoadIFF24 which
	modify memory, to make the frame buffer (and hence display) consistent with the image in Amiga
	memory.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"UpdateDelay24()" Link "UpdateDelay24()"}
	@{"StopUpdate24()" Link "StopUpdate24()"}
	@{"UpdatePFStencil24()" Link "UpdatePFStencil24()"}
	@{"UpdateAll24()" Link "UpdateAll24()"}

@EndNode

@Node "RegWait24()" "opal.library/RegWait24"

@{b}	NAME@{ub}
	RegWait24 -- Wait for register update to complete.

@{b}	SYNOPSIS@{ub}
	void RegWait24 (void);

@{b}	FUNCTION@{ub}
	This function waits for register information to be updated to the OpalVision before returning, or returns
	immediately if no updates are pending.

	This function is important for synchronizing your program with the OpalVision's update scheme. After
	any direct modification of OpalVision registers or after a call to a library function which modifies
	registers, this function should be called to allow the update to occur, If this function is not called register
	data may be lost.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}

@EndNode

@Node "RGBtoOV()" "opal.library/RGBtoOV"

@{b}	NAME@{ub}
	RGBtoOV -- Converts three planes of RGB to OpalVision bitplane data.

@{b}	SYNOPSIS@{ub}
	void RGBtoOV (OScrn, RGBPlanes[], Top, Left, Width, Height)
		      A0     A1 	  D0   D1    D2     D3

	struct OpalScreen *OScrn;
	UBYTE **RGBPlanes[];
	long Top;
	long Left;
	long Width;
	long Height;

@{b}	FUNCTION@{ub}
	This call converts three source planes, one containing Red, one Blue and the last Green into OpalVision
	bitplane format. This function is useful for pasting clipped regions (using OVtoRGB) back into
	OpalVision memory, or for pasting back data after scaling.

	Unlike the other conversion routines, this function is clipped if it is outside of the clipping region, this
	enables it to be used as a drawing function rather than a conversion function.

	The OpalScreen can be any size, and reside in fast or chip ram.

@{b}	INPUTS@{ub}
	OScrn		= OpalScreen structure containing destination bitplanes.
	RGBPlanes	= Pointer to an array of 3 plane pointers.
	Top		= x coordinate of top left hand corner to start conversion.
	Left		= y coordinate of top left hand corner to start conversion.
	Width		= Width in pixels of region to cut.
	Height		= Number of lines to cut.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"OVtoRGB()" Link "OVtoRGB()"}

@EndNode

@Node "SaveIFF24()" "opal.library/SaveIFF24"

@{b}	NAME@{ub}
	SaveIFF24 -- Save an OpalScreen as an IFF file.

@{b}	SYNOPSIS@{ub}
	Error = SaveIFF24 (OScrn, FileName, ChunkFunction, Flags)
	D0		   A0	  A1	    A2		   D0

	long Error;
	struct OpalScreen *OScrn;
	char *FileName;
	long (*ChunkFunction)();
	long Flags;

@{b}	FUNCTION@{ub}

	SaveIFF24 will save any sized OpalScreen in normal IFF file format. The chunks written will include

		CAMG	- Containing the resolution  (Hires/Interlace/Overscan)
		CMAP	- Colour map if in 8bit mode.
		CLUT	- Colour lookup tables if in true colour mode.
		OVTN	- OpalVision 24bit thumb-nail for display in OpalPaint,
			  OpalShow and other system software.
		BODY	- Standard 24 bit ILBM data using byte run encoding.

	If ChunkFunction is not NULL, the function that it points at will be called after the file has been opened
	(and FORM ILBM has been written) and before any other chunks have been written. ChunkFunction is
	used to insert your own chunks into the IFF file before any of the above chunks. The DOS File Handle for
	the open file will be passed to the function on the stack (in standard C calling convention) the chunk
	function must return 0 or an error code.

	Flags:
		OVFASTFORMAT	- Save as OpalVision fast format.
		NOTHUMBNAIL	- @{"Inhibit" Link "dos/Inhibit()"} writing thumb-nail chunk.
		SAVEMASK24		- Saves mask plane if one exists.

@{b}	INPUTS@{ub}
	OScrn		= OpalScreen to be saved.
	FileName	= Filename of file to be written (including full path).
	ChunkFunction	= Pointer to code to be executed after file is opened.

@{b}	RESULT@{ub}
	Error	= 0 if no error code, >0 if error occurred.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}

	@{"LoadImage24()" Link "LoadImage24()"}
	@{"SaveJPEG24()" Link "SaveJPEG24()"}

@EndNode

@Node "SaveJPEG24()" "opal.library/SaveJPEG24"

@{b}	NAME@{ub}
	SaveJPEG24 -- Save an OpalScreen as a JPEG JFIF file.

@{b}	SYNOPSIS@{ub}
	Error = SaveJPEG24 (OScrn, FileName, Flags, Quality)
	D0		    A0	   A1	     D0     D1

	long Error;
	struct OpalScreen *OScrn;
	char *FileName;
	long Flags;
	long Quality;

@{b}	FUNCTION@{ub}
	SaveJPEG24 will save any sized OpalScreen in the JPEG JFIF file format. JPEG is a compression
	standard which enables a large amount of compression to be gained on continuous tone images with
	minimum loss in image quality. It should be stressed that this compression method is based on
	continuous tone images and compression of images with sharp edges may suffer more degradation. For
	more details see the JPEG draft  standard ISO/IEC Dis10918-1.

	This generates a base line JPEG file using interleaved components, Huffman entropy compression and 8
	bit quatization tables. A thumbnail will also be written into the APP0 marker of the JFIF file unless the
	NOTHUMBNAIL flag is set.

	The quality factor is a percentage value (0...100) which defines the allowable amount of loss in the
	compressed image. A factor of 100 corresponds to a quantization table of all 1's and hence has no
	quantization loss. A value of 50 corresponds to the quantization tables suggested by the draft standard as
	being acceptable for good image quality. A reasonable default value to use is 75, using this level for
	continuous tone scanned images a compression factor of	between 15:1 and 20:1 is typical.

	Flags:
		NOTHUMBNAIL	- @{"Inhibit" Link "dos/Inhibit()"} writing thumb-nail chunk.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to be saved.
	FileName= Filename of file to be written (including full path).
	Flags	= See above.
	Quality = (0...100) This determines the amount of loss allowed in the compression of
		   the image. 100 % corresponds to minimum loss.

@{b}	RESULT@{ub}
	Error		= 0 if no error code, >0 if error occurred.

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}

@{"LoadImage24()" Link "LoadImage24()"}

@EndNode

@Node "Scroll24()" "opal.library/Scroll24"

@{b}	NAME@{ub}
	Scroll24 -- Scrolls currently displayed OpalVision image.

@{b}	SYNOPSIS@{ub}
	void Scroll24 (DeltaX, DeltaY)
			D0     D1

	long DeltaX;
	long DeltaY;

@{b}	FUNCTION@{ub}
	This function scrolls the currently displayed image by DeltaX pixels horizontally, and DeltaY lines
	vertically, by modifying the video load address register in the OpalVision.

	DeltaX and DeltaY are signed values, to enable scrolling in all directions.

	This function also clears the ADDLOAD bit on the first CoPro instruction if it is not already cleared.

@{b}	INPUTS@{ub}
	DeltaX	= Number of pixels to scroll horizontally.
	DeltaY	= Number of lines to scroll vertically.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	For the Scroll to function correctly, update DMA to the framebuffer must be turned off by calling
	@{"StopUpdate24()" Link "StopUpdate24()"}.

@{b}	SEE ALSO@{ub}
	@{"SetLoadAddress24()" Link "SetLoadAddress24()"}

@EndNode

@Node "SetControlBit24()" "opal.library/SetControlBit24"

@{b}	NAME@{ub}
	SetControlBit24 -- Modifies a bit in the control line register.

@{b}	SYNOPSIS@{ub}
	void SetControlBit24 (FrameNumber, BitNumber, State)
			      D0	   D1	      D2

	long FrameNumber;
	long BitNumber;
	BOOL State;

@{b}	FUNCTION@{ub}
	Sets or clears a bit in the control line register. See "The Opal Control Line Register" for details.

	There are 14 different versions of the control line register used to update the maximum of 12 different
	memory segments. These differ by the state of the bank and field write enable bits. The frame number
	variable specifies which one of these registers should be updated, for bits such as AUTO or COL/CoPro a
	global change may be required (i.e. changing all 12 control lines).

		Frame Number		Description
		     0		Red Bank0, Field0 Update
		     1		Green Bank0, Field0 Update
		     2		Blue Bank0, Field0 Update
		     3		Red Bank0, Field1 Update
		     4		Green Bank0, Field1 Update
		     5		Blue Bank0, Field1 Update
		     6		Red Bank1, Field0 Update
		     7		Green Bank1, Field0 Update
		     8		Blue Bank1, Field0 Update
		     9		Red Bank1, Field1 Update
		     10 	Green Bank1, Field1 Update
		     11 	Blue Bank1, Field1 Update
		     12 	Field 0 Display only
		     13 	Field 1 Display only


@{b}	INPUTS@{ub}
	FrameNumber	= The OpalVision update frame number to modify. One frame corresponds to
			one bank update (maximum 12 frames, 2 noupdate lists).
	BitNumber	= Bit number within control line to modify (4...19).
	State		= State to be written into bit (Boolean).

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	These bits should be modified with caution.

@{b}	SEE ALSO@{ub}
	Control Line Register

@EndNode

@Node "SetCoPro24()" "opal.library/SetCoPro24"

@{b}	NAME@{ub}
	SetCoPro24 -- Modifies a single instruction in the CoPro list.

@{b}	SYNOPSIS@{ub}
	void SetCoPro24 (InstructionNumber, Instruction);
			 D0		    D1

	long InstructionNumber;
	long Instruction;

@{b}	FUNCTION@{ub}
	This function modifies a single CoPro instruction and initiates an update to the OpalVision CoPro. Note
	that this function is much faster than calling @{"UpdateCoPro24()" Link "UpdateCoPro24()"}.

@{b}	INPUTS@{ub}
	InstructionNumber	= The CoPro instruction number (0...289)
	Instruction		= 8Bit CoPro instruction. See "The CoPro"

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	InstructionNumber should be less than LastCoProIns in the OpalScreen structure.

@{b}	SEE ALSO@{ub}
	@{"UpdateCoPro24()" Link "UpdateCoPro24()"}

@EndNode

@Node "SetDisplayBottom24()" "opal.library/SetDisplayBottom24"

@{b}	NAME@{ub}
	SetDisplayBottom24 -- Sets the lower limit of the OpalVision screen.

@{b}	SYNOPSIS@{ub}
	Result = SetDisplayBottom24 (BottomLine);
					D0

	long BottomLine;
	BOOL Result;

@{b}	FUNCTION@{ub}
	This function specifies the lower limit of the OpalVision screen. Below this point Amiga only graphics
	will be displayed. Once a display bottom has been set, the region below that line will always contains
	Amiga graphics regardless of whether the frame buffer is being updated or not. This is useful for
	displaying Amiga gadgets on the screen.

@{b}	INPUTS@{ub}
	BottomLine	-Specifies the last line of OpalVision graphics.

@{b}	RESULT@{ub}
	Result		= 1 if operation successful, 0 if operation failed.

@{b}	CONSIDERATIONS@{ub}
	This function uses the CoPro to enable Amiga graphics on the bottom section of the screen. To ensure
	that the display is not corrupted, only CoPro instructions up to the line specified by LastCoProIns in the
	OpalScreen structure should be modified.

@{b}	SEE ALSO@{ub}
	ClearDisplayBottom24 ()

@EndNode

@Node "SetHires24()" "opal.library/SetHires24"

@{b}	NAME@{ub}
	SetHires24 -- Enable a hires display for a section of the screen.

@{b}	SYNOPSIS@{ub}
	Result = SetHires24 (TopLine, Lines);
			     D0       D1
	long TopLine;
	long Lines;

@{b}	FUNCTION@{ub}
	Sets the HIRESDISP bits on CoPro instructions starting at TopLine for 'Lines' number of lines. Both
	TopLine and Lines must be specified as a non-interlaced scan line (i.e. must be divided by 2 if an
	interlaced screen).

@{b}	INPUTS@{ub}
	TopLine 	-Specifies the first line to start setting HIRESDISP bits.
	Lines		-Number of lines to modify.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}
	SetLores24 ()

@EndNode

@Node "SetLoadAddress24()" "opal.library/SetLoadAddress24"

@{b}	NAME@{ub}
	SetLoadAddress24 -- Updates the OpalVision load address register.

@{b}	SYNOPSIS@{ub}
	void SetLoadAddress24 (void)

@{b}	FUNCTION@{ub}
	This function uses the Load Address value in the displayed OpalScreen structure to update the load
	address register in the OpalVision.

	This function is useful for scrolling and distortion effects.

	The modulo for a scan line is given in the OpalScreen structure and is independent of the display
	resolution.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	Load Address only has an effect when a CoPro instruction having its ADDLOAD bit cleared is executed.
	Therefore a combination of CoPro instructions and the address load register are required to produce the
	effect.

@{b}	SEE ALSO@{ub}
	@{"Scroll24()" Link "Scroll24()"}

@EndNode

@Node "SetLores24()" "opal.library/SetLores24"

@{b}	NAME@{ub}
	SetLores24 -- Enable a Lores display for a section of the screen.

@{b}	SYNOPSIS@{ub}
	Result = SetLores24 (TopLine, Lines);
			     D0       D1
	long TopLine;
	long Lines;

@{b}	FUNCTION@{ub}
	Clears the HIRESDISP bits on CoPro instructions starting at TopLine for 'Lines' number of lines. Both
	TopLine and Lines must be specified as a non-interlaced scan line (i.e. must be divided by 2 if an
	interlaced screen).

@{b}	INPUTS@{ub}
	TopLine 	-Specifies the first line to start clearing HIRESDISP bits.
	Lines		-Number of lines to modify.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}

@{b}	SEE ALSO@{ub}
	SetHires24 ()

@EndNode

@Node "SetPFStencil24()" "opal.library/SetPFStencil24"

@{b}	NAME@{ub}
	SetPFStencil24 -- Sets the PlayField Stencil of the specified @{"Screen" Link "TEXT_INCLUDE:intuition/screens.h/Main" 97}.

@{b}	SYNOPSIS@{ub}
	void SetPFStencil24 (OScrn);
			     A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	Sets the playfield stencil (least significant bit of green bank 0) of all of the pixels in the specified screen.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen structure.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This will only have an effect if Dual Playfield mode has been set up using DualPlayField24().

@{b}	SEE ALSO@{ub}
	ClearPFStencil()
	DualPlayField24()
	@{"SinglePlayField24()" Link "SinglePlayField24()"}

@EndNode

@Node "SetPRStencil24()" "opal.library/SetPRStencil24"

@{b}	NAME@{ub}
	SetPRStencil24 -- Sets the Priority Stencil of the specified @{"Screen" Link "TEXT_INCLUDE:intuition/screens.h/Main" 97}.

@{b}	SYNOPSIS@{ub}
	void SetPRStencil24 (OScrn);
			     A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	Sets the priority stencil (least significant bit of blue bank 0) of all pixels in the specified screen.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen structure.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This will only have an effect if dual OpalVision/Amiga display mode has been set up using
	@{"DualDisplay24()" Link "DualDisplay24()"}.

@{b}	SEE ALSO@{ub}
	ClearPRStencil()
	@{"DualDisplay24()" Link "DualDisplay24()"}
	@{"SingleDisplay24()" Link "SingleDisplay24()"}

@EndNode

@Node "SetRGB24()" "opal.library/SetRGB24"

@{b}	NAME@{ub}
	SetRGB24 -- Updates a single palette entry to the OpalVision palette registers.

@{b}	SYNOPSIS@{ub}
	void SetRGB24 (Entry, Red,  Green,  Blue);
			D0    D1    D2	    D3

	long Entry;
	long Red;
	long Green;
	long Blue;

@{b}	FUNCTION@{ub}
	This function updates a single palette entry in the OpalVision palette registers.

@{b}	INPUTS@{ub}
	Entry	- The entry selected for update (0-255).
	Red	- Red value (0-255).
	Green	- Green value (0-255).
	Blue	- Blue value (0-255).

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This function will only have a visible effect when in palette mapped mode.

@{b}	SEE ALSO@{ub}
	PaletteMap ()
	SetPalette ()

@EndNode

@Node "SetScreen24()" "opal.library/SetScreen24"

@{b}	NAME@{ub}
	SetScreen24 -- Fills screen with a specified colour.

@{b}	SYNOPSIS@{ub}
	void SetScreen24 (OScrn)
			    A0

	struct OpalScreen *OScrn;

@{b}	FUNCTION@{ub}
	This function is similar to ClearScreen24, but fills the screen with the colour contained in Pen_R,Pen_G
	& Pen_B in the OpalScreen structure.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"ClearScreen24()" Link "ClearScreen24()"}

@EndNode

@Node "SetSprite24()" "opal.library/SetSprite24"

@{b}	NAME@{ub}
	SetSprite24 -- Allows Amiga sprites to be displayed over OpalVision graphics.

@{b}	SYNOPSIS@{ub}
	void SetSprite24 (SpriteData, SpriteNumber);
			  A0	      D0

	USHORT *SpriteData;
	long SpriteNumber;

@{b}	FUNCTION@{ub}
	This function allows Amiga hardware sprites to be displayed in OpalVision graphics.

	Sprites are displayed during both display and update cycles and due to this the sprite data is written into
	the frame buffer memory along with the video data. This may be undesirable in some cases, so the sprite
	may be removed before starting updates using @{"Refresh24()" Link "Refresh24()"} or @{"UpdateDelay24()" Link "UpdateDelay24()"} by calling SetSprite24()
	with SpriteData = NULL

	SpriteData  is a pointer to a data definition of a spite as passed to the @{"SetPointer()" Link "intuition/SetPointer()"} function in the
	intuition library. The SpriteNumber is the hardware sprite number to be used to display the sprite, this
	will normally be 0 to modify the mouse pointer sprite.

	N.B.	Passing -1 for the SpriteData will use the currently active Amiga Sprite in the system. For
	example SetSprite24((USHORT *) - 1,0) will allow the currently active mouse pointer to be displayed
	over the 24 bit image.

@{b}	INPUTS@{ub}
	SpriteData	- pointer to the sprite data.
	SpriteNumber	- Amiga hardware sprite number (0...7).

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	All sprites other than the mouse pointer sprite should be allocated by the user using @{"GetSprite" Link "graphics/GetSprite()"} () as sprite
	0 is normally used for the mouse pointer and another sprite is required by the opal library for normal
	screen updates.

	Sprites will only be visible during display cycles if Amiga priority is set and dual display mode is active.

@{b}	SEE ALSO@{ub}

@EndNode

@Node "SingleDisplay24()" "opal.library/SingleDisplay24"

@{b}	NAME@{ub}
	SingleDisplay24 -- Sets up an Amiga/OpalVision single display.

@{b}	SYNOPSIS@{ub}
	void SingleDisplay24 (void);

@{b}	FUNCTION@{ub}
	This function sets the DUALDISPLAY bit of all CoPro instructions, allowing an OpalVision or Amiga
	only display.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If Amiga display bottom has been set, using the @{"SetDisplayBottom24()" Link "SetDisplayBottom24()"} the CoPro instructions will not be
	modified for that region of the display.

@{b}	SEE ALSO@{ub}
	@{"DualDisplay24()" Link "DualDisplay24()"}

@EndNode

@Node "SinglePlayField24()" "opal.library/SinglePlayField24"

@{b}	NAME@{ub}
	SinglePlayField24() -- Sets up an Amiga or OpalVision single playfield.

@{b}	SYNOPSIS@{ub}
	void SinglePlayField24 (void)

@{b}	FUNCTION@{ub}
	This function clears the DUALPLAYFIELD bit of all coprocessor instructions, Allowing only one of
	OpalVision playfield to be displayed.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	If an Amiga display bottom has been set, the coprocessor instructions will not be modified for that region
	of the display.

@{b}	SEE ALSO@{ub}
	DualPlayField24()

@EndNode

@Node "StopUpdate24()" "opal.library/StopUpdate24"

@{b}	NAME@{ub}
	StopUpdate24 -- Stops updates to the frame buffer memory.

@{b}	SYNOPSIS@{ub}
	void StopUpdate24 (void);

@{b}	FUNCTION@{ub}
	This function stops updates to the OpalVision frame buffer memory initiated with a call to
	@{"UpdateDelay24()" Link "UpdateDelay24()"}. This allows changes to be made to the Amiga memory without affecting the
	OpalVision frame buffer memory thus offering inherent double buffering. Stopping updates will also
	reduce the DMA load on the Amiga.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	This function may take up to 1 frame as it must wait for the current frame update to be completed.

@{b}	SEE ALSO@{ub}
	@{"UpdateDelay24()" Link "UpdateDelay24()"}
	@{"Refresh24()" Link "Refresh24()"}

@EndNode

@Node "UpdateAll24()" "opal.library/UpdateAll24"

@{b}	NAME@{ub}
	UpdateAll24 -- Resets the internal update structure so all required banks are updated.

@{b}	SYNOPSIS@{ub}
	void UpdateAll24 (void);

@{b}	FUNCTION@{ub}
	Resets the internal update structure so that all required banks are updated.  This function is useful after a
	call to @{"UpdatePFStencil24()" Link "UpdatePFStencil24()"} to reinitialise the internal state of the library so that all the required segments
	are updated correctly on subsequent calls to @{"Refresh24()" Link "Refresh24()"} or @{"UpdateDelay24()" Link "UpdateDelay24()"}.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"UpdatePFStencil24()" Link "UpdatePFStencil24()"}

@EndNode

@Node "UpdateCoPro24()" "opal.library/UpdateCoPro24"

@{b}	NAME@{ub}
	UpdateCoPro24() -- Writes CoPro list for the current display screen to Video coprocessor

@{b}	SYNOPSIS@{ub}
	void UpdateCoPro24 (void);

@{b}	FUNCTION@{ub}
	Encodes the entire CoPro instruction list from the displayed screen structure and initiates a coprocessor
	update.

	This function also updates the Load Address Register.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	Modifying the coprocessor list in the screen structure does not have any effect on the display until
	UpdateCoPro24 () is called.

	The CoPro list will not be updated in the OpalVision until the next vertical blanking period.

@{b}	SEE ALSO@{ub}
	@{"SetCoPro24()" Link "SetCoPro24()"}
	@{"RegWait24()" Link "RegWait24()"}

@EndNode

@Node "UpdateDelay24()" "opal.library/UpdateDelay24"

@{b}	NAME@{ub}
	UpdateDelay24 () -- Sets the delay between consecutive frame buffer updates.

@{b}	SYNOPSIS@{ub}
	void UpdateDelay24 (FrameDelay);
				D0

	long FrameDelay;

@{b}	FUNCTION@{ub}
	This function allows a variable frame delay between consecutive frame buffer updates. Setting a frame
	delay of zero enables continuous full speed updates.

	This function also initiates continuous updates to the OpalVision frame buffer memory which will
	continue until either @{"Refresh24()" Link "Refresh24()"} or @{"StopUpdate24()" Link "StopUpdate24()"} is called.

	Setting a delay increases free bus DMA bandwidth to increase performance of the CPU and other DMA
	devices.

@{b}	INPUTS@{ub}
	FrameDelay	= Number of Frames to pause between frame buffer updates.

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	@{"UpdateAll24()" Link "UpdateAll24()"} and @{"UpdatePFStencil24()" Link "UpdatePFStencil24()"} determine which memory segments will be updated during an
	update sequence.

@{b}	SEE ALSO@{ub}
	@{"StopUpdate24()" Link "StopUpdate24()"}
	@{"UpdateAll24()" Link "UpdateAll24()"}
	@{"UpdatePFStencil24()" Link "UpdatePFStencil24()"}
	@{"Refresh24()" Link "Refresh24()"}

@EndNode

@Node "UpdatePalette24()" "opal.library/UpdatePalette24"

@{b}	NAME@{ub}
	UpdatePalette 24 -- Loads all 256 entries of Red, Green and Blue values in the OpalScreen structure onto
			the OpalVision	palette registers.

@{b}	SYNOPSIS@{ub}
	void UpdatePalette (void);

@{b}	FUNCTION@{ub}
	Updates the OpalVision palette registers with the palette values in the OpalScreen structure.

	This also updates the Pixel Read mask and the Command Register and uses the Palette Load Address as
	an offset for the palette update.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	Updates will have no effect in non palette mapped modes.

@{b}	SEE ALSO@{ub}
	SetRGB24 ()
	PaletteMap24 ()

@EndNode

@Node "UpdatePFStencil24()" "opal.library/UpdatePFStencil24"

@{b}	NAME@{ub}
	UpdatePFStencil24() -- Updates playfield stencil at highest possible rate.

@{b}	SYNOPSIS@{ub}
	void UpdatePFStencil24(void);

@{b}	FUNCTION@{ub}
	Enables updates to only the segments containing the playfield stencil (green segments). The speed of
	update is three times that of a normal 24bit update. This enables quick playfield transitions.

	This function does not update the playfield stencil as such, but modifies the internal state of the library so
	that subsequent calls to @{"Refresh24()" Link "Refresh24()"} or @{"UpdateDelay24()" Link "UpdateDelay24()"} will only update the segments containing the
	playfield stencil. The internal state of the library can be returned to normal by calling @{"UpdateAll24()" Link "UpdateAll24()"}.

	To use the playfield stencil in 8bit mode, the green bank contains the stencil and therefore must be
	updated. The most convenient way to do this is to write the frame for the first playfield in the red
	segment of bank 0 using WriteFrame24(0) and the second playfield into the red segment of bank 1 using
	WriteFrame24(3). UpdatePFStencil24() will call WriteFrame24(1) when in 8bit mode to switch to the
	green segment. Placing you playfields in segments other than the green segment will give you the full
	256 colours rather than 128.

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	UpdateDelay24 ()
	DualPlayField24()
	@{"SinglePlayField24()" Link "SinglePlayField24()"}
	@{"Refresh24()" Link "Refresh24()"}
	@{"UpdateAll24()" Link "UpdateAll24()"}

@EndNode

@Node "UpdateRegs24()()" "opal.library/UpdateRegs24()"

@{b}	NAME@{ub}
	UpdateRegs24 () -- Updates the hardware registers for the current display screen

@{b}	SYNOPSIS@{ub}
	void UpdateRegs24 (void)

@{b}	FUNCTION@{ub}
	Updates the Pixel Read mask, Command register and Palette Load Address registers in the OpalVision
	with the values from the current display screen structure (See "Registers").

@{b}	INPUTS@{ub}
	None

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	Changing register values in the screen structure does not take effect until an update has been initiated.

	Register updates are not completed until the next vertical blanking period.

@{b}	SEE ALSO@{ub}
	@{"RegWait24()" Link "RegWait24()"}

@EndNode

@Node "WriteFrame24()" "opal.library/WriteFrame24"

@{b}	NAME@{ub}
	WriteFrame24 -- Sets the current frame to be written to within the frame buffer memory.

@{b}	SYNOPSIS@{ub}
	void WriteFrame24 (Frame);
			   D0

	long Frame;

@{b}	FUNCTION@{ub}
	Depending on the resolution of the displayed OpalVision screen, a number of screens can be stored in the
	frame buffer memory. The number of frames available for the screens resolution are given in the
	MaxFrames variable in the OpalScreen structure.

	WriteFrame24() allows each individual frame to be written separately where Frame is in the range
	0...MaxFrames. Using a combination of WriteFrame24 and DisplayFrame24, it is possible to store
	several images in frame buffer memory and to perform simple page flip animation.

@{b}	INPUTS@{ub}
	Frame	= Frame number to display (0...MaxFrames).

@{b}	RESULT@{ub}
	None

@{b}	CONSIDERATIONS@{ub}
	The display frame and the write frame, must reside in the same field area in the frame buffer memory.
	(See "Memory Segment Diagram"). Due to this WriteFrame24() has the side effect of changing the
	display frame if the new write frame is in a different field.

@{b}	SEE ALSO@{ub}
	@{"DisplayFrame24()" Link "DisplayFrame24()"}

@EndNode

@Node "WritePFPixel24()" "opal.library/WritePFPixel24"

@{b}	NAME@{ub}
	WritePFPixel24 () -- Set or clear a pixel in the playfield stencil.

@{b}	SYNOPSIS@{ub}
	Result = WritePFPixel24 (OScrn, x, y);
	D0			 A0	D0 D1

	struct OpalScreen *OScrn;
	long x;
	long y;
	long Result;

@{b}	FUNCTION@{ub}
	Sets or clears a pixel in the playfield stencil depending on the state of Pen_R in the screen structure. If
	Pen_R is = 0, the pixel will be cleared else it is set. The SetPFPen macro can be used to initialize Pen_R.

@{b}	INPUTS@{ub}
	OScrn	= A pointer to an OpalScreen structure.
	x	= x coordinate of pixel.
	y	= y coordinate of pixel.

@{b}	RESULT@{ub}
	Result	= -1 if the pixel is outside the clip boundary else 0.

@{b}	CONSIDERATIONS@{ub}
	This function only has visible effect in dual playfield mode.

@{b}	SEE ALSO@{ub}
	@{"ReadPFPixel24()" Link "ReadPFPixel24()"}
	UpdatePFStencil()
	DualPlayField24()
	SinglePlayfield24()

@EndNode

@Node "WritePixel24()" "opal.library/WritePixel24"

@{b}	NAME@{ub}
	WritePixel24 () -- Write a pixel into an OpalScreen.

@{b}	SYNOPSIS@{ub}
	Result = WritePixel24 (OScrn, x, y);
	D0		       A0     D0 D1


	struct OpalScreen *OScrn;
	long x;
	long y;
	long Result;

@{b}	FUNCTION@{ub}
	Writes a pixel in the specified OpalScreen using the current pen value in that structure. The macro
	SetPen can be used to initialize pen values correctly.

@{b}	INPUTS@{ub}
	OScrn	= A pointer to an OpalScreen structure.
	x	= x coordinate of pixel.
	y	= y coordinate of pixel.

@{b}	RESULT@{ub}
	Result	= -1 if the pixel is outside the clip boundary else 0.

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"ReadPixel24()" Link "ReadPixel24()"}

@EndNode

@Node "WritePRPixel24()" "opal.library/WritePRPixel24"

@{b}	NAME@{ub}
	WritePRPixel24 () -- Set or clear a pixel in the priority stencil.

@{b}	SYNOPSIS@{ub}
	Result = WritePRPixel24 (OScrn, x, y);
	D0			 A0	D0 D1

	struct OpalScreen *OScrn;
	long x;
	long y;
	long Result;

@{b}	FUNCTION@{ub}
	Sets or clears a pixel in the priority stencil depending on the state of Pen_R in the screen structure. If
	Pen_R is = 0, the pixel will be cleared else it is set. The macro SetPRPen can be used to initialize the
	state of Pen_R.

@{b}	INPUTS@{ub}
	OScrn	= A pointer to an OpalScreen structure.
	x	= x coordinate of pixel.
	y	= y coordinate of pixel.

@{b}	RESULT@{ub}
	Result	= -1 if the pixel is outside the clip boundary else 0.

@{b}	CONSIDERATIONS@{ub}
	This function only has visible effect when the priority stencil is enabled.

@{b}	SEE ALSO@{ub}
	@{"ReadPRPixel24()" Link "ReadPRPixel24()"}
	@{"EnablePRStencil24()" Link "EnablePRStencil24()"}
	@{"DisablePRStencil24()" Link "DisablePRStencil24()"}

@EndNode

@Node "WriteThumbnail24()" "opal.library/WriteThumbnail24"

@{b}	NAME@{ub}
	WriteThumbnail24 -- Writes an IFF thumb-nail chunk into a file.

@{b}	SYNOPSIS@{ub}
	ReturnCode = WriteThumbnail24 (OScrn, File);
	D0				A0    A1

	struct OpalScreen *OScrn;
	BPTR File;
	long ReturnCode;


@{b}	FUNCTION@{ub}
	This function generates a 24 bit thumb-nail for the given OpalScreen and writes an IFF OVTN thumb-
	nail chunk into the given file.

@{b}	INPUTS@{ub}
	OScrn	= OpalScreen to generate the thumb-nail for.
	File	= File Handle of the file to write thumb-nail to.

@{b}	RESULT@{ub}
	ReturnCode = 0 if all ok, or an OpalVision Error code  if en error occurred.

@{b}	CONSIDERATIONS@{ub}


@{b}	SEE ALSO@{ub}
	@{"SaveIFF24()" Link "SaveIFF24()"}
	LoadIFF24()

@EndNode

@Node "OpalRequester()" "opalreq.library/OpalRequester"

@{b}	NAME@{ub}
	OpalRequester -- The OpalVision file requester.

@{b}	SYNOPSIS@{ub}
	ReturnCode = OpalRequester (OReq);
	D0			    A0

	struct OpalReq *OReq;

@{b}	FUNCTION@{ub}
	This is the entry point for the OpalVision requester. OReq is a pointer to a properly initialised OpalReq
	structure defined in the above sections. The requester will be displayed and handled completely by the
	library, when the user has selected a file or hit cancel, this function will return the selected file and
	directory name in OReq. OKHit will be cleared if the user hit the Cancel gadget and set otherwise.

@{b}	INPUTS@{ub}
	OReq	= A pointer to a correctly initialised OpalReq structure.

@{b}	RESULT@{ub}
	ReturnCode = 0 if all ok
		   =  OR_ERR_OUTOFMEM if there is not enough memory to display requester
		   =  OR_ERR_INUSE if the requester is currently in use.

@{b}	CONSIDERATIONS@{ub}
	For this release the intuition screen used to display the requester
	must be hires interlaced, and have atleast 2 bit planes.

@{b}	SEE ALSO@{ub}

@EndNode

