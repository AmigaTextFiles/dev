@database "Arrays.M - Dokumentation"
@$VER: Arrays.GUIDE v2.8 (c) Copyrights by Daniel Kasmeroglu

@node main "E-Modul: Arrays.M"
@prev main
@next main

  @{" Einführung              " LINK einleitung}
  @{" Copyrights und Vertrieb " LINK copyrights}

  Enthaltene Objekte:      Abkürzungen:  

    @{" OBJECT array2   " LINK short_array2}           a2
    @{" OBJECT array3   " LINK short_array3}           a3
    @{" OBJECT booleans " LINK short_booleans}           bs
    @{" OBJECT boolong  " LINK short_boolong}           bg
    @{" OBJECT bool2    " LINK short_bool2}           b2
    @{" OBJECT bool3    " LINK short_bool3}           b3

  Methoden:

    WICHTIG: Neben den Methoden stehen Abkürzungen für die jeweiligen
             Objekte, in denen diese Methode enthalten ist.

    @{" arr_ArrayExist()  " LINK arr_arrayexist} alle Objekte
    @{" arr_CellSize()    " LINK arr_cellsize} a2 a3
    @{" arr_ClearArray()  " LINK arr_cleararray} alle Objekte
    @{" arr_Copy()        " LINK arr_copy} alle Objekte
    @{" arr_CreateArray() " LINK arr_createarray} a2 a3 bs
    @{" arr_FreeArray()   " LINK arr_freearray} alle Objekte
    @{" arr_GetCell()     " LINK arr_getcell} alle Objekte
    @{" arr_InitArray()   " LINK arr_initarray} alle Objekte
    @{" arr_MaxBools()    " LINK arr_maxbools} bs
    @{" arr_MaxX()        " LINK arr_maxx} a2 a3 b2 b3
    @{" arr_MaxY()        " LINK arr_maxy} a2 a3 b2 b3
    @{" arr_MaxZ()        " LINK arr_maxz} a3 b3
    @{" arr_SetCell()     " LINK arr_setcell} alle Objekte
    @{" arr_UsedMem()     " LINK arr_usedmem} alle Objekte
    @{" end()             " LINK arr_end} a2 a3 b2 b3 bs

@endnode


@node einleitung "Einführung"
@prev main
@next copyrights

  Autor...: Daniel Kasmeroglu
  Modul...: Arrays.m
  Version.: 2.8

  Wie ihr seht, ist mein Name Daniel Kasmeroglu (Hehe ;-)
  Ich habe dieses Modul geschrieben, um es dem E-Programmierer
  zu ermöglichen mehrdimensionale Reihungen ohne größeren
  Aufwand zu nutzen. Zusätzlich habe ich Objekte integriert,
  mit denen man boolesche Ausdrücke in entsprechenden Reihungen
  benutzen kann. Im Gegensatz zu Programmiersprachen, wie 
  Pascal, Modula-II (ich glaube auch C++), wird hier für jeden
  booleschen Ausdruck nur ein Bit verbraucht, während die 
  genannten anderen Compiler 32 Bit verbrauchen. Natürlich
  darf man nicht vergessen, daß die Datenkomponenten ebenfalls
  Speicher verbrauchen. Die Speicherersparnis steigt aber mit 
  zunehmender Größe der Reihung.

  Ich wünsche euch viel Spaß mit diesem Modul ;-)

  P.S.: Als ich diese Anleitung schrieb, hatte ich mir vorgenommen
        eine möglichst leicht verständliche Struktur zu benutzen.
        Leider ist es mir nicht gelungen, weshalb ich hier um
        Nachsicht bitte ;(

  P.S.: Die Objekte `bool2' und `bool3' werden in dieser Dokumentation
        zwar behandelt, befinden sich aber nicht im entsprechenden
        Modul. Diese Objekte sind bereits fertig, enthalten aber noch
        einige Fehler, die ich noch beseitigen muß. Damit ihr User
        (v.a. Anfänger) keine unnötigen Probleme bekommt, habe ich diese
        Objekte entfernt.

@endnode


@node copyrights "Copyrights und Vertrieb"
@prev einleitung
@next short_array2

  Folgende Dateien sind FREEWARE: - arrays.m
                                  - arrays.e
                                  - arrays.guide
                                  - test_arrays_a.e   (OBJECT array2)
                                  - test_arrays_b.e   (OBJECT array3)
                                  - test_arrays_c.e   (OBJECT booleans)
                                  - test_arrays_d.e   (OBJECT boolong)
                                  - test_arrays_e.e   (OBJECT bool2)
                                  - test_arrays_f.e   (OBJECT bool3)
                                  - die dazugehörigen Icons

  Einschränkungen:  - Die Copyrights gehören mir (Daniel Kasmeroglu)
                    - Für diese Dateien darf KEIN Entgelt verlangt werden
                    - Die Benutzung dieser Dateien geschieht auf eigener 
                      Verantwortung
                    - Die Dateien dürfen nur im Original-Zustand
                      weitergegeben werden

  Erlaubt ist    :  - Die Modifikation der Dateien für eigene Zwecke
                    - Dem Autoren Quellcodes unentgeltlich zu schicken ;-)
                    - Dem Autoren Anregungen und Tips zu diesem oder
                      zu einem noch nicht bestehenden Modul zu schicken 
                    - Fehlermeldungen inkl. Bericht zu schicken

  Meine Adresse  :  Daniel Kasmeroglu
                    Rubensstr. 26
                    12159 Berlin (Schöneberg)
                    Deutschland

@endnode


@node short_array2 "OBJECT array2"
@prev copyrights
@next short_array3

  Objektbezeichner: "array2"

  Typ der Reihung : Dieses Objekt erstellt eine zweidimensionale Reihung,
                    die entweder CHARs, INTs oder LONGs aufnehmen kann.
                    Die meisten Datenkomponenten können mittels der
                    Methoden ausgelesen werden, wobei sie vor einem
                    überschreiben des Programmierers geschützt sind.

  Verfügbare Methoden:

    @{" arr_ArrayExist()  " LINK arr_arrayexist}
    @{" arr_CellSize()    " LINK arr_cellsize}
    @{" arr_ClearArray()  " LINK arr_cleararray}
    @{" arr_Copy()        " LINK arr_copy}
    @{" arr_CreateArray() " LINK arr_createarray}
    @{" arr_FreeArray()   " LINK arr_freearray}
    @{" arr_GetCell()     " LINK arr_getcell}
    @{" arr_InitArray()   " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_MaxX()        " LINK arr_maxx}
    @{" arr_MaxY()        " LINK arr_maxy}
    @{" arr_SetCell()     " LINK arr_setcell}
    @{" arr_UsedMem()     " LINK arr_usedmem}
    @{" end()             " LINK arr_end} (DESTRUKTOR)

@endnode

@node short_array3 "OBJECT array3"
@prev short_array2
@next short_bool2

  Objektbezeichner: "array3"

  Typ der Reihung : Dieses Objekt erstellt eine dreidimensionale Reihung,
                    die entweder CHARs, INTs oder LONGs aufnehmen kann.
                    Die meisten Datenkomponenten können mittels der
                    Methoden ausgelesen werden, wobei sie vor einem
                    überschreiben des Programmierers geschützt sind.

  Verfügbare Methoden:

    @{" arr_ArrayExist()  " LINK arr_arrayexist}
    @{" arr_CellSize()    " LINK arr_cellsize}
    @{" arr_ClearArray()  " LINK arr_cleararray}
    @{" arr_Copy()        " LINK arr_copy}
    @{" arr_CreateArray() " LINK arr_createarray}
    @{" arr_FreeArray()   " LINK arr_freearray}
    @{" arr_GetCell()     " LINK arr_getcell}
    @{" arr_InitArray()   " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_MaxX()        " LINK arr_maxx}
    @{" arr_MaxY()        " LINK arr_maxy}
    @{" arr_MaxZ()        " LINK arr_maxz}
    @{" arr_SetCell()     " LINK arr_setcell}
    @{" arr_UsedMem()     " LINK arr_usedmem}
    @{" end()             " LINK arr_end} (DESTRUKTOR)

@endnode


@node short_bool2 "OBJECT bool2"
@prev short_array3
@next short_bool3

  Objektbezeichner: "bool2"

  Typ der Reihung : Dieses Objekt stellt eine zweidimensionale Reihung
                    zur Verfügung, die lediglich boolesche Wert annehmen
                    kann.

  Verfügbare Methoden:

    @{" arr_ArrayExist() " LINK arr_arrayexist}
    @{" arr_ClearArray() " LINK arr_cleararray}
    @{" arr_Copy()       " LINK arr_copy}
    @{" arr_FreeArray()  " LINK arr_freearray}
    @{" arr_GetCell()    " LINK arr_getcell}
    @{" arr_InitArray()  " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_MaxX()       " LINK arr_maxx}
    @{" arr_MaxY()       " LINK arr_maxy}
    @{" arr_SetCell()    " LINK arr_setcell}
    @{" arr_UsedMem()    " LINK arr_usedmem}
    @{" end()            " LINK arr_end} (DESTRUKTOR)

@endnode


@node short_bool3 "OBJECT bool3"
@prev short_bool2
@next short_booleans

  Objektbezeichner: "bool3"

  Typ der Reihung : Dieses Objekt stellt eine dreidimensionale Reihung
                    zur Verfügung, die lediglich boolesche Wert annehmen
                    kann.

  Verfügbare Methoden:

    @{" arr_ArrayExist() " LINK arr_arrayexist}
    @{" arr_ClearArray() " LINK arr_cleararray}
    @{" arr_Copy()       " LINK arr_copy}
    @{" arr_FreeArray()  " LINK arr_freearray}
    @{" arr_GetCell()    " LINK arr_getcell}
    @{" arr_InitArray()  " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_MaxX()       " LINK arr_maxx}
    @{" arr_MaxY()       " LINK arr_maxy}
    @{" arr_MaxZ()       " LINK arr_maxz}
    @{" arr_SetCell()    " LINK arr_setcell}
    @{" arr_UsedMem()    " LINK arr_usedmem}
    @{" end()            " LINK arr_end} (DESTRUKTOR)

@endnode


@node short_booleans "OBJECT booleans"
@prev short_bool3
@next short_boolong

  Objektbezeichner: "booleans"

  Typ der Reihung : Eindimensionale Reihung, die nur boolesche
                    Wert (TRUE oder FALSE) aufnehmen kann. Jeder
                    Wert beansprucht dabei nur ein Bit, was eine
                    deutliche Speicherersparnis zur Folge hat.
  
  Verfügbare Methoden:

    @{" arr_ArrayExist()  " LINK arr_arrayexist}
    @{" arr_ClearArray()  " LINK arr_cleararray}
    @{" arr_Copy()        " LINK arr_copy}
    @{" arr_CreateArray() " LINK arr_createarray}
    @{" arr_FreeArray()   " LINK arr_freearray}
    @{" arr_GetCell()     " LINK arr_getcell}
    @{" arr_InitArray()   " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_MaxBools()    " LINK arr_maxbools}
    @{" arr_SetCell()     " LINK arr_setcell}
    @{" arr_UsedMem()     " LINK arr_usedmem}
    @{" end()             " LINK arr_end} (DESTRUKTOR)

@endnode


@node short_boolong "OBJECT boolong"
@prev short_booleans
@next main

  Objektbezeichner: "boolong"

  Typ der Reihung : Dieses Objekt stellt, wie @{" booleans " LINK short_booleans} eine eindimensionale
                    Reihung mit booleschen Werten dar. Der einzige
                    Unterschied zu booleans besteht in der Tatsache, daß
                    die Größe der Reihung auf 32 Zellen (0..31) 
                    beschränkt ist. Dafür spart aber zusätzlich Speicher,
                    da dieses Objekt nur noch eine Datenkomponente enthält.

  Verfügbare Methoden:

    @{" arr_ClearArray() " LINK arr_cleararray}
    @{" arr_Copy()       " LINK arr_copy}
    @{" arr_InitArray()  " LINK arr_initarray} (KONSTRUKTOR)
    @{" arr_GetCell()    " LINK arr_getcell}
    @{" arr_SetCell()    " LINK arr_setcell}
    @{" arr_UsedMem()    " LINK arr_usedmem}

  WICHTIG: Wie in dieser Auflistung zu sehen ist, ist kein Destruktor
           definiert. Dies hängt damit zusammen, daß der Speicher, der
           für diese Reihung benötigt wird, lediglich eine Datenkomponente
           dieses Objektes ist. Sobald das Objekt gelöscht wird, wird
           auch automatisch die Reihung gelöscht.

@endnode


@node arr_arrayexist "arr_ArrayExist()"
@prev main
@next arr_cellsize

  Syntax...: <1> := <2>.arr_ArrayExist()
             <1> := <3>.arr_ArrayExist()
             <1> := <4>.arr_ArrayExist()
             <1> := <5>.arr_ArrayExist()
             <1> := <6>.arr_ArrayExist()

  <1>: ist eine Variable, die einen booleschen Wert erhält
  <2>: ist eine Variable vom Typ `PTR TO array2'
  <3>: ist eine Variable vom Typ `PTR TO array3'
  <4>: ist eine Variable vom Typ `PTR TO bool2'
  <5>: ist eine Variable vom Typ `PTR TO bool3'
  <6>: ist eine Variable vom Typ `PTR TO booleans'

  Funktion: Diese Methode liefert den Wert TRUE, falls das entsprechende
            Objekt erfolgreich initialisiert wurde und externer Speicher
            vorhanden ist. Sollte dieses Objekt keinen externen Speicher
            anfordern können oder irgendein anderes Problem auftauchen,
            ist der Funktionswert <1> gleich FALSE.

@endnode

@node arr_cellsize "arr_CellSize()"
@prev arr_arrayexist
@next arr_cleararray

  Syntax...: <1> := <2>.arr_CellSize()
             <1> := <3>.arr_CellSize()

  <1>: ist eine Variable, die den Wert ARR_BYTE, ARR_INT oder ARR_LONG
       erhält
  <2>: ist eine Variable vom Typ `PTR TO array2'
  <3>: ist eine Variable vom Typ `PTR TO array3'

  Funktion: Diese Funktion liefert die Größe einer Speicherzelle
            zurück. 

@endnode

@node arr_cleararray "arr_ClearArray()"
@prev arr_cellsize
@next arr_copy

  Syntax...: <1>.arr_ClearArray(<7> = 0)
             <2>.arr_ClearArray(<7> = 0)
             <3>.arr_ClearArray(<8> = FALSE)
             <4>.arr_ClearArray(<8> = FALSE)
             <5>.arr_ClearArray(<8> = FALSE)
             <6>.arr_ClearArray(<9> = %00000000000000000000000000000000)

  <1>: ist eine Variable vom Typ `PTR TO array2'
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO bool2'
  <4>: ist eine Variable vom Typ `PTR TO bool3'
  <5>: ist eine Variable vom Typ `PTR TO booleans'
  <6>: ist eine Variable vom Typ `PTR TO boolong'
  <7>: ist eine Zahl
  <8>: ist ein boolescher Wert (TRUE oder FALSE)
  <9>: ist eine 32-Bit-Maske bzw. eine entsprechende dezimale Zahl

  Funktion: Mit dieser Methode können die einzelnen Zellen der
            Reihung initialisiert werden. In der Syntaxerklärung
            ist auch erkennbar, welche Werte die Parameter als
            Standardwert erhalten.

@endnode

@node arr_copy "arr_Copy()"
@prev arr_cleararray
@next arr_createarray

  Syntax...: <1> := <1>.arr_Copy()
             <2> := <2>.arr_Copy()
             <3> := <3>.arr_Copy()
             <4> := <4>.arr_Copy()
             <5> := <5>.arr_Copy()
             <6> := <6>.arr_Copy()

  <1>: ist eine Variable vom Typ `PTR TO array2'
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO bool2'
  <4>: ist eine Variable vom Typ `PTR TO bool3'
  <5>: ist eine Variable vom Typ `PTR TO booleans'
  <6>: ist eine Variable vom Typ `PTR TO boolong'

  Funktion: Mit dieser Funktion ist es möglich Inhalte verschiedener
            Reihungen zu kopieren. Um Mißverständnisse von vornherein
            zu vermeiden: Der Funktionswert muß vom selben Typ, wie
            das entsprechende Objekt sein, aber die BEZEICHNER müssen
            natürlich unterschiedlich sein. Der Funktionswert erhält
            ein komplett fertiggestelltes Objekt (oder NIL). 
            Da ich in diesem Falle natürlich, daß NEW-Statement
            benutzen mußte habe ich sicherheitshalber einen
            Exception-Handler integriert um evtl. Exceptions abzufangen.

@endnode

@node arr_createarray "arr_CreateArray()"
@prev arr_copy
@next arr_freearray

  Syntax...: <1>.arr_CreateArray()
             <2>.arr_CreateArray()
             <3>.arr_CreateArray()

  <1>: ist eine Variable vom Typ `PTR TO array2'
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO booleans'

  Funktion: Diese Methode allokiert den benötigten "externen" Speicher.
            Sie wird automatisch vom Konstruktor @{" arr_InitArray() " LINK arr_initarray}
            aufgerufen. Daher muß sie nur aufgerufen werden, wenn die
            Reihung mittels @{" arr_FreeArray() " LINK arr_freearray} gelöscht wurde und nun
            eine neue erzeugt werden soll.

@endnode

@node arr_freearray "arr_FreeArray()"
@prev arr_createarray
@next arr_getcell

  Syntax...: <1>.arr_FreeArray()
             <2>.arr_FreeArray()
             <3>.arr_FreeArray()
             <4>.arr_FreeArray()
             <5>.arr_FreeArray()

  <1>: ist eine Variable vom Typ `PTR TO array2'
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO bool2'
  <4>: ist eine Variable vom Typ `PTR TO bool3'
  <5>: ist eine Variable vom Typ `PTR TO booleans'

  Funktion: Diese Methode gibt allokierten Speicher wieder frei.
            Falls man den Speicher erst mit der Auflösung des
            Objektes freigeben möchte, braucht man diese Methode
            nicht zu benutzen, da der Destruktor @{" end() " LINK arr_end} automatisch
            von ihr Gebrauch macht.

@endnode

@node arr_getcell "arr_GetCell()"
@prev arr_freearray
@next arr_initarray

  Syntax...: <01>,<02> := <04>.arr_GetCell(<10>,<11>)
             <01>,<02> := <05>.arr_GetCell(<10>,<11>,<12>)
             <03>,<02> := <06>.arr_GetCell(<10>,<11>)
             <03>,<02> := <07>.arr_GetCell(<10>,<11>,<12>)
             <03>,<02> := <08>.arr_GetCell(<10>)
             <03>,<02> := <09>.arr_GetCell(<10>)

  <01>: ist eine Variable, die den dezimalen Zellen-Inhalt aufnimmt
  <02>: ist eine Variable, die einen booleschen Wert aufnimmt
  <03>: ist eine Variable, die den booleschen Zellen-Inhalt aufnimmt
  <04>: ist eine Variable vom Typ `PTR TO array2'
  <05>: ist eine Variable vom Typ `PTR TO array3'
  <06>: ist eine Variable vom Typ `PTR TO bool2'
  <07>: ist eine Variable vom Typ `PTR TO bool3'
  <08>: ist eine Variable vom Typ `PTR TO booleans'
  <09>: ist eine Variable vom Typ `PTR TO boolong'
  <10>: ist der Zellen-Index in "X-Richtung"
  <11>: ist der Zellen-Index in "Y-Richtung"
  <12>: ist der Zellen-Index in "Z-Richtung"

  Funktion: Diese Methode liest den Funktionswert der entsprechenden
            Reihung aus. Da dies in irgendeiner Weise fehlschlagen
            könnte, wird ein zweiter Funktionswert benutzt. Ist dieser
            TRUE, dann ist das Ergebnis (der 1. Funktionswert) mit
            Sicherheit falsch. Die Wert dieser Zellen kann man mit
            der Methode @{" arr_SetCell() " LINK arr_setcell} festlegen.

@endnode

@node arr_initarray "arr_InitArray()"
@prev arr_getcell
@next arr_maxbools

  Syntax...: NEW <01>.arr_InitArray(<07>,<08>,<10>)
             NEW <02>.arr_InitArray(<07>,<08>,<09>,<10>)
             NEW <03>.arr_InitArray(<07>,<08>)
             NEW <04>.arr_InitArray(<07>,<08>,<09>)
             NEW <05>.arr_InitArray(<07>)
             NEW <06>.arr_InitArray(<07>)

  <01>: ist eine Variable vom Typ `PTR TO array2'
  <02>: ist eine Variable vom Typ `PTR TO array3'
  <03>: ist eine Variable vom Typ `PTR TO bool2'
  <04>: ist eine Variable vom Typ `PTR TO bool3'
  <05>: ist eine Variable vom Typ `PTR TO booleans'
  <06>: ist eine Variable vom Typ `PTR TO boolong'
  <07>: maximale Zellen-Anzahl in "X-Richtung"
  <08>: maximale Zellen-Anzahl in "Y-Richtung"
  <09>: maximale Zellen-Anzahl in "Z-Richtung"
  <10>: Zellen-Größe ARR_BYTE, ARR_INT oder ARR_LONG

  Funktion: Bei dieser Methode handelt es sich um den sog. Konstruktor.
            Diese Methode initialisiert das Objekt und allokiert
            externen Speicher. Sollte der Konstruktor keinen Erfolg
            haben, kann man dies mit der Methode @{" arr_ArrayExist() " LINK arr_arrayexist}
            in Erfahrung bringen.

@endnode

@node arr_maxbools "arr_MaxBools()"
@prev arr_initarray
@next arr_maxx

  Syntax...: <1> := <2>.arr_MaxBools()

  <1>: ist die Anzahl maximal verfügbarer Zellen
  <2>: ist eine Variable vom Typ `PTR TO booleans'

  Funktion: Diese Methode liefert die Anzahl maximal verfügbarer
            boolescher Zellen zurück.

@endnode

@node arr_maxx "arr_MaxX()"
@prev arr_maxbools
@next arr_maxy

  Syntax...: <1> := <2>.arr_MaxX()
             <1> := <3>.arr_MaxX()
             <1> := <4>.arr_MaxX()
             <1> := <5>.arr_MaxX()

  <1>: ist die Anzahl verfügbarer Zellen in "X-Richtung"
  <2>: ist eine Variable vom Typ `PTR TO array2'
  <3>: ist eine Variable vom Typ `PTR TO array3'
  <4>: ist eine Variable vom Typ `PTR TO bool2'
  <5>: ist eine Variable vom Typ `PTR TO bool3'

  Funktion: Diese Funktion liefert die Anzahl maximal verfügbarer
            Zellen in "X-Richtung" zurück. Vergleiche dazu
            @{" arr_MaxY() " LINK arr_maxy} oder @{" arr_MaxZ() " LINK arr_maxz} . 

@endnode

@node arr_maxy "arr_MaxY()"
@prev arr_maxx
@next arr_maxz

  Syntax...: <1> := <2>.arr_MaxY()
             <1> := <3>.arr_MaxY()
             <1> := <4>.arr_MaxY()
             <1> := <5>.arr_MaxY()

  <1>: ist die Anzahl verfügbarer Zellen in "Y-Richtung"
  <2>: ist eine Variable vom Typ `PTR TO array2'
  <3>: ist eine Variable vom Typ `PTR TO array3'
  <4>: ist eine Variable vom Typ `PTR TO bool2'
  <5>: ist eine Variable vom Typ `PTR TO bool3'

  Funktion: Diese Funktion liefert die Anzahl maximal verfügbarer
            Zellen in "Y-Richtung" zurück. Vergleiche dazu
            @{" arr_MaxX() " LINK arr_maxy} oder @{" arr_MaxZ() " LINK arr_maxz} . 

@endnode

@node arr_maxz "arr_MaxZ()"
@prev arr_maxy
@next arr_setcell

  Syntax...: <1> := <2>.arr_MaxZ()
             <1> := <3>.arr_MaxZ()

  <1>: ist die Anzahl verfügbarer Zellen in "Z-Richtung"
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO bool3'

  Funktion: Diese Funktion liefert die Anzahl maximal verfügbarer
            Zellen in "Z-Richtung" zurück. Vergleiche dazu
            @{" arr_MaxX() " LINK arr_maxy} oder @{" arr_MaxY() " LINK arr_maxz} . 

@endnode

@node arr_setcell "arr_SetCell()"
@prev arr_maxz
@next arr_usedmem

  Syntax...: <01>.arr_SetCell(<07>,<08>,<10>)
             <02>.arr_SetCell(<07>,<08>,<09>,<10>)
             <03>.arr_SetCell(<07>,<08>,<11>)
             <04>.arr_SetCell(<07>,<08>,<09>,<11>)
             <05>.arr_SetCell(<07>,<11>)
             <06>.arr_SetCell(<07>,<11>)

  <01>: ist eine Variable vom Typ `PTR TO array2'
  <02>: ist eine Variable vom Typ `PTR TO array3'
  <03>: ist eine Variable vom Typ `PTR TO bool2'
  <04>: ist eine Variable vom Typ `PTR TO bool3'
  <05>: ist eine Variable vom Typ `PTR TO booleans'
  <06>: ist eine Variable vom Typ `PTR TO boolong'
  <07>: ist der Zellen-Index in "X-Richtung"
  <08>: ist der Zellen-Index in "Y-Richtung"
  <09>: ist der Zellen-Index in "Z-Richtung"
  <10>: ist ein dezimaler Wert, den die betreffende Zelle erhält
  <11>: ist ein boolescher Wert, den die betreffende Zelle erhält

  Funktion: Mit dieser Funktion kann man einer einzelnen Zelle
            einen bestimmten Wert zuweisen. Dieser Wert hängt
            lediglich davon ab, welcher Typ vom jeweiligen
            Objekt zugelassen ist. Diese Zell-Inhalte lassen
            sich mit @{" arr_GetCell() " LINK arr_getcell} wieder auslesen.

@endnode

@node arr_usedmem "arr_UsedMem()"
@prev arr_setcell
@next arr_end

  Syntax...: <1> := <2>.arr_UsedMem()
             <1> := <3>.arr_UsedMem()
             <1> := <4>.arr_UsedMem()
             <1> := <5>.arr_UsedMem()
             <1> := <6>.arr_UsedMem()
             <1> := <7>.arr_UsedMem()

  <1>: Speicherverbrauch in Bytes
  <2>: ist eine Variable vom Typ `PTR TO array2'
  <3>: ist eine Variable vom Typ `PTR TO array3'
  <4>: ist eine Variable vom Typ `PTR TO bool2'
  <5>: ist eine Variable vom Typ `PTR TO bool3'
  <6>: ist eine Variable vom Typ `PTR TO booleans'
  <7>: ist eine Variable vom Typ `PTR TO boolong'

  Funktion: Diese Funktion liefert den Speicherverbrauch eines
            Objektes zurück, wobei der Speicherbedarf der
            Datenstruktur mitberücksichtigt wird.

@endnode

@node arr_end "end()"
@prev arr_usedmem
@next arr_main

  Syntax...: END <1>
             END <2>
             END <3>
             END <4>
             END <5>

  <1>: ist eine Variable vom Typ `PTR TO array2'
  <2>: ist eine Variable vom Typ `PTR TO array3'
  <3>: ist eine Variable vom Typ `PTR TO bool2'
  <4>: ist eine Variable vom Typ `PTR TO bool3'
  <5>: ist eine Variable vom Typ `PTR TO booleans'

  Funktion: end() ist der sog. Destruktor, der die Aufgabe hat alle
            Initialisierungen rückgängig zu machen. Außerdem werden
            besetzte Speicherbereiche wieder freigegeben. Diese 
            Methode wird automatisch vom END-Statement aufgerufen,
            wobei sie selbst auf die Methode @{" arr_FreeArray() " LINK arr_freearray}
            zurückgreift.

@endnode
