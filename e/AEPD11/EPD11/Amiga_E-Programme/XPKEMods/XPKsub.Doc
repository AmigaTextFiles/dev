TABLE OF CONTENTS

xpksub.library/XpksPackerInfo
xpksub.library/XpksPackChunk
xpksub.library/XpksPackFree
xpksub.library/XpksPackReset
xpksub.library/XpksUnpackChunk
xpksub.library/XpksUnpackFree
xpksub.library/--sublibs--

xpksub.library/XpksPackerInfo

    NAME
	XpksPackerInfo - Get information about a packer sub-library

    SYNOPSIS
	info = XpkPackerInfo()
	 D0

	struct XpkInfo *XpkPackerInfo( void );

    FUNCTION
	Returns all information about a packer sub-library for use
	by the master library.

    RESULT
	info - pointer to struct XpkPackerInfo. see libraries/xpksub.h
	       for the meaning of all the fields.

    SEE ALSO
	XpksPackChunk()

xpksub.library/XpksPackChunk

    NAME
	XpksPackChunk - Pack a chunk of data

    SYNOPSIS
	err = XpksPackChunk( param )
	D0		      A0

	long XpksPackChunk( struct XpkSubParams * );

    FUNCTION
	Packs one chunk of data from memory to memory. The size of the 
	chunk will not surpass the MaxPkInChunk field of the packer info
	structure. Chunks are numbered in case a library writes various
	dictionaries at special places.

    INPUTS
	struct XpkSubParams, where the fields mean:
	  InBuf     Pointer to the data to be compressed
	  InLen     The number of bytes to pack
	  OutBuf    Pointer to the memory area to write packed data to
	  OutBufLen Size of above memory area
	  OutLen    Will be set to compressed length by sublib
	  Number    The number of this chunk
	  Mode      The sub-mode to be used
	  Password  The password to be used for encryption
	  Sub[4]    Here the sub library stores its private data

    RESULTS
	err    - global xpk error code
	OutLen - Number of bytes written

    SEE ALSO
	XpksPackReset(), XpksPackFree()
xpksub.library/XpksPackFree

    NAME
	XpksPackFree - Free buffers associated with packing process

    SYNOPSIS
	XpksPackFree( param )
		       A0

	void XpksPackFree( struct XpkSubParams * )

    FUNCTION
	Frees all buffers the sub-library has allocated privately
	while doing some packing

    INPUTS
	param - The XpkSubParams used for packing

    SEE ALSO
	XpksPackChunk(), XpksPackReset()

xpksub.library/XpksPackReset

    NAME
	XpksPackReset - Reset all internal tables

    SYNOPSIS
	XpksPackReset( param )
			A0

	long XpksPackReset( struct XpkSubParams * )

    FUNCTION
	Clears all internal tables of the packer that prevent independent
	unpacking of the chunk to come. The packers call this function
	automatically before returning XPKERR_EXPANSION (data could not
	be compressed).

    INPUTS
	param - The XpkSubParams used for packing

    SEE ALSO
	XpksPackChunk(), XpksPackFree()
xpksub.library/XpksUnpackChunk

    NAME
	XpksUnpackChunk - Uncompress a chunk of data

    SYNOPSIS
	err = XpksUnpackChunk( param )
				A0

	long XpksUnpackChunk( struct XpkSubParams * )

    FUNCTION
	Decompresses one chunk of data.

    INPUTS
	param - The XpkSubParams used for unpacking
	  InBuf     Pointer to the data to be uncompressed
	  InLen     The number of bytes to unpack
	  OutBuf    Pointer to the memory area to write unpacked data to
	  OutBufLen Size of above memory area
	  OutLen    Must contain the decompressed size of the data
	  Number    The number of this chunk
	  Password  The password to be used for decryption
	  Sub[4]    Here the sub library stores its private data
	

    RESULT
	err - global xpk error code

    SEE ALSO
	XpksUnpackFree()
xpksub.library/XpksUnpackFree

    NAME
	XpksUnpackFree - Free all private data the sublib has allocated

    SYNOPSIS
	XpksUnpackFree( param )
			  A0

	long XpksUnpackFree( struct XpkSubParams * )

    FUNCTION
	Will free all memory the sub-library has allocated during the
	decompression.

    INPUTS
	param - The XpkSubParams used for unpacking

    SEE ALSO
	XpksUnpackChunk()
xpksub.library/--sublibs--

How XpkPackChunk works:

- Check xpar->Sub[0]. If it's 0, this is the first call. Allocate your tables
  and store pointers to them in Sub[0] .. Sub[3].
- Read xpar->InLen bytes from xpar->InBuf and pack them to xpar->OutBuf.
  Don't exceed xpar->OutBufLen. Store packed len in xpar->OutLen.

How XpkUnpackChunk works:
- Check xpar->Sub[0]. If it's 0, this is the first call. Allocate your tables
  and store pointers to them in Sub[0] .. Sub[3].
- Read xpar->InLen bytes from xpar->InBuf and unpack them to xpar->OutBuf.
  Don't exceed xpar->OutBufLen. Maybe compare uncompressed len with 
  xpar->OutLen.

Some notes for sub library writers:

- Your library should, of course, be re-entrant. This means no PC-relative
  addressing of writeable data. Whatever you have, store a pointer to it
  somewhere in the XpkSubMessage. You can detect the first chunk of a file
  by the fact that this pointer is still NULL.

- There will be no larger chunks on (de)compression than the first one.

- On compression, you may expand the data by XPK_MARGIN bytes maximum. This
  means the output buffer is as large as the input buffer plus XPK_MARGIN.
  Compression libs would, of course, already return XPKERR_EXPANSION if
  they exceed the input buffer by more than, say, 10 bytes.

- You must supply a function XpkPackReset, which clears all tables so
  that the next chunk will be able to be unpacked independently.

- After an expansion, you have to call XpkPackReset by yourself.

- On decompression, you will also have a XPK_MARGIN byte saftey margin for
  runaway unpacking. 
