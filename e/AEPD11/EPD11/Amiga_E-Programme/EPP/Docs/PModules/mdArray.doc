~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                     Multi-Dimensional Arrays in E
                           by Barry Wills

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Disclaimer.
~~~~~~~~~~
   The user of this software assumes all risk.  This software is hereby
   placed in the public domain.


What is it?
~~~~~~~~~~
   Create and use multi-dimensional arrays of any dimension in E by using
   these routines.  The demos in this distribution use 3d arrays, but you
   are by no means limited to these!


Constants.
~~~~~~~~~
   CONST SIZEOF_CHAR = 1
   CONST SIZEOF_INT  = 2
   CONST SIZEOF_LONG = 4

   These are passed into the function md_dim () via parameter elementSize.
   They represent the size in bytes of the largest value which can be held
   by an element of the array:  character is 1 byte, integer is 2 bytes,
   long integer is 4 bytes.


Types.
~~~~~
   OBJECT md_arrayType
     uBound             : LONG
     elementSize        : LONG
     numberOfDimensions : LONG
     sizeOfDimension    : LONG
     elements           : LONG
   ENDOBJECT

   Declare a variable of this type for each array.  (NOTE:  If you declare a
   "PTR TO md_arrayType" *YOU* must create and destroy it using New () and
   Dispose() )

   The components herein are read-only!  Change the values in this object
   at your own risk!  If you want to bypass the provided functions, then
   study the code to see how these are used.


Variables.
~~~~~~~~~
   DEF md_constraintError = -1

   Assign to this variable the value of the exception that you want functions
   md_set() and md_get() to raise if an attempt is made to access an array
   out of bounds.  The default value of NIL indicates that boundary
   violations will not be reported nor handled (i.e., they will be ALLOWED
   to occur.)


Functions.
~~~~~~~~~
PROC md_dim (array     : PTR TO md_arrayType,
             indexList : PTR TO LONG,
             elementSize)

   Description.  Create private array data.
   Arguments.  "array" is a static (or previously allocated) variable of type
               md_arrayType.  "indexList" is a List variable of any length
               which specifies the dimensions of the array.  "elementSize" is
               one of the three provided constants described above.


PROC md_set (array     : PTR TO md_arrayType,
             indexList : PTR TO LONG,
             value)

   Description.  Put a value into an element of the array.
   Arguments.  "array" is a valid array as initialized by the function
               md_dim().  "indexList" is a List variable whose length is the
               same as the number of dimensions as specified by the
               "indexList" passed to md_dim().  "value" is the value to be
               stored in the element.


PROC md_get (array     : PTR TO md_arrayType,
             indexList : PTR TO LONG)

   Description.  Get a value from an element of the array.  This function
               requires an lvalue.
   Arguments.  "array" is a valid array as initialized by the function
               md_dim().  "indexList" is a List variable whose length is the
               same as the number of dimensions as specified by the
               "indexList" passed to md_dim().


PROC md_dispose (array : PTR TO md_arrayType)

   Description.  Deallocate private array data.
   Arguments.  "array" is a valid array as initialized by the function
               md_dim().


PROC md_offset (array     : PTR TO md_arrayType,
                indexList : PTR TO LONG)

   Description.  Computes the number of bytes beyond the starting address of
                 the array which correspond to the indices.  There is no
                 requirement for the programmer to ever call this explicitly.
   Arguments.  "array" is a valid array as initialized by the function
               md_dim().  "indexList" is a List variable whose length is the
               same as the number of dimensions as specified by the
               "indexList" passed to md_dim().


PROC md_withinBounds (array     : PTR TO md_arrayType,
                      indexList : PTR TO LONG)

   Description.  Checks the indices to ensure that they are within bounds.
               There is no requirement for the programmer to ever call this
               explicitly.
   Arguments.  "array" is a valid array as initialized by the function
               md_dim().  "indexList" is a List variable whose length is the
               same as the number of dimensions as specified by the
               "indexList" passed to md_dim().


PROC listItem (listVar : PTR TO LONG, item)

   Description.  Returns the specified element of a list.  There is no
                 requirement for the programmer to ever call this explicitly.
   Arguments.  "listVar" is a List variable of any length.  "item" is a LONG
               value which specifies the index of "listVar".  Useful if
               referencing a list in an object, e.g.,
               myValue := listItem (object.list, 0).


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
These are figures to show the computation of the array offset as if it were
hard-coded instead of programmed.  The array offset is the number of bytes
beyond the starting address of array which correspond to the indices.

NOTE:  sizeOfDimension holds the size of a single row in elements, not bytes.

1d array, 5 characters:

  uBound             =[4]
  elementSize        =[1]
  numberOfDimensions =[1]
  sizeOfDimension    =[1]

  [0] = (0*1) = 0
  [1] = (1*1) = 1
  [2] = (2*1) = 2
  [3] = (3*1) = 3
  [4] = (4*1) = 4


2d array, 2 * 3 integers:

  uBound             =[2,3]
  elementSize        =[2]
  numberOfDimensions =[2]
  sizeOfDimension    =[3,1]

  [0,0] = (0*3) + (0*1) =  0
  [0,1] = (0*3) + (1*1) =  2
  [0,2] = (0*3) + (2*1) =  4
  [1,0] = (1*3) + (0*1) =  6
  [1,1] = (1*3) + (1*1) =  8
  [1,2] = (1*3) + (2*1) = 10


3d array, 2 * 2 * 2 long integers:

  uBound             =[2,2,2]
  elementSize        =[4]
  numberOfDimensions =[3]
  sizeOfDimension    =[4,2,1]

  [0,0,0] = (0*4) + (0*2) + (0*1) =  0
  [0,0,1] = (0*4) + (0*2) + (1*1) =  4
  [0,1,0] = (0*4) + (1*2) + (0*1) =  8
  [0,1,1] = (0*4) + (1*2) + (1*1) = 12
  [1,0,0] = (1*4) + (0*2) + (0*1) = 16
  [1,0,1] = (1*4) + (0*2) + (1*1) = 20
  [1,1,0] = (1*4) + (1*2) + (0*1) = 24
  [1,1,1] = (1*4) + (1*2) + (1*1) = 28


3d array, 3 * 3 * 4 characters:

  uBound             =[3,3,4]
  elementSize        =[1]
  numberOfDimensions =[3]
  sizeOfDimension    =[12,4,1]

  [0,0,0] = (0*12) + (0*4) + (0*1) =  0
  [0,0,1] = (0*12) + (0*4) + (1*1) =  1
  [0,0,2] = (0*12) + (0*4) + (2*1) =  2
  [0,0,3] = (0*12) + (0*4) + (3*1) =  3
  [0,1,0] = (0*12) + (1*4) + (0*1) =  4
  [0,1,1] = (0*12) + (1*4) + (1*1) =  5
  [0,1,2] = (0*12) + (1*4) + (2*1) =  6
  [0,1,3] = (0*12) + (1*4) + (3*1) =  7
  [0,2,0] = (0*12) + (2*4) + (0*1) =  8
  [0,2,1] = (0*12) + (2*4) + (1*1) =  9
  [0,2,2] = (0*12) + (2*4) + (2*1) = 10
  [0,2,3] = (0*12) + (2*4) + (3*1) = 11
  [1,0,0] = (1*12) + (0*4) + (0*1) = 12
  [1,0,1] = (1*12) + (0*4) + (1*1) = 13
  [1,0,2] = (1*12) + (0*4) + (2*1) = 14
  [1,0,3] = (1*12) + (0*4) + (3*1) = 15
  [1,1,0] = (1*12) + (1*4) + (0*1) = 16
  [1,1,1] = (1*12) + (1*4) + (1*1) = 17
  [1,1,2] = (1*12) + (1*4) + (2*1) = 18
  [1,1,3] = (1*12) + (1*4) + (3*1) = 19

  ...and so on...

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~