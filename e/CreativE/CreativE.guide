@database  CreativE.guide
@AUTHOR   Tomasz   Wiszkowski
@$VER: CreativE guide v2.x by Error/BlaBla
@font xhelvetica.font 11
@wordwrap

@REMARK B Main
@NODE main CreativE

@REMARM @{b}
@REMARK          ______________________________  ____  ______
@REMARK         /'__/',_/'._/', /' _/'/'/ /'._/ /-__/ /'/-__/
@REMARK        /___/_/_/___/_/_//_//_/\__/___/ /___/./_/___/
@REMARK
@REMARK @{ub}

    @{fg fill}@{b} CreativE 2.12 @{fg text}@{ub} @{b}[mailware]@{ub}
    ~~~~~~~~~~~~~~
    @{"   " LINK INTRO} Introduction
    @{"   " LINK COMPATIBILITY} Compatibility
    @{"   " LINK NEWCOMMANDS} Commands
    @{"   " LINK PREPROCESSOR} Preprocessor
    @{"   " LINK NEWKEYWORDS} Keywords
    @{"   " LINK NEWVARIABLES} Variables
    @{"   " LINK NEWCONSTS} Constants
    @{"   " LINK NEWOPERS} Operators
    @{"   " LINK LONGSTRINGS} LONG strings
    @{"   " LINK NORMALSTRINGS} Normal strings
    @{"   " LINK FORMATIO} Formatted I/O
    @{"   " LINK ASSEMBLER} Assembler part
    @{"   " LINK PATCHER} Patcher
    @{"   " LINK ERRORS} Error messages
    @{"   " LINK INLINE} Inline cmds
    @{"   " LINK OTHER} Others
    @{"   " LINK PROBLEMS} Other problems

    @{"   " LINK THANKS} Thanks
    @{"   " LINK ERROR} Author

    @{"   " LINK HISTORY} History

  @{b}IMPORTANT NOTES @{ub}
    -. please read the .readme also.
    -. please recompile all the modules compiled with the 2.10ß as those can no longer be used.
    -. A few changes has been made comparing to 2.10ß that make the 2.10ß partially incompatible with newer versions. These are:
       a. module format
       b. ENDPROC WITH RTE
    -. This is probably the last version based on Wouter's code. The updates will appear if any bugs are reported. If everything goes well, the completely new version will appear in 2k1... let's hope :)
    -. Did I mention that it's emailware? :) ok. If You don't care, I am not going to do so, too. I received a couple of emails since last year from CreativE users [greetings to all of You people]. Email isn't that much [I hope], so - CreativE's future is in Your hands. I hope to receive at least 20 emails from all of You. If You don't care about it - this is the end of CreativE. This project takes a bit too much time to release it for nobody. Sorry.
    
    AmigaE Support site:
        @{b}http://strony.poland.com/creative
    @{ub}
    I would like to make it some kind of real support site. If You have anything You'd like to share with other E programmers, please send it to me and I will put it on my web page. Remember about short description :)

@ENDNODE
@REMARK E
@REMARK B INTRO
@NODE INTRO "Introduction"

    At least after long fights against the difficulties I can bring to You some new stuff to compile Your E programs :). CreativE is an AmigaE compiler which offers You many new improvements and features. The current version seems to have really much less bugs than any other version [it seems to be a good idea - release new versions after heavier tests hehe ;)]. Just take a look what it brings to You 8D.

    Please remember that You're using this compiler on Your own risk!. I don't take responsibility of any damage caused by this program.

@ENDNODE
@REMARK E
@REMARK B COMPATIBILITY
@NODE COMPATIBILITY Compatibility

        @{b}String formatting@{ub}

    There is a problem with a "%" sign. EC v3.3a used to placing a normal percent char there. CreativE lets you use C alike format strings (%ld, %s etcetera). That's why you MUST place two signs (%%) to get this character in output string [this bug concerns only functions using formatted output, i.e. WriteF, PrintF, Vfprintf etc.).
@ENDNODE
@REMARK E
@REMARK B NEWCOMMANDS
@NODE NEWCOMMANDS "New commands"

    @{"   " LINK 0000} Alloc()
    @{"   " LINK 0001} Chk()
    @{"   " LINK 0002} CoerceMethod()
    @{"   " LINK 0002} CoerceMethodA()
    @{"   " LINK 0003} CtrlD()
    @{"   " LINK 0003} CtrlE()
    @{"   " LINK 0003} CtrlF()
    @{"   " LINK 0004} DoMethod()
    @{"   " LINK 0004} DoMethodA()
    @{"   " LINK 0005} DoSuperMethod()
    @{"   " LINK 0005} DoSuperMethodA()
    @{"   " LINK 0006} Eof()
    @{"   " LINK 0007} Fclose()
    @{"   " LINK 0008} Fopen()
    @{"   " LINK 0009} Free()
    @{"   " LINK 000a} Get()
    @{"   " LINK 000b} GetA4()
    @{"   " LINK 000a} Gets()
    @{"   " LINK 0013} Lsl()
    @{"   " LINK 0013} Lsr()
    @{"   " LINK 000e} PutF()
    @{"   " LINK 000f} ReadB()
    @{"   " LINK 0010} Set()
    @{"   " LINK 0010} Sets()
    @{"   " LINK 0011} Size()
    @{"   " LINK 0012} WriteB()

@ENDNODE
@REMARK B Commands
@REMARK B 0000 Alloc()
@NODE 0000 Alloc()

    @{fg fill}@{b}Alloc()@{fg text}@{ub}

  SYNOPSIS
    mem:=Alloc(size)

  FUNCTION
    Function allocates POOL memory if it is present.

  INPUTS
    @{b}size@{ub} - size of memory to alloc

  RESULT
    @{B}mem@{ub} - pointer to allocated memory or 0 if allocation failed

  NOTE
    - OPT POOL must be specified

  SEE ALSO
    @{" Free() " LINK 0009}

@ENDNODE
@REMARK E
@REMARK B 0001 Chk()
@NODE 0001 Chk()

    @{b}@{fg fill}Chk()@{ub}@{fg text}

  SYNOPSIS
    bool:=Chk(a)

  FUNCTION
    Function checks parameter and returns FALSE if it is equal to 0 or TRUE if it's not.

  INPUTS
    @{b}a@{ub} - variable, expression or anything else to be checked

  RESULT
    @{b}bool@{ub} - boolean value

  SEE ALSO

@ENDNODE
@REMARK E
@REMARK B 0002 CoerceMethod()/CoerceMethodA()
@NODE 0002 CoerceMethod()/CoerceMethodA()

    @{b}@{fg fill}CoerceMethod()/CoerceMethodA()@{ub}@{fg text}

  SYNOPSIS
    res:=CoerceMethod(class, object, message, ...)
    res:=CoerceMethodA(class, object, message)

  FUNCTION
    Function invokes the supplied message on the specific object as though it were the specified class

  INPUTS
    @{b}class@{ub} - pointer to boopsi class
    @{b}object@{ub} - pointer to boopsi object
    @{b}message@{ub} - method-specific message to be send

  RESULT
    @{b}res@{ub} - class and message specific result

  NOTE
    This function is v36+ only!

  SEE ALSO
    @{" DoMethod() " LINK 0004}, @{" DoSuperMethod() " LINK 0005}

@ENDNODE
@REMARK E
@REMARK B 0003 CtrlD()/CtrlE()/CtrlF()
@NODE 0003 CtrlD()/CtrlE()/CtrlF()

    @{b}@{fg fill}CtrlD()/CtrlE()/CtrlF()@{ub}@{fg text}

  SYNOPSIS
    bool:=CtrlD()
    bool:=CtrlE()
    bool:=CtrlF()

  FUNCTION
    Functions check for break signals and return TRUE if the signal was received

  INPUTS
    none

  RESULT
    @{b}bool@{ub} - holds TRUE if break signal was received

  SEE ALSO

@ENDNODE
@REMARK E
@REMARK B 0004 DoMethod()/DoMethodA()
@NODE 0004 DoMethod()/DoMethodA()

    @{b}@{fg fill}DoMethod()/DoMethodA()@{ub}@{fg text}

  SYNOPSIS
    res:=DoMethod(object, message, ...)
    res:=DoMethodA(object, message)

  FUNCTION
    Function invokes the supplied message on the specified object

  INPUTS
    @{b}object@{ub} - pointer to boopsi object
    @{b}message@{ub} - method-specific message to be send

  RESULT
    @{b}res@{ub} - object and message specific result

  NOTE
    This function is v36+ only!

  SEE ALSO
    @{" CoerceMethod() " LINK 0002}, @{" DoSuperMethod() " LINK 0005}

@ENDNODE
@REMARK E
@REMARK B 0005 DoSuperMethod()/DoSuprMethodA()
@NODE 0005 DoMethod()/DoMethodA()

    @{b}@{fg fill}DoSuperMethod()/DoSuperMethodA()@{ub}@{fg text}

  SYNOPSIS
    res:=DoSuperMethod(class, object, message, ...)
    res:=DoSuperMethodA(class, object, message)

  FUNCTION
    Function invokes the supplied message on the specified object though as it were the superclass of the specified class

  INPUTS
    @{b}class@{ub} - pointer to boopsi class
    @{b}object@{ub} - pointer to boopsi object
    @{b}message@{ub} - method-specific message to be send

  RESULT
    @{b}res@{ub} - class and message specific result

  NOTE
    This function is v36+ only!

  SEE ALSO
    @{" CoerceMethod() " LINK 0002}, @{" DoMethod() " LINK 0004}

@ENDNODE
@REMARK E
@REMARK B 0006 Eof()
@NODE 0006 Eof()

    @{b}@{fg fill}Eof()@{ub}@{fg text}

  SYNOPSIS
    bool:=Eof(fh)

  FUNCTION
    Function checks if the EOF has been reached

  INPUTS
    @{b}fh@{ub} - pointer to DOS filehandle structure

  RESULT
    @{b}bool@{ub} - holds TRUE if the file reached EOF, otherwise it's false

  SEE ALSO
    @{" Size() " LINK 0011}
@ENDNODE
@REMARK E
@REMARK B 0007 Fclose()
@NODE 0007 Fclose()

    @{b}@{fg fill}Fclose()@{ub}@{fg text}

  SYNOPSIS
    Fclose(fh)

  FUNCTIONS
    Function closes file opened previously with Fopen()

  INPUTS
    @{b}fh@{ub} - filehandle obtained from Fopen()

  RESULT
    none

  SEE ALSO
    @{" Fopen() " LINK 0008}
@ENDNODE
@REMARK E
@REMARK B 0008 Fopen()
@NODE 0008 Fopen()

    @{b}@{fg fill}Fopen()@{ub}@{fg text}

  SYNOPSIS
    fh:=Fopen(name, mode)

  FUNCTION
    function opens DOS file using standard Open() command and stores the filehandle in global list of filehandles. All the opened files are closed automatically at the end of program

  INPUTS
    @{b}name@{ub} - name of file to be opened
    @{b}mode@{ub} - open file mode

  RESULT
    @{b}fh@{ub} - filehandle that can be used with any DOS command

  SEE ALSO
    @{" Fclose() " LINK 0007}, @{" ReadB() " LINK 000f}, @{" WriteB() " LINK 0012}

@ENDNODE
@REMARK E
@REMARK B 0009 Free()
@NODE 0009 Free()

    @{b}@{fg fill}Free()@{ub}@{fg text}

  SYNOPSIS
    Free(mem)

  FUNCTION
    Function disposes memory allocated previously with Alloc() command

  INPUTS
    @{b}mem@{uB} - pointer to memory obtained from Alloc()

  RESULT
    none

  SEE ALSO
    @{" Alloc() " LINK 0000}
@ENDNODE
@REMARK E
@REMARK B 000a Get()/Gets()
@NODE 000a Get()/Gets()

    @{b}@{fg fill}Get()/Gets()@{ub}@{fg text}

  SYNOPSIS
    res:=Get(object, attr, store)
    res:=Gets(object, attr)

  FUNCTION
    Ask specified object for a value assigned to specified attribute

  INPUTS
    @{B}object@{UB} - pointer to boopsi object
    @{B}attr@{UB} - attribute tag id
    @{B}store@{UB} - pointer to storage for the answer

  RESULT
    @{B}res@{ub} - value assigned to specified attribute (Gets);
          FALSE if the inquiries of attribute are not provided by the object's class (Get)

  NOTE
    This function is v36+ only!

  SEE ALSO
    @{" Set() " LINK 0010}

@ENDNODE
@REMARK E
@REMARK B 000b GetA4()
@NODE 000b GetA4()

    @{b}@{fg fill}GetA4()@{ub}@{fg text}

  SYNOPSIS
    GetA4()

  FUNCTION
    Restore A4 register

  INPUTS
    none

  RESULT
    none

  NOTE
    - This function doesn't have to be called before use, therefore You can use it only where needed.
    - Doesn't work in library mode.

  BUGS
    None known.

  SEE ALSO
@ENDNODE
@REMARK E
@REMARK B 000e PutF()
@NODE 000e PutF()

    @{b}@{fg fill}PutF()@{ub}@{fg text}

  SYNOPSIS
    PutF(fh, formatstr, args...)

  FUNCTION
    Function writes formatted string to selected filehandle

  INPUTS
    @{B}fh@{UB} - filehandle
    @{B}formatstr@{UB} - C or E alike formatstring
    @{b}args@{ub} - list of arguments

  RESULT
    none

  SEE ALSO
@ENDNODE
@REMARK E
@REMARK B 000f ReadB()
@NODE 000f ReadB()

    @{b}@{fg fill}ReadB()@{ub}@{fg text}

  SYNOPSIS
    blks:=ReadB(fh, blksize, numblocks, mem)

  FUNCTION
    This function reads numblocks blocks of size specified in blksize into continuous memory starting at mem

  INPUTS
    @{b}fh@{ub} - DOS filehandle
    @{B}blksize@{UB} - size of one block
    @{B}numblocks@{UB} - number of blocks to be read
    @{B}mem@{UB} - memory location to store blocks

  RESULT
    @{B}blks@{UB} - number of read blocks

  SEE ALSO
    @{" WriteB() " LINK 0012}
@ENDNODE
@REMARK E
@REMARK B 0010 Set()/Sets()
@NODE 0010 Set()/Sets()

    @{b}@{fg fill}Set()/Sets()@{ub}@{fg text}

  SYNOPSIS
    Set(object, attr, value, ...)
    Sets(object, attr, value)

  FUNCTION
    Assign a value assigned to specified attribute of the object

  INPUTS
    @{B}object@{UB} - pointer to boopsi object
    @{B}attr@{UB} - attribute tag id
    @{B}value@{UB} - value to be assigned to the attribute

  RESULT
    none

  NOTE
    This function is v36+ only!

  SEE ALSO
    @{" Get() " LINK 000a}

@ENDNODE
@REMARK E
@REMARK B 0011 Size()
@NODE 0011 Size()

    @{b}@{fg fill}Size()@{ub}@{fg text}

  SYNOPSIS
    len:=Size(fh)

  FUNCTION
    returns file size

  INPUTS
    @{B}fh@{UB} - DOS filehandle

  RESULT
    @{B}len@{UB} - file size

  SEE ALSO
    @{" Eof() " LINK 0006}
@ENDNODE
@REMARK E
@REMARK B 0012 WriteB()
@NODE 0012 WriteB()

    @{b}@{fg fill}WriteB()@{ub}@{fg text}

  SYNOPSIS
    blks:=WriteB(fh, blksize, numblocks, mem)

  FUNCTION
    writes numblocks blocks of size specified in blksize from continuous memory starting at mem

  INPUTS
    @{B}fh@{UB} - DOS filehandle
    @{B}blksize@{UB} - size of one block
    @{B}numblocks@{UB} - number of blocks to be read
    @{B}mem@{UB} - memory location storing blocks

  RESULT
    @{B}blks@{UB} - number of written blocks

  SEE ALSO
    @{" ReadB() " LINK 000f}
@ENDNODE
@REMARK E
@REMARK B 0013 Lsd()
@NODE 0013 Lsd()

    @{b}@{fg fill}Lsl() / Lsr()@{ub}@{fg text}

  SYNOPSIS
    x:=Lsl(y,s)
    x:=Lsr(y,s)

  FUNCTION
    Performs logical shift left / right

  INPUTS
    @{B}y@{UB} - variable to be shifted
    @{B}s@{UB} - number of shifts

  RESULT
    @{B}x@{UB} - shifted output

  SEE ALSO

@ENDNODE
@REMARK E
@REMARK E
@REMARK E
@REMARK B NewKeywords
@NODE NEWKEYWORDS "New Keywords"

    @{"   " LINK K0010} CLEANUP
    @{"   " LINK K0012} CODE
    @{"   " LINK K0013} CONST
    @{"   " LINK K000A} ENDPROC
    @{"   " LINK K0011} EXTRA
    @{"   " LINK K0009} FOR
    @{"   " LINK K000C} FPEXP
    @{"   " LINK K0006} INCLIB
    @{"   " LINK K0004} INLINE
    @{"   " LINK K0000} LINKABLE
    @{"   " LINK K0008} LONG
    @{"   " LINK K0001} NOSTARTUP
    @{"   " LINK K0002} POOL
    @{"   " LINK K000D} RUNBG
    @{"   " LINK K000F} SETUP
    @{"   " LINK K0007} STARTUP
    @{"   " LINK K0005} UNION
    @{"   " LINK K0003} UTILLIB
    @{"   " LINK K000B} WHILE
@ENDNODE
@REMARK B K0000 LINKABLE
@NODE K0000 LINKABLE

    @{b}@{fg fill}OPT LINKABLE@{ub}@{fg text}

  USAGE
    OPT LINKABLE

  ABOUT
    This option allows You creating linkable object code (.o) instead of normal executable or library one.

  NOTE
    object has no references specified and therefore might be used only with E

@ENDNODE
@REMARK E
@REMARK B K0001 NOSTARTUP
@NODE K0001 NOSTARTUP

    @{b}@{fg fill}OPT NOSTARTUP@{ub}@{fg text}

  USAGE
    OPT NOSTARTUP

  ABOUT
    This option lets You use Your own startup code. No libraries are opened and nothing is initialized (except execbase and stack) in Your output code, You have to do everythnig Yourself. It is made especially for those who want to make really small progs ;).

  NOTE
    arg string is placed in A0, not in the arg variable. You must initialize all the resources You want to use Yourself. Only memory allocated with New() and files opened with Fopen() are closed at the end.

@ENDNODE
@REMARK E
@REMARK B K0002 POOL
@NODE K0002

    @{b}@{fg fill}OPT POOL@{ub}@{fg text}

  USAGE
    OPT POOL (memtype, puddlesize, threshsize)

  ABOUT
    This switch lets You create pool that can be used later in Your program e.g. via @{" Alloc " LINK 0000} or anything else. Pool pointer is stored in @{" __pool " LINK NEWVARIABLES} variable. Parameters are optional, so You can write simply OPT POOL to use it.

  NOTE
    This is v39+ only!
@ENDNODE
@REMARK E
@REMARK B K0003 UTILLIB
@NODE K0003 UTILLIB

    @{b}@{fg text}OPT UTILLIB@{ub}@{fg text}

  USAGE
    OPT UTILLIB

  ABOUT
    This switch links utility.library support to Your code. Some utility functions are used by @{" patched " LINK NEWPATCHES} commands. All the offsets appear automatically when You simply switch this option on.

  NOTE
    This is v37+ only!

@ENDNODE
@REMARK E
@REMARK B K0004 INLINE
@NODE K0004 INLINE
    @{b}@{fg fill}OPT INLINE@{fg text}@{ub}

  USAGE
    OPT INLINE

  ABOUT
    This option marks some -short- E internal commands to be placed in the code as inline functions. This makes Your programs faster, but also a bit longer. Inline command list can be found @{"here" LINK INLINE}

@ENDNODE
@REMARK E
@REMARK B K0005 UNION
@NODE K0005
    @{b}UNION@{ub}

  USAGE
    @{b}UNION [ [a],[b], ... ]@{ub}

  ABOUT
    Since 2.04 it is possible to @{b}UNION@{ub} some members in object definition; the main rules are:
    - All the members that needs to be unified must be placed in "[]"
    - Each "[]" repressents one group of members to union
    - Union must start with "[" and end with "]".
    - All members must be separated with commas (",")
    - members that follow each union start after the biggest unioned group
    - union declaration may be spreaded into several lines

  EXAMPLE
@{i}
    OBJECT a
        UNION
        [
            [
                a, b, c
            ],[
                d:INT, e:INT, f:INT
            ],[
                g:CHAR, h:CHAR, i:CHAR
            ]
        ]
        j
    ENDOBJECT
@{ui}
    will produce:
@{I}
    (----) OBJECT a
    (   0)   a:LONG
    (   4)   b:LONG
    (   8)   c:LONG
    (   0)   d:INT
    (   2)   e:INT
    (   4)   f:INT
    (   0)   g:CHAR
    (   1)   h:CHAR
    (   2)   i:CHAR
    (  12)   j:LONG
    (----) ENDOBJECT     /* SIZEOF=16 */
@{ui}
@ENDNODE
@REMARK E
@REMARK B K0006 INCLIB
@NODE K0006 "Lib support"
  @{b}INCLIB@{ub}

  USAGE
    @{b}INCLIB 'libname', 'libname'...@{ub}

  ABOUT
    This stuff allows You to make use of object files.

    The main requirement (hehe ;) is to have an "ELIB:" assignment (suggested place: "E:LIB"). For each object two files must exist:
        - @{b}*.lib@{ub} - the main LIB file [object]
        - @{b}*.m@{ub} - description module

    module format is very simple; You can use only PROCs, INLINEs and STARTUPs. Comments are also supported - "//", "->" and "/* */".

    To make a .lib file, You need a good assembler [AsmOne is recommended]. The internal variables You want to use must be XREFfed [see: @{" Variables " LINK K0006_x001}]. To get the proper output, You need to compile Your file and write it as linkable object. To add new functions to Your lib file, simply append new objects to the lib.

    @{"   " LINK K0006_0001} PROC
    @{"   " LINK K0006_0002} INLINE
    @{"   " LINK K0006_0003} STARTUP

    @{"   " LINK K0006_x001} Variables

  NOTES
    - only RELOC32 reloc hunk type is supported
    - a small check is performed to find the best entry, when more than one command with the same name is met. It means that if You link two commands - one for OS33 and one for OS39 and set up the OSVERSION to 39, the first one is discarded even if is met first.

  BUGS
    None found

@ENDNODE
@REMARK E
@REMARK B K0006_0001
@NODE K0006_0001 "PROC"
    @{b}PROC Whatever(x,y,z...)@{ub}

    This works almost exactly same as the EC internal functions (e.g. WriteF). There's only one difference - linked procs don't support streams of parameters. If You want to send a stream, You must use an array of elements. The parameters are stored on stack in reverse order. Please note that the contents of regs D3-D7/A4/A5 MUST be kept, all the other registers may be changed. The result should be returned in D0 [and the second one in D1]. Now - example:

    Write sth. like e.g.
    @{i}
        MOVE.L  4(A7),A0
        MOVE.L  8(A7),(A0)
        RTS
    @{ui}
    Compile and write as link; note that ".lib" suffix is necessary . Now run an editor (ced, ged or whatever) and write sth like:
    @{i}
    PROC PutLong(what,where)
    @{ui}
    and save with same name but different suffix (this time - ".m"). Now write a program, e.g.
    @{i}
    INCLIB 'YourLib'
    PROC main()
        DEF a

        PutLong(5, {a})
    ENDPROC
    @{ui}
    This will change the internal "PutLong" function with the new one You wrote.

    Big advantage of lib files here is that not whole lib is included; only used parts are linked.

@ENDNODE
@REMARK E
@REMARK B K0006_0002
@NODE K0006_0002 "INLINE"
    @{b}INLINE Whatever(x:Rx,y:Ry,z:Rz...)@{ub}

    INLINE lib function is a quite interesting thing ;). It works almost like PROCs, but the difference is that inlines are placed directly in call-place. Also, the structure is different. The first longword of code must contain the length (in bytes) of code to be copied; Example: Write sth. like e.g.
    @{i}
        DC.L    END-START
    START:
        MOVE.L  D0,(A0)
    END:
    @{ui}
    Compile and write as link; note that ".lib" suffix is necessary . Now run an editor (ced, ged or whatever) and write sth. like:
    @{i}
    INLINE PutLong(what:D0,where:A0)
    @{ui}
    and save with same name but different suffix (this time - ".m"). Now write a program, e.g.
    @{i}
    INCLIB 'YourLib'
    PROC main()
        DEF a

        PutLong(5, {a})
    ENDPROC
    @{ui}
    This will change the internal "PutLong" function with the new one You wrote.
    Please note that the first longword determines the size of Your procedure which MUST BE even!
@ENDNODE
@REMARK E
@REMARK B K0006_0003
@NODE K0006_0003 "STARTUP"
    @{b}STARTUP CODENAME@{ub}

    this defines a startup code. The startup code is a code that initializes all the system variables before the main procedure is launched. The name of a startup code must be defined with capital letters. Startups do not take _any_ parameters. This type is a bit dangerous stuff for a novice programmer and hence shouldn't be used by them.
@ENDNODE
@REMARK E
@REMARK B K0006_x001
@NODE K0006_x001 "Variables"
    @{b} V A R I A B L E S @{ub}

    This is the list of accessible variables (LIB level only!). Note that the name parser is case insensitive, so You can write "_DOSBASE" and "_dosbase", which mean the same. Ok, the list. First - A4 offsets, normal code:
    @{b}_dosbase@{ub} - dos base
    @{b}_gfxbase@{ub} - graphics base
    @{b}_intuitionbase@{ub} - intuition base
    @{b}_utilitybase@{ub} - utility base
    @{b}_mathieeesingbasbase@{ub} - mathieeesingbas base
    @{b}_mathieeesingtransbase@{ub} - mathieeesingtrans base
    @{b}_stdin@{ub} - standard input
    @{b}_stdout@{ub} - standard output
    @{b}_stdrast@{ub} - standard rastport
    @{b}_pool@{ub} - pool pointer
    @{b}_arg@{ub} - argument string
    @{b}_exception@{ub} - exception variable
    @{b}_exceptioninfo@{ub} - exceptioninfo variable
    @{b}_wbmessage@{ub} - workbench message

    A4 offsets, startup code - above plus:
    @{b}_stkret@{ub} - return stack store - used with CleanUp()
    @{b}_memlist@{ub} - memory list
    @{b}_exitcode@{ub} - exit code jump pointer
    @{b}_clireturnvalue@{ub} - value to be returned to CLI
    @{b}_bottomstk@{ub} - bottom stack pointer
    @{b}_filelist@{ub} - list of files (Fopen)
    @{b}_osversion@{ub} - minimal os version (set by OPT OSVERSION)
    @{b}_cpuflags@{ub} - cpu attn flag set

    Others:
    @{b}_stkframe@{ub} - used for LINK A4 command, size: WORD
    @{b}_stksize@{ub} - alloc stack size, size: LONG
    @{b}_delmem@{ub} - delegates memory, size: LONG
    @{b}_setup@{ub} - the main routine, size: LONG
    @{b}_a4storage@{ub} - this is where a4 is stored. Please note You HAVE TO set this in startup code if You want to use the GetA4() cmd; size: LONG
    @{b}_cleanup@{ub} - the cleanup procedure; switches on open & close of math libs, console etc. size: LONG

    All the A4 vars should be defined with @{b}XREF@{ub} and used as <name>(A4), e.g. "_arg(A4)"

    The "LONG" types should also be defined with XREF but used as i.e. "JSR _setup"

    The _a4storage is a place the a4 register ptr will be stored at. It means that it needn't be defined with XREF but XDEF instead.

    Now the variables that can (or should) be set:
    @{b}__cpu@{ub} - minimal cpu that can handle Your source; normally 000; possible settins:
        - 0x0,
        - 680x0,
        - x
        (i.e. 020 is same as 68020 and 2)
    @{b}__fpu@{ub} - fpu required to handle Your source; normally - FFP libs; possible settings:
        - 88x,
        - 6888x,
        - 0x0,
        - 680x0
        (i.e. 881=68881, 060=68060)
    @{b}__mmu@{ub} - mmu that can handle Your source; normally - no mmu; possible settings:
        - 0x0,
        - 680x0,
        - 851,
        - 68851.

    the variables mentioned above can be set for both procs and startups.

@ENDNODE
@REMARK E
@REMARK B K0007 STARTUP
@NODE K0007 "Custom Startup Code"
  @{b}OPT STARTUP@{ub}

  USAGE
    @{b}OPT STARTUP='codename'@{ub}

  ABOUT
    Keyword allows using custom startup code. It means that You can use self-made in Your programs. This makes output files shorter/larger than usual; You can i.e. only open the dos.library or does not open anything, just link and call the main routine.

    The main code must link a4 register and jump to the setup routine (=call main() procedure). In case when only _setup is called (no _cleanup calls found), no additional routines (math libs, pool etc) are performed; To have it opened You must use _cleanup, too. Minimal startup code:
    @{i}
        XREF _STKFRAME
        XREF _SETUP

        LINK A4,#_STKFRAME
        JSR _SETUP
        UNLK A4
        RTS
    @{ui}
    This code _does not_ initialize _any_ field, it only calls the main() procedure.

  NOTES
    -only RELOC32 reloc hunk type is supported

  BUGS
    None found

@ENDNODE
@REMARK E
@REMARK B K0008 LONG
@NODE K0008 "LONG keyword and labels"
  @{b}LONG keyword and labels@{ub}

    Ok, saying not much - it works. It is now possible to use "LONG <label>" sentence in the source, and this will place a longword pointing directly to label in Your source. Also, LONGs, INTs and CHARs support now the whole immediate expressions :)
@ENDNODE
@REMARK E
@REMARK B K0009 FOR
@NODE K0009 "FOR loop enhancement"
  @{b}FOR loop enhancement@{ub}

    I managed to let the programmer use dynamic STEP size. This causes speed loss (well...) but allows You using the whole expressions. Please note that expression is calculated ONLY ONCE, not more, so the step cannot change while loop is executed. Therefore if You do sth like
    @{i}
    a:=1
    FOR b:=0 TO 100 STEP a DO a:=0
    @{ui}
    the assignment "a:=0" does not affect the loop execution.

@ENDNODE
@REMARK E
@REMARK B K000A ENDPROC
@NODE K000A "ENDPROC enhancement"
  @{b}ENDPROC enhancement@{ub}
  @{b} C H A N G E D @{ub}

    I had to change the meaning of this keyword. I know I shouldn't do it but, as I said here last, it was a BETA feature and it could be changed or removed. Due to some requests, the code does no longer support the system exceptions. The current version can be used as a supervisor part code offering You such features as access to the CPU registers available only in supervisor mode. The form has not changed, so it's still
    @{i}
        PROC blah()
            ...
        ENDPROC exp WITH RTE
    @{ui}
    Procedure can be used later as code pointer for Supervisor(). Please don't blame me for this as it is MUCH more useful than the last version.

@ENDNODE
@REMARK E
@REMARK B K000B WHILE
@NODE K000B "WHILE loop enhancement"
  @{b}WHILE-ENDWHILE loop enhancement@{ub}

    This great idea was brought by Martin Kuchinka - author of PowerD compiler. The WHILE-ENDWHILE loop is expanded with following keywords:

      @{b}ELSEWHILE@{ub}
    Alternative loop part. Any number of ELSEWHIlE keywords can be used in each WHILE loop. Usage is same as for WHILE:
    
    @{i}ELSEWHILE <condition>@{ui}
    
    with only one exception from the rule. As for now it DOESN'T support "DO" kword (it means: You cannot write ELSEWHILE x DO y as it will cause an error)

    Every time the WHILE loop is executed, program searches for a condition that returns true and executes proper part of program. In other case it returns the loop

      @{b}ALWAYS@{ub}
    This keyword is designed especially to be used together with ELSEWHILE. It declares part of program that will be called every time the loop is executed and at last one condition is true.

    Sample code (as short as possible :):
    @{i}
    PROC main()

        DEF a=10

        WHILE a=10
            a:=a+1
            WriteF('Incrementing "a" by 1\\n');
        ELSEWHILE a=11
            a:=0
            WriteF('Setting "a" to zero\\n');
        ALWAYS
            WriteF('Loop is called again now\\n');
        ENDWHILE

        WriteF('a=\\d\\n',a)
    ENDPROC
    @{ui}

    will return:
    @{i}
    Incrementing "a" by 1
    Loop is called again now
    Setting "a" to zero
    Loop is called again now
    a=0
    @{ui}

      @{b}NOTES@{ub}
    - The infinite loops are much easier to create :))
    - Please don't use ALWAYS keyword without ELSEWHILE

@ENDNODE
@REMARK E
@REMARK B K000C FPEXP
@NODE K000C FPExp-beta

    @{b}@{fg fill}OPT FPEXP@{ub}@{fg text}

  USAGE
    OPT FPEXP

  ABOUT
    Allows generating code based on floating-point unit, so that float calculations speed up (depending on FPU)

  NOTE
    You also need to specify either the cpu like 040/060 or the fpu like 881/882 to switch this on.

    060 FPU is also supported. In this case some commands are replaced
    as described below:
@{i}
        FScc    D0
        EXT.W   D0
        EXT.L   D0
@{ui}
    changed to
@{i}                        
        MOVEQ   #-1,D0
        FBcc    lab
        MOVEQ   #0,D0
    lab: [...]
@{ui}
    and
@{i}
        FMOVE.x #y,FPz
@{ui}
    to
@{i}
        MOVE.L  #y,D0
        FMOVE.x D0,FPz
@{ui}
    For both 040 and 060 processors special mnemonics are used (FSxxx) to speedup[?] calculations.

@ENDNODE
@REMARK E
@REMARK B K000D RUNBG
@NODE K000D RunBG

    @{b}@{fg fill}OPT RUNBG@{ub}@{fg text}

  USAGE
    OPT RUNBG (programname, pri)

  PARAMETERS
    Parameters are optional. It means that even a single "OPT RUNBG" is enough to activate the option. @{b}Programname@{ub} is a string that contains a name of background task and @{b}Pri@{ub} is it's priority.

  ABOUT
    This switch allows You to make a program that executes in background (this means that it does not block console and does't have to be RUN any more).

  NOTE
    - v37+ only
    - Although it should work on most OS versions, I don't know if it will on future ones [3.5+] because it fakes the segment structure to avoid disposition of memory the program is located in.
    - Please play with the priority carefully. Too high priority may freeze Your system ;)
    - Files compiled with OPT RUNBG are NOT debuggable

@ENDNODE
@REMARK E
@REMARK B K000E SECTION
@NODE K000E Sections

    @{b}@{fg fill}SECTION@{ub}@{fg text}

  USAGE
    SECTION type,mem

  PARAMETERS
    Second parameter is optional. First one decides about the section type [CODE/DATA], second - memory type [none=PUBLIC, FAST or CHIP]

  ABOUT
    This keyword allows a programmer creating programs splitted up to more than one hunk

  NOTE
    - OPT LARGE should be set if You want to use it.
    - Although SECTION DATA allows storing code, please don't do it.
    - it is allowed only in executable files, not in modules

    and a small example - don't blame me for it, I want to make it as simple as possible ;)

    @{i}
    MODULE 'tools/pt', 'dos/dos'

    PROC main()
        pt_play({module})
        Wait(SIGBREAKF_CTRL_C)
        pt_stop()
    ENDPROC

        SECTION DATA,CHIP
    module:
        INCBIN 'pt_module'
    @{ui}

@ENDNODE
@REMARK E
@REMARK B K000F SETUP
@NODE K000F "SETUP"

    @{b}@{fg fill}SETUP@{ub}@{fg text}

  USAGE
    PROC blah() SETUP

  ABOUT
    This feature is very useful for some advanced programmers who need to have some internal stuff initialized before main procedure is executed. All the normal E code is allowed in such procedures and these can also be called in the middle of the normal code.

  NOTE
    - Such procedure CAN NOT ask for any arguments because none are passed to it.
    - This kind of procedure may be declared ONLY in modules.
@ENDNODE
@REMARK E
@REMARK B K0010 CLEANUP
@NODE K0010 "CLEANUP"

    @{b}@{fg fill}CLEANUP@{ub}@{fg text}

  USAGE
    PROC blah() CLEANUP

  ABOUT
    This one is made for advanced programmers who need to make some additional code for module which has to be executed after the main program quits. Normal E code may be used in such type of the procedure and it might be called wherever in the normal code as a procedure.

  NOTE
    - Such procedure CAN NOT ask for any arguments because none are passed to it.
    - This kind of procedure may be declared ONLY in modules.

@ENDNODE
@REMARK E
@REMARK B K0011 EXTRA
@NODE K0011 "EXTRA"

    @{b}@{fg fill}EXTRA@{ub}@{fg text}

  USAGE
    LIBRARY name,verstr,ver,rev EXTRA size IS...

  PARAMETERS
    @{b}name@{ub} is the library name
    @{b}verstr@{ub} is the version string
    @{b}ver@{ub} is the library version
    @{b}rev@{ub} is the library revision
    @{b}size@{ub} is the size of extra space in the library base. This number must be in range 0 - 32000 and also must be even.

  ABOUT
    Keyword is used to get the extra space in the library base. You can define it if You want to use the base as Your own structure and store sth in it.

  NOTE
    - some internal datas are stored behind this space! Don't write anything there!

  EXAMPLE
    @{i}
    MODULE 'exec/libraries', 'exec/execbase', 'exec/nodes'

    OBJECT libbase
        lib:lib
        long
    ENDOBJECT

    LIBRARY 'example.library', 'example.library 1.0 (07.03.2k)',
            1, 0 EXTRA 4 IS a,b

        DEF base:PTR TO libbase

    PROC main()
        base:=FindName(execbase.liblist, 'example.library')
    ENDPROC

    PROC a(text) IS base.long:=text

    PROC b() IS EasyRequestArgs(0,
        [20, 0, 'Request', 'Text: \s', 'Ok'], 0,
            [base.long])
    @{ui}

    To see how does this program work, You'll need to write two clients, first one to call function "a" with some text, second - "b" with no args.

@ENDNODE
@REMARK E
@REMARK B K0012 CODE
@NODE K0012 CODE
    @{b}@{fg fill}CODE@{ub}@{fg text}

  USAGE
    OPT CODE FAST
    OPT CODE SMALL

  ABOUT
    This switch selects the different types of output code that is to be generated; although CODE SMALL does nothing at this time [normally the output is optimized nowadays ;)], OPT FAST generates the code a bit longer, but uses only the fastest routines [mostly in multiplication - from 2 to 30 optimized at this time]. If You want to get the fastest code for new machines, please specify also processor [020+], FPEXP mode, osversion and INLINE. This should speed the output code really much.

  NOTE

@ENDNODE
@REMARK E
@REMARK B K0013 CONST
@NODE K0013 CONST
    @{b}@{fg fill}CONST@{ub}@{fg text}

  USAGE
    CONST X=<val>
    CONST X=<string>

  ABOUT
    Since 2.12 it is possible to declare string constants. A string constant is parsed as normal E string, therefore null-chars are also allowed. String constants may be used as normal strings and can be exported to module.

  NOTE

@ENDNODE
@REMARK E
@REMARK E
@REMARK B NEWVARIABLES
@NODE NEWVARIABLES "New variables"

  @{b}utilitybase@{ub}
    points to utility.library if it was opened (see @{" UTILLIB " LINK K0003})

  @{b}__pool@{ub}
    points to internal pool, if it was created (see @{" POOL " LINK K0002})

@ENDNODE
@REMARK E
@REMARK B NEWCONSTS
@NODE NEWCONSTS "New constants"
@{CODE}
@SMARTWRAP
@FONT XEN.FONT 11
@{JLEFT}
@{CODE}
   @{U}Constant@{UU}            @{U}Value@{UU}
   TAG_DONE            0
   TAG_END             0
   TAG_IGNORE          1
   TAG_MORE            2
   TAG_SKIP            3
   TAG_USER            $80000000
   OFFSET_BEGINNING    -1
   OFFSET_CURRENT      0
   OFFSET_END          1
   READWRITE           1004
@{BODY}
@ENDNODE
@REMARK E
@REMARK B NEWOPERS
@NODE NEWOPERS "New operators"

    @{"   " LINK OP001} //
    @{"   " LINK OP002} &
    @{"   " LINK OP002} ||
    @{"   " LINK OP003} =>
    @{"   " LINK OP003} =<
    @{"   " LINK OP004} >>
    @{"   " LINK OP004} <<
    @{"   " LINK OP005} *=
    @{"   " LINK OP006} ==

@ENDNODE
@REMARK B //
@NODE OP001 "//"

    The "//" sequence defines a short comment in the source [just like the "->"]
@ENDNODE
@REMARK E
@REMARK B "& and ||"
@NODE OP002 "& and ||"

    These two sequences can be used as replacement of two keywords: "&" means "AND" and "||" means OR
@ENDNODE
@REMARK E
@REMARK B "=> and =<"
@NODE OP003 "=> and =<"

    Thesetwo sequences means the same as ">=" ("=>") and "<=" ("=<") ;)
@ENDNODE
@REMARK E
@REMARK B ">> and <<"
@NODE OP004 ">> and <<"

    These two work a bit more like Shr and Shl, but no function is called. Rotation is placed directly in the code so it is much faster. Works exactly as in C/C++. Example source:

    @{i}
    PROC rotate_left(v,n)
        DEF x

        x:=v<<n     // here the v is shifted left n times
    ENDPROC x
    @{ui}
@ENDNODE
@REMARK E
@REMARK B "*="
@NODE OP005 "*= etc"

    That works mostly same as in C. You can easily omit the sequence such as

        x:=x....

    and start it without writing the above. It is especially useful when You want to perform an action on some long-named fields in Your object identifier or the variables with quite big names. The main sequence is:

        <function>=

    where <function> may be one of those: +, -, *, /, AND, &, OR, ||, <<, >>

    example use:
    @{i}
    DEF object:objectname
    ...
    PROC increase(value)
        object.member+=value
        // same as: object.member:=object.member+value
    ENDPROC
    @{ui}

@ENDNODE
@REMARK E
@REMARK B "=="
@NODE OP006 "quick compare"

    This sequence lets You compare a single expression against any bounds or values [or even expressions, if needed] in a very fast way. The main use is:

        @{b}<exp> == [<exp>, <lower> TO <upper>,...]@{ub}

    What is a good thing about it? Well, I think it's the speed. The output code is much shorter and the check procedure exits as soon as one comparison is true [for example, if an array has 100 entries and the first entry matches the given expression, it exits immediately with TRUE]. It might be very useful together with IF sentence.

    Example use:
    @{i}
    PROC checkrange(value)
        IF value*16-2 == [2, 10 TO 20, xyz()-blah+3] THEN
            DisplayBeep(NIL)
    ENDPROC
    @{ui}
    is equivalent to:
    @{i}
    PROC checkrange(value)
        IF (value*16-2=2) OR ((value*16-2>10) AND (value*16-2<20)) OR
           (value*16-2=(xyz()-blah+3)) THEN DisplayBeep(NIL)
    ENDPROC
    @{ui}
@ENDNODE
@REMARK E
@ENDNODE
@REMARK E
@REMARK B LONGSTRINGS
@NODE LONGSTRINGS "LONG strings"

  @{b}\\x@{ub}

    This  lets You insert any value into your "LONG" string  '\\x' MUST be followed by two HEX digits describing the ascii number You want to put instead of \\x. Function will cause an error if You write something wrong. Please note you ALWAYS have to put TWO digits, even if the whole number fits in one. You can't use signs here!

@ENDNODE
@REMARK E
@REMARK B NORMALSTRINGS
@NODE NORMALSTRINGS "Normal strings"

  @{b}\\x@{ub}

    This  lets You insert any value in string. "\\x" MUST be followed by two digits describing HEX number which is the number of ASCII char You want to put there. Compiler returns an error if You do something wrong.

  @{b}\\!@{ub}

    This inserts a BELL ($07) char to Your string. It causes the screen-flash (DisplayBeep()) when put on console.


  @{b}\\v@{ub}
    This inserts a vertical tab ($0B)

@ENDNODE
@REMARK E
@REMARK B FORMATIO
@NODE FORMATIO "Formatted I/O functions"

  @{b}\\u@{ub}

    This puts unsigned decimal number. This is equal to %lu (RawDoFmt)

@ENDNODE
@REMARK E
@REMARK B ASSEMBLER
@NODE ASSEMBLER "Assembler part"

    because of the number of added  commands,  I  have  put  only  the most-important informations about improvements here. Sorry, folx.

    - No more "weird" operand sizes (like RTS.x or MOVE.S)
    - Multiplication and division can operate on longs (020+)
    - Quite big instruction set - support for CPUs (68k family),
      FPUs and MMUs.
    - Over 400 assembler commands
    - Support to extended addressing mode with suppressed regs
    - Lib offset access from assembler (i.e. MOVE.L #Open,D0)
    - EA constructor fixed (no more D0.W.L.W.L.W.W.W etc)
    - Scale factor added for some 020+ addressing modes
    - CCR and SR access added
    - xx(Ax) = (xx, Ax) (same for other similar addressing modes)

    Not supported commands:
        -Pack
        -Unpk
        -Cas
        -Cas2
        -Chk2
        -Cmp2
        -CallM
        -RtM
        -Bgnd

    Please note that PPC assembler is also supported but SHOULDN'T and CAN'T be used. That is, because of the problems I have stumbled on while trying to implement the ppc support... For more informations read the top page.

@ENDNODE
@REMARK E
@REMARK B PATCHER
@NODE PATCHER "The Patcher"

    The patcher changes some commands to generate the code optimized for different cpus/fpus/osversions and others; Currently those functions are patched

  @{B}Kickstart@{UB}

    WriteF() [37+]
    PutF() [37+]
    PrintF() [37+]

    Please note that the patcher will be useless soon...

@ENDNODE
@REMARK E
@REMARK B THANKS
@NODE THANKS "I wish to thank to..."

    It's a list of people I wish to thank

  Wouter van Oortmerssent
    ... for writing the best programming language ever!

  Gateway
    ... for keeping alive our lovely Amiga!

  Dietmar Eilert
    ... for GoldEd - the greatest editor ever made!

  Michal Wozniak
    ... for being the top betatester for now!

  Alex van Niel, Marcin Juszkiewicz, Tomasz Bielinski
    ... for help and betatesting

  Martin Kuchinka
    ... for his great ideas, betatesting and emails :)

  Special thanks goes to [random order]:
    - Waldemar Skiba
    - mysterious MeF ;)
    - Michal Wozniak
    - Rainer Müller
    - Tomasz Bielinski

  Also, thanks to
    - all people mailing me =)
    - all E developers
    - all Amigians

    Amiga, forever!

@ENDNODE
@REMARK E
@REMARK B ERROR
@NODE ERROR "Hi, it's me! :)"

    Ok, shortly: feel free to email me, snail me or even call me. Here are my addresses (snail and email ofcourse :)

    snailmail:
    Tomasz Wiszkowski
    Katowicka 23/4
    44-335 Jastrzebie Zdroj
    POLAND

    email:
    t_error@interia.pl

    phone:
    +48-32-471-23-21

    Any new ideas? Write to me, too!!!

    That's all! Enjoy using CreativE!

@ENDNODE
@REMARK E
@REMARK B PREPROCESSOR
@NODE PREPROCESSOR "PreProcessor"

    List of preprocessor commands I have added to CreativE:

    @{"   " LINK PREPDATE} #date

@ENDNODE
@REMARK B #date
@NODE PREPDATE #date

    This preprocessor keyword is very useful when You want to place compilation date of Your program. It's very easy to use

    @{B}#date store fmtstring@{ub}

    Ok. This macro keyword allows You to insert current date in any type You wish. The format is defined in format string. Supported keys:
        @{B}%d@{ub} - day nr
        @{B}%m@{ub} - month nr
        @{B}%y@{ub} - year nr (4 digits)
        @{B}%D@{ub} - day (name)
        @{B}%M@{ub} - month (name)
        @{B}%Y@{ub} - year nr (2 digits)
        @{B}%aD@{ub} - day (abbreviated name)
        @{B}%aM@{ub} - month (abbreviated name)

    So, if You want a e.g. version string, You can write sth like:

    @{i}#date Version '$VER: SpaceSheep v0.0 (%d.%aM.%Y) by LittleGreenMan'@{ui}

    and put it somewhere in your source... the only thing You must take care of is the version ;).

@ENDNODE
@REMARK E
@REMARK E
@REMARK B Problems
@NODE PROBLEMS "Common problems"

    These are the problems You may have when compiling Your source with CreativE. Those are not the bugs :)

    Q: When I compile my source with CreativE, the compiler crashes my system after writing the executable
    A: Please increase Your stack size. Usually 20k should be enough, but for bigger programms [200k+] You may find it too small.

    Q: Compiler complains about stacksize. Why did You make this restriction?
    A: Well, CrtvE is very stack-consuming stuff :(. In some cases even 20k isn't enough for it. Please remember to keep an eye on Your stack!
@ENDNODE
@REMARK E
@REMARK B Errors
@NODE ERRORS "New error and warning messages"

    A short description of error mesages and warnings...

    @{"   " LINK ERR0001} unknown HEX value after \\x
    @{"   " LINK ERR0002} value expected
    @{"   " LINK ERR0003} ')' expected
    @{"   " LINK ERR0004} even number expected
    @{"   " LINK ERR0005} you need a newer OS for this
    @{"   " LINK ERR0006} unable to open resource
    @{"   " LINK ERR0007} this instruction needs a newer OS version (see OPT)
    @{"   " LINK ERR0008} illegal size
    @{"   " LINK ERR0009} fpu register expected
    @{"   " LINK ERR000A} ':' expected
    @{"   " LINK ERR000B} mmu register expected
    @{"   " LINK ERR000C} control register expected
    @{"   " LINK ERR000D} cpu register expected
    @{"   " LINK ERR000E} this instruction works only in pool mode
    @{"   " LINK ERR000F} not allowed in library mode
    @{"   " LINK ERR0010} a4 storage not defined in startup code
    @{"   " LINK ERR0011} only RTR and RTE allowed
    @{"   " LINK ERR0012} illegal scale factor
    @{"   " LINK ERR0013} address/pc register expected
    @{"   " LINK ERR0014} value does not fit in 16 bit
    @{"   " LINK ERR0015} value does not fit in 8 bit
    @{"   " LINK ERR0016} address/data register expected
    @{"   " LINK ERR0017} reg args not allowed in methods
    @{"   " LINK ERR0018} illegal section definition
    @{"   " LINK ERR0019} 680x0 code not allowed in powerpc program
    @{"   " lINK ERR001A} powerpc code not allowed in 680x0 program
    @{"   " LINK ERR001B} general purpose register expected
    @{"   " LINK ERR001C} unknown/illegal mnemonic
    @{"   " LINK ERR001D} condition register expected
    @{"   " LINK ERR001E} ppc floating point register expected
    @{"   " LINK ERR001F} fp condition register expected
    @{"   " LINK ERR0020} special purpose register expected
    @{"   " LINK ERR0021} time base register expected
    @{"   " LINK ERR0022} better CPU/FPU/MMU/OSVERSION required
    @{"   " LINK ERR0023} stack too small; need at least 20000 bytes
    W A R N I N G S

    @{"   " LINK WRN0001} 040/060 emulated instruction(s) used
@ENDNODE

@REMARK B ERR0001 (unknown HEX value after \x)
@NODE ERR0001 "Unknown HEX value after \x"
        @{b}unknown HEX value after \\x@{ub}

    PROBLEM:
        This error will appear every time when You use a "\\x" sentence in Your string with incorrect HEX number (e.g. "\\xZG" etc). Please note "\\x" always eats TWO characters, not one.

    HELP:
        Check Your strings for an incorrect "hex" numbers
@ENDNODE
@REMARK E
@REMARK B ERR0002 (value expected)
@NODE ERR0002 "value expected"
        @{b}value expected@{ub}

    PROBLEM: 
        Error appears every time You use e.g. a variable when a value is expected, e.g. when You use a variable describing extra place in Your library definition

    HELP:
        Simply place an immediate value or constant in such place.
@ENDNODE
@REMARK E
@REMARK B ERR0003 (')' expected)
@NODE ERR0003 "')' expected"
        @{b}")" expected@{ub}

    PROBLEM:
        You've probably forgotten to close a bracket :)... most commands does not support it, yet, but they surely will. Example: GetA4(

    HELP:
        Put a closing bracket
@ENDNODE
@REMARK E
@REMARK B ERR0004 (even number expected)
@NODE ERR0004 "even number expected"
        @{b}even number expected@{ub}

    PROBLEM:
        An even number is required. This pops up especially when You try to create  a library space with odd number of bytes

    HELP:
        Round Your value to the nearest even number
@ENDNODE
@REMARK E
@REMARK B ERR0005 (you need a newer OS for this)
@NODE ERR0005 "you need a newer OS for this"
        @{b}you need a newer OS for this@{ub}

    PROBLEM:
        You have probably used a compiler option which is not supported by Your operating system. This message will usually pop when You're tring to use some compiler ops (e.g. #date) on a pre-2.0 operating system

    HELP:
        Well... You must try to remove the object that causes this error or map Your ROM/buy a new kickstart
@ENDNODE
@REMARK E
@REMARK B ERR0006 (unable to open resource)
@NODE ERR0006 "unable to open resource"
        @{b}unable to open resource@{ub}

    PROBLEM:
        CreativE is unable to open a required resource (e.g. battclock.resource to use with #date preprocessor macro)

    HELP:
        Reboot Your amiga and try again
@ENDNODE
@REMARK E
@REMARK B ERR0007 (this instruction needs a newer OS version (see OPT)
@NODE ERR0007 "This instruction needs a newer OS version (see OPT)"
        @{b}this instruction needs a newer OS version (see OPT)@{ub}

    PROBLEM:
        The command(s) You've used are not supported by the system you're compiling a program to.

    HELP:
        change OSVERSION setting (e.g. OPT OSVERSION=37)
@ENDNODE
@REMARK E
@REMARK B ERR0008 (illegal size)
@NODE ERR0008 "illegal size"
        @{b}illegal size@{ub}

    PROBLEM:
        The assembler size is not supported by mnemonic (e.g. ADDA.B)

    HELP:
        fix up the size or remove it.
@ENDNODE
@REMARK E
@REMARK B ERR0009 (fpu register expected)
@NODE ERR0009 "fpu register expected"
        @{b}fpu register expected@{ub}

    PROBLEM:
        The assembler mnemonic requires at last one FPU register (usually all Fxxxx do) or at last one FPU control register

    HELP:
        Check out the command syntax
@ENDNODE
@REMARK E
@REMARK B ERR000A (':' expected)
@NODE ERR000A "':' expected"
        @{b}":" expected@{ub}

    PROBLEM:
        a colon is required

    HELP:
        put a colon in a proper place
@ENDNODE
@REMARK E
@REMARK B ERR000B (mmu register expected)
@NODE ERR000B "mmu register expected"
        @{b}mmu register expected@{ub}

    PROBLEM:
        The assembler mnemonic requires at last one MMU register (usually all Pxxxx do) or at last one MMU control register

    HELP:
        Check out the command syntax
@ENDNODE
@REMARK E
@REMARK B ERR000C (control register expected)
@NODE ERR000C "control register expected"
        @{b}contol register expected@{ub}

    PROBLEM:
        (usually appears with MOVEC mnemonic) - the assembler command requires at last one control register
    HELP:
        Check out the command syntax/put a control register in a proper place
@ENDNODE
@REMARK E
@REMARK B ERR000D (cpu register expected)
@NODE ERR000D "cpu register expected"
        @{b}cpu register expected@{ub}

    PROBLEM:
        The mnemonic You've used requires a CPU register

    HELP:
        Check out the command syntax/put a control register in a proper place
@ENDNODE
@REMARK E
@REMARK B ERR000E (this instruction works only in pool mode)
@NODE ERR000E "this instruction works only in pool mode"
        @{b}this instruction works only in pool mode@{ub}

    PROBLEM:
        You've used probably an instruction which needs a pool to be present (e.g. Alloc())

    HELP:
        add a POOL keyword to OPT settings
@ENDNODE
@REMARK E
@REMARK B ERR000F (not allowed in library mode)
@NODE ERR000F "not allowed in library mode"
        @{b}not allowed in library mode@{ub}

    PROBLEM:
        The instruction You've used does not work in library mode (e.g. GetA4())
    
    HELP:
        Remove or replace the instruction.
@ENDNODE
@REMARK E
@REMARK B ERR0010 (a4 storage not defined in startup code)
@NODE ERR0010 "a4 storage not defined in startup code"

        @{b}a4 storage not defined in startup code@{ub}

    PROBLEM:
        You have probably used GetA4() command together with some "custom" startup routine, which hasn't got defined a field storage for A4 register
    HELP:
        If the startup code was made by You, You should provide extra space for A4 register in it and also store it. Otherwise, You should either use other startup routine or avoid using "GetA4" command.
@ENDNODE
@REMARK E
@REMARK B ERR0011 (only RTR and RTE allowed)
@NODE ERR0011 "only RTR and RTE allowed"
        @{b}only RTR and RTE allowed@{ub}

    PROBLEM:
        The keyword You used requires You to chose only between RTR and RTE (as for now - only ENDPROC WITH xxx)

    HELP:
        simply fix up the keyword.
@ENDNODE
@REMARK E
@REMARK B ERR0012 (illegal scale factor)
@NODE ERR0012 "illegal scale factor"
        @{b}illegal scale factor@{ub}

    PROBLEM:
        You've set a wrong scale factor in Your adressing mode

    HELP:
        Check if it's one of [1, 2, 4, 8]. These are only possibilities
@ENDNODE
@REMARK E
@REMARK B ERR0013 (address/pc register expected)
@NODE ERR0013 "address/pc register expected"
        @{b}address/pc register expected@{ub}

    PROBLEM:
        The adressing mode You've used requires either Ax or PC register

    HELP:
        Check up the adressing mode and put the reg in a proper place
@ENDNODE
@REMARK E
@REMARK B ERR0014 (value does not fit in 16 bit)
@NODE ERR0014 "value does not fit in 16 bit"
        @{b}value does not fit in 16 bit@{ub}

    PROBLEM:
        The value/offset You've used does not fit in 16 bit

    HELP:
        fix up the value/offset
@ENDNODE
@REMARK E
@REMARK B ERR0015 (value does not fit in 8 bit)
@NODE ERR0015 "value does not fit in 8 bit"
        @{b}value does not fit in 8 bit@{ub}

    PROBLEM:
        Value/offset You've used does not fit in 8 bit range

    HELP:
        fix the value/offset up
@ENDNODE
@REMARK E
@REMARK B ERR0016 (address/data register expected}
@NODE ERR0016 "address/data register expected"
        @{b}address/data register expected@{ub}

    PROBLEM:
        The adressing mode You've used requires adressing or data
        register

    HELP:
        Check up the adressing mode and put the reg in a proper place.
@ENDNODE
@REMARK E
@REMARK B ERR0017 (reg args not allowed in methods)
@NODE ERR0017 "reg args not allowed in methods"
        @{b}reg args not allowed in methods@{ub}

    PROBLEM:
        You're asking for arguments stored in regs for method i.e. @{i}PROC blah(a=D1) OF x@{ui}

    HELP:
        Please fix up the PROC definition. You cannot ask for regs.
@ENDNODE
@REMARK E
@REMARK B ERR0018 (illegal section definition)
@NODE ERR0018 "illegal section definition"
        @{b}illegal section definition@{ub}

    PROBLEM:
        Your section definition is not declared properly, i.e.
        SECTION CHIP,CODE

    HELP:
        Read the @{" Section " LINK K000E} keyword documentation
@ENDNODE
@REMARK E
@REMARK B ERR0019 (680x0 code not allowed in powerpc program)
@NODE ERR0019 "680x0 code not allowed in powerpc program"
        @{b}680x0 code not allowed in powerpc program@{ub}

    PROBLEM:
        You're trying to use a MC680x0 code in powerpc executable

    HELP:
        Replace the mnemonics with PPC code
@ENDNODE
@REMARK E
@REMARK B ERR001A (powerpc code not allowed in 680x0 program)
@NODE ERR001A "powerpc code not allowed in 680x0 program"
        @{b}powerpc code not allowed in 680x0 program@{ub}

    PROBLEM:
        You're trying to use powerpc code in 680x0 executable

    HELP:
        Replace the mnemonics with 680x0 code
@ENDNODE
@REMARK E
@REMARK B ERR001B (general purpose register expected)
@NODE ERR001B "general purpose register expected"
        @{b}general purpose register expected@{ub}

    PROBLEM:
        You've probably missed some general purpose register in powerpc code

    HELP:
        locate the correct place and put there a proper register
@ENDNODE
@REMARK E
@REMARK B ERR001C (unknown/illegal mnemonic)
@NODE ERR001C "unknown/illegal mnemonic"
        @{b}unknown/illegal mnemonic@{ub}

    PROBLEM:
        You're trying to use unknown form of powerpc mnemonic [i.e. STWCX]

    HELP:
        Take a look at the powerpc developers documentation :)
@ENDNODE
@REMARK E
@REMARK B ERR001D (condition register expected)
@NODE ERR001D "condition register expected"
        @{b}condition register expected@{ub}

    PROBLEM:
        The instruction You're trying to use requires the condition register

    HELP:
        Locate the proper place and put the condition register
        there
@ENDNODE
@REMARK E
@REMARK B ERR001E (ppc floating point register expected)
@NODE ERR001E "ppc floating point register expected"
        @{b}ppc floating point register expected@{ub}

    PROBLEM:
        A powerpc floating point register is missed

    HELP:
        Locate the proper place for a floating point register
@ENDNODE
@REMARK E
@REMARK B ERR001F (fp condition register expected)
@NODE ERR001F "fp condition register expected"
        @{b}fp condition register expected@{ub}

    PROBLEM:
        This command requires a fpu condition register [to be fixed soon]

    HELP:
        place the correct condition register in a correct place
@ENDNODE
@REMARK E
@REMARK B ERR0020 (special purpose register expected)
@NODE ERR0020 "special purpose register expected"
        @{b}special purpose register expected@{ub}

    PROBLEM:
        The instruction You've used takes a special purpose register as an argument

    HELP:
        Please place the correct special purpose register in a correct place
@ENDNODE
@REMARK E
@REMARK B ERR0021 (time base register expected)
@NODE ERR0021 "time base register expected"
        @{b}time base register expected@{ub}

    PROBLEM:
        The instruction You've used needs a time base register

    HELP:
        Put the correct time base register in a correct place
@ENDNODE
@REMARK E
@REMARK B ERR0022 (better cpu/fpu/mmu/osversion required)
@NODE ERR0022 "better cpu/fpu/mmu/osversion required"
        @{b}better cpu/fpu/mmu/osversion required@{ub}

    PROBLEM:
        Ehhm.. This error appears only when using some lib (.o) files with set some special flags [__cpu, __fpu, __mmu or __osversion]

    HELP:
        Please try to set up the proper values for each of these.
@ENDNODE
@REMARK E
@REMARK B ERR0023 (stack too small; need at least 20000 bytes)
@NODE ERR0023 "stack too small; need at least 20000 bytes"
        @{b}stack too small; need at least 20000 bytes@{ub}

    PROBLEM:
        You need a bigger stack to use CreativE; Your stack is too small

    HELP:
        Use the CLI "STACK" command to set the stack size to 20000 or more bytes. CreativE needs at least 20k for safe compilation.
@ENDNODE
@REMARK E

@REMARK B WRN0001 (040/060 emulated instruction(s) used)
@NODE WRN0001 "040/060 emulated instruction(s) used"

        @{b}040/060 emulated instruction(s) used@{ub}

    PROBLEM:
        You've used some emulated instructions in Your assembly code; it means that Your programm will work slower on 040/060 CPUs
@ENDNODE
@REMARK E
@REMARK E
@REMARK B Inlines
@NODE INLINE "Inline commands"

    Since 2.01 I've enhanced E with @{b}Inline commands@{ub}. It means that such commands are NO LONGER called (with BSRs); they're placed directly in place of call, so work as fast as if were a simple "+" or "*" in the expression. To use the inline commands please look at description of @{"INLINE" LINK K0004} keyword. Patched are:

    - Abs
    - And
    - Car
    - Cdr
    - Char
    - CleanUp
    - Div (020+)
    - Eor
    - Eval
    - Even
    - Fabs
    - Facos
    - Fatan
    - Fasin
    - Fceil
    - Fcos
    - Fcosh
    - Fexp
    - Ffieee
    - Ffloor
    - Flog
    - Flog10
    - Fpow
    - Fsin
    - Fsincos
    - Fsinh
    - Fsqrt
    - Ftan
    - Ftanh
    - Ftieee
    - Int
    - Lsl
    - Lsr
    - Long
    - Mod (020+)
    - MouseX
    - MouseY
    - MsgCode
    - MsgIaddr
    - MsgQual
    - Mul (020+)
    - Not
    - Odd
    - Or
    - PutChar
    - PutInt
    - PutLong
    - RndQ
    - Shl
    - Shr

@ENDNODE
@REMARK E
@REMARK B Others...
@NODE OTHER "Other things"

    Yes... Well, this chapter contains only stuff I don't know where to put... hehe q:)c=

    @{"   " LINK OTH000000} Object members
    @{"   " LINK OTH000001} Another IF format
    @{"   " LINK OTH000002} Modules vs inlines
    @{"   " LINK OTH000003} Expressions swap
    @{"   " LINK OTH000005} ARRAY declarations
    @{"   " LINK OTH000006} SIZEOF and vars
    @{"   " LINK OTH000007} Multiple pointers
    @{"   " LINK OTH000008} Typed variables
    @{"   " LINK OTH000009} CONST declaration
    @{"   " LINK OTH00000B} Vars declarations

@ENDNODE
@REMARK B Member assignment
@NODE OTH000000 Member assignment

  @{b}Object members@{ub}

        Since 2.01 it is possible to make an assignment to any object's member inside the immediate list. It's now possible to perform this:
            @{b}a:=[b[c].d:=e]:x@{ub}
@ENDNODE
@REMARK E
@REMARK B Another IF format
@NODE OTH000001 "Another IF expression format
  @{b}Another IF format@{ub}

        I'm sure that many ppl will blame me for using C/C++ features in E compiler but I think that if there's a way to do sth easier, it should be implemented.. Ok, and here it is. The format is:
            @{b}<exp> ? <texp> : <fexp>@{ub}

        Of course this feature can be a bit deeper (read: you can use one in another, like brackets). <exp> stands for any expression to be checked, <texp> stands for expression to be calculated in case of true and <fexp> is the one to be calculated in case of false.
@ENDNODE
@REMARK E
@REMARK B Modules vs inline code
@NODE OTH000002 "Modules vs inline code"
  @{b}Modules vs inline code@{ub}

        Yes... this was the main problem the programs compiled with INLINE option crashes because of. Now (hehe... a bit too late) the compiler is a bit smarter - checks whether the inline code is used by the module to encounter whether copy it or not.
@ENDNODE
@REMARK E
@REMARK B Expressions swap
@NODE OTH000003 "Expressions swap"
  @{b}Expressions swap@{ub}

    I think it's usable feature ;). Imagine You can calculate at once two expressions and store them in specified variables later. It means that i.e. You don't have to define additional vars for temporary use; now:
        @{b}<exp1>:=:<exp2>@{ub}

    will solve this problem. The results will be stored in the last-used variables (i.e. in a+b/c*d, "d" is the last one). Multiple use of it is possible but the variables are set after each two (i.e. when You write sth like:
        a:=:b:=:c
    first a is swapped with b and then b is swapped with c)

    I know it's a bit weird but it's very difficult to explain it. Maybe a little example:

    @{i}
    PROC main()
        DEF a=1, b=10, c=2

        WriteF('a=\d, b=\d, c=\d\n', a, b, c)
        a+15:=:b/2:=:c*2
        WriteF('a=\d, b=\d, c=\d\n', a, b, c)
    ENDPROC
    @{ui}

    will produce:
    @{i}
    a=1, b=10, c=2
    a=5, b=4, c=16
    @{ui}

    so, first a+15 is calculated (=16) and put on stack; then b/2 is calculated
    and stored in "a". Then, b is set with value from stack and another swap
    is done.

  @{b}IMPORTANT NOTE!@{ub}

    This "thing" is only for variables, NOT for objects and members. SO! If you
    do sth. like:

    @{i}a.b.c:=:d.e.f@{ui}

    then ONLY POINTERS are set with expression values! In this case it is equal
    to sth. like:
    @{i}
    t:=a
    a:=d.e.f
    d:=t.b.c
    @{ui}

@ENDNODE
@REMARK E
@REMARK B ARRAY declarations
@NODE OTH000005 "ARRAY declarations"
  @{b}ARRAY declarations@{ub}

    Hence I got several mails about it I decided to allow programmer using the faster way to declare arrays. Since 2.10 it is possible to skip the "ARRAY OF" keyword set and for CHAR - even everything. To declare an array You can write simply:

    @{i}DEF x[100]:LONG@{ui}

    to get an "ARRAY OF LONG".
@ENDNODE
@REMARK E
@REMARK B SIZEOF and vars
@NODE OTH000006 "SIZEOF and variables"
  @{b}SIZEOF and vars@{ub}

    Hmm.. Have You ever used "SIZEOF" keyword? It becomes very awkward in situations when You need a size of an object_with_very_long_name. So... here's the way to do it a bit different. Example:
    @{i}
    MODULE 'dos/dos'
    PROC main()
        DEF a:fileinfoblock

        WriteF('FileInfoBlock size: \d\n', SIZEOF a)
    ENDPROC
    @{ui}
    will output
    @{i}
    FileInfoBlock size: 260
    @{ui}
    As You can see, it is now possible to use the variable to obtain object's size. Now some technical info:
    -. You can ONLY get the destination object's size (i.e., when You declare a as ARRAY OF fileinfoblock, You'll always get "260", no matter how many fields are in the array
    -. You won't get the size of an identifier (I mean: declaring "a" as a LONG, You won't get "4" as a SIZEOF value, because "a" is also same as PTR TO CHAR (=you'll get "1" instead of "4"). Now, if You specify "a" as PTR TO INT, the result will be "2", not "4" (as this is the destination object's size).

@ENDNODE
@REMARK E
@REMARK B Multiple pointers
@NODE OTH000007 "Multiple pointers"
  @{b}Multiple pointers@{ub}

    Yess! At last :). I had a couple of emails about multiple pointers (PTR TO PTR TO ... <object>). Although it's added as a beta feature, it should work in most cases (if not in all). Ok, some source code to show the use in practise:
    @{i}
    PROC main()
        DEF args:PTR TO PTR TO PTR TO CHAR,b=0

        ReadArgs('FILES/M', args, NIL)

        WHILE a[0][b]<>NIL
            WriteF('\s\n',a[0][b])
            b++
        ENDWHILE
    ENDPROC
    @{ui}
    Hmm, yes, this source also shows the exceptions. There is only one for three identifiers: CHAR, INT and LONG. Let me give You an example: when You declare a variable as a PTR TO CHAR, You won't access the pointer typing a[x], because "a" already points to char (so You can only access the field in a CHAR stream). It's same here. Declaring the variable as a PTR TO PTR TO PTR TO CHAR (as above) is equivalent to: first branch of tree is a LONG pointing to another, which also is LONG and points to the last one which is CHAR typed.

    Now, some words about the use IRL...

    In objects the situation becomes a bit handy. As You might have noticed, in pointers the objects are stored in one stream (one just after another). So the use of variable declared as below

        DEF blah:PTR TO PTR TO oblah

    must look like

        blah[x][y].field

    and will give You the Y'th stream object's field. Note it is a stream (!), just like an array.

    and there is no way to skip the second index ([y]). This will change in the nearest future.

  NOTES:
    -. The multiple pointers cannot be typed (::) in the middle of the code (to be fixed)
    -. In arrays, the first (highest) stream is allocated automatically but the rest IS NOT (!). Same to pointers. Writing code like:
       @{i}
       PROC main()
           DEF a:PTR TO PTR TO PTR TO LONG

           a[0][0][0]:=3
       ENDPROC
       @{ui}
       is illegal (writing to unknown memory region) and may cause system crashes.



@ENDNODE
@REMARK E
@REMARK B Typed variables
@NODE OTH000008 "Typed variables"
  @{b}Typed variables@{ub}

    I know it was a bit stupid to use another variables to access i.e. the execbase field and type it as pointer to execbase. Therefore I made a simple thing that will allow You to use these variables (execbase, intuitionbase, gfxbase, wbmessage and dosbase) as a typed variables, all You have to do is to include the modules such as 'exec/execbase', 'intuition/intuitionbase' etc. etc., depending on what do You want to have.
@ENDNODE
@REMARK E
@REMARK B CONST declaration
@NODE OTH000009 "Constants declarations"
  @{b}Constants declarations@{ub}

    Since 2.12 it is possible to use the following signs in the constants assignments:

    <<      - logical shift left
    >>      - logical shift right

@ENDNODE
@REMARK E
@REMARK B Variables declarations inside procs
@NODE OTH00000B
  @{B}Variables declaration@{UB}

    A small thing I've been asked for several times. Well, since 2.12 You can declare Your variables nearly everywhere inside proc, but You have to remember that DEF cannot be covered by anything but PROC and ENDPROC [what I mean is: You cannot define any variable in WHILE/ENDWHILE loop and so on].

    A few more words about it: Each variable declared that way is accessible from anywhere in a proc, even before it was declared, but it doesn't mean that it is initialized. What's the difference? Type down this program:
    @{i}
    PROC main()
        ...
        WriteF('a equals to: \\d\\n', a)
        DEF a=3
        ...
    ENDPROC
    @{ui}
    As You may see, a holds some random value, because it gets initialized in place of declaration. It means, that if You change that program to this:
    @{i}
    PROC main()
        ...
        DEF a=3
        WriteF('a equals to: \\d\\n', a)
        ...
    ENDPROC
    @{ui}
    You will get the proper value, I mean: 3.

    The same thing happens whenever a variable is a structure or array. Such variable is a pointer to the structure till it is initialized, that is, if You write sth like:
    @{i}
    PROC main()
        ...
        z[4].blerk:=33
        DEF z[100]:ARRAY OF blah
        ...
    ENDPROC
    @{ui}
    Your computer will probably crash. You must remember that "z" becomes an array of blah after the declaration, so the proper version is:
    @{i}
    PROC main()
        ...
        DEF z[100]:ARRAY OF blah
        z[4].blerk:=33
        ...
    ENDPROC
    @{ui}
    That's all, I suppose ;)
@ENDNODE
@REMARK E
@REMARK E
@REMARK B History
@NODE HISTORY "CreativE's History"

    @{"   " LINK HST_2_12} 2.12
    @{"   " LINK HST_2_10} 2.10
    @{"   " LINK HST_2_06} 2.06
    @{"   " LINK HST_2_05} 2.05
    @{"   " LINK HST_2_03} 2.03
    @{"   " LINK HST_2_02} 2.02
    @{"   " LINK HST_2_01} 2.01
    @{"   " LINK HST_2_00} 2.00
@ENDNODE
@REMARK B 2.00
@NODE HST_2_00 "CreativE v2.00"

    - Assembler for all the cpu's (010-060) except ~8 commands
    - Enhanced string format codes
    - Enhanced "long" strings format codes
    - New keywords
    - New variables
    - New commands
    - New error reports
    - New warnings
    - New expression components
    - Patcher

@ENDNODE
@REMARK E
@REMARK B 2.01
@NODE HST_2_01 "CreativE v2.01"

    - Inline commands! Faaaaast! 8D
    - x<<a.b now works correctly
    - Patcher (expanded)
    - Enhanced library declaration ("EXTRA" field)

@ENDNODE
@REMARK E
@REMARK B 2.02
@NODE HST_2_02 "CreativE v2.02"

    - Few optimizations
    - Expressions generated for 020+ (partially)
    - Few fixes
    - New IF statement format (<exp> ? <exp> : <exp>)

@ENDNODE
@REMARK E
@REMARK B 2.03
@NODE HST_2_03 "CreativE v2.03"

    - Pointer typing for variables (e.g. execbase::execbase.thistask)
    - Val() and CleanUp() work as they did
    - Enhanced inline instruction list
    - added "INLINE" keyword

@ENDNODE
@REMARK E
@REMARK B 2.05
@NODE HST_2_05 "CreativE v2.05"

    - Smarter version -> determines if the "inline" code is used by module(s)
    - Unions in objects!!! At last!
    - "lib" files support! began
    - expression swap (":=:")

@ENDNODE
@REMARK E
@REMARK B 2.06
@NODE HST_2_06 "CreativE v2.06"

    - Extended EA support! At last!!!
    - custom STARTUP code support
    - LONG <label> now possible
    - Reloc hunks in lib files
    - variable access from lib files
    - FOR loop now support expression for STEP
    - CCR/SR access from assembler
    - arrays, object members assignments inside array
    - extended array/object member access (+=, &=...)
    - pc relative access with direct values (e.g. 10(PC))

@ENDNODE
@REMARK E
@REMARK B 2.10
@NODE HST_2_10 "CreativE v2.10"

    - One can use the suggested by Motorola adressing modes
    - FOR loop now determines the type of params - faster than Wouter's
    - ELSEWHILE/ALWAYS (WHILE loop enhancements)
    - FPU can be used to calculate the floating-point expressions
    - "ARRAY OF" can be omitted (DEF a[100]:LONG)
    - PROCs now can get params via registers
    - LIBRARY mode fixed (bug in lib compiled w. EXTRA keyword)
    - "IF IF" sentence fixed
    - "ENDPROC WITH" sentence (for system exception handlers)
    - A couple of new error messages
    - Fixed a small bug in EA creator (D0.W.W.W.W.L etc)
    - Scale factors in EAs
    - Object members can be now odd-sized (i.e. a[3]:CHAR)
    - Changed moduleversion to 11 because of some module-improvements
    - SIZEOF <var> now possible
    - Fixed a bug in a few commands (i.e. Fatan())
    - Multiple pointers - beta feature
    - Variable typing (::)
    - Object files are created properly now
    - Sources released in another archive
@ENDNODE
@REMARK E
@REMARK B 2.12
@NODE HST_2_12 "CreativE v2.12"

    - Hunk support!!! YEEEAA!
    - Added the RUNBG option for use with executables
    - Internal variables became typed
    - Fixed some bugs in OPT FPEXP
    - Another fixes made to the module format
    - Shifts may be used in constants declaration
    - AmigaE support FTP site organized
    - OPT OPTI generates the RELOC16 hunk
    - "==" for checking expression with multiple values/ranges etc.
    - Creative needs at least 20k of stack [!!!]
    - SETUP and CLEANUP procedures for modules
    - linklibs support fixed
    - "/" and "*" produces the DIVS.L and MULS.L for 020+
    - some various fixes/improvements
    - variables can be defined nearly anywhere in proc
    - Some new commands added
    - Heavy optimizations done - output code is shorter than in Wouter's version in some cases :)
    - String constants introduced.
    - Extended interim buffer - most weird crashes shouldn't appear anymore

@ENDNODE
@REMARK E
@REMARK E
