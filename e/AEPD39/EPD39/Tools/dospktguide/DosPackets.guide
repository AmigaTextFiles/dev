@database "DosPackets"
@$VER: DosPackets 42.1 (8.8.95)
@author Bruce M. Simpson <bsimpson@toucdwn.demon.co.uk>
@remark A guide to standard DOS Packet arguments and functions.
@remark Mainly autogenerated by AD2AG ;-)
@master "DosPackets.doc"
@Node Main "DosPackets.doc"
    @{" --unknown--" Link "--unknown--"}
    @{" ACTION_CREATE_DIR " Link "ACTION_CREATE_DIR"}
    @{" ACTION_CURRENT_VOLUME " Link "ACTION_CURRENT_VOLUME"}
    @{" ACTION_DELETE_OBJECT " Link "ACTION_DELETE_OBJECT"}
    @{" ACTION_DIE " Link "ACTION_DIE"}
    @{" ACTION_DISK_INFO " Link "ACTION_DISK_INFO"}
    @{" ACTION_END " Link "ACTION_END"}
    @{" ACTION_EXAMINE_FH " Link "ACTION_EXAMINE_FH"}
    @{" ACTION_EXAMINE_OBJECT " Link "ACTION_EXAMINE_OBJECT"}
    @{" ACTION_EXAMINE_NEXT  " Link "ACTION_EXAMINE_NEXT"}
    @{" ACTION_FH_FROM_LOCK " Link "ACTION_FH_FROM_LOCK"}
    @{" ACTION_FINDINPUT " Link "ACTION_FINDINPUT"}
    @{" ACTION_FINDOUTPUT " Link "ACTION_FINDOUTPUT"}
    @{" ACTION_FINDUPDATE " Link "ACTION_FINDUPDATE"}
    @{" ACTION_FLUSH " Link "ACTION_FLUSH"}
    @{" ACTION_FORMAT " Link "ACTION_FORMAT"}
    @{" ACTION_FREE_LOCK " Link "ACTION_FREE_LOCK"}
    @{" ACTION_INFO " Link "ACTION_INFO"}
    @{" ACTION_INHIBIT " Link "ACTION_INHIBIT"}
    @{" ACTION_IS_FILESYSTEM " Link "ACTION_IS_FILESYSTEM"}
    @{" ACTION_LOCATE_OBJECT " Link "ACTION_LOCATE_OBJECT"}
    @{" ACTION_MORE_CACHE " Link "ACTION_MORE_CACHE"}
    @{" ACTION_PARENT " Link "ACTION_PARENT"}
    @{" ACTION_PARENT_FH " Link "ACTION_PARENT_FH"}
    @{" ACTION_READ " Link "ACTION_READ"}
    @{" ACTION_READ_LINK " Link "ACTION_READ_LINK"}
    @{" ACTION_RENAME_DISK " Link "ACTION_RENAME_DISK"}
    @{" ACTION_RENAME_OBJECT " Link "ACTION_RENAME_OBJECT"}
    @{" ACTION_SAME_LOCK " Link "ACTION_SAME_LOCK"}
    @{" ACTION_SCREEN_MODE " Link "ACTION_SCREEN_MODE"}
    @{" ACTION_SEEK " Link "ACTION_SEEK"}
    @{" ACTION_SERIALIZE_DISK " Link "ACTION_SERIALIZE_DISK"}
    @{" ACTION_SET_COMMENT " Link "ACTION_SET_COMMENT"}
    @{" ACTION_SET_DATE " Link "ACTION_SET_DATE"}
    @{" ACTION_SET_OWNER " Link "ACTION_SET_OWNER"}
    @{" ACTION_SET_PROTECT " Link "ACTION_SET_PROTECT"}
    @{" ACTION_WRITE " Link "ACTION_WRITE"}
    @{" ACTION_WRITE_PROTECT " Link "ACTION_WRITE_PROTECT"}
@EndNode
@Node "--unknown--" "DosPackets/--unknown--"
@{b}  Unknown Packets@{ub}

  These are packets I don't have any information on at this time.

	ACTION_ADD_NOTIFY
	ACTION_CHANGE_MODE
	ACTION_CHANGE_SIGNAL
	ACTION_COPY_DIR
	ACTION_COPY_DIR_FH
	ACTION_DEBUG
	ACTION_DISK_CHANGE
	ACTION_DISK_TYPE
	ACTION_EVENT
	ACTION_EXAMINE_ALL
	ACTION_EXAMINE_ALL_END
	ACTION_FREE_DISK_FSSM
	ACTION_FREE_RECORD
	ACTION_GET_DISK_FSSM
	ACTION_LOCK_RECORD
	ACTION_MAKE_LINK
	ACTION_NETWORK_HELLO
	ACTION_QUEUE
	ACTION_READ_RETURN
	ACTION_REMOVE_NOTIFY
	ACTION_SETTRANS
	ACTION_SET_FILE_SIZE
	ACTION_SET_MAP
	ACTION_STACK
	ACTION_STARTUP
	ACTION_TIMER
	ACTION_WAIT_CHAR
	ACTION_WRITE_RETURN
@EndNode
@Node "ACTION_CREATE_DIR" "DosPackets/ACTION_CREATE_DIR"

@{b}   NAME@{ub}
	ACTION_CREATE_DIR -- create a directory

@{b}   SYNOPSIS@{ub}
	ACTION_CREATE_DIR ( lock, name )
	                    Arg1  Arg2

	ACTION_CREATE_DIR ( BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Create a subdirectory of name 'name' in directory specified by 'lock'.

@{b}   INPUTS@{ub}
	lock - lock specifying directory in which to create new subdir.
	name - name of new subdir.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/CreateDir()" Link "dos/CreateDir()"}
@EndNode
@Node "ACTION_CURRENT_VOLUME" "DosPackets/ACTION_CURRENT_VOLUME"

@{b}   NAME@{ub}
	ACTION_CURRENT_VOLUME -- inquire about a file's volume and unit number

@{b}   SYNOPSIS@{ub}
	ACTION_CURRENT_VOLUME ( fh_Args )
	                          Arg1

	ACTION_CURRENT_VOLUME ( BPTR );

@{b}   FUNCTION@{ub}
	Inquire about a file's volume and unit number

@{b}   INPUTS@{ub}
	fh_Args - the fh_Args field of the active filehandle, or pointer to a
	          filehandle.  If NULL, return current volume and unit number.

@{b}   RESULTS@{ub}
	res1 - BPTR to current volume node where file is located
	res2 - unit number where file is located
@EndNode
@Node "ACTION_DELETE_OBJECT" "DosPackets/ACTION_DELETE_OBJECT"

@{b}   NAME@{ub}
	ACTION_DELETE_OBJECT -- delete a file or an empty directory

@{b}   SYNOPSIS@{ub}
	ACTION_DELETE_OBJECT ( lock, name )
	                       Arg1  Arg2

	ACTION_DELETE_OBJECT ( BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Delete an object.

@{b}   INPUTS@{ub}
	lock - lock on directory containing object or NULL for root of device
	name - name of object to delete.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	If the object to be deleted is a directory, and it still contains
	files, an error will be returned.

@{b}   SEE ALSO@{ub}
	@{"dos.library/DeleteFile()" Link "dos/DeleteFile()"}
@EndNode
@Node "ACTION_DIE" "DosPackets/ACTION_DIE"

@{b}   NAME@{ub}
	ACTION_DIE -- unload handler code from memory and free buffers

@{b}   SYNOPSIS@{ub}
	ACTION_DIE ()

	ACTION_DIE ( void );

@{b}   FUNCTION@{ub}
	Tell a handler to unload and flush.

@{b}   INPUTS@{ub}
	none

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.
@EndNode
@Node "ACTION_DISK_INFO" "DosPackets/ACTION_DISK_INFO"

@{b}   NAME@{ub}
	ACTION_DISK_INFO -- obtain information about a disk

@{b}   SYNOPSIS@{ub}
	ACTION_DISK_INFO(  id  )
	                  Arg1

	ACTION_DISK_INFO( BPTR );

@{b}   FUNCTION@{ub}
	Fill the specified @{"InfoData" Link "TEXT_INCLUDE:dos/dos.h/Main" 118} structure with information about the
	device.

@{b}   INPUTS@{ub}
	id - BPTR to an @{"InfoData" Link "TEXT_INCLUDE:dos/dos.h/Main" 118} structure.

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	When sent to a console handler, this packet now returns not only the
	window pointer in the id_VolumeNode field, but also a pointer to the
	console handler's console IO block in the id_InUse field.  (These
	fields are part of the @{"InfoData" Link "TEXT_INCLUDE:dos/dos.h/Main" 118} structure initialized by
	ACTION_DISK_INFO).  @{"Remember" Link "TEXT_INCLUDE:intuition/intuition.h/Main" 1233} that you must @{"AllocMem" Link "exec/AllocMem()"} your @{"InfoData" Link "TEXT_INCLUDE:dos/dos.h/Main" 118}
	structure to assure longword alignment since a BPTR to this structure
	is arg[0] for the packet.

	A pointer to the @{"ConUnit" Link "TEXT_INCLUDE:devices/conunit.h/Main" 54} structure (see @{"devices/conunit.h" Link "TEXT_INCLUDE:devices/conunit.h/Main" 0}, .i) can be
	found from the returned console IO block pointer:

	conUnit = (struct @{"ConUnit" Link "TEXT_INCLUDE:devices/conunit.h/Main" 54} *)
				((struct @{"IOStdReq" Link "TEXT_INCLUDE:exec/io.h/Main" 28} *)infoData->id_InUse)->io_Unit;

	There is a lot of useful information in the @{"ConUnit" Link "TEXT_INCLUDE:devices/conunit.h/Main" 54} structure such as
	text cursor position and limits.  If you are using the exec
	console.device directly, you should be able to get the @{"ConUnit" Link "TEXT_INCLUDE:devices/conunit.h/Main" 54} pointer
	from yourIoRequest->io_Unit.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Info()" Link "dos/Info()"}
@EndNode
@Node "ACTION_END" "DosPackets/ACTION_END"

@{b}   NAME@{ub}
	ACTION_END -- terminate access to a file via a handle.

@{b}   SYNOPSIS@{ub}
	ACTION_END ( fh_Args )
	              Arg1

	ACTION_END ( LONG );

@{b}   FUNCTION@{ub}
	Terminate access to a filehandle. Send this packet when done reading or
	writing from or to a file. Don't reuse the filehandle after sending
	ACTION_END, and don't send it more than once - doing so has been known
	to trash entire hard disks...

@{b}   INPUTS@{ub}
	fh_Args - the fh_Args field of the @{"FileHandle" Link "TEXT_INCLUDE:dos/dosextens.h/Main" 90}.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	I don't think this flushes the device buffers.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Close()" Link "dos/Close()"}
@EndNode
@Node "ACTION_EXAMINE_FH" "DosPackets/ACTION_EXAMINE_FH"

@{b}   NAME@{ub}
	ACTION_EXAMINE_FH -- examine an already open file

@{b}   SYNOPSIS@{ub}
	ACTION_EXAMINE_FH ( fh_Args,  fib  )
	                      Arg1   Arg2

	ACTION_EXAMINE_FH ( LONG, BPTR );

@{b}   FUNCTION@{ub}
	Examine an already opened file.

@{b}   INPUTS@{ub}
	fh_Args - the fh_Args field of the file's filehandle.
	fib     - BPTR to a @{"FileInfoBlock" Link "TEXT_INCLUDE:dos/dos.h/Main" 62} to recieve info.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/ExamineFH()" Link "dos/ExamineFH()"}
@EndNode
@Node "ACTION_EXAMINE_OBJECT" "DosPackets/ACTION_EXAMINE_OBJECT"

@{b}   NAME@{ub}
	ACTION_EXAMINE_OBJECT -- obtain information about an object

@{b}   SYNOPSIS@{ub}
	ACTION_EXAMINE_OBJECT ( lock, fib )
	                        Arg1  Arg2

	ACTION_EXAMINE_OBJECT ( BPTR, BPTR );

@{b}   FUNCTION@{ub}
	Obtain information about the specified object.

@{b}   INPUTS@{ub}
	lock - a lock on the object you wish to examine.
	fib  - BPTR to a @{"FileInfoBlock" Link "TEXT_INCLUDE:dos/dos.h/Main" 62} to hold the information.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Examine()" Link "dos/Examine()"}
@EndNode
@Node "ACTION_EXAMINE_NEXT" "DosPackets/ACTION_EXAMINE_NEXT"

@{b}   NAME@{ub}
	ACTION_EXAMINE_NEXT -- examine next entry in a directory

@{b}   SYNOPSIS@{ub}
	ACTION_EXAMINE_NEXT ( lock, fib )
	                      Arg1  Arg2

	ACTION_EXAMINE_NEXT ( BPTR, BPTR );

@{b}   FUNCTION@{ub}
	Obtain information on the next entry in a directory.  When you send
	this packet initially, the lock must be on the directory you wish to
	examine, and the @{"FileInfoBlock" Link "TEXT_INCLUDE:dos/dos.h/Main" 62} must have been initialised from a
	previous invoation of @{"ACTION_EXAMINE_OBJECT" Link "ACTION_EXAMINE_OBJECT"} on the directory.

	For more detailed information, see @{"dos.library/ExNext()" Link "dos/ExNext()"}.

@{b}   INPUTS@{ub}
	lock - a lock on the directory you wish to examine.
	fib  - BPTR to a previously initialised @{"FileInfoBlock" Link "TEXT_INCLUDE:dos/dos.h/Main" 62}.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.
	       The usual cause of failure is ERROR_NO_MORE_ENTRIES.

@{b}   SEE ALSO@{ub}
	@{"dos.library/ExNext()" Link "dos/ExNext()"}
@EndNode
@Node "ACTION_FH_FROM_LOCK" "DosPackets/ACTION_FH_FROM_LOCK"

@{b}   NAME@{ub}
	ACTION_FH_FROM_LOCK -- open a file from a lock

@{b}   SYNOPSIS@{ub}
	ACTION_FH_FROM_LOCK (   fh, lock )
	                      Arg1  Arg2

	ACTION_FH_FROM_LOCK ( BPTR, BPTR )

@{b}   FUNCTION@{ub}
	Open a file from a previously existing lock. This effectively
	relinquishes the lock.  The access type is determined by the type of
	the lock you pass in - SHARED_LOCK is similar to MODE_OLDFILE, whereas
	EXCLUSIVE_LOCK is similar to MODE_NEWFILE.

@{b}   INPUTS@{ub}
	fh   - pointer to previously allocated filehandle
	lock - lock on the file to open

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	If the open failed, the lock is still usable.

@{b}   SEE ALSO@{ub}
	@{"dos.library/OpenFromLock()" Link "dos/OpenFromLock()"}
@EndNode
@Node "ACTION_FINDINPUT" "DosPackets/ACTION_FINDINPUT"

@{b}   NAME@{ub}
	ACTION_FINDINPUT -- open an existing file for input

@{b}   SYNOPSIS@{ub}
	ACTION_FINDINPUT (  fh,  lock, name )
	                   Arg1  Arg2  Arg3

	ACTION_FINDINPUT ( BPTR, BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Open a previously existing file for reading.

@{b}   INPUTS@{ub}
	fh   - BPTR to a previously allocated @{"FileHandle" Link "TEXT_INCLUDE:dos/dosextens.h/Main" 90}.
	lock - lock on the directory holding file 'name'.
	name - BPTR to BCPL string specifying name of the file to open.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Open()" Link "dos/Open()"}
@EndNode
@Node "ACTION_FINDOUTPUT" "DosPackets/ACTION_FINDOUTPUT"

@{b}   NAME@{ub}
	ACTION_FINDOUTPUT -- open a new file for output

@{b}   SYNOPSIS@{ub}
	ACTION_FINDOUTPUT (  fh,  lock, name )
	                    Arg1  Arg2  Arg3

	ACTION_FINDOUTPUT ( BPTR, BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Open a new file for writing, overwriting any file of the same name
	which already exists.

@{b}   INPUTS@{ub}
	fh   - BPTR to a previously allocated @{"FileHandle" Link "TEXT_INCLUDE:dos/dosextens.h/Main" 90}.
	lock - lock on the directory holding file 'name'.
	name - BPTR to BCPL string specifying name of the file to open.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Open()" Link "dos/Open()"}
@EndNode

@Node "ACTION_FINDUPDATE" "DosPackets/ACTION_FINDUPDATE"

@{b}   NAME@{ub}
	ACTION_FINDUPDATE -- open a file for updating

@{b}   SYNOPSIS@{ub}
	ACTION_FINDUPDATE (  fh,  lock, name )
	                    Arg1  Arg2  Arg3

	ACTION_FINDUPDATE ( BPTR, BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Open a file for reading and writing, creating it if it didn't exist.

@{b}   INPUTS@{ub}
	fh   - BPTR to a previously allocated @{"FileHandle" Link "TEXT_INCLUDE:dos/dosextens.h/Main" 90}.
	lock - lock on the directory holding file 'name'.
	name - name of the file to open.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Open()" Link "dos/Open()"}
@EndNode
@Node "ACTION_FLUSH" "DosPackets/ACTION_FLUSH"

@{b}   NAME@{ub}
	ACTION_FLUSH -- flush contents of device's I/O buffers

@{b}   SYNOPSIS@{ub}
	ACTION_FLUSH ()

	ACTION_FLUSH ( void );

@{b}   FUNCTION@{ub}
	Cause pending blocks to be written out and motor turned off.  This is
	expensive, so should not be done after every write.  It is used by the
	system before putting up a requester saying "Change Disk" and the
	packet is only returned when the job is done.  This action would be
	useful in a database when it wished to commit.

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Flush()" Link "dos/Flush()"}
@EndNode
@Node "ACTION_FORMAT" "DosPackets/ACTION_FORMAT"

@{b}   NAME@{ub}
	ACTION_FORMAT -- initialise a filesystem for use

@{b}   SYNOPSIS@{ub}
	ACTION_FORMAT ( newname, dostype )
	                  Arg1   Arg2

	ACTION_FORMAT ( BSTR, LONG );

@{b}   FUNCTION@{ub}
	Initialise a filesystem.  This function performs no kind of low level
	formatting of media whatsoever.

@{b}   INPUTS@{ub}
	newname - name of new volume to create
	dostype - DosType to use, if filesystem supports multiple types.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Format()" Link "dos/Format()"}
@EndNode

@Node "ACTION_FREE_LOCK" "DosPackets/ACTION_FREE_LOCK"

@{b}   NAME@{ub}
	ACTION_FREE_LOCK -- free a lock on an object

@{b}   SYNOPSIS@{ub}
	ACTION_FREE_LOCK ( lock )
	                   Arg1

	ACTION_FREE_LOCK ( BPTR );

@{b}   FUNCTION@{ub}
	Free a lock that was previously obtained on an object. THE OBJECT MUST
	RESIDE ON THE FILESYSTEM YOU ARE SENDING THE PACKET TO!

@{b}   INPUTS@{ub}
	lock - the lock to free

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"ACTION_LOCATE_OBJECT" Link "ACTION_LOCATE_OBJECT"}, @{"dos.library/UnLock()" Link "dos/UnLock()"}
@EndNode

@Node "ACTION_INFO" "DosPackets/ACTION_INFO"

@{b}   NAME@{ub}
	ACTION_INFO -- obtain information about a handler

@{b}   SYNOPSIS@{ub}
	ACTION_INFO ( lock,  id  )
	              Arg1  Arg2

	ACTION_INFO ( BPTR, BPTR )

@{b}   FUNCTION@{ub}
	Obtain information about the disk on which an object resides.

@{b}   INPUTS@{ub}
	lock - lock on an object which is on the device to be examined
	id   - BPTR to an @{"InfoData" Link "TEXT_INCLUDE:dos/dos.h/Main" 118} structure to hold the information.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Info()" Link "dos/Info()"}
@EndNode

@Node "ACTION_INHIBIT" "DosPackets/ACTION_INHIBIT"

@{b}   NAME@{ub}
	ACTION_INHIBIT -- prevent user from accessing a filesystem

@{b}   SYNOPSIS@{ub}
	ACTION_INHIBIT ( flag )
	                 Arg1

	ACTION_INHIBIT ( LONG );

@{b}   FUNCTION@{ub}
	@{"Inhibit" Link "dos/Inhibit()"} a filesystem, i.e. prevent operations from taking place on it
	until it is un-inhibited. Commonly used to disable file operations
	before formatting or carrying out similar maintenance on a device.

	The volume appears to the user as 'Not a DOS Disk'.

	When called via dos.library, an @{"ACTION_FLUSH" Link "ACTION_FLUSH"} is usually sent to the
	handler first.

@{b}   INPUTS@{ub}
	flag - 0 to uninhibit, anything other than 0 to inhibit.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Inhibit()" Link "dos/Inhibit()"}
@EndNode

@Node "ACTION_IS_FILESYSTEM" "DosPackets/ACTION_IS_FILESYSTEM"

@{b}   NAME@{ub}
	ACTION_IS_FILESYSTEM -- determine if handler is a filesystem

@{b}   SYNOPSIS@{ub}
	ACTION_IS_FILESYSTEM ( )

	ACTION_IS_FILESYSTEM ( void );

@{b}   FUNCTION@{ub}
	Determine if handler is a filesystem.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if handler is a filesystem, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/IsFileSystem()" Link "dos/IsFileSystem()"}
@EndNode

@Node "ACTION_LOCATE_OBJECT" "DosPackets/ACTION_LOCATE_OBJECT"

@{b}   NAME@{ub}
	ACTION_LOCATE_OBJECT -- locate an object ('lock' it)

@{b}   SYNOPSIS@{ub}
	ACTION_LOCATE_OBJECT ( lock, name, type )
	                       Arg1  Arg2  Arg3

	ACTION_LOCATE_OBJECT ( BPTR, BSTR, LONG );

@{b}   FUNCTION@{ub}
	Locate an object and return a @{"FileLock" Link "TEXT_INCLUDE:dos/dosextens.h/Main" 453} on it.

@{b}   INPUTS@{ub}
	lock - lock on a directory. NULL for root directory.
	name - A pathname relative to 'lock'.
	type - Type of lock to obtain. Can be SHARED_LOCK or EXCLUSIVE_LOCK.

@{b}   RESULTS@{ub}
	res1 - Lock on the specified object or DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"ACTION_FREE_LOCK" Link "ACTION_FREE_LOCK"}, @{"dos.library/Lock()" Link "dos/Lock()"}
@EndNode

@Node "ACTION_MORE_CACHE" "DosPackets/ACTION_MORE_CACHE"

@{b}   NAME@{ub}
	ACTION_MORE_CACHE -- modify amount of cache buffers

@{b}   SYNOPSIS@{ub}
	ACTION_MORE_CACHE( buffers )
	                     Arg1

	ACTION_MORE_CACHE( LONG );

@{b}   FUNCTION@{ub}
	Change the amount of cache buffers allocated by a handler.

@{b}   INPUTS@{ub}
	buffers - signed longword integer specifying number of cache buffers to
	          create or delete. 0 returns the current number.

@{b}   RESULT@{ub}
	res1 - the new amount of cache buffers held by the handler.
	res2 - Secondary return code. You get this even if packet was successful

@{b}   NOTES@{ub}
	Older handlers may only support the creation of new buffers and not the
	deallocation of them. Examples include the release 1.3 FileSystem.

@{b}   SEE ALSO@{ub}
	@{"dos.library/AddBuffers()" Link "dos/AddBuffers()"}
@EndNode

@Node "ACTION_PARENT" "DosPackets/ACTION_PARENT"

@{b}   NAME@{ub}
	ACTION_PARENT -- obtain lock on parent directory of object

@{b}   SYNOPSIS@{ub}
	ACTION_PARENT ( lock )
	                Arg1

	ACTION_PARENT ( BPTR );

@{b}   FUNCTION@{ub}
	Obtains a lock on the parent directory of 'lock', which can either be a
	file or a directory.

	For more detailed information see @{"dos.library/ParentDir()" Link "dos/ParentDir()"}.

@{b}   INPUTS@{ub}
	lock - lock to find parent of.

@{b}   RESULTS@{ub}
	res1 - Lock on parent directory if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/ParentDir()" Link "dos/ParentDir()"}
@EndNode

@Node "ACTION_PARENT_FH" "DosPackets/ACTION_PARENT_FH"

@{b}   NAME@{ub}
	ACTION_PARENT_FH -- obtain parent directory of an open file

@{b}   SYNOPSIS@{ub}
	ACTION_PARENT_FH ( fh_Args )
	                    Arg1

	ACTION_PARENT_FH ( BPTR );

@{b}   FUNCTION@{ub}
	duplicate the lock on the parent dir of the specified file

@{b}   INPUTS@{ub}
	fh_Args - the fh_Args field of the file's filehandle structure.

@{b}   RESULTS@{ub}
	res1 - Lock on parent directory if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/ParentOfFH()" Link "dos/ParentOfFH()"}
@EndNode

@Node "ACTION_READ" "DosPackets/ACTION_READ"

@{b}   NAME@{ub}
	ACTION_READ -- read bytes of data from specified stream

@{b}   SYNOPSIS@{ub}
	ACTION_READ ( fh_Args,  buf, numbytes )
	                Arg1   Arg2    Arg3

	ACTION_READ ( LONG, APTR , ULONG );

@{b}   FUNCTION@{ub}
	Read data from specified filehandle, obtained with @{"ACTION_FINDINPUT" Link "ACTION_FINDINPUT"} or
	@{"ACTION_FINDUPDATE" Link "ACTION_FINDUPDATE"}.

@{b}   INPUTS@{ub}
	fh_Args  - the fh_Args field of the filehandle obtained with
	           @{"ACTION_FINDINPUT" Link "ACTION_FINDINPUT"} or @{"ACTION_FINDUPDATE" Link "ACTION_FINDUPDATE"}.
	buf      - pointer to the buffer which is to receive the data.
	numbytes - number of bytes to read from file.

@{b}   RESULTS@{ub}
	res1 - actual number of bytes read, or DOSFALSE if failed.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Read()" Link "dos/Read()"}
@EndNode

@Node "ACTION_READ_LINK" "DosPackets/ACTION_READ_LINK"

@{b}   NAME@{ub}
	ACTION_READ_LINK -- resolve a soft link

@{b}   SYNOPSIS@{ub}
	ACTION_READ_LINK ( lock, path, buf, size )
	                   Arg1  Arg2  Arg3 Arg4

	ACTION_READ_LINK ( BPTR, STRPTR, STRPTR, ULONG );

@{b}   FUNCTION@{ub}
	Resolve a soft link.

@{b}   INPUTS@{ub}
	lock - lock this path is relative to filesystem
	path - path that caused an ERROR_IS_SOFT_LINK
	buf  - pointer to buffer for new path from handler
	size - size of buffer.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/ReadLink()" Link "dos/ReadLink()"}
@EndNode

@Node "ACTION_RENAME_DISK" "DosPackets/ACTION_RENAME_DISK"

@{b}   NAME@{ub}
	ACTION_RENAME_DISK -- rename a volume.

@{b}   SYNOPSIS@{ub}
	ACTION_RENAME_DISK( name )
	                    Arg1

	ACTION_RENAME_DISK( BSTR );

@{b}   FUNCTION@{ub}
	Set the volume name of a device.

@{b}   INPUTS@{ub}
	name - pointer to a string containing the new name of the device.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Relabel()" Link "dos/Relabel()"}
@EndNode

@Node "ACTION_RENAME_OBJECT" "DosPackets/ACTION_RENAME_OBJECT"

@{b}   NAME@{ub}
	ACTION_RENAME_OBJECT -- rename an object

@{b}   SYNOPSIS@{ub}
	ACTION_RENAME_OBJECT ( lock, name, newlock, newname )
	                       Arg1  Arg2    Arg3     Arg4

	ACTION_RENAME_OBJECT ( BPTR, BSTR, BPTR, BSTR );

@{b}   FUNCTION@{ub}
	Rename an object.

@{b}   INPUTS@{ub}
	lock    - Lock on directory holding object (NULL for root).
	name    - Name of the object to be renamed / moved.
	newlock - Lock on directory to move object to (NULL for root).
	newname - New name for the object.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Rename()" Link "dos/Rename()"}
@EndNode

@Node "ACTION_SAME_LOCK" "DosPackets/ACTION_SAME_LOCK"

@{b}   NAME@{ub}
	ACTION_SAME_LOCK -- determine if two locks refer to same object (V36)

@{b}   SYNOPSIS@{ub}
	ACTION_SAME_LOCK ( lock1, lock2 )
	                    Arg1   Arg2

	ACTION_SAME_LOCK ( BPTR, BPTR );

@{b}   FUNCTION@{ub}
	Test if two locks are on the same object.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if both locks refer to same object, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/SameLock()" Link "dos/SameLock()"}
@EndNode

@Node "ACTION_SCREEN_MODE" "DosPackets/ACTION_SCREEN_MODE"

@{b}   NAME@{ub}
	ACTION_SCREEN_MODE -- set the mode of a CON: handler

@{b}   SYNOPSIS@{ub}
	ACTION_SCREEN_MODE ( rawMode )
	                       Arg1

	ACTION_SCREEN_MODE ( ULONG );

@{b}   FUNCTION@{ub}
	Switches CON: into raw mode and back again.

@{b}   INPUTS@{ub}
	rawMode - DOSTRUE for RAW: mode, DOSFALSE for CON: mode.

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	The packet should be sent to @{"MsgPort" Link "TEXT_INCLUDE:exec/ports.h/Main" 29} of the console's handler task,
	which is usually found in '(struct MsgPort *) process->pr_ConsoleTask'.

	Note that in addition to this, an escape sequence may be sent to turn
	on or off the automatic translation of LF to CR/LF.  Normally RAW:
	does not enable this and CON:  does.  SetRawMode does not affect the
	translation.  The escape sequences are CSI 20h to enable, and CSI 20l
	to disable this translation.

@{b}   SEE ALSO@{ub}
	@{"dos.library/SetMode()" Link "dos/SetMode()"}
@EndNode

@Node "ACTION_SEEK" "DosPackets/ACTION_SEEK"

@{b}   NAME@{ub}
	ACTION_SEEK -- seek to a new position in a file

@{b}   SYNOPSIS@{ub}
	ACTION_SEEK ( fh_Args,  pos, offset )
	                Arg1   Arg2   Arg3

	ACTION_SEEK ( LONG, LONG, LONG );

@{b}   FUNCTION@{ub}
	Change the position of the cursor within a file for reading or writing.

@{b}   INPUTS@{ub}
	fh_Args - the fh_Args field of the file to seek within.
	pos     - current position in file.
	offset  - seek offset relative to 'pos'.

@{b}   RESULTS@{ub}
	res1 - previous seek position in file, or DOSTRUE if the seek failed.
	res2 - If res1 was DOSTRUE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Seek()" Link "dos/Seek()"}
@EndNode

@Node "ACTION_SERIALIZE_DISK" "DosPackets/ACTION_SERIALIZE_DISK"

@{b}   NAME@{ub}
	ACTION_SERIALIZE_DISK -- make a filesystem unique (V39)

@{b}   SYNOPSIS@{ub}
	ACTION_SERIALIZE_DISK ()

	ACTION_SERIALIZE_DISK ( void );

@{b}   FUNCTION@{ub}
	Takes no parameters, makes the FS change the disk to make it unique
	(normally by changing the creation date).  Useful in diskcopy with
	non-amiga filesystems (diskcopy knows about amiga filesystems and can
	do it without the packet for them).  Normal sorts of return codes.

@{b}   INPUTS@{ub}
	none

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.
@EndNode

@Node "ACTION_SET_COMMENT" "DosPackets/ACTION_SET_COMMENT"

@{b}   NAME@{ub}
	ACTION_SET_COMMENT -- set the comment for an object

@{b}   SYNOPSIS@{ub}
	ACTION_SET_COMMENT (   0L, lock, name, comment )
	                     Arg1  Arg2  Arg3    Arg4

	ACTION_SET_COMMENT ( ULONG, BPTR, BSTR, BSTR );

@{b}   FUNCTION@{ub}
	Sets the file note / comment on 'file' in directory specified by 'lock'
	to 'comment'.

@{b}   INPUTS@{ub}
	lock    - lock on directory containing file
	name    - name of file
	comment - the comment

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/SetComment()" Link "dos/SetComment()"}
@EndNode

@Node "ACTION_SET_DATE" "DosPackets/ACTION_SET_DATE"

@{b}   NAME@{ub}
	ACTION_SET_DATE -- set 'last modified' date of an object

@{b}   SYNOPSIS@{ub}
	ACTION_SET_DATE ( 0L, lock, fname, ds )
	                 Arg1 Arg2  Arg3  Arg4

	ACTION_SET_DATE ( ULONG, BPTR, BSTR, APTR );

@{b}   FUNCTION@{ub}
	Sets the date of a file or directory to specified date.

@{b}   INPUTS@{ub}
	lock - lock on @{"ParentDir" Link "dos/ParentDir()"} of file
	fname - BPTR to BCPL string of filename
	ds - APTR to a @{"DateStamp" Link "TEXT_INCLUDE:dos/dos.h/Main" 53} structure

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	Arg1 should always be set to NULL.

@{b}   SEE ALSO@{ub}
	@{"dos.library/SetFileDate()" Link "dos/SetFileDate()"}
@EndNode

@Node "ACTION_SET_OWNER" "DosPackets/ACTION_SET_OWNER"

@{b}   NAME@{ub}
	ACTION_SET_OWNER -- set ownership information for an object (V39)

@{b}   SYNOPSIS@{ub}
	ACTION_SET_OWNER ( NULL, lock,  name, owner_info )

	ACTION_SET_OWNER ( ULONG, BPTR, BSTR, LONG );

@{b}   FUNCTION@{ub}
	Sets the ownership information for an object.  Similar arguments to
	@{"ACTION_SET_PROTECT" Link "ACTION_SET_PROTECT"}, except the data is a longword of owner info:  high
	16 bits are GID (group), low 16 are UID (user id).

@{b}   INPUTS@{ub}
	lock  - specifies parent directory of the object
	name  - name of the object
	owner_info  - High 16 bits are GID (group), low 16 are UID (user ID).

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"ACTION_SET_PROTECT" Link "ACTION_SET_PROTECT"}, dos.library/SetOwner()
@EndNode

@Node "ACTION_SET_PROTECT" "DosPackets/ACTION_SET_PROTECT"

@{b}   NAME@{ub}
	ACTION_SET_PROTECT -- set attributes of an object

@{b}   SYNOPSIS@{ub}
	ACTION_SET_PROTECT ( NULL, lock,  name, attrs )

	ACTION_SET_PROTECT ( ULONG, BPTR, BSTR, LONG );

@{b}   FUNCTION@{ub}
	Sets the attributes or 'protection bits' for an object.

	See @{"<dos/dos.h>" Link "TEXT_INCLUDE:dos/dos.h/Main" 0} for a list of these attributes.

@{b}   INPUTS@{ub}
	lock  - specifies parent directory of the object
	name  - name of the object
	attrs - longword of flags specifying file attributes

@{b}   RESULT@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/SetProtection()" Link "dos/SetProtection()"}, @{"ACTION_SET_OWNER" Link "ACTION_SET_OWNER"}
@EndNode

@Node "ACTION_WRITE" "DosPackets/ACTION_WRITE"

@{b}   NAME@{ub}
	ACTION_WRITE -- write bytes of data to specified stream

@{b}   SYNOPSIS@{ub}
	ACTION_WRITE ( fh_Args,  buf, numbytes )
	                 Arg1   Arg2    Arg3

	ACTION_WRITE ( LONG, APTR , ULONG );

@{b}   FUNCTION@{ub}
	Write data to specified filehandle, obtained with @{"ACTION_FINDOUTPUT" Link "ACTION_FINDOUTPUT"} or
	@{"ACTION_FINDUPDATE" Link "ACTION_FINDUPDATE"}.

@{b}   INPUTS@{ub}
	fh_Args  - the fh_Args field of the filehandle obtained with
	           @{"ACTION_FINDOUTPUT" Link "ACTION_FINDOUTPUT"} or @{"ACTION_FINDUPDATE" Link "ACTION_FINDUPDATE"}.
	buf      - pointer to the buffer which contains the data to be written.
	numbytes - number of bytes to write to the file.

@{b}   RESULTS@{ub}
	res1 - actual number of bytes written, or DOSFALSE if failed.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   SEE ALSO@{ub}
	@{"dos.library/Write()" Link "dos/Write()"}
@EndNode

@Node "ACTION_WRITE_PROTECT" "DosPackets/ACTION_WRITE_PROTECT"

@{b}   NAME@{ub}
	ACTION_WRITE_PROTECT -- 'write protect' a filesystem (V34)

@{b}   SYNOPSIS@{ub}
	ACTION_WRITE_PROTECT ( flag,  key )
	                       Arg1  Arg2

	ACTION_WRITE_PROTECT ( LONG, LONG );

@{b}   FUNCTION@{ub}
	Prevent write access to a filesystem using a key.

@{b}   INPUTS@{ub}
	flag - DOSTRUE to lock device, DOSFALSE to unlock.
	key  - Key to lock drive with. Required for unlocking.

@{b}   RESULTS@{ub}
	res1 - DOSTRUE if successful, else DOSFALSE.
	res2 - If res1 was DOSFALSE, this tells you why the error occured.

@{b}   NOTES@{ub}
	The AmigaDOS 'Lock' command uses a 'key' of 0 if no passkey is
	specified on the command line, otherwise it uses a simple encoding
	algorithm on the key supplied.

	This is a method of software write protection, nothing more.
@EndNode
