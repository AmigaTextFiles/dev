@database

@NODE MAIN
                       The Tutorial Sources Guide File
                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   This file is intended to be used as an on-line reference whilst reading
the main tutorial. As you browses from left to right, this takes you through
this document in ascending example order. Hope you like this file!

                               Comments welcome!
@ENDNODE

@NODE e1

-> Example1.e
-> The Most Basic Muse Program.

MODULE 'muse/muse'
PROC main() IS easy_muse([[WINDOW,[]]])
@ENDNODE

@NODE e2

-> Example2.e
-> Bigger Things

MODULE 'muse/muse'
PROC main() IS easy_muse([
   [WINDOW, [
             [BOX, [30,15,590,200]]
            ]
   ]
])
@ENDNODE

@NODE e3

-> Example 3.e
-> Hello, world! Seconded for the most boring example!

MODULE 'muse/muse'
PROC main() IS easy_muse([
   [WINDOW, [
             [TITLE, 'Hello, World!']
            ]
   ]
])
@ENDNODE

@NODE e4

-> Example 4.e
-> Hello, world and Bigger Things.

MODULE 'muse/muse'
PROC main() IS easy_muse([
   [WINDOW, [
             [TITLE, 'Hello, World!'],
             [BOX, [30,15,590,200]]
            ]
   ]
])
@ENDNODE

@NODE e4a

-> Example 4a.e
-> Hello, world and Bigger Things. Done using variables to reduce brackets!

MODULE 'muse/muse'

PROC main()
DEF title, box, mywindow
   title:=    [TITLE, 'Hello, World!']
   box:=      [BOX, [30,15,590,200]]
   mywindow:= [title, box]

   easy_muse([
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE

@NODE e5

-> Example 5.e
-> As example 4a, but now with keyboard processing.

MODULE 'muse/muse'
PROC main()
DEF title, box, keyboard, mywindow
   title:=    [TITLE, 'Hello, World!']
   box:=      [BOX, [30,15,590,200]]
   keyboard:= [KEYS, [  ["q", QUIT], ["k", CLOSE]
                     ]
              ]
   mywindow:= [title, box,keyboard]

   easy_muse([
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE

@NODE e6

-> Example 6.e
-> As per example 5, but with a CLOSE event handler!

MODULE 'muse/muse'

PROC main()
DEF title, box, keyboard, mywindow, myevents
   title:=    [TITLE, 'Hello, World!']
   box:=      [BOX, [30,15,590,200]]
   keyboard:= [KEYS, [ ["q", QUIT], ["k", CLOSE]
                     ]
              ]
   mywindow:= [title, box,keyboard]


/*    Here we declare the pointer to the event handling procedure in the
      event definitions list */
   myevents:= [
                 [CLOSE, {mycloseprocessor}]
              ]

   easy_muse([
               [EVENTS, myevents], -> This is where Muse finds out!
               [WINDOW, mywindow]
             ])
ENDPROC

PROC mycloseprocessor() IS CLOSE
   -> This procedure effectively short-circuits the 'Do you really want to
   -> close this window' requester by returning CLOSE which signals `Yes'
   -> to that question to Muse.,
@ENDNODE

@NODE e7

-> Example7.e
-> Let's try just having a gadget in the window!

MODULE 'muse/muse'
PROC main()
DEF mywindow, mygadgets
   mygadgets:=[
                 ['RADIO', [0,0,['Hello','There','Then',0],10,10,0]]
              ]
   mywindow:=[[GADGETS, mygadgets]]

   easy_muse([
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE

@NODE e8

-> Example8.e
-> Same as Example7.e but can now query the selection!

MODULE 'muse/muse'
ENUM NONE, QUERY_VALUE        -> QUERY_VALUE is used as a user-event number which
                              -> is raised by the gadget.

DEF labels:PTR TO LONG        -> Used to hold a pointer a an array of strings
                              -> to use as the gadget's labels.


/*{-------------- ADDITIONAL PROCEDURE -------------}*/
PROC display_selection()      -> The QUERY_VALUE event handler.
DEF v
   v:=get_gadget_info(get_gadgethandle('message')) -> Get the gadget's value (integer)
   request(labels[v])                              -> Display the string relating to it
ENDPROC
/*{---------- END OF ADDITIONAL PROCEDURE ----------}*/



PROC main()
DEF mygadgets, mywindow, myevents
   labels:=['Hello','There','Then',0]
   mygadgets:= [
                ['RADIO', [QUERY_VALUE,'message', labels,10,10,0]]
               ]
   mywindow:=[
              [GADGETS, mygadgets]
             ]

/*    This line declares a pointer to a procedure to call when the event
      QUERY_VALUE is raised by the gadget */
   myevents:=[
              [QUERY_VALUE, {display_selection}]
             ]

   easy_muse([
               [EVENTS, myevents],     -> Give Muse the processing.
               [WINDOW, mywindow]      -> Give Muse the window.
             ])
ENDPROC
@ENDNODE

@NODE e9

-> Example9.e
-> As per Example8.e, but now queries via a key press! ('?' key)
-> You will note the query procedure, and the event declaration has NOT changed.

MODULE 'muse/muse'
ENUM NONE, QUERY_VALUES        -> QUERY_VALUE is used as a user-event number which
                               -> is raised by the gadget.

DEF labels:PTR TO LONG        -> Used to hold a pointer a an array of strings
                              -> to use as the gadget's labels.

PROC display_selection()      -> The QUERY_VALUE event handler.
DEF v
   v:=get_gadget_info(get_gadgethandle('message')) -> Get the gadget's value (integer)
   request(labels[v])                              -> Display the string relating to it
ENDPROC

PROC main()
DEF mykeys, mygadgets, mywindow, myevents    -> Variable mykeys added
   mykeys:=    [["?", QUERY_VALUES]          -> Extra line.
               ]
   labels:=    ['Hello','There','Then',0]
   mygadgets:= [
                  ['RADIO', [NONE,'message',labels,10,10,0]] -> disable querying
               ]                                             -> when gadget clicked.
   mywindow:=[
                [KEYS,    mykeys],           -> Extra line.
                [GADGETS, mygadgets]
             ]
/* No changes from here on! */
   myevents:=[
               [QUERY_VALUES, {display_selection}]
             ]

   easy_muse([
               [EVENTS, myevents],
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE

@NODE e10

-> Example10.e
-> As per Example9.e, but has a completely different appearnce!
-> Only one line changed...

MODULE 'muse/muse'
ENUM NONE, QUERY_VALUES      -> NO CHANGE!

DEF labels:PTR TO LONG       -> NO CHANGE!

PROC display_selection()     -> NO CHANGE!
DEF v
   v:=get_gadget_info(get_gadgethandle('message'))
   request(labels[v])
ENDPROC

PROC main()
DEF mykeys, mygadgets, mywindow, myevents    -> NO CHANGE!
   mykeys:=     [["?", QUERY_VALUES]
                ]
   labels:=['Hello','There','Then',0]

/* THIS LINE HAS THE CHANGE!!! */
   mygadgets:=  [
                   ['CYCLE', [NONE,'message','Options',80,10,80,labels]]
                ]
   mywindow:=[
                [KEYS,    mykeys],
                [GADGETS, mygadgets]
             ]
   myevents:=[
               [QUERY_VALUES, {display_selection}]
             ]

   easy_muse([
               [EVENTS, myevents],
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE


@NODE e11

-> Example11.e
-> This program has a simple menu, and a simple menu event handler.

MODULE 'muse/muse'

ENUM NONE, SELECTION

/* Menu event handler */
PROC menu_selection() IS request('You selected a menu item!')

PROC main()
DEF mymenus, mywindow, myevents
/* Define the menus we want and their event numbers */
   mymenus:= [
               ['HEADER','Project'],
               ['ITEM', ['New'    ,'n',SELECTION]],
               ['ITEM', ['Open...','o',SELECTION]],
               ['ITEM', ['Close',  'k',SELECTION]],
               ['ITEM', ['Quit',   'q',QUIT]]
             ]

/*    Define the window structure.
      This version lets everything else - size etc - take their default values */
   mywindow:=[
              [MENUS,    mymenus]
             ]
   myevents:=[
               [SELECTION, {menu_selection}]    -> Define the processing
             ]
   easy_muse([
               [EVENTS, myevents],     -> Tell Muse about the processing.
               [WINDOW, mywindow]      -> Tell Muse about the window.
             ])
ENDPROC
@ENDNODE


@NODE e12

-> Example12.e
-> A more complex menu.

MODULE 'muse/muse'
ENUM NONE, SELECTION

/* Same handler */
PROC menu_selection() IS request('You selected a menu item!')

PROC main()
DEF mymenus, mywindow, myevents
   mymenus:= [
               ['HEADER','Project'],
                  ['ITEM', ['New'    ,'n',SELECTION]],
                  ['STD_IMAGE', ['OPEN','o',SELECTION]],      -> Images
                  ['ITEM', ['Printer',0,0]],                  -> Sub menu header
                     ['SUBITEM',       ['Print','p',0]],      -> Sub item.
                     ['SUB_STD_IMAGE', ['PRINT','p',0]],      -> Image in a sub-menu
                     ['SUB_STD_IMAGE', ['PRINTSETUP','p',0]],
                  ['BAR',0],
                  ['ITEM', ['Close',  'k',SELECTION]],
                  ['BAR',0],
                  ['ITEM', ['Quit',   'q',QUIT]],
               ['HEADER','Edit'],
                 ['STD_IMAGE', ['MUSE_LOGO',0,0]],
                  ['ITEM', ['Clips',0,0]],
                     ['SUB_STD_IMAGE', ['CUT',  'x',0]],
                     ['SUB_STD_IMAGE', ['COPY', 'c',0]],
                     ['SUB_STD_IMAGE', ['PASTE','v',0]]
             ]
/* NO CHANGES FROM HERE ON */
   mywindow:=[
                [MENUS,    mymenus]
             ]
   myevents:=[
               [SELECTION, {menu_selection}]
             ]
   easy_muse([
               [EVENTS, myevents],
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE

@NODE e13

-> Example13.e
-> As per Example12.e and also Example8.e because we've merged the two examples.
-> We can now query the gadget's value by a menu selection instead, but you may
-> notice our procedure to process the QUERY_VALUE event, still hasn't changed!
MODULE 'muse/muse'

ENUM NONE, SELECTION, QUERY_VALUE
DEF labels:PTR TO LONG

-> As before.. Ex 12
PROC menu_selection() IS request('You selected a menu item!')

-> As before.. Ex 8
PROC display_selection()
DEF v
   v:=get_gadget_info(get_gadgethandle('message'))
   request(labels[v])
ENDPROC

PROC main()
DEF mygadgets, mymenus, mywindow, myevents
   labels:=['Hello','There','Then',0]     -> Ex 8
   mygadgets:=  [
                   ['CYCLE', [NONE,'message','Options',80,10,80,labels]]   -> Ex 8
                ]
   mymenus:= [                                                 -> EX 12
               ['HEADER','Project'],
                  ['ITEM', ['New'    ,'n',SELECTION]],
                  ['STD_IMAGE', ['OPEN','o',SELECTION]],
                  ['ITEM', ['Printer',0,0]],
                     ['SUBITEM',       ['Print','p',0]],
                     ['SUB_STD_IMAGE', ['PRINT','p',0]],
                     ['SUB_STD_IMAGE', ['PRINTSETUP','p',0]],
                  ['BAR',0],

/* New option!! */
                  ['ITEM', ['What''s the gadget value?',  '?',QUERY_VALUE]],
                  ['BAR',0],
                  ['ITEM', ['Quit',   'q',QUIT]],
               ['HEADER','Edit'],
                 ['STD_IMAGE', ['MUSE_LOGO',0,0]],
                  ['ITEM', ['Clips',0,0]],
                     ['SUB_STD_IMAGE', ['CUT',  'x',0]],
                     ['SUB_STD_IMAGE', ['COPY', 'c',0]],
                     ['SUB_STD_IMAGE', ['PASTE','v',0]]
             ]

   mywindow:=[
                [GADGETS, mygadgets],
                [MENUS,   mymenus]
             ]

/* NOTE how you delcare extra procressing - you just do it! */
   myevents:=[
               [QUERY_VALUE, {display_selection}],
               [SELECTION, {menu_selection}]
             ]
   easy_muse([
               [EVENTS, myevents],
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE


@NODE e14

-> Example14.e
-> A vaguely complex menu, cycle gadget, a button to query it,
-> a menu option to query the cycle gadget, and a keyboard shortcut to
-> query it.
-> All these methods of querying the gadget you will notice *still* use the
-> same processing code!

MODULE 'muse/muse'

ENUM NONE, SELECTION, QUERY_VALUE
DEF labels:PTR TO LONG

/* This might seem silly, but these two procedures STILL haven't changed! */
PROC menu_selection() IS request('You selected a menu item!')
PROC display_selection()
DEF v
   v:=get_gadget_info(get_gadgethandle('message'))
   request(labels[v])
ENDPROC



PROC main()
DEF title, box, keyboard, mygadgets, mymenus, mywindow, myevents, name
   name:=     'WINODW1'             -> name for window
   title:=    'Hello, World!'       -> Text to put in title bar
   box:=      [30,15,240,70]        -> Lets declare the window size
   keyboard:= [                     -> Declare a keyboard handler.
                 ["?", QUERY_VALUE],
                 ["q", QUIT],
                 ["k", CLOSE]
              ]
   labels:=['Hello','There','Then',0]     -> As before


-> The first gadget is the gadget that cycles through the options.
-> The second, when clicked, tells Muse to raise a QUERY_VALUE event.
   mygadgets:=  [
                   ['CYCLE', [NONE,'message','Options',80,10,80,labels]],
                   ['BUTTON',[QUERY_VALUE,0,'Cycle value...',40,30,160,13]]
                ]


/* The menu declaration */
   mymenus:= [
               ['HEADER','Project'],
                  ['ITEM', ['New'    ,'n',SELECTION]],
                  ['STD_IMAGE', ['OPEN','o',SELECTION]],
                  ['ITEM', ['Printer',0,0]],
                     ['SUBITEM',       ['Print','p',0]],
                     ['SUB_STD_IMAGE', ['PRINT','p',0]],
                     ['SUB_STD_IMAGE', ['PRINTSETUP','p',0]],
                  ['BAR',0],
                  ['ITEM', ['What''s the gadget value?',  '?',QUERY_VALUE]],
                  ['BAR',0],
                  ['ITEM', ['Quit',   'q',QUIT]],
               ['HEADER','Edit'],
                 ['STD_IMAGE', ['MUSE_LOGO',0,0]],
                  ['ITEM', ['Clips',0,0]],
                     ['SUB_STD_IMAGE', ['CUT',  'x',0]],
                     ['SUB_STD_IMAGE', ['COPY', 'c',0]],
                     ['SUB_STD_IMAGE', ['PASTE','v',0]]
             ]


/* Now follows a fully fledged window declaration with lots of bits in it! */
   mywindow:=[
                [TITLE,   title],
                [BOX,     box],
                [KEYS,    keyboard],
                [GADGETS, mygadgets],
                [MENUS,   mymenus]
             ]


/* The rest from here on is the same as all the other examples like this! */
   myevents:=[
               [QUERY_VALUE, {display_selection}],
               [SELECTION, {menu_selection}]
             ]
   easy_muse([
               [EVENTS, myevents],
               [WINDOW, mywindow]
             ])
ENDPROC
@ENDNODE


@NODE e14a

-> Example14a.e 11/11/95
-> This is Example14.e, with better structure.

MODULE 'muse/muse'

ENUM NONE, SELECTION, QUERY_VALUE
DEF labels:PTR TO LONG

/*{------------------------------- Startup Code --------------------------------}*/
PROC main()
   easy_muse(myinterface())
ENDPROC

/*{-------------------------------- The Program! --------------------------------}*/
PROC menu_selection() IS request('You selected a menu item!')

PROC display_selection()
DEF v
   v:=get_gadget_info(get_gadgethandle('message'))
   request(labels[v])
ENDPROC


/*{-------------------------- The Interface Definition --------------------------}*/
PROC myinterface()
DEF title, box, keyboard, mygadgets, mymenus, mywindow, myevents, interface
   title:=    'Hello, World!'
   box:=      [30,15,240,70]
   keyboard:= [
                 ["?", QUERY_VALUE],
                 ["q", QUIT],
                 ["k", CLOSE]
              ]

   labels:=['Hello','There','Then',0]
   mygadgets:=  [
                   ['CYCLE', [NONE,'message','Options',80,10,80,labels]],
                   ['BUTTON',[QUERY_VALUE,0,'Cycle value...',40,30,160,13]]
                ]

   mymenus:= [
               ['HEADER','Project'],
                  ['ITEM', ['New'    ,'n',SELECTION]],
                  ['STD_IMAGE', ['OPEN','o',SELECTION]],
                  ['ITEM', ['Printer',0,0]],
                     ['SUBITEM',       ['Print','p',0]],
                     ['SUB_STD_IMAGE', ['PRINT','p',0]],
                     ['SUB_STD_IMAGE', ['PRINTSETUP','p',0]],
                  ['BAR',0],
                  ['ITEM', ['What''s the gadget value?',  '?',QUERY_VALUE]],
                  ['BAR',0],
                  ['ITEM', ['Quit',   'q',QUIT]],
               ['HEADER','Edit'],
                 ['STD_IMAGE', ['MUSE_LOGO',0,0]],
                  ['ITEM', ['Clips',0,0]],
                     ['SUB_STD_IMAGE', ['CUT',  'x',0]],
                     ['SUB_STD_IMAGE', ['COPY', 'c',0]],
                     ['SUB_STD_IMAGE', ['PASTE','v',0]]
             ]

   mywindow:=[
                [TITLE,   title],
                [BOX,     box],
                [KEYS,    keyboard],
                [GADGETS, mygadgets],
                [MENUS,   mymenus]
             ]

   myevents:=[
               [QUERY_VALUE, {display_selection}],
               [SELECTION, {menu_selection}]
             ]
   interface:=[
                 [EVENTS, myevents],
                 [WINDOW, mywindow]
              ]
ENDPROC interface
@ENDNODE

@NODE e14b

-> Example14b.e
-> This is Example14.e with an alternative, possibly horrendous structure!
-> It does however illustrate very graphically the declarative nature of Muse.
-> It also illustrates the heirarchy involved in defining an interface.
-> One typing mistake though can be a nightmare to find...
MODULE 'muse/muse'

ENUM NONE, SELECTION, QUERY_VALUE
DEF labels:PTR TO LONG

/*{------------------------------- Startup Code --------------------------------}*/
PROC main()
   labels:=['Hello','There','Then',0]
   easy_muse(myinterface())
ENDPROC

/*{-------------------------------- The Program! --------------------------------}*/
PROC menu_selection() IS request('You selected a menu item!')

PROC display_selection()
DEF v
   v:=get_gadget_info(get_gadgethandle('message'))
   request(labels[v])
ENDPROC


/*{-------------------------- The Interface Definition --------------------------}*/
PROC myinterface() IS [
   [EVENTS, [
               [QUERY_VALUE, {display_selection}],
               [SELECTION, {menu_selection}]
            ]],
   [WINDOW,
            [
               [TITLE,   'Hello, World!'], -> end of title
               [BOX,     [30,15,240,70]],  -> end of box
               [KEYS,    [
                            ["?", QUERY_VALUE],
                            ["q", QUIT],
                            ["k", CLOSE]
                         ]],  -> end of keys
               [GADGETS, [
                            ['CYCLE', [NONE,'message','Options',80,10,80,labels]],
                            ['BUTTON',[QUERY_VALUE,0,'Cycle value...',40,30,160,13]]
                         ]], -> end of gadgets
               [MENUS,   [
                            ['HEADER','Project'],
                            ['ITEM', ['New'    ,'n',SELECTION]],
                            ['STD_IMAGE', ['OPEN','o',SELECTION]],
                            ['ITEM', ['Printer',0,0]],
                            ['SUBITEM',       ['Print','p',0]],
                            ['SUB_STD_IMAGE', ['PRINT','p',0]],
                            ['SUB_STD_IMAGE', ['PRINTSETUP','p',0]],
                            ['BAR',0],
                            ['ITEM', ['What''s the gadget value?',  '?',QUERY_VALUE]],
                            ['BAR',0],
                            ['ITEM', ['Quit',   'q',QUIT]],
                            ['HEADER','Edit'],
                            ['STD_IMAGE', ['MUSE_LOGO',0,0]],
                            ['ITEM', ['Clips',0,0]],
                            ['SUB_STD_IMAGE', ['CUT',  'x',0]],
                            ['SUB_STD_IMAGE', ['COPY', 'c',0]],
                            ['SUB_STD_IMAGE', ['PASTE','v',0]]
                         ]] -> end of menus
            ]] -> end of window
] -> end of interface definition declaration!
@ENDNODE
