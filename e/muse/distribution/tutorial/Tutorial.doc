
                            The Muse Tutorial
                            ~~~~~~~~~~~~~~~~~

                        Text ©1996 Michael Sparks






Introduction
~~~~~~~~~~~~
     The aim of this tutorial is to introduce you gently into first simple
examples, followed by more complex examples of how to code and process user
interfaces using Muse. I have placed the emphasis on GUI interfaces, but I
hope to do an extended tutorial including ARexx examples at a later date.

     Included with this tutorial, is a sources.guide file that contains a
copy of the source codes referenced by this document. The way I envisage this
tutorial being read is with the source.guide file being displayed at the same
time. You will also find in the tutoials source(s) directory a copy of all the
programs to use if you prefer.

     Those files are provided to enable you to easily compile them to see the
results. This does assume you have installed Muse properly though. (ie copied
the contents of the emodules directory in the distribution to your EMODULES: 
directory; and the contents of the libs directory to your LIBS: directory.)

     This is the first tutorial I have ever written, I hope it is useful!
Let's Go!


Basics
~~~~~~
     The first thing we need to know is how to use Muse in a program. If you
look at example 1, which is the shortest program that uses Muse I can think of,
consists of only two program lines! The first line ` MODULE 'muse/muse' ` is the
line that tells the E compiler to include all information and code needed to
use Muse in your program.

     The second is the main() procedure and that bit does the `hard' part. It
initialises Muse, creates a window, waits for the user to try to close it, asks
them if they really want to, and if they do, closes it and quits the program!
The way this works is the procedure easy_muse() takes the definition in between
the brackets, checks it is a valid definition, and if it is, creates it, and
waits for a CLOSE or QUIT event. The important part to look at in this program
is what is between those brackets:
          [[WINDOW, []]]

     Why so many brackets you may ask? The reason is most interfaces are more
complex than just one empty window and Muse is designed to cater for most
interface styles. A perhaps more clear way of writing the above definition
would be:
          1:   [
          2:      [WINDOW,[]]
          3:   ]

     The numbers are for reference only. If you look at this, lines 1 and 3 are
the opening and closing square-brackets that define a list. The Muse definition
itself is a list of Muse elements where each element has the form:
         [identification-field, definition-field]

     In the case of defining a window, the identification field is the value
WINDOW, whereas the definition field is a list of window definition elements.
This list is allowed to be empty, but it must be present, hence the minimal
value for it is []. These three facts combined show that the minimal window
element that is valid is:
          [WINDOW, [] ]

      Which means the minimal Muse interface definition is that in square
brackets, giving:
          [[WINDOW, []]]
As we saw above.

      Muse takes this definition, looks at the first element and sees it is
a window definition. It notices that the window definition list is empty and
therefore takes the defaults hard-coded in Muse as the window defaults and
opens the window. It waits for the user to click on the close gadget, and when
the user does so, Muse raises a CLOSE event. In doing so, it checks to see if
you have defined a procedure to deal with the event and discovers that you
didn't. As a result Muse calls its standard CLOSE event processor which asks
the user if they really want to close the window. If the user clicks on the yes
button, this standard procedure returns the value CLOSE to Muse which in turn
closes the window (otherwise Muse doesn't!).

     Whenever a window is closed, Muse checks to see if there are any Muse
windows left open to process input from. If there aren't any, then Muse raises
a QUIT event and leaves the easy_muse() procedure, thus (in this example)
quitting the program.



First Steps Towards a Decent Interface
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     The first real step is to learn how to customise the window by changing
its title bar, its size, adding gadgets, menus and adding processing of that
sort of window. So that's what we're going to do wth the rest of the examples
in the sources.guide file and in the "tutorial source" directory.


Changing Aspects of The Window
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     In example two, I show how to change the window dimensions. In pratical
terms, in the window definition list (which was empty `[]' in example 1 we add
a window box definition element. Like all elements it has two parts: an
identification-field and a definition-field. In a window bos definition, the
contents of the identification field is the value BOX, and its definition is a
constant list with four elements defining the left edge, top edge, width and
height in that order.

Hence given the definition:
          [WINDOW, [
                    [BOX, [30,15,590,200]]
                   ]
          ]

tells Muse that we wish to create a window which is defined to have a window
box that has it's top left corner at 30,15 , has a width of 590 pixels and a
height of 200 pixels. The rest of the program acts as before.

     I may have laboured the point a bit here, but the main point is that I am
showing how you can build up a window definition out of Muse elements. This is
the same thing as building up the Muse definition in essence - the elements are
different, but the technique is the same.


Changing the Window Title
~~~~~~~~~~~~~~~~~~~~~~~~~
     In this example, (Example3.e), we change the window definition element so
that instead of a different window size, we have a different window title. The
way we do this is using exactly the same technique. Since we wish to define the
window title, we add a window title definition element to the window definition
element. Its identification field takes the value TITLE and the definition
field is a string defining what we would like to see in the title bar.

Hence given the window definition:
          [WINDOW, [
                    [TITLE, 'Hello, World!']
                   ]
          ]

   This tells Muse that we wish to have a window with the words 'Hello, World!'
in its title bar. (What else?!-) As you can see, we've used the same technique
as before - different contents, but the same technique nonetheless.



Combining the two examples
~~~~~~~~~~~~~~~~~~~~~~~~~~
   In this example (Example4.e) we just take the two program's we've just done
and combine them so that we have a big window with Hello, World! in the title
bar. In practice, since we wish to define box the box and title, we have to
include those two elements in the window definition list. We do this in the
following manner:
          [WINDOW, [
                    [TITLE, 'Hello, World!'],
                    [BOX, [30,15,590,200]]
                   ]
          ]

As you can wee, I've separated the two elements by a comma. That's all you have
to worry about. The _ordering_ of the two elements is unimportant. Hence:
          [WINDOW, [
                    [BOX, [30,15,590,200]]
                    [TITLE, 'Hello, World!'],
                   ]
          ]

gives the same result. Whilst we're on this sort of thing, this:
          [WINDOW, [
                     [BOX, [30,15,590,200]]
                     [TITLE, 'Hello, World!'],
                     [BOX, [10,10,400,30]]
                   ]
          ]

   Will not crash, will do the same thing everytime in this version, but is
undefined and any side-effects thus relied on in this version cannot be relied
upon in future versions. So if you do it by accident, you're program will still
work, but I would make sure that you don't!


Alternative forms
~~~~~~~~~~~~~~~~~
   Example4a.e is exactly the same program, but uses a different format to show
what a Muse program can also look like. The format used is more programmer
friendly if you get an error from the E-compiler saying missing brackets. It
also helps if Muse tells you that your interface definition has a structural
error. It is in many respects a more readable and friendly way of using Muse,
but no more valid than the method used in Example4.e. I shall be coming back to
Muse programming styles in a later section.

   The techniques are combined in the Muse version of the address book program
in the example apps, to show a much better way of using Muse to separate out
the interface and concrete processing of it from the abstract processing that
the program performs on its data.


Adding Inputs to the Program
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     This is the first stage that must be done to turn a window into an
interface. Later examples will show how to merge interfaces with programs
to form applications. The first example, as before will be the simplest sort
you can do.

   In Example5.e we add keyboard processing to the program that we've created
so far. In practical terms, applications recieve keyboard inputs via their
window. So to add keyboard processing, we need to add a keyboard input
definition element to the window definition we've created so far.

     This like all other elements consists of the two fields mentioned
previously, but in this case the identification field consists of the value
KEYS, where as this definition field is a list of keyboard mappings. Each
keyboard mapping takes a character (key) and defines an event to be raised
when that key is
pressed.
   It takes the form:
          [key, event]

     In the list there can be as many of these as we like, as long as they are
separated by commas. Thus if we wish to quit the program when the letter q is
pressed, the keyboard mapping would be ["q", QUIT] where quit is the standard
event value as defined by Muse. If we wish to close the window when the key k
is pressed - ie raise a CLOSE event, the keyboard mapping would be:
          ["k", CLOSE].
Given this, the keyboard mapping list would be:
          [
               ["q",QUIT], ["k",CLOSE]
          ]

Which means a full keyboard definition for this takes the form:
          [KEYS, [  ["q",QUIT], ["k",CLOSE]
                 ]
          ]
 
If we let the variable keyboard take this value, and have variables box and
title similarly defined, the window definition looks thus:
          [WINDOW, [box, title, keyboard]
          ]

In the program, the variable mywindow is defined to take the value:
          [box,title,keyboard]
and is used in the place of the list above.

   And that as they say is that. As before Muse takes the definition, opens the
window with the attributes defined beforehand, but now also waits for any
keyboard input that the user makes, and checks it with the keys in the keyboard
definition. As you would expect, the key q will just quit the program, whereas
the k key will raise a CLOSE event and have the same result as clicking on the
close gadget. 


Basic Input Processing
~~~~~~~~~~~~~~~~~~~~~~
     So far, we've let Muse handle all the processing required. This
next example (Example6.e)introduces the techniques required to do your
own processing. What we're going to do is create our own event handling
procedure for the standard CLOSE event. Our program will now be made to
NOT ask the user if they really want to close the window, it will just
close.

     For this to happen, we need to write a CLOSE event handler procedure.
As mentioned elsewhere, Muse will only close the window if such a procedure
returns the value CLOSE. Anything else the procedure does, Muse doesn't care
about. Thus all our procedure needs to do is return the value CLOSE.

     It doesn't require the event number either, because we will define this
procedure only to be called when a close event is raised. Also, we don't need
the window since we're just ditching the close event requester. As a result,
the procedure itself does not need to have any parameters. Taking all this
information into account, the procedure looks thus:
          PROC mycloseprocessor() IS CLOSE

     If you did require either of the two arguments mentioned your procedure
heading should look thus:
          PROC mycloseprocessor(event, secondary_info)
But since we don't, it doesn't!

     The way we tell Muse about this is via an events definition element. The
identification field of takes the value EVENTS, whereas the definition field is
a list of event mapping elements. These are similar in appearance to keyboard
mapping elements. They look thus:
          [event_number, procedure_to_call]

     They define as you can probably deduce a procedure to be called when the
event on the left is raised by an input. The procedure is referenced via a
pointer to the procedure.

    Using the example above, the pointer would be: {mycloseprocessor}. The
event would be CLOSE giving a mapping element of [CLOSE, {mycloseprocessor}].
Thus our event elements list would take the form:
          [
               [CLOSE, {mycloseprocessor}]
          ]

     Which if we called this myevents as in the program, which makes our events
element:
          [EVENTS, myevents]

     This makes the modified Muse definition (and thence our procedure call)
look thus:
          easy_muse([
                      [EVENTS, myevents],
                      [WINDOW, mywindow]
                   ])

     If you now compile the program and run it, you will find that when you
press the key k or click on the close gadget that the window just closes,
_without_ asking you if you really want to or not.

     And as far as the events processing is concerned, and how you define
handler procedures, that's all there is to it. If the program raised more
events, then you just define more event handlers in exactly the same way
(probably different code inside the procedures though).


Making a GUI
~~~~~~~~~~~~
     Now that we've seen all the basic principals involved with creating an
interface using Muse and the basic principal behind processing, we're ready to
start creating `proper' interfaces. The first step is to see how we process
gadgets. I say those, because they are really the most visible part of a GUI
and therefore any program that has one. The next example (example7.e) shows
how to add them.

     The way we add these is very similar (and the same conceptually) as
adding keyboard inputs to a window. The way we do this is to define a list
of gadgets using a gadgets definition element. The gadgets definition element
has the value GADGETS in the identification field, and a list of gadget
definition elements in the definition field.

     Each gadget definition consists of two parts like all Muse elements in
that it has an identification field and a definition field. In the case of all
gadgets, the identification field is a string with the name of a gadget type -
 eg 'IMAGE'.

     In the demonstration source, I have assign the list of gadgets to a
variable mygadgets. Inside that list, is the definition of one gadget. Since
we're not actually *doing* anything with it, like decoration, it has not been
given a name, or an event number to raise.

     The radio gadget used is used to determine a value between 0 and 2
inclusive which are indices into the array containing the strings in the gadget
definition. The value determines which option is currently displayed. The two
10s after that list define the location where that gadget resides, whereas the
0 at the end determines which option is selected initially.

     The example (I feel) clearly demonstrates the relationship between
gadgets, their window and Muse. To add more gadgets, you would just insert
more gadget definition lines into the mygadgets list. (separated by comma
obviously)


Processing Gadgets
~~~~~~~~~~~~~~~~~~
     In the next example (Example8.e) I show how to query/display the value
of this gadget when the user clicks on the gadget. In doing so, our program
becomes closer to being anything like useful since not only are we reacting
to user input, we are gathering data as well.

    Since we wish to react to the user when they click on the gadget, we need
to define an event number for it. The enumeration in the program enables us
to reference this event as QUERY_VALUE. Also so that we can modify the labels
used in the gadget easily we are using a variable labels to hold a list of the
labels rather than justlisting them in the definition.

     Since we will be wanting to query the gadget's value, we need to give
the gadget a name. The name I've given it is 'message' since that is what the
labels sort of are.  Also we wish to do something when the user clicks on the
gadget, so we define the event QUERY_VALUE to be raised when this happens.  We
do these two things by modifying the first two fields of the gadget definition
itself.

     In order to do anything when the event is raised, we need to define an
event handler to deal with the event. The procedure display_selection() does
this. Therefore our event mappings list looks like:
          [
             [QUERY_VALUE, {display_selection}]
          ]
     Which tells Muse to call display_selction() whenever the QUERY_VALUE event
is raised. This is subtly different from saying call that procedure when the
gadget is clicked on since it does not preclude other inputs raising the event.

I will now briefly mention how display_selection() works.

   The first line gets the current value that the gadget currently has. The
way it does this is by using the procedure get_gadget_info(). However that
procedure requires a pointer to the gadget, and does not accept the gadget
name. To get the gadget pointer to pass on to get_gadget_info we call the
procedure get_gadget with the name of the gadget to return the pointer to
the gadget with that name.

     The second line takes the value returned which is an index into the list
labels and uses the label in the corresponding list position as the argument
to the procedure request. the procedure then displays a requester with the
label's text in the body of the requester and waits until the user clicks on
the OK button before closing.

      So whenever the QUERY_VALUE event is raised, (At this stage our program
only does so via one method) Muse calls this procedure, which in turn queries
the gadget and displays its value. In the next two programs, we shall build on
the two main aspects raised by this example:
              ·  The fact that querying the gadget depends on an input
                 raising the QUERY_VALUE event.

              ·  The fact that the gadget processing depends on the value
                 the gadget returns and not the look of the gadget that
                 returns it.


Gathering Data from Gadgets that Don't Raise Events
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     This example (Example9.e) deals with the first point mentioned with
reference to example 8. The gadget definition has been modified so that the
gadget has been changed so that it does not raise an event. Since it doesn't
raise an event, we need to define an input that raises the QUERY_VALUE event -
otherwise we have no way of getting the program to query it.

     The way this example does this is to add a keyboard event to the window
which is raised when the user presses the ? key. As before the event raised
is the QUERY_VALUE event. We add then keyboard definition into the window
definition, and that's it as far as the program is concerned.

   The reason we don't modify the display_selection() procedure, despite the
fact that the input that causes it to be called has changed, is because the
procedure does not depend on the style of input to work. It is only dependent
on there being a gadget that is called message that can return a value that
lies in the indices set formed from the indices of the list labels.

     And that's it. You can now query the gadget just by pressing a key. The
modifications are simple to make due to the flexibility of the structure. The
next example is almost as 'silly'!


Changing the Interface, But Not the Program!
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     In this example (example10.e) we take example 9 and change one line. The
gadget we used previously was a radio gadget. We are now going to use a cycle
gadget instead. The reason we can do this is because both gadgets take a list
of options and return a value that is an index into that list.

     A key difference between them though is with a cycle gadget, you cannot
set the initial value when the window is initially created. You could via a
startup event though - if you must! Aside from these very minor considerations,
that is that. There are no more modifications in the program.


Comment on Examples8-10
~~~~~~~~~~~~~~~~~~~~~~~
     I feel that these three very graphically demonstrate the principals that
Muse enshrines in its system for the programmer. In Muse, the program should
not be worried about concrete details concerning the interface. It should just
concern itself with processing information it can gather and obviously react to
user input.

     The reacting part is very easy to automate, so Muse also makes it easy to
just gather data. In these three examples the `program' can be considered the
procedure display_selection(). After all, the program could do something much
more interesting based on the selection that just display it. An example would
be to display a picture based on the selection the user made.

     Another thing to note, is that these three examples have demonstrated
ALL the principles in processing gadgets that you need to know. Anything else
you do (with the exception of setting gadget values) is just syntax. In the
case of setting gadget values, the technique is identical to the of getting
the gadget's value. The only difference is the command name, and the fact you
supply a value instead of recieve one.

     So instead of carrying on with gadgets now, we'll turn to menus


Dealing with Menus
~~~~~~~~~~~~~~~~~~
     Example 11 shows a simple Muse program with a menu definition. There is
an artificial edge to it it that all the menu options except quit raise the
same event. If they really did this in practice, it would mean that they were
all for the same purpose. Other than that though it is a very `clean' example
of how a menu relates to a window definition.

     Example 12 also doesn't actually do that much, but is does show what a
fairly small but realistic (to some extant) menu might look like. It has two
main menus, with each having a sub menu. You will notice that the example uses
several standard images in the menus. It should be apparent that doing so is
no more difficult than using text in a menu option. For various reasons you
cannot have an image as a menu header and you cannot have an image with text
in the menu. Yet.

      The indentation I have used in this example is one that I recommend that
you use since if you miss out any brackets, it will make it easier to find
_where_ you've missed them.


Creating a Fully Fledged Program with Gadgets and Menus
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     This example (13) just takes examples 12 and 8 and combines them to
form one complete program. If you look at it, the lines that needed
modification are minimal. One line is the enumeration - which has been
modified to contain both events that the program is interested in. The
display_selection() procedure has also not been changed, despite the fact
that the QUERY_VALUE event is raised by a menu option now.

     The biggest change, if you can call it that, is in the window definition,
in that we now have both a gadgets definition and a menus definition. Having
said that though it is the first Muse program that you've seen so far that
does. A similar change has happened in the event mappings list.

     Despite the grand sounding name of this section, that's really all there
is to it. Disappointingly simple really isn't it?


The Last of the Do Virtually Nothing Interface Demos
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
     This is example 14. This example is the same as example 13 except you
can now query the gadget via clicking on a button gadget, pressing a key, or
selecting a menu option. These are all declared and defined in exactly the
same manner as before hand, and as such, there's not much to write home
about. The main thing you'll probably want to look at is the window definition,
because the title bar has also been changed, and the window itself been given
a name.

     The reason the window has been given a name is because it enables you
to get hold of the pointer to the window should you ever need to. As with all
names in Muse Version 1 the name must be unique.

   The two remaining examples (14a & b) are there to show two alternative forms
that example 14 could take. In practice a decent form is a combination of both
of these styles. The first style (14a) has the advantage that it is easy to
find where you've missed out or misplaced brackets. The second style (14b)
helps to show the heirachical nature of Muse and doesn't use any temporary
variables where they aren't absolutely necessary. There isn't anything
inherently wrong with that style, but it can make it difficult to find
missing brackets.


Example Applications
~~~~~~~~~~~~~~~~~~~~
     To help take this tutorial beyond programs that do very little I have
written and included the source to two simple example appilcations. One is a
paint program, the other is an address book program.  Also in the case of the
address book program I have included the source to a text based version of the
same program to show exactly how the interface code relates to program code.

    In this section I will discuss their usage of Muse and structure in
fairly general terms because you will find in their respective directories
more detailed documentation as to how they work.


The Paint Program
~~~~~~~~~~~~~~~~~
     This program is as far as program's go very simple conceptually. All it
does is keep track of which colour the user wants to draw with & what shape
they want to draw with. It then just sits there waiting for the user to tell
it that they've changed colour (via an event raised by the palette gadget) or
changed tool (each tool icon raises a distinct event). Also when the user to
clicks the mouse in the draw window, it then renders the approriate shape into
the draw window at the location(s) where the mouse was clicked.

     From Muse's point of view this is very simple to do. All we do is define
an interface with 2 windows - one empty with just a title saying its the draw
window. The other has a gadgets list definition that includes all the draw
icons the program requires an a palette gadget. It also has a keyboard
definition to enable the user to change tools via a key-press.

     From the program's point of view, it has to have a procedure for each
event raised by the mouse clicking either in the draw window, or by the mouse
clicking on a draw icon. There's not really that much more to it. A paint
program like this is essentially a doddle to write using Muse since it is
all interface and virtually no processing.


The Address Book Program
~~~~~~~~~~~~~~~~~~~~~~~~
     This is much more like it. A `real' application with a GUI. The address
book program is a fully working sub set of the features you would normally
have in a true address book program. You can store up to 100 records (easily
changeable) where each record can store the name, address and telephone number.
Searches can be done on any field and any combination of fields. You can search
on part of a name (eg "mith" matches "Smith" amongst others), address or
telephone number (eg area code).

    sidenote: this document will  only describe the structure  of the program
              and how it relates to muse, I will not go into detail as to the
              algorithms  used.  I do that in the documentation  accompanying
              the source.

  When we begin to consider this the best place to start is to try and simplify
the problem. One way of doing this is by trying to identify the modules we will
need to write to get the program working. A possible technique, and the one
used, is to do the following:

   · We're storing information about people. This means we're going to need
     a structure to store information about a person. This also implies that
     we're going to want to be able to easy create, modify, destroy and compare
     these structures. All this is quite a lot of things to do and they all
     logically refer to the manipulation of a single instance of data. It
     therefore makes sense to make this a module. The source file is person.e

   · Now that we can do all of these things on a single record, it'd be nice to
     be able to store and retrieve these easily. Things the storage mechanism
     should be able to do is:
           ø  add records to the store
           ø  delete specfic records from the store. (implies search)
           ø  search for records and return the next occurance after each
              search (this implies some sort of search position indicator)
           ø  techniques to return the current record, and the number of
              records
     All this is also wrapped up in a module. The source file is people.e

     The bulk of our program, technically, is now written, but that's not
enough. Things that we still can't do is let the user control the program or
see the results of the program. In short - it needs an interface. This itself
can also be split up into 2 distinct sections - look and control. A different
way of viewing that, can be concrete interface handling (nuts and bolts) and
abstract interface control (plans and blueprints). I'll describe these next,
and try to convince you why this is a good idea.

   · The first one is the concrete interface handling. What this module does is
     just control on a low-level the interface which the user can see. It is
     specifically just to do with input and output of data. In the case of both
     versions, they need to be able provide a method for doing the following:
           ø  Displaying data.
           ø  Displaying the interface so the user knows what to type/click.
           ø  Provide a means for the user to be able to enter name, address
              and telephone details for a single person.
           ø  Provide a means of making this available so that the data can be
              presented to the relevent feature in the people module.
           ø  Provide/display a means of control for/to the user.

      All of these are very simple and low-level, but very related in that they
     are ALL concrete. Some say "Select an option", others take input from the
     user and provide to the system that's using this module. This module could
     be considered an interface input/output module. (But NOT process/control!)

   · The next (and last) module is highly abstract. It is so abstract that if
     you look at the top level module (of the Muse version) it just looks like
     pseudo-code, except it's not!

        It uses and binds together the raw-interface control with the high
     level storage control. It performs any and all necessary initialisations.
     Imposes structure on the control of things like searches.

        The text version breaks these rules a touch by using the interface
     occasionally on a concrete level. It shouldn't but it does. However if
     you look at it's main() procedure, you'll see that even that looks like
     pseudo-code. The same goes for most of the rest of the text version's top
     level module.

        The Muse version however, is much better behaved - it does _NO_
     low-level control of the interface other that which it should. The
     top-level should be control of the program and binding, which it is.

        The only 'low-level' work it does is initialise the interface by taking
     the window definition from the interface IO module (source address_gui.e),
     slams it into a Muse definition structure with a list of events and
     procedures and slams that into easy_muse(). Not really low-level! That is
     the extent to which the interface impinges on the top-level module.

        Note that the event numbers are defined in (and exported from) the
     address_gui.e module. This enables them to be used in input declarations
     and event declarations, but to enable keeping them separate. I think this
     type of modular structure really demonstrates how independent from the
     look of a program the control processing can and should be. It also shows
     the ease by which such separation has been made. This is the key advantage
     with Muse.

     The address book program truly shows how irrelevant the interface itself
is to the program itself. After all, what has changed, logically, to the
program's functionality when we changed the interface from text to GUI. The
answer is the following:
   · increased ease of use.
   · much shorter learning curve - it's all there ready to use.

     That's it. The features of the search and storage engine and the
information it can store didn't change, but without that engine, we'd have
a pretty interface with nothing behind it. Much like some games. Mentioning
no names.


End Notes
~~~~~~~~~
     As we have seen through out, creating, modifying, destroying and
processing of interfaces in Muse is simple. This last example showed just
how far the separation of an interface from the processing of the data and
program can go. I would recommend that any non-trivial programs take the
format of the address book program. The paint program format I feel is fine
for short programs however.

     Another thing to note is that any program that is display intensive, as we
have seen from the paint program, is fairly trivial to write. Any program that
processes data however in any meaningful way (as say a draw program might) is a
completely different kettle of fish.

   When writing your programs, remember that the user can click or press on any
part of your program's interface in any order. You should therefore make sure
that any program you write is aware of this. In essence each event handling
procedure is a mini-program in itself, dedicated to perfoming a particular
action upon request/event. They should, therefore, make no assumptions about
the state of the program and its interface without explicitly checking it first
- unless it is has good reason to do otherwise.

     This will take a little practice, but examine the address book program in
detail to see how this works in a real example. Other than that, and learning
the elements that you have available, you can now program and process a decent
interface using Muse. The reference document supplied is totally comprehensive
covering virtually everything to do with Muse. Once you've read the conceptual
parts and seen how the various bits link together you probably won't need to do
so again for quite a while, since the two reference documents cover evrything
you'll need on a day by day basis.

     You might consider printing them out - one on each side of an A4 sheet -
for convenience. When you consider how much power you have available and the
fact that the day by day reference you need to use that power efficiently is
just 2 A4 sides, I think you'll see just how much effort has gone into Muse to
make it that simple but powerful. The alternative is to wade through 2 rom
kernal manuals and create your interface from scratch. (or use other pd
offerings)

     Remember this system is FREEWARE. You can copy it and use it for any
purpose you choose. The only constraint is to contact me and let me know
what you think of it. This I do not consider too much to ask! As mentioned
elsewhere, there will be mid '96 a registered version available with many,
many new features which will have a modest price tag. There will also be
available shortly - before end Feb '96 a printed comprehensive manual for
this version.

     The bulk of it has already been written formatted and printed. I am still
in the process of reviewing it and honing it. It goes into much more detail on
everything, so that anyone who reads it will have a much greater level of
understanding of Muse.

     It's being produced using the PageStream2.2UK coverdisk as supplied by CU
Amiga magazine and each copy will also be bound and packed from cover to cover
with useful information: from diagrams of the structure of Muse to the quick
reference section, and detailed appendices. It is designed to be a definitive
reference to this version, and will point the way in which later versions may
progress.

     Just in case you're wondering though - it _expands_ on what's written
in the documents you have NOW, but does not giving you new topics since none
have been left out of these documents. I want Muse to be used, usable and
understandable with or without the printed manual. You will probably get more
out of Muse though if you have the manual. (It's designed to help you - not
make me money!)


     And that's that. If you have any queries please feel free to contact me.
Any detailed queries would be best made in writing, with perhaps a listing and
details of your machine's configuration. If you write by snail-mail, rather
than e-mail please enclose return postage and be prepared for a wait of up-to
2 weeks.

Check my web-page for up-to-date contact details:-
                              http://www.bridge.anglia.ac.uk/~csbs94mps

(potentially out of date details are with this
 distribution archive in the reference document)
