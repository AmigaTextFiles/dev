
                          The Paint Program Example
                          ~~~~~~~~~~~~~~~~~~~~~~~~~
                                (public domain)
                        Version 0 1995 Michael Sparks

                        Support/Explaination Document

Introduction
~~~~~~~~~~~~
   The paint program in this directory is the smallest `real' application
that I can think of as an application. It's code is very short, but it is
a very good example of how the Muse environment is programmed. Usage of
the program is no different from any other paint program. (things you can
do though is much more limited)

   In  it  I  have  also  used  code from  the  Muse  support  module
`manipulators.m'. The reason I've used it is because it makes conversions
between data formats quick and simple. A manipulator is a list of pairs
of values, (ie two columns of values...) and the function info2data()
takes a value that is in the left-hand side column and returns the
corresponding one in the right.


Compilation
~~~~~~~~~~~
If Muse is set up on your system, type `EC easy-paint' . That's it!


Program Overview
~~~~~~~~~~~~~~~~
   The interface consists of two windows: a tool bar window which
contains image gadgets pertaining to the different drawing modes and
colours available, and a draw window. This enables the program to operate
in a modal manner. At any time, you can either be drawing boxes, lines,
circles or dots, or selecting a new drawing mode or colour.

   When the mode is set or changed, a pointer to the procedure that does
the drawing is set to the correct procedure for that mode. When the user
clicks the mouse in the draw window, the program calls the procedure thus
pointed to with the location where the mouse was clicked. This may in
fact be a pair of locations (mouse-down and mouse-up) depending on the
draw-tool. The information required to ensure that two locations go to
box drawing routines (eg) and one location to dot drawing is stored with
a copy of the pointer to the procedure in a manipulator that converts a
mode value to this pair.
  see procedures: initialise_draw_tools(), setmode(), mouse()

   When the user changes the colour, this raises a COLOUR (user) event
which causes the procedure setcolour() to be called. All this does is
read the current value of the palette gadget and uses that.

   The mouse handling procedure ensures that if a rendering procedure
requires two locations that it recieves two locations. If it requires
one, then the rendering procedure is called on the button-down of the
mouse click. In either case, before the rendering procedure is called,
the _locations_ are clipped to ensure that they do not lie either above
or to the left of the window!

   The rendering functions themselves are equally polite. They all wait
until the blitter is free before sending a request to draw to the
graphics library. (In the first version I didn't and kept crashing my
machine - Muse was processing my input much faster than I anticipated! -
For those who don't know, if you send too many requests to the blitter in
quick succession via graphics calls etc, then it crashes because it can't
keep up and you're interrupting it!) Another aspect is that when drawing
boxes the direction of point 1 to point 2 must go DOWN and towards the
RIGHT across the screen. The program ensures this too!

   You can incidentally set the draw mode using the keyboard as well;
this is what each key does:
   .  sets the mode to DOTS
   l  sets the mode to LINES
   c  sets the mode to CIRCLES
   b  sets the mode to BOXES
   q  quits the program
   k  closes the (draw) window!


Comment
~~~~~~~
   The best thing to do now would be for you to compare the program with
this description of how it works, and also with how it works in practice.
The bit to look carefully at is where the variable `render' crops up, and
how it is used. (esp in the mouse() procedure) Advisable also is to look
at HOW the variable drawtools is initialised, and used.


Adding to the Application
~~~~~~~~~~~~~~~~~~~~~~~~~
   Overall, this application is very simple, but has a lot of potential.
For example to add a new drawing method would just require you to write
the procedure. Give it an mode value, a gadget (image type perhaps?) to
enable that mode to be set, and an entry added to the manipulator in
initialise_draw_tools(). An example addition might be:
      [EQUILATERAL,[{equilateral}, TRUE]]

   This would enable a mode that allows you to draw equilateral triangles
at any angle. The capitalised bit would be the mode value that would be
added to the `ENUM' line. The bit in braces (`{'&`}') would be a pointer
to/name of a rendering procedure. The TRUE bit says that this function
DOES require 2 locations. I'll leave that up to you to write if you like.

   Adding an ARexx port to this would be fairly simple to do. I haven't
done this (yet) though due to time constraints! Again, you might like to
try doing this...


End Note
~~~~~~~~
   Feel free to modify the program to your hearts content! If you make
(m)any major changes and release it, unless the program is massively
changed, please credit me! (after all, I've done the hard bit - the
actual mechanics of the interface!)
