@DATABASE "Muse.guide"
@AUTHOR "Michael Sparks"
@(C) "© 1995 Michael Sparks"




@NODE MAIN "Welcome to Muse!"
@TOC "Muse.guide/Contents"

                          T H E    M U S E

                    R E F E R E N C E    G U I D E

                     (Also known as the Appendix)

                         ©1995 Michael Sparks

      Muse. The nine Muses helped and inspired people to create.
                        Consider this a tenth.

                               @{"Contents" link Contents}

 STOP PRESS! The Muse web site is now ONLINE!
               http://www.anglia.ac.uk/~mps102/index.html
@ENDNODE




@NODE Contents "MUSE - Contents"
@TOC "Muse.guide/Contents"
                              CONTENTS
                              ========

                            @{"Introduction" link Introduction}
                              @{"Concepts" link Concepts}

                         @{"Program Structure" link ProgramStructure}
                          @{"Elements Syntax" link ElementsSyntax}
                        @{"Procedure Reference" link ProcedureReference}
                     @{"Functions Quick Reference" link FunctionsRef}
                              (flat list)
                   @{"Variables Muse Makes Available" link MuseVariables}
                @{"Constants Available for use in Muse" link Constants}

                              @{"History" link History}
                              @{"Author" link Author}
                              @{"Credits" link Credits}
                         @{"Registration/Cost" link Registration}
@ENDNODE





@NODE Introduction "MUSE - Introduction to Muse"
@TOC "Muse.guide/Contents"
                        Introduction
                        ============

                            Muse.m
                      (+support modules)
          An interface programming system for AmigaE.

OBJECTIVES
----------
   The main idea behind Muse is that life should be easy for users. This
includes programmers, since they are users too. Also users should have as
much control over how they interact with their program as possible. This
includes programmers. ie programmers and end-users should have as much
control over their programs.


THIS VERSION
------------
   This version of Muse, the release version is the first step towards that
goal. It is primarily aimed at programmers programming in the langauge
AmigaE. It is designed to be very programmer friendly in that to process/
create/destroy an interface, all you do is declare it. The advantage is the
fact that you are no longer worried with HOW it's implemented. This means
that you can concentrate on getting your program right.


USAGE
-----
  To use it, you have make a directory "muse" in your emodules: directory.
You then copy all the modules supplied there. You then create a directory
"muse" in your LIBS: directory, and copy all the standard image icons there.
If your program uses any of these you will need to distribute the ones you
use (all?) with your program.


NOTES
-----
   It is designed to create V.flexible interfaces with the minimum of fuss.
See the features section for more details.


COMMENT
-------
   As with any substantial system of this type, this document's size comes
from its comprehensiveness. You make want to look at the example program's
first (!) to get a rough idea of how things work before reading all of this.
There is also supplied a couple of quick reference files. Once familiar with
Muse, those are all you should need on a regular basis.
@ENDNODE




@NODE "Concepts" "MUSE - Concepts"
@TOC "Muse.guide/Contents"
                           Concepts
                           ========

   As previously mentioned, to use Muse, you just declare the interface
and the processing to be done and let Muse get on with it. This section
describes the concepts as to how this works.


EVENTS
------
   The key concept in Muse is that program's in general sit there waiting
for events to happen. These events are various inputs to the program :
eg key presses, button clicks, menu selections, inter-process ARexx calls.
As far as your program is concerned though, they are just events to react to.


PROCESSES
---------
   The main Muse handler which processes your interface first converts the
inputs it recieves into events which you've defined for them. Eg pressing
the key "k" might be converted to a @{"CLOSE" link CloseEvent} event. This event is then used to
find what procedure you've defined to process that event. This procedure is
then called with certain parameters and information about the event.


PRACTICALITIES
--------------
   This process I is called raising an event handler. ie the process of
converting a menu selection of Close to the action of closing would be said
that the menu selection raises the CLOSE event handler. There are some
@{"standard events" link StandardEvents} : CLOSE, QUIT, MAIN, OTHER, MOUSE. Other events are tied to
inputs which you define. The event itself eg CLOSE, QUIT etc are integers.
All events defined by your program MUST be positive integers greater than
zero. ALL negative events are RESERVED.


VIRTUAL VISIBLE VARIABLES
-------------------------
    UG? Well, this is really a very simple concept. Sounds complicated but
is really a fairly sensible (IMHO) conceptual view of interfaces. As well
as raising events, interfaces provide programs with more information - such
as the value of a slider, the selection from a set of radio buttons, the
current point through a sequence of cycle gadget labels etc.

    In other words, many parts of the interface can in fact hold information
about which the program might wish to know about. They sound dangerously
like variables really don't they?! But we all know that they're not "True"
variables so I've decided that they must be virtual ;-). However in a GUI
they're also visible hence the three V words.
                               (side note: a W3 browser with V3 interface?)

    To this end, each input that can store a value which the main program
might wish to know about is given a name - which is the same idea as giving
normal variables a name. This name takes the form of a string, and can
currently be considered global to the Muse program. (Scoping will be
introduced in V2, possibly in the registered version)

Also currently the only such VV variables are gadgets, and hence to find
the information stored, you cuurently use the following construct:
    @{"get_gadget_info" link get_gadgetinfo}(@{"get_gadgethandle" link get_gadgethandle}( vv_variablename))

Also like normal variables, you can SET the value of a VVV. Again due to
the fact that the only ones are gadgets, you use a similar construct:
    @{"set_gadgetinfo" link set_gadgetinfo}(@{"get_gadgethandle" link get_gadgethandle}(gadget_name, value))

    For an example of programming using these, see the included address book
database program.


As a side note, the VVV system will (probably) grow dramatically in Release 2.

   See the section on @{"Events Elements Definitions" link EventsElements} for more detail on
specific event types.

See Also @{"Standard Events" link StandardEvents} .
@ENDNODE




@NODE VirtualVisibleVariables "MUSE - The Virtual Visible Variables Concept"
@TOC "Muse.guide/Contents"
              Virtual Visible Variables and their use
              =======================================
                    (currently fairly primitive)

 UG? Well, this is really a very simple concept. Sounds complicated
but is really a fairly sensible (IMHO) conceptual view of interfaces. As
well as raising events, interfaces provide programs with more information -
such as the value of a slider, the selection from a set of radio buttons,
the current point through a sequence of cycle gadget labels etc.

  In other words, many parts of the interface can in fact hold information
about which the program might wish to know about. They sound dangerously
like variables really don't they?! But we all know that they're not "True"
variables so I've decided that they must be virtual ;-). However in a GUI
they're also visible hence the three V words.
                              (side note: a W3 browser with V3 interface?)

    To this end, each input that can store a value which the main program
might wish to know about is given a name - which is the same idea as giving
normal variables a name. This name takes the form of a string, and can
currently be considered global to the Muse program. (Scoping will be
introduced in V2, possibly in the registered version)

Also currently the only such VV variables are gadgets, and hence to find
the information stored, you currently use the following construct:
    @{"get_gadget_info" link get_gadgetinfo}(@{"get_gadgethandle" link get_gadgethandle}(gadget_name))

Also like normal variables, you can SET the value of a VVV. Again due to
the fact that the only ones are gadgets, you use a similar construct:
    @{"set_gadgetinfo" link set_gadgetinfo}(@{"get_gadgethandle" link get_gadgethandle}(gadget_name, value))

    For an example of programming using these, see the included address book
database program.


As a side note, the VVV system will (probably) grow dramatically in Release 2.

@ENDNODE



@NODE "ProgramStructure" "MUSE - Program Structure"
@TOC "Muse.guide/Contents"
                        Program Structure
                        =================

  There are a few key elements to the structure of a program using Muse. The
line that includes the module in the program, the section that declares the
interface and the section that procedures that handle the events as they
happen.
                          @{"Module inclusion" link ModuleInclusion}
                       @{"Interface declaration" link InterfaceDeclaration}
                     @{"Event Handling Procedures" link EventHandlingProcedures}
@ENDNODE




@NODE ModuleInclusion "MUSE - Module Inlusion"
@TOC "Muse.guide/Contents"
                          Module inclusion
                          ================

Stick the following line at the start of your program:
   MODULE 'muse/muse'

Yep, just the one. Nice and simple!

@ENDNODE




@NODE InterfaceDeclaration "MUSE - Declaring your interface"
@TOC "Muse.guide/Contents"
                      Interface declaration
                      =====================

SYNTAX
------
For this, include the following line:
    @{"easy_muse" link TheMainFunction}(interface_definition)
or
    @{"muse" link museProc}(interface_definition)
for that matter


COMMENT
-------
OK, interface definition is where the "magic" happens. This is a list of
interface elements definitions. Each of which may or may not be defined in
terms of other interface elements.


SYNTAX OF "interface_definition"
-------------------------------------
As mentioned above, this is a list of interface elements.
Each @{"element" link ElementsSyntax} takes the form:-
            [element-type, element-definition]

ie a list of two parts.


ADVANTAGES, LIMITATIONS & FLEXIBILITY
-------------------------------------
  High level element-types are currently constants, low-level element-types
are strings. (For future flexibility) Some element definitions are simple -
just a string, some are more complex eg gadgets in a window is made up of a
list of individual gadget definitions. The result is a highly flexible
structure.

   All elements in the list can be left out. They are all optional. ie if
there should be a list of elements, [] is fine. An element definition
though must be complete. ie ['QUIT',QUIT] is fine, but ['QUIT'] or [,QUIT]
etc are wrong, as is [] for an element. If you mess up the brackets, and
don't cause a syntax error from the compiler, Muse will tell you you've got
a structural problem.

  For more detail on the individual elements, see @{"Elements Syntax" link ElementsSyntax}.
@ENDNODE




@NODE EventHandlingProcedures "MUSE - Processing the interface"
@TOC "Muse.guide/Contents"
                   Event Handling Procedures
                   =========================

    These are invoked when the user causes an input that raises an
event. You will be pleased (shocked?, worried?, bored?!) that all the
inputs use the same style of processing. Indeed, they are designed to
reduce application code size, as well as the interface code.

They all take the form:
      PROC name(event, evemt_info)
         do_stuff...
      ENDPROC (some have return codes)

"event"      is the event that caused this procedure to be called.
             (an integer value)
"event_info" depends on the input that caused this event to be raised.


DETERMINING THE EVENT TYPE (should you wish)
--------------------------
   You can determine the input type (if need be) by testing the global
variable "event_type" which takes different values depending on the input
type. The values are as follows:
   @{"MUSE_SYSTEM" link StandardEvents}, @{"MUSE_GADGET" link GadgetsElements}, @{"MUSE_MENU" link MenuElements}, @{"MUSE_KEY" link KeysElements},
   @{"MUSE_REXX_FUNC & MUSE_REXX_COMMAND" link ARexxConcepts}.

   For all the types, except MUSE_REXX (both sorts), event_info is currently
a pointer to the window from which the input originated. For MUSE_REXX types,
event_info is determined by the command/function that caused that event to be
raised.

   For information specific to the individual elements and their types,
see @{"Elements Syntax" link ElementsSyntax}.
For information specific to the standard events see: @{"Standard Events" link StandardEvents}.
For an overview of the Events system & Muse in general see @{"Concepts" link Concepts}.
@ENDNODE




@NODE ElementsSyntax "MUSE - The Elements Syntaxes"
@TOC "Muse.guide/Contents"
                           Elements Syntaxes
                           =================
   NOTE!!! In this version (Release V1), the structure you pass Muse MUST
NOT change. IT MUST be STATIC. If it isn't, the results are indeterminate,
and therefore liable to change, an possibly dangerous.

   This section describes the syntax of all the Muse elements that you use
to define the interface that your program uses. It also has sections for
notes on each element.

                    @{"Top Level Elements" link TopLevelElements}

A note on the @{"notation" link NotationUsed} used.
@ENDNODE




@NODE NotationUsed "MUSE - A Note on the Notaion Used to Describe Elements"
@TOC "Muse.guide/Contents"
                           NOTATION
                           ========

In definitions :-

A word/label enclosed in < and > denotes something that is yet to
be defined. (and would be defined below)

If something is denoted as being <a|b|c|d> it means that the part
may be a or b or c or d. Each option is NOT a literal unless explicitly
stated otherwise.

Also a hyper-link from part of an element indicates that that part is 
complex enough to have it's own defintion, and hence the link.

A word/label (enclosed or not) followed by a * denotes that you may have
mutilples of these, with each part seperated by commas.

Bits that are punched into the definitions are desribed in indented text.
      Like this!

Square brackets are literals.

Examples
    "hello* world" is equivalent to "hello, hello, hello, world"
    "[hello* world]" is equivalent to "[hello, hello, hello, world]"
    "[ <Hellodef|Goodbyedef> ]"
where hellodef=hello
      goodbyedef = goodbye
means that the above def is satisfied by the values [hello] or [goodbye].

Clear? Check the examples if you require greater clarity.
@ENDNODE




@NODE TopLevelElements "MUSE - Top Level Elements"
@TOC "Muse.guide/Contents"
                      TOP LEVEL ELEMENTS SYNTAX
                      =========================

MuseDef = [ <WindowDef>,* <RexxDef>, <EventDef>]

WindowDef= [WINDOW, @{"window-elements-list" link WindowElements}]
RexxDef  = [REXX,   @{"rexx-elements-list" link REXXElements}]
EventDef = [EVENTS, @{"event-elements-list" link EventsElements}]

The links take you to the nodes that define those element parts!
If only text was this simple!

@ENDNODE




@NODE EventsElements "MUSE - Event Elements"
@TOC "Muse.guide/Contents"
                      EVENT ELEMENTS SYNTAX
                      =====================
event-elements-list = [ <eventdef>* ]

eventdef = [ userdata , procedure ]
      userdata : is a constant greater than zero that defines the event no
                 that this event raises. The best way of using this is via
                 an enumeration.
                    eg ENUM NONE, OPEN, SAVE, SAVEAS, HELP.
                 Negative events are reserved by the Muse system. The event
                 number zero is completely reserved. It must not be used.
                 It will work differently in different contexts, and is
                 therefore indeterminate in general.

      procedure : this is a pointer to a procedure that is called when the
                  event defined by this element's user_data is raised.
                  ie an input which raises an event with the same no as
                  defined by this element.


      Examples [OPEN, {open_file}]
               [CLOSEFILE, {close_current_file}]

USED WITHIN : @{"Top Level Elements" link TopLevelElements}.
See Also : @{"The Standard Events" link StandardEvents}.
@ENDNODE




@NODE StandardEvents "MUSE - The Muse Standard Events"
@TOC "Muse.guide/Contents"
                    The Muse Standard Events
                    ========================
   These are used in an event element definition on the left hand
side. They are all in practice constants that can be used in your
program. Consider their values private. Anyway, there's no point really
in not using them!

There are several standard events that the system can raise:-
                            @{"STARTUP" link StartUpEvent}
                            @{"CLOSE" link CloseEvent}
                            @{"QUIT" link QuitEvent}
                            @{"MAIN" link MainEvent}
                            @{"OTHER" link OtherEvent}
                            @{"MOUSE" link MouseEvent}

  Yes, I know I said several, there are currentlyonly 5, but this list is
likely to grow rather dramatically!
(in time! - ie later versions)

NOTE: @{"HACKERS LOOK HERE" link HackerWarning} (esp those who just use VALUES in their progs)
@ENDNODE




@NODE HackerWarning "MUSE - Hackers, please don't"
@TOC "Muse.guide/Contents"
                            A PLEA!
                            =======

   This is a project to enable flexible systems to be developed with
ease, to allow people to enhance their lives. 

   When I give a constant as available, please do NOT go WriteF'ing
them and using them. PLEASE only use what I describe - that way I can
ensure future upgradability.(?Doesn't look right) They are also there to
enhance the readability of YOUR programs. This is an integral concept in
Muse. Ignore this at your peril!

   If people do ignore this, and use the values they recieve, I'll be
very tempted to change their values in the next version just for the heck
of it. However, what is more likely is that I just reorder the sequence I
declare them which would change their values. ie if you want your program
to recompile with later versions with no complications, use their NAMES as
shown, not their values. 

You're using E, reference them :-)
@ENDNODE




@NODE StartUpEvent "MUSE - The Start up Event"
@TOC "Muse.guide/Contents"
                             The STARTUP Event
                             =================
EVENT VALUE = STARTUP

   This is automatically raised if Muse is invoked by the easy_muse() command rather than using any other method. (ie not muse()!) It is raised by Muse once your interface has been created, but processing of it has not started. This allows you to do things like say hello to the user. Not fancy, but useful. For an example of usage, please see the Address book program!

@ENDNODE




@NODE CloseEvent "MUSE - The Close Event"
@TOC "Muse.guide/Contents"
                              The CLOSE Event 
                              ===============
EVENT VALUE = CLOSE

   This is automatically raised when the user clicks on the close
gadget of a window. This is not to say that you may not have
other inputs that can raise this, quite the opposite. It is
sensible to have keystrokes and menu options that can allow a
window to be closed.

   When this event is raised, the system looks for your CLOSE
event's procedure. If you have it will be called, and on return,
Muse will either close or not close the window dependent on your
procedure's return value. If it returns CLOSE, then the window
will close, otherwise it should return zero. If you do not supply
a procedure, then Muse will ask the user whether they would like
to close the window or not.

   A way of ensuring all windows always close in response to a
close event without asking the user would be:

   In your events def : [CLOSE, {always}]
   & add the procedure: PROC always() IS CLOSE

@ENDNODE




@NODE QuitEvent "MUSE - The Quit Event"
@TOC "Muse.guide/Contents"
                              The Quit Event
                              ==============
EVENT VALUE = QUIT
    A special one this. You cannot define a quit event handler. (yet) I
am still deciding on what the semantics of just such a handler would
mean/entail. When raised by an input you define (or when the last window
closes), Muse goes into shutdown mode and starts shutting everything down.
It quits easy_muse() and muse_process_events().

NOTE! YOUR PROGRAM MAY NOT ASSUME ANYTHING ABOUT THE INTERFACE ONCE
      THIS EVENT HAS BEEN RAISED (ESP IF YOU'RE USING THE PROCEDURES
      easy_muse() IS MADE UP OF). 
You may not even assume that the interface is valid at this stage!

   The only thing that you may assume if the program leaves @{"easy_muse()" link TheMainFunction} is
that the user is quitting, and that you must perform your shutdown code.

   The only thing that your program may assume if the program leaves
@{"muse_process_events()" link muse_process_events} via a QUIT event, is that you may restart processing
the interface by a second call. 

If an exception has been raised, you may not restart processing.
(Fireworks?)

Note : The @{"Main" link MainEvent} event is not processed with this event.
@ENDNODE




@NODE MainEvent "MUSE - The 'Main' Event"
@TOC "Muse.guide/Contents"
                         The 'Main' Event
                         ================
EVENT VALUE : MAIN
   This is a special event that is quite nice. It is made available
for the reason that lots of programs take the form:-
     REPEAT
        Wait for input
        Do some general MAIN stuff   ***
        Process it in some specific way
     UNTIL Quit

    This event is virtually alway raised for every event (see exceptions
below) that your program can recieve, IF you've defined a procedure to
handle this event. Otherwise, there's no need to worry about it!

   When raised, this event calls a procedure that does '***' event_info
will be the same as the event_info for the normal event handler. Unlike
@{"CLOSE" link CloseEvent}, there is no default procedure.


Exceptions
   This event is not raised when the actual event is a @{"QUIT" link QuitEvent} event, or a
@{"REXX function event" link ARexxConcepts}. (Although it could be 'chained' into action - see
@{"Arexx Elements" link REXXElements} for more details)
@ENDNODE




@NODE OtherEvent "MUSE - The 'Other' Event"
@TOC "Muse.guide/Contents"
                          The 'Other' Event
                          =================
EVENT VALUE : OTHER
   This event is raised if the user presses a key that you haven't
defined a key for.(but have defined actions for some other keys)
Like @{"MAIN" link MainEvent}, @{"CLOSE" link CloseEvent} and @{"MOUSE" link MouseEvent}, it is only raised if a handler procedure
exists for it!

Could be used say in a text editor...

See the section on @{"Keys Elements" link KeysElements} for more information.
@ENDNODE




@NODE MouseEvent "MUSE - The Mouse Event"
@TOC "Muse.guide/Contents"
                       The Mouse Event
                       ===============

EVENT VALUE : MOUSE
   This event is raised if the user clicks the mouse inside a window for which
you have declared MOUSE events to be activated within (see @{"Mouse Element" link MouseElement}). It
may also be raised in ones that have certain types of gadgets in them. You
should therefore always check the window which raised this event.

   @{"event_info" link EventHandlingProcedures} will contain the window's pointer. 
   @{"posx & posy" link MuseVariables} will contain the location of where the mouse was clicked.

You will recieve a MOUSE event for both a click and a release. ie Button down
and up. (But no events for dragging - yet.)

Also, it should be handled by itself in it's own procedure in this version.
@ENDNODE




@NODE WindowElements "MUSE - The Window Elememts"
@TOC "Muse.guide/Contents"
                           WINDOW ELEMENTS
                           ===============

window-elements-list = [<boxdef>, <namedef>, <titledef>,
                        <keysdef>, <gadgetsdef>,
                        <menusdef>, @{"mousedef" link MouseElement}]
boxdef = [BOX, [ x,y, width, height]]
      x,y,width,height are all integers. Define the dimensions of the window.
      Defaults to: [10,10,300,100]

namedef = [NAME, string]
      string is the name you wish to call this window. It is this string
             you pass to get_winhandle().
      Defaults to the title bar's string.

titledef = [TITLE, string]
      string is the text you wish to put in this window's title bar.
      Defaults to TEST.

mousedef = [MOUSE, 1]
      This just tells Muse that you want mouse events switched on in
      this window. The 1 is obligitory. Anything else _may_ work, with this
      version, but is not guaranteed to be in any future version.
  
gadgetsdef = [GADGETS, @{"gadget-list-def" link GadgetsElements}]
menusdef   = [MENUS, @{"menu-list-def" link MenuElements}]
keysdef    = [KEYS, @{"key-list-def" link KeysElements}]

USED WITHIN : @{"Top Level Elements" link TopLevelElements}
@ENDNODE


@NODE KeysElements "MUSE - Keys list  Definition"
@TOC "Muse.guide/Contents"
Key list Definition
===================
key-list-def = [ keydef* ]
keydef = [key, event]
      key   is a character that defines this event.
            Examples "'" "a" 27 $0A "8"
      event is the event number that this event raises.
            eg @{"QUIT" link QuitEvent} OPEN 5 $10

USED WITHIN: @{"Window definitions" link WindowElements} (Key elements def)

Notes : This list defines a list of events to be raised by particular keys.
        If you define 2 or more events for a key then the result is currently.
        undefined.

See Also: The @{"'Other'" link OtherEvent} Event '.
@ENDNODE




@NODE MouseElement "MUSE - Mouse Element Definition"
@TOC "Muse.guide/Contents"
The Mouse Element
=================
mousedef = [MOUSE, 1]
   This just tells Muse that you want mouse events switched on in
   this window. The 1 is obligitory. Anything else _may_ work, with this
   version, but is not guaranteed to be in any future version.

USED WITHIN : @{"Window definitions" link WindowElements} (Key elements def)

Notes: This element declares to Muse that this window will need to be able to
       recieve @{"MOUSE" link Constants} events.

See also: The @{"Mouse Event" link MouseEvent} .
@ENDNODE




@NODE GadgetsElements "MUSE - Gadget Elements"
@TOC "Muse.guide/Contents"
                          GADGET ELEMENTS
                          ===============

gadget-list-def = [ gadgetdef* ]
gadgetdef =  < @{"button" link ButtonElement} | @{"radio" link RadioElement} | @{"scroller" link ScrollerElement} |
               @{"cycle" link CycleElement} | @{"string" link StringGadgetElement} | @{"palette" link PaletteElement} |
               @{"checkbox" link CheckboxElement} | @{"image" link ImageGadgetElement} | @{"stdimage" link StdImageGadgetElement}  >

Please click on a gadget type to find out how to define it!

SEE ALSO : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE ButtonElement "MUSE - Button Gadget Definition"
@TOC "Muse.guide/Contents"
Button Gadget Syntax
====================
buttongadget   = ['BUTTON', <buttondef>]

     buttondef = [event, name, label, x,y,width, height]

      event   is the event that gadget raises.
      name    is the _name_ of that gadget. (ie passable to
              @{"get_gadgethandle()" link get_gadgethandle})
      x,y     define the location top left corner of the gadget relative
              to the top left corner of the window. (in pixels)
      width   defines the width of the gadget in pixels.
      height  defines the height of the gadget in pixels
      label   is the text to place centred INSIDE the gadget.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This type of gadget does not store any information - it sole purpose
       is to enable the user to give the program a graphical command - since
       all it does is raise an event. This type of gadget cannot therefore be a
       virtual visible variable.
See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE RadioElement "MUSE - Radio Gadget Definition"
@TOC "Muse.guide/Contents"
RADIO GADGET SYNTAX
===================
radiogadget    = ['RADIO', <radiodef>]

      radiodef = [event, name, options, x,y, initiallyactive]

      event  is the event that gadget raises.
      name   is the _name_ of that gadget. (ie passable to
             @{"get_gadgethandle()" link get_gadgethandle}}

      x,y    define the location top left corner of the gadget relative
             to the top left corner of the window. (in pixels)

      options = [label* , 0 ]
             Where label is a string denoting a possible selection.
             The labels appear to the RIGHT of the buttons.

      initiallyactive denotes which option is initially selected. It is
             an integer from 0 to number of options-1.
             ie options[initiallyactive] will be the initially selected
             possibility.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE


@NODE CycleElement "MUSE - Cycle Gadget Definition"
@TOC "Muse.guide/Contents"
CYCLE GADGET SYNTAX
===================
cyclegadget    = ['CYCLE', <cycledef>]
      cycledef = [event, name, label, x,y,width, options]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

                 The label appears to the LEFT of the buttons.
          options = [label* , 0 ]
                 Where label is a string denoting a possible selection.
                 The labels appear to the RIGHT of the buttons.
                 The option initially active in this case is the first
                 option in the list.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE


@NODE ScrollerElement "MUSE - Scroller Gadget Definition"
@TOC "Muse.guide/Contents"
SCROLLER GADGET SYNTAX
======================
scrollergadget = ['SCROLLER', <scrollerdef>]
   scrollerdef = [event, name, label, x, y, width, divisions, visible]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         divisions and visible are best described with an example.
         A document might have 500 divisions (lines) but have only 20
         divisions(lines) visible on screen.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is current level of the
       scroller.

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE


@NODE StringGadgetElement "MUSE - String Gadget Definition"
@TOC "Muse.guide/Contents"
STRING GADGET SYNTAX
====================
stringgadget   = ['STRINGGAD', <stringgaddef>]
  stringgaddef = [event, name, label, x,y,width, chars]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         chars is the maximum number of characters this gadget accepts.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is the current contents of
       the string gadget. (ie a string!)

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE PaletteElement "MUSE - Palette Element Definition"!
@TOC "Muse.guide/Contents"
PALETTE GADGET SYNTAX
=====================
palettegadget  = ['PALETTE', <palettedef>]
    palettedef = [event, name, label, x,y,width,height, depth]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears ABOVE the gadget
         depth is the number of bit-planes this palette is designed to edit.
               1=2 divisons. 2=4 divisions. 3=8 divisions. This only makes
               sense if it equals the depth of the screen it's on...

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE CheckboxElement "MUSE - Checkbox Element Definition"
@TOC "Muse.guide/Contents"
CHECKBOX GADGET SYNTAX
======================
checkboxgadget = ['CHECKBOX', <checkboxdef>]
   checkboxdef = [event, name, label, x,y, checked]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         checked = TRUE if you want it initially checked.
                 = FALSE if you don't.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is whether the gadget is
       ticked (checked if you're not UK) or not. If it is, value is TRUE.

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE ImageGadgetElement "MUSE - Image Gadget Syntax"
@TOC "Muse.guide/Contents"
IMAGE GADGET SYNTAX
===================
imagegadget    = ['IMGAE', <imagegaddef>]
   imagegaddef = [event, name, toggle-flag, x,y, pathname]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         toggle-flag=NORMAL means this gadget works like a button gadget
                    =TOGGLE means this gadget works like a checkbox gadget
         pathname is the path to an icon on disk. Best way of doing this is
         for it to be localised via PROGDIR: or a standard directory.
         NOTE: the pathname excludes the .info part.

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query if and only if the image gadget is a "TOGGLEing"
       image gadget. (Spelling is like that to make it more obvious. Comments?)
       The value it stores is whether the item is toggled or not. 
       (TRUE = Toggled!)
       
See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE StdImageGadgetElement "MUSE - Standard Image Gadget Definition"
@TOC "Muse.guide/Contents"
STANDARD IMAGE GADGET SYNTAX
============================
stdimagegadget = ['STD_IMAGE', <stdimagegaddef>]
stdimagegaddef = [event, name, toggle-flag, x,y, stdimagename]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   @{"get_gadgethandle()" link get_gadgethandle}}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         toggle-flag - as for imagegadget
         stdimagename - The name of a gadget icon as it appears on the
         workbench when you open the LIBS:Muse directory. Eg 'OPEN'

USED WITHIN : @{"Gadgets Elements" link GadgetsElements}
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query if and only if the image gadget is a "TOGGLEing"
       image gadget. (Spelling is like that to make it more obvious. Comments?)
       The value it stores is whether the item is toggled or not. 
       (TRUE = Toggled!)

See Also : @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE MenuElements "MUSE - Menu Elements Definitions"
@TOC "Muse.guide/Contents"
MENUS
=====
menu-list-def = [ <menudef>* ]
menu-def = < headeritem   |    baritem | @{"imageitem" link ImageItemElement} |
             @{"stdimageitem" link StdImageItemElement} |    @{"subitem" link SubItemElement} | @{"item" link ItemElement} |
             @{"substdimageitem" link SubStdImageItemElement} | @{"subimageitem" link SubImageItemElement}>

Menu Header    = headeritem
Menu Items     = baritem, item, imageitem, stdimageitem
Menu Sub-items = subitem, subimageitem, substdimageitem.
Text Items     = item, subitem.
Image Items    = imageitem, stdimageitem, subimageitem, substdimageitem.

To find out the syntax, click on the menu elemnt type itself.
The trivial elements are described below.

headeritem = ['HEADER', name]
    name is a string that denotes the name of the menu that is defined by the
          elements that follow. A sub menu item cannot directly follow this.
          Also if the next item is a Header item, you will have a menu with no
          items. Which is generally NOT useful, but is allowed (currently) by
           Muse (and the OS).

baritem    = ['BAR', NIL]
      This puts a item in the menu that acts as a separator between items. It
   can be useful for grouping sets of logical actions within a menu together.
   Note the NIL is OBLIGITORY. No other value can be considered value - even
   if you find it works with other values. This is to ensure future
   upgradability.
@ENDNODE




@NODE ItemElement "MUSE - Menu item definition"
@TOC "Muse.guide/Contents"
MENU ITEM (text label)
======================
item       = ['ITEM', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the label for this menu item.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.
@ENDNODE





@NODE SubItemElement "MUSE - Menu sub-item definition"
@TOC "Muse.guide/Contents"
MENU SUB ITEM (text label)
==========================
subitem    = ['SUBITEM', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the label for this menu item.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.
@ENDNODE




@NODE ImageItemElement "MUSE - Menu items using images"
@TOC "Muse.guide/Contents"
MENU ITEM USING AN IMAGE
========================
imageitem    = ['IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the path to the icon on disk to use as the 
             image. This is must be without the .info part.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the icon you have requested to use the images of,
       Muse will put the name of the icon in the menu instead of the image.
@ENDNODE




@NODE SubImageItemElement "MUSE - Menu sub-items using imgaes"
@TOC "Muse.guide/Contents"
MENU SUB ITEM USING AN IMAGE
============================
subimageitem = ['SUB_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the path to the icon on disk to use as the 
             image. This is must be without the .info part.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the icon you have requested to use the images of,
       Muse will put the name of the icon in the menu instead of the image.
@ENDNODE




@NODE StdImageItemElement "MUSE - Menu items using standard images"
@TOC "Muse.guide/Contents"
MENU ITEM USING A STANDARD IMAGE
================================
stdimageitem    = ['STD_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the name of the standard image as it appears
             in th Libs:MUSE directory if it were to be viewed on the Workbench
             ie without the .info part. EGs 'OPEN' 'CLOSE'
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the standard image you have requested to use the
       images of,  Muse will put the name of the standard image in the menu
       instead of the image.
@ENDNODE



@NODE SubStdImageItemElement "MUSE - Menu sub-items using standard images"
@TOC "Muse.guide/Contents"
MENU SUB ITEM USING A STANDARD IMAGE
====================================
substdimageitem = ['SUB_STD_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the name of the standard image as it appears
             in th Libs:MUSE directory if it were to be viewed on the Workbench
             ie without the .info part. EGs 'OPEN' 'CLOSE'
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the standard image you have requested to use the
       images of,  Muse will put the name of the standard image in the menu
       instead of the image. 
@ENDNODE



@NODE ARexxConcepts "MUSE - ARexx Support"
@TOC "Muse.guide/Contents"
              ARexx Concepts Available in Muse
              ================================

Overview Hosts AREXX supports (not necessarily Muse)
-----------------------------
       There are two types of ARexx HOST that have ports available through
    which they communicate with the outside world. The two types are Command
    Hosts and Function Hosts. 

       Function hosts are (I believe) MUCH harder to implement, but much
   easier to use (from an ARexx programmer's perspective). With them you
   just use their functions/commands names without any more description.
   Their commands may or may not return values directly to the ARexx program.
   They act much like an add on library for ARexx.

       Command hosts are much easier to implement, but a but harder to use
   (from an ARexx programmer's perspective). However, virtually all Arexx
   Hosts on the Amiga are of this type. With these you must directly ADDRESS
   the portname of the Command host in order to use the commands it makes
   available.

      The commands you give it are (normally) enclosed by single quotes and
   cannot directly return a value to an arbitrary variable set by the ARexx
   programmer. There is support for the ability to return values to the
   caller program via the ARexx standard variable 'result'.


What this means for Muse
      Any ARexx interface you define for Muse is a Command Host (like most
   programs) irrelevant of the types of command you make available. For
   implementation reasons, they are classified into two types: commands and
   functions. These are described in detail below, but one returns a value
   whereas the former does not. It is important to note that the Host type
   is a Command Host NOT a function host. Trying to use a Muse ARexx port as
   a function host WILL crash the system. This is something that may or may
   not be patched - but since it isn't a bug, just user mis-use, it *may*
   not.


Port Name
---------
      Like all implementations of ARexx ports, your port has a name. What
   you define is the BASE for which you would like your port to be named
   from. This comes the the Amiga Style Guide since it is a GOOD IDEA

      Suppose you named your port 'Flooble'. If you ran it by itself then
   any program that addressed Flooble would have no problem. BUT suppose
   your user ran it TWICE. The second copy would not be allowed to run since
   the port name Flooble was already in use. Using a Base gets around this
   problem.

      If you request a BASE of 'Flooble' then the first run copy's port will
   be called 'Flooble.1'. The second's 'Flooble.2'. The third - 'Flooble.3'
   and so on up to the 100th copy. (Yes, if you subsequently close a copy,
   and run another copy, the freed name will be reused) There is currently
   an upper limit in 100 names per base. 


Commands & Functions
--------------------
      Commands are just that. The calling ARexx program is just asking your
   program to do something. Commands do not return any values, and are
   therefore inherently easier to implement. Commands can also be considered
   to run concurrently with respect to the CALLER ARexx program.

      Functions are a completely different kettle of fish. As you can see
   they are declared in the same manner as commands, and if implemented in
   an INEFFICIENT manner by YOU the user programmer, then they are relatively
   simple to write. The problem comes from the fact that they are Functions.
   An Arexx command function (as opposed to a command, or a True Arexx
   function) can return a value to the caller's Arexx program via the standard
   AREXX variable result. ALso with Arexx command functions you can define a
   return code. You should ALWAYS return 0 for no error. Any other values
   are at the moment undefined. (honest...)

      The fact that you return values is not really what complicates things.
   The thing that complicates things is the fact that whilst you are processing
   the command function call, the CALLING Arexx program has to wait for you.
   If other programs are waiting for that program, and so on, then you can
   SERIOUSLY degrade the user's machine's performance. You should therefore
   write them to be FAST, and only used if you MUST return a value.

      To this end, a FUNCTION may also request an event to be raised after
   the function's results have been passed back. This is so that you can reply
   to the calling process AS SOON as you know what the return codes will be.

Therefore, the ENDPROC line of a COMMAND is:
    ENDPROC
           the ENDPROC line of a FUNCTION is:
    ENDPROC event, return_code, return_string
     event = event to raise upon reply to caller process
     return_code = as mentioned above. MUST be zero. Anything else is undefined
     return_string = the __string__ you wish to return the caller process.

@<"Click here to back to ARexx Elements" link REXXElements>

@ENDNODE



@NODE REXXElements "MUSE - ARexx Interface Definition Support"
@TOC "Muse.guide/Contents"
                       AREXX ELEMENTS
                       ==============
Before diving straight in and looking at the definitions themselves, it
would probably be worth your while looking at @{"ARexx Concepts In Muse" link ARexxConcepts}.

rexx-elements-list = [ <port-name-def> , <rexx-commands-list> ,
                       <rexx-functions-list> ]
port-name-def = ['NAME', portname-base]
        portname-base is a string defining the BASE name for your porgram's 
                      port.

rexx-commands-list = ['COMMANDS', <command-element-list>]
rexx-functions-list= ['FUNCTIONS', <command-element-list>] 
        If you've read the bit I mentioned above you'll understand why there
        are these two types, if not read it @{"now!" link ARexxConcepts} Other than the conceptual
        difference, there is NO difference in how you define the functions or
        commands. So they use the same format.

command-element-list
--------------------
   This is the bread and butter of your interface. But look how simple it
is to define!

command-element-list = [ <simplecommand>* , <argscommand>* ]
simplecommand = ['SIMPLE', name]
argscommand   = ['ARGS',   name]
    Again the difference between these is run-time usage. They are just there
to help speed up your processing of any arguments passed. These two just
modify the format of the arguments that your procedure recives from the
outside world. Both recieve their value from the rexx_info argument to your
Rexx event-handler ie the second parameter.

    An analogy would be to say the SIMPLE form presents the arguments to your
event-handling proecdure like E's built in variable 'arg' that contains the
command line arguments as a single string. The ARGS form is similar in concept
to the argv/argc style of processing you have in C in that the argument is
limitted formatted to a tokenised array. 

Remembering when raised with 
   event_type=MUSE_REXX_FUNC
or event_type=MUSE_REXX_COMMAND    

That the procedure heading can be interpreted as:
    PROC procedurename(event, rexx_info)

Then in the following example,
 if the command (in the calling ARexx program) is
       'DO this that and the other'

    where 'DO' is a SIMPLE command,
       rexx_info would take the value 'this that and the other'

    where 'DO' is an ARGS command,
       rexx_info would take the value ['this','that','and','the','other']
       This means of course you could, say, ForAll({x},rexx_info,`WriteF(x))
       ListLen(rexx_info) will also obviously tell you the number of arguments.

Note, tokens are defined to be sperated by white space. 
      Since we're dealing with Arexx, multi-line arguments are not in the
      equation. The ONLY characters defined as white space are space itself,
      tabs and commas.
      Also quotes are not considered anything special. SO '"hello, world"' for
      example will tokenise to ['"hello','world"']

   The tokeniser will be DRAMATICALLY revamped for both the Registered Version
1 and Release Version 2.
@ENDNODE



@NODE "ProcedureReference" "Procedure Reference"
@TOC "Muse.guide/Contents"

                       The Muse Procedure Reference
                       ===========================

                            @{"The Main Function" link TheMainFunction}
                            @{"Support Procedures" link SupportProcedures}
                        @{"Window Support Procedures" link WindowSupportProcedures}
                      @{"Environment Support Procedures" link EnvironmentSupport}

The most important ones to look are the first, third and fourth on this list.
@ENDNODE




@NODE TheMainFunction "MUSE - The Simplicity of Muse"
@TOC "Muse.guide/Contents"
                              The Main Function
                              ~~~~~~~~~~~~~~~~~
Procedure:  easy_muse(def)
Parameters: def
Result    : A Living breathing program who's interface was easy to write.
Bugs      : None known.

   def is a fully qualified @{"Muse Interface Definition structure" link InterfaceDeclaration}
   It is (briefly) a list of Muse @{"elements" link TopLevelElements}, where each element that
   is in itself not a list of Muse elements is a base definition of
   some part of the interface. Each element that is a list of Muse
   elements defines a logically coherant grouping. (eg @{"GADGETS" link GadgetsElements}!)

   easy_muse() takes this definition, allocates the defined interface,
   opens it, and processes it, calling your program as need be. If your
   program quits, dies, or otherwise finishes (GURU excepted), easy_muse()
   quietly, promptly, and succinctly shuts everything down, and deallocates
   it.

   Worth noting: If for any reason Muse cannot open the interface,
   easy_muse() will let you, or your user know why and where.
      EG Window too large!                (and _which_ window)
         Can't find icon to create image! (and where it should be!)

   Doesn't do much else. Doesn't sound as if it should be as long as it
   is, but there we go... Makes it look easy doesn't it!
   (Took long enough)

SEE: @{"Support Procedures" link SupportProcedures}, @{"Window Support Procedures" link WindowSupportProcedures},
     @{"Environment Support Procedures" link EnvironmentSupport}, @{"Elements Syntax" link ElementsSyntax},
     @{"Concepts" link Concepts}, @{"ARexx Concepts" link ARexxConcepts}
@ENDNODE





@NODE SupportProcedures "MUSE - Three procedures that Muse possible"
@TOC "Muse.guide/Contents"
                          Support Procedures
                          ~~~~~~~~~~~~~~~~~~

   These three do the hard work for easy_muse() See the individual defs
   of each to see what. The reason for having them available is so that,
   if you wished, you could put code in between them if you wished.
   EG to draw a piccy in the window between the call to muse() and the call
   to muse_process_events() , or if you wanted to make sure the user was
   really, really sure they really, definately wanted to certainly quit
   between muse_process_events() and end_muse()

                 @{"muse(def)" link museProc}
                 @{"muse_process_events()" link muse_process_events}
                 @{"end_muse()" link end_muse}


SEE: @{"easy_muse()" link TheMainFunction}, @{"Window Support Procedures" link WindowSupportProcedures} , @{"Environment Support Procedures" link EnvironmentSupport},
     @{"Defining your interface." link InterfaceDeclaration} (ie the 'def' above!)
@ENDNODE




@NODE museProc "MUSE - The Creator Cometh (Seven easy steps)"
@TOC "Muse.guide/Contents"
Procedure : muse(@{"muse_def" link InterfaceDeclaration})
Parameters: muse_def
Result    : A tidily allocated, visible interface that's awkward to do
            otherwise!
Bugs      : None known.

   muse_def is a fully qualified @{"Muse Interface Definition" link InterfaceDeclaration} structure.

   This results in a living, breathing, beautiful(?) interface, ready for
   the world, and all it can throw at it.

   ie  muse_process_events() can now process it!

SEE: @{"easy_muse()" link TheMainFunction}, @{"muse_process_events()" link muse_process_events}, @{"end_muse()" link end_muse},
     @{"Support Procedures" link SupportProcedures}
@ENDNODE




@NODE muse_process_events "MUSE - The Main work horse."
@TOC "Muse.guide/Contents"
Procedure : muse_process_events()
Parameters: none
Result    : Your program is run!
Bugs      : None known.

   This procedure assumes and is allowed to assume that you have an
   interface open ready to be processed. This interface must have been
   created using the Muse procedures available.

   It waits for input from the user. Translates that input into an event
   you've defined, and then calls the procedure you've written to handle
   that event.

   Doesn't do much else. (doesn't sound as if it should be as long as it
   is, but there we go... Makes it look easy doesn't it!)

SEE: @{"easy_muse()" link TheMainFunction}, @{"muse()" link museProc}, @{"end_muse()" link end_muse},
     @{"Support Procedures" link SupportProcedures}
@ENDNODE




@NODE end_muse "MUSE - and he taketh away..."
@TOC "Muse.guide/Contents"
Procedure : end_muse()
Parameters: none
Result    : It all disappears and goes away!
Bugs      : None known.

   Assumes you had a Muse interface open to start with.
   Closes it. That's it. Finito. (well, it also deallocates it! Nicely)


SEE: @{"easy_muse()" link TheMainFunction}, @{"muse()" link museProc}, @{"muse_process_events()" link muse_process_events},
     @{"Support Procedures" link SupportProcedures}
@ENDNODE




@NODE WindowSupportProcedures "MUSE - Window Support Procedure"
@TOC "Muse.guide/Contents"
                     Window Support Procedures
                     ~~~~~~~~~~~~~~~~~~~~~~~~~
   These procedures are there to enable you to selectively open and close
   windows to enable you to have finer control on the use of your program.
   This is especially the case with request().

                          @{"openwin(def)" link openwin}
                          @{"closewin(w)" link closewin}
                          @{"request()" link request}

SEE ALSO: @{"set_stdwin()" link set_stdwin}, @{"get_winhandle()" link get_winhandle}, @{"get_winname()" link get_winname}.
@ENDNODE


@NODE openwin "MUSE - How to open extra windows after muse() or easy_muse()"
@TOC "Muse.guide/Contents"
Procedure : openwin(@{"def" link WindowElements})
Parameters: def
Result    : A window with clickable's and stuff...
Bugs      : None known.

   This procedure takes a window definition element, and creates a winodw
   with it, muse_process_events() and easy_muse() will both recognise it.
   eg
      mywindow:=[
                  [TITLE, 'Easy Paint : Draw Window'],
                  [BOX, [50,80,550,170]],
                  [MOUSE,1]
                ]
      openwin(mywindow)
   This results in a window that can be used say as a paint program's
   window. Not bad huh?

SEE ALSO : @{"closewin(w)" link closewin}
@ENDNODE




@NODE closewin "MUSE - How to Muse-legally close a window Muse opened."
@TOC "Muse.guide/Contents"
Procedure : closewin(w)
Parameters: w:PTR TO window
Result    : Closes the window pointed to by w.
Bugs      : None known.

   w is a pointer to a window. eg stdwin

   This is the only way to legally close any window created by Muse for
   you, if you try doing it any other way, you are liable to crash the
   system. (At best, only sometimes)

SEE: @{"get_winhandle()" link get_winhandle}, @{"get_winname()" link get_winname}, @{"set_stdwin()" link set_stdwin}, @{"openwin(def)" link openwin}
@ENDNODE




@NODE request "MUSE - The first of many standard requesters to come"
@TOC "Muse.guide/Contents"
Procedure : request(text,buttons,arguments)
Parameters: text (optional), buttons (optional), arguments (optional)
Result    : Returns a value indicating which button was pressed.
Bugs      : None known.

   Useful one this. Creates a requester for the user to act upon. Used by you
   the programmer to force the user to make a choice before proceeding.

NB. All options default to either NIL,or something sensible.


   text is a string to be displayed in the requester's body. It can include
        standard E formatting codes, including those for arguments.

   buttons is a string defining the buttons in the requester.  It has the
      following format:-
         option (+ '|' option)
      where the bit in brackets is repeated as many times as you wish
      eg:      'OK'
               'OK|CANCEL'
               'Way!|Definately|Probably|Possibly|Maybe|NoWay!'
      Each button is numbered from 1 to number of options-1 from left to
      right excepting of course the right most one (the Cancel position)
      which has the value 0.
      It is this value that request returns upon exit.

   arguments is a list of arguments to fill the spaces left for them in the
             text section.

   Examples:
      request('Are you absolutely positive that you want to delete\n'+
              'File: \s size\d\nI mean *really* sure?',
              'Yes, Of course|May be|Ooops!',
              [filename,size])
      request('Hi There!')
      request('Quit?','Yes|no')
      request('Howdy!','Howdy to you too')

   Example Deluxe...
      name:= 'Insert your name here!'
      messages:=['Bye Bye\s',
                 'Good \s, You're staying',
                 '\s - you are boring!']
      request(messages[request('What Now?',
                               'Stay here|Use a PC|Go Home!')],
              'Yep',[name])

SEE: @{"Window Support Procedures" link WindowSupportProcedures}, @{"Support Procedures" link SupportProcedures}
@ENDNODE





@NODE EnvironmentSupport "MUSE - Environment support"
@TOC "Muse.guide/Contents"
                   Environment Support Procedures
                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   These procedures allow you to find out where things are, what they're
   called, what their values are, and even change them!

                      @{"rx_port()" link rx_port}

                      @{"get_winhandle()" link get_winhandle}
                      @{"get_winname()" link get_winname}
                      @{"get_gadgethandle()" link get_gadgethandle}
                      @{"get_gadgetname()" link get_gadgetname}

                      @{"get_gadget_info()" link get_gadgetinfo}
                      @{"set_gadgetinfo()" link set_gadgetinfo}

                      @{"set_stdwin()" link set_stdwin}
@ENDNODE


@NODE rx_port "MUSE - Querying your ARexx port's name"
@TOC "Muse.guide/Contents"
Procedure : rx_port()
Parameters: none
Result    : The name of your program's rexx port.
Bugs      : None known.

   This procedure simply returns a string with the actual name of your
   program's Arexx Port. The reason for the need for this function is
   simple : What happens if your program is run a second time concurrent
   to the first?
      Well, suppose you requested a port name of 'MyProg'.
      The first program's Rexx port name would be 'MyProg.1'
      The second's would be 'MyProg.2'
      The third's : 'MyProg.3'
   And so on up to the 100'th copy. This is currently the upper limit.

   This is a limit imposed by me, not by th OS (I think). The reason is
   twofold: it simplifies things somewhat, and also I can't see why anyone
   would want to run 100 copies of the same program at the same time. (Not
   on a micro anyway)

See Also : @{"Arexx Concepts" link ARexxConcepts}
@ENDNODE




@NODE get_winhandle "MUSE - How to get the window handle from it's name"
@TOC "Muse.guide/Contents"
Procedure : get_winhandle(name)
Parameters: name
Result    : A pointer to the window you've asked for.
Bugs      : None known.

   name is a string defining the name of a window you have opened using
        either easy_muse() or muse() or openwin()

   This procedure returns a window pointer pointing to the window you've
   asked for. This is *not* done in a time critical manner, so if you
   intend to use that window often (ie switch between using different
   windows a lot), you would be well advised to take a copy of the pointer 
   for yourself.

   This is the opposite of get_winname()

SEE: @{"set_stdwin()" link set_stdwin}, @{"get_winname()" link get_winname}, @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE





@NODE get_winname "MUSE - Getting the name of a window from it's pointer"
@TOC "Muse.guide/Contents"
Procedure : get_winname(handle)
Parameters: handle
Result    : The name of the window pointed to by handle.
Bugs      : None known.

   handle is a window handle for a window you have opened using either
          easy_muse() or muse() or openwin()

   This procedure returns the name of the window pointed to by the window
   handle you have passed it. This is *not* done in a time critical manner.
   So if you need to know it's name on a regular basis you would be well
   advised to keep a note of it in your program!

   This is the opposite of get_winnhandle()

SEE: @{"set_stdwin()" link set_stdwin}, @{"get_winhandle()" link get_winhandle}, @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE get_gadgethandle "MUSE - Getting the pointer to a gadget from it's name"
@TOC "Muse.guide/Contents"
Procedure : get_gadgethandle(name)
Parameters: name
Result    : A pointer to the gadget you've asked for.
Bugs      : None known.

   name is a string defining the name of a gadget you have created using
        either easy_muse() or muse() or openwin()

   This procedure returns a pointer to the gadget you've asked for. This
   is  *not* done in a time critical manner, so if you intend to use that
   gadget's value a lot, you would be well advised to take a copy of the
   pointer for yourself!

   This is the opposite of get_gadgetname()

SEE: @{"get_gadgetinfo()" link get_gadgetinfo}, @{"get_gadgetname()" link get_gadgetname}, @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE



@NODE get_gadgetname "MUSE - Getting the name of a gadget from it's pointer"
@TOC "Muse.guide/Contents"
Procedure : get_gadgetname(handle)
Parameters: handle
Result    : A string containing the name of the gadget to asked for!
Bugs      : None known.

   handle is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   This procedure returns the name of the gadget pointed to by the gadget
   handle you have passed it. This is *not* done in a time critical manner.
   So if you need it on a regular basis you would be well advised to keep
   a note of it in your program!

   This is the opposite of get_gadgethandle()

SEE: @{"get_gadgetinfo()" link get_gadgetinfo}, @{"get_gadgethandle()" link get_gadgethandle}, @{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE




@NODE get_gadgetinfo "MUSE - How to query the VALUE of a gadget"
@TOC "Muse.guide/Contents"
Procedure : get_gadget_info(gad)
Parameters: gad
Result    : The information stored inside that gadget!
Bugs      : None known

   gad is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   What this returns is a bit spesh! If the gadget stores a value, it returns
   that value. If it makes a selection from a set of options it returns that
   option's number.

   This function alone would be *much* more awkward to code if it weren't
   for E. (and I do mean MUCH more awkward)

SEE: @{"get_gadgetname()" link get_gadgetname}, @{"get_gadgethandle()" link get_gadgethandle}, @{"GadgetsDefinitions" link GadgetsElements},
     @{"set_gadgetinfo()" link set_gadgetinfo},@{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE


@NODE set_gadgetinfo "MUSE - How to CHANGE the value of a gadget"
@TOC "Muse.guide/Contents"
Procedure : set_gadgetinfo(gad, value)
Parameters: gad, value
Result    : The information stored inside that gadget!
Bugs      : None known

   gad is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   This procedure is quite nice. It does (unsuprisingly) the opposite of
   get_gadget_info()! ie It acts as an assignment statement. The gadget
   (currently) must be accessed via it's pointer rather than it's name,
   but that's so that if you use any of the VVV's on a very regular basis,
   you'll probably want to keep a copy of the variable anyway

   The values you can set for each gadget type are described along with
   that gadget. But put simply, if the gadget makes a selection from a set
   of options, value takes that selection's number. If gadget takes input
   for a string, then value is a (pointer to a) string. If the gadget stores
   is a colour, then value is the colour number. And so on. Nice and SIMPLE!


SEE: @{"get_gadgetname()" link get_gadgetname}, @{"get_gadgethandle()" link get_gadgethandle}, @{"GadgetsDefinitions" link GadgetsElements},
     @{"get_gadget_info()" link get_gadgetinfo},@{"Virtual Visible Variables" link VirtualVisibleVariables}
@ENDNODE


@NODE set_stdwin "MUSE - How to change the current window"
@TOC "Muse.guide/Contents"
Procedure : set_stdwin(handle,name,activate)
Parameters: handle(optional), name(optional), activate(optional)
Result    : Sets the current window to the window denoted by handle or name
            Activates it as well if required
Bugs      : None known.

   handle is a window handle for a window you have opened using either
          easy_muse() or muse() or openwin(). Default=NIL

   name is a string defining the name of a window you have opened using
        either easy_muse() or muse() or openwin(). Default=NIL

   activate is a Boolean defining whether to activate the window as well
            or not. Default is FALSE. (Don't activate)

   What this procedure does is:
      Sets @{"stdwin" link MuseVariables} to the window pointed to by either handle or name.
           (if you pass neither, it doesn't change stdwin, if you pass both,
            the result will be consistant, undefined!)
      It then checks to see if you wanted to activate it.
      If you did, it does so.

   Also worth noting, stdrast (E's built-in variable) is also kept in step
   with this command!

SEE: @{"MuseVariables" link MuseVariables}, @{"Window Support Procedures" link WindowSupportProcedures}
@ENDNODE





@NODE MuseVariables "MuseVariables"
@TOC "Muse.guide/Contents"
                 Variables Muse Makes Available
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   The variables that Muse makes available for your ponderance upon are:
      event_type, stdwin, posx,posy, lastgadget, muse_error, muse_info

   These variables are ALL read only! (stdwin can be modified using the
   given function only)

NOTE: Although there are some more exported, you may not modify them
      Those (undefined here) are PRIVATE! Use at your peril!

event_type
   This variable lets you know what type of input caused your EventHandler
   to be called. It contains a constant.
   SEE: @{"Constants" link Constants}

stdwin : PTR TO window
   The current window. If you use Muse's procedures to keep this current,
   then stdrast will be attached to this window. (standard window struct)
   SEE: @{"set_stdwin()" link set_stdwin}

posx, posy
   The location where the mouse was last clicked. Only set if you have a
   MOUSE event handler, and the window that was clicked in has had a MOUSE
   declaration.
   SEE: @{"Constants" link Constants}

last_gadget
   Contains the handle (not the name) of the last gadget to be clicked
   on. If one hasn't been clicked on, the value of this is undefined.
   SEE: @{"get_gadgethandle()" link get_gadgethandle}, @{"get_gadgetname()" link get_gadgetname}, @{"get_gadget_info()" link get_gadgetinfo}

muse_error
   Constant defining what just went wrong!
   Currently, although defined, sometimes vaguely, although this is a
   public variable, I am keeping it's values private. The reason is I
   want to make sure this is good before I set it in concrete.

muse_info
   A string _explaining_ what went wrong!
   In general though, if you use @{"easy_muse()" link TheMainFunction} your program will tell you
   what went wrong with as many refernces as it can manage.
@ENDNODE




@NODE Constants "MUSE - The Constants you can use"
@TOC "Muse.guide/Contents"
                 Constants Available for use in Muse
                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following are the constants available for use in Muse. Although there
are also some other ones exported, they are PRIVATE. VIP's eyes ONLY!
(ie if you use them - it's at your peril)

@{"EVENTS, WINDOW, REXX" link TopLevelElements}
   Used for top level Muse elements.

@{"TITLE, NAME, BOX," link WindowElements}
   The bits that define general bits about your window!

@{"MENUS, GADGETS, KEYS, MOUSE" link WindowElements}
   The bits that define the inputs to your window!

@{"TOGGLE, NORMAL" link ImageGadgetElement}
   Used with image gadgets

@{"CLOSE, QUIT, OTHER, MAIN, MOUSE" link StandardEvents}
   The Muse standard events.

@{"MUSE_KEY, MUSE_GADGET, MUSE_MENU, MUSE_REXX_FUNC, MUSE_NONE," link EventHandlingProcedures}
@{"MUSE_REXX_COMMAND, MUSE_SYSTEM" link EventHandlingProcedures}
   The various sources of input...
   Note mouse is (currently) intentionally left out... (in that there isn't
   a MUSE_MOUSE note. It should (currently) be handled by itself.
@ENDNODE


@NODE History "MUSE - A Brief History of how Muse came into being etc"
@TOC "Muse.guide/Contents"
                                 History
                                 ~~~~~~~
Feb 96 Release Version 1 uploaded to Aminmet. Announced on Newsgroups.
       Web site as a source of information to do with Muse set up.


   Muse did not start out with the aim of being what it has become. It
started out with me wanting a simple way of programming 2.0 style gadgets.
This was around  Nov 94. Due to my having a full-time retail management job
at the time, work progressed slowly, often with nothing being done on it
for weeks at a time.

   It was at this stage I started using lists to define gadget structures
rather than procedure parameters, mainly because I was trying to think
ahead to a time when I would be able to sequence through a list perhaps, or
maybe create a run-time editor. Events were nowhere to be seen, and it
wasn't anything like a module at that stage. 

   Then I got hold of Amiga E Version 3. The power thus dispensed, I decided
to get a hard drive and register. This dramatically changed the turn-around
time on testing, debugging, and prototyping. One Late Jan95 day, I was
watching an episode of Babylon 5 and I was thinking to myself, (I know, sad)
that their computer systems would have to be incredibly complex (and
reliable) in order to deal with all the troubles that could happen in that
environment. This made me think.

  The use of those systems appeared to be incredibly simple: re-configuring
an entire sensor net took only a short while, adding in new systems was as
easy as pie, writing programs must therefore be as easy to do in that time.
After all 3 centuries of CASE tool development must produce some nifty tools.

   My idea started there. I thought to myself, the list structures used by
easygads (as it was then) were quite flexible, but not as flexible as they
could be. I decided to write a program to take a list structure, and open a
window using that. Once that was done, I wrote a little procedure to take a
list of V.simple gadget definition lists, which produced a pointer to a
list of gadgets ready to be linked into a window. The gadgets were the
simple Gadget() (E's built in function) type. But this was just prototyping.

   Next I decided to nest that procedure within then window procedure. It
was then that I realised that this could be extended into making lists of
windows. Also at the time I was wading through the RKRMs looking at tag's,
but I realised early on that E's unification command was the best was way
of utilising something slightly different. I realised that there was the
possibility that you could use a very simple structure to define things of
the form:
   [tag, bla]
But in E this was a list, not a tag-list. Hence Muse uses lists, not tag-lists.

2nd Feb 95. This was when Muse in a recognisable form was conceived. I
decided how would I like to define a program programs interface in such a
way that it would be easy to process. I considered the idea that each input
would have a procedure attached to it.

   Conceptually it's good, but it ignores the fact that different input
techniques effectively as far as the program is concerned is just different
ways of getting essentially the same info. After all a menu selection Close
is the same as a close gadget click, the same as a right-amiga k, the same
as a control \, the same as (say) pressing q.

   To write a procedure for every one of those inputs struck me as pointless.
After all the event that is happening is that the window should close.
Thats's when I struck of the idea of input->event->procedure call. Where
the first conversion is from a 'physical' input to a logical event, and the
second being a look up as it were of what we do in that situation. This
reduced redundancy. Which invcreases both readability, efficiency, decreases
program complexity, and these factors combined with the fact you are no
longer worrying about the interface and how to process increases the
likelyhood of program correctness. (ie less bugs!?)

   It also struck me that the list structure available in E is very similar
to the sequence structure in VDM, and if I completely specified the
interface using this, and specified what happened when this structure was
processed that VDM would finally have a precise, REUSABLE, technique for
specifying the interface a program has with respect to the outside world
without enforcing the appearance of that interface. (There's no reason if
Muse existed on other platforms that you couldn't take virtually the same
code recompile it and use it.) Certainly the EER diagram you can draw (as in
Fund. DB Sys. Elmasri & Navathe) for Muse is to say the least elegant.

   It was at this point I decided to go for it. What followed next, is as
they say history. Over the following months, I created manipulators to work
on the structures Muse used. It had several name changes. The first was
SimpleGUI, a few months later after I added in ARexx support, it briefly
became SimpleUI. It was at this stage nick-named 'A YACC for WIMPs', since
YACC (as I understand it) dow the same for a text environment.

   These acronyms began to hack me off after a while, so I decided to call
it something sensible so I looked through some of my books on Greek
mythology, and came up with Muse. (Because they inspired people, as Muse
was inspiring me to add in new features every time I added in the one I had
just thought of) I decided to add in ARexx when I decided that Muse was of a
high enough potential to release given a few more months work.

   So what you have is one programmer's labour of love. A desire to see
programs easy to write, efficient ands reliable. This has gone through all
the way, hence if say, you give Muse a string rather than a list, it will
spit it back at you. This system is not complete. This version is. But
there is the registered version to come. And after that version 2. (Which I
think will raise quite a few eyebrows)

   This version is fairly bullet-proof. I am in the process of formally
speciying Muse to help keep later versions that way. One reason it is fairl
bullet proof is due to OO style techniques, where approriate and dynamic
run-time coding as well to increase readability, flexibility and reliability.
@ENDNODE





@NODE Author "MUSE - Well its talk about yourself time!"
@TOC "Muse.guide/Contents"
                            About The Author
                            ~~~~~~~~~~~~~~~~
This is me:
   Michael Sparks, 22 years old,
   40 James Street, Cambridge.
   Tel (01223) 563995   (or +44 1223 563995)
   email: mps102@bridge.anglia.ac.uk
   Home page: http://www.anglia.ac.uk/~mps102/index.html

My Machine:
   A600, 2Mb RAM, 170Mb HD, Canon B10sx Printer.
   (Not a bad little 7Mhz system really!)

Software:
   Ed 2.00 (!!) AmigaE3.2 REGISTERED.

(tip for using Ed (yes as in 'in the c: directory') - try deleting the
 ed-startup file. Ed is much better than you think. Its got hidden secrets)

   All money donated will go towards further Muse production (which will go
on even if no-one sends any money). ie me getting an A1200 or such like!
Electricity bills, coffee, drink, etc...

   The crux algorithms and structures that Muse relies on came from not
thinking about it for the best part of 6 Months. (The six months prior
to Feb95) The resultant structure is MUCH more powerful than it appears.
But you'll have to wait for either V2 or Registered to see why...
@ENDNODE




@NODE Credits "MUSE - The Credits!"
@TOC "Muse.guide/Contents"
                                Credits
                                ~~~~~~~

   Although not able to give any help in either a coding way or testing way,
the following people were instrumental in my continuance of development:

      Wouter van Oortmersson - Registered E is well worth it. E is his idea
                     of an ideal programming language. Mine too. Muse would
                     not be possible without it. Well, this is my first
                     version of Muse. This is my idea of an interface
                     processing system.

      David Sparks - My brother - His assistance in conceptually help
                     develop Muse was more helpful than I think he'll ever
                     realise. Especially the practice I got in explaining
                     the event mechanism, and the reason for the mechanism.
                     ALso for insights into various other areas into which
                     Muse could move into.

      Anthony Brown - For very similar reasons. (And also for downloading E
                      Version 3 for me - getting that made me register).


People who helped with the documentation:
      Jason Hulance - For Ag2txt - used to generate the plain text version of 
                  this document.

      Christian Scholz - For Guide2Html - used to generate the first generation
                  of the web-pages to be used on the Muse web site. And also
                  for the substantial disclaimer, modified and enhanced for
                   Muse.

General Credit goes to:
      Escom     - For buying Amiga!
      CU Amiga  - For providing such decent coverdisks and magazines over
                  the years, The printed manual that I have produced is
                  entirely done using Pagestream2.2UK as supplied on the
                  coverdisk supplied with one of their magazines. I was
                  totally gobsmacked when I saw that they had included the
                  registered version of E this month. I urge them if they
                  read this to contact me about inclusion on their disks!
      MUI - for being so pretty, but totally unusable on my machine due
            to it's high memory overheads, and sluggishness!-)
            (ie putting me off it!  :-) I do NOT MEAN TO BASH MUI BECAUSE
            MUI SEEMS TO HAVE VERY SIMILAR AIMS, AND I COMMEND IT.
            (It just doesn't work too well on a 7Mhz 2Mb machine.;-)
            After all, Muse could be used as an overlay onto MUI at a later
            point, if approriate/possible...
@ENDNODE




@NODE Registration "MUSE - Registration. Or how not to!"
@TOC "Muse.guide/Contents"
                              Cost!
                              ~~~~~
   Registration - what a horrible word.

   Well, this is always the uncomfortable bit. What does it cost me? Well,
2000 lines of code such as Muse is, with it's high complexity of what it
does for you, what do YOU reckon it's worth.

   One way of evaluating it would be to use Intermediate @{"COCOMO" link CocomoOfMuse} (which gives
a cost estimation based on program length and functions it handles).
(click on COCOMO above for the evaluation) The resulting cost is:

Total cost = £15500

   This is a valid, recognised project cost evaluation model. A fair asking
price for this product if it were to be sold to and used by one user would
the price above. (honest, read a book on it. eg Software Engineering
Economics By Barry Boehm. Publ. Prentic Hall)


What am I asking?
=================
                                                +---------+
This version you have, the Release Version 1 is | F R E E |
                                                +---------+
It costs you nothing. You are free to copy it as you choose.
(see the licence aggreement for more details, and disclaimers)

                +-----------------------------------+
                | All I ask is this if you use it,  |
                |    LET ME KNOW WHAT YOU THINK!    |
                |          @{"contact point" link Author}            |
                |(Politely, after all this is free.)|
                +-----------------------------------+


   There will also be available a
                +-----------------------------------+
                | Printed & Bound  Reference Manual |
                +-----------------------------------+
    at the end of April '96.
    which goes into much greater detail about everything to do with Muse,
    and is well worth the money.

   Cost?
      UK : £5 (inc P&P)
      Everywhere else : £15. (or $20)

  There will be available mid '96 the registered version. A piece of paper
with your name and address on, with postage will ensure you finding out
when it is due for release, and perhaps a flyer saying what features it has.
The registered version will cost £10. The printed manual for it will cost
the same as above. (unless you have already bought one, in which case you
will get a reduction!)

  Those who @{"send me detailed bug reports" link Author}, with source code,
a directory listing of your development system, and if I can reproduce the bug
will recieve a FREE copy of the registered version. Registered users, esp those
who register before it's available, will get free notification on new
releases.

  Basically you can use Muse, without reservations or guilt. If you send me
@{"money" link Author}, you get stuff! Also I am happy to answer any Muse
related questions. I'll obviously lend a (more) sympathetic ear if you've
registered!

   All money donated will go towards further Muse production (which will go
on even if no-one sends any money). ie me getting an A1200 or such like!
Electricity bills etc. Coffee, drink, nights out...

See Also : @{"Author" link Author}
@ENDNODE




@NODE CocomoOfMuse "MUSE - Lets Be silly for a moment!"
@TOC "Muse.guide/Contents"
                COCOMO Evaluation of Muse ;-)
                =========================

Assume a full-time programmer costs 12,000 p.a. (1000 p.m)
The mode would be embedded mode:-
   General objectives, moderate experience with tools, absoulte need
   to conform to requirements, absoulte need to conform to external
   interface requirements, considerable need for new algorithm and 
   structure development.

Nominal Man-months(ft) = 2.8 * 2^1.2
                       = 6.4MM
RELY = 1.4, DATA = 1.0, CPLX = 1.30, TIME = 1.66, STOR = 1.56,
VIRT = .87, TURN = .87, ACAP = 1.0,  AEXP = 1.13, PCAP = .7
VEXP = 1.1, LEXP = 1.0, MODP = .82, TOOL = .83, SCED = 1.0

Adjusted MM= 6.4 * 1.4 * 1.3 * 1.66 * 1.56 * .87 * .87 * 1.13 * .7 *
             1.1 * .82 * .83
           = 13.5 MM

Schedule = 2.5 * (MM)^.32 = 2.5 * (13.5)^.32 = 5.7 Months

No Of people Required = MM/schedule = 2.3 people.
                                     (eg 2 people + 1 part-timer)

Breakdown of required personel through project:
                   Effort     Sched    Av. Pers. Pay Months Req Pers. Cost
Plans and req's       .81MM    1.37M      .59     1.5        1       £1500
Product Design       2.43MM    1.71M      1.42    1.75       1.5     £2625
Programming          8.1MM     2.73M      2.96    2.75       3.0     £8250
Integration & test   2.97MM    1.25M      2.37    1.25       2.5     £3125
(.5 person = 1 part-timer)

Total cost = £15500

   This is a valid, recognised project cost evaluation model. A fair asking
price for this product if it were to be sold to and used by one user would
the price above. (honest, read a book on it. eg Software Engineering
Economics By Barry Boehm. Publ. Prentic Hall)
@ENDNODE

@NODE FunctionsRef "MUSE - Functions Quick Reference"
@TOC "Muse.guide/Contents"
                             Muse Functions

                             Quick Refernce


closewin(w:PTR TO window)
Closes the window (opened by muse)

easy_muse(muse_def)
Creates a living breathing program!

end_muse()
Closes interface down! (not to be used with easy_muse())

get_gadgethandle(name:STRING)
Returns the gadget pointer named.

get_gadgetname(w:PTR TO window)
Returns the name of the gadget pointed to.

get_gadget_info(g:PTR TO gadget)
Returns any info stored by gadget.

get_windhandle(name:STRING)
Returns the window handle named.

get_winname(w:PTR TO window)
Returns the name of window pointed to.

muse(muse_def)
Opens an interface for processing with muse_process_events()

muse_process_events()
Processes an interface opened using muse()

openwin(def)
Used to open a Muse window. (Called *after* muse() or easy_muse())

request(text,buttons,arguments)
Opens, processes and returns the result of a requester.

rx_port()
Returns the name of your program's Arexx port.

set_gadgetinfo(g:PTR TO gadget, value)
Assigns the value given to the gadget pointed to. It is up to you to
ensure that the type of value you provide the gadget is correct!

set_stdwin(w:PTR TO window,name:STRING,activate:BOOL)
Sets the current window, and optionally activates it.
@ENDNODE
