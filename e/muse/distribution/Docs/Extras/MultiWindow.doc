
                               MultiWindows.m Module
                               =====================

                               © 1996 Michael Sparks

Multiple windows object!
   OBJECT
      mwin() -> constructor
      end()  -> destructor called by END
      stdwinport() ->returns the stdwinport
      win(x,y,width,height,idcmp,wflags,title,screen,sflags,gadgets,
          taglist=NIL) -> opens a window
      removewin(w pointer) -> closes a specific window
      closewindows() -> closes all the windows
   ENDOBJECT

     Unlike the multiple windows module supplied with the compiler, this module uses
the technique as specified in the RKRMs of doing it, and therefore uses only one
port/signal to do it! And it works reliably.

     The window structures are normal ones, and have no funny business happen to them,
but I would NOT go changing any fields in the structure if you want to live! If you
want to associate something with a window created using this, I would use a manipulator
of the style:
   [
      [win1ptr, yourdata],
      [win2ptr, yourdata],
      [win3ptr, yourdata]
   ]
and so on.
Or whatever!

The advantage of using this module over the other one, is that this technique only uses
one signal provided by the system, no matter how many windows you have open! (This does
of course make it not quite as fast - can't have everything. Unlimited and fairly fast
or max 15/16 and fast (using the other system), up to you.)

This does of course therefore account for why I haven't indicated an upper limit to the
number of windows your program using Muse may open.

It is in fact: Maximum 100 windows, but I can't see anyone really wanting that many.
Just think how cluttered the screen would get!

This module can raise a "wind" exception if it fails to open the window. This may be
due to the windows dimensions being impossible to fulfill :
   -  too large/small, off screen, etc

Like all other modules in this set of docs, this one is also subject to change.



