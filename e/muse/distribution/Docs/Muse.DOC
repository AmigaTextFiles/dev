
                          T H E    M U S E

                    R E F E R E N C E    G U I D E


                         Е1995 Michael Sparks
      Muse. The nine Muses helped and inspired people to create.
                        Consider this a tenth.


                               Contents
                               ********

1 Introduction
    1.1 Objectives
    1.2 This Version
    1.3 Usage
    1.4 Notes
    1.5 Comment

2 Concepts
    2.1 Events
    2.2 Processing
    2.3 Practicalities
    2.4 Virtual Visible Variables
    2.5 ARexx Concepts
        2.5.1 Overview of Hosts ARexx Supports
        2.5.2 Portname
        2.5.3 Commands & Functions

3 Program Structure
    3.1 Module Inclusion
    3.2 Interface Declaration
        3.2.1 Syntax
        3.2.2 Comment
        3.2.3 Syntax of `interface_definition'
        3.2.4 Advantages, Limitations & Flexibility
    3.3 Event Handling Procedures
        3.3.1 Determining the Event Type

4 Elements Syntax
    4.1 Notation
    4.2 Top Level Elements
    4.3 Event Elements Syntax
        4.3.1 The Standard Events
    4.4 Window Elements
        4.4.1 Key List Definition
        4.4.2 The Mouse Element
        4.4.3 Gadget Elements
        4.4.4 Menu Elements
    4.5 ARexx Elements
        4.5.1 command-element-list

5 Procedure Reference
    5.1 The Main Function
    5.2 Support Procedures
    5.3 Window Support Procedures
    5.4 Environment Support Procedures
        5.4.1 ARexx Related
        5.4.2 Window Related
        5.4.3 Gadget Related

6 Support Variables & Constants
    6.1 Variables
    6.2 Constants

7 Miscellaneous
    7.1 Author
    7.2 Credits
    7.3 History
    7.4 Cost


Preamble
    This document is a slightly(!) modified form of the fully hypertexted
AmigaGuide version that accompanies this one. As a result, some information
may be spread around more than it might seem necessary. In creating the Guide
version, I was thinking ahead towards this plain version, but this may have
not been enough for some people. To those people, I say upgrade and get a copy
of AmigaGuide! (or buy the printed reference manual - see end - which was
created from scratch and heavily influenced modifactions to this document)

A compromise form is available is available on the web:
    http://www.anglia.ac.uk/~mps102/index.html

Enjoy!




                        1 Introduction
                        **************

                            Muse.m
                      (+support modules)
          An interface programming system for AmigaE.



1.1 OBJECTIVES
==============
   The main idea behind Muse is that life should be easy for users. This
includes programmers, since they are users too. Also users should have as
much control over how they interact with their program as possible. This
includes programmers. ie programmers and end-users should have as much
control over their programs.



1.2 THIS VERSION
================
   This version of Muse, the release version is the first step towards that
goal. It is primarily aimed at programmers programming in the langauge
AmigaE. It is designed to be very programmer friendly in that to process/
create/destroy an interface, all you do is declare it. The advantage is the
fact that you are no longer worried with HOW it's implemented. This means
that you can concentrate on getting your program right.

NOTE, Muses Web site where any update info will first be shown is:
    HTTP://www.anglia.ac.uk/~mps102/index.html


1.3 USAGE
=========
  To use it, you have make a directory "muse" in your emodules: directory.
You then copy all the modules supplied there. You then create a directory
"muse" in your LIBS: directory, and copy all the standard image icons there.
If your program uses any of these you will need to distribute the ones you
use (all?) with your program.



1.4 NOTES
=========
   It is designed to create V.flexible interfaces with the minimum of fuss.
See the features section for more details.



1.5 COMMENT
===========
   As with any substantial system of this type, this document's size comes
from its comprehensiveness. You make want to look at the example program's
first (!) to get a rough idea of how things work before reading all of this.
There is also supplied a couple of quick reference files. Once familiar with
Muse, those are all you should need on a regular basis.






                           2 Concepts
                           **********

   As previously mentioned, to use Muse, you just declare the interface
and the processing to be done and let Muse get on with it. This section
describes the concepts as to how this works.



2.1 EVENTS
==========
   The key concept in Muse is that program's in general sit there waiting
for events to happen. These events are various inputs to the program :
eg key presses, button clicks, menu selections, inter-process ARexx calls.
As far as your program is concerned though, they are just events to react to.



2.2 PROCESSES
=============
   The main Muse handler which processes your interface first converts the
inputs it recieves into events which you've defined for them. Eg pressing
the key "k" might be converted to a CLOSE event. This event is then used to
find what procedure you've defined to process that event. This procedure is
then called with certain parameters and information about the event.



2.3 PRACTICALITIES
==================
   This process I is called raising an event handler. ie the process of
converting a menu selection of Close to the action of closing would be said
that the menu selection raises the CLOSE event handler. There are some
standard events : CLOSE, QUIT, MAIN, OTHER, MOUSE. Other events are tied to
inputs which you define. The event itself eg CLOSE, QUIT etc are integers.
All events defined by your program MUST be positive integers greater than
zero. ALL negative events are RESERVED.



2.4 VIRTUAL VISIBLE VARIABLES
=============================
    UG? Well, this is really a very simple concept. Sounds complicated but
is really a fairly sensible (IMHO) conceptual view of interfaces. As well
as raising events, interfaces provide programs with more information - such
as the value of a slider, the selection from a set of radio buttons, the
current point through a sequence of cycle gadget labels etc.

    In other words, many parts of the interface can in fact hold information
about which the program might wish to know about. They sound dangerously
like variables really don't they?! But we all know that they're not "True"
variables so I've decided that they must be virtual ;-). However in a GUI
they're also visible hence the three V words.
                               (side note: a W3 browser with V3 interface?)

    To this end, each input that can store a value which the main program
might wish to know about is given a name - which is the same idea as giving
normal variables a name. This name takes the form of a string, and can
currently be considered global to the Muse program. (Scoping will be
introduced in V2, possibly in the registered version)

Also currently the only such VV variables are gadgets, and hence to find
the information stored, you cuurently use the following construct:
    get_gadget_info(get_gadgethandle( vv_variablename))

Also like normal variables, you can SET the value of a VVV. Again due to
the fact that the only ones are gadgets, you use a similar construct:
    set_gadgetinfo(get_gadgethandle(gadget_name, value))

    For an example of programming using these, see the included address book
database program.


As a side note, the VVV system will (probably) grow dramatically in Release 2.

   See the section on Events Elements Definitions for more detail on
specific event types.

See Also Standard Events .



2.5 ARexx Concepts
==================

2.5.1 Overview Hosts AREXX supports 
----------------------------------
  There are two types of ARexx HOST that have ports available through
which they communicate with the outside world. The two types are Command
Hosts and Function Hosts. 

    Function hosts are (I believe) MUCH harder to implement, but much
easier to use (from an ARexx programmer's perspective). With them you
just use their functions/commands names without any more description.
Their commands may or may not return values directly to the ARexx program.
They act much like an add on library for ARexx.

    Command hosts are much easier to implement, but a but harder to use
(from an ARexx programmer's perspective). However, virtually all Arexx
Hosts on the Amiga are of this type. With these you must directly ADDRESS
the portname of the Command host in order to use the commands it makes
available.

   The commands you give it are (normally) enclosed by single quotes and
cannot directly return a value to an arbitrary variable set by the ARexx
programmer. There is support for the ability to return values to the
caller program via the ARexx standard variable 'result'.


What this means for Muse
   Any ARexx interface you define for Muse is a Command Host (like most
programs) irrelevant of the types of command you make available. For
implementation reasons, they are classified into two types: commands and
functions. These are described in detail below, but one returns a value
whereas the former does not. It is important to note that the Host type
is a Command Host NOT a function host. Trying to use a Muse ARexx port as
a function host WILL crash the system. This is something that may or may
not be patched - but since it isn't a bug, just user mis-use, it *may*
not.


2.5.2 Port Name
---------------
   Like all implementations of ARexx ports, your port has a name. What
you define is the BASE for which you would like your port to be named
from. This comes the the Amiga Style Guide since it is a GOOD IDEA

   Suppose you named your port 'Flooble'. If you ran it by itself then
any program that addressed Flooble would have no problem. BUT suppose
your user ran it TWICE. The second copy would not be allowed to run since
the port name Flooble was already in use. Using a Base gets around this
problem.

   If you request a BASE of 'Flooble' then the first run copy's port will
be called 'Flooble.1'. The second's 'Flooble.2'. The third - 'Flooble.3'
and so on up to the 100th copy. (Yes, if you subsequently close a copy,
and run another copy, the freed name will be reused) There is currently
an upper limit in 100 names per base. 


2.5.3 Commands & Functions
--------------------------
   Commands are just that. The calling ARexx program is just asking your
program to do something. Commands do not return any values, and are
therefore inherently easier to implement. Commands can also be considered
to run concurrently with respect to the CALLER ARexx program.

   Functions are a completely different kettle of fish. As you can see
they are declared in the same manner as commands, and if implemented in
an INEFFICIENT manner by YOU the user programmer, then they are relatively
simple to write. The problem comes from the fact that they are Functions.
An Arexx command function (as opposed to a command, or a True Arexx
function) can return a value to the caller's Arexx program via the standard
AREXX variable result. ALso with Arexx command functions you can define a
return code. You should ALWAYS return 0 for no error. Any other values
are at the moment undefined. (honest...)

   The fact that you return values is not really what complicates things.
The thing that complicates things is the fact that whilst you are processing
the command function call, the CALLING Arexx program has to wait for you.
If other programs are waiting for that program, and so on, then you can
SERIOUSLY degrade the user's machine's performance. You should therefore
write them to be FAST, and only used if you MUST return a value.

   To this end, a FUNCTION may also request an event to be raised after
the function's results have been passed back. This is so that you can reply
to the calling process AS SOON as you know what the return codes will be.

Therefore, the ENDPROC line of a COMMAND is:
    ENDPROC
           the ENDPROC line of a FUNCTION is:
    ENDPROC event, return_code, return_string

   event = event to raise upon reply to caller process
   return_code = as mentioned above. MUST be zero. Anything else is undefined
   return_string = the __string__ you wish to return the caller process.

And that's that.






                        3 Program Structure
                        *******************

   There are a few key elements to the structure of a program using Muse. The
line that includes the module in the program, the section that declares the
interface and the section that procedures that handle the events as they
happen. This chapter deals with those



3.1 Module inclusion
====================

Stick the following line at the start of your program:
   MODULE 'muse/muse'

Yep, just the one. Nice and simple!



3.2 Interface declaration
=========================

3.2.1 SYNTAX
------------
For this, include the following line:
    easy_muse(interface_definition)
or
    muse(interface_definition)
for that matter


3.2.2 COMMENT
-------------
OK, interface definition is where the "magic" happens. This is a list of
interface elements definitions. Each of which may or may not be defined in
terms of other interface elements.


3.2.3 SYNTAX OF "interface_definition"
--------------------------------------
As mentioned above, this is a list of interface elements.
Each element takes the form:-
            [element-type, element-definition]

ie a list of two parts.


3.2.4 ADVANTAGES, LIMITATIONS & FLEXIBILITY
-------------------------------------------
  High level element-types are currently constants, low-level element-types
are strings. (For future flexibility) Some element definitions are simple -
just a string, some are more complex eg gadgets in a window is made up of a
list of individual gadget definitions. The result is a highly flexible
structure.

   All elements in the list can be left out. They are all optional. ie if
there should be a list of elements, [] is fine. An element definition
though must be complete. ie ['QUIT',QUIT] is fine, but ['QUIT'] or [,QUIT]
etc are wrong, as is [] for an element. If you mess up the brackets, and
don't cause a syntax error from the compiler, Muse will tell you you've got
a structural problem.

  For more detail on the individual elements, see Elements Syntax.



3.3 Event Handling Procedures
=============================

    These are invoked when the user causes an input that raises an
event. You will be pleased (shocked?, worried?, bored?!) that all the
inputs use the same style of processing. Indeed, they are designed to
reduce application code size, as well as the interface code.

They all take the form:
      PROC name(event, evemt_info)
         do_stuff...
      ENDPROC (some have return codes)

"event"      is the event that caused this procedure to be called.
             (an integer value)
"event_info" depends on the input that caused this event to be raised.


3.3.1 DETERMINING THE EVENT TYPE
--------------------------------
   You can determine the input type (if need be) by testing the global
variable "event_type" which takes different values depending on the input
type. The values are as follows:
   MUSE_SYSTEM, MUSE_GADGET, MUSE_MENU, MUSE_KEY,
   MUSE_REXX_FUNC & MUSE_REXX_COMMAND.

   For all the types, except MUSE_REXX (both sorts), event_info is currently
a pointer to the window from which the input originated. For MUSE_REXX types,
event_info is determined by the command/function that caused that event to be
raised.

   For information specific to the individual elements and their types,
see Elements Syntax.
For information specific to the standard events see: Standard Events.
For an overview of the Events system & Muse in general see Concepts.






                           4 Elements Syntaxes
                           *******************

   NOTE!!! In this version (Release V1), the structure you pass Muse MUST
NOT change. IT MUST be STATIC. If it isn't, the results are indeterminate,
and therefore liable to change, an possibly dangerous.

   This section describes the syntax of all the Muse elements that you use
to define the interface that your program uses. It also has sections for
notes on each element.



4.1 NOTATION
============

In definitions :-

A word/label enclosed in < and > denotes something that is yet to
be defined. (and would be defined below)

If something is denoted as being <a|b|c|d> it means that the part
may be a or b or c or d. Each option is NOT a literal unless explicitly
stated otherwise.

Also a hyper-link from part of an element indicates that that part is 
complex enough to have it's own defintion, and hence the link.

A word/label (enclosed or not) followed by a * denotes that you may have
mutilples of these, with each part seperated by commas.

Bits that are punched into the definitions are desribed in indented text.
      Like this!

Square brackets are literals.

Examples
    "hello* world" is equivalent to "hello, hello, hello, world"
    "[hello* world]" is equivalent to "[hello, hello, hello, world]"
    "[ <Hellodef|Goodbyedef> ]"
where hellodef=hello
      goodbyedef = goodbye
means that the above def is satisfied by the values [hello] or [goodbye].

Clear? Check the examples if you require greater clarity.



4.2 TOP LEVEL ELEMENTS SYNTAX
=============================

MuseDef = [ <WindowDef>,* <RexxDef>, <EventDef>]

WindowDef= [WINDOW, <window-elements-list>]
RexxDef  = [REXX,   <rexx-elements-list>]
EventDef = [EVENTS, <event-elements-list>]

The in the Guide, links take you to the nodes that define those element parts!
If only text was this simple!
It may help to look at the structure's quick reference file first!



4.3 EVENT ELEMENTS SYNTAX
=========================
event-elements-list = [ <eventdef>* ]

eventdef = [ userdata , procedure ]
      userdata : is a constant greater than zero that defines the event no
                 that this event raises. The best way of using this is via
                 an enumeration.
                    eg ENUM NONE, OPEN, SAVE, SAVEAS, HELP.
                 Negative events are reserved by the Muse system. The event
                 number zero is completely reserved. It must not be used.
                 It will work differently in different contexts, and is
                 therefore indeterminate in general.

      procedure : this is a pointer to a procedure that is called when the
                  event defined by this element's user_data is raised.
                  ie an input which raises an event with the same no as
                  defined by this element.


      Examples [OPEN, {open_file}]
               [CLOSEFILE, {close_current_file}]

USED WITHIN : Top Level Elements.
See Also : The Standard Events.


4.3.1 The Muse Standard Events
------------------------------
   These are used in an event element definition on the left hand
side. They are all in practice constants that can be used in your
program. Consider their values private. Anyway, there's no point really
in not using them!

There are several standard events that the system can raise: STARTUP, CLOSE,
 QUIT, MAIN, OTHER and MOUSE.

  Yes, I know I said several, there are currently only 6, but this list is
likely to grow rather dramatically! (in time! - ie later versions)


The STARTUP Event
иииииииииииииииии
EVENT VALUE = STARTUP

   This is automatically raised if Muse is invoked by the easy_muse() command
rather than using any other method. (ie not muse()!) It is raised by Muse once
your interface has been created, but processing of it has not started. This
allows you to do things like say hello to the user. Not fancy, but useful. For
an example of usage, please see the Address book program!


The CLOSE Event
иииииииииииииии
EVENT VALUE = CLOSE

   This is automatically raised when the user clicks on the close
gadget of a window. This is not to say that you may not have
other inputs that can raise this, quite the opposite. It is
sensible to have keystrokes and menu options that can allow a
window to be closed.

   When this event is raised, the system looks for your CLOSE
event's procedure. If you have it will be called, and on return,
Muse will either close or not close the window dependent on your
procedure's return value. If it returns CLOSE, then the window
will close, otherwise it should return zero. If you do not supply
a procedure, then Muse will ask the user whether they would like
to close the window or not.

   A way of ensuring all windows always close in response to a
close event without asking the user would be:

   In your events def : [CLOSE, {always}]
   & add the procedure: PROC always() IS CLOSE


The QUIT Event
ииииииииииииии
EVENT VALUE = QUIT
    A special one this. You cannot define a quit event handler. (yet) I
am still deciding on what the semantics of just such a handler would
mean/entail. When raised by an input you define (or when the last window
closes), Muse goes into shutdown mode and starts shutting everything down.
It quits easy_muse() and muse_process_events().

NOTE! YOUR PROGRAM MAY NOT ASSUME ANYTHING ABOUT THE INTERFACE ONCE
      THIS EVENT HAS BEEN RAISED (ESP IF YOU'RE USING THE PROCEDURES
      easy_muse() IS MADE UP OF). 
You may not even assume that the interface is valid at this stage!

   The only thing that you may assume if the program leaves easy_muse() is
that the user is quitting, and that you must perform your shutdown code.

   The only thing that your program may assume if the program leaves
muse_process_events() via a QUIT event, is that you may restart processing
the interface by a second call. 

If an exception has been raised, you may not restart processing.
(Fireworks?)

Note : The Main event is not processed with this event.


The MAIN Event
ииииииииииииии
EVENT VALUE : MAIN
   This is a special event that is quite nice. It is made available
for the reason that lots of programs take the form:-
     REPEAT
        Wait for input
        Do some general MAIN stuff   ***
        Process it in some specific way
     UNTIL Quit

    This event is virtually alway raised for every event (see exceptions
below) that your program can recieve, IF you've defined a procedure to
handle this event. Otherwise, there's no need to worry about it!

   When raised, this event calls a procedure that does '***' event_info
will be the same as the event_info for the normal event handler. Unlike
CLOSE, there is no default procedure.


Exceptions
   This event is not raised when the actual event is a QUIT event, or a
REXX function event. (Although it could be 'chained' into action - see
Arexx Elements for more details)


The OTHER Event
иииииииииииииии
EVENT VALUE : OTHER
   This event is raised if the user presses a key that you haven't
defined a key for.(but have defined actions for some other keys)
Like MAIN, CLOSE and MOUSE, it is only raised if a handler procedure
exists for it!

Could be used say in a text editor...

See the section on Keys Elements for more information.


The Mouse Event
иииииииииииииии
EVENT VALUE : MOUSE
   This event is raised if the user clicks the mouse inside a window for which
you have declared MOUSE events to be activated within (see Mouse Element). It
may also be raised in ones that have certain types of gadgets in them. You
should therefore always check the window which raised this event.

   event_info will contain the window's pointer. 
   posx & posy will contain the location of where the mouse was clicked.

You will recieve a MOUSE event for both a click and a release. ie Button down
and up. (But no events for dragging - yet.)

Also, it should be handled by itself in it's own procedure in this version.



4.4 WINDOW ELEMENTS
===================

window-elements-list = [<boxdef>, <namedef>, <titledef>,
                        <keysdef>, <gadgetsdef>,
                        <menusdef>, <mousedef>]
boxdef = [BOX, [ x,y, width, height]]
      x,y,width,height are all integers. Define the dimensions of the window.
      Defaults to: [10,10,300,100]

namedef = [NAME, string]
      string is the name you wish to call this window. It is this string
             you pass to get_winhandle().
      Defaults to the title bar's string.

titledef = [TITLE, string]
      string is the text you wish to put in this window's title bar.
      Defaults to TEST.

gadgetsdef = [GADGETS, <gadget-list-def>]
menusdef   = [MENUS, <menu-list-def>]
keysdef    = [KEYS, <key-list-def>]

USED WITHIN : Top Level Elements


4.4.1 Key list Definition
-------------------------
key-list-def = [ keydef* ]
keydef = [key, event]
      key   is a character that defines this event.
            Examples "'" "a" 27 $0A "8"
      event is the event number that this event raises.
            eg QUIT OPEN 5 $10

USED WITHIN: Window definitions (Key elements def)

Notes : This list defines a list of events to be raised by particular keys.
        If you define 2 or more events for a key then the result is currently.
        undefined.

See Also: The 'Other' Event '.


4.4.2 The Mouse Element
-----------------------
mousedef = [MOUSE, 1]
   This just tells Muse that you want mouse events switched on in
   this window. The 1 is obligitory. Anything else _may_ work, with this
   version, but is not guaranteed to be in any future version.

USED WITHIN : Window definitions (Key elements def)

Notes: This element declares to Muse that this window will need to be able to
       recieve MOUSE events.

See also: The Mouse Event .


4.4.3 GADGET ELEMENTS
---------------------
gadget-list-def = [ gadgetdef* ]
gadgetdef =  < <button> | <radio> | <scroller> |
               <cycle> | <string> | <palette> |
               <checkbox> | <image> | <stdimage> >

SEE ALSO : Virtual Visible Variables


Button Gadget Syntax
ииииииииииииииииииии
buttongadget   = ['BUTTON', <buttondef>]

     buttondef = [event, name, label, x,y,width, height]

      event   is the event that gadget raises.
      name    is the _name_ of that gadget. (ie passable to
              get_gadgethandle())
      x,y     define the location top left corner of the gadget relative
              to the top left corner of the window. (in pixels)
      width   defines the width of the gadget in pixels.
      height  defines the height of the gadget in pixels
      label   is the text to place centred INSIDE the gadget.

USED WITHIN : Gadgets Elements
Notes: This type of gadget does not store any information - it sole purpose
       is to enable the user to give the program a graphical command - since
       all it does is raise an event. This type of gadget cannot therefore be a
       virtual visible variable.
See Also : Virtual Visible Variables


RADIO GADGET SYNTAX
иииииииииииииииииии
radiogadget    = ['RADIO', <radiodef>]

      radiodef = [event, name, options, x,y, initiallyactive]

      event  is the event that gadget raises.
      name   is the _name_ of that gadget. (ie passable to
             get_gadgethandle()}

      x,y    define the location top left corner of the gadget relative
             to the top left corner of the window. (in pixels)

      options = [label* , 0 ]
             Where label is a string denoting a possible selection.
             The labels appear to the RIGHT of the buttons.

      initiallyactive denotes which option is initially selected. It is
             an integer from 0 to number of options-1.
             ie options[initiallyactive] will be the initially selected
             possibility.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : Virtual Visible Variables


CYCLE GADGET SYNTAX
иииииииииииииииииии
cyclegadget    = ['CYCLE', <cycledef>]
      cycledef = [event, name, label, x,y,width, options]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

                 The label appears to the LEFT of the buttons.
          options = [label* , 0 ]
                 Where label is a string denoting a possible selection.
                 The labels appear to the RIGHT of the buttons.
                 The option initially active in this case is the first
                 option in the list.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : Virtual Visible Variables


SCROLLER GADGET SYNTAX
ииииииииииииииииииииии
scrollergadget = ['SCROLLER', <scrollerdef>]
   scrollerdef = [event, name, label, x, y, width, divisions, visible]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         divisions and visible are best described with an example.
         A document might have 500 divisions (lines) but have only 20
         divisions(lines) visible on screen.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is current level of the
       scroller.

See Also : Virtual Visible Variables


STRING GADGET SYNTAX
ииииииииииииииииииии
stringgadget   = ['STRINGGAD', <stringgaddef>]
  stringgaddef = [event, name, label, x,y,width, chars]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         chars is the maximum number of characters this gadget accepts.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is the current contents of
       the string gadget. (ie a string!)

See Also : Virtual Visible Variables


PALETTE GADGET SYNTAX
иииииииииииииииииииии
palettegadget  = ['PALETTE', <palettedef>]
    palettedef = [event, name, label, x,y,width,height, depth]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears ABOVE the gadget
         depth is the number of bit-planes this palette is designed to edit.
               1=2 divisons. 2=4 divisions. 3=8 divisions. This only makes
               sense if it equals the depth of the screen it's on...

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is which option from the
       options list (from 0 to no_of_options-1) is currently selected.

See Also : Virtual Visible Variables


CHECKBOX GADGET SYNTAX
ииииииииииииииииииииии
checkboxgadget = ['CHECKBOX', <checkboxdef>]
   checkboxdef = [event, name, label, x,y, checked]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         label appears to the LEFT of the gadget.
         checked = TRUE if you want it initially checked.
                 = FALSE if you don't.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query. The value it stores is whether the gadget is
       ticked (checked if you're not UK) or not. If it is, value is TRUE.

See Also : Virtual Visible Variables


IMAGE GADGET SYNTAX
иииииииииииииииииии
imagegadget    = ['IMGAE', <imagegaddef>]
   imagegaddef = [event, name, toggle-flag, x,y, pathname]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         toggle-flag=NORMAL means this gadget works like a button gadget
                    =TOGGLE means this gadget works like a checkbox gadget
         pathname is the path to an icon on disk. Best way of doing this is
         for it to be localised via PROGDIR: or a standard directory.
         NOTE: the pathname excludes the .info part.

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query if and only if the image gadget is a "TOGGLEing"
       image gadget. (Spelling is like that to make it more obvious. Comments?)
       The value it stores is whether the item is toggled or not. 
       (TRUE = Toggled!)
       
See Also : Virtual Visible Variables


STANDARD IMAGE GADGET SYNTAX
ииииииииииииииииииииииииииии
stdimagegadget = ['STD_IMAGE', <stdimagegaddef>]
stdimagegaddef = [event, name, toggle-flag, x,y, stdimagename]
            event  is the event that gadget raises.
            name   is the _name_ of that gadget. (ie passable to
                   get_gadgethandle()}
            x,y    define the location top left corner of the gadget relative
                   to the top left corner of the window. (in pixels)
            width  defines the width of the gadget in pixels.
            height defines the height of the gadget in pixels
            label  is the label to place beside that gadget.

         toggle-flag - as for imagegadget
         stdimagename - The name of a gadget icon as it appears on the
         workbench when you open the LIBS:Muse directory. Eg 'OPEN'

USED WITHIN : Gadgets Elements
Notes: This declaration can be considered declaring a virtual visible variable
       that you wish to query if and only if the image gadget is a "TOGGLEing"
       image gadget. (Spelling is like that to make it more obvious. Comments?)
       The value it stores is whether the item is toggled or not. 
       (TRUE = Toggled!)

See Also : Virtual Visible Variables



4.4.4 MENU ELEMENTS
-------------------
menu-list-def = [ <menudef>* ]
menu-def = < <headeritem>   |    <baritem> | <imageitem> |
             <stdimageitem> |    <subitem> | <item> |
             <substdimageitem> | <subimageitem>

Menu Header    = headeritem
Menu Items     = baritem, item, imageitem, stdimageitem
Menu Sub-items = subitem, subimageitem, substdimageitem.
Text Items     = item, subitem.
Image Items    = imageitem, stdimageitem, subimageitem, substdimageitem.


headeritem = ['HEADER', name]
    name is a string that denotes the name of the menu that is defined by the
          elements that follow. A sub menu item cannot directly follow this.
          Also if the next item is a Header item, you will have a menu with no
          items. Which is generally NOT useful, but is allowed (currently) by
           Muse (and the OS).

baritem    = ['BAR', NIL]
      This puts a item in the menu that acts as a separator between items. It
   can be useful for grouping sets of logical actions within a menu together.
   Note the NIL is OBLIGITORY. No other value can be considered value - even
   if you find it works with other values. This is to ensure future
   upgradability.


MENU ITEM (text label)
ииииииииииииииииииииии
item       = ['ITEM', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the label for this menu item.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.


MENU SUB ITEM (text label)
ииииииииииииииииииииииииии
subitem    = ['SUBITEM', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the label for this menu item.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.


MENU ITEM USING AN IMAGE
ииииииииииииииииииииииии
imageitem    = ['IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the path to the icon on disk to use as the 
             image. This is must be without the .info part.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the icon you have requested to use the images of,
       Muse will put the name of the icon in the menu instead of the image.


MENU SUB ITEM USING AN IMAGE
ииииииииииииииииииииииииииии
subimageitem = ['SUB_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the path to the icon on disk to use as the 
             image. This is must be without the .info part.
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the icon you have requested to use the images of,
       Muse will put the name of the icon in the menu instead of the image.


MENU ITEM USING A STANDARD IMAGE
ииииииииииииииииииииииииииииииии
stdimageitem    = ['STD_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the name of the standard image as it appears
             in th Libs:MUSE directory if it were to be viewed on the Workbench
             ie without the .info part. EGs 'OPEN' 'CLOSE'
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the standard image you have requested to use the
       images of,  Muse will put the name of the standard image in the menu
       instead of the image.


MENU SUB ITEM USING A STANDARD IMAGE
ииииииииииииииииииииииииииииииииииии
substdimageitem = ['SUB_STD_IMAGE', <itemdef>]
itemdef = [name, shortcut, event]
        name is a string defining the name of the standard image as it appears
             in th Libs:MUSE directory if it were to be viewed on the Workbench
             ie without the .info part. EGs 'OPEN' 'CLOSE'
        shortcut is this menu item's keyboard shortcut.
        event is the event no. to raise.

Note : If Muse cannot open the standard image you have requested to use the
       images of,  Muse will put the name of the standard image in the menu
       instead of the image. 



4.5 AREXX ELEMENTS
==================
Before diving straight in and looking at the definitions themselves, it
would probably be worth your while looking at ARexx Concepts In Muse. (2.5)

rexx-elements-list = [ <port-name-def> , <rexx-commands-list> ,
                       <rexx-functions-list> ]
port-name-def = ['NAME', portname-base]
        portname-base is a string defining the BASE name for your porgram's 
                      port.

rexx-commands-list = ['COMMANDS', <command-element-list>]
rexx-functions-list= ['FUNCTIONS', <command-element-list>] 
        If you've read the bit I mentioned above you'll understand why there
        are these two types, if not read it now! Other than the conceptual
        difference, there is NO difference in how you define the functions or
        commands. So they use the same format.


4.5.1 command-element-list
--------------------------
   This is the bread and butter of your interface. But look how simple it
is to define!

command-element-list = [ <simplecommand>* , <argscommand>* ]
simplecommand = ['SIMPLE', name]
argscommand   = ['ARGS',   name]
    Again the difference between these is run-time usage. They are just there
to help speed up your processing of any arguments passed. These two just
modify the format of the arguments that your procedure recives from the
outside world. Both recieve their value from the rexx_info argument to your
Rexx event-handler ie the second parameter.

    An analogy would be to say the SIMPLE form presents the arguments to your
event-handling proecdure like E's built in variable 'arg' that contains the
command line arguments as a single string. The ARGS form is similar in concept
to the argv/argc style of processing you have in C in that the argument is
limitted formatted to a tokenised array. 

Remembering when raised with 
   event_type=MUSE_REXX_FUNC
or event_type=MUSE_REXX_COMMAND    

That the procedure heading can be interpreted as:
    PROC procedurename(event, rexx_info)

Then in the following example,
 if the command (in the calling ARexx program) is
       'DO this that and the other'

    where 'DO' is a SIMPLE command,
       rexx_info would take the value 'this that and the other'

    where 'DO' is an ARGS command,
       rexx_info would take the value ['this','that','and','the','other']
       This means of course you could, say, ForAll({x},rexx_info,`WriteF(x))
       ListLen(rexx_info) will also obviously tell you the number of arguments.

Note, tokens are defined to be sperated by white space. 
      Since we're dealing with Arexx, multi-line arguments are not in the
      equation. The ONLY characters defined as white space are space itself,
      tabs and commas.
      Also quotes are not considered anything special. SO '"hello, world"' for
      example will tokenise to ['"hello','world"']

   The tokeniser will be DRAMATICALLY revamped for both the Registered Version
1 and Release Version 2.






                      5 The Muse Procedure Reference
                      ******************************
The most important sections here are to look are the first, third and fourth on this list.



5.1 The Main Function
=====================
Procedure:  easy_muse(def)
Parameters: def
Result    : A Living breathing program who's interface was easy to write.
Bugs      : None known.

   def is a fully qualified Muse Interface Definition structure
   It is (briefly) a list of Muse elements, where each element that
   is in itself not a list of Muse elements is a base definition of
   some part of the interface. Each element that is a list of Muse
   elements defines a logically coherant grouping. (eg GADGETS!)

   easy_muse() takes this definition, allocates the defined interface,
   opens it, and processes it, calling your program as need be. If your
   program quits, dies, or otherwise finishes (GURU excepted), easy_muse()
   quietly, promptly, and succinctly shuts everything down, and deallocates
   it.

   Worth noting: If for any reason Muse cannot open the interface,
   easy_muse() will let you, or your user know why and where.
      EG Window too large!                (and _which_ window)
         Can't find icon to create image! (and where it should be!)

   Doesn't do much else. Doesn't sound as if it should be as long as it
   is, but there we go... Makes it look easy doesn't it!
   (Took long enough)

SEE: Support Procedures, Window Support Procedures,
     Environment Support Procedures, Elements Syntax,
     Concepts, ARexx Concepts



5.2 Support Procedures
======================
   These three do the hard work for easy_muse() See the individual defs
of each to see what. The reason for having them available is so that,
if you wished, you could put code in between them if you wished.
EG to draw a piccy in the window between the call to muse() and the call
to muse_process_events() , or if you wanted to make sure the user was
really, really sure they really, definately wanted to certainly quit
between muse_process_events() and end_muse()


SEE: easy_muse(), Window Support Procedures , Environment Support Procedures,
     Defining your interface. (ie the 'def' above!)



Procedure : muse(muse_def)
Parameters: muse_def
Result    : A tidily allocated, visible interface that's awkward to do
            otherwise!
Bugs      : None known.

   muse_def is a fully qualified Muse Interface Definition structure.

   This results in a living, breathing, beautiful(?) interface, ready for
   the world, and all it can throw at it.

   ie  muse_process_events() can now process it!

SEE: easy_muse(), muse_process_events(), end_muse(),
     Support Procedures



Procedure : muse_process_events()
Parameters: none
Result    : Your program is run!
Bugs      : None known.

   This procedure assumes and is allowed to assume that you have an
   interface open ready to be processed. This interface must have been
   created using the Muse procedures available.

   It waits for input from the user. Translates that input into an event
   you've defined, and then calls the procedure you've written to handle
   that event.

   Doesn't do much else. (doesn't sound as if it should be as long as it
   is, but there we go... Makes it look easy doesn't it!)

SEE: easy_muse(), muse(), end_muse(),
     Support Procedures



Procedure : end_muse()
Parameters: none
Result    : It all disappears and goes away!
Bugs      : None known.

   Assumes you had a Muse interface open to start with.
   Closes it. That's it. Finito. (well, it also deallocates it! Nicely)


SEE: easy_muse(), muse(), muse_process_events(),
     Support Procedures



5.3 Window Support Procedures
=============================
   These procedures are there to enable you to selectively open and close
windows to enable you to have finer control on the use of your program.
This is especially the case with request().

SEE ALSO: set_stdwin(), get_winhandle(), get_winname().


Procedure : openwin(def)
Parameters: def
Result    : A window with clickable's and stuff...
Bugs      : None known.

   This procedure takes a window definition element, and creates a winodw
   with it, muse_process_events() and easy_muse() will both recognise it.
   eg
      mywindow:=[
                  [TITLE, 'Easy Paint : Draw Window'],
                  [BOX, [50,80,550,170]],
                  [MOUSE,1]
                ]
      openwin(mywindow)
   This results in a window that can be used say as a paint program's
   window. Not bad huh?

SEE ALSO : closewin(w)



Procedure : closewin(w)
Parameters: w:PTR TO window
Result    : Closes the window pointed to by w.
Bugs      : None known.

   w is a pointer to a window. eg stdwin

   This is the only way to legally close any window created by Muse for
   you, if you try doing it any other way, you are liable to crash the
   system. (At best, only sometimes)

SEE: get_winhandle(), get_winname(), set_stdwin(), openwin(def)



Procedure : request(text,buttons,arguments)
Parameters: text (optional), buttons (optional), arguments (optional)
Result    : Returns a value indicating which button was pressed.
Bugs      : None known.

   Useful one this. Creates a requester for the user to act upon. Used by you
   the programmer to force the user to make a choice before proceeding.

NB. All options default to either NIL,or something sensible.


   text is a string to be displayed in the requester's body. It can include
        standard E formatting codes, including those for arguments.

   buttons is a string defining the buttons in the requester.  It has the
      following format:-
         option (+ '|' option)
      where the bit in brackets is repeated as many times as you wish
      eg:      'OK'
               'OK|CANCEL'
               'Way!|Definately|Probably|Possibly|Maybe|NoWay!'
      Each button is numbered from 1 to number of options-1 from left to
      right excepting of course the right most one (the Cancel position)
      which has the value 0.
      It is this value that request returns upon exit.

   arguments is a list of arguments to fill the spaces left for them in the
             text section.

   Examples:
      request('Are you absolutely positive that you want to delete\n'+
              'File: \s size\d\nI mean *really* sure?',
              'Yes, Of course|May be|Ooops!',
              [filename,size])
      request('Hi There!')
      request('Quit?','Yes|no')
      request('Howdy!','Howdy to you too')

   Example Deluxe...
      name:= 'Insert your name here!'
      messages:=['Bye Bye\s',
                 'Good \s, You're staying',
                 '\s - you are boring!']
      request(messages[request('What Now?',
                               'Stay here|Use a PC|Go Home!')],
              'Yep',[name])

SEE: Window Support Procedures, Support Procedures



5.4 Environment Support Procedures
==================================
   These procedures allow you to find out where things are, what they're
called, what their values are, and even change them!


5.4.1 ARexx Related
-------------------
Procedure : rx_port()
Parameters: none
Result    : The name of your program's rexx port.
Bugs      : None known.

   This procedure simply returns a string with the actual name of your
   program's Arexx Port. The reason for the need for this function is
   simple : What happens if your program is run a second time concurrent
   to the first?
      Well, suppose you requested a port name of 'MyProg'.
      The first program's Rexx port name would be 'MyProg.1'
      The second's would be 'MyProg.2'
      The third's : 'MyProg.3'
   And so on up to the 100'th copy. This is currently the upper limit.

   This is a limit imposed by me, not by th OS (I think). The reason is
   twofold: it simplifies things somewhat, and also I can't see why anyone
   would want to run 100 copies of the same program at the same time. (Not
   on a micro anyway)

See Also : Arexx Concepts


5.4.2 Window Related
--------------------
Procedure : get_winhandle(name)
Parameters: name
Result    : A pointer to the window you've asked for.
Bugs      : None known.

   name is a string defining the name of a window you have opened using
        either easy_muse() or muse() or openwin()

   This procedure returns a window pointer pointing to the window you've
   asked for. This is *not* done in a time critical manner, so if you
   intend to use that window often (ie switch between using different
   windows a lot), you would be well advised to take a copy of the pointer 
   for yourself.

   This is the opposite of get_winname()

SEE: set_stdwin(), get_winname(), Virtual Visible Variables



MUSE - Getting the name of a window from it's pointerProcedure : get_winname(handle)
Parameters: handle
Result    : The name of the window pointed to by handle.
Bugs      : None known.

   handle is a window handle for a window you have opened using either
          easy_muse() or muse() or openwin()

   This procedure returns the name of the window pointed to by the window
   handle you have passed it. This is *not* done in a time critical manner.
   So if you need to know it's name on a regular basis you would be well
   advised to keep a note of it in your program!

   This is the opposite of get_winnhandle()

SEE: set_stdwin(), get_winhandle(), Virtual Visible Variables



Procedure : set_stdwin(handle,name,activate)
Parameters: handle(optional), name(optional), activate(optional)
Result    : Sets the current window to the window denoted by handle or name
            Activates it as well if required
Bugs      : None known.

   handle is a window handle for a window you have opened using either
          easy_muse() or muse() or openwin(). Default=NIL

   name is a string defining the name of a window you have opened using
        either easy_muse() or muse() or openwin(). Default=NIL

   activate is a Boolean defining whether to activate the window as well
            or not. Default is FALSE. (Don't activate)

   What this procedure does is:
      Sets stdwin to the window pointed to by either handle or name.
           (if you pass neither, it doesn't change stdwin, if you pass both,
            the result will be consistant, undefined!)
      It then checks to see if you wanted to activate it.
      If you did, it does so.

   Also worth noting, stdrast (E's built-in variable) is also kept in step
   with this command!

SEE: MuseVariables, Window Support Procedures


5.4.3 Gadget Related
--------------------
Procedure : get_gadgethandle(name)
Parameters: name
Result    : A pointer to the gadget you've asked for.
Bugs      : None known.

   name is a string defining the name of a gadget you have created using
        either easy_muse() or muse() or openwin()

   This procedure returns a pointer to the gadget you've asked for. This
   is  *not* done in a time critical manner, so if you intend to use that
   gadget's value a lot, you would be well advised to take a copy of the
   pointer for yourself!

   This is the opposite of get_gadgetname()

SEE: get_gadgetinfo(), get_gadgetname(), Virtual Visible Variables



Procedure : get_gadgetname(handle)
Parameters: handle
Result    : A string containing the name of the gadget to asked for!
Bugs      : None known.

   handle is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   This procedure returns the name of the gadget pointed to by the gadget
   handle you have passed it. This is *not* done in a time critical manner.
   So if you need it on a regular basis you would be well advised to keep
   a note of it in your program!

   This is the opposite of get_gadgethandle()

SEE: get_gadgetinfo(), get_gadgethandle(), Virtual Visible Variables



Procedure : get_gadget_info(gad)
Parameters: gad
Result    : The information stored inside that gadget!
Bugs      : None known

   gad is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   What this returns is a bit spesh! If the gadget stores a value, it returns
   that value. If it makes a selection from a set of options it returns that
   option's number.

   This function alone would be *much* more awkward to code if it weren't
   for E. (and I do mean MUCH more awkward)

SEE: get_gadgetname(), get_gadgethandle(), GadgetsDefinitions,
     set_gadgetinfo(),Virtual Visible Variables



Procedure : set_gadgetinfo(gad, value)
Parameters: gad, value
Result    : The information stored inside that gadget!
Bugs      : None known

   gad is a pointer to a gadget you have created using either easy_muse()
          or muse() or openwin()

   This procedure is quite nice. It does (unsuprisingly) the opposite of
   get_gadget_info()! ie It acts as an assignment statement. The gadget
   (currently) must be accessed via it's pointer rather than it's name,
   but that's so that if you use any of the VVV's on a very regular basis,
   you'll probably want to keep a copy of the variable anyway

   The values you can set for each gadget type are described along with
   that gadget. But put simply, if the gadget makes a selection from a set
   of options, value takes that selection's number. If gadget takes input
   for a string, then value is a (pointer to a) string. If the gadget stores
   is a colour, then value is the colour number. And so on. Nice and SIMPLE!


SEE: get_gadgetname(), get_gadgethandle(), GadgetsDefinitions,
     get_gadget_info(),Virtual Visible Variables






                 6 Support Variables and Constants
                 *********************************

6.1 Variables
=============
   The variables that Muse makes available for your ponderance upon are:
      event_type, stdwin, posx,posy, lastgadget, muse_error, muse_info

   These variables are ALL read only! (stdwin can be modified using the given function only)

NOTE: Although there are some more exported, you may not modify them
      Those (undefined here) are PRIVATE! Use at your peril!

event_type
   This variable lets you know what type of input caused your EventHandler
   to be called. It contains a constant.
   SEE: Constants

stdwin : PTR TO window
   The current window. If you use Muse's procedures to keep this current,
   then stdrast will be attached to this window. (standard window struct)
   SEE: set_stdwin()

posx, posy
   The location where the mouse was last clicked. Only set if you have a
   MOUSE event handler, and the window that was clicked in has had a MOUSE
   declaration.
   SEE: Constants

last_gadget
   Contains the handle (not the name) of the last gadget to be clicked
   on. If one hasn't been clicked on, the value of this is undefined.
   SEE: get_gadgethandle(), get_gadgetname(), get_gadget_info()

muse_error
   Constant defining what just went wrong!
   Currently, although defined, sometimes vaguely, although this is a
   public variable, I am keeping it's values private. The reason is I
   want to make sure this is good before I set it in concrete.

muse_info
   A string _explaining_ what went wrong!
   In general though, if you use easy_muse() your program will tell you
   what went wrong with as many refernces as it can manage.



6.2 Constants
=============
   The following are the constants available for use in Muse. Although there
are also some other ones exported, they are PRIVATE. VIP's eyes ONLY! (ie if
you use them - it's at your peril)

EVENTS, WINDOW, REXX
   Used for top level Muse elements.

TITLE, NAME, BOX,
   The bits that define general bits about your window!

MENUS, GADGETS, KEYS, MOUSE
   The bits that define the inputs to your window!

TOGGLE, NORMAL
   Used with image gadgets

CLOSE, QUIT, OTHER, MAIN, MOUSE
   The Muse standard events.

MUSE_KEY, MUSE_GADGET, MUSE_MENU, MUSE_REXX_FUNC, MUSE_NONE,
MUSE_REXX_COMMAND, MUSE_SYSTEM
   The various sources of input...
   Note mouse is (currently) intentionally left out... (in that there isn't
   a MUSE_MOUSE note. It should (currently) be handled by itself.






                             7 Miscellaneous
                             ***************

7.1 About The Author
====================
This is me:
   Michael Sparks, 22 years old,
   40 James Street, Cambridge.
   Tel (01223) 563995   (or +44 1223 563995)
   email: mps102@bridge.anglia.ac.uk
   Home page: http://www.anglia.ac.uk/~mps102/index.html

My Machine:
   A600, 2Mb RAM, 170Mb HD, Canon B10sx Printer.
   (Not a bad little 7Mhz system really!)

Software:
   Ed 2.00 (!!) AmigaE3.2 REGISTERED.

(tip for using Ed (yes as in 'in the c: directory') - try deleting the
 ed-startup file. Ed is much better than you think. Its got hidden secrets)

   All money donated will go towards further Muse production (which will go
on even if no-one sends any money). ie me getting an A1200 or such like!
Electricity bills, coffee, drink, etc...

   The crux algorithms and structures that Muse relies on came from not
thinking about it for the best part of 6 Months. (The six months prior
to Feb95) The resultant structure is MUCH more powerful than it appears.
But you'll have to wait for either V2 or Registered to see why...



7.2 Credits
===========
   Although not able to give any help in either a coding way or testing way,
the following people were instrumental in my continuance of development:

      Wouter van Oortmersson - Registered E is well worth it. E is his idea
                     of an ideal programming language. Mine too. Muse would
                     not be possible without it. Well, this is my first
                     version of Muse. This is my idea of an interface
                     processing system.

      David Sparks - My brother - His assistance in conceptually help
                     develop Muse was more helpful than I think he'll ever
                     realise. Especially the practice I got in explaining
                     the event mechanism, and the reason for the mechanism.
                     ALso for insights into various other areas into which
                     Muse could move into.

      Anthony Brown - For very similar reasons. (And also for downloading E
                      Version 3 for me - getting that made me register).


People who helped with the documentation:
      T Rochford - Head of Computing Services at Anglia for helping with the
                   web site's teething problems!

      Jason Hulance - For Ag2txt - used to generate the first generation plain
                  text version of this document.

      Christian Scholz - For Guide2Html - used to generate the first generation
                  of the web-pages to be used on the Muse web site. And also
                  for the substantial disclaimer, modified and enhanced for
                  Muse.
                      Web Address: http://www.anglia.ac.uk/~mps102/index.html

General Credit goes to:
      Escom     - For buying Amiga!
      CU Amiga  - For providing such decent coverdisks and magazines over
                  the years, The printed manual that I have produced is
                  entirely done using Pagestream2.2UK as supplied on the
                  coverdisk supplied with one of their magazines. I was
                  totally gobsmacked when I saw that they had included the
                  registered version of E this month. I urge them if they
                  read this to contact me about inclusion on their disks!
      MUI - for being so pretty, but totally unusable on my machine due
            to it's high memory overheads, and sluggishness!-)
            (ie putting me off it!  :-) I do NOT MEAN TO BASH MUI BECAUSE
            MUI SEEMS TO HAVE VERY SIMILAR AIMS, AND I COMMEND IT.
            (It just doesn't work too well on a 7Mhz 2Mb machine.;-)
            After all, Muse could be used as an overlay onto MUI at a later
            point, if approriate/possible...



7.3 History
===========
Feb 96 Release Version 1 uploaded to Aminmet. Announced on Newsgroups.
       Web site as a source of information to do with Muse set up.

   Muse did not start out with the aim of being what it has become. It
started out with me wanting a simple way of programming 2.0 style gadgets.
This was around  Nov 94. Due to my having a full-time retail management job
at the time, work progressed slowly, often with nothing being done on it
for weeks at a time.

   It was at this stage I started using lists to define gadget structures
rather than procedure parameters, mainly because I was trying to think
ahead to a time when I would be able to sequence through a list perhaps, or
maybe create a run-time editor. Events were nowhere to be seen, and it
wasn't anything like a module at that stage. 

   Then I got hold of Amiga E Version 3. The power thus dispensed, I decided
to get a hard drive and register. This dramatically changed the turn-around
time on testing, debugging, and prototyping. One Late Jan95 day, I was
watching an episode of Babylon 5 and I was thinking to myself, (I know, sad)
that their computer systems would have to be incredibly complex (and
reliable) in order to deal with all the troubles that could happen in that
environment. This made me think.

  The use of those systems appeared to be incredibly simple: re-configuring
an entire sensor net took only a short while, adding in new systems was as
easy as pie, writing programs must therefore be as easy to do in that time.
After all 3 centuries of CASE tool development must produce some nifty tools.

   My idea started there. I thought to myself, the list structures used by
easygads (as it was then) were quite flexible, but not as flexible as they
could be. I decided to write a program to take a list structure, and open a
window using that. Once that was done, I wrote a little procedure to take a
list of V.simple gadget definition lists, which produced a pointer to a
list of gadgets ready to be linked into a window. The gadgets were the
simple Gadget() (E's built in function) type. But this was just prototyping.

   Next I decided to nest that procedure within then window procedure. It
was then that I realised that this could be extended into making lists of
windows. Also at the time I was wading through the RKRMs looking at tag's,
but I realised early on that E's unification command was the best was way
of utilising something slightly different. I realised that there was the
possibility that you could use a very simple structure to define things of
the form:
   [tag, bla]
But in E this was a list, not a tag-list. Hence Muse uses lists, not tag-lists.

2nd Feb 95. This was when Muse in a recognisable form was conceived. I
decided how would I like to define a program programs interface in such a
way that it would be easy to process. I considered the idea that each input
would have a procedure attached to it.

   Conceptually it's good, but it ignores the fact that different input
techniques effectively as far as the program is concerned is just different
ways of getting essentially the same info. After all a menu selection Close
is the same as a close gadget click, the same as a right-amiga k, the same
as a control \, the same as (say) pressing q.

   To write a procedure for every one of those inputs struck me as pointless.
After all the event that is happening is that the window should close.
Thats's when I struck of the idea of input->event->procedure call. Where
the first conversion is from a 'physical' input to a logical event, and the
second being a look up as it were of what we do in that situation. This
reduced redundancy. Which invcreases both readability, efficiency, decreases
program complexity, and these factors combined with the fact you are no
longer worrying about the interface and how to process increases the
likelyhood of program correctness. (ie less bugs!?)

   It also struck me that the list structure available in E is very similar
to the sequence structure in VDM, and if I completely specified the
interface using this, and specified what happened when this structure was
processed that VDM would finally have a precise, REUSABLE, technique for
specifying the interface a program has with respect to the outside world
without enforcing the appearance of that interface. (There's no reason if
Muse existed on other platforms that you couldn't take virtually the same
code recompile it and use it.) Certainly the EER diagram you can draw (as in
Fund. DB Sys. Elmasri & Navathe) for Muse is to say the least elegant.

   It was at this point I decided to go for it. What followed next, is as
they say history. Over the following months, I created manipulators to work
on the structures Muse used. It had several name changes. The first was
SimpleGUI, a few months later after I added in ARexx support, it briefly
became SimpleUI. It was at this stage nick-named 'A YACC for WIMPs', since
YACC (as I understand it) does the same for a text environment.

   These acronyms began to hack me off after a while, so I decided to call
it something sensible so I looked through some of my books on Greek
mythology, and came up with Muse. (Because they inspired people, as Muse
was inspiring me to add in new features every time I added in the one I had
just thought of) I decided to add in ARexx when I decided that Muse was of a
high enough potential to release given a few more months work.

   So what you have is one programmer's labour of love. A desire to see
programs easy to write, efficient ands reliable. This has gone through all
the way, hence if say, you give Muse a string rather than a list, it will
spit it back at you. This system is not complete. This version is. But
there is the registered version to come. And after that version 2. (Which I
think will raise quite a few eyebrows)

   This version is fairly bullet-proof. I am in the process of formally
speciying Muse to help keep later versions that way. One reason it is fairl
bullet proof is due to OO style techniques, where approriate and dynamic
run-time coding as well to increase readability, flexibility and reliability.




7.4 Cost!
=========
   Well, this is always the uncomfortable bit. What does it cost me? Well,
2000 lines of code such as Muse is, with it's high complexity of what it
does for you, what do YOU reckon it's worth.

   One way of evaluating it would be to use Intermediate COCOMO (which gives
a cost estimation based on program length and functions it handles. The
evaluation is in the guide file if you're desparate!) The resulting cost is:
Total cost = Б15500

   This is a valid, recognised project cost evaluation model. A fair asking
price for this product if it were to be sold to and used by one user would
the price above. (Read a book on it. eg Software Engineering Economics By Barry
Boehm. Publ. Prentic Hall)
Honest!-)


What am I asking?
=================
                                                +---------+
This version you have, the Release Version 1 is | F R E E |
                                                +---------+
It costs you nothing. You are free to copy it as you choose.
(see the licence aggreement for more details, and disclaimers)

                +-----------------------------------+
                | All I ask is this if you use it,  |
                |    LET ME KNOW WHAT YOU THINK!    |
                |          contact point            |
                |(Politely, after all this is free.)|
                +-----------------------------------+


   There will also be available a
                +-----------------------------------+
                | Printed & Bound  Reference Manual |
                +-----------------------------------+
    at the end of Mar '96.
    which goes into much greater detail about everything to do with Muse,
    and is well worth the money.

Until Then, don't forget the Web Site:
    Http://www.anglia.ac.uk/~mps102/index.html

   Cost?
      UK : Б5 (inc P&P)
      Everywhere else : Б15. (or $20)

  There will be available mid '96 the registered version. A piece of paper
with your name and address on, with postage will ensure you finding out
when it is due for release, and perhaps a flyer saying what features it has.
The registered version will cost Б10. The printed manual for it will cost
the same as above. (unless you have already bought one, in which case you
will get a reduction!)

  Those who send me detailed bug reports, with source code,
a directory listing of your development system, and if I can reproduce the bug
will recieve a FREE copy of the registered version. Registered users, esp those
who register before it's available, will get free notification on new
releases.

  Basically you can use Muse, without reservations or guilt. If you send me
money, you get stuff! Also I am happy to answer any Muse
related questions. I'll obviously lend a (more) sympathetic ear if you've
registered!

   All money donated will go towards further Muse production (which will go
on even if no-one sends any money). ie me getting an A1200 or such like!
Electricity bills etc. Coffee, drink, nights out...

See Also : Author




That's it, read the tutorials, examine them, and enjoy!

