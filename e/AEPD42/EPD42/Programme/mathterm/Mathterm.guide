@database Mathterm
@master //Docs/Mathterm.guide
@$VER: Mathterm.guide Version 1.23 (16-Jun-96)
@author "Marcel Bennicke"
@(c) "© Marcel Bennicke"
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" "Mathterm-Object"
  @{b}-------------------------------------
   Mathterm-Object for the E-Language@{ub}
       Version 1.23 (16-Jun-1996)
  @{b}-------------------------------------@{ub}

       @{"††††††Introduction††††††" link "introduction" 0}   What is it...
       @{"††††††††Features††††††††" link "features" 0}   What are its goals...

       @{"†††††Using†Mathterm†††††" link "usage" 0}   I want it!

       @{"†††††††Known†Bugs†††††††" link "bugs" 0}   What, are there any?
       @{"†††††Known†Problems†††††" link "problems" 0}   Hey, what's wrong?

       @{"††††††††††Todo††††††††††" link "todo" 0}   Future releases...
       @{"†Disclaimer,†Copyright††" link "disclaimer" 0}   no warranties!

       @{"††Contacting†the†Autor††" link "author" 0}   Who did it?


  @{fg highlight}Thanks to Wouter van Oortmerssen for his great compiler!@{fg text}
@endnode

@node "introduction" "Mathterm-Object"
@{b}What's the purpose of Mathterm?
---------------------------------------------------------------------@{ub}

Imagine you are going to implement a program that plots graphs of any
mathematical function. Probably it wouldn't be a problem for you to
create a functional graphical interface, to manage a full set of
functions, to give your outcome abilities such as differential and
integral calculus, to cut the matter short: to create the most
powerfull plotter ever seen.

But nevertheless you will have a tough nut to crack: How to get your
Amiga to compute mathematical terms?

Here comes Mathterm: Using the OO-mechanisms of Amiga-E (Version 3.0a
and upper ones) I've implemented an OBJECT that does exactly that: to
compute any mathematical term. But there are even more @{"features" link "features" 0} you as
a programmer may profit from. Have a look!
@endnode

@node "features" "Mathterm-Object"
@{b}List of Features
---------------------------------------------------------------------@{ub}

 ∑large set of @{"built-in†functions" link "list of built-in functions" 0} (those functions the Amiga-
  libraries support plus some extra-ones)
 ∑integrated constants (pi, e)
 ∑automatically manages a @{"list†of†functions" link "Construct funccontext" 0} and constants with
  different names
 ∑user can @{"add†new†functions" link "Adding functions" 0} and constants using the internal ones
 ∑each function can have any number of variables
 ∑no restrictions in names', terms' and variable-names' length
 ∑object can be used with @{"single-terms" link "Construct single-term" 0} as well 
 ∑supported operators: + - * / ^
 ∑clear @{"spelling†of†terms" link "Expression-syntax" 0}
 ∑english error-messges provided in a @{"separate module" link "Modules" 0}
 ∑@{"versions" link "usage" 0} for IEEE-single and IEEE-double variables. You may import
  both into one program (to let the user decide if he wants to
  struggle with single-precision or he prefers double)
 ∑makes heavy use of E's exception-machanism for comfortable
  @{"error-handling" link "error-handling" 0}
 ∑elaborate object-oriented interface
@endnode

@node "usage" "Mathterm-Object"
@{b}How to use Mathterm?
---------------------------------------------------------------------@{ub}

@{u}Currently there are two ways using mathterm:@{uu}

 1. Directly interface the calculation engine. So you may work around
    a luxurious set of procedures but lack of the ability to
    implement own functions at runtime.
 
 2. Make use of the funccontext-OBJECT that provides an expandable
    functionlist.


@{b}Please notice that there are two different Modules:@{ub}

 - mathterms    For use with IEEE-Singles as the built-in
                compiler-functions (current version 3.2e)

 - mathtermd    For use with IEEE-Doubles as the
                mathieeedoub#?-libraries provide them. In E you can
                access these libraries with the longreal-Module that
                comes with your compiler or use my @{"DoubleSupport.m" link "Modules" 0}
                which is a extension to longreal.m

  Each function, OBJECT, constant ... exported by these modules
  has one of the extensions "s" (@{b}s@{ub}ingle)  or "d" (@{b}d@{ub}ouble)
  indicating with precision is used. So the name of the
  mathterm-OBJECT exported by the single-precision-module is
  "mathterms" and its corresponding funccontext-OBJECT will be
  "funccontexts".

Additionally there are two modules for error-handling which both the
single and the double-version make use of:

 - @{"mathtermerrors" link "Modules" 0}         contains declaration of error-constants
 - @{"mathtermerrorstring" link "Modules" 0}    english error-messages which you may use
                          in your programs.

No matter which module you import, you either have to do some
@{"initialisation" link "Initialisation & Clean up" 0}-work before using one of the imported functions and you
should @{"clean†up" link "Initialisation & Clean up" 17} everything when you are finished.

In-between those steps mathterm provides you with the following
features:


  @{b}Calculating a single-term@{ub}

     @{"Constructing†a†mathterm-OBJECT" link "Construct single-term" 0}
     @{"Variable-setting†and†computing" link "" 0}
     @{"Auxiliary†methods" link "Auxiliary† methods" 0}
     @{"Destruction" link "Destructing a mathterm-OBJECT" 0}
     @{"Example" link "Example Single Term" 0}

  @{b}Setting up a list of functions@{ub}

     @{"Construncting†a†funccontext-OBJECT" link "Construct funccontext" 0}
     @{"Adding†new†functions†and†constants†at†runtime" link "Adding functions" 0}
     @{"Variable-setting†and†computing" link "set vars & †compute (list)" 0}
     @{"Interation†through†the†list" link "List Interation†" 0}
     @{"Destruction" link "Destruction of list" 0}
     @{"Example" link "Example Funclist" 0}

  @{b}Error-handling@{ub}
                        
     @{"General" link "" 0}
     @{"List†of†errors" link "" 0}
@endnode

@node "Initialisation & Clean up" "Mathterm-Object"
@{b}Initialisation and Clean up
---------------------------------------------------------------------@{ub}

Before you call to any of the provided functions, the module has to be
initialized. That's why you must call

    @{b}mtsInit([exception-key])    -> single
    mtdInit([exception-key])    -> double@{ub}

anywhere in the beginning section of your program (mts/mtd stands for
mathterm-single /-double). This will allocate some memory and set
internal data to default values. As argument you have to pass an
exception-key which will be used when mathterm begins to throw out
exceptions (see @{"error-handling" link "error-handling" 0}). This way it can't interfere with
other modules you might import.

When your program finishes you should call

    @{b}mtsCleanup() or
    mtdCleanup()@{ub}

to free all resources. mtxCleanup() might be called mutiple.
@endnode

@node "Construct single-term" "Mathterm-Object"
@{b}Constructing a mathterm-OBJECT
---------------------------------------------------------------------@{ub}

First of all you have to construct an OBJECT to supply the engine with
informations such as a expression-description, used variables and some
more. Having set up such an OBJECT correctly you might @{"compute" link "Variable-Setting and Computing" 0} its
result, @{"modify†its†variable-contents" link "Variable-Setting and Computing" 22} or do some @{"other†things" link "Auxiliary† methods" 0} with it.

Anyway creating a mathterm-OBJECT (let's say we want to have a
single-precision one) follows the usual E-syntax:

 @{b} NEW [PTR TO mathterms].mathterms([expression-string],
                                   [variablelist=NIL],
                                   [name=NIL])@{ub}

As you can see the name of the constructor is "mathterms". You feed
him with at least one argument:

 - An expression-description given as a string. Your expression
   might consist of operators (+ - * / ^), operands (actually
   numbers or constants), functions (see list of built-in
   @{"functions" link "list of built-in functions" 0}) and brackets for grouping. How a correct
   expression looks like you find @{"here" link "Expression-syntax" 0}!

Optionally you might pass:
                                                                 
 - an E-List (be sure it is really an Elist not an ARRAY OF LONG!)
   enumerating all variables by name. Omitting this argument
   will cause your expression to behave like a constant. Please
   notice that ALL names are case-sensitive! If you declare a
   variable in this EList but don't really use it within your
   description nothing will happen but wasting a few bytes of
   memory.
                                                                   
 - a name for your function, but in most cases it should be
   redundant here (default-argument =NIL)


@{u}EXAMPLES:@{uu}

1. @{b}DEF a=NIL:PTR TO mathterms
   NEW a.mathterms('x*x',['x'])@{ub}
                                                                
   Will create an OBJECT computing the sqare of a given value.

2. @{b}NEW a.mathterms('(x+y)/2',['x','y'])@{ub}

   will give you the middle between two values x and y.

3. @{b}NEW a.mathterms('sin(degree)',['degree'])@{ub}

   simply computes the sinus of a value. The variable's name here
   is 'degree'.

4. @{b}NEW a.mathterms('3^x',['myvar'])@{ub}

   Error, because the variable x doesn't appear in the separate
   list. (It would give you 3 to the power of x)

5. @{b}NEW a.mathterms('4E-1+2e2-0.3')@{ub}

   Simply computes "0.4+200-0.3". No variables are used. Please
   notice that writing "200.1" would be faster because mathterm
   still @{"does†no†optimization" link "todo" 0}!
@endnode

@node "Variable-Setting and Computing" "Mathterm-Object"
@{b}Variable-Setting and Computing
---------------------------------------------------------------------@{ub}

After you have created a mathterm-OBJECT it is ready to run.

Of course you can compute the result of an OBJECT "a" with the help of
the calc()-method:

    @{b}[value] := a.calc()@{ub}

If there are variables, their current contents will be used (initially
0). Please notice that returning a value only is compliant with the
singe-precision-module because only IEEE-singles fit into one LONG. If
you want to use doubles you have to pass a "PTR TO longreal" where the
result will be stored (see @{"DoubleSupport" link "Modules" 0}):

    @{b}a.calc([PTR TO longreal])    -> for doubles@{ub}


It goes without saying that there is a method that allows you to
modify your variables. Its name is setVar().

  @{b}setVar([value],[index=0]) OF mathterms@{ub}

As arguments you have to pass the new value and an index marking which
variable should be altered (if there are more than one).

Please notice that value's internal representation MUST match the type
of your mathterm-OBJECT, i.e. if you have a single-precision mathterms
you must supply it with IEEE-singles and if you have a
mathtermd-OBJECT only IEEE-doubles (represented as in longreal-module)
are welcome. Getting an IEEE-single should be no problem since writing
"a.set(4.5)" in an E-source is right. To get the
IEEE-double-representation of a certain value you should use the
longreal-module-function a2d() or have a look at my
DoubleSupport-module.

The index metioned above is the postition (starting from 0) of the
variable-name within the E-list you passed as argument to the
constructor. So if you wrote

    @{b}NEW a.mathterms('a+b-c*d',['a','b','c','d']@{ub}

the correct indexes are:        0   1   2   3

This sets variable 'c' to 1.4: @{b}a.setVar(1.4,2)@{ub}

You even might have the index searched by the method getVarIndex()
(see @{"auxiliary†methods" link "Auxiliary† methods" 0}).
@endnode

@node "Auxiliary† methods" "Mathterm Object"
@{b}Auxiliary Methods
---------------------------------------------------------------------@{ub}

This chapter describes some handy methods which don't fit into one of
the previous chapters.

@{i}Please notice that there is no range-checking on any indexes you pass
to a method!@{ui}


    @{b}[value] := getVar([index=0])@{ub}

reads the current value of the specified variable. 

    @{b}[index] := getVarIndex([namestring])@{ub}

will try to find out the index of the given variable. First var has
index 0. Returns -1 when variable not found. Please notice again that
names are case-sensitive.

    @{b}[name] := getVarName([index=0])@{ub}

opposite to getVarIndex: returns a pointer to the variable's name.
NOTE: @{i}Only read this data!@{ui} (E doesn't know about constant references
like C++ for example)

    @{b}[count] := getVarCount()@{ub}

returns the number of variables defined for this mathterm.

    @{b}[name] := getFuncName()@{ub}

results in a pointer to the name of your expression if you specified
one. Again, only read this data!

    @{b}[expression-description] := getFuncTerm()@{ub}

will give you a PTR TO CHAR containing a copy of your
expression-description you passed to the constructor.


If you have a look at the source-code, you will notice some more
methods. Originally these are of internal use, but couldn't be hidden
when exporting the OBJECT throughout a module. So don't use them
within any of your applications!
@endnode

@node "Destructing a mathterm-OBJECT" "Mathterm-Object"
@{b}Destructing a mathterm-OBJECT
---------------------------------------------------------------------@{ub}

As usual in E you simply launch a

    @{b}END [PTR TO mathterm]@{ub}

to invoke the OBJECT's destructor and free all memory.

You best destruct an OBJECT after "EXCEPT DO" !
@endnode

@node "Example Single Term" "Mathterm-Object"
@{b}Example 1
---------------------------------------------------------------------@{ub}

The following code will ask the user for a name and a description of a
function with two variables 'x' and 'y'. If he he enters an invalid
term the program quits with an english error-message you get by
calling getMTErrorStr() (see @{"error-handling" link "error-handling" 0}). If everything is fine
the user may enter several values for both variables and the program
will compute the result.

Please notice that this demo imports the SingleSupport-module for
converting strings into IEEE-single-floats and vice versa. Be aware,
it is not thoroughly tested and may produce a little incorrect outputs
(but supports 'large' numbers like 2E+20).

Here is the source code:


MODULE 'tools/mathterms','mathieeesingbas','mathieeesingtrans',
       'tools/SingleSupport','tools/mathtermerrorstrings'

CONST   MATHEXCEPT = "math"

PROC main() HANDLE
    DEF descr[100]:STRING, input[40]:STRING,
        func=NIL:PTR TO mathterms,r,
        out[50]:STRING,

        err_string[MT_ERRORLENGTH]:STRING, -> space for error-strings
        type,info                          -> space for error-numbers


    IF (mathieeesingbasbase:=OpenLibrary('mathieeesingbas.library',
        37))=NIL THEN Raise("sinB")
    IF (mathieeesingtransbase:=OpenLibrary(
       'mathieeesingtrans.library',37))=NIL THEN Raise("sinT")

    mtsInit(MATHEXCEPT)      -> initialize module

   
    WriteF('Please enter name and description for a function\n'+
            'using two variables \ax\a and \ay\a.\n\n')

    WriteF('Name: ');ReadStr(stdout,input)
    WriteF('\s(x,y) = ',input);ReadStr(stdout,descr)

    ->create Object with input-string and variables x & y
    NEW func.mathterms(descr,['x','y'],input)

    WriteF('Enter values for x and y. Nothing for x quits.\n\n')

    LOOP
        WriteF('x = ');ReadStr(stdout,input)
        IF EstrLen(input)=0 THEN Raise("quit")
        func.setVar(str2Single(input),0)  -> set variable x (index 0)

        WriteF('y = ');ReadStr(stdout,input)
        func.setVar(str2Single(input),1)         -> set y

        r:=func.calc()                           -> compute

        -> output results (floats must be converted into strings)
        WriteF('\s(\s,',func.getFuncName(),
            single2Estr(out,func.getVar(0)))
        WriteF('\s) = ',single2Estr(out,func.getVar(1)))
        WriteF('\s\n\n',single2Estr(out,r))
    ENDLOOP

EXCEPT DO

    SELECT exception
    CASE "sinB"
        WriteF('\nError opening mathieeesingbas.library\n')
    CASE "sinT"
        WriteF('\nError opening mathieeesingtrans.library\n')

    CASE MATHEXCEPT -> catch ALL exceptions raised by module
        -> inquire error-type and additional-info with mtsGetError()
           [or mtdGetError() when using doubles]
        type,info:=mtsGetError()
        -> pass these args and an EString to GetMTErrorStr() to get a
        -> description
        WriteF('\nError within mathterm:\n\s!\n',
                getMTErrorStr(err_string,type,info))

    CASE "quit"
        WriteF('\nProgram finished.\n')
    ENDSELECT

    END func                -> never forget!
    mtsCleanup()

    IF mathieeesingbasbase THEN CloseLibrary(mathieeesingbasbase)
    IF mathieeesingtransbase THEN CloseLibrary(mathieeesingtransbase)
ENDPROC



This could be one output of it:

Please enter name and description for a function using two variables
'x' and 'y'.

Name: foo foo(x,y) = x*y+x/y

Enter values for x and y. Nothing for x quits.

x = 4 y = 2 foo(4,2) = 10

x = 9 y = 3 foo(9,3) = 30

x =

Program finished.
@endnode

@node "Construct funccontext" "Mathterm-Object"
@{b}Constructing a funccontext-OBJECT
---------------------------------------------------------------------@{ub}

This OBJECT represents a list of functions, that might be linked up,
i. e. if you have a term A declared, you might add a second term B to
the list, that makes use of A.

The list now is needed to keep track of such relations between several
terms and supports features such as @{"iteration" link "List Interation†" 0} through itself and
@{"searching" link "List Interation†" 0}.

First of all, you have to create a funccontext-OBJECT (again, there is
one for singles and doubles) in memory by calling its constructor:

    @{b}NEW [PTR TO funccontexts].funccontexts()@{ub}

As you can see, no args are needed. The constructor-method initialises
the list-structure and adds two terms named 'pi' and 'e' to itself
(both need no arguments and simply contain the numbers 3,141592... and
2.7182818...). This way you can always use these standard-constants in
other definitions.
@endnode

@node "Adding functions" "Mathterm-Object"
@{b}Adding functions
---------------------------------------------------------------------@{ub}

To get a funccontext-OBJECT growing simply apply the

    [PTR TO mathterm] := addTerm(name, description, [varlist = NIL])

method on its instance. The arguments you supply are the same as for a
mathterm-constructor: a unique name for your term, its description and
an E-List of variable-names if needed.

The result of addTerm is a pointer to an initialized mathterm-OBJECT,
which you can modify right as a @{"simple†created†OBJECT" link "Construct single-term" 0}. The only thing
you @{u}must not@{uu} to do is to destruct it with END. Instead make use of the
@{"removeTerm()-method" link "Destruction of list" 0} (it will see if it is still used by other terms
and if not delete the term from the list before).


EXAMPLE:

    -> this time we use double-precision
    MODULE "DoubleSupport", "mathtermd"

    ...

    DEF flist=NIL:PTR TO funccontextd, term=NIL:PTR TO mathtermd,
        temp: longreal   -> imported from DoubleSupport

    NEW flist       -> construct list

    -> add term and store PTR to initialized mathtermd
    term:=flist.addTerm("sqare","x*x",["x"]) 

    str2Double(temp,"4.2")    -> make a double-representation
    term.setVar(temp)         -> set 1st (and only) variable to 4.2

    term.calc(temp)          -> compute term and store result in temp

    ...
@endnode

@node "set vars & †compute (list)" "Mathterm-Object"
@{b}Setting variables and coputing of terms in a list
---------------------------------------------------------------------@{ub}

This chapter is merely redundant because there are no differences @{"here" link "Variable-Setting and Computing" 0}
between single-terms and terms added to a funccontext-OBJECT. (Why
should that be, in both cases you get a PTR TO mathterm). But there is
an additional funccontext-method which may help you with one problem:

When setting variables you always must provide the @{"setVar-method" link "Variable-Setting and Computing" 0} with
a number in single-float-form or as a "longreal" (see @{"DoubleSupport" link "DoubleSupport" 0}).
Much more intuitive would arguments as 2*pi be. That's the purpose of
new method

    @{b}setVarTerm([PTR TO mathterm], expression, index=0)@{ub}

To set the variable # '0' of the term 'myterm' to the value of 'pi/2'
simply call

    @{b}fc.setVarTerm(myterm,'pi/2',0)@{ub} or
    @{b}fc.setVarTerm(myterm,'pi/2')@{ub} .

This will temporarily add the term 'pi/2' to the funccontext 'fc'
(must be previously constructed) and compute it in that context, i. e.
the definition for 'pi' is taken from the list 'fc'. Afterwards 'pi/2'
will be deleted again. Note that setVarTerm() may raise exceptions
(see @{"error-handling" link "error-handling" 0}) if expression can't be computed in the given
context or @{"contains†errors" link "Expression-syntax" 0}.
@endnode

@node "List Interation†" "Mathterm-Object"
@{b}Iteration through list
---------------------------------------------------------------------@{ub}

Having a liked list of functions can be fine in a lot of programs. But
with its comfort comes some overhead as well. One surely needs to know
which functions are actually in the list, how their names and
descriptions are and last but not least one should not need to store
every pointer to a added term by himself.

That's why there are two methods which help you with such problems.

The first is named

    @{b}[PTR TO mathterm] := nextTerm([PTR TO mathterm])@{ub}

and provides an iterator for every funccontext-OBJECT. Simply pass a
NIL to this method and you get a PTR TO mathterm for the first term in
the list (may be NIL too!). Then feed the method with this pointer and
you get the next term... When there are no more functions in the list
you get NIL (This way you magically arrive in an infinite loop when
you make silly errors :-).


The second method is called

    @{b}[PTR TO mathterm] := findTerm(name)@{ub}

and allows you to serach for a specific term (what else ;-). Still be
aware that names are case sensitive. If it can't find such a function
you get NIL.
@endnode

@node "Destruction of list" "Mathterm-Object"
@{b}Destruction of list
---------------------------------------------------------------------@{ub}

There are three ways to get rid of these terms and lists:

@{u}1. delete them "by hand"@{uu}

   To remove a particular term from a funccontext you should use
   the method

      @{b}[PTR TO funccontext].removeTerm([PTR TO mathterm])@{ub}

   As you can see you'll need the address of the term. Before
   destroying your term by END this function will look if it is
   still in use by other terms. In this case it raises an
   MT_TERMINUSE - exception. Otherwise your term will be removed
   from the list and destroyed (destructor-call).


@{u}2. delete all terms@{uu}

    @{b}[PTR TO funccontext].clear()@{ub}

    The clear-method removes ALL terms from this context but leaves
    the list intact so you can add new terms again. There will
    be no warnings.


@{u}3. delete all terms and destroy list@{uu}

    @{b}END [PTR TO funccontext]@{ub}

    Guess what, it is the destructor!
@endnode

@node "Example Funclist" "Mathterm-Object"
@{b}Example funccontext-OBJECT
---------------------------------------------------------------------@{ub}

Please have a look at the mathtermdemo2.e program - I didn't want to
blow up this guide with almost 400 lines of code.

This example-program is quite useful, not only for demonstration
purposes. You can test how to @{"add†new†terms†to†the†list" link "Adding functions" 0}, @{"delete†them" link "Destruction of list" 0},
you might plot a graph or simply do @{"calculations" link "set vars & †compute (list)" 0}. All this is realized
only by a few methods of both OBJECTs mathtermd and funccontextd. By
the way: this demo makes use of the double-precision-versions.
@endnode

@node "bugs" "Mathterm-Object"
@{b}Bug-Report
---------------------------------------------------------------------@{ub}

- The module contains a bug in it's structure, which I found
  some days before distribution. To remove it the whole OBJECT had to
  be rewritten... Being afraid of destroying all my work I decided to
  work around it by introducing a global variable "schmuggleBug".
  However the computing-engine itself isn't touched (only the way how
  to create a tree for the term) and in fact gains some speed. If
  desired I'll fix the problem in a future version.

- nevertheless, the OBJECT seems to be stable (even against
  error-provoking inputs), fastly computes correct results and does
  not cause Enforcer-hits.

If you see things from a different view let @{"me" link "author" 0} know!
@endnode

@node "problems" "Mathterm-Object"
@{b}Known Problems
---------------------------------------------------------------------@{ub}

 - Both mathterms and mathtermd use separate modules for converting
   float-strings into their internal representation and vice versa.
   I've implemented those @{"modules" link "Modules" 0} (SingleSupport.m, DoubleSupport.m)
   because E can't handle strings like "1.3e24".

   The Problem now is, that my routines seem to be quite slow and
   much harder the output-procedure might be incorrect at the last
   digit(s). You are encouraged to rewrite these routines!

 - Because E can't bring OO-programming together with features like
   inline-substitution the whole mathterm-OBJECT is in some respects
   "over-styled" and thus inefficient. For example the
   element-function getVarName() of the mathterm-OBJECT causes 3
   function-calls only so extract a PTR TO CHAR.
@endnode

@node "todo" "Mathterm-Object"
@{b}Items still to implement
---------------------------------------------------------------------@{ub}

 - get rid of the "schmuggleBug"-variable (see @{"Bugs" link "bugs" 0})

 - optimize internal representation (e.g. a*(1+2) is still stored as
   it is, but could faster be computet as a*3)

- support diffential calculus as a way to create new terms

 - do not only return a copy of expression-description but create
   a new string out of the tree. This feature is especially needed
   when differential calculus gets implemented
@endnode

@node "author" "Mathterm-Object"
@{b}Author's Information
----------------------------------------------------------------------@{ub}


If you have got any questions, bug-reports, suggestions please contact
me at the following address:

  Snail-mail  Marcel Bennicke
              Dorfstraﬂe 32
              03130 Bohsdorf
              GERMANY
              
  EMail       marcel.bennicke@t-online.de


I'm especially interested in programs you've written using Mathterm.
Please feel free to send me a copy of your work or at least mail me a
description. I'd like to know how many of you out there really use
mathterm.
@endnode

@node "list of built-in functions" "Mathterm-Object"
@{b}List of built-in functions
---------------------------------------------------------------------@{ub}

These are the basic-functions mathterm supports.

sin          Sine (expects argument in rad) cos          Cosine (same
arg as sine) tan          Tangent ... cot          Cotangent asin
Arc sine acos         Arc cosine atan         Arc tangent sinh
Hyperbolic sine cosh         Hyperbolic cosine  tanh
Hyperbolic tangent exp          natural antilogarithm (e^x) ln
natural logarithm lg           common logarithm sqrt         square
root rad          conversion grad (circle = 360∞) to rad (circle = pi)
grad         conversion rad to grad abs          absolute value ( |x|
)
@endnode

@node "Expression-syntax" "Mathterm-Object"
@{b}Expression-syntax
---------------------------------------------------------------------@{ub}

Since I'm too lazy (and unable :-) to present you some EBNF-scheme for
the syntax of terms please heed the following hints and find out the
rest by yourself if something is unclear (e. g. with
'mathtermdemo2').

- all caracters with ascii <=32 are whitespaces

- Terms may cosist of the following binary operators:

     +  -  *  /  ^ (power)

  On each side of them something useful must be present. There are
  the following priorities: + -     1
                            * /     2
                            ^       3

  So '2 + x^2^y * sin(x)' will be interpretet as
  '2 + ( ((x^2)^y) * sin(x))'


- There is only one unary operator, which may be placed in front
  of the whole thing or after an opening bracket.

    - (minus)

- Constant numbers may contain an E or e followed by +2, only 3
  or -4 indicating 10 to the power of that exponent.
  Valid numbes are: 3  3.0   4e-20   -2.3E3 (= -2300)
                    .1e-2 (=0.001)
  invalid are       3.  E2   -.23  3.23e  ...

- If you use one of the built-in functions an opening (and later
  a closing) bracket must follow. See @{"here" link "list of built-in functions" 0} for a list of all
  functions.

- If you use self-defined functions while adding terms to a
  funccontext-OBJECT an opening bracket must follow if this
  particular function requires one or more arguments. Multiple
  arguments are separated by a comma. If a term does not need any
  args you must not supply a bracket.

- Names for variables/terms should obey the following rules:
  ∑may only contain characters a-z, A-Z, 1-9
  ∑first character must be a letter
  ∑you may append numbers at the end, do not mix them with letters
  ∑must be unique in their particular environment (you may have
   terms with different names in a list each of them with its
   own set of different variable-names, but variable-names of
   two terms may repeat)
@endnode

@node "error-handling" "Mathterm-Object"
@{b}Error-handling
---------------------------------------------------------------------@{ub}

Thanks to E's sophisticated exception-mechanism you as a programmer
have an easy game to play when something goes wrong. Of course you
have to know how to handle E's exceptions in general but since this is
dead easy everybody should be capable of mastering mathterm's errors.

As mentioned above each error is handled via exception. But to prevent
you from remembering lots of error-numbers I conceived the following
solution:

The only exception mathterm may raise is the one you passed as
argument to mtxInit()-function (replace x by s or d depending on which
module you use).  It is a general exception telling your program that
something within mathterm went wrong. You might catch it the
EXCEPT-part of any procedure and do appropiate steps. Be aware of one
more exception that might be produced by the NEW-operator. It raises
"MEM" if you're not having enough free memory.

To figure out what type of error occured you can use the

  @{b}[mathterm-error],[info] := mtxGetError()@{ub}

procedure (it is really a procedure not a method!). It will return you
two values: an error-number and some additional information which
actually depends on the first value. The meaning of these
@{"error-numbers" link "List of Errors" 0} is defined in the external module 'mathtermerrors.m'. So
you can easily build your own error-messages. But there is more: the
english strings I've implemented in a second separate module:
'mathtermerrorstrings.m'. Using its procedure

  @{b}[EString] := getMTErrorStr([mathterm-error],[info],[EString])@{ub}

you even don't have to know about the error-numbers. Simply pass the
results of mtxGetError() to getMTErrorStr() and you get a complete
error-message. Furthermore mathtermerrorstrings.m exports a constant
MT_ERRORLENGTH which you should use when defining an Estring for the
messages.

OK, that was enough theory. Here is an example of how to handle errors
correctly. Please have a look at the code of the second demo-program
as well!


MODULE  'mathterms',            -> include mathterms-OBJECT
        'mathtermerrorstrings'  -> include english error-messages


PROC main() HANDLE

    -> open libs etc.

    mtsInit("math")             -> init module, tell him to raise
                                -> exception "math" when something
                                -> goes wrong
    LOOP
        ...                     -> your code here!
        xyz()
    ENDLOOP

EXCEPT DO
    -> handle program-specific exceptions

    mtsCleanup()                -> call it best after EXCEPT DO
    -> close libs etc. ENDPROC


PROC xyz() HANDLE
    DEF term=NIL:PTR TO mathterms

    NEW term.mathterms('x*x + this_is_an_error',['x'])
    -> creating this term will definitely fail and thus the
    -> constructor raises our defined exception "math"

EXCEPT DO           -> don't forgert the DO
    END term                -> Never forget to destruct the OBJECT,
                            -> even if an exception occured.
                            -> At least NEW allocated some bytes
                            -> of memory which have to be freed

    SELECT exception
    CASE "MEM"
        WriteF('Operator NEW failed allocating memory!\n')
    CASE "math"             -> here we catch ALL mathterm-errors!
        handle_matherror()
    ENDSELECT

ENDPROC

PROC handle_matherror()
    DEF error, info,                -> space
        msg[MT_ERRORLENGTH]:STRING  -> an Estring to hold the message

    error, info:=mtsGetError() -> figure out last error-type and info
                               -> we needn't to know the meanings

    -> get an english message and print it out
    -> getMTErrorStr() will return your Estring again so you can use
    -> it this way within WriteF() for example

    WriteF('Mathterm-Error: \s!\n',getMTErrorStr(error, info, msg))
ENDPROC


That's all folks!
@endnode

@node "List of Errors" "Mathterm-Object"
@{b}List of Errors
---------------------------------------------------------------------@{ub}

@{u}These may occur during a mathterms/d(), addTerm() or setVarTerm()@{uu}

@{fg fill}number/name             description + content of info@{fg text}

MT_NONE                 dummy error, everything is fine
                        info: -

MT_NOSTRING             you tried to build a term from that: ''
                        info: -

MT_IDRESERVED           the name of one of your variables or of
                        your term is already the name of another
                        term
                        info: PTR TO CHAR referring to name

MT_UNKNOWNID            expression-description contained an unknown
                        name/char/whatever
                        info: position of first char in
                              description-string (starting from 0)

MT_IDTOOSHORT           the variable list contained ''
                        info: -

MT_NOTALLOWEDID         variable-name or term-name is invalid
                        maybe you tried something like "3w",
                        "myvar5c" or "money$"
                        info: PTR TO CHAR pointing to this name

MT_VARSTWICE            you passed 2 variables with the same name
                        info: PTR TO CHAR ...

MT_MISSOPERANDBEFORE    description contains error: missing
                        operand before that position you get in
                        info
                        info: look above

MT_MISSOPERANDAFTER     same as before, only missing operand
                        after position in info
                        info: position where operand should follow

MT_MISSOPENBRACKET      missing bracket in description. Occurs
                        after usage of a function which requires
                        arguments (e. g. 'sin+3' -> 'sin(pi/2)+3')
                        info: position of function which missed
                              args

MT_MISSOPERATOR         missing an operator between two operands
                        info: position where operator should be
                              placed

MT_TOOMUCHOPENBR        description contains more opening brackets
                        than closing ones
                        info: number of superfluous opening brackets

MT_TOOMUCHCLOSEBR       same as before, only for closing brackets
                        info: dito

MT_KOMMASEPARATES       a comma was found at invalid position. It
                        solely should separate multiple arguments
                        within function-calls
                        info: position of comma

MT_WRONGARGS            a function required more/less arguments than
                        passed
                        info: PTR TO CHAR pointing to func-name

MT_STACKOVERFLOW        guess what :->



@{u}This may occur only during removeTerm()@{uu}

MT_TERMINUSE            you attempted to delete a term which is
                        still in use by other terms of that list
                        info: PTR TO CHAR referring to name
@endnode

@node "Modules" "Additional modules"
@{b}Additional modules
--------------------------------------------------------------------@{ub}

mathterm makes use of the following external modules, written by me

@{u}DoubleSupport.m/SingleSupport.m:@{uu}

    These mods serve procedures to convert strings into their
    internal representation of IEEE-singles or IEEE-doubles and vice
    versa. There are extra-procedures to produce correct EStrings
    from my routines.
    Since IEEE-doubles are 64 Bits wide, they can't be stored in a
    standard LONG-variable but in an OBJECT called 'longreal'
    (consists of two 32 bit LONGs :-). I simply extended the
    longreal-module you get with your compiler with my procedures.
    (original longreal-module was written by EA van Breemen 1994)

    PROCEDURES:
       SingleSupport:
       single2Str(string, single, # of digits=6, exponent=7)
       single2Estr(string, single, # of digits=6, exponent=7)
       str2Single(string, startposition=0)

       DoubleSupport:
       double2Str(string, longreal, # digits=15, exponent=16)
       double2Estr(string, longreal, # digits=15, exponent=16)
       str2Double(longreal, string, startposition=0)
       ...many more as in longreal-module

@{u}Chars.m:@{uu}

    My Amiga-E version of C header-file 'ctype.h'.

    PROCEDURES:
       isDigit(char)
       isAlpha(char)
       isUpCase(char)
       isLowCase(char)

@{u}mathhtermerrors.m:@{uu}

    definition of error-constants, no precedures

@{u}[mathtermerrorstrings.m:]@{uu}

    this one is not really included in the mathterm-modules, but
    you should use it!

    exports procedure getMTErrorStr() to provide built-in english
    error-messages.

    PROCEDURES:
       getMTErrorStr(string to hold message, exception, info)

@endnode

@node "disclaimer" "Disclaimer"
@{b}Disclaimer and Copyright
---------------------------------------------------------------------@{ub}

THIS PIECE OF SOFTWARE (MODULES "MATHTERMS.M", "MATHTERMS.M",
SINGLESUPPORT.M", "DOUBLESUPPORT.M", "CHARS.M", "MATHTERMERRORS.M",
"MATHTERMERRORSTRINGS.M" AND DEMO-PROGRAMS "MATHTERMDEMO1" AND
"MATHTERMDEMO2"  ITS CORRESPONTING SOURCES) ARE PROVIDED "AS IS". BY
USING THEM, YOU ACCEPT THE RESPONSIBILITY FOR ANY DAMAGE OR LOSS THAT
MAY OCCUR DURING OR BECAUSE OF THEIR USE, DIRECTLY OR INDIRECTLY. THE
FITNESS OF THIS SOFTWARE FOR ANY USE OR PURPOSE IS NOT GUARANTEED. THE
AUTHOR IS NOT, AND CAN NOT BE HELD LIABLE FOR ANYTHING.

Mathterm is Copyright 1996 by Marcel Bennicke.

The whole pakage of mathterm and its acompanying modules and sources
are freeware. You can do with it what you want except using the
sources and/or modules for commercial purposes of any kind. You can
spread the archive as long as no parts of it are removed or modified.
@endnode

