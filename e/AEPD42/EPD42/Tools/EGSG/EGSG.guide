@database "EGSG.guide"

@node main "Inhaltsverzeichniss"


              EGSG (@{b}E@{ub}-@{b}G@{ub}adToolsBox-@{b}S@{ub}ource-@{b}G@{ub}enerator) v1.0b

              Quellcode-Generator für die Sprache Amiga-E

                Copyright (c) Daniel Kasmeroglu (1996)

                              - @{b}FREEWARE@{ub} -


 Informationen für alle Benutzer...

   @{" Der Autor               " LINK ma_author}
   @{" Kopierrechte            " LINK ma_copyrights}
   @{" Amateure                " LINK ma_disclamer}


 Einleitung...

   @{" Wofür dieses Programm ? " LINK ma_sense}  
   @{" Systemanforderungen     " LINK ma_requirements}
   @{" Installation            " LINK ma_installation}


 Benutzung des Programms...

   @{" Starten des Programms   " LINK ma_starting}
   @{" Grafische Oberfläche    " LINK ma_interface}


 Anmerkungen des Autors...

   @{" Weiterentwicklung       " LINK ma_future}
   @{" Einschränkungen         " LINK ma_restrictions}
   @{" Vor- und Nachteile      " LINK ma_disadvantages}


@endnode


@node ma_author " Der Autor "

  Mein Name ist Daniel Kasmeroglu (netter Zungenbrecher ;-) und ich
  programmiere seit einiger Zeit in der Sprache E, da sie mir u.a.
  erlaubt Assembler-Quelltext bequem einzubinden um das Programm
  zu optimieren. Auch dieses Programm entstand auf diese Art und
  Weise. Obwohl ich zu den Leuten gehöre, die ihre Programme
  (mittlerweile) vorerst auf Papier planen und dann programmtechnisch
  umsetzen, kann es trotzdem zu Fehlern komme. Ich habe das
  Programm zwar von einigen Freunden (mehr oder weniger intensiv)
  testen lassen, aber es könnten dennoch Fehler im Programm sein.
  Diese erste Version ist eine sog. Beta-Version, was bedeutet,
  daß sie sich noch im Teststadium befindet. Da ich keine MMU
  besitze und folglich das Programm "Enforcer" nicht nutzen kann
  bin ich auf Fehlerberichte angewiesen, die v.a. im Zusammenhang
  mit diesem Programm auftraten. Wer also Anregungen bzw. Fehlerberichte
  für mich hat soll sie bitte an folgende Adresse senden:

     Daniel Kasmeroglu      (Leider bin ich nicht via Internet erreichbar !)
     Rubensstr. 26
     12159 Berlin
  

  P.S.: Fehlerberichte sollten möglichst detailliert sein und die
        aktuelle Systemkonfiguration enthalten.

  P.S.: Dies ist mein erstes öffentlich verfügbares Programm,
        weshalb meine Erfahrungen beim Schreiben einer Dokumentation
        nicht allzu berauschend sind.

@endnode


@node ma_copyrights " Kopierrechte "

  Dieses Programm und seine dazugehörigen Dateien sind @{b}FREEWARE@{ub}.
  Sie dürfen an jeden weitergegeben werden, sofern sie @{b}unverändert@{ub}
  und @{b}vollständig@{ub} sind. Es dürfen lediglich Gebühren zum Selbstkosten-
  ausgleich erhoben werden. Jeglicher Versuch mittels Gebühren einen
  Gewinn zu erzielen kann @{b}strafrechtlich@{ub} verfolgt werden.

  Folgende Dateien gehören zu diesem Programm:

     - EGSG, EGSG.info                     ; Das Programm
     - EGSG.guide, EGSG.guide.info         ; Diese Dokumentation
     - gtsupport.e, gtsupport.m            ; E-Module
     - listview.e, listview.m
     - hook.e, hook.m
     - kicker.e, kicker.m
     - helpful.e, helpful.m

@endnode

@node ma_disclamer " Amateure "

  Die Benutzung dieses Programms geschieht auf eigene Gefahr. Der Autor
  (Daniel Kasmeroglu) übernimmt für Schäden, die durch das Programm
  oder seiner fehlerhaften Anwendung entstanden sind keine Haftung.

@endnode

@node ma_sense " Wofür dieses Programm ? "

  GadToolsBox ( Jaba Development ) ist ein Programm, daß es dem 
  Programmierer ermöglicht grafische Oberflächen zu zeichnen und
  in einem speziellen Format zu speichern. Die daraus resultierende
  GUI-Datei enthält aber keinen Quelltext, sondern nur die
  Beschreibung der Oberfläche. Hier kommen die sog. Quelltext-
  Generatoren ins Spiel, deren Aufgabe es ist, die GUI-Datei in
  Quelltext umzuwandeln. Auch für E gibt es einen solchen
  Quelltext-Generator namens "SrcGen", der vom Programmierer
  dieser Sprache (Wouter van Oortmerssen) geschrieben wurde.
  Natürlich hat er nicht so viel Zeit in diesen Quelltext-Generator
  stecken können, wie in seine Sprache, weshalb das Ergebnis
  zwar passable aber nicht berauschend war. Aus diesem Grunde
  habe ich selbst einen Quelltext-Generator geschrieben, der noch
  einige zusätzliche Funktionen besitzt und über eine einfache
  grafische Benutzeroberfläche verfügt.

@endnode

@node ma_requirements " Systemanforderungen "

  Unbedingt notwendig:

    o Amiga OS 2.04 oder höher
    o ca. 250 KB freier Hauptspeicher
    o "gadtoolsbox.library" v35 oder höher
    o "nofrag.library" v2.2 oder höher        


  Sollte vorhanden sein:

    o Compiler Amiga-E v3.0 oder höher
    o GadToolsBox v2.0c oder höher 
      (vielleicht funktionieren auch ältere Versionen :)
    o "powerpacker.library" v35.347 oder höher
    o "asl.library" v37 oder höher
    

@endnode

@node ma_installation " Installation "

  Die unter " Systemanforderungen " aufgeführten Bibliotheken sollten
  sich im Verzeichniss "Libs:" befinden. Die E-Module sollten sich
  im Verzeichniss "EModules:GTS/" befinden um den generierten
  Quelltext kompilieren zu können. Die Position des Programmes und
  der Dokumentation spielen keine Rolle.

@endnode

@node ma_starting " Starten des Programms "

  Dieses Programm läßt sich über die Workbench oder vom CLI/Shell aus 
  starten.

  Bsp.:  Das Programm befindet sich im Verzeichniss "Work:Tools/"

  CLI/Shell:      1> [run] Work:Tools/EGSG

  Workbench:      1. Fenster der Partition "Work:" öffnen.
                  2. Fenster des Verzeichnisses "Tools/" öffnen.
                  3. Piktogramm des Programmes "EGSG" zweimal
                     schnell hintereinander anwählen.

@endnode

@node ma_interface " Grafische Oberfläche "

  Hauptfenster:


  Nr.|        Schaltertext       |  HotKey  |
 ----+---------------------------+----------+
  1. |        "GUI-Datei"        | "D", "d" |
  2. |            "A"            | "A", "a" |
  3. |        "Quelltext"        | "Q", "q" |
  4. |      "Programmname"       | "N", "n" |
  5. |     "Zusatz-Module"       | "Z", "z" |
  6. |     "Einstellungen"       | "E", "e" |
  7. |   "Compiler-Optionen"     | "C", "c" |
  8. |       "Generieren"        | "G", "g" |
  9. |   "Programm beenden"      | "P", "p" |
 ----+---------------------------+----------+

  1: Texteingabefeld, in dem der Pfad der GUI-Datei eingegeben werden muß.
  2: Dieser Schalter aktiviert einen ASL-Requester mit dem es möglich
     ist, die GUI-Datei bequem auszuwählen.
  3: Texteingabefeld, in dem der Pfad des später generierten Quelltextes
     stehen muß.
  4: Texteingabefeld, in dem der Name des Programmes eingegeben wird.
  5: Hier wird ein neues Eingabefenster geöffnet. @{"   Zusatz-Module   " LINK int_addimod}
  6: Hier wird ein neues Eingabefenster geöffnet. @{"   Einstellungen   " LINK int_prefs}
  7: Hier wird ein neues Eingabefenster geöffnet. @{" Compiler-Optionen " LINK int_compiler}
  8: Mit diesem Schalter kann man den Quelltext generieren lassen,
     sofern alles korrekt eingegeben wurde.
  9: Dieser Schalter erlaubt das Verlassen des Programmes. 

@endnode

@node int_addimod " Zusätzliche Module "

  Nr.|        Schaltertext       |  HotKey  |
 ----+---------------------------+----------+
  1. |    "Zusätzliche Module"   |    -     |
  2. |        <ohne Text>        |    -     |
  3. |            "M"            | "M", "m" |
  4. |       "Hinzufügen"        | "H", "h" |
  5. |        "Löschen"          | "L", "l" |
  6. |       "Speichern"         | "S", "s" |
  7. |         "Fertig"          | "F", "f" |
 ----+---------------------------+----------+

  1: Liste, die die Modulenamen enthält.
  2: Texteingabefeld, in dem ein Modulename eingegeben werden kann.
  3: Es wird ein ASL-Requester gestartet, der es erlaubt eine
     oder mehrere (gleichzeitig) E-Module auszuwählen, die dann
     sofort in die Liste aufgenommen werden.
  4: Der Eintrag unter Nr. 2 wird, falls vorhanden, in die Liste
     eingetragen.
  5: Der Eintrag unter Nr. 2 wird, falls vorhanden, aus der Liste
     entfernt.
  6: Alle Module werden in der Konfigurationsdatei "s:egsg.cfg"
     gespeichert.
  7: Das Fenster wird geschlossen (ESCAPE ist auch möglich). 


@endnode

@node int_prefs " Einstellungen "

  Nr.|        Schaltertext       |  HotKey  |
 ----+---------------------------+----------+
  1. |     "Name des Autors"     | "N", "n" |
  2. |         "Version"         | "V", "v" |
  3. |       "Kommentare"        | "K", "k" |
  4. | "Groß- = Kleinschreibung" | "G", "g" |
  5. |        "Speichern"        | "S", "s" |
  6. |          "Fertig"         | "F", "f" |
 ----+---------------------------+----------+

  1: Texteingabefeld, in dem der Name des Autoren eingeben werden kann.
  2: Versionsnummer, die die Programme erhalten.
  3: Ist das Häkchen sichtbar, werden Kommentare in den Quelltext
     geschrieben.
  4: Ist das Häkchen sichtbar, behandelt die HotKey-Methode im
     generierten Quelltext ein "A" genauso wie ein "a".
  5: Die Einstellungen werden in der Datei "s:egsg.cfg" gespeichert.
  6: Das Fenster wird geschlossen (ESCAPE ist auch möglich).

@endnode

@node int_compiler " Compiler-Optionen "

  Nr.|        Schaltertext       |  HotKey  |
 ----+---------------------------+----------+
  1. |         "LARGE"           | "L", "l" |
  2. |         "STACK"           | "K", "k" |
  3. |          "020"            | "2"      |
  4. |          "040"            | "4"      |
  5. |          "881"            | "1"      |
  6. |          "RTD"            | "R", "r" |
  7. |          "REG"            | "E", "e" |
  8. |       "OSVERSION"         | "O", "o" |
  9. |      "PREPROCESS"         | "P", "p" |
 10. |     "OS-Nachricht"        | "N", "n" |
 11. |          "Reg"            | "G", "g" |
 12. |         "Stack"           | "T", "t" |
 13. |       "Amiga-OS"          | "A", "a" |
 14. |      "Speichern"          | "S", "s" |
 15. |        "Fertig"           | "F", "f" |
 ----+---------------------------+----------+

  1: OPT LARGE
  2: OPT STACK
  3: OPT 020    (wird vom Compiler noch nicht unterstützt)
  4: OPT 040    (wird vom Compiler noch nicht unterstützt)
  5: OPT 881    (wird vom Compiler noch nicht unterstützt)
  6: OPT RTD
  7: OPT REG
  8: OPT OSVERSION (wird nur generiert, wenn Nr. 10 deaktiviert ist)
  9: OPT PREPROCESS
 10: Ist dieser Schalter und Nr. 8 aktiviert, wird am Anfang des
     Programmes eine Abfrage der Betriebssystemversion generiert,
     die dem User verrät, daß er ein zu altes Betriebssystem benutzt.
 11: Hier kann man die Anzahl der Register zur Optimierung angeben.
     Ist natürlich nur wirksam, wenn Nr. 7 aktiviert ist.
 12: Hier gibt man die Größe des Stack-Speichers in Bytes an.
     Ist nur wirksam, wenn Nr. 2 aktiviert ist.
 13: Hier wird die minimale Betriebssystemversion festgelegt.
     Alles unter Amiga-OS 2.04 habe ich absichtlich nicht berücksichtigt.
 14: Die Einstellungen werden in der Datei "s:egsg.cfg" gespeichert.
 15: Das Fenster wird geschlossen (ESCAPE ist auch möglich).

@endnode

@node ma_future " Weiterentwicklung "

  o Möglichkeit um Texte zu schattieren.

  o Schalter vom Typen STRING_KIND mittels Hook-Strukturen zu
    modifizieren, so daß nur noch REAL-Zahlen oder spezifizierte
    Zeichen erlaubt werden.

  o Es soll ein kontextsensitives Hilfssystem integriert werden, daß
    ab Amiga OS 2.04 funktioniert.

  o Falls ich das IFF-Format von LOCALE-Katalogen herausfinden sollte,
    werde ich auch die Lokalisierung eigener Applikationen einbinden.

  ooo Momentan arbeite ich parallel an einem Oberflächengenerator
      ähnlich der GadToolsBox. Der Unterschied wird darin bestehen,
      daß die "bgui.library" ( Jaba Development ) benutzt wird.
      Der dazugehörige Quelltextgenerator wird in etwa diesem
      Programm entsprechen, aber wesentlich mehr Funktionen haben.

@endnode

@node ma_restrictions " Einschränkungen "

  1. Pro Oberfläche sind maximal 30 Fenster erlaubt.

  2. Die Projektnamen dieser Fenster (Auswahl LAMIGA-H bei
     GadToolsBox) sollten in den ersten 5 Zeichen unterschiedliche
     Buchstaben enthalten.

@endnode

@node ma_disadvantages " Vor- und Nachteile"

  Vorteile..:

    1. Zusätzliche Module können einfach per ASL-Requester
       hinzugefügt werden.

    2. Compiler-Optionen können ebenfalls per Oberfläche angegeben
       werden.

    3. Fontsensitive Oberflächen (Unabhängig von den Ausmaßen des 
       Zeichensatzes)

    4. Jedes Projektfenster entspricht einem Objekt, daß über einheitliche
       Methoden verfügt um das grafische User-Interface zu starten.


  Nachteile.:

    1. Keine kontextsensitive Hilfe integriert.

    2. Kein AREXX-Port zur Anbindung in andere Applikationen.

    3. Keine Lokalisierung.

@endnode
