@database "bitfield"
@master "Dixie:home/kyz/dev/src/mine/e/objects/doc/bitfield.doc"

@Node Main "bitfield.doc"
    @{" --overview-- " Link "--overview--"}
    @{" bit_operations() " Link "bit_operations()"}
    @{" bitfield_combine() " Link "bitfield_combine()"}
    @{" bitfield_operations() " Link "bitfield_operations()"}
    @{" end() " Link "end()"}
    @{" field_operations() " Link "field_operations()"}
    @{" field_range() " Link "field_range()"}
    @{" new() " Link "new()"}
    @{" range_errors() " Link "range_errors()"}
@EndNode

@Node "--overview--" "bitfield.m/--overview--"

@{b}   PURPOSE@{ub}
	To provide a multi-purpose bitfield.

@{b}   OVERVIEW@{ub}
	Bitfields  are a simple way of encoding a set of true/false states
	for  a  number  of integer values. Rather than use a lookup table,
	you can use a bitfield which holds 8 states per byte.

	Basically, the bitfield is a collection of individual 'bits', each
	of which is a simple boolean value, TRUE or FALSE.
	
	You  can  set,  clear,  and test individual bit and ranges of bits
	within  the bitfield. You can ask the bitfield either to ignore or
	raise  exceptions  if you step outside of it. You can also combine
	bitfields logically.

@EndNode

@Node "bit_operations()" "bitfield.m/bit_operations"

@{b}   NAME@{ub}
	bitfield.set() -- set an individual bit.
	bitfield.clear() -- clear an individual bit.
	bitfield.toggle() -- toggle an individual bit.
	bitfield.test() -- test an individual bit.

@{b}   SYNOPSIS@{ub}
	state := set(bit)
	state := clear(bit)
	state := toggle(bit)
	state := test(bit)

@{b}   FUNCTION@{ub}
	Will  test,  then perform an operation on an individual bit in the
	bitfield:

	set()    will set the bit to boolean TRUE.
	clear()  will clear the bit to boolean FALSE.
	toggle() will change a boolean FALSE bit to TRUE, and vice-versa.
	test()   will perform no altering operation on the bit.

	If  the bit specified is outwith the range stored by the bitfield,
	a range error will occur.

@{b}   INPUTS@{ub}
	bit   - the bit to perform an operation on.

@{b}   RESULT@{ub}
	state - the  previous  state  of  the bit before the operation was
	        performed on it, either TRUE or FALSE.

@{b}   SEE ALSO@{ub}
	@{"bitfield_operations()" Link "bitfield_operations()"}, @{"range_errors()" Link "range_errors()"}

@EndNode

@Node "bitfield_combine()" "bitfield.m/bitfield_combine"

@{b}   NAME@{ub}
	bitfield.copy() -- copy from another bitfield.
	bitfield.and() -- mask bitfield with another.
	bitfield.or() -- overlay from another bitfield.
	bitfield.xor() -- perform exclusive-or combine of bitfield.

@{b}   SYNOPSIS@{ub}
	bitfield.copy(bitfield2)
	bitfield.and(bitfield2)
	bitfield.or(bitfield2)
	bitfield.xor(bitfield2)

@{b}   FUNCTION@{ub}
	Will  perform  a  logical operation on the bitfield using the data
	held in another bitfield.

	Currently,  both  bitfields  must be exactly the same size as each
	other, or a range error will occur.

	b1.copy(b2) will perform  b1 := b2
	b1.and(b2)  will perform  b1 := b1 AND b2
	b1.or(b2)   will perform  b1 := b1 OR b2
	b1.xor(b2)  will perform  b1 := b1 XOR b2

	If  the  bitfield  specified  falls  in  any way outwith the range
	stored by the bitfield, a range error will occur.

@{b}   INPUTS@{ub}
	bitfield2 - pointer to another instance of the bitfield class.

@{b}   RESULT@{ub}
	Always returns TRUE, except if a range error occurs, in which case
	it will return FALSE.

@{b}   SEE ALSO@{ub}
	@{"range_errors()" Link "range_errors()"}

@EndNode

@Node "bitfield_operations()" "bitfield.m/bitfield_operations"

@{b}   NAME@{ub}
	bitfield.bf_set() -- set a range of bits.
	bitfield.bf_clear() -- clear a range of bits.
	bitfield.bf_invert() -- invert a range of bits.
	bitfield.bf_test() -- test a range of bit.

@{b}   SYNOPSIS@{ub}
	andstate, orstate := bf_set(leftbit, rightbit)
	andstate, orstate := bf_clear(leftbit, rightbit)
	andstate, orstate := bf_invert(leftbit, rightbit)
	andstate, orstate := bf_test(leftbit, rightbit)

@{b}   FUNCTION@{ub}
	Will  test all of, then perform an operation on a range of bits in
	the bitfield:

	bf_set()    will set all affected bits to boolean TRUE.
	bf_clear()  will clear all affected bits to boolean FALSE.
	bf_invert() will change boolean FALSE bits to TRUE, and vice-versa.
	bf_test()   will perform no altering operation on the bits.

	If  the  bitfield  specified  falls  in  any way outwith the range
	stored by the bitfield, a range error will occur.

@{b}   INPUTS@{ub}
	leftbit, rightbit - the  bits you  want to affect, from leftbit to
	                    rightbit  (inclusive).  left and right will be
	                    swapped automatically if right < left.

@{b}   RESULT@{ub}
	andstate - an  AND-based  combination  of  the  states  of all the
	           affected bits before any changes were made.

	           If ALL of the bits were TRUE, the andstate is TRUE
	           If any of the bits were FALSE, the andstate is FALSE.

	orstate  - an  OR-based  combination  of  the  states  of  all the
	           affected bits before any changes were made.

	           If ANY of the bits were TRUE, the orstate is TRUE
	           If all of the bits were FALSE, the orstate is FALSE.

@{b}   SEE ALSO@{ub}
	@{"bit_operations()" Link "bit_operations()"}, @{"range_errors()" Link "range_errors()"}

@EndNode

@Node "end()" "bitfield.m/end"

@{b}   NAME@{ub}
	bitfield.end() -- Destructor.

@{b}   SYNOPSIS@{ub}
	end()

@{b}   FUNCTION@{ub}
	Frees resources used by an instance of the bitfield class.

@{b}   SEE ALSO@{ub}
	@{"new()" Link "new()"}

@EndNode

@Node "field_operations()" "bitfield.m/field_operations"

@{b}   NAME@{ub}
	bitfield.setfield() -- set all bits.
	bitfield.clearfield() -- clear all bits.
	bitfield.invert() -- invert all bits.

@{b}   SYNOPSIS@{ub}
	setfield()
	clearfield()
	invert()

@{b}   FUNCTION@{ub}
	setfield() sets all bits in the bitfield to boolean TRUE.
	clearfield() clears all bits in the bitfield to boolean FALSE.
	invert() switches all bits to their opposite boolean value.

	These  functions are more optimised than using the ranged bitfield
	operations over the entire range.

@{b}   SEE ALSO@{ub}
	@{"bitfield_operations()" Link "bitfield_operations()"}

@EndNode

@Node "field_range()" "bitfield.m/field_range"

@{b}   NAME@{ub}
	bitfield.range() -- report range of representable integers.

@{b}   SYNOPSIS@{ub}
	min, max := range()

@{b}   FUNCTION@{ub}
	Returns  the  minimum  and  maximum  represented  integers in this
	instance, as defined in the construction.

@{b}   RESULT@{ub}
	min - the minimum representable integer in this bitfield.
	max - the maximum representable integer in this bitfield.

@{b}   SEE ALSO@{ub}
	@{"new()" Link "new()"}

@EndNode

@Node "new()" "bitfield.m/new"

@{b}   NAME@{ub}
	bitfield.new() -- Constructor.

@{b}   SYNOPSIS@{ub}
	new(min, max)
	new(min, max, range)

@{b}   FUNCTION@{ub}
	Initialises  an  instance  of the bitfield class. Raises exception
	"MEM"  if it cannot allocate enough memory for the required number
	of bits. All bits are initially cleared.

@{b}   INPUT@{ub}
	min   - the  minimum integer value that will be represented in the
	        field. This can be negative.

	max   - the  maximum integer value that will be represented in the
	        field.  This  can  also  be negative, and can also be less
	        than min (the values will be swapped if they are).

	range - whether range errors are fatal or not. See @{"range_errors()" Link "range_errors()"}.
	        The default for this argument is FALSE.

@{b}   SEE ALSO@{ub}
	@{"end()" Link "end()"}, range(), @{"range_errors()" Link "range_errors()"}

@EndNode

@Node "range_errors()" "bitfield.m/range_errors"

@{b}   NAME@{ub}
	bitfield.range_errors() -- define range error handling.

@{b}   SYNOPSIS@{ub}
	oldstate := range_errors(newstate)

@{b}   FUNCTION@{ub}
	Defines  the  handling  of  range errors with this instance of the
	bitfield.

	A  range  error  occurs  when  you  try  an  operation that cannot
	logically  perform  its  function  with  the  parameters  you have
	specified. For example, trying to toggle a bit that is outside the
	range of the bitfield, or trying to combine two bitfields that are
	not the same size.

	When  a range error occurs, what happens next depends on the state
	of  the range_errors flag for the bitfield instance, as set in the
	construction, or at runtime with this function.

	If  range_errors  =  FALSE,  NO  OPERATION  WILL  OCCUR,  and  the
	operation will immediately return FALSE.

	If range_errors = TRUE, NO OPERATION WILL OCCUR, and the operation
	will throw the exception "rnge".

	It is essential to realise that NO operation happens when there is
	a  range  error. range_errors=FALSE does NOT mean that 'errors are
	ignored'. It means that 'errors do not throw an exception'.

	An  analogy  is  that  range_errors=TRUE  makes  errors  'loud' or
	'fatal'.

@{b}   INPUTS@{ub}
	newstate - a TRUE or FALSE value to set the range_errors flag.

@{b}   RESULT@{ub}
	oldstate - the previous value of range_errors flag.

@{b}   SEE ALSO@{ub}
	@{"new()" Link "new()"}, range(), @{"bitfield_operations()" Link "bitfield_operations()"}, @{"bit_operations()" Link "bit_operations()"},
	@{"bitfield_combine()" Link "bitfield_combine()"}

@EndNode

