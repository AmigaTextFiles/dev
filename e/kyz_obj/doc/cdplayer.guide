@database "cdplayer"
@master "Dixie:home/kyz/dev/src/mine/e/objects/doc/cdplayer.doc"

@Node Main "cdplayer.doc"
    @{" --overview-- " Link "--overview--"}
    @{" currenttrack() " Link "currenttrack()"}
    @{" discchanged() " Link "discchanged()"}
    @{" discinserted() " Link "discinserted()"}
    @{" eject() " Link "eject()"}
    @{" ejected() " Link "ejected()"}
    @{" end() " Link "end()"}
    @{" insert() " Link "insert()"}
    @{" length() " Link "length()"}
    @{" location() " Link "location()"}
    @{" maketime() " Link "maketime()"}
    @{" open() " Link "open()"}
    @{" pause() " Link "pause()"}
    @{" paused() " Link "paused()"}
    @{" play() " Link "play()"}
    @{" playing() " Link "playing()"}
    @{" search() " Link "search()"}
    @{" spindown() " Link "spindown()"}
    @{" spinning() " Link "spinning()"}
    @{" spinup() " Link "spinup()"}
    @{" stop() " Link "stop()"}
    @{" timeval() " Link "timeval()"}
    @{" trackinfo() " Link "trackinfo()"}
    @{" tracks() " Link "tracks()"}
    @{" unpause() " Link "unpause()"}
    @{" waitfordisc() " Link "waitfordisc()"}
@EndNode

@Node "--overview--" "cdplayer.m/--overview--"
 
@{b}   PURPOSE@{ub}
	To provide an interface to the cd.device for playing Audio CDs.
 
@{b}   OVERVIEW@{ub}
	This  object  simulates the high-level idea of 'CD Controls', such
	as  @{"play()" Link "play()"},  @{"pause()" Link "pause()"}, @{"stop()" Link "stop()"} and so on. It also allows querying of
	the  CD  drive, such as whether the door is open or if the disc is
	spinning.
	
	Audio  play  is,  of  course,  asynchronous,  and the audio can be
	manipulated while play is in progress.

	Construction and destruction:
	  @{"open()" Link "open()"}, @{"end()" Link "end()"}
	
	CD Controls:
	  @{"play()" Link "play()"}, @{"stop()" Link "stop()"}, @{"search()" Link "search()"}

	CD State controls:
	  @{"pause()" Link "pause()"}, @{"unpause()" Link "unpause()"}, @{"paused()" Link "paused()"} - pause control
	  @{"eject()" Link "eject()"}, @{"insert()" Link "insert()"}, @{"ejected()" Link "ejected()"} - door control
	  @{"spinup()" Link "spinup()"}, @{"spindown()" Link "spindown()"}, @{"spinning()" Link "spinning()"} - motor control
	  @{"playing()" Link "playing()"}, @{"location()" Link "location()"}

	Disc information:
	  @{"discchanged()" Link "discchanged()"}, @{"discinserted()" Link "discinserted()"}, @{"waitfordisc()" Link "waitfordisc()"}

	Track information:
	  @{"length()" Link "length()"}, @{"tracks()" Link "tracks()"}, @{"trackinfo()" Link "trackinfo()"}, @{"currenttrack()" Link "currenttrack()"}

	Timing specifications

	    Audio CDs are marked in minutes, seconds and frames. There are
	    75 frames in a second, and 60 seconds in a minute.
	
	    To work with Audio CDs, there must be some way of representing
	    a  time  values.  Time values are used to specify positions on
	    the  CD,  offsets  from the beginning of the CD or tracks, the
	    length of tracks, the total time on the CD, amounts of time to
	    be played, and so on.
	
	    There  are two standard ways to represent time values for CDs.
	    One  is  called  'LSN  format',  where LSN stands for 'Logical
	    Sector  Numbers'.  LSN  format  is  basically a mass number of
	    frames,  where  a  minute  is  4500 frames, and a second is 75
	    frames.  The  advantage  of  this  format is that times can be
	    worked  with  like  normal numbers. You can add them, subtract
	    them and compare them with normal number math.
	
	    The  other standard time representation is 'MSF format', where
	    MSF  stands  for  'Minutes,  Seconds,  Frames'. Just as an LSN
	    value  is  an unsigned 32-bit LONG value, so is an MSF value -
	    but  each  byte  of  the  LONG is used individually to store a
	    minute  count,  second  count,  and  a  frame  count. The most
	    significant  byte is unused, the next most significant byte is
	    a number from 0 to 255 representing the number of minutes, the
	    next  byte is a number from 0 to 59 representing the number of
	    seconds,  and  the least significant byte holds a value from -
	    to 74 containing a number of frames.
	
	    A  fair  analogy for MSF format would be the well known Binary
	    Coded  Decimal  (BCD) format supported by most processors. The
	    numbers   cannot  be  added  or  manipulated  without  special
	    instructions,  and  'invalid'  values  are  possible,  but the
	    values  themselves  are  more  readable  and 'splittable' than
	    normal integers.
	
	    Before an argument breaks out, it must be said that this class
	    always  uses  LSN format time values - in all instances. It is
	    far  more  practical  to  do  so  than  to support MSF format.
	    However,  there are two functions to provide the functionality
	    inherent  in  the MSF format. @{"maketime()" Link "maketime()"} will take a number of
	    minutes,  seconds  and frames, and create an LSN format number
	    from  them.  @{"timeval()" Link "timeval()"}  will  take  an  LSN format number, and
	    return a number of minutes, seconds and frames.

	    The unit of time value measurement is referred to as 'frames'.
	
	Error handling

	    When  the  functions of the cdplayer object mention 'failure',
	    'errors'  and  so  on,  they  refer to logical errors that the
	    functions specifically expect and report. However, they do not
	    expect  I/O  errors  with  the  CD  device.  If  the CD device
	    returns an errors, the exception CDPERR_DEVICE will be thrown,
	    and the device error will be in exceptioninfo. In their normal
	    operation,  the  functions  do  not cause or expect any device
	    errors. However, events beyond their control can cause them.
	    In practise, it is very difficult to cause them.

@EndNode

@Node "currenttrack()" "cdplayer.m/currenttrack"

@{b}   NAME@{ub}
       cdplayer.currenttrack() -- report track being played.

@{b}   SYNOPSIS@{ub}
       track := currenttrack()

@{b}   FUNCTION@{ub}
	Returns  the  latest known currently playing track. The CD must be
	playing, but it does not matter if play is paused or searching.

@{b}   RESULT@{ub}
	track - CDTRACK_INVALID  if  the  CD is not playing, otherwise the
	        track number.

@{b}   SEE ALSO@{ub}
       @{"play()" Link "play()"}, @{"playing()" Link "playing()"}, @{"location()" Link "location()"}

@EndNode

@Node "discchanged()" "cdplayer.m/discchanged"

@{b}   NAME@{ub}
	cdplayer.discchanged() -- report if disc has been changed.

@{b}   SYNOPSIS@{ub}
	changed := discchanged()

@{b}   FUNCTION@{ub}
	This function returns TRUE if the disc in the CD drive has changed
	since  you last called this function. To help you, the function is
	called  automatically  on  your  behalf  when you first create the
	cdplayer object.

@{b}   RESULT@{ub}
	changed - TRUE if the disc in the CD drive has changed since this
	          function was last called, FALSE otherwise.

@{b}   NOTE@{ub}
	A disc change does not imply that there is a disc in the drive!

@{b}   SEE ALSO@{ub}
	@{"discinserted()" Link "discinserted()"}, @{"waitfordisc()" Link "waitfordisc()"}

@EndNode

@Node "discinserted()" "cdplayer.m/discinserted"

@{b}   NAME@{ub}
	cdplayer.discinserted() -- report if a disc is in the drive.

@{b}   SYNOPSIS@{ub}
	inserted := discinserted()

@{b}   FUNCTION@{ub}
	Reports if a readable disc is ready and in the CD drive.

@{b}   RESULT@{ub}
	inserted - TRUE if a disc is inserted, FALSE otherwise.

@{b}   NOTE@{ub}
	Discs  may  be  removed at any time, even just after this call has
	returned TRUE! A TRUE result from this function is no guarantee of
	permanent disc availability.

@{b}   SEE ALSO@{ub}
	@{"discchanged()" Link "discchanged()"}, @{"waitfordisc()" Link "waitfordisc()"}

@EndNode

@Node "eject()" "cdplayer.m/eject"

@{b}   NAME@{ub}
	cdplayer.eject() -- open the CD drawer/door.

@{b}   SYNOPSIS@{ub}
	eject()

@{b}   FUNCTION@{ub}
	Requests the CD drive to open its drawer or door.

@{b}   NOTE@{ub}
	You  must have a CD drive with a motorized drawer or door for this
       call to work. The CD³² drive throws IO error CDERR_NOCMD.

@{b}   SEE ALSO@{ub}
	@{"insert()" Link "insert()"}, @{"ejected()" Link "ejected()"}

@EndNode

@Node "ejected()" "cdplayer.m/ejected"

@{b}   NAME@{ub}
	cdplayer.ejected() -- report if CD drawer/door is open.

@{b}   SYNOPSIS@{ub}
	door_open := ejected()

@{b}   FUNCTION@{ub}
	Reports the current state of the CD drawer or door.

@{b}   RESULT@{ub}
	Returns TRUE if the door is open, FALSE otherwise.

@{b}   NOTE@{ub}
	Cartridge-based CD drives do not normally report being 'open'.

@{b}   SEE ALSO@{ub}
	@{"eject()" Link "eject()"}, @{"insert()" Link "insert()"}

@EndNode

@Node "end()" "cdplayer.m/end"

@{b}   NAME@{ub}
	cdplayer.end() -- Destructor.

@{b}   SYNOPSIS@{ub}
	end()

@{b}   FUNCTION@{ub}
	Frees resources used by an instance of the cdplayer class.

@{b}   SEE ALSO@{ub}
	new()

@EndNode

@Node "insert()" "cdplayer.m/insert"

@{b}   NAME@{ub}
	cdplayer.insert() -- close the CD drawer/door.

@{b}   SYNOPSIS@{ub}
	insert()

@{b}   FUNCTION@{ub}
	Requests the CD drive to close its drawer or door.

@{b}   NOTE@{ub}
	You  must have a CD drive with a motorized drawer or door for this
       call to work. The CD³² drive throws IO error CDERR_NOCMD.

@{b}   SEE ALSO@{ub}
	@{"eject()" Link "eject()"}, @{"ejected()" Link "ejected()"}

@EndNode

@Node "length()" "cdplayer.m/length"

@{b}   NAME@{ub}
	cdplayer.length() -- report the running time for the CD.

@{b}   SYNOPSIS@{ub}
	length := length()

@{b}   FUNCTION@{ub}
	Returns the length in time of the CD currently inserted.

@{b}   RESULT@{ub}
	length - A time value in frames, or CDTIME_INVALID in error.

@{b}   SEE ALSO@{ub}
	@{"tracks()" Link "tracks()"}

@EndNode

@Node "location()" "cdplayer.m/location"

@{b}   NAME@{ub}
       cdplayer.location() -- report current location of laser on the CD.

@{b}   SYNOPSIS@{ub}
       position := location()

@{b}   FUNCTION@{ub}
	Returns  the  latest known position of play on the CD. The CD must
	be playing, but it does not matter if play is paused or searching.

@{b}   RESULT@{ub}
	position - CDTIME_INVALID  if  the  CD is not playing, otherwise a
	           time offset in frames from the start of the disc.

@{b}   SEE ALSO@{ub}
       @{"play()" Link "play()"}, @{"playing()" Link "playing()"}, @{"currenttrack()" Link "currenttrack()"}

@EndNode

@Node "maketime()" "cdplayer.m/maketime"

@{b}   NAME@{ub}
	maketime() -- Create an LSN time value.

@{b}   SYNOPSIS@{ub}
	time := maketime()
	time := maketime(minutes)
	time := maketime(minutes, seconds)
	time := maketime(minutes, seconds, frames)

@{b}   FUNCTION@{ub}
	Creates an LSN time value from the 3 component parts, for use with
	the  cdplayer class. Any component part you do not specify will be
	assumed to be zero.

@{b}   INPUTS@{ub}
	minutes - A number of minutes of time
	seconds - A number of seconds of time
	frames  - A number of frames (1/75 s) of time

	Parameters you do not specify will be assumed to be zero.
	
@{b}   RESULT@{ub}
	time - a  time  value  in a suitable form for adding, subtracting,
	       comparing, and passing to cdplayer functions.

@{b}   NOTE@{ub}
	This is not a member function of the cdplayer class.

@{b}   SEE ALSO@{ub}
	@{"timeval()" Link "timeval()"}
	
@EndNode

@Node "open()" "cdplayer.m/open"

@{b}   NAME@{ub}
	cdplayer.open() -- Constructor.

@{b}   SYNOPSIS@{ub}
	open()
	open(device)
	open(device, unit)

@{b}   FUNCTION@{ub}
	Initialises  an  instance  of the cdplayer class. Raises exception
	CDPERR_INIT if it cannot allocate required memory and resources.

	By  default, this opens "cd.device" unit 0. You can change this by
	passing  an  alternate  device name. Similarly, you can provide an
	alternate  unit  to  open. This option should be made available to
	the user if at all possible. Note that the device opened *must* be
	compatible  to  the  cd.device  interface  -  scsi.device  is  not
	acceptable,  even  though  many  CD-ROMs  are  controlled with the
	scsi.device, in that case they must be sent SCSI commands.

	If  opening the device fails, CDPERR_OPENDEV will be thrown, along
	with the OpenDevice() error code.

@{b}   INPUTS@{ub}
	device - device to be opened, default is 'cd.device'
	unit   - unit of device to be opened, default is 0.
   
@{b}   SEE ALSO@{ub}
	@{"end()" Link "end()"}

@EndNode

@Node "pause()" "cdplayer.m/pause"

@{b}   NAME@{ub}
       cdplayer.pause() -- put CD player in pause mode.

@{b}   SYNOPSIS@{ub}
       pause()

@{b}   FUNCTION@{ub}
       If the CD player is currently playing, it will be paused. If it is
       not playing, it will pause when the next @{"play()" Link "play()"} is issued.

@{b}   SEE ALSO@{ub}
       @{"unpause()" Link "unpause()"}, @{"paused()" Link "paused()"}

@EndNode

@Node "paused()" "cdplayer.m/paused"

@{b}   NAME@{ub}
       cdplayer.paused() -- report if CD player is paused.

@{b}   SYNOPSIS@{ub}
       paused := paused()

@{b}   FUNCTION@{ub}
       Returns the state of the 'pause button' in the CD player.

@{b}   RESULT@{ub}
       Returns TRUE if in pause mode, otherwise FALSE.

@{b}   SEE ALSO@{ub}
@{b}     @{"pause()" Link "pause()"}, unpause()@{ub}

@EndNode

@Node "play()" "cdplayer.m/play"

@{b}   NAME@{ub}
	cdplayer.play() -- play audio on the CD.

@{b}   SYNOPSIS@{ub}
	playing := play(offset, length)

@{b}   FUNCTION@{ub}
	Attempts to start playing a specified area of the CD.

	If  any  previous play request is still running, it is immediately
	stopped, regardless of whether this new request succeeds.

	There  must  be  a  valid CD in the drive, and the area you select
	must  be  within  the  bounds  of  the disc, otherwise an error is
	returned.  Similarly,  failure occurs if the CD drive reports that
	the disc is currently playing, but it is not us who is playing it.

	If  successful, a CD play request will be issued, and the CD drive
	should  begin asynchronously playing the specified audio area. Any
	errors with the CD drive playing will not be reported.

	Play continues until one of the following occurs:
	- play reaches the end of the selected area.
	- you @{"stop()" Link "stop()"} the CD, or play() a new area.
	- you @{"eject()" Link "eject()"} the CD, or the user ejects it himself.
	- you @{"search()" Link "search()"} backwards to a point before play started.

@{b}   INPUTS@{ub}
	offset - the  location  on  the  CD  from  which you want to start
	         playing.

	length - the  duration  for  which  the play should last. The area
	         played  is therefore from (offset) to (offset+length).

@{b}   RESULT@{ub}
	playing - TRUE if succeeded, FALSE for failure

@{b}   NOTE@{ub}
	You are not currently prohibited from playing data tracks, which
	sound rather unpleasent. This may change in future.

@{b}   SEE ALSO@{ub}
	@{"stop()" Link "stop()"}, @{"pause()" Link "pause()"}, @{"search()" Link "search()"}, @{"playing()" Link "playing()"}

@EndNode

@Node "playing()" "cdplayer.m/playing"

@{b}   NAME@{ub}
	cdplayer.playing() -- report if we are playing the CD.

@{b}   SYNOPSIS@{ub}
	playing := playing()

@{b}   FUNCTION@{ub}
	Reports  on  whether  or  not there is a play request in progress.
	That is, whether or not we are playing the CD.

@{b}   RESULT@{ub}
	playing - TRUE if play is in progress, FALSE otherwise.

@{b}   SEE ALSO@{ub}
	@{"play()" Link "play()"}, @{"stop()" Link "stop()"}

@EndNode

@Node "search()" "cdplayer.m/search"

@{b}   NAME@{ub}
	cdplayer.search() -- search CD in 'scan mode' while playing.

@{b}   SYNOPSIS@{ub}
	oldmode := search(mode)

@{b}   FUNCTION@{ub}
	Allows  a  playing  CD to play in 'fast forward' or 'fast reverse'
	modes.  If,  in  these modes, the position of play goes beyond the
	boundaries selected in the original call to @{"play()" Link "play()"}, then play will
	finish.  If  play is currently @{"paused()" Link "paused()"}, the search mode will take
	effect when the play is unpaused().

@{b}   INPUTS@{ub}
	mode - one of the following modes:
	       CDSEARCH_STOP - turn off search mode
	       CDSEARCH_FWD  - enter 'fast forward' mode
	       CDSEARCH_BACK - enter 'fast reverse' mode

@{b}   RESULT@{ub}
	oldmode - the previous state - one of the above 3 modes.

@{b}   SEE ALSO@{ub}
	@{"play()" Link "play()"}

@EndNode

@Node "spindown()" "cdplayer.m/spindown"

@{b}   NAME@{ub}
	cdplayer.spindown() -- turn the CD motor off.

@{b}   SYNOPSIS@{ub}
	spindown()

@{b}   FUNCTION@{ub}
	Turns  the CD motor off. If the CD player is currently playing, it
	will stop until the motor is turned back on again.

@{b}   SEE ALSO@{ub}
	@{"spinup()" Link "spinup()"}, @{"spinning()" Link "spinning()"}

@EndNode

@Node "spinning()" "cdplayer.m/spinning"

@{b}   NAME@{ub}
	cdplayer.spinning() -- report if CD motor is running.

@{b}   SYNOPSIS@{ub}
	spinning := spinning()

@{b}   FUNCTION@{ub}
	Reports the current state of the CD motor.

@{b}   RESULT@{ub}
	Returns TRUE if the motor is spinning, FALSE otherwise.

@{b}   SEE ALSO@{ub}
	@{"spinup()" Link "spinup()"}, @{"spindown()" Link "spindown()"}

@EndNode

@Node "spinup()" "cdplayer.m/spinup"

@{b}   NAME@{ub}
	cdplayer.spinup() -- turn the CD motor on.

@{b}   SYNOPSIS@{ub}
	spinup()

@{b}   FUNCTION@{ub}
	Turns the CD motor on. If the CD player was playing when the
	motor was spun down, it will continue where it left off.

@{b}   NOTE@{ub}
	The CD motor automatically turns itself on if it recieves any
	request to read data/audio from the drive while it is off.

@{b}   SEE ALSO@{ub}
	@{"spindown()" Link "spindown()"}, @{"spinning()" Link "spinning()"}

@EndNode

@Node "stop()" "cdplayer.m/stop"

@{b}   NAME@{ub}
	cdplayer.stop() -- stop any currently running play request.

@{b}   SYNOPSIS@{ub}
	stop()

@{b}   FUNCTION@{ub}
	Stops playing the CD.

@{b}   SEE ALSO@{ub}
	@{"play()" Link "play()"}, @{"pause()" Link "pause()"}

@EndNode

@Node "timeval()" "cdplayer.m/timeval"

@{b}   NAME@{ub}
	timeval() -- Break an LSN time value into its component parts.

@{b}   SYNOPSIS@{ub}
	minutes, seconds, frames := timeval(time)
	
@{b}   FUNCTION@{ub}
	Breaks an integral LSN time value into a number of minutes,
	seconds and frames (1/75 s).
	
@{b}   INPUTS@{ub}
	time - an LSN time value that you have calculated or recieved from
	       a function in the cdplayer class. For correct operation, it
	       should  range  between  0 and about 80*60*75 (the '80' is a
	       nominal  value  for the maximum number of minutes likely to
	       be represented on a CD.
	
@{b}   RESULT@{ub}
	minutes - the number of whole minutes in the time (from 0 to 80)
	seconds - the number of whole seconds in the time (from 0 to 59)
	frames  - the number of frames left (from 0 to 75)
	
@{b}   NOTE@{ub}
	This is not a member function of the cdplayer class.

@{b}   SEE ALSO@{ub}
	@{"maketime()" Link "maketime()"}

@EndNode

@Node "trackinfo()" "cdplayer.m/trackinfo"

@{b}   NAME@{ub}
	cdplayer.trackinfo() -- retrieve information about a track.

@{b}   SYNOPSIS@{ub}
	type, offset, length := trackinfo(track)

@{b}   FUNCTION@{ub}
	Retrieves  information  from  the  table  of  contents  (TOC)  the
	requested track on the CD in the drive. This data is simplified to
	just 'track type', position on the disc, and running time.

@{b}   INPUTS@{ub}
	track - the  track to get information about. Must be between 1 and
	        @{"tracks()" Link "tracks()"}, otherwise an error will occur.

@{b}   RESULT@{ub}
	type   - Will be one of the following three types:

	         CDTRACK_INVALID:
	         An  error has occured. For example, there may be no valid
	         disc  in  the  drive, or the track you requested does not
	         exist. In this case, the other results returned will also
	         be invalid.

	         CDTRACK_DATA:
	         The track is certainly valid, however you should not play
	         it as it is actually CD-ROM data, not an audio track.

	         CDTRACK_AUDIO:
	         The track is both valid and playable.

	offset - The position in frames where the track begins on the CD.

	length - The running time of the track, in frames.

@{b}   SEE ALSO@{ub}
	@{"tracks()" Link "tracks()"}, @{"play()" Link "play()"}

@EndNode

@Node "tracks()" "cdplayer.m/tracks"

@{b}   NAME@{ub}
	cdplayer.tracks() -- report the number of tracks on the CD.

@{b}   SYNOPSIS@{ub}
	tracks := tracks()

@{b}   FUNCTION@{ub}
	Returns  the  total number of tracks on the CD. The result is also
	the track number of the last track (the first track is always 1).

@{b}   RESULT@{ub}
	tracks - the number of tracks, or CDTRACK_INVALID in error.

@{b}   SEE ALSO@{ub}
	@{"length()" Link "length()"}

@EndNode

@Node "unpause()" "cdplayer.m/unpause"

@{b}   NAME@{ub}
       cdplayer.unpause() -- take CD player out of pause mode.

@{b}   SYNOPSIS@{ub}
       unpause()

@{b}   FUNCTION@{ub}
       If the CD player is currently playing, it will be paused. If it is
       not playing, it will pause when the next @{"play()" Link "play()"} is issued.

@{b}   SEE ALSO@{ub}
@{b}     @{"pause()" Link "pause()"}, paused()@{ub}

@EndNode

@Node "waitfordisc()" "cdplayer.m/waitfordisc"

@{b}   NAME@{ub}
	cdplayer.waitfordisc() -- efficiently wait for a disc to be ready.

@{b}   SYNOPSIS@{ub}
	waitfordisc()

@{b}   FUNCTION@{ub}
	Will  wait indefinately until a readable disc is inserted into the
	drive. A more efficent form of "REPEAT UNTIL discinserted()".

@{b}   SEE ALSO@{ub}
	@{"discinserted()" Link "discinserted()"}

@EndNode

