@database 000df4c0-3
@master 
@index Main
@remark Created with Heddley v1.0 (c) Edd Dumbill 1994

@node "Main" "0. Einleitung"
    Wichtiger Hinweis und Copyright
    -------------------------------

    Dieser Workshop basiert auf meinen eigenen Erfahrungen mit Modulen.
    D.h., es gibt sicherlich noch effektivere Methoden der Program-
    mierung mit Modulen und jeder ist selbst aufgefordert, etwas mehr
    als bloßes abtippen zu tun.

    Verbesserungswünsche, Fehlermeldungen etc. werden selbstverständ-
    lich gerne entgegengenommen.

    Und für schwache Typen und sonstige Chaoten:

        DIESER TEXT IST © 1994 bei Jörg Wach.

        Der Text als ganzes oder als Teil darf ohne meine SCHRIFTLICHE
        Einwilligung weder in anderen Disketten- oder CDROM-Serien
        übernommen werden, ausgenommen die EPD.

        Ein Abdruck des Workshops in Zeitschriften oder anderen Medien
        Bedarf EBENFALLS meiner schriftlichen Genehmigung.

    .--------------------.
    | Inhaltsverzeichnis |
    `--------------------'

     @{"1.  Einleitung" link "Document_0" 0}

     @{"2.  Module, was'n das?" link "Document_1" 0}
     @{"2.1 Module für Library-Informationen" link "Document_2" 0}
     @{"2.2 Datenstrukturen, Konstanten" link "Document_3" 0}
     @{"2.3 Module unter EC3.0" link "Document_4" 0}

     @{"3.0 Unser erstes, eigenes Modul - Was soll es können?" link "Document_5" 0}
     @{"3.1 Was brauchen wir den alles?" link "Document_6" 0}
     @{"3.2 Es geht los ....." link "Document_7" 0}

     @{"4.  Erzeugen eines Modules mit EC" link "Document_8" 0}
     @{"5.  Test des Modules" link "Document_9" 0}
     @{"6.  Was mann noch alles machen könnte ...." link "Document_10" 0}
     @{"7.  Schlußwort " link "Document_11" 0} 
@endnode

@node "Document_0" "1. Einleitung"
1.  Einleitung

    Dieser Workshop soll die Benutzung des neuen Modulkonzeptes unter
    Amiga_E ab Version EC3.0 aufzeigen.

    Neben enigen allgemeinen Informationen wird anhand eines prakti-
    schen Problemes sowohl die Erstellung von eigenen Modulen, deren
    Optimierung und deren Benutzung in eigenen Programmen demonstriert.

    Gleichzeitig werden auch noch einige Informationen über die Rück-
    gabe von mehreren Informationen aus PROC's aufgezeigt sowie die
    praktische Benutzung von Amiga-Datenstrukturen.

    Das Workshop-Module sowie alle hierin angesprochenen Programme sind
    mit auf der Diskette vorhanden.

    Tja, was soll ich jetzt noch sagen? Einfach: let's go ......  
@endnode

@node "Document_1" "2.0 Module, was'n das ??? "
2.  Module, was'n das?

    Mit dem gelieferten Amiga_E-Packet habt ihr eine Menge sogenannter
    .m-Files geliefert bekommen, nur was sind das?

    In diesen sogenannten Modulen sind in der älteren Version des
    Amiga_E-Compilers (EC2.1, EC2.1b) Informationen über Libraries
    und Datenstrukturen enthalten.

    Definitionen zu den Datenstrukturen des Amiga-Systems sind für die
    Programmierung von Routinen, die Systemfunktionen benutzen, eminent
    wichtig. Ohne diese Strukturen ist jeder gezwungen, die für System-
    aufrufe benötigten Datenstrukturen und Werte selber zu definieren.

    Das bedeutet aber eine Menge Aufwand und wer kann sich denn schon
    ca. 5000 Datenstrukturen und Strukturwerte im Kopf merken?

    Zu unterscheiden sind die Daten in Library-Informationen, Daten-
    strukturen und Konstanten.  
@endnode

@node "Document_2" "2.1 Module für Library-Informationen "
2.1 Module für Library-Informationen

    Dazu ein Beispiel des Modules "mathffp.m" aus dem "Modules-Ordner"
    (Anmerkung: alle Module wurden mit dem Programm "Showmodule"
    aufgelistet, welches zu den zum Compiler gelieferten Programmen
    gehört):

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

       ShowModule v1.7 (c) 1992 $#%!
       now showing: "mathffp.m"
       NOTE: don't use this output in your code, use the module instead.

         LIBRARY mathbase         /* informal notation */
            SpFix(D0)
            SpFlt(D0)
            SpCmp(D1,D0)
            [..]

            SpCeil(D0)
         ENDLIBRARY

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    Das sieht doch recht interessant aus, oder?

    Naja, für diejenigen, die nicht in die Assembler- und Betriebs-
    systemprogrammierung eingeweiht sind, eigentlich herzlich wenig.
    Und so soll es eigentlich auch sein.

    Das Beispiel soll nur deutlich machen, das in den Modulen für
    Librarys Informationen vorhanden sind, die ohne Module ALLE bekannt
    sein müßten. Und wer möchten das alles, bitte schön, abtippen, nur
    um die MathFFP-Routinen zu nutzen?

    Und damit sind wir auch schon beim ersten Effekt der Module: sie
    sparen Zeit!

    Ein und das selbe Modul kann in verschiedenen Programmen benutzt
    werden und muß nicht jedesmal aufs neue eingegeben werden.

    Wie so ein Modul in einem eigenen Programm genutzt wird, dazu
    später mehr.    
@endnode

@node "Document_3" "2.2 Datenstrukturen und Konstanten"
2.2 Datenstrukturen, Konstanten

    Neben Librarys spielen Datenstrukturen eine große Rolle im
    Amiga-System.
    Man kann auch sagen, daß die Datenstrukturen DIE Rolle spielen.

    Konstanten beschreiben Werte, die in den Datenstrukturen oder bei
    Systemaufrufen benutzt werden dürfen. Normalerweise sind die
    Konstanten nichts anderes als Zahlenwerte, aber wer aknn sich schon
    alle merken?
    Deshalb hat jede Konstanten einen Namen bekommen, über den diese
    sich ansprechen läßt.

    Und hier haben wir wieder das gleiche Poblem: entweder alle
    Informationen abtippen oder .... na ihr wisst schon, Module ver-
    wenden.

    Module mit Datenstrukturen sehen wie folgt aus (Beispiel: gfx.m aus
    "Modules/graphics"):

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       ShowModule v1.7 (c) 1992 $#%!
       now showing: "gfx.m"
       NOTE: don't use this output in your code, use the module instead.

         CONST BITSET=$8000,
               BITCLR=0,
               AGNUS=1,
               DENISE=1

         (---) OBJECT bitmap
               (  0)   bytesperrow:INT
               (  2)   rows:INT
               (  4)   flags:CHAR
               (  5)   depth:CHAR
               (  6)   pad:INT
               (  8)   planes:substructure
         (---) ENDOBJECT     /* SIZEOF=40 */

         [..]

    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
-

    Zum einen sehen wir am Anfang ein Schlüsselwort von E: CONST. D.h.
    nichts anderes, als das alle nachfolgenden Einträge Konstanten
    sind.

    Zum anderen sehen wir eine Datenstruktur, die auch mit dem bekannten
    E-Schlüsselwort "OBJECT" eingeleitet wird.

    Und was können wir aus dem ganzen schließen? Das uns alle diese
    Daten helfen, Zeit zu sparen. Und zwar verdammt viel Zeit fürs
    eintippen ...   
@endnode

@node "Document_4" "2.3 Module unter EC3.0"
2.3 Module unter EC3.0

    Mit den älteren EC-Versionen war es recht umständlich, sich eigene
    Module zu definieren. Hierfür gab es keine Funktion im Compiler und
    so mußte man, wenn denn eigene Datenstrukturen als Module benötigt
    wurden, eine Erzeugung über Hilfsprogramme vornehmen.

    Außerdem war es mit den alten Versionen auch nicht möglich, eigene
    Programme, PROCS oder Datendefinition als Module zu erstellen.

    Aber das hat sich jetzt geändert ...

    Seit der Version EC3.0 und folgende können in den Modulen nicht nur
    Libraryinformationen, Datenstrukturen und Konstanten hinterlegt
    werden sondern auch Procs, eigene Datendefinitionen usw.

    Und genau um diesen Punkt geht es. Hierzu werden wir jetzt in die
    vollen einsteigen ....       
@endnode

@node "Document_5" "3.0 Unser erstes, eigenes Modul - was soll es können ? "
3.0 Unser erstes, eigenes Modul - Was soll es können?

    Fangen wir doch mal an, zu umreißen, was denn unser Workshop-Modul
    machen soll.

    Unter den E-Systemfunktionen befindet sich eine Namens
    "KickVersion".
    Diese Funktionen macht nichts anderes, als das es anhand der über-
    gebenen Versionsnummer überprüft, ob die entsprechende Kickstart-
    version vorhanden ist oder nicht.

    Wenn diese vorhanden ist wird TRUE zurückgegeben, ansonsten False.

    Das Problem dieser Funktion ist aber, daß nicht die tatsächliche
    Kickstartversion zurückgegeben wird. Und das kann problematisch
    sein ...

    Z.B. wollt ihr ein Programm schreiben, daß sowohl für Kick 1.3,
    Kick 2.04 und Kick3.0 unterschiedliche Routinen aufweist. In diesem
    Fall müßt ihr MEHRMALS diese Funktion aufrufen, um zu überprüfen,
    welche Version denn nun tatsächlich vorhanden ist.

    Wie wäre es denn nun mit einer Funktion, die genau dieses ermög-
    licht?

    Zusätzlich vermisse ich eine Funktion, die auch Informationen über
    die verwendete CPU oder FPU anzeigt.

    Tja, da haben wir also unsere Funktionen des WorkShop-Modules
    zusammen:

        a) Information über die verwendete CPU,
        b) Information über die verwendete FPU,
        c) Information über die verwendete Kickstart-Version.

    Als kleinere Besonderheit soll es nicht 3 verschiedene Funktionen
    geben, sondern nur eine einzige Funktion, die drei Rückgabewerte
    zurückgibt.

    Und um dem ganzen noch einen Namen zu geben nennen wir das Modul
    "SystemInfo"

    Wie gesagt, daß ist ein Workshop, wie man Module benutzen kann.
    Sicher könnte man auch noch andere Module für div. Probleme ent-
    werfen, aber genau das solltet ihr hiernach können ...  
@endnode

@node "Document_6" "3.1 Was brauchen wir denn alles ?"
3.1 Was brauchen wir den alles?

    Nun, fangen wir mal mit dem Punkt a) an.

    Woher bekommen wir den Informationen über die verwendete CPU?

    In der Exec-Library gibt es eine Konstante, die sich ATTNFlag
    nennt.
    Und genau hier drin steht, was für eine CPU in dem Amiga genutzt
    wird. Da es sich hierbei um ein Flag handelt, werden die Infor-
    mationen in BIT's dargestellt, d.h. wir müssen prüfen, ob das ent-
    sprechende Bit für die entsprechende CPU AN oder AUS ist.

    Die einzelnen Flags im Detail:

    AFF_68040 ---> Amiga hat 68040 CPU.
    AFF_68030 ---> Amiga hat 68030 CPU.
    AFF_68020 ---> Amiga hat 68020 CPU.
    AFF_68010 ---> Amiga hat 68010 CPU.

    Ist keines dieser Flags gesetzt, dann handelt es sich um eine
    60000er CPU.

    Zusätzlich kann man aus dem ATTNFlag jedoch auch noch erkennen,
    welche FPU vorhanden ist:

    AFF_68881 ---> Amiga hat 68881 FPU.
    AFF_68882 ---> Amiga hat 68882 FPU.
    AFF_FPU40 ---> Amiga hat 68040-interne FPU.

    Ist keines dieser Flags gesetzt, dann ist auch keine FPU vorhanden.

    Damit hätten wir den Punkt b) auch schon erledigt.
    Wie bekommen wir aber jetzt Informationen zu der verwendeten Kick-
    start Version?

    Hierzu muß man wissen, daß jede Library im Amiga-System eine sog.
    Versionsnummer besitzt. Un genau mit dieser Versionsnummer aus der
    Exec-Library kann man erfahren, welche Kick-Version der Amiga
    benutzt.   
@endnode

@node "Document_7" "3.2 Es geht los ..."
3.2 Es geht los .....

    Mit dem Rüstzeug aus dem vorgenannten Kapitel können wir uns jetzt
    ransetzten und eine PROC für dieses Problem schreiben:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


/**********************************************************************
:Modul.         Syseminfo :Beschreibung.  Ein Modul, das die CPU/FPU -
                Typen ermittelt und zu-
                sätzlich die Kickversion. :Autor.         Jörg Wach
(=JCL_POWER) :EC-Version.    EC3.0e :OS.            > 1.2 :PRG-Version.
                1.0 -> Weils mal sein mußte
                       Noch ohne Kickversion
                1.1 -> Mit Kickversion
**********************************************************************/

OPT MODULE OPT EXPORT

MODULE 'exec/execbase' MODULE 'exec/libraries'

PROC systeminfo()

DEF execBase : PTR TO execbase, attnFlag, cpu, fpu, kick,
    libbase : PTR TO lib

    execBase := execbase
    attnFlag := execBase.attnflags

    /* Welche CPU haben wir denn hier ? */

    IF (attnFlag AND AFF_68040)
       cpu := 68040
    ELSEIF (attnFlag AND AFF_68030)
       cpu := 68030
    ELSEIF (attnFlag AND AFF_68020)
       cpu := 68020
    ELSEIF (attnFlag AND AFF_68010)
       cpu := 68010
    ELSE
       cpu := 68000
    ENDIF

    /* Und ist eine FPU an Bord? */

    IF (attnFlag AND AFF_68881)
       fpu := 68881
    ELSEIF (attnFlag AND AFF_68882)
       fpu := 68882
    ELSEIF (attnFlag AND AFF_FPU40)
       fpu := 68040
    ELSE
       fpu := 0
    ENDIF

    /* Und Kick-Version? */

    libbase := execBase.lib
    kick := libbase.version

ENDPROC kick, cpu, fpu


- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    Nehmen wir doch mal den Quelltext auseinander, wobei ich Block bzw.
    Zeilenweise vorgehe:

    1. Der Kommentar

       Als Programmierer sollte man nie die Dokumentation, die
       Versionsnummer eines Programmes usw. vergessen.
       Deshalb habe ich für mich selber einen Standardblock definiert,
       der ein paar kurze Informationen zu dem Quelltext enthält.

    2. OPT MODULE

       Dieses ist ein neues Schlüsselwort unter EC 3.0 und besagt
       nichts anderes, als das der jetzt folgende Sourcecode ein Modul
       ist.
       Damit weiß der Compiler aber auch, das er aus dem Sourcecode
       kein ausführbares Programm machen darf.

       Dieses Schlüsselwort muß UNBEDINGT als erstes bei eigenen Module
       stehen.

    3. OPT EXPORT

       Das ist ein spezielles Schlüsselwort nur für Module. Es be-
       schreibt nämlich, WAS aus dem Modul anderen Programmen bekannt
       gegeben werden darf.

       Mit anderen Worten: hierüber läßt sich steuern, WELCHE PROC's,
       Definitionen etc. ein anderes Programm denn überhaupt aus diesem
       Modul kennen darf.

       Wird dieses Schlüsselwort nirgends im Quelltext eingesetzt, dann
       bedeutet es, daß alle Funktionen, Konstanten usw. PRIVAT sind,
       d.h. anderen Programmen nicht bekannt gegeben werden dürfen.

       Wenn dieses Schlüsselwort als zweites in dem Sourcecode genannt
       wird, dann werden alle nachfolgenden Informationen anderen Pro-
       grammen bekannt gemacht.

       Wenn man nur einzelne Funktionen anderen Programmen bekannt
       machen will, dann muß vor den jeweiligen Funktionen das
       Schlüsselwort EXPORT geschrieben werden.

       Beispiel:

        PROC eins()

        ENDPROC

        EXPORT PROC zwei()

               [..]

               ENDPROC

       Dieses bedeutet nichts anderes, als das die Prozedur eins()
       anderen Programmen nicht bekannt gegeben wird, während die
       Prozedur zwei anderen Progammen sehr wohl bekannt gemacht wird.

       Ihr werdet euch jetzt sicherlich fragen: was soll das?

       Das ist ganz einfach zu beantworten: wenn ihr eine Hauptprozedur
       habt, die viele Unterprozeduren aufruft, wobei andere Programme
       nur über die Hauptprozedur kommunizieren, dann ist es doch un-
       sinnig, anderen Programmen die Unterprozeduren auch noch bekannt
       zu machen, oder?

    3. Die PROC bis ENDPROC

       Brauch ich wohl nicht näher erläutern, da wir ja alles wissens-
       wertes dazu in den vorigen Kapiteln geklärt haben.

    4. ENDPROC kick, cpu, fpu

       Wie ich bei der Zieldefinition schon gesagt habe, sollen alle
       Werte aus dieser Prozedur ausgegeben werden.

       Und dazu greifen wir auf die Besonderheit von EC3.0 zurück: die
       Rückgabe von mehreren Werten.

       Tja, und so einfach kann man mehrere Werte zurückgeben ....

    Ja, und das war alles für den Sourcecode.    
@endnode

@node "Document_8" "4.0 Erzeugen eines Modules mit EC"
4.  Erzeugen eines Modules mit EC

    Dazu brauche ich nicht viel zu sagen, da das ganz normal erfolgt.
    Die einzige Ausnahme ist, daß ich nach den Zeilen

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Amiga E Compiler/Assembler/Linker v3.0e registered (c) 91/92/93/94 $#%!
lexical analysing ... parsing and compiling ... no errors ... - - - - - -
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    kein "SystemInfo"-File erzeugt wird, sondern ein File mit dem Namen
    "SystemInfo.m", weil wir ja ein Modul erstellt haben.  
@endnode

@node "Document_9" "5.0 Test des Modules "
5.  Test des Modules

    Nachdem wir jetzt ein Modul haben, wollen wir es jetzt auch mal in
    Aktion sehen.

    Dazu erstellen wir ein kleines Testprogramm, daß das Modul und die
    darin enthaltene PROC systeminfo() aufruft.
    Die Ausgabe soll, ganz banal, im CLI erfolgen.

    Und hier ist das Testprogramm:

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

MODULE '*SystemInfo'


PROC main() DEF t1, t2, t3
    t1,t2,t3 := systeminfo()
    WriteF('\d \d \d',t1, t2, t3)

ENDPROC

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    Zu dem Testprogramm gibt es nur einen besonderen Hinweis zu nennen:
    die erste Zeile.

    In dieser steht "MODULE '*Systeminfo", was unserem Programm sagt,
    daß es ein Modul mit dem Namem "SystemInfo" verwenden soll und das
    dieses Modul sich in dem aktuellen Verzeichnis befindet.

    Woher EC weiß, daß dieses Modul sich in dem aktuellen Verzeichnis
    befindet? Durch nichts anderem als dem "*" vor dem Modul-Namen.

    Wird der Stern weggelassen, dann sucht EC das Modul in dem Ver-
    zeichnis "MODULES:", wo es natürlich nur stehen kann, wenn Ihr es
    dort hineinkopiert habt.  
@endnode

@node "Document_10" "6.0 Was noch alles machen könnte ..."
6.  Was mann noch alles machen könnte ....

    Dieses kleine Beispiel soll euch nur aufzeigen, wie man Module in E
    programieren und verwenden kann.

    Praktische Bedeutung hat das ganze, wenn man ein Programm erstellt,
    daß sehr groß wird. Und darin kann man schnell die Übersicht
    verlieren ...

    Deshalb bietet es sich mit der Modultechnik unter EC3.0 gerade zu
    an, in großes Programm in kleinere "Häppchen" zu zerteilen. Somit
    bewahrt man die Übersicht, muß nicht immer alles neu compilieren
    lassen, wenn sich ein kleines Teil ändert, und kann evtl. Module
    für andere, neue Programme verwenden, ohne diese mühsam aus dem
    ehemaligen großen Programm zu suchen und heraus zu kopieren.

    Auf der anderen Seite gibt es sicher das eine oder das andere, was
    man immer wieder braucht. Warum nicht daraus ein Modul machen?
    Einfacher gehts nicht .........  
@endnode

@node "Document_11" "7.0 Schlußwort"
7.  Schlußwort

    Ihr habt jetzt die Grundkenntnisse bekommen, was ihr daraus macht,
    bleibt euch überlassen.

    Ich würde mich über entsprechende Resonanz freuen, im Besonderen,
    wenn ich die Programme auf der EPD veröffentlichen darf.

    Aber auch für Fragen und Antworten stehe ich gerne zur Verfügung
    (solange ihr nicht wissen wollt, welche Amiga-Funktion ihr für euer
    Problem xyz benutzen könnt. Das steht in Büchern und ich bin nun
    mal kein wandelndes Lexikon).

    Jörg Wach, 27.11.1994

@endnode

