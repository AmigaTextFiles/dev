simplelex.m: very simple general purpose lexical analyser for various tasks.

This lex() can used there where one quickly needs a lex without
bothering to make one yourself. It may also serve as an example
or starting point on how to make your own lex. See simplelextest.e
for a nice parser example that makes use of this lex.


	lex_int(start,len,freeform=FALSE,onelinecomment=-2)

initialises the lex. start and len denote the memory area where
the text is that lex() will take it's tokens from. The memory
needs to be trailed by "\n", readfile() from file.m does this for
you. freeform says wether "\n" should be interpreted as whitespace
or not. onelinecomment allows only one char.

	token,attr:=lex()

the actual lex. returns a token, and for some tokens also an attribute.

" ", "\t"			whitespace, not returned
"\n"				LEX_EOL, or whitespace
"[a-zA-Z_][a-zA-Z0-9_]*"	LEX_IDENT, attr=ptr to first char
				[same as E's idents]
<num>				LEX_INTEGER, attr=value
				[everything accepted by Val()]
<eof>				LEX_EOF
"<anything>"			LEX_STRINGQ, attr=ptr to first char
'<anything>'			LEX_STRINGA, idem.

any other character is returned as token on it's own.

	linenum:=lex_curline()

returns the current linenumber being lexical-analysed.

	ptr:=lex_current()

returns the current ptr in the text. Handy for those cases where
lex() returns 'ptr to first char', as this will then be 'ptr past
last char'.

	pos:=lex_getline(estring)

copies the current line into the estring, and returns the offset
into that string where lex() currently is. Very handy for precise
error-reports, as the simplelextest.e demonstrates.
