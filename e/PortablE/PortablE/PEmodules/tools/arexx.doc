arexx.m: simple routines for adding an arexx-port to your program.

	port:=rx_OpenPort(portname)

Creates an arexx-port. macro programs may now reach you by saying
'ADDRESS portname'. May raise: "MEM", "SIG", "DOUB". the last two are
'could not allocate signal' and 'port with same name already exists'.

	rx_ClosePort(port)

Frees up the port and all associated resources. May safely be called
with NIL.

	mes,string:=rx_GetMsg(port)

Just about the same as exec's GetMsg, only now rexx-specific.
extracts the string send from the macro program. If mes=NIL then there
was no message.

	rx_ReplyMsg(mes,rc=0,resultstring=NIL)

reply the message you got from rx_GetMsg(). pass rc=0 for no error,
and a string if you think the command send requires a result. rc>0
signals an error (no result is returned).

	rx_HandleAll(interpret_proc,portname)

The first four functions supply you with all the machinery needed
for adding an arexxport to your programs. However, if all your
program does is wait for and process messages from arexx anyway,
you can use this function which encapsulates the other four. All
it needs is a PROC to process the messages and again a portname.

Alternatively, the source of this function is a usefull example
of how to call the other four functions, just incase you want
to call them yourself:


PROC rx_HandleAll(interpret_proc,portname) HANDLE
  DEF port=NIL,sig,quit=FALSE,mes,s,rc,rs
  port,sig:=rx_OpenPort(portname)
  REPEAT
    Wait(sig)
    REPEAT
      mes,s:=rx_GetMsg(port)
      IF mes 
        quit,rc,rs:=interpret_proc(s)
        rx_ReplyMsg(mes,rc,rs)
      ENDIF
    UNTIL (mes=NIL) OR (quit=TRUE)
  UNTIL quit
  Raise()
EXCEPT
  rx_ClosePort(port)
  ReThrow()
ENDPROC


From the code we can see that the proc given as an argument to rx_HandleAll()
gets as argument a string he may want to process, and returns a flag
wether to quit or not, and the rc and result as mentioned in the rx_Reply()
function. see arexxsimple.e how to make an arexxhost with this function
with just a few lines of code.
