<html>
<head>
  <title>chunky.lib - Chunky graphics support functions</title>
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body bgcolor=#ffffff>
<ul type=square>
<li><big>Introduction</big><br>
  Chunky.lib is a small link library containing several functions to provide
  chunky graphics usage. I hope this will be useless in future AmigaOS
  versions, but now this is only way to use fast 8bit graphics on AGA.
  Most of it's functions are written in pure assembly to gain maximum
  perfomance, but I suppose some can be well much faster...
  It contains only basic chunky functions like chunky allocation,
  copying and pixel writing/reading. Nothing more included, nothing more
  that much needed. Sorry.<br>
  There aren't any c2p routines included, so You have to use Your own, or
  to compine chunky.lib with the rtgmaster.library usage, what I preffer.
  (See some examples)
<br><br>
<li><big>PowerPC support</big><br>
  There is ofcourse also a version of chunky.lib for PowerPC, it's fully
  native and doesn't make any context switches. The interface is completely
  the same as for the 68k chunky.lib, so if You will enable the 'OPT PPC'
  option, PowerD will automaticaly select the correct PowerPC version.<br>
  In the PowerPC version is one missing function, the DrawTriangle(), sorry.
<br><br>
  As You can see, this library still lack many important functions, but
  some of them provides rtgmaster.library, please see it's documentation.
<br><br>
<li><big>Basic functions</big><br>
  <ul type=disc>
  <li><font size=+1>CreateChunky(width,height)(PTR)</font><br>
    Allocates and clears memory for 8bit chunky memory field of size width x height.
  <br><br>
  <li><font size=+1>CreateChunky32(width,height)(PTR)</font><br>
    Allocates and clears memory for 32bit (ARGB) chunky memory field of size width x height.
  <br><br>
  <li><font size=+1>CreateChunky32Z(width,height)(PTR)</font><br>
    Allocates and clears memory for 32bit (ARGB) chunky and 32bit z-buffer memory field of size width x height.
  <br><br>
  <li><font size=+1>DeleteChunky(chunky)</font><br>
    Frees memory allocated by one of above functions.
  <br><br>
  </ul>
<li><big>Lowlevel drawing functions</big><br>
  There is currently only pixel writing/reading functions.
  <ul type=disc>
  <li><font size=+1>PutPixel(chunky,x,y,colour)(L)</font><br>
    Write a pixel of colour to coordinates of x and y in chunky.
    Returns previous pixel on this position in the chunky.
  <br><br>
  <li><font size=+1>PutPixelFast(chunky,x,y,colour)</font><br>
    Write a pixel of colour to coordinates of x and y in chunky.
    It doesn't check if the coordinates fits to the chunky, so
    use it only if You are sure, that it fits!!!
  <br><br>
  <li><font size=+1>PutPixel32(chunky,x,y,colour)(L)</font><br>
    Write a pixel of colour (ARGB) to coordinates of x and y in chunky.
    Returns previous pixel (ARGB) on this position in the chunky.
  <br><br>
  <li><font size=+1>PutPixel32Z(chunky,x,y,colour,z)(L,F)</font><br>
    Write a pixel of colour (ARGB) to coordinates of x and y in chunky if
    the z value is lower then the z-buffer value in the chunky.
    Returns previous pixel (ARGB) and previous z-buffer value on this
    position in the chunky.
  <br><br>
  <li><font size=+1>GetPixel(chunky,x,y)(L)</font><br>
    Returns pixel colour on the position of x and y in the chunky.
  <br><br>
  <li><font size=+1>GetPixel32(chunky,x,y)(L)</font><br>
    Returns pixel colour (ARGB) on the position of x and y in the chunky.
  <br><br>
  <li><font size=+1>GetPixel32Z(chunky,x,y)(L,F)</font><br>
    Returns pixel colour (ARGB) and z-buffer value on the position of
    x and y in the chunky.
  <br><br>
  <li><font size=+1>FillChunky(chunky,colour)</font><br>
    Fills the 8bit chunky buffer with colour. Be sure, that the chunky width
    must be aligned to four byte boundary (dividable by four). 
  <br><br>
  <li><font size=+1>FillChunky32(chunky,colour)</font><br>
    Fills the 32bit (ARGB) chunky buffer with colour. As this function
    uses 32bit colour definition, it doesn't any alignation.
  <br><br>
  <li><font size=+1>FillChunky32Z(chunky,colour,zdist)</font><br>
    Fills the 32bit (ARGB) chunky buffer with colour and the zbuffer with
    a value of zdist. As this function uses 32bit colour definition, it
    doesn't any alignation.
  <br><br>
  </ul>
<li><big>Highlevel drawing functions</big><br>
  <ul type=disc>
  <li><font size=+1>DrawTriangle(chunky,xy:PTR TO FLOAT,colour)</font><br>
    This function draws a filled triangle in to the chunky. The triangle
    coordinates must be provided as a field of three pairs of floats.<br>
    Note: This function is pretty slow as it is written in assembly only
    partialy. It can be usefull only for simplier objects. On 040/25 it
    does between 3000-8000 (small) triangles per second, so please don't
    await too much :)
  <br><br>
  </ul>
<li><big>Conversion functions</big><br>
  As I said above, this is only for temporaryli usage, so stay calm, anything
  'revolutionary' isn't here :)
  <ul type=disc>
  <li><font size=+1>Pack32(a,r,g,b)(UL)</font><br>
    This converts alpha, red, green and blue components of colour into
    one 32bit (ARGB) colour.
  <br><br>
  <li><font size=+1>UnPack32(argb)(L,L,L,L)</font><br>
    This converts the 32bit (ARGB) colour into it's separated components
    of red, green, blue and alpha (in this order!!!).
  <br><br>
  <li><font size=+1>Conv24To8(argb)(L)</font><br>
    Converts single 24bit colour (alpha is left) into 8bit gray scale.
  <br><br>
  <li><font size=+1>Conv24ToGray(chunky8,chunky32)(L)</font><br>
    Converts whole 32bit chunky buffer (alpha is left) into 8bit gray scale
    chunky buffer.
  <br><br>
  </ul>
<li><big>Chunky copying routines</big><br>
  <ul type=disc>
  <li><font size=+1>ChunkyCopy(dst,dx,dy,src,sx,sy,w,h)</font><br>
    Copy a part of src chunky starting on sx and sy coordinates into the
    dst chunky starting at dx and dy coordinates. Copied block is w x h
    pixels large.
  <br><br>
  <li><font size=+1>ChunkyCopyMask(dst,dx,dy,src,sx,sy,w,h)</font><br>
    The same as above, but all the zero pixels from the source are skipped.
  <br><br>
  </ul>
</ul>
</body>
</html>
