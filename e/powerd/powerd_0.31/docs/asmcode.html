<html>
<head>
  <title>PowerD.html - How to use Assembler code</title>
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body bgcolor=#ffffff>
<ul type=square>
<li><big>Description:</big><br>
  Just an inlined assembly, read some 68k or ppc assembler documentation to
  learn more about this stuff.
<br><br>

<li><big>History:</big><br>
  <ul type=disc>
  <li>0.15:
    <ul type=circle>
    <li>inline assembler can be used in more confortable way
    <li>You are able to use constants, variables and more in your assembler source
    <li>You can also use normal PowerD <a href="comment.html">comments</a>.
    </ul>
  <li>0.18:
    <ul type=circle>
    <li>You can define the ASM/ENDASM keywords outside the procedures.
    </ul>
  <li>0.20:
    <ul type=circle>
    <li>You are able to use arguments like (obj.item,ax), where obj is an object,
        item is the obj's item, and ax is an address register.
    <li>You can use constant expressions, where the constants could be used
    </ul>
  </ul>
<br><br>

<li><big>Limitations:</big><br>
  This feature requires sth like complete assembler reader. (Assembler
  writer is already contained in PowerD). I supported as much instructions
  and their addressing modes as I know, but these things requires lots of
  numbers and tables, so if You will find an error, please report.
  <br><br>

<li><big>Syntax:</big><br>
  PowerD knows two ways of assembler usage in it's source. First way
  starts with <font color=#ff0000>ASM</font>
  and ends with <font color=#ff0000>ENDASM</font>
  keyword. Assembler code can be used only between these two keywords. Else
  some systax errors will appear. Second way is assembler-only procedure.
  Such procedure starts with <font color=#ff0000>APROC</font>
  and ends with <font color=#ff0000>ENDPROC</font> keyword.
<font color=#ff0000><pre>
  ASM
    here should be your assembler routines
  ENDASM

  APROC compute(d0:LONG,d1:LONG,d2:LONG)(LONG)
    here should be your assembler routines
  ENDPROC
</pre></font>
<li><big>PowerD known instructions:</big><br>
  PowerD knows all the 68k instructions except some supervisor, mmu and some
  rare fpu instructions. If You find, something missing, please let me know,
  and I will fix/add it.
<br><br>

<li><big>PowerD known addressing modes:</big><br>
  PowerD used only 020 addressing modes, so obsolete modes like 123(a0)
  have to be changed to (123,a0). PowerD knows all 68k addressing modes.
  When addressing local PowerD variables, they have to be used alone,
  while global variables can be used much more comfortable ways:
<font color=#ff0000><pre>
  move.l  lvar,a0
  move.l  d2,lvar
  addi.l  #1,lvar

  move.l  ([gvar,pc],d0.w*8),d0
  move.l  ([gvar]),d0

</pre></font>
<br><br>

<li><big>Simple object offsets:</big><br>
  To make Your inlined assembly more readable, You can replace Your direct offsets
  by it's object.item equivalents, so You can from 0.20a2 use:

<font color=#ff0000><pre>
  OBJECT myobj
    x,y

  DEF ptr:PTR TO myobj

  APROC main()
    move.l  ptr,a0
    move.l  (myobj.y,a0),d0
  ENDPROC
</pre></font><br>
  instead of:
<font color=#ff0000><pre>
  OBJECT myobj
    x,y

  DEF ptr:PTR TO myobj

  APROC main()
    move.l  ptr,a0
    move.l  (4,a0),d0
  ENDPROC
</pre></font><br>

</ul>
</body>
</html>
