<html>
<head>
  <title>PowerD.html - OBJECT definition</title>
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body bgcolor=#ffffff>
<ul type=square>
<li><big>Description:</big><br>
  Object is something like field of types or typed memory.<br>
<br><br>

<li><big>News:</big><br>
  <ul type=disc>
  <li>From 0.02<br>
    <ul type=circle>
    <li>Added <a href="#union">unions</a> support.
    </ul>
  <li>From 0.05b<br>
    <ul type=circle>
    <li>Added <a href="#pad">pad</a> bytes support.
    </ul>
  <li>From 0.15<br>
    <ul type=circle>
    <li>You are allowed to use <a href="#short">&lt;/&gt;</a> for shorter entry.
    </ul>
  <li>From 0.16
    <ul type=circle>
    <li>You are allowed to use <a href="#multio">multiple object names</a>.
    <li>Item names can start with <a href="#number">numbers</a>.
    </ul>
  <li>From 0.17
    <ul type=circle>
    <li>Added keywords <a href="#offset">OFFSET</a> and <a href="#relofs">RELOFS</a> for custom position of items in an object.
      <ul type=circle>
      <li>Each item can have set it's <a href="#dirofs">position</a> directly.
      </ul>
    <li>Again added <a href="oop.html">OOP</a> support, which a bit changes the OBJECT <a href="#oop">structure</a>.
    <li>Added C alike <a href="#cunion">unions</a>.
    </ul>
  <li>From 0.19
    <ul type=circle>
    <li>OBJECTs can be now defined also inside the procedures to become local
    <li>added support for <a href="#multi">multi dimensional</a>. items (upto 3d)
    <li>each 'PTR TO ' keyword after the ':' can be replaced by single '[]' before the ':'
    </ul>
  </ul>
<br><br>

<li><big>Syntax:</big>
<font color=#ff0000><pre>
  OBJECT &lt;name&gt; [ OF &lt;linkname&gt; ]
    &lt;item&gt; [ &lt;[size]&gt; ] [ &lt;:type&gt; ] [ ,
    &lt;item&gt; ]
</pre></font><br>
  Where <font color=#ff0000>&lt;name&gt;</font> is the
  new OBJECT's name. <font color=#ff0000>&lt;linkname&gt;</font>
  is the OBJECT whose all items will be inserted before items of this new
  OBJECT. <font color=#ff0000>&lt;item&gt;</font> is the new
  item name. <font color=#ff0000>&lt;[size]&gt;</font> means
  count of elements in the item. Pay attention, that one object's size is
  limited by 32 kB length. <font color=#ff0000>&lt;:type&gt;<font
  color=#000000> is one of <a href="types.html">types</a>.<br><br>

<a name="multii"></a>
<li><big>Item synonyms:</big><br>
  Each item in object can have upto 31 synonyms, all of these must be
  separated by '|' operator.
<font color=#ff0000><pre>
  OBJECT Point
    X|x|R|r:FLOAT,
    Y|y|G|g:FLOAT,
    Z|z|B|b:FLOAT
</pre></font><br><br>

<a name="short"></a>
<li><big>Short item list entry:</big><br>
  This allows You to enter items in shorter way then eg. the following:
<font color=#ff0000><pre>
  OBJECT vertex
    X|x:FLOAT,
    Y|y:FLOAT,
    Z|z:FLOAT
</pre></font><br>
  You can simply separate them with '/' operator:
<font color=#ff0000><pre>
  OBJECT vertex
    X|x/Y|y/Z|z:FLOAT
</pre></font><br>
  This generates completely the same as above, but the count of the
  this-way-entered-items (including synonyms!) mustn't be higher then
  32 items.
<br><br>

<a name="multio"></a>
<li><big>Object synonyms:</big><br>
  Each object can have upto 7 synonyms, all of these must be
  separated by '|' operator.
<font color=#ff0000><pre>
  OBJECT point|vector|vertex|d3d
    x/y/z:FLOAT
</pre></font><br>
  Note: If You compile module with such object then the produced binary
  module will contain four objects, not one with four names!!!
<br><br>

<a name="union"></a>
<li><big>Unions:</big><br>
  This is very useful, if you want to use one object to store different
  types of values in same object but different memory block.
<font color=#ff0000><pre>
  OBJECT Help
    Type:UWORD,             // help type
    NEWUNION AmigaGuide     // amigaguide help
      File:PTR TO UBYTE,    // file name
      Node:PTR TO UBYTE     // node name
    UNION LocalHelp         // inlined help
      Text:PTR TO UBYTE,    // pointer to text
      Length:UWORD          // length of the text
    ENDUNION,               // end of the union
    HelpTitle:PTR TO UBYTE  // title of the help
</pre></font><br>
  This will generate have length of 14 bytes: Type has 2 bytes, each
  UNION between NEWUNION and ENDUNION has the same start offset (in
  this case it is 2). Each UNION starts on even address, so if the
  address is odd, one byte is skipped. Then PowerD finds the longest
  UNION and adds it's length to the UNION offset (in this case has
  AmigaGuide 8 bytes and LocalHelp 6 bytes, 8 bytes used).  Next item
  starts on this address.<br><br>

  <font size=+1>ATTENTION:</font> see the commas, they have to be used
  exactly.<br><br>

<a name="cunion"></a>
<li><big>C alike unions:</big><br>
  This feature is finaly added to simplify the C source/header translation.
<font color=#ff0000><pre>
  OBJECT xxx
    x:W,
    CUNION
      a:L,
      b:D,
      [i,j,k]:c
    ENDUNION,
    y:L
</pre></font><br>
  This setups the offset of 2 (x is 2 bytes long) to all of the CUNION
  items a, b and c has offset of 2. The y will have offset of 14, it
  takes the longest item of the union and here it is c (3xlong=12bytes).
<br><br>

<a name="pad"></a>
<li><big>Pad bytes:</big><br>
  Each non BYTE/UBYTE item must start on even address:
<font color=#ff0000><pre>
  OBJECT xxx               // SIZEOF_xxx = 6 bytes
    a:BYTE,                // offset=0
    b:BYTE,                // offset=1
    c:BYTE,                // offset=2
    d:WORD                 // offset=4
</pre></font><br><br>

<li><big>Linked objects:</big>
<font color=#ff0000><pre>
  OBJECT PointList OF Point  // see OBJECT Point above
    Next:PTR TO Point,
    Prev:PTR TO Point
</pre></font><br>
  is the same as:
<font color=#ff0000><pre>
  OBJECT PointList
    X|x|R|r:FLOAT,
    Y|y|G|g:FLOAT,
    Z|z|B|b:FLOAT,
    Next:PTR TO Point,
    Prev:PTR TO Point
</pre></font><br><br>

<a name="offset"></a>
<a name="relofs"></a>
<li><big>Custom item offsets:</big><br>
  <font color=#ff0000>OFFSET &lt;x&gt;</font> sets the current offset value to &lt;x&gt;.<br>
  <font color=#ff0000>RELOFS &lt;x&gt;</font> adds the &lt;x&gt; to current offset value.<br><br>

  It allows You to use for example negative offsets for object items and
  to share parts of memory.<br><br>

  Important note: Objects, that contains these keywords, MUSTN'T be used as a
  static objects ([a,b,1,2]:obj), because of different offsets, compiler wouldn't
  even know, how will be these item used, watch this:
<font color=#ff0000><pre>
  OBJECT test
    a:W,
    OFFSET 4,
    b:W,
    RELOFS -4,
    c:W
</pre></font><br>
  This will generate an object with items, that has offsets: a=0, b=4 and c=2.
  Item a is at the top of the object, so it has offset of 0, it is WORD, so
  we will add 2 bytes to the offset, but now comes keyword OFFSET 4, which
  sets the offset value to 4, then the item b will be on the address of 4.
  Now, b is WORD, it has two bytes, the offset raises to 6, but here follows
  the RELOFS -4 keyword, which adds the -4 to the offset, so it's on address
  of 2 (6-4).
<font color=#ff0000><pre>
  OBJECT mem
    long:L,
    OFFSET 2,
    word:W,
    OFFSET 3,
    byte:B
</pre></font><br>
  Pay attention, when You want to use these keywords with OOP!
<br><br>

<a name="dirofs"></a>
<li><big>Simple and short direct offset usage:</big><br>
  This feature must be used with care and is the same as the OFFSET keyword.
  This has the same function as that keywords, but it's shorter and
  simplier to use:
<font color=#ff0000><pre>
  OBJECT mem
    long:L,
    word=2:W,
    byte=3:B
</pre></font><br>
  This does the same as the above example. I hope, it's clear and don't
  need anything more to explain ;)
<br><br>

<li><big>Object sizes:</big><br>
    With each object is generates one constant called SIZEOF_xxx, where xxx is object
  name, this constant contains the object length in bytes.
<br><br>

<a name="numbers"></a>
<li><big>Number leading items:</big><br>
  From v0.16 You are allowed to use item names like following:
<font color=#ff0000><pre>
  OBJECT xxx
    0:WORD,
    1:LONG,
    3:DOUBLE,
    0name:PTR TO CHAR,
    1name:PTR TO CHAR
</pre></font><br>
  etc. Pay attention about usage of <a href="prepro.html">preprocessor
  feature a:=.b</a> what is normally converted to a:=a.b this doesn't
  work if the item begins with number!!!
<br><br>

<a name="multi"></a>
<li><big>Multi dimensional items:</big><br>
  From 0.19 alpha 5, is possible to define and use arrays in objects with
  more then one dimension, You are allowed to use upto three dimensions:
<font color=#ff0000><pre>
  OBJECT test
    array[10,5,2]:UB
</pre></font><br>
  To access such items, enter:
<font color=#ff0000><pre>
  x:=test.array[5,3,1]
</pre></font><br>
  it's the same as:
<font color=#ff0000><pre>
  x:=test.array[5*10+3*5+1]
</pre></font><br>
<br><br>

<a name="oop"></a>
<li><big>OOP and objects:</big><br>
  As You can see, the first item in each object starts at offset of 0.
  When You attach to this object an OOP method, the first item will
  start at offset of 4. That's because at the offset of 0 is in this
  case defined the pointer to the list of all methods attached to the
  object.<br>
  Take care about the OFFSET/RELOFS keyword usage, if some item will
  start at address, which is occupied by the method pointer list, it
  will probably crash Your computer. The best way to avoid such problems
  is to don't use these (lowlevel) keywords at all.
</ul><br><br>
</body>
</html>
