<html>
<head>
  <title>chunky.lib - knihovna funkci pro 8 bitovou grafiku</title>
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body bgcolor=#ffffff>
<ul type=square>
<li><big>Uvod</big><br>
  chunky.lib je mala linkovaci knihovna obsahujici hromadu funkci pro
  praci s 8 bitovou chunky (bajtovou) grafikou. Doufam, ze toto bude
  zbytecne v budoucich verzich AmigaOS/MorphOS, ale ted je toto jedina
  moznost, jak pouzit rychlou 8 bitovou grafiku na AGA. Vetsina funkci
  je napsana primo v assembleru pro maximalni vykon, ale myslim, ze
  nektere mohou byt jeste mnohem rychlejsi...
  Knihovna obsahuje pouze zakladni graficke funkce jako alokace chunky
  dat, kopirovani grafiky, nacitani/zapisovani pixelu. Nic vic neni
  pridano, nic vic neni tak moc potreba. Snad pozdeji.<br>
  Zadne c2p rutiny nejsouo prilozeny, musite poiuzit bud svoje vlastni,
  nebo zkombinovat chunky.lib s rtgmaster.library, coz ja uprednostnuji.
  (podivejte se na nejake ukazky)
<br><br>
<li><big>Podpora PowerPC</big><br>
  Samozrejme existuje i PowerPC verze chunky.lib. je zcela nativni a
  nevyzaduje zadne prepinani kontextu (68k X ppc). Prostredi je zcela
  stejne jako pro 68k verzi knihovny, takze pokud aktivujete 'OPT PPC',
  PowerD automaticky vybere spravnou PowerPC verzi.<br>
  V PowerPC verzi chybi jedina funkce, a sice DrawTriangle(), snad pozdeji.
<br><br>
  Jak je videt, knihovna stale postrada radu dulezitych funkci, ale nektere
  z nich poskytuje rtgmaster.library, tak se prosim podivejte na jeji dokumentaci.
<br><br>
<li><big>Zakladni funkce</big><br>
  <ul type=disc>
  <li><font size=+1>CreateChunky(sirka,vyska)(PTR)</font><br>
    alokuje a cisti pamet pro 8 bitovou chunky grafiku o dane velikosti.
  <br><br>
  <li><font size=+1>CreateChunky32(sirka,vyska)(PTR)</font><br>
    alokuje a cisti pamet pro 32 bitovou (ARGB) grafiku o dane velikosti.
  <br><br>
  <li><font size=+1>CreateChunky32Z(sirka,vyska)(PTR)</font><br>
    alokuje a cisti pamet pro 32 bitovou (ARGB) grafiku a 32 bitovy z-buffer o dane velikosti.
  <br><br>
  <li><font size=+1>DeleteChunky(chunky)</font><br>
    uvolni pamet po jedne z predchazejicich funkci
  <br><br>
  </ul>
<li><big>zakladni vykreslovaci funkce</big><br>
  Momentalne je pouze jedna funkce a to na praci s jednim pixelem:
  <ul type=disc>
  <li><font size=+1>PutPixel(chunky,x,y,barva)(L)</font><br>
    zapise pixel v barve na souradnice x a y pro danou chunky pamet.
    vraci hodnotu predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>PutPixelFast(chunky,x,y,barva)</font><br>
    zapise pixel v barve na souradnice x a y pro danou chunky pamet.
    nekontroluje, jestli se souradnice vejdou do dane chunky pameti,
    takze ji pouzijte jen pokud vite, co delate.
  <br><br>
  <li><font size=+1>PutPixel32(chunky,x,y,barva)(L)</font><br>
    zapise pixel v barve (ARGB) na souradnice x a y pro danou chunky pamet.
    vraci hodnotu (ARGB) predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>PutPixel32Z(chunky,x,y,barva,z)(L,F)</font><br>
    zapise pixel v barve (ARGB) a hodnotu do z-bufferu na souradnice x a y pro danou chunky pamet.
    the z value is lower then the z-buffer value in the chunky.
    vraci hodnotu (ARGB) a hodnotu v z-bufferu predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>GetPixel(chunky,x,y)(L)</font><br>
    vraci hodnotu predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>GetPixel32(chunky,x,y)(L)</font><br>
    vraci hodnotu (ARGB) predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>GetPixel32Z(chunky,x,y)(L,F)</font><br>
    vraci hodnotu (ARGB) a hodnotu v z-bufferu predchoziho pixelu na danych souradnicich.
  <br><br>
  <li><font size=+1>FillChunky(chunky,barva)</font><br>
    vyplni chunky pamet danou barvou. lze pouzit pouze, pokud je sirka pameti delitelna 4.
  <br><br>
  <li><font size=+1>FillChunky32(chunky,barva)</font><br>
    vyplni chunky pamet danou barvou (ARGB).
  <br><br>
  <li><font size=+1>FillChunky32Z(chunky,barva,z)</font><br>
    vyplni chunky pamet danou barvou (ARGB) a z-buffer nastavi na hodnotu z.
  <br><br>
  </ul>
<li><big>pokrocile vykreslovaci funkce</big><br>
  <ul type=disc>
  <li><font size=+1>DrawTriangle(chunky,xy:PTR TO FLOAT,barva)</font><br>
    tato funkce vykresli vyplneny trojuhelnik do 8 bitove chunky pameti.
    souradnice trojuhelniku v poli tri paru floatu.<br>
    poznamka: tato funkce je velice pomala, protoze je napsana v assembleru
    pouze castecne. Muze byt pouzitelna pouze pro jednodussi objekty. na 040/25
    dela mezi 3000 a 8000 (malych) trojuhelniku za sekundu, tak od toho prosim
    moc neocekavejte ;)
  <br><br>
  </ul>
<li><big>konverzni funkce</big><br>
  jak jsem rekl vyse, jsou tyto funkce pouze pro docasne pouziti, tak zustante klidni,
  nic revolucniho zde neni :)
  <ul type=disc>
  <li><font size=+1>Pack32(a,r,g,b)(UL)</font><br>
    toto konvertuje alfa kanal, cervenou, zelenou a modrou zlosku do jedne 32 bitove (ARGB) hodnoty.
  <br><br>
  <li><font size=+1>UnPack32(argb)(L,L,L,L)</font><br>
    toto konvertuje jednu 32 bitovou (ARGB) hodnotu do separatnich hodnot cervena, zelena, modna, alfa kanal (v tomto poradi!!!).
  <br><br>
  <li><font size=+1>Conv24To8(argb)(L)</font><br>
    konvertuje 32 bitovou barvu (ARGB) (alfa je vypustena) do 8 bitove v odstinech sedi.
  <br><br>
  <li><font size=+1>Conv24ToGray(chunky8,chunky32)(L)</font><br>
    konvertuje 32 bitovou chunky32 grafiku (ARGB) (alfa je vypustena) do 8 bitove chunky8 grafiky v odstinech sedi.
  <br><br>
  </ul>
<li><big>kopirovaci chunky funkce</big><br>
  <ul type=disc>
  <li><font size=+1>ChunkyCopy(dst,dx,dy,src,sx,sy,w,h)</font><br>
    kopiruje cast src chunky grafiky na souradnicich sx a sy do dst chunky grafiky na souradnice dx a dy. kopiruje se blok velikosti w x h pixelu.
  <br><br>
  <li><font size=+1>ChunkyCopyMask(dst,dx,dy,src,sx,sy,w,h)</font><br>
    to same, co predchozi funkce, jen nulove bajty z src chunky grafiky jsou preskoceny.
  <br><br>
  </ul>
</ul>
</body>
</html>
