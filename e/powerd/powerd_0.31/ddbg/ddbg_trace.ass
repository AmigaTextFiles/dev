; Code by Zbigniew `Zeeball` Trzcionkowski
; At: 19.02.2000
; Use it for free just credit me!

; 2.6.2002 by Martin <MarK> Kuchinka:
; small changes to make the code more relevant for PowerD debugger

; history
; 16.8.2002 changes by MarK
;   the tracing routine speeded up by skipping all the non-proggy code

	machine	68010

; Trace(code:a0,test:a1)(pc,reglist)
	xdef	_Trace
_Trace	movem.l	a5-a6,-(a7)
	movea.l	$4.w,a6
	jsr	(-132,a6)		; Forbid
	jsr	(-$78,a6)		; Disable

	lea	(Trail,pc),a5
	move.l	a0,(-4,a5)
	move.l	a1,(-8,a5)
	move.l	a2,(-16,a5)
	move.l	a3,(-12,a5)
	jsr	(-30,a6)		; Supervisor

	jsr	(-$7e,a6)		; Enable
	jsr	(-138,a6)		; Permit
	movem.l	(a7)+,a5-a6
	move.l	(addy,pc),d0
	lea	(reglist,pc),a0
	move.l	a0,d1
	rts


start	dc.l	0
stop	dc.l	0
test	dc.l	0
Procedura	dc.l	0
Trail	movem.l	d0-a6,-(sp)

	; get vbr 68000-68060 compatible
	suba.l	a1,a1
	movea.l	$4.w,a6
	move.w	($128,a6),d0	; ExecBase.AttnFlags
	btst	#0,d0		; 68010+?
	beq.b	.xvbr
	movec	VBR,a1		; yes, get VBR
.xvbr
	move.l	($24,a1),-(sp)
	move.l	a1,-(sp)

	lea	(Trailer,pc),a0
	move.l	a0,($24,a1)	; setup the tracing function

	bsr.b	.change_t		; enable tracing

	move.l	(Procedura,pc),a0
	jsr	(a0)		; run the code

	bsr.b	.change_t		; disable tracing

	move.l	(sp)+,a1
	move.l	(sp)+,($24,a1)
	movem.l	(sp)+,d0-a6
	rte

; change the tracing bit
.change_t	move.w	SR,d0
	bchg	#15,d0
	move.w	d0,SR
	rts


exitd0	move.l	(sp)+,d0
	rte

; this function is invoked when an instruction is completed
; it stores the address of the next instruction to be executed to the addy address
Trailer	move.l	d0,-(sp)
	move.l	(6,sp),d0
	cmp.l	(start,pc),d0
	blt.s	exitd0
	cmp.l	(stop,pc),d0
	bgt.s	exitd0

	move.l	(sp)+,d0
	movem.l	d0-a6,-(sp)

	move.l	a0,-(a7)		; save all the registers
	lea	(reglist,pc),a0
	move.l	d0,(a0)
	move.l	d1,(4,a0)
	move.l	d2,(8,a0)
	move.l	d3,(12,a0)
	move.l	d4,(16,a0)
	move.l	d5,(20,a0)
	move.l	d6,(24,a0)
	move.l	d7,(28,a0)
	move.l	(a7)+,(32,a0)
	move.l	a1,(36,a0)
	move.l	a2,(40,a0)
	move.l	a3,(44,a0)
	move.l	a4,(48,a0)
	move.l	a5,(52,a0)
	move.l	a6,(56,a0)
	move.l	usp,a1
	move.l	a1,(60,a0)
	move.w	(60,sp),(64,a0)

	move.l	a0,a1
	move.l	(62,sp),a0
	move.l	(test,pc),a2
	jsr	(a2)
; this returns:
; 0 - everything is ok
; 1 - raise

	tst.l	d0
	beq.b	.exit

	lea	(addy,pc),a0
	move.l	(62,sp),(a0)	; store pc

	; get vbr 68000-68060 compatible
	suba.l	a1,a1
	movea.l	$4.w,a6
	move.w	($128,a6),d0	; ExecBase.AttnFlags
	btst	#0,d0		; 68010+?
	beq.b	.xvbr
	movec	VBR,a1
.xvbr
	; now enshort the tracing routine to be as small as possible
	; by setting the tracing exception vector to rte instruction only
	lea	(ski,pc),a0
	move.l	a0,($24,a1)
.ok
.exit	movem.l	(sp)+,d0-a6
ski	rte

addy	dc.l	0
reglist	ds.l	17
	xref	_exe
