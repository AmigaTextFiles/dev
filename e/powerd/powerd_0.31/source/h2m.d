//
// h2m.d - c include into d ascii module converter by Martin <MarK> Kuchinka (2000-2002)
//
// history:
// 1.0 initial release
//
// 1.1 1.7.2000
//   - added enumerations
//
// 1.2 18.11.2000
//   - '*' doesn't have to be right before the name in structure definition
//
// 1.3 14.1.2001
//   - now the source name can contain the '.h'
//   - now removes the 'xxx_' in 'xxx_yyy' in item names
//   - added recognition for function pointers in structures, requires dc v0.17 or newer
//   - added typedef support, requires dc v0.17 or newer
//
// 1.4 10.2.2001
//   - structs defined by union keyword are now recognised
//
// 1.5 19.6.2001
//   - improved reading of structures
//   - 'short' and 'unsigned xxx' types supported
//
// 1.6 7.7.2001
//   - #if defined(xxx) in now recognized as #ifdef xxx
//   - typedefs as items in structures doesn't freeze anymore (I hope)
//   - typedef like structure supported
//
// 1.7 30.9.2001
//   - removed result typing in function pointers defined in structures
//   - added the #undef support
//
// 1.8 21.1.2002
//   - structs enclosed with it's names are now supported
//
// 1.9 29.5.2002 (reported by Michel Bagmeijer)
//   - fixed conversion: text0x39 was translated to text$39
//   - items in structs now supports mutlidimensional arrays (upto 3d)
//   - added unsigned int type
//
// 1.10 16.8.2002 (reported by Michel Bagmeijer)
//   - small fix in macro reading
//// - enum can now read computed values
//
// todo:
//   - macros inside the structure/typedef
// macro to constant optimizer

OPT	OPTIMIZE

MODULE	'exec/memory'

RAISE	"^C"  IF CtrlC()=TRUE,
		"MEM" IF AllocPooled()=NIL,
		"MEM" IF AllocVecPooled()=NIL

ENUM	SOURCE,NOCOMMENT,OPTIMIZE
SET	F_NOCOMMENT,F_OPTIMIZE

DEF	pool,flags=0,global:PTR TO data

BYTE '\n\n$VER: h2m v1.10 by MarK (\xt \x5d)\n\n\n\0'

PROC main()
	DEF	args:PTR TO LONG,ra,
			name[256]:STRING,dest[256]:STRING,
			src:PTR TO CHAR,l,f=NIL,data
	args:=[NIL,FALSE,FALSE]:LONG
	IFN ra:=ReadArgs('SOURCE/A,NC=NOCOMMENT/S,O=OPTIMIZE/S',args,NIL) THEN Raise("DOS")
	IF StrCmp(args[SOURCE]+StrLen(args[SOURCE])-2,'.h')
		StrCopy(name,args[SOURCE])
		StrCopy(dest,args[SOURCE])
		dest[StrLen(dest)-1]:="m"
	ELSE
		StringF(name,'\s.h',args[SOURCE])
		StringF(dest,'\s.m',args[SOURCE])
	ENDIF
	IF args[NOCOMMENT] THEN flags:=F_NOCOMMENT
	IF args[OPTIMIZE] THEN flags|=F_OPTIMIZE
	IF (l:=FileLength(name))<=0 THEN Raise("DOS")
	IFN pool:=CreatePool(MEMF_PUBLIC|MEMF_CLEAR,16384,4096) THEN Raise("MEM")
	src:=AllocVecPooled(pool,l+16)
	IF f:=Open(name,OLDFILE)
		Read(f,src,l)
		Close(f)
		f:=NIL
		global:=data:=ReadC(src,l)
	ELSE Raise("DOS")
	IF flags & F_OPTIMIZE THEN Optimize(data)
	IF f:=Open(dest,NEWFILE)
		WriteD(f,data)
		VFPrintF(f,'\n',NIL)
		Close(f)
		f:=NIL
	ELSE Raise("DOS")
EXCEPTDO
	SELECT exception
	CASE "DOS";	PrintFault(IOErr(),'h2m')
	CASE "MEM";	PrintF('\s: not enough memory\n','h2m')
	CASE "EOF";	PrintF('\s: unexpected eof (\d)\n','h2m',exceptioninfo)
	CASE "^C";	PrintF('\s: ***break \s\n','h2m',exceptioninfo)
	CASE "TYP";	PrintF('\s: unknown type (\d)\n','h2m',exceptioninfo)
	CASE "PTR";	PrintF('\s: too deep pointer (\d)\n','h2m',exceptioninfo)
	CASE "STX";	PrintF('\s: syntax error (\d)\n','h2m',exceptioninfo)
	ENDSELECT
	IF f THEN Close(f)
	IF pool THEN DeletePool(pool)
	IF ra THEN FreeArgs(ra)
ENDPROC

OBJECT data
	what:WORD,			// DA...
	next:PTR TO macro

ENUM	DA_None,
		DA_Comment,
		DA_OBJECT,		// struct
		DA_STRUCT,		// struct inside an object
		DA_UNION,
		DA_ITEM,
		DA_ENUM,			// enum
		DA_Macro,
		DA_TDEF,			// typedef
		DA_OConst		// constant generated by optimizer

OBJECT comment OF data
	comment:PTR TO CHAR

OBJECT obj OF data
	name:PTR TO CHAR,
	comment:PTR TO comment,
	item:PTR TO item

OBJECT item OF data
	name:PTR TO CHAR,
	comment:PTR TO comment,
	type:UBYTE,				// DT...
	flags:UBYTE,			// IF...
	size:LONG,
	size2:LONG,
	size3:LONG,
	obj:PTR TO CHAR		// obj/NIL

OBJECT enum OF data
	first:PTR TO const

OBJECT const
	next:PTR TO const,
	name:PTR TO CHAR,
	value:LONG,
	comment:PTR TO comment

SET	IF_UNION,					// item is an UNION
		IF_FUNC

ENUM	DT_VOID,						// cut from dc.e
		DT_LONG,
		DT_ULONG,
		DT_WORD,
		DT_UWORD,
		DT_BYTE,
		DT_UBYTE,
		DT_FLOAT,
		DT_DOUBLE,
		DT_BOOL,
		DT_CUSTOM,					-> object - global field
		DT_PTR,						-> VOID pointer
		DT_DLONG,
		DT_UDLONG,
		DT_STRING,
		DT_BASE,
		DT_FUNC,						// function pointer
		DT_STRUCT					// typedef structure/object

OBJECT macro OF data
	type:WORD,
	name:PTR TO CHAR,
	args:PTR TO CHAR,
	comment:PTR TO CHAR,
	mline:PTR TO mline

ENUM	MT_define,
		MT_include,
		MT_ifdef,
		MT_ifndef,
		MT_endif,
		MT_if,
		MT_else,
		MT_undef

OBJECT mline
	next:PTR TO mline,
	data:PTR TO CHAR,
	comment:PTR TO CHAR

OBJECT typedef OF data
	type:WORD,						// DT...
	obj:PTR TO CHAR,
	name:PTR TO CHAR,				// new type name
	object:PTR TO obj

OBJECT oconst OF data
	name:PTR TO CHAR,
	value:LONG,
	comment:PTR TO comment

PROC ReadC(src:PTR TO CHAR,l)(L)
	DEF	last=NIL:PTR TO data,frst=NIL:PTR TO data,pos=0,
			data:PTR TO data,name[80]:CHAR
	WHILE pos<l
		data:=NIL
		pos:=Crop(src,pos,l)
		IF Word(src+pos)="//"||Word(src+pos)="/*"
//		IF (src[pos]="/"&&src[pos+1]="/")||(src[pos]="/"&&src[pos+1]="*")
			pos,data:=Comment(src,pos,l)
		ELSEIF src[pos]="#"
			pos,data:=Macro(src,pos,l)
		ELSE
			pos:=GetName(name,src,pos,l)
			IF StrCmp(name,'struct')
				pos,data:=OBJECT(src,pos,l)
			ELSEIF StrCmp(name,'union')
				pos,data:=OBJECT(src,pos,l)
			ELSEIF StrCmp(name,'enum')
				pos,data:=ENUM(src,pos,l)
			ELSEIF StrCmp(name,'typedef')
				pos,data:=TYPEDEF(src,pos,l)
			ELSE
				pos++
			ENDIF
			name[0]:="\0"
		ENDIF
		IFN frst THEN frst:=data
		IF  last THEN last.next:=data
		IF  data THEN last:=data
		WHILE last.next DO last:=.next
		CtrlC()
		IF CtrlD() THEN RETURN frst
	EXITIF src[pos]="\0"
	ENDWHILE
ENDPROC frst

// read one or more comments if available
PROC Comment(src:PTR TO CHAR,pos,l)(LONG,PTR TO comment)
	DEF	opos=pos,comment=NIL:PTR TO comment,data:PTR TO CHAR,first=NIL:PTR TO comment,
			last=NIL:PTR TO comment
	WHILE Word(src+pos)="//"
		WHILE src[pos]<>"\n"
			pos++
			CtrlC()
		ENDWHILE
	ELSEWHILE Word(src+pos)="/*"
		REPEAT
			pos++
			CtrlC()
		UNTIL Word(src+pos)="*/"
		pos+=2
	ALWAYS
		IFN flags&F_NOCOMMENT
			comment:=AllocPooled(pool,SIZEOF_comment)
			comment.what:=DA_Comment
			data:=AllocVecPooled(pool,pos-opos+4)
			StrCopy(data,src+opos,pos-opos)
			comment.comment:=data
//			PrintF('(\d) \s\n',opos,data)
			IFN first THEN first:=comment
			IF last THEN last.next:=comment
			last:=comment
		ENDIF
//		pos:=Crop(src,pos,l)
		opos:=pos
	ENDWHILE
ENDPROC pos,first

PROC OBJECT(src:PTR TO CHAR,pos,l,etype=FALSE)(LONG,PTR TO obj)
	DEF	name[80]:CHAR,obj:PTR TO obj,next=TRUE,item:PTR TO item,type,objn:PTR TO CHAR,
			last=NIL:PTR TO item,ptr,opos,func,havename=FALSE
	obj:=AllocPooled(pool,SIZEOF_obj)
	obj.what:=DA_OBJECT
	pos:=Skip(src,pos,l)
	IF src[pos]="{"
		pos++
		havename:=FALSE
	ELSE
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		obj.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(obj.name,name)
		pos:=Crop(src,pos,l)
		pos,obj.comment:=Comment(src,pos,l)
		pos:=Skip(src,pos,l)
		IF src[pos]="{" THEN pos++ //ELSE Raise("STX",pos)
		havename:=TRUE
	ENDIF
//	PrintF('(\d) \s\n',pos,obj.name)
	WHILE next
		opos:=pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l,TRUE)	// read type
//		PrintF('(\d) \s\n',pos,name)
		objn:=NIL
		func:=FALSE
		next:=TRUE

		SELECT TRUE
		CASE StrCmp(name,'int'),StrCmp(name,'long'),StrCmp(name,'LONG')
												type:=DT_LONG
		CASE StrCmp(name,'ULONG');		type:=DT_ULONG
		CASE StrCmp(name,'WORD');		type:=DT_WORD
		CASE StrCmp(name,'void');		type:=DT_VOID
		CASE StrCmp(name,'UWORD');		type:=DT_UWORD
		CASE StrCmp(name,'short');		type:=DT_WORD
		CASE StrCmp(name,'BYTE');		type:=DT_BYTE
		CASE StrCmp(name,'UBYTE'),StrCmp(name,'char')
												type:=DT_UBYTE
		CASE StrCmp(name,'STRPTR');	type:=DT_UBYTE|%100000
		CASE StrCmp(name,'float');		type:=DT_FLOAT
		CASE StrCmp(name,'double');	type:=DT_DOUBLE
		CASE StrCmp(name,'short');		type:=DT_WORD
		CASE StrCmp(name,'unsigned long');	type:=DT_ULONG
		CASE StrCmp(name,'unsigned short');	type:=DT_UWORD
		CASE StrCmp(name,'unsigned char');	type:=DT_UBYTE
		CASE StrCmp(name,'unsigned int');	type:=DT_ULONG
		CASE StrCmp(name,'APTR'),StrCmp(name,'BPTR'),StrCmp(name,'CPTR')
												type:=DT_PTR
		CASE StrCmp(name,'struct');	type:=DT_CUSTOM
			pos:=Skip(src,pos,l)
			IF src[pos]="{"
				pos,item:=OBJECT(src,pos,l,DA_STRUCT)
				pos:=Skip(src,pos,l)
//				PrintF('(\d) \s\n',pos,item.name)
				IFN obj.item THEN obj.item:=item
				IF last THEN last.next:=item
				last:=item
				next:=FALSE
			ELSE
				pos:=GetName(name,src,pos,l)
				objn:=AllocPooled(pool,StrLen(name)+4)
				StrCopy(objn,name)
				pos:=Skip(src,pos,l)
//				PrintF('1(\d) \s\n',pos,item.name)
			ENDIF
		CASE StrCmp(name,'union');		type:=DT_CUSTOM
			pos:=Skip(src,pos,l)
			IF src[pos]="{"
				pos,item:=OBJECT(src,pos,l,DA_UNION)
				pos:=Skip(src,pos,l)
//				PrintF('(\d) \s\n',pos,item.name)
				IFN obj.item THEN obj.item:=item
				IF last THEN last.next:=item
				last:=item
				next:=FALSE
			ELSE
				pos:=GetName(name,src,pos,l)
				objn:=AllocPooled(pool,StrLen(name)+4)
				StrCopy(objn,name)
				pos:=Skip(src,pos,l)
			ENDIF
		DEFAULT;								type:=DT_CUSTOM
			objn:=AllocPooled(pool,StrLen(name)+4)
			StrCopy(objn,name)
			pos:=Skip(src,pos,l)
//			Raise("TYP",opos)
		ENDSELECT

//		PrintF('type=\d\n',type)

		// next is TRUE
		WHILE next
			pos:=Skip(src,pos,l)
			item:=AllocPooled(pool,SIZEOF_item)
			item.what:=DA_ITEM
			item.obj:=objn
			item.type:=type
			IF src[pos]="("
				func:=TRUE
				pos:=Skip(src,pos+1,l)
			ENDIF
			ptr:=0
			WHILE src[pos]="*" DO pos++;	ptr++
			pos:=Skip(src,pos,l)
			IF ptr>4 THEN Raise("PTR",pos)
			item.type|=ptr<<5
			pos:=GetName(name,src,pos,l)
			item.name:=AllocPooled(pool,StrLen(name)+4)
			StrCopy(item.name,name)
//			PrintF('(\d) \s(\d)\n',pos,name,ptr)
			pos:=Crop(src,pos,l)
			IF func
				IF src[pos]=")"
					pos:=Skip(src,pos+1,l)
					IF src[pos]="(" THEN pos:=Skip(src,pos+1,l) ELSE Raise("STX",pos)
					IF src[pos]=")" THEN pos:=Crop(src,pos+1,l) ELSE Raise("STX",pos)
					item.flags|=IF_FUNC
				ELSE
					Raise("STX",pos)
				ENDIF
			ENDIF
//			PrintF('(\d) \s\n',pos,name)
			IF src[pos]="["
				opos:=++pos
				pos:=Find("]",src,pos,l)
				StrCopy(name,src+opos,pos-opos)
				C2D(name)
				item.size:=AllocPooled(pool,StrLen(name)+4)
				StrCopy(item.size,name)
				pos++
			ENDIF
			IF src[pos]="["
				opos:=++pos
				pos:=Find("]",src,pos,l)
				StrCopy(name,src+opos,pos-opos)
				C2D(name)
				item.size2:=AllocPooled(pool,StrLen(name)+4)
				StrCopy(item.size2,name)
				pos++
			ENDIF
			IF src[pos]="["
				opos:=++pos
				pos:=Find("]",src,pos,l)
				StrCopy(name,src+opos,pos-opos)
				C2D(name)
				item.size3:=AllocPooled(pool,StrLen(name)+4)
				StrCopy(item.size3,name)
				pos++
			ENDIF
			pos:=Crop(src,pos,l)
			IF src[pos]=","
				next:=TRUE
				pos++
			ELSE
				next:=FALSE
			ENDIF
			pos:=Crop(src,pos,l)
			pos,item.comment:=Comment(src,pos,l)
			pos:=Skip(src,pos,l)
			IFN obj.item THEN obj.item:=item
			IF last THEN last.next:=item
			last:=item
			CtrlC()
		ENDWHILE
		CtrlC()
	EXITIF src[pos]="}" DO pos:=Crop(src,pos+1,l)
		next:=TRUE
	ENDWHILE
	IF havename=FALSE
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
//		PrintF('(\d) \s\n',pos,name)
		obj.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(obj.name,name)
		pos:=Crop(src,pos,l)
		pos,obj.comment:=Comment(src,pos,l)
	ENDIF
ENDPROC pos,obj

PROC TYPEDEF(src:PTR TO CHAR,pos,l)(LONG,PTR TO typedef)
	DEF	tdef:PTR TO typedef,name[64]:STRING,type,obj=NIL:PTR TO CHAR,object:PTR TO obj
	tdef:=AllocPooled(pool,SIZEOF_typedef)
	tdef.what:=DA_TDEF
	pos:=Skip(src,pos,l)
	pos:=GetName(name,src,pos,l)
	pos:=Skip(src,pos,l)
	SELECT TRUE
	CASE StrCmp(name,'struct')
		pos,object:=OBJECT(src,pos,l,DA_STRUCT)
		object.what:=DA_OBJECT
		type:=DT_STRUCT
		obj:=object.name
		tdef.object:=object
//		PrintF('\s,\d\n',obj,pos)
	CASE StrCmp(name,'int');		type:=DT_LONG
	CASE StrCmp(name,'LONG');		type:=DT_LONG
	CASE StrCmp(name,'ULONG');		type:=DT_ULONG
	CASE StrCmp(name,'float');		type:=DT_FLOAT
	CASE StrCmp(name,'double');	type:=DT_DOUBLE
	CASE StrCmp(name,'short');		type:=DT_WORD
	CASE StrCmp(name,'unsigned long');	type:=DT_ULONG
	CASE StrCmp(name,'unsigned short');	type:=DT_UWORD
	CASE StrCmp(name,'unsigned char');	type:=DT_UBYTE
	DEFAULT;								type:=DT_CUSTOM
		obj:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(obj,name)
	ENDSELECT
	IF type<>DT_STRUCT
		pos:=GetName(name,src,pos,l)
		pos:=Skip(src,pos,l)
		tdef.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(tdef.name,name)
	ENDIF

	tdef.type:=type
	tdef.obj:=obj
ENDPROC pos,tdef

PROC ENUM(src:PTR TO CHAR,pos,l)(LONG,PTR TO ENUM)
	DEF	enum:PTR TO enum,next=TRUE,const:PTR TO const,prev=NIL:PTR TO const
	DEF	name[256]:STRING,value=0,opos
	enum:=AllocPooled(pool,SIZEOF_enum)
	enum.what:=DA_ENUM
	pos:=Skip(src,pos,l)
	pos:=GetName(name,src,pos,l)
	pos:=Skip(src,pos,l)
//	PrintF('\d=\s\n',pos,name)
	IF src[pos]<>"{" THEN Raise("STX",pos) ELSE pos++
	WHILE next
		value:=NIL
		pos:=Skip(src,pos,l)
		const:=AllocPooled(pool,SIZEOF_const)
		IFN enum.first THEN enum.first:=const
		IF prev THEN prev.next:=const

		pos:=GetName(name,src,pos,l)
		const.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(const.name,name)

		pos:=Skip(src,pos,l)
//		PrintF('1=\d\n',pos)
		IF src[pos]="="
//			pos,value:=GetNum(src,pos+1,l)

			opos:=++pos
			pos:=Find(",",src,pos,l)
			StrCopy(name,src+opos,pos-opos)
			C2D(name)
			value:=AllocPooled(pool,StrLen(name)+4)
			StrCopy(value,name)

		ENDIF
//		PrintF('2=\d\n',pos)

		const.value:=value

		pos:=Crop(src,pos,l)
		pos,const.comment:=Comment(src,pos,l)
		pos:=Skip(src,pos,l)
//		PrintF('3=\d\n',pos)

//		PrintF('\s=\s\n',const.name,const.value)

		IF src[pos]=","
			pos++
		ELSEIF src[pos]="}"
			next:=FALSE
			pos++
		ELSE
			Raise("STX",pos)
		ENDIF

//		value++
		prev:=const
	ENDWHILE
ENDPROC pos,enum

PROC Macro(src:PTR TO CHAR,pos,l)(LONG,PTR TO macro)
	DEF	opos,macro=NIL:PTR TO macro,name[80]:STRING,next,ml,
			line:PTR TO mline,last:PTR TO mline,buf[1024]:STRING,cpos
	macro:=AllocPooled(pool,SIZEOF_macro)
	macro.what:=DA_Macro
	pos:=Skip(src,pos,l)
	pos:=GetName(name,src,pos,l)
	IF StrCmp(name,'#define')
		macro.type:=MT_define
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		macro.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(macro.name,name)
		IF src[pos]="("
			opos:=pos
			pos:=Find(")",src,pos,l)
			macro.args:=AllocPooled(pool,pos-opos+4)
			StrCopy(macro.args,src+opos,pos-opos)
		ENDIF
		next:=TRUE
		last:=NIL
		WHILE next
			opos:=pos
			pos:=MaCrop(src,pos,l)
			line:=AllocPooled(pool,SIZEOF_mline)
			StrCopy(buf,src+opos,pos-opos)
			cpos:=C2D(buf)
			ml:=StrLen(buf)+1
			IF cpos<100000 THEN ml-=ml-cpos
			line.data:=AllocPooled(pool,ml+4)
			StrCopy(line.data,buf,ml)
//			PrintF('\s\n',line.data)
			IF src[pos]="\\"
				pos++
				next:=TRUE
				pos:=Crop(src,pos,l)
				pos,line.comment:=Comment(src,pos,l)
			ELSE
				next:=FALSE
				IF cpos<100000 THEN pos,line.comment:=Comment(src,opos+cpos,l)
				pos++				// skip "\n"
			ENDIF
			IFN macro.mline THEN macro.mline:=line
			IF last THEN last.next:=line
			last:=line
			CtrlC()
		ENDWHILE
	ELSEIF StrCmp(name,'#ifdef')
		macro.type:=MT_ifdef
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		macro.name:=AllocPooled(pool,StrLen(name)+4)
		pos:=Skip(src,pos,l)
		StrCopy(macro.name,name)
	ELSEIF StrCmp(name,'#ifndef')
		macro.type:=MT_ifndef
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		macro.name:=AllocPooled(pool,StrLen(name)+4)
		StrCopy(macro.name,name)
	ELSEIF StrCmp(name,'#endif')
		macro.type:=MT_endif
	ELSEIF StrCmp(name,'#include')
		macro.type:=MT_include
		pos:=Skip(src,pos,l)
		IF src[pos]="\q"
			opos:=++pos
			WHILE src[pos]<>"\q" DO pos++
			buf[0]:="*"
			StrCopy(buf+1,src+opos,pos-opos)
		ELSEIF src[pos]="<"
			opos:=++pos
			WHILE src[pos]<>">" DO pos++
			StrCopy(buf,src+opos,pos-opos)
		ENDIF
		ml:=StrLen(buf)
		IF buf[ml-2]="."&&buf[ml-1]="h" THEN buf[ml-2]:="\0"
		macro.name:=AllocPooled(pool,ml+4)
		StrCopy(macro.name,buf)
		pos++				// skip "\q" or ">"
	ELSEIF StrCmp(name,'#if')
		macro.type:=MT_if
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		IF StrCmp(name,'defined') AND src[pos]="("
			pos:=Skip(src,pos+1,l)
			pos:=GetName(name,src,pos,l)
			pos:=Skip(src,pos,l)
			IF src[pos]<>")" THEN Raise("STX",pos)
			macro.type:=MT_ifdef
		ENDIF
		macro.name:=AllocPooled(pool,StrLen(name)+4)
		pos:=Skip(src,pos,l)
		StrCopy(macro.name,name)
	ELSEIF StrCmp(name,'#undef')
		macro.type:=MT_undef
		pos:=Skip(src,pos,l)
		pos:=GetName(name,src,pos,l)
		macro.name:=AllocPooled(pool,StrLen(name)+4)
		pos:=Skip(src,pos,l)
		StrCopy(macro.name,name)
	ELSEIF StrCmp(name,'#else')
		macro.type:=MT_else
	ENDIF
ENDPROC pos,macro

// this function replaces: '->' to '.', '0x' to '$'
PROC C2D(src:PTR TO CHAR)(LONG)
	DEF	spos=0,dpos=0,l=StrLen(src),cpos=100000
	WHILE spos<l		// dpos is always smaller or equal then spos
		IF src[spos]="-"&&src[spos+1]=">"
			src[dpos]:="."
			spos++
		ELSEIF src[spos]="0"&&src[spos+1]="x"
			IFN IsAlpha2Num(src[spos-1])
				src[dpos]:="$"
				spos++
			ELSE
				src[dpos]:=src[spos]
			ENDIF
//		ELSEIF IsHex(src[spos])&&src[spos+1]="L"
		ELSEIF src[spos]>="0"&&src[spos]<="9"&&src[spos+1]="L"
			src[dpos]:=src[spos]
			spos++
		ELSEIF src[spos]>="0"&&src[spos]<="9"&&src[spos+1]="U"&&src[spos+2]="L"
			src[dpos]:=src[spos]
			spos+++
		ELSEIF src[spos]="\q"
			src[dpos]:="\a"
		ELSEIF src[spos]="\a"
			src[dpos]:="\q"
		ELSEIF src[spos]="%"
			src[dpos]:="\\"
		ELSEIF src[spos]="/"&&src[spos+1]="/"
			IF cpos=100000 THEN cpos:=spos
		ELSEIF src[spos]="/"&&src[spos+1]="*"
			IF cpos=100000 THEN cpos:=spos
		ELSE
			src[dpos]:=src[spos]
		ENDIF
		spos++
		dpos++
		CtrlC()
	ENDWHILE
	src[dpos]:="\0"
ENDPROC cpos			// position of comment

PROC WriteD(f,data:PTR TO macro)
	DEF	prev
	WHILE data
		prev:=data
		// this loop removes #ifndef and #endif lines from destination
		WHILE data.what=DA_Macro&&data.type=MT_ifndef
			DEF	next=data.next:PTR TO macro
			IF next
				IF next.what=DA_Macro&&next.type=MT_include
					IF next.next.what=DA_Macro&&next.next.type=MT_endif
						WriteMacro(f,next)
						IF next.next THEN IFN data:=next.next.next THEN RETURN
					ENDIF
				ENDIF
			ENDIF
		EXITIF prev=data
		ENDWHILE
		SELECT data.what
		CASE DA_Comment;	WriteComment(f,data)
		CASE DA_OBJECT;	WriteOBJECT(f,data)
		CASE DA_ENUM;		WriteENUM(f,data)
		CASE DA_Macro;		WriteMacro(f,data)
		CASE DA_TDEF;		WriteTDEF(f,data)
		CASE DA_OConst;	data:=WriteCONST(f,data)
		DEFAULT;				PrintF('\d\n',data.what)
		ENDSELECT
		data:=.next
		CtrlC()
	ENDWHILE
ENDPROC

PROC WriteComment(f,comment:PTR TO comment)
	FPrintF(f,'\s\n',comment.comment)
ENDPROC

PROC WriteOBJECT(f,obj:PTR TO obj,level=0)
	DEF	item:PTR TO item,maxl=0,l

//	PrintF('Yeah(\s)\n',obj.name)

	item:=obj.item
	ReNameAllItems(item)

	// find maximal name length
	WHILE item DO IF (l:=ItemLen(item))>maxl THEN maxl:=l;	item:=.next;	CtrlC()
	IF maxl>80 THEN maxl:=1

	IF level>0 THEN FOR l:=1 TO level FPrintF(f,'\t', NIL)
	IF obj.what=DA_OBJECT
		FPrintF(f,'OBJECT \s',obj.name)
		IF obj.comment
			l:=StrLen(item)+3
			WHILE l<maxl DO l++;	FPrintF(f,' ',NIL)
			WriteD(f,obj.comment)
		ELSE
			FPrintF(f,'\n',NIL)
		ENDIF
	ELSEIF obj.what=DA_UNION
		FPrintF(f,'[CUNION\n',obj.name)
	ELSEIF obj.what=DA_STRUCT
		FPrintF(f,'[\n',obj.name)
	ENDIF

	item:=obj.item
	WHILE item
		IF item.what=DA_UNION||item.what=DA_STRUCT||item.what=DA_OBJECT
			WriteOBJECT(f,item,level+1)
		ELSE
			FOR l:=0 TO level FPrintF(f,'\t', NIL)
			FPrintF(f,'\s',item.name)
			IF item.flags&IF_FUNC
				/*IF (item.type&$1f)<>DT_VOID THEN FPrintF(f,'()(\s\s)',TypeStr(item.type-32),item.obj) ELSE*/ VFPrintF(f,'()')
			ELSE
				IF item.size3
					FPrintF(f,'[\s,\s,\s]',item.size,item.size2,item.size3)
				ELSEIF item.size2
					FPrintF(f,'[\s,\s]',item.size,item.size2)
				ELSEIF item.size
					FPrintF(f,'[\s]',item.size)
				ENDIF
				FPrintF(f,':\s',TypeStr(item.type))
				IF item.obj THEN FPrintF(f,item.obj,NIL)
			ENDIF
		ENDIF
		IF item.next THEN FPrintF(f,',',NIL)
		IF item.comment
			l:=ItemLen(item)
			l-=4
			IFN item.next THEN l--
			WHILE l<maxl DO l++;	FPrintF(f,' ',NIL)
			WriteComment(f,item.comment)
		ELSE
			FPrintF(f,'\n',NIL)
		ENDIF
		item:=.next
		CtrlC()
	ENDWHILE
	IF level>0 THEN FOR l:=1 TO level FPrintF(f,'\t', NIL)
	IF obj.what=DA_OBJECT
		IF level>0
			FPrintF(f,'ENDOBJECT',NIL)
		ELSE
			FPrintF(f,'\n',NIL)
		ENDIF
	ELSEIF obj.what=DA_STRUCT
		FPrintF(f,']:\s',obj.name)
	ELSEIF obj.what=DA_UNION
		FPrintF(f,'ENDUNION]:\s',obj.name)
	ENDIF
ENDPROC

PROC WriteTDEF(f,tdef:PTR TO typedef)
	IF tdef.type<>DT_STRUCT
		FPrintF(f,'TDEF\t\s:\s',tdef.name,TypeStr(tdef.type))
		IF tdef.obj THEN FPrintF(f,'\s\n',tdef.obj)
		FPrintF(f,'\n',NIL)
	ELSE
		IF tdef.object THEN WriteOBJECT(f,tdef.object)
	ENDIF
ENDPROC

PROC ReNameAllItems(first:PTR TO item)
	DEF	pre[16]:CHAR,n=0,len,item=first:PTR TO item

	// find the "_" to get the
	len:=StrLen(item.name)
	WHILE item.name[n]<>"_"
		IF n=>len THEN RETURN
		pre[n]:=item.name[n]
		n++
	ENDWHILE
	pre[n++]:="_"
	pre[n]:="\0"

	WHILE item
		IF StrCmp(item.name,pre,n)=FALSE THEN RETURN
		item:=.next
	ENDWHILE

	item:=first
	WHILE item
		item.name+=n
		item:=.next
	ENDWHILE
ENDPROC

PROC WriteENUM(f,enum:PTR TO enum)
	DEF	const:PTR TO const
	const:=enum.first
	FPrintF(f,'ENUM\t',NIL)
	WHILE const
		IF const<>enum.first THEN FPrintF(f,'\t\t',NIL)
		FPrintF(f,'\s',const.name)
		IF const.value
			FPrintF(f,'=\s',const.value)
		ENDIF
		const:=const.next
		IF const THEN FPrintF(f,',',NIL)
		FPrintF(f,'\n',NIL)
		CtrlC()
	ENDWHILE
	FPrintF(f,'\n',NIL)
ENDPROC

PROC WriteMacro(f,macro:PTR TO macro)
	SELECT macro.type
	CASE MT_define
		DEF	line:PTR TO mline
		FPrintF(f,'#define \s\s',macro.name,macro.args)
		line:=macro.mline
		WHILE line
			FPrintF(f,' \s',line.data)
			IF line.next THEN FPrintF(f,'\\',NIL)
			IF line.comment
				FPrintF(f,'\t',NIL)
				WriteD(f,line.comment)
			ELSE FPrintF(f,'\n',NIL)
			line:=.next
			CtrlC()
		ENDWHILE
	CASE MT_include
		IFN StrCmp(macro.name,'exec/types') THEN FPrintF(f,'MODULE\t''\s''\n',macro.name)
	CASE MT_ifdef
		FPrintF(f,'#ifdef \s\n',macro.name)
	CASE MT_ifndef
		FPrintF(f,'#ifndef \s\n',macro.name)
	CASE MT_endif
		FPrintF(f,'#endif\n',NIL)
	CASE MT_if
		FPrintF(f,'#if \s\n',macro.name)
	CASE MT_undef
		FPrintF(f,'#undefine \s\n',macro.name)
	CASE MT_else
		FPrintF(f,'#else\n',NIL)
	ENDSELECT
ENDPROC

PROC WriteCONST(f,const:PTR TO oconst)(PTR TO oconst)
	FPrintF(f,'CONST\t\s=\d',const.name,const.value)
	IF const.next
		IF const.next.what=DA_OConst
			IF const:=.next
				WHILE const.what=DA_OConst
					FPrintF(f,',\n\t\t\s=\d',const.name,const.value)
				EXITIF const.next=NIL
					const:=.next
				ENDWHILE
			ENDIF
			FPrintF(f,'\n',NIL)
		ENDIF
	ELSE FPrintF(f,'\n',NIL)
ENDPROC const

PROC ItemLen(item:PTR TO item)(L)
	DEF	l,ptr
	l:=IF item.name THEN StrLen(item.name) ELSE 0
	IF item.size THEN l+=StrLen(item.size)+2
	IF item.obj THEN l+=StrLen(item.obj)
	SELECT item.type&$1f										// add ':type'
	CASE DT_PTR;												l+=4
	CASE DT_LONG,DT_WORD,DT_BYTE,DT_BOOL,DT_VOID;	l+=5
	CASE DT_ULONG,DT_UWORD,DT_UBYTE,DT_FLOAT;			l+=6
	CASE DT_DOUBLE;											l+=7
	DEFAULT;														l++
	ENDSELECT
	ptr:=item.type>>5
	l+=ptr*7					// length of 'PTR TO '
ENDPROC l

PROC TypeStr(type)(PTR TO CHAR)
	DEF	str:PTR TO CHAR
	SELECT type
	CASE 1;	str:='LONG'
	CASE 2;	str:='ULONG'
	CASE 3;	str:='WORD'
	CASE 4;	str:='UWORD'
	CASE 5;	str:='BYTE'
	CASE 6;	str:='UBYTE'
	CASE 7;	str:='FLOAT'
	CASE 8;	str:='DOUBLE'
	CASE 9;	str:='BOOL'
	CASE 10;	str:=NIL
	CASE 11;	str:='PTR'
	CASE 12;	str:='DLONG'
	CASE 13;	str:='UDLONG'
	CASE 14;	str:='STRING'

	CASE 33;	str:='PTR TO LONG'
	CASE 34;	str:='PTR TO ULONG'
	CASE 35;	str:='PTR TO WORD'
	CASE 36;	str:='PTR TO UWORD'
	CASE 37;	str:='PTR TO BYTE'
	CASE 38;	str:='PTR TO UBYTE'
	CASE 39;	str:='PTR TO FLOAT'
	CASE 40;	str:='PTR TO DOUBLE'
	CASE 41;	str:='PTR TO BOOL'
	CASE 42;	str:='PTR TO '
	CASE 43;	str:='PTR TO PTR'
	CASE 44;	str:='PTR TO DLONG'
	CASE 45;	str:='PTR TO UDLONG'
	CASE 46;	str:='PTR TO CHAR'

	CASE 65;	str:='PTR TO PTR TO LONG'
	CASE 66;	str:='PTR TO PTR TO ULONG'
	CASE 67;	str:='PTR TO PTR TO WORD'
	CASE 68;	str:='PTR TO PTR TO UWORD'
	CASE 69;	str:='PTR TO PTR TO BYTE'
	CASE 70;	str:='PTR TO PTR TO UBYTE'
	CASE 71;	str:='PTR TO PTR TO FLOAT'
	CASE 72;	str:='PTR TO PTR TO DOUBLE'
	CASE 73;	str:='PTR TO PTR TO BOOL'
	CASE 74;	str:='PTR TO PTR TO '
	CASE 75;	str:='PTR TO PTR TO PTR'
	CASE 76;	str:='PTR TO PTR TO DLONG'
	CASE 77;	str:='PTR TO PTR TO UDLONG'
	CASE 78;	str:='PTR TO PTR TO CHAR'

	CASE 129;str:='LIST OF LONG'
	CASE 130;str:='LIST OF ULONG'
	CASE 131;str:='LIST OF WORD'
	CASE 132;str:='LIST OF UWORD'
	CASE 133;str:='LIST OF BYTE'
	CASE 134;str:='LIST OF UBYTE'
	CASE 135;str:='LIST OF FLOAT'
	CASE 136;str:='LIST OF DOUBLE'
	CASE 137;str:='LIST OF BOOL'
	CASE 138;str:='LIST OF '
	CASE 139;str:='LIST OF PTR'
	CASE 140;str:='LIST OF DLONG'
	CASE 141;str:='LIST OF UDLONG'
	CASE 142;str:='LIST OF CHAR'
	DEFAULT;	str:='VOID'
	ENDSELECT
ENDPROC str

PROC GetNum(s:PTR TO CHAR,n=0,l)(LONG,LONG)
	DEF	num=0,sign=1
	WHILE s[n]="\t" OR s[n]="\n" OR s[n]=" " DO n++
	IF s[n]="-"
		sign:=-1
		n++
	ENDIF
	IF s[n]="0" AND s[n+1]="x"									// HEXADECIMAL number
		n+++
		WHILE s[n]>="0" AND s[n]<="9"
			num<<=4
			num|=s[n]-"0"
		ELSEWHILE s[n]>="a" AND s[n]<="f"
			num<<=4
			num|=s[n]-"a"+10
		ELSEWHILE s[n]>="A" AND s[n]<="F"
			num<<=4
			num|=s[n]-"A"+10
		ALWAYS
			n++
			IF n>l THEN Raise("EOF",n)
		ENDWHILE
	ELSE																// DECIMAL number
		WHILE s[n]>="0" AND s[n]<="9"
			num*=10
			num+=s[n]-"0"
			n++
			IF n>l THEN Raise("EOF",n)
		ENDWHILE
	ENDIF
ENDPROC n,num*sign

PROC GetName(name:PTR TO CHAR,src:PTR TO CHAR,pos,length,istype=FALSE)(L,PTR)
	DEF i=0,c=1
	IF name
		IF IsAlpha2(src[pos])
			WHILE c
				WHILE IsAlpha2Num(src[pos])
					name[i]:=src[pos]
					pos++
					i++
					CtrlC()
					IF pos>length THEN Raise("EOF",pos)
				ENDWHILE
				name[i]:="\0"
				c--
				IF istype
					IF StrCmp(name,'unsigned')
						name[i++]:=" "
						pos:=Skip(src,pos,length)
						c:=1
					ENDIF
				ENDIF
			ENDWHILE
		ENDIF
	ELSE
		IF IsAlpha2(src[pos])
			WHILE IsAlpha2Num(src[pos])
				pos++
				CtrlC()
				IF pos>length THEN Raise("EOF",pos)
			ENDWHILE
			name:=TRUE
		ENDIF
	ENDIF
ENDPROC pos,name

PROC GetString(str:PTR TO CHAR,src:PTR TO CHAR,pos,length)(L,PTR)
	DEF i=0
	IF (src[pos]=34)||(src[pos]="<")
		pos++
		WHILE (src[pos]<>34)&&(src[pos]<>">")
			str[i]:=src[pos]
			pos++
			i++
			CtrlC()
			IF pos>length THEN Raise("EOF",pos)
		ENDWHILE
		str[i]:="\0"
		pos++				// skip ",>
	ENDIF
ENDPROC pos,str

PROC Find(char,src:PTR TO CHAR,pos,length)(L)
	WHILE src[pos]<>char
		pos++
		CtrlC()
		IF pos>length THEN Raise("EOF",pos)
	ENDWHILE
ENDPROC pos

PROC FindTDEF(item:PTR TO typedef,name:PTR TO CHAR)(BOOL)
	WHILE item
		IF item.what=DA_TDEF
			IF StrCmp(item.name,name) THEN RETURN TRUE
		ENDIF
		CtrlC()
		item:=.next
	ENDWHILE
ENDPROC FALSE

PROC IsAlpha2(char)(L) IS IF ((char>="A")&&(char<="Z"))||((char>="a")&&(char<="z"))||(char="_")||(char="#") THEN TRUE ELSE FALSE
PROC IsAlpha2Num(char)(L) IS IF ((char>="A")&&(char<="Z"))||((char>="a")&&(char<="z"))||(char="_")||((char>="0")&&(char<="9"))||(char="#") THEN TRUE ELSE FALSE
PROC IsFirstNum(char)(L) IS IF ((char>="0")&&(char<="9"))||(char=".")||(char="$")||(char="%")||(char="-") THEN TRUE ELSE FALSE

// skip whitespaces and comments
PROC Skip(src:PTR TO CHAR,pos,length)(L)
	DEF done=FALSE,char
	REPEAT
		char:=src[pos]
		IF char=" "
			pos++
		ELSEIF char="\t"
			pos++
		ELSEIF char=";"
			pos++
		ELSEIF char="\n"
			pos++
		ELSEIF char="/"
			IF src[pos+1]="*"
				pos++
				REPEAT
					pos++
					IF pos>length THEN RETURN pos
				UNTIL (src[pos-1]="*")&&(src[pos]="/")
				pos++
			ELSEIF src[pos+1]="/"
				pos++
				REPEAT
					pos++
					IF pos>length THEN RETURN pos
				UNTIL (src[pos]="\n")||((src[pos-1]="/")&&(src[pos]="/"))
				pos++
			ELSE
				done:=TRUE
			ENDIF
		ELSE
			done:=TRUE
		ENDIF
		IF pos>length THEN Raise("EOF",pos)
	UNTIL done=TRUE
ENDPROC pos

// skip whitespaces only
PROC Crop(src:PTR TO CHAR,pos,length)(L)
	DEF done=FALSE,char
	REPEAT
		char:=src[pos]
		IF char=" "
			pos++
		ELSEIF char="\t"
			pos++
		ELSEIF char=";"
			pos++
		ELSEIF char="\n"
			pos++
		ELSE
			done:=TRUE
		ENDIF
		IF pos>length THEN Raise("EOF",pos)
	UNTIL done=TRUE
ENDPROC pos

PROC MaCrop(src:PTR TO CHAR,pos,length)(L)
	DEF	cpos=-1,qpos=-1,apos=-1
	WHILE src[pos]<>"\n"
		IF src[pos]="/" AND src[pos+1]="/" THEN cpos:=0
		IF src[pos]="/" AND src[pos+1]="*" THEN cpos:=0
		IF src[pos]="*" AND src[pos+1]="/" THEN cpos:=-1
		IF src[pos]="\q" THEN qpos:=~qpos
		IF src[pos]="\a" THEN apos:=~apos
		IF src[pos]="\\" THEN IF cpos=-1 AND qpos=-1 AND apos=-1 THEN RETURN pos
		pos++
		IF pos>length THEN Raise("EOF",pos)
	ENDWHILE
ENDPROC pos

PROC Optimize(first:PTR TO data)(PTR)
	DEF	prev=NIL:PTR TO data,data=first:PTR TO data,cnst:PTR TO oconst
	DEF	macro:PTR TO macro,mline:PTR TO mline,bool:BOOL,flt:BOOL,value

	// change all number-only macros to constants
	WHILE data
		IF data.what=DA_Macro
			macro:=data
			IF macro.type=MT_define && macro.args=NIL
				IF mline:=macro.mline
					IF mline.next=NIL
						IF bool,flt:=CheckNumber(mline.data)
							IFN flt
								cnst:=AllocPooled(pool,SIZEOF_oconst)
								cnst.what:=DA_OConst
								cnst.next:=data.next
								cnst.name:=macro.name
								value:=Val(mline.data)
								cnst.value:=value
								cnst.comment:=mline.comment
								IF prev THEN prev.next:=cnst ELSE first:=cnst
								data:=cnst
							ENDIF
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		prev:=data
		data:=.next
		CtrlC()
	ENDWHILE
ENDPROC first

PROC CheckNumber(str:PTR TO CHAR)(BOOL,BOOL)
	DEF	number=TRUE:BOOL,n=0,float=FALSE:BOOL
	n:=Crop(str,0,StrLen(str))
	IF IsFirstNum(str[n])
		n++
		WHILE str[n]
			IF IsHex(str[n])
			ELSEIF str[n]=".";	float:=TRUE
			ELSE number:=FALSE
			n++
		ENDWHILE
	ELSE number:=FALSE
ENDPROC number,float

PROC ComputeMacro(first:PTR TO data,macro:PTR TO macro)
	DEF	line:PTR TO mline,name[64]:STRING,pos,len,npos
	DEF	value
	line:=macro.mline
	WHILE line
		pos:=0
		len:=StrLen(line.data)
//		pos:=Crop(line.data,pos,len)
		value:=0
		WHILE (npos:=GetName(name,line.data,pos,len))>pos
			SELECT TRUE
			CASE StrCmp(name,'TAG_USER');	value|=$80000000
			DEFAULT
			ENDSELECT
		ENDWHILE
		line:=.next
		CtrlC()
	ENDWHILE
ENDPROC
