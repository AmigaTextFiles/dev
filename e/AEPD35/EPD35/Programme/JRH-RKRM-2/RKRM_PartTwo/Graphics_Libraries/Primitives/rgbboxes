-> appkeymap.e - Subroutines to copy the default keymap, modify the copy
->
-> Usage: (PTR TO keymap) appkeymap:=createAppKeyMap()
->        PROC deleteAppKeyMap(appkeymap:PTR TO keymap)
->
-> This example modifies the copied keymap by unmapping all of the numeric
-> keypad keys.  This creates a good keymap for use with either keymap.library
-> MapANSI() or commodities InvertString().  If you used a default keymap with
-> the above functions, numeric keypad raw key values would be returned for
-> keys which are available with fewer keypresses on numeric pad than on the
-> normal keyboard.  It is generally preferable to have the normal keyboard
-> raw values since many applications attach special meanings to numeric pad
-> keys.  The AlterAppKeyMap() routine in this module could easilty be
-> modified to instead set new values for numeric pad or function keys.
->
-> IMPORTANT: Do Not Use SetKeyMapDefault() unless you are a system
-> preferences editor OR an application that takes over the machine.  If you
-> want to use a customized keymap such as this in your application, open your
-> own Intuition window, attach a console device to it, and then use the
-> console device SETKEYMAP command to set your console device unit to your
-> custom keymap.

->>> Header (globals)
OPT MODULE

MODULE 'keymap',
       'devices/keymap'

ENUM ERR_NONE, ERR_ASK, ERR_LIB

RAISE ERR_ASK IF AskKeyMapDefault()=NIL,
      ERR_LIB IF OpenLibrary()=NIL

-> Raw keys we might want to remap which are the same on all keyboards
EXPORT ENUM UP_KEY=$4C, DOWN_KEY, RIGHT_KEY, LEFT_KEY, F1_KEY, F2_KEY, F3_KEY,
       F4_KEY, F5_KEY, F6_KEY, F7_KEY, F8_KEY, F9_KEY, F10_KEY

EXPORT CONST N0_KEY=$0F, N1_KEY=$1D, N2_KEY=$1E, N3_KEY=$1F, N4_KEY=$2D,
             N5_KEY=$2E, N6_KEY=$2F, N7_KEY=$3D, N8_KEY=$3E, N9_KEY=$3F

EXPORT CONST NPERIOD_KEY=$3C, NOPAREN_KEY=$5A, NCPAREN_KEY=$5B, NSLASH_KEY=$5C,
             NASTER_KEY=$5D,  NMINUS_KEY=$4A,  NPLUS_KEY=$5E,   NENTER_KEY=$43

EXPORT CONST RETURN_KEY=$44, HELP_KEY=$5F

-> Count of elements in keymap arrays
EXPORT CONST MAP_SIZE=64, TYPE_SIZE=64, CAPS_SIZE=8, REPS_SIZE=8
EXPORT CONST MAP_SIZE_P=MAP_SIZE*2, TYPE_SIZE_P=TYPE_SIZE*2,
             CAPS_SIZE_P=CAPS_SIZE*2, REPS_SIZE_P=REPS_SIZE*2

-> We allocate our Lo and Hi array pairs each as a single array
EXPORT OBJECT keyMapArrays
   lhKeyMap[MAP_SIZE_P]:ARRAY OF LONG
   lhKeyMapTypes[TYPE_SIZE_P]:ARRAY
   lhCapsable[CAPS_SIZE_P]:ARRAY
   lhRepeatable[REPS_SIZE_P]:ARRAY
ENDOBJECT

DEF karrays:PTR TO keyMapArrays, defkeymap:PTR TO keymap,
    appkeymap:PTR TO keymap, mapsize
->>>

->>> EXPORT PROC createAppKeyMap()
EXPORT PROC createAppKeyMap() HANDLE
  keymapbase:=OpenLibrary('keymap.library', 37)
  defkeymap:=NIL  -> E-Note: help with error trapping
  -> Get a pointer to the keymap which is set as the system default
  defkeymap:=AskKeyMapDefault()
  -> Allocate our KeyMap structures and arrays
  m