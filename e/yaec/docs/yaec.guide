@database e:docs/YAEC_26D_GUIDE
@node main

[0] - YAEC_26D_GUIDE

   @{" 01.Introduction " link __1__}

   @{" 02.Requirements " link __2__}

   @{" 03.Installation " link __3__}

   @{" 04.Distribution_disclaimer " link __4__}

   @{" 05.Usage " link __5__}

   @{" 06.Positron " link __6__}

   @{" 07.Other_things " link __52__}

   @{" 08.Files " link __59__}

   @{" 09.History " link __60__}

   @{" 0A.Bugs_Todo " link __61__}

   @{" 0B.Author " link __62__}

   @{" 0C.FAQ " link __63__}

@endnode
@node __1__ "01.Introduction"

[1] - YAEC_26D_GUIDE / 01.Introduction

   YAEC tries to be very compatible with
   the original AmigaE Compiler 3.3a By Wouter.
   (see examples/ drawer !)

   This guide tries to cover things that will work
   differently compared to Wouters ec3.3a.

   I assume You already are familiar with the E language,
   if not, You will have to read up on it first, try
   the docs in Wouters ec33a.lha archive.

   Also additions / improvements to the E language (called e+) is mentioned.

   YAEC was programmed from scratch and compiled with Wouters AmigaE 3.3a.
   The goal was to make an Ecompiler that was a bit more modern
   then the old one that was programmed in pure asm.
   Some differences :

   o All Modules are in ASCII format.

   o Improved type system. (massively)

   o As of v2+, binary modules are also supported.

   o Makes use of Frank Willes PhxAss/PhxLnk assembler/linker
     to generate binaries.

   o Completer error-checking.

   o Better error-reporting.

   o Slower at compiling. (oh yeah ? :))

   o Most bugs mentioned in e.guide are gone.

   o + tons of improved details here and there that just came along..

@endnode
@node __2__ "02.Requirements"

[2] - YAEC_26D_GUIDE / 02.Requirements


 Compiler:

   Should work on v37+, 68000
   Recommended : v39, 030/50 + 16 MB
   YAEC needs Frank Willes PhxAss and PhxLnk
   (Aminet:dev/asm/) to be somewhere in the command-path.
   If its not, add it with the AmigaDOS PATH command.

 Generated exes:

   Minimum v39 (3.0) of the operatingsystem.
   Minimum 68020 cpu and 881 fpu.

@endnode
@node __3__ "03.Installation"

[3] - YAEC_26D_GUIDE / 03.Installation



   !CHANGED!

   Unpack yaec.lha to ram:
   Copy the drawer yaec<version> anywhere.
   Then put in user-startup (or eqvivalent):   

---8<-----

   ASSIGN E: <yaec-drawer>
   
   PATH E:bin 

   ASSIGN yaecmods: E:modules
     
--->8-----
   

@endnode
@node __4__ "04.Distribution_disclaimer"

[4] - YAEC_26D_GUIDE / 04.Distribution_disclaimer

   


   How may YAEC be distributed ?

   The archive (yaec.lha) in an unchanged state may be distributed
   anywhere. Money cannot be made from the distribution.


   Disclaimer :

   The author of YAEC cannot take any responsibility for any kind of
   damage caused by using anything in this archive (yaec.lha).
   Use at your own risk.  

   
   
@endnode
@node __5__ "05.Usage"

[5] - YAEC_26D_GUIDE / 05.Usage


Usage :

   Commandline options :

   SOURCE/A          - required, the source file name.

   NILCHECK/S        - insert code to check for nil-ptrs.

   PTRCHECK/S        - like above, but more strict.
                       Does Throw("PTR", linenumber) for
                       ptrs with values below 4096, including
                       all negative values.

   HOLD/S            - waits for a RETURN before exiting.

   WB/S              - flips the workbench screen to front.

   OPTI/S            - enable maximum optimisation.
                       currently sets assembler to max opti.

   SHOWFILENAME/S    - shows the name of SOURCE file in the output.

   TCL/N             - typechecklevel (-1/0/1). 0 is default.
                       -1 : Reduces "compatible type" to ANY.
                       (rare use. 1 is not very useable for now)

   LINKARGS/K        - optional linker args.
                       not normally needed.

   ASMARGS/K         - optional assembler args.
                       not normally needed.

   DEFINE/K          - #define global macro(s) without parameters or body.
                       ex : DEFINE DEBUG
                       Macro is visible to any source.
                       v2.2 : Multiple defines separated with "-".

   INDEXCHECK/S      - check index-expressions in arrays/lists/strings.
                       does Throw("INDX", line) if iexp is <0 OR >maxindex.

   STACKCHECK/S      - check early in procedures that the stack is
                       not getting too small.
                       does Throw("STCK", line) if it is.

   CHECK/S           - just check source without generating any code.
                       (binary modules might get created on success)

   SHOW/S            - for modules only. generates showmodule-like output.

   NOBINARYUPDATE/S  - binary (.b) modules will not get created.

   ASCIIFIRST/S      - only use binary (.b) when ascii (.m) is not available.

   SNAPSHOT/S        - for ascii modules only. creates a *static* binary
                       module (.b). See below..

   DIR/K             - alternative moduledir. (default : E:modules/)

   DEPENDENCIES      - Shows dependancy between modules.



Filenames :

   YAEC handles files ending with .e .m and .b

   .e
   This is the extension for main, linkobject and library sources.

   .m
   This is the extension for modules (ascii).

   .b
   This is the extension for binary modules.

   If YAEC is given a filname without an extension,
   it tries to open the file in this order (.e .m .b).

   Compiling an .m file from the commandline automatcally
   creates a .b file (after compilation and everything went well).

   What happens if trying to compile a .b (binary) file ?
   It will not be compiled! What will happen is that
   a showmodule-like output is generated to stdout.

Operation:

   YAEC may work in ascii-only mode, binary only (modules) or mixed.
   When searching for a module that is used by the "top"
   module or main-source, binary (.b) modules will be
   loaded if available, else the ascii one (.m) is loaded.
   (.e named modules works too for compability)

   V2.2+ :

   YAEC now automatically takes the newest file if both ascii and binary
   versions exists. If ascii is newer, it will be loaded and if all went
   well, a binary file gets created. Next time the binary file will be loaded.
   (as it is now the newest).

   V2.5+ :

   There now is a *static* moduleformat also, to complement the
   *dynamic* one. Static modules are created manually with the
   SNAPSHOT/S commandline option. Great for system-modules and
   similar. For now only information about OBJECT,CONST,SET,ENUM,
   MACRO and #define will be saved.
   Advantages: much faster as submodules need not
               be loaded/compiled. Uses less mem.
   Disadvantages: changing submodules will have no
                  effect at all without recompilation.
   In SHOW mode, you will see "(s)" after the modulename, which
   means module is static.


   An example source tree :

   application.e
   mygui.m
   supportfunctions.b
   e:modules/
             gadtools.b
             libraries/
                       gadtools.b

   Check hole application :  (sources may be binary/ascii or mixture)
   > yaec CHECK application

   Compile hole application : (sources may be binary/ascii or mixture)
   > yaec application

   Check module : (create .b) (sub-modules will also be checked)
   > yaec mygui

   Show binary module :
   > yaec supportfunctions

   Its quite simple, .e-files gets compiled by default,
                     .m-files gets checked by default (on success, creates .b),
                     .b-files gets showed by default.


   For those interested, binary modules always starts with "BMOD".
   Other than that, the format of binary modules is private and
   under construction.


@endnode
@node __6__ "06.Positron"

[6] - YAEC_26D_GUIDE / 06.Positron

   @{" 1.Type-system " link __7__}

   @{" 2.Misc " link __27__}

   @{" 3.OOP " link __41__}

   @{" 4.List-unification " link __48__}

   @{" 5.String-unification " link __49__}

   @{" 6.Compability " link __50__}

   @{" 7.Other " link __51__}

@endnode
@node __7__ "1.Type-system"

[7] - 06.Positron / 1.Type-system

   @{" 1.New_Types " link __8__}

   @{" 2.Type-conflicts " link __9__}

   @{" 3.Typed_Assignment " link __10__}

   @{" 4.Parameter-passing " link __11__}

   @{" 5.Typed_Internal_Functions " link __12__}

   @{" 6.Typed_Procedures-Methods " link __22__}

   @{" 7.Cloning_With_NEW " link __23__}

   @{" 8.Argument-types " link __24__}

   @{" 9.Using_floats " link __25__}

   @{" A.Compatible_types-table " link __26__}

@endnode
@node __8__ "1.New_Types"

[8] - 1.Type-system / 1.New_Types

   ANY   --   32 bit typeless (or untyped)
              May be indexed as PTR TO CHAR.
              ++/-- : steps of 1.
              This is the default "type".
              May be substitute for any other type.

   example : DEF x, y:ANY -> both are of type ANY.


   LONG  --   32 bit integer. May not be indexed.
              ++/-- : steps of 1.

   FLOAT --   32 bit IEEE float.
              
   ARRAY/PTR TO versions of above exists too.


   PTR TO STRING  --  32 bit ptr to STRING
                      ++/-- : not allowed.
                      May be indexed as PTR TO CHAR.

   PTR TO LIST    --  32 bit ptr to LIST
                      ++/-- : not allowed.
                      May be indexed as PTR TO ANY.

   Theese last two may be used in OBJECTs, which is not
   the case with STRING/LIST.
   

   PROC  --  32 bit ptr to procedure.
             May not be indexed.
             ++/-- : not allowed.

   QUOTE  --  32 bit ptr to quoted expression.
              May not be indexed.
              ++/-- : not allowed.

   No PTR TO / ARRAY versions of theese last two.


   V2.5+ :  

   UINT  --  16bit unsigned integer
             ++/-- : steps of 1.             
             May not be indexed.

   BYTE  --  8bit signed integer
             ++/-- : steps of 1.
             May not be indexed.             

   PTR TO / ARRAY versions exists.


   
Basic types are :

   ANY, LONG, CHAR, INT, UINT, BYTE, FLOAT, PTR TO *.

@endnode
@node __9__ "2.Type-conflicts"

[9] - 1.Type-system / 2.Type-conflicts

   1. Whitout types, there can be no type conflicts.

   2. Types may be used to increase functionality.

   3. Types may be used to spot errors.

   -> this will be compiled okey
   ng:=[140, (20+topborder), 200, 12, '_Volume:   ', topaz80,
       MYGAD_SLIDER, NG_HIGHLABEL, vi, 0]:newgadget

   -> but not this
   ng:=[140, (20+topborder), 200, 12, '_Volume:   ', 123.123 ->topaz80,
       MYGAD_SLIDER, NG_HIGHLABEL, vi, 0]:newgadget
   -> we replaced "topaz80" (PTR TO textattr)
   -> with "123.123" (FLOAT)
   -> theese type are not compatible and You will get a "type conflict".

   -> it may be forced to work
   ng:=[140, (20+topborder), 200, 12, '_Volume:   ', Any(123.123) ->topaz80,
       MYGAD_SLIDER, NG_HIGHLABEL, vi, 0]:newgadget
   -> here we "untyped" the float-value, thus it can not cause
   -> type-conflicts and the type-system happily accepts it.

   (This last example is just a way to show the possybilities,
    but dont try it, as something in gadtools.library will surely break :))

   To completely turn off type-checking, use commandline option "TCL -1".
@endnode
@node __10__ "3.Typed_Assignment"

[10] - 1.Type-system / 3.Typed_Assignment

   What it means is that assignment (:=) is type-aware.

   Type-aware means two things :

   1. type-conflicts may be spotted (type-errors)

   2. assignment may be used for big types, such as
      arrays, lists and so on.

   o Type-conflicts

   Compiler will spit out a "type-conflict" if types
   conflict with eachother.

   The special type ANY is not affected by the type-system.

   To define a variable as ANY :

   DEF x, y:ANY -> both are of type ANY.

   Some example of type-conflicts You may make :

   DEF f:FLOAT, a:ARRAY OF CHAR, l[100]:LIST

   f := l -> cannot put a list in a float :)

   a := f -> well.. you get the idea..

   To "detype" an expression in the code :

   Any(exp) -> of rare use


   o Big type assignment

   array := array2
   -> this actually copies conents of "array2" into "array" !!

   array := any
   -> as "any" _may_ be an array, (the compiler can not now for
   -> sure that it is _not_)
   -> conents pointed to by "any" will be copied into "array".

   How did the compiler now how much to copy ?
   It did not get it from "any", no size declared there.
   It got it from the declaration of "array" !

   DEF array[100]:ARRAY OF CHAR

   100 bytes would be copied in this case.

   DEF array2[200]:ARRAY OF CHAR

   still 100 bytes would be copied. there can never be any mem-overwrite.

   any := array2
   -> this would just make "any" point to "array2",
   -> its the only logical thing to do.

   Okey, what if using different types ?

   string := ptr_to_long
   -> this gives type error message.

   But this would be okey :

   string := ptr_to_char
   -> this actually equals "StrCopy(string, ptr_to_char)"

   the other way around would the again just copy a ptr :

   ptr_to_char := string
   -> "ptr_to_char" now points to "string".

   THE LEFTMOST VARIABLE ALWAYS DENOTES HOW ASSIGNMENT SHOULD BE DONE.

   THE RIGHTMOST EXPRESSION JUST HAVE TO BE OF A COMPATIBLE TYPE.

   "ANY" IS TYPELESS AND CAN SUBSTITUTE FOR ANY OTHER TYPE.

   typed copy also works with object.members :
   obj.array := array

   An Example:
   ---------------------------------------------
   DEF array[100]:ARRAY OF INT

   PROC main()
      array := bla()
      <use array>
   ENDPROC

   PROC bla()
      DEF array[100]:ARRAY OF INT
      <fill array with values>
   ENDPROC array
   ----------------------------------------------

   Here we used arrays as they where like any other values.

   There is ONE limitation on returning non-basic types :
   If the returnvalue is located on stack (parameter or local) 
   then the receiver of the returnvalue cannot be a parameter !


   V2.5+ :

   Big type assignment now also applies on typed lists,
   which means we may use objects with arrays in them :

   OBJECT test
      x
      y[5]:ARRAY OF INT
      z
   ENDOBJECT

   DEF x

   x := [100, [1,2,3,4,5]:INT, 10]:test

   Or why not (does the same) :

   DEF x,y
 
   y := [1,2,3,4,5]:INT

   x := [100, y, 10]:test

   So.. what types can be used for the second element in the typed list ?  
   
   As the second element in the object is "ARRAY OF INT" we have some
   choices :

   ANY
   ARRAY OF INT (no kidding ?)
   PTR TO INT   
   ARRAY OF UINT (yep)
   PTR TO UINT
  
   Trying anything else should give us a "type conflict".


   (UINT type introduced in v2.5)
   
@endnode
@node __11__ "4.Parameter-passing"

[11] - 1.Type-system / 4.Parameter-passing

   Parameterpassing is type-aware.

   Assigning parameters to values works similar to @{"typed assignment" link P_typedassign}.
   when it comes to type-checking.

   See @{"Argument types" link P_argtypes} for more info.

   The typechecking may be disabled with the commandline option "TCL -1".
   But it should be of rare use, only for some older sources.
@endnode
@node __12__ "5.Typed_Internal_Functions"

[12] - 1.Type-system / 5.Typed_Internal_Functions

   @{" extra.doc " link __13__}

   @{" float.doc " link __14__}

   @{" gfx.doc " link __15__}

   @{" intui.doc " link __16__}

   @{" io.doc " link __17__}

   @{" list.doc " link __18__}

   @{" mem.doc " link __19__}

   @{" Misc.doc " link __20__}

   @{" str.doc " link __21__}

@endnode
@node __13__ "extra.doc"

[13] - 5.Typed_Internal_Functions / extra.doc

TABLE OF CONTENTS

yaec.extra/Any
yaec.extra/CloneStr
yaec.extra/CloneList
yaec.extra/StrIns
yaec.extra/StrRem
yaec.extra/ObjectSize
yaec.extra/ObjectName
yaec.extra/Hbox
yaec.extra/EndString
yaec.extra/StrFmt
yaec.extra/PutFmt
yaec.extra/Allocs
yaec.extra/Rems
yaec.extra/Stores
yaec.extra/StoresT
yaec.extra/Loads


yaec.extra/Any      yaec.extra/Any

      NAME

         Any  --  untype any expression 

      SYNOPSIS

         Any(exp)

         Any(ANY) (ANY)

      FUNCTION

         Strips away any type information from "exp". 
         This is not a real function and generates no code.
         
      INPUTS

         exp  --  any expression

      RESULTS

         "exp" echoed back but without type-information.

      

yaec.extra/CloneStr       yaec.extra/CloneStr

      NAME

         CloneStr  --  Dynamically make copy of a string.

      SYNOPSIS

         newstring := CloneStr(str, len=ALL)

         CloneStr(PTR TO CHAR, LONG) (PTR TO STRING)

      FUNCTION

         Takes any nil-terminated string and
         makes a dynamic copy. string returned
         is an estring.

      INPUTS

         str  --  a string.

         len  --  optional length.

      RESULTS

         newstring  --  an estring.

      NOTES

         This function equals this code :

         StrCopy(String(IF len=ALL THEN StrLen(str) ELSE len), str)

      SEE ALSO

         CloneList()

      BUGS

yaec.extra/CloneList       yaec.extra/CloneList

      NAME

         CloneList  --  Dynamically make copy of a list.

      SYNOPSIS

         newlist := CloneList(list, len=ALL)

         CloneList(PTR TO LIST, LONG) (PTR TO LIST)

      FUNCTION

         Takes an elist and makes a dynamic copy.
         Can also be used to make a list out of an array.

      INPUTS

         list  --  a list.

         len  --  optional length.

      RESULTS

         newlist  --  an elist.

      EXAMPLE

         /* clone list */
         newlist := CloneList(list)

         /* clone array to list */
         list := CloneList(array, arraysize)

      NOTES

         This function equals this code :

         ListCopy(List(IF len=ALL THEN ListLen(list) ELSE len), list)

      SEE ALSO

         CloneStr()

      BUGS

yaec.extra/StrIns       yaec.extra/StrIns

      NAME

         StrIns  --  Insert string into string

      SYNOPSIS

         estring := StrIns(estring, str, pos=0)

         StrIns(PTR TO STRING, PTR TO CHAR, LONG) (PTR TO STRING)

      FUNCTION

         Inserts "str" into "estring" at pos "pos".

      INPUTS

         estring  --  an estring.

         str      --  any string.

         pos      --  position.

      RESULTS

         estring  --  parameter echoed back.

      NOTES
            
      SEE ALSO

         StrRem()

      BUGS

yaec.extra/StrRem       yaec.extra/StrRem

      NAME

         StrRem  --  remove string from estring

      SYNOPSIS

         estring := StrRem(estring, len, pos=0)

         StrRem(PTR TO STRING, LONG, LONG) (PTR TO STRING)

      FUNCTION

         Removes "len" nr of characters at position "pos" from "estring"

      INPUTS

         estring  --  an estring.

         len      --  nr of characters to remove.

         pos      --  position.

      RESULTS

         estring  --  parameter echoed back.

      NOTES

      SEE ALSO

         StrIns()

      BUGS


yaec.extra/ObjectSize       yaec.extra/ObjectSize

      NAME

         ObjectSize  --  get size of an object with methods

      SYNOPSIS

         size := ObjectSize(object)

         ObjectSize(ANY) (LONG)

      FUNCTION

         Returns size of an e-object with methods (class).

      INPUTS

         object  --  ptr to class

      RESULTS

         size      --  size of object

      NOTES 

      SEE ALSO

         ObjectName()

      BUGS

yaec.extra/ObjectName       yaec.extra/ObjectName

      NAME

         ObjectName  --  get name of an object with methods

      SYNOPSIS

         name := ObjectName(object)

         ObjectName(ANY) (PTR TO CHAR)

      FUNCTION

         Returns name of an e-object with methods (class).

      INPUTS

         object  --  ptr to class

      RESULTS

         name    --  name of object

      NOTES

      SEE ALSO

         ObjectSize()

      BUGS

yaec.extra/Hbox       yaec.extra/Hbox

      NAME

         Hbox  --  draw a rectangle

      SYNOPSIS

         Hbox(x1, y1, x2, y2, col=1)

         Hbox(LONG, LONG, LONG, LONG, LONG) (VOID)

      FUNCTION

         Functions as Box() but the box is not filled.
         (draws a rectangle)

      INPUTS

         x1,y1,x2,y2  --  coordinates for the upper-left and lower-right
                          corners.

         col          --  optional color to use.

      RESULTS

      NOTES

      SEE ALSO

         yaec.gfx/Box()

      BUGS

yaec.extra/EndString       yaec.extra/EndString

      NAME

         EndString  --  deallocate an estring

      SYNOPSIS

         EndString(string)

         EndString(PTR TO STRING) (VOID)

      FUNCTION

         Frees a string previously allocated with
         String() or NEW 'static string..'.

      INPUTS

         string  --  an estring

      RESULTS

      NOTES

         In YAEC strings are allocated from the fast pool
         rather than system. This is why Dispose() can NOT be
         used for this.

         It is safe to pass strings allocated on stack to this function.
         Global :STRINGs are NOT safe at this time.
         Well.. You should not be doing this anyway.. :)

         "string" may be NIL, function will just return.

      SEE ALSO

      BUGS

yaec.extra/StrFmt       yaec.extra/StrFmt

      NAME

         StrFmt  --  format string non-varargs

      SYNOPSIS

         estr := StrFmt(estr, fstr, values)

         StrFmt(PTR TO STRING,PTR TO CHAR,ANY) (PTR TO STRING)

      FUNCTION

         Replaces "\" formatting commands found in "fstr" with
         the corresponding elements in "values". Puts result in
         "estr".

      INPUTS

         estr    --  estring to put formatted string in.

         fstr    --  string containing text and formattingcommands.

              Formatcodes following the formatcode-identifier "\" :

              d  --  decimal value

              h  --  hexadecimal value

              s  --  string

              c  --  character

              f  --  float value (v1.9+)

                 Nr of decimals defaults to one.
                 May be followed by punctation and number of decimals
                 Ex : f.3 -> three decimals
                      f.0 -> zero decimals (no punctation).

              z  --  zero-fill (switch)

              l  --  left justification (switch)

              r  --  right justification (sitch)

              Formatcodes d,h,s,f may be followed by field-specifier :

              [fieldsize]    Ex : s[10]

         values  --  should point to an array of longwords.

      RESULT

         estr    --  parameter echoed back.

      EXAMPLE

         StrFmt(estr, 'ive got \d cents in my \s\n', [10, 'pocket'])

      NOTES

         This function does not use exec.library/RawDoFmt(),
         instead custom routines are used to achive maximum
         performance. Its atleast 5-10 times faster.

         If You dont belive me ...:) .. compile examples/showhunk.e.
         Its disasm-output to ram: is eleven (11) times faster !!

         This function is also used by
         StringF(), PutFmt(), PrintF(), WriteF(), RealF()

         "(x,y)" is not supported. -> poke me if its important :)

         The floating-point parts should not use any instructions
         that is missing in the 040 FPU ; no sw emulating = more speed.

      SEE ALSO

         StringF(), PutFmt(), PrintF(), WriteF(), RealF()

      BUGS




yaec.extra/PutFmt       yaec.extra/PutFmt

      NAME

         PutFmt  --  formatted print non-varargs

      SYNOPSIS

         len := PutFmt(fstr, values, output=NIL)

         PutFmt(PTR TO CHAR,ANY,ANY) (LONG)

      FUNCTION

         Prints formatted string (buffered) to the default output.


      INPUTS

         fstr    --  See StrFmt()

         values  --  See StrFmt()

         output  --  optional output.

                        NIL (default) : prints to stdout (if possible).
                        -1            : prints to dos.library/Output().
                        filehandle    : prints to filehandle.

      RESULT

         len    --  length of string printed.

      EXAMPLE

         PutFmt('hello \s\n', ['world'])
         -> prints to stdout

         PutFmt('ive got \d cents in my \s\n', [10, 'pocket'], fh)
         -> prints string to "fh".

      NOTES

         If output is not specified (or NIL) and stdout is NIL, then this
         function will instead print to dos.library/Output().
         (Handy when in librarymode).

      SEE ALSO

         PrintF(), WriteF()

      BUGS

yaec.extra/Allocs       yaec.extra/Allocs

      NAME

         Allocs  --  allocate from stack

      SYNOPSIS

         ptr := Allocs(size)

         Allocs(LONG) (PTR TO ANY)

      FUNCTION

         Allocates "size" bytes from stack, returns memory.
         "size" is automatically rounded to even 4-byte.
         Memory is NOT cleared.

      INPUTS
      
         size  --  size to allocate from stack

      RESULT

         ptr    --  ptr to allocated memory.

      EXAMPLE
      

      NOTES

         There is no checking against stack overflow!

      SEE ALSO

         Rems(), Stores(), StoresT(), Loads()

      BUGS

yaec.extra/Rems       yaec.extra/Rems

      NAME

         Rems  --  deallocate from stack

      SYNOPSIS

         Rems(size)

         Rems(LONG)

      FUNCTION

         Deallocates "size" bytes from stack, returns stackptr
         after deallocation.
         "size" is automatically rounded to even 4-byte.

      INPUTS

         size  --  size to deallocate from stack

      RESULT

      EXAMPLE

      NOTES

      SEE ALSO

         Allocs(), Stores(), StoresT(), Loads()

      BUGS


yaec.extra/Stores       yaec.extra/Stores

      NAME

         Stores  --  push longword(s) on stack

      SYNOPSIS

         ptr := Stores(lw,...)

         Stores(ANY,...)

      FUNCTION

         Pushes longwords on stack in reverse order.
         This means that Stores(a,b,c) will result in stack looking like :

         (0)a
         (4)b
         (8)c

         It is possible to push arrays, lists and so on, Stores()
         only pushes the PTR in that case.

         See StoresT() if pushing hole big types is desired.

      INPUTS

         lw,..   --  longwords to be pushed

      RESULT

         ptr     --  ptr to array of parameters

      EXAMPLE

      NOTES

         There is no checking against stack overflow!

      SEE ALSO

         Allocs(), Rems(), StoresT(), Loads()

      BUGS

yaec.extra/StoresT       yaec.extra/StoresT

      NAME

         StoresT  --  push items on stack (type aware)

      SYNOPSIS

         ptr := StoresT(item,...)

         StoresT(*,...) (ANY)

      FUNCTION

         Pushes items on stack in reverse order.
         Items may be simple types as CHAR,LONG or
         complex/big types such as object, list etc..
         In either case, the HOLE item is pushed.

      INPUTS

         item,..   --  items to be pushed

      RESULT

         ptr     --  ptr to array of parameters

      EXAMPLE

      NOTES

         There is no checking against stack overflow!

      SEE ALSO

         Allocs(), Rems(), Stores(), Loads()

      BUGS

         Not really implemented yet.


yaec.extra/Loads       yaec.extra/Loads

      NAME

         Loads  --  pop items from stack into variable(s) (type aware)

      SYNOPSIS

         Loads(var,...)

         StoresT(*,...)

      FUNCTION

         Pops items from stack into variable(s)
         This function is type-aware. This means
         that the type(s) of variables will control
         what is poped from stack.

      INPUTS

         var,..   --  variables to pop to

      RESULT

      EXAMPLE

         DEF o:object, x:object

         /* Store object */
         StoresT(object)

         /* Load object */
         Loads(x)

      NOTES

         There is no checking against stack overflow!

      SEE ALSO

         Allocs(), Rems(), Stores(), StoresT()

      BUGS

@endnode
@node __14__ "float.doc"

[14] - 5.Typed_Internal_Functions / float.doc


[To be written..]

@endnode
@node __15__ "gfx.doc"

[15] - 5.Typed_Internal_Functions / gfx.doc


 [To be written..]

@endnode
@node __16__ "intui.doc"

[16] - 5.Typed_Internal_Functions / intui.doc


 [To be written..]

@endnode
@node __17__ "io.doc"

[17] - 5.Typed_Internal_Functions / io.doc

TABLE OF CONTENTS

yaec.io/Inp
yaec.io/Out
yaec.io/SetStdIn
yaec.io/SetStdOut


yaec.io/Inp       yaec.io/Inp

      NAME

            Inp  --  get character from filehandle

      SYNOPSIS

            char := Inp(fh)

            Inp(ANY) (LONG)

      FUNCTION

            Returns a character read from filehandle or -1 for EOF.

      INPUTS

           fh   --   AmigaDOS filehandle

      RESULTS

           len      -- length of list

      NOTES

         Is now buffered.
         Implemented for backwards compability only.
         Please dont use in new programs.


yaec.io/Out       yaec.io/Out

      NAME

            Out  --  put character to filehandle

      SYNOPSIS

            success := Out(fh, char)

            Out(ANY, LONG) (LONG)

      FUNCTION

            Outputs a character to filehandle

      INPUTS

           fh   --   AmigaDOS filehandle

           char --   character to put

      RESULTS

           success  -- length of write, or <> 1 for failure.

      NOTES

         Is now buffered.
         Implemented for backwards compability only.
         Please dont use in new programs.


yaec.io/SetStdIn       yaec.io/SetStdIn

      NAME

            SetStdIn  --  Set global stdin variable

      SYNOPSIS

            oldstdin := SetStdIn(newstdin)

            SetStdIn(ANY) (ANY)

      FUNCTION

            Change the global stdin variable to new filehandle.
            Returns old filehandle.

      INPUTS

           newstdin  --   AmigaDOS filehandle

      RESULTS

           oldstdin  --   AmigaDOS filehandle.


yaec.io/SetStdOut       yaec.io/SetStdOut

      NAME

            SetStdOut  --  Set global stdout variable

      SYNOPSIS

            oldstdout := SetStdOut(newstdout)

            SetStdOut(ANY) (ANY)

      FUNCTION

            Change the global stdout variable to new filehandle.
            Returns old filehandle.

      INPUTS

           newstdout  --   AmigaDOS filehandle

      RESULTS

           oldstdout  --   AmigaDOS filehandle.



@endnode
@node __18__ "list.doc"

[18] - 5.Typed_Internal_Functions / list.doc

TABLE OF CONTENTS

yaec.list/ListLen
yaec.list/ListMax
yaec.list/SetList
yaec.list/ListCmp
yaec.list/ListCopy
yaec.list/ListAdd
yaec.list/List
yaec.list/FastDisposeList
yaec.list/ListItem
yaec.list/Exists
yaec.list/ForAll
yaec.list/MapList
yaec.list/SelectList


yaec.list/ListLen       yaec.list/ListLen

      NAME

            ListLen  --  get length of list

      SYNOPSIS

            len := ListLen(list)

            ListLen(PTR TO LIST) (LONG)

      FUNCTION

            Returns length of an elist.

      INPUTS

            list     --  ptr to list

      RESULTS

            len      -- length of list


yaec.list/ListMax       yaec.list/ListMax

      NAME

            ListMax  --  get maximum length of list

      SYNOPSIS

            len := ListMax(list)

            ListMax(PTR TO LIST) (LONG)

      FUNCTION

            Returns maximum length of an elist.

      INPUTS

            list     --  ptr to list

      RESULTS

            len      -- maxlength of list
   

yaec.list/SetList       yaec.list/SetList

      NAME

            SetList  --  manually set length of list

      SYNOPSIS

            len := SetList(list, len)

            SetList(PTR TO LIST, LONG) (LONG)

      FUNCTION

            Set length of list by hand.

      INPUTS

            list     --  ptr to list

            len      --  new length

      RESULTS

            len      --  parameter echoed back.


yaec.list/ListCmp       yaec.list/ListCmp

      NAME

            ListCmp  --  compare to lists for equality

      SYNOPSIS

            bool := ListCmp(list1, list2, len=ALL)

            ListCmp(PTR TO LIST, PTR TO LIST, LONG) (LONG)

      FUNCTION

            Compare to elists.

      INPUTS

            list1     --  ptr to list

            list2     --  ptr to list

      RESULTS

            bool      --  TRUE if lists where equal, both by
            content and length, else FALSE.

      NOTES

            If len is specified, then list1/2 does not really need
            to be lists, but ptrs to longwords.


yaec.list/ListCopy       yaec.list/ListCopy

      NAME

            ListCopy  --  put content into list

      SYNOPSIS

            list1 := ListCopy(list1, list2, len=ALL)

            ListCopy(PTR TO LIST, PTR TO LIST, LONG) (PTR TO LIST)

      FUNCTION

            Copies list2 into list1.

      INPUTS

            list1     --  ptr to list

            list2     --  ptr to list

            len       --  optional length to copy

      RESULTS

            list1     --  parameter echoed back.

      NOTES

            If len is specified, then list2 does not really need
            to be a list, but a ptr to longwords.

            It is okey to specify a way too big len;
            nothing more than ListMax(list1) will be copied.



yaec.list/ListAdd       yaec.list/ListAdd

      NAME

            ListAdd  --  append content to list

      SYNOPSIS

            list1 := ListAdd(list1, list2, len=ALL)

            ListAdd(PTR TO LIST, PTR TO LIST, LONG) (PTR TO LIST)

      FUNCTION

            Adds list2 to list1.

      INPUTS

            list1     --  ptr to list

            list2     --  ptr to list

            len       --  optional length to add

      RESULTS

            list1     --  parameter echoed back.

      NOTES

            If len is specified, then list2 does not really need
            to be a list, but can be a ptr to any longwords.

            It is okey to specify a way too big len;
            adding will stop when ListLen(list1) = ListMax(list1).


yaec.list/List       yaec.list/List

      NAME

            List  --  dynamically allocate and initialise a list

      SYNOPSIS

            list := List(len)

            List(LONG) (PTR TO LIST)

      FUNCTION

            Returns an empty list, allocated from the fast pool (if possible)

      INPUTS

            len       --  length of list in elements

      RESULTS

            list      --  new list

      NOTES

            If len is > 64 then memory will be allocated
            from system. It is still okey to free it with
            FastDisposeList() or EndList().


yaec.list/FastDisposeList       yaec.list/FastDisposeList

      NAME

            FastDisposeList  --  free a dynamically alocated list.

      SYNOPSIS

            FastDisposeList(listptr)

            FastDisposeList(PTR TO LIST) (VOID)

            /* preferred YAEC style */

            EndList(listptr)

            EndList(PTR TO LIST) (VOID)

      FUNCTION

            Deallocates a list previously allocated with
            List() or NEW [...].

      INPUTS

            listptr  --  list to free

      RESULTS

      NOTES

            It is okey to pass lists allocated on stack to this function.
            It is NOT okey to pass global :LISTs for now.
            You shouldnt be doing this anyway..

      SEE ALSO

      BUGS

yaec.list/ListItem       yaec.list/ListItem

      NAME

            ListItem  --  get a listelement by number

      SYNOPSIS

            item := ListItem(list, itemnum)

            ListItem(PTR TO LIST, LONG) (ANY)

      FUNCTION

            Returns value at position "itemnum" in "list".

      INPUTS

            list     --  list

            itemnum  --  position in list.

      RESULTS

            item     --  value.

      NOTES

            This function roughly equals :
            "item := Long(list+(itemnum*4))"
            (but more efficient)

            There is NO checking if itemnum > ListLen/ListMax(list).
            (ie. list may well be a ptr to any longwords.)


      SEE ALSO

      BUGS

yaec.list/Exists       yaec.list/Exists

      NAME

            Exists  --  traverse threw list until match

      SYNOPSIS

            bool, pos := Exists(list, qexp, qexp2=NIL)

            Exists(PTR TO LIST, QUOTE, QUOTE) (LONG, LONG)

      FUNCTION

            Returns TRUE when an element in list makes
            "qexp" match (evaluates to <> NIL), else FALSE.

            If "qexp2" is defined, then "qexp2" will
            be evaluated and returned on a match.

      INPUTS

            list     --  elist

            qexp     --  quoted expression

            qexp2    --  optional quoted expression

      RESULTS

            bool     --  TRUE if match, else FALSE

            pos      --  the position for element that matched.

      NOTES

            YAEC : Slight API-change, for the better.
                   Gone is the "{var}" parameter; instead the
                   element can be reached from within a quoted
                   expression with "\\1". Position with "\\2".

                   Additions are "qexp2" and "pos".
                   It is also safe to nest theese functions.
      EXAMPLE

            /* find an element containing the value 14 in list */
            Exists(list, `\\1=14, `PrintF('yes, at pos \\d\\n', \\2))

      SEE ALSO

            MapList(), ForAll(), SelectList()

      BUGS

yaec.list/ForAll       yaec.list/ForAll

      NAME

            ForAll  --  check all elements for match

      SYNOPSIS

            bool := ForAll(list, qexp, qexp2=NIL)

            ForAll(PTR TO LIST, QUOTE, QUOTE) (LONG)

      FUNCTION

            Returns TRUE when if all elements in list makes
            "qexp" match (evaluates to <> NIL), else FALSE.

            If "qexp2" is defined, then "qexp2" will
            be evaluated and returned instead of TRUE.

      INPUTS

            list     --  elist

            qexp     --  quoted expression

            qexp2    --  optional quoted expression

      RESULTS

            bool     --  TRUE if all match, else FALSE

      NOTES

            YAEC : Slight API-change, for the better.
                   Gone is the "{var}" parameter; instead the
                   element can be reached from within a quoted
                   expression with "\\1". Position with "\\2".

                   Addition is "qexp2".
                   It is safe to nest theese functions.
      EXAMPLE

            /* print out all strings in list */
            ForAll(['one','two','three'],`WriteF('example: \\s\\n',\\x))

      SEE ALSO

            MapList(), Exists(), SelectList()

      BUGS


yaec.list/MapList       yaec.list/MapList

      NAME

            MapList  --  list to list mapping

      SYNOPSIS

            listvar := MapList(list, listvar, qexp)

            MapList(PTR TO LIST, PTR TO LIST, QUOTE) (PTR TO LIST)

      FUNCTION

            perform action on all elements of "list" and return all
            results in "listvar".

      INPUTS

            list     --  elist

            listvar  --  elist (variable)

            qexp     --  quoted expression

      RESULTS

            listvar  --  parameter echoed back (altered)

      NOTES

            YAEC : Slight API-change, for the better.
                   Gone is the "{var}" parameter; instead the
                   element can be reached from within a quoted
                   expression with "\\1". Position with "\\2".

                   It is safe to nest theese functions.
      EXAMPLE

            MapList([1,2,3,4,5],r,`x*x) -> results r in:  [1,4,9,16,25]

      SEE ALSO

            Exists(), ForAll(), SelectList()

      BUGS

yaec.list/SelectList       yaec.list/SelectList

      NAME

            SelectList  --  conditional list to list mapping

      SYNOPSIS

            listvarlen := SelectList(list, listvar, qexp)

            SelectList(PTR TO LIST, PTR TO LIST, QUOTE) (LONG)

      FUNCTION

            ---e.guide snip----------------------------------------
            Much like MapList(), only now doesn't store the result
            from qexp, it uses it as a boolean value, and only
            those values for which it is true are stored in listvar
            (which should be capable of holding the same amount of
            elements as list).
            --------------------------------------------------------

      INPUTS

            list     --  elist

            listvar  --  elist (variable)

            qexp     --  quoted expression

      RESULTS

            listvarlen  -- (new) length of listvar

      NOTES

            YAEC : Slight API-change, for the better.
                   Gone is the "{var}" parameter; instead the
                   element can be reached from within a quoted
                   expression with "\\1". Position with "\\2".

                   It is safe to nest theese functions.
      EXAMPLE

            SelectList([1,2,0,3,NIL],r,`\\1<>0)
            ->results in r being [1,2,3].

      SEE ALSO

            Exists(), MapList(), ForAll()

      BUGS

@endnode
@node __19__ "mem.doc"

[19] - 5.Typed_Internal_Functions / mem.doc

TABLE OF CONTENTS

yaec.mem/New
yaec.mem/Dispose
yaec.mem/FastNew
yaec.mem/FastDispose


yaec.mem/New       yaec.mem/New

      NAME
            New  --  Allocate memory

      SYNOPSIS
            mem := New(size)

            New(LONG) (ANY)

      FUNCTION
            Allocate cleared memory.

      INPUTS
            size  --  nr of bytes to allocate.

      RESULTS
            mem  --  ptr to allocated memoryblock or NIL.

      NOTES
            Memory flags are MEMF_CLEAR|MEMF_PUBLIC

            All memory allocated will automatically be
            freed at program end. (if not freed with Dispose())

      SEE ALSO
            Dispose(), FastNew(), FastDispose()

      BUGS

yaec.mem/Dispose       yaec.mem/Dispose

      NAME
            Dispose  --  Free memory

      SYNOPSIS
            Dispose(mem)

            Dispose(ANY) (VOID)

      FUNCTION
            Free memory allocated with New().

      INPUTS
            mem  --  memoryblock.

      RESULTS

      NOTES
            YAEC : much, much faster then before.

      SEE ALSO
            New(), FastNew(), FastDispose()

      BUGS

yaec.mem/FastNew       yaec.mem/FastNew

      NAME
            FastNew  --  Fast allocate memory

      SYNOPSIS
            mem := FastNew(size)

            FastNew(LONG) (ANY)

      FUNCTION
            Allocate cleared memory.

      INPUTS
            size  --  nr of bytes to allocate.

      RESULTS
            mem  --  ptr to memoryblock or NIL.

      NOTES
            FastNew() is optimised for memorysizes 1-256 bytes.

            Memory flags are MEMF_CLEAR|MEMF_PUBLIC

            All memory allocated will automatically be
            freed at program end. (if not free with FastDispose())

      SEE ALSO
            New(), Dispose(), FastDispose()

      BUGS

yaec.mem/FastDispose       yaec.mem/FastDispose

      NAME
            FastDispose  --  Fast free memory

      SYNOPSIS
            FastDispose(mem, size)

            FastDispose(ANY, LONG) (VOID)

      FUNCTION
            Free memory allocated with FastNew().

      INPUTS
            mem   --  memoryblock to free.

            size  --  size of memoryblock.

      RESULTS

      NOTES
            Memory is not released to system until program end
            but instead put in a "recylce-bin" for fast reuse.

      SEE ALSO
            New(), Dispose(), FastNew()

      BUGS






@endnode
@node __20__ "Misc.doc"

[20] - 5.Typed_Internal_Functions / Misc.doc

TABLE OF CONTENTS

yaec.misc/Abs
yaec.misc/Bounds
yaec.misc/Char
yaec.misc/CtrlC
yaec.misc/Div
yaec.misc/Eor
yaec.misc/Even
yaec.misc/FileLength
yaec.misc/FreeStack
yaec.misc/Int
yaec.misc/KickVersion
yaec.misc/Long
yaec.misc/Max
yaec.misc/Min
yaec.misc/Mod
yaec.misc/Mul
yaec.misc/Not
yaec.misc/Odd
yaec.misc/PutChar
yaec.misc/PutInt
yaec.misc/PutLong
yaec.misc/Rnd
yaec.misc/RndQ
yaec.misc/Shl
yaec.misc/Shr
yaec.misc/Sign
yaec.misc/Val


yaec.misc/Abs       yaec.misc/Abs

      NAME

         Abs  --  get absolute value

      SYNOPSIS

         absval := Abs(val)

         Abs(LONG) (LONG)

      FUNCTION

         If "val" is negative, subtract it from zero.

      INPUTS

         val     --  value

      RESULT

         absval  --  absolute value

      SEE ALSO

yaec.misc/Bounds       yaec.misc/Bounds

      NAME

         Bounds  --  limit value

      SYNOPSIS

         limval := Bounds(l,h,x)

         Bounds(LONG, LONG, LONG) (LONG)

      FUNCTION

         (roughly)

         IF x < l THEN x := l ELSE IF x > h THEN x := h

      INPUTS

         l    --  lower bound

         h    --  upper bound

         x    --  value to be bounded

      RESULT

         val  --  bounded value

      SEE ALSO
         Max(), Min()


yaec.misc/Char       yaec.misc/Char

      NAME

         Char  --  peek byte

      SYNOPSIS

         val := Char(adr)

         Char(PTR TO ANY) (ANY)

      FUNCTION

      INPUTS

      RESULT

      SEE ALSO

yaec.misc/CtrlC       yaec.misc/CtrlC

      NAME

         CtrlC  --  check if user has pressed CTRL-C

      SYNOPSIS

         bool := CtrlC()

         CtrlC() (LONG)

      FUNCTION

         Returns status of ctrl-c being pressed by user.

      INPUTS

      RESULT

         bool  --  TRUE if user pressed ctrl-c, else FALSE

      SEE ALSO

yaec.misc/Div       yaec.misc/Div

      NAME

         Div  --  integer division

      SYNOPSIS

         x := Div(a,b)

         Div(LONG,LONG) (LONG)

      FUNCTION

         Returns the result of dividing "a" with "b".

      INPUTS

         a  --  value to be divided

         b  --  value to divide "a" with

      RESULT

         x  --  a/b

      SEE ALSO
           
         Mul(), Mod()

yaec.misc/Eor       yaec.misc/Eor

      NAME

         Eor  --  perform logical exclusive or.

      SYNOPSIS

         x := Eor(a,b)

         Eor(LONG,LONG) (LONG)

      FUNCTION

         Returns the result of exclusive or:ing "a" and "b".

      INPUTS

         a  --  first value

         b  --  second value

      RESULT

         x  --  new xor:ed value

      SEE ALSO


yaec.misc/Even       yaec.misc/Even

      NAME

         Even  --  check if value is even

      SYNOPSIS

         bool := Even(v)

         Even(LONG) (LONG)

      FUNCTION

         Returns status of "v" beeing an even value.

      INPUTS

         v     --  value

      RESULT

         bool  --  TRUE if "v" is even, else FALSE

      SEE ALSO

yaec.misc/FileLength       yaec.misc/FileLength

      NAME

         FileLength  --  get length of file

      SYNOPSIS

         len := FileLength(name)

         FileLength(PTR TO CHAR) (LONG)

      FUNCTION

         Returns length of file.

      INPUTS

         name     --  name of file

      RESULT

         len      --  length of file, or -1 for error.

      SEE ALSO


yaec.misc/FreeStack       yaec.misc/FreeStack

      NAME

         FreeStack  --  get size of free stack available

      SYNOPSIS

         size := FreeStack()

         FreeStack() (LONG)

      FUNCTION

         Returns nr of bytes left on the stack.

      INPUTS

      RESULT

         size      --  amount of free stack

      SEE ALSO

yaec.misc/Int       yaec.misc/Int

      NAME

         Int  --  peek word

      SYNOPSIS

         val := Int(adr)

         Int(ANY) (ANY)

      FUNCTION

         Returns word at "adr".

      INPUTS

         adr  --  address to peek.

      RESULT

         val  --  value at "adr"

      NOTES

         Wordsize is 16-bit.
         Function does NO sign-extending!.

         (why is it called "Int()" ?, a bit misleading ..
          how about "Word()" ?
         )

      SEE ALSO

         Char(), Long()

yaec.misc/KickVersion       yaec.misc/KickVersion

      NAME

         KickVersion  --  check if a certain version of OS is available

      SYNOPSIS

         bool := KickVersion(version)

         KickVersion(LONG) (LONG)

      FUNCTION

         Check if a certain version of OS is available

      INPUTS

         ver   --  version to check (37/39/40/...)

      RESULT

         bool  --  TRUE if version is available, else FALSE.

      NOTES

      SEE ALSO

yaec.misc/Long       yaec.misc/Long

      NAME

         Long  --  peek longword

      SYNOPSIS

         val := Long(adr)

         Long(ANY) (ANY)

      FUNCTION

         Returns longword at "adr".

      INPUTS

         adr  --  address to peek.

      RESULT

         val  --  value at "adr"

      NOTES

      SEE ALSO

         Char(), Int()

yaec.misc/Max       yaec.misc/Max

      NAME

         Max  --  get the maximum of two values

      SYNOPSIS

         max := Max(a,b)

         Max(LONG,LONG) (LONG)

      FUNCTION

         Returns the maximum of "a" and "b".

      INPUTS

         a    --  first value

         b    --  second value

      RESULT

         max  --  either "a" or "b" echoed back.

      NOTES

      SEE ALSO

         Min(), Bounds()

yaec.misc/Min       yaec.misc/Min

      NAME

         Min  --  get the minimum of two values

      SYNOPSIS

         max := Min(a,b)

         Min(LONG,LONG) (LONG)

      FUNCTION

         Returns the minimum of "a" and "b".

      INPUTS

         a    --  first value

         b    --  second value

      RESULT

         max  --  either "a" or "b" echoed back.

      NOTES

      SEE ALSO

         Max(), Bounds()

yaec.misc/Mod       yaec.misc/Mod

      NAME

         Mod  --  get the modulo of division

      SYNOPSIS

         r, q := Mod(a,b)

         Mod(LONG,LONG) (LONG,LONG)

      FUNCTION

         Returns the remainder of dividing "a" with "b"
         Optional returnvalue returns the quotient.

      INPUTS

         a  --  value to be divided

         b  --  value to divide "a" with

      RESULT

         r  --  remainder (modulo)

         q  --  quotient

      NOTES

         YAEC : All values are in full 32-bit !

      SEE ALSO

         Mul(), Mod()

yaec.misc/Mul       yaec.misc/Mul

      NAME

         Mul  --  integer multiplication

      SYNOPSIS

         x := Mul(a,b)

         Mul(LONG,LONG) (LONG)

      FUNCTION

         Returns the result of multiplying "a" with "b".

      INPUTS

         a  --  first value

         b  --  second value

      RESULT

         x  --  a*b

      SEE ALSO

         Mod(), Div()

yaec.misc/Not       yaec.misc/Not

      NAME

         Not  --  invert all bits in value

      SYNOPSIS

         x := Not(a)

         Not(LONG) (LONG)

      FUNCTION

         Inverts all bits in "a" and returns it.

      INPUTS

         a  --  value to invert

      RESULT

         x  --  inverted value

      SEE ALSO

yaec.misc/Odd       yaec.misc/Odd

      NAME

         Odd  --  check if value is odd

      SYNOPSIS

         bool := Odd(v)

         Odd(LONG) (LONG)

      FUNCTION

         Returns status of "v" beeing odd.

      INPUTS

         v     --  value

      RESULT

         bool  --  TRUE if "v" is odd, else FALSE.

      SEE ALSO

         Even()


yaec.misc/PutChar       yaec.misc/PutChar

      NAME

         PutChar  --  poke byte

      SYNOPSIS

         PutChar(adr, val)

         PutChar(ANY,ANY)

      FUNCTION

         exactly!

      INPUTS

         adr  --  address to put the byte

         val  --  the value..

      RESULT

      SEE ALSO

         PutInt(), PutLong()

yaec.misc/PutInt       yaec.misc/PutInt

      NAME

         PutInt  --  poke word

      SYNOPSIS

         PutInt(adr, val)

         PutInt(ANY,ANY)

      FUNCTION

         exactly!

      INPUTS

         adr  --  address to put the word

         val  --  the value..

      RESULT

      SEE ALSO

         PutChar(), PutLong()


yaec.misc/PutLong       yaec.misc/PutLong

      NAME

         PutLong  --  poke longword

      SYNOPSIS

         PutLong(adr, val)

         PutLong(ANY,ANY)

      FUNCTION

         exactly!

      INPUTS

         adr  --  address to put the longword

         val  --  the value..

      RESULT

      SEE ALSO

         PutChar(), PutInt()

yaec.misc/Rnd       yaec.misc/Rnd

      NAME

         Rnd  --  compute random number

      SYNOPSIS

         rnum := Rnd(max)

         Rnd(LONG) (LONG)

      FUNCTION

         Computes a random number from the internal seed in range 0...max-1.

         To initialise, call Rnd() with a negative number, the Abs() of
         this number will then be used as the internal seed.

      INPUTS

         adr  --  address to put the longword

         val  --  the value..

      RESULT

      SEE ALSO

         RndQ()

yaec.misc/RndQ       yaec.misc/RndQ

      NAME

         RndQ  --  compute random number, quick

      SYNOPSIS

         seed := RndQ(seed)

         RndQ(LONG) (LONG)

      FUNCTION

         Faster version of Rnd(). Returns only full range 32-bit numbers.
         Use the result as the seed for the next call, and for startseed,
         use any large value like $AF097845.

      INPUTS

         seed  --  seed

      RESULT

         seed  --  random seed

      SEE ALSO

         Rnd()


yaec.misc/Shl       yaec.misc/Shl

      NAME

         Shl  --  logical shift left

      SYNOPSIS

         Shl(y,num)

         Shl(LONG,LONG)

      FUNCTION

         Logically shifts "y" "num" bits to the left.
         New bits are cleared.

      INPUTS

         y     --  value to shift

         num   --  nr of positions to shift

      RESULT

      SEE ALSO

         Shr()

yaec.misc/Shr       yaec.misc/Shr

      NAME

         Shr  --  logical shift right

      SYNOPSIS

         Shr(y,num)

         Shr(LONG,LONG)

      FUNCTION

         Logically shifts "y" "num" bits to the right.
         New bits are cleared.

      INPUTS

         y     --  value to shift

         num   --  nr of positions to shift

      RESULT

      SEE ALSO

         Shl()

yaec.misc/Sign       yaec.misc/Sign

      NAME

         Sign  --  returns the sign of value

      SYNOPSIS

         s := Sign(v)

         Sign(LONG) (LONG)

      FUNCTION

         Returns -1 for negative numbers, 1 for positive numbers, else 0.

      INPUTS

         v    --  value

      RESULT

         s    --  sign of value

      SEE ALSO

         Odd(), Even()


yaec.misc/Val       yaec.misc/Val

      NAME

         Val  --  get integer value out of string

      SYNOPSIS

         val,read := Val(str)

         Val(PTR TO CHAR) (LONG,LONG)

      FUNCTION

         Translates a value encoded in ascii to integer.
         Valid prefixes for the string-value are :
         "$" : hexadecimal
         "%" : binary
         "-" : negative

         Val() calls TrimStr() first thing to skip leading
         spaces, tabs, newlines.

      INPUTS

         str   --  a string containing "value" to parse.

      RESULT

         val   --  integer value.

         read  --  nr of characters read from string, or NIL for failure.

      SEE ALSO






@endnode
@node __21__ "str.doc"

[21] - 5.Typed_Internal_Functions / str.doc

TABLE OF CONTENTS

yaec.str/StrLen
yaec.str/EstrLen
yaec.str/StrMax
yaec.str/SetStr
yaec.str/StrAdd
yaec.str/InStr
yaec.str/LowerStr
yaec.str/UpperStr
yaec.str/StrCopy
yaec.str/MidStr
yaec.str/RightStr
yaec.str/StrCmp
yaec.str/TrimStr
yaec.str/ReadStr
yaec.str/String
yaec.str/EndString


yaec.str/StrLen       yaec.str/StrLen

      NAME

            StrLen  --  get length of string

      SYNOPSIS

            len := StrLen(string)

            StrLen(PTR TO CHAR) (LONG)

      FUNCTION

            Returns the length of any nil-terminated string.

      INPUTS

            string  --  cstring.

      RESULTS

            len     --  length of string.

      NOTES

      SEE ALSO

      BUGS

yaec.str/EstrLen       yaec.str/EstrLen

      NAME

            EstrLen  --  get current length of estring

      SYNOPSIS

            len := EstrLen(estring)

            EstrLen(PTR TO STRING) (LONG)

      FUNCTION

            Returns the current length of any estring,
            including inline ones.

      INPUTS

            estring  --  any estring.

      RESULTS

            len      --  length of estring.

      NOTES

            With yaec, this function can be used on _any_
            strings created within the E language. 

      SEE ALSO

      BUGS

yaec.str/StrMax       yaec.str/StrMax

      NAME

            StrMax  --  get maximum length of estring

      SYNOPSIS

            maxlen := StrMax(estring)

            StrMax(PTR TO STRING) (LONG)

      FUNCTION

            Returns the maximum length of estring.

      INPUTS

            estring  --  :STRING / String()

      RESULTS

            maxlen   --  max length of estring.

      NOTES

      SEE ALSO

      BUGS


yaec.str/SetStr       yaec.str/SetStr

      NAME

            SetStr  --  manually set length of estring

      SYNOPSIS

            len := SetStr(estring, len)

            SetStr(PTR TO STRING, LONG) (LONG)

      FUNCTION

            sets the len-field of an estring,
            as well as putting nil-byte at the rigth place.

            It is safe to set len > maxlen, maxlen will then be used.

      INPUTS

            estring  --  :STRING / String()

            len      --  new length.

      RESULTS

            len      --  the new len of estring.

      NOTES   

            ec3.3a : This function just returns if len > maxlen.

      SEE ALSO

      BUGS


yaec.str/StrAdd       yaec.str/StrAdd

      NAME

            StrAdd  --  append string to estring.

      SYNOPSIS

            estring := StrAdd(estring, str, len=ALL)

            StrAdd(PTR TO STRING, PTR TO CHAR, LONG) (PTR TO STRING)

      FUNCTION

            Add content to an estring.

      INPUTS

            estring  --  :STRING / String()

            str      --  nil-terminated string.

            len      --  length to add, defaults to ALL.

      RESULTS

            estring  --  see above.

      NOTES

      SEE ALSO

      BUGS

yaec.str/InStr       yaec.str/InStr

      NAME

            InStr  --  find string.

      SYNOPSIS

            pos := InStr(str, str2, start=NIL)

            InStr(PTR TO CHAR, PTR TO CHAR, LONG) (LONG)

      FUNCTION

            Find a string in a string.

      INPUTS

            str   --  NIL-terminated string to look in.

            str2  --  NIL-terminated string to find.

            start --  offset into the str, default to NIL.

      RESULTS

            pos   --  the offset at which str2 was found or -1.

      NOTES

      SEE ALSO

      BUGS

yaec.str/LowerStr       yaec.str/LowerStr

      NAME

            LowerStr  --  convert string to lowercase.

      SYNOPSIS

            str := LowerStr(str)

            LowerStr(PTR TO CHAR) (PTR TO CHAR)

      FUNCTION

            convert str to lowercase.

      INPUTS

            str  --  nil-terminated string.

      RESULTS

            str  --  see above.

      NOTES

      SEE ALSO

      BUGS

yaec.str/UpperStr       yaec.str/UpperStr

      NAME

            UpperStr  --  convert str to uppercase.

      SYNOPSIS

            str := UpperStr(str)

            UpperStr(PTR TO CHAR) (PTR TO CHAR)

      FUNCTION

            convert str to uppercase.

      INPUTS

            str  --  nil-terminated str.

      RESULTS

            str  --  parameter echoed back.

      NOTES

      SEE ALSO

      BUGS

  yaec.str/StrCopy       yaec.str/StrCopy

        NAME

              StrCopy  --  put content into estring.

        SYNOPSIS

              estring := StrCopy(estring, string, len=ALL)

              StrCopy(PTR TO STRING, PTR TO CHAR, LONG) (PTR TO STRING)

        FUNCTION

              put content into an estring.

        INPUTS

              estring    --  estring.

              string     --  normal string.

              len        --  length to copy, defaults to ALL.

        RESULTS

              estring    --  parameter echoed back

        NOTES
              
        SEE ALSO

        BUGS

             ec3.3a : forced copylen of 0 did not set estring-len to 0.



yaec.str/MidStr       yaec.str/MidStr

      NAME

            MidStr  --  put content into estring.

      SYNOPSIS

            estring := MidStr(estring, estring2, ofs, len=ALL)

            MidStr(PTR TO STRING, PTR TO STRING, LONG, LONG) (PTR TO STRING)

      FUNCTION

            put content from str+ofs into estring.

      INPUTS

            estring   --  estring.

            estring2  --  estring.

            len       --  length to copy, defaults to ALL.

      RESULTS

            estring  --  parameter echoed back

      NOTES
           
      SEE ALSO

      BUGS

            ec3.3a : copylen of 0 copies ALL.
                     forced copylen of 0 does not set estring-len to 0.


yaec.str/RightStr       yaec.str/RightStr

      NAME

            RightStr  --  copy last n characters

      SYNOPSIS

            estring1 := RightStr(estring1, estring2, n)

            RightStr(PTR TO STRING, PTR TO STRING, LONG) (PTR TO STRING)

      FUNCTION

            copy last n characters fom estring2 to estring1.

      INPUTS

            estring1  --  estring.

            estring2  --  estring.

            n         --  last n characters.

      RESULTS

            estring1  --  parameter echoed back

      NOTES

      SEE ALSO

      BUGS


yaec.str/StrCmp       yaec.str/StrCmp

      NAME

            StrCmp  --  compare two strings (case sensitive).

      SYNOPSIS

            bool := StrCmp(str1, str2, len=ALL)

            StrCmp(PTR TO CHAR, PTR TO CHAR, LONG) (LONG)

      FUNCTION

            perform case sensitive comparison of two strings
            if len=ALL then strings must have same length too.

      INPUTS

            str1  --  cstring.

            str2  --  cstring.

            len   --  length to compare, defaults to ALL.

      RESULTS

            bool  --  TRUE if strings are identical, else FALSE.

      NOTES

            comparison with len=0, always returns TRUE.

      SEE ALSO

      BUGS


yaec.str/TrimStr       yaec.str/TrimStr

      NAME

            TrimStr  --  skip spaces, tabs and linefeeds

      SYNOPSIS

            newstradr := TrimStr(str)

            TrimStr(PTR TO CHAR) (PTR TO CHAR)

      FUNCTION

            advances forward threw str until no spaces,
            tabs or linefeeds are found.

      INPUTS

            str        --  cstring.

      RESULTS

            newstradr  --  trimmed str.

      NOTES

            str returned should NOT be used as estring.
            (or the guru will visit you)

      SEE ALSO

      BUGS


yaec.str/ReadStr       yaec.str/ReadStr

      NAME

            ReadStr  --  Read line from filehandle into estring.

      SYNOPSIS

            bool, read := ReadStr(fh, estring)

            ReadStr(PTR TO filehandle, PTR TO STRING) (LONG, LONG)

      FUNCTION

            reads a string (ending with ascii 10) from filehandle
            into estring.

      INPUTS

            fh      --  AmigaDOS filehandle.

            estring --  estring to read into.

      RESULTS

            bool    --  NIL for success, else -1.

            read    --  length read (estring-len)

      NOTES

            the linefeed (ascii 10) will NOT be read into estring.

            YAEC : ReadStr() now uses buffered routines for reading.
                   Added second returnvalue "read".

      SEE ALSO

      BUGS

yaec.str/String       yaec.str/String

      NAME

            String  --  allocate and initialise an estring

      SYNOPSIS

            estring := String(size)

            String(LONG) (PTR TO STRING)

      FUNCTION

            allocate and initialise an estring.

      INPUTS

            size   --  max size of string to allocate.

      RESULTS

            estring    --  estring, or NIL for failure.

      NOTES

            YAEC : Uses FastNew() for allocating (=faast).
                   This means Dispose() can not be used for
                   deallocating. Instead, use EndString().

                   About 10(!) times faster than before
                   when allocating small (=<240 bytes) strings.

      SEE ALSO

            EndString()

      BUGS

yaec.str/EndString       yaec.str/EndString

      NAME

            EndString  --  deallocate an estring

      SYNOPSIS

            EndString(stringptr)

            EndString(PTR TO STRING) (VOID)

      FUNCTION

            Frees memory taken by the string to pool/system.

      INPUTS

            stringptr   --  string to deallocate

      RESULTS

      NOTES

            YAEC : Uses FastDispose() when deallocating strings =<240 bytes.
                   Its _awful_ fast :)

            This function was born because Dispose() can not be used
            on strings in YAEC.

      SEE ALSO

      BUGS
            





@endnode
@node __22__ "6.Typed_Procedures-Methods"

[22] - 1.Type-system / 6.Typed_Procedures-Methods

   The syntax for this is inspired from PowerD language.

   ex:

   PROC bla(x,y) (LONG) ...

   Tells that this procedure/method returns ONE value
   which is of the type LONG.

   If a function does not return anything, "VOID" may be used :

   PROC compute(a,b) (VOID) ...


   now this is an error (compiler will complain) :

   x := compute(a,b)

   If omitting the optional type-info (like in AmigaE), the procedure/method
   is considered as returning (ANY,ANY,ANY).

   Note : currently, only first returntype is actually used by compiler.
          Rest always have the ANY type.

@endnode
@node __23__ "7.Cloning_With_NEW"

[23] - 1.Type-system / 7.Cloning_With_NEW

   NEW can be used to "clone" variables :
   (just as it may clone static lists, strings, objects)

   DEF array[100]:ARRAY OF LONG, copy, string[100]:STRING

   <fill array with values>

   copy := NEW array

   <put text in string>

   copy := NEW string

   -> "copy" now is an _exact_ copy of "string". _including_ maxlen and all that stuff.

   NEW may as usual raise "MEM" if failing to allocate.

   This works for objects too.

   Another way to clone a string or list :

   clone := CloneStr(stringptr)

   clone := CloneList(listptr)

   This time, only current length is allocated. (maxlen is not preserved).
@endnode
@node __24__ "8.Argument-types"

[24] - 1.Type-system / 8.Argument-types

  
   Arguments are not limited to basic LONGs and PTRs.
   It works very much like typed assignment.

   example:

   PROC bla(l[10]:LIST, o:object, x) 
      <do stuff>

   -> equals :
   PROC bla(li:PTR TO LIST, ob:PTR TO object, x) 
      DEF l[10]:LIST, o:object
      ListCopy(l, li)
      CopyMem(ob, o, SIZEOF object)
      <do stuff>

   -> now lets call it :
   bla(list, object, 10)

   Now, no matter if "list" and "object" are basic or
   non-basic ones, they will get cloned after entering 
   procedure "bla". 

   A parameter always takes up one longword on the stack
   no matter what kind of expression it is and no matter
   what the corresponding argument type is. Very polymorphic.
 

@endnode
@node __25__ "9.Using_floats"

[25] - 1.Type-system / 9.Using_floats

   Well, its simpler to use them now :)


   The key is the FLOAT keyword. Using it gives compiler
   a clue about how to handle it. The old ways of using floats
   are fully supported!

   example :

   DEF f:FLOAT, f2:FLOAT, x, y:LONG

   f := 1.0 -> nothing new here

   f := 10 -> type conflict ! (trying to assign integer to float)

   f := x -> no problemo, x _could_ be a float :)

   f := y -> type conflict (trying to assign integr to float)

   f := f2 * 100.0 -> no need for "!" here :) (f2 sets mode to float)

   x := f2 * 100.0 + f -> okey, as "x" is ANY.

   y := f2 * f ! -> here we used "!" for explicit type-conversion.
                 ->   (float to int)

   y := ! f2 * f ! -> same as above, but AmigaE-style.

   f := f2 * x -> legal float-operation, x _could_ be float

   f := x * f2 -> this is not okey as "x"(ANY) is by default integer
               -> and thereby sets mode to int.


   The first variable in the expression denotes the type.
   If variables of ANY-type are found, they are expected
   to be of the current type (float). Assignment checks
   that both sides do not conflict with eachother.

@endnode
@node __26__ "A.Compatible_types-table"

[26] - 1.Type-system / A.Compatible_types-table


Assignment / parameter passing / return values:


      ANY              ANY/LONG/INT/UINT/CHAR/BYTE/FLOAT/STRING/LIST/
                       ARRAY OF */OBJECT/PTR TO */PROC/QUOTE
                       (all types)

      LONG             ANY/LONG/INT/UINT/CHAR/BYTE

      FLOAT            ANY/FLOAT

      INT              ANY/LONG/INT/UINT/CHAR/BYTE

      UINT             ANY/LONG/UINT/INT/CHAR/BYTE

      CHAR             ANY/LONG/INT/UINT/CHAR/BYTE

      BYTE             ANY/LONG/UINT/INT/BYTE/CHAR

      object           ANY/object/PTR TO object

      LIST             ANY/LIST/PTR TO LIST

      STRING           ANY/STRING/PTR TO STRING

      PTR TO LIST      ANY/PTR TO LIST/LIST/LONG

      PTR TO STRING    ANY/PTR TO STRING/STRING/LONG

      PROC             ANY/PROC/LONG

      QUOTE            ANY/QUOTE/LONG

      PTR TO ANY       ANY/LIST/PTR TO */STRING/ARRAY OF */LONG/OBJECT

      PTR TO LONG      ANY/LIST/ARRAY OF LONG/ARRAY OF ANY/
                       PTR TO LONG/PTR TO ANY/PTR TO LIST/LONG

      PTR TO FLOAT     ANY/LIST/ARRAY OF FLOAT/ARRAY OF ANY/
                       PTR TO FLOAT/PTR TO ANY/PTR TO LIST/LONG

      PTR TO INT       ANY/ARRAY OF INT/ARRAY OF UINT/PTR TO INT/ 
                       PTR TO UINT/LONG

      PTR TO UINT      ANY/ARRAY OF UINT/ARRAY OF INT/PTR TO INT/
                       PTR TO UINT/LONG

      PTR TO CHAR      ANY/STRING/ARRAY OF CHAR/PTR TO CHAR/ARRAY OF BYTE/
                       PTR TO BYTE/PTR TO STRING/LONG

      PTR TO BYTE      ANY/PTR TO BYTE/PTR TO CHAR/ARRAY OF BYTE/
                       ARRAY OF CHAR/LONG

      PTR TO OBJECT    ANY/PTR TO OBJECT/
                       OBJECT/ARRAY OF OBJECT/LONG

      ARRAY OF CHAR    ANY/ARRAY OF CHAR/ARRAY OF BYTE/PTR TO CHAR/
                       PTR TO BYTE/STRING

      ARRAY OF LONG    ANY/ARRAY OF LONG/PTR TO LONG/PTR TO ANY/LIST

      ARRAY OF ANY     ANY/ARRAY OF ANY/ARRAY OF LONG/ARRAY OF FLOAT/
                       LIST/PTR TO FLOAT/PTR TO LONG/PTR TO ANY

      ARRAY OF INT     ANY/ARRAY OF INT/PTR TO INT/
                       ARRAY OF UINT/PTR TO UINT

      ARRAY OF FLOAT   ANY/ARRAY OF FLOAT/ARRAY OF ANY/LIST/
                       PTR TO FLOAT/PTR TO ANY

      ARRAY OF object  ANY/ARRAY OF object/PTR TO object


      Notes:

      "sub-object" may substitute "object"


Math-bitwise : 

      All types except the FLOAT type are considered as LONG.
      The exception to this is ANY, which by default is treated
      as LONG, but will be seen as FLOAT, if we are in float-mode. 
      
Comparison :

      Same as math-bitwise.
     



@endnode
@node __27__ "2.Misc"

[27] - 06.Positron / 2.Misc

   @{" Const_extensions " link __28__}

   @{" EXIT_keyword " link __29__}

   @{" Globals " link __30__}

   @{" Local_labels " link __31__}

   @{" LOOP_keyword " link __32__}

   @{" MACRO_keyword " link __33__}

   @{" Member_inc-dec " link __34__}

   @{" Operator-grouping-precedence " link __35__}

   @{" OPT_keyword " link __36__}

   @{" SELECT_keyword " link __37__}

   @{" Some_new_constants " link __38__}

   @{" STATIC_keyword " link __39__}

   @{" StrFmt-codes " link __40__}

@endnode
@node __28__ "Const_extensions"

[28] - 2.Misc / Const_extensions

   Float constants :

   CONST FLOATVAL=0.1263

   Constant labels knows their type, for example, this would not slip
   threw type-system :

   CONST AAA=10,
      BBB=10.12345,
      CCC=AAA+BBB -> type error!

   not his either :

   x := Max(AAA, BBB) -> type error, "BBB" is not integer.


   To make them OK :

   CONST AAA=10,
            BBB=10.12345,
            CCC=AAA!+BBB  -> CCC= 20.12345

   x := Max(AAA, !BBB!)

   Finally, "<<" and ">>" is allowed in constant expressions.
   (shift left, shift right)

   CONST BLA_B = 16,
         BLA_F = 1 << BLA_B

@endnode
@node __29__ "EXIT_keyword"

[29] - 2.Misc / EXIT_keyword



   EXIT keyword may now be used in any of the loop-constructs :
   FOR-ENDFOR, WHILE-ENDWHILE, REPEAT-UNTIL, LOOP-ENDLOOP.

@endnode
@node __30__ "Globals"

[30] - 2.Misc / Globals

   No more limitations on globals in modules.

   Arrays, objects, lists, defaultvalues, etc..
   all legal :)

   example :
    
      DEF x=9, l[100]:LIST, a[12]:ARRAY OF FLOAT,...
 

Sharing globals:


   To put it simple :

   [EXPORT] DEF ...  -> always allocates global

   IMPORT DEF ...    -> always imports already allocated global

   Importing always imports from main source.

   Exporting always exports to users of our module.


   So there are two ways of sharing the globals.
   
   1. put all globals that is to be shared in a "globals.m" module.
      include (MODULE) module.m to reach globals. 
      (globals.m could have any name, this was an example)

   2. put all globals in main source.
      import globals into modules using them with *DEF.

 (3). or any mixture of above.


   As before, importing means getting a 32bit value/address,
   so arrays/lists/etc have to be turned into PTRs.

   As a concequence of this, even EXPORTed variables may be of 
   other types than LONG/PTR ! Default values are okey too.

   EXPORT DEF myarray[100]:ARRAY OF INT, hereyougo=8

   In SHOW mode, all imported globals, even from sub-modules
   will show up, so that you can see exactly what globals
   needs to be defined in main-source.

   example:

   *DEF xxx:PTR TO xxx, yyy


Librarybases:

   You have to define the librarybases you use, except for
   execbase, intuitionbase, gfxbase and dosbase.

   The reason for this is flexibility and power :

   As the librarymodules for yaec is nothing but regular modules
   with just macros in them, the librarybases are not hardcoded.

   This means that private librarybases is possible like in AmigaE,
   and even *local* librarybases are possible :

   PROC main()
      DEF utilitybase
      utilitybase := OpenLibrary(UTILITY_NAME, UTILITY_VERSION)
      <use functions>
      CloseLibrary(utilitybase)
   ENDPROC

   The librarybase is referenced by name, so imagine what 
   could be done using a macro like this :

   MACRO mylibbase IS <some_expression>

   To share librarybases between modules, DEFine it in main,
   IMPORT DEFine it in modules.
@endnode
@node __31__ "Local_labels"

[31] - 2.Misc / Local_labels

   Well, they are actually *local* now.

   This means jumping into a label in another procedure is 
   not possible. ( I recently had one of those bugs in the compiler,
   took several days to spot it) :)
   
   It also means local labels will not show up in showmodule-output.
@endnode
@node __32__ "LOOP_keyword"

[32] - 2.Misc / LOOP_keyword


   LOOP keyword extended.

      LOOP exp
         <do funky stuff>
      ENDLOOP

   ..This does funky stuff "exp" nr of times.
@endnode
@node __33__ "MACRO_keyword"

[33] - 2.Misc / MACRO_keyword

   MACRO is supposed to replace #define, at places
   where code is used (in procedures).

   [EXPORT] MACRO <name>[(...)] IS <expression>

      MACRO Bla(x, y) IS y.yeah+(x*2)

   MACROs may have variable arguments : (not implemented yet)

      MACRO yehaa(x,y,...) IS func(BLAA, x, [y, ...])

   The current nr of variable arguments is in VARARGS constant.
   It may be used when inside MACRO with variable arguments.

   MACRO may have default-values, just like procedures : (not impl yet)
   
      MACRO yipee(x,y=NIL,z=BLABLA+5) IS ...

   note that default-values are evaluated at the spot
   where the MACRO statement is, not when using the macro.


   note : there is no need to enclose the body in ().
          The body is evaluated separately from the
          rest of the code.

   note2 : The expanded body MUST be a legal expression (by it self).
           Compiler will complain otherwise.

   MACROs may be RAISE-checked.
   This is very useful for systemfunctions :

   RAISE "LIB" IF OpenLibrary()=NIL

   (All systemfunctions are implemented as MACROs)

@endnode
@node __34__ "Member_inc-dec"

[34] - 2.Misc / Member_inc-dec

   This works a bit better now IMO : 

   example :

   object.member++ -> this increments *member*
                   -> steps to increment depends on members type

   object.member-- -> you guessed it.

   object.member[10].member++ -> once again, *member* is incremented.

   self.member[x]-- -> guess what, *member* is decremented.

@endnode
@node __35__ "Operator-grouping-precedence"

[35] - 2.Misc / Operator-grouping-precedence

   
   e+ have group-based left-to-right operator-precedence.

   Groups :

   Math-bitwise : (+ - * / AND OR << >>)
   
   (e1 + e2 * e3 / e4 - e5 AND e6 OR e7 << e8 >> e9...)

   Other operators are their own groups :

   BUT     (e1 BUT e2 [BUT e3...])
   :=      (a := b [:= c...])
   <=>     (e1 <=> e2)
   <       (e1 < e2)
   >       (e1 > e2)
   =>, >=  (e1 >= e2)
   <=, =<  (e1 =< e2)
   =       (e1 = e2)
   <>      (e1 <> e2)  
   
          
Some examples : 

   (--> : interpreted as)

   /* "IF" expects an expression and assignment is one */   
   
   IF libbase := OpenLibrary(LIB_NAME, LIB_VERSION)

   -->   IF (libbase := OpenLibrary(LIB_NAME, LIB_VERSION))

   
   /* "AND" and "+" belongs to same group */

   IF a AND b + 6

   -->   IF (a AND b + 6)


   /* "AND" and ">" are in different groups, so theres a split */

   IF a AND b > c

   -->   IF (a AND (b > c))


   /* "=" is one group, "OR" and "+" another */
   
   a = b OR c + d

   -->   a = (b OR c + d)


   /* much like above */

   IF a = b OR c + d

   -->   IF (a = (b OR c + d))

 
   /* assignment expects an expression, "y BUT z++" is one */

   x := y BUT z++

   -->   x := (y BUT z++)

   
   /* BUT expects an expression, "y+10" is one */

   x BUT y+10

   -->   x BUT (y+10)  
    

   /* "+" expects an expression, "a <> [1,2,3,z]" is one

   a + b <=> [1,2,3,z]

   -->   a + (b <=> [1,2,3,z])


   /* much like above */

   IF x := a + b <=> [1,2,3,z]

   -->   IF (x := (a + (b <=> [1,2,3,z])))


   /* well.. :) */

   a := b + c * d / e

   -->   a := (b + c * d / e)


   /* starting expression with "-" subtracts expression from zero */

   - a + b * c

   -->   0 - a + b * c


   Its pretty simple when you understand it :)

   When expressions have operators in them from different groups,
   the expressions will be spilt up into subexpressions :

   IF a + b > c   -->   IF (a + (b > c))
   

   Just read from left to right, if all operators are from same
   group, then thats it! (just like in E)

   IF a + b AND c  -->  IF (a + b AND c)
 


   Notes : 
   Dont be afraid to use pharantheses.. even if YAEC have some 
   precedence.. Pharantheses makes source much clearer
   and increases possybility that other compilers might 
   work with your code too.

   In practice, this kind of operator precedence is much compatible
   with the AmigaE one. 


@endnode
@node __36__ "OPT_keyword"

[36] - 2.Misc / OPT_keyword

   Following may follow the OPT keyword :


   MODULE     - declare source as module 
                (not neccessary for modules with .m name)
   
   EXPORT     - export everything from module, except
                PRIVATE stuff.

   STACK      - manually set stacksize. ex : OPT STACK=50000

   NODEFMODS  - do not include the standard modules (exec,dos,gfx,intui)

   NOWARN     - disable warnings, under construction

   DIR        - set default module-dir, under construction.

   OSVERSION  - under construction

   SINGLEBASE - in LIBRARY mode only. use single librarybase.
                under construction.

   INIT       - define init-code for module. OPT INIT = exp.
                Example : OPT INIT = myinit().

   END        - define end-code for module. OPT END = exp.
                Example : OPT END = myend().

   XREF       - reference external asm-labels, useful together with OPT LINK.
                Example : OPT XREF _Label, Label2, label3,...
                under construction

   LINK       - link in external linkobject, useful together with OPT XREF.
                Example : OPT LINK = 'linklibs:mylinklib.o', (needs full path)
                under construction

   
   Notes about OPT XREF, OPT LINK :

      Useful for writers of interface-modules.

   
   Notes about OPT INIT, OPT END :

      It is important that a module is fully initialised before it is used
      by other modules or the main-source. Undoing the initialisation should
      be done in the reverse order, last thing inited = first thing ended.
      This is taken care of care of with in a simple way using OPT INIT 
      end OPT END. 

      Modules at the lowest (deepest) level will be initialised first
      then modules at higher levels etc.. 

      note: end-code currently is activated first in the deepest modules,
      just like init-code. Ill try to fix this in future. 
      
      Init-expression may return anything, the returnvalue is
      not used. To signal error, an exception should be thrown,
      then handle it in main().
   

@endnode
@node __37__ "SELECT_keyword"

[37] - 2.Misc / SELECT_keyword


  SELECT is less limited now.

  SELECT exp
  CASE exp
  CASE exp, exp, exp -> this required OF-mode before
  CASE exp TO exp    -> this required OF-mode before.
  DEFAULT
  ENDSELECT 

  OF-mode (SELECT size OF exp) is supported but treated
  as a regular SELECT. (no jumptable generated)

@endnode
@node __38__ "Some_new_constants"

[38] - 2.Misc / Some_new_constants



   READWRITE  -  this equals dos/dos/MODE_READWRITE
   
   LSTLEN     -  as STRLEN but for lists.
   
   VARARGS    -  Contains nr of variable arguments when
                 inside a MACRO body. 

   
@endnode
@node __39__ "STATIC_keyword"

[39] - 2.Misc / STATIC_keyword

   The idea is to have "constant data pointers" that bahaves
   like a regular CONSTant, put is a pointer to initialised data.
   The pointer is automatically typed. Pointer cannot be changed.

   example:
 
   STATIC MY_List = [1,2,3,4,5] -> MY_List is of te type [5]:LIST

   also strings, objects, type lists and arrays may be defined.
   any expressions may be elements.

   This will replace the old storage keywords : LONG,INT,CHAR. 

   May only be defined globally.

   May be preceeded with EXPORT.

   more examples:

   OBJECT colour
      red:CHAR
      green:CHAR
      blue:CHAR
      alpha:CHAR
   ENDOBJECT

   STATIC COL_Black = [0,0,0]:colour,
          COL_White = [255,255,255]:colour,
          COL_Red   = [255,0,0]:colour,
          ...
          ...

   DEF colour:colour
   
   colour := COL_Red

   Plot24(10,20,colour)

   ...

@endnode
@node __40__ "StrFmt-codes"

[40] - 2.Misc / StrFmt-codes

   \\n       -    newline
   \\t       -    tabulator
   \\e       -    escape
   \\b       -    carriage return
   \\q       -    quote
   \\a       -    single quote
   \\"       -    quote           (new) 
   \\'       -    single quote    (new) 
   
   Special codes used by string formatting functions :

   \\l       -    left justification
   \\r       -    right justification
   \\z       -    zero fill
   \\d       -    decimal value
   \\s       -    string
   \\h       -    hexadecimal value
   \\c       -    character
   \\f       -    float value     (new)
   \\~       -    nothing         (new) 

@endnode
@node __41__ "3.OOP"

[41] - 06.Positron / 3.OOP

   @{" Classes_without_NEW-END " link __42__}

   @{" Dereferencing_methods " link __43__}

   @{" Inherit_renamed_constructor " link __44__}

   @{" Private_methods " link __45__}

   @{" Ptr_to_self " link __46__}

   @{" Redefining_with_SUPER " link __47__}

@endnode
@node __42__ "Classes_without_NEW-END"

[42] - 3.OOP / Classes_without_NEW-END

   Classes (OBJECTs with methods) may now be allocated by simply
   typing something like :

   DEF o:classobject

   Locally or globally.

   At procedure/program end, an automatic "END o" is performed on
   the classobject. (including calling .end() method)

   example :

   PROC bla(x)
      DEF o:object
   ENDPROC o.method(x)


   DEF:ined classes are automatically cleared (as with NEW).

   What happens if we NEW such an object later on ?

   It will be cloned ! See @{"Cloning with NEW" link P_clonenew}

   What happens if we try to END it ?

   Compiler will complain. As compiler have created it for you,
   it is also responsible for automatically deallocate it, see
   above..

More: (v2.5+)

   Classes may be constructed at DEF point :

   example:   

   DEF varname:constructor()

   Constructor MUST have same name as class.
   (compiler looks at constructorname to know which class to define)

   This works localy and globaly.

   Caution ! Only way to signal error from the constructor
   is by raising an exception.

   In the case of failure in global class-construction the
   exception raised will end up in main() procedure.
   (so it can be handled).
   This is true also for global classes in modules.

   If no handler is defined in main(), application
   will simply quit.
@endnode
@node __43__ "Dereferencing_methods"

[43] - 3.OOP / Dereferencing_methods

   Methods may now be dereferenced just as members!

   object.method().member[].value .. etc..

   For this to work, the method must be typed,
   and ofcource as returning some kind of object :
   PROC method() (PTR TO object) OF object


   Ptr-typeing also works :

   x := object.bla()::window.rport

   for now, this ptr-typeing is not smart enough
   to react if .bla() returns a CHAR or INT...
@endnode
@node __44__ "Inherit_renamed_constructor"

[44] - 3.OOP / Inherit_renamed_constructor

   What does this mean ?

   It means that if we do not define a new constructor
   for a sub-class, then the super-constructor will be used,
   but with its name changed to that of the sub-object.

   Example :

   OBJECT firstclass
      ...
      ...
   ENDOBJECT

   /* constructor for firstclass */
   PROC firstclass() OF firstclass IS <whatever>

   OBJECT secondclass OF firstclass
      ...
      ...
   ENDOBJECT

   /* we have not defined a new constructor for secondclass,  */
   /* (probably because we are pleased with the initialison   */
   /*  the constructor of firstclass supplies) so we          */
   /* automatically inherit .firstclass() =as= .secondclass() */

   DEF sc:PTR TO secondclass

   NEW sc.secondclass()

   
   etc..

   This makes the code easier to understand :

   NEW sc.secondclass()
  
   instead of 

   NEW sc.firstclass() -> this looks like we are creating a firstclass

   ofcource, its possible to make the new wrapper by hand, but this is
   simpler, and more efficient, as we dont wrap another method around
   the firstclass constructor.

PROC secondclass() OF secondclass IS self.firstclass()


@endnode
@node __45__ "Private_methods"

[45] - 3.OOP / Private_methods

SYNOPSIS

      PRIVATE PROC <name>(...) OF ...

   DESCRIPTION

      Method will be private on module-level.
      This means, it will not be "seen" outside the module.

      Outside the module, the method is considered "dead"
      and compiler will complain if we try to use it.

      It is okey to "redefine" it. It will NOT "link"
      with the private one, so dont try that.
@endnode
@node __46__ "Ptr_to_self"

[46] - 3.OOP / Ptr_to_self



   [Evaluation feature..]

   PTR TO self, Or "polymorhic self type"

   Imagine following

   OBJECT node
      next:PTR TO node -> link to next node
   ENDOBJECT

   OBJECT mynode OF node
      data   -> we inherit to add some fields
   ENDOBJECT

   now "mynode.next" is "PTR TO node".  (often we do not want that)

   Instead type :

   OBJECT node
      next:PTR TO self
   ENDOBJECT

   OBJECT mynode OF node
      data
   ENDOBJECT

   NOW, "mynode.next" is "PTR TO mynode" !


   "self" may be used in methods too:

   PROC bla(n:PTR TO self) OF node 
      DEF n2:PTR TO self, x:self, y:LONG
      ...
      

   ..and as returnvalue for methods :

   PROC method(x,y) (PTR TO self) OF node IS ...

   When inheriting method, PTR TO self will also
   be inherited. For the same reasons PTR TO self-members
   are inherited.

@endnode
@node __47__ "Redefining_with_SUPER"

[47] - 3.OOP / Redefining_with_SUPER


   We may explicity declare a method as redefining another.

   PROC method() OF SUPER object ...

   Usage of the SUPER keyword makes the compiler check if there really
   is a method with this name in the superclass. If not found, we`ll 
   get an errormessage.


@endnode
@node __48__ "4.List-unification"

[48] - 06.Positron / 4.List-unification



1. AmigaE compatible

   exp <=> [var,BLA,var2,[10]]


2. Extension A

   "*" may be used to match anything (wildcard).
   'strings' may be used as constants.

   exp <=> ['string', *, var, BLA, 12]


3. Extension B 

   Allow comparison and floats

   exp <=> [>2, <>10.12, NIL, =x, y]
   -> "=" here forces "x" into constant.


Notes:

   "exp" may be one of three types :
   ANY, PTR TO LIST or LIST.

   If unification fails (returns FALSE),
   variables are guarantied to be untouched.

   If "exp" is NIL, unification will fail imediately.

@endnode
@node __49__ "5.String-unification"

[49] - 06.Positron / 5.String-unification



   exp <=> 'hello'  
      Does a simple "StrCmp(exp, 'hello')"

   exp <=> 'hello', x 
      If "exp" starts with 'hello', then put the remaining
      characters in "x".

   exp <=> x, 'hello'
      If "exp" ends with 'hello', then put all characters
      before it in "x". 

   exp <=> 'hello', *
      "*" here matches anything. So if "exp" just starts with
      'hello' this will return TRUE. 

   exp <=> *, '<HTML>', *, '<HEAD>', *, '<TITLE>', x, 
           '</TITLE>', *, '</HEAD>', *, '</HTML>', *
      Figure this one out ! :)    


   "exp" may be one of five types : 
   ANY, PTR TO CHAR, ARRAY OF CHAR, PTR TO STRING or STRING.

   "x" may be one of three types :
   ANY, PTR TO STRING or STRING. (variable)

   The 'static string' may have formattingcodes in it.
   ex : exp <=> '\\t', x, 'bla\\n'
   
   If "exp" is NIL, unification will fail imediately.

   'static string's should not follow eachother.

@endnode
@node __50__ "6.Compability"

[50] - 06.Positron / 6.Compability

--------------------------
               Compability
               -----------   


   The LONG type
----------------

   LONG (and also INT/CHAR/UINT/BYTE) is meant for integer values only.

   Reading the e.guide it seems this was the intended behaviour from the beginning.

   problem example :

      DEF x:PTR TO LONG, y[100]:ARRAY OF LONG

      x[] := y -> this will give "type conflict" error.

   "x" point to integer values and y is not an integer (but an array).

   solution1 :

      Replace LONG with ANY. ANY have the same size, but may contain anything.

      DEF x:PTR TO ANY, y[100]:ARRAY OF LONG

      x[] := y -> no problemo.

   solution2 :

      The type-checking mey be turned off with the commandline option "TCL -1".

      Not recommended, but a solution.


   The List functions
---------------------

   The internal functions have typed parameters and returnvalues by default.

   example :

   Some sources gives "PTR TO LONG" as parameter to ListLen().

   The ListLen() function now atleast expects "PTR TO LIST".
   This means we can use three types : "PTR TO LIST", "LIST" or "ANY".

   so the solutions are :

      1. If expression is variable, change its type to "PTR TO LIST".
         Or : dont type it at all.

      2. Untype the parameter-expression with Any(param-exp)

      3. Use commandline option "TCL -1" to turn off type-checking.


   Freeing dynamic strings
--------------------------

   String() now uses the fast-pool for allocations.
   This means Dispose() cannot be used to deallocate an estring.
   Use EndString() for this. It is also possible to use "END s"
   if the string was DEFined as "PTR TO STRING".

   
   Changed functions 
--------------------
   
   See the ListNQuote-functions in @{"list.doc" link e:docs/if/list.doc/MAIN}


   Removed functions
--------------------
   
   Gadget()  -- pherhaps something similar might show up..
   
   CleanUp() -- Use Raise(0) instead.


   Removed Keywords
-------------------

   INC  --  use ++
   
   DEC  --  use --

   not removed but skipped:

   HANDLE 

   PREPROCESS
  
   REG

   
   Stringformatting
-------------------

   " or ' inside strings does not work.
   use \\q \\" or \\a \\' instead.

   
   Unification
--------------
   
   Variables will not get new values unless everything matches.
   (consider it a bugfix :))


   Sharing globals
------------------

   See @{"Globals in modules/sharing" link P_gim}


   Operators
------------

   Watch out for theese kinds of expressions:

   "a < b AND c"

   In AmigaE it would first compare "a" and "b" then bitwise-AND 
   the result with "c".

   In e+ it would translate to : "a < (b AND c)"
   that is first bitwise-AND "b" and "c", then compare.

   The reason is that "AND" and "<" comes from different groups
   in e+ (see doc on operator precedence in this guide).

   Theese kinds of expressions are not very common, 
   (from what *Ive* seen) anyway ...

   an expression like :

   "a + b AND c"

   will on the other hand work exactly like before..
   "AND" and "+" comes from same group.

@endnode
@node __51__ "7.Other"

[51] - 06.Positron / 7.Other


   Other stuff
   ~~~~~~~~~~~


   - Arrays/lists/strings can not be ENDed (guess why)
   - Arrays/lists/strings can not be incremented/decremented.
   - dereferencing arrays/ptrs gives ARRAY OF ... / PTR TO ... type.



@endnode
@node __52__ "07.Other_things"

[52] - YAEC_26D_GUIDE / 07.Other_things

   @{" Asm_support " link __53__}

   @{" Hardcoded_ilmits " link __54__}

   @{" obsolete.Library-mode " link __55__}

   @{" Preprocessor " link __56__}

   @{" Showmodule_output " link __57__}

   @{" Union_members " link __58__}

@endnode
@node __53__ "Asm_support"

[53] - 07.Other_things / Asm_support

   YAEC supports asm in a different way compared to EC.
   First off, it is not integrated into the language.
   This makes little sense for portability.

   Note : This features are mainly here too help interfacing
          with external code like shared libs and linklibs. 
          (not to be used by beginners) 

   To insert a single line of asm :

   ASM ' move.l d0, (a0)+' -> note the apostrofes!

   V2.5+ : ASM-ENDASM has been removed !
   The filosofy is that asmcode is too platform-specific,
   and should be written in an assembler and than linked
   with the program instead. (OPT LINK ...)

   Asm-code is not touched or checked in any way by YAEC.
   This is up to the assembler, currently PhxAss.

   To pass values between asm and E, YAEC can use 
   registers D0-D7/A0-A7 as variables :

   ex:

   x := A0
   D0 := blah()

   You should not use registers D2-D7/A2-A5/A7 without
   saving/restoring them.
@endnode
@node __54__ "Hardcoded_ilmits"

[54] - 07.Other_things / Hardcoded_ilmits


   identifierlength                   100 chars (+-)
   max nr of global vars              16000 
   max nr of macroargs                16
   max objectsize                     32k
   FOR/LOOP/WHILE/REPEAT depth        100
   max macro nesting depth            100 
   
   ..under construction.. 
@endnode
@node __55__ "obsolete.Library-mode"

[55] - 07.Other_things / obsolete.Library-mode


   YEAH ! Library-mode .. :)

   [NOT YET IMPLEMENTED]

   WARNING !! not for beginners !!

   A big difference from before is that YAEC uses *shared* globals
   in libraries. This has advantages and disadvantages.
   
   We may not write to globals. several tasks may
   read and write to it at the same time = problems.
   An exception to this is in Init(), Open(), Close() and Expunge().
   They are single-threaded, so we may init librarybases and
   similar stuff here. 
   
   If global data is desired, on a task-basis, a solution is
   to pass it along from the caller of a function. That is
   we reserve an extra argument to functions for a global
   data ptr. EC-style libraries may be emulated this way.

   -> calling a function and passing along global environment.
   A_Function(globals, p1, p2)

   "globals" should be allocated in calling program, or 
   by a dedicated function in our library.

   ex:

   -> get globals from library (library may initialise it)
   globals := MyLib_NewGlobalEnv()

   -> call a function in library
   MyLib_Function(globals, x, y)

   -> free global environment
   MyLib_EndGlobalEnv(globals)

   Internally, in our library, "globals" is probably a
   PTR TO object, where object could look like:

   OBJECT globals
      global1
      global2
      ... etc ...
   ENDOBJECT  

   "MyLib_Function()" could look like :

   PROC myLib_Function(g:PTR TO globals, x, y)
   ENDPROC g.global1 + x * y

   
   YAEC`s Memory-functions are automatically semaphore-protected
   and fully safe to use at all times in libraries. The memorypool 
   is shared by all users of the library. This means that one task 
   may allocate something that another later deallocates without 
   any problems.

   stdout, stdin, stdrast and arg are NIL, as we might expect.
   It is however possible to print from libraries using
   PrintF(), WriteF() and PutFmt(). Theese functions will
   use dos.library/Output() as filehandle when stdout=NIL.
   (we use the callers stdout).


   Header:

   LIBRARY 'example.library', ver, rev, 'example.library by The Badger(tm)'

   Declaring a public library-function:
   
   ENTRY MyLibFunction(x,y,z)(d0/d1/d2) IS myLibFunction(D0,D1,D2)

   "ENTRY" is a new keyword for this purpose.
   "MyLibFunction" is the name of public function.
   "(x,y,z)(d0/d1/d2)" will be used for .fd creation.
   (YAEC automatically creates an .fd file when compiling library)
   The function-offset starts at -30 and decrements with 6 for each
   ENTRY we add, from top to bottom.

   Defining it:
  
   PROC myLibFunction(x,y,z) IS x+y*z


   More control.
   YAEC libraries require functions Init(), Open(), Close()
   and Expunge() to be defined. The library-startup-code
   will call them.

   The four required functions:

   PROC Init() IS TRUE  
   
   This is the simplest possible defenition of Init().
   We return <>NIL to signal success. If we return NIL,
   libraryinit will fail.  

   PROC Open() IS TRUE
  
   This is the simplest possible defenition of Open().
   We return <>NIL to signal success. If we return NIL,
   OpenLibrary() will fail.   

   PROC Close() IS TRUE

   This is the simplest possible defenition of Close().
   May return any value. TRUE is a good value :) 
   We end uf here when someone does a CloseLibrary() on us. 

   PROC Expunge() IS TRUE

   This is the simplest possible defenition of Expunge().
   We return <>NIL to signal that we accept beeing expunged
   (removed from librarylist and deallocated). If we return 
   NIL, no expunge will take place.   
   Here we end up when memory is low and we have no openers.


   Remember to not Wait() inside above functions!

   Notes on Init() : OPT INIT or global class-construction
   may pass out exceptions on failure. It will end up in Init().
   (in executables it ends up in main()) 
   So be sure to define an EXCEPT-block in Init() in that case.
  
   Notes on stacksize: YAEC library-startup does a stackswap
   before calling Init(), so we have 10k of stack to have fun with.
   (else we would just have 4k) This should be enough for opening 
   stack-hungry MUI-libs and similar. 
 
   And, almost forgot, the librarybase is READ-ONLY.
   It is okey to check open-count and similar.
   And, everything below the libraryheader (34 bytes)
   is PRIVATE.

   For more info, see e:examples/bla.library.e.


@endnode
@node __56__ "Preprocessor"

[56] - 07.Other_things / Preprocessor

   As of v2, YAEC got a real preprocessor built in.
   (before, it was "emulated")

   Directives :

   o #define
   o #ifdef
   o #ifndef
   o #endif

   Additional directives :

   o #undef <label>   -> undo a #define 
 
   o #else

      example :

         #ifdef BLAA 
            dostuff()
         #else
            dootherstuff()
         #endif

   o EXPORT #define ...



   note : "OPT PREPROCESS" is not needed for preprocessing.
          (will be skipped)

   note2 : macrosubstitution now works more like with C-preprocessors;
           substituting inside strings is not possible.
           I know this was useful sometimes... but hey..


@endnode
@node __57__ "Showmodule_output"

[57] - 07.Other_things / Showmodule_output

   The output generated in SHOW mode.


   Order of item-types :

   1. Imported globals (*DEF)  (from sub-modules too!)

   2. Globals (DEF)

   3. Constant data (STATIC)

   4. Procedures (PROC)

   5. Objects (OBJECT)

   6. Constants (CONST)
 
   7. Macros (MACRO)
 
   8. defines (#define)

   9. sub-modules. (sub-modules:)
@endnode
@node __58__ "Union_members"

[58] - 07.Other_things / Union_members

   Add union-members :

   OBJECT test
      xxx:LONG
      yyy:INT
      zzz:INT
   /* union members */
      float:FLOAT \@ xxx
      ptr:PTR TO LONG \@ xxx
      data[2]:ARRAY OF LONG \@ xxx
      data2[2]:ARRAY OF INT \@ yyy
   ENDOBJECT

   Will produce :

(----) OBJECT test
(   0) value:LONG
(   4) val2:INT
(   6) val3:INT
(    ) float:FLOAT             ->at the offset of value (0)
(    ) ptr:PTR TO LONG         ->at the offset of value (0)
(    ) data[2]:ARRAY OF LONG   ->at the offset of value (0)
(    ) data2[2]:ARRAY OF INT   ->at the offset of val2  (4)
(----) ENDOBJECT   /* SIZEOF = 8 */     


   Typed lists have no problem with this :

   [10, 12, 13]:test

   (Only the non-union-members will be used) 
@endnode
@node __59__ "08.Files"

[59] - YAEC_26D_GUIDE / 08.Files


   E:
      bin/
         yaec
         fd2mod
         h2mod
      modules/
         #?.m
         #?/
            #?.m
      docs/
         yaec.readme
         yaec.guide
      startup/
         yaec.i
         yaec.lib
         startup.o
         generate.script
      examples/
         #?.e
      temp/    -> do not remove !


@endnode
@node __60__ "09.History"

[60] - YAEC_26D_GUIDE / 09.History

2.5d:

   - Some speedups when reading binary modules and temp-files.
    
   - some documentation changes, additions.
     
   - fixed the "type conflict-all-day-long bug" ! :)
     (objectptrs could give "type conflict" when there was not)

   - fixed amigalib.m for v2.5+ (varargs is back)

   - alpha : varargs support for #define and MACRO.
     (constant VARARGS not working yet)

   - alpha : defaultvalues for MACROs. (just like PROC)

   - fixed a problem in fd2mod. (it didnt work on some .FDs)

   - fixed a problem in "user-initialisation" code.
     ("user-initialisation" here means global class construction
       and OPT INIT)

   - fix : "NEW var.method()" did not return "var" but "method()".
           (all oop examples working now..)

   - fix : RAISE had some problems, hopefully no more!
           (raised wrong value, sometimes crashed)


2.5c: (Dec 15 2001)

   8:th public release.

   frontend:

   - Fix: SUPER called dynamic superclass. oops!

   - Add: OPT INIT, OPT END. (init-code, end-code)

   linklib:

   - Fix: PutFmt() had a fatal error.

   frontend:

   - Fix: non-basic arguments didnt work very well.

   - Fix: multiplication in constant float expression did addition :)

   - Add: OPT INIT now passes exception to main().

   - Chg: Libbases moved out of system-modules.

   linklib:

   - Fix: Val() did not recognice lowercase hex-digits.

   - Fix: StrFmt(),StringF() *added* characters to "estr".

   - Fix: FastDispose() (and END) could crash.

   frontend:

   - Add: Inherit renamed constructor feature.
 
   - Fix: Eval() caused internal error.

   backend:

   - Fix: Nasty bug in comparison (sometimes compared wrongly)
          (this one has been around for some time)

   frontend:
 
   - Add: List-unification (documentation)

   - Add: String-unification !
   
   misc:

   - Fix: Running from Ram: now works. 
     

2.5b: (private)

   frontend:

   - Add: DIR/K commandline option. (alternative moduledir) 
   
   - Add: static modules option (SNAPSHOT/S) 

   - Fix: NEW, END did not work on PTR TO STRING, PTR TO LIST

   - Chg: binary moduleformat slightly changed. 

   - Add: commandline option DEPENDENCIES/S.

   - Add: OPT NODEFMODS - dont include default modules (exec,dos,intui,gfx)

   - Fix: "\e" "\b" "\q" in valuestrings did not work.

   - Rem: moved ASM - ENDASM !  *outahere*

   - Fix: NEW _static_list_ always had currlen of 0, not good.

   linklib:

   - Fix: some bugs in Quote-List functions where fixed.

   frontend:

   - Add: NEW obj.constructor() now works.
          (OOP still not 100% working...)

   - Add: typed lists may use objects with arrays !!

   - Add: new types: UINT,BYTE and array/ptr/list versions of them.

   misc:

   - Add: docs for STATIC keyword.
 
   - Chg: Tweaked bin/h2mod some to the better.

   frontend:

   - Add: Show-mode now includes redefenition status for methods.

   - Add: IMPORT DEF   (Share global with main source)

   - Fix: typed lists now may be longer than "nr_of_members".

   - Add: member-unioning feature. 

   - Fix: "redefinition" of private method was not possible.

   - Fix: double declaration of object-member was not spotted.

   - Fix: SET was complaining about too many values when there was NOT.

   - Add: Call constructor in DEF statement !

   - Fix: multiple commandline defines was broke.


2.4b:  (private)
   
   - Documented some undocumented stuff :)

   - bugfixed procedure/method output in show module mode.

   - PTR TO self did not virtually change for method-returns.
  
   - changing nr of args when redefining method was not spotted as error. 
 

2.4a:  (Oct 16 2001)

   7:th public release

   - FREEWARE

   - New powerful binary module system !
     - CPU independant.
     - no need to recompile a module if sub-modules change.
     - fully automatic (no need for build-tools).
     - Application may be compiled with one invocation of compiler.
     - Coexists nicely with ascii-modules.

   - built in showmodule functionality.

   - added h2mod utility : c header -> yaec module.

   - added missing internal functions : OstrCmp(), AstrCopy()

   - added preprocessor (#define,#ifdef,#ifndef,#else,#endif)
         
   - added unreferenced check.

   - Heavily improved internal structure, resulting in :
     - not so picky about "source-style" anymore.
     - faster in all.
     - binary module support.
     - real preprocessor.
     - stability.
     
   - storage-keywords LONG,INT,CHAR removed.

   - New keyword STATIC added. (replaces above)

   - Unification is back ! (alpha)

   - misc bugfixes, improvements.

   - cosmetic changes :)

   - undocumented features/bugs :)


2.2a: (private)

    - MANY bugfixes..

2.0a: (private)

    - BIG internal changes.
    - implemented preparser
    - binary modules
    - showmod and binmod utilities.
    - implemented preprocessor

1.9b: (yaec_upd.lha, only yaec executable)

   - Fix : Methods was not found !

   Which I had betatesters...


1.9a: (Aug 12 2001)

   6:th public release (Bugfix release)

   Well, last version had been pretty rearranged internally, it shows :)


   *** front-end ***

   - Fix : RAISE keyword had no effect.

   - Fix : oop was messed up.

   - Fix : conditional compilation did not work.

   - Fix : indexing buggy ...gaah..

   *** back-end ***

   - Fix : nilcheck/ptrcheck was messed up.

   *** linklib ***

   - Fix : stringformatting - now formats hexa correctly AND is
     even faster then before ! :)

   - Fix : StrAdd() with len did not set strlen correctly.

   - now libraries have exec,dos,intuition and graphics
     libraries opened automatically. (just as exes).

   - It is now possible to use WriteF(),PrintF(),PutFmt()
     from libraries!

   - Added new formatcode : \f  --  for floats !
     see example.

   *** source ***

   - Added debuglib.e and ddebuglib.e, modules with inline macros.
     You need the appropriate linklibs from Amiga to use them.

   *** front-end ***

   - Implemented compiler-arg DEF/K.
     Define a globally visible symbol to be used with
     conditional compilation. ex : DEF DEBUG.
     (The global symbol YAEC is always defined)


1.8a: (July 15 2001)

   Fifth public release.

   *** front-end ***

   - Bugfixed : relative module path (*).

   - macros (#define) implemented.
     Bonus : 0-arg macros "()", "EXPORT #define" and "#undef" keyword.
     experimental : "IMPORT #define <label>"
       -> grab a #define from main-source into module.

   - conditional compilation (#ifdef,#ifndef,#endif) moved back in.
     bit of a fast hack but works for simpler stuff.

   - MACRO keyword -- expression substitution.
     The better way to do it. supports varargs! see docs for more info.

   *** back-end/linklib ***

   - dynamic strings/lists may have more than 32k elements.
     (theoretically 2 gig!) using 32bit currlen,maxlen
     (which is faster in 32bit memory)

   *** front-end ***

   - Constant "VARARGS" contains the latest number of variable
     arguments in MACRO.
     guess what this example does:
     MACRO FmtPrint(fmt,...) IS Stores(...) BUT (A0 := fmt) BUT \
                                (A1 := A7) BUT ASM " bsr PrintFmt" BUT \
                                Rems(VARARGS*4)
     bug : does not nest properly. (needs a stack..)

   - automatic "#define YAEC". useful with conditional compilation.

   - multiline RAISE statement.  (finally)

   - "EXPORT MODULE ..." well..guess what it does..  (alpha)

   - CONSTants now include static strings,lists,arrays,objects!
     ex : CONST MYVAL=10, MYSTRING='blabla',
                MYLIST=[1,2,-0.6, {func}, BLABLA],
                MYARRAY=[4,5,6,7]:INT               (beta)

   - Heheh... "MACRO" changed name again to "#macro".

   - Conditional compilation : #else keyword. (alpha)

   - Possible bugfix : Conditional compilation _may_ work 100% now :)

   - "<<" and ">>" accepted in constant expressions.
     ex : CONST BLA_F = 1 << BLA_B

   *** misc ***

   - wrote/added amigalib.e



1.7a: (June 15 2001)

   *** misc ***

   - some more sources in examples/ drawer.

   *** linklib ***

   - Bugfixed FastDispose(), some errors where introduced in prev version.

   - Bugfixed MidStr(), now copies 0 bytes if len=0.

   - Bugfixed SetStr(), didnt set nil-byte.

   - Bugfixed StrCopy(),MidStr(): now sets estring-len to 0 if copy-len is 0.


1.6a: (April 17 2001)

   *** Front-end ***

   - Speeded up module-parsing a little bit.

   - LONG/INT/CHAR didnt continiue on several lines. Fixed!

   - Well, one of the very last incompabilities just went away..
     MODULE 'alibrary' is now allowed ! :)

   - Disabled unification and lisp-cells as they are not really
     stable and bugfree. Positive : compiler got faster! :)

   - Disabled #define, #ifdef, #ifndef, #endif.
     (#define still gets parsed, but skipped)
     Yaec does not have a real pre-processor at the moment,
     but its planned. For now, a new keyword MACRO can
     be used instead of #define in many cases.
     ex : MACRO BLABLANAME IS 'blabla.library'
          MACRO Max(x,y) IS IF x > y THEN x ELSE y

     MACROs may be EXPORTed. (EXPORT MACRO ...)
     For more examples, look at the system-modules.

   - Changed syntax of single-line asm (ASM).
     Before : ASM <instruction>
     Now :    ASM '<whatever>' -> Note the apostrofes !
     Some advantages : 1. e-style comments can be appended.
                       2. Multiple ASM via BUT.

   - Completely got rid of EXTERN keyword and .ext files!
     The E language itself is now capable of doing all that
     and more. External defenitions are now in standard
     ascii module-format.

   - EXIT keyword implemented. (works with _all_ loop constructs)

   - relative module path (*) now works exactly as with EC.

   - multiple return values (3) implemented.

   - "EXPORT DEF ..." in modules is now allowed for compability.
     Preferred way is to type "IMPORT DEF ...".

   - Constant folding implemented.

   - Experimental error-recovery.

   *** Linklib ***

   - o FastNew(),FastDispose() now uses very fast recycling pool!
       (thanks to Wouter for helping here!)
     o Fix: FastNew() now raises "MEM" if out of memory.
     o Some NEW/END bugs removed.
     o Optimised NEW:s exceptiongenerating. (saved some instructions)

   - Startupcode would fail on > v40, when it should fail on < v40. Fixed.

   - Fix : Exes now returns exception as return-code. (if throwed out)

   - exe/lib/dev v39 support. not tested but hey!.. send me a line if it works.

   *** back-end ***

   - produces much better code now.

   *** Misc ***

   - bin/fdtool replaced with bin/fd2module.


1.5a:   (April 10 2001)

   Fourth public release.

   - ReadStr() didnt set stringlen correctly. does now.

   - Nested comments didnt work. Should now.

   - Amiga.lib working again :)

   - Added two .ext files : debuglib.ext and ddebuglib.ext
     for using debug.lib and ddebug.lib from Amiga Dev CD.

   - Added bin/fdtool - convert Your .fd:s to .ext:s with this.

   - All the v40 standard Amiga librarybases are predefined now!

   - Stringformatting : added \z support. (zero-fill)

   - Globals now accept constants and simple constant expressions
     as defaultvalue. ex : DEF myglobal=ACONSTANT*4-7

   - FPU is now only required if floating point is used.
     (previous version required fpu anyway)

   - Added compiler args : WB/S,OPTI/S,HOLD/S,LARGE/S,SF=SHOWFILENAME/S.
     OPTI and LARGE does nothing for now, but may in future.

   - Default arguments to procedures works now.

   - PUBLIC/PRIVATE in OBJECT declaration works now.

   - Parameters to procedures where swapped. Fixed.

   - Librarymode now automatically creates .fd file.
     (use bin/fdtool to convert it to .ext)

   - Linkobject mode automatically creates .ext file.
     (still a bit experimental and under construction)

   - Fixed "IS" in "PROC name([params]) [OF name] IS <exp>".
     <exp> must be on the same line as "IS".

   - "OPT LINKOBJ" turned into "LINKOBJECT".
     (must be first thing in source (like LIBRARY)).

   - "*" preceeding module/extern-name now inserts path to
     the main-source. This is not perfect, but atleast makes
     things a little better.

   - Ptr-math is _allowed_ for now. (as in ec3.3a) Maybe it stays.
     Probably it will return, but a bit smarter; for example things
     like this should be spotted as errors, always :
     "array + array" or "ptr * 10" etc..

   - Added some missing internal functions : Mouse(), LeftMouse(),
     WaitLeftMouse(), RealF(), Rnd(), RndQ(), RealVal().

   - Multi-line DEF (DEF statement can continiue on several lines).

   - Modules can now be check-compiled.

   - OPT STACK implemented : OPT STACK=<sizevalue>
     -> manually set stacksize, overrides YAEC:s estimation.

   - Added keywords : JUMP and LAB.
     -> JUMP <labelname> : Jump to a local label.
     -> LAB <labelname>  : Define a local label.

   - Global labels (label:)

   - Global storage definition (LONG 1,2,3,.. / INT / CHAR)

   - Global Asm (ASM.. / ENDASM)


1.4a: (Feb 22 2001)

   Third public release.

   - Rewrote the hole type-system. Its real good now,
     and ready for the future.

   - NEW/END/++/-- fully implemented.

   - Added AFD-Copyright Notice.

   - YAEC is now SHAREWARE.

   - Fixed NILCHECK and added PTRCHECK cli-args.

   - Compiling LINKOBJ now automatically creates .ext file.
     (this means its usable now :))

   - LIBRARY/DEVICE mode ! (see examples)
     (device mode not tested)

   - Fixed a nasty bug in externs that could cause crashes
     in some executables.

   - Fixed arguments to procedures so they are evaluated
     in the same way they are on ec3.3a, that is from
     left to right! some programs should work beter now! :)

   - Fixed SELECT statement so it accepts "x OF y".

   - Amigalib support gone again.. :(


1.3b: (Jan 21 2001)

   - Added Amigaguide documentation.

   - SetStdRast() was missing.

   - Enabled 68881/2 fpu-asm    (Martin Kuchinka)

   - Added Amigalib support. -> amigalib.ext

   - Improved NEW, objectptr[] still missing.

   - Added END keyword.


1.2b: (Jan 1 2001)

   Second public release

   - Fixed some archiveing errors.

   - Methods returned crap.


1.1.1 Beta: (Dec 2000)

   First public release

1.0
0.9
0.8
0.7
0.6
0.5
0.4
0.2
0.1 : (~Mid 2000)

   First exe largely based on LITTEL sources.


@endnode
@node __61__ "0A.Bugs_Todo"

[61] - YAEC_26D_GUIDE / 0A.Bugs_Todo

Known bugs:

   o There seems to be some problem with classes, 
     not sure what it is at this time.
     (bintree.e compiles but crashes when run)
     *FIXED* (was a bug in source!!)
    
   o STACKCHECK commandline option appears to not work.

   o SIZEOF cannot be used outside procedures.

   o Found anything ? (bugreports greatly appreciated!)


Todo:

   o Stringformatting : (x,y) is not implemented (anyone`s using it ?)

   o bugfix OOP stuff *DONE (i hope :))*

   o complete autodocs for internal functions

   o Allow " inside 'strings' and ' inside "" (valuestrings).

   o Remove new types "PROC" and "QUOTE". Maybe it was a bit
     of overkill .. 

   o Library/device/linkobject creation (under construction)


Future plans: 

   o PPC support.
     (YAEC needs a new backend first, will also give better optimisations.)

   o E+ Editor.

   o Better docs :).

   o YAEC compiling itself. (not that far away..)


@endnode
@node __62__ "0B.Author"

[62] - YAEC_26D_GUIDE / 0B.Author


   address:
   
   Leif Salomonsson
   Tallstigen 3
   771 40 LUDVIKA
   SWEDEN

   email:

   amigae@swipnet.se
   or
   leif_salomonsson@swipnet.se

   homepage: 
   
   home.swipnet.se/blubbe/YAEC (YAEC Homepage)

   home.swipnet.se/blubbe (personal)
   

Languages I have been using the last 10 years:

   in *kinda* order (overlapping) :

   o Micro$oft Amiga Basic  
      
      Hehe.. this was extremely fun.. but it was also
      the first programming-language I tried.

   o Shell-sripts

      It was a mystery to be solved.. HOW did that startup-
      sequence work ?? :))

   o 68k assembler

      Remember writing a little rainboweffect with the copper
      And a dir-util of 640 bytes, that displayed filetype also.

   o AMOS Basic

      Graphical demos over and over again.. :) funny.

   o AmigaE
   
      First I didnt like the uppercase keywords at all.
      Now I love it. Have written all kinds of stuff in E,
      including the YAEC compiler.

   o QBASIC

      At school... well, what can be said about it..

   o Pascal

      Beginners cource in school..

   o C

      Two beginners cources few years apart.

   o C++ / Java / Networks / W2000 Admin    

      A cource Im taking at home right now.
      

Computers :

   A500 kick 1.2, 1 MB    
      
      sold it to a guy that later dropped it on the ground, 
      killing the sound :(
   
   A1200 030/50 16 MB 
      
      later turned into PC-tower.
      Currently dead keyboard.

   Celeron 466 PC 384 MB Ram.

      Running W2000 and UAE-JIT (Amiga Forever 4).

My next computer will not have windows on it..:)
History suggests that it should have 3GB memory ...?? :)

@endnode
@node __63__ "0C.FAQ"

[63] - YAEC_26D_GUIDE / 0C.FAQ


   Mac version ?

   - Too early to even speculate about. 

   Debugger ?

   - Pretty low on current todo-list. (but I have some plans :))

   PPC version ?

   - As soon as I get my hands on PPC hardware,
     right now this looks dark, with no money to spare.

   
@endnode
