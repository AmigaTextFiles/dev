@DATABASE EC4OS3_eng.guide
@$VER: EC4OS3_eng.guide 0.2 (01.12.2004) Copyright © Damien Guichard

@WORDWRAP 80


@NODE Main "AmigaOS programming with Amiga-E"

  Copyright (c) 2004, Damien Guichard.


  AmigaOS programming with Amiga-E
  ********************************

  @{" The Amiga-E advantage "    LINK Advantage    }

  @{" Resource tracking "        LINK Resources    }
  @{" System libraries "         LINK Libraries    }
  @{" Tracking with exceptions " LINK Tracking     }
  @{" Program environment "      LINK Environment  }
  @{" Shell arguments "          LINK ReadArgs     }
  @{" Workbench arguments "      LINK Tooltypes    }

  @{" Program version "          LINK Version      }
  @{" Program localization "     LINK Localization }
  @{" Task signals "             LINK TaskSignals  }
  @{" Tag lists "                LINK TagLists     }
  @{" Exec lists "               LINK ExecLists    }

  @{" Intuition "                LINK Intuition    }
  @{" Gadtools "                 LINK Gadtools     }
  @{" Menus "                    LINK Menus        }
  @{" Gadgets "                  LINK Gadgets      }
  @{" Interaction "              LINK Interaction  }
  @{" Shortcuts "                LINK Shortcuts    }
  @{" AppWindows "               LINK AppWindows   }
  @{" Toolkits "                 LINK Toolkits     }

  @{" AREXX "                    LINK Arexx        }
  
@ENDNODE


@NODE Advantage "The Amiga-E Advantage"

The Amiga-E advantage
*********************

No other programming language makes it easier to program the AmigaOS
than Amiga-E does.
Among the many features that simplify the programmer life one should
mention the following:
 * easy to read, well structured MODULA-style syntax
 * lower-level types
 * E exceptions
 * E lists
 * pre-compiled OS3 modules
 * ASM code mixed with E code

The result is a more fluent and more friendly system programming style
than what is possible with other languages.
With ECX generating both 68020+ and PPC code, plus offering many language
clarifications and improvements, there is no reason not to program your
Amiga with an up-to-date Amiga-E compiler.

Usually a good programming style and careful reviewing of your code
should be enough to ensure system friendlines.
You should not resort to Enforcer, MungWall and similar utilities
to debug system programming.
As much as possible you should prevent the bugs rather than cure them.
Debugging tools seem to have magic powers but actually they make you
work at a much lower-level than desired.
Remember the best bug-hunter is source readibility.
Anything that work at a lower-level than source code is too low-level.

Of course the ultimate system programming reference is:

  http://aminet.net/dev/misc/AmigaOS_guides.lha

The amiga Includes are equally essential:

  http://www.amiga.com/3.9/download/NDK3.9.lha

The ASM includes are the ones used by Amiga-E.

Whenever you need more info about a function, refer to the Autodocs.
Whenever you need more info about structs and tags, refer to the Includes.

EC v3.3a compiler by Wouter van Oortmerssen: http://wouter.fov120.com/e/

ECX v1.7 compiler by Leif Salomonsson: http://home.swipnet.se/blubbe/ECX 

The Amiga-E mailing list: http://www.freelists.org/list/positron

Note: if you want to copy code in this document keep in mind any double "\\\\"
in an amigaguide document actually stands for a single "\\" character.

@ENDNODE


@NODE Resources "AmigaOS: Resource tracking"

Resource tracking
*****************

Because all computer resources are shared between all running programs
some mechanisms are included in AmigaOS so that resources are optimally
distributed.
The system strategy is actually fast but simplistic: the first resource
demander is the first served.
This strategy works well but requires a bit discipline from the programmer:
* you should request resources the lastest possible
* you should release these resources the earliest as possible
* you should "parenthesize" requests and releases

The next chapter will explain what "parenthesize" means and how E exceptions
greatly help the process.

Also keep in mind:
* any resource request can succeed or fail
* your program must behave well in both cases
* you should inform the user with any appropriate error message

@ENDNODE


@NODE Libraries "AmigaOS: System libraries"

System libraries
****************

As you already know, system fonctionality resides mainly in libraries.
Some of them are in the ROMs, many are in the LIBS: drawer.
Some third-party libraries (reqtools,MUI) can also be considered as
full parts of AmigaOS.

Libraries are great resources and you should learn how to manage them
before anything else:
* use OPT OSVERSION=37 at program start, there is no point to program
  below OS2.0
* a library can be opened with OpenLibrary(name,version)
* use version=37 for OS2.0+ libs and version=39 for OS3.0+ libs
* you should store the result in the library base variable
* if the result is NIL you can't do anything but display an error message
  and exit the program
* otherwise you can call library functions
* and when you are done you must call CloseLibrary(base)
* but then you can no more call the library functions

The reqtools.library is nice and handy to display error messages,
so it's usually a good idea to open the reqtools.library in first place.
The following program is an HelloWorld requester that examplifies
the library management:

OPT OSVERSION=37

MODULE 'reqtools'

PROC main()
  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase
    RtEZRequestA('Hello World!','Ok',0,0,0)
    CloseLibrary(reqtoolsbase)
  ELSE
    PrintF('Could not open reqtools.library!\\n')
  ENDIF
ENDPROC

The library base is @{b}reqtoolsbase@{ub} and @{b}RtEZRequestA@{ub} opens a simple requester.
Note that success and failure are clearly separated:
* OpenLibrary fails: we do no more than display an error message
  (note we can't use reqtools for that!)
* OpenLibrary succeeds: we can call reqtools functions, we must close
  the library when done

These two properties considered as a whole is resource parenthesization.

@ENDNODE


@NODE Tracking "Amiga-E: Tracking with exceptions"

Tracking with exceptions
************************

The above program seems clear enough, however it's not a realistic program.
A realistic program involves more libraries, files and memory resources.
But the resource tracking should not be at the cost of obfuscating
your program with multiple nested IF statements that implement resource
parenthesization.
The main burden is resource parenthesization introduces indentation levels
that make your program logic appear more complex than it actually is.
Thanksfully E exceptions allow the indentation level to come back to 0,
while making resource tracking even more safe and readeable.
Thus your program indentation will only reflect its main logic, not
being cluttered with extraneous conditionnal statements.

Here is how our HelloWorld example should be changed:

OPT OSVERSION=37

MODULE 'reqtools'

ENUM ERR_OK,ERR_NOREQTOOLS

PROC main() HANDLE
  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase=NIL THEN Raise(ERR_NOREQTOOLS)
  RtEZRequestA('Hello World!','Ok',0,0,0)
EXCEPT DO
  SELECT exception
  CASE ERR_NOREQTOOLS
    PrintF('Could not open reqtools.library v37+ !\\n')
  ENDSELECT
  IF reqtoolsbase THEN CloseLibrary(reqtoolsbase)
ENDPROC

This version may seems more complex than the initial version,
however it has a huge advantage: it scales up.
Adding more resources only means adding more "Open", more "Raise",
more "CASE" and more "Close" statements.
Whatever complex the resources the program logic is simple and fixed.

Don't use automatic exceptions however: it makes things more implicit,
which is not usually a good idea.
Make explicit as much as possible.

@ENDNODE


@NODE Environment "Amiga-E: Program environment"

Program environment
*******************

A program can be launched from either Shell or Workbench.
Both cases should be handled well.
The variable @{b}wbmessage@{ub} gives info about the launching environment.
If program is launched from Workbench then @{b}wbmessage@{ub}<>NIL.
If program is launched from Shell then @{b}wbmessage@{ub}=NIL.

Of course if the program is launched from Shell then we prefer text
to be printed in console rather than a requester to be opened.
So we use @{b}wbmessage@{ub} to distinguish both cases.

Another important Shell feature is returned error code:
* we should return 0 if everything is okay
* or return 5 for a warning (program is still able to proceed)
* or return 10 for an error (program is unable to proceed)
* or return 20 for a failure (program is unable to totally recover error)

S:startup-sequence uses FAILAT 21, so don't return error above 20.

Here is how our HelloWorld example should be changed:

OPT OSVERSION=37

MODULE 'reqtools'

ENUM ERR_OK,ERR_NOREQTOOLS

PROC main() HANDLE
  DEF rcode
  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase=NIL THEN Raise(ERR_NOREQTOOLS)
  display('Hello World!')
EXCEPT DO
  SELECT exception
  CASE ERR_NOREQTOOLS
    PrintF('Could not open reqtools.library v37+ !\\n')
    rcode:=10
  DEFAULT
    rcode:=0
  ENDSELECT
  IF reqtoolsbase THEN CloseLibrary(reqtoolsbase)
ENDPROC rcode

PROC display(msg)
  IF wbmessage
    RtEZRequestA(msg,'Ok',0,0,0)
  ELSE
    PrintF('\\s\\n',msg)
  ENDIF
ENDPROC

@ENDNODE


@NODE ReadArgs "AmigaOS: Shell arguments"

Shell arguments
***************

Shell arguments are parsed by the ReadArgs() function from the dos.library,
you provide ReadArgs() with a buffer of LONGs, then ReadArgs() puts all the
results in the buffer.
Of course you must use FreeArgs() when done.

This simple example echoes the MESSAGE shell argument:

OPT OSVERSION=37

ENUM ERR_OK,ERR_ARGS

DEF myargs:PTR TO LONG,rdargs

PROC main() HANDLE
  myargs:=[0]
  rdargs:=ReadArgs('MESSAGE/A',myargs,NIL)
  IF rdargs=NIL THEN Raise(ERR_ARGS)
  PrintF('\\s\\n',myargs[0])
EXCEPT DO
  SELECT exception
  CASE ERR_ARGS
    PrintF('Bad Args!\\n')
  ENDSELECT
  IF rdargs THEN FreeArgs(rdargs)
ENDPROC

See the Autodocs for more information about ReadArgs().

@ENDNODE


@NODE Tooltypes "AmigaOS: Workbench arguments"

Workbench arguments
*******************

Tooltypes are very handy, very versatile and even more useful than Shell
arguments, because tooltypes are stored. So you may want to take advantage
of tooltypes even when starting with Shell.

Here is how you read the tooltypes:

1. open the icon.library
Then if you start from the Shell:
2. get the program pathname,
   via GetProgramName() from dos.library
Else you start from the Workbench:
2a. get the program path @{b}wbmessage.arglist.lock@{ub},
    via NameFromLock() from the dos library
2b. append the program name @{b}wbmessage.arglist.name@{ub},
    via AddPart() from the dos library
Continue:
3. load the program icon using GetDiskObject() from the icon.library
4. retrieve tooltypes via FindToolType() from the icon.library,
   non-existent tooltypes return NIL
5. when done, you have to free the icon object via FreeDiskObject()

The following program code illustrates the whole proces, it reads the
MESSAGE tooltype in the program info file, and displays it in the Shell
or on the Workbench:

OPT OSVERSION=37

MODULE 'reqtools','icon'
MODULE 'workbench/startup','workbench/workbench'

ENUM ERR_OK,ERR_NOREQTOOLS,ERR_NOICON,ERR_NOINFO,ERR_NOMESSAGE

DEF prog[80]:STRING
DEF wbmsg:PTR TO wbstartup
DEF diskobj:PTR TO diskobject

PROC main() HANDLE
  DEF rcode,msg

  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase=NIL THEN Raise(ERR_NOREQTOOLS)

  iconbase:=OpenLibrary('icon.library',37)
  IF iconbase=NIL THEN Raise(ERR_NOICON)

  IF wbmessage
    wbmsg:=wbmessage
    NameFromLock(wbmsg.arglist.lock,prog,80)
    AddPart(prog,wbmsg.arglist.name,80)
  ELSE
    GetProgramName(prog,80)
  ENDIF
  IF (diskobj:=GetDiskObject(prog))=NIL THEN Raise(ERR_NOINFO)

  msg:=FindToolType(diskobj.tooltypes,'MESSAGE')
  IF msg=NIL THEN Raise(ERR_NOMESSAGE)

  display(msg)

EXCEPT DO

  rcode:=10

  SELECT exception
  CASE ERR_NOREQTOOLS
    PrintF('Could not open reqtools.library v37+ !\\n')
  CASE ERR_NOICON
    display('Could not open icon.library v37+ !')
  CASE ERR_NOINFO
    display('Could not open .info file!')
  CASE ERR_NOMESSAGE
    display('Could not find MESSAGE tooltype!')
  DEFAULT
    rcode:=0
  ENDSELECT

  IF diskobj THEN FreeDiskObject(diskobj)
  IF iconbase THEN CloseLibrary(iconbase)
  IF reqtoolsbase THEN CloseLibrary(reqtoolsbase)

ENDPROC rcode

PROC display(msg)
  IF wbmessage
    RtEZRequestA(msg,'Ok',0,0,0)
  ELSE
    PrintF('\\s\\n',msg)
  ENDIF
ENDPROC

@ENDNODE


@NODE Version "AmigaOS: Program version"

Program version
***************

A program version string is just like any standard version string:

OPT OSVERSION=37

PROC main()
  PrintF('Hello World!\\n')
ENDPROC

CHAR '$VER: HelloWorld 1.0 (04.05.2004) Copyright © Damien Guichard'

Then the C:Version command can be used to display program info.
If you don't already have it be sure you get VersionWB by Håkan Parting:

  aminet/util/sys/VersionWB.lha

@ENDNODE


@NODE Localization "AmigaOS: Program localization"

Program localization
********************

The locale.library allows program localization.
To localize a program is quite easy.
A catalog contains all the program strings.
It is opened via OpenCatalogA() and closed via CloseCatalog().
Meanwhile all strings are retrieved via GetCatalogStr().

Use EasyCatalog to produce the actual catalog:

  aminet/dev/misc/EasyCatalog.lha

Here is how an HelloWorld can be localized:

OPT OSVERSION=37

MODULE 'locale'

ENUM ERR_OK,ERR_NOLOCALE

ENUM CAT_HELLO

DEF cat

PROC main() HANDLE
  localebase:=OpenLibrary('locale.library',38)
  IF localebase=NIL THEN Raise(ERR_NOLOCALE)
  cat:=OpenCatalogA(NIL,'hello.catalog',NIL)
  PrintF(GetCatalogStr(cat,CAT_HELLO,'Hello World!\\n'))
EXCEPT DO
  SELECT exception
  CASE ERR_NOLOCALE
    PrintF('Could not open locale.library v38+ !\\n')
  ENDSELECT
  IF cat THEN CloseCatalog(cat)
  IF localebase THEN CloseLibrary(localebase)
ENDPROC

This program could write 'Bonjour le monde!\\n' if the appropriate catalog
and language were selected.
Note there is no need to abort the program if OpenCatalogA fails.
The program would then use the program builtin strings.

Important note: if your selected language is english then OpenCatalogA
will NOT open a catalog, even if you provide an english catalog, it will
return NIL anyway. To test localization you have to select another language
than english.

@ENDNODE


@NODE TaskSignals "AmigaOS: Task signals"

Task signals
************

Most GUI applications are event-driven, they sleep waiting some signal that
would awake them. A sleeping task does not consume processor power.
You can make your task to sleep by calling Wait() with the appropriate events
you want to be signaled.

As an example this program sleeps until you signal it with the "Break" button
of PriMan v2.0 :

OPT OSVERSION=37

CONST SIGNAL_BREAK=$1000

PROC main()
  PrintF('sleeping... (use PriMan v2.0 to continue)\\n')
  Wait(SIGNAL_BREAK)
  PrintF('running...\\n')
ENDPROC

PriMan v2.0 can be found here:

  aminet/util/moni/Priman20.lha

Later we will see how Wait() can be used to wait more events, including
window events.

@ENDNODE


@NODE TagLists "Amiga-E: Tag lists"

Tag lists
*********

Tag lists are a highly versatile way to pass arguments to AmigaOS functions.
A tag list is just a LONG array terminated by 0.
They always have the following form:

  [TAG1,info1,TAG2,info2,...,0]

The uppercase TAG part designates the attribut modified by the "info" part.
The "info" part is the value/information itself.
Tag-lists are a native data type in Amiga-E.

Note that tag-lists are statically allocated.
If you want dynamically allocated tag-lists, you have to use NEW:

  NEW [TAG1,info1,TAG2,info2,...,0]

Among many other libraries, Intuition and Gadtools make intensive usage
of tag lists.
See the Includes and Autodocs of the utility.library for more information
about tag lists.

@ENDNODE


@NODE ExecLists "AmigaOS: Exec lists"

Exec lists
**********

Whereas a tag-list is much like a static array of info, an Exec list is more
like a dynamic linked list where you can add/remove list nodes.
The basic functions to construct and modify an Exec list are AddHead,AddTail,
RemHead,RemTail,Insert and Remove.

This function allocates a new empty Exec list:

MODULE 'exec/nodes','exec/lists'

PROC newlist()
  DEF list:PTR TO mlh
  list:=NewR(SIZEOF mlh)
  list.head:=list+4
  list.tailpred:=list
ENDPROC list

And this function takes a name and returns a new Exec list node with the
specified name:

PROC newnode(name)
ENDPROC NEW [0,0,0,0,name]:ln

See the exec.library Autodocs plus the exec/lists.h and exec/nodes.h Includes
for more information about Exec lists.

@ENDNODE


@NODE Intuition "AmigaOS with Amiga-E: Intuition"

Intuition
*********

Here is the general process of creating, handling and closing a window user
interface:

* you provide the WA_FLAGS, they specify the window equipment
* you provide the WA_IDCMP, they specify the window events to be notified
* you open the window via @{b}OpenWindowTagList()@{ub}
* your window message port is @{b}win.userport@{ub}
* the corresponding signal is @{b}Shl(1,win.userport.sigbit)@{ub}
* you wait any signal, including the window message port signal
* when you receive a signal from this window port then:
*   1. get the message via @{b}imsg:=GetMsg(win.userport)@{ub}
*   2. the window event is @{b}imsg.class@{ub}
*   3. the eventual concerned gadget is @{b}imsg.iaddress@{ub}
*   4. reply via @{b}ReplyMsg(imsg)@{ub}
*   5. when an IDCMP_REFRESHWINDOW event is received yo have to call
*      BeginRefresh(), then update window graphics, and then call EndRefresh()
* when done you flush the window message port and close the window

OPT OSVERSION=37

MODULE 'exec/ports'
MODULE 'reqtools','intuition/intuition'

ENUM ERR_OK,ERR_NOREQTOOLS,ERR_NOWINDOW

CONST SIGNAL_BREAK=$1000

DEF win:PTR TO window
DEF iclass,icode,igad:PTR TO gadget

PROC main() HANDLE
  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase=NIL THEN Raise(ERR_NOREQTOOLS)
  win:=OpenWindowTagList(NIL,
     [WA_TITLE, 'My Window',
      WA_FLAGS, WFLG_SIZEGADGET+WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+
                WFLG_DRAGBAR+WFLG_SIMPLE_REFRESH+WFLG_ACTIVATE,
      WA_IDCMP, IDCMP_CLOSEWINDOW+IDCMP_REFRESHWINDOW,
      WA_MINWIDTH,  140,
      WA_MINHEIGHT, 35,
      NIL])
  IF win=NIL THEN Raise(ERR_NOWINDOW)
  handle()
EXCEPT DO
  SELECT exception
  CASE ERR_NOREQTOOLS
    PrintF('Could not open reqtools.library v37+ !\\n')
  CASE ERR_NOWINDOW
    RtEZRequestA('Could not open window!','Ok',0,0,0)
  ENDSELECT
  IF win THEN CloseWindow(win)
  IF reqtoolsbase THEN CloseLibrary(reqtoolsbase)
ENDPROC

PROC handle() HANDLE
  DEF signals,winsig,imsg:PTR TO intuimessage
  winsig:=Shl(1,win.userport.sigbit)
  LOOP
    signals:=Wait(winsig+SIGNAL_BREAK)
    IF signals AND winsig
      WHILE imsg:=GetMsg(win.userport)
        iclass:=imsg.class
        icode:=imsg.code
        igad:=imsg.iaddress
        ReplyMsg(imsg)
        SELECT iclass
        CASE IDCMP_REFRESHWINDOW
          BeginRefresh(win)
          EndRefresh(win,TRUE)
        CASE IDCMP_CLOSEWINDOW
          Raise(0)
        ENDSELECT
      ENDWHILE
    ENDIF
    IF signals AND SIGNAL_BREAK
      Raise(0)
    ENDIF
  ENDLOOP
EXCEPT
  WHILE imsg:=GetMsg(win.userport)
    ReplyMsg(imsg)
  ENDWHILE
ENDPROC


Note that you don't have to open/close the intuition.library, that is done by
the Amiga-E startup code.

See the Includes and Autodocs for more information about WA_FLAGS,WA_IDCMP,
OpenWindowTagList(),intuimessage, BeginRefresh() and EndRefresh().

@ENDNODE


@NODE Gadtools "AmigaOS with Amiga-E: Gadtools"

Gadtools
********

If we want nice ready-made gadgets, easy menus and more fancy features, then
intuition is not sufficient, we need a GUI toolkit above intuition.
Gadtools is a good candidate to start with. Later you may choose BOOPSI, MUI,
Reaction or Feelin, but first you have to learn the basics with Gadtools.

Gadtools works much like intuition, the only difference are:
* we have to open/close gadtools.library
* GetMsg/ReplyMsg becomes Gt_GetIMsg/Gt_ReplyIMsg
* BeginRefresh/EndRefresh becomes Gt_BeginRefresh/Gt_EndRefresh
* there is extra initialization with GetVisualInfoA() and CreateContext()
* once window is opened you have to call Gt_RefreshWindow()

We also want to benefit from the menu capabilities of Gadtools so:
* we have to create the menu via CreateMenuA() and LayoutMenuA()
* when done we have to free the menu via ClearMenuStrip() and FreeMenus()

Simple as it is this window code is the same again and again so we put in a
'gt_window' module:

OPT MODULE
OPT EXPORT

MODULE 'exec/ports'
MODULE 'reqtools','intuition/intuition'
MODULE 'gadtools','libraries/gadtools'

ENUM ERR_OK,ERR_NOREQTOOLS,ERR_NOGADTOOLS,ERR_NOSCREEN,
     ERR_NOVISUAL,ERR_NOCONTEXT,ERR_NOMENU,ERR_NOGADGET,ERR_NOWINDOW

CONST SIGNAL_BREAK=$1000

PROC gt_openwindow(windef,newmenu,winhandler) HANDLE
  DEF win=NIL:PTR TO window,iclass,icode,igad
  DEF signals,winsig,imsg:PTR TO intuimessage
  DEF scr=NIL,visual=NIL,context,gadlist=NIL,menu=NIL
  reqtoolsbase:=OpenLibrary('reqtools.library',37)
  IF reqtoolsbase=NIL THEN Raise(ERR_NOREQTOOLS)
  gadtoolsbase:=OpenLibrary('gadtools.library',37)
  IF gadtoolsbase=NIL THEN Raise(ERR_NOGADTOOLS)
  IF (scr:=LockPubScreen('Workbench'))=NIL THEN Raise(ERR_NOSCREEN)
  IF (visual:=GetVisualInfoA(scr,NIL))=NIL THEN Raise(ERR_NOVISUAL)
  IF (context:=CreateContext({gadlist}))=NIL THEN Raise(ERR_NOCONTEXT)
  IF newmenu
    IF (menu:=CreateMenusA(newmenu,NIL))=NIL THEN Raise(ERR_NOMENU)
    IF LayoutMenusA(menu,visual,NIL)=FALSE THEN Raise(ERR_NOMENU)
  ENDIF
  IF (win:=windef(scr,context,visual,gadlist))=NIL THEN Raise(ERR_NOWINDOW)
  IF menu THEN IF SetMenuStrip(win,menu)=FALSE THEN Raise(ERR_NOMENU)
  Gt_RefreshWindow(win,NIL)
  winsig:=Shl(1,win.userport.sigbit)
  LOOP
    signals:=Wait(winsig+SIGNAL_BREAK)
    IF signals AND winsig
      WHILE imsg:=Gt_GetIMsg(win.userport)
        iclass:=imsg.class
        icode:=imsg.code
        igad:=imsg.iaddress
        Gt_ReplyIMsg(imsg)
        winhandler(win,iclass,icode,igad)
      ENDWHILE
    ENDIF
    IF signals AND SIGNAL_BREAK
      Raise(0)
    ENDIF
  ENDLOOP
EXCEPT DO
  WHILE imsg:=Gt_GetIMsg(win.userport)
    Gt_ReplyIMsg(imsg)
  ENDWHILE
  SELECT exception
  CASE ERR_NOREQTOOLS
    PrintF('Could not open reqtools.library v37+ !\\n')
  CASE ERR_NOGADTOOLS
    RtEZRequestA('Could not open gadtools.library v37+ !','Ok',0,0,0)
  CASE ERR_NOSCREEN
    RtEZRequestA('Could not lock Workbench screen!','Ok',0,0,0)
  CASE ERR_NOVISUAL
    RtEZRequestA('Could not get visual info!','Ok',0,0,0)
  CASE ERR_NOCONTEXT
    RtEZRequestA('Could not create window context!','Ok',0,0,0)
  CASE ERR_NOMENU
    RtEZRequestA('Could not create menu!','Ok',0,0,0)
  CASE ERR_NOGADGET
    RtEZRequestA('Could not create gadget!','Ok',0,0,0)
  CASE ERR_NOWINDOW
    RtEZRequestA('Could not open window!','Ok',0,0,0)
  ENDSELECT
  IF win THEN ClearMenuStrip(win)
  IF menu THEN FreeMenus(menu)
  IF win THEN CloseWindow(win)
  IF gadlist THEN FreeGadgets(gadlist)
  IF visual THEN FreeVisualInfo(visual)
  IF scr THEN UnlockPubScreen(NIL,scr)
  IF gadtoolsbase THEN CloseLibrary(gadtoolsbase)
  IF reqtoolsbase THEN CloseLibrary(reqtoolsbase)
ENDPROC


Now we can open a window just by calling the gt_openwindow() function with an
appropriate window definition and window handler:

OPT OSVERSION=37

MODULE 'intuition/intuition','gadtools'
MODULE '*gt_window'

PROC main()
  gt_openwindow({windef},NIL,{winhandler})
ENDPROC

PROC windef(scr,context,visual,gadlist)
  RETURN OpenWindowTagList(NIL,
    [WA_TITLE, 'My Window',
     WA_FLAGS, WFLG_SIZEGADGET+WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+
               WFLG_DRAGBAR+WFLG_SIMPLE_REFRESH+WFLG_ACTIVATE,
     WA_IDCMP, IDCMP_CLOSEWINDOW+IDCMP_REFRESHWINDOW,
     WA_MINWIDTH,  140,
     WA_MINHEIGHT, 35,
     WA_GADGETS,   gadlist,
     NIL])
ENDPROC

PROC winhandler(win,iclass,icode,igad)
  SELECT iclass
  CASE IDCMP_REFRESHWINDOW
    Gt_BeginRefresh(win)
    Gt_EndRefresh(win,TRUE)
  CASE IDCMP_CLOSEWINDOW
    Raise(0)
  ENDSELECT
ENDPROC

@ENDNODE


@NODE Menus "AmigaOS: Gadtools menus"

Gadtools menus
**************

The first thing is to add IDCMP_MENUPICK in your window IDCMPs.
Second you have to provide a filled @{b}newmenu@{ub} structure.
Then each time a menu entry is selected your window handler is called with
@{b}iclass@{ub} set to IDCMP_MENUPICK and @{b}icode@{ub} containing a menu number.

From this menu number the following functions extracts the menu item number and
the menu sub-item number:

PROC itemnum(n)                // menu item
ENDPROC Shr(n,5) AND $3F

PROC subnum(n)                 // menu sub item
ENDPROC Shr(n,11) AND $1F

See the Includes libraries/gadtools.h and intuition/intuition.h for more
information about the Gadtools menus.

@ENDNODE


@NODE Gadgets "AmigaOS: Gadtools gadgets"

Gadtools gadgets
****************

The CreateGadgetA() function is called to create and link a new Gadtools
gadget to the window.
CreateGadgetA() expects a gadget kind such as SCROLLER_KIND or LISTVIEW_KIND,
plus a filled @{b}newgadget@{ub} structure and a taglist.
The @{b}newgadget@{ub} structure mainly contains gadget dimensions plus visual info.
The tag-list is kind-specific, see libraries/gadtools.h for what tags can be
used with your gadget kind.
You don't have to test each gadget creation, you test the last gadget creation,
it would fail if any previous gadget creation has failed.

The LISTVIEW_KIND gadget can be given an Exec list as initial contents, so we
have to contruct this list before creating the listview gadget.

Another thing is that the gadgets coordinates are given relative to window
exterior frame, not to window interior frame, hence the @{b}offx@{ub} and @{b}offy@{ub}
calculations.

This calendar demo illustrates how a complete GUI with menu is created with
Gadtools:

OPT OSVERSION=37

MODULE 'intuition/intuition','intuition/screens','intuition/gadgetclass'
MODULE 'gadtools','libraries/gadtools'
MODULE 'utility/tagitem','graphics/rastport'
MODULE 'exec/nodes','exec/lists'
MODULE '*gt_window'

PROC main()
  DEF menu
  menu:=[NM_TITLE,0,'Project',0,0,0,0,
         NM_ITEM,0,'New','N',0,0,0,
         NM_ITEM,0,'Load...','L',0,0,0,
         NM_ITEM,0,'Save','S',0,0,0,
         NM_ITEM,0,'Babbling',0,0,0,0,
         NM_SUB,0,'aaargh','A',0,0,0,
         NM_SUB,0,'hmmm','H',0,0,0,
         NM_ITEM,0,NM_BARLABEL,0,0,0,0,
         NM_ITEM,0,'Quit','Q',0,0,0,
         0,0,0,0,0,0,0]:newmenu
  gt_openwindow({windef},menu,{winhandler})
ENDPROC

PROC newlist()
  DEF list:PTR TO mlh
  list:=NewR(SIZEOF mlh)
  list.head:=list+4
  list.tailpred:=list
ENDPROC list

PROC insert(list,name)
  AddTail(list,NEW [0,0,0,0,name]:ln)
ENDPROC

PROC windef(scr:PTR TO screen,gad,visual,glist)
  DEF offx,offy,labels=NIL

  offx:=scr.wborleft
  offy:=scr.wbortop+scr.rastport.txheight+1

  gad:=CreateGadgetA(CYCLE_KIND,gad,
    [offx+20,offy+9,155,16,NIL,scr.font,0,0,visual,0]:newgadget,
    [GTCY_LABELS,
     ['Monday','Tuesday','Wednesday','Thursday','Friday','Saturday','Sunday',
     NIL],
     TAG_DONE])

  gad:=CreateGadgetA(SLIDER_KIND,gad,
    [offx+40,offy+36,135,16,NIL,scr.font,0,0,visual,0]:newgadget,
    [GTSL_MIN,1,
     GTSL_MAX,31,
     GTSL_LEVELFORMAT,'\\d[2]',
     GTSL_MAXLEVELLEN,2,
     TAG_DONE])

  labels:=newlist()
  insert(labels,'January')
  insert(labels,'February')
  insert(labels,'March')
  insert(labels,'April')
  insert(labels,'May')
  insert(labels,'June')
  insert(labels,'July')
  insert(labels,'August')
  insert(labels,'September')
  insert(labels,'October')
  insert(labels,'November')
  insert(labels,'December')

  gad:=CreateGadgetA(LISTVIEW_KIND,gad,
    [offx+20,offy+63,155,100,NIL,scr.font,0,0,visual,0]:newgadget,
    [GTLV_SCROLLWIDTH,20,
     GTLV_LABELS,labels,
     TAG_DONE])

  IF gad=NIL THEN Raise(ERR_NOGADGET)

  RETURN OpenWindowTagList(NIL,
    [WA_TITLE, 'Calendar Demo',
     WA_FLAGS,  WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+WFLG_DRAGBAR+
                WFLG_SIMPLE_REFRESH+WFLG_ACTIVATE,
     WA_IDCMP,  IDCMP_CLOSEWINDOW+IDCMP_REFRESHWINDOW+
                IDCMP_GADGETDOWN+IDCMP_GADGETUP+IDCMP_MOUSEMOVE+IDCMP_MENUPICK,
     WA_LEFT,   70,
     WA_TOP,    40,
     WA_WIDTH,  200,
     WA_HEIGHT, offy+176,
     WA_GADGETS,      glist,
     WA_NEWLOOKMENUS, TRUE,
     WA_AUTOADJUST,   TRUE,
     TAG_DONE])

ENDPROC

PROC itemnum(n)
ENDPROC Shr(n,5) AND $3F

PROC winhandler(win,iclass,icode,igad)
  SELECT iclass
  CASE IDCMP_CLOSEWINDOW
    Raise(ERR_OK)
  CASE IDCMP_REFRESHWINDOW
    Gt_BeginRefresh(win)
    Gt_EndRefresh(win,TRUE)
  CASE IDCMP_MENUPICK
    IF itemnum(icode)=5 THEN Raise(ERR_OK)
  ENDSELECT
ENDPROC


The way the program interacts with the GUI is via win,iclass,icode,igad, the
parameters of the window handler.
See the Includes libraries/gadtools.h for more information about the Gadtools
gadgets.

@ENDNODE


@NODE Interaction "AmigaOS: Interaction with gadtools "

Interaction
***********

Interaction with Gadtools gadgets is much like interaction with menus except
@{b}class@{ub} is typically IDCMP_GADGETUP and @{b}gad@{ub} contains the concerned gadget.

To help the identification of @{b}gad@{ub} it is convenient to provide a gadgetid
in the newmenu structure. Then response to IDCMP_GADGETUP is selected according
to the @{b}gad.gadgetid@{ub} value.

Reading and updating gadget attributs is not symmetric.
As an example, read @{b}gad.specialinfo.longint@{ub} for the integer value of an
INTEGER_KIND gadget. But to update the value you must use a different method,
you have to call Gt_SetGadgetAttrsA() and specify the new value of the
GTIN_NUMBER attribut. Then Gadtools not only changes @{b}gad.specialinfo.longint@{ub}
but it also updates the display

OPT OSVERSION=37

MODULE 'intuition/intuition','intuition/screens'
MODULE 'reqtools','gadtools','libraries/gadtools'
MODULE 'utility/tagitem','graphics/rastport'
MODULE '*gt_window'

DEF display:PTR TO gadget
DEF result=0
DEF value=0

PROC main()
  DEF newmenu
  newmenu:=[NM_TITLE,0,'Calculator',0,0,0,0,
            NM_ITEM,0,'Reset','R',0,0,0,
            NM_ITEM,0,'About','A',0,0,0,
            NM_ITEM,0,'Quit','Q',0,0,0,
            0,0,0,0,0,0,0]:newmenu
  gt_openwindow({windef},newmenu,{winhandler})
ENDPROC

PROC windef(scr:PTR TO screen,gad,visual,glist)
  DEF offx,offy

  offx:=scr.wborleft
  offy:=scr.wbortop+scr.rastport.txheight+1

  gad:=display:=CreateGadgetA(INTEGER_KIND,gad,
    [offx+10,offy+8,124,22,NIL,scr.font,0,0,visual,0]:newgadget,
    NIL)

  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+10,offy+36,40,20,'7',scr.font,7,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+52,offy+36,40,20,'8',scr.font,8,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+94,offy+36,40,20,'9',scr.font,9,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+10,offy+58,40,20,'4',scr.font,4,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+52,offy+58,40,20,'5',scr.font,5,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+94,offy+58,40,20,'6',scr.font,6,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+10,offy+80,40,20,'1',scr.font,1,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+52,offy+80,40,20,'2',scr.font,2,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+94,offy+80,40,20,'3',scr.font,3,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+10,offy+102,40,20,'0',scr.font,0,0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+52,offy+102,40,20,'+',scr.font,"+",0,visual,0]:newgadget,
    NIL)
  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+94,offy+102,40,20,'=',scr.font,"=",0,visual,0]:newgadget,
    NIL)

  IF gad=NIL THEN Raise(ERR_NOGADGET)

  RETURN OpenWindowTagList(NIL,
    [WA_TITLE, 'Minicalc Demo',
     WA_FLAGS,  WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+WFLG_DRAGBAR+
                WFLG_SIMPLE_REFRESH+WFLG_ACTIVATE,
     WA_IDCMP,  IDCMP_CLOSEWINDOW+IDCMP_REFRESHWINDOW+
                IDCMP_GADGETUP+IDCMP_MENUPICK,
     WA_LEFT,   70,
     WA_TOP,    40,
     WA_WIDTH,  150,
     WA_HEIGHT, offy+136,
     WA_GADGETS,      glist,
     WA_NEWLOOKMENUS, TRUE,
     WA_AUTOADJUST,   TRUE,
     TAG_DONE])

ENDPROC

PROC itemnum(n)
ENDPROC Shr(n,5) AND $3F

PROC winhandler(win,class,code,gad:PTR TO gadget)
  SELECT class
  CASE IDCMP_CLOSEWINDOW
    Raise(ERR_OK)
  CASE IDCMP_REFRESHWINDOW
    Gt_BeginRefresh(win)
    Gt_EndRefresh(win,TRUE)
  CASE IDCMP_GADGETUP
    IF gad=display
      result:=result+gad.specialinfo::stringinfo.longint
      Gt_SetGadgetAttrsA(display,win,NIL,[GTIN_NUMBER,result,0])
      value:=0
    ELSEIF (gad.gadgetid>=0) AND (gad.gadgetid<=9)
      value:=Mul(10,value)+gad.gadgetid
      Gt_SetGadgetAttrsA(display,win,NIL,[GTIN_NUMBER,value,0])
    ELSEIF gad.gadgetid="+"
      result:=result+value; value:=0
      Gt_SetGadgetAttrsA(display,win,NIL,[GTIN_NUMBER,0,0])
    ELSEIF gad.gadgetid="="
      result:=result+value
      Gt_SetGadgetAttrsA(display,win,NIL,[GTIN_NUMBER,result,0])
      value:=0; result:=0
    ENDIF
  CASE IDCMP_MENUPICK
    IF itemnum(code)=0
      value:=0; result:=0
      Gt_SetGadgetAttrsA(display,win,NIL,[GTIN_NUMBER,0,0])
    ELSEIF itemnum(code)=1
      RtEZRequestA('Demo: Mini Calculator\\nAuthor: Damien Guichard\\n','Ok',0,0,0)
    ELSEIF itemnum(code)=2
      Raise(ERR_OK)
    ENDIF
  ENDSELECT
ENDPROC

@ENDNODE


@NODE Shortcuts "AmigaOS: Keyboard shortcuts"

Keyboard shortcuts
******************

Gadtools knows about menu shortcuts and sends the appropriate IDCMP_MENUPICK message. However Gadtools ignores the keyboard shortcuts for gadgets, the corresponding keyboard events have to be explicitly filtered by the programmer. 

You add IDCMP_VANILLAKEY to the window's WA_IDCMP so that you are notified each time a keyboard key is pressed. Then @{b}imsg.code@{ub} contains the character code and it's up to you to issue the pertaining action. 

As a visual clue for the final user about keyboard shortcuts, you can specify GT_UNDERSCORE,"_" in the taglist of the CreateGadgetA() call. Then you place a "_" character in the gadget label, so that "_quit" means the user can quit by pressing the "q" key.

The code example in the next chapter illustrates how you handle keyboard shortcuts.

@ENDNODE


@NODE AppWindows "AmigaOS: AppWindows"

AppWindows
**********

How to create an AppWindow :
* we have to open/close the workbench.library
* an already opened window becomes an appwindow via AddAppWindowA().
* then we can receive appmessages.
* @{b}appmsg.type@{ub}=AMTYPE_APPWINDOW means an appwindow event.
* @{b}appmsg.numargs@{ub} is how many icons have been dropped in the appwindow.
* @{b}appmsg.arglist@{ub} is the dropped icons, much like a WB Startup message.
* before closing the window we have to call RemoveAppWindow().

This demo lists all dropped icons in a ListView gadget, use the menu entry or the keyboard shortcut to quit, "new" clears the ListView, the "save" action is just a placeholder:

OPT OSVERSION=37

MODULE 'intuition/intuition','intuition/screens','intuition/gadgetclass'
MODULE 'gadtools','libraries/gadtools'
MODULE 'wb','workbench/startup','workbench/workbench'
MODULE 'utility/tagitem','graphics/rastport'
MODULE 'exec/nodes','exec/lists'
MODULE '*gt_window'

CONST ERR_NOWB=ERR_NOWINDOW+1

DEF win:PTR TO window
DEF appwin=NIL
DEF listview=NIL
DEF labels:PTR TO mlh

DEF path[80]:STRING

PROC main() HANDLE
  DEF menu
  workbenchbase:=OpenLibrary('workbench.library',37)
  IF workbenchbase=NIL THEN Raise(ERR_NOWB)
  menu:=[NM_TITLE,0,'Project',0,0,0,0,
         NM_ITEM,0,'New','N',0,0,0,
         NM_ITEM,0,'Load...','L',0,0,0,
         NM_ITEM,0,'Save','S',0,0,0,
         NM_ITEM,0,NM_BARLABEL,0,0,0,0,
         NM_ITEM,0,'Quit','Q',0,0,0,
         0,0,0,0,0,0,0]:newmenu
  gt_openwindow({windef},menu,{winhandler})
EXCEPT DO
  IF workbenchbase THEN CloseLibrary(workbenchbase)
ENDPROC

PROC newlist()
  DEF list:PTR TO mlh
  NEW list
  list.head:=list+4
  list.tailpred:=list
ENDPROC list

PROC insert(list,name)
  AddTail(list,NEW [0,0,0,0,name]:ln)
ENDPROC

PROC windef(scr:PTR TO screen,gad,visual,glist)
  DEF offx,offy

  offx:=scr.wborleft
  offy:=scr.wbortop+scr.rastport.txheight+1

  labels:=newlist()

  gad:=listview:=CreateGadgetA(LISTVIEW_KIND,gad,
    [offx+20,offy+14,255,130,NIL,scr.font,0,0,visual,0]:newgadget,
    [GTLV_SCROLLWIDTH,20,GTLV_LABELS,labels,GTLV_SHOWSELECTED,NIL,TAG_DONE])

  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+20,offy+144,70,18,'_New',scr.font,"N",0,visual,0]:newgadget,
    [GT_UNDERSCORE,"_",TAG_DONE])

  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+112,offy+144,70,18,'_Save',scr.font,"S",0,visual,0]:newgadget,
    [GT_UNDERSCORE,"_",TAG_DONE])


  gad:=CreateGadgetA(BUTTON_KIND,gad,
    [offx+205,offy+144,70,18,'_Quit',scr.font,"Q",0,visual,0]:newgadget,
    [GT_UNDERSCORE,"_",TAG_DONE])

  IF gad=NIL THEN Raise(ERR_NOGADGET)

  win:=OpenWindowTagList(NIL,
    [WA_TITLE, 'AppWin Demo',
     WA_FLAGS,  WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+WFLG_DRAGBAR+
                WFLG_SIMPLE_REFRESH+WFLG_ACTIVATE,
     WA_IDCMP,  IDCMP_CLOSEWINDOW+IDCMP_REFRESHWINDOW+IDCMP_VANILLAKEY+
                IDCMP_GADGETDOWN+IDCMP_GADGETUP+IDCMP_MOUSEMOVE+IDCMP_MENUPICK,
     WA_WIDTH,  300,
     WA_HEIGHT, offy+176,
     WA_ZOOM,   [0,offy,130,offy]:INT,
     WA_GADGETS,      glist,
     WA_NEWLOOKMENUS, TRUE,
     WA_AUTOADJUST,   TRUE,
     TAG_DONE])

  IF win
    appwin:=AddAppWindowA(0,0,win,win.userport,NIL)
  ENDIF

  RETURN win

ENDPROC

PROC itemnum(n)
ENDPROC Shr(n,5) AND $3F

PROC winhandler(msg:PTR TO appmessage,class,code,gad:PTR TO gadget) HANDLE
  IF msg.type=AMTYPE_APPWINDOW
    expand_list(msg)
    Gt_ReplyIMsg(msg)
  ELSE
    Gt_ReplyIMsg(msg)
    SELECT class
    CASE IDCMP_CLOSEWINDOW
      Raise(ERR_OK)
    CASE IDCMP_REFRESHWINDOW
      Gt_BeginRefresh(win)
      Gt_EndRefresh(win,TRUE)
    CASE IDCMP_GADGETUP
      IF gad.gadgetid="N"
        clear_list()
      ELSEIF gad.gadgetid="Q"
        Raise(ERR_OK)
      ENDIF
    CASE IDCMP_MENUPICK
      IF itemnum(code)=0 THEN clear_list()
      IF itemnum(code)=4 THEN Raise(ERR_OK)
    CASE IDCMP_VANILLAKEY
      IF code="n"
        clear_list()
      ELSEIF code="q"
        Raise(ERR_OK)
      ENDIF
    ENDSELECT
  ENDIF
EXCEPT
  IF appwin THEN RemoveAppWindow(appwin)
  Raise(ERR_OK)
ENDPROC

PROC clear_list()
  labels.head:=labels+4
  labels.tailpred:=labels
  Gt_SetGadgetAttrsA(listview,win,NIL,[GTLV_LABELS,labels,0])
ENDPROC

PROC expand_list(msg:PTR TO appmessage)
  DEF i,name
  FOR i:=0 TO msg.numargs-1
    NameFromLock(msg.arglist[i].lock,path,80)
    AddPart(path,msg.arglist[i].name,80)
    name:=String(StrLen(path))
    StrCopy(name,path)
    insert(labels,name)
  ENDFOR
  Gt_SetGadgetAttrsA(listview,win,NIL,[GTLV_LABELS,labels,0])
ENDPROC


AppIcons handling is very similar to AppWindows handling, mainly @{b}appmsg.type@{ub}=AMTYPE_APPICON means an appicon event.

@ENDNODE


@NODE Toolkits "AmigaOS: Gadget Toolkits"

Gadget Toolkits
***************

Gadget toolkits are beyond the scope of this tutorial.
Nevertheless here are some resource and documentation links for the Amiga-E
development with popular gadget toolkits:

MUI:


  http://aminet.net/dev/mui/mui38dev.lha
  http://aminet.net/dev/mui/mui38dev-E.lha

Feelin:

  http://www.feelin.fr/

@ENDNODE


@NODE Arexx "AmigaOS: Arexx Hosts"

Arexx Hosts
***********

An AREXX host greatly augments the interoperability of your program by exposing
its inner functions to the world, thus allowing them to be interactively used,
to be scripted, and to cooperate with the many other AREXX capable amiga
programs.

Interaction with AREXX is gained via the rexxsyslib.library, you create and
name a message port, this message port will be your AREXX host address.
Of course you can use your window message port for that, otherwise you can use
CreateMsgPort() and DeleteMsgPort() from the exec.library
Then you have to set the port priority, and finally make the port public via
AddPort(), which at end will be mirrored by RemPort().

The IsRexxMsg() function will tell you if a received message is an Arexx
message, otherwise it's probably just an intuimessage.

Once you have identified @{b}rxmsg@{ub} as an Arexx message:
* @{b}rxmsg.args[0]@{ub} is the command line string
* interpret the command
* set @{b}rxmsg.result1@{ub} to a return error code (same as DOS return code)
* you can set @{b}rxmsg.result2@{ub} to a string return value such as 'TRUE' or '0'
* finally ReplyMsg(@{b}rxmsg@{ub})

The following hosted commands:

QUIT
MOVE x y
DRAW x y
RECTFILL xmin ymin xmax ymax
ELLIPSE cx cy a b
SETPEN pen
TEXT string

use the graphics.library functions to make an Arexx-scripted paint program,
implemented by this short source:

OPT OSVERSION=37

MODULE 'exec/ports','exec/nodes','intuition/intuition'
MODULE 'rexxsyslib','rexx/storage'

ENUM ERR_OK,ERR_NOREXXSYSLIB,ERR_NOWINDOW

CONST SIGNAL_BREAK=$1000

DEF win:PTR TO window
DEF rastport
DEF xa,ya,xb,yb:LONG

PROC main() HANDLE
  rexxsysbase:=OpenLibrary('rexxsyslib.library',36)
  IF rexxsysbase=NIL THEN Raise(ERR_NOREXXSYSLIB)
  win:=OpenWindowTagList(NIL,
     [WA_TITLE,  'AREXX Paint Demo',
      WA_FLAGS,  WFLG_DEPTHGADGET+WFLG_CLOSEGADGET+WFLG_DRAGBAR+
                 WFLG_NOCAREREFRESH+WFLG_ACTIVATE,
      WA_IDCMP,  IDCMP_CLOSEWINDOW,
      WA_WIDTH,  320,
      WA_HEIGHT, 256,
      WA_AUTOADJUST, TRUE,
      NIL])
  IF win=NIL THEN Raise(ERR_NOWINDOW)
  win.userport::ln.name:='APaint.1'
  win.userport::ln.pri:=5
  AddPort(win.userport)
  rastport:=win.rport
  SetAPen(rastport,1)
  handle()
EXCEPT DO
  SELECT exception
  CASE ERR_NOREXXSYSLIB
    PrintF('Could not open rexxsyslib.library v36+ !\\n')
  CASE ERR_NOWINDOW
    PrintF('Could not open window!\\n')
  ENDSELECT
  IF win THEN CloseWindow(win)
  IF rexxsysbase THEN CloseLibrary(rexxsysbase)
ENDPROC

PROC handle() HANDLE
  DEF signals,winsig,iclass,imsg:PTR TO intuimessage
  DEF cmdline,rxmsg:PTR TO rexxmsg
  winsig:=Shl(1,win.userport.sigbit)
  LOOP
    signals:=Wait(winsig+SIGNAL_BREAK)
    IF signals AND winsig
      WHILE rxmsg:=imsg:=GetMsg(win.userport)
        IF IsRexxMsg(imsg)
          cmdline:=TrimStr(rxmsg.args[0])
          IF StrCmp(cmdline,'QUIT')
            rxmsg.result1:=0
            ReplyMsg(rxmsg)
            Raise(0)
          ELSEIF StrCmp(cmdline,'MOVE ',STRLEN)
            IF read_args(rxmsg,2)
              Move(rastport,xa,ya)
            ENDIF
          ELSEIF StrCmp(cmdline,'DRAW ',STRLEN)
            IF read_args(rxmsg,2)
              Draw(rastport,xa,ya)
            ENDIF
          ELSEIF StrCmp(cmdline,'RECTFILL ',STRLEN)
            IF read_args(rxmsg,4)
              IF (xb>=xa) AND (yb>=ya)
                RectFill(rastport,xa,ya,xb,yb)
              ELSE
                rxmsg.result1:=10
              ENDIF
            ENDIF
          ELSEIF StrCmp(cmdline,'ELLIPSE ',STRLEN)
            IF read_args(rxmsg,4)
              DrawEllipse(rastport,xa,ya,xb,yb)
            ENDIF
          ELSEIF StrCmp(cmdline,'SETPEN ',STRLEN)
            IF read_args(rxmsg,1)
              SetAPen(rastport,xa)
            ENDIF
          ELSEIF StrCmp(cmdline,'TEXT ',STRLEN)
            cmdline:=TrimStr(cmdline+STRLEN)
            Text(rastport,cmdline,StrLen(cmdline))
            rxmsg.result1:=0
          ENDIF
          ReplyMsg(rxmsg)
        ELSE
          iclass:=imsg.class
          ReplyMsg(imsg)
          SELECT iclass
          CASE IDCMP_CLOSEWINDOW
            Raise(0)
          ENDSELECT
        ENDIF
      ENDWHILE
    ENDIF
    IF signals AND SIGNAL_BREAK
      Raise(0)
    ENDIF
  ENDLOOP
EXCEPT
  WHILE imsg:=GetMsg(win.userport)
    ReplyMsg(imsg)
  ENDWHILE
ENDPROC

PROC read_args(rxmsg:PTR TO rexxmsg,num)
  DEF str,ch
  str:=TrimStr(rxmsg.args[0])
  WHILE str[]<>" " DO INC str
  xa,ch:=Val(str); IF ch THEN DEC num; str:=str+ch
  ya,ch:=Val(str); IF ch THEN DEC num; str:=str+ch
  xb,ch:=Val(str); IF ch THEN DEC num; str:=str+ch
  yb,ch:=Val(str); IF ch THEN DEC num; str:=str+ch
  IF num THEN rxmsg.result1:=10 ELSE rxmsg.result1:=0
ENDPROC num=0
 

The following Shell commands allow you to interactively paint in the window:

 RUN >NIL: APaint
 RX "ADDRESS 'APaint.1' ELLIPSE 160 128 100 60"
 RX "ADDRESS 'APaint.1' QUIT"


One thing that this simple example does not handle is multiple program
executions. When executed several times either you want to share the Arexx host
address, otherwise you want multiple hosts such as APaint.1, APaint.2 and more.
The way you generate the port name is you call FindPort('APaint.1'), if it's
not found then create it, else continue with 'APaint.2' and loop until the port
is name is unknown.

See the rexxsyslib.library Autodocs plus the rexx/storage.h Includes for more
information about AREXX communications.

@ENDNODE

