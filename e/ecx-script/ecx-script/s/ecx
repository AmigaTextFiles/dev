.key "Source,O=moreOpts/K,D=Debug/S,DR=DontRun/S"
.bra {
.ket }

; $VER: ecx 1.5 (05.07.13) by Thomas Igracki
;
; A starter for the ecx compiler to be able to jump to the error line 
; in Scribble. And after a successful compile request the user to run 
; the executable. This script is smart enough to dont ask if you're
; compiling a module (OPT MODULE).
;
; Tip: You can use my "Foreach" to compile multiple sources at once!
; Foreach modules/winMain_mcc.e modules/app_mcc.e ecxHelper.e DO "s:ecx %s"
;
; Required commands:
;  c:Replace, FileInfo (http://igracki.de/) and ecx, of course;)
;   
; Bug: The second line of the error-text has a number preceeded, this is due to 
;      a bug in "Search" (bugreport is sent)!
;
; History:
; 05-Jul-13: v1.5
;   fix: because the "Fail" command which should be "FailAt 10", the script didn't worked
;	chg: show the ecx's output also if the compile succeeded
;	chg: changed the error-text extraction
;
; 02-Jul-13: v1.4
;	the error text is now displayed in a requester
;   (the Replace shell-command v1.1 from Martin Kuchinka is needed for that feature!)
;
; 01-Jul-13: v1.3
;	fixed loading the file (to jump to the error line) for relative paths
;
; 29-Jun-13: v1.2
;	added DR=DontRun/S switch -> dont ask to run the executable
;
; 28-Jun-13: v1.1
;	added Debug/S switch, which adds the options SYM and LINEDEBUG to ecx
;
; 26-Jun-13: v1.0
;   first version

; set path to ecx's compiler
Set ecx ecx:bin/ecx.mos
; set your default options
Set opts MorphOS SHOWARGS SHOWFNAME
; all options
; SOURCE/A,NIL=NILCHECK/S,HOLD/S,WBTOFRONT/S,OPTI/S,LARGE/S,SHOWFNAME/S,NOWARN/S,
; VAR=VARDEBUG/S,LINE=LINEDEBUG/S,SYM=SYMBOLHUNK/S,ICA=IGNORECACHE/S,NODEFMODS/S,
; SHOWBUF/S,REG=NUMREGALLOC/N,FREG=NUMFREGALLOC/N,TOADDR/N,ABSOLUTE/N,MDIR=MODULEDIR/K,
; DEFINE/K,DDIR=DESTDIR/K,QUIET/S,EXENAME/K,MODNAME/K,STEP=STEPDEBUG/S,
; POWERPC/S,MORPHOS/S,AMIGAOS/S,SHOWARGS/S,AMIGAOS4/S,OUTFORMAT/K,SHOWCONDSYMS/S,ERRLINE/S,VARFILL/N

IF {Debug}
	; SYMBOLHUNK and LINEDEBUG gets automatically activated, if VARDEBUG is used!
	Set opts $opts VARDEBUG
ENDIF

IF NOT {Source}
   RequestChoice >NIL: TITLE "s:ecx Usage" BODY "s:ecx <ecx source> [O=<more options>] [D=Debug] [DR=DontRun]" Gadgets OK
ELSE
	FailAt 11; because, ecx sets RC to 10 for an error!
	Echo ;just print an empty line, usefull, if you compile multiple sources
	$ecx {Source} $opts {moreOpts} > t:ecx-output
	; Result2 holds the linenumber, if ecx failed to compile your source
	Set lineNr $Result2; we need to get this right after ecx
	FailAt 10
	Type t:ecx-output
	IF $lineNr GT 0
		Search t:ecx-output "ERROR:" LINES 1 NONUM >t:ecx-error__
		c:replace >NIL: t:ecx-error__ TO t:ecx-error_ "*"" "'"
		c:replace >NIL: t:ecx-error_ TO t:ecx-error "*n" "**n"
		; because the replace cmd add a "*" at the end, we need to add a "n"!
		Set errTxt `Type t:ecx-error`n
		; jump to the line number with the error
		rxcmd SCRIBBLE.1 "OPEN FILE `FileInfo FN Q {Source}` LINE $lineNr"
		;bring scribble to front
		rxcmd SCRIBBLE.1 "APPTOFRONT"
		Set RC 20
		RequestChoice TITLE ecx-Script BODY "ecx failed to compile because:*n*n$errTxt" Gadgets OK
	ELSE
		IF NOT {DontRun}
			;test if the source is a module else ask to run it
			IF NOT EXISTS `FileInfo Q FRN {Source}`.m
				Set exe `FileInfo Q RN {Source}`
				IF 1 EQ `RequestChoice TITLE "s:ecx" BODY "{Source} compiled with no errors!*n*n$exe starten?" GADGETS "Yes|No"`
					Run $exe
				ENDIF
			ENDIF
		ENDIF
	ENDIF
ENDIF

UnSet ecx 
UnSet opts
Delete QUIET t:ecx-output
IF $lineNr GT 0
	Delete QUIET t:ecx-error*
	UnSet lineNr
	QUIT 10
ENDIF