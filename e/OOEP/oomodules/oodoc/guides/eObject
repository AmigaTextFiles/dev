@database "eObject"
@master "Ram Disk:T/docs/eObject.doc"

@Node Main "eObject.doc"
    @{" amIPublic() " Link "amIPublic()"}
    @{" buildOffsetList() " Link "buildOffsetList()"}
    @{" getAttributeOffset() " Link "getAttributeOffset()"}
    @{" getInheritedSize() " Link "getInheritedSize()"}
    @{" getName() " Link "getName()"}
    @{" getParentObject() " Link "getParentObject()"}
    @{" getSize() " Link "getSize()"}
    @{" name() " Link "name()"}
    @{" addValue() " Link "addValue()"}
    @{" eObject() " Link "eObject()"}
    @{" getAttributeOffset() " Link "getAttributeOffset()"}
@EndNode

@Node "amIPublic()" "eObject/amIPublic"

@{b}   NAME@{ub}
       amIPublic() of @{"eObject" Link "eObject/eObject()"} -- Is this object visible outside the module?

@{b}   SYNOPSIS@{ub}
       eObject.amIPublic(LONG)

       eObject.amIPublic(line)

@{b}   FUNCTION@{ub}
       Identifies this object as public or private.

@{b}   INPUTS@{ub}
       line:LONG -- Number of the proc's header line. Usually startLine.

@{b}   RESULT@{ub}
       TRUE if the object is public, FALSE otherwise.

@{b}   EXAMPLE@{ub}
       public := object.amIPublic(object.startLine)

@{b}   NOTES@{ub}
       Does not check if the EXPORT option is set for this module.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "buildOffsetList()" "eObject/buildOffsetList"

@{b}   NAME@{ub}
       buildOffsetList() of @{"eObject" Link "eObject/eObject()"} -- Build list of attribute offsets.

@{b}   SYNOPSIS@{ub}
       eObject.buildOffsetList()

@{b}   FUNCTION@{ub}
       Build an @{"elist" Link "elist/elist()"} which contains the byte offets of the attributes.
       Sets the according attribute to this list.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "getAttributeOffset()" "eObject/getAttributeOffset"

@{b}   NAME@{ub}
       getEntries() of @{"eObject" Link "eObject/eObject()"} -- Get list of attributes.

@{b}   SYNOPSIS@{ub}
       eObject.getEntries()

@{b}   FUNCTION@{ub}
       Builds an @{"elist" Link "elist/elist()"} of attributes this object posesses. The entries 
       of this list are initialized @{"eVar" Link "eVar/eVar()"} objects.

@{b}   RESULT@{ub}
       PTR TO LONG -- @{"elist" Link "elist/elist()"} of eVars which represent the attributes of this
           object. A value of NIL represents no attributes.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}, @{"eVar/eVar" Link "eVar/eVar()"}

@EndNode

@Node "getInheritedSize()" "eObject/getInheritedSize"

@{b}   NAME@{ub}
       getInheritedSize() of @{"eObject" Link "eObject/eObject()"} -- Get the 'inherited' size.

@{b}   SYNOPSIS@{ub}
       eObject.getInheritedSize()

@{b}   FUNCTION@{ub}
       Returns the 'inherited' size, i.e. the size of all parent objects.
       Be object a 6 and object b 14 bytes big. Object c which inherits
       from object b would have an inherited size of 20.

@{b}   RESULT@{ub}
       LONG -- the sum of all parental object sizes.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "getName()" "eObject/getName"

@{b}   NAME@{ub}
       getName() of @{"eObject" Link "eObject/eObject()"} -- Get the name of the object from the source.

@{b}   SYNOPSIS@{ub}
       eObject.getName(LONG=0)

       eObject.getName(lineNumber)

@{b}   FUNCTION@{ub}
       Gets the name of this object from the source. If the name was already
       found out just the pointer to this name is returned.

@{b}   INPUTS@{ub}
       lineNumber:LONG -- The number of the line the object definition
           starts, i.e. object.startLine

@{b}   RESULT@{ub}
       PTR TO CHAR -- the name of the object

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "getParentObject()" "eObject/getParentObject"

@{b}   NAME@{ub}
       getParentObject() of @{"eObject" Link "eObject/eObject()"} HANDLE -- Get object I'm inheriting
       from.

@{b}   SYNOPSIS@{ub}
       eObject.getParentObject()

@{b}   FUNCTION@{ub}
       Tries to get the pointer to the object the current one inherits
       from. The result is an initialized @{"eObject" Link "eObject/eObject()"}. Note that the source
       attribute is valid, this means you have to END the source. Keep
       in mind that when you end the source attribute of an object frees
       the object itself, see @{"eSource/end()" Link "string/end()"} for more details.

@{b}   RESULT@{ub}
       PTR TO @{"eObject" Link "eObject/eObject()"} -- The parent object or NIL if I have no parent.

@{b}   EXAMPLE@{ub}

      /*
       * Get the parent object.
       */

       parent := object.getParentObject()


      /*
       * Work with it as you like. All attributes are valid.
       * Here we just dump the attributes.
       */

       dumpObjectAttributes(parent.entryList)

      /*
       * Before we end the object we end the source
       */

       END object.source

@{b}   NOTES@{ub}
       Doesn't get the parent object if it's definition is in the same
       module.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "getSize()" "eObject/getSize"

@{b}   NAME@{ub}
       getSize() of @{"eObject" Link "eObject/eObject()"} -- Gets size of object in bytes.

@{b}   SYNOPSIS@{ub}
       eObject.getSize()

@{b}   FUNCTION@{ub}
       Returns the object's size.

@{b}   RESULT@{ub}
       LONG -- object size. 0 if object has no attributes.

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "name()" "eObject/name"

@{b}   NAME@{ub}
       name() of @{"eObject" Link "eObject/eObject()"} -- Return object identifier.

@{b}   SYNOPSIS@{ub}
       eObject.name()

@{b}   FUNCTION@{ub}
       Returns 'eObject'

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

@Node "addValue()" "private/addValue"

@{b}   NAME@{ub}
       addValue() -- Add value to long variable.

@{b}   SYNOPSIS@{ub}
       addValue(LONG, LONG)

       addValue(var, value)

@{b}   FUNCTION@{ub}
       Adds value to var.

@{b}   INPUTS@{ub}
       var:LONG -- Address of var.

       value:LONG -- Value to add.

@{b}   EXAMPLE@{ub}
       addValue({longvar},42)

@{b}   NOTES@{ub}
       It here for a compiler bug (I suppose) - in @{"getInheritedSize()" Link "getInheritedSize()"}
       it is not possible to initialize a var which should contain
       the sum of all parental object's sizes. The var would contain
       such a nice value like 4237458 and the like. ECv3.2e

@{b}   SEE ALSO@{ub}
       @{"getInheritedSize()" Link "getInheritedSize()"}

@EndNode

@Node "eObject()" "sourceBlock/eObject"

@{b}   NAME@{ub}
       eObject() of sourceBlock --

@{b}   ATTRIBUTES@{ub}
       name:PTR TO CHAR -- 

       inheritsFrom:PTR TO CHAR -- 

       entryList:PTR TO LONG -- @{"elist" Link "elist/elist()"} of attributes of this object. Contains
           pointers to eVars. May be NIL if no attributes are present.

       offsetList:PTR TO LONG -- @{"elist" Link "elist/elist()"} of byte offsets of the attributes.
           For this object this would be [0,4,8,12,16]. Note that this list
           one item longer than the entryList for the last item contains
           the size of this object in bytes. However, this length does not
           include the function table for the methods.

@{b}   SEE ALSO@{ub}
       sourceBlock

@EndNode

@Node "getAttributeOffset()" "eObject/getAttributeOffset"

@{b}   NAME@{ub}
       getAttributeOffset() of @{"eObject" Link "eObject/eObject()"} --

@{b}   SYNOPSIS@{ub}
       eObject.getAttributeOffset(LONG)

       eObject.getAttributeOffset(number)

@{b}   FUNCTION@{ub}

@{b}   INPUTS@{ub}
       number:LONG -- 

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   CREATION@{ub}

@{b}   HISTORY@{ub}

@{b}   NOTES@{ub}

@{b}   SEE ALSO@{ub}
       @{"eObject" Link "eObject/eObject()"}

@EndNode

