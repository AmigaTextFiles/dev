@database "object"
@master "Ram Disk:T/docs/object.doc"

@Node Main "object.doc"
    @{" --background-- " Link "--background--"}
    @{" --object--() " Link "--object--()"}
    @{" derivedClassResponse() " Link "derivedClassResponse()"}
    @{" differentFrom() " Link "differentFrom()"}
    @{" end() " Link "end()"}
    @{" error() " Link "error()"}
    @{" halt() " Link "halt()"}
    @{" init() " Link "init()"}
    @{" name() " Link "name()"}
    @{" new() " Link "new()"}
    @{" opts() " Link "opts()"}
    @{" sameAs() " Link "sameAs()"}
    @{" select() " Link "select()"}
    @{" size() " Link "size()"}
    @{" update() " Link "update()"}
@EndNode

@Node "--background--" "object/--background--"

@{b}   PURPOSE@{ub}
       The base object for everything in the oomodules/ hierarchy.

@{b}   CREATION@{ub}
       in early 1995 by Trey van Riper

@{b}   HISTORY@{ub}

@EndNode

@Node "--object--()" "object/--object--"

@{b}   NAME@{ub}
       object

@{b}   NOTES@{ub}
       The Object object (hmm.. sounds redundant) has no attributes, and
       tons of methods.

       We may decide to create one or two very important global variables
       in the future.  These variables will hold information on various
       system settings which will allow a smoother @{"halt()" Link "halt()"} and some other
       handy functions.  At the moment, though, no global variables exist
       in the Object module.

@EndNode

@Node "derivedClassResponse()" "object/derivedClassResponse"

@{b}   NAME@{ub}
       derivedClassResponse() -- Standard proc for derived responsibility.

@{b}   SYNOPSIS@{ub}
       object.derivedClassResponse()

@{b}   FUNCTION@{ub}
       Call this proc in a method that is non-functional by now, but is
       functional in objects that derive from this. It writes a @{"message" Link "standard/message()"}
       to stdout that tells that this method isn't implemented.

@EndNode

@Node "differentFrom()" "object/differentFrom"

@{b}   NAME@{ub}
       differentFrom() -- Are the objects not of the same kind?

@{b}   SYNOPSIS@{ub}
       object.differentFrom(obj)

@{b}   FUNCTION@{ub}
       This method determines whether or not the current object is a
       different kind of object from the parameter object.  obj is
       assumed to be in the Object heirarchy at some point.

@{b}   INPUTS@{ub}
       obj -- Pointer to any object in the oomodules/ hierarchy.

@{b}   RESULT@{ub}
       TRUE if objects are different, FALSE if the same.

@{b}   NOTES@{ub}
       Doesn't do anything by now, derived objects have to handle this.

@EndNode

@Node "end()" "object/end"

@{b}   NAME@{ub}
       end() -- Global destructor.

@{b}   SYNOPSIS@{ub}
       object.end()

@{b}   FUNCTION@{ub}
       This is the automatic deallocator.  Whenever an object is ENDed,
       this will be called.  While the Object's end() statement does
       nothing, other objects in the hierarchy may be doing some kind
       of housekeeping before deallocating the object.  If you do not
       know whether or not your parent object needs to do some kind of
       housekeeping, do a SUPER self.end() somewhere within your own
       end() statement (if you even need an end() statement).

@{b}   SEE ALSO@{ub}
       @{"new()" Link "new()"}
@EndNode

@Node "error()" "object/error"

@{b}   NAME@{ub}
       error() -- Report error to stderr

@{b}   SYNOPSIS@{ub}
       object.error(string,number)

@{b}   FUNCTION@{ub}
       This calles err_WriteF(a,b) as it stands, and returns NIL. You may
       want to overload this behavior to do something else, or perhaps
       call this from within your own error() routine via SUPER.  The
       err_WriteF() procedure was written by Joseph E. Van Riper III as
       an easy kind of standard error @{"port" Link "port/port()"} for Amiga E... it should be
       found in the emodules:other directory of your structure. If you
       don't have it, you can get it from aminet:dev/e.

       If err_WriteF() is ever called, the programmer must end hir @{"main()" Link "master/main()"}
       program with 'err_Dispose()' before exiting.  This is due to
       certain housekeeping matters in Van Riper's StdErr @{"port" Link "port/port()"}.

@{b}   INPUTS@{ub}
       @{"string" Link "reqtools/string()"} -- String to report.

@EndNode

@Node "halt()" "object/halt"

@{b}   NAME@{ub}
       halt() -- Stop program execution immediately.

@{b}   SYNOPSIS@{ub}
       object.halt(i)

@{b}   FUNCTION@{ub}
       This is intended to stop the entire program dead in its tracks.
       Use this with extreme prejudice, as it doesn't bother to
       deallocate anything (yet), and will likely leave filehandles
       open or memory allocated or any of a hundred other horrible
       system-unfriendly things (it calls CleanUp()).

       In the future, this statement will likely be used to Raise() an
       exception rather than die.

@{b}   INPUTS@{ub}
       i -- Anything you like. Passed to CleanUp().

@EndNode

@Node "init()" "object/init"

@{b}   NAME@{ub}
       init() -- Initialize an object.

@{b}   SYNOPSIS@{ub}
       object.init()

@{b}   FUNCTION@{ub}
       Initializes an object to default startup values.  You very likely
       will want to create your own init() method in your derived objects,
       in order to properly initialize your attributes.  This init()
       method does nothing.  If you're not concerned about the internal
       attributes during initialization, then this method can be left
       alone.

@{b}   SEE ALSO@{ub}
       @{"new()" Link "new()"}, @{"select()" Link "select()"}
@EndNode

@Node "name()" "object/name"

@{b}   NAME@{ub}
       name() -- Get the name of the object.

@{b}   SYNOPSIS@{ub}
       object.name()

@{b}   FUNCTION@{ub}
       This method should be overloaded for each @{"new" Link "resource/new()"} class.  It should
       return a short @{"string" Link "reqtools/string()"} of the name of the object.  In the object
       Object, it's called 'Object'.  This is useful for trying to track
       down certain internal things in the system (particularly some of
       the really funky stuff in the Numbers hierarchy).

@{b}   RESULT@{ub}
       A @{"string" Link "reqtools/string()"} with the name of the object.

@EndNode

@Node "new()" "object/new"

@{b}   NAME@{ub}
       new() -- Create a new instance of an object.

@{b}   SYNOPSIS@{ub}
       object.new(opts=0)

@{b}   FUNCTION@{ub}
       This allows new instances of objects to be created.  It takes as
       an argument an Amiga E list ['such','as','this'] which is then
       parsed by the @{"opts()" Link "opts()"} method, which places a call to the @{"select()" Link "select()"}
       method.  My might want to read up on those.

       In general, you will only want to create new @{"select()" Link "select()"} statements
       for your objects... new() most likely can be left alone.

@{b}   INPUTS@{ub}
       opts=0 -- The optionlist

@{b}   EXAMPLE@{ub}
       When folks go to use objects, they ought to do something like the
       following:

         NEW object.new()

       or if there are options to parse...

         NEW object.new(["boo",'SCREAM'])

@{b}   SEE ALSO@{ub}
       @{"select()" Link "select()"}, @{"init()" Link "init()"}
@EndNode

@Node "opts()" "object/opts"

@{b}   NAME@{ub}
       opts() -- Parse options.

@{b}   SYNOPSIS@{ub}
       object.opts(optionlist)

@{b}   FUNCTION@{ub}
       This runs a FOR/ENDFOR loop that calls @{"select()" Link "select()"}.  It's most
       unlikely that you'll need to modify this method. This method
       may disappear in the future (it might be absorbed by @{"new()" Link "new()"}).

@{b}   INPUTS@{ub}
       optionlist -- The optionlist to parse.

@{b}   SEE ALSO@{ub}
       @{"select()" Link "select()"}, @{"new()" Link "new()"}
@EndNode

@Node "sameAs()" "object/sameAs"

@{b}   NAME@{ub}
       sameAs() -- Compare to another object.

@{b}   SYNOPSIS@{ub}
       object.sameAs(obj:PTR TO object)

@{b}   FUNCTION@{ub}
       This method determines whether or not the current object is the
       same kind of object as the parameter object.  obj is assumed to
       be in the Object heirarchy at some point. Basically, this simply
       compares self.name() to a.name() to see if it's the same value.

@{b}   INPUTS@{ub}
       obj:PTR TO object -- Pointer to any object in the oomodules/
           hierarchy.

@{b}   RESULT@{ub}
       TRUE if both objects are the same, FALSE if not.

@EndNode

@Node "select()" "object/select"

@{b}   NAME@{ub}
       select() -- Selection of action on initialization.

@{b}   SYNOPSIS@{ub}
       object.select(optionlist,index)

@{b}   FUNCTION@{ub}
       You'll definately want to create a 'select' statement if you want
       @{"new()" Link "new()"} to have options enabled.  All select statements should have
       this general format:

       PROC select(optionlist,index) OF myBlowOutObject
       DEF item
         item:=ListItem(optionlist,index)
         SELECT item
           -> various cases and perhaps a default.. could look like this:
           CASE "boo"
          INC @{"index" Link "definitions/index()"}
          self.boo(ListItem(optionlist,index))
         ENDSELECT
       ENDPROC i

       NOTE THE LAST LINE!  If you fail to return i, you could wind up
       with an endless loop!  This would be a bad thing.

@{b}   INPUTS@{ub}
       optionlist -- An @{"elist" Link "elist/elist()"} with tags (or options) that define object
           specific actions.

       @{"index" Link "definitions/index()"} -- Position of item we process next in the list.

@{b}   SEE ALSO@{ub}
       @{"new()" Link "new()"}, @{"init()" Link "init()"}
@EndNode

@Node "size()" "object/size"

@{b}   NAME@{ub}
       size() -- Get the size of the object in bytes

@{b}   SYNOPSIS@{ub}
       object.size()

@{b}   FUNCTION@{ub}
       This returns the SIZEOF the current object.  Most likely, this is
       a superfluous method, and might need to be reconsidered.  In the
       meantime, if you want this method to have any meaning at all, you
       need to calculate the 'SIZEOF' your object either by adding up all
       the attributes and adding four more bytes (for the pointer to its
       methods), or by compiling the object and using ShowModule to see
       the SIZEOF it comes up with.

@{b}   RESULT@{ub}
       The size in bytes

@EndNode

@Node "update()" "object/update"

@{b}   NAME@{ub}
       update() -- Update the object.

@{b}   SYNOPSIS@{ub}
       object.update(a)

@{b}   FUNCTION@{ub}
       This method currently does nothing, but the idea behind this method
       is to cause the object to update itself (freshen its current
       information, perhaps).

@{b}   INPUTS@{ub}
       a -- Use it as you want.

@EndNode

