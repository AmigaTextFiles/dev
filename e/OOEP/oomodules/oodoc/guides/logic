@database "logic"
@master "Ram Disk:T/docs/logic.doc"

@Node Main "logic.doc"
    @{" --logic--() " Link "--logic--()"}
    @{" beFalse() " Link "beFalse()"}
    @{" beTrue() " Link "beTrue()"}
    @{" beUndetermined() " Link "beUndetermined()"}
    @{" copy() " Link "copy()"}
    @{" if() " Link "if()"}
    @{" ifDetermined() " Link "ifDetermined()"}
    @{" ifFalse() " Link "ifFalse()"}
    @{" ifTrue() " Link "ifTrue()"}
    @{" ifUndetermined() " Link "ifUndetermined()"}
    @{" isDetermined() " Link "isDetermined()"}
    @{" isFalse() " Link "isFalse()"}
    @{" isTrue() " Link "isTrue()"}
    @{" isUndetermined() " Link "isUndetermined()"}
    @{" select() " Link "select()"}
    @{" write() " Link "write()"}
@EndNode

@Node "--logic--()" "logic/--logic--"

@{b}   NAME @{ub}
       logic of object

@{b}   PURPOSE@{ub}
       Logic, derived from Object, handles logical statements.  I
       will likely change its name in the future due to further
       considerations (logical terms are different from
       statements).

@{b}   ATTRIBUTES@{ub}
       All logical statements have truth, therefore, truth is its
       only attribute.  Truth is always either TRUE, FALSE, or
       UNDETERMINED.  Unfortunately, Amiga E has already assigned
       values to those three constants, so for my purposes, TRUE is
       '1', FALSE is '-1', and UNDETERMINED is '0'.  Fortunately, I
       have ways of testing this information without having to
       resort to clumsy IF/THEN statements.. more on this later.

@{b}   NOTES@{ub}

@EndNode

@Node "beFalse()" "logic/beFalse"

@{b}   NAME @{ub}
       beFalse() -- Force truth to be false.

@{b}   SYNOPSIS@{ub}
       logic.beFalse()

@{b}   FUNCTION@{ub}
       Forces truth to be false.

@{b}   SEE ALSO@{ub}
       @{"beTrue()" Link "beTrue()"}, @{"beUndetermined()" Link "beUndetermined()"}
@EndNode

@Node "beTrue()" "logic/beTrue"

@{b}   NAME @{ub}
       beTrue() -- Force truth to be true.

@{b}   SYNOPSIS@{ub}
       logic.beTrue()

@{b}   FUNCTION@{ub}
       Forces truth to be true.

@{b}   SEE ALSO@{ub}
       @{"beFalse()" Link "beFalse()"}, @{"beUndetermined()" Link "beUndetermined()"}
@EndNode

@Node "beUndetermined()" "logic/beUndetermined"

@{b}   NAME @{ub}
       beUndetermined() -- Force truth to be undetermined.

@{b}   SYNOPSIS@{ub}
       logic.beUndetermined()

@{b}   FUNCTION@{ub}
       Forces truth to be undetermined.

@{b}   SEE ALSO@{ub}
       @{"beTrue()" Link "beTrue()"}, @{"beFalse()" Link "beFalse()"}
@EndNode

@Node "copy()" "logic/copy"

@{b}   NAME @{ub}
       copy() -- Copy a logic object.

@{b}   SYNOPSIS@{ub}
       logic.copy()

@{b}   FUNCTION@{ub}
       This method allows you to copy a Logic statement.  If a is
       missing, it will create a @{"new" Link "resource/new()"} one.  If a is not missing, it
       will simply copy the contents of its truth to the incoming
       Logic statement.

@{b}   INPUTS@{ub}
       a=NIL:PTR TO object -- Pointer to logic or NIL.

@{b}   RESULT@{ub}
       PTR TO logic -- Freshly created logic object if the incoming
           object pointer was NIL.
@EndNode

@Node "if()" "logic/if"

@{b}   NAME @{ub}
       if() -- If... Then... Else... statement

@{b}   SYNOPSIS@{ub}
       if(quotedExpression,quotedThenExpression,quotedElseExpression)

@{b}   FUNCTION@{ub}
       This is the only procedure that isn't actually part of the
       logic object.  This may change in the future.  All
       parameters (q, a, and b) will be Eval()uated, and must
       therefore be "`" expressions... I chose to do things this
       way in order to save space, and in order to do things more
       easily.  I couldn't find another way to allow users to call
       their object's methods arbitrarily from within this function.

       Basically, 'q' should return either TRUE or FALSE (in the
       classic Amiga E sense).  If a or b has a value other than 0,
       a will be Eval()ed if q Eval()s to TRUE, b if q Eval()s to
       FALSE.  If a is missing, and q indicates TRUE, then TRUE
       will be returned.  If b is missing, and q indicates FALSE,
       then FALSE will be returned.

       So, in essence, this procedure acts as a very sophisticated
       IF THEN ELSE statement, but in a much more easily readable
       format.  This will become particularly useful as you read.

@{b}   INPUTS@{ub}
       quotedExpression,
       quotedThenExpression,
       quotedElseExpression --- see above

@{b}   RESULT@{ub}
       see above

@EndNode

@Node "ifDetermined()" "logic/ifDetermined"

@{b}   NAME @{ub}
       ifDetermined() -- If I am true, then... else...

@{b}   SYNOPSIS@{ub}
       logic.ifDetermined(quotedThenExpression,quotedElseExpression)

@{b}   FUNCTION@{ub}
       If I am determined, quotedThenExpression is evaluated, else
       quotedElseExpression will be evaluated.

@{b}   INPUTS@{ub}
       quotedThenExpression,
       quotedElseExpression -- Quoted expressions

@{b}   RESULT@{ub}
       Depends on the quoted expressions. See @{"if()" Link "if()"} on that.

@{b}   SEE ALSO@{ub}
       @{"if()" Link "if()"}
@EndNode

@Node "ifFalse()" "logic/ifFalse"

@{b}   NAME @{ub}
       ifFalse() -- If I am false, then... else...

@{b}   SYNOPSIS@{ub}
       logic.ifFalse(quotedThenExpression,quotedElseExpression)

@{b}   FUNCTION@{ub}
       If I am false, quotedThenExpression is evaluated, else
       quotedElseExpression will be evaluated.

@{b}   INPUTS@{ub}
       quotedThenExpression,
       quotedElseExpression -- Quoted expressions

@{b}   RESULT@{ub}
       Depends on the quoted expressions. See @{"if()" Link "if()"} on that.

@{b}   SEE ALSO@{ub}
       @{"if()" Link "if()"}
@EndNode

@Node "ifTrue()" "logic/ifTrue"

@{b}   NAME @{ub}
       ifTrue() -- If I am true, then... else...

@{b}   SYNOPSIS@{ub}
       logic.ifTrue(quotedThenExpression,quotedElseExpression)

@{b}   FUNCTION@{ub}
       If I am true, quotedThenExpression is evaluated, else
       quotedElseExpression will be evaluated.

@{b}   INPUTS@{ub}
       quotedThenExpression,
       quotedElseExpression -- Quoted expressions

@{b}   RESULT@{ub}
       Depends on the quoted expressions. See @{"if()" Link "if()"} on that.

@{b}   SEE ALSO@{ub}
       @{"if()" Link "if()"}
@EndNode

@Node "ifUndetermined()" "logic/ifUndetermined"

@{b}   NAME @{ub}
       ifUndetermined() -- If I am true, then... else...

@{b}   SYNOPSIS@{ub}
       logic.ifUndetermined(quotedThenExpression,quotedElseExpression)

@{b}   FUNCTION@{ub}
       If I am undetermined, quotedThenExpression is evaluated, else
       quotedElseExpression will be evaluated.

@{b}   INPUTS@{ub}
       quotedThenExpression,
       quotedElseExpression -- Quoted expressions

@{b}   RESULT@{ub}
       Depends on the quoted expressions. See @{"if()" Link "if()"} on that.

@{b}   SEE ALSO@{ub}
       @{"if()" Link "if()"}
@EndNode

@Node "isDetermined()" "logic/isDetermined"

@{b}   NAME @{ub}
       isDetermined() -- is the statement determined?

@{b}   SYNOPSIS@{ub}
       logic.isDetermined()

@{b}   FUNCTION@{ub}
       Determines if the truth is determined.

@{b}   RESULT@{ub}
       TRUE if truth is determined, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       @{"isFalse()" Link "isFalse()"}, @{"isUndetermined()" Link "isUndetermined()"}, @{"isTrue()" Link "isTrue()"}
@EndNode

@Node "isFalse()" "logic/isFalse"

@{b}   NAME @{ub}
       isFalse() -- is the statement false?

@{b}   SYNOPSIS@{ub}
       logic.isFalse()

@{b}   FUNCTION@{ub}
       Determines if the truth is false.

@{b}   RESULT@{ub}
       TRUE if truth is false, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       @{"isTrue()" Link "isTrue()"}, @{"isUndetermined()" Link "isUndetermined()"}, @{"isDetermined()" Link "isDetermined()"}
@EndNode

@Node "isTrue()" "logic/isTrue"

@{b}   NAME @{ub}
       isTrue() -- is the statement true?

@{b}   SYNOPSIS@{ub}
       logic.isTrue()

@{b}   FUNCTION@{ub}
       Determines if the truth is true.

@{b}   RESULT@{ub}
       TRUE if truth is true, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       @{"isFalse()" Link "isFalse()"}, @{"isUndetermined()" Link "isUndetermined()"}, @{"isDetermined()" Link "isDetermined()"}
@EndNode

@Node "isUndetermined()" "logic/isUndetermined"

@{b}   NAME @{ub}
       @{"isTrue()" Link "isTrue()"} -- is the statement undetermined?

@{b}   SYNOPSIS@{ub}
       logic.isUndetermined()

@{b}   FUNCTION@{ub}
       Determines if the truth is undetermined.

@{b}   RESULT@{ub}
       TRUE if truth is undetermined, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       @{"isFalse()" Link "isFalse()"}, @{"isTrue()" Link "isTrue()"}, @{"isDetermined()" Link "isDetermined()"}
@EndNode

@Node "select()" "logic/select"

@{b}   NAME @{ub}
       select() -- Selection of action on initialization.

@{b}   SYNOPSIS@{ub}
       logic.select()

@{b}   FUNCTION@{ub}
       This method allows one to create a @{"new" Link "resource/new()"} instantiation of the
       Logic object.  'a' is an E list that may have the following:

           "set"  -- Sets the truth value to the following item.
           "true" -- Sets truth to true.
           "fals" -- Sets truth to false.

           The truth attribute always starts off undetermined.

@{b}   INPUTS@{ub}
       opts -- The optionlist

       i -- The @{"index" Link "definitions/index()"} of the optionlist

@{b}   SEE ALSO@{ub}
       object/select()
@EndNode

@Node "write()" "logic/write"

@{b}   NAME @{ub}
       write() -- Write @{"string" Link "reqtools/string()"} with truth of statement.

@{b}   SYNOPSIS@{ub}
       logic.write()

@{b}   FUNCTION@{ub}
       This method will print 'This statement is' followed by
       either True, False, or Undetermined, depending on the value
       of truth.  This method will not exist in the future... it
       will be replaced with something more flexible.. currently,
       it will only write to stdout.

@EndNode

