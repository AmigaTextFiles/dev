@database "string"
@master "Ram Disk:T/docs/string.doc"

@Node Main "string.doc"
    @{" --string--() " Link "--string--()"}
    @{" asInteger() " Link "asInteger()"}
    @{" cat() " Link "cat()"}
    @{" catString() " Link "catString()"}
    @{" cmp() " Link "cmp()"}
    @{" concat() " Link "concat()"}
    @{" concatString() " Link "concatString()"}
    @{" end() " Link "end()"}
    @{" find() " Link "find()"}
    @{" get() " Link "get()"}
    @{" init() " Link "init()"}
    @{" left() " Link "left()"}
    @{" length() " Link "length()"}
    @{" lower() " Link "lower()"}
    @{" middle() " Link "middle()"}
    @{" name() " Link "name()"}
    @{" right() " Link "right()"}
    @{" select() " Link "select()"}
    @{" set() " Link "set()"}
    @{" size() " Link "size()"}
    @{" trimmed() " Link "trimmed()"}
    @{" upper() " Link "upper()"}
    @{" write() " Link "write()"}
@EndNode

@Node "--string--()" "string/--string--"

@{b}   NAME @{ub}
       @{"string" Link "reqtools/string()"} of sort

@{b}   ATTRIBUTES@{ub}
       item -- Pointer to the characters in this @{"string" Link "reqtools/string()"}. Is the first
           element of a @{"string" Link "reqtools/string()"} chain that is modified by such functions
           as @{"cat()" Link "cat()"}. Various functions work with the @{"string" Link "reqtools/string()"} chain, @{"write()" Link "write()"}
           for example reduces the size of it to one entry.

       len:PTR TO integer -- The length of this instance.

@{b}   NOTES@{ub}
@{b}     Through this document there are the following terms used:@{ub}
         'String' -- this is the object we're talking about.
         @{"string" Link "reqtools/string()"} -- a chain of characters ('this is one'). It is terminated
             with a 0-byte. When there is a @{"string" Link "reqtools/string()"} required you may
             also provide an estring.

@{b}   SEE ALSO@{ub}
       @{"sort/--sort--" Link "sort/--sort--()"}
@EndNode

@Node "asInteger()" "string/asInteger"

@{b}   NAME @{ub}
       asInteger() -- Turn 'String' to Integer

@{b}   SYNOPSIS@{ub}
       string.asInteger()

@{b}   FUNCTION@{ub}
       Tries to turn itself to an Integer.

@{b}   RESULT@{ub}
       PTR TO integer -- The integer that was in 'String'.

@{b}   NOTES@{ub}
       Only call when you know that the @{"string" Link "reqtools/string()"} contains an integer. There
       is actually no way to test if the proc ran successful over the
       strings contents.

       Call @{"write()" Link "write()"}.

@EndNode

@Node "cat()" "string/cat"

@{b}   NAME @{ub}
       cat() -- Add normal @{"string" Link "reqtools/string()"}.

@{b}   SYNOPSIS@{ub}
       string.cat(in)

@{b}   FUNCTION@{ub}
       Adds a normal @{"string" Link "reqtools/string()"} to itself. This can be a 0-terminated array of
       char or an estring. The @{"string" Link "reqtools/string()"} is copied and added at the end.

@{b}   INPUTS@{ub}
       in -- @{"string" Link "reqtools/string()"} to add.

@{b}   RESULT@{ub}
       Pointer to the estring @{"copy" Link "logic/copy()"} of the @{"string" Link "reqtools/string()"} to add.

@{b}   EXAMPLE@{ub}
       PROC @{"main()" Link "master/main()"}
       DEF string:PTR TO @{"string" Link "reqtools/string()"}

         NEW string.new()    -> allocate and initialize
         string.set('build no schools, construct no roads ')
         string.cat('mark them as fools, let ignorance rule')

         WriteF('\s\n', string.write())  ->get @{"string" Link "reqtools/string()"} and write it

       ENDPROC


@{b}   SEE ALSO@{ub}
       @{"concat()" Link "concat()"}, @{"catString()" Link "catString()"}, @{"concatString()" Link "concatString()"}
@EndNode

@Node "catString()" "string/catString"

@{b}   NAME @{ub}
       catString() -- Cat a 'String' to another.

@{b}   SYNOPSIS@{ub}
       catString(in:PTR TO string)

@{b}   FUNCTION@{ub}
       Puts a 'String' at the end of itself.

@{b}   INPUTS@{ub}
       in:PTR TO @{"string" Link "reqtools/string()"} -- 'String' to add.

@{b}   RESULT@{ub}
       item of itself.

@{b}   SEE ALSO@{ub}
       @{"concatString()" Link "concatString()"}

@EndNode

@Node "cmp()" "string/cmp"

@{b}   NAME @{ub}
       cmp() -- Compare to another 'String'.

@{b}   SYNOPSIS@{ub}
       string.cmp(item:PTR TO string)

@{b}   FUNCTION@{ub}
       Compares itself to another 'String' via E's builtin OstrCmp().

@{b}   INPUTS@{ub}
       item:PTR TO @{"string" Link "reqtools/string()"} -- The 'String' to compare to.

@{b}   RESULT@{ub}
       'Ordered String Compare' returns 1 if string2>string1, 0 for equal
       and 1 for less.

@{b}   NOTES@{ub}
       cmp() compares two strings quickly.. but it doesn't handle
       international characters. Many improvements could be made to this,
       I'm sure, but it has the virtue of being fairly quick.  Perhaps
       locale.library support would be nice.

@{b}   SEE ALSO@{ub}
       E reference/OstrCmp()
@EndNode

@Node "concat()" "string/concat"

@{b}   NAME @{ub}
       concat() -- Add @{"string" Link "reqtools/string()"} to the internal @{"string" Link "reqtools/string()"} chain.

@{b}   SYNOPSIS@{ub}
       string.concat(in,count=0)

@{b}   FUNCTION@{ub}
       Adds a @{"string" Link "reqtools/string()"} to the internal @{"string" Link "reqtools/string()"} chain. The length is set to the
       @{"new" Link "resource/new()"} length.

@{b}   INPUTS@{ub}
       in -- normal @{"string" Link "reqtools/string()"} to add.

       count -- the length of in. Can be left 0 normally, in that case the
           length is found out by StrLen().

@{b}   NOTES@{ub}
       Mainly for internal use. Mortal beings use @{"catString()" Link "catString()"}.

@{b}   SEE ALSO@{ub}
       @{"cat()" Link "cat()"}, @{"concatString()" Link "concatString()"}, @{"catString()" Link "catString()"}
@EndNode

@Node "concatString()" "string/concatString"

@{b}   NAME @{ub}
       concatString() -- Add 'String' to the internal @{"string" Link "reqtools/string()"} chain.

@{b}   SYNOPSIS@{ub}
       string.concatString(in:PTR TO string)

@{b}   FUNCTION@{ub}
       Adds a 'String' to the internal @{"string" Link "reqtools/string()"} chain. The length is set to the
       @{"new" Link "resource/new()"} length.

@{b}   INPUTS@{ub}
       in -- 'String' to add.

@{b}   RESULT@{ub}
       Pointer to @{"new" Link "resource/new()"} @{"string" Link "reqtools/string()"} or 0 if in was NIL.

@{b}   NOTES@{ub}
       Mainly for internal use. Mortal beings use @{"catString()" Link "catString()"}.

@{b}   SEE ALSO@{ub}
       @{"cat()" Link "cat()"}, @{"concat()" Link "concat()"}, @{"catString()" Link "catString()"}
@EndNode

@Node "end()" "string/end"

@{b}   NAME @{ub}
@{b}     end() -- Global destructor.@{ub}

@{b}   SYNOPSIS@{ub}
@{b}     string.end()@{ub}

@{b}   FUNCTION@{ub}
@{b}     Frees used resources of the instance. It frees the @{"string" Link "reqtools/string()"} and the@{ub}
@{b}     length Integer.@{ub}

@{b}   SEE ALSO@{ub}
@{b}     object/end()@{ub}
@EndNode

@Node "find()" "string/find"

@{b}   NAME @{ub}
       find() -- Test if 'String' is in 'String'.

@{b}   SYNOPSIS@{ub}
       string.find(in:PTR TO string)

@{b}   FUNCTION@{ub}
       Searches a 'String' in itself.

@{b}   INPUTS@{ub}
       in:PTR TO @{"string" Link "reqtools/string()"} -- 'String' to search for

@{b}   RESULT@{ub}
       TRUE if in is in self, FALSE otherwise.

@{b}   NOTES@{ub}
       Calls @{"write()" Link "write()"} on in.

@EndNode

@Node "get()" "string/get"

@{b}   NAME @{ub}
       get() -- Get 'String''s item.

@{b}   SYNOPSIS@{ub}
       string.get()

@{b}   FUNCTION@{ub}
       Gets its item. Only for internal use, if you want to print the 'String
'
       or work with it you have to call @{"write()" Link "write()"}.

@{b}   RESULT@{ub}
       string.item

@{b}   SEE ALSO@{ub}
       @{"write()" Link "write()"}
@EndNode

@Node "init()" "string/init"

@{b}   NAME @{ub}
       init() -- Initialize the object.

@{b}   SYNOPSIS@{ub}
       string.init()

@{b}   FUNCTION@{ub}
       Allocates the Integer object used for len.

@{b}   SEE ALSO@{ub}
       integer/--integer--
@EndNode

@Node "left()" "string/left"

@{b}   NAME @{ub}
       left() -- Get left part of 'String'.

@{b}   SYNOPSIS@{ub}
       string.left(length)

@{b}   FUNCTION@{ub}
       Gets a part from the left side of itself and builds a @{"new" Link "resource/new()"} 'String'
       from it.

@{b}   INPUTS@{ub}
       length -- get how many characters.

@{b}   RESULT@{ub}
       PTR TO @{"string" Link "reqtools/string()"} -- a freshly created 'String' that contains the desired
           @{"string" Link "reqtools/string()"} part.

@{b}   EXAMPLE@{ub}

       PROC @{"main()" Link "master/main()"}
       DEF mainString:PTR TO @{"string" Link "reqtools/string()"},
           partOfString:PTR TO @{"string" Link "reqtools/string()"}

         NEW mainString.new(["set", 'down in Los Angeles'])

         partOfString := mainString.left(4)

         WriteF('\s\n', partOfString.write())

         END partOfString
         END mainString
       ENDPROC

@{b}   SEE ALSO@{ub}
       @{"middle()" Link "middle()"}, @{"right()" Link "right()"}
@EndNode

@Node "length()" "string/length"

@{b}   NAME @{ub}
       length() -- Get length of 'String'.

@{b}   SYNOPSIS@{ub}
       string.length()

@{b}   FUNCTION@{ub}
       Gets the length of itself.

@{b}   RESULT@{ub}
       Length of itself.

@{b}   SEE ALSO@{ub}
       @{"integer/get()" Link "get()"}
@EndNode

@Node "lower()" "string/lower"

@{b}   NAME @{ub}
@{b}     lower() -- Change the case of each character to lower.@{ub}

@{b}   SYNOPSIS@{ub}
@{b}     string.lower()@{ub}

@{b}   FUNCTION@{ub}
@{b}     The case of each character in the 'String' is turned to lower.@{ub}

@{b}   NOTES@{ub}
@{b}     Calls write().@{ub}

@EndNode

@Node "middle()" "string/middle"

@{b}   NAME @{ub}
       middle() -- Get a part of 'String'.

@{b}   SYNOPSIS@{ub}
       string.middle(position,length)

@{b}   FUNCTION@{ub}
       Gets a part from itself and builds a @{"new" Link "resource/new()"} 'String' from it.

@{b}   INPUTS@{ub}
       position -- Start at what position of itself.

       length -- get how many characters from position up to the end.

@{b}   RESULT@{ub}
       PTR TO @{"string" Link "reqtools/string()"} -- a freshly created 'String' that contains the desired
           @{"string" Link "reqtools/string()"} part.

@{b}   EXAMPLE@{ub}

       PROC @{"main()" Link "master/main()"}
       DEF mainString:PTR TO @{"string" Link "reqtools/string()"},
           partOfString:PTR TO @{"string" Link "reqtools/string()"}

         NEW mainString.new(["set", 'down in Los Angeles'])

         partOfString := mainString.middle(5,2)

         WriteF('\s\n', partOfString.write())

         END partOfString
         END mainString
       ENDPROC

@{b}   SEE ALSO@{ub}
       @{"left()" Link "left()"}, @{"right()" Link "right()"}
@EndNode

@Node "name()" "string/name"

@{b}   NAME @{ub}
       name() -- Get name of object.

@{b}   SYNOPSIS@{ub}
       string.name()

@{b}   FUNCTION@{ub}
       Returns the name of the object. In this case 'String'.

@EndNode

@Node "right()" "string/right"

@{b}   NAME @{ub}
       right() -- Get right part of 'String'.

@{b}   SYNOPSIS@{ub}
       string.right(length)

@{b}   FUNCTION@{ub}
       Gets part from the right side of itself and builds a @{"new" Link "resource/new()"} 'String'
       from it.

@{b}   INPUTS@{ub}
       length -- get how many characters.

@{b}   RESULT@{ub}
       PTR TO @{"string" Link "reqtools/string()"} -- a freshly created 'String' that contains the desired
           @{"string" Link "reqtools/string()"} part.

@{b}   EXAMPLE@{ub}

       PROC @{"main()" Link "master/main()"}
       DEF mainString:PTR TO @{"string" Link "reqtools/string()"},
           partOfString:PTR TO @{"string" Link "reqtools/string()"}

         NEW mainString.new(["set", 'down in Los Angeles'])

         partOfString := mainString.right(11)

         WriteF('\s\n', partOfString.write())

         END partOfString
         END mainString
       ENDPROC

@{b}   SEE ALSO@{ub}
       @{"left()" Link "left()"}, @{"middle()" Link "middle()"}
@EndNode

@Node "select()" "string/select"

@{b}   NAME @{ub}
       select() -- Select action on initialization.

@{b}   SYNOPSIS@{ub}
       string.select(optionlist,index)

@{b}   FUNCTION@{ub}
       Recognizes the following items:
         "set" -- calls self.cat() with the following item

         "sset" -- calls self.catString() with the following item

@{b}   INPUTS@{ub}
       optionlist -- The optionlist

       @{"index" Link "definitions/index()"} -- The @{"index" Link "definitions/index()"} of the optionlist

@{b}   SEE ALSO@{ub}
       object/select()
@EndNode

@Node "set()" "string/set"

@{b}   NAME @{ub}
       set() -- Set the 'String''s contents.

@{b}   SYNOPSIS@{ub}
       string.set(in)

@{b}   FUNCTION@{ub}
       Sets the contents of itself. An already present @{"string" Link "reqtools/string()"} will be freed
       first.

@{b}   INPUTS@{ub}
       in -- Pointer to normal 0-terminated @{"string" Link "reqtools/string()"}. Could be an estring
           as well.

@{b}   EXAMPLE@{ub}

       PROC @{"main()" Link "master/main()"}
       DEF string:PTR TO @{"string" Link "reqtools/string()"}

         NEW string.new()    -> allocate and initialize
         string.set('build no schools, construct no roads')
         string.cat('mark them as fools, let ignorance rule')

         WriteF('\s\n', string.write())  ->get @{"string" Link "reqtools/string()"} and write it

       ENDPROC

@{b}   SEE ALSO@{ub}
       @{"cat()" Link "cat()"}
@EndNode

@Node "size()" "string/size"

@{b}   NAME @{ub}
       size() -- Get size of instance.

@{b}   SYNOPSIS@{ub}
       string.size()

@{b}   FUNCTION@{ub}
       Returns the size of the instance.

@EndNode

@Node "trimmed()" "string/trimmed"

@{b}   NAME @{ub}
       trimmed() -- Trim whitespace from 'String'.

@{b}   SYNOPSIS@{ub}
       string.trimmed()

@{b}   FUNCTION@{ub}
       Trims itself, i.e. returns a @{"string" Link "reqtools/string()"} that starts with the first
       non-whitespace character.

@{b}   RESULT@{ub}
       Pointer to 'String' which contains the trimmed contents of self.
       It is a newly created 'String', you have to END() it yourself when
       you don't need it anymore.

@EndNode

@Node "upper()" "string/upper"

@{b}   NAME @{ub}
@{b}     upper() -- Change the case of each character to upper.@{ub}

@{b}   SYNOPSIS@{ub}
@{b}     string.upper()@{ub}

@{b}   FUNCTION@{ub}
@{b}     The case of each character in the 'String' is turned to upper.@{ub}

@{b}   NOTES@{ub}
@{b}     Calls write().@{ub}

@EndNode

@Node "write()" "string/write"

@{b}   NAME @{ub}
@{b}     write() -- Turn 'String' into printable string.@{ub}

@{b}   SYNOPSIS@{ub}
@{b}     string.write()@{ub}

@{b}   FUNCTION@{ub}
@{b}     If you want to turn 'String' into a normal @{"string" Link "reqtools/string()"} (or estring) so@{ub}
@{b}     you can work with it as if it was a normal series of characters you@{ub}
@{b}     should call this function. It returns a pointer to an estring that@{ub}
@{b}     contains 'String''s contents.@{ub}

@{b}   RESULT@{ub}
@{b}     Pointer to estring containing@{ub}

@{b}   NOTES@{ub}
@{b}     Works on the internal @{"string" Link "reqtools/string()"} chain and builds one continuous string@{ub}
@{b}     from it. The @{"string" Link "reqtools/string()"} chain contains only one entry after the call@{ub}
@{b}     of this proc.@{ub}

@{b}   EXAMPLE@{ub}
       PROC @{"main()" Link "master/main()"}
       DEF string:PTR TO @{"string" Link "reqtools/string()"}

         NEW string.new()    -> allocate and initialize
         string.set('build no schools, construct no roads')
         string.cat('mark them as fools, let ignorance rule')

         WriteF('\s\n', string.write())  ->get @{"string" Link "reqtools/string()"} and write it

       ENDPROC

@EndNode

