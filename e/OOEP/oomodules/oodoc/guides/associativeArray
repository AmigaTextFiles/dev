@database "associativeArray"
@master "Ram Disk:T/docs/associativeArray.doc"

@Node Main "associativeArray.doc"
    @{" binarySearch() " Link "binarySearch()"}
    @{" makeRoom() " Link "makeRoom()"}
    @{" disposeKey() " Link "disposeKey()"}
    @{" disposeVal() " Link "disposeVal()"}
    @{" end() " Link "end()"}
    @{" get() " Link "get()"}
    @{" init() " Link "init()"}
    @{" remove() " Link "remove()"}
    @{" set() " Link "set()"}
    @{" testKey() " Link "testKey()"}
    @{" associativeArray() " Link "associativeArray()"}
@EndNode

@Node "binarySearch()" "/binarySearch"

@{b}   NAME@{ub}
       binarySearch() --

@{b}   SYNOPSIS@{ub}
       binarySearch(PTR TO @{"associativeArray" Link "associativeArray/associativeArray()"}, LONG, LONG, LONG, LONG)

       binarySearch(ar, l, u, key, pivot)

@{b}   FUNCTION@{ub}
       Recursive binary search of array ar.key.  Returns pos when
       ar.key[pos] equals key, or when l=u.

@{b}   INPUTS@{ub}
       ar:PTR TO @{"associativeArray" Link "associativeArray/associativeArray()"} -- array to work on

       l:LONG -- 

       u:LONG -- 

       key:LONG -- 

       pivot:LONG -- 

@{b}   RESULT@{ub}
       LONG -- @{"index" Link "definitions/index()"}

@{b}   EXCEPTION@{ub}
       Throws ASAR_EXCEPTION, ASAR_STACKOVERFLOW

@EndNode

@Node "makeRoom()" "/makeRoom"

@{b}   NAME@{ub}
       makeRoom() -- Make room for an element.

@{b}   SYNOPSIS@{ub}
       makeRoom(PTR TO @{"associativeArray" Link "associativeArray/associativeArray()"}, LONG)

       makeRoom(ar, pos)

@{b}   FUNCTION@{ub}
       Make a blank element at position pos (for an insert operation).
       Expand the length of the array by 32 elements if necessary.

@{b}   INPUTS@{ub}
       ar:PTR TO @{"associativeArray" Link "associativeArray/associativeArray()"} -- array to work on

       pos:LONG -- position to insert an element

@EndNode

@Node "disposeKey()" "associativeArray/disposeKey"

@{b}   NAME@{ub}
       disposeKey() of @{"associativeArray" Link "associativeArray/associativeArray()"} -- Call destructor of key.

@{b}   SYNOPSIS@{ub}
       associativeArray.disposeKey(LONG)

       associativeArray.disposeKey(key)

@{b}   FUNCTION@{ub}
       Empty method. Special action to take when calling the destructor for
       an array whose keys are dynamically allocated.  Default for type LONG
       is NO ACTION.

@{b}   INPUTS@{ub}
       key:LONG -- Pointer to key.

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}, @{"disposeVal()" Link "disposeVal()"}

@EndNode

@Node "disposeVal()" "associativeArray/disposeVal"

@{b}   NAME@{ub}
       disposeVal() of @{"associativeArray" Link "associativeArray/associativeArray()"} -- Call destructor of value.

@{b}   SYNOPSIS@{ub}
       associativeArray.disposeVal(LONG)

       associativeArray.disposeVal(val)

@{b}   FUNCTION@{ub}
       Empty method. Special action to take when calling the destructor,
       or overwriting a value for a key that already exists, for an array
       whose keys are dynamically allocated.  Default for type LONG is
       NO ACTION.

@{b}   INPUTS@{ub}
       val:LONG -- Pointer to value.

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}, @{"disposeKey()" Link "disposeKey()"}

@EndNode

@Node "end()" "associativeArray/end"

@{b}   NAME@{ub}
       end() of @{"associativeArray" Link "associativeArray/associativeArray()"} -- Global destructor.

@{b}   SYNOPSIS@{ub}
       associativeArray.end()

@{b}   FUNCTION@{ub}
       Cleans up keys and values using methods @{"disposeKey()" Link "disposeKey()"} and @{"disposeVal()" Link "disposeVal()"},
       so if your keys and values are dynamically allocated, you must
       override these if you want this method to free them.  NOTE: this
       method was written to be very safe!  It may be called directly at any
       time (even multiple times) to free resources.  'myobj.end()' doesn't
       free the object, only its contents.  Just don't be so silly as to
       call -any- methods after an 'END myobj'. :)

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "get()" "associativeArray/get"

@{b}   NAME@{ub}
       get() of @{"associativeArray" Link "associativeArray/associativeArray()"} --

@{b}   SYNOPSIS@{ub}
       associativeArray.get(LONG)

       associativeArray.get(searchKey)

@{b}   FUNCTION@{ub}
       Perform binary search for matching key and return its associated
       value.

@{b}   INPUTS@{ub}
       searchKey:LONG -- the associated key used to identify a value

@{b}   RESULT@{ub}
       val:LONG -- value associated with key

       pos:LONG -- the position of the element in the array.

@{b}   EXCEPTIONS@{ub}
       Throws ASAR_EXCEPTION, ASAR_KEYNOTFOUND or
       ASAR_EXCEPTION, ASAR_STACKOVERFLOW

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "init()" "associativeArray/init"

@{b}   NAME@{ub}
       init() of @{"associativeArray" Link "associativeArray/associativeArray()"} -- Initialization of the object.

@{b}   SYNOPSIS@{ub}
       associativeArray.init()

@{b}   FUNCTION@{ub}
       Initializes the object. The list will initially contain
       DEFAULT_LENGTH elements.

@{b}   EXCEPTION@{ub}
       May raise "MEM".

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "remove()" "associativeArray/remove"

@{b}   NAME@{ub}
       remove() of @{"associativeArray" Link "associativeArray/associativeArray()"} --

@{b}   SYNOPSIS@{ub}
       associativeArray.remove(LONG)

       associativeArray.remove(searchKey)

@{b}   FUNCTION@{ub}
       Remove the key and value from the array and return them.

@{b}   INPUTS@{ub}
       searchKey:LONG -- the key of the element to be removed

@{b}   RESULT@{ub}
       key:LONG -- the key you passed

       val:LONG -- value associated with key

@{b}   EXCEPTIONS@{ub}
       Throws ASAR_EXCEPTION, ASAR_KEYNOTFOUND or
       ASAR_EXCEPTION, ASAR_STACKOVERFLOW

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "set()" "associativeArray/set"

@{b}   NAME@{ub}
       set() of @{"associativeArray" Link "associativeArray/associativeArray()"} --

@{b}   SYNOPSIS@{ub}
       associativeArray.set(LONG, LONG)

       associativeArray.get(key, val)

@{b}   FUNCTION@{ub}
       Overwrites the value associated with key if it already exists, else
       inserts it ordered on key.  Once you set() an element, you
       effectively give it to the array object to hold until you @{"remove()" Link "remove()"} it
       or @{"end()" Link "end()"} the object.  When in doubt about what is legal, read this
       simple module's source!

       WARNING, key:  calling this method essentially makes the elements of
       array.key READ-ONLY.  DO NOT change them (peeking allowed, but no
       poking:), else risk corrupting the order and breaking binary search.

       WARNING, val:  It IS safe to change (okay to poke:) the elements of
       array.val, eg, change the numeric value or swap out a @{"string" Link "reqtools/string()"}, etc,
       just BE SMART ABOUT IT.  If val is dynamically allocated, it is the
       programmer's responsibility to free the swapped-out val.

@{b}   INPUTS@{ub}
       key:LONG -- the key used to @{"index" Link "definitions/index()"} val

       val:LONG -- the value associated with key

@{b}   EXCEPTIONS@{ub}
       May raise "MEM" or throw ASAR_EXCEPTION, ASAR_STACKOVERFLOW.

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "testKey()" "associativeArray/testKey"

@{b}   NAME@{ub}
       testKey() of @{"associativeArray" Link "associativeArray/associativeArray()"} --

@{b}   SYNOPSIS@{ub}
       associativeArray.testKey(LONG, LONG)

       associativeArray.testKey(left, right)

@{b}   FUNCTION@{ub}
       Ordered comparison of two keys.  Default behavior is for comparison
       of type LONG.  Override this method to change the behavior.

@{b}   INPUTS@{ub}
       left:LONG -- the left operand of an infix expression (left = right)
       right:LONG -- the right operand of an infix expression (left = right)

@{b}   RESULT@{ub}
      -1 if left is less than right
       0 if left equals right
       1 if left is greater than right

@{b}   EXAMPLE@{ub}
      /*
       * simple adaption for strings
       */

       PROC testKey(left, right) OF myAsAr IS OstrCmp(left, right)

@{b}   SEE ALSO@{ub}
       @{"associativeArray" Link "associativeArray/associativeArray()"}

@EndNode

@Node "associativeArray()" "object/associativeArray"

@{b}   NAME@{ub}
       associativeArray of object -- Dynamic, one-dimensional, ordered
           array

@{b}   PURPOSE@{ub}
       Dynamic, one-dimensional, ordered array for storing things whose
       indices fit any of these criteria:  1) are non-numeric (most
       popular @{"index" Link "definitions/index()"} type is a string), 2) are not consecutive and/or
       have big gaps between values (commonly known as sparse arrays),
       3) order cannot be simply determined by builtin E arithmetic
       operators (=<>).  Basically any @{"index" Link "definitions/index()"} type that is not the typical
       positive integer from 0 to MAXLONG.

@{b}   ATTRIBUTES@{ub}
       len:LONG -- current max length of the array

       tail:LONG -- first empty place after the last element

       key:PTR TO LONG -- array stores the keys in ordered sequence

       val:PTR TO LONG -- array stores the values associated with each key
           in array key

@{b}   EXCEPTIONS@{ub}
       ASAR_EXCEPTION identifies this module as the origin of the exception.
       The remaining constants identify the reason for an exception raised
       by this module. These are:

           ASAR_KEYNOTFOUND -- there is no such key in the array

           ASAR_STACKOVERFLOW -- stack overflow. Should not be raised if the
               stack watch is enabled.

@{b}   NOTES@{ub}
       disposeKey(key)
       disposeVal(val)

       These are the default actions for disposal of keys and vals of type
       LONG, which is "do nothing", since they require no special cleanup.
       Override them if key and/or val requires cleanup, (ie, dynamically
       allocated, else your storage WILL NOT be freed when you @{"set()" Link "set()"} or @{"end()" Link "end()"}
!!!)

       EXAMPLE:

       PROC disposeVal(val) OF myAsAr IS DisposeLink(val)

       Storage for @{"new" Link "resource/new()"} elements is automatically allocated, increased by 32
       each time the array's limits are exceeded.

       No duplicate keys will ever exist, values are simply overwritten.

       Inserting and removing from the front of the array is SLOW with large
       arrays.  This can't be helped, however it's often worth the sacrifice
       for the efficient lookup of binary searches and the handiness of
       sparse, non-numeric indexed arrays.

       The binary search function uses recursion and has a FreeStack() check.
       4096 should be plenty for most applications since the algorithm is
       amazingly efficient.

       Changing any of the PUBLIC (READ-ONLY) values in the object isn't
       recommended, but hey, who's to stop ya besides the guru? :)

@{b}   SEE ALSO@{ub}
       object

@EndNode

