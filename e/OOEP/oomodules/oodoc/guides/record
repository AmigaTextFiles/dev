@database "record"
@master "Ram Disk:T/docs/record.doc"

@Node Main "record.doc"
    @{" record() " Link "record()"}
    @{" addField() " Link "addField()"}
    @{" getByteSize() " Link "getByteSize()"}
    @{" getField() " Link "getField()"}
    @{" getSizeOnDisk() " Link "getSizeOnDisk()"}
    @{" init() " Link "init()"}
    @{" readFieldDefinitions() " Link "readFieldDefinitions()"}
    @{" readFromFile() " Link "readFromFile()"}
    @{" select() " Link "select()"}
    @{" writeToFile() " Link "writeToFile()"}
@EndNode

@Node "record()" "object/record"

@{b}   NAME@{ub}
       record of object

@{b}   PURPOSE@{ub}

@{b}   ATTRIBUTES@{ub}

       identifier:PTR TO @{"string" Link "reqtools/string()"} -- name of the record as found in the object
           header

       fieldArray:PTR TO @{"associativeArray" Link "associativeArray/associativeArray()"} -- fields this record consists of.

       numberOfFields:LONG -- how many fields the record consists of.

       fieldCount:LONG -- which @{"field" Link "field/field()"} we are at. This attribute is used by
           the methods to @{"index" Link "definitions/index()"} the @{"fieldArray" Link "fieldArray/fieldArray()"}. Don't play around with it.

       dataFile:PTR TO dataFile -- the file this record is built from.

       byteSize:LONG -- size of the record.

       sizeOnDisk:LONG -- size of the record on disk. Sum the length of each
           @{"field" Link "field/field()"} and you have it.

@{b}   SEE ALSO@{ub}
       object

@EndNode

@Node "addField()" "record/addField"

@{b}   NAME@{ub}
       addField() of @{"record" Link "record/record()"} -- Add a @{"field" Link "field/field()"} to the @{"record" Link "record/record()"}.

@{b}   SYNOPSIS@{ub}
       record.addField(PTR TO field)

       record.addField(field)

@{b}   FUNCTION@{ub}
       Adds a @{"field" Link "field/field()"} object to the @{"record" Link "record/record()"}. When building a @{"record" Link "record/record()"} you should
       add the fields one after another to the @{"record" Link "record/record()"}. Don't call any other
       method that works on the fieldCount attribute - this method relies
       on it. The current value in fieldCount is taken as the place to put
       the next @{"field" Link "field/field()"} in the @{"fieldArray" Link "fieldArray/fieldArray()"}.

       When you want to expand the @{"record" Link "record/record()"} after you've already worked with
       it you have to get the length of the @{"fieldArray" Link "fieldArray/fieldArray()"} and set the fieldCount
       to it.

@{b}   INPUTS@{ub}
       field:PTR TO @{"field" Link "field/field()"} -- Field object to add to the @{"record" Link "record/record()"}.

@{b}   NOTES@{ub}
       The associative array @{"fieldArray" Link "fieldArray/fieldArray()"} points to and the @{"field" Link "field/field()"} object have
       to be valid.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "getByteSize()" "record/getByteSize"

@{b}   NAME@{ub}
       getByteSize() of @{"record" Link "record/record()"} -- Get byte size of the object.

@{b}   SYNOPSIS@{ub}
       record.getByteSize()

@{b}   FUNCTION@{ub}
       Returns the byte size as found in the byteSize attribute.

@{b}   RESULT@{ub}
       LONG -- size of object in bytes.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "getField()" "record/getField"

@{b}   NAME@{ub}
       getField() of @{"record" Link "record/record()"} -- Get pointer to @{"field" Link "field/field()"} object.

@{b}   SYNOPSIS@{ub}
       record.getField(LONG)

       record.getField(number)

@{b}   FUNCTION@{ub}
       Gets you a certain @{"field" Link "field/field()"} object. The @{"field" Link "field/field()"} remains in the @{"record" Link "record/record()"}.
       You may change the @{"field" Link "field/field()"}.

@{b}   INPUTS@{ub}
       number:LONG -- Which @{"field" Link "field/field()"} to get. 0 is the first @{"field" Link "field/field()"}.

@{b}   RESULT@{ub}
       PTR TO @{"field" Link "field/field()"} -- @{"field" Link "field/field()"} object. NIL if a number higher than the number
           of fields in the @{"record" Link "record/record()"} is passed.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "getSizeOnDisk()" "record/getSizeOnDisk"

@{b}   NAME@{ub}
       getSizeOnDisk() of @{"record" Link "record/record()"} -- Get byte size of the object on disk.

@{b}   SYNOPSIS@{ub}
       record.getSizeOnDisk()

@{b}   FUNCTION@{ub}
       Returns the byte size as found in the sizeOnDisk attribute.

@{b}   RESULT@{ub}
       LONG -- how many bytes a @{"record" Link "record/record()"} of data needs in the file.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "init()" "record/init"

@{b}   NAME@{ub}
       init() of @{"record" Link "record/record()"} -- Initialization of the object.

@{b}   SYNOPSIS@{ub}
       record.init()

@{b}   FUNCTION@{ub}
       News the identifier and fieldArry objects.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "readFieldDefinitions()" "record/readFieldDefinitions"

@{b}   NAME@{ub}
       readFieldDefinitions() of @{"record" Link "record/record()"} -- Read filed definitions from
           @{"record" Link "record/record()"} header and build @{"record" Link "record/record()"}.

@{b}   SYNOPSIS@{ub}
       record.readFieldDefinitions()

@{b}   FUNCTION@{ub}
       Read the @{"field" Link "field/field()"} definitions from the @{"record" Link "record/record()"} and builds the @{"record" Link "record/record()"}.
       The @{"field" Link "field/field()"} objects are added and the size attributes are set.

@{b}   NOTES@{ub}
       Since this method actually does more than it's name suggests it may
       be split. Future versions may only read the definitions and return
       something that may be passed to a metho called buildRecord() or
       the like.

       Before calling this method the numberOfFields attribute has to be
       set to the value found in the file.

       Does use fixed values.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}

@EndNode

@Node "readFromFile()" "record/readFromFile"

@{b}   NAME@{ub}
       readFromFile() of @{"record" Link "record/record()"} --

@{b}   SYNOPSIS@{ub}
       record.readFromFile(PTR TO dataFile)

       record.readFromFile(datafile)

@{b}   FUNCTION@{ub}
       Reads a @{"record" Link "record/record()"} from a @{"datafile" Link "definitions/datafile()"}. The @{"field" Link "field/field()"} contents will be set to
       the values found on disk.

       The data is read in by a call to the readFromFile() method of each
       @{"field" Link "field/field()"} object, see there for more details.

@{b}   INPUTS@{ub}
       datafile:PTR TO dataFile -- file to read from.

@{b}   RESULT@{ub}
       LONG -- "nof" if the numberOfField attribute is out of range, NIL
           otherwise.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"} HANDLE

@EndNode

@Node "select()" "record/select"

@{b}   NAME@{ub}
       select() of @{"record" Link "record/record()"} -- Selection of action.

@{b}   SYNOPSIS@{ub}
       record.select(LONG, LONG)

       record.select(optionlist, index)

@{b}   FUNCTION@{ub}
       The following tags are recognized:
           "dfil" -- next item will be moved to the @{"datafile" Link "definitions/datafile()"} attribute.

@{b}   INPUTS@{ub}
       optionlist:LONG -- List of options

       index:LONG -- Index of option list

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}, @{"object/new" Link "resource/new()"}

@EndNode

@Node "writeToFile()" "record/writeToFile"

@{b}   NAME@{ub}
       writeToFile() of @{"record" Link "record/record()"} --

@{b}   SYNOPSIS@{ub}
       record.writeToFile(PTR TO dataFile)

       record.writeToFile(datafile)

@{b}   FUNCTION@{ub}
       Writes the fields contents to the @{"datafile" Link "definitions/datafile()"}.

       The data is written by a call to the writetoFile() method of each
       @{"field" Link "field/field()"} object, see there for more details.

@{b}   INPUTS@{ub}
       datafile:PTR TO dataFile -- file to write to.

@{b}   RESULTS@{ub}
       LONG -- "nof" if the numberOfFields attribute is out of range, NIL
           otherwise.

@{b}   SEE ALSO@{ub}
       @{"record" Link "record/record()"}, field/writeToFile

@EndNode

