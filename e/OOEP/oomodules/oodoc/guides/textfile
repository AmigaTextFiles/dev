@database "textfile"
@master "Ram Disk:T/docs/textfile.doc"

@Node Main "textfile.doc"
    @{" --background-- " Link "--background--"}
    @{" --textfile--() " Link "--textfile--()"}
    @{" atBeginning() " Link "atBeginning()"}
    @{" atEnd() " Link "atEnd()"}
    @{" buildLineList() " Link "buildLineList()"}
    @{" countLines() " Link "countLines()"}
    @{" findLine() " Link "findLine()"}
    @{" findLineFromBack() " Link "findLineFromBack()"}
    @{" flashbackLine() " Link "flashbackLine()"}
    @{" getCurrentLineNumber() " Link "getCurrentLineNumber()"}
    @{" getLine() " Link "getLine()"}
    @{" getNextLine() " Link "getNextLine()"}
    @{" getPreviousLine() " Link "getPreviousLine()"}
    @{" previewLine() " Link "previewLine()"}
    @{" select() " Link "select()"}
    @{" setCurrentLineNumber() " Link "setCurrentLineNumber()"}
    @{" setLine() " Link "setLine()"}
    @{" suck() " Link "suck()"}
    @{" writeTo() " Link "writeTo()"}
@EndNode

@Node "--background--" "textfile/--background--"

@{b}   PURPOSE@{ub}
       This is the first draft of a basic textfile module. This object
       provides the means to deal with text files. Everything is based
       on lines.

       The methods may change when the file object was adapted for
       Stream.

@{b}   CREATION@{ub}
       September 23 1995 Gregor Goldbach

@{b}   HISTORY@{ub}
       September 23 1995 Gregor Goldbach
         Took procs from tools/file and squeezed them into countlines()
         and @{"buildLineList()" Link "buildLineList()"}.

       September 25 1995 Gregor Goldbach
         Created all other procs.

       October 1 1995 Gregor Goldbach

@{b}   TODO@{ub}
       Change implementation of @{"getLine()" Link "getLine()"} and relying procs. The way they
       exist now is very memory consuming, maybe one short suck()ing and a
       @{"buildLineList()" Link "buildLineList()"} would be better. The line list could be
       recalculated to contain offsets from the beginning of the file, so
       every @{"getLine()" Link "getLine()"} could get that offset and read from the file...
       That could require a locking protocol so nobody can edit the file
       while we are working it (unset w protection flag).

       Add methods to process lines. These methods could also be methods of
       some String sub-object. They should work word-based:
       getNextWordAfter(a,b,c)
       Could search the next word the is after the character a and which
       has to be surrounded by b and c. getNextWordAfter(",","\a","\a")
       would find "this, 'mater'" would return mater.
@EndNode

@Node "--textfile--()" "textfile/--textfile--"

@{b}   NAME@{ub}
       textfile of file

@{b}   FUNCTION@{ub}
       The basic textfile object.

@{b}   ATTRIBUTES@{ub}
       numberOfLines:LONG -- The number of lines that are in this file. Set
           by @{"countLines()" Link "countLines()"}

       lineList:PTR TO LONG -- An @{"elist" Link "elist/elist()"} with pointers to the lines as
           items. Set by @{"buildLineList()" Link "buildLineList()"}

       lineCount:LONG
           The number of the current line, 0 means we are in the very
           first line whereas numberOfLines-1 is the last line.

@{b}   NOTES@{ub}
       By now the attributes are public. This will change, so don't use
       them.

       If you get a @{"string" Link "reqtools/string()"} address (getLine() and the like), do NOT
       Dispose() it! This is done when ENDing the object. This may change
       in the future.

@EndNode

@Node "atBeginning()" "textfile/atBeginning"

@{b}   NAME@{ub}
       atBeginning() -- test if at the beginning of a textfile.

@{b}   SYNOPSIS@{ub}
       textfile.atBeginning()

@{b}   FUNCTION@{ub}
       Tests if the current line is the first one in the file.

@{b}   RESULT@{ub}
       TRUE if in the first line of the file, FALSE otherwise.

@EndNode

@Node "atEnd()" "textfile/atEnd"

@{b}   NAME@{ub}
       atEnd() -- Tes tif at the end of the file.

@{b}   SYNOPSIS@{ub}
       textfile.atEnd()

@{b}   FUNCTION@{ub}
       Tests if the current line is the last one in the file.

@{b}   RESULT@{ub}
       TRUE if at the end of the file, FALSE otherwise.

@EndNode

@Node "buildLineList()" "textfile/buildLineList"

@{b}   NAME@{ub}
      buildLineList() -- Build list of lines.

@{b}   SYNOPSIS@{ub}
       textfile.buildLineList()

@{b}   FUNCTION@{ub}
       Builds an @{"elist" Link "elist/elist()"} with pointers to the lines as items. The hunk of
       memory where the original textfile image lies is modified, every
       cr is sustituted by a 0byte so fiddling around with the line
       is save.

@{b}   RESULT@{ub}
       @{"elist" Link "elist/elist()"} -- List of line pointers.

@{b}   NOTES@{ub}
       Not callable outside the module.

@EndNode

@Node "countLines()" "textfile/countLines"

@{b}   NAME@{ub}
       countLines() -- Count number of lines in the file

@{b}   SYNOPSIS@{ub}
       textfile.countLines()

@{b}   FUNCTION@{ub}
       Counts the lines of the suck()ed text file.

@{b}   RESULT@{ub}
       LONG -- number of lines, at least 1.

@{b}   NOTES@{ub}
       This proc is taken from src/tools/file.e of the original E
       distribution.

       This proc is only callable within the textfile module since it's
       no use anywhere else for the number is stored in the textfile
       object.

@{b}   SEE ALSO@{ub}
       @{"suck()" Link "suck()"}.
@EndNode

@Node "findLine()" "textfile/findLine"

@{b}   NAME@{ub}
       findLine() -- Find a line that begins with @{"string" Link "reqtools/string()"}.

@{b}   SYNOPSIS@{ub}
       textfile.findLine(str,fromLine=0)

@{b}   FUNCTION@{ub}
       Searches for a line that starts with the @{"string" Link "reqtools/string()"} provided in str.

@{b}   INPUTS@{ub}
       str:PTR TO CHAR -- @{"string" Link "reqtools/string()"} to search for.

       fromLine=0 -- number of line to start with hte search.

@{b}   RESULT@{ub}
       LONG -- Number of the line the @{"string" Link "reqtools/string()"} was found in or -1 if not
           found.

@EndNode

@Node "findLineFromBack()" "textfile/findLineFromBack"

@{b}   NAME@{ub}
       findLineFromBack()

@{b}   SYNOPSIS@{ub}
       textfile.findLineFromBack(str,fromLine=0)

@{b}   FUNCTION@{ub}
       Searches for a line that ends with the @{"string" Link "reqtools/string()"} provided in str.

@{b}   INPUTS@{ub}
       str:PTR TO CHAR -- @{"string" Link "reqtools/string()"} to search for.

       fromLine=0 -- number of line to start with hte search.

@{b}   RESULT@{ub}
       LONG -- Number of the line the @{"string" Link "reqtools/string()"} was found in or -1 if not
           found.
@EndNode

@Node "flashbackLine()" "textfile/flashbackLine"

@{b}   NAME@{ub}
       flashbackLine() -- Look number of lines back.

@{b}   SYNOPSIS@{ub}
       textfile.flashbackLine(number=0)

@{b}   FUNCTION@{ub}
       Get the line that is a couple of lines in front of the current
       one. Unlike with @{"getPreviousLine()" Link "getPreviousLine()"}, the current line number is not
       changed. Use only on previously suck()ed textfile's.

@{b}   INPUTS@{ub}
       number=0 -- The number of lines you want to look back. 0 gives you
           current line. If the resulting line would be somewhere 'before'
           the actual file start you get the first line.

@{b}   RESULT@{ub}
       PTR TO CAHR -- Pointer to a line.

@EndNode

@Node "getCurrentLineNumber()" "textfile/getCurrentLineNumber"

@{b}   NAME@{ub}
       getCurrentLineNumber() -- get number of current line

@{b}   SYNOPSIS@{ub}
       textfile.getCurrentLineNumber()

@{b}   FUNCTION@{ub}
       Returns the number of the current line. Useful if you want to set it
       for some function and have to set it back later.

@{b}   RESULT@{ub}
       LONG -- The number of the current line.

@EndNode

@Node "getLine()" "textfile/getLine"

@{b}   NAME@{ub}
       getLine() -- Get a line from a textfile.

@{b}   SYNOPSIS@{ub}
       textfile.getLine(lineNumber=0)

@{b}   FUNCTION@{ub}
       Gets a line from the textfile's buffer. You have to do a @{"suck()" Link "suck()"}
       on the file before using this function or unpredictable results
       may happen.

@{b}   INPUTS@{ub}
       lineNumber=0 -- The number of the line you want to get. If too
       high you get the last line of the file.

@{b}   RESULT@{ub}
       PTR TO CHAR -- Pointer to the line.

@{b}   SEE ALSO@{ub}
       @{"suck()" Link "suck()"}

@EndNode

@Node "getNextLine()" "textfile/getNextLine"

@{b}   NAME@{ub}
       getNextLine() -- Get next line from a textfile.

@{b}   SYNOPSIS@{ub}
       textfile.getNextLine()

@{b}   FUNCTION@{ub}
       Gets the next line of a already suck()ed textfile. If already at
       end the last line is returned.

@{b}   RESULT@{ub}
       PTR TO CHAR -- Pointer to next line.

@EndNode

@Node "getPreviousLine()" "textfile/getPreviousLine"

@{b}   NAME@{ub}
       getPreviousLine() -- Get the previous line of a textfile.

@{b}   SYNOPSIS@{ub}
       textfile.getPreviousLine()

@{b}   FUNCTION@{ub}
       Gets the previous line from a textfile. If already at the beginning
       of the text file you'll get the first line.

@{b}   RESULT@{ub}
       PTR TO CHAR -- Pointer to the line.

@EndNode

@Node "previewLine()" "textfile/previewLine"

@{b}   NAME@{ub}
       previewLine() -- Look some lines in the future.

@{b}   SYNOPSIS@{ub}
       textfile.previewLine(number=0)

@{b}   FUNCTION@{ub}
       Get pointer to a line that is (temporarily) behind the current
       line. Unlike with @{"getNextLine()" Link "getNextLine()"} the number of the current line
       is not changed. Use only on previously suck()ed textfile's.

@{b}   INPUTS@{ub}
       number=0 -- How many lines you want to look forth.

@{b}   RESULT@{ub}
       PTR TO CHAR -- Pointer to the line.

@EndNode

@Node "select()" "textfile/select"

@{b}   NAME@{ub}
       select() -- action on textfile via taglist

@{b}   SYNOPSIS@{ub}
       textfile.select(opts,i)

@{b}   FUNCTION@{ub}
       Performs an action that is defined via in item i of the
       optionlist. See Object's @{"new()" Link "resource/new()"} doc for more info.

       The following actions are defined:
         "open" -- Take next item as file name. Open that file.

         "suck" -- Take next item as file name. Perform a
          @{"suck()" Link "suck()"} on it.

@{b}   INPUTS@{ub}
       opts -- @{"elist" Link "elist/elist()"} with tags

       i -- @{"index" Link "definitions/index()"} of optionlist

@EndNode

@Node "setCurrentLineNumber()" "textfile/setCurrentLineNumber"

@{b}   NAME@{ub}
       setCurrentLineNumber() -- Set the current line number

@{b}   SYNOPSIS@{ub}
       textfile.setCurrentLineNumber(number)

@{b}   FUNCTION@{ub}
       Set the current line number which @{"getNextLine()" Link "getNextLine()"} ant the like react
       on.

@{b}   INPUTS@{ub}
       number -- New current line number. Not tested if valid.

@{b}   SEE ALSO@{ub}
       @{"getNextLine()" Link "getNextLine()"}, setNextLine(), @{"getCurrentLineNumber()" Link "getCurrentLineNumber()"}
@EndNode

@Node "setLine()" "textfile/setLine"

@{b}   NAME@{ub}
       setLine() -- Set the contents of a line.

@{b}   SYNOPSIS@{ub}
       textfile.setLine(lineNumber,str:PTR TO CHAR)

@{b}   FUNCTION@{ub}
       Set the contents of a textfile line. The contents of the @{"string" Link "reqtools/string()"}
       are not tested in any way. Be sure not to exceed the file's maximum
       line number. Be also sure to make a @{"suck()" Link "suck()"} on the file first.

@{b}   INPUTS@{ub}
       lineNumber -- The number of the line to change.

       str:PTR TO CHAR -- Pointer to the @{"new" Link "resource/new()"} line.

@{b}   NOTES@{ub}
       In the future there may be a version that doesn't require a @{"suck()" Link "suck()"}.

@EndNode

@Node "suck()" "textfile/suck"

@{b}   NAME@{ub}
       suck() -- Read textfile into memory.

@{b}   SYNOPSIS@{ub}
       textfile.suck(name=NIL)

@{b}   FUNCTION@{ub}
       Adapted suck() of file. A text file is read into memory.
       Various methods, like @{"getNextLine()" Link "getNextLine()"}, need this method to be
       called before.

       In addition to the simple reading of the file also the lines
       are counted and the line list is built.

@{b}   INPUTS@{ub}
       name=NIL:PTR TO CHAR -- file name to suck. Passed on to file.suck(),
       see there for more information.

@{b}   SEE ALSO@{ub}
       suck()
@EndNode

@Node "writeTo()" "textfile/writeTo"

@{b}   NAME@{ub}
       writeTo() -- Write the text to a file.

@{b}   SYNOPSIS@{ub}
       textfile.writeTo(filename:PTR TO CHAR)

@{b}   FUNCTION@{ub}
       Write the contents of the file to a file. The lines are
       actually appended.

@{b}   INPUTS@{ub}
       filename:PTR TO CHAR -- name of the file to write to.

@EndNode

