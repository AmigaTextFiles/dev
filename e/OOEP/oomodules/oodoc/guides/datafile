@database "datafile"
@master "Ram Disk:T/docs/datafile.doc"

@Node Main "datafile.doc"
    @{" appendRecord() " Link "appendRecord()"}
    @{" end() " Link "end()"}
    @{" getCurrentPosition() " Link "getCurrentPosition()"}
    @{" getRecordNumberByPosition() " Link "getRecordNumberByPosition()"}
    @{" getStartOfData() " Link "getStartOfData()"}
    @{" goToEOF() " Link "goToEOF()"}
    @{" goToFirstRecord() " Link "goToFirstRecord()"}
    @{" goToLastRecord() " Link "goToLastRecord()"}
    @{" goToRecord() " Link "goToRecord()"}
    @{" init() " Link "init()"}
    @{" read() " Link "read()"}
    @{" readCurrentRecord() " Link "readCurrentRecord()"}
    @{" readNextRecord() " Link "readNextRecord()"}
    @{" readPreviousRecord() " Link "readPreviousRecord()"}
    @{" readRecordHeader() " Link "readRecordHeader()"}
    @{" readString() " Link "readString()"}
    @{" setStartOfData() " Link "setStartOfData()"}
    @{" updateIndex() " Link "updateIndex()"}
    @{" updateRecordCounter() " Link "updateRecordCounter()"}
    @{" dataFile() " Link "dataFile()"}
@EndNode

@Node "appendRecord()" "dataFile/appendRecord"

@{b}   NAME@{ub}
       appendRecord() of dataFile --

@{b}   SYNOPSIS@{ub}
       dataFile.appendRecord(PTR TO record)

       dataFile.appendRecord(record)

@{b}   FUNCTION@{ub}
       Appends the data contained in the @{"record" Link "record/record()"} object to the file. The
       current position in the file remains unchanged.

@{b}   SEE ALSO@{ub}
       dataFile, @{"record/writeToFile" Link "record/writeToFile()"}

@EndNode

@Node "end()" "dataFile/end"

@{b}   NAME@{ub}
       end() of dataFile -- Global destructor.

@{b}   SYNOPSIS@{ub}
       dataFile.end()

@{b}   FUNCTION@{ub}
       Disposes the buffer for temporary data, ends the @{"record" Link "record/record()"} and
       calls it's parental objects' end method.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "getCurrentPosition()" "dataFile/getCurrentPosition"

@{b}   NAME@{ub}
       getCurrentPosition() of dataFile -- Get current byte position in file.

@{b}   SYNOPSIS@{ub}
       dataFile.getCurrentPosition()

@{b}   FUNCTION@{ub}
       Does a Seek() on the file and returns the current byte offset from
       the start of the file. The file has to be open.

@{b}   RESULT@{ub}
       LONG -- byte offset from the start of the file.

@{b}   SEE ALSO@{ub}
       dataFile, dos/Seek

@EndNode

@Node "getRecordNumberByPosition()" "dataFile/getRecordNumberByPosition"

@{b}   NAME@{ub}
       getRecordNumberByPosition() of dataFile -- At which @{"record" Link "record/record()"} are we?

@{b}   SYNOPSIS@{ub}
       dataFile.getRecordNumberByPosition()

@{b}   FUNCTION@{ub}
       Gets you the physical number of the @{"record" Link "record/record()"} you are in the file.

@{b}   RESULT@{ub}
       LONG -- Number of @{"record" Link "record/record()"} you are at. Ranges from 0 to
       self.numberOfRecords.

@{b}   NOTES@{ub}
       Not tested.

@{b}   SEE ALSO@{ub}
       dataFile, getStartOfDisk, @{"getCurrentPosition" Link "datafile/getCurrentPosition()"}, @{"record/getSizeOnDisk" Link "record/getSizeOnDisk()"}

@EndNode

@Node "getStartOfData()" "dataFile/getStartOfData"

@{b}   NAME@{ub}
       getStartOfData() of dataFile -- Get bytes offset where the data
           starts.

@{b}   SYNOPSIS@{ub}
       dataFile.getStartOfData()

@{b}   FUNCTION@{ub}
       Get the byte offset in the data file where the actual data starts.

@{b}   RESULT@{ub}
       LONG -- start of data

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "goToEOF()" "dataFile/goToEOF"

@{b}   NAME@{ub}
       goToEOF() of dataFile -- Jumps to the end of the file.

@{b}   SYNOPSIS@{ub}
       dataFile.goToEOF()

@{b}   FUNCTION@{ub}
       Jumps to the end of the file. This should be the position of the last
       @{"record" Link "record/record()"} plus the record's size if the @{"datafile" Link "definitions/datafile()"} is intact.

@{b}   SEE ALSO@{ub}
       dataFile, dos/Seek

@EndNode

@Node "goToFirstRecord()" "dataFile/goToFirstRecord"

@{b}   NAME@{ub}
       goToFirstRecord() of dataFile -- Go to first @{"record" Link "record/record()"} in file.

@{b}   SYNOPSIS@{ub}
       dataFile.goToFirstRecord(LONG=TRUE)

       dataFile.goToFirstRecord(byIndex)

@{b}   FUNCTION@{ub}
       The current position in the file is changed to point at the first
       @{"record" Link "record/record()"} of data. This can be either the 'physical' first @{"record" Link "record/record()"}
       (the one that is first in the file) or the 'logical' first @{"record" Link "record/record()"}
       (the first @{"record" Link "record/record()"} in the index).

@{b}   INPUTS@{ub}
       byIndex:LONG -- Get there by the @{"index" Link "definitions/index()"} or not.

@{b}   NOTES@{ub}
       Currently only the @{"index" Link "definitions/index()"} way is provided.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "goToLastRecord()" "dataFile/goToLastRecord"

@{b}   NAME@{ub}
       goToLastRecord() of dataFile -- Go to the last @{"record" Link "record/record()"}.

@{b}   SYNOPSIS@{ub}
       dataFile.goToLastRecord()

@{b}   FUNCTION@{ub}
       Changes the file position to point at the last @{"record" Link "record/record()"}.

@{b}   RESULT@{ub}
       LONG -- self.recordCount

@{b}   SEE ALSO@{ub}
       dataFile, @{"goToRecord" Link "datafile/goToRecord()"}

@EndNode

@Node "goToRecord()" "dataFile/goToRecord"

@{b}   NAME@{ub}
       goToRecord() of dataFile -- Go to any @{"record" Link "record/record()"}.

@{b}   SYNOPSIS@{ub}
       dataFile.goToRecord(LONG, LONG=TRUE)

       dataFile.goToRecord(recordNumber, byIndex)

@{b}   FUNCTION@{ub}
       Changes the position in the file to point at a certain @{"record" Link "record/record()"}.
       This can be done by @{"index" Link "definitions/index()"}, which is default, or physical.

       For example, take this record:

           file size
           file name
           date

       Suppose you have entered three records in the following order:

           file size 3000
           file name bla.text
           date      Today

           file size 20000
           file name foo.text
           date      Yesterday

           file size 42
           file name bar.text
           date      Yesterday

       The records are indexed by the file size @{"field" Link "field/field()"}. On disk we have this
       order:

         3000 bla.text Today 20000 foo.text Yesterday 42 bar.text Yesterday


       The @{"index" Link "definitions/index()"} gives us a logical view to the file which looks like this:

         42 bar.text Yesterday 3000 bla.text Today 20000 foo.text Yesterday


       goToRecord(1,FALSE) will point at the @{"record" Link "record/record()"} that describes the file
       bla.text, goToRecord(1,TRUE), however, points at bar.text. Note that
       you can omit the second argument, you will the go everywhere by the
       @{"index" Link "definitions/index()"}. This second argument can be omitted with all xxxRecord()
       methods.

@{b}   INPUTS@{ub}
       recordNumber:LONG -- Where you want to go. Can be larger than the
           number of records in the file, it is set to the highest possible
           value if this is the case. If <0 it is set to 0.

       byIndex:LONG -- Go there by @{"index" Link "definitions/index()"} or not. Defaults to TRUE.

@{b}   RESULT@{ub}
       The number of the @{"record" Link "record/record()"} we went to. May be adjusted (see input).

@{b}   SEE ALSO@{ub}
       dataFile, @{"readNextRecord" Link "datafile/readNextRecord()"}, @{"readPreviousRecord" Link "datafile/readPreviousRecord()"}, @{"goToFirstRecord" Link "datafile/goToFirstRecord()"},
       @{"getStartOfData" Link "datafile/getStartOfData()"}, @{"record/getSizeOnDisk" Link "record/getSizeOnDisk()"}

@EndNode

@Node "init()" "dataFile/init"

@{b}   NAME@{ub}
       init() of dataFile -- Initialization of the object.

@{b}   SYNOPSIS@{ub}
       dataFile.init()

@{b}   FUNCTION@{ub}
       Makes the object ready-to-use. It news the @{"record" Link "record/record()"} and @{"index" Link "definitions/index()"} object
       with the "dfil" tag and allocates the buffer for temporary data.

@{b}   SEE ALSO@{ub}
       dataFile, @{"record/record" Link "record/record()"}, @{"index/index" Link "definitions/index()"}

@EndNode

@Node "read()" "dataFile/read"

@{b}   NAME@{ub}
       read() of dataFile -- Read from file.

@{b}   SYNOPSIS@{ub}
       dataFile.read(LONG=1)

       dataFile.read(number)

@{b}   FUNCTION@{ub}
       Reads a number of bytes from the file. The file has to be open.

@{b}   INPUTS@{ub}
       number:LONG -- How many bytes to read in. Defaults to 1.

@{b}   RESULT@{ub}
       PTR TO LONG -- the buffer the bytes were written to.

@{b}   NOTES@{ub}
       Doesn't append but overwrite the data in the buffer.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "readCurrentRecord()" "dataFile/readCurrentRecord"

@{b}   NAME@{ub}
       readCurrentRecord() of dataFile -- Read current @{"record" Link "record/record()"} from file.

@{b}   SYNOPSIS@{ub}
       dataFile.readCurrentRecord(LONG=TRUE)

       dataFile.readCurrentRecord(byIndex)

@{b}   FUNCTION@{ub}
       Reads in a @{"record" Link "record/record()"} from the current position in the file.

@{b}   INPUTS@{ub}
       byIndex:LONG -- TRUE if the @{"index" Link "definitions/index()"} should be used. Defaults to TRUE.
           Unused by now, may vanish.

@{b}   SEE ALSO@{ub}
       dataFile, @{"record/readFromFile" Link "record/readFromFile()"}

@EndNode

@Node "readNextRecord()" "dataFile/readNextRecord"

@{b}   NAME@{ub}
       readNextRecord() of dataFile -- Read the next @{"record" Link "record/record()"} from the file.

@{b}   SYNOPSIS@{ub}
       dataFile.readNextRecord(LONG=TRUE)

       dataFile.readNextRecord(byIndex)

@{b}   FUNCTION@{ub}
       Reads the next @{"record" Link "record/record()"} from the file. This is done either 'physical'
       or 'logical' (on-disk order or @{"index" Link "definitions/index()"} order). Returns immediately if
       we are at the last @{"record" Link "record/record()"}.

@{b}   INPUTS@{ub}
       byIndex:LONG -- TRUE if the @{"index" Link "definitions/index()"} should be used. Defaults to TRUE.

@{b}   RESULT@{ub}
       LONG -- self.recordCount

@{b}   SEE ALSO@{ub}
       dataFile, @{"goToRecord" Link "datafile/goToRecord()"}, @{"index/index" Link "definitions/index()"}

@EndNode

@Node "readPreviousRecord()" "dataFile/readPreviousRecord"

@{b}   NAME@{ub}
       readPreviousRecord() of dataFile -- Read previous @{"record" Link "record/record()"} from file.

@{b}   SYNOPSIS@{ub}
       dataFile.readPreviousRecord(LONG=TRUE)

       dataFile.readPreviousRecord(byIndex)

@{b}   FUNCTION@{ub}

       Read the previous @{"record" Link "record/record()"} from the file. This is done either 'physical'
       or 'logical' (on-disk order or @{"index" Link "definitions/index()"} order). Returns immediately when
       we are at @{"record" Link "record/record()"} 0.

@{b}   INPUTS@{ub}
       byIndex:LONG -- TRUE if the @{"index" Link "definitions/index()"} should be used. Defaults to TRUE.

@{b}   RESULT@{ub}
       LONG -- self.recordCount

@{b}   SEE ALSO@{ub}
       dataFile, @{"goToRecord" Link "datafile/goToRecord()"}

@EndNode

@Node "readRecordHeader()" "dataFile/readRecordHeader"
@{b}   NAME@{ub}
       readRecordHeader() of dataFile -- Read in the @{"record" Link "record/record()"} header.

@{b}   SYNOPSIS@{ub}
       dataFile.readRecordHeader()

@{b}   FUNCTION@{ub}
       Reads the @{"record" Link "record/record()"} header from the data file. The @{"record" Link "record/record()"} header is
       assumed to be at the current position in the file so make sure
       you've done a Seek(datafile.handle,0,OFFSET_BEGINNING) before
       calling it.

       After calling this method the @{"record" Link "record/record()"} definitions are valid, the
       number of records in the file are known, the @{"record" Link "record/record()"} name is known,
       the number of fields is valid and the start of the actual data can
       be read from the according attribute. In other words, the @{"record" Link "record/record()"}
       is ready.

@{b}   NOTES@{ub}
       Here's what the @{"record" Link "record/record()"} header currently looks like:

       00 - 03                 DFIL indicator
       04                      version byte
       05 up to 08 (including) number of fields the @{"record" Link "record/record()"} consists of
       09 up to 0byte          name of the @{"record" Link "record/record()"} (currently unused)
       after that              @{"field" Link "field/field()"} definitions
       8 bytes                 number of records in the file

       By now all numbers in the file are strings that can be turned to
       numbers using Val(). This may change, don't rely on that.

       Uses dos.library's Seek() instead of parental object's method.

@{b}   SEE ALSO@{ub}
       dataFile, @{"setStartOfData" Link "datafile/setStartOfData()"}, @{"record/readFieldDefinitions" Link "record/readFieldDefinitions()"}

@EndNode

@Node "readString()" "dataFile/readString"

@{b}   NAME@{ub}
       readString() of dataFile -- Read 0terminated @{"string" Link "reqtools/string()"} from file.

@{b}   SYNOPSIS@{ub}
       dataFile.readString(LONG=-1)

       dataFile.readString(number)

@{b}   FUNCTION@{ub}
       Reads in @{"string" Link "reqtools/string()"} of characters that is terminated by a 0byte.
       The @{"string" Link "reqtools/string()"} can be found in the buffer for temporary data.

@{b}   INPUTS@{ub}
       number:LONG -- Maximum number of bytes to read.

@{b}   RESULT@{ub}
       PTR TO CHAR -- buffer the bytes were written to.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "setStartOfData()" "dataFile/setStartOfData"

@{b}   NAME@{ub}
       setStartOfData() of dataFile -- Set attribute to usable value.

@{b}   SYNOPSIS@{ub}
       dataFile.setStartOfData(LONG)

       dataFile.setStartOfData(number)

@{b}   FUNCTION@{ub}
       Sets the according attribute.

@{b}   INPUTS@{ub}
       number:LONG -- Number to set the attribute to.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "updateIndex()" "dataFile/updateIndex"

@{b}   NAME@{ub}
       updateIndex() of dataFile -- Add @{"record" Link "record/record()"} to @{"index" Link "definitions/index()"}.

@{b}   SYNOPSIS@{ub}
       dataFile.updateIndex(PTR TO record)

       dataFile.updateIndex(record)

@{b}   FUNCTION@{ub}
       When accessing records by @{"index" Link "definitions/index()"} those have to be in the @{"index" Link "definitions/index()"}.
       Add a @{"record" Link "record/record()"} with a call of this method to the @{"index" Link "definitions/index()"}. Otherwise
       they won't appear in the @{"index" Link "definitions/index()"}.

@{b}   INPUTS@{ub}
       record:PTR TO @{"record" Link "record/record()"} -- Record to add. Usually self.record.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "updateRecordCounter()" "dataFile/updateRecordCounter"

@{b}   NAME@{ub}
       updateRecordCounter() of dataFile -- Update the @{"record" Link "record/record()"} counter on
           disk.

@{b}   SYNOPSIS@{ub}
       dataFile.updateRecordCounter()

@{b}   FUNCTION@{ub}
       Sets the value in the file to the one that can be found in the
       according attribute. The number is written as a @{"string" Link "reqtools/string()"} of
       characters that can be Val()d. The current position in the file
       remains unchanged.

@{b}   SEE ALSO@{ub}
       dataFile

@EndNode

@Node "dataFile()" "file/dataFile"

@{b}   NAME@{ub}
       dataFile() of file -- basic database file

@{b}   PURPOSE@{ub}
       This object provides the means to handle indexed databases.
       A datafile consists of a description of the contained records
       at the start of the file, called the @{"record" Link "record/record()"} header, and the @{"record" Link "record/record()"}
       data.

       The @{"record" Link "record/record()"} header holds the description of the fields a
       @{"record" Link "record/record()"} consists of. Each @{"field" Link "field/field()"} description holds at least the
       field's name, it's length and it's type. There are a number
       of @{"field" Link "field/field()"} types, e.g. @{"string" Link "reqtools/string()"}, integer, float and date. Refer
       to the according autodoc for more information.

       After the @{"record" Link "record/record()"} header the actual data can by found.

       The @{"index" Link "definitions/index()"} can be found in a second file.

@{b}   ATTRIBUTES@{ub}
       buffer:PTR TO CHAR -- A place where the methods store temporary
           data.

       record:PTR TO @{"record" Link "record/record()"} -- The @{"record" Link "record/record()"} object. It is built when the
           @{"record" Link "record/record()"} header is being read in.

       numberOfRecords:LONG -- How many records there are in the file.
           Updated automatically when you write to the file via the
           provided methods.

       startOfData :LONG -- Byte offset. By now this is right after
           the @{"record" Link "record/record()"} header, this may change.

       recordCount :LONG -- Which @{"record" Link "record/record()"} we are at. This can be either
           the actual position 'on disk' or the position in the @{"index" Link "definitions/index()"}.

       index:PTR TO @{"recordIndex" Link "index/recordIndex()"} -- The @{"index" Link "definitions/index()"} object. Built automatically
           when the @{"index" Link "definitions/index()"} is being read in.

       indexCount :LONG -- Used by @{"index" Link "definitions/index()"} methods.

       version:CHAR -- The version of the @{"record" Link "record/record()"} header. The look of the
           @{"record" Link "record/record()"} header in version 3 may not be the same as it is now,
           even the @{"field" Link "field/field()"} specifications may vary. By checking this
           attribute the code in @{"readRecordHeader()" Link "readRecordHeader()"} can be adapted to fit
           the @{"new" Link "resource/new()"} design. Other methods, be it of recor, @{"field" Link "field/field()"}, @{"index" Link "definitions/index()"}
           or associated objects should not work with this attribute.
           The attribute may be PRIVATE in the future.

@{b}   NOTES@{ub}
       Uses dos.library's buffered file i/o functions instead of the
       parental object's methods.

@{b}   SEE ALSO@{ub}
       file

@EndNode

