@database "file"
@master "Ram Disk:T/docs/file.doc"

@Node Main "file.doc"
    @{" file() " Link "file()"}
    @{" --background-- " Link "--background--"}
    @{" appendBytes() " Link "appendBytes()"}
    @{" close() " Link "close()"}
    @{" end() " Link "end()"}
    @{" exists() " Link "exists()"}
    @{" freeContents() " Link "freeContents()"}
    @{" getDateString() " Link "getDateString()"}
    @{" getProtectionFlags() " Link "getProtectionFlags()"}
    @{" getSize() " Link "getSize()"}
    @{" hasBeenOpenedBefore() " Link "hasBeenOpenedBefore()"}
    @{" isClosed() " Link "isClosed()"}
    @{" isOpen() " Link "isOpen()"}
    @{" open() " Link "open()"}
    @{" select() " Link "select()"}
    @{" suck() " Link "suck()"}
    @{" file() " Link "file()"}
@EndNode

@Node "file()" "file"

@{b}   NAME@{ub}
       getDate() of file -- Get last modification date of a file.

@{b}   SYNOPSIS@{ub}
       file.getDate(LONG=TRUE, PTR TO CHAR=NIL:PTR TO CHAR)

       file.getDate(convert, name)

@{b}   FUNCTION@{ub}
       Get the date of the last modification of a file. If a name is
       provided the current file is closed if open. If no name is
       provided you get the date stamp of the current file.

       The date stamp structure can be automatically converted to a
       human readable @{"string" Link "reqtools/string()"} by providing TRUE for the convert parameter.

@{b}   INPUTS@{ub}
       convert:LONG -- Convert date stamp to @{"string" Link "reqtools/string()"}.


       name:PTR TO CHAR -- name of file to get the stamp of. If NIL the
           date stamp of the current file is returned.


@{b}   RESULT@{ub}
       Date stamp entry of the file info block structure from dos or
       a @{"string" Link "reqtools/string()"} which contains that date in localized form.

@{b}   EXAMPLE@{ub}

@{b}   CREATION@{ub}

@{b}   HISTORY@{ub}

@{b}   NOTES@{ub}

@{b}   SEE ALSO@{ub}
       file, @{"open()" Link "open()"}, @{"close()" Link "close()"}

@EndNode

@Node "--background--" "file/--background--"

@{b}   PURPOSE@{ub}
       This is the first draft of the file module. The file object
       provides the means to handle any kind of file.

       Future implementations may include automatic file recognition,
       buffered input/output (the stream object needed for this is being
       developed) and convertion between different file formats. Since
       the latter is somewhat more 'high-level' the inheriting objects may

       provided methods for that purpose.
       Note that file recognition is already available through the
       recognize procedure in oomodules/file/.

@{b}   CREATION@{ub}
       January 29 1995 Gregor Goldbach

@{b}   HISTORY@{ub}
       February 18 1995 Gregor Goldbach
         Added attributes fib and contents. The first contains the
         fileinfoblock which is filled by ExamineFH(), the second
         contains the file read in by method @{"suck()" Link "suck()"}.

         Added ExamineFH() to method @{"open()" Link "open()"}, it fills the fib attribute
         at the file's opening.

         Added method @{"suck()" Link "suck()"}, it reads the whole file into memory.


       September 23 1995 Gregor Goldbach
         Made it fit into the oomodules/ hierarchy, i.e. it inherits from
         object.

         Added select with arguments "open" and "suck".

         Added @{"getSize()" Link "getSize()"}

       September 25 1995 Gregor Goldbach
         Added isopen(), @{"isClosed()" Link "isClosed()"} and @{"hasBeenOpenedBefore()" Link "hasBeenOpenedBefore()"}.

       October 1 1995 Gregor Goldbach
         Looked for autodocs and found it, so now there is at last a
         documentation. Started documenting things for the next E
         distribution.

       October 2 1995 Gregor Goldbach
         Added @{"getProtectionFlags()" Link "getProtectionFlags()"}, getDate(), @{"getDateString()" Link "getDateString()"} and
         @{"freeContents()" Link "freeContents()"}

@EndNode

@Node "appendBytes()" "file/appendBytes"

@{b}   NAME@{ub}
       appendBytes() of file -- Append bytes to the file.

@{b}   SYNOPSIS@{ub}
       file.appendBytes(PTR TO CHAR=NIL, LONG=0)

       file.appendBytes(string, number)

@{b}   FUNCTION@{ub}
       Append a number of bytes to the file. The status of the file
       has to be at MODE_READWRITE.

@{b}   INPUTS@{ub}
       string:PTR TO CHAR -- Characters to write.

       number:LONG -- Number of characters to write. If NIL, it will be
           found out by calling a StrLen() on the @{"string" Link "reqtools/string()"} input.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "close()" "file/close"

@{b}   NAME@{ub}
       close() of file -- Close an open file.

@{b}   SYNOPSIS@{ub}
       file.close()

@{b}   FUNCTION@{ub}
       Closes a file if it is open, otherwise nothing happens.

@{b}   EXAMPLE@{ub}
       file.close()

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "end()" "file/end"

@{b}   NAME@{ub}
       end() of file -- Free resources used by the object.

@{b}   SYNOPSIS@{ub}
       file.end()

@{b}   FUNCTION@{ub}
       Frees all allocated resources. As with all end() procedures,
       it is called automatically when using END. If the file is still
       opened it is closed and the memory allocated by @{"suck()" Link "suck()"} will be
       freed.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "exists()" "file/exists"

@{b}   NAME@{ub}
       exists() of file -- Test existence of a file.

@{b}   SYNOPSIS@{ub}
       file.exists(PTR TO CHAR)

       file.exists(name)

@{b}   FUNCTION@{ub}
       Test if a file exists.

@{b}   INPUTS@{ub}
       name:LONG -- The file's name.

@{b}   RESULT@{ub}
       TRUE is the file exists, FALSE otherwise.

@{b}   EXAMPLE@{ub}
       existence := file.exists('RAM:GuruChair')

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "freeContents()" "file/freeContents"

@{b}   NAME@{ub}
       freeContents() of file -- Free memory allocated by @{"suck()" Link "suck()"}.

@{b}   SYNOPSIS@{ub}
       file.freeContents()

@{b}   FUNCTION@{ub}
       Frees the memory allocated for the file's contents. May be safely
       called more than once.

@{b}   NOTES@{ub}
       It is not necessary to call this function since it's called
       automatically when ENDing the object. You may call it, however, if
       you are using the same object for several files.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "getDateString()" "file/getDateString"

@{b}   NAME@{ub}
       getDateString() of file -- Get date @{"string" Link "reqtools/string()"} in readable form.

@{b}   SYNOPSIS@{ub}
       file.getDateString(PTR TO datestamp=NIL:PTR TO datestamp)

       file.getDateString(datestamp)

@{b}   FUNCTION@{ub}
       Returns a @{"string" Link "reqtools/string()"} which contains the datestamp provided in a human
       readable form. The @{"string" Link "reqtools/string()"} is localized.

@{b}   INPUTS@{ub}
       datestamp:PTR TO datestamp --  The stamp to get the date from.
           If NIL the current time is returned.

@{b}   RESULT@{ub}
       The date in humand readable form or NIL if an error occurred.

@{b}   NOTES@{ub}
       Only usable in this module. Will be moved to another module,
       maybe Date or something like that.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "getProtectionFlags()" "file/getProtectionFlags"

@{b}   NAME@{ub}
       getProtectionFlags() -- Get the protection flags of a file

@{b}   SYNOPSIS@{ub}
       file.getProtectionFlags(PTR TO CHAR)

       file.getProtectionFlags(name=NIL)

@{b}   FUNCTION@{ub}
       Get the protection flags of a file. If a name is provided the current
       file is closed if open. If no name is provided you get the flags of
       the current file.

@{b}   INPUTS@{ub}
       name:PTR TO CHAR -- name of file to get the flags of. If NIL the
           flags of the current file are returned.

@{b}   RESULT@{ub}
       Protection flag entry of the file info block structure from dos.

@{b}   SEE ALSO@{ub}
       @{"open()" Link "open()"}, @{"close()" Link "close()"}
@EndNode

@Node "getSize()" "file/getSize"

@{b}   NAME@{ub}
       getSize() of file -- Get the size of the file in bytes.

@{b}   SYNOPSIS@{ub}
       file.getSize()

@{b}   FUNCTION@{ub}
       Gets the size of the file in bytes.

@{b}   RESULT@{ub}
       Number of bytes or 0 if the file is not or has not been open.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "hasBeenOpenedBefore()" "file/hasBeenOpenedBefore"

@{b}   NAME@{ub}
       hasBeenOpenedBefore() -- test if a file was already open.

@{b}   SYNOPSIS@{ub}
       file.hasBeenOpenedBefore()

@{b}   FUNCTION@{ub}
       Test if the file has been opened before. This function does NOT
       test if the file is open right now or if it is closed.

@{b}   RESULT@{ub}
       TRUE if the file was opened before, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       @{"isOpen()" Link "isOpen()"}, @{"isClosed()" Link "isClosed()"}

@EndNode

@Node "isClosed()" "file/isClosed"

@{b}   NAME@{ub}
       isClosed() -- Test if a file is closed.

@{b}   SYNOPSIS@{ub}
       file.isClosed()

@{b}   FUNCTION@{ub}
       Being the counterpart of @{"isOpen()" Link "isOpen()"} this function test if a file
       is closed.

@{b}   RESULT@{ub}
       TRUE if the file is closed, FALSE otherwise.

@EndNode

@Node "isOpen()" "file/isOpen"

@{b}   NAME@{ub}
       isOpen() of file -- test if the file is open.

@{b}   SYNOPSIS@{ub}
       file.isOpen()

@{b}   FUNCTION@{ub}
       Test if the file represented by this object is open.

@{b}   RESULT@{ub}
       TRUE if the file is open, FALSE otherwise.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "open()" "file/open"

@{b}   NAME@{ub}
       open() of file -- Open a file.

@{b}   SYNOPSIS@{ub}
       file.open(PTR TO CAHR, LONG=MODE_OLDFILE)

       file.open(name, mode)

@{b}   FUNCTION@{ub}

@{b}   INPUTS@{ub}
       name:PTR TO CHAR -- Name of the file to open.

       mode:LONG -- The usual dos.library's open modes.

@{b}   EXAMPLE@{ub}
       file.open('S:Startup-sequence', MODE_OLDFILE)

@{b}   NOTES@{ub}
       Throws the exception "file" if the file could not be opened.
       The exceptioninfo is the address of the @{"string" Link "reqtools/string()"} 'Unable to open
       file.', it is 0-terminated.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "select()" "file/select"

@{b}   NAME@{ub}
       select() of file -- Selection of action upon initialization.

@{b}   SYNOPSIS@{ub}
       file.select(LONG, LONG)

       file.select(opts, i)

@{b}   FUNCTION@{ub}
       See object/select().

       These items are recognized:
         "open" -- Next item is name of file, that file is opened.

         "suck" -- Next item is name of file, a @{"suck()" Link "suck()"} will be performed
          upon it.

@{b}   INPUTS@{ub}
       opts:LONG -- Optionlist.

       i:LONG -- Index of optionlist.

@{b}   SEE ALSO@{ub}
       file, object, @{"open()" Link "open()"}, @{"suck()" Link "suck()"}

@EndNode

@Node "suck()" "file/suck"

@{b}   NAME@{ub}
       suck() of file -- Read a file into memory.

@{b}   SYNOPSIS@{ub}
       file.suck(PTR TO CHAR=NIL)

       file.suck(name)

@{b}   FUNCTION@{ub}
       Loads a file of the given name into memory. If this object represents
       an already opened file it is closed first, then the @{"new" Link "resource/new()"} file is
       opened.

@{b}   INPUTS@{ub}
       name:PTR TO CHAR -- name of the file to read in.

@{b}   RESULT@{ub}
       TRUE if the file could be read in, FALSE otherwise.

@{b}   EXCEPTIONS@{ub}
       Raises an exception if no filename is provided and no file is open.
       The exception has the number 0, this will change in the future when
       the exception handling is improved.

@{b}   SEE ALSO@{ub}
       file

@EndNode

@Node "file()" "object/file"

@{b}   NAME@{ub}
       file of object -- The basic file object

@{b}   ATTRIBUTES@{ub}
       handle:LONG -- dos.library's file handle.

       type:LONG --  The type of the file. Not used in this module, may be
           used by inheriting objects or future methods. recognize() does
           use it, though.

       status:LONG -- The type of access we want to gain. Usually the modes
           passed to Open(), porting reasons may allow for such constants
           like "read", "write" and "apen".


       fib:fileinfoblock  -- The file info block filled by dos.libary's
           ExamineFH(). By now not used that much but the future will bring
           methods that rely on this one. For now thou may read from this
           attribute if you want to get the time or the like.

       contents:PTR TO CHAR -- Pointer to the memory hunk where the whole
           file lies. @{"suck()" Link "suck()"} sets this.

@{b}   SEE ALSO@{ub}
       object

@EndNode

