@DATABASE "jevr.doc"

@NODE MAIN "jevr.doc"

I, Joseph Edwards Van Riper III, as of this writing, am busy
writing music and developing object technologies for the
public domain community, with the hopes of getting things
going in these areas.  The technology is too good to allow
the industrial sector to abuse.

I had intended to graduate this semester, but I blew it
(wasn't able to finish my project in time).  I hope to
graduate by the end of the summer of '95.

Most of the work in building objects for a system is in the
design, not in the programming; programming should be
relatively simple once the analysis and design is taken care
of.  It is my sincere hope that this meager beginning might
help folks start developing a system that would work with
the Amiga and Amiga E, with elegance and efficiency.

Ultimately, I would like to see object equivalences to the
entire Amiga OS handled by these objects, but I cannot
possibly do this on my own without desiring to charge for
the work <grin>.

In this way, I see this rather daunting project of
developing a system of objects for Amiga E as an excellent
opportunity for the Amiga E Encyclopedia, for as folks code
examples of the OS, that same code can be re-written as
objects applicable to this project.

If Object Technology works as I understand it to work, this
job will never be completed.. only perfected.  As such, I am
concerned that this project be handled with as much
responsibility and care as possible.  Please examine
documents carefully.  Please try to grok Object Technology,
its advantages, methodology issues, and other related
matters as much as possible while you contribute.

We may not be able to resurrect the Amiga from Commodore's
flames, but we can put up a good fight <grin>.

Those of you familiar with Smalltalk may notice some
similarities in what I'm trying to do and the GNU Smalltalk
available for unix systems.  I've taken many of the ideas
and reapplied them.  Because this is not actually Smalltalk,
we have several significant differences in the way we handle
things.  This is normal.

@{" Table Of Contents " Link Table_Of_Contents}

@{" My OT History " Link 1.}
@{" OT Satori " Link 2.}
@ENDNODE

@NODE Table_Of_Contents " Table Of Contents "
MAIN@{" jevr.doc " Link MAIN}
  1.@{" My OT History " Link 1.}
  2.@{" OT Satori " Link 2.}
@ENDNODE

@NODE 1. "My OT History"

I've been trying to gather an understanding of Object
Technology since 1990, when I left the US military (I am
honorably discharged, something I think of as remarkable
considering my distaste for the military).  I bought the
Lattice C++ compilor for $300, only to find Lattice had but
one object with the compilor... 'stream'.  I felt as if I'd
been ripped off.

Now SAS owns Lattice, and no longer freely provides the
technical support they used to provide, something I consider
horrid as the manuals are terribly misleading, and the
compilor will GURU if coaxed none-too-carefully.

Thus I started working with Amiga E.  Amiga E is faster,
handles objects with greater facility than C++, makes
smaller code, and has the greatest bunch of folks using it
that one could ever hope for.  I'll admit that Amiga E has
its shortcomings, but that I have put Amiga E on my 40 meg
harddrive and not SAS's C++ compilor should speak volumes.
My $35 for Amiga E feels better spent than the $300 on SAS's
C++.

I'm now taking Object Technology as a course at
UNC-Asheville.  I'm probably not going to do well in the
course, though, because I can't stand the volumes of
busy-work this instructor loads the students with.  A
three-credit hour course does not require papers written
each week on various readings we do... and my ability to
retain information is not so weak as to necessitate this
kind of work.  Unfortunately, I cannot seem to convince the
instructor to ease up, so I'll probably not do well.

None-the-less, I am learning what I want to learn from the
course.  I figured out fairly early (during my SAS C++
miseries) that the key to making Object Technology work was
not as much in the programming as the organization, but I
hadn't quite figured out the way to approach organizing what
I wanted to do.

So I thought I'd try leaping into the whole mess with my
first fairly significant programming project for the Amiga,
'Quip'.  Some of you may have seen it haunting Aminet... it
lurks as a rather large, hulking entity, and boasts itself
as The Fortune Cookie Program from Hell.  The first version
I wrote was written in C++, although I took advantage of
none of the object features in the language, having been
accustomed to procedural ways of programming.  Thus, C++ was
a failure for me, in terms of learning object technology.
Amiga E suffers from the same problem, frankly.  They are
both hybrid languages, incorporating both Object and
Procedural methodologies.

I realized I wasn't really working with objects, so I
attempted to reprogram the entire thing as a set of objects.
I made the classic OT programming mistake of turning the
main() part into a separate object and thinking "Object
Oriented".  I had done a little more than this, though, but
ultimately I had failed to really grasp it, and I could tell
that my work was still somehow 'weak' in terms of
programming elegance; I couldn't reuse my code very well.

It wasn't long after this that I abandoned programming for
a long time, concentrating on my music studies.  Eventually,
I picked up the GNU C++ compilor, but I had to get rid of
it, since it was taking up too much space on my tiny
harddrive.  Then I stumbled into Amiga E, which proved to be
faster than any compilor I'd run across on any platform.

I was saddened that Amiga E wasn't object oriented (this was
the old 2.?? version).  I still had demands set up for
myself for Quip, so I reprogrammed the entire thing from
scratch (this was at least the second or third time I had
done so), but I had to use procedural ways of doing things
to avoid global variables.  I STILL hadn't really grasped OT
that well.  Considering some of the comments I had made to
Wouter, and that Wouter had had a chance to examine some of
my code before I finished it (in the process of hunting down
errors I perceived in his compilors.. I think the errors
were mostly mine, as usual.. Wouter is the most patient
programmer I have ever stumbled across) I sometimes think I
must have looked like a total dolt as far as Object
Technology is concerned.

I could tell I hadn't quite figured SOMETHING out, but I
didn't really quite grasp it until I picked up 'IBM
Smalltalk; The Language' for my Object Technology course.  I
started reading some of it before the course started, and
suddenly figured out what my basic problem was, and how to
go about creating good objects.

When the course started, everything fell right into place.
I had alread grasped the single most difficult concept this
way of programming threw to me, and I was hungry for more
information.

One might say that this attempt to create a system of
objects for Amiga E and the Amiga is the culmination of
literally years of searching for The Way to program in this
kind of methodology.

@ENDNODE

@NODE 2. "OT Satori"

The trick to working with OT is in the design (as I
mentioned before).  Before writing the first character of
code, one must analyse and design what one is attempting to
do, and with what one must do it.

This is the biggest difference:  'with what one must do it'.

In the past, I had been trying to figure out 'how one must
do it' rather than 'with what one must do it.'  The
difference is staggering.  In fact, one begins to find a
greater ease in programming in an OT fashion than in the
older procedural way... the hard part becomes the analysis
and design.

You find yourself building little objects, and ways for the
little objects to communicate to each other so they might,
in a tiny little community that makes up your program, get a
specific set of tasks done.  Together, they form a kind of
community (or 'system' as the parlance goes).  The focus is
on the data you're trying to play with, and not on the
actual "playing with the data".

I've already uploaded a couple of examples of the Object
Technology approach, by way of showing its benefits (and,
hopefully, how to think about the matter elegantly).  The
best example prior to this starting project that I uploaded
was my most recent set of Quip objects (which are still not
even close to being done <sigh>, since I've been working on
this project and a zillion other things).  I urge you to
examine that code (and this code) to get an idea of what I'm
up to.

@ENDNODE

