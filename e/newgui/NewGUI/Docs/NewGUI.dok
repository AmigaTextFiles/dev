
                        Kurzbeschreibung für NewGUI 1.0
                       -===============================-

                                Stand 28.02.1998


Inhalt:
=======

  1. Vorwort (NewGUI <> EasyGUI)

  2. Prozeduren des NewGUI Moduls

     2.1 newguiA()
     2.2 guiinitA()
     2.3 guimessage()
     2.4 cleangui()
     2.5 ng_setattrsA()

  3. TAGs für guiinitA(), newguiA() und ng_setattrsA()

  4. GUI-Elemente mit Syntax und Beschreibung

  5. PLUGIN-Format und Prozedurenbeschreibung

  6. Fehlermeldungen der Prozeduren

  7. Autor und Adressen

  8. Future


1. Vorwort:
===========

  NewGUI ist eine eigene Entwicklung von THE DARK FRONTIER Softwarentwicklungen
  unter der Leitung von Grundler Mathias. (© 1995-98 THE DARK FRONTIER).
  NewGUI ist KEIN einfacher Abklatsch von EasyGUI (wie es für außenstehende
  wahrscheinlich auf den ersten Blick erscheint!) sondern eine eigen-
  ständige Entwicklung. Nach dem Erscheinen des EasyGUI-Sources (Ende 1997)
  wurden allerdings einige Änderungen vorgenommen um eine gewisse Kompa-
  tibilität zu EasyGUI herzustellen und damit eine breitere Zielgruppe anzu-
  sprechen (Ein Umstieg oder eine Teilweise benutzung von NewGUI ist somit
  sehr leicht!).
  Der Source von EasyGUI diente dabei lediglich als Vorlage zur Änderung
  des Syntax und der Rendering-Engine (welche an den neuen Syntax angepasst
  wurde), es wurden KEINE Teile von EasyGUI kopiert oder übernommen sondern
  alles neu geschrieben und hinzugefügt.
  Es gibt zwar viele Übereinstimmungen, aber gerade das macht NewGUI für viele
  sehr interessant, da man "alte" Oberflächenbeschreibungen sehr einfach
  weiterverwenden kann und man nur einige kleinere Änderungen vornehmen muß.
  Obwohl NewGUI viele Features hat und damit EasyGUI in einigen Disziplinen
  überlegen ist, hat EasyGUI doch noch einige Vorteile, welche absichtlich
  nicht den Weg in NewGUI gefunden haben, hier die größten:
        - NewGUI hat KEINEN AppWindow-Support (alle Programmierer die ich
          kenne oder auch befragt haben benötigten den AppWindowSupport bis
          jetzt nur in einigen Ausnahmesituationen, andere wiederum gar nicht!)
        - Es gibt keine LITE-Version von NewGUI (was ja auch unnötig wäre,
          denn dann wären NewGUI und EasyGUI von den Funktionen her ja
          fast gleich und es würde nur eine unnötige Konkurrenz entstehen!),
          also ist die LITE-Version von EasyGUI besser für kleinere Programme
          geeignet, während NewGUI viele Features für größere Programme be-
          inhaltet (z.B. ARexx-Port, eigenen Screen, mehr GUI-Elemente ect...)


2. Prozeduren des Moduls:
=========================

  2.1 newguiA()
        Ist (grob gesehen) eine Zusammenfassung der Prozeduren guiinitA(),
        guimessage() und cleangui(). Nur wird hier (im Fall, daß das GUI
        nicht auf den Screen passt) AUTOMATISCH ein BackFall auf den topaz-
        Font der Größe 8 (ROM-Font) durchgeführt.
        Parameter:

          ret:=newguiA(taglist,{dataproc})

        Die Tags der Taglist sind unter (3) aufgeführt, {dataproc} ist ein
        Pointer auf eine Prozedur, welche wichtige Daten übergeben bekommt,
        hier die Übergabeparameter:

          dataproc(guihandle,screen)

        Als returncode (ret) wird 0 zurückgegeben, wenn das alle GUIs ge-
        schlossen wurden (z.B. CloseGadget des Main-GUIs) oder die Zahl,
        welche einem Gadget anstelle einer Prozedur übergeben wurde

  2.2 guiinitA()
        Initialisiert ein Gui und öffnet das dazugehörige Fenster, ACHTUNG!
        es werden keine Aktionen vom GIU behandelt, dafür ist die Prozedur
        guiimessage() zuständig!!!
        Aufgerufen wird diese Prozedur so:

          guihandle:=guiinitA(taglist)

        Die Tags der Taglist sind unter (3) aufgeführt.
        Als Rückgabeparameter bekommt mein einen Pointer auf den geöffneten
        guihandle (dieser muß immer bei guimessage angegeben werden, außer
        man benutzt das MultiGUI-Handling und fügt dieses Fenster dem Main-
        gui hinzu, dann kann man (NACH DEM HINZUFÜGEN) diese Variable
        weiterbenutzen (z.B. für das nächste GUI) oder vergessen!

  2.3 guimessage()
        Analysiert die Messages vom GUI und vom ARexx-Port. Das Fenster und
        die Oberfläche wird ggf. gerefreshed und neugezeichnet. 
        Syntax:

          ret:=guimessage(guihandle)

        Als Übergabeparameter (guihandle) muß für das MultiGUI-Handling nur
        der handle (guihandle) des Main-GUIs übergeben werden, ansonsten 
        (Wenn nur 1 Fenster offen ist ect...) muß immer das entsprechende
        guihandle zum Fenster übergeben werden.
        Als Rückgabeparameter (ret) erhält man 0, wenn das GUI geschlossen
        wurde/werden soll oder eine Zahl, welche man einem Gadget anstelle
        einer Prozedur übergeben hat.

  2.4 cleangui()
        Schließt das angegebene Guihandle (im MultiGUI-Fall, darf man eine
        Oberfläche NICHT mit cleangui() schließen sondern muß ng_setattrsA()
        mit den Tags NG_CLOSEGUI benutzen!, nur das Maingui kann/darf mit
        cleangui() geschlossen werden!)
        Syntax:

          cleangui(guihandle,closeall=FALSE)

        guihandle ist ein PTR auf das MainGUI oder ein guihandle eines EIN-
        ZELNEN Fensters (Kein MultiGUI!!!!).
        closeall gibt im MultiGUI-Fall an, daß auch alle Unterguis geschlossen
        werden sollen!!! (closegui=TRUE bedeutet also, daß ALLE guis ge-
        schlossen werden sollen!)

  2.5 ng_setattrsA()
        Mittels dieser Prozedur können die meisten Angaben/Tags des GUIS
        verändert werden, es können aber auch Daten vom GUI geholt werden.
        Als wichtigestes muß IMMER das Mainguihandle angegeben werden,
        (Mittels NG_GUI,        guihandle,...) wird KEIN MultiGUIhandling
        verwendet, wird hier immer das jeweilige guihandle des zugehörigen
        Fensters angegeben!
        Die möglichen Tags sind unter (3) aufgelistet und entsprechend
        gekennzeichnet!

3. TAGS für guiinitA(), newguiA() und ng_setattrsA()
====================================================

        NG_WINDOWTITLE
                Eine Zeichenfolge ('beispieltext') oder ein PTR auf einen
                String der in der Titelzeile des Fensters erscheinen soll

        NG_WINDOWLEFT
                X-Koordinate des Fensters (Relativ zum 0-Punkt des Schirms)

        NG_WINDOWTOP
                Y-Koordinate des Fensters (Relativ zum 0-Punkt des Schirms)

        NG_WINDOWWIDTH
                Vorgegebene Breite des Fensters (wird gegebenenfalls ver-
                größert, wenn die Oberfläche zu groß für die angegebene
                Breite ist!

        NG_WINDOWHEIGHT
                Vorgegebene Höhe des Fensters (wird gegebenenfalls ver-
                größert, wenn die Oberfläche zu groß für die angegebene
                Höhe ist!

        NG_WINDOWMAXWIDTH
                Maximale Breite des Fensters (wird nicht überschritten!)

        NG_WINDOWMAXHEIGHT
                Maximale Höhe des Fensters (wird nicht überschritten!)

        NG_WINDOWTYPE
                Art des Fensters, es sind folgende Typen möglich:
                    - WTYPE_BASIC
                        Das Fenster besitzt nur einen dünnen Rand, ohne
                        Titelzeile und ohne Systemgadgets (Closegadget,
                        Sizegadget ect...)

                    - WTYPE_NOSIZE
                        Komplettes Fenster ohne Sizegadget! (Aber sonst 
                        sind alle Systemgadgets vorhanden!)

                    - WTYPE_COMPLETE
                        Komplettes Fenster (Standart!)

        NG_SCREEN
                        PTR auf einen Screen, dort wird das Fenster der Ober-
                        fläche dann geöffnet!

        NG_CLONESCREEN
                        Clont den Workbench-Screen, durch Angabe von weiteren
                        Tags (NG_SCR_*) können die Parameter beeinflusst
                        werden. Alle Angaben die NICHT explizit angegeben
                        werden (durch die NG_SCR_* Tags) werden vom Workbench-
                        Screen übernommen!

        NG_SCR_WIDTH
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann die Breite des Screens
                        angegeben werden!

        NG_SCR_HEIGHT
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann die Höhe des Screens
                        angegeben werden!

        NG_SCR_DEPTH
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann die Anzahl der Farben
                        (In Bitplanes [2 hoch x] ) des Screens angegeben
                        werden!

        NG_SCR_PENS
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann ein PTR auf die Farben
                        des Screens (PENS) angegeben werden!

        NG_SCR_MODEID
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann die ModeID des Screens
                        angegeben werden! (Mittels eines ScreenMode-
                        Requester ermittelte ID [LONG])

        NG_SCR_TITLE
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann der Text für die Titel-
                        zeile des Screens angegeben werden (Entweder eine
                        Zeichenfolge ['Beispieltitel'] oder ein STRING (PTR)

        NG_SCR_PUBNAME
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Hier kann der Pubscreen-Name des
                        zu öffnenden Screens angegeben werden.

        NG_SCR_TAGS
                        Erweiterte Angabe zum öffnen des Screens mittels
                        NG_CLONESCREEN. Diese Tags werden direkt an 
                        OpenScreenTagList() weitergereicht.

        NG_TEXTATTR
                        Textattr für die Oberfläche (Der Font muß beöffnet
                        sein!!!)
                        Später folgen die Tags NG_FONTNAME und NG_FONTSIZE,
                        damit kann dann ein Name und die Größe eines Fonts
                        angegeben werden, welcher dann von NewGUI automatisch
                        geöffnet und geschlossen wird!

        NG_HIDE
                        Damit versteckt man die Oberfläche (wenn dieses
                        Tag bei ng_setattrsA() angegeben wird) oder man
                        verhindert, daß die Oberfläche gleich beim Aufruf
                        geöffnet wird (bei der Verwendung mit guiinitA() oder
                        newguiA())

        NG_APPEAR
                        Hiermit kann die Oberfläche wieder sichtbar gemacht
                        werden (Parameter für ng_setattrsA())

        NG_MENU
                PTR auf ein GadTools-Konformes Menü (newmenu), welches von 
                diesem GUI benutzt werden soll

        NG_HELPGUIDE
                Name der AmigaGUIDE-Datei welche die Hilfsprozeduren zur Ober-
                fläche enthält. (ACHTUNG! Pfad muß mit angegeben werden!)

        NG_SHOWGUIDE
                Parameter für ng_setattrsA()
                Hiermit kann man eine beliebige Node des Hilfsguides anzeigen
                lassen (wenn als Parameter TRUE übergeben wird, so wird die
                main-Node angezeigt!)

        NG_GUI
                PTR auf die Oberlächenbeschreibung oder die Oberflächenbe-
                schreibung direkt!

        NG_GUIID
                ID für dieses GUI (sollte eine zahl sein!), wird nur für
                ein besseres MultiGUI-Handling benutzt!

        NG_APPENDGUI
                Parameter für ng_setattrsA()
                Fügt das angegebene GUI (muß vorher mit guiinitA() geöffnet
                worden sein!) an ein vorhandenes GUI (normalerweise Main-GUI)
                hinzu!

        NG_REMOVEGUI
                Parameter für ng_setattrsA()
                Entfernt ein GUI, Als Parameter muß die GUI-ID übergeben werden!
                (NG_GUIID,     guiid,)

        NG_REMOVECHILDS
                Parameter für ng_setattrsA()
                Entfernt alle Unter-GUIs (alle GUIs außer dem Maingui werden
                geschlossen und entfernt!)

        NG_DOUBLEGUI
                Dieses GUI kann doppelt geöffnet werden! (Nur nötig, wenn
                MultiGUI-Handling erwünscht ist und dieses Fenster mehrmals
                geöffnet werden kann/sein soll!)

        NG_REFRESHGUI
                Parameter für ng_setattrsA()
                Das angegebene GUI wird neu aufgebaut/gezeichnet (z.B. wenn
                Zahlen/Texte oder Strings ect... verändert worden sind)

        NG_DATA
                Hiermit wird das Datenfeld der Oberfläche übergeben (der
                angegebene Parameter wird den Unterprozeduren übergeben, z.B.
                ein Objekt oder ein PTR ect...)

        NG_GUIVAR
                Wird nur in Verbindung mit ng_setattrsA() und anderen Para-
                metern, z.B. CHANGEGUI ect... benutzt um eine Adresse (KEINE
                ID!!!) eines GUIs zu übergeben, auf welches sie angegebene
                Aktion ausgeführt werden soll!

        NG_ONCLOSE
                PTR auf eine Prozedur, welche ausgeführt wird, wenn bei dem
                angegebenen GUI das CloseGadget betätigt wird. Bei dieser
                Prozedur ist es WICHTIG einen Wert zurückzugeben, der angibt,
                ob dieses GUI wirklich geschlossen werden soll, folgende
                Returnwerte sind möglich:
                        -2      Das angebene GUI soll geschlossen werden!
                        -1      Keine Reaktion, alle GUIS bleiben offen!
                         0      Alle GUIS sollen geschlossen werden (Auch das
                                Main-GUI!!!)

        NG_ONTICK
                PTR auf eine Prozedur, die bei jedem INTUITICK ausgeführt wird

        NG_ONHIDE
                PTR auf eine Prozedur, welche ausgeführt wird, wenn das GUI
                versteckt wird.

        NG_ONAPPEAR
                PTR auf eine Prozedur, welche ausgeführt wird, wenn das GUI
                wieder erscheinen soll.

        NG_REXXPROC
                PTR auf eine Prozedur, welche die ARexx-Messages verarbeitet,
                Diese Prozedur wird mit folgenden Parametern aufgerufen:
                        quit,retcode,rplystr:=rexxproc(str,mes)
                quit    =  Programm beenden (wenn quit=TRUE)
                retcode =  Returncode
                rplystr =  String der zurückgegeben wird

                Näheres ist in der Dokumentation des AFC/Rexxer zu finden!

        NG_REXXNAME
                Name des ARexx-Ports

        NG_SENDREXX
                Parameter für ng_setattrsA()
                Schickt einen String an einen ARexx-Port

        NG_RX_RETURNCODE
                Parameter für ng_setattrsA()
                Holt den Returncode den ein Skript/Programm an uns geschickt
                hat und liefert diesen zurück.

        NG_RX_RESULT
                Parameter für ng_setattrsA()
                Holt einen String ect.. ab, welcher von einem anderen
                Programm an uns gesendet wurde

        NG_BFPATTERN
                Pattern zum füllen des Fensterhintergrundes (siehe graphics/
                SetAfPt() für nähere Informationen), bewährt hat sich die
                Angabe von [$AAAA,$5555]:INT, was ein Kariertes Muster erzeugt.

        NG_BFEXP
                Exponent für den Pattern (1,2...) siehe graphics/SetAfPt(),
                für obiges Muster ist der Exponent 1!

        NG_BFBACKPEN
                Nummer des Stiftes, welcher die Hintergrundfarbe zeichnen soll

        NG_BFFRONTPEN
                Nummer des Stiftes, welcher die Vordergrundfarbe zeichnen soll

        NG_PATTERNEXP
                Exponent für die Füllmuster (siehe graphics/SetAfPt())

        NG_PATTERN1
                Pattern für das Oberflächenelement FILLGROUP1, siehe
                NG_BFPATTERN und/oder graphics/SetAfPt()

        NG_P1FRONTPEN
                Nummer des Stiftes, welcher die Vordergrundfarbe zeichnen soll

        NG_P1BACKPEN
                Nummer des Stiftes, welcher die Hintergrundfarbe zeichnen soll

        NG_PATTERN2
                Siehe NG_PATTERN1

        NG_P2FRONTPEN
                Siehe NG_P1FONTPEN

        NG_P2BACKPEN
                Siehe NG_P1BACKPEN

        NG_PATTERN3
                Siehe NG_PATTERN1

        NG_P3FRONTPEN
                Siehe NG_P1FONTPEN

        NG_P3BACKPEN
                Siehe NG_P1BACKPEN

        NG_PATTERN4
                Siehe NG_PATTERN1

        NG_P4FRONTPEN
                Siehe NG_P1FONTPEN

        NG_P4BACKPEN
                Siehe NG_P1BACKPEN

        NG_BITMAPHEIGHT
                Höhe der Bitmap die zum Füllen benutzt werden soll

        NG_BITMAPWIDTH
                Breite der Bitmap die zum Füllen benutzt werdne soll

        NG_BFBITMAP
                BitMap (PTR) zum Füllen des Hintergrundes

        NG_BITMAP1
                Bitmap zum Füllen des GUI-Elementes FILLBITMAP1

        NG_BITMAP2
                Bitmap zum Füllen des GUI-Elementes FILLBITMAP2

        NG_GETSCREEN
                Parameter für ng_setattrsA()
                Holt den PTR zum Screen auf welchem das Main-GUI geöffnet
                ist.

        NG_GETGUI
                Parameter für ng_setattrsA()
                Holt den PTR zu einem guihandle, welches zu der angegebenen
                guiid gehört (Falls dieses geöffnet ist, sont NIL!)
                Nur in verbindung mit NG_GUIID, guiid, möglich!

        NG_NEWGUI
                Parameter für ng_setattrsA()
                Ändert die vorhandene Oberfläche! ACHTUNG! Es wird KEIN
                guihandle übergeben sondern eine Oberflächenbeschreibung!

        NG_CHANGEWINDOW
                Parameter für ng_setattrsA()
                Es sollen Parameter des Fensters geändert werden, folgene
                Tags sind möglich:
                        NG_WINDOWTITLE
                        NG_WINDOWLEFT
                        NG_WINDOWTOP
                        NG_WINDOWWIDTH

        NG_CHANGEMENU
                Parameter für ng_setattrsA()
                Ändert Menü des angegebenen GUIs (guihandle muß angegeben
                werden - mittels NG_CHANGEGUI!!!)

        NG_CHANGEGUI
                Parameter für ng_setattrsA()
                Oberbegriff, wenn irgendwelche Elemente eine GUIS (Menu,
                Window, Oberflächenbeschreibung ect...) geändert werden
                soll, als Parameter muß noch das guihandle angegeben werden!

        NG_CHANGEGAD
                Parameter für ng_setattrsA()
                Ändert ein Gadget, als Anlage muß das GuiElement angegeben
                werden (z.B. MX, CYCLE, STRING, LISTV...)
                Die Adresse (die REELE Adresse, nicht die Gui-Adresse, die
                reele Adresse muß mittels NG_GETGADGET ermittelt werden!)
                muß per NG_GADGET übergeben werden!
                Die neuen Werte müssen per NG_NEWDATA angegeben werden!
                Es sind einige Sonderfälle (z.B. bei Listen oder Scroller)
                möglich, z.B.
                        NG_VISIBLE      = Ändert GTSC_VISIBLE oder
                                                 GTLV_MAKEVISIBLE
                        NG_TOP          = Ändert GTSC_TOP
                        NG_TOTAL        = Ändert GTSC_TOTAL oder
                                                 GTLV_TOTAL
                        NG_SELECTED     = Ändert GTLV_SELECTED
                        NG_LABELS       = Ändert GTLV_LABELS

        NG_CHANGETICKER
                Parameter für ng_setattrsA()
                Ändert die Prozedur die bei jedem INTUITICK aufgerufen wird,
                ist die Anlage TRUE, dann wird die Prozedur nicht mehr auf-
                gerufen

        NG_BLOCKGUI
                Parameter für ng_setattrsA()
                Blockiert das angegebene GUI, alle anderen GUIS (wenn Multi-
                GUI handling aktiv ist) sind und bleiben voll steuerbar!

        NG_UNBLOCKGUI
                Parameter für ng_setattrsA()
                Hebt die Blockierung des Fensters auf!

        NG_GETGADDATA
                Parameter für ng_setattrsA()
                Holt Daten von einem GUI-Element, derzeit sind folgenede
                Typen möglich:
                        STR     = Holt den aktuellen String (buffer)
                        INTEGER = Holt die aktuelle Zahl (Buffer)

        NG_GETGADGET
                Parameter für ng_setattrsA()
                Ermittelt anhand der GUI-Element-Adresse die Reele Adresse
                Eines Gadgets, z.B. zum ändern des Gadgets mittels NG_CHANGEGAD

        NG_GADGET
                Parameter für ng_setattrsA()
                Mittels diesem Parameter kann man die Adresse (die REELE
                Adresse) eine Gadgets angeben (z.B. für NG_CHANGEGAD)

        NG_NEWDATA
                Parameter für ng_setattrsA()
                Neue Daten, hiermit kann man z.B. eine neue Beschreibung für
                NG_CHANGEGUI, TRUE, NG_NEWGUI, ... angeben!

        NG_SELECTED
                Parameter für ng_setattrsA()
                Für das ändern eines Gadgets, Ändert GTLV_SELECTED

        NG_VISIBLE
                Parameter für ng_setattrsA()
                Für das ändern eines Gadgets, Ändert GTSC_VISIBLE oder
                GTLV_MAKEVISIBLE

        NG_LABELS
                Parameter für ng_setattrsA()
                Für das ändern eines Gadgets, Ändert GTLV_LABELS

        NG_TOP
                Parameter für ng_setattrsA()
                Für das ändern eines Gadgets, Ändert GTSC_TOP

        NG_TOTAL
                Parameter für ng_setattrsA()
                Für das ändern eines Gadgets, Ändert GTSC_TOTAL oder
                GTLV_TOTAL

4. GUI-Elemente und Syntax:
===========================

   ROWS         = Alle folgenden Elemente untereinander anordnen

        [ROWS, [...] ]

   EQROWS       = Wie ROWS, nur alle Elemente gleiche Größe!
 
        [EQROWS, [...] ]

   COLS         = Alle folgenden Elemente nebeneinander anordnen

        [COLS, [...] ]

   EQCOLS       = Wie COLS, nur alle Elemente gleiche Größe!

        [EQCOLS, [...] ]

   BEVEL        = Zeichnet einen 3D Rahmen um die folgenden Elemente

        [BEVEL, [...] ]

   BEVELR       = wie BEVEL, nur sieht der Rahmen eingedrückt aus

        [BEVELR, [...] ]

   FILLPATTERNx = Füllt eine Gruppe mit einem Füllmuster (x = 1-4)

        [FILLPATTERNx, [...] ]

   FILLBITMAPx  = Füllt eine Gruppe mit einer Bitmap aus (x = 1 oder 2)

        [FILLBITMAPx, [...] ]

   DBEVEL       = Wie BEVEL nur ein Doppelter Rahmen

        [DBEVEL, [...] ]

   DBEVELR      = Wie BEVELR nur mit einem doppelten Rahmen

        [DBEVELR, [...] ]

   BUTTON       = Ein "einfacher" Knopf

        [BUTTON,{proc},'_Text',*info,*'T',*'helpnode]

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text im Button (_ = Folgendes Zeichen = Hotkey)
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   CHECK        = Ein Schalter (Check-Gadget)

        [CHECK,{proc},'_Text',check,textleft,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text im Gadget (_ = Folgendes Zeichen = Hotkey)
                check      = Ist das gadget angewählt oder nicht (TRUE = aktiv)
                textleft   = Der text soll links vom Gadget stehen
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   INTEGER      = Ein Zahlen-Eingabefeld

        [INTEGER,{proc},'_Text',num,size,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text im Gadget (_ = Folgendes Zeichen = Hotkey)
                num        = PTR auf eine Variable die die Nummer enthält
                             und änderungen aufnehmen soll
                size       = Minimale Größe für das Gadget (muß probiert
                             werden, als relativ passend hat sich 2 oder 3
                             bewährt!)
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   LISTV        = Eine Liste zum zeigen von EXEC-Listen (doppelt verkettet!)

        [LISTV,{proc},'_Text',xsize,ysize,execlist,read,selected,current,
         *info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                num        = PTR auf eine Variable die die Nummer enthält
                             und änderungen aufnehmen soll
                xsize      = Minimale Breite für das Gadget
                ysize      = Minimale Höhe für das Gadget
                execlist   = PTR auf eine INITALISIERTE Execliste (:lh,:ln)
                read       = Wenn read TRUE ist, dann ist das Gadget nur
                             Lesbar, ansonsten kann man auch Einträhe an-
                             wählen
                selected   = 1 = Das angewähle Element zeigen
                             0 = Nicht anzeigen!
                current    = Das Aktuell angewähle Element!
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   MX           = MutalExclude (mehrfach-Schalter)

        [MX,{proc},'_Text',[eliste],textleft,current,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                [eliste]   = Eine Liste (['1','2','3',NIL]), diese List MUß
                             unbedingt mit NIL abgeschlossen werden!!
                textleft   = Der text soll links vom Gadget stehen
                current    = Das Aktuell angewähle Element!
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   CYCLE        = Mehrfach-Auswahl Element (ähnlich Drehschalter)

        [CYCLE,{proc},'_Text',[eliste],current,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                [eliste]   = Eine Liste (['1','2','3',NIL]), diese List MUß
                             unbedingt mit NIL abgeschlossen werden!!
                current    = Das Aktuell angewähle Element!
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   PALETTE      = Farbauswahl-Element

        [PALETTE,{proc},'_Text',depth,sizex,sizey,current,*info,*'T',
        *'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                depth      = Farbanzahl (Tiefe in Bitplanes)
                xsize      = Minimale Breite für das Gadget
                ysize      = Minimale Höhe für das Gadget
                current    = Das Aktuell angewähle Element!
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   SCROLL       = Scroller (Schiebe-wähl-Schalter)

        [SCROLL,{proc},vert,total,top,current,size,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                vert       = wenn TRUE, dann ist das Gadget Vertikal!
                total      = Bis zu diesem Wert "geht" der Scroller
                top        = Aktuelle Obergrenze
                current    = Aktuelle Position
                size       = Minimale Größe für das Gadget
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!


   SLIDE        = Slider (wie Scroller nur mir 2 Pfeiltasten)

        [SLIDE,{proc},'_Text',vert,min,max,current,size,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                vert       = wenn TRUE, dann ist das Gadget Vertikal!
                min        = Unterste Grenze (Von...)
                max        = Oberste Grenze  (...Bis)
                current    = Aktuelle Position
                size       = Minimale Größe für das Gadget
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   STR          = Texteingabe-Element

        [STR,{proc},'_Text',str,max,size,*over,*info,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                '_Text'    = Text über dem Gadget (_ = Hotkey)
                str        = Estring (Anfangsinhalt des Stringgadgets)
                max        = Maximale Stringlänge
                size       = Minimale Größe für das Gadget (muß probiert
                             werden, als relativ passend hat sich 2 oder 3
                             bewährt!)
                over       = Modus, z.B. Einfüge-Modus ändern...
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   TEXT         = Textausgabe-Element

        [TEXT,str,'Text',border,size,*'helpnode']

                str        = String (oder Zeichenkette ('beispiel') der
                             ausgegeben werden soll, diese Variable ist
                             veränderbar!
                'Text'     = Text der links von str steht!
                size       = Minimale Größe für das Gadget (muß probiert
                             werden, als relativ passend hat sich 2 oder 3
                             bewährt!)
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   NUM          = Element zur Zahlenausgabe

        [NUM,num,'Text',border,size,*'helpnode']

                num        = Zahl oder Variable die ausgegeben werden soll,
                             diese Variable ist veränderbar!
                'Text'     = Text der links von str steht!
                size       = Minimale Größe für das Gadget (muß probiert
                             werden, als relativ passend hat sich 2 oder 3
                             bewährt!)
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   SBUTTON      = Wie Button, nur freie Breite

        [SBUTTON,{proc},'_Text',*info,*'T',*'helpnode]

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text im Button (_ = Folgendes Zeichen = Hotkey)
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   PLUGIN       = Plugin (kann auch durch andere Konstanten ersetzt werden!)

        [PLUIGN,{proc},obj,*'T',*'helpnode']

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                obj        = PLUGIN-Objekt (muß entweder vorher initialisiert
                             worden sein, oder wird an dieser Stelle initiali-
                             sitert!!! ACHTUNG! Es darf kein Plugin doppelt
                             benutzt werden, es muß für JEDES Plugin eine
                             eigene Variable benutzt werden, welche immer
                             initialisiert werden muß!)
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   BAR          = Zieht einen 3D-Strich (eingedrückt)

        [BAR],

   BARR         = Wie BAR nur erscheint der Strich herausragend

        [BARR],

   SPACEH       = Platzhalter Horizontal

        [SPACEH],

   SPACE        = Platzhalter (hier kann die Oberfläche gedehnt werden)

        [SPACE],

   SPACEV       = Platzhalter Vertikal

        [SPACEV],

   RBUTTON      = Wie BUTTON, nur freie Höhe!

        [RBUTTON,{proc},'_Text',*info,*'T',*'helpnode]

                *          = Optional!
                proc       = PTR auf eine Prozedur die bei Betätigung
                             ausgeführt werden soll
                '_Text'    = Text im Button (_ = Folgendes Zeichen = Hotkey)
                info       = Information (z.B. PTR auf ein Objekt) die der
                             aufgerufenen Prozedur übergeben werden soll!
                'T'        = HotKey
                'helpnode' = Name der Node in der Hilfsdatei die bei Drücken
                             der HELP-Taste gezeigt werden soll!

   MAXGUI       = PRIVAT! Nicht benutzen, dient nur zum abschließen der Liste!


5. Das PLUGIN-Format und die Beschreibung der Prozeduren:
=========================================================

Das PLUGIN-Format ist für Anwender (Programmierer) fast identisch mit dem von
 EasyGUI, es mussten jedoch einige Veränderungen vorgenommen werden und
 deshalb folgt hier nochmals eine genaue Erklärung des PLUGIN-Formats:

    Änderungen gegenüber dem EasyGUI-PLUGIN-Format:
    -----------------------------------------------
        - Die Prozedur appmessage() wurde nicht implementiert, da ja kein
          AppWindow-Support vorhanden ist
        - Eine neue Prozedur isgtgadget() ist hinzugekommen, welche angibt,
          ob das Plugin ein GadTools-Gadget hat oder andere Aufgaben erledigt
          (z.B. Zeichnen auf den Window-Rastport ect...)

Eine Einfache Portierung von Plugins sollte ohne weiteres möglich sein, es
 müssen lediglich die Prozeduren appmessage() entfernt werden und die Prozedur
 isgtgadget() eventuell auf TRUE gesetzt werden!

Syntax der einzelnen Prozeduren:
--------------------------------

  clear_render(window)
        Kann benutzt werden, um den gerenderten Bereich des Plugins zu leeren
        (füllen ect...) die Koordinaten kann man mittels des self-Operanten
        ermitteln (z.B. self.x, self.xs ect...)

  gadgetlist:=gtrender(gadgetlist,visible,textattr,x,y,xs,ys,window)
        Render-Funktion für GadTools-gadgets, Wichtig ist hier, daß die Gadget-
        liste zurückgegeben wird!!!

  isgt:=isgtgadget()
        Muß auf TRUE gesetzt werden, wenn gtrender benutzt werden soll!!

  isplugmsg:=message_test(intuimsg,window)
        Funktion um zu testen, ob eine Message für unser Plugin war (z.B.
        Gadget-ID prüfen oder koordinaten der Maus mit den Plugin-koordinaten
        vergleichen...)
        HIER DARF NICHT GEZEICHNET ECT... WERDEN! Hier soll nur festgestellt
        werden, ob diese Message für unser Plugin war, der rest wird in 
        message_action() erledigt!
        War die Message für uns, müssen wir TRUE zurückiefern!

  message_action(class,qual,code,window)
        Hier können Aktionen zum Plugin ausgeführt werden (z.B. Ändern des
        Plugin-Rahmens oder Öffnen eine POPUP-Menüs ect...)

  x,y:=min_size(textattr,fontheight)
        Bei dieser Funktion müssen wir die Mindestgröße die unser Plugin
        belegt zurückliefern (x-groesse, ygroesse)

  render(textattr,x,y,xs,ys,window)
        Diese Funktion wird von NewGUI aufgerufen, wenn das Plugin neu ge-
        zeichnet werden soll (z.B. wenn das Fenster in der Größe verändert
        wurde...)

  resize:=will_resize()
        Diese Funktion muss zurückgeben, ob sich unser Plugin in der Größe
        verändern kann, mögliche Werte sind:
                0           = Feste Größe
                RESIZEX     = Breite ist Variabel
                RESIZEY     = Höhe ist Variabel
                RESIZEXANDY = Größe ist voll veränderbar (Höhe und Breite)


6. Fehlermeldungen von NewGUI:
==============================

Die Fehlercodes können mit der Prozedur ng_showerror() ausgewertet werden,
oder in eigene Exception-Handlings eingebaut werden.

   ERR_NG_MENU
        Das Menü konnte nicht angelegt werden oder fehler im Menülayout

   ERR_NG_BIG
        Die Oberfläche ist zu groß für die Screen-Ausmaße (vieleicht
        handelt es sich um einen Designfehler oder um einen zu großen
        Zeichensatz!)

   ERR_NG_VISUAL
        Beim besorgen des Visualinfo des Screens ist ein Fehler unterlaufen

   ERR_NG_WINOPEN
        Das Fenster ließ sich nicht öffnen (vieleicht Speichermangel!)

   ERR_NG_LIB
        Eine benötigte Library ließ sich nicht öffnen!!

   ERR_NG_SCREEN
        Der benötigte Screen ließ sich nicht öffnen, oder LockPubScreen()
        schlug fehl (evtl. nicht genug Speicher oder Workbench NICHT
        offen!)

   ERR_NG_MSGPORT
        Ein Messageport ließ sich nicht anlegen (zu wenig Speicher)

   ERR_NG_CONTEXT
        Die GadToolsBox konnte den Context für die Gadgets nicht anlegen
        (evtl. Speicher nicht ausreichend!)

   ERR_NG_GUI
        Fehler beim berechnen / Öffnen der Oberfläche)

   ERR_NG_SYNTAX
        Syntaxfehler in der Oberflächenbeschreibung (falsche Anordnung
        der Argumente, z.B. [ROWS, {gehtnicht}, 'Falsch', [...]])

   ERR_NG_FEWARGS
        Zu wenig Argumente für das GUI-Element (z.B. [TEXT, 'text',FALSE])

   ERR_NG_PLUGIN
        Das Plugin war NIL! (initialisierung schlug fehl, evtl. zu wenig
        Speicher frei!)

   ERR_NG_CREATEGAD
        Ein Gadget konnte NICHT erzeugt werden (evtl. zu wenig Speicher
        oder Fehler in der GUI-Beschreibung!)

   ERR_NG_END
        Dummy, mittels diesem Element kann man weitere eigene Fehlercodes
        anlegen ohne in Konflikte zu gerate, z.B.:
                ENUM ERR_OWN_MEM=ERR_NG_END,
                     ERR_OWN_???, ...

7. Der Autor und Adressen:
==========================

THE DARK FRONTIER Softwareentwicklungen
z. Hd. Grundler Mathias
Am Hofgraben 2

67378 Zeiskam

Fax  : +49(0)7274-8774

Email: frontier@starbase.inka.de

WWW  : http://www.inka.de/sites/starbase/frontier.html


Danksagungen:
-------------
        Patricia D.             - Die zwar nichts hiervon weiß, aber mich
                                  trotzdem immer bei Laune und Wach hielt :-)
        Wouter van Oortmerssen  - Für AmigaE, ohne diese Sprache wäre NewGUI
                                  nie entstanden
        AFC-Group               - Für das Rexxer - Modul und die Zusammenarbeit
        |tEEdEE| (#strandcafe)  - Für die CD (:-))

        und alle die ich vergessen habe! (sind ja ne ganze Menge :-))


8. Geplantes (Future):
======================

        - Neue Features (z.B. NG_FONTNAME, NG_FONTSIZE...)
        - Evtl. Bugfixes (wenn mir welche gemeldet werden)
        - Optimierungen  (z.B. Berechnungen)
        - Irgendwann eine C/C++ Umsetzung durch die AFC-Group
